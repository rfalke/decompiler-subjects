typedef unsigned char   undefined;

typedef unsigned char    byte;
typedef unsigned char    dwfenc;
typedef unsigned int    dword;
typedef long long    longlong;
typedef int    sdword;
typedef short    sword;
typedef unsigned char    uchar;
typedef unsigned int    uint;
typedef unsigned long    ulong;
typedef unsigned long long    ulonglong;
typedef unsigned char    undefined1;
typedef unsigned short    undefined2;
typedef unsigned int    undefined3;
typedef unsigned int    undefined4;
typedef unsigned long long    undefined5;
typedef unsigned long long    undefined7;
typedef unsigned long long    undefined8;
typedef unsigned short    ushort;
typedef unsigned short    word;
typedef struct eh_frame_hdr eh_frame_hdr, *Peh_frame_hdr;

struct eh_frame_hdr {
    byte eh_frame_hdr_version; // Exception Handler Frame Header Version
    dwfenc eh_frame_pointer_encoding; // Exception Handler Frame Pointer Encoding
    dwfenc eh_frame_desc_entry_count_encoding; // Encoding of # of Exception Handler FDEs
    dwfenc eh_frame_table_encoding; // Exception Handler Table Encoding
};

typedef struct fde_table_entry fde_table_entry, *Pfde_table_entry;

struct fde_table_entry {
    dword initial_loc; // Initial Location
    dword data_loc; // Data location
};

typedef ushort sa_family_t;

typedef struct termios termios, *Ptermios;

typedef uint tcflag_t;

typedef uchar cc_t;

typedef uint speed_t;

struct termios {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;
};

typedef void _IO_lock_t;

typedef struct _IO_marker _IO_marker, *P_IO_marker;

typedef struct _IO_FILE _IO_FILE, *P_IO_FILE;

typedef long __off_t;

typedef longlong __quad_t;

typedef __quad_t __off64_t;

typedef ulong size_t;

struct _IO_FILE {
    int _flags;
    char * _IO_read_ptr;
    char * _IO_read_end;
    char * _IO_read_base;
    char * _IO_write_base;
    char * _IO_write_ptr;
    char * _IO_write_end;
    char * _IO_buf_base;
    char * _IO_buf_end;
    char * _IO_save_base;
    char * _IO_backup_base;
    char * _IO_save_end;
    struct _IO_marker * _markers;
    struct _IO_FILE * _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    ushort _cur_column;
    char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t * _lock;
    __off64_t _offset;
    void * __pad1;
    void * __pad2;
    void * __pad3;
    void * __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[40];
};

struct _IO_marker {
    struct _IO_marker * _next;
    struct _IO_FILE * _sbuf;
    int _pos;
};

typedef struct rlimit64 rlimit64, *Prlimit64;

typedef ulonglong __u_quad_t;

typedef __u_quad_t __rlim64_t;

typedef __rlim64_t rlim64_t;

struct rlimit64 {
    rlim64_t rlim_cur;
    rlim64_t rlim_max;
};

typedef enum __rlimit_resource {
    RLIMIT_CPU=0,
    RLIMIT_FSIZE=1,
    RLIMIT_DATA=2,
    RLIMIT_STACK=3,
    RLIMIT_CORE=4,
    __RLIMIT_RSS=5,
    __RLIMIT_NPROC=6,
    RLIMIT_NOFILE=7,
    __RLIMIT_MEMLOCK=8,
    __RLIMIT_OFILE=8,
    RLIMIT_AS=9,
    __RLIMIT_LOCKS=10,
    __RLIMIT_SIGPENDING=11,
    __RLIMIT_MSGQUEUE=12,
    __RLIMIT_NICE=13,
    __RLIMIT_RTPRIO=14,
    __RLIMIT_NLIMITS=15,
    __RLIM_NLIMITS=16
} __rlimit_resource;

typedef enum __rlimit_resource __rlimit_resource_t;

typedef struct stat64 stat64, *Pstat64;

typedef __u_quad_t __dev_t;

typedef ulong __ino_t;

typedef uint __mode_t;

typedef uint __nlink_t;

typedef uint __uid_t;

typedef uint __gid_t;

typedef long __blksize_t;

typedef __quad_t __blkcnt64_t;

typedef struct timespec timespec, *Ptimespec;

typedef __u_quad_t __ino64_t;

typedef long __time_t;

struct timespec {
    __time_t tv_sec;
    long tv_nsec;
};

struct stat64 {
    __dev_t st_dev;
    uint __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    uint __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef struct utsname utsname, *Putsname;

struct utsname {
    char sysname[65];
    char nodename[65];
    char release[65];
    char version[65];
    char machine[65];
    char domainname[65];
};

typedef struct addrinfo addrinfo, *Paddrinfo;

typedef uint __socklen_t;

typedef __socklen_t socklen_t;

typedef struct sockaddr sockaddr, *Psockaddr;

struct addrinfo {
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    socklen_t ai_addrlen;
    struct sockaddr * ai_addr;
    char * ai_canonname;
    struct addrinfo * ai_next;
};

struct sockaddr {
    sa_family_t sa_family;
    char sa_data[14];
};

typedef struct _IO_FILE FILE;

typedef int __ssize_t;

typedef __ssize_t ssize_t;

typedef int __pid_t;

typedef int __int32_t;

typedef long __suseconds_t;

typedef long __clock_t;

typedef struct passwd passwd, *Ppasswd;

struct passwd {
    char * pw_name;
    char * pw_passwd;
    __uid_t pw_uid;
    __gid_t pw_gid;
    char * pw_gecos;
    char * pw_dir;
    char * pw_shell;
};

typedef struct evp_pkey_ctx_st evp_pkey_ctx_st, *Pevp_pkey_ctx_st;

struct evp_pkey_ctx_st {
};

typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;

typedef int nl_item;

typedef struct dirent64 dirent64, *Pdirent64;

struct dirent64 {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};

typedef struct __dirstream __dirstream, *P__dirstream;

struct __dirstream {
};

typedef struct __dirstream DIR;

typedef struct utimbuf utimbuf, *Putimbuf;

struct utimbuf {
    __time_t actime;
    __time_t modtime;
};

typedef union _union_1031 _union_1031, *P_union_1031;

typedef struct _struct_1032 _struct_1032, *P_struct_1032;

typedef struct _struct_1033 _struct_1033, *P_struct_1033;

typedef struct _struct_1034 _struct_1034, *P_struct_1034;

typedef struct _struct_1035 _struct_1035, *P_struct_1035;

typedef struct _struct_1036 _struct_1036, *P_struct_1036;

typedef struct _struct_1037 _struct_1037, *P_struct_1037;

typedef union sigval sigval, *Psigval;

typedef union sigval sigval_t;

struct _struct_1032 {
    __pid_t si_pid;
    __uid_t si_uid;
};

union sigval {
    int sival_int;
    void * sival_ptr;
};

struct _struct_1033 {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

struct _struct_1035 {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

struct _struct_1037 {
    long si_band;
    int si_fd;
};

struct _struct_1036 {
    void * si_addr;
};

struct _struct_1034 {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

union _union_1031 {
    int _pad[29];
    struct _struct_1032 _kill;
    struct _struct_1033 _timer;
    struct _struct_1034 _rt;
    struct _struct_1035 _sigchld;
    struct _struct_1036 _sigfault;
    struct _struct_1037 _sigpoll;
};

typedef struct siginfo siginfo, *Psiginfo;

struct siginfo {
    int si_signo;
    int si_errno;
    int si_code;
    union _union_1031 _sifields;
};

typedef struct siginfo siginfo_t;

typedef uint VALUE;

typedef uint uLong;

typedef uchar transmem_block_t;


// WARNING! conflicting data type names: /DWARF/size_t - /stddef.h/size_t

typedef char XML_Char;

typedef uint uInt;


// WARNING! conflicting data type names: /DWARF/__time_t - /types.h/__time_t

typedef int action_id_T;

typedef char yysigned_char;

typedef int milliseconds_T;

typedef uint ID;


// WARNING! conflicting data type names: /DWARF/__off_t - /types.h/__off_t

typedef sdword int32_t;

typedef dword uint32_t;

typedef dword uint_least32_t;

typedef uchar uint8_t;

typedef uint hash_value_T;


// WARNING! conflicting data type names: /DWARF/__suseconds_t - /types.h/__suseconds_t

typedef int __fd_mask;

typedef word uint16_t;


// WARNING! conflicting data type names: /DWARF/__clock_t - /types.h/__clock_t

typedef uchar Byte;

typedef dword nls_uint32;


// WARNING! conflicting data type names: /DWARF/__blksize_t - /types.h/__blksize_t

typedef sword int16_t;

typedef int longptr_T;


// WARNING! conflicting data type names: /DWARF/__ino_t - /types.h/__ino_t

typedef struct color_spec color_spec, *Pcolor_spec;

typedef uint32_t color_T;

struct color_spec {
    char * name;
    color_T rgb;
};

typedef struct color_mode_info color_mode_info, *Pcolor_mode_info;

typedef struct rgb rgb, *Prgb;

typedef struct anon_struct_8_2_f9ee7239 anon_struct_8_2_f9ee7239, *Panon_struct_8_2_f9ee7239;

struct anon_struct_8_2_f9ee7239 {
    int bg;
    int fg;
};

struct color_mode_info {
    struct rgb * palette;
    struct anon_struct_8_2_f9ee7239 palette_range[2];
};

struct rgb {
    uchar r;
    uchar g;
    uchar b;
    uchar pad;
};

typedef struct rgb_cache_entry rgb_cache_entry, *Prgb_cache_entry;

struct rgb_cache_entry {
    int color;
    int level;
    color_T rgb;
};

typedef enum palette_range {
    PALETTE_FULL=0,
    PALETTE_HALF=1,
    PALETTE_RANGES=2
} palette_range;

typedef enum color_mode {
    COLOR_MODE_DUMP=-1,
    COLOR_MODE_MONO=0,
    COLOR_MODE_16=1,
    COLOR_MODE_88=2,
    COLOR_MODE_256=3,
    COLOR_MODES=5
} color_mode;

typedef enum color_flags {
    COLOR_DECREASE_LIGHTNESS=1,
    COLOR_ENHANCE_UNDERLINE=2,
    COLOR_INCREASE_CONTRAST=4,
    COLOR_ENSURE_CONTRAST=8,
    COLOR_ENSURE_INVERTED_CONTRAST=16
} color_flags;

typedef struct language language, *Planguage;

struct language {
    uchar * name;
    uchar * iso639;
};

typedef enum listbox_match {
    LISTBOX_MATCH_OK=0,
    LISTBOX_MATCH_NO=1,
    LISTBOX_MATCH_IMPOSSIBLE=2
} listbox_match;

typedef enum listbox_item_type {
    BI_LEAF=0,
    BI_FOLDER=1,
    BI_SEPARATOR=2
} listbox_item_type;

typedef struct listbox_data listbox_data, *Plistbox_data;

typedef struct listbox_ops listbox_ops, *Plistbox_ops;

typedef struct listbox_item listbox_item, *Plistbox_item;

typedef struct terminal terminal, *Pterminal;

typedef struct uri uri, *Puri;

typedef struct listbox_context listbox_context, *Plistbox_context;

typedef struct list_head_elinks list_head_elinks, *Plist_head_elinks;

typedef struct option_elinks option_elinks, *Poption_elinks;

typedef struct terminal_screen terminal_screen, *Pterminal_screen;

typedef struct menu menu, *Pmenu;

typedef enum term_redrawing_state {
    TREDRAW_READY=0,
    TREDRAW_BUSY=1,
    TREDRAW_DELAYED=2
} term_redrawing_state;

typedef enum term_env_type {
    ENV_ANY=-1,
    ENV_CONSOLE=1,
    ENV_XWIN=2,
    ENV_SCREEN=4,
    ENV_OS2VIO=8,
    ENV_BE=16,
    ENV_TWIN=32,
    ENV_WIN32=64
} term_env_type;

typedef struct terminal_interlink terminal_interlink, *Pterminal_interlink;

typedef struct term_event_mouse term_event_mouse, *Pterm_event_mouse;

typedef struct object object, *Pobject;

typedef struct dialog_data dialog_data, *Pdialog_data;

typedef struct widget_data widget_data, *Pwidget_data;

typedef struct listbox_ops_messages listbox_ops_messages, *Plistbox_ops_messages;

typedef enum option_flags {
    OPT_HIDDEN=1,
    OPT_AUTOCREATE=2,
    OPT_MUST_SAVE=4,
    OPT_TOUCHED=8,
    OPT_LISTBOX=16,
    OPT_ALLOC=32,
    OPT_SORT=64,
    OPT_DELETED=128,
    OPT_ALIAS_NEGATE=256
} option_flags;

typedef enum option_type {
    OPT_BOOL=0,
    OPT_INT=1,
    OPT_LONG=2,
    OPT_STRING=3,
    OPT_CODEPAGE=4,
    OPT_LANGUAGE=5,
    OPT_COLOR=6,
    OPT_COMMAND=7,
    OPT_ALIAS=8,
    OPT_TREE=9
} option_type;

typedef union option_value option_value, *Poption_value;

typedef struct session session, *Psession;

typedef int (* change_hook_T)(struct session *, struct option_elinks *, struct option_elinks *);

typedef struct screen_char screen_char, *Pscreen_char;

typedef struct window window, *Pwindow;

typedef struct term_event term_event, *Pterm_event;

typedef struct menu_item menu_item, *Pmenu_item;

typedef struct box box, *Pbox;

typedef struct anon_struct_16_4_ef67fadd_for_utf8 anon_struct_16_4_ef67fadd_for_utf8, *Panon_struct_16_4_ef67fadd_for_utf8;

typedef struct dialog dialog, *Pdialog;

typedef enum widget_handler_status_T {
    EVENT_PROCESSED=0,
    EVENT_NOT_PROCESSED=1
} widget_handler_status_T;

typedef struct memory_list memory_list, *Pmemory_list;

typedef struct widget widget, *Pwidget;

typedef union anon_union_24_3_5d775672_for_info anon_union_24_3_5d775672_for_info, *Panon_union_24_3_5d775672_for_info;

typedef struct ses_history ses_history, *Pses_history;

typedef struct download download, *Pdownload;

typedef enum cache_mode {
    CACHE_MODE_INCREMENT=-1,
    CACHE_MODE_ALWAYS=0,
    CACHE_MODE_NORMAL=1,
    CACHE_MODE_CHECK_IF_MODIFIED=2,
    CACHE_MODE_FORCE_RELOAD=3,
    CACHE_MODE_NEVER=4
} cache_mode;

typedef struct document_view document_view, *Pdocument_view;

typedef struct session_task session_task, *Psession_task;

typedef struct kbdprefix kbdprefix, *Pkbdprefix;

typedef struct timer timer, *Ptimer;

typedef struct timer * timer_id_T;

typedef enum insert_mode {
    INSERT_MODE_LESS=0,
    INSERT_MODE_ON=1,
    INSERT_MODE_OFF=2
} insert_mode;

typedef enum navigate_mode {
    NAVIGATE_LINKWISE=0,
    NAVIGATE_CURSOR_ROUTING=1
} navigate_mode;

typedef struct session_status session_status, *Psession_status;

typedef uint32_t unicode_val_T;

typedef enum window_type {
    WINDOW_NORMAL=0,
    WINDOW_TAB=1
} window_type;

typedef enum term_event_type {
    EVENT_INIT=0,
    EVENT_KBD=1,
    EVENT_MOUSE=2,
    EVENT_REDRAW=3,
    EVENT_RESIZE=4,
    EVENT_ABORT=5
} term_event_type;

typedef union anon_union_12_3_3ebaaa1f_for_info anon_union_12_3_3ebaaa1f_for_info, *Panon_union_12_3_3ebaaa1f_for_info;

typedef enum main_action {
    ACT_MAIN_NONE=0,
    ACT_MAIN_SCRIPTING_FUNCTION=1,
    ACT_MAIN_ABORT_CONNECTION=2,
    ACT_MAIN_ADD_BOOKMARK=3,
    ACT_MAIN_ADD_BOOKMARK_LINK=4,
    ACT_MAIN_ADD_BOOKMARK_TABS=5,
    ACT_MAIN_AUTH_MANAGER=6,
    ACT_MAIN_BACKSPACE_PREFIX=7,
    ACT_MAIN_BOOKMARK_MANAGER=8,
    ACT_MAIN_CACHE_MANAGER=9,
    ACT_MAIN_CACHE_MINIMIZE=10,
    ACT_MAIN_COOKIE_MANAGER=11,
    ACT_MAIN_COOKIES_LOAD=12,
    ACT_MAIN_COPY_CLIPBOARD=13,
    ACT_MAIN_DOCUMENT_INFO=14,
    ACT_MAIN_DOWNLOAD_MANAGER=15,
    ACT_MAIN_EXMODE=16,
    ACT_MAIN_FILE_MENU=17,
    ACT_MAIN_FIND_NEXT=18,
    ACT_MAIN_FIND_NEXT_BACK=19,
    ACT_MAIN_FORGET_CREDENTIALS=20,
    ACT_MAIN_FORMHIST_MANAGER=21,
    ACT_MAIN_FRAME_EXTERNAL_COMMAND=22,
    ACT_MAIN_FRAME_MAXIMIZE=23,
    ACT_MAIN_FRAME_NEXT=24,
    ACT_MAIN_FRAME_PREV=25,
    ACT_MAIN_GOTO_URL=26,
    ACT_MAIN_GOTO_URL_CURRENT=27,
    ACT_MAIN_GOTO_URL_CURRENT_LINK=28,
    ACT_MAIN_GOTO_URL_HOME=29,
    ACT_MAIN_HEADER_INFO=30,
    ACT_MAIN_HISTORY_MANAGER=31,
    ACT_MAIN_HISTORY_MOVE_BACK=32,
    ACT_MAIN_HISTORY_MOVE_FORWARD=33,
    ACT_MAIN_JUMP_TO_LINK=34,
    ACT_MAIN_KEYBINDING_MANAGER=35,
    ACT_MAIN_KILL_BACKGROUNDED_CONNECTIONS=36,
    ACT_MAIN_LINK_DOWNLOAD=37,
    ACT_MAIN_LINK_DOWNLOAD_IMAGE=38,
    ACT_MAIN_LINK_DOWNLOAD_RESUME=39,
    ACT_MAIN_LINK_EXTERNAL_COMMAND=40,
    ACT_MAIN_LINK_FOLLOW=41,
    ACT_MAIN_LINK_FOLLOW_RELOAD=42,
    ACT_MAIN_LINK_MENU=43,
    ACT_MAIN_LINK_FORM_MENU=44,
    ACT_MAIN_LUA_CONSOLE=45,
    ACT_MAIN_MARK_GOTO=46,
    ACT_MAIN_MARK_SET=47,
    ACT_MAIN_MENU=48,
    ACT_MAIN_MOVE_CURSOR_DOWN=49,
    ACT_MAIN_MOVE_CURSOR_LEFT=50,
    ACT_MAIN_MOVE_CURSOR_LINE_START=51,
    ACT_MAIN_MOVE_CURSOR_RIGHT=52,
    ACT_MAIN_MOVE_CURSOR_UP=53,
    ACT_MAIN_MOVE_DOCUMENT_END=54,
    ACT_MAIN_MOVE_DOCUMENT_START=55,
    ACT_MAIN_MOVE_LINK_DOWN=56,
    ACT_MAIN_MOVE_LINK_DOWN_LINE=57,
    ACT_MAIN_MOVE_LINK_LEFT=58,
    ACT_MAIN_MOVE_LINK_LEFT_LINE=59,
    ACT_MAIN_MOVE_LINK_NEXT=60,
    ACT_MAIN_MOVE_LINK_PREV=61,
    ACT_MAIN_MOVE_LINK_RIGHT=62,
    ACT_MAIN_MOVE_LINK_RIGHT_LINE=63,
    ACT_MAIN_MOVE_LINK_UP=64,
    ACT_MAIN_MOVE_LINK_UP_LINE=65,
    ACT_MAIN_MOVE_PAGE_DOWN=66,
    ACT_MAIN_MOVE_PAGE_UP=67,
    ACT_MAIN_OPEN_LINK_IN_NEW_TAB=68,
    ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND=69,
    ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW=70,
    ACT_MAIN_OPEN_NEW_TAB=71,
    ACT_MAIN_OPEN_NEW_TAB_IN_BACKGROUND=72,
    ACT_MAIN_OPEN_NEW_WINDOW=73,
    ACT_MAIN_OPEN_OS_SHELL=74,
    ACT_MAIN_OPTIONS_MANAGER=75,
    ACT_MAIN_QUIT=76,
    ACT_MAIN_REALLY_QUIT=77,
    ACT_MAIN_REDRAW=78,
    ACT_MAIN_RELOAD=79,
    ACT_MAIN_RERENDER=80,
    ACT_MAIN_RESET_FORM=81,
    ACT_MAIN_RESOURCE_INFO=82,
    ACT_MAIN_SAVE_AS=83,
    ACT_MAIN_SAVE_FORMATTED=84,
    ACT_MAIN_SAVE_OPTIONS=85,
    ACT_MAIN_SAVE_URL_AS=86,
    ACT_MAIN_SCROLL_DOWN=87,
    ACT_MAIN_SCROLL_LEFT=88,
    ACT_MAIN_SCROLL_RIGHT=89,
    ACT_MAIN_SCROLL_UP=90,
    ACT_MAIN_SEARCH=91,
    ACT_MAIN_SEARCH_BACK=92,
    ACT_MAIN_SEARCH_TYPEAHEAD=93,
    ACT_MAIN_SEARCH_TYPEAHEAD_LINK=94,
    ACT_MAIN_SEARCH_TYPEAHEAD_TEXT=95,
    ACT_MAIN_SEARCH_TYPEAHEAD_TEXT_BACK=96,
    ACT_MAIN_SHOW_TERM_OPTIONS=97,
    ACT_MAIN_SUBMIT_FORM=98,
    ACT_MAIN_SUBMIT_FORM_RELOAD=99,
    ACT_MAIN_TAB_CLOSE=100,
    ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT=101,
    ACT_MAIN_TAB_EXTERNAL_COMMAND=102,
    ACT_MAIN_TAB_MENU=103,
    ACT_MAIN_TAB_MOVE_LEFT=104,
    ACT_MAIN_TAB_MOVE_RIGHT=105,
    ACT_MAIN_TAB_NEXT=106,
    ACT_MAIN_TAB_PREV=107,
    ACT_MAIN_TERMINAL_RESIZE=108,
    ACT_MAIN_TOGGLE_CSS=109,
    ACT_MAIN_TOGGLE_DISPLAY_IMAGES=110,
    ACT_MAIN_TOGGLE_DISPLAY_TABLES=111,
    ACT_MAIN_TOGGLE_DOCUMENT_COLORS=112,
    ACT_MAIN_TOGGLE_HTML_PLAIN=113,
    ACT_MAIN_TOGGLE_MOUSE=114,
    ACT_MAIN_TOGGLE_NUMBERED_LINKS=115,
    ACT_MAIN_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES=116,
    ACT_MAIN_TOGGLE_WRAP_TEXT=117,
    ACT_MAIN_VIEW_IMAGE=118
} main_action;

typedef void (* menu_func_T)(struct terminal *, void *, void *);

typedef enum menu_item_flags {
    NO_FLAG=0,
    FREE_LIST=1,
    FREE_TEXT=2,
    FREE_RTEXT=4,
    FREE_DATA=8,
    MENU_FULLNAME=16,
    SUBMENU=32,
    NO_INTL=64,
    NO_SELECT=128,
    RIGHT_INTL=256
} menu_item_flags;

typedef enum hotkey_state {
    HKS_SHOW=0,
    HKS_IGNORE=1,
    HKS_CACHED=2
} hotkey_state;

typedef enum term_event_modifier_T {
    KBD_MOD_NONE=0,
    KBD_MOD_SHIFT=1,
    KBD_MOD_CTRL=2,
    KBD_MOD_ALT=4
} term_event_modifier_T;

typedef struct dialog_refresh dialog_refresh, *Pdialog_refresh;

typedef struct dialog_layout dialog_layout, *Pdialog_layout;

typedef struct widget_ops widget_ops, *Pwidget_ops;

typedef union anon_union_24_4_73ccb3a3_for_info anon_union_24_4_73ccb3a3_for_info, *Panon_union_24_4_73ccb3a3_for_info;

typedef enum widget_type {
    WIDGET_CHECKBOX=0,
    WIDGET_FIELD=1,
    WIDGET_FIELD_PASS=2,
    WIDGET_BUTTON=3,
    WIDGET_LISTBOX=4,
    WIDGET_TEXT=5
} widget_type;

typedef struct widget_data_info_field widget_data_info_field, *Pwidget_data_info_field;

typedef struct widget_data_info_checkbox widget_data_info_checkbox, *Pwidget_data_info_checkbox;

typedef struct widget_data_info_text widget_data_info_text, *Pwidget_data_info_text;

typedef struct location location, *Plocation;

typedef struct connection connection, *Pconnection;

typedef struct cache_entry cache_entry, *Pcache_entry;

typedef struct progress progress, *Pprogress;

typedef struct connection_state connection_state, *Pconnection_state;

typedef enum connection_priority {
    PRI_DOWNLOAD=0,
    PRI_MAIN=0,
    PRI_FRAME=1,
    PRI_CSS=2,
    PRI_NEED_IMG=3,
    PRI_IMG=4,
    PRI_PRELOAD=5,
    PRI_CANCEL=6,
    PRIORITIES=7
} connection_priority;

typedef struct document document, *Pdocument;

typedef struct view_state view_state, *Pview_state;

typedef enum task_type {
    TASK_NONE=0,
    TASK_FORWARD=1,
    TASK_IMGMAP=2,
    TASK_RELOAD=3,
    TASK_HISTORY=4
} task_type;

typedef struct anon_struct_8_2_800802a3_for_target anon_struct_8_2_800802a3_for_target, *Panon_struct_8_2_800802a3_for_target;

typedef enum anon_enum_32 {
    COMMON_DOWNLOAD_DO=0,
    DOM_SCAN_RANGE=0,
    GNUTLS_KX_UNKNOWN=0,
    GNUTLS_MAC_UNKNOWN=0,
    GNUTLS_SHUT_RDWR=0,
    GNUTLS_X509_FMT_DER=0,
    IDNA_SUCCESS=0,
    IPPROTO_HOPOPTS=0,
    IPPROTO_IP=0,
    KP_MARK_NOTHING=0,
    SCAN_RANGE=0,
    _NL_CTYPE_CLASS=0,
    _SC_ARG_MAX=0,
    __LC_CTYPE=0,
    CONTINUE_DOWNLOAD_DO=1,
    DOM_SCAN_STRING=1,
    GNUTLS_CRD_CERTIFICATE=1,
    GNUTLS_KX_RSA=1,
    GNUTLS_MAC_NULL=1,
    GNUTLS_SERVER=1,
    GNUTLS_SHUT_WR=1,
    GNUTLS_SSL3=1,
    GNUTLS_X509_FMT_PEM=1,
    IDNA_STRINGPREP_ERROR=1,
    IPPROTO_ICMP=1,
    KP_MARK_SET=1,
    SCAN_STRING=1,
    TERM_FN_TITLE=1,
    _ISblank=1,
    _NL_CTYPE_TOUPPER=1,
    _SC_CHILD_MAX=1,
    __LC_NUMERIC=1,
    DOM_SCAN_END=2,
    GNUTLS_CLIENT=2,
    GNUTLS_CRD_ANON=2,
    GNUTLS_KX_DHE_DSS=2,
    GNUTLS_MAC_MD5=2,
    GNUTLS_TLS1_0=2,
    IDNA_PUNYCODE_ERROR=2,
    IPPROTO_IGMP=2,
    KP_MARK_GOTO=2,
    SCAN_END=2,
    TERM_FN_RESIZE=2,
    _IScntrl=2,
    _NL_CTYPE_GAP1=2,
    _SC_CLK_TCK=2,
    __LC_TIME=2,
    GNUTLS_CRD_SRP=3,
    GNUTLS_KX_DHE_RSA=3,
    GNUTLS_MAC_SHA1=3,
    GNUTLS_TLS1_1=3,
    IDNA_CONTAINS_LDH=3,
    IDNA_CONTAINS_NON_LDH=3,
    TERM_FN_TITLE_CODEPAGE=3,
    _NL_CTYPE_TOLOWER=3,
    _SC_NGROUPS_MAX=3,
    __LC_COLLATE=3,
    GNUTLS_CRD_PSK=4,
    GNUTLS_KX_ANON_DH=4,
    GNUTLS_MAC_RMD160=4,
    GNUTLS_TLS1_2=4,
    IDNA_CONTAINS_MINUS=4,
    IPPROTO_IPIP=4,
    _ISpunct=4,
    _NL_CTYPE_GAP2=4,
    _SC_OPEN_MAX=4,
    __LC_MONETARY=4,
    GNUTLS_CRD_IA=5,
    GNUTLS_KX_SRP=5,
    GNUTLS_MAC_MD2=5,
    IDNA_INVALID_LENGTH=5,
    _NL_CTYPE_CLASS32=5,
    _SC_STREAM_MAX=5,
    __LC_MESSAGES=5,
    GNUTLS_KX_RSA_EXPORT=6,
    GNUTLS_MAC_SHA256=6,
    IDNA_NO_ACE_PREFIX=6,
    IPPROTO_TCP=6,
    _NL_CTYPE_GAP3=6,
    _SC_TZNAME_MAX=6,
    __LC_ALL=6,
    GNUTLS_KX_SRP_RSA=7,
    GNUTLS_MAC_SHA384=7,
    IDNA_ROUNDTRIP_VERIFY_ERROR=7,
    _NL_CTYPE_GAP4=7,
    _SC_JOB_CONTROL=7,
    __LC_PAPER=7,
    GNUTLS_KX_SRP_DSS=8,
    GNUTLS_MAC_SHA512=8,
    IDNA_CONTAINS_ACE_PREFIX=8,
    IPPROTO_EGP=8,
    _ISalnum=8,
    _NL_CTYPE_GAP5=8,
    _SC_SAVED_IDS=8,
    __LC_NAME=8,
    GNUTLS_KX_PSK=9,
    IDNA_ICONV_ERROR=9,
    _NL_CTYPE_GAP6=9,
    _SC_REALTIME_SIGNALS=9,
    __LC_ADDRESS=9,
    GNUTLS_KX_DHE_PSK=10,
    _NL_CTYPE_CLASS_NAMES=10,
    _SC_PRIORITY_SCHEDULING=10,
    __LC_TELEPHONE=10,
    _NL_CTYPE_MAP_NAMES=11,
    _SC_TIMERS=11,
    __LC_MEASUREMENT=11,
    IPPROTO_PUP=12,
    _NL_CTYPE_WIDTH=12,
    _SC_ASYNCHRONOUS_IO=12,
    __LC_IDENTIFICATION=12,
    _NL_CTYPE_MB_CUR_MAX=13,
    _SC_PRIORITIZED_IO=13,
    CODESET=14,
    _NL_CTYPE_CODESET_NAME=14,
    _SC_SYNCHRONIZED_IO=14,
    _NL_CTYPE_TOUPPER32=15,
    _SC_FSYNC=15,
    _NL_CTYPE_TOLOWER32=16,
    _SC_MAPPED_FILES=16,
    IPPROTO_UDP=17,
    _NL_CTYPE_CLASS_OFFSET=17,
    _SC_MEMLOCK=17,
    _NL_CTYPE_MAP_OFFSET=18,
    _SC_MEMLOCK_RANGE=18,
    _NL_CTYPE_INDIGITS_MB_LEN=19,
    _SC_MEMORY_PROTECTION=19,
    _NL_CTYPE_INDIGITS0_MB=20,
    _SC_MESSAGE_PASSING=20,
    _NL_CTYPE_INDIGITS1_MB=21,
    _SC_SEMAPHORES=21,
    IPPROTO_IDP=22,
    _NL_CTYPE_INDIGITS2_MB=22,
    _SC_SHARED_MEMORY_OBJECTS=22,
    _NL_CTYPE_INDIGITS3_MB=23,
    _SC_AIO_LISTIO_MAX=23,
    _NL_CTYPE_INDIGITS4_MB=24,
    _SC_AIO_MAX=24,
    _NL_CTYPE_INDIGITS5_MB=25,
    _SC_AIO_PRIO_DELTA_MAX=25,
    _NL_CTYPE_INDIGITS6_MB=26,
    _SC_DELAYTIMER_MAX=26,
    _NL_CTYPE_INDIGITS7_MB=27,
    _SC_MQ_OPEN_MAX=27,
    _NL_CTYPE_INDIGITS8_MB=28,
    _SC_MQ_PRIO_MAX=28,
    IPPROTO_TP=29,
    _NL_CTYPE_INDIGITS9_MB=29,
    _SC_VERSION=29,
    _NL_CTYPE_INDIGITS_WC_LEN=30,
    _SC_PAGESIZE=30,
    _NL_CTYPE_INDIGITS0_WC=31,
    _SC_RTSIG_MAX=31,
    _NL_CTYPE_INDIGITS1_WC=32,
    _SC_SEM_NSEMS_MAX=32,
    IPPROTO_DCCP=33,
    _NL_CTYPE_INDIGITS2_WC=33,
    _SC_SEM_VALUE_MAX=33,
    _NL_CTYPE_INDIGITS3_WC=34,
    _SC_SIGQUEUE_MAX=34,
    _NL_CTYPE_INDIGITS4_WC=35,
    _SC_TIMER_MAX=35,
    _NL_CTYPE_INDIGITS5_WC=36,
    _SC_BC_BASE_MAX=36,
    _NL_CTYPE_INDIGITS6_WC=37,
    _SC_BC_DIM_MAX=37,
    _NL_CTYPE_INDIGITS7_WC=38,
    _SC_BC_SCALE_MAX=38,
    _NL_CTYPE_INDIGITS8_WC=39,
    _SC_BC_STRING_MAX=39,
    _NL_CTYPE_INDIGITS9_WC=40,
    _SC_COLL_WEIGHTS_MAX=40,
    IPPROTO_IPV6=41,
    _NL_CTYPE_OUTDIGIT0_MB=41,
    _SC_EQUIV_CLASS_MAX=41,
    _NL_CTYPE_OUTDIGIT1_MB=42,
    _SC_EXPR_NEST_MAX=42,
    IPPROTO_ROUTING=43,
    _NL_CTYPE_OUTDIGIT2_MB=43,
    _SC_LINE_MAX=43,
    IPPROTO_FRAGMENT=44,
    _NL_CTYPE_OUTDIGIT3_MB=44,
    _SC_RE_DUP_MAX=44,
    _NL_CTYPE_OUTDIGIT4_MB=45,
    _SC_CHARCLASS_NAME_MAX=45,
    IPPROTO_RSVP=46,
    _NL_CTYPE_OUTDIGIT5_MB=46,
    _SC_2_VERSION=46,
    IPPROTO_GRE=47,
    _NL_CTYPE_OUTDIGIT6_MB=47,
    _SC_2_C_BIND=47,
    _NL_CTYPE_OUTDIGIT7_MB=48,
    _SC_2_C_DEV=48,
    _NL_CTYPE_OUTDIGIT8_MB=49,
    _SC_2_FORT_DEV=49,
    IPPROTO_ESP=50,
    _NL_CTYPE_OUTDIGIT9_MB=50,
    _SC_2_FORT_RUN=50,
    IPPROTO_AH=51,
    _NL_CTYPE_OUTDIGIT0_WC=51,
    _SC_2_SW_DEV=51,
    _NL_CTYPE_OUTDIGIT1_WC=52,
    _SC_2_LOCALEDEF=52,
    _NL_CTYPE_OUTDIGIT2_WC=53,
    _SC_PII=53,
    _NL_CTYPE_OUTDIGIT3_WC=54,
    _SC_PII_XTI=54,
    _NL_CTYPE_OUTDIGIT4_WC=55,
    _SC_PII_SOCKET=55,
    _NL_CTYPE_OUTDIGIT5_WC=56,
    _SC_PII_INTERNET=56,
    _NL_CTYPE_OUTDIGIT6_WC=57,
    _SC_PII_OSI=57,
    IPPROTO_ICMPV6=58,
    _NL_CTYPE_OUTDIGIT7_WC=58,
    _SC_POLL=58,
    IPPROTO_NONE=59,
    _NL_CTYPE_OUTDIGIT8_WC=59,
    _SC_SELECT=59,
    IPPROTO_DSTOPTS=60,
    _NL_CTYPE_OUTDIGIT9_WC=60,
    _SC_IOV_MAX=60,
    _SC_UIO_MAXIOV=60,
    _NL_CTYPE_TRANSLIT_TAB_SIZE=61,
    _SC_PII_INTERNET_STREAM=61,
    _NL_CTYPE_TRANSLIT_FROM_IDX=62,
    _SC_PII_INTERNET_DGRAM=62,
    _NL_CTYPE_TRANSLIT_FROM_TBL=63,
    _SC_PII_OSI_COTS=63,
    _NL_CTYPE_TRANSLIT_TO_IDX=64,
    _SC_PII_OSI_CLTS=64,
    _NL_CTYPE_TRANSLIT_TO_TBL=65,
    _SC_PII_OSI_M=65,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN=66,
    _SC_T_IOV_MAX=66,
    _NL_CTYPE_TRANSLIT_DEFAULT_MISSING=67,
    _SC_THREADS=67,
    _NL_CTYPE_TRANSLIT_IGNORE_LEN=68,
    _SC_THREAD_SAFE_FUNCTIONS=68,
    _NL_CTYPE_TRANSLIT_IGNORE=69,
    _SC_GETGR_R_SIZE_MAX=69,
    _NL_CTYPE_MAP_TO_NONASCII=70,
    _SC_GETPW_R_SIZE_MAX=70,
    _NL_CTYPE_NONASCII_CASE=71,
    _SC_LOGIN_NAME_MAX=71,
    _NL_CTYPE_EXTRA_MAP_1=72,
    _SC_TTY_NAME_MAX=72,
    _NL_CTYPE_EXTRA_MAP_2=73,
    _SC_THREAD_DESTRUCTOR_ITERATIONS=73,
    _NL_CTYPE_EXTRA_MAP_3=74,
    _SC_THREAD_KEYS_MAX=74,
    _NL_CTYPE_EXTRA_MAP_4=75,
    _SC_THREAD_STACK_MIN=75,
    _NL_CTYPE_EXTRA_MAP_5=76,
    _SC_THREAD_THREADS_MAX=76,
    _NL_CTYPE_EXTRA_MAP_6=77,
    _SC_THREAD_ATTR_STACKADDR=77,
    _NL_CTYPE_EXTRA_MAP_7=78,
    _SC_THREAD_ATTR_STACKSIZE=78,
    _NL_CTYPE_EXTRA_MAP_8=79,
    _SC_THREAD_PRIORITY_SCHEDULING=79,
    _NL_CTYPE_EXTRA_MAP_9=80,
    _SC_THREAD_PRIO_INHERIT=80,
    _NL_CTYPE_EXTRA_MAP_10=81,
    _SC_THREAD_PRIO_PROTECT=81,
    _NL_CTYPE_EXTRA_MAP_11=82,
    _SC_THREAD_PROCESS_SHARED=82,
    _NL_CTYPE_EXTRA_MAP_12=83,
    _SC_NPROCESSORS_CONF=83,
    _NL_CTYPE_EXTRA_MAP_13=84,
    _SC_NPROCESSORS_ONLN=84,
    _NL_CTYPE_EXTRA_MAP_14=85,
    _SC_PHYS_PAGES=85,
    _NL_NUM_LC_CTYPE=86,
    _SC_AVPHYS_PAGES=86,
    _SC_ATEXIT_MAX=87,
    _SC_PASS_MAX=88,
    _SC_XOPEN_VERSION=89,
    _SC_XOPEN_XCU_VERSION=90,
    _SC_XOPEN_UNIX=91,
    IPPROTO_MTP=92,
    _SC_XOPEN_CRYPT=92,
    _SC_XOPEN_ENH_I18N=93,
    _SC_XOPEN_SHM=94,
    _SC_2_CHAR_TERM=95,
    _SC_2_C_VERSION=96,
    _SC_2_UPE=97,
    IPPROTO_ENCAP=98,
    _SC_XOPEN_XPG2=98,
    _SC_XOPEN_XPG3=99,
    _SC_XOPEN_XPG4=100,
    _SC_CHAR_BIT=101,
    _SC_CHAR_MAX=102,
    IPPROTO_PIM=103,
    _SC_CHAR_MIN=103,
    _SC_INT_MAX=104,
    _SC_INT_MIN=105,
    _SC_LONG_BIT=106,
    _SC_WORD_BIT=107,
    IPPROTO_COMP=108,
    _SC_MB_LEN_MAX=108,
    _SC_NZERO=109,
    _SC_SSIZE_MAX=110,
    _SC_SCHAR_MAX=111,
    _SC_SCHAR_MIN=112,
    _SC_SHRT_MAX=113,
    _SC_SHRT_MIN=114,
    _SC_UCHAR_MAX=115,
    _SC_UINT_MAX=116,
    _SC_ULONG_MAX=117,
    _SC_USHRT_MAX=118,
    _SC_NL_ARGMAX=119,
    _SC_NL_LANGMAX=120,
    _SC_NL_MSGMAX=121,
    _SC_NL_NMAX=122,
    _SC_NL_SETMAX=123,
    _SC_NL_TEXTMAX=124,
    _SC_XBS5_ILP32_OFF32=125,
    _SC_XBS5_ILP32_OFFBIG=126,
    _SC_XBS5_LP64_OFF64=127,
    _SC_XBS5_LPBIG_OFFBIG=128,
    _SC_XOPEN_LEGACY=129,
    _SC_XOPEN_REALTIME=130,
    _SC_XOPEN_REALTIME_THREADS=131,
    IPPROTO_SCTP=132,
    _SC_ADVISORY_INFO=132,
    _SC_BARRIERS=133,
    _SC_BASE=134,
    _SC_C_LANG_SUPPORT=135,
    IPPROTO_UDPLITE=136,
    _SC_C_LANG_SUPPORT_R=136,
    _SC_CLOCK_SELECTION=137,
    _SC_CPUTIME=138,
    _SC_THREAD_CPUTIME=139,
    _SC_DEVICE_IO=140,
    _SC_DEVICE_SPECIFIC=141,
    _SC_DEVICE_SPECIFIC_R=142,
    _SC_FD_MGMT=143,
    _SC_FIFO=144,
    _SC_PIPE=145,
    _SC_FILE_ATTRIBUTES=146,
    _SC_FILE_LOCKING=147,
    _SC_FILE_SYSTEM=148,
    _SC_MONOTONIC_CLOCK=149,
    _SC_MULTI_PROCESS=150,
    _SC_SINGLE_PROCESS=151,
    _SC_NETWORKING=152,
    _SC_READER_WRITER_LOCKS=153,
    _SC_SPIN_LOCKS=154,
    _SC_REGEXP=155,
    _SC_REGEX_VERSION=156,
    _SC_SHELL=157,
    _SC_SIGNALS=158,
    _SC_SPAWN=159,
    _SC_SPORADIC_SERVER=160,
    _SC_THREAD_SPORADIC_SERVER=161,
    _SC_SYSTEM_DATABASE=162,
    _SC_SYSTEM_DATABASE_R=163,
    _SC_TIMEOUTS=164,
    _SC_TYPED_MEMORY_OBJECTS=165,
    _SC_USER_GROUPS=166,
    _SC_USER_GROUPS_R=167,
    _SC_2_PBS=168,
    _SC_2_PBS_ACCOUNTING=169,
    _SC_2_PBS_LOCATE=170,
    _SC_2_PBS_MESSAGE=171,
    _SC_2_PBS_TRACK=172,
    _SC_SYMLOOP_MAX=173,
    _SC_STREAMS=174,
    _SC_2_PBS_CHECKPOINT=175,
    _SC_V6_ILP32_OFF32=176,
    _SC_V6_ILP32_OFFBIG=177,
    _SC_V6_LP64_OFF64=178,
    _SC_V6_LPBIG_OFFBIG=179,
    _SC_HOST_NAME_MAX=180,
    _SC_TRACE=181,
    _SC_TRACE_EVENT_FILTER=182,
    _SC_TRACE_INHERIT=183,
    _SC_TRACE_LOG=184,
    _SC_LEVEL1_ICACHE_SIZE=185,
    _SC_LEVEL1_ICACHE_ASSOC=186,
    _SC_LEVEL1_ICACHE_LINESIZE=187,
    _SC_LEVEL1_DCACHE_SIZE=188,
    _SC_LEVEL1_DCACHE_ASSOC=189,
    _SC_LEVEL1_DCACHE_LINESIZE=190,
    _SC_LEVEL2_CACHE_SIZE=191,
    _SC_LEVEL2_CACHE_ASSOC=192,
    _SC_LEVEL2_CACHE_LINESIZE=193,
    _SC_LEVEL3_CACHE_SIZE=194,
    _SC_LEVEL3_CACHE_ASSOC=195,
    _SC_LEVEL3_CACHE_LINESIZE=196,
    _SC_LEVEL4_CACHE_SIZE=197,
    _SC_LEVEL4_CACHE_ASSOC=198,
    _SC_LEVEL4_CACHE_LINESIZE=199,
    IDNA_MALLOC_ERROR=201,
    IDNA_DLOPEN_ERROR=202,
    _SC_IPV6=235,
    _SC_RAW_SOCKETS=236,
    _SC_V7_ILP32_OFF32=237,
    _SC_V7_ILP32_OFFBIG=238,
    _SC_V7_LP64_OFF64=239,
    _SC_V7_LPBIG_OFFBIG=240,
    _SC_SS_REPL_MAX=241,
    _SC_TRACE_EVENT_NAME_MAX=242,
    _SC_TRACE_NAME_MAX=243,
    _SC_TRACE_SYS_MAX=244,
    _SC_TRACE_USER_EVENT_MAX=245,
    _SC_XOPEN_STREAMS=246,
    _SC_THREAD_ROBUST_PRIO_INHERIT=247,
    _SC_THREAD_ROBUST_PRIO_PROTECT=248,
    GNUTLS_VERSION_UNKNOWN=255,
    IPPROTO_RAW=255,
    IPPROTO_MAX=256,
    _ISupper=256,
    _ISlower=512,
    _ISalpha=1024,
    _ISdigit=2048,
    _ISxdigit=4096,
    _ISspace=8192,
    _ISprint=16384,
    _ISgraph=32768,
    RADIXCHAR=65536,
    __DECIMAL_POINT=65536,
    THOUSEP=65537,
    __THOUSANDS_SEP=65537,
    __GROUPING=65538,
    _NL_NUMERIC_DECIMAL_POINT_WC=65539,
    _NL_NUMERIC_THOUSANDS_SEP_WC=65540,
    _NL_NUMERIC_CODESET=65541,
    _NL_NUM_LC_NUMERIC=65542,
    ABDAY_1=131072,
    ABDAY_2=131073,
    ABDAY_3=131074,
    ABDAY_4=131075,
    ABDAY_5=131076,
    ABDAY_6=131077,
    ABDAY_7=131078,
    DAY_1=131079,
    DAY_2=131080,
    DAY_3=131081,
    DAY_4=131082,
    DAY_5=131083,
    DAY_6=131084,
    DAY_7=131085,
    ABMON_1=131086,
    ABMON_2=131087,
    ABMON_3=131088,
    ABMON_4=131089,
    ABMON_5=131090,
    ABMON_6=131091,
    ABMON_7=131092,
    ABMON_8=131093,
    ABMON_9=131094,
    ABMON_10=131095,
    ABMON_11=131096,
    ABMON_12=131097,
    MON_1=131098,
    MON_2=131099,
    MON_3=131100,
    MON_4=131101,
    MON_5=131102,
    MON_6=131103,
    MON_7=131104,
    MON_8=131105,
    MON_9=131106,
    MON_10=131107,
    MON_11=131108,
    MON_12=131109,
    AM_STR=131110,
    PM_STR=131111,
    D_T_FMT=131112,
    D_FMT=131113,
    T_FMT=131114,
    T_FMT_AMPM=131115,
    ERA=131116,
    __ERA_YEAR=131117,
    ERA_D_FMT=131118,
    ALT_DIGITS=131119,
    ERA_D_T_FMT=131120,
    ERA_T_FMT=131121,
    _NL_TIME_ERA_NUM_ENTRIES=131122,
    _NL_TIME_ERA_ENTRIES=131123,
    _NL_WABDAY_1=131124,
    _NL_WABDAY_2=131125,
    _NL_WABDAY_3=131126,
    _NL_WABDAY_4=131127,
    _NL_WABDAY_5=131128,
    _NL_WABDAY_6=131129,
    _NL_WABDAY_7=131130,
    _NL_WDAY_1=131131,
    _NL_WDAY_2=131132,
    _NL_WDAY_3=131133,
    _NL_WDAY_4=131134,
    _NL_WDAY_5=131135,
    _NL_WDAY_6=131136,
    _NL_WDAY_7=131137,
    _NL_WABMON_1=131138,
    _NL_WABMON_2=131139,
    _NL_WABMON_3=131140,
    _NL_WABMON_4=131141,
    _NL_WABMON_5=131142,
    _NL_WABMON_6=131143,
    _NL_WABMON_7=131144,
    _NL_WABMON_8=131145,
    _NL_WABMON_9=131146,
    _NL_WABMON_10=131147,
    _NL_WABMON_11=131148,
    _NL_WABMON_12=131149,
    _NL_WMON_1=131150,
    _NL_WMON_2=131151,
    _NL_WMON_3=131152,
    _NL_WMON_4=131153,
    _NL_WMON_5=131154,
    _NL_WMON_6=131155,
    _NL_WMON_7=131156,
    _NL_WMON_8=131157,
    _NL_WMON_9=131158,
    _NL_WMON_10=131159,
    _NL_WMON_11=131160,
    _NL_WMON_12=131161,
    _NL_WAM_STR=131162,
    _NL_WPM_STR=131163,
    _NL_WD_T_FMT=131164,
    _NL_WD_FMT=131165,
    _NL_WT_FMT=131166,
    _NL_WT_FMT_AMPM=131167,
    _NL_WERA_YEAR=131168,
    _NL_WERA_D_FMT=131169,
    _NL_WALT_DIGITS=131170,
    _NL_WERA_D_T_FMT=131171,
    _NL_WERA_T_FMT=131172,
    _NL_TIME_WEEK_NDAYS=131173,
    _NL_TIME_WEEK_1STDAY=131174,
    _NL_TIME_WEEK_1STWEEK=131175,
    _NL_TIME_FIRST_WEEKDAY=131176,
    _NL_TIME_FIRST_WORKDAY=131177,
    _NL_TIME_CAL_DIRECTION=131178,
    _NL_TIME_TIMEZONE=131179,
    _DATE_FMT=131180,
    _NL_W_DATE_FMT=131181,
    _NL_TIME_CODESET=131182,
    _NL_NUM_LC_TIME=131183,
    _NL_COLLATE_NRULES=196608,
    _NL_COLLATE_RULESETS=196609,
    _NL_COLLATE_TABLEMB=196610,
    _NL_COLLATE_WEIGHTMB=196611,
    _NL_COLLATE_EXTRAMB=196612,
    _NL_COLLATE_INDIRECTMB=196613,
    _NL_COLLATE_GAP1=196614,
    _NL_COLLATE_GAP2=196615,
    _NL_COLLATE_GAP3=196616,
    _NL_COLLATE_TABLEWC=196617,
    _NL_COLLATE_WEIGHTWC=196618,
    _NL_COLLATE_EXTRAWC=196619,
    _NL_COLLATE_INDIRECTWC=196620,
    _NL_COLLATE_SYMB_HASH_SIZEMB=196621,
    _NL_COLLATE_SYMB_TABLEMB=196622,
    _NL_COLLATE_SYMB_EXTRAMB=196623,
    _NL_COLLATE_COLLSEQMB=196624,
    _NL_COLLATE_COLLSEQWC=196625,
    _NL_COLLATE_CODESET=196626,
    _NL_NUM_LC_COLLATE=196627,
    __INT_CURR_SYMBOL=262144,
    __CURRENCY_SYMBOL=262145,
    __MON_DECIMAL_POINT=262146,
    __MON_THOUSANDS_SEP=262147,
    __MON_GROUPING=262148,
    __POSITIVE_SIGN=262149,
    __NEGATIVE_SIGN=262150,
    __INT_FRAC_DIGITS=262151,
    __FRAC_DIGITS=262152,
    __P_CS_PRECEDES=262153,
    __P_SEP_BY_SPACE=262154,
    __N_CS_PRECEDES=262155,
    __N_SEP_BY_SPACE=262156,
    __P_SIGN_POSN=262157,
    __N_SIGN_POSN=262158,
    _NL_MONETARY_CRNCYSTR=262159,
    __INT_P_CS_PRECEDES=262160,
    __INT_P_SEP_BY_SPACE=262161,
    __INT_N_CS_PRECEDES=262162,
    __INT_N_SEP_BY_SPACE=262163,
    __INT_P_SIGN_POSN=262164,
    __INT_N_SIGN_POSN=262165,
    _NL_MONETARY_DUO_INT_CURR_SYMBOL=262166,
    _NL_MONETARY_DUO_CURRENCY_SYMBOL=262167,
    _NL_MONETARY_DUO_INT_FRAC_DIGITS=262168,
    _NL_MONETARY_DUO_FRAC_DIGITS=262169,
    _NL_MONETARY_DUO_P_CS_PRECEDES=262170,
    _NL_MONETARY_DUO_P_SEP_BY_SPACE=262171,
    _NL_MONETARY_DUO_N_CS_PRECEDES=262172,
    _NL_MONETARY_DUO_N_SEP_BY_SPACE=262173,
    _NL_MONETARY_DUO_INT_P_CS_PRECEDES=262174,
    _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE=262175,
    _NL_MONETARY_DUO_INT_N_CS_PRECEDES=262176,
    _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE=262177,
    _NL_MONETARY_DUO_P_SIGN_POSN=262178,
    _NL_MONETARY_DUO_N_SIGN_POSN=262179,
    _NL_MONETARY_DUO_INT_P_SIGN_POSN=262180,
    _NL_MONETARY_DUO_INT_N_SIGN_POSN=262181,
    _NL_MONETARY_UNO_VALID_FROM=262182,
    _NL_MONETARY_UNO_VALID_TO=262183,
    _NL_MONETARY_DUO_VALID_FROM=262184,
    _NL_MONETARY_DUO_VALID_TO=262185,
    _NL_MONETARY_CONVERSION_RATE=262186,
    _NL_MONETARY_DECIMAL_POINT_WC=262187,
    _NL_MONETARY_THOUSANDS_SEP_WC=262188,
    _NL_MONETARY_CODESET=262189,
    _NL_NUM_LC_MONETARY=262190,
    __YESEXPR=327680,
    __NOEXPR=327681,
    __YESSTR=327682,
    __NOSTR=327683,
    _NL_MESSAGES_CODESET=327684,
    _NL_NUM_LC_MESSAGES=327685,
    _NL_PAPER_HEIGHT=458752,
    _NL_PAPER_WIDTH=458753,
    _NL_PAPER_CODESET=458754,
    _NL_NUM_LC_PAPER=458755,
    _NL_NAME_NAME_FMT=524288,
    _NL_NAME_NAME_GEN=524289,
    _NL_NAME_NAME_MR=524290,
    _NL_NAME_NAME_MRS=524291,
    _NL_NAME_NAME_MISS=524292,
    _NL_NAME_NAME_MS=524293,
    _NL_NAME_CODESET=524294,
    _NL_NUM_LC_NAME=524295,
    _NL_ADDRESS_POSTAL_FMT=589824,
    _NL_ADDRESS_COUNTRY_NAME=589825,
    _NL_ADDRESS_COUNTRY_POST=589826,
    _NL_ADDRESS_COUNTRY_AB2=589827,
    _NL_ADDRESS_COUNTRY_AB3=589828,
    _NL_ADDRESS_COUNTRY_CAR=589829,
    _NL_ADDRESS_COUNTRY_NUM=589830,
    _NL_ADDRESS_COUNTRY_ISBN=589831,
    _NL_ADDRESS_LANG_NAME=589832,
    _NL_ADDRESS_LANG_AB=589833,
    _NL_ADDRESS_LANG_TERM=589834,
    _NL_ADDRESS_LANG_LIB=589835,
    _NL_ADDRESS_CODESET=589836,
    _NL_NUM_LC_ADDRESS=589837,
    _NL_TELEPHONE_TEL_INT_FMT=655360,
    _NL_TELEPHONE_TEL_DOM_FMT=655361,
    _NL_TELEPHONE_INT_SELECT=655362,
    _NL_TELEPHONE_INT_PREFIX=655363,
    _NL_TELEPHONE_CODESET=655364,
    _NL_NUM_LC_TELEPHONE=655365,
    _NL_MEASUREMENT_MEASUREMENT=720896,
    _NL_MEASUREMENT_CODESET=720897,
    _NL_NUM_LC_MEASUREMENT=720898,
    _NL_IDENTIFICATION_TITLE=786432,
    _NL_IDENTIFICATION_SOURCE=786433,
    _NL_IDENTIFICATION_ADDRESS=786434,
    _NL_IDENTIFICATION_CONTACT=786435,
    _NL_IDENTIFICATION_EMAIL=786436,
    _NL_IDENTIFICATION_TEL=786437,
    _NL_IDENTIFICATION_FAX=786438,
    _NL_IDENTIFICATION_LANGUAGE=786439,
    _NL_IDENTIFICATION_TERRITORY=786440,
    _NL_IDENTIFICATION_AUDIENCE=786441,
    _NL_IDENTIFICATION_APPLICATION=786442,
    _NL_IDENTIFICATION_ABBREVIATION=786443,
    _NL_IDENTIFICATION_REVISION=786444,
    _NL_IDENTIFICATION_DATE=786445,
    _NL_IDENTIFICATION_CATEGORY=786446,
    _NL_IDENTIFICATION_CODESET=786447,
    _NL_NUM_LC_IDENTIFICATION=786448,
    _NL_NUM=786449
} anon_enum_32;

typedef struct timeval_T timeval_T, *Ptimeval_T;

typedef struct led_panel led_panel, *Pled_panel;

typedef struct led led, *Pled;

typedef struct term_event_keyboard term_event_keyboard, *Pterm_event_keyboard;

typedef struct term_event_size term_event_size, *Pterm_event_size;

typedef enum dlg_refresh_code {
    REFRESH_DIALOG=0,
    REFRESH_CANCEL=1,
    REFRESH_NONE=2,
    REFRESH_STOP=3
} dlg_refresh_code;

typedef dlg_refresh_code (* dialog_refresh_handler_T)(struct dialog_data *, void *);

typedef struct widget_info_checkbox widget_info_checkbox, *Pwidget_info_checkbox;

typedef struct widget_info_field widget_info_field, *Pwidget_info_field;

typedef struct widget_info_button widget_info_button, *Pwidget_info_button;

typedef struct widget_info_text widget_info_text, *Pwidget_info_text;

typedef struct input_history_entry input_history_entry, *Pinput_history_entry;

typedef __off64_t off_t;

typedef enum stream_encoding {
    ENCODING_NONE=0,
    ENCODING_GZIP=1,
    ENCODING_BZIP2=2,
    ENCODING_LZMA=3,
    ENCODING_DEFLATE=4,
    ENCODINGS_KNOWN=5
} stream_encoding;

typedef struct stream_encoded stream_encoded, *Pstream_encoded;

typedef struct socket socket, *Psocket;

typedef __time_t time_t;

typedef enum connection_basic_state {
    S_FSP_OPEN_SESSION_UNKN=-100900,
    S_BITTORRENT_PEER_URL=-100804,
    S_BITTORRENT_BAD_URL=-100803,
    S_BITTORRENT_TRACKER=-100802,
    S_BITTORRENT_METAINFO=-100801,
    S_BITTORRENT_ERROR=-100800,
    S_PROXY_ERROR=-100700,
    S_NO_JAVASCRIPT=-100600,
    S_GOPHER_CSO_ERROR=-100500,
    S_NNTP_SERVER_ERROR=-100408,
    S_NNTP_ACCESS_DENIED=-100407,
    S_NNTP_AUTH_REQUIRED=-100406,
    S_NNTP_TRANSFER_ERROR=-100405,
    S_NNTP_ARTICLE_UNKNOWN=-100404,
    S_NNTP_GROUP_UNKNOWN=-100403,
    S_NNTP_SERVER_HANG_UP=-100402,
    S_NNTP_NEWS_SERVER=-100401,
    S_NNTP_ERROR=-100400,
    S_FTP_FILE_ERROR=-100305,
    S_FTP_NO_FILE=-100304,
    S_FTP_PORT=-100303,
    S_FTP_LOGIN=-100302,
    S_FTP_UNAVAIL=-100301,
    S_FTP_ERROR=-100300,
    S_FILE_ANONYMOUS=-100203,
    S_FILE_CGI_BAD_PATH=-100202,
    S_FILE_ERROR=-100201,
    S_FILE_TYPE=-100200,
    S_HTTP_204=-100101,
    S_HTTP_ERROR=-100100,
    S_NO_FORCED_DNS=-100019,
    S_SSL_ERROR=-100018,
    S_ENCODE_ERROR=-100017,
    S_EXTERNAL_PROTOCOL=-100016,
    S_UNKNOWN_PROTOCOL=-100015,
    S_LOCAL_ONLY=-100014,
    S_WAIT_REDIR=-100013,
    S_STATE=-100012,
    S_RESTART=-100011,
    S_TIMEOUT=-100010,
    S_BAD_URL=-100009,
    S_MODIFIED=-100008,
    S_CANT_READ=-100007,
    S_CANT_WRITE=-100006,
    S_NO_DNS=-100005,
    S_OUT_OF_MEM=-100004,
    S_INTERNAL=-100003,
    S_EXCEPT=-100002,
    S_INTERRUPTED=-100001,
    S_OK=-100000,
    S_ERRNO=-1,
    S_WAIT=0,
    S_DNS=1,
    S_CONN=2,
    S_SSL_NEG=3,
    S_SENT=4,
    S_LOGIN=5,
    S_GETH=6,
    S_PROC=7,
    S_TRANS=8,
    S_QUESTIONS=9,
    S_CONN_PEERS=10,
    S_CONN_TRACKER=11,
    S_RESUME=12
} connection_basic_state;

typedef struct document_options document_options, *Pdocument_options;

typedef struct uri_list uri_list, *Puri_list;

typedef struct frame_desc frame_desc, *Pframe_desc;

typedef struct frameset_desc frameset_desc, *Pframeset_desc;

typedef struct document_refresh document_refresh, *Pdocument_refresh;

typedef struct line line, *Pline;

typedef struct link link, *Plink;

typedef struct search search, *Psearch;

typedef enum cp_status {
    CP_STATUS_NONE=0,
    CP_STATUS_SERVER=1,
    CP_STATUS_ASSUMED=2,
    CP_STATUS_IGNORED=3
} cp_status;

typedef struct form_state form_state, *Pform_state;

typedef int32_t term_event_key_T;

typedef struct input_history input_history, *Pinput_history;

typedef enum inpfield_flags {
    INPFIELD_NONE=0,
    INPFIELD_FLOAT=1,
    INPFIELD_FLOAT2=2
} inpfield_flags;

typedef enum format_align {
    ALIGN_LEFT=0,
    ALIGN_CENTER=1,
    ALIGN_RIGHT=2,
    ALIGN_JUSTIFY=3
} format_align;

typedef enum socket_state {
    SOCKET_RETRY_ONCLOSE=0,
    SOCKET_END_ONCLOSE=1,
    SOCKET_CLOSED=2
} socket_state;

typedef struct connect_info connect_info, *Pconnect_info;

typedef struct read_buffer read_buffer, *Pread_buffer;

typedef struct socket_operations socket_operations, *Psocket_operations;

typedef void (* socket_read_T)(struct socket *, struct read_buffer *);

typedef struct text_style text_style, *Ptext_style;

typedef struct active_link_options active_link_options, *Pactive_link_options;

typedef struct anon_struct_28_7_ce8ae3d2_for_image_link anon_struct_28_7_ce8ae3d2_for_image_link, *Panon_struct_28_7_ce8ae3d2_for_image_link;

typedef enum link_type {
    LINK_HYPERTEXT=0,
    LINK_MAP=1,
    LINK_BUTTON=2,
    LINK_CHECKBOX=3,
    LINK_SELECT=4,
    LINK_FIELD=5,
    LINK_AREA=6
} link_type;

typedef struct point point, *Ppoint;

typedef struct color_pair color_pair, *Pcolor_pair;

typedef union anon_union_4_2_0d81108a_for_data anon_union_4_2_0d81108a_for_data, *Panon_union_4_2_0d81108a_for_data;

typedef struct form_view form_view, *Pform_view;

typedef enum form_type {
    FC_TEXT=0,
    FC_PASSWORD=1,
    FC_FILE=2,
    FC_TEXTAREA=3,
    FC_CHECKBOX=4,
    FC_RADIO=5,
    FC_SELECT=6,
    FC_SUBMIT=7,
    FC_IMAGE=8,
    FC_RESET=9,
    FC_BUTTON=10,
    FC_HIDDEN=11
} form_type;

typedef struct sockaddr_storage sockaddr_storage, *Psockaddr_storage;

typedef void (* socket_connect_T)(struct socket *);

typedef void (* socket_operation_T)(struct socket *, struct connection_state);

typedef enum text_style_format {
    AT_BOLD=1,
    AT_ITALIC=2,
    AT_UNDERLINE=4,
    AT_FIXED=8,
    AT_GRAPHICS=16,
    AT_PREFORMATTED=32
} text_style_format;

typedef struct form_control form_control, *Pform_control;

typedef struct form form, *Pform;

typedef enum form_mode {
    FORM_MODE_NORMAL=0,
    FORM_MODE_READONLY=1,
    FORM_MODE_DISABLED=2
} form_mode;

typedef enum form_wrap {
    FORM_WRAP_NONE=0,
    FORM_WRAP_SOFT=1,
    FORM_WRAP_HARD=2
} form_wrap;

typedef enum form_method {
    FORM_METHOD_GET=0,
    FORM_METHOD_POST=1,
    FORM_METHOD_POST_MP=2,
    FORM_METHOD_POST_TEXT_PLAIN=3
} form_method;

struct widget_ops {
    widget_handler_status_T (* display)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* init)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* mouse)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* kbd)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* select)(struct dialog_data *, struct widget_data *);
    widget_handler_status_T (* clear)(struct dialog_data *, struct widget_data *);
};

struct anon_struct_28_7_ce8ae3d2_for_image_link {
    uchar * prefix;
    uchar * suffix;
    int filename_maxlen;
    int label_maxlen;
    int display_style;
    int tagging;
    uint show_any_as_links:1;
};

struct terminal_screen {
    struct screen_char * image;
    struct screen_char * last_image;
    int cx;
    int cy;
    int lcx;
    int lcy;
    int dirty_from;
    int dirty_to;
};

struct menu_item {
    uchar * text;
    uchar * rtext;
    enum main_action action_id;
    menu_func_T func;
    void * data;
    enum menu_item_flags flags;
    enum hotkey_state hotkey_state;
    int hotkey_pos;
};

struct read_buffer {
    socket_read_T done;
    int length;
    int freespace;
    uchar data[1];
};

struct led {
    uint used__:1;
    uint value_changed__:1;
    uint value__:8;
};

union anon_union_4_2_0d81108a_for_data {
    uchar * name;
    struct form_control * form_control;
};

struct memory_list {
    int n;
    void * p[1];
};

struct connection_state {
    enum connection_basic_state basic;
    int syserr;
};

struct download {
    struct download * next;
    struct download * prev;
    struct connection * conn;
    struct cache_entry * cached;
    void (* callback)(struct download *, void *);
    void * data;
    struct progress * progress;
    struct connection_state state;
    struct connection_state prev_error;
    enum connection_priority pri;
};

struct anon_struct_8_2_800802a3_for_target {
    uchar * frame;
    struct location * location;
};

struct session_task {
    enum task_type type;
    struct anon_struct_8_2_800802a3_for_target target;
};

struct list_head_elinks {
    void * next;
    void * prev;
};

struct view_state {
    struct document_view * doc_view;
    struct uri * uri;
    struct list_head_elinks forms;
    struct form_state * form_info;
    int form_info_len;
    int x;
    int y;
    int current_link;
    int old_current_link;
    int plain;
    uint wrap:1;
    uint did_fragment:1;
};

struct connection {
    struct connection * next;
    struct connection * prev;
    struct list_head_elinks downloads;
    struct progress * progress;
    struct uri * uri;
    struct uri * proxied_uri;
    struct uri * referrer;
    enum cache_mode cache_mode;
    struct cache_entry * cached;
    off_t from;
    off_t received;
    off_t est_length;
    enum stream_encoding content_encoding;
    struct stream_encoded * stream;
    void (* done)(struct connection *);
    uint id;
    struct connection_state state;
    struct connection_state prev_error;
    struct socket * socket;
    struct socket * data_socket;
    int tries;
    timer_id_T timer;
    int stream_pipes[2];
    uint running:1;
    uint unrestartable:1;
    uint detached:1;
    uint cgi:1;
    int pri[7];
    void * info;
};

struct anon_struct_16_4_ef67fadd_for_utf8 {
    unicode_val_T ucs;
    int len;
    unicode_val_T min;
    enum term_event_modifier_T modifier;
};

struct terminal_interlink {
    int qlen;
    int qfreespace;
    struct anon_struct_16_4_ef67fadd_for_utf8 utf8;
    uchar input_queue[1];
};

struct uri_list {
    int size;
    struct uri * * uris;
};

struct led_panel {
    struct led leds[6];
};

struct session_status {
    uint show_tabs_bar:1;
    uint show_status_bar:1;
    uint show_title_bar:1;
    int force_show_status_bar:2;
    int force_show_title_bar:2;
    uint set_window_title:1;
    uchar * last_title;
    uint show_leds:1;
    struct led_panel leds;
    struct led * ssl_led;
    struct led * insert_mode_led;
    struct led * ecmascript_led;
    struct led * popup_led;
    uint visited:1;
    uint processing_file_requests:1;
    uint show_tabs_bar_at_top:1;
};

struct input_history {
    struct list_head_elinks entries;
    int size;
    uint dirty:1;
    uint nosave:1;
};

struct timeval_T {
    long sec;
    long usec;
};

struct object {
    int refcount;
};

struct cache_entry {
    struct cache_entry * next;
    struct cache_entry * prev;
    struct object object;
    struct list_head_elinks frag;
    struct uri * uri;
    struct uri * proxy_uri;
    struct uri * redirect;
    uchar * head;
    uchar * content_type;
    uchar * last_modified;
    uchar * etag;
    uchar * ssl_info;
    uchar * encoding_info;
    uint cache_id;
    time_t seconds;
    off_t length;
    off_t data_size;
    struct listbox_item * box_item;
    struct timeval_T max_age;
    uint expire:1;
    uint preformatted:1;
    uint redirect_get:1;
    uint incomplete:1;
    uint valid:1;
    uint gc_target:1;
    uint cgi:1;
    enum cache_mode cache_mode;
};

struct form_view {
    struct form_view * next;
    struct form_view * prev;
    int form_num;
};

struct widget_data_info_checkbox {
    int checked;
};

struct box {
    int x;
    int y;
    int width;
    int height;
};

struct widget_data_info_field {
    int vpos;
    int cpos;
    struct list_head_elinks history;
    struct input_history_entry * cur_hist;
};

struct widget_data_info_text {
    int current;
    int lines;
    int max_width;
    int scroller_height;
    int scroller_y;
    int scroller_last_dir;
};

union anon_union_24_3_5d775672_for_info {
    struct widget_data_info_field field;
    struct widget_data_info_checkbox checkbox;
    struct widget_data_info_text text;
};

struct widget_data {
    struct widget * widget;
    uchar * cdata;
    struct box box;
    union anon_union_24_3_5d775672_for_info info;
};

struct dialog_data {
    struct window * win;
    struct dialog * dlg;
    struct memory_list * ml;
    struct box box;
    int number_of_widgets;
    int selected_widget_id;
    struct term_event * term_event;
    struct widget_data widgets_data[1];
};

struct term_event_mouse {
    int x;
    int y;
    uint button;
};

struct term_event_size {
    int width;
    int height;
};

struct term_event_keyboard {
    term_event_key_T key;
    enum term_event_modifier_T modifier;
};

union anon_union_12_3_3ebaaa1f_for_info {
    struct term_event_mouse mouse;
    struct term_event_keyboard keyboard;
    struct term_event_size size;
};

struct dialog_refresh {
    dialog_refresh_handler_T handler;
    void * data;
    timer_id_T timer;
};

struct frame_desc {
    struct frameset_desc * subframe;
    uchar * name;
    struct uri * uri;
    int width;
    int height;
};

struct frameset_desc {
    int n;
    struct box box;
    struct frame_desc frame_desc[1];
};

struct screen_char {
    unicode_val_T data;
    uchar attr;
    uchar color[2];
};

struct sockaddr_storage {
    sa_family_t ss_family;
    ulong __ss_align;
    char __ss_padding[120];
};

struct active_link_options {
    uint color:1;
    uint underline:1;
    uint bold:1;
    uint invert:1;
    color_T fg;
    color_T bg;
};

struct text_style {
    enum text_style_format attr;
    color_T fg;
    color_T bg;
};

struct document_options {
    enum color_mode color_mode;
    int cp;
    int assume_cp;
    int hard_assume;
    int margin;
    int num_links_key;
    int use_document_colors;
    int meta_link_display;
    int default_form_input_size;
    struct text_style default_style;
    color_T default_link;
    color_T default_vlink;
    color_T default_bookmark_link;
    color_T default_image_link;
    enum color_flags color_flags;
    uint css_enable:1;
    uint css_import:1;
    uint tables:1;
    uint table_order:1;
    uint frames:1;
    uint images:1;
    uint display_subs:1;
    uint display_sups:1;
    uint underline_links:1;
    uint wrap_nbsp:1;
    uint plain_display_links:1;
    uint plain_compress_empty_lines:1;
    uint links_numbering:1;
    uint use_tabindex:1;
    uint plain:1;
    uint wrap:1;
    uchar * framename;
    struct box box;
    uint needs_height:1;
    uint needs_width:1;
    uint no_cache:1;
    uint gradual_rerendering:1;
    uint utf8:1;
    struct active_link_options active_link;
    struct anon_struct_28_7_ce8ae3d2_for_image_link image_link;
};

struct form_state {
    struct form_view * form_view;
    int g_ctrl_num;
    int position;
    enum form_type type;
    uchar * value;
    int state;
    int state_cell;
    int vpos;
    int vypos;
};

struct widget_info_checkbox {
    int gid;
    int gnum;
};

struct dialog_layout {
    uint maximize_width:1;
    uint padding_top:1;
    uint fit_datalen:1;
    uint float_groups:1;
    uint only_widgets:1;
};

struct stream_encoded {
    enum stream_encoding encoding;
    void * data;
};

struct document_refresh {
    timer_id_T timer;
    ulong seconds;
    struct uri * uri;
    uint restart:1;
};

struct widget_info_text {
    enum format_align align;
    uint is_label:1;
    uint is_scrollable:1;
};

struct widget_info_field {
    int min;
    int max;
    struct input_history * history;
    enum inpfield_flags flags;
};

struct widget_info_button {
    int flags;
    int hotkey_pos;
    int textlen;
    int truetextlen;
    void (* done)(void *);
    void * done_data;
};

union anon_union_24_4_73ccb3a3_for_info {
    struct widget_info_checkbox checkbox;
    struct widget_info_field field;
    struct widget_info_button button;
    struct widget_info_text text;
};

struct widget {
    struct widget_ops * ops;
    uchar * text;
    widget_handler_status_T (* handler)(struct dialog_data *, struct widget_data *);
    void * data;
    int datalen;
    union anon_union_24_4_73ccb3a3_for_info info;
    enum widget_type type;
};

struct ses_history {
    struct list_head_elinks history;
    struct location * current;
};

struct kbdprefix {
    int repeat_count;
    enum anon_enum_32 mark;
};

struct session {
    struct session * next;
    struct session * prev;
    struct window * tab;
    struct ses_history history;
    struct list_head_elinks more_files;
    struct download loading;
    struct uri * loading_uri;
    enum cache_mode reloadlevel;
    int redirect_cnt;
    struct document_view * doc_view;
    struct list_head_elinks scrn_frames;
    struct uri * download_uri;
    struct uri * referrer;
    struct session_task task;
    int search_direction;
    struct kbdprefix kbdprefix;
    int exit_query;
    timer_id_T display_timer;
    enum insert_mode insert_mode;
    enum navigate_mode navigate_mode;
    uchar * search_word;
    uchar * last_search_word;
    struct list_head_elinks type_queries;
    struct session_status status;
};

struct line {
    struct screen_char * chars;
    int length;
};

struct document {
    struct document * next;
    struct document * prev;
    struct object object;
    struct document_options options;
    struct list_head_elinks forms;
    struct list_head_elinks tags;
    struct list_head_elinks nodes;
    struct uri_list css_imports;
    ulong css_magic;
    struct uri * uri;
    uchar * title;
    struct cache_entry * cached;
    struct frame_desc * frame;
    struct frameset_desc * frame_desc;
    struct document_refresh * refresh;
    struct line * data;
    struct link * links;
    struct link * * lines1;
    struct link * * lines2;
    struct search * search;
    struct search * * slines1;
    struct search * * slines2;
    uchar buf[7];
    uchar buf_length;
    uint cache_id;
    int cp;
    int width;
    int height;
    int nlinks;
    int nsearch;
    color_T bgcolor;
    enum cp_status cp_status;
    uint links_sorted:1;
};

struct color_pair {
    color_T background;
    color_T foreground;
};

struct link {
    unicode_val_T accesskey;
    enum link_type type;
    uchar * where;
    uchar * target;
    uchar * where_img;
    uchar * title;
    struct point * points;
    int npoints;
    int number;
    struct color_pair color;
    struct list_head_elinks * event_hooks;
    union anon_union_4_2_0d81108a_for_data data;
};

struct listbox_data {
    struct listbox_data * next;
    struct listbox_data * prev;
    struct listbox_ops * ops;
    struct listbox_item * sel;
    struct listbox_item * top;
    int sel_offset;
    struct list_head_elinks * items;
};

struct document_view {
    struct document_view * next;
    struct document_view * prev;
    uchar * name;
    uchar * * search_word;
    struct session * session;
    struct document * document;
    struct view_state * vs;
    struct box box;
    int last_x;
    int last_y;
    int depth;
    int used;
};

struct point {
    int x;
    int y;
};

struct dialog {
    uchar * title;
    void * udata;
    void * udata2;
    struct dialog_refresh * refresh;
    void (* layouter)(struct dialog_data *);
    widget_handler_status_T (* handle_event)(struct dialog_data *);
    void (* abort)(struct dialog_data *);
    struct dialog_layout layout;
    int number_of_widgets;
    struct widget widgets[1];
};

struct timer {
    struct timer * next;
    struct timer * prev;
    struct timeval_T interval;
    void (* func)(void *);
    void * data;
};

struct socket_operations {
    socket_operation_T set_state;
    socket_operation_T set_timeout;
    socket_operation_T retry;
    socket_operation_T done;
};

struct listbox_item {
    struct listbox_item * next;
    struct listbox_item * prev;
    struct list_head_elinks child;
    enum listbox_item_type type;
    int depth;
    uint expanded:1;
    uint visible:1;
    uint marked:1;
    void * udata;
};

struct search {
    int x;
    int y;
    int n;
    unicode_val_T c;
};

struct listbox_ops {
    void (* lock)(struct listbox_item *);
    void (* unlock)(struct listbox_item *);
    int (* is_used)(struct listbox_item *);
    uchar * (* get_text)(struct listbox_item *, struct terminal *);
    uchar * (* get_info)(struct listbox_item *, struct terminal *);
    uri * (* get_uri)(struct listbox_item *);
    listbox_item * (* get_root)(struct listbox_item *);
    listbox_match (* match)(struct listbox_item *, struct terminal *, uchar *);
    int (* can_delete)(struct listbox_item *);
    void (* delete)(struct listbox_item *, int);
    void (* draw)(struct listbox_item *, struct listbox_context *, int, int, int);
    struct listbox_ops_messages * messages;
};

struct input_history_entry {
    struct input_history_entry * next;
    struct input_history_entry * prev;
    uchar data[1];
};

union option_value {
    struct list_head_elinks * tree;
    int number;
    long big_number;
    color_T color;
    uchar * (* command)(struct option_elinks *, uchar * * *, int *);
    uchar * string;
};

struct option_elinks {
    struct option_elinks * next;
    struct option_elinks * prev;
    struct object object;
    uchar * name;
    enum option_flags flags;
    enum option_type type;
    long min;
    long max;
    union option_value value;
    uchar * desc;
    uchar * capt;
    struct option_elinks * root;
    change_hook_T change_hook;
    struct listbox_item * box_item;
};

struct terminal {
    struct terminal * next;
    struct terminal * prev;
    struct list_head_elinks windows;
    struct option_elinks * spec;
    uchar * title;
    struct terminal_screen * screen;
    struct menu * main_menu;
    int fdin;
    int fdout;
    int blocked;
    int width;
    int height;
    enum term_redrawing_state redrawing;
    uint master:1;
    uint utf8_cp:1;
    uint utf8_io:1;
    int current_tab;
    int leds_length;
    enum term_env_type environment;
    uchar cwd[256];
    struct terminal_interlink * interlink;
    struct term_event_mouse prev_mouse_event;
};

struct menu {
    struct window * win;
    struct menu_item * items;
    int size;
    int selected;
    int first;
    int last;
    struct box box;
    int parent_x;
    int parent_y;
    int hotkeys;
    int lang;
    void * data;
};

struct uri {
    uchar * string;
    int protocol;
    int ip_family;
    uchar * user;
    uchar * password;
    uchar * host;
    uchar * port;
    uchar * data;
    uchar * fragment;
    uchar * post;
    uint protocollen:16;
    uint userlen:16;
    uint passwordlen:16;
    uint hostlen:16;
    uint portlen:8;
    uint datalen:16;
    uint fragmentlen:16;
    uint ipv6:1;
    uint form:1;
    struct object object;
};

struct listbox_ops_messages {
    uchar * cant_delete_item;
    uchar * cant_delete_used_item;
    uchar * cant_delete_folder;
    uchar * cant_delete_used_folder;
    uchar * delete_marked_items_title;
    uchar * delete_marked_items;
    uchar * delete_folder_title;
    uchar * delete_folder;
    uchar * delete_item_title;
    uchar * delete_item;
    uchar * clear_all_items_title;
    uchar * clear_all_items;
};

struct term_event {
    enum term_event_type ev;
    union anon_union_12_3_3ebaaa1f_for_info info;
};

struct form_control {
    struct form_control * next;
    struct form_control * prev;
    struct form * form;
    int g_ctrl_num;
    int position;
    enum form_type type;
    enum form_mode mode;
    uchar * id;
    uchar * name;
    uchar * alt;
    uchar * default_value;
    int default_state;
    int size;
    int cols;
    int rows;
    enum form_wrap wrap;
    int maxlength;
    int nvalues;
    uchar * * values;
    uchar * * labels;
    struct menu_item * menu;
};

struct connect_info {
    struct sockaddr_storage * addr;
    int addrno;
    int triedno;
    socket_connect_T done;
    void * dnsquery;
    int port;
    int ip_family;
    struct uri * uri;
};

struct form {
    struct form * next;
    struct form * prev;
    int form_num;
    int form_end;
    uchar * action;
    uchar * name;
    uchar * onsubmit;
    uchar * target;
    enum form_method method;
    struct list_head_elinks items;
};

struct progress {
    struct timeval_T elapsed;
    struct timeval_T last_time;
    struct timeval_T dis_b;
    struct timeval_T estimated_time;
    int average_speed;
    int current_speed;
    uint valid:1;
    off_t size;
    off_t loaded;
    off_t last_loaded;
    off_t cur_loaded;
    off_t start;
    off_t pos;
    off_t seek;
    timer_id_T timer;
    void (* timer_func)(void *);
    void * timer_func_data;
    int data_in_secs[50];
};

struct location {
    struct location * next;
    struct location * prev;
    struct list_head_elinks frames;
    struct download download;
    struct view_state vs;
};

struct window {
    struct window * next;
    struct window * prev;
    enum window_type type;
    void (* handler)(struct window *, struct term_event *);
    void * data;
    struct terminal * term;
    int xpos;
    int width;
    int x;
    int y;
    uint resize:1;
};

struct socket {
    int fd;
    enum socket_state state;
    void * conn;
    struct connect_info * connect_info;
    struct read_buffer * read_buffer;
    void * write_buffer;
    struct socket_operations * ops;
    socket_read_T read_done;
    void * ssl;
    uint protocol_family:1;
    uint need_ssl:1;
    uint no_tls:1;
    uint set_no_tls:1;
    uint duplex:1;
};

struct listbox_context {
    struct terminal * term;
    struct listbox_item * item;
    struct listbox_data * box;
    struct dialog_data * dlg_data;
    struct widget_data * widget_data;
    int dist;
    int offset;
};

typedef struct screen_state screen_state, *Pscreen_state;

struct screen_state {
    uchar border;
    uchar underline;
    uchar bold;
    uchar attr;
    uchar color[2];
};

typedef struct screen_driver_opt screen_driver_opt, *Pscreen_driver_opt;


// WARNING! conflicting data type names: /DWARF/string.h/string - /string

struct screen_driver_opt {
    int charsets[2];
    uchar * frame;
    struct string * frame_seqs;
    struct string * underline;
    enum color_mode color_mode;
    uint transparent:1;
    uint utf8_cp:1;
};

typedef struct screen_driver screen_driver, *Pscreen_driver;

typedef enum term_mode_type {
    TERM_DUMB=0,
    TERM_VT100=1,
    TERM_LINUX=2,
    TERM_KOI8=3,
    TERM_FREEBSD=4
} term_mode_type;

struct screen_driver {
    struct screen_driver * next;
    struct screen_driver * prev;
    enum term_mode_type type;
    struct screen_driver_opt opt;
    uchar name[1];
};

typedef uint_least32_t globus_uint_t;

typedef globus_uint_t OM_uint32;

typedef struct gss_ctx_id_desc_struct gss_ctx_id_desc_struct, *Pgss_ctx_id_desc_struct;

typedef struct gss_ctx_id_desc_struct * gss_ctx_id_t;

struct gss_ctx_id_desc_struct {
};

typedef struct gss_OID_desc_struct gss_OID_desc_struct, *Pgss_OID_desc_struct;

typedef struct gss_OID_desc_struct * gss_OID;

struct gss_OID_desc_struct {
    OM_uint32 length;
    void * elements;
};

typedef struct gss_name_desc_struct gss_name_desc_struct, *Pgss_name_desc_struct;

typedef struct gss_name_desc_struct * gss_name_t;

struct gss_name_desc_struct {
};

typedef struct gss_buffer_desc_struct gss_buffer_desc_struct, *Pgss_buffer_desc_struct;

struct gss_buffer_desc_struct {
    size_t length;
    void * value;
};

typedef struct gss_buffer_desc_struct gss_buffer_desc;

typedef struct gss_channel_bindings_struct gss_channel_bindings_struct, *Pgss_channel_bindings_struct;

struct gss_channel_bindings_struct {
    OM_uint32 initiator_addrtype;
    gss_buffer_desc initiator_address;
    OM_uint32 acceptor_addrtype;
    gss_buffer_desc acceptor_address;
    gss_buffer_desc application_data;
};

typedef char * __gnuc_va_list;

typedef enum docbook_attribute_type {
    DOCBOOK_ATTRIBUTE_UNKNOWN=0,
    DOCBOOK_ATTRIBUTE_ABBR=1,
    DOCBOOK_ATTRIBUTE_ACTION=2,
    DOCBOOK_ATTRIBUTE_ALIGN=3,
    DOCBOOK_ATTRIBUTE_APPLICATION=4,
    DOCBOOK_ATTRIBUTE_ARCH=5,
    DOCBOOK_ATTRIBUTE_AREAREFS=6,
    DOCBOOK_ATTRIBUTE_AUDIENCE=7,
    DOCBOOK_ATTRIBUTE_AXIS=8,
    DOCBOOK_ATTRIBUTE_BASEFORM=9,
    DOCBOOK_ATTRIBUTE_BGCOLOR=10,
    DOCBOOK_ATTRIBUTE_BORDER=11,
    DOCBOOK_ATTRIBUTE_CELLSPACING=12,
    DOCBOOK_ATTRIBUTE_CHAR=13,
    DOCBOOK_ATTRIBUTE_CHAROFF=14,
    DOCBOOK_ATTRIBUTE_CHOICE=15,
    DOCBOOK_ATTRIBUTE_CLASS=16,
    DOCBOOK_ATTRIBUTE_CMDLENGTH=17,
    DOCBOOK_ATTRIBUTE_COLNAME=18,
    DOCBOOK_ATTRIBUTE_COLNUM=19,
    DOCBOOK_ATTRIBUTE_COLNUMS=20,
    DOCBOOK_ATTRIBUTE_COLS=21,
    DOCBOOK_ATTRIBUTE_COLSEP=22,
    DOCBOOK_ATTRIBUTE_COLSPAN=23,
    DOCBOOK_ATTRIBUTE_COLWIDTH=24,
    DOCBOOK_ATTRIBUTE_CONDITION=25,
    DOCBOOK_ATTRIBUTE_CONFORMANCE=26,
    DOCBOOK_ATTRIBUTE_CONTENTDEPTH=27,
    DOCBOOK_ATTRIBUTE_CONTENTS=28,
    DOCBOOK_ATTRIBUTE_CONTENTWIDTH=29,
    DOCBOOK_ATTRIBUTE_CONTINUATION=30,
    DOCBOOK_ATTRIBUTE_COORDS=31,
    DOCBOOK_ATTRIBUTE_DEF=32,
    DOCBOOK_ATTRIBUTE_DEFAULTLABEL=33,
    DOCBOOK_ATTRIBUTE_DEPTH=34,
    DOCBOOK_ATTRIBUTE_ENCODING=35,
    DOCBOOK_ATTRIBUTE_ENDTERM=36,
    DOCBOOK_ATTRIBUTE_ENTITYREF=37,
    DOCBOOK_ATTRIBUTE_FILEREF=38,
    DOCBOOK_ATTRIBUTE_FLOAT=39,
    DOCBOOK_ATTRIBUTE_FLOATSTYLE=40,
    DOCBOOK_ATTRIBUTE_FORMAT=41,
    DOCBOOK_ATTRIBUTE_FPI=42,
    DOCBOOK_ATTRIBUTE_FRAME=43,
    DOCBOOK_ATTRIBUTE_FUNCTION=44,
    DOCBOOK_ATTRIBUTE_HEADERS=45,
    DOCBOOK_ATTRIBUTE_HEIGHT=46,
    DOCBOOK_ATTRIBUTE_ID=47,
    DOCBOOK_ATTRIBUTE_INHERITNUM=48,
    DOCBOOK_ATTRIBUTE_LABEL=49,
    DOCBOOK_ATTRIBUTE_LANG=50,
    DOCBOOK_ATTRIBUTE_LANGUAGE=51,
    DOCBOOK_ATTRIBUTE_LEVEL=52,
    DOCBOOK_ATTRIBUTE_LINENUMBERING=53,
    DOCBOOK_ATTRIBUTE_LINKEND=54,
    DOCBOOK_ATTRIBUTE_LINKENDS=55,
    DOCBOOK_ATTRIBUTE_LINKMODE=56,
    DOCBOOK_ATTRIBUTE_LOCALINFO=57,
    DOCBOOK_ATTRIBUTE_MARK=58,
    DOCBOOK_ATTRIBUTE_MOREINFO=59,
    DOCBOOK_ATTRIBUTE_MOREROWS=60,
    DOCBOOK_ATTRIBUTE_NAMEEND=61,
    DOCBOOK_ATTRIBUTE_NAMESPACE=62,
    DOCBOOK_ATTRIBUTE_NAMEST=63,
    DOCBOOK_ATTRIBUTE_NOWRAP=64,
    DOCBOOK_ATTRIBUTE_NUMERATION=65,
    DOCBOOK_ATTRIBUTE_ONCLICK=66,
    DOCBOOK_ATTRIBUTE_ONDBLCLICK=67,
    DOCBOOK_ATTRIBUTE_ONKEYDOWN=68,
    DOCBOOK_ATTRIBUTE_ONKEYPRESS=69,
    DOCBOOK_ATTRIBUTE_ONKEYUP=70,
    DOCBOOK_ATTRIBUTE_ONMOUSEDOWN=71,
    DOCBOOK_ATTRIBUTE_ONMOUSEMOVE=72,
    DOCBOOK_ATTRIBUTE_ONMOUSEOUT=73,
    DOCBOOK_ATTRIBUTE_ONMOUSEOVER=74,
    DOCBOOK_ATTRIBUTE_ONMOUSEUP=75,
    DOCBOOK_ATTRIBUTE_ORIENT=76,
    DOCBOOK_ATTRIBUTE_ORIGIN=77,
    DOCBOOK_ATTRIBUTE_OS=78,
    DOCBOOK_ATTRIBUTE_OTHERACTION=79,
    DOCBOOK_ATTRIBUTE_OTHERCLASS=80,
    DOCBOOK_ATTRIBUTE_OTHERFUNCTION=81,
    DOCBOOK_ATTRIBUTE_OTHERSPATIAL=82,
    DOCBOOK_ATTRIBUTE_OTHERTEMPORAL=83,
    DOCBOOK_ATTRIBUTE_OTHERTERM=84,
    DOCBOOK_ATTRIBUTE_OTHERTYPE=85,
    DOCBOOK_ATTRIBUTE_OTHERUNITS=86,
    DOCBOOK_ATTRIBUTE_OVERRIDE=87,
    DOCBOOK_ATTRIBUTE_PAGENUM=88,
    DOCBOOK_ATTRIBUTE_PARENTBOOK=89,
    DOCBOOK_ATTRIBUTE_PATH=90,
    DOCBOOK_ATTRIBUTE_PERFORMANCE=91,
    DOCBOOK_ATTRIBUTE_PGWIDE=92,
    DOCBOOK_ATTRIBUTE_PUBWORK=93,
    DOCBOOK_ATTRIBUTE_RELATION=94,
    DOCBOOK_ATTRIBUTE_REMAP=95,
    DOCBOOK_ATTRIBUTE_RENDERAS=96,
    DOCBOOK_ATTRIBUTE_REP=97,
    DOCBOOK_ATTRIBUTE_REVISION=98,
    DOCBOOK_ATTRIBUTE_REVISIONFLAG=99,
    DOCBOOK_ATTRIBUTE_ROLE=100,
    DOCBOOK_ATTRIBUTE_ROTATE=101,
    DOCBOOK_ATTRIBUTE_ROWSEP=102,
    DOCBOOK_ATTRIBUTE_ROWSPAN=103,
    DOCBOOK_ATTRIBUTE_RULES=104,
    DOCBOOK_ATTRIBUTE_SCALE=105,
    DOCBOOK_ATTRIBUTE_SCALEFIT=106,
    DOCBOOK_ATTRIBUTE_SCHEME=107,
    DOCBOOK_ATTRIBUTE_SCOPE=108,
    DOCBOOK_ATTRIBUTE_SECURITY=109,
    DOCBOOK_ATTRIBUTE_SEPCHAR=110,
    DOCBOOK_ATTRIBUTE_SHORTENTRY=111,
    DOCBOOK_ATTRIBUTE_SIGNIFICANCE=112,
    DOCBOOK_ATTRIBUTE_SORTAS=113,
    DOCBOOK_ATTRIBUTE_SPACING=114,
    DOCBOOK_ATTRIBUTE_SPAN=115,
    DOCBOOK_ATTRIBUTE_SPANNAME=116,
    DOCBOOK_ATTRIBUTE_SPATIAL=117,
    DOCBOOK_ATTRIBUTE_SRCCREDIT=118,
    DOCBOOK_ATTRIBUTE_STARTINGLINENUMBER=119,
    DOCBOOK_ATTRIBUTE_STARTREF=120,
    DOCBOOK_ATTRIBUTE_STATUS=121,
    DOCBOOK_ATTRIBUTE_STYLE=122,
    DOCBOOK_ATTRIBUTE_SUBJECT=123,
    DOCBOOK_ATTRIBUTE_SUMMARY=124,
    DOCBOOK_ATTRIBUTE_TABSTYLE=125,
    DOCBOOK_ATTRIBUTE_TARGETDOC=126,
    DOCBOOK_ATTRIBUTE_TARGETDOCENT=127,
    DOCBOOK_ATTRIBUTE_TARGETPTR=128,
    DOCBOOK_ATTRIBUTE_TEMPORAL=129,
    DOCBOOK_ATTRIBUTE_TERMLENGTH=130,
    DOCBOOK_ATTRIBUTE_TGROUPSTYLE=131,
    DOCBOOK_ATTRIBUTE_TITLE=132,
    DOCBOOK_ATTRIBUTE_TOCENTRY=133,
    DOCBOOK_ATTRIBUTE_TYPE=134,
    DOCBOOK_ATTRIBUTE_UNITS=135,
    DOCBOOK_ATTRIBUTE_URL=136,
    DOCBOOK_ATTRIBUTE_USERLEVEL=137,
    DOCBOOK_ATTRIBUTE_VALIGN=138,
    DOCBOOK_ATTRIBUTE_VENDOR=139,
    DOCBOOK_ATTRIBUTE_WEIGTH=140,
    DOCBOOK_ATTRIBUTE_WIDTH=141,
    DOCBOOK_ATTRIBUTE_XREFLABEL=142,
    DOCBOOK_ATTRIBUTE_XREFSTYLE=143,
    DOCBOOK_ATTRIBUTE_ZONE=144,
    DOCBOOK_ATTRIBUTES=145
} docbook_attribute_type;

typedef enum docbook_element_type {
    DOCBOOK_ELEMENT_UNKNOWN=0,
    DOCBOOK_ELEMENT_ABBREV=1,
    DOCBOOK_ELEMENT_ABSTRACT=2,
    DOCBOOK_ELEMENT_ACCEL=3,
    DOCBOOK_ELEMENT_ACKNO=4,
    DOCBOOK_ELEMENT_ACRONYM=5,
    DOCBOOK_ELEMENT_ACTION=6,
    DOCBOOK_ELEMENT_ADDRESS=7,
    DOCBOOK_ELEMENT_AFFILIATION=8,
    DOCBOOK_ELEMENT_ALT=9,
    DOCBOOK_ELEMENT_ANCHOR=10,
    DOCBOOK_ELEMENT_ANSWER=11,
    DOCBOOK_ELEMENT_APPENDIX=12,
    DOCBOOK_ELEMENT_APPENDIXINFO=13,
    DOCBOOK_ELEMENT_APPLICATION=14,
    DOCBOOK_ELEMENT_AREA=15,
    DOCBOOK_ELEMENT_AREASET=16,
    DOCBOOK_ELEMENT_AREASPEC=17,
    DOCBOOK_ELEMENT_ARG=18,
    DOCBOOK_ELEMENT_ARTICLE=19,
    DOCBOOK_ELEMENT_ARTICLEINFO=20,
    DOCBOOK_ELEMENT_ARTPAGENUMS=21,
    DOCBOOK_ELEMENT_ATTRIBUTION=22,
    DOCBOOK_ELEMENT_AUDIODATA=23,
    DOCBOOK_ELEMENT_AUDIOOBJECT=24,
    DOCBOOK_ELEMENT_AUTHOR=25,
    DOCBOOK_ELEMENT_AUTHORBLURB=26,
    DOCBOOK_ELEMENT_AUTHORGROUP=27,
    DOCBOOK_ELEMENT_AUTHORINITIALS=28,
    DOCBOOK_ELEMENT_BEGINPAGE=29,
    DOCBOOK_ELEMENT_BIBLIOCOVERAGE=30,
    DOCBOOK_ELEMENT_BIBLIODIV=31,
    DOCBOOK_ELEMENT_BIBLIOENTRY=32,
    DOCBOOK_ELEMENT_BIBLIOGRAPHY=33,
    DOCBOOK_ELEMENT_BIBLIOGRAPHYINFO=34,
    DOCBOOK_ELEMENT_BIBLIOID=35,
    DOCBOOK_ELEMENT_BIBLIOMISC=36,
    DOCBOOK_ELEMENT_BIBLIOMIXED=37,
    DOCBOOK_ELEMENT_BIBLIOMSET=38,
    DOCBOOK_ELEMENT_BIBLIORELATION=39,
    DOCBOOK_ELEMENT_BIBLIOSET=40,
    DOCBOOK_ELEMENT_BIBLIOSOURCE=41,
    DOCBOOK_ELEMENT_BLOCKINFO=42,
    DOCBOOK_ELEMENT_BLOCKQUOTE=43,
    DOCBOOK_ELEMENT_BOOK=44,
    DOCBOOK_ELEMENT_BOOKINFO=45,
    DOCBOOK_ELEMENT_BRIDGEHEAD=46,
    DOCBOOK_ELEMENT_CALLOUT=47,
    DOCBOOK_ELEMENT_CALLOUTLIST=48,
    DOCBOOK_ELEMENT_CAPTION=49,
    DOCBOOK_ELEMENT_CAUTION=50,
    DOCBOOK_ELEMENT_CHAPTER=51,
    DOCBOOK_ELEMENT_CHAPTERINFO=52,
    DOCBOOK_ELEMENT_CITATION=53,
    DOCBOOK_ELEMENT_CITEBIBLIOID=54,
    DOCBOOK_ELEMENT_CITEREFENTRY=55,
    DOCBOOK_ELEMENT_CITETITLE=56,
    DOCBOOK_ELEMENT_CITY=57,
    DOCBOOK_ELEMENT_CLASSNAME=58,
    DOCBOOK_ELEMENT_CLASSSYNOPSIS=59,
    DOCBOOK_ELEMENT_CLASSSYNOPSISINFO=60,
    DOCBOOK_ELEMENT_CMDSYNOPSIS=61,
    DOCBOOK_ELEMENT_CO=62,
    DOCBOOK_ELEMENT_CODE=63,
    DOCBOOK_ELEMENT_COL=64,
    DOCBOOK_ELEMENT_COLGROUP=65,
    DOCBOOK_ELEMENT_COLLAB=66,
    DOCBOOK_ELEMENT_COLLABNAME=67,
    DOCBOOK_ELEMENT_COLOPHON=68,
    DOCBOOK_ELEMENT_COLSPEC=69,
    DOCBOOK_ELEMENT_COMMAND=70,
    DOCBOOK_ELEMENT_COMPUTEROUTPUT=71,
    DOCBOOK_ELEMENT_CONFDATES=72,
    DOCBOOK_ELEMENT_CONFGROUP=73,
    DOCBOOK_ELEMENT_CONFNUM=74,
    DOCBOOK_ELEMENT_CONFSPONSOR=75,
    DOCBOOK_ELEMENT_CONFTITLE=76,
    DOCBOOK_ELEMENT_CONSTANT=77,
    DOCBOOK_ELEMENT_CONSTRAINT=78,
    DOCBOOK_ELEMENT_CONSTRAINTDEF=79,
    DOCBOOK_ELEMENT_CONSTRUCTORSYNOPSIS=80,
    DOCBOOK_ELEMENT_CONTRACTNUM=81,
    DOCBOOK_ELEMENT_CONTRACTSPONSOR=82,
    DOCBOOK_ELEMENT_CONTRIB=83,
    DOCBOOK_ELEMENT_COPYRIGHT=84,
    DOCBOOK_ELEMENT_COREF=85,
    DOCBOOK_ELEMENT_CORPAUTHOR=86,
    DOCBOOK_ELEMENT_CORPCREDIT=87,
    DOCBOOK_ELEMENT_CORPNAME=88,
    DOCBOOK_ELEMENT_COUNTRY=89,
    DOCBOOK_ELEMENT_DATABASE=90,
    DOCBOOK_ELEMENT_DATE=91,
    DOCBOOK_ELEMENT_DEDICATION=92,
    DOCBOOK_ELEMENT_DESTRUCTORSYNOPSIS=93,
    DOCBOOK_ELEMENT_EDITION=94,
    DOCBOOK_ELEMENT_EDITOR=95,
    DOCBOOK_ELEMENT_EMAIL=96,
    DOCBOOK_ELEMENT_EMPHASIS=97,
    DOCBOOK_ELEMENT_ENTRY=98,
    DOCBOOK_ELEMENT_ENTRYTBL=99,
    DOCBOOK_ELEMENT_ENVAR=100,
    DOCBOOK_ELEMENT_EPIGRAPH=101,
    DOCBOOK_ELEMENT_EQUATION=102,
    DOCBOOK_ELEMENT_ERRORCODE=103,
    DOCBOOK_ELEMENT_ERRORNAME=104,
    DOCBOOK_ELEMENT_ERRORTEXT=105,
    DOCBOOK_ELEMENT_ERRORTYPE=106,
    DOCBOOK_ELEMENT_EXAMPLE=107,
    DOCBOOK_ELEMENT_EXCEPTIONNAME=108,
    DOCBOOK_ELEMENT_FAX=109,
    DOCBOOK_ELEMENT_FIELDSYNOPSIS=110,
    DOCBOOK_ELEMENT_FIGURE=111,
    DOCBOOK_ELEMENT_FILENAME=112,
    DOCBOOK_ELEMENT_FIRSTNAME=113,
    DOCBOOK_ELEMENT_FIRSTTERM=114,
    DOCBOOK_ELEMENT_FOOTNOTE=115,
    DOCBOOK_ELEMENT_FOOTNOTEREF=116,
    DOCBOOK_ELEMENT_FOREIGNPHRASE=117,
    DOCBOOK_ELEMENT_FORMALPARA=118,
    DOCBOOK_ELEMENT_FUNCDEF=119,
    DOCBOOK_ELEMENT_FUNCPARAMS=120,
    DOCBOOK_ELEMENT_FUNCPROTOTYPE=121,
    DOCBOOK_ELEMENT_FUNCSYNOPSIS=122,
    DOCBOOK_ELEMENT_FUNCSYNOPSISINFO=123,
    DOCBOOK_ELEMENT_FUNCTION=124,
    DOCBOOK_ELEMENT_GLOSSARY=125,
    DOCBOOK_ELEMENT_GLOSSARYINFO=126,
    DOCBOOK_ELEMENT_GLOSSDEF=127,
    DOCBOOK_ELEMENT_GLOSSDIV=128,
    DOCBOOK_ELEMENT_GLOSSENTRY=129,
    DOCBOOK_ELEMENT_GLOSSLIST=130,
    DOCBOOK_ELEMENT_GLOSSSEE=131,
    DOCBOOK_ELEMENT_GLOSSSEEALSO=132,
    DOCBOOK_ELEMENT_GLOSSTERM=133,
    DOCBOOK_ELEMENT_GRAPHIC=134,
    DOCBOOK_ELEMENT_GRAPHICCO=135,
    DOCBOOK_ELEMENT_GROUP=136,
    DOCBOOK_ELEMENT_GUIBUTTON=137,
    DOCBOOK_ELEMENT_GUIICON=138,
    DOCBOOK_ELEMENT_GUILABEL=139,
    DOCBOOK_ELEMENT_GUIMENU=140,
    DOCBOOK_ELEMENT_GUIMENUITEM=141,
    DOCBOOK_ELEMENT_GUISUBMENU=142,
    DOCBOOK_ELEMENT_HARDWARE=143,
    DOCBOOK_ELEMENT_HIGHLIGHTS=144,
    DOCBOOK_ELEMENT_HOLDER=145,
    DOCBOOK_ELEMENT_HONORIFIC=146,
    DOCBOOK_ELEMENT_IMAGEDATA=147,
    DOCBOOK_ELEMENT_IMAGEOBJECT=148,
    DOCBOOK_ELEMENT_IMAGEOBJECTCO=149,
    DOCBOOK_ELEMENT_IMPORTANT=150,
    DOCBOOK_ELEMENT_INDEX=151,
    DOCBOOK_ELEMENT_INDEXDIV=152,
    DOCBOOK_ELEMENT_INDEXENTRY=153,
    DOCBOOK_ELEMENT_INDEXINFO=154,
    DOCBOOK_ELEMENT_INDEXTERM=155,
    DOCBOOK_ELEMENT_INFORMALEQUATION=156,
    DOCBOOK_ELEMENT_INFORMALEXAMPLE=157,
    DOCBOOK_ELEMENT_INFORMALFIGURE=158,
    DOCBOOK_ELEMENT_INFORMALTABLE=159,
    DOCBOOK_ELEMENT_INITIALIZER=160,
    DOCBOOK_ELEMENT_INLINEEQUATION=161,
    DOCBOOK_ELEMENT_INLINEGRAPHIC=162,
    DOCBOOK_ELEMENT_INLINEMEDIAOBJECT=163,
    DOCBOOK_ELEMENT_INTERFACE=164,
    DOCBOOK_ELEMENT_INTERFACENAME=165,
    DOCBOOK_ELEMENT_INVPARTNUMBER=166,
    DOCBOOK_ELEMENT_ISBN=167,
    DOCBOOK_ELEMENT_ISSN=168,
    DOCBOOK_ELEMENT_ISSUENUM=169,
    DOCBOOK_ELEMENT_ITEMIZEDLIST=170,
    DOCBOOK_ELEMENT_ITERMSET=171,
    DOCBOOK_ELEMENT_JOBTITLE=172,
    DOCBOOK_ELEMENT_KEYCAP=173,
    DOCBOOK_ELEMENT_KEYCODE=174,
    DOCBOOK_ELEMENT_KEYCOMBO=175,
    DOCBOOK_ELEMENT_KEYSYM=176,
    DOCBOOK_ELEMENT_KEYWORD=177,
    DOCBOOK_ELEMENT_KEYWORDSET=178,
    DOCBOOK_ELEMENT_LABEL=179,
    DOCBOOK_ELEMENT_LEGALNOTICE=180,
    DOCBOOK_ELEMENT_LHS=181,
    DOCBOOK_ELEMENT_LINEAGE=182,
    DOCBOOK_ELEMENT_LINEANNOTATION=183,
    DOCBOOK_ELEMENT_LINK=184,
    DOCBOOK_ELEMENT_LISTITEM=185,
    DOCBOOK_ELEMENT_LITERAL=186,
    DOCBOOK_ELEMENT_LITERALLAYOUT=187,
    DOCBOOK_ELEMENT_LOT=188,
    DOCBOOK_ELEMENT_LOTENTRY=189,
    DOCBOOK_ELEMENT_MANVOLNUM=190,
    DOCBOOK_ELEMENT_MARKUP=191,
    DOCBOOK_ELEMENT_MEDIALABEL=192,
    DOCBOOK_ELEMENT_MEDIAOBJECT=193,
    DOCBOOK_ELEMENT_MEDIAOBJECTCO=194,
    DOCBOOK_ELEMENT_MEMBER=195,
    DOCBOOK_ELEMENT_MENUCHOICE=196,
    DOCBOOK_ELEMENT_METHODNAME=197,
    DOCBOOK_ELEMENT_METHODPARAM=198,
    DOCBOOK_ELEMENT_METHODSYNOPSIS=199,
    DOCBOOK_ELEMENT_MODESPEC=200,
    DOCBOOK_ELEMENT_MODIFIER=201,
    DOCBOOK_ELEMENT_MOUSEBUTTON=202,
    DOCBOOK_ELEMENT_MSG=203,
    DOCBOOK_ELEMENT_MSGAUD=204,
    DOCBOOK_ELEMENT_MSGENTRY=205,
    DOCBOOK_ELEMENT_MSGEXPLAN=206,
    DOCBOOK_ELEMENT_MSGINFO=207,
    DOCBOOK_ELEMENT_MSGLEVEL=208,
    DOCBOOK_ELEMENT_MSGMAIN=209,
    DOCBOOK_ELEMENT_MSGORIG=210,
    DOCBOOK_ELEMENT_MSGREL=211,
    DOCBOOK_ELEMENT_MSGSET=212,
    DOCBOOK_ELEMENT_MSGSUB=213,
    DOCBOOK_ELEMENT_MSGTEXT=214,
    DOCBOOK_ELEMENT_NONTERMINAL=215,
    DOCBOOK_ELEMENT_NOTE=216,
    DOCBOOK_ELEMENT_OBJECTINFO=217,
    DOCBOOK_ELEMENT_OLINK=218,
    DOCBOOK_ELEMENT_OOCLASS=219,
    DOCBOOK_ELEMENT_OOEXCEPTION=220,
    DOCBOOK_ELEMENT_OOINTERFACE=221,
    DOCBOOK_ELEMENT_OPTION=222,
    DOCBOOK_ELEMENT_OPTIONAL=223,
    DOCBOOK_ELEMENT_ORDEREDLIST=224,
    DOCBOOK_ELEMENT_ORGDIV=225,
    DOCBOOK_ELEMENT_ORGNAME=226,
    DOCBOOK_ELEMENT_OTHERADDR=227,
    DOCBOOK_ELEMENT_OTHERCREDIT=228,
    DOCBOOK_ELEMENT_OTHERNAME=229,
    DOCBOOK_ELEMENT_PAGENUMS=230,
    DOCBOOK_ELEMENT_PARA=231,
    DOCBOOK_ELEMENT_PARAMDEF=232,
    DOCBOOK_ELEMENT_PARAMETER=233,
    DOCBOOK_ELEMENT_PART=234,
    DOCBOOK_ELEMENT_PARTINFO=235,
    DOCBOOK_ELEMENT_PARTINTRO=236,
    DOCBOOK_ELEMENT_PERSONBLURB=237,
    DOCBOOK_ELEMENT_PERSONNAME=238,
    DOCBOOK_ELEMENT_PHONE=239,
    DOCBOOK_ELEMENT_PHRASE=240,
    DOCBOOK_ELEMENT_POB=241,
    DOCBOOK_ELEMENT_POSTCODE=242,
    DOCBOOK_ELEMENT_PREFACE=243,
    DOCBOOK_ELEMENT_PREFACEINFO=244,
    DOCBOOK_ELEMENT_PRIMARY=245,
    DOCBOOK_ELEMENT_PRIMARYIE=246,
    DOCBOOK_ELEMENT_PRINTHISTORY=247,
    DOCBOOK_ELEMENT_PROCEDURE=248,
    DOCBOOK_ELEMENT_PRODUCTION=249,
    DOCBOOK_ELEMENT_PRODUCTIONRECAP=250,
    DOCBOOK_ELEMENT_PRODUCTIONSET=251,
    DOCBOOK_ELEMENT_PRODUCTNAME=252,
    DOCBOOK_ELEMENT_PRODUCTNUMBER=253,
    DOCBOOK_ELEMENT_PROGRAMLISTING=254,
    DOCBOOK_ELEMENT_PROGRAMLISTINGCO=255,
    DOCBOOK_ELEMENT_PROMPT=256,
    DOCBOOK_ELEMENT_PROPERTY=257,
    DOCBOOK_ELEMENT_PUBDATE=258,
    DOCBOOK_ELEMENT_PUBLISHER=259,
    DOCBOOK_ELEMENT_PUBLISHERNAME=260,
    DOCBOOK_ELEMENT_PUBSNUMBER=261,
    DOCBOOK_ELEMENT_QANDADIV=262,
    DOCBOOK_ELEMENT_QANDAENTRY=263,
    DOCBOOK_ELEMENT_QANDASET=264,
    DOCBOOK_ELEMENT_QUESTION=265,
    DOCBOOK_ELEMENT_QUOTE=266,
    DOCBOOK_ELEMENT_REFCLASS=267,
    DOCBOOK_ELEMENT_REFDESCRIPTOR=268,
    DOCBOOK_ELEMENT_REFENTRY=269,
    DOCBOOK_ELEMENT_REFENTRYINFO=270,
    DOCBOOK_ELEMENT_REFENTRYTITLE=271,
    DOCBOOK_ELEMENT_REFERENCE=272,
    DOCBOOK_ELEMENT_REFERENCEINFO=273,
    DOCBOOK_ELEMENT_REFMETA=274,
    DOCBOOK_ELEMENT_REFMISCINFO=275,
    DOCBOOK_ELEMENT_REFNAME=276,
    DOCBOOK_ELEMENT_REFNAMEDIV=277,
    DOCBOOK_ELEMENT_REFPURPOSE=278,
    DOCBOOK_ELEMENT_REFSECT1=279,
    DOCBOOK_ELEMENT_REFSECT1INFO=280,
    DOCBOOK_ELEMENT_REFSECT2=281,
    DOCBOOK_ELEMENT_REFSECT2INFO=282,
    DOCBOOK_ELEMENT_REFSECT3=283,
    DOCBOOK_ELEMENT_REFSECT3INFO=284,
    DOCBOOK_ELEMENT_REFSECTION=285,
    DOCBOOK_ELEMENT_REFSECTIONINFO=286,
    DOCBOOK_ELEMENT_REFSYNOPSISDIV=287,
    DOCBOOK_ELEMENT_REFSYNOPSISDIVINFO=288,
    DOCBOOK_ELEMENT_RELEASEINFO=289,
    DOCBOOK_ELEMENT_REMARK=290,
    DOCBOOK_ELEMENT_REPLACEABLE=291,
    DOCBOOK_ELEMENT_RETURNVALUE=292,
    DOCBOOK_ELEMENT_REVDESCRIPTION=293,
    DOCBOOK_ELEMENT_REVHISTORY=294,
    DOCBOOK_ELEMENT_REVISION=295,
    DOCBOOK_ELEMENT_REVNUMBER=296,
    DOCBOOK_ELEMENT_REVREMARK=297,
    DOCBOOK_ELEMENT_RHS=298,
    DOCBOOK_ELEMENT_ROW=299,
    DOCBOOK_ELEMENT_SBR=300,
    DOCBOOK_ELEMENT_SCREEN=301,
    DOCBOOK_ELEMENT_SCREENCO=302,
    DOCBOOK_ELEMENT_SCREENINFO=303,
    DOCBOOK_ELEMENT_SCREENSHOT=304,
    DOCBOOK_ELEMENT_SECONDARY=305,
    DOCBOOK_ELEMENT_SECONDARYIE=306,
    DOCBOOK_ELEMENT_SECT1=307,
    DOCBOOK_ELEMENT_SECT1INFO=308,
    DOCBOOK_ELEMENT_SECT2=309,
    DOCBOOK_ELEMENT_SECT2INFO=310,
    DOCBOOK_ELEMENT_SECT3=311,
    DOCBOOK_ELEMENT_SECT3INFO=312,
    DOCBOOK_ELEMENT_SECT4=313,
    DOCBOOK_ELEMENT_SECT4INFO=314,
    DOCBOOK_ELEMENT_SECT5=315,
    DOCBOOK_ELEMENT_SECT5INFO=316,
    DOCBOOK_ELEMENT_SECTION=317,
    DOCBOOK_ELEMENT_SECTIONINFO=318,
    DOCBOOK_ELEMENT_SEE=319,
    DOCBOOK_ELEMENT_SEEALSO=320,
    DOCBOOK_ELEMENT_SEEALSOIE=321,
    DOCBOOK_ELEMENT_SEEIE=322,
    DOCBOOK_ELEMENT_SEG=323,
    DOCBOOK_ELEMENT_SEGLISTITEM=324,
    DOCBOOK_ELEMENT_SEGMENTEDLIST=325,
    DOCBOOK_ELEMENT_SEGTITLE=326,
    DOCBOOK_ELEMENT_SERIESVOLNUMS=327,
    DOCBOOK_ELEMENT_SET=328,
    DOCBOOK_ELEMENT_SETINDEX=329,
    DOCBOOK_ELEMENT_SETINDEXINFO=330,
    DOCBOOK_ELEMENT_SETINFO=331,
    DOCBOOK_ELEMENT_SGMLTAG=332,
    DOCBOOK_ELEMENT_SHORTAFFIL=333,
    DOCBOOK_ELEMENT_SHORTCUT=334,
    DOCBOOK_ELEMENT_SIDEBAR=335,
    DOCBOOK_ELEMENT_SIDEBARINFO=336,
    DOCBOOK_ELEMENT_SIMPARA=337,
    DOCBOOK_ELEMENT_SIMPLELIST=338,
    DOCBOOK_ELEMENT_SIMPLEMSGENTRY=339,
    DOCBOOK_ELEMENT_SIMPLESECT=340,
    DOCBOOK_ELEMENT_SPANSPEC=341,
    DOCBOOK_ELEMENT_STATE=342,
    DOCBOOK_ELEMENT_STEP=343,
    DOCBOOK_ELEMENT_STEPALTERNATIVES=344,
    DOCBOOK_ELEMENT_STREET=345,
    DOCBOOK_ELEMENT_STRUCTFIELD=346,
    DOCBOOK_ELEMENT_STRUCTNAME=347,
    DOCBOOK_ELEMENT_SUBJECT=348,
    DOCBOOK_ELEMENT_SUBJECTSET=349,
    DOCBOOK_ELEMENT_SUBJECTTERM=350,
    DOCBOOK_ELEMENT_SUBSCRIPT=351,
    DOCBOOK_ELEMENT_SUBSTEPS=352,
    DOCBOOK_ELEMENT_SUBTITLE=353,
    DOCBOOK_ELEMENT_SUPERSCRIPT=354,
    DOCBOOK_ELEMENT_SURNAME=355,
    DOCBOOK_ELEMENT_SYMBOL=356,
    DOCBOOK_ELEMENT_SYNOPFRAGMENT=357,
    DOCBOOK_ELEMENT_SYNOPFRAGMENTREF=358,
    DOCBOOK_ELEMENT_SYNOPSIS=359,
    DOCBOOK_ELEMENT_SYSTEMITEM=360,
    DOCBOOK_ELEMENT_TABLE=361,
    DOCBOOK_ELEMENT_TASK=362,
    DOCBOOK_ELEMENT_TASKPREREQUISITES=363,
    DOCBOOK_ELEMENT_TASKRELATED=364,
    DOCBOOK_ELEMENT_TASKSUMMARY=365,
    DOCBOOK_ELEMENT_TBODY=366,
    DOCBOOK_ELEMENT_TD=367,
    DOCBOOK_ELEMENT_TERM=368,
    DOCBOOK_ELEMENT_TERTIARY=369,
    DOCBOOK_ELEMENT_TERTIARYIE=370,
    DOCBOOK_ELEMENT_TEXTDATA=371,
    DOCBOOK_ELEMENT_TEXTOBJECT=372,
    DOCBOOK_ELEMENT_TFOOT=373,
    DOCBOOK_ELEMENT_TGROUP=374,
    DOCBOOK_ELEMENT_TH=375,
    DOCBOOK_ELEMENT_THEAD=376,
    DOCBOOK_ELEMENT_TIP=377,
    DOCBOOK_ELEMENT_TITLE=378,
    DOCBOOK_ELEMENT_TITLEABBREV=379,
    DOCBOOK_ELEMENT_TOC=380,
    DOCBOOK_ELEMENT_TOCBACK=381,
    DOCBOOK_ELEMENT_TOCCHAP=382,
    DOCBOOK_ELEMENT_TOCENTRY=383,
    DOCBOOK_ELEMENT_TOCFRONT=384,
    DOCBOOK_ELEMENT_TOCLEVEL1=385,
    DOCBOOK_ELEMENT_TOCLEVEL2=386,
    DOCBOOK_ELEMENT_TOCLEVEL3=387,
    DOCBOOK_ELEMENT_TOCLEVEL4=388,
    DOCBOOK_ELEMENT_TOCLEVEL5=389,
    DOCBOOK_ELEMENT_TOCPART=390,
    DOCBOOK_ELEMENT_TOKEN=391,
    DOCBOOK_ELEMENT_TR=392,
    DOCBOOK_ELEMENT_TRADEMARK=393,
    DOCBOOK_ELEMENT_TYPE=394,
    DOCBOOK_ELEMENT_ULINK=395,
    DOCBOOK_ELEMENT_URI=396,
    DOCBOOK_ELEMENT_USERINPUT=397,
    DOCBOOK_ELEMENT_VARARGS=398,
    DOCBOOK_ELEMENT_VARIABLELIST=399,
    DOCBOOK_ELEMENT_VARLISTENTRY=400,
    DOCBOOK_ELEMENT_VARNAME=401,
    DOCBOOK_ELEMENT_VIDEODATA=402,
    DOCBOOK_ELEMENT_VIDEOOBJECT=403,
    DOCBOOK_ELEMENT_VOID=404,
    DOCBOOK_ELEMENT_VOLUMENUM=405,
    DOCBOOK_ELEMENT_WARNING=406,
    DOCBOOK_ELEMENT_WORDASWORD=407,
    DOCBOOK_ELEMENT_XREF=408,
    DOCBOOK_ELEMENT_YEAR=409,
    DOCBOOK_ELEMENTS=410
} docbook_element_type;

typedef struct protocol_backend protocol_backend, *Pprotocol_backend;

typedef void (protocol_handler_T)(struct connection *);

struct protocol_backend {
    uchar * name;
    int port;
    protocol_handler_T * handler;
    uint need_slashes:1;
    uint need_slash_after_host:1;
    uint free_syntax:1;
    uint need_ssl:1;
    uint keep_double_slashes:1;
};

typedef enum protocol {
    PROTOCOL_ABOUT=0,
    PROTOCOL_BITTORRENT=1,
    PROTOCOL_BITTORRENT_PEER=2,
    PROTOCOL_DATA=3,
    PROTOCOL_FILE=4,
    PROTOCOL_FINGER=5,
    PROTOCOL_FSP=6,
    PROTOCOL_FTP=7,
    PROTOCOL_GOPHER=8,
    PROTOCOL_HTTP=9,
    PROTOCOL_HTTPS=10,
    PROTOCOL_JAVASCRIPT=11,
    PROTOCOL_NEWS=12,
    PROTOCOL_NNTP=13,
    PROTOCOL_NNTPS=14,
    PROTOCOL_PROXY=15,
    PROTOCOL_SMB=16,
    PROTOCOL_SNEWS=17,
    PROTOCOL_UNKNOWN=18,
    PROTOCOL_USER=19,
    PROTOCOL_LUA=20,
    PROTOCOL_BACKENDS=21
} protocol;

typedef struct sgml_info sgml_info, *Psgml_info;

typedef enum sgml_document_type {
    SGML_DOCTYPE_DOCBOOK=0,
    SGML_DOCTYPE_HTML=1,
    SGML_DOCTYPE_RSS=2,
    SGML_DOCTYPE_XBEL=3,
    SGML_DOCTYPES=4
} sgml_document_type;

typedef struct sgml_node_info sgml_node_info, *Psgml_node_info;

typedef struct dom_string dom_string, *Pdom_string;

struct dom_string {
    uint length;
    uchar * string;
};

struct sgml_node_info {
    struct dom_string string;
    uint16_t type;
    uint16_t flags;
};

struct sgml_info {
    enum sgml_document_type doctype;
    struct sgml_node_info * attributes;
    struct sgml_node_info * elements;
};

typedef enum sgml_element_flags {
    SGML_ELEMENT_OPTIONAL=1,
    SGML_ELEMENT_EMPTY=2,
    SGML_ELEMENT_END_OPTIONAL=4
} sgml_element_flags;

typedef enum sgml_attribute_flags {
    SGML_ATTRIBUTE_IDENTIFIER=1,
    SGML_ATTRIBUTE_REFERENCE=2
} sgml_attribute_flags;

typedef void (* __sighandler_t)(int);

typedef __pid_t pid_t;

typedef struct mailcap_hash_item mailcap_hash_item, *Pmailcap_hash_item;

struct mailcap_hash_item {
    struct list_head_elinks entries;
    uchar type[1];
};

typedef enum mailcap_option {
    MAILCAP_TREE=0,
    MAILCAP_ENABLE=1,
    MAILCAP_PATH=2,
    MAILCAP_ASK=3,
    MAILCAP_DESCRIPTION=4,
    MAILCAP_PRIORITIZE=5,
    MAILCAP_OPTIONS=6
} mailcap_option;

typedef struct mailcap_entry mailcap_entry, *Pmailcap_entry;

struct mailcap_entry {
    struct mailcap_entry * next;
    struct mailcap_entry * prev;
    uchar * testcommand;
    uchar * description;
    uint priority;
    uint needsterminal:1;
    uint copiousoutput:1;
    uchar command[1];
};


// WARNING! conflicting data type names: /DWARF/libio.h/_IO_marker - /libio.h/_IO_marker

typedef enum Gpm_Etype {
    GPM_MOVE=1,
    GPM_DRAG=2,
    GPM_DOWN=4,
    GPM_UP=8,
    GPM_SINGLE=16,
    GPM_DOUBLE=32,
    GPM_TRIPLE=64,
    GPM_MFLAG=128,
    GPM_HARD=256,
    GPM_ENTER=512,
    GPM_LEAVE=1024
} Gpm_Etype;

typedef struct Gpm_Connect Gpm_Connect, *PGpm_Connect;

struct Gpm_Connect {
    ushort eventMask;
    ushort defaultMask;
    ushort minMod;
    ushort maxMod;
    int pid;
    int vc;
};

typedef enum Gpm_Margin {
    GPM_TOP=1,
    GPM_BOT=2,
    GPM_LFT=4,
    GPM_RGT=8
} Gpm_Margin;

typedef struct Gpm_Event Gpm_Event, *PGpm_Event;

struct Gpm_Event {
    uchar buttons;
    uchar modifiers;
    ushort vc;
    short dx;
    short dy;
    short x;
    short y;
    enum Gpm_Etype type;
    int clicks;
    enum Gpm_Margin margin;
    short wdx;
    short wdy;
};

typedef struct css_property_info css_property_info, *Pcss_property_info;

typedef enum css_property_type {
    CSS_PT_NONE=0,
    CSS_PT_BACKGROUND=1,
    CSS_PT_BACKGROUND_COLOR=2,
    CSS_PT_COLOR=3,
    CSS_PT_DISPLAY=4,
    CSS_PT_FONT_STYLE=5,
    CSS_PT_FONT_WEIGHT=6,
    CSS_PT_TEXT_ALIGN=7,
    CSS_PT_TEXT_DECORATION=8,
    CSS_PT_WHITE_SPACE=9,
    CSS_PT_LAST=10
} css_property_type;

typedef enum css_property_value_type {
    CSS_VT_NONE=0,
    CSS_VT_COLOR=1,
    CSS_VT_DISPLAY=2,
    CSS_VT_FONT_ATTRIBUTE=3,
    CSS_VT_TEXT_ALIGN=4,
    CSS_VT_LAST=5
} css_property_value_type;

typedef union css_property_value css_property_value, *Pcss_property_value;

typedef struct scanner scanner, *Pscanner;

typedef int (* css_property_value_parser_T)(struct css_property_info *, union css_property_value *, struct scanner *);

typedef enum css_display {
    CSS_DISP_INLINE=0,
    CSS_DISP_BLOCK=1
} css_display;

typedef struct anon_struct_8_2_43df1dfe_for_font_attribute anon_struct_8_2_43df1dfe_for_font_attribute, *Panon_struct_8_2_43df1dfe_for_font_attribute;

typedef struct scanner_token scanner_token, *Pscanner_token;

typedef struct scanner_info scanner_info, *Pscanner_info;

typedef struct scanner_string_mapping scanner_string_mapping, *Pscanner_string_mapping;

typedef struct scan_table_info scan_table_info, *Pscan_table_info;

typedef union scan_table_data scan_table_data, *Pscan_table_data;

typedef struct anon_struct_8_2_098db148_for_string anon_struct_8_2_098db148_for_string, *Panon_struct_8_2_098db148_for_string;

typedef struct anon_struct_8_2_26475ede_for_range anon_struct_8_2_26475ede_for_range, *Panon_struct_8_2_26475ede_for_range;

struct anon_struct_8_2_26475ede_for_range {
    uchar * start;
    long end;
};

struct anon_struct_8_2_098db148_for_string {
    uchar * source;
    long length;
};

union scan_table_data {
    struct anon_struct_8_2_098db148_for_string string;
    struct anon_struct_8_2_26475ede_for_range range;
};

struct scanner_token {
    int type;
    int precedence;
    uchar * string;
    int length;
};

struct scanner {
    uchar * string;
    uchar * position;
    uchar * end;
    struct scanner_token * current;
    int tokens;
    struct scanner_info * info;
    int state;
    struct scanner_token table[10];
};

struct scanner_info {
    struct scanner_string_mapping * mappings;
    struct scan_table_info * scan_table_info;
    scanner_token * (* scan)(struct scanner *);
    int scan_table[256];
    uint initialized:1;
};

struct css_property_info {
    uchar * name;
    enum css_property_type type;
    enum css_property_value_type value_type;
    css_property_value_parser_T parser;
    void * parser_data;
};

struct scanner_string_mapping {
    uchar * name;
    int type;
    int base_type;
};

struct anon_struct_8_2_43df1dfe_for_font_attribute {
    enum text_style_format add;
    enum text_style_format rem;
};

union css_property_value {
    void * none;
    color_T color;
    enum css_display display;
    struct anon_struct_8_2_43df1dfe_for_font_attribute font_attribute;
    enum format_align text_align;
};

struct scan_table_info {
    enum anon_enum_32 type;
    union scan_table_data data;
    int bits;
};

typedef struct css_property css_property, *Pcss_property;

struct css_property {
    struct css_property * next;
    struct css_property * prev;
    enum css_property_type type;
    enum css_property_value_type value_type;
    union css_property_value value;
};

typedef struct gnutls_anon_client_credentials_st gnutls_anon_client_credentials_st, *Pgnutls_anon_client_credentials_st;

typedef struct gnutls_anon_client_credentials_st * gnutls_anon_client_credentials_t;

struct gnutls_anon_client_credentials_st {
};

typedef enum gnutls_cipher_algorithm_t {
    GNUTLS_CIPHER_UNKNOWN=0,
    GNUTLS_CIPHER_NULL=1,
    GNUTLS_CIPHER_ARCFOUR_128=2,
    GNUTLS_CIPHER_3DES_CBC=3,
    GNUTLS_CIPHER_AES_128_CBC=4,
    GNUTLS_CIPHER_AES_256_CBC=5,
    GNUTLS_CIPHER_ARCFOUR_40=6,
    GNUTLS_CIPHER_CAMELLIA_128_CBC=7,
    GNUTLS_CIPHER_CAMELLIA_256_CBC=8,
    GNUTLS_CIPHER_RC2_40_CBC=90,
    GNUTLS_CIPHER_DES_CBC=91,
    GNUTLS_CIPHER_IDEA_PGP_CFB=200,
    GNUTLS_CIPHER_3DES_PGP_CFB=201,
    GNUTLS_CIPHER_CAST5_PGP_CFB=202,
    GNUTLS_CIPHER_BLOWFISH_PGP_CFB=203,
    GNUTLS_CIPHER_SAFER_SK128_PGP_CFB=204,
    GNUTLS_CIPHER_AES128_PGP_CFB=205,
    GNUTLS_CIPHER_AES192_PGP_CFB=206,
    GNUTLS_CIPHER_AES256_PGP_CFB=207,
    GNUTLS_CIPHER_TWOFISH_PGP_CFB=208
} gnutls_cipher_algorithm_t;

typedef struct gnutls_certificate_credentials_st gnutls_certificate_credentials_st, *Pgnutls_certificate_credentials_st;

typedef struct gnutls_certificate_credentials_st * gnutls_certificate_credentials_t;

struct gnutls_certificate_credentials_st {
};

typedef struct gnutls_session_int gnutls_session_int, *Pgnutls_session_int;

typedef struct gnutls_session_int * gnutls_session_t;

struct gnutls_session_int {
};

typedef struct hierbox_browser hierbox_browser, *Phierbox_browser;

typedef struct hierbox_browser_button hierbox_browser_button, *Phierbox_browser_button;

struct hierbox_browser_button {
    uchar * label;
    widget_handler_status_T (* handler)(struct dialog_data *, struct widget_data *);
    uint anonymous:1;
};

struct hierbox_browser {
    uchar * title;
    void (* expansion_callback)(void);
    struct hierbox_browser_button * buttons;
    size_t buttons_size;
    struct list_head_elinks boxes;
    struct list_head_elinks dialogs;
    struct listbox_item root;
    struct listbox_ops * ops;
    struct listbox_data box_data;
    uint do_not_save_state:1;
};

typedef struct hierbox_dialog_list_item hierbox_dialog_list_item, *Phierbox_dialog_list_item;

struct hierbox_dialog_list_item {
    struct hierbox_dialog_list_item * next;
    struct hierbox_dialog_list_item * prev;
    struct dialog_data * dlg_data;
};

typedef struct keys_toggle_info keys_toggle_info, *Pkeys_toggle_info;

struct keys_toggle_info {
    struct terminal * term;
    int toggle;
};

typedef enum addr_type {
    ADDR_IP_CLIENT=0,
    ADDR_IP_SERVER=1,
    ADDR_ANY_SERVER=2
} addr_type;

typedef struct socket_info socket_info, *Psocket_info;

struct socket_info {
    struct sockaddr * addr;
    int size;
    int fd;
};

typedef enum delete_error {
    DELETE_IMPOSSIBLE=0,
    DELETE_LOCKED=1,
    DELETE_ERRORS=2
} delete_error;

typedef enum __socket_type {
    SOCK_STREAM=1,
    SOCK_DGRAM=2,
    SOCK_RAW=3,
    SOCK_RDM=4,
    SOCK_SEQPACKET=5,
    SOCK_DCCP=6,
    SOCK_PACKET=10,
    SOCK_NONBLOCK=2048,
    SOCK_CLOEXEC=524288
} __socket_type;

typedef void (* socket_write_T)(struct socket *);

typedef enum socket_error {
    SOCKET_CANT_WRITE=-5,
    SOCKET_CANT_READ=-4,
    SOCKET_SSL_WANT_READ=-3,
    SOCKET_INTERNAL_ERROR=-2,
    SOCKET_SYSCALL_ERROR=-1
} socket_error;

typedef struct socket_weak_ref socket_weak_ref, *Psocket_weak_ref;

struct socket_weak_ref {
    struct socket_weak_ref * next;
    struct socket_weak_ref * prev;
    struct socket * socket;
};

typedef struct write_buffer write_buffer, *Pwrite_buffer;

struct write_buffer {
    socket_write_T done;
    int length;
    int pos;
    uchar data[1];
};


// WARNING! conflicting data type names: /DWARF/explodename.c/_nl_explode_name/anon_enum_32 - /DWARF/session.h/anon_enum_32

typedef enum pass_uri_type {
    PASS_URI_FRAME=0,
    PASS_URI_LINK=1,
    PASS_URI_TAB=2
} pass_uri_type;

typedef struct open_in_new open_in_new, *Popen_in_new;

struct open_in_new {
    enum term_env_type env;
    uchar * command;
    uchar * text;
};

typedef enum html_whitespace_state {
    HTML_SPACE_SUPPRESS=0,
    HTML_SPACE_NORMAL=1,
    HTML_SPACE_ADD=2
} html_whitespace_state;

typedef struct negotiate negotiate, *Pnegotiate;

struct negotiate {
    struct negotiate * next;
    struct negotiate * prev;
    struct object object;
    struct uri * uri;
    int type;
    OM_uint32 status;
    gss_ctx_id_t context;
    gss_name_t server_name;
    gss_buffer_desc output_token;
    gss_buffer_desc input_token;
};

typedef struct ewd ewd, *Pewd;

struct ewd {
    void (* fn)(void *);
    void * data;
    uint called_once:1;
};

typedef struct dummy_enc_data dummy_enc_data, *Pdummy_enc_data;

struct dummy_enc_data {
    int fd;
};

typedef struct decoding_backend decoding_backend, *Pdecoding_backend;

struct decoding_backend {
    uchar * name;
    uchar * * extensions;
    int (* open)(struct stream_encoded *, int);
    int (* read)(struct stream_encoded *, uchar *, int);
    uchar * (* decode_buffer)(uchar *, int, int *);
    void (* close)(struct stream_encoded *);
};

typedef struct sockaddr_un sockaddr_un, *Psockaddr_un;

struct sockaddr_un {
    sa_family_t sun_family;
    char sun_path[108];
};

typedef struct dom_stack_state dom_stack_state, *Pdom_stack_state;

typedef struct dom_node dom_node, *Pdom_node;

typedef union dom_node_data dom_node_data, *Pdom_node_data;

typedef struct dom_document_node dom_document_node, *Pdom_document_node;

typedef struct dom_document_type_node dom_document_type_node, *Pdom_document_type_node;

typedef struct dom_element_node dom_element_node, *Pdom_element_node;

typedef struct dom_attribute_node dom_attribute_node, *Pdom_attribute_node;

typedef struct dom_text_node dom_text_node, *Pdom_text_node;

typedef struct dom_id dom_id, *Pdom_id;

typedef struct dom_proc_instruction_node dom_proc_instruction_node, *Pdom_proc_instruction_node;

typedef struct dom_document dom_document, *Pdom_document;

typedef struct dom_node_list dom_node_list, *Pdom_node_list;

typedef struct dom_doctype_subset_infot dom_doctype_subset_infot, *Pdom_doctype_subset_infot;

struct dom_proc_instruction_node {
    struct dom_string instruction;
    uint16_t type;
    struct dom_node_list * map;
};

struct dom_text_node {
    uint newlines;
    uint only_space:1;
    uint converted:1;
};

struct dom_id {
    struct dom_string public_id;
    struct dom_string system_id;
};

struct dom_document_node {
    struct dom_document * document;
    struct dom_node_list * children;
};

struct dom_attribute_node {
    struct dom_string value;
    uint16_t namespace_offset;
    uint16_t type;
    uchar quoted;
    uint specified:1;
    uint converted:1;
    uint id:1;
    uint reference:1;
};

struct dom_element_node {
    struct dom_node_list * children;
    struct dom_node_list * map;
    uint16_t namespace_offset;
    uint16_t type;
};

struct dom_document_type_node {
    struct dom_node_list * entities;
    struct dom_node_list * notations;
    struct dom_doctype_subset_infot * subset;
};

union dom_node_data {
    struct dom_document_node document;
    struct dom_document_type_node document_type;
    struct dom_element_node element;
    struct dom_attribute_node attribute;
    struct dom_text_node text;
    struct dom_id notation;
    struct dom_id entity;
    struct dom_proc_instruction_node proc_instruction;
};

struct dom_stack_state {
    struct dom_node * node;
    uint depth;
    uint immutable:1;
};

struct dom_node {
    uint16_t type;
    uint allocated:1;
    struct dom_string string;
    struct dom_node * parent;
    union dom_node_data data;
};

struct dom_node_list {
    size_t size;
    struct dom_node * entries[1];
};

struct dom_document {
};

struct dom_doctype_subset_infot {
};

typedef struct dom_stack_context_info dom_stack_context_info, *Pdom_stack_context_info;

typedef enum dom_code {
    DOM_CODE_ERR=-1000,
    DOM_CODE_INCOMPLETE=-999,
    DOM_CODE_FREE_NODE=-998,
    DOM_CODE_ALLOC_ERR=-997,
    DOM_CODE_MAX_DEPTH_ERR=-996,
    DOM_CODE_VALUE_ERR=-995,
    DOM_CODE_OK=0,
    DOM_CODE_INDEX_SIZE_ERR=1,
    DOM_CODE_DOMSTRING_SIZE_ERR=2,
    DOM_CODE_HIERARCHY_REQUEST_ERR=3,
    DOM_CODE_WRONG_DOCUMENT_ERR=4,
    DOM_CODE_INVALID_CHARACTER_ERR=5,
    DOM_CODE_NO_DATA_ALLOWED_ERR=6,
    DOM_CODE_NO_MODIFICATION_ALLOWED_ERR=7,
    DOM_CODE_NOT_FOUND_ERR=8,
    DOM_CODE_NOT_SUPPORTED_ERR=9,
    DOM_CODE_INUSE_ATTRIBUTE_ERR=10,
    DOM_CODE_INVALID_STATE_ERR=11,
    DOM_CODE_SYNTAX_ERR=12,
    DOM_CODE_INVALID_MODIFICATION_ERR=13,
    DOM_CODE_NAMESPACE_ERR=14,
    DOM_CODE_INVALID_ACCESS_ERR=15,
    DOM_CODE_VALIDATION_ERR=16,
    DOM_CODE_TYPE_MISMATCH_ERR=17
} dom_code;

typedef struct dom_stack dom_stack, *Pdom_stack;

typedef dom_code (* dom_stack_callback_T)(struct dom_stack *, struct dom_node *, void *);

typedef enum dom_stack_flag {
    DOM_STACK_FLAG_NONE=0,
    DOM_STACK_FLAG_FREE_NODES=1
} dom_stack_flag;

typedef struct dom_stack_context dom_stack_context, *Pdom_stack_context;

struct dom_stack_context_info {
    size_t object_size;
    dom_stack_callback_T push[13];
    dom_stack_callback_T pop[13];
};

struct dom_stack_context {
    void * data;
    uchar * state_objects;
    struct dom_stack_context_info * info;
};

struct dom_stack {
    struct dom_stack_state * states;
    size_t depth;
    enum dom_stack_flag flags;
    struct dom_stack_context * * contexts;
    size_t contexts_size;
    struct dom_stack_context * current;
};


// WARNING! conflicting data type names: /DWARF/time.h/timespec - /time.h/timespec

typedef struct timeval timeval, *Ptimeval;

struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};

typedef struct tm tm, *Ptm;

struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    char * tm_zone;
};

typedef struct http_version http_version, *Phttp_version;

struct http_version {
    int major;
    int minor;
};


// WARNING! conflicting data type names: /DWARF/http.c/decompress_data/anon_enum_32 - /DWARF/session.h/anon_enum_32

typedef enum css_char_group {
    CSS_CHAR_ALPHA=1,
    CSS_CHAR_DIGIT=2,
    CSS_CHAR_HEX_DIGIT=4,
    CSS_CHAR_IDENT=8,
    CSS_CHAR_IDENT_START=16,
    CSS_CHAR_NEWLINE=32,
    CSS_CHAR_NON_ASCII=64,
    CSS_CHAR_SGML_MARKUP=128,
    CSS_CHAR_TOKEN=256,
    CSS_CHAR_TOKEN_START=512,
    CSS_CHAR_WHITESPACE=1024
} css_char_group;

typedef enum sgml_char_group {
    SGML_CHAR_ENTITY=2,
    SGML_CHAR_IDENT=4,
    SGML_CHAR_NEWLINE=8,
    SGML_CHAR_WHITESPACE=16,
    SGML_CHAR_NOT_TEXT=32,
    SGML_CHAR_NOT_ATTRIBUTE=64
} sgml_char_group;

typedef struct RBasic RBasic, *PRBasic;

struct RBasic {
    ulong flags;
    VALUE klass;
};

typedef struct RString RString, *PRString;

typedef union anon_union_4_2_13036f57_for_aux anon_union_4_2_13036f57_for_aux, *Panon_union_4_2_13036f57_for_aux;

union anon_union_4_2_13036f57_for_aux {
    long capa;
    VALUE shared;
};

struct RString {
    struct RBasic basic;
    long len;
    char * ptr;
    union anon_union_4_2_13036f57_for_aux aux;
};

typedef struct dom_scan_table_info dom_scan_table_info, *Pdom_scan_table_info;

struct dom_scan_table_info {
    enum anon_enum_32 type;
    struct dom_string data;
    int bits;
};

typedef struct dom_scanner dom_scanner, *Pdom_scanner;

typedef struct dom_scanner_token dom_scanner_token, *Pdom_scanner_token;

typedef struct dom_scanner_info dom_scanner_info, *Pdom_scanner_info;

typedef struct dom_scanner_string_mapping dom_scanner_string_mapping, *Pdom_scanner_string_mapping;

struct dom_scanner_info {
    struct dom_scanner_string_mapping * mappings;
    struct dom_scan_table_info * scan_table_info;
    dom_scanner_token * (* scan)(struct dom_scanner *);
    int scan_table[256];
    uint initialized:1;
};

struct dom_scanner_string_mapping {
    struct dom_string name;
    int type;
    int base_type;
};

struct dom_scanner_token {
    int type;
    int precedence;
    uint lineno;
    struct dom_string string;
};

struct dom_scanner {
    uchar * string;
    uchar * end;
    uchar * position;
    struct dom_scanner_token * current;
    int tokens;
    struct dom_scanner_info * info;
    uint check_complete:1;
    uint incomplete:1;
    uint detect_errors:1;
    uint found_error;
    uint count_lines:1;
    uint lineno;
    int state;
    struct dom_scanner_token table[10];
};

typedef enum sgml_scanner_state {
    SGML_STATE_TEXT=0,
    SGML_STATE_ELEMENT=1,
    SGML_STATE_PROC_INST=2
} sgml_scanner_state;

typedef enum css_token_type {
    CSS_TOKEN_NONE=0,
    CSS_TOKEN_IDENT=256,
    CSS_TOKEN_NUMBER=257,
    CSS_TOKEN_PERCENTAGE=258,
    CSS_TOKEN_STRING=259,
    CSS_TOKEN_ANGLE=260,
    CSS_TOKEN_DIMENSION=261,
    CSS_TOKEN_EM=262,
    CSS_TOKEN_EX=263,
    CSS_TOKEN_FREQUENCY=264,
    CSS_TOKEN_LENGTH=265,
    CSS_TOKEN_TIME=266,
    CSS_TOKEN_HASH=267,
    CSS_TOKEN_HEX_COLOR=268,
    CSS_TOKEN_FUNCTION=269,
    CSS_TOKEN_RGB=270,
    CSS_TOKEN_URL=271,
    CSS_TOKEN_AT_KEYWORD=272,
    CSS_TOKEN_AT_CHARSET=273,
    CSS_TOKEN_AT_FONT_FACE=274,
    CSS_TOKEN_AT_IMPORT=275,
    CSS_TOKEN_AT_MEDIA=276,
    CSS_TOKEN_AT_PAGE=277,
    CSS_TOKEN_IMPORTANT=278,
    CSS_TOKEN_SELECT_SPACE_LIST=279,
    CSS_TOKEN_SELECT_HYPHEN_LIST=280,
    CSS_TOKEN_SELECT_BEGIN=281,
    CSS_TOKEN_SELECT_END=282,
    CSS_TOKEN_SELECT_CONTAINS=283,
    CSS_TOKEN_GARBAGE=284,
    CSS_TOKEN_SKIP=285
} css_token_type;

typedef enum sgml_token_type {
    SGML_TOKEN_NONE=0,
    SGML_TOKEN_IDENT=256,
    SGML_TOKEN_TAG_END=257,
    SGML_TOKEN_STRING=258,
    SGML_TOKEN_NOTATION=259,
    SGML_TOKEN_NOTATION_COMMENT=260,
    SGML_TOKEN_NOTATION_DOCTYPE=261,
    SGML_TOKEN_NOTATION_ELEMENT=262,
    SGML_TOKEN_NOTATION_ENTITY=263,
    SGML_TOKEN_NOTATION_ATTLIST=264,
    SGML_TOKEN_CDATA_SECTION=265,
    SGML_TOKEN_PROCESS=266,
    SGML_TOKEN_PROCESS_XML=267,
    SGML_TOKEN_PROCESS_XML_STYLESHEET=268,
    SGML_TOKEN_PROCESS_DATA=269,
    SGML_TOKEN_ELEMENT=270,
    SGML_TOKEN_ELEMENT_BEGIN=271,
    SGML_TOKEN_ELEMENT_END=272,
    SGML_TOKEN_ELEMENT_EMPTY_END=273,
    SGML_TOKEN_ATTRIBUTE=274,
    SGML_TOKEN_ENTITY=275,
    SGML_TOKEN_TEXT=276,
    SGML_TOKEN_SPACE=277,
    SGML_TOKEN_GARBAGE=278,
    SGML_TOKEN_INCOMPLETE=279,
    SGML_TOKEN_ERROR=280,
    SGML_TOKEN_SKIP=281
} sgml_token_type;

typedef void * iconv_t;

typedef struct directory_entry directory_entry, *Pdirectory_entry;

struct directory_entry {
    uchar * attrib;
    uchar * name;
};

typedef struct group group, *Pgroup;

struct group {
    char * gr_name;
    char * gr_passwd;
    __gid_t gr_gid;
    char * * gr_mem;
};

typedef struct bookmark bookmark, *Pbookmark;

struct bookmark {
    struct bookmark * next;
    struct bookmark * prev;
    struct object object;
    struct bookmark * root;
    struct listbox_item * box_item;
    uchar * title;
    uchar * url;
    struct list_head_elinks child;
};

typedef struct about_page about_page, *Pabout_page;

struct about_page {
    uchar * name;
    uchar * string;
};

typedef enum term_exec {
    TERM_EXEC_BG=0,
    TERM_EXEC_FG=1,
    TERM_EXEC_NEWWIN=2
} term_exec;

typedef struct bookmark_search_ctx bookmark_search_ctx, *Pbookmark_search_ctx;

struct bookmark_search_ctx {
    uchar * url;
    uchar * title;
    int found;
    int offset;
    int utf8_cp;
    int system_cp;
};

typedef struct kbdbind_add_hop kbdbind_add_hop, *Pkbdbind_add_hop;

typedef enum keymap_id {
    KEYMAP_INVALID=-1,
    KEYMAP_MAIN=0,
    KEYMAP_EDIT=1,
    KEYMAP_MENU=2,
    KEYMAP_MAX=3
} keymap_id;

struct kbdbind_add_hop {
    struct terminal * term;
    action_id_T action_id;
    enum keymap_id keymap_id;
    struct term_event_keyboard kbd;
    struct widget_data * widget_data;
};

typedef struct extension extension, *Pextension;

struct extension {
    uchar ext_orig[1024];
    uchar ext[1024];
    uchar ct[1024];
};

typedef enum move_bookmark_flags {
    MOVE_BOOKMARK_NONE=0,
    MOVE_BOOKMARK_MOVED=1,
    MOVE_BOOKMARK_CYCLE=2
} move_bookmark_flags;

typedef struct add_option_to_tree_ctx add_option_to_tree_ctx, *Padd_option_to_tree_ctx;

struct add_option_to_tree_ctx {
    struct option_elinks * option_elinks;
    struct widget_data * widget_data;
};

typedef struct hash_item hash_item, *Phash_item;

struct hash_item {
    struct hash_item * next;
    struct hash_item * prev;
    uchar * key;
    uint keylen;
    void * value;
};

typedef struct hash hash, *Phash;

typedef hash_value_T (* hash_func_T)(uchar *, uint, hash_value_T);

struct hash {
    uint width;
    hash_func_T func;
    struct list_head_elinks hash[1];
};

typedef struct line_info line_info, *Pline_info;

struct line_info {
    int start;
    int end;
    int last_char_width;
    int split_prev:1;
    int split_next:1;
};

typedef enum xbel_element_type {
    XBEL_ELEMENT_UNKNOWN=0,
    XBEL_ELEMENT_ALIAS=1,
    XBEL_ELEMENT_BOOKMARK=2,
    XBEL_ELEMENT_DESC=3,
    XBEL_ELEMENT_FOLDER=4,
    XBEL_ELEMENT_INFO=5,
    XBEL_ELEMENT_METADATA=6,
    XBEL_ELEMENT_SEPARATOR=7,
    XBEL_ELEMENT_TITLE=8,
    XBEL_ELEMENT_XBEL=9,
    XBEL_ELEMENTS=10
} xbel_element_type;

typedef enum xbel_attribute_type {
    XBEL_ATTRIBUTE_UNKNOWN=0,
    XBEL_ATTRIBUTE_ADDED=1,
    XBEL_ATTRIBUTE_FOLDED=2,
    XBEL_ATTRIBUTE_HREF=3,
    XBEL_ATTRIBUTE_ID=4,
    XBEL_ATTRIBUTE_MODIFIED=5,
    XBEL_ATTRIBUTE_OWNER=6,
    XBEL_ATTRIBUTE_REF=7,
    XBEL_ATTRIBUTE_VERSION=8,
    XBEL_ATTRIBUTE_VISITED=9,
    XBEL_ATTRIBUTES=10
} xbel_attribute_type;

typedef struct http_connection_info http_connection_info, *Phttp_connection_info;

typedef enum blacklist_flags {
    SERVER_BLACKLIST_NONE=0,
    SERVER_BLACKLIST_HTTP10=1,
    SERVER_BLACKLIST_NO_CHARSET=2,
    SERVER_BLACKLIST_NO_TLS=4
} blacklist_flags;

struct http_connection_info {
    enum blacklist_flags bl_flags;
    struct http_version recv_version;
    struct http_version sent_version;
    int close;
    int length;
    int chunk_remaining;
    int code;
};

typedef enum html_element_mortality_type {
    ELEMENT_IMMORTAL=0,
    ELEMENT_DONT_KILL=1,
    ELEMENT_KILLABLE=2,
    ELEMENT_WEAK=3
} html_element_mortality_type;

typedef enum html_element_pseudo_class {
    ELEMENT_LINK=1,
    ELEMENT_VISITED=2
} html_element_pseudo_class;

typedef enum format_list_flag {
    P_NONE=0,
    P_NUMBER=1,
    P_STAR=1,
    P_O=2,
    P_alpha=2,
    P_ALPHA=3,
    P_PLUS=3,
    P_roman=4,
    P_ROMAN=5,
    P_LISTMASK=7,
    P_COMPACT=8
} format_list_flag;

typedef struct cookie_str cookie_str, *Pcookie_str;

struct cookie_str {
    uchar * str;
    uchar * nam_end;
    uchar * val_start;
    uchar * val_end;
};

typedef enum sgml_parser_type {
    SGML_PARSER_STREAM=0,
    SGML_PARSER_TREE=1
} sgml_parser_type;

typedef struct par_attrib par_attrib, *Ppar_attrib;

struct par_attrib {
    enum format_align align;
    int leftmargin;
    int rightmargin;
    int width;
    int list_level;
    uint list_number;
    int dd_margin;
    enum format_list_flag flags;
    color_T bgcolor;
};

typedef struct sgml_parser sgml_parser, *Psgml_parser;

typedef dom_code (* sgml_error_T)(struct sgml_parser *, struct dom_string *, uint);

typedef enum sgml_parser_flag {
    SGML_PARSER_COUNT_LINES=1,
    SGML_PARSER_COMPLETE=2,
    SGML_PARSER_INCREMENTAL=4,
    SGML_PARSER_DETECT_ERRORS=8
} sgml_parser_flag;

struct sgml_parser {
    enum sgml_parser_type type;
    enum sgml_parser_flag flags;
    struct sgml_info * info;
    struct dom_string uri;
    struct dom_node * root;
    enum dom_code code;
    sgml_error_T error_func;
    struct dom_stack stack;
    struct dom_stack parsing;
};

typedef struct sgml_parser_state sgml_parser_state, *Psgml_parser_state;

struct sgml_parser_state {
    struct sgml_node_info * info;
    struct dom_scanner_token end_token;
};

typedef struct text_attrib text_attrib, *Ptext_attrib;

struct text_attrib {
    struct text_style style;
    int fontsize;
    uchar * link;
    uchar * target;
    uchar * image;
    uchar * title;
    struct form_control * form;
    color_T clink;
    color_T vlink;
    color_T bookmark_link;
    color_T image_link;
    uchar * id;
    uchar * class;
    uchar * select;
    int select_disabled;
    uint tabindex;
    unicode_val_T accesskey;
    uchar * onclick;
    uchar * ondblclick;
    uchar * onmouseover;
    uchar * onhover;
    uchar * onfocus;
    uchar * onmouseout;
    uchar * onblur;
};

typedef enum html_special_type.conflict {
    SP_TAG=0,
    SP_FORM=1,
    SP_CONTROL=2,
    SP_TABLE=3,
    SP_USED=4,
    SP_FRAMESET=5,
    SP_FRAME=6,
    SP_NOWRAP=7,
    SP_CACHE_CONTROL=8,
    SP_CACHE_EXPIRES=9,
    SP_REFRESH=10,
    SP_STYLESHEET=11,
    SP_COLOR_LINK_LINES=12,
    SP_SCRIPT=13
} html_special_type.conflict;

typedef struct xlist_head xlist_head, *Pxlist_head;

struct xlist_head {
    struct xlist_head * next;
    struct xlist_head * prev;
};

typedef struct sgml_parsing_state sgml_parsing_state, *Psgml_parsing_state;

struct sgml_parsing_state {
    struct dom_scanner scanner;
    struct dom_node * node;
    struct dom_string incomplete;
    size_t depth;
    uint resume:1;
};

typedef struct selector_pkg selector_pkg, *Pselector_pkg;

typedef struct css_selector css_selector, *Pcss_selector;

typedef enum css_selector_relation {
    CSR_ROOT=0,
    CSR_SPECIFITY=1,
    CSR_ANCESTOR=2,
    CSR_PARENT=3
} css_selector_relation;

typedef enum css_selector_type {
    CST_ELEMENT=0,
    CST_ID=1,
    CST_CLASS=2,
    CST_PSEUDO=3,
    CST_INVALID=4
} css_selector_type;

struct selector_pkg {
    struct selector_pkg * next;
    struct selector_pkg * prev;
    struct css_selector * selector;
};

struct css_selector {
    struct css_selector * next;
    struct css_selector * prev;
    enum css_selector_relation relation;
    struct list_head_elinks leaves;
    enum css_selector_type type;
    uchar * name;
    struct list_head_elinks properties;
};

typedef enum dom_stack_action {
    DOM_STACK_PUSH=0,
    DOM_STACK_POP=1
} dom_stack_action;

typedef struct dom_stack_walk_state dom_stack_walk_state, *Pdom_stack_walk_state;

struct dom_stack_walk_state {
    struct dom_node_list * list;
    size_t index;
};

typedef struct gpm_mouse_spec gpm_mouse_spec, *Pgpm_mouse_spec;

struct gpm_mouse_spec {
    int h;
    int cons;
    void (* fn)(void *, uchar *, int);
    void * data;
};

typedef struct input_line input_line, *Pinput_line;

typedef enum input_line_code {
    INPUT_LINE_CANCEL=0,
    INPUT_LINE_PROCEED=1,
    INPUT_LINE_REWIND=2
} input_line_code;

typedef input_line_code (* input_line_handler_T)(struct input_line *, int);

struct input_line {
    struct session * ses;
    input_line_handler_T handler;
    void * data;
    uchar buffer[256];
};

typedef struct tree_node tree_node, *Ptree_node;

struct tree_node {
    uchar * name;
    uchar * text;
    struct list_head_elinks attrs;
    struct tree_node * parent;
    struct tree_node * children;
    struct tree_node * prev;
    struct tree_node * next;
};

typedef struct attributes attributes, *Pattributes;

struct attributes {
    struct attributes * next;
    struct attributes * prev;
    uchar * name;
    uchar * value;
};

typedef struct read_bookmarks_xbel read_bookmarks_xbel, *Pread_bookmarks_xbel;

struct read_bookmarks_xbel {
    int utf8_cp;
};

typedef struct module module, *Pmodule;

typedef struct option_info option_info, *Poption_info;

typedef struct event_hook_info event_hook_info, *Pevent_hook_info;

typedef enum evhook_status {
    EVENT_HOOK_STATUS_NEXT=0,
    EVENT_HOOK_STATUS_LAST=1
} evhook_status;

typedef __gnuc_va_list va_list;

typedef evhook_status (* event_hook_T)(va_list, void *);

struct event_hook_info {
    uchar * name;
    int priority;
    event_hook_T callback;
    void * data;
};

struct option_info {
    struct option_elinks option_elinks;
    uchar * path;
};

struct module {
    uchar * name;
    struct option_info * options;
    struct event_hook_info * hooks;
    struct module * * submodules;
    void * data;
    void (* init)(struct module *);
    void (* done)(struct module *);
};

typedef struct secure_save_info secure_save_info, *Psecure_save_info;


// WARNING! conflicting data type names: /DWARF/stdio.h/FILE - /stdio.h/FILE

struct secure_save_info {
    FILE * fp;
    uchar * file_name;
    uchar * tmp_file_name;
    int err;
    int secure_save;
};

typedef enum secsave_errno {
    SS_ERR_NONE=0,
    SS_ERR_DISABLED=1,
    SS_ERR_OUT_OF_MEM=2,
    SS_ERR_OPEN_READ=3,
    SS_ERR_OPEN_WRITE=4,
    SS_ERR_STAT=5,
    SS_ERR_ACCESS=6,
    SS_ERR_MKSTEMP=7,
    SS_ERR_RENAME=8,
    SS_ERR_OTHER=9
} secsave_errno;

typedef enum global_history_options {
    GLOBHIST_TREE=0,
    GLOBHIST_ENABLE=1,
    GLOBHIST_MAX_ITEMS=2,
    GLOBHIST_DISPLAY_TYPE=3,
    GLOBHIST_OPTIONS=4
} global_history_options;

typedef struct s_msg_dsc s_msg_dsc, *Ps_msg_dsc;

struct s_msg_dsc {
    int n;
    uchar * msg;
};

typedef struct strerror_val strerror_val, *Pstrerror_val;

struct strerror_val {
    struct strerror_val * next;
    struct strerror_val * prev;
    uchar msg[1];
};

typedef struct global_history_item global_history_item, *Pglobal_history_item;

struct global_history_item {
    struct global_history_item * next;
    struct global_history_item * prev;
    struct object object;
    struct listbox_item * box_item;
    uchar * title;
    uchar * url;
    time_t last_visit;
};


// WARNING! conflicting data type names: /DWARF/kbd.c/resize_terminal_from_str/anon_enum_32 - /DWARF/session.h/anon_enum_32

typedef struct css_stylesheet css_stylesheet, *Pcss_stylesheet;

typedef void (* css_stylesheet_importer_T)(struct css_stylesheet *, struct uri *, uchar *, int);

struct css_stylesheet {
    css_stylesheet_importer_T import;
    void * import_data;
    struct list_head_elinks selectors;
    int import_level;
};

typedef enum term_event_special_key {
    KBD_CTRL_C=-512,
    KBD_F12=-299,
    KBD_F11=-298,
    KBD_F10=-297,
    KBD_F9=-296,
    KBD_F8=-295,
    KBD_F7=-294,
    KBD_F6=-293,
    KBD_F5=-292,
    KBD_F4=-291,
    KBD_F3=-290,
    KBD_F2=-289,
    KBD_F1=-288,
    KBD_PAGE_DOWN=-269,
    KBD_PAGE_UP=-268,
    KBD_END=-267,
    KBD_HOME=-266,
    KBD_DEL=-265,
    KBD_INS=-264,
    KBD_DOWN=-263,
    KBD_UP=-262,
    KBD_RIGHT=-261,
    KBD_LEFT=-260,
    KBD_ESC=-259,
    KBD_TAB=-258,
    KBD_BS=-257,
    KBD_ENTER=-256,
    KBD_UNDEF=-1
} term_event_special_key;

typedef struct itrm itrm, *Pitrm;

typedef struct itrm_in itrm_in, *Pitrm_in;

typedef struct itrm_out itrm_out, *Pitrm_out;

typedef struct itrm_queue itrm_queue, *Pitrm_queue;

struct itrm_queue {
    uchar * data;
    int len;
};

struct itrm_in {
    int std;
    int sock;
    int ctl;
    struct itrm_queue queue;
};

struct itrm_out {
    int std;
    int sock;
    struct itrm_queue queue;
};

struct itrm {
    struct itrm_in in;
    struct itrm_out out;
    timer_id_T timer;
    struct termios t;
    void * mouse_h;
    uchar * orig_title;
    int verase;
    int title_codepage;
    uint blocked:1;
    uint altscreen:1;
    uint touched_title:1;
    uint remote:1;
};

typedef struct interlink_event_keyboard interlink_event_keyboard, *Pinterlink_event_keyboard;

struct interlink_event_keyboard {
    int key;
    int modifier;
};

typedef unicode_val_T term_event_char_T;

typedef struct http_code http_code, *Phttp_code;

struct http_code {
    int num;
    uchar * str;
};

typedef struct http_error_info http_error_info, *Phttp_error_info;

struct http_error_info {
    int code;
    struct uri * uri;
};

typedef enum uri_component {
    URI_HTTP_AUTH=-32717,
    URI_SERVER=-32705,
    URI_ORIGINAL=-32321,
    URI_BASE=-32065,
    URI_PUBLIC=-31305,
    URI_PROXY=-30529,
    URI_FORM_GET=-28609,
    URI_PROTOCOL=1,
    URI_IP_FAMILY=2,
    URI_USER=4,
    URI_PASSWORD=8,
    URI_HOST=16,
    URI_PORT=32,
    URI_HTTP_REFERRER_HOST=49,
    URI_KEEPALIVE=61,
    URI_DEFAULT_PORT=64,
    URI_HTTP_CONNECT=112,
    URI_DATA=128,
    URI_HTTP_REFERRER=177,
    URI_FRAGMENT=256,
    URI_POST=512,
    URI_POST_INFO=1024,
    URI_IDN=2048,
    URI_DNS_HOST=2064,
    URI_HTTP_HOST=2096,
    URI_DIR_LOCATION=2097,
    URI_PATH=4096,
    URI_FILENAME=8192,
    URI_QUERY=16384,
    URI_SPECIAL=28736,
    URI_RARE=32320
} uri_component;

typedef enum uri_errno {
    URI_ERRNO_OK=0,
    URI_ERRNO_EMPTY=1,
    URI_ERRNO_INVALID_PROTOCOL=2,
    URI_ERRNO_NO_SLASHES=3,
    URI_ERRNO_TOO_MANY_SLASHES=4,
    URI_ERRNO_TRAILING_DOTS=5,
    URI_ERRNO_NO_HOST=6,
    URI_ERRNO_NO_PORT_COLON=7,
    URI_ERRNO_NO_HOST_SLASH=8,
    URI_ERRNO_IPV6_SECURITY=9,
    URI_ERRNO_INVALID_PORT=10,
    URI_ERRNO_INVALID_PORT_RANGE=11
} uri_errno;

typedef enum parse_header_param {
    HEADER_PARAM_FOUND=0,
    HEADER_PARAM_NOT_FOUND=1,
    HEADER_PARAM_OUT_OF_MEMORY=2
} parse_header_param;

typedef struct uri_cache_entry uri_cache_entry, *Puri_cache_entry;

struct uri_cache_entry {
    struct uri uri;
    uchar string[1];
};

typedef struct uri_cache uri_cache, *Puri_cache;

struct uri_cache {
    struct hash * map;
    struct object object;
};

typedef struct dom_renderer dom_renderer, *Pdom_renderer;

typedef struct conv_table conv_table, *Pconv_table;

typedef enum convert_string_mode {
    CSM_DEFAULT=0,
    CSM_QUERY=1,
    CSM_FORM=2,
    CSM_NONE=3
} convert_string_mode;

typedef union anon_union_4_2_43af338e_for_u anon_union_4_2_43af338e_for_u, *Panon_union_4_2_43af338e_for_u;

struct dom_renderer {
    enum sgml_document_type doctype;
    struct document * document;
    struct conv_table * convert_table;
    enum convert_string_mode convert_mode;
    struct uri * base_uri;
    uchar * source;
    uchar * end;
    uchar * position;
    int canvas_x;
    int canvas_y;
    struct screen_char styles[13];
    struct dom_node * channel;
    struct dom_node_list * items;
    struct dom_node * item;
    struct dom_node * node;
    struct dom_string text;
};

union anon_union_4_2_43af338e_for_u {
    uchar * str;
    struct conv_table * tbl;
};

struct conv_table {
    int t;
    union anon_union_4_2_43af338e_for_u u;
};

typedef struct table_cache_entry_key table_cache_entry_key, *Ptable_cache_entry_key;

struct table_cache_entry_key {
    uchar * start;
    uchar * end;
    int align;
    int margin;
    int width;
    int x;
    int link_num;
};

typedef struct renderer_context renderer_context, *Prenderer_context;

typedef struct tag tag, *Ptag;

typedef struct link_state_info link_state_info, *Plink_state_info;

struct link_state_info {
    uchar * link;
    uchar * target;
    uchar * image;
    struct form_control * form;
};

struct renderer_context {
    int last_link_to_move;
    struct tag * last_tag_to_move;
    struct tag * last_tag_for_newline;
    struct link_state_info link_state_info;
    struct conv_table * convert_table;
    struct cache_entry * cached;
    int g_ctrl_num;
    int subscript;
    int supscript;
    uint empty_format:1;
    uint nobreak:1;
    uint nosearchable:1;
    uint nowrap:1;
};

struct tag {
    struct tag * next;
    struct tag * prev;
    int x;
    int y;
    uchar name[1];
};

typedef struct plain_renderer plain_renderer, *Pplain_renderer;

struct plain_renderer {
    struct document * document;
    uchar * source;
    int length;
    struct conv_table * convert_table;
    struct screen_char template;
    int max_width;
    int lineno;
    uint compress:1;
};

typedef enum link_state {
    LINK_STATE_NONE=0,
    LINK_STATE_NEW=1,
    LINK_STATE_SAME=2
} link_state;

typedef struct table_cache_entry table_cache_entry, *Ptable_cache_entry;

typedef struct part part, *Ppart;

struct part {
    struct document * document;
    uchar * spaces;
    int spaces_len;
    uchar * char_width;
    struct box box;
    int max_width;
    int xa;
    int cx;
    int cy;
    int link_num;
};

struct table_cache_entry {
    struct table_cache_entry * next;
    struct table_cache_entry * prev;
    struct table_cache_entry_key key;
    struct part part;
};

typedef struct fragment fragment, *Pfragment;

struct fragment {
    struct fragment * next;
    struct fragment * prev;
    off_t offset;
    off_t length;
    off_t real_length;
    uchar data[1];
};

typedef struct formhist_data formhist_data, *Pformhist_data;

struct formhist_data {
    struct formhist_data * next;
    struct formhist_data * prev;
    struct object object;
    struct list_head_elinks * submit;
    struct listbox_item * box_item;
    uint dontsave:1;
    uchar url[1];
};

typedef enum mime_options {
    MIME_TREE=0,
    MIME_DEFAULT_TYPE=1,
    MIME_OPTIONS=2
} mime_options;

typedef struct frameset_param frameset_param, *Pframeset_param;

struct frameset_param {
    struct frameset_desc * parent;
    int x;
    int y;
    int * width;
    int * height;
};

typedef struct mime_handler mime_handler, *Pmime_handler;

struct mime_handler {
    uchar * description;
    uchar * backend_name;
    uint ask:1;
    uint block:1;
    uchar program[1];
};

typedef struct keymap keymap, *Pkeymap;

struct keymap {
    uchar * str;
    enum keymap_id keymap_id;
    uchar * desc;
};

typedef struct action action, *Paction;

struct action {
    uchar * str;
    action_id_T num;
    enum keymap_id keymap_id;
    uchar * desc;
    uint flags;
};

typedef enum menu_action_offset {
    ACT_MENU_OFFSET_NONE=0,
    ACT_MENU_OFFSET_SCRIPTING_FUNCTION=1,
    ACT_MENU_OFFSET_CANCEL=2,
    ACT_MENU_OFFSET_DELETE=3,
    ACT_MENU_OFFSET_DOWN=4,
    ACT_MENU_OFFSET_END=5,
    ACT_MENU_OFFSET_ENTER=6,
    ACT_MENU_OFFSET_EXPAND=7,
    ACT_MENU_OFFSET_HOME=8,
    ACT_MENU_OFFSET_LEFT=9,
    ACT_MENU_OFFSET_MARK_ITEM=10,
    ACT_MENU_OFFSET_NEXT_ITEM=11,
    ACT_MENU_OFFSET_PAGE_DOWN=12,
    ACT_MENU_OFFSET_PAGE_UP=13,
    ACT_MENU_OFFSET_PREVIOUS_ITEM=14,
    ACT_MENU_OFFSET_REDRAW=15,
    ACT_MENU_OFFSET_RIGHT=16,
    ACT_MENU_OFFSET_SEARCH=17,
    ACT_MENU_OFFSET_SELECT=18,
    ACT_MENU_OFFSET_UNEXPAND=19,
    ACT_MENU_OFFSET_UP=20,
    MENU_ACTIONS=21
} menu_action_offset;

typedef enum kbdbind_flags {
    KBDB_WATERMARK=1,
    KBDB_TOUCHED=2,
    KBDB_DEFAULT_KEY=4,
    KBDB_DEFAULT_BINDING=8
} kbdbind_flags;

typedef struct action_list action_list, *Paction_list;

struct action_list {
    struct action * actions;
    int num_actions;
};

typedef struct keybinding keybinding, *Pkeybinding;

struct keybinding {
    struct keybinding * next;
    struct keybinding * prev;
    struct object object;
    enum keymap_id keymap_id;
    action_id_T action_id;
    struct term_event_keyboard kbd;
    int event;
    enum kbdbind_flags flags;
    struct listbox_item * box_item;
};

typedef enum menu_action {
    ACT_MENU_NONE=0,
    ACT_MENU_SCRIPTING_FUNCTION=1,
    ACT_MENU_CANCEL=2,
    ACT_MENU_DELETE=3,
    ACT_MENU_DOWN=4,
    ACT_MENU_END=5,
    ACT_MENU_ENTER=6,
    ACT_MENU_EXPAND=7,
    ACT_MENU_HOME=8,
    ACT_MENU_LEFT=9,
    ACT_MENU_MARK_ITEM=10,
    ACT_MENU_NEXT_ITEM=11,
    ACT_MENU_PAGE_DOWN=12,
    ACT_MENU_PAGE_UP=13,
    ACT_MENU_PREVIOUS_ITEM=14,
    ACT_MENU_REDRAW=15,
    ACT_MENU_RIGHT=16,
    ACT_MENU_SEARCH=17,
    ACT_MENU_SELECT=18,
    ACT_MENU_UNEXPAND=19,
    ACT_MENU_UP=20
} menu_action;

typedef enum edit_action_offset {
    ACT_EDIT_OFFSET_NONE=0,
    ACT_EDIT_OFFSET_SCRIPTING_FUNCTION=1,
    ACT_EDIT_OFFSET_AUTO_COMPLETE=2,
    ACT_EDIT_OFFSET_AUTO_COMPLETE_FILE=3,
    ACT_EDIT_OFFSET_AUTO_COMPLETE_UNAMBIGUOUS=4,
    ACT_EDIT_OFFSET_BACKSPACE=5,
    ACT_EDIT_OFFSET_BEGINNING_OF_BUFFER=6,
    ACT_EDIT_OFFSET_CANCEL=7,
    ACT_EDIT_OFFSET_COPY_CLIPBOARD=8,
    ACT_EDIT_OFFSET_CUT_CLIPBOARD=9,
    ACT_EDIT_OFFSET_DELETE=10,
    ACT_EDIT_OFFSET_DOWN=11,
    ACT_EDIT_OFFSET_END=12,
    ACT_EDIT_OFFSET_END_OF_BUFFER=13,
    ACT_EDIT_OFFSET_ENTER=14,
    ACT_EDIT_OFFSET_HOME=15,
    ACT_EDIT_OFFSET_KILL_TO_BOL=16,
    ACT_EDIT_OFFSET_KILL_TO_EOL=17,
    ACT_EDIT_OFFSET_KILL_WORD_BACK=18,
    ACT_EDIT_OFFSET_LEFT=19,
    ACT_EDIT_OFFSET_MOVE_BACKWARD_WORD=20,
    ACT_EDIT_OFFSET_MOVE_FORWARD_WORD=21,
    ACT_EDIT_OFFSET_NEXT_ITEM=22,
    ACT_EDIT_OFFSET_OPEN_EXTERNAL=23,
    ACT_EDIT_OFFSET_PASTE_CLIPBOARD=24,
    ACT_EDIT_OFFSET_PREVIOUS_ITEM=25,
    ACT_EDIT_OFFSET_REDRAW=26,
    ACT_EDIT_OFFSET_RIGHT=27,
    ACT_EDIT_OFFSET_SEARCH_TOGGLE_REGEX=28,
    ACT_EDIT_OFFSET_UP=29,
    EDIT_ACTIONS=30
} edit_action_offset;

typedef enum main_action_offset {
    ACT_MAIN_OFFSET_NONE=0,
    ACT_MAIN_OFFSET_SCRIPTING_FUNCTION=1,
    ACT_MAIN_OFFSET_ABORT_CONNECTION=2,
    ACT_MAIN_OFFSET_ADD_BOOKMARK=3,
    ACT_MAIN_OFFSET_ADD_BOOKMARK_LINK=4,
    ACT_MAIN_OFFSET_ADD_BOOKMARK_TABS=5,
    ACT_MAIN_OFFSET_AUTH_MANAGER=6,
    ACT_MAIN_OFFSET_BACKSPACE_PREFIX=7,
    ACT_MAIN_OFFSET_BOOKMARK_MANAGER=8,
    ACT_MAIN_OFFSET_CACHE_MANAGER=9,
    ACT_MAIN_OFFSET_CACHE_MINIMIZE=10,
    ACT_MAIN_OFFSET_COOKIE_MANAGER=11,
    ACT_MAIN_OFFSET_COOKIES_LOAD=12,
    ACT_MAIN_OFFSET_COPY_CLIPBOARD=13,
    ACT_MAIN_OFFSET_DOCUMENT_INFO=14,
    ACT_MAIN_OFFSET_DOWNLOAD_MANAGER=15,
    ACT_MAIN_OFFSET_EXMODE=16,
    ACT_MAIN_OFFSET_FILE_MENU=17,
    ACT_MAIN_OFFSET_FIND_NEXT=18,
    ACT_MAIN_OFFSET_FIND_NEXT_BACK=19,
    ACT_MAIN_OFFSET_FORGET_CREDENTIALS=20,
    ACT_MAIN_OFFSET_FORMHIST_MANAGER=21,
    ACT_MAIN_OFFSET_FRAME_EXTERNAL_COMMAND=22,
    ACT_MAIN_OFFSET_FRAME_MAXIMIZE=23,
    ACT_MAIN_OFFSET_FRAME_NEXT=24,
    ACT_MAIN_OFFSET_FRAME_PREV=25,
    ACT_MAIN_OFFSET_GOTO_URL=26,
    ACT_MAIN_OFFSET_GOTO_URL_CURRENT=27,
    ACT_MAIN_OFFSET_GOTO_URL_CURRENT_LINK=28,
    ACT_MAIN_OFFSET_GOTO_URL_HOME=29,
    ACT_MAIN_OFFSET_HEADER_INFO=30,
    ACT_MAIN_OFFSET_HISTORY_MANAGER=31,
    ACT_MAIN_OFFSET_HISTORY_MOVE_BACK=32,
    ACT_MAIN_OFFSET_HISTORY_MOVE_FORWARD=33,
    ACT_MAIN_OFFSET_JUMP_TO_LINK=34,
    ACT_MAIN_OFFSET_KEYBINDING_MANAGER=35,
    ACT_MAIN_OFFSET_KILL_BACKGROUNDED_CONNECTIONS=36,
    ACT_MAIN_OFFSET_LINK_DOWNLOAD=37,
    ACT_MAIN_OFFSET_LINK_DOWNLOAD_IMAGE=38,
    ACT_MAIN_OFFSET_LINK_DOWNLOAD_RESUME=39,
    ACT_MAIN_OFFSET_LINK_EXTERNAL_COMMAND=40,
    ACT_MAIN_OFFSET_LINK_FOLLOW=41,
    ACT_MAIN_OFFSET_LINK_FOLLOW_RELOAD=42,
    ACT_MAIN_OFFSET_LINK_MENU=43,
    ACT_MAIN_OFFSET_LINK_FORM_MENU=44,
    ACT_MAIN_OFFSET_LUA_CONSOLE=45,
    ACT_MAIN_OFFSET_MARK_GOTO=46,
    ACT_MAIN_OFFSET_MARK_SET=47,
    ACT_MAIN_OFFSET_MENU=48,
    ACT_MAIN_OFFSET_MOVE_CURSOR_DOWN=49,
    ACT_MAIN_OFFSET_MOVE_CURSOR_LEFT=50,
    ACT_MAIN_OFFSET_MOVE_CURSOR_LINE_START=51,
    ACT_MAIN_OFFSET_MOVE_CURSOR_RIGHT=52,
    ACT_MAIN_OFFSET_MOVE_CURSOR_UP=53,
    ACT_MAIN_OFFSET_MOVE_DOCUMENT_END=54,
    ACT_MAIN_OFFSET_MOVE_DOCUMENT_START=55,
    ACT_MAIN_OFFSET_MOVE_LINK_DOWN=56,
    ACT_MAIN_OFFSET_MOVE_LINK_DOWN_LINE=57,
    ACT_MAIN_OFFSET_MOVE_LINK_LEFT=58,
    ACT_MAIN_OFFSET_MOVE_LINK_LEFT_LINE=59,
    ACT_MAIN_OFFSET_MOVE_LINK_NEXT=60,
    ACT_MAIN_OFFSET_MOVE_LINK_PREV=61,
    ACT_MAIN_OFFSET_MOVE_LINK_RIGHT=62,
    ACT_MAIN_OFFSET_MOVE_LINK_RIGHT_LINE=63,
    ACT_MAIN_OFFSET_MOVE_LINK_UP=64,
    ACT_MAIN_OFFSET_MOVE_LINK_UP_LINE=65,
    ACT_MAIN_OFFSET_MOVE_PAGE_DOWN=66,
    ACT_MAIN_OFFSET_MOVE_PAGE_UP=67,
    ACT_MAIN_OFFSET_OPEN_LINK_IN_NEW_TAB=68,
    ACT_MAIN_OFFSET_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND=69,
    ACT_MAIN_OFFSET_OPEN_LINK_IN_NEW_WINDOW=70,
    ACT_MAIN_OFFSET_OPEN_NEW_TAB=71,
    ACT_MAIN_OFFSET_OPEN_NEW_TAB_IN_BACKGROUND=72,
    ACT_MAIN_OFFSET_OPEN_NEW_WINDOW=73,
    ACT_MAIN_OFFSET_OPEN_OS_SHELL=74,
    ACT_MAIN_OFFSET_OPTIONS_MANAGER=75,
    ACT_MAIN_OFFSET_QUIT=76,
    ACT_MAIN_OFFSET_REALLY_QUIT=77,
    ACT_MAIN_OFFSET_REDRAW=78,
    ACT_MAIN_OFFSET_RELOAD=79,
    ACT_MAIN_OFFSET_RERENDER=80,
    ACT_MAIN_OFFSET_RESET_FORM=81,
    ACT_MAIN_OFFSET_RESOURCE_INFO=82,
    ACT_MAIN_OFFSET_SAVE_AS=83,
    ACT_MAIN_OFFSET_SAVE_FORMATTED=84,
    ACT_MAIN_OFFSET_SAVE_OPTIONS=85,
    ACT_MAIN_OFFSET_SAVE_URL_AS=86,
    ACT_MAIN_OFFSET_SCROLL_DOWN=87,
    ACT_MAIN_OFFSET_SCROLL_LEFT=88,
    ACT_MAIN_OFFSET_SCROLL_RIGHT=89,
    ACT_MAIN_OFFSET_SCROLL_UP=90,
    ACT_MAIN_OFFSET_SEARCH=91,
    ACT_MAIN_OFFSET_SEARCH_BACK=92,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD=93,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD_LINK=94,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD_TEXT=95,
    ACT_MAIN_OFFSET_SEARCH_TYPEAHEAD_TEXT_BACK=96,
    ACT_MAIN_OFFSET_SHOW_TERM_OPTIONS=97,
    ACT_MAIN_OFFSET_SUBMIT_FORM=98,
    ACT_MAIN_OFFSET_SUBMIT_FORM_RELOAD=99,
    ACT_MAIN_OFFSET_TAB_CLOSE=100,
    ACT_MAIN_OFFSET_TAB_CLOSE_ALL_BUT_CURRENT=101,
    ACT_MAIN_OFFSET_TAB_EXTERNAL_COMMAND=102,
    ACT_MAIN_OFFSET_TAB_MENU=103,
    ACT_MAIN_OFFSET_TAB_MOVE_LEFT=104,
    ACT_MAIN_OFFSET_TAB_MOVE_RIGHT=105,
    ACT_MAIN_OFFSET_TAB_NEXT=106,
    ACT_MAIN_OFFSET_TAB_PREV=107,
    ACT_MAIN_OFFSET_TERMINAL_RESIZE=108,
    ACT_MAIN_OFFSET_TOGGLE_CSS=109,
    ACT_MAIN_OFFSET_TOGGLE_DISPLAY_IMAGES=110,
    ACT_MAIN_OFFSET_TOGGLE_DISPLAY_TABLES=111,
    ACT_MAIN_OFFSET_TOGGLE_DOCUMENT_COLORS=112,
    ACT_MAIN_OFFSET_TOGGLE_HTML_PLAIN=113,
    ACT_MAIN_OFFSET_TOGGLE_MOUSE=114,
    ACT_MAIN_OFFSET_TOGGLE_NUMBERED_LINKS=115,
    ACT_MAIN_OFFSET_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES=116,
    ACT_MAIN_OFFSET_TOGGLE_WRAP_TEXT=117,
    ACT_MAIN_OFFSET_VIEW_IMAGE=118,
    MAIN_ACTIONS=119
} main_action_offset;

typedef enum action_flags {
    ACTION_RESTRICT_ANONYMOUS=65536,
    ACTION_REQUIRE_VIEW_STATE=131072,
    ACTION_REQUIRE_LOCATION=262144,
    ACTION_JUMP_TO_LINK=524288,
    ACTION_REQUIRE_LINK=1048576,
    ACTION_REQUIRE_FORM=2097152,
    ACTION_FLAGS_MASK=16711680
} action_flags;

typedef enum edit_action {
    ACT_EDIT_NONE=0,
    ACT_EDIT_SCRIPTING_FUNCTION=1,
    ACT_EDIT_AUTO_COMPLETE=2,
    ACT_EDIT_AUTO_COMPLETE_FILE=3,
    ACT_EDIT_AUTO_COMPLETE_UNAMBIGUOUS=4,
    ACT_EDIT_BACKSPACE=5,
    ACT_EDIT_BEGINNING_OF_BUFFER=6,
    ACT_EDIT_CANCEL=7,
    ACT_EDIT_COPY_CLIPBOARD=8,
    ACT_EDIT_CUT_CLIPBOARD=9,
    ACT_EDIT_DELETE=10,
    ACT_EDIT_DOWN=11,
    ACT_EDIT_END=12,
    ACT_EDIT_END_OF_BUFFER=13,
    ACT_EDIT_ENTER=14,
    ACT_EDIT_HOME=15,
    ACT_EDIT_KILL_TO_BOL=16,
    ACT_EDIT_KILL_TO_EOL=17,
    ACT_EDIT_KILL_WORD_BACK=18,
    ACT_EDIT_LEFT=19,
    ACT_EDIT_MOVE_BACKWARD_WORD=20,
    ACT_EDIT_MOVE_FORWARD_WORD=21,
    ACT_EDIT_NEXT_ITEM=22,
    ACT_EDIT_OPEN_EXTERNAL=23,
    ACT_EDIT_PASTE_CLIPBOARD=24,
    ACT_EDIT_PREVIOUS_ITEM=25,
    ACT_EDIT_REDRAW=26,
    ACT_EDIT_RIGHT=27,
    ACT_EDIT_SEARCH_TOGGLE_REGEX=28,
    ACT_EDIT_UP=29
} edit_action;

typedef struct option_type_info option_type_info, *Poption_type_info;

struct option_type_info {
    uchar * name;
    uchar * (* cmdline)(struct option_elinks *, uchar * * *, int *);
    uchar * (* read)(struct option_elinks *, uchar * *, int *);
    void (* write)(struct option_elinks *, struct string *);
    void (* dup)(struct option_elinks *, struct option_elinks *);
    int (* set)(struct option_elinks *, uchar *);
    int (* equals)(struct option_elinks *, uchar *);
    uchar * help_str;
};

typedef struct mimetypes_entry mimetypes_entry, *Pmimetypes_entry;

struct mimetypes_entry {
    uchar * content_type;
    uchar extension[1];
};

typedef enum mimetypes_option {
    MIMETYPES_TREE=0,
    MIMETYPES_ENABLE=1,
    MIMETYPES_PATH=2,
    MIMETYPES_OPTIONS=3
} mimetypes_option;

typedef struct entity entity, *Pentity;

struct entity {
    char * s;
    unicode_val_T c;
};

typedef struct blacklist_entry blacklist_entry, *Pblacklist_entry;

struct blacklist_entry {
    struct blacklist_entry * next;
    struct blacklist_entry * prev;
    enum blacklist_flags flags;
    uchar host[1];
};

typedef struct erb_protect_info erb_protect_info, *Perb_protect_info;

struct erb_protect_info {
    uchar * name;
    int argc;
    VALUE * args;
};

typedef enum referer {
    REFERER_NONE=0,
    REFERER_SAME_URL=1,
    REFERER_FAKE=2,
    REFERER_TRUE=3
} referer;

typedef struct change_hook_info change_hook_info, *Pchange_hook_info;

struct change_hook_info {
    uchar * name;
    change_hook_T change_hook;
};

typedef struct option_resolver option_resolver, *Poption_resolver;

struct option_resolver {
    int id;
    uchar * name;
};

typedef enum verbose_level {
    VERBOSE_QUIET=0,
    VERBOSE_WARNINGS=1,
    VERBOSE_ALL=2,
    VERBOSE_LEVELS=3
} verbose_level;

typedef enum html_element_type {
    HTML_ELEMENT_UNKNOWN=0,
    HTML_ELEMENT_A=1,
    HTML_ELEMENT_ABBR=2,
    HTML_ELEMENT_ACRONYM=3,
    HTML_ELEMENT_ADDRESS=4,
    HTML_ELEMENT_APPLET=5,
    HTML_ELEMENT_AREA=6,
    HTML_ELEMENT_B=7,
    HTML_ELEMENT_BASE=8,
    HTML_ELEMENT_BASEFONT=9,
    HTML_ELEMENT_BDO=10,
    HTML_ELEMENT_BIG=11,
    HTML_ELEMENT_BLOCKQUOTE=12,
    HTML_ELEMENT_BODY=13,
    HTML_ELEMENT_BR=14,
    HTML_ELEMENT_BUTTON=15,
    HTML_ELEMENT_CAPTION=16,
    HTML_ELEMENT_CENTER=17,
    HTML_ELEMENT_CITE=18,
    HTML_ELEMENT_CODE=19,
    HTML_ELEMENT_COL=20,
    HTML_ELEMENT_COLGROUP=21,
    HTML_ELEMENT_DD=22,
    HTML_ELEMENT_DEL=23,
    HTML_ELEMENT_DFN=24,
    HTML_ELEMENT_DIR=25,
    HTML_ELEMENT_DIV=26,
    HTML_ELEMENT_DL=27,
    HTML_ELEMENT_DT=28,
    HTML_ELEMENT_EM=29,
    HTML_ELEMENT_FIELDSET=30,
    HTML_ELEMENT_FONT=31,
    HTML_ELEMENT_FORM=32,
    HTML_ELEMENT_FRAME=33,
    HTML_ELEMENT_FRAMESET=34,
    HTML_ELEMENT_H1=35,
    HTML_ELEMENT_H2=36,
    HTML_ELEMENT_H3=37,
    HTML_ELEMENT_H4=38,
    HTML_ELEMENT_H5=39,
    HTML_ELEMENT_H6=40,
    HTML_ELEMENT_HEAD=41,
    HTML_ELEMENT_HR=42,
    HTML_ELEMENT_HTML=43,
    HTML_ELEMENT_I=44,
    HTML_ELEMENT_IFRAME=45,
    HTML_ELEMENT_IMG=46,
    HTML_ELEMENT_INPUT=47,
    HTML_ELEMENT_INS=48,
    HTML_ELEMENT_ISINDEX=49,
    HTML_ELEMENT_KBD=50,
    HTML_ELEMENT_LABEL=51,
    HTML_ELEMENT_LEGEND=52,
    HTML_ELEMENT_LI=53,
    HTML_ELEMENT_LINK=54,
    HTML_ELEMENT_MAP=55,
    HTML_ELEMENT_MENU=56,
    HTML_ELEMENT_META=57,
    HTML_ELEMENT_NOFRAMES=58,
    HTML_ELEMENT_NOSCRIPT=59,
    HTML_ELEMENT_OBJECT=60,
    HTML_ELEMENT_OL=61,
    HTML_ELEMENT_OPTGROUP=62,
    HTML_ELEMENT_OPTION=63,
    HTML_ELEMENT_P=64,
    HTML_ELEMENT_PARAM=65,
    HTML_ELEMENT_PRE=66,
    HTML_ELEMENT_Q=67,
    HTML_ELEMENT_S=68,
    HTML_ELEMENT_SAMP=69,
    HTML_ELEMENT_SCRIPT=70,
    HTML_ELEMENT_SELECT=71,
    HTML_ELEMENT_SMALL=72,
    HTML_ELEMENT_SPAN=73,
    HTML_ELEMENT_STRIKE=74,
    HTML_ELEMENT_STRONG=75,
    HTML_ELEMENT_STYLE=76,
    HTML_ELEMENT_SUB=77,
    HTML_ELEMENT_SUP=78,
    HTML_ELEMENT_TABLE=79,
    HTML_ELEMENT_TBODY=80,
    HTML_ELEMENT_TD=81,
    HTML_ELEMENT_TEXTAREA=82,
    HTML_ELEMENT_TFOOT=83,
    HTML_ELEMENT_TH=84,
    HTML_ELEMENT_THEAD=85,
    HTML_ELEMENT_TITLE=86,
    HTML_ELEMENT_TR=87,
    HTML_ELEMENT_TT=88,
    HTML_ELEMENT_U=89,
    HTML_ELEMENT_UL=90,
    HTML_ELEMENT_VAR=91,
    HTML_ELEMENT_XMP=92,
    HTML_ELEMENTS=93
} html_element_type;

typedef enum html_attribute_type {
    HTML_ATTRIBUTE_UNKNOWN=0,
    HTML_ATTRIBUTE_ABBR=1,
    HTML_ATTRIBUTE_ACCEPT=2,
    HTML_ATTRIBUTE_ACCEPT_CHARSET=3,
    HTML_ATTRIBUTE_ACCESSKEY=4,
    HTML_ATTRIBUTE_ACTION=5,
    HTML_ATTRIBUTE_ALIGN=6,
    HTML_ATTRIBUTE_ALINK=7,
    HTML_ATTRIBUTE_ALT=8,
    HTML_ATTRIBUTE_ARCHIVE=9,
    HTML_ATTRIBUTE_AXIS=10,
    HTML_ATTRIBUTE_BACKGROUND=11,
    HTML_ATTRIBUTE_BGCOLOR=12,
    HTML_ATTRIBUTE_BORDER=13,
    HTML_ATTRIBUTE_BORDERCOLOR=14,
    HTML_ATTRIBUTE_CELLPADDING=15,
    HTML_ATTRIBUTE_CELLSPACING=16,
    HTML_ATTRIBUTE_CHAR=17,
    HTML_ATTRIBUTE_CHAROFF=18,
    HTML_ATTRIBUTE_CHARSET=19,
    HTML_ATTRIBUTE_CHECKED=20,
    HTML_ATTRIBUTE_CITE=21,
    HTML_ATTRIBUTE_CLASS=22,
    HTML_ATTRIBUTE_CLASSID=23,
    HTML_ATTRIBUTE_CLEAR=24,
    HTML_ATTRIBUTE_CODE=25,
    HTML_ATTRIBUTE_CODEBASE=26,
    HTML_ATTRIBUTE_CODETYPE=27,
    HTML_ATTRIBUTE_COLOR=28,
    HTML_ATTRIBUTE_COLS=29,
    HTML_ATTRIBUTE_COLSPAN=30,
    HTML_ATTRIBUTE_COMPACT=31,
    HTML_ATTRIBUTE_CONTENT=32,
    HTML_ATTRIBUTE_COORDS=33,
    HTML_ATTRIBUTE_DATA=34,
    HTML_ATTRIBUTE_DATETIME=35,
    HTML_ATTRIBUTE_DECLARE=36,
    HTML_ATTRIBUTE_DEFER=37,
    HTML_ATTRIBUTE_DIR=38,
    HTML_ATTRIBUTE_DISABLED=39,
    HTML_ATTRIBUTE_ENCTYPE=40,
    HTML_ATTRIBUTE_FACE=41,
    HTML_ATTRIBUTE_FOR=42,
    HTML_ATTRIBUTE_FRAME=43,
    HTML_ATTRIBUTE_FRAMEBORDER=44,
    HTML_ATTRIBUTE_HEADERS=45,
    HTML_ATTRIBUTE_HEIGHT=46,
    HTML_ATTRIBUTE_HREF=47,
    HTML_ATTRIBUTE_HREFLANG=48,
    HTML_ATTRIBUTE_HSPACE=49,
    HTML_ATTRIBUTE_HTTP_EQUIV=50,
    HTML_ATTRIBUTE_ID=51,
    HTML_ATTRIBUTE_ISMAP=52,
    HTML_ATTRIBUTE_LABEL=53,
    HTML_ATTRIBUTE_LANG=54,
    HTML_ATTRIBUTE_LANGUAGE=55,
    HTML_ATTRIBUTE_LINK=56,
    HTML_ATTRIBUTE_LONGDESC=57,
    HTML_ATTRIBUTE_MARGINHEIGHT=58,
    HTML_ATTRIBUTE_MARGINWIDTH=59,
    HTML_ATTRIBUTE_MAXLENGTH=60,
    HTML_ATTRIBUTE_MEDIA=61,
    HTML_ATTRIBUTE_METHOD=62,
    HTML_ATTRIBUTE_MULTIPLE=63,
    HTML_ATTRIBUTE_NAME=64,
    HTML_ATTRIBUTE_NOHREF=65,
    HTML_ATTRIBUTE_NORESIZE=66,
    HTML_ATTRIBUTE_NOSHADE=67,
    HTML_ATTRIBUTE_NOWRAP=68,
    HTML_ATTRIBUTE_OBJECT=69,
    HTML_ATTRIBUTE_ONBLUR=70,
    HTML_ATTRIBUTE_ONCHANGE=71,
    HTML_ATTRIBUTE_ONCLICK=72,
    HTML_ATTRIBUTE_ONDBLCLICK=73,
    HTML_ATTRIBUTE_ONFOCUS=74,
    HTML_ATTRIBUTE_ONKEYDOWN=75,
    HTML_ATTRIBUTE_ONKEYPRESS=76,
    HTML_ATTRIBUTE_ONKEYUP=77,
    HTML_ATTRIBUTE_ONLOAD=78,
    HTML_ATTRIBUTE_ONMOUSEDOWN=79,
    HTML_ATTRIBUTE_ONMOUSEMOVE=80,
    HTML_ATTRIBUTE_ONMOUSEOUT=81,
    HTML_ATTRIBUTE_ONMOUSEOVER=82,
    HTML_ATTRIBUTE_ONMOUSEUP=83,
    HTML_ATTRIBUTE_ONRESET=84,
    HTML_ATTRIBUTE_ONSELECT=85,
    HTML_ATTRIBUTE_ONSUBMIT=86,
    HTML_ATTRIBUTE_ONUNLOAD=87,
    HTML_ATTRIBUTE_PROFILE=88,
    HTML_ATTRIBUTE_PROMPT=89,
    HTML_ATTRIBUTE_READONLY=90,
    HTML_ATTRIBUTE_REL=91,
    HTML_ATTRIBUTE_REV=92,
    HTML_ATTRIBUTE_ROWS=93,
    HTML_ATTRIBUTE_ROWSPAN=94,
    HTML_ATTRIBUTE_RULES=95,
    HTML_ATTRIBUTE_SCHEME=96,
    HTML_ATTRIBUTE_SCOPE=97,
    HTML_ATTRIBUTE_SCROLLING=98,
    HTML_ATTRIBUTE_SELECTED=99,
    HTML_ATTRIBUTE_SHAPE=100,
    HTML_ATTRIBUTE_SIZE=101,
    HTML_ATTRIBUTE_SPAN=102,
    HTML_ATTRIBUTE_SRC=103,
    HTML_ATTRIBUTE_STANDBY=104,
    HTML_ATTRIBUTE_START=105,
    HTML_ATTRIBUTE_STYLE=106,
    HTML_ATTRIBUTE_SUMMARY=107,
    HTML_ATTRIBUTE_TABINDEX=108,
    HTML_ATTRIBUTE_TARGET=109,
    HTML_ATTRIBUTE_TEXT=110,
    HTML_ATTRIBUTE_TITLE=111,
    HTML_ATTRIBUTE_TYPE=112,
    HTML_ATTRIBUTE_URL=113,
    HTML_ATTRIBUTE_USEMAP=114,
    HTML_ATTRIBUTE_VALIGN=115,
    HTML_ATTRIBUTE_VALUE=116,
    HTML_ATTRIBUTE_VALUETYPE=117,
    HTML_ATTRIBUTE_VERSION=118,
    HTML_ATTRIBUTE_VISIBILITY=119,
    HTML_ATTRIBUTE_VLINK=120,
    HTML_ATTRIBUTE_VSPACE=121,
    HTML_ATTRIBUTE_WIDTH=122,
    HTML_ATTRIBUTES=123
} html_attribute_type;

typedef enum termopt {
    TERM_OPT_TYPE=0,
    TERM_OPT_M11_HACK=1,
    TERM_OPT_RESTRICT_852=2,
    TERM_OPT_BLOCK_CURSOR=3,
    TERM_OPT_COLORS=4,
    TERM_OPT_UTF_8_IO=5,
    TERM_OPT_TRANSPARENCY=6,
    TERM_OPT_UNDERLINE=7,
    TERM_OPTIONS=8
} termopt;

typedef struct action_alias action_alias, *Paction_alias;

struct action_alias {
    uchar * str;
    action_id_T action_id;
};

typedef struct named_key named_key, *Pnamed_key;

struct named_key {
    uchar * str;
    term_event_key_T num;
};

typedef struct default_kb default_kb, *Pdefault_kb;

struct default_kb {
    struct term_event_keyboard kbd;
    action_id_T action_id;
};

typedef enum select_handler_type {
    SELECT_HANDLER_READ=0,
    SELECT_HANDLER_WRITE=1,
    SELECT_HANDLER_ERROR=2,
    SELECT_HANDLER_DATA=3
} select_handler_type;

typedef struct dom_select_node dom_select_node, *Pdom_select_node;

typedef struct dom_select_nth_match dom_select_nth_match, *Pdom_select_nth_match;

typedef union anon_union_4_3_7017aa2b_for_match anon_union_4_3_7017aa2b_for_match, *Panon_union_4_3_7017aa2b_for_match;

typedef enum dom_select_element_match {
    DOM_SELECT_RELATION_DESCENDANT=0,
    DOM_SELECT_RELATION_DIRECT_CHILD=1,
    DOM_SELECT_RELATION_DIRECT_ADJACENT=2,
    DOM_SELECT_RELATION_INDIRECT_ADJACENT=4,
    DOM_SELECT_RELATION_FLAGS=7,
    DOM_SELECT_ELEMENT_UNIVERSAL=8,
    DOM_SELECT_ELEMENT_ROOT=16,
    DOM_SELECT_ELEMENT_EMPTY=32,
    DOM_SELECT_ELEMENT_NTH_CHILD=64,
    DOM_SELECT_ELEMENT_NTH_TYPE=128
} dom_select_element_match;

typedef enum dom_select_attribute_match {
    DOM_SELECT_ATTRIBUTE_ANY=1,
    DOM_SELECT_ATTRIBUTE_EXACT=2,
    DOM_SELECT_ATTRIBUTE_SPACE_LIST=4,
    DOM_SELECT_ATTRIBUTE_HYPHEN_LIST=8,
    DOM_SELECT_ATTRIBUTE_BEGIN=16,
    DOM_SELECT_ATTRIBUTE_END=32,
    DOM_SELECT_ATTRIBUTE_CONTAINS=64,
    DOM_SELECT_ATTRIBUTE_ID=128
} dom_select_attribute_match;

typedef enum dom_select_text_match {
    DOM_SELECT_TEXT_CONTAINS=1
} dom_select_text_match;

struct dom_select_nth_match {
    size_t step;
    size_t index;
};

union anon_union_4_3_7017aa2b_for_match {
    enum dom_select_element_match element;
    enum dom_select_attribute_match attribute;
    enum dom_select_text_match text;
};

struct dom_select_node {
    struct dom_node node;
    struct dom_select_nth_match nth_child;
    struct dom_select_nth_match nth_type;
    union anon_union_4_3_7017aa2b_for_match match;
};

typedef enum dom_select_pseudo {
    DOM_SELECT_PSEUDO_UNKNOWN=0,
    DOM_SELECT_PSEUDO_FIRST_LINE=1,
    DOM_SELECT_PSEUDO_FIRST_LETTER=2,
    DOM_SELECT_PSEUDO_SELECTION=4,
    DOM_SELECT_PSEUDO_AFTER=8,
    DOM_SELECT_PSEUDO_BEFORE=16,
    DOM_SELECT_PSEUDO_LINK=32,
    DOM_SELECT_PSEUDO_VISITED=64,
    DOM_SELECT_PSEUDO_ACTIVE=128,
    DOM_SELECT_PSEUDO_HOVER=256,
    DOM_SELECT_PSEUDO_FOCUS=512,
    DOM_SELECT_PSEUDO_TARGET=1024,
    DOM_SELECT_PSEUDO_ENABLED=2048,
    DOM_SELECT_PSEUDO_DISABLED=4096,
    DOM_SELECT_PSEUDO_CHECKED=8192,
    DOM_SELECT_PSEUDO_CONTAINS=10000,
    DOM_SELECT_PSEUDO_NTH_CHILD=10001,
    DOM_SELECT_PSEUDO_NTH_LAST_CHILD=10002,
    DOM_SELECT_PSEUDO_FIRST_CHILD=10003,
    DOM_SELECT_PSEUDO_LAST_CHILD=10004,
    DOM_SELECT_PSEUDO_ONLY_CHILD=10005,
    DOM_SELECT_PSEUDO_NTH_TYPE=10006,
    DOM_SELECT_PSEUDO_NTH_LAST_TYPE=10007,
    DOM_SELECT_PSEUDO_FIRST_TYPE=10008,
    DOM_SELECT_PSEUDO_LAST_TYPE=10009,
    DOM_SELECT_PSEUDO_ONLY_TYPE=10010,
    DOM_SELECT_PSEUDO_ROOT=10011,
    DOM_SELECT_PSEUDO_EMPTY=10012,
    DOM_SELECT_PSEUDO_INDETERMINATE=16384
} dom_select_pseudo;

typedef struct fd_set fd_set, *Pfd_set;

struct fd_set {
    __fd_mask __fds_bits[32];
};

typedef enum dom_select_syntax {
    DOM_SELECT_SYNTAX_CSS=0,
    DOM_SELECT_SYNTAX_PATH=1
} dom_select_syntax;

typedef struct dom_select dom_select, *Pdom_select;

struct dom_select {
    struct dom_select_node * selector;
    ulong specificity;
    enum dom_select_pseudo pseudo;
};

typedef void (* select_handler_T)(void *);

typedef struct bottom_half bottom_half, *Pbottom_half;

struct bottom_half {
    struct bottom_half * next;
    struct bottom_half * prev;
    select_handler_T fn;
    void * data;
};

typedef struct thread thread, *Pthread;

struct thread {
    select_handler_T read_func;
    select_handler_T write_func;
    select_handler_T error_func;
    void * data;
};

typedef struct dom_select_data dom_select_data, *Pdom_select_data;

struct dom_select_data {
    struct dom_stack stack;
    struct dom_select * select;
    struct dom_node_list * list;
};

typedef struct dom_select_state dom_select_state, *Pdom_select_state;

struct dom_select_state {
    struct dom_node * node;
};

typedef struct anon_struct_12_2_b9013266 anon_struct_12_2_b9013266, *Panon_struct_12_2_b9013266;

struct anon_struct_12_2_b9013266 {
    struct dom_string string;
    enum dom_select_pseudo pseudo;
};

typedef struct XML_ParserStruct XML_ParserStruct, *PXML_ParserStruct;

typedef struct XML_ParserStruct * XML_Parser;

struct XML_ParserStruct {
};

typedef enum retval {
    RET_OK=0,
    RET_ERROR=1,
    RET_SIGNAL=2,
    RET_SYNTAX=3,
    RET_FATAL=4,
    RET_PING=5,
    RET_REMOTE=6,
    RET_COMMAND=7
} retval;

typedef struct program program, *Pprogram;

struct program {
    int terminate;
    enum retval retval;
    uchar * path;
};

typedef struct list_menu list_menu, *Plist_menu;

struct list_menu {
    struct menu_item * * stack;
    int stack_size;
};

typedef struct ftp_connection_info ftp_connection_info, *Pftp_connection_info;

struct ftp_connection_info {
    int pending_commands;
    int opc;
    int conn_state;
    int buf_pos;
    uint dir:1;
    uint rest_sent:1;
    uint use_pasv:1;
    uint use_epsv:1;
    uchar ftp_buffer[16384];
    uchar cmd_buffer[1];
};

typedef struct ftp_dir_html_format ftp_dir_html_format, *Pftp_dir_html_format;

struct ftp_dir_html_format {
    int libc_codepage;
    int colorize_dir;
    uchar dircolor[8];
};

typedef struct type_query type_query, *Ptype_query;

struct type_query {
    struct type_query * next;
    struct type_query * prev;
    struct download download;
    struct cache_entry * cached;
    struct session * ses;
    struct uri * uri;
    uchar * target_frame;
    uchar * external_handler;
    int block;
    uint cgi:1;
};

typedef struct file_download file_download, *Pfile_download;

struct file_download {
    struct file_download * next;
    struct file_download * prev;
    struct object object;
    struct uri * uri;
    uchar * file;
    uchar * external_handler;
    struct session * ses;
    struct terminal * term;
    time_t remotetime;
    off_t seek;
    int handle;
    int redirect_cnt;
    int notify;
    struct download download;
    uint delete:1;
    uint stop:1;
    uint block:1;
    struct dialog_data * dlg_data;
    struct listbox_item * box_item;
};

typedef __mode_t mode_t;


// WARNING! conflicting data type names: /DWARF/dirent.h/DIR - /dirent.h/DIR

typedef struct dirent dirent, *Pdirent;

struct dirent {
    __ino64_t d_ino;
    __off64_t d_off;
    ushort d_reclen;
    uchar d_type;
    char d_name[256];
};


// WARNING! conflicting data type names: /DWARF/utime.h/utimbuf - /utime.h/utimbuf


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo - /siginfo.h/siginfo


// WARNING! conflicting data type names: /DWARF/siginfo.h/siginfo_t - /siginfo.h/siginfo_t

typedef union anon_union_116_7_b489c2e4_for__sifields anon_union_116_7_b489c2e4_for__sifields, *Panon_union_116_7_b489c2e4_for__sifields;

typedef struct anon_struct_8_2_0a3d7222_for__kill anon_struct_8_2_0a3d7222_for__kill, *Panon_struct_8_2_0a3d7222_for__kill;

typedef struct anon_struct_12_3_5124685d_for__timer anon_struct_12_3_5124685d_for__timer, *Panon_struct_12_3_5124685d_for__timer;

typedef struct anon_struct_12_3_9bedbd60_for__rt anon_struct_12_3_9bedbd60_for__rt, *Panon_struct_12_3_9bedbd60_for__rt;

typedef struct anon_struct_20_5_7a025f54_for__sigchld anon_struct_20_5_7a025f54_for__sigchld, *Panon_struct_20_5_7a025f54_for__sigchld;

typedef struct anon_struct_4_1_ff5bff1a_for__sigfault anon_struct_4_1_ff5bff1a_for__sigfault, *Panon_struct_4_1_ff5bff1a_for__sigfault;

typedef struct anon_struct_8_2_686959ae_for__sigpoll anon_struct_8_2_686959ae_for__sigpoll, *Panon_struct_8_2_686959ae_for__sigpoll;

struct anon_struct_8_2_686959ae_for__sigpoll {
    long si_band;
    int si_fd;
};

struct anon_struct_4_1_ff5bff1a_for__sigfault {
    void * si_addr;
};

struct anon_struct_12_3_5124685d_for__timer {
    int si_tid;
    int si_overrun;
    sigval_t si_sigval;
};

struct anon_struct_12_3_9bedbd60_for__rt {
    __pid_t si_pid;
    __uid_t si_uid;
    sigval_t si_sigval;
};

struct anon_struct_8_2_0a3d7222_for__kill {
    __pid_t si_pid;
    __uid_t si_uid;
};

struct anon_struct_20_5_7a025f54_for__sigchld {
    __pid_t si_pid;
    __uid_t si_uid;
    int si_status;
    __clock_t si_utime;
    __clock_t si_stime;
};

union anon_union_116_7_b489c2e4_for__sifields {
    int _pad[29];
    struct anon_struct_8_2_0a3d7222_for__kill _kill;
    struct anon_struct_12_3_5124685d_for__timer _timer;
    struct anon_struct_12_3_9bedbd60_for__rt _rt;
    struct anon_struct_20_5_7a025f54_for__sigchld _sigchld;
    struct anon_struct_4_1_ff5bff1a_for__sigfault _sigfault;
    struct anon_struct_8_2_686959ae_for__sigpoll _sigpoll;
};

typedef enum parse_error {
    ERROR_NONE=0,
    ERROR_COMMAND=1,
    ERROR_PARSE=2,
    ERROR_OPTION=3,
    ERROR_VALUE=4,
    ERROR_NOMEM=5
} parse_error;

typedef struct conf_parsing_pos conf_parsing_pos, *Pconf_parsing_pos;

struct conf_parsing_pos {
    uchar * look;
    int line;
};

typedef struct parse_handler parse_handler, *Pparse_handler;

typedef struct conf_parsing_state conf_parsing_state, *Pconf_parsing_state;

struct conf_parsing_state {
    struct conf_parsing_pos pos;
    uchar * mirrored;
    uchar * filename;
};

struct parse_handler {
    uchar * command;
    parse_error (* handler)(struct option_elinks *, struct conf_parsing_state *, struct string *, int);
};

typedef enum border_char {
    BORDER_NONE=0,
    BORDER_SVLINE=179,
    BORDER_SLTEE=180,
    BORDER_SDLTEE=181,
    BORDER_DSLTEE=182,
    BORDER_DSURCORNER=183,
    BORDER_SDURCORNER=184,
    BORDER_DLTEE=185,
    BORDER_DVLINE=186,
    BORDER_DURCORNER=187,
    BORDER_DDRCORNER=188,
    BORDER_DSDRCORNER=189,
    BORDER_SDDRCORNER=190,
    BORDER_SURCORNER=191,
    BORDER_SDLCORNER=192,
    BORDER_SUTEE=193,
    BORDER_SDTEE=194,
    BORDER_SRTEE=195,
    BORDER_SHLINE=196,
    BORDER_SCROSS=197,
    BORDER_SDRTEE=198,
    BORDER_DSRTEE=199,
    BORDER_DDLCORNER=200,
    BORDER_DULCORNER=201,
    BORDER_DUTEE=202,
    BORDER_DDTEE=203,
    BORDER_DRTEE=204,
    BORDER_DHLINE=205,
    BORDER_DCROSS=206,
    BORDER_SDUTEE=207,
    BORDER_DSUTEE=208,
    BORDER_SDDTEE=209,
    BORDER_DSDTEE=210,
    BORDER_DSDLCORNER=211,
    BORDER_SDDLCORNER=212,
    BORDER_SDULCORNER=213,
    BORDER_DSULCORNER=214,
    BORDER_DSCROSS=215,
    BORDER_SDCROSS=216,
    BORDER_SDRCORNER=217,
    BORDER_SULCORNER=218
} border_char;

typedef enum screen_char_attr {
    SCREEN_ATTR_UNSEARCHABLE=1,
    SCREEN_ATTR_BOLD=8,
    SCREEN_ATTR_ITALIC=16,
    SCREEN_ATTR_UNDERLINE=32,
    SCREEN_ATTR_STANDOUT=64,
    SCREEN_ATTR_FRAME=128
} screen_char_attr;

typedef enum border_cross_direction {
    BORDER_X_RIGHT=0,
    BORDER_X_LEFT=1,
    BORDER_X_DOWN=2,
    BORDER_X_UP=3
} border_cross_direction;

typedef struct hlink hlink, *Phlink;

typedef enum hlink_type {
    LT_UNKNOWN=0,
    LT_START=1,
    LT_PARENT=2,
    LT_NEXT=3,
    LT_PREV=4,
    LT_CONTENTS=5,
    LT_INDEX=6,
    LT_GLOSSARY=7,
    LT_CHAPTER=8,
    LT_SECTION=9,
    LT_SUBSECTION=10,
    LT_APPENDIX=11,
    LT_HELP=12,
    LT_SEARCH=13,
    LT_BOOKMARK=14,
    LT_COPYRIGHT=15,
    LT_AUTHOR=16,
    LT_ICON=17,
    LT_ALTERNATE=18,
    LT_ALTERNATE_LANG=19,
    LT_ALTERNATE_MEDIA=20,
    LT_ALTERNATE_STYLESHEET=21,
    LT_STYLESHEET=22
} hlink_type;

typedef enum hlink_direction {
    LD_UNKNOWN=0,
    LD_REV=1,
    LD_REL=2
} hlink_direction;

struct hlink {
    enum hlink_type type;
    enum hlink_direction direction;
    uchar * content_type;
    uchar * media;
    uchar * href;
    uchar * hreflang;
    uchar * title;
    uchar * lang;
    uchar * name;
};

typedef struct lt_default_name lt_default_name, *Plt_default_name;

struct lt_default_name {
    enum hlink_type type;
    uchar * str;
};

typedef struct delayed_open delayed_open, *Pdelayed_open;

struct delayed_open {
    struct session * ses;
    struct uri * uri;
    uchar * target;
};

typedef struct frame frame, *Pframe;

struct frame {
    struct frame * next;
    struct frame * prev;
    uchar * name;
    int redirect_cnt;
    struct view_state vs;
};

typedef enum remote_session_flags {
    SES_REMOTE_NEW_TAB=1,
    SES_REMOTE_NEW_WINDOW=2,
    SES_REMOTE_CURRENT_TAB=4,
    SES_REMOTE_PROMPT_URL=8,
    SES_REMOTE_PING=16,
    SES_REMOTE_ADD_BOOKMARK=32,
    SES_REMOTE_INFO_BOX=64
} remote_session_flags;

typedef struct sigaction sigaction, *Psigaction;

typedef union anon_union_4_2_5ad2d23e_for___sigaction_handler anon_union_4_2_5ad2d23e_for___sigaction_handler, *Panon_union_4_2_5ad2d23e_for___sigaction_handler;

typedef struct __sigset_t __sigset_t, *P__sigset_t;

struct __sigset_t {
    ulong __val[32];
};

union anon_union_4_2_5ad2d23e_for___sigaction_handler {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

struct sigaction {
    union anon_union_4_2_5ad2d23e_for___sigaction_handler __sigaction_handler;
    struct __sigset_t sa_mask;
    int sa_flags;
    void (* sa_restorer)(void);
};

typedef struct anon_struct_8_2_38bb682c anon_struct_8_2_38bb682c, *Panon_struct_8_2_38bb682c;


// WARNING! conflicting data type names: /DWARF/cmdline.c/remote_cmd/anon_struct_8_2_38bb682c/anon_enum_32 - /DWARF/session.h/anon_enum_32

struct anon_struct_8_2_38bb682c {
    uchar * name;
    enum anon_enum_32 type;
};

typedef union YYSTYPE YYSTYPE, *PYYSTYPE;

typedef enum operator {
    var=0,
    num=1,
    lnot=2,
    mult=3,
    divide=4,
    module=5,
    plus=6,
    minus=7,
    less_than=8,
    greater_than=9,
    less_or_equal=10,
    greater_or_equal=11,
    equal=12,
    not_equal=13,
    land=14,
    lor=15,
    qmop=16
} operator;

typedef struct expression expression, *Pexpression;

typedef union anon_union_12_2_61c3a44c_for_val anon_union_12_2_61c3a44c_for_val, *Panon_union_12_2_61c3a44c_for_val;

union YYSTYPE {
    ulong num;
    enum operator op;
    struct expression * exp;
};

union anon_union_12_2_61c3a44c_for_val {
    ulong num;
    struct expression * args[3];
};

struct expression {
    int nargs;
    enum operator operation;
    union anon_union_12_2_61c3a44c_for_val val;
    undefined field3_0xc;
    undefined field4_0xd;
    undefined field5_0xe;
    undefined field6_0xf;
    undefined field7_0x10;
    undefined field8_0x11;
    undefined field9_0x12;
    undefined field10_0x13;
};

typedef struct file_to_load file_to_load, *Pfile_to_load;

struct file_to_load {
    struct file_to_load * next;
    struct file_to_load * prev;
    struct session * ses;
    uint req_sent:1;
    int pri;
    struct cache_entry * cached;
    uchar * target_frame;
    struct uri * uri;
    struct download download;
};

typedef struct session_info session_info, *Psession_info;

struct session_info {
    struct session_info * next;
    struct session_info * prev;
    int id;
    timer_id_T timer;
    struct session * ses;
    struct uri * uri;
    struct uri * referrer;
    enum task_type task;
    enum cache_mode cache_mode;
};

typedef struct questions_entry questions_entry, *Pquestions_entry;

struct questions_entry {
    struct questions_entry * next;
    struct questions_entry * prev;
    void (* callback)(struct session *, void *);
    void * data;
};

typedef struct string_list_item string_list_item, *Pstring_list_item;

struct string_list_item {
    struct string_list_item * next;
    struct string_list_item * prev;
    struct string string;
};

typedef struct table_elinks table_elinks, *Ptable_elinks;

typedef struct table_cell table_cell, *Ptable_cell;

typedef struct table_column table_column, *Ptable_column;

typedef struct html_start_end html_start_end, *Phtml_start_end;

struct html_start_end {
    uchar * start;
    uchar * end;
};

struct table_column {
    int group;
    int align;
    int valign;
    int width;
};

struct table_elinks {
    struct part * part;
    struct table_cell * cells;
    uchar * fragment_id;
    color_T bgcolor;
    color_T bordercolor;
    int align;
    struct table_column * columns;
    int columns_count;
    int real_columns_count;
    int * min_cols_widths;
    int * max_cols_widths;
    int * cols_widths;
    int * cols_x;
    int cols_x_count;
    int * rows_heights;
    int cols;
    int rows;
    int real_cols;
    int real_rows;
    int border;
    int cellpadding;
    int vcellpadding;
    int cellspacing;
    int frame;
    int rules;
    int width;
    int real_width;
    int real_height;
    int min_width;
    int max_width;
    int link_num;
    uint full_width:1;
    struct html_start_end caption;
    int caption_height;
    struct html_start_end * bad_html;
    int bad_html_size;
};

struct table_cell {
    uchar * start;
    uchar * end;
    uchar * fragment_id;
    color_T bgcolor;
    int col;
    int row;
    int align;
    int valign;
    int colspan;
    int rowspan;
    int min_width;
    int max_width;
    int width;
    int height;
    int link_num;
    uint is_used:1;
    uint is_spanned:1;
    uint is_header:1;
    uint is_group:1;
};

typedef struct script_event_hook script_event_hook, *Pscript_event_hook;

typedef enum script_event_hook_type {
    SEVHOOK_ONCLICK=0,
    SEVHOOK_ONDBLCLICK=1,
    SEVHOOK_ONMOUSEOVER=2,
    SEVHOOK_ONHOVER=3,
    SEVHOOK_ONFOCUS=4,
    SEVHOOK_ONMOUSEOUT=5,
    SEVHOOK_ONBLUR=6
} script_event_hook_type;

struct script_event_hook {
    struct script_event_hook * next;
    struct script_event_hook * prev;
    enum script_event_hook_type type;
    uchar * src;
};

typedef struct node node, *Pnode;

struct node {
    struct node * next;
    struct node * prev;
    struct box box;
};

typedef struct mime_backend mime_backend, *Pmime_backend;

struct mime_backend {
    uchar * (* get_content_type)(uchar *);
    mime_handler * (* get_mime_handler)(uchar *, int);
};

typedef struct bookmarks_backend bookmarks_backend, *Pbookmarks_backend;

struct bookmarks_backend {
    uchar * (* filename)(int);
    void (* read)(FILE *);
    void (* write)(struct secure_save_info *, struct list_head_elinks *);
};

typedef struct ifaddrs ifaddrs, *Pifaddrs;

typedef union anon_union_4_2_2dfc25a4_for_ifa_ifu anon_union_4_2_2dfc25a4_for_ifa_ifu, *Panon_union_4_2_2dfc25a4_for_ifa_ifu;

union anon_union_4_2_2dfc25a4_for_ifa_ifu {
    struct sockaddr * ifu_broadaddr;
    struct sockaddr * ifu_dstaddr;
};

struct ifaddrs {
    struct ifaddrs * ifa_next;
    char * ifa_name;
    uint ifa_flags;
    struct sockaddr * ifa_addr;
    struct sockaddr * ifa_netmask;
    union anon_union_4_2_2dfc25a4_for_ifa_ifu ifa_ifu;
    void * ifa_data;
};

typedef struct dom_config_info dom_config_info, *Pdom_config_info;

typedef enum dom_config_flag {
    DOM_CONFIG_CDATA_SECTIONS=1,
    DOM_CONFIG_COMMENTS=2,
    DOM_CONFIG_ELEMENT_CONTENT_WHITESPACE=4,
    DOM_CONFIG_ENTITIES=8,
    DOM_CONFIG_NORMALIZE_CHARACTERS=16,
    DOM_CONFIG_UNKNOWN=32,
    DOM_CONFIG_NORMALIZE_WHITESPACE=64
} dom_config_flag;

struct dom_config_info {
    struct dom_string name;
    enum dom_config_flag flag;
};

typedef struct link_def link_def, *Plink_def;

struct link_def {
    uchar * link;
    uchar * target;
};

typedef __rlim64_t rlim_t;

typedef struct rlimit rlimit, *Prlimit;

struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};


// WARNING! conflicting data type names: /DWARF/resource.h/__rlimit_resource - /resource.h/__rlimit_resource

typedef enum do_move {
    DO_MOVE_ABORT=0,
    DO_MOVE_DISPLAY=1,
    DO_MOVE_DONE=2
} do_move;

typedef struct task task, *Ptask;

struct task {
    struct session * ses;
    struct uri * uri;
    enum cache_mode cache_mode;
    struct session_task session_task;
};

typedef struct deflate_enc_data deflate_enc_data, *Pdeflate_enc_data;

typedef struct z_stream_s z_stream_s, *Pz_stream_s;

typedef struct z_stream_s z_stream;

typedef Byte Bytef;

typedef struct internal_state internal_state, *Pinternal_state;

typedef void * voidpf;

typedef voidpf (* alloc_func)(voidpf, uInt, uInt);

typedef void (* free_func)(voidpf, voidpf);

struct z_stream_s {
    Bytef * next_in;
    uInt avail_in;
    uLong total_in;
    Bytef * next_out;
    uInt avail_out;
    uLong total_out;
    char * msg;
    struct internal_state * state;
    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;
    int data_type;
    uLong adler;
    uLong reserved;
};

struct deflate_enc_data {
    z_stream deflate_stream;
    int fdread;
    uint last_read:1;
    uint after_first_read:1;
    uchar buf[5000];
};

struct internal_state {
    int dummy;
};

typedef struct interlink_event interlink_event, *Pinterlink_event;


// WARNING! conflicting data type names: /DWARF/event.h/interlink_event/anon_union_12_3_3ebaaa1f_for_info - /DWARF/event.h/term_event/anon_union_12_3_3ebaaa1f_for_info

struct interlink_event {
    enum term_event_type ev;
    union anon_union_12_3_3ebaaa1f_for_info info;
};

typedef struct known_translation_t known_translation_t, *Pknown_translation_t;

typedef struct loaded_l10nfile loaded_l10nfile, *Ploaded_l10nfile;

struct known_translation_t {
    uchar * domainname;
    int category;
    int counter;
    struct loaded_l10nfile * domain;
    uchar * translation;
    size_t translation_length;
    uchar msgid[1];
};

struct loaded_l10nfile {
    uchar * filename;
    uchar * langdirname;
    int langdirnamelen;
    int decided;
    void * data;
    struct loaded_l10nfile * next;
    struct loaded_l10nfile * successor[1];
};

typedef struct html_element html_element, *Phtml_element;

struct html_element {
    struct html_element * next;
    struct html_element * prev;
    enum html_element_mortality_type type;
    struct text_attrib attr;
    struct par_attrib parattr;
    int invisible;
    uchar * name;
    int namelen;
    uchar * options;
    int linebreak;
    struct frameset_desc * frameset;
    enum html_element_pseudo_class pseudo_class;
};

typedef struct html_context html_context, *Phtml_context;

typedef enum html_special_type {
} html_special_type;

struct html_context {
    struct css_stylesheet css_styles;
    struct uri * base_href;
    uchar * base_target;
    struct document_options * options;
    int doc_cp;
    struct list_head_elinks stack;
    uchar * eoff;
    int line_breax;
    int position;
    enum html_whitespace_state putsp;
    int was_li;
    uint quote_level;
    uint was_br:1;
    uint was_xmp:1;
    uint was_style:1;
    uint has_link_lines:1;
    uint was_body:1;
    uint was_body_background:1;
    int margin;
    uchar * startf;
    int table_level;
    struct part * part;
    void (* put_chars_f)(struct html_context *, uchar *, int);
    void (* line_break_f)(struct html_context *);
    void * (* special_f)(struct html_context *, enum html_special_type, ...);
};

typedef enum html_attr_flags {
    HTML_ATTR_NONE=0,
    HTML_ATTR_TEST=1,
    HTML_ATTR_EAT_NL=2,
    HTML_ATTR_LITERAL_NL=8
} html_attr_flags;

typedef struct ftp_file_info ftp_file_info, *Pftp_file_info;

typedef enum ftp_file_type {
    FTP_FILE_PLAINFILE=45,
    FTP_FILE_UNKNOWN=63,
    FTP_FILE_DIRECTORY=100,
    FTP_FILE_SYMLINK=108
} ftp_file_type;

struct ftp_file_info {
    enum ftp_file_type type;
    struct string name;
    struct string symlink;
    off_t size;
    time_t mtime;
    uint local_time_zone:1;
    mode_t permissions;
};


// WARNING! conflicting data type names: /DWARF/stdio.h/_IO_FILE - /stdio.h/_IO_FILE

typedef struct element_info element_info, *Pelement_info;

typedef enum element_type {
    ET_NESTABLE=0,
    ET_NON_NESTABLE=1,
    ET_NON_PAIRABLE=2,
    ET_LI=3
} element_type;

struct element_info {
    uchar * name;
    void (* open)(struct html_context *, uchar *, uchar *, uchar *, uchar * *);
    void (* close)(struct html_context *, uchar *, uchar *, uchar *, uchar * *);
    int linebreak;
    enum element_type type;
};

typedef enum ftp_unix {
    FTP_UNIX_PERMISSIONS=0,
    FTP_UNIX_SIZE=1,
    FTP_UNIX_DAY=2,
    FTP_UNIX_TIME=3,
    FTP_UNIX_NAME=4
} ftp_unix;

typedef enum ftp_eplf {
    FTP_EPLF_FILENAME=9,
    FTP_EPLF_DIRECTORY=47,
    FTP_EPLF_ID=105,
    FTP_EPLF_MTIME=109,
    FTP_EPLF_PLAINFILE=114,
    FTP_EPLF_SIZE=115
} ftp_eplf;

typedef void (* dns_callback_T)(void *, struct sockaddr_storage *, int);

typedef enum dns_result {
    DNS_ERROR=-1,
    DNS_SUCCESS=0,
    DNS_ASYNC=1
} dns_result;

typedef struct dom_config dom_config, *Pdom_config;

typedef struct dom_error dom_error, *Pdom_error;

struct dom_error {
};

struct dom_config {
    enum dom_config_flag flags;
    void (* error_handler)(struct dom_config *, struct dom_error *);
};

typedef void (* css_applier_T)(struct html_context *, struct html_element *, struct css_property *);

typedef struct bfu_color_entry bfu_color_entry, *Pbfu_color_entry;

struct bfu_color_entry {
    color_T * background;
    color_T * foreground;
    struct color_pair colors;
};

typedef enum uri_rewrite_type {
    URI_REWRITE_DUMB=0,
    URI_REWRITE_SMART=1
} uri_rewrite_type;

typedef enum uri_rewrite_option {
    URI_REWRITE_TREE=0,
    URI_REWRITE_ENABLE_DUMB=1,
    URI_REWRITE_ENABLE_SMART=2,
    URI_REWRITE_DUMB_TREE=3,
    URI_REWRITE_DUMB_TEMPLATE=4,
    URI_REWRITE_SMART_TREE=5,
    URI_REWRITE_SMART_TEMPLATE=6,
    URI_REWRITE_OPTIONS=7
} uri_rewrite_option;

typedef struct search_dlg_hop search_dlg_hop, *Psearch_dlg_hop;

struct search_dlg_hop {
    void * data;
    union option_value values[1];
};

typedef enum typeahead_code {
    TYPEAHEAD_MATCHED=0,
    TYPEAHEAD_ERROR=1,
    TYPEAHEAD_ERROR_NO_FURTHER=2,
    TYPEAHEAD_CANCEL=3
} typeahead_code;

typedef enum search_option {
    SEARCH_OPT_CASE=0,
    SEARCH_OPTIONS=1
} search_option;

typedef enum find_error {
    FIND_ERROR_NONE=0,
    FIND_ERROR_NO_PREVIOUS_SEARCH=1,
    FIND_ERROR_HIT_TOP=2,
    FIND_ERROR_HIT_BOTTOM=3,
    FIND_ERROR_NOT_FOUND=4,
    FIND_ERROR_MEMORY=5,
    FIND_ERROR_REGEX=6
} find_error;

typedef struct dnsquery dnsquery, *Pdnsquery;

struct dnsquery {
    dns_callback_T done;
    void * data;
    struct sockaddr_storage * addr;
    int addrno;
    struct dnsquery * * queryref;
    int h;
    uchar name[1];
};

typedef struct dnsentry dnsentry, *Pdnsentry;

struct dnsentry {
    struct dnsentry * next;
    struct dnsentry * prev;
    struct sockaddr_storage * addr;
    int addrno;
    struct timeval_T creation_time;
    uchar name[1];
};

typedef struct alias_map alias_map, *Palias_map;

struct alias_map {
    uchar * alias;
    uchar * value;
};

typedef struct dom_node_search dom_node_search, *Pdom_node_search;

struct dom_node_search {
    struct dom_node * key;
    uint from;
    uint pos;
    uint to;
};

typedef struct fastfind_key_value fastfind_key_value, *Pfastfind_key_value;

struct fastfind_key_value {
    uchar * key;
    void * data;
};

typedef enum fastfind_flags {
    FF_NONE=0,
    FF_CASE_AWARE=1,
    FF_COMPRESS=2,
    FF_LOCALE_INDEP=4
} fastfind_flags;

typedef struct fastfind_index fastfind_index, *Pfastfind_index;

struct fastfind_index {
    uchar * comment;
    void (* reset)(void);
    fastfind_key_value * (* next)(void);
    void * handle;
};

typedef enum dom_node_type {
    DOM_NODE_UNKNOWN=0,
    DOM_NODE_ELEMENT=1,
    DOM_NODE_ATTRIBUTE=2,
    DOM_NODE_TEXT=3,
    DOM_NODE_CDATA_SECTION=4,
    DOM_NODE_ENTITY_REFERENCE=5,
    DOM_NODE_ENTITY=6,
    DOM_NODE_PROCESSING_INSTRUCTION=7,
    DOM_NODE_COMMENT=8,
    DOM_NODE_DOCUMENT=9,
    DOM_NODE_DOCUMENT_TYPE=10,
    DOM_NODE_DOCUMENT_FRAGMENT=11,
    DOM_NODE_NOTATION=12,
    DOM_NODES=13
} dom_node_type;

typedef enum dom_proc_instruction_type {
    DOM_PROC_INSTRUCTION=0,
    DOM_PROC_INSTRUCTION_XML=1,
    DOM_PROC_INSTRUCTION_XML_STYLESHEET=2,
    DOM_PROC_INSTRUCTION_TYPES=3
} dom_proc_instruction_type;

typedef struct fastfind_info fastfind_info, *Pfastfind_info;

typedef struct ff_data ff_data, *Pff_data;

typedef struct ff_node_c ff_node_c, *Pff_node_c;

struct ff_node_c {
    uint e:1;
    uint c:1;
    uint p:10;
    uint l:13;
    uint ch:7;
};

struct fastfind_info {
    struct ff_data * data;
    struct ff_node_c * * leafsets;
    struct ff_node_c * root_leafset;
    int min_key_len;
    int max_key_len;
    int uniq_chars_count;
    int count;
    int pointers_count;
    int leafsets_count;
    uint case_aware:1;
    uint locale_indep:1;
    uint compress:1;
    int idxtab[128];
    uchar uniq_chars[128];
};

struct ff_data {
    void * pointer;
    int keylen;
};

typedef struct write_bookmarks_default write_bookmarks_default, *Pwrite_bookmarks_default;

struct write_bookmarks_default {
    struct secure_save_info * ssi;
    int save_folder_state;
    int codepage;
    struct conv_table * conv_table;
};


// WARNING! conflicting data type names: /DWARF/utsname.h/utsname - /utsname.h/utsname

typedef struct stat stat, *Pstat;

struct stat {
    __dev_t st_dev;
    ushort __pad1;
    __ino_t __st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    ushort __pad2;
    __off64_t st_size;
    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __ino64_t st_ino;
};

typedef struct bz2_enc_data bz2_enc_data, *Pbz2_enc_data;

typedef struct bz_stream bz_stream, *Pbz_stream;

struct bz_stream {
    char * next_in;
    uint avail_in;
    uint total_in_lo32;
    uint total_in_hi32;
    char * next_out;
    uint avail_out;
    uint total_out_lo32;
    uint total_out_hi32;
    void * state;
    void * (* bzalloc)(void *, int, int);
    void (* bzfree)(void *, void *);
    void * opaque;
};

struct bz2_enc_data {
    struct bz_stream fbz_stream;
    int fdread;
    int last_read;
    uchar buf[5000];
};

typedef enum edit_dialog_type {
    EDIT_DLG_SEARCH=0,
    EDIT_DLG_ADD=1
} edit_dialog_type;

typedef struct winsize winsize, *Pwinsize;

struct winsize {
    ushort ws_row;
    ushort ws_col;
    ushort ws_xpixel;
    ushort ws_ypixel;
};

typedef enum msgbox_flags {
    MSGBOX_FREE_TEXT=1,
    MSGBOX_NO_INTL=2,
    MSGBOX_SCROLLABLE=4,
    MSGBOX_NO_TEXT_INTL=8
} msgbox_flags;

typedef struct auth_entry auth_entry, *Pauth_entry;

struct auth_entry {
    struct auth_entry * next;
    struct auth_entry * prev;
    struct object object;
    struct uri * uri;
    uchar * realm;
    uchar * nonce;
    uchar * opaque;
    struct listbox_item * box_item;
    uchar user[40];
    uchar password[40];
    uint blocked:1;
    uint valid:1;
    uint digest:1;
};


// WARNING! conflicting data type names: /DWARF/_UNCATEGORIZED_/__dirstream - /dirent.h/__dirstream

typedef struct gss_cred_id_desc_struct gss_cred_id_desc_struct, *Pgss_cred_id_desc_struct;

struct gss_cred_id_desc_struct {
};

typedef struct dump_output dump_output, *Pdump_output;

struct dump_output {
    size_t bufpos;
    struct string * string;
    int fd;
    uchar buf[65536];
};

typedef enum rss_attribute_type {
    RSS_ATTRIBUTE_UNKNOWN=0,
    RSS_ATTRIBUTE_ISPERMALINK=1,
    RSS_ATTRIBUTES=2
} rss_attribute_type;

typedef enum rss_element_type {
    RSS_ELEMENT_UNKNOWN=0,
    RSS_ELEMENT_AUTHOR=1,
    RSS_ELEMENT_CHANNEL=2,
    RSS_ELEMENT_DESCRIPTION=3,
    RSS_ELEMENT_GUID=4,
    RSS_ELEMENT_ITEM=5,
    RSS_ELEMENT_LINK=6,
    RSS_ELEMENT_PUBDATE=7,
    RSS_ELEMENT_TITLE=8,
    RSS_ELEMENTS=9
} rss_element_type;

typedef enum cookies_accept {
    COOKIES_ACCEPT_NONE=0,
    COOKIES_ACCEPT_ASK=1,
    COOKIES_ACCEPT_ALL=2
} cookies_accept;

typedef struct cookie cookie, *Pcookie;

typedef struct cookie_server cookie_server, *Pcookie_server;

struct cookie_server {
    struct cookie_server * next;
    struct cookie_server * prev;
    struct object object;
    struct listbox_item * box_item;
    uchar host[1];
};

struct cookie {
    struct cookie * next;
    struct cookie * prev;
    struct object object;
    uchar * name;
    uchar * value;
    uchar * path;
    uchar * domain;
    struct cookie_server * server;
    time_t expires;
    int secure;
    struct listbox_item * box_item;
};

typedef struct anon_struct_8_2_947311e0 anon_struct_8_2_947311e0, *Panon_struct_8_2_947311e0;

struct anon_struct_8_2_947311e0 {
    unicode_val_T x;
    uchar * s;
};

typedef enum led_option {
    LEDS_CLOCK_TREE=0,
    LEDS_CLOCK_ENABLE=1,
    LEDS_CLOCK_FORMAT=2,
    LEDS_CLOCK_ALIAS=3,
    LEDS_PANEL_TREE=4,
    LEDS_PANEL_ENABLE=5,
    LEDS_OPTIONS=6
} led_option;

typedef struct table_frames table_frames, *Ptable_frames;

struct table_frames {
    uint top:1;
    uint bottom:1;
    uint left:1;
    uint right:1;
};

typedef enum cookies_option {
    COOKIES_TREE=0,
    COOKIES_ACCEPT_POLICY=1,
    COOKIES_MAX_AGE=2,
    COOKIES_PARANOID_SECURITY=3,
    COOKIES_SAVE=4,
    COOKIES_RESAVE=5,
    COOKIES_OPTIONS=6
} cookies_option;

typedef struct c_domain c_domain, *Pc_domain;

struct c_domain {
    struct c_domain * next;
    struct c_domain * prev;
    uchar domain[1];
};

typedef struct anon_struct_8_2_43e60426 anon_struct_8_2_43e60426, *Panon_struct_8_2_43e60426;

struct anon_struct_8_2_43e60426 {
    uchar * pos;
    int len;
};


// WARNING! conflicting data type names: /DWARF/cookies.c/load_cookies/lexical_block_0/anon_enum_32 - /DWARF/session.h/anon_enum_32

typedef union yyalloc yyalloc, *Pyyalloc;

union yyalloc {
    short yyss;
    union YYSTYPE yyvs;
};

typedef struct anon_struct_8_2_947310aa anon_struct_8_2_947310aa, *Panon_struct_8_2_947310aa;

struct anon_struct_8_2_947310aa {
    int n;
    uchar * s;
};

typedef enum gnutls_certificate_verify_flags {
    GNUTLS_VERIFY_DISABLE_CA_SIGN=1,
    GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT=2,
    GNUTLS_VERIFY_DO_NOT_ALLOW_SAME=4,
    GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT=8,
    GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2=16,
    GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5=32,
    GNUTLS_VERIFY_DISABLE_TIME_CHECKS=64
} gnutls_certificate_verify_flags;


// WARNING! conflicting data type names: /DWARF/netdb.h/addrinfo - /netdb.h/addrinfo

typedef struct entity_cache entity_cache, *Pentity_cache;

struct entity_cache {
    uint hits;
    int strlen;
    int encoding;
    uchar * result;
    uchar str[20];
};

typedef struct codepage_desc codepage_desc, *Pcodepage_desc;

typedef struct table_entry table_entry, *Ptable_entry;

struct table_entry {
    uchar c;
    uint16_t u;
};

struct codepage_desc {
    uchar * name;
    uchar * * aliases;
    uint16_t * highhalf;
    struct table_entry * table_elinks;
};

typedef struct md5_context md5_context, *Pmd5_context;

struct md5_context {
    uint32_t buf[4];
    uint32_t bits[2];
    uchar in[64];
};

typedef uchar md5_digest_bin_T[16];

typedef struct md5_context MD5_CTX;

typedef uchar md5_digest_hex_T[32];

typedef struct mo_file_header mo_file_header, *Pmo_file_header;

struct mo_file_header {
    nls_uint32 magic;
    nls_uint32 revision;
    nls_uint32 nstrings;
    nls_uint32 orig_tab_offset;
    nls_uint32 trans_tab_offset;
    nls_uint32 hash_tab_size;
    nls_uint32 hash_tab_offset;
};

typedef struct string_desc string_desc, *Pstring_desc;

struct string_desc {
    nls_uint32 length;
    nls_uint32 offset;
};

typedef struct terminal_info terminal_info, *Pterminal_info;

struct terminal_info {
    struct interlink_event event;
    uchar name[32];
    uchar cwd[256];
    int system_env;
    int length;
    int session_info;
    int magic;
    uchar data[1];
};

typedef struct submitted_value submitted_value, *Psubmitted_value;

struct submitted_value {
    struct submitted_value * next;
    struct submitted_value * prev;
    uchar * name;
    uchar * value;
    struct form_control * form_control;
    enum form_type type;
    int position;
};

typedef struct boundary_info boundary_info, *Pboundary_info;

struct boundary_info {
    int count;
    int * offsets;
    uchar string[32];
};

typedef struct in_addr in_addr, *Pin_addr;

typedef uint32_t in_addr_t;

struct in_addr {
    in_addr_t s_addr;
};

typedef uint16_t in_port_t;

typedef struct sockaddr_in sockaddr_in, *Psockaddr_in;

struct sockaddr_in {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;
    uchar sin_zero[8];
};

typedef struct sockaddr_in6 sockaddr_in6, *Psockaddr_in6;

typedef struct in6_addr in6_addr, *Pin6_addr;

typedef union anon_union_16_3_a3f0114d_for___in6_u anon_union_16_3_a3f0114d_for___in6_u, *Panon_union_16_3_a3f0114d_for___in6_u;

union anon_union_16_3_a3f0114d_for___in6_u {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
};

struct in6_addr {
    union anon_union_16_3_a3f0114d_for___in6_u __in6_u;
};

struct sockaddr_in6 {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
};

typedef enum utf8_step {
    UTF8_STEP_CHARACTERS=0,
    UTF8_STEP_CELLS_FEWER=1,
    UTF8_STEP_CELLS_MORE=2
} utf8_step;

typedef enum nbsp_mode {
    NBSP_MODE_HACK=0,
    NBSP_MODE_ASCII=1
} nbsp_mode;

typedef struct host_connection host_connection, *Phost_connection;

struct host_connection {
    struct host_connection * next;
    struct host_connection * prev;
    struct object object;
    struct uri * uri;
};

typedef struct keepalive_connection keepalive_connection, *Pkeepalive_connection;

struct keepalive_connection {
    struct keepalive_connection * next;
    struct keepalive_connection * prev;
    struct uri * uri;
    void (* done)(struct connection *);
    struct timeval_T timeout;
    struct timeval_T creation_time;
    uint protocol_family:1;
    int socket;
};

typedef struct loaded_domain loaded_domain, *Ploaded_domain;

struct loaded_domain {
    uchar * data;
    int use_mmap;
    size_t mmap_size;
    int must_swap;
    nls_uint32 nstrings;
    struct string_desc * orig_tab;
    struct string_desc * trans_tab;
    nls_uint32 hash_size;
    nls_uint32 * hash_tab;
    int codeset_cntr;
    iconv_t conv;
    uchar * * conv_tab;
    struct expression * plural;
    ulong nplurals;
};

typedef struct binding binding, *Pbinding;

struct binding {
    struct binding * next;
    uchar * dirname;
    int codeset_cntr;
    uchar * codeset;
    uchar domainname[1];
};

typedef struct parse_args parse_args, *Pparse_args;

struct parse_args {
    uchar * cp;
    struct expression * res;
};

typedef struct lun_hop lun_hop, *Plun_hop;

struct lun_hop {
    struct terminal * term;
    uchar * ofile;
    uchar * file;
    void (* callback)(struct terminal *, uchar *, void *, int);
    void * data;
};

typedef struct anon_struct_8_2_24c50097 anon_struct_8_2_24c50097, *Panon_struct_8_2_24c50097;

struct anon_struct_8_2_24c50097 {
    uchar * type;
    uint plain:1;
};

typedef struct codw_hop codw_hop, *Pcodw_hop;

struct codw_hop {
    int magic;
    struct type_query * type_query;
    uchar * real_file;
    uchar * file;
};

typedef struct cdf_hop cdf_hop, *Pcdf_hop;

struct cdf_hop {
    uchar * * real_file;
    int safe;
    void (* callback)(struct terminal *, int, void *, int);
    void * data;
};

typedef struct cmdw_hop cmdw_hop, *Pcmdw_hop;

struct cmdw_hop {
    int magic;
    struct session * ses;
    uchar * real_file;
};

typedef enum frame_event_status {
    FRAME_EVENT_IGNORED=0,
    FRAME_EVENT_REFRESH=1,
    FRAME_EVENT_OK=2,
    FRAME_EVENT_SESSION_DESTROYED=3
} frame_event_status;

typedef struct signal_info signal_info, *Psignal_info;

struct signal_info {
    void (* handler)(void *);
    void * data;
    int critical;
    int mask;
};

typedef struct event event, *Pevent;

typedef struct event_handler event_handler, *Pevent_handler;

struct event_handler {
    event_hook_T callback;
    int priority;
    void * data;
};

struct event {
    uchar * name;
    struct event_handler * handlers;
    uint count;
    int id;
};

typedef struct form_type_name form_type_name, *Pform_type_name;

struct form_type_name {
    enum form_type num;
    uchar * name;
};


// WARNING! conflicting data type names: /stdarg.h/__gnuc_va_list - /DWARF/stdarg.h/__gnuc_va_list


// WARNING! conflicting data type names: /time.h/timeval - /DWARF/time.h/timeval

typedef struct timezone timezone, *Ptimezone;

typedef struct timezone * __timezone_ptr_t;

struct timezone {
    int tz_minuteswest;
    int tz_dsttime;
};


// WARNING! conflicting data type names: /time.h/time_t - /DWARF/time.h/time_t


// WARNING! conflicting data type names: /sigaction.h/sigaction - /DWARF/sigaction.h/sigaction

typedef union _union_1051 _union_1051, *P_union_1051;


// WARNING! conflicting data type names: /signal.h/__sighandler_t - /DWARF/signal.h/__sighandler_t

union _union_1051 {
    __sighandler_t sa_handler;
    void (* sa_sigaction)(int, siginfo_t *, void *);
};

typedef uint wint_t;


// WARNING! conflicting data type names: /select.h/__fd_mask - /DWARF/__fd_mask

typedef struct __sigset_t sigset_t;


// WARNING! conflicting data type names: /select.h/fd_set - /DWARF/select.h/fd_set

typedef int (* __compar_fn_t)(void *, void *);

typedef struct Elf32_Shdr Elf32_Shdr, *PElf32_Shdr;

typedef enum Elf_SectionHeaderType_x86 {
    SHT_NULL=0,
    SHT_PROGBITS=1,
    SHT_SYMTAB=2,
    SHT_STRTAB=3,
    SHT_RELA=4,
    SHT_HASH=5,
    SHT_DYNAMIC=6,
    SHT_NOTE=7,
    SHT_NOBITS=8,
    SHT_REL=9,
    SHT_SHLIB=10,
    SHT_DYNSYM=11,
    SHT_INIT_ARRAY=14,
    SHT_FINI_ARRAY=15,
    SHT_PREINIT_ARRAY=16,
    SHT_GROUP=17,
    SHT_SYMTAB_SHNDX=18,
    SHT_ANDROID_REL=1610612737,
    SHT_ANDROID_RELA=1610612738,
    SHT_GNU_ATTRIBUTES=1879048181,
    SHT_GNU_HASH=1879048182,
    SHT_GNU_LIBLIST=1879048183,
    SHT_CHECKSUM=1879048184,
    SHT_SUNW_move=1879048186,
    SHT_SUNW_COMDAT=1879048187,
    SHT_SUNW_syminfo=1879048188,
    SHT_GNU_verdef=1879048189,
    SHT_GNU_verneed=1879048190,
    SHT_GNU_versym=1879048191
} Elf_SectionHeaderType_x86;

struct Elf32_Shdr {
    dword sh_name;
    enum Elf_SectionHeaderType_x86 sh_type;
    dword sh_flags;
    dword sh_addr;
    dword sh_offset;
    dword sh_size;
    dword sh_link;
    dword sh_info;
    dword sh_addralign;
    dword sh_entsize;
};

typedef struct Elf32_Dyn_x86 Elf32_Dyn_x86, *PElf32_Dyn_x86;

typedef enum Elf32_DynTag_x86 {
    DT_NULL=0,
    DT_NEEDED=1,
    DT_PLTRELSZ=2,
    DT_PLTGOT=3,
    DT_HASH=4,
    DT_STRTAB=5,
    DT_SYMTAB=6,
    DT_RELA=7,
    DT_RELASZ=8,
    DT_RELAENT=9,
    DT_STRSZ=10,
    DT_SYMENT=11,
    DT_INIT=12,
    DT_FINI=13,
    DT_SONAME=14,
    DT_RPATH=15,
    DT_SYMBOLIC=16,
    DT_REL=17,
    DT_RELSZ=18,
    DT_RELENT=19,
    DT_PLTREL=20,
    DT_DEBUG=21,
    DT_TEXTREL=22,
    DT_JMPREL=23,
    DT_BIND_NOW=24,
    DT_INIT_ARRAY=25,
    DT_FINI_ARRAY=26,
    DT_INIT_ARRAYSZ=27,
    DT_FINI_ARRAYSZ=28,
    DT_RUNPATH=29,
    DT_FLAGS=30,
    DT_PREINIT_ARRAY=32,
    DT_PREINIT_ARRAYSZ=33,
    DT_RELRSZ=35,
    DT_RELR=36,
    DT_RELRENT=37,
    DT_ANDROID_REL=1610612751,
    DT_ANDROID_RELSZ=1610612752,
    DT_ANDROID_RELA=1610612753,
    DT_ANDROID_RELASZ=1610612754,
    DT_ANDROID_RELR=1879040000,
    DT_ANDROID_RELRSZ=1879040001,
    DT_ANDROID_RELRENT=1879040003,
    DT_GNU_PRELINKED=1879047669,
    DT_GNU_CONFLICTSZ=1879047670,
    DT_GNU_LIBLISTSZ=1879047671,
    DT_CHECKSUM=1879047672,
    DT_PLTPADSZ=1879047673,
    DT_MOVEENT=1879047674,
    DT_MOVESZ=1879047675,
    DT_FEATURE_1=1879047676,
    DT_POSFLAG_1=1879047677,
    DT_SYMINSZ=1879047678,
    DT_SYMINENT=1879047679,
    DT_GNU_XHASH=1879047924,
    DT_GNU_HASH=1879047925,
    DT_TLSDESC_PLT=1879047926,
    DT_TLSDESC_GOT=1879047927,
    DT_GNU_CONFLICT=1879047928,
    DT_GNU_LIBLIST=1879047929,
    DT_CONFIG=1879047930,
    DT_DEPAUDIT=1879047931,
    DT_AUDIT=1879047932,
    DT_PLTPAD=1879047933,
    DT_MOVETAB=1879047934,
    DT_SYMINFO=1879047935,
    DT_VERSYM=1879048176,
    DT_RELACOUNT=1879048185,
    DT_RELCOUNT=1879048186,
    DT_FLAGS_1=1879048187,
    DT_VERDEF=1879048188,
    DT_VERDEFNUM=1879048189,
    DT_VERNEED=1879048190,
    DT_VERNEEDNUM=1879048191,
    DT_AUXILIARY=2147483645,
    DT_FILTER=2147483647
} Elf32_DynTag_x86;

struct Elf32_Dyn_x86 {
    enum Elf32_DynTag_x86 d_tag;
    dword d_val;
};

typedef struct Elf32_Sym Elf32_Sym, *PElf32_Sym;

struct Elf32_Sym {
    dword st_name;
    dword st_value;
    dword st_size;
    byte st_info;
    byte st_other;
    word st_shndx;
};

typedef struct Elf32_Phdr Elf32_Phdr, *PElf32_Phdr;

typedef enum Elf_ProgramHeaderType_x86 {
    PT_NULL=0,
    PT_LOAD=1,
    PT_DYNAMIC=2,
    PT_INTERP=3,
    PT_NOTE=4,
    PT_SHLIB=5,
    PT_PHDR=6,
    PT_TLS=7,
    PT_GNU_EH_FRAME=1685382480,
    PT_GNU_STACK=1685382481,
    PT_GNU_RELRO=1685382482
} Elf_ProgramHeaderType_x86;

struct Elf32_Phdr {
    enum Elf_ProgramHeaderType_x86 p_type;
    dword p_offset;
    dword p_vaddr;
    dword p_paddr;
    dword p_filesz;
    dword p_memsz;
    dword p_flags;
    dword p_align;
};

typedef struct NoteAbiTag NoteAbiTag, *PNoteAbiTag;

struct NoteAbiTag {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    dword abiType; // 0 == Linux
    dword requiredKernelVersion[3]; // Major.minor.patch
};

typedef struct Elf32_Rel Elf32_Rel, *PElf32_Rel;

struct Elf32_Rel {
    dword r_offset; // location to apply the relocation action
    dword r_info; // the symbol table index and the type of relocation
};

typedef struct GnuBuildId GnuBuildId, *PGnuBuildId;

struct GnuBuildId {
    dword namesz; // Length of name field
    dword descsz; // Length of description field
    dword type; // Vendor specific type
    char name[4]; // Vendor name
    byte hash[20];
};

typedef struct Elf32_Ehdr Elf32_Ehdr, *PElf32_Ehdr;

struct Elf32_Ehdr {
    byte e_ident_magic_num;
    char e_ident_magic_str[3];
    byte e_ident_class;
    byte e_ident_data;
    byte e_ident_version;
    byte e_ident_osabi;
    byte e_ident_abiversion;
    byte e_ident_pad[7];
    word e_type;
    word e_machine;
    dword e_version;
    dword e_entry;
    dword e_phoff;
    dword e_shoff;
    dword e_flags;
    word e_ehsize;
    word e_phentsize;
    word e_phnum;
    word e_shentsize;
    word e_shnum;
    word e_shstrndx;
};




undefined4 _init(void)

{
  undefined4 uStack_c;
  
  __gmon_start__();
  frame_dummy();
  __do_global_ctors_aux();
  return uStack_c;
}



void FUN_08058bf8(void)

{
                    // WARNING: Treating indirect jump as call
  (*(code *)(undefined *)0x0)();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputs(char *__s,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputs(__s,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void abort(void)

{
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}



void gnutls_mac_get(void)

{
  gnutls_mac_get();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * inet_ntop(int __af,void *__cp,char *__buf,socklen_t __len)

{
  char *pcVar1;
  
  pcVar1 = inet_ntop(__af,__cp,__buf,__len);
  return pcVar1;
}



void gnutls_global_init(void)

{
  gnutls_global_init();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * popen(char *__command,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = popen(__command,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void srand(uint __seed)

{
  srand(__seed);
  return;
}



void __argz_count(void)

{
  __argz_count();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int connect(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = connect(__fd,__addr,__len);
  return iVar1;
}



void rb_define_global_function(void)

{
  rb_define_global_function();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t getpid(void)

{
  __pid_t _Var1;
  
  _Var1 = getpid();
  return _Var1;
}



void gss_release_name(void)

{
  gss_release_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int mkdir(char *__path,__mode_t __mode)

{
  int iVar1;
  
  iVar1 = mkdir(__path,__mode);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getsockname(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getsockname(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long sysconf(int __name)

{
  long lVar1;
  
  lVar1 = sysconf(__name);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int memcmp(void *__s1,void *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = memcmp(__s1,__s2,__n);
  return iVar1;
}



void gnutls_certificate_type_get_name(void)

{
  gnutls_certificate_type_get_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  qsort(__base,__nmemb,__size,__compar);
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void freeaddrinfo(addrinfo *__ai)

{
  freeaddrinfo(__ai);
  return;
}



void gnutls_record_recv(void)

{
  gnutls_record_recv();
  return;
}



void XML_ParserCreate(void)

{
  XML_ParserCreate();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * bsearch(void *__key,void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = bsearch(__key,__base,__nmemb,__size,__compar);
  return pvVar1;
}



void inflateEnd(void)

{
  inflateEnd();
  return;
}



void gss_release_buffer(void)

{
  gss_release_buffer();
  return;
}



void __isoc99_fscanf(void)

{
  __isoc99_fscanf();
  return;
}



void gnutls_record_send(void)

{
  gnutls_record_send();
  return;
}



void gnutls_handshake(void)

{
  gnutls_handshake();
  return;
}



void __fprintf_chk(void)

{
  __fprintf_chk();
  return;
}



void gnutls_protocol_get_name(void)

{
  gnutls_protocol_get_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__sighandler_t signal(int __sig,__sighandler_t __handler)

{
  __sighandler_t p_Var1;
  
  p_Var1 = signal(__sig,__handler);
  return p_Var1;
}



void __gmon_start__(void)

{
  __gmon_start__();
  return;
}



void gnutls_certificate_set_x509_trust_file(void)

{
  gnutls_certificate_set_x509_trust_file();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

iconv_t iconv_open(char *__tocode,char *__fromcode)

{
  iconv_t pvVar1;
  
  pvVar1 = iconv_open(__tocode,__fromcode);
  return pvVar1;
}



void gnutls_compression_get(void)

{
  gnutls_compression_get();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __xstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __xstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * localtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = localtime(__timer);
  return ptVar1;
}



void __argz_stringify(void)

{
  __argz_stringify();
  return;
}



void __printf_chk(void)

{
  __printf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

double strtod(char *__nptr,char **__endptr)

{
  longdouble extraout_ST0;
  
  strtod(__nptr,__endptr);
  return (double)extraout_ST0;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getenv(char *__name)

{
  char *pcVar1;
  
  pcVar1 = getenv(__name);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * calloc(size_t __nmemb,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = calloc(__nmemb,__size);
  return pvVar1;
}



void gnutls_certificate_allocate_credentials(void)

{
  gnutls_certificate_allocate_credentials();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int system(char *__command)

{
  int iVar1;
  
  iVar1 = system(__command);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strncpy(char *__dest,char *__src,size_t __n)

{
  char *pcVar1;
  
  pcVar1 = strncpy(__dest,__src,__n);
  return pcVar1;
}



void gnutls_transport_set_ptr(void)

{
  gnutls_transport_set_ptr();
  return;
}



void ruby_init(void)

{
  ruby_init();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * mremap(void *__addr,size_t __old_len,size_t __new_len,int __flags,...)

{
  void *pvVar1;
  
  pvVar1 = mremap(__addr,__old_len,__new_len,__flags);
  return pvVar1;
}



void gnutls_certificate_set_verify_flags(void)

{
  gnutls_certificate_set_verify_flags();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t write(int __fd,void *__buf,size_t __n)

{
  ssize_t sVar1;
  
  sVar1 = write(__fd,__buf,__n);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int listen(int __fd,int __n)

{
  int iVar1;
  
  iVar1 = listen(__fd,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__off64_t lseek64(int __fd,__off64_t __offset,int __whence)

{
  undefined4 extraout_EAX;
  undefined4 extraout_EDX;
  
  lseek64(__fd,__offset,__whence);
  return CONCAT44(extraout_EDX,extraout_EAX);
}



void XML_GetErrorCode(void)

{
  XML_GetErrorCode();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * fgets(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rename(char *__old,char *__new)

{
  int iVar1;
  
  iVar1 = rename(__old,__new);
  return iVar1;
}



void rb_protect(void)

{
  rb_protect();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memset(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memset(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fopen64(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen64(__filename,__modes);
  return pFVar1;
}



void ruby_init_loadpath(void)

{
  ruby_init_loadpath();
  return;
}



void __libc_start_main(void)

{
  __libc_start_main();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * mempcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = mempcpy(__dest,__src,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int execl(char *__path,char *__arg,...)

{
  int iVar1;
  
  iVar1 = execl(__path,__arg);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _IO_getc(_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_getc(__fp);
  return iVar1;
}



void __memcpy_chk(void)

{
  __memcpy_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * stpcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = stpcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void _exit(int __status)

{
                    // WARNING: Subroutine does not return
  _exit(__status);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strrchr(char *__s,int __c)

{
  char *pcVar1;
  
  pcVar1 = strrchr(__s,__c);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int uname(utsname *__name)

{
  int iVar1;
  
  iVar1 = uname(__name);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcgetattr(int __fd,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcgetattr(__fd,__termios_p);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fseeko64(FILE *__stream,__off64_t __off,int __whence)

{
  int iVar1;
  
  iVar1 = fseeko64(__stream,__off,__whence);
  return iVar1;
}



void __vsnprintf_chk(void)

{
  __vsnprintf_chk();
  return;
}



void rb_str_new(void)

{
  rb_str_new();
  return;
}



void idna_to_ascii_lz(void)

{
  idna_to_ascii_lz();
  return;
}



void XML_GetCurrentColumnNumber(void)

{
  XML_GetCurrentColumnNumber();
  return;
}



void gnutls_cipher_set_priority(void)

{
  gnutls_cipher_set_priority();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t read(int __fd,void *__buf,size_t __nbytes)

{
  ssize_t sVar1;
  
  sVar1 = read(__fd,__buf,__nbytes);
  return sVar1;
}



void inflateInit2_(void)

{
  inflateInit2_();
  return;
}



void __strcat_chk(void)

{
  __strcat_chk();
  return;
}



void gnutls_anon_free_client_credentials(void)

{
  gnutls_anon_free_client_credentials();
  return;
}



void gnutls_credentials_set(void)

{
  gnutls_credentials_set();
  return;
}



void gnutls_cipher_get_name(void)

{
  gnutls_cipher_get_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ungetc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = ungetc(__c,__stream);
  return iVar1;
}



void gnutls_init(void)

{
  gnutls_init();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int gettimeofday(timeval *__tv,__timezone_ptr_t __tz)

{
  int iVar1;
  
  iVar1 = gettimeofday(__tv,__tz);
  return iVar1;
}



void inflate(void)

{
  inflate();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

long strtol(char *__nptr,char **__endptr,int __base)

{
  long lVar1;
  
  lVar1 = strtol(__nptr,__endptr,__base);
  return lVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

FILE * fdopen(int __fd,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fdopen(__fd,__modes);
  return pFVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__int32_t ** __ctype_toupper_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_toupper_loc();
  return pp_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void free(void *__ptr)

{
  free(__ptr);
  return;
}



void rb_define_singleton_method(void)

{
  rb_define_singleton_method();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int inet_pton(int __af,char *__cp,void *__buf)

{
  int iVar1;
  
  iVar1 = inet_pton(__af,__cp,__buf);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __lxstat64(int __ver,char *__filename,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __lxstat64(__ver,__filename,__stat_buf);
  return iVar1;
}



void backtrace_symbols(void)

{
  backtrace_symbols();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * fgets_unlocked(char *__s,int __n,FILE *__stream)

{
  char *pcVar1;
  
  pcVar1 = fgets_unlocked(__s,__n,__stream);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setpgid(__pid_t __pid,__pid_t __pgid)

{
  int iVar1;
  
  iVar1 = setpgid(__pid,__pgid);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int access(char *__name,int __type)

{
  int iVar1;
  
  iVar1 = access(__name,__type);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigaction(int __sig,sigaction *__act,sigaction *__oact)

{
  int iVar1;
  
  iVar1 = sigaction(__sig,__act,__oact);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}



void __vfprintf_chk(void)

{
  __vfprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

DIR * opendir(char *__name)

{
  DIR *pDVar1;
  
  pDVar1 = opendir(__name);
  return pDVar1;
}



void rb_define_module(void)

{
  rb_define_module();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int accept(int __fd,sockaddr *__addr,socklen_t *__addr_len)

{
  int iVar1;
  
  iVar1 = accept(__fd,__addr,__addr_len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ioctl(int __fd,ulong __request,...)

{
  int iVar1;
  
  iVar1 = ioctl(__fd,__request);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int socket(int __domain,int __type,int __protocol)

{
  int iVar1;
  
  iVar1 = socket(__domain,__type,__protocol);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int dup2(int __fd,int __fd2)

{
  int iVar1;
  
  iVar1 = dup2(__fd,__fd2);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ushort ** __ctype_b_loc(void)

{
  ushort **ppuVar1;
  
  ppuVar1 = __ctype_b_loc();
  return ppuVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int isatty(int __fd)

{
  int iVar1;
  
  iVar1 = isatty(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getaddrinfo(char *__name,char *__service,addrinfo *__req,addrinfo **__pai)

{
  int iVar1;
  
  iVar1 = getaddrinfo(__name,__service,__req,__pai);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__mode_t umask(__mode_t __mask)

{
  __mode_t _Var1;
  
  _Var1 = umask(__mask);
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__off64_t ftello64(FILE *__stream)

{
  undefined4 extraout_EAX;
  undefined4 extraout_EDX;
  
  ftello64(__stream);
  return CONCAT44(extraout_EDX,extraout_EAX);
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t mktime(tm *__tp)

{
  time_t tVar1;
  
  tVar1 = mktime(__tp);
  return tVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fsync(int __fd)

{
  int iVar1;
  
  iVar1 = fsync(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

dirent64 * readdir64(DIR *__dirp)

{
  dirent64 *pdVar1;
  
  pdVar1 = readdir64(__dirp);
  return pdVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * tfind(void *__key,void **__rootp,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = tfind(__key,__rootp,__compar);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}



void gnutls_kx_set_priority(void)

{
  gnutls_kx_set_priority();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int utime(char *__file,utimbuf *__file_times)

{
  int iVar1;
  
  iVar1 = utime(__file,__file_times);
  return iVar1;
}



void gnutls_protocol_set_priority(void)

{
  gnutls_protocol_set_priority();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ulong strtoul(char *__nptr,char **__endptr,int __base)

{
  ulong uVar1;
  
  uVar1 = strtoul(__nptr,__endptr,__base);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}



void gnutls_protocol_get_version(void)

{
  gnutls_protocol_get_version();
  return;
}



void gnutls_deinit(void)

{
  gnutls_deinit();
  return;
}



void rb_load_protect(void)

{
  rb_load_protect();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint alarm(uint __seconds)

{
  uint uVar1;
  
  uVar1 = alarm(__seconds);
  return uVar1;
}



void gnutls_anon_allocate_client_credentials(void)

{
  gnutls_anon_allocate_client_credentials();
  return;
}



void rb_class_path(void)

{
  rb_class_path();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int unlink(char *__name)

{
  int iVar1;
  
  iVar1 = unlink(__name);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t iconv(iconv_t __cd,char **__inbuf,size_t *__inbytesleft,char **__outbuf,
            size_t *__outbytesleft)

{
  size_t sVar1;
  
  sVar1 = iconv(__cd,__inbuf,__inbytesleft,__outbuf,__outbytesleft);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

passwd * getpwuid(__uid_t __uid)

{
  passwd *ppVar1;
  
  ppVar1 = getpwuid(__uid);
  return ppVar1;
}



void BZ2_bzDecompress(void)

{
  BZ2_bzDecompress();
  return;
}



void getifaddrs(void)

{
  getifaddrs();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t waitpid(__pid_t __pid,int *__stat_loc,int __options)

{
  __pid_t _Var1;
  
  _Var1 = waitpid(__pid,__stat_loc,__options);
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int feof(FILE *__stream)

{
  int iVar1;
  
  iVar1 = feof(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcpy(char *__dest,char *__src)

{
  char *pcVar1;
  
  pcVar1 = strcpy(__dest,__src);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__gid_t getegid(void)

{
  __gid_t _Var1;
  
  _Var1 = getegid();
  return _Var1;
}



void XML_GetCurrentLineNumber(void)

{
  XML_GetCurrentLineNumber();
  return;
}



void rb_inspect(void)

{
  rb_inspect();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int chdir(char *__path)

{
  int iVar1;
  
  iVar1 = chdir(__path);
  return iVar1;
}



void gnutls_mac_get_name(void)

{
  gnutls_mac_get_name();
  return;
}



void ruby_script(void)

{
  ruby_script();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * ctime(time_t *__timer)

{
  char *pcVar1;
  
  pcVar1 = ctime(__timer);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int bind(int __fd,sockaddr *__addr,socklen_t __len)

{
  int iVar1;
  
  iVar1 = bind(__fd,__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__uid_t getuid(void)

{
  __uid_t _Var1;
  
  _Var1 = getuid();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int raise(int __sig)

{
  int iVar1;
  
  iVar1 = raise(__sig);
  return iVar1;
}



void gnutls_certificate_verify_peers(void)

{
  gnutls_certificate_verify_peers();
  return;
}



void Gpm_GetEvent(void)

{
  Gpm_GetEvent();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int mkstemp64(char *__template)

{
  int iVar1;
  
  iVar1 = mkstemp64(__template);
  return iVar1;
}



void gnutls_compression_get_name(void)

{
  gnutls_compression_get_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int select(int __nfds,fd_set *__readfds,fd_set *__writefds,fd_set *__exceptfds,timeval *__timeout)

{
  int iVar1;
  
  iVar1 = select(__nfds,__readfds,__writefds,__exceptfds,__timeout);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int closedir(DIR *__dirp)

{
  int iVar1;
  
  iVar1 = closedir(__dirp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int close(int __fd)

{
  int iVar1;
  
  iVar1 = close(__fd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strstr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strstr(__haystack,__needle);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

time_t time(time_t *__timer)

{
  time_t tVar1;
  
  tVar1 = time(__timer);
  return tVar1;
}



void gnutls_certificate_free_credentials(void)

{
  gnutls_certificate_free_credentials();
  return;
}



void BZ2_bzDecompressEnd(void)

{
  BZ2_bzDecompressEnd();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * nl_langinfo(nl_item __item)

{
  char *pcVar1;
  
  pcVar1 = nl_langinfo(__item);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}



void XML_ErrorString(void)

{
  XML_ErrorString();
  return;
}



void rb_obj_as_string(void)

{
  rb_obj_as_string();
  return;
}



void __stack_chk_fail(void)

{
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void Gpm_Close(void)

{
  Gpm_Close();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int iconv_close(iconv_t __cd)

{
  int iVar1;
  
  iVar1 = iconv_close(__cd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fputc(int __c,FILE *__stream)

{
  int iVar1;
  
  iVar1 = fputc(__c,__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memrchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memrchr(__s,__c,__n);
  return pvVar1;
}



void rb_define_module_function(void)

{
  rb_define_module_function();
  return;
}



void gss_delete_sec_context(void)

{
  gss_delete_sec_context();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * strcasestr(char *__haystack,char *__needle)

{
  char *pcVar1;
  
  pcVar1 = strcasestr(__haystack,__needle);
  return pcVar1;
}



void freeifaddrs(void)

{
  freeifaddrs();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

group * getgrgid(__gid_t __gid)

{
  group *pgVar1;
  
  pgVar1 = getgrgid(__gid);
  return pgVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

uint sleep(uint __seconds)

{
  uint uVar1;
  
  uVar1 = sleep(__seconds);
  return uVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

ssize_t readlink(char *__path,char *__buf,size_t __len)

{
  ssize_t sVar1;
  
  sVar1 = readlink(__path,__buf,__len);
  return sVar1;
}



void backtrace(void)

{
  backtrace();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}



void XML_ParserFree(void)

{
  XML_ParserFree();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__int32_t ** __ctype_tolower_loc(void)

{
  __int32_t **pp_Var1;
  
  pp_Var1 = __ctype_tolower_loc();
  return pp_Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

wint_t towlower(wint_t __wc)

{
  wint_t wVar1;
  
  wVar1 = towlower(__wc);
  return wVar1;
}



void gnutls_certificate_type_get(void)

{
  gnutls_certificate_type_get();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * getcwd(char *__buf,size_t __size)

{
  char *pcVar1;
  
  pcVar1 = getcwd(__buf,__size);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int sigfillset(sigset_t *__set)

{
  int iVar1;
  
  iVar1 = sigfillset(__set);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int vasprintf(char **__ptr,char *__f,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vasprintf(__ptr,__f,__arg);
  return iVar1;
}



void __rawmemchr(void)

{
  __rawmemchr();
  return;
}



void XML_SetElementHandler(void)

{
  XML_SetElementHandler();
  return;
}



void gnutls_priority_set_direct(void)

{
  gnutls_priority_set_direct();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__pid_t fork(void)

{
  __pid_t _Var1;
  
  _Var1 = fork();
  return _Var1;
}



void gnutls_kx_get(void)

{
  gnutls_kx_get();
  return;
}



void gnutls_kx_get_name(void)

{
  gnutls_kx_get_name();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int __fxstat64(int __ver,int __fildes,stat64 *__stat_buf)

{
  int iVar1;
  
  iVar1 = __fxstat64(__ver,__fildes,__stat_buf);
  return iVar1;
}



void gss_import_name(void)

{
  gss_import_name();
  return;
}



void rb_str_new2(void)

{
  rb_str_new2();
  return;
}



void XML_Parse(void)

{
  XML_Parse();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t __optlen)

{
  int iVar1;
  
  iVar1 = setsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int tcsetattr(int __fd,int __optional_actions,termios *__termios_p)

{
  int iVar1;
  
  iVar1 = tcsetattr(__fd,__optional_actions,__termios_p);
  return iVar1;
}



void rb_intern(void)

{
  rb_intern();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int fcntl(int __fd,int __cmd,...)

{
  int iVar1;
  
  iVar1 = fcntl(__fd,__cmd);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getrlimit64(__rlimit_resource_t __resource,rlimit64 *__rlimits)

{
  int iVar1;
  
  iVar1 = getrlimit64(__resource,__rlimits);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int rand(void)

{
  int iVar1;
  
  iVar1 = rand();
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

tm * gmtime(time_t *__timer)

{
  tm *ptVar1;
  
  ptVar1 = gmtime(__timer);
  return ptVar1;
}



void __sprintf_chk(void)

{
  __sprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * memchr(void *__s,int __c,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memchr(__s,__c,__n);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int open64(char *__file,int __oflag,...)

{
  int iVar1;
  
  iVar1 = open64(__file,__oflag);
  return iVar1;
}



void rb_funcall3(void)

{
  rb_funcall3();
  return;
}



void __snprintf_chk(void)

{
  __snprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int _IO_putc(int __c,_IO_FILE *__fp)

{
  int iVar1;
  
  iVar1 = _IO_putc(__c,__fp);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int munmap(void *__addr,size_t __len)

{
  int iVar1;
  
  iVar1 = munmap(__addr,__len);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pipe(int *__pipedes)

{
  int iVar1;
  
  iVar1 = pipe(__pipedes);
  return iVar1;
}



void Gpm_Open(void)

{
  Gpm_Open();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getsockopt(int __fd,int __level,int __optname,void *__optval,socklen_t *__optlen)

{
  int iVar1;
  
  iVar1 = getsockopt(__fd,__level,__optname,__optval,__optlen);
  return iVar1;
}



void gnutls_global_deinit(void)

{
  gnutls_global_deinit();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strftime(char *__s,size_t __maxsize,char *__format,tm *__tp)

{
  size_t sVar1;
  
  sVar1 = strftime(__s,__maxsize,__format,__tp);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int kill(__pid_t __pid,int __sig)

{
  int iVar1;
  
  iVar1 = kill(__pid,__sig);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * mmap64(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off64_t __offset)

{
  void *pvVar1;
  
  pvVar1 = mmap64(__addr,__len,__prot,__flags,__fd,__offset);
  return pvVar1;
}



void __memmove_chk(void)

{
  __memmove_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

char * tempnam(char *__dir,char *__pfx)

{
  char *pcVar1;
  
  pcVar1 = tempnam(__dir,__pfx);
  return pcVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

size_t strcspn(char *__s,char *__reject)

{
  size_t sVar1;
  
  sVar1 = strcspn(__s,__reject);
  return sVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int getpeername(int __fd,sockaddr *__addr,socklen_t *__len)

{
  int iVar1;
  
  iVar1 = getpeername(__fd,__addr,__len);
  return iVar1;
}



void BZ2_bzDecompressInit(void)

{
  BZ2_bzDecompressInit();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

passwd * getpwnam(char *__name)

{
  passwd *ppVar1;
  
  ppVar1 = getpwnam(__name);
  return ppVar1;
}



void gss_init_sec_context(void)

{
  gss_init_sec_context();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}



void XML_SetCharacterDataHandler(void)

{
  XML_SetCharacterDataHandler();
  return;
}



void gnutls_cipher_get(void)

{
  gnutls_cipher_get();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void herror(char *__str)

{
  herror(__str);
  return;
}



void __strdup(void)

{
  __strdup();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int setenv(char *__name,char *__value,int __replace)

{
  int iVar1;
  
  iVar1 = setenv(__name,__value,__replace);
  return iVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void exit(int __status)

{
                    // WARNING: Subroutine does not return
  exit(__status);
}



void gnutls_bye(void)

{
  gnutls_bye();
  return;
}



void rb_define_const(void)

{
  rb_define_const();
  return;
}



void gnutls_strerror(void)

{
  gnutls_strerror();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

int pclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = pclose(__stream);
  return iVar1;
}



void backtrace_symbols_fd(void)

{
  backtrace_symbols_fd();
  return;
}



void __vasprintf_chk(void)

{
  __vasprintf_chk();
  return;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__gid_t getgid(void)

{
  __gid_t _Var1;
  
  _Var1 = getgid();
  return _Var1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

void * tsearch(void *__key,void **__rootp,__compar_fn_t __compar)

{
  void *pvVar1;
  
  pvVar1 = tsearch(__key,__rootp,__compar);
  return pvVar1;
}



// WARNING: Unknown calling convention -- yet parameter storage is locked

__uid_t geteuid(void)

{
  __uid_t _Var1;
  
  _Var1 = geteuid();
  return _Var1;
}



void processEntry _start(undefined4 param_1,undefined4 param_2)

{
  undefined auStack_4 [4];
  
  __libc_start_main(main,param_2,&stack0x00000004,__libc_csu_init,__libc_csu_fini,param_1,auStack_4)
  ;
  do {
                    // WARNING: Do nothing block with infinite loop
  } while( true );
}



// WARNING: Removing unreachable block (ram,0x08059baa)
// WARNING: Removing unreachable block (ram,0x08059bb0)

void __do_global_dtors_aux(void)

{
  if (completed_7065 == '\0') {
    completed_7065 = '\x01';
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x08059bef)
// WARNING: Removing unreachable block (ram,0x08059bf8)

void frame_dummy(void)

{
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T select_button(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
                    // WARNING: Could not recover jumptable at 0x08059c1f. Too many branches
                    // WARNING: Treating indirect jump as call
  wVar1 = (*widget_data->widget->handler)(dlg_data,widget_data);
  return wVar1;
}



// WARNING: Unknown calling convention

widget_handler_status_T mouse_button(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *ptVar1;
  term_event *ptVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  widget_handler_T *UNRECOVERED_JUMPTABLE;
  widget_handler_status_T wVar7;
  term_event *ev;
  
  ptVar1 = dlg_data->win->term;
  ptVar2 = dlg_data->term_event;
  if (((ptVar2->info).mouse.button & 7) < 3) {
    iVar3 = (ptVar2->info).mouse.y;
    iVar4 = (ptVar2->info).mouse.x;
    iVar5 = (widget_data->box).x;
    if ((((iVar5 <= iVar4) && (iVar6 = (widget_data->box).y, iVar6 <= iVar3)) &&
        (iVar4 < iVar5 + (widget_data->box).width)) && (iVar3 < (widget_data->box).height + iVar6))
    {
      select_widget(dlg_data,widget_data);
      (ptVar1->prev_mouse_event).x = 0;
      (ptVar1->prev_mouse_event).y = 0;
      (ptVar1->prev_mouse_event).button = 0;
      if (((*(byte *)((int)&ptVar2->info + 8) & 0x20) != 0) &&
         (UNRECOVERED_JUMPTABLE = widget_data->widget->ops->select,
         UNRECOVERED_JUMPTABLE != (widget_handler_T *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x08059cee. Too many branches
                    // WARNING: Treating indirect jump as call
        wVar7 = (*UNRECOVERED_JUMPTABLE)(dlg_data,widget_data);
        return wVar7;
      }
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_button(dialog_data *dlg_data,widget_data *widget_data)

{
  uchar *p;
  terminal *term_00;
  uchar *text;
  uint length;
  option_value *poVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int text_cells;
  int right;
  int iVar5;
  int right_1;
  int hk_len;
  screen_char_attr attr;
  int button_left_len;
  terminal *term;
  bool bVar6;
  int local_34;
  color_pair *local_2c;
  int local_24;
  color_pair *local_20;
  
  term_00 = dlg_data->win->term;
  bVar6 = dlg_data->widgets_data + dlg_data->selected_widget_id == widget_data;
  if (bVar6) {
    local_2c = get_bfu_color(term_00,"dialog.button-shortcut-selected");
    local_20 = get_bfu_color(term_00,(uchar *)"dialog.button-selected");
  }
  else {
    local_2c = get_bfu_color(term_00,(uchar *)"dialog.button-shortcut");
    local_20 = get_bfu_color(term_00,"dialog.button");
  }
  if ((local_2c != (color_pair *)0x0) && (local_20 != (color_pair *)0x0)) {
    if ((term_00->field_0x38 & 2) == 0) {
      iVar2 = (widget_data->box).x;
      local_34 = iVar2 + 2;
      local_24 = (widget_data->box).width + -4;
    }
    else {
      iVar3 = utf8_ptr2cells("[ ",(uchar *)0x0);
      iVar4 = utf8_ptr2cells(" ]",(uchar *)0x0);
      iVar2 = (widget_data->box).x;
      local_34 = iVar3 + iVar2;
      local_24 = (-iVar3 - iVar4) + (widget_data->box).width;
    }
    draw_text(term_00,iVar2,(widget_data->box).y,"[ ",2,0,local_20);
    if (0 < local_24) {
      text = widget_data->widget->text;
      length = (widget_data->widget->info).checkbox.gnum;
      poVar1 = get_opt_();
      attr = ~-(uint)(poVar1->tree == (list_head_elinks *)0x0) & SCREEN_ATTR_UNDERLINE;
      if ((term_00->field_0x38 & 2) == 0) {
        if ((int)length < 0) {
          draw_text(term_00,local_34,(widget_data->box).y,text,1,attr,local_2c);
          draw_text(term_00,local_34 + 1,(widget_data->box).y,text + 1,local_24 + -1,0,local_20);
        }
        else {
          iVar2 = ~length + (widget_data->widget->info).field.flags;
          if (length != 0) {
            draw_text(term_00,local_34,(widget_data->box).y,text,length,0,local_20);
          }
          draw_text(term_00,local_34 + length,(widget_data->box).y,text + length + 1,1,attr,local_2c
                   );
          if (1 < iVar2) {
            draw_text(term_00,local_34 + length + 1,(widget_data->box).y,text + length + 2,
                      iVar2 + -1,0,local_20);
          }
        }
      }
      else if ((int)length < 0) {
        iVar2 = utf8_char2cells(text,(uchar *)0x0);
        iVar3 = utf8charlen(text);
        iVar4 = utf8_cells2bytes(text + iVar3,local_24 - iVar2,(uchar *)0x0);
        draw_text(term_00,local_34,(widget_data->box).y,text,iVar3,attr,local_2c);
        draw_text(term_00,iVar2 + local_34,(widget_data->box).y,text + iVar3,iVar4,0,local_20);
      }
      else {
        p = text + length + 1;
        iVar2 = utf8charlen(p);
        iVar3 = utf8_ptr2cells(text,text + length);
        iVar5 = ((widget_data->widget->info).field.flags - length) - iVar2;
        iVar4 = utf8_char2cells(p,(uchar *)0x0);
        if (length != 0) {
          draw_text(term_00,local_34,(widget_data->box).y,text,length,0,local_20);
        }
        draw_text(term_00,iVar3 + local_34,(widget_data->box).y,p,iVar2,attr,local_2c);
        if (1 < iVar5) {
          draw_text(term_00,iVar3 + local_34 + iVar4,(widget_data->box).y,text + iVar2 + 1 + length,
                    iVar5 + -1,0,local_20);
        }
      }
    }
    if ((term_00->field_0x38 & 2) == 0) {
      draw_text(term_00,local_34 + local_24,(widget_data->box).y," ]",2,0,local_20);
    }
    else {
      iVar2 = utf8_ptr2cells(widget_data->widget->text,(uchar *)0x0);
      draw_text(term_00,local_34 + (~(widget_data->widget->info).checkbox.gnum >> 0x1f) + iVar2,
                (widget_data->box).y," ]",2,0,local_20);
    }
    if (bVar6) {
      set_cursor(term_00,local_34,(widget_data->box).y,1);
      dlg_data->win->x = (widget_data->box).x;
      dlg_data->win->y = (widget_data->box).y;
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void add_dlg_button_do(dialog *dlg,uchar *text,int flags,widget_handler_T *handler,void *data,
                      done_handler_T *done,void *done_data)

{
  input_history **ppiVar1;
  int iVar2;
  size_t sVar3;
  void *pvVar4;
  
  sVar3 = strlen((char *)text);
  iVar2 = dlg->number_of_widgets;
  dlg->number_of_widgets = iVar2 + 1;
  dlg->widgets[iVar2].type = WIDGET_BUTTON;
  dlg->widgets[iVar2].text = text;
  dlg->widgets[iVar2].handler = handler;
  dlg->widgets[iVar2].data = data;
  dlg->widgets[iVar2].info.checkbox.gid = flags;
  dlg->widgets[iVar2].info.button.done = done;
  dlg->widgets[iVar2].info.button.done_data = done_data;
  dlg->widgets[iVar2].info.checkbox.gnum = -1;
  dlg->widgets[iVar2].info.button.textlen = sVar3;
  dlg->widgets[iVar2].info.button.truetextlen = sVar3;
  if (1 < (int)sVar3) {
    pvVar4 = memchr(text,0x7e,sVar3 - 1);
    if (pvVar4 != (void *)0x0) {
      ppiVar1 = &dlg->widgets[iVar2].info.field.history;
      *ppiVar1 = (input_history *)&(*ppiVar1)[-1].field_0xf;
      dlg->widgets[iVar2].info.checkbox.gnum = (int)pvVar4 - (int)text;
    }
  }
  return;
}



// WARNING: Type propagation algorithm not settling

void __regparm3 buttons_width(widget_data *widget_data,int n,int *minwidth,int *maxwidth,int utf8)

{
  int iVar1;
  int iVar2;
  int button_lr_len;
  int minw;
  int iVar3;
  undefined *puVar4;
  int maxw;
  int iVar5;
  undefined *puVar6;
  
  iVar1 = utf8_ptr2cells("[ ",(uchar *)0x0);
  iVar2 = utf8_ptr2cells(" ]",(uchar *)0x0);
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(n < 1);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/button.c";
    errline = 0x60;
    elinks_internal((uchar *)"assertion n > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (n == 0) {
    puVar6 = (undefined *)0xfffffffe;
  }
  else {
    iVar5 = n + -1;
    puVar6 = (undefined *)0xfffffffe;
    while( true ) {
      if (maxwidth == (int *)0x0) {
        puVar4 = (undefined *)
                 ((int)&(((widget_data->widget->info).field.history)->entries).prev + 2);
      }
      else {
        iVar3 = utf8_ptr2cells(widget_data->widget->text,(uchar *)0x0);
        puVar4 = (undefined *)(iVar3 + iVar2 + iVar1 + 2);
      }
      puVar6 = puVar6 + (int)puVar4;
      if (iVar5 == 0) break;
      iVar5 = iVar5 + -1;
      widget_data = widget_data + 1;
    }
  }
  if ((minwidth != (int *)0x0) && (*minwidth < (int)puVar6)) {
    *minwidth = (int)puVar6;
  }
  return;
}



// WARNING: Unknown calling convention

void dlg_format_buttons(terminal *term,widget_data *widget_data,int n,int x,int *y,int w,int *rw,
                       format_align align,int format_only)

{
  input_history *piVar1;
  int iVar2;
  int iVar3;
  int i;
  void **ppvVar4;
  int iVar5;
  undefined *puVar6;
  void **ppvVar7;
  int p;
  int i2;
  int iVar8;
  undefined *puVar9;
  int iVar10;
  widget_data *widget_data_00;
  int in_stack_ffffffb8;
  int local_34;
  int local_20 [4];
  
  if (0 < n) {
    local_34 = 0;
    do {
      iVar8 = local_34 + 1;
      widget_data_00 = widget_data + local_34;
      if (iVar8 < n) {
        iVar10 = 2;
        do {
          local_20[0] = 0;
          buttons_width(widget_data_00,iVar10,local_20,(int *)((byte)term->field_0x38 >> 1 & 1),
                        in_stack_ffffffb8);
          if (w < local_20[0]) break;
          iVar8 = iVar8 + 1;
          iVar10 = iVar10 + 1;
        } while (iVar8 < n);
      }
      local_20[0] = 0;
      buttons_width(widget_data_00,iVar8 - local_34,local_20,
                    (int *)((byte)term->field_0x38 >> 1 & 1),in_stack_ffffffb8);
      if (rw != (int *)0x0) {
        if (*rw < local_20[0]) {
          *rw = local_20[0];
        }
        else if (w < *rw) {
          *rw = w;
        }
      }
      if (format_only == 0) {
        iVar10 = 0;
        if (align == ALIGN_CENTER) {
          iVar10 = (w - local_20[0]) / 2;
        }
        iVar2 = utf8_ptr2cells("[ ",(uchar *)0x0);
        in_stack_ffffffb8 = 0;
        iVar3 = utf8_ptr2cells(" ]",(uchar *)0x0);
        if (local_34 < iVar8) {
          puVar9 = (undefined *)(iVar10 + x);
          while( true ) {
            if ((term->field_0x38 & 2) == 0) {
              iVar10 = *y;
              piVar1 = (widget_data_00->widget->info).field.history;
              puVar6 = (undefined *)0x0;
              if (-1 < (int)puVar9) {
                puVar6 = puVar9;
              }
              (widget_data_00->box).x = (int)puVar6;
              (widget_data_00->box).height = 1;
              if (iVar10 < 0) {
                iVar10 = 0;
              }
              ppvVar4 = &(piVar1->entries).prev;
              if ((int)ppvVar4 < 0) {
                ppvVar4 = (void **)0x0;
              }
              (widget_data_00->box).y = iVar10;
              (widget_data_00->box).width = (int)ppvVar4;
            }
            else {
              in_stack_ffffffb8 = 0;
              iVar5 = utf8_ptr2cells(widget_data_00->widget->text,(uchar *)0x0);
              iVar10 = *y;
              puVar6 = (undefined *)0x0;
              if (-1 < (int)puVar9) {
                puVar6 = puVar9;
              }
              (widget_data_00->box).x = (int)puVar6;
              if (iVar10 < 0) {
                iVar10 = 0;
              }
              (widget_data_00->box).y = iVar10;
              ppvVar7 = (void **)(iVar5 + iVar3 + iVar2);
              (widget_data_00->box).height = 1;
              ppvVar4 = (void **)0x0;
              if (-1 < (int)ppvVar7) {
                ppvVar4 = ppvVar7;
              }
              (widget_data_00->box).width = (int)ppvVar4;
            }
            if (iVar8 <= local_34 + 1) break;
            local_34 = local_34 + 1;
            widget_data_00 = widget_data_00 + 1;
            puVar9 = (undefined *)((int)ppvVar4 + 2) + (int)puVar9;
          }
        }
      }
      *y = *y + 2;
      local_34 = iVar8;
    } while (iVar8 < n);
  }
  return;
}



// WARNING: Unknown calling convention

void add_dlg_radio_do(dialog *dlg,uchar *text,int groupid,int groupnum,int *data)

{
  int iVar1;
  
  iVar1 = dlg->number_of_widgets;
  dlg->number_of_widgets = iVar1 + 1;
  dlg->widgets[iVar1].type = WIDGET_CHECKBOX;
  dlg->widgets[iVar1].text = text;
  dlg->widgets[iVar1].datalen = 4;
  dlg->widgets[iVar1].data = data;
  dlg->widgets[iVar1].info.checkbox.gid = groupid;
  dlg->widgets[iVar1].info.checkbox.gnum = groupnum;
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T init_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  int *cdata;
  
  piVar1 = (int *)widget_data->cdata;
  if ((assert_failed == 0) && (assert_failed = (int)(piVar1 == (int *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
    errline = 0x60;
    elinks_internal((uchar *)"assertion cdata failed!");
  }
  if ((widget_data->widget->info).checkbox.gid == 0) {
    if (*piVar1 != 0) goto LAB_0805a77e;
  }
  else if (*piVar1 == (widget_data->widget->info).checkbox.gnum) {
LAB_0805a77e:
    (widget_data->info).field.vpos = 1;
    return EVENT_PROCESSED;
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T select_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  uint *puVar1;
  uint uVar2;
  int *piVar3;
  widget *pwVar4;
  int iVar5;
  int *cdata;
  widget_data *wdata;
  widget_data *widget_data_00;
  
  if ((widget_data->widget->info).checkbox.gid == 0) {
    puVar1 = (uint *)widget_data->cdata;
    if ((assert_failed == 0) && (assert_failed = (int)(puVar1 == (uint *)0x0), assert_failed != 0))
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
      errline = 0x88;
      elinks_internal((uchar *)"assertion cdata failed!");
    }
    uVar2 = *puVar1;
    *puVar1 = (uint)(uVar2 == 0);
    (widget_data->info).field.vpos = (uint)(uVar2 == 0);
  }
  else {
    iVar5 = dlg_data->number_of_widgets;
    widget_data_00 = dlg_data->widgets_data;
    if (widget_data_00 != dlg_data->widgets_data + iVar5) {
      do {
        piVar3 = (int *)widget_data_00->cdata;
        if ((widget_data_00->widget->type == WIDGET_CHECKBOX) &&
           (pwVar4 = widget_data->widget,
           (widget_data_00->widget->info).checkbox.gid == (pwVar4->info).checkbox.gid)) {
          if (assert_failed == 0) {
            assert_failed = (int)(piVar3 == (int *)0x0);
            if (assert_failed == 0) {
              pwVar4 = widget_data->widget;
            }
            else {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
              errline = 0x9a;
              elinks_internal((uchar *)"assertion cdata failed!");
              pwVar4 = widget_data->widget;
            }
          }
          *piVar3 = (pwVar4->info).checkbox.gnum;
          (widget_data_00->info).field.vpos = 0;
          display_widget(dlg_data,widget_data_00);
          iVar5 = dlg_data->number_of_widgets;
        }
        widget_data_00 = widget_data_00 + 1;
      } while (dlg_data->widgets_data + iVar5 != widget_data_00);
    }
    (widget_data->info).field.vpos = 1;
  }
  display_widget(dlg_data,widget_data);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T mouse_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *ptVar1;
  term_event *ptVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  widget_handler_T *pwVar7;
  term_event *ev;
  
  ptVar1 = dlg_data->win->term;
  ptVar2 = dlg_data->term_event;
  if (((ptVar2->info).mouse.button & 7) < 3) {
    iVar3 = (ptVar2->info).mouse.y;
    iVar4 = (ptVar2->info).mouse.x;
    iVar5 = (widget_data->box).x;
    if ((((iVar5 <= iVar4) && (iVar6 = (widget_data->box).y, iVar6 <= iVar3)) &&
        (iVar4 < iVar5 + (widget_data->box).width)) && (iVar3 < (widget_data->box).height + iVar6))
    {
      select_widget(dlg_data,widget_data);
      (ptVar1->prev_mouse_event).x = 0;
      (ptVar1->prev_mouse_event).y = 0;
      (ptVar1->prev_mouse_event).button = 0;
      if (((*(byte *)((int)&ptVar2->info + 8) & 0x20) != 0) &&
         (pwVar7 = widget_data->widget->ops->select, pwVar7 != (widget_handler_T *)0x0)) {
        (*pwVar7)(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_checkbox(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *term_00;
  color_pair *color_00;
  color_pair *color;
  uchar *text_00;
  uchar *text;
  terminal *term;
  bool bVar1;
  
  term_00 = dlg_data->win->term;
  bVar1 = dlg_data->widgets_data + dlg_data->selected_widget_id == widget_data;
  if (bVar1) {
    color_00 = get_bfu_color(term_00,(uchar *)"dialog.checkbox-selected");
  }
  else {
    color_00 = get_bfu_color(term_00,(uchar *)"dialog.checkbox");
  }
  if (color_00 != (color_pair *)0x0) {
    if ((widget_data->info).field.vpos == 0) {
      text_00 = "[ ]";
      if ((widget_data->widget->info).checkbox.gid != 0) {
        text_00 = "( )";
      }
    }
    else {
      text_00 = "[X]";
      if ((widget_data->widget->info).checkbox.gid != 0) {
        text_00 = "(X)";
      }
    }
    draw_text(term_00,(widget_data->box).x,(widget_data->box).y,text_00,3,0,color_00);
    if (bVar1) {
      set_cursor(term_00,(widget_data->box).x + 1,(widget_data->box).y,1);
      dlg_data->win->x = (widget_data->box).x;
      dlg_data->win->y = (widget_data->box).y;
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void dlg_format_checkbox(terminal *term,widget_data *widget_data,int x,int *y,int w,int *rw,
                        format_align align,int format_only)

{
  uchar *text_00;
  int iVar1;
  color_pair *pcVar2;
  int iVar3;
  uchar *text;
  
  text_00 = widget_data->widget->text;
  iVar1 = *y;
  iVar3 = 0;
  if (-1 < x) {
    iVar3 = x;
  }
  (widget_data->box).x = iVar3;
  iVar3 = 0;
  if (-1 < iVar1) {
    iVar3 = iVar1;
  }
  (widget_data->box).y = iVar3;
  (widget_data->box).width = 3;
  (widget_data->box).height = 1;
  if (((4 < w) && (text_00 != (uchar *)0x0)) && (*text_00 != '\0')) {
    if (rw == (int *)0x0) {
      pcVar2 = get_bfu_color(term,(uchar *)"dialog.checkbox-label");
      dlg_format_text_do(term,text_00,x + 4,y,w + -4,(int *)0x0,pcVar2,align,format_only);
    }
    else {
      *rw = *rw + -4;
      pcVar2 = get_bfu_color(term,(uchar *)"dialog.checkbox-label");
      dlg_format_text_do(term,text_00,x + 4,y,w + -4,rw,pcVar2,align,format_only);
      *rw = *rw + 4;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void refresh_dialog(dialog_data *dlg_data,dialog_refresh_handler_T handler,void *data)

{
  dialog_refresh *pdVar1;
  dialog_refresh *refresh;
  timer_id_T *id;
  
  pdVar1 = dlg_data->dlg->refresh;
  if (pdVar1 == (dialog_refresh *)0x0) {
    pdVar1 = (dialog_refresh *)mem_calloc(1,0xc);
    if (pdVar1 == (dialog_refresh *)0x0) {
      return;
    }
    id = &pdVar1->timer;
    dlg_data->dlg->refresh = pdVar1;
  }
  else {
    id = &pdVar1->timer;
    kill_timer(id);
  }
  pdVar1->handler = handler;
  pdVar1->data = data;
  install_timer(id,100,do_refresh_dialog,dlg_data);
  return;
}



// WARNING: Unknown calling convention

void draw_dialog(dialog_data *dlg_data,int width,int height)

{
  terminal *term_00;
  int iVar1;
  color_pair *pcVar2;
  option_value *poVar3;
  int iVar4;
  int dlg_width;
  box *box;
  terminal *term;
  int dlg_height;
  int iVar5;
  int iVar6;
  
  iVar4 = width + 0xc;
  term_00 = dlg_data->win->term;
  iVar6 = term_00->height;
  if (term_00->width < iVar4) {
    iVar4 = term_00->width;
  }
  iVar1 = height + 4;
  if (iVar6 < height + 4) {
    iVar1 = iVar6;
  }
  iVar5 = (term_00->width - iVar4) / 2;
  if (iVar5 < 0) {
    iVar5 = 0;
  }
  (dlg_data->box).x = iVar5;
  iVar6 = (iVar6 - iVar1) / 2;
  if (iVar6 < 0) {
    iVar6 = 0;
  }
  if (iVar4 < 0) {
    iVar4 = 0;
  }
  if (iVar1 < 0) {
    iVar1 = 0;
  }
  (dlg_data->box).width = iVar4;
  (dlg_data->box).y = iVar6;
  (dlg_data->box).height = iVar1;
  box = &dlg_data->box;
  pcVar2 = get_bfu_color(term_00,"dialog.generic");
  draw_box(term_00,box,' ',0,pcVar2);
  poVar3 = get_opt_();
  if (poVar3->tree == (list_head_elinks *)0x0) {
    if ((term_00->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term_00,box,0,0,0);
      return;
    }
  }
  else {
    pcVar2 = get_bfu_color(term_00,"dialog.shadow");
    draw_shadow(term_00,box,pcVar2,2,1);
    if ((term_00->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term_00,box,0,2,1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void format_widgets(terminal *term,dialog_data *dlg_data,int x,int *y,int w,int h,int *rw,
                   int format_only)

{
  widget *pwVar1;
  widget_data *widget_data;
  widget_data *pwVar2;
  int iVar3;
  int size;
  int n;
  int widgets;
  int n_00;
  widget_data *wdata;
  
  n_00 = dlg_data->number_of_widgets;
  widget_data = dlg_data->widgets_data;
  do {
    if (n_00 < 1) {
      return;
    }
    pwVar1 = widget_data->widget;
    if (WIDGET_TEXT < pwVar1->type) goto LAB_0805ae4c;
    switch(pwVar1->type) {
    case WIDGET_CHECKBOX:
      iVar3 = (pwVar1->info).checkbox.gid;
      if ((iVar3 < 1) || ((*(byte *)&dlg_data->dlg->layout & 8) == 0)) {
        dlg_format_checkbox(term,widget_data,x,y,w,rw,ALIGN_LEFT,format_only);
        if (n_00 == 1) {
          *y = *y + 1;
          return;
        }
        pwVar2 = widget_data + 1;
        if (pwVar2->widget->type == WIDGET_CHECKBOX) {
          if ((pwVar2->widget->info).checkbox.gid == iVar3) goto LAB_0805b096;
        }
        else if (iVar3 == -1) {
LAB_0805b096:
          n_00 = n_00 + -1;
          iVar3 = *y + -1;
          *y = iVar3;
          break;
        }
LAB_0805ae4c:
        pwVar2 = widget_data + 1;
        iVar3 = *y;
        n_00 = n_00 + -1;
      }
      else {
        n = 1;
        pwVar2 = widget_data;
        do {
          if (((pwVar2[1].widget)->type != WIDGET_CHECKBOX) ||
             (iVar3 != ((pwVar2[1].widget)->info).checkbox.gid)) {
            n_00 = n_00 + -1;
            goto LAB_0805afef;
          }
          n = n + 1;
          pwVar2 = pwVar2 + 1;
          n_00 = n_00 + -1;
        } while (n_00 != 0);
        n_00 = -1;
LAB_0805afef:
        dlg_format_group(term,widget_data,n,x,y,w,rw,format_only);
        pwVar2 = widget_data + n;
        iVar3 = *y;
      }
      break;
    default:
      n_00 = n_00 + -1;
      pwVar2 = widget_data + 1;
      dlg_format_field(term,widget_data,x,y,w,rw,ALIGN_LEFT,format_only);
      iVar3 = *y;
      break;
    case WIDGET_BUTTON:
      dlg_format_buttons(term,widget_data,n_00,x,y,w,rw,ALIGN_CENTER,format_only);
      return;
    case WIDGET_LISTBOX:
      n_00 = n_00 + -1;
      pwVar2 = widget_data + 1;
      dlg_format_listbox(term,widget_data,x,y,w,h,rw,ALIGN_LEFT,format_only);
      iVar3 = *y;
      break;
    case WIDGET_TEXT:
      n_00 = n_00 + -1;
      pwVar2 = widget_data + 1;
      dlg_format_text(term,widget_data,x,y,w,rw,h,format_only);
      iVar3 = *y;
    }
    *y = iVar3 + 1;
    widget_data = pwVar2;
  } while( true );
}



// WARNING: Unknown calling convention

void generic_dialog_layouter(dialog_data *dlg_data)

{
  byte bVar1;
  terminal *term_00;
  int y;
  size_t sVar2;
  int iVar3;
  size_t sVar4;
  int iVar5;
  int height;
  dialog *pdVar6;
  terminal *term;
  int w;
  size_t w_00;
  int local_30;
  size_t local_24;
  int local_20 [4];
  
  term_00 = dlg_data->win->term;
  sVar4 = (term_00->width * 9) / 10 - 0xc;
  w_00 = 1;
  if (0 < (int)sVar4) {
    sVar2 = term_00->width - 0xc;
    if (0 < (int)sVar2) {
      w_00 = sVar2;
    }
    if ((int)sVar4 <= (int)w_00) {
      w_00 = sVar4;
    }
  }
  local_30 = 1;
  iVar5 = (term_00->height * 9) / 10 + -4;
  if (0 < iVar5) {
    iVar3 = term_00->height + -4;
    local_30 = 1;
    if (0 < iVar3) {
      local_30 = iVar3;
    }
    if (iVar5 <= local_30) {
      local_30 = iVar5;
    }
  }
  if ((term_00->field_0x38 & 2) == 0) {
    pdVar6 = dlg_data->dlg;
    local_24 = strlen((char *)pdVar6->title);
    if ((int)w_00 < (int)local_24) {
      local_24 = w_00;
    }
  }
  else {
    local_24 = utf8_ptr2cells(dlg_data->dlg->title,(uchar *)0x0);
    if ((int)w_00 < (int)local_24) {
      local_24 = w_00;
    }
    pdVar6 = dlg_data->dlg;
  }
  local_20[0] = -(uint)((*(byte *)&pdVar6->layout & 2) == 0);
  format_widgets(term_00,dlg_data,0,local_20,w_00,local_30,(int *)&local_24,1);
  bVar1 = *(byte *)&dlg_data->dlg->layout;
  if ((bVar1 & 4) == 0) {
    sVar4 = local_24;
    if ((bVar1 & 1) == 0) goto LAB_0805b1e7;
  }
  else {
    sVar4 = dlg_data->dlg->widgets[0].datalen;
    if ((int)sVar4 <= (int)local_24) {
      sVar4 = local_24;
    }
    local_24 = sVar4;
    sVar4 = local_24;
    if ((int)local_24 < (int)w_00) goto LAB_0805b1e7;
  }
  sVar4 = w_00;
LAB_0805b1e7:
  draw_dialog(dlg_data,sVar4,local_20[0]);
  local_20[0] = (dlg_data->box).y + 2 + (*(byte *)&dlg_data->dlg->layout >> 1 & 1);
  format_widgets(term_00,dlg_data,(dlg_data->box).x + 6,local_20,sVar4,local_30,(int *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

int update_dialog_data(dialog_data *dlg_data)

{
  size_t __n;
  int iVar1;
  widget_data *widget_data;
  widget_data *pwVar2;
  
  iVar1 = dlg_data->number_of_widgets;
  pwVar2 = dlg_data->widgets_data;
  if (pwVar2 != dlg_data->widgets_data + iVar1) {
    do {
      __n = pwVar2->widget->datalen;
      if (__n != 0) {
        memcpy(pwVar2->widget->data,pwVar2->cdata,__n);
        iVar1 = dlg_data->number_of_widgets;
      }
      pwVar2 = pwVar2 + 1;
    } while (dlg_data->widgets_data + iVar1 != pwVar2);
  }
  return 0;
}



// WARNING: Unknown calling convention

widget_handler_status_T cancel_dialog(dialog_data *dlg_data,widget_data *xxx)

{
  delete_window(dlg_data->win);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void select_widget(dialog_data *dlg_data,widget_data *widget_data)

{
  int iVar1;
  widget_data *previously_selected_widget;
  
  iVar1 = dlg_data->selected_widget_id;
  dlg_data->selected_widget_id = ((int)widget_data - (int)dlg_data->widgets_data >> 4) * -0x55555555
  ;
  display_widget(dlg_data,dlg_data->widgets_data + iVar1);
  display_widget(dlg_data,widget_data);
  return;
}



// WARNING: Unknown calling convention

widget_data * select_widget_by_id(dialog_data *dlg_data,int i)

{
  widget_data *widget_data_00;
  widget_data *widget_data;
  
  widget_data_00 = (widget_data *)0x0;
  if (dlg_data->number_of_widgets != i && i <= dlg_data->number_of_widgets) {
    widget_data_00 = dlg_data->widgets_data + i;
    select_widget(dlg_data,widget_data_00);
  }
  return widget_data_00;
}



// WARNING: Unknown calling convention

void select_dlg_item(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_T *pwVar1;
  
  select_widget(dlg_data,widget_data);
  pwVar1 = widget_data->widget->ops->select;
  if (pwVar1 != (widget_handler_T *)0x0) {
    (*pwVar1)(dlg_data,widget_data);
  }
  return;
}



// WARNING: Unknown calling convention

void cycle_widget_focus(dialog_data *dlg_data,int direction)

{
  int iVar1;
  widget *pwVar2;
  widget_type wVar3;
  int iVar4;
  int iVar5;
  int prev_selected;
  int iVar6;
  
  iVar1 = dlg_data->selected_widget_id;
  iVar6 = dlg_data->number_of_widgets + -1;
  prev_selected = iVar1;
  do {
    prev_selected = prev_selected + direction;
    dlg_data->selected_widget_id = prev_selected;
    if (prev_selected < dlg_data->number_of_widgets) {
      if (prev_selected < 0) {
        dlg_data->selected_widget_id = iVar6;
        prev_selected = iVar6;
      }
    }
    else {
      dlg_data->selected_widget_id = 0;
      prev_selected = 0;
    }
    pwVar2 = dlg_data->widgets_data[prev_selected].widget;
    wVar3 = pwVar2->type;
  } while (((wVar3 == WIDGET_LISTBOX) ||
           ((wVar3 == WIDGET_TEXT &&
            (((((*(byte *)((int)&pwVar2->info + 4) & 2) == 0 ||
               (iVar4 = dlg_data->widgets_data[prev_selected].box.height, iVar4 < 1)) ||
              (iVar5 = dlg_data->widgets_data[prev_selected].info.field.cpos, iVar5 < 1)) ||
             (iVar5 <= iVar4)))))) && (iVar1 != prev_selected));
  display_widget(dlg_data,dlg_data->widgets_data + iVar1);
  display_widget(dlg_data,dlg_data->widgets_data + dlg_data->selected_widget_id);
  redraw_from_window(dlg_data->win);
  return;
}



// WARNING: Unknown calling convention

void redraw_dialog(dialog_data *dlg_data,int layout)

{
  terminal *term_00;
  uchar *string;
  widget *pwVar1;
  widget_type wVar2;
  color_pair *pcVar3;
  color_pair *title_color;
  size_t length;
  int titlecells;
  size_t sVar4;
  int titlelen;
  int iVar5;
  int x;
  int iVar6;
  terminal *term;
  widget_data *widget_data;
  widget_data *widget_data_00;
  size_t local_38;
  box box;
  
  term_00 = dlg_data->win->term;
  if (layout != 0) {
    (*dlg_data->dlg->layouter)(dlg_data);
    iVar5 = dlg_data->selected_widget_id;
    pwVar1 = dlg_data->widgets_data[iVar5].widget;
    wVar2 = pwVar1->type;
    if ((wVar2 == WIDGET_LISTBOX) ||
       ((wVar2 == WIDGET_TEXT &&
        (((((*(byte *)((int)&pwVar1->info + 4) & 2) == 0 ||
           (iVar6 = dlg_data->widgets_data[iVar5].box.height, iVar6 < 1)) ||
          (iVar5 = dlg_data->widgets_data[iVar5].info.field.cpos, iVar5 < 1)) || (iVar5 <= iVar6))))
       )) {
      cycle_widget_focus(dlg_data,1);
    }
  }
  if ((*(byte *)&dlg_data->dlg->layout & 0x10) == 0) {
    box.x = (dlg_data->box).x + 4;
    if (box.x < 0) {
      box.x = 0;
    }
    box.y = (dlg_data->box).y + 2;
    if (box.y < 0) {
      box.y = 0;
    }
    box.width = (dlg_data->box).width + -8;
    if (box.width < 0) {
      box.width = 0;
    }
    iVar5 = (dlg_data->box).height + -4;
    box.height = 0;
    if (-1 < iVar5) {
      box.height = iVar5;
    }
    pcVar3 = get_bfu_color(term_00,"dialog.frame");
    draw_border(term_00,&box,pcVar3,2);
    if ((assert_failed == 0) &&
       (assert_failed = (int)(dlg_data->dlg->title == (uchar *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
      errline = 0x5f;
      elinks_internal((uchar *)"assertion dlg_data->dlg->title failed!");
    }
    pcVar3 = get_bfu_color(term_00,"dialog.title");
    iVar5 = box.width;
    if ((pcVar3 != (color_pair *)0x0) && (2 < box.width)) {
      string = dlg_data->dlg->title;
      length = strlen((char *)string);
      if ((term_00->field_0x38 & 2) == 0) {
        local_38 = iVar5 - 2U;
        if ((int)length <= (int)(iVar5 - 2U)) {
          local_38 = length;
        }
      }
      else {
        sVar4 = utf8_ptr2cells(string,string + length);
        local_38 = box.width - 2U;
        if ((int)sVar4 <= (int)(box.width - 2U)) {
          local_38 = sVar4;
        }
        iVar5 = box.width;
        if ((term_00->field_0x38 & 2) != 0) {
          length = utf8_cells2bytes(string,local_38,(uchar *)0x0);
          iVar5 = box.width;
        }
      }
      iVar6 = (int)(iVar5 - local_38) / 2 + box.x;
      iVar5 = box.y + -1;
      draw_text(term_00,iVar6 + -1,iVar5," ",1,0,pcVar3);
      draw_text(term_00,iVar6,iVar5,string,length,0,pcVar3);
      draw_text(term_00,iVar6 + local_38,iVar5," ",1,0,pcVar3);
    }
  }
  for (widget_data_00 = dlg_data->widgets_data + dlg_data->number_of_widgets + -1;
      widget_data_00 != (widget_data *)((int)&dlg_data[-1].widgets_data[0].info + 0x10);
      widget_data_00 = widget_data_00 + -1) {
    display_widget(dlg_data,widget_data_00);
  }
  redraw_from_window(dlg_data->win);
  return;
}



// WARNING: Unknown calling convention

void do_refresh_dialog(dialog_data *dlg_data)

{
  dialog_refresh *pdVar1;
  dlg_refresh_code dVar2;
  dlg_refresh_code refresh_code;
  dialog_refresh *refresh;
  
  pdVar1 = dlg_data->dlg->refresh;
  if (assert_failed == 0) {
    if ((pdVar1 == (dialog_refresh *)0x0) || (pdVar1->handler == (dialog_refresh_handler_T)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
      errline = 0x2ad;
      elinks_internal((uchar *)"assertion refresh && refresh->handler failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  dVar2 = (*pdVar1->handler)(dlg_data,pdVar1->data);
  if ((dVar2 == REFRESH_STOP) || (dVar2 == REFRESH_CANCEL)) {
    pdVar1->timer = (timer_id_T)0x0;
    if (dVar2 == REFRESH_CANCEL) {
      delete_window(dlg_data->win);
      return;
    }
  }
  else {
    if (dVar2 == REFRESH_DIALOG) {
      redraw_dialog(dlg_data,1);
    }
    install_timer(&pdVar1->timer,100,do_refresh_dialog,dlg_data);
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T clear_dialog(dialog_data *dlg_data,widget_data *xxx)

{
  widget_handler_T *pwVar1;
  int iVar2;
  widget_data *widget_data;
  widget_data *pwVar3;
  
  iVar2 = dlg_data->number_of_widgets;
  pwVar3 = dlg_data->widgets_data;
  if (pwVar3 != dlg_data->widgets_data + iVar2) {
    do {
      pwVar1 = pwVar3->widget->ops->clear;
      if (pwVar1 != (widget_handler_T *)0x0) {
        (*pwVar1)(dlg_data,pwVar3);
        iVar2 = dlg_data->number_of_widgets;
      }
      pwVar3 = pwVar3 + 1;
    } while (dlg_data->widgets_data + iVar2 != pwVar3);
  }
  select_widget_by_id(dlg_data,0);
  redraw_dialog(dlg_data,0);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

int check_dialog(dialog_data *dlg_data)

{
  widget_handler_T *pwVar1;
  widget_handler_status_T wVar2;
  int iVar3;
  widget_data *widget_data;
  widget_data *widget_data_00;
  
  iVar3 = dlg_data->number_of_widgets;
  widget_data_00 = dlg_data->widgets_data;
  if (widget_data_00 != dlg_data->widgets_data + iVar3) {
    do {
      if ((widget_data_00->widget->type < WIDGET_BUTTON) &&
         (pwVar1 = widget_data_00->widget->handler, pwVar1 != (widget_handler_T *)0x0)) {
        wVar2 = (*pwVar1)(dlg_data,widget_data_00);
        if (wVar2 == EVENT_NOT_PROCESSED) {
          select_widget(dlg_data,widget_data_00);
          redraw_dialog(dlg_data,0);
          return 1;
        }
        iVar3 = dlg_data->number_of_widgets;
      }
      widget_data_00 = widget_data_00 + 1;
    } while (dlg_data->widgets_data + iVar3 != widget_data_00);
  }
  return 0;
}



// WARNING: Unknown calling convention

widget_handler_status_T ok_dialog(dialog_data *dlg_data,widget_data *widget_data)

{
  done_handler_T *pdVar1;
  void *pvVar2;
  int iVar3;
  widget_handler_status_T wVar4;
  done_handler_T *done;
  void *done_data;
  
  pdVar1 = (widget_data->widget->info).button.done;
  pvVar2 = (widget_data->widget->info).button.done_data;
  iVar3 = check_dialog(dlg_data);
  wVar4 = EVENT_NOT_PROCESSED;
  if (iVar3 == 0) {
    update_dialog_data(dlg_data);
    if (pdVar1 != (done_handler_T *)0x0) {
      (*pdVar1)(pvVar2);
    }
    delete_window(dlg_data->win);
    wVar4 = EVENT_PROCESSED;
  }
  return wVar4;
}



// WARNING: Unknown calling convention

dialog_data * do_dialog(terminal *term,dialog *dlg,memory_list *ml)

{
  int iVar1;
  dialog_data *data;
  dialog_data *dlg_data;
  
  data = (dialog_data *)mem_calloc(1,dlg->number_of_widgets * 0x30 + 0x58);
  if (data == (dialog_data *)0x0) {
    freeml(ml);
  }
  else {
    data->dlg = dlg;
    iVar1 = dlg->number_of_widgets;
    data->ml = ml;
    data->number_of_widgets = iVar1;
    add_window(term,dialog_func,data);
  }
  return data;
}



// WARNING: Unknown calling convention

void dialog_func(window *win,term_event *ev)

{
  void **ppvVar1;
  input_history_entry *piVar2;
  dialog_data *dlg_data_00;
  _func_widget_handler_status_T_dialog_data_ptr *p_Var3;
  widget_handler_T *pwVar4;
  term_event *ev_00;
  widget_ops *pwVar5;
  size_t size;
  dialog_refresh *p_00;
  void **p_01;
  void **ppvVar6;
  int iVar7;
  void **ppvVar8;
  widget_handler_status_T wVar9;
  term_event *ev_1;
  action_id_T aVar10;
  unicode_val_T uVar11;
  int iVar12;
  uchar *puVar13;
  unicode_val_T uVar14;
  term_event_char_T hk_char;
  widget *pwVar15;
  dialog *pdVar16;
  void *p;
  widget_data *widget_data_2;
  int hk_pos;
  int iVar17;
  widget_data *widget_data_5;
  widget_data *pwVar18;
  dialog_data *dlg_data;
  int i;
  widget_data *widget_data;
  xlist_head *head;
  widget_ops *ops;
  widget_data *widget_data_4;
  widget_data *pwVar19;
  byte bVar20;
  uchar *local_20 [4];
  
  bVar20 = 0;
  dlg_data_00 = (dialog_data *)win->data;
  dlg_data_00->win = win;
  dlg_data_00->term_event = ev;
  p_Var3 = dlg_data_00->dlg->handle_event;
  if (((p_Var3 == (_func_widget_handler_status_T_dialog_data_ptr *)0x0) ||
      (wVar9 = (*p_Var3)(dlg_data_00), wVar9 != EVENT_PROCESSED)) && (ev->ev < 6)) {
    switch(ev->ev) {
    case EVENT_INIT:
      iVar17 = dlg_data_00->number_of_widgets + -1;
      if (-1 < iVar17) {
        pwVar18 = dlg_data_00->widgets_data + dlg_data_00->number_of_widgets + -1;
        do {
          pwVar19 = dlg_data_00->widgets_data + iVar17;
          for (iVar12 = 0xc; iVar12 != 0; iVar12 = iVar12 + -1) {
            pwVar19->widget = (widget *)0x0;
            pwVar19 = (widget_data *)((int)pwVar19 + ((uint)bVar20 * -2 + 1) * 4);
          }
          pdVar16 = dlg_data_00->dlg;
          pwVar15 = pdVar16->widgets + iVar17;
          pwVar18->widget = pwVar15;
          size = pdVar16->widgets[iVar17].datalen;
          if (size == 0) {
LAB_0805bd0c:
            pwVar15->ops = widget_type_to_ops[pwVar15->type];
            pwVar15 = pwVar18->widget;
            if ((pwVar15->type == WIDGET_FIELD) &&
               ((pwVar15->info).field.history != (input_history *)0x0)) {
              piVar2 = (input_history_entry *)((int)&dlg_data_00->widgets_data[iVar17].info + 8);
              (pwVar18->info).field.history.prev = piVar2;
              (pwVar18->info).field.history.next = piVar2;
              (pwVar18->info).field.cur_hist = piVar2;
            }
            pwVar4 = pwVar15->ops->init;
            if (pwVar4 != (widget_handler_T *)0x0) {
              (*pwVar4)(dlg_data_00,dlg_data_00->widgets_data + iVar17);
              pwVar15 = pwVar18->widget;
            }
            if ((pwVar15->type != WIDGET_LISTBOX) &&
               ((pwVar15->type != WIDGET_TEXT ||
                (((((*(byte *)((int)&pwVar15->info + 4) & 2) != 0 &&
                   (iVar12 = (pwVar18->box).height, 0 < iVar12)) &&
                  (iVar7 = (pwVar18->info).field.cpos, 0 < iVar7)) && (iVar12 < iVar7)))))) {
              dlg_data_00->selected_widget_id = iVar17;
            }
          }
          else {
            puVar13 = (uchar *)mem_alloc(size);
            pwVar18->cdata = puVar13;
            if (puVar13 != (uchar *)0x0) {
              memcpy(puVar13,pwVar18->widget->data,pwVar18->widget->datalen);
              pwVar15 = pwVar18->widget;
              goto LAB_0805bd0c;
            }
          }
          pwVar18 = pwVar18 + -1;
          iVar17 = iVar17 + -1;
        } while (-1 < iVar17);
      }
    default:
      redraw_dialog(dlg_data_00,1);
      return;
    case EVENT_KBD:
      iVar17 = dlg_data_00->selected_widget_id;
      pwVar18 = dlg_data_00->widgets_data + iVar17;
      ev_00 = dlg_data_00->term_event;
      pwVar5 = (dlg_data_00->widgets_data[iVar17].widget)->ops;
      if ((pwVar5->kbd == (widget_handler_T *)0x0) ||
         (wVar9 = (*pwVar5->kbd)(dlg_data_00,pwVar18), wVar9 != EVENT_PROCESSED)) {
        aVar10 = kbd_action(KEYMAP_MENU,ev_00,(int *)0x0);
        switch(aVar10) {
        default:
          uVar11 = (dlg_data_00->term_event->info).mouse.x;
          if ((0x20 < (int)uVar11) &&
             ((iVar17 = (dlg_data_00->term_event->info).mouse.y, iVar17 == 4 || (iVar17 == 0)))) {
            pwVar18 = dlg_data_00->widgets_data;
            uVar11 = unicode_fold_label_case(uVar11);
            iVar12 = get_terminal_codepage(dlg_data_00->win->term);
            iVar17 = dlg_data_00->number_of_widgets;
            if (pwVar18 != dlg_data_00->widgets_data + iVar17) {
              do {
                if (pwVar18->widget->type == WIDGET_BUTTON) {
                  local_20[0] = pwVar18->widget->text;
                  if (*local_20[0] != '\0') {
                    iVar17 = (pwVar18->widget->info).checkbox.gnum;
                    if (-1 < iVar17) {
                      local_20[0] = local_20[0] + iVar17 + 1;
                    }
                    puVar13 = (uchar *)__rawmemchr(local_20[0],0);
                    uVar14 = cp_to_unicode(iVar12,local_20,puVar13);
                    if (assert_failed == 0) {
                      assert_failed = (int)(uVar14 == 0xfffffffd);
                      if (assert_failed != 0) {
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
                        errline = 0x149;
                        elinks_internal((uchar *)"assertion hk_char != UCS_NO_CHAR failed!");
                        if (assert_failed != 0) goto LAB_0805bfa8;
                      }
                      uVar14 = unicode_fold_label_case(uVar14);
                      if (uVar11 == uVar14) {
LAB_0805bf69:
                        select_dlg_item(dlg_data_00,pwVar18);
                        return;
                      }
                    }
                    else {
LAB_0805bfa8:
                      assert_failed = 0;
                    }
                  }
                  iVar17 = dlg_data_00->number_of_widgets;
                }
                pwVar18 = pwVar18 + 1;
              } while (pwVar18 != dlg_data_00->widgets_data + iVar17);
            }
          }
          break;
        case 2:
          for (pwVar18 = dlg_data_00->widgets_data;
              pwVar18 != dlg_data_00->widgets_data + dlg_data_00->number_of_widgets;
              pwVar18 = pwVar18 + 1) {
            if ((pwVar18->widget->type == WIDGET_BUTTON) &&
               ((*(byte *)&pwVar18->widget->info & 2) != 0)) goto LAB_0805bf69;
          }
          break;
        case 4:
        case 0xb:
        case 0x10:
          cycle_widget_focus(dlg_data_00,1);
          break;
        case 6:
          if (pwVar5->select == (widget_handler_T *)0x0) {
            if ((((dlg_data_00->widgets_data[iVar17].widget)->type + ~WIDGET_CHECKBOX < 2) ||
                (iVar17 = (ev_00->info).mouse.y, iVar17 == 2)) || (iVar17 == 4)) {
              for (pwVar18 = dlg_data_00->widgets_data;
                  pwVar18 != dlg_data_00->widgets_data + dlg_data_00->number_of_widgets;
                  pwVar18 = pwVar18 + 1) {
                if ((pwVar18->widget->type == WIDGET_BUTTON) &&
                   ((*(byte *)&pwVar18->widget->info & 1) != 0)) goto LAB_0805bf69;
              }
            }
          }
          else {
            (*pwVar5->select)(dlg_data_00,pwVar18);
          }
          break;
        case 9:
        case 0xe:
        case 0x14:
          cycle_widget_focus(dlg_data_00,-1);
          break;
        case 0xf:
          redraw_terminal_cls(dlg_data_00->win->term);
          break;
        case 0x12:
          if (pwVar5->select != (widget_handler_T *)0x0) {
            (*pwVar5->select)(dlg_data_00,pwVar18);
          }
        }
      }
      break;
    case EVENT_MOUSE:
      iVar17 = dlg_data_00->number_of_widgets;
      for (pwVar18 = dlg_data_00->widgets_data; pwVar18 != dlg_data_00->widgets_data + iVar17;
          pwVar18 = pwVar18 + 1) {
        pwVar4 = pwVar18->widget->ops->mouse;
        if (pwVar4 != (widget_handler_T *)0x0) {
          wVar9 = (*pwVar4)(dlg_data_00,pwVar18);
          if (wVar9 == EVENT_PROCESSED) {
            return;
          }
          iVar17 = dlg_data_00->number_of_widgets;
        }
      }
      break;
    case EVENT_ABORT:
      pdVar16 = dlg_data_00->dlg;
      p_00 = pdVar16->refresh;
      if (p_00 != (dialog_refresh *)0x0) {
        kill_timer(&p_00->timer);
        mem_free(p_00);
        pdVar16 = dlg_data_00->dlg;
      }
      if (pdVar16->abort != (_func_void_dialog_data_ptr *)0x0) {
        (*pdVar16->abort)(dlg_data_00);
      }
      pwVar18 = dlg_data_00->widgets_data;
      if (dlg_data_00->widgets_data + dlg_data_00->number_of_widgets != pwVar18) {
        do {
          if (pwVar18->cdata != (uchar *)0x0) {
            mem_free(pwVar18->cdata);
          }
          if ((pwVar18->widget->type == WIDGET_FIELD) &&
             ((pwVar18->widget->info).field.history != (input_history *)0x0)) {
            ppvVar1 = (void **)((int)&pwVar18->info + 8);
            p_01 = (void **)(pwVar18->info).field.history.next;
            for (ppvVar6 = p_01; ppvVar1 != ppvVar6; ppvVar6 = (void **)*ppvVar6) {
            }
            for (ppvVar6 = (void **)(pwVar18->info).text.scroller_height; ppvVar1 != ppvVar6;
                ppvVar6 = (void **)ppvVar6[1]) {
            }
            ppvVar6 = (void **)*p_01;
            while (ppvVar8 = ppvVar6, ppvVar1 != p_01) {
              ppvVar8[1] = p_01[1];
              *(void **)p_01[1] = *p_01;
              mem_free(p_01);
              ppvVar6 = (void **)*ppvVar8;
              p_01 = ppvVar8;
            }
          }
          pwVar18 = pwVar18 + 1;
        } while (pwVar18 != dlg_data_00->widgets_data + dlg_data_00->number_of_widgets);
      }
      freeml(dlg_data_00->ml);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention
// Local variable lb_1:int[Stack[0x10]:4] conflicts with parameter, skipped.

void dlg_format_group(terminal *term,widget_data *widget_data,int n,int x,int *y,int w,int *rw,
                     int format_only)

{
  uchar *string;
  color_pair *color;
  widget_type wVar1;
  size_t sVar2;
  int iVar3;
  int lb;
  int label_length;
  int iVar4;
  uchar *text;
  widget *pwVar5;
  int widget_width;
  int iVar6;
  size_t local_2c;
  uint local_28;
  int local_24;
  int local_20;
  
  color = get_bfu_color(term,"dialog.text");
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(n < 1);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/group.c";
    errline = 0x20;
    elinks_internal((uchar *)"assertion n > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  local_20 = 0;
  do {
    if (n == 0) {
      *y = *y + 1;
      return;
    }
    pwVar5 = widget_data->widget;
    string = pwVar5->text;
    if ((term->field_0x38 & 2) == 0) {
      if ((string == (uchar *)0x0) || (*string == '\0')) {
LAB_0805c095:
        local_28 = 0;
        label_length = 0;
        goto LAB_0805c09e;
      }
      label_length = strlen((char *)string);
      local_28 = (uint)(0 < label_length);
      wVar1 = pwVar5->type;
      local_24 = 3;
      if (wVar1 != WIDGET_CHECKBOX) goto LAB_0805c0ac;
LAB_0805c108:
      local_2c = 0;
      if ((-1 < label_length) &&
         (sVar2 = (w - local_24) - local_28, local_2c = label_length, (int)sVar2 <= label_length)) {
        local_2c = sVar2;
      }
      iVar4 = local_24 + local_28;
      iVar6 = local_2c + iVar4 + local_20;
      if (w < iVar6) {
        *y = *y + 2;
        local_20 = 0;
        iVar6 = local_2c + iVar4;
      }
      if (format_only == 0) {
        local_20 = local_20 + x;
        wVar1 = widget_data->widget->type;
        if (wVar1 == WIDGET_CHECKBOX) {
          if (local_2c != 0) {
            if ((term->field_0x38 & 2) == 0) {
              draw_text(term,iVar4 + local_20,*y,string,local_2c,0,color);
            }
            else {
              iVar3 = utf8_cells2bytes(string,local_2c,(uchar *)0x0);
              draw_text(term,iVar4 + local_20,*y,string,iVar3,0,color);
            }
          }
          iVar4 = *y;
          iVar3 = 0;
          if (-1 < local_20) {
            iVar3 = local_20;
          }
          (widget_data->box).x = iVar3;
          if (iVar4 < 0) {
            iVar4 = 0;
          }
          (widget_data->box).y = iVar4;
          iVar4 = 0;
          if (-1 < local_24) {
            iVar4 = local_24;
          }
          (widget_data->box).height = 1;
          (widget_data->box).width = iVar4;
        }
        else if (wVar1 + ~WIDGET_CHECKBOX < 2) {
          if (local_2c != 0) {
            if ((term->field_0x38 & 2) == 0) {
              draw_text(term,local_20,*y,string,local_2c,0,color);
            }
            else {
              iVar4 = utf8_cells2bytes(string,local_2c,(uchar *)0x0);
              draw_text(term,local_20,*y,string,iVar4,0,color);
            }
          }
          local_20 = local_2c + local_28 + local_20;
          iVar4 = *y;
          if (local_20 < 0) {
            local_20 = 0;
          }
          (widget_data->box).x = local_20;
          iVar3 = 0;
          if (-1 < iVar4) {
            iVar3 = iVar4;
          }
          (widget_data->box).y = iVar3;
          iVar4 = 0;
          if (-1 < local_24) {
            iVar4 = local_24;
          }
          (widget_data->box).height = 1;
          (widget_data->box).width = iVar4;
        }
      }
      if (rw != (int *)0x0) {
        if (*rw < iVar6) {
          *rw = iVar6;
        }
        else if (w < *rw) {
          *rw = w;
        }
      }
      local_20 = iVar6 + 1;
    }
    else {
      if ((string == (uchar *)0x0) || (*string == '\0')) goto LAB_0805c095;
      label_length = utf8_ptr2cells(string,(uchar *)0x0);
      local_28 = (uint)(0 < label_length);
      pwVar5 = widget_data->widget;
LAB_0805c09e:
      wVar1 = pwVar5->type;
      local_24 = 3;
      if (wVar1 == WIDGET_CHECKBOX) goto LAB_0805c108;
LAB_0805c0ac:
      if (wVar1 + ~WIDGET_CHECKBOX < 2) {
        if ((term->field_0x38 & 2) == 0) {
          local_24 = pwVar5->datalen;
        }
        else {
          local_24 = utf8_ptr2cells((uchar *)pwVar5->data,(uchar *)0x0);
        }
        goto LAB_0805c108;
      }
    }
    n = n + -1;
    widget_data = widget_data + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void group_layouter(dialog_data *dlg_data)

{
  terminal *term_00;
  int iVar1;
  int n;
  size_t sVar2;
  size_t sVar3;
  terminal *term;
  int w;
  size_t sVar4;
  int local_24;
  size_t local_20 [4];
  
  term_00 = dlg_data->win->term;
  sVar3 = (term_00->width * 9) / 10 - 0xc;
  sVar4 = 1;
  if (0 < (int)sVar3) {
    sVar2 = term_00->width - 0xc;
    if (0 < (int)sVar2) {
      sVar4 = sVar2;
    }
    if ((int)sVar3 <= (int)sVar4) {
      sVar4 = sVar3;
    }
  }
  local_24 = 0;
  iVar1 = dlg_data->number_of_widgets;
  n = iVar1 + -2;
  if ((term_00->field_0x38 & 2) == 0) {
    local_20[0] = strlen((char *)dlg_data->dlg->title);
    if ((int)sVar4 < (int)local_20[0]) {
      local_20[0] = sVar4;
    }
  }
  else {
    local_20[0] = utf8_ptr2cells(dlg_data->dlg->title,(uchar *)0x0);
    if ((int)sVar4 < (int)local_20[0]) {
      local_20[0] = sVar4;
    }
  }
  dlg_format_group(term_00,dlg_data->widgets_data,n,0,&local_24,sVar4,(int *)local_20,1);
  local_24 = local_24 + 1;
  dlg_format_buttons(term_00,dlg_data->widgets_data + iVar1 + -2,2,0,&local_24,sVar4,(int *)local_20
                     ,ALIGN_CENTER,1);
  sVar4 = local_20[0];
  draw_dialog(dlg_data,local_20[0],local_24);
  local_24 = (dlg_data->box).y + 3;
  dlg_format_group(term_00,dlg_data->widgets_data,n,(dlg_data->box).x + 6,&local_24,sVar4,(int *)0x0
                   ,0);
  local_24 = local_24 + 1;
  dlg_format_buttons(term_00,dlg_data->widgets_data + iVar1 + -2,2,(dlg_data->box).x + 6,&local_24,
                     sVar4,(int *)local_20,ALIGN_CENTER,0);
  return;
}



// WARNING: Unknown calling convention

void recursively_set_expanded(listbox_item *item,int expanded)

{
  listbox_item *item_00;
  listbox_item *child;
  
  if (item->type == BI_FOLDER) {
    item_00 = (listbox_item *)(item->child).next;
    item->field_0x18 = item->field_0x18 & 0xfe | (byte)expanded & 1;
    for (; item_00 != (listbox_item *)&item->child; item_00 = item_00->next) {
      recursively_set_expanded(item_00,expanded);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int scan_for_marks(listbox_item *item,void *info_,int *offset)

{
  if ((item->field_0x18 & 4) != 0) {
    *(undefined4 *)((int)info_ + 4) = 0;
    *offset = 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

int scan_for_used(listbox_item *item,void *info_,int *offset)

{
  int iVar1;
  
  iVar1 = (**(code **)(*(int *)(*(int *)((int)info_ + 8) + 8) + 8))(item);
  if (iVar1 != 0) {
    *(listbox_item **)((int)info_ + 4) = item;
    *offset = 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

void done_listbox_context(void *context_)

{
  if (*(int *)((int)context_ + 4) != 0) {
                    // WARNING: Could not recover jumptable at 0x0805c70d. Too many branches
                    // WARNING: Treating indirect jump as call
    (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 4))();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int scan_for_matches(listbox_item *item,void *info_,int *offset)

{
  uchar *text;
  int iVar1;
  
  if (**(char **)((int)info_ + 0x10) != '\0') {
                    // WARNING: Load size is inaccurate
    iVar1 = (**(code **)(*(int *)(*(int *)((int)info_ + 8) + 8) + 0x1c))
                      (item,*info_,*(char **)((int)info_ + 0x10));
    if (iVar1 != 0) {
      if (iVar1 != 1) {
        return 0;
      }
      item->field_0x18 = item->field_0x18 & 0xfd;
      return 0;
    }
    *(listbox_item **)((int)info_ + 4) = item;
  }
  item->field_0x18 = item->field_0x18 | 2;
  return 0;
}



// WARNING: Unknown calling convention

int mark_visible(listbox_item *item,void *xxx,int *offset)

{
  item->field_0x18 = item->field_0x18 | 2;
  return 0;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_hierbox_search_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term_00;
  listbox_data *plVar1;
  listbox_data *box;
  terminal *term;
  bool bVar2;
  
  term_00 = dlg_data->win->term;
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  if (plVar1->sel != (listbox_item *)0x0) {
    if ((assert_failed == 0) &&
       (bVar2 = plVar1->ops->match ==
                (_func_listbox_match_listbox_item_ptr_terminal_ptr_uchar_ptr *)0x0,
       assert_failed = (int)bVar2, bVar2)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x3ce;
      elinks_internal((uchar *)"assertion box->ops->match failed!");
    }
    input_dialog(term_00,(memory_list *)0x0,"Search","Name",dlg_data,(input_history *)0x0,0x400,"",0
                 ,0,(widget_handler_T *)0x0,search_hierbox_browser,(done_handler_T *)0x0);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void do_clear_browser(void *context_)

{
  traverse_listbox_items_list
            ((listbox_item *)(*(listbox_data **)((int)context_ + 8))->items->next,
             *(listbox_data **)((int)context_ + 8),0,0,delete_unused,context_);
  return;
}



// WARNING: Unknown calling convention

listbox_context *
init_listbox_context
          (listbox_data *box,terminal *term,listbox_item *item,
          _func_int_listbox_item_ptr_void_ptr_int_ptr *scanner)

{
  list_head_elinks *plVar1;
  listbox_context *d;
  listbox_context *context;
  bool bVar2;
  
  d = (listbox_context *)mem_calloc(1,0x1c);
  if (d != (listbox_context *)0x0) {
    d->item = item;
    d->term = term;
    d->box = box;
    if (scanner != (_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0) {
      if ((assert_failed == 0) &&
         (plVar1 = box->items, bVar2 = plVar1 == (list_head_elinks *)plVar1->next,
         assert_failed = (int)bVar2, bVar2)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 0x185;
        elinks_internal((uchar *)"assertion !list_empty(*box->items) failed!");
      }
      traverse_listbox_items_list((listbox_item *)box->items->next,box,0,0,scanner,d);
    }
  }
  return d;
}



// WARNING: Unknown calling convention

void search_hierbox_browser(void *data,uchar *text)

{
  terminal *term_00;
  listbox_data *box_00;
  listbox_context *d;
  listbox_context *context;
  option_value *poVar1;
  uchar *text_00;
  listbox_data *box;
  terminal *term;
  
  box_00 = get_listbox_widget_data((widget_data *)((int)data + 0x28));
                    // WARNING: Load size is inaccurate
  term_00 = *(terminal **)(*data + 0x14);
  d = init_listbox_context
                (box_00,term_00,(listbox_item *)0x0,
                 (_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0);
  if (d != (listbox_context *)0x0) {
    d->widget_data = (widget_data *)text;
    traverse_listbox_items_list((listbox_item *)box_00->items->next,box_00,0,0,scan_for_matches,d);
    if ((d->item == (listbox_item *)0x0) && (*text != '\0')) {
      poVar1 = get_opt_();
      if (poVar1->tree == (list_head_elinks *)0x1) {
        beep_terminal(term_00);
      }
      else if (poVar1->tree == (list_head_elinks *)0x2) {
        text_00 = msg_text(term_00,(uchar *)"Search string \'%s\' not found",text);
        info_box(term_00,MSGBOX_FREE_TEXT,"Search",ALIGN_CENTER,text_00);
      }
      traverse_listbox_items_list
                ((listbox_item *)box_00->items->next,box_00,0,0,mark_visible,(void *)0x0);
    }
    mem_free(d);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_hierbox_info_button(dialog_data *dlg_data,widget_data *button)

{
  listbox_item *item_00;
  terminal *term_00;
  listbox_data *box_00;
  listbox_data *box;
  listbox_context *p;
  uchar *text;
  uchar *msg;
  memory_list *ml;
  listbox_item *item;
  terminal *term;
  
  box_00 = get_listbox_widget_data(dlg_data->widgets_data);
  item_00 = box_00->sel;
  term_00 = dlg_data->win->term;
  if (item_00 != (listbox_item *)0x0) {
    if ((assert_failed == 0) &&
       (assert_failed = (int)(box_00->ops == (listbox_ops *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x1a4;
      elinks_internal((uchar *)"assertion box->ops failed!");
    }
    p = init_listbox_context
                  (box_00,term_00,item_00,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0);
    if (p != (listbox_context *)0x0) {
      text = (*box_00->ops->get_info)(item_00,term_00);
      if (text == (uchar *)0x0) {
        mem_free(p);
        if (item_00->type == BI_FOLDER) {
          info_box(term_00,0,"Info",ALIGN_CENTER,(uchar *)"Press space to expand this folder.");
        }
      }
      else {
        (*box_00->ops->lock)(item_00);
        ml = getml(p,0);
        msg_box(term_00,ml,MSGBOX_FREE_TEXT,"Info",ALIGN_LEFT,text,p,1,&DAT_081275e4,
                done_listbox_context,3);
      }
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void print_delete_error(listbox_item *item,terminal *term,listbox_ops *ops,delete_error err)

{
  uchar *puVar1;
  string *psVar2;
  int cp_index;
  int new_charset;
  uchar *codeset;
  char *msgid;
  uchar *info;
  uchar *errmsg;
  string msg;
  
  if (err == DELETE_IMPOSSIBLE) {
    if (item->type == BI_FOLDER) {
      if ((ops->messages == (listbox_ops_messages *)0x0) ||
         (msgid = (char *)ops->messages->cant_delete_folder, (uchar *)msgid == (uchar *)0x0)) {
        msgid = "Sorry, but the folder \"%s\" cannot be deleted.";
      }
    }
    else if ((ops->messages == (listbox_ops_messages *)0x0) ||
            (msgid = (char *)ops->messages->cant_delete_item, (uchar *)msgid == (uchar *)0x0)) {
      msgid = "Sorry, but the item \"%s\" cannot be deleted.";
    }
  }
  else {
    if (err != DELETE_LOCKED) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x26b;
      elinks_internal((uchar *)"Bad delete error code (%d)!",err);
      return;
    }
    if (item->type == BI_FOLDER) {
      if ((ops->messages == (listbox_ops_messages *)0x0) ||
         (msgid = (char *)ops->messages->cant_delete_used_folder, (uchar *)msgid == (uchar *)0x0)) {
        msgid = "Sorry, but the folder \"%s\" is being used by something else.";
      }
    }
    else if ((ops->messages == (listbox_ops_messages *)0x0) ||
            (msgid = (char *)ops->messages->cant_delete_used_item, (uchar *)msgid == (uchar *)0x0))
    {
      msgid = "Sorry, but the item \"%s\" is being used by something else.";
    }
  }
  puVar1 = (*ops->get_text)(item,term);
  if (puVar1 != (uchar *)0x0) {
    psVar2 = init_string(&msg);
    if (psVar2 == (string *)0x0) {
      mem_free(puVar1);
    }
    else {
      if (((uchar *)msgid != (uchar *)0x0) && (*msgid != '\0')) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      add_format_to_string(&msg,(uchar *)msgid,puVar1);
      mem_free(puVar1);
      if ((item->type == BI_LEAF) && (puVar1 = (*ops->get_info)(item,term), puVar1 != (uchar *)0x0))
      {
        add_format_to_string(&msg,"\n\n%s",puVar1);
        mem_free(puVar1);
      }
      info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Delete error",ALIGN_LEFT,msg.source);
    }
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_hierbox_clear_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term_00;
  listbox_ops *ops_00;
  listbox_ops_messages *plVar1;
  listbox_data *box_00;
  listbox_data *box;
  listbox_context *p;
  listbox_context *context;
  memory_list *ml;
  char *title;
  terminal *term;
  listbox_ops *ops;
  char *text;
  
  box_00 = get_listbox_widget_data(dlg_data->widgets_data);
  term_00 = dlg_data->win->term;
  ops_00 = box_00->ops;
  if (box_00->sel == (listbox_item *)0x0) {
    return EVENT_PROCESSED;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(ops_00 == (listbox_ops *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x359;
    elinks_internal((uchar *)"assertion ops failed!");
  }
  p = init_listbox_context(box_00,term_00,(listbox_item *)0x0,scan_for_used);
  if (p == (listbox_context *)0x0) {
    return EVENT_PROCESSED;
  }
  if (p->item != (listbox_item *)0x0) {
    print_delete_error(p->item,term_00,ops_00,DELETE_LOCKED);
    mem_free(p);
    return EVENT_PROCESSED;
  }
  plVar1 = ops_00->messages;
  if (plVar1 == (listbox_ops_messages *)0x0) {
    text = "Do you really want to remove all items?";
  }
  else {
    text = (char *)plVar1->clear_all_items;
    title = (char *)plVar1->clear_all_items_title;
    if ((uchar *)text == (uchar *)0x0) {
      text = "Do you really want to remove all items?";
    }
    if ((uchar *)title != (uchar *)0x0) goto LAB_0805cf42;
  }
  title = "Clear all items";
LAB_0805cf42:
  ml = getml(p,0);
  msg_box(term_00,ml,0,(uchar *)title,ALIGN_CENTER,(uchar *)text,p,2,&DAT_0812762b,do_clear_browser,
          1,&DAT_08127627,0,2);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void do_delete_item(listbox_item *item,listbox_context *info,int last)

{
  listbox_ops *ops_00;
  int iVar1;
  listbox_ops *ops;
  
  ops_00 = info->box->ops;
  if ((assert_failed == 0) &&
     (assert_failed = (int)(item == (listbox_item *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x28c;
    elinks_internal((uchar *)"assertion item failed!");
  }
  iVar1 = (*ops_00->can_delete)(item);
  if (iVar1 == 0) {
    print_delete_error(item,info->term,ops_00,DELETE_IMPOSSIBLE);
  }
  else {
    iVar1 = (*ops_00->is_used)(item);
    if (iVar1 == 0) {
      (*ops_00->delete)(item,last);
    }
    else {
      print_delete_error(item,info->term,ops_00,DELETE_LOCKED);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int delete_unused(listbox_item *item,void *data_,int *offset)

{
  int iVar1;
  
  iVar1 = (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 8))(item);
  if (iVar1 == 0) {
    do_delete_item(item,(listbox_context *)data_,0);
  }
  return (uint)(iVar1 == 0);
}



// WARNING: Unknown calling convention

int delete_marked(listbox_item *item,void *data_,int *offset)

{
  int iVar1;
  
  if (((item->field_0x18 & 4) != 0) &&
     (iVar1 = (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 8))(item), iVar1 == 0)) {
    if (*(int *)((int)data_ + 4) == 0) {
      *(listbox_item **)((int)data_ + 4) = item;
      return 1;
    }
    do_delete_item(item,(listbox_context *)data_,0);
    return 1;
  }
  return 0;
}



// WARNING: Unknown calling convention

widget_handler_status_T query_delete_selected_item(void *context_)

{
  terminal *term;
  listbox_data *box;
  listbox_ops *ops_00;
  listbox_item *item_00;
  int iVar1;
  int iVar2;
  listbox_context *p;
  uchar *p_00;
  uchar *p_01;
  uchar *msg;
  uchar *puVar3;
  memory_list *pmVar4;
  delete_error delete;
  listbox_item *item;
  char *pcVar5;
  listbox_ops *ops;
  listbox_context *oldcontext;
  uchar *text;
  
                    // WARNING: Load size is inaccurate
  term = *context_;
  box = *(listbox_data **)((int)context_ + 8);
  ops_00 = box->ops;
  item_00 = box->sel;
  if ((assert_failed == 0) &&
     (assert_failed = (int)(item_00 == (listbox_item *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x2d8;
    elinks_internal((uchar *)"assertion item failed!");
  }
  iVar1 = (*ops_00->can_delete)(item_00);
  if (((iVar1 != 0) == DELETE_IMPOSSIBLE) || (iVar2 = (*ops_00->is_used)(item_00), iVar2 != 0)) {
    print_delete_error(item_00,term,ops_00,(uint)(iVar1 != 0));
    return EVENT_PROCESSED;
  }
  p = init_listbox_context(box,term,item_00,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0);
  if (p == (listbox_context *)0x0) {
    return EVENT_PROCESSED;
  }
  p->widget_data = *(widget_data **)((int)context_ + 0x10);
  p_00 = (*ops_00->get_text)(item_00,term);
  if (p_00 == (uchar *)0x0) {
    mem_free(p);
    return EVENT_PROCESSED;
  }
  if (item_00->type == BI_FOLDER) {
    (*ops_00->lock)(item_00);
    if ((ops_00->messages == (listbox_ops_messages *)0x0) ||
       (pcVar5 = (char *)ops_00->messages->delete_folder, (uchar *)pcVar5 == (uchar *)0x0)) {
      pcVar5 = "Delete the folder \"%s\" and its content?";
    }
    puVar3 = msg_text(term,(uchar *)pcVar5,p_00);
    if ((ops_00->messages == (listbox_ops_messages *)0x0) ||
       (pcVar5 = (char *)ops_00->messages->delete_folder_title, (uchar *)pcVar5 == (uchar *)0x0)) {
      pcVar5 = "Delete folder";
    }
    pmVar4 = getml(p,0);
    msg_box(term,pmVar4,MSGBOX_FREE_TEXT,(uchar *)pcVar5,ALIGN_CENTER,puVar3,p,2,&DAT_0812762b,
            push_ok_delete_button,1,&DAT_08127627,done_listbox_context,2);
  }
  else {
    p_01 = (*ops_00->get_info)(item_00,term);
    (*ops_00->lock)(item_00);
    puVar3 = "";
    if (p_01 != (uchar *)0x0) {
      puVar3 = p_01;
    }
    if ((ops_00->messages == (listbox_ops_messages *)0x0) ||
       (pcVar5 = (char *)ops_00->messages->delete_item, (uchar *)pcVar5 == (uchar *)0x0)) {
      pcVar5 = "Delete \"%s\"?\n\n%s";
    }
    puVar3 = msg_text(term,(uchar *)pcVar5,p_00,puVar3);
    if ((ops_00->messages == (listbox_ops_messages *)0x0) ||
       (pcVar5 = (char *)ops_00->messages->delete_item_title, (uchar *)pcVar5 == (uchar *)0x0)) {
      pcVar5 = "Delete item";
    }
    pmVar4 = getml(p,0);
    msg_box(term,pmVar4,MSGBOX_FREE_TEXT,(uchar *)pcVar5,ALIGN_LEFT,puVar3,p,2,&DAT_0812762b,
            push_ok_delete_button,1,&DAT_08127627,done_listbox_context,2);
    if (p_01 != (uchar *)0x0) {
      mem_free(p_01);
    }
  }
  mem_free(p_00);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_hierbox_delete_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term_00;
  listbox_item *item_00;
  listbox_ops *plVar1;
  listbox_ops_messages *plVar2;
  listbox_data *box_00;
  listbox_data *box;
  listbox_context *p;
  listbox_context *context;
  widget_handler_status_T wVar3;
  memory_list *ml;
  widget_handler_status_T status;
  listbox_item *item;
  char *text;
  listbox_ops *ops;
  char *title;
  terminal *term;
  
  term_00 = dlg_data->win->term;
  box_00 = get_listbox_widget_data(dlg_data->widgets_data);
  item_00 = box_00->sel;
  plVar1 = box_00->ops;
  if (item_00 == (listbox_item *)0x0) {
    return EVENT_PROCESSED;
  }
  if (assert_failed == 0) {
    if (((plVar1 == (listbox_ops *)0x0) || (plVar1->can_delete == (_func_int_listbox_item_ptr *)0x0)
        ) || (plVar1->delete == (_func_void_listbox_item_ptr_int *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x31a;
      elinks_internal((uchar *)"assertion ops && ops->can_delete && ops->delete failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  p = init_listbox_context(box_00,term_00,item_00,scan_for_marks);
  if (p == (listbox_context *)0x0) {
    return EVENT_PROCESSED;
  }
  p->widget_data = dlg_data->widgets_data;
  if (p->item != (listbox_item *)0x0) {
    wVar3 = query_delete_selected_item(p);
    mem_free(p);
    return wVar3;
  }
  plVar2 = plVar1->messages;
  if (plVar2 == (listbox_ops_messages *)0x0) {
    text = "Delete marked items?";
  }
  else {
    text = (char *)plVar2->delete_marked_items;
    title = (char *)plVar2->delete_marked_items_title;
    if ((uchar *)text == (uchar *)0x0) {
      text = "Delete marked items?";
    }
    if ((uchar *)title != (uchar *)0x0) goto LAB_0805d522;
  }
  title = "Delete marked items";
LAB_0805d522:
  ml = getml(p,0);
  msg_box(term_00,ml,0,(uchar *)title,ALIGN_CENTER,(uchar *)text,p,2,&DAT_0812762b,
          push_ok_delete_button,1,&DAT_08127627,dont_delete_marked_items,2);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void dont_delete_marked_items(void *context_)

{
  query_delete_selected_item(context_);
  return;
}



// WARNING: Unknown calling convention

void push_ok_delete_button(void *context_)

{
  listbox_item *item;
  listbox_item *plVar1;
  int iVar2;
  listbox_item *root;
  listbox_context *context;
  
  if (*(int *)((int)context_ + 4) == 0) {
    traverse_listbox_items_list
              ((listbox_item *)(*(listbox_data **)((int)context_ + 8))->items->next,
               *(listbox_data **)((int)context_ + 8),0,0,delete_marked,context_);
    if (*(int *)((int)context_ + 4) == 0) {
      return;
    }
    iVar2 = (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 0x18))
                      (*(int *)((int)context_ + 4));
  }
  else {
    (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 4))(*(int *)((int)context_ + 4));
    iVar2 = (**(code **)(*(int *)(*(int *)((int)context_ + 8) + 8) + 0x18))
                      (*(undefined4 *)((int)context_ + 4));
  }
  if (iVar2 != 0) {
    item = *(listbox_item **)((int)context_ + 4);
    plVar1 = *(listbox_item **)(iVar2 + 0xc);
    do_delete_item(item,(listbox_context *)context_,1);
    if (item == plVar1) {
      listbox_sel_move(*(widget_data **)((int)context_ + 0x10),-1);
    }
    return;
  }
  do_delete_item(*(listbox_item **)((int)context_ + 4),(listbox_context *)context_,1);
  return;
}



// WARNING: Unknown calling convention

void recursively_goto_listbox(session *ses,listbox_item *item,listbox_data *box)

{
  listbox_item *item_00;
  uri *uri_00;
  uri *uri;
  
  if (item->type == BI_FOLDER) {
    for (item_00 = (listbox_item *)(item->child).next; item_00 != (listbox_item *)&item->child;
        item_00 = item_00->next) {
      recursively_goto_listbox(ses,item_00,box);
    }
  }
  else if ((item->type == BI_LEAF) && (uri_00 = (*box->ops->get_uri)(item), uri_00 != (uri *)0x0)) {
    open_uri_in_new_tab(ses,uri_00,1,0);
    done_uri(uri_00);
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_hierbox_goto_button(dialog_data *dlg_data,widget_data *button)

{
  listbox_item *item_00;
  session *ses;
  listbox_item *item_01;
  listbox_data *box_00;
  listbox_context *d;
  uri *uri_00;
  uri *uri;
  terminal *term;
  listbox_item *item;
  listbox_data *box;
  
  box_00 = get_listbox_widget_data(dlg_data->widgets_data);
  item_00 = box_00->sel;
  ses = (session *)dlg_data->dlg->udata;
  if ((item_00 != (listbox_item *)0x0) &&
     (d = init_listbox_context(box_00,dlg_data->win->term,item_00,scan_for_marks),
     d != (listbox_context *)0x0)) {
    if (d->item == (listbox_item *)0x0) {
      d->dlg_data = dlg_data;
      traverse_listbox_items_list((listbox_item *)d->box->items->next,d->box,0,0,goto_marked,d);
    }
    else if (item_00->type == BI_FOLDER) {
      for (item_01 = (listbox_item *)(item_00->child).next;
          item_01 != (listbox_item *)&item_00->child; item_01 = item_01->next) {
        recursively_goto_listbox(ses,item_01,box_00);
      }
    }
    else {
      if (item_00->type != BI_LEAF) {
        mem_free(d);
        return EVENT_PROCESSED;
      }
      uri_00 = (*box_00->ops->get_uri)(item_00);
      if (uri_00 != (uri *)0x0) {
        goto_uri(ses,uri_00);
        done_uri(uri_00);
      }
    }
    mem_free(d);
    delete_window(dlg_data->win);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

int goto_marked(listbox_item *item,void *data_,int *offset)

{
  if ((item->field_0x18 & 4) != 0) {
    recursively_goto_listbox
              (*(session **)(*(int *)(*(int *)((int)data_ + 0xc) + 4) + 4),item,
               *(listbox_data **)((int)data_ + 8));
  }
  return 0;
}



// WARNING: Unknown calling convention

widget_handler_status_T hierbox_dialog_event_handler(dialog_data *dlg_data)

{
  widget_data *widget_data_00;
  term_event *ev_00;
  term_event_type tVar1;
  void *pvVar2;
  int iVar3;
  undefined4 *puVar4;
  widget_handler_T *pwVar5;
  int **p;
  code *pcVar6;
  int *piVar7;
  listbox_item *litem;
  hierbox_dialog_list_item *item;
  widget_handler_status_T wVar8;
  uint uVar9;
  listbox_data *plVar10;
  listbox_data *box;
  listbox_item *root;
  listbox_item *plVar11;
  listbox_data *box_1;
  term_event *ev;
  hierbox_browser *browser_1;
  hierbox_browser *browser;
  widget_data *widget_data;
  listbox_item *selected;
  
  ev_00 = dlg_data->term_event;
  tVar1 = ev_00->ev;
  if (tVar1 == EVENT_KBD) {
    widget_data_00 = dlg_data->widgets_data;
    pvVar2 = dlg_data->dlg->udata2;
    pwVar5 = (dlg_data->widgets_data[0].widget)->ops->kbd;
    if ((pwVar5 != (widget_handler_T *)0x0) &&
       (wVar8 = (*pwVar5)(dlg_data,widget_data_00), wVar8 == EVENT_PROCESSED)) {
      return EVENT_PROCESSED;
    }
    plVar10 = get_listbox_widget_data(widget_data_00);
    plVar11 = plVar10->sel;
    uVar9 = kbd_action(KEYMAP_MENU,ev_00,(int *)0x0);
    if (uVar9 == 0x11) {
      if (plVar10->ops->match != (_func_listbox_match_listbox_item_ptr_terminal_ptr_uchar_ptr *)0x0)
      {
        push_hierbox_search_button(dlg_data,(widget_data *)0x0);
        return EVENT_PROCESSED;
      }
    }
    else if (uVar9 < 0x12) {
      if (uVar9 == 7) {
        if (plVar11 == (listbox_item *)0x0) {
          return EVENT_PROCESSED;
        }
        if (plVar11->type != BI_FOLDER) {
          return EVENT_PROCESSED;
        }
        recursively_set_expanded(plVar11,1);
        goto LAB_0805db02;
      }
    }
    else if (uVar9 == 0x12) {
      if (plVar11 == (listbox_item *)0x0) {
        return EVENT_PROCESSED;
      }
      if (plVar11->type == BI_FOLDER) {
        plVar11->field_0x18 = plVar11->field_0x18 & 0xfe | (plVar11->field_0x18 ^ 1) & 1;
        goto LAB_0805db02;
      }
    }
    else if (uVar9 == 0x13) {
      if (plVar11 == (listbox_item *)0x0) {
        return EVENT_PROCESSED;
      }
      if (((list_head_elinks *)(plVar11->child).next == &plVar11->child) ||
         ((plVar11->field_0x18 & 1) == 0)) {
        plVar11 = (*plVar10->ops->get_root)(plVar11);
        if (plVar11 != (listbox_item *)0x0) {
          listbox_sel(widget_data_00,plVar11);
        }
      }
      else if (plVar11->type == BI_FOLDER) {
        recursively_set_expanded(plVar11,0);
      }
LAB_0805db02:
      pcVar6 = *(code **)((int)pvVar2 + 4);
      if (pcVar6 != (code *)0x0) {
        (*pcVar6)();
      }
      display_widget(dlg_data,widget_data_00);
      return EVENT_PROCESSED;
    }
  }
  else if (tVar1 == EVENT_INIT) {
    pvVar2 = dlg_data->dlg->udata2;
    piVar7 = (int *)mem_alloc(0xc);
    if (piVar7 != (int *)0x0) {
      piVar7[2] = (int)dlg_data;
      iVar3 = *(int *)((int)pvVar2 + 0x18);
      piVar7[1] = (int)pvVar2 + 0x18;
      *piVar7 = iVar3;
      *(int **)((int)pvVar2 + 0x18) = piVar7;
      *(int **)(*piVar7 + 4) = piVar7;
    }
    for (puVar4 = *(undefined4 **)((int)pvVar2 + 0x28); puVar4 != (undefined4 *)((int)pvVar2 + 0x28)
        ; puVar4 = (undefined4 *)*puVar4) {
      *(byte *)(puVar4 + 6) = *(byte *)(puVar4 + 6) | 2;
    }
  }
  else if (tVar1 == EVENT_ABORT) {
    plVar10 = get_listbox_widget_data(dlg_data->widgets_data);
    pvVar2 = dlg_data->dlg->udata2;
    if ((*(byte *)((int)pvVar2 + 0x60) & 1) == 0) {
      *(listbox_data **)((int)pvVar2 + 0x44) = plVar10->next;
      *(listbox_data **)((int)pvVar2 + 0x48) = plVar10->prev;
      *(listbox_ops **)((int)pvVar2 + 0x4c) = plVar10->ops;
      *(listbox_item **)((int)pvVar2 + 0x50) = plVar10->sel;
      *(listbox_item **)((int)pvVar2 + 0x54) = plVar10->top;
      *(int *)((int)pvVar2 + 0x58) = plVar10->sel_offset;
      *(list_head_elinks **)((int)pvVar2 + 0x5c) = plVar10->items;
    }
    plVar10->next->prev = plVar10->prev;
    plVar10->prev->next = plVar10->next;
    for (p = *(int ***)((int)pvVar2 + 0x18); p != (int **)((int)pvVar2 + 0x18); p = (int **)*p) {
      if (dlg_data == (dialog_data *)p[2]) {
        (*p)[1] = (int)p[1];
        *p[1] = (int)*p;
        mem_free(p);
        return EVENT_NOT_PROCESSED;
      }
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

void update_hierbox_browser(hierbox_browser *browser)

{
  undefined4 *puVar1;
  hierbox_dialog_list_item *item;
  
  for (puVar1 = (undefined4 *)(browser->dialogs).next;
      (list_head_elinks *)puVar1 != &browser->dialogs; puVar1 = (undefined4 *)*puVar1) {
    redraw_from_window(**(window ***)puVar1[2]);
  }
  return;
}



// WARNING: Unknown calling convention

listbox_item *
add_listbox_item(hierbox_browser *browser,listbox_item *root,listbox_item_type type,void *data,
                int add_position)

{
  listbox_item *plVar1;
  listbox_item *plVar2;
  listbox_item *item;
  
  if (root == (listbox_item *)0x0) {
    if ((assert_failed == 0) &&
       (assert_failed = (int)(browser == (hierbox_browser *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 0x2e;
      elinks_internal((uchar *)"assertion browser != NULL failed: Nowhere to add new list box item")
      ;
    }
    root = &browser->root;
  }
  plVar2 = (listbox_item *)mem_calloc(1,0x20);
  if (plVar2 != (listbox_item *)0x0) {
    plVar2->field_0x18 = plVar2->field_0x18 | 2;
    (plVar2->child).prev = &plVar2->child;
    (plVar2->child).next = &plVar2->child;
    plVar2->udata = data;
    plVar2->type = type;
    plVar2->depth = root->depth + 1;
    if (add_position < 0) {
                    // WARNING: Load size is inaccurate
      plVar2->next = *(root->child).prev;
      plVar2->prev = (listbox_item *)(root->child).prev;
      *(listbox_item **)(root->child).prev = plVar2;
      plVar2->next->prev = plVar2;
    }
    else {
      plVar1 = (listbox_item *)(root->child).next;
      plVar2->prev = (listbox_item *)&root->child;
      plVar2->next = plVar1;
      (root->child).next = plVar2;
      plVar2->next->prev = plVar2;
    }
    if (browser != (hierbox_browser *)0x0) {
      update_hierbox_browser(browser);
    }
  }
  return plVar2;
}



// WARNING: Unknown calling convention

void done_listbox_item(hierbox_browser *browser,listbox_item *item)

{
  listbox_item *new_item;
  listbox_item *plVar1;
  listbox_data *box_data;
  listbox_data *box;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((item == (listbox_item *)0x0) || ((list_head_elinks *)(item->child).next != &item->child)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
    errline = 0x5c;
    elinks_internal((uchar *)"assertion item && list_empty(item->child) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  plVar1 = item->next;
  if (plVar1 != (listbox_item *)0x0) {
    box = (listbox_data *)(browser->boxes).next;
    if (box != (listbox_data *)&browser->boxes) {
      do {
        if (box->sel == item) {
          plVar1 = traverse_listbox_items_list
                             (item,box,1,1,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                              (void *)0x0);
          if ((item == plVar1) &&
             (plVar1 = traverse_listbox_items_list
                                 (item,box,-1,1,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                                  (void *)0x0), item == plVar1)) {
            plVar1 = (listbox_item *)0x0;
          }
          box->sel = plVar1;
        }
        if (box->top == item) {
          plVar1 = traverse_listbox_items_list
                             (item,box,1,1,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                              (void *)0x0);
          if ((item == plVar1) &&
             (plVar1 = traverse_listbox_items_list
                                 (item,box,-1,1,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                                  (void *)0x0), item == plVar1)) {
            plVar1 = (listbox_item *)0x0;
          }
          box->top = plVar1;
        }
        box = box->next;
      } while (box != (listbox_data *)&browser->boxes);
      plVar1 = item->next;
    }
    plVar1->prev = item->prev;
    item->prev->next = item->next;
    update_hierbox_browser(browser);
  }
  mem_free(item);
  return;
}



// WARNING: Unknown calling convention

dialog_data * hierbox_browser(hierbox_browser *browser,session *ses)

{
  terminal *term;
  size_t sVar1;
  widget_handler_T *handler;
  option_value *poVar2;
  dialog *dlg;
  dialog_data *pdVar3;
  int iVar4;
  int new_charset;
  uchar *puVar5;
  uchar *puVar6;
  hierbox_browser_button *but;
  hierbox_browser_button *phVar7;
  int new_charset_1;
  int new_charset_2;
  code *pcVar8;
  memory_list *ml;
  uint uVar9;
  int button;
  _func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *local_24;
  
  term = ses->tab->term;
  sVar1 = browser->buttons_size;
  poVar2 = get_opt_();
  local_24 = poVar2->command;
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  dlg = (dialog *)mem_calloc(1,sVar1 * 0x30 + 0xa0);
  pdVar3 = (dialog_data *)0x0;
  if (dlg != (dialog *)0x0) {
    puVar6 = browser->title;
    if ((puVar6 != (uchar *)0x0) && (*puVar6 != '\0')) {
      if ((term != (terminal *)0x0) &&
         (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
        puVar5 = get_cp_mime_name(iVar4);
        bind_textdomain_codeset("elinks",puVar5);
        current_charset = iVar4;
      }
      puVar6 = gettext(puVar6);
    }
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 3;
    dlg->title = puVar6;
    dlg->layouter = generic_dialog_layouter;
    dlg->handle_event = hierbox_dialog_event_handler;
    dlg->udata2 = browser;
    dlg->udata = ses;
    uVar9 = 0;
    add_dlg_listbox(dlg,&dlg[1].widgets[sVar1].data);
    if (browser->buttons_size != 0) {
      do {
        while ((phVar7 = browser->buttons + uVar9,
               local_24 == (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x0 ||
               ((phVar7->field_0x8 & 1) != 0))) {
          handler = phVar7->handler;
          puVar6 = phVar7->label;
          if ((puVar6 != (uchar *)0x0) && (*puVar6 != '\0')) {
            if ((term != (terminal *)0x0) &&
               (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
              puVar5 = get_cp_mime_name(iVar4);
              bind_textdomain_codeset("elinks",puVar5);
              current_charset = iVar4;
            }
            puVar6 = gettext(puVar6);
          }
          uVar9 = uVar9 + 1;
          add_dlg_button_do(dlg,puVar6,1,handler,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
          if (browser->buttons_size < uVar9 || browser->buttons_size == uVar9) goto LAB_0805e08d;
        }
        local_24 = local_24 + 1;
        uVar9 = uVar9 + 1;
      } while (uVar9 <= browser->buttons_size && browser->buttons_size != uVar9);
    }
LAB_0805e08d:
    if ((term != (terminal *)0x0) && (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)
       ) {
      puVar6 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar6);
      current_charset = iVar4;
    }
    puVar6 = gettext((uchar *)"Close");
    add_dlg_button_do(dlg,puVar6,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if (assert_failed == 0) {
      pcVar8 = (code *)0x0;
      if (local_24 != (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x0) {
        pcVar8 = local_24 + -1;
      }
      assert_failed = (int)((uVar9 + 2) - (int)pcVar8 != dlg->number_of_widgets);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 0x150;
        elinks_internal((uchar *)
                        "assertion button + 2 - (anonymous ? anonymous - 1 : 0) == (dlg)->number_of_widgets failed!"
                       );
      }
    }
    ml = getml(dlg,0);
    pdVar3 = do_dialog(term,dlg,ml);
  }
  return pdVar3;
}



// WARNING: Unknown calling convention

void clear_hotkeys_cache(menu *menu)

{
  uchar *puVar1;
  int iVar2;
  menu_item *item;
  menu_item *pmVar3;
  
  pmVar3 = menu->items;
  puVar1 = pmVar3->text;
  while (puVar1 != (uchar *)0x0) {
    iVar2 = menu->hotkeys;
    pmVar3->hotkey_pos = 0;
    pmVar3->hotkey_state = (uint)(iVar2 == 0);
    pmVar3 = pmVar3 + 1;
    puVar1 = pmVar3->text;
  }
  return;
}



// WARNING: Unknown calling convention

void init_hotkeys(terminal *term,menu *menu)

{
  char *pcVar1;
  int cp_index;
  int new_charset;
  uchar *codeset;
  uchar *msgid;
  menu_item *mi;
  menu_item *pmVar2;
  uchar *text;
  
  pmVar2 = menu->items;
  msgid = pmVar2->text;
  do {
    while( true ) {
      if (msgid == (uchar *)0x0) {
        return;
      }
      if (menu->hotkeys == 0) break;
      if (((pmVar2->hotkey_state == HKS_CACHED) || (pmVar2->hotkey_pos != 0)) || (*msgid == '\0'))
      goto LAB_0805e206;
      if ((*(byte *)&pmVar2->flags & 0x40) == 0) {
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          codeset = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = cp_index;
        }
        msgid = gettext(msgid);
        if (*msgid == '\0') goto LAB_0805e206;
      }
      pcVar1 = strchr((char *)msgid,0x7e);
      if (pcVar1 == (char *)0x0) {
        pmVar2->hotkey_pos = 0;
        goto LAB_0805e206;
      }
      pmVar2->hotkey_pos = (int)(pcVar1 + (1 - (int)msgid));
      if (pcVar1 + (1 - (int)msgid) == (char *)0x0) goto LAB_0805e206;
      pmVar2->hotkey_state = HKS_CACHED;
      pmVar2 = pmVar2 + 1;
      msgid = pmVar2->text;
    }
    pmVar2->hotkey_pos = 0;
    pmVar2->hotkey_state = HKS_IGNORE;
LAB_0805e206:
    pmVar2 = pmVar2 + 1;
    msgid = pmVar2->text;
  } while( true );
}



// WARNING: Unknown calling convention

void refresh_hotkeys(terminal *term,menu *menu)

{
  uchar *puVar1;
  int iVar2;
  menu_item *item;
  menu_item *pmVar3;
  
  if (menu->lang != current_language) {
    pmVar3 = menu->items;
    puVar1 = pmVar3->text;
    while (puVar1 != (uchar *)0x0) {
      iVar2 = menu->hotkeys;
      pmVar3->hotkey_pos = 0;
      pmVar3->hotkey_state = (uint)(iVar2 == 0);
      pmVar3 = pmVar3 + 1;
      puVar1 = pmVar3->text;
    }
    init_hotkeys(term,menu);
    menu->lang = current_language;
  }
  return;
}



// WARNING: Unknown calling convention

int check_hotkeys_common(menu *menu,term_event_char_T hotkey,terminal *term,int check_mode)

{
  unicode_val_T uVar1;
  int codepage;
  int i;
  int key_pos;
  uchar *puVar2;
  unicode_val_T uVar3;
  unicode_val_T items_hotkey;
  int new_charset;
  uchar *codeset;
  menu_item *item;
  int iVar4;
  uchar **ppuVar5;
  int iVar6;
  int local_30;
  uchar *local_20 [4];
  
  uVar1 = unicode_fold_label_case(hotkey);
  codepage = get_terminal_codepage(term);
  iVar4 = menu->size;
  if (iVar4 < 1) {
    return 0;
  }
  local_30 = menu->selected % iVar4;
  if (local_30 < 0) {
    local_30 = local_30 + iVar4;
  }
  iVar6 = local_30 + 1;
  if (iVar6 == iVar4) goto LAB_0805e44b;
LAB_0805e388:
  iVar4 = iVar6 << 5;
  do {
    ppuVar5 = (uchar **)((int)&menu->items->text + iVar4);
    puVar2 = *ppuVar5;
    if ((puVar2 != (uchar *)0x0) && (*puVar2 != '\0')) {
      local_20[0] = puVar2;
      if (((*(byte *)(ppuVar5 + 5) & 0x40) == 0) && (*puVar2 != '\0')) {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          codeset = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = iVar4;
        }
        local_20[0] = gettext(puVar2);
        if (local_20[0] == (uchar *)0x0) goto LAB_0805e438;
      }
      if (*local_20[0] != '\0') {
        if (check_mode == 0) {
          if (ppuVar5[7] == (uchar *)0x0) goto LAB_0805e438;
          local_20[0] = local_20[0] + (int)ppuVar5[7];
        }
        puVar2 = (uchar *)__rawmemchr(local_20[0],0);
        uVar3 = cp_to_unicode(codepage,local_20,puVar2);
        if (assert_failed == 0) {
          assert_failed = (int)(uVar3 == 0xfffffffd);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hotkey.c";
            errline = 0xb8;
            elinks_internal((uchar *)"assertion items_hotkey != UCS_NO_CHAR failed!");
            if (assert_failed != 0) goto LAB_0805e517;
          }
          uVar3 = unicode_fold_label_case(uVar3);
          if (uVar1 == uVar3) {
            menu->selected = iVar6;
            return 1;
          }
        }
        else {
LAB_0805e517:
          assert_failed = 0;
        }
      }
    }
LAB_0805e438:
    if (local_30 == iVar6) {
      return 0;
    }
    iVar6 = iVar6 + 1;
    if (iVar6 != menu->size) goto LAB_0805e388;
LAB_0805e44b:
    iVar4 = 0;
    iVar6 = 0;
  } while( true );
}



// WARNING: Unknown calling convention

int check_not_so_hot_keys(menu *menu,term_event_char_T key,terminal *term)

{
  int iVar1;
  
  iVar1 = check_hotkeys_common(menu,key,term,1);
  return iVar1;
}



// WARNING: Unknown calling convention

int check_hotkeys(menu *menu,term_event_char_T key,terminal *term)

{
  int iVar1;
  
  iVar1 = check_hotkeys_common(menu,key,term,0);
  return iVar1;
}



// WARNING: Unknown calling convention

void add_dlg_field_do(dialog *dlg,widget_type type,uchar *label,int min,int max,
                     widget_handler_T *handler,int datalen,void *data,input_history *history,
                     inpfield_flags flags)

{
  int iVar1;
  
  iVar1 = dlg->number_of_widgets;
  dlg->number_of_widgets = iVar1 + 1;
  dlg->widgets[iVar1].type = type;
  dlg->widgets[iVar1].text = label;
  dlg->widgets[iVar1].handler = handler;
  dlg->widgets[iVar1].datalen = datalen;
  dlg->widgets[iVar1].data = data;
  dlg->widgets[iVar1].info.field.history = history;
  dlg->widgets[iVar1].info.field.flags = flags;
  dlg->widgets[iVar1].info.checkbox.gid = min;
  dlg->widgets[iVar1].info.checkbox.gnum = max;
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_field_do(dialog_data *dlg_data,widget_data *widget_data,int hide)

{
  terminal *term_00;
  int iVar1;
  uchar *string;
  byte bVar2;
  int iVar3;
  color_pair *pcVar4;
  color_pair *color;
  int w;
  int iVar5;
  int iVar6;
  uchar *text;
  uchar *t;
  int x;
  terminal *term;
  int local_3c;
  int local_38;
  size_t local_30;
  box box;
  
  term_00 = dlg_data->win->term;
  iVar1 = dlg_data->selected_widget_id;
  if ((term_00->field_0x38 & 2) == 0) {
    iVar5 = (widget_data->info).field.cpos;
    iVar6 = (widget_data->info).field.vpos;
    iVar3 = (iVar5 + 1) - (widget_data->box).width;
    if (iVar6 < iVar3) {
      (widget_data->info).field.vpos = iVar3;
      iVar6 = iVar3;
    }
    else if (iVar5 < iVar6) {
      (widget_data->info).field.vpos = iVar5;
      iVar6 = iVar5;
    }
    local_38 = 0;
    local_3c = 0;
    if (iVar6 < 0) {
      (widget_data->info).field.vpos = 0;
      local_38 = 0;
      local_3c = 0;
    }
  }
  else {
    string = widget_data->cdata;
    local_3c = utf8_ptr2cells(string,string + (widget_data->info).field.cpos);
    iVar5 = (local_3c - (widget_data->box).width) + 1;
    local_38 = 0;
    if (0 < iVar5) {
      local_38 = iVar5;
    }
    iVar5 = utf8_cells2bytes(string,local_38,(uchar *)0x0);
    (widget_data->info).field.vpos = iVar5;
  }
  pcVar4 = get_bfu_color(term_00,"dialog.field");
  if (pcVar4 != (color_pair *)0x0) {
    draw_box(term_00,&widget_data->box,' ',0,pcVar4);
  }
  pcVar4 = get_bfu_color(term_00,(uchar *)"dialog.field-text");
  if (pcVar4 == (color_pair *)0x0) goto LAB_0805e719;
  text = widget_data->cdata + (widget_data->info).field.vpos;
  bVar2 = (byte)term_00->field_0x38 >> 1 & 1;
  if (hide == 0) {
    if (bVar2 == 0) goto LAB_0805e6ba;
    iVar5 = utf8_ptr2cells(text,(uchar *)0x0);
    w = (widget_data->box).width;
    if (iVar5 <= w) {
      w = iVar5;
    }
    bVar2 = term_00->field_0x38;
  }
  else {
    if (bVar2 == 0) {
LAB_0805e6ba:
      local_30 = strlen((char *)text);
    }
    else {
      local_30 = utf8_ptr2chars(text,(uchar *)0x0);
    }
    w = (widget_data->box).width;
    if ((int)local_30 <= w) {
      w = local_30;
    }
    if (hide != 0) {
      box.x = (widget_data->box).x;
      box.y = (widget_data->box).y;
      box.height = (widget_data->box).height;
      box.width = w;
      draw_box(term_00,&box,'*',0,pcVar4);
      goto LAB_0805e719;
    }
    bVar2 = term_00->field_0x38;
  }
  if ((bVar2 & 2) != 0) {
    w = utf8_cells2bytes(text,w,(uchar *)0x0);
  }
  draw_text(term_00,(widget_data->box).x,(widget_data->box).y,text,w,0,pcVar4);
LAB_0805e719:
  if (dlg_data->widgets_data + iVar1 != widget_data) {
    return EVENT_PROCESSED;
  }
  if ((term_00->field_0x38 & 2) == 0) {
    x = dlg_data->widgets_data[iVar1].info.field.cpos + dlg_data->widgets_data[iVar1].box.x;
    local_38 = x - dlg_data->widgets_data[iVar1].info.field.vpos;
  }
  else {
    local_38 = (local_3c + dlg_data->widgets_data[iVar1].box.x) - local_38;
  }
  set_cursor(term_00,local_38,dlg_data->widgets_data[iVar1].box.y,0);
  dlg_data->win->x = dlg_data->widgets_data[iVar1].box.x;
  dlg_data->win->y = dlg_data->widgets_data[iVar1].box.y;
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_field_pass(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
  wVar1 = display_field_do(dlg_data,widget_data,1);
  return wVar1;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_field(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
  wVar1 = display_field_do(dlg_data,widget_data,0);
  return wVar1;
}



// WARNING: Unknown calling convention

widget_handler_status_T clear_field(dialog_data *dlg_data,widget_data *widget_data)

{
  widget *pwVar1;
  size_t __n;
  
  pwVar1 = widget_data->widget;
  (widget_data->info).field.cpos = 0;
  __n = pwVar1->datalen;
  if (__n != 0) {
    memset(widget_data->cdata,0,__n);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T kbd_field(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  uchar uVar2;
  byte bVar3;
  terminal *term;
  term_event *ev;
  uint uVar4;
  action_id_T action_id_00;
  action_id_T action_id;
  action *paVar5;
  action *action;
  option_value *poVar6;
  size_t sVar7;
  int iVar8;
  uchar *puVar9;
  size_t __n;
  input_history_entry *piVar10;
  ushort *puVar11;
  ushort **ppuVar12;
  uchar *end_1;
  unicode_val_T uVar13;
  unicode_val_T data;
  uchar tmp;
  uchar *text;
  uchar *puVar14;
  uchar *end;
  byte *pbVar15;
  uchar *text_2;
  uchar *text_1;
  int iVar16;
  uchar *local_38;
  uchar *local_20 [4];
  
  term = dlg_data->win->term;
  ev = dlg_data->term_event;
  action_id_00 = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
  if (action_id_00 == -1) {
switchD_0805eae0_caseD_0:
    if (((ev->info).mouse.x < 0x20) || ((ev->info).mouse.y != 0)) {
      return EVENT_NOT_PROCESSED;
    }
    puVar14 = widget_data->cdata;
    sVar7 = strlen((char *)puVar14);
    iVar8 = get_terminal_codepage(term);
    puVar9 = u2cp_((ev->info).mouse.x,iVar8,NBSP_MODE_ASCII);
    __n = strlen((char *)puVar9);
    if ((int)sVar7 < (int)(widget_data->widget->datalen - __n)) {
      iVar8 = (widget_data->info).field.cpos;
      puVar14 = puVar14 + iVar8;
      memmove(puVar14 + __n,puVar14,(sVar7 - iVar8) + 1);
      memcpy(puVar14,puVar9,__n);
      piVar1 = &(widget_data->info).field.cpos;
      *piVar1 = *piVar1 + __n;
    }
    goto display_field;
  }
  paVar5 = get_action(KEYMAP_EDIT,action_id_00);
  if (((paVar5 == (action *)0x0) || ((*(byte *)((int)&paVar5->flags + 2) & 1) != 0)) &&
     (poVar6 = get_opt_(), poVar6->tree != (list_head_elinks *)0x0)) {
    return EVENT_NOT_PROCESSED;
  }
  switch(action_id_00) {
  default:
    goto switchD_0805eae0_caseD_0;
  case 2:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if ((widget_data->widget->info).field.history == (input_history *)0x0) {
      return EVENT_NOT_PROCESSED;
    }
    do_tab_compl(dlg_data,&(widget_data->info).field.history);
    break;
  case 3:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if ((widget_data->widget->info).field.history == (input_history *)0x0) {
      return EVENT_NOT_PROCESSED;
    }
    do_tab_compl_file(dlg_data,&(widget_data->info).field.history);
    break;
  case 4:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if ((widget_data->widget->info).field.history == (input_history *)0x0) {
      return EVENT_NOT_PROCESSED;
    }
    do_tab_compl_unambiguous(dlg_data,&(widget_data->info).field.history);
    break;
  case 5:
    iVar8 = (widget_data->info).field.cpos;
    if (iVar8 != 0) {
      if ((term->field_0x38 & 2) == 0) {
        puVar14 = widget_data->cdata;
        sVar7 = strlen((char *)puVar14);
        memmove(puVar14 + iVar8 + -1,puVar14 + iVar8,(sVar7 - iVar8) + 1);
        piVar1 = &(widget_data->info).field.cpos;
        *piVar1 = *piVar1 + -1;
      }
      else {
        local_20[0] = widget_data->cdata;
        end_1 = widget_data->cdata + iVar8 + -1;
        do {
          uVar13 = utf8_to_unicode(local_20,end_1);
        } while (uVar13 != 0xfffffffd);
        puVar14 = widget_data->cdata;
        (widget_data->info).field.cpos = (int)local_20[0] - (int)puVar14;
        if (iVar8 != (int)local_20[0] - (int)puVar14) {
          local_20[0] = puVar14;
          sVar7 = strlen((char *)(puVar14 + iVar8));
          memmove(puVar14 + (widget_data->info).field.cpos,puVar14 + iVar8,sVar7 + 1);
        }
      }
    }
    break;
  case 8:
    set_clipboard_text(widget_data->cdata);
    return EVENT_PROCESSED;
  case 9:
    set_clipboard_text(widget_data->cdata);
    *widget_data->cdata = '\0';
    (widget_data->info).field.cpos = 0;
    break;
  case 10:
    puVar14 = widget_data->cdata;
    sVar7 = strlen((char *)puVar14);
    iVar8 = (widget_data->info).field.cpos;
    if (iVar8 < (int)sVar7) {
      if ((term->field_0x38 & 2) == 0) {
        memmove(puVar14 + iVar8,puVar14 + iVar8 + 1,(sVar7 - iVar8) + 1);
      }
      else {
        puVar9 = puVar14 + iVar8;
        local_20[0] = puVar9;
        utf8_to_unicode(local_20,puVar14 + sVar7);
        if (puVar9 != local_20[0]) {
          memmove(puVar9,local_20[0],(size_t)(puVar14 + sVar7 + (1 - (int)local_20[0])));
        }
      }
    }
    break;
  case 0xb:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if ((widget_data->widget->info).field.history == (input_history *)0x0) {
      return EVENT_NOT_PROCESSED;
    }
    piVar10 = (widget_data->info).field.cur_hist;
    if (piVar10 == (input_history_entry *)((int)&widget_data->info + 8)) {
      return EVENT_NOT_PROCESSED;
    }
    piVar10 = piVar10->next;
    goto LAB_0805ecc7;
  case 0xc:
    sVar7 = strlen((char *)widget_data->cdata);
    (widget_data->info).field.cpos = sVar7;
    break;
  case 0x10:
    puVar14 = widget_data->cdata;
    puVar9 = puVar14 + (widget_data->info).field.cpos;
    sVar7 = strlen((char *)puVar9);
    memmove(puVar14,puVar9,sVar7 + 1);
  case 0xf:
    (widget_data->info).field.cpos = 0;
    break;
  case 0x11:
    widget_data->cdata[(widget_data->info).field.cpos] = '\0';
    break;
  case 0x12:
    puVar14 = widget_data->cdata;
    sVar7 = strlen((char *)puVar14);
    iVar8 = (widget_data->info).field.cpos;
    iVar16 = iVar8;
    if (0 < iVar8) {
      ppuVar12 = __ctype_b_loc();
      puVar9 = puVar14 + iVar8;
      do {
        if ((*(byte *)((int)*ppuVar12 + (uint)puVar9[-1] * 2 + 1) & 0x20) == 0) {
          if (0 < iVar16) {
            puVar9 = puVar14 + iVar16;
            goto LAB_0805ed3a;
          }
          break;
        }
        iVar16 = iVar16 + -1;
        puVar9 = puVar9 + -1;
      } while (0 < iVar16);
    }
    goto LAB_0805ed45;
  case 0x13:
    iVar8 = (widget_data->info).field.cpos;
    if (0 < iVar8) {
      iVar8 = iVar8 + -1;
      (widget_data->info).field.cpos = iVar8;
    }
    if ((iVar8 != 0) && ((term->field_0x38 & 2) != 0)) {
      puVar14 = widget_data->cdata;
      puVar9 = puVar14 + (widget_data->info).field.cpos;
      uVar2 = *puVar9;
      *puVar9 = '\0';
      local_20[0] = puVar14;
      strlen_utf8(local_20);
      *puVar9 = uVar2;
      (widget_data->info).field.cpos = (int)local_20[0] - (int)puVar14;
    }
    break;
  case 0x14:
    iVar8 = (widget_data->info).field.cpos;
    if (0 < iVar8) {
      ppuVar12 = __ctype_b_loc();
      puVar14 = widget_data->cdata + iVar8;
      do {
        puVar11 = *ppuVar12;
        if ((*(byte *)((int)puVar11 + (uint)puVar14[-1] * 2 + 1) & 0x20) == 0) {
          iVar8 = (widget_data->info).field.cpos;
          if (0 < iVar8) {
            while ((iVar8 = iVar8 + -1,
                   (*(byte *)((int)puVar11 + (uint)widget_data->cdata[iVar8] * 2 + 1) & 0x20) == 0
                   && ((widget_data->info).field.cpos = iVar8, 0 < iVar8))) {
              puVar11 = *ppuVar12;
            }
          }
          break;
        }
        iVar8 = iVar8 + -1;
        puVar14 = puVar14 + -1;
        (widget_data->info).field.cpos = iVar8;
      } while (0 < iVar8);
    }
    break;
  case 0x15:
    ppuVar12 = __ctype_b_loc();
    iVar8 = (widget_data->info).field.cpos;
    pbVar15 = widget_data->cdata + iVar8;
    while( true ) {
      bVar3 = *pbVar15;
      pbVar15 = pbVar15 + 1;
      if ((*(byte *)((int)*ppuVar12 + (uint)bVar3 * 2 + 1) & 0x20) == 0) break;
      (widget_data->info).field.cpos = iVar8 + 1;
      iVar8 = iVar8 + 1;
    }
    if (bVar3 != 0) {
      puVar14 = widget_data->cdata + iVar8;
      do {
        iVar8 = iVar8 + 1;
        (widget_data->info).field.cpos = iVar8;
        pbVar15 = puVar14 + 1;
        if (*pbVar15 == 0) {
          if ((*(byte *)((int)*ppuVar12 + 1) & 0x20) == 0) goto display_field;
          break;
        }
        puVar14 = puVar14 + 1;
      } while ((*(byte *)((int)*ppuVar12 + (uint)*pbVar15 * 2 + 1) & 0x20) == 0);
      puVar14 = widget_data->cdata + iVar8;
      do {
        iVar8 = iVar8 + 1;
        (widget_data->info).field.cpos = iVar8;
        pbVar15 = puVar14 + 1;
        puVar14 = puVar14 + 1;
      } while ((*(byte *)((int)*ppuVar12 + (uint)*pbVar15 * 2 + 1) & 0x20) != 0);
    }
    break;
  case 0x18:
    puVar14 = get_clipboard_text();
    if (puVar14 != (uchar *)0x0) {
      safe_strncpy(widget_data->cdata,puVar14,widget_data->widget->datalen);
      sVar7 = strlen((char *)widget_data->cdata);
      (widget_data->info).field.cpos = sVar7;
      mem_free(puVar14);
    }
    break;
  case 0x1a:
    redraw_terminal_cls(term);
    return EVENT_PROCESSED;
  case 0x1b:
    puVar14 = widget_data->cdata;
    uVar4 = (widget_data->info).field.cpos;
    sVar7 = strlen((char *)puVar14);
    if (uVar4 < sVar7) {
      if ((term->field_0x38 & 2) == 0) {
        (widget_data->info).field.cpos = uVar4 + 1;
      }
      else {
        local_20[0] = puVar14 + uVar4;
        puVar14 = (uchar *)__rawmemchr(local_20[0],0);
        utf8_to_unicode(local_20,puVar14);
        (widget_data->info).field.cpos = (int)local_20[0] - (int)widget_data->cdata;
      }
    }
    break;
  case 0x1d:
    if (widget_data->widget->type != WIDGET_FIELD) {
      return EVENT_NOT_PROCESSED;
    }
    if ((widget_data->widget->info).field.history == (input_history *)0x0) {
      return EVENT_NOT_PROCESSED;
    }
    piVar10 = ((widget_data->info).field.cur_hist)->prev;
    if (piVar10 == (input_history_entry *)((int)&widget_data->info + 8)) {
      return EVENT_NOT_PROCESSED;
    }
LAB_0805ecc7:
    (widget_data->info).field.cur_hist = piVar10;
    dlg_set_history(widget_data);
  }
display_field:
  display_widget(dlg_data,widget_data);
  redraw_from_window(dlg_data->win);
  return EVENT_PROCESSED;
  while( true ) {
    iVar16 = iVar16 + -1;
    puVar9 = puVar9 + -1;
    if (iVar16 < 1) break;
LAB_0805ed3a:
    if ((*(byte *)((int)*ppuVar12 + (uint)puVar9[-1] * 2 + 1) & 0x20) != 0) break;
  }
LAB_0805ed45:
  local_38 = puVar14 + iVar8;
  memmove(puVar14 + iVar16,local_38,(sVar7 - iVar8) + 1);
  (widget_data->info).field.cpos = iVar16;
  goto display_field;
}



// WARNING: Unknown calling convention

widget_handler_status_T mouse_field(dialog_data *dlg_data,widget_data *widget_data)

{
  term_event *ptVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  uint uVar5;
  input_history_entry *piVar6;
  term_event *ev;
  size_t sVar7;
  int iVar8;
  
  ptVar1 = dlg_data->term_event;
  iVar8 = (widget_data->box).x;
  iVar2 = (ptVar1->info).mouse.x;
  iVar3 = (ptVar1->info).mouse.y;
  if ((((iVar8 <= iVar2) && (iVar4 = (widget_data->box).y, iVar4 <= iVar3)) &&
      (iVar2 < (widget_data->box).width + iVar8)) && (iVar3 < iVar4 + (widget_data->box).height)) {
    uVar5 = (ptVar1->info).mouse.button;
    if ((uVar5 & 7) == 3) {
      if ((((uVar5 & 0x20) == 0) && (widget_data->widget->type == WIDGET_FIELD)) &&
         (((widget_data->widget->info).field.history != (input_history *)0x0 &&
          (piVar6 = ((widget_data->info).field.cur_hist)->prev,
          piVar6 != (input_history_entry *)((int)&widget_data->info + 8))))) {
        (widget_data->info).field.cur_hist = piVar6;
        dlg_set_history(widget_data);
        select_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
    }
    else {
      if ((uVar5 & 7) != 4) {
        iVar8 = ((widget_data->info).field.vpos + iVar2) - iVar8;
        (widget_data->info).field.cpos = iVar8;
        sVar7 = strlen((char *)widget_data->cdata);
        if ((int)sVar7 < iVar8) {
          (widget_data->info).field.cpos = sVar7;
        }
        select_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
      if ((((uVar5 & 0x20) == 0) && (widget_data->widget->type == WIDGET_FIELD)) &&
         (((widget_data->widget->info).field.history != (input_history *)0x0 &&
          (piVar6 = (widget_data->info).field.cur_hist,
          piVar6 != (input_history_entry *)((int)&widget_data->info + 8))))) {
        (widget_data->info).field.cur_hist = piVar6->next;
        dlg_set_history(widget_data);
        select_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T init_field(dialog_data *dlg_data,widget_data *widget_data)

{
  list_head_elinks *plVar1;
  input_history *piVar2;
  void *pvVar3;
  size_t sVar4;
  void **ppvVar5;
  input_history_entry *entry;
  input_history *piVar6;
  
  if (((widget_data->widget->type == WIDGET_FIELD) &&
      (piVar2 = (widget_data->widget->info).field.history, piVar2 != (input_history *)0x0)) &&
     (piVar6 = (input_history *)(piVar2->entries).next, piVar6 != piVar2)) {
    plVar1 = &(widget_data->info).field.history;
    do {
      sVar4 = strlen((char *)&piVar6->size);
      ppvVar5 = (void **)mem_alloc(sVar4 + 0xc);
      if (ppvVar5 != (void **)0x0) {
        memcpy(ppvVar5 + 2,&piVar6->size,sVar4 + 1);
        pvVar3 = plVar1->next;
        ppvVar5[1] = plVar1;
        *ppvVar5 = pvVar3;
        plVar1->next = ppvVar5;
        *(void ***)((int)*ppvVar5 + 4) = ppvVar5;
      }
      piVar6 = (input_history *)(piVar6->entries).next;
    } while ((widget_data->widget->info).field.history != piVar6);
  }
  sVar4 = strlen((char *)widget_data->cdata);
  (widget_data->info).field.cpos = sVar4;
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void input_field_line(session *ses,uchar *prompt,void *data,input_history *history,
                     input_line_handler_T handler)

{
  int iVar1;
  dialog *dlg;
  input_line *input_line;
  memory_list *ml;
  
  if ((assert_failed == 0) && (assert_failed = (int)(ses == (session *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inpfield.c";
    errline = 0x370;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  dlg = (dialog *)mem_calloc(1,0x160);
  if (dlg != (dialog *)0x0) {
    dlg[1].title = (uchar *)ses;
    dlg[1].udata = handler;
    dlg[1].udata2 = data;
    iVar1 = dlg->number_of_widgets;
    dlg->udata = dlg + 1;
    *(byte *)&dlg->layout = *(byte *)&dlg->layout | 0x10;
    dlg->number_of_widgets = iVar1 + 1;
    dlg->handle_event = input_line_event_handler;
    dlg->layouter = input_line_layouter;
    dlg->widgets[iVar1].type = WIDGET_FIELD;
    dlg->widgets[iVar1].handler = (widget_handler_T *)0x0;
    dlg->widgets[iVar1].text = prompt;
    dlg->widgets[iVar1].datalen = 0x100;
    dlg->widgets[iVar1].data = &dlg[1].refresh;
    dlg->widgets[iVar1].info.field.flags = INPFIELD_FLOAT2;
    dlg->widgets[iVar1].info.checkbox.gid = 0;
    dlg->widgets[iVar1].info.checkbox.gnum = 0;
    dlg->widgets[iVar1].info.field.history = history;
    ml = getml(dlg,0);
    do_dialog(ses->tab->term,dlg,ml);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T input_line_event_handler(dialog_data *dlg_data)

{
  int *piVar1;
  void *pvVar2;
  code *pcVar3;
  term_event *ev_00;
  term_event_type tVar4;
  widget *pwVar5;
  uint uVar6;
  uchar *__s;
  input_history *history;
  int iVar7;
  uint uVar8;
  uint uVar9;
  size_t sVar10;
  uint *puVar11;
  uint *puVar12;
  term_event *ev;
  input_line *input_line;
  widget_handler_status_T wVar13;
  bool bVar14;
  action_id_T local_28;
  
  pvVar2 = dlg_data->dlg->udata;
  pcVar3 = *(code **)((int)pvVar2 + 4);
  ev_00 = dlg_data->term_event;
  tVar4 = ev_00->ev;
  if (tVar4 == EVENT_MOUSE) {
    if ((ev_00->info).mouse.y == dlg_data->win->y) {
      return EVENT_NOT_PROCESSED;
    }
    delete_window_ev(dlg_data->win,ev_00);
    return EVENT_PROCESSED;
  }
  if (tVar4 < EVENT_REDRAW) {
    if (tVar4 != EVENT_KBD) {
      return EVENT_NOT_PROCESSED;
    }
    local_28 = kbd_action(KEYMAP_EDIT,ev_00,(int *)0x0);
    switch(local_28) {
    case 5:
      if (*(char *)((int)pvVar2 + 0xc) == '\0') goto cancel_input_line;
      break;
    case 7:
cancel_input_line:
      wVar13 = EVENT_PROCESSED;
      goto LAB_0805f47d;
    case 0xe:
    case 0x16:
    case 0x19:
      pwVar5 = dlg_data->widgets_data[0].widget;
      if ((pwVar5->type == WIDGET_FIELD) &&
         (history = (pwVar5->info).field.history, history != (input_history *)0x0)) {
        add_to_input_history(history,(uchar *)((int)pvVar2 + 0xc),1);
      }
    }
    kbd_field(dlg_data,dlg_data->widgets_data);
    wVar13 = (widget_handler_status_T)(local_28 == 0x1a);
  }
  else {
    if (tVar4 == EVENT_REDRAW) {
      pwVar5 = dlg_data->widgets_data[0].widget;
      if (((pwVar5->type != WIDGET_FIELD) || ((pwVar5->info).field.history == (input_history *)0x0))
         || (uVar6 = dlg_data->widgets_data[0].info.field.cpos, (int)uVar6 < 1)) {
        return EVENT_NOT_PROCESSED;
      }
      puVar12 = (uint *)((int)pvVar2 + 0xc);
      do {
        puVar11 = puVar12;
        uVar8 = *puVar11 + 0xfefefeff & ~*puVar11;
        uVar9 = uVar8 & 0x80808080;
        puVar12 = puVar11 + 1;
      } while (uVar9 == 0);
      bVar14 = (uVar8 & 0x8080) == 0;
      if (bVar14) {
        uVar9 = uVar9 >> 0x10;
      }
      if (bVar14) {
        puVar12 = (uint *)((int)puVar11 + 6);
      }
      if (uVar6 <= (int)puVar12 +
                   ((-3 - (uint)CARRY1((byte)uVar9,(byte)uVar9)) - (int)(uint *)((int)pvVar2 + 0xc))
         ) {
        return EVENT_NOT_PROCESSED;
      }
    }
    else if (tVar4 != EVENT_RESIZE) {
      return EVENT_NOT_PROCESSED;
    }
    wVar13 = EVENT_NOT_PROCESSED;
    local_28 = 0x1a;
  }
  update_dialog_data(dlg_data);
  while (iVar7 = (*pcVar3)(pvVar2,local_28), iVar7 != 0) {
    if (iVar7 != 2) {
      return wVar13;
    }
    __s = dlg_data->widgets_data[0].cdata;
    sVar10 = strlen((char *)__s);
    iVar7 = dlg_data->widgets_data[0].info.field.cpos;
    memmove(__s + iVar7 + -1,__s + iVar7,(1 - iVar7) + sVar10);
    piVar1 = &dlg_data->widgets_data[0].info.field.cpos;
    *piVar1 = *piVar1 + -1;
    update_dialog_data(dlg_data);
  }
  wVar13 = (widget_handler_status_T)(local_28 == 0x1a);
LAB_0805f47d:
  cancel_dialog(dlg_data,dlg_data->widgets_data);
  return wVar13;
}



// WARNING: Unknown calling convention

widget_handler_status_T input_field_cancel(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  done_handler_T *fn;
  widget_handler_status_T wVar2;
  void *data;
  
  pcVar1 = (code *)widget_data->widget->data;
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(dlg_data->dlg->udata2);
  }
  wVar2 = cancel_dialog(dlg_data,widget_data);
  return wVar2;
}



// WARNING: Unknown calling convention

widget_handler_status_T input_field_ok(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  void *pvVar2;
  uchar *data;
  widget *pwVar3;
  int iVar4;
  widget_handler_status_T wVar5;
  
  pcVar1 = (code *)widget_data->widget->data;
  pvVar2 = dlg_data->dlg->udata2;
  data = dlg_data->widgets_data[0].cdata;
  iVar4 = check_dialog(dlg_data);
  if (iVar4 != 0) {
    return EVENT_NOT_PROCESSED;
  }
  pwVar3 = dlg_data->widgets_data[0].widget;
  if ((pwVar3->type == WIDGET_FIELD) && ((pwVar3->info).field.history != (input_history *)0x0)) {
    add_to_input_history(dlg_data->dlg->widgets[0].info.field.history,data,1);
  }
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(pvVar2,data);
  }
  wVar5 = cancel_dialog(dlg_data,widget_data);
  return wVar5;
}



// WARNING: Unknown calling convention

void dlg_format_field(terminal *term,widget_data *widget_data,int x,int *y,int w,int *rw,
                     format_align align,int format_only)

{
  uchar *text;
  uchar *label;
  int iVar1;
  bool bVar2;
  color_pair *local_24;
  size_t local_20;
  
  text = widget_data->widget->text;
  if (text != (uchar *)0x0) {
    bVar2 = ((widget_data->widget->info).field.flags & (INPFIELD_FLOAT|INPFIELD_FLOAT2)) ==
            INPFIELD_NONE;
    if (bVar2) {
      if (*text == '\0') goto LAB_0805f818;
      local_20 = 0;
    }
    else {
      if (*text == '\0') goto LAB_0805f818;
      local_20 = strlen((char *)text);
      if (dlg_format_field::prev_y == y) {
        local_24 = (color_pair *)dlg_format_field::max_label_width;
        if (dlg_format_field::max_label_width < (int)local_20) {
          local_24 = (color_pair *)local_20;
        }
      }
      else {
        dlg_format_field::prev_y = y;
        local_24 = (color_pair *)local_20;
      }
      x = (x - local_20) + (int)local_24;
      w = (w + local_20) - (int)local_24;
      dlg_format_field::max_label_width = (int)local_24;
    }
    local_24 = (color_pair *)0x0;
    if (format_only == 0) {
      local_24 = get_bfu_color(term,"dialog.text");
    }
    dlg_format_text_do(term,text,x,y,w,rw,local_24,ALIGN_LEFT,format_only);
    if ((!bVar2) && (*text != '\0')) {
      if ((*(byte *)((int)&widget_data->widget->info + 0xc) & 1) != 0) {
        *y = *y + -1;
        dlg_format_text_do(term,":",local_20 + x,y,w,rw,local_24,ALIGN_LEFT,format_only);
        x = x + 2;
        w = w + -2;
      }
      if ((int)local_20 < w + -5) {
        *y = *y + -1;
        w = w - local_20;
        x = x + local_20;
      }
    }
  }
LAB_0805f818:
  if (rw != (int *)0x0) {
    iVar1 = 0x2a;
    if (w < 0x2a) {
      iVar1 = w;
    }
    if (*rw < iVar1) {
      *rw = iVar1;
    }
  }
  iVar1 = *y;
  if (x < 0) {
    x = 0;
  }
  (widget_data->box).x = x;
  (widget_data->box).height = 1;
  if (iVar1 < 0) {
    iVar1 = 0;
  }
  if (w < 0) {
    w = 0;
  }
  (widget_data->box).y = iVar1;
  (widget_data->box).width = w;
  *y = *y + 1;
  return;
}



// WARNING: Unknown calling convention

void input_line_layouter(dialog_data *dlg_data)

{
  byte bVar1;
  terminal *term;
  window *win;
  session *ses;
  int local_10;
  
                    // WARNING: Load size is inaccurate
  bVar1 = *(byte *)(*dlg_data->dlg->udata + 0xa8);
  local_10 = ((dlg_data->win->term->height + -1) - (bVar1 & 1)) - (bVar1 >> 1 & 1);
  term = dlg_data->win->term;
  dlg_format_field(term,dlg_data->widgets_data,0,&local_10,term->width,(int *)0x0,ALIGN_LEFT,0);
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T check_nonempty(dialog_data *dlg_data,widget_data *widget_data)

{
  byte bVar1;
  uchar *p;
  byte *pbVar2;
  
  pbVar2 = widget_data->cdata;
  bVar1 = *pbVar2;
  while( true ) {
    if (bVar1 == 0) {
      info_box(dlg_data->win->term,0,(uchar *)"Bad string",ALIGN_CENTER,
               (uchar *)"Empty string not allowed");
      return EVENT_NOT_PROCESSED;
    }
    if (0x20 < bVar1) break;
    pbVar2 = pbVar2 + 1;
    bVar1 = *pbVar2;
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T check_number(dialog_data *dlg_data,widget_data *widget_data)

{
  widget *pwVar1;
  int iVar2;
  int *piVar3;
  long lVar4;
  char *text;
  long l;
  int iVar5;
  msgbox_flags flags;
  char *local_20 [4];
  
  pwVar1 = widget_data->widget;
  piVar3 = __errno_location();
  *piVar3 = 0;
  lVar4 = strtol((char *)widget_data->cdata,local_20,10);
  if (((*piVar3 == 0) && (*widget_data->cdata != '\0')) && (*local_20[0] == '\0')) {
    iVar2 = (pwVar1->info).checkbox.gid;
    if (lVar4 < iVar2) {
      iVar5 = (pwVar1->info).checkbox.gnum;
    }
    else {
      iVar5 = (pwVar1->info).checkbox.gnum;
      if (lVar4 <= iVar5) {
        return EVENT_PROCESSED;
      }
    }
    text = (char *)msg_text(dlg_data->win->term,
                            (uchar *)"Number should be in the range from %d to %d.",iVar2,iVar5);
    flags = MSGBOX_FREE_TEXT;
  }
  else {
    text = "Number expected in field";
    flags = 0;
  }
  info_box(dlg_data->win->term,flags,(uchar *)"Bad number",ALIGN_CENTER,(uchar *)text);
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

void input_field(terminal *term,memory_list *ml,int intl,uchar *title,uchar *text,uchar *okbutton,
                uchar *cancelbutton,void *data,input_history *history,int l,uchar *def,int min,
                int max,widget_handler_T *check,_func_void_void_ptr_uchar_ptr *fn,
                done_handler_T *cancelfn)

{
  int iVar1;
  uchar *__s;
  dialog *dlg_00;
  dialog *dlg;
  size_t sVar2;
  size_t __n;
  int iVar3;
  int new_charset;
  uchar *puVar4;
  int new_charset_1;
  int new_charset_2;
  
  __s = def;
  iVar1 = l;
  if (intl != 0) {
    if ((title != (uchar *)0x0) && (*title != '\0')) {
      if (term != (terminal *)0x0) {
        iVar3 = get_terminal_codepage(term);
        if (iVar3 != current_charset) {
          puVar4 = get_cp_mime_name(iVar3);
          bind_textdomain_codeset("elinks",puVar4);
          current_charset = iVar3;
        }
      }
      title = gettext(title);
    }
    if ((text != (uchar *)0x0) && (*text != '\0')) {
      if (term != (terminal *)0x0) {
        iVar3 = get_terminal_codepage(term);
        if (iVar3 != current_charset) {
          puVar4 = get_cp_mime_name(iVar3);
          bind_textdomain_codeset("elinks",puVar4);
          current_charset = iVar3;
        }
      }
      text = gettext(text);
    }
    if ((okbutton != (uchar *)0x0) && (*okbutton != '\0')) {
      if (term != (terminal *)0x0) {
        iVar3 = get_terminal_codepage(term);
        if (iVar3 != current_charset) {
          puVar4 = get_cp_mime_name(iVar3);
          bind_textdomain_codeset("elinks",puVar4);
          current_charset = iVar3;
        }
      }
      okbutton = gettext(okbutton);
    }
    if ((cancelbutton != (uchar *)0x0) && (*cancelbutton != '\0')) {
      if (term != (terminal *)0x0) {
        iVar3 = get_terminal_codepage(term);
        if (iVar3 != current_charset) {
          puVar4 = get_cp_mime_name(iVar3);
          bind_textdomain_codeset("elinks",puVar4);
          current_charset = iVar3;
        }
      }
      cancelbutton = gettext(cancelbutton);
    }
  }
  dlg_00 = (dialog *)mem_calloc(1,iVar1 + 0xb4);
  if (dlg_00 != (dialog *)0x0) {
    if (__s != (uchar *)0x0) {
      sVar2 = strlen((char *)__s);
      __n = sVar2 + 1;
      if (iVar1 < (int)(sVar2 + 1)) {
        __n = iVar1 - 1;
      }
      memcpy(&dlg_00[2].refresh,__s,__n);
    }
    *(byte *)&dlg_00->layout = *(byte *)&dlg_00->layout | 4;
    dlg_00->layouter = generic_dialog_layouter;
    dlg_00->title = title;
    dlg_00->udata2 = data;
    iVar3 = dlg_00->number_of_widgets;
    dlg_00->number_of_widgets = iVar3 + 1;
    dlg_00->widgets[iVar3].type = WIDGET_FIELD;
    dlg_00->widgets[iVar3].text = text;
    dlg_00->widgets[iVar3].handler = check;
    dlg_00->widgets[iVar3].datalen = iVar1;
    dlg_00->widgets[iVar3].data = &dlg_00[2].refresh;
    dlg_00->widgets[iVar3].info.field.flags = INPFIELD_NONE;
    dlg_00->widgets[iVar3].info.field.history = history;
    dlg_00->widgets[iVar3].info.checkbox.gid = min;
    dlg_00->widgets[iVar3].info.checkbox.gnum = max;
    add_dlg_button_do(dlg_00,okbutton,1,input_field_ok,fn,(done_handler_T *)0x0,(void *)0x0);
    add_dlg_button_do(dlg_00,cancelbutton,2,input_field_cancel,cancelfn,(done_handler_T *)0x0,
                      (void *)0x0);
    if ((assert_failed == 0) &&
       (assert_failed = (int)(dlg_00->number_of_widgets != 3), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inpfield.c";
      errline = 0xef;
      elinks_internal((uchar *)"assertion 3 == (dlg)->number_of_widgets failed!");
    }
    add_to_ml(&ml,dlg_00,0);
    do_dialog(term,dlg_00,ml);
  }
  return;
}



// WARNING: Unknown calling convention

void input_dialog(terminal *term,memory_list *ml,uchar *title,uchar *text,void *data,
                 input_history *history,int l,uchar *def,int min,int max,widget_handler_T *check,
                 _func_void_void_ptr_uchar_ptr *fn,done_handler_T *cancelfn)

{
  input_field(term,ml,1,title,text,"~OK",(uchar *)"~Cancel",data,history,l,def,min,max,check,fn,
              cancelfn);
  return;
}



// WARNING: Unknown calling convention

void dlg_set_history(widget_data *widget_data)

{
  bool bVar1;
  size_t sVar2;
  int iVar3;
  int iVar4;
  size_t __n;
  undefined *puVar5;
  uchar *s;
  
  if (assert_failed == 0) {
    if ((widget_data->widget->type != WIDGET_FIELD) ||
       ((widget_data->widget->info).field.history == (input_history *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
      errline = 0x165;
      elinks_internal((uchar *)"assertion widget_has_history(widget_data) failed!");
      if (assert_failed != 0) goto LAB_0805ff30;
    }
    bVar1 = widget_data->widget->datalen < 1;
    assert_failed = (int)bVar1;
    if (!bVar1) goto LAB_0805ff30;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
    errline = 0x166;
    elinks_internal((uchar *)"assertion widget_data->widget->datalen > 0 failed!");
    puVar5 = (undefined *)(widget_data->info).text.scroller_y;
    if (puVar5 == (undefined *)((int)&widget_data->info + 8)) goto LAB_08060000;
  }
  else {
LAB_0805ff30:
    puVar5 = (undefined *)(widget_data->info).text.scroller_y;
    if (puVar5 == (undefined *)((int)&widget_data->info + 8)) {
LAB_08060000:
      (widget_data->info).field.cpos = 0;
      iVar3 = 0;
      goto LAB_0805ff5f;
    }
  }
  iVar3 = widget_data->widget->datalen;
  sVar2 = strlen(puVar5 + 8);
  __n = iVar3 - 1;
  if ((int)sVar2 <= (int)__n) {
    __n = sVar2;
  }
  iVar3 = 0;
  (widget_data->info).field.cpos = __n;
  if (__n != 0) {
    memcpy(widget_data->cdata,puVar5 + 8,__n);
    iVar3 = (widget_data->info).field.cpos;
  }
LAB_0805ff5f:
  widget_data->cdata[iVar3] = '\0';
  iVar4 = (widget_data->info).field.cpos - (widget_data->box).width;
  iVar3 = 0;
  if (-1 < iVar4) {
    iVar3 = iVar4;
  }
  (widget_data->info).field.vpos = iVar3;
  return;
}



// WARNING: Unknown calling convention

int save_input_history(input_history *history,uchar *filename)

{
  option_value *poVar1;
  uchar *file_name;
  secure_save_info *ssi_00;
  int iVar2;
  int i;
  uchar *history_file;
  input_history_entry *entry;
  input_history *piVar3;
  secure_save_info *ssi;
  
  if ((((history->field_0xc & 1) == 0) || (elinks_home == (uchar *)0x0)) ||
     (poVar1 = get_opt_(), poVar1->tree != (list_head_elinks *)0x0)) {
    return 0;
  }
  file_name = straconcat(elinks_home,filename,0);
  if (file_name != (uchar *)0x0) {
    ssi_00 = secure_open(file_name);
    mem_free(file_name);
    if (ssi_00 != (secure_save_info *)0x0) {
      piVar3 = (input_history *)(history->entries).prev;
      iVar2 = 1;
      if (piVar3 == history) {
        if (ssi_00->err == 0) {
LAB_0806010b:
          history->field_0xc = history->field_0xc & 0xfe;
        }
      }
      else {
        while( true ) {
          secure_fputs(ssi_00,(char *)&piVar3->size);
          secure_fputc(ssi_00,10);
          if (ssi_00->err != 0) break;
          piVar3 = (input_history *)(piVar3->entries).prev;
          if ((piVar3 == history) || (iVar2 == 0x101)) goto LAB_0806010b;
          iVar2 = iVar2 + 1;
        }
      }
      iVar2 = secure_close(ssi_00);
      return iVar2;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

void add_to_input_history(input_history *history,uchar *data,int check_duplicate)

{
  uchar *puVar1;
  uchar uVar2;
  int *p;
  void *pvVar3;
  size_t sVar4;
  uchar *__src;
  input_history *piVar5;
  int iVar6;
  void **ppvVar7;
  uchar *puVar8;
  input_history_entry *entry;
  int l;
  input_history *piVar9;
  input_history *p_00;
  input_history *piVar10;
  
  if (((data != (uchar *)0x0) && (history != (input_history *)0x0)) &&
     (uVar2 = *data, uVar2 != '\0')) {
    sVar4 = strlen((char *)data);
    __src = data;
    while (uVar2 == ' ') {
      __src = __src + 1;
      sVar4 = sVar4 - 1;
      uVar2 = *__src;
    }
    if (sVar4 == 0) {
LAB_0806018d:
      *data = *__src;
    }
    else {
      if (__src[sVar4 - 1] == ' ') {
        puVar8 = __src + sVar4;
        do {
          sVar4 = sVar4 - 1;
          puVar8[-1] = '\0';
          if (sVar4 == 0) goto LAB_0806018d;
          puVar1 = puVar8 + -2;
          puVar8 = puVar8 + -1;
        } while (*puVar1 == ' ');
      }
      memmove(data,__src,sVar4 + 1);
      if (((check_duplicate != 0) && (*data != '\0')) &&
         (p_00 = (input_history *)(history->entries).next, p_00 != history)) {
        piVar10 = (input_history *)0x0;
        do {
          iVar6 = strcmp((char *)&p_00->size,(char *)data);
          piVar5 = p_00;
          piVar9 = piVar10;
          if (iVar6 == 0) {
            piVar5 = (input_history *)(p_00->entries).prev;
            *(input_history **)((int)(p_00->entries).next + 4) = piVar5;
            *(void **)(p_00->entries).prev = (p_00->entries).next;
            history->size = history->size + -1;
            if ((history->field_0xc & 2) == 0) {
              history->field_0xc = history->field_0xc | 1;
            }
            piVar9 = p_00;
            if (piVar10 != (input_history *)0x0) {
              mem_free(p_00);
              piVar9 = piVar10;
            }
          }
          p_00 = (input_history *)(piVar5->entries).next;
          piVar10 = piVar9;
        } while (p_00 != history);
        if (piVar9 != (input_history *)0x0) {
          pvVar3 = (history->entries).next;
          (piVar9->entries).prev = history;
          (piVar9->entries).next = pvVar3;
          (history->entries).next = piVar9;
          *(input_history **)((int)(piVar9->entries).next + 4) = piVar9;
          history->size = history->size + 1;
          if ((history->field_0xc & 2) != 0) {
            return;
          }
          history->field_0xc = history->field_0xc | 1;
          return;
        }
      }
      ppvVar7 = (void **)mem_alloc(sVar4 + 0xc);
      if (ppvVar7 != (void **)0x0) {
        memcpy(ppvVar7 + 2,data,sVar4 + 1);
        pvVar3 = (history->entries).next;
        ppvVar7[1] = history;
        *ppvVar7 = pvVar3;
        (history->entries).next = ppvVar7;
        *(void ***)((int)*ppvVar7 + 4) = ppvVar7;
        iVar6 = history->size + 1;
        history->size = iVar6;
        if ((history->field_0xc & 2) == 0) {
          history->field_0xc = history->field_0xc | 1;
        }
        while (0x100 < iVar6) {
          if (history == (input_history *)(history->entries).next) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
            errline = 0x112;
            elinks_internal("history is empty");
            history->size = 0;
            return;
          }
          p = (int *)(history->entries).prev;
          *(int *)(*p + 4) = p[1];
          *(int *)p[1] = *p;
          history->size = history->size + -1;
          if ((history->field_0xc & 2) == 0) {
            history->field_0xc = history->field_0xc | 1;
          }
          mem_free(p);
          iVar6 = history->size;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int load_input_history(input_history *history,uchar *filename)

{
  option_value *poVar1;
  FILE *__stream;
  uint uVar2;
  uint uVar3;
  char *pcVar4;
  uint *puVar5;
  uint *puVar6;
  uchar *history_file;
  FILE *file;
  int in_GS_OFFSET;
  bool bVar7;
  FILE *pFVar8;
  char *pcVar9;
  uchar auStack_424 [4];
  uchar line [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar9 = "anonymous";
  pFVar8 = (FILE *)cmdline_options;
  poVar1 = get_opt_();
  if ((poVar1->tree == (list_head_elinks *)0x0) &&
     ((elinks_home == (uchar *)0x0 ||
      (pFVar8 = (FILE *)elinks_home, pcVar9 = (char *)filename,
      filename = straconcat(elinks_home,filename,0), (FILE *)filename != (FILE *)0x0)))) {
    pcVar9 = "rb";
    pFVar8 = (FILE *)filename;
    __stream = fopen64((char *)filename,"rb");
    if (elinks_home != (uchar *)0x0) {
      mem_free(filename);
      pFVar8 = (FILE *)filename;
    }
    if (__stream != (FILE *)0x0) {
      history->field_0xc = history->field_0xc | 2;
      while( true ) {
        pcVar9 = (char *)0x400;
        pcVar4 = fgets((char *)line,0x400,__stream);
        if (pcVar4 == (char *)0x0) break;
        puVar6 = (uint *)line;
        if (line[0] != '\0') {
          do {
            puVar5 = puVar6;
            uVar2 = *puVar5 + 0xfefefeff & ~*puVar5;
            uVar3 = uVar2 & 0x80808080;
            puVar6 = puVar5 + 1;
          } while (uVar3 == 0);
          bVar7 = (uVar2 & 0x8080) == 0;
          if (bVar7) {
            uVar3 = uVar3 >> 0x10;
          }
          if (bVar7) {
            puVar6 = (uint *)((int)puVar5 + 6);
          }
          *(uchar *)((int)puVar6 +
                    (int)(auStack_424 + (-(int)line - (uint)CARRY1((byte)uVar3,(byte)uVar3)))) =
               '\0';
        }
        add_to_input_history(history,line,0);
      }
      history->field_0xc = history->field_0xc & 0xfd;
      fclose(__stream);
      pFVar8 = __stream;
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(pFVar8,pcVar9);
  }
  return 0;
}



// WARNING: Unknown calling convention

void tab_complete_file_menu(terminal *term,void *path_,void *dlg_data_)

{
  auto_complete_file(term,0,(uchar *)path_,set_complete_file_menu,tab_complete_file_menu,dlg_data_);
  return;
}



// WARNING: Unknown calling convention

void do_tab_compl_file(dialog_data *dlg_data,list_head_elinks *history)

{
  int iVar1;
  option_value *poVar2;
  
  iVar1 = dlg_data->selected_widget_id;
  poVar2 = get_opt_();
  if (poVar2->tree == (list_head_elinks *)0x0) {
    tab_complete_file_menu(dlg_data->win->term,dlg_data->widgets_data[iVar1].cdata,dlg_data);
  }
  return;
}



// WARNING: Unknown calling convention

void set_complete_file_menu(terminal *term,void *filename_,void *dlg_data_)

{
  int iVar1;
  bool bVar2;
  size_t sVar3;
  dialog_data *dlg_data;
  size_t __n;
  int filenamelen;
  
  iVar1 = *(int *)((int)dlg_data_ + 0x20);
  if ((assert_failed == 0) &&
     (bVar2 = 1 < *(int *)(*(int *)((int)dlg_data_ + iVar1 * 0x30 + 0x28) + 0x2c) - 1U,
     assert_failed = (int)bVar2, bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
    errline = 0xa6;
    elinks_internal((uchar *)"assertion widget_is_textfield(widget_data) failed!");
  }
  sVar3 = strlen((char *)filename_);
  __n = *(int *)(*(int *)((int)dlg_data_ + iVar1 * 0x30 + 0x28) + 0x10) - 1;
  if ((int)sVar3 <= (int)__n) {
    __n = sVar3;
  }
  memcpy(*(void **)((int)dlg_data_ + iVar1 * 0x30 + 0x2c),filename_,__n);
  *(undefined *)(*(int *)((int)dlg_data_ + iVar1 * 0x30 + 0x2c) + __n) = 0;
  iVar1 = iVar1 * 3 + 3;
  *(size_t *)((int)dlg_data_ + iVar1 * 0x10 + 0x14) = __n;
  *(undefined4 *)((int)dlg_data_ + iVar1 * 0x10 + 0x10) = 0;
  mem_free(filename_);
  redraw_dialog((dialog_data *)dlg_data_,1);
  return;
}



// WARNING: Unknown calling convention

void tab_compl_n(dialog_data *dlg_data,uchar *item,int len)

{
  int iVar1;
  bool bVar2;
  size_t __n;
  
  iVar1 = dlg_data->selected_widget_id;
  if ((assert_failed == 0) &&
     (bVar2 = 1 < (dlg_data->widgets_data[iVar1].widget)->type + ~WIDGET_CHECKBOX,
     assert_failed = (int)bVar2, bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
    errline = 0x1f;
    elinks_internal((uchar *)"assertion widget_is_textfield(widget_data) failed!");
  }
  __n = (dlg_data->widgets_data[iVar1].widget)->datalen - 1;
  if (len <= (int)__n) {
    __n = len;
  }
  memcpy(dlg_data->widgets_data[iVar1].cdata,item,__n);
  dlg_data->widgets_data[iVar1].cdata[__n] = '\0';
  dlg_data->widgets_data[iVar1].info.field.cpos = __n;
  dlg_data->widgets_data[iVar1].info.field.vpos = 0;
  redraw_dialog(dlg_data,1);
  return;
}



// WARNING: Unknown calling convention

void menu_tab_compl(terminal *term,void *item_,void *dlg_data_)

{
  size_t len;
  
  len = strlen((char *)item_);
  tab_compl_n((dialog_data *)dlg_data_,(uchar *)item_,len);
  return;
}



// WARNING: Removing unreachable block (ram,0x0806078a)
// WARNING: Unknown calling convention

void do_tab_compl_unambiguous(dialog_data *dlg_data,list_head_elinks *history)

{
  int iVar1;
  uchar uVar2;
  int iVar3;
  int longest_common_match;
  uchar *cur;
  list_head_elinks *plVar4;
  size_t __n;
  string *psVar5;
  void **ppvVar6;
  uchar *puVar7;
  list_head_elinks *__src;
  size_t oldsize;
  uint uVar8;
  uint uVar9;
  input_history_entry *entry;
  list_head_elinks *plVar10;
  size_t newsize;
  uint size;
  uchar *match;
  list_head_elinks *plVar11;
  list_head_elinks *plVar12;
  bool bVar13;
  size_t local_30;
  string completion;
  
  iVar3 = dlg_data->selected_widget_id;
  plVar10 = (list_head_elinks *)history->next;
  if (plVar10 == history) {
    return;
  }
  local_30 = 0;
  plVar12 = plVar10 + 1;
  plVar11 = (list_head_elinks *)0x0;
LAB_080607e8:
  __src = (list_head_elinks *)dlg_data->widgets_data[iVar3].cdata;
  uVar2 = *(uchar *)&plVar10[1].next;
  if (uVar2 != '\0') goto LAB_08060798;
LAB_080607f5:
  __n = 0;
  __src = plVar12;
  do {
    if ((int)__n < dlg_data->widgets_data[iVar3].info.field.cpos) {
LAB_080607d2:
      __n = local_30;
      __src = plVar11;
    }
    else {
      plVar12 = __src;
      if (plVar11 == (list_head_elinks *)0x0) {
        do {
          plVar11 = plVar12;
          uVar8 = (int)plVar11->next + 0xfefefeffU & ~(uint)plVar11->next;
          uVar9 = uVar8 & 0x80808080;
          plVar12 = (list_head_elinks *)&plVar11->prev;
        } while (uVar9 == 0);
        bVar13 = (uVar8 & 0x8080) == 0;
        if (bVar13) {
          uVar9 = uVar9 >> 0x10;
        }
        ppvVar6 = (void **)((int)&plVar11->prev + 2);
        if (!bVar13) {
          ppvVar6 = &plVar11->prev;
        }
        __n = (int)ppvVar6 + ((-3 - (uint)CARRY1((byte)uVar9,(byte)uVar9)) - (int)__src);
      }
      else {
        __src = plVar11;
        if ((int)local_30 <= (int)__n) goto LAB_080607d2;
      }
    }
    plVar10 = (list_head_elinks *)plVar10->next;
    if (plVar10 == history) {
      if (__src == (list_head_elinks *)0x0) {
        return;
      }
      psVar5 = init_string(&completion);
      if (psVar5 == (string *)0x0) {
        return;
      }
      if (assert_failed == 0) {
        if ((int)__n < 0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_0806081b;
        }
        else {
          assert_failed = 0;
          if (__n == 0) goto LAB_08060825;
        }
        iVar1 = __n + completion.length;
        uVar9 = completion.length + 0xffU >> 8;
        uVar8 = completion.length + 0xffU & 0xffffff00;
        size = iVar1 + 0x100U & 0xffffff00;
        if (uVar8 <= size && size + uVar9 * -0x100 != 0) {
          puVar7 = (uchar *)mem_realloc(completion.source,size);
          if (puVar7 == (uchar *)0x0) goto LAB_08060825;
          completion.source = puVar7;
          memset(puVar7 + uVar8,0,size + uVar9 * -0x100);
        }
        if (completion.source != (uchar *)0x0) {
          memcpy(completion.source + completion.length,__src,__n);
          completion.source[iVar1] = '\0';
          completion.length = iVar1;
        }
      }
      else {
LAB_0806081b:
        assert_failed = 0;
      }
LAB_08060825:
      add_to_string(&completion,
                    dlg_data->widgets_data[iVar3].cdata +
                    dlg_data->widgets_data[iVar3].info.field.cpos);
      tab_compl_n(dlg_data,completion.source,completion.length);
      done_string(&completion);
      return;
    }
    plVar12 = plVar10 + 1;
    plVar11 = __src;
    local_30 = __n;
    if (__src == (list_head_elinks *)0x0) goto LAB_080607e8;
    uVar2 = *(uchar *)&plVar10[1].next;
    if (uVar2 == '\0') goto LAB_080607f5;
LAB_08060798:
    plVar4 = plVar12;
    if (uVar2 != *(uchar *)&__src->next) goto LAB_080607f5;
    do {
      plVar4 = (list_head_elinks *)((int)&plVar4->next + 1);
      if (*(uchar *)&plVar4->next == '\0') break;
      __src = (list_head_elinks *)((int)&__src->next + 1);
    } while (*(uchar *)&plVar4->next == *(uchar *)&__src->next);
    __n = (int)plVar4 - (int)plVar12;
    __src = plVar12;
  } while( true );
}



// WARNING: Unknown calling convention

void do_tab_compl(dialog_data *dlg_data,list_head_elinks *history)

{
  list_head_elinks *text;
  terminal *term;
  int iVar1;
  uchar *item;
  int iVar2;
  size_t sVar3;
  input_history_entry *entry;
  list_head_elinks *plVar4;
  int cpos;
  int local_34;
  menu_item *local_20 [4];
  
  term = dlg_data->win->term;
  iVar1 = dlg_data->selected_widget_id;
  sVar3 = dlg_data->widgets_data[iVar1].info.field.cpos;
  local_20[0] = new_menu(FREE_LIST|NO_INTL);
  if (local_20[0] != (menu_item *)0x0) {
    plVar4 = (list_head_elinks *)history->next;
    if (plVar4 != history) {
      local_34 = 0;
      do {
        while( true ) {
          text = plVar4 + 1;
          iVar2 = strncmp((char *)dlg_data->widgets_data[iVar1].cdata,(char *)text,sVar3);
          if (iVar2 != 0) break;
          add_to_menu(local_20,(uchar *)text,(uchar *)0x0,ACT_MAIN_NONE,menu_tab_compl,text,NO_FLAG)
          ;
          local_34 = local_34 + 1;
          plVar4 = (list_head_elinks *)plVar4->next;
          if (plVar4 == history) goto LAB_08060a51;
        }
        plVar4 = (list_head_elinks *)plVar4->next;
      } while (plVar4 != history);
LAB_08060a51:
      if (1 < local_34) {
        do_menu_selected(term,local_20[0],dlg_data,local_34 + -1,0);
        return;
      }
      if (local_34 == 1) {
        item = (uchar *)local_20[0]->data;
        sVar3 = strlen((char *)item);
        tab_compl_n(dlg_data,item,sVar3);
      }
    }
    mem_free(local_20[0]);
  }
  return;
}



// WARNING: Unknown calling convention

void init_leds(module *module)

{
  timer_duration_backup = 0;
  return;
}



// WARNING: Unknown calling convention

void set_led_value(led *led,uchar value)

{
  uint uVar1;
  
  if ((uchar)(*(ushort *)led >> 2) != value) {
    uVar1 = (uint)(*(ushort *)led & 0xfc03) | (uint)value << 2;
    *(short *)led = (short)uVar1;
    *(byte *)led = (byte)uVar1 | 2;
  }
  return;
}



// WARNING: Unknown calling convention

void unset_led_value(led *led)

{
  ushort uVar1;
  
  if ((char)(*(ushort *)led >> 2) != '-') {
    uVar1 = *(ushort *)led & 0xfc03;
    *(ushort *)led = uVar1 | 0xb4;
    *(byte *)led = (byte)uVar1 | 0xb6;
  }
  return;
}



// WARNING: Unknown calling convention

void init_led_panel(led_panel *leds)

{
  int i;
  int iVar1;
  ushort uVar2;
  
  iVar1 = 0;
  do {
    *(byte *)(leds->leds + iVar1) = *(byte *)(leds->leds + iVar1) & 0xfe;
    if ((char)(*(ushort *)(leds->leds + iVar1) >> 2) != '-') {
      uVar2 = *(ushort *)(leds->leds + iVar1) & 0xfc03;
      *(ushort *)(leds->leds + iVar1) = uVar2 | 0xb4;
      *(byte *)(leds->leds + iVar1) = (byte)uVar2 | 0xb6;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 != 6);
  return;
}



// WARNING: Unknown calling convention

led * register_led(session *ses,int number)

{
  byte bVar1;
  led *led;
  
  if ((uint)number < 6) {
    bVar1 = *(byte *)((ses->status).leds.leds + number);
    if ((bVar1 & 1) == 0) {
      *(byte *)((ses->status).leds.leds + number) = bVar1 | 1;
      led = (ses->status).leds.leds + number;
      return led;
    }
  }
  led = (led *)0x0;
  return led;
}



// WARNING: Unknown calling convention

void unregister_led(led *led)

{
  ushort uVar1;
  
  if ((assert_failed == 0) && (assert_failed = (*(byte *)led ^ 1) & 1, assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/leds.c";
    errline = 0x155;
    elinks_internal((uchar *)"assertion led->used__ failed: Attempted to unregister unused led!");
  }
  *(byte *)led = *(byte *)led & 0xfe;
  if ((char)(*(ushort *)led >> 2) != '-') {
    uVar1 = *(ushort *)led & 0xfc03;
    *(ushort *)led = uVar1 | 0xb4;
    *(byte *)led = (byte)uVar1 | 0xb6;
  }
  return;
}



// WARNING: Unknown calling convention

void menu_leds_info(terminal *term,void *xxx,void *xxxx)

{
  uchar *text;
  
  text = msg_text(term,(uchar *)
                       "What the different LEDs indicate:\n\n[SIJP--]\n |||||`- Unused\n ||||`-- Unused\n |||`--- A JavaScript pop-up window was blocked\n ||`---- A JavaScript error has occurred\n |`----- The state of insert mode for text-input form-fields\n |       \'i\' means modeless, \'I\' means insert mode is on\n `------ Whether an SSL connection was used\n\n\'-\' generally indicates that the LED is off."
                 );
  info_box(term,MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE,(uchar *)"LED indicators",ALIGN_LEFT,text);
  return;
}



// WARNING: Unknown calling convention

void draw_leds(session *ses)

{
  led *plVar1;
  byte bVar2;
  terminal *term_00;
  int iVar3;
  terminal *ptVar4;
  int iVar5;
  option_value *poVar6;
  int i;
  tm *__tp;
  tm *loctime;
  size_t sVar7;
  terminal **pptVar8;
  int iVar9;
  int i_1;
  byte *pbVar10;
  uint uVar11;
  uint uVar12;
  terminal *term;
  color_pair *color;
  color_pair *led_color;
  int iVar13;
  int iVar14;
  int i_2;
  int y;
  int ypos;
  char *x;
  int in_GS_OFFSET;
  bool bVar15;
  timer_id_T *pptVar16;
  char *x_00;
  terminal *local_88;
  undefined4 local_64;
  uchar s [64];
  int local_20;
  
  color = (color_pair *)0x0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  term_00 = ses->tab->term;
  iVar3 = term_00->width;
  iVar5 = iVar3 + -9;
  term_00->leds_length = 0;
  x_00 = "ui.timer.enable";
  y = term_00->height + -1;
  pptVar16 = (timer_id_T *)config_options;
  poVar6 = get_opt_();
  if (poVar6->tree == (list_head_elinks *)0x2) {
    x_00 = "status.status-text";
    pptVar16 = (timer_id_T *)term_00;
    color = get_bfu_color(term_00,(uchar *)"status.status-text");
    if (color != (color_pair *)0x0) {
      iVar13 = term_00->leds_length;
      iVar14 = get_timer_duration();
      x_00 = (char *)0x40;
      pptVar16 = (timer_id_T *)(terminal *)s;
      __snprintf_chk((terminal *)s,0x40,1,0x40,&DAT_08127765,iVar14);
      ptVar4 = (terminal *)s;
      do {
        local_88 = ptVar4;
        uVar11 = (uint)(local_88->next[-0xbf43].cwd + 0xbf) & ~(uint)local_88->next;
        uVar12 = uVar11 & 0x80808080;
        ptVar4 = (terminal *)&local_88->prev;
      } while (uVar12 == 0);
      bVar15 = (uVar11 & 0x8080) == 0;
      if (bVar15) {
        uVar12 = uVar12 >> 0x10;
      }
      pptVar8 = &local_88->prev;
      if (bVar15) {
        pptVar8 = (terminal **)((int)&local_88->prev + 2);
      }
      iVar14 = (int)pptVar8 + ((-3 - (uint)CARRY1((byte)uVar12,(byte)uVar12)) - (int)(terminal *)s);
      iVar9 = iVar14 + -1;
      if (-1 < iVar9) {
        pbVar10 = (byte *)((int)(terminal *)s + iVar9);
        x = (char *)((iVar14 + -1 + iVar5) - iVar14);
        do {
          bVar2 = *pbVar10;
          pbVar10 = pbVar10 + -1;
          pptVar16 = (timer_id_T *)term_00;
          x_00 = x;
          draw_char(term_00,(int)x,y,(uint)bVar2,0,color);
          iVar9 = iVar9 + -1;
          x = x + -1;
        } while (-1 < iVar9);
      }
      term_00->leds_length = iVar14 + iVar13;
      goto LAB_08060cdd;
    }
  }
  else {
LAB_08060cdd:
    if (led_options[5].option_elinks.value.tree == (list_head_elinks *)0x0) goto LAB_08060de3;
    if (color == (color_pair *)0x0) {
      x_00 = "status.status-text";
      pptVar16 = (timer_id_T *)term_00;
      color = get_bfu_color(term_00,(uchar *)"status.status-text");
      if (color == (color_pair *)0x0) goto end;
    }
    if (led_options[1].option_elinks.value.tree != (list_head_elinks *)0x0) {
      iVar13 = term_00->leds_length;
      local_64 = time((time_t *)0x0);
      __tp = localtime(&local_64);
      sVar7 = strftime((char *)s,0x40,(char *)led_options[2].option_elinks.value.string,__tp);
      iVar14 = sVar7 - 1;
      s[sVar7] = '\0';
      if (-1 < iVar14) {
        pbVar10 = s + iVar14;
        iVar9 = ((sVar7 - 1) + (iVar5 - iVar13)) - sVar7;
        do {
          bVar2 = *pbVar10;
          pbVar10 = pbVar10 + -1;
          draw_char(term_00,iVar9,y,(uint)bVar2,0,color);
          iVar14 = iVar14 + -1;
          iVar9 = iVar9 + -1;
        } while (-1 < iVar14);
      }
      term_00->leds_length = sVar7 + iVar13;
    }
    draw_char(term_00,iVar5,y,0x5b,0,color);
    iVar5 = iVar3 + -8;
    iVar13 = 0;
    do {
      iVar14 = iVar13 + 1;
      draw_char(term_00,iVar5,y,(uint)(byte)(*(ushort *)((ses->status).leds.leds + iVar13) >> 2),0,
                color);
      plVar1 = (ses->status).leds.leds + iVar13;
      *(byte *)plVar1 = *(byte *)plVar1 & 0xfd;
      iVar5 = iVar5 + 1;
      iVar13 = iVar14;
    } while (iVar14 != 6);
    x_00 = (char *)(iVar3 + -2);
    pptVar16 = (timer_id_T *)term_00;
    draw_char(term_00,(int)x_00,y,0x5d,0,color);
    term_00->leds_length = term_00->leds_length + 8;
  }
end:
  if ((drawing == 0) && (redraw_timer == (timer_id_T)0x0)) {
    x_00 = (char *)0x64;
    pptVar16 = &redraw_timer;
    install_timer(&redraw_timer,100,redraw_leds,(void *)0x0);
  }
LAB_08060de3:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(pptVar16,x_00);
  }
  return;
}



// WARNING: Unknown calling convention

void redraw_leds(void *xxx)

{
  session *ses_00;
  option_value *poVar1;
  int timer_duration;
  int i;
  int iVar2;
  session *ses;
  
  if ((led_options[5].option_elinks.value.tree == (list_head_elinks *)0x0) &&
     (poVar1 = get_opt_(), poVar1->tree != (list_head_elinks *)0x2)) {
    redraw_timer = (timer_id_T)0x0;
  }
  else {
    install_timer(&redraw_timer,100,redraw_leds,(void *)0x0);
    if (drawing == 0) {
      drawing = 1;
      ses_00 = (session *)sessions.next;
      do {
        if (ses_00 == (session *)&sessions) {
          drawing = 0;
          return;
        }
        iVar2 = timer_duration_backup;
        if (led_options[1].option_elinks.value.tree == (list_head_elinks *)0x0) {
          i = 0;
          do {
            if ((*(byte *)((ses_00->status).leds.leds + i) & 2) != 0) goto LAB_08061148;
            i = i + 1;
          } while (i != 6);
          iVar2 = get_timer_duration();
          if (iVar2 != timer_duration_backup) goto LAB_08061148;
        }
        else {
LAB_08061148:
          timer_duration_backup = iVar2;
          redraw_terminal(ses_00->tab->term);
          draw_leds(ses_00);
        }
        ses_00 = ses_00->next;
      } while( true );
    }
  }
  return;
}



// WARNING: Unknown calling convention

void done_leds(module *module)

{
  kill_timer(&redraw_timer);
  return;
}



// WARNING: Unknown calling convention

void add_dlg_listbox(dialog *dlg,void *box_data)

{
  int iVar1;
  
  iVar1 = dlg->number_of_widgets;
  dlg->number_of_widgets = iVar1 + 1;
  dlg->widgets[iVar1].type = WIDGET_LISTBOX;
  dlg->widgets[iVar1].data = box_data;
  return;
}



// WARNING: Unknown calling convention

listbox_item *
traverse_listbox_items_list
          (listbox_item *item,listbox_data *box,int offset,int follow_visible,
          _func_int_listbox_item_ptr_void_ptr_int_ptr *fn,void *d)

{
  byte bVar1;
  bool bVar2;
  bool bVar3;
  int iVar4;
  int levmove;
  listbox_item *plVar5;
  int stop;
  listbox_item *cnext;
  listbox_item *croot;
  listbox_item *plVar6;
  listbox_item *cprev;
  listbox_item *plVar7;
  bool bVar8;
  listbox_item *local_24;
  
  if (item == (listbox_item *)0x0) {
    return (listbox_item *)0x0;
  }
  bVar8 = offset == 0;
  if (bVar8) {
    offset = 1;
  }
  local_24 = item;
  bVar2 = false;
  plVar5 = local_24;
LAB_08061208:
  local_24 = plVar5;
  plVar6 = item;
  if (bVar2) {
    return local_24;
  }
  do {
    if (offset == 0) {
      return local_24;
    }
    item = (*box->ops->get_root)(plVar6);
    plVar7 = plVar6->prev;
    plVar5 = plVar6->next;
    if ((fn != (_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0) &&
       ((follow_visible == 0 || ((plVar6->field_0x18 & 2) != 0)))) {
      iVar4 = (*fn)(plVar6,d,&offset);
      if (iVar4 != 0) {
        plVar6 = (listbox_item *)0x0;
      }
      if (offset == 0) {
        bVar8 = false;
        bVar2 = false;
        item = plVar6;
        plVar5 = local_24;
        goto LAB_08061208;
      }
    }
    if (offset < 1) {
      if (!bVar8) {
        offset = offset + 1;
      }
      bVar3 = false;
      if (item == (listbox_item *)0x0) {
LAB_0806143c:
        item = plVar6;
        bVar2 = true;
        if ((listbox_item *)box->items == plVar7) goto LAB_08061453;
        if (bVar3) goto LAB_08061451;
      }
      else if ((listbox_item *)&item->child == plVar7) {
        plVar5 = (*box->ops->get_root)(item);
        plVar7 = item->prev;
        if (plVar5 == (listbox_item *)0x0) {
          bVar3 = true;
          plVar6 = item;
          goto LAB_0806143c;
        }
        bVar2 = false;
        goto LAB_08061457;
      }
      item = plVar7;
      (*box->ops->get_root)(item);
      iVar4 = follow_visible;
      if (item == (listbox_item *)0x0) goto LAB_08061414;
      if ((list_head_elinks *)(item->child).next == &item->child) goto LAB_0806147a;
      bVar1 = item->field_0x18;
      break;
    }
    if (!bVar8) {
      offset = offset + -1;
    }
    if ((((plVar6 == (listbox_item *)0x0) ||
         (plVar7 = (listbox_item *)(plVar6->child).next, plVar7 == (listbox_item *)&plVar6->child))
        || ((plVar6->field_0x18 & 1) == 0)) ||
       ((follow_visible != 0 && ((plVar6->field_0x18 & 2) == 0)))) {
      plVar7 = (listbox_item *)0x0;
      if (item == (listbox_item *)0x0) {
LAB_08061357:
        if ((plVar5 == (listbox_item *)0x0) || ((listbox_item *)box->items == plVar5)) {
          plVar5 = plVar6;
          if (plVar7 != (listbox_item *)0x0) {
            (*box->ops->get_root)(plVar7);
            plVar5 = plVar7;
          }
          bVar2 = true;
          goto done_down;
        }
      }
      else {
        plVar7 = plVar6;
        if (plVar5 == (listbox_item *)&item->child) {
          while( true ) {
            plVar6 = item;
            item = (*box->ops->get_root)(plVar6);
            plVar5 = plVar6->next;
            if (item == (listbox_item *)0x0) break;
            if ((listbox_item *)&item->child != plVar5) goto LAB_08061370;
            if (plVar7 == (listbox_item *)0x0) {
              plVar7 = plVar6;
            }
          }
          goto LAB_08061357;
        }
      }
LAB_08061370:
      (*box->ops->get_root)(plVar5);
      bVar2 = false;
    }
    else {
      (*box->ops->get_root)(plVar7);
      bVar2 = false;
      plVar5 = plVar7;
    }
done_down:
    if ((plVar5 != (listbox_item *)0x0) &&
       ((item = plVar5, follow_visible == 0 || ((plVar5->field_0x18 & 2) != 0)))) goto LAB_08061208;
    offset = offset + 1;
    plVar6 = plVar5;
    if (bVar2) {
      return local_24;
    }
  } while( true );
joined_r0x080613d6:
  if ((bVar1 & 1) == 0) goto LAB_0806147a;
  if ((iVar4 != 0) && ((bVar1 & 2) == 0)) goto LAB_08061451;
  item = (listbox_item *)(item->child).prev;
  (*box->ops->get_root)(item);
  if (item == (listbox_item *)0x0) goto LAB_08061414;
  if ((list_head_elinks *)(item->child).next == &item->child) goto LAB_0806147a;
  bVar1 = item->field_0x18;
  goto joined_r0x080613d6;
LAB_08061451:
  bVar2 = false;
LAB_08061453:
  if (item == (listbox_item *)0x0) goto LAB_0806146c;
LAB_08061457:
  plVar5 = item;
  if ((follow_visible == 0) || ((item->field_0x18 & 2) != 0)) goto LAB_08061208;
LAB_0806146c:
  offset = offset + -1;
  plVar5 = local_24;
  goto LAB_08061208;
LAB_08061414:
  bVar2 = false;
  item = (listbox_item *)0x0;
  goto LAB_0806146c;
LAB_0806147a:
  bVar2 = false;
  goto LAB_08061457;
}



// WARNING: Unknown calling convention

int calc_dist(listbox_item *item,void *data_,int *offset)

{
  if (-1 < *offset) {
    if (*offset != 0) {
                    // WARNING: Load size is inaccurate
      *(int *)data_ = *data_ + 1;
    }
    return 0;
  }
                    // WARNING: Load size is inaccurate
  *(int *)data_ = *data_ + -1;
  return 0;
}



// WARNING: Unknown calling convention

int test_search(listbox_item *item,void *data_,int *offset)

{
  if (*(listbox_item **)((int)data_ + 4) != item) {
    *(int *)((int)data_ + 0x18) = *(int *)((int)data_ + 0x18) + 1;
    return 0;
  }
  *offset = 0;
  return 0;
}



// WARNING: Unknown calling convention

int check_old_state(listbox_item *item,void *info_,int *offset)

{
  if (*(listbox_item **)((int)info_ + 0xc) == item) {
    *(undefined4 *)((int)info_ + 0xc) = 0;
  }
  else {
    if (*(listbox_item **)((int)info_ + 0x10) == item) {
      *(undefined4 *)((int)info_ + 0x10) = 0;
    }
    if (*(listbox_item **)((int)info_ + 0xc) != (listbox_item *)0x0) {
      return 0;
    }
  }
  if (*(int *)((int)info_ + 0x10) == 0) {
    *offset = 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

listbox_data * get_listbox_widget_data(widget_data *widget_data)

{
  bool bVar1;
  
  if ((assert_failed == 0) &&
     (bVar1 = widget_data->widget->type != WIDGET_LISTBOX, assert_failed = (int)bVar1, bVar1)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
    errline = 0x26;
    elinks_internal((uchar *)"assertion widget_data->widget->type == WIDGET_LISTBOX failed!");
    return (listbox_data *)widget_data->widget->data;
  }
  return (listbox_data *)widget_data->widget->data;
}



// WARNING: Unknown calling convention

widget_handler_status_T init_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  listbox_ops *plVar2;
  listbox_data *plVar3;
  listbox_data *box_00;
  listbox_item *plVar4;
  listbox_item *plVar5;
  listbox_data *box;
  hierbox_browser *browser;
  
  pvVar1 = dlg_data->dlg->udata2;
  box_00 = get_listbox_widget_data(widget_data);
  if ((*(list_head_elinks **)((int)pvVar1 + 0x28) == (list_head_elinks *)((int)pvVar1 + 0x28)) ||
     (*(int *)((int)pvVar1 + 0x5c) == 0)) goto LAB_08061692;
  box_00->next = *(listbox_data **)((int)pvVar1 + 0x44);
  box_00->prev = *(listbox_data **)((int)pvVar1 + 0x48);
  box_00->ops = *(listbox_ops **)((int)pvVar1 + 0x4c);
  box_00->sel = *(listbox_item **)((int)pvVar1 + 0x50);
  box_00->top = *(listbox_item **)((int)pvVar1 + 0x54);
  box_00->sel_offset = *(int *)((int)pvVar1 + 0x58);
  box_00->items = *(list_head_elinks **)((int)pvVar1 + 0x5c);
  traverse_listbox_items_list
            (*(listbox_item **)((int)pvVar1 + 0x28),box_00,0,0,check_old_state,box_00);
  plVar5 = (listbox_item *)0x0;
  if (box_00->sel == (listbox_item *)0x0) {
    plVar5 = *(listbox_item **)((int)pvVar1 + 0x50);
    box_00->sel = plVar5;
    if (box_00->top == (listbox_item *)0x0) goto LAB_080616d0;
LAB_08061687:
    plVar4 = (listbox_item *)0x0;
    box_00->top = (listbox_item *)0x0;
  }
  else {
    box_00->sel = (listbox_item *)0x0;
    if (box_00->top != (listbox_item *)0x0) goto LAB_08061687;
LAB_080616d0:
    plVar4 = *(listbox_item **)((int)pvVar1 + 0x54);
    box_00->top = plVar4;
  }
  if (plVar5 == (listbox_item *)0x0) {
    box_00->sel = plVar4;
  }
  if (plVar4 == (listbox_item *)0x0) {
    box_00->top = box_00->sel;
  }
LAB_08061692:
  plVar2 = *(listbox_ops **)((int)pvVar1 + 0x40);
  box_00->items = (list_head_elinks *)((int)pvVar1 + 0x28);
  box_00->ops = plVar2;
  plVar3 = *(listbox_data **)((int)pvVar1 + 0x10);
  box_00->prev = (listbox_data *)((int)pvVar1 + 0x10);
  box_00->next = plVar3;
  *(listbox_data **)((int)pvVar1 + 0x10) = box_00;
  box_00->next->prev = box_00;
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void listbox_sel_move(widget_data *widget_data,int dist)

{
  listbox_item *plVar1;
  int iVar2;
  listbox_data *box_00;
  listbox_item *item;
  listbox_item *plVar3;
  listbox_data *box;
  
  box_00 = get_listbox_widget_data(widget_data);
  plVar3 = ((listbox_item *)box_00->items)->next;
  if ((listbox_item *)box_00->items == plVar3) {
    return;
  }
  item = box_00->top;
  if (item == (listbox_item *)0x0) {
    plVar1 = box_00->sel;
    box_00->top = plVar3;
    item = plVar3;
  }
  else {
    plVar1 = box_00->sel;
  }
  if (plVar1 == (listbox_item *)0x0) {
    box_00->sel = item;
    item = box_00->top;
  }
  if ((item == (listbox_item *)0x0) || ((item->field_0x18 & 2) != 0)) {
    plVar3 = box_00->sel;
  }
  else {
    plVar3 = traverse_listbox_items_list
                       (item,box_00,1,1,(_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,
                        (void *)0x0);
    box_00->top = plVar3;
    box_00->sel = plVar3;
  }
  if (dist == 0) {
    if ((plVar3->field_0x18 & 2) != 0) goto LAB_08061775;
    dist = 1;
  }
  plVar3 = traverse_listbox_items_list(plVar3,box_00,dist,1,calc_dist,&box_00->sel_offset);
  box_00->sel = plVar3;
LAB_08061775:
  if (box_00->sel_offset < 0) {
    box_00->sel_offset = 0;
    box_00->top = box_00->sel;
  }
  else {
    iVar2 = (widget_data->box).height;
    if (iVar2 <= box_00->sel_offset) {
      box_00->sel_offset = iVar2 + -1;
      plVar3 = traverse_listbox_items_list
                         (box_00->sel,box_00,1 - (widget_data->box).height,1,
                          (_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,(void *)0x0);
      box_00->top = plVar3;
    }
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T kbd_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_data *widget_data_00;
  listbox_item *plVar1;
  listbox_ops *plVar2;
  listbox_data *box_3;
  action_id_T aVar3;
  listbox_data *box_2;
  listbox_data *plVar4;
  listbox_data *box;
  term_event *ev;
  widget_data *dlg_item;
  int iVar5;
  
  if (dlg_data->term_event->ev != EVENT_KBD) {
    return EVENT_NOT_PROCESSED;
  }
  widget_data_00 = dlg_data->widgets_data;
  aVar3 = kbd_action(KEYMAP_MENU,dlg_data->term_event,(int *)0x0);
  switch(aVar3) {
  case 3:
    plVar4 = get_listbox_widget_data(widget_data_00);
    plVar2 = plVar4->ops;
    if (((plVar2 != (listbox_ops *)0x0) &&
        (plVar2->delete != (_func_void_listbox_item_ptr_int *)0x0)) &&
       (plVar2->can_delete != (_func_int_listbox_item_ptr *)0x0)) {
      push_hierbox_delete_button(dlg_data,widget_data);
      return EVENT_PROCESSED;
    }
    return EVENT_PROCESSED;
  case 4:
    iVar5 = 1;
    break;
  case 5:
    iVar5 = 0x7fffffff;
    break;
  default:
    return EVENT_NOT_PROCESSED;
  case 8:
    iVar5 = -0x7fffffff;
    break;
  case 10:
    plVar4 = get_listbox_widget_data(widget_data_00);
    plVar1 = plVar4->sel;
    if (plVar1 != (listbox_item *)0x0) {
      plVar1->field_0x18 =
           plVar1->field_0x18 & 0xfb | (byte)((((byte)plVar1->field_0x18 >> 2 ^ 1) & 1) << 2);
      listbox_sel_move(widget_data_00,1);
    }
    goto LAB_080618c0;
  case 0xc:
    plVar4 = get_listbox_widget_data(widget_data_00);
    iVar5 = (dlg_data->widgets_data[0].box.height * 2 - plVar4->sel_offset) + -1;
    goto LAB_080618e8;
  case 0xd:
    plVar4 = get_listbox_widget_data(widget_data_00);
    iVar5 = -plVar4->sel_offset - dlg_data->widgets_data[0].box.height;
LAB_080618e8:
    listbox_sel_move(widget_data_00,iVar5);
    goto LAB_080618c0;
  case 0x14:
    iVar5 = -1;
  }
  listbox_sel_move(widget_data_00,iVar5);
LAB_080618c0:
  display_widget(dlg_data,widget_data_00);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T mouse_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  term_event *ptVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  listbox_data *box_00;
  int offset;
  widget_handler_status_T wVar5;
  listbox_item *plVar6;
  widget_data *dlg_item;
  int xdepth;
  int iVar7;
  term_event *ev;
  int x;
  listbox_data *box;
  int iVar8;
  
  box_00 = get_listbox_widget_data(widget_data);
  ptVar1 = dlg_data->term_event;
  plVar6 = ((listbox_item *)box_00->items)->next;
  if ((listbox_item *)box_00->items != plVar6) {
    if (box_00->top == (listbox_item *)0x0) {
      box_00->top = plVar6;
      plVar6 = box_00->sel;
    }
    else {
      plVar6 = box_00->sel;
    }
    if (plVar6 == (listbox_item *)0x0) {
      box_00->sel = box_00->top;
    }
  }
  uVar2 = (ptVar1->info).mouse.button;
  if ((uVar2 & 0x20) == 0) {
    if ((uVar2 & 7) == 3) {
      iVar8 = -1;
    }
    else {
      if ((uVar2 & 7) != 4) goto LAB_08061a33;
      iVar8 = 1;
    }
    listbox_sel_move(dlg_data->widgets_data,iVar8);
    display_widget(dlg_data,dlg_data->widgets_data);
    wVar5 = EVENT_PROCESSED;
  }
  else {
LAB_08061a33:
    if ((uVar2 & 7) < 3) {
      iVar8 = (ptVar1->info).mouse.y;
      iVar7 = (ptVar1->info).mouse.x;
      iVar3 = (widget_data->box).x;
      if ((((iVar3 <= iVar7) && (iVar4 = (widget_data->box).y, iVar4 <= iVar8)) &&
          (iVar7 < iVar3 + (widget_data->box).width)) && (iVar8 < iVar4 + (widget_data->box).height)
         ) {
        offset = iVar8 - iVar4;
        box_00->sel_offset = offset;
        if (offset == 0) {
          plVar6 = box_00->top;
        }
        else {
          plVar6 = traverse_listbox_items_list
                             (box_00->top,box_00,offset,1,
                              (_func_int_listbox_item_ptr_void_ptr_int_ptr *)0x0,(void *)0x0);
        }
        box_00->sel = plVar6;
        if ((plVar6 != (listbox_item *)0x0) && (plVar6->type == BI_FOLDER)) {
          iVar8 = (ptVar1->info).mouse.x;
          iVar7 = plVar6->depth * 5 + (widget_data->box).x;
          if ((iVar7 <= iVar8) && (iVar8 <= iVar7 + 2)) {
            plVar6->field_0x18 = plVar6->field_0x18 & 0xfe | (plVar6->field_0x18 ^ 1) & 1;
          }
        }
        display_widget(dlg_data,widget_data);
        return EVENT_PROCESSED;
      }
    }
    wVar5 = EVENT_NOT_PROCESSED;
  }
  return wVar5;
}



// WARNING: Unknown calling convention

int display_listbox_item(listbox_item *item,void *data_,int *offset)

{
  border_char *pbVar1;
  int x_00;
  listbox_item_type lVar2;
  listbox_item *plVar3;
  listbox_item **pplVar4;
  listbox_item *plVar5;
  int iVar6;
  color_pair *color;
  listbox_item *plVar7;
  listbox_item *root_1;
  uchar *string;
  size_t max_cells;
  int len;
  size_t sVar8;
  terminal *term;
  int x;
  int iVar9;
  byte bVar10;
  int y_00;
  size_t sVar11;
  int len_bytes;
  int x_1;
  int i;
  int iVar12;
  int iVar13;
  int i_1;
  listbox_item *root;
  uchar *text;
  int y;
  color_pair *local_5c;
  int local_48;
  int local_44;
  int local_40;
  border_char str [5];
  
  iVar9 = item->depth;
  iVar6 = iVar9 + 1;
                    // WARNING: Load size is inaccurate
  color = get_bfu_color(*data_,"menu.normal");
  if (*(listbox_item **)(*(int *)((int)data_ + 8) + 0xc) == item) {
                    // WARNING: Load size is inaccurate
    local_5c = get_bfu_color(*data_,"menu.selected");
  }
  else {
    local_5c = color;
    if ((item->field_0x18 & 4) != 0) {
                    // WARNING: Load size is inaccurate
      local_5c = get_bfu_color(*data_,"menu.marked");
    }
  }
  y_00 = *(int *)((int)data_ + 0x18) + *(int *)(*(int *)((int)data_ + 0x10) + 0xc);
  if (0 < iVar9) {
    local_44 = 0;
    local_48 = 0;
    plVar7 = item;
    plVar3 = item;
    iVar12 = iVar6;
    local_40 = iVar6;
    do {
      for (; plVar5 = plVar7, iVar12 != 0; iVar12 = iVar12 + -1) {
        plVar7 = (listbox_item *)0x0;
        if (plVar5 != (listbox_item *)0x0) {
          plVar7 = (listbox_item *)
                   (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 0x18))(plVar5);
        }
        plVar3 = plVar5;
      }
      iVar12 = local_44 + *(int *)(*(int *)((int)data_ + 0x10) + 8);
                    // WARNING: Load size is inaccurate
      draw_text(*data_,iVar12,y_00,"     ",5,0,color);
      if (plVar5 == (listbox_item *)0x0) {
        plVar7 = *(listbox_item **)(*(int *)(*(int *)((int)data_ + 8) + 0x18) + 4);
      }
      else {
        plVar7 = (listbox_item *)(plVar5->child).prev;
      }
      if (plVar7 != plVar3) {
                    // WARNING: Load size is inaccurate
        draw_border_char(*data_,iVar12 + 1,y_00,BORDER_SVLINE,color);
      }
      local_48 = local_48 + 1;
      iVar12 = local_40 + -1;
      local_44 = local_44 + 5;
      plVar7 = item;
      plVar3 = item;
      local_40 = iVar12;
    } while (local_48 < iVar9);
  }
  if (iVar6 == 0) goto LAB_08061d5c;
  str[0] = 0x20;
  str[1] = BORDER_SRTEE;
  str[2] = BORDER_SHLINE;
  str[3] = BORDER_SHLINE;
  str[4] = 0x20;
  lVar2 = item->type;
  if (lVar2 == BI_FOLDER) {
    bVar10 = item->field_0x18;
    str[0] = 0x5b;
    str[2] = 0x5d;
    str[1] = (-(uint)((bVar10 & 1) == 0) & 0xfffffffe) + 0x2d;
  }
  else if ((lVar2 == BI_LEAF) || (lVar2 == BI_SEPARATOR)) {
    iVar12 = (**(code **)(*(int *)(*(int *)((int)data_ + 8) + 8) + 0x18))(item);
    if (iVar12 == 0) {
      pplVar4 = *(listbox_item ***)(*(int *)((int)data_ + 8) + 0x18);
      if (*pplVar4 != item) {
        plVar3 = pplVar4[1];
        goto joined_r0x08062010;
      }
      str[1] = BORDER_SULCORNER;
    }
    else {
      plVar3 = *(listbox_item **)(iVar12 + 0xc);
joined_r0x08062010:
      if (plVar3 == item) {
        str[1] = BORDER_SDLCORNER;
        bVar10 = item->field_0x18;
        goto LAB_08061d05;
      }
    }
    bVar10 = item->field_0x18;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
    errline = 0x1aa;
    elinks_internal((uchar *)"Unknown item type");
    bVar10 = item->field_0x18;
  }
LAB_08061d05:
  if ((bVar10 & 4) != 0) {
    str[4] = 0x2a;
  }
  iVar13 = 0;
  iVar12 = *(int *)(*(int *)((int)data_ + 0x10) + 8);
  do {
    pbVar1 = str + iVar13;
    x_00 = iVar13 + iVar9 * 5 + iVar12;
    iVar13 = iVar13 + 1;
                    // WARNING: Load size is inaccurate
    draw_border_char(*data_,x_00,y_00,*pbVar1,color);
  } while (iVar13 != 5);
LAB_08061d5c:
  iVar9 = *(int *)((int)data_ + 0x10);
  iVar12 = *(int *)(iVar9 + 8) + iVar6 * 5;
  if (item->type == BI_SEPARATOR) {
    iVar9 = iVar6 * -5 + *(int *)(iVar9 + 0x10);
    if (0 < iVar9) {
      iVar6 = 0;
      do {
        iVar13 = iVar6 + iVar12;
        iVar6 = iVar6 + 1;
                    // WARNING: Load size is inaccurate
        draw_border_char(*data_,iVar13,y_00,BORDER_SHLINE,local_5c);
      } while (iVar6 < iVar9);
    }
  }
  else {
    iVar13 = *(int *)(*(int *)((int)data_ + 8) + 8);
    if ((iVar13 == 0) || (*(code **)(iVar13 + 0x28) == (code *)0x0)) {
      if (assert_failed == 0) {
        if ((iVar13 == 0) || (*(int *)(iVar13 + 0x10) == 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
          errline = 0x1ca;
          elinks_internal((uchar *)"assertion ops && ops->get_info failed!");
        }
        else {
          assert_failed = 0;
        }
      }
                    // WARNING: Load size is inaccurate
      string = (uchar *)(**(code **)(iVar13 + 0xc))(item,*data_);
      if (string == (uchar *)0x0) {
        return 0;
      }
      max_cells = strlen((char *)string);
      sVar11 = iVar6 * -5 + *(int *)(*(int *)((int)data_ + 0x10) + 0x10);
      sVar8 = 0;
      if (-1 < (int)sVar11) {
        sVar8 = sVar11;
      }
      if ((int)sVar8 < (int)max_cells) {
        max_cells = sVar8;
      }
                    // WARNING: Load size is inaccurate
      term = *data_;
      if ((term->field_0x38 & 2) != 0) {
        max_cells = utf8_cells2bytes(string,max_cells,(uchar *)0x0);
                    // WARNING: Load size is inaccurate
        term = *data_;
      }
      draw_text(term,iVar12,y_00,string,max_cells,0,local_5c);
      mem_free(string);
    }
    else {
      (**(code **)(iVar13 + 0x28))(item,data_,iVar12,y_00,iVar6 * -5 + *(int *)(iVar9 + 0x10));
    }
  }
  if (*(listbox_item **)(*(int *)((int)data_ + 8) + 0xc) == item) {
    iVar9 = *(int *)(*(int *)((int)data_ + 0x10) + 8) + 5 + item->depth * 5;
                    // WARNING: Load size is inaccurate
    set_cursor(*data_,iVar9,y_00,1);
    *(int *)(**(int **)((int)data_ + 0xc) + 0x20) = iVar9;
    *(int *)(**(int **)((int)data_ + 0xc) + 0x24) = y_00;
  }
  *(int *)((int)data_ + 0x18) = *(int *)((int)data_ + 0x18) + 1;
  return 0;
}



// WARNING: Unknown calling convention

void dlg_format_listbox(terminal *term,widget_data *widget_data,int x,int *y,int w,int max_height,
                       int *rw,format_align align,int format_only)

{
  option_value *poVar1;
  int iVar2;
  int min;
  int iVar3;
  int height;
  int iVar4;
  
  poVar1 = get_opt_();
  iVar3 = poVar1->number;
  iVar4 = max_height + -3;
  if (iVar3 <= max_height + -3) {
    iVar4 = (max_height * 7) / 10 + -3;
    if (iVar4 < iVar3) {
      iVar4 = iVar3;
    }
  }
  iVar3 = *y;
  if (x < 0) {
    x = 0;
  }
  if (iVar3 < 0) {
    iVar3 = 0;
  }
  (widget_data->box).x = x;
  (widget_data->box).y = iVar3;
  iVar3 = w;
  if (w < 0) {
    iVar3 = 0;
  }
  iVar2 = 0;
  if (-1 < iVar4) {
    iVar2 = iVar4;
  }
  (widget_data->box).width = iVar3;
  (widget_data->box).height = iVar2;
  *y = *y + iVar4;
  if (rw != (int *)0x0) {
    *rw = w;
  }
  return;
}



// WARNING: Unknown calling convention

int listbox_item_offset(listbox_data *box,listbox_item *item)

{
  uint uVar1;
  listbox_context ctx;
  
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&ctx.term + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x1c);
  ctx.offset = 0;
  ctx.item = item;
  traverse_listbox_items_list((listbox_item *)box->items->next,box,0,1,test_search,&ctx);
  return ctx.offset;
}



// WARNING: Unknown calling convention

void listbox_sel(widget_data *widget_data,listbox_item *item)

{
  listbox_data *box_00;
  int iVar1;
  int iVar2;
  listbox_data *box;
  
  box_00 = get_listbox_widget_data(widget_data);
  iVar1 = listbox_item_offset(box_00,item);
  iVar2 = listbox_item_offset(box_00,box_00->sel);
  listbox_sel_move(widget_data,iVar1 - iVar2);
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_listbox(dialog_data *dlg_data,widget_data *widget_data)

{
  color_pair *color;
  uint uVar1;
  terminal *term;
  listbox_context data;
  
  data.term = dlg_data->win->term;
  data.box = get_listbox_widget_data(widget_data);
  listbox_sel_move(widget_data,0);
  color = get_bfu_color(data.term,"menu.normal");
  draw_box(data.term,&widget_data->box,' ',0,color);
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&data.term + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x1c);
  data.widget_data = widget_data;
  data.dlg_data = dlg_data;
  traverse_listbox_items_list
            ((data.box)->top,data.box,(widget_data->box).height,1,display_listbox_item,&data);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

int menu_contains(menu_item *m,int f)

{
  uchar *puVar1;
  int iVar2;
  menu_item *m_00;
  
  if (m->func != do_select_submenu) {
    return (uint)(m->data == (void *)f);
  }
  m_00 = (menu_item *)m->data;
  puVar1 = m_00->text;
  while( true ) {
    if (puVar1 == (uchar *)0x0) {
      return 0;
    }
    iVar2 = menu_contains(m_00,f);
    if (iVar2 != 0) break;
    m_00 = m_00 + 1;
    puVar1 = m_00->text;
  }
  return 1;
}



// WARNING: Unknown calling convention

void menu_labels(menu_item *items,uchar *base,uchar **lbls)

{
  uchar *puVar1;
  menu_func_T p_Var2;
  menu_item *item;
  uchar *local_20 [4];
  
  puVar1 = items->text;
  while (puVar1 != (uchar *)0x0) {
    local_20[0] = "";
    if ((*(byte *)&items->flags & 0x10) == 0) {
      local_20[0] = base;
    }
    local_20[0] = straconcat(local_20[0],items->text,0);
    if (local_20[0] != (uchar *)0x0) {
      p_Var2 = items->func;
      if (p_Var2 == do_select_submenu) {
        add_to_strn(local_20," ");
        menu_labels((menu_item *)items->data,local_20[0],lbls);
        mem_free(local_20[0]);
      }
      else {
        if ((assert_failed == 0) &&
           (assert_failed = (int)(p_Var2 != selected_item), p_Var2 != selected_item)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
          errline = 0xbc;
          elinks_internal((uchar *)"assertion item->func == selected_item failed!");
        }
        lbls[(int)items->data] = local_20[0];
      }
    }
    items = items + 1;
    puVar1 = items->text;
  }
  return;
}



// WARNING: Unknown calling convention

menu_item * detach_menu(list_menu *menu)

{
  menu_item **p;
  menu_item *pmVar1;
  menu_item *i;
  
  pmVar1 = (menu_item *)0x0;
  p = menu->stack;
  if (p != (menu_item **)0x0) {
    if (menu->stack_size != 0) {
      pmVar1 = *p;
    }
    mem_free(p);
  }
  return pmVar1;
}



// WARNING: Unknown calling convention

void free_menu(menu_item *m)

{
  uchar *p;
  menu_item *mm;
  menu_item *pmVar1;
  
  if (m != (menu_item *)0x0) {
    p = m->text;
    pmVar1 = m;
    while (p != (uchar *)0x0) {
      mem_free(p);
      if (pmVar1->func == do_select_submenu) {
        free_menu((menu_item *)pmVar1->data);
      }
      pmVar1 = pmVar1 + 1;
      p = pmVar1->text;
    }
    mem_free(m);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void destroy_menu(list_menu *menu)

{
  if (menu->stack != (menu_item **)0x0) {
    free_menu(*menu->stack);
  }
  detach_menu(menu);
  return;
}



// WARNING: Unknown calling convention

void new_menu_item(list_menu *menu,uchar *name,int data,int fullname)

{
  uint uVar1;
  uchar *puVar2;
  menu_item_flags flags;
  menu_item *new_menu_item;
  menu_item *below;
  menu_item *pmVar3;
  menu_item **ppmVar4;
  menu_item **items;
  int iVar5;
  code *func;
  
  uVar1 = menu->stack_size;
  if (name == (uchar *)0x0) {
    menu->stack_size = uVar1 - 1;
    return;
  }
  if ((data == -1) || (uVar1 != 0)) {
    clr_spaces(name);
    if (*name == '\0') {
      mem_free(name);
      name = stracpy(" ");
      if (name == (uchar *)0x0) {
        return;
      }
    }
    if (data != -1) {
      items = menu->stack + (uVar1 - 1);
      func = selected_item;
      flags = ~-(uint)(fullname == 0) & MENU_FULLNAME;
LAB_08062540:
      add_to_menu(items,name,(uchar *)0x0,ACT_MAIN_NONE,func,(void *)data,flags);
      if (1 < uVar1) {
        pmVar3 = menu->stack[uVar1 - 2];
        puVar2 = pmVar3->text;
        while (puVar2 != (uchar *)0x0) {
          pmVar3 = pmVar3 + 1;
          puVar2 = pmVar3->text;
        }
        pmVar3[-1].data = *items;
      }
      return;
    }
    ppmVar4 = (menu_item **)mem_realloc(menu->stack,menu->stack_size * 4 + 4);
    if (ppmVar4 != (menu_item **)0x0) {
      menu->stack = ppmVar4;
      data = (int)new_menu(NO_INTL);
      if ((menu_item *)data != (menu_item *)0x0) {
        iVar5 = menu->stack_size;
        menu->stack[iVar5] = (menu_item *)data;
        iVar5 = iVar5 + 1;
        menu->stack_size = iVar5;
        if (iVar5 != 1) {
          items = menu->stack + (uVar1 - 1);
          flags = SUBMENU;
          func = do_select_submenu;
          goto LAB_08062540;
        }
      }
    }
  }
  mem_free(name);
  return;
}



// WARNING: Unknown calling convention

void add_select_item(list_menu *menu,string *string,string *orig_string,uchar **value,int order,
                    int dont_add)

{
  uchar *puVar1;
  uint data;
  int pos;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(menu == (list_menu *)0x0 || string == (string *)0x0),
     menu == (list_menu *)0x0 || string == (string *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
    errline = 0xc9;
    elinks_internal((uchar *)"assertion menu && string failed!");
    puVar1 = string->source;
  }
  else {
    puVar1 = string->source;
  }
  if (puVar1 != (uchar *)0x0) {
    data = order - 1;
    if ((assert_failed == 0) &&
       (assert_failed = data >> 0x1f | (uint)(value == (uchar **)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
      errline = 0xcd;
      elinks_internal((uchar *)"assertion value && pos >= 0 failed!");
    }
    if (value[data] == (uchar *)0x0) {
      puVar1 = memacpy(orig_string->source,orig_string->length);
      value[data] = puVar1;
    }
    if (dont_add == 0) {
      new_menu_item(menu,string->source,data,1);
      string->source = (uchar *)0x0;
      string->length = 0;
    }
    else {
      done_string(string);
    }
    done_string(orig_string);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void init_menu(list_menu *menu)

{
  uchar *name;
  
  menu->stack_size = 0;
  menu->stack = (menu_item **)0x0;
  name = stracpy("");
  new_menu_item(menu,name,-1,0);
  return;
}



// WARNING: Unknown calling convention

void do_select_submenu(terminal *term,void *menu_,void *ses_)

{
  uchar *puVar1;
  menu_item *m_00;
  int iVar2;
  menu_item *m;
  int sel;
  int def;
  int f;
  
  iVar2 = get_current_state((session *)ses_);
                    // WARNING: Load size is inaccurate
  puVar1 = *menu_;
  m_00 = (menu_item *)menu_;
  f = 0;
  if (-1 < iVar2) {
    f = iVar2;
  }
  do {
    if (puVar1 == (uchar *)0x0) {
      sel = 0;
LAB_0806285a:
      do_menu_selected(term,(menu_item *)menu_,ses_,sel,0);
      return;
    }
    iVar2 = menu_contains(m_00,f);
    if (iVar2 != 0) {
      sel = (int)m_00 - (int)menu_ >> 5;
      goto LAB_0806285a;
    }
    puVar1 = m_00[1].text;
    m_00 = m_00 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void deselect_mainmenu(terminal *term,menu *menu)

{
  menu->selected = -1;
  menu->win->next->prev = menu->win->prev;
  menu->win->prev->next = menu->win->next;
                    // WARNING: Load size is inaccurate
  menu->win->next = *(term->windows).prev;
  menu->win->prev = (window *)(term->windows).prev;
  *(window **)(term->windows).prev = menu->win;
  menu->win->next->prev = menu->win;
  return;
}



// WARNING: Unknown calling convention

void set_menu_selection(menu *menu,int pos)

{
  int iVar1;
  int iVar2;
  int scr_i;
  int iVar3;
  int iVar4;
  int height;
  
  if (assert_failed == 0) {
    if ((pos < 0) || (menu->size <= pos)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
      errline = 0x15f;
      elinks_internal((uchar *)"assertion pos >= 0 && pos < menu->size failed!");
      if (assert_failed != 0) goto LAB_080629d8;
    }
    assert_failed = menu->items[pos].flags >> 7 & 1;
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
      errline = 0x160;
      elinks_internal((uchar *)"assertion mi_is_selectable(&menu->items[pos]) failed!");
      if (assert_failed != 0) goto LAB_080629d8;
    }
    iVar3 = (menu->box).height;
    menu->selected = pos;
    iVar1 = iVar3 + -2;
    if ((0 < iVar1) && (iVar1 != 1)) {
      iVar2 = menu->first;
      iVar3 = iVar3 + -3 >> 1;
      if (1 < iVar3) {
        iVar3 = 2;
      }
      iVar4 = iVar3 + 1 + (pos - iVar1);
      if ((iVar2 < iVar4) || (iVar4 = pos - iVar3, iVar4 < iVar2)) {
        iVar3 = menu->size;
        menu->first = iVar4;
        iVar2 = iVar4;
      }
      else {
        iVar3 = menu->size;
      }
      if (iVar2 < 0) {
        menu->first = 0;
      }
      else if (iVar3 - iVar1 < iVar2) {
        menu->first = iVar3 - iVar1;
      }
    }
  }
  else {
LAB_080629d8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void scroll_menu(menu *menu,int steps,int wrap)

{
  int iVar1;
  int pos;
  int start;
  int iVar2;
  int pos_00;
  int iVar3;
  int s;
  int local_28;
  
  iVar3 = 1;
  if (steps != 0) {
    iVar3 = steps / ((steps >> 0x1f ^ steps) - (steps >> 0x1f));
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(menu->selected < -1);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
    errline = 0x11e;
    elinks_internal((uchar *)"assertion menu->selected >= -1 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar1 = menu->size;
  if (iVar1 < 1) {
no_item:
    menu->selected = -1;
    menu->first = 0;
    return;
  }
  iVar2 = menu->selected;
  pos_00 = iVar2;
  if ((steps == 0) && (steps = 1, -1 < iVar2)) {
    pos_00 = iVar2 + -1;
  }
  local_28 = steps - iVar3;
LAB_08062af0:
  pos_00 = pos_00 + iVar3;
  if (iVar2 != pos_00) {
    do {
      if ((pos_00 < iVar1) || (iVar3 != 1)) {
        if ((pos_00 < 0) && (iVar3 == -1)) {
          pos_00 = iVar1 + -1;
          if (wrap == 0) {
            iVar3 = 0;
            pos_00 = 0;
            goto select_item;
          }
        }
        else {
          if (-1 < *(char *)&menu->items[pos_00].flags) goto code_r0x08062b83;
          pos_00 = pos_00 + iVar3;
        }
      }
      else {
        if (wrap == 0) {
          pos_00 = iVar1 + -1;
          iVar3 = pos_00 * 0x20;
          goto select_item;
        }
        pos_00 = 0;
      }
      if (iVar2 == -1) {
        iVar2 = 0;
      }
      if (pos_00 == iVar2) break;
    } while( true );
  }
  iVar3 = pos_00 << 5;
select_item:
  if (*(char *)((int)&menu->items->flags + iVar3) < '\0') goto no_item;
  goto LAB_08062b99;
code_r0x08062b83:
  local_28 = local_28 - iVar3;
  if (local_28 + iVar3 == 0) {
LAB_08062b99:
    set_menu_selection(menu,pos_00);
    return;
  }
  goto LAB_08062af0;
}



// WARNING: Unknown calling convention

uchar * _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

void select_menu_item(terminal *term,menu_item *it,void *data)

{
  void *pvVar1;
  menu_func_T p_Var2;
  main_action action_id;
  menu_item_flags mVar3;
  int **ppiVar4;
  window *win;
  menu_func_T func;
  
  pvVar1 = it->data;
  p_Var2 = it->func;
  action_id = it->action_id;
  mVar3 = it->flags;
  if (-1 < (char)mVar3) {
    if ((mVar3 & SUBMENU) == NO_FLAG) {
      it->flags = mVar3 & ~FREE_DATA;
      while (win = (window *)(term->windows).next, win != (window *)&term->windows) {
        while (win->handler != menu_handler) {
          if (win->handler != mainmenu_handler) goto LAB_08062d48;
          ppiVar4 = (int **)win->data;
          ppiVar4[3] = (int *)0xffffffff;
          *(int *)(**ppiVar4 + 4) = (*ppiVar4)[1];
          *(int *)(*ppiVar4)[1] = **ppiVar4;
                    // WARNING: Load size is inaccurate
          **ppiVar4 = *(term->windows).prev;
          (*ppiVar4)[1] = (int)(term->windows).prev;
          *(int **)(term->windows).prev = *ppiVar4;
          *(int **)(**ppiVar4 + 4) = *ppiVar4;
          redraw_terminal(term);
          win = (window *)(term->windows).next;
          if (win == (window *)&term->windows) goto LAB_08062d48;
        }
        delete_window(win);
      }
    }
LAB_08062d48:
    if ((p_Var2 == (menu_func_T)0x0) && (action_id != ACT_MAIN_NONE)) {
      do_action((session *)data,action_id,1);
      return;
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    assert_failed = (int)(p_Var2 == (menu_func_T)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
      errline = 0xae;
      elinks_internal((uchar *)"assertion func != NULL failed: No menu function");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    (*p_Var2)(term,pvVar1,data);
  }
  return;
}



// WARNING: Unknown calling convention

void free_menu_items(menu_item *items)

{
  uchar *p_00;
  void *p;
  void *p_1;
  menu_item_flags mVar1;
  menu_item *item;
  menu_item *pmVar2;
  
  if ((items != (menu_item *)0x0) &&
     (mVar1 = items->flags, (mVar1 & (FREE_LIST|FREE_TEXT|FREE_RTEXT|FREE_DATA)) != NO_FLAG)) {
    p_00 = items->text;
    pmVar2 = items;
    if (p_00 != (uchar *)0x0) {
      while( true ) {
        if ((mVar1 & FREE_TEXT) != NO_FLAG) {
          mem_free(p_00);
          mVar1 = pmVar2->flags;
        }
        if (((mVar1 & FREE_RTEXT) != NO_FLAG) && (pmVar2->rtext != (uchar *)0x0)) {
          mem_free(pmVar2->rtext);
          mVar1 = pmVar2->flags;
        }
        if (((mVar1 & FREE_DATA) != NO_FLAG) && (pmVar2->data != (void *)0x0)) {
          mem_free(pmVar2->data);
        }
        p_00 = pmVar2[1].text;
        if (p_00 == (uchar *)0x0) break;
        mVar1 = pmVar2[1].flags;
        pmVar2 = pmVar2 + 1;
      }
    }
    mem_free(items);
  }
  return;
}



// WARNING: Unknown calling convention

void do_menu_selected(terminal *term,menu_item *items,void *data,int selected,int hotkeys)

{
  menu *menu_00;
  menu *menu;
  int iVar1;
  int i;
  
  menu_00 = (menu *)mem_calloc(1,0x3c);
  if (menu_00 != (menu *)0x0) {
    menu_00->items = items;
    menu_00->data = data;
    menu_00->selected = selected;
    if ((items == (menu_item *)0x0) || (items->text == (uchar *)0x0)) {
      iVar1 = 0;
    }
    else {
      iVar1 = 0;
      do {
        items = items + 1;
        iVar1 = iVar1 + 1;
      } while (items->text != (uchar *)0x0);
    }
    menu_00->size = iVar1;
    menu_00->lang = -1;
    menu_00->hotkeys = hotkeys;
    refresh_hotkeys(term,menu_00);
    add_window(term,menu_handler,menu_00);
    return;
  }
  free_menu_items(items);
  return;
}



// WARNING: Unknown calling convention

void do_menu(terminal *term,menu_item *items,void *data,int hotkeys)

{
  do_menu_selected(term,items,data,0,hotkeys);
  return;
}



// WARNING: Unknown calling convention

void add_to_menu(menu_item **mi,uchar *text,uchar *rtext,main_action action_id,menu_func_T func,
                void *data,menu_item_flags flags)

{
  menu_item *item_1;
  menu_item *pmVar1;
  menu_item *pmVar2;
  menu_item *item;
  size_t newsize;
  uint uVar3;
  size_t size;
  int n;
  int iVar4;
  int iVar5;
  size_t oldsize;
  uint uVar6;
  
  pmVar2 = *mi;
  if (pmVar2 != (menu_item *)0x0) {
    if (pmVar2->text == (uchar *)0x0) {
      iVar5 = 0;
    }
    else {
      pmVar1 = pmVar2;
      iVar5 = 0;
      do {
        iVar4 = iVar5;
        pmVar1 = pmVar1 + 1;
        iVar5 = iVar4 + 1;
      } while (pmVar1->text != (uchar *)0x0);
      uVar3 = iVar4 + 0x13U & 0xfffffff0;
      uVar6 = iVar4 + 0x11U & 0xfffffff0;
      if (uVar6 < uVar3) {
        size = uVar3 * 0x20;
        pmVar2 = (menu_item *)mem_realloc(pmVar2,size);
        if (pmVar2 == (menu_item *)0x0) {
          return;
        }
        *mi = pmVar2;
        memset(pmVar2 + uVar6,0,size + uVar6 * -0x20);
        pmVar2 = *mi;
      }
    }
    if (pmVar2 != (menu_item *)0x0) {
      pmVar2 = pmVar2 + iVar5;
      pmVar2[1].text = pmVar2->text;
      pmVar2[1].rtext = pmVar2->rtext;
      pmVar2[1].action_id = pmVar2->action_id;
      pmVar2[1].func = pmVar2->func;
      pmVar2[1].data = pmVar2->data;
      pmVar2[1].flags = pmVar2->flags;
      pmVar2[1].hotkey_state = pmVar2->hotkey_state;
      pmVar2[1].hotkey_pos = pmVar2->hotkey_pos;
      pmVar2->text = text;
      pmVar2->rtext = rtext;
      pmVar2->action_id = action_id;
      pmVar2->func = func;
      pmVar2->data = data;
      pmVar2->flags = pmVar2->flags | flags;
      pmVar2->hotkey_state = HKS_SHOW;
      pmVar2->hotkey_pos = 0;
    }
  }
  return;
}



// WARNING: Unknown calling convention

menu_item * new_menu(menu_item_flags flags)

{
  menu_item *pmVar1;
  uint uVar2;
  uint uVar3;
  menu_item *pmVar4;
  uchar *data;
  bool bVar5;
  byte bVar6;
  menu_item *local_10;
  
  bVar6 = 0;
  local_10 = (menu_item *)0x0;
  pmVar1 = (menu_item *)mem_realloc((void *)0x0,0x200);
  if (pmVar1 != (menu_item *)0x0) {
    bVar5 = ((uint)pmVar1 & 1) != 0;
    uVar3 = 0x200;
    pmVar4 = pmVar1;
    if (bVar5) {
      *(undefined *)&pmVar1->text = 0;
      pmVar4 = (menu_item *)((int)&pmVar1->text + 1);
      uVar3 = 0x1ff;
    }
    if (((uint)pmVar4 & 2) != 0) {
      *(undefined2 *)&pmVar4->text = 0;
      uVar3 = uVar3 - 2;
      pmVar4 = (menu_item *)((int)&pmVar4->text + 2);
    }
    for (uVar2 = uVar3 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
      pmVar4->text = (uchar *)0x0;
      pmVar4 = (menu_item *)((int)pmVar4 + (uint)bVar6 * -8 + 4);
    }
    if ((uVar3 & 2) != 0) {
      *(undefined2 *)&pmVar4->text = 0;
      pmVar4 = (menu_item *)((int)&pmVar4->text + 2);
    }
    if (bVar5) {
      *(undefined *)&pmVar4->text = 0;
    }
    if (pmVar1 == (menu_item *)0x0) {
      local_10 = (menu_item *)0x0;
    }
    else {
      pmVar1->flags = flags;
      local_10 = pmVar1;
    }
  }
  return local_10;
}



// WARNING: Unknown calling convention

void display_menu(terminal *term,menu *menu)

{
  byte *pbVar1;
  byte *pbVar2;
  int iVar3;
  color_pair *color;
  color_pair *color_00;
  color_pair *color_01;
  option_value *poVar4;
  color_pair *pcVar5;
  color_pair *pcVar6;
  screen_char_attr attr;
  uint uVar7;
  size_t sVar8;
  string *psVar9;
  int new_charset_1;
  int iVar10;
  unicode_val_T c_00;
  int iVar11;
  int new_charset;
  uchar *puVar12;
  byte *pbVar13;
  uchar c;
  byte bVar14;
  int iVar15;
  int iVar16;
  size_t sVar17;
  int iVar18;
  int iVar19;
  uchar *text;
  unicode_val_T data;
  byte *pbVar20;
  int iVar21;
  int p;
  menu_item *mi;
  byte **ppbVar22;
  int hk_state;
  int iVar23;
  bool bVar24;
  screen_char_attr attr_00;
  int local_a0;
  color_pair *local_50;
  uint local_4c;
  int local_48;
  size_t local_40;
  box box;
  string keystroke;
  byte *local_20 [4];
  
  color = get_bfu_color(term,"menu.normal");
  color_00 = get_bfu_color(term,"menu.selected");
  color_01 = get_bfu_color(term,"menu.frame");
  box.x = (menu->box).x + 1;
  if (box.x < 0) {
    box.x = 0;
  }
  box.y = (menu->box).y + 1;
  if (box.y < 0) {
    box.y = 0;
  }
  box.width = (menu->box).width + -2;
  if (box.width < 0) {
    box.width = 0;
  }
  iVar19 = (menu->box).height + -2;
  box.height = 0;
  if (-1 < iVar19) {
    box.height = iVar19;
  }
  draw_box(term,&box,' ',0,color);
  draw_border(term,&box,color_01,1);
  poVar4 = get_opt_();
  if (poVar4->tree == (list_head_elinks *)0x0) {
    if ((term->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term,&box,1,0,0);
    }
  }
  else {
    pcVar6 = get_bfu_color(term,"dialog.shadow");
    draw_shadow(term,&menu->box,pcVar6,2,1);
    if ((term->field_0x38 & 2) != 0) {
      fix_dwchar_around_box(term,&box,1,2,1);
    }
  }
  iVar3 = box.height;
  box.height = 1;
  iVar19 = menu->first;
  if ((iVar19 < menu->size) && (iVar19 < iVar19 + iVar3)) {
    local_48 = iVar19 << 5;
    do {
      ppbVar22 = (byte **)((int)&menu->items->text + local_48);
      bVar24 = menu->selected == iVar19;
      local_50 = color;
      if (bVar24) {
        set_cursor(term,box.x,box.y,1);
        menu->win->x = (menu->box).width + (menu->box).x;
        menu->win->y = box.y;
        draw_box(term,&box,' ',0,color_00);
        local_50 = color_00;
      }
      pbVar20 = ppbVar22[5];
      local_4c = (uint)pbVar20 & 0x80;
      if (local_4c == 0) {
        pbVar13 = *ppbVar22;
        if (pbVar13 == (byte *)0x0) goto LAB_08063428;
        if (*pbVar13 != 0) goto LAB_0806326e;
        if (((uint)pbVar20 & 0x20) != 0) goto LAB_08063526;
LAB_08063431:
        if (ppbVar22[2] == (byte *)0x0) {
          pbVar13 = ppbVar22[1];
          iVar11 = box.y;
          if ((pbVar13 != (byte *)0x0) && (*pbVar13 != 0)) {
            if (((uint)pbVar20 & 0x100) != 0) {
              if ((term != (terminal *)0x0) &&
                 (iVar11 = get_terminal_codepage(term), iVar11 != current_charset)) {
                puVar12 = get_cp_mime_name(iVar11);
                bind_textdomain_codeset("elinks",puVar12);
                current_charset = iVar11;
              }
              pbVar13 = gettext(pbVar13);
              iVar11 = box.y;
              if (*pbVar13 == 0) goto LAB_080634d3;
            }
            iVar15 = box.width;
            iVar11 = box.y;
            iVar18 = (menu->box).x;
            sVar17 = box.width - 2;
            if ((0 < (int)sVar17) && (sVar8 = strlen((char *)pbVar13), sVar8 != 0)) {
              if ((int)sVar17 < (int)sVar8) {
                sVar8 = sVar17;
              }
              draw_text(term,(iVar15 + iVar18) - sVar8,iVar11,pbVar13,sVar8,0,local_50);
              iVar11 = box.y;
            }
          }
        }
        else {
          psVar9 = init_string(&keystroke);
          iVar11 = box.y;
          if (psVar9 != (string *)0x0) {
            add_keystroke_action_to_string(&keystroke,(action_id_T)ppbVar22[2],KEYMAP_MAIN);
            puVar12 = keystroke.source;
            iVar18 = box.y;
            iVar11 = (menu->box).x;
            sVar17 = box.width - 2;
            if (0 < (int)sVar17) {
              sVar8 = keystroke.length;
              if (keystroke.length < 0) {
                sVar8 = strlen((char *)keystroke.source);
              }
              if (sVar8 != 0) {
                if ((int)sVar17 < (int)sVar8) {
                  sVar8 = sVar17;
                }
                draw_text(term,(iVar11 + 2 + sVar17) - sVar8,iVar18,puVar12,sVar8,0,local_50);
              }
            }
            done_string(&keystroke);
            iVar11 = box.y;
          }
        }
      }
      else {
        pbVar13 = *ppbVar22;
        if (pbVar13 == (byte *)0x0) {
LAB_08063428:
          if (((uint)pbVar20 & 0x20) == 0) goto LAB_08063431;
LAB_08063526:
          iVar18 = box.width + -2;
          iVar11 = box.y;
          if (0 < iVar18) {
            iVar11 = (iVar18 != 1) + 1;
            draw_text(term,((menu->box).x + 2 + iVar18) - iVar11,box.y,m_submenu,iVar11,0,local_50);
            iVar11 = box.y;
          }
        }
        else {
          if (*pbVar13 != 0) {
LAB_0806326e:
            pbVar1 = ppbVar22[7];
            if (((uint)pbVar20 & 0x40) == 0) {
              if ((term != (terminal *)0x0) &&
                 (iVar11 = get_terminal_codepage(term), iVar11 != current_charset)) {
                puVar12 = get_cp_mime_name(iVar11);
                bind_textdomain_codeset("elinks",puVar12);
                current_charset = iVar11;
              }
              pbVar13 = gettext(pbVar13);
              pbVar20 = ppbVar22[5];
              local_4c = (uint)pbVar20 & 0x80;
            }
            iVar15 = box.width;
            iVar18 = box.y;
            iVar11 = box.x;
            if ((local_4c == 0) && (pbVar1 != (byte *)0x0)) {
              pcVar5 = get_bfu_color(term,(uchar *)"menu.hotkey.normal");
              pcVar6 = get_bfu_color(term,(uchar *)"menu.hotkey.selected");
              poVar4 = get_opt_();
              iVar15 = iVar15 + -2;
              attr = ~-(uint)(poVar4->tree == (list_head_elinks *)0x0) & SCREEN_ATTR_UNDERLINE;
              if (0 < iVar15) {
                if (!bVar24) {
                  pcVar6 = pcVar5;
                }
                iVar16 = iVar11 + 1;
                if ((term->field_0x38 & 2) == 0) {
                  bVar14 = *pbVar13;
                  if (bVar14 == 0) goto LAB_08063682;
                  iVar16 = 0;
                  uVar7 = 0;
                  pbVar20 = (byte *)0x0;
                  do {
                    if (iVar16 == 0) {
                      if (pbVar1 + -1 != pbVar20) goto LAB_08063379;
                      uVar7 = 1;
                      iVar16 = 1;
LAB_080633b1:
                      pbVar2 = pbVar20 + (1 - uVar7);
                    }
                    else {
                      if (iVar16 != 1) {
LAB_08063379:
                        draw_char(term,(iVar11 + 1) - uVar7,iVar18,(uint)bVar14,0,local_50);
                        uVar7 = (uint)(iVar16 != 0);
                        goto LAB_080633b1;
                      }
                      iVar16 = 2;
                      draw_char(term,iVar11,iVar18,(uint)bVar14,attr,pcVar6);
                      uVar7 = 1;
                      pbVar2 = pbVar20;
                    }
                    if (iVar15 <= (int)pbVar2) break;
                    pbVar20 = pbVar20 + 1;
                    iVar11 = iVar11 + 1;
                    bVar14 = pbVar13[(int)pbVar20];
                  } while (bVar14 != 0);
                  pbVar20 = ppbVar22[5];
                }
                else {
                  puVar12 = (uchar *)__rawmemchr(pbVar13,0);
                  local_20[0] = pbVar13;
                  if (*pbVar13 == 0) goto LAB_08063682;
                  iVar23 = 0;
                  uVar7 = 0;
                  iVar21 = 0;
                  local_40 = 0;
                  do {
                    c_00 = utf8_to_unicode(local_20,puVar12);
                    if (iVar23 == 0) {
                      if (pbVar1 != local_20[0] + -(int)pbVar13) goto LAB_080638a7;
                      uVar7 = 1;
                      iVar23 = 1;
LAB_0806392a:
                      iVar10 = iVar21 + 1;
                      local_40 = (iVar21 + 1) - uVar7;
                    }
                    else {
                      if (iVar23 != 1) {
LAB_080638a7:
                        iVar10 = unicode_to_cell(c_00);
                        if (iVar10 == 2) {
                          if ((int)(local_40 + 1) < iVar15) {
                            local_a0 = (iVar16 + iVar21) - uVar7;
                            if (local_a0 + 1 < term->width) {
                              iVar21 = iVar21 + 1;
                              draw_char(term,local_a0,iVar18,c_00,0,local_50);
                              draw_char(term,iVar16 + (iVar21 - uVar7),iVar18,0xfffffffd,0,local_50)
                              ;
                              uVar7 = (uint)(iVar23 != 0);
                              goto LAB_0806392a;
                            }
                          }
                          else {
                            local_a0 = (iVar16 + iVar21) - uVar7;
                          }
                          c_00 = 0x20;
                        }
                        else {
                          local_a0 = (iVar21 + iVar16) - uVar7;
                        }
                        draw_char(term,local_a0,iVar18,c_00,0,local_50);
                        uVar7 = (uint)(iVar23 != 0);
                        goto LAB_0806392a;
                      }
                      iVar23 = unicode_to_cell(c_00);
                      attr_00 = attr;
                      if (iVar23 == 2) {
                        if ((iVar21 < iVar15) && (iVar23 = iVar21 + iVar16, iVar23 < term->width)) {
                          iVar21 = iVar21 + 1;
                          uVar7 = 1;
                          draw_char(term,iVar23 + -1,iVar18,c_00,attr,pcVar6);
                          iVar23 = 2;
                          draw_char(term,iVar21 + iVar11,iVar18,0xfffffffd,0,pcVar6);
                          goto LAB_0806392a;
                        }
                        c_00 = 0x20;
                        attr_00 = 0;
                      }
                      uVar7 = 1;
                      iVar23 = 2;
                      draw_char(term,iVar21 + iVar11,iVar18,c_00,attr_00,pcVar6);
                      iVar10 = iVar21 + 1;
                      local_40 = iVar21;
                    }
                    iVar21 = iVar10;
                  } while (((int)local_40 < iVar15) && (*local_20[0] != 0));
                  pbVar20 = ppbVar22[5];
                }
                goto LAB_08063428;
              }
            }
            else {
              local_40 = box.width - 2;
              if (((int)local_40 < 1) || (sVar17 = strlen((char *)pbVar13), sVar17 == 0))
              goto LAB_08063428;
              if (((term->field_0x38 & 2) == 0) ||
                 (local_40 = utf8_cells2bytes(pbVar13,local_40,(uchar *)0x0), 0 < (int)local_40)) {
                if ((int)local_40 <= (int)sVar17) {
                  sVar17 = local_40;
                }
                draw_text(term,iVar11 + 1,iVar18,pbVar13,sVar17,0,local_50);
              }
            }
LAB_08063682:
            pbVar20 = ppbVar22[5];
            goto LAB_08063428;
          }
          draw_border_char(term,(menu->box).x,box.y,BORDER_SRTEE,color_01);
          draw_box(term,&box,0xc4,SCREEN_ATTR_FRAME,color_01);
          draw_border_char(term,box.width + box.x,box.y,BORDER_SLTEE,color_01);
          iVar11 = box.y;
        }
      }
LAB_080634d3:
      box.y = iVar11 + 1;
      iVar19 = iVar19 + 1;
    } while ((menu->size != iVar19 && iVar19 <= menu->size) &&
            (local_48 = local_48 + 0x20, iVar19 < iVar3 + menu->first));
  }
  redraw_from_window(menu->win);
  return;
}



// WARNING: Unknown calling convention

void display_mainmenu(terminal *term,menu *menu)

{
  uchar c;
  color_pair *color;
  color_pair *color_00;
  int iVar2;
  menu_item *mi;
  byte bVar1;
  size_t sVar3;
  color_pair *pcVar4;
  color_pair *color_01;
  option_value *poVar5;
  int iVar6;
  int p;
  screen_char *schar;
  int new_charset;
  byte *__s;
  uchar *puVar7;
  int iVar8;
  unicode_val_T c_00;
  screen_char *psVar9;
  int iVar10;
  int num_items_offscreen;
  int num_items_offscreen_1;
  screen_char_attr attr;
  uint uVar11;
  int iVar12;
  unicode_val_T data;
  int textlen;
  int iVar13;
  color_pair *hk_color;
  int iVar14;
  bool bVar15;
  int local_64;
  int local_60;
  color_pair *local_58;
  int local_54;
  int local_48;
  byte *local_44;
  int local_40;
  box box;
  byte *local_20 [4];
  
  color = get_bfu_color(term,"menu.normal");
  color_00 = get_bfu_color(term,"menu.selected");
  iVar10 = menu->selected;
  iVar12 = menu->first;
  if (iVar10 < iVar12) {
    iVar10 = iVar10 - iVar12;
    iVar12 = iVar10 + iVar12;
    menu->first = iVar12;
    iVar2 = menu->last + iVar10;
    menu->last = iVar2;
LAB_08063d1b:
    if (iVar2 < 1) goto LAB_08064071;
LAB_08063d23:
    iVar10 = menu->size;
  }
  else {
    iVar2 = menu->last;
    if (iVar10 <= iVar2) goto LAB_08063d1b;
    iVar12 = iVar12 - (iVar2 - iVar10);
    iVar2 = iVar2 - (iVar2 - iVar10);
    menu->first = iVar12;
    menu->last = iVar2;
    if (0 < iVar2) goto LAB_08063d23;
LAB_08064071:
    iVar10 = menu->size;
    iVar2 = iVar10 + -1;
    menu->last = iVar2;
    if (iVar2 < 0) {
      menu->last = 0;
      iVar2 = 0;
      goto joined_r0x08064093;
    }
  }
  iVar10 = iVar10 + -1;
  if (iVar10 < iVar2) {
    menu->last = iVar10;
    iVar2 = iVar10;
  }
joined_r0x08064093:
  if (iVar12 < 0) {
    menu->first = 0;
  }
  else if (iVar2 < iVar12) {
    menu->first = iVar2;
  }
  box.x = 0;
  box.y = 0;
  box.height = 1;
  box.width = 0;
  if (-1 < term->width) {
    box.width = term->width;
  }
  draw_box(term,&box,' ',0,color);
  local_54 = 0;
  if (menu->first != 0) {
    box.width = 2;
    draw_box(term,&box,'<',0,color);
    local_54 = menu->first;
  }
  if (menu->size <= local_54) {
LAB_08064118:
    iVar12 = menu->first;
    local_54 = local_54 + -1;
    menu->last = local_54;
    if (local_54 < iVar12) {
      menu->last = iVar12;
      local_54 = iVar12;
    }
    if (local_54 < menu->size + -1) {
      if (((term->field_0x38 & 2) != 0) &&
         (psVar9 = get_char(term,term->width + -2,0), psVar9->data == 0xfffffffd)) {
        draw_char_data(term,term->width + -3,0,0x20);
      }
      box.y = 0;
      box.width = 2;
      iVar12 = term->width + -2;
      box.x = 0;
      if (-1 < iVar12) {
        box.x = iVar12;
      }
      box.height = 1;
      draw_box(term,&box,'>',0,color);
    }
    redraw_from_window(menu->win);
    return;
  }
  local_64 = local_54 << 5;
  local_40 = 2;
  do {
    mi = (menu_item *)((int)&menu->items->text + local_64);
    local_44 = mi->text;
    iVar12 = mi->hotkey_pos;
    bVar15 = menu->selected == local_54;
    __s = local_44;
    if ((((*(byte *)&mi->flags & 0x40) == 0) && (__s = (byte *)0x0, local_44 != (byte *)0x0)) &&
       (__s = local_44, *local_44 != 0)) {
      iVar10 = get_terminal_codepage(term);
      if (iVar10 != current_charset) {
        puVar7 = get_cp_mime_name(iVar10);
        bind_textdomain_codeset("elinks",puVar7);
        current_charset = iVar10;
      }
      __s = gettext(local_44);
      local_44 = __s;
    }
    sVar3 = strlen((char *)__s);
    iVar10 = sVar3 - (iVar12 != 0);
    local_60 = iVar10;
    if ((term->field_0x38 & 2) != 0) {
      local_60 = utf8_ptr2cells(local_44,(uchar *)0x0);
      local_60 = local_60 - (uint)(iVar12 != 0);
    }
    local_58 = color;
    if (bVar15) {
      box.x = local_40;
      iVar2 = iVar10;
      if ((term->field_0x38 & 2) != 0) {
        iVar2 = local_60;
      }
      box.width = iVar2 + 4;
      draw_box(term,&box,' ',0,color_00);
      set_cursor(term,local_40,0,1);
      menu->win->x = local_40;
      menu->win->y = 1;
      local_58 = color_00;
    }
    iVar2 = local_40 + 1;
    if (iVar12 == 0) {
      if (iVar10 < 1) goto LAB_0806400b;
      if ((term->field_0x38 & 2) == 0) {
LAB_080640ca:
        iVar12 = iVar10;
      }
      else {
        iVar12 = utf8_cells2bytes(local_44,iVar10,(uchar *)0x0);
        if (iVar12 < 1) goto LAB_0806400b;
        if (iVar10 <= iVar12) goto LAB_080640ca;
      }
      draw_text(term,local_40 + 2,0,local_44,iVar12,0,local_58);
      if (term->width + -2 <= local_60 + iVar2) goto LAB_08064118;
    }
    else {
      pcVar4 = get_bfu_color(term,(uchar *)"menu.hotkey.normal");
      color_01 = get_bfu_color(term,(uchar *)"menu.hotkey.selected");
      poVar5 = get_opt_();
      attr = ~-(uint)(poVar5->tree == (list_head_elinks *)0x0) & SCREEN_ATTR_UNDERLINE;
      if (0 < iVar10) {
        if (!bVar15) {
          color_01 = pcVar4;
        }
        iVar6 = local_40 + 2;
        if ((term->field_0x38 & 2) == 0) {
          bVar1 = *local_44;
          if (bVar1 != 0) {
            iVar14 = 0;
            iVar6 = 0;
            uVar11 = 0;
            iVar13 = iVar2;
            do {
              if (iVar6 == 0) {
                if (iVar12 + -1 != iVar14) goto LAB_08063f69;
                uVar11 = 1;
                iVar6 = 1;
LAB_08063fa2:
                iVar8 = (iVar14 + 1) - uVar11;
              }
              else {
                if (iVar6 != 1) {
LAB_08063f69:
                  draw_char(term,(iVar13 + 1) - uVar11,0,(uint)bVar1,0,local_58);
                  uVar11 = (uint)(iVar6 != 0);
                  goto LAB_08063fa2;
                }
                iVar6 = 2;
                draw_char(term,iVar13,0,(uint)bVar1,attr,color_01);
                uVar11 = 1;
                iVar8 = iVar14;
              }
              if (iVar10 <= iVar8) break;
              iVar14 = iVar14 + 1;
              iVar13 = iVar13 + 1;
              bVar1 = local_44[iVar14];
            } while (bVar1 != 0);
          }
        }
        else {
          puVar7 = (uchar *)__rawmemchr(local_44,0);
          local_20[0] = local_44;
          if (*local_44 != 0) {
            iVar13 = 0;
            iVar14 = 0;
            uVar11 = 0;
            local_48 = 0;
            local_40 = local_40 + 1;
            do {
              c_00 = utf8_to_unicode(local_20,puVar7);
              if (iVar14 == 0) {
                if (iVar12 == (int)local_20[0] - (int)local_44) {
                  uVar11 = 1;
                  iVar14 = 1;
                  goto LAB_08064369;
                }
LAB_080642df:
                iVar8 = unicode_to_cell(c_00);
                if (iVar8 == 2) {
                  if ((local_48 + 1 < iVar10) &&
                     (iVar8 = (iVar13 + iVar6) - uVar11, iVar8 + 1 < term->width)) {
                    iVar13 = iVar13 + 1;
                    draw_char(term,iVar8,0,c_00,0,local_58);
                    draw_char(term,iVar6 + (iVar13 - uVar11),0,0xfffffffd,0,local_58);
                    uVar11 = (uint)(iVar14 != 0);
                    goto LAB_08064369;
                  }
                  c_00 = 0x20;
                }
                draw_char(term,(iVar13 + iVar6) - uVar11,0,c_00,0,local_58);
                uVar11 = (uint)(iVar14 != 0);
LAB_08064369:
                iVar8 = iVar13 + 1;
                local_48 = (iVar13 + 1) - uVar11;
              }
              else {
                if (iVar14 != 1) goto LAB_080642df;
                iVar14 = unicode_to_cell(c_00);
                if (iVar14 != 2) {
                  uVar11 = 1;
                  iVar14 = 2;
                  draw_char(term,local_40 + iVar13,0,c_00,attr,color_01);
                  goto LAB_08064369;
                }
                if ((iVar13 < iVar10) && (iVar14 = iVar13 + iVar6, iVar14 < term->width)) {
                  iVar13 = iVar13 + 1;
                  uVar11 = 1;
                  draw_char(term,iVar14 + -1,0,c_00,attr,color_01);
                  iVar14 = 2;
                  draw_char(term,local_40 + iVar13,0,0xfffffffd,0,color_01);
                  goto LAB_08064369;
                }
                uVar11 = 1;
                iVar14 = 2;
                draw_char(term,local_40 + iVar13,0,0x20,0,color_01);
                iVar8 = iVar13 + 1;
                local_48 = iVar13;
              }
              iVar13 = iVar8;
            } while ((local_48 < iVar10) && (*local_20[0] != 0));
          }
        }
      }
LAB_0806400b:
      p = local_60 + iVar2;
      if (term->width + -2 <= p) goto LAB_08064118;
    }
    local_54 = local_54 + 1;
    local_64 = local_64 + 0x20;
    if (menu->size == local_54 || menu->size < local_54) goto LAB_08064118;
    local_40 = local_60 + iVar2 + 3;
  } while( true );
}



// WARNING: Unknown calling convention

void do_mainmenu(terminal *term,menu_item *items,void *data,int sel)

{
  list_head_elinks *plVar1;
  menu *pmVar2;
  void **ppvVar3;
  bool bVar4;
  int iVar5;
  int i;
  window *win;
  window *pwVar6;
  menu *menu;
  int init;
  
  bVar4 = false;
  menu = term->main_menu;
  if (menu == (menu *)0x0) {
    menu = (menu *)mem_calloc(1,0x3c);
    term->main_menu = menu;
    if (menu == (menu *)0x0) {
      return;
    }
    bVar4 = true;
  }
  iVar5 = 0;
  if (sel != -1) {
    iVar5 = sel;
  }
  menu->selected = iVar5;
  menu->items = items;
  menu->data = data;
  if ((items == (menu_item *)0x0) || (items->text == (uchar *)0x0)) {
    iVar5 = 0;
  }
  else {
    iVar5 = 0;
    do {
      items = items + 1;
      iVar5 = iVar5 + 1;
    } while (items->text != (uchar *)0x0);
  }
  menu->size = iVar5;
  menu->hotkeys = 1;
  clear_hotkeys_cache(menu);
  init_hotkeys(term,menu);
  if (bVar4) {
    add_window(term,mainmenu_handler,menu);
    pwVar6 = menu->win;
    if (assert_failed == 0) {
      assert_failed = (int)(pwVar6 == (window *)0x0);
      if (pwVar6 == (window *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
        errline = 0x414;
        elinks_internal((uchar *)"assertion win failed!");
        pwVar6 = menu->win;
      }
      else {
        pwVar6 = menu->win;
      }
    }
    menu->selected = -1;
    pwVar6->next->prev = pwVar6->prev;
    menu->win->prev->next = menu->win->next;
                    // WARNING: Load size is inaccurate
    menu->win->next = *(term->windows).prev;
    menu->win->prev = (window *)(term->windows).prev;
    *(window **)(term->windows).prev = menu->win;
    menu->win->next->prev = menu->win;
  }
  else {
    ppvVar3 = (void **)(term->windows).next;
    plVar1 = &term->windows;
    if ((list_head_elinks *)ppvVar3 != plVar1) {
      pmVar2 = (menu *)ppvVar3[4];
      while (menu != pmVar2) {
        ppvVar3 = (void **)*ppvVar3;
        if ((list_head_elinks *)ppvVar3 == plVar1) goto LAB_080646eb;
        pmVar2 = (menu *)ppvVar3[4];
      }
      *(void **)((int)*ppvVar3 + 4) = ppvVar3[1];
      *(void **)ppvVar3[1] = *ppvVar3;
      *ppvVar3 = (term->windows).next;
      ppvVar3[1] = plVar1;
      (term->windows).next = ppvVar3;
      *(void ***)((int)*ppvVar3 + 4) = ppvVar3;
      display_mainmenu(term,menu);
    }
  }
LAB_080646eb:
  if (((sel != -1) && (iVar5 = menu->selected, -1 < iVar5)) && (iVar5 < menu->size)) {
    select_menu_item(term,menu->items + iVar5,menu->data);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void mainmenu_handler(window *win,term_event *ev)

{
  menu *menu_00;
  uint uVar1;
  term_event_char_T key;
  menu_action action_id;
  action_id_T aVar2;
  int p;
  size_t sVar3;
  int new_charset;
  uchar *codeset;
  uchar *msgid;
  terminal *ptVar4;
  menu_item *item;
  void *data;
  int scroll;
  int iVar5;
  menu *menu;
  menu_item *pmVar6;
  int iVar7;
  
  menu_00 = (menu *)win->data;
  menu_00->win = win;
  if (EVENT_RESIZE < ev->ev) {
    return;
  }
  switch(ev->ev) {
  default:
    goto switchD_08064851_caseD_0;
  case EVENT_KBD:
    break;
  case EVENT_MOUSE:
    uVar1 = (ev->info).mouse.button;
    if (2 < (uVar1 & 7)) {
      return;
    }
    if ((ev->info).mouse.y == 0) {
      iVar7 = (ev->info).mouse.x;
      iVar5 = -1;
      if (iVar7 < 2) {
LAB_08064a98:
        scroll_menu(menu_00,iVar5,1);
        display_mainmenu(win->term,menu_00);
        iVar7 = menu_00->selected;
LAB_08064ab1:
        ptVar4 = win->term;
      }
      else {
        ptVar4 = win->term;
        iVar5 = 1;
        if (ptVar4->width + -2 <= iVar7) goto LAB_08064a98;
        pmVar6 = menu_00->items;
        msgid = pmVar6->text;
        if (msgid != (uchar *)0x0) {
          iVar7 = 2;
          do {
            if (*msgid != '\0') {
              if ((*(byte *)&pmVar6->flags & 0x40) == 0) {
                if ((win->term != (terminal *)0x0) &&
                   (iVar5 = get_terminal_codepage(win->term), iVar5 != current_charset)) {
                  codeset = get_cp_mime_name(iVar5);
                  bind_textdomain_codeset("elinks",codeset);
                  current_charset = iVar5;
                }
                msgid = gettext(msgid);
              }
              sVar3 = strlen((char *)msgid);
              iVar7 = (4 - (uint)(pmVar6->hotkey_pos != 0)) + iVar7 + sVar3;
              if ((ev->info).mouse.x < iVar7) {
                iVar7 = menu_00->selected;
                iVar5 = ((int)pmVar6 - (int)menu_00->items >> 5) - iVar7;
                if (iVar5 != 0) goto LAB_08064a98;
                goto LAB_08064ab1;
              }
            }
            pmVar6 = pmVar6 + 1;
            msgid = pmVar6->text;
          } while (msgid != (uchar *)0x0);
          ptVar4 = win->term;
        }
        iVar7 = menu_00->selected;
      }
      if (iVar7 < 0) {
        return;
      }
      if (menu_00->size == iVar7 || menu_00->size < iVar7) {
        return;
      }
      data = menu_00->data;
      goto LAB_08064932;
    }
    if ((uVar1 & 0x20) != 0) {
      return;
    }
    ptVar4 = win->term;
    menu_00->selected = -1;
    win->next->prev = win->prev;
    goto LAB_0806496c;
  }
  aVar2 = kbd_action(KEYMAP_MENU,ev,(int *)0x0);
  switch(aVar2) {
  default:
    key = (ev->info).mouse.x;
    if ((0x20 < (int)key) &&
       (((iVar7 = (ev->info).mouse.y, iVar7 == 4 || (iVar7 == 0)) &&
        (iVar7 = check_hotkeys(menu_00,key,win->term), iVar7 != 0)))) {
      display_mainmenu(win->term,menu_00);
      goto switchD_08064950_caseD_4;
    }
  case 2:
    ptVar4 = win->term;
    menu_00->selected = -1;
    menu_00->win->next->prev = menu_00->win->prev;
LAB_0806496c:
    menu_00->win->prev->next = menu_00->win->next;
                    // WARNING: Load size is inaccurate
    menu_00->win->next = *(ptVar4->windows).prev;
    menu_00->win->prev = (window *)(ptVar4->windows).prev;
    *(window **)(ptVar4->windows).prev = menu_00->win;
    menu_00->win->next->prev = menu_00->win;
    break;
  case 4:
  case 6:
  case 0xc:
  case 0xd:
  case 0x12:
  case 0x14:
switchD_08064950_caseD_4:
    iVar7 = menu_00->selected;
    ptVar4 = win->term;
    if ((iVar7 < 0) || (menu_00->size <= iVar7)) {
      return;
    }
    data = menu_00->data;
LAB_08064932:
    select_menu_item(ptVar4,menu_00->items + iVar7,data);
    return;
  case 5:
    scroll_menu(menu_00,(menu_00->size + -1) - menu_00->selected,0);
    break;
  case 8:
    scroll_menu(menu_00,-menu_00->selected,0);
    break;
  case 9:
  case 0x10:
    if (aVar2 == 9) goto LAB_08064af1;
LAB_08064891:
    iVar7 = 1;
    goto LAB_08064896;
  case 0xb:
  case 0xe:
    if (aVar2 == 0xb) goto LAB_08064891;
LAB_08064af1:
    iVar7 = -1;
LAB_08064896:
    scroll_menu(menu_00,iVar7,1);
    break;
  case 0xf:
    break;
  }
switchD_08064851_caseD_0:
  display_mainmenu(win->term,menu_00);
  return;
}



// WARNING: Unknown calling convention

input_line_code menu_search_handler(input_line *line,int action_id)

{
  menu *menu_00;
  terminal *term;
  void **ppvVar1;
  void *pvVar2;
  int pos;
  menu_item *item;
  uchar **ppuVar3;
  uchar *puVar4;
  char *pcVar5;
  size_t __n;
  int cp_index;
  int new_charset;
  uchar *puVar6;
  int iVar7;
  int pos_00;
  window *win;
  menu *menu;
  uchar *text;
  int local_24;
  
  menu_00 = (menu *)line->data;
  term = menu_00->win->term;
  iVar7 = menu_00->selected;
  if (action_id == 0x16) {
    iVar7 = iVar7 + 1;
  }
  else if (action_id < 0x17) {
    if (action_id == 0xe) {
      ppvVar1 = (void **)(term->windows).next;
      *(void **)((int)*ppvVar1 + 4) = ppvVar1[1];
      *(void **)ppvVar1[1] = *ppvVar1;
      iVar7 = menu_00->selected;
      if ((-1 < iVar7) && (iVar7 < menu_00->size)) {
        select_menu_item(term,menu_00->items + iVar7,menu_00->data);
      }
      pvVar2 = (term->windows).next;
      ppvVar1[1] = &term->windows;
      *ppvVar1 = pvVar2;
      (term->windows).next = ppvVar1;
      *(void ***)((int)*ppvVar1 + 4) = ppvVar1;
      return INPUT_LINE_CANCEL;
    }
  }
  else {
    if (action_id == 0x19) {
      iVar7 = iVar7 + -1;
      local_24 = -1;
      goto LAB_08064b92;
    }
    if (action_id == 0x1a) {
      return INPUT_LINE_PROCEED;
    }
  }
  local_24 = 1;
LAB_08064b92:
  if (line->buffer[0] == '\0') {
    return INPUT_LINE_PROCEED;
  }
  iVar7 = iVar7 % menu_00->size;
  pos_00 = iVar7;
  do {
    while( true ) {
      item = (menu_item *)(pos_00 * 0x20);
      ppuVar3 = (uchar **)((int)&menu_00->items->text + (int)&item->text);
      puVar4 = *ppuVar3;
      if (((puVar4 != (uchar *)0x0) && (*puVar4 != '\0')) &&
         (puVar6 = ppuVar3[5], -1 < (char)puVar6)) {
        if (((uint)puVar6 & 0x40) == 0) {
          if ((term != (terminal *)0x0) &&
             (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
            puVar6 = get_cp_mime_name(cp_index);
            bind_textdomain_codeset("elinks",puVar6);
            current_charset = cp_index;
          }
          puVar4 = gettext(puVar4);
        }
        puVar4 = stracpy(puVar4);
        if (puVar4 != (uchar *)0x0) {
          pcVar5 = strchr((char *)puVar4,0x7e);
          if (pcVar5 != (char *)0x0) {
            __n = strlen(pcVar5);
            memmove(pcVar5,pcVar5 + 1,__n);
          }
          pcVar5 = strcasestr((char *)puVar4,(char *)line->buffer);
          mem_free(puVar4);
          if (pcVar5 != (char *)0x0) {
            set_menu_selection(menu_00,pos_00);
            display_menu(term,menu_00);
            return INPUT_LINE_PROCEED;
          }
        }
      }
      pos_00 = pos_00 + local_24;
      if (menu_00->size != pos_00) break;
      pos_00 = 0;
      if (iVar7 == 0) {
        return INPUT_LINE_CANCEL;
      }
    }
    if (pos_00 < 0) {
      pos_00 = menu_00->size + -1;
    }
  } while (pos_00 != iVar7);
  return INPUT_LINE_CANCEL;
}



// WARNING: Unknown calling convention

void menu_handler(window *win,term_event *ev)

{
  list_head_elinks *plVar1;
  menu *menu;
  uint uVar2;
  void *pvVar3;
  int iVar4;
  term_event_char_T key_00;
  int iVar5;
  int my;
  int iVar6;
  uchar *rtext;
  size_t sVar7;
  uchar *puVar8;
  string *psVar9;
  action_id_T aVar10;
  menu_action action_id;
  int new_charset;
  uchar *codeset;
  window *pwVar11;
  window *current_tab;
  uchar *prompt;
  int step_1;
  menu_item_flags *pmVar12;
  int s;
  int iVar13;
  int next_sep;
  menu *m1;
  int scroll_direction;
  int rtext_width;
  int iVar14;
  menu_item *item;
  menu_item *pmVar15;
  int iVar16;
  session *ses;
  session *ses_00;
  term_event_key_T key;
  int iVar17;
  int mx;
  int text_width;
  terminal *term;
  terminal *ptVar18;
  window *end;
  uchar *text;
  int iVar19;
  int next_sep_1;
  bool bVar20;
  string keystroke;
  
  menu = (menu *)win->data;
  menu->win = win;
  if (EVENT_ABORT < ev->ev) {
    return;
  }
  switch(ev->ev) {
  default:
    get_parent_ptr(win,&menu->parent_x,&menu->parent_y);
  case EVENT_REDRAW:
    ptVar18 = win->term;
    iVar13 = ptVar18->width + -2;
    iVar5 = ptVar18->height + -2;
    iVar14 = menu->size;
    if (iVar5 <= menu->size) {
      iVar14 = iVar5;
    }
    pmVar15 = menu->items;
    iVar17 = 0;
    iVar6 = 2;
    puVar8 = pmVar15->text;
    if (puVar8 != (uchar *)0x0) {
      iVar17 = 0;
      do {
        if (*puVar8 == '\0') {
          text_width = 0;
        }
        else {
          if ((*(byte *)&pmVar15->flags & 0x40) == 0) {
            iVar6 = get_terminal_codepage(ptVar18);
            if (iVar6 != current_charset) {
              codeset = get_cp_mime_name(iVar6);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = iVar6;
            }
            puVar8 = gettext(puVar8);
            if (*puVar8 == '\0') {
              text_width = 0;
              goto LAB_08064f13;
            }
          }
          if ((ptVar18->field_0x38 & 2) == 0) {
            sVar7 = strlen((char *)puVar8);
          }
          else {
            sVar7 = utf8_ptr2cells(puVar8,(uchar *)0x0);
          }
          text_width = (2 - (uint)(pmVar15->hotkey_pos != 0)) + sVar7;
        }
LAB_08064f13:
        iVar6 = 4;
        if ((pmVar15->flags & SUBMENU) == NO_FLAG) {
          if (pmVar15->action_id == ACT_MAIN_NONE) {
            puVar8 = pmVar15->rtext;
            if (((puVar8 == (uchar *)0x0) || (*puVar8 == '\0')) ||
               (((pmVar15->flags & RIGHT_INTL) != NO_FLAG &&
                (puVar8 = _(puVar8,ptVar18), *puVar8 == '\0')))) {
LAB_08064f98:
              iVar6 = 0;
            }
            else {
              sVar7 = strlen((char *)puVar8);
              iVar6 = sVar7 + 2;
            }
          }
          else {
            psVar9 = init_string(&keystroke);
            if (psVar9 == (string *)0x0) goto LAB_08064f98;
            add_keystroke_action_to_string(&keystroke,pmVar15->action_id,KEYMAP_MAIN);
            iVar6 = keystroke.length + 2;
            done_string(&keystroke);
          }
        }
        if (iVar13 < text_width) {
          text_width = iVar13;
        }
        if (iVar13 - text_width < iVar6) {
          iVar6 = iVar13 - text_width;
        }
        if (iVar17 < iVar6 + text_width) {
          iVar17 = iVar6 + text_width;
        }
        pmVar15 = pmVar15 + 1;
        puVar8 = pmVar15->text;
      } while (puVar8 != (uchar *)0x0);
      iVar6 = iVar17 + 2;
      if (iVar6 < 0) {
        iVar6 = 0;
      }
    }
    iVar4 = menu->parent_y;
    iVar16 = menu->parent_x;
    if (iVar16 < 0) {
      iVar16 = 0;
    }
    (menu->box).x = iVar16;
    iVar19 = 0;
    if (-1 < iVar4) {
      iVar19 = iVar4;
    }
    (menu->box).y = iVar19;
    (menu->box).width = iVar6;
    iVar6 = 0;
    if (-1 < iVar14 + 2) {
      iVar6 = iVar14 + 2;
    }
    (menu->box).height = iVar6;
    if (iVar13 - iVar17 < iVar16) {
      (menu->box).x = iVar13 - iVar17;
    }
    if (iVar5 - iVar14 < iVar19) {
      (menu->box).y = iVar5 - iVar14;
    }
    scroll_menu(menu,0,1);
    display_menu(win->term,menu);
    return;
  case EVENT_KBD:
    break;
  case EVENT_MOUSE:
    uVar2 = (ev->info).mouse.button;
    if ((uVar2 & 7) == 3) {
      iVar14 = -1;
    }
    else {
      if ((uVar2 & 7) != 4) {
        iVar14 = (ev->info).mouse.y;
        iVar5 = (ev->info).mouse.x;
        iVar13 = (menu->box).x;
        if ((((iVar13 <= iVar5) && (iVar6 = (menu->box).y, iVar6 <= iVar14)) &&
            (iVar5 < iVar13 + (menu->box).width)) && (iVar14 < (menu->box).height + iVar6)) {
          iVar6 = (iVar14 + menu->first + -1) - iVar6;
          if (iVar6 < 0) {
            return;
          }
          if (menu->size <= iVar6) {
            return;
          }
          if (*(char *)&menu->items[iVar6].flags < '\0') {
            return;
          }
          set_menu_selection(menu,iVar6);
          display_menu(win->term,menu);
          iVar14 = menu->selected;
          if (iVar14 < 0) {
            return;
          }
          if (menu->size <= iVar14) {
            return;
          }
          select_menu_item(win->term,menu->items + iVar14,menu->data);
          return;
        }
        if ((uVar2 & 0x20) != 0) {
          plVar1 = &win->term->windows;
          if (win == (window *)plVar1) {
            return;
          }
          if (win->handler != mainmenu_handler) {
            pwVar11 = win;
            if (win->handler != menu_handler) {
              return;
            }
            while( true ) {
              pvVar3 = pwVar11->data;
              if (((*(int *)((int)pvVar3 + 0x18) <= iVar5) &&
                  (*(int *)((int)pvVar3 + 0x1c) <= iVar14)) &&
                 ((iVar5 < *(int *)((int)pvVar3 + 0x18) + *(int *)((int)pvVar3 + 0x20) &&
                  (iVar14 < *(int *)((int)pvVar3 + 0x1c) + *(int *)((int)pvVar3 + 0x24))))) {
                delete_window_ev(win,ev);
                return;
              }
              pwVar11 = pwVar11->next;
              if ((window *)plVar1 == pwVar11) {
                return;
              }
              if (pwVar11->handler == mainmenu_handler) break;
              if (pwVar11->handler != menu_handler) {
                return;
              }
            }
          }
          if (iVar14 != 0) {
            return;
          }
          delete_window_ev(win,ev);
          return;
        }
        goto LAB_08065247;
      }
      iVar14 = 1;
    }
    if ((uVar2 & 0x20) != 0) {
      return;
    }
    scroll_menu(menu,iVar14,1);
    display_menu(win->term,menu);
    return;
  case EVENT_ABORT:
    free_menu_items(menu->items);
    return;
  }
  aVar10 = kbd_action(KEYMAP_MENU,ev,(int *)0x0);
  switch(aVar10) {
  default:
    key_00 = (ev->info).mouse.x;
    if ((key_00 + 299 < 0xc) || (iVar14 = (ev->info).mouse.y, iVar14 == 4)) {
LAB_08065247:
      delete_window_ev(win,ev);
      return;
    }
    if ((0x20 < (int)key_00) && (iVar14 == 0)) {
      iVar14 = check_hotkeys(menu,key_00,win->term);
      if (iVar14 != 0) {
        scroll_menu(menu,0,1);
        display_menu(win->term,menu);
        ptVar18 = win->term;
        goto enter;
      }
      iVar14 = check_not_so_hot_keys(menu,key_00,win->term);
      if (iVar14 != 0) {
        scroll_menu(menu,0,1);
        display_menu(win->term,menu);
        return;
      }
    }
    break;
  case 2:
    if ((win->next != (window *)&win->term->windows) && (win->next->handler == mainmenu_handler)) {
      delete_window_ev(win,ev);
      return;
    }
    delete_window_ev(win,(term_event *)0x0);
    return;
  case 4:
    scroll_menu(menu,1,1);
    break;
  case 5:
    scroll_menu(menu,(menu->size + -1) - menu->selected,0);
    break;
  case 6:
  case 0x12:
    ptVar18 = win->term;
    goto enter;
  case 8:
    scroll_menu(menu,-menu->selected,0);
    break;
  case 9:
  case 0x10:
    pwVar11 = win->next;
    ptVar18 = win->term;
    if ((pwVar11 != (window *)&ptVar18->windows) && (pwVar11->handler == mainmenu_handler)) {
      delete_window_ev(win,ev);
      pvVar3 = pwVar11->data;
      iVar14 = *(int *)((int)pvVar3 + 0xc);
      if (iVar14 < 0) {
        return;
      }
      if (*(int *)((int)pvVar3 + 8) <= iVar14) {
        return;
      }
      select_menu_item(pwVar11->term,(menu_item *)(iVar14 * 0x20 + *(int *)((int)pvVar3 + 4)),
                       *(void **)((int)pvVar3 + 0x38));
      return;
    }
    if (aVar10 != 0x10) {
      delete_window(win);
      return;
    }
enter:
    iVar14 = menu->selected;
    if ((-1 < iVar14) && (iVar14 < menu->size)) {
      select_menu_item(ptVar18,menu->items + iVar14,menu->data);
    }
    return;
  case 0xc:
    iVar14 = menu->size;
    iVar5 = iVar14 + -1;
    iVar13 = menu->selected;
    if (iVar5 <= menu->selected) {
      iVar13 = iVar5;
    }
    iVar6 = 0;
    if (-1 < iVar13) {
      iVar6 = iVar13;
    }
    iVar13 = iVar6 + 1;
    iVar17 = iVar5;
    if (iVar13 < iVar14) {
      pmVar12 = &menu->items[iVar13].flags;
      do {
        if (((*(char *)pmVar12 < '\0') && (((menu_item *)(pmVar12 + -5))->text != (uchar *)0x0)) &&
           (iVar17 = iVar13, *((menu_item *)(pmVar12 + -5))->text == '\0')) break;
        iVar13 = iVar13 + 1;
        pmVar12 = pmVar12 + 8;
        iVar17 = iVar5;
      } while (iVar13 < iVar14);
    }
    iVar5 = iVar5 - iVar6;
    if (4 < iVar5) {
      iVar5 = 5;
    }
    iVar13 = (iVar17 - iVar6) + 1;
    iVar14 = 0;
    if ((-1 < iVar13) && (iVar14 = iVar13, iVar5 <= iVar13)) {
      iVar14 = iVar5;
    }
    goto LAB_08065352;
  case 0xd:
    iVar5 = menu->size + -1;
    iVar14 = menu->selected;
    if (iVar5 <= menu->selected) {
      iVar14 = iVar5;
    }
    iVar5 = 0;
    if (-1 < iVar14) {
      iVar5 = iVar14;
    }
    iVar14 = iVar5 + -1;
    if (0 < iVar14) {
      pmVar12 = &menu->items[iVar14].flags;
      do {
        if (((*(char *)pmVar12 < '\0') && (((menu_item *)(pmVar12 + -5))->text != (uchar *)0x0)) &&
           (*((menu_item *)(pmVar12 + -5))->text == '\0')) goto LAB_08065335;
        iVar14 = iVar14 + -1;
        pmVar12 = pmVar12 + -8;
      } while (0 < iVar14);
    }
    iVar14 = 0;
LAB_08065335:
    iVar13 = iVar5 + 1;
    if (4 < iVar5) {
      iVar5 = 5;
    }
    iVar13 = iVar13 - iVar14;
    iVar14 = 0;
    if (-1 < iVar13) {
      if (iVar5 <= iVar13) {
        iVar13 = iVar5;
      }
      iVar14 = -iVar13;
    }
LAB_08065352:
    scroll_menu(menu,iVar14,0);
    break;
  case 0x11:
    bVar20 = true;
    ses_00 = (session *)0x0;
    ptVar18 = menu->win->term;
    pwVar11 = get_tab_by_number(ptVar18,ptVar18->current_tab);
    if (pwVar11 != (window *)0x0) {
      ses_00 = (session *)pwVar11->data;
      bVar20 = ses_00 == (session *)0x0;
    }
    puVar8 = _((uchar *)"Search menu/",ptVar18);
    if ((!bVar20) && (0 < menu->size)) {
      input_field_line(ses_00,puVar8,menu,(input_history *)0x0,menu_search_handler);
    }
    break;
  case 0x14:
    scroll_menu(menu,-1,1);
  }
  display_menu(win->term,menu);
  return;
}



// WARNING: Unknown calling convention

void abort_refreshed_msg_box_handler(dialog_data *dlg_data)

{
  uchar *p;
  void *data;
  
  p = dlg_data->dlg->widgets[0].text;
  if ((uchar *)dlg_data->dlg->udata != p) {
    mem_free(p);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

dlg_refresh_code refresh_msg_box(dialog_data *dlg_data,void *data)

{
  uchar *puVar1;
  uchar *info;
  
  puVar1 = (uchar *)(*(code *)data)(dlg_data->win->term,dlg_data->dlg->udata2);
  if (puVar1 != (uchar *)0x0) {
    abort_refreshed_msg_box_handler(dlg_data);
    dlg_data->dlg->widgets[0].text = puVar1;
  }
  return (uint)(puVar1 == (uchar *)0x0);
}



// WARNING: Unknown calling convention

uchar * msg_text(terminal *term,uchar *format,...)

{
  int iVar1;
  int new_charset;
  uchar *puVar2;
  int infolen;
  uchar *p;
  uchar *info;
  int iVar3;
  int len;
  uchar *puVar4;
  
  puVar2 = (uchar *)0x0;
  if ((format != (uchar *)0x0) && (puVar2 = format, *format != '\0')) {
    if (term != (terminal *)0x0) {
      iVar1 = get_terminal_codepage(term);
      if (iVar1 != current_charset) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
    }
    puVar2 = gettext(format);
  }
  iVar1 = __vsnprintf_chk(0,0,1,0xffffffff,puVar2,&stack0x0000000c);
  p = (uchar *)mem_alloc(iVar1 + 1U);
  puVar4 = p;
  if (p != (uchar *)0x0) {
    iVar3 = __vsnprintf_chk(p,iVar1 + 1U,1,0xffffffff,puVar2,&stack0x0000000c);
    if (iVar1 == iVar3) {
      p[iVar1] = '\0';
    }
    else {
      puVar4 = (uchar *)0x0;
      mem_free(p);
    }
  }
  return puVar4;
}



// WARNING: Unknown calling convention

dialog_data *
msg_box(terminal *term,memory_list *ml,msgbox_flags flags,uchar *title,format_align align,
       uchar *text,void *udata,int buttons,...)

{
  byte *pbVar1;
  done_handler_T *done_00;
  msgbox_flags mVar2;
  dialog *dlg_00;
  dialog *dlg;
  dialog_data *pdVar3;
  int iVar4;
  uchar *codeset;
  uchar *puVar5;
  uchar *puVar6;
  int bflags;
  done_handler_T *done;
  va_list ap;
  uchar **ppuVar7;
  uchar **ppuVar8;
  uchar *label;
  int new_charset;
  msgbox_flags local_24;
  int local_20;
  
  puVar5 = text;
  mVar2 = flags;
  if ((-1 < buttons) && (text != (uchar *)0x0)) {
    if ((flags & MSGBOX_FREE_TEXT) != 0) {
      add_one_to_ml(&ml,text);
    }
    if ((mVar2 & MSGBOX_NO_INTL) == 0) {
      if ((title != (uchar *)0x0) && (*title != '\0')) {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar6 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar6);
          current_charset = iVar4;
        }
        title = gettext(title);
      }
      if (((mVar2 & (MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL)) == 0) && (*puVar5 != '\0')) {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar6 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar6);
          current_charset = iVar4;
        }
        puVar5 = gettext(puVar5);
      }
    }
    local_24 = mVar2 & MSGBOX_NO_INTL;
    dlg_00 = (dialog *)mem_calloc(1,buttons * 0x30 + 0x54);
    if (dlg_00 != (dialog *)0x0) {
      add_one_to_ml(&ml,dlg_00);
      *(byte *)&dlg_00->layout = *(byte *)&dlg_00->layout | 2;
      dlg_00->layouter = generic_dialog_layouter;
      dlg_00->title = title;
      dlg_00->udata2 = udata;
      if ((mVar2 & MSGBOX_SCROLLABLE) != 0) {
        pbVar1 = (byte *)((int)&dlg_00->widgets[0].info + 4);
        *pbVar1 = *pbVar1 | 2;
      }
      ppuVar7 = (uchar **)&stack0x00000024;
      add_dlg_text(dlg_00,puVar5,align,0);
      iVar4 = dlg_00->number_of_widgets;
      local_20 = buttons + 1;
      while (ppuVar8 = ppuVar7, iVar4 < local_20) {
        while( true ) {
          puVar5 = *ppuVar8;
          done_00 = (done_handler_T *)ppuVar8[1];
          ppuVar7 = ppuVar8 + 3;
          puVar6 = ppuVar8[2];
          if (puVar5 == (uchar *)0x0) break;
          if ((local_24 == 0) && (*puVar5 != '\0')) {
            if ((term != (terminal *)0x0) &&
               (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
              codeset = get_cp_mime_name(iVar4);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = iVar4;
            }
            puVar5 = gettext(puVar5);
          }
          add_dlg_button_do(dlg_00,puVar5,(int)puVar6,ok_dialog,(void *)0x0,done_00,udata);
          iVar4 = dlg_00->number_of_widgets;
          ppuVar8 = ppuVar7;
          if (local_20 <= iVar4) goto LAB_08065869;
        }
        local_20 = buttons;
        buttons = buttons + -1;
      }
LAB_08065869:
      if ((assert_failed == 0) && (assert_failed = (int)(local_20 != iVar4), local_20 != iVar4)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/msgbox.c";
        errline = 0x5b;
        elinks_internal((uchar *)"assertion buttons + 1 == (dlg)->number_of_widgets failed!");
      }
      pdVar3 = do_dialog(term,dlg_00,ml);
      return pdVar3;
    }
    freeml(ml);
  }
  return (dialog_data *)0x0;
}



// WARNING: Unknown calling convention

dialog_data *
info_box(terminal *term,msgbox_flags flags,uchar *title,format_align align,uchar *text)

{
  dialog_data *pdVar1;
  
  pdVar1 = msg_box(term,(memory_list *)0x0,flags,title,align,text,(void *)0x0,1,&DAT_081275e4,0,3);
  return pdVar1;
}



// WARNING: Unknown calling convention

void refreshed_msg_box(terminal *term,msgbox_flags flags,uchar *title,format_align align,
                      _func_uchar_ptr_terminal_ptr_void_ptr *get_info,void *data)

{
  uchar *text;
  uchar *info;
  dialog_data *dlg_data_00;
  dialog_data *dlg_data;
  
  text = (*get_info)(term,data);
  if (text != (uchar *)0x0) {
    dlg_data_00 = msg_box(term,(memory_list *)0x0,flags | MSGBOX_FREE_TEXT,title,align,text,data,1,
                          &DAT_081275e4,0,3);
    if (dlg_data_00 != (dialog_data *)0x0) {
      dlg_data_00->dlg->udata = text;
      dlg_data_00->dlg->abort = abort_refreshed_msg_box_handler;
      refresh_dialog(dlg_data_00,refresh_msg_box,get_info);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void done_bfu_colors(void)

{
  hash *phVar1;
  void *p;
  hash *phVar2;
  int iVar3;
  int i;
  hash_item *item;
  int *piVar4;
  
  if (bfu_colors != (hash *)0x0) {
    if (0 < 1 << ((byte)bfu_colors->width & 0x1f)) {
      iVar3 = 0;
      phVar1 = bfu_colors;
      phVar2 = bfu_colors;
      do {
        piVar4 = (int *)phVar2->hash[iVar3].next;
        if ((list_head_elinks *)piVar4 != phVar2->hash + iVar3) {
          do {
            if ((void *)piVar4[4] != (void *)0x0) {
              mem_free((void *)piVar4[4]);
              phVar1 = bfu_colors;
            }
            piVar4 = (int *)*piVar4;
            phVar2 = phVar1;
          } while (phVar1->hash + iVar3 != (list_head_elinks *)piVar4);
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 < 1 << ((byte)phVar2->width & 0x1f));
    }
    free_hash(&bfu_colors);
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

color_pair * get_bfu_color(terminal *term,uchar *stylename)

{
  color_mode cVar1;
  color_mode cVar2;
  option_value *poVar3;
  hash *hash;
  size_t keylen;
  hash_item *phVar4;
  char *name;
  option_elinks *poVar5;
  option_value **value;
  void *p;
  hash *phVar6;
  bfu_color_entry *entry;
  int i;
  int iVar7;
  hash_item *item;
  option_elinks *opt;
  
  if (term == (terminal *)0x0) {
    return (color_pair *)0x0;
  }
  poVar3 = get_opt_();
  cVar1 = poVar3->number;
  if (bfu_colors == (hash *)0x0) {
    bfu_colors = init_hash8();
    hash = bfu_colors;
    cVar2 = cVar1;
    if (bfu_colors == (hash *)0x0) {
      return (color_pair *)0;
    }
  }
  else {
    hash = bfu_colors;
    cVar2 = get_bfu_color::last_color_mode;
    if ((cVar1 != get_bfu_color::last_color_mode) &&
       (cVar2 = cVar1, 0 < 1 << ((byte)bfu_colors->width & 0x1f))) {
      iVar7 = 0;
      phVar6 = bfu_colors;
      do {
        phVar4 = (hash_item *)phVar6->hash[iVar7].next;
        if (phVar4 != (hash_item *)(phVar6->hash + iVar7)) {
          do {
            if (phVar4->value != (void *)0x0) {
              mem_free(phVar4->value);
              hash = bfu_colors;
            }
            phVar4 = phVar4->prev;
            del_hash_item(hash,phVar4->next);
            phVar4 = phVar4->next;
            hash = bfu_colors;
            phVar6 = bfu_colors;
          } while ((hash_item *)(bfu_colors->hash + iVar7) != phVar4);
        }
        iVar7 = iVar7 + 1;
      } while (iVar7 < 1 << ((byte)phVar6->width & 0x1f));
    }
  }
  get_bfu_color::last_color_mode = cVar2;
  keylen = strlen((char *)stylename);
  phVar4 = get_hash_item(hash,stylename,keylen);
  if ((phVar4 == (hash_item *)0x0) ||
     (value = (option_value **)phVar4->value, value == (option_value **)0x0)) {
    name = "ui.colors.color";
    if (cVar1 == COLOR_MODE_MONO) {
      name = "ui.colors.mono";
    }
    poVar5 = get_opt_rec_real(config_options,(uchar *)name);
    if (poVar5 == (option_elinks *)0x0) {
      return (color_pair *)0;
    }
    poVar5 = get_opt_rec_real(poVar5,stylename);
    if (poVar5 == (option_elinks *)0x0) {
      return (color_pair *)0;
    }
    value = (option_value **)mem_calloc(1,0x10);
    if (value == (option_value **)0x0) {
      return (color_pair *)0;
    }
    phVar4 = add_hash_item(bfu_colors,stylename,keylen,value);
    if (phVar4 == (hash_item *)0x0) {
      mem_free(value);
      return (color_pair *)0x0;
    }
    poVar3 = get_opt_();
    value[1] = poVar3;
    poVar3 = get_opt_();
    *value = poVar3;
  }
  else {
    poVar3 = *value;
  }
  *(option_value *)(value + 2) = *poVar3;
  *(option_value *)(value + 3) = *value[1];
  return (color_pair *)(value + 2);
}



// WARNING: Unknown calling convention

void add_dlg_text(dialog *dlg,uchar *text,format_align align,int bottom_pad)

{
  int iVar1;
  
  iVar1 = dlg->number_of_widgets;
  dlg->number_of_widgets = iVar1 + 1;
  dlg->widgets[iVar1].type = WIDGET_TEXT;
  dlg->widgets[iVar1].text = text;
  dlg->widgets[iVar1].info.text.align = align;
  *(byte *)((int)&dlg->widgets[iVar1].info + 4) =
       *(byte *)((int)&dlg->widgets[iVar1].info + 4) & 0xfe | bottom_pad != 0;
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T display_text(dialog_data *dlg_data,widget_data *widget_data)

{
  int iVar1;
  window *pwVar2;
  int iVar3;
  int iVar4;
  color_pair *pcVar5;
  int iVar6;
  int iVar7;
  int step;
  int iVar8;
  window *win;
  box box;
  
  iVar1 = (widget_data->info).field.cpos;
  pwVar2 = dlg_data->win;
  box.y = (widget_data->box).y;
  iVar3 = (widget_data->box).height;
  box.width = 1;
  box.x = (dlg_data->box).x + (dlg_data->box).width + -4;
  if (box.x < 0) {
    box.x = 0;
  }
  if (box.y < 0) {
    box.y = 0;
  }
  box.height = 0;
  if (-1 < iVar3) {
    box.height = iVar3;
  }
  if (((((*(byte *)((int)&widget_data->widget->info + 4) & 2) != 0) && (0 < iVar3)) && (0 < iVar1))
     && ((iVar3 < iVar1 && (box.height != 0)))) {
    pcVar5 = get_bfu_color(pwVar2->term,(uchar *)"dialog.scrollbar");
    draw_box(pwVar2->term,&box,' ',0,pcVar5);
    iVar3 = (widget_data->info).field.vpos;
    iVar6 = ((box.height + 1) * 100) / iVar1;
    iVar4 = (widget_data->box).height;
    iVar7 = ((iVar3 + 1) * iVar6) / 100;
    iVar8 = 0;
    if ((-1 < iVar7) && (iVar8 = iVar4 + -1, iVar7 <= iVar4 + -1)) {
      iVar8 = iVar7;
    }
    box.height = (iVar6 * (box.height + 1)) / 100;
    if (box.height < 1) {
      box.height = 1;
    }
    else {
      iVar7 = 1;
      if (0 < iVar4 - iVar8) {
        iVar7 = iVar4 - iVar8;
      }
      if (iVar7 < box.height) {
        box.height = iVar7;
      }
    }
    if (iVar1 - iVar4 == iVar3) {
      iVar8 = iVar4 - box.height;
    }
    box.y = box.y + iVar8;
    (widget_data->info).text.scroller_height = box.height;
    (widget_data->info).text.scroller_y = box.y;
    pcVar5 = get_bfu_color(pwVar2->term,(uchar *)"dialog.scrollbar-selected");
    draw_box(pwVar2->term,&box,' ',0,pcVar5);
    set_cursor(pwVar2->term,(widget_data->box).x,(widget_data->box).y,1);
    pwVar2->x = (widget_data->box).x;
    pwVar2->y = (widget_data->box).y;
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void dlg_format_text_do(terminal *term,uchar *text,int x,int *y,int width,int *real_width,
                       color_pair *color,format_align align,int format_only)

{
  byte bVar1;
  size_t sVar2;
  ushort **ppuVar3;
  int m_bytes;
  byte bVar4;
  uchar *puVar5;
  int line_width;
  byte *utf8_char;
  int iVar6;
  int shift;
  uchar *next_char_begin;
  byte *pbVar7;
  int local_2c;
  byte *local_24;
  int local_20;
  
  if (*text != '\0') {
    bVar4 = *text;
LAB_080660a8:
    if (bVar4 != 0) {
LAB_080660b0:
      bVar1 = (byte)term->field_0x38 >> 1;
      sVar2 = strlen((char *)text);
      if (0 < width) {
        local_20 = 0;
        local_2c = local_20;
        local_24 = text;
        do {
          if ((bVar4 == 10) || (bVar4 == 0)) goto LAB_08066163;
          if ((bVar1 & 1) == 0) {
            bVar4 = local_24[1];
            utf8_char = local_24 + 1;
            if ((bVar4 != 0) && (bVar4 != 10)) {
              ppuVar3 = __ctype_b_loc();
              while ((*(byte *)((int)*ppuVar3 + (uint)bVar4 * 2 + 1) & 0x20) == 0) {
                utf8_char = utf8_char + 1;
                bVar4 = *utf8_char;
                if ((bVar4 == 10) || (bVar4 == 0)) break;
              }
            }
            local_20 = (int)utf8_char - (int)text;
          }
          else {
            iVar6 = utf8charlen(local_24);
            local_20 = utf8_char2cells(local_24,text + sVar2);
            bVar4 = *local_24;
            utf8_char = local_24;
            while ((utf8_char != local_24 + iVar6 && (bVar4 != 0))) {
              utf8_char = utf8_char + 1;
              bVar4 = *utf8_char;
            }
            local_20 = local_2c + local_20;
            pbVar7 = utf8_char;
            while (((bVar4 != 10 && (bVar4 != 0)) &&
                   (ppuVar3 = __ctype_b_loc(),
                   (*(byte *)((int)*ppuVar3 + (uint)bVar4 * 2 + 1) & 0x20) == 0))) {
              if (utf8_char < pbVar7) {
                utf8_char = utf8_char + 1;
              }
              else {
                iVar6 = utf8_char2cells(utf8_char,text + sVar2);
                local_20 = local_20 + iVar6;
                iVar6 = utf8charlen(utf8_char);
                pbVar7 = pbVar7 + iVar6;
              }
              bVar4 = *utf8_char;
            }
          }
          if (width < local_20) {
            if (text == local_24) {
              if ((bVar1 & 1) == 0) {
                local_2c = width;
                local_24 = text + width;
                goto LAB_0806631c;
              }
              iVar6 = utf8_cells2bytes(text,width,(uchar *)0x0);
              local_24 = text + iVar6;
              local_2c = utf8_ptr2cells(text,local_24);
              goto LAB_080663c8;
            }
            goto LAB_08066163;
          }
          bVar4 = *utf8_char;
          local_2c = local_20;
          local_24 = utf8_char;
        } while( true );
      }
      goto LAB_0806634a;
    }
  }
  return;
LAB_0806631c:
  if (text == local_24 + -1) goto LAB_080663dd;
  ppuVar3 = __ctype_b_loc();
  if ((*(byte *)(*ppuVar3 + local_24[-1]) & 4) != 0) goto LAB_080663c8;
  local_2c = local_2c + -1;
  local_24 = local_24 + -1;
  goto LAB_0806631c;
LAB_080663c8:
  if (text == local_24) {
LAB_080663dd:
    puVar5 = text + width;
    local_2c = width;
    iVar6 = width;
  }
  else {
LAB_08066163:
    iVar6 = (int)local_24 - (int)text;
    if (iVar6 < 1) {
LAB_0806634a:
      puVar5 = text + 1;
      goto LAB_0806620b;
    }
    puVar5 = text + iVar6;
  }
  if ((real_width != (int *)0x0) && (*real_width < local_2c)) {
    *real_width = local_2c;
  }
  if (format_only == 0) {
    if (align == ALIGN_CENTER) {
      shift = (width - local_2c) / 2;
    }
    else {
      shift = width - local_2c;
      if (align != ALIGN_RIGHT) {
        shift = 0;
      }
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(width < local_2c || width <= shift),
       width < local_2c || width <= shift)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 0x100;
      elinks_internal((uchar *)"assertion cells <= width && shift < width failed!");
    }
    draw_text(term,shift + x,*y,text,iVar6,0,color);
  }
LAB_0806620b:
  text = puVar5;
  *y = *y + 1;
  bVar4 = *text;
  if (bVar4 == 0) {
    return;
  }
  ppuVar3 = __ctype_b_loc();
  if ((*(byte *)((int)*ppuVar3 + (uint)bVar4 * 2 + 1) & 0x20) == 0) goto LAB_080660a8;
  text = text + 1;
  bVar4 = *text;
  if (bVar4 == 0) {
    return;
  }
  goto LAB_080660b0;
}



// WARNING: Unknown calling convention

void dlg_format_text(terminal *term,widget_data *widget_data,int x,int *y,int width,int *real_width,
                    int max_height,int format_only)

{
  int *piVar1;
  size_t size;
  format_align align;
  byte bVar2;
  color_pair *color;
  ushort **ppuVar3;
  size_t sVar4;
  size_t newsize;
  uint uVar5;
  int visible;
  int lines_pos;
  int m_bytes;
  uchar *puVar6;
  byte bVar7;
  int height;
  int iVar8;
  int iVar9;
  widget *pwVar10;
  uchar *puVar11;
  int iVar12;
  uchar *saved_pos;
  size_t oldsize;
  byte *utf8_char;
  uint uVar13;
  uchar *next_char_begin;
  bool bVar14;
  int line;
  uchar **lines;
  byte *pbVar15;
  uchar saved;
  uchar uVar16;
  int iVar17;
  uchar *split;
  byte *p;
  int local_48;
  int local_38;
  byte *local_34;
  uchar *local_30;
  uchar *local_20;
  
  pwVar10 = widget_data->widget;
  height = max_height + -3;
  if (height < 0) {
    height = 0;
  }
  local_30 = pwVar10->text;
  iVar17 = (widget_data->box).width;
  iVar8 = *y;
  iVar12 = x;
  if (x < 0) {
    iVar12 = 0;
  }
  if (iVar8 < 0) {
    iVar8 = 0;
  }
  iVar9 = 0;
  if (-1 < iVar17) {
    iVar9 = iVar17;
  }
  (widget_data->box).x = iVar12;
  (widget_data->box).y = iVar8;
  (widget_data->box).width = iVar9;
  (widget_data->box).height = height;
  if (height != 0) {
    if (((*(byte *)((int)&pwVar10->info + 4) & 2) == 0) ||
       (((widget_data->info).field.history.next == (void *)width &&
        (piVar1 = &(widget_data->info).field.cpos, *piVar1 == height || *piVar1 < height)))) {
      bVar14 = false;
      uVar16 = '\0';
      (widget_data->info).field.vpos = 0;
      saved_pos = (uchar *)0x0;
    }
    else {
      if (width != iVar9) {
        bVar2 = (byte)term->field_0x38 >> 1;
        local_34 = pwVar10->text;
        local_20 = widget_data->cdata;
        if ((void *)width != (widget_data->info).field.history.next) {
          (widget_data->box).width = 0;
          bVar7 = *local_34;
          if (bVar7 != 0) {
            ppuVar3 = __ctype_b_loc();
            local_48 = 0;
LAB_08066558:
            if ((*(byte *)((int)*ppuVar3 + (uint)bVar7 * 2 + 1) & 0x20) != 0) {
              local_34 = local_34 + 1;
              bVar7 = *local_34;
            }
            puVar11 = local_20;
            if (bVar7 != 0) {
              iVar17 = 1;
              sVar4 = strlen((char *)local_34);
              local_38 = 1;
              iVar8 = local_38;
              if (0 < width) {
                local_30 = (uchar *)0x0;
                local_38 = (int)local_30;
                p = local_34;
                do {
                  if ((bVar7 == 10) || (bVar7 == 0)) goto LAB_08066621;
                  if ((bVar2 & 1) == 0) {
                    bVar7 = p[1];
                    utf8_char = p + 1;
                    if ((bVar7 != 0) && (bVar7 != 10)) {
                      while ((*(byte *)((int)*ppuVar3 + (uint)bVar7 * 2 + 1) & 0x20) == 0) {
                        utf8_char = utf8_char + 1;
                        bVar7 = *utf8_char;
                        if ((bVar7 == 10) || (bVar7 == 0)) break;
                      }
                    }
                    local_30 = (uchar *)((int)utf8_char - (int)local_34);
                  }
                  else {
                    iVar17 = utf8charlen(p);
                    iVar8 = utf8_char2cells(p,local_34 + sVar4);
                    bVar7 = *p;
                    utf8_char = p;
                    while ((utf8_char != p + iVar17 && (bVar7 != 0))) {
                      utf8_char = utf8_char + 1;
                      bVar7 = *utf8_char;
                    }
                    local_30 = (uchar *)(local_38 + iVar8);
                    pbVar15 = utf8_char;
                    while (((bVar7 != 10 && (bVar7 != 0)) &&
                           ((*(byte *)((int)*ppuVar3 + (uint)bVar7 * 2 + 1) & 0x20) == 0))) {
                      if (utf8_char < pbVar15) {
                        utf8_char = utf8_char + 1;
                      }
                      else {
                        iVar17 = utf8_char2cells(utf8_char,local_34 + sVar4);
                        local_30 = (uchar *)((int)local_30 + iVar17);
                        iVar17 = utf8charlen(utf8_char);
                        pbVar15 = pbVar15 + iVar17;
                      }
                      bVar7 = *utf8_char;
                    }
                  }
                  if (width < (int)local_30) {
                    if (local_34 == p) {
                      if ((bVar2 & 1) == 0) {
                        local_38 = width;
                        p = local_34 + width;
                        goto LAB_08066824;
                      }
                      iVar17 = utf8_cells2bytes(local_34,width,(uchar *)0x0);
                      p = local_34 + iVar17;
                      local_38 = utf8_ptr2cells(local_34,p);
                      goto LAB_08066873;
                    }
                    goto LAB_08066621;
                  }
                  bVar7 = *utf8_char;
                  local_38 = (int)local_30;
                  p = utf8_char;
                } while( true );
              }
              goto LAB_0806663f;
            }
            goto LAB_0806669f;
          }
          puVar11 = local_20;
          local_48 = 0;
LAB_0806669f:
          widget_data->cdata = puVar11;
          (widget_data->info).field.cpos = local_48;
          (widget_data->info).text.max_width = width;
        }
        if (local_20 == (uchar *)0x0) {
          return;
        }
      }
      iVar17 = (widget_data->info).field.vpos;
      puVar11 = widget_data->cdata;
      iVar8 = (widget_data->info).field.cpos;
      if (iVar17 < 0) {
        (widget_data->info).field.vpos = 0;
        iVar12 = 0;
        iVar9 = 0;
      }
      else {
        iVar9 = iVar8 - height;
        if (iVar9 < height) {
          iVar9 = height;
        }
        if (iVar9 < iVar17) {
          (widget_data->info).field.vpos = iVar9;
          iVar12 = iVar9 * 4;
        }
        else {
          iVar12 = iVar17 * 4;
          iVar9 = iVar17;
        }
      }
      local_30 = *(uchar **)(puVar11 + iVar12);
      uVar16 = '\0';
      saved_pos = (uchar *)0x0;
      if (height < iVar8 - iVar9) {
        puVar11 = *(uchar **)(puVar11 + (iVar9 + height) * 4);
        if ((iVar9 + height < 1) || (saved_pos = puVar11 + -1, puVar11[-1] != '\n')) {
          uVar16 = *puVar11;
          saved_pos = puVar11;
        }
        else {
          uVar16 = '\n';
        }
        *saved_pos = '\0';
      }
      if ((real_width != (int *)0x0) && (iVar17 = (widget_data->box).width, *real_width < iVar17)) {
        *real_width = iVar17;
      }
      bVar14 = uVar16 != '\0' && saved_pos != (uchar *)0x0;
      pwVar10 = widget_data->widget;
    }
    align = (pwVar10->info).text.align;
    color = get_bfu_color(term,"dialog.text");
    dlg_format_text_do(term,local_30,x,y,width,real_width,color,align,format_only);
    if ((*(byte *)((int)&widget_data->widget->info + 4) & 1) != 0) {
      *y = *y + -1;
    }
    if (bVar14) {
      *saved_pos = uVar16;
    }
  }
  return;
LAB_08066824:
  if (local_34 == p + -1) goto LAB_0806687c;
  if ((*(byte *)(*ppuVar3 + p[-1]) & 4) != 0) goto LAB_08066873;
  local_38 = local_38 + -1;
  p = p + -1;
  goto LAB_08066824;
LAB_08066873:
  if (local_34 == p) {
LAB_0806687c:
    local_38 = width;
    iVar17 = width;
  }
  else {
LAB_08066621:
    iVar17 = (int)p - (int)local_34;
    if ((int)p - (int)local_34 < 1) {
      iVar17 = 1;
    }
  }
  iVar8 = 1;
  if (0 < local_38) {
    iVar8 = local_38;
  }
LAB_0806663f:
  local_38 = iVar8;
  if ((widget_data->box).width < local_38) {
    (widget_data->box).width = local_38;
  }
  uVar5 = local_48 + 8U & 0xfffffff8;
  uVar13 = local_48 + 7U & 0xfffffff8;
  iVar8 = local_48 + 1;
  if (uVar13 < uVar5) {
    size = uVar5 * 4;
    puVar6 = (uchar *)mem_realloc(local_20,size);
    if (puVar6 == (uchar *)0x0) goto LAB_0806669f;
    memset(puVar6 + uVar13 * 4,0,size + uVar13 * -4);
    local_20 = puVar6;
  }
  if (local_20 == (uchar *)0x0) {
    puVar11 = (uchar *)0x0;
    goto LAB_0806669f;
  }
  *(byte **)(local_20 + iVar8 * 4 + -4) = local_34;
  local_34 = local_34 + iVar17;
  bVar7 = *local_34;
  puVar11 = local_20;
  local_48 = iVar8;
  if (bVar7 == 0) goto LAB_0806669f;
  goto LAB_08066558;
}



// WARNING: Unknown calling convention

void format_and_display_text(widget_data *widget_data,dialog_data *dlg_data,int current)

{
  terminal *term_00;
  int height;
  color_pair *color;
  int iVar1;
  int lines;
  int iVar2;
  int max_height;
  terminal *term;
  int local_20 [4];
  
  term_00 = dlg_data->win->term;
  local_20[0] = (widget_data->box).y;
  iVar2 = (term_00->height * 9) / 10 + -4;
  max_height = 1;
  if (0 < iVar2) {
    iVar1 = term_00->height + -4;
    if (0 < iVar1) {
      max_height = iVar1;
    }
    if (iVar2 <= max_height) {
      max_height = iVar2;
    }
  }
  iVar2 = (widget_data->info).field.cpos;
  if (assert_failed == 0) {
    assert_failed = -(iVar2 >> 0x1f);
    if (assert_failed == 0) {
      iVar1 = (widget_data->box).height;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 0x19e;
      elinks_internal((uchar *)"assertion lines >= 0 failed!");
      if (assert_failed != 0) goto LAB_080669d0;
      iVar1 = (widget_data->box).height;
    }
    assert_failed = -(iVar1 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 0x19f;
      elinks_internal((uchar *)"assertion widget_data->box.height >= 0 failed!");
    }
  }
LAB_080669d0:
  iVar1 = 0;
  if ((-1 < current) &&
     (iVar2 = iVar2 - (widget_data->box).height, iVar1 = current, iVar2 < current)) {
    iVar1 = iVar2;
  }
  if ((widget_data->info).field.vpos != iVar1) {
    (widget_data->info).field.vpos = iVar1;
    color = get_bfu_color(term_00,"dialog.generic");
    draw_box(term_00,&widget_data->box,' ',0,color);
    dlg_format_text(term_00,widget_data,(widget_data->box).x,local_20,(widget_data->box).width,
                    (int *)0x0,max_height,0);
    display_text(dlg_data,widget_data);
    redraw_from_window(dlg_data->win);
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T kbd_text(dialog_data *dlg_data,widget_data *widget_data)

{
  action_id_T aVar1;
  int iVar2;
  int current;
  
  iVar2 = (widget_data->info).field.vpos;
  aVar1 = kbd_action(KEYMAP_MENU,dlg_data->term_event,(int *)0x0);
  switch(aVar1) {
  case 4:
    iVar2 = iVar2 + 1;
    break;
  case 5:
    iVar2 = (widget_data->info).field.cpos;
    break;
  default:
    return EVENT_NOT_PROCESSED;
  case 8:
    iVar2 = 0;
    break;
  case 0xc:
    iVar2 = (widget_data->box).height + iVar2;
    break;
  case 0xd:
    iVar2 = iVar2 - (widget_data->box).height;
    break;
  case 0x14:
    iVar2 = iVar2 + -1;
  }
  format_and_display_text(widget_data,dlg_data,iVar2);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T mouse_text(dialog_data *dlg_data,widget_data *widget_data)

{
  int iVar1;
  int iVar2;
  term_event *ptVar3;
  int iVar4;
  int iVar5;
  term_event *ev;
  uint uVar6;
  int iVar7;
  int iVar8;
  int scroller_middle;
  int current;
  
  iVar1 = (widget_data->info).field.vpos;
  iVar2 = (widget_data->box).height;
  ptVar3 = dlg_data->term_event;
  iVar8 = (widget_data->box).y;
  iVar7 = (dlg_data->box).x + (dlg_data->box).width + -6;
  if (iVar7 < 0) {
    iVar7 = 0;
  }
  iVar4 = (ptVar3->info).mouse.y;
  iVar5 = (ptVar3->info).mouse.x;
  if (iVar7 <= iVar5) {
    if (iVar8 < 0) {
      iVar8 = 0;
    }
    if ((iVar8 <= iVar4) && (iVar5 < iVar7 + 5)) {
      iVar7 = 0;
      if (-1 < iVar2) {
        iVar7 = iVar2;
      }
      if (iVar4 < iVar7 + iVar8) {
        uVar6 = (ptVar3->info).mouse.button & 7;
        iVar2 = ((widget_data->info).text.scroller_height / 2 -
                (widget_data->info).text.scroller_last_dir) +
                (int)(widget_data->info).field.cur_hist;
        if (uVar6 == 2) {
          iVar8 = iVar1 + -5;
          if (iVar2 < iVar4) {
            iVar8 = iVar1 + 5;
          }
        }
        else if (uVar6 < 3) {
          if (uVar6 != 0) {
            return EVENT_NOT_PROCESSED;
          }
          iVar8 = iVar1 + -1;
          if (iVar2 < iVar4) {
            iVar8 = iVar1 + 1;
          }
        }
        else if (uVar6 == 3) {
          iVar8 = iVar1 + -1;
        }
        else {
          if (uVar6 != 4) {
            return EVENT_NOT_PROCESSED;
          }
          iVar8 = iVar1 + 1;
        }
        (widget_data->info).text.scroller_last_dir = (uint)(iVar1 < iVar8) * 2 + -1;
        format_and_display_text(widget_data,dlg_data,iVar8);
        return EVENT_PROCESSED;
      }
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

void display_widget(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_T *UNRECOVERED_JUMPTABLE;
  
  UNRECOVERED_JUMPTABLE = widget_data->widget->ops->display;
  if (UNRECOVERED_JUMPTABLE != (widget_handler_T *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08066cf4. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)(dlg_data,widget_data);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

evhook_status bookmark_change_hook(va_list ap,void *data)

{
  if (*(bookmark **)ap != bm_snapshot_last_folder) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  bm_snapshot_last_folder = (bookmark *)0x0;
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

int change_hook_folder_state(session *ses,option_elinks *current,option_elinks *changed)

{
  if ((changed->value).tree == (list_head_elinks *)0x0) {
    bookmarks_dirty = 1;
  }
  return 0;
}



// WARNING: Unknown calling convention

void bookmarks_set_dirty(void)

{
  bookmarks_dirty = 1;
  return;
}



// WARNING: Unknown calling convention

void bookmarks_unset_dirty(void)

{
  bookmarks_dirty = 0;
  return;
}



// WARNING: Unknown calling convention

int bookmarks_are_dirty(void)

{
  return (uint)(bookmarks_dirty == 1);
}



// WARNING: Unknown calling convention

void free_bookmarks(list_head_elinks *bookmarks_list,list_head_elinks *box_items)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  xlist_head *head;
  xlist_head *head_1;
  bookmark *bm;
  xlist_head *next_1;
  xlist_head *next;
  
  for (plVar1 = (list_head_elinks *)bookmarks_list->next; plVar1 != bookmarks_list;
      plVar1 = (list_head_elinks *)plVar1->next) {
    if ((void **)plVar1[3].prev != &plVar1[3].prev) {
      free_bookmarks((list_head_elinks *)&plVar1[3].prev,
                     (list_head_elinks *)((int)plVar1[2].next + 8));
    }
    mem_free(plVar1[2].prev);
    mem_free(plVar1[3].next);
  }
  plVar1 = (list_head_elinks *)box_items->next;
  plVar2 = plVar1;
  plVar4 = box_items;
  while (plVar2 != box_items) {
    plVar2 = (list_head_elinks *)plVar2->next;
    plVar4 = plVar2;
  }
  for (plVar2 = (list_head_elinks *)box_items->prev; plVar2 != plVar4;
      plVar2 = (list_head_elinks *)plVar2->prev) {
  }
  plVar2 = (list_head_elinks *)plVar1->next;
  while (plVar3 = plVar2, plVar1 != plVar4) {
    plVar3->prev = plVar1->prev;
    *(void **)plVar1->prev = plVar1->next;
    mem_free(plVar1);
    plVar2 = (list_head_elinks *)plVar3->next;
    plVar1 = plVar3;
  }
  plVar1 = (list_head_elinks *)bookmarks_list->next;
  plVar2 = plVar1;
  plVar4 = bookmarks_list;
  while (plVar2 != bookmarks_list) {
    plVar2 = (list_head_elinks *)plVar2->next;
    plVar4 = plVar2;
  }
  for (plVar2 = (list_head_elinks *)bookmarks_list->prev; plVar2 != plVar4;
      plVar2 = (list_head_elinks *)plVar2->prev) {
  }
  plVar2 = (list_head_elinks *)plVar1->next;
  while (plVar1 != plVar4) {
    plVar2->prev = plVar1->prev;
    *(void **)plVar1->prev = plVar1->next;
    mem_free(plVar1);
    plVar1 = plVar2;
    plVar2 = (list_head_elinks *)plVar2->next;
  }
  if (bookmark_cache != (hash *)0x0) {
    free_hash(&bookmark_cache);
  }
  return;
}



// WARNING: Unknown calling convention

bookmark * get_bookmark_by_name(bookmark *folder,uchar *title)

{
  bookmark *pbVar1;
  int iVar2;
  bookmark *bookmark;
  list_head_elinks *lh;
  bookmark *pbVar3;
  
  pbVar3 = (bookmark *)&bookmarks;
  if (folder != (bookmark *)0x0) {
    pbVar3 = (bookmark *)&folder->child;
  }
  pbVar1 = pbVar3->next;
  while( true ) {
    if (pbVar1 == pbVar3) {
      return (bookmark *)0x0;
    }
    iVar2 = strcmp((char *)pbVar1->title,(char *)title);
    if (iVar2 == 0) break;
    pbVar1 = pbVar1->next;
  }
  return pbVar1;
}



// WARNING: Unknown calling convention

void open_bookmark_folder(session *ses,uchar *foldername)

{
  int iVar1;
  uri *uri;
  uri *uri_00;
  undefined4 *puVar2;
  bookmark *bookmark;
  list_head_elinks *plVar3;
  undefined4 *local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(foldername == (uchar *)0x0 || ses == (session *)0x0);
  if (foldername == (uchar *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c";
    errline = 0x2de;
    elinks_internal((uchar *)"assertion foldername && ses failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  plVar3 = (list_head_elinks *)bookmarks.next;
  if ((list_head_elinks *)bookmarks.next != &bookmarks) {
    do {
      if ((*(int *)((int)plVar3[2].next + 0x10) == 1) &&
         (iVar1 = strcmp((char *)plVar3[2].prev,(char *)foldername), iVar1 == 0)) {
        puVar2 = (undefined4 *)plVar3[3].prev;
        if ((void **)puVar2 == &plVar3[3].prev) {
          return;
        }
        local_20 = (undefined4 *)0x0;
        do {
          if (((*(int *)(puVar2[4] + 0x10) - 1U < 2) || (*(uchar *)puVar2[6] == '\0')) ||
             (uri_00 = get_translated_uri((uchar *)puVar2[6],(uchar *)0x0), uri_00 == (uri *)0x0)) {
            puVar2 = (undefined4 *)*puVar2;
          }
          else {
            if (local_20 == (undefined4 *)0x0) {
              goto_uri(ses,uri_00);
              local_20 = puVar2;
            }
            else {
              open_uri_in_new_tab(ses,uri_00,1,0);
            }
            done_uri(uri_00);
            puVar2 = (undefined4 *)*puVar2;
          }
        } while ((void **)puVar2 != &plVar3[3].prev);
        return;
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &bookmarks);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_auto_save_bookmark_foldername_utf8(void)

{
  option_value *poVar1;
  int from;
  int to;
  conv_table *convert_table_00;
  size_t charslen;
  uchar *puVar2;
  uchar *foldername;
  conv_table *convert_table;
  int from_cp;
  int to_cp;
  
  poVar1 = get_opt_();
  puVar2 = poVar1->string;
  if (*puVar2 != '\0') {
    from = get_cp_index((uchar *)"System");
    to = get_cp_index("UTF-8");
    convert_table_00 = get_translation_table(from,to);
    if (convert_table_00 != (conv_table *)0x0) {
      charslen = strlen((char *)puVar2);
      puVar2 = convert_string_elinks
                         (convert_table_00,puVar2,charslen,to,CSM_NONE,(int *)0x0,
                          (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      return puVar2;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

bookmark * get_bookmark(uchar *url)

{
  hash *hash;
  hash_item *item;
  size_t keylen;
  hash_item *phVar1;
  
  hash = bookmark_cache;
  if (((url != (uchar *)0x0) && (bookmark_cache != (hash *)0x0)) && (*url != '\0')) {
    keylen = strlen((char *)url);
    phVar1 = get_hash_item(hash,url,keylen);
    if (phVar1 != (hash_item *)0x0) {
      return (bookmark *)phVar1->value;
    }
  }
  return (bookmark *)0x0;
}



// WARNING: Unknown calling convention

int update_bookmark(bookmark *bm,int codepage,uchar *title,uchar *url)

{
  hash *phVar1;
  int to;
  conv_table *convert_table;
  conv_table *table;
  size_t sVar2;
  hash_item *item;
  hash_item *item_00;
  uchar *url_00;
  uchar *url2;
  uchar *puVar3;
  uchar *title2;
  
  to = get_cp_index("UTF-8");
  convert_table = get_translation_table(codepage,to);
  if (convert_table == (conv_table *)0x0) {
    return 0;
  }
  url_00 = (uchar *)0x0;
  if (url != (uchar *)0x0) {
    sVar2 = strlen((char *)url);
    url_00 = convert_string_elinks
                       (convert_table,url,sVar2,to,CSM_NONE,(int *)0x0,
                        (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (url_00 == (uchar *)0x0) {
      return 0;
    }
    sanitize_url(url_00);
  }
  puVar3 = (uchar *)0x0;
  if (title != (uchar *)0x0) {
    sVar2 = strlen((char *)title);
    puVar3 = convert_string_elinks
                       (convert_table,title,sVar2,to,CSM_NONE,(int *)0x0,
                        (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (puVar3 == (uchar *)0x0) {
      if (url_00 == (uchar *)0x0) {
        return 0;
      }
      mem_free(url_00);
      return 0;
    }
    sanitize_title(puVar3);
  }
  if (update_bookmark::update_bookmark_event_id == -1) {
    update_bookmark::update_bookmark_event_id = get_event_id((uchar *)"bookmark-update");
  }
  trigger_event(update_bookmark::update_bookmark_event_id,bm,puVar3,url_00);
  if (puVar3 != (uchar *)0x0) {
    if (bm->title != (uchar *)0x0) {
      mem_free(bm->title);
    }
    bm->title = puVar3;
  }
  phVar1 = bookmark_cache;
  if (url_00 == (uchar *)0x0) {
    bookmarks_dirty = 1;
    return 1;
  }
  if (bookmark_cache != (hash *)0x0) {
    puVar3 = bm->url;
    if ((puVar3 != (uchar *)0x0) && (*puVar3 != '\0')) {
      sVar2 = strlen((char *)puVar3);
      item_00 = get_hash_item(phVar1,puVar3,sVar2);
      if (item_00 != (hash_item *)0x0) {
        del_hash_item(bookmark_cache,item_00);
      }
      if (bookmark_cache == (hash *)0x0) {
        puVar3 = bm->url;
        goto joined_r0x080672ea;
      }
    }
    phVar1 = bookmark_cache;
    if (*url_00 != '\0') {
      sVar2 = strlen((char *)url_00);
      add_hash_item(phVar1,url_00,sVar2,bm);
    }
  }
  puVar3 = bm->url;
joined_r0x080672ea:
  if (puVar3 != (uchar *)0x0) {
    mem_free(puVar3);
  }
  bm->url = url_00;
  bookmarks_dirty = 1;
  return 1;
}



// WARNING: Unknown calling convention

bookmark * add_bookmark(bookmark *root,int place,uchar *title,uchar *url)

{
  hash *hash;
  bookmark *p;
  bookmark *bm;
  uchar *puVar1;
  listbox_item_type type_00;
  listbox_item_type type;
  size_t keylen;
  listbox_item *plVar2;
  bookmark *pbVar3;
  
  p = (bookmark *)mem_calloc(1,0x24);
  pbVar3 = p;
  if (p != (bookmark *)0x0) {
    puVar1 = stracpy(title);
    p->title = puVar1;
    if (puVar1 != (uchar *)0x0) {
      sanitize_title(puVar1);
      puVar1 = "";
      if (url != (uchar *)0x0) {
        puVar1 = url;
      }
      puVar1 = stracpy(puVar1);
      p->url = puVar1;
      if (puVar1 != (uchar *)0x0) {
        sanitize_url(puVar1);
        p->root = root;
        (p->child).prev = &p->child;
        (p->child).next = &p->child;
        if (((url == (uchar *)0x0) || (type_00 = BI_LEAF, *url == '\0')) &&
           ((title == (uchar *)0x0 ||
            ((*title != '-' || (type_00 = BI_SEPARATOR, title[1] != '\0')))))) {
          type_00 = BI_FOLDER;
        }
        plVar2 = (listbox_item *)0x0;
        if (root != (bookmark *)0x0) {
          plVar2 = root->box_item;
        }
        plVar2 = add_listbox_item(&bookmark_browser,plVar2,type_00,p,(-(uint)(place == 0) & 2) - 1);
        p->box_item = plVar2;
        if (plVar2 == (listbox_item *)0x0) {
          mem_free(p->url);
          mem_free(p->title);
          mem_free(p);
          return (bookmark *)0x0;
        }
        if (place == 0) {
          if (root == (bookmark *)0x0) {
            p->prev = (bookmark *)&bookmarks;
            p->next = (bookmark *)bookmarks.next;
            bookmarks.next = p;
            p->next->prev = p;
          }
          else {
            pbVar3 = (bookmark *)(root->child).next;
            p->prev = (bookmark *)&root->child;
            p->next = pbVar3;
            (root->child).next = p;
            p->next->prev = p;
          }
        }
        else if (root == (bookmark *)0x0) {
                    // WARNING: Load size is inaccurate
          p->next = *bookmarks.prev;
          p->prev = (bookmark *)bookmarks.prev;
          *(bookmark **)bookmarks.prev = p;
          p->next->prev = p;
        }
        else {
                    // WARNING: Load size is inaccurate
          p->next = *(root->child).prev;
          p->prev = (bookmark *)(root->child).prev;
          *(bookmark **)(root->child).prev = p;
          p->next->prev = p;
        }
        bookmarks_dirty = 1;
        if ((bookmark_cache == (hash *)0x0) &&
           (bookmark_cache = init_hash8(), bookmark_cache == (hash *)0x0)) {
          return p;
        }
        hash = bookmark_cache;
        puVar1 = p->url;
        if (puVar1 == (uchar *)0x0) {
          return p;
        }
        if (*puVar1 == '\0') {
          return p;
        }
        keylen = strlen((char *)puVar1);
        add_hash_item(hash,puVar1,keylen,p);
        return p;
      }
      mem_free(p->title);
    }
    pbVar3 = (bookmark *)0x0;
    mem_free(p);
  }
  return pbVar3;
}



// WARNING: Unknown calling convention

bookmark * add_bookmark_cp(bookmark *root,int place,int codepage,uchar *title,uchar *url)

{
  int to;
  conv_table *convert_table;
  bookmark *bookmark;
  size_t sVar1;
  uchar *title_00;
  uchar *url_00;
  uchar *utf8_url;
  bookmark *pbVar2;
  uchar *utf8_title;
  conv_table *table;
  int utf8_cp;
  
  to = get_cp_index("UTF-8");
  if (url == (uchar *)0x0) {
    url = "";
  }
  convert_table = get_translation_table(codepage,to);
  if (convert_table == (conv_table *)0x0) {
    return (bookmark *)0x0;
  }
  sVar1 = strlen((char *)title);
  title_00 = convert_string_elinks
                       (convert_table,title,sVar1,to,CSM_NONE,(int *)0x0,
                        (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  sVar1 = strlen((char *)url);
  url_00 = convert_string_elinks
                     (convert_table,url,sVar1,to,CSM_NONE,(int *)0x0,
                      (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  if (url_00 != (uchar *)0x0) {
    if (title_00 != (uchar *)0x0) {
      pbVar2 = add_bookmark(root,place,title_00,url_00);
      goto LAB_080676e9;
    }
  }
  else {
    pbVar2 = (bookmark *)0x0;
    if (title_00 != (uchar *)0x0) {
LAB_080676e9:
      mem_free(title_00);
      goto LAB_080676f7;
    }
  }
  pbVar2 = (bookmark *)0x0;
LAB_080676f7:
  if (url_00 != (uchar *)0x0) {
    mem_free(url_00);
  }
  return pbVar2;
}



// WARNING: Unknown calling convention

void bookmark_terminal(terminal *term,bookmark *folder)

{
  int iVar1;
  undefined *puVar2;
  session *ses_00;
  int codepage;
  uchar *puVar3;
  window *tab;
  session *ses;
  int in_GS_OFFSET;
  uchar url [1024];
  uchar title [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  codepage = get_terminal_codepage(term);
  puVar2 = (undefined *)(term->windows).prev;
  do {
    while( true ) {
      if ((list_head_elinks *)puVar2 == &term->windows) {
        if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
          return;
        }
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      if (*(int *)(puVar2 + 8) == 1) break;
LAB_08067780:
      puVar2 = *(undefined **)(puVar2 + 4);
    }
    ses_00 = *(session **)(puVar2 + 0x10);
    puVar3 = get_current_url(ses_00,url,0x400);
    if ((puVar3 == (uchar *)0x0) ||
       (puVar3 = get_current_title(ses_00,title,0x400), puVar3 == (uchar *)0x0)) goto LAB_08067780;
    add_bookmark_cp(folder,1,codepage,title,url);
    puVar2 = *(undefined **)(puVar2 + 4);
  } while( true );
}



// WARNING: Unknown calling convention

void bookmark_terminal_tabs(terminal *term,uchar *foldername)

{
  bookmark *folder_00;
  bookmark *folder;
  
  folder_00 = add_bookmark((bookmark *)0x0,1,foldername,(uchar *)0x0);
  if (folder_00 != (bookmark *)0x0) {
    bookmark_terminal(term,folder_00);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void delete_bookmark(bookmark *bm)

{
  bookmark *bm_00;
  uchar *key;
  hash *hash;
  hash_item *item;
  size_t keylen;
  hash_item *item_00;
  
  bm_00 = (bookmark *)(bm->child).next;
  hash = bookmark_cache;
  while (bookmark_cache = hash, bm_00 != (bookmark *)&bm->child) {
    delete_bookmark(bm_00);
    hash = bookmark_cache;
    bm_00 = (bookmark *)(bm->child).next;
  }
  if (((hash != (hash *)0x0) && (key = bm->url, key != (uchar *)0x0)) && (*key != '\0')) {
    keylen = strlen((char *)key);
    item_00 = get_hash_item(hash,key,keylen);
    if (item_00 != (hash_item *)0x0) {
      del_hash_item(bookmark_cache,item_00);
    }
  }
  if (delete_bookmark::delete_bookmark_event_id == -1) {
    delete_bookmark::delete_bookmark_event_id = get_event_id((uchar *)"bookmark-delete");
  }
  trigger_event(delete_bookmark::delete_bookmark_event_id,bm);
  bm->next->prev = bm->prev;
  bm->prev->next = bm->next;
  bookmarks_dirty = 1;
  done_listbox_item(&bookmark_browser,bm->box_item);
  mem_free(bm->title);
  mem_free(bm->url);
  mem_free(bm);
  return;
}



// WARNING: Unknown calling convention

void bookmark_auto_save_tabs(terminal *term)

{
  bookmark *pbVar1;
  option_value *poVar2;
  uchar *foldername;
  int iVar3;
  bookmark *pbVar4;
  bookmark *bookmark;
  bookmark *bm;
  
  poVar2 = get_opt_();
  if (((poVar2->tree != (list_head_elinks *)0x0) ||
      (poVar2 = get_opt_(), poVar2->tree == (list_head_elinks *)0x0)) ||
     (foldername = get_auto_save_bookmark_foldername_utf8(), foldername == (uchar *)0x0)) {
    return;
  }
                    // WARNING: Load size is inaccurate
  pbVar1 = *bookmarks.next;
  bm = (bookmark *)bookmarks.next;
  if ((list_head_elinks *)bookmarks.next != &bookmarks) {
    do {
      while (((pbVar4 = pbVar1, bm->url != (uchar *)0x0 && (*bm->url != '\0')) ||
             (iVar3 = strcmp((char *)bm->title,(char *)foldername), iVar3 != 0))) {
        pbVar1 = pbVar4->next;
        bm = pbVar4;
        if (pbVar4 == (bookmark *)&bookmarks) goto LAB_08067a40;
      }
      delete_bookmark(bm);
      pbVar1 = pbVar4->next;
      bm = pbVar4;
    } while (pbVar4 != (bookmark *)&bookmarks);
  }
LAB_08067a40:
  bookmark_terminal_tabs(term,foldername);
  mem_free(foldername);
  return;
}



// WARNING: Unknown calling convention

void write_bookmarks(void)

{
  option_value *poVar1;
  
  poVar1 = get_opt_();
  if (poVar1->tree != (list_head_elinks *)0x0) {
    bookmarks_dirty = 0;
    return;
  }
  bookmarks_write(&bookmarks);
  return;
}



// WARNING: Unknown calling convention

void done_bookmarks(module *module)

{
  if (bm_snapshot_last_folder != (bookmark *)0x0) {
    delete_bookmark(bm_snapshot_last_folder);
  }
  bm_snapshot_last_folder = (bookmark *)0x0;
  write_bookmarks();
  free_bookmarks(&bookmarks,&bookmark_browser.root.child);
  free_last_searched_bookmark();
  return;
}



// WARNING: Unknown calling convention

evhook_status bookmark_write_hook(va_list ap,void *data)

{
  option_value *poVar1;
  string *psVar2;
  int codepage;
  bookmark *folder;
  bookmark *pbVar3;
  bookmark *subfolder;
  uint uVar4;
  terminal *term;
  terminal *term_00;
  uint n;
  ulong number;
  string folderstring;
  uchar subfoldername [4];
  
  poVar1 = get_opt_();
  pbVar3 = bm_snapshot_last_folder;
  if ((poVar1->tree != (list_head_elinks *)0x0) &&
     (poVar1 = get_opt_(), pbVar3 = bm_snapshot_last_folder, poVar1->tree == (list_head_elinks *)0x0
     )) {
    psVar2 = init_string(&folderstring);
    pbVar3 = bm_snapshot_last_folder;
    if (psVar2 != (string *)0x0) {
      add_to_string(&folderstring,(uchar *)"Session snapshot");
      add_to_string(&folderstring," - ");
      poVar1 = get_opt_();
      add_date_to_string(&folderstring,poVar1->string,(time_t *)0x0);
      codepage = get_cp_index((uchar *)"System");
      folder = add_bookmark_cp((bookmark *)0x0,1,codepage,folderstring.source,(uchar *)0x0);
      done_string(&folderstring);
      pbVar3 = bm_snapshot_last_folder;
      if (folder != (bookmark *)0x0) {
        poVar1 = get_opt_();
        if (poVar1->tree == (list_head_elinks *)0x0) {
          if (terminals.next == terminals.prev) {
            bookmark_terminal((terminal *)terminals.next,folder);
          }
          else if ((list_head_elinks *)terminals.next != &terminals) {
            number = 0;
            term_00 = (terminal *)terminals.next;
            while ((uVar4 = elinks_ulongcat(subfoldername,(uint *)0x0,number,4,'\0',10,0), uVar4 < 4
                   && (pbVar3 = add_bookmark(folder,1,subfoldername,(uchar *)0x0),
                      pbVar3 != (bookmark *)0x0))) {
              bookmark_terminal(term_00,pbVar3);
              term_00 = term_00->next;
              if (term_00 == (terminal *)&terminals) break;
              number = number + 1;
            }
          }
        }
        pbVar3 = folder;
        if (bm_snapshot_last_folder != (bookmark *)0x0) {
          delete_bookmark(bm_snapshot_last_folder);
        }
      }
    }
  }
  bm_snapshot_last_folder = pbVar3;
  write_bookmarks();
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

void read_bookmarks(void)

{
  bookmarks_read();
  return;
}



// WARNING: Unknown calling convention

void init_bookmarks(module *module)

{
  register_change_hooks(init_bookmarks::bookmarks_change_hooks);
  bookmarks_read();
  return;
}



// WARNING: Unknown calling convention

void lock_bookmark(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_bookmark(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_bookmark_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

listbox_item * get_bookmark_root(listbox_item *item)

{
  int iVar1;
  listbox_item *plVar2;
  
  iVar1 = *(int *)((int)item->udata + 0xc);
  plVar2 = (listbox_item *)0x0;
  if (iVar1 != 0) {
    plVar2 = *(listbox_item **)(iVar1 + 0x10);
  }
  return plVar2;
}



// WARNING: Unknown calling convention

int can_delete_bookmark(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void bookmark_edit_cancel(dialog *dlg)

{
  int *piVar1;
  bookmark *bm;
  
  piVar1 = (int *)((int)dlg->udata2 + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

void update_depths(listbox_item *parent)

{
  listbox_item *item;
  listbox_item *parent_00;
  
  parent_00 = (listbox_item *)(parent->child).next;
  do {
    if (parent_00 == (listbox_item *)&parent->child) {
      return;
    }
    while (parent_00->depth = parent->depth + 1, parent_00->type != BI_FOLDER) {
      parent_00 = parent_00->next;
      if (parent_00 == (listbox_item *)&parent->child) {
        return;
      }
    }
    update_depths(parent_00);
    parent_00 = parent_00->next;
  } while( true );
}



// WARNING: Unknown calling convention

void delete_bookmark_item(listbox_item *item,int last)

{
  bookmark *bm;
  bookmark *bookmark;
  
  bm = (bookmark *)item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)((bm->object).refcount != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
    errline = 0x8a;
    elinks_internal((uchar *)"assertion !is_object_used(bookmark) failed!");
  }
  delete_bookmark(bm);
  if (last == 0) {
    return;
  }
  write_bookmarks();
  return;
}



// WARNING: Unknown calling convention

uri * get_bookmark_uri(listbox_item *item)

{
  uchar *uristring;
  uri *puVar1;
  
  uristring = *(uchar **)((int)item->udata + 0x18);
  if ((uristring != (uchar *)0x0) && (*uristring != '\0')) {
    puVar1 = get_translated_uri(uristring,(uchar *)0x0);
    return puVar1;
  }
  return (uri *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_bookmark_text(listbox_item *item,terminal *term)

{
  void *pvVar1;
  int from;
  int to;
  conv_table *convert_table_00;
  uchar *puVar2;
  size_t charslen;
  int utf8_cp;
  conv_table *convert_table;
  int term_cp;
  
  pvVar1 = item->udata;
  from = get_cp_index("UTF-8");
  to = get_terminal_codepage(term);
  convert_table_00 = get_translation_table(from,to);
  puVar2 = (uchar *)0x0;
  if (convert_table_00 != (conv_table *)0x0) {
    puVar2 = *(uchar **)((int)pvVar1 + 0x14);
    charslen = strlen((char *)puVar2);
    puVar2 = convert_string_elinks
                       (convert_table_00,puVar2,charslen,to,CSM_NONE,(int *)0x0,
                        (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  }
  return puVar2;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_bookmark_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  int from;
  int to;
  conv_table *convert_table_00;
  string *psVar2;
  uchar *puVar3;
  size_t sVar4;
  int term_cp;
  conv_table *convert_table;
  string info;
  
  pvVar1 = item->udata;
  from = get_cp_index("UTF-8");
  to = get_terminal_codepage(term);
  if (((item->type != BI_FOLDER) &&
      (convert_table_00 = get_translation_table(from,to), convert_table_00 != (conv_table *)0x0)) &&
     (psVar2 = init_string(&info), psVar2 != (string *)0x0)) {
    puVar3 = _((uchar *)"Title",term);
    add_format_to_string(&info,"%s: ",puVar3);
    puVar3 = *(uchar **)((int)pvVar1 + 0x14);
    sVar4 = strlen((char *)puVar3);
    convert_string_elinks
              (convert_table_00,puVar3,sVar4,to,CSM_NONE,(int *)0x0,add_converted_bytes_to_string,
               &info);
    puVar3 = _("URL",term);
    add_format_to_string(&info,"\n%s: ",puVar3);
    puVar3 = *(uchar **)((int)pvVar1 + 0x18);
    sVar4 = strlen((char *)puVar3);
    convert_string_elinks
              (convert_table_00,puVar3,sVar4,to,CSM_NONE,(int *)0x0,add_converted_bytes_to_string,
               &info);
    return info.source;
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void add_converted_bytes_to_string(void *data,uchar *buf,int buflen)

{
  int iVar1;
  void *pvVar2;
  size_t oldsize;
  uint uVar3;
  int newlength;
  size_t newsize;
  uint size;
  
  if (assert_failed == 0) {
    if (((buf == (uchar *)0x0) || (data == (void *)0x0)) || (buflen < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_08068188;
    }
    else {
      assert_failed = 0;
    }
    if (buflen != 0) {
      iVar1 = buflen + *(int *)((int)data + 4);
      uVar3 = *(int *)((int)data + 4) + 0xffU & 0xffffff00;
      size = iVar1 + 0x100U & 0xffffff00;
      if (uVar3 < size) {
                    // WARNING: Load size is inaccurate
        pvVar2 = mem_realloc(*data,size);
        if (pvVar2 == (void *)0x0) {
          return;
        }
        *(void **)data = pvVar2;
        memset((void *)((int)pvVar2 + uVar3),0,size - uVar3);
      }
                    // WARNING: Load size is inaccurate
      if (*data != 0) {
        memcpy((void *)(*data + *(int *)((int)data + 4)),buf,buflen);
                    // WARNING: Load size is inaccurate
        *(undefined *)(*data + iVar1) = 0;
        *(int *)((int)data + 4) = iVar1;
      }
    }
  }
  else {
LAB_08068188:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void free_last_searched_bookmark(void)

{
  if (bm_last_searched_title != (uchar *)0x0) {
    mem_free(bm_last_searched_title);
  }
  bm_last_searched_title = (uchar *)0x0;
  if (bm_last_searched_url != (uchar *)0x0) {
    mem_free(bm_last_searched_url);
  }
  bm_last_searched_url = (uchar *)0x0;
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_search_button(dialog_data *dlg_data,widget_data *widget_data)

{
  session *ses;
  terminal *term;
  int from;
  int to;
  conv_table *convert_table_00;
  conv_table *convert_table;
  size_t sVar1;
  uchar *puVar2;
  uchar *src_url;
  uchar *url;
  uchar *title;
  int utf8_cp;
  
  ses = (session *)dlg_data->dlg->udata;
  term = dlg_data->win->term;
  if ((bm_last_searched_title != (uchar *)0x0) && (bm_last_searched_url != (uchar *)0x0)) {
    from = get_cp_index("UTF-8");
    to = get_terminal_codepage(term);
    convert_table_00 = get_translation_table(from,to);
    puVar2 = bm_last_searched_title;
    if (convert_table_00 != (conv_table *)0x0) {
      sVar1 = strlen((char *)bm_last_searched_title);
      puVar2 = convert_string_elinks
                         (convert_table_00,puVar2,sVar1,to,CSM_NONE,(int *)0x0,
                          (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      sVar1 = strlen((char *)bm_last_searched_url);
      src_url = convert_string_elinks
                          (convert_table_00,bm_last_searched_url,sVar1,to,CSM_NONE,(int *)0x0,
                           (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (src_url == (uchar *)0x0) {
        if (puVar2 != (uchar *)0x0) {
          mem_free(puVar2);
        }
      }
      else {
        if (puVar2 != (uchar *)0x0) {
          do_edit_dialog(term,1,(uchar *)"Search bookmarks",puVar2,src_url,ses,dlg_data,
                         bookmark_search_do,(_func_void_dialog_ptr *)0x0,(void *)0x0,EDIT_DLG_SEARCH
                        );
          mem_free(puVar2);
          mem_free(src_url);
          return EVENT_PROCESSED;
        }
        mem_free(src_url);
      }
    }
  }
  do_edit_dialog(term,1,(uchar *)"Search bookmarks",(uchar *)0x0,(uchar *)0x0,ses,dlg_data,
                 bookmark_search_do,(_func_void_dialog_ptr *)0x0,(void *)0x0,EDIT_DLG_SEARCH);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void launch_bm_add_dialog(terminal *term,dialog_data *parent,session *ses,uchar *title,uchar *url)

{
  do_edit_dialog(term,1,(uchar *)"Add bookmark",title,url,ses,parent,bookmark_add_add,
                 (_func_void_dialog_ptr *)0x0,term,EDIT_DLG_ADD);
  return;
}



// WARNING: Unknown calling convention

void launch_bm_add_doc_dialog(terminal *term,dialog_data *parent,session *ses)

{
  launch_bm_add_dialog(term,parent,ses,(uchar *)0x0,(uchar *)0x0);
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_add_button(dialog_data *dlg_data,widget_data *widget_data)

{
  launch_bm_add_doc_dialog(dlg_data->win->term,dlg_data,(session *)dlg_data->dlg->udata);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_edit_button(dialog_data *dlg_data,widget_data *edit_btn)

{
  void *done_data;
  listbox_data *box;
  listbox_data *plVar1;
  int from;
  int to;
  conv_table *convert_table_00;
  conv_table *convert_table;
  size_t sVar2;
  uchar *src_name;
  uchar *puVar3;
  uchar *title;
  int utf8_cp;
  uchar *url;
  int term_cp;
  
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  if (plVar1->sel == (listbox_item *)0x0) {
    return EVENT_PROCESSED;
  }
  done_data = plVar1->sel->udata;
  from = get_cp_index("UTF-8");
  to = get_terminal_codepage(dlg_data->win->term);
  convert_table_00 = get_translation_table(from,to);
  if (convert_table_00 == (conv_table *)0x0) {
    return EVENT_PROCESSED;
  }
  puVar3 = *(uchar **)((int)done_data + 0x14);
  sVar2 = strlen((char *)puVar3);
  src_name = convert_string_elinks
                       (convert_table_00,puVar3,sVar2,to,CSM_NONE,(int *)0x0,
                        (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  puVar3 = *(uchar **)((int)done_data + 0x18);
  sVar2 = strlen((char *)puVar3);
  puVar3 = convert_string_elinks
                     (convert_table_00,puVar3,sVar2,to,CSM_NONE,(int *)0x0,
                      (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  if (puVar3 != (uchar *)0x0) {
    if (src_name == (uchar *)0x0) goto LAB_0806862f;
    *(int *)((int)done_data + 8) = *(int *)((int)done_data + 8) + 1;
    do_edit_dialog(dlg_data->win->term,1,(uchar *)"Edit bookmark",src_name,puVar3,
                   (session *)dlg_data->dlg->udata,dlg_data,bookmark_edit_done,bookmark_edit_cancel,
                   done_data,EDIT_DLG_ADD);
  }
  else if (src_name == (uchar *)0x0) {
    return EVENT_PROCESSED;
  }
  mem_free(src_name);
LAB_0806862f:
  if (puVar3 != (uchar *)0x0) {
    mem_free(puVar3);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void bookmark_search_do(void *data)

{
  int *piVar1;
  uchar *puVar2;
  uchar *chars;
  int from;
  conv_table *pcVar3;
  conv_table *convert_table;
  size_t sVar4;
  listbox_data *box_00;
  listbox_data *box;
  void *p;
  void *p_1;
  uchar *src;
  uchar *title_utf8;
  widget_data *widget_data;
  int term_cp;
  bookmark_search_ctx ctx;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  ctx.url = (uchar *)0x0;
  ctx.title = (uchar *)0x0;
  ctx.found = 0;
  ctx.offset = 0;
  ctx.utf8_cp = -1;
  ctx.system_cp = -1;
  assert_failed = (int)(*(int *)((int)data + 4) == 0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
    errline = 0x2ee;
    elinks_internal((uchar *)
                    "assertion dlg->udata != NULL failed: Bookmark search with NULL udata in dialog"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  piVar1 = *(int **)((int)data + 4);
  from = get_terminal_codepage(*(terminal **)(*piVar1 + 0x14));
  ctx.system_cp = get_cp_index((uchar *)"System");
  ctx.utf8_cp = get_cp_index("UTF-8");
  puVar2 = *(uchar **)((int)data + 0x30);
  chars = *(uchar **)((int)data + 0x60);
  pcVar3 = get_translation_table(from,ctx.system_cp);
  if (pcVar3 == (conv_table *)0x0) goto free_all;
  sVar4 = strlen((char *)puVar2);
  src = (uchar *)0x0;
  ctx.title = convert_string_elinks
                        (pcVar3,puVar2,sVar4,ctx.system_cp,CSM_NONE,(int *)0x0,
                         (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
  if (ctx.title == (uchar *)0x0) goto LAB_08068911;
  pcVar3 = get_translation_table(from,ctx.utf8_cp);
  if (pcVar3 == (conv_table *)0x0) {
free_all:
    src = (uchar *)0x0;
  }
  else {
    sVar4 = strlen((char *)chars);
    ctx.url = convert_string_elinks
                        (pcVar3,chars,sVar4,ctx.utf8_cp,CSM_NONE,(int *)0x0,
                         (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (ctx.url == (uchar *)0x0) goto free_all;
    sVar4 = strlen((char *)puVar2);
    src = convert_string_elinks
                    (pcVar3,puVar2,sVar4,ctx.utf8_cp,CSM_NONE,(int *)0x0,
                     (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    puVar2 = ctx.url;
    if (src != (uchar *)0x0) {
      if (bm_last_searched_title != (uchar *)0x0) {
        mem_free(bm_last_searched_title);
      }
      bm_last_searched_title = stracpy(src);
      if (bm_last_searched_title != (uchar *)0x0) {
        if (bm_last_searched_url != (uchar *)0x0) {
          mem_free(bm_last_searched_url);
        }
        bm_last_searched_url = stracpy(puVar2);
        if (bm_last_searched_url == (uchar *)0x0) {
          if (bm_last_searched_title != (uchar *)0x0) {
            mem_free(bm_last_searched_title);
          }
          bm_last_searched_title = (uchar *)0x0;
        }
        else {
          widget_data = (widget_data *)(piVar1 + 10);
          box_00 = get_listbox_widget_data(widget_data);
          traverse_listbox_items_list(box_00->sel,box_00,0,0,test_search,&ctx);
          if (ctx.found != 0) {
            listbox_sel_move(widget_data,ctx.offset + -1);
          }
        }
      }
    }
  }
  if (ctx.title != (uchar *)0x0) {
    mem_free(ctx.title);
  }
LAB_08068911:
  if (ctx.url != (uchar *)0x0) {
    mem_free(ctx.url);
  }
  if (src != (uchar *)0x0) {
    mem_free(src);
  }
  return;
}



// WARNING: Unknown calling convention

int test_search(listbox_item *item,void *data_,int *offset)

{
  void *pvVar1;
  conv_table *convert_table_00;
  conv_table *convert_table;
  size_t charslen;
  uchar *puVar2;
  char *pcVar3;
  bookmark *bm;
  uchar *title;
  
  if (*(int *)((int)data_ + 0xc) == 0) {
    *(undefined4 *)((int)data_ + 8) = 0;
    goto LAB_080689fe;
  }
  pvVar1 = item->udata;
  if (assert_failed == 0) {
                    // WARNING: Load size is inaccurate
    if ((*(int *)((int)data_ + 4) == 0) || (*data_ == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
      errline = 0x298;
      elinks_internal((uchar *)"assertion ctx->title && ctx->url failed!");
    }
    else {
      assert_failed = 0;
    }
  }
                    // WARNING: Load size is inaccurate
  if ((**data_ == '\0') ||
     (pcVar3 = c_strcasestr(*(char **)((int)pvVar1 + 0x18),*data_), pcVar3 == (char *)0x0)) {
    *(undefined4 *)((int)data_ + 8) = 0;
    if (**(char **)((int)data_ + 4) == '\0') goto LAB_080689fe;
    convert_table_00 =
         get_translation_table(*(int *)((int)data_ + 0x10),*(int *)((int)data_ + 0x14));
    if (convert_table_00 != (conv_table *)0x0) {
      puVar2 = *(uchar **)((int)pvVar1 + 0x14);
      charslen = strlen((char *)puVar2);
      puVar2 = convert_string_elinks
                         (convert_table_00,puVar2,charslen,*(int *)((int)data_ + 0x14),CSM_NONE,
                          (int *)0x0,(_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (puVar2 != (uchar *)0x0) {
        pcVar3 = strcasestr((char *)puVar2,*(char **)((int)data_ + 4));
        *(uint *)((int)data_ + 8) = (uint)(pcVar3 != (char *)0x0);
        mem_free(puVar2);
      }
    }
    if (*(int *)((int)data_ + 8) == 0) goto LAB_080689fe;
  }
  else {
    *(undefined4 *)((int)data_ + 8) = 1;
  }
  *offset = 0;
LAB_080689fe:
  *(int *)((int)data_ + 0xc) = *(int *)((int)data_ + 0xc) + 1;
  return 0;
}



// WARNING: Unknown calling convention
// Local variable box2:listbox_data *[EAX:4] conflicts with parameter, skipped.

move_bookmark_flags
do_move_bookmark(bookmark *dest,int insert_as_child,list_head_elinks *src,listbox_data *box)

{
  byte bVar1;
  bookmark *pbVar2;
  listbox_item *plVar3;
  listbox_data *plVar4;
  int iVar5;
  bookmark *next;
  move_bookmark_flags mVar6;
  widget_data *widget_data;
  bookmark *bm;
  bookmark *pbVar7;
  hierbox_dialog_list_item *item;
  int *piVar8;
  int local_2c;
  move_bookmark_flags local_24;
  bookmark *local_20;
  
  if (do_move_bookmark::move_bookmark_event_id == -1) {
    do_move_bookmark::move_bookmark_event_id = get_event_id((uchar *)"bookmark-move");
  }
  pbVar7 = (bookmark *)src->next;
  local_20 = pbVar7->next;
  local_24 = MOVE_BOOKMARK_NONE;
  if (pbVar7 == (bookmark *)src) {
    return MOVE_BOOKMARK_NONE;
  }
  plVar3 = pbVar7->box_item;
  bVar1 = plVar3->field_0x18;
  local_2c = insert_as_child;
  if ((bVar1 & 4) == 0) goto LAB_08068c8e;
LAB_08068b68:
  if ((pbVar7 == dest) || (pbVar7 == move_cache_root_avoid)) {
    local_24 = local_24 | MOVE_BOOKMARK_CYCLE;
    if (plVar3->type == BI_FOLDER) goto LAB_08068c94;
  }
  else {
    local_24 = local_24 | MOVE_BOOKMARK_MOVED;
    plVar3->field_0x18 = bVar1 & 0xfb;
    trigger_event(do_move_bookmark::move_bookmark_event_id,pbVar7,dest);
    piVar8 = (int *)bookmark_browser.dialogs.next;
    if ((list_head_elinks *)bookmark_browser.dialogs.next != &bookmark_browser.dialogs) {
      do {
        iVar5 = piVar8[2];
        plVar4 = get_listbox_widget_data((widget_data *)(iVar5 + 0x28));
        if (plVar4->top == pbVar7->box_item) {
          listbox_sel_move((widget_data *)(iVar5 + 0x28),1);
        }
        piVar8 = (int *)*piVar8;
      } while (piVar8 != (int *)0x81377d8);
    }
    pbVar7->box_item->next->prev = pbVar7->box_item->prev;
    pbVar7->box_item->prev->next = pbVar7->box_item->next;
    pbVar7->next->prev = pbVar7->prev;
    pbVar7->prev->next = pbVar7->next;
    if (local_2c == 0) {
      pbVar2 = dest->next;
      pbVar7->prev = dest;
      pbVar7->next = pbVar2;
      dest->next = pbVar7;
      pbVar7->next->prev = pbVar7;
      pbVar7->box_item->next = dest->box_item->next;
      pbVar7->box_item->prev = dest->box_item;
      dest->box_item->next = pbVar7->box_item;
      pbVar7->box_item->next->prev = pbVar7->box_item;
      dest = dest->root;
      pbVar7->root = dest;
    }
    else {
      pbVar2 = (bookmark *)(dest->child).next;
      pbVar7->prev = (bookmark *)&dest->child;
      pbVar7->next = pbVar2;
      (dest->child).next = pbVar7;
      pbVar7->next->prev = pbVar7;
      pbVar7->box_item->next = (listbox_item *)(dest->box_item->child).next;
      pbVar7->box_item->prev = (listbox_item *)&dest->box_item->child;
      (dest->box_item->child).next = pbVar7->box_item;
      pbVar7->box_item->next->prev = pbVar7->box_item;
      pbVar7->root = dest;
    }
    iVar5 = 0;
    if (dest != (bookmark *)0x0) {
      iVar5 = dest->box_item->depth + 1;
    }
    pbVar7->box_item->depth = iVar5;
    local_2c = 0;
    dest = pbVar7;
    if (pbVar7->box_item->type == BI_FOLDER) {
      update_depths(pbVar7->box_item);
      local_2c = 0;
    }
  }
  do {
    pbVar2 = local_20->next;
    pbVar7 = local_20;
    while( true ) {
      local_20 = pbVar2;
      if ((bookmark *)src == pbVar7) {
        return local_24;
      }
      plVar3 = pbVar7->box_item;
      bVar1 = plVar3->field_0x18;
      if ((bVar1 & 4) != 0) goto LAB_08068b68;
LAB_08068c8e:
      if (plVar3->type != BI_FOLDER) break;
LAB_08068c94:
      mVar6 = do_move_bookmark(dest,local_2c,&pbVar7->child,box);
      local_24 = local_24 | mVar6;
      pbVar2 = local_20->next;
      pbVar7 = local_20;
    }
  } while( true );
}



// WARNING: Unknown calling convention

widget_handler_status_T push_move_button(dialog_data *dlg_data,widget_data *blah)

{
  listbox_item *plVar1;
  move_bookmark_flags result;
  listbox_data *box_00;
  listbox_data *box;
  bookmark *dest;
  move_bookmark_flags mVar2;
  bookmark *bm;
  bookmark *pbVar3;
  uint insert_as_child_00;
  int insert_as_child;
  char *title;
  char *text;
  
  box_00 = get_listbox_widget_data(dlg_data->widgets_data);
  plVar1 = box_00->sel;
  if (plVar1 != (listbox_item *)0x0) {
    insert_as_child_00 = 0;
    if (plVar1->type == BI_FOLDER) {
      insert_as_child_00 = (byte)plVar1->field_0x18 & 1;
    }
    move_cache_root_avoid = (bookmark *)0x0;
    pbVar3 = ((bookmark *)plVar1->udata)->root;
    if (pbVar3 != (bookmark *)0x0) {
      move_cache_root_avoid = (bookmark *)0x0;
      do {
        if ((pbVar3->box_item->field_0x18 & 4) != 0) {
          move_cache_root_avoid = pbVar3;
        }
        pbVar3 = pbVar3->root;
      } while (pbVar3 != (bookmark *)0x0);
    }
    mVar2 = do_move_bookmark((bookmark *)plVar1->udata,insert_as_child_00,&bookmarks,box_00);
    if ((mVar2 & MOVE_BOOKMARK_MOVED) != MOVE_BOOKMARK_NONE) {
      bookmarks_set_dirty();
      write_bookmarks();
      update_hierbox_browser(&bookmark_browser);
      return EVENT_PROCESSED;
    }
    if ((mVar2 & MOVE_BOOKMARK_CYCLE) == MOVE_BOOKMARK_NONE) {
      text = 
      "To move bookmarks, first mark all the bookmarks (or folders) you want to move.  This can be done with the Insert key if you\'re using the default key-bindings.  An asterisk will appear near all marked bookmarks.  Now move to where you want to have the stuff moved to, and press the \"Move\" button."
      ;
      title = "Nothing to move";
    }
    else {
      text = 
      "You are trying to move the marked folder inside itself. To move the folder to a different location select the new location before pressing the Move button."
      ;
      title = "Cannot move folder inside itself";
    }
    info_box(dlg_data->win->term,0,(uchar *)title,ALIGN_LEFT,(uchar *)text);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_add_folder_button(dialog_data *dlg_data,widget_data *widget_data)

{
  input_dialog(dlg_data->win->term,(memory_list *)0x0,(uchar *)"Add folder",(uchar *)"Folder name",
               dlg_data,(input_history *)0x0,0x400,(uchar *)0x0,0,0,(widget_handler_T *)0x0,
               do_add_folder,(done_handler_T *)0x0);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention
// Local variable box:listbox_data *[EAX:4] conflicts with parameter, skipped.

void do_add_bookmark(terminal *term,dialog_data *dlg_data,uchar *title,uchar *url)

{
  listbox_item *plVar1;
  bookmark *pbVar2;
  int codepage;
  listbox_data *plVar3;
  bookmark *pbVar4;
  bookmark *bm;
  int term_cp;
  bookmark *selected;
  bookmark *pbVar5;
  
  codepage = get_terminal_codepage(term);
  if (dlg_data != (dialog_data *)0x0) {
    plVar3 = get_listbox_widget_data(dlg_data->widgets_data);
    plVar1 = plVar3->sel;
    if (plVar1 != (listbox_item *)0x0) {
      pbVar5 = (bookmark *)plVar1->udata;
      if ((plVar1->type != BI_FOLDER) || (pbVar4 = pbVar5, (plVar1->field_0x18 & 1) == 0)) {
        pbVar4 = pbVar5->root;
      }
      goto LAB_08068f2b;
    }
  }
  pbVar5 = (bookmark *)0x0;
  pbVar4 = (bookmark *)0x0;
LAB_08068f2b:
  pbVar4 = add_bookmark_cp(pbVar4,1,codepage,title,url);
  if (pbVar4 != (bookmark *)0x0) {
    if ((((pbVar5 != (bookmark *)0x0) && (pbVar5 != pbVar4->root)) &&
        (pbVar5->box_item != (listbox_item *)0x0)) &&
       (plVar1 = pbVar4->box_item, plVar1 != (listbox_item *)0x0)) {
      plVar1->next->prev = plVar1->prev;
      pbVar4->box_item->prev->next = pbVar4->box_item->next;
      pbVar4->next->prev = pbVar4->prev;
      pbVar4->prev->next = pbVar4->next;
      pbVar2 = pbVar5->next;
      pbVar4->prev = pbVar5;
      pbVar4->next = pbVar2;
      pbVar5->next = pbVar4;
      pbVar4->next->prev = pbVar4;
      pbVar4->box_item->next = pbVar5->box_item->next;
      pbVar4->box_item->prev = pbVar5->box_item;
      pbVar5->box_item->next = pbVar4->box_item;
      pbVar4->box_item->next->prev = pbVar4->box_item;
    }
    write_bookmarks();
    if (dlg_data != (dialog_data *)0x0) {
      listbox_sel(dlg_data->widgets_data,pbVar4->box_item);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void do_add_folder(dialog_data *dlg_data,uchar *foldername)

{
  do_add_bookmark(dlg_data->win->term,dlg_data,foldername,(uchar *)0x0);
  return;
}



// WARNING: Unknown calling convention

void bookmark_add_add(void *data)

{
  do_add_bookmark(*(terminal **)((int)data + 8),*(dialog_data **)((int)data + 4),
                  *(uchar **)((int)data + 0x30),*(uchar **)((int)data + 0x60));
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_add_separator_button(dialog_data *dlg_data,widget_data *widget_data)

{
  do_add_bookmark(dlg_data->win->term,dlg_data,"-","");
  redraw_dialog(dlg_data,1);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void bookmark_edit_done(void *data)

{
  object *poVar1;
  bookmark *bm_00;
  int codepage;
  int term_cp;
  bookmark *bm;
  
  bm_00 = *(bookmark **)((int)data + 8);
  codepage = get_terminal_codepage(*(terminal **)(**(int **)((int)data + 4) + 0x14));
  update_bookmark(bm_00,codepage,*(uchar **)((int)data + 0x30),*(uchar **)((int)data + 0x60));
  poVar1 = &bm_00->object;
  poVar1->refcount = poVar1->refcount + -1;
  write_bookmarks();
  return;
}



// WARNING: Unknown calling convention

void bookmark_terminal_tabs_ok(void *term_void,uchar *foldername)

{
  int from;
  int to;
  int to_cp;
  conv_table *convert_table_00;
  conv_table *convert_table;
  size_t charslen;
  uchar *foldername_00;
  uchar *converted;
  int from_cp;
  
  from = get_terminal_codepage((terminal *)term_void);
  to = get_cp_index("UTF-8");
  convert_table_00 = get_translation_table(from,to);
  if (convert_table_00 != (conv_table *)0x0) {
    charslen = strlen((char *)foldername);
    foldername_00 =
         convert_string_elinks
                   (convert_table_00,foldername,charslen,to,CSM_NONE,(int *)0x0,
                    (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    if (foldername_00 != (uchar *)0x0) {
      bookmark_terminal_tabs((terminal *)term_void,foldername_00);
      mem_free(foldername_00);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void launch_bm_add_link_dialog(terminal *term,dialog_data *parent,session *ses)

{
  int iVar1;
  uchar *url_00;
  uchar *title_00;
  int in_GS_OFFSET;
  uchar url [1024];
  uchar title [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  url_00 = get_current_link_url(ses,url,0x400);
  title_00 = get_current_link_name(ses,title,0x400);
  launch_bm_add_dialog(term,parent,ses,title_00,url_00);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void bookmark_manager(session *ses)

{
  free_last_searched_bookmark();
  bookmark_browser.expansion_callback = bookmarks_set_dirty;
  hierbox_browser(&bookmark_browser,ses);
  return;
}



// WARNING: Unknown calling convention

void bookmark_terminal_tabs_dialog(terminal *term)

{
  string *psVar1;
  int cp_index;
  int new_charset;
  uchar *puVar2;
  option_value *poVar3;
  string string;
  
  psVar1 = init_string(&string);
  if (psVar1 != (string *)0x0) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      puVar2 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = cp_index;
    }
    puVar2 = gettext((uchar *)"Saved session");
    add_to_string(&string,puVar2);
    add_to_string(&string," - ");
    poVar3 = get_opt_();
    add_date_to_string(&string,poVar3->string,(time_t *)0x0);
    input_dialog(term,(memory_list *)0x0,(uchar *)"Bookmark tabs",(uchar *)"Enter folder name",term,
                 (input_history *)0x0,0x400,string.source,0,0,(widget_handler_T *)0x0,
                 bookmark_terminal_tabs_ok,(done_handler_T *)0x0);
    done_string(&string);
  }
  return;
}



// WARNING: Unknown calling convention

void bookmarks_write(list_head_elinks *bookmarks_list)

{
  bookmarks_backend *pbVar1;
  option_value *poVar2;
  int iVar3;
  uchar *puVar4;
  uchar *file_name;
  secure_save_info *ssi_00;
  secure_save_info *ssi;
  int iVar5;
  bookmarks_backend *backend;
  int backend_num;
  
  poVar2 = get_opt_();
  iVar5 = poVar2->number;
  pbVar1 = bookmarks_backends[iVar5];
  iVar3 = bookmarks_are_dirty();
  if (((((iVar3 != 0) || (iVar5 != loaded_backend_num)) && (pbVar1 != (bookmarks_backend *)0x0)) &&
      ((pbVar1->write != (_func_void_secure_save_info_ptr_list_head_elinks_ptr *)0x0 &&
       (elinks_home != (uchar *)0x0)))) &&
     ((pbVar1->filename != (_func_uchar_ptr_int *)0x0 &&
      ((puVar4 = (*pbVar1->filename)(1), puVar4 != (uchar *)0x0 &&
       (puVar4 = straconcat(elinks_home,puVar4,0), puVar4 != (uchar *)0x0)))))) {
    ssi_00 = secure_open(puVar4);
    mem_free(puVar4);
    if (ssi_00 != (secure_save_info *)0x0) {
      (*pbVar1->write)(ssi_00,bookmarks_list);
      iVar5 = secure_close(ssi_00);
      if (iVar5 == 0) {
        bookmarks_unset_dirty();
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void bookmarks_read(void)

{
  int iVar1;
  bookmarks_backend *pbVar2;
  option_value *poVar3;
  uchar *__filename;
  uchar *file_name;
  FILE *__stream;
  FILE *f;
  bookmarks_backend *backend;
  int backend_num;
  
  poVar3 = get_opt_();
  iVar1 = poVar3->number;
  pbVar2 = bookmarks_backends[iVar1];
  if ((((pbVar2 != (bookmarks_backend *)0x0) && (pbVar2->read != (_func_void_FILE_ptr *)0x0)) &&
      (pbVar2->filename != (_func_uchar_ptr_int *)0x0)) &&
     (__filename = (*pbVar2->filename)(0), __filename != (uchar *)0x0)) {
    if ((elinks_home != (uchar *)0x0) &&
       (__filename = straconcat(elinks_home,__filename,0), __filename == (uchar *)0x0)) {
      return;
    }
    __stream = fopen64((char *)__filename,"rb");
    if (elinks_home != (uchar *)0x0) {
      mem_free(__filename);
    }
    if (__stream != (FILE *)0x0) {
      (*pbVar2->read)((FILE *)__stream);
      fclose(__stream);
      bookmarks_unset_dirty();
      loaded_backend_num = iVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

uchar * filename_bookmarks_default(int writing)

{
  return "bookmarks";
}



// WARNING: Unknown calling convention

void write_bookmarks_default_inner(write_bookmarks_default *out,list_head_elinks *bookmarks_list)

{
  list_head_elinks *plVar1;
  size_t sVar2;
  uchar *p;
  uchar *p_00;
  uchar *title;
  uchar *puVar3;
  uchar *puVar4;
  bookmark *bm;
  uchar *url;
  
  plVar1 = (list_head_elinks *)bookmarks_list->next;
  do {
    if (plVar1 == bookmarks_list) {
      return;
    }
    puVar4 = (uchar *)plVar1[2].prev;
    sVar2 = strlen((char *)puVar4);
    p = convert_string_elinks
                  (out->conv_table,puVar4,sVar2,out->codepage,CSM_NONE,(int *)0x0,
                   (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    puVar4 = (uchar *)plVar1[3].next;
    sVar2 = strlen((char *)puVar4);
    p_00 = convert_string_elinks
                     (out->conv_table,puVar4,sVar2,out->codepage,CSM_NONE,(int *)0x0,
                      (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    puVar4 = "";
    if (p_00 != (uchar *)0x0) {
      puVar4 = p_00;
    }
    puVar3 = "";
    if (p != (uchar *)0x0) {
      puVar3 = p;
    }
    secure_fprintf(out->ssi,"%s\t%s\t%d\t",puVar3,puVar4,*(undefined4 *)((int)plVar1[2].next + 0x14)
                  );
    if (((*(int *)((int)plVar1[2].next + 0x10) == 1) &&
        (secure_fputc(out->ssi,0x46), out->save_folder_state != 0)) &&
       ((*(byte *)((int)plVar1[2].next + 0x18) & 1) != 0)) {
      secure_fputc(out->ssi,0x45);
    }
    secure_fputc(out->ssi,10);
    if ((p_00 == (uchar *)0x0) || (p == (uchar *)0x0)) {
      secsave_errno = SS_ERR_OTHER;
      out->ssi->err = 0xc;
      if (p != (uchar *)0x0) goto LAB_080695e7;
    }
    else {
LAB_080695e7:
      mem_free(p);
    }
    if (p_00 != (uchar *)0x0) {
      mem_free(p_00);
    }
    if (out->ssi->err != 0) {
      return;
    }
    if ((void **)plVar1[3].prev != &plVar1[3].prev) {
      write_bookmarks_default_inner(out,(list_head_elinks *)&plVar1[3].prev);
    }
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

void write_bookmarks_default(secure_save_info *ssi,list_head_elinks *bookmarks_list)

{
  option_value *poVar1;
  int to;
  int from;
  write_bookmarks_default out;
  
  out.ssi = ssi;
  poVar1 = get_opt_();
  out.save_folder_state = poVar1->number;
  to = get_cp_index((uchar *)"System");
  out.codepage = to;
  from = get_cp_index("UTF-8");
  out.conv_table = get_translation_table(from,to);
  write_bookmarks_default_inner(&out,bookmarks_list);
  return;
}



// WARNING: Unknown calling convention

void read_bookmarks_default(FILE *f)

{
  uchar *url;
  undefined *puVar1;
  uchar uVar2;
  int iVar3;
  int codepage;
  char *pcVar4;
  uchar *puVar5;
  long lVar6;
  bookmark *root;
  bookmark *root_00;
  int last_depth;
  bookmark *last_bm;
  int iVar7;
  int depth;
  long lVar8;
  uchar *flags;
  uchar *puVar9;
  int in_GS_OFFSET;
  int local_c40;
  bookmark *local_c3c;
  uchar *local_c34;
  uchar in_buffer [3079];
  
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  codepage = get_cp_index((uchar *)"System");
  local_c40 = 0;
  local_c3c = (bookmark *)0x0;
LAB_08069810:
  do {
    pcVar4 = fgets((char *)in_buffer,0xc07,(FILE *)f);
    if (pcVar4 == (char *)0x0) {
      if (iVar3 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return;
    }
    puVar5 = (uchar *)strchr((char *)in_buffer,9);
  } while (((puVar5 == (uchar *)0x0) || (in_buffer == puVar5)) ||
          (0x3ff < (int)puVar5 - (int)in_buffer));
  url = puVar5 + 1;
  *puVar5 = '\0';
  pcVar4 = strchr((char *)url,9);
  if (pcVar4 != (char *)0x0) goto code_r0x0806987f;
  lVar8 = 0;
  local_c34 = url;
  goto LAB_08069a32;
code_r0x0806987f:
  if ((int)pcVar4 - (int)url < 0x400) {
    *pcVar4 = '\0';
    local_c34 = (uchar *)(pcVar4 + 1);
    lVar6 = strtol((char *)local_c34,(char **)0x0,10);
    iVar7 = 0;
    if (local_c3c != (bookmark *)0x0) {
      iVar7 = local_c40 + 1;
    }
    lVar8 = 0;
    if ((-1 < lVar6) && (lVar8 = lVar6, iVar7 <= lVar6)) {
      lVar8 = iVar7;
    }
    pcVar4 = strchr((char *)local_c34,9);
    if (pcVar4 == (char *)0x0) {
LAB_08069a32:
      puVar9 = (uchar *)0x0;
    }
    else {
      *pcVar4 = '\0';
      puVar9 = (uchar *)(pcVar4 + 1);
      if (puVar9 != (uchar *)0x0) {
        local_c34 = puVar9;
      }
    }
    pcVar4 = strchr((char *)local_c34,10);
    if (pcVar4 != (char *)0x0) {
      *pcVar4 = '\0';
      root_00 = (bookmark *)0x0;
      if (lVar8 != 0) {
        if (local_c40 == lVar8) {
          root_00 = local_c3c->root;
        }
        else {
          root_00 = local_c3c;
          if (lVar8 <= local_c40) {
            do {
              local_c40 = local_c40 + -1;
              local_c3c = local_c3c->root;
            } while (local_c40 != lVar8);
            root_00 = local_c3c->root;
          }
        }
      }
      local_c3c = add_bookmark_cp(root_00,1,codepage,in_buffer,url);
      local_c40 = lVar8;
      if (((puVar5[1] == '\0') && (in_buffer[0] == '-')) && (in_buffer[1] == '\0')) {
        local_c3c->box_item->type = BI_SEPARATOR;
      }
      else if ((puVar9 != (uchar *)0x0) && (uVar2 = *puVar9, local_c3c != (bookmark *)0x0)) {
        while (uVar2 != '\0') {
          if (uVar2 == 'E') {
            puVar1 = &local_c3c->box_item->field_0x18;
            *puVar1 = *puVar1 | 1;
          }
          else if (uVar2 == 'F') {
            local_c3c->box_item->type = BI_FOLDER;
          }
          if (puVar9 == (uchar *)0xffffffff) break;
          puVar9 = puVar9 + 1;
          uVar2 = *puVar9;
        }
      }
    }
  }
  goto LAB_08069810;
}



// WARNING: Unknown calling convention

uchar * filename_bookmarks_xbel(int writing)

{
  if ((writing != 0) && (readok == 0)) {
    return (uchar *)0x0;
  }
  return (uchar *)"bookmarks.xbel";
}



// WARNING: Unknown calling convention

void on_element_close(void *data,char *name)

{
  current_node = current_node->parent;
  return;
}



// WARNING: Unknown calling convention

void print_xml_entities(secure_save_info *ssi,uchar *str)

{
  string *psVar1;
  size_t len;
  string entitized;
  
  entitized.source = (uchar *)0x0;
  entitized.length = 0;
  psVar1 = init_string(&entitized);
  if (psVar1 != (string *)0x0) {
    len = strlen((char *)str);
    psVar1 = add_html_to_string(&entitized,str,len);
    if (psVar1 != (string *)0x0) {
      secure_fputs(ssi,(char *)entitized.source);
      goto LAB_08069b71;
    }
  }
  secsave_errno = SS_ERR_OUT_OF_MEM;
  ssi->err = 0xc;
LAB_08069b71:
  done_string(&entitized);
  return;
}



// WARNING: Unknown calling convention

void write_bookmarks_list
               (secure_save_info *ssi,list_head_elinks *bookmarks_list,int n,int folder_state)

{
  int iVar1;
  char *s;
  int n_00;
  int i;
  int i_1;
  int i_2;
  int i_3;
  int i_4;
  int iVar2;
  bookmark *bm;
  list_head_elinks *plVar3;
  
  plVar3 = (list_head_elinks *)bookmarks_list->next;
  if (plVar3 != bookmarks_list) {
    iVar1 = n + 1;
    n_00 = n + 2;
    do {
      if (0 < iVar1) {
        iVar2 = 0;
        do {
          iVar2 = iVar2 + 1;
          secure_fputs(ssi,"    ");
        } while (iVar2 < iVar1);
      }
      iVar2 = *(int *)((int)plVar3[2].next + 0x10);
      if (iVar2 == 1) {
        if ((folder_state == 0) || ((*(byte *)((int)plVar3[2].next + 0x18) & 1) == 0)) {
          secure_fputs(ssi,"<folder folded=\"");
          s = "yes";
        }
        else {
          secure_fputs(ssi,"<folder folded=\"");
          s = "no";
        }
        secure_fputs(ssi,s);
        secure_fputs(ssi,"\">\n");
        if (0 < n_00) {
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            secure_fputs(ssi,"    ");
          } while (iVar2 < n_00);
        }
        secure_fputs(ssi,"<title>");
        print_xml_entities(ssi,(uchar *)plVar3[2].prev);
        secure_fputs(ssi,"</title>\n");
        if ((void **)plVar3[3].prev != &plVar3[3].prev) {
          write_bookmarks_list(ssi,(list_head_elinks *)&plVar3[3].prev,n_00,folder_state);
        }
        if (0 < iVar1) {
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            secure_fputs(ssi,"    ");
          } while (iVar2 < iVar1);
        }
        secure_fputs(ssi,"</folder>\n\n");
      }
      else if (iVar2 == 0) {
        secure_fputs(ssi,"<bookmark href=\"");
        print_xml_entities(ssi,(uchar *)plVar3[3].next);
        secure_fputs(ssi,"\">\n");
        if (0 < n_00) {
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            secure_fputs(ssi,"    ");
          } while (iVar2 < n_00);
        }
        secure_fputs(ssi,"<title>");
        print_xml_entities(ssi,(uchar *)plVar3[2].prev);
        secure_fputs(ssi,"</title>\n");
        if (0 < iVar1) {
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            secure_fputs(ssi,"    ");
          } while (iVar2 < iVar1);
        }
        secure_fputs(ssi,"</bookmark>\n\n");
      }
      else if (iVar2 == 2) {
        secure_fputs(ssi,"<separator/>\n\n");
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != bookmarks_list);
  }
  return;
}



// WARNING: Unknown calling convention

void write_bookmarks_xbel(secure_save_info *ssi,list_head_elinks *bookmarks_list)

{
  int folder_state_00;
  option_value *poVar1;
  int folder_state;
  
  poVar1 = get_opt_();
  folder_state_00 = poVar1->number;
  secure_fputs(ssi,
               "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\"\n\t\t       \"http://www.python.org/topics/xml/dtds/xbel-1.0.dtd\">\n\n<xbel>\n\n\n"
              );
  write_bookmarks_list(ssi,bookmarks_list,0,folder_state_00);
  secure_fputs(ssi,"\n</xbel>\n");
  return;
}



// WARNING: Unknown calling convention

void free_node(tree_node *node)

{
  int **ppiVar1;
  int **ppiVar2;
  list_head_elinks *plVar3;
  xlist_head *next;
  void *p;
  void *p_1;
  xlist_head *head;
  attributes *attribute;
  int **ppiVar4;
  int **p_00;
  
  ppiVar4 = (int **)(node->attrs).next;
  plVar3 = &node->attrs;
  p_00 = ppiVar4;
  if ((list_head_elinks *)ppiVar4 != plVar3) {
    do {
      mem_free((void *)((int *)ppiVar4)[2]);
      mem_free((void *)((int *)ppiVar4)[3]);
      ppiVar4 = (int **)*ppiVar4;
    } while ((list_head_elinks *)ppiVar4 != plVar3);
    ppiVar4 = (int **)(node->attrs).next;
    p_00 = ppiVar4;
  }
  for (; (list_head_elinks *)ppiVar4 != plVar3; ppiVar4 = (int **)*ppiVar4) {
  }
  for (ppiVar1 = (int **)(node->attrs).prev; ppiVar4 != ppiVar1; ppiVar1 = (int **)ppiVar1[1]) {
  }
  ppiVar1 = (int **)*p_00;
  while (ppiVar2 = ppiVar1, p_00 != ppiVar4) {
    ppiVar2[1] = p_00[1];
    *p_00[1] = (int)*p_00;
    mem_free(p_00);
    ppiVar1 = (int **)*ppiVar2;
    p_00 = ppiVar2;
  }
  if (node->name != (uchar *)0x0) {
    mem_free(node->name);
  }
  if (node->text != (uchar *)0x0) {
    mem_free(node->text);
  }
  mem_free(node);
  return;
}



// WARNING: Unknown calling convention

void free_xbeltree(tree_node *node)

{
  tree_node *ptVar1;
  tree_node *next_node;
  
  if (node != (tree_node *)0x0) {
    do {
      if (node->children != (tree_node *)0x0) {
        free_xbeltree(node->children);
      }
      ptVar1 = node->next;
      free_node(node);
      node = ptVar1;
    } while (ptVar1 != (tree_node *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void on_text(void *data,XML_Char *text,int len)

{
  byte bVar1;
  uchar *puVar2;
  bool bVar3;
  tree_node *ptVar4;
  char *__s;
  char *tmp;
  uchar *puVar5;
  size_t sVar6;
  int i;
  int iVar7;
  int c;
  size_t sVar8;
  int len2;
  int last_was_space;
  
  if (len != 0) {
    sVar8 = 0;
    puVar5 = current_node->text;
    if (puVar5 != (uchar *)0x0) {
      sVar8 = strlen((char *)puVar5);
    }
    __s = (char *)mem_realloc(puVar5,sVar8 + 1 + len);
    if (__s != (char *)0x0) {
      strncpy(__s + sVar8,text,len);
      __s[sVar8 + len] = '\0';
      ptVar4 = current_node;
      sVar8 = strlen(__s);
      puVar5 = (uchar *)mem_alloc(sVar8 + 1);
      if (puVar5 != (uchar *)0x0) {
        iVar7 = 0;
        if (0 < (int)sVar8) {
          bVar3 = false;
          sVar6 = 0;
          do {
            while( true ) {
              puVar2 = (uchar *)(__s + sVar6);
              bVar1 = *puVar2 - 9;
              if ((bVar1 < 0x18) && ((1 << (bVar1 & 0x1f) & 0x800013U) != 0)) break;
              bVar3 = false;
              sVar6 = sVar6 + 1;
              puVar5[iVar7] = *puVar2;
              iVar7 = iVar7 + 1;
              if (sVar8 == sVar6) goto LAB_0806a084;
            }
            if (!bVar3) {
              puVar5[iVar7] = ' ';
              iVar7 = iVar7 + 1;
            }
            sVar6 = sVar6 + 1;
            bVar3 = true;
          } while (sVar8 != sVar6);
        }
LAB_0806a084:
        puVar5[iVar7] = '\0';
      }
      ptVar4->text = puVar5;
      mem_free(__s);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void on_element_open(void *data,char *name,char **attr)

{
  tree_node *ptVar1;
  uchar *puVar2;
  int *p;
  uchar *p_00;
  uchar *value;
  tree_node *node;
  tree_node *ptVar3;
  uchar *name_1;
  
  ptVar3 = current_node;
  ptVar1 = (tree_node *)mem_calloc(1,0x20);
  if (ptVar1 != (tree_node *)0x0) {
    if (ptVar3 == (tree_node *)0x0) {
      ptVar3 = ptVar1;
    }
    ptVar1->parent = ptVar3;
    (ptVar1->attrs).prev = &ptVar1->attrs;
    (ptVar1->attrs).next = &ptVar1->attrs;
    ptVar3 = ptVar1;
    if (root_node != (tree_node *)0x0) {
      ptVar3 = current_node->children;
      if (ptVar3 == (tree_node *)0x0) {
        current_node->children = ptVar1;
        ptVar3 = root_node;
      }
      else {
        current_node->children = ptVar1;
        ptVar1->next = ptVar3;
        current_node->children->prev = (tree_node *)0x0;
        ptVar3 = root_node;
      }
    }
    root_node = ptVar3;
    current_node = ptVar1;
    puVar2 = stracpy((uchar *)name);
    ptVar1->name = puVar2;
    if (current_node->name == (uchar *)0x0) {
      mem_free(current_node);
      return;
    }
    for (; (uchar *)*attr != (uchar *)0x0; attr = (char **)((uchar **)attr + 2)) {
      p = (int *)mem_calloc(1,0x10);
      puVar2 = stracpy((uchar *)*attr);
      p_00 = stracpy(((uchar **)attr)[1]);
      if (p == (int *)0x0) {
LAB_0806a1ca:
        if (puVar2 != (uchar *)0x0) {
          mem_free(puVar2);
        }
        if (p_00 != (uchar *)0x0) {
          mem_free(p_00);
        }
        free_node(current_node);
        return;
      }
      if ((puVar2 == (uchar *)0x0) || (p_00 == (uchar *)0x0)) {
        if (p != (int *)0x0) {
          mem_free(p);
        }
        goto LAB_0806a1ca;
      }
      p[2] = (int)puVar2;
      p[3] = (int)p_00;
      ptVar3 = current_node;
                    // WARNING: Load size is inaccurate
      *p = *(current_node->attrs).prev;
      p[1] = (int)(ptVar3->attrs).prev;
      *(int **)(ptVar3->attrs).prev = p;
      *(int **)(*p + 4) = p;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int xbeltree_to_bookmarks_list
              (read_bookmarks_xbel *preload,tree_node *node,bookmark *current_parent)

{
  undefined *puVar1;
  tree_node *ptVar2;
  undefined4 *puVar3;
  bookmark *tmp;
  attributes *attribute;
  uchar *puVar4;
  bookmark *pbVar5;
  attributes *attribute_1;
  uchar *folded;
  uchar *puVar6;
  int iVar7;
  bookmark *parent_for_nested;
  tree_node *title;
  char *pcVar8;
  byte *pbVar9;
  uchar *href;
  char *pcVar10;
  uchar *puVar11;
  byte *pbVar12;
  bool bVar13;
  bool bVar14;
  byte bVar15;
  
  bVar15 = 0;
  bVar14 = node == (tree_node *)0x0;
  do {
    if (bVar14) {
      return 1;
    }
    iVar7 = 9;
    puVar6 = node->name;
    puVar4 = puVar6;
    puVar11 = "bookmark";
    do {
      if (iVar7 == 0) break;
      iVar7 = iVar7 + -1;
      bVar14 = *puVar4 == *puVar11;
      puVar4 = puVar4 + (uint)bVar15 * -2 + 1;
      puVar11 = puVar11 + (uint)bVar15 * -2 + 1;
    } while (bVar14);
    if (bVar14) {
      for (ptVar2 = node->children; bVar14 = ptVar2 == (tree_node *)0x0, !bVar14;
          ptVar2 = ptVar2->next) {
        iVar7 = 6;
        puVar6 = "title";
        puVar4 = ptVar2->name;
        do {
          if (iVar7 == 0) break;
          iVar7 = iVar7 + -1;
          bVar14 = *puVar6 == *puVar4;
          puVar6 = puVar6 + (uint)bVar15 * -2 + 1;
          puVar4 = puVar4 + (uint)bVar15 * -2 + 1;
        } while (bVar14);
        if (bVar14) break;
      }
      for (puVar3 = (undefined4 *)(node->attrs).next;
          bVar14 = (list_head_elinks *)puVar3 == &node->attrs, !bVar14;
          puVar3 = (undefined4 *)*puVar3) {
        iVar7 = 5;
        pcVar8 = (char *)puVar3[2];
        pcVar10 = "href";
        do {
          if (iVar7 == 0) break;
          iVar7 = iVar7 + -1;
          bVar14 = *pcVar8 == *pcVar10;
          pcVar8 = pcVar8 + (uint)bVar15 * -2 + 1;
          pcVar10 = pcVar10 + (uint)bVar15 * -2 + 1;
        } while (bVar14);
        if (bVar14) {
          puVar6 = (uchar *)puVar3[3];
          goto LAB_0806a2d7;
        }
      }
      puVar6 = (uchar *)0x0;
LAB_0806a2d7:
      iVar7 = preload->utf8_cp;
      if (iVar7 != current_charset) {
        puVar4 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar7;
      }
      if (puVar6 == (uchar *)0x0) {
        puVar6 = gettext((uchar *)"No URL");
      }
      if ((ptVar2 == (tree_node *)0x0) || (puVar4 = ptVar2->text, puVar4 == (uchar *)0x0)) {
        puVar4 = gettext((uchar *)"No title");
      }
      pbVar5 = add_bookmark(current_parent,0,puVar4,puVar6);
      if (pbVar5 == (bookmark *)0x0) {
        return 0;
      }
      pbVar5->root = current_parent;
      xbeltree_to_bookmarks_list::lastbm = pbVar5;
    }
    else {
      iVar7 = 7;
      puVar4 = puVar6;
      puVar11 = "folder";
      do {
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        bVar14 = *puVar4 == *puVar11;
        puVar4 = puVar4 + (uint)bVar15 * -2 + 1;
        puVar11 = puVar11 + (uint)bVar15 * -2 + 1;
      } while (bVar14);
      if (bVar14) {
        for (ptVar2 = node->children; bVar14 = ptVar2 == (tree_node *)0x0, !bVar14;
            ptVar2 = ptVar2->next) {
          iVar7 = 6;
          puVar6 = "title";
          puVar4 = ptVar2->name;
          do {
            if (iVar7 == 0) break;
            iVar7 = iVar7 + -1;
            bVar14 = *puVar6 == *puVar4;
            puVar6 = puVar6 + (uint)bVar15 * -2 + 1;
            puVar4 = puVar4 + (uint)bVar15 * -2 + 1;
          } while (bVar14);
          if (bVar14) break;
        }
        iVar7 = preload->utf8_cp;
        if (iVar7 != current_charset) {
          puVar6 = get_cp_mime_name(iVar7);
          bind_textdomain_codeset("elinks",puVar6);
          current_charset = iVar7;
        }
        if ((ptVar2 == (tree_node *)0x0) || (puVar6 = ptVar2->text, puVar6 == (uchar *)0x0)) {
          puVar6 = gettext((uchar *)"No title");
        }
        pbVar5 = add_bookmark(current_parent,0,puVar6,(uchar *)0x0);
        if (pbVar5 == (bookmark *)0x0) {
          return 0;
        }
        for (puVar3 = (undefined4 *)(node->attrs).next;
            bVar14 = (list_head_elinks *)puVar3 == &node->attrs,
            xbeltree_to_bookmarks_list::lastbm = pbVar5, !bVar14; puVar3 = (undefined4 *)*puVar3) {
          bVar13 = puVar3 < &node->attrs;
          iVar7 = 7;
          pbVar9 = (byte *)puVar3[2];
          pbVar12 = (byte *)"folded";
          do {
            if (iVar7 == 0) break;
            iVar7 = iVar7 + -1;
            bVar13 = *pbVar9 < *pbVar12;
            bVar14 = *pbVar9 == *pbVar12;
            pbVar9 = pbVar9 + (uint)bVar15 * -2 + 1;
            pbVar12 = pbVar12 + (uint)bVar15 * -2 + 1;
          } while (bVar14);
          if ((!bVar13 && !bVar14) == bVar13) {
            pcVar8 = (char *)puVar3[3];
            if ((((pcVar8 != (char *)0x0) && (*pcVar8 == 'n')) && (pcVar8[1] == 'o')) &&
               (pcVar8[2] == '\0')) {
              puVar1 = &pbVar5->box_item->field_0x18;
              *puVar1 = *puVar1 | 1;
            }
            break;
          }
        }
      }
      else {
        iVar7 = 10;
        puVar4 = "separator";
        do {
          if (iVar7 == 0) break;
          iVar7 = iVar7 + -1;
          bVar14 = *puVar6 == *puVar4;
          puVar6 = puVar6 + (uint)bVar15 * -2 + 1;
          puVar4 = puVar4 + (uint)bVar15 * -2 + 1;
        } while (bVar14);
        if (bVar14) {
          pbVar5 = add_bookmark(current_parent,0,"-","");
          if (pbVar5 == (bookmark *)0x0) {
            return 0;
          }
          pbVar5->root = current_parent;
          xbeltree_to_bookmarks_list::lastbm = pbVar5;
        }
      }
    }
    bVar14 = node->children == (tree_node *)0x0;
    if (!bVar14) {
      iVar7 = 7;
      puVar6 = node->name;
      puVar4 = "folder";
      do {
        if (iVar7 == 0) break;
        iVar7 = iVar7 + -1;
        bVar14 = *puVar6 == *puVar4;
        puVar6 = puVar6 + (uint)bVar15 * -2 + 1;
        puVar4 = puVar4 + (uint)bVar15 * -2 + 1;
      } while (bVar14);
      pbVar5 = current_parent;
      if (bVar14) {
        pbVar5 = xbeltree_to_bookmarks_list::lastbm;
      }
      iVar7 = xbeltree_to_bookmarks_list(preload,node->children,pbVar5);
      if (iVar7 == 0) {
        return 0;
      }
    }
    node = node->next;
    bVar14 = node == (tree_node *)0x0;
  } while( true );
}



// WARNING: Unknown calling convention

void read_bookmarks_xbel(FILE *f)

{
  int iVar1;
  int iVar2;
  size_t sVar3;
  int iVar4;
  uchar *puVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  int done;
  size_t len;
  int in_GS_OFFSET;
  read_bookmarks_xbel preload;
  uchar in_buffer [8192];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  readok = 0;
  iVar2 = XML_ParserCreate(0);
  if (iVar2 == 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/backend/xbel.c";
    errline = 0x69;
    puVar5 = gettext((uchar *)"read_bookmarks_xbel(): Error in XML_ParserCreate()");
    elinks_error(puVar5);
  }
  else {
    XML_SetElementHandler(iVar2,on_element_open,on_element_close);
    XML_SetCharacterDataHandler(iVar2,on_text);
    do {
      sVar3 = fread(in_buffer,1,0x2000,(FILE *)f);
      iVar4 = ferror((FILE *)f);
      if (iVar4 != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/backend/xbel.c";
        errline = 0x74;
        puVar5 = gettext((uchar *)"read_bookmarks_xbel(): Error reading %s");
        elinks_error(puVar5,"bookmarks.xbel");
        goto LAB_0806a642;
      }
      iVar4 = feof((FILE *)f);
      iVar6 = XML_Parse(iVar2,in_buffer,sVar3,iVar4);
      if (iVar6 == 0) {
        uVar7 = XML_GetErrorCode(iVar2);
        uVar7 = XML_ErrorString(uVar7);
        uVar8 = XML_GetCurrentColumnNumber(iVar2);
        uVar9 = XML_GetCurrentLineNumber(iVar2);
        puVar5 = gettext((uchar *)
                         "Parse error while processing XBEL bookmarks in %s at line %d column %d:\n%s"
                        );
        usrerror(puVar5,"bookmarks.xbel",uVar9,uVar8,uVar7);
        goto LAB_0806a642;
      }
    } while (iVar4 == 0);
    preload.utf8_cp = get_cp_index("UTF-8");
    readok = xbeltree_to_bookmarks_list(&preload,root_node->children,(bookmark *)0x0);
LAB_0806a642:
    XML_ParserFree(iVar2);
    free_xbeltree(root_node);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

ulonglong get_cache_size(void)

{
  return CONCAT44(cache_size._4_4_,(undefined4)cache_size);
}



// WARNING: Unknown calling convention

int get_cache_entry_count(void)

{
  void **ppvVar1;
  int iVar2;
  int size;
  list_head_elinks *item;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &cache_entries);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_cache_entry_used_count(void)

{
  void **ppvVar1;
  int iVar2;
  int i;
  cache_entry *cached;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + (uint)(plVar3[1].next != (void *)0x0);
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &cache_entries);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int cache_entry_is_valid(cache_entry *cached)

{
  cache_entry *valid_cached;
  cache_entry *pcVar1;
  
  if ((list_head_elinks *)cache_entries.next == &cache_entries) {
    return 0;
  }
  pcVar1 = (cache_entry *)cache_entries.next;
  if ((cache_entry *)cache_entries.next != cached) {
    do {
      pcVar1 = pcVar1->next;
      if (pcVar1 == (cache_entry *)&cache_entries) {
        return 0;
      }
    } while (cached != pcVar1);
  }
  return 1;
}



// WARNING: Unknown calling convention

int get_cache_entry_loading_count(void)

{
  int iVar1;
  cache_entry *cached;
  cache_entry *cached_00;
  int iVar2;
  int i;
  
  iVar2 = 0;
  cached_00 = (cache_entry *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      iVar1 = is_entry_used(cached_00);
      cached_00 = cached_00->next;
      iVar2 = iVar2 + iVar1;
    } while (cached_00 != (cache_entry *)&cache_entries);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

uri * redirect_cache(cache_entry *cached,uchar *location,int get,int incomplete)

{
  byte bVar1;
  byte bVar2;
  uri *puVar3;
  char *pcVar4;
  uchar *puVar5;
  uchar *local_20 [4];
  
  if (((incomplete == 0) && (*location == '/')) && (location[1] == '\0')) {
    local_20[0] = get_uri_string(cached->uri,URI_ORIGINAL);
    if (local_20[0] == (uchar *)0x0) {
      return (uri *)0x0;
    }
    add_to_strn(local_20,location);
  }
  else {
    local_20[0] = join_urls(cached->uri,location);
  }
  if (local_20[0] == (uchar *)0x0) {
    return (uri *)0x0;
  }
  puVar5 = cached->uri->post;
  if (((puVar5 != (uchar *)0x0) && (get == 0)) && ((cached->field_0x5c & 4) == 0)) {
    if (assert_failed == 0) {
      pcVar4 = strchr((char *)local_20[0],1);
      assert_failed = (int)(pcVar4 != (char *)0x0);
      if (pcVar4 != (char *)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 0x2e2;
        elinks_internal((uchar *)"assertion !strchr(uristring, POST_CHAR) failed!");
      }
      puVar5 = cached->uri->post;
    }
    add_to_strn(local_20,puVar5 + -1);
  }
  if (cached->redirect != (uri *)0x0) {
    done_uri(cached->redirect);
  }
  puVar3 = get_uri(local_20[0],0);
  cached->redirect = puVar3;
  bVar1 = cached->field_0x5c;
  bVar2 = (byte)((get & 1U) << 2);
  cached->field_0x5c = bVar1 & 0xfb | bVar2;
  if (-1 < incomplete) {
    cached->field_0x5c = bVar1 & 0xf3 | bVar2 | (byte)((incomplete & 1U) << 3);
  }
  mem_free(local_20[0]);
  return cached->redirect;
}



// WARNING: Unknown calling convention

fragment * frag_alloc(size_t size)

{
  fragment *__s;
  fragment *f;
  
  __s = (fragment *)mem_mmap_alloc(size + 0x23);
  if (__s != (fragment *)0x0) {
    memset(__s,0,size + 0x23);
  }
  return __s;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

fragment * get_cache_fragment(cache_entry *cached)

{
  fragment *pfVar1;
  long gap;
  int iVar2;
  fragment *pfVar3;
  fragment *pfVar4;
  fragment *first_frag;
  fragment *pfVar5;
  size_t size;
  int new_frag_len;
  fragment *adj_frag;
  list_head_elinks *plVar6;
  fragment *frag;
  fragment *p;
  
  p = (fragment *)(cached->frag).next;
  plVar6 = &cached->frag;
  if ((p != (fragment *)plVar6) && ((*(uint *)((int)&p->offset + 4) | *(uint *)&p->offset) == 0)) {
    if (p == (fragment *)(cached->frag).prev) {
      return p;
    }
    pfVar4 = p->next;
    if ((fragment *)plVar6 == pfVar4) {
      return p;
    }
    iVar2 = (-*(int *)&pfVar4->prev->offset - *(int *)&pfVar4->prev->length) +
            *(int *)&pfVar4->offset;
    pfVar1 = pfVar4;
    if (0 < iVar2) {
      return p;
    }
    do {
      if (iVar2 != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 0x1fa;
        elinks_internal((uchar *)"fragments overlap");
        return (fragment *)0x0;
      }
      pfVar1 = pfVar1->next;
      if ((fragment *)plVar6 == pfVar1) goto LAB_0806aaf1;
      iVar2 = (-*(int *)&pfVar1->prev->offset - *(int *)&pfVar1->prev->length) +
              *(int *)&pfVar1->offset;
    } while (iVar2 < 1);
    if (pfVar1 == pfVar4) {
      return p;
    }
LAB_0806aaf1:
    size = 0;
    pfVar5 = p;
    if (pfVar1 != p) {
      while (pfVar3 = pfVar4, size = size + *(int *)&pfVar5->length, pfVar1 != pfVar3) {
        pfVar5 = pfVar3;
        pfVar4 = pfVar3->next;
      }
    }
    pfVar4 = frag_alloc(size);
    if (pfVar4 != (fragment *)0x0) {
      *(size_t *)&pfVar4->length = size;
      *(int *)((int)&pfVar4->length + 4) = (int)size >> 0x1f;
      *(size_t *)&pfVar4->real_length = size;
      *(int *)((int)&pfVar4->real_length + 4) = (int)size >> 0x1f;
      if (pfVar1 != p) {
        iVar2 = 0;
        do {
          memcpy(pfVar4->data + iVar2,p->data,*(size_t *)&p->length);
          pfVar5 = p->prev;
          iVar2 = iVar2 + *(int *)&p->length;
          p->next->prev = pfVar5;
          p->prev->next = p->next;
          mem_mmap_free(p,*(int *)&p->real_length + 0x23);
          p = pfVar5->next;
        } while (pfVar1 != p);
      }
      pfVar4->next = (fragment *)(cached->frag).next;
      pfVar4->prev = (fragment *)plVar6;
      (cached->frag).next = pfVar4;
      pfVar4->next->prev = pfVar4;
      return pfVar4;
    }
    if ((*(uint *)((int)&p->length + 4) | *(uint *)&p->length) != 0) {
      return p;
    }
  }
  return (fragment *)0x0;
}



// WARNING: Unknown calling convention

cache_entry * find_in_cache(uri *uri)

{
  int iVar1;
  uri *c_uri;
  int iVar2;
  cache_entry *cached;
  cache_entry *pcVar3;
  
  iVar1 = uri->protocol;
  pcVar3 = (cache_entry *)cache_entries.next;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    do {
      if ((pcVar3->field_0x5c & 0x10) != 0) {
        if (iVar1 == 0xf) {
          c_uri = pcVar3->proxy_uri;
        }
        else {
          c_uri = pcVar3->uri;
        }
        iVar2 = compare_uri(c_uri,uri,URI_BASE);
        if (iVar2 != 0) {
          if ((cache_entry *)cache_entries.next == pcVar3) {
            return pcVar3;
          }
          pcVar3->next->prev = pcVar3->prev;
          pcVar3->prev->next = pcVar3->next;
          pcVar3->prev = (cache_entry *)&cache_entries;
          pcVar3->next = (cache_entry *)cache_entries.next;
          cache_entries.next = pcVar3;
          pcVar3->next->prev = pcVar3;
          return pcVar3;
        }
      }
      pcVar3 = pcVar3->next;
    } while (pcVar3 != (cache_entry *)&cache_entries);
  }
  return (cache_entry *)0x0;
}



// WARNING: Unknown calling convention

cache_entry * follow_cached_redirects(cache_entry *cached)

{
  cache_entry *pcVar1;
  uri *uri;
  int iVar2;
  int redirects;
  
  if (cached != (cache_entry *)0x0) {
    uri = cached->redirect;
    iVar2 = 1;
    if (uri != (uri *)0x0) {
      do {
        pcVar1 = find_in_cache(uri);
        if (pcVar1 == (cache_entry *)0x0) {
          return (cache_entry *)0x0;
        }
        uri = pcVar1->redirect;
        if (uri == (uri *)0x0) {
          return pcVar1;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 != 0xb);
      cached = (cache_entry *)0x0;
    }
  }
  return cached;
}



// WARNING: Unknown calling convention

cache_entry * get_redirected_cache_entry(uri *uri)

{
  cache_entry *pcVar1;
  cache_entry *cached;
  
  pcVar1 = find_in_cache(uri);
  if (pcVar1 != (cache_entry *)0x0) {
    pcVar1 = follow_cached_redirects(pcVar1);
    return pcVar1;
  }
  return (cache_entry *)0x0;
}



// WARNING: Unknown calling convention

cache_entry * get_cache_entry(uri *uri)

{
  cache_entry *pcVar1;
  cache_entry *p;
  uri *puVar2;
  listbox_item *plVar3;
  cache_entry *cached;
  
  pcVar1 = find_in_cache(uri);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(uri->fragment != (uchar *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
    errline = 0x83;
    elinks_internal((uchar *)"assertion !uri->fragment failed: Fragment in URI (%s)",uri->string);
  }
  if (pcVar1 == (cache_entry *)0x0) {
    shrink_memory(0);
    p = (cache_entry *)mem_calloc(1,100);
    if (p != (cache_entry *)0x0) {
      puVar2 = get_proxied_uri(uri);
      p->uri = puVar2;
      if (puVar2 != (uri *)0x0) {
        puVar2 = get_proxy_uri(uri,(connection_state *)0x0);
        p->proxy_uri = puVar2;
        if (puVar2 != (uri *)0x0) {
          p->field_0x5c = p->field_0x5c | 0x18;
          (p->frag).prev = &p->frag;
          (p->frag).next = &p->frag;
          p->cache_id = id_counter;
          id_counter = id_counter + 1;
          plVar3 = add_listbox_item(&cache_browser,(listbox_item *)0x0,BI_LEAF,p,1);
          p->box_item = plVar3;
          p->prev = (cache_entry *)&cache_entries;
          p->next = (cache_entry *)cache_entries.next;
          cache_entries.next = p;
          p->next->prev = p;
          return p;
        }
        done_uri(p->uri);
      }
      mem_free(p);
    }
  }
  return pcVar1;
}



// WARNING: Removing unreachable block (ram,0x0806ae92)
// WARNING: Removing unreachable block (ram,0x0806af5a)
// WARNING: Unknown calling convention

void free_entry_to(cache_entry *cached,off_t offset)

{
  longlong *plVar1;
  int **p;
  int *piVar2;
  int *__n;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  fragment *f;
  int **ppiVar7;
  
  p = (int **)(cached->frag).next;
  do {
    if ((list_head_elinks *)p == &cached->frag) {
      return;
    }
    plVar1 = (longlong *)(p + 2);
    piVar2 = p[4];
    if (offset < CONCAT44((int)p[5] + (int)p[3] + (uint)CARRY4((uint)piVar2,*(uint *)plVar1),
                          (int)piVar2 + *(uint *)plVar1)) {
      if (offset <= *plVar1) {
        return;
      }
      piVar2 = (int *)(offset - *plVar1);
      iVar5 = (int)((ulonglong)(offset - *plVar1) >> 0x20);
      uVar6 = -(int)piVar2;
      iVar3 = -(iVar5 + (uint)(piVar2 != (int *)0x0));
      iVar4 = iVar3 + *(int *)((int)&cached->data_size + 4) +
              (uint)CARRY4(uVar6,*(uint *)&cached->data_size);
      *(uint *)&cached->data_size = uVar6 + *(int *)&cached->data_size;
      *(int *)((int)&cached->data_size + 4) = iVar4;
      if (assert_failed == 0) {
        assert_failed = -(iVar4 >> 0x1f);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 0x105;
          elinks_internal((uchar *)
                          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                          ,*(undefined4 *)&cached->data_size,
                          *(undefined4 *)((int)&cached->data_size + 4));
          if (assert_failed != 0) goto LAB_0806b050;
        }
        cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar6);
LAB_0806afc6:
        cache_size._0_4_ = (uint)cache_size + uVar6;
      }
      else {
LAB_0806b050:
        assert_failed = 0;
        *(undefined4 *)&cached->data_size = 0;
        *(undefined4 *)((int)&cached->data_size + 4) = 0;
        cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar6);
        if (assert_failed == 0) goto LAB_0806afc6;
        cache_size._0_4_ = 0;
        cache_size._4_4_ = 0;
      }
      assert_failed = 0;
      __n = (int *)((int)p[4] - (int)piVar2);
      p[5] = (int *)((int)p[5] + (-(uint)(p[4] < piVar2) - iVar5));
      p[4] = __n;
      memmove(p + 8,(void *)((int)(p + 8) + (int)piVar2),(size_t)__n);
      *(off_t *)(p + 2) = offset;
      ppiVar7 = p;
    }
    else {
      uVar6 = -(int)piVar2;
      iVar3 = -((int)p[5] + (uint)(piVar2 != (int *)0x0));
      iVar4 = iVar3 + *(int *)((int)&cached->data_size + 4) +
              (uint)CARRY4(uVar6,*(uint *)&cached->data_size);
      *(uint *)&cached->data_size = uVar6 + *(int *)&cached->data_size;
      *(int *)((int)&cached->data_size + 4) = iVar4;
      if (assert_failed == 0) {
        assert_failed = -(iVar4 >> 0x1f);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 0x105;
          elinks_internal((uchar *)
                          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                          ,*(undefined4 *)&cached->data_size,
                          *(undefined4 *)((int)&cached->data_size + 4));
          if (assert_failed != 0) goto LAB_0806b100;
        }
        cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar6);
LAB_0806aeeb:
        cache_size._0_4_ = (uint)cache_size + uVar6;
      }
      else {
LAB_0806b100:
        assert_failed = 0;
        *(undefined4 *)&cached->data_size = 0;
        *(undefined4 *)((int)&cached->data_size + 4) = 0;
        cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar6);
        if (assert_failed == 0) goto LAB_0806aeeb;
        cache_size._0_4_ = 0;
        cache_size._4_4_ = 0;
      }
      assert_failed = 0;
      ppiVar7 = (int **)p[1];
      (*p)[1] = (int)ppiVar7;
      *p[1] = (int)*p;
      mem_mmap_free(p,(int)p[6] + 0x23);
    }
    p = (int **)*ppiVar7;
  } while( true );
}



// WARNING: Unknown calling convention

void remove_overlaps(cache_entry *cached,fragment *f,int *trunc)

{
  fragment *pfVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  fragment *nf;
  fragment *p;
  uchar *puVar8;
  uint uVar9;
  uchar *puVar10;
  int iVar11;
  bool bVar12;
  byte bVar13;
  fragment *local_50;
  uchar *local_44;
  int local_2c;
  
  bVar13 = 0;
  local_44 = *(uchar **)&f->offset;
  p = f->next;
  if (p != (fragment *)&cached->frag) {
    uVar3 = (int)local_44 + *(uint *)&f->length;
    iVar7 = *(int *)((int)&f->offset + 4) + *(int *)((int)&f->length + 4) +
            (uint)CARRY4((uint)local_44,*(uint *)&f->length);
    iVar6 = *(int *)((int)&p->offset + 4);
    uVar9 = *(uint *)&p->offset;
    if ((iVar6 <= iVar7) && ((local_50 = f, iVar6 < iVar7 || (uVar9 < uVar3)))) {
      do {
        uVar5 = *(uint *)&p->length;
        uVar2 = uVar5 + uVar9;
        iVar6 = *(int *)((int)&p->length + 4) + iVar6 + (uint)CARRY4(uVar5,uVar9);
        if ((iVar6 < iVar7) || ((iVar6 <= iVar7 && (uVar2 <= uVar3)))) {
          bVar12 = true;
          puVar8 = (uchar *)((int)local_50 + uVar9 + (0x20 - (int)local_44));
          puVar10 = p->data;
          do {
            if (uVar5 == 0) break;
            uVar5 = uVar5 - 1;
            bVar12 = *puVar8 == *puVar10;
            puVar8 = puVar8 + (uint)bVar13 * -2 + 1;
            puVar10 = puVar10 + (uint)bVar13 * -2 + 1;
          } while (bVar12);
          if (!bVar12) {
            *trunc = 1;
            goto LAB_0806b3f8;
          }
        }
        else {
          pfVar1 = (fragment *)
                   mem_mmap_realloc(local_50,*(int *)&local_50->real_length + 0x23,
                                    uVar2 + (0x23 - (int)local_44));
          if (pfVar1 == (fragment *)0x0) {
LAB_0806b3f8:
            p = local_50->next;
          }
          else {
            pfVar1->prev->next = pfVar1;
            pfVar1->next->prev = pfVar1;
            local_2c = *(int *)&pfVar1->length;
            iVar11 = *(int *)&pfVar1->next->offset;
            local_44 = pfVar1->next->data;
            iVar4 = (*(int *)&pfVar1->offset + local_2c) - iVar11;
            bVar12 = true;
            puVar8 = pfVar1->data + (iVar11 - *(int *)&pfVar1->offset);
            puVar10 = local_44;
            do {
              if (iVar4 == 0) break;
              iVar4 = iVar4 + -1;
              bVar12 = *puVar8 == *puVar10;
              puVar8 = puVar8 + (uint)bVar13 * -2 + 1;
              puVar10 = puVar10 + (uint)bVar13 * -2 + 1;
            } while (bVar12);
            if (!bVar12) {
              *trunc = 1;
              local_2c = *(int *)&pfVar1->length;
              iVar11 = *(int *)&pfVar1->next->offset;
              local_44 = pfVar1->next->data;
            }
            memcpy(pfVar1->data + local_2c,local_44 + (uVar3 - iVar11),uVar2 - uVar3);
            uVar9 = uVar2 - uVar3;
            iVar4 = (iVar6 - iVar7) - (uint)(uVar2 < uVar3);
            iVar11 = iVar4 + *(int *)((int)&cached->data_size + 4) +
                     (uint)CARRY4(uVar9,*(uint *)&cached->data_size);
            *(uint *)&cached->data_size = uVar9 + *(int *)&cached->data_size;
            *(int *)((int)&cached->data_size + 4) = iVar11;
            if (assert_failed == 0) {
              assert_failed = -(iVar11 >> 0x1f);
              if (assert_failed != 0) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
                errline = 0x105;
                elinks_internal((uchar *)
                                "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                                ,*(undefined4 *)&cached->data_size,
                                *(undefined4 *)((int)&cached->data_size + 4));
                if (assert_failed != 0) goto LAB_0806b4e0;
              }
              cache_size._4_4_ = cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,uVar9);
LAB_0806b2da:
              cache_size._0_4_ = (uint)cache_size + uVar9;
            }
            else {
LAB_0806b4e0:
              assert_failed = 0;
              *(undefined4 *)&cached->data_size = 0;
              *(undefined4 *)((int)&cached->data_size + 4) = 0;
              cache_size._4_4_ = cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,uVar9);
              if (assert_failed == 0) goto LAB_0806b2da;
              cache_size._0_4_ = 0;
              cache_size._4_4_ = 0;
            }
            assert_failed = 0;
            iVar11 = uVar2 - *(int *)&pfVar1->offset;
            iVar6 = (iVar6 - *(int *)((int)&pfVar1->offset + 4)) -
                    (uint)(uVar2 < *(uint *)&pfVar1->offset);
            *(int *)&pfVar1->real_length = iVar11;
            *(int *)((int)&pfVar1->real_length + 4) = iVar6;
            *(int *)&pfVar1->length = iVar11;
            *(int *)((int)&pfVar1->length + 4) = iVar6;
            p = pfVar1->next;
            local_50 = pfVar1;
          }
        }
        uVar9 = -*(int *)&p->length;
        iVar11 = -(*(int *)((int)&p->length + 4) + (uint)(*(int *)&p->length != 0));
        iVar6 = iVar11 + *(int *)((int)&cached->data_size + 4) +
                (uint)CARRY4(uVar9,*(uint *)&cached->data_size);
        *(uint *)&cached->data_size = uVar9 + *(int *)&cached->data_size;
        *(int *)((int)&cached->data_size + 4) = iVar6;
        if (assert_failed == 0) {
          assert_failed = -(iVar6 >> 0x1f);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 0x105;
            elinks_internal((uchar *)
                            "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                            ,*(undefined4 *)&cached->data_size,
                            *(undefined4 *)((int)&cached->data_size + 4));
            if (assert_failed != 0) goto LAB_0806b448;
          }
          cache_size._4_4_ = cache_size._4_4_ + iVar11 + (uint)CARRY4((uint)cache_size,uVar9);
LAB_0806b354:
          cache_size._0_4_ = (uint)cache_size + uVar9;
        }
        else {
LAB_0806b448:
          assert_failed = 0;
          *(undefined4 *)&cached->data_size = 0;
          *(undefined4 *)((int)&cached->data_size + 4) = 0;
          cache_size._4_4_ = cache_size._4_4_ + iVar11 + (uint)CARRY4((uint)cache_size,uVar9);
          if (assert_failed == 0) goto LAB_0806b354;
          cache_size._0_4_ = 0;
          cache_size._4_4_ = 0;
        }
        assert_failed = 0;
        p->next->prev = p->prev;
        p->prev->next = p->next;
        mem_mmap_free(p,*(int *)&p->real_length + 0x23);
        p = local_50->next;
        if (p == (fragment *)&cached->frag) {
          return;
        }
        iVar6 = *(int *)((int)&p->offset + 4);
        uVar9 = *(uint *)&p->offset;
        if (iVar7 < iVar6) {
          return;
        }
        if ((iVar7 <= iVar6) && (uVar3 <= uVar9)) {
          return;
        }
        local_44 = *(uchar **)&local_50->offset;
      } while( true );
    }
  }
  return;
}



// WARNING: Unknown calling convention

void delete_entry_content(cache_entry *cached)

{
  int iVar1;
  int *p;
  uchar *p_00;
  uint uVar2;
  int iVar3;
  
  iVar3 = *(int *)&cached->data_size;
  iVar1 = *(int *)((int)&cached->data_size + 4);
  *(undefined4 *)&cached->data_size = 0;
  *(undefined4 *)((int)&cached->data_size + 4) = 0;
  uVar2 = -iVar3;
  iVar3 = -(iVar1 + (uint)(iVar3 != 0));
  if (assert_failed == 0) {
    cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar2);
  }
  else {
    assert_failed = 0;
    *(undefined4 *)&cached->data_size = 0;
    *(undefined4 *)((int)&cached->data_size + 4) = 0;
    cache_size._4_4_ = cache_size._4_4_ + iVar3 + (uint)CARRY4((uint)cache_size,uVar2);
    if (assert_failed != 0) {
      cache_size._0_4_ = 0;
      cache_size._4_4_ = 0;
      goto LAB_0806b58a;
    }
  }
  cache_size._0_4_ = (uint)cache_size + uVar2;
LAB_0806b58a:
  assert_failed = 0;
  p = (int *)(cached->frag).next;
  while ((list_head_elinks *)p != &cached->frag) {
    *(int *)(*p + 4) = p[1];
    *(int *)p[1] = *p;
    mem_mmap_free(p,p[6] + 0x23);
    p = (int *)(cached->frag).next;
  }
  cached->cache_id = id_counter;
  id_counter = id_counter + 1;
  p_00 = cached->last_modified;
  cached->field_0x5c = cached->field_0x5c | 8;
  *(undefined4 *)&cached->length = 0;
  *(undefined4 *)((int)&cached->length + 4) = 0;
  if (p_00 != (uchar *)0x0) {
    mem_free(p_00);
  }
  cached->last_modified = (uchar *)0x0;
  if (cached->etag != (uchar *)0x0) {
    mem_free(cached->etag);
  }
  cached->etag = (uchar *)0x0;
  return;
}



// WARNING: Unknown calling convention

void delete_cache_entry(cache_entry *cached)

{
  int iVar1;
  void *p_5;
  void *p_4;
  void *p_3;
  void *p_2;
  void *p_1;
  void *p;
  
  cached->next->prev = cached->prev;
  cached->prev->next = cached->next;
  if (assert_failed == 0) {
    assert_failed = (int)((cached->object).refcount != 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x290;
      elinks_internal((uchar *)
                      "assertion !is_object_used(cached) failed: deleting locked cache entry");
      if (assert_failed != 0) goto LAB_0806b6c7;
    }
    iVar1 = is_entry_used(cached);
    assert_failed = (int)(iVar1 != 0);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x291;
      elinks_internal((uchar *)
                      "assertion !is_entry_used(cached) failed: deleting loading cache entry");
    }
  }
LAB_0806b6c7:
  delete_entry_content(cached);
  if (cached->box_item != (listbox_item *)0x0) {
    done_listbox_item(&cache_browser,cached->box_item);
  }
  if (cached->uri != (uri *)0x0) {
    done_uri(cached->uri);
  }
  if (cached->proxy_uri != (uri *)0x0) {
    done_uri(cached->proxy_uri);
  }
  if (cached->redirect != (uri *)0x0) {
    done_uri(cached->redirect);
  }
  if (cached->head != (uchar *)0x0) {
    mem_free(cached->head);
  }
  if (cached->content_type != (uchar *)0x0) {
    mem_free(cached->content_type);
  }
  if (cached->last_modified != (uchar *)0x0) {
    mem_free(cached->last_modified);
  }
  if (cached->ssl_info != (uchar *)0x0) {
    mem_free(cached->ssl_info);
  }
  if (cached->encoding_info != (uchar *)0x0) {
    mem_free(cached->encoding_info);
  }
  if (cached->etag != (uchar *)0x0) {
    mem_free(cached->etag);
  }
  mem_free(cached);
  return;
}



// WARNING: Removing unreachable block (ram,0x0806b98c)
// WARNING: Removing unreachable block (ram,0x0806b95d)
// WARNING: Removing unreachable block (ram,0x0806b9c8)
// WARNING: Unknown calling convention

void garbage_collection(int whole)

{
  uint *puVar1;
  byte bVar2;
  off_t *poVar3;
  cache_entry **ppcVar4;
  option_value *poVar5;
  uint uVar6;
  cache_entry *entry;
  cache_entry *pcVar7;
  int iVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  uint uVar12;
  cache_entry *cached;
  cache_entry *pcVar13;
  list_head_elinks *cached_00;
  bool bVar14;
  bool bVar15;
  ulonglong uVar16;
  uint local_54;
  uint local_50;
  
  poVar5 = get_opt_();
  uVar10 = poVar5->color;
  uVar11 = (int)uVar10 >> 0x1f;
  if (whole == 0) {
    if (cache_size._4_4_ < uVar11) {
      return;
    }
    if ((cache_size._4_4_ <= uVar11) && ((uint)cache_size <= uVar10)) {
      return;
    }
  }
  uVar12 = 0;
  uVar9 = 0;
  local_54 = (uint)cache_size;
  local_50 = cache_size._4_4_;
  if ((list_head_elinks *)cache_entries.next != &cache_entries) {
    uVar12 = 0;
    uVar9 = 0;
    pcVar13 = (cache_entry *)cache_entries.next;
    do {
      bVar14 = CARRY4(uVar12,*(uint *)&pcVar13->data_size);
      uVar12 = uVar12 + *(int *)&pcVar13->data_size;
      uVar9 = uVar9 + *(int *)((int)&pcVar13->data_size + 4) + (uint)bVar14;
      if (((pcVar13->object).refcount != 0) || (iVar8 = is_entry_used(pcVar13), iVar8 != 0)) {
        if (assert_failed == 0) {
          puVar1 = (uint *)((int)&pcVar13->data_size + 4);
          bVar14 = local_50 <= *puVar1;
          if ((bVar14 && *puVar1 != local_50) ||
             ((bVar14 &&
              (local_54 <= *(uint *)&pcVar13->data_size && *(uint *)&pcVar13->data_size != local_54)
              ))) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 0x321;
            elinks_internal((uchar *)
                            "assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld"
                            ,(uint)cache_size,cache_size._4_4_,*(undefined4 *)&pcVar13->data_size,
                            *(undefined4 *)((int)&pcVar13->data_size + 4),local_54,local_50);
            uVar6 = *(uint *)&pcVar13->data_size;
            iVar8 = *(int *)((int)&pcVar13->data_size + 4);
            if (assert_failed != 0) goto LAB_0806ba90;
          }
          else {
            assert_failed = 0;
            uVar6 = *(uint *)&pcVar13->data_size;
            iVar8 = *(int *)((int)&pcVar13->data_size + 4);
          }
          bVar14 = local_54 < uVar6;
          local_54 = local_54 - uVar6;
          local_50 = (local_50 - iVar8) - (uint)bVar14;
        }
        else {
LAB_0806ba90:
          assert_failed = 0;
          local_54 = 0;
          local_50 = 0;
        }
      }
      pcVar13 = pcVar13->next;
    } while (pcVar13 != (cache_entry *)&cache_entries);
  }
  if (assert_failed == 0) {
    bVar14 = (cache_size._4_4_ ^ uVar9 | uVar12 ^ (uint)cache_size) != 0;
    assert_failed = (int)bVar14;
    if (bVar14) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x32a;
      elinks_internal((uchar *)
                      "assertion old_cache_size == cache_size failed: cache_size out of sync: %ld != (actual) %ld"
                      ,(uint)cache_size,cache_size._4_4_,uVar12,uVar9);
      if (assert_failed != 0) goto LAB_0806b8de;
    }
  }
  else {
LAB_0806b8de:
    assert_failed = 0;
    cache_size._0_4_ = uVar12;
    cache_size._4_4_ = uVar9;
  }
  bVar14 = whole == 0;
  if ((local_50 <= uVar11) && (((local_50 < uVar11 || (local_54 <= uVar10)) && (bVar14)))) {
    return;
  }
  uVar16 = __udivdi3((int)((ulonglong)uVar10 * 0x5a),
                     uVar11 * 0x5a + (int)((ulonglong)uVar10 * 0x5a >> 0x20),100,0);
  if ((list_head_elinks *)cache_entries.prev != &cache_entries) {
    cached_00 = (list_head_elinks *)cache_entries.prev;
    if (CONCAT44(local_50,local_54) <= uVar16) goto LAB_0806b992;
    do {
      do {
        if ((((object *)((int)cached_00 + 8))->refcount == 0) &&
           (iVar8 = is_entry_used((cache_entry *)cached_00), iVar8 == 0)) {
          if (assert_failed == 0) {
            puVar1 = (uint *)((int)((int)cached_00 + 0x48) + 4);
            bVar15 = local_50 <= *puVar1;
            if ((bVar15 && *puVar1 != local_50) ||
               ((bVar15 &&
                (local_54 <= *(uint *)(off_t *)((int)cached_00 + 0x48) &&
                 *(uint *)(off_t *)((int)cached_00 + 0x48) != local_54)))) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
              errline = 0x348;
              elinks_internal((uchar *)
                              "assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld"
                              ,(uint)cache_size,cache_size._4_4_,
                              *(undefined4 *)((int)cached_00 + 0x48),
                              *(undefined4 *)((int)((int)cached_00 + 0x48) + 4),local_54,local_50);
            }
            else {
              assert_failed = 0;
            }
          }
          *(undefined *)((int)cached_00 + 0x5c) = *(undefined *)((int)cached_00 + 0x5c) | 0x20;
          poVar3 = (off_t *)((int)cached_00 + 0x48);
          if (assert_failed != 0) {
            assert_failed = 0;
            local_54 = 0;
            local_50 = 0;
            goto LAB_0806b97a;
          }
          bVar15 = local_54 < *(uint *)((int)cached_00 + 0x48);
          local_54 = local_54 - *(uint *)((int)cached_00 + 0x48);
          cached_00 = (list_head_elinks *)((cache_entry *)cached_00)->prev;
          local_50 = (local_50 - *(int *)((int)poVar3 + 4)) - (uint)bVar15;
          if (cached_00 == &cache_entries) goto LAB_0806bbc8;
        }
        else {
          *(undefined *)((int)cached_00 + 0x5c) = *(undefined *)((int)cached_00 + 0x5c) & 0xdf;
LAB_0806b97a:
          cached_00 = (list_head_elinks *)((cache_entry *)cached_00)->prev;
          if (cached_00 == &cache_entries) goto LAB_0806bbc8;
        }
      } while (uVar16 < CONCAT44(local_50,local_54));
LAB_0806b992:
    } while (!bVar14);
    goto LAB_0806b99a;
  }
LAB_0806bbc8:
  if (assert_failed == 0) {
    bVar15 = (local_54 | local_50) != 0;
    assert_failed = (int)bVar15;
    if (bVar15) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x354;
      elinks_internal((uchar *)
                      "assertion new_cache_size == 0 failed: cache_size (%ld) overflow: %ld",
                      (uint)cache_size,cache_size._4_4_,local_54,local_50);
      if (assert_failed != 0) goto LAB_0806bcd0;
    }
    cached_00 = &cache_entries;
  }
  else {
LAB_0806bcd0:
    assert_failed = 0;
    cached_00 = &cache_entries;
    local_54 = 0;
    local_50 = 0;
  }
LAB_0806b99a:
  pcVar13 = ((cache_entry *)cached_00)->next;
  if (pcVar13 != (cache_entry *)&cache_entries) {
    pcVar7 = pcVar13;
    if (!bVar14) goto LAB_0806b9fc;
    do {
      uVar11 = local_54 + *(int *)&pcVar7->data_size;
      uVar10 = *(int *)((int)&pcVar7->data_size + 4) +
               CARRY4(local_54,*(uint *)&pcVar7->data_size) + local_50;
      if (CONCAT44(uVar10,uVar11) <= uVar16) {
        pcVar7->field_0x5c = pcVar7->field_0x5c & 0xdf;
        local_54 = uVar11;
        local_50 = uVar10;
      }
      ppcVar4 = &pcVar7->next;
      pcVar7 = *ppcVar4;
    } while (*ppcVar4 != (cache_entry *)&cache_entries);
    pcVar13 = pcVar13->next;
    pcVar7 = pcVar13->prev;
    bVar2 = pcVar7->field_0x5c;
    while( true ) {
      if ((bVar2 & 0x20) != 0) {
        delete_cache_entry(pcVar7);
      }
      if (pcVar13 == (cache_entry *)&cache_entries) break;
LAB_0806b9fc:
      pcVar13 = pcVar13->next;
      pcVar7 = pcVar13->prev;
      bVar2 = pcVar7->field_0x5c;
    }
  }
  return;
}



// WARNING: Unknown calling convention

cache_entry * get_validated_cache_entry(uri *uri,cache_mode cache_mode)

{
  list_head_elinks *plVar1;
  byte bVar2;
  cache_entry *cached_00;
  option_value *poVar3;
  time_t tVar4;
  int iVar5;
  cache_entry *cached;
  timeval_T now;
  
  if (CACHE_MODE_NORMAL < cache_mode) {
    return (cache_entry *)0x0;
  }
  cached_00 = find_in_cache(uri);
  if (cached_00 == (cache_entry *)0x0) {
    return (cache_entry *)0x0;
  }
  bVar2 = cached_00->field_0x5c;
  if ((bVar2 & 8) != 0) {
    return (cache_entry *)0x0;
  }
  if ((cache_mode == CACHE_MODE_ALWAYS) || (cached_00->cache_mode != CACHE_MODE_NEVER)) {
    if (cached_00->redirect != (uri *)0x0) {
      poVar3 = get_opt_();
      if (poVar3->tree == (list_head_elinks *)0x0) goto LAB_0806bdec;
      bVar2 = cached_00->field_0x5c;
    }
    if ((bVar2 & 1) != 0) {
      timeval_now(&now);
      iVar5 = timeval_cmp(&cached_00->max_age,&now);
      if (iVar5 < 1) goto LAB_0806bdec;
    }
    if (CACHE_MODE_CHECK_IF_MODIFIED < cached_00->cache_mode) {
      return cached_00;
    }
    if ((cached_00->last_modified == (uchar *)0x0) && (cached_00->etag == (uchar *)0x0)) {
      return cached_00;
    }
    poVar3 = get_opt_();
    if (poVar3->number < 0) {
      return cached_00;
    }
    iVar5 = cached_00->seconds;
    poVar3 = get_opt_();
    plVar1 = poVar3->tree;
    tVar4 = time((time_t *)0x0);
    if (tVar4 <= (int)&plVar1->next + iVar5) {
      return cached_00;
    }
  }
  else {
LAB_0806bdec:
    if ((cached_00->object).refcount == 0) {
      delete_cache_entry(cached_00);
      return (cache_entry *)0x0;
    }
  }
  return (cache_entry *)0x0;
}



void __regparm3 truncate_entry(cache_entry *cached,off_t offset,int final)

{
  int **p;
  int *piVar1;
  int *piVar2;
  int **ppiVar3;
  uint uVar4;
  int in_ECX;
  int *piVar5;
  int iVar6;
  int iVar7;
  int *piVar8;
  fragment *f;
  
  piVar5 = (int *)((int)&cached->length + 4);
  iVar7 = *piVar5;
  if ((in_ECX <= iVar7) &&
     ((*piVar5 != in_ECX && in_ECX <= iVar7 ||
      ((uint)final <= *(uint *)&cached->length && *(int *)&cached->length != final)))) {
    cached->field_0x5c = cached->field_0x5c | 8;
    *(int *)&cached->length = final;
    *(int *)((int)&cached->length + 4) = in_ECX;
  }
  p = (int **)(cached->frag).next;
  while( true ) {
    if ((list_head_elinks *)p == &cached->frag) {
      return;
    }
    piVar5 = (int *)(final - (int)p[2]);
    piVar8 = (int *)((in_ECX - (int)p[3]) - (uint)((uint)final < p[2]));
    if ((assert_failed == 0) && (assert_failed = -((int)p[5] >> 0x1f), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x244;
      elinks_internal((uchar *)"assertion f->length >= 0 failed!");
    }
    piVar1 = p[5];
    piVar2 = p[4];
    if (((int)piVar8 < (int)piVar1) || (((int)piVar8 <= (int)piVar1 && (piVar5 < piVar2)))) break;
    p = (int **)*p;
  }
  if (((int)piVar8 < 0) || (((int)piVar8 < 1 && (piVar5 == (int *)0x0)))) goto joined_r0x0806bf7e;
  uVar4 = (int)piVar5 - (int)piVar2;
  iVar7 = -(uint)(piVar5 < piVar2) - (int)piVar1;
  iVar6 = (int)piVar8 +
          (uint)CARRY4(uVar4,*(uint *)&cached->data_size) +
          *(int *)((int)&cached->data_size + 4) + iVar7;
  *(uint *)&cached->data_size = uVar4 + *(int *)&cached->data_size;
  *(int *)((int)&cached->data_size + 4) = iVar6;
  if (assert_failed == 0) {
    assert_failed = -(iVar6 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x105;
      elinks_internal((uchar *)
                      "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                      ,*(undefined4 *)&cached->data_size,
                      *(undefined4 *)((int)&cached->data_size + 4));
      if (assert_failed != 0) goto LAB_0806bf0c;
    }
    iVar7 = (uint)CARRY4((uint)cache_size,uVar4) + cache_size._4_4_ + iVar7;
LAB_0806c10e:
    cache_size._4_4_ = (int)piVar8 + iVar7;
    cache_size._0_4_ = (uint)cache_size + uVar4;
  }
  else {
LAB_0806bf0c:
    assert_failed = 0;
    *(undefined4 *)&cached->data_size = 0;
    *(undefined4 *)((int)&cached->data_size + 4) = 0;
    iVar7 = (uint)CARRY4((uint)cache_size,uVar4) + cache_size._4_4_ + iVar7;
    if (assert_failed == 0) goto LAB_0806c10e;
    cache_size._0_4_ = 0;
    cache_size._4_4_ = 0;
  }
  assert_failed = 0;
  p[4] = piVar5;
  p[5] = piVar8;
  if (((int)offset == 0) ||
     (piVar5 = (int *)mem_mmap_realloc(p,(int)p[6] + 0x23,(int)piVar5 + 0x23), piVar5 == (int *)0x0)
     ) {
    p = (int **)*p;
  }
  else {
    *(int **)(*piVar5 + 4) = piVar5;
    *(int **)piVar5[1] = piVar5;
    piVar5[6] = piVar5[4];
    piVar5[7] = piVar5[5];
    p = (int **)*piVar5;
  }
joined_r0x0806bf7e:
  do {
    if ((list_head_elinks *)p == &cached->frag) {
      return;
    }
    ppiVar3 = (int **)*p;
    uVar4 = -(int)p[4];
    iVar7 = -((int)p[5] + (uint)(p[4] != (int *)0x0));
    iVar6 = iVar7 + *(int *)((int)&cached->data_size + 4) +
            (uint)CARRY4(uVar4,*(uint *)&cached->data_size);
    *(uint *)&cached->data_size = uVar4 + *(int *)&cached->data_size;
    *(int *)((int)&cached->data_size + 4) = iVar6;
    if (assert_failed == 0) {
      assert_failed = -(iVar6 >> 0x1f);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 0x105;
        elinks_internal((uchar *)
                        "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                        ,*(undefined4 *)&cached->data_size,
                        *(undefined4 *)((int)&cached->data_size + 4));
        if (assert_failed != 0) goto LAB_0806c023;
      }
      cache_size._4_4_ = cache_size._4_4_ + iVar7 + (uint)CARRY4((uint)cache_size,uVar4);
LAB_0806bfb0:
      cache_size._0_4_ = (uint)cache_size + uVar4;
    }
    else {
LAB_0806c023:
      assert_failed = 0;
      *(undefined4 *)&cached->data_size = 0;
      *(undefined4 *)((int)&cached->data_size + 4) = 0;
      cache_size._4_4_ = cache_size._4_4_ + iVar7 + (uint)CARRY4((uint)cache_size,uVar4);
      if (assert_failed == 0) goto LAB_0806bfb0;
      cache_size._0_4_ = 0;
      cache_size._4_4_ = 0;
    }
    assert_failed = 0;
    (*p)[1] = (int)p[1];
    *p[1] = (int)*p;
    mem_mmap_free(p,(int)p[6] + 0x23);
    p = ppiVar3;
  } while( true );
}



// WARNING: Unknown calling convention

void normalize_cache_entry(cache_entry *cached,off_t truncate_length)

{
  time_t tVar1;
  undefined4 in_stack_ffffffe8;
  
  if (-1 < truncate_length) {
    truncate_entry(cached,CONCAT44(in_stack_ffffffe8,1),(int)truncate_length);
    cached->field_0x5c = cached->field_0x5c & 0xf5;
    tVar1 = time((time_t *)0x0);
    cached->seconds = tVar1;
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0806c360)
// WARNING: Removing unreachable block (ram,0x0806c3a5)
// WARNING: Removing unreachable block (ram,0x0806c680)
// WARNING: Removing unreachable block (ram,0x0806c3f8)
// WARNING: Unknown calling convention

int add_fragment(cache_entry *cached,off_t offset,uchar *data,ssize_t length)

{
  int iVar1;
  longlong lVar2;
  uint uVar3;
  fragment *f_00;
  fragment *f;
  size_t size;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  uint final;
  int iVar9;
  fragment *f_01;
  int local_34;
  int local_20 [4];
  
  if (length == 0) {
    return 0;
  }
  local_20[0] = 0;
  iVar4 = length >> 0x1f;
  final = length + (uint)offset;
  iVar9 = iVar4 + offset._4_4_ + (uint)CARRY4(length,(uint)offset);
  iVar7 = *(int *)((int)&cached->length + 4);
  if ((iVar7 <= iVar9) &&
     ((iVar7 < iVar9 || (*(uint *)&cached->length <= final && final != *(uint *)&cached->length))))
  {
    *(uint *)&cached->length = final;
    *(int *)((int)&cached->length + 4) = iVar9;
  }
  cached->cache_id = id_counter;
  id_counter = id_counter + 1;
  f_01 = (fragment *)(cached->frag).next;
  if (f_01 != (fragment *)&cached->frag) {
    uVar8 = *(uint *)&f_01->offset;
    iVar7 = *(int *)((int)&f_01->offset + 4);
    if (f_01->offset <= offset) {
      uVar3 = *(uint *)&f_01->length + uVar8;
      iVar5 = *(int *)((int)&f_01->length + 4) + iVar7 + (uint)CARRY4(*(uint *)&f_01->length,uVar8);
      lVar2 = CONCAT44(iVar5,uVar3);
      while (lVar2 < offset) {
        f_01 = f_01->next;
        if (f_01 == (fragment *)&cached->frag) goto LAB_0806c406;
        iVar7 = *(int *)((int)&f_01->offset + 4);
        uVar8 = *(uint *)&f_01->offset;
        if (offset < f_01->offset) goto LAB_0806c406;
        uVar3 = *(uint *)&f_01->length + uVar8;
        iVar5 = *(int *)((int)&f_01->length + 4) + iVar7 +
                (uint)CARRY4(*(uint *)&f_01->length,uVar8);
        lVar2 = CONCAT44(iVar5,uVar3);
      }
      if ((iVar9 < iVar5) || ((iVar9 <= iVar5 && (final <= uVar3)))) {
        local_34 = 0;
        goto LAB_0806c2f8;
      }
      iVar6 = (iVar9 - iVar7) - (uint)(final < uVar8);
      iVar1 = *(int *)((int)&f_01->real_length + 4);
      if ((iVar1 < iVar6) ||
         ((iVar1 <= iVar6 &&
          (*(uint *)&f_01->real_length <= final - uVar8 &&
           final - uVar8 != *(uint *)&f_01->real_length)))) {
        f_01->length = offset - CONCAT44(iVar7,uVar8);
        f_01 = f_01->next;
        goto LAB_0806c406;
      }
      uVar8 = final - uVar3;
      iVar7 = (iVar9 - iVar5) - (uint)(final < uVar3);
      iVar4 = iVar7 + *(int *)((int)&cached->data_size + 4) +
              (uint)CARRY4(uVar8,*(uint *)&cached->data_size);
      *(uint *)&cached->data_size = uVar8 + *(int *)&cached->data_size;
      *(int *)((int)&cached->data_size + 4) = iVar4;
      if (assert_failed == 0) {
        assert_failed = -(iVar4 >> 0x1f);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 0x105;
          elinks_internal((uchar *)
                          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                          ,*(undefined4 *)&cached->data_size,
                          *(undefined4 *)((int)&cached->data_size + 4));
          if (assert_failed != 0) goto LAB_0806c5f8;
        }
        cache_size._4_4_ = cache_size._4_4_ + iVar7 + (uint)CARRY4((uint)cache_size,uVar8);
LAB_0806c5a6:
        cache_size._0_4_ = (uint)cache_size + uVar8;
      }
      else {
LAB_0806c5f8:
        assert_failed = 0;
        *(undefined4 *)&cached->data_size = 0;
        *(undefined4 *)((int)&cached->data_size + 4) = 0;
        cache_size._4_4_ = cache_size._4_4_ + iVar7 + (uint)CARRY4((uint)cache_size,uVar8);
        if (assert_failed == 0) goto LAB_0806c5a6;
        cache_size._0_4_ = 0;
        cache_size._4_4_ = 0;
      }
      assert_failed = 0;
      iVar7 = *(int *)((int)&f_01->offset + 4);
      *(uint *)&f_01->length = final - *(int *)&f_01->offset;
      *(uint *)((int)&f_01->length + 4) = (iVar9 - iVar7) - (uint)(final < *(uint *)&f_01->offset);
      local_34 = 1;
LAB_0806c2f8:
      memcpy((void *)((int)f_01 + ((uint)offset - *(int *)&f_01->offset) + 0x20),data,length);
      remove_overlaps(cached,f_01,local_20);
      truncate_entry(cached,ZEXT48(data) << 0x20,final);
      return local_34;
    }
  }
LAB_0806c406:
  size = (length | 0x3fffU) + 1;
  f_00 = frag_alloc(size);
  if (f_00 == (fragment *)0x0) {
    return -1;
  }
  f_00->offset = offset;
  *(ssize_t *)&f_00->length = length;
  *(int *)((int)&f_00->length + 4) = iVar4;
  *(size_t *)&f_00->real_length = size;
  *(int *)((int)&f_00->real_length + 4) = (int)size >> 0x1f;
  memcpy(f_00->data,data,length);
  f_00->next = f_01->prev->next;
  f_00->prev = f_01->prev;
  f_01->prev->next = f_00;
  f_00->next->prev = f_00;
  iVar7 = iVar4 + *(int *)((int)&cached->data_size + 4) +
          (uint)CARRY4(length,*(uint *)&cached->data_size);
  *(ssize_t *)&cached->data_size = length + *(int *)&cached->data_size;
  *(int *)((int)&cached->data_size + 4) = iVar7;
  if (assert_failed == 0) {
    assert_failed = -(iVar7 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 0x105;
      data = *(uchar **)&cached->data_size;
      elinks_internal((uchar *)
                      "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld"
                      ,data,*(undefined4 *)((int)&cached->data_size + 4));
      if (assert_failed != 0) goto LAB_0806c4b7;
    }
    cache_size._4_4_ = cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,length);
  }
  else {
LAB_0806c4b7:
    assert_failed = 0;
    *(undefined4 *)&cached->data_size = 0;
    *(undefined4 *)((int)&cached->data_size + 4) = 0;
    cache_size._4_4_ = cache_size._4_4_ + iVar4 + (uint)CARRY4((uint)cache_size,length);
    if (assert_failed != 0) {
      cache_size._0_4_ = 0;
      cache_size._4_4_ = 0;
      goto LAB_0806c510;
    }
  }
  cache_size._0_4_ = (uint)cache_size + length;
LAB_0806c510:
  assert_failed = 0;
  remove_overlaps(cached,f_00,local_20);
  if (local_20[0] != 0) {
    truncate_entry(cached,ZEXT48(data) << 0x20,final);
  }
  return 1;
}



// WARNING: Unknown calling convention

void lock_cache_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_cache_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_cache_entry_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

uri * get_cache_entry_uri(listbox_item *item)

{
  object *poVar1;
  uri *puVar2;
  
  puVar2 = *(uri **)((int)item->udata + 0x14);
  poVar1 = &puVar2->object;
  poVar1->refcount = poVar1->refcount + 1;
  return puVar2;
}



// WARNING: Unknown calling convention

listbox_item * get_cache_entry_root(listbox_item *item)

{
  return (listbox_item *)0x0;
}



// WARNING: Unknown calling convention

int can_delete_cache_entry(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void delete_cache_entry_item(listbox_item *item,int last)

{
  cache_entry *cached_00;
  cache_entry *cached;
  
  cached_00 = (cache_entry *)item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)((cached_00->object).refcount != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/dialogs.c";
    errline = 0xa7;
    elinks_internal((uchar *)"assertion !is_object_used(cached) failed!");
    delete_cache_entry(cached_00);
    return;
  }
  delete_cache_entry(cached_00);
  return;
}



// WARNING: Unknown calling convention

listbox_match match_cache_entry(listbox_item *item,terminal *term,uchar *text)

{
  void *pvVar1;
  char *pcVar2;
  listbox_match lVar3;
  cache_entry *cached;
  
  pvVar1 = item->udata;
  pcVar2 = c_strcasestr(**(char ***)((int)pvVar1 + 0x14),(char *)text);
  lVar3 = LISTBOX_MATCH_OK;
  if (pcVar2 == (char *)0x0) {
    pcVar2 = *(char **)((int)pvVar1 + 0x20);
    lVar3 = LISTBOX_MATCH_NO;
    if (pcVar2 != (char *)0x0) {
      pcVar2 = c_strcasestr(pcVar2,(char *)text);
      return (uint)(pcVar2 == (char *)0x0);
    }
  }
  return lVar3;
}



// WARNING: Unknown calling convention

uchar * _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_cache_entry_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  undefined4 uVar2;
  int iVar3;
  byte bVar4;
  string *psVar5;
  uchar *puVar6;
  option_value *poVar7;
  undefined4 uVar8;
  string msg;
  long local_20 [4];
  
  pvVar1 = item->udata;
  if (item->type != BI_FOLDER) {
    psVar5 = init_string(&msg);
    if (psVar5 != (string *)0x0) {
      puVar6 = _("URL",term);
      add_to_string(&msg,puVar6);
      add_to_string(&msg,": ");
      add_uri_to_string(&msg,*(uri **)((int)pvVar1 + 0x14),URI_PUBLIC);
      if (*(int *)((int)pvVar1 + 0x18) != *(int *)((int)pvVar1 + 0x14)) {
        puVar6 = _((uchar *)"Proxy URL",term);
        add_format_to_string(&msg,"\n%s: ",puVar6);
        add_uri_to_string(&msg,*(uri **)((int)pvVar1 + 0x18),URI_PUBLIC);
      }
      if (*(int *)((int)pvVar1 + 0x1c) != 0) {
        puVar6 = _("Redirect",term);
        add_format_to_string(&msg,"\n%s: ",puVar6);
        add_uri_to_string(&msg,*(uri **)((int)pvVar1 + 0x1c),URI_PUBLIC);
        if ((*(byte *)((int)pvVar1 + 0x5c) & 4) != 0) {
          add_to_string(&msg,(uchar *)" (GET)");
        }
      }
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x40);
      uVar8 = *(undefined4 *)((int)pvVar1 + 0x44);
      puVar6 = _("Size",term);
      add_format_to_string(&msg,(uchar *)"\n%s: %lld",puVar6,uVar2,uVar8);
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x48);
      uVar8 = *(undefined4 *)((int)pvVar1 + 0x4c);
      puVar6 = _((uchar *)"Loaded size",term);
      add_format_to_string(&msg,(uchar *)"\n%s: %lld",puVar6,uVar2,uVar8);
      iVar3 = *(int *)((int)pvVar1 + 0x24);
      if (iVar3 != 0) {
        puVar6 = _((uchar *)"Content type",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar6,iVar3,uVar8);
      }
      iVar3 = *(int *)((int)pvVar1 + 0x28);
      if (iVar3 != 0) {
        puVar6 = _((uchar *)"Last modified",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar6,iVar3,uVar8);
      }
      if (*(int *)((int)pvVar1 + 0x2c) != 0) {
        add_format_to_string
                  (&msg,(uchar *)"\n%s: %s",&DAT_08127c19,*(int *)((int)pvVar1 + 0x2c),uVar8);
      }
      iVar3 = *(int *)((int)pvVar1 + 0x30);
      if (iVar3 != 0) {
        puVar6 = _((uchar *)"SSL Cipher",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar6,iVar3);
      }
      iVar3 = *(int *)((int)pvVar1 + 0x34);
      if (iVar3 != 0) {
        puVar6 = _("Encoding",term);
        add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar6,iVar3);
      }
      bVar4 = *(byte *)((int)pvVar1 + 0x5c);
      if ((bVar4 & 0x18) != 0x10) {
        add_char_to_string(&msg,'\n');
        puVar6 = _((uchar *)"Flags",term);
        add_to_string(&msg,puVar6);
        add_to_string(&msg,": ");
        bVar4 = *(byte *)((int)pvVar1 + 0x5c);
        if ((bVar4 & 8) != 0) {
          puVar6 = _((uchar *)"incomplete",term);
          add_to_string(&msg,puVar6);
          add_char_to_string(&msg,' ');
          bVar4 = *(byte *)((int)pvVar1 + 0x5c);
        }
        if ((bVar4 & 0x10) == 0) {
          puVar6 = _((uchar *)"invalid",term);
          add_to_string(&msg,puVar6);
          bVar4 = *(byte *)((int)pvVar1 + 0x5c);
        }
      }
      if ((bVar4 & 1) == 0) {
        return msg.source;
      }
      local_20[0] = timeval_to_seconds((timeval_T *)((int)pvVar1 + 0x54));
      puVar6 = _((uchar *)"Expires",term);
      add_format_to_string(&msg,"\n%s: ",puVar6);
      poVar7 = get_opt_();
      add_date_to_string(&msg,poVar7->string,local_20);
      return msg.source;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_cache_entry_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  puVar1 = get_uri_string(*(uri **)((int)item->udata + 0x14),URI_PUBLIC);
  return puVar1;
}



// WARNING: Unknown calling convention

void cache_manager(session *ses)

{
  hierbox_browser(&cache_browser,ses);
  return;
}



// WARNING: Unknown calling convention

uchar * version_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  __printf_chk(1,&DAT_0813514d,full_static_version);
  fflush(stdout);
  return "";
}



// WARNING: Unknown calling convention

uchar * remote_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  byte bVar1;
  byte *s1;
  ushort *puVar2;
  uchar *command;
  ushort **ppuVar3;
  size_t sVar4;
  uchar *argend;
  byte *pbVar5;
  byte *pbVar6;
  byte *pbVar7;
  char *pcVar8;
  uchar *puVar9;
  int iVar10;
  uchar *start;
  byte *pbVar11;
  byte bVar12;
  uchar *arg;
  byte *pbVar13;
  int iVar14;
  int method;
  int len;
  uchar *end;
  char *local_9c;
  int local_88;
  uint local_80;
  anon_struct_8_2_38bb682c remote_methods [6];
  uchar *remote_argv [10];
  
  local_9c = "openURL";
  remote_methods[0].name = "openURL";
  remote_methods[0].type = REMOTE_METHOD_OPENURL;
  remote_methods[1].name = "ping";
  remote_methods[1].type = REMOTE_METHOD_PING;
  remote_methods[2].name = "addBookmark";
  remote_methods[2].type = REMOTE_METHOD_ADDBOOKMARK;
  remote_methods[3].name = "infoBox";
  remote_methods[3].type = REMOTE_METHOD_INFOBOX;
  remote_methods[4].name = "xfeDoCommand";
  remote_methods[4].type = REMOTE_METHOD_XFEDOCOMMAND;
  remote_methods[5].name = (uchar *)0x0;
  remote_methods[5].type = REMOTE_METHOD_NOT_SUPPORTED;
  if (*argc < 1) {
    o = (option_elinks *)s_Parameter_expected_08127cec;
  }
  else {
    s1 = **argv;
    bVar12 = *s1;
    if (((byte)(bVar12 + 0x9f) < 0x1a) || ((byte)(bVar12 + 0xbf) < 0x1a)) {
      local_88 = 0;
      do {
        do {
          local_88 = local_88 + 1;
          bVar12 = s1[local_88];
          pbVar6 = s1 + local_88;
        } while ((byte)(bVar12 + 0x9f) < 0x1a);
      } while ((byte)(bVar12 + 0xbf) < 0x1a);
    }
    else {
      local_88 = 0;
      pbVar6 = s1;
    }
    ppuVar3 = __ctype_b_loc();
    puVar2 = *ppuVar3;
    while ((*(byte *)((int)puVar2 + (uint)bVar12 * 2 + 1) & 0x20) != 0) {
      pbVar6 = pbVar6 + 1;
      bVar12 = *pbVar6;
    }
    sVar4 = strlen((char *)pbVar6);
    pbVar13 = pbVar6 + sVar4;
    if (pbVar6 < pbVar13) {
      bVar1 = *(byte *)((int)puVar2 + (uint)pbVar13[-1] * 2 + 1);
      while ((bVar1 & 0x20) != 0) {
        pbVar5 = pbVar13 + -1;
        if (pbVar5 <= pbVar6) goto LAB_0806ce7b;
        bVar1 = *(byte *)((int)puVar2 + (uint)pbVar13[-2] * 2 + 1);
        pbVar13 = pbVar5;
      }
    }
    pbVar5 = pbVar13 + -(uint)(pbVar6 < pbVar13);
LAB_0806ce7b:
    if (((local_88 == 0) || (bVar12 != 0x28)) || (*pbVar5 != 0x29)) {
      remote_session_flags = remote_session_flags | SES_REMOTE_NEW_TAB;
      return (uchar *)0x0;
    }
    pbVar6 = memacpy(pbVar6 + 1,(int)pbVar5 - (int)(pbVar6 + 1));
    if (pbVar6 == (byte *)0x0) {
      o = (option_elinks *)s_Out_of_memory_08127cff;
    }
    else {
      bVar12 = *pbVar6;
      local_80 = 0;
      pbVar13 = pbVar6;
      do {
        puVar2 = *ppuVar3;
        bVar1 = *(byte *)((int)puVar2 + (uint)bVar12 * 2 + 1);
        while ((bVar1 & 0x20) != 0) {
          pbVar13 = pbVar13 + 1;
          bVar12 = *pbVar13;
          bVar1 = *(byte *)((int)puVar2 + (uint)bVar12 * 2 + 1);
        }
        if (bVar12 == 0x22) {
          pbVar5 = pbVar13 + 1;
          pbVar13 = pbVar5;
          while( true ) {
            pcVar8 = strchr((char *)pbVar13,0x22);
            if (pcVar8 == (char *)0x0) {
              o = (option_elinks *)s_Mismatched_ending_argument_quoti_08111364;
              goto LAB_0806cf92;
            }
            bVar12 = pcVar8[1];
            pbVar13 = (byte *)(pcVar8 + 1);
            if (bVar12 != 0x22) break;
            pbVar13 = (byte *)(pcVar8 + 2);
          }
          while ((*(byte *)((int)puVar2 + (uint)bVar12 * 2 + 1) & 0x20) != 0) {
            pbVar13 = pbVar13 + 1;
            bVar12 = *pbVar13;
          }
          if ((bVar12 != 0x2c) && (bVar12 != 0)) {
            o = (option_elinks *)s_Garbage_after_quoted_argument_08127d20;
            goto LAB_0806cf92;
          }
          *pcVar8 = '\0';
          bVar12 = *pbVar5;
          pbVar11 = pbVar5;
          pbVar7 = pbVar5;
          while (bVar12 != 0) {
            *pbVar11 = bVar12;
            pbVar11 = pbVar11 + 1;
            pbVar7 = pbVar7 + (*pbVar7 == 0x22) + 1;
            bVar12 = *pbVar7;
          }
          remote_argv[local_80] = pbVar5;
          local_80 = local_80 + 1;
          *pbVar11 = 0;
          bVar12 = *pbVar13;
        }
        else {
          pbVar7 = (byte *)strchr((char *)pbVar13,0x2c);
          pbVar5 = pbVar7 + 1;
          if (pbVar7 == (byte *)0x0) {
            sVar4 = strlen((char *)pbVar13);
            pbVar5 = pbVar13 + sVar4;
            pbVar7 = pbVar5;
          }
          do {
            pbVar11 = pbVar7;
            if (pbVar11 <= pbVar13) {
              if (pbVar13 == pbVar11) goto LAB_0806cf2d;
              break;
            }
            pbVar7 = pbVar11 + -1;
          } while ((*(byte *)((int)puVar2 + (uint)pbVar11[-1] * 2 + 1) & 0x20) != 0);
          remote_argv[local_80] = pbVar13;
          local_80 = local_80 + 1;
LAB_0806cf2d:
          *pbVar11 = 0;
          bVar12 = *pbVar5;
          pbVar13 = pbVar5;
        }
        if (bVar12 == 0x2c) {
          pbVar13 = pbVar13 + 1;
          bVar12 = *pbVar13;
        }
        if (bVar12 == 0) {
          iVar14 = 0;
          goto LAB_0806d04a;
        }
      } while (local_80 < 0xb);
      mem_free(pbVar6);
      o = (option_elinks *)s_Too_many_arguments_08127d0d;
    }
  }
LAB_0806cf92:
  puVar9 = gettext((uchar *)o);
  return puVar9;
  while( true ) {
    iVar14 = iVar14 + 1;
    local_9c = (char *)remote_methods[iVar14].name;
    if ((uchar *)local_9c == (uchar *)0x0) break;
LAB_0806d04a:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
    errline = 0x142;
    iVar10 = elinks_strlcasecmp(s1,local_88,(uchar *)local_9c,0xffffffff,1);
    if (iVar10 == 0) break;
  }
  switch(remote_methods[iVar14].type) {
  case REMOTE_METHOD_OPENURL:
    if (local_80 == 0) {
      remote_session_flags = remote_session_flags | SES_REMOTE_PROMPT_URL;
    }
    else {
      if (local_80 == 2) {
        pcVar8 = strstr((char *)remote_argv[1],"new-window");
        if (pcVar8 == (char *)0x0) {
          pcVar8 = strstr((char *)remote_argv[1],"new-tab");
          if (pcVar8 == (char *)0x0) break;
          remote_session_flags = remote_session_flags | SES_REMOTE_NEW_TAB;
        }
        else {
          remote_session_flags = remote_session_flags | SES_REMOTE_NEW_WINDOW;
        }
      }
      else {
        remote_session_flags = remote_session_flags | SES_REMOTE_CURRENT_TAB;
      }
      remote_url = stracpy(remote_argv[0]);
    }
    break;
  case REMOTE_METHOD_PING:
    remote_session_flags = SES_REMOTE_PING;
    break;
  case REMOTE_METHOD_XFEDOCOMMAND:
    if ((local_80 != 0) &&
       (iVar14 = c_strcasecmp((char *)remote_argv[0],"openBrowser"), iVar14 == 0)) {
      remote_session_flags = SES_REMOTE_NEW_WINDOW;
    }
    break;
  case REMOTE_METHOD_ADDBOOKMARK:
    if (local_80 != 0) {
      remote_url = stracpy(remote_argv[0]);
      remote_session_flags = SES_REMOTE_ADD_BOOKMARK;
    }
    break;
  case REMOTE_METHOD_INFOBOX:
    if (local_80 != 0) {
      remote_url = stracpy(remote_argv[0]);
      if (remote_url != (uchar *)0x0) {
        insert_in_string(&remote_url,0,(uchar *)"about:",6);
      }
      remote_session_flags = SES_REMOTE_INFO_BOX;
    }
  }
  mem_free(pbVar6);
  if (remote_session_flags != 0) {
    *argv = *argv + 1;
    *argc = *argc + -1;
    return (uchar *)0x0;
  }
  puVar9 = gettext((uchar *)"Remote method not supported");
  return puVar9;
}



// WARNING: Unknown calling convention

uchar * lookup_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  int iVar1;
  uchar *puVar2;
  dns_result dVar3;
  char *pcVar4;
  void *p_1;
  in6_addr *__cp;
  int i;
  int iVar5;
  int in_GS_OFFSET;
  int local_74;
  sockaddr_storage *local_70;
  uchar p [46];
  sockaddr_in6 addr;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  local_70 = (sockaddr_storage *)0x0;
  if (*argc == 0) {
    puVar2 = gettext((uchar *)"Parameter expected");
  }
  else if (*argc < 2) {
    *argv = *argv + 1;
    *argc = *argc + -1;
    dVar3 = do_real_lookup((*argv)[-1],&local_70,&local_74,0);
    if (dVar3 == DNS_ERROR) {
      puVar2 = gettext("error");
      herror((char *)puVar2);
      puVar2 = "";
    }
    else {
      if (0 < local_74) {
        iVar5 = 0;
        do {
          while( true ) {
            addr._0_4_ = *(undefined4 *)(local_70 + iVar5);
            addr.sin6_flowinfo = local_70[iVar5].__ss_align;
            addr.sin6_addr.__in6_u.__u6_addr32[0] = *(undefined4 *)local_70[iVar5].__ss_padding;
            addr.sin6_addr.__in6_u.__u6_addr32[1] =
                 *(undefined4 *)(local_70[iVar5].__ss_padding + 4);
            addr.sin6_addr.__in6_u.__u6_addr32[2] =
                 *(undefined4 *)(local_70[iVar5].__ss_padding + 8);
            addr.sin6_addr.__in6_u.__u6_addr32[3] =
                 *(undefined4 *)(local_70[iVar5].__ss_padding + 0xc);
            addr.sin6_scope_id = *(uint32_t *)(local_70[iVar5].__ss_padding + 0x10);
            __cp = &addr.sin6_addr;
            if (addr.sin6_family != 10) {
              __cp = (in6_addr *)&addr.sin6_flowinfo;
            }
            pcVar4 = inet_ntop(addr._0_4_ & 0xffff,__cp,(char *)p,0x2e);
            if (pcVar4 != (char *)0x0) break;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
            iVar5 = iVar5 + 1;
            errline = 0xb3;
            puVar2 = gettext((uchar *)"Resolver error");
            elinks_error(puVar2);
            if (local_74 <= iVar5) goto LAB_0806d430;
          }
          iVar5 = iVar5 + 1;
          __printf_chk(1,&DAT_0813514d,p);
        } while (iVar5 < local_74);
      }
LAB_0806d430:
      if (local_70 != (sockaddr_storage *)0x0) {
        mem_free(local_70);
      }
      fflush(stdout);
      puVar2 = "";
    }
  }
  else {
    puVar2 = gettext((uchar *)"Too many parameters");
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return puVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

uchar * forcehtml_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  option_value *poVar1;
  
  poVar1 = get_opt_();
  safe_strncpy(poVar1->string,(uchar *)"text/html",0x400);
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * eval_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar *puVar1;
  
  if (*argc < 1) {
    puVar1 = gettext((uchar *)"Parameter expected");
    return puVar1;
  }
  *argv = *argv + 1;
  *argc = *argc + -1;
  parse_config_file(config_options,(uchar *)"-eval",(*argv)[-1],(string *)0x0,0);
  fflush(stdout);
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void print_full_help_inner(option_elinks *tree,uchar *path,int trees)

{
  option_type oVar1;
  uchar *help;
  string *psVar2;
  uchar *msgid;
  size_t sVar3;
  size_t sVar4;
  uchar *puVar5;
  list_head_elinks *plVar6;
  int iVar7;
  char *pcVar8;
  uchar *desc;
  uchar *puVar9;
  int max;
  option_elinks *option_elinks;
  option_elinks *tree_00;
  option_type type;
  uchar *capt;
  int in_GS_OFFSET;
  uchar *puVar10;
  uchar *puVar11;
  uchar *local_450;
  undefined2 *local_448;
  string wrapped;
  uchar saved [1024];
  uchar hexcolor [8];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  saved[0] = '\0';
  tree_00 = ((option_elinks *)(tree->value).tree)->next;
  if (tree_00 != (option_elinks *)(tree->value).tree) {
    local_448 = (undefined2 *)saved;
    do {
      while( true ) {
        puVar9 = tree_00->desc;
        oVar1 = tree_00->type;
        pcVar8 = (char *)tree_00->capt;
        if ((puVar9 == (uchar *)0x0) || (*puVar9 == '\0')) {
          puVar9 = "N/A";
        }
        else {
          puVar9 = gettext(puVar9);
        }
        if (((uint)(oVar1 == OPT_TREE) != trees) ||
           (((oVar1 == OPT_ALIAS && (tree != cmdline_options)) ||
            ((*(byte *)&tree_00->flags & 1) != 0)))) break;
        if ((uchar *)pcVar8 == (uchar *)0x0) {
          pcVar8 = "Template option folder";
          iVar7 = c_strncasecmp((char *)tree_00->name,"_template_",10);
          if (iVar7 != 0) {
            puVar9 = tree_00->name;
            sVar3 = strlen((char *)puVar9);
            max = (int)hexcolor - (int)local_448;
            safe_strncpy((uchar *)local_448,puVar9,max);
            safe_strncpy((uchar *)((int)local_448 + sVar3),", -",max - sVar3);
            local_448 = (undefined2 *)((int)local_448 + sVar3 + 3);
            break;
          }
        }
        msgid = option_types[tree_00->type].help_str;
        if (*msgid == '\0') {
          if (oVar1 == OPT_TREE) goto switchD_0806d7c0_caseD_9;
LAB_0806d614:
          puVar11 = tree_00->name;
          puVar10 = saved;
          __printf_chk(1,"    %s%s%s %s ",path,puVar10,puVar11,msgid);
          switch(oVar1) {
          case OPT_BOOL:
          case OPT_INT:
          case OPT_LONG:
            plVar6 = (tree_00->value).tree;
            pcVar8 = "(default: %ld)";
            break;
          case OPT_STRING:
            plVar6 = (tree_00->value).tree;
            pcVar8 = "(default: \"%s\")";
            break;
          case OPT_CODEPAGE:
            plVar6 = (list_head_elinks *)get_cp_name((tree_00->value).number);
            pcVar8 = "(default: %s)";
            break;
          case OPT_LANGUAGE:
            plVar6 = (list_head_elinks *)language_to_name((tree_00->value).number);
            pcVar8 = "(default: \"%s\")";
            break;
          case OPT_COLOR:
            plVar6 = (list_head_elinks *)get_color_string((tree_00->value).color,hexcolor);
            pcVar8 = "(default: %s)";
            break;
          default:
            goto switchD_0806d7c0_caseD_7;
          case OPT_ALIAS:
            plVar6 = (tree_00->value).tree;
            pcVar8 = "(alias for %s)";
            break;
          case OPT_TREE:
            goto switchD_0806d7c0_caseD_9;
          }
          puVar5 = gettext((uchar *)pcVar8);
          __printf_chk(1,puVar5,plVar6,puVar10,puVar11,msgid);
        }
        else {
          msgid = gettext(msgid);
          if (oVar1 != OPT_TREE) goto LAB_0806d614;
switchD_0806d7c0_caseD_9:
          sVar3 = strlen((char *)path);
          local_450 = tree_00->name;
          sVar4 = strlen((char *)local_450);
          if (0x400 < (int)(sVar3 + 2 + sVar4)) break;
          local_448 = (undefined2 *)saved;
          if (0 < (int)sVar3) {
            __memcpy_chk(saved,path,sVar3,0x400);
            local_448 = (undefined2 *)(saved + sVar3);
            local_450 = tree_00->name;
          }
          memcpy(local_448,local_450,sVar4 + 1);
          if (*pcVar8 != '\0') {
            pcVar8 = (char *)gettext((uchar *)pcVar8);
          }
          local_448 = (undefined2 *)((int)local_448 + sVar4);
          __printf_chk(1,"  %s: (%s)",pcVar8,saved);
        }
switchD_0806d7c0_caseD_7:
        _IO_putc(10,stdout);
        psVar2 = init_string(&wrapped);
        if ((psVar2 == (string *)0x0) ||
           (psVar2 = wrap_option_desc(&wrapped,puVar9,&print_option_desc::indent,0x43),
           psVar2 == (string *)0x0)) {
          puVar9 = gettext((uchar *)"Out of memory formatting option documentation");
          __fprintf_chk(stderr,1,"%12s%s\n",&DAT_0812e3d8,puVar9);
        }
        else {
          fwrite(wrapped.source,1,wrapped.length,stdout);
        }
        done_string(&wrapped);
        _IO_putc(10,stdout);
        if (tree_00->type == OPT_TREE) {
          *local_448 = 0x2e;
          print_full_help_outer(tree_00,saved);
        }
        local_448 = (undefined2 *)saved;
        saved[0] = '\0';
        tree_00 = tree_00->next;
        if ((option_elinks *)(tree->value).tree == tree_00) goto LAB_0806d738;
      }
      tree_00 = tree_00->next;
    } while ((option_elinks *)(tree->value).tree != tree_00);
  }
LAB_0806d738:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void print_full_help_outer(option_elinks *tree,uchar *path)

{
  print_full_help_inner(tree,path,0);
  print_full_help_inner(tree,path,1);
  return;
}



// WARNING: Unknown calling convention

uchar * printconfigdump_cmd(option_elinks *option_elinks,uchar ***argv,int *argc)

{
  option_value *poVar1;
  uchar *p;
  uchar *config_string;
  
  poVar1 = get_opt_();
  poVar1->number = 2;
  p = create_config_string("","",config_options);
  if (p != (uchar *)0x0) {
    __printf_chk(1,"%s",p);
    mem_free(p);
  }
  fflush(stdout);
  return "";
}



// WARNING: Unknown calling convention

uchar * redir_cmd(option_elinks *option_elinks,uchar ***argv,int *argc)

{
  uchar *puVar1;
  option_elinks *poVar2;
  int iVar3;
  char *name_;
  uchar *target;
  byte *pbVar4;
  byte *pbVar5;
  byte *pbVar6;
  bool bVar7;
  bool bVar8;
  bool bVar9;
  
  iVar3 = 8;
  bVar7 = &stack0xfffffffc < (undefined *)0x48;
  bVar9 = &stack0x00000000 == (undefined *)0x4c;
  pbVar5 = option_elinks->name;
  pbVar4 = pbVar5;
  pbVar6 = (byte *)"confdir";
  do {
    if (iVar3 == 0) break;
    iVar3 = iVar3 + -1;
    bVar7 = *pbVar4 < *pbVar6;
    bVar9 = *pbVar4 == *pbVar6;
    pbVar4 = pbVar4 + 1;
    pbVar6 = pbVar6 + 1;
  } while (bVar9);
  name_ = "config-dir";
  bVar8 = (!bVar7 && !bVar9) < bVar7;
  bVar7 = (!bVar7 && !bVar9) == bVar7;
  if (!bVar7) {
    iVar3 = 9;
    pbVar4 = pbVar5;
    pbVar6 = (byte *)"conffile";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar8 = *pbVar4 < *pbVar6;
      bVar7 = *pbVar4 == *pbVar6;
      pbVar4 = pbVar4 + 1;
      pbVar6 = pbVar6 + 1;
    } while (bVar7);
    name_ = "config-file";
    bVar7 = (!bVar8 && !bVar7) == bVar8;
    if (!bVar7) {
      iVar3 = 6;
      pbVar4 = (byte *)0x813154f;
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        bVar7 = *pbVar5 == *pbVar4;
        pbVar5 = pbVar5 + 1;
        pbVar4 = pbVar4 + 1;
      } while (bVar7);
      if (!bVar7) {
        puVar1 = gettext((uchar *)"Internal consistency error");
        return puVar1;
      }
      if (redir_cmd::lexical_block_3::complained != 0) {
        return (uchar *)0x0;
      }
      redir_cmd::lexical_block_3::complained = 1;
      puVar1 = **argv;
      if (((puVar1 != (uchar *)0x0) && ((byte)(*puVar1 - 0x30) < 2)) && (puVar1[1] == '\0')) {
        *argv = *argv + 1;
        *argc = *argc + -1;
      }
      __fprintf_chk();
      __fprintf_chk();
      __fprintf_chk();
      __fprintf_chk();
      return (uchar *)0x0;
    }
  }
  poVar2 = get_opt_rec(cmdline_options,(uchar *)name_);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(poVar2 == (option_elinks *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
    errline = 0x2c1;
    elinks_internal((uchar *)"assertion option failed!");
  }
  (*option_types[poVar2->type].cmdline)(poVar2,argv,argc);
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

retval parse_options(int argc,uchar **argv,list_head_elinks *url_list)

{
  uchar **ppuVar1;
  option_elinks *tree;
  uchar *puVar2;
  option_elinks *poVar3;
  uchar *puVar4;
  uchar *err;
  char *__s;
  uchar *pos;
  uchar *puVar5;
  option_elinks *option_elinks;
  uchar *oname;
  uchar *argname;
  uchar **local_24;
  retval local_20 [4];
  
  tree = cmdline_options;
  local_24 = argv;
  while( true ) {
    do {
      while( true ) {
        if (argc == RET_OK) {
          return RET_OK;
        }
        argc = argc + ~RET_OK;
        ppuVar1 = local_24 + 1;
        puVar4 = *local_24;
        local_24 = ppuVar1;
        local_20[0] = argc;
        if ((*puVar4 == '-') && (puVar4[1] != '\0')) break;
        if (url_list != (list_head_elinks *)0x0) {
          add_to_string_list(url_list,puVar4,-1);
          argc = local_20[0];
        }
      }
      puVar2 = stracpy(puVar4 + 1);
      argc = local_20[0];
    } while (puVar2 == (uchar *)0x0);
    puVar5 = puVar4 + 1;
    if (puVar4[1] == '-') {
      puVar5 = puVar4 + 2;
    }
    poVar3 = get_opt_rec(tree,puVar5);
    if ((poVar3 == (option_elinks *)0x0) &&
       (poVar3 = get_opt_rec(tree,puVar2), poVar3 == (option_elinks *)0x0)) {
      for (__s = strchr((char *)(puVar2 + 1),0x5f); __s != (char *)0x0; __s = strchr(__s,0x5f)) {
        *__s = '-';
      }
      poVar3 = get_opt_rec(tree,puVar2 + 1);
      mem_free(puVar2);
      if (poVar3 == (option_elinks *)0x0) break;
    }
    else {
      mem_free(puVar2);
    }
    if (option_types[poVar3->type].cmdline ==
        (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x0) break;
    puVar4 = (*option_types[poVar3->type].cmdline)(poVar3,&local_24,(int *)local_20);
    if (puVar4 != (uchar *)0x0) {
      if (*puVar4 == '\0') {
        return RET_COMMAND;
      }
      puVar2 = local_24[-1];
      puVar5 = gettext((uchar *)"Cannot parse option %s: %s");
      usrerror(puVar5,puVar2,puVar4);
      return RET_SYNTAX;
    }
    argc = local_20[0];
    if (remote_url != (uchar *)0x0) {
      if (url_list != (list_head_elinks *)0x0) {
        add_to_string_list(url_list,remote_url,-1);
      }
      mem_free(remote_url);
      remote_url = (uchar *)0x0;
      argc = local_20[0];
    }
  }
  puVar4 = local_24[-1];
  puVar2 = gettext((uchar *)"Unknown option %s");
  usrerror(puVar2,puVar4);
  return RET_SYNTAX;
}



// WARNING: Unknown calling convention

uchar * printhelp_cmd(option_elinks *option_elinks,uchar ***argv,int *argc)

{
  char *pcVar1;
  uchar *puVar2;
  uchar *puVar3;
  size_t sVar4;
  size_t sVar5;
  string *psVar6;
  int iVar7;
  uint uVar8;
  int len;
  uchar *help;
  option_elinks *option_elinks_1;
  list_head_elinks *plVar9;
  string *string_00;
  string *saved;
  uchar *capt;
  option_elinks *poVar10;
  int in_GS_OFFSET;
  undefined uVar11;
  byte bVar12;
  uchar *local_40;
  string string;
  uchar align [20];
  int local_20;
  
  bVar12 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar1 = strchr((char *)full_static_version,10);
  uVar11 = pcVar1 == (char *)0x0;
  if (!(bool)uVar11) {
    *pcVar1 = '\0';
  }
  __printf_chk(1,"%s\n\n",full_static_version);
  iVar7 = 0xc;
  puVar2 = option_elinks->name;
  puVar3 = (uchar *)"config-help";
  do {
    if (iVar7 == 0) break;
    iVar7 = iVar7 + -1;
    uVar11 = *puVar2 == *puVar3;
    puVar2 = puVar2 + (uint)bVar12 * -2 + 1;
    puVar3 = puVar3 + (uint)bVar12 * -2 + 1;
  } while ((bool)uVar11);
  if ((bool)uVar11) {
    puVar2 = gettext((uchar *)"Configuration options");
    __printf_chk(1,&DAT_08127efa,puVar2);
    print_full_help_outer(config_options,"");
  }
  else {
    puVar2 = gettext((uchar *)"Options");
    puVar3 = gettext((uchar *)"Usage: elinks [OPTION]... [URL]...");
    __printf_chk(1,&DAT_08127ef6,puVar3,puVar2);
    iVar7 = 10;
    puVar2 = option_elinks->name;
    puVar3 = (uchar *)"long-help";
    do {
      if (iVar7 == 0) break;
      iVar7 = iVar7 + -1;
      uVar11 = *puVar2 == *puVar3;
      puVar2 = puVar2 + (uint)bVar12 * -2 + 1;
      puVar3 = puVar3 + (uint)bVar12 * -2 + 1;
    } while ((bool)uVar11);
    if ((bool)uVar11) {
      print_full_help_outer(cmdline_options,"-");
    }
    else {
      string_00 = (string *)0x0;
      string.source = (uchar *)0x0;
      string.length = 0;
      align[0] = ' ';
      align[1] = ' ';
      align[2] = ' ';
      align[3] = ' ';
      align[4] = ' ';
      align[5] = ' ';
      align[6] = ' ';
      align[7] = ' ';
      align[8] = ' ';
      align[9] = ' ';
      align[10] = ' ';
      align[11] = ' ';
      align[12] = ' ';
      align[13] = ' ';
      align[14] = ' ';
      align[15] = ' ';
      align[16] = ' ';
      align[17] = ' ';
      align[18] = ' ';
      align[19] = '\0';
      plVar9 = (list_head_elinks *)((cmdline_options->value).tree)->next;
      local_40 = "";
      poVar10 = cmdline_options;
      if (plVar9 != (cmdline_options->value).tree) {
LAB_0806e0d9:
        puVar2 = (uchar *)plVar9[1].prev;
        sVar5 = strlen((char *)puVar2);
        if ((*(byte *)&plVar9[2].next & 1) == 0) {
          puVar3 = (uchar *)plVar9[5].next;
          if (puVar3 == (uchar *)0x0) {
            if (string_00 == (string *)0x0) {
              psVar6 = init_string(&string);
              poVar10 = cmdline_options;
              if (psVar6 == (string *)0x0) goto LAB_0806e0c2;
              puVar2 = (uchar *)plVar9[1].prev;
              string_00 = &string;
            }
            add_to_string(string_00,puVar2);
            add_to_string(string_00,", -");
            poVar10 = cmdline_options;
          }
          else {
            if (*puVar3 != '\0') {
              puVar3 = gettext(puVar3);
            }
            puVar2 = option_types[(int)plVar9[2].prev].help_str;
            if (*puVar2 != '\0') {
              puVar2 = gettext(puVar2);
            }
            sVar4 = strlen((char *)puVar2);
            iVar7 = 0;
            if (string_00 != (string *)0x0) {
              iVar7 = string_00->length;
            }
            uVar8 = ((0x14 - sVar5) - sVar4) - iVar7;
            if ((int)uVar8 < 0) {
              uVar8 = (uint)(*puVar2 != '\0');
            }
            align[uVar8] = '\0';
            __printf_chk(1,"  -%s%s %s%s%s\n",local_40,plVar9[1].prev,puVar2,align,puVar3);
            align[uVar8] = ' ';
            poVar10 = cmdline_options;
            if (string_00 != (string *)0x0) {
              done_string(string_00);
              string_00 = (string *)0x0;
              poVar10 = cmdline_options;
            }
          }
        }
LAB_0806e0c2:
        plVar9 = (list_head_elinks *)plVar9->next;
        if (plVar9 != (poVar10->value).tree) {
          local_40 = "";
          if (string_00 != (string *)0x0) {
            local_40 = string_00->source;
          }
          goto LAB_0806e0d9;
        }
      }
    }
  }
  fflush(stdout);
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return "";
}



// WARNING: Unknown calling convention

void skip_quoted(conf_parsing_pos *pos)

{
  uchar *puVar1;
  uchar uVar2;
  uchar *puVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  uVar2 = *pos->look;
  assert_failed = (int)(uVar2 != '\"' && uVar2 != '\'');
  if (uVar2 != '\"' && uVar2 != '\'') {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
    errline = 0x88;
    elinks_internal((uchar *)"assertion isquote(*pos->look) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  puVar3 = pos->look;
  puVar1 = puVar3 + 1;
  pos->look = puVar1;
  uVar2 = puVar3[1];
  if (uVar2 != '\0') {
    if ((uVar2 != '\"') && (uVar2 != '\'')) {
      do {
        if ((uVar2 == '\\') && (puVar3 = puVar1 + 1, puVar1[1] != '\0')) {
          pos->look = puVar3;
          uVar2 = *puVar3;
        }
        else {
          puVar3 = pos->look;
          uVar2 = *puVar3;
        }
        if (uVar2 == '\n') {
          pos->line = pos->line + 1;
          puVar3 = pos->look;
        }
        puVar1 = puVar3 + 1;
        pos->look = puVar1;
        uVar2 = puVar3[1];
        if (uVar2 == '\0') {
          return;
        }
      } while ((uVar2 != '\'') && (uVar2 != '\"'));
    }
    pos->look = puVar1 + 1;
  }
  return;
}



// WARNING: Unknown calling convention

void skip_option_value(conf_parsing_pos *pos)

{
  uchar uVar1;
  uchar *puVar2;
  
  puVar2 = pos->look;
  uVar1 = *puVar2;
  if ((uVar1 != '\'') && (uVar1 != '\"')) {
    while ((((byte)(uVar1 + 0x9f) < 0x1a ||
            ((((byte)(uVar1 + 0xbf) < 0x1a || ((byte)(uVar1 - 0x30) < 10)) || (uVar1 == '.')))) ||
           ((uVar1 == '+' || (uVar1 == '-'))))) {
      puVar2 = puVar2 + 1;
      pos->look = puVar2;
      uVar1 = *puVar2;
    }
    return;
  }
  skip_quoted(pos);
  return;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Unknown calling convention

void add_cfg_header_to_string(string *string,uchar *text)

{
  size_t sVar1;
  int iVar2;
  int n;
  int times;
  
  sVar1 = strlen((char *)text);
  iVar2 = sVar1 + 2;
  times = 10;
  if ((9 < iVar2) && (times = 0x50, iVar2 < 0x51)) {
    times = iVar2;
  }
  add_to_string(string,"\n\n\n");
  add_xchar_to_string(string,'#',times);
  add_to_string(string,"\n# ");
  add_to_string(string,text);
  add_to_string(string,"#\n\n");
  return;
}



// WARNING: Unknown calling convention

void skip_white(conf_parsing_pos *pos)

{
  byte bVar1;
  ushort **ppuVar2;
  ushort *puVar3;
  uint uVar4;
  int iVar5;
  size_t __result;
  uchar *start;
  byte *pbVar6;
  
  pbVar6 = pos->look;
  bVar1 = *pbVar6;
  if (bVar1 != 0) {
    ppuVar2 = __ctype_b_loc();
    uVar4 = (uint)bVar1;
    puVar3 = *ppuVar2;
    do {
      while ((*(byte *)((int)puVar3 + uVar4 * 2 + 1) & 0x20) != 0) {
        if ((char)uVar4 == '\n') {
          pos->line = pos->line + 1;
          puVar3 = *ppuVar2;
        }
        pbVar6 = pbVar6 + 1;
        uVar4 = (uint)*pbVar6;
      }
      if ((char)uVar4 != '#') break;
      iVar5 = 0;
      do {
        iVar5 = iVar5 + 1;
        if (pbVar6[iVar5] == 0) break;
      } while (pbVar6[iVar5] != 10);
      pbVar6 = pbVar6 + iVar5;
      uVar4 = (uint)*pbVar6;
    } while (*pbVar6 != 0);
  }
  pos->look = pbVar6;
  return;
}



// WARNING: Unknown calling convention

parse_error show_parse_error(conf_parsing_state *state,parse_error err)

{
  if (state->filename != (uchar *)0x0) {
    __fprintf_chk(stderr,1,"%s:%d: %s\n",state->filename,(state->pos).line,
                  show_parse_error::error_msg[err]);
  }
  return err;
}



// WARNING: Unknown calling convention

parse_error
parse_bind(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  int *line;
  uchar *puVar1;
  uchar *keymap_str;
  parse_error pVar2;
  uchar *puVar3;
  uchar *action_str;
  uchar *source;
  option_value *poVar4;
  int iVar5;
  parse_error err;
  uchar *keystroke;
  uchar *action;
  
  skip_white(&state->pos);
  puVar3 = (state->pos).look;
  if (*puVar3 == '\0') goto LAB_0806e67a;
  iVar5 = (state->pos).line;
  line = &(state->pos).line;
  keymap_str = str_rd((option_elinks *)0x0,(uchar **)state,line);
  skip_white(&state->pos);
  if ((keymap_str == (uchar *)0x0) || (puVar1 = (state->pos).look, *puVar1 == '\0')) {
    (state->pos).look = puVar3;
    (state->pos).line = iVar5;
    goto LAB_0806e67a;
  }
  iVar5 = (state->pos).line;
  puVar3 = str_rd((option_elinks *)0x0,(uchar **)state,line);
  skip_white(&state->pos);
  if (puVar3 == (uchar *)0x0) {
    mem_free(keymap_str);
  }
  else {
    if (*(state->pos).look != '\0') {
      skip_white(&state->pos);
      puVar1 = (state->pos).look;
      if (*puVar1 == '=') {
        (state->pos).look = puVar1 + 1;
        skip_white(&state->pos);
        puVar1 = (state->pos).look;
        if (*puVar1 != '\0') {
          iVar5 = (state->pos).line;
          action_str = str_rd((option_elinks *)0x0,(uchar **)state,line);
          if (action_str == (uchar *)0x0) {
            mem_free(keymap_str);
            mem_free(puVar3);
            (state->pos).line = iVar5;
            (state->pos).look = puVar1;
            goto LAB_0806e67a;
          }
          if (mirror == (string *)0x0) {
            poVar4 = get_opt_();
            if (poVar4->tree == (list_head_elinks *)0x0) {
              iVar5 = bind_do(keymap_str,puVar3,action_str,is_system_conf);
              if (iVar5 != 0) goto LAB_0806e84e;
            }
          }
          else if (is_system_conf == 0) {
            source = bind_act(keymap_str,puVar3);
            if (source != (uchar *)0x0) {
              add_bytes_to_string__(mirror,state->mirrored,(int)puVar1 - (int)state->mirrored);
              add_to_string(mirror,source);
              mem_free(source);
              state->mirrored = (state->pos).look;
              err = ERROR_NONE;
              goto LAB_0806e772;
            }
LAB_0806e84e:
            err = show_parse_error(state,ERROR_VALUE);
            goto LAB_0806e772;
          }
          err = ERROR_NONE;
LAB_0806e772:
          mem_free(keymap_str);
          mem_free(puVar3);
          mem_free(action_str);
          return err;
        }
      }
      mem_free(keymap_str);
      mem_free(puVar3);
      goto LAB_0806e67a;
    }
    mem_free(keymap_str);
    mem_free(puVar3);
  }
  (state->pos).look = puVar1;
  (state->pos).line = iVar5;
LAB_0806e67a:
  pVar2 = show_parse_error(state,ERROR_PARSE);
  return pVar2;
}



// WARNING: Unknown calling convention

parse_error
parse_unset(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  uchar uVar1;
  uchar *src;
  uchar *puVar2;
  uchar *name;
  uchar *optname_copy;
  option_elinks *poVar3;
  option_elinks *poVar4;
  option_elinks *flagsite;
  option_flags oVar5;
  parse_error pVar6;
  option_elinks *opt;
  
  skip_white(&state->pos);
  src = (state->pos).look;
  uVar1 = *src;
  puVar2 = src;
  if (uVar1 == '\0') {
    pVar6 = ERROR_PARSE;
  }
  else {
    while ((((((byte)(uVar1 + 0x9f) < 0x1a || ((byte)(uVar1 + 0xbf) < 0x1a)) ||
             ((byte)(uVar1 - 0x30) < 10)) || ((uVar1 == '_' || (uVar1 == '-')))) ||
           ((uVar1 == '*' || ((uVar1 == '.' || (uVar1 == '+'))))))) {
      puVar2 = puVar2 + 1;
      (state->pos).look = puVar2;
      uVar1 = *puVar2;
    }
    name = memacpy(src,(int)puVar2 - (int)src);
    if (name != (uchar *)0x0) {
      poVar3 = get_opt_rec_real(opt_tree,name);
      mem_free(name);
      if ((poVar3 != (option_elinks *)0x0) && ((poVar3->flags & OPT_HIDDEN) == 0)) {
        if (mirror == (string *)0x0) {
          if ((poVar3->flags & OPT_ALLOC) == 0) {
            mark_option_as_deleted(poVar3);
          }
          else {
            delete_option(poVar3);
          }
        }
        else if (is_system_conf == 0) {
          poVar4 = indirect_option(poVar3);
          oVar5 = poVar4->flags;
          if ((-1 < (char)oVar5) &&
             (option_types[poVar3->type].write != (_func_void_option_elinks_ptr_string_ptr *)0x0)) {
            add_to_string(mirror,"set ");
            add_bytes_to_string__(mirror,src,(int)puVar2 - (int)src);
            add_to_string(mirror," = ");
            (*option_types[poVar3->type].write)(poVar3,mirror);
            state->mirrored = (state->pos).look;
            oVar5 = poVar4->flags;
          }
          poVar4->flags = oVar5 & ~OPT_MUST_SAVE;
        }
        else {
          poVar3 = indirect_option(poVar3);
          oVar5 = poVar3->flags;
          if ((char)oVar5 < '\0') {
            poVar3->flags = oVar5 & ~OPT_MUST_SAVE;
          }
          else {
            poVar3->flags = oVar5 | OPT_MUST_SAVE;
          }
        }
      }
      return ERROR_NONE;
    }
    pVar6 = ERROR_NOMEM;
  }
  pVar6 = show_parse_error(state,pVar6);
  return pVar6;
}



// WARNING: Unknown calling convention

parse_error
parse_set(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  uchar uVar1;
  uchar *src;
  uchar *puVar2;
  uchar *puVar3;
  uchar *optname_copy;
  option_elinks *alias;
  int iVar4;
  option_elinks *poVar5;
  option_flags oVar6;
  parse_error pVar7;
  option_elinks *flagsite;
  uchar *puVar8;
  option_elinks *opt;
  
  skip_white(&state->pos);
  src = (state->pos).look;
  uVar1 = *src;
  puVar8 = src;
  if (uVar1 != '\0') {
    while ((((((byte)(uVar1 + 0x9f) < 0x1a || ((byte)(uVar1 + 0xbf) < 0x1a)) ||
             ((byte)(uVar1 - 0x30) < 10)) || ((uVar1 == '_' || (uVar1 == '-')))) ||
           ((uVar1 == '*' || ((uVar1 == '.' || (uVar1 == '+'))))))) {
      puVar8 = puVar8 + 1;
      (state->pos).look = puVar8;
      uVar1 = *puVar8;
    }
    skip_white(&state->pos);
    puVar3 = (state->pos).look;
    if (*puVar3 == '=') {
      (state->pos).look = puVar3 + 1;
      skip_white(&state->pos);
      if (*(state->pos).look != '\0') {
        puVar3 = memacpy(src,(int)puVar8 - (int)src);
        if (puVar3 == (uchar *)0x0) {
          pVar7 = ERROR_NOMEM;
          goto LAB_0806ead5;
        }
        iVar4 = (state->pos).line;
        puVar2 = (state->pos).look;
        if (mirror == (string *)0x0) {
          alias = get_opt_rec(opt_tree,puVar3);
        }
        else {
          alias = get_opt_rec_real(opt_tree,puVar3);
        }
        mem_free(puVar3);
        if ((alias == (option_elinks *)0x0) || ((*(byte *)&alias->flags & 1) != 0)) {
          show_parse_error(state,ERROR_OPTION);
          skip_option_value(&state->pos);
          return ERROR_OPTION;
        }
        if (option_types[alias->type].read ==
            (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_int_ptr *)0x0) {
LAB_0806ecc2:
          show_parse_error(state,ERROR_VALUE);
          skip_option_value(&state->pos);
          return ERROR_VALUE;
        }
        puVar3 = (*option_types[alias->type].read)(alias,(uchar **)state,&(state->pos).line);
        if (puVar3 == (uchar *)0x0) {
          (state->pos).line = iVar4;
          (state->pos).look = puVar2;
          goto LAB_0806ecc2;
        }
        if (mirror != (string *)0x0) {
          if (is_system_conf == 0) {
            poVar5 = indirect_option(alias);
            oVar6 = poVar5->flags;
            if ((char)oVar6 < '\0') {
              add_to_string(mirror,(uchar *)"unset ");
              add_bytes_to_string__(mirror,src,(int)puVar8 - (int)src);
              state->mirrored = (state->pos).look;
              oVar6 = poVar5->flags;
            }
            else if (option_types[alias->type].write !=
                     (_func_void_option_elinks_ptr_string_ptr *)0x0) {
              add_bytes_to_string__(mirror,state->mirrored,(int)puVar2 - (int)state->mirrored);
              (*option_types[alias->type].write)(alias,mirror);
              state->mirrored = (state->pos).look;
              oVar6 = poVar5->flags;
            }
            poVar5->flags = oVar6 & ~OPT_MUST_SAVE;
          }
          else {
            poVar5 = indirect_option(alias);
            oVar6 = poVar5->flags;
            if ((-1 < (char)oVar6) &&
               (option_types[alias->type].equals != (_func_int_option_elinks_ptr_uchar_ptr *)0x0)) {
              iVar4 = (*option_types[alias->type].equals)(alias,puVar3);
              if (iVar4 != 0) {
                poVar5->flags = poVar5->flags & ~OPT_MUST_SAVE;
                goto LAB_0806ec22;
              }
              oVar6 = poVar5->flags;
            }
            poVar5->flags = oVar6 | OPT_MUST_SAVE;
          }
LAB_0806ec22:
          mem_free(puVar3);
          return ERROR_NONE;
        }
        if ((option_types[alias->type].set != (_func_int_option_elinks_ptr_uchar_ptr *)0x0) &&
           (iVar4 = (*option_types[alias->type].set)(alias,puVar3), iVar4 != 0)) goto LAB_0806ec22;
        mem_free(puVar3);
      }
      pVar7 = ERROR_VALUE;
      goto LAB_0806ead5;
    }
  }
  pVar7 = ERROR_PARSE;
LAB_0806ead5:
  pVar7 = show_parse_error(state,pVar7);
  return pVar7;
}



// WARNING: Unknown calling convention

string * wrap_option_desc(string *out,uchar *src,string *indent,int maxwidth)

{
  uint uVar1;
  uchar uVar2;
  string *psVar3;
  uint size;
  int iVar4;
  int width;
  uint uVar5;
  size_t __n;
  uchar *uncopied;
  uchar *puVar6;
  uchar *last_space;
  uchar *puVar7;
  uchar *source;
  
  uVar2 = *src;
  if (uVar2 == '\0') {
    return out;
  }
  iVar4 = 0;
  puVar6 = (uchar *)0x0;
  source = src;
  do {
    puVar7 = src;
    if (uVar2 == '\n') {
split:
      psVar3 = add_string_to_string(out,indent);
      if (psVar3 == (string *)0x0) {
        return (string *)0x0;
      }
      if (assert_failed != 0) {
        assert_failed = 0;
        return (string *)0x0;
      }
      __n = (int)puVar7 - (int)source;
      if (((source == (uchar *)0x0) || (out == (string *)0x0)) || ((int)__n < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) {
          assert_failed = 0;
          return (string *)0x0;
        }
      }
      assert_failed = 0;
      if (__n != 0) {
        assert_failed = 0;
        iVar4 = out->length + __n;
        uVar5 = out->length + 0xff;
        uVar1 = uVar5 >> 8;
        uVar5 = uVar5 & 0xffffff00;
        size = iVar4 + 0x100U & 0xffffff00;
        if (uVar5 <= size && size + uVar1 * -0x100 != 0) {
          puVar6 = (uchar *)mem_realloc(out->source,size);
          if (puVar6 == (uchar *)0x0) {
            return (string *)0x0;
          }
          out->source = puVar6;
          memset(puVar6 + uVar5,0,size + uVar1 * -0x100);
        }
        if (out->source == (uchar *)0x0) {
          return (string *)0x0;
        }
        memcpy(out->source + out->length,source,__n);
        out->source[iVar4] = '\0';
        out->length = iVar4;
      }
      if (out == (string *)0x0) {
        return (string *)0x0;
      }
      psVar3 = add_char_to_string(out,'\n');
      if (psVar3 == (string *)0x0) {
        return (string *)0x0;
      }
      uVar2 = src[1];
      source = puVar7 + 1;
      puVar6 = (uchar *)0x0;
      iVar4 = (int)src - (int)source;
    }
    else {
      if (uVar2 == ' ') {
        puVar6 = src;
      }
      if ((puVar6 != (uchar *)0x0) && (puVar7 = puVar6, maxwidth <= iVar4)) goto split;
      uVar2 = src[1];
    }
    if (uVar2 == '\0') {
      if (*source == '\0') {
        return out;
      }
      psVar3 = add_string_to_string(out,indent);
      if (((psVar3 != (string *)0x0) &&
          (psVar3 = add_to_string(out,source), psVar3 != (string *)0x0)) &&
         (psVar3 = add_char_to_string(out,'\n'), psVar3 != (string *)0x0)) {
        return out;
      }
      return (string *)0x0;
    }
    src = src + 1;
    iVar4 = iVar4 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void smart_config_output_fn
               (string *string,option_elinks *option_elinks,uchar *path,int depth,
               int do_print_comment,int action,int i18n)

{
  string *psVar1;
  uchar *msgid;
  uchar *desc_i18n;
  string indent;
  
  if (option_elinks->type != OPT_ALIAS) {
    if (action == 1) {
      if (((((byte)comments & 2) != 0) && (msgid = option_elinks->desc, do_print_comment != 0)) &&
         (msgid != (uchar *)0x0)) {
        if (i18n != 0) {
          msgid = gettext(msgid);
        }
        psVar1 = init_string(&indent);
        if (psVar1 != (string *)0x0) {
          if (depth != 0) {
            add_xchar_to_string(&indent,' ',depth * indentation);
          }
          psVar1 = add_to_string(&indent,"#  ");
          if (psVar1 != (string *)0x0) {
            wrap_option_desc(string,msgid,&indent,0x50 - indent.length);
          }
          done_string(&indent);
        }
      }
    }
    else if (action < 2) {
      if ((action == 0) && (((byte)comments & 1) != 0)) {
        if (depth != 0) {
          add_xchar_to_string(string,' ',depth * indentation);
        }
        add_to_string(string,"## ");
        if (path != (uchar *)0x0) {
          add_to_string(string,path);
          add_char_to_string(string,'.');
        }
        add_to_string(string,option_elinks->name);
        add_char_to_string(string,' ');
        add_to_string(string,option_types[option_elinks->type].help_str);
        add_char_to_string(string,'\n');
      }
    }
    else {
      if (action == 2) {
        if (depth != 0) {
          add_xchar_to_string(string,' ',depth * indentation);
        }
        if (*(char *)&option_elinks->flags < '\0') {
          add_to_string(string,"un");
        }
        add_to_string(string,"set ");
        if (path != (uchar *)0x0) {
          add_to_string(string,path);
          add_char_to_string(string,'.');
        }
        add_to_string(string,option_elinks->name);
        if (-1 < *(char *)&option_elinks->flags) {
          add_to_string(string," = ");
          if ((assert_failed == 0) &&
             (assert_failed =
                   (int)(option_types[option_elinks->type].write ==
                        (_func_void_option_elinks_ptr_string_ptr *)0x0), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
            errline = 0x38a;
            elinks_internal((uchar *)"assertion option_types[option->type].write failed!");
          }
          (*option_types[option_elinks->type].write)(option_elinks,string);
        }
        add_char_to_string(string,'\n');
        if (do_print_comment == 0) {
          return;
        }
      }
      else {
        if (action != 3) {
          return;
        }
        if (1 < do_print_comment) {
          return;
        }
      }
      add_char_to_string(string,'\n');
    }
  }
  return;
}



// WARNING: Unknown calling convention

uchar * read_config_file(uchar *name)

{
  int iVar1;
  uint uVar2;
  int fd_00;
  int fd;
  string *psVar3;
  size_t __n;
  uchar *puVar4;
  size_t oldsize;
  uint uVar5;
  size_t newsize;
  uint size;
  ssize_t r;
  int in_GS_OFFSET;
  string string;
  uchar cfg_buffer [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  fd_00 = open64((char *)name,0x100);
  if (-1 < fd_00) {
    set_bin(fd_00);
    psVar3 = init_string(&string);
    if (psVar3 != (string *)0x0) {
LAB_0806f33b:
      do {
        __n = read(fd_00,cfg_buffer,0x400);
        if ((int)__n < 1) goto LAB_0806f3ef;
        puVar4 = cfg_buffer;
        do {
          if (*puVar4 == '\0') {
            *puVar4 = ' ';
          }
          puVar4 = puVar4 + 1;
        } while (puVar4 != cfg_buffer + __n);
        if (assert_failed == 0) {
          assert_failed = 0;
          iVar1 = __n + string.length;
          uVar2 = string.length + 0xffU >> 8;
          uVar5 = string.length + 0xffU & 0xffffff00;
          size = iVar1 + 0x100U & 0xffffff00;
          if (uVar5 <= size && size + uVar2 * -0x100 != 0) {
            puVar4 = (uchar *)mem_realloc(string.source,size);
            if (puVar4 == (uchar *)0x0) goto LAB_0806f33b;
            string.source = puVar4;
            memset(puVar4 + uVar5,0,size + uVar2 * -0x100);
          }
          if (string.source != (uchar *)0x0) {
            memcpy(string.source + string.length,cfg_buffer,__n);
            string.source[iVar1] = '\0';
            string.length = iVar1;
          }
          goto LAB_0806f33b;
        }
        assert_failed = 0;
      } while( true );
    }
  }
  puVar4 = (uchar *)0x0;
LAB_0806f300:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return puVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0806f3ef:
  if (__n != 0) {
    done_string(&string);
  }
  close(fd_00);
  puVar4 = string.source;
  goto LAB_0806f300;
}



// WARNING: Unknown calling convention

void parse_config_file(option_elinks *options,uchar *name,uchar *file,string *mirror,
                      int is_system_conf)

{
  bool bVar1;
  size_t sVar2;
  int iVar3;
  ushort **ppuVar4;
  parse_error pVar5;
  option_value *poVar6;
  uchar *puVar7;
  uchar *puVar8;
  uint uVar9;
  uchar uVar10;
  int newlength;
  size_t oldsize;
  size_t newsize_1;
  uint size;
  parse_error err;
  uchar *puVar11;
  parse_handler *handler;
  parse_handler *ppVar12;
  size_t newsize;
  byte *pbVar13;
  uint uVar14;
  conf_parsing_state state;
  
  state.filename = (uchar *)0x0;
  state.pos.line = 1;
  state.pos.look = file;
  state.mirrored = file;
  if ((mirror == (string *)0x0) && (poVar6 = get_opt_(), 0 < poVar6->number)) {
    state.filename = name;
  }
  bVar1 = false;
  while ((state.pos.look != (uchar *)0x0 && (*state.pos.look != '\0'))) {
    skip_white(&state.pos);
    puVar11 = state.mirrored;
    puVar8 = state.mirrored;
    if (mirror != (string *)0x0) {
      if (assert_failed == 0) {
        sVar2 = (int)state.pos.look - (int)state.mirrored;
        if ((state.mirrored == (uchar *)0x0) || ((int)sVar2 < 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_0806f4e0;
        }
        else {
          assert_failed = 0;
        }
        puVar8 = state.pos.look;
        if (sVar2 != 0) {
          iVar3 = sVar2 + mirror->length;
          uVar9 = mirror->length + 0xffU & 0xffffff00;
          uVar14 = iVar3 + 0x100U & 0xffffff00;
          if (uVar9 < uVar14) {
            puVar7 = (uchar *)mem_realloc(mirror->source,uVar14);
            puVar8 = state.pos.look;
            if (puVar7 == (uchar *)0x0) goto LAB_0806f4f3;
            mirror->source = puVar7;
            memset(puVar7 + uVar9,0,uVar14 - uVar9);
          }
          puVar8 = state.pos.look;
          if (mirror->source != (uchar *)0x0) {
            memcpy(mirror->source + mirror->length,puVar11,sVar2);
            mirror->source[iVar3] = '\0';
            mirror->length = iVar3;
            puVar8 = state.pos.look;
          }
        }
      }
      else {
LAB_0806f4e0:
        assert_failed = 0;
        puVar8 = state.pos.look;
      }
    }
LAB_0806f4f3:
    state.mirrored = puVar8;
    if (*state.pos.look == '\0') break;
    if (assert_failed == 0) {
      if ((mirror == (string *)0x0) || (state.pos.look == state.mirrored)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
        errline = 0x23e;
        elinks_internal((uchar *)
                        "assertion mirror == NULL || state->mirrored == state->pos.look failed!");
        if (assert_failed != 0) goto LAB_0806f6b8;
      }
      puVar8 = state.pos.look;
      puVar11 = "set";
      ppVar12 = parse_handlers;
      do {
        sVar2 = strlen((char *)puVar11);
        iVar3 = strncmp((char *)puVar8,(char *)puVar11,sVar2);
        if (iVar3 == 0) {
          ppuVar4 = __ctype_b_loc();
          pbVar13 = puVar8 + sVar2;
          if ((*(byte *)((int)*ppuVar4 + (uint)*pbVar13 * 2 + 1) & 0x20) != 0) {
            state.pos.look = pbVar13;
            pVar5 = (*ppVar12->handler)(options,&state,mirror,is_system_conf);
            puVar11 = state.mirrored;
            if (mirror != (string *)0x0) {
              if (assert_failed == 0) {
                sVar2 = (int)state.pos.look - (int)state.mirrored;
                if ((state.mirrored == (uchar *)0x0) || ((int)sVar2 < 0)) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 0xff;
                  elinks_internal((uchar *)
                                  "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                 );
                  if (assert_failed != 0) goto LAB_0806f752;
                }
                else {
                  assert_failed = 0;
                }
                if (sVar2 != 0) {
                  iVar3 = sVar2 + mirror->length;
                  uVar14 = mirror->length + 0xff;
                  uVar9 = uVar14 >> 8;
                  uVar14 = uVar14 & 0xffffff00;
                  size = iVar3 + 0x100U & 0xffffff00;
                  if (uVar14 <= size && size + uVar9 * -0x100 != 0) {
                    puVar8 = (uchar *)mem_realloc(mirror->source,size);
                    if (puVar8 == (uchar *)0x0) goto LAB_0806f818;
                    mirror->source = puVar8;
                    memset(puVar8 + uVar14,0,size + uVar9 * -0x100);
                  }
                  if (mirror->source != (uchar *)0x0) {
                    memcpy(mirror->source + mirror->length,puVar11,sVar2);
                    mirror->source[iVar3] = '\0';
                    mirror->length = iVar3;
                  }
                }
LAB_0806f818:
                state.mirrored = state.pos.look;
              }
              else {
LAB_0806f752:
                assert_failed = 0;
                state.mirrored = state.pos.look;
              }
            }
            goto LAB_0806f5c4;
          }
        }
        ppVar12 = ppVar12 + 1;
        puVar11 = ppVar12->command;
      } while (puVar11 != (uchar *)0x0);
      pVar5 = show_parse_error(&state,ERROR_COMMAND);
    }
    else {
LAB_0806f6b8:
      assert_failed = 0;
      pVar5 = show_parse_error(&state,ERROR_PARSE);
    }
LAB_0806f5c4:
    if (pVar5 != ERROR_NONE) {
      if (pVar5 < ERROR_OPTION) {
        while (puVar11 = state.mirrored, uVar10 = *state.pos.look, uVar10 != '#') {
          while( true ) {
            if ((uVar10 == '\0') || (uVar10 == '\n')) goto LAB_0806f685;
            if ((uVar10 == '\'') || (uVar10 == '\"')) break;
            state.pos.look = state.pos.look + 1;
            uVar10 = *state.pos.look;
            if (uVar10 == '#') goto LAB_0806f685;
          }
          skip_quoted(&state.pos);
        }
LAB_0806f685:
        if (mirror != (string *)0x0) {
          if (assert_failed == 0) {
            sVar2 = (int)state.pos.look - (int)state.mirrored;
            if ((state.mirrored == (uchar *)0x0) || ((int)sVar2 < 0)) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) goto LAB_0806f6a4;
            }
            else {
              assert_failed = 0;
            }
            if (sVar2 != 0) {
              iVar3 = sVar2 + mirror->length;
              uVar9 = mirror->length + 0xffU & 0xffffff00;
              uVar14 = iVar3 + 0x100U & 0xffffff00;
              if (uVar9 < uVar14) {
                puVar8 = (uchar *)mem_realloc(mirror->source,uVar14);
                if (puVar8 == (uchar *)0x0) goto LAB_0806f7dd;
                mirror->source = puVar8;
                memset(puVar8 + uVar9,0,uVar14 - uVar9);
              }
              if (mirror->source != (uchar *)0x0) {
                memcpy(mirror->source + mirror->length,puVar11,sVar2);
                mirror->source[iVar3] = '\0';
                mirror->length = iVar3;
              }
            }
LAB_0806f7dd:
            state.mirrored = state.pos.look;
          }
          else {
LAB_0806f6a4:
            assert_failed = 0;
            state.mirrored = state.pos.look;
          }
        }
      }
      bVar1 = true;
    }
  }
  if ((bVar1) && (state.filename != (uchar *)0x0)) {
    fputc(7,stderr);
    poVar6 = get_opt_();
    if ((poVar6->tree == (list_head_elinks *)0x0) &&
       (poVar6 = get_opt_(), poVar6->tree == (list_head_elinks *)0x0)) {
      sleep(1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int load_config_file(uchar *prefix,uchar *name,option_elinks *options,string *mirror,
                    int is_system_conf)

{
  uchar *name_00;
  uchar *file;
  uchar *config_str;
  uchar *config_file;
  
  name_00 = straconcat(prefix,&DAT_08132419,name,0);
  if (name_00 == (uchar *)0x0) {
    return 1;
  }
  file = read_config_file(name_00);
  if (file == (uchar *)0x0) {
    mem_free(name_00);
    name_00 = straconcat(prefix,&DAT_08132419,&DAT_0813015e,name,0);
    if (name_00 == (uchar *)0x0) {
      return 2;
    }
    file = read_config_file(name_00);
    if (file == (uchar *)0x0) {
      mem_free(name_00);
      return 3;
    }
  }
  parse_config_file(options,name_00,file,mirror,is_system_conf);
  mem_free(file);
  mem_free(name_00);
  return 0;
}



// WARNING: Unknown calling convention

uchar * create_config_string(uchar *prefix,uchar *name,option_elinks *options)

{
  _func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *p_Var1;
  int iVar2;
  option_value *poVar3;
  string *psVar4;
  int iVar5;
  char *pcVar6;
  int savestyle;
  int i18n;
  int origlen;
  string tmpstring;
  string config;
  
  poVar3 = get_opt_();
  p_Var1 = poVar3->command;
  poVar3 = get_opt_();
  iVar2 = poVar3->number;
  psVar4 = init_string(&config);
  if (psVar4 == (string *)0x0) {
    return (uchar *)0x0;
  }
  prepare_mustsave_flags((options->value).tree,(uint)(p_Var1 + -1 < (code *)0x2));
  if (((p_Var1 != (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x2) &&
      (iVar5 = load_config_file(prefix,name,options,&config,0), iVar5 == 0)) && (config.length != 0)
     ) goto LAB_0806fcd7;
  add_to_string(&config,(uchar *)"## ELinks 0.12pre5 configuration file\n\n");
  if ((assert_failed == 0) &&
     (assert_failed =
           (int)((_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x3 < p_Var1),
     assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
    errline = 0x3bf;
    elinks_internal((uchar *)"assertion savestyle >= 0 && savestyle <= 3 failed!");
  }
  if (p_Var1 == (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x1) {
LAB_0806fde8:
    pcVar6 = 
    "## This is ELinks configuration file. You can edit it manually,\n## if you wish so; this file is edited by ELinks when you save\n## options through UI, however only option values will be altered\n## and missing options will be added at the end of file; if option\n## is not written in this file, but in some file included from it,\n## it is NOT counted as missing. Note that all your formatting,\n## own comments and so on will be kept as-is.\n"
    ;
joined_r0x0806fe67:
    if (iVar2 != 0) {
      pcVar6 = (char *)gettext((uchar *)pcVar6);
    }
    add_to_string(&config,(uchar *)pcVar6);
  }
  else if ((int)p_Var1 < 2) {
    if (p_Var1 == (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x0) {
      pcVar6 = 
      "## This is ELinks configuration file. You can edit it manually,\n## if you wish so; this file is edited by ELinks when you save\n## options through UI, however only option values will be altered\n## and all your formatting, own comments etc will be kept as-is.\n"
      ;
      goto joined_r0x0806fe67;
    }
  }
  else {
    if (p_Var1 == (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x2) {
      pcVar6 = 
      "## This is ELinks configuration file. You can edit it manually,\n## if you wish so, but keep in mind that this file is overwritten\n## by ELinks when you save options through UI and you are out of\n## luck with your formatting and own comments then, so beware.\n"
      ;
      goto joined_r0x0806fe67;
    }
    if (p_Var1 == (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x3)
    goto LAB_0806fde8;
  }
  add_to_string(&config,"##\n");
  pcVar6 = 
  "## Obviously, if you don\'t like what ELinks is going to do with\n## this file, you can change it by altering the config.saving_style\n## option. Come on, aren\'t we friendly guys after all?\n"
  ;
  if (iVar2 != 0) {
    pcVar6 = (char *)gettext((uchar *)
                             "## Obviously, if you don\'t like what ELinks is going to do with\n## this file, you can change it by altering the config.saving_style\n## option. Come on, aren\'t we friendly guys after all?\n"
                            );
  }
  add_to_string(&config,(uchar *)pcVar6);
LAB_0806fcd7:
  if (p_Var1 != (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x0) {
    poVar3 = get_opt_();
    indentation = poVar3->number;
    poVar3 = get_opt_();
    comments = poVar3->number;
    psVar4 = init_string(&tmpstring);
    if (psVar4 != (string *)0x0) {
      pcVar6 = "Automatically saved options\n";
      if (iVar2 != 0) {
        pcVar6 = (char *)gettext((uchar *)"Automatically saved options\n");
      }
      add_cfg_header_to_string(&tmpstring,(uchar *)pcVar6);
      iVar5 = tmpstring.length;
      smart_config_string(&tmpstring,2,iVar2,(options->value).tree,(uchar *)0x0,0,
                          smart_config_output_fn);
      if (iVar5 < tmpstring.length) {
        add_string_to_string(&config,&tmpstring);
      }
      done_string(&tmpstring);
      psVar4 = init_string(&tmpstring);
      if (psVar4 != (string *)0x0) {
        pcVar6 = "Automatically saved keybindings\n";
        if (iVar2 != 0) {
          pcVar6 = (char *)gettext((uchar *)"Automatically saved keybindings\n");
        }
        add_cfg_header_to_string(&tmpstring,(uchar *)pcVar6);
        iVar2 = tmpstring.length;
        bind_config_string(&tmpstring);
        if (iVar2 < tmpstring.length) {
          add_string_to_string(&config,&tmpstring);
        }
        done_string(&tmpstring);
      }
    }
  }
  return config.source;
}



// WARNING: Unknown calling convention

int write_config(terminal *term)

{
  uchar *str;
  option_elinks *options;
  option_value *poVar1;
  uchar *s;
  size_t sVar2;
  int stdio_error;
  int ret;
  int name_has_slash;
  secure_save_info *ssi_00;
  undefined1 *puVar3;
  uchar *slash;
  int prefix_has_slash;
  uchar *puVar4;
  uchar *config_file;
  secure_save_info *ssi;
  uchar *cfg_str;
  bool bVar5;
  bool bVar6;
  
  if ((assert_failed == 0) && (assert_failed = (int)(term == (terminal *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
    errline = 0x42d;
    elinks_internal((uchar *)"assertion term failed!");
  }
  options = config_options;
  if (elinks_home == (uchar *)0x0) {
    poVar1 = get_opt_();
    write_config_dialog(term,poVar1->string,1,0);
    return -1;
  }
  poVar1 = get_opt_();
  str = elinks_home;
  puVar4 = poVar1->string;
  s = create_config_string(elinks_home,puVar4,options);
  sVar2 = strlen((char *)str);
  bVar6 = false;
  if (sVar2 == 0) {
    bVar5 = *puVar4 == '/';
LAB_0806ff54:
    puVar3 = &DAT_08132419;
    if (!bVar5) goto LAB_0806ff62;
  }
  else {
    bVar6 = str[sVar2 - 1] == '/';
    bVar5 = *puVar4 == '/';
    if (!bVar6) goto LAB_0806ff54;
  }
  puVar3 = &DAT_0812e3d8;
LAB_0806ff62:
  stdio_error = -1;
  if (s != (uchar *)0x0) {
    if (bVar6) {
      puVar4 = puVar4 + bVar5;
    }
    puVar4 = straconcat(str,puVar3,puVar4,0);
    stdio_error = -1;
    if (puVar4 != (uchar *)0x0) {
      ssi_00 = secure_open(puVar4);
      stdio_error = -1;
      if (ssi_00 != (secure_save_info *)0x0) {
        secure_fputs(ssi_00,(char *)s);
        stdio_error = secure_close(ssi_00);
        if (stdio_error == 0) {
          untouch_options((options->value).tree);
        }
      }
      write_config_dialog(term,puVar4,secsave_errno,stdio_error);
      mem_free(puVar4);
    }
    mem_free(s);
  }
  return stdio_error;
}



// WARNING: Unknown calling convention

void load_config(void)

{
  uchar *name;
  option_elinks *options;
  option_value *poVar1;
  uchar *prefix;
  
  options = config_options;
  poVar1 = get_opt_();
  name = poVar1->string;
  load_config_file((uchar *)"/etc/elinks",name,options,(string *)0x0,1);
  prefix = elinks_home;
  if (elinks_home == (uchar *)0x0) {
    prefix = "";
  }
  load_config_file(prefix,name,options,(string *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

parse_error
parse_include(option_elinks *opt_tree,conf_parsing_state *state,string *mirror,int is_system_conf)

{
  string *psVar1;
  uchar *name;
  uchar *fname;
  uchar *puVar2;
  int iVar3;
  parse_error pVar4;
  string dumbstring;
  
  psVar1 = init_string(&dumbstring);
  if (psVar1 == (string *)0x0) {
    pVar4 = show_parse_error(state,ERROR_NOMEM);
  }
  else {
    skip_white(&state->pos);
    puVar2 = (state->pos).look;
    if (*puVar2 == '\0') {
      done_string(&dumbstring);
      pVar4 = show_parse_error(state,ERROR_PARSE);
    }
    else {
      iVar3 = (state->pos).line;
      name = str_rd((option_elinks *)0x0,(uchar **)state,&(state->pos).line);
      if (name == (uchar *)0x0) {
        done_string(&dumbstring);
        (state->pos).line = iVar3;
        (state->pos).look = puVar2;
        pVar4 = show_parse_error(state,ERROR_PARSE);
      }
      else {
        psVar1 = (string *)0x0;
        if (mirror != (string *)0x0) {
          psVar1 = &dumbstring;
        }
        puVar2 = "";
        if (*name != '/') {
          puVar2 = elinks_home;
        }
        iVar3 = load_config_file(puVar2,name,opt_tree,psVar1,1);
        if (iVar3 == 0) {
          done_string(&dumbstring);
          mem_free(name);
          pVar4 = ERROR_NONE;
        }
        else {
          done_string(&dumbstring);
          mem_free(name);
          pVar4 = show_parse_error(state,ERROR_VALUE);
        }
      }
    }
  }
  return pVar4;
}



// WARNING: Unknown calling convention

void lock_option(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_option(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_option_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

listbox_item * get_option_root(listbox_item *item)

{
  option_elinks *poVar1;
  
  poVar1 = *(option_elinks **)((int)item->udata + 0x2c);
  if ((poVar1 != config_options) && (poVar1 != (option_elinks *)0x0)) {
    return poVar1->box_item;
  }
  return (listbox_item *)0x0;
}



// WARNING: Unknown calling convention

int can_delete_option(listbox_item *item)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = *(int *)((int)item->udata + 0x2c);
  uVar2 = 0;
  if (iVar1 != 0) {
    uVar2 = *(uint *)(iVar1 + 0x10) & 2;
  }
  return uVar2;
}



// WARNING: Unknown calling convention

void lock_keybinding(listbox_item *item)

{
  int *piVar1;
  
  if (item->depth != 2) {
    return;
  }
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_keybinding(listbox_item *item)

{
  int *piVar1;
  
  if (item->depth != 2) {
    return;
  }
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_keybinding_used(listbox_item *item)

{
  if (item->depth != 2) {
    return 0;
  }
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

int can_delete_keybinding(listbox_item *item)

{
  return (uint)(item->depth == 2);
}



// WARNING: Unknown calling convention

listbox_item * get_keybinding_action_box_item(keymap_id keymap_id,action_id_T action_id)

{
  listbox_item *plVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (listbox_item *)0x0;
  }
  assert_failed = (int)(0x7f < action_id);
  if (assert_failed == 0) {
    plVar1 = action_box_items[keymap_id][action_id];
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
    errline = 0x21f;
    elinks_internal((uchar *)"assertion action_id < ACTION_BOX_SIZE failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (listbox_item *)0x0;
    }
    plVar1 = action_box_items[keymap_id][action_id];
  }
  return plVar1;
}



// WARNING: Unknown calling convention

listbox_item * get_keybinding_root(listbox_item *item)

{
  listbox_item *plVar1;
  keybinding *kb;
  
  plVar1 = (listbox_item *)0x0;
  if (item->depth != 0) {
    if (item->depth == 1) {
      return keymap_box_item[*(int *)((int)item->udata + 8)];
    }
    plVar1 = get_keybinding_action_box_item
                       (*(keymap_id *)((int)item->udata + 0xc),
                        *(action_id_T *)((int)item->udata + 0x10));
  }
  return plVar1;
}



// WARNING: Unknown calling convention

void delete_keybinding_item(listbox_item *item,int last)

{
  keybinding *keybinding_00;
  keybinding *keybinding;
  
  keybinding_00 = (keybinding *)item->udata;
  if (assert_failed == 0) {
    if ((item->depth == 2) && ((keybinding_00->object).refcount == 0)) {
      assert_failed = 0;
    }
    else {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
      errline = 0x2da;
      elinks_internal((uchar *)"assertion item->depth == 2 && !is_object_used(keybinding) failed!");
    }
  }
  free_keybinding(keybinding_00);
  return;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_keybinding_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  string *psVar2;
  uchar *puVar3;
  uchar *puVar4;
  uchar *puVar5;
  uchar *action;
  string info;
  
  pvVar1 = item->udata;
  if ((1 < item->depth) && (item->type != BI_FOLDER)) {
    psVar2 = init_string(&info);
    if (psVar2 != (string *)0x0) {
      puVar3 = get_action_name(*(keymap_id *)((int)pvVar1 + 0xc),
                               *(action_id_T *)((int)pvVar1 + 0x10));
      puVar4 = get_keymap_name(*(keymap_id *)((int)pvVar1 + 0xc));
      puVar5 = _((uchar *)"Keystroke",term);
      add_format_to_string(&info,"%s: ",puVar5);
      add_keystroke_to_string(&info,(term_event_keyboard *)((int)pvVar1 + 0x14),0);
      puVar5 = _((uchar *)"Action",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar5,puVar3);
      puVar3 = _((uchar *)"Keymap",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar3,puVar4);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

widget_handler_status_T
push_kbdbind_save_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  write_config(dlg_data->win->term);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T
push_kbdbind_toggle_display_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  keybinding_text_toggle = (int)(keybinding_text_toggle == 0);
  redraw_dialog(dlg_data,0);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T check_option_name(dialog_data *dlg_data,widget_data *widget_data)

{
  uchar uVar1;
  uchar *p;
  uchar *puVar2;
  
  puVar2 = widget_data->cdata;
  uVar1 = *puVar2;
  while( true ) {
    if (uVar1 == '\0') {
      return EVENT_PROCESSED;
    }
    if ((((0x19 < (byte)(uVar1 + 0x9f)) && (0x19 < (byte)(uVar1 + 0xbf))) &&
        (9 < (byte)(uVar1 - 0x30))) && ((uVar1 != '_' && (uVar1 != '-')))) break;
    puVar2 = puVar2 + 1;
    uVar1 = *puVar2;
  }
  info_box(dlg_data->win->term,0,(uchar *)"Bad string",ALIGN_CENTER,
           (uchar *)
           "Option names may only contain alpha-numeric characters\nin addition to \'_\' and \'-\'."
          );
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T
push_kbdbind_add_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  terminal *term_00;
  listbox_item *plVar1;
  void *pvVar2;
  listbox_data *plVar3;
  listbox_data *box;
  terminal **p;
  action *action;
  terminal *keymap_id;
  uchar *puVar4;
  uchar *puVar5;
  memory_list *ml;
  keybinding *keybinding;
  listbox_item *item;
  uchar *text;
  kbdbind_add_hop *hop;
  terminal *term;
  
  term_00 = dlg_data->win->term;
  plVar3 = get_listbox_widget_data(dlg_data->widgets_data);
  plVar1 = plVar3->sel;
  if ((plVar1 == (listbox_item *)0x0) || (plVar1->depth == 0)) {
    info_box(term_00,0,(uchar *)"Add keybinding",ALIGN_CENTER,(uchar *)"Need to select an action.");
  }
  else {
    p = (terminal **)mem_calloc(1,0x18);
    if (p != (terminal **)0x0) {
      *p = term_00;
      p[5] = (terminal *)dlg_data->widgets_data;
      if (plVar1->depth == 2) {
        pvVar2 = plVar1->udata;
        p[1] = *(terminal **)((int)pvVar2 + 0x10);
        keymap_id = *(terminal **)((int)pvVar2 + 0xc);
        p[2] = keymap_id;
      }
      else {
        pvVar2 = plVar1->udata;
        p[1] = *(terminal **)((int)pvVar2 + 4);
        keymap_id = *(terminal **)((int)pvVar2 + 8);
        p[2] = keymap_id;
      }
      puVar4 = get_keymap_name((keymap_id)keymap_id);
      puVar5 = get_action_name((keymap_id)p[2],(action_id_T)p[1]);
      puVar4 = msg_text(term_00,(uchar *)
                                "Action: %s\nKeymap: %s\n\nKeystroke should be written in the format: [Shift-][Ctrl-][Alt-]Key\nKey: a,b,c,...,1,2,3,...,Space,Up,PageDown,Tab,Enter,Insert,F5,...\n\nKeystroke"
                        ,puVar5,puVar4);
      ml = getml(p,puVar4,0);
      input_dialog(term_00,ml,(uchar *)"Add keybinding",puVar4,p,(input_history *)0x0,0x400,"",0,0,
                   check_keystroke,really_add_keybinding,(done_handler_T *)0x0);
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_add_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  terminal *term;
  listbox_data *plVar1;
  listbox_data *box;
  void **p;
  memory_list *ml;
  listbox_item *plVar2;
  listbox_item *item;
  void *pvVar3;
  option_elinks *option_elinks;
  
  term = dlg_data->win->term;
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  plVar2 = plVar1->sel;
  if ((((plVar2 == (listbox_item *)0x0) || (pvVar3 = plVar2->udata, pvVar3 == (void *)0x0)) ||
      (((plVar2->type == BI_FOLDER && ((plVar2->field_0x18 & 1) == 0)) &&
       ((plVar2 = (*plVar1->ops->get_root)(plVar2), plVar2 == (listbox_item *)0x0 ||
        (pvVar3 = plVar2->udata, pvVar3 == (void *)0x0)))))) ||
     (((*(byte *)((int)pvVar3 + 0x10) & 2) == 0 &&
      ((pvVar3 = *(void **)((int)pvVar3 + 0x2c), pvVar3 == (void *)0x0 ||
       ((*(byte *)((int)pvVar3 + 0x10) & 2) == 0)))))) {
    info_box(term,0,(uchar *)"Add option",ALIGN_CENTER,(uchar *)"Cannot add an option here.");
  }
  else {
    p = (void **)mem_alloc(8);
    if (p != (void **)0x0) {
      *p = pvVar3;
      p[1] = dlg_data->widgets_data;
      ml = getml(p,0);
      input_dialog(term,ml,(uchar *)"Add option","Name",p,(input_history *)0x0,0x400,"",0,0,
                   check_option_name,add_option_to_tree,(done_handler_T *)0x0);
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void really_really_add_keybinding(void *data)

{
  keybinding *pkVar1;
  keybinding *keybinding;
  
  if ((assert_failed == 0) && (assert_failed = (int)(data == (void *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
    errline = 0x308;
    elinks_internal((uchar *)"assertion hop failed!");
  }
  pkVar1 = add_keybinding(*(keymap_id *)((int)data + 8),*(action_id_T *)((int)data + 4),
                          (term_event_keyboard *)((int)data + 0xc),-1);
  if ((pkVar1 != (keybinding *)0x0) && (pkVar1->box_item != (listbox_item *)0x0)) {
    listbox_sel(*(widget_data **)((int)data + 0x14),pkVar1->box_item);
  }
  return;
}



// WARNING: Unknown calling convention

void really_add_keybinding(void *data,uchar *keystroke)

{
  int iVar1;
  terminal **p;
  kbdbind_add_hop *new_hop;
  string *psVar2;
  uchar *puVar3;
  memory_list *ml;
  string canonical;
  int local_20 [4];
  
  iVar1 = keybinding_exists(*(keymap_id *)((int)data + 8),(term_event_keyboard *)((int)data + 0xc),
                            local_20);
  if ((iVar1 == 0) || (local_20[0] == 0)) {
    really_really_add_keybinding(data);
  }
  else if (local_20[0] != *(int *)((int)data + 4)) {
    p = (terminal **)mem_alloc(0x18);
    if (p != (terminal **)0x0) {
                    // WARNING: Load size is inaccurate
      *p = *data;
      p[1] = *(terminal **)((int)data + 4);
      p[2] = *(terminal **)((int)data + 8);
      p[3] = *(terminal **)((int)data + 0xc);
      p[4] = *(terminal **)((int)data + 0x10);
      p[5] = *(terminal **)((int)data + 0x14);
      psVar2 = init_string(&canonical);
      if (psVar2 != (string *)0x0) {
        add_keystroke_to_string(&canonical,(term_event_keyboard *)((int)data + 0xc),0);
      }
      puVar3 = get_action_name(*(keymap_id *)((int)data + 8),local_20[0]);
      if (canonical.length != 0) {
        keystroke = canonical.source;
      }
      puVar3 = msg_text(*p,(uchar *)
                           "The keystroke \"%s\" is currently used for \"%s\".\nAre you sure you want to replace it?"
                        ,keystroke,puVar3);
      ml = getml(p,0);
      msg_box(*p,ml,MSGBOX_FREE_TEXT,(uchar *)"Keystroke already used",ALIGN_CENTER,puVar3,p,2,
              &DAT_0812762b,really_really_add_keybinding,1,&DAT_08127627,0,2);
      done_string(&canonical);
    }
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T check_keystroke(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal **pptVar1;
  int iVar2;
  kbdbind_add_hop *hop;
  
  pptVar1 = (terminal **)dlg_data->dlg->udata2;
  iVar2 = parse_keystroke(widget_data->cdata,(term_event_keyboard *)(pptVar1 + 3));
  if (-1 < iVar2) {
    return EVENT_PROCESSED;
  }
  info_box(*pptVar1,0,(uchar *)"Add keybinding",ALIGN_CENTER,(uchar *)"Invalid keystroke.");
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

void delete_option_item(listbox_item *item,int last)

{
  option_elinks *option_elinks_00;
  option_elinks *option_elinks;
  
  option_elinks_00 = (option_elinks *)item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)((option_elinks_00->object).refcount != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
    errline = 0xee;
    elinks_internal((uchar *)"assertion !is_object_used(option) failed!");
  }
  if ((*(byte *)&option_elinks_00->flags & 0x20) == 0) {
    mark_option_as_deleted(option_elinks_00);
    return;
  }
  delete_option(option_elinks_00);
  return;
}



// WARNING: Unknown calling convention

void done_keybinding_listboxes(void)

{
  int **ppiVar1;
  int **ppiVar2;
  undefined *puVar3;
  int **ppiVar4;
  int **ppiVar5;
  xlist_head *head_2;
  undefined4 *puVar6;
  int **ppiVar7;
  xlist_head *head_1;
  xlist_head *head;
  xlist_head *next_1;
  xlist_head *next_2;
  undefined4 *puVar8;
  xlist_head *next;
  bool bVar9;
  int *local_28;
  int **local_20;
  
  local_28 = (int *)keybinding_browser.root.child.next;
  puVar6 = (undefined4 *)keybinding_browser.root.child.next;
  if ((list_head_elinks *)keybinding_browser.root.child.next != &keybinding_browser.root.child) {
    do {
      local_20 = (int **)local_28[2];
      ppiVar5 = (int **)(local_28 + 2);
      ppiVar7 = local_20;
      if (local_20 != ppiVar5) {
        do {
          ppiVar7 = (int **)local_20[2];
          for (ppiVar1 = ppiVar7; ppiVar1 != local_20 + 2; ppiVar1 = (int **)*ppiVar1) {
          }
          for (ppiVar2 = (int **)local_20[3]; ppiVar2 != ppiVar1; ppiVar2 = (int **)ppiVar2[1]) {
          }
          ppiVar2 = (int **)*ppiVar7;
          while (ppiVar4 = ppiVar2, ppiVar7 != ppiVar1) {
            ppiVar4[1] = ppiVar7[1];
            *ppiVar7[1] = (int)*ppiVar7;
            mem_free(ppiVar7);
            ppiVar2 = (int **)*ppiVar4;
            ppiVar7 = ppiVar4;
          }
          local_20 = (int **)*local_20;
        } while (local_20 != ppiVar5);
        local_20 = (int **)local_28[2];
        ppiVar7 = local_20;
      }
      for (; local_20 != ppiVar5; local_20 = (int **)*local_20) {
      }
      for (ppiVar5 = (int **)local_28[3]; ppiVar5 != local_20; ppiVar5 = (int **)ppiVar5[1]) {
      }
      ppiVar5 = (int **)*ppiVar7;
      while (ppiVar1 = ppiVar5, ppiVar7 != local_20) {
        ppiVar1[1] = ppiVar7[1];
        *ppiVar7[1] = (int)*ppiVar7;
        mem_free(ppiVar7);
        ppiVar5 = (int **)*ppiVar1;
        ppiVar7 = ppiVar1;
      }
      local_28 = (int *)*local_28;
      puVar6 = (undefined4 *)keybinding_browser.root.child.next;
    } while (local_28 != (int *)0x8138268);
  }
  for (; puVar3 = (undefined *)keybinding_browser.root.child.prev,
      (list_head_elinks *)puVar6 != &keybinding_browser.root.child; puVar6 = (undefined4 *)*puVar6)
  {
  }
  for (; (list_head_elinks *)puVar3 != &keybinding_browser.root.child;
      puVar3 = *(undefined **)(puVar3 + 4)) {
  }
                    // WARNING: Load size is inaccurate
  puVar6 = (undefined4 *)keybinding_browser.root.child.next;
  puVar8 = *keybinding_browser.root.child.next;
  if ((list_head_elinks *)keybinding_browser.root.child.next != &keybinding_browser.root.child) {
    do {
      puVar8[1] = puVar6[1];
      *(undefined4 *)puVar6[1] = *puVar6;
      mem_free(puVar6);
      bVar9 = (list_head_elinks *)puVar8 != &keybinding_browser.root.child;
      puVar6 = puVar8;
      puVar8 = (undefined4 *)*puVar8;
    } while (bVar9);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_range_string(option_elinks *option_elinks)

{
  string *psVar1;
  uchar *puVar2;
  string info;
  
  psVar1 = init_string(&info);
  puVar2 = (uchar *)0x0;
  if (psVar1 != (string *)0x0) {
    if (option_elinks->type == OPT_BOOL) {
      add_to_string(&info,(uchar *)"[0|1]");
      puVar2 = info.source;
    }
    else {
      puVar2 = info.source;
      if (option_elinks->type + ~OPT_BOOL < 2) {
        add_format_to_string(&info,(uchar *)"[%li..%li]",option_elinks->min,option_elinks->max);
        puVar2 = info.source;
      }
    }
  }
  return puVar2;
}



// WARNING: Unknown calling convention

widget_handler_status_T
push_save_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  write_config(dlg_data->win->term);
  update_hierbox_browser(&option_browser);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void add_option_to_tree(void *data,uchar *name)

{
  option_elinks *poVar1;
  option_elinks *old;
  option_elinks *new;
  
                    // WARNING: Load size is inaccurate
  poVar1 = get_opt_rec_real(*data,name);
  if ((poVar1 != (option_elinks *)0x0) && (*(char *)&poVar1->flags < '\0')) {
    delete_option(poVar1);
  }
                    // WARNING: Load size is inaccurate
  poVar1 = get_opt_rec(*data,name);
  if (poVar1 != (option_elinks *)0x0) {
    listbox_sel(*(widget_data **)((int)data + 4),poVar1->box_item);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T check_valid_option(dialog_data *dlg_data,widget_data *widget_data)

{
  terminal *term_00;
  option_elinks *option_elinks_00;
  session *ses;
  uchar *p;
  uchar *chinon;
  int iVar1;
  option_elinks *option_elinks;
  terminal *term;
  int local_24;
  uchar *local_20 [4];
  
  term_00 = dlg_data->win->term;
  option_elinks_00 = (option_elinks *)dlg_data->dlg->udata;
  ses = (session *)dlg_data->dlg->udata2;
  local_20[0] = widget_data->cdata;
  local_24 = 0;
  commandline = 1;
  p = (*option_types[option_elinks_00->type].read)(option_elinks_00,local_20,&local_24);
  if (p != (uchar *)0x0) {
    if (option_types[option_elinks_00->type].set != (_func_int_option_elinks_ptr_uchar_ptr *)0x0) {
      iVar1 = (*option_types[option_elinks_00->type].set)(option_elinks_00,p);
      if (iVar1 != 0) {
        option_changed(ses,option_elinks_00);
        commandline = 0;
        mem_free(p);
        return EVENT_PROCESSED;
      }
    }
    mem_free(p);
  }
  commandline = 0;
  info_box(term_00,0,"Error",ALIGN_LEFT,(uchar *)"Bad option value.");
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

void keybinding_manager(session *ses)

{
  hierbox_browser(&keybinding_browser,ses);
  return;
}



// WARNING: Unknown calling convention

void options_manager(session *ses)

{
  hierbox_browser(&option_browser,ses);
  return;
}



// WARNING: Unknown calling convention

void init_keybinding_listboxes(keymap *keymap_table,action_list *actions)

{
  int iVar1;
  listbox_item *root;
  listbox_item *item;
  listbox_item *plVar2;
  action *act;
  int *data;
  listbox_item *keymap_box;
  keymap *local_28;
  int local_24;
  int local_20;
  
  local_20 = 0;
  local_24 = 0;
  local_28 = keymap_table;
  while (root = add_listbox_item((hierbox_browser *)0x0,&keybinding_browser.root,BI_FOLDER,local_28,
                                 -1), root == (listbox_item *)0x0) {
LAB_0807117b:
    local_20 = local_20 + 8;
    local_24 = local_24 + 1;
    local_28 = local_28 + 1;
    if (local_20 == 0x18) {
      return;
    }
  }
  data = *(int **)((int)&actions->actions + local_20);
  iVar1 = *data;
joined_r0x080710cf:
  if (iVar1 != 0) {
    do {
      if (assert_failed == 0) {
        assert_failed = (int)(0x7f < data[1]);
        if (assert_failed == 0) goto LAB_080710f6;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
        errline = 0x239;
        elinks_internal((uchar *)"assertion act->num < ACTION_BOX_SIZE failed!");
        if (assert_failed == 0) goto LAB_080710f6;
      }
      data = data + 5;
      assert_failed = 0;
      if (*data == 0) break;
    } while( true );
  }
  keymap_box_item[local_24] = root;
  goto LAB_0807117b;
LAB_080710f6:
  if (1 < (uint)data[1]) {
    assert_failed = (int)(data[3] == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
      errline = 0x241;
      elinks_internal((uchar *)"assertion act->desc failed!");
    }
    plVar2 = add_listbox_item((hierbox_browser *)0x0,root,BI_FOLDER,data,-1);
    if (plVar2 != (listbox_item *)0x0) {
      plVar2->field_0x18 = plVar2->field_0x18 | 1;
      action_box_items[local_24][data[1]] = plVar2;
    }
  }
  data = data + 5;
  iVar1 = *data;
  goto joined_r0x080710cf;
}



// WARNING: Unknown calling convention

void disable_success_msgbox(void *dummy)

{
  option_value *poVar1;
  option_elinks *option_elinks;
  
  poVar1 = get_opt_();
  poVar1->tree = (list_head_elinks *)0x0;
  option_elinks = get_opt_rec(config_options,(uchar *)"ui.success_msgbox");
  option_changed((session *)0x0,option_elinks);
  return;
}



// WARNING: Unknown calling convention

void write_config_dialog(terminal *term,uchar *config_file,int secsave_error,int stdio_error)

{
  option_value *poVar1;
  char *pcVar2;
  uchar *p;
  uchar *puVar3;
  uchar *errmsg;
  
  if ((stdio_error == 0) && (secsave_error == 0)) {
    poVar1 = get_opt_();
    if (poVar1->tree != (list_head_elinks *)0x0) {
      puVar3 = msg_text(term,(uchar *)"Options were saved successfully to config file %s.",
                        config_file);
      msg_box(term,(memory_list *)0x0,MSGBOX_FREE_TEXT,(uchar *)"Write config success",ALIGN_CENTER,
              puVar3,(void *)0x0,2,&DAT_081275e4,0,3,"~Do not show anymore",disable_success_msgbox,0
             );
    }
  }
  else {
    puVar3 = secsave_strerror(secsave_error,term);
    if (0 < stdio_error) {
      pcVar2 = strerror(stdio_error);
      p = straconcat(puVar3,&DAT_0812839e,pcVar2,&DAT_0812757c,0);
      if (p != (uchar *)0x0) {
        puVar3 = msg_text(term,(uchar *)"Unable to write to config file %s.\n%s",config_file,p);
        info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Write config error",ALIGN_CENTER,puVar3);
        mem_free(p);
        return;
      }
    }
    puVar3 = msg_text(term,(uchar *)"Unable to write to config file %s.\n%s",config_file,puVar3);
    info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Write config error",ALIGN_CENTER,puVar3);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_option_text(listbox_item *item,terminal *term)

{
  void *pvVar1;
  option_elinks *option_elinks;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  uchar *puVar4;
  int new_charset_1;
  int new_charset_2;
  uchar *codeset;
  uchar *desc;
  
  pvVar1 = item->udata;
  puVar4 = *(uchar **)((int)pvVar1 + 0x28);
  if (puVar4 == (uchar *)0x0) {
    puVar4 = *(uchar **)((int)pvVar1 + 0xc);
  }
  if ((*(byte *)((int)pvVar1 + 0x10) & 8) != 0) {
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext("modified");
    if ((puVar4 != (uchar *)0x0) && (*puVar4 != '\0')) {
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        codeset = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = iVar2;
      }
      puVar4 = gettext(puVar4);
    }
    puVar4 = straconcat(puVar4,&DAT_0812839e,puVar3,&DAT_0812757c,0);
    return puVar4;
  }
  if ((puVar4 != (uchar *)0x0) && (*puVar4 != '\0')) {
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar4 = gettext(puVar4);
  }
  puVar4 = stracpy(puVar4);
  return puVar4;
}



// WARNING: Unknown calling convention

widget_handler_status_T
push_edit_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  terminal *term_00;
  option_elinks *option_elinks;
  option_type oVar1;
  void *pvVar2;
  listbox_data *box;
  listbox_data *plVar3;
  string *psVar4;
  dialog *dlg_00;
  dialog *dlg;
  int iVar5;
  int new_charset_3;
  uchar *puVar6;
  int new_charset_4;
  int new_charset_5;
  uchar *puVar7;
  int new_charset_6;
  uchar *puVar8;
  int new_charset_7;
  int new_charset_8;
  uchar *range;
  int new_charset_2;
  int new_charset_1;
  int new_charset;
  memory_list *ml;
  terminal *term;
  char *pcVar9;
  undefined4 uVar10;
  uchar *local_3c;
  uchar *local_30;
  string tvalue;
  
  term_00 = dlg_data->win->term;
  plVar3 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar3->sel != (listbox_item *)0x0) &&
     (option_elinks = (option_elinks *)plVar3->sel->udata, option_elinks != (option_elinks *)0x0)) {
    oVar1 = option_elinks->type;
    if ((option_types[oVar1].write == (_func_void_option_elinks_ptr_string_ptr *)0x0) ||
       ((option_types[oVar1].read == (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_int_ptr *)0x0
        || (option_types[oVar1].set == (_func_int_option_elinks_ptr_uchar_ptr *)0x0)))) {
      info_box(term_00,0,"Edit",ALIGN_LEFT,
               (uchar *)
               "This option cannot be edited. This means that this is some special option like a folder - try to press a space in order to see its contents."
              );
      return EVENT_PROCESSED;
    }
    pvVar2 = dlg_data->dlg->udata;
    psVar4 = init_string(&tvalue);
    if (psVar4 != (string *)0x0) {
      commandline = 1;
      (*option_types[option_elinks->type].write)(option_elinks,&tvalue);
      commandline = 0;
      dlg_00 = (dialog *)mem_calloc(1,0x514);
      if (dlg_00 == (dialog *)0x0) {
        done_string(&tvalue);
      }
      else {
        if ((term_00 != (terminal *)0x0) &&
           (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
          puVar6 = get_cp_mime_name(iVar5);
          bind_textdomain_codeset("elinks",puVar6);
          current_charset = iVar5;
        }
        puVar6 = gettext("Edit");
        dlg_00->title = puVar6;
        dlg_00->layouter = generic_dialog_layouter;
        dlg_00->udata = option_elinks;
        dlg_00->udata2 = pvVar2;
        safe_strncpy((uchar *)&dlg_00[3].abort,tvalue.source,0x400);
        done_string(&tvalue);
        local_30 = option_types[option_elinks->type].name;
        if ((local_30 != (uchar *)0x0) && (*local_30 != '\0')) {
          if ((term_00 != (terminal *)0x0) &&
             (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
            puVar6 = get_cp_mime_name(iVar5);
            bind_textdomain_codeset("elinks",puVar6);
            current_charset = iVar5;
          }
          local_30 = gettext(local_30);
        }
        if ((term_00 != (terminal *)0x0) &&
           (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
          puVar6 = get_cp_mime_name(iVar5);
          bind_textdomain_codeset("elinks",puVar6);
          current_charset = iVar5;
        }
        puVar7 = gettext("Type");
        puVar6 = option_elinks->name;
        if ((term_00 != (terminal *)0x0) &&
           (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
          puVar8 = get_cp_mime_name(iVar5);
          bind_textdomain_codeset("elinks",puVar8);
          current_charset = iVar5;
        }
        puVar8 = gettext("Name");
        uVar10 = 0;
        pcVar9 = ": ";
        local_3c = straconcat(puVar8,": ",puVar6,&DAT_08131ec3,puVar7,": ",local_30,0);
        puVar6 = option_elinks->desc;
        if (puVar6 == (uchar *)0x0) {
          puVar6 = "N/A";
        }
        if (*puVar6 != '\0') {
          if ((term_00 != (terminal *)0x0) &&
             (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
            puVar8 = get_cp_mime_name(iVar5);
            bind_textdomain_codeset("elinks",puVar8);
            current_charset = iVar5;
          }
          puVar6 = gettext(puVar6);
        }
        if ((term_00 != (terminal *)0x0) &&
           (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
          puVar8 = get_cp_mime_name(iVar5);
          bind_textdomain_codeset("elinks",puVar8);
          current_charset = iVar5;
        }
        puVar8 = gettext((uchar *)"Description");
        puVar6 = straconcat(puVar8,&DAT_081283c0,puVar6,0,puVar7,pcVar9,local_30,uVar10);
        puVar7 = get_range_string(option_elinks);
        local_30 = local_3c;
        if (puVar7 != (uchar *)0x0) {
          if ((*puVar7 != '\0') &&
             (puVar8 = straconcat(local_3c,&DAT_08134f9c,puVar7,0), puVar8 != (uchar *)0x0)) {
            mem_free(local_3c);
            local_3c = puVar8;
          }
          mem_free(puVar7);
          local_30 = local_3c;
        }
        if (local_30 == (uchar *)0x0) {
          if (puVar6 != (uchar *)0x0) {
            mem_free(puVar6);
          }
        }
        else {
          if (puVar6 != (uchar *)0x0) {
            add_dlg_text(dlg_00,local_30,ALIGN_LEFT,0);
            if ((term_00 != (terminal *)0x0) &&
               (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
              puVar7 = get_cp_mime_name(iVar5);
              bind_textdomain_codeset("elinks",puVar7);
              current_charset = iVar5;
            }
            puVar7 = gettext((uchar *)"Value");
            add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar7,0,0,check_valid_option,0x400,
                             &dlg_00[3].abort,(input_history *)0x0,INPFIELD_FLOAT);
            add_dlg_text(dlg_00,puVar6,ALIGN_LEFT,0);
            if ((term_00 != (terminal *)0x0) &&
               (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
              puVar7 = get_cp_mime_name(iVar5);
              bind_textdomain_codeset("elinks",puVar7);
              current_charset = iVar5;
            }
            puVar7 = gettext("~OK");
            add_dlg_button_do(dlg_00,puVar7,1,ok_dialog,(void *)0x0,(done_handler_T *)0x0,
                              (void *)0x0);
            if ((term_00 != (terminal *)0x0) &&
               (iVar5 = get_terminal_codepage(term_00), iVar5 != current_charset)) {
              puVar7 = get_cp_mime_name(iVar5);
              bind_textdomain_codeset("elinks",puVar7);
              current_charset = iVar5;
            }
            puVar7 = gettext((uchar *)"~Cancel");
            add_dlg_button_do(dlg_00,puVar7,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,
                              (void *)0x0);
            if ((assert_failed == 0) &&
               (assert_failed = (int)(dlg_00->number_of_widgets != 5), assert_failed != 0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
              errline = 0x170;
              elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
            }
            ml = getml(dlg_00,local_30,puVar6,0);
            do_dialog(term_00,dlg_00,ml);
            return EVENT_PROCESSED;
          }
          mem_free(local_30);
        }
        mem_free(dlg_00);
      }
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

uchar * get_keybinding_text(listbox_item *item,terminal *term)

{
  uchar **ppuVar1;
  uchar *puVar2;
  int cp_index;
  uchar *codeset;
  string *psVar3;
  int new_charset;
  string info;
  
  ppuVar1 = (uchar **)item->udata;
  if (item->depth == 0) {
    if (keybinding_text_toggle != 0) {
LAB_08071c75:
      puVar2 = *ppuVar1;
      goto LAB_08071c77;
    }
    puVar2 = ppuVar1[2];
  }
  else {
    if (1 < item->depth) {
      psVar3 = init_string(&info);
      if (psVar3 == (string *)0x0) {
        return (uchar *)0x0;
      }
      add_keystroke_to_string(&info,(term_event_keyboard *)(ppuVar1 + 5),0);
      return info.source;
    }
    if (keybinding_text_toggle != 0) goto LAB_08071c75;
    puVar2 = ppuVar1[3];
  }
  if ((puVar2 != (uchar *)0x0) && (*puVar2 != '\0')) {
    if ((term != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
      codeset = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",codeset);
      current_charset = cp_index;
    }
    puVar2 = gettext(puVar2);
  }
LAB_08071c77:
  puVar2 = stracpy(puVar2);
  return puVar2;
}



// WARNING: Unknown calling convention

listbox_match match_option(listbox_item *item,terminal *term,uchar *text)

{
  void *pvVar1;
  listbox_match lVar2;
  char *pcVar3;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  option_elinks *option_elinks;
  int new_charset;
  
  pvVar1 = item->udata;
  lVar2 = LISTBOX_MATCH_IMPOSSIBLE;
  if (*(int *)((int)pvVar1 + 0x14) != 9) {
    pcVar3 = strcasestr(*(char **)((int)pvVar1 + 0xc),(char *)text);
    lVar2 = LISTBOX_MATCH_OK;
    if (pcVar3 == (char *)0x0) {
      msgid = *(uchar **)((int)pvVar1 + 0x28);
      lVar2 = LISTBOX_MATCH_NO;
      if (msgid != (uchar *)0x0) {
        if (*msgid != '\0') {
          if (term != (terminal *)0x0) {
            cp_index = get_terminal_codepage(term);
            if (cp_index != current_charset) {
              codeset = get_cp_mime_name(cp_index);
              bind_textdomain_codeset("elinks",codeset);
              current_charset = cp_index;
            }
          }
          msgid = gettext(msgid);
        }
        pcVar3 = strcasestr((char *)msgid,(char *)text);
        lVar2 = (listbox_match)(pcVar3 == (char *)0x0);
      }
    }
  }
  return lVar2;
}



// WARNING: Unknown calling convention

listbox_match match_keybinding(listbox_item *item,terminal *term,uchar *text)

{
  char *pcVar1;
  int cp_index;
  uchar *codeset;
  uchar *msgid;
  uchar *desc;
  int new_charset;
  
  if (item->depth != 1) {
    return LISTBOX_MATCH_IMPOSSIBLE;
  }
  if (keybinding_text_toggle == 0) {
    msgid = *(uchar **)((int)item->udata + 0xc);
    if (msgid == (uchar *)0x0) {
      return LISTBOX_MATCH_NO;
    }
    if (*msgid != '\0') {
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
      msgid = gettext(msgid);
    }
  }
  else {
                    // WARNING: Load size is inaccurate
    msgid = *item->udata;
  }
  if (msgid == (uchar *)0x0) {
    return LISTBOX_MATCH_NO;
  }
  pcVar1 = strcasestr((char *)msgid,(char *)text);
  return (uint)(pcVar1 == (char *)0x0);
}



// WARNING: Unknown calling convention

uchar * get_option_info(listbox_item *item,terminal *term)

{
  option_elinks *option_elinks;
  string *psVar1;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  int new_charset_1;
  uchar *puVar4;
  int new_charset_2;
  option_type oVar5;
  uchar *range;
  int new_charset_4;
  int new_charset_5;
  int new_charset_6;
  int new_charset_3;
  int new_charset_7;
  uchar *desc;
  uchar *local_30;
  string value;
  string info;
  
  option_elinks = (option_elinks *)item->udata;
  psVar1 = init_string(&info);
  puVar4 = (uchar *)0x0;
  if (psVar1 != (string *)0x0) {
    puVar4 = option_elinks->name;
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext("Name");
    add_format_to_string(&info,"%s: %s",puVar3,puVar4);
    oVar5 = option_elinks->type;
    local_30 = option_types[oVar5].name;
    if ((local_30 != (uchar *)0x0) && (*local_30 != '\0')) {
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      local_30 = gettext(local_30);
      oVar5 = option_elinks->type;
    }
    if (oVar5 == OPT_TREE) {
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"(expand by pressing space)");
      local_30 = straconcat(local_30,&DAT_08134f9c,puVar4,0);
    }
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar2;
    }
    puVar4 = gettext("Type");
    add_format_to_string(&info,(uchar *)"\n%s: %s",puVar4,local_30);
    oVar5 = option_elinks->type;
    if (oVar5 == OPT_TREE) {
      mem_free(local_30);
      oVar5 = option_elinks->type;
    }
    if (option_types[oVar5].write != (_func_void_option_elinks_ptr_string_ptr *)0x0) {
      psVar1 = init_string(&value);
      if (psVar1 == (string *)0x0) {
        done_string(&info);
        return (uchar *)0x0;
      }
      (*option_types[option_elinks->type].write)(option_elinks,&value);
      puVar4 = get_range_string(option_elinks);
      if (puVar4 != (uchar *)0x0) {
        if (*puVar4 != '\0') {
          add_to_string(&info," ");
          add_to_string(&info,puVar4);
        }
        mem_free(puVar4);
      }
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"Value");
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar4,value.source);
      done_string(&value);
      if ((*(byte *)&option_elinks->flags & 8) != 0) {
        if ((term != (terminal *)0x0) &&
           (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
          puVar4 = get_cp_mime_name(iVar2);
          bind_textdomain_codeset("elinks",puVar4);
          current_charset = iVar2;
        }
        puVar4 = gettext((uchar *)
                         "\n\nThis value has been changed since you last saved your configuration.")
        ;
        add_to_string(&info,puVar4);
      }
    }
    puVar3 = option_elinks->desc;
    if (puVar3 == (uchar *)0x0) {
      puVar3 = "N/A";
    }
    puVar4 = info.source;
    if (*puVar3 != '\0') {
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar3 = gettext(puVar3);
      puVar4 = info.source;
      if (*puVar3 != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
          puVar4 = get_cp_mime_name(iVar2);
          bind_textdomain_codeset("elinks",puVar4);
          current_charset = iVar2;
        }
        puVar4 = gettext((uchar *)"Description");
        add_format_to_string(&info,(uchar *)"\n\n%s:\n%s",puVar4,puVar3);
        puVar4 = info.source;
      }
    }
  }
  return puVar4;
}



// WARNING: Unknown calling convention

void done_home(void)

{
  void *p;
  
  if (elinks_home != (uchar *)0x0) {
    mem_free(elinks_home);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * test_confdir(uchar *home,uchar *path,uchar *error_message)

{
  uchar *puVar1;
  uchar *__s;
  size_t sVar2;
  uchar *puVar3;
  uchar *confdir;
  int i;
  int iVar4;
  stat st;
  
  if ((path == (uchar *)0x0) || (*path == '\0')) {
    confdir = (uchar *)0x0;
  }
  else {
    if (((home == (uchar *)0x0) || (*home == '\0')) || (*path == '/')) {
      __s = stracpy(path);
    }
    else {
      __s = straconcat(home,&DAT_08132419,path,0);
    }
    confdir = __s;
    if (__s != (uchar *)0x0) {
      sVar2 = strlen((char *)__s);
      iVar4 = sVar2 - 1;
      if ((0 < iVar4) && (__s[sVar2 - 1] == '/')) {
        puVar3 = __s + sVar2;
        do {
          iVar4 = iVar4 + -1;
          if (iVar4 == 0) {
            iVar4 = 0;
            break;
          }
          puVar1 = puVar3 + -2;
          puVar3 = puVar3 + -1;
        } while (*puVar1 == '/');
      }
      __s[iVar4 + 1] = '\0';
      iVar4 = __xstat64(3,(char *)__s,(stat64 *)&st);
      if (iVar4 == 0) {
        if ((st.st_mode & 0xf000) == 0x4000) {
          first_use = 0;
          return __s;
        }
      }
      else {
        iVar4 = mkdir((char *)__s,0x1c0);
        if (iVar4 == 0) {
          return __s;
        }
      }
      if (error_message != (uchar *)0x0) {
        puVar3 = gettext(error_message);
        usrerror(puVar3,path,__s);
        sleep(3);
      }
      confdir = (uchar *)0x0;
      mem_free(__s);
    }
  }
  return confdir;
}



// WARNING: Unknown calling convention

void init_home(void)

{
  uchar *puVar1;
  uchar *puVar2;
  uchar *home;
  size_t sVar3;
  option_value *poVar4;
  uchar *puVar5;
  int i;
  int i_1;
  int iVar6;
  uchar *local_10;
  
  first_use = 1;
  puVar2 = (uchar *)getenv("HOME");
  if ((puVar2 == (uchar *)0x0) || (puVar2 = stracpy(puVar2), puVar2 == (uchar *)0x0)) {
    if ((program.path != (uchar *)0x0) && (puVar2 = stracpy(program.path), puVar2 != (uchar *)0x0))
    {
      sVar3 = strlen((char *)puVar2);
      iVar6 = sVar3 - 1;
      if ((-1 < iVar6) && (puVar2[sVar3 - 1] != '/')) {
        puVar5 = puVar2 + sVar3;
        do {
          iVar6 = iVar6 + -1;
          if (iVar6 == -1) {
            iVar6 = -1;
            break;
          }
          puVar1 = puVar5 + -2;
          puVar5 = puVar5 + -1;
        } while (*puVar1 != '/');
      }
      puVar2[iVar6 + 1] = '\0';
      goto LAB_08072558;
    }
    puVar2 = (uchar *)0x0;
  }
  else {
LAB_08072558:
    sVar3 = strlen((char *)puVar2);
    iVar6 = sVar3 - 1;
    if ((0 < iVar6) && (puVar2[sVar3 - 1] == '/')) {
      puVar5 = puVar2 + sVar3;
      do {
        iVar6 = iVar6 + -1;
        if (iVar6 == 0) {
          iVar6 = 0;
          break;
        }
        puVar1 = puVar5 + -2;
        puVar5 = puVar5 + -1;
      } while (*puVar1 == '/');
    }
    puVar2[iVar6 + 1] = '\0';
  }
  poVar4 = get_opt_();
  local_10 = test_confdir(puVar2,poVar4->string,
                          (uchar *)
                          "Commandline options -config-dir set to %s, but could not create directory %s."
                         );
  if (local_10 == (uchar *)0x0) {
    puVar5 = (uchar *)getenv("ELINKS_CONFDIR");
    local_10 = test_confdir(puVar2,puVar5,
                            (uchar *)"ELINKS_CONFDIR set to %s, but could not create directory %s.")
    ;
    if (((local_10 == (uchar *)0x0) &&
        (local_10 = test_confdir(puVar2,(uchar *)".elinks",(uchar *)0x0), local_10 == (uchar *)0x0))
       && (local_10 = test_confdir(puVar2,"elinks",(uchar *)0x0), local_10 == (uchar *)0x0))
    goto LAB_080725d3;
  }
  add_to_strn(&local_10,"/");
LAB_080725d3:
  if (puVar2 != (uchar *)0x0) {
    mem_free(puVar2);
  }
  elinks_home = local_10;
  if (local_10 == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/home.c";
    errline = 0x9c;
    puVar2 = gettext((uchar *)
                     "Unable to find or create ELinks config directory. Please check if you have $HOME variable set correctly and if you have write permission to your home directory."
                    );
    elinks_error(puVar2);
    sleep(3);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int keybinding_exists(keymap_id keymap_id,term_event_keyboard *kbd,action_id_T *action_id)

{
  keybinding *keybinding;
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
  if (plVar1 != keymaps + keymap_id) {
    do {
      if (((void *)kbd->key == plVar1[2].prev) && (plVar1[3].next == (void *)kbd->modifier)) {
        if (action_id != (action_id_T *)0x0) {
          *action_id = (action_id_T)plVar1[2].next;
        }
        return 1;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != keymaps + keymap_id);
  }
  return 0;
}



// WARNING: Unknown calling convention

action_id_T kbd_action(keymap_id keymap_id,term_event *ev,int *event)

{
  keybinding *keybinding;
  list_head_elinks *plVar1;
  
  if (ev->ev == EVENT_KBD) {
    plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
    if (plVar1 != keymaps + keymap_id) {
      do {
        if ((plVar1[2].prev == (void *)(ev->info).mouse.x) &&
           (plVar1[3].next == (void *)(ev->info).mouse.y)) {
          if ((event != (int *)0x0) && (plVar1[2].next == (void *)0x1)) {
            *event = (int)plVar1[3].prev;
          }
          return (action_id_T)plVar1[2].next;
        }
        plVar1 = (list_head_elinks *)plVar1->next;
      } while (plVar1 != keymaps + keymap_id);
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

keybinding * kbd_ev_lookup(keymap_id keymap_id,term_event_keyboard *kbd,int *event)

{
  keybinding *keybinding;
  keybinding *pkVar1;
  
  pkVar1 = (keybinding *)keymaps[keymap_id].next;
  if (pkVar1 != (keybinding *)(keymaps + keymap_id)) {
    do {
      if ((kbd->key == (pkVar1->kbd).key) && ((pkVar1->kbd).modifier == kbd->modifier)) {
        if (event == (int *)0x0) {
          return pkVar1;
        }
        if (pkVar1->action_id != 1) {
          return pkVar1;
        }
        *event = pkVar1->event;
        return pkVar1;
      }
      pkVar1 = pkVar1->next;
    } while (pkVar1 != (keybinding *)(keymaps + keymap_id));
  }
  return (keybinding *)0x0;
}



// WARNING: Unknown calling convention

void free_keymaps(module *xxx)

{
  list_head_elinks *p;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  xlist_head *head;
  xlist_head *next;
  list_head_elinks *plVar3;
  int local_20;
  
  plVar3 = keymaps;
  done_keybinding_listboxes();
  local_20 = 0;
  do {
    p = (list_head_elinks *)keymaps[local_20].next;
    for (plVar1 = p; plVar1 != plVar3; plVar1 = (list_head_elinks *)plVar1->next) {
    }
    for (plVar1 = (list_head_elinks *)keymaps[local_20].prev; plVar1 != plVar3;
        plVar1 = (list_head_elinks *)plVar1->prev) {
    }
    plVar1 = (list_head_elinks *)p->next;
    while (plVar2 = plVar1, p != plVar3) {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      plVar1 = (list_head_elinks *)plVar2->next;
      p = plVar2;
    }
    plVar3 = plVar3 + 1;
    local_20 = local_20 + 1;
  } while (plVar3 != (list_head_elinks *)&no_autocreate);
  return;
}



// WARNING: Unknown calling convention

uchar * get_keymap_name(keymap_id keymap_id)

{
  if ((assert_failed == 0) && (assert_failed = (int)(2 < (uint)keymap_id), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x12a;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
    return keymap_table[keymap_id].str;
  }
  return keymap_table[keymap_id].str;
}



// WARNING: Unknown calling convention

action * get_action(keymap_id keymap_id,action_id_T action_id)

{
  if ((assert_failed == 0) && (assert_failed = (int)(2 < (uint)keymap_id), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x10d;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  if (-1 < action_id) {
    if (action_id < action_table[keymap_id].num_actions) {
      return action_table[keymap_id].actions + action_id;
    }
  }
  return (action *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_action_name(keymap_id keymap_id,action_id_T action_id)

{
  action *paVar1;
  uchar *puVar2;
  action *action;
  
  paVar1 = get_action(keymap_id,action_id);
  puVar2 = (uchar *)0x0;
  if (paVar1 != (action *)0x0) {
    puVar2 = paVar1->str;
  }
  return puVar2;
}



// WARNING: Unknown calling convention

action_id_T get_action_from_string(keymap_id keymap_id,uchar *str)

{
  uchar *__s1;
  int iVar1;
  action *action;
  action *paVar2;
  
  if ((assert_failed == 0) && (assert_failed = (int)(2 < (uint)keymap_id), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x101;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  paVar2 = action_table[keymap_id].actions;
  __s1 = paVar2->str;
  while( true ) {
    if (__s1 == (uchar *)0x0) {
      return -1;
    }
    iVar1 = strcmp((char *)__s1,(char *)str);
    if (iVar1 == 0) break;
    paVar2 = paVar2 + 1;
    __s1 = paVar2->str;
  }
  return paVar2->num;
}



// WARNING: Unknown calling convention

keybinding * kbd_nm_lookup(keymap_id keymap_id,uchar *name)

{
  keybinding *pkVar1;
  action_id_T aVar2;
  action_id_T action_id;
  keybinding *keybinding;
  
  aVar2 = get_action_from_string(keymap_id,name);
  if (-1 < aVar2) {
    for (pkVar1 = (keybinding *)keymaps[keymap_id].next;
        pkVar1 != (keybinding *)(keymaps + keymap_id); pkVar1 = pkVar1->next) {
      if (aVar2 == pkVar1->action_id) {
        return pkVar1;
      }
    }
  }
  return (keybinding *)0x0;
}



// WARNING: Removing unreachable block (ram,0x08072bf0)
// WARNING: Unknown calling convention

void add_keystroke_to_string(string *str,term_event_keyboard *kbd,int escape)

{
  int __c;
  named_key *pnVar1;
  term_event_modifier_T tVar2;
  named_key *key;
  named_key *pnVar3;
  char *pcVar4;
  char *source;
  uchar *key_string;
  uchar key_buffer [3];
  
  key_buffer[0] = '\\';
  key_buffer[1] = 'x';
  key_buffer[2] = '\0';
  if (kbd->key != -1) {
    tVar2 = kbd->modifier;
    if ((tVar2 & KBD_MOD_SHIFT) != KBD_MOD_NONE) {
      add_to_string(str,(uchar *)"Shift-");
      tVar2 = kbd->modifier;
    }
    if ((tVar2 & KBD_MOD_CTRL) != KBD_MOD_NONE) {
      add_to_string(str,(uchar *)"Ctrl-");
      tVar2 = kbd->modifier;
    }
    if ((tVar2 & KBD_MOD_ALT) != KBD_MOD_NONE) {
      add_to_string(str,"Alt-");
    }
    source = "Enter";
    __c = kbd->key;
    pnVar3 = key_table;
    if (__c != -0x100) {
      do {
        source = (char *)pnVar3[1].str;
        if ((uchar *)source == (uchar *)0x0) {
          key_buffer[1] = (char)__c;
          source = (char *)(key_buffer + 1);
          if (escape != 0) {
            pcVar4 = strchr("\'\"\\",__c);
            source = (char *)key_buffer;
            if (pcVar4 == (char *)0x0) {
              source = (char *)(key_buffer + 1);
            }
          }
          break;
        }
        pnVar1 = pnVar3 + 1;
        pnVar3 = pnVar3 + 1;
      } while (pnVar1->num != __c);
    }
    add_to_string(str,(uchar *)source);
  }
  return;
}



// WARNING: Unknown calling convention

void bind_config_string(string *file)

{
  uchar *source;
  uchar *source_00;
  keybinding *keybinding;
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  keymap_id keymap_id_00;
  keymap_id keymap_id;
  uchar *action_str;
  
  keymap_id_00 = KEYMAP_MAIN;
  plVar2 = keymaps;
  do {
    plVar1 = (list_head_elinks *)keymaps[keymap_id_00].next;
joined_r0x08072c19:
    if (plVar1 != plVar2) {
      do {
        if ((*(byte *)&plVar1[4].next & 8) == 0) {
          source = get_keymap_name(keymap_id_00);
          source_00 = get_action_name(keymap_id_00,(action_id_T)plVar1[2].next);
          if (((source_00 != (uchar *)0x0) && (source != (uchar *)0x0)) && (*source_00 != ' ')) {
            if (((uint)plVar1[4].next & 1) != 0) goto code_r0x08072c65;
            add_to_string(file,(uchar *)"bind \"");
            add_to_string(file,source);
            add_to_string(file,"\" \"");
            add_keystroke_to_string(file,(term_event_keyboard *)&plVar1[2].prev,1);
            add_to_string(file,(uchar *)"\" = \"");
            add_to_string(file,source_00);
            add_char_to_string(file,'\"');
            add_char_to_string(file,'\n');
          }
        }
        plVar1 = (list_head_elinks *)plVar1->next;
        if (plVar1 == plVar2) break;
      } while( true );
    }
    plVar2 = plVar2 + 1;
    keymap_id_00 = keymap_id_00 + KEYMAP_EDIT;
    if (plVar2 == (list_head_elinks *)&no_autocreate) {
      return;
    }
  } while( true );
code_r0x08072c65:
  plVar1[4].next = (void *)((uint)plVar1[4].next & 0xfffffffe);
  plVar1 = (list_head_elinks *)plVar1->next;
  goto joined_r0x08072c19;
}



// WARNING: Unknown calling convention

void add_keystroke_action_to_string(string *string,action_id_T action_id,keymap_id keymap_id)

{
  list_head_elinks *plVar1;
  keybinding *keybinding;
  
  plVar1 = (list_head_elinks *)keymaps[keymap_id].next;
  while( true ) {
    if (plVar1 == keymaps + keymap_id) {
      return;
    }
    if ((void *)action_id == plVar1[2].next) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  add_keystroke_to_string(string,(term_event_keyboard *)&plVar1[2].prev,0);
  return;
}



// WARNING: Unknown calling convention

uchar * get_keystroke(action_id_T action_id,keymap_id keymap_id)

{
  string *psVar1;
  uchar *puVar2;
  string keystroke;
  
  psVar1 = init_string(&keystroke);
  puVar2 = (uchar *)0x0;
  if ((psVar1 != (string *)0x0) &&
     (add_keystroke_action_to_string(&keystroke,action_id,keymap_id), puVar2 = keystroke.source,
     keystroke.length == 0)) {
    done_string(&keystroke);
    puVar2 = keystroke.source;
  }
  return puVar2;
}



// WARNING: Removing unreachable block (ram,0x08072e2e)
// WARNING: Unknown calling convention

term_event_key_T read_key(uchar *key_str)

{
  uint uVar1;
  char *s1;
  int iVar2;
  named_key *key;
  named_key *pnVar3;
  
  if ((*key_str == 0) || (uVar1 = (uint)*key_str, key_str[1] != '\0')) {
    s1 = "Enter";
    pnVar3 = key_table;
    do {
      iVar2 = c_strcasecmp(s1,(char *)key_str);
      if (iVar2 == 0) {
        return pnVar3->num;
      }
      pnVar3 = pnVar3 + 1;
      s1 = (char *)pnVar3->str;
    } while ((uchar *)s1 != (uchar *)0x0);
    uVar1 = 0xffffffff;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int parse_keystroke(uchar *s,term_event_keyboard *kbd)

{
  int iVar1;
  
  kbd->modifier = KBD_MOD_NONE;
  while( true ) {
    while( true ) {
      for (; (iVar1 = c_strncasecmp((char *)s,"Shift",5), iVar1 == 0 &&
             ((s[5] == '+' || (s[5] == '-')))); s = s + 6) {
        kbd->modifier = kbd->modifier | KBD_MOD_SHIFT;
      }
      iVar1 = c_strncasecmp((char *)s,"Ctrl",4);
      if ((iVar1 != 0) || ((s[4] != '+' && (s[4] != '-')))) break;
      kbd->modifier = kbd->modifier | KBD_MOD_CTRL;
      s = s + 5;
    }
    iVar1 = c_strncasecmp((char *)s,"Alt",3);
    if ((iVar1 != 0) || ((s[3] != '+' && (s[3] != '-')))) break;
    kbd->modifier = kbd->modifier | KBD_MOD_ALT;
    s = s + 4;
  }
  iVar1 = read_key(s);
  kbd->key = iVar1;
  if (((*(byte *)&kbd->modifier & 2) != 0) && (-1 < iVar1)) {
    if (0x7f < iVar1) {
      return 0;
    }
    iVar1 = c_toupper(iVar1);
    kbd->key = iVar1;
  }
  if (iVar1 != -1) {
    return 0;
  }
  return -1;
}



// WARNING: Unknown calling convention

uchar * bind_act(uchar *keymap_str,uchar *keystroke_str)

{
  list_head_elinks *plVar1;
  int iVar2;
  uchar *action;
  uchar *puVar3;
  keymap_id keymap_id_00;
  keymap_id keymap_id;
  int iVar4;
  keybinding *keybinding;
  term_event_keyboard kbd;
  
  iVar4 = 0;
  keymap_id_00 = KEYMAP_MAIN;
  while (iVar2 = strcmp((char *)keymap_table[keymap_id_00].str,(char *)keymap_str), iVar2 != 0) {
    iVar4 = iVar4 + 1;
    keymap_id_00 = keymap_id_00 + KEYMAP_EDIT;
    if (iVar4 == 3) {
      return (uchar *)0x0;
    }
  }
  iVar4 = parse_keystroke(keystroke_str,&kbd);
  if (iVar4 < 0) {
    return (uchar *)0x0;
  }
  plVar1 = (list_head_elinks *)keymaps[keymap_id_00].next;
  while( true ) {
    if (plVar1 == keymaps + keymap_id_00) {
      return (uchar *)0x0;
    }
    if (((void *)kbd.key == plVar1[2].prev) && (plVar1[3].next == (void *)kbd.modifier)) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  puVar3 = get_action_name(keymap_id_00,(action_id_T)plVar1[2].next);
  if (puVar3 == (uchar *)0x0) {
    return (uchar *)0x0;
  }
  plVar1[4].next = (void *)((uint)plVar1[4].next | 1);
  puVar3 = straconcat("\"",puVar3,&DAT_08128449,0);
  return puVar3;
}



// WARNING: Unknown calling convention

uchar * get_action_name_from_keystroke(keymap_id keymap_id,uchar *keystroke_str)

{
  list_head_elinks *plVar1;
  keybinding *keybinding_1;
  int iVar2;
  keybinding *keybinding;
  action *paVar3;
  action *action;
  term_event_keyboard kbd;
  
  iVar2 = parse_keystroke(keystroke_str,&kbd);
  if (-1 < iVar2) {
    for (plVar1 = (list_head_elinks *)keymaps[keymap_id].next; plVar1 != keymaps + keymap_id;
        plVar1 = (list_head_elinks *)plVar1->next) {
      if ((plVar1[2].prev == (void *)kbd.key) && (plVar1[3].next == (void *)kbd.modifier)) {
        paVar3 = get_action(keymap_id,(action_id_T)plVar1[2].next);
        if (paVar3 == (action *)0x0) {
          return (uchar *)0x0;
        }
        return paVar3->str;
      }
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void free_keybinding(keybinding *keybinding)

{
  if (keybinding->box_item != (listbox_item *)0x0) {
    done_listbox_item(&keybinding_browser,keybinding->box_item);
    keybinding->box_item = (listbox_item *)0x0;
  }
  if ((keybinding->flags & KBDB_DEFAULT_KEY) != 0) {
    keybinding->flags = keybinding->flags & ~KBDB_DEFAULT_BINDING;
    keybinding->action_id = 0;
    return;
  }
  keybinding->next->prev = keybinding->prev;
  keybinding->prev->next = keybinding->next;
  mem_free(keybinding);
  return;
}



// WARNING: Unknown calling convention

keybinding *
add_keybinding(keymap_id keymap_id,action_id_T action_id,term_event_keyboard *kbd,int event)

{
  keybinding *pkVar1;
  term_event_modifier_T tVar2;
  keybinding *keybinding_1;
  keybinding *pkVar3;
  keybinding *keybinding;
  default_kb *pos;
  default_kb *pdVar4;
  listbox_item *root;
  listbox_item *plVar5;
  int iVar6;
  default_kb *pdVar7;
  uint uVar8;
  default_kb *pdVar9;
  bool bVar10;
  byte bVar11;
  default_kb default_keybinding;
  
  bVar11 = 0;
  pkVar3 = (keybinding *)keymaps[keymap_id].next;
  pkVar1 = (keybinding *)(keymaps + keymap_id);
  if (pkVar3 != pkVar1) {
    do {
      if (((pkVar3->kbd).key == kbd->key) && ((pkVar3->kbd).modifier == kbd->modifier)) {
        iVar6 = 1;
        if ((pkVar3->flags & KBDB_DEFAULT_KEY) != 0) {
          iVar6 = 2;
          pkVar3->flags = pkVar3->flags & ~KBDB_DEFAULT_KEY;
        }
        free_keybinding(pkVar3);
        uVar8 = (uint)(iVar6 == 2);
        goto LAB_08073188;
      }
      pkVar3 = pkVar3->next;
    } while (pkVar3 != pkVar1);
  }
  uVar8 = 0;
LAB_08073188:
  pkVar3 = (keybinding *)mem_calloc(1,0x28);
  if (pkVar3 != (keybinding *)0x0) {
    pkVar3->keymap_id = keymap_id;
    pkVar3->action_id = action_id;
    tVar2 = kbd->modifier;
    (pkVar3->kbd).key = kbd->key;
    default_keybinding.kbd.key = (pkVar3->kbd).key;
    (pkVar3->kbd).modifier = tVar2;
    pkVar3->flags = uVar8 << 2;
    pkVar3->event = event;
    default_keybinding.kbd.modifier = (pkVar3->kbd).modifier;
    default_keybinding.action_id = action_id;
    pdVar4 = default_keybindings[pkVar3->keymap_id];
    bVar10 = (pdVar4->kbd).key == 0;
    if (!bVar10) {
      do {
        iVar6 = 0xc;
        pdVar7 = &default_keybinding;
        pdVar9 = pdVar4;
        do {
          if (iVar6 == 0) break;
          iVar6 = iVar6 + -1;
          bVar10 = *(char *)&(pdVar7->kbd).key == *(char *)&(pdVar9->kbd).key;
          pdVar7 = (default_kb *)((int)pdVar7 + (uint)bVar11 * -2 + 1);
          pdVar9 = (default_kb *)((int)pdVar9 + (uint)bVar11 * -2 + 1);
        } while (bVar10);
        if (bVar10) {
          pkVar3->flags = pkVar3->flags | KBDB_DEFAULT_BINDING;
          break;
        }
        pdVar4 = pdVar4 + 1;
        bVar10 = (pdVar4->kbd).key == 0;
      } while (!bVar10);
    }
    pkVar3->next = (keybinding *)keymaps[keymap_id].next;
    pkVar3->prev = pkVar1;
    keymaps[keymap_id].next = pkVar3;
    pkVar3->next->prev = pkVar3;
    if ((action_id == 0) ||
       (plVar5 = get_keybinding_action_box_item(keymap_id,action_id), plVar5 == (listbox_item *)0x0)
       ) {
      return (keybinding *)0x0;
    }
    plVar5 = add_listbox_item(&keybinding_browser,plVar5,BI_LEAF,pkVar3,1);
    pkVar3->box_item = plVar5;
  }
  return pkVar3;
}



// WARNING: Unknown calling convention

void init_keymaps(module *xxx)

{
  int iVar1;
  default_kb *kbd;
  keybinding *keybinding;
  keybinding *pkVar2;
  default_kb *kb;
  keymap_id keymap_id_00;
  keymap_id keymap_id;
  int iVar3;
  
  iVar3 = 0;
  keymap_id_00 = KEYMAP_MAIN;
  keymaps[0].prev = keymaps;
  keymaps[0].next = keymaps;
  keymaps[1].prev = keymaps + 1;
  keymaps[1].next = keymaps + 1;
  keymaps[2].prev = keymaps + 2;
  keymaps[2].next = keymaps + 2;
  init_keybinding_listboxes(keymap_table,action_table);
  do {
    iVar1 = (default_keybindings[keymap_id_00]->kbd).key;
    kbd = default_keybindings[keymap_id_00];
    while (iVar1 != 0) {
      pkVar2 = add_keybinding(keymap_id_00,kbd->action_id,&kbd->kbd,-1);
      pkVar2->flags = pkVar2->flags | (KBDB_DEFAULT_KEY|KBDB_DEFAULT_BINDING);
      iVar1 = kbd[1].kbd.key;
      kbd = kbd + 1;
    }
    iVar3 = iVar3 + 1;
    keymap_id_00 = keymap_id_00 + KEYMAP_EDIT;
  } while (iVar3 != 3);
  return;
}



// WARNING: Unknown calling convention

int bind_do(uchar *keymap_str,uchar *keystroke_str,uchar *action_str,int is_system_conf)

{
  int iVar1;
  action_id_T action_id_00;
  keybinding *pkVar2;
  keybinding *keybinding;
  action_id_T action_id;
  int iVar3;
  action_alias *alias;
  action_alias *paVar4;
  keymap_id keymap_id_00;
  keymap_id keymap_id;
  term_event_keyboard kbd;
  
  keymap_id_00 = KEYMAP_MAIN;
  iVar3 = 0;
  while (iVar1 = strcmp((char *)keymap_table[keymap_id_00].str,(char *)keymap_str), iVar1 != 0) {
    iVar3 = iVar3 + 1;
    keymap_id_00 = keymap_id_00 + KEYMAP_EDIT;
    if (iVar3 == 3) {
      return 1;
    }
  }
  iVar3 = parse_keystroke(keystroke_str,&kbd);
  if (iVar3 < 0) {
    return 2;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(2 < (uint)keymap_id_00), 2 < (uint)keymap_id_00)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x377;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  paVar4 = action_aliases[keymap_id_00];
  if (paVar4 != (action_alias *)0x0) {
    for (; paVar4->str != (uchar *)0x0; paVar4 = paVar4 + 1) {
      iVar3 = strcmp((char *)paVar4->str,(char *)action_str);
      if (iVar3 == 0) {
        action_id_00 = paVar4->action_id;
        goto LAB_0807341f;
      }
    }
  }
  action_id_00 = get_action_from_string(keymap_id_00,action_str);
LAB_0807341f:
  if (action_id_00 < 0) {
    return 3;
  }
  pkVar2 = add_keybinding(keymap_id_00,action_id_00,&kbd,-1);
  if ((pkVar2 != (keybinding *)0x0) && (is_system_conf != 0)) {
    pkVar2->flags = pkVar2->flags | (KBDB_DEFAULT_KEY|KBDB_DEFAULT_BINDING);
  }
  return 0;
}



// WARNING: Unknown calling convention

int bind_key_to_event_name(uchar *ckmap,uchar *ckey,uchar *event_name,uchar **err)

{
  int event;
  int iVar1;
  uchar *puVar2;
  action_id_T action_id_00;
  action_id_T action_id;
  keymap_id keymap_id;
  int iVar3;
  term_event_keyboard kbd;
  
  event = register_event(event_name);
  if (event == -1) {
    puVar2 = gettext((uchar *)"Error registering event");
    *err = puVar2;
  }
  else {
    iVar3 = 0;
    keymap_id = KEYMAP_MAIN;
    do {
      iVar1 = strcmp((char *)keymap_table[keymap_id].str,(char *)ckmap);
      if (iVar1 == 0) {
        iVar3 = parse_keystroke(ckey,&kbd);
        if (iVar3 < 0) {
          puVar2 = gettext((uchar *)"Error parsing keystroke");
        }
        else {
          action_id_00 = get_action_from_string(keymap_id,(uchar *)" *scripting-function*");
          if (action_id_00 < 0) {
            puVar2 = gettext((uchar *)"Unrecognised action (internal error)");
          }
          else {
            add_keybinding(keymap_id,action_id_00,&kbd,event);
            puVar2 = (uchar *)0x0;
          }
        }
        goto LAB_080734e8;
      }
      iVar3 = iVar3 + 1;
      keymap_id = keymap_id + KEYMAP_EDIT;
    } while (iVar3 != 3);
    puVar2 = gettext((uchar *)"Unrecognised keymap");
LAB_080734e8:
    *err = puVar2;
  }
  return event;
}



// WARNING: Unknown calling convention

void add_actions_to_string
               (string *string,action_id_T *action_ids,keymap_id keymap_id,terminal *term)

{
  void *pvVar1;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  uchar *puVar4;
  void *action_id;
  action *paVar5;
  action *action;
  int times;
  keybinding *keybinding;
  list_head_elinks *plVar6;
  uchar *desc;
  action_id_T *local_20;
  
  if ((assert_failed == 0) && (assert_failed = (int)(2 < (uint)keymap_id), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 0x1f6;
    elinks_internal((uchar *)"assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  }
  puVar4 = keymap_table[keymap_id].desc;
  if ((puVar4 != (uchar *)0x0) && (*puVar4 != '\0')) {
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar4 = gettext(puVar4);
  }
  add_format_to_string(string,"%s:\n",puVar4);
  action_id = (void *)*action_ids;
  if (action_id != (void *)0x0) {
    local_20 = action_ids;
    do {
      plVar6 = (list_head_elinks *)keymaps[keymap_id].next;
      if (plVar6 == keymaps + keymap_id) {
LAB_08073760:
        plVar6 = (list_head_elinks *)0x0;
      }
      else {
        pvVar1 = plVar6[2].next;
        while (action_id != pvVar1) {
          plVar6 = (list_head_elinks *)plVar6->next;
          if (plVar6 == keymaps + keymap_id) goto LAB_08073760;
          pvVar1 = plVar6[2].next;
        }
      }
      iVar2 = string->length;
      puVar4 = (uchar *)0x0;
      paVar5 = get_action(keymap_id,(action_id_T)action_id);
      if ((paVar5 != (action *)0x0) && (puVar4 = paVar5->desc, puVar4 == (uchar *)0x0)) {
        puVar4 = paVar5->str;
      }
      if (plVar6 != (list_head_elinks *)0x0) {
        add_char_to_string(string,'\n');
        add_keystroke_to_string(string,(term_event_keyboard *)&plVar6[2].prev,0);
        iVar2 = (iVar2 - string->length) + 0xf;
        times = 1;
        if (0 < iVar2) {
          times = iVar2;
        }
        add_xchar_to_string(string,' ',times);
        if ((puVar4 != (uchar *)0x0) && (*puVar4 != '\0')) {
          if ((term != (terminal *)0x0) &&
             (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
            puVar3 = get_cp_mime_name(iVar2);
            bind_textdomain_codeset("elinks",puVar3);
            current_charset = iVar2;
          }
          puVar4 = gettext(puVar4);
        }
        add_to_string(string,puVar4);
      }
      action_id = (void *)local_20[1];
      local_20 = local_20 + 1;
    } while (action_id != (void *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void prepare_mustsave_flags(list_head_elinks *tree,int set_all)

{
  list_head_elinks *plVar1;
  void *pvVar2;
  option_elinks *option_elinks;
  
  plVar1 = (list_head_elinks *)tree->next;
  do {
    while( true ) {
      if (plVar1 == tree) {
        return;
      }
      if (set_all != 0) break;
      pvVar2 = plVar1[2].next;
      if ((((uint)pvVar2 & 0x88) != 0) || ((undefined *)plVar1[2].prev == &DAT_00000005))
      goto LAB_080737bb;
      plVar1[2].next = (void *)((uint)pvVar2 & 0xfffffffb);
      if ((undefined *)plVar1[2].prev == &DAT_00000009) goto LAB_080737f0;
LAB_080737c7:
      plVar1 = (list_head_elinks *)plVar1->next;
    }
    pvVar2 = plVar1[2].next;
LAB_080737bb:
    plVar1[2].next = (void *)((uint)pvVar2 | 4);
    if ((undefined *)plVar1[2].prev != &DAT_00000009) goto LAB_080737c7;
LAB_080737f0:
    prepare_mustsave_flags((list_head_elinks *)plVar1[4].next,set_all);
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

void untouch_options(list_head_elinks *tree)

{
  option_elinks *option_elinks;
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)tree->next;
  do {
    if (plVar1 == tree) {
      return;
    }
    while (plVar1[2].next = (void *)((uint)plVar1[2].next & 0xfffffff7),
          (undefined *)plVar1[2].prev != &DAT_00000009) {
      plVar1 = (list_head_elinks *)plVar1->next;
      if (plVar1 == tree) {
        return;
      }
    }
    untouch_options((list_head_elinks *)plVar1[4].next);
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

int check_nonempty_tree(list_head_elinks *options)

{
  list_head_elinks *plVar1;
  int iVar2;
  option_elinks *opt;
  
  plVar1 = (list_head_elinks *)options->next;
  do {
    if (plVar1 == options) {
      return 0;
    }
    if ((undefined *)plVar1[2].prev == &DAT_00000009) {
      iVar2 = check_nonempty_tree((list_head_elinks *)plVar1[4].next);
      if (iVar2 != 0) {
        return 1;
      }
    }
    else if ((*(byte *)&plVar1[2].next & 4) != 0) {
      return 1;
    }
    plVar1 = (list_head_elinks *)plVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

int change_hook_html(session *ses,option_elinks *current,option_elinks *changed)

{
  byte *pbVar1;
  list_head_elinks *plVar2;
  
  plVar2 = (list_head_elinks *)sessions.next;
  if ((list_head_elinks *)sessions.next != &sessions) {
    do {
      pbVar1 = (byte *)((int)plVar2[1].next + 0x28);
      *pbVar1 = *pbVar1 | 1;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (plVar2 != &sessions);
  }
  return 0;
}



// WARNING: Unknown calling convention

void call_change_hooks(session *ses,option_elinks *current,option_elinks *option_elinks)

{
  int iVar1;
  
  if (current != (option_elinks *)0x0) {
    do {
      if ((current->change_hook != (change_hook_T)0x0) &&
         (iVar1 = (*current->change_hook)(ses,current,option_elinks), iVar1 != 0)) {
        return;
      }
      current = current->root;
    } while (current != (option_elinks *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void option_changed(session *ses,option_elinks *option_elinks)

{
  option_elinks->flags = option_elinks->flags | OPT_TOUCHED;
  call_change_hooks(ses,option_elinks,option_elinks);
  return;
}



// WARNING: Unknown calling convention

void delete_option_do(option_elinks *option_elinks,int recursive)

{
  option_type oVar1;
  void *p_1;
  void *p;
  option_elinks *option_elinks_00;
  int iVar2;
  void *p_2;
  option_elinks *p_00;
  byte bVar3;
  
  bVar3 = 0;
  if (option_elinks->next != (option_elinks *)0x0) {
    option_elinks->next->prev = option_elinks->prev;
    option_elinks->prev->next = option_elinks->next;
    option_elinks->next = (option_elinks *)0x0;
    option_elinks->prev = (option_elinks *)0x0;
  }
  if (recursive == -1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 0x254;
    elinks_error((uchar *)"Orphaned option %s",option_elinks->name);
  }
  oVar1 = option_elinks->type;
  if (oVar1 == OPT_TREE) {
    p_00 = (option_elinks *)(option_elinks->value).tree;
    if ((p_00 != (option_elinks *)0x0) && (option_elinks_00 = p_00->next, p_00 != option_elinks_00))
    {
      if ((recursive == 0) && (recursive = 1, (*(byte *)&option_elinks->flags & 2) == 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        recursive = -1;
        errline = 0x25d;
        elinks_error((uchar *)"Orphaned unregistered option in subtree %s!",option_elinks->name);
        p_00 = (option_elinks *)(option_elinks->value).tree;
        option_elinks_00 = p_00->next;
        if (p_00 != option_elinks_00) goto LAB_08073a18;
      }
      else {
LAB_08073a18:
        do {
          delete_option_do(option_elinks_00,recursive);
          option_elinks_00 = p_00->next;
        } while (option_elinks_00 != p_00);
      }
      oVar1 = option_elinks->type;
      goto joined_r0x08073a2b;
    }
  }
  else {
joined_r0x08073a2b:
    if (oVar1 == OPT_STRING) {
      if ((option_elinks->value).tree != (list_head_elinks *)0x0) {
        mem_free((option_elinks->value).tree);
      }
      goto LAB_080739a0;
    }
    if (oVar1 != OPT_TREE) goto LAB_080739a0;
    p_00 = (option_elinks *)(option_elinks->value).tree;
  }
  if (p_00 != (option_elinks *)0x0) {
    mem_free(p_00);
  }
LAB_080739a0:
  if (option_elinks->box_item != (listbox_item *)0x0) {
    done_listbox_item(&option_browser,option_elinks->box_item);
  }
  if ((option_elinks->flags & OPT_ALLOC) == 0) {
    if (option_elinks->capt == (uchar *)0x0) {
      for (iVar2 = 0xe; iVar2 != 0; iVar2 = iVar2 + -1) {
        option_elinks->next = (option_elinks *)0x0;
        option_elinks = (option_elinks *)((int)option_elinks + (uint)bVar3 * -8 + 4);
      }
    }
  }
  else {
    if (option_elinks->name != (uchar *)0x0) {
      mem_free(option_elinks->name);
    }
    mem_free(option_elinks);
  }
  return;
}



// WARNING: Unknown calling convention

void unregister_options(option_info *info,option_elinks *tree)

{
  option_info *poVar1;
  int iVar2;
  option_info *poVar3;
  int i;
  int iVar4;
  
  if (info->path != (uchar *)0x0) {
    poVar3 = info;
    iVar2 = 0;
    do {
      iVar4 = iVar2;
      poVar1 = poVar3 + 1;
      poVar3 = poVar3 + 1;
      iVar2 = iVar4 + 1;
    } while (poVar1->path != (uchar *)0x0);
    if (iVar4 != -1) {
      poVar3 = info + iVar4;
      do {
        iVar4 = iVar4 + -1;
        delete_option_do(&poVar3->option_elinks,0);
        poVar3 = poVar3 + -1;
      } while (iVar4 != -1);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void done_options(void)

{
  unregister_options(config_options_info,config_options);
  unregister_options(cmdline_options_info,cmdline_options);
  config_options->box_item = (listbox_item *)0x0;
  while ((list_head_elinks *)options_root_tree.next != &options_root_tree) {
    delete_option_do((option_elinks *)options_root_tree.next,0);
  }
  return;
}



// WARNING: Unknown calling convention

void delete_option(option_elinks *option_elinks)

{
  delete_option_do(option_elinks,1);
  return;
}



// WARNING: Unknown calling convention

list_head_elinks * init_options_tree(void)

{
  list_head_elinks *plVar1;
  list_head_elinks *ptr;
  
  plVar1 = (list_head_elinks *)mem_alloc(8);
  if (plVar1 != (list_head_elinks *)0x0) {
    plVar1->prev = plVar1;
    plVar1->next = plVar1;
  }
  return plVar1;
}



// WARNING: Unknown calling convention

void toggle_option(session *ses,option_elinks *option_elinks)

{
  long number;
  undefined *puVar1;
  
  puVar1 = (undefined *)((int)&((option_elinks->value).tree)->next + 1);
  if (assert_failed == 0) {
    assert_failed = (int)(OPT_INT < option_elinks->type);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x3dc;
      elinks_internal((uchar *)
                      "assertion option->type == OPT_BOOL || option->type == OPT_INT failed!");
      if (assert_failed != 0) goto LAB_08073c1a;
    }
    assert_failed = (int)(option_elinks->max == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x3dd;
      elinks_internal((uchar *)"assertion option->max failed!");
    }
  }
LAB_08073c1a:
  if (option_elinks->max < (int)puVar1) {
    puVar1 = (undefined *)option_elinks->min;
  }
  (option_elinks->value).number = (int)puVar1;
  option_changed(ses,option_elinks);
  return;
}



// WARNING: Unknown calling convention

void mark_option_as_deleted(option_elinks *option_elinks)

{
  undefined *puVar1;
  option_elinks *unmarked;
  option_elinks *option_elinks_00;
  
  if (option_elinks->type == OPT_TREE) {
    if ((assert_failed == 0) &&
       (assert_failed = (int)((option_elinks->value).tree == (list_head_elinks *)0x0),
       assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x26f;
      elinks_internal((uchar *)"assertion option->value.tree failed!");
    }
    option_elinks_00 = ((option_elinks *)(option_elinks->value).tree)->next;
    if (option_elinks_00 != (option_elinks *)(option_elinks->value).tree) {
      do {
        mark_option_as_deleted(option_elinks_00);
        option_elinks_00 = option_elinks_00->next;
      } while ((option_elinks *)(option_elinks->value).tree != option_elinks_00);
    }
  }
  puVar1 = &option_elinks->box_item->field_0x18;
  *puVar1 = *puVar1 & 0xfd;
  option_elinks->flags = option_elinks->flags | (OPT_TOUCHED|OPT_DELETED);
  return;
}



// WARNING: Unknown calling convention

void update_visibility(list_head_elinks *tree,int show)

{
  void *pvVar1;
  byte bVar2;
  int iVar3;
  option_elinks *opt;
  list_head_elinks *plVar4;
  char *pcVar5;
  char *pcVar6;
  bool bVar7;
  byte bVar8;
  byte local_28;
  
  bVar8 = 0;
  plVar4 = (list_head_elinks *)tree->next;
  if (plVar4 == tree) {
    return;
  }
  local_28 = (byte)show;
  bVar2 = (local_28 & 1) * '\x02';
  do {
    while (bVar7 = *(char *)&plVar4[2].next == '\0', *(char *)&plVar4[2].next < '\0') {
LAB_08073d82:
      plVar4 = (list_head_elinks *)plVar4->next;
      if (plVar4 == tree) {
        return;
      }
    }
    iVar3 = 0xb;
    pcVar5 = (char *)plVar4[1].prev;
    pcVar6 = "_template_";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar7 = *pcVar5 == *pcVar6;
      pcVar5 = pcVar5 + (uint)bVar8 * -2 + 1;
      pcVar6 = pcVar6 + (uint)bVar8 * -2 + 1;
    } while (bVar7);
    if (bVar7) {
      pvVar1 = plVar4[6].prev;
      if (pvVar1 != (void *)0x0) {
        *(byte *)((int)pvVar1 + 0x18) = *(byte *)((int)pvVar1 + 0x18) & 0xfd | bVar2;
      }
      if ((undefined *)plVar4[2].prev == &DAT_00000009) {
        update_visibility((list_head_elinks *)plVar4[4].next,show | 2);
      }
      goto LAB_08073d82;
    }
    pvVar1 = plVar4[6].prev;
    if ((pvVar1 != (void *)0x0) && ((show & 2U) != 0)) {
      *(byte *)((int)pvVar1 + 0x18) = *(byte *)((int)pvVar1 + 0x18) & 0xfd | bVar2;
    }
    if ((undefined *)plVar4[2].prev != &DAT_00000009) goto LAB_08073d82;
    update_visibility((list_head_elinks *)plVar4[4].next,show);
    plVar4 = (list_head_elinks *)plVar4->next;
    if (plVar4 == tree) {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

int change_hook_stemplate(session *ses,option_elinks *current,option_elinks *changed)

{
  update_visibility((config_options->value).tree,(changed->value).number);
  return 0;
}



// WARNING: Unknown calling convention

void smart_config_string(string *str,int print_comment,int i18n,list_head_elinks *options,
                        uchar *path,int depth,
                        _func_void_string_ptr_option_elinks_ptr_uchar_ptr_int_int_int_int *fn)

{
  string *psVar1;
  int iVar2;
  undefined *puVar3;
  option_elinks *option_elinks;
  option_elinks *poVar4;
  int do_print_comment;
  uint print_comment_00;
  uchar *puVar5;
  uchar *puVar6;
  bool bVar7;
  byte bVar8;
  int iVar9;
  string newpath;
  
  bVar8 = 0;
  poVar4 = (option_elinks *)options->next;
  if (poVar4 != (option_elinks *)options) {
    do {
      if ((poVar4->flags & OPT_HIDDEN) == 0) {
        bVar7 = (undefined *)poVar4->type == &DAT_00000008;
        if (!bVar7) {
          iVar2 = 0xb;
          puVar5 = poVar4->name;
          puVar6 = "_template_";
          do {
            if (iVar2 == 0) break;
            iVar2 = iVar2 + -1;
            bVar7 = *puVar5 == *puVar6;
            puVar5 = puVar5 + (uint)bVar8 * -2 + 1;
            puVar6 = puVar6 + (uint)bVar8 * -2 + 1;
          } while (bVar7);
          if (!bVar7) {
            if ((undefined *)poVar4->type == &DAT_00000009) {
              iVar2 = check_nonempty_tree((poVar4->value).tree);
              bVar7 = iVar2 == 0;
            }
            else {
              bVar7 = (bool)(((byte)(poVar4->flags >> 2) ^ 1) & 1);
            }
            if (bVar7 == false) {
              if (print_comment == 0) {
                puVar3 = (undefined *)poVar4->type;
                iVar2 = 0;
LAB_08073e8a:
                iVar9 = print_comment;
                if (puVar3 != &DAT_00000009) {
LAB_08073e92:
                  iVar9 = iVar2;
                  iVar2 = iVar9;
                }
              }
              else {
                bVar7 = print_comment == 1;
                if (!bVar7) {
LAB_08073f52:
                  puVar3 = (undefined *)poVar4->type;
                  iVar2 = 1;
                  goto LAB_08073e8a;
                }
                iVar2 = 0xb;
                puVar5 = poVar4->name;
                puVar6 = "_template_";
                do {
                  if (iVar2 == 0) break;
                  iVar2 = iVar2 + -1;
                  bVar7 = *puVar5 == *puVar6;
                  puVar5 = puVar5 + (uint)bVar8 * -2 + 1;
                  puVar6 = puVar6 + (uint)bVar8 * -2 + 1;
                } while (bVar7);
                if ((bVar7) || ((*(byte *)&poVar4->flags & 2) == 0)) goto LAB_08073f52;
                iVar2 = 1;
                if ((undefined *)poVar4->type != &DAT_00000009) goto LAB_08073e92;
                iVar9 = 1;
                iVar2 = 0;
              }
              (*fn)(str,poVar4,path,depth,iVar9,0,i18n);
              (*fn)(str,poVar4,path,depth,iVar2,1,i18n);
              if (option_types[(int)(undefined *)poVar4->type].write ==
                  (_func_void_option_elinks_ptr_string_ptr *)0x0) {
                if ((undefined *)poVar4->type == &DAT_00000009) {
                  psVar1 = init_string(&newpath);
                  if (psVar1 != (string *)0x0) {
                    if (print_comment == 2) {
                      print_comment_00 = ~-(uint)((poVar4->flags & OPT_AUTOCREATE) == 0) + 2;
                    }
                    else {
                      print_comment_00 = print_comment;
                      if (print_comment == 1) {
                        iVar2 = strcmp((char *)poVar4->name,"_template_");
                        print_comment_00 = (uint)(iVar2 == 0);
                      }
                    }
                    (*fn)(str,poVar4,path,depth,1,3,i18n);
                    if (path != (uchar *)0x0) {
                      add_to_string(&newpath,path);
                      add_char_to_string(&newpath,'.');
                    }
                    add_to_string(&newpath,poVar4->name);
                    smart_config_string(str,print_comment_00,i18n,(poVar4->value).tree,
                                        newpath.source,depth + 1,fn);
                    done_string(&newpath);
                    iVar9 = 3;
                    iVar2 = 1;
                    goto LAB_08073f15;
                  }
                }
              }
              else {
                iVar9 = 2;
LAB_08073f15:
                (*fn)(str,poVar4,path,depth,iVar2,iVar9,i18n);
              }
            }
          }
        }
      }
      poVar4 = poVar4->next;
    } while (poVar4 != (option_elinks *)options);
  }
  return;
}



// WARNING: Unknown calling convention

int change_hook_ui(session *ses,option_elinks *current,option_elinks *changed)

{
  update_status();
  return 0;
}



// WARNING: Unknown calling convention

int change_hook_insert_mode(session *ses,option_elinks *current,option_elinks *changed)

{
  update_status();
  return 0;
}



// WARNING: Unknown calling convention

int change_hook_language(session *ses,option_elinks *current,option_elinks *changed)

{
  set_language((changed->value).number);
  return 0;
}



// WARNING: Unknown calling convention

int change_hook_terminal(session *ses,option_elinks *current,option_elinks *changed)

{
  cls_redraw_all_terminals();
  return 0;
}



// WARNING: Unknown calling convention

int change_hook_cache(session *ses,option_elinks *current,option_elinks *changed)

{
  shrink_memory(0);
  return 0;
}



// WARNING: Unknown calling convention

int change_hook_active_link(session *ses,option_elinks *current,option_elinks *changed)

{
  update_cached_document_options();
  return 0;
}



// WARNING: Unknown calling convention

int change_hook_connection(session *ses,option_elinks *current,option_elinks *changed)

{
  register_check_queue();
  return 0;
}



// WARNING: Unknown calling convention

option_elinks * copy_option(option_elinks *template)

{
  option_elinks *poVar1;
  option_elinks *option_elinks;
  uchar *puVar2;
  listbox_item *plVar3;
  
  poVar1 = (option_elinks *)mem_calloc(1,0x38);
  if (poVar1 != (option_elinks *)0x0) {
    puVar2 = (uchar *)0x0;
    if (template->name != (uchar *)0x0) {
      puVar2 = stracpy(template->name);
    }
    poVar1->name = puVar2;
    poVar1->flags = template->flags | OPT_ALLOC;
    poVar1->type = template->type;
    poVar1->min = template->min;
    poVar1->max = template->max;
    poVar1->capt = template->capt;
    poVar1->desc = template->desc;
    poVar1->change_hook = template->change_hook;
    plVar3 = (listbox_item *)mem_calloc(1,0x20);
    if (plVar3 == (listbox_item *)0x0) {
      poVar1->box_item = (listbox_item *)0x0;
    }
    else {
      plVar3->field_0x18 = plVar3->field_0x18 | 2;
      (plVar3->child).prev = &plVar3->child;
      (plVar3->child).next = &plVar3->child;
      plVar3->udata = poVar1;
      plVar3->type = (uint)(poVar1->type == OPT_TREE);
      poVar1->box_item = plVar3;
      if (template->box_item != (listbox_item *)0x0) {
        plVar3->type = template->box_item->type;
        poVar1->box_item->depth = template->box_item->depth;
      }
    }
    if (option_types[template->type].dup == (_func_void_option_elinks_ptr_option_elinks_ptr *)0x0) {
      poVar1->value = template->value;
      return poVar1;
    }
    (*option_types[template->type].dup)(poVar1,template);
  }
  return poVar1;
}



// WARNING: Unknown calling convention

option_elinks * get_opt_rec(option_elinks *tree,uchar *name_)

{
  option_elinks *poVar1;
  uchar *name__00;
  uchar *aname;
  char *pcVar2;
  int iVar3;
  option_elinks *template;
  uchar *puVar4;
  option_elinks *poVar5;
  option_elinks *option_elinks;
  uchar *name;
  uchar *local_24;
  
  poVar5 = (option_elinks *)0x0;
  name__00 = stracpy(name_);
  if (name__00 != (uchar *)0x0) {
    pcVar2 = strrchr((char *)name__00,0x2e);
    local_24 = name__00;
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
      tree = get_opt_rec(tree,name__00);
      if (((tree == (option_elinks *)0x0) || (tree->type != OPT_TREE)) ||
         ((*(byte *)&tree->flags & 1) != 0)) goto LAB_080743c0;
      *pcVar2 = '.';
      local_24 = (uchar *)(pcVar2 + 1);
    }
    poVar5 = (option_elinks *)(tree->value).tree;
    for (poVar1 = poVar5->next; poVar1 != poVar5; poVar1 = poVar1->next) {
      if ((poVar1->name != (uchar *)0x0) &&
         (iVar3 = strcmp((char *)poVar1->name,(char *)local_24), iVar3 == 0)) {
        mem_free(name__00);
        return poVar1;
      }
    }
    if (((*(byte *)&tree->flags & 2) == 0) || (no_autocreate != 0)) {
LAB_080743c0:
      mem_free(name__00);
      return (option_elinks *)0x0;
    }
    poVar5 = get_opt_rec(tree,"_template_");
    if (assert_failed != 0) {
LAB_08074439:
      assert_failed = 0;
      mem_free(name__00);
      return (option_elinks *)0x0;
    }
    assert_failed = (int)(poVar5 == (option_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0xd1;
      elinks_internal((uchar *)
                      "assertion template != NULL failed: Requested %s should be autocreated but %.*s._template_ is missing!"
                      ,name_,(int)pcVar2 - (int)name_,name_);
      if (assert_failed != 0) goto LAB_08074439;
    }
    poVar5 = copy_option(poVar5);
    if (poVar5 != (option_elinks *)0x0) {
      if (poVar5->name != (uchar *)0x0) {
        mem_free(poVar5->name);
      }
      puVar4 = stracpy(local_24);
      poVar5->name = puVar4;
      add_opt_rec(tree,"",poVar5);
    }
    mem_free(name__00);
  }
  return poVar5;
}



// WARNING: Unknown calling convention

void checkout_option_values
               (option_resolver *resolvers,option_elinks *root,option_value *values,int size)

{
  option_resolver *poVar1;
  option_elinks *option_elinks;
  option_elinks *poVar2;
  int i;
  
  if (0 < size) {
    i = 0;
    do {
      poVar2 = get_opt_rec(root,resolvers[i].name);
      poVar1 = resolvers + i;
      i = i + 1;
      values[poVar1->id] = poVar2->value;
    } while (i < size);
  }
  return;
}



// WARNING: Unknown calling convention

int commit_option_values
              (option_resolver *resolvers,option_elinks *root,option_value *values,int size)

{
  option_value oVar1;
  option_elinks *option_elinks;
  option_elinks *poVar2;
  int iVar3;
  int iVar4;
  int i;
  option_value *poVar5;
  option_value *poVar6;
  undefined uVar7;
  byte bVar8;
  int local_24;
  
  bVar8 = 0;
  if (assert_failed == 0) {
    if ((((root == (option_elinks *)0x0) || (resolvers == (option_resolver *)0x0)) || (size == 0))
       || (values == (option_value *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x425;
      elinks_internal((uchar *)"assertion resolvers && root && values && size failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  iVar4 = 0;
  local_24 = 0;
  uVar7 = size == 0;
  if (0 < size) {
    do {
      poVar2 = get_opt_rec(root,resolvers[iVar4].name);
      iVar3 = 4;
      poVar5 = &poVar2->value;
      poVar6 = values + resolvers[iVar4].id;
      do {
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        uVar7 = *(char *)poVar5 == *(char *)poVar6;
        poVar5 = (option_value *)((int)poVar5 + (uint)bVar8 * -2 + 1);
        poVar6 = (option_value *)((int)poVar6 + (uint)bVar8 * -2 + 1);
      } while ((bool)uVar7);
      if (!(bool)uVar7) {
        oVar1 = values[resolvers[iVar4].id];
        poVar2->flags = poVar2->flags | OPT_TOUCHED;
        poVar2->value = oVar1;
        if (poVar2->change_hook != (change_hook_T)0x0) {
          (*poVar2->change_hook)((session *)0x0,poVar2,(option_elinks *)0x0);
        }
        local_24 = local_24 + 1;
      }
      iVar4 = iVar4 + 1;
      uVar7 = size == iVar4;
    } while (!(bool)uVar7 && iVar4 <= size);
  }
  call_change_hooks((session *)0x0,root,(option_elinks *)0x0);
  return local_24;
}



// WARNING: Unknown calling convention

void register_change_hooks(change_hook_info *change_hooks)

{
  uchar *name_;
  option_elinks *option_elinks;
  option_elinks *poVar1;
  
  name_ = change_hooks->name;
  while (name_ != (uchar *)0x0) {
    poVar1 = get_opt_rec(config_options,name_);
    if ((assert_failed == 0) &&
       (assert_failed = (int)(poVar1 == (option_elinks *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x2f3;
      elinks_internal((uchar *)"assertion option failed!");
    }
    poVar1->change_hook = change_hooks->change_hook;
    name_ = change_hooks[1].name;
    change_hooks = change_hooks + 1;
  }
  return;
}



// WARNING: Unknown calling convention
// Local variable opt:option_elinks *[EAX:4] conflicts with parameter, skipped.

option_value * get_opt_(void)

{
  option_elinks *poVar1;
  option_elinks *in_stack_00000004;
  uchar *in_stack_00000008;
  
  poVar1 = get_opt_rec(in_stack_00000004,in_stack_00000008);
  return &poVar1->value;
}



// WARNING: Unknown calling convention

void add_opt_rec(option_elinks *tree,uchar *path,option_elinks *option_elinks)

{
  list_head_elinks *plVar1;
  uchar uVar2;
  byte bVar3;
  listbox_item *plVar4;
  option_elinks *poVar5;
  byte *__s2;
  listbox_item **pplVar6;
  option_elinks *poVar7;
  option_elinks *template;
  undefined *puVar8;
  option_elinks *opt;
  int iVar9;
  option_elinks *pos;
  int abi;
  uchar *puVar10;
  option_elinks *poVar11;
  undefined *puVar12;
  uchar *puVar13;
  bool bVar14;
  bool bVar15;
  byte bVar16;
  listbox_item *local_28;
  option_elinks *local_20;
  
  bVar16 = 0;
  if (assert_failed == 0) {
    if (((option_elinks == (option_elinks *)0x0) || (path == (uchar *)0x0)) ||
       (tree == (option_elinks *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x1a3;
      elinks_internal((uchar *)"assertion path && option && tree failed!");
      goto LAB_080746e0;
    }
    assert_failed = 0;
    uVar2 = *path;
  }
  else {
LAB_080746e0:
    uVar2 = *path;
  }
  local_20 = tree;
  if (uVar2 != '\0') {
    local_20 = get_opt_rec(tree,path);
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(local_20 == (option_elinks *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 0x1a6;
    elinks_internal((uchar *)"assertion tree != NULL failed: Missing option tree for \'%s\'",path);
  }
  if ((local_20->value).tree == (list_head_elinks *)0x0) {
    return;
  }
  plVar4 = option_elinks->box_item;
  if (plVar4 == (listbox_item *)0x0) {
LAB_08074738:
    bVar3 = *(byte *)&local_20->flags;
  }
  else {
    bVar14 = option_elinks->name == (uchar *)0x0;
    if (bVar14) goto LAB_08074738;
    iVar9 = 0xb;
    puVar10 = option_elinks->name;
    puVar13 = "_template_";
    do {
      if (iVar9 == 0) break;
      iVar9 = iVar9 + -1;
      bVar14 = *puVar10 == *puVar13;
      puVar10 = puVar10 + (uint)bVar16 * -2 + 1;
      puVar13 = puVar13 + (uint)bVar16 * -2 + 1;
    } while (bVar14);
    if (!bVar14) goto LAB_08074738;
    poVar7 = get_opt_rec(config_options,(uchar *)"config.show_template");
    plVar4->field_0x18 = plVar4->field_0x18 & 0xfd | ((byte)(poVar7->value).color & 1) * '\x02';
    bVar3 = *(byte *)&local_20->flags;
  }
  if (((bVar3 & 2) != 0) && (option_elinks->desc == (uchar *)0x0)) {
    poVar7 = get_opt_rec(local_20,"_template_");
    if ((assert_failed == 0) &&
       (assert_failed = (int)(poVar7 == (option_elinks *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x1b1;
      elinks_internal((uchar *)"assertion template failed!");
    }
    option_elinks->desc = poVar7->desc;
  }
  option_elinks->root = local_20;
  plVar4 = local_20->box_item;
  if ((plVar4 != (listbox_item *)0x0) && (option_elinks->box_item != (listbox_item *)0x0)) {
    bVar14 = true;
    if (plVar4->next != (listbox_item *)0x0) {
      option_elinks->box_item->depth = plVar4->depth + 1;
    }
    if ((*(byte *)&local_20->flags & 0x40) != 0) goto LAB_08074887;
LAB_08074782:
                    // WARNING: Load size is inaccurate
    option_elinks->next = *((local_20->value).tree)->prev;
    option_elinks->prev = (option_elinks *)((local_20->value).tree)->prev;
    *(option_elinks **)((local_20->value).tree)->prev = option_elinks;
    option_elinks->next->prev = option_elinks;
    if (!bVar14) goto LAB_080747d5;
                    // WARNING: Load size is inaccurate
    option_elinks->box_item->next = *(local_20->box_item->child).prev;
    option_elinks->box_item->prev = (listbox_item *)(local_20->box_item->child).prev;
    pplVar6 = (listbox_item **)(local_20->box_item->child).prev;
LAB_080747c8:
    *pplVar6 = option_elinks->box_item;
    option_elinks->box_item->next->prev = option_elinks->box_item;
    goto LAB_080747d5;
  }
  bVar14 = false;
  if ((*(byte *)&local_20->flags & 0x40) == 0) goto LAB_08074782;
LAB_08074887:
  poVar7 = (option_elinks *)(local_20->value).tree;
  plVar4 = local_20->box_item;
  plVar1 = &plVar4->child;
  poVar5 = poVar7->next;
  if (poVar7 == poVar5) {
    option_elinks->next = poVar7;
    option_elinks->prev = poVar7;
    poVar7->next = option_elinks;
    option_elinks->next->prev = option_elinks;
    if (bVar14) {
      option_elinks->box_item->next = (listbox_item *)(plVar4->child).next;
      option_elinks->box_item->prev = (listbox_item *)plVar1;
      (plVar4->child).next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    goto LAB_080747d5;
  }
  puVar12 = (undefined *)option_elinks->type;
  local_28 = (listbox_item *)plVar1;
  if (puVar12 == &DAT_00000009) {
    poVar11 = poVar7->prev;
    if (poVar11->type == OPT_TREE) goto LAB_080748b5;
  }
  else {
    poVar11 = poVar7->prev;
LAB_080748b5:
    iVar9 = strcmp((char *)poVar11->name,(char *)option_elinks->name);
    if ((iVar9 < 1) || ((puVar12 != &DAT_00000009 && (poVar11->type == OPT_TREE)))) {
      option_elinks->next = poVar11->next;
      option_elinks->prev = poVar7->prev;
      poVar7->prev->next = option_elinks;
      option_elinks->next->prev = option_elinks;
      if (!bVar14) goto LAB_080747d5;
                    // WARNING: Load size is inaccurate
      option_elinks->box_item->next = *(plVar4->child).prev;
      option_elinks->box_item->prev = (listbox_item *)(plVar4->child).prev;
      pplVar6 = (listbox_item **)(plVar4->child).prev;
      goto LAB_080747c8;
    }
  }
  for (; poVar5 != poVar7; poVar5 = poVar5->next) {
    if (((-1 < *(char *)&poVar5->flags) && (poVar5->box_item != (listbox_item *)0x0)) &&
       (local_28 = local_28->next, assert_failed == 0)) {
      assert_failed = (int)((listbox_item *)plVar1 == local_28);
      if ((listbox_item *)plVar1 == local_28) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 0x175;
        elinks_internal((uchar *)"assertion bpos != (struct listbox_item *) bcat failed!");
        puVar12 = (undefined *)option_elinks->type;
      }
      else {
        puVar12 = (undefined *)option_elinks->type;
      }
    }
    if ((puVar12 == &DAT_00000009) && ((undefined *)poVar5->type != &DAT_00000009))
    goto LAB_08074978;
    puVar10 = poVar5->name;
    __s2 = option_elinks->name;
    iVar9 = strcmp((char *)puVar10,(char *)__s2);
    if (0 < iVar9) {
      if (puVar12 == &DAT_00000009) {
        puVar8 = (undefined *)poVar5->type;
      }
      else {
        puVar8 = (undefined *)poVar5->type;
        if (puVar8 == &DAT_00000009) goto LAB_08074ab0;
      }
      if ((puVar12 != puVar8) || (bVar15 = *__s2 == 0x5f, 0x5f < *__s2)) goto LAB_08074978;
      iVar9 = 0xb;
      puVar13 = "_template_";
      goto code_r0x08074b56;
    }
LAB_08074ab0:
  }
  goto LAB_080749bc;
  while( true ) {
    iVar9 = iVar9 + -1;
    bVar15 = *puVar10 == *puVar13;
    puVar10 = puVar10 + (uint)bVar16 * -2 + 1;
    puVar13 = puVar13 + (uint)bVar16 * -2 + 1;
    if (!bVar15) break;
code_r0x08074b56:
    if (iVar9 == 0) break;
  }
  if (bVar15) {
    if (bVar14) {
      option_elinks->box_item->next = local_28->next;
      option_elinks->box_item->prev = local_28;
      local_28->next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    poVar11 = poVar5->next;
    option_elinks->prev = poVar5;
    option_elinks->next = poVar11;
    poVar5->next = option_elinks;
    option_elinks->next->prev = option_elinks;
  }
  else {
LAB_08074978:
    if (bVar14) {
      option_elinks->box_item->next = local_28->prev->next;
      option_elinks->box_item->prev = local_28->prev;
      local_28->prev->next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    option_elinks->next = poVar5->prev->next;
    option_elinks->prev = poVar5->prev;
    poVar5->prev->next = option_elinks;
    option_elinks->next->prev = option_elinks;
  }
LAB_080749bc:
  if (assert_failed == 0) {
    assert_failed = (int)(poVar5 == poVar7);
    if (poVar5 == poVar7) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x198;
      elinks_internal((uchar *)"assertion pos != (struct option *) cat failed!");
      if (assert_failed != 0) goto LAB_080747d5;
    }
    assert_failed = (int)((listbox_item *)plVar1 == local_28);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 0x199;
      elinks_internal((uchar *)"assertion bpos != (struct listbox_item *) bcat failed!");
    }
  }
LAB_080747d5:
  update_hierbox_browser(&option_browser);
  return;
}



// WARNING: Unknown calling convention

void register_options(option_info *info,option_elinks *tree)

{
  option_info *poVar1;
  listbox_item *plVar2;
  option_type oVar3;
  list_head_elinks *plVar4;
  size_t slen;
  int iVar5;
  uchar *puVar6;
  uchar *string;
  option_info *poVar7;
  
  if (info->path != (uchar *)0x0) {
    poVar1 = info + 1;
    do {
      poVar7 = poVar1;
      oVar3 = (info->option_elinks).type;
      if (oVar3 == OPT_ALIAS) goto LAB_08074cb0;
      if (((*(byte *)&tree->flags & 0x10) == 0) &&
         ((*(byte *)&(info->option_elinks).flags & 0x10) == 0)) {
LAB_08074d20:
        if (oVar3 == OPT_CODEPAGE) {
          puVar6 = (info->option_elinks).value.string;
          if ((assert_failed == 0) &&
             (assert_failed = (int)(puVar6 == (uchar *)0x0), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
            errline = 0x486;
            elinks_internal((uchar *)"assertion string failed!");
          }
          iVar5 = get_cp_index(puVar6);
          (info->option_elinks).value.number = iVar5;
LAB_08074cb0:
          add_opt_rec(tree,info->path,&info->option_elinks);
          goto LAB_08074cbc;
        }
        if (OPT_CODEPAGE < oVar3) {
          if (oVar3 == OPT_COLOR) {
            puVar6 = (info->option_elinks).value.string;
            if ((assert_failed == 0) &&
               (assert_failed = (int)(puVar6 == (uchar *)0x0), assert_failed != 0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
              errline = 0x480;
              elinks_internal((uchar *)"assertion string failed!");
            }
            slen = strlen((char *)puVar6);
            decode_color(puVar6,slen,&(info->option_elinks).value.color);
          }
          else if (oVar3 == OPT_TREE) {
            plVar4 = init_options_tree();
            (info->option_elinks).value.tree = plVar4;
            if (plVar4 == (list_head_elinks *)0x0) goto LAB_08074d50;
          }
          goto LAB_08074cb0;
        }
        if (oVar3 != OPT_STRING) goto LAB_08074cb0;
        puVar6 = (uchar *)mem_alloc(0x400);
        if (puVar6 != (uchar *)0x0) {
          safe_strncpy(puVar6,(info->option_elinks).value.string,0x400);
          (info->option_elinks).value.string = puVar6;
          goto LAB_08074cb0;
        }
LAB_08074d50:
        delete_option(&info->option_elinks);
        puVar6 = poVar7->path;
      }
      else {
        plVar2 = (listbox_item *)mem_calloc(1,0x20);
        if (plVar2 != (listbox_item *)0x0) {
          plVar2->field_0x18 = plVar2->field_0x18 | 2;
          (plVar2->child).prev = &plVar2->child;
          (plVar2->child).next = &plVar2->child;
          plVar2->udata = info;
          plVar2->type = (uint)((info->option_elinks).type == OPT_TREE);
          (info->option_elinks).box_item = plVar2;
          oVar3 = (info->option_elinks).type;
          goto LAB_08074d20;
        }
        (info->option_elinks).box_item = (listbox_item *)0x0;
        delete_option(&info->option_elinks);
LAB_08074cbc:
        puVar6 = poVar7->path;
      }
      poVar1 = poVar7 + 1;
      info = poVar7;
    } while (puVar6 != (uchar *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

option_elinks *
add_opt(option_elinks *tree,uchar *path,uchar *capt,uchar *name,option_flags flags,option_type type,
       long min,long max,longptr_T value,uchar *desc)

{
  option_elinks *option_elinks_00;
  option_elinks *option_elinks;
  uchar *puVar1;
  listbox_item *plVar2;
  size_t slen;
  
  option_elinks_00 = (option_elinks *)mem_calloc(1,0x38);
  if (option_elinks_00 == (option_elinks *)0x0) {
    return (option_elinks *)0x0;
  }
  puVar1 = stracpy(name);
  option_elinks_00->name = puVar1;
  if (puVar1 == (uchar *)0x0) goto LAB_08074fcf;
  option_elinks_00->type = type;
  option_elinks_00->flags = flags | OPT_ALLOC;
  option_elinks_00->min = min;
  option_elinks_00->max = max;
  option_elinks_00->capt = capt;
  option_elinks_00->desc = desc;
  switch(type) {
  case OPT_STRING:
  case OPT_TREE:
    if (value == 0) goto LAB_08074fcf;
  case OPT_BOOL:
  case OPT_INT:
  case OPT_LONG:
  case OPT_CODEPAGE:
  case OPT_COMMAND:
    (option_elinks_00->value).number = value;
    break;
  default:
    goto switchD_08074f88_caseD_5;
  case OPT_COLOR:
    slen = strlen((char *)value);
    decode_color((uchar *)value,slen,&(option_elinks_00->value).color);
    type = option_elinks_00->type;
switchD_08074f88_caseD_5:
    if (type == OPT_ALIAS) goto LAB_08074f6f;
    break;
  case OPT_ALIAS:
    (option_elinks_00->value).number = value;
    goto LAB_08074f6f;
  }
  if (((*(byte *)&tree->flags & 0x10) != 0) || ((*(byte *)&option_elinks_00->flags & 0x10) != 0)) {
    plVar2 = (listbox_item *)mem_calloc(1,0x20);
    if (plVar2 == (listbox_item *)0x0) {
      option_elinks_00->box_item = (listbox_item *)0x0;
LAB_08074fcf:
      mem_free(option_elinks_00);
      return (option_elinks *)0x0;
    }
    plVar2->field_0x18 = plVar2->field_0x18 | 2;
    (plVar2->child).prev = &plVar2->child;
    (plVar2->child).next = &plVar2->child;
    plVar2->udata = option_elinks_00;
    plVar2->type = (uint)(option_elinks_00->type == OPT_TREE);
    option_elinks_00->box_item = plVar2;
  }
LAB_08074f6f:
  add_opt_rec(tree,path,option_elinks_00);
  return option_elinks_00;
}



// WARNING: Unknown calling convention

void update_options_visibility(void)

{
  option_elinks *poVar1;
  option_elinks *opt;
  
  poVar1 = get_opt_rec(config_options,(uchar *)"config.show_template");
  update_visibility((config_options->value).tree,(poVar1->value).number);
  return;
}



// WARNING: Unknown calling convention

void init_options(void)

{
  list_head_elinks *plVar1;
  option_elinks *poVar2;
  option_elinks *opt;
  option_elinks *opt_1;
  option_elinks *opt_2;
  option_elinks *opt_3;
  option_elinks *opt_4;
  option_elinks *opt_5;
  option_elinks *opt_6;
  option_elinks *opt_7;
  option_elinks *opt_8;
  option_elinks *opt_9;
  option_elinks *opt_10;
  option_elinks *opt_11;
  option_elinks *opt_12;
  option_elinks *opt_13;
  option_elinks *opt_14;
  option_elinks *opt_15;
  
  plVar1 = init_options_tree();
  cmdline_options =
       add_opt(&options_root,"","",(uchar *)"cmdline",0,OPT_TREE,0,0,(longptr_T)plVar1,"");
  register_options(cmdline_options_info,cmdline_options);
  plVar1 = init_options_tree();
  config_options =
       add_opt(&options_root,"","",(uchar *)"config",OPT_SORT,OPT_TREE,0,0,(longptr_T)plVar1,"");
  config_options->flags = config_options->flags | OPT_LISTBOX;
  config_options->box_item = &option_browser.root;
  register_options(config_options_info,config_options);
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.linux.type");
  (poVar2->value).number = 2;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.linux.colors");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.linux.m11_hack");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.vt100.type");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.vt110.type");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm.type");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm.underline");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-color.type");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-color.colors");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-color.underline");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-88color.type");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-88color.colors");
  (poVar2->value).number = 2;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-88color.underline");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-256color.type");
  (poVar2->value).number = 1;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-256color.colors");
  (poVar2->value).number = 3;
  poVar2 = get_opt_rec(config_options,(uchar *)"terminal.xterm-256color.underline");
  (poVar2->value).number = 1;
  register_change_hooks(change_hooks);
  return;
}



// WARNING: Unknown calling convention

option_elinks * indirect_option(option_elinks *alias)

{
  option_elinks *real;
  
  if (alias->type != OPT_ALIAS) {
    real = alias;
    return real;
  }
  real = get_opt_rec(config_options,(alias->value).string);
  if (assert_failed == 0) {
    assert_failed = (int)(real == (option_elinks *)0x0);
    if (assert_failed == 0) {
      return real;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 0x10a;
    elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                    alias->name,(alias->value).tree);
    if (assert_failed == 0) {
      return real;
    }
  }
  assert_failed = 0;
  real = alias;
  return real;
}



// WARNING: Unknown calling convention

option_elinks * get_opt_rec_real(option_elinks *tree,uchar *name)

{
  option_elinks *opt;
  option_elinks *poVar1;
  
  no_autocreate = 1;
  poVar1 = get_opt_rec(tree,name);
  no_autocreate = 0;
  return poVar1;
}



// WARNING: Unknown calling convention

uchar * bool_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar uVar1;
  uchar **ppuVar2;
  
  (o->value).number = 1;
  if (*argc != 0) {
    ppuVar2 = *argv;
    uVar1 = **ppuVar2;
    if ((uVar1 != '\0') && ((*ppuVar2)[1] == '\0')) {
      if (uVar1 == '0') {
        (o->value).tree = (list_head_elinks *)0x0;
        ppuVar2 = *argv;
      }
      else {
        if (uVar1 != '1') {
          return (uchar *)0x0;
        }
        (o->value).number = 1;
      }
      *argv = ppuVar2 + 1;
      *argc = *argc + -1;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * exec_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x0807543d. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (*(o->value).command)(o,argv,argc);
  return puVar1;
}



// WARNING: Unknown calling convention

int num_set(option_elinks *opt,uchar *str)

{
  (opt->value).color = *(color_T *)str;
  return 1;
}



// WARNING: Unknown calling convention

int num_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    uVar1 = (uint)((opt->value).tree == *(list_head_elinks **)str);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int long_set(option_elinks *opt,uchar *str)

{
  (opt->value).color = *(color_T *)str;
  return 1;
}



// WARNING: Unknown calling convention

int long_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    uVar1 = (uint)((opt->value).tree == *(list_head_elinks **)str);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int str_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    iVar2 = strcmp((char *)(opt->value).string,(char *)str);
    uVar1 = (uint)(iVar2 == 0);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void tree_dup(option_elinks *opt,option_elinks *template)

{
  option_elinks *poVar1;
  option_elinks *template_00;
  listbox_item *plVar2;
  list_head_elinks *plVar3;
  option_elinks *poVar4;
  option_value *poVar5;
  int iVar6;
  list_head_elinks *new;
  option_elinks *new_opt;
  uchar *puVar7;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  
  bVar10 = 0;
  plVar3 = init_options_tree();
  poVar1 = (option_elinks *)(template->value).tree;
  if (plVar3 != (list_head_elinks *)0x0) {
    (opt->value).tree = plVar3;
    for (template_00 = poVar1->prev; template_00 != poVar1; template_00 = template_00->prev) {
      poVar4 = copy_option(template_00);
      if (poVar4 != (option_elinks *)0x0) {
                    // WARNING: Load size is inaccurate
        poVar4->next = *plVar3->prev;
        poVar4->prev = (option_elinks *)plVar3->prev;
        *(option_elinks **)plVar3->prev = poVar4;
        poVar4->next->prev = poVar4;
        plVar2 = poVar4->box_item;
        poVar4->root = opt;
        if (plVar2 != (listbox_item *)0x0) {
          bVar9 = poVar4->name == (uchar *)0x0;
          if (!bVar9) {
            iVar6 = 0xb;
            puVar7 = poVar4->name;
            puVar8 = "_template_";
            do {
              if (iVar6 == 0) break;
              iVar6 = iVar6 + -1;
              bVar9 = *puVar7 == *puVar8;
              puVar7 = puVar7 + (uint)bVar10 * -2 + 1;
              puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
            } while (bVar9);
            if (bVar9) {
              poVar5 = get_opt_();
              plVar2->field_0x18 = plVar2->field_0x18 & 0xfd | ((byte)poVar5->color & 1) * '\x02';
            }
          }
          if (opt->box_item != (listbox_item *)0x0) {
            poVar4->box_item->next = (listbox_item *)(opt->box_item->child).next;
            poVar4->box_item->prev = (listbox_item *)&opt->box_item->child;
            (opt->box_item->child).next = poVar4->box_item;
            poVar4->box_item->next->prev = poVar4->box_item;
          }
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int redir_eq(option_elinks *opt,uchar *str)

{
  option_elinks *poVar1;
  int iVar2;
  int ret;
  _func_int_option_elinks_ptr_uchar_ptr *p_Var3;
  option_elinks *real;
  uint local_20 [4];
  
  poVar1 = get_opt_rec(config_options,(opt->value).string);
  if (assert_failed == 0) {
    assert_failed = (int)(poVar1 == (option_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0xab;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,(opt->value).tree);
      if (assert_failed != 0) goto LAB_080756c0;
    }
    p_Var3 = option_types[poVar1->type].equals;
    iVar2 = 0;
    if (p_Var3 != (_func_int_option_elinks_ptr_uchar_ptr *)0x0) {
      if (((*(byte *)((int)&opt->flags + 1) & 1) != 0) && (poVar1->type == OPT_BOOL)) {
        iVar2 = *(int *)str;
        str = (uchar *)local_20;
        local_20[0] = (uint)(iVar2 == 0);
        p_Var3 = option_types[poVar1->type].equals;
      }
      iVar2 = (*p_Var3)(poVar1,str);
    }
  }
  else {
LAB_080756c0:
    assert_failed = 0;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int redir_set(option_elinks *opt,uchar *str)

{
  option_elinks *poVar1;
  int iVar2;
  int ret;
  _func_int_option_elinks_ptr_uchar_ptr *p_Var3;
  option_elinks *real;
  uint local_20 [4];
  
  poVar1 = get_opt_rec(config_options,(opt->value).string);
  if (assert_failed == 0) {
    assert_failed = (int)(poVar1 == (option_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0x95;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,(opt->value).tree);
      if (assert_failed != 0) goto LAB_080757b0;
    }
    p_Var3 = option_types[poVar1->type].set;
    iVar2 = 0;
    if (p_Var3 != (_func_int_option_elinks_ptr_uchar_ptr *)0x0) {
      if (((*(byte *)((int)&opt->flags + 1) & 1) != 0) && (poVar1->type == OPT_BOOL)) {
        iVar2 = *(int *)str;
        str = (uchar *)local_20;
        local_20[0] = (uint)(iVar2 == 0);
        p_Var3 = option_types[poVar1->type].set;
      }
      iVar2 = (*p_Var3)(poVar1,str);
    }
  }
  else {
LAB_080757b0:
    assert_failed = 0;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void redir_wr(option_elinks *opt,string *string)

{
  option_elinks *poVar1;
  option_elinks *real;
  
  poVar1 = get_opt_rec(config_options,(opt->value).string);
  if (assert_failed == 0) {
    assert_failed = (int)(poVar1 == (option_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0x88;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,(opt->value).tree);
      if (assert_failed != 0) goto LAB_08075890;
    }
    if (option_types[poVar1->type].write != (_func_void_option_elinks_ptr_string_ptr *)0x0) {
                    // WARNING: Could not recover jumptable at 0x08075849. Too many branches
                    // WARNING: Treating indirect jump as call
      (*option_types[poVar1->type].write)(poVar1,string);
      return;
    }
  }
  else {
LAB_08075890:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * redir_rd(option_elinks *opt,uchar **file,int *line)

{
  option_elinks *poVar1;
  uint *puVar2;
  uchar *ret;
  option_elinks *real;
  
  poVar1 = get_opt_rec(config_options,(opt->value).string);
  if (assert_failed == 0) {
    assert_failed = (int)(poVar1 == (option_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 0x76;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,(opt->value).tree);
      if (assert_failed != 0) goto LAB_080758db;
    }
    puVar2 = (uint *)0x0;
    if ((((option_types[poVar1->type].read !=
           (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_int_ptr *)0x0) &&
         (puVar2 = (uint *)(*option_types[poVar1->type].read)(poVar1,file,line),
         puVar2 != (uint *)0x0)) && ((*(byte *)((int)&opt->flags + 1) & 1) != 0)) &&
       (poVar1->type == OPT_BOOL)) {
      *puVar2 = (uint)(*puVar2 == 0);
      return (uchar *)puVar2;
    }
  }
  else {
LAB_080758db:
    assert_failed = 0;
    puVar2 = (uint *)0x0;
  }
  return (uchar *)puVar2;
}



// WARNING: Unknown calling convention

uchar * redir_cmd(option_elinks *opt,uchar ***argv,int *argc)

{
  option_elinks *poVar1;
  uchar *puVar2;
  uchar *ret;
  option_value oVar3;
  option_elinks *real;
  
  poVar1 = get_opt_rec(config_options,(opt->value).string);
  if (assert_failed == 0) {
    assert_failed = (int)(poVar1 == (option_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 99;
      elinks_internal((uchar *)"assertion real != NULL failed: %s aliased to unknown option %s!",
                      opt->name,(opt->value).tree);
      if (assert_failed != 0) goto LAB_080759bb;
    }
    puVar2 = (uchar *)0x0;
    if (((option_types[poVar1->type].cmdline !=
          (_func_uchar_ptr_option_elinks_ptr_uchar_ptr_ptr_ptr_int_ptr *)0x0) &&
        (puVar2 = (*option_types[poVar1->type].cmdline)(poVar1,argv,argc),
        (*(byte *)((int)&opt->flags + 1) & 1) != 0)) && (poVar1->type == OPT_BOOL)) {
      oVar3.number._1_3_ = 0;
      oVar3.number._0_1_ = (poVar1->value).tree == (list_head_elinks *)0x0;
      poVar1->value = oVar3;
      return puVar2;
    }
  }
  else {
LAB_080759bb:
    assert_failed = 0;
    puVar2 = (uchar *)0x0;
  }
  return puVar2;
}



// WARNING: Unknown calling convention

uchar * get_option_type_name(option_type type)

{
  if (assert_failed == 0) {
    assert_failed = (int)(OPT_TREE < type);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 500;
      elinks_internal((uchar *)
                      "assertion type >= 0 && type < sizeof(option_types)/sizeof(struct option_type_info) failed!"
                     );
      if (assert_failed != 0) goto LAB_08075ad8;
    }
    return option_types[type].name;
  }
LAB_08075ad8:
  assert_failed = 0;
  return "";
}



// WARNING: Unknown calling convention

int color_eq(option_elinks *opt,uchar *str)

{
  size_t slen;
  int iVar1;
  list_head_elinks *local_10 [2];
  
  if (str != (uchar *)0x0) {
    slen = strlen((char *)str);
    iVar1 = decode_color(str,slen,(color_T *)local_10);
    if (iVar1 == 0) {
      return (uint)((opt->value).tree == local_10[0]);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int color_set(option_elinks *opt,uchar *str)

{
  size_t slen;
  int iVar1;
  
  slen = strlen((char *)str);
  iVar1 = decode_color(str,slen,&(opt->value).color);
  return (uint)(iVar1 == 0);
}



// WARNING: Unknown calling convention

void add_optstring_to_string(string *s,uchar *q,int qlen)

{
  if (commandline == 0) {
    add_char_to_string(s,'\"');
  }
  add_quoted_to_string(s,q,qlen);
  if (commandline == 0) {
    add_char_to_string(s,'\"');
  }
  return;
}



// WARNING: Unknown calling convention

void color_wr(option_elinks *opt,string *str)

{
  int iVar1;
  uchar *q;
  uchar *strcolor;
  size_t qlen;
  int in_GS_OFFSET;
  uchar hexcolor [8];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  q = get_color_string((opt->value).color,hexcolor);
  qlen = strlen((char *)q);
  add_optstring_to_string(str,q,qlen);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void str_wr(option_elinks *o,string *s)

{
  uchar *q;
  size_t sVar1;
  size_t qlen;
  int len;
  
  q = (o->value).string;
  sVar1 = strlen((char *)q);
  qlen = o->max - 1;
  if ((int)sVar1 <= (int)qlen) {
    qlen = sVar1;
  }
  add_optstring_to_string(s,q,qlen);
  return;
}



// WARNING: Unknown calling convention

int lang_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  list_head_elinks *plVar2;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    plVar2 = (list_head_elinks *)name_to_language(str);
    uVar1 = (uint)(plVar2 == (opt->value).tree);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int lang_set(option_elinks *opt,uchar *str)

{
  int language;
  
  language = name_to_language(str);
  (opt->value).number = language;
  set_language(language);
  return 1;
}



// WARNING: Unknown calling convention

void lang_wr(option_elinks *o,string *s)

{
  uchar *q;
  uchar *lang;
  size_t qlen;
  
  q = language_to_name(current_language);
  qlen = strlen((char *)q);
  add_optstring_to_string(s,q,qlen);
  return;
}



// WARNING: Unknown calling convention

int cp_eq(option_elinks *opt,uchar *str)

{
  uint uVar1;
  list_head_elinks *plVar2;
  
  uVar1 = 0;
  if (str != (uchar *)0x0) {
    plVar2 = (list_head_elinks *)get_cp_index(str);
    uVar1 = (uint)(plVar2 == (opt->value).tree);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int cp_set(option_elinks *opt,uchar *str)

{
  int iVar1;
  int ret;
  
  iVar1 = get_cp_index(str);
  if (-1 < iVar1) {
    (opt->value).number = iVar1;
  }
  return (uint)(-1 < iVar1);
}



// WARNING: Unknown calling convention

void cp_wr(option_elinks *o,string *s)

{
  uchar *q;
  uchar *mime_name;
  size_t qlen;
  
  q = get_cp_config_name((o->value).number);
  qlen = strlen((char *)q);
  add_optstring_to_string(s,q,qlen);
  return;
}



// WARNING: Unknown calling convention

int str_set(option_elinks *opt,uchar *str)

{
  if ((assert_failed == 0) &&
     (assert_failed = (int)((opt->value).tree == (list_head_elinks *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
    errline = 0x141;
    elinks_internal((uchar *)"assertion opt->value.string failed!");
  }
  safe_strncpy((opt->value).string,str,0x400);
  return 1;
}



// WARNING: Unknown calling convention

void str_dup(option_elinks *opt,option_elinks *template)

{
  uchar *dst;
  uchar *new;
  
  dst = (uchar *)mem_alloc(0x400);
  if (dst != (uchar *)0x0) {
    safe_strncpy(dst,(template->value).string,0x400);
  }
  (opt->value).string = dst;
  return;
}



// WARNING: Unknown calling convention

uchar * str_rd(option_elinks *opt,uchar **file,int *line)

{
  uchar uVar1;
  string *psVar2;
  uchar *puVar3;
  uchar *str;
  uchar *puVar4;
  uchar *puVar5;
  string str2;
  
  puVar5 = *file;
  psVar2 = init_string(&str2);
  if (psVar2 == (string *)0x0) {
    return (uchar *)0x0;
  }
  if (commandline == 0) {
    if ((*puVar5 != '\'') && (*puVar5 != '\"')) goto LAB_08075fcb;
    puVar5 = puVar5 + 1;
  }
  uVar1 = *puVar5;
  while (uVar1 != '\0') {
    if ((commandline == 0) && ((uVar1 == '\'' || (uVar1 == '\"')))) {
      if (uVar1 == '\0') goto LAB_08075fa2;
      *file = puVar5 + 1;
      goto LAB_08075f64;
    }
    puVar4 = puVar5 + 1;
    puVar3 = puVar5;
    if (uVar1 == '\\') {
      uVar1 = puVar5[1];
      puVar3 = puVar5 + 1;
      if (uVar1 == '\n') {
        puVar5[1] = ' ';
        puVar4 = puVar5 + 2;
        *line = *line + 1;
        goto LAB_08075ed8;
      }
      if ((uVar1 == '\'') || (uVar1 == '\"')) {
        puVar4 = puVar5 + 2;
      }
      else {
        puVar4 = puVar3;
        puVar3 = puVar5;
        if (uVar1 != '\\') goto LAB_08075ed8;
        puVar4 = puVar5 + 2;
      }
    }
    else {
LAB_08075ed8:
      uVar1 = *puVar3;
      if (uVar1 == '\n') {
        *line = *line + 1;
        uVar1 = *puVar3;
      }
    }
    add_char_to_string(&str2,uVar1);
    puVar5 = puVar4;
    uVar1 = *puVar4;
  }
  if (commandline == 0) {
LAB_08075fa2:
    done_string(&str2);
    *file = puVar5;
    return (uchar *)0x0;
  }
LAB_08075f64:
  if (opt == (option_elinks *)0x0) {
    return str2.source;
  }
  if (opt->max == 0) {
    return str2.source;
  }
  if (str2.length < opt->max) {
    return str2.source;
  }
LAB_08075fcb:
  done_string(&str2);
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void long_wr(option_elinks *option_elinks,string *string)

{
  add_knum_to_string(string,(option_elinks->value).big_number);
  return;
}



// WARNING: Unknown calling convention

void num_wr(option_elinks *option_elinks,string *string)

{
  add_knum_to_string(string,(option_elinks->value).big_number);
  return;
}



// WARNING: Unknown calling convention

uchar * gen_cmd(option_elinks *o,uchar ***argv,int *argc)

{
  uchar *puVar1;
  uchar *str;
  int iVar2;
  int local_20 [4];
  
  local_20[0] = 0;
  if (*argc == 0) {
    puVar1 = gettext((uchar *)"Parameter expected");
  }
  else {
    commandline = 1;
    puVar1 = (*option_types[o->type].read)(o,*argv,local_20);
    commandline = 0;
    if (puVar1 != (uchar *)0x0) {
      *argv = *argv + 1;
      *argc = *argc + -1;
      iVar2 = (*option_types[o->type].set)(o,puVar1);
      if (iVar2 != 0) {
        mem_free(puVar1);
        return (uchar *)0x0;
      }
      mem_free(puVar1);
    }
    puVar1 = gettext((uchar *)"Read error");
  }
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * num_rd(option_elinks *opt,uchar **file,int *line)

{
  byte bVar1;
  int *p;
  long lVar2;
  ushort **ppuVar3;
  int *piVar4;
  long *value;
  byte *local_20 [4];
  
  local_20[0] = *file;
  p = (int *)mem_alloc(4);
  piVar4 = (int *)0x0;
  if (p != (int *)0x0) {
    lVar2 = strtolx(*file,local_20);
    *p = lVar2;
    if (commandline == 0) {
      *file = local_20[0];
    }
    bVar1 = *local_20[0];
    if ((((bVar1 != 0) &&
         ((commandline != 0 ||
          ((ppuVar3 = __ctype_b_loc(), (*(byte *)((int)*ppuVar3 + (uint)bVar1 * 2 + 1) & 0x20) == 0
           && (bVar1 != 0x23)))))) || (*p < opt->min)) || (piVar4 = p, opt->max < *p)) {
      mem_free(p);
      piVar4 = (int *)0x0;
    }
  }
  return (uchar *)piVar4;
}



// WARNING: Unknown calling convention

void done_timer(module *module)

{
  kill_timer(&periodic_save_timer);
  return;
}



// WARNING: Unknown calling convention

void periodic_save_handler(void *xxx)

{
  option_value *poVar1;
  milliseconds_T delay;
  milliseconds_T interval;
  char *pcVar2;
  
  pcVar2 = "anonymous";
  poVar1 = get_opt_();
  if (poVar1->tree == (list_head_elinks *)0x0) {
    if (periodic_save_handler::periodic_save_event_id == -1) {
      periodic_save_handler::periodic_save_event_id = get_event_id((uchar *)"periodic-saving");
    }
    else {
      trigger_event(periodic_save_handler::periodic_save_event_id,pcVar2);
    }
    poVar1 = get_opt_();
    delay = sec_to_ms(poVar1->big_number);
    if (delay != 0) {
      install_timer(&periodic_save_timer,delay,periodic_save_handler,(void *)0x0);
      return;
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(periodic_save_timer != (timer_id_T)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/timer.c";
      errline = 0x2a;
      elinks_internal((uchar *)"assertion periodic_save_timer == TIMER_ID_UNDEF failed!");
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void init_timer(module *module)

{
  register_change_hooks(init_timer::timer_change_hooks);
  periodic_save_handler((void *)0x0);
  return;
}



// WARNING: Unknown calling convention

int periodic_save_change_hook(session *ses,option_elinks *current,option_elinks *changed)

{
  option_value *poVar1;
  
  poVar1 = get_opt_();
  if (poVar1->tree == (list_head_elinks *)0x0) {
    kill_timer(&periodic_save_timer);
    periodic_save_handler((void *)0x0);
  }
  return 0;
}



// WARNING: Unknown calling convention

evhook_status goto_url_history_write_hook(va_list ap,void *data)

{
  save_input_history(&goto_url_history,(uchar *)"gotohist");
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

void done_url_history(module *module)

{
  input_history *piVar1;
  input_history *piVar2;
  input_history *piVar3;
  xlist_head *head;
  input_history *piVar4;
  xlist_head *next;
  
  save_input_history(&goto_url_history,(uchar *)"gotohist");
  piVar4 = (input_history *)goto_url_history.entries.next;
  piVar1 = (input_history *)goto_url_history.entries.prev;
  if ((input_history *)goto_url_history.entries.next != &goto_url_history) {
    do {
      piVar4 = (input_history *)(piVar4->entries).next;
    } while (piVar4 != &goto_url_history);
  }
  for (; piVar1 != piVar4; piVar1 = (input_history *)(piVar1->entries).prev) {
  }
                    // WARNING: Load size is inaccurate
  piVar3 = *goto_url_history.entries.next;
  piVar1 = (input_history *)goto_url_history.entries.next;
  while (piVar2 = piVar3, piVar1 != piVar4) {
    (piVar2->entries).prev = (piVar1->entries).prev;
    *(void **)(piVar1->entries).prev = (piVar1->entries).next;
    mem_free(piVar1);
    piVar3 = (input_history *)(piVar2->entries).next;
    piVar1 = piVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void init_url_history(module *module)

{
  load_input_history(&goto_url_history,(uchar *)"gotohist");
  return;
}



// WARNING: Unknown calling convention

void save_cookies(terminal *term)

{
  void *pvVar1;
  void **ppvVar2;
  option_value *poVar3;
  uchar *puVar4;
  secure_save_info *ssi;
  time_t tVar5;
  int iVar6;
  undefined1 *puVar7;
  undefined1 *puVar8;
  cookie *c;
  list_head_elinks *plVar9;
  char *text;
  
  if (cookies_nosave != 0) {
    if (assert_failed == 0) {
      assert_failed = (int)(term != (terminal *)0x0);
      if (assert_failed == 0) {
        return;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/cookies.c";
      errline = 0x339;
      elinks_internal((uchar *)"assertion term == NULL failed!");
      if (assert_failed == 0) {
        return;
      }
    }
    assert_failed = 0;
    return;
  }
  if (elinks_home == (uchar *)0x0) {
    if (term == (terminal *)0x0) {
      return;
    }
    text = "ELinks was started without a home directory.";
  }
  else {
    if ((term == (terminal *)0x0) && (cookies_dirty == 0)) {
      return;
    }
    poVar3 = get_opt_();
    if (poVar3->tree == (list_head_elinks *)0x0) {
      puVar4 = straconcat(elinks_home,"cookies",0);
      if (puVar4 != (uchar *)0x0) {
        ssi = secure_open(puVar4);
        mem_free(puVar4);
        if (ssi != (secure_save_info *)0x0) {
          tVar5 = time((time_t *)0x0);
          plVar9 = (list_head_elinks *)cookies.next;
          if ((list_head_elinks *)cookies.next != &cookies) {
            do {
              pvVar1 = plVar9[4].next;
              if ((pvVar1 != (void *)0x0) && (tVar5 < (int)pvVar1)) {
                puVar7 = (undefined1 *)plVar9[3].next;
                if (puVar7 == (undefined1 *)0x0) {
                  puVar7 = &DAT_0812e3d8;
                }
                puVar8 = (undefined1 *)plVar9[2].prev;
                if (puVar8 == (undefined1 *)0x0) {
                  puVar8 = &DAT_0812e3d8;
                }
                iVar6 = secure_fprintf(ssi,"%s\t%s\t%s\t%s\t%s\t%ld\t%d\n",plVar9[1].prev,
                                       plVar9[2].next,(int)plVar9[3].prev + 0x10,puVar8,puVar7,
                                       pvVar1,plVar9[4].prev);
                if (iVar6 < 0) break;
              }
              ppvVar2 = &plVar9->next;
              plVar9 = (list_head_elinks *)*ppvVar2;
            } while ((list_head_elinks *)*ppvVar2 != &cookies);
          }
          secsave_errno = SS_ERR_OTHER;
          iVar6 = secure_close(ssi);
          if (iVar6 == 0) {
            cookies_dirty = 0;
            return;
          }
        }
        if (term == (terminal *)0x0) {
          return;
        }
        puVar4 = secsave_strerror(secsave_errno,term);
        info_box(term,MSGBOX_NO_TEXT_INTL,(uchar *)"Cannot save cookies",ALIGN_LEFT,puVar4);
        return;
      }
      if (term == (terminal *)0x0) {
        return;
      }
      text = "Out of memory";
    }
    else {
      if (term == (terminal *)0x0) {
        return;
      }
      text = "ELinks was started with the -anonymous option.";
    }
  }
  info_box(term,0,(uchar *)"Cannot save cookies",ALIGN_LEFT,(uchar *)text);
  return;
}



// WARNING: Unknown calling convention

void resave_cookies_bottom_half(void *always_null)

{
  if ((cookies_options[4].option_elinks.value.tree != (list_head_elinks *)0x0) &&
     (cookies_options[5].option_elinks.value.tree != (list_head_elinks *)0x0)) {
    save_cookies((terminal *)0x0);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void set_cookies_dirty(void)

{
  cookies_dirty = 1;
  register_bottom_half_do(resave_cookies_bottom_half,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

cookie_server * get_cookie_server(uchar *host,int hostlen)

{
  cookie_server *pcVar1;
  int cmp;
  size_t sVar2;
  int iVar3;
  cookie_server *data;
  listbox_item *plVar4;
  cookie_server *cs;
  list_head_elinks *local_24;
  cookie_server *local_20;
  
  if ((list_head_elinks *)cookie_servers.next == &cookie_servers) {
    local_20 = (cookie_server *)0x0;
    local_24 = &cookie_servers;
  }
  else {
    local_20 = (cookie_server *)0x0;
    local_24 = (list_head_elinks *)cookie_servers.next;
    do {
      sVar2 = strlen((char *)(uchar *)((int)local_24 + 0x10));
      iVar3 = c_strncasecmp((char *)(uchar *)((int)local_24 + 0x10),(char *)host,hostlen);
      if ((local_20 == (cookie_server *)0x0) &&
         ((0 < iVar3 || ((hostlen < (int)sVar2 && (iVar3 == 0)))))) {
        local_20 = (cookie_server *)local_24->prev;
      }
      if ((sVar2 == hostlen) && (iVar3 == 0)) {
        ((object *)((int)local_24 + 8))->refcount = ((object *)((int)local_24 + 8))->refcount + 1;
        return (cookie_server *)local_24;
      }
      local_24 = (list_head_elinks *)local_24->next;
    } while (local_24 != &cookie_servers);
  }
  data = (cookie_server *)mem_calloc(1,hostlen + 0x14);
  if (data != (cookie_server *)0x0) {
    memcpy(data->host,host,hostlen);
    plVar4 = add_listbox_item(&cookie_browser,(listbox_item *)0x0,BI_FOLDER,data,1);
    (data->object).refcount = (data->object).refcount + 1;
    data->box_item = plVar4;
    if (local_20 == (cookie_server *)0x0) {
                    // WARNING: Load size is inaccurate
      data->next = *cookie_servers.prev;
      data->prev = (cookie_server *)cookie_servers.prev;
      *(cookie_server **)cookie_servers.prev = data;
      data->next->prev = data;
      data->box_item->next->prev = data->box_item->prev;
      data->box_item->prev->next = data->box_item->next;
                    // WARNING: Load size is inaccurate
      data->box_item->next = *cookie_browser.root.child.prev;
      data->box_item->prev = (listbox_item *)cookie_browser.root.child.prev;
      *(listbox_item **)cookie_browser.root.child.prev = data->box_item;
      data->box_item->next->prev = data->box_item;
    }
    else {
      pcVar1 = local_20->next;
      data->prev = local_20;
      data->next = pcVar1;
      local_20->next = data;
      data->next->prev = data;
      if ((cookie_server *)local_24 != local_20) {
        data->box_item->next->prev = data->box_item->prev;
        data->box_item->prev->next = data->box_item->next;
        data->box_item->next = local_20->box_item->next;
        data->box_item->prev = local_20->box_item;
        local_20->box_item->next = data->box_item;
        data->box_item->next->prev = data->box_item;
      }
    }
  }
  return data;
}



// WARNING: Unknown calling convention

void done_cookie_server(cookie_server *cs)

{
  int iVar1;
  
  iVar1 = (cs->object).refcount + -1;
  (cs->object).refcount = iVar1;
  if (iVar1 == 0) {
    if (cs->box_item != (listbox_item *)0x0) {
      done_listbox_item(&cookie_browser,cs->box_item);
    }
    cs->next->prev = cs->prev;
    cs->prev->next = cs->next;
    mem_free(cs);
  }
  return;
}



// WARNING: Unknown calling convention

cookie * init_cookie(uchar *name,uchar *value,uchar *path,uchar *domain,cookie_server *server)

{
  cookie *p;
  cookie *cookie;
  
  p = (cookie *)mem_calloc(1,0x2c);
  if (p != (cookie *)0x0) {
    if ((((name != (uchar *)0x0) && (path != (uchar *)0x0)) && (value != (uchar *)0x0)) &&
       ((server != (cookie_server *)0x0 && (domain != (uchar *)0x0)))) {
      p->name = name;
      p->value = value;
      p->path = path;
      p->domain = domain;
      p->server = server;
      return p;
    }
    if (p != (cookie *)0x0) {
      mem_free(p);
    }
  }
  if (name != (uchar *)0x0) {
    mem_free(name);
  }
  if (value != (uchar *)0x0) {
    mem_free(value);
  }
  if (path != (uchar *)0x0) {
    mem_free(path);
  }
  if (domain != (uchar *)0x0) {
    mem_free(domain);
  }
  done_cookie_server(server);
  return (cookie *)0x0;
}



// WARNING: Unknown calling convention

void done_cookie(cookie *c)

{
  void *p;
  void *p_1;
  void *p_2;
  void *p_3;
  
  if (c->box_item != (listbox_item *)0x0) {
    done_listbox_item(&cookie_browser,c->box_item);
  }
  if (c->server != (cookie_server *)0x0) {
    done_cookie_server(c->server);
  }
  if (c->name != (uchar *)0x0) {
    mem_free(c->name);
  }
  if (c->value != (uchar *)0x0) {
    mem_free(c->value);
  }
  if (c->path != (uchar *)0x0) {
    mem_free(c->path);
  }
  if (c->domain != (uchar *)0x0) {
    mem_free(c->domain);
  }
  mem_free(c);
  return;
}



// WARNING: Unknown calling convention

void delete_cookie(cookie *c)

{
  c->next->prev = c->prev;
  c->prev->next = c->next;
  done_cookie(c);
  return;
}



// WARNING: Unknown calling convention

void done_cookies(module *module)

{
  void **ppvVar1;
  xlist_head *head;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  xlist_head *next;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)c_domains.next;
  if ((list_head_elinks *)c_domains.next != &c_domains) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &c_domains);
  }
  plVar2 = (list_head_elinks *)c_domains.prev;
  if ((list_head_elinks *)c_domains.prev != plVar3) {
    do {
      ppvVar1 = &plVar2->prev;
      plVar2 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != plVar3);
  }
                    // WARNING: Load size is inaccurate
  plVar2 = *c_domains.next;
  p = (list_head_elinks *)c_domains.next;
  if ((list_head_elinks *)c_domains.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  if (cookies_nosave != 0) goto LAB_08076ad8;
  if (cookies_options[4].option_elinks.value.tree == (list_head_elinks *)0x0) goto LAB_08076ad8;
  save_cookies((terminal *)0x0);
  if ((list_head_elinks *)cookies.next != &cookies) {
    do {
      delete_cookie((cookie *)cookies.next);
LAB_08076ad8:
    } while ((list_head_elinks *)cookies.next != &cookies);
    cookies.next = &cookies;
  }
  while ((list_head_elinks *)cookie_queries.next != &cookie_queries) {
    delete_cookie((cookie *)cookie_queries.next);
  }
  cookies_dirty = 0;
  return;
}



// WARNING: Unknown calling convention

string * send_cookies(uri *uri)

{
  cookie *pcVar1;
  int iVar2;
  uchar *puVar3;
  time_t tVar4;
  cookie *next;
  size_t sVar5;
  size_t sVar6;
  cookie *c;
  cookie *c_00;
  c_domain *cd;
  list_head_elinks *plVar7;
  uchar *__s;
  uchar *path;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  cookie *local_20;
  
  bVar10 = 0;
  puVar3 = uri->host;
  if (((puVar3 != (uchar *)0x0) && (uri->data != (uchar *)0x0)) &&
     (plVar7 = (list_head_elinks *)c_domains.next, (list_head_elinks *)c_domains.next != &c_domains)
     ) {
    while (iVar2 = is_in_domain((uchar *)(plVar7 + 1),puVar3,(uint)*(ushort *)&uri->field_0x2e),
          iVar2 == 0) {
      plVar7 = (list_head_elinks *)plVar7->next;
      if (plVar7 == &c_domains) {
        return (string *)0x0;
      }
      puVar3 = uri->host;
    }
    puVar3 = get_uri_string(uri,URI_PATH);
    if (puVar3 != (uchar *)0x0) {
      init_string(&send_cookies::header);
      tVar4 = time((time_t *)0x0);
                    // WARNING: Load size is inaccurate
      c_00 = (cookie *)cookies.next;
      local_20 = *cookies.next;
      if ((list_head_elinks *)cookies.next != &cookies) {
        do {
          iVar2 = is_in_domain(c_00->domain,uri->host,(uint)*(ushort *)&uri->field_0x2e);
          if (iVar2 == 0) {
LAB_08076be0:
            pcVar1 = local_20->next;
          }
          else {
            __s = c_00->path;
            sVar5 = strlen((char *)__s);
            sVar6 = strlen((char *)puVar3);
            if (sVar6 < sVar5) goto LAB_08076be0;
            bVar9 = true;
            puVar8 = puVar3;
            do {
              if (sVar5 == 0) break;
              sVar5 = sVar5 - 1;
              bVar9 = *__s == *puVar8;
              __s = __s + (uint)bVar10 * -2 + 1;
              puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
            } while (bVar9);
            if (!bVar9) goto LAB_08076be0;
            if ((c_00->expires != 0) && (c_00->expires <= tVar4)) {
              delete_cookie(c_00);
              set_cookies_dirty();
              goto LAB_08076be0;
            }
            if ((c_00->secure != 0) && (uri->protocol != 10)) goto LAB_08076be0;
            if (send_cookies::header.length != 0) {
              add_to_string(&send_cookies::header,"; ");
            }
            add_to_string(&send_cookies::header,c_00->name);
            add_char_to_string(&send_cookies::header,'=');
            add_to_string(&send_cookies::header,c_00->value);
            pcVar1 = local_20->next;
          }
          bVar9 = local_20 != (cookie *)&cookies;
          c_00 = local_20;
          local_20 = pcVar1;
        } while (bVar9);
      }
      mem_free(puVar3);
      if (send_cookies::header.length == 0) {
        done_string(&send_cookies::header);
        return (string *)0x0;
      }
      return &send_cookies::header;
    }
  }
  return (string *)0x0;
}



// WARNING: Unknown calling convention

void accept_cookie(cookie *cookie)

{
  void *pvVar1;
  listbox_item *root;
  listbox_item *plVar2;
  int iVar3;
  size_t sVar4;
  void **ppvVar5;
  cookie *c;
  c_domain *cd;
  list_head_elinks *plVar6;
  cookie *c_00;
  cookie *next;
  cookie *pcVar7;
  bool bVar8;
  
  plVar2 = cookie->server->box_item;
  if (plVar2 != (listbox_item *)0x0) {
    plVar2 = add_listbox_item(&cookie_browser,plVar2,BI_LEAF,cookie,1);
    cookie->box_item = plVar2;
  }
                    // WARNING: Load size is inaccurate
  if ((cookies_nosave == 0) &&
     (c_00 = (cookie *)cookies.next, pcVar7 = *cookies.next,
     (list_head_elinks *)cookies.next != &cookies)) {
    do {
      iVar3 = c_strcasecmp((char *)c_00->name,(char *)cookie->name);
      if ((iVar3 == 0) &&
         (iVar3 = c_strcasecmp((char *)c_00->domain,(char *)cookie->domain), iVar3 == 0)) {
        delete_cookie(c_00);
      }
      bVar8 = pcVar7 != (cookie *)&cookies;
      c_00 = pcVar7;
      pcVar7 = pcVar7->next;
    } while (bVar8);
  }
  cookie->prev = (cookie *)&cookies;
  cookie->next = (cookie *)cookies.next;
  cookies.next = cookie;
  cookie->next->prev = cookie;
  set_cookies_dirty();
  plVar6 = (list_head_elinks *)c_domains.next;
  if ((list_head_elinks *)c_domains.next == &c_domains) {
    plVar6 = &c_domains;
  }
  else {
    do {
      iVar3 = c_strcasecmp((char *)(plVar6 + 1),(char *)cookie->domain);
      if (iVar3 == 0) {
        return;
      }
      plVar6 = (list_head_elinks *)plVar6->next;
    } while (plVar6 != &c_domains);
  }
  sVar4 = strlen((char *)cookie->domain);
  ppvVar5 = (void **)mem_alloc(sVar4 + 0xc);
  if (ppvVar5 == (void **)0x0) {
    return;
  }
  memcpy(ppvVar5 + 2,cookie->domain,sVar4 + 1);
  pvVar1 = plVar6->next;
  ppvVar5[1] = plVar6;
  *ppvVar5 = pvVar1;
  plVar6->next = ppvVar5;
  *(void ***)((int)*ppvVar5 + 4) = ppvVar5;
  return;
}



// WARNING: Unknown calling convention

void load_cookies(void)

{
  int iVar1;
  FILE *__stream;
  time_t tVar2;
  char *pcVar3;
  long lVar4;
  cookie *c;
  cookie_server *pcVar5;
  uchar *puVar6;
  uchar *cookfile;
  uchar *q;
  anon_enum_32 member;
  int iVar7;
  int iVar8;
  int in_GS_OFFSET;
  anon_struct_8_2_43e60426 members [7];
  uchar in_buffer [6144];
  
  puVar6 = "cookies";
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((elinks_home == (uchar *)0x0) ||
     (puVar6 = straconcat(elinks_home,"cookies",0), puVar6 != (uchar *)0x0)) {
    cookies_nosave = 1;
    done_cookies(&cookies_module);
    cookies_nosave = 0;
    __stream = fopen64((char *)puVar6,"rb");
    if (elinks_home != (uchar *)0x0) {
      mem_free(puVar6);
    }
    if (__stream != (FILE *)0x0) {
      cookies_nosave = 1;
      tVar2 = time((time_t *)0x0);
LAB_08076f35:
      pcVar3 = fgets((char *)in_buffer,0x1800,__stream);
      if (pcVar3 != (char *)0x0) {
        iVar8 = 0;
        iVar7 = 0;
        puVar6 = in_buffer;
        while (pcVar3 = strchr((char *)puVar6,9), pcVar3 != (char *)0x0) {
          iVar8 = iVar8 + 1;
          members[iVar7].pos = puVar6;
          members[iVar7].len = (int)pcVar3 - (int)puVar6;
          iVar7 = iVar7 + 1;
          if (iVar8 == 7) {
            if (iVar7 == 7) goto LAB_08076fd3;
            goto LAB_08076f35;
          }
          puVar6 = (uchar *)(pcVar3 + 1);
        }
        if ((iVar7 == 6) && (pcVar3 = strchr((char *)puVar6,10), pcVar3 != (char *)0x0)) {
          members[6].len = (int)pcVar3 - (int)puVar6;
          members[6].pos = puVar6;
LAB_08076fd3:
          lVar4 = strtol((char *)members[5].pos,(char **)0x0,10);
          if ((tVar2 < lVar4) && (lVar4 != 0)) {
            c = (cookie *)mem_calloc(1,0x2c);
            if (c != (cookie *)0x0) {
              pcVar5 = get_cookie_server(members[2].pos,members[2].len);
              c->server = pcVar5;
              puVar6 = memacpy(members[0].pos,members[0].len);
              c->name = puVar6;
              puVar6 = memacpy(members[1].pos,members[1].len);
              c->value = puVar6;
              puVar6 = memacpy(members[3].pos,members[3].len);
              c->path = puVar6;
              puVar6 = memacpy(members[4].pos,members[4].len);
              c->domain = puVar6;
              if ((((c->server == (cookie_server *)0x0) || (c->name == (uchar *)0x0)) ||
                  (c->value == (uchar *)0x0)) ||
                 ((c->path == (uchar *)0x0 || (puVar6 == (uchar *)0x0)))) {
                done_cookie(c);
              }
              else {
                c->expires = lVar4;
                lVar4 = strtol((char *)members[6].pos,(char **)0x0,10);
                c->secure = (uint)(lVar4 != 0);
                accept_cookie(c);
              }
            }
          }
          else {
            set_cookies_dirty();
          }
        }
        goto LAB_08076f35;
      }
      cookies_nosave = 0;
      fclose(__stream);
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void init_cookies(module *module)

{
  if (cookies_options[4].option_elinks.value.tree == (list_head_elinks *)0x0) {
    return;
  }
  load_cookies();
  return;
}



// WARNING: Unknown calling convention

void set_cookie(uri *uri,uchar *str)

{
  option_value oVar1;
  cookie_str *pcVar2;
  parse_header_param pVar3;
  size_t sVar4;
  cookie_server *server;
  uchar *puVar5;
  uchar *name;
  cookie *c;
  time_t tVar6;
  time_t tVar7;
  int iVar8;
  time_t deadline;
  uint addresslen;
  uchar *puVar9;
  char *pcVar10;
  int pos;
  time_t expires;
  int need_dots;
  uchar uVar11;
  int max_age;
  uchar *puVar12;
  cookie *cookie;
  cookie_str cstr;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  if (cookies_options[1].option_elinks.value.tree == (list_head_elinks *)0x0) {
    return;
  }
  pcVar2 = parse_cookie_str(&cstr,str);
  if (pcVar2 == (cookie_str *)0x0) {
    return;
  }
  pVar3 = parse_header_param(str,"path",local_20);
  puVar9 = local_20[0];
  if (pVar3 == HEADER_PARAM_FOUND) {
    uVar11 = *local_20[0];
    if ((uVar11 == '\0') || (sVar4 = strlen((char *)local_20[0]), puVar9[sVar4 - 1] != '/')) {
      add_to_strn(local_20,"/");
      uVar11 = *local_20[0];
    }
    if (uVar11 != '/') {
      add_to_strn(local_20,"x");
      puVar9 = local_20[0];
      sVar4 = strlen((char *)local_20[0]);
      memmove(puVar9 + 1,puVar9,sVar4 - 1);
      *local_20[0] = '/';
    }
  }
  else {
    if (pVar3 != HEADER_PARAM_NOT_FOUND) {
      return;
    }
    local_20[0] = get_uri_string(uri,URI_PATH);
    if (local_20[0] == (uchar *)0x0) {
      return;
    }
    pcVar10 = strrchr((char *)local_20[0],0x2f);
    if (pcVar10 != (char *)0x0) {
      pcVar10[1] = '\0';
    }
  }
  pVar3 = parse_header_param(str,"domain",&local_24);
  if (pVar3 == HEADER_PARAM_NOT_FOUND) {
    local_24 = memacpy(uri->host,(uint)*(ushort *)&uri->field_0x2e);
  }
  puVar9 = local_24;
  if ((local_24 != (uchar *)0x0) && (*local_24 == '.')) {
    sVar4 = strlen((char *)local_24);
    memmove(puVar9,puVar9 + 1,sVar4);
  }
  server = get_cookie_server(uri->host,(uint)*(ushort *)&uri->field_0x2e);
  puVar12 = local_20[0];
  puVar9 = local_24;
  puVar5 = memacpy(cstr.val_start,(int)cstr.val_end - (int)cstr.val_start);
  name = memacpy(str,(int)cstr.nam_end - (int)str);
  c = init_cookie(name,puVar5,puVar12,puVar9,server);
  oVar1 = cookies_options[2].option_elinks.value;
  if (c == (cookie *)0x0) {
    return;
  }
  if (cookies_options[2].option_elinks.value.tree != (list_head_elinks *)0x0) {
    pVar3 = parse_header_param(str,(uchar *)"expires",&local_28);
    if (pVar3 == HEADER_PARAM_FOUND) {
      tVar6 = parse_date(&local_28,(uchar *)0x0,0,1);
      mem_free(local_28);
      if (tVar6 != 0) {
        if (0 < oVar1.number) {
          tVar7 = time((time_t *)0x0);
          iVar8 = tVar7 + oVar1.number * 0x15180;
          if (iVar8 < tVar6) {
            tVar6 = iVar8;
          }
        }
        c->expires = tVar6;
      }
    }
    else if (pVar3 != HEADER_PARAM_NOT_FOUND) {
      done_cookie(c);
      return;
    }
  }
  pVar3 = parse_header_param(str,(uchar *)"secure",(uchar **)0x0);
  c->secure = (uint)(pVar3 == HEADER_PARAM_FOUND);
  addresslen = (uint)*(ushort *)&uri->field_0x2e;
  puVar9 = uri->host;
  puVar12 = c->domain;
  puVar5 = puVar12 + 1;
  if (*puVar12 != '.') {
    puVar5 = puVar12;
  }
  sVar4 = strlen((char *)puVar5);
  if ((int)sVar4 <= (int)addresslen) {
    iVar8 = c_strncasecmp((char *)puVar5,(char *)(puVar9 + (addresslen - sVar4)),sVar4);
    if (iVar8 == 0) {
      if (addresslen == sVar4) goto LAB_08077420;
      iVar8 = is_ip_address(puVar9,addresslen);
      if (iVar8 == 0) {
        if ((cookies_options[3].option_elinks.value.tree == (list_head_elinks *)0x0) ||
           (((0 < (int)sVar4 && (iVar8 = end_with_known_tld(puVar5,sVar4), 0 < iVar8)) &&
            (puVar5[iVar8 + -1] == '.')))) {
          iVar8 = 1;
        }
        else {
          iVar8 = 2;
        }
        uVar11 = *puVar5;
        while (uVar11 != '\0') {
          if (uVar11 == '.') {
            if (iVar8 == 1) goto LAB_08077420;
            iVar8 = 1;
          }
          puVar9 = puVar5 + 1;
          puVar5 = puVar5 + 1;
          uVar11 = *puVar9;
        }
      }
    }
    puVar12 = c->domain;
  }
  mem_free(puVar12);
  puVar9 = memacpy(uri->host,(uint)*(ushort *)&uri->field_0x2e);
  c->domain = puVar9;
LAB_08077420:
  if (cookies_options[1].option_elinks.value.tree == (list_head_elinks *)0x1) {
    c->prev = (cookie *)&cookie_queries;
    c->next = (cookie *)cookie_queries.next;
    cookie_queries.next = c;
    c->next->prev = c;
    add_questions_entry(accept_cookie_dialog,c);
  }
  else {
    accept_cookie(c);
  }
  return;
}



// WARNING: Unknown calling convention

void lock_cookie(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_cookie(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_cookie_used(listbox_item *item)

{
  undefined4 *puVar1;
  
  if (item->type != BI_FOLDER) {
    return (uint)(*(int *)((int)item->udata + 8) != 0);
  }
  puVar1 = (undefined4 *)(item->child).next;
  while( true ) {
    if ((list_head_elinks *)puVar1 == &item->child) {
      return 0;
    }
    if (*(int *)(puVar1[7] + 8) != 0) break;
    puVar1 = (undefined4 *)*puVar1;
  }
  return 1;
}



// WARNING: Unknown calling convention

listbox_item * get_cookie_root(listbox_item *item)

{
  listbox_item *plVar1;
  
  plVar1 = (listbox_item *)0x0;
  if (item->type != BI_FOLDER) {
    plVar1 = *(listbox_item **)(*(int *)((int)item->udata + 0x1c) + 0xc);
  }
  return plVar1;
}



// WARNING: Unknown calling convention

int can_delete_cookie(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void delete_cookie_item(listbox_item *item,int last)

{
  cookie *c;
  listbox_item *item_00;
  listbox_item *plVar1;
  listbox_item *plVar2;
  listbox_item *next;
  
  c = (cookie *)item->udata;
  if (item->type != BI_FOLDER) {
    if ((assert_failed == 0) &&
       (assert_failed = (int)((c->object).refcount != 0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
      errline = 200;
      elinks_internal((uchar *)"assertion !is_object_used(cookie) failed!");
    }
    delete_cookie(c);
    set_cookies_dirty();
    return;
  }
  item_00 = (listbox_item *)(item->child).next;
  plVar2 = item_00->next;
  while (plVar1 = plVar2, item_00 != (listbox_item *)&item->child) {
    delete_cookie_item(item_00,0);
    plVar2 = plVar1->next;
    item_00 = plVar1;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_cookie_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  if (item->type != BI_FOLDER) {
    puVar1 = stracpy(*(uchar **)((int)item->udata + 0xc));
    return puVar1;
  }
  puVar1 = stracpy((uchar *)((int)item->udata + 0x10));
  return puVar1;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_save_button(dialog_data *dlg_data,widget_data *button)

{
  save_cookies(dlg_data->win->term);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T set_cookie_domain(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *puVar2;
  cookie *cookie;
  uchar *value;
  
  pvVar1 = dlg_data->dlg->udata;
  puVar2 = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (puVar2 != (uchar *)0x0)) {
    if (*(void **)((int)pvVar1 + 0x18) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar1 + 0x18));
    }
    puVar2 = stracpy(puVar2);
    *(uchar **)((int)pvVar1 + 0x18) = puVar2;
    set_cookies_dirty();
    return EVENT_PROCESSED;
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T set_cookie_value(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *puVar2;
  cookie *cookie;
  uchar *value;
  
  pvVar1 = dlg_data->dlg->udata;
  puVar2 = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (puVar2 != (uchar *)0x0)) {
    if (*(void **)((int)pvVar1 + 0x10) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar1 + 0x10));
    }
    puVar2 = stracpy(puVar2);
    *(uchar **)((int)pvVar1 + 0x10) = puVar2;
    set_cookies_dirty();
    return EVENT_PROCESSED;
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T set_cookie_name(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *puVar2;
  cookie *cookie;
  uchar *value;
  
  pvVar1 = dlg_data->dlg->udata;
  puVar2 = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (puVar2 != (uchar *)0x0)) {
    if (*(void **)((int)pvVar1 + 0xc) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar1 + 0xc));
    }
    puVar2 = stracpy(puVar2);
    *(uchar **)((int)pvVar1 + 0xc) = puVar2;
    set_cookies_dirty();
    return EVENT_PROCESSED;
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T set_cookie_secure(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *__nptr;
  int *piVar2;
  long lVar3;
  long number;
  uchar *end;
  cookie *cookie;
  uchar *value;
  char *local_20 [4];
  
  pvVar1 = dlg_data->dlg->udata;
  __nptr = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (__nptr != (uchar *)0x0)) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    lVar3 = strtol((char *)__nptr,local_20,10);
    if ((*piVar2 == 0) && (*local_20[0] == '\0')) {
      number = (long)(lVar3 != 0);
      *(long *)((int)pvVar1 + 0x24) = number;
      set_cookies_dirty();
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T set_cookie_expires(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  uchar *__nptr;
  long number;
  int *piVar2;
  long lVar3;
  uchar *end;
  cookie *cookie;
  uchar *value;
  char *local_20 [4];
  
  pvVar1 = dlg_data->dlg->udata;
  __nptr = widget_data->cdata;
  if ((pvVar1 != (void *)0x0) && (__nptr != (uchar *)0x0)) {
    piVar2 = __errno_location();
    *piVar2 = 0;
    lVar3 = strtol((char *)__nptr,local_20,10);
    if ((*piVar2 == 0) && ((-1 < lVar3 && (*local_20[0] == '\0')))) {
      *(long *)((int)pvVar1 + 0x20) = lVar3;
      set_cookies_dirty();
      return EVENT_PROCESSED;
    }
  }
  return EVENT_NOT_PROCESSED;
}



// WARNING: Unknown calling convention

void add_server_do(void *data)

{
  size_t hostlen;
  cookie_server *server;
  uchar *domain;
  uchar *path;
  uchar *value;
  uchar *name;
  cookie *cookie;
  cookie *dummy_cookie;
  
  if (data != (void *)0x0) {
    hostlen = strlen((char *)data);
    server = get_cookie_server((uchar *)data,hostlen);
    domain = stracpy((uchar *)data);
    path = stracpy("/");
    value = stracpy("1");
    name = stracpy("empty");
    cookie = init_cookie(name,value,path,domain,server);
    if (cookie != (cookie *)0x0) {
      accept_cookie(cookie);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void accept_cookie_in_msg_box(void *cookie_)

{
  accept_cookie((cookie *)cookie_);
  return;
}



// WARNING: Unknown calling convention

void cookie_manager(session *ses)

{
  hierbox_browser(&cookie_browser,ses);
  return;
}



// WARNING: Unknown calling convention

void reject_cookie_in_msg_box(void *cookie_)

{
  done_cookie((cookie *)cookie_);
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_add_server_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term_00;
  dialog *dlg_00;
  widget_handler_status_T wVar1;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  uchar *text;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  memory_list *ml;
  dialog *dlg;
  terminal *term;
  uchar *name;
  
  term_00 = dlg_data->win->term;
  dlg_00 = (dialog *)mem_calloc(1,0x4b4);
  wVar1 = EVENT_NOT_PROCESSED;
  if (dlg_00 != (dialog *)0x0) {
    if ((term_00 != (terminal *)0x0) &&
       (iVar2 = get_terminal_codepage(term_00), iVar2 != current_charset)) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Add server");
    dlg_00->title = puVar3;
    dlg_00->layouter = generic_dialog_layouter;
    dlg_00->udata = (void *)0x0;
    dlg_00->udata2 = (void *)0x0;
    if ((term_00 != (terminal *)0x0) &&
       (iVar2 = get_terminal_codepage(term_00), iVar2 != current_charset)) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Server name");
    add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar3,0,0,check_nonempty,0x400,&dlg_00[2].refresh,
                     (input_history *)0x0,INPFIELD_FLOAT);
    if ((term_00 != (terminal *)0x0) &&
       (iVar2 = get_terminal_codepage(term_00), iVar2 != current_charset)) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext("~OK");
    add_dlg_button_do(dlg_00,puVar3,1,ok_dialog,(void *)0x0,add_server_do,&dlg_00[2].refresh);
    if ((term_00 != (terminal *)0x0) &&
       (iVar2 = get_terminal_codepage(term_00), iVar2 != current_charset)) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"~Cancel");
    add_dlg_button_do(dlg_00,puVar3,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if ((assert_failed == 0) &&
       (assert_failed = (int)(dlg_00->number_of_widgets != 3), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
      errline = 0x1d8;
      elinks_internal((uchar *)"assertion 3 == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg_00,0);
    do_dialog(term_00,dlg_00,ml);
    wVar1 = EVENT_PROCESSED;
  }
  return wVar1;
}



// WARNING: Unknown calling convention

void build_edit_dialog(terminal *term,cookie *cookie)

{
  void **s;
  int *s_00;
  cookie_server *pcVar1;
  dialog *dlg_00;
  dialog *dlg;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  int new_charset_1;
  int new_charset_2;
  uchar *puVar4;
  int new_charset_3;
  int new_charset_4;
  int new_charset_5;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  memory_list *ml;
  uchar *dlg_server;
  uint local_20 [4];
  
  local_20[0] = 0;
  dlg_00 = (dialog *)mem_calloc(1,0x15a4);
  if (dlg_00 != (dialog *)0x0) {
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext("Edit");
    dlg_00->title = puVar3;
    dlg_00->udata = cookie;
    dlg_00->layouter = generic_dialog_layouter;
    dlg_00->udata2 = (void *)0x0;
    s = &dlg_00[0x29].widgets[0].data;
    s_00 = &dlg_00[0x35].widgets[0].info.button.textlen;
    safe_strncpy((uchar *)(dlg_00 + 5),cookie->name,0x400);
    safe_strncpy((uchar *)&dlg_00[0x11].layouter,cookie->value,0x400);
    safe_strncpy((uchar *)&dlg_00[0x1d].number_of_widgets,cookie->domain,0x400);
    elinks_ulongcat((uchar *)s,local_20,cookie->expires,0x400,'\0',10,0);
    local_20[0] = 0;
    elinks_ulongcat((uchar *)s_00,local_20,cookie->secure,0x400,'\0',10,0);
    pcVar1 = cookie->server;
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Server");
    puVar3 = straconcat(puVar3,": ",pcVar1->host,&DAT_08131ec3,0);
    if (puVar3 == (uchar *)0x0) {
      mem_free(dlg_00);
    }
    else {
      add_dlg_text(dlg_00,puVar3,ALIGN_LEFT,0);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext("Name");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar4,0,0,set_cookie_name,0x400,dlg_00 + 5,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"Value");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar4,0,0,set_cookie_value,0x400,&dlg_00[0x11].layouter,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"Domain");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar4,0,0,set_cookie_domain,0x400,
                       &dlg_00[0x1d].number_of_widgets,(input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"Expires");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar4,0,0,set_cookie_expires,0x400,s,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"Secure");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar4,0,0,set_cookie_secure,0x400,s_00,
                       (input_history *)0x0,INPFIELD_FLOAT);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext("~OK");
      add_dlg_button_do(dlg_00,puVar4,1,ok_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg_00,puVar4,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0)
      ;
      if ((assert_failed == 0) &&
         (assert_failed = (int)(dlg_00->number_of_widgets != 8), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
        errline = 0x177;
        elinks_internal((uchar *)"assertion 8 == (dlg)->number_of_widgets failed!");
      }
      ml = getml(dlg_00,puVar3,0);
      do_dialog(term,dlg_00,ml);
    }
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_edit_button(dialog_data *dlg_data,widget_data *button)

{
  listbox_item *plVar1;
  listbox_data *box;
  listbox_data *plVar2;
  terminal *term;
  cookie *cookie;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  plVar1 = plVar2->sel;
  if (((plVar1 != (listbox_item *)0x0) && (plVar1->type != BI_FOLDER)) &&
     ((cookie *)plVar1->udata != (cookie *)0x0)) {
    build_edit_dialog(dlg_data->win->term,(cookie *)plVar1->udata);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_add_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  listbox_item *plVar1;
  listbox_data *plVar2;
  listbox_data *box;
  uchar *domain;
  uchar *path;
  uchar *value;
  uchar *name;
  cookie *cookie;
  cookie *new_cookie;
  cookie_server *server;
  bool bVar3;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  plVar1 = plVar2->sel;
  if ((plVar1 != (listbox_item *)0x0) &&
     (server = (cookie_server *)plVar1->udata, server != (cookie_server *)0x0)) {
    if (plVar1->type == BI_FOLDER) {
      if (assert_failed == 0) {
        bVar3 = plVar1->depth != 0;
        assert_failed = (int)bVar3;
        if (bVar3) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
          errline = 0x197;
          elinks_internal((uchar *)"assertion box->sel->depth == 0 failed!");
        }
        server = (cookie_server *)plVar2->sel->udata;
      }
    }
    else {
      server = (cookie_server *)server[1].object.refcount;
    }
    (server->object).refcount = (server->object).refcount + 1;
    domain = stracpy(server->host);
    path = stracpy("/");
    value = stracpy("");
    name = stracpy("");
    cookie = init_cookie(name,value,path,domain,server);
    if (cookie != (cookie *)0x0) {
      accept_cookie(cookie);
      build_edit_dialog(term,cookie);
    }
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void add_cookie_info_to_string(string *string,cookie *cookie,terminal *term)

{
  int iVar1;
  int new_charset;
  uchar *puVar2;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  int new_charset_5;
  uchar *puVar3;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  option_value *poVar4;
  
  puVar3 = cookie->name;
  if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset))
  {
    puVar2 = get_cp_mime_name(iVar1);
    bind_textdomain_codeset("elinks",puVar2);
    current_charset = iVar1;
  }
  puVar2 = gettext("Name");
  add_format_to_string(string,(uchar *)"\n%s: %s",puVar2,puVar3);
  puVar3 = cookie->value;
  if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset))
  {
    puVar2 = get_cp_mime_name(iVar1);
    bind_textdomain_codeset("elinks",puVar2);
    current_charset = iVar1;
  }
  puVar2 = gettext((uchar *)"Value");
  add_format_to_string(string,(uchar *)"\n%s: %s",puVar2,puVar3);
  puVar3 = cookie->domain;
  if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset))
  {
    puVar2 = get_cp_mime_name(iVar1);
    bind_textdomain_codeset("elinks",puVar2);
    current_charset = iVar1;
  }
  puVar2 = gettext((uchar *)"Domain");
  add_format_to_string(string,(uchar *)"\n%s: %s",puVar2,puVar3);
  puVar3 = cookie->path;
  if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset))
  {
    puVar2 = get_cp_mime_name(iVar1);
    bind_textdomain_codeset("elinks",puVar2);
    current_charset = iVar1;
  }
  puVar2 = gettext("Path");
  add_format_to_string(string,(uchar *)"\n%s: %s",puVar2,puVar3);
  if (cookie->expires == 0) {
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Expires");
    add_format_to_string(string,"\n%s: ",puVar2,puVar3);
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar1;
    }
    puVar3 = gettext((uchar *)"at quit time");
    add_to_string(string,puVar3);
  }
  else {
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Expires");
    add_format_to_string(string,"\n%s: ",puVar2,puVar3);
    poVar4 = get_opt_();
    add_date_to_string(string,poVar4->string,&cookie->expires);
  }
  puVar3 = "yes";
  if (cookie->secure == 0) {
    puVar3 = "no";
  }
  if (*puVar3 != '\0') {
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar3 = gettext(puVar3);
  }
  if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset))
  {
    puVar2 = get_cp_mime_name(iVar1);
    bind_textdomain_codeset("elinks",puVar2);
    current_charset = iVar1;
  }
  puVar2 = gettext((uchar *)"Secure");
  add_format_to_string(string,(uchar *)"\n%s: %s",puVar2,puVar3);
  return;
}



// WARNING: Unknown calling convention

uchar * get_cookie_info(listbox_item *item,terminal *term)

{
  cookie *cookie;
  cookie_server *pcVar1;
  string *psVar2;
  int cp_index;
  int new_charset;
  uchar *puVar3;
  string string;
  
  cookie = (cookie *)item->udata;
  if (item->type != BI_FOLDER) {
    psVar2 = init_string(&string);
    if (psVar2 != (string *)0x0) {
      pcVar1 = cookie->server;
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        puVar3 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",puVar3);
        current_charset = cp_index;
      }
      puVar3 = gettext((uchar *)"Server");
      add_format_to_string(&string,"%s: %s",puVar3,pcVar1->host);
      add_cookie_info_to_string(&string,cookie,term);
      return string.source;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void accept_cookie_dialog(session *ses,void *data)

{
  int iVar1;
  terminal *term;
  void *cookie;
  string *psVar2;
  int cp_index;
  int new_charset;
  uchar *puVar3;
  string string;
  
  cookie = cookie_queries.next;
  if ((assert_failed == 0) && (assert_failed = (int)(ses == (session *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
    errline = 0x49;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if ((list_head_elinks *)cookie_queries.next != &cookie_queries) {
    psVar2 = init_string(&string);
    if (psVar2 != (string *)0x0) {
                    // WARNING: Load size is inaccurate
      *(undefined4 *)(*cookie + 4) = *(undefined4 *)((int)cookie + 4);
                    // WARNING: Load size is inaccurate
      **(undefined4 **)((int)cookie + 4) = *cookie;
      iVar1 = *(int *)((int)cookie + 0x1c);
      term = ses->tab->term;
      if ((term != (terminal *)0x0) &&
         (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
        puVar3 = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",puVar3);
        current_charset = cp_index;
      }
      puVar3 = gettext((uchar *)"Do you want to accept a cookie from %s?");
      add_format_to_string(&string,puVar3,iVar1 + 0x10);
      add_to_string(&string,"\n\n");
      add_cookie_info_to_string(&string,(cookie *)cookie,ses->tab->term);
      msg_box(ses->tab->term,(memory_list *)0x0,MSGBOX_FREE_TEXT,(uchar *)"Accept cookie?",
              ALIGN_LEFT,string.source,cookie,2,"~Accept",accept_cookie_in_msg_box,1,"~Reject",
              reject_cookie_in_msg_box,2);
    }
  }
  return;
}



// WARNING: Unknown calling convention

cookie_str * parse_cookie_str(cookie_str *cstr,uchar *str)

{
  ushort *puVar1;
  ushort **ppuVar2;
  byte *pbVar3;
  byte bVar4;
  
  cstr->nam_end = (uchar *)0x0;
  cstr->val_start = (uchar *)0x0;
  cstr->val_end = (uchar *)0x0;
  cstr->str = str;
  bVar4 = *str;
  if ((bVar4 != 0x3d) && (bVar4 != 0x3b)) {
    ppuVar2 = __ctype_b_loc();
    pbVar3 = str;
    while (((*(byte *)((int)*ppuVar2 + (uint)bVar4 * 2 + 1) & 0x20) == 0 && (bVar4 != 0))) {
      pbVar3 = pbVar3 + 1;
      bVar4 = *pbVar3;
      if ((bVar4 == 0x3d) || (bVar4 == 0x3b)) break;
    }
    if (pbVar3 != str) {
      cstr->nam_end = pbVar3;
      puVar1 = *ppuVar2;
      while (bVar4 = *pbVar3, (*(byte *)((int)puVar1 + (uint)bVar4 * 2 + 1) & 0x20) != 0) {
        pbVar3 = pbVar3 + 1;
      }
      if (bVar4 != 0x3b) {
        if (bVar4 == 0x3d) {
          do {
            pbVar3 = pbVar3 + 1;
          } while (*pbVar3 == 0x3d);
          bVar4 = *(byte *)((int)puVar1 + (uint)*pbVar3 * 2 + 1);
          while ((bVar4 & 0x20) != 0) {
            pbVar3 = pbVar3 + 1;
            bVar4 = *(byte *)((int)puVar1 + (uint)*pbVar3 * 2 + 1);
          }
          cstr->val_start = pbVar3;
          cstr->val_end = pbVar3;
          bVar4 = *pbVar3;
          if (bVar4 != 0x3b) {
            if (bVar4 == 0) {
              return cstr;
            }
            while( true ) {
              pbVar3 = pbVar3 + 1;
              if ((*(byte *)((int)*ppuVar2 + (uint)bVar4 * 2 + 1) & 0x20) == 0) {
                cstr->val_end = pbVar3;
              }
              bVar4 = *pbVar3;
              if (bVar4 == 0) break;
              if (bVar4 == 0x3b) {
                return cstr;
              }
            }
            return cstr;
          }
          return cstr;
        }
        if (bVar4 != 0) {
          return (cookie_str *)0x0;
        }
      }
      cstr->val_start = pbVar3;
      cstr->val_end = pbVar3;
      return cstr;
    }
  }
  return (cookie_str *)0x0;
}



// WARNING: Unknown calling convention

void cached_header_dialog(session *ses,cache_entry *cached)

{
  uchar *puVar1;
  uchar *puVar2;
  size_t sVar3;
  uchar uVar4;
  int iVar5;
  int i;
  byte bVar6;
  msgbox_flags flags;
  int j;
  int iVar7;
  byte *pbVar8;
  char *local_20;
  
  if (((cached != (cache_entry *)0x0) && (puVar1 = cached->head, puVar1 != (uchar *)0x0)) &&
     (*puVar1 != '\0')) {
    sVar3 = strlen((char *)puVar1);
    local_20 = (char *)mem_alloc(sVar3 + 1);
    if ((uchar *)local_20 == (uchar *)0x0) {
      return;
    }
    pbVar8 = cached->head;
    bVar6 = *pbVar8;
    if (bVar6 == 0) {
      *local_20 = '\0';
    }
    else {
      iVar7 = 0;
      iVar5 = 0;
      do {
        while ((bVar6 != 10 && (bVar6 < 0x20))) {
          if (bVar6 != 0xd) {
            ((uchar *)local_20)[iVar7] = '*';
            pbVar8 = cached->head;
            iVar7 = iVar7 + 1;
          }
          iVar5 = iVar5 + 1;
          bVar6 = pbVar8[iVar5];
          if (bVar6 == 0) goto LAB_08078dfe;
        }
        iVar5 = iVar5 + 1;
        ((uchar *)local_20)[iVar7] = bVar6;
        pbVar8 = cached->head;
        iVar7 = iVar7 + 1;
        bVar6 = pbVar8[iVar5];
      } while (bVar6 != 0);
LAB_08078dfe:
      ((uchar *)local_20)[iVar7] = '\0';
      if (iVar7 != 0) {
        iVar5 = iVar7 + -1;
        uVar4 = ((uchar *)local_20)[iVar5];
        puVar1 = (uchar *)local_20 + iVar5;
        puVar2 = (uchar *)local_20 + iVar7 + -2;
        while (uVar4 == '\n') {
          *puVar1 = '\0';
          if (iVar5 == 0) {
            uVar4 = *local_20;
            goto LAB_08078e3e;
          }
          iVar5 = iVar5 + -1;
          uVar4 = *puVar2;
          puVar1 = puVar2;
          puVar2 = puVar2 + -1;
        }
      }
      uVar4 = *local_20;
LAB_08078e3e:
      flags = MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE;
      if (uVar4 != '\0') goto LAB_08078d55;
    }
    mem_free(local_20);
  }
  local_20 = "No header info.";
  flags = 0;
LAB_08078d55:
  info_box(ses->tab->term,flags,(uchar *)"Header info",ALIGN_LEFT,(uchar *)local_20);
  return;
}



// WARNING: Unknown calling convention

void nowhere_box(terminal *term,uchar *title)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(term == (terminal *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/document.c";
    errline = 0x27;
    elinks_internal((uchar *)"assertion term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if ((title == (uchar *)0x0) || (*title == '\0')) {
    title = "Info";
  }
  info_box(term,0,title,ALIGN_CENTER,(uchar *)"You are nowhere!");
  return;
}



// WARNING: Unknown calling convention

void protocol_header_dialog(session *ses)

{
  document *pdVar1;
  
  if ((ses->history).current != (location *)0x0) {
    if ((ses->doc_view != (document_view *)0x0) &&
       (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) {
      cached_header_dialog(ses,pdVar1->cached);
    }
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)"Header info");
  return;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

void document_info_dialog(session *ses)

{
  terminal *term_00;
  location *plVar1;
  cache_entry *pcVar2;
  cp_status cVar3;
  terminal *term_01;
  uint uVar4;
  document_view *pdVar5;
  string *psVar6;
  int iVar7;
  int new_charset;
  uchar *puVar8;
  int new_charset_1;
  uchar *puVar9;
  int new_charset_3;
  int new_charset_4;
  uchar *a;
  int new_charset_5;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  int new_charset_9;
  int new_charset_10;
  global_history_item *pgVar10;
  global_history_item *historyitem;
  undefined4 *puVar11;
  uchar *last_visit;
  uint size;
  undefined4 *puVar12;
  uchar *a_1;
  int new_charset_15;
  int new_charset_14;
  link *plVar13;
  link *link;
  int new_charset_13;
  global_history_item *historyitem_1;
  char *pcVar14;
  uchar *last_visit_1;
  int new_charset_11;
  int new_charset_12;
  int new_charset_2;
  int iVar15;
  uint uVar16;
  terminal *term;
  undefined4 uVar17;
  undefined4 uVar18;
  string img;
  string msg;
  
  term_00 = ses->tab->term;
  plVar1 = (ses->history).current;
  if (plVar1 == (location *)0x0) {
    nowhere_box(term_00,(uchar *)0x0);
    return;
  }
  pdVar5 = current_frame(ses);
  psVar6 = init_string(&msg);
  if (psVar6 == (string *)0x0) {
    return;
  }
  if ((term_00 != (terminal *)0x0) &&
     (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
    puVar8 = get_cp_mime_name(iVar7);
    bind_textdomain_codeset("elinks",puVar8);
    current_charset = iVar7;
  }
  puVar8 = gettext("URL");
  add_to_string(&msg,puVar8);
  add_to_string(&msg,": ");
  add_uri_to_string(&msg,(plVar1->vs).uri,URI_PUBLIC);
  add_char_to_string(&msg,'\n');
  if ((pdVar5 != (document_view *)0x0) && (puVar8 = pdVar5->document->title, puVar8 != (uchar *)0x0)
     ) {
    if ((term_00 != (terminal *)0x0) &&
       (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
      puVar9 = get_cp_mime_name(iVar7);
      bind_textdomain_codeset("elinks",puVar9);
      current_charset = iVar7;
    }
    puVar9 = gettext((uchar *)"Title");
    add_format_to_string(&msg,"%s: %s",puVar9,puVar8);
  }
  add_char_to_string(&msg,'\n');
  pcVar2 = pdVar5->document->cached;
  if (pcVar2 != (cache_entry *)0x0) {
    uVar17 = *(undefined4 *)&pcVar2->length;
    uVar18 = *(undefined4 *)((int)&pcVar2->length + 4);
    if ((term_00 != (terminal *)0x0) &&
       (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
      puVar8 = get_cp_mime_name(iVar7);
      bind_textdomain_codeset("elinks",puVar8);
      current_charset = iVar7;
    }
    puVar8 = gettext("Size");
    add_format_to_string(&msg,(uchar *)"\n%s: %lld",puVar8,uVar17,uVar18);
    if ((pcVar2->field_0x5c & 8) != 0) {
      if ((term_00 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
        puVar8 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar8);
        current_charset = iVar7;
      }
      puVar8 = gettext((uchar *)"incomplete");
      add_format_to_string(&msg," (%s)",puVar8,uVar17,uVar18);
    }
    puVar8 = get_cp_name(pdVar5->document->cp);
    if ((term_00 != (terminal *)0x0) &&
       (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
      puVar9 = get_cp_mime_name(iVar7);
      bind_textdomain_codeset("elinks",puVar9);
      current_charset = iVar7;
    }
    puVar9 = gettext((uchar *)"Codepage");
    add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
    cVar3 = pdVar5->document->cp_status;
    if (cVar3 == CP_STATUS_ASSUMED) {
      pcVar14 = "assumed";
LAB_08079b4f:
      puVar9 = _((uchar *)pcVar14,term_00);
      add_format_to_string(&msg," (%s)",puVar9,puVar8);
    }
    else if (cVar3 == CP_STATUS_IGNORED) {
      pcVar14 = "ignoring server setting";
      goto LAB_08079b4f;
    }
    puVar8 = parse_header(pcVar2->head,(uchar *)"Server",(uchar **)0x0);
    if (puVar8 != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext((uchar *)"Server");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
      mem_free(puVar8);
    }
    puVar8 = pcVar2->ssl_info;
    if (puVar8 != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext((uchar *)"SSL Cipher");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
    }
    puVar8 = pcVar2->encoding_info;
    if (puVar8 != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext("Encoding");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
    }
    puVar8 = parse_header(pcVar2->head,"Date",(uchar **)0x0);
    if (puVar8 != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext("Date");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
      mem_free(puVar8);
    }
    puVar8 = pcVar2->last_modified;
    if (puVar8 != (uchar *)0x0) {
      if ((term_00 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext((uchar *)"Last modified");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
    }
  }
  if ((term_00 != (terminal *)0x0) &&
     (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
    puVar8 = get_cp_mime_name(iVar7);
    bind_textdomain_codeset("elinks",puVar8);
    current_charset = iVar7;
  }
  puVar8 = gettext((uchar *)"Last visit time");
  add_format_to_string(&msg,"\n%s: ",puVar8);
  pgVar10 = get_global_history_item(((plVar1->vs).uri)->string);
  if ((pgVar10 == (global_history_item *)0x0) ||
     (puVar11 = (undefined4 *)ctime(&pgVar10->last_visit), iVar7 = msg.length,
     puVar11 == (undefined4 *)0x0)) {
    puVar8 = _((uchar *)"Unknown",term_00);
    add_to_string(&msg,puVar8);
  }
  else if (assert_failed == 0) {
    assert_failed = 0;
    iVar15 = msg.length + 0x18;
    size = msg.length + 0x118U & 0xffffff00;
    uVar4 = msg.length + 0xffU >> 8;
    uVar16 = msg.length + 0xffU & 0xffffff00;
    if (uVar16 <= size && size + uVar4 * -0x100 != 0) {
      puVar8 = (uchar *)mem_realloc(msg.source,size);
      if (puVar8 == (uchar *)0x0) goto LAB_080796d3;
      msg.source = puVar8;
      memset(puVar8 + uVar16,0,size + uVar4 * -0x100);
    }
    if (msg.source != (uchar *)0x0) {
      puVar12 = (undefined4 *)(msg.source + msg.length);
      *puVar12 = *puVar11;
      puVar12[1] = puVar11[1];
      puVar12[2] = puVar11[2];
      puVar12[3] = puVar11[3];
      puVar12[4] = puVar11[4];
      puVar12[5] = puVar11[5];
      msg.source[iVar7 + 0x18] = '\0';
      msg.length = iVar15;
    }
  }
  else {
    assert_failed = 0;
  }
LAB_080796d3:
  pdVar5 = current_frame(ses);
  term_01 = ses->tab->term;
  if (pdVar5 != (document_view *)0x0) {
    add_char_to_string(&msg,'\n');
    puVar8 = get_current_link_info(ses,pdVar5);
    if (puVar8 != (uchar *)0x0) {
      if ((term_01 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_01), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext("Link");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
      mem_free(puVar8);
    }
    puVar8 = get_current_link_title(pdVar5);
    if (puVar8 != (uchar *)0x0) {
      if ((term_01 != (terminal *)0x0) &&
         (iVar7 = get_terminal_codepage(term_01), iVar7 != current_charset)) {
        puVar9 = get_cp_mime_name(iVar7);
        bind_textdomain_codeset("elinks",puVar9);
        current_charset = iVar7;
      }
      puVar9 = gettext((uchar *)"Link title");
      add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
      mem_free(puVar8);
    }
    plVar13 = get_current_link_in_view(pdVar5);
    if (plVar13 != (link *)0x0) {
      if ((plVar13->where_img != (uchar *)0x0) &&
         (psVar6 = init_string(&img), psVar6 != (string *)0x0)) {
        add_string_uri_to_string(&img,plVar13->where_img,URI_PUBLIC);
        decode_uri_string_for_display(&img);
        if ((term_01 != (terminal *)0x0) &&
           (iVar7 = get_terminal_codepage(term_01), iVar7 != current_charset)) {
          puVar8 = get_cp_mime_name(iVar7);
          bind_textdomain_codeset("elinks",puVar8);
          current_charset = iVar7;
        }
        puVar8 = gettext((uchar *)"Link image");
        add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar8,img.source);
        done_string(&img);
      }
      pgVar10 = get_global_history_item(plVar13->where);
      if (pgVar10 != (global_history_item *)0x0) {
        pcVar14 = ctime(&pgVar10->last_visit);
        if (pcVar14 != (char *)0x0) {
          if ((term_01 != (terminal *)0x0) &&
             (iVar7 = get_terminal_codepage(term_01), iVar7 != current_charset)) {
            puVar8 = get_cp_mime_name(iVar7);
            bind_textdomain_codeset("elinks",puVar8);
            current_charset = iVar7;
          }
          puVar8 = gettext((uchar *)"Link last visit time");
          add_format_to_string(&msg,(uchar *)"\n%s: %.24s",puVar8,pcVar14);
        }
        puVar8 = pgVar10->title;
        if (*puVar8 != '\0') {
          if ((term_01 != (terminal *)0x0) &&
             (iVar7 = get_terminal_codepage(term_01), iVar7 != current_charset)) {
            puVar9 = get_cp_mime_name(iVar7);
            bind_textdomain_codeset("elinks",puVar9);
            current_charset = iVar7;
          }
          puVar9 = gettext((uchar *)"Link title (from history)");
          add_format_to_string(&msg,(uchar *)"\n%s: %s",puVar9,puVar8);
        }
      }
    }
  }
  info_box(term_00,MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE,"Info",ALIGN_LEFT,msg.source);
  return;
}



// WARNING: Unknown calling convention

void download_abort_function(dialog_data *dlg_data)

{
  *(undefined4 *)((int)dlg_data->dlg->udata + 0x6c) = 0;
  return;
}



// WARNING: Unknown calling convention

void lock_file_download(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_file_download(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_file_download_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

uchar * get_file_download_info(listbox_item *item,terminal *term)

{
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uri * get_file_download_uri(listbox_item *item)

{
  object *poVar1;
  uri *puVar2;
  
  puVar2 = *(uri **)((int)item->udata + 0xc);
  poVar1 = &puVar2->object;
  poVar1->refcount = poVar1->refcount + 1;
  return puVar2;
}



// WARNING: Unknown calling convention

listbox_item * get_file_download_root(listbox_item *item)

{
  return (listbox_item *)0x0;
}



// WARNING: Unknown calling convention

int can_delete_file_download(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void done_download_display(file_download *file_download)

{
  if (file_download->box_item != (listbox_item *)0x0) {
    done_listbox_item(&download_browser,file_download->box_item);
    file_download->box_item = (listbox_item *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

dlg_refresh_code refresh_file_download(dialog_data *dlg_data,void *data)

{
  int iVar1;
  
  iVar1 = are_there_downloads();
  return -(uint)(iVar1 == 0) & 3;
}



// WARNING: Unknown calling convention

void delete_file_download(listbox_item *item,int last)

{
  void *data;
  file_download *file_download;
  
  data = item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)(*(int *)((int)data + 8) != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
    errline = 0x15b;
    elinks_internal((uchar *)"assertion !is_object_used(file_download) failed!");
  }
  register_bottom_half_do(do_abort_download,data);
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_delete_button(dialog_data *dlg_data,widget_data *widget_data)

{
  void *data;
  file_download *file_download;
  
  data = dlg_data->dlg->udata;
  *(byte *)((int)data + 0x68) = *(byte *)((int)data + 0x68) | 1;
  *(int *)((int)data + 8) = *(int *)((int)data + 8) + -1;
  register_bottom_half_do(do_abort_download,data);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T dlg_abort_download(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  void *data;
  file_download *file_download;
  
  data = dlg_data->dlg->udata;
  piVar1 = (int *)((int)data + 8);
  *piVar1 = *piVar1 + -1;
  register_bottom_half_do(do_abort_download,data);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T dlg_undisplay_download(dialog_data *dlg_data,widget_data *widget_data)

{
  int *piVar1;
  void *data;
  file_download *file_download;
  
  data = dlg_data->dlg->udata;
  piVar1 = (int *)((int)data + 8);
  *piVar1 = *piVar1 + -1;
  register_bottom_half_do(undisplay_download,data);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void do_abort_download(file_download *file_download)

{
  file_download *down;
  file_download *pfVar1;
  
  pfVar1 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download == pfVar1) {
        file_download->field_0x68 = file_download->field_0x68 | 2;
        abort_download(file_download);
        return;
      }
      pfVar1 = pfVar1->next;
    } while (pfVar1 != (file_download *)&downloads);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_file_download_text(listbox_item *item,terminal *term)

{
  uchar *src;
  uchar *uristring;
  
  src = get_uri_string(*(uri **)((int)item->udata + 0xc),URI_PUBLIC);
  if (src != (uchar *)0x0) {
    if ((term->field_0x38 & 2) != 0) {
      decode_uri(src);
      return src;
    }
    decode_uri_for_display(src);
  }
  return src;
}



// WARNING: Unknown calling convention

void draw_file_download(listbox_item *item,listbox_context *context,int x,int y,int width)

{
  void *pvVar1;
  progress *progress;
  dialog_refresh *pdVar2;
  uchar *puVar3;
  uchar *stylename;
  color_pair *color;
  uchar *text;
  size_t length;
  int iVar4;
  int trimmedlen;
  size_t length_00;
  
  pvVar1 = item->udata;
  if (width < 4) {
    return;
  }
  puVar3 = "menu.selected";
  if ((context->box->sel != item) && (puVar3 = "menu.normal", (item->field_0x18 & 4) != 0)) {
    puVar3 = "menu.marked";
  }
  color = get_bfu_color(context->term,puVar3);
  puVar3 = get_file_download_text(item,context->term);
  if (puVar3 == (uchar *)0x0) {
    return;
  }
  length = strlen((char *)puVar3);
  length_00 = width - 0x13;
  if ((int)length_00 <= (int)(length * 0x32) / 100) {
    length_00 = width - 3;
  }
  if ((int)length < (int)length_00) {
    draw_text(context->term,x,y,puVar3,length,0,color);
    length_00 = length;
  }
  else {
    draw_text(context->term,x,y,puVar3,length_00,0,color);
    if ((int)length_00 < (int)length) {
      iVar4 = length_00 + x;
      length_00 = length_00 + 3;
      draw_text(context->term,iVar4,y,"...",3,0,color);
    }
  }
  mem_free(puVar3);
  progress = *(progress **)((int)pvVar1 + 0x50);
  if ((((progress != (progress *)0x0) && (-1 < *(int *)((int)&progress->size + 4))) &&
      (*(int *)((int)pvVar1 + 0x54) == 8)) && (iVar4 = has_progress(progress), iVar4 != 0)) {
    pdVar2 = context->dlg_data->dlg->refresh;
    if ((pdVar2 == (dialog_refresh *)0x0) || (pdVar2->timer == (timer_id_T)0x0)) {
      refresh_dialog(context->dlg_data,refresh_file_download,(void *)0x0);
    }
    if ((int)(length_00 + 0xf) < width) {
      draw_progress_bar(*(progress **)((int)pvVar1 + 0x50),context->term,width + -0xf + x,y,0xf,
                        (uchar *)0x0,(color_pair *)0x0);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void init_download_display(file_download *file_download)

{
  listbox_item *plVar1;
  
  plVar1 = add_listbox_item(&download_browser,(listbox_item *)0x0,BI_LEAF,file_download,1);
  file_download->box_item = plVar1;
  return;
}



// WARNING: Unknown calling convention

void download_manager(session *ses)

{
  hierbox_browser(&download_browser,ses);
  download_browser._96_1_ = download_browser._96_1_ | 1;
  return;
}



// WARNING: Unknown calling convention

void undisplay_download(file_download *file_download)

{
  file_download *down;
  file_download *pfVar1;
  
  pfVar1 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download == pfVar1) {
        if (file_download->dlg_data == (dialog_data *)0x0) {
          return;
        }
        cancel_dialog(file_download->dlg_data,(widget_data *)0x0);
        return;
      }
      pfVar1 = pfVar1->next;
    } while (pfVar1 != (file_download *)&downloads);
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T dlg_set_notify(dialog_data *dlg_data,widget_data *widget_data)

{
  file_download *file_download_00;
  file_download *file_download;
  
  file_download_00 = (file_download *)dlg_data->dlg->udata;
  file_download_00->notify = 1;
  undisplay_download(file_download_00);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void download_dialog_layouter(dialog_data *dlg_data)

{
  void *pvVar1;
  terminal *term_00;
  color_pair *color;
  uchar *text;
  uchar *src;
  size_t sVar2;
  int iVar3;
  int iVar4;
  terminal *term;
  int w;
  int iVar5;
  uint local_38;
  int *local_34;
  int local_24;
  int local_20 [4];
  
  pvVar1 = dlg_data->dlg->udata;
  term_00 = dlg_data->win->term;
  iVar4 = (term_00->width * 9) / 10 + -0xc;
  iVar5 = 1;
  if (0 < iVar4) {
    iVar3 = term_00->width + -0xc;
    if (0 < iVar3) {
      iVar5 = iVar3;
    }
    if (iVar4 <= iVar5) {
      iVar5 = iVar4;
    }
  }
  local_24 = 0;
  local_20[0] = iVar5;
  color = get_bfu_color(term_00,"dialog.text");
  text = get_download_msg((download *)((int)pvVar1 + 0x38),term_00,1,1,"\n");
  iVar4 = download_is_progressing((download *)((int)pvVar1 + 0x38));
  local_38 = 0;
  if (iVar4 != 0) {
    local_38 = ~*(uint *)(*(int *)((int)pvVar1 + 0x50) + 0x30) >> 0x1f;
  }
  redraw_below_window(dlg_data->win);
  *(dialog_data **)((int)pvVar1 + 0x6c) = dlg_data;
  if (text != (uchar *)0x0) {
    src = get_uri_string(*(uri **)((int)pvVar1 + 0xc),URI_PUBLIC);
    if (src != (uchar *)0x0) {
      if ((term_00->field_0x38 & 2) == 0) {
        decode_uri_for_display(src);
      }
      else {
        decode_uri(src);
      }
      sVar2 = strlen((char *)src);
      if (local_38 == 0) {
        dlg_format_text_do(term_00,src,0,&local_24,iVar5,local_20,color,ALIGN_LEFT,1);
        local_24 = local_24 + 1;
      }
      else {
        if (iVar5 < 0x14) {
          iVar5 = 0x14;
        }
        dlg_format_text_do(term_00,src,0,&local_24,iVar5,local_20,color,ALIGN_LEFT,1);
        local_24 = local_24 + 3;
      }
      local_34 = &local_24;
      dlg_format_text_do(term_00,text,0,local_34,iVar5,local_20,color,ALIGN_LEFT,1);
      local_24 = local_24 + 1;
      dlg_format_buttons(term_00,dlg_data->widgets_data,dlg_data->number_of_widgets,0,local_34,iVar5
                         ,local_20,ALIGN_CENTER,1);
      draw_dialog(dlg_data,iVar5,local_24);
      iVar5 = local_20[0];
      if ((local_20[0] < (int)sVar2) && (src[local_20[0]] = '\0', 4 < local_20[0])) {
        src[local_20[0] + -1] = '.';
        src[local_20[0] + -2] = '.';
        src[local_20[0] + -3] = '.';
      }
      local_24 = (dlg_data->box).y + 3;
      iVar4 = (dlg_data->box).x + 6;
      dlg_format_text_do(term_00,src,iVar4,local_34,local_20[0],(int *)0x0,color,ALIGN_LEFT,0);
      if (local_38 != 0) {
        local_24 = local_24 + 1;
        draw_progress_bar(*(progress **)((int)pvVar1 + 0x50),term_00,iVar4,local_24,iVar5,
                          (uchar *)0x0,(color_pair *)0x0);
        local_24 = local_24 + 1;
      }
      local_24 = local_24 + 1;
      dlg_format_text_do(term_00,text,iVar4,local_34,iVar5,(int *)0x0,color,ALIGN_LEFT,0);
      local_24 = local_24 + 1;
      dlg_format_buttons(term_00,dlg_data->widgets_data,dlg_data->number_of_widgets,iVar4,local_34,
                         iVar5,(int *)0x0,ALIGN_CENTER,0);
      mem_free(src);
    }
    mem_free(text);
  }
  return;
}



// WARNING: Unknown calling convention

void display_download(terminal *term,file_download *file_download,session *ses)

{
  file_download *down;
  file_download *pfVar1;
  dialog *dlg_00;
  dialog *dlg;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  memory_list *ml;
  int new_charset_4;
  bool bVar4;
  
  pfVar1 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download == pfVar1) {
        dlg_00 = (dialog *)mem_calloc(1,0xe4);
        if (dlg_00 == (dialog *)0x0) {
          return;
        }
        undisplay_download(file_download);
        file_download->ses = ses;
        if ((term != (terminal *)0x0) &&
           (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
          puVar3 = get_cp_mime_name(iVar2);
          bind_textdomain_codeset("elinks",puVar3);
          current_charset = iVar2;
        }
        puVar3 = gettext((uchar *)"Download");
        dlg_00->title = puVar3;
        dlg_00->layouter = download_dialog_layouter;
        dlg_00->abort = download_abort_function;
        dlg_00->udata = file_download;
        (file_download->object).refcount = (file_download->object).refcount + 1;
        if ((term != (terminal *)0x0) &&
           (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
          puVar3 = get_cp_mime_name(iVar2);
          bind_textdomain_codeset("elinks",puVar3);
          current_charset = iVar2;
        }
        puVar3 = gettext((uchar *)"~Background");
        add_dlg_button_do(dlg_00,puVar3,3,dlg_undisplay_download,(void *)0x0,(done_handler_T *)0x0,
                          (void *)0x0);
        if ((term != (terminal *)0x0) &&
           (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
          puVar3 = get_cp_mime_name(iVar2);
          bind_textdomain_codeset("elinks",puVar3);
          current_charset = iVar2;
        }
        puVar3 = gettext((uchar *)"Background with ~notify");
        add_dlg_button_do(dlg_00,puVar3,3,dlg_set_notify,(void *)0x0,(done_handler_T *)0x0,
                          (void *)0x0);
        if ((term != (terminal *)0x0) &&
           (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
          puVar3 = get_cp_mime_name(iVar2);
          bind_textdomain_codeset("elinks",puVar3);
          current_charset = iVar2;
        }
        puVar3 = gettext((uchar *)"~Abort");
        add_dlg_button_do(dlg_00,puVar3,0,dlg_abort_download,(void *)0x0,(done_handler_T *)0x0,
                          (void *)0x0);
        if (file_download->external_handler == (uchar *)0x0) {
          if ((term != (terminal *)0x0) &&
             (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
            puVar3 = get_cp_mime_name(iVar2);
            bind_textdomain_codeset("elinks",puVar3);
            current_charset = iVar2;
          }
          puVar3 = gettext((uchar *)"Abort and ~delete file");
          add_dlg_button_do(dlg_00,puVar3,0,push_delete_button,(void *)0x0,(done_handler_T *)0x0,
                            (void *)0x0);
        }
        if ((assert_failed == 0) &&
           (bVar4 = ~-(uint)(file_download->external_handler == (uchar *)0x0) + 4 !=
                    dlg_00->number_of_widgets, assert_failed = (int)bVar4, bVar4)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
          errline = 0x10e;
          elinks_internal((uchar *)
                          "assertion 4 - !!file_download->external_handler == (dlg)->number_of_widgets failed!"
                         );
        }
        ml = getml(dlg_00,0);
        do_dialog(term,dlg_00,ml);
        return;
      }
      pfVar1 = pfVar1->next;
    } while (pfVar1 != (file_download *)&downloads);
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_info_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *term;
  session *ses_00;
  listbox_data *box;
  listbox_data *plVar1;
  file_download *file_download_00;
  file_download *file_download;
  session *ses;
  
  file_download_00 = (file_download *)0x0;
  plVar1 = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  ses_00 = (session *)dlg_data->dlg->udata;
  if (plVar1->sel != (listbox_item *)0x0) {
    file_download_00 = (file_download *)plVar1->sel->udata;
  }
  if ((assert_failed == 0) && (assert_failed = (int)(ses_00 == (session *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
    errline = 0x1d8;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if (file_download_00 != (file_download *)0x0) {
    delete_window(dlg_data->win);
    display_download(term,file_download_00,ses_00);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T my_cancel_dialog(dialog_data *dlg_data,widget_data *widget_data)

{
  widget_handler_status_T wVar1;
  
  (*(code *)widget_data->widget->data)(dlg_data->dlg);
  wVar1 = cancel_dialog(dlg_data,widget_data);
  return wVar1;
}



// WARNING: Unknown calling convention

void do_edit_dialog(terminal *term,int intl,uchar *title,uchar *src_name,uchar *src_url,session *ses
                   ,dialog_data *parent,done_handler_T *when_done,_func_void_dialog_ptr *when_cancel
                   ,void *done_data,edit_dialog_type dialog_type)

{
  uchar **str;
  dialog *dlg_00;
  dialog *dlg;
  _func_void_dialog_data_ptr **str_00;
  int iVar1;
  int new_charset;
  uchar *puVar2;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  memory_list *ml;
  int new_charset_5;
  int new_charset_6;
  int new_charset_7;
  code *handler;
  
  if (((intl != 0) && (title != (uchar *)0x0)) && (*title != '\0')) {
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    title = gettext(title);
  }
  dlg_00 = (dialog *)mem_calloc(1,0x914);
  if (dlg_00 != (dialog *)0x0) {
    str_00 = &dlg_00[3].abort;
    str = &dlg_00[0xf].widgets[0].text;
    if (src_name == (uchar *)0x0) {
      get_current_title(ses,(uchar *)str_00,0x400);
    }
    else {
      safe_strncpy((uchar *)str_00,src_name,0x400);
    }
    if (src_url == (uchar *)0x0) {
      get_current_url(ses,(uchar *)str,0x400);
    }
    else {
      safe_strncpy((uchar *)str,src_url,0x400);
    }
    *(byte *)&dlg_00->layout = *(byte *)&dlg_00->layout | 1;
    dlg_00->title = title;
    dlg_00->layouter = generic_dialog_layouter;
    dlg_00->udata = parent;
    dlg_00->udata2 = done_data;
    if (dialog_type == EDIT_DLG_ADD) {
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext("Name");
      handler = check_nonempty;
    }
    else {
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext("Name");
      handler = (widget_handler_T *)0x0;
    }
    add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar2,0,0,handler,0x400,str_00,(input_history *)0x0,
                     INPFIELD_NONE);
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext("URL");
    add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar2,0,0,(widget_handler_T *)0x0,0x400,str,
                     (input_history *)0x0,INPFIELD_NONE);
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext("~OK");
    add_dlg_button_do(dlg_00,puVar2,1,ok_dialog,(void *)0x0,when_done,dlg_00);
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"C~lear");
    add_dlg_button_do(dlg_00,puVar2,0,clear_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if (when_cancel == (_func_void_dialog_ptr *)0x0) {
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg_00,puVar2,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0)
      ;
    }
    else {
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg_00,puVar2,2,my_cancel_dialog,when_cancel,(done_handler_T *)0x0,
                        (void *)0x0);
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(dlg_00->number_of_widgets != 5), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/edit.c";
      errline = 0x6c;
      elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg_00,0);
    do_dialog(term,dlg_00,ml);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void resource_info(terminal *term)

{
  refreshed_msg_box(term,0,(uchar *)"Resources",ALIGN_LEFT,get_resource_info,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

void menu_copying(terminal *term,void *xxx,void *xxxx)

{
  uchar *text;
  
  text = msg_text(term,(uchar *)
                       "ELinks %s\n\n%set al.\n\nThis program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, specifically version 2 of the License."
                  ,"0.12pre5",
                  "(C) 1999 - 2002 Mikulas Patocka\n(C) 2001 - 2004 Petr Baudis\n(C) 2002 - 2007 Jonas Fonseca\n"
                 );
  info_box(term,MSGBOX_FREE_TEXT,"Copying",ALIGN_CENTER,text);
  return;
}



// WARNING: Unknown calling convention

void menu_keys(terminal *term,void *d_,void *xxx)

{
  terminal **p;
  string *psVar1;
  action_id_T action_id;
  memory_list *ml;
  int iVar2;
  keymap_id keymap_id;
  keymap_id keymap_id_00;
  action_id_T *paVar3;
  int iStack_204;
  action_id_T action_ids [119];
  string keys;
  
  paVar3 = action_ids;
  for (iVar2 = 0x77; iVar2 != 0; iVar2 = iVar2 + -1) {
    *paVar3 = 0;
    paVar3 = paVar3 + 1;
  }
  action_ids[0] = 0x30;
  action_ids[1] = 0x4c;
  action_ids[2] = 0x3c;
  action_ids[3] = 0x3d;
  action_ids[4] = 0x57;
  action_ids[5] = 0x5a;
  action_ids[6] = 0x58;
  action_ids[7] = 0x59;
  action_ids[8] = 0x20;
  action_ids[9] = 0x1a;
  action_ids[10] = 0x1b;
  action_ids[11] = 0xe;
  action_ids[12] = 0x1e;
  action_ids[13] = 0x5b;
  action_ids[14] = 0x5c;
  action_ids[15] = 0x12;
  action_ids[16] = 0x13;
  action_ids[17] = 0x29;
  action_ids[18] = 0x25;
  action_ids[19] = 0x71;
  p = (terminal **)mem_calloc(1,8);
  if (p != (terminal **)0x0) {
    psVar1 = init_string(&keys);
    if (psVar1 == (string *)0x0) {
      mem_free(p);
      return;
    }
    *p = term;
    p[1] = (terminal *)d_;
    if (d_ == (void *)0x0) {
      add_actions_to_string(&keys,action_ids,KEYMAP_MAIN,term);
    }
    else {
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        (&iStack_204)[iVar2] = iVar2;
      } while (iVar2 != 0x76);
      iVar2 = 0;
      keymap_id_00 = KEYMAP_MAIN;
      while( true ) {
        add_actions_to_string(&keys,action_ids,keymap_id_00,term);
        if (keymap_id_00 + KEYMAP_EDIT != KEYMAP_MAX) {
          add_to_string(&keys,"\n\n");
        }
        if (assert_failed == 0) {
          assert_failed = 0;
        }
        if (keymap_id_00 == KEYMAP_MAIN) {
          action_ids[30] = 0;
        }
        else if (keymap_id_00 == KEYMAP_EDIT) {
          action_ids[21] = 0;
        }
        if (iVar2 == 2) break;
        iVar2 = iVar2 + 1;
        keymap_id_00 = keymap_id_00 + KEYMAP_EDIT;
      }
    }
    ml = getml(p,0);
    msg_box(term,ml,MSGBOX_FREE_TEXT|MSGBOX_SCROLLABLE,"Keys",ALIGN_LEFT,keys.source,p,2,
            &DAT_081275e4,0,3,"~Toggle display",push_toggle_keys_display_button,1);
  }
  return;
}



// WARNING: Unknown calling convention

void push_toggle_keys_display_button(void *data)

{
                    // WARNING: Load size is inaccurate
  menu_keys(*data,(void *)(uint)(*(int *)((int)data + 4) == 0),(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

void menu_about(terminal *term,void *xxx,void *xxxx)

{
  uchar *text;
  
  text = get_dyn_full_version(term,1);
  info_box(term,MSGBOX_FREE_TEXT,(uchar *)"About",ALIGN_CENTER,text);
  return;
}



// WARNING: Unknown calling convention

uchar * get_resource_info(terminal *term,void *data)

{
  void **ppvVar1;
  string *psVar2;
  int iVar3;
  int new_charset;
  uchar *puVar4;
  ulong uVar5;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  int new_charset_5;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  int new_charset_9;
  int new_charset_10;
  int new_charset_11;
  int new_charset_12;
  int new_charset_13;
  int new_charset_14;
  int new_charset_15;
  int new_charset_16;
  int new_charset_17;
  int new_charset_18;
  list_head_elinks *item;
  int new_charset_19;
  list_head_elinks *item_1;
  list_head_elinks *plVar6;
  int new_charset_20;
  long val;
  int new_charset_21;
  ulong n;
  ulonglong uVar7;
  string info;
  
  psVar2 = init_string(&info);
  puVar4 = (uchar *)0x0;
  if (psVar2 != (string *)0x0) {
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = gettext((uchar *)"Resources");
    add_to_string(&info,puVar4);
    add_to_string(&info,": ");
    uVar5 = get_file_handles_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld handle",(uchar *)"%ld handles",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_timers_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld timer",(uchar *)"%ld timers",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = gettext((uchar *)"Connections");
    add_to_string(&info,puVar4);
    add_to_string(&info,": ");
    uVar5 = get_connections_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld connection",(uchar *)"%ld connections",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_connections_connecting_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld connecting",(uchar *)"%ld connecting",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_connections_transfering_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld transferring",(uchar *)"%ld transferring",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_keepalive_connections_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld keepalive",(uchar *)"%ld keepalive",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = gettext((uchar *)"Memory cache");
    add_to_string(&info,puVar4);
    add_to_string(&info,": ");
    uVar7 = get_cache_size();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld byte",(uchar *)"%ld bytes",(ulong)uVar7);
    add_format_to_string(&info,puVar4,(ulong)uVar7,(int)(uVar7 >> 0x20));
    add_to_string(&info,", ");
    uVar5 = get_cache_entry_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld file",(uchar *)"%ld files",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_cache_entry_used_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld in use",(uchar *)"%ld in use",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_cache_entry_loading_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld loading",(uchar *)"%ld loading",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = gettext((uchar *)"Document cache");
    add_to_string(&info,puVar4);
    add_to_string(&info,": ");
    uVar5 = get_format_cache_size();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld formatted",(uchar *)"%ld formatted",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_format_cache_used_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld in use",(uchar *)"%ld in use",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    uVar5 = get_format_cache_refresh_count();
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld refreshing",(uchar *)"%ld refreshing",uVar5);
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,".\n");
    if ((term != (terminal *)0x0) && (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = gettext((uchar *)"Interlinking");
    add_to_string(&info,puVar4);
    add_to_string(&info,": ");
    if ((term->field_0x38 & 1) == 0) {
      iVar3 = get_terminal_codepage(term);
      if (iVar3 != current_charset) {
        puVar4 = get_cp_mime_name(iVar3);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar3;
      }
      puVar4 = gettext((uchar *)"slave terminal");
    }
    else {
      iVar3 = get_terminal_codepage(term);
      if (iVar3 != current_charset) {
        puVar4 = get_cp_mime_name(iVar3);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar3;
      }
      puVar4 = gettext((uchar *)"master terminal");
    }
    uVar5 = 0;
    add_to_string(&info,puVar4);
    add_to_string(&info,", ");
    plVar6 = (list_head_elinks *)terminals.next;
    if ((list_head_elinks *)terminals.next != &terminals) {
      do {
        ppvVar1 = &plVar6->next;
        uVar5 = uVar5 + 1;
        plVar6 = (list_head_elinks *)*ppvVar1;
      } while ((list_head_elinks *)*ppvVar1 != &terminals);
    }
    iVar3 = get_terminal_codepage(term);
    if (iVar3 != current_charset) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld terminal",(uchar *)"%ld terminals",uVar5);
    n = 0;
    add_format_to_string(&info,puVar4,uVar5);
    add_to_string(&info,", ");
    plVar6 = (list_head_elinks *)sessions.next;
    if ((list_head_elinks *)sessions.next != &sessions) {
      do {
        ppvVar1 = &plVar6->next;
        n = n + 1;
        plVar6 = (list_head_elinks *)*ppvVar1;
      } while ((list_head_elinks *)*ppvVar1 != &sessions);
    }
    iVar3 = get_terminal_codepage(term);
    if (iVar3 != current_charset) {
      puVar4 = get_cp_mime_name(iVar3);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar3;
    }
    puVar4 = ngettext((uchar *)"%ld session",(uchar *)"%ld sessions",n);
    add_format_to_string(&info,puVar4,n);
    add_char_to_string(&info,'.');
    puVar4 = info.source;
  }
  return puVar4;
}



// WARNING: Unknown calling convention

void dont_exit_prog(void *ses_)

{
  *(undefined4 *)((int)ses_ + 0x88) = 0;
  return;
}



// WARNING: Unknown calling convention

void add_uri_command_to_menu(menu_item **mi,pass_uri_type type,uchar *text)

{
  list_head_elinks *plVar1;
  bool bVar2;
  option_value *poVar3;
  option_elinks *option_elinks;
  list_head_elinks *plVar4;
  menu_item_flags flags;
  int iVar5;
  byte *pbVar6;
  byte *pbVar7;
  bool bVar8;
  bool bVar9;
  byte bVar10;
  main_action local_28;
  
  bVar10 = 0;
  poVar3 = get_opt_();
  plVar1 = poVar3->tree;
  local_28 = ACT_MAIN_TAB_EXTERNAL_COMMAND;
  if (type < PASS_URI_TAB) {
    local_28 = *(main_action *)((int)&CSWTCH_174 + type * 4);
  }
  plVar4 = (list_head_elinks *)plVar1->next;
  bVar9 = plVar4 == plVar1;
  if (!bVar9) {
    bVar2 = false;
    do {
      bVar8 = plVar4 < plVar1;
      iVar5 = 0xb;
      pbVar6 = (byte *)plVar4[1].prev;
      pbVar7 = (byte *)0x813178d;
      do {
        if (iVar5 == 0) break;
        iVar5 = iVar5 + -1;
        bVar8 = *pbVar6 < *pbVar7;
        bVar9 = *pbVar6 == *pbVar7;
        pbVar6 = pbVar6 + (uint)bVar10 * -2 + 1;
        pbVar7 = pbVar7 + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      if ((!bVar8 && !bVar9) != bVar8) {
        if (bVar2) {
          flags = SUBMENU;
          goto LAB_0807bf35;
        }
        bVar2 = true;
      }
      plVar4 = (list_head_elinks *)plVar4->next;
      bVar9 = plVar4 == plVar1;
    } while (!bVar9);
    if (bVar2) {
      flags = NO_FLAG;
LAB_0807bf35:
      add_to_menu(mi,text,(uchar *)0x0,local_28,(menu_func_T)0x0,(void *)0x0,flags);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void do_setup_menu(terminal *term,void *xxx,void *ses_)

{
  option_value *poVar1;
  
  poVar1 = get_opt_();
  if (poVar1->tree != (list_head_elinks *)0x0) {
    do_menu(term,setup_menu_anon,ses_,1);
    return;
  }
  do_menu(term,setup_menu,ses_,1);
  return;
}



// WARNING: Unknown calling convention

void do_submenu(terminal *term,void *menu_,void *ses_)

{
  do_menu(term,(menu_item *)menu_,ses_,1);
  return;
}



// WARNING: Unknown calling convention

void history_menu_common(terminal *term,session *ses,int unhist)

{
  location *plVar1;
  uchar *url;
  uchar *text;
  location *loc;
  menu_item *local_20 [4];
  
  local_20[0] = (menu_item *)0x0;
  plVar1 = (ses->history).current;
  if (plVar1 != (location *)0x0) {
    if (unhist == 0) {
      loc = plVar1->prev;
    }
    else {
      loc = plVar1->next;
    }
    while ((location *)&ses->history != loc) {
      if ((local_20[0] == (menu_item *)0x0) &&
         (local_20[0] = new_menu(FREE_LIST|FREE_TEXT|NO_INTL), local_20[0] == (menu_item *)0x0)) {
        return;
      }
      text = get_uri_string((loc->vs).uri,URI_PUBLIC);
      if (text != (uchar *)0x0) {
        add_to_menu(local_20,text,(uchar *)0x0,ACT_MAIN_NONE,go_historywards,loc,NO_FLAG);
      }
      if (unhist == 0) {
        loc = loc->prev;
      }
      else {
        loc = loc->next;
      }
    }
    if (local_20[0] != (menu_item *)0x0) {
      do_menu(term,local_20[0],ses,0);
      return;
    }
  }
  do_menu(term,no_hist_menu,ses,0);
  return;
}



// WARNING: Unknown calling convention

void unhistory_menu(terminal *term,void *xxx,void *ses_)

{
  history_menu_common(term,(session *)ses_,1);
  return;
}



// WARNING: Unknown calling convention

void history_menu(terminal *term,void *xxx,void *ses_)

{
  history_menu_common(term,(session *)ses_,0);
  return;
}



// WARNING: Unknown calling convention

void do_pass_uri_to_command(terminal *term,void *command_,void *xxx)

{
  exec_on_terminal(term,(uchar *)command_,"",TERM_EXEC_BG);
  mem_free(command_);
  return;
}



// WARNING: Unknown calling convention

void add_new_win_to_menu(menu_item **mi,uchar *text,terminal *term)

{
  int iVar1;
  int c;
  option_value *poVar2;
  menu_item_flags flags;
  
  iVar1 = can_open_in_new(term);
  if (iVar1 != 0) {
    poVar2 = get_opt_();
    if (poVar2->tree == (list_head_elinks *)0x0) {
      poVar2 = get_opt_();
      if (poVar2->tree == (list_head_elinks *)0x0) {
        poVar2 = get_opt_();
        if (poVar2->tree == (list_head_elinks *)0x0) {
          flags = NO_FLAG;
          if (iVar1 != 1) {
            flags = SUBMENU;
          }
          add_to_menu(mi,text,(uchar *)0x0,ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW,open_in_new_window,
                      send_open_in_new_window,flags);
        }
      }
    }
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x0807c34b)
// WARNING: Unknown calling convention

void open_in_new_window(terminal *term,void *func_,void *ses_)

{
  int iVar1;
  term_env_type tVar2;
  open_in_new *data;
  menu_item *local_20 [4];
  
  if (assert_failed == 0) {
    if (((ses_ == (void *)0x0) || (term == (terminal *)0x0)) || (func_ == (void *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x2c4;
      elinks_internal((uchar *)"assertion term && ses && func failed!");
      if (assert_failed != 0) goto LAB_0807c2e8;
    }
    else {
      assert_failed = 0;
    }
    iVar1 = can_open_in_new(term);
    if (iVar1 != 0) {
      if (iVar1 == 1) {
        local_20[0] = (menu_item *)0x0;
      }
      else {
        local_20[0] = new_menu(FREE_LIST);
        if (local_20[0] == (menu_item *)0x0) {
          return;
        }
      }
      tVar2 = ENV_XWIN;
      data = open_in_new;
      do {
        if ((term->environment & tVar2) != 0) {
          if (local_20[0] == (menu_item *)0x0) {
            (*(code *)func_)(term,data,ses_);
            return;
          }
          add_to_menu(local_20,data->text,(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T)func_,data,NO_FLAG
                     );
        }
        tVar2 = data[1].env;
        data = data + 1;
      } while (tVar2 != ~ENV_ANY);
      do_menu(term,local_20[0],ses_,1);
      return;
    }
  }
  else {
LAB_0807c2e8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void add_cmdline_bool_option(string *string,uchar *name)

{
  option_value *poVar1;
  
  poVar1 = get_opt_();
  if (poVar1->tree != (list_head_elinks *)0x0) {
    add_to_string(string," -");
    add_to_string(string,name);
  }
  return;
}



// WARNING: Unknown calling convention

void open_uri_in_new_window
               (session *ses,uri *uri,uri *referrer,term_env_type env,cache_mode cache_mode,
               task_type task)

{
  list_head_elinks *plVar1;
  option_value *poVar2;
  int iVar3;
  int id;
  string *psVar4;
  char *pcVar5;
  string parameters;
  
  pcVar5 = "session-ring";
  poVar2 = get_opt_();
  plVar1 = poVar2->tree;
  if (assert_failed == 0) {
    assert_failed = (int)(env == ~ENV_ANY || ses == (session *)0x0);
    if (env == ~ENV_ANY || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x280;
      elinks_internal((uchar *)"assertion env && ses failed!",pcVar5);
      if (assert_failed != 0) goto LAB_0807c565;
    }
    iVar3 = add_session_info(ses,uri,referrer,cache_mode,task);
    if (0 < iVar3) {
      psVar4 = init_string(&parameters);
      if (psVar4 != (string *)0x0) {
        add_format_to_string(&parameters,(uchar *)"-base-session %d",iVar3);
        if (plVar1 != (list_head_elinks *)0x0) {
          add_format_to_string(&parameters,(uchar *)" -session-ring %d",plVar1);
        }
        if (uri == (uri *)0x0) {
          add_cmdline_bool_option(&parameters,(uchar *)"localhost");
          add_cmdline_bool_option(&parameters,(uchar *)"no-home");
          add_cmdline_bool_option(&parameters,(uchar *)"no-connect");
        }
        open_new_window(ses->tab->term,program.path,env,parameters.source);
        done_string(&parameters);
      }
    }
  }
  else {
LAB_0807c565:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void send_open_new_window(terminal *term,open_in_new *open,session *ses)

{
  open_uri_in_new_window(ses,(uri *)0x0,(uri *)0x0,open->env,CACHE_MODE_NORMAL,TASK_NONE);
  return;
}



// WARNING: Unknown calling convention

void send_open_in_new_window(terminal *term,open_in_new *open,session *ses)

{
  int iVar1;
  document_view *doc_view;
  document_view *doc_view_00;
  uri *uri_00;
  link *link;
  link *link_00;
  uri *uri;
  
  if (assert_failed == 0) {
    if (((open == (open_in_new *)0x0) || (term == (terminal *)0x0)) || (ses == (session *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x2a2;
      elinks_internal((uchar *)"assertion term && open && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    doc_view_00 = current_frame(ses);
    if (assert_failed == 0) {
      if (((doc_view_00 == (document_view *)0x0) || (doc_view_00->vs == (view_state *)0x0)) ||
         (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
        errline = 0x2a5;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
        if (doc_view_00 == (document_view *)0x0) {
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view_00->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (iVar1 < doc_view_00->document->nlinks) {
        link_00 = doc_view_00->document->links + iVar1;
        if (link_00 == (link *)0x0) {
          return;
        }
        uri_00 = get_link_uri(ses,doc_view_00,link_00);
        if (uri_00 != (uri *)0x0) {
          open_uri_in_new_window(ses,uri_00,(uri *)0x0,open->env,CACHE_MODE_NORMAL,TASK_NONE);
          done_uri(uri_00);
          return;
        }
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void free_history_lists(void)

{
  xlist_head *head;
  input_history *p;
  input_history *piVar1;
  input_history *piVar2;
  xlist_head *next;
  bool bVar3;
  
  piVar2 = (input_history *)file_history.entries.next;
  if ((input_history *)file_history.entries.next != &file_history) {
    do {
      piVar2 = (input_history *)(piVar2->entries).next;
    } while (piVar2 != &file_history);
  }
  piVar1 = (input_history *)file_history.entries.prev;
  if ((input_history *)file_history.entries.prev != piVar2) {
    do {
      piVar1 = (input_history *)(piVar1->entries).prev;
    } while (piVar1 != piVar2);
  }
                    // WARNING: Load size is inaccurate
  piVar1 = *file_history.entries.next;
  p = (input_history *)file_history.entries.next;
  if ((input_history *)file_history.entries.next != piVar2) {
    do {
      (piVar1->entries).prev = (p->entries).prev;
      *(void **)(p->entries).prev = (p->entries).next;
      mem_free(p);
      bVar3 = piVar1 != piVar2;
      p = piVar1;
      piVar1 = (input_history *)(piVar1->entries).next;
    } while (bVar3);
  }
  trigger_event_name((uchar *)"free-history");
  return;
}



// WARNING: Unknown calling convention

void dialog_goto_url(session *ses,uchar *url)

{
  input_dialog(ses->tab->term,(memory_list *)0x0,"Go to URL",(uchar *)"Enter URL",ses,
               &goto_url_history,0x400,url,0,0,(widget_handler_T *)0x0,goto_url_with_hook,
               (done_handler_T *)0x0);
  return;
}



// WARNING: Unknown calling convention

void save_url_as(session *ses)

{
  input_dialog(ses->tab->term,(memory_list *)0x0,(uchar *)"Save URL",(uchar *)"Enter URL",ses,
               &goto_url_history,0x400,"",0,0,(widget_handler_T *)0x0,save_url,(done_handler_T *)0x0
              );
  return;
}



// WARNING: Unknown calling convention

void activate_bfu_technology(session *ses,int item)

{
  do_mainmenu(ses->tab->term,main_menu,ses,item);
  return;
}



// WARNING: Unknown calling convention

void menu_url_shortcut(terminal *term,void *url_,void *ses_)

{
  uri *uri_00;
  uri *uri;
  
  uri_00 = get_uri((uchar *)url_,0);
  if (uri_00 != (uri *)0x0) {
    goto_uri((session *)ses_,uri_00);
    done_uri(uri_00);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void do_file_menu(terminal *term,void *xxx,void *ses_)

{
  list_head_elinks *plVar1;
  option_value *poVar2;
  menu_item *items;
  menu_item *file_menu;
  menu_item *e;
  size_t __n;
  menu_item *f;
  int o;
  int iVar3;
  int anonymous;
  menu_item *pmVar4;
  menu_item_flags mVar5;
  int x;
  menu_item *pmVar6;
  menu_item *pmVar7;
  byte bVar8;
  
  bVar8 = 0;
  poVar2 = get_opt_();
  plVar1 = poVar2->tree;
  items = (menu_item *)mem_alloc(0x2e0);
  if (items != (menu_item *)0x0) {
    if (plVar1 == (list_head_elinks *)0x0) {
      poVar2 = get_opt_();
      pmVar6 = items;
      if ((poVar2->tree == (list_head_elinks *)0x0) &&
         (poVar2 = get_opt_(), poVar2->tree == (list_head_elinks *)0x0)) {
        iVar3 = can_open_in_new(term);
        if (iVar3 != 0) {
          mVar5 = NO_FLAG;
          if (iVar3 != 1) {
            mVar5 = SUBMENU;
          }
          items->text = (uchar *)"Open ~new window";
          items->rtext = (uchar *)0x0;
          items->action_id = ACT_MAIN_OPEN_NEW_WINDOW;
          items->func = open_in_new_window;
          items->data = send_open_new_window;
          items->flags = mVar5;
          items->hotkey_state = HKS_SHOW;
          items->hotkey_pos = 0;
          pmVar6 = items + 1;
        }
        pmVar4 = file_menu11;
        pmVar7 = pmVar6;
        for (iVar3 = 0x38; iVar3 != 0; iVar3 = iVar3 + -1) {
          pmVar7->text = pmVar4->text;
          pmVar4 = (menu_item *)((int)pmVar4 + ((uint)bVar8 * -2 + 1) * 4);
          pmVar7 = (menu_item *)((int)pmVar7 + (uint)bVar8 * -8 + 4);
        }
      }
      else {
        pmVar4 = file_menu11;
        pmVar7 = items;
        for (iVar3 = 0x38; iVar3 != 0; iVar3 = iVar3 + -1) {
          pmVar7->text = pmVar4->text;
          pmVar4 = (menu_item *)((int)pmVar4 + ((uint)bVar8 * -2 + 1) * 4);
          pmVar7 = (menu_item *)((int)pmVar7 + (uint)bVar8 * -8 + 4);
        }
      }
      pmVar4 = file_menu21;
      pmVar7 = pmVar6 + 7;
      for (iVar3 = 0x28; iVar3 != 0; iVar3 = iVar3 + -1) {
        pmVar7->text = pmVar4->text;
        pmVar4 = (menu_item *)((int)pmVar4 + ((uint)bVar8 * -2 + 1) * 4);
        pmVar7 = (menu_item *)((int)pmVar7 + (uint)bVar8 * -8 + 4);
      }
      pmVar4 = file_menu22;
      pmVar7 = pmVar6 + 0xc;
      for (iVar3 = 0x28; iVar3 != 0; iVar3 = iVar3 + -1) {
        pmVar7->text = pmVar4->text;
        pmVar4 = (menu_item *)((int)pmVar4 + ((uint)bVar8 * -2 + 1) * 4);
        pmVar7 = (menu_item *)((int)pmVar7 + (uint)bVar8 * -8 + 4);
      }
      pmVar4 = pmVar6 + 0x11;
      x = 1;
      iVar3 = can_open_os_shell(term->environment);
      if (iVar3 != 0) {
        pmVar6[0x11].text = (uchar *)"~OS shell";
        x = 0;
        pmVar6[0x11].rtext = (uchar *)0x0;
        pmVar6[0x11].action_id = ACT_MAIN_OPEN_OS_SHELL;
        pmVar6[0x11].func = (menu_func_T)0x0;
        pmVar6[0x11].data = (void *)0x0;
        pmVar6[0x11].flags = NO_FLAG;
        pmVar6[0x11].hotkey_state = HKS_SHOW;
        pmVar6[0x11].hotkey_pos = 0;
        pmVar4 = pmVar6 + 0x12;
      }
    }
    else {
      pmVar6 = file_menu11;
      pmVar4 = items;
      for (iVar3 = 0x38; iVar3 != 0; iVar3 = iVar3 + -1) {
        pmVar4->text = pmVar6->text;
        pmVar6 = (menu_item *)((int)pmVar6 + ((uint)bVar8 * -2 + 1) * 4);
        pmVar4 = (menu_item *)((int)pmVar4 + (uint)bVar8 * -8 + 4);
      }
      pmVar6 = file_menu22;
      pmVar4 = items + 7;
      for (iVar3 = 0x28; iVar3 != 0; iVar3 = iVar3 + -1) {
        pmVar4->text = pmVar6->text;
        pmVar6 = (menu_item *)((int)pmVar6 + ((uint)bVar8 * -2 + 1) * 4);
        pmVar4 = (menu_item *)((int)pmVar4 + (uint)bVar8 * -8 + 4);
      }
      pmVar4 = items + 0xc;
      x = 1;
    }
    iVar3 = can_resize_window(term->environment);
    if (iVar3 == 0) {
      __n = (3 - x) * 0x20;
      pmVar6 = file_menu3 + x;
    }
    else {
      pmVar4->text = (uchar *)"Resize t~erminal";
      pmVar6 = file_menu3;
      __n = 0x60;
      pmVar4->rtext = (uchar *)0x0;
      pmVar4->action_id = ACT_MAIN_TERMINAL_RESIZE;
      pmVar4->func = (menu_func_T)0x0;
      pmVar4->data = (void *)0x0;
      pmVar4->flags = NO_FLAG;
      pmVar4->hotkey_state = HKS_SHOW;
      pmVar4->hotkey_pos = 0;
      pmVar4 = pmVar4 + 1;
    }
    memcpy(pmVar4,pmVar6,__n);
    for (pmVar6 = items; pmVar6 < pmVar4 + 3; pmVar6 = pmVar6 + 1) {
      pmVar6->flags = pmVar6->flags | FREE_LIST;
    }
    do_menu(term,items,ses_,1);
  }
  return;
}



// WARNING: Unknown calling convention

void go_historywards(terminal *term,void *target_,void *ses_)

{
  go_history((session *)ses_,(location *)target_);
  return;
}



// WARNING: Unknown calling convention

void tab_menu(session *ses,int x,int y,int place_above_cursor)

{
  list_head_elinks *plVar1;
  document *pdVar2;
  uchar *puVar3;
  option_value *poVar4;
  int iVar5;
  menu_item *menu;
  int i;
  int anonymous;
  char *pcVar6;
  menu_item *local_20 [4];
  
  pcVar6 = "anonymous";
  poVar4 = get_opt_();
  plVar1 = poVar4->tree;
  if (assert_failed == 0) {
    if ((ses == (session *)0x0) || (ses->tab == (window *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0xe7;
      elinks_internal((uchar *)"assertion ses && ses->tab failed!",pcVar6);
      if (assert_failed != 0) goto LAB_0807d080;
    }
    else {
      assert_failed = 0;
    }
    iVar5 = number_of_tabs(ses->tab->term);
    local_20[0] = new_menu(FREE_LIST);
    if (local_20[0] != (menu_item *)0x0) {
      add_to_menu(local_20,(uchar *)"Go ~back",(uchar *)0x0,ACT_MAIN_HISTORY_MOVE_BACK,
                  (menu_func_T)0x0,(void *)0x0,NO_FLAG);
      add_to_menu(local_20,(uchar *)"Go for~ward",(uchar *)0x0,ACT_MAIN_HISTORY_MOVE_FORWARD,
                  (menu_func_T)0x0,(void *)0x0,NO_FLAG);
      if ((ses->history).current != (location *)0x0) {
        add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T)0x0,(void *)0x0,NO_SELECT);
        if (plVar1 == (list_head_elinks *)0x0) {
          add_to_menu(local_20,(uchar *)"Bookm~ark document",(uchar *)0x0,ACT_MAIN_ADD_BOOKMARK,
                      (menu_func_T)0x0,(void *)0x0,NO_FLAG);
        }
        add_to_menu(local_20,(uchar *)"Toggle ~HTML/plain",(uchar *)0x0,ACT_MAIN_TOGGLE_HTML_PLAIN,
                    (menu_func_T)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"~Reload",(uchar *)0x0,ACT_MAIN_RELOAD,(menu_func_T)0x0,
                    (void *)0x0,NO_FLAG);
        if (((ses->doc_view != (document_view *)0x0) &&
            (pdVar2 = ses->doc_view->document, pdVar2 != (document *)0x0)) &&
           (pdVar2->frame_desc != (frameset_desc *)0x0)) {
          add_to_menu(local_20,(uchar *)"Frame at ~full-screen",(uchar *)0x0,ACT_MAIN_FRAME_MAXIMIZE
                      ,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
          add_uri_command_to_menu
                    (local_20,PASS_URI_FRAME,(uchar *)"~Pass frame URI to external command");
        }
      }
      add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T)0x0,(void *)0x0,NO_SELECT);
      if (iVar5 < 2) {
        add_to_menu(local_20,(uchar *)"~Close tab",(uchar *)0x0,ACT_MAIN_TAB_CLOSE,(menu_func_T)0x0,
                    (void *)0x0,NO_FLAG);
      }
      else {
        add_to_menu(local_20,(uchar *)"Nex~t tab",(uchar *)0x0,ACT_MAIN_TAB_NEXT,(menu_func_T)0x0,
                    (void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Pre~v tab",(uchar *)0x0,ACT_MAIN_TAB_PREV,(menu_func_T)0x0,
                    (void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"~Close tab",(uchar *)0x0,ACT_MAIN_TAB_CLOSE,(menu_func_T)0x0,
                    (void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"C~lose all tabs but the current",(uchar *)0x0,
                    ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
        if (plVar1 == (list_head_elinks *)0x0) {
          add_to_menu(local_20,(uchar *)"B~ookmark all tabs",(uchar *)0x0,ACT_MAIN_ADD_BOOKMARK_TABS
                      ,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
        }
      }
      if ((ses->history).current != (location *)0x0) {
        add_uri_command_to_menu(local_20,PASS_URI_TAB,(uchar *)"Pass tab URI to e~xternal command");
      }
      if (place_above_cursor != 0) {
        iVar5 = 0;
        puVar3 = local_20[0]->text;
        while (puVar3 != (uchar *)0x0) {
          iVar5 = iVar5 + 1;
          puVar3 = local_20[0][iVar5].text;
        }
        iVar5 = (y + -1) - iVar5;
        y = 0;
        if (-1 < iVar5) {
          y = iVar5;
        }
      }
      ses->tab->x = x;
      ses->tab->y = y;
      do_menu(ses->tab->term,local_20[0],ses,1);
      return;
    }
  }
  else {
LAB_0807d080:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void really_exit_prog(void *ses_)

{
  register_bottom_half_do(destroy_terminal,*(void **)(*(int *)((int)ses_ + 8) + 0x14));
  return;
}



// WARNING: Unknown calling convention

void query_exit(session *ses)

{
  terminal *term;
  int iVar1;
  char *text;
  
  ses->exit_query = 1;
  term = ses->tab->term;
  if (term->next == term->prev) {
    iVar1 = are_there_downloads();
    if (iVar1 != 0) {
      text = "Do you really want to exit ELinks (and terminate all downloads)?";
      term = ses->tab->term;
      goto LAB_0807d1b6;
    }
    term = ses->tab->term;
  }
  text = "Do you really want to exit ELinks?";
LAB_0807d1b6:
  msg_box(term,(memory_list *)0x0,0,(uchar *)"Exit ELinks",ALIGN_CENTER,(uchar *)text,ses,2,
          &DAT_0812762b,really_exit_prog,1,&DAT_08127627,dont_exit_prog,2);
  return;
}



// WARNING: Unknown calling convention

void exit_prog(session *ses,int query)

{
  int iVar1;
  
  if ((assert_failed == 0) && (assert_failed = (int)(ses == (session *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
    errline = 0x8b;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if (ses->exit_query == 0) {
    if ((query == 0) &&
       ((terminals.next != terminals.prev || (iVar1 = are_there_downloads(), iVar1 == 0)))) {
      really_exit_prog(ses);
      return;
    }
    query_exit(ses);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status pass_uri_to_command(session *ses,document_view *doc_view,int which_type)

{
  int iVar1;
  list_head_elinks *plVar2;
  uint uVar3;
  char cVar4;
  option_value *poVar5;
  menu_item *items;
  uchar *puVar6;
  string *psVar7;
  uchar *data;
  uint uVar8;
  int length;
  uchar *puVar9;
  int iVar10;
  int pos;
  size_t sVar11;
  size_t newsize;
  link *link;
  uint uVar12;
  link *link_00;
  option_elinks *option_elinks;
  list_head_elinks *plVar13;
  uchar *str;
  size_t __n;
  undefined2 *__src;
  undefined2 *puVar14;
  bool bVar15;
  byte bVar16;
  int local_40;
  uri *local_3c;
  string string;
  menu_item *local_20 [4];
  
  bVar16 = 0;
  poVar5 = get_opt_();
  plVar2 = poVar5->tree;
  if (which_type == 0) {
    local_3c = doc_view->document->uri;
    (local_3c->object).refcount = (local_3c->object).refcount + 1;
  }
  else if (which_type == 1) {
    if (doc_view == (document_view *)0x0) {
      return FRAME_EVENT_OK;
    }
    iVar10 = doc_view->vs->current_link;
    if (iVar10 < 0) {
      return FRAME_EVENT_OK;
    }
    if (doc_view->document->nlinks <= iVar10) {
      return FRAME_EVENT_OK;
    }
    link_00 = doc_view->document->links + iVar10;
    if (link_00 == (link *)0x0) {
      return FRAME_EVENT_OK;
    }
    local_3c = get_link_uri(ses,doc_view,link_00);
    if (local_3c == (uri *)0x0) {
      return FRAME_EVENT_OK;
    }
  }
  else {
    local_3c = ses->doc_view->document->uri;
    (local_3c->object).refcount = (local_3c->object).refcount + 1;
  }
  local_20[0] = new_menu(FREE_LIST|FREE_TEXT|FREE_DATA|NO_INTL);
  if (local_20[0] == (menu_item *)0x0) {
    done_uri(local_3c);
    return FRAME_EVENT_OK;
  }
  plVar13 = (list_head_elinks *)plVar2->next;
  bVar15 = plVar13 == plVar2;
  if (bVar15) {
    done_uri(local_3c);
  }
  else {
    local_40 = 0;
    do {
      iVar10 = 0xb;
      puVar6 = (uchar *)plVar13[1].prev;
      puVar9 = "_template_";
      do {
        if (iVar10 == 0) break;
        iVar10 = iVar10 + -1;
        bVar15 = *puVar6 == *puVar9;
        puVar6 = puVar6 + (uint)bVar16 * -2 + 1;
        puVar9 = puVar9 + (uint)bVar16 * -2 + 1;
      } while (bVar15);
      if ((!bVar15) && (puVar6 = stracpy((uchar *)plVar13[1].prev), puVar6 != (uchar *)0x0)) {
        __src = (undefined2 *)plVar13[4].next;
        psVar7 = init_string(&string);
        if (psVar7 != (string *)0x0) {
LAB_0807d3c6:
          cVar4 = *(char *)__src;
          if (cVar4 != '\0') {
            do {
              sVar11 = 0;
              __n = 0;
              puVar14 = __src;
              if (cVar4 != '%') {
                do {
                  sVar11 = sVar11 + 1;
                  __n = sVar11;
                  puVar14 = (undefined2 *)(sVar11 + (int)__src);
                  if (*(char *)((int)__src + sVar11) == '%') break;
                } while (*(char *)((int)__src + sVar11) != '\0');
              }
              if (assert_failed == 0) {
                if ((int)__n < 0) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 0xff;
                  elinks_internal((uchar *)
                                  "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                 );
                  if (assert_failed != 0) goto LAB_0807d402;
                }
                else {
                  assert_failed = 0;
                }
                if (__n != 0) {
                  iVar10 = __n + string.length;
                  uVar3 = string.length + 0xffU >> 8;
                  uVar8 = string.length + 0xffU & 0xffffff00;
                  uVar12 = iVar10 + 0x100U & 0xffffff00;
                  if (uVar8 <= uVar12 && uVar12 + uVar3 * -0x100 != 0) {
                    puVar9 = (uchar *)mem_realloc(string.source,uVar12);
                    if (puVar9 == (uchar *)0x0) goto LAB_0807d410;
                    string.source = puVar9;
                    memset(puVar9 + uVar8,0,uVar12 + uVar3 * -0x100);
                  }
                  if (string.source != (uchar *)0x0) {
                    memcpy(string.source + string.length,__src,__n);
                    string.source[iVar10] = '\0';
                    string.length = iVar10;
                  }
                }
              }
              else {
LAB_0807d402:
                assert_failed = 0;
              }
LAB_0807d410:
              iVar10 = string.length;
              cVar4 = *(char *)puVar14;
              if (cVar4 == '%') goto LAB_0807d4c8;
              __src = puVar14;
              if (cVar4 == '\0') break;
            } while( true );
          }
          if (string.source == (uchar *)0x0) goto LAB_0807d780;
          add_to_menu(local_20,puVar6,(uchar *)0x0,ACT_MAIN_NONE,do_pass_uri_to_command,
                      string.source,NO_FLAG);
          local_40 = local_40 + 1;
          plVar13 = (list_head_elinks *)plVar13->next;
          goto joined_r0x0807d46e;
        }
LAB_0807d780:
        mem_free(puVar6);
      }
      plVar13 = (list_head_elinks *)plVar13->next;
joined_r0x0807d46e:
      bVar15 = plVar13 == plVar2;
    } while (!bVar15);
    done_uri(local_3c);
    if (1 < local_40) {
      do_menu(ses->tab->term,local_20[0],ses,1);
      return FRAME_EVENT_OK;
    }
    if (local_40 == 1) {
      do_pass_uri_to_command(ses->tab->term,local_20[0]->data,ses);
      goto LAB_0807d49d;
    }
  }
  mem_free(local_20[0]->data);
LAB_0807d49d:
  mem_free(local_20[0]->text);
  mem_free(local_20[0]);
  return FRAME_EVENT_OK;
LAB_0807d4c8:
  if (*(char *)((int)puVar14 + 1) == '%') {
    add_char_to_string(&string,'%');
  }
  else if (*(char *)((int)puVar14 + 1) == 'c') {
    puVar9 = local_3c->string;
    if (local_3c->post == (uchar *)0x0) {
      length = strlen((char *)puVar9);
    }
    else {
      length = (int)local_3c->post + (-1 - (int)puVar9);
    }
    add_shell_quoted_to_string(&string,puVar9,length);
  }
  else if (assert_failed == 0) {
    assert_failed = 0;
    uVar12 = string.length + 0x102U & 0xffffff00;
    uVar3 = string.length + 0xffU >> 8;
    uVar8 = string.length + 0xffU & 0xffffff00;
    iVar1 = string.length + 2;
    if (uVar8 <= uVar12 && uVar12 + uVar3 * -0x100 != 0) {
      puVar9 = (uchar *)mem_realloc(string.source,uVar12);
      if (puVar9 == (uchar *)0x0) goto LAB_0807d536;
      string.source = puVar9;
      memset(puVar9 + uVar8,0,uVar12 + uVar3 * -0x100);
    }
    if (string.source != (uchar *)0x0) {
      *(undefined2 *)(string.source + string.length) = *puVar14;
      string.source[iVar10 + 2] = '\0';
      string.length = iVar1;
    }
  }
  else {
    assert_failed = 0;
  }
LAB_0807d536:
  __src = (undefined2 *)((int)puVar14 + (2 - (uint)(*(char *)((int)puVar14 + 1) == '\0')));
  goto LAB_0807d3c6;
}



// WARNING: Unknown calling convention

void query_file(session *ses,uri *uri,void *data,_func_void_void_ptr_uchar_ptr *std,
               _func_void_void_ptr *cancel,int interactive)

{
  connection_state state;
  protocol_external_handler_T *ppVar1;
  uint uVar2;
  string *psVar3;
  option_value *poVar4;
  string def;
  
  if (assert_failed == 0) {
    assert_failed = (int)(uri == (uri *)0x0 || ses == (session *)0x0);
    if (uri == (uri *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x230;
      elinks_internal((uchar *)"assertion ses && uri failed!");
      if (assert_failed != 0) goto LAB_0807d8c8;
    }
    if (uri->protocol == 0x12) {
      assert_failed = 0;
      print_error_dialog(ses,(connection_state)0xfffe7951,uri,PRI_CANCEL);
    }
    else {
      ppVar1 = get_protocol_external_handler(ses->tab->term,uri);
      if (ppVar1 == (protocol_external_handler_T *)0x0) {
        psVar3 = init_string(&def);
        if (psVar3 != (string *)0x0) {
          poVar4 = get_opt_();
          add_to_string(&def,poVar4->string);
          if ((def.length != 0) && (def.source[def.length + -1] != '/')) {
            add_char_to_string(&def,'/');
          }
          add_mime_filename_to_string(&def,uri);
          if ((ses->tab->term->field_0x38 & 2) == 0) {
            decode_uri_string_for_display(&def);
          }
          else {
            decode_uri_string(&def);
          }
          if (interactive == 0) {
            (*std)(data,def.source);
          }
          else {
            input_dialog(ses->tab->term,(memory_list *)0x0,(uchar *)"Download",
                         (uchar *)"Save to file",data,&file_history,0x400,def.source,0,0,
                         check_nonempty,std,(done_handler_T *)cancel);
          }
          done_string(&def);
        }
      }
      else {
        if (assert_failed == 0) {
          uVar2 = 0xfffe7950;
        }
        else {
          uVar2 = 0xfffe795d;
        }
        assert_failed = 0;
        state.syserr = 0;
        state.basic = uVar2;
        print_error_dialog(ses,state,uri,PRI_CANCEL);
      }
    }
  }
  else {
LAB_0807d8c8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void save_url(session *ses,uchar *url)

{
  connection_state state;
  uri *puVar1;
  uri *uri;
  document_view *pdVar2;
  document_view *doc_view;
  uint uVar3;
  
  if (assert_failed == 0) {
    if ((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) || (url == (uchar *)0x0)) ||
       (ses->tab->term == (terminal *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x46;
      elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && url failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    if (*url == '\0') {
      return;
    }
    puVar1 = get_translated_uri(url,ses->tab->term->cwd);
    if (puVar1 == (uri *)0x0) {
      if (assert_failed == 0) {
        uVar3 = 0xfffe7957;
      }
      else {
        uVar3 = 0xfffe795d;
      }
      assert_failed = 0;
      state.syserr = 0;
      state.basic = uVar3;
      print_error_dialog(ses,state,(uri *)0x0,PRI_CANCEL);
      return;
    }
    if (ses->download_uri != (uri *)0x0) {
      done_uri(ses->download_uri);
    }
    ses->download_uri = puVar1;
    pdVar2 = current_frame(ses);
    if (assert_failed == 0) {
      if (((pdVar2 == (document_view *)0x0) || (pdVar2->document == (document *)0x0)) ||
         (pdVar2->document->uri == (uri *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
        errline = 0x56;
        elinks_internal((uchar *)
                        "assertion doc_view && doc_view->document && doc_view->document->uri failed!"
                       );
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      set_session_referrer(ses,pdVar2->document->uri);
      query_file(ses,ses->download_uri,ses,start_download,(_func_void_void_ptr *)0x0,1);
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void auto_complete_file(terminal *term,int no_elevator,uchar *path,menu_func_T file_func,
                       menu_func_T dir_func,void *data)

{
  char *pcVar1;
  uchar uVar2;
  void *p;
  directory_entry *pdVar3;
  option_value *poVar4;
  uri *uri_00;
  uri *uri;
  uchar *puVar5;
  uchar *__s;
  menu_item *pmVar6;
  size_t sVar7;
  directory_entry *p_00;
  int iVar8;
  uchar *text_00;
  uchar *__s1;
  uchar *puVar9;
  uchar *filename;
  directory_entry *entry;
  directory_entry *pdVar10;
  uchar *text;
  int is_dir;
  int new_charset;
  int new_charset_1;
  uchar *text_1;
  int local_3c;
  int local_34;
  undefined4 local_24;
  uchar *local_20 [4];
  
  if (assert_failed == 0) {
    if ((((data == (void *)0x0) || (term == (terminal *)0x0)) || (dir_func == (menu_func_T)0x0)) ||
       (file_func == (menu_func_T)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 0x41a;
      elinks_internal((uchar *)"assertion term && data && file_func && dir_func && data failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  poVar4 = get_opt_();
  if (poVar4->tree == (list_head_elinks *)0x0) {
    if (*path == '\0') {
      path = "./";
    }
    uri_00 = get_translated_uri(path,term->cwd);
    if (uri_00 != (uri *)0x0) {
      if (uri_00->protocol == 4) {
        local_20[0] = get_uri_string(uri_00,URI_PATH);
        done_uri(uri_00);
        if (local_20[0] != (uchar *)0x0) {
          puVar5 = get_filename_position(local_20[0]);
          if (*puVar5 != '\0') {
            iVar8 = file_is_dir(local_20[0]);
            if (iVar8 == 0) {
              if ((*puVar5 != '\0') && (iVar8 = file_exists(local_20[0]), iVar8 != 0)) {
                (*file_func)(term,local_20[0],data);
                return;
              }
            }
            else {
              sVar7 = strlen((char *)local_20[0]);
              puVar5 = local_20[0] + sVar7;
            }
          }
          __s = stracpy(puVar5);
          *puVar5 = '\0';
          if (puVar5[-1] != '/') {
            local_24 = (menu_item *)CONCAT31(local_24._1_3_,*local_20[0]);
            insert_in_string(local_20,(int)puVar5 - (int)local_20[0],(uchar *)&local_24,1);
          }
          puVar5 = local_20[0];
          pmVar6 = new_menu(FREE_LIST|NO_INTL);
          local_24 = pmVar6;
          sVar7 = strlen((char *)__s);
          if (pmVar6 != (menu_item *)0x0) {
            p_00 = get_directory_entries(puVar5,1);
            if (p_00 != (directory_entry *)0x0) {
              if (p_00->name == (uchar *)0x0) {
                mem_free(p_00);
              }
              else {
                local_3c = 0;
                local_34 = 0;
                pdVar10 = p_00;
                do {
                  while( true ) {
                    uVar2 = *pdVar10->attrib;
                    mem_free(pdVar10->attrib);
                    if (((uVar2 == '-') || (uVar2 == 'd')) &&
                       (iVar8 = file_can_read(pdVar10->name), iVar8 != 0)) break;
LAB_0807ddf8:
                    mem_free(pdVar10->name);
LAB_0807de03:
                    pdVar3 = pdVar10 + 1;
                    pdVar10 = pdVar10 + 1;
                    if (pdVar3->name == (uchar *)0x0) goto LAB_0807def0;
                  }
                  text_00 = get_filename_position(pdVar10->name);
                  iVar8 = strncmp((char *)__s,(char *)text_00,sVar7);
                  if ((iVar8 != 0) ||
                     ((((no_elevator != 0 && (*text_00 == '.')) && (text_00[1] == '.')) &&
                      (text_00[2] == '\0')))) goto LAB_0807ddf8;
                  if (uVar2 != 'd') {
                    if (local_3c == 0) {
                      if (local_34 != 0) {
                        add_to_menu((menu_item **)&local_24,"",(uchar *)0x0,ACT_MAIN_NONE,
                                    (menu_func_T)0x0,(void *)0x0,NO_SELECT);
                      }
                      if ((term != (terminal *)0x0) &&
                         (iVar8 = get_terminal_codepage(term), iVar8 != current_charset)) {
                        puVar9 = get_cp_mime_name(iVar8);
                        bind_textdomain_codeset("elinks",puVar9);
                        current_charset = iVar8;
                      }
                      puVar9 = gettext((uchar *)"Files:");
                      add_to_menu((menu_item **)&local_24,puVar9,(uchar *)0x0,ACT_MAIN_NONE,
                                  (menu_func_T)0x0,(void *)0x0,NO_SELECT);
                      add_to_menu((menu_item **)&local_24,"",(uchar *)0x0,ACT_MAIN_NONE,
                                  (menu_func_T)0x0,(void *)0x0,NO_SELECT);
                    }
                    add_to_menu((menu_item **)&local_24,text_00,(uchar *)0x0,ACT_MAIN_NONE,file_func
                                ,pdVar10->name,FREE_DATA);
                    local_3c = local_3c + 1;
                    goto LAB_0807de03;
                  }
                  if (local_34 == 0) {
                    if ((term != (terminal *)0x0) &&
                       (iVar8 = get_terminal_codepage(term), iVar8 != current_charset)) {
                      puVar9 = get_cp_mime_name(iVar8);
                      bind_textdomain_codeset("elinks",puVar9);
                      current_charset = iVar8;
                    }
                    puVar9 = gettext((uchar *)"Directories:");
                    add_to_menu((menu_item **)&local_24,puVar9,(uchar *)0x0,ACT_MAIN_NONE,
                                (menu_func_T)0x0,(void *)0x0,NO_SELECT);
                    add_to_menu((menu_item **)&local_24,"",(uchar *)0x0,ACT_MAIN_NONE,
                                (menu_func_T)0x0,(void *)0x0,NO_SELECT);
                  }
                  add_to_menu((menu_item **)&local_24,text_00,(uchar *)0x0,ACT_MAIN_NONE,dir_func,
                              pdVar10->name,FREE_DATA|SUBMENU);
                  local_34 = local_34 + 1;
                  pdVar3 = pdVar10 + 1;
                  pdVar10 = pdVar10 + 1;
                } while (pdVar3->name != (uchar *)0x0);
LAB_0807def0:
                mem_free(p_00);
                if ((local_34 != 0) || (local_3c != 0)) {
                  if (local_34 + local_3c == 1) {
                    p = local_24[2].data;
                    mem_free(local_24);
                    if (local_3c == 0) {
                      sVar7 = strlen((char *)puVar5);
                      pcVar1 = (char *)((int)p + sVar7);
                      if (((*pcVar1 == '.') && (pcVar1[1] == '.')) && (pcVar1[2] == '\0')) {
                        do_menu(term,empty_directory_menu,(void *)0x0,0);
                      }
                      else {
                        (*dir_func)(term,p,data);
                      }
                      mem_free(p);
                    }
                    else {
                      (*file_func)(term,p,data);
                    }
                  }
                  else {
                    do_menu(term,local_24,data,0);
                  }
                  goto LAB_0807df39;
                }
              }
            }
            mem_free(local_24);
          }
LAB_0807df39:
          mem_free(local_20[0]);
          mem_free(__s);
          return;
        }
      }
      else {
        done_uri(uri_00);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void push_resize_button(void *data)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar str [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(str,0x400,1,0x400,"%s,%s,%d,%d",width_str,height_str,
                 *(undefined4 *)((int)data + 0x2c),*(undefined4 *)((int)data + 0x30));
  do_terminal_function((terminal *)data,'\x02',str);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void menu_language_list(terminal *term,void *xxx,void *ses)

{
  uchar *rtext;
  int i;
  void *data;
  void *pvVar1;
  menu_item *local_10;
  
  local_10 = new_menu(FREE_LIST);
  if (local_10 != (menu_item *)0x0) {
    if (languages[0].name != (uchar *)0x0) {
      data = (void *)0x0;
      do {
        rtext = language_to_iso639((int)data);
        pvVar1 = (void *)((int)data + 1);
        add_to_menu(&local_10,languages[(int)data].name,rtext,ACT_MAIN_NONE,menu_set_language,data,
                    NO_FLAG);
        data = pvVar1;
      } while (languages[(int)pvVar1].name != (uchar *)0x0);
    }
    do_menu_selected(term,local_10,ses,current_language,0);
  }
  return;
}



// WARNING: Unknown calling convention

void menu_set_language(terminal *term,void *pcp_,void *xxx)

{
  set_language((int)pcp_);
  cls_redraw_all_terminals();
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_ok_button(dialog_data *dlg_data,widget_data *button)

{
  terminal *ptVar1;
  option_value *values_00;
  widget_handler_status_T wVar2;
  option_value *values;
  terminal *term;
  
  ptVar1 = dlg_data->win->term;
  values_00 = (option_value *)dlg_data->dlg->udata;
  update_dialog_data(dlg_data);
  commit_option_values(resolvers,ptVar1->spec,values_00,8);
  if (button->widget->handler != push_ok_button) {
    return EVENT_PROCESSED;
  }
  wVar2 = cancel_dialog(dlg_data,button);
  return wVar2;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_save_button(dialog_data *dlg_data,widget_data *button)

{
  push_ok_button(dlg_data,button);
  write_config(dlg_data->win->term);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void charset_list(terminal *term,void *xxx,void *ses_)

{
  int iVar1;
  uchar *__s1;
  menu_item *mi;
  uchar *puVar2;
  int iVar3;
  uchar *text;
  int i;
  uchar *name;
  int selected;
  int sel;
  menu_item *local_20 [4];
  
  iVar1 = get_terminal_codepage(term);
  __s1 = get_cp_mime_name(iVar1);
  local_20[0] = new_menu(FREE_LIST);
  if (local_20[0] != (menu_item *)0x0) {
    selected = 0;
    iVar1 = 0;
    while( true ) {
      text = get_cp_name(iVar1);
      if (text == (uchar *)0x0) break;
      puVar2 = get_cp_mime_name(iVar1);
      iVar3 = strcmp((char *)__s1,(char *)puVar2);
      if (iVar3 == 0) {
        selected = iVar1;
      }
      puVar2 = get_cp_config_name(iVar1);
      add_to_menu(local_20,text,(uchar *)0x0,ACT_MAIN_NONE,display_codepage,puVar2,NO_FLAG);
      iVar1 = iVar1 + 1;
    }
    do_menu_selected(term,local_20[0],ses_,selected,0);
  }
  return;
}



// WARNING: Unknown calling convention

void display_codepage(terminal *term,void *name_,void *xxx)

{
  option_elinks *option_elinks;
  list_head_elinks *plVar1;
  int index;
  option_elinks *opt;
  
  option_elinks = get_opt_rec(term->spec,"charset");
  plVar1 = (list_head_elinks *)get_cp_index((uchar *)name_);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(plVar1 == (list_head_elinks *)0xffffffff), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
    errline = 0x24;
    elinks_internal((uchar *)"assertion index != -1 failed: %s",name_);
  }
  if (plVar1 != (option_elinks->value).tree) {
    (option_elinks->value).number = (int)plVar1;
    option_changed((session *)0x0,option_elinks);
  }
  cls_redraw_all_terminals();
  return;
}



// WARNING: Unknown calling convention

void resize_terminal_dialog(terminal *term)

{
  int iVar1;
  dialog *dlg_00;
  int new_charset;
  uchar *puVar2;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  memory_list *ml;
  int height;
  ulong number;
  dialog *dlg;
  int width;
  ulong number_00;
  
  number_00 = term->width;
  number = term->height;
  if (0x3e6 < (int)number_00) {
    number_00 = 999;
  }
  if (0x3e6 < (int)number) {
    number = 999;
  }
  iVar1 = can_resize_window(term->environment);
  if (iVar1 != 0) {
    elinks_ulongcat(width_str,(uint *)0x0,number_00,3,' ',10,0);
    elinks_ulongcat(height_str,(uint *)0x0,number,3,' ',10,0);
    dlg_00 = (dialog *)mem_calloc(1,0xe4);
    if (dlg_00 != (dialog *)0x0) {
      iVar1 = get_terminal_codepage(term);
      if (iVar1 != current_charset) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"Resize terminal");
      dlg_00->title = puVar2;
      dlg_00->layouter = group_layouter;
      iVar1 = get_terminal_codepage(term);
      if (iVar1 != current_charset) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"Width=");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar2,1,999,check_number,4,width_str,
                       (input_history *)0x0,INPFIELD_NONE);
      iVar1 = get_terminal_codepage(term);
      if (iVar1 != current_charset) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"Height=");
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar2,1,999,check_number,4,height_str,
                       (input_history *)0x0,INPFIELD_NONE);
      iVar1 = get_terminal_codepage(term);
      if (iVar1 != current_charset) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext("~OK");
      add_dlg_button_do(dlg_00,puVar2,1,ok_dialog,(void *)0x0,push_resize_button,term);
      iVar1 = get_terminal_codepage(term);
      if (iVar1 != current_charset) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg_00,puVar2,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0)
      ;
      if ((assert_failed == 0) &&
         (assert_failed = (int)(dlg_00->number_of_widgets != 4), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
        errline = 0x13e;
        elinks_internal((uchar *)"assertion 4 == (dlg)->number_of_widgets failed!");
      }
      ml = getml(dlg_00,0);
      do_dialog(term,dlg_00,ml);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void terminal_options(terminal *term,void *xxx,session *ses)

{
  inpfield_flags *text_00;
  int *data;
  widget *values_00;
  int iVar1;
  int iVar2;
  option_value *poVar3;
  int iVar4;
  size_t help_textlen;
  dialog *dlg_00;
  dialog *dlg;
  int new_charset;
  uchar *puVar5;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  int new_charset_5;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  int new_charset_9;
  int new_charset_10;
  int new_charset_11;
  int new_charset_12;
  int new_charset_13;
  int new_charset_14;
  int new_charset_15;
  int new_charset_16;
  int new_charset_17;
  int new_charset_18;
  int new_charset_19;
  memory_list *ml;
  uchar *puVar6;
  uint uVar7;
  uint uVar8;
  size_t eltsize;
  uchar *text;
  uint *puVar9;
  uint *puVar10;
  int new_charset_20;
  option_value *values;
  int new_charset_21;
  int in_GS_OFFSET;
  bool bVar11;
  size_t local_430;
  uchar help_text [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  poVar3 = get_opt_();
  iVar1 = poVar3->number;
  if (term->height < 0x1f) {
    eltsize = 0x435;
    iVar4 = 0;
    local_430 = 1;
  }
  else {
    puVar5 = term->spec->name;
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar6 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar6);
      current_charset = iVar4;
    }
    puVar6 = gettext((uchar *)
                     "The environmental variable TERM is set to \'%s\'.\n\nELinks maintains separate sets of values for these options\nand chooses the appropriate set based on the value of TERM.\nThis allows you to configure the settings appropriately for\neach terminal in which you run ELinks."
                    );
    __snprintf_chk(help_text,0x3fd,1,0x400,puVar6,puVar5);
    puVar10 = (uint *)help_text;
    do {
      puVar9 = puVar10;
      uVar7 = *puVar9 + 0xfefefeff & ~*puVar9;
      uVar8 = uVar7 & 0x80808080;
      puVar10 = puVar9 + 1;
    } while (uVar8 == 0);
    bVar11 = (uVar7 & 0x8080) == 0;
    if (bVar11) {
      uVar8 = uVar8 >> 0x10;
    }
    if (bVar11) {
      puVar10 = (uint *)((int)puVar9 + 6);
    }
    iVar2 = (-3 - (uint)CARRY1((byte)uVar8,(byte)uVar8)) - (int)help_text;
    local_430 = (int)puVar10 + iVar2 + 3;
    *(uchar *)((int)puVar10 + (int)(&stack0xfffffbdd + iVar2 + 3)) = '\n';
    iVar4 = (int)puVar10 + iVar2 + 2;
    *(uchar *)((int)puVar10 + (int)(&stack0xfffffbdd + iVar2 + 4)) = '\n';
    eltsize = (int)puVar10 + iVar2 + 0x437;
  }
  help_text[iVar4] = '\0';
  dlg_00 = (dialog *)mem_calloc(1,eltsize);
  if (dlg_00 != (dialog *)0x0) {
    values_00 = dlg_00[0xc].widgets;
    checkout_option_values(resolvers,term->spec,(option_value *)values_00,8);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext("Terminal options");
    *(byte *)&dlg_00->layout = *(byte *)&dlg_00->layout | 2;
    text_00 = &dlg_00[0xc].widgets[0].info.field.flags;
    dlg_00->title = puVar5;
    dlg_00->layouter = generic_dialog_layouter;
    dlg_00->udata = values_00;
    memcpy(text_00,help_text,local_430);
    add_dlg_text(dlg_00,(uchar *)text_00,ALIGN_LEFT,1);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Frame handling:");
    add_dlg_text(dlg_00,puVar5,ALIGN_LEFT,1);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"No frames");
    add_dlg_radio_do(dlg_00,puVar5,1,0,(int *)values_00);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"VT 100 frames");
    add_dlg_radio_do(dlg_00,puVar5,1,1,(int *)values_00);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Linux or OS/2 frames");
    add_dlg_radio_do(dlg_00,puVar5,1,2,(int *)values_00);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"FreeBSD frames");
    add_dlg_radio_do(dlg_00,puVar5,1,4,(int *)values_00);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"KOI8-R frames");
    add_dlg_radio_do(dlg_00,puVar5,1,3,(int *)values_00);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Color mode:");
    add_dlg_text(dlg_00,puVar5,ALIGN_LEFT,1);
    data = &dlg_00[0xc].widgets[0].datalen;
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"No colors (mono)");
    add_dlg_radio_do(dlg_00,puVar5,2,0,data);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"16 colors");
    add_dlg_radio_do(dlg_00,puVar5,2,1,data);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"88 colors");
    add_dlg_radio_do(dlg_00,puVar5,2,2,data);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"256 colors");
    add_dlg_radio_do(dlg_00,puVar5,2,3,data);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Switch fonts for line drawing");
    add_dlg_radio_do(dlg_00,puVar5,0,0,(int *)&dlg_00[0xc].widgets[0].text);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Restrict frames in cp850/852");
    add_dlg_radio_do(dlg_00,puVar5,0,0,(int *)&dlg_00[0xc].widgets[0].handler);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Block cursor");
    add_dlg_radio_do(dlg_00,puVar5,0,0,(int *)&dlg_00[0xc].widgets[0].data);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Transparency");
    add_dlg_radio_do(dlg_00,puVar5,0,0,&dlg_00[0xc].widgets[0].info.checkbox.gnum);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Underline");
    add_dlg_radio_do(dlg_00,puVar5,0,0,&dlg_00[0xc].widgets[0].info.button.textlen);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext("UTF-8 I/O");
    add_dlg_radio_do(dlg_00,puVar5,0,0,(int *)&dlg_00[0xc].widgets[0].info);
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext("~OK");
    add_dlg_button_do(dlg_00,puVar5,1,push_ok_button,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if (iVar1 == 0) {
      iVar4 = get_terminal_codepage(term);
      if (iVar4 != current_charset) {
        puVar5 = get_cp_mime_name(iVar4);
        bind_textdomain_codeset("elinks",puVar5);
        current_charset = iVar4;
      }
      puVar5 = gettext((uchar *)"Sa~ve");
      add_dlg_button_do(dlg_00,puVar5,1,push_save_button,(void *)0x0,(done_handler_T *)0x0,
                        (void *)0x0);
    }
    iVar4 = get_terminal_codepage(term);
    if (iVar4 != current_charset) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"~Cancel");
    add_dlg_button_do(dlg_00,puVar5,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if ((assert_failed == 0) &&
       (bVar11 = 0x15 - iVar1 != dlg_00->number_of_widgets, assert_failed = (int)bVar11, bVar11)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
      errline = 0xef;
      elinks_internal((uchar *)
                      "assertion (19 + 1 + 1 + 0) - anonymous == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg_00,0);
    do_dialog(term,dlg_00,ml);
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void draw_progress_bar(progress *progress,terminal *term,int x,int y,int width,uchar *text,
                      color_pair *meter_color)

{
  longlong lVar1;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  ulong local_44;
  box barprogress;
  uint local_20 [4];
  
  iVar3 = *(int *)((int)&progress->size + 4);
  if ((iVar3 < 1) && ((iVar3 < 0 || (*(int *)&progress->size == 0)))) {
    local_44 = 0;
  }
  else {
    lVar1 = (ulonglong)*(uint *)&progress->pos * 100;
    local_44 = __divdi3((int)lVar1,
                        (int)((ulonglong)lVar1 >> 0x20) + *(int *)((int)&progress->pos + 4) * 100,
                        *(int *)&progress->size,iVar3);
  }
  if ((text == (uchar *)0x0) && (2 < width)) {
    width = width - 2;
    draw_text(term,x,y,"[",1,0,(color_pair *)0x0);
    draw_text(term,width + x + 1,y,"]",1,0,(color_pair *)0x0);
    x = x + 1;
  }
  if (meter_color == (color_pair *)0x0) {
    meter_color = get_bfu_color(term,"dialog.meter");
  }
  barprogress.height = 1;
  barprogress.width = (int)(local_44 * width) / 100;
  if (width < barprogress.width) {
    barprogress.width = width;
  }
  barprogress.x = 0;
  if (-1 < x) {
    barprogress.x = x;
  }
  barprogress.y = y;
  if (y < 0) {
    barprogress.y = 0;
  }
  if (barprogress.width < 0) {
    barprogress.width = 0;
  }
  draw_box(term,&barprogress,' ',0,meter_color);
  if (text == (uchar *)0x0) {
    if (1 < width) {
      uVar4 = 5;
      if (width < 6) {
        uVar4 = width;
      }
      local_20[0] = 0;
      iVar3 = elinks_ulongcat(draw_progress_bar::lexical_block_0::s,local_20,local_44,uVar4 - 1,'\0'
                              ,10,0);
      if (iVar3 == 0) {
        uVar4 = local_20[0] + 1;
        iVar3 = -local_20[0];
      }
      else {
        draw_progress_bar::lexical_block_0::s[0] = '?';
        iVar3 = -1;
        uVar4 = 2;
        local_20[0] = 1;
      }
      draw_progress_bar::lexical_block_0::s[local_20[0]] = '%';
      local_20[0] = uVar4;
      if ((assert_failed == 0) && (assert_failed = (int)((uint)width < uVar4), assert_failed != 0))
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/progress.c";
        errline = 0x88;
        elinks_internal((uchar *)"assertion slen <= width failed!");
      }
      text = draw_progress_bar::lexical_block_0::s;
      x = ((uint)(iVar3 + width) >> 1) + x;
      width = local_20[0];
    }
  }
  else {
    sVar2 = strlen((char *)text);
    if ((int)sVar2 <= width) {
      width = sVar2;
    }
  }
  draw_text(term,x,y,text,width,0,(color_pair *)0x0);
  return;
}



// WARNING: Unknown calling convention

uchar * get_progress_msg(progress *progress,terminal *term,int wide,int full,uchar *separator)

{
  uchar uVar1;
  size_t sVar2;
  string *psVar3;
  int iVar4;
  int new_charset;
  uchar *puVar5;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  int new_charset_5;
  int new_charset_6;
  char *pcVar6;
  bool bVar7;
  string msg;
  
  sVar2 = strlen((char *)separator);
  uVar1 = separator[sVar2 - 1];
  psVar3 = init_string(&msg);
  puVar5 = (uchar *)0x0;
  if (psVar3 != (string *)0x0) {
    if ((term != (terminal *)0x0) && (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)
       ) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"Received");
    add_to_string(&msg,puVar5);
    add_char_to_string(&msg,' ');
    add_xnum_to_string(&msg,progress->pos);
    if (-1 < *(int *)((int)&progress->size + 4)) {
      add_char_to_string(&msg,' ');
      if ((term != (terminal *)0x0) &&
         (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
        puVar5 = get_cp_mime_name(iVar4);
        bind_textdomain_codeset("elinks",puVar5);
        current_charset = iVar4;
      }
      puVar5 = gettext("of");
      add_to_string(&msg,puVar5);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,progress->size);
    }
    bVar7 = uVar1 == '\n';
    add_to_string(&msg,separator);
    if (wide == 0) {
      pcVar6 = "speed";
      if (bVar7) {
        pcVar6 = "Speed";
      }
      if (*pcVar6 != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar4;
        }
        pcVar6 = (char *)gettext((uchar *)pcVar6);
      }
      add_to_string(&msg,(uchar *)pcVar6);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,(longlong)progress->average_speed);
      add_to_string(&msg,"/s");
    }
    else {
      pcVar6 = "avg";
      if ((full != 0) && (pcVar6 = "average speed", bVar7)) {
        pcVar6 = "Average speed";
      }
      if (*pcVar6 != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar4;
        }
        pcVar6 = (char *)gettext((uchar *)pcVar6);
      }
      add_to_string(&msg,(uchar *)pcVar6);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,(longlong)progress->average_speed);
      add_to_string(&msg,"/s");
      add_to_string(&msg,", ");
      pcVar6 = "current speed";
      if (full == 0) {
        pcVar6 = "cur";
      }
      if (*pcVar6 != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar4;
        }
        pcVar6 = (char *)gettext((uchar *)pcVar6);
      }
      add_to_string(&msg,(uchar *)pcVar6);
      add_char_to_string(&msg,' ');
      add_xnum_to_string(&msg,(longlong)progress->current_speed);
      add_to_string(&msg,"/s");
      pcVar6 = "ETT";
      add_to_string(&msg,separator);
      if ((full != 0) && (pcVar6 = "elapsed time", bVar7)) {
        pcVar6 = "Elapsed time";
      }
      if (*pcVar6 != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar4;
        }
        pcVar6 = (char *)gettext((uchar *)pcVar6);
      }
      add_to_string(&msg,(uchar *)pcVar6);
      add_char_to_string(&msg,' ');
      add_timeval_to_string(&msg,&progress->elapsed);
    }
    puVar5 = msg.source;
    if (((-1 < *(int *)((int)&progress->size + 4)) &&
        (iVar4 = *(int *)((int)&progress->loaded + 4), -1 < iVar4)) &&
       ((0 < iVar4 || (*(int *)&progress->loaded != 0)))) {
      pcVar6 = "estimated time";
      add_to_string(&msg,", ");
      if (full == 0) {
        pcVar6 = "ETA";
      }
      if (*pcVar6 != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar4);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar4;
        }
        pcVar6 = (char *)gettext((uchar *)pcVar6);
      }
      add_to_string(&msg,(uchar *)pcVar6);
      add_char_to_string(&msg,' ');
      add_timeval_to_string(&msg,&progress->estimated_time);
      puVar5 = msg.source;
    }
  }
  return puVar5;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Unknown calling convention

void update_status(void)

{
  byte bVar1;
  int iVar2;
  color_T cVar3;
  color_T cVar4;
  color_T cVar5;
  list_head_elinks *plVar6;
  terminal *term_00;
  terminal_screen *ptVar7;
  int iVar8;
  option_value *poVar9;
  terminal *term;
  terminal *ptVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  char cVar14;
  int dirty;
  session *ses;
  session *ses_00;
  int set_window_title;
  uint uVar15;
  bool bVar16;
  bool bVar17;
  byte local_3c;
  byte local_30;
  int local_2c;
  color_T local_24;
  color_T local_20;
  
  poVar9 = get_opt_();
  local_24 = poVar9->color;
  poVar9 = get_opt_();
  local_20 = poVar9->color;
  poVar9 = get_opt_();
  iVar2 = poVar9->number;
  poVar9 = get_opt_();
  cVar3 = poVar9->color;
  poVar9 = get_opt_();
  cVar4 = poVar9->color;
  poVar9 = get_opt_();
  cVar5 = poVar9->color;
  poVar9 = get_opt_();
  plVar6 = poVar9->tree;
  if ((list_head_elinks *)sessions.next != &sessions) {
    local_3c = (byte)cVar3;
    local_2c = 1;
    local_30 = (byte)cVar4;
    ptVar10 = (terminal *)0x0;
    ses_00 = (session *)sessions.next;
    do {
      term_00 = ses_00->tab->term;
      if (term_00 != ptVar10) {
        local_2c = number_of_tabs(term_00);
      }
      bVar1 = *(byte *)&ses_00->status;
      uVar11 = (uint)bVar1;
      cVar14 = (char)(bVar1 * '\x02') >> 6;
      uVar12 = (int)cVar14;
      if (cVar14 < '\0') {
        uVar12 = local_24;
      }
      bVar16 = (bVar1 >> 2 & 1) != uVar12;
      if (bVar16) {
        uVar11 = uVar11 & 0xfffffffb | (uVar12 & 1) << 2;
        *(char *)&ses_00->status = (char)uVar11;
      }
      cVar14 = (char)((char)uVar11 * '\b') >> 6;
      uVar15 = (int)cVar14;
      if (cVar14 < '\0') {
        uVar15 = local_20;
      }
      bVar17 = (uVar11 >> 1 & 1) != uVar15;
      if (bVar17) {
        uVar11 = uVar11 & 0xfffffffd | (uVar15 & 1) * 2;
        *(char *)&ses_00->status = (char)uVar11;
      }
      bVar17 = bVar17 || bVar16;
      uVar13 = 0;
      if (0 < iVar2) {
        uVar13 = (uint)(1 < local_2c || iVar2 != 1);
      }
      if (uVar13 != (uVar11 & 1)) {
        uVar13 = 0;
        if (0 < iVar2) {
          uVar13 = (uint)(1 < local_2c || iVar2 != 1);
        }
        uVar11 = uVar11 & 0xfffffffe | uVar13;
        bVar17 = true;
        *(char *)&ses_00->status = (char)uVar11;
      }
      if (((uVar11 & 1) != 0) && (bVar1 = (ses_00->status).field_0x34, (bVar1 >> 2 & 1) != cVar3)) {
        bVar17 = true;
        (ses_00->status).field_0x34 = bVar1 & 0xfb | (local_3c & 1) * '\x04';
      }
      bVar1 = (ses_00->status).field_0x8;
      if ((bVar1 & 1) != cVar4) {
        bVar17 = true;
        (ses_00->status).field_0x8 = bVar1 & 0xfe | local_30 & 1;
      }
      *(byte *)&ses_00->status = (byte)uVar11 & 0x7f | (byte)(cVar5 << 7);
      if (plVar6 == (list_head_elinks *)0x0) {
        ses_00->insert_mode = INSERT_MODE_LESS;
LAB_080800ca:
        if (!bVar17) goto LAB_080800d2;
LAB_08080251:
        render_document_frames(ses_00,1);
        ptVar7 = term_00->screen;
        iVar8 = term_00->height;
        if (0 < ptVar7->dirty_from) {
          ptVar7->dirty_from = 0;
        }
        if (iVar8 <= ptVar7->dirty_to) goto LAB_080800d2;
        ptVar7->dirty_to = iVar8;
        ses_00 = ses_00->next;
      }
      else {
        if (ses_00->insert_mode != INSERT_MODE_LESS) goto LAB_080800ca;
        ses_00->insert_mode = INSERT_MODE_OFF;
        if (bVar17) goto LAB_08080251;
LAB_080800d2:
        ses_00 = ses_00->next;
      }
      ptVar10 = term_00;
      local_24 = uVar12;
      local_20 = uVar15;
    } while (ses_00 != (session *)&sessions);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_download_msg(download *download,terminal *term,int wide,int full,uchar *separator)

{
  int iVar1;
  uchar *puVar2;
  
  iVar1 = download_is_progressing(download);
  if (iVar1 != 0) {
    puVar2 = get_progress_msg(download->progress,term,wide,full,separator);
    return puVar2;
  }
  puVar2 = get_state_message(download->state,term);
  puVar2 = stracpy(puVar2);
  return puVar2;
}



// WARNING: Unknown calling convention

void print_screen_status(session *ses)

{
  terminal *term_00;
  session *ses_00;
  document *pdVar1;
  cache_entry *pcVar2;
  anon_enum_32 aVar3;
  progress *progress;
  byte bVar4;
  int iVar5;
  window *pwVar6;
  color_pair *pcVar7;
  color_pair *pcVar8;
  color_pair *pcVar9;
  color_pair *pcVar10;
  color_pair *color;
  int tab_remain_width;
  document_view *doc_view;
  download *pdVar11;
  download *download;
  window *pwVar12;
  document_view *pdVar13;
  int iVar14;
  int new_charset;
  uchar *puVar15;
  size_t sVar16;
  int new_charset_1;
  uchar *doc_title;
  size_t sVar17;
  int iVar18;
  cache_entry *cached;
  option_value *poVar19;
  string *psVar20;
  int iVar21;
  document_view *doc_view_1;
  connection_basic_state cVar22;
  uchar *puVar23;
  uchar *puVar24;
  int width;
  int iVar25;
  int height;
  int iVar26;
  int ncl;
  uchar *title;
  int tab_num;
  int page;
  int msglen;
  int titlewidth;
  color_pair *text_color;
  int xend;
  uchar *link_title;
  download *download_1;
  terminal *term;
  int pos;
  int in_GS_OFFSET;
  bool bVar27;
  byte bVar28;
  int local_80;
  color_pair *local_7c;
  uchar *local_74;
  size_t local_70;
  box box;
  string title_1;
  uint local_4c;
  uchar tab_info [8];
  int local_20;
  
  bVar28 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  term_00 = ses->tab->term;
  iVar5 = number_of_tabs(term_00);
  pwVar12 = ses->tab;
  pwVar6 = get_tab_by_number(term_00,term_00->current_tab);
  if (pwVar12 != pwVar6) goto LAB_08080388;
  bVar4 = *(byte *)&ses->status;
  if ((char)bVar4 < '\0') {
    if ((((ses->doc_view == (document_view *)0x0) ||
         (pdVar1 = ses->doc_view->document, pdVar1 == (document *)0x0)) ||
        (puVar15 = pdVar1->title, puVar15 == (uchar *)0x0)) || (*puVar15 == '\0')) {
      puVar15 = stracpy("ELinks");
    }
    else {
      puVar15 = straconcat(puVar15," - ELinks",0);
    }
    if (puVar15 == (uchar *)0x0) {
      bVar4 = *(byte *)&ses->status;
    }
    else {
      sVar17 = strlen((char *)puVar15);
      if (((ses == display_window_title::last_ses) &&
          (puVar23 = (ses->status).last_title, puVar23 != (uchar *)0x0)) &&
         (sVar16 = strlen((char *)puVar23), sVar17 == sVar16)) {
        bVar27 = true;
        puVar24 = puVar15;
        do {
          if (sVar17 == 0) break;
          sVar17 = sVar17 - 1;
          bVar27 = *puVar23 == *puVar24;
          puVar23 = puVar23 + (uint)bVar28 * -2 + 1;
          puVar24 = puVar24 + (uint)bVar28 * -2 + 1;
        } while (bVar27);
        if (!bVar27) goto LAB_08080910;
      }
      else {
LAB_08080910:
        iVar18 = set_terminal_title(term_00,puVar15);
        if (-1 < iVar18) {
          puVar23 = (ses->status).last_title;
          if (puVar23 != (uchar *)0x0) {
            mem_free(puVar23);
          }
          (ses->status).last_title = puVar15;
          display_window_title::last_ses = ses;
          bVar4 = *(byte *)&ses->status;
          goto LAB_08080958;
        }
      }
      mem_free(puVar15);
      bVar4 = *(byte *)&ses->status;
    }
  }
LAB_08080958:
  if ((bVar4 & 4) != 0) {
    poVar19 = get_opt_();
    if (poVar19->tree == (list_head_elinks *)0x0) {
      box.x = 0;
      box.y = 0;
      box.height = 1;
      box.width = 0;
      if (-1 < term_00->width) {
        box.width = term_00->width;
      }
      pcVar7 = get_bfu_color(term_00,(uchar *)"title.title-bar");
      draw_box(term_00,&box,' ',0,pcVar7);
    }
    pdVar13 = current_frame(ses);
    if (pdVar13 == (document_view *)0x0) {
      bVar4 = *(byte *)&ses->status;
    }
    else if (pdVar13->document == (document *)0x0) {
      bVar4 = *(byte *)&ses->status;
    }
    else {
      psVar20 = init_string(&title_1);
      if (psVar20 != (string *)0x0) {
        pdVar1 = pdVar13->document;
        iVar18 = (pdVar13->box).height;
        iVar25 = pdVar1->height;
        if ((iVar18 < iVar25) && (pdVar13->vs != (view_state *)0x0)) {
          iVar26 = 1;
          iVar14 = pdVar13->vs->y + iVar18;
          if (iVar18 != 0) {
            iVar26 = (iVar25 + -1 + iVar18) / iVar18;
          }
          iVar21 = iVar26;
          if (((iVar14 < iVar25) && (iVar21 = 1, iVar18 != 0)) &&
             (iVar21 = (iVar14 - iVar18 / 2) / iVar18 + 1, iVar26 <= iVar21)) {
            iVar21 = iVar26;
          }
          iVar18 = __snprintf_chk(tab_info,0x28,1,0x28," (%d/%d)",iVar21,iVar26);
          if (iVar18 < 0) goto LAB_08081078;
        }
        else {
LAB_08081078:
          iVar18 = 0;
        }
        puVar15 = pdVar1->title;
        if (puVar15 != (uchar *)0x0) {
          sVar16 = (term_00->width + -4) - iVar18;
          sVar17 = 0;
          if (-1 < (int)sVar16) {
            sVar17 = sVar16;
          }
          if ((term_00->field_0x38 & 2) == 0) {
            sVar16 = strlen((char *)puVar15);
            local_70 = sVar16;
            if ((int)sVar16 < (int)sVar17) goto LAB_08080ea8;
            add_bytes_to_string__(&title_1,puVar15,sVar17);
          }
          else {
            local_70 = utf8_ptr2cells(puVar15,(uchar *)0x0);
            if ((int)sVar17 < (int)local_70) {
              local_70 = sVar17;
            }
            sVar16 = utf8_cells2bytes(pdVar1->title,local_70,(uchar *)0x0);
            puVar15 = pdVar1->title;
LAB_08080ea8:
            add_bytes_to_string__(&title_1,puVar15,sVar16);
            if (local_70 != sVar17) goto LAB_08080ebd;
          }
          add_bytes_to_string__(&title_1,"...",3);
        }
LAB_08080ebd:
        if (iVar18 != 0) {
          add_bytes_to_string__(&title_1,tab_info,iVar18);
        }
        if (title_1.length != 0) {
          if ((term_00->field_0x38 & 2) == 0) {
            iVar25 = ~title_1.length + term_00->width;
          }
          else {
            iVar18 = term_00->width;
            iVar25 = utf8_ptr2cells(title_1.source,title_1.source + title_1.length);
            iVar25 = (iVar18 + -1) - iVar25;
          }
          if (iVar25 < 1) {
            iVar25 = 0;
          }
          pcVar7 = get_bfu_color(term_00,(uchar *)"title.title-text");
          draw_text(term_00,iVar25,0,title_1.source,title_1.length,0,pcVar7);
        }
        done_string(&title_1);
      }
      bVar4 = *(byte *)&ses->status;
    }
  }
  if ((bVar4 & 2) == 0) {
LAB_08080968:
    bVar28 = (ses->status).field_0x8;
  }
  else {
    local_4c = 0;
    pdVar11 = get_current_download(ses);
    aVar3 = (ses->kbdprefix).mark;
    if (aVar3 == COMMON_DOWNLOAD_DO) {
      iVar18 = (ses->kbdprefix).repeat_count;
      if (iVar18 == 0) {
        if (pdVar11 == (download *)0x0) goto LAB_08080a99;
        pdVar13 = current_frame(ses);
        if ((pdVar13 != (document_view *)0x0) && (pdVar13->vs != (view_state *)0x0)) {
          iVar18 = pdVar13->vs->current_link;
          if (((pdVar11->state).basic == S_INTERRUPTED) &&
             (iVar18 != display_status_bar::lexical_block_0::lexical_block_0_0::last_current_link))
          {
            if (assert_failed == 0) {
              cVar22 = S_OK;
            }
            else {
              cVar22 = S_INTERNAL;
            }
            assert_failed = 0;
            (pdVar11->state).basic = cVar22;
            (pdVar11->state).syserr = 0;
          }
          display_status_bar::lexical_block_0::lexical_block_0_0::last_current_link = iVar18;
          if ((pdVar11->state).basic == S_OK) {
            iVar18 = pdVar13->vs->current_link;
            if (((iVar18 < 0) || (pdVar13->document->nlinks <= iVar18)) ||
               (pdVar13->document->links + iVar18 == (link *)0x0)) {
              if (ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) goto LAB_08080fe6;
              puVar23 = msg_text(term_00,(uchar *)"Cursor position: %dx%d",ses->tab->x + 1,
                                 ses->tab->y + 1);
            }
            else {
              puVar23 = get_current_link_info(ses,pdVar13);
              if ((puVar23 != (uchar *)0x0) &&
                 (puVar24 = get_current_link_title(pdVar13), puVar24 != (uchar *)0x0)) {
                if ((assert_failed == 0) &&
                   (assert_failed = (int)(*puVar24 == '\0'), assert_failed != 0)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/status.c";
                  errline = 0x99;
                  elinks_internal((uchar *)"assertion *link_title failed!");
                }
                puVar15 = straconcat(puVar23,&DAT_081327ae,puVar24,0);
                mem_free(puVar23);
                mem_free(puVar24);
                if (puVar15 != (uchar *)0x0) goto LAB_08080a9b;
              }
            }
            puVar15 = puVar23;
            if (puVar15 != (uchar *)0x0) goto LAB_08080a9b;
          }
        }
LAB_08080fe6:
        puVar15 = get_download_msg(pdVar11,term_00,(uint)(0x50 < term_00->width),
                                   (uint)(0x82 < term_00->width),", ");
      }
      else {
        puVar15 = msg_text(term_00,(uchar *)"Keyboard prefix: %d",iVar18);
      }
    }
    else if (aVar3 == CONTINUE_DOWNLOAD_DO) {
      puVar15 = msg_text(term_00,(uchar *)"Enter a mark to set");
    }
    else if (aVar3 == COMMON_DOWNLOAD_DO) {
      if (assert_failed == 0) {
        assert_failed = 1;
        puVar15 = (uchar *)0x0;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/status.c";
        errline = 0xb5;
        elinks_internal((uchar *)"assertion 0 failed!");
      }
      else {
LAB_08080a99:
        puVar15 = (uchar *)0x0;
      }
    }
    else {
      if (aVar3 != DOM_SCAN_END) goto LAB_08080a99;
      puVar15 = msg_text(term_00,(uchar *)"Enter a mark to which to jump");
    }
LAB_08080a9b:
    box.width = term_00->width;
    box.x = 0;
    box.height = 1;
    box.y = term_00->height + -1;
    if (box.y < 0) {
      box.y = 0;
    }
    if (box.width < 0) {
      box.width = 0;
    }
    pcVar7 = get_bfu_color(term_00,(uchar *)"status.status-bar");
    draw_box(term_00,&box,' ',0,pcVar7);
    if ((iVar5 < 2) || ((*(byte *)&ses->status & 1) != 0)) {
      pcVar7 = (color_pair *)0x0;
    }
    else {
      tab_info[local_4c] = '[';
      local_4c = local_4c + 1;
      elinks_ulongcat(tab_info,&local_4c,term_00->current_tab + 1,4,'\0',10,0);
      tab_info[local_4c] = ']';
      tab_info[local_4c + 1] = ' ';
      tab_info[local_4c + 2] = '\0';
      local_4c = local_4c + 2;
      pcVar7 = get_bfu_color(term_00,(uchar *)"status.status-text");
      draw_text(term_00,0,term_00->height + -1,tab_info,local_4c,0,pcVar7);
    }
    if (puVar15 == (uchar *)0x0) goto LAB_08080968;
    if (pcVar7 == (color_pair *)0x0) {
      pcVar7 = get_bfu_color(term_00,(uchar *)"status.status-text");
    }
    sVar17 = strlen((char *)puVar15);
    draw_text(term_00,local_4c,term_00->height + -1,puVar15,sVar17,0,pcVar7);
    mem_free(puVar15);
    iVar18 = download_is_progressing(pdVar11);
    if (iVar18 == 0) {
LAB_08080c00:
      bVar28 = (ses->status).field_0x8;
    }
    else {
      progress = pdVar11->progress;
      iVar18 = *(int *)((int)&progress->size + 4);
      if (iVar18 < 0) {
        bVar28 = (ses->status).field_0x8;
      }
      else if ((iVar18 < 1) && (*(int *)&progress->size == 0)) {
        bVar28 = (ses->status).field_0x8;
      }
      else {
        bVar28 = (ses->status).field_0x8;
        iVar18 = term_00->width + -1;
        if ((bVar28 & 1) != 0) {
          iVar18 = iVar18 - term_00->leds_length;
        }
        iVar25 = (-1 - local_4c) + (iVar18 - sVar17);
        if ((-1 < iVar25) && (5 < iVar25)) {
          iVar26 = 0x14;
          if (iVar25 < 0x15) {
            iVar26 = iVar25;
          }
          draw_progress_bar(progress,term_00,iVar18 - iVar26,term_00->height + -1,iVar26,
                            (uchar *)0x0,(color_pair *)0x0);
          goto LAB_08080c00;
        }
      }
    }
  }
  if ((bVar28 & 1) != 0) {
    if ((ses->doc_view != (document_view *)0x0) &&
       (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) {
      pcVar2 = pdVar1->cached;
      if (pcVar2 == (cache_entry *)0x0) {
        set_led_value((ses->status).ssl_led,'?');
      }
      else if (pcVar2->ssl_info == (uchar *)0x0) {
        unset_led_value((ses->status).ssl_led);
      }
      else {
        set_led_value((ses->status).ssl_led,'S');
      }
    }
    if (ses->insert_mode == INSERT_MODE_LESS) {
      set_led_value((ses->status).insert_mode_led,'i');
    }
    else if (ses->insert_mode == INSERT_MODE_ON) {
      set_led_value((ses->status).insert_mode_led,'I');
    }
    else {
      unset_led_value((ses->status).insert_mode_led);
    }
    draw_leds(ses);
  }
  bVar28 = (ses->status).field_0x34;
  if ((bVar28 & 1) == 0) {
    (ses->status).field_0x34 = bVar28 | 1;
  }
LAB_08080388:
  if ((*(byte *)&ses->status & 1) != 0) {
    pcVar7 = get_bfu_color(term_00,"tabs.normal");
    pcVar8 = get_bfu_color(term_00,"tabs.selected");
    pcVar9 = get_bfu_color(term_00,"tabs.loading");
    pcVar10 = get_bfu_color(term_00,"tabs.unvisited");
    color = get_bfu_color(term_00,"tabs.separator");
    box.width = term_00->width;
    iVar18 = 1;
    if (0 < box.width / iVar5) {
      iVar18 = box.width / iVar5;
    }
    local_80 = box.width - iVar5 * iVar18;
    if (local_80 < 0) {
      local_80 = 0;
    }
    iVar25 = 1;
    if (0 < local_80 / iVar5) {
      iVar25 = local_80 / iVar5;
    }
    if (((ses->status).field_0x34 & 4) == 0) {
      box.width = 0;
      iVar26 = term_00->height - (2 - (uint)((*(byte *)&ses->status & 2) == 0));
      box.y = 0;
      if (-1 < iVar26) {
        box.y = iVar26;
      }
    }
    else {
      box.y = *(byte *)&ses->status >> 2 & 1;
      if (box.width < 0) {
        box.width = 0;
      }
    }
    box.height = 1;
    box.x = 0;
    if (0 < iVar5) {
      iVar26 = 0;
      do {
        pwVar12 = get_tab_by_number(term_00,iVar26);
        ses_00 = (session *)pwVar12->data;
        sVar17 = iVar18 - 1U;
        if (local_80 != 0) {
          local_80 = local_80 - iVar25;
          sVar17 = iVar25 + (iVar18 - 1U);
        }
        if ((ses_00 == (session *)0x0) ||
           (pdVar13 = current_frame(ses_00), pdVar13 == (document_view *)0x0)) {
          iVar14 = get_terminal_codepage(term_00);
          if (iVar14 != current_charset) {
            puVar15 = get_cp_mime_name(iVar14);
            bind_textdomain_codeset("elinks",puVar15);
            current_charset = iVar14;
          }
          local_74 = gettext((uchar *)"No document");
        }
        else {
          local_74 = pdVar13->document->title;
          if ((local_74 == (uchar *)0x0) || (*local_74 == '\0')) {
            iVar14 = get_terminal_codepage(term_00);
            if (iVar14 != current_charset) {
              puVar15 = get_cp_mime_name(iVar14);
              bind_textdomain_codeset("elinks",puVar15);
              current_charset = iVar14;
            }
            local_74 = gettext((uchar *)"Untitled");
          }
        }
        if (iVar26 != 0) {
          draw_char(term_00,box.x,box.y,0xb3,SCREEN_ATTR_FRAME,color);
          box.x = box.x + 1;
        }
        local_7c = pcVar8;
        if (iVar26 == term_00->current_tab) {
LAB_080806de:
          box.width = sVar17 + 1;
          draw_box(term_00,&box,' ',0,local_7c);
          if ((term_00->field_0x38 & 2) == 0) {
            sVar16 = strlen((char *)local_74);
            if ((int)sVar17 <= (int)sVar16) {
              sVar16 = sVar17;
            }
          }
          else {
            puVar15 = utf8_step_forward(local_74,(uchar *)0x0,sVar17,UTF8_STEP_CELLS_FEWER,
                                        (int *)0x0);
            sVar16 = (int)puVar15 - (int)local_74;
          }
          draw_text(term_00,box.x,box.y,local_74,sVar16,0,local_7c);
        }
        else {
          pdVar11 = get_current_download(ses_00);
          if (((pdVar11 == (download *)0x0) || (local_7c = pcVar9, (pdVar11->state).basic == S_OK))
             && ((ses_00 == (session *)0x0 ||
                 (local_7c = pcVar7, ((ses_00->status).field_0x34 & 1) == 0)))) {
            local_7c = pcVar10;
          }
          iVar14 = download_is_progressing(pdVar11);
          if (iVar14 == 0) goto LAB_080806de;
          iVar14 = *(int *)((int)&pdVar11->progress->size + 4);
          if ((iVar14 < 0) || ((iVar14 < 1 && (*(int *)&pdVar11->progress->size == 0))))
          goto LAB_080806de;
          box.width = sVar17 + 1;
          draw_box(term_00,&box,' ',0,local_7c);
          draw_progress_bar(pdVar11->progress,term_00,box.x,box.y,sVar17,local_74,(color_pair *)0x0)
          ;
        }
        local_70 = sVar17 + 1;
        pwVar12->xpos = box.x;
        if (iVar26 != iVar5 + -1) {
          local_70 = sVar17;
        }
        iVar26 = iVar26 + 1;
        pwVar12->width = local_70;
        box.x = box.x + sVar17;
      } while (iVar26 < iVar5);
    }
  }
  redraw_from_window(ses->tab);
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

line * realloc_lines(document *document,int y)

{
  line *plVar1;
  size_t newsize;
  uint uVar2;
  size_t size;
  size_t oldsize;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (line *)0x0;
  }
  assert_failed = (int)(document == (document *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/docdata.c";
    errline = 0x14;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (line *)0x0;
    }
  }
  if (y < document->height) {
LAB_080813da:
    plVar1 = document->data + y;
  }
  else {
    uVar3 = document->height + 0x7fU & 0xffffff80;
    uVar2 = y + 0x80U & 0xffffff80;
    if (uVar3 < uVar2) {
      size = uVar2 * 8;
      plVar1 = (line *)mem_realloc(document->data,size);
      if (plVar1 != (line *)0x0) {
        document->data = plVar1;
        memset(plVar1 + uVar3,0,size + uVar3 * -8);
        goto LAB_08081436;
      }
    }
    else {
LAB_08081436:
      if (document->data != (line *)0x0) {
        document->height = y + 1;
        goto LAB_080813da;
      }
    }
    plVar1 = (line *)0x0;
  }
  return plVar1;
}



// WARNING: Unknown calling convention

int get_format_cache_size(void)

{
  void **ppvVar1;
  int iVar2;
  int size;
  list_head_elinks *item;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &format_cache);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_format_cache_used_count(void)

{
  void **ppvVar1;
  int iVar2;
  int i;
  document *document;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + (uint)(plVar3[1].next != (void *)0x0);
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &format_cache);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_format_cache_refresh_count(void)

{
  void **ppvVar1;
  int iVar2;
  int i;
  document *document;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      if ((int *)plVar3[0x19].prev != (int *)0x0) {
                    // WARNING: Load size is inaccurate
        iVar2 = (iVar2 + 1) - (uint)(*plVar3[0x19].prev == 0);
      }
      ppvVar1 = &plVar3->next;
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &format_cache);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void done_documents(module *module)

{
  free_tags_lookup();
  free_table_cache();
  return;
}



// WARNING: Unknown calling convention

void init_documents(module *module)

{
  init_tags_lookup();
  return;
}



// WARNING: Unknown calling convention

ulong get_document_css_magic(document *document)

{
  uri *uri_00;
  uri *uri;
  cache_entry *pcVar1;
  int iVar2;
  int index;
  ulong uVar3;
  ulong css_magic;
  
  uVar3 = 0;
  iVar2 = 0;
  if (0 < (document->css_imports).size) {
    uVar3 = 0;
    do {
      uri_00 = (document->css_imports).uris[iVar2];
      if (uri_00 != (uri *)0x0) {
        pcVar1 = find_in_cache(uri_00);
        if (pcVar1 != (cache_entry *)0x0) {
          uVar3 = uVar3 + *(int *)&pcVar1->data_size + pcVar1->cache_id;
        }
      }
      iVar2 = iVar2 + 1;
    } while ((document->css_imports).size != iVar2 && iVar2 <= (document->css_imports).size);
  }
  return uVar3;
}



// WARNING: Unknown calling convention

int find_tag(document *document,uchar *name,int namelen)

{
  undefined4 *puVar1;
  int iVar2;
  tag *tag;
  
  puVar1 = (undefined4 *)(document->tags).next;
  while( true ) {
    if ((list_head_elinks *)puVar1 == &document->tags) {
      return -1;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0xbe;
    iVar2 = elinks_strlcasecmp((uchar *)(puVar1 + 4),0xffffffff,name,namelen,1);
    if (iVar2 == 0) break;
    puVar1 = (undefined4 *)*puVar1;
  }
  return puVar1[3];
}



// WARNING: Unknown calling convention

void release_document(document *document)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(document == (document *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0xad;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (document->refresh != (document_refresh *)0x0) {
    kill_document_refresh(document->refresh);
  }
  (document->object).refcount = (document->object).refcount + -1;
  if ((document *)format_cache.next != document) {
    document->next->prev = document->prev;
    document->prev->next = document->next;
    document->prev = (document *)&format_cache;
    document->next = (document *)format_cache.next;
    format_cache.next = document;
    document->next->prev = document;
  }
  return;
}



// WARNING: Unknown calling convention

void free_frameset_desc(frameset_desc *frameset_desc)

{
  frameset_desc *frameset_desc_00;
  uchar *p_00;
  uri *uri;
  void *p;
  frameset_desc *pfVar1;
  int i;
  
  if (0 < frameset_desc->n) {
    i = 0;
    pfVar1 = frameset_desc;
    do {
      frameset_desc_00 = pfVar1->frame_desc[0].subframe;
      if (frameset_desc_00 != (frameset_desc *)0x0) {
        free_frameset_desc(frameset_desc_00);
      }
      p_00 = pfVar1->frame_desc[0].name;
      if (p_00 != (uchar *)0x0) {
        mem_free(p_00);
      }
      uri = pfVar1->frame_desc[0].uri;
      if (uri != (uri *)0x0) {
        done_uri(uri);
      }
      i = i + 1;
      pfVar1 = (frameset_desc *)pfVar1->frame_desc;
    } while (frameset_desc->n != i && i <= frameset_desc->n);
  }
  mem_free(frameset_desc);
  return;
}



// WARNING: Unknown calling convention

void done_link_members(link *link)

{
  void *p;
  list_head_elinks *p_00;
  void *p_1;
  void *p_2;
  void *p_3;
  void *p_4;
  void *p_5;
  void *p_6;
  script_event_hook *evhook;
  list_head_elinks *p_01;
  script_event_hook *safety;
  list_head_elinks *plVar1;
  bool bVar2;
  
  p_00 = link->event_hooks;
  if (p_00 != (list_head_elinks *)0x0) {
    p_01 = (list_head_elinks *)p_00->next;
    plVar1 = (list_head_elinks *)p_01->next;
    if (p_01 != p_00) {
      do {
        if (p_01[1].prev != (void *)0x0) {
          mem_free(p_01[1].prev);
        }
        mem_free(p_01);
        p_00 = link->event_hooks;
        bVar2 = p_00 != plVar1;
        p_01 = plVar1;
        plVar1 = (list_head_elinks *)plVar1->next;
      } while (bVar2);
    }
    mem_free(p_00);
  }
  if ((link->type < LINK_BUTTON) && ((link->data).name != (uchar *)0x0)) {
    mem_free((link->data).name);
  }
  if (link->where != (uchar *)0x0) {
    mem_free(link->where);
  }
  if (link->target != (uchar *)0x0) {
    mem_free(link->target);
  }
  if (link->title != (uchar *)0x0) {
    mem_free(link->title);
  }
  if (link->where_img != (uchar *)0x0) {
    mem_free(link->where_img);
  }
  if (link->points == (point *)0x0) {
    return;
  }
  mem_free(link->points);
  return;
}



// WARNING: Unknown calling convention

void done_document(document *document)

{
  object *poVar1;
  list_head_elinks *plVar2;
  form *form;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  undefined *puVar6;
  void *p;
  link *plVar7;
  void *p_1;
  void *p_2;
  void *p_3;
  xlist_head *head;
  xlist_head *head_1;
  void *p_4;
  void *p_5;
  void *p_6;
  line *p_00;
  int iVar8;
  int pos;
  int pos_1;
  xlist_head *next_1;
  int iVar9;
  xlist_head *next;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(document == (document *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x6e;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = (int)((document->object).refcount != 0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x71;
    elinks_internal((uchar *)
                    "assertion !is_object_used(document) failed: Attempt to free locked formatted data."
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = (int)(document->cached == (cache_entry *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x74;
    elinks_internal((uchar *)"assertion document->cached failed!");
  }
  poVar1 = &document->cached->object;
  poVar1->refcount = poVar1->refcount + -1;
  if (document->uri != (uri *)0x0) {
    done_uri(document->uri);
  }
  if (document->title != (uchar *)0x0) {
    mem_free(document->title);
  }
  if (document->frame_desc != (frameset_desc *)0x0) {
    free_frameset_desc(document->frame_desc);
  }
  if (document->refresh != (document_refresh *)0x0) {
    done_document_refresh(document->refresh);
  }
  plVar7 = document->links;
  if (plVar7 != (link *)0x0) {
    if (0 < document->nlinks) {
      iVar9 = 0;
      iVar8 = 0;
      while( true ) {
        plVar7 = (link *)((int)&plVar7->accesskey + iVar9);
        iVar8 = iVar8 + 1;
        iVar9 = iVar9 + 0x34;
        done_link_members(plVar7);
        if (document->nlinks == iVar8 || document->nlinks < iVar8) break;
        plVar7 = document->links;
      }
      plVar7 = document->links;
    }
    mem_free(plVar7);
  }
  p_00 = document->data;
  if (p_00 != (line *)0x0) {
    if (0 < document->height) {
      pos_1 = 0;
      do {
        if (p_00[pos_1].chars != (screen_char *)0x0) {
          mem_free(p_00[pos_1].chars);
          p_00 = document->data;
        }
        pos_1 = pos_1 + 1;
      } while (document->height != pos_1 && pos_1 <= document->height);
    }
    mem_free(p_00);
  }
  if (document->lines1 != (link **)0x0) {
    mem_free(document->lines1);
  }
  if (document->lines2 != (link **)0x0) {
    mem_free(document->lines2);
  }
  done_document_options(&document->options);
  form = (form *)(document->forms).next;
  while (form != (form *)&document->forms) {
    done_form(form);
    form = (form *)(document->forms).next;
  }
  free_uri_list(&document->css_imports);
  puVar3 = (undefined4 *)(document->tags).next;
  for (puVar4 = puVar3; (list_head_elinks *)puVar4 != &document->tags;
      puVar4 = (undefined4 *)*puVar4) {
  }
  for (puVar5 = (undefined4 *)(document->tags).prev; puVar5 != puVar4;
      puVar5 = (undefined4 *)puVar5[1]) {
  }
  puVar5 = (undefined4 *)*puVar3;
  while (puVar3 != puVar4) {
    puVar5[1] = puVar3[1];
    *(undefined4 *)puVar3[1] = *puVar3;
    mem_free(puVar3);
    puVar3 = puVar5;
    puVar5 = (undefined4 *)*puVar5;
  }
  plVar2 = &document->nodes;
  puVar3 = (undefined4 *)(document->nodes).next;
  for (puVar4 = puVar3; plVar2 != (list_head_elinks *)puVar4; puVar4 = (undefined4 *)*puVar4) {
  }
  for (puVar6 = (undefined *)(document->nodes).prev; (list_head_elinks *)puVar6 != plVar2;
      puVar6 = *(undefined **)(puVar6 + 4)) {
  }
  puVar4 = (undefined4 *)*puVar3;
  while (puVar5 = puVar4, (list_head_elinks *)puVar3 != plVar2) {
    puVar5[1] = puVar3[1];
    *(undefined4 *)puVar3[1] = *puVar3;
    mem_free(puVar3);
    puVar4 = (undefined4 *)*puVar5;
    puVar3 = puVar5;
  }
  if (document->search != (search *)0x0) {
    mem_free(document->search);
  }
  if (document->slines1 != (search **)0x0) {
    mem_free(document->slines1);
  }
  if (document->slines2 != (search **)0x0) {
    mem_free(document->slines2);
  }
  document->next->prev = document->prev;
  document->prev->next = document->next;
  mem_free(document);
  return;
}



// WARNING: Unknown calling convention

void shrink_format_cache(int whole)

{
  int iVar1;
  document *pdVar2;
  option_value *poVar3;
  document *document;
  document *pdVar4;
  document *next;
  document *pdVar5;
  int iVar6;
  int format_cache_entries;
  int format_cache_size;
  bool bVar7;
  char *pcVar8;
  
  iVar6 = 0;
  pcVar8 = "document.cache.format.size";
  poVar3 = get_opt_();
  iVar1 = poVar3->number;
                    // WARNING: Load size is inaccurate
  pdVar4 = (document *)format_cache.next;
  pdVar5 = *format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      if ((pdVar4->object).refcount == 0) {
        if (pdVar4->cached->cache_id == pdVar4->cache_id) {
          iVar6 = iVar6 + 1;
          goto LAB_08081bcb;
        }
        done_document(pdVar4);
        pdVar2 = pdVar5->next;
      }
      else {
LAB_08081bcb:
        pdVar2 = pdVar5->next;
      }
      bVar7 = pdVar5 != (document *)&format_cache;
      pdVar4 = pdVar5;
      pdVar5 = pdVar2;
    } while (bVar7);
  }
  if (assert_failed == 0) {
    assert_failed = -(iVar6 >> 0x1f);
    if (assert_failed == 0) goto LAB_08081c1d;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x126;
    elinks_internal((uchar *)
                    "assertion format_cache_entries >= 0 failed: format_cache_entries underflow on entry"
                    ,pcVar8);
    if (assert_failed == 0) goto LAB_08081c1d;
  }
  assert_failed = 0;
  iVar6 = 0;
LAB_08081c1d:
  pdVar4 = (document *)format_cache.prev;
  pdVar5 = *(document **)((int)format_cache.prev + 4);
  if ((list_head_elinks *)format_cache.prev != &format_cache) {
    do {
      if ((pdVar4->object).refcount == 0) {
        if ((iVar6 <= iVar1) && (whole == 0)) break;
        iVar6 = iVar6 + -1;
        done_document(pdVar4);
      }
      bVar7 = pdVar5 != (document *)&format_cache;
      pdVar4 = pdVar5;
      pdVar5 = pdVar5->prev;
    } while (bVar7);
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -(iVar6 >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 0x135;
    elinks_internal((uchar *)
                    "assertion format_cache_entries >= 0 failed: format_cache_entries underflow",
                    pcVar8);
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

document * get_cached_document(cache_entry *cached,document_options *options)

{
  ulong uVar1;
  int iVar2;
  ulong uVar3;
  document *document;
  document *document_00;
  document *next;
  document *pdVar4;
  bool bVar5;
  
                    // WARNING: Load size is inaccurate
  document_00 = (document *)format_cache.next;
  pdVar4 = *format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      iVar2 = compare_uri(document_00->uri,cached->uri,0);
      if ((iVar2 != 0) && (iVar2 = compare_opt(&document_00->options,options), iVar2 == 0)) {
        if (((options->field_0x5c & 4) == 0) &&
           ((cached->cache_id == document_00->cache_id &&
            (uVar1 = document_00->css_magic, uVar3 = get_document_css_magic(document_00),
            uVar1 == uVar3)))) {
          if ((document *)format_cache.next != document_00) {
            document_00->next->prev = document_00->prev;
            document_00->prev->next = document_00->next;
            document_00->prev = (document *)&format_cache;
            document_00->next = (document *)format_cache.next;
            format_cache.next = document_00;
            document_00->next->prev = document_00;
          }
          (document_00->object).refcount = (document_00->object).refcount + 1;
          return document_00;
        }
        if ((document_00->object).refcount == 0) {
          done_document(document_00);
        }
      }
      bVar5 = pdVar4 != (document *)&format_cache;
      document_00 = pdVar4;
      pdVar4 = pdVar4->next;
    } while (bVar5);
  }
  return (document *)0x0;
}



// WARNING: Unknown calling convention

document * init_document(cache_entry *cached,document_options *options)

{
  object *poVar1;
  uri *puVar2;
  uint uVar3;
  document *pdVar4;
  document *document;
  
  pdVar4 = (document *)mem_calloc(1,0x118);
  if (pdVar4 != (document *)0x0) {
    puVar2 = cached->uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    pdVar4->uri = puVar2;
    uVar3 = cached->cache_id;
    (cached->object).refcount = (cached->object).refcount + 1;
    (pdVar4->object).refcount = (pdVar4->object).refcount + 1;
    pdVar4->cache_id = uVar3;
    (pdVar4->forms).prev = &pdVar4->forms;
    (pdVar4->forms).next = &pdVar4->forms;
    (pdVar4->tags).prev = &pdVar4->tags;
    (pdVar4->tags).next = &pdVar4->tags;
    pdVar4->cached = cached;
    (pdVar4->nodes).prev = &pdVar4->nodes;
    (pdVar4->nodes).next = &pdVar4->nodes;
    copy_opt(&pdVar4->options,options);
    pdVar4->prev = (document *)&format_cache;
    pdVar4->next = (document *)format_cache.next;
    format_cache.next = pdVar4;
    pdVar4->next->prev = pdVar4;
  }
  return pdVar4;
}



// WARNING: Unknown calling convention

void update_cached_document_options(void)

{
  option_value oVar1;
  option_value oVar2;
  color_T cVar3;
  uint uVar4;
  color_T cVar5;
  void **ppvVar6;
  document *document;
  option_value *poVar7;
  list_head_elinks *plVar8;
  active_link_options active_link;
  
  poVar7 = get_opt_();
  oVar1 = *poVar7;
  poVar7 = get_opt_();
  oVar2 = *poVar7;
  poVar7 = get_opt_();
  cVar3 = poVar7->color;
  poVar7 = get_opt_();
  uVar4 = poVar7->color;
  poVar7 = get_opt_();
  cVar5 = poVar7->color;
  poVar7 = get_opt_();
  active_link._1_3_ = 0;
  active_link._0_1_ =
       (byte)cVar3 & 1 | (byte)((uVar4 & 1) << 3) | ((byte)cVar5 & 1) * '\x02' & 0xfb |
       (byte)((poVar7->color & 1) << 2);
  plVar8 = (list_head_elinks *)format_cache.next;
  if ((list_head_elinks *)format_cache.next != &format_cache) {
    do {
      plVar8[0xd].prev = (void *)active_link._0_4_;
      plVar8[0xe].next = (void *)oVar1;
      plVar8[0xe].prev = (void *)oVar2;
      ppvVar6 = &plVar8->next;
      plVar8 = (list_head_elinks *)*ppvVar6;
    } while ((list_head_elinks *)*ppvVar6 != &format_cache);
  }
  return;
}



// WARNING: Unknown calling convention

void get_screen_char_template(screen_char *template,document_options *options,text_style style)

{
  color_pair colors;
  
  template->attr = '\0';
  template->data = 0x20;
  if (style.attr != 0) {
    if (((undefined  [12])style & (undefined  [12])0x4) != (undefined  [12])0x0) {
      template->attr = ' ';
    }
    if (((undefined  [12])style & (undefined  [12])0x1) != (undefined  [12])0x0) {
      template->attr = template->attr | 8;
    }
    if (((undefined  [12])style & (undefined  [12])0x2) != (undefined  [12])0x0) {
      template->attr = template->attr | 0x10;
    }
    if (((undefined  [12])style & (undefined  [12])0x10) != (undefined  [12])0x0) {
      template->attr = template->attr | 0x80;
    }
  }
  colors.background = style.bg;
  colors.foreground = style.fg;
  set_term_color(template,&colors,options->color_flags,options->color_mode);
  return;
}



// WARNING: Unknown calling convention

uchar * form_type2str(form_type num)

{
  int iVar1;
  int n;
  
  iVar1 = 1;
  if (num == FC_TEXT) {
    iVar1 = 0;
  }
  else {
    while (form_type2name[iVar1].num != num) {
      iVar1 = iVar1 + 1;
      if (iVar1 == 10) {
        return (uchar *)0x0;
      }
    }
  }
  return form_type2name[iVar1].name;
}



// WARNING: Unknown calling convention

int has_form_submit(form *form)

{
  undefined4 *puVar1;
  form_control *fc;
  int iVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(form == (form *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x70;
      elinks_internal((uchar *)"assertion form failed!");
      if (assert_failed != 0) goto LAB_08082150;
    }
    assert_failed = (int)((list_head_elinks *)(form->items).next == &form->items);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x73;
      elinks_internal((uchar *)"assertion !list_empty(form->items) failed: form has no items");
    }
    puVar1 = (undefined4 *)(form->items).next;
    while( true ) {
      if (&form->items == (list_head_elinks *)puVar1) {
        return 0;
      }
      if (puVar1[5] - 7 < 2) break;
      puVar1 = (undefined4 *)*puVar1;
    }
    iVar2 = 1;
  }
  else {
LAB_08082150:
    assert_failed = 0;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void done_form_control(form_control *fc)

{
  void *p;
  void *p_1;
  void *p_2;
  void *p_3;
  void *p_5;
  void *p_4;
  void *p_6;
  void *p_7;
  int iVar1;
  int i;
  
  if (assert_failed == 0) {
    assert_failed = (int)(fc == (form_control *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x98;
      elinks_internal((uchar *)"assertion fc failed!");
      if (assert_failed != 0) goto LAB_080822b0;
    }
    if (fc->id != (uchar *)0x0) {
      mem_free(fc->id);
    }
    if (fc->name != (uchar *)0x0) {
      mem_free(fc->name);
    }
    if (fc->alt != (uchar *)0x0) {
      mem_free(fc->alt);
    }
    if (fc->default_value != (uchar *)0x0) {
      mem_free(fc->default_value);
    }
    if (0 < fc->nvalues) {
      iVar1 = 0;
      do {
        if (fc->values[iVar1] != (uchar *)0x0) {
          mem_free(fc->values[iVar1]);
        }
        if (fc->labels[iVar1] != (uchar *)0x0) {
          mem_free(fc->labels[iVar1]);
        }
        iVar1 = iVar1 + 1;
      } while (fc->nvalues != iVar1 && iVar1 <= fc->nvalues);
    }
    if (fc->values != (uchar **)0x0) {
      mem_free(fc->values);
    }
    if (fc->labels != (uchar **)0x0) {
      mem_free(fc->labels);
    }
    if (fc->menu != (menu_item *)0x0) {
      free_menu(fc->menu);
      return;
    }
  }
  else {
LAB_080822b0:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void done_form(form *form)

{
  undefined *puVar1;
  form_control *pfVar2;
  void *p;
  void *p_1;
  void *p_2;
  void *p_3;
  xlist_head *head;
  form_control *p_00;
  list_head_elinks *plVar3;
  form_control *fc;
  form_control *pfVar4;
  xlist_head *next;
  
  if (form->next != (form *)0x0) {
    form->next->prev = form->prev;
    form->prev->next = form->next;
  }
  if (form->action != (uchar *)0x0) {
    mem_free(form->action);
  }
  if (form->name != (uchar *)0x0) {
    mem_free(form->name);
  }
  if (form->onsubmit != (uchar *)0x0) {
    mem_free(form->onsubmit);
  }
  if (form->target != (uchar *)0x0) {
    mem_free(form->target);
  }
  pfVar4 = (form_control *)(form->items).next;
  plVar3 = &form->items;
  p_00 = pfVar4;
  if (pfVar4 != (form_control *)plVar3) {
    do {
      done_form_control(pfVar4);
      pfVar4 = pfVar4->next;
    } while (pfVar4 != (form_control *)plVar3);
    pfVar4 = (form_control *)(form->items).next;
    p_00 = pfVar4;
  }
  for (; pfVar4 != (form_control *)plVar3; pfVar4 = pfVar4->next) {
  }
  for (puVar1 = (undefined *)(form->items).prev; (list_head_elinks *)puVar1 != plVar3;
      puVar1 = *(undefined **)(puVar1 + 4)) {
  }
  pfVar4 = p_00->next;
  while (pfVar2 = pfVar4, p_00 != (form_control *)plVar3) {
    pfVar2->prev = p_00->prev;
    p_00->prev->next = p_00->next;
    mem_free(p_00);
    pfVar4 = pfVar2->next;
    p_00 = pfVar2;
  }
  mem_free(form);
  return;
}



// WARNING: Unknown calling convention

int get_form_control_link(document *document,form_control *fc)

{
  int iVar1;
  int link;
  form_control *pfVar2;
  link *plVar3;
  
  if (fc->type != FC_HIDDEN) {
    if ((document->field_0x114 & 1) == 0) {
      sort_links(document);
    }
    if (0 < document->nlinks) {
      plVar3 = document->links;
      iVar1 = 0;
      do {
        pfVar2 = (form_control *)0x0;
        if (LINK_MAP < plVar3->type) {
          pfVar2 = (form_control *)(plVar3->data).name;
        }
        if (pfVar2 == fc) {
          return iVar1;
        }
        iVar1 = iVar1 + 1;
        plVar3 = plVar3 + 1;
      } while (iVar1 < document->nlinks);
    }
    if (assert_failed == 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 0x8e;
      elinks_internal((uchar *)"assertion 0 failed: Form control has no link.");
      return -1;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

form * init_form(void)

{
  form *pfVar1;
  form *form;
  
  pfVar1 = (form *)mem_calloc(1,0x2c);
  if (pfVar1 != (form *)0x0) {
    pfVar1->form_end = 0x7fffffff;
    (pfVar1->items).prev = &pfVar1->items;
    (pfVar1->items).next = &pfVar1->items;
  }
  return pfVar1;
}



// WARNING: Unknown calling convention

int str2form_type(uchar *s)

{
  int iVar1;
  int iVar2;
  int n;
  
  iVar2 = 0;
  do {
    iVar1 = strcmp((char *)form_type2name[iVar2].name,(char *)s);
    if (iVar1 == 0) {
      return form_type2name[iVar2].num;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 10);
  return -1;
}



// WARNING: Unknown calling convention

void toggle_document_option(session *ses,uchar *option_name)

{
  option_elinks *option_elinks_00;
  option_elinks *option_elinks;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((ses == (session *)0x0) || (ses->doc_view == (document_view *)0x0)) ||
      (ses->tab == (window *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/options.c";
    errline = 0x81;
    elinks_internal((uchar *)"assertion ses && ses->doc_view && ses->tab && ses->tab->term failed!")
    ;
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if (ses->doc_view->vs != (view_state *)0x0) {
    option_elinks_00 = get_opt_rec(config_options,option_name);
    toggle_option(ses,option_elinks_00);
    draw_formatted(ses,1);
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)0x0);
  return;
}



// WARNING: Unknown calling convention

void done_document_options(document_options *options)

{
  void *p;
  
  if (options->framename != (uchar *)0x0) {
    mem_free(options->framename);
  }
  mem_free((options->image_link).prefix);
  mem_free((options->image_link).suffix);
  return;
}



// WARNING: Unknown calling convention

void copy_opt(document_options *o1,document_options *o2)

{
  uchar *puVar1;
  option_value *poVar2;
  int iVar3;
  document_options *pdVar4;
  document_options *pdVar5;
  
  pdVar4 = o2;
  pdVar5 = o1;
  for (iVar3 = 0x22; iVar3 != 0; iVar3 = iVar3 + -1) {
    pdVar5->color_mode = pdVar4->color_mode;
    pdVar4 = (document_options *)&pdVar4->cp;
    pdVar5 = (document_options *)&pdVar5->cp;
  }
  puVar1 = stracpy(o2->framename);
  o1->framename = puVar1;
  poVar2 = get_opt_();
  puVar1 = stracpy(poVar2->string);
  (o1->image_link).prefix = puVar1;
  poVar2 = get_opt_();
  puVar1 = stracpy(poVar2->string);
  (o1->image_link).suffix = puVar1;
  return;
}



// WARNING: Unknown calling convention

int compare_opt(document_options *o1,document_options *o2)

{
  uint uVar1;
  int iVar2;
  document_options *pdVar3;
  document_options *pdVar4;
  bool bVar5;
  
  iVar2 = 0x48;
  bVar5 = &stack0x00000000 == (undefined *)0x3c;
  pdVar3 = o1;
  pdVar4 = o2;
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar5 = *(char *)&pdVar3->color_mode == *(char *)&pdVar4->color_mode;
    pdVar3 = (document_options *)((int)&pdVar3->color_mode + 1);
    pdVar4 = (document_options *)((int)&pdVar4->color_mode + 1);
  } while (bVar5);
  if (((((bVar5) && (iVar2 = c_strcasecmp((char *)o1->framename,(char *)o2->framename), iVar2 == 0))
       && ((o1->box).x == (o2->box).x)) && ((o1->box).y == (o2->box).y)) &&
     ((((o1->field_0x5c & 1) == 0 && ((o2->field_0x5c & 1) == 0)) ||
      ((o1->box).height == (o2->box).height)))) {
    if (((o1->field_0x5c & 2) != 0) || (uVar1 = 0, (o2->field_0x5c & 2) != 0)) {
      uVar1 = (uint)((o1->box).width != (o2->box).width);
    }
  }
  else {
    uVar1 = 1;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void init_document_options(document_options *doo)

{
  byte bVar1;
  color_T cVar2;
  option_value *poVar3;
  int iVar4;
  document_options *pdVar5;
  
  pdVar5 = doo;
  for (iVar4 = 0x22; iVar4 != 0; iVar4 = iVar4 + -1) {
    pdVar5->color_mode = COLOR_MODE_MONO;
    pdVar5 = (document_options *)&pdVar5->cp;
  }
  poVar3 = get_opt_();
  doo->assume_cp = (int)*poVar3;
  poVar3 = get_opt_();
  doo->hard_assume = (int)*poVar3;
  poVar3 = get_opt_();
  doo->use_document_colors = (int)*poVar3;
  poVar3 = get_opt_();
  doo->margin = (int)*poVar3;
  poVar3 = get_opt_();
  doo->num_links_key = (int)*poVar3;
  poVar3 = get_opt_();
  doo->meta_link_display = (int)*poVar3;
  poVar3 = get_opt_();
  doo->default_form_input_size = (int)*poVar3;
  poVar3 = get_opt_();
  (doo->default_style).fg = (color_T)*poVar3;
  poVar3 = get_opt_();
  (doo->default_style).bg = (color_T)*poVar3;
  poVar3 = get_opt_();
  doo->default_link = (color_T)*poVar3;
  poVar3 = get_opt_();
  doo->default_vlink = (color_T)*poVar3;
  poVar3 = get_opt_();
  doo->default_bookmark_link = (color_T)*poVar3;
  poVar3 = get_opt_();
  doo->default_image_link = (color_T)*poVar3;
  poVar3 = get_opt_();
  (doo->active_link).fg = (color_T)*poVar3;
  poVar3 = get_opt_();
  (doo->active_link).bg = (color_T)*poVar3;
  poVar3 = get_opt_();
  if (poVar3->tree != (list_head_elinks *)0x0) {
    doo->color_flags = doo->color_flags | COLOR_INCREASE_CONTRAST;
  }
  poVar3 = get_opt_();
  if (poVar3->tree != (list_head_elinks *)0x0) {
    doo->color_flags = doo->color_flags | COLOR_ENSURE_CONTRAST;
  }
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xfe | (byte)poVar3->color & 1;
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xfd | ((byte)poVar3->color & 1) * '\x02';
  poVar3 = get_opt_();
  doo->field_0x45 = doo->field_0x45 & 0xfb | (byte)((poVar3->color & 1) << 2);
  poVar3 = get_opt_();
  doo->field_0x45 = doo->field_0x45 & 0xf7 | (byte)((poVar3->color & 1) << 3);
  poVar3 = get_opt_();
  doo->field_0x45 = doo->field_0x45 & 0xfe | (byte)poVar3->color & 1;
  poVar3 = get_opt_();
  doo->field_0x45 = doo->field_0x45 & 0xfd | ((byte)poVar3->color & 1) * '\x02';
  poVar3 = get_opt_();
  doo->field_0x45 = doo->field_0x45 & 0xdf | (byte)((poVar3->color & 1) << 5);
  poVar3 = get_opt_();
  doo->field_0x45 = doo->field_0x45 & 0xef | (byte)((poVar3->color & 1) << 4);
  poVar3 = get_opt_();
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xfe | (byte)poVar3->color & 1;
  poVar3 = get_opt_();
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xf7 | (byte)((poVar3->color & 1) << 3);
  poVar3 = get_opt_();
  *(byte *)&doo->active_link =
       *(byte *)&doo->active_link & 0xfd | ((byte)poVar3->color & 1) * '\x02';
  poVar3 = get_opt_();
  *(byte *)&doo->active_link = *(byte *)&doo->active_link & 0xfb | (byte)((poVar3->color & 1) << 2);
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xf7 | (byte)((poVar3->color & 1) << 3);
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xfb | (byte)((poVar3->color & 1) << 2);
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xef | (byte)((poVar3->color & 1) << 4);
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xdf | (byte)((poVar3->color & 1) << 5);
  poVar3 = get_opt_();
  doo->field_0x44 = doo->field_0x44 & 0xbf | (byte)((poVar3->color & 1) << 6);
  poVar3 = get_opt_();
  cVar2 = poVar3->color;
  bVar1 = doo->field_0x44;
  doo->framename = "";
  (doo->image_link).prefix = "";
  doo->field_0x44 = bVar1 & 0x7f | (byte)(cVar2 << 7);
  (doo->image_link).suffix = "";
  poVar3 = get_opt_();
  (doo->image_link).filename_maxlen = (int)*poVar3;
  poVar3 = get_opt_();
  (doo->image_link).label_maxlen = (int)*poVar3;
  poVar3 = get_opt_();
  (doo->image_link).display_style = (int)*poVar3;
  poVar3 = get_opt_();
  (doo->image_link).tagging = (int)*poVar3;
  poVar3 = get_opt_();
  (doo->image_link).field_0x18 = (doo->image_link).field_0x18 & 0xfe | (byte)poVar3->color & 1;
  return;
}



// WARNING: Unknown calling convention

void start_document_refreshes(session *ses)

{
  document *pdVar1;
  document_refresh *id;
  undefined4 *puVar2;
  option_value *poVar3;
  milliseconds_T mVar4;
  int iVar5;
  int delay;
  type_query *type_query;
  
  if ((assert_failed == 0) && (assert_failed = (int)(ses == (session *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/refresh.c";
    errline = 0x7f;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  if ((((ses->doc_view != (document_view *)0x0) &&
       (pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0)) &&
      (pdVar1->refresh != (document_refresh *)0x0)) &&
     (poVar3 = get_opt_(), poVar3->tree != (list_head_elinks *)0x0)) {
    id = ses->doc_view->document->refresh;
    poVar3 = get_opt_();
    delay = poVar3->number;
    mVar4 = sec_to_ms(id->seconds);
    if (((id->field_0xc & 1) != 0) && (id->timer == (timer_id_T)0x0)) {
      for (puVar2 = (undefined4 *)(ses->type_queries).next;
          (list_head_elinks *)puVar2 != &ses->type_queries; puVar2 = (undefined4 *)*puVar2) {
        iVar5 = compare_uri(id->uri,(uri *)puVar2[0x10],URI_BASE);
        if (iVar5 != 0) {
          return;
        }
      }
      if (delay <= mVar4) {
        delay = mVar4;
      }
      install_timer(&id->timer,delay,do_document_refresh,ses);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void do_document_refresh(void *data)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  type_query *type_query;
  document_refresh *refresh;
  
  puVar1 = *(undefined4 **)(*(int *)(*(int *)((int)data + 0x5c) + 0x14) + 0xcc);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(puVar1 == (undefined4 *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/refresh.c";
    errline = 0x49;
    elinks_internal((uchar *)"assertion refresh failed!");
  }
  *puVar1 = 0;
  for (puVar2 = *(undefined4 **)((int)data + 0xa0); puVar2 != (undefined4 *)((int)data + 0xa0);
      puVar2 = (undefined4 *)*puVar2) {
    iVar3 = compare_uri((uri *)puVar1[2],(uri *)puVar2[0x10],URI_BASE);
    if (iVar3 != 0) {
      return;
    }
  }
  iVar3 = compare_uri((uri *)puVar1[2],*(uri **)(*(int *)(*(int *)((int)data + 0x5c) + 0x14) + 0xb8)
                      ,0);
  if (iVar3 == 0) {
    goto_uri_frame((session *)data,(uri *)puVar1[2],(uchar *)0x0,CACHE_MODE_NORMAL);
    *(byte *)(puVar1 + 3) = *(byte *)(puVar1 + 3) & 0xfe;
    return;
  }
  reload((session *)data,CACHE_MODE_FORCE_RELOAD);
  return;
}



// WARNING: Unknown calling convention

void kill_document_refresh(document_refresh *refresh)

{
  kill_timer(&refresh->timer);
  return;
}



// WARNING: Unknown calling convention

void done_document_refresh(document_refresh *refresh)

{
  kill_timer(&refresh->timer);
  done_uri(refresh->uri);
  mem_free(refresh);
  return;
}



// WARNING: Unknown calling convention

document_refresh * init_document_refresh(uchar *url,ulong seconds)

{
  document_refresh *p;
  document_refresh *refresh;
  uri *puVar1;
  document_refresh *pdVar2;
  
  p = (document_refresh *)mem_alloc(0x10);
  pdVar2 = p;
  if (p != (document_refresh *)0x0) {
    puVar1 = get_uri(url,0);
    p->uri = puVar1;
    if (puVar1 == (uri *)0x0) {
      pdVar2 = (document_refresh *)0x0;
      mem_free(p);
    }
    else {
      p->field_0xc = p->field_0xc | 1;
      p->timer = (timer_id_T)0x0;
      p->seconds = seconds;
    }
  }
  return pdVar2;
}



// WARNING: Unknown calling convention

int comp_links(void *v1,void *v2)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(v2 == (void *)0x0 || v1 == (void *)0x0);
  if (v2 == (void *)0x0 || v1 == (void *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x204;
    elinks_internal((uchar *)"assertion l1 && l2 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return *(int *)((int)v1 + 0x20) - *(int *)((int)v2 + 0x20);
}



// WARNING: Unknown calling convention

conv_table *
get_convert_table(uchar *head,int to_cp,int default_cp,int *from_cp,cp_status *cp_status,
                 int ignore_server_cp)

{
  conv_table *pcVar1;
  int cp_index;
  uchar *puVar2;
  uchar *meta;
  uchar *puVar3;
  int iVar4;
  uchar *a;
  uchar *a_1;
  uchar *local_24;
  uchar *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (conv_table *)0x0;
  }
  local_20[0] = head;
  assert_failed = (int)(head == (uchar *)0x0);
  if (head == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x247;
    elinks_internal((uchar *)"assertion head failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (conv_table *)0x0;
    }
    assert_failed = 0;
  }
  if (ignore_server_cp != 0) {
    if (cp_status != (cp_status *)0x0) {
      *cp_status = CP_STATUS_IGNORED;
    }
    if (from_cp != (int *)0x0) {
      *from_cp = default_cp;
    }
    pcVar1 = get_translation_table(default_cp,to_cp);
    return pcVar1;
  }
  do {
    while( true ) {
      puVar2 = parse_header(local_20[0],(uchar *)"Content-Type",local_20);
      if (puVar2 == (uchar *)0x0) {
        puVar2 = parse_header(head,(uchar *)"Content-Charset",(uchar **)0x0);
        if (puVar2 != (uchar *)0x0) {
          iVar4 = get_cp_index(puVar2);
          mem_free(puVar2);
          if (iVar4 != -1) goto LAB_080831ad;
        }
        puVar2 = parse_header(head,"Charset",(uchar **)0x0);
        if (puVar2 != (uchar *)0x0) {
          iVar4 = get_cp_index(puVar2);
          mem_free(puVar2);
          if (iVar4 != -1) goto LAB_080831ad;
        }
        if (cp_status != (cp_status *)0x0) {
          *cp_status = CP_STATUS_ASSUMED;
        }
        goto LAB_080831bd;
      }
      while (puVar3 = parse_header(local_20[0],(uchar *)"Content-Type",local_20),
            puVar3 != (uchar *)0x0) {
        mem_free(puVar2);
        puVar2 = puVar3;
      }
      parse_header_param(puVar2,"charset",&local_24);
      if (local_24 != (uchar *)0x0) break;
      mem_free(puVar2);
    }
    iVar4 = get_cp_index(local_24);
    mem_free(local_24);
    mem_free(puVar2);
  } while (iVar4 == -1);
LAB_080831ad:
  default_cp = iVar4;
  if (cp_status != (cp_status *)0x0) {
    *cp_status = CP_STATUS_SERVER;
  }
LAB_080831bd:
  if (from_cp != (int *)0x0) {
    *from_cp = default_cp;
  }
  pcVar1 = get_translation_table(default_cp,to_cp);
  return pcVar1;
}



// WARNING: Unknown calling convention

void sort_links(document *document)

{
  size_t count;
  link **pplVar1;
  void *p;
  void *p_1;
  int q;
  int iVar2;
  link *link;
  link *link_00;
  int p_2;
  int iVar3;
  int iVar4;
  uint local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(document == (document *)0x0);
  if (assert_failed == 0) {
    iVar3 = document->nlinks;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x20e;
    elinks_internal((uchar *)"assertion document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    iVar3 = document->nlinks;
  }
  assert_failed = 0;
  if ((iVar3 != 0) && ((document->field_0x114 & 1) == 0)) {
    assert_failed = (int)(document->links == (link *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
      errline = 0x213;
      elinks_internal((uchar *)"assertion document->links failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    qsort(document->links,document->nlinks,0x34,comp_links);
    count = document->height;
    if (count != 0) {
      if (document->lines1 != (link **)0x0) {
        mem_free(document->lines1);
        count = document->height;
      }
      pplVar1 = (link **)mem_calloc(count,4);
      document->lines1 = pplVar1;
      if (document->lines2 != (link **)0x0) {
        mem_free(document->lines2);
        pplVar1 = document->lines1;
      }
      if (pplVar1 != (link **)0x0) {
        pplVar1 = (link **)mem_calloc(document->height,4);
        document->lines2 = pplVar1;
        if (pplVar1 == (link **)0x0) {
          mem_free(document->lines1);
          return;
        }
        local_20 = 0;
        if (0 < document->nlinks) {
          do {
            link_00 = document->links + local_20;
            if (link_00->npoints == 0) {
              done_link_members(link_00);
              memmove(link_00,link_00 + 1,(~local_20 + document->nlinks) * 0x34);
              iVar3 = document->nlinks + -1;
              document->nlinks = iVar3;
              local_20 = local_20 - 1;
            }
            else {
              iVar3 = link_00->points->y;
              iVar4 = link_00->points[link_00->npoints + -1].y;
              iVar2 = iVar4;
              if (iVar4 < iVar3) {
                iVar2 = iVar3;
                iVar3 = iVar4;
              }
              iVar4 = iVar3 * 4;
              do {
                while (assert_failed == 0) {
                  assert_failed = (int)(document->height == iVar3 || document->height < iVar3);
                  if (assert_failed != 0) {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
                    errline = 0x235;
                    elinks_internal((uchar *)
                                    "assertion j < document->height failed: link out of screen");
                    if (assert_failed != 0) break;
                  }
                  *(link **)((int)document->lines2 + iVar4) = document->links + local_20;
                  pplVar1 = (link **)((int)document->lines1 + iVar4);
                  if (*pplVar1 == (link *)0x0) {
                    *pplVar1 = document->links + local_20;
                  }
                  iVar3 = iVar3 + 1;
                  iVar4 = iVar4 + 4;
                  if (iVar2 < iVar3) goto LAB_0808347c;
                }
                iVar3 = iVar3 + 1;
                iVar4 = iVar4 + 4;
                assert_failed = 0;
              } while (iVar3 <= iVar2);
LAB_0808347c:
              iVar3 = document->nlinks;
            }
            local_20 = local_20 + 1;
          } while ((int)local_20 < iVar3);
        }
        document->field_0x114 = document->field_0x114 | 1;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void render_document(view_state *vs,document_view *doc_view,document_options *options)

{
  uri *uri_00;
  byte bVar1;
  document_view *pdVar2;
  cache_entry *cached_00;
  cache_entry *cached;
  document *document;
  int iVar3;
  fragment *pfVar4;
  fragment *fragment;
  uchar *puVar5;
  uchar *extension;
  uchar *source;
  ulong uVar6;
  uri_component components_00;
  uri_component components;
  stream_encoding encoding;
  uri *uri;
  stream_encoding encoding_00;
  uchar *name;
  bool bVar7;
  string buffer;
  int local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if (((doc_view == (document_view *)0x0) || (vs == (view_state *)0x0)) ||
     (options == (document_options *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x119;
    elinks_internal((uchar *)"assertion vs && doc_view && options failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  puVar5 = doc_view->name;
  doc_view->name = (uchar *)0x0;
  detach_formatted(doc_view);
  doc_view->name = puVar5;
  doc_view->vs = vs;
  doc_view->last_y = -1;
  doc_view->last_x = -1;
  pdVar2 = vs->doc_view;
  if (pdVar2 != (document_view *)0x0) {
    if (assert_failed == 0) {
      bVar7 = pdVar2->vs != vs;
      assert_failed = (int)bVar7;
      if (bVar7) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
        errline = 0x139;
        elinks_internal((uchar *)"assertion vs->doc_view->vs == vs failed!");
      }
      pdVar2 = vs->doc_view;
    }
    pdVar2->used = 0;
    vs->doc_view->vs = (view_state *)0x0;
    vs->doc_view = (document_view *)0x0;
  }
  vs->doc_view = doc_view;
  cached_00 = find_in_cache(vs->uri);
  if (cached_00 == (cache_entry *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 0x146;
    elinks_internal((uchar *)"document %s to format not found",vs->uri->string);
    return;
  }
  document = get_cached_document(cached_00,options);
  if (document != (document *)0x0) {
    doc_view->document = document;
    goto LAB_080836ea;
  }
  document = init_document(cached_00,options);
  if (document == (document *)0x0) {
    return;
  }
  doc_view->document = document;
  if ((doc_view->session != (session *)0x0) && (CACHE_MODE_NORMAL < doc_view->session->reloadlevel))
  {
    iVar3 = vs->form_info_len;
    while (0 < iVar3) {
      done_form_state(vs->form_info + iVar3 + -1);
      iVar3 = vs->form_info_len + -1;
      vs->form_info_len = iVar3;
    }
  }
  shrink_memory(0);
  uri_00 = cached_00->uri;
  pfVar4 = get_cache_fragment(cached_00);
  buffer.source = "";
  buffer.length = 0;
  if (pfVar4 != (fragment *)0x0) {
    buffer.source = pfVar4->data;
    buffer.length = *(int *)&pfVar4->length;
  }
  if (uri_00->protocol == 4) {
LAB_08083908:
    encoding_00 = ENCODING_NONE;
  }
  else {
    encoding_00 = ENCODING_NONE;
    puVar5 = get_extension_from_uri(uri_00);
    if (puVar5 != (uchar *)0x0) {
      encoding_00 = guess_encoding(puVar5);
      mem_free(puVar5);
      if (encoding_00 != ENCODING_NONE) {
        local_20[0] = 0;
        puVar5 = decode_encoded_buffer(encoding_00,buffer.source,buffer.length,local_20);
        if (puVar5 == (uchar *)0x0) goto LAB_08083908;
        buffer.length = local_20[0];
        buffer.source = puVar5;
      }
    }
  }
  if (((document->options).field_0x45 & 0x40) == 0) {
    if (cached_00->content_type != (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
      errline = 0x105;
      iVar3 = elinks_strlcasecmp((uchar *)"application/rss+xml",0x13,cached_00->content_type,
                                 0xffffffff,1);
      if (iVar3 == 0) goto LAB_080838b8;
    }
    render_html_document(cached_00,document,&buffer);
  }
  else if ((cached_00->content_type == (uchar *)0x0) ||
          ((((iVar3 = c_strcasecmp("text/html",(char *)cached_00->content_type), iVar3 != 0 &&
             (iVar3 = c_strcasecmp("application/xhtml+xml",(char *)cached_00->content_type),
             iVar3 != 0)) &&
            ((iVar3 = c_strcasecmp("application/docbook+xml",(char *)cached_00->content_type),
             iVar3 != 0 &&
             (((iVar3 = c_strcasecmp("application/rss+xml",(char *)cached_00->content_type),
               iVar3 != 0 &&
               (iVar3 = c_strcasecmp("application/xbel+xml",(char *)cached_00->content_type),
               iVar3 != 0)) &&
              (iVar3 = c_strcasecmp("application/x-xbel",(char *)cached_00->content_type),
              iVar3 != 0)))))) &&
           (iVar3 = c_strcasecmp("application/xbel",(char *)cached_00->content_type), iVar3 != 0))))
  {
    render_plain_document(cached_00,document,&buffer);
  }
  else {
LAB_080838b8:
    render_dom_document(cached_00,document,&buffer);
  }
  if (encoding_00 != ENCODING_NONE) {
    done_string(&buffer);
  }
  sort_links(document);
  if (document->title == (uchar *)0x0) {
    components_00 = URI_PUBLIC;
    if (document->uri->protocol == 4) {
      components_00 = URI_PATH;
    }
    puVar5 = get_uri_string(document->uri,components_00);
    document->title = puVar5;
    if (puVar5 != (uchar *)0x0) {
      if (((doc_view->document->options).field_0x5c & 0x10) == 0) {
        decode_uri_for_display(puVar5);
      }
      else {
        decode_uri(puVar5);
      }
    }
  }
  uVar6 = get_document_css_magic(document);
  document->css_magic = uVar6;
LAB_080836ea:
  (doc_view->box).x = (document->options).box.x;
  (doc_view->box).y = (document->options).box.y;
  (doc_view->box).width = (document->options).box.width;
  (doc_view->box).height = (document->options).box.height;
  bVar1 = (document->options).field_0x5c;
  if ((bVar1 & 2) == 0) {
    (doc_view->box).width = (options->box).width;
    bVar1 = (document->options).field_0x5c;
  }
  if ((bVar1 & 1) == 0) {
    (doc_view->box).height = (options->box).height;
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void render_document_frames(session *ses,int no_cache)

{
  list_head_elinks *plVar1;
  byte bVar2;
  location *plVar3;
  terminal *ptVar4;
  undefined4 *puVar5;
  document *pdVar6;
  document_view *pdVar7;
  option_value *poVar8;
  document_view *doc_view;
  document_view *pdVar9;
  int iVar10;
  int n;
  uint uVar11;
  document_view *prev_doc_view;
  view_state *vs;
  document_view *current_doc_view;
  bool bVar12;
  document_view *local_b0;
  document_options doc_opts;
  
  if (ses->doc_view == (document_view *)0x0) {
    pdVar9 = (document_view *)mem_calloc(1,0x3c);
    ses->doc_view = pdVar9;
    if (pdVar9 == (document_view *)0x0) {
      return;
    }
    pdVar9->session = ses;
    ses->doc_view->search_word = &ses->search_word;
  }
  plVar3 = (ses->history).current;
  vs = &plVar3->vs;
  if (plVar3 == (location *)0x0) {
    vs = (view_state *)0x0;
  }
  init_document_options(&doc_opts);
  ptVar4 = ses->tab->term;
  doc_opts.box.height = ptVar4->height;
  doc_opts.box.width = ptVar4->width;
  doc_opts.box.x = 0;
  if (doc_opts.box.width < 0) {
    doc_opts.box.width = 0;
  }
  if (doc_opts.box.height < 0) {
    doc_opts.box.height = 0;
  }
  bVar2 = *(byte *)&ses->status;
  bVar12 = (bVar2 & 4) != 0;
  if (bVar12) {
    doc_opts.box.height = doc_opts.box.height + -1;
  }
  doc_opts.box.y = (int)bVar12;
  if ((bVar2 & 2) != 0) {
    doc_opts.box.height = doc_opts.box.height + -1;
  }
  if (((bVar2 & 1) != 0) &&
     (doc_opts.box.height = doc_opts.box.height + -1, ((ses->status).field_0x34 & 4) != 0)) {
    doc_opts.box.y = doc_opts.box.y + 1;
  }
  poVar8 = get_opt_();
  doc_opts.color_mode = poVar8->number;
  poVar8 = get_opt_();
  if (poVar8->tree == (list_head_elinks *)0x0) {
    doc_opts.color_flags = doc_opts.color_flags | COLOR_ENHANCE_UNDERLINE;
  }
  doc_opts.cp = get_terminal_codepage(ses->tab->term);
  doc_opts._92_1_ =
       doc_opts._92_1_ & 0xf3 | (byte)((no_cache & 1U) << 2) |
       (byte)(((uint)no_cache >> 1 & 1) << 3);
  if (vs == (view_state *)0x0) {
    doc_opts._69_1_ = doc_opts._69_1_ | 0x40;
  }
  else {
    if (vs->plain < 0) {
      vs->plain = 0;
      uVar11 = 0;
    }
    else {
      uVar11 = vs->plain & 1;
    }
    doc_opts._69_1_ = doc_opts._69_1_ & 0x3f | (byte)(uVar11 << 6) | vs->field_0x2c << 7;
  }
  plVar1 = &ses->scrn_frames;
  for (puVar5 = (undefined4 *)(ses->scrn_frames).next; plVar1 != (list_head_elinks *)puVar5;
      puVar5 = (undefined4 *)*puVar5) {
    puVar5[0xe] = 0;
  }
  if (vs != (view_state *)0x0) {
    render_document(vs,ses->doc_view,&doc_opts);
  }
  pdVar6 = ses->doc_view->document;
  if ((pdVar6 == (document *)0x0) || (pdVar6->frame_desc == (frameset_desc *)0x0)) {
    local_b0 = (document_view *)0x0;
  }
  else {
    local_b0 = current_frame(ses);
    format_frames(ses,ses->doc_view->document->frame_desc,&doc_opts,0);
  }
  for (pdVar9 = (document_view *)(ses->scrn_frames).next; (document_view *)plVar1 != pdVar9;
      pdVar9 = pdVar9->next) {
    while (pdVar7 = pdVar9->prev, pdVar9->used == 0) {
      detach_formatted(pdVar9);
      pdVar9->next->prev = pdVar9->prev;
      pdVar9->prev->next = pdVar9->next;
      mem_free(pdVar9);
      pdVar9 = pdVar7->next;
      if ((document_view *)plVar1 == pdVar9) goto LAB_08083cef;
    }
  }
LAB_08083cef:
  if ((local_b0 != (document_view *)0x0) &&
     (pdVar9 = (document_view *)(ses->scrn_frames).next, (document_view *)plVar1 != pdVar9)) {
    iVar10 = 0;
    do {
      while ((pdVar9->document != (document *)0x0 &&
             (pdVar9->document->frame_desc != (frameset_desc *)0x0))) {
        pdVar9 = pdVar9->next;
        if ((document_view *)plVar1 == pdVar9) {
          return;
        }
      }
      if (pdVar9 == local_b0) {
        (((ses->history).current)->vs).current_link = iVar10;
        return;
      }
      pdVar9 = pdVar9->next;
      iVar10 = iVar10 + 1;
    } while ((document_view *)plVar1 != pdVar9);
  }
  return;
}



// WARNING: Unknown calling convention

void apply_css_selector_style
               (html_context *html_context,html_element *element,css_selector *selector)

{
  css_property *pcVar1;
  css_property *property;
  
  pcVar1 = (css_property *)(selector->properties).next;
  do {
    if (pcVar1 == (css_property *)&selector->properties) {
      return;
    }
    if (assert_failed == 0) {
      assert_failed = (int)(CSS_PT_WHITE_SPACE < pcVar1->type);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
        errline = 0x114;
        elinks_internal((uchar *)"assertion property->type < CSS_PT_LAST failed!");
        if (assert_failed != 0) goto LAB_08083dfb;
      }
      assert_failed = (int)(css_appliers[pcVar1->type] == (css_applier_T)0x0);
      if (css_appliers[pcVar1->type] == (css_applier_T)0x0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
        errline = 0x118;
        elinks_internal((uchar *)"assertion css_appliers[property->type] failed!");
      }
    }
LAB_08083dfb:
    (*css_appliers[pcVar1->type])(html_context,element,pcVar1);
    pcVar1 = pcVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

void css_apply_text_align(html_context *html_context,html_element *element,css_property *prop)

{
  if ((assert_failed == 0) &&
     (assert_failed = (int)(prop->value_type != CSS_VT_TEXT_ALIGN), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x65;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_TEXT_ALIGN failed!");
    (element->parattr).align = (format_align)(prop->value).none;
    return;
  }
  (element->parattr).align = (format_align)(prop->value).none;
  return;
}



// WARNING: Unknown calling convention

void css_apply_font_attribute(html_context *html_context,html_element *element,css_property *prop)

{
  text_style_format tVar1;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(prop->value_type != CSS_VT_FONT_ATTRIBUTE), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x59;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
  }
  tVar1 = (prop->value).color | (element->attr).style.attr;
  (element->attr).style.attr = tVar1;
  (element->attr).style.attr = ~(prop->value).font_attribute.rem & tVar1;
  return;
}



// WARNING: Unknown calling convention

void css_apply_display(html_context *html_context,html_element *element,css_property *prop)

{
  if ((assert_failed == 0) &&
     (assert_failed = (int)(prop->value_type != CSS_VT_DISPLAY), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_DISPLAY failed!");
  }
  if ((prop->value).none == (void *)0x0) {
    element->linebreak = 0;
    return;
  }
  if ((prop->value).none != (void *)0x1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x50;
    elinks_internal((uchar *)"Bad prop->value.display %d");
    return;
  }
  element->linebreak = 2;
  return;
}



// WARNING: Unknown calling convention

void css_apply_color(html_context *html_context,html_element *element,css_property *prop)

{
  if ((assert_failed == 0) &&
     (assert_failed = (int)(prop->value_type != CSS_VT_COLOR), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x2e;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_COLOR failed!");
  }
  if ((html_context->options->color_mode != COLOR_MODE_MONO) &&
     (0 < html_context->options->use_document_colors)) {
    (element->attr).style.fg = (color_T)(prop->value).none;
  }
  return;
}



// WARNING: Unknown calling convention

void css_apply_background_color(html_context *html_context,html_element *element,css_property *prop)

{
  if ((assert_failed == 0) &&
     (assert_failed = (int)(prop->value_type != CSS_VT_COLOR), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 0x39;
    elinks_internal((uchar *)"assertion prop->value_type == CSS_VT_COLOR failed!");
  }
  if ((html_context->options->color_mode != COLOR_MODE_MONO) &&
     (html_context->options->use_document_colors == 2)) {
    (element->attr).style.bg = (color_T)(prop->value).none;
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void examine_element(html_context *html_context,css_selector *base,css_selector_type seltype,
                    css_selector_relation rel,list_head_elinks *selectors,html_element *element)

{
  html_element_pseudo_class hVar1;
  css_selector *pcVar2;
  list_head_elinks *plVar3;
  uchar *class;
  uchar *puVar4;
  html_element *ancestor_4;
  html_element *ancestor_3;
  html_element *ancestor_2;
  html_element *ancestor;
  html_element *phVar5;
  uchar *puVar6;
  css_selector *selector;
  html_element *ancestor_1;
  list_head_elinks *plVar7;
  css_selector_type local_30;
  list_head_elinks *local_28;
  
  if ((seltype == CST_ELEMENT) && (plVar3 = &html_context->stack, element->namelen != 0)) {
    pcVar2 = find_css_selector(selectors,CST_ELEMENT,rel,"*",1);
    if (pcVar2 != (css_selector *)0x0) {
      plVar7 = &pcVar2->leaves;
      merge_css_selectors(base,pcVar2);
      phVar5 = element->next;
      if (phVar5 != (html_element *)plVar3) {
        do {
          examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,plVar7,phVar5);
          phVar5 = phVar5->next;
        } while ((html_element *)plVar3 != phVar5);
        examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,plVar7,element->next);
      }
      examine_element(html_context,base,CST_ID,CSR_SPECIFITY,plVar7,element);
    }
    pcVar2 = find_css_selector(selectors,CST_ELEMENT,rel,element->name,element->namelen);
    if (pcVar2 != (css_selector *)0x0) {
      plVar7 = &pcVar2->leaves;
      merge_css_selectors(base,pcVar2);
      phVar5 = element->next;
      if (phVar5 != (html_element *)plVar3) {
        do {
          examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,plVar7,phVar5);
          phVar5 = phVar5->next;
        } while ((html_element *)plVar3 != phVar5);
        examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,plVar7,element->next);
      }
      examine_element(html_context,base,CST_ID,CSR_SPECIFITY,plVar7,element);
    }
  }
  local_28 = &html_context->stack;
  puVar4 = element->options;
  do {
    if (puVar4 == (uchar *)0x0) {
      return;
    }
    hVar1 = element->pseudo_class;
    if ((hVar1 & ELEMENT_LINK) != 0) {
      pcVar2 = find_css_selector(selectors,CST_PSEUDO,rel,"link",-1);
      if (pcVar2 != (css_selector *)0x0) {
        plVar3 = &pcVar2->leaves;
        merge_css_selectors(base,pcVar2);
        phVar5 = element->next;
        if (phVar5 != (html_element *)local_28) {
          do {
            examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,plVar3,phVar5);
            phVar5 = phVar5->next;
          } while ((html_element *)local_28 != phVar5);
          examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,plVar3,element->next);
        }
        examine_element(html_context,base,CST_INVALID,CSR_SPECIFITY,plVar3,element);
      }
      hVar1 = element->pseudo_class;
    }
    if (((hVar1 & ELEMENT_VISITED) != 0) &&
       (pcVar2 = find_css_selector(selectors,CST_PSEUDO,rel,"visited",-1),
       pcVar2 != (css_selector *)0x0)) {
      plVar3 = &pcVar2->leaves;
      merge_css_selectors(base,pcVar2);
      phVar5 = element->next;
      if ((html_element *)local_28 != phVar5) {
        do {
          examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,plVar3,phVar5);
          phVar5 = phVar5->next;
        } while ((html_element *)local_28 != phVar5);
        examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,plVar3,element->next);
      }
      examine_element(html_context,base,CST_INVALID,CSR_SPECIFITY,plVar3,element);
    }
    puVar4 = (element->attr).class;
    if ((seltype < CST_PSEUDO) && (puVar4 != (uchar *)0x0)) {
      while( true ) {
        for (; *puVar4 == ' '; puVar4 = puVar4 + 1) {
        }
        puVar6 = puVar4;
        if (*puVar4 == '\0') break;
        do {
          puVar6 = puVar6 + 1;
          if (*puVar6 == '\0') break;
        } while (*puVar6 != ' ');
        pcVar2 = find_css_selector(selectors,CST_CLASS,rel,puVar4,(int)puVar6 - (int)puVar4);
        puVar4 = puVar6;
        if (pcVar2 != (css_selector *)0x0) {
          plVar3 = &pcVar2->leaves;
          merge_css_selectors(base,pcVar2);
          phVar5 = element->next;
          if ((html_element *)local_28 != phVar5) {
            do {
              examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,plVar3,phVar5);
              phVar5 = phVar5->next;
            } while ((html_element *)local_28 != phVar5);
            examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,plVar3,element->next);
          }
          examine_element(html_context,base,CST_PSEUDO,CSR_SPECIFITY,plVar3,element);
        }
      }
    }
    puVar4 = (element->attr).id;
    if (CST_ID < seltype) {
      return;
    }
    if (puVar4 == (uchar *)0x0) {
      return;
    }
    pcVar2 = find_css_selector(selectors,CST_ID,rel,puVar4,-1);
    if (pcVar2 == (css_selector *)0x0) {
      return;
    }
    selectors = &pcVar2->leaves;
    merge_css_selectors(base,pcVar2);
    phVar5 = element->next;
    if ((html_element *)local_28 != phVar5) {
      do {
        examine_element(html_context,base,CST_ELEMENT,CSR_ANCESTOR,selectors,phVar5);
        phVar5 = phVar5->next;
      } while ((html_element *)local_28 != phVar5);
      examine_element(html_context,base,CST_ELEMENT,CSR_PARENT,selectors,element->next);
    }
    local_30 = CST_CLASS;
    rel = CSR_SPECIFITY;
    puVar4 = element->options;
    seltype = local_30;
  } while( true );
}



// WARNING: Unknown calling convention

css_selector *
get_css_selector_for_element
          (html_context *html_context,html_element *element,css_stylesheet *css,
          list_head_elinks *html_stack)

{
  css_selector *base;
  css_selector *selector;
  uchar *string;
  uchar *code;
  css_selector *sel2;
  css_selector *stylesel;
  scanner scanner;
  
  if (assert_failed == 0) {
    if (((element == (html_element *)0x0) || (css == (css_stylesheet *)0x0)) ||
       (element->options == (uchar *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 0xe8;
      elinks_internal((uchar *)"assertion element && element->options && css failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  base = init_css_selector((list_head_elinks *)0x0,CST_ELEMENT,(uchar *)0x0,0);
  if (base != (css_selector *)0x0) {
    examine_element(html_context,base,CST_ELEMENT,CSR_ROOT,&css->selectors,element);
    string = get_attr_value(element->options,"style",html_context->doc_cp,HTML_ATTR_NONE);
    if (string != (uchar *)0x0) {
      sel2 = init_css_selector((list_head_elinks *)0x0,CST_ELEMENT,(uchar *)0x0,0);
      if (sel2 != (css_selector *)0x0) {
        init_scanner(&scanner,&css_scanner_info,string,(uchar *)0x0);
        css_parse_properties(&sel2->properties,&scanner);
        merge_css_selectors(base,sel2);
        done_css_selector(sel2);
      }
      mem_free(string);
    }
  }
  return base;
}



// WARNING: Unknown calling convention

void css_apply(html_context *html_context,html_element *element,css_stylesheet *css,
              list_head_elinks *html_stack)

{
  css_selector *selector_00;
  css_selector *selector;
  
  selector_00 = get_css_selector_for_element(html_context,element,css,html_stack);
  if (selector_00 != (css_selector *)0x0) {
    apply_css_selector_style(html_context,element,selector_00);
    done_css_selector(selector_00);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void done_css(module *module)

{
  done_css_stylesheet(&default_stylesheet);
  return;
}



// WARNING: Unknown calling convention

void import_css_file(css_stylesheet *css,uri *base_uri,uchar *url,int urllen)

{
  uint uVar1;
  string *psVar2;
  uint uVar3;
  uchar *puVar4;
  int newlength;
  int iVar5;
  size_t newsize;
  uint size;
  uchar *end;
  int local_34;
  string filename;
  string string;
  
  if (*url == '\0') {
    return;
  }
  if (9 < css->import_level) {
    return;
  }
  psVar2 = init_string(&filename);
  if (psVar2 == (string *)0x0) {
    return;
  }
  if ((*url != '/') && (elinks_home != (uchar *)0x0)) {
    add_to_string(&filename,elinks_home);
  }
  if (assert_failed == 0) {
    if (urllen < 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_08084933;
    }
    else {
      assert_failed = 0;
      if (urllen == 0) goto LAB_0808493d;
    }
    iVar5 = urllen + filename.length;
    uVar1 = filename.length + 0xffU >> 8;
    uVar3 = filename.length + 0xffU & 0xffffff00;
    size = iVar5 + 0x100U & 0xffffff00;
    if (uVar3 <= size && size + uVar1 * -0x100 != 0) {
      puVar4 = (uchar *)mem_realloc(filename.source,size);
      if (puVar4 == (uchar *)0x0) goto LAB_0808493d;
      filename.source = puVar4;
      memset(puVar4 + uVar3,0,size + uVar1 * -0x100);
    }
    if (filename.source != (uchar *)0x0) {
      memcpy(filename.source + filename.length,url,urllen);
      filename.source[iVar5] = '\0';
      filename.length = iVar5;
    }
  }
  else {
LAB_08084933:
    assert_failed = 0;
  }
LAB_0808493d:
  read_encoded_file(&filename,&string);
  if (local_34 == -100000) {
    css->import_level = css->import_level + 1;
    css_parse_stylesheet(css,base_uri,string.source,string.source + string.length);
    done_string(&string);
    css->import_level = css->import_level + -1;
  }
  done_string(&filename);
  return;
}



// WARNING: Unknown calling convention

void import_default_css(void)

{
  uchar *url_00;
  option_value *poVar1;
  size_t urllen;
  uchar *url;
  
  poVar1 = get_opt_();
  url_00 = poVar1->string;
  if ((list_head_elinks *)default_stylesheet.selectors.next != &default_stylesheet.selectors) {
    done_css_stylesheet(&default_stylesheet);
  }
  if (*url_00 != '\0') {
    urllen = strlen((char *)url_00);
    import_css_file(&default_stylesheet,(uri *)0x0,url_00,urllen);
  }
  return;
}



// WARNING: Unknown calling convention

void init_css(module *module)

{
  register_change_hooks(init_css::css_change_hooks);
  import_default_css();
  return;
}



// WARNING: Unknown calling convention

int change_hook_css(session *ses,option_elinks *current,option_elinks *changed)

{
  session **ppsVar1;
  int iVar2;
  uchar *puVar3;
  session *ses_00;
  uchar *puVar4;
  bool bVar5;
  
  iVar2 = 0xb;
  bVar5 = &stack0x00000000 == (undefined *)0x1c;
  puVar3 = changed->name;
  puVar4 = "stylesheet";
  do {
    if (iVar2 == 0) break;
    iVar2 = iVar2 + -1;
    bVar5 = *puVar3 == *puVar4;
    puVar3 = puVar3 + 1;
    puVar4 = puVar4 + 1;
  } while (bVar5);
  if (bVar5) {
    import_default_css();
  }
  ses_00 = (session *)sessions.next;
  if ((list_head_elinks *)sessions.next != &sessions) {
    do {
      draw_formatted(ses_00,1);
      ppsVar1 = &ses_00->next;
      ses_00 = *ppsVar1;
    } while (*ppsVar1 != (session *)&sessions);
  }
  return 0;
}



// WARNING: Unknown calling convention

void import_css(css_stylesheet *css,uri *uri)

{
  int iVar1;
  cache_entry *cached;
  cache_entry *cached_00;
  fragment *pfVar2;
  uchar *end;
  
  if ((uri != (uri *)0x0) && (css->import_level < 10)) {
    cached_00 = get_redirected_cache_entry(uri);
    if (cached_00 != (cache_entry *)0x0) {
      pfVar2 = get_cache_fragment(cached_00);
      if (pfVar2 != (fragment *)0x0) {
        iVar1 = *(int *)&pfVar2->length;
        css->import_level = css->import_level + 1;
        css_parse_stylesheet(css,uri,pfVar2->data,pfVar2->data + iVar1);
        css->import_level = css->import_level + -1;
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

css_selector * reparent_selector(list_head_elinks *sels,css_selector *selector,css_selector **watch)

{
  css_selector *pcVar1;
  css_selector *selector_00;
  
  pcVar1 = find_css_selector(sels,selector->type,selector->relation,selector->name,-1);
  if (pcVar1 != (css_selector *)0x0) {
    merge_css_selectors(pcVar1,selector);
    selector_00 = (css_selector *)(selector->leaves).next;
    if (selector_00 != (css_selector *)&selector->leaves) {
      do {
        reparent_selector(&pcVar1->leaves,selector_00,watch);
        selector_00 = (css_selector *)(selector->leaves).next;
      } while (selector_00 != (css_selector *)&selector->leaves);
    }
    if (*watch == selector) {
      *watch = pcVar1;
    }
    done_css_selector(selector);
    return pcVar1;
  }
  if (selector->next != (css_selector *)0x0) {
    selector->next->prev = selector->prev;
    selector->prev->next = selector->next;
  }
  pcVar1 = (css_selector *)sels->next;
  selector->prev = (css_selector *)sels;
  selector->next = pcVar1;
  sels->next = selector;
  selector->next->prev = selector;
  return selector;
}



// WARNING: Unknown calling convention

void css_parse_properties(list_head_elinks *props,scanner *scanner)

{
  scanner_token *psVar1;
  int iVar2;
  uchar *puVar3;
  void *pvVar4;
  scanner_token *psVar5;
  void **p;
  int iVar6;
  scanner_token *token;
  css_property_info *property_info;
  css_property_info *propinfo;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(scanner == (scanner *)0x0 || props == (list_head_elinks *)0x0),
     scanner == (scanner *)0x0 || props == (list_head_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
    errline = 0x1e;
    elinks_internal((uchar *)"assertion props && scanner failed!");
  }
LAB_08084d0b:
  iVar6 = scanner->tokens;
LAB_08084d0e:
  if (iVar6 < 1) {
    return;
  }
  do {
    psVar1 = scanner->current;
    psVar5 = scanner->table + iVar6;
    if (psVar5 <= psVar1) {
      return;
    }
    if (psVar1 == (scanner_token *)0x0) {
      return;
    }
    iVar2 = psVar1->type;
    if (iVar2 == 0x7d) {
      return;
    }
    if (iVar2 == 0x100) {
      if ((psVar1 + 1 < psVar5) && (psVar1[1].type == 0x3a)) {
        propinfo = css_property_info;
        puVar3 = css_property_info[0].name;
        break;
      }
    }
    else if (iVar2 == 0x7b) goto LAB_08084e70;
    skip_scanner_tokens(scanner,0x3b,0x100);
    iVar6 = scanner->tokens;
    if (iVar6 < 1) {
      return;
    }
  } while( true );
joined_r0x08084d81:
  if (puVar3 == (uchar *)0x0) goto LAB_08084ebd;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
  errline = 0x39;
  iVar6 = elinks_strlcasecmp(psVar1->string,psVar1->length,propinfo->name,0xffffffff,1);
  if (iVar6 == 0) goto LAB_08084dd6;
  puVar3 = propinfo[1].name;
  propinfo = propinfo + 1;
  goto joined_r0x08084d81;
LAB_08084ebd:
  propinfo = (css_property_info *)0x0;
LAB_08084dd6:
  psVar5 = skip_scanner_tokens(scanner,0x3a,0);
  if (psVar5 == (scanner_token *)0x0) {
    if (assert_failed == 0) {
      if ((0 < scanner->tokens) && (scanner->current < scanner->table + scanner->tokens)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
        errline = 0x41;
        elinks_internal((uchar *)"assertion !scanner_has_tokens(scanner) failed!");
        return;
      }
      assert_failed = 0;
    }
    return;
  }
  if ((propinfo != (css_property_info *)0x0) && (p = (void **)mem_calloc(1,0x18), p != (void **)0x0)
     ) {
    p[2] = (void *)propinfo->type;
    p[3] = (void *)propinfo->value_type;
    iVar6 = css_parse_value(propinfo,(css_property_value *)(p + 4),scanner);
    if (iVar6 == 0) {
      mem_free(p);
    }
    else {
      pvVar4 = props->next;
      p[1] = props;
      *p = pvVar4;
      props->next = p;
      *(void ***)((int)*p + 4) = p;
    }
  }
  skip_scanner_tokens(scanner,0x3b,0x100);
  goto LAB_08084d0b;
LAB_08084e70:
  scanner->current = psVar1 + 1;
  if (psVar5 <= psVar1 + 2) {
    (*scanner->info->scan)(scanner);
    iVar6 = scanner->tokens;
  }
  goto LAB_08084d0e;
}



// WARNING: Unknown calling convention

void skip_css_block(scanner *scanner)

{
  scanner_token *psVar1;
  scanner_token *psVar2;
  scanner_token *psVar3;
  scanner_token *token;
  int iVar4;
  int iVar5;
  int depth;
  
  psVar3 = skip_scanner_tokens(scanner,0x7b,0x200);
  if ((((psVar3 != (scanner_token *)0x0) && (iVar4 = scanner->tokens, 0 < iVar4)) &&
      (psVar3 = scanner->current, psVar3 < scanner->table + iVar4)) &&
     ((psVar3 != (scanner_token *)0x0 && (psVar3->precedence < 0x401)))) {
    iVar5 = 1;
    while( true ) {
      if (psVar3->type == 0x7b) {
        iVar5 = iVar5 + 1;
      }
      else {
        iVar5 = iVar5 - (uint)(psVar3->type == 0x7d);
      }
      if (iVar4 < 1) break;
      psVar2 = scanner->current;
      psVar1 = scanner->table + iVar4;
      if (psVar1 <= psVar2) {
        return;
      }
      psVar3 = psVar2 + 1;
      scanner->current = psVar3;
      if (psVar2 + 2 < psVar1) {
        if (psVar1 <= psVar3) {
          return;
        }
      }
      else {
        psVar3 = (*scanner->info->scan)(scanner);
      }
      if (psVar3 == (scanner_token *)0x0) {
        return;
      }
      if (iVar5 < 1) {
        return;
      }
      if (0x400 < psVar3->precedence) {
        return;
      }
      iVar4 = scanner->tokens;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void css_parse_stylesheet(css_stylesheet *css,uri *base_uri,uchar *string,uchar *end)

{
  uchar uVar1;
  void **ppvVar2;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  list_head_elinks *plVar5;
  scanner_token *token_1;
  int selector_start;
  xlist_head *head_1;
  css_selector *pcVar6;
  list_head_elinks *plVar7;
  scanner_token *psVar8;
  list_head_elinks *sels;
  css_selector_relation reltype;
  css_selector_relation cVar9;
  uint uVar10;
  int iVar11;
  scanner_token *token;
  scanner_token *psVar12;
  selector_pkg *pkg;
  uchar *name;
  css_selector *pcVar13;
  css_selector *prev_element_selector;
  css_selector *selector;
  uint uVar14;
  int last_fragment;
  bool bVar15;
  css_selector_type local_100;
  css_selector *local_fc;
  css_selector *local_f8;
  scanner_token *local_f4;
  void **local_f0;
  scanner scanner;
  list_head_elinks properties;
  list_head_elinks selectors;
  
  init_scanner(&scanner,&css_scanner_info,string,end);
  sels = &css->selectors;
LAB_08085068:
  while( true ) {
    if ((scanner.tokens < 1) || (scanner.table + scanner.tokens <= scanner.current)) {
      return;
    }
    psVar12 = scanner.current;
    if (scanner.table + scanner.tokens <= scanner.current) {
      psVar12 = (scanner_token *)0x0;
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(psVar12 == (scanner_token *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x229;
      elinks_internal((uchar *)"assertion token failed!");
    }
    if (5 < psVar12->type - 0x110U) break;
    iVar11 = iRam00000000;
    if ((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) {
      iVar11 = (scanner.current)->type;
    }
    if (iVar11 - 0x110U < 6) {
                    // WARNING: Could not recover jumptable at 0x0808512e. Too many branches
                    // WARNING: Treating indirect jump as call
      (*(code *)(&PTR_DAT_081019d8)[iVar11 - 0x110U])();
      return;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
    errline = 0xb4;
    elinks_internal((uchar *)"@-rule parser called without atrule.");
  }
  selectors.next = &selectors;
  selector = (css_selector *)0x0;
  properties.next = &properties;
  uVar14 = 0;
  bVar15 = true;
  local_fc = (css_selector *)0x0;
  local_f8 = (css_selector *)0x0;
  local_f0 = (void **)0x0;
  properties.prev = properties.next;
  selectors.prev = selectors.next;
LAB_080851de:
  psVar12 = scanner.current;
  if ((scanner.tokens < 1) || (scanner.table + scanner.tokens <= scanner.current))
  goto LAB_080852c1;
  if (assert_failed == 0) {
    assert_failed = (int)(scanner.current == (scanner_token *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x116;
      elinks_internal((uchar *)"assertion token failed!");
      if (assert_failed != 0) goto LAB_0808522b;
    }
    assert_failed = uVar14;
    if (uVar14 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x117;
      elinks_internal((uchar *)"assertion !last_fragment failed!");
    }
  }
LAB_0808522b:
  iVar11 = psVar12->type;
  if (((iVar11 == 0x7d) || (iVar11 == 0x7b)) || (iVar11 == 0x3b)) goto LAB_080852c1;
  if (iVar11 == 0x100) {
    if (local_f0 == (void **)0x0) {
      iVar11 = psVar12->length;
      cVar9 = CSR_ROOT;
      name = psVar12->string;
      local_100 = CST_ELEMENT;
    }
    else {
      iVar11 = psVar12->length;
      cVar9 = CSR_ANCESTOR;
      name = psVar12->string;
      local_100 = CST_ELEMENT;
    }
  }
  else {
    if (iVar11 != 0x3e) {
      if (iVar11 < 0x3f) {
        if (iVar11 == 0x2e) {
          local_100 = CST_CLASS;
        }
        else {
          if (iVar11 != 0x3a) goto LAB_080851a6;
          local_100 = CST_PSEUDO;
        }
        if (bVar15) {
          cVar9 = CSR_ANCESTOR;
        }
        else {
          cVar9 = CSR_SPECIFITY;
        }
        goto LAB_080854c5;
      }
      uVar10 = iVar11 - 0x10b;
      if (uVar10 < 2) {
        local_100 = CST_ID;
        cVar9 = CSR_ANCESTOR - !bVar15;
        goto LAB_08085485;
      }
LAB_080851a6:
      psVar12 = skip_scanner_tokens(&scanner,0x2c,0);
      if (((psVar12 == (scanner_token *)0x0) && (0 < scanner.tokens)) &&
         ((scanner.current < scanner.table + scanner.tokens &&
          (psVar12 = scanner.current + 1, psVar8 = scanner.current + 2, scanner.current = psVar12,
          scanner.table + scanner.tokens <= psVar8)))) {
        (*(scanner.info)->scan)(&scanner);
      }
      goto LAB_080851de;
    }
    local_100 = CST_ELEMENT;
    cVar9 = CSR_PARENT;
    uVar10 = 0xffffff33;
LAB_08085485:
    if (1 < uVar10) {
LAB_080854c5:
      if ((scanner.tokens < 1) ||
         (psVar12 = scanner.table + scanner.tokens, psVar12 <= scanner.current)) goto LAB_080852c1;
      psVar8 = scanner.current + 1;
      if (scanner.current + 2 < psVar12) {
        scanner.current = psVar8;
        if (psVar12 <= psVar8) goto LAB_080852c1;
      }
      else {
        scanner.current = psVar8;
        psVar8 = (*(scanner.info)->scan)(&scanner);
      }
      if (psVar8 == (scanner_token *)0x0) goto LAB_080852c1;
      if (psVar8->type == 0x100) {
        iVar11 = psVar8->length;
        name = psVar8->string;
        goto LAB_08085273;
      }
      goto LAB_080851de;
    }
    name = psVar12->string + 1;
    iVar11 = psVar12->length + -1;
    psVar12->string = name;
    psVar12->length = iVar11;
  }
LAB_08085273:
  if (name + iVar11 < scanner.end) {
    uVar1 = name[iVar11];
    if ((uVar1 == '.') || (uVar1 == '#')) {
      bVar15 = false;
    }
    else {
      bVar15 = uVar1 != ':';
    }
  }
  if ((scanner.tokens < 1) || (psVar12 = scanner.table + scanner.tokens, psVar12 <= scanner.current)
     ) goto LAB_080852c1;
  local_f4 = scanner.current + 1;
  if (scanner.current + 2 < psVar12) {
    scanner.current = local_f4;
    if (psVar12 <= local_f4) goto LAB_080852c1;
  }
  else {
    scanner.current = local_f4;
    local_f4 = (*(scanner.info)->scan)(&scanner);
  }
  if (local_f4 == (scanner_token *)0x0) goto LAB_080852c1;
  uVar14 = (uint)(local_f4->type == 0x7b || local_f4->type == 0x2c);
  if (local_f0 == (void **)0x0) {
    if ((css == (css_stylesheet *)0x0) || (plVar7 = sels, uVar14 == 0)) {
      plVar7 = (list_head_elinks *)0x0;
    }
    pcVar13 = get_css_selector(plVar7,local_100,CSR_ROOT,name,iVar11);
    if ((pcVar13 == (css_selector *)0x0) ||
       (local_f0 = (void **)mem_calloc(1,0xc), local_f0 == (void **)0x0)) goto LAB_080851de;
    *local_f0 = selectors.next;
    local_f0[1] = &selectors;
    *(void ***)((int)*local_f0 + 4) = local_f0;
    local_f0[2] = pcVar13;
    pcVar6 = pcVar13;
    selectors.next = local_f0;
    if (cVar9 != CSR_SPECIFITY) {
LAB_0808562c:
      pcVar13 = (css_selector *)0x0;
      selector = pcVar6;
    }
LAB_08085630:
    if (uVar14 != 0) {
      bVar15 = true;
      pcVar13 = (css_selector *)0x0;
      selector = (css_selector *)0x0;
      local_fc = (css_selector *)0x0;
      local_f0 = (void **)0x0;
    }
  }
  else {
    if (cVar9 != CSR_SPECIFITY) {
      if ((css == (css_stylesheet *)0x0) || (plVar7 = sels, uVar14 == 0)) {
        plVar7 = (list_head_elinks *)0x0;
      }
      pcVar6 = get_css_selector(plVar7,local_100,CSR_ROOT,name,iVar11);
      if (pcVar6 != (css_selector *)0x0) {
        if ((assert_failed == 0) &&
           (assert_failed = (int)(selector == (css_selector *)0x0), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
          errline = 0x1ad;
          elinks_internal((uchar *)"assertion prev_element_selector failed!");
        }
        pcVar13 = (css_selector *)(pcVar6->leaves).next;
        selector->prev = (css_selector *)&pcVar6->leaves;
        selector->next = pcVar13;
        (pcVar6->leaves).next = selector;
        selector->next->prev = selector;
        selector->relation = cVar9;
        local_fc = selector;
        goto LAB_0808562c;
      }
      goto LAB_080851de;
    }
    pcVar6 = local_f8;
    if (local_f8 == (css_selector *)0x0) {
      pcVar6 = selector;
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(pcVar6 == (css_selector *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 0x17f;
      elinks_internal((uchar *)"assertion base_sel failed!");
    }
    pcVar13 = get_css_selector(&pcVar6->leaves,local_100,CSR_SPECIFITY,name,iVar11);
    if (pcVar13 == (css_selector *)0x0) goto LAB_080851de;
    if (local_fc != (css_selector *)0x0) {
      local_fc->next->prev = local_fc->prev;
      local_fc->prev->next = local_fc->next;
      local_fc->next = (css_selector *)(pcVar13->leaves).next;
      local_fc->prev = (css_selector *)&pcVar13->leaves;
      (pcVar13->leaves).next = local_fc;
      local_fc->next->prev = local_fc;
    }
    if (pcVar6 == (css_selector *)local_f0[2]) {
      local_f0[2] = pcVar13;
    }
    if (uVar14 != 0) {
      if ((assert_failed == 0) &&
         (assert_failed = (int)(selector == (css_selector *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
        errline = 0x19b;
        elinks_internal((uchar *)"assertion prev_element_selector failed!");
      }
      selector->relation = CSR_ROOT;
      selector = reparent_selector(sels,selector,(css_selector **)(local_f0 + 2));
      goto LAB_08085630;
    }
  }
  local_f8 = pcVar13;
  if (local_f4->type == 0x2c) {
    if (((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) &&
       (psVar12 = scanner.current + 1, psVar8 = scanner.current + 2, scanner.current = psVar12,
       scanner.table + scanner.tokens <= psVar8)) {
      uVar14 = 0;
      (*(scanner.info)->scan)(&scanner);
      goto LAB_080851de;
    }
  }
  else if (local_f4->type == 0x7b) goto LAB_080852c1;
  uVar14 = 0;
  goto LAB_080851de;
LAB_080852c1:
  if (local_f0 != (void **)0x0) {
    if (selector != (css_selector *)0x0) {
      done_css_selector(selector);
    }
    *(void **)((int)*local_f0 + 4) = local_f0[1];
    *(void **)local_f0[1] = *local_f0;
    mem_free(local_f0);
  }
  if (&selectors != (list_head_elinks *)selectors.next) {
    psVar12 = skip_scanner_tokens(&scanner,0x7b,0x200);
    if (psVar12 != (scanner_token *)0x0) {
      css_parse_properties(&properties,&scanner);
      skip_scanner_tokens(&scanner,0x7d,0x400);
      for (plVar7 = (list_head_elinks *)selectors.next; plVar3 = (list_head_elinks *)selectors.next,
          plVar7 != &selectors; plVar7 = (list_head_elinks *)plVar7->next) {
        add_selector_properties((css_selector *)plVar7[1].next,&properties);
      }
      for (; plVar7 = (list_head_elinks *)selectors.prev, plVar3 != &selectors;
          plVar3 = (list_head_elinks *)plVar3->next) {
      }
      for (; plVar7 != plVar3; plVar7 = (list_head_elinks *)plVar7->prev) {
      }
      plVar5 = (list_head_elinks *)*(void **)selectors.next;
      plVar7 = (list_head_elinks *)selectors.next;
      while (plVar4 = plVar5, plVar7 != plVar3) {
        plVar4->prev = plVar7->prev;
        *(void **)plVar7->prev = plVar7->next;
        mem_free(plVar7);
        plVar5 = (list_head_elinks *)plVar4->next;
        plVar7 = plVar4;
      }
      plVar7 = (list_head_elinks *)properties.next;
      plVar3 = (list_head_elinks *)properties.prev;
      if ((list_head_elinks *)properties.next == &properties) {
        plVar7 = &properties;
      }
      else {
        do {
          plVar7 = (list_head_elinks *)plVar7->next;
        } while (plVar7 != &properties);
      }
      for (; plVar3 != plVar7; plVar3 = (list_head_elinks *)plVar3->prev) {
      }
      plVar5 = (list_head_elinks *)*(void **)properties.next;
      plVar3 = (list_head_elinks *)properties.next;
      while (plVar4 = plVar5, plVar3 != plVar7) {
        plVar4->prev = plVar3->prev;
        *(void **)plVar3->prev = plVar3->next;
        mem_free(plVar3);
        plVar5 = (list_head_elinks *)plVar4->next;
        plVar3 = plVar4;
      }
      goto LAB_08085068;
    }
    plVar7 = (list_head_elinks *)selectors.next;
    if (&selectors != (list_head_elinks *)selectors.next) {
      do {
        ppvVar2 = &plVar7->next;
        plVar7 = (list_head_elinks *)*ppvVar2;
        plVar3 = (list_head_elinks *)selectors.prev;
      } while (&selectors != (list_head_elinks *)*ppvVar2);
      for (; &selectors != plVar3; plVar3 = (list_head_elinks *)plVar3->prev) {
      }
                    // WARNING: Load size is inaccurate
      plVar3 = *selectors.next;
      plVar7 = (list_head_elinks *)selectors.next;
      while (plVar5 = plVar3, &selectors != plVar7) {
        plVar5->prev = plVar7->prev;
        *(void **)plVar7->prev = plVar7->next;
        mem_free(plVar7);
        plVar3 = (list_head_elinks *)plVar5->next;
        plVar7 = plVar5;
      }
    }
  }
  skip_scanner_tokens(&scanner,0x7d,0x400);
  goto LAB_08085068;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

scanner_token * scan_css_tokens(scanner *scanner)

{
  scanner_token *__dest;
  byte *__s;
  byte bVar1;
  byte bVar2;
  scanner_token *psVar3;
  uint uVar4;
  byte bVar5;
  scanner_token *__src;
  uint uVar6;
  uchar *puVar7;
  void *pvVar8;
  int real_length;
  scanner *psVar9;
  uchar *to;
  scanner_token *table;
  size_t __n;
  byte *pbVar10;
  int hexdigits;
  int move_to_front;
  int iVar11;
  uchar *string;
  byte *pbVar12;
  css_token_type type;
  uchar *puVar13;
  size_t moved_size;
  scanner *psVar14;
  byte *pbVar15;
  byte *pbVar16;
  byte *local_30;
  scanner *local_20;
  
  __dest = scanner->table;
  psVar3 = scanner->current;
  iVar11 = (int)scanner + ((scanner->tokens * 0x10 + 0x1c) - (int)psVar3) >> 4;
  __src = psVar3;
  if (iVar11 < 1) {
    iVar11 = 0;
    __src = __dest;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(psVar3 == (scanner_token *)0x0), psVar3 == (scanner_token *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
    errline = 0xd8;
    elinks_internal((uchar *)"assertion scanner->current failed!");
  }
  __n = 0xa0;
  if (iVar11 != 0) {
    memmove(__dest,__src,iVar11 * 0x10);
    __src = scanner->table + iVar11;
    __n = iVar11 * -0x10 + 0xa0;
  }
  memset(__src,0,__n);
  if (scanner->position == (uchar *)0x0) {
    if (iVar11 == 0) {
      iVar11 = -1;
    }
    scanner->tokens = iVar11;
    scanner->current = __dest;
    if (assert_failed == 0) {
      if ((iVar11 < 10) || (scanner->table + 1 < scanner->table + iVar11)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
        errline = 0xe7;
        elinks_internal((uchar *)"assertion check_scanner(scanner) failed!");
      }
    }
    iVar11 = scanner->tokens;
  }
  else {
    scanner->tokens = iVar11;
    if (__dest != (scanner_token *)0x0) {
      local_20 = (scanner *)(scanner->table + iVar11);
      psVar14 = scanner + 1;
      if ((psVar14 <= local_20) ||
         (pbVar15 = scanner->position, scanner->end < pbVar15 || scanner->end == pbVar15)) {
joined_r0x080864be:
        if ((assert_failed == 0) && (assert_failed = (int)(psVar14 < local_20), assert_failed != 0))
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
          errline = 0xf9;
          elinks_internal((uchar *)"assertion end <= scanner->table + SCANNER_TOKENS failed!");
        }
        iVar11 = (int)local_20 - (int)__dest >> 4;
        scanner->tokens = iVar11;
        scanner->current = __dest;
        if (scanner->end <= scanner->position) {
          scanner->position = (uchar *)0x0;
        }
        if (assert_failed == 0) {
          if ((iVar11 < 10) || (scanner->current + 1 < scanner->table + iVar11)) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
            errline = 0x100;
            elinks_internal((uchar *)"assertion check_scanner(scanner) failed!");
          }
        }
        if (0 < scanner->tokens) {
          if (scanner->current < scanner->table + scanner->tokens) {
            return scanner->current;
          }
          return (scanner_token *)0x0;
        }
        return (scanner_token *)0x0;
      }
      do {
        bVar1 = *pbVar15;
        uVar6 = (uint)bVar1;
        pbVar12 = pbVar15;
        if ((*(byte *)((int)css_scanner_info.scan_table + uVar6 * 4 + 1) & 4) != 0) {
          do {
            pbVar12 = pbVar12 + 1;
            scanner->position = pbVar12;
            if (scanner->end <= pbVar12) goto joined_r0x080864be;
            bVar1 = *pbVar12;
            uVar6 = (uint)bVar1;
          } while ((*(byte *)((int)css_scanner_info.scan_table + uVar6 * 4 + 1) & 4) != 0);
        }
        if ((assert_failed == 0) && (assert_failed = (int)(bVar1 == 0), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
          errline = 0x84;
          elinks_internal((uchar *)"assertion first_char failed!");
        }
        pbVar15 = pbVar12 + 1;
        local_20->end = pbVar12;
        uVar4 = css_scanner_info.scan_table[uVar6];
        if ((uVar4 & 0x100) != 0) {
          puVar13 = (uchar *)(uint)bVar1;
          goto LAB_08086081;
        }
        if (((uVar4 & 2) == 0) && (bVar1 != 0x2e)) {
          if ((uVar4 & 0x10) == 0) {
            if ((uVar4 & 0x200) == 0) {
LAB_08086337:
              puVar13 = (uchar *)0x11c;
            }
            else {
              if (bVar1 == 0x23) {
                if ((css_scanner_info.scan_table[*pbVar15] & 4U) == 0) {
                  if ((css_scanner_info.scan_table[*pbVar15] & 8U) == 0) goto LAB_08086337;
                  pbVar12 = pbVar15;
                  if (pbVar15 < scanner->end) {
                    do {
                      pbVar15 = pbVar12 + 1;
                      if (scanner->end <= pbVar15) break;
                      pbVar10 = pbVar12 + 1;
                      pbVar12 = pbVar15;
                    } while ((*(byte *)(css_scanner_info.scan_table + *pbVar10) & 8) != 0);
                    goto LAB_08086547;
                  }
                  puVar13 = (uchar *)0x10b;
                }
                else {
                  pbVar10 = scanner->end;
                  if (pbVar15 < pbVar10) {
                    do {
                      pbVar15 = pbVar15 + 1;
                      if (pbVar10 <= pbVar15) break;
                    } while ((*(byte *)(css_scanner_info.scan_table + *pbVar15) & 4) != 0);
                  }
                  if (((pbVar15 + ~(uint)pbVar12 == (byte *)0x6) ||
                      (pbVar15 + ~(uint)pbVar12 == (byte *)0x3)) &&
                     ((*(byte *)(css_scanner_info.scan_table + *pbVar15) & 8) == 0)) {
                    puVar13 = (uchar *)0x10c;
                  }
                  else if ((pbVar15 < pbVar10) &&
                          (pbVar12 = pbVar15,
                          (*(byte *)(css_scanner_info.scan_table + *pbVar15) & 8) != 0)) {
                    do {
                      pbVar15 = pbVar12 + 1;
                      if (pbVar10 <= pbVar15) break;
                      pbVar16 = pbVar12 + 1;
                      pbVar12 = pbVar15;
                    } while ((*(byte *)(css_scanner_info.scan_table + *pbVar16) & 8) != 0);
LAB_08086547:
                    puVar13 = (uchar *)0x10b;
                  }
                  else {
                    puVar13 = (uchar *)0x10b;
                  }
                }
                goto LAB_08086081;
              }
              if (bVar1 != 0x40) {
                if (bVar1 == 0x2a) {
                  if (*pbVar15 != 0x3d) goto LAB_0808620e;
                  pbVar15 = pbVar12 + 2;
                  puVar13 = (uchar *)0x11b;
                  goto LAB_08086081;
                }
                if (bVar1 == 0x5e) {
                  if (*pbVar15 != 0x3d) goto LAB_08086337;
                  pbVar15 = pbVar12 + 2;
                  puVar13 = (uchar *)0x119;
                  goto LAB_08086081;
                }
                if (bVar1 == 0x24) {
                  if (*pbVar15 != 0x3d) goto LAB_08086337;
                  pbVar15 = pbVar12 + 2;
                  puVar13 = (uchar *)0x11a;
                  goto LAB_08086081;
                }
                if (bVar1 == 0x7c) {
                  if (*pbVar15 != 0x3d) goto LAB_08086337;
                  pbVar15 = pbVar12 + 2;
                  puVar13 = (uchar *)0x118;
                  goto LAB_08086081;
                }
                if (bVar1 == 0x21) {
                  if (pbVar15 < scanner->end) {
                    bVar1 = *(byte *)((int)css_scanner_info.scan_table + (uint)*pbVar15 * 4 + 1);
                    pbVar12 = pbVar15;
                    while ((pbVar15 = pbVar12, (bVar1 & 4) != 0 &&
                           (pbVar15 = pbVar12 + 1, pbVar15 < scanner->end))) {
                      bVar1 = *(byte *)((int)css_scanner_info.scan_table + (uint)pbVar12[1] * 4 + 1)
                      ;
                      pbVar12 = pbVar15;
                    }
                  }
                  iVar11 = c_strncasecmp((char *)pbVar15,"important",9);
                  if (iVar11 == 0) {
                    pbVar15 = pbVar15 + 9;
                    puVar13 = (uchar *)0x116;
                  }
                  else {
                    puVar13 = (uchar *)0x11c;
                  }
                  goto LAB_08086081;
                }
                if ((bVar1 != 0x27) && (bVar1 != 0x22)) {
                  if ((bVar1 != 0x2d) && (bVar1 != 0x3c)) {
                    if (bVar1 == 0x2f) {
                      if (*pbVar15 == 0x2a) {
                        pbVar15 = pbVar12 + 3;
                        for (pbVar12 = pbVar12 + 2; pbVar12 < scanner->end; pbVar12 = pbVar12 + 1) {
                          if ((*pbVar12 == 0x2a) && (*pbVar15 == 0x2f)) {
                            pbVar15 = pbVar12 + 2;
                            puVar13 = (uchar *)0x11d;
                            goto LAB_08086081;
                          }
                          pbVar15 = pbVar15 + 1;
                        }
                        goto LAB_08086b4e;
                      }
                    }
                    else {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                      errline = 0x157;
                      elinks_internal((uchar *)
                                      "Someone forgot to put code for recognizing tokens which start with \'%c\'."
                                      ,uVar6);
                    }
                    goto LAB_08086337;
                  }
                  bVar2 = *pbVar15;
                  if (bVar2 == 0x2f) {
                    puVar13 = (uchar *)0x0;
                    goto LAB_08086081;
                  }
                  if ((pbVar15 < scanner->end) &&
                     (pbVar12 = pbVar15, *(char *)(css_scanner_info.scan_table + bVar2) < '\0')) {
                    do {
                      pbVar10 = pbVar12;
                      pbVar12 = pbVar10 + 1;
                      if (scanner->end <= pbVar12) break;
                    } while (*(char *)(css_scanner_info.scan_table + *pbVar12) < '\0');
                    if (1 < (int)pbVar12 - (int)pbVar15) {
                      if (bVar1 == 0x3c) {
                        if (bVar2 == 0x21) goto LAB_08086b4e;
                      }
                      else if ((bVar1 == 0x2d) && (*pbVar10 == 0x3e)) {
LAB_08086b4e:
                        pbVar15 = pbVar12;
                        puVar13 = (uchar *)0x11d;
                        goto LAB_08086081;
                      }
                    }
                  }
LAB_080868aa:
                  puVar13 = (uchar *)0x11c;
                  goto LAB_08086081;
                }
                pvVar8 = memchr(pbVar15,uVar6,(int)scanner->end - (int)pbVar15);
                if (pvVar8 == (void *)0x0) goto LAB_080868aa;
                puVar13 = (uchar *)0x103;
                real_length = (int)pvVar8 - (int)pbVar15;
                local_20->end = pbVar15;
                pbVar15 = (byte *)((int)pvVar8 + 1);
                goto LAB_0808644f;
              }
              if ((css_scanner_info.scan_table[*pbVar15] & 0x10U) == 0) goto LAB_08086337;
              pbVar10 = pbVar15;
              if ((pbVar15 < scanner->end) && ((css_scanner_info.scan_table[*pbVar15] & 8U) != 0)) {
                do {
                  pbVar10 = pbVar10 + 1;
                  if (scanner->end <= pbVar10) break;
                } while ((*(byte *)(css_scanner_info.scan_table + *pbVar10) & 8) != 0);
              }
              iVar11 = 0x110;
              pbVar12 = pbVar15;
LAB_080861ac:
              pbVar15 = pbVar10;
              puVar13 = (uchar *)map_scanner_string(scanner,pbVar12,pbVar15,iVar11);
            }
            goto LAB_08086081;
          }
          pbVar10 = scanner->end;
          for (pbVar16 = pbVar15; pbVar16 < pbVar10; pbVar16 = pbVar16 + 1) {
            bVar1 = *pbVar16;
            if ((*(byte *)(css_scanner_info.scan_table + bVar1) & 8) == 0) goto joined_r0x08086208;
          }
          bVar1 = *pbVar16;
joined_r0x08086208:
          pbVar15 = pbVar16;
          if (bVar1 != 0x28) {
LAB_0808620e:
            puVar13 = (uchar *)0x100;
            goto LAB_08086081;
          }
          pbVar15 = pbVar16 + 1;
          local_30 = pbVar15;
          if (pbVar15 < pbVar10) {
            bVar1 = pbVar16[1];
            if (bVar1 == 0x29) goto LAB_08086692;
            uVar6 = (uint)bVar1;
            if ((uVar6 != 0x7d) && (uVar6 != 0x7b)) {
              while (uVar6 != 0x3b) {
                if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                  __s = local_30 + 1;
                  pvVar8 = memchr(__s,uVar6,(int)pbVar10 - (int)local_30);
                  local_30 = (byte *)((int)pvVar8 + 1);
                  if (pvVar8 == (void *)0x0) {
                    local_30 = __s;
                  }
                }
                else {
                  local_30 = local_30 + 1;
                }
                if (pbVar10 <= local_30) goto LAB_0808661d;
                bVar1 = *local_30;
                if (bVar1 == 0x29) goto LAB_08086692;
                uVar6 = (uint)bVar1;
                if ((uVar6 == 0x7d) || (uVar6 == 0x7b)) break;
              }
            }
LAB_08086443:
            real_length = -1;
            puVar13 = (uchar *)0x11c;
          }
          else {
LAB_0808661d:
            if (*local_30 != 0x29) goto LAB_08086443;
LAB_08086692:
            puVar13 = (uchar *)map_scanner_string(scanner,pbVar12,pbVar16,0x10d);
            if (puVar13 == (uchar *)0x10d) {
              real_length = -1;
              pbVar16 = local_30;
LAB_080866cb:
              local_30 = pbVar16;
              if (assert_failed == 0) {
                if ((puVar13 != (uchar *)0x10e) || (*local_30 == 0x28)) {
LAB_080866e7:
                  if ((puVar13 == (uchar *)0x10f) && (*local_30 != 0x29)) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                    errline = 0xd4;
                    elinks_internal((uchar *)
                                    "assertion type != CSS_TOKEN_URL || *string == \')\' failed!");
                    if (assert_failed != 0) {
                      pbVar15 = local_30 + 1;
                      goto LAB_0808644f;
                    }
                  }
                  else {
LAB_08086a20:
                    if ((puVar13 == (uchar *)0x10d) && (*local_30 != 0x29)) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                      errline = 0xd5;
                      elinks_internal((uchar *)
                                      "assertion type != CSS_TOKEN_FUNCTION || *string == \')\' failed!"
                                     );
                      pbVar15 = local_30 + 1;
                      goto LAB_0808644f;
                    }
                  }
                  assert_failed = 0;
                  pbVar15 = local_30 + 1;
                  goto LAB_0808644f;
                }
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                errline = 0xd3;
                elinks_internal((uchar *)
                                "assertion type != CSS_TOKEN_RGB || *string == \'(\' failed!");
                if (assert_failed == 0) goto LAB_08086a20;
              }
            }
            else {
              real_length = -1;
              if (puVar13 != (uchar *)0x10f) goto LAB_080866cb;
              for (; pbVar15 < scanner->end; pbVar15 = pbVar15 + 1) {
                bVar1 = *pbVar15;
                if ((*(byte *)((int)css_scanner_info.scan_table + (uint)bVar1 * 4 + 1) & 4) == 0)
                goto LAB_08086a8c;
              }
              bVar1 = *pbVar15;
LAB_08086a8c:
              pbVar12 = local_30;
              do {
                pbVar10 = pbVar12;
                pbVar12 = pbVar10 + -1;
                if (pbVar12 < scanner->string) {
                  bVar2 = *pbVar12;
                  break;
                }
                bVar2 = *pbVar12;
              } while ((*(byte *)((int)css_scanner_info.scan_table + (uint)bVar2 * 4 + 1) & 4) != 0)
              ;
              if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                pbVar15 = pbVar15 + 1;
              }
              if ((bVar2 == 0x27) || (bVar2 == 0x22)) {
                pbVar12 = pbVar10 + -2;
              }
              real_length = (int)(pbVar12 + (1 - (int)pbVar15));
              local_20->end = pbVar15;
              if (assert_failed == 0) {
                assert_failed = -(real_length >> 0x1f);
                if (assert_failed != 0) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
                  errline = 0xcf;
                  elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                  pbVar16 = local_30;
                  goto LAB_080866cb;
                }
                goto LAB_080866e7;
              }
            }
            pbVar15 = local_30 + 1;
          }
LAB_0808644f:
          local_20->string = puVar13;
          if (real_length < 1) goto LAB_08086086;
        }
        else {
          pbVar12 = scanner->end;
          if (pbVar15 < pbVar12) {
            bVar5 = *pbVar15;
            bVar2 = *(byte *)(css_scanner_info.scan_table + bVar5);
            while ((bVar2 & 2) != 0) {
              pbVar15 = pbVar15 + 1;
              if (pbVar12 <= pbVar15) goto LAB_08086147;
              bVar5 = *pbVar15;
              bVar2 = *(byte *)(css_scanner_info.scan_table + bVar5);
            }
          }
          else {
LAB_08086147:
            bVar5 = *pbVar15;
          }
          if (bVar5 == 0x2e) {
            pbVar15 = pbVar15 + 1;
            bVar5 = *pbVar15;
            if ((*(byte *)(css_scanner_info.scan_table + bVar5) & 2) == 0) goto LAB_08086152;
            if (pbVar15 < pbVar12) {
              do {
                pbVar15 = pbVar15 + 1;
                if (pbVar12 <= pbVar15) {
                  bVar5 = *pbVar15;
                  puVar13 = (uchar *)0x101;
                  goto LAB_08086157;
                }
                bVar5 = *pbVar15;
              } while ((*(byte *)(css_scanner_info.scan_table + bVar5) & 2) != 0);
            }
            puVar13 = (uchar *)0x101;
          }
          else {
LAB_08086152:
            puVar13 = (uchar *)0x11c;
          }
LAB_08086157:
          if (bVar5 == 0x25) {
            if (bVar1 != 0x2e) {
              puVar13 = (uchar *)0x102;
            }
            pbVar15 = pbVar15 + 1;
          }
          else {
            if ((css_scanner_info.scan_table[bVar5] & 0x10U) != 0) {
              pbVar10 = pbVar15;
              if ((pbVar15 < pbVar12) && ((css_scanner_info.scan_table[bVar5] & 8U) != 0)) {
                do {
                  pbVar10 = pbVar10 + 1;
                  if (pbVar12 <= pbVar10) break;
                } while ((*(byte *)(css_scanner_info.scan_table + *pbVar10) & 8) != 0);
              }
              iVar11 = 0x105;
              pbVar12 = pbVar15;
              goto LAB_080861ac;
            }
            puVar13 = (uchar *)0x101;
          }
LAB_08086081:
          local_20->string = puVar13;
LAB_08086086:
          real_length = (int)pbVar15 - (int)local_20->end;
        }
        puVar7 = (uchar *)0x400;
        local_20->current = (scanner_token *)real_length;
        if ((((puVar13 != (uchar *)0x7d) && (puVar7 = (uchar *)0x200, puVar13 != (uchar *)0x7b)) &&
            (puVar7 = (uchar *)0x100, puVar13 != (uchar *)0x3b)) &&
           (puVar7 = (uchar *)0x0, puVar13 == (uchar *)0x29)) {
          puVar7 = (uchar *)0x80;
        }
        local_20->position = puVar7;
        scanner->position = pbVar15;
        if (local_20->string == (uchar *)0x0) {
          scanner->position = (uchar *)0x0;
          local_20 = (scanner *)(local_20[-1].table + 9);
          goto joined_r0x080864be;
        }
        psVar9 = (scanner *)(local_20[-1].table + 9);
        if (local_20->string != (uchar *)0x11d) {
          psVar9 = local_20;
        }
        local_20 = (scanner *)&psVar9->tokens;
        if ((psVar14 <= local_20) || (scanner->end < pbVar15 || scanner->end == pbVar15))
        goto joined_r0x080864be;
      } while( true );
    }
  }
  if ((0 < iVar11) && (scanner->current < scanner->table + iVar11)) {
    return scanner->current;
  }
  return (scanner_token *)0x0;
}



// WARNING: Unknown calling convention

css_stylesheet * init_css_stylesheet(css_stylesheet_importer_T importer,void *import_data)

{
  css_stylesheet *pcVar1;
  css_stylesheet *css;
  
  pcVar1 = (css_stylesheet *)mem_calloc(1,0x14);
  if (pcVar1 != (css_stylesheet *)0x0) {
    pcVar1->import = importer;
    pcVar1->import_data = import_data;
    (pcVar1->selectors).prev = &pcVar1->selectors;
    (pcVar1->selectors).next = &pcVar1->selectors;
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

void done_css_selector(css_selector *selector)

{
  css_selector *selector_00;
  undefined4 *p_00;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  xlist_head *head;
  void *p;
  xlist_head *next;
  
  selector_00 = (css_selector *)(selector->leaves).next;
  while (selector_00 != (css_selector *)&selector->leaves) {
    done_css_selector(selector_00);
    selector_00 = (css_selector *)(selector->leaves).next;
  }
  if (selector->next != (css_selector *)0x0) {
    selector->next->prev = selector->prev;
    selector->prev->next = selector->next;
  }
  p_00 = (undefined4 *)(selector->properties).next;
  for (puVar1 = p_00; (list_head_elinks *)puVar1 != &selector->properties;
      puVar1 = (undefined4 *)*puVar1) {
  }
  for (puVar2 = (undefined4 *)(selector->properties).prev; puVar2 != puVar1;
      puVar2 = (undefined4 *)puVar2[1]) {
  }
  puVar2 = (undefined4 *)*p_00;
  while (puVar3 = puVar2, p_00 != puVar1) {
    puVar3[1] = p_00[1];
    *(undefined4 *)p_00[1] = *p_00;
    mem_free(p_00);
    puVar2 = (undefined4 *)*puVar3;
    p_00 = puVar3;
  }
  if (selector->name != (uchar *)0x0) {
    mem_free(selector->name);
  }
  mem_free(selector);
  return;
}



// WARNING: Unknown calling convention

void done_css_stylesheet(css_stylesheet *css)

{
  css_selector *selector;
  
  selector = (css_selector *)(css->selectors).next;
  while (selector != (css_selector *)&css->selectors) {
    done_css_selector(selector);
    selector = (css_selector *)(css->selectors).next;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void merge_css_selectors(css_selector *sel1,css_selector *sel2)

{
  css_property_type cVar1;
  css_property *pcVar2;
  css_property *pcVar3;
  css_property *origprop;
  css_property *prop;
  undefined *puVar4;
  
  puVar4 = (undefined *)(sel2->properties).next;
  if ((list_head_elinks *)puVar4 != &sel2->properties) {
    origprop = (css_property *)&sel1->properties;
    do {
      pcVar3 = (css_property *)(sel1->properties).next;
      if (pcVar3 != origprop) {
        cVar1 = pcVar3->type;
        while (cVar1 != *(css_property_type *)((int)puVar4 + 8)) {
          pcVar3 = pcVar3->next;
          if (pcVar3 == origprop) goto LAB_08086d08;
          cVar1 = pcVar3->type;
        }
        pcVar3->next->prev = pcVar3->prev;
        pcVar3->prev->next = pcVar3->next;
        mem_free(pcVar3);
      }
LAB_08086d08:
      pcVar3 = (css_property *)mem_alloc(0x18);
      if (pcVar3 != (css_property *)0x0) {
        pcVar3->next = *(css_property **)puVar4;
        pcVar3->prev = *(css_property **)((int)puVar4 + 4);
        pcVar3->type = *(css_property_type *)((int)puVar4 + 8);
        pcVar3->value_type = *(css_property_value_type *)((int)puVar4 + 0xc);
        (pcVar3->value).none = *(void **)((int)puVar4 + 0x10);
        (pcVar3->value).font_attribute.rem = *(text_style_format *)(puVar4 + 0x14);
        pcVar2 = origprop->next;
        pcVar3->prev = origprop;
        pcVar3->next = pcVar2;
        origprop->next = pcVar3;
        pcVar3->next->prev = pcVar3;
      }
      puVar4 = *(undefined **)puVar4;
    } while ((list_head_elinks *)puVar4 != &sel2->properties);
  }
  return;
}



// WARNING: Unknown calling convention

void add_selector_properties(css_selector *selector,list_head_elinks *properties)

{
  void *pvVar1;
  void **ppvVar2;
  css_property *prop;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  
  plVar3 = (list_head_elinks *)properties->next;
  if (plVar3 != properties) {
    plVar4 = &selector->properties;
    do {
      ppvVar2 = (void **)mem_alloc(0x18);
      if (ppvVar2 != (void **)0x0) {
        *ppvVar2 = plVar3->next;
        ppvVar2[1] = plVar3->prev;
        ppvVar2[2] = plVar3[1].next;
        ppvVar2[3] = plVar3[1].prev;
        ppvVar2[4] = plVar3[2].next;
        ppvVar2[5] = plVar3[2].prev;
        pvVar1 = plVar4->next;
        ppvVar2[1] = plVar4;
        *ppvVar2 = pvVar1;
        plVar4->next = ppvVar2;
        *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != properties);
  }
  return;
}



// WARNING: Unknown calling convention

css_selector *
init_css_selector(list_head_elinks *sels,css_selector_type type,uchar *name,int namelen)

{
  css_selector *pcVar1;
  css_selector *p;
  css_selector *selector;
  uchar *puVar2;
  
  p = (css_selector *)mem_calloc(1,0x24);
  if (p != (css_selector *)0x0) {
    p->relation = CSR_ROOT;
    (p->leaves).prev = &p->leaves;
    (p->leaves).next = &p->leaves;
    p->type = type;
    (p->properties).prev = &p->properties;
    (p->properties).next = &p->properties;
    if (name != (uchar *)0x0) {
      if (namelen < 0) {
        namelen = strlen((char *)name);
      }
      puVar2 = memacpy(name,namelen);
      p->name = puVar2;
      if (puVar2 == (uchar *)0x0) {
        mem_free(p);
        return (css_selector *)0x0;
      }
    }
    if (sels != (list_head_elinks *)0x0) {
      pcVar1 = (css_selector *)sels->next;
      p->prev = (css_selector *)sels;
      p->next = pcVar1;
      sels->next = p;
      p->next->prev = p;
    }
  }
  return p;
}



// WARNING: Unknown calling convention

void mirror_css_stylesheet(css_stylesheet *css1,css_stylesheet *css2)

{
  uchar *name;
  css_selector *copy;
  size_t namelen;
  css_selector *selector_00;
  css_selector *selector;
  int *piVar1;
  uint uVar2;
  
  piVar1 = (int *)(css1->selectors).next;
  if ((list_head_elinks *)piVar1 != &css1->selectors) {
    do {
      if (assert_failed == 0) {
        uVar2 = (uint)(css2 == (css_stylesheet *)0x0 || piVar1 == (int *)0x0);
        if (css2 == (css_stylesheet *)0x0 || piVar1 == (int *)0x0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
          errline = 0x94;
          assert_failed = uVar2;
          elinks_internal((uchar *)"assertion css && orig failed!");
          if (assert_failed == 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
            errline = 0x6f;
            assert_failed = uVar2;
            elinks_internal((uchar *)"assertion css && orig failed!");
          }
        }
        else {
          assert_failed = 0;
        }
      }
      name = (uchar *)piVar1[6];
      namelen = strlen((char *)name);
      selector_00 = init_css_selector(&css2->selectors,piVar1[5],name,namelen);
      if (selector_00 != (css_selector *)0x0) {
        add_selector_properties(selector_00,(list_head_elinks *)(piVar1 + 7));
      }
      piVar1 = (int *)*piVar1;
    } while ((list_head_elinks *)piVar1 != &css1->selectors);
  }
  return;
}



// WARNING: Unknown calling convention

css_selector *
find_css_selector(list_head_elinks *sels,css_selector_type type,css_selector_relation rel,
                 uchar *name,int namelen)

{
  css_selector *pcVar1;
  int iVar2;
  css_selector *selector;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(name == (uchar *)0x0 || sels == (list_head_elinks *)0x0),
     name == (uchar *)0x0 || sels == (list_head_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
    errline = 0x24;
    elinks_internal((uchar *)"assertion sels && name failed!");
  }
  pcVar1 = (css_selector *)sels->next;
  do {
    if (pcVar1 == (css_selector *)sels) {
      return (css_selector *)0x0;
    }
    if ((pcVar1->type == type) && (pcVar1->relation == rel)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
      errline = 0x29;
      iVar2 = elinks_strlcasecmp(name,namelen,pcVar1->name,0xffffffff,1);
      if (iVar2 == 0) {
        return pcVar1;
      }
    }
    pcVar1 = pcVar1->next;
  } while( true );
}



// WARNING: Unknown calling convention

css_selector *
get_css_selector(list_head_elinks *sels,css_selector_type type,css_selector_relation rel,uchar *name
                ,int namelen)

{
  css_selector *pcVar1;
  css_selector *selector;
  
  if ((((name != (uchar *)0x0) && (sels != (list_head_elinks *)0x0)) && (namelen != 0)) &&
     (pcVar1 = find_css_selector(sels,type,rel,name,namelen), pcVar1 != (css_selector *)0x0)) {
    return pcVar1;
  }
  pcVar1 = init_css_selector(sels,type,name,namelen);
  if (pcVar1 != (css_selector *)0x0) {
    pcVar1->relation = rel;
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

int css_parse_value(css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  
  if (assert_failed == 0) {
    if (((scanner == (scanner *)0x0) || (value == (css_property_value *)0x0)) ||
       (propinfo == (css_property_info *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x140;
      elinks_internal((uchar *)"assertion scanner && value && propinfo failed!");
      if (assert_failed != 0) goto LAB_08087160;
    }
    assert_failed = (int)(propinfo->parser == (css_property_value_parser_T)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x141;
      elinks_internal((uchar *)"assertion propinfo->parser failed!");
    }
  }
LAB_08087160:
  if (((0 < scanner->tokens) && (scanner->current < scanner->table + scanner->tokens)) &&
     (scanner->current != (scanner_token *)0x0)) {
                    // WARNING: Could not recover jumptable at 0x08087191. Too many branches
                    // WARNING: Treating indirect jump as call
    iVar1 = (*propinfo->parser)(propinfo,value,scanner);
    return iVar1;
  }
  return 0;
}



// WARNING: Unknown calling convention

int css_parse_display_value(css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_DISPLAY, assert_failed = (int)bVar3, bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x125;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_DISPLAY failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 != 0x100) {
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 0x12a;
  iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"inline",6,1);
  if (iVar1 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 300;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"inline-block",0xc,1);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x12e;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"block",5,1);
      if (iVar1 != 0) {
        return 0;
      }
      value->color = 1;
      goto LAB_080872b8;
    }
  }
  value->none = (void *)0x0;
LAB_080872b8:
  skip_scanner_tokens(scanner,0x100,0);
  return 1;
}



// WARNING: Unknown calling convention

int css_parse_white_space_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = (int)bVar3, bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x10b;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 == 0x100) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x110;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"pre",3,1);
    if (iVar1 == 0) {
      value->color = value->color | 0x20;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x113;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"normal",6,1);
      if (iVar1 != 0) goto LAB_08087406;
      (value->font_attribute).rem = (value->font_attribute).rem | AT_PREFORMATTED;
    }
    skip_scanner_tokens(scanner,0x100,0);
    iVar1 = 1;
  }
  else {
LAB_08087406:
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int css_parse_text_decoration_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = (int)bVar3, bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xf0;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 == 0x100) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xf6;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"underline",9,1);
    if (iVar1 == 0) {
      value->color = value->color | 4;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xf9;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"none",4,1);
      if (iVar1 != 0) goto LAB_08087566;
      (value->font_attribute).rem = (value->font_attribute).rem | AT_UNDERLINE;
    }
    skip_scanner_tokens(scanner,0x100,0);
    iVar1 = 1;
  }
  else {
LAB_08087566:
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int css_parse_text_align_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_TEXT_ALIGN, assert_failed = (int)bVar3, bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xd0;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_TEXT_ALIGN failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 == 0x100) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xd4;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"left",4,1);
    if (iVar1 == 0) {
      value->none = (void *)0x0;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xd7;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"right",5,1);
      if (iVar1 == 0) {
        value->color = 2;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 0xda;
        iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"center",6,1);
        if (iVar1 == 0) {
          value->color = 1;
        }
        else {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
          errline = 0xdd;
          iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"justify",7,1);
          if (iVar1 != 0) goto LAB_080876c5;
          value->color = 3;
        }
      }
    }
    skip_scanner_tokens(scanner,0x100,0);
    iVar1 = 1;
  }
  else {
LAB_080876c5:
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int css_parse_font_style_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  scanner_token *psVar2;
  bool bVar3;
  
  if ((scanner->tokens < 1) ||
     (psVar2 = scanner->current, scanner->table + scanner->tokens <= psVar2)) {
    psVar2 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar3 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = (int)bVar3, bVar3)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x7f;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar2->type;
  }
  else {
    iVar1 = psVar2->type;
  }
  if (iVar1 != 0x100) {
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 0x83;
  iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"italic",6,1);
  if (iVar1 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x84;
    iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,(uchar *)"oblique",7,1);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0x87;
      iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"underline",9,1);
      if (iVar1 == 0) {
        value->color = value->color | 4;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 0x8a;
        iVar1 = elinks_strlcasecmp(psVar2->string,psVar2->length,"normal",6,1);
        if (iVar1 != 0) {
          return 0;
        }
        (value->font_attribute).rem = (value->font_attribute).rem | AT_ITALIC;
      }
      goto LAB_08087935;
    }
  }
  value->color = value->color | 2;
LAB_08087935:
  skip_scanner_tokens(scanner,0x100,0);
  return 1;
}



// WARNING: Unknown calling convention

int css_parse_font_weight_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  long lVar2;
  int weight;
  scanner_token *token;
  scanner_token *psVar3;
  bool bVar4;
  uchar *local_20 [4];
  
  if ((scanner->tokens < 1) ||
     (psVar3 = scanner->current, scanner->table + scanner->tokens <= psVar3)) {
    psVar3 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar4 = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE, assert_failed = (int)bVar4, bVar4)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x9f;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    iVar1 = psVar3->type;
  }
  else {
    iVar1 = psVar3->type;
  }
  if (iVar1 != 0x100) {
    if ((iVar1 != 0x101) ||
       (lVar2 = strtol((char *)psVar3->string,(char **)local_20,10), psVar3->string == local_20[0]))
    {
      return 0;
    }
    skip_scanner_tokens(scanner,0x101,0);
    if ((99 < lVar2) && ((900 < lVar2 || (699 < lVar2)))) {
      value->color = value->color | 1;
      return 1;
    }
    return 1;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 0xa2;
  iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,(uchar *)"bolder",6,1);
  if (iVar1 == 0) {
LAB_08087b5e:
    value->color = value->color | 1;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0xa5;
    iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,(uchar *)"lighter",7,1);
    if (iVar1 != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xa8;
      iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,"bold",4,1);
      if (iVar1 == 0) goto LAB_08087b5e;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 0xab;
      iVar1 = elinks_strlcasecmp(psVar3->string,psVar3->length,"normal",6,1);
      if (iVar1 != 0) {
        return 0;
      }
    }
    (value->font_attribute).rem = (value->font_attribute).rem | AT_BOLD;
  }
  skip_scanner_tokens(scanner,0x100,0);
  return 1;
}



// WARNING: Unknown calling convention

int css_parse_color_value(css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  scanner_token *psVar1;
  uint skipto;
  int iVar2;
  uint uVar3;
  scanner_token *psVar4;
  int iVar5;
  int shift;
  int part;
  int iVar6;
  uchar paskynator;
  byte bVar7;
  scanner_token *token;
  scanner_token *psVar8;
  bool bVar9;
  uchar *local_20 [4];
  
  if ((scanner->tokens < 1) ||
     (psVar8 = scanner->current, scanner->table + scanner->tokens <= psVar8)) {
    psVar8 = (scanner_token *)0x0;
  }
  if ((assert_failed == 0) &&
     (bVar9 = propinfo->value_type != CSS_VT_COLOR, assert_failed = (int)bVar9, bVar9)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x1e;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_COLOR failed!");
  }
  iVar2 = psVar8->type;
  if (iVar2 != 0x10e) {
    if (((iVar2 == 0x10c) || (iVar2 == 0x100)) &&
       (iVar2 = decode_color(psVar8->string,psVar8->length,&value->color), -1 < iVar2)) {
      iVar2 = psVar8->type;
      iVar6 = 0x400;
      if (((iVar2 != 0x7d) && (iVar6 = 0x200, iVar2 != 0x7b)) &&
         ((iVar6 = 0x100, iVar2 != 0x3b && (iVar6 = 0, iVar2 == 0x29)))) {
        iVar6 = 0x80;
      }
      skip_scanner_tokens(scanner,iVar2,iVar6);
      return 1;
    }
    return 0;
  }
  if (0 < scanner->tokens) {
    psVar1 = scanner->current;
    psVar8 = scanner->table + scanner->tokens;
    if (psVar1 < psVar8) {
      psVar4 = psVar1 + 1;
      scanner->current = psVar4;
      if (psVar1 + 2 < psVar8) {
        if (psVar8 <= psVar4) {
          return 1;
        }
      }
      else {
        psVar4 = (*scanner->info->scan)(scanner);
      }
      if (psVar4 != (scanner_token *)0x0) {
        iVar2 = 0x10;
        do {
          local_20[0] = psVar4->string;
          bVar7 = (-(iVar2 == 0) & 0xfdU) + 0x2c;
          if (1 < psVar4->type - 0x101U) {
            return 0;
          }
          if (scanner->tokens < 1) {
            return 0;
          }
          psVar8 = scanner->current;
          if (scanner->table + scanner->tokens <= psVar8) {
            return 0;
          }
          if (scanner->table + scanner->tokens <= psVar8 + 1) {
            return 0;
          }
          skipto = psVar8[1].type;
          if (skipto != bVar7) {
            return 0;
          }
          iVar6 = strtol((char *)psVar4->string,(char **)local_20,10);
          if (psVar4->string == local_20[0]) {
            return 0;
          }
          if (psVar4->type == 0x102) {
            iVar5 = 100;
            if (iVar6 < 0x65) {
              iVar5 = iVar6;
            }
            iVar6 = 0;
            if (-1 < iVar5) {
              iVar6 = iVar5;
            }
            iVar6 = (iVar6 * 0xff) / 100;
LAB_08087e2e:
            iVar5 = 0xff;
            if (iVar6 < 0x100) {
              iVar5 = iVar6;
            }
            uVar3 = iVar5 << ((byte)iVar2 & 0x1f);
          }
          else {
            uVar3 = 0;
            if (-1 < iVar6) goto LAB_08087e2e;
          }
          value->color = value->color | uVar3;
          iVar6 = 0;
          if (bVar7 == 0x29) {
            iVar6 = 0x80;
          }
          psVar4 = skip_scanner_tokens(scanner,skipto,iVar6);
          iVar2 = iVar2 + -8;
        } while ((psVar4 != (scanner_token *)0x0) && (-1 < iVar2));
      }
    }
  }
  return 1;
}



// WARNING: Unknown calling convention

int css_parse_background_value
              (css_property_info *propinfo,css_property_value *value,scanner *scanner)

{
  int iVar1;
  scanner_token *token;
  scanner_token *psVar2;
  int iVar3;
  int success;
  int iVar4;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(propinfo->value_type != CSS_VT_COLOR), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 0x60;
    elinks_internal((uchar *)"assertion propinfo->value_type == CSS_VT_COLOR failed!");
  }
  iVar3 = scanner->tokens;
  iVar4 = 0;
LAB_08087fd8:
  while( true ) {
    if ((((iVar3 < 1) || (psVar2 = scanner->current, scanner->table + iVar3 <= psVar2)) ||
        (iVar1 = psVar2->type, iVar1 == 0x7d)) || ((iVar1 == 0x7b || (iVar1 == 0x3b)))) {
      return iVar4;
    }
    if (iVar1 == 0x2c) break;
    iVar3 = css_parse_color_value(propinfo,value,scanner);
    if (iVar3 == 0) goto LAB_08088050;
    iVar4 = iVar4 + 1;
    iVar3 = scanner->tokens;
  }
  goto LAB_0808800a;
LAB_08088050:
  iVar3 = scanner->tokens;
  if (iVar3 < 1) {
    return iVar4;
  }
  psVar2 = scanner->current;
  if (psVar2 < scanner->table + iVar3) {
LAB_0808800a:
    scanner->current = psVar2 + 1;
    if (scanner->table + iVar3 <= psVar2 + 2) {
      (*scanner->info->scan)(scanner);
      iVar3 = scanner->tokens;
    }
  }
  goto LAB_08087fd8;
}



// WARNING: Unknown calling convention

screen_char * realloc_line(document *document,int x,int y)

{
  line *plVar1;
  line *line;
  screen_char *psVar2;
  int iVar3;
  size_t newsize;
  uint uVar4;
  size_t size;
  size_t oldsize;
  uint uVar5;
  
  plVar1 = realloc_lines(document,y);
  if (plVar1 == (line *)0x0) {
LAB_080880f0:
    psVar2 = (screen_char *)0x0;
  }
  else {
    if (plVar1->length < x) {
      uVar5 = plVar1->length + 0xfU & 0xfffffff0;
      uVar4 = x + 0xfU & 0xfffffff0;
      if (uVar5 < uVar4) {
        size = uVar4 * 8;
        psVar2 = (screen_char *)mem_realloc(plVar1->chars,size);
        if (psVar2 == (screen_char *)0x0) goto LAB_080880f0;
        plVar1->chars = psVar2;
        memset(psVar2 + uVar5,0,size + uVar5 * -8);
      }
      psVar2 = plVar1->chars;
      if (psVar2 == (screen_char *)0x0) goto LAB_080880f0;
      iVar3 = plVar1->length;
      if (iVar3 < x) {
        while( true ) {
          psVar2[iVar3].data = 0x20;
          iVar3 = plVar1->length + 1;
          plVar1->length = iVar3;
          if (x <= iVar3) break;
          psVar2 = plVar1->chars;
        }
      }
      if (document->width < x) {
        document->width = x;
      }
    }
    psVar2 = plVar1->chars;
  }
  return psVar2;
}



// WARNING: Unknown calling convention

void render_dom_text(dom_renderer *renderer,screen_char *template,uchar *string,int length)

{
  byte bVar1;
  byte bVar2;
  document *document;
  conv_table *convert_table;
  convert_string_mode mode_00;
  uchar uVar3;
  uchar uVar4;
  undefined uVar5;
  uchar *puVar6;
  int linelen;
  screen_char *psVar7;
  void **ppvVar8;
  unicode_val_T data;
  int iVar9;
  uchar *end;
  int step;
  uint uVar10;
  convert_string_mode mode;
  void *pvVar11;
  void *pvVar12;
  uchar *puVar13;
  unicode_val_T uVar14;
  uchar *newline;
  uchar *puVar15;
  int tab_width;
  uint uVar16;
  int local_3c;
  uchar *local_38;
  int local_34;
  uchar *local_30;
  byte *local_24;
  uchar *local_20 [4];
  
  if (length < 1) {
    return;
  }
  end = string + length;
  local_30 = string;
  if (end <= string) goto LAB_08088248;
  do {
    uVar10 = (uint)(*local_30 == '\r');
    puVar15 = local_30 + uVar10;
    puVar6 = local_30;
    if (*puVar15 == '\n') {
LAB_080881f8:
      local_38 = puVar6 + -(int)local_30;
      puVar15 = puVar6 + uVar10 + 1;
LAB_08088204:
      if (local_38 != (uchar *)0x0) goto LAB_08088250;
    }
    else {
      if (uVar10 == 0) {
        do {
          puVar6 = puVar6 + 1;
          if (end <= puVar6) goto LAB_08088248;
          uVar10 = (uint)(*puVar6 == '\r');
          puVar15 = puVar6 + uVar10;
          if (*puVar15 == '\n') goto LAB_080881f8;
        } while (uVar10 == 0);
        local_38 = puVar6 + -(int)local_30;
        goto LAB_08088204;
      }
      local_38 = (uchar *)0x0;
    }
    while( true ) {
      if (puVar15 != (uchar *)0x0) {
        local_38 = puVar15 + -(int)local_30;
        renderer->canvas_y = renderer->canvas_y + 1;
        renderer->canvas_x = 0;
      }
      length = length - (int)local_38;
      if (length < 1) {
        return;
      }
      local_30 = local_30 + (int)local_38;
      end = local_30 + length;
      if (local_30 < end) break;
LAB_08088248:
      puVar15 = (uchar *)0x0;
      local_38 = (uchar *)length;
LAB_08088250:
      document = renderer->document;
      convert_table = renderer->convert_table;
      local_20[0] = local_38;
      mode_00 = renderer->convert_mode;
      bVar1 = (document->options).field_0x5c;
      if (assert_failed == 0) {
        if ((template == (screen_char *)0x0) || (local_30 == (uchar *)0x0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x103;
          elinks_internal((uchar *)"assertion renderer && template && string && length failed!");
        }
        else {
          assert_failed = 0;
        }
      }
      puVar6 = convert_string_elinks
                         (convert_table,local_30,(int)local_20[0],(document->options).cp,mode_00,
                          (int *)local_20,(_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (puVar6 != (uchar *)0x0) {
        psVar7 = realloc_line(document,(int)(local_20[0] + renderer->canvas_x),renderer->canvas_y);
        puVar13 = local_20[0];
        if (psVar7 == (screen_char *)0x0) {
          mem_free(puVar6);
        }
        else {
          ppvVar8 = (void **)mem_alloc(0x18);
          if (ppvVar8 != (void **)0x0) {
            pvVar12 = (void *)renderer->canvas_y;
            pvVar11 = (void *)renderer->canvas_x;
            if ((int)pvVar11 < 0) {
              pvVar11 = (void *)0x0;
            }
            ppvVar8[2] = pvVar11;
            if ((int)pvVar12 < 0) {
              pvVar12 = (void *)0x0;
            }
            ppvVar8[3] = pvVar12;
            ppvVar8[5] = (void *)0x1;
            if ((int)puVar13 < 0) {
              puVar13 = (uchar *)0x0;
            }
            ppvVar8[4] = puVar13;
            *ppvVar8 = (renderer->document->nodes).next;
            ppvVar8[1] = &renderer->document->nodes;
            (renderer->document->nodes).next = ppvVar8;
            *(void ***)((int)*ppvVar8 + 4) = ppvVar8;
          }
          puVar13 = puVar6 + (int)local_20[0];
          if (0 < (int)local_20[0]) {
            local_3c = 1;
            local_34 = 0;
            do {
              local_24 = puVar6 + local_34;
              bVar2 = *local_24;
              if (bVar2 == 9) {
                uVar10 = renderer->canvas_x;
                template->data = 0x20;
                uVar16 = ~uVar10 & 7;
                psVar7 = realloc_line(document,(int)(local_20[0] + ((uVar16 + uVar10) - local_34)),
                                      renderer->canvas_y);
                if (psVar7 == (screen_char *)0x0) goto LAB_080883ed;
                if (uVar16 == 0) {
                  iVar9 = renderer->canvas_x;
                  local_3c = 1;
                }
                else {
                  iVar9 = renderer->canvas_x;
                  do {
                    uVar16 = uVar16 - 1;
                    psVar7 = renderer->document->data[renderer->canvas_y].chars + iVar9;
                    psVar7->data = template->data;
                    uVar3 = template->color[0];
                    uVar4 = template->color[1];
                    uVar5 = template->field_0x7;
                    psVar7->attr = template->attr;
                    psVar7->color[0] = uVar3;
                    psVar7->color[1] = uVar4;
                    psVar7->field_0x7 = uVar5;
                    iVar9 = renderer->canvas_x + 1;
                    renderer->canvas_x = iVar9;
                  } while (0 < (int)uVar16);
                  local_3c = 1;
                }
              }
              else {
                if ((bVar1 >> 4 & 1) == 0) {
                  if ((bVar2 == 0x7f) || (bVar2 < 0x20)) {
                    uVar14 = 0x2e;
                  }
                  else {
                    uVar14 = (unicode_val_T)bVar2;
                  }
                  template->data = uVar14;
                }
                else {
                  local_3c = utf8charlen(local_24);
                  uVar14 = utf8_to_unicode(&local_24,puVar13);
                  template->data = uVar14;
                  iVar9 = unicode_to_cell(uVar14);
                  if (iVar9 == 2) {
                    psVar7 = renderer->document->data[renderer->canvas_y].chars + renderer->canvas_x
                    ;
                    psVar7->data = template->data;
                    uVar3 = template->color[0];
                    uVar4 = template->color[1];
                    uVar5 = template->field_0x7;
                    psVar7->attr = template->attr;
                    psVar7->color[0] = uVar3;
                    psVar7->color[1] = uVar4;
                    psVar7->field_0x7 = uVar5;
                    renderer->canvas_x = renderer->canvas_x + 1;
                    template->data = 0xfffffffd;
                    iVar9 = renderer->canvas_x;
                    goto LAB_080883f0;
                  }
                }
LAB_080883ed:
                iVar9 = renderer->canvas_x;
              }
LAB_080883f0:
              psVar7 = renderer->document->data[renderer->canvas_y].chars + iVar9;
              psVar7->data = template->data;
              uVar3 = template->color[0];
              uVar4 = template->color[1];
              uVar5 = template->field_0x7;
              psVar7->attr = template->attr;
              psVar7->color[0] = uVar3;
              psVar7->color[1] = uVar4;
              psVar7->field_0x7 = uVar5;
              local_34 = local_34 + local_3c;
              renderer->canvas_x = renderer->canvas_x + 1;
            } while (local_34 < (int)local_20[0]);
          }
          mem_free(puVar6);
        }
      }
    }
  } while( true );
}



// WARNING: Unknown calling convention

void render_dom_flush(dom_renderer *renderer,uchar *string)

{
  uchar *puVar1;
  uchar *puVar2;
  int length;
  
  puVar2 = renderer->position;
  if (assert_failed == 0) {
    if ((puVar2 < renderer->source) || (renderer->end <= puVar2 && puVar2 != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,renderer->position,renderer->position);
      if (assert_failed != 0) goto LAB_08088628;
      puVar1 = renderer->source;
    }
    else {
      puVar1 = renderer->source;
    }
    if ((string < puVar1) || (renderer->end <= string && string != renderer->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer->source,renderer->end,string,string);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08088628:
  if (0 < (int)string - (int)puVar2) {
    render_dom_text(renderer,renderer->styles + 3,renderer->position,(int)string - (int)puVar2);
    renderer->position = string;
    if (assert_failed == 0) {
      if ((string < renderer->source) || (renderer->end <= string && string != renderer->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer->source,renderer->end,renderer->position,renderer->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

dom_code render_dom_element_end_source(dom_stack *stack,dom_node *node,void *data)

{
  dom_renderer *renderer_00;
  dom_stack_state *pdVar1;
  size_t sVar2;
  dom_stack_context *pdVar3;
  size_t sVar4;
  uchar *string_00;
  int length;
  uchar *puVar5;
  uchar *string;
  int iVar6;
  dom_renderer *renderer;
  size_t object_size;
  
  iVar6 = assert_failed;
  renderer_00 = (dom_renderer *)stack->current->data;
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  pdVar1 = stack->states;
  sVar2 = stack->depth;
  pdVar3 = *stack->contexts;
  sVar4 = pdVar3->info->object_size;
  puVar5 = (uchar *)0x0;
  if (sVar4 != 0) {
    if ((iVar6 == 0) &&
       (assert_failed = (int)(pdVar3->state_objects == (uchar *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
      errline = 0xc6;
      elinks_internal((uchar *)"assertion context->state_objects failed!");
      iVar6 = assert_failed;
    }
    puVar5 = pdVar3->state_objects + sVar4 * pdVar1[sVar2 - 1].depth;
  }
  string_00 = *(uchar **)(puVar5 + 0x14);
  length = *(int *)(puVar5 + 0x10);
  if (iVar6 == 0) {
    if (((node == (dom_node *)0x0) || (renderer_00 == (dom_renderer *)0x0)) ||
       (renderer_00->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x242;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if ((length != 0) && (string_00 != (uchar *)0x0)) {
    if ((renderer_00->source <= string_00) &&
       (puVar5 = string_00 + length, puVar5 < renderer_00->end || puVar5 == renderer_00->end)) {
      render_dom_flush(renderer_00,string_00);
      renderer_00->position = puVar5;
      if (assert_failed == 0) {
        if ((puVar5 < renderer_00->source) ||
           (renderer_00->end <= puVar5 && puVar5 != renderer_00->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x24a;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer_00->source,renderer_00->end,renderer_00->position,
                          renderer_00->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
    render_dom_text(renderer_00,renderer_00->styles + node->type,string_00,length);
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_string * get_rss_text(dom_node *node,rss_element_type type)

{
  dom_node *pdVar1;
  
  pdVar1 = get_dom_node_child(node,DOM_NODE_ELEMENT,(int16_t)type);
  if (pdVar1 != (dom_node *)0x0) {
    pdVar1 = get_dom_node_child(pdVar1,DOM_NODE_TEXT,0);
    if (pdVar1 != (dom_node *)0x0) {
      return &pdVar1->string;
    }
  }
  return (dom_string *)0x0;
}



// WARNING: Unknown calling convention

dom_code dom_rss_pop_element(dom_stack *stack,dom_node *node,void *data)

{
  ushort uVar1;
  uint16_t uVar2;
  void *pvVar3;
  dom_node *parent;
  uint uVar4;
  dom_node *pdVar5;
  dom_node_list **list;
  dom_renderer *renderer;
  
  pvVar3 = stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (pvVar3 == (void *)0x0)) || (*(int *)((int)pvVar3 + 4) == 0))
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x338;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if (8 < (node->data).element.type) {
    return DOM_CODE_OK;
  }
  uVar4 = 1 << ((byte)(node->data).element.type & 0x1f);
  if ((uVar4 & 0x1ca) == 0) {
    if ((uVar4 & 0x20) == 0) {
      return DOM_CODE_OK;
    }
    if ((*(void **)((int)pvVar3 + 0xa4) != (void *)0x0) && (*(int *)((int)pvVar3 + 0xa0) != 0)) {
      mem_free(*(void **)((int)pvVar3 + 0xa4));
      *(undefined4 *)((int)pvVar3 + 0xa4) = 0;
      *(undefined4 *)((int)pvVar3 + 0xa0) = 0;
    }
    *(undefined4 *)((int)pvVar3 + 0x98) = 0;
    return DOM_CODE_OK;
  }
  if (*(int *)((int)pvVar3 + 0xa4) == 0) {
    return DOM_CODE_OK;
  }
  if (*(int *)((int)pvVar3 + 0xa0) == 0) {
    return DOM_CODE_OK;
  }
  pdVar5 = node->parent;
  if (pdVar5 == (dom_node *)0x0) {
    return DOM_CODE_OK;
  }
  if (pdVar5 != *(dom_node **)((int)pvVar3 + 0x98)) {
    return DOM_CODE_OK;
  }
  parent = *(dom_node **)((int)pvVar3 + 0x9c);
  if (parent != node) {
    return DOM_CODE_OK;
  }
  uVar1 = pdVar5->type;
  uVar2 = node->type;
  if (uVar1 == 7) {
    list = (dom_node_list **)&(pdVar5->data).notation.system_id.string;
    if (uVar2 == 2) goto LAB_08088a5c;
  }
  else if (uVar1 < 8) {
    if (uVar1 == 1) {
      list = (dom_node_list **)&pdVar5->data;
      if (uVar2 == 2) {
        list = (dom_node_list **)&(pdVar5->data).attribute.value.string;
      }
      goto LAB_08088a5c;
    }
  }
  else {
    if (uVar1 == 9) {
LAB_08088ab3:
      list = (dom_node_list **)&(pdVar5->data).attribute.value.string;
      goto LAB_08088a5c;
    }
    if (uVar1 == 10) {
      list = (dom_node_list **)&pdVar5->data;
      if (uVar2 == 6) goto LAB_08088a5c;
      if (uVar2 == 0xc) goto LAB_08088ab3;
    }
  }
  list = (dom_node_list **)0x0;
LAB_08088a5c:
  done_dom_node_list(*list);
  if (((*(int *)((int)pvVar3 + 0xa4) != 0) && (*(int *)((int)pvVar3 + 0xa0) != 0)) &&
     (pdVar5 = init_dom_node_at(parent,DOM_NODE_TEXT,(dom_string *)((int)pvVar3 + 0xa0),-1),
     pdVar5 == (dom_node *)0x0)) {
    if (*(void **)((int)pvVar3 + 0xa4) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar3 + 0xa4));
    }
    *(undefined4 *)((int)pvVar3 + 0xa4) = 0;
    *(undefined4 *)((int)pvVar3 + 0xa0) = 0;
  }
  *(undefined4 *)((int)pvVar3 + 0x9c) = 0;
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code dom_rss_push_element(dom_stack *stack,dom_node *node,void *data)

{
  void *pvVar1;
  uint uVar2;
  dom_renderer *renderer;
  
  pvVar1 = stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (pvVar1 == (void *)0x0)) || (*(int *)((int)pvVar1 + 4) == 0))
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x309;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  if ((node->data).element.type < 9) {
    uVar2 = 1 << ((byte)(node->data).element.type & 0x1f);
    if ((uVar2 & 0x1ca) == 0) {
      if ((uVar2 & 0x20) == 0) {
        if ((((uVar2 & 4) != 0) && (stack->depth == 3)) && (*(int *)((int)pvVar1 + 0x90) == 0)) {
          *(dom_node **)((int)pvVar1 + 0x90) = node;
        }
      }
      else if (*(int *)((int)pvVar1 + 0x98) == 0) {
        add_to_dom_node_list((dom_node_list **)((int)pvVar1 + 0x94),node,-1);
        *(dom_node **)((int)pvVar1 + 0x98) = node;
      }
    }
    else if ((node->parent != (dom_node *)0x0) &&
            (node->parent == *(dom_node **)((int)pvVar1 + 0x9c))) {
      *(dom_node **)((int)pvVar1 + 0x9c) = node;
    }
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

void render_dom_document(cache_entry *cached,document *document,string *buffer)

{
  undefined4 *puVar1;
  undefined *puVar2;
  dom_string *pdVar3;
  dom_string *name;
  css_selector *selector;
  screen_char_attr attr;
  uint uVar4;
  sgml_parser *parser_00;
  sgml_parser *parser;
  css_selector *pcVar5;
  sgml_document_type doctype;
  int iVar6;
  conv_table *convert_table;
  css_property *property;
  undefined4 *puVar7;
  uchar *head;
  uchar *head_00;
  dom_node_type type;
  dom_node_type type_00;
  uchar *string;
  dom_renderer *pdVar8;
  byte bVar9;
  color_T local_e8;
  int local_e4;
  color_T local_e0;
  dom_renderer renderer;
  color_pair colors;
  dom_string uri;
  dom_config config;
  
  bVar9 = 0;
  head_00 = cached->head;
  if (head_00 == (uchar *)0x0) {
    head_00 = "";
  }
  uri.string = cached->uri->string;
  uri.length = strlen((char *)uri.string);
  renderer.convert_table =
       get_convert_table(head_00,(document->options).cp,(document->options).assume_cp,&document->cp,
                         &document->cp_status,(document->options).hard_assume);
  pdVar8 = &renderer;
  for (iVar6 = 0x2a; iVar6 != 0; iVar6 = iVar6 + -1) {
    pdVar8->doctype = SGML_DOCTYPE_DOCBOOK;
    pdVar8 = (dom_renderer *)((int)pdVar8 + (uint)bVar9 * -8 + 4);
  }
  renderer.document = document;
  renderer.convert_mode = ~-(uint)(((document->options).field_0x45 & 0x40) == 0) & 3;
  renderer.source = buffer->source;
  renderer.end = renderer.source + buffer->length;
  renderer.base_uri = document->uri;
  ((renderer.base_uri)->object).refcount = ((renderer.base_uri)->object).refcount + 1;
  local_e4 = 0;
  type_00 = DOM_NODE_UNKNOWN;
  renderer.position = renderer.source;
  do {
    local_e8 = (document->options).default_style.bg;
    local_e0 = (document->options).default_style.fg;
    pdVar3 = get_dom_node_type_name(type_00);
    if (init_dom_renderer::lexical_block_0::i_want_struct_module_for_dom == 0) {
      init_dom_renderer::lexical_block_0::i_want_struct_module_for_dom = 1;
      css_parse_stylesheet
                (&default_stylesheet,(uri *)0x0,
                 "document\t{ color: yellow } element\t{ color: lightgreen } entity-reference { color: red } proc-instruction { color: red } attribute\t{ color: magenta } comment\t{ color: aqua } cdata-section\t{ color: orange2 } "
                 ,"");
    }
    if ((((pdVar3 == (dom_string *)0x0) || (pdVar3->string == (uchar *)0x0)) ||
        (pdVar3->length == 0)) ||
       (pcVar5 = find_css_selector(&default_stylesheet.selectors,CST_ELEMENT,CSR_ROOT,pdVar3->string
                                   ,pdVar3->length), pcVar5 == (css_selector *)0x0)) {
LAB_08088d5d:
      selector._0_1_ = 0;
      attr._0_1_ = (byte)selector;
    }
    else {
      puVar7 = (undefined4 *)(pcVar5->properties).next;
      if ((list_head_elinks *)puVar7 == &pcVar5->properties) goto LAB_08088d5d;
      attr._0_1_ = 0;
      do {
        switch(puVar7[2]) {
        case 1:
        case 2:
          if (puVar7[3] != 1) goto switchD_08088f11_caseD_0;
          local_e8 = puVar7[4];
          puVar7 = (undefined4 *)*puVar7;
          break;
        case 3:
          local_e0 = puVar7[4];
          puVar7 = (undefined4 *)*puVar7;
          break;
        case 5:
          if ((*(byte *)(puVar7 + 4) & 4) != 0) {
            attr._0_1_ = (byte)attr | 0x20;
          }
          puVar1 = puVar7 + 4;
          puVar7 = (undefined4 *)*puVar7;
          if ((*(byte *)puVar1 & 2) != 0) {
            attr._0_1_ = (byte)attr | 0x10;
          }
          break;
        case 6:
          if ((*(byte *)(puVar7 + 4) & 1) != 0) {
            attr._0_1_ = (byte)attr | 8;
          }
        default:
switchD_08088f11_caseD_0:
          puVar7 = (undefined4 *)*puVar7;
          break;
        case 8:
          puVar1 = puVar7 + 4;
          puVar7 = (undefined4 *)*puVar7;
          if ((*(byte *)puVar1 & 4) != 0) {
            attr._0_1_ = (byte)attr | 0x20;
          }
        }
      } while ((list_head_elinks *)puVar7 != &pcVar5->properties);
    }
    colors.background = local_e8;
    colors.foreground = local_e0;
    renderer.styles[type_00].attr = (byte)attr;
    renderer.styles[type_00].data = 0x20;
    set_term_color(renderer.styles + type_00,&colors,(document->options).color_flags,
                   (document->options).color_mode);
    local_e4 = local_e4 + 1;
    type_00 = type_00 + DOM_NODE_ELEMENT;
  } while (local_e4 != 0xd);
  document->bgcolor = (document->options).default_style.bg;
  uVar4 = is_cp_utf8((document->options).cp);
  bVar9 = (document->options).field_0x45;
  (document->options).field_0x5c = (document->options).field_0x5c & 0xef | (byte)((uVar4 & 1) << 4);
  iVar6 = c_strcasecmp("application/rss+xml",(char *)cached->content_type);
  if (iVar6 == 0) {
    renderer.doctype = SGML_DOCTYPE_RSS;
    doctype = SGML_DOCTYPE_RSS;
  }
  else {
    iVar6 = c_strcasecmp("application/docbook+xml",(char *)cached->content_type);
    if (iVar6 == 0) {
      renderer.doctype = SGML_DOCTYPE_DOCBOOK;
      doctype = SGML_DOCTYPE_DOCBOOK;
    }
    else {
      iVar6 = c_strcasecmp("application/xbel+xml",(char *)cached->content_type);
      if (((iVar6 == 0) ||
          (iVar6 = c_strcasecmp("application/x-xbel",(char *)cached->content_type), iVar6 == 0)) ||
         (iVar6 = c_strcasecmp("application/xbel",(char *)cached->content_type), iVar6 == 0)) {
        renderer.doctype = SGML_DOCTYPE_XBEL;
        doctype = SGML_DOCTYPE_XBEL;
      }
      else {
        if (assert_failed == 0) {
          iVar6 = c_strcasecmp("text/html",(char *)cached->content_type);
          if ((iVar6 == 0) ||
             (iVar6 = c_strcasecmp("application/xhtml+xml",(char *)cached->content_type), iVar6 == 0
             )) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 0x3fa;
            elinks_internal((uchar *)
                            "assertion !c_strcasecmp(\"text/html\", cached->content_type) || !c_strcasecmp(\"application/xhtml+xml\", cached->content_type) failed: Couldn\'t resolve doctype \'%s\'"
                            ,cached->content_type);
          }
        }
        renderer.doctype = SGML_DOCTYPE_HTML;
        doctype = SGML_DOCTYPE_HTML;
      }
    }
  }
  parser_00 = init_sgml_parser((bVar9 >> 6 ^ 1) & 1,doctype,&uri,0);
  if (parser_00 == (sgml_parser *)0x0) {
    return;
  }
  if (((document->options).field_0x45 & 0x40) == 0) {
    if (renderer.doctype == SGML_DOCTYPE_RSS) {
      add_dom_stack_context(&parser_00->stack,&renderer,&dom_rss_renderer_context_info);
      add_dom_config_normalizer
                (&parser_00->stack,&config,
                 DOM_CONFIG_NORMALIZE_CHARACTERS|DOM_CONFIG_NORMALIZE_WHITESPACE);
    }
  }
  else {
    add_dom_stack_context(&parser_00->stack,&renderer,&dom_source_renderer_context_info);
  }
  parse_sgml(parser_00,buffer->source,buffer->length,1);
  if (parser_00->root == (dom_node *)0x0) goto LAB_08088ea7;
  if (assert_failed == 0) {
    assert_failed = (int)((parser_00->stack).depth != 1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x437;
      elinks_internal((uchar *)"assertion parser->stack.depth == 1 failed!");
      if (assert_failed != 0) goto LAB_08088e8d;
    }
    assert_failed = 0;
  }
LAB_08088e8d:
  puVar2 = &(parser_00->stack).states[(parser_00->stack).depth - 1].field_0x8;
  *puVar2 = *puVar2 & 0xfe;
  pop_dom_node(&parser_00->stack);
LAB_08088ea7:
  done_uri(renderer.base_uri);
  done_sgml_parser(parser_00);
  return;
}



// WARNING: Unknown calling convention

void render_rss_item(dom_renderer *renderer,dom_node *item)

{
  int iVar1;
  int iVar2;
  document *pdVar3;
  int iVar4;
  dom_string *pdVar5;
  dom_string *pdVar6;
  dom_string *pdVar7;
  dom_string *pdVar8;
  uint uVar9;
  size_t newsize;
  uint uVar10;
  uchar *puVar11;
  uchar *url;
  global_history_item *pgVar12;
  color_T fgcolor;
  point *point;
  uchar *str;
  size_t size;
  link *plVar13;
  point *ppVar14;
  bookmark *pbVar15;
  dom_string *title;
  int x;
  int iVar16;
  size_t oldsize;
  uint uVar17;
  dom_string *author;
  dom_string *date;
  int y;
  uint local_38;
  color_pair colors;
  screen_char template;
  
  pdVar5 = get_rss_text(item,RSS_ELEMENT_TITLE);
  pdVar6 = get_rss_text(item,RSS_ELEMENT_LINK);
  pdVar7 = get_rss_text(item,RSS_ELEMENT_AUTHOR);
  pdVar8 = get_rss_text(item,RSS_ELEMENT_PUBDATE);
  if (((pdVar5 != (dom_string *)0x0) && (puVar11 = pdVar5->string, puVar11 != (uchar *)0x0)) &&
     (local_38 = pdVar5->length, local_38 != 0)) {
    if (renderer->channel == item) {
      puVar11 = convert_string_elinks
                          (renderer->convert_table,puVar11,local_38,(renderer->document->options).cp
                           ,CSM_DEFAULT,(int *)0x0,(_func_void_void_ptr_uchar_ptr_int *)0x0,
                           (void *)0x0);
      if (puVar11 == (uchar *)0x0) {
        local_38 = pdVar5->length;
        puVar11 = pdVar5->string;
      }
      else {
        renderer->document->title = puVar11;
        local_38 = pdVar5->length;
        puVar11 = pdVar5->string;
      }
    }
    render_dom_text(renderer,renderer->styles + 1,puVar11,local_38);
  }
  if (((pdVar6 != (dom_string *)0x0) && (pdVar6->string != (uchar *)0x0)) && (pdVar6->length != 0))
  {
    iVar1 = renderer->canvas_x;
    iVar16 = iVar1 + 1;
    renderer->canvas_x = iVar16;
    uVar9 = pdVar6->length;
    iVar2 = renderer->canvas_y;
    puVar11 = pdVar6->string;
    pdVar3 = renderer->document;
    uVar10 = pdVar3->nlinks + 0x80U & 0xffffff80;
    uVar17 = pdVar3->nlinks + 0x7fU & 0xffffff80;
    if (uVar17 < uVar10) {
      size = uVar10 * 0x34;
      plVar13 = (link *)mem_realloc(pdVar3->links,size);
      if (plVar13 == (link *)0x0) goto LAB_08089254;
      pdVar3->links = plVar13;
      memset(plVar13 + uVar17,0,size + uVar17 * -0x34);
    }
    plVar13 = pdVar3->links;
    if (plVar13 != (link *)0x0) {
      iVar4 = pdVar3->nlinks;
      uVar10 = plVar13[iVar4].npoints;
      if (uVar10 < 6) {
        ppVar14 = (point *)mem_realloc(plVar13[iVar4].points,0x30);
        if (ppVar14 == (point *)0x0) goto LAB_08089254;
        plVar13[iVar4].points = ppVar14;
        memset(ppVar14 + uVar10,0,uVar10 * -8 + 0x30);
      }
      if (plVar13[iVar4].points != (point *)0x0) {
        puVar11 = convert_string_elinks
                            (renderer->convert_table,puVar11,uVar9,(pdVar3->options).cp,CSM_DEFAULT,
                             (int *)0x0,(_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        if (puVar11 != (uchar *)0x0) {
          url = join_urls(renderer->base_uri,puVar11);
          mem_free(puVar11);
          if (url != (uchar *)0x0) {
            pgVar12 = get_global_history_item(url);
            if (pgVar12 == (global_history_item *)0x0) {
              pbVar15 = get_bookmark(url);
              if (pbVar15 == (bookmark *)0x0) {
                fgcolor = (pdVar3->options).default_link;
              }
              else {
                fgcolor = (pdVar3->options).default_bookmark_link;
              }
            }
            else {
              fgcolor = (pdVar3->options).default_vlink;
            }
            plVar13[iVar4].npoints = 6;
            plVar13[iVar4].type = LINK_HYPERTEXT;
            plVar13[iVar4].where = url;
            colors.background = (pdVar3->options).default_style.bg;
            plVar13[iVar4].color.background = colors.background;
            plVar13[iVar4].color.foreground = fgcolor;
            plVar13[iVar4].number = pdVar3->nlinks;
            template.attr = '\0';
            template.data = 0x20;
            colors.foreground = fgcolor;
            set_term_color(&template,&colors,(pdVar3->options).color_flags,
                           (pdVar3->options).color_mode);
            render_dom_text(renderer,&template,(uchar *)"[link]",6);
            ppVar14 = plVar13[iVar4].points;
            do {
              ppVar14->x = iVar16;
              iVar16 = iVar16 + 1;
              ppVar14->y = iVar2;
              ppVar14 = ppVar14 + 1;
            } while (iVar16 != iVar1 + 7);
            pdVar3->nlinks = pdVar3->nlinks + 1;
            pdVar3->field_0x114 = pdVar3->field_0x114 & 0xfe;
          }
        }
      }
    }
  }
LAB_08089254:
  renderer->canvas_y = renderer->canvas_y + 1;
  renderer->canvas_x = 0;
  if (((pdVar7 != (dom_string *)0x0) && (pdVar7->string != (uchar *)0x0)) && (pdVar7->length != 0))
  {
    render_dom_text(renderer,renderer->styles + 8,pdVar7->string,pdVar7->length);
  }
  if (((pdVar8 != (dom_string *)0x0) && (puVar11 = pdVar8->string, puVar11 != (uchar *)0x0)) &&
     (uVar9 = pdVar8->length, uVar9 != 0)) {
    if (((pdVar7 != (dom_string *)0x0) && (pdVar7->string != (uchar *)0x0)) && (pdVar7->length != 0)
       ) {
      render_dom_text(renderer,renderer->styles + 8," - ",3);
      uVar9 = pdVar8->length;
      puVar11 = pdVar8->string;
    }
    render_dom_text(renderer,renderer->styles + 8,puVar11,uVar9);
  }
  if ((((pdVar7 != (dom_string *)0x0) && (pdVar7->string != (uchar *)0x0)) && (pdVar7->length != 0))
     || (((pdVar8 != (dom_string *)0x0 && (pdVar8->string != (uchar *)0x0)) && (pdVar8->length != 0)
         ))) {
    renderer->canvas_y = renderer->canvas_y + 1;
    renderer->canvas_x = 0;
  }
  return;
}



// WARNING: Unknown calling convention

dom_code dom_rss_pop_document(dom_stack *stack,dom_node *root,void *data)

{
  dom_renderer *renderer_00;
  dom_node *item;
  uchar *p_00;
  dom_code dVar1;
  void *p;
  dom_node_list *p_01;
  dom_node *node;
  dom_renderer *renderer;
  int index;
  uint uVar2;
  
  renderer_00 = (dom_renderer *)stack->current->data;
  dVar1 = DOM_CODE_OK;
  if (renderer_00->channel != (dom_node *)0x0) {
    render_rss_item(renderer_00,renderer_00->channel);
    p_01 = renderer_00->items;
    if ((p_01 != (dom_node_list *)0x0) && (p_01->size != 0)) {
      uVar2 = 0;
      do {
        item = p_01->entries[uVar2];
        if (item != (dom_node *)0x0) {
          renderer_00->canvas_y = renderer_00->canvas_y + 1;
          renderer_00->canvas_x = 0;
          render_rss_item(renderer_00,item);
          p_01 = renderer_00->items;
        }
        uVar2 = uVar2 + 1;
      } while (uVar2 < p_01->size);
    }
    p_00 = (renderer_00->text).string;
    if ((p_00 != (uchar *)0x0) && ((renderer_00->text).length != 0)) {
      mem_free(p_00);
      p_01 = renderer_00->items;
      (renderer_00->text).string = (uchar *)0x0;
      (renderer_00->text).length = 0;
    }
    dVar1 = DOM_CODE_FREE_NODE;
    if (p_01 != (dom_node_list *)0x0) {
      mem_free(p_01);
      dVar1 = DOM_CODE_FREE_NODE;
    }
  }
  return dVar1;
}



// WARNING: Unknown calling convention

dom_code render_dom_document_end(dom_stack *stack,dom_node *node,void *data)

{
  dom_renderer *renderer_00;
  uchar *puVar1;
  uchar *puVar2;
  dom_renderer *renderer;
  int length;
  
  renderer_00 = (dom_renderer *)stack->current->data;
  puVar1 = renderer_00->position;
  if ((renderer_00->source < puVar1 || renderer_00->source == puVar1) &&
     (puVar2 = renderer_00->end, puVar1 <= puVar2)) {
    if (assert_failed == 0) {
      if ((puVar2 < renderer_00->source) ||
         (renderer_00->end <= puVar2 && puVar2 != renderer_00->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1ca;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,puVar2,puVar2);
      }
      else {
        assert_failed = 0;
      }
    }
    if (0 < (int)puVar2 - (int)puVar1) {
      render_dom_text(renderer_00,renderer_00->styles + 3,renderer_00->position,
                      (int)puVar2 - (int)puVar1);
      renderer_00->position = puVar2;
      if (assert_failed == 0) {
        if ((puVar2 < renderer_00->source) ||
           (renderer_00->end <= puVar2 && puVar2 != renderer_00->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1d0;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer_00->source,renderer_00->end,renderer_00->position,
                          renderer_00->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code render_dom_node_source(dom_stack *stack,dom_node *node,void *data)

{
  uchar *puVar1;
  ushort uVar2;
  dom_renderer *renderer_00;
  uchar *puVar3;
  int length_1;
  dom_renderer *renderer;
  uchar *string;
  uchar *string_00;
  int length;
  uint length_00;
  
  renderer_00 = (dom_renderer *)stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (renderer_00 == (dom_renderer *)0x0)) ||
       (renderer_00->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x21c;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  uVar2 = node->type;
  string_00 = (node->string).string;
  length_00 = (node->string).length;
  if (uVar2 == 5) {
    string_00 = string_00 + -1;
    length_00 = length_00 + 2;
  }
  if (string_00 < renderer_00->source) goto LAB_080898f4;
  puVar1 = string_00 + length_00;
  if (renderer_00->end < puVar1) goto LAB_080898f4;
  puVar3 = renderer_00->position;
  if (assert_failed == 0) {
    if ((puVar3 < renderer_00->source) || (renderer_00->end < puVar3)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
      if (assert_failed != 0) goto LAB_08089a04;
    }
    if ((string_00 < renderer_00->source) ||
       (renderer_00->end <= string_00 && string_00 != renderer_00->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,string_00,string_00);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089a04:
  if (0 < (int)string_00 - (int)puVar3) {
    render_dom_text(renderer_00,renderer_00->styles + 3,renderer_00->position,
                    (int)string_00 - (int)puVar3);
    renderer_00->position = string_00;
    if (assert_failed == 0) {
      if ((string_00 < renderer_00->source) ||
         (renderer_00->end <= string_00 && string_00 != renderer_00->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,renderer_00->position,
                        renderer_00->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  renderer_00->position = puVar1;
  if (assert_failed == 0) {
    if ((puVar1 < renderer_00->source) || (renderer_00->end <= puVar1 && puVar1 != renderer_00->end)
       ) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1e2;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_080898f4:
  render_dom_text(renderer_00,renderer_00->styles + uVar2,string_00,length_00);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code render_dom_element_source(dom_stack *stack,dom_node *node,void *data)

{
  uchar *puVar1;
  ushort uVar2;
  dom_renderer *renderer_00;
  uchar *puVar3;
  int length_1;
  dom_renderer *renderer;
  uchar *string;
  uchar *string_00;
  int length;
  uint length_00;
  
  renderer_00 = (dom_renderer *)stack->current->data;
  if (assert_failed == 0) {
    if (((node == (dom_node *)0x0) || (renderer_00 == (dom_renderer *)0x0)) ||
       (renderer_00->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x231;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  uVar2 = node->type;
  string_00 = (node->string).string;
  length_00 = (node->string).length;
  if (uVar2 == 5) {
    string_00 = string_00 + -1;
    length_00 = length_00 + 2;
  }
  if (string_00 < renderer_00->source) goto LAB_08089bc4;
  puVar1 = string_00 + length_00;
  if (renderer_00->end < puVar1) goto LAB_08089bc4;
  puVar3 = renderer_00->position;
  if (assert_failed == 0) {
    if ((puVar3 < renderer_00->source) || (renderer_00->end < puVar3)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
      if (assert_failed != 0) goto LAB_08089cd4;
    }
    if ((string_00 < renderer_00->source) ||
       (renderer_00->end <= string_00 && string_00 != renderer_00->end)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,string_00,string_00);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089cd4:
  if (0 < (int)string_00 - (int)puVar3) {
    render_dom_text(renderer_00,renderer_00->styles + 3,renderer_00->position,
                    (int)string_00 - (int)puVar3);
    renderer_00->position = string_00;
    if (assert_failed == 0) {
      if ((string_00 < renderer_00->source) ||
         (renderer_00->end <= string_00 && string_00 != renderer_00->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,renderer_00->position,
                        renderer_00->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  renderer_00->position = puVar1;
  if (assert_failed == 0) {
    if ((puVar1 < renderer_00->source) || (renderer_00->end <= puVar1 && puVar1 != renderer_00->end)
       ) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1e2;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089bc4:
  render_dom_text(renderer_00,renderer_00->styles + uVar2,string_00,length_00);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code render_dom_cdata_source(dom_stack *stack,dom_node *node,void *data)

{
  ushort uVar1;
  dom_renderer *renderer_00;
  uchar *puVar2;
  uchar *puVar3;
  int length_1;
  int length_2;
  dom_renderer *renderer;
  uchar *puVar4;
  uchar *string;
  uchar *puVar5;
  int length;
  uint length_00;
  
  renderer_00 = (dom_renderer *)stack->current->data;
  puVar5 = (node->string).string;
  if (assert_failed == 0) {
    if ((renderer_00 == (dom_renderer *)0x0) || (renderer_00->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x2b8;
      elinks_internal((uchar *)"assertion node && renderer && renderer->document failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  puVar3 = renderer_00->source;
  puVar4 = puVar5 + -6;
  if ((puVar3 <= puVar4) && (puVar5 <= renderer_00->end)) {
    puVar2 = renderer_00->position;
    length_2 = (int)puVar4 - (int)puVar2;
    if (assert_failed == 0) {
      if ((puVar2 < puVar3) || (renderer_00->end < puVar2)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1c9;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,renderer_00->position,
                        renderer_00->position);
        if (assert_failed != 0) goto LAB_0808a0fc;
      }
      if ((puVar4 < renderer_00->source) ||
         (renderer_00->end <= puVar4 && puVar4 != renderer_00->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1ca;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,puVar4,puVar4);
      }
      else {
        assert_failed = 0;
      }
    }
LAB_0808a0fc:
    if (0 < length_2) {
      render_dom_text(renderer_00,renderer_00->styles + 3,renderer_00->position,length_2);
      renderer_00->position = puVar4;
      if (assert_failed == 0) {
        if ((puVar4 < renderer_00->source) ||
           (renderer_00->end <= puVar4 && puVar4 != renderer_00->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1d0;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer_00->source,renderer_00->end,renderer_00->position,
                          renderer_00->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
    render_dom_text(renderer_00,renderer_00->styles + 2,puVar4,5);
    puVar5 = puVar5 + -1;
    renderer_00->position = puVar5;
    if (assert_failed == 0) {
      if ((renderer_00->source <= puVar5) &&
         (puVar5 < renderer_00->end || puVar5 == renderer_00->end)) {
        assert_failed = 0;
        puVar3 = renderer_00->source;
        goto LAB_08089e6a;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x2bf;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
    }
    puVar3 = renderer_00->source;
  }
LAB_08089e6a:
  uVar1 = node->type;
  puVar5 = (node->string).string;
  length_00 = (node->string).length;
  if (uVar1 == 5) {
    puVar5 = puVar5 + -1;
    length_00 = length_00 + 2;
  }
  if (puVar5 < puVar3) goto LAB_08089e92;
  puVar4 = puVar5 + length_00;
  if (renderer_00->end < puVar4) goto LAB_08089e92;
  puVar2 = renderer_00->position;
  if (assert_failed == 0) {
    if ((puVar2 < puVar3) || (renderer_00->end < puVar2)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1c9;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
      if (assert_failed != 0) goto LAB_08089f7c;
    }
    if ((puVar5 < renderer_00->source) || (renderer_00->end <= puVar5 && puVar5 != renderer_00->end)
       ) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1ca;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,puVar5,puVar5);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089f7c:
  if (0 < (int)puVar5 - (int)puVar2) {
    render_dom_text(renderer_00,renderer_00->styles + 3,renderer_00->position,
                    (int)puVar5 - (int)puVar2);
    renderer_00->position = puVar5;
    if (assert_failed == 0) {
      if ((puVar5 < renderer_00->source) ||
         (renderer_00->end <= puVar5 && puVar5 != renderer_00->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x1d0;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,renderer_00->position,
                        renderer_00->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  renderer_00->position = puVar4;
  if (assert_failed == 0) {
    if ((puVar4 < renderer_00->source) || (renderer_00->end <= puVar4 && puVar4 != renderer_00->end)
       ) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x1e2;
      elinks_internal((uchar *)
                      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                      ,renderer_00->source,renderer_00->end,renderer_00->position,
                      renderer_00->position);
    }
    else {
      assert_failed = 0;
    }
  }
LAB_08089e92:
  render_dom_text(renderer_00,renderer_00->styles + uVar1,puVar5,length_00);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code render_dom_attribute_source(dom_stack *stack,dom_node *node,void *data)

{
  screen_char *template_00;
  dom_renderer *renderer_00;
  dom_node_list *pdVar1;
  document *pdVar2;
  int iVar3;
  uchar *puVar4;
  int iVar5;
  ushort uVar6;
  ushort **ppuVar7;
  size_t newsize_1;
  point *point;
  uri *puVar8;
  global_history_item *pgVar9;
  color_T fgcolor;
  link *plVar10;
  point *ppVar11;
  bookmark *pbVar12;
  uchar *puVar13;
  int x;
  int length;
  int iVar14;
  size_t size;
  size_t newsize;
  uchar *puVar15;
  uchar *uristring;
  size_t oldsize;
  uint uVar16;
  int valuelen;
  dom_document *pdVar17;
  dom_renderer *renderer;
  uchar *string;
  uint uVar18;
  int quoted;
  int skips;
  int iVar19;
  int y;
  uchar *href;
  document *document;
  bool bVar20;
  uchar *local_38;
  dom_document *local_30;
  color_pair colors;
  screen_char template;
  
  renderer_00 = (dom_renderer *)stack->current->data;
  uVar6 = node->type;
  template_00 = renderer_00->styles + uVar6;
  if (assert_failed == 0) {
    if (renderer_00->document == (document *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 0x26d;
      elinks_internal((uchar *)"assertion node && renderer->document failed!");
      uVar6 = node->type;
    }
    else {
      assert_failed = 0;
      uVar6 = node->type;
    }
  }
  local_30 = (dom_document *)(node->string).length;
  puVar15 = (node->string).string;
  if (uVar6 == 5) {
    local_30 = (dom_document *)((int)local_30 + 2);
    puVar15 = puVar15 + -1;
  }
  if (renderer_00->source <= puVar15) {
    puVar13 = puVar15 + (int)local_30;
    if (puVar13 <= renderer_00->end) {
      puVar4 = renderer_00->position;
      length = (int)puVar15 - (int)puVar4;
      if (assert_failed == 0) {
        if ((puVar4 < renderer_00->source) || (renderer_00->end < puVar4)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1c9;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer_00->source,renderer_00->end,renderer_00->position,
                          renderer_00->position);
          if (assert_failed != 0) goto LAB_0808a5bd;
        }
        if ((puVar15 < renderer_00->source) ||
           (renderer_00->end <= puVar15 && puVar15 != renderer_00->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1ca;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer_00->source,renderer_00->end,puVar15,puVar15);
        }
        else {
          assert_failed = 0;
        }
      }
LAB_0808a5bd:
      if (0 < length) {
        render_dom_text(renderer_00,renderer_00->styles + 3,renderer_00->position,length);
        renderer_00->position = puVar15;
        if (assert_failed == 0) {
          if ((puVar15 < renderer_00->source) ||
             (renderer_00->end <= puVar15 && puVar15 != renderer_00->end)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 0x1d0;
            elinks_internal((uchar *)
                            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                            ,renderer_00->source,renderer_00->end,renderer_00->position,
                            renderer_00->position);
          }
          else {
            assert_failed = 0;
          }
        }
      }
      renderer_00->position = puVar13;
      if (assert_failed == 0) {
        if ((puVar13 < renderer_00->source) ||
           (renderer_00->end <= puVar13 && puVar13 != renderer_00->end)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 0x1e2;
          elinks_internal((uchar *)
                          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                          ,renderer_00->source,renderer_00->end,renderer_00->position,
                          renderer_00->position);
        }
        else {
          assert_failed = 0;
        }
      }
    }
  }
  render_dom_text(renderer_00,template_00,puVar15,(int)local_30);
  pdVar1 = (node->data).document.children;
  if (pdVar1 == (dom_node_list *)0x0) {
    return DOM_CODE_OK;
  }
  local_30 = (node->data).document.document;
  if (local_30 == (dom_document *)0x0) {
    return DOM_CODE_OK;
  }
  bVar20 = (node->data).attribute.quoted == '\x01';
  uVar18 = (uint)bVar20;
  local_38 = (uchar *)((int)pdVar1 - uVar18);
  local_30 = local_30 + uVar18 * 2;
  if ((renderer_00->source <= local_38) &&
     (local_38 < renderer_00->end || local_38 == renderer_00->end)) {
    render_dom_flush(renderer_00,local_38);
    puVar15 = local_38 + (int)local_30;
    renderer_00->position = puVar15;
    if (assert_failed == 0) {
      if ((puVar15 < renderer_00->source) ||
         (renderer_00->end <= puVar15 && puVar15 != renderer_00->end)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 0x279;
        elinks_internal((uchar *)
                        "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]"
                        ,renderer_00->source,renderer_00->end,renderer_00->position,
                        renderer_00->position);
      }
      else {
        assert_failed = 0;
      }
    }
  }
  if (((*(byte *)((int)&node->data + 0xd) & 8) == 0) || ((int)(local_30 + uVar18 * -2) < 1)) {
    render_dom_text(renderer_00,template_00,local_38,(int)local_30);
    return DOM_CODE_OK;
  }
  if ((int)local_30 < 1) {
LAB_0808aa18:
    iVar19 = 0;
    pdVar17 = local_30;
  }
  else {
    iVar19 = 0;
    do {
      if ((iVar19 != 0) || (!bVar20)) {
        ppuVar7 = __ctype_b_loc();
        if (((*(byte *)((int)*ppuVar7 + (uint)local_38[iVar19] * 2 + 1) & 0x20) == 0) &&
           (0x1f < local_38[iVar19])) break;
      }
      iVar19 = iVar19 + 1;
    } while (iVar19 < (int)local_30);
    if (0 < iVar19) {
      render_dom_text(renderer_00,template_00,local_38,iVar19);
      local_38 = local_38 + iVar19;
      local_30 = local_30 + -iVar19;
      if ((int)local_30 < 1) goto LAB_0808aa18;
    }
    iVar19 = 0;
    puVar15 = local_38 + (int)local_30;
    do {
      if ((iVar19 != 0) || (!bVar20)) {
        ppuVar7 = __ctype_b_loc();
        if (((*(byte *)((int)*ppuVar7 + (uint)puVar15[-1] * 2 + 1) & 0x20) == 0) &&
           (pdVar17 = local_30 + -iVar19, 0x1f < puVar15[-1])) goto LAB_0808a489;
      }
      iVar19 = iVar19 + 1;
      puVar15 = puVar15 + -1;
    } while (iVar19 < (int)local_30);
    pdVar17 = local_30 + -iVar19;
  }
LAB_0808a489:
  local_30 = pdVar17;
  if ((((renderer_00->doctype == SGML_DOCTYPE_HTML) && ((node->data).element.type == 0x2f)) &&
      ((node->parent->data).element.type == 8)) &&
     (puVar15 = memacpy(local_38,(int)local_30), puVar15 != (uchar *)0x0)) {
    puVar13 = join_urls(renderer_00->base_uri,puVar15);
    mem_free(puVar15);
    if (puVar13 != (uchar *)0x0) {
      puVar8 = get_uri(puVar13,0);
      mem_free(puVar13);
      if (puVar8 != (uri *)0x0) {
        done_uri(renderer_00->base_uri);
        renderer_00->base_uri = puVar8;
      }
    }
  }
  iVar14 = renderer_00->canvas_x;
  pdVar2 = renderer_00->document;
  iVar3 = renderer_00->canvas_y;
  uVar18 = pdVar2->nlinks + 0x80U & 0xffffff80;
  uVar16 = pdVar2->nlinks + 0x7fU & 0xffffff80;
  if (uVar16 < uVar18) {
    size = uVar18 * 0x34;
    plVar10 = (link *)mem_realloc(pdVar2->links,size);
    if (plVar10 == (link *)0x0) goto LAB_0808a4cc;
    pdVar2->links = plVar10;
    memset(plVar10 + uVar16,0,size + uVar16 * -0x34);
  }
  plVar10 = pdVar2->links;
  if (plVar10 != (link *)0x0) {
    iVar5 = pdVar2->nlinks;
    pdVar17 = (dom_document *)plVar10[iVar5].npoints;
    if (pdVar17 < local_30) {
      newsize = (int)local_30 * 8;
      ppVar11 = (point *)mem_realloc(plVar10[iVar5].points,newsize);
      if (ppVar11 == (point *)0x0) goto LAB_0808a4cc;
      plVar10[iVar5].points = ppVar11;
      memset(ppVar11 + (int)pdVar17,0,newsize + (int)pdVar17 * -8);
    }
    if ((plVar10[iVar5].points != (point *)0x0) &&
       (puVar15 = convert_string_elinks
                            (renderer_00->convert_table,local_38,(int)local_30,(pdVar2->options).cp,
                             CSM_DEFAULT,(int *)0x0,(_func_void_void_ptr_uchar_ptr_int *)0x0,
                             (void *)0x0), puVar15 != (uchar *)0x0)) {
      puVar13 = join_urls(renderer_00->base_uri,puVar15);
      mem_free(puVar15);
      if (puVar13 != (uchar *)0x0) {
        pgVar9 = get_global_history_item(puVar13);
        if (pgVar9 == (global_history_item *)0x0) {
          pbVar12 = get_bookmark(puVar13);
          if (pbVar12 == (bookmark *)0x0) {
            fgcolor = (pdVar2->options).default_link;
          }
          else {
            fgcolor = (pdVar2->options).default_bookmark_link;
          }
        }
        else {
          fgcolor = (pdVar2->options).default_vlink;
        }
        plVar10[iVar5].npoints = (int)local_30;
        plVar10[iVar5].type = LINK_HYPERTEXT;
        plVar10[iVar5].where = puVar13;
        colors.background = (pdVar2->options).default_style.bg;
        plVar10[iVar5].color.background = colors.background;
        plVar10[iVar5].color.foreground = fgcolor;
        plVar10[iVar5].number = pdVar2->nlinks;
        template.attr = '\0';
        template.data = 0x20;
        colors.foreground = fgcolor;
        set_term_color(&template,&colors,(pdVar2->options).color_flags,(pdVar2->options).color_mode)
        ;
        render_dom_text(renderer_00,&template,local_38,(int)local_30);
        ppVar11 = plVar10[iVar5].points;
        pdVar17 = local_30;
        if (0 < (int)local_30) {
          do {
            ppVar11->x = iVar14;
            iVar14 = iVar14 + 1;
            ppVar11->y = iVar3;
            ppVar11 = ppVar11 + 1;
            pdVar17 = pdVar17 + -1;
          } while (pdVar17 != (dom_document *)0x0);
        }
        pdVar2->nlinks = pdVar2->nlinks + 1;
        pdVar2->field_0x114 = pdVar2->field_0x114 & 0xfe;
      }
    }
  }
LAB_0808a4cc:
  if (0 < iVar19) {
    render_dom_text(renderer_00,template_00,local_38 + (int)local_30,iVar19);
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

int distribute_rows_or_cols(int *val_,int max_value,int *values,int values_count)

{
  int *piVar1;
  int iVar2;
  bool bVar3;
  int iVar4;
  int i;
  int iVar5;
  int val;
  int iVar6;
  int divisor;
  int iVar7;
  int flag;
  int local_20;
  
  iVar4 = 0;
  local_20 = 0;
  iVar6 = *val_ - max_value;
  if (0 < values_count) {
    local_20 = 0;
    do {
      while (piVar1 = values + iVar4, *piVar1 < 1) {
        values[iVar4] = 1;
        iVar4 = iVar4 + 1;
        local_20 = local_20 + 1;
        if (iVar4 == values_count) goto LAB_0808ab40;
      }
      iVar4 = iVar4 + 1;
      local_20 = local_20 + *piVar1;
    } while (iVar4 != values_count);
  }
LAB_0808ab40:
  if ((assert_failed == 0) && (assert_failed = (int)(local_20 == 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x13a;
    elinks_internal((uchar *)"assertion divisor failed!");
  }
  if (0 < values_count) {
    iVar7 = 0;
    iVar4 = local_20 - iVar6;
    do {
      iVar2 = values[iVar7];
      iVar5 = (iVar4 * iVar2) / local_20;
      values[iVar7] = iVar5;
      iVar6 = iVar6 + (iVar5 - iVar2);
      iVar7 = iVar7 + 1;
    } while (iVar7 != values_count);
  }
  if ((iVar6 != 0) && (0 < values_count)) {
    do {
      bVar3 = false;
      iVar4 = 0;
      do {
        if (iVar6 < 0) {
          iVar6 = iVar6 + 1;
          values[iVar4] = values[iVar4] + 1;
joined_r0x0808abc5:
          if (iVar6 == 0) {
            bVar3 = true;
LAB_0808abe8:
            iVar6 = 0;
            break;
          }
          bVar3 = true;
        }
        else {
          if (iVar6 == 0) goto LAB_0808abe8;
          if (1 < values[iVar4]) {
            iVar6 = iVar6 + -1;
            values[iVar4] = values[iVar4] + -1;
            goto joined_r0x0808abc5;
          }
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < values_count);
    } while ((bVar3) && (iVar6 != 0));
  }
  *val_ = iVar6;
  return 1;
}



// WARNING: Unknown calling convention

void parse_frame_widths(uchar *str,int max_value,int pixels_per_char,int **new_values,
                       int *new_values_count)

{
  bool bVar1;
  byte *__s;
  ushort **ppuVar2;
  ulong uVar3;
  ulong number;
  char *pcVar4;
  int j;
  int ret;
  int iVar5;
  int iVar6;
  void *__dest;
  int i_1;
  int iVar7;
  int val;
  int neg;
  int iVar8;
  int divisor;
  byte *__nptr;
  ulong uVar9;
  int maxval;
  int val_1;
  int *values_00;
  int *values;
  int values_count;
  int values_count_00;
  int i;
  int local_30;
  byte *local_24;
  int local_20 [4];
  
  values_00 = (int *)0x0;
  *new_values_count = 0;
  ppuVar2 = __ctype_b_loc();
  local_20[0] = 0;
  do {
    __nptr = str;
    while ((*(byte *)((int)*ppuVar2 + (uint)*__nptr * 2 + 1) & 0x20) != 0) {
      __nptr = __nptr + 1;
    }
    local_24 = str;
    uVar3 = strtoul((char *)__nptr,(char **)&local_24,10);
    __s = local_24;
    if (__nptr == local_24) {
      uVar3 = 0;
LAB_0808ad0a:
      if (*local_24 == 0x25) {
        uVar9 = 100;
        if ((int)uVar3 < 100) {
          uVar9 = uVar3;
        }
        val = (int)(uVar9 * max_value) / 100;
      }
      else if (*local_24 == 0x2a) {
        if (uVar3 == 0) goto LAB_0808acb8;
        val = -uVar3;
      }
      else {
        val = (uVar3 + (pixels_per_char + -1) / 2) / (uint)pixels_per_char;
      }
    }
    else {
      if (uVar3 < 0x10000) goto LAB_0808ad0a;
LAB_0808acb8:
      val = -1;
    }
    values_count_00 = local_20[0] + 1;
    values_00 = (int *)mem_realloc(values_00,values_count_00 * 4);
    if (values_00 == (int *)0x0) {
      return;
    }
    values_00[local_20[0]] = val;
    pcVar4 = strchr((char *)__s,0x2c);
    if (pcVar4 == (char *)0x0) break;
    str = (uchar *)(pcVar4 + 1);
    local_20[0] = values_count_00;
  } while( true );
  local_20[0] = local_20[0] + values_count_00;
  if (0 < values_count_00) {
    iVar5 = 0;
    do {
      if (0 < values_00[iVar5]) {
        local_20[0] = local_20[0] + -1 + values_00[iVar5];
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 != values_count_00);
  }
  iVar5 = local_20[0];
  if (local_20[0] < max_value) {
    bVar1 = false;
    iVar6 = 0;
    if (0 < values_count_00) {
      do {
        if (values_00[iVar6] < 0) {
          bVar1 = true;
        }
        iVar6 = iVar6 + 1;
      } while (iVar6 != values_count_00);
      if (bVar1) {
        __dest = mem_alloc(values_count_00 * 4);
        if (__dest == (void *)0x0) {
          return;
        }
        memcpy(__dest,values_00,values_count_00 * 4);
        iVar6 = 0;
        do {
          while (values_00[iVar6] < 1) {
            values_00[iVar6] = 1;
            iVar6 = iVar6 + 1;
            if (iVar6 == values_count_00) goto LAB_0808ae4b;
          }
          iVar6 = iVar6 + 1;
        } while (iVar6 != values_count_00);
LAB_0808ae4b:
        iVar8 = 0;
        iVar6 = 0;
        do {
          while (iVar7 = *(int *)((int)__dest + iVar6 * 4), iVar7 < 0) {
            iVar6 = iVar6 + 1;
            iVar8 = iVar8 - iVar7;
            if (iVar6 == values_count_00) goto LAB_0808ae77;
          }
          iVar6 = iVar6 + 1;
        } while (iVar6 != values_count_00);
LAB_0808ae77:
        if ((assert_failed == 0) && (assert_failed = (int)(iVar8 == 0), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
          errline = 0x16c;
          elinks_internal((uchar *)"assertion divisor failed!");
        }
        iVar6 = 0;
        local_30 = max_value - iVar5;
        do {
          while (iVar7 = *(int *)((int)__dest + iVar6 * 4), iVar7 < 0) {
            iVar7 = ((max_value - iVar5) * -iVar7) / iVar8;
            values_00[iVar6] = values_00[iVar6] + iVar7;
            iVar6 = iVar6 + 1;
            local_30 = local_30 - iVar7;
            if (iVar6 == values_count_00) goto LAB_0808aecd;
          }
          iVar6 = iVar6 + 1;
        } while (iVar6 != values_count_00);
LAB_0808aecd:
        if (assert_failed == 0) {
          assert_failed = -(local_30 >> 0x1f);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
            errline = 0x176;
            elinks_internal((uchar *)
                            "assertion val >= 0 failed: distribute_rows_or_cols_that_left: val < 0")
            ;
            if (assert_failed != 0) goto LAB_0808afc8;
          }
        }
        else {
LAB_0808afc8:
          assert_failed = 0;
          local_30 = 0;
        }
        iVar5 = 0;
        do {
          if ((local_30 != 0) && (*(int *)((int)__dest + iVar5 * 4) < 0)) {
            values_00[iVar5] = values_00[iVar5] + 1;
            local_30 = local_30 + -1;
          }
          iVar5 = iVar5 + 1;
        } while (iVar5 != values_count_00);
        if (assert_failed == 0) {
          assert_failed = (int)(0 < local_30);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
            errline = 0x17d;
            elinks_internal((uchar *)
                            "assertion val <= 0 failed: distribute_rows_or_cols_that_left: val > 0")
            ;
            if (assert_failed != 0) goto LAB_0808b00b;
          }
        }
        else {
LAB_0808b00b:
          assert_failed = 0;
        }
        mem_free(__dest);
        goto LAB_0808af5d;
      }
    }
  }
  iVar5 = distribute_rows_or_cols(local_20,max_value,values_00,values_count_00);
  if (iVar5 == 0) {
    return;
  }
LAB_0808af5d:
  if (0 < values_count_00) {
    iVar5 = 0;
    do {
      if (values_00[iVar5] == 0) {
        local_30 = 0;
        iVar6 = 0;
        iVar8 = 0;
        do {
          if (iVar6 < values_00[iVar8]) {
            iVar6 = values_00[iVar8];
            local_30 = iVar8;
          }
          iVar8 = iVar8 + 1;
        } while (iVar8 != values_count_00);
        if (iVar6 != 0) {
          values_00[iVar5] = 1;
          values_00[local_30] = values_00[local_30] + -1;
        }
      }
      iVar5 = iVar5 + 1;
    } while (iVar5 != values_count_00);
  }
  *new_values = values_00;
  *new_values_count = values_count_00;
  return;
}



// WARNING: Unknown calling convention

void format_frames(session *ses,frameset_desc *fsd,document_options *op,int depth)

{
  object *poVar1;
  uint uVar2;
  uri *puVar3;
  document *pdVar4;
  int iVar5;
  cache_entry *pcVar6;
  uint uVar7;
  frame *pfVar8;
  int iVar9;
  document_view *doc_view_00;
  uchar *puVar10;
  int sy;
  int iVar11;
  list_head_elinks *plVar12;
  document_view *ses_doc_view;
  int *piVar13;
  document_view *doc_view;
  frame *frame;
  int sx;
  document_options *pdVar14;
  int *piVar15;
  frame_desc *frame_desc;
  document_options *pdVar16;
  cache_entry *cached;
  byte bVar17;
  int local_cc;
  int local_b4;
  int local_b0;
  document_options o;
  
  bVar17 = 0;
  if (assert_failed == 0) {
    if (((fsd == (frameset_desc *)0x0) || (ses == (session *)0x0)) ||
       (op == (document_options *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
      errline = 0xdc;
      elinks_internal((uchar *)"assertion ses && fsd && op failed!");
      if (assert_failed != 0) goto LAB_0808b0ac;
    }
    else {
      assert_failed = 0;
    }
    if (depth < 6) {
      pdVar14 = op;
      pdVar16 = &o;
      for (iVar11 = 0x22; iVar11 != 0; iVar11 = iVar11 + -1) {
        pdVar16->color_mode = pdVar14->color_mode;
        pdVar14 = (document_options *)((int)pdVar14 + (uint)bVar17 * -8 + 4);
        pdVar16 = (document_options *)((int)pdVar16 + (uint)bVar17 * -8 + 4);
      }
      o.margin = (int)(o.margin != 0);
      if (0 < (fsd->box).height) {
        local_b0 = 0;
        plVar12 = &ses->scrn_frames;
        local_cc = 0;
        while (o.box.x = (op->box).x, (fsd->box).width < 1) {
LAB_0808b358:
          local_cc = local_cc + 1;
          o.box.y = o.box.y + o.box.height + 1;
          piVar15 = &(fsd->box).height;
          if (*piVar15 == local_cc || *piVar15 < local_cc) {
            return;
          }
        }
        local_b4 = 0;
        piVar15 = &fsd->frame_desc[local_b0].width;
LAB_0808b1db:
        o.box.width = *piVar15;
        o.box.height = piVar15[1];
        o.framename = (uchar *)piVar15[-2];
        if (((frame_desc *)(piVar15 + -3))->subframe == (frameset_desc *)0x0) {
          if ((uchar *)piVar15[-2] != (uchar *)0x0) {
            if (assert_failed == 0) {
              if (ses == (session *)0x0) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
                errline = 0xae;
                elinks_internal((uchar *)"assertion ses && frame_desc && o failed!");
                if (assert_failed != 0) goto LAB_0808b348;
              }
              else {
                assert_failed = 0;
              }
              while (pfVar8 = ses_find_frame(ses,fsd->frame_desc[local_b0].name),
                    pfVar8 != (frame *)0x0) {
                pcVar6 = find_in_cache((pfVar8->vs).uri);
                iVar5 = o.box.y;
                iVar11 = o.box.x;
                if (pcVar6 == (cache_entry *)0x0) break;
                uVar2 = (pfVar8->vs).plain;
                uVar7 = (byte)o._69_1_ >> 6 & 1;
                if (uVar2 != 0xffffffff) {
                  o._69_1_ = o._69_1_ & 0xbf | (byte)((uVar2 & 1) << 6);
                }
                if ((pcVar6->redirect == (uri *)0x0) || (9 < pfVar8->redirect_cnt)) {
                  puVar10 = (uchar *)piVar15[-2];
                  if (assert_failed == 0) {
                    assert_failed = (int)(puVar10 == (uchar *)0x0 || ses == (session *)0x0);
                    if (puVar10 == (uchar *)0x0 || ses == (session *)0x0) {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
                      errline = 0x87;
                      elinks_internal((uchar *)"assertion ses && name failed!");
                      if (assert_failed != 0) goto LAB_0808b3af;
                    }
                    doc_view_00 = (document_view *)(ses->scrn_frames).prev;
                    goto joined_r0x0808b423;
                  }
LAB_0808b3af:
                  assert_failed = 0;
                  goto LAB_0808b3b9;
                }
                pfVar8->redirect_cnt = pfVar8->redirect_cnt + 1;
                done_uri((pfVar8->vs).uri);
                puVar3 = pcVar6->redirect;
                poVar1 = &puVar3->object;
                poVar1->refcount = poVar1->refcount + 1;
                (pfVar8->vs).uri = puVar3;
                o._69_1_ = o._69_1_ & 0xbf | (byte)(uVar7 << 6);
              }
            }
            else {
LAB_0808b348:
              assert_failed = 0;
            }
          }
        }
        else {
          format_frames(ses,((frame_desc *)(piVar15 + -3))->subframe,&o,depth + 1);
        }
        goto LAB_0808b1b1;
      }
    }
  }
  else {
LAB_0808b0ac:
    assert_failed = 0;
  }
  return;
joined_r0x0808b423:
  if ((document_view *)plVar12 == doc_view_00) goto LAB_0808b54e;
  if ((doc_view_00->used == 0) &&
     (iVar9 = c_strcasecmp((char *)doc_view_00->name,(char *)puVar10), iVar9 == 0)) {
    doc_view_00->used = 1;
    doc_view_00->depth = depth;
    goto LAB_0808b476;
  }
  doc_view_00 = doc_view_00->prev;
  goto joined_r0x0808b423;
LAB_0808b54e:
  doc_view_00 = (document_view *)mem_calloc(1,0x3c);
  if (doc_view_00 != (document_view *)0x0) {
    doc_view_00->used = 1;
    puVar10 = stracpy(puVar10);
    doc_view_00->name = puVar10;
    if (puVar10 != (uchar *)0x0) {
      doc_view_00->depth = depth;
      doc_view_00->session = ses;
      if (iVar11 < 0) {
        iVar11 = 0;
      }
      (doc_view_00->box).x = iVar11;
      doc_view_00->search_word = &ses->search_word;
      iVar11 = 0;
      if (-1 < iVar5) {
        iVar11 = iVar5;
      }
      (doc_view_00->box).width = 0;
      (doc_view_00->box).height = 0;
      (doc_view_00->box).y = iVar11;
      if (assert_failed == 0) {
        assert_failed = 0;
        piVar13 = (int *)(ses->scrn_frames).next;
        if (plVar12 == (list_head_elinks *)piVar13) {
LAB_0808b654:
                    // WARNING: Load size is inaccurate
          doc_view_00->next = *(ses->scrn_frames).prev;
          doc_view_00->prev = (document_view *)(ses->scrn_frames).prev;
          *(document_view **)(ses->scrn_frames).prev = doc_view_00;
          doc_view_00->next->prev = doc_view_00;
        }
        else {
          iVar11 = (doc_view_00->box).x;
          iVar5 = (doc_view_00->box).y;
          if ((piVar13[8] <= iVar5) && ((piVar13[8] != iVar5 || (piVar13[7] <= iVar11)))) {
            do {
              piVar13 = (int *)*piVar13;
              if (plVar12 == (list_head_elinks *)piVar13) goto LAB_0808b654;
            } while ((piVar13[8] <= iVar5) && ((piVar13[7] <= iVar11 || (iVar5 != piVar13[8]))));
          }
          doc_view_00->next = *(document_view **)piVar13[1];
          doc_view_00->prev = (document_view *)piVar13[1];
          *(document_view **)piVar13[1] = doc_view_00;
          doc_view_00->next->prev = doc_view_00;
        }
      }
      else {
        assert_failed = 0;
      }
LAB_0808b476:
      render_document(&pfVar8->vs,doc_view_00,&o);
      if ((assert_failed == 0) &&
         (assert_failed = (int)(doc_view_00->document == (document *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
        errline = 0xcd;
        elinks_internal((uchar *)"assertion doc_view->document failed!");
      }
      doc_view_00->document->frame = fsd->frame_desc + local_b0;
      o._69_1_ = o._69_1_ & 0xbf | (byte)(uVar7 << 6);
      if (((doc_view_00 != (document_view *)0x0) &&
          (pdVar4 = doc_view_00->document, pdVar4 != (document *)0x0)) &&
         (pdVar4->frame_desc != (frameset_desc *)0x0)) {
        (pdVar4->object).refcount = (pdVar4->object).refcount + 1;
        format_frames(ses,pdVar4->frame_desc,&o,depth + 1);
        (pdVar4->object).refcount = (pdVar4->object).refcount + -1;
      }
      goto LAB_0808b1b1;
    }
    mem_free(doc_view_00);
  }
LAB_0808b3b9:
  o._69_1_ = o._69_1_ & 0xbf | (byte)(uVar7 << 6);
LAB_0808b1b1:
  o.box.x = o.box.width + 1 + o.box.x;
  piVar15 = piVar15 + 5;
  local_b4 = local_b4 + 1;
  local_b0 = local_b0 + 1;
  piVar13 = &(fsd->box).width;
  if (*piVar13 == local_b4 || *piVar13 < local_b4) goto LAB_0808b358;
  goto LAB_0808b1db;
}



// WARNING: Unknown calling convention

void add_frameset_entry(frameset_desc *frameset_desc,frameset_desc *subframe,uchar *name,uchar *url)

{
  int *piVar1;
  uchar *puVar2;
  uri *puVar3;
  int iVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(frameset_desc == (frameset_desc *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x24;
    elinks_internal((uchar *)"assertion frameset_desc failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar4 = (frameset_desc->box).y;
  if ((frameset_desc->box).height <= iVar4) {
    return;
  }
  iVar4 = iVar4 * (frameset_desc->box).width + (frameset_desc->box).x;
  frameset_desc->frame_desc[iVar4].subframe = subframe;
  puVar2 = (uchar *)0x0;
  if (name != (uchar *)0x0) {
    puVar2 = stracpy(name);
  }
  frameset_desc->frame_desc[iVar4].name = puVar2;
  if ((url == (uchar *)0x0) || (*url == '\0')) {
    frameset_desc->frame_desc[iVar4].uri = (uri *)0x0;
  }
  else {
    puVar3 = get_uri(url,0);
    frameset_desc->frame_desc[iVar4].uri = puVar3;
    if (puVar3 != (uri *)0x0) goto LAB_0808b7dd;
  }
  puVar3 = get_uri((uchar *)"about:blank",0);
  frameset_desc->frame_desc[iVar4].uri = puVar3;
LAB_0808b7dd:
  iVar4 = (frameset_desc->box).x + 1;
  (frameset_desc->box).x = iVar4;
  if ((frameset_desc->box).width <= iVar4) {
    piVar1 = &(frameset_desc->box).y;
    *piVar1 = *piVar1 + 1;
    (frameset_desc->box).x = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frameset_desc * create_frameset(frameset_param *fp)

{
  uint uVar1;
  frameset_desc *subframe;
  int iVar2;
  int i;
  uint uVar3;
  frameset_desc *pfVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (frameset_desc *)0x0;
  }
  assert_failed = (int)(fp == (frameset_param *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x46;
    elinks_internal((uchar *)"assertion fp failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (frameset_desc *)0x0;
    }
  }
  if ((fp->x < 1) || (fp->y < 1)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
    errline = 0x4a;
    elinks_internal((uchar *)
                    "assertion fp->x > 0 && fp->y > 0 failed: Bad size of frameset: x=%d y=%d",fp->x
                    ,fp->y);
    if (assert_failed != 0) {
      assert_failed = 0;
      if (fp->x < 1) {
        fp->x = 1;
      }
      iVar2 = fp->y;
      if (iVar2 < 1) {
        fp->y = 1;
        iVar2 = 1;
      }
      goto LAB_0808b97d;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar2 = fp->y;
LAB_0808b97d:
  uVar1 = iVar2 * fp->x;
  subframe = (frameset_desc *)mem_calloc(1,(uVar1 * 5 + 5) * 4);
  if (subframe != (frameset_desc *)0x0) {
    if (uVar1 != 0) {
      iVar2 = fp->x;
      uVar3 = 0;
      pfVar4 = subframe;
      while( true ) {
        pfVar4->frame_desc[0].width = fp->width[(int)uVar3 % iVar2];
        pfVar4->frame_desc[0].height = fp->height[(int)uVar3 / fp->x];
        pfVar4 = (frameset_desc *)pfVar4->frame_desc;
        if (uVar1 <= uVar3 + 1) break;
        iVar2 = fp->x;
        uVar3 = uVar3 + 1;
      }
    }
    subframe->n = uVar1;
    (subframe->box).width = fp->x;
    (subframe->box).height = fp->y;
    if (fp->parent != (frameset_desc *)0x0) {
      add_frameset_entry(fp->parent,subframe,(uchar *)0x0,(uchar *)0x0);
      return subframe;
    }
  }
  return subframe;
}



// WARNING: Unknown calling convention

void ln_break(html_context *html_context,int n)

{
  if ((n != 0) && (*(int *)((int)(html_context->stack).next + 0x98) == 0)) {
    while (html_context->line_breax < n) {
      html_context->line_breax = html_context->line_breax + 1;
      (*html_context->line_break_f)(html_context);
    }
    html_context->position = 0;
    html_context->putsp = HTML_SPACE_SUPPRESS;
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void add_fragment_identifier(html_context *html_context,part *part,uchar *attr)

{
  part *ppVar1;
  part *saved_part;
  
  ppVar1 = html_context->part;
  html_context->part = part;
  (*html_context->special_f)(html_context,0,attr);
  html_context->part = ppVar1;
  return;
}



// WARNING: Unknown calling convention

void html_skip(html_context *html_context,uchar *a)

{
  *(undefined4 *)((int)(html_context->stack).next + 0x98) = 1;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  return;
}



// WARNING: Unknown calling convention

void done_html_parser_state(html_context *html_context,void *state)

{
  html_element *e;
  html_element *element;
  
  e = (html_element *)(html_context->stack).next;
  html_context->line_breax = 1;
  while (e != (html_element *)state) {
    kill_html_stack_item(html_context,e);
    e = (html_element *)(html_context->stack).next;
  }
  *(undefined4 *)((int)state + 8) = 2;
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  return;
}



// WARNING: Unknown calling convention

void done_html_parser(html_context *html_context)

{
  list_head_elinks *plVar1;
  
  if ((html_context->options->field_0x44 & 1) != 0) {
    done_css_stylesheet(&html_context->css_styles);
  }
  plVar1 = &html_context->stack;
  mem_free(html_context->base_target);
  done_uri(html_context->base_href);
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  if (assert_failed != 0) {
LAB_0808bc00:
    assert_failed = 0;
    (html_context->stack).prev = plVar1;
    (html_context->stack).next = plVar1;
    mem_free(html_context);
    return;
  }
  assert_failed = (int)((list_head_elinks *)(html_context->stack).next != plVar1);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
    errline = 0x3c5;
    elinks_internal((uchar *)
                    "assertion list_empty(html_context->stack) failed: html stack not empty after operation"
                   );
    if (assert_failed != 0) goto LAB_0808bc00;
  }
  mem_free(html_context);
  return;
}



// WARNING: Unknown calling convention

html_context *
init_html_parser(uri *uri,document_options *options,uchar *start,uchar *end,string *head,
                string *title,_func_void_html_context_ptr_uchar_ptr_int *put_chars,
                _func_void_html_context_ptr *line_break,
                _func_void_ptr_html_context_ptr_html_special_type *special)

{
  list_head_elinks *plVar1;
  void *pvVar2;
  html_context *css2;
  html_context *html_context;
  list_head_elinks *plVar3;
  uchar *puVar4;
  void **ppvVar5;
  
  if (assert_failed == 0) {
    assert_failed = (int)(options == (document_options *)0x0 || uri == (uri *)0x0);
    if (options == (document_options *)0x0 || uri == (uri *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x369;
      elinks_internal((uchar *)"assertion uri && options failed!");
      if (assert_failed != 0) goto LAB_0808bef6;
    }
    css2 = (html_context *)mem_calloc(1,100);
    if (css2 != (html_context *)0x0) {
      (css2->css_styles).import = import_css_stylesheet;
      plVar1 = &css2->stack;
      plVar3 = &(css2->css_styles).selectors;
      (css2->css_styles).selectors.prev = plVar3;
      (css2->css_styles).selectors.next = plVar3;
      (css2->stack).prev = plVar1;
      (css2->stack).next = plVar1;
      css2->startf = start;
      css2->put_chars_f = put_chars;
      css2->line_break_f = line_break;
      css2->special_f = (_func_void_ptr_html_context_ptr_html_special_type_varargs *)special;
      puVar4 = (uchar *)0x0;
      (uri->object).refcount = (uri->object).refcount + 1;
      css2->base_href = uri;
      if (options->framename != (uchar *)0x0) {
        puVar4 = stracpy(options->framename);
      }
      css2->base_target = puVar4;
      css2->options = options;
      scan_http_equiv(start,end,head,title,options);
      ppvVar5 = (void **)mem_calloc(1,0xb4);
      if (ppvVar5 == (void **)0x0) {
        css2 = (html_context *)0x0;
      }
      else {
        pvVar2 = plVar1->next;
        ppvVar5[1] = plVar1;
        *ppvVar5 = pvVar2;
        plVar1->next = ppvVar5;
        *(void ***)((int)*ppvVar5 + 4) = ppvVar5;
        *(undefined4 *)((int)(css2->stack).next + 0xc) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x18) = 3;
        pvVar2 = (css2->stack).next;
        *(undefined4 *)((int)pvVar2 + 0x24) = 0;
        *(undefined4 *)((int)pvVar2 + 0x20) = 0;
        *(undefined4 *)((int)pvVar2 + 0x1c) = 0;
        pvVar2 = (css2->stack).next;
        *(undefined4 *)((int)pvVar2 + 0x70) = 0;
        *(undefined4 *)((int)pvVar2 + 0x6c) = 0;
        *(undefined4 *)((int)pvVar2 + 0x68) = 0;
        *(undefined4 *)((int)pvVar2 + 100) = 0;
        *(undefined4 *)((int)pvVar2 + 0x60) = 0;
        *(undefined4 *)((int)pvVar2 + 0x5c) = 0;
        *(undefined4 *)((int)pvVar2 + 0x58) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x48) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x2c) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x28) = 0;
        pvVar2 = (css2->stack).next;
        *(text_style_format *)((int)pvVar2 + 0xc) = (options->default_style).attr;
        *(color_T *)((int)pvVar2 + 0x10) = (options->default_style).fg;
        *(color_T *)((int)pvVar2 + 0x14) = (options->default_style).bg;
        *(color_T *)((int)(css2->stack).next + 0x30) = options->default_link;
        *(color_T *)((int)(css2->stack).next + 0x34) = options->default_vlink;
        *(color_T *)((int)(css2->stack).next + 0x38) = options->default_bookmark_link;
        *(color_T *)((int)(css2->stack).next + 0x3c) = options->default_image_link;
        *(undefined4 *)((int)(css2->stack).next + 0x74) = 0;
        *(int *)((int)(css2->stack).next + 0x78) = options->margin;
        *(int *)((int)(css2->stack).next + 0x7c) = options->margin;
        *(int *)((int)(css2->stack).next + 0x80) = (options->box).width;
        *(undefined4 *)((int)(css2->stack).next + 0x88) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x84) = 0;
        *(int *)((int)(css2->stack).next + 0x8c) = options->margin;
        *(undefined4 *)((int)(css2->stack).next + 0x90) = 0;
        *(color_T *)((int)(css2->stack).next + 0x94) = (options->default_style).bg;
        *(undefined4 *)((int)(css2->stack).next + 0x98) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0x9c) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0xa0) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0xa4) = 0;
        *(undefined4 *)((int)(css2->stack).next + 0xa8) = 1;
        *(undefined4 *)((int)(css2->stack).next + 8) = 1;
        css2->field_0x44 = css2->field_0x44 & 0xf7;
        css2->table_level = 0;
        (css2->css_styles).import_data = css2;
        if ((options->field_0x44 & 1) != 0) {
          mirror_css_stylesheet(&default_stylesheet,(css_stylesheet *)css2);
        }
      }
    }
  }
  else {
LAB_0808bef6:
    assert_failed = 0;
    css2 = (html_context *)0x0;
  }
  return css2;
}



// WARNING: Unknown calling convention

void * init_html_parser_state
                 (html_context *html_context,html_element_mortality_type type,int align,int margin,
                 int width)

{
  html_stack_dup(html_context,type);
  *(int *)((int)(html_context->stack).next + 0x74) = align;
  if (type == ELEMENT_IMMORTAL) {
    *(int *)((int)(html_context->stack).next + 0x78) = margin;
    *(int *)((int)(html_context->stack).next + 0x7c) = margin;
    *(int *)((int)(html_context->stack).next + 0x80) = width;
    *(undefined4 *)((int)(html_context->stack).next + 0x84) = 0;
    *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
    *(undefined4 *)((int)(html_context->stack).next + 0x8c) = 0;
    *(undefined4 *)((int)(html_context->stack).next + 0xa0) = 0;
  }
  return (html_context->stack).next;
}



// WARNING: Unknown calling convention

void set_fragment_identifier(html_context *html_context,uchar *attr_name,uchar *attr)

{
  uchar *p;
  uchar *id_attr;
  
  p = get_attr_value(attr_name,attr,html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    (*html_context->special_f)(html_context,0,p);
    mem_free(p);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void put_chrs(html_context *html_context,uchar *start,int len)

{
  void *pvVar1;
  ushort **ppuVar2;
  ushort *puVar3;
  
  pvVar1 = (html_context->stack).next;
  if ((*(byte *)((int)pvVar1 + 0xc) & 0x20) != 0) {
    html_context->putsp = HTML_SPACE_NORMAL;
  }
  if (len == 0) {
    return;
  }
  if (*(int *)((int)pvVar1 + 0x98) != 0) {
    return;
  }
  if (html_context->putsp != HTML_SPACE_SUPPRESS) {
    if (html_context->putsp != HTML_SPACE_ADD) {
      ppuVar2 = __ctype_b_loc();
      puVar3 = *ppuVar2;
      goto LAB_0808c06d;
    }
    (*html_context->put_chars_f)(html_context," ",1);
    html_context->position = html_context->position + 1;
    html_context->putsp = HTML_SPACE_SUPPRESS;
  }
  html_context->putsp = HTML_SPACE_NORMAL;
  ppuVar2 = __ctype_b_loc();
  puVar3 = *ppuVar2;
  if ((*(byte *)((int)puVar3 + (uint)*start * 2 + 1) & 0x20) != 0) {
    len = len + -1;
    if (len == 0) {
      html_context->putsp = HTML_SPACE_SUPPRESS;
      return;
    }
    start = start + 1;
  }
LAB_0808c06d:
  if (((*(byte *)((int)puVar3 + (uint)start[len + -1] * 2 + 1) & 0x20) != 0) &&
     ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0)) {
    html_context->putsp = HTML_SPACE_SUPPRESS;
  }
  html_context->field_0x44 = html_context->field_0x44 & 0xfe;
  (*html_context->put_chars_f)(html_context,start,len);
  html_context->position = html_context->position + len;
  html_context->line_breax = 0;
  if (0 < html_context->was_li) {
    html_context->was_li = html_context->was_li + -1;
  }
  return;
}



// WARNING: Unknown calling convention

void html_focusable(html_context *html_context,uchar *a)

{
  byte bVar1;
  int cp_00;
  byte *p;
  uchar *accesskey;
  int tabindex;
  uchar *puVar2;
  ushort **ppuVar3;
  uint uVar4;
  void *pvVar5;
  int cp;
  
  *(undefined4 *)((int)(html_context->stack).next + 0x54) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x50) = 0x80000000;
  if (a == (uchar *)0x0) {
    return;
  }
  cp_00 = html_context->doc_cp;
  p = get_attr_value(a,"accesskey",cp_00,HTML_ATTR_NONE);
  if (p == (byte *)0x0) goto LAB_0808c191;
  pvVar5 = (html_context->stack).next;
  bVar1 = *p;
  if ((bVar1 == 0) || (p[1] != 0)) {
LAB_0808c181:
    uVar4 = 0;
  }
  else {
    ppuVar3 = __ctype_b_loc();
    uVar4 = (uint)bVar1;
    if ((*(byte *)((int)*ppuVar3 + uVar4 * 2 + 1) & 0x40) == 0) goto LAB_0808c181;
  }
  *(uint *)((int)pvVar5 + 0x54) = uVar4;
  mem_free(p);
LAB_0808c191:
  uVar4 = get_num(a,"tabindex",html_context->doc_cp);
  if (uVar4 - 1 < 0x7ffe) {
    *(uint *)((int)(html_context->stack).next + 0x50) = (uVar4 & 0x7fff) << 0x10;
  }
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x58) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x58));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onclick",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x58) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x5c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x5c));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"ondblclick",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x5c) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x60) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x60));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onmouseover",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x60) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 100) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 100));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onhover",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 100) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x68) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x68));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onfocus",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x68) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x6c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x6c));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onmouseout",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x6c) = puVar2;
  pvVar5 = (html_context->stack).next;
  if (*(void **)((int)pvVar5 + 0x70) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar5 + 0x70));
    pvVar5 = (html_context->stack).next;
  }
  puVar2 = get_attr_value(a,(uchar *)"onblur",cp_00,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar5 + 0x70) = puVar2;
  return;
}



// WARNING: Unknown calling convention

void process_head(html_context *html_context,uchar *head)

{
  byte *pbVar1;
  uchar *puVar2;
  byte bVar3;
  uchar *puVar4;
  uchar *p;
  uchar *puVar5;
  int len;
  option_value *poVar6;
  char *pcVar7;
  int len_00;
  int plen;
  int *piVar8;
  uchar *puVar9;
  size_t len_01;
  byte *pbVar10;
  uchar uVar11;
  uchar *p_1;
  ulong uVar12;
  ulong seconds;
  byte *src;
  uchar *url;
  time_t expires;
  long lVar13;
  timeval_T now;
  timeval_T max_age;
  uchar *local_20 [4];
  
  puVar4 = parse_header(head,(uchar *)"Refresh",(uchar **)0x0);
  if (puVar4 != (uchar *)0x0) {
    if ((assert_failed == 0) && (assert_failed = 0, *puVar4 != '\0')) {
      pcVar7 = c_strcasestr((char *)puVar4,"url");
      if (pcVar7 != (char *)0x0) {
        src = (byte *)(pcVar7 + 3);
        bVar3 = pcVar7[3];
        while (bVar3 != 0) {
          if ((bVar3 != 0x3d) && (0x20 < bVar3)) {
            len_00 = 0;
            goto LAB_0808c56c;
          }
          src = src + 1;
          bVar3 = *src;
        }
        puVar5 = stracpy("");
        if (puVar5 != (uchar *)0x0) goto LAB_0808c466;
      }
      goto LAB_0808c5ce;
    }
LAB_0808c3fe:
    assert_failed = 0;
    uVar11 = *puVar4;
    if (uVar11 != '\0') {
      puVar5 = puVar4;
      if ((uVar11 == ' ') || (uVar11 == '\t')) {
        do {
          puVar5 = puVar5 + 1;
          uVar11 = *puVar5;
          if (uVar11 == '\0') goto LAB_0808c433;
        } while ((uVar11 == '\t') || (uVar11 == ' '));
      }
      while ((byte)(uVar11 - 0x30) < 10) {
        uVar11 = puVar5[1];
        puVar5 = puVar5 + 1;
      }
      if ((uVar11 != '\0') && (uVar11 = *puVar5, uVar11 != '\0')) {
        if ((uVar11 == ' ') || (uVar11 == '\t')) {
          do {
            puVar5 = puVar5 + 1;
            uVar11 = *puVar5;
            if (uVar11 == '\0') goto LAB_0808c433;
          } while ((uVar11 == '\t') || (uVar11 == ' '));
        }
        if ((uVar11 == ',') || (uVar11 == ';')) {
          puVar9 = puVar5 + 1;
          uVar11 = puVar5[1];
          if (uVar11 != '\0') {
            if ((uVar11 == ' ') || (uVar11 == '\t')) {
              do {
                puVar9 = puVar9 + 1;
                uVar11 = *puVar9;
                if (uVar11 == '\0') goto LAB_0808c433;
              } while ((uVar11 == '\t') || (uVar11 == ' '));
            }
            len_01 = strlen((char *)puVar9);
            if (len_01 != 0) {
              puVar5 = puVar9 + len_01;
              if ((*puVar5 == ' ') || (*puVar5 == '\t')) {
                do {
                  len_01 = len_01 - 1;
                  if (len_01 == 0) goto LAB_0808c433;
                  puVar2 = puVar5 + -1;
                  puVar5 = puVar5 + -1;
                } while ((*puVar2 == '\t') || (*puVar2 == ' '));
              }
              puVar5 = memacpy(puVar9,len_01);
              if (puVar5 != (uchar *)0x0) goto LAB_0808c466;
            }
          }
        }
      }
    }
    goto LAB_0808c433;
  }
  goto LAB_0808c48e;
LAB_0808c56c:
  bVar3 = src[len_00];
  if (bVar3 < 0x21) {
    if ((bVar3 != 9) && (bVar3 != 0x20)) goto LAB_0808c57a;
  }
  else if (bVar3 == 0x3b) goto LAB_0808c57a;
  len_00 = len_00 + 1;
  goto LAB_0808c56c;
LAB_0808c57a:
  if (len_00 != 0) {
    if ((src[len_00 + -1] == 9) || (src[len_00 + -1] == 0x20)) {
      pbVar10 = src + len_00;
      do {
        len_00 = len_00 + -1;
        if (len_00 == 0) goto LAB_0808c5b8;
        pbVar1 = pbVar10 + -2;
        pbVar10 = pbVar10 + -1;
      } while ((*pbVar1 == 9) || (*pbVar1 == 0x20));
    }
    if ((1 < len_00) && ((*src == 0x27 && (src[len_00 + -1] == 0x27)))) {
      pbVar10 = src + len_00;
      do {
        len_00 = len_00 + -2;
        src = src + 1;
        if ((len_00 < 2) || (*src != 0x27)) break;
        pbVar1 = pbVar10 + -2;
        pbVar10 = pbVar10 + -1;
      } while (*pbVar1 == 0x27);
    }
  }
LAB_0808c5b8:
  puVar5 = memacpy(src,len_00);
  if (puVar5 == (uchar *)0x0) {
LAB_0808c5ce:
    if (assert_failed == 0) goto LAB_0808c3fe;
    assert_failed = 0;
LAB_0808c433:
    puVar5 = get_uri_string(html_context->base_href,URI_ORIGINAL);
    if (puVar5 != (uchar *)0x0) goto LAB_0808c466;
  }
  else {
LAB_0808c466:
    uVar12 = 0;
    if (*puVar4 == ';') {
LAB_0808c62f:
      puVar9 = join_urls(html_context->base_href,puVar5);
      html_focusable(html_context,(uchar *)0x0);
      put_link_line((uchar *)"Refresh: ",puVar5,puVar9,html_context->options->framename,html_context
                   );
      (*html_context->special_f)(html_context,10,uVar12,puVar9);
      mem_free(puVar9);
    }
    else if ((byte)(*puVar4 - 0x30) < 10) {
      piVar8 = __errno_location();
      *piVar8 = 0;
      uVar12 = strtoul((char *)puVar4,(char **)0x0,10);
      if ((*piVar8 == 0x22) || (0x2a300 < uVar12)) {
        uVar12 = 0x2a300;
      }
      else if (*piVar8 != 0) goto LAB_0808c47e;
      goto LAB_0808c62f;
    }
LAB_0808c47e:
    mem_free(puVar5);
  }
  mem_free(puVar4);
LAB_0808c48e:
  poVar6 = get_opt_();
  if (poVar6->tree == (list_head_elinks *)0x0) {
    puVar4 = parse_header(head,(uchar *)"Pragma",(uchar **)0x0);
    local_20[0] = puVar4;
    if (puVar4 != (uchar *)0x0) {
      pcVar7 = strstr((char *)puVar4,"no-cache");
      mem_free(puVar4);
      if (pcVar7 != (char *)0x0) goto LAB_0808c502;
    }
    puVar4 = parse_header(head,(uchar *)"Cache-Control",(uchar **)0x0);
    local_20[0] = puVar4;
    if (puVar4 == (uchar *)0x0) {
      lVar13 = 0;
    }
    else {
      pcVar7 = strstr((char *)puVar4,"no-cache");
      if ((pcVar7 != (char *)0x0) ||
         (pcVar7 = strstr((char *)puVar4,"must-revalidate"), pcVar7 != (char *)0x0)) {
        mem_free(puVar4);
LAB_0808c502:
        (*html_context->special_f)(html_context,8);
        return;
      }
      pcVar7 = strstr((char *)puVar4,"max-age=");
      if (assert_failed == 0) {
        assert_failed = 0;
      }
      lVar13 = 0;
      if (pcVar7 != (char *)0x0) {
        lVar13 = strtol(pcVar7 + 8,(char **)0x0,10);
        timeval_from_seconds(&now,lVar13);
        timeval_now(&max_age);
        timeval_add_interval(&max_age,&now);
        lVar13 = timeval_to_seconds(&max_age);
        puVar4 = local_20[0];
      }
      mem_free(puVar4);
    }
    local_20[0] = parse_header(head,(uchar *)"Expires",(uchar **)0x0);
    if (local_20[0] != (uchar *)0x0) {
      pcVar7 = strstr((char *)local_20[0],"now");
      if (pcVar7 == (char *)0x0) {
        lVar13 = parse_date(local_20,(uchar *)0x0,0,1);
      }
      else {
        timeval_now(&now);
        lVar13 = timeval_to_seconds(&now);
      }
      mem_free(local_20[0]);
    }
    if (lVar13 != 0) {
      (*html_context->special_f)(html_context,9,lVar13);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void import_css_stylesheet(css_stylesheet *css,uri *base_uri,uchar *unterminated_url,int len)

{
  byte bVar1;
  void *pvVar2;
  uchar *url;
  uchar *rel;
  uchar *string;
  uri *uri;
  html_context *html_context;
  uchar *import_url;
  
  pvVar2 = css->import_data;
  if (assert_failed == 0) {
    assert_failed = (int)(pvVar2 == (void *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0xc0;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) goto LAB_0808ca8b;
    }
    assert_failed = (int)(base_uri == (uri *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0xc1;
      elinks_internal((uchar *)"assertion base_uri failed!");
      bVar1 = *(byte *)(*(int *)((int)pvVar2 + 0x1c) + 0x44);
      goto joined_r0x0808ca97;
    }
  }
LAB_0808ca8b:
  bVar1 = *(byte *)(*(int *)((int)pvVar2 + 0x1c) + 0x44);
joined_r0x0808ca97:
  if (((bVar1 & 3) == 3) && (rel = memacpy(unterminated_url,len), rel != (uchar *)0x0)) {
    string = join_urls(base_uri,rel);
    mem_free(rel);
    if (string != (uchar *)0x0) {
      uri = get_uri(string,URI_BASE);
      mem_free(string);
      if (uri != (uri *)0x0) {
        (**(code **)((int)pvVar2 + 0x60))(pvVar2,0xb,uri);
        import_css(css,uri);
        done_uri(uri);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_target(document_options *options,uchar *a)

{
  uchar *puVar1;
  uchar *v;
  int iVar2;
  
  puVar1 = get_attr_value(a,(uchar *)"target",options->cp,HTML_ATTR_NONE);
  if (puVar1 == (uchar *)0x0) {
    return (uchar *)0x0;
  }
  if ((*puVar1 != '\0') && (iVar2 = c_strcasecmp((char *)puVar1,"_self"), iVar2 != 0)) {
    return puVar1;
  }
  mem_free(puVar1);
  puVar1 = stracpy(options->framename);
  return puVar1;
}



// WARNING: Unknown calling convention

int get_image_map(uchar *head,uchar *pos,uchar *eof,menu_item **menu,memory_list **ml,uri *uri,
                 document_options *options,uchar *target_base,int to,int def,int hdef)

{
  uchar **ppuVar1;
  char **ppcVar2;
  uchar *eof_00;
  uchar *n1;
  uchar *s1;
  string *psVar3;
  conv_table *convert_table;
  menu_item *pmVar4;
  int iVar5;
  uchar *puVar6;
  size_t sVar7;
  uchar **p;
  uchar *puVar8;
  uint uVar9;
  size_t newsize;
  uint size;
  link_def *ll;
  uchar *al;
  menu_item *pmVar10;
  uint uVar11;
  int nmenu;
  int iVar12;
  uchar **ppuVar13;
  bool bVar14;
  byte bVar15;
  uchar *local_44;
  uchar *local_40;
  string str;
  string hd;
  uchar *local_2c;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  eof_00 = eof;
  bVar15 = 0;
  psVar3 = init_string(&hd);
  if (psVar3 != (string *)0x0) {
    if (head != (uchar *)0x0) {
      add_to_string(&hd,head);
    }
    scan_http_equiv(pos,eof_00,&hd,(string *)0x0,options);
    convert_table = get_convert_table(hd.source,to,def,(int *)0x0,(cp_status *)0x0,hdef);
    done_string(&hd);
    pmVar4 = (menu_item *)mem_calloc(1,0x20);
    *menu = pmVar4;
    if (pmVar4 != (menu_item *)0x0) {
LAB_0808cd33:
      do {
        if (eof_00 <= pos) {
LAB_0808cd37:
          mem_free(*menu);
          return -1;
        }
        if (*pos == '<') {
          if ((eof_00 < pos + 2) || ((pos[1] != '?' && (pos[1] != '!')))) {
            iVar5 = parse_element(pos,eof_00,&local_24,(int *)local_20,&local_28,&pos);
            if (iVar5 == 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
              errline = 0x226;
              iVar5 = elinks_strlcasecmp(local_24,(size_t)local_20[0],"MAP",3,1);
              if (iVar5 == 0) {
                if ((uri != (uri *)0x0) && (uri->fragment != (uchar *)0x0)) {
                  puVar6 = get_attr_value(local_28,"name",options->cp,HTML_ATTR_NONE);
                  if (puVar6 == (uchar *)0x0) goto LAB_0808cd33;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
                  errline = 0x22e;
                  iVar5 = elinks_strlcasecmp(puVar6,0xffffffff,uri->fragment,
                                             (uint)*(ushort *)&uri->field_0x34,1);
                  if (iVar5 != 0) {
                    mem_free(puVar6);
                    goto LAB_0808cd33;
                  }
                  mem_free(puVar6);
                }
                if (pos < eof_00) {
                  *ml = (memory_list *)0x0;
                  goto joined_r0x0808ce97;
                }
                goto LAB_0808cd37;
              }
            }
            else {
              pos = pos + 1;
            }
          }
          else {
            pos = skip_comment(pos,eof_00);
          }
          goto LAB_0808cd33;
        }
        pos = pos + 1;
      } while( true );
    }
  }
  return -1;
joined_r0x0808ce97:
  puVar6 = pos;
  if (eof_00 <= pos) {
LAB_0808d0b8:
    pos = puVar6;
    freeml(*ml);
    mem_free(*menu);
    return -1;
  }
  if (*pos != '<') {
    pos = pos + 1;
    goto joined_r0x0808ce97;
  }
  if ((eof_00 < pos + 2) || ((pos[1] != '?' && (pos[1] != '!')))) {
    iVar5 = parse_element(pos,eof_00,&local_24,(int *)&local_28,local_20,&pos);
    if (iVar5 == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x28a;
      iVar5 = elinks_strlcasecmp(local_24,(size_t)local_28,"A",1,1);
      if (iVar5 == 0) {
LAB_0808d060:
        s1 = local_24;
        n1 = local_28;
        psVar3 = init_string(&str);
        puVar8 = pos;
        puVar6 = eof_00;
        if (psVar3 == (string *)0x0) goto LAB_0808d0b8;
        local_2c = pos;
        if (eof_00 <= pos) {
LAB_0808d0a3:
          done_string(&str);
          goto LAB_0808d0b8;
        }
        if (*pos != '<') {
          do {
            local_2c = local_2c + 1;
            if (eof_00 <= local_2c) goto LAB_0808d0a3;
          } while (*local_2c != '<');
          if (local_2c != pos) {
            if (assert_failed == 0) {
              sVar7 = (int)local_2c - (int)pos;
              if ((int)sVar7 < 0) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                errline = 0xff;
                elinks_internal((uchar *)
                                "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                               );
                if (assert_failed != 0) goto LAB_0808d4c4;
              }
              else {
                assert_failed = 0;
              }
              if (sVar7 != 0) {
                iVar5 = sVar7 + str.length;
                uVar11 = str.length + 0xffU >> 8;
                uVar9 = str.length + 0xffU & 0xffffff00;
                size = iVar5 + 0x100U & 0xffffff00;
                if (uVar9 <= size && size + uVar11 * -0x100 != 0) {
                  puVar6 = (uchar *)mem_realloc(str.source,size);
                  if (puVar6 == (uchar *)0x0) goto LAB_0808d4d4;
                  str.source = puVar6;
                  memset(puVar6 + uVar9,0,size + uVar11 * -0x100);
                }
                if (str.source != (uchar *)0x0) {
                  memcpy(str.source + str.length,puVar8,sVar7);
                  str.source[iVar5] = '\0';
                  str.length = iVar5;
                }
              }
            }
            else {
LAB_0808d4c4:
              assert_failed = 0;
            }
          }
        }
LAB_0808d4d4:
        local_44 = str.source;
        pos = local_2c;
        if ((local_2c + 2 <= eof_00) && ((local_2c[1] == '?' || (local_2c[1] == '!')))) {
          pos = skip_comment(local_2c,eof_00);
          goto LAB_0808d060;
        }
        iVar5 = parse_element(local_2c,eof_00,(uchar **)0x0,(int *)0x0,(uchar **)0x0,&local_2c);
        if (iVar5 != 0) goto LAB_0808d060;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 0x25d;
        iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"A",1,1);
        if (iVar5 != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x25e;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"/A",2,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x25f;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"MAP",3,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x260;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"/MAP",4,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x261;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,"AREA",4,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
          errline = 0x262;
          iVar5 = elinks_strlcasecmp(s1,(size_t)n1,(uchar *)"/AREA",5,1);
          if (iVar5 == 0) goto LAB_0808d56d;
          pos = local_2c;
          goto LAB_0808d060;
        }
LAB_0808d56d:
        puVar6 = pos;
        if (eof_00 <= pos) goto LAB_0808d0b8;
LAB_0808d1ee:
        local_40 = get_target(options,local_20[0]);
        if (local_40 == (uchar *)0x0) {
          puVar6 = "";
          if (target_base != (uchar *)0x0) {
            puVar6 = target_base;
          }
          local_40 = stracpy(puVar6);
          if (local_40 == (uchar *)0x0) {
            if (local_44 != (uchar *)0x0) {
              mem_free(local_44);
            }
            goto joined_r0x0808ce97;
          }
        }
        p = (uchar **)mem_alloc(8);
        if (p == (uchar **)0x0) {
          if (local_44 != (uchar *)0x0) {
            mem_free(local_44);
          }
          mem_free(local_40);
        }
        else {
          puVar6 = get_attr_value(local_20[0],"href",options->cp,HTML_ATTR_EAT_NL);
          if (puVar6 == (uchar *)0x0) {
            if (local_44 != (uchar *)0x0) {
              mem_free(local_44);
            }
            mem_free(local_40);
            mem_free(p);
          }
          else {
            puVar8 = join_urls(uri,puVar6);
            *p = puVar8;
            mem_free(puVar6);
            if (*p == (uchar *)0x0) {
              if (local_44 != (uchar *)0x0) {
                mem_free(local_44);
              }
LAB_0808d740:
              mem_free(local_40);
              mem_free(p);
            }
            else {
              iVar12 = 0;
              p[1] = local_40;
              iVar5 = 0;
              if ((*menu)->text != (uchar *)0x0) {
                puVar6 = *p;
                pmVar4 = *menu;
                do {
                  pmVar10 = pmVar4 + 1;
                  ppcVar2 = (char **)pmVar4->data;
                  iVar5 = strcmp(*ppcVar2,(char *)puVar6);
                  if ((iVar5 == 0) && (iVar5 = strcmp(ppcVar2[1],(char *)local_40), iVar5 == 0)) {
                    mem_free(puVar6);
                    mem_free(p[1]);
                    mem_free(p);
                    if (local_44 != (uchar *)0x0) {
                      mem_free(local_44);
                    }
                    goto joined_r0x0808ce97;
                  }
                  iVar12 = iVar12 + 1;
                  iVar5 = iVar12 * 0x20;
                  pmVar4 = pmVar10;
                } while (pmVar10->text != (uchar *)0x0);
              }
              if (local_44 == (uchar *)0x0) {
LAB_0808d763:
                local_44 = stracpy(*p);
                if (local_44 == (uchar *)0x0) {
                  mem_free(local_40);
                  local_40 = *p;
                  goto LAB_0808d740;
                }
              }
              else {
                clr_spaces(local_44);
                if (*local_44 == '\0') {
                  mem_free(local_44);
                  goto LAB_0808d763;
                }
              }
              pmVar4 = (menu_item *)mem_realloc(*menu,(iVar12 + 2) * 0x20);
              if (pmVar4 != (menu_item *)0x0) {
                uVar11 = 0x40;
                *menu = pmVar4;
                ppuVar1 = (uchar **)((int)&pmVar4->text + iVar5);
                bVar14 = ((uint)ppuVar1 & 1) != 0;
                ppuVar13 = ppuVar1;
                if (bVar14) {
                  *(undefined *)ppuVar1 = 0;
                  ppuVar13 = (uchar **)((int)ppuVar1 + 1);
                  uVar11 = 0x3f;
                }
                if (((uint)ppuVar13 & 2) != 0) {
                  *(undefined2 *)ppuVar13 = 0;
                  uVar11 = uVar11 - 2;
                  ppuVar13 = (uchar **)((int)ppuVar13 + 2);
                }
                for (uVar9 = uVar11 >> 2; uVar9 != 0; uVar9 = uVar9 - 1) {
                  *ppuVar13 = (uchar *)0x0;
                  ppuVar13 = ppuVar13 + (uint)bVar15 * -2 + 1;
                }
                if ((uVar11 & 2) != 0) {
                  *(undefined2 *)ppuVar13 = 0;
                  ppuVar13 = (uchar **)((int)ppuVar13 + 2);
                }
                if (bVar14) {
                  *(undefined *)ppuVar13 = 0;
                }
                ppuVar1[3] = (uchar *)map_selected;
                *ppuVar1 = local_44;
                ppuVar1[5] = (uchar *)0x40;
                ppuVar1[4] = (uchar *)p;
              }
              add_to_ml(ml,p,*p,p[1],local_44,0);
            }
          }
        }
        goto joined_r0x0808ce97;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x28f;
      iVar5 = elinks_strlcasecmp(local_24,(size_t)local_28,"AREA",4,1);
      if (iVar5 == 0) {
        puVar6 = get_attr_value(local_20[0],"alt",options->cp,HTML_ATTR_NONE);
        local_44 = (uchar *)0x0;
        if (puVar6 != (uchar *)0x0) {
          sVar7 = strlen((char *)puVar6);
          local_44 = convert_string_elinks
                               (convert_table,puVar6,sVar7,options->cp,CSM_DEFAULT,(int *)0x0,
                                (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
          mem_free(puVar6);
        }
        goto LAB_0808d1ee;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 0x29d;
      iVar5 = elinks_strlcasecmp(local_24,(size_t)local_28,"/MAP",4,1);
      if (iVar5 == 0) {
        add_to_ml(ml,*menu,0);
        return 0;
      }
    }
    else {
      pos = pos + 1;
    }
    goto joined_r0x0808ce97;
  }
  pos = skip_comment(pos,eof_00);
  goto joined_r0x0808ce97;
}



// WARNING: Unknown calling convention

int get_color(html_context *html_context,uchar *a,uchar *c,color_T *rgb)

{
  int r;
  uchar *str;
  size_t slen;
  uchar *at;
  
  if (((html_context->options->color_mode != COLOR_MODE_MONO) &&
      (0 < html_context->options->use_document_colors)) &&
     (str = get_attr_value(a,c,html_context->doc_cp,HTML_ATTR_NONE), str != (uchar *)0x0)) {
    slen = strlen((char *)str);
    r = decode_color(str,slen,rgb);
    mem_free(str);
    return r;
  }
  r = -1;
  return r;
}



// WARNING: Unknown calling convention

int get_bgcolor(html_context *html_context,uchar *a,color_T *rgb)

{
  int iVar1;
  
  if ((html_context->options->color_mode != COLOR_MODE_MONO) &&
     (html_context->options->use_document_colors == 2)) {
    iVar1 = get_color(html_context,a,(uchar *)"bgcolor",rgb);
    return iVar1;
  }
  return -1;
}



// WARNING: Unknown calling convention

void check_html_form_hierarchy(part *part)

{
  document *pdVar1;
  void *pvVar2;
  list_head_elinks *plVar3;
  list_head_elinks *plVar4;
  list_head_elinks *plVar5;
  list_head_elinks *plVar6;
  form_control *fc;
  int *piVar7;
  form_control *next;
  form *form;
  list_head_elinks form_controls;
  
  pdVar1 = part->document;
  piVar7 = (int *)(pdVar1->forms).next;
  plVar6 = &pdVar1->forms;
  if ((list_head_elinks *)piVar7 != plVar6) {
    if (assert_failed != 0) {
      assert_failed = 0;
      piVar7 = (int *)(pdVar1->forms).next;
    }
    form_controls.next = &form_controls;
    form_controls.prev = &form_controls;
    if ((list_head_elinks *)piVar7 != plVar6) {
      do {
        if ((assert_failed == 0) &&
           (assert_failed = (int)(piVar7[3] < piVar7[2]), piVar7[3] < piVar7[2])) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x778;
          elinks_internal((uchar *)"assertion form->form_num <= form->form_end failed: %p [%d : %d]"
                          ,piVar7,piVar7[2],piVar7[3]);
        }
        plVar5 = (list_head_elinks *)((list_head_elinks *)piVar7[9])->next;
        plVar4 = (list_head_elinks *)piVar7[9];
        while (plVar3 = plVar5, plVar4 != (list_head_elinks *)(piVar7 + 9)) {
          pvVar2 = plVar4[2].next;
          if ((((void *)piVar7[2] != pvVar2 && (int)pvVar2 <= (int)piVar7[2]) ||
              (piVar7[3] < (int)pvVar2)) && ((list_head_elinks *)form_controls.next != plVar4)) {
            *(void **)((int)plVar4->next + 4) = plVar4->prev;
            *(void **)plVar4->prev = plVar4->next;
            plVar4->prev = &form_controls;
            plVar4->next = form_controls.next;
            *(list_head_elinks **)((int)plVar4->next + 4) = plVar4;
            form_controls.next = plVar4;
          }
          plVar5 = (list_head_elinks *)plVar3->next;
          plVar4 = plVar3;
        }
        piVar7 = (int *)*piVar7;
      } while ((list_head_elinks *)piVar7 != plVar6);
      plVar5 = (list_head_elinks *)*(void **)form_controls.next;
      plVar4 = (list_head_elinks *)form_controls.next;
      while (plVar3 = plVar5, plVar4 != &form_controls) {
        piVar7 = (int *)(pdVar1->forms).next;
        if ((list_head_elinks *)piVar7 == plVar6) {
LAB_0808d99a:
          plVar5 = (list_head_elinks *)plVar3->next;
          plVar4 = plVar3;
        }
        else {
          pvVar2 = plVar4[2].next;
          do {
            if (((void *)piVar7[2] == pvVar2 || (int)piVar7[2] < (int)pvVar2) &&
               ((int)pvVar2 <= piVar7[3])) {
              plVar4[1].next = piVar7;
              if ((list_head_elinks *)piVar7[9] != plVar4) {
                *(void **)((int)plVar4->next + 4) = plVar4->prev;
                *(void **)plVar4->prev = plVar4->next;
                pvVar2 = (void *)piVar7[9];
                plVar4->prev = piVar7 + 9;
                plVar4->next = pvVar2;
                piVar7[9] = (int)plVar4;
                *(list_head_elinks **)((int)plVar4->next + 4) = plVar4;
              }
              goto LAB_0808d99a;
            }
            piVar7 = (int *)*piVar7;
          } while ((list_head_elinks *)piVar7 != plVar6);
          plVar5 = (list_head_elinks *)plVar3->next;
          plVar4 = plVar3;
        }
      }
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(&form_controls != (list_head_elinks *)form_controls.next),
       assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x792;
      elinks_internal((uchar *)"assertion list_empty(form_controls) failed!");
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void * html_special(html_context *html_context,html_special_type_conflict c,...)

{
  part *ppVar1;
  document *pdVar2;
  form_control *pfVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  tag *ptVar7;
  color_mode color_mode;
  color_flags flags;
  screen_char *psVar8;
  cache_entry *pcVar9;
  void *ret_val;
  time_t expires;
  document_refresh *pdVar10;
  cache_entry *cached_1;
  form *nform;
  int *piVar11;
  size_t sVar12;
  tag *ptVar13;
  line *plVar14;
  form *pfVar15;
  form *form;
  document *document_1;
  undefined *puVar16;
  part *part;
  uchar *t;
  screen_char *schar;
  document *document;
  int x;
  int iVar17;
  uchar *t_1;
  ulong seconds;
  list_head_elinks *plVar18;
  form_control *in_stack_0000000c;
  uchar *in_stack_00000010;
  uchar *in_stack_00000014;
  int local_3c;
  color_pair colors;
  
  if (assert_failed != 0) goto LAB_0808da89;
  assert_failed = (int)(html_context == (html_context *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x7b8;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) goto LAB_0808da89;
  }
  ppVar1 = html_context->part;
  assert_failed = (int)(ppVar1 == (part *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x7bd;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) goto LAB_0808da89;
  }
  pcVar9 = renderer_context.cached;
  pdVar2 = ppVar1->document;
  switch(c) {
  case SP_TAG:
    if (pdVar2 == (document *)0x0) {
      return (void *)0x0;
    }
    iVar17 = (ppVar1->box).y;
    iVar4 = ppVar1->cy;
    iVar5 = (ppVar1->box).x;
    iVar6 = ppVar1->cx;
    if (assert_failed == 0) {
      assert_failed = 0;
      sVar12 = strlen((char *)in_stack_0000000c);
      ptVar13 = (tag *)mem_alloc(sVar12 + 0x14);
      if (ptVar13 == (tag *)0x0) {
        return (void *)0x0;
      }
      ptVar13->x = iVar6 + iVar5;
      ptVar13->y = iVar4 + iVar17;
      memcpy(ptVar13->name,in_stack_0000000c,sVar12 + 1);
      ptVar7 = (tag *)(pdVar2->tags).next;
      ptVar13->prev = (tag *)&pdVar2->tags;
      ptVar13->next = ptVar7;
      (pdVar2->tags).next = ptVar13;
      ptVar13->next->prev = ptVar13;
      if ((tag *)&pdVar2->tags != renderer_context.last_tag_for_newline) {
        return (void *)0x0;
      }
      ret_val = (void *)0x0;
      renderer_context.last_tag_for_newline = ptVar13;
      return ret_val;
    }
    goto LAB_0808da89;
  case SP_FORM:
    if (assert_failed == 0) {
      assert_failed = (int)(in_stack_0000000c == (form_control *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x6d7;
        elinks_internal((uchar *)"assertion part && form failed!");
        if (assert_failed != 0) goto LAB_0808da89;
      }
      assert_failed = (int)((int)in_stack_0000000c->form < 1);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x6d8;
        elinks_internal((uchar *)"assertion form->form_num > 0 failed!");
        if (assert_failed != 0) goto LAB_0808da89;
      }
      assert_failed = (int)(in_stack_0000000c->g_ctrl_num != 0x7fffffff);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x6d9;
        elinks_internal((uchar *)"assertion form->form_end == INT_MAX failed!");
        if (assert_failed != 0) goto LAB_0808da89;
      }
      pdVar2 = ppVar1->document;
      if (pdVar2 != (document *)0x0) {
        piVar11 = (int *)(pdVar2->forms).next;
        plVar18 = &pdVar2->forms;
        if ((list_head_elinks *)piVar11 == plVar18) {
          pfVar15 = init_form();
          if (pfVar15 == (form *)0x0) goto LAB_0808e042;
          pfVar15->form_num = 0;
          pfVar15->next = (form *)(ppVar1->document->forms).next;
          pfVar15->prev = (form *)&ppVar1->document->forms;
          (ppVar1->document->forms).next = pfVar15;
          pfVar15->next->prev = pfVar15;
          piVar11 = (int *)(ppVar1->document->forms).next;
          plVar18 = &ppVar1->document->forms;
        }
        if (plVar18 != (list_head_elinks *)piVar11) {
          pfVar15 = in_stack_0000000c->form;
          do {
            if (((int)(form *)piVar11[2] <= (int)pfVar15) && ((int)pfVar15 <= piVar11[3])) {
              if ((form *)piVar11[2] != pfVar15) {
                puVar16 = (undefined *)((int)&pfVar15[-1].items.prev + 3);
                in_stack_0000000c->g_ctrl_num = piVar11[3];
                piVar11[3] = (int)puVar16;
                if ((assert_failed == 0) &&
                   (assert_failed = (int)((int)puVar16 < piVar11[2]), (int)puVar16 < piVar11[2])) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
                  errline = 0x70f;
                  elinks_internal((uchar *)
                                  "assertion nform->form_num <= nform->form_end failed: [%d:%d] [%d:%d]"
                                  ,piVar11[2],piVar11[3],in_stack_0000000c->form,
                                  in_stack_0000000c->g_ctrl_num);
                }
                in_stack_0000000c->next = (form_control *)(ppVar1->document->forms).next;
                in_stack_0000000c->prev = (form_control *)&ppVar1->document->forms;
                (ppVar1->document->forms).next = in_stack_0000000c;
                in_stack_0000000c->next->prev = in_stack_0000000c;
                ret_val = (void *)0x0;
                return ret_val;
              }
              goto LAB_0808e042;
            }
            piVar11 = (int *)*piVar11;
          } while (plVar18 != (list_head_elinks *)piVar11);
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x714;
        elinks_error((uchar *)"hole between forms");
      }
LAB_0808e042:
      done_form((form *)in_stack_0000000c);
      ret_val = (void *)0x0;
      return ret_val;
    }
    goto LAB_0808da89;
  case SP_CONTROL:
    if (assert_failed == 0) {
      assert_failed = (int)(in_stack_0000000c == (form_control *)0x0);
      if (assert_failed == 0) {
LAB_0808dc94:
        if (ppVar1->document != (document *)0x0) {
          in_stack_0000000c->g_ctrl_num = renderer_context.g_ctrl_num;
          renderer_context.g_ctrl_num = renderer_context.g_ctrl_num + 1;
          pfVar15 = (form *)(ppVar1->document->forms).next;
          if (pfVar15 == (form *)&ppVar1->document->forms) {
            pfVar15 = init_form();
            pfVar15->form_num = 0;
            pfVar15->next = (form *)(ppVar1->document->forms).next;
            pfVar15->prev = (form *)&ppVar1->document->forms;
            (ppVar1->document->forms).next = pfVar15;
            pfVar15->next->prev = pfVar15;
            pfVar15 = (form *)(ppVar1->document->forms).next;
          }
          in_stack_0000000c->form = pfVar15;
          pfVar3 = (form_control *)(pfVar15->items).next;
          in_stack_0000000c->prev = (form_control *)&pfVar15->items;
          in_stack_0000000c->next = pfVar3;
          (pfVar15->items).next = in_stack_0000000c;
          in_stack_0000000c->next->prev = in_stack_0000000c;
          ret_val = (void *)0x0;
          return ret_val;
        }
        done_form_control(in_stack_0000000c);
        mem_free(in_stack_0000000c);
        ret_val = (void *)0x0;
        return ret_val;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x71e;
      elinks_internal((uchar *)"assertion part && fc failed!");
      if (assert_failed == 0) goto LAB_0808dc94;
    }
LAB_0808da89:
    assert_failed = 0;
    ret_val = (void *)0x0;
    break;
  case SP_TABLE:
    ret_val = renderer_context.convert_table;
    break;
  case SP_USED:
    ret_val = (void *)(uint)(pdVar2 != (document *)0x0);
    break;
  case SP_FRAMESET:
    if ((in_stack_0000000c->next == (form_control *)0x0) &&
       (pdVar2->frame_desc != (frameset_desc *)0x0)) {
      return (void *)0x0;
    }
    ret_val = create_frameset((frameset_param *)in_stack_0000000c);
    if ((in_stack_0000000c->next == (form_control *)0x0) &&
       (pdVar2->frame_desc == (frameset_desc *)0x0)) {
      pdVar2->frame_desc = (frameset_desc *)ret_val;
    }
    break;
  case SP_FRAME:
    add_frameset_entry((frameset_desc *)in_stack_0000000c,(frameset_desc *)0x0,in_stack_00000010,
                       in_stack_00000014);
    ret_val = (void *)0x0;
    break;
  case SP_NOWRAP:
    renderer_context._48_1_ =
         renderer_context._48_1_ & 0xf7 | (in_stack_0000000c != (form_control *)0x0) << 3;
    ret_val = (void *)0x0;
    break;
  case SP_CACHE_CONTROL:
    (renderer_context.cached)->cache_mode = CACHE_MODE_NEVER;
    puVar16 = &pcVar9->field_0x5c;
    *puVar16 = *puVar16 & 0xfe;
    ret_val = (void *)0x0;
    break;
  case SP_CACHE_EXPIRES:
    if (in_stack_0000000c == (form_control *)0x0) {
      return (void *)0x0;
    }
    if ((renderer_context.cached)->cache_mode == CACHE_MODE_NEVER) {
      return (void *)0x0;
    }
    timeval_from_seconds(&(renderer_context.cached)->max_age,(long)in_stack_0000000c);
    ret_val = (void *)0x0;
    puVar16 = &pcVar9->field_0x5c;
    *puVar16 = *puVar16 | 1;
    break;
  case SP_REFRESH:
    if (pdVar2 == (document *)0x0) {
      return (void *)0x0;
    }
    if (pdVar2->refresh != (document_refresh *)0x0) {
      done_document_refresh(pdVar2->refresh);
    }
    pdVar10 = init_document_refresh(in_stack_00000010,(ulong)in_stack_0000000c);
    pdVar2->refresh = pdVar10;
    ret_val = (void *)0x0;
    break;
  case SP_STYLESHEET:
    if (pdVar2 == (document *)0x0) {
      return (void *)0x0;
    }
    add_to_uri_list(&pdVar2->css_imports,(uri *)in_stack_0000000c);
    ret_val = (void *)0x0;
    break;
  case SP_COLOR_LINK_LINES:
    if (((pdVar2 != (document *)0x0) && ((pdVar2->options).color_mode != COLOR_MODE_MONO)) &&
       ((pdVar2->options).use_document_colors == 2)) {
      pdVar2 = html_context->part->document;
      colors.background = *(color_T *)((int)(html_context->stack).next + 0x94);
      color_mode = (pdVar2->options).color_mode;
      flags = (pdVar2->options).color_flags;
      local_3c = 0;
      if (0 < pdVar2->height) {
        do {
          colors.foreground = 0;
          iVar17 = 0;
          plVar14 = pdVar2->data + local_3c;
          if (0 < plVar14->length) {
            do {
              psVar8 = plVar14->chars;
              set_term_color(psVar8 + iVar17,&colors,flags,color_mode);
              if ((psVar8[iVar17].data == 0x3a) && (colors.foreground == 0)) {
                colors.foreground = *(color_T *)((int)(html_context->stack).next + 0x30);
              }
              iVar17 = iVar17 + 1;
              plVar14 = pdVar2->data + local_3c;
            } while (iVar17 < plVar14->length);
          }
          local_3c = local_3c + 1;
        } while (local_3c < pdVar2->height);
      }
    }
  default:
    return (void *)0x0;
  }
  return ret_val;
}



// WARNING: Unknown calling convention

void move_links(html_context *html_context,int xf,int yf,int xt,int yt)

{
  part *ppVar1;
  link *plVar2;
  bool bVar3;
  tag *ptVar4;
  line *plVar5;
  int *piVar6;
  tag *tag;
  tag *ptVar7;
  int iVar8;
  int iVar9;
  document *pdVar10;
  int i;
  uint uVar11;
  int iVar12;
  tag *ptVar13;
  int to_move;
  int iVar14;
  int matched;
  int local_40;
  int local_38;
  int local_20;
  
  local_40 = renderer_context.last_link_to_move;
  local_38 = renderer_context.last_link_to_move;
  if (assert_failed == 0) {
    assert_failed = (int)(html_context == (html_context *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x270;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) goto LAB_0808e3f8;
    }
    ppVar1 = html_context->part;
    if ((ppVar1 == (part *)0x0) || (ppVar1->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x275;
      elinks_internal((uchar *)"assertion part && part->document failed!");
      if (assert_failed != 0) goto LAB_0808e3f8;
    }
    else {
      assert_failed = 0;
    }
    plVar5 = realloc_lines(ppVar1->document,(ppVar1->box).y + yt);
    if (plVar5 != (line *)0x0) {
      pdVar10 = ppVar1->document;
      if (local_40 < pdVar10->nlinks) {
        local_40 = local_40 * 0x34;
        bVar3 = false;
        do {
          plVar2 = pdVar10->links;
          local_20 = *(int *)((int)&plVar2->npoints + local_40);
          if (0 < local_20) {
            uVar11 = 0;
LAB_0808e2f3:
            do {
              if (bVar3) {
                piVar6 = (int *)(*(int *)((int)&plVar2->points + local_40) + uVar11 * 8);
                iVar8 = piVar6[1];
                iVar14 = (ppVar1->box).y;
                iVar9 = iVar14 + yf;
              }
              else {
                piVar6 = (int *)(*(int *)((int)&plVar2->points + local_40) + uVar11 * 8);
                iVar14 = (ppVar1->box).y;
                iVar8 = piVar6[1];
                iVar9 = iVar14 + yf;
                if (iVar9 < iVar8) {
                  uVar11 = uVar11 + 1;
                  bVar3 = true;
                  if (local_20 <= (int)uVar11) break;
                  goto LAB_0808e2f3;
                }
              }
              iVar12 = uVar11 * 8;
              if (iVar8 == iVar9) {
                if (*piVar6 < (ppVar1->box).x + xf) {
                  bVar3 = true;
                }
                else if (yt < 0) {
                  local_20 = ~uVar11 + local_20;
                  if ((assert_failed == 0) &&
                     (assert_failed = -(local_20 >> 0x1f), assert_failed != 0)) {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
                    errline = 0x2af;
                    elinks_internal((uchar *)"assertion to_move >= 0 failed!");
                  }
                  if (0 < local_20) {
                    iVar8 = *(int *)((int)&plVar2->points + local_40);
                    iVar14 = uVar11 * 8;
                    uVar11 = uVar11 - 1;
                    memmove((void *)(iVar8 + iVar12),(void *)(iVar8 + 8 + iVar14),local_20 * 8);
                  }
                  local_20 = *(int *)((int)&plVar2->npoints + local_40) + -1;
                  *(int *)((int)&plVar2->npoints + local_40) = local_20;
                  bVar3 = true;
                }
                else {
                  piVar6[1] = iVar14 + yt;
                  piVar6 = (int *)(iVar12 + *(int *)((int)&plVar2->points + local_40));
                  *piVar6 = *piVar6 + (xt - xf);
                  local_20 = *(int *)((int)&plVar2->npoints + local_40);
                  bVar3 = true;
                }
              }
              uVar11 = uVar11 + 1;
            } while ((int)uVar11 < local_20);
          }
          if (!bVar3) {
            renderer_context.last_link_to_move = local_38;
          }
          local_38 = local_38 + 1;
          pdVar10 = ppVar1->document;
          local_40 = local_40 + 0x34;
        } while (pdVar10->nlinks != local_38 && local_38 <= pdVar10->nlinks);
      }
      if (-1 < yt) {
        bVar3 = false;
        ptVar13 = (tag *)&pdVar10->tags;
        ptVar7 = renderer_context.last_tag_to_move;
        while (ptVar4 = ptVar7->next, ptVar7->next != ptVar13) {
          while( true ) {
            ptVar7 = ptVar4;
            iVar14 = (ppVar1->box).y;
            iVar8 = iVar14 + yf;
            if (ptVar7->y == iVar8) break;
            if ((bVar3) || (iVar8 < ptVar7->y)) goto LAB_0808e488;
            ptVar13 = (tag *)&ppVar1->document->tags;
            ptVar4 = ptVar7->next;
            renderer_context.last_tag_to_move = ptVar7;
            if (ptVar7->next == ptVar13) {
              return;
            }
          }
          if ((ppVar1->box).x + xf <= ptVar7->x) {
            ptVar7->y = iVar14 + yt;
            ptVar7->x = ptVar7->x + (xt - xf);
            ptVar13 = (tag *)&ppVar1->document->tags;
          }
LAB_0808e488:
          bVar3 = true;
        }
      }
    }
  }
  else {
LAB_0808e3f8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void del_chars(html_context *html_context,int x,int y)

{
  part *ppVar1;
  part *part;
  
  if (assert_failed == 0) {
    assert_failed = (int)(html_context == (html_context *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x324;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) goto LAB_0808e628;
    }
    ppVar1 = html_context->part;
    if (((ppVar1 == (part *)0x0) || (ppVar1->document == (document *)0x0)) ||
       (ppVar1->document->data == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x329;
      elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
      if (assert_failed != 0) goto LAB_0808e628;
    }
    else {
      assert_failed = 0;
    }
    ppVar1->document->data[(ppVar1->box).y + y].length = x + (ppVar1->box).x;
    move_links(html_context,x,y,-1,-1);
  }
  else {
LAB_0808e628:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void * mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  size_t newsize;
  uint uVar2;
  size_t size;
  size_t oldsize;
  uint uVar3;
  int iVar4;
  
  uVar2 = mask + new & ~mask;
  uVar3 = mask + old & ~mask;
  if (uVar3 < uVar2) {
    size = uVar2 * objsize;
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    iVar4 = uVar3 * objsize;
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + iVar4),0,size - iVar4);
  }
  return *ptr;
}



// WARNING: Unknown calling convention

int realloc_line(html_context *html_context,document *document,int y,int length)

{
  size_t old;
  uchar uVar1;
  uchar uVar2;
  undefined uVar3;
  line *plVar4;
  void *pvVar5;
  screen_char *end;
  screen_char *schar;
  screen_char *pos;
  screen_char *psVar6;
  line *line;
  int orig_length;
  color_pair colors;
  
  plVar4 = realloc_lines(document,y);
  if (plVar4 != (line *)0x0) {
    line = document->data + y;
    old = line->length;
    if (length < (int)old) {
      return old;
    }
    pvVar5 = mem_align_alloc__(&line->chars,old,length + 1U,8,0xf);
    if (pvVar5 != (void *)0x0) {
      end = (screen_char *)(length * 8);
      schar = (screen_char *)(end->color + (int)((int)&line->chars[-1].data + 3));
      schar->data = 0x20;
      schar->attr = '\0';
      colors.background = *(color_T *)((int)(html_context->stack).next + 0x94);
      colors.foreground = 0;
      set_term_color(schar,&colors,COLOR_ENSURE_CONTRAST,(document->options).color_mode);
      for (psVar6 = line->chars + line->length; psVar6 < schar; psVar6 = psVar6 + 1) {
        psVar6->data = schar->data;
        uVar1 = schar->color[0];
        uVar2 = schar->color[1];
        uVar3 = schar->field_0x7;
        psVar6->attr = schar->attr;
        psVar6->color[0] = uVar1;
        psVar6->color[1] = uVar2;
        psVar6->field_0x7 = uVar3;
      }
      line->length = length + 1U;
      return old;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

void draw_frame_hchars(part *part,int x,int y,int width,uchar data,color_T bgcolor,color_T fgcolor,
                      html_context *html_context)

{
  uchar uVar1;
  uchar uVar2;
  undefined uVar3;
  int iVar4;
  int iVar5;
  screen_char *psVar6;
  screen_char *template;
  screen_char *schar;
  int local_30;
  color_pair colors;
  
  if (assert_failed == 0) {
    assert_failed = (int)(width < 1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x128;
      elinks_internal((uchar *)"assertion width > 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    assert_failed = (int)(html_context == (html_context *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10b;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    iVar5 = x + -1 + width;
    if ((((part == (part *)0x0) || (iVar5 < 0)) || (part->document == (document *)0x0)) || (y < 0))
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10e;
      elinks_internal((uchar *)"assertion part && part->document && x >= 0 && y >= 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar4 = realloc_line(html_context,part->document,y + (part->box).y,(part->box).x + iVar5);
    if (iVar4 < 0) {
      return;
    }
    if (assert_failed == 0) {
      assert_failed = (int)(part->document->data == (line *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x114;
        elinks_internal((uchar *)"assertion part->document->data failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      schar = part->document->data[y + (part->box).y].chars + iVar5 + (part->box).x;
      schar->attr = 0x80;
      schar->data = (uint)data;
      colors.background = bgcolor;
      colors.foreground = fgcolor;
      set_term_color(schar,&colors,(part->document->options).color_flags,
                     (part->document->options).color_mode);
      local_30 = width + -1;
      if (local_30 != 0) {
        do {
          iVar5 = (part->box).x + x;
          x = x + 1;
          psVar6 = part->document->data[y + (part->box).y].chars + iVar5;
          psVar6->data = schar->data;
          uVar1 = schar->color[0];
          uVar2 = schar->color[1];
          uVar3 = schar->field_0x7;
          psVar6->attr = schar->attr;
          psVar6->color[0] = uVar1;
          psVar6->color[1] = uVar2;
          psVar6->field_0x7 = uVar3;
          local_30 = local_30 + -1;
        } while (local_30 != 0);
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void expand_lines(html_context *html_context,part *part,int x,int y,int lines,color_T bgcolor)

{
  int y_00;
  int line;
  
  if (assert_failed == 0) {
    if ((part == (part *)0x0) || (part->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0xb9;
      elinks_internal((uchar *)"assertion part && part->document failed!");
      if (assert_failed != 0) goto LAB_0808eb28;
    }
    else {
      assert_failed = 0;
    }
    if ((((part->document->options).color_mode != COLOR_MODE_MONO) &&
        ((part->document->options).use_document_colors == 2)) &&
       (*(color_T *)((int)(html_context->stack).next + 0x94) = bgcolor, 0 < lines)) {
      line = 0;
      do {
        y_00 = (part->box).y + y + line;
        line = line + 1;
        realloc_line(html_context,part->document,y_00,x + (part->box).x);
      } while (line < lines);
    }
  }
  else {
LAB_0808eb28:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void align_line(html_context *html_context,int y,int last)

{
  unicode_val_T *puVar1;
  screen_char *schar;
  part *ppVar2;
  link *plVar3;
  uchar uVar4;
  uchar uVar5;
  undefined uVar6;
  undefined uVar7;
  undefined uVar8;
  int len;
  int iVar9;
  int len_1;
  size_t sVar10;
  void *pvVar11;
  screen_char *pos;
  int *p;
  int *p_00;
  int pos_1;
  screen_char *psVar12;
  int iVar13;
  int iVar14;
  int i;
  point *point;
  int iVar15;
  line *plVar16;
  screen_char *line;
  int iVar17;
  part *part;
  part *part_1;
  screen_char *end;
  int len_2;
  document *document;
  int prev_end;
  int iVar18;
  uint uVar19;
  int *piVar20;
  int spaces;
  int word_start;
  size_t sVar21;
  int word_len;
  int iVar22;
  int shift;
  int iVar23;
  part *part_2;
  bool bVar24;
  uint local_4c;
  int local_44;
  document *local_40;
  int local_38;
  int local_34;
  int local_30;
  color_pair colors;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(html_context == (html_context *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x488;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  ppVar2 = html_context->part;
  if (((ppVar2 == (part *)0x0) || (ppVar2->document == (document *)0x0)) ||
     (ppVar2->document->data == (line *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x48d;
    elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  len = ppVar2->document->data[(ppVar2->box).y + y].length - (ppVar2->box).x;
  if (len < 1) {
    return;
  }
  pvVar11 = (html_context->stack).next;
  iVar9 = *(int *)((int)pvVar11 + 0x74);
  if (iVar9 == 0) {
    return;
  }
  if (iVar9 == 3) {
    if (last != 0) {
      return;
    }
    ppVar2 = html_context->part;
    if (((ppVar2 == (part *)0x0) || (ppVar2->document == (document *)0x0)) ||
       (plVar16 = ppVar2->document->data, plVar16 == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x402;
      elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
      plVar16 = ppVar2->document->data;
    }
    iVar23 = plVar16[(ppVar2->box).y + y].length - (ppVar2->box).x;
    iVar9 = 0;
    if (-1 < iVar23) {
      iVar9 = iVar23;
    }
    assert_failed = (int)(iVar9 < 1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x406;
      elinks_internal((uchar *)"assertion len > 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    p = (int *)mem_alloc(iVar9 * 8);
    if (p == (int *)0x0) {
      return;
    }
    p_00 = (int *)mem_alloc(iVar9 * 4 + 4);
    if (p_00 == (int *)0x0) {
      mem_free(p);
      return;
    }
    memcpy(p,ppVar2->document->data[(ppVar2->box).y + y].chars + (ppVar2->box).x,iVar9 * 8);
    local_34 = 0;
    local_30 = -1;
    if (*p == 0x20) {
      local_34 = 0;
      do {
        local_30 = local_34;
        local_34 = local_30 + 1;
      } while (p[local_34 * 2] == 0x20);
    }
    *p_00 = local_30;
    if (local_34 < iVar9) {
      iVar23 = 1;
      piVar20 = p + local_34 * 2;
      do {
        if (*piVar20 == 0x20) {
          p_00[iVar23] = local_34;
          iVar23 = iVar23 + 1;
        }
        local_34 = local_34 + 1;
        piVar20 = piVar20 + 2;
      } while (local_34 < iVar9);
      p_00[iVar23] = iVar9;
      iVar13 = *(int *)((int)(html_context->stack).next + 0x80) -
               *(int *)((int)(html_context->stack).next + 0x7c);
      iVar15 = 0;
      if (-1 < iVar13) {
        iVar15 = iVar13;
      }
      if (((0 < iVar15 - iVar9) && (1 < iVar23)) &&
         (iVar13 = realloc_line(html_context,html_context->part->document,(ppVar2->box).y + y,
                                iVar15 + (ppVar2->box).x), iVar13 != 0)) {
        local_44 = 0;
        local_40 = (document *)0x0;
        local_30 = 0;
        do {
          if (assert_failed == 0) {
            iVar13 = p_00[local_30] + 1;
            iVar22 = p_00[local_30 + 1] - iVar13;
            assert_failed = -(iVar22 >> 0x1f);
            if (assert_failed != 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 0x44a;
              elinks_internal((uchar *)"assertion word_len >= 0 failed!");
              if (assert_failed != 0) goto LAB_0808f428;
            }
            iVar14 = local_44 / (iVar23 + -1) + iVar13;
            local_4c = iVar14 + iVar22;
            iVar18 = ppVar2->document->data[y + (ppVar2->box).y].length - (ppVar2->box).x;
            iVar17 = 0;
            if (-1 < iVar18) {
              iVar17 = iVar18;
            }
            assert_failed = (int)(iVar17 < (int)local_4c);
            if (iVar17 < (int)local_4c) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 0x453;
              elinks_internal((uchar *)"assertion LEN(y) >= new_start + word_len failed!");
              if (assert_failed != 0) {
                assert_failed = 0;
                local_4c = (uint)local_40;
                goto LAB_0808f3dd;
              }
            }
            memcpy(ppVar2->document->data[y + (ppVar2->box).y].chars + iVar14 + (ppVar2->box).x,
                   p + iVar13 * 2,iVar22 * 8);
            if (local_30 != 0) {
              if ((int)local_40 < iVar14) {
                uVar19 = (uint)local_40;
                do {
                  iVar22 = (ppVar2->box).x + uVar19;
                  uVar19 = uVar19 + 1;
                  psVar12 = ppVar2->document->data[y + (ppVar2->box).y].chars + iVar22;
                  psVar12->data = p[iVar13 * 2 + -2];
                  puVar1 = (unicode_val_T *)(p + iVar13 * 2 + -2 + 1);
                  uVar6 = *(undefined *)((int)puVar1 + 1);
                  uVar7 = *(undefined *)((int)puVar1 + 2);
                  uVar8 = *(undefined *)((int)puVar1 + 3);
                  psVar12->attr = *(undefined *)puVar1;
                  psVar12->color[0] = uVar6;
                  psVar12->color[1] = uVar7;
                  psVar12->field_0x7 = uVar8;
                } while ((int)uVar19 < iVar14);
              }
              iVar13 = ~(uint)local_40 + iVar14;
              if (iVar13 != 0) {
                move_links(html_context,(int)local_40 + 1,y,iVar14,y);
                iVar22 = ppVar2->document->nlinks;
                iVar14 = iVar14 + (ppVar2->box).x;
                iVar17 = y + (ppVar2->box).y;
                iVar18 = (iVar22 + -1) * 0x34;
                while (iVar22 != 0) {
                  iVar22 = iVar22 + -1;
                  plVar3 = ppVar2->document->links;
                  sVar10 = *(size_t *)((int)&plVar3->npoints + iVar18);
                  local_38 = sVar10 * 8;
                  sVar21 = sVar10;
                  while (local_38 = local_38 + -8, 1 < (int)sVar21) {
                    sVar21 = sVar21 - 1;
                    piVar20 = (int *)(local_38 + *(int *)((int)&plVar3->points + iVar18));
                    if ((iVar14 == *piVar20) && (iVar17 == piVar20[1])) {
                      pvVar11 = mem_align_alloc__((void **)((int)&plVar3->points + iVar18),sVar10,
                                                  sVar10 + iVar13,8,0);
                      if (pvVar11 != (void *)0x0) {
                        iVar22 = iVar13 + *(int *)((int)&plVar3->npoints + iVar18);
                        *(int *)((int)&plVar3->npoints + iVar18) = iVar22;
                        iVar22 = iVar22 * 8 + -8 + *(int *)((int)&plVar3->points + iVar18);
                        iVar18 = 0;
                        do {
                          iVar14 = iVar14 + -1;
                          *(int *)(iVar22 + iVar18 * 8) = iVar14;
                          *(int *)(iVar22 + 4 + iVar18 * 8) = iVar17;
                          iVar18 = iVar18 + -1;
                        } while (iVar18 + iVar13 != 0);
                      }
                      goto LAB_0808f3dd;
                    }
                  }
                  iVar18 = iVar18 + -0x34;
                }
              }
            }
          }
          else {
LAB_0808f428:
            local_4c = (uint)local_40;
            assert_failed = 0;
          }
LAB_0808f3dd:
          local_30 = local_30 + 1;
          local_44 = local_44 + (iVar15 - iVar9);
          if (iVar23 <= local_30) break;
          local_40 = (document *)local_4c;
        } while( true );
      }
    }
    else {
      p_00[1] = iVar9;
    }
    mem_free(p_00);
    mem_free(p);
    return;
  }
  iVar15 = *(int *)((int)pvVar11 + 0x80) - *(int *)((int)pvVar11 + 0x7c);
  iVar23 = 0;
  if (-1 < iVar15) {
    iVar23 = iVar15;
  }
  iVar23 = iVar23 - len;
  if (iVar9 == 1) {
    iVar23 = iVar23 / 2;
  }
  if (iVar23 < 1) {
    return;
  }
  ppVar2 = html_context->part;
  if (((ppVar2 == (part *)0x0) || (ppVar2->document == (document *)0x0)) ||
     (plVar16 = ppVar2->document->data, plVar16 == (line *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x30e;
    elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    plVar16 = ppVar2->document->data;
  }
  else {
    assert_failed = 0;
  }
  iVar9 = plVar16[(ppVar2->box).y + y].length - (ppVar2->box).x;
  if (iVar9 < 0) {
    iVar9 = 0;
  }
  sVar10 = iVar9 << 3;
  pvVar11 = mem_alloc(sVar10);
  if (pvVar11 == (void *)0x0) {
    return;
  }
  memcpy(pvVar11,ppVar2->document->data[(ppVar2->box).y + y].chars + (ppVar2->box).x,sVar10);
  if (assert_failed == 0) {
    ppVar2 = html_context->part;
    if ((ppVar2 == (part *)0x0) || (document = ppVar2->document, document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0xec;
      elinks_internal((uchar *)"assertion part && part->document && width > 0 failed!");
      if (assert_failed != 0) goto LAB_0808ed00;
      document = ppVar2->document;
    }
    else {
      assert_failed = 0;
    }
    iVar15 = realloc_line(html_context,document,(ppVar2->box).y + y,iVar23 + -1 + (ppVar2->box).x);
    if (-1 < iVar15) {
      if (assert_failed != 0) goto LAB_0808ed00;
      bVar24 = ppVar2->document->data == (line *)0x0;
      assert_failed = (int)bVar24;
      if (bVar24) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0xf2;
        elinks_internal((uchar *)"assertion part->document->data failed!");
        if (assert_failed != 0) goto LAB_0808ed00;
      }
      psVar12 = ppVar2->document->data[(ppVar2->box).y + y].chars + (ppVar2->box).x;
      schar = psVar12 + iVar23 + -1;
      schar->data = 0x20;
      schar->attr = '\0';
      colors.background = *(color_T *)((int)(html_context->stack).next + 0x94);
      colors.foreground = 0;
      set_term_color(schar,&colors,COLOR_ENSURE_CONTRAST,(ppVar2->document->options).color_mode);
      for (; psVar12 < schar; psVar12 = psVar12 + 1) {
        psVar12->data = schar->data;
        uVar4 = schar->color[0];
        uVar5 = schar->color[1];
        uVar6 = schar->field_0x7;
        psVar12->attr = schar->attr;
        psVar12->color[0] = uVar4;
        psVar12->color[1] = uVar5;
        psVar12->field_0x7 = uVar6;
      }
    }
    if (assert_failed == 0) goto LAB_0808ed00;
LAB_0808ed53:
    assert_failed = 0;
  }
  else {
LAB_0808ed00:
    ppVar2 = html_context->part;
    if (((iVar9 < 1) || (ppVar2 == (part *)0x0)) ||
       ((local_40 = ppVar2->document, local_40 == (document *)0x0 || (local_40->data == (line *)0x0)
        ))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x2e5;
      elinks_internal((uchar *)
                      "assertion width > 0 && part && part->document && part->document->data failed!"
                     );
      if (assert_failed != 0) goto LAB_0808ed53;
      local_40 = ppVar2->document;
    }
    else {
      assert_failed = 0;
    }
    iVar9 = realloc_line(html_context,local_40,y + (ppVar2->box).y,
                         iVar9 + -1 + (ppVar2->box).x + iVar23);
    if (-1 < iVar9) {
      memcpy(ppVar2->document->data[(ppVar2->box).y + y].chars + (ppVar2->box).x + iVar23,pvVar11,
             sVar10);
    }
  }
  mem_free(pvVar11);
  move_links(html_context,0,y,iVar23,y);
  return;
}



// WARNING: Unknown calling convention

void line_break(html_context *html_context)

{
  int x;
  part *ppVar1;
  document *document;
  int iVar2;
  tag *ptVar3;
  line *plVar4;
  int iVar5;
  tag *tag;
  int iVar6;
  part *part;
  int iVar7;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(html_context == (html_context *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x6a3;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  ppVar1 = html_context->part;
  assert_failed = (int)(ppVar1 == (part *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x6a8;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar5 = ppVar1->cx + *(int *)((int)(html_context->stack).next + 0x7c);
  if ((ppVar1->box).width < iVar5) {
    (ppVar1->box).width = iVar5;
  }
  if ((renderer_context._48_1_ & 2) != 0) {
    renderer_context._48_1_ = renderer_context._48_1_ & 0xfd;
    ppVar1->cx = -1;
    ppVar1->xa = 0;
    return;
  }
  document = ppVar1->document;
  if ((document != (document *)0x0) && (document->data != (line *)0x0)) {
    plVar4 = realloc_lines(document,ppVar1->cy + (ppVar1->box).height + 1);
    if (plVar4 == (line *)0x0) {
      return;
    }
    iVar5 = ppVar1->cx;
    if (*(int *)((int)(html_context->stack).next + 0x78) < iVar5) {
      x = iVar5 + -1;
      plVar4 = ppVar1->document->data + (ppVar1->box).y + ppVar1->cy;
      iVar2 = (ppVar1->box).x;
      iVar7 = plVar4->length - iVar2;
      iVar6 = 0;
      if (-1 < iVar7) {
        iVar6 = iVar7;
      }
      if ((x < iVar6) && (plVar4->chars[x + iVar2].data == 0x20)) {
        del_chars(html_context,x,ppVar1->cy);
        iVar5 = ppVar1->cx + -1;
        ppVar1->cx = iVar5;
      }
    }
    ptVar3 = renderer_context.last_tag_for_newline;
    if (0 < iVar5) {
      align_line(html_context,ppVar1->cy,1);
      ptVar3 = renderer_context.last_tag_for_newline;
    }
    for (; (ptVar3 != (tag *)0x0 && ((tag *)&ppVar1->document->tags != ptVar3));
        ptVar3 = ptVar3->prev) {
      ptVar3->x = (ppVar1->box).x;
      ptVar3->y = ppVar1->cy + (ppVar1->box).y + 1;
    }
  }
  ppVar1->cy = ppVar1->cy + 1;
  ppVar1->cx = -1;
  ppVar1->xa = 0;
  memset(ppVar1->spaces,0,ppVar1->spaces_len);
  memset(ppVar1->char_width,0,ppVar1->spaces_len);
  return;
}



// WARNING: Unknown calling convention

void free_table_cache(void)

{
  hash *phVar1;
  void *p;
  int iVar2;
  int i;
  hash_item *item;
  int *piVar3;
  
  if (table_cache != (hash *)0x0) {
    if (0 < 1 << ((byte)table_cache->width & 0x1f)) {
      iVar2 = 0;
      phVar1 = table_cache;
      do {
        piVar3 = (int *)phVar1->hash[iVar2].next;
        if ((list_head_elinks *)piVar3 != phVar1->hash + iVar2) {
          do {
            if ((void *)piVar3[4] != (void *)0x0) {
              mem_free((void *)piVar3[4]);
              phVar1 = table_cache;
            }
            piVar3 = (int *)*piVar3;
          } while (phVar1->hash + iVar2 != (list_head_elinks *)piVar3);
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < 1 << ((byte)phVar1->width & 0x1f));
    }
    free_hash(&table_cache);
    table_cache_entries = 0;
  }
  return;
}



// WARNING: Unknown calling convention

part * format_html_part(html_context *html_context,uchar *start,uchar *end,int align,int margin,
                       int width,document *document,int x,int y,uchar *head,int link_num)

{
  int iVar1;
  int iVar2;
  int iVar3;
  tag *ptVar4;
  void **ppvVar5;
  node *node;
  void *p_2;
  void *p_1;
  void *p;
  part *ppVar6;
  void *pvVar7;
  void *html_state;
  void *p_3;
  void *p_4;
  void *p_5;
  void *p_6;
  void *p_7;
  node *node_1;
  hash_item *phVar8;
  uint uVar9;
  void *pvVar10;
  byte bVar11;
  part *part;
  table_cache_entry_key key;
  
  ptVar4 = renderer_context.last_tag_to_move;
  iVar3 = renderer_context.last_link_to_move;
  bVar11 = renderer_context._48_1_ & 1;
  iVar1 = html_context->margin;
  if (table_cache == (hash *)0x0) {
    table_cache = init_hash8();
  }
  else if (document == (document *)0x0) {
    uVar9 = 0;
    do {
      *(undefined4 *)((int)&key.start + uVar9) = 0;
      uVar9 = uVar9 + 4;
    } while (uVar9 < 0x1c);
    key.start = start;
    key.end = end;
    key.align = align;
    key.margin = margin;
    key.width = width;
    key.x = x;
    key.link_num = link_num;
    phVar8 = get_hash_item(table_cache,(uchar *)&key,0x1c);
    if ((phVar8 != (hash_item *)0x0) && (ppVar6 = (part *)mem_alloc(0x34), ppVar6 != (part *)0x0)) {
      pvVar7 = phVar8->value;
      ppVar6->document = *(document **)((int)pvVar7 + 0x24);
      ppVar6->spaces = *(uchar **)((int)pvVar7 + 0x28);
      ppVar6->spaces_len = *(int *)((int)pvVar7 + 0x2c);
      ppVar6->char_width = *(uchar **)((int)pvVar7 + 0x30);
      (ppVar6->box).x = *(int *)((int)pvVar7 + 0x34);
      (ppVar6->box).y = *(int *)((int)pvVar7 + 0x38);
      (ppVar6->box).width = *(int *)((int)pvVar7 + 0x3c);
      (ppVar6->box).height = *(int *)((int)pvVar7 + 0x40);
      ppVar6->max_width = *(int *)((int)pvVar7 + 0x44);
      ppVar6->xa = *(int *)((int)pvVar7 + 0x48);
      ppVar6->cx = *(int *)((int)pvVar7 + 0x4c);
      ppVar6->cy = *(int *)((int)pvVar7 + 0x50);
      ppVar6->link_num = *(int *)((int)pvVar7 + 0x54);
      return ppVar6;
    }
  }
  if (assert_failed == 0) {
    assert_failed = -(y >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x877;
      elinks_internal((uchar *)"assertion y >= 0 failed: format_html_part: y == %d",y);
      if (assert_failed != 0) goto LAB_0808fbf8;
    }
    if (document == (document *)0x0) {
      renderer_context.last_link_to_move = 0;
      renderer_context.last_tag_for_newline = (tag *)0x0;
    }
    else {
      ppvVar5 = (void **)mem_alloc(0x18);
      if (ppvVar5 != (void **)0x0) {
        pvVar7 = (void *)0x7fffffff;
        if ((html_context->table_level != 0) && (pvVar7 = (void *)0x0, -1 < width)) {
          pvVar7 = (void *)width;
        }
        pvVar10 = (void *)x;
        if (x < 0) {
          pvVar10 = (void *)0x0;
        }
        ppvVar5[2] = pvVar10;
        pvVar10 = (void *)0x0;
        if (-1 < y) {
          pvVar10 = (void *)y;
        }
        ppvVar5[4] = pvVar7;
        ppvVar5[5] = (void *)0x1;
        ppvVar5[3] = pvVar10;
        pvVar7 = (document->nodes).next;
        ppvVar5[1] = &document->nodes;
        *ppvVar5 = pvVar7;
        (document->nodes).next = ppvVar5;
        *(void ***)((int)*ppvVar5 + 4) = ppvVar5;
      }
      renderer_context.last_link_to_move = document->nlinks;
      renderer_context.last_tag_for_newline = (tag *)&document->tags;
    }
    renderer_context.last_tag_to_move = renderer_context.last_tag_for_newline;
    html_context->margin = margin;
    renderer_context._48_1_ = renderer_context._48_1_ & 0xfe | document == (document *)0x0;
    if (renderer_context.link_state_info.link != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.link);
    }
    if (renderer_context.link_state_info.target != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.target);
    }
    if (renderer_context.link_state_info.image != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.image);
    }
    renderer_context._48_1_ = renderer_context._48_1_ | 2;
    renderer_context.link_state_info.link = (uchar *)0x0;
    renderer_context.link_state_info.target = (uchar *)0x0;
    renderer_context.link_state_info.image = (uchar *)0x0;
    renderer_context.link_state_info.form = (form_control *)0x0;
    ppVar6 = (part *)mem_calloc(1,0x34);
    if (ppVar6 != (part *)0x0) {
      ppVar6->document = document;
      (ppVar6->box).x = x;
      ppVar6->cx = -1;
      ppVar6->cy = 0;
      (ppVar6->box).y = y;
      ppVar6->link_num = link_num;
      pvVar7 = init_html_parser_state(html_context,ELEMENT_IMMORTAL,align,margin,width);
      parse_html(start,end,ppVar6,head,html_context);
      done_html_parser_state(html_context,pvVar7);
      iVar2 = (ppVar6->box).width;
      if (ppVar6->max_width < iVar2) {
        ppVar6->max_width = iVar2;
      }
      renderer_context._48_1_ = renderer_context._48_1_ & 0xfd;
      if (renderer_context.link_state_info.link != (uchar *)0x0) {
        mem_free(renderer_context.link_state_info.link);
      }
      if (renderer_context.link_state_info.target != (uchar *)0x0) {
        mem_free(renderer_context.link_state_info.target);
      }
      if (renderer_context.link_state_info.image != (uchar *)0x0) {
        mem_free(renderer_context.link_state_info.image);
      }
      renderer_context.link_state_info.link = (uchar *)0x0;
      renderer_context.link_state_info.target = (uchar *)0x0;
      renderer_context.link_state_info.image = (uchar *)0x0;
      renderer_context.link_state_info.form = (form_control *)0x0;
      if (ppVar6->spaces != (uchar *)0x0) {
        mem_free(ppVar6->spaces);
      }
      if (ppVar6->char_width != (uchar *)0x0) {
        mem_free(ppVar6->char_width);
      }
      if (document != (document *)0x0) {
        pvVar7 = (document->nodes).next;
        *(int *)((int)pvVar7 + 0x14) = (y + (ppVar6->box).height) - *(int *)((int)pvVar7 + 0xc);
      }
    }
    renderer_context._48_1_ = renderer_context._48_1_ & 0xfe | bVar11;
    renderer_context.last_link_to_move = iVar3;
    renderer_context.last_tag_to_move = ptVar4;
    html_context->margin = iVar1;
    if ((((document == (document *)0x0) && (1 < html_context->table_level)) &&
        (table_cache != (hash *)0x0)) &&
       ((table_cache_entries < 0x4000 && (pvVar7 = mem_calloc(1,0x58), pvVar7 != (void *)0x0)))) {
      *(uchar **)((int)pvVar7 + 8) = start;
      *(uchar **)((int)pvVar7 + 0xc) = end;
      *(int *)((int)pvVar7 + 0x10) = align;
      *(int *)((int)pvVar7 + 0x14) = margin;
      *(int *)((int)pvVar7 + 0x18) = width;
      *(int *)((int)pvVar7 + 0x1c) = x;
      *(int *)((int)pvVar7 + 0x20) = link_num;
      *(document **)((int)pvVar7 + 0x24) = ppVar6->document;
      *(uchar **)((int)pvVar7 + 0x28) = ppVar6->spaces;
      *(int *)((int)pvVar7 + 0x2c) = ppVar6->spaces_len;
      *(uchar **)((int)pvVar7 + 0x30) = ppVar6->char_width;
      *(int *)((int)pvVar7 + 0x34) = (ppVar6->box).x;
      *(int *)((int)pvVar7 + 0x38) = (ppVar6->box).y;
      *(int *)((int)pvVar7 + 0x3c) = (ppVar6->box).width;
      *(int *)((int)pvVar7 + 0x40) = (ppVar6->box).height;
      *(int *)((int)pvVar7 + 0x44) = ppVar6->max_width;
      *(int *)((int)pvVar7 + 0x48) = ppVar6->xa;
      *(int *)((int)pvVar7 + 0x4c) = ppVar6->cx;
      *(int *)((int)pvVar7 + 0x50) = ppVar6->cy;
      *(int *)((int)pvVar7 + 0x54) = ppVar6->link_num;
      phVar8 = add_hash_item(table_cache,(uchar *)((int)pvVar7 + 8),0x1c,pvVar7);
      if (phVar8 != (hash_item *)0x0) {
        table_cache_entries = table_cache_entries + 1;
        return ppVar6;
      }
      mem_free(pvVar7);
    }
  }
  else {
LAB_0808fbf8:
    assert_failed = 0;
    ppVar6 = (part *)0x0;
  }
  return ppVar6;
}



// WARNING: Unknown calling convention

void render_html_document(cache_entry *cached,document *document,string *buffer)

{
  undefined *puVar1;
  uchar *start_00;
  document_options *pdVar2;
  void *pvVar3;
  form *form_00;
  string *psVar4;
  html_context *html_context;
  uint uVar5;
  part *p_00;
  int iVar6;
  form *form;
  int i;
  uchar *puVar7;
  int iVar8;
  int iVar9;
  void *p;
  uchar *start;
  string head;
  string title;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(document == (document *)0x0 || cached == (cache_entry *)0x0);
  if (document == (document *)0x0 || cached == (cache_entry *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x8e4;
    elinks_internal((uchar *)"assertion cached && document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  psVar4 = init_string(&head);
  if (psVar4 != (string *)0x0) {
    if (cached->head != (uchar *)0x0) {
      add_to_string(&head,cached->head);
    }
    start_00 = buffer->source;
    iVar8 = buffer->length;
    html_context = init_html_parser(cached->uri,&document->options,start_00,start_00 + iVar8,&head,
                                    &title,put_chars_conv,line_break,html_special);
    if (html_context != (html_context *)0x0) {
      renderer_context.cached = cached;
      renderer_context.g_ctrl_num = 0;
      renderer_context.convert_table =
           get_convert_table(head.source,(document->options).cp,(document->options).assume_cp,
                             &document->cp,&document->cp_status,(document->options).hard_assume);
      pdVar2 = html_context->options;
      uVar5 = is_cp_utf8((document->options).cp);
      pdVar2->field_0x5c = pdVar2->field_0x5c & 0xef | (byte)((uVar5 & 1) << 4);
      html_context->doc_cp = document->cp;
      if (title.length != 0) {
        puVar7 = convert_string_elinks
                           (renderer_context.convert_table,title.source,title.length,
                            (document->options).cp,CSM_DEFAULT,(int *)0x0,
                            (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        document->title = puVar7;
      }
      done_string(&title);
      pvVar3 = (html_context->stack).next;
      p_00 = format_html_part(html_context,start_00,start_00 + iVar8,*(int *)((int)pvVar3 + 0x74),
                              *(int *)((int)pvVar3 + 0x78),(document->options).box.width,document,0,
                              0,head.source,1);
LAB_0808ff72:
      iVar6 = document->height;
      iVar8 = iVar6 * 8 + -8;
      iVar9 = iVar8;
      while ((iVar6 != 0 && (*(int *)((int)&document->data->length + iVar8) == 0))) {
        iVar6 = iVar6 + -1;
        iVar8 = iVar8 + -8;
        document->height = iVar6;
        pvVar3 = *(void **)((int)&document->data->chars + iVar9);
        iVar9 = iVar9 + -8;
        if (pvVar3 != (void *)0x0) goto code_r0x0808ffb8;
      }
      document->width = 0;
      if (0 < document->height) {
        iVar8 = 0;
        iVar6 = 0;
        while( true ) {
          iVar9 = document->data[iVar6].length;
          if (iVar8 < iVar9) {
            document->width = iVar9;
          }
          iVar6 = iVar6 + 1;
          if (document->height <= iVar6) break;
          iVar8 = document->width;
        }
      }
      puVar1 = &(document->options).field_0x5c;
      *puVar1 = *puVar1 | 2;
      document->bgcolor = *(color_T *)((int)(html_context->stack).next + 0x94);
      done_html_parser(html_context);
      form_00 = (form *)(document->forms).next;
      if ((form *)&document->forms != form_00) {
        iVar8 = form_00->form_num;
        while (iVar8 != 0) {
          form_00 = form_00->next;
          if ((form *)&document->forms == form_00) goto LAB_0808ffe8;
          iVar8 = form_00->form_num;
        }
        if ((list_head_elinks *)(form_00->items).next == &form_00->items) {
          done_form(form_00);
        }
      }
LAB_0808ffe8:
      done_string(&head);
      if (p_00 != (part *)0x0) {
        mem_free(p_00);
      }
    }
  }
  return;
code_r0x0808ffb8:
  mem_free(pvVar3);
  goto LAB_0808ff72;
}



// WARNING: Unknown calling convention

void draw_frame_vchars(part *part,int x,int y,int height,uchar data,color_T bgcolor,color_T fgcolor,
                      html_context *html_context)

{
  uchar uVar1;
  uchar uVar2;
  undefined uVar3;
  int iVar4;
  screen_char *psVar5;
  int iVar6;
  screen_char *template;
  screen_char *schar;
  color_pair colors;
  
  if (assert_failed == 0) {
    assert_failed = (int)(html_context == (html_context *)0x0);
    if (html_context == (html_context *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10b;
      elinks_internal((uchar *)"assertion html_context failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if ((((part == (part *)0x0) || (x < 0)) || (part->document == (document *)0x0)) || (y < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x10e;
      elinks_internal((uchar *)"assertion part && part->document && x >= 0 && y >= 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar4 = realloc_line(html_context,part->document,(part->box).y + y,x + (part->box).x);
    if (iVar4 < 0) {
      return;
    }
    if (assert_failed == 0) {
      assert_failed = (int)(part->document->data == (line *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x114;
        elinks_internal((uchar *)"assertion part->document->data failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      schar = part->document->data[(part->box).y + y].chars + x + (part->box).x;
      schar->attr = 0x80;
      schar->data = (uint)data;
      colors.background = bgcolor;
      colors.foreground = fgcolor;
      set_term_color(schar,&colors,(part->document->options).color_flags,
                     (part->document->options).color_mode);
      iVar4 = height + -1;
      while( true ) {
        if (iVar4 == 0) {
          return;
        }
        y = y + 1;
        iVar6 = realloc_line(html_context,part->document,(part->box).y + y,x + (part->box).x);
        if (iVar6 < 0) break;
        psVar5 = part->document->data[(part->box).y + y].chars + x + (part->box).x;
        psVar5->data = schar->data;
        uVar1 = schar->color[0];
        uVar2 = schar->color[1];
        uVar3 = schar->field_0x7;
        psVar5->attr = schar->attr;
        psVar5->color[0] = uVar1;
        psVar5->color[1] = uVar2;
        psVar5->field_0x7 = uVar3;
        iVar4 = iVar4 + -1;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

int split_line_at(html_context *html_context,int width)

{
  byte bVar1;
  part *ppVar2;
  part *ppVar3;
  screen_char *psVar4;
  part *ppVar5;
  int new_width;
  int iVar6;
  int iVar7;
  int iVar8;
  part *part_1;
  int yt;
  line *plVar9;
  int iVar10;
  size_t sVar11;
  int tmp;
  int iVar12;
  part *part;
  bool bVar13;
  document *local_60;
  document *local_50;
  int local_3c;
  int local_38;
  int local_30;
  int local_28;
  line *local_20;
  
  iVar7 = *(int *)((int)(html_context->stack).next + 0x7c);
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  ppVar2 = html_context->part;
  assert_failed = (int)(ppVar2 == (part *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x344;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  iVar7 = width + iVar7;
  if ((ppVar2->box).width < iVar7) {
    (ppVar2->box).width = iVar7;
  }
  if (ppVar2->document == (document *)0x0) {
LAB_08090588:
    bVar1 = html_context->options->field_0x5c;
joined_r0x0809058f:
    if ((bVar1 & 0x10) != 0) goto LAB_080906c8;
LAB_08090598:
    iVar7 = ppVar2->spaces_len;
LAB_0809059b:
    width = width + 1;
  }
  else {
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
    bVar13 = ppVar2->document->data == (line *)0x0;
    assert_failed = (int)bVar13;
    if (bVar13) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x34c;
      elinks_internal((uchar *)"assertion part->document->data failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return 0;
      }
    }
    if ((((html_context->options->field_0x5c & 0x10) != 0) && (width < ppVar2->spaces_len)) &&
       (ppVar2->char_width[width] == '\x02')) {
      iVar7 = ppVar2->cy;
      iVar12 = *(int *)((int)(html_context->stack).next + 0x78);
      ppVar3 = html_context->part;
      if (((ppVar3 == (part *)0x0) || (ppVar3->document == (document *)0x0)) ||
         (plVar9 = ppVar3->document->data, plVar9 == (line *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x2f8;
        elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!")
        ;
        if (assert_failed == 0) {
          plVar9 = ppVar3->document->data;
          goto LAB_08090455;
        }
        assert_failed = 0;
      }
      else {
        assert_failed = 0;
LAB_08090455:
        iVar8 = (ppVar3->box).x;
        iVar10 = plVar9[iVar7 + (ppVar3->box).y].length - iVar8;
        if (iVar10 < 0) {
          iVar10 = 0;
        }
        iVar10 = iVar10 - width;
        if (0 < iVar10) {
          yt = iVar7 + 1;
          psVar4 = plVar9[iVar7 + (ppVar3->box).y].chars;
          ppVar5 = html_context->part;
          if (((ppVar5 == (part *)0x0) || (local_50 = ppVar5->document, local_50 == (document *)0x0)
              ) || (local_50->data == (line *)0x0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x2e5;
            elinks_internal((uchar *)
                            "assertion width > 0 && part && part->document && part->document->data failed!"
                           );
            if (assert_failed == 0) {
              local_50 = ppVar5->document;
              goto LAB_080904d0;
            }
            assert_failed = 0;
          }
          else {
            assert_failed = 0;
LAB_080904d0:
            iVar6 = realloc_line(html_context,local_50,yt + (ppVar5->box).y,
                                 iVar10 + -1 + iVar12 + (ppVar5->box).x);
            if (-1 < iVar6) {
              memcpy(ppVar5->document->data[yt + (ppVar5->box).y].chars + iVar12 + (ppVar5->box).x,
                     psVar4 + width + iVar8,iVar10 * 8);
            }
          }
          ppVar3->document->data[iVar7 + (ppVar3->box).y].length = (ppVar3->box).x + width;
          move_links(html_context,width,iVar7,iVar12,yt);
        }
      }
      del_chars(html_context,width,ppVar2->cy);
      goto LAB_08090588;
    }
    bVar13 = ppVar2->document->data[ppVar2->cy + (ppVar2->box).y].chars[(ppVar2->box).x + width].
             data != 0x20;
    assert_failed = (int)bVar13;
    if (bVar13) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x357;
      elinks_internal((uchar *)"assertion POS(width, part->cy).data == \' \' failed: bad split: %c",
                      ppVar2->document->data[ppVar2->cy + (ppVar2->box).y].chars
                      [(ppVar2->box).x + width].data);
      local_28 = ppVar2->cy;
      local_38 = *(int *)((int)(html_context->stack).next + 0x78);
      if (assert_failed == 0) goto LAB_08090730;
LAB_08090a04:
      local_28 = ppVar2->cy;
LAB_08090a0a:
      ppVar3 = html_context->part;
      if (((ppVar3 == (part *)0x0) || (ppVar3->document == (document *)0x0)) ||
         (local_20 = ppVar3->document->data, local_20 == (line *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x329;
        elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!")
        ;
        if (assert_failed != 0) goto LAB_080908a5;
        local_20 = ppVar3->document->data;
      }
      else {
        assert_failed = 0;
      }
      local_20[local_28 + (ppVar3->box).y].length = (ppVar3->box).x + width;
      move_links(html_context,width,local_28,-1,-1);
      bVar1 = html_context->options->field_0x5c;
      goto joined_r0x0809058f;
    }
    local_28 = ppVar2->cy;
    local_38 = *(int *)((int)(html_context->stack).next + 0x78);
LAB_08090730:
    local_30 = width + 1;
    local_3c = local_28 + 1;
    ppVar3 = html_context->part;
    if (((ppVar3 == (part *)0x0) || (ppVar3->document == (document *)0x0)) ||
       (plVar9 = ppVar3->document->data, plVar9 == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x2f8;
      elinks_internal((uchar *)"assertion part && part->document && part->document->data failed!");
      if (assert_failed != 0) goto LAB_08090a04;
      plVar9 = ppVar3->document->data;
    }
    iVar7 = (ppVar3->box).x;
    iVar12 = plVar9[local_28 + (ppVar3->box).y].length - iVar7;
    if (iVar12 < 0) {
      iVar12 = 0;
    }
    iVar12 = iVar12 - local_30;
    if (iVar12 < 1) goto LAB_08090a04;
    psVar4 = plVar9[local_28 + (ppVar3->box).y].chars;
    ppVar5 = html_context->part;
    if (((ppVar5 == (part *)0x0) || (local_60 = ppVar5->document, local_60 == (document *)0x0)) ||
       (local_60->data == (line *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x2e5;
      elinks_internal((uchar *)
                      "assertion width > 0 && part && part->document && part->document->data failed!"
                     );
      if (assert_failed == 0) {
        local_60 = ppVar5->document;
        goto LAB_080907e2;
      }
      assert_failed = 0;
    }
    else {
      assert_failed = 0;
LAB_080907e2:
      iVar8 = realloc_line(html_context,local_60,local_3c + (ppVar5->box).y,
                           local_38 + -1 + (ppVar5->box).x + iVar12);
      if (-1 < iVar8) {
        memcpy(ppVar5->document->data[local_3c + (ppVar5->box).y].chars + local_38 + (ppVar5->box).x
               ,psVar4 + local_30 + iVar7,iVar12 * 8);
      }
    }
    ppVar3->document->data[local_28 + (ppVar3->box).y].length = local_30 + (ppVar3->box).x;
    move_links(html_context,local_30,local_28,local_38,local_3c);
    local_28 = ppVar2->cy;
    if (assert_failed == 0) goto LAB_08090a0a;
LAB_080908a5:
    assert_failed = 0;
    if ((html_context->options->field_0x5c & 0x10) == 0) goto LAB_08090598;
LAB_080906c8:
    iVar7 = ppVar2->spaces_len;
    if ((iVar7 <= width) || (ppVar2->char_width[width] != '\x02')) goto LAB_0809059b;
  }
  sVar11 = iVar7 - width;
  if (0 < (int)sVar11) {
    memmove(ppVar2->spaces,ppVar2->spaces + width,sVar11);
    memmove(ppVar2->char_width,ppVar2->char_width + width,sVar11);
  }
  if (assert_failed == 0) {
    assert_failed = -((int)sVar11 >> 0x1f);
    if (assert_failed == 0) goto LAB_080905fb;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x36e;
    elinks_internal((uchar *)"assertion tmp >= 0 failed!");
    if (assert_failed == 0) goto LAB_080905fb;
  }
  assert_failed = 0;
  sVar11 = 0;
LAB_080905fb:
  memset(ppVar2->spaces + sVar11,0,width);
  memset(ppVar2->char_width + sVar11,0,width);
  iVar7 = *(int *)((int)(html_context->stack).next + 0x78);
  if (0 < iVar7) {
    sVar11 = ppVar2->spaces_len - iVar7;
    if (assert_failed == 0) {
      assert_failed = (int)((int)sVar11 < 1);
      if (assert_failed == 0) {
        iVar7 = *(int *)((int)(html_context->stack).next + 0x78);
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 0x377;
        elinks_internal((uchar *)
                        "assertion tmp > 0 failed: part->spaces_len - par_format.leftmargin == %d",
                        sVar11);
        iVar7 = *(int *)((int)(html_context->stack).next + 0x78);
      }
    }
    memmove(ppVar2->spaces + iVar7,ppVar2->spaces,sVar11);
    memmove(ppVar2->char_width + *(int *)((int)(html_context->stack).next + 0x78),ppVar2->char_width
            ,sVar11);
  }
  iVar12 = ppVar2->cy;
  iVar7 = iVar12 + 1;
  ppVar2->cy = iVar7;
  if (ppVar2->cx == width) {
    iVar12 = (ppVar2->box).height;
    iVar8 = 2;
    ppVar2->cx = -1;
    if (iVar12 < iVar7) {
      (ppVar2->box).height = iVar7;
      return 2;
    }
  }
  else {
    iVar12 = iVar12 + 2;
    iVar8 = 1;
    iVar7 = (ppVar2->box).height;
    ppVar2->cx = (ppVar2->cx + *(int *)((int)(html_context->stack).next + 0x78)) - width;
    if (iVar7 < iVar12) {
      (ppVar2->box).height = iVar12;
      return 1;
    }
  }
  return iVar8;
}



// WARNING: Unknown calling convention

void put_chars(html_context *html_context,uchar *chars,int charslen)

{
  byte bVar1;
  part *ppVar2;
  part *ppVar3;
  form_control *pfVar4;
  part *ppVar5;
  int iVar6;
  int iVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  text_style style;
  undefined uVar11;
  uchar uVar12;
  undefined uVar13;
  int pos;
  int iVar14;
  void *p_2;
  void *p_1;
  void *p;
  int x_offset;
  int iVar15;
  int x;
  ushort **ppuVar16;
  uchar *puVar17;
  uchar *puVar18;
  uchar *puVar19;
  size_t newsize_2;
  uint uVar20;
  point *point;
  int x_2;
  unicode_val_T data;
  unicode_val_T uVar21;
  byte *pbVar22;
  byte *pbVar23;
  int orig_length;
  uchar i;
  form *form;
  form *pfVar24;
  uchar *puVar25;
  color_T cVar26;
  list_head_elinks *plVar27;
  void **ppvVar28;
  void *pvVar29;
  int iVar30;
  point *ppVar31;
  link *plVar32;
  screen_char *psVar33;
  int cells;
  uchar i_1;
  form_control *ff;
  document_options *options;
  part *part_1;
  int y;
  int x_3;
  uchar uVar34;
  byte *pbVar35;
  size_t newsize_1;
  size_t sVar36;
  unicode_val_T c;
  text_style *ptVar37;
  int utf8;
  size_t newsize;
  int iVar38;
  int x_offset_1;
  int x_1;
  uchar *new_name;
  part *part;
  unicode_val_T data_1;
  document *pdVar39;
  char *pcVar40;
  int iVar41;
  int length;
  uint uVar42;
  part *part_3;
  uchar *name;
  int in_GS_OFFSET;
  bool bVar43;
  byte bVar44;
  int local_9c;
  byte *local_98;
  int local_94;
  byte *local_90;
  int local_8c;
  link *local_84;
  text_style final_style;
  uchar *local_68;
  byte *local_64;
  uchar s [64];
  int local_20;
  
  bVar44 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_90 = chars;
  if (assert_failed != 0) {
LAB_08091010:
    assert_failed = 0;
    goto LAB_0809101a;
  }
  assert_failed = (int)(html_context == (html_context *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x62a;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) goto LAB_08091010;
  }
  ppVar2 = html_context->part;
  assert_failed = (int)(ppVar2 == (part *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x62f;
    elinks_internal((uchar *)"assertion part failed!");
    if (assert_failed != 0) goto LAB_08091010;
  }
  assert_failed = (int)(charslen == 0 || chars == (uchar *)0x0);
  if (charslen == 0 || chars == (uchar *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x632;
    elinks_internal((uchar *)"assertion chars && charslen failed!");
    if (assert_failed != 0) goto LAB_08091010;
  }
  if (ppVar2->cx == -1) {
    pvVar29 = (html_context->stack).next;
    if ((*(byte *)((int)pvVar29 + 0xc) & 0x20) == 0) {
      if (charslen == 0) goto LAB_0809101a;
      bVar1 = *chars;
      while (bVar1 == 0x20) {
        charslen = charslen + -1;
        if (charslen == 0) goto LAB_0809101a;
        local_90 = local_90 + 1;
        bVar1 = *local_90;
      }
      if (charslen < 1) goto LAB_0809101a;
    }
    ppVar2->cx = *(int *)((int)pvVar29 + 0x78);
    if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0) goto LAB_08091038;
LAB_08090d0f:
    renderer_context.last_tag_for_newline = (tag *)&ppVar2->document->tags;
  }
  else {
    if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) != 0) goto LAB_08090d0f;
LAB_08091038:
    if (0 < charslen) {
      ppuVar16 = __ctype_b_loc();
      iVar14 = 0;
      do {
        if ((*(byte *)((int)*ppuVar16 + (uint)local_90[iVar14] * 2 + 1) & 0x20) == 0)
        goto LAB_08090d0f;
        iVar14 = iVar14 + 1;
      } while (iVar14 < charslen);
    }
  }
  iVar14 = ppVar2->cy + 1;
  if ((ppVar2->box).height < iVar14) {
    (ppVar2->box).height = iVar14;
  }
  pvVar29 = (html_context->stack).next;
  if (((*(uchar **)((int)pvVar29 + 0x1c) == (uchar *)0x0) && (*(int *)((int)pvVar29 + 0x24) == 0))
     && (local_8c = 0, *(int *)((int)pvVar29 + 0x2c) == 0)) {
LAB_08090d69:
    if (renderer_context.link_state_info.link != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.link);
    }
LAB_08090d7a:
    if (renderer_context.link_state_info.target != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.target);
    }
    if (renderer_context.link_state_info.image != (uchar *)0x0) {
      mem_free(renderer_context.link_state_info.image);
    }
    bVar43 = local_8c == 1;
    renderer_context.link_state_info.link = (uchar *)0x0;
    renderer_context.link_state_info.target = (uchar *)0x0;
    renderer_context.link_state_info.image = (uchar *)0x0;
    renderer_context.link_state_info.form = (form_control *)0x0;
    if (bVar43) {
      iVar14 = 0;
      if (charslen < 1) {
LAB_080918d5:
        bVar43 = iVar14 == charslen;
        if (bVar43) goto LAB_08090dd1;
      }
      else if (*local_90 < 0x21) {
        do {
          iVar14 = iVar14 + 1;
          if (charslen <= iVar14) break;
        } while (local_90[iVar14] < 0x21);
        goto LAB_080918d5;
      }
      bVar43 = (html_context->options->field_0x45 & 0x10) == 0;
      if (!bVar43) {
        pvVar29 = (html_context->stack).next;
        ppVar3 = html_context->part;
        uVar8 = *(undefined4 *)((int)pvVar29 + 0x1c);
        uVar9 = *(undefined4 *)((int)pvVar29 + 0x20);
        uVar10 = *(undefined4 *)((int)pvVar29 + 0x24);
        iVar14 = *(int *)((int)pvVar29 + 0x2c);
        *(undefined4 *)((int)pvVar29 + 0x24) = 0;
        *(undefined4 *)((int)pvVar29 + 0x20) = 0;
        *(undefined4 *)((int)pvVar29 + 0x1c) = 0;
        *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
        s[0] = '[';
        local_64 = (byte *)0x1;
        elinks_ulongcat(s,(uint *)&local_64,ppVar3->link_num,0x3d,'\0',10,0);
        renderer_context._48_1_ = renderer_context._48_1_ | 4;
        s[(int)local_64] = ']';
        local_64 = local_64 + 1;
        s[(int)local_64] = '\0';
        put_chars(html_context,s,(int)local_64);
        renderer_context._48_1_ = renderer_context._48_1_ & 0xfb;
        if ((iVar14 != 0) && (*(int *)(iVar14 + 0x14) == 3)) {
          line_break(html_context);
        }
        bVar43 = ppVar3->cx == -1;
        if (bVar43) {
          ppVar3->cx = *(int *)((int)(html_context->stack).next + 0x78);
        }
        *(undefined4 *)((int)(html_context->stack).next + 0x1c) = uVar8;
        *(undefined4 *)((int)(html_context->stack).next + 0x20) = uVar9;
        *(undefined4 *)((int)(html_context->stack).next + 0x24) = uVar10;
        *(int *)((int)(html_context->stack).next + 0x2c) = iVar14;
        pvVar29 = (html_context->stack).next;
        goto LAB_08090dde;
      }
    }
    else {
LAB_08090dd1:
      local_8c = 0;
    }
    pvVar29 = (html_context->stack).next;
  }
  else {
    if (((renderer_context.link_state_info.link == (uchar *)0x0) &&
        (renderer_context.link_state_info.image == (uchar *)0x0)) &&
       (local_8c = 1, renderer_context.link_state_info.form == (form_control *)0x0))
    goto LAB_08090d7a;
    iVar14 = xstrcmp(*(uchar **)((int)pvVar29 + 0x1c),renderer_context.link_state_info.link);
    if (((iVar14 != 0) ||
        (iVar14 = xstrcmp(*(uchar **)((int)(html_context->stack).next + 0x20),
                          renderer_context.link_state_info.target), iVar14 != 0)) ||
       (iVar14 = xstrcmp(*(uchar **)((int)(html_context->stack).next + 0x24),
                         renderer_context.link_state_info.image), iVar14 != 0)) {
LAB_08090d5f:
      local_8c = 1;
      goto LAB_08090d69;
    }
    pvVar29 = (html_context->stack).next;
    bVar43 = *(form_control **)((int)pvVar29 + 0x2c) == renderer_context.link_state_info.form;
    local_8c = 2;
    if (!bVar43) goto LAB_08090d5f;
  }
LAB_08090dde:
  local_64 = local_90;
  ppVar3 = html_context->part;
  iVar14 = 0xc;
  ptVar37 = &get_format_screen_char::ta_cache;
  pcVar40 = (char *)((int)pvVar29 + 0xc);
  do {
    if (iVar14 == 0) break;
    iVar14 = iVar14 + -1;
    bVar43 = *(char *)&ptVar37->attr == *pcVar40;
    ptVar37 = (text_style *)((int)ptVar37 + (uint)bVar44 * -2 + 1);
    pcVar40 = pcVar40 + (uint)bVar44 * -2 + 1;
  } while (bVar43);
  if (!bVar43) {
    get_format_screen_char::ta_cache.attr = *(text_style_format *)((int)pvVar29 + 0xc);
    get_format_screen_char::ta_cache.fg = *(color_T *)((int)pvVar29 + 0x10);
    get_format_screen_char::ta_cache.bg = *(color_T *)((int)pvVar29 + 0x14);
    pvVar29 = (html_context->stack).next;
    uVar20 = *(uint *)((int)pvVar29 + 0xc);
    if (local_8c == 0) {
      options = html_context->options;
    }
    else {
      options = html_context->options;
      if ((options->field_0x45 & 1) != 0) {
        uVar20 = uVar20 | 4;
      }
    }
    style.fg = *(undefined4 *)((int)pvVar29 + 0x10);
    style.attr = uVar20;
    style.bg = *(undefined4 *)((int)pvVar29 + 0x14);
    get_screen_char_template(&get_format_screen_char::schar_cache,options,style);
  }
  if (((byte)renderer_context._48_1_ >> 2 & 1) !=
      ((byte)get_format_screen_char::schar_cache._4_4_ & 1)) {
    get_format_screen_char::schar_cache._4_4_ = get_format_screen_char::schar_cache._4_4_ ^ 1;
  }
  iVar14 = ppVar3->cx;
  iVar38 = ppVar3->cy;
  bVar44 = html_context->options->field_0x5c;
  if (assert_failed == 0) {
    assert_failed = -(charslen >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x177;
      elinks_internal((uchar *)"assertion charslen >= 0 failed!");
    }
    bVar44 = bVar44 >> 4 & 1;
    local_98 = (byte *)(iVar14 + charslen);
    if ((int)local_98 < ppVar3->spaces_len) {
LAB_08090eec:
      if (ppVar3->document == (document *)0x0) {
        if (bVar44 == 0) {
          iVar38 = charslen;
          if (0 < charslen) {
            while( true ) {
              ppVar3->char_width[iVar14] = '\x01';
              if (*local_64 == 1) {
                ppVar3->spaces[iVar14] = (byte)html_context->options->field_0x45 >> 1 & 1;
              }
              else {
                ppVar3->spaces[iVar14] = *local_64 == 0x20;
              }
              local_64 = local_64 + 1;
              if (iVar38 + -1 == 0) break;
              iVar14 = iVar14 + 1;
              iVar38 = iVar38 + -1;
            }
          }
          local_94 = charslen;
        }
        else {
          pbVar35 = local_64 + charslen;
          local_94 = iVar14;
          while (local_64 < pbVar35) {
            uVar21 = utf8_to_unicode(&local_64,pbVar35);
            if (uVar21 != 0xad) {
              if (uVar21 == 0xa0) {
                bVar44 = html_context->options->field_0x45 & 2;
                uVar34 = '\x01' - (bVar44 == 0);
                c = 0x20;
                if (bVar44 == 0) {
                  c = uVar21;
                }
              }
              else {
                uVar34 = uVar21 == 0x20;
                c = uVar21;
              }
              ppVar3->spaces[local_94] = uVar34;
              puVar25 = ppVar3->char_width;
              iVar38 = unicode_to_cell(c);
              puVar25[local_94] = (uchar)iVar38;
              if (ppVar3->char_width[local_94] == '\x02') {
                local_94 = local_94 + 1;
                ppVar3->spaces[local_94] = '\0';
                ppVar3->char_width[local_94] = '\0';
              }
              if (c == 0xfffffffd) break;
              local_94 = local_94 + 1;
            }
          }
          local_94 = local_94 - iVar14;
        }
      }
      else {
        iVar15 = realloc_line(html_context,ppVar3->document,(ppVar3->box).y + iVar38,
                              (ppVar3->box).x + charslen + iVar14);
        if (iVar15 < 0) goto LAB_08091e30;
        if (bVar44 == 0) {
          iVar30 = iVar14;
          iVar41 = charslen;
          if (0 < charslen) {
            do {
              ppVar3->char_width[iVar30] = '\x01';
              if (*local_64 == 1) {
                get_format_screen_char::schar_cache.data = 0x20;
                ppVar3->spaces[iVar30] = (byte)html_context->options->field_0x45 >> 1 & 1;
              }
              else {
                ppVar3->spaces[iVar30] = *local_64 == 0x20;
                get_format_screen_char::schar_cache.data = (unicode_val_T)*local_64;
              }
              iVar41 = iVar41 + -1;
              psVar33 = ppVar3->document->data[(ppVar3->box).y + iVar38].chars +
                        iVar30 + (ppVar3->box).x;
              psVar33->data = get_format_screen_char::schar_cache.data;
              uVar34 = get_format_screen_char::schar_cache.color[0];
              uVar12 = get_format_screen_char::schar_cache.color[1];
              uVar11 = get_format_screen_char::schar_cache._7_1_;
              psVar33->attr = get_format_screen_char::schar_cache.attr;
              psVar33->color[0] = uVar34;
              psVar33->color[1] = uVar12;
              psVar33->field_0x7 = uVar11;
              local_64 = local_64 + 1;
              iVar30 = iVar30 + 1;
            } while (0 < iVar41);
            goto LAB_08091d43;
          }
          local_94 = 0;
          local_98 = (byte *)iVar14;
        }
        else {
          pbVar35 = local_64 + charslen;
          local_98 = (byte *)iVar14;
          if (ppVar3->document->buf_length != '\0') {
            iVar30 = utf8charlen(ppVar3->document->buf);
            local_68 = ppVar3->document->buf;
            pdVar39 = ppVar3->document;
            bVar44 = pdVar39->buf_length;
            uVar20 = (uint)bVar44;
            if (((int)uVar20 < iVar30) && (local_64 < pbVar35)) {
              while( true ) {
                bVar1 = *local_64;
                bVar44 = bVar44 + 1;
                local_64 = local_64 + 1;
                pdVar39->buf[uVar20] = bVar1;
                uVar20 = (uint)bVar44;
                if ((iVar30 <= (int)uVar20) || (pbVar35 <= local_64)) break;
                pdVar39 = ppVar3->document;
              }
              pdVar39 = ppVar3->document;
            }
            pdVar39->buf_length = bVar44;
            ppVar3->document->buf[uVar20] = '\0';
            uVar21 = utf8_to_unicode(&local_68,local_68 + bVar44);
            if (uVar21 != 0xfffffffd) {
              ppVar3->document->buf_length = '\0';
              goto good_char;
            }
            ppVar3->document->data[(ppVar3->box).y + iVar38].length = iVar15;
            local_94 = 0;
            goto LAB_0809108b;
          }
          while (local_64 < pbVar35) {
LAB_08091c26:
            uVar21 = utf8_to_unicode(&local_64,pbVar35);
            if (uVar21 == 0xfffffffd) {
              ppVar3->spaces[(int)local_98] = '\0';
              if (charslen == 1) goto LAB_0809256f;
              uVar34 = '\0';
              pbVar22 = local_64;
              if (local_64 < pbVar35) {
                do {
                  pbVar23 = pbVar22 + 1;
                  ppVar3->document->buf[(byte)((char)pbVar22 - (char)local_64)] = *pbVar22;
                  pbVar22 = pbVar23;
                } while (pbVar23 < pbVar35);
                local_9c._0_1_ = (char)pbVar35;
                uVar34 = (char)local_9c - (char)local_64;
                local_64 = pbVar23;
              }
              ppVar3->document->buf_length = uVar34;
              local_94 = (int)local_98 - iVar14;
              goto LAB_08091cc9;
            }
good_char:
            if (uVar21 != 0xad) {
              if (uVar21 == 0xa0) {
                bVar44 = html_context->options->field_0x45 & 2;
                uVar34 = '\x01' - (bVar44 == 0);
                if (bVar44 != 0) {
                  uVar21 = 0x20;
                }
              }
              else {
                uVar34 = uVar21 == 0x20;
              }
              ppVar3->spaces[(int)local_98] = uVar34;
              iVar30 = unicode_to_cell(uVar21);
              if (iVar30 == 2) {
                get_format_screen_char::schar_cache.data = uVar21;
                ppVar3->char_width[(int)local_98] = '\x02';
                iVar30 = (int)local_98 + (ppVar3->box).x;
                local_98 = (byte *)((int)local_98 + 1);
                psVar33 = ppVar3->document->data[(ppVar3->box).y + iVar38].chars + iVar30;
                psVar33->data = get_format_screen_char::schar_cache.data;
                uVar34 = get_format_screen_char::schar_cache.color[0];
                uVar12 = get_format_screen_char::schar_cache.color[1];
                uVar11 = get_format_screen_char::schar_cache._7_1_;
                psVar33->attr = get_format_screen_char::schar_cache.attr;
                psVar33->color[0] = uVar34;
                psVar33->color[1] = uVar12;
                psVar33->field_0x7 = uVar11;
                get_format_screen_char::schar_cache.data = 0xfffffffd;
                ppVar3->spaces[(int)local_98] = '\0';
                ppVar3->char_width[(int)local_98] = '\0';
              }
              else {
                puVar25 = ppVar3->char_width;
                iVar30 = unicode_to_cell(uVar21);
                puVar25[(int)local_98] = (uchar)iVar30;
                get_format_screen_char::schar_cache.data = uVar21;
              }
              psVar33 = ppVar3->document->data[(ppVar3->box).y + iVar38].chars +
                        (ppVar3->box).x + (int)local_98;
              local_98 = (byte *)((int)local_98 + 1);
              psVar33->data = get_format_screen_char::schar_cache.data;
              uVar34 = get_format_screen_char::schar_cache.color[0];
              uVar12 = get_format_screen_char::schar_cache.color[1];
              uVar11 = get_format_screen_char::schar_cache._7_1_;
              psVar33->attr = get_format_screen_char::schar_cache.attr;
              psVar33->color[0] = uVar34;
              psVar33->color[1] = uVar12;
              psVar33->field_0x7 = uVar11;
            }
          }
LAB_08091d43:
          local_94 = (int)local_98 - iVar14;
        }
LAB_08091cc9:
        if ((assert_failed == 0) &&
           (bVar43 = ppVar3->document->data[(ppVar3->box).y + iVar38].length <
                     (ppVar3->box).x + (int)local_98, assert_failed = (int)bVar43, bVar43)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x206;
          elinks_internal((uchar *)"assertion X(x) <= LINE(y).length failed!");
        }
        iVar14 = (ppVar3->box).x + (int)local_98;
        if (iVar14 < iVar15) {
          iVar14 = iVar15;
        }
        ppVar3->document->data[(ppVar3->box).y + iVar38].length = iVar14;
      }
    }
    else {
      uVar20 = (int)local_98 + 0x7fU & 0xffffff80;
      uVar42 = ppVar3->spaces_len + 0x7fU & 0xffffff80;
      if (uVar42 < uVar20) {
        puVar25 = (uchar *)mem_realloc(ppVar3->spaces,uVar20);
        if (puVar25 != (uchar *)0x0) {
          ppVar3->spaces = puVar25;
          memset(puVar25 + uVar42,0,uVar20 - uVar42);
          goto LAB_08091a66;
        }
      }
      else {
LAB_08091a66:
        if (ppVar3->spaces != (uchar *)0x0) {
          uVar42 = ppVar3->spaces_len + 0x7fU & 0xffffff80;
          if (uVar42 < uVar20) {
            puVar25 = (uchar *)mem_realloc(ppVar3->char_width,uVar20);
            if (puVar25 == (uchar *)0x0) goto LAB_08091e30;
            ppVar3->char_width = puVar25;
            memset(puVar25 + uVar42,0,uVar20 - uVar42);
          }
          if (ppVar3->char_width != (uchar *)0x0) {
            ppVar3->spaces_len = (int)local_98;
            goto LAB_08090eec;
          }
        }
      }
LAB_08091e30:
      local_94 = 0;
    }
  }
  else {
    assert_failed = 0;
    local_94 = charslen;
  }
LAB_0809108b:
  if (local_8c != 0) {
    ppVar3 = html_context->part;
    iVar14 = local_94;
    if (local_8c == 2) {
      if (ppVar3->document != (document *)0x0) {
        if (assert_failed != 0) goto LAB_08091318;
        assert_failed = (int)(ppVar3->document->nlinks < 1);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x5a6;
          elinks_internal((uchar *)"assertion part->document->nlinks > 0 failed: no link");
          if (assert_failed != 0) goto LAB_08091318;
        }
        local_84 = ppVar3->document->links + ppVar3->document->nlinks + -1;
        if (((local_84->type < LINK_BUTTON) &&
            (puVar25 = (local_84->data).name, puVar25 != (uchar *)0x0)) &&
           (puVar19 = straconcat(puVar25,local_90,0), puVar19 != (uchar *)0x0)) {
          mem_free(puVar25);
          (local_84->data).name = puVar19;
          iVar38 = 0;
        }
        else {
          iVar38 = 0;
        }
LAB_08091673:
        uVar20 = local_84->npoints;
        if (uVar20 < iVar14 + uVar20) {
          sVar36 = (iVar14 + uVar20) * 8;
          ppVar31 = (point *)mem_realloc(local_84->points,sVar36);
          if (ppVar31 == (point *)0x0) goto LAB_08091322;
          local_84->points = ppVar31;
          memset(ppVar31 + uVar20,0,sVar36 + uVar20 * -8);
        }
        if (local_84->points != (point *)0x0) {
          iVar15 = local_84->npoints;
          iVar30 = (ppVar3->box).x;
          iVar41 = ppVar3->cx;
          iVar6 = ppVar3->cy;
          iVar7 = (ppVar3->box).y;
          local_84->npoints = iVar15 + iVar14;
          if (0 < iVar14) {
            ppVar31 = local_84->points + iVar15;
            iVar38 = iVar41 + iVar30 + iVar38;
            do {
              ppVar31->x = iVar38;
              iVar38 = iVar38 + 1;
              ppVar31->y = iVar6 + iVar7;
              ppVar31 = ppVar31 + 1;
              iVar14 = iVar14 + -1;
            } while (iVar14 != 0);
          }
        }
      }
    }
    else {
      ppVar3->link_num = ppVar3->link_num + 1;
      pvVar29 = (html_context->stack).next;
      pfVar4 = *(form_control **)((int)pvVar29 + 0x2c);
      puVar25 = *(uchar **)((int)pvVar29 + 0x24);
      puVar19 = *(uchar **)((int)pvVar29 + 0x20);
      puVar18 = *(uchar **)((int)pvVar29 + 0x1c);
      if (assert_failed == 0) {
        assert_failed = (int)(renderer_context.link_state_info.image != (uchar *)0x0);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x57e;
          elinks_internal((uchar *)
                          "assertion !(renderer_context.link_state_info.image) failed: Old link value [%s]. New value [%s]"
                          ,renderer_context.link_state_info.image,puVar25);
          if (assert_failed != 0) goto LAB_080910df;
        }
        assert_failed = (int)(renderer_context.link_state_info.target != (uchar *)0x0);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x57f;
          elinks_internal((uchar *)
                          "assertion !(renderer_context.link_state_info.target) failed: Old link value [%s]. New value [%s]"
                          ,renderer_context.link_state_info.target,puVar19);
          if (assert_failed != 0) goto LAB_080910df;
        }
        assert_failed = (int)(renderer_context.link_state_info.link != (uchar *)0x0);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x580;
          elinks_internal((uchar *)
                          "assertion !(renderer_context.link_state_info.link) failed: Old link value [%s]. New value [%s]"
                          ,renderer_context.link_state_info.link,puVar18);
        }
      }
LAB_080910df:
      puVar17 = (uchar *)0x0;
      if (puVar18 != (uchar *)0x0) {
        puVar17 = stracpy(puVar18);
      }
      puVar18 = (uchar *)0x0;
      renderer_context.link_state_info.link = puVar17;
      if (puVar19 != (uchar *)0x0) {
        puVar18 = stracpy(puVar19);
      }
      puVar19 = (uchar *)0x0;
      renderer_context.link_state_info.target = puVar18;
      if (puVar25 != (uchar *)0x0) {
        puVar19 = stracpy(puVar25);
      }
      renderer_context.link_state_info.image = puVar19;
      renderer_context.link_state_info.form = pfVar4;
      if (ppVar3->document != (document *)0x0) {
        if ((charslen < 1) || (0x20 < *local_90)) {
          iVar38 = 0;
          local_9c = charslen;
          local_98 = local_90;
        }
        else {
          iVar38 = 0;
          do {
            iVar38 = iVar38 + 1;
            if (charslen <= iVar38) break;
          } while (local_90[iVar38] < 0x21);
          if (iVar38 == 0) {
            local_9c = charslen;
            local_98 = local_90;
          }
          else {
            local_9c = charslen - iVar38;
            local_98 = local_90 + iVar38;
            iVar14 = local_94 - iVar38;
          }
        }
        if (assert_failed == 0) {
          ppVar5 = html_context->part;
          assert_failed = (int)(ppVar5 == (part *)0x0);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x4cf;
            elinks_internal((uchar *)"assertion part failed!");
            if (assert_failed != 0) goto LAB_08091318;
          }
          pdVar39 = ppVar5->document;
          assert_failed = (int)(pdVar39 == (document *)0x0);
          if (pdVar39 == (document *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 0x4d4;
            elinks_internal((uchar *)"assertion document failed!");
            if (assert_failed != 0) goto LAB_08091318;
          }
          iVar15 = ppVar5->link_num;
          uVar20 = pdVar39->nlinks + 0x80U & 0xffffff80;
          uVar42 = pdVar39->nlinks + 0x7fU & 0xffffff80;
          if (uVar42 < uVar20) {
            sVar36 = uVar20 * 0x34;
            plVar32 = (link *)mem_realloc(pdVar39->links,sVar36);
            if (plVar32 == (link *)0x0) goto LAB_08091322;
            pdVar39->links = plVar32;
            memset(plVar32 + uVar42,0,sVar36 + uVar42 * -0x34);
          }
          if (pdVar39->links != (link *)0x0) {
            local_84 = pdVar39->links + pdVar39->nlinks;
            pdVar39->nlinks = pdVar39->nlinks + 1;
            iVar15 = iVar15 + -1;
            local_84->number = iVar15;
            if (((pdVar39->options).field_0x45 & 0x20) != 0) {
              local_84->number = iVar15 + *(int *)((int)(html_context->stack).next + 0x50);
            }
            local_84->accesskey = *(unicode_val_T *)((int)(html_context->stack).next + 0x54);
            puVar25 = *(uchar **)((int)(html_context->stack).next + 0x28);
            puVar19 = (uchar *)0x0;
            if (puVar25 != (uchar *)0x0) {
              puVar19 = stracpy(puVar25);
            }
            local_84->title = puVar19;
            puVar25 = *(uchar **)((int)(html_context->stack).next + 0x24);
            puVar19 = (uchar *)0x0;
            if (puVar25 != (uchar *)0x0) {
              puVar19 = stracpy(puVar25);
            }
            local_84->where_img = puVar19;
            pvVar29 = (html_context->stack).next;
            pfVar4 = *(form_control **)((int)pvVar29 + 0x2c);
            if (pfVar4 == (form_control *)0x0) {
              puVar25 = *(uchar **)((int)pvVar29 + 0x20);
              puVar19 = (uchar *)0x0;
              if (puVar25 != (uchar *)0x0) {
                puVar19 = stracpy(puVar25);
              }
              local_84->target = puVar19;
              puVar25 = memacpy(local_98,local_9c);
              (local_84->data).name = puVar25;
              pbVar35 = *(byte **)((int)(html_context->stack).next + 0x1c);
              if (((pbVar35 == (byte *)0x0) || ((*pbVar35 | 0x20) != 0x6d)) ||
                 (((pbVar35[1] | 0x20) != 0x61 ||
                  ((((pbVar35[2] | 0x20) != 0x70 || (pbVar35[3] != 0x40)) || (pbVar35[4] == 0))))))
              {
                local_84->type = LINK_HYPERTEXT;
                puVar25 = *(uchar **)((int)(html_context->stack).next + 0x1c);
                puVar19 = (uchar *)0x0;
                if (puVar25 != (uchar *)0x0) {
                  puVar19 = stracpy(puVar25);
                }
                local_84->where = puVar19;
              }
              else {
                local_84->type = LINK_MAP;
                puVar25 = stracpy((uchar *)(*(int *)((int)(html_context->stack).next + 0x1c) + 4));
                local_84->where = puVar25;
              }
            }
            else {
              if (pfVar4->type < 0xc) {
                switch(pfVar4->type) {
                case FC_TEXT:
                case FC_PASSWORD:
                case FC_FILE:
                  local_84->type = LINK_FIELD;
                  break;
                case FC_TEXTAREA:
                  local_84->type = LINK_AREA;
                  break;
                case FC_CHECKBOX:
                case FC_RADIO:
                  local_84->type = LINK_CHECKBOX;
                  break;
                case FC_SELECT:
                  local_84->type = LINK_SELECT;
                  break;
                default:
                  local_84->type = LINK_BUTTON;
                }
              }
              (local_84->data).form_control = pfVar4;
              pfVar24 = pfVar4->form;
              if (((pfVar24 == (form *)0x0) &&
                  ((pfVar24 = (form *)(pdVar39->forms).next, pfVar24 == (form *)&pdVar39->forms ||
                   (pfVar24 == (form *)0x0)))) || (pfVar24->target == (uchar *)0x0)) {
                puVar25 = (uchar *)0x0;
              }
              else {
                puVar25 = stracpy(pfVar24->target);
              }
              local_84->target = puVar25;
            }
            (local_84->color).background = *(color_T *)((int)(html_context->stack).next + 0x14);
            if (local_84->type + ~LINK_SELECT < 2) {
              cVar26 = *(color_T *)((int)(html_context->stack).next + 0x10);
            }
            else {
              cVar26 = *(color_T *)((int)(html_context->stack).next + 0x30);
            }
            (local_84->color).foreground = cVar26;
            plVar27 = (list_head_elinks *)mem_calloc(1,8);
            local_84->event_hooks = plVar27;
            if (plVar27 != (list_head_elinks *)0x0) {
              plVar27->prev = plVar27;
              plVar27->next = plVar27;
              pvVar29 = (html_context->stack).next;
              if (*(int *)((int)pvVar29 + 0x58) != 0) {
                ppvVar28 = (void **)mem_calloc(1,0x10);
                if (ppvVar28 == (void **)0x0) {
                  pvVar29 = (html_context->stack).next;
                }
                else {
                  ppvVar28[2] = (void *)0x0;
                  puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 0x58));
                  ppvVar28[3] = puVar25;
                  *ppvVar28 = local_84->event_hooks->next;
                  ppvVar28[1] = local_84->event_hooks;
                  local_84->event_hooks->next = ppvVar28;
                  *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
                  pvVar29 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar29 + 0x5c) != 0) {
                ppvVar28 = (void **)mem_calloc(1,0x10);
                if (ppvVar28 == (void **)0x0) {
                  pvVar29 = (html_context->stack).next;
                }
                else {
                  ppvVar28[2] = (void *)0x1;
                  puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 0x5c));
                  ppvVar28[3] = puVar25;
                  *ppvVar28 = local_84->event_hooks->next;
                  ppvVar28[1] = local_84->event_hooks;
                  local_84->event_hooks->next = ppvVar28;
                  *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
                  pvVar29 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar29 + 0x60) != 0) {
                ppvVar28 = (void **)mem_calloc(1,0x10);
                if (ppvVar28 == (void **)0x0) {
                  pvVar29 = (html_context->stack).next;
                }
                else {
                  ppvVar28[2] = (void *)0x2;
                  puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 0x60));
                  ppvVar28[3] = puVar25;
                  *ppvVar28 = local_84->event_hooks->next;
                  ppvVar28[1] = local_84->event_hooks;
                  local_84->event_hooks->next = ppvVar28;
                  *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
                  pvVar29 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar29 + 100) != 0) {
                ppvVar28 = (void **)mem_calloc(1,0x10);
                if (ppvVar28 == (void **)0x0) {
                  pvVar29 = (html_context->stack).next;
                }
                else {
                  ppvVar28[2] = (void *)0x3;
                  puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 100));
                  ppvVar28[3] = puVar25;
                  *ppvVar28 = local_84->event_hooks->next;
                  ppvVar28[1] = local_84->event_hooks;
                  local_84->event_hooks->next = ppvVar28;
                  *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
                  pvVar29 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar29 + 0x68) != 0) {
                ppvVar28 = (void **)mem_calloc(1,0x10);
                if (ppvVar28 == (void **)0x0) {
                  pvVar29 = (html_context->stack).next;
                }
                else {
                  ppvVar28[2] = (void *)0x4;
                  puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 0x68));
                  ppvVar28[3] = puVar25;
                  *ppvVar28 = local_84->event_hooks->next;
                  ppvVar28[1] = local_84->event_hooks;
                  local_84->event_hooks->next = ppvVar28;
                  *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
                  pvVar29 = (html_context->stack).next;
                }
              }
              if (*(int *)((int)pvVar29 + 0x6c) != 0) {
                ppvVar28 = (void **)mem_calloc(1,0x10);
                if (ppvVar28 == (void **)0x0) {
                  pvVar29 = (html_context->stack).next;
                }
                else {
                  ppvVar28[2] = (void *)0x5;
                  puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 0x6c));
                  ppvVar28[3] = puVar25;
                  *ppvVar28 = local_84->event_hooks->next;
                  ppvVar28[1] = local_84->event_hooks;
                  local_84->event_hooks->next = ppvVar28;
                  *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
                  pvVar29 = (html_context->stack).next;
                }
              }
              if ((*(int *)((int)pvVar29 + 0x70) != 0) &&
                 (ppvVar28 = (void **)mem_calloc(1,0x10), ppvVar28 != (void **)0x0)) {
                ppvVar28[2] = (void *)0x6;
                puVar25 = stracpy(*(uchar **)((int)(html_context->stack).next + 0x70));
                ppvVar28[3] = puVar25;
                *ppvVar28 = local_84->event_hooks->next;
                ppvVar28[1] = local_84->event_hooks;
                local_84->event_hooks->next = ppvVar28;
                *(void ***)((int)*ppvVar28 + 4) = ppvVar28;
              }
            }
            pdVar39->field_0x114 = pdVar39->field_0x114 & 0xfe;
            goto LAB_08091673;
          }
        }
        else {
LAB_08091318:
          assert_failed = 0;
        }
      }
    }
  }
LAB_08091322:
  if ((renderer_context._48_1_ & 8) == 0) {
    iVar38 = local_94 + ppVar2->cx;
  }
  else {
    iVar38 = local_94 + ppVar2->cx;
    pvVar29 = (html_context->stack).next;
    iVar15 = *(int *)((int)pvVar29 + 0x80) - *(int *)((int)pvVar29 + 0x7c);
    iVar14 = 0;
    if (-1 < iVar15) {
      iVar14 = iVar15;
    }
    if (iVar14 < iVar38) goto LAB_0809101a;
  }
  ppVar2->cx = iVar38;
  renderer_context._48_1_ = renderer_context._48_1_ & 0xfd;
  if ((-1 < (char)html_context->options->field_0x45) &&
     (pvVar29 = (html_context->stack).next, (*(uint *)((int)pvVar29 + 0xc) & 0x20) == 0)) {
    iVar38 = *(int *)((int)pvVar29 + 0x80) - *(int *)((int)pvVar29 + 0x7c);
    iVar14 = 0;
    if (-1 < iVar38) {
      iVar14 = iVar38;
    }
    if ((iVar14 < ppVar2->cx) && (*(int *)((int)pvVar29 + 0x78) < ppVar2->cx)) {
      do {
        if (assert_failed != 0) goto LAB_08091489;
        ppVar3 = html_context->part;
        assert_failed = (int)(ppVar3 == (part *)0x0);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 0x39f;
          elinks_internal((uchar *)"assertion part failed!");
          if (assert_failed != 0) goto LAB_08091489;
        }
        if ((html_context->options->field_0x5c & 0x10) == 0) {
          pvVar29 = (html_context->stack).next;
          local_84 = *(link **)((int)pvVar29 + 0x7c);
          iVar15 = *(int *)((int)pvVar29 + 0x80) - (int)local_84;
          iVar14 = *(int *)((int)pvVar29 + 0x78);
          iVar38 = 0;
          if (-1 < iVar15) {
            iVar38 = iVar15;
          }
          if (iVar14 <= iVar38) {
            do {
              if ((iVar38 < ppVar3->spaces_len) && (ppVar3->spaces[iVar38] != '\0'))
              goto LAB_08091418;
              iVar38 = iVar38 + -1;
            } while (iVar14 <= iVar38);
          }
          iVar15 = ppVar3->cx;
          if (iVar15 <= iVar14) goto LAB_080917b0;
          while ((ppVar3->spaces_len <= iVar14 || (iVar38 = iVar14, ppVar3->spaces[iVar14] == '\0'))
                ) {
            iVar14 = iVar14 + 1;
            if (iVar15 <= iVar14) goto LAB_080917b0;
          }
        }
        else {
          pvVar29 = (html_context->stack).next;
          local_84 = *(link **)((int)pvVar29 + 0x7c);
          iVar14 = *(int *)((int)pvVar29 + 0x78);
          iVar15 = *(int *)((int)pvVar29 + 0x80) - (int)local_84;
          iVar38 = 0;
          if (-1 < iVar15) {
            iVar38 = iVar15;
          }
          if (iVar14 <= iVar38) {
            do {
              if ((iVar38 < ppVar3->spaces_len) &&
                 ((ppVar3->spaces[iVar38] != '\0' ||
                  ((ppVar3->char_width[iVar38] == '\x02' && (iVar38 != iVar14))))))
              goto LAB_08091418;
              iVar38 = iVar38 + -1;
            } while (iVar14 <= iVar38);
          }
          iVar15 = ppVar3->cx;
          if (iVar15 <= iVar14) {
LAB_080917b0:
            if ((ppVar3->box).width < iVar15 + (int)local_84) {
              (ppVar3->box).width = iVar15 + (int)local_84;
            }
            break;
          }
          iVar38 = iVar14;
          while ((ppVar3->spaces_len <= iVar38 ||
                 ((ppVar3->spaces[iVar38] == '\0' &&
                  ((ppVar3->char_width[iVar38] != '\x02' || (iVar38 <= iVar14))))))) {
            iVar38 = iVar38 + 1;
            if (iVar15 <= iVar38) goto LAB_080917b0;
          }
        }
LAB_08091418:
        iVar14 = split_line_at(html_context,iVar38);
        if (iVar14 == 0) break;
        if (ppVar2->document != (document *)0x0) {
          align_line(html_context,ppVar2->cy + -1,0);
        }
        renderer_context._48_1_ = renderer_context._48_1_ & 0xfd | (iVar14 != 1) * '\x02';
        pvVar29 = (html_context->stack).next;
        iVar38 = *(int *)((int)pvVar29 + 0x80) - *(int *)((int)pvVar29 + 0x7c);
        iVar14 = 0;
        if (-1 < iVar38) {
          iVar14 = iVar38;
        }
        if ((ppVar2->cx <= iVar14) || (ppVar2->cx <= *(int *)((int)pvVar29 + 0x78))) break;
      } while( true );
    }
  }
  if (assert_failed == 0) {
LAB_08091489:
    assert_failed = (int)(charslen < 1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 0x68d;
      elinks_internal((uchar *)"assertion charslen > 0 failed!");
    }
  }
  uVar20 = 0;
  local_94 = local_94 + ppVar2->xa;
  ppVar2->xa = local_94;
  pvVar29 = (html_context->stack).next;
  if (local_90[charslen + -1] == 0x20) {
    uVar20 = (*(uint *)((int)pvVar29 + 0xc) >> 5 ^ 1) & 1;
  }
  iVar14 = (*(int *)((int)pvVar29 + 0x7c) + *(int *)((int)pvVar29 + 0x78) + local_94) - uVar20;
  if (ppVar2->max_width < iVar14) {
    ppVar2->max_width = iVar14;
  }
LAB_0809101a:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_0809256f:
  uVar11 = (undefined)get_format_screen_char::schar_cache._4_4_;
  get_format_screen_char::schar_cache.data = (unicode_val_T)*local_64;
  local_64 = local_64 + 1;
  get_format_screen_char::schar_cache.attr = 0x80;
  psVar33 = ppVar3->document->data[(ppVar3->box).y + iVar38].chars + (ppVar3->box).x + (int)local_98
  ;
  psVar33->data = get_format_screen_char::schar_cache.data;
  uVar34 = get_format_screen_char::schar_cache.color[0];
  uVar12 = get_format_screen_char::schar_cache.color[1];
  uVar13 = get_format_screen_char::schar_cache._7_1_;
  psVar33->attr = get_format_screen_char::schar_cache.attr;
  psVar33->color[0] = uVar34;
  psVar33->color[1] = uVar12;
  psVar33->field_0x7 = uVar13;
  get_format_screen_char::schar_cache.attr = uVar11;
  ppVar3->char_width[(int)local_98] = '\0';
  local_98 = (byte *)((int)local_98 + 1);
  if (pbVar35 <= local_64) {
    local_94 = (int)local_98 - iVar14;
    goto LAB_08091cc9;
  }
  goto LAB_08091c26;
}



// WARNING: Unknown calling convention

void put_chars_conv(html_context *html_context,uchar *chars,int charslen)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(html_context == (html_context *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x542;
    elinks_internal((uchar *)"assertion html_context failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (((chars == (uchar *)0x0) || (html_context->part == (part *)0x0)) || (charslen == 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 0x547;
    elinks_internal((uchar *)"assertion part && chars && charslen failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x10) != 0) {
    put_chars(html_context,chars,charslen);
    return;
  }
  convert_string_elinks
            (renderer_context.convert_table,chars,charslen,html_context->options->cp,CSM_DEFAULT,
             (int *)0x0,put_chars,html_context);
  return;
}



// WARNING: Unknown calling convention

int get_hline_width(table_elinks *table_elinks,int row)

{
  undefined *puVar1;
  table_cell *ptVar2;
  int col;
  int iVar3;
  
  if (row == 0) {
    return -1;
  }
  iVar3 = table_elinks->rules;
  if ((iVar3 != 3) && (iVar3 != 1)) {
    if ((iVar3 != 4) || (table_elinks->cols < 1)) {
LAB_08092baa:
      iVar3 = 0;
      goto LAB_08092bac;
    }
    iVar3 = row * table_elinks->real_cols;
    if ((table_elinks->cells[iVar3].field_0x3c & 8) == 0) {
      ptVar2 = table_elinks->cells + iVar3 + 1;
      iVar3 = 0;
      do {
        iVar3 = iVar3 + 1;
        if (table_elinks->cols <= iVar3) goto LAB_08092baa;
        puVar1 = &ptVar2->field_0x3c;
        ptVar2 = ptVar2 + 1;
      } while ((*puVar1 & 8) == 0);
    }
  }
  iVar3 = table_elinks->cellspacing;
  if (iVar3 != 0) {
    return iVar3;
  }
LAB_08092bac:
  if (table_elinks->vcellpadding == 0) {
    return -1;
  }
  return iVar3;
}



// WARNING: Unknown calling convention

void get_table_frames(table_elinks *table_elinks,table_frames *result)

{
  byte bVar1;
  byte bVar2;
  byte bVar3;
  byte bVar4;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(result == (table_frames *)0x0 || table_elinks == (table_elinks *)0x0),
     result == (table_frames *)0x0 || table_elinks == (table_elinks *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x27;
    elinks_internal((uchar *)"assertion table && result failed!");
  }
  if (table_elinks->border != 0) {
    bVar1 = *(byte *)result;
    bVar2 = (byte)table_elinks->frame & 1;
    *(byte *)result = bVar1 & 0xfe | bVar2;
    bVar3 = ((byte)((uint)table_elinks->frame >> 1) & 1) * '\x02';
    *(byte *)result = bVar1 & 0xfc | bVar2 | bVar3;
    bVar4 = (byte)(((uint)table_elinks->frame >> 2 & 1) << 2);
    *(byte *)result = bVar1 & 0xf8 | bVar2 | bVar3 | bVar4;
    *(byte *)result =
         bVar1 & 0xf0 | bVar2 | bVar3 | bVar4 | (byte)(((uint)table_elinks->frame >> 3 & 1) << 3);
    return;
  }
  *result = (table_frames)0x0;
  return;
}



// WARNING: Unknown calling convention

void draw_table_frames(table_elinks *table_elinks,int indent,int y,html_context *html_context)

{
  undefined *puVar1;
  char cVar2;
  char cVar3;
  char cVar4;
  char cVar5;
  char bottom_1;
  char bottom;
  void *__s;
  table_cell *cell;
  uint __c;
  uint uVar6;
  int pos;
  int iVar7;
  int iVar8;
  int row;
  int iVar9;
  int pos_3;
  int ysp;
  char right;
  size_t __n;
  int iVar10;
  size_t sVar11;
  table_cell *ptVar12;
  int fh_size;
  int iVar13;
  int col_1;
  int col;
  int iVar14;
  int pos_2;
  size_t size;
  int row_1;
  int cx;
  uint uVar15;
  bool bVar16;
  int local_a0;
  int local_60;
  int local_5c;
  int local_58;
  int local_50;
  int local_48;
  uint local_44;
  int local_40;
  uint local_3c;
  int local_38;
  int local_34;
  int local_30;
  table_frames table_frames;
  
  iVar13 = (table_elinks->rows + 1) * (table_elinks->cols + 2);
  size = (table_elinks->rows + 2) * (table_elinks->cols + 1) + iVar13;
  __s = mem_alloc(size);
  if (__s != (void *)0x0) {
    memset(__s,-1,size);
    local_3c = table_elinks->rules;
    if (local_3c != 0) {
      local_48 = table_elinks->rows;
      if (0 < local_48) {
        local_30 = table_elinks->cols;
        local_40 = 1;
        local_38 = 0;
        local_34 = local_48;
        do {
          if (0 < local_30) {
            iVar14 = 1;
            iVar8 = 0;
            do {
              iVar10 = local_38 * table_elinks->real_cols + iVar8;
              ptVar12 = table_elinks->cells;
              iVar9 = local_34;
              if ((ptVar12[iVar10].field_0x3c & 3) == 1) {
                sVar11 = local_30 - iVar8;
                if (ptVar12[iVar10].colspan != 0) {
                  sVar11 = ptVar12[iVar10].colspan;
                }
                __n = ptVar12[iVar10].rowspan;
                if (ptVar12[iVar10].rowspan == 0) {
                  __n = local_34 - local_38;
                }
                if (local_3c != 2) {
                  iVar9 = table_elinks->cellspacing;
                  if (assert_failed == 0) {
                    if ((((iVar8 < -1) && (local_30 + 2 <= iVar8)) && (local_38 < 0)) &&
                       (local_34 < local_38)) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                      errline = 0x3cb;
                      elinks_internal((uchar *)
                                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                     );
                      if (assert_failed != 0) goto LAB_08093ff8;
                    }
                    else {
                      assert_failed = 0;
                    }
                    iVar10 = (local_30 + 2) * local_38 + iVar14;
                  }
                  else {
LAB_08093ff8:
                    assert_failed = 0;
                    iVar10 = 0;
                  }
                  memset((void *)(iVar10 + (int)__s),iVar9,sVar11);
                  iVar9 = table_elinks->cellspacing;
                  iVar10 = table_elinks->cols;
                  if (assert_failed == 0) {
                    iVar7 = local_38 + __n;
                    if (((iVar8 < -1) && (iVar7 < 0)) &&
                       ((iVar10 + 2 <= iVar8 && (table_elinks->rows < iVar7)))) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                      errline = 0x3cb;
                      elinks_internal((uchar *)
                                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                     );
                      if (assert_failed != 0) goto LAB_08093f70;
                    }
                    else {
                      assert_failed = 0;
                    }
                    local_3c = iVar10 + 2;
                    iVar10 = local_3c * iVar7 + iVar14;
                  }
                  else {
LAB_08093f70:
                    assert_failed = 0;
                    iVar10 = 0;
                  }
                  memset((void *)(iVar10 + (int)__s),iVar9,sVar11);
                  if (table_elinks->rules == 1) {
                    local_30 = table_elinks->cols;
                    local_3c = 1;
                    iVar9 = table_elinks->rows;
                    goto joined_r0x08093c59;
                  }
                  local_48 = table_elinks->rows;
                  local_30 = table_elinks->cols;
                }
                iVar9 = table_elinks->cellspacing;
                if (assert_failed == 0) {
                  if (((local_38 < -1) && (local_48 + 2 <= local_38)) &&
                     ((iVar8 < 0 && (local_30 < iVar8)))) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x3cb;
                    elinks_internal((uchar *)
                                    "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                   );
                    if (assert_failed != 0) goto LAB_08094100;
                  }
                  else {
                    assert_failed = 0;
                  }
                  iVar10 = (local_48 + 2) * iVar8 + local_40;
                }
                else {
LAB_08094100:
                  assert_failed = 0;
                  iVar10 = 0;
                }
                memset((void *)((int)__s + iVar10 + iVar13),iVar9,__n);
                iVar9 = table_elinks->cellspacing;
                iVar10 = table_elinks->rows;
                if (assert_failed == 0) {
                  iVar7 = sVar11 + iVar8;
                  if ((((local_38 < -1) && (iVar7 < 0)) && (iVar10 + 2 <= local_38)) &&
                     (table_elinks->cols < iVar7)) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x3cb;
                    elinks_internal((uchar *)
                                    "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                   );
                    if (assert_failed != 0) goto LAB_08094078;
                  }
                  else {
                    assert_failed = 0;
                  }
                  local_3c = iVar10 + 2;
                  iVar10 = local_3c * iVar7 + local_40;
                }
                else {
LAB_08094078:
                  assert_failed = 0;
                  iVar10 = 0;
                }
                memset((void *)((int)__s + iVar10 + iVar13),iVar9,__n);
                local_30 = table_elinks->cols;
                local_3c = table_elinks->rules;
                iVar9 = table_elinks->rows;
              }
joined_r0x08093c59:
              local_48 = iVar9;
              local_34 = local_48;
              if (local_30 <= iVar14) break;
              iVar14 = iVar14 + 1;
              iVar8 = iVar8 + 1;
            } while( true );
          }
          local_38 = local_38 + 1;
          bVar16 = local_40 < local_34;
          local_40 = local_40 + 1;
        } while (bVar16);
      }
      if (local_3c == 4) {
        if (1 < table_elinks->cols) {
          iVar8 = 1;
          do {
            if (table_elinks->cols_x[iVar8] == 0) {
              if (assert_failed == 0) {
                iVar14 = (table_elinks->rows + 2U) * iVar8 + 1;
              }
              else {
                iVar14 = 0;
              }
              assert_failed = 0;
              memset((void *)((int)__s + iVar14 + iVar13),0,table_elinks->rows);
            }
            iVar8 = iVar8 + 1;
          } while (iVar8 < table_elinks->cols);
        }
        iVar8 = 1;
        if (1 < table_elinks->rows) {
          do {
            sVar11 = table_elinks->cols;
            if ((int)sVar11 < 1) {
LAB_08094303:
              if (assert_failed == 0) {
                iVar14 = (sVar11 + 2) * iVar8 + 1;
              }
              else {
                iVar14 = 0;
              }
              assert_failed = 0;
              memset((void *)(iVar14 + (int)__s),0,sVar11);
            }
            else {
              iVar14 = table_elinks->real_cols * iVar8;
              if ((table_elinks->cells[iVar14].field_0x3c & 8) == 0) {
                ptVar12 = table_elinks->cells + iVar14 + 1;
                iVar14 = 0;
                do {
                  iVar14 = iVar14 + 1;
                  if ((int)sVar11 <= iVar14) goto LAB_08094303;
                  puVar1 = &ptVar12->field_0x3c;
                  ptVar12 = ptVar12 + 1;
                } while ((*puVar1 & 8) == 0);
              }
            }
            iVar8 = iVar8 + 1;
          } while (iVar8 < table_elinks->rows);
        }
      }
    }
    get_table_frames(table_elinks,&table_frames);
    bVar16 = assert_failed == 0;
    assert_failed = 0;
    memset((void *)((uint)bVar16 + (int)__s),(uint)(table_frames._0_1_ & 1),table_elinks->cols);
    if (assert_failed == 0) {
      iVar8 = (table_elinks->cols + 2U) * table_elinks->rows + 1;
    }
    else {
      iVar8 = 0;
    }
    assert_failed = 0;
    memset((void *)(iVar8 + (int)__s),(uint)((byte)table_frames._0_1_ >> 1 & 1),table_elinks->cols);
    bVar16 = assert_failed == 0;
    assert_failed = 0;
    memset((void *)((int)__s + (uint)bVar16 + iVar13),(uint)((byte)table_frames._0_1_ >> 2 & 1),
           table_elinks->rows);
    if (assert_failed == 0) {
      iVar8 = (table_elinks->rows + 2U) * table_elinks->cols + 1;
    }
    else {
      iVar8 = 0;
    }
    assert_failed = 0;
    __c = (uint)((byte)table_frames._0_1_ >> 3 & 1);
    memset((void *)((int)__s + iVar8 + iVar13),__c,table_elinks->rows);
    local_40 = table_elinks->rows;
    if (-1 < local_40) {
      local_5c = -1;
      local_58 = 0;
      local_48 = 1;
      local_38 = 0;
      local_50 = y;
LAB_08092e88:
      if (local_38 < 1) {
        if ((local_38 != 0) || ((table_frames._0_1_ & 1) == 0)) goto LAB_08092e9b;
LAB_080930af:
        local_44 = 0xffffffff;
        if ((table_frames._0_1_ & 4) != 0) {
          local_44 = table_elinks->border;
        }
        iVar8 = table_elinks->cols;
        if (0 < iVar8) {
          local_a0 = 0;
          iVar14 = 0;
          uVar15 = indent;
          do {
            if ((int)local_44 < 0) {
              if (assert_failed == 0) goto LAB_08093112;
LAB_080933b2:
              iVar8 = 0;
            }
            else {
              if (assert_failed == 0) {
                if ((((iVar14 + -1 < -1) && (iVar8 + 2 <= iVar14 + -1)) && (local_38 < 0)) &&
                   (local_40 < local_38)) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                  errline = 0x3cb;
                  elinks_internal((uchar *)
                                  "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                  ,__c);
                  if (assert_failed != 0) goto LAB_08093428;
                }
                iVar8 = (iVar8 + 2) * local_38 + iVar14;
              }
              else {
LAB_08093428:
                iVar8 = 0;
              }
              cVar2 = *(char *)((int)__s + iVar8);
              iVar8 = table_elinks->cols;
              if (((iVar14 < -1) && (iVar8 + 2 <= iVar14)) &&
                 ((local_38 < 0 && (table_elinks->rows < local_38)))) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                               );
                if (assert_failed == 0) goto LAB_08093252;
                local_3c = 0;
              }
              else {
LAB_08093252:
                local_3c = (iVar8 + 2) * local_38 + iVar14 + 1;
              }
              cVar3 = *(char *)((int)__s + local_3c);
              iVar8 = table_elinks->rows;
              if (((local_5c < -1) && (iVar14 < 0)) &&
                 ((iVar8 + 2 <= local_5c && (table_elinks->cols < iVar14)))) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                               );
                if (assert_failed == 0) goto LAB_0809328b;
                iVar8 = 0;
              }
              else {
LAB_0809328b:
                iVar8 = (iVar8 + 2) * iVar14 + local_38;
              }
              iVar9 = table_elinks->rows;
              cVar4 = *(char *)((int)__s + iVar8 + iVar13);
              if ((((local_38 < -1) && (iVar14 < 0)) && (iVar9 + 2 <= local_38)) &&
                 (table_elinks->cols < iVar14)) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                               );
                if (assert_failed == 0) goto LAB_080932bb;
                assert_failed = 0;
                iVar8 = 0;
              }
              else {
                assert_failed = 0;
LAB_080932bb:
                iVar8 = (iVar9 + 2) * iVar14 + local_48;
              }
              cVar5 = *(char *)((int)__s + iVar8 + iVar13);
              if (((-1 < cVar3) || (-1 < cVar2)) || ((-1 < cVar5 || (-1 < cVar4)))) {
                iVar9 = (int)cVar2;
                iVar10 = (int)cVar4;
                iVar8 = (int)cVar3;
                if (iVar8 < 0) {
                  iVar8 = 0;
                }
                if (iVar9 < 0) {
                  iVar9 = 0;
                }
                if (iVar10 < 0) {
                  iVar10 = 0;
                }
                iVar7 = 0;
                if (-1 < cVar5) {
                  iVar7 = (int)cVar5;
                }
                __c = uVar15;
                draw_frame_hchars(table_elinks->part,uVar15,local_50,1,
                                  *(uchar *)(draw_frame_point::border_chars +
                                            iVar9 * 9 + iVar8 * 3 + iVar7 * 0x1b + iVar10),
                                  *(color_T *)((int)(html_context->stack).next + 0x94),
                                  table_elinks->bordercolor,html_context);
              }
              local_40 = table_elinks->rows;
              if (local_38 < local_40) {
                if (assert_failed == 0) {
                  if (((local_38 < -1) && (iVar14 < 0)) &&
                     ((local_40 + 2 <= local_38 && (table_elinks->cols < iVar14)))) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x3cb;
                    elinks_internal((uchar *)
                                    "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                   );
                    if (assert_failed != 0) goto LAB_08093648;
                  }
                  iVar8 = (local_40 + 2) * iVar14 + local_48;
                }
                else {
LAB_08093648:
                  iVar8 = 0;
                }
                uVar6 = (uint)*(char *)((int)__s + iVar8 + iVar13);
                assert_failed = (int)(2 < (int)uVar6);
                if (assert_failed != 0) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                  errline = 0x426;
                  __c = uVar6;
                  elinks_internal((uchar *)
                                  "assertion pos < 3 failed: Vertical table position out of bound [%d]"
                                  ,uVar6);
                  if (assert_failed != 0) {
                    local_40 = table_elinks->rows;
                    local_34 = 0;
                    goto LAB_080933a1;
                  }
                }
                local_60 = local_50 + 1;
                if ((int)uVar6 < 0) {
                  local_40 = table_elinks->rows;
                  local_34 = assert_failed;
                }
                else {
                  iVar8 = *(int *)((int)table_elinks->rows_heights + local_58);
                  if (0 < iVar8) {
                    __c = uVar15;
                    draw_frame_vchars(table_elinks->part,uVar15,local_60,iVar8,
                                      draw_frame_vline::vltable[uVar6],
                                      *(color_T *)((int)(html_context->stack).next + 0x94),
                                      table_elinks->bordercolor,html_context);
                  }
                  local_40 = table_elinks->rows;
                  local_34 = assert_failed;
                }
              }
              else {
                local_34 = assert_failed;
              }
LAB_080933a1:
              uVar15 = uVar15 + 1;
              iVar8 = table_elinks->cols;
              if (local_34 != 0) goto LAB_080933b2;
LAB_08093112:
              local_30 = iVar14 + 1;
              if ((((iVar14 < -1) && (iVar8 + 2 <= iVar14)) && (local_38 < 0)) &&
                 (local_40 < local_38)) {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x3cb;
                elinks_internal((uchar *)
                                "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!"
                                ,__c);
                if (assert_failed != 0) goto LAB_080933b2;
              }
              iVar8 = (iVar8 + 2) * local_38 + local_30;
            }
            local_30 = iVar14 + 1;
            uVar6 = (uint)*(char *)((int)__s + iVar8);
            assert_failed = (int)(2 < (int)uVar6);
            if (assert_failed == 0) {
LAB_0809314b:
              if (-1 < (int)uVar6) {
                iVar8 = *(int *)((int)table_elinks->cols_widths + local_a0);
                if (iVar8 < 1) goto LAB_080931ad;
                __c = uVar15;
                draw_frame_hchars(table_elinks->part,uVar15,local_50,iVar8,
                                  draw_frame_hline::hltable[uVar6],
                                  *(color_T *)((int)(html_context->stack).next + 0x94),
                                  table_elinks->bordercolor,html_context);
              }
              iVar8 = *(int *)((int)table_elinks->cols_widths + local_a0);
            }
            else {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
              errline = 0x416;
              __c = uVar6;
              elinks_internal((uchar *)
                              "assertion pos < 3 failed: Horizontal table position out of bound [%d]"
                              ,uVar6);
              if (assert_failed == 0) goto LAB_0809314b;
              assert_failed = 0;
              iVar8 = *(int *)((int)table_elinks->cols_widths + local_a0);
            }
LAB_080931ad:
            uVar15 = uVar15 + iVar8;
            iVar8 = table_elinks->cols;
            if (iVar8 <= local_30) goto LAB_08092fa0;
            if (0 < local_30) {
              if (table_elinks->rules - 2U < 2) {
                local_44 = table_elinks->cellspacing;
                uVar6 = local_44;
joined_r0x080935d8:
                if (uVar6 != 0) goto LAB_080931e4;
              }
              else if ((table_elinks->rules == 4) && (local_30 < table_elinks->columns_count)) {
                local_44 = 1;
                uVar6 = table_elinks->columns[local_30].group;
                goto joined_r0x080935d8;
              }
              local_44 = ~-(uint)(table_elinks->cellpadding == 0);
            }
LAB_080931e4:
            local_40 = table_elinks->rows;
            local_a0 = local_a0 + 4;
            iVar14 = local_30;
          } while( true );
        }
        local_30 = 0;
        local_3c = indent;
        goto LAB_08092faf;
      }
      if (local_38 < local_40) {
        iVar8 = get_hline_width(table_elinks,local_38);
        if (-1 < iVar8) {
          local_40 = table_elinks->rows;
          goto LAB_080930af;
        }
        local_40 = table_elinks->rows;
      }
LAB_08092e9b:
      if (local_40 != local_38) {
        if (local_40 <= local_38) goto LAB_08092fdc;
        iVar8 = table_elinks->cols;
        if (-1 < iVar8) {
          iVar14 = 0;
          uVar15 = indent;
          do {
            if (iVar14 == 0) {
              if ((table_frames._0_1_ & 4) != 0) goto LAB_08092eff;
LAB_08092ed8:
              if ((iVar14 == iVar8) && ((table_frames._0_1_ & 8) != 0)) goto LAB_08092eff;
            }
            else {
              if (iVar8 <= iVar14) goto LAB_08092ed8;
              if (table_elinks->rules - 2U < 2) {
                if (table_elinks->cellspacing == 0) goto LAB_08093070;
                if (table_elinks->cellspacing < 0) goto LAB_08092ed8;
              }
              else if (((table_elinks->rules != 4) || (table_elinks->columns_count <= iVar14)) ||
                      (table_elinks->columns[iVar14].group == 0)) {
LAB_08093070:
                if (table_elinks->cellpadding != 0) goto LAB_08092ed8;
              }
LAB_08092eff:
              if (assert_failed == 0) {
                iVar8 = (local_40 + 2) * iVar14 + local_48;
              }
              else {
                iVar8 = 0;
              }
              uVar6 = (uint)*(char *)((int)__s + iVar8 + iVar13);
              assert_failed = (int)(2 < (int)uVar6);
              if (assert_failed == 0) {
LAB_08092f36:
                if ((-1 < (int)uVar6) &&
                   (iVar8 = *(int *)((int)table_elinks->rows_heights + local_58), 0 < iVar8)) {
                  __c = uVar15;
                  draw_frame_vchars(table_elinks->part,uVar15,local_50,iVar8,
                                    draw_frame_vline::vltable[uVar6],
                                    *(color_T *)((int)(html_context->stack).next + 0x94),
                                    table_elinks->bordercolor,html_context);
                }
              }
              else {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x426;
                __c = uVar6;
                elinks_internal((uchar *)
                                "assertion pos < 3 failed: Vertical table position out of bound [%d]"
                                ,uVar6);
                if (assert_failed == 0) goto LAB_08092f36;
                assert_failed = 0;
              }
              local_40 = table_elinks->rows;
              uVar15 = uVar15 + 1;
              iVar8 = table_elinks->cols;
            }
            if (iVar14 < iVar8) {
              uVar15 = uVar15 + table_elinks->cols_widths[iVar14];
            }
            iVar14 = iVar14 + 1;
          } while (iVar14 <= iVar8);
          goto LAB_08092fc5;
        }
        goto LAB_08092fca;
      }
      if ((table_frames._0_1_ & 2) != 0) goto LAB_080930af;
      goto LAB_08092fdc;
    }
LAB_08092ff5:
    mem_free(__s);
  }
  return;
LAB_08092fa0:
  local_40 = table_elinks->rows;
  local_3c = uVar15;
LAB_08092faf:
  local_60 = local_50 + 1;
  if ((table_frames._0_1_ & 8) == 0) goto LAB_08092fbf;
  if (assert_failed == 0) {
    if (((local_30 + -1 < -1) && (iVar8 + 2 <= local_30 + -1)) &&
       ((local_38 < 0 && (local_40 < local_38)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 0x3cb;
      elinks_internal((uchar *)
                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!",__c);
      if (assert_failed != 0) goto LAB_08093b90;
    }
    iVar8 = (iVar8 + 2) * local_38 + local_30;
  }
  else {
LAB_08093b90:
    iVar8 = 0;
  }
  cVar2 = *(char *)((int)__s + iVar8);
  iVar8 = table_elinks->cols;
  if ((((local_30 < -1) && (iVar8 + 2 <= local_30)) && (local_38 < 0)) &&
     (table_elinks->rows < local_38)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x3cb;
    elinks_internal((uchar *)"assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!")
    ;
    if (assert_failed == 0) goto LAB_080938cb;
    iVar8 = 0;
  }
  else {
LAB_080938cb:
    iVar8 = local_30 + 1 + (iVar8 + 2) * local_38;
  }
  cVar3 = *(char *)((int)__s + iVar8);
  iVar8 = table_elinks->rows;
  if (((local_5c < -1) && (local_30 < 0)) &&
     ((iVar8 + 2 <= local_5c && (table_elinks->cols < local_30)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x3cb;
    elinks_internal((uchar *)"assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!")
    ;
    if (assert_failed == 0) goto LAB_080938f7;
    iVar8 = 0;
  }
  else {
LAB_080938f7:
    iVar8 = (iVar8 + 2) * local_30 + local_38;
  }
  cVar4 = *(char *)((int)__s + iVar8 + iVar13);
  iVar8 = table_elinks->rows;
  if (((local_38 < -1) && (local_30 < 0)) &&
     ((iVar8 + 2 <= local_38 && (table_elinks->cols < local_30)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x3cb;
    elinks_internal((uchar *)"assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!")
    ;
    if (assert_failed == 0) goto LAB_08093921;
    assert_failed = 0;
    iVar8 = 0;
  }
  else {
    assert_failed = 0;
LAB_08093921:
    iVar8 = (iVar8 + 2) * local_30 + local_48;
  }
  cVar5 = *(char *)((int)__s + iVar8 + iVar13);
  if ((((-1 < cVar3) || (-1 < cVar2)) || (-1 < cVar5)) || (-1 < cVar4)) {
    iVar8 = (int)cVar4;
    iVar14 = (int)cVar2;
    iVar9 = (int)cVar3;
    if (iVar9 < 0) {
      iVar9 = 0;
    }
    if (iVar14 < 0) {
      iVar14 = 0;
    }
    if (iVar8 < 0) {
      iVar8 = 0;
    }
    iVar10 = 0;
    if (-1 < cVar5) {
      iVar10 = (int)cVar5;
    }
    __c = local_3c;
    draw_frame_hchars(table_elinks->part,local_3c,local_50,1,
                      *(uchar *)(draw_frame_point::border_chars +
                                iVar9 * 3 + iVar10 * 0x1b + iVar14 * 9 + iVar8),
                      *(color_T *)((int)(html_context->stack).next + 0x94),table_elinks->bordercolor
                      ,html_context);
  }
  local_40 = table_elinks->rows;
  if (local_40 <= local_38) goto LAB_08092fbf;
  if (assert_failed == 0) {
    if (((local_38 < -1) && (local_30 < 0)) &&
       ((local_40 + 2 <= local_38 && (table_elinks->cols < local_30)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 0x3cb;
      elinks_internal((uchar *)
                      "assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
      if (assert_failed != 0) goto LAB_080939f2;
    }
    iVar8 = (local_40 + 2) * local_30 + local_48;
  }
  else {
LAB_080939f2:
    iVar8 = 0;
  }
  uVar15 = (uint)*(char *)((int)__s + iVar8 + iVar13);
  assert_failed = (int)(2 < (int)uVar15);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x426;
    __c = uVar15;
    elinks_internal((uchar *)"assertion pos < 3 failed: Vertical table position out of bound [%d]",
                    uVar15);
    if (assert_failed != 0) {
      assert_failed = 0;
      local_40 = table_elinks->rows;
      goto LAB_08092fbf;
    }
  }
  if ((-1 < (int)uVar15) &&
     (iVar8 = *(int *)((int)table_elinks->rows_heights + local_58), 0 < iVar8)) {
    draw_frame_vchars(table_elinks->part,local_3c,local_60,iVar8,draw_frame_vline::vltable[uVar15],
                      *(color_T *)((int)(html_context->stack).next + 0x94),table_elinks->bordercolor
                      ,html_context);
    __c = local_3c;
  }
  local_40 = table_elinks->rows;
LAB_08092fbf:
  local_50 = local_60;
LAB_08092fc5:
  if (local_38 < local_40) {
LAB_08092fca:
    local_50 = local_50 + *(int *)((int)table_elinks->rows_heights + local_58);
  }
LAB_08092fdc:
  local_38 = local_38 + 1;
  local_58 = local_58 + 4;
  local_5c = local_5c + 1;
  bVar16 = local_40 < local_48;
  local_48 = local_48 + 1;
  if (bVar16) goto LAB_08092ff5;
  goto LAB_08092e88;
}



// WARNING: Unknown calling convention

void format_table(uchar *attr,uchar *html,uchar *eof,uchar **end,html_context *html_context)

{
  uint *puVar1;
  part *ppVar2;
  int iVar3;
  color_T bgcolor_00;
  document *document;
  uint uVar4;
  bool bVar5;
  uint uVar6;
  table_elinks *table_elinks_00;
  table_elinks *table_elinks;
  html_start_end *html_1;
  ushort **ppuVar7;
  void *state;
  part *part;
  part *part_2;
  part *ppVar8;
  part *part_1;
  int i_2;
  int iVar9;
  int i_1;
  size_t sVar10;
  int *piVar11;
  void *pvVar12;
  int stretched;
  int iVar13;
  int k_1;
  part *ppVar14;
  part *part_3;
  int total_width;
  table_cell *cell_3;
  int col_4;
  part *part_5;
  part *part_4;
  int sum_3;
  int old_height;
  void **ppvVar15;
  int *piVar16;
  part *part_6;
  int s;
  void *pvVar17;
  int tmpy;
  int colspan;
  int p;
  int width;
  int vl;
  int max_cols_width;
  int stretch_col;
  int *piVar18;
  int iVar19;
  int width_3;
  int indent;
  void *pvVar20;
  int width_7;
  int i;
  int width_2;
  int col_2;
  int k;
  int delta;
  int iVar21;
  int r;
  size_t sVar22;
  int col;
  int iVar23;
  int col_3;
  int new_width;
  int delta_1;
  int width_4;
  uchar *end_3;
  void *pvVar24;
  int iVar25;
  int xp;
  int width_5;
  byte *pbVar26;
  int iVar27;
  int iVar28;
  int row;
  int col_1;
  uchar *start;
  byte *pbVar29;
  int max;
  table_cell *cell_1;
  table_cell *ptVar30;
  table_cell *cell;
  int height;
  int width_1;
  int sum;
  int d;
  int t;
  int spare_width;
  int p_1;
  int max_1;
  uchar *start_1;
  int height_1;
  int rowspan;
  int row_3;
  color_T bgcolor;
  table_cell *cell_6;
  int width_6;
  uchar *end_1;
  int iVar31;
  int min;
  int link_num;
  table_cell *cell_2;
  int col_5;
  int colspan_1;
  uchar *end_2;
  uchar *start_2;
  byte *pbVar32;
  int row_1;
  table_cell *cell_4;
  int t_1;
  part *part_7;
  int our_height;
  int local_78;
  int local_74;
  int local_70;
  int local_60;
  int *local_5c;
  int local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  int local_40;
  int local_3c;
  int local_38;
  int local_34;
  int local_30;
  table_frames table_frames;
  
  ppVar2 = html_context->part;
  uVar6 = 1;
  html_context->table_level = html_context->table_level + 1;
  if (ppVar2->document == (document *)0x0) {
    uVar6 = (uint)((ppVar2->box).x != 0);
  }
  table_elinks_00 = parse_table(html,eof,end,attr,uVar6,html_context);
  if (table_elinks_00 != (table_elinks *)0x0) {
    table_elinks_00->part = ppVar2;
    local_34 = table_elinks_00->bad_html_size;
    iVar27 = 0;
LAB_0809447d:
    if (iVar27 < local_34) {
      pbVar29 = table_elinks_00->bad_html[iVar27].start;
      pbVar32 = table_elinks_00->bad_html[iVar27].end;
      if (pbVar29 < pbVar32) {
        ppuVar7 = __ctype_b_loc();
        do {
          if ((*(byte *)((int)*ppuVar7 + (uint)*pbVar29 * 2 + 1) & 0x20) == 0)
          goto joined_r0x080944c8;
          pbVar29 = pbVar29 + 1;
        } while (pbVar29 < pbVar32);
      }
      goto LAB_08094528;
    }
    state = init_html_parser_state(html_context,ELEMENT_DONT_KILL,0,0,0);
    pvVar12 = (html_context->stack).next;
    iVar31 = *(int *)((int)pvVar12 + 0x7c) + *(int *)((int)pvVar12 + 0x78);
    ppVar14 = table_elinks_00->part;
    iVar27 = table_elinks_00->cellpadding;
    local_78 = 0;
    local_74 = 0;
    ppVar8 = ppVar14;
LAB_08094589:
    local_30 = ppVar8->link_num;
    if ((html_context->options->field_0x44 & 8) == 0) {
      local_34 = 0;
      if (0 < table_elinks_00->rows) {
        do {
          iVar9 = 0;
          if (0 < table_elinks_00->cols) {
            do {
              ptVar30 = table_elinks_00->cells + iVar9 + local_34 * table_elinks_00->real_cols;
              if (ptVar30->start != (uchar *)0x0) {
                ptVar30->link_num = local_30;
                iVar28 = table_elinks_00->cellpadding;
                ptVar30->min_width = -1;
                ptVar30->max_width = -1;
                ppVar8 = format_html_part(html_context,ptVar30->start,ptVar30->end,0,iVar28,0,
                                          (document *)0x0,0,0,(uchar *)0x0,local_30);
                if (ppVar8 != (part *)0x0) {
                  iVar28 = (ppVar8->box).width;
                  ptVar30->min_width = iVar28;
                  iVar19 = ppVar8->max_width;
                  ptVar30->max_width = iVar19;
                  local_30 = ppVar8->link_num;
                  if ((assert_failed == 0) &&
                     (assert_failed = (int)(iVar19 < iVar28), iVar19 < iVar28)) {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x77;
                    elinks_internal((uchar *)
                                    "assertion *min <= *max failed: get_cell_width: %d > %d",
                                    ptVar30->min_width,ptVar30->max_width);
                  }
                  mem_free(ppVar8);
                }
              }
              iVar9 = iVar9 + 1;
            } while (iVar9 < table_elinks_00->cols);
          }
          local_34 = local_34 + 1;
        } while (local_34 < table_elinks_00->rows);
      }
    }
    else {
      local_34 = 0;
      if (0 < table_elinks_00->cols) {
        do {
          if (0 < table_elinks_00->rows) {
            iVar9 = table_elinks_00->real_cols;
            iVar28 = 0;
            while( true ) {
              ptVar30 = table_elinks_00->cells + iVar9 * iVar28 + local_34;
              if (ptVar30->start != (uchar *)0x0) {
                ptVar30->link_num = local_30;
                iVar9 = table_elinks_00->cellpadding;
                ptVar30->min_width = -1;
                ptVar30->max_width = -1;
                ppVar8 = format_html_part(html_context,ptVar30->start,ptVar30->end,0,iVar9,0,
                                          (document *)0x0,0,0,(uchar *)0x0,local_30);
                if (ppVar8 != (part *)0x0) {
                  iVar9 = (ppVar8->box).width;
                  ptVar30->min_width = iVar9;
                  iVar19 = ppVar8->max_width;
                  ptVar30->max_width = iVar19;
                  local_30 = ppVar8->link_num;
                  if ((assert_failed == 0) &&
                     (assert_failed = (int)(iVar19 < iVar9), iVar19 < iVar9)) {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 0x77;
                    elinks_internal((uchar *)
                                    "assertion *min <= *max failed: get_cell_width: %d > %d",
                                    ptVar30->min_width,ptVar30->max_width);
                  }
                  mem_free(ppVar8);
                }
              }
              iVar28 = iVar28 + 1;
              if (table_elinks_00->rows <= iVar28) break;
              iVar9 = table_elinks_00->real_cols;
            }
          }
          local_34 = local_34 + 1;
        } while (local_34 < table_elinks_00->cols);
      }
    }
    sVar10 = table_elinks_00->cols;
    table_elinks_00->link_num = local_30;
    if (sVar10 == 0) goto ret2;
    if (table_elinks_00->min_cols_widths == (int *)0x0) {
      piVar11 = (int *)mem_calloc(sVar10,4);
      table_elinks_00->min_cols_widths = piVar11;
      if (piVar11 == (int *)0x0) goto LAB_08095bce;
      sVar10 = table_elinks_00->cols;
    }
    if (table_elinks_00->max_cols_widths == (int *)0x0) {
      piVar11 = (int *)mem_calloc(sVar10,4);
      table_elinks_00->max_cols_widths = piVar11;
      if (piVar11 == (int *)0x0) {
        if (table_elinks_00->min_cols_widths != (int *)0x0) {
          mem_free(table_elinks_00->min_cols_widths);
        }
        table_elinks_00->min_cols_widths = (int *)0x0;
        local_30 = table_elinks_00->link_num;
        goto ret2;
      }
      sVar10 = table_elinks_00->cols;
    }
    if (table_elinks_00->cols_widths == (int *)0x0) {
      piVar11 = (int *)mem_calloc(sVar10,4);
      table_elinks_00->cols_widths = piVar11;
      if (piVar11 == (int *)0x0) {
        if (table_elinks_00->min_cols_widths != (int *)0x0) {
          mem_free(table_elinks_00->min_cols_widths);
        }
        table_elinks_00->min_cols_widths = (int *)0x0;
        if (table_elinks_00->max_cols_widths != (int *)0x0) {
          mem_free(table_elinks_00->max_cols_widths);
        }
        table_elinks_00->max_cols_widths = (int *)0x0;
        local_30 = table_elinks_00->link_num;
        goto ret2;
      }
      sVar10 = table_elinks_00->cols;
    }
    local_30 = 1;
LAB_080946f0:
    if (0 < (int)sVar10) {
      local_58 = 0;
      local_60 = 1;
      local_4c = 0x7fffffff;
LAB_08094710:
      local_48 = local_4c;
      if (0 < table_elinks_00->rows) {
        iVar9 = table_elinks_00->real_cols;
        local_44 = 0;
        do {
          iVar9 = iVar9 * local_44 + local_60 + -1;
          ptVar30 = table_elinks_00->cells;
          if ((ptVar30[iVar9].field_0x3c & 3) == 1) {
            if (assert_failed != 0) {
LAB_08094799:
              assert_failed = 0;
              local_30 = table_elinks_00->link_num;
              goto ret2;
            }
            bVar5 = table_elinks_00->cols < local_60 + -1 + ptVar30[iVar9].colspan;
            assert_failed = (int)bVar5;
            if (bVar5) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
              errline = 0x124;
              elinks_internal((uchar *)
                              "assertion cell->colspan + col <= table->cols failed: colspan out of table"
                             );
              if (assert_failed != 0) goto LAB_08094799;
            }
            local_48 = ptVar30[iVar9].colspan;
            if (local_48 == local_30) {
              local_54 = 0;
              if (1 < local_30) {
                iVar19 = 1;
                local_54 = 0;
                iVar28 = local_60;
                local_38 = local_60 << 4;
                do {
                  uVar6 = 0;
                  if (iVar28 != 0) {
                    if (table_elinks_00->rules - 2U < 2) {
                      if (table_elinks_00->cellspacing == 0) {
LAB_080948a5:
                        uVar6 = (uint)(table_elinks_00->cellpadding == 0);
                      }
                      else {
                        uVar6 = (uint)~table_elinks_00->cellspacing >> 0x1f;
                      }
                    }
                    else if (((table_elinks_00->rules != 4) ||
                             (table_elinks_00->columns_count == iVar28 ||
                              table_elinks_00->columns_count < iVar28)) ||
                            (uVar6 = 1,
                            *(int *)((int)&table_elinks_00->columns->group + local_38) == 0))
                    goto LAB_080948a5;
                  }
                  local_54 = local_54 + uVar6;
                  iVar19 = iVar19 + 1;
                  iVar28 = iVar28 + 1;
                  local_38 = local_38 + 0x10;
                } while (iVar19 < local_30);
              }
              local_5c = table_elinks_00->max_cols_widths;
              iVar28 = local_58 + (int)local_5c;
              iVar19 = 0;
              iVar23 = ptVar30[iVar9].min_width - local_54;
              piVar11 = table_elinks_00->min_cols_widths;
              iVar25 = 0;
              if (0 < local_48) {
                iVar25 = 0;
                do {
                  iVar25 = iVar25 + *(int *)((int)piVar11 + iVar19 * 4 + local_58);
                  iVar19 = iVar19 + 1;
                } while (iVar19 != local_30);
              }
              if (iVar25 < iVar23) {
                iVar23 = iVar23 - iVar25;
                iVar19 = iVar23 / local_48;
                iVar23 = iVar23 % local_48;
                if (iVar28 == 0) {
                  if (0 < local_48) {
LAB_080949c6:
                    iVar28 = 0;
                    do {
                      *(uint *)((int)piVar11 + iVar28 * 4 + local_58) =
                           *(int *)((int)piVar11 + iVar28 * 4 + local_58) + iVar19 +
                           (uint)(iVar28 < iVar23);
                      iVar28 = iVar28 + 1;
                    } while (iVar28 != local_30);
                    local_5c = table_elinks_00->max_cols_widths;
                  }
                  iVar28 = (int)local_5c + local_58;
                  goto LAB_080949fc;
                }
                if (local_48 < 1) {
                  local_54 = ptVar30[iVar9].max_width - local_54;
                  goto LAB_08094aa1;
                }
                iVar13 = 0;
                iVar25 = 0;
                do {
                  iVar21 = iVar19 + *(int *)((int)piVar11 + iVar25 * 4 + local_58) +
                           (uint)(iVar25 < iVar23);
                  *(int *)((int)piVar11 + iVar25 * 4 + local_58) = iVar21;
                  iVar3 = *(int *)(iVar28 + iVar25 * 4);
                  iVar21 = iVar21 - iVar3;
                  if (0 < iVar21) {
                    iVar13 = iVar13 + iVar21;
                    *(int *)((int)piVar11 + iVar25 * 4 + local_58) = iVar3;
                  }
                  iVar25 = iVar25 + 1;
                } while (iVar25 != local_30);
                if (iVar13 != 0) {
                  iVar19 = iVar13 / local_30;
                  iVar23 = iVar13 % local_30;
                  goto LAB_080949c6;
                }
                local_5c = table_elinks_00->max_cols_widths;
                local_54 = ptVar30[iVar9].max_width - local_54;
                iVar28 = (int)local_5c + local_58;
LAB_08094a10:
                iVar9 = 0;
                iVar19 = 0;
                do {
                  iVar9 = iVar9 + *(int *)(iVar28 + iVar19 * 4);
                  iVar19 = iVar19 + 1;
                } while (iVar19 != local_30);
                if (iVar9 < local_54) goto LAB_08094a2a;
LAB_08094aab:
                if (local_48 < 1) goto LAB_08094748;
              }
              else {
LAB_080949fc:
                local_54 = ptVar30[iVar9].max_width - local_54;
                if (0 < local_48) goto LAB_08094a10;
LAB_08094aa1:
                iVar9 = 0;
                if (local_54 < 1) goto LAB_08094aab;
LAB_08094a2a:
                if (local_48 < 1) goto LAB_08094748;
                iVar19 = 0;
                do {
                  *(uint *)(iVar28 + iVar19 * 4) =
                       *(int *)(iVar28 + iVar19 * 4) + (local_54 - iVar9) / local_48 +
                       (uint)(iVar19 < (local_54 - iVar9) % local_48);
                  iVar19 = iVar19 + 1;
                } while (iVar19 != local_30);
                local_5c = table_elinks_00->max_cols_widths;
              }
              iVar28 = 0;
              iVar9 = local_58;
              while( true ) {
                iVar19 = *(int *)((int)table_elinks_00->min_cols_widths + iVar9);
                if (*(int *)((int)local_5c + iVar9) < iVar19) {
                  *(int *)((int)local_5c + iVar9) = iVar19;
                }
                iVar28 = iVar28 + 1;
                iVar9 = iVar9 + 4;
                if (local_48 <= iVar28) break;
                local_5c = table_elinks_00->max_cols_widths;
              }
              goto LAB_08094748;
            }
            if ((local_48 <= local_30) || (local_4c <= local_48)) goto LAB_08094748;
            if (table_elinks_00->rows <= local_44 + 1) goto LAB_08094854;
          }
          else {
LAB_08094748:
            local_48 = local_4c;
            if (table_elinks_00->rows <= local_44 + 1) goto LAB_08094854;
          }
          local_44 = local_44 + 1;
          iVar9 = table_elinks_00->real_cols;
          local_4c = local_48;
        } while( true );
      }
      goto LAB_08094857;
    }
LAB_08094f85:
    iVar9 = 0;
    local_44 = 0;
    goto LAB_08094d3c;
  }
  goto ret0;
  while (pbVar32 = pbVar26 + -1, (*(byte *)((int)*ppuVar7 + (uint)pbVar26[-1] * 2 + 1) & 0x20) != 0)
  {
joined_r0x080944c8:
    pbVar26 = pbVar32;
    if (pbVar26 <= pbVar29) goto LAB_08094528;
  }
  if (pbVar29 < pbVar26) {
    parse_html(pbVar29,pbVar26,table_elinks_00->part,(uchar *)0x0,html_context);
    local_34 = table_elinks_00->bad_html_size;
  }
LAB_08094528:
  iVar27 = iVar27 + 1;
  goto LAB_0809447d;
LAB_08094854:
  sVar10 = table_elinks_00->cols;
LAB_08094857:
  local_58 = local_58 + 4;
  if ((int)sVar10 <= local_60) goto LAB_08094b29;
  local_4c = local_48;
  local_60 = local_60 + 1;
  goto LAB_08094710;
LAB_08094b29:
  if (local_48 == 0x7fffffff) {
    if (0 < (int)sVar10) {
      sVar22 = 0;
      uVar6 = 0xffffffff;
      iVar9 = 0;
      local_44 = 0;
      goto LAB_08094cb9;
    }
    goto LAB_08094f85;
  }
  local_30 = local_48;
  goto LAB_080946f0;
LAB_08094cb9:
  vl = -((int)~uVar6 >> 0x1f);
  local_44 = local_44 + table_elinks_00->min_cols_widths[sVar22] + vl;
  iVar9 = iVar9 + table_elinks_00->max_cols_widths[sVar22] + vl;
  if (table_elinks_00->max_cols_widths[sVar22] < table_elinks_00->cols_x[sVar22]) {
    iVar9 = iVar9 + table_elinks_00->cols_x[sVar22];
  }
  sVar22 = sVar22 + 1;
  if (sVar22 != sVar10) {
    if (sVar22 == 0) goto LAB_08094d0f;
    if (1 < table_elinks_00->rules - 2U) {
      if ((table_elinks_00->rules == 4) && ((int)sVar22 < table_elinks_00->columns_count)) {
        uVar6 = 1;
        uVar4 = table_elinks_00->columns[sVar22].group;
        goto joined_r0x08094d1b;
      }
      goto LAB_08094d07;
    }
    uVar6 = table_elinks_00->cellspacing;
    uVar4 = uVar6;
joined_r0x08094d1b:
    if (uVar4 == 0) {
LAB_08094d07:
      uVar6 = 0;
      if (table_elinks_00->cellpadding != 0) {
LAB_08094d0f:
        uVar6 = 0xffffffff;
      }
    }
    goto LAB_08094cb9;
  }
LAB_08094d3c:
  get_table_frames(table_elinks_00,&table_frames);
  table_elinks_00->min_width =
       ((byte)table_frames._0_1_ >> 3 & 1) + ((byte)table_frames._0_1_ >> 2 & 1) + local_44;
  table_elinks_00->max_width =
       ((byte)table_frames._0_1_ >> 3 & 1) + ((byte)table_frames._0_1_ >> 2 & 1) + iVar9;
  if ((assert_failed == 0) && (assert_failed = (int)(iVar9 < local_44), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x15f;
    elinks_internal((uchar *)"assertion min <= max failed: min(%d) > max(%d)",local_44,iVar9);
  }
  if ((ppVar14->document == (document *)0x0) && ((ppVar14->box).x == 0)) {
    if ((table_elinks_00->field_0x7c & 1) == 0) {
      iVar27 = table_elinks_00->width;
      iVar9 = table_elinks_00->max_width;
      if (iVar27 < iVar9) {
        table_elinks_00->max_width = iVar27;
        iVar9 = iVar27;
      }
    }
    else {
      iVar9 = table_elinks_00->max_width;
    }
    iVar27 = table_elinks_00->min_width;
    if (iVar9 < iVar27) {
      table_elinks_00->max_width = iVar27;
      iVar9 = iVar27;
    }
    if (ppVar14->max_width < iVar9 + iVar31) {
      ppVar14->max_width = iVar9 + iVar31;
    }
    iVar31 = iVar31 + table_elinks_00->min_width;
    if (iVar31 <= (ppVar14->box).width) goto LAB_08095bce;
    (ppVar14->box).width = iVar31;
    local_30 = table_elinks_00->link_num;
    goto ret2;
  }
  if (local_74 == 0) {
    iVar9 = table_elinks_00->min_width;
    iVar28 = table_elinks_00->width;
    if (iVar28 < iVar9) {
      iVar19 = iVar9;
      if (table_elinks_00->cellpadding == 0) goto LAB_08094dc7;
      table_elinks_00->cellpadding = 0;
      local_74 = 1;
      ppVar8 = table_elinks_00->part;
      local_78 = iVar9;
      goto LAB_08094589;
    }
  }
  else if (local_74 == 1) {
    iVar9 = table_elinks_00->min_width;
    if (local_78 < iVar9) {
      table_elinks_00->cellpadding = iVar27;
      local_74 = 2;
      ppVar8 = table_elinks_00->part;
      goto LAB_08094589;
    }
    iVar28 = table_elinks_00->width;
  }
  else {
    iVar28 = table_elinks_00->width;
    iVar9 = table_elinks_00->min_width;
  }
  iVar19 = iVar9;
  if ((iVar9 < iVar28) &&
     ((iVar28 <= table_elinks_00->max_width ||
      (iVar19 = table_elinks_00->max_width, (table_elinks_00->field_0x7c & 1) == 0)))) {
    iVar19 = iVar28;
  }
LAB_08094dc7:
  iVar27 = table_elinks_00->cols;
  if (iVar27 != 0) {
    if (assert_failed == 0) {
      assert_failed = -(iVar19 - iVar9 >> 0x1f);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 0x1ed;
        elinks_internal((uchar *)
                        "assertion spare_width >= 0 failed: too small width %d, required %d",iVar19,
                        table_elinks_00->min_width);
      }
      iVar27 = table_elinks_00->cols;
    }
    iVar28 = 0;
    for (iVar23 = 0; iVar23 < iVar27; iVar23 = iVar23 + 1) {
      if (iVar28 < table_elinks_00->max_cols_widths[iVar23]) {
        iVar28 = table_elinks_00->max_cols_widths[iVar23];
      }
    }
    sVar10 = iVar27 << 2;
    memcpy(table_elinks_00->cols_widths,table_elinks_00->min_cols_widths,sVar10);
    table_elinks_00->real_width = iVar19;
    piVar11 = (int *)mem_alloc(sVar10);
    if (piVar11 != (int *)0x0) {
      pvVar12 = mem_alloc(sVar10);
      if (pvVar12 != (void *)0x0) {
        local_3c = 0;
        iVar27 = iVar19 - iVar9;
LAB_08094e8e:
        local_30 = iVar27;
        if (local_30 != 0) {
          iVar9 = 0;
          memset(piVar11,0,sVar10);
          memset(pvVar12,0,sVar10);
          iVar27 = table_elinks_00->cols;
          local_38 = 0;
          piVar18 = piVar11;
          for (local_48 = 0; local_48 < iVar27; local_48 = local_48 + 1) {
            switch(local_3c) {
            case 0:
              if (*(int *)((int)table_elinks_00->cols_x + iVar9) <=
                  *(int *)((int)table_elinks_00->cols_widths + iVar9)) break;
              *piVar18 = 1;
              iVar27 = *(int *)((int)table_elinks_00->max_cols_widths + iVar9);
              iVar19 = *(int *)((int)table_elinks_00->cols_x + iVar9);
              if (iVar19 <= iVar27) {
                iVar27 = iVar19;
              }
              iVar27 = iVar27 - *(int *)((int)table_elinks_00->cols_widths + iVar9);
              *(int *)((int)pvVar12 + iVar9) = iVar27;
              if (0 < iVar27) goto LAB_08095c21;
LAB_08095cb5:
              *piVar18 = 0;
              iVar19 = 0;
              iVar27 = table_elinks_00->cols;
              goto LAB_08095c26;
            case 1:
              iVar19 = *(int *)((int)table_elinks_00->cols_x + iVar9);
              if (-2 < iVar19) break;
              *piVar18 = -2 - iVar19;
              piVar16 = table_elinks_00->max_cols_widths;
LAB_08095c0a:
              iVar27 = *(int *)((int)piVar16 + iVar9) -
                       *(int *)((int)table_elinks_00->cols_widths + iVar9);
              *(int *)((int)pvVar12 + iVar9) = iVar27;
              if (iVar27 < 1) goto LAB_08095cb5;
              goto LAB_08095c21;
            case 2:
              if (*(int *)((int)table_elinks_00->cols_x + iVar9) == -1)
              goto switchD_08094f99_caseD_3;
              break;
            case 3:
switchD_08094f99_caseD_3:
              iVar19 = *(int *)((int)table_elinks_00->cols_widths + iVar9);
              iVar23 = *(int *)((int)table_elinks_00->max_cols_widths + iVar9);
              if (iVar19 < iVar23) {
                *(int *)((int)pvVar12 + iVar9) = iVar23 - iVar19;
                if (iVar28 == 0) {
                  *piVar18 = 1;
                  iVar19 = 1;
                  iVar27 = table_elinks_00->cols;
                }
                else {
                  iVar19 = (*(int *)((int)table_elinks_00->max_cols_widths + iVar9) * 10) / iVar28 +
                           5;
                  *piVar18 = iVar19;
                  iVar27 = table_elinks_00->cols;
                }
                goto LAB_08095c26;
              }
              break;
            case 4:
              if (-1 < *(int *)((int)table_elinks_00->cols_x + iVar9)) {
                *piVar18 = 1;
                piVar16 = table_elinks_00->cols_x;
                goto LAB_08095c0a;
              }
              break;
            case 5:
              iVar19 = *(int *)((int)table_elinks_00->cols_x + iVar9);
              if (iVar19 < 0) {
                if (iVar19 == -1) {
                  *piVar18 = 1;
                }
                else {
                  *piVar18 = -2 - iVar19;
                }
                *(undefined4 *)((int)pvVar12 + iVar9) = 0x7fffffff;
                iVar19 = *piVar18;
                iVar27 = table_elinks_00->cols;
                goto LAB_08095c26;
              }
              break;
            case 6:
              *piVar18 = 1;
              *(undefined4 *)((int)pvVar12 + iVar9) = 0x7fffffff;
LAB_08095c21:
              iVar19 = *piVar18;
              iVar27 = table_elinks_00->cols;
              goto LAB_08095c26;
            default:
              local_38 = -1;
              goto LAB_08094eff;
            }
            iVar19 = *piVar18;
LAB_08095c26:
            local_38 = local_38 + iVar19;
            piVar18 = piVar18 + 1;
            iVar9 = iVar9 + 4;
          }
LAB_08094eff:
          if (assert_failed != 0) {
LAB_080950d4:
            assert_failed = 0;
            goto LAB_080950de;
          }
          assert_failed = (int)(local_38 == -1);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
            errline = 0x203;
            elinks_internal((uchar *)"assertion total_width != -1 failed: Could not expand table");
            if (assert_failed != 0) goto LAB_080950d4;
          }
          iVar27 = local_30;
          if (local_38 != 0) {
LAB_08094fa3:
            if (0 < table_elinks_00->cols) {
              local_48 = -1;
              iVar9 = 0;
              iVar19 = 0;
              do {
                if (piVar11[iVar19] == 0) {
LAB_08095000:
                  iVar23 = local_48;
                  iVar25 = iVar9;
                }
                else {
                  iVar13 = (piVar11[iVar19] * local_30) / local_38;
                  iVar23 = *(int *)((int)pvVar12 + iVar19 * 4);
                  iVar25 = 1;
                  if ((0 < iVar13) && (iVar25 = iVar23, iVar13 <= iVar23)) {
                    iVar25 = iVar13;
                  }
                  iVar23 = iVar19;
                  if (iVar25 <= iVar9) goto LAB_08095000;
                }
                iVar9 = iVar25;
                local_48 = iVar23;
                if (iVar19 + 1 == table_elinks_00->cols) goto LAB_0809500a;
                iVar19 = iVar19 + 1;
              } while( true );
            }
            goto LAB_08095054;
          }
LAB_08094f2b:
          local_3c = local_3c + 1;
          iVar27 = local_30;
          goto LAB_08094e8e;
        }
LAB_080950de:
        mem_free(pvVar12);
      }
      mem_free(piVar11);
    }
  }
  if ((ppVar2->document != (document *)0x0) || ((ppVar2->box).x != 1)) {
    piVar11 = (int *)mem_calloc(table_elinks_00->cols,4);
    if (piVar11 != (int *)0x0) {
      iVar27 = table_elinks_00->cols;
      local_34 = iVar27;
      for (local_44 = 0; local_44 < table_elinks_00->rows; local_44 = local_44 + 1) {
        for (local_30 = 0; local_30 < iVar27; local_30 = local_30 + 1) {
          ptVar30 = table_elinks_00->cells + local_44 * table_elinks_00->real_cols + local_30;
          if (ptVar30->start != (uchar *)0x0) {
            iVar27 = ptVar30->colspan;
            if (iVar27 < 1) {
              local_38 = table_elinks_00->cellpadding;
              iVar9 = 0;
            }
            else {
              local_38 = table_elinks_00->cellpadding;
              iVar9 = 0;
              iVar28 = 0;
              piVar18 = table_elinks_00->cols_widths + local_30;
              do {
                while( true ) {
                  iVar23 = *piVar18;
                  iVar19 = iVar28 + local_30;
                  if ((iVar28 != 0) && (iVar19 != 0)) break;
LAB_0809518a:
                  iVar28 = iVar28 + 1;
                  piVar18 = piVar18 + 1;
                  iVar9 = iVar9 + iVar23;
                  if (iVar28 == iVar27) goto LAB_080951f8;
                }
                if (table_elinks_00->rules - 2U < 2) {
                  if (table_elinks_00->cellspacing == 0) goto LAB_080951d1;
                  if (-1 < table_elinks_00->cellspacing) goto LAB_080951d7;
                  goto LAB_0809518a;
                }
                if (((table_elinks_00->rules != 4) || (table_elinks_00->columns_count <= iVar19)) ||
                   (table_elinks_00->columns[iVar19].group == 0)) {
LAB_080951d1:
                  if (local_38 != 0) goto LAB_0809518a;
                }
LAB_080951d7:
                iVar28 = iVar28 + 1;
                piVar18 = piVar18 + 1;
                iVar9 = iVar9 + iVar23 + 1;
              } while (iVar28 != iVar27);
            }
LAB_080951f8:
            ptVar30->width = -1;
            ppVar14 = format_html_part(html_context,ptVar30->start,ptVar30->end,0,local_38,iVar9,
                                       (document *)0x0,1,1,(uchar *)0x0,ptVar30->link_num);
            if (ppVar14 != (part *)0x0) {
              ptVar30->width = (ppVar14->box).width;
              mem_free(ppVar14);
            }
            if (iVar9 < ptVar30->width) {
              ptVar30->width = iVar9;
            }
            iVar27 = table_elinks_00->cols;
          }
          local_34 = iVar27;
        }
      }
      colspan_1 = 1;
      do {
        local_48 = 0;
        local_30 = 0x7fffffff;
        for (local_4c = 1; iVar27 = local_4c + -1, iVar27 < local_34; local_4c = local_4c + 1) {
          iVar9 = table_elinks_00->rows;
          for (local_50 = 0; local_50 < iVar9; local_50 = local_50 + 1) {
            ptVar30 = table_elinks_00->cells + local_50 * table_elinks_00->real_cols + iVar27;
            if (ptVar30->start != (uchar *)0x0) {
              if (assert_failed != 0) {
LAB_080953ca:
                assert_failed = 0;
                goto end;
              }
              bVar5 = table_elinks_00->cols < iVar27 + ptVar30->colspan;
              assert_failed = (int)bVar5;
              if (bVar5) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 0x26d;
                elinks_internal((uchar *)
                                "assertion cell->colspan + col <= table->cols failed: colspan out of table"
                               );
                if (assert_failed != 0) goto LAB_080953ca;
              }
              iVar28 = ptVar30->colspan;
              if (iVar28 == colspan_1) {
                local_3c = 0;
                if (1 < colspan_1) {
                  local_44 = 1;
                  local_34 = local_4c;
                  local_38 = local_4c << 4;
                  do {
                    uVar6 = 0;
                    if (local_34 != 0) {
                      if (table_elinks_00->rules - 2U < 2) {
                        if (table_elinks_00->cellspacing == 0) {
LAB_080955a9:
                          uVar6 = (uint)(table_elinks_00->cellpadding == 0);
                        }
                        else {
                          uVar6 = (uint)~table_elinks_00->cellspacing >> 0x1f;
                        }
                      }
                      else if (((table_elinks_00->rules != 4) ||
                               (table_elinks_00->columns_count <= local_34)) ||
                              (uVar6 = 1,
                              *(int *)((int)&table_elinks_00->columns->group + local_38) == 0))
                      goto LAB_080955a9;
                    }
                    local_44 = local_44 + 1;
                    local_3c = local_3c + uVar6;
                    local_34 = local_34 + 1;
                    local_38 = local_38 + 0x10;
                  } while (local_44 < colspan_1);
                }
                local_3c = ptVar30->width - local_3c;
                iVar9 = 0;
                if (0 < iVar28) {
                  iVar19 = 0;
                  do {
                    iVar9 = iVar9 + *(int *)((int)piVar11 + iVar19 * 4 + local_48);
                    iVar19 = iVar19 + 1;
                  } while (iVar19 != colspan_1);
                }
                if (iVar9 < local_3c) {
                  local_3c = local_3c - iVar9;
                  iVar9 = local_3c / iVar28;
                  local_3c = local_3c % iVar28;
                  iVar19 = (int)table_elinks_00->max_cols_widths + local_48;
                  if (iVar19 == 0) {
                    local_34 = local_3c;
                    if (0 < iVar28) {
LAB_08095699:
                      iVar28 = 0;
                      do {
                        *(uint *)((int)piVar11 + iVar28 * 4 + local_48) =
                             (uint)(iVar28 < local_34) +
                             *(int *)((int)piVar11 + iVar28 * 4 + local_48) + iVar9;
                        iVar28 = iVar28 + 1;
                      } while (iVar28 != colspan_1);
                    }
                  }
                  else if (0 < iVar28) {
                    local_34 = 0;
                    iVar28 = 0;
                    do {
                      iVar23 = iVar9 + *(int *)((int)piVar11 + iVar28 * 4 + local_48) +
                               (uint)(iVar28 < local_3c);
                      *(int *)((int)piVar11 + iVar28 * 4 + local_48) = iVar23;
                      iVar25 = *(int *)(iVar19 + iVar28 * 4);
                      iVar23 = iVar23 - iVar25;
                      if (0 < iVar23) {
                        local_34 = local_34 + iVar23;
                        *(int *)((int)piVar11 + iVar28 * 4 + local_48) = iVar25;
                      }
                      iVar28 = iVar28 + 1;
                    } while (iVar28 != colspan_1);
                    if (local_34 != 0) {
                      iVar9 = local_34 / colspan_1;
                      local_34 = local_34 % colspan_1;
                      goto LAB_08095699;
                    }
                  }
                }
              }
              else if ((colspan_1 < iVar28) && (iVar28 < local_30)) {
                iVar9 = table_elinks_00->rows;
                local_30 = iVar28;
                goto LAB_08095399;
              }
              iVar9 = table_elinks_00->rows;
            }
LAB_08095399:
          }
          local_34 = table_elinks_00->cols;
          local_48 = local_48 + 4;
        }
        colspan_1 = local_30;
      } while (local_30 != 0x7fffffff);
      iVar28 = 0;
      iVar9 = 0;
      for (iVar27 = 0; iVar27 < local_34; iVar27 = iVar27 + 1) {
        iVar9 = iVar9 + table_elinks_00->cols_widths[iVar27];
        iVar28 = iVar28 + piVar11[iVar27];
      }
      if (iVar28 <= iVar9) {
        local_30 = 0;
        iVar19 = -1;
        for (iVar27 = 0; iVar27 < local_34; iVar27 = iVar27 + 1) {
          iVar23 = table_elinks_00->max_cols_widths[iVar27];
          iVar25 = iVar27;
          if (table_elinks_00->max_cols_widths[iVar27] <= iVar19) {
            iVar23 = iVar19;
            iVar25 = local_30;
          }
          local_30 = iVar25;
          iVar19 = iVar23;
        }
        if ((iVar19 != -1) &&
           (iVar27 = piVar11[local_30] + (iVar9 - iVar28), piVar11[local_30] = iVar27,
           iVar27 <= table_elinks_00->max_cols_widths[local_30])) {
          mem_free(table_elinks_00->cols_widths);
          table_elinks_00->cols_widths = piVar11;
          goto LAB_080953df;
        }
      }
end:
      mem_free(piVar11);
    }
LAB_080953df:
    pbVar29 = (table_elinks_00->caption).end;
    pbVar32 = (table_elinks_00->caption).start;
    if ((pbVar29 != (byte *)0x0) && (pbVar32 != (byte *)0x0)) {
      for (; pbVar32 < pbVar29; pbVar32 = pbVar32 + 1) {
        ppuVar7 = __ctype_b_loc();
        if ((*(byte *)((int)*ppuVar7 + (uint)*pbVar32 * 2 + 1) & 0x20) == 0) goto LAB_08096485;
      }
    }
    goto LAB_080953f7;
  }
  iVar27 = table_elinks_00->real_width;
  iVar31 = iVar31 + iVar27;
  iVar9 = *(int *)((int)(html_context->stack).next + 0x80);
  if ((iVar27 <= iVar31) && (iVar27 = iVar9, iVar31 <= iVar9)) {
    iVar27 = iVar31;
  }
  if ((ppVar2->box).width < iVar27) {
LAB_08095302:
    (ppVar2->box).width = iVar27;
  }
LAB_08095305:
  ppVar2->cy = ppVar2->cy + table_elinks_00->real_height;
  local_30 = table_elinks_00->link_num;
  goto ret2;
LAB_0809500a:
  if (local_48 == -1) {
LAB_08095054:
    if (local_30 - iVar27 == 0) goto LAB_08094f2b;
    iVar27 = local_30 - (local_30 - iVar27);
    goto LAB_08094e8e;
  }
  if (iVar27 < iVar9) {
    iVar9 = iVar27;
  }
  piVar11[local_48] = 0;
  if ((assert_failed == 0) && (assert_failed = -(iVar9 >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
    errline = 0x1d4;
    elinks_internal((uchar *)"assertion stretch_width >= 0 failed: shrinking cell");
  }
  table_elinks_00->cols_widths[local_48] = table_elinks_00->cols_widths[local_48] + iVar9;
  iVar27 = iVar27 - iVar9;
  if (iVar27 == 0) goto LAB_08094e8e;
  goto LAB_08094fa3;
  while( true ) {
    ppuVar7 = __ctype_b_loc();
    pbVar29 = pbVar26 + -1;
    if ((*(byte *)((int)*ppuVar7 + (uint)pbVar26[-1] * 2 + 1) & 0x20) == 0) break;
LAB_08096485:
    pbVar26 = pbVar29;
    if (pbVar26 <= pbVar32) goto LAB_080953f7;
  }
  ppVar14 = format_html_part(html_context,pbVar32,pbVar26,table_elinks_00->align,0,
                             table_elinks_00->real_width,(document *)0x0,0,0,(uchar *)0x0,
                             table_elinks_00->link_num);
  if (ppVar14 == (part *)0x0) {
LAB_080953f7:
    height_1 = 0;
  }
  else {
    height_1 = (ppVar14->box).height;
    mem_free(ppVar14);
  }
  table_elinks_00->caption_height = height_1;
  for (local_34 = 0; iVar27 = table_elinks_00->rows, local_34 < iVar27; local_34 = local_34 + 1) {
    iVar27 = table_elinks_00->cols;
    local_30 = 1;
    for (iVar9 = 0; iVar9 < iVar27; iVar9 = iVar9 + 1) {
      ptVar30 = table_elinks_00->cells + iVar9 + local_34 * table_elinks_00->real_cols;
      if ((ptVar30->field_0x3c & 3) == 1) {
        iVar27 = ptVar30->colspan;
        if (iVar27 < 1) {
          iVar28 = table_elinks_00->cellpadding;
          local_38 = 0;
        }
        else {
          iVar28 = table_elinks_00->cellpadding;
          local_44 = local_30 << 4;
          piVar11 = table_elinks_00->cols_widths + iVar9;
          local_38 = 0;
          local_3c = 0;
          iVar19 = local_30;
          do {
            iVar23 = *piVar11;
            if ((local_3c < iVar27 + -1) && (iVar19 != 0)) {
              if (table_elinks_00->rules - 2U < 2) {
                if (table_elinks_00->cellspacing == 0) goto LAB_080954e2;
                if (table_elinks_00->cellspacing < 0) goto LAB_08095490;
              }
              else if (((table_elinks_00->rules != 4) || (table_elinks_00->columns_count <= iVar19))
                      || (*(int *)((int)&table_elinks_00->columns->group + local_44) == 0)) {
LAB_080954e2:
                if (iVar28 != 0) goto LAB_08095490;
              }
              local_4c = 1;
            }
            else {
LAB_08095490:
              local_4c = 0;
            }
            piVar11 = piVar11 + 1;
            iVar19 = iVar19 + 1;
            local_3c = local_3c + 1;
            local_38 = local_38 + local_4c + iVar23;
            local_44 = local_44 + 0x10;
          } while (local_3c != iVar27);
        }
        ppVar14 = format_html_part(html_context,ptVar30->start,ptVar30->end,ptVar30->align,iVar28,
                                   local_38,(document *)0x0,2,2,(uchar *)0x0,ptVar30->link_num);
        if (ppVar14 == (part *)0x0) goto LAB_0809572f;
        ptVar30->height = (ppVar14->box).height;
        mem_free(ppVar14);
        iVar27 = table_elinks_00->cols;
      }
      local_30 = local_30 + 1;
    }
  }
  rowspan = 1;
  do {
    local_30 = 0x7fffffff;
    for (iVar9 = 0; iVar9 < iVar27; iVar9 = iVar9 + 1) {
      if (0 < table_elinks_00->cols) {
        local_34 = 0;
        do {
          iVar27 = table_elinks_00->real_cols * iVar9 + local_34;
          ptVar30 = table_elinks_00->cells;
          if ((ptVar30[iVar27].field_0x3c & 3) == 1) {
            iVar28 = ptVar30[iVar27].rowspan;
            if (iVar28 == rowspan) {
              local_3c = 0;
              if (1 < rowspan) {
                local_38 = 1;
                do {
                  uVar6 = get_hline_width(table_elinks_00,local_38 + iVar9);
                  local_38 = local_38 + 1;
                  local_3c = local_3c - ((int)~uVar6 >> 0x1f);
                } while (local_38 < rowspan);
              }
              iVar28 = 0;
              piVar11 = table_elinks_00->rows_heights;
              local_3c = ptVar30[iVar27].height - local_3c;
              if (0 < rowspan) {
                iVar27 = 0;
                do {
                  iVar28 = iVar28 + piVar11[iVar9 + iVar27];
                  iVar27 = iVar27 + 1;
                } while (iVar27 != rowspan);
              }
              if (iVar28 < local_3c) {
                t_1 = local_3c - iVar28;
                if (0 < rowspan) {
                  iVar27 = 0;
                  do {
                    piVar11[iVar9 + iVar27] =
                         (uint)(iVar27 < t_1 % rowspan) + piVar11[iVar9 + iVar27] + t_1 / rowspan;
                    iVar27 = iVar27 + 1;
                  } while (iVar27 != rowspan);
                }
              }
              goto LAB_08095833;
            }
            if ((iVar28 <= rowspan) || (local_30 <= iVar28)) goto LAB_08095833;
          }
          else {
LAB_08095833:
            iVar28 = local_30;
          }
          local_34 = local_34 + 1;
          local_30 = iVar28;
        } while (local_34 < table_elinks_00->cols);
        iVar27 = table_elinks_00->rows;
      }
    }
    rowspan = local_30;
  } while (local_30 != 0x7fffffff);
  get_table_frames(table_elinks_00,&table_frames);
  iVar27 = table_elinks_00->rows;
  iVar9 = ((byte)table_frames._0_1_ & 1) + ((byte)table_frames._0_1_ >> 1 & 1) +
          table_elinks_00->caption_height;
  for (iVar28 = 0; iVar28 < iVar27; iVar28 = iVar28 + 1) {
    iVar9 = iVar9 + table_elinks_00->rows_heights[iVar28];
    if (iVar28 != 0) {
      iVar27 = get_hline_width(table_elinks_00,iVar28);
      if (-1 < iVar27) {
        iVar9 = iVar9 + 1;
      }
      iVar27 = table_elinks_00->rows;
    }
  }
  table_elinks_00->real_height = iVar9;
LAB_0809572f:
  if (ppVar2->document == (document *)0x0) {
    iVar27 = iVar31 + table_elinks_00->real_width;
    if ((ppVar2->box).width < iVar27) goto LAB_08095302;
    goto LAB_08095305;
  }
  pvVar12 = (ppVar2->document->nodes).next;
  *(int *)((int)pvVar12 + 0x14) = (ppVar2->cy + (ppVar2->box).y) - *(int *)((int)pvVar12 + 0xc);
  iVar27 = table_elinks_00->real_width;
  pvVar17 = (html_context->stack).next;
  iVar31 = table_elinks_00->align;
  iVar9 = *(int *)((int)pvVar17 + 0x80) - iVar27;
  if (iVar31 == 1) {
    iVar28 = ((iVar9 - *(int *)((int)pvVar17 + 0x7c)) + *(int *)((int)pvVar17 + 0x78)) / 2;
  }
  else if (iVar31 == 2) {
    iVar28 = iVar9 - *(int *)((int)pvVar17 + 0x7c);
  }
  else {
    iVar28 = *(int *)((int)pvVar17 + 0x78);
  }
  if (iVar28 <= iVar9) {
    iVar9 = iVar28;
  }
  if (iVar9 < 0) {
    iVar9 = 0;
  }
  iVar28 = (ppVar2->box).y;
  local_40 = ppVar2->cy;
  iVar19 = (ppVar2->box).x;
  pbVar29 = (table_elinks_00->caption).end;
  pbVar32 = (table_elinks_00->caption).start;
  if ((pbVar29 != (byte *)0x0) && (pbVar32 != (byte *)0x0)) {
    while ((pbVar32 < pbVar29 &&
           (ppuVar7 = __ctype_b_loc(),
           (*(byte *)((int)*ppuVar7 + (uint)*pbVar32 * 2 + 1) & 0x20) != 0))) {
      pbVar32 = pbVar32 + 1;
    }
    do {
      pbVar26 = pbVar29;
      if (pbVar26 <= pbVar32) goto LAB_08095f47;
      ppuVar7 = __ctype_b_loc();
      pbVar29 = pbVar26 + -1;
    } while ((*(byte *)((int)*ppuVar7 + (uint)pbVar26[-1] * 2 + 1) & 0x20) != 0);
    ppVar14 = format_html_part(html_context,pbVar32,pbVar26,iVar31,0,iVar27,
                               table_elinks_00->part->document,iVar9 + iVar19,local_40 + iVar28,
                               (uchar *)0x0,table_elinks_00->link_num);
    if (ppVar14 == (part *)0x0) {
      local_40 = ppVar2->cy;
      pvVar17 = (html_context->stack).next;
    }
    else {
      piVar11 = &table_elinks_00->part->cy;
      *piVar11 = *piVar11 + (ppVar14->box).height;
      table_elinks_00->part->cx = -1;
      table_elinks_00->part->link_num = ppVar14->link_num;
      mem_free(ppVar14);
      local_40 = ppVar2->cy;
      pvVar17 = (html_context->stack).next;
    }
  }
LAB_08095f47:
  bgcolor_00 = *(color_T *)((int)pvVar17 + 0x94);
  get_table_frames(table_elinks_00,&table_frames);
  if (table_elinks_00->fragment_id != (uchar *)0x0) {
    add_fragment_identifier(html_context,table_elinks_00->part,table_elinks_00->fragment_id);
  }
  expand_lines(html_context,table_elinks_00->part,iVar9 + -1,local_40,table_elinks_00->real_height,
               bgcolor_00);
  local_54 = ((byte)table_frames._0_1_ >> 2 & 1) + iVar9;
  iVar27 = table_elinks_00->cols;
  local_4c = 1;
  local_3c = 0;
  while (local_3c < iVar27) {
    local_58 = 0;
    local_44 = ((byte)table_frames._0_1_ & 1) + local_40;
    local_48 = 1;
    while( true ) {
      iVar27 = local_48 + -1;
      if (table_elinks_00->rows <= iVar27) break;
      iVar31 = *(int *)((int)table_elinks_00->rows_heights + local_58);
      if (iVar27 < table_elinks_00->rows + -1) {
        iVar28 = get_hline_width(table_elinks_00,local_48);
        local_70 = 1;
        if (iVar28 < 0) goto LAB_08096028;
      }
      else {
LAB_08096028:
        local_70 = 0;
      }
      document = table_elinks_00->part->document;
      ptVar30 = table_elinks_00->cells + iVar27 * table_elinks_00->real_cols + local_3c;
      if (ptVar30->start != (uchar *)0x0) {
        iVar27 = ptVar30->colspan;
        local_50 = 0;
        if (0 < iVar27) {
          iVar28 = 0;
          piVar11 = table_elinks_00->cols_widths + local_3c;
          local_50 = 0;
          do {
            iVar19 = *piVar11;
            if ((iVar28 < iVar27 + -1) && (iVar23 = iVar28 + local_3c + 1, iVar23 != 0)) {
              if (table_elinks_00->rules - 2U < 2) {
                if (table_elinks_00->cellspacing == 0) goto LAB_080962a8;
                uVar6 = (uint)~table_elinks_00->cellspacing >> 0x1f;
              }
              else if (((table_elinks_00->rules != 4) || (table_elinks_00->columns_count <= iVar23))
                      || (uVar6 = 1, table_elinks_00->columns[iVar23].group == 0)) {
LAB_080962a8:
                uVar6 = (uint)(table_elinks_00->cellpadding == 0);
              }
            }
            else {
              uVar6 = 0;
            }
            iVar28 = iVar28 + 1;
            piVar11 = piVar11 + 1;
            local_50 = local_50 + uVar6 + iVar19;
          } while (iVar28 != iVar27);
        }
        iVar27 = ptVar30->rowspan;
        local_30 = 0;
        if (0 < iVar27) {
          local_34 = local_48;
          iVar19 = 0;
          iVar28 = local_58;
          do {
            iVar23 = *(int *)((int)table_elinks_00->rows_heights + iVar28);
            if (iVar19 < iVar27 + -1) {
              iVar27 = get_hline_width(table_elinks_00,local_34);
              if (iVar27 < 0) {
                iVar27 = ptVar30->rowspan;
                goto LAB_080960de;
              }
              iVar25 = 1;
              iVar27 = ptVar30->rowspan;
            }
            else {
LAB_080960de:
              iVar25 = 0;
            }
            iVar19 = iVar19 + 1;
            iVar28 = iVar28 + 4;
            local_34 = local_34 + 1;
            local_30 = local_30 + iVar25 + iVar23;
          } while (iVar19 < iVar27);
        }
        pvVar17 = init_html_parser_state(html_context,ELEMENT_DONT_KILL,ptVar30->align,0,0);
        if ((ptVar30->field_0x3c & 4) != 0) {
          puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
          *puVar1 = *puVar1 | 1;
        }
        *(color_T *)((int)(html_context->stack).next + 0x14) = ptVar30->bgcolor;
        *(color_T *)((int)(html_context->stack).next + 0x94) = ptVar30->bgcolor;
        if (ptVar30->valign == 1) {
          iVar27 = (local_30 - ptVar30->height) / 2 + local_44;
        }
        else {
          iVar27 = local_44;
          if (ptVar30->valign == 2) {
            iVar27 = (local_44 - ptVar30->height) + local_30;
          }
        }
        iVar28 = local_54;
        if (document != (document *)0x0) {
          iVar28 = local_54 + (table_elinks_00->part->box).x;
          iVar27 = iVar27 + (table_elinks_00->part->box).y;
        }
        ppVar14 = format_html_part(html_context,ptVar30->start,ptVar30->end,ptVar30->align,
                                   table_elinks_00->cellpadding,local_50,document,iVar28,iVar27,
                                   (uchar *)0x0,ptVar30->link_num);
        if (ppVar14 == (part *)0x0) {
          done_html_parser_state(html_context,pvVar17);
        }
        else {
          if ((assert_failed == 0) &&
             (bVar5 = local_30 < ptVar30->height, assert_failed = (int)bVar5, bVar5)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
            errline = 0x378;
            elinks_internal((uchar *)"assertion height >= cell->height failed!");
          }
          expand_lines(html_context,table_elinks_00->part,local_54 + -1 + local_50,local_44,local_30
                       ,ptVar30->bgcolor);
          if (ptVar30->fragment_id != (uchar *)0x0) {
            add_fragment_identifier(html_context,ppVar14,ptVar30->fragment_id);
          }
          done_html_parser_state(html_context,pvVar17);
          mem_free(ppVar14);
        }
      }
      local_48 = local_48 + 1;
      local_44 = local_44 + iVar31 + local_70;
      local_58 = local_58 + 4;
    }
    iVar27 = table_elinks_00->cols;
    if (local_3c < iVar27 + -1) {
      uVar6 = 0;
      if (local_4c != 0) {
        if (table_elinks_00->rules - 2U < 2) {
          if (table_elinks_00->cellspacing == 0) goto LAB_080963c2;
          uVar6 = (uint)~table_elinks_00->cellspacing >> 0x1f;
        }
        else if (((table_elinks_00->rules != 4) || (table_elinks_00->columns_count <= local_4c)) ||
                (uVar6 = 1, table_elinks_00->columns[local_4c].group == 0)) {
LAB_080963c2:
          uVar6 = (uint)(table_elinks_00->cellpadding == 0);
        }
      }
      local_54 = table_elinks_00->cols_widths[local_3c] + local_54 + uVar6;
    }
    local_4c = local_4c + 1;
    local_3c = local_3c + 1;
  }
  expand_lines(html_context,table_elinks_00->part,iVar9 + -1 + table_elinks_00->real_width,local_40,
               table_elinks_00->real_height,table_elinks_00->bgcolor);
  check_html_form_hierarchy(table_elinks_00->part);
  iVar27 = table_elinks_00->real_height;
  iVar19 = 1;
  iVar31 = table_elinks_00->part->cy;
  iVar28 = table_elinks_00->rows;
  local_40 = ((byte)table_frames._0_1_ & 1) + ((byte)table_frames._0_1_ >> 1 & 1) +
             table_elinks_00->caption_height + local_40;
  for (iVar23 = 0; iVar23 < iVar28; iVar23 = iVar23 + 1) {
    iVar25 = table_elinks_00->rows_heights[iVar23];
    iVar13 = 0;
    if (iVar23 < iVar28 + -1) {
      iVar28 = get_hline_width(table_elinks_00,iVar19);
      if (iVar28 < 0) {
        iVar28 = table_elinks_00->rows;
        iVar13 = 0;
      }
      else {
        iVar28 = table_elinks_00->rows;
        iVar13 = 1;
      }
    }
    iVar19 = iVar19 + 1;
    local_40 = local_40 + iVar13 + iVar25;
  }
  if (assert_failed == 0) {
    iVar31 = iVar31 + iVar27;
    assert_failed = (int)(iVar31 != local_40);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 0x2c0;
      elinks_internal((uchar *)
                      "assertion old_height == our_height failed: size not matching! %d vs %d",
                      iVar31,local_40);
    }
  }
  draw_table_frames(table_elinks_00,iVar9,ppVar2->cy,html_context);
  ppVar2->cy = ppVar2->cy + table_elinks_00->real_height;
  ppVar2->cx = -1;
  ppvVar15 = (void **)mem_alloc(0x18);
  if (ppvVar15 != (void **)0x0) {
    pvVar17 = *(void **)((int)pvVar12 + 0x10);
    pvVar24 = (void *)(ppVar2->cy + (ppVar2->box).y);
    pvVar12 = *(void **)((int)pvVar12 + 8);
    ppvVar15[5] = (void *)0x0;
    if ((int)pvVar12 < 0) {
      pvVar12 = (void *)0x0;
    }
    if ((int)pvVar24 < 0) {
      pvVar24 = (void *)0x0;
    }
    pvVar20 = (void *)0x0;
    if (-1 < (int)pvVar17) {
      pvVar20 = pvVar17;
    }
    ppvVar15[2] = pvVar12;
    ppvVar15[3] = pvVar24;
    ppvVar15[4] = pvVar20;
    *ppvVar15 = (ppVar2->document->nodes).next;
    ppvVar15[1] = &ppVar2->document->nodes;
    (ppVar2->document->nodes).next = ppvVar15;
    *(void ***)((int)*ppvVar15 + 4) = ppvVar15;
  }
LAB_08095bce:
  local_30 = table_elinks_00->link_num;
ret2:
  ppVar2->link_num = local_30;
  if ((ppVar2->box).height < ppVar2->cy) {
    (ppVar2->box).height = ppVar2->cy;
  }
  html_context->part = ppVar2;
  done_html_parser_state(html_context,state);
  free_table(table_elinks_00);
ret0:
  iVar27 = html_context->table_level + -1;
  html_context->table_level = iVar27;
  if (iVar27 == 0) {
    free_table_cache();
  }
  return;
}



// WARNING: Unknown calling convention

form_control * init_form_control(form_type type,uchar *attr,html_context *html_context)

{
  form_control *pfVar1;
  form_control *fc;
  uchar *puVar2;
  form_mode fVar3;
  
  pfVar1 = (form_control *)mem_calloc(1,0x54);
  if (pfVar1 != (form_control *)0x0) {
    pfVar1->type = type;
    pfVar1->position = (int)attr - (int)html_context->startf;
    puVar2 = get_attr_value(attr,(uchar *)"disabled",html_context->doc_cp,HTML_ATTR_TEST);
    fVar3 = FORM_MODE_DISABLED;
    if (puVar2 == (uchar *)0x0) {
      puVar2 = get_attr_value(attr,(uchar *)"readonly",html_context->doc_cp,HTML_ATTR_TEST);
      fVar3 = (form_mode)(puVar2 != (uchar *)0x0);
    }
    pfVar1->mode = fVar3;
  }
  return pfVar1;
}



// WARNING: Unknown calling convention

void html_textarea(html_context *html_context,uchar *attr,uchar *html,uchar *eof,uchar **end)

{
  undefined *puVar1;
  uint *puVar2;
  uchar uVar3;
  int iVar4;
  form_control *pfVar5;
  uchar *puVar6;
  uchar *puVar7;
  int cols;
  int rows;
  uchar *wrap_attr;
  int iVar8;
  int iVar9;
  size_t __n;
  document_options *pdVar10;
  uchar *p;
  int iVar11;
  int j;
  int local_30;
  size_t local_24;
  uchar *local_20 [4];
  
  html_focusable(html_context,attr);
  puVar7 = html;
  if (html < eof) {
    do {
      if ((*html != '\r') && (puVar7 = html, *html != '\n')) break;
      html = html + 1;
      puVar7 = html;
    } while (html < eof);
  }
  do {
    if (eof <= html) {
      *end = eof;
      return;
    }
    if ((*html == '<') &&
       (iVar4 = parse_element(html,eof,local_20,(int *)&local_24,(uchar **)0x0,end), iVar4 == 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 0x286;
      iVar4 = elinks_strlcasecmp(local_20[0],local_24,(uchar *)"/TEXTAREA",9,1);
      if (iVar4 == 0) {
        pfVar5 = init_form_control(FC_TEXTAREA,attr,html_context);
        if (pfVar5 == (form_control *)0x0) {
          return;
        }
        puVar6 = get_attr_value(attr,"id",html_context->doc_cp,HTML_ATTR_NONE);
        pfVar5->id = puVar6;
        puVar6 = get_attr_value(attr,"name",html_context->doc_cp,HTML_ATTR_NONE);
        pfVar5->name = puVar6;
        puVar7 = convert_string_elinks
                           ((conv_table *)0x0,puVar7,(int)html - (int)puVar7,html_context->doc_cp,
                            CSM_DEFAULT,(int *)0x0,(_func_void_void_ptr_uchar_ptr_int *)0x0,
                            (void *)0x0);
        pfVar5->default_value = puVar7;
        if (puVar7 == (uchar *)0x0) goto LAB_08096848;
        uVar3 = *puVar7;
        break;
      }
    }
    html = html + 1;
  } while( true );
joined_r0x080967ff:
  if (uVar3 == '\0') goto LAB_08096848;
  puVar6 = puVar7 + 1;
  if (uVar3 == '\r') {
    if ((puVar7[1] == '\n') || ((pfVar5->default_value < puVar7 && (puVar7[-1] == '\n')))) {
      __n = strlen((char *)puVar7);
      memmove(puVar7,puVar7 + 1,__n);
      puVar6 = puVar7;
    }
    else {
      *puVar7 = '\n';
      puVar6 = puVar7 + 1;
    }
  }
  if (puVar6 == (uchar *)0x0) goto LAB_08096848;
  uVar3 = *puVar6;
  puVar7 = puVar6;
  goto joined_r0x080967ff;
LAB_08096848:
  iVar4 = get_num(attr,"cols",html_context->doc_cp);
  if (iVar4 < 1) {
    pdVar10 = html_context->options;
    iVar4 = pdVar10->default_form_input_size;
  }
  else {
    pdVar10 = html_context->options;
  }
  iVar11 = (pdVar10->box).width;
  if (iVar4 + 1 <= iVar11) {
    iVar11 = iVar4 + 1;
  }
  pfVar5->cols = iVar11;
  rows = get_num(attr,"rows",html_context->doc_cp);
  if (rows < 1) {
    rows = 1;
  }
  iVar4 = (html_context->options->box).height;
  if (rows <= iVar4) {
    iVar4 = rows;
  }
  pfVar5->rows = iVar4;
  puVar1 = &html_context->options->field_0x5c;
  *puVar1 = *puVar1 | 1;
  puVar7 = get_attr_value(attr,"wrap",html_context->doc_cp,HTML_ATTR_NONE);
  if (puVar7 == (uchar *)0x0) {
    puVar7 = get_attr_value(attr,(uchar *)"nowrap",html_context->doc_cp,HTML_ATTR_TEST);
    pfVar5->wrap = (uint)(puVar7 == (uchar *)0x0);
  }
  else {
    iVar8 = c_strcasecmp((char *)puVar7,"hard");
    if ((iVar8 == 0) || (iVar8 = c_strcasecmp((char *)puVar7,"physical"), iVar8 == 0)) {
      pfVar5->wrap = FORM_WRAP_HARD;
    }
    else {
      iVar8 = c_strcasecmp((char *)puVar7,"soft");
      if ((iVar8 == 0) || (iVar8 = c_strcasecmp((char *)puVar7,"virtual"), iVar8 == 0)) {
        pfVar5->wrap = FORM_WRAP_SOFT;
      }
      else {
        iVar8 = c_strcasecmp((char *)puVar7,"none");
        if ((iVar8 == 0) || (iVar8 = c_strcasecmp((char *)puVar7,"off"), iVar8 == 0)) {
          pfVar5->wrap = FORM_WRAP_NONE;
        }
      }
    }
    mem_free(puVar7);
  }
  iVar9 = get_num(attr,(uchar *)"maxlength",html_context->doc_cp);
  iVar8 = 0x7fffffff;
  if (iVar9 != -1) {
    iVar8 = iVar9;
  }
  pfVar5->maxlength = iVar8;
  if (iVar4 < 2) {
    put_chrs(html_context," ",1);
    html_stack_dup(html_context,ELEMENT_KILLABLE);
    *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar5;
    puVar2 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar2 = *puVar2 | 1;
    if (0 < iVar4) goto LAB_0809697a;
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  }
  else {
    ln_break(html_context,1);
    html_stack_dup(html_context,ELEMENT_KILLABLE);
    *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar5;
    puVar2 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar2 = *puVar2 | 1;
LAB_0809697a:
    local_30 = 0;
    do {
      iVar8 = 0;
      if (0 < iVar11) {
        do {
          iVar8 = iVar8 + 1;
          put_chrs(html_context,"_",1);
        } while (iVar8 < iVar11);
      }
      if (local_30 < iVar4 + -1) {
        ln_break(html_context,1);
      }
      local_30 = local_30 + 1;
    } while (local_30 < iVar4);
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
    if (1 < iVar4) {
      ln_break(html_context,1);
      goto LAB_080969f6;
    }
  }
  put_chrs(html_context," ",1);
LAB_080969f6:
  (*html_context->special_f)(html_context,2,pfVar5);
  return;
}



// WARNING: Unknown calling convention

void html_option(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  ushort uVar2;
  uchar *puVar3;
  uchar *val;
  form_control *pfVar4;
  form_control *fc;
  uchar *puVar5;
  uchar *puVar6;
  string *psVar7;
  int iVar8;
  ushort **ppuVar9;
  byte character;
  form_mode fVar10;
  byte *pbVar11;
  uchar *r;
  byte *html;
  string str;
  size_t local_28;
  uchar *local_24;
  byte *local_20 [4];
  
  if (*(int *)((int)(html_context->stack).next + 0x48) != 0) {
    puVar3 = get_attr_value(a,(uchar *)"value",html_context->doc_cp,HTML_ATTR_NONE);
    if (puVar3 == (uchar *)0x0) {
      local_20[0] = a + -1;
      if (a[-1] != '<') {
        pbVar11 = a + -2;
        do {
          local_20[0] = pbVar11;
          pbVar11 = local_20[0] + -1;
        } while (*local_20[0] != 0x3c);
      }
      psVar7 = init_string(&str);
      if (psVar7 != (string *)0x0) {
        iVar8 = parse_element(local_20[0],html_context->eoff,(uchar **)0x0,(int *)0x0,(uchar **)0x0,
                              local_20);
        if (iVar8 == 0) {
          pbVar11 = html_context->eoff;
          html = local_20[0];
joined_r0x08096dce:
          while ((local_20[0] = html, html < pbVar11 &&
                 (ppuVar9 = __ctype_b_loc(),
                 (*(byte *)((int)*ppuVar9 + (uint)*html * 2 + 1) & 0x20) != 0))) {
            html = html + 1;
          }
          do {
            puVar3 = str.source;
            if (pbVar11 <= html) goto end_parse;
            ppuVar9 = __ctype_b_loc();
            puVar3 = str.source;
            character = *html;
            uVar2 = (*ppuVar9)[character];
            if (((uVar2 & 0x2000) != 0) || (character == 0x3c)) {
              while ((uVar2 & 0x2000) != 0) {
                html = html + 1;
                if (pbVar11 <= html) goto end_parse;
                uVar2 = (*ppuVar9)[*html];
              }
              if (pbVar11 <= html) goto end_parse;
              if ((html + -2 <= pbVar11) && ((html[1] == 0x3f || (html[1] == 0x21)))) {
                html = skip_comment(html,pbVar11);
                pbVar11 = html_context->eoff;
                goto joined_r0x08096dce;
              }
              iVar8 = parse_element(html,pbVar11,&local_24,(int *)&local_28,(uchar **)0x0,local_20);
              if (iVar8 == 0) goto LAB_08096eca;
              character = *local_20[0];
            }
            if (character == 0) {
              character = 0x20;
            }
            add_char_to_string(&str,character);
            html = local_20[0] + 1;
            pbVar11 = html_context->eoff;
            local_20[0] = html;
          } while( true );
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 0x235;
        elinks_internal((uchar *)"parse element failed");
        puVar3 = str.source;
      }
    }
end_parse:
    pfVar4 = init_form_control(FC_CHECKBOX,a,html_context);
    if (pfVar4 == (form_control *)0x0) {
      if (puVar3 != (uchar *)0x0) {
        mem_free(puVar3);
        return;
      }
    }
    else {
      puVar5 = get_attr_value(a,"id",html_context->doc_cp,HTML_ATTR_NONE);
      pfVar4->id = puVar5;
      puVar5 = *(uchar **)((int)(html_context->stack).next + 0x48);
      puVar6 = (uchar *)0x0;
      if (puVar5 != (uchar *)0x0) {
        puVar6 = stracpy(puVar5);
      }
      pfVar4->name = puVar6;
      pfVar4->default_value = puVar3;
      puVar3 = get_attr_value(a,"selected",html_context->doc_cp,HTML_ATTR_TEST);
      pfVar4->default_state = (uint)(puVar3 != (uchar *)0x0);
      puVar3 = get_attr_value(a,(uchar *)"disabled",html_context->doc_cp,HTML_ATTR_TEST);
      fVar10 = FORM_MODE_DISABLED;
      if (puVar3 == (uchar *)0x0) {
        fVar10 = *(form_mode *)((int)(html_context->stack).next + 0x4c);
      }
      pfVar4->mode = fVar10;
      put_chrs(html_context," ",1);
      html_stack_dup(html_context,ELEMENT_KILLABLE);
      *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar4;
      puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
      *puVar1 = *puVar1 | 1;
      put_chrs(html_context,"[ ]",3);
      kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
      put_chrs(html_context," ",1);
      (*html_context->special_f)(html_context,2,pfVar4);
    }
  }
  return;
LAB_08096eca:
  if (5 < (int)local_28) {
    if (*local_24 == '/') {
      local_24 = local_24 + 1;
      local_28 = local_28 - 1;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x250;
    iVar8 = elinks_strlcasecmp(local_24,local_28,(uchar *)"OPTION",6,1);
    if (iVar8 == 0) goto end_parse;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x251;
    iVar8 = elinks_strlcasecmp(local_24,local_28,"SELECT",6,1);
    if (iVar8 == 0) goto end_parse;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x252;
    iVar8 = elinks_strlcasecmp(local_24,local_28,(uchar *)"OPTGROUP",8,1);
    if (iVar8 == 0) goto end_parse;
  }
  pbVar11 = html_context->eoff;
  html = local_20[0];
  goto joined_r0x08096dce;
}



// WARNING: Unknown calling convention

void html_button(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  int cp_00;
  uchar *puVar2;
  form_type fVar3;
  form_type type;
  int iVar4;
  form_control *pfVar5;
  uchar *al;
  int cp;
  
  cp_00 = html_context->doc_cp;
  html_focusable(html_context,a);
  puVar2 = get_attr_value(a,"type",cp_00,HTML_ATTR_NONE);
  fVar3 = FC_SUBMIT;
  if (puVar2 != (uchar *)0x0) {
    iVar4 = c_strcasecmp((char *)puVar2,"button");
    fVar3 = FC_BUTTON;
    if (iVar4 != 0) {
      iVar4 = c_strcasecmp((char *)puVar2,"reset");
      fVar3 = FC_RESET;
      if (iVar4 != 0) {
        iVar4 = c_strcasecmp((char *)puVar2,"submit");
        fVar3 = FC_SUBMIT;
        if (iVar4 != 0) {
          mem_free(puVar2);
          return;
        }
      }
    }
    mem_free(puVar2);
  }
  pfVar5 = init_form_control(fVar3,a,html_context);
  if (pfVar5 == (form_control *)0x0) {
    return;
  }
  puVar2 = get_attr_value(a,"id",cp_00,HTML_ATTR_NONE);
  pfVar5->id = puVar2;
  puVar2 = get_attr_value(a,"name",cp_00,HTML_ATTR_NONE);
  pfVar5->name = puVar2;
  puVar2 = get_attr_value(a,(uchar *)"value",cp_00,HTML_ATTR_NONE);
  pfVar5->default_value = puVar2;
  if (puVar2 != (uchar *)0x0) goto LAB_0809710a;
  fVar3 = pfVar5->type;
  if (fVar3 == FC_SUBMIT) {
    puVar2 = stracpy((uchar *)"Submit");
    pfVar5->default_value = puVar2;
LAB_080971d2:
    if (puVar2 != (uchar *)0x0) goto LAB_0809710a;
  }
  else {
    if (fVar3 == FC_RESET) {
      puVar2 = stracpy((uchar *)"Reset");
      pfVar5->default_value = puVar2;
      goto LAB_080971d2;
    }
    if (fVar3 == FC_BUTTON) {
      puVar2 = stracpy((uchar *)"Button");
      pfVar5->default_value = puVar2;
      goto LAB_080971d2;
    }
  }
  puVar2 = stracpy("");
  pfVar5->default_value = puVar2;
LAB_0809710a:
  (*html_context->special_f)(html_context,2,pfVar5);
  *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar5;
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  return;
}



// WARNING: Unknown calling convention

void html_input(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  form_control *pfVar2;
  uchar *puVar3;
  uchar *al;
  int iVar4;
  int iVar5;
  form_type fVar6;
  size_t len;
  void *pvVar7;
  uchar *puVar8;
  int i;
  int iVar9;
  int cp;
  uchar *al_1;
  html_attr_flags flags;
  
  iVar9 = html_context->doc_cp;
  pfVar2 = init_form_control(FC_TEXT,a,html_context);
  if (pfVar2 == (form_control *)0x0) {
    return;
  }
  puVar3 = get_attr_value(a,"type",iVar9,HTML_ATTR_NONE);
  if (puVar3 != (uchar *)0x0) {
    iVar4 = c_strcasecmp((char *)puVar3,"text");
    if (iVar4 == 0) {
      pfVar2->type = FC_TEXT;
    }
    else {
      iVar4 = c_strcasecmp((char *)puVar3,"hidden");
      if (iVar4 == 0) {
        pfVar2->type = FC_HIDDEN;
      }
      else {
        iVar4 = c_strcasecmp((char *)puVar3,"button");
        if (iVar4 == 0) {
          pfVar2->type = FC_BUTTON;
        }
        else {
          iVar4 = c_strcasecmp((char *)puVar3,"checkbox");
          if (iVar4 == 0) {
            pfVar2->type = FC_CHECKBOX;
          }
          else {
            iVar4 = c_strcasecmp((char *)puVar3,"radio");
            if (iVar4 == 0) {
              pfVar2->type = FC_RADIO;
            }
            else {
              iVar4 = c_strcasecmp((char *)puVar3,"password");
              if (iVar4 == 0) {
                pfVar2->type = FC_PASSWORD;
              }
              else {
                iVar4 = c_strcasecmp((char *)puVar3,"submit");
                if (iVar4 == 0) {
                  pfVar2->type = FC_SUBMIT;
                }
                else {
                  iVar4 = c_strcasecmp((char *)puVar3,"reset");
                  if (iVar4 == 0) {
                    pfVar2->type = FC_RESET;
                  }
                  else {
                    iVar4 = c_strcasecmp((char *)puVar3,"file");
                    if (iVar4 == 0) {
                      pfVar2->type = FC_FILE;
                    }
                    else {
                      iVar4 = c_strcasecmp((char *)puVar3,"image");
                      if (iVar4 == 0) {
                        pfVar2->type = FC_IMAGE;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mem_free(puVar3);
  }
  if (pfVar2->type == FC_HIDDEN) {
    flags = HTML_ATTR_LITERAL_NL;
LAB_080972a8:
    puVar3 = get_attr_value(a,(uchar *)"value",iVar9,flags);
    pfVar2->default_value = puVar3;
  }
  else {
    if (pfVar2->type != FC_FILE) {
      flags = HTML_ATTR_NONE;
      goto LAB_080972a8;
    }
    puVar3 = pfVar2->default_value;
  }
  if (puVar3 == (uchar *)0x0) {
    fVar6 = pfVar2->type;
    if (fVar6 == FC_CHECKBOX) {
      puVar3 = stracpy("on");
      pfVar2->default_value = puVar3;
LAB_0809778a:
      if (puVar3 != (uchar *)0x0) goto LAB_080972ca;
    }
    else {
      if (fVar6 == FC_SUBMIT) {
        puVar3 = stracpy((uchar *)"Submit");
        pfVar2->default_value = puVar3;
        goto LAB_0809778a;
      }
      if (fVar6 == FC_RESET) {
        puVar3 = stracpy((uchar *)"Reset");
        pfVar2->default_value = puVar3;
        goto LAB_0809778a;
      }
      if (fVar6 == FC_BUTTON) {
        puVar3 = stracpy((uchar *)"Button");
        pfVar2->default_value = puVar3;
        goto LAB_0809778a;
      }
    }
    puVar3 = stracpy("");
    pfVar2->default_value = puVar3;
  }
LAB_080972ca:
  puVar3 = get_attr_value(a,"id",iVar9,HTML_ATTR_NONE);
  pfVar2->id = puVar3;
  puVar3 = get_attr_value(a,"name",iVar9,HTML_ATTR_NONE);
  pfVar2->name = puVar3;
  iVar4 = get_num(a,"size",iVar9);
  pfVar2->size = iVar4;
  if (iVar4 == -1) {
    iVar4 = html_context->options->default_form_input_size;
    pfVar2->size = iVar4;
  }
  pfVar2->size = iVar4 + 1;
  iVar5 = (html_context->options->box).width;
  if (iVar5 < iVar4 + 1) {
    pfVar2->size = iVar5;
  }
  iVar5 = get_num(a,(uchar *)"maxlength",iVar9);
  iVar4 = 0x7fffffff;
  if (iVar5 != -1) {
    iVar4 = iVar5;
  }
  pfVar2->maxlength = iVar4;
  fVar6 = pfVar2->type;
  if (fVar6 + ~FC_TEXTAREA < 2) {
    puVar3 = get_attr_value(a,(uchar *)"checked",iVar9,HTML_ATTR_TEST);
    pfVar2->default_state = (uint)(puVar3 != (uchar *)0x0);
    fVar6 = pfVar2->type;
  }
  if (fVar6 == FC_IMAGE) {
    puVar3 = get_attr_value(a,"alt",iVar9,HTML_ATTR_NONE);
    pfVar2->alt = puVar3;
    fVar6 = pfVar2->type;
  }
  if (fVar6 == FC_HIDDEN) goto LAB_080974f0;
  put_chrs(html_context," ",1);
  html_stack_dup(html_context,ELEMENT_KILLABLE);
  html_focusable(html_context,a);
  *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar2;
  pvVar7 = (html_context->stack).next;
  if (*(void **)((int)pvVar7 + 0x28) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar7 + 0x28));
    pvVar7 = (html_context->stack).next;
  }
  puVar3 = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
  *(uchar **)((int)pvVar7 + 0x28) = puVar3;
  if (FC_HIDDEN < pfVar2->type) goto LAB_080974c9;
  switch(pfVar2->type) {
  default:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    if (0 < pfVar2->size) {
      iVar9 = 0;
      do {
        iVar9 = iVar9 + 1;
        put_chrs(html_context,"_",1);
      } while (iVar9 < pfVar2->size);
    }
    break;
  case FC_TEXTAREA:
  case FC_SELECT:
  case FC_HIDDEN:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 0x101;
    elinks_internal((uchar *)"bad control type");
    break;
  case FC_CHECKBOX:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,"[&nbsp;]",8);
    break;
  case FC_RADIO:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,(uchar *)"(&nbsp;)",8);
    break;
  case FC_SUBMIT:
  case FC_RESET:
  case FC_BUTTON:
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,(uchar *)"[&nbsp;",7);
    puVar3 = pfVar2->default_value;
    if (puVar3 != (uchar *)0x0) {
LAB_08097499:
      len = strlen((char *)puVar3);
      put_chrs(html_context,puVar3,len);
    }
    goto LAB_080974b1;
  case FC_IMAGE:
    pvVar7 = (html_context->stack).next;
    if (*(void **)((int)pvVar7 + 0x24) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar7 + 0x24));
      pvVar7 = (html_context->stack).next;
    }
    *(undefined4 *)((int)pvVar7 + 0x24) = 0;
    puVar3 = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL);
    if ((puVar3 != (uchar *)0x0) ||
       (puVar3 = get_attr_value(a,"dynsrc",html_context->doc_cp,HTML_ATTR_EAT_NL),
       puVar3 != (uchar *)0x0)) {
      pvVar7 = (html_context->stack).next;
      puVar8 = join_urls(html_context->base_href,puVar3);
      *(uchar **)((int)pvVar7 + 0x24) = puVar8;
      mem_free(puVar3);
    }
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    put_chrs(html_context,(uchar *)"[&nbsp;",7);
    puVar3 = pfVar2->alt;
    if ((puVar3 != (uchar *)0x0) || (puVar3 = pfVar2->name, puVar3 != (uchar *)0x0))
    goto LAB_08097499;
    put_chrs(html_context,(uchar *)"Submit",6);
LAB_080974b1:
    put_chrs(html_context,(uchar *)"&nbsp;]",7);
  }
LAB_080974c9:
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  put_chrs(html_context," ",1);
LAB_080974f0:
                    // WARNING: Could not recover jumptable at 0x0809750a. Too many branches
                    // WARNING: Treating indirect jump as call
  (*html_context->special_f)(html_context,2);
  return;
}



// WARNING: Unknown calling convention

void html_form(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *puVar1;
  uchar uVar2;
  form *pfVar3;
  form *form;
  uchar *puVar4;
  uchar *al;
  int iVar5;
  uchar *enctype;
  uri_component components;
  char *pcVar6;
  size_t sVar7;
  int l;
  uchar *puVar8;
  uchar *puVar9;
  
  html_context->field_0x44 = html_context->field_0x44 | 1;
  pfVar3 = init_form();
  if (pfVar3 == (form *)0x0) {
    return;
  }
  pfVar3->method = FORM_METHOD_GET;
  pfVar3->form_num = (int)a - (int)html_context->startf;
  puVar4 = get_attr_value(a,(uchar *)"method",html_context->doc_cp,HTML_ATTR_NONE);
  if (puVar4 != (uchar *)0x0) {
    iVar5 = c_strcasecmp((char *)puVar4,"post");
    if (iVar5 == 0) {
      puVar8 = get_attr_value(a,(uchar *)"enctype",html_context->doc_cp,HTML_ATTR_NONE);
      pfVar3->method = FORM_METHOD_POST;
      if (puVar8 != (uchar *)0x0) {
        iVar5 = c_strcasecmp((char *)puVar8,"multipart/form-data");
        if (iVar5 == 0) {
          pfVar3->method = FORM_METHOD_POST_MP;
        }
        else {
          iVar5 = c_strcasecmp((char *)puVar8,"text/plain");
          if (iVar5 == 0) {
            pfVar3->method = FORM_METHOD_POST_TEXT_PLAIN;
          }
        }
        mem_free(puVar8);
      }
    }
    mem_free(puVar4);
  }
  puVar4 = get_attr_value(a,(uchar *)"onsubmit",html_context->doc_cp,HTML_ATTR_NONE);
  pfVar3->onsubmit = puVar4;
  puVar4 = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
  if (puVar4 != (uchar *)0x0) {
    pfVar3->name = puVar4;
  }
  puVar4 = get_attr_value(a,"action",html_context->doc_cp,HTML_ATTR_NONE);
  if (puVar4 != (uchar *)0x0) {
    uVar2 = *puVar4;
    if (uVar2 != '\0') {
      sVar7 = strlen((char *)puVar4);
      puVar8 = puVar4;
      while (uVar2 == ' ') {
        puVar8 = puVar8 + 1;
        sVar7 = sVar7 - 1;
        uVar2 = *puVar8;
      }
      if (sVar7 == 0) {
LAB_08097bb3:
        sVar7 = 1;
      }
      else {
        puVar9 = puVar8 + sVar7;
        uVar2 = puVar8[sVar7 - 1];
        while (uVar2 == ' ') {
          sVar7 = sVar7 - 1;
          puVar9[-1] = '\0';
          if (sVar7 == 0) goto LAB_08097bb3;
          puVar1 = puVar9 + -2;
          puVar9 = puVar9 + -1;
          uVar2 = *puVar1;
        }
        sVar7 = sVar7 + 1;
      }
      memmove(puVar4,puVar8,sVar7);
      puVar8 = join_urls(html_context->base_href,puVar4);
      pfVar3->action = puVar8;
      mem_free(puVar4);
      goto LAB_08097b28;
    }
    mem_free(puVar4);
  }
  components = -(uint)(pfVar3->method == FORM_METHOD_GET) & 0xe80;
  puVar4 = get_uri_string(html_context->base_href,components + URI_ORIGINAL);
  pfVar3->action = puVar4;
  if (assert_failed == 0) {
    if ((puVar4 == (uchar *)0x0) || (pcVar6 = strchr((char *)puVar4,1), pcVar6 == (char *)0x0)) {
      assert_failed = 0;
    }
    else {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 99;
      elinks_internal((uchar *)"assertion !form->action || !strchr(form->action, POST_CHAR) failed!"
                     );
      if (assert_failed != 0) goto LAB_08097b28;
    }
    if (((pfVar3->action == (uchar *)0x0) || (pfVar3->method != FORM_METHOD_GET)) ||
       (pcVar6 = strchr((char *)pfVar3->action,0x3f), pcVar6 == (char *)0x0)) {
      assert_failed = 0;
    }
    else {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 0x68;
      elinks_internal((uchar *)
                      "assertion !form->action || form->method != FORM_METHOD_GET || !strchr(form->action, \'?\') failed!"
                     );
    }
  }
LAB_08097b28:
  puVar4 = get_target(html_context->options,a);
  if (puVar4 == (uchar *)0x0) {
    puVar4 = stracpy(html_context->base_target);
  }
  pfVar3->target = puVar4;
                    // WARNING: Could not recover jumptable at 0x08097b5c. Too many branches
                    // WARNING: Treating indirect jump as call
  (*html_context->special_f)(html_context,1);
  return;
}



// WARNING: Unknown calling convention

void html_select(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint *puVar1;
  size_t size;
  uchar uVar2;
  byte bVar3;
  bool bVar4;
  bool bVar5;
  uchar *puVar6;
  uchar *al;
  conv_table *convert_table;
  uchar *label_1;
  void *p;
  ushort **ppuVar7;
  int iVar8;
  uint uVar9;
  size_t newsize_1;
  uchar *name;
  uchar **ppuVar10;
  form_control *pfVar11;
  menu_item *items;
  int iVar12;
  byte *pbVar13;
  size_t newsize;
  uint size_00;
  byte bVar14;
  void *pvVar15;
  size_t oldsize;
  uint uVar16;
  int max_width;
  uchar *label;
  byte *html_00;
  int j;
  form_control *fc;
  int preselect;
  int closing_tag;
  int l;
  size_t sVar17;
  int iVar18;
  int i;
  byte *chars;
  byte bVar19;
  size_t local_64;
  uint local_60;
  size_t local_5c;
  string orig_lbl;
  string lbl;
  size_t local_30;
  byte *local_2c;
  uchar *local_28;
  uchar *local_24;
  uchar **local_20;
  
  bVar19 = 0;
  puVar6 = get_attr_value(a,(uchar *)"multiple",html_context->doc_cp,HTML_ATTR_TEST);
  if (puVar6 != (uchar *)0x0) {
    puVar6 = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
    if (puVar6 != (uchar *)0x0) {
      html_focusable(html_context,a);
      *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
      pvVar15 = (html_context->stack).next;
      if (*(void **)((int)pvVar15 + 0x48) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar15 + 0x48));
        pvVar15 = (html_context->stack).next;
      }
      *(uchar **)((int)pvVar15 + 0x48) = puVar6;
      pvVar15 = (html_context->stack).next;
      puVar6 = get_attr_value(a,(uchar *)"disabled",html_context->doc_cp,HTML_ATTR_TEST);
      *(uint *)((int)pvVar15 + 0x4c) = ~-(uint)(puVar6 == (uchar *)0x0) & 2;
    }
    return;
  }
  convert_table = (conv_table *)(*html_context->special_f)(html_context,3,0);
  lbl.source = (uchar *)0x0;
  lbl.length = 0;
  orig_lbl.source = (uchar *)0x0;
  orig_lbl.length = 0;
  local_20 = (uchar **)0x0;
  html_focusable(html_context,a);
  init_menu(&lnk_menu);
  bVar5 = false;
  local_64 = 0xffffffff;
  local_5c = 0;
  local_60 = 0;
  local_2c = html;
LAB_08097e20:
  do {
    chars = local_2c;
    html_00 = local_2c;
    if (eof <= local_2c) {
abort:
      *end = html_00;
      if (lbl.source != (uchar *)0x0) {
        done_string(&lbl);
      }
      if (orig_lbl.source != (uchar *)0x0) {
        done_string(&orig_lbl);
      }
      if (local_20 != (uchar **)0x0) {
        ppuVar10 = local_20;
        if (local_5c != 0) {
          j = 0;
          do {
            if (ppuVar10[j] != (uchar *)0x0) {
              mem_free(ppuVar10[j]);
              ppuVar10 = local_20;
            }
            j = j + 1;
          } while (j < (int)local_5c);
        }
        mem_free(ppuVar10);
      }
      destroy_menu(&lnk_menu);
      *end = local_2c;
      return;
    }
    bVar14 = *local_2c;
    bVar3 = bVar14;
    while (bVar3 != 0x3c) {
      html_00 = html_00 + 1;
      if (eof <= html_00) goto abort;
      bVar3 = *html_00;
    }
    if (lbl.source != (uchar *)0x0) {
      l = (int)html_00 - (int)local_2c;
      if (l == 0) {
LAB_08098030:
        l = 0;
      }
      else {
        ppuVar7 = __ctype_b_loc();
        while ((*(byte *)((int)*ppuVar7 + (uint)bVar14 * 2 + 1) & 0x20) != 0) {
          chars = chars + 1;
          l = l - 1;
          if (l == 0) goto LAB_08098030;
          bVar14 = *chars;
        }
        if (l != 0) {
          pbVar13 = chars + l;
          do {
            if ((*(byte *)((int)*ppuVar7 + (uint)pbVar13[-1] * 2 + 1) & 0x20) == 0) break;
            pbVar13 = pbVar13 + -1;
            l = l - 1;
          } while (l != 0);
        }
      }
      puVar6 = convert_string_elinks
                         (convert_table,chars,l,html_context->options->cp,CSM_DEFAULT,(int *)0x0,
                          (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (puVar6 != (uchar *)0x0) {
        add_to_string(&lbl,puVar6);
        mem_free(puVar6);
      }
      if (assert_failed == 0) {
        if ((chars == (byte *)0x0) || (l < 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_08098078;
        }
        else {
          assert_failed = 0;
        }
        if (l != 0) {
          iVar8 = l + orig_lbl.length;
          uVar16 = orig_lbl.length + 0xffU >> 8;
          uVar9 = orig_lbl.length + 0xffU & 0xffffff00;
          size_00 = iVar8 + 0x100U & 0xffffff00;
          if (uVar9 <= size_00 && size_00 + uVar16 * -0x100 != 0) {
            puVar6 = (uchar *)mem_realloc(orig_lbl.source,size_00);
            if (puVar6 == (uchar *)0x0) goto LAB_08097fca;
            orig_lbl.source = puVar6;
            memset(puVar6 + uVar9,0,size_00 + uVar16 * -0x100);
          }
          if (orig_lbl.source != (uchar *)0x0) {
            memcpy(orig_lbl.source + orig_lbl.length,chars,l);
            orig_lbl.source[iVar8] = '\0';
            orig_lbl.length = iVar8;
          }
        }
      }
      else {
LAB_08098078:
        assert_failed = 0;
      }
    }
LAB_08097fca:
    if ((eof < html_00 + 2) || ((html_00[1] != 0x3f && (html_00[1] != 0x21)))) {
      iVar8 = parse_element(html_00,eof,&local_24,(int *)&local_30,&local_28,&local_2c);
      if (iVar8 != 0) {
        local_2c = html_00 + 1;
        goto LAB_08097e20;
      }
      if (local_30 != 0) {
        bVar4 = false;
        if (*local_24 == '/') {
          local_30 = local_30 - 1;
          if (local_30 == 0) goto LAB_08097e20;
          local_24 = local_24 + 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
          errline = 0x19d;
          iVar8 = elinks_strlcasecmp(local_24,local_30,"SELECT",6,1);
          if (iVar8 == 0) {
            add_select_item(&lnk_menu,&lbl,&orig_lbl,local_20,local_5c,local_60);
            *end = local_2c;
            if ((local_5c != 0) &&
               (ppuVar10 = (uchar **)mem_calloc(local_5c,4), ppuVar10 != (uchar **)0x0)) {
              pfVar11 = init_form_control(FC_SELECT,a,html_context);
              if (pfVar11 != (form_control *)0x0) {
                puVar6 = get_attr_value(a,"id",html_context->doc_cp,HTML_ATTR_NONE);
                pfVar11->id = puVar6;
                puVar6 = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
                pfVar11->name = puVar6;
                sVar17 = 0;
                if (-1 < (int)local_64) {
                  sVar17 = local_64;
                }
                pfVar11->default_state = sVar17;
                puVar6 = stracpy(local_20[sVar17]);
                pfVar11->default_value = puVar6;
                pfVar11->nvalues = local_5c;
                pfVar11->values = local_20;
                items = detach_menu(&lnk_menu);
                pfVar11->menu = items;
                pfVar11->labels = ppuVar10;
                menu_labels(items,"",ppuVar10);
                put_chrs(html_context,"[",1);
                html_stack_dup(html_context,ELEMENT_KILLABLE);
                *(form_control **)((int)(html_context->stack).next + 0x2c) = pfVar11;
                puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
                *puVar1 = *puVar1 | 1;
                iVar18 = 0;
                iVar8 = 0;
                break;
              }
              mem_free(ppuVar10);
            }
            goto abort;
          }
          bVar4 = true;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 0x1a2;
        iVar8 = elinks_strlcasecmp(local_24,local_30,(uchar *)"OPTION",6,1);
        if (iVar8 == 0) {
          add_select_item(&lnk_menu,&lbl,&orig_lbl,local_20,local_5c,local_60);
          if ((!bVar4) &&
             (puVar6 = get_attr_value(local_28,(uchar *)"disabled",html_context->doc_cp,
                                      HTML_ATTR_TEST), puVar6 == (uchar *)0x0)) {
            sVar17 = local_64;
            if ((local_64 == 0xffffffff) &&
               (puVar6 = get_attr_value(local_28,"selected",html_context->doc_cp,HTML_ATTR_TEST),
               sVar17 = local_5c, puVar6 == (uchar *)0x0)) {
              sVar17 = local_64;
            }
            local_64 = sVar17;
            puVar6 = get_attr_value(local_28,(uchar *)"value",html_context->doc_cp,HTML_ATTR_NONE);
            uVar16 = local_5c + 0xff;
            sVar17 = local_5c + 1;
            newsize_1 = local_5c + 0x100;
            if ((uVar16 & 0xffffff00) <= (newsize_1 & 0xffffff00) &&
                (newsize_1 & 0xffffff00) + (uVar16 >> 8) * -0x100 != 0) {
              size = (newsize_1 >> 8) * 0x400;
              ppuVar10 = (uchar **)mem_realloc(local_20,size);
              if (ppuVar10 == (uchar **)0x0) goto abort;
              local_20 = ppuVar10;
              memset(ppuVar10 + (uVar16 & 0xffffff00),0,size + (uVar16 >> 8) * -0x400);
            }
            if (local_20 == (uchar **)0x0) goto abort;
            local_20[local_5c] = puVar6;
            name = get_attr_value(local_28,"label",html_context->doc_cp,HTML_ATTR_NONE);
            if ((name == (uchar *)0x0) ||
               (new_menu_item(&lnk_menu,name,local_5c,0), local_5c = sVar17, puVar6 == (uchar *)0x0)
               ) {
              init_string(&lbl);
              init_string(&orig_lbl);
              local_60 = (uint)(name != (uchar *)0x0);
              local_5c = sVar17;
            }
          }
        }
        else {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
          errline = 0x1bf;
          iVar8 = elinks_strlcasecmp(local_24,local_30,(uchar *)"OPTGROUP",8,1);
          if (iVar8 == 0) {
            add_select_item(&lnk_menu,&lbl,&orig_lbl,local_20,local_5c,local_60);
            if (bVar5) {
              new_menu_item(&lnk_menu,(uchar *)0x0,-1,0);
            }
            if ((bVar4) ||
               ((puVar6 = get_attr_value(local_28,"label",html_context->doc_cp,HTML_ATTR_NONE),
                puVar6 == (uchar *)0x0 && (puVar6 = stracpy(""), puVar6 == (uchar *)0x0)))) {
              bVar5 = false;
            }
            else {
              new_menu_item(&lnk_menu,puVar6,-1,0);
              bVar5 = true;
            }
          }
        }
      }
      goto LAB_08097e20;
    }
    local_2c = skip_comment(html_00,eof);
  } while( true );
LAB_08098648:
  if ((int)local_5c <= iVar18) {
    for (iVar18 = 0; iVar18 < iVar8; iVar18 = iVar18 + 1) {
      put_chrs(html_context,"_",1);
    }
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
    put_chrs(html_context,"]",1);
    (*html_context->special_f)(html_context,2,pfVar11);
    return;
  }
  puVar6 = ppuVar10[iVar18];
  if (puVar6 == (uchar *)0x0) {
LAB_0809868e:
    iVar12 = iVar8;
  }
  else {
    if ((html_context->options->field_0x5c & 0x10) == 0) {
      uVar16 = 0xffffffff;
      do {
        if (uVar16 == 0) break;
        uVar16 = uVar16 - 1;
        uVar2 = *puVar6;
        puVar6 = puVar6 + (uint)bVar19 * -2 + 1;
      } while (uVar2 != '\0');
      iVar12 = ~uVar16 - 1;
    }
    else {
      iVar12 = utf8_ptr2cells(puVar6,(uchar *)0x0);
    }
    if (iVar12 <= iVar8) goto LAB_0809868e;
  }
  iVar18 = iVar18 + 1;
  iVar8 = iVar12;
  goto LAB_08098648;
}



// WARNING: Unknown calling convention

void html_span(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



// WARNING: Unknown calling convention

void html_bold(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  return;
}



// WARNING: Unknown calling convention

void html_italic(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 2;
  return;
}



// WARNING: Unknown calling convention

void html_underline(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 4;
  return;
}



// WARNING: Unknown calling convention

void html_fixed(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 8;
  return;
}



// WARNING: Unknown calling convention

void html_style_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_context->field_0x44 = html_context->field_0x44 & 0xfb;
  return;
}



// WARNING: Unknown calling convention

void html_html(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  void *pvVar2;
  int iVar3;
  
  pvVar1 = (html_context->stack).next;
  pvVar2 = (html_context->stack).prev;
  iVar3 = *(int *)((int)pvVar1 + 0x14);
  if (*(int *)((int)pvVar1 + 0x94) != iVar3) {
    *(int *)((int)pvVar1 + 0x94) = iVar3;
    *(int *)((int)pvVar2 + 0x14) = iVar3;
    *(int *)((int)pvVar2 + 0x94) = iVar3;
  }
  return;
}



// WARNING: Unknown calling convention

void html_head(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



// WARNING: Unknown calling convention

void html_meta(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



// WARNING: Unknown calling convention

void html_title(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  *(undefined4 *)((int)(html_context->stack).next + 0x98) = 1;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 3;
  return;
}



// WARNING: Unknown calling convention

void html_center(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 1;
  if (html_context->table_level == 0) {
    pvVar1 = (html_context->stack).next;
    *(undefined4 *)((int)pvVar1 + 0x7c) = 0;
    *(undefined4 *)((int)pvVar1 + 0x78) = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void html_address(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x78);
  *piVar1 = *piVar1 + 1;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  return;
}



// WARNING: Unknown calling convention

void html_blockquote(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x78);
  *piVar1 = *piVar1 + 2;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  return;
}



// WARNING: Unknown calling convention

void html_pre(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  void *pvVar2;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 0x20;
  pvVar2 = (html_context->stack).next;
  *(uint *)((int)pvVar2 + 0x78) = (uint)(1 < *(int *)((int)pvVar2 + 0x78));
  *(undefined4 *)((int)(html_context->stack).next + 0x7c) = 0;
  return;
}



// WARNING: Unknown calling convention

void html_xmp(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint *puVar1;
  void *pvVar2;
  
  pvVar2 = (html_context->stack).next;
  html_context->field_0x44 = html_context->field_0x44 | 2;
  puVar1 = (uint *)((int)pvVar2 + 0xc);
  *puVar1 = *puVar1 | 0x20;
  pvVar2 = (html_context->stack).next;
  *(uint *)((int)pvVar2 + 0x78) = (uint)(1 < *(int *)((int)pvVar2 + 0x78));
  *(undefined4 *)((int)(html_context->stack).next + 0x7c) = 0;
  return;
}



// WARNING: Unknown calling convention

void html_xmp_close(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_context->field_0x44 = html_context->field_0x44 & 0xfd;
  return;
}



// WARNING: Unknown calling convention

void html_tt(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



// WARNING: Unknown calling convention

void html_noscript(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  return;
}



// WARNING: Unknown calling convention

void html_frameset(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int iVar1;
  document_options *pdVar2;
  html_element *phVar3;
  void *pvVar4;
  uchar *str;
  uchar *str_00;
  void *p;
  void *p_1;
  void *pvVar5;
  int offset;
  int width;
  int max_value;
  uchar *cols;
  uchar *rows;
  int local_40;
  frameset_param fp;
  
  phVar3 = search_html_stack(html_context,"BODY");
  if (phVar3 != (html_element *)0x0) {
    return;
  }
  if ((html_context->options->field_0x44 & 0x10) == 0) {
    return;
  }
  pvVar4 = (*html_context->special_f)(html_context,4,0);
  if (pvVar4 == (void *)0x0) {
    return;
  }
  str = get_attr_value(a,"cols",html_context->doc_cp,HTML_ATTR_NONE);
  if ((str == (uchar *)0x0) && (str = stracpy("100%"), str == (uchar *)0x0)) {
    return;
  }
  str_00 = get_attr_value(a,"rows",html_context->doc_cp,HTML_ATTR_NONE);
  if ((str_00 == (uchar *)0x0) && (str_00 = stracpy("100%"), str_00 == (uchar *)0x0)) {
    mem_free(str);
    return;
  }
  iVar1 = *(int *)((int)(html_context->stack).next + 0xac);
  if (iVar1 == 0) {
    pdVar2 = html_context->options;
    local_40 = (pdVar2->box).height;
    max_value = (pdVar2->box).width;
    pdVar2->field_0x5c = pdVar2->field_0x5c | 1;
  }
  else {
    if (*(int *)(iVar1 + 0x10) <= *(int *)(iVar1 + 8)) goto free_and_return;
    offset = *(int *)(iVar1 + 8) * *(int *)(iVar1 + 0xc) + *(int *)(iVar1 + 4);
    iVar1 = iVar1 + offset * 0x14;
    max_value = *(int *)(iVar1 + 0x20);
    local_40 = *(int *)(iVar1 + 0x24);
  }
  fp.height = (int *)0x0;
  fp.width = (int *)0x0;
  parse_frame_widths(str,max_value,10,&fp.width,&fp.x);
  parse_frame_widths(str_00,local_40,0x10,&fp.height,&fp.y);
  pvVar4 = (html_context->stack).next;
  fp.parent = *(frameset_desc **)((int)pvVar4 + 0xac);
  if ((fp.x != 0) && (fp.y != 0)) {
    pvVar5 = (*html_context->special_f)(html_context,5,&fp);
    *(void **)((int)pvVar4 + 0xac) = pvVar5;
  }
  if (fp.width != (int *)0x0) {
    mem_free(fp.width);
  }
  if (fp.height != (int *)0x0) {
    mem_free(fp.height);
  }
free_and_return:
  mem_free(str);
  mem_free(str_00);
  return;
}



// WARNING: Unknown calling convention

void html_frame(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *puVar1;
  uchar *src;
  uchar *src_00;
  uchar *name;
  void *pvVar2;
  uchar *url;
  
  puVar1 = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (puVar1 == (uchar *)0x0) {
    src_00 = stracpy((uchar *)"about:blank");
  }
  else {
    src_00 = join_urls(html_context->base_href,puVar1);
    mem_free(puVar1);
  }
  if (src_00 != (uchar *)0x0) {
    puVar1 = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
    if (puVar1 != (uchar *)0x0) {
      if (*puVar1 != '\0') goto LAB_08098b84;
      mem_free(puVar1);
    }
    puVar1 = stracpy(src_00);
    if (puVar1 != (uchar *)0x0) {
LAB_08098b84:
      if (((html_context->options->field_0x44 & 0x10) == 0) ||
         (*(int *)((int)(html_context->stack).next + 0xac) == 0)) {
        html_focusable(html_context,a);
        put_link_line("Frame: ",puVar1,src_00,"",html_context);
      }
      else {
        pvVar2 = (*html_context->special_f)(html_context,4,0);
        if (pvVar2 != (void *)0x0) {
          (*html_context->special_f)
                    (html_context,6,*(undefined4 *)((int)(html_context->stack).next + 0xac),puVar1,
                     src_00);
        }
      }
      mem_free(puVar1);
      mem_free(src_00);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void html_noframes(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_element *element;
  html_element *phVar1;
  
  if ((html_context->options->field_0x44 & 0x10) != 0) {
    phVar1 = search_html_stack(html_context,(uchar *)"frameset");
    if ((phVar1 == (html_element *)0x0) || (phVar1->frameset != (frameset_desc *)0x0)) {
      html_skip(html_context,a);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void html_style(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_context->field_0x44 = html_context->field_0x44 | 4;
  html_skip(html_context,a);
  return;
}



// WARNING: Unknown calling convention

void html_script(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_skip(html_context,a);
  return;
}



// WARNING: Unknown calling convention

void html_dd(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  void *pvVar2;
  int iVar3;
  
  kill_html_stack_until(html_context,0,&DAT_0812e3d8,&DAT_0812f308,0);
  pvVar2 = (html_context->stack).next;
  *(int *)((int)pvVar2 + 0x78) = *(int *)((int)pvVar2 + 0x8c) + 3;
  if (html_context->table_level == 0) {
    piVar1 = (int *)((int)(html_context->stack).next + 0x78);
    *piVar1 = *piVar1 + 5;
    pvVar2 = (html_context->stack).next;
    iVar3 = *(int *)((int)pvVar2 + 0x80) / 2;
    if (*(int *)((int)pvVar2 + 0x78) <= iVar3) goto LAB_08098d6d;
    *(int *)((int)pvVar2 + 0x78) = iVar3;
  }
  pvVar2 = (html_context->stack).next;
LAB_08098d6d:
  *(undefined4 *)((int)pvVar2 + 0x74) = 0;
  return;
}



// WARNING: Unknown calling convention

void html_dt(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  uchar *puVar2;
  
  kill_html_stack_until(html_context,0,&DAT_0812e3d8,&DAT_0812f308,0);
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  pvVar1 = (html_context->stack).next;
  *(undefined4 *)((int)pvVar1 + 0x78) = *(undefined4 *)((int)pvVar1 + 0x8c);
  if ((*(byte *)((int)(html_context->stack).next + 0x90) & 8) == 0) {
    puVar2 = get_attr_value(a,(uchar *)"compact",html_context->doc_cp,HTML_ATTR_TEST);
    if (puVar2 == (uchar *)0x0) {
      ln_break(html_context,2);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void html_dl(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  uchar *puVar2;
  void *pvVar3;
  int iVar4;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0x90);
  *puVar1 = *puVar1 & 0xfffffff7;
  puVar2 = get_attr_value(a,(uchar *)"compact",html_context->doc_cp,HTML_ATTR_TEST);
  if (puVar2 != (uchar *)0x0) {
    puVar1 = (uint *)((int)(html_context->stack).next + 0x90);
    *puVar1 = *puVar1 | 8;
  }
  pvVar3 = (html_context->stack).next;
  iVar4 = 0;
  if (*(int *)((int)pvVar3 + 0x84) != 0) {
    *(int *)((int)pvVar3 + 0x78) = *(int *)((int)pvVar3 + 0x78) + 5;
    pvVar3 = (html_context->stack).next;
    iVar4 = *(int *)((int)pvVar3 + 0x84);
  }
  *(int *)((int)pvVar3 + 0x84) = iVar4 + 1;
  *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  pvVar3 = (html_context->stack).next;
  *(undefined4 *)((int)pvVar3 + 0x8c) = *(undefined4 *)((int)pvVar3 + 0x78);
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  if ((*(byte *)((int)(html_context->stack).next + 0x90) & 8) == 0) {
    ln_break(html_context,2);
    *(undefined4 *)((int)(html_context->stack).next + 0xa8) = 2;
  }
  return;
}



// WARNING: Unknown calling convention

void html_td(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  kill_html_stack_until(html_context,1,&DAT_0812c5c4,&DAT_0812cf4a,&DAT_0812e3d8,"TR","TABLE",0);
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 & 0xfffffffe;
  put_chrs(html_context," ",1);
  return;
}



// WARNING: Unknown calling convention

void html_th(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint *puVar1;
  
  kill_html_stack_until(html_context,1,&DAT_0812c5c4,&DAT_0812cf4a,&DAT_0812e3d8,"TR","TABLE",0);
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  put_chrs(html_context," ",1);
  return;
}



// WARNING: Unknown calling convention

void html_quote_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uint uVar1;
  
  uVar1 = 0;
  if (html_context->quote_level != 0) {
    uVar1 = html_context->quote_level - 1;
    html_context->quote_level = uVar1;
  }
  put_chrs(html_context,quote_char[uVar1 & 1],1);
  return;
}



// WARNING: Unknown calling convention

void html_quote(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *start;
  uchar *q;
  
  start = quote_char[html_context->quote_level & 1];
  html_context->quote_level = html_context->quote_level + 1;
  put_chrs(html_context,start,1);
  return;
}



// WARNING: Unknown calling convention

void html_superscript(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  put_chrs(html_context,"^",1);
  return;
}



// WARNING: Unknown calling convention

void html_subscript_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  put_chrs(html_context,"]",1);
  return;
}



// WARNING: Unknown calling convention

void html_subscript(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  put_chrs(html_context,"[",1);
  return;
}



// WARNING: Unknown calling convention

void html_ol(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  uchar uVar2;
  int iVar3;
  int st;
  uchar *p;
  uchar *al;
  void *pvVar4;
  int iVar5;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x84);
  *piVar1 = *piVar1 + 1;
  iVar3 = get_num(a,"start",html_context->doc_cp);
  iVar5 = 1;
  if (iVar3 != -1) {
    iVar5 = iVar3;
  }
  *(int *)((int)(html_context->stack).next + 0x88) = iVar5;
  *(undefined4 *)((int)(html_context->stack).next + 0x90) = 1;
  p = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    uVar2 = *p;
    if ((uVar2 != '\0') && (p[1] == '\0')) {
      if (uVar2 == '1') {
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 1;
      }
      else if (uVar2 == 'a') {
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 2;
      }
      else if (uVar2 == 'A') {
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 3;
      }
      else if (uVar2 == 'r') {
LAB_08099210:
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 4;
      }
      else {
        if (uVar2 != 'R') {
          if (uVar2 == 'i') goto LAB_08099210;
          if (uVar2 != 'I') goto LAB_0809913a;
        }
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 5;
      }
    }
LAB_0809913a:
    mem_free(p);
  }
  pvVar4 = (html_context->stack).next;
  piVar1 = (int *)((int)pvVar4 + 0x78);
  *piVar1 = *piVar1 + (uint)(1 < *(int *)((int)pvVar4 + 0x84));
  if (html_context->table_level == 0) {
    pvVar4 = (html_context->stack).next;
    iVar5 = *(int *)((int)pvVar4 + 0x80) / 2;
    if (*(int *)((int)pvVar4 + 0x78) <= iVar5) goto LAB_08099179;
    *(int *)((int)pvVar4 + 0x78) = iVar5;
  }
  pvVar4 = (html_context->stack).next;
LAB_08099179:
  *(undefined4 *)((int)pvVar4 + 0x74) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  return;
}



// WARNING: Unknown calling convention

void html_li(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  void *pvVar2;
  uchar *puVar3;
  uint uVar4;
  int t;
  uint uVar5;
  int iVar6;
  int s;
  uint uVar7;
  uint uVar8;
  html_element *phVar9;
  html_element *element;
  char cVar10;
  byte bVar11;
  uchar c;
  uchar *x_1;
  uint *puVar12;
  uint *puVar13;
  byte *pbVar14;
  int in_GS_OFFSET;
  bool bVar15;
  int local_5c;
  uchar x [7];
  uchar n [32];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (html_context->was_li != 0) {
    html_context->line_breax = 0;
    ln_break(html_context,1);
  }
  pvVar2 = (html_context->stack).next;
  if (*(int *)((int)pvVar2 + 0x88) == 0) {
    x[0] = '*';
    x[1] = '&';
    x[2] = 'n';
    x[3] = 'b';
    x[4] = 's';
    x[5] = 'p';
    x[6] = ';';
    t = *(uint *)((int)pvVar2 + 0x90) & 7;
    if (t == 2) {
      x[0] = 'o';
      x[1] = '&';
      x[2] = 'n';
      x[3] = 'b';
    }
    else if (t == 3) {
      x[0] = '+';
      x[1] = '&';
      x[2] = 'n';
      x[3] = 'b';
    }
    put_chrs(html_context,x,7);
    piVar1 = (int *)((int)(html_context->stack).next + 0x78);
    *piVar1 = *piVar1 + 2;
    *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  }
  else {
    uVar5 = *(uint *)((int)pvVar2 + 0x90) & 7;
    iVar6 = get_num(a,(uchar *)"value",html_context->doc_cp);
    if (iVar6 != -1) {
      *(int *)((int)(html_context->stack).next + 0x88) = iVar6;
    }
    if (uVar5 - 2 < 2) {
      put_chrs(html_context,(uchar *)"&nbsp;",6);
      bVar11 = 0;
      iVar6 = *(int *)((int)(html_context->stack).next + 0x88);
      if (iVar6 != 0) {
        cVar10 = 'a';
        if (uVar5 == 3) {
          cVar10 = 'A';
        }
        uVar5 = iVar6 - 1;
        bVar11 = cVar10 + (char)uVar5 + (char)(uVar5 / 0x1a) * -0x1a;
      }
      uVar5 = 1;
      n[1] = '\0';
      n[0] = bVar11;
    }
    else if (uVar5 - 4 < 2) {
      uVar8 = *(uint *)((int)(html_context->stack).next + 0x88);
      if (uVar8 < 4000) {
        if (uVar8 == 0) {
          n[0] = 'o';
          n[1] = '\0';
        }
        else {
          n._0_4_ = n._0_4_ & 0xffffff00;
          local_5c = 0;
          do {
            while( true ) {
              uVar7 = roman_tbl[local_5c].n;
              if (uVar7 <= uVar8) {
                puVar3 = roman_tbl[local_5c].s;
                uVar4 = uVar8 - uVar7;
                do {
                  uVar8 = uVar4;
                  __strcat_chk(n,puVar3,0x20);
                  uVar4 = uVar8 - uVar7;
                } while (!CARRY4(uVar7,uVar8 - uVar7));
              }
              if (assert_failed != 0) goto LAB_08099600;
              local_5c = local_5c + 1;
              if ((uVar8 != 0) && (roman_tbl[local_5c].n == 0)) break;
              assert_failed = 0;
              if (uVar8 == 0) goto LAB_08099610;
            }
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/general.c";
            errline = 0x34c;
            elinks_internal((uchar *)
                            "assertion !(n && !roman_tbl[i].n) failed: BUG in roman number converter"
                           );
          } while (assert_failed == 0);
LAB_08099600:
          assert_failed = 0;
        }
      }
      else {
        n[0] = '-';
        n[1] = '-';
        n[2] = '-';
        n[3] = '\0';
      }
LAB_08099610:
      pbVar14 = n;
      if ((uVar5 == 5) && (bVar11 = n[0], n[0] != '\0')) {
        do {
          iVar6 = c_toupper((uint)bVar11);
          *pbVar14 = (byte)iVar6;
          pbVar14 = pbVar14 + 1;
          bVar11 = *pbVar14;
        } while (*pbVar14 != 0);
        uVar5 = 0;
      }
      else {
        uVar5 = 0;
      }
    }
    else {
      uVar5 = *(uint *)((int)(html_context->stack).next + 0x88);
      bVar15 = uVar5 < 10;
      if (bVar15) {
        put_chrs(html_context,(uchar *)"&nbsp;",6);
        uVar5 = *(ulong *)((int)(html_context->stack).next + 0x88);
      }
      elinks_ulongcat(n,(uint *)0x0,uVar5,0x1f,'\0',10,0);
      uVar5 = (uint)bVar15;
    }
    puVar13 = (uint *)n;
    do {
      puVar12 = puVar13;
      uVar7 = *puVar12 + 0xfefefeff & ~*puVar12;
      uVar8 = uVar7 & 0x80808080;
      puVar13 = puVar12 + 1;
    } while (uVar8 == 0);
    bVar15 = (uVar7 & 0x8080) == 0;
    if (bVar15) {
      uVar8 = uVar8 >> 0x10;
    }
    if (bVar15) {
      puVar13 = (uint *)((int)puVar12 + 6);
    }
    iVar6 = (int)puVar13 + ((-3 - (uint)CARRY1((byte)uVar8,(byte)uVar8)) - (int)n);
    put_chrs(html_context,n,iVar6);
    put_chrs(html_context,".&nbsp;",7);
    pvVar2 = (html_context->stack).next;
    *(uint *)((int)pvVar2 + 0x78) = uVar5 + 2 + *(int *)((int)pvVar2 + 0x78) + iVar6;
    *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
    phVar9 = search_html_stack(html_context,"ol");
    if (phVar9 != (html_element *)0x0) {
      (phVar9->parattr).list_number = *(int *)((int)(html_context->stack).next + 0x88) + 1;
    }
    *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
  }
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->line_breax = 2;
  html_context->was_li = 1;
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void html_ul(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  int *piVar1;
  uchar *s1;
  uchar *al;
  int iVar2;
  void *pvVar3;
  
  piVar1 = (int *)((int)(html_context->stack).next + 0x84);
  *piVar1 = *piVar1 + 1;
  *(undefined4 *)((int)(html_context->stack).next + 0x88) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x90) = 1;
  s1 = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  if (s1 != (uchar *)0x0) {
    iVar2 = c_strcasecmp((char *)s1,"disc");
    if (iVar2 == 0) {
LAB_080996eb:
      *(undefined4 *)((int)(html_context->stack).next + 0x90) = 2;
    }
    else {
      iVar2 = c_strcasecmp((char *)s1,"circle");
      if (iVar2 == 0) goto LAB_080996eb;
      iVar2 = c_strcasecmp((char *)s1,"square");
      if (iVar2 == 0) {
        *(undefined4 *)((int)(html_context->stack).next + 0x90) = 3;
      }
    }
    mem_free(s1);
  }
  pvVar3 = (html_context->stack).next;
  piVar1 = (int *)((int)pvVar3 + 0x78);
  *piVar1 = *piVar1 + (1 < *(int *)((int)pvVar3 + 0x84)) + 2;
  if (html_context->table_level == 0) {
    pvVar3 = (html_context->stack).next;
    iVar2 = *(int *)((int)pvVar3 + 0x80) / 2;
    if (*(int *)((int)pvVar3 + 0x78) <= iVar2) goto LAB_0809973a;
    *(int *)((int)pvVar3 + 0x78) = iVar2;
  }
  pvVar3 = (html_context->stack).next;
LAB_0809973a:
  *(undefined4 *)((int)pvVar3 + 0x74) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 8) = 1;
  return;
}



// WARNING: Unknown calling convention

void html_linebrk(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  uchar *s1;
  uchar *al;
  int iVar2;
  
  s1 = get_attr_value(a,"align",html_context->doc_cp,HTML_ATTR_NONE);
  if (s1 == (uchar *)0x0) {
    return;
  }
  iVar2 = c_strcasecmp((char *)s1,"left");
  if (iVar2 == 0) {
    *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  }
  else {
    iVar2 = c_strcasecmp((char *)s1,"right");
    if (iVar2 == 0) {
      *(undefined4 *)((int)(html_context->stack).next + 0x74) = 2;
      mem_free(s1);
      return;
    }
    iVar2 = c_strcasecmp((char *)s1,"center");
    if (iVar2 == 0) {
      *(undefined4 *)((int)(html_context->stack).next + 0x74) = 1;
      if (html_context->table_level == 0) {
        pvVar1 = (html_context->stack).next;
        *(undefined4 *)((int)pvVar1 + 0x7c) = 0;
        *(undefined4 *)((int)pvVar1 + 0x78) = 0;
      }
    }
    else {
      iVar2 = c_strcasecmp((char *)s1,"justify");
      if (iVar2 == 0) {
        *(undefined4 *)((int)(html_context->stack).next + 0x74) = 3;
      }
    }
  }
  mem_free(s1);
  return;
}



// WARNING: Unknown calling convention

void html_tr(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_linebrk(html_context,a,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_h(int h,uchar *a,format_align default_align,html_context *html_context,uchar *html,
           uchar *eof,uchar **end)

{
  void *pvVar1;
  int iVar2;
  int iVar3;
  
  pvVar1 = (html_context->stack).next;
  if (*(int *)((int)pvVar1 + 0x74) == 0) {
    *(format_align *)((int)pvVar1 + 0x74) = default_align;
  }
  html_linebrk(html_context,a,html,eof,end);
  pvVar1 = (html_context->stack).next;
  iVar3 = 0;
  if (-1 < h + -2) {
    iVar3 = h + -2;
  }
  iVar2 = *(int *)((int)pvVar1 + 0x74);
  if (iVar2 == 1) {
    *(undefined4 *)((int)pvVar1 + 0x7c) = 0;
    *(undefined4 *)((int)pvVar1 + 0x78) = 0;
    return;
  }
  if (iVar2 == 0) {
    *(int *)((int)pvVar1 + 0x78) = iVar3 * 2;
    *(undefined4 *)((int)(html_context->stack).next + 0x7c) = 0;
  }
  else {
    if (iVar2 == 2) {
      *(undefined4 *)((int)pvVar1 + 0x78) = 0;
      *(int *)((int)(html_context->stack).next + 0x7c) = iVar3 * 2;
      return;
    }
    if (iVar2 == 3) {
      *(int *)((int)pvVar1 + 0x7c) = iVar3 * 2;
      *(int *)((int)pvVar1 + 0x78) = iVar3 * 2;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void html_h6(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(6,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_h5(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(5,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_h4(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(4,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_h3(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(3,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_h2(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_h(2,a,ALIGN_LEFT,html_context,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_h1(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint *puVar1;
  
  puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
  *puVar1 = *puVar1 | 1;
  html_h(1,a,ALIGN_CENTER,html_context,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_p(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  int iVar1;
  void *pvVar2;
  
  pvVar2 = (html_context->stack).next;
  iVar1 = html_context->margin;
  if (*(int *)((int)pvVar2 + 0x78) < iVar1) {
    *(int *)((int)pvVar2 + 0x78) = iVar1;
    iVar1 = html_context->margin;
    pvVar2 = (html_context->stack).next;
  }
  if (*(int *)((int)pvVar2 + 0x7c) < iVar1) {
    *(int *)((int)pvVar2 + 0x7c) = iVar1;
  }
  html_linebrk(html_context,a,html,eof,end);
  return;
}



// WARNING: Unknown calling convention

void html_br(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  html_linebrk(html_context,a,html,eof,end);
  if ((html_context->field_0x44 & 1) == 0) {
    html_context->field_0x44 = html_context->field_0x44 | 1;
    return;
  }
  ln_break(html_context,2);
  return;
}



// WARNING: Unknown calling convention

void html_base(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *puVar1;
  uchar *al;
  uchar *string;
  uchar *base;
  uri *puVar2;
  
  puVar1 = get_attr_value(a,"href",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (puVar1 != (uchar *)0x0) {
    string = join_urls(html_context->base_href,puVar1);
    if (string == (uchar *)0x0) {
      mem_free(puVar1);
    }
    else {
      puVar2 = get_uri(string,0);
      mem_free(puVar1);
      mem_free(string);
      if (puVar2 != (uri *)0x0) {
        done_uri(html_context->base_href);
        html_context->base_href = puVar2;
      }
    }
  }
  puVar1 = get_target(html_context->options,a);
  if (puVar1 != (uchar *)0x0) {
    if (html_context->base_target != (uchar *)0x0) {
      mem_free(html_context->base_target);
    }
    html_context->base_target = puVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void html_table(html_context *html_context,uchar *attr,uchar *html,uchar *eof,uchar **end)

{
  void *pvVar1;
  int iVar2;
  
  if (((html_context->options->field_0x44 & 4) != 0) && (html_context->table_level < 10)) {
    format_table(attr,html,eof,end,html_context);
    ln_break(html_context,2);
    return;
  }
  pvVar1 = (html_context->stack).next;
  iVar2 = html_context->margin;
  *(int *)((int)pvVar1 + 0x78) = iVar2;
  *(int *)((int)pvVar1 + 0x7c) = iVar2;
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 0;
  html_linebrk(html_context,attr,html,eof,end);
  *(undefined4 *)((int)(html_context->stack).next + 0xc) = 0;
  return;
}



// WARNING: Unknown calling convention

void html_hr(html_context *html_context,uchar *a,uchar *html,uchar *eof,uchar **end)

{
  uint uVar1;
  int q;
  int iVar2;
  int i;
  void *pvVar3;
  int iVar4;
  uchar local_1d [13];
  
  local_1d[0] = 0xcd;
  uVar1 = get_num(a,"size",html_context->doc_cp);
  if (uVar1 < 2) {
    local_1d[0] = 0xc4;
  }
  html_stack_dup(html_context,ELEMENT_KILLABLE);
  *(undefined4 *)((int)(html_context->stack).next + 0x74) = 1;
  pvVar3 = (html_context->stack).next;
  if (*(void **)((int)pvVar3 + 0x1c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar3 + 0x1c));
    pvVar3 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar3 + 0x1c) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
  html_linebrk(html_context,a,html,eof,end);
  pvVar3 = (html_context->stack).next;
  if (*(int *)((int)pvVar3 + 0x74) == 3) {
    *(undefined4 *)((int)pvVar3 + 0x74) = 1;
    pvVar3 = (html_context->stack).next;
  }
  iVar2 = html_context->margin;
  *(int *)((int)pvVar3 + 0x7c) = iVar2;
  *(int *)((int)pvVar3 + 0x78) = iVar2;
  iVar2 = get_width(a,"width",1,html_context);
  if (iVar2 == -1) {
    pvVar3 = (html_context->stack).next;
    iVar4 = (-*(int *)((int)pvVar3 + 0x78) - *(int *)((int)pvVar3 + 0x7c)) +
            *(int *)((int)pvVar3 + 0x80);
    iVar2 = 0;
    if (-1 < iVar4) {
      iVar2 = iVar4;
    }
  }
  else {
    pvVar3 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar3 + 0xc) = 0x10;
  (*html_context->special_f)(html_context,7,1);
  if (0 < iVar2) {
    do {
      iVar2 = iVar2 + -1;
      put_chrs(html_context,local_1d,1);
    } while (0 < iVar2);
  }
  (*html_context->special_f)(html_context,7,0);
  ln_break(html_context,2);
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  return;
}



// WARNING: Unknown calling convention

void html_handle_body_meta(html_context *html_context,uchar *meta,uchar *eof)

{
  string *psVar1;
  string head;
  
  psVar1 = init_string(&head);
  if (psVar1 != (string *)0x0) {
    scan_http_equiv(meta,eof,&head,(string *)0x0,html_context->options);
    process_head(html_context,head.source);
    done_string(&head);
  }
  return;
}



// WARNING: Unknown calling convention

void html_apply_canvas_bgcolor(html_context *html_context)

{
  void *pvVar1;
  void *pvVar2;
  undefined4 uVar3;
  html_element *phVar4;
  html_element *e;
  
  if ((html_context->options->field_0x44 & 1) != 0) {
    css_apply(html_context,(html_element *)(html_context->stack).next,&html_context->css_styles,
              &html_context->stack);
  }
  pvVar1 = (html_context->stack).next;
  if (*(int *)((int)pvVar1 + 0x94) != *(int *)((int)pvVar1 + 0x14)) {
    html_context->field_0x44 = html_context->field_0x44 | 0x20;
    pvVar2 = (html_context->stack).prev;
    uVar3 = *(undefined4 *)((int)pvVar1 + 0x14);
    *(undefined4 *)((int)pvVar1 + 0x94) = uVar3;
    *(undefined4 *)((int)pvVar2 + 0x14) = uVar3;
    *(undefined4 *)((int)pvVar2 + 0x94) = uVar3;
  }
  if (((html_context->field_0x44 & 8) != 0) &&
     (*(color_T *)((int)(html_context->stack).next + 0x94) !=
      (html_context->options->default_style).bg)) {
    phVar4 = search_html_stack(html_context,"BODY");
    if (phVar4 == (html_element *)0x0) {
      (*html_context->special_f)(html_context,0xc);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void html_html_close(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  if ((1 < *(uint *)((int)(html_context->stack).next + 8)) &&
     ((html_context->field_0x44 & 0x20) == 0)) {
    html_apply_canvas_bgcolor(html_context);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void html_body(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  byte bVar1;
  int iVar2;
  
  get_color(html_context,a,"text",(color_T *)((int)(html_context->stack).next + 0x10));
  get_color(html_context,a,"link",(color_T *)((int)(html_context->stack).next + 0x30));
  get_color(html_context,a,"vlink",(color_T *)((int)(html_context->stack).next + 0x34));
  iVar2 = get_bgcolor(html_context,a,(color_T *)((int)(html_context->stack).next + 0x14));
  if (iVar2 == -1) {
    bVar1 = html_context->field_0x44;
  }
  else {
    bVar1 = html_context->field_0x44 | 0x20;
    html_context->field_0x44 = bVar1;
  }
  html_context->field_0x44 = bVar1 | 0x10;
  html_apply_canvas_bgcolor(html_context);
  return;
}



// WARNING: Unknown calling convention

void html_font(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  void *pvVar1;
  uchar *p;
  uchar *al;
  int *piVar2;
  ulong uVar3;
  uint s;
  ulong uVar4;
  int local_34;
  uchar *local_30;
  char *local_20 [4];
  
  p = get_attr_value(a,"size",html_context->doc_cp,HTML_ATTR_NONE);
  if (p != (uchar *)0x0) {
    if (*p == '+') {
      local_30 = p + 1;
      local_34 = 1;
    }
    else {
      local_34 = 0;
      local_30 = p;
      if (*p == '-') {
        local_30 = p + 1;
        local_34 = -1;
      }
    }
    piVar2 = __errno_location();
    *piVar2 = 0;
    uVar3 = strtoul((char *)local_30,local_20,10);
    if (((*piVar2 == 0) && (*local_30 != '\0')) && (*local_20[0] == '\0')) {
      uVar4 = 7;
      if (uVar3 < 8) {
        uVar4 = uVar3;
      }
      if (local_34 == 0) {
        *(ulong *)((int)(html_context->stack).next + 0x18) = uVar4;
      }
      else {
        piVar2 = (int *)((int)(html_context->stack).next + 0x18);
        *piVar2 = *piVar2 + uVar4 * local_34;
      }
      pvVar1 = (html_context->stack).next;
      if (*(int *)((int)pvVar1 + 0x18) < 1) {
        *(undefined4 *)((int)pvVar1 + 0x18) = 1;
      }
      else if (7 < *(int *)((int)pvVar1 + 0x18)) {
        *(undefined4 *)((int)pvVar1 + 0x18) = 7;
      }
    }
    mem_free(p);
  }
  get_color(html_context,a,"color",(color_T *)((int)(html_context->stack).next + 0x10));
  return;
}



// WARNING: Unknown calling convention

uchar * truncate_label(uchar *label,int max_len)

{
  size_t sVar1;
  size_t __n;
  size_t __n_00;
  size_t sVar2;
  uchar *__dest;
  uchar *new_label;
  
  __dest = (uchar *)0x0;
  sVar1 = strlen((char *)label);
  if (-1 < max_len) {
    if ((max_len < (int)sVar1) && (max_len != 0)) {
      __n = max_len / 2;
      __n_00 = __n - 1;
      if ((int)(__n * 2 + 1) <= max_len) {
        __n_00 = __n;
      }
      __dest = (uchar *)mem_alloc(max_len + 1);
      if (__dest != (uchar *)0x0) {
        sVar2 = 0;
        if (__n != 0) {
          memcpy(__dest,label,__n);
          sVar2 = __n;
        }
        __dest[sVar2] = '*';
        if (__n_00 != 0) {
          memcpy(__dest + sVar2 + 1,label + (sVar1 - __n_00),__n_00);
        }
        __dest[max_len] = '\0';
      }
    }
    else {
      __dest = stracpy(label);
    }
  }
  return __dest;
}



// WARNING: Unknown calling convention

uchar * get_image_filename_from_src(int max_len,uchar *src)

{
  uchar *puVar1;
  int iVar2;
  size_t __result;
  uchar *start;
  uchar *puVar3;
  uchar *filename;
  uchar *puVar4;
  int len;
  uchar *text;
  
  if (src != (uchar *)0x0) {
    if ((*src == '\0') || (*src == '?')) {
      iVar2 = 0;
      puVar3 = src;
    }
    else {
      iVar2 = 0;
      do {
        iVar2 = iVar2 + 1;
        if (src[iVar2] == '\0') break;
      } while (src[iVar2] != '?');
      puVar4 = src + iVar2;
      do {
        puVar3 = puVar4;
        if (puVar4 <= src) break;
        puVar1 = puVar4 + -1;
        puVar4 = puVar4 + -1;
      } while (*puVar1 != '/');
    }
    puVar3 = memacpy(puVar3,(int)(src + (iVar2 - (int)puVar3)));
    if (puVar3 != (uchar *)0x0) {
      puVar4 = truncate_label(puVar3,max_len);
      mem_free(puVar3);
      return puVar4;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void put_image_label(uchar *a,uchar *label,html_context *html_context)

{
  void *pvVar1;
  undefined4 uVar2;
  size_t len;
  color_T fg;
  
  html_focusable(html_context,a);
  pvVar1 = (html_context->stack).next;
  uVar2 = *(undefined4 *)((int)pvVar1 + 0x10);
  *(undefined4 *)((int)pvVar1 + 0x10) = *(undefined4 *)((int)pvVar1 + 0x3c);
  len = strlen((char *)label);
  put_chrs(html_context,label,len);
  *(undefined4 *)((int)(html_context->stack).next + 0x10) = uVar2;
  return;
}



// WARNING: Unknown calling convention

void html_img_do(uchar *a,uchar *object_src,html_context *html_context)

{
  uint *puVar1;
  document_options *pdVar2;
  int iVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  uchar *puVar7;
  uchar *usemap_attr;
  uchar *puVar8;
  int img_link_tag;
  uchar *new_label;
  void *pvVar9;
  size_t sVar10;
  uchar *label;
  uchar *joined_urls;
  document_options *options;
  uchar *new_link;
  uchar *map_url;
  uchar *local_20;
  
  pdVar2 = html_context->options;
  iVar3 = (pdVar2->image_link).display_style;
  puVar7 = get_attr_value(a,"usemap",html_context->doc_cp,HTML_ATTR_NONE);
  bVar5 = false;
  if (puVar7 != (uchar *)0x0) {
    puVar8 = join_urls(html_context->base_href,puVar7);
    mem_free(puVar7);
    if (puVar8 == (uchar *)0x0) {
      return;
    }
    puVar7 = straconcat("MAP@",puVar8,0);
    mem_free(puVar8);
    if (puVar7 == (uchar *)0x0) {
      return;
    }
    html_stack_dup(html_context,ELEMENT_KILLABLE);
    pvVar9 = (html_context->stack).next;
    if (*(void **)((int)pvVar9 + 0x1c) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar9 + 0x1c));
      pvVar9 = (html_context->stack).next;
    }
    *(uchar **)((int)pvVar9 + 0x1c) = puVar7;
    *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
    puVar1 = (uint *)((int)(html_context->stack).next + 0xc);
    *puVar1 = *puVar1 | 1;
    bVar5 = true;
  }
  if (((*(int *)((int)(html_context->stack).next + 0x1c) == 0) ||
      (puVar7 = get_attr_value(a,(uchar *)"ismap",html_context->doc_cp,HTML_ATTR_TEST),
      puVar7 == (uchar *)0x0)) || (bVar4 = true, bVar5)) {
    bVar4 = false;
  }
  puVar7 = (uchar *)0x0;
  if (((iVar3 - 2U < 2) &&
      ((puVar7 = get_attr_value(a,"alt",html_context->doc_cp,HTML_ATTR_NONE), puVar7 != (uchar *)0x0
       || (puVar7 = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE),
          puVar7 != (uchar *)0x0)))) && (sVar10 = strlen((char *)puVar7), 5 < sVar10)) {
    clr_spaces(puVar7);
  }
  if (((object_src == (uchar *)0x0) || (local_20 = stracpy(object_src), local_20 == (uchar *)0x0))
     && (local_20 = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL),
        local_20 == (uchar *)0x0)) {
    local_20 = get_attr_value(a,"dynsrc",html_context->doc_cp,HTML_ATTR_EAT_NL);
  }
  if (puVar7 != (uchar *)0x0) {
    if (*puVar7 == '\0') {
      mem_free(puVar7);
      goto LAB_0809a720;
    }
    puVar8 = truncate_label(puVar7,(pdVar2->image_link).label_maxlen);
    mem_free(puVar7);
    bVar6 = false;
    goto LAB_0809a5ae;
  }
LAB_0809a720:
  if (((pdVar2->field_0x44 & 0x20) == 0) && (*(int *)((int)(html_context->stack).next + 0x1c) == 0))
  goto LAB_0809a6e7;
  if (bVar5) {
    puVar8 = stracpy((uchar *)"USEMAP");
    bVar6 = true;
LAB_0809a5ae:
    if (puVar8 == (uchar *)0x0) goto LAB_0809a5bf;
    if (*puVar8 == '\0') {
      mem_free(puVar8);
      goto LAB_0809a5bf;
    }
  }
  else {
    if (bVar4) {
      puVar8 = stracpy((uchar *)"ISMAP");
      bVar6 = true;
      goto LAB_0809a5ae;
    }
    if (iVar3 == 3) {
      puVar8 = get_image_filename_from_src((pdVar2->image_link).filename_maxlen,local_20);
      bVar6 = true;
      goto LAB_0809a5ae;
    }
LAB_0809a5bf:
    if ((iVar3 == 1) &&
       (puVar8 = get_image_filename_from_src((pdVar2->image_link).filename_maxlen,local_20),
       puVar8 != (uchar *)0x0)) {
      bVar6 = true;
      if (*puVar8 != '\0') goto LAB_0809a5de;
      mem_free(puVar8);
    }
    puVar8 = stracpy("IMG");
    bVar6 = true;
  }
LAB_0809a5de:
  pvVar9 = (html_context->stack).next;
  if (*(void **)((int)pvVar9 + 0x24) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar9 + 0x24));
    pvVar9 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar9 + 0x24) = 0;
  pvVar9 = (html_context->stack).next;
  if (*(void **)((int)pvVar9 + 0x28) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar9 + 0x28));
    pvVar9 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar9 + 0x28) = 0;
  if (puVar8 != (uchar *)0x0) {
    iVar3 = (pdVar2->image_link).tagging;
    if ((iVar3 != 0) &&
       (((bVar6 || (iVar3 == 2)) &&
        (puVar7 = straconcat((pdVar2->image_link).prefix,puVar8,(pdVar2->image_link).suffix,0),
        puVar7 != (uchar *)0x0)))) {
      mem_free(puVar8);
      puVar8 = puVar7;
    }
    if (((pdVar2->image_link).field_0x18 & 1) == 0) {
      put_image_label(a,puVar8,html_context);
    }
    else {
      if (local_20 != (uchar *)0x0) {
        pvVar9 = (html_context->stack).next;
        puVar7 = join_urls(html_context->base_href,local_20);
        *(uchar **)((int)pvVar9 + 0x24) = puVar7;
      }
      pvVar9 = (html_context->stack).next;
      puVar7 = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
      *(uchar **)((int)pvVar9 + 0x28) = puVar7;
      if (bVar4) {
        html_stack_dup(html_context,ELEMENT_KILLABLE);
        puVar7 = straconcat(*(uchar **)((int)(html_context->stack).next + 0x1c),&DAT_0812c60d,0);
        if (puVar7 != (uchar *)0x0) {
          pvVar9 = (html_context->stack).next;
          if (*(void **)((int)pvVar9 + 0x1c) != (void *)0x0) {
            mem_free(*(void **)((int)pvVar9 + 0x1c));
            pvVar9 = (html_context->stack).next;
          }
          *(uchar **)((int)pvVar9 + 0x1c) = puVar7;
        }
        put_image_label(a,puVar8,html_context);
        kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
      }
      else {
        put_image_label(a,puVar8,html_context);
      }
      pvVar9 = (html_context->stack).next;
      if (*(void **)((int)pvVar9 + 0x24) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar9 + 0x24));
        pvVar9 = (html_context->stack).next;
      }
      *(undefined4 *)((int)pvVar9 + 0x24) = 0;
      pvVar9 = (html_context->stack).next;
      if (*(void **)((int)pvVar9 + 0x28) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar9 + 0x28));
        pvVar9 = (html_context->stack).next;
      }
      *(undefined4 *)((int)pvVar9 + 0x28) = 0;
    }
    mem_free(puVar8);
  }
LAB_0809a6e7:
  if (local_20 != (uchar *)0x0) {
    mem_free(local_20);
  }
  if (bVar5) {
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  }
  return;
}



// WARNING: Unknown calling convention

void html_img(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_img_do(a,(uchar *)0x0,html_context);
  return;
}



// WARNING: Unknown calling convention

void put_link_line(uchar *prefix,uchar *linkname,uchar *link,uchar *target,
                  html_context *html_context)

{
  void *pvVar1;
  size_t sVar2;
  uchar *puVar3;
  
  html_context->field_0x44 = html_context->field_0x44 | 8;
  html_stack_dup(html_context,ELEMENT_KILLABLE);
  ln_break(html_context,1);
  pvVar1 = (html_context->stack).next;
  if (*(void **)((int)pvVar1 + 0x1c) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar1 + 0x1c));
    pvVar1 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar1 + 0x1c) = 0;
  pvVar1 = (html_context->stack).next;
  if (*(void **)((int)pvVar1 + 0x20) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar1 + 0x20));
    pvVar1 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar1 + 0x20) = 0;
  pvVar1 = (html_context->stack).next;
  if (*(void **)((int)pvVar1 + 0x28) != (void *)0x0) {
    mem_free(*(void **)((int)pvVar1 + 0x28));
    pvVar1 = (html_context->stack).next;
  }
  *(undefined4 *)((int)pvVar1 + 0x28) = 0;
  *(undefined4 *)((int)(html_context->stack).next + 0x2c) = 0;
  sVar2 = strlen((char *)prefix);
  put_chrs(html_context,prefix,sVar2);
  pvVar1 = (html_context->stack).next;
  puVar3 = join_urls(html_context->base_href,link);
  *(uchar **)((int)pvVar1 + 0x1c) = puVar3;
  pvVar1 = (html_context->stack).next;
  puVar3 = stracpy(target);
  *(uchar **)((int)pvVar1 + 0x20) = puVar3;
  pvVar1 = (html_context->stack).next;
  *(undefined4 *)((int)pvVar1 + 0x10) = *(undefined4 *)((int)pvVar1 + 0x30);
  sVar2 = strlen((char *)linkname);
  put_chrs(html_context,linkname,sVar2);
  ln_break(html_context,1);
  kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  return;
}



// WARNING: Unknown calling convention

void html_link(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  hlink_type hVar1;
  bool bVar2;
  lt_default_name *plVar3;
  int iVar4;
  lt_default_name *entry;
  lt_default_name *plVar5;
  string *psVar6;
  int name_neq_title;
  uchar *puVar7;
  char *pcVar8;
  uchar *prefix;
  void *p;
  void *p_1;
  void *p_2;
  void *p_3;
  void *p_4;
  void *p_5;
  void *p_6;
  size_t len;
  int iVar9;
  int iVar10;
  int first;
  hlink *phVar11;
  int i;
  uchar *name;
  uchar *link_name;
  byte bVar12;
  hlink link;
  string text;
  
  bVar12 = 0;
  iVar9 = html_context->options->meta_link_display;
  if ((assert_failed == 0) && (assert_failed = (int)(a == (uchar *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/link.c";
    errline = 0x2e0;
    elinks_internal((uchar *)"assertion a && link failed!");
  }
  phVar11 = &link;
  for (iVar10 = 9; iVar10 != 0; iVar10 = iVar10 + -1) {
    phVar11->type = LT_UNKNOWN;
    phVar11 = (hlink *)((int)phVar11 + (uint)bVar12 * -8 + 4);
  }
  link.href = get_attr_value(a,"href",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (link.href == (uchar *)0x0) {
    return;
  }
  link.lang = get_attr_value(a,"lang",html_context->doc_cp,HTML_ATTR_NONE);
  link.hreflang = get_attr_value(a,(uchar *)"hreflang",html_context->doc_cp,HTML_ATTR_NONE);
  link.title = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
  link.content_type = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  link.media = get_attr_value(a,"media",html_context->doc_cp,HTML_ATTR_NONE);
  link.name = get_attr_value(a,"rel",html_context->doc_cp,HTML_ATTR_NONE);
  if (link.name == (uchar *)0x0) {
    link.name = get_attr_value(a,"rev",html_context->doc_cp,HTML_ATTR_NONE);
    hVar1 = link.type;
    if (link.name != (uchar *)0x0) {
      link.direction = LD_REV;
      goto LAB_0809ac39;
    }
  }
  else {
    link.direction = LD_REL;
LAB_0809ac39:
    if (lt_names[0].str != (uchar *)0x0) {
      iVar10 = 0;
      puVar7 = lt_names[0].str;
      do {
        iVar4 = c_strcasecmp((char *)link.name,(char *)puVar7);
        if (iVar4 == 0) {
          hVar1 = lt_names[iVar10].type;
          goto LAB_0809ac7f;
        }
        iVar10 = iVar10 + 1;
        puVar7 = lt_names[iVar10].str;
      } while (puVar7 != (uchar *)0x0);
    }
    pcVar8 = c_strcasestr((char *)link.name,"icon");
    if ((pcVar8 == (char *)0x0) &&
       ((link.content_type == (uchar *)0x0 ||
        (pcVar8 = c_strcasestr((char *)link.content_type,"icon"), pcVar8 == (char *)0x0)))) {
      pcVar8 = c_strcasestr((char *)link.name,"alternate");
      if (pcVar8 == (char *)0x0) {
        hVar1 = link.type;
        if (link.content_type != (uchar *)0x0) {
          pcVar8 = c_strcasestr((char *)link.content_type,"css");
          hVar1 = LT_STYLESHEET;
          if (pcVar8 == (char *)0x0) {
            hVar1 = link.type;
          }
        }
      }
      else {
        link.type = LT_ALTERNATE;
        if (link.lang == (uchar *)0x0) {
          pcVar8 = c_strcasestr((char *)link.name,"stylesheet");
          if ((pcVar8 == (char *)0x0) &&
             ((link.content_type == (uchar *)0x0 ||
              (pcVar8 = c_strcasestr((char *)link.content_type,"css"), pcVar8 == (char *)0x0)))) {
            hVar1 = LT_ALTERNATE_MEDIA;
            if (link.media == (uchar *)0x0) {
              hVar1 = link.type;
            }
          }
          else {
            link.type = LT_ALTERNATE_STYLESHEET;
            hVar1 = link.type;
          }
        }
        else {
          link.type = LT_ALTERNATE_LANG;
          hVar1 = link.type;
        }
      }
    }
    else {
      link.type = LT_ICON;
      hVar1 = link.type;
    }
  }
LAB_0809ac7f:
  link.type = hVar1;
  puVar7 = link.href;
  if (link.href == (uchar *)0x0) goto LAB_0809ae88;
  if (link.type == LT_STYLESHEET) {
    len = strlen((char *)link.href);
    import_css_stylesheet(&html_context->css_styles,html_context->base_href,puVar7,len);
  }
  if ((iVar9 == 0) ||
     ((iVar9 < 5 &&
      (((link.type + ~LT_COPYRIGHT < 2 || (link.type == LT_STYLESHEET)) ||
       (link.type == LT_ALTERNATE_STYLESHEET)))))) goto LAB_0809ae88;
  if ((link.name == (uchar *)0x0) || (link_name = link.name, link.type != LT_UNKNOWN)) {
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    if (lt_names[0].str == (uchar *)0x0) {
LAB_0809acf8:
      link_name = (uchar *)"unknown";
    }
    else {
      plVar3 = lt_names;
      link_name = lt_names[0].str;
      hVar1 = lt_names[0].type;
      while (hVar1 != link.type) {
        plVar5 = plVar3 + 1;
        if ((plVar5 == (lt_default_name *)0x0) ||
           (link_name = plVar3[1].str, link_name == (uchar *)0x0)) goto LAB_0809acf8;
        plVar3 = plVar5;
        hVar1 = plVar5->type;
      }
    }
  }
  psVar6 = init_string(&text);
  if (psVar6 == (string *)0x0) goto LAB_0809ae88;
  html_focusable(html_context,a);
  if (link.title == (uchar *)0x0) {
    add_to_string(&text,link_name);
    name_neq_title = 0;
  }
  else {
    add_to_string(&text,link.title);
    name_neq_title = strcmp((char *)link.title,(char *)link_name);
  }
  if (iVar9 != 1) {
    if (name_neq_title != 0) {
      add_to_string(&text," (");
      add_to_string(&text,link_name);
    }
    bVar2 = name_neq_title == 0;
    if (2 < iVar9) {
      if (link.hreflang != (uchar *)0x0) {
        puVar7 = ", ";
        if (bVar2) {
          puVar7 = " (";
        }
        bVar2 = false;
        add_to_string(&text,puVar7);
        add_to_string(&text,link.hreflang);
      }
      if ((iVar9 != 3) && (link.content_type != (uchar *)0x0)) {
        puVar7 = ", ";
        if (bVar2) {
          puVar7 = " (";
        }
        bVar2 = false;
        add_to_string(&text,puVar7);
        add_to_string(&text,link.content_type);
      }
    }
    if (((link.lang != (uchar *)0x0) && (link.type == LT_ALTERNATE_LANG)) &&
       ((iVar9 < 3 ||
        ((link.hreflang != (uchar *)0x0 &&
         (iVar9 = c_strcasecmp((char *)link.hreflang,(char *)link.lang), iVar9 != 0)))))) {
      puVar7 = ", ";
      if (bVar2) {
        puVar7 = " (";
      }
      bVar2 = false;
      add_to_string(&text,puVar7);
      add_to_string(&text,link.lang);
    }
    if (link.media == (uchar *)0x0) {
      if (bVar2) goto put_link_line;
    }
    else {
      puVar7 = " (";
      if (!bVar2) {
        puVar7 = ", ";
      }
      add_to_string(&text,puVar7);
      add_to_string(&text,link.media);
    }
    add_char_to_string(&text,')');
  }
put_link_line:
  pcVar8 = "Link: ";
  if (link.direction != LD_REL) {
    pcVar8 = "Reverse link: ";
  }
  if (text.length != 0) {
    link_name = text.source;
  }
  put_link_line((uchar *)pcVar8,link_name,link.href,html_context->base_target,html_context);
  if (text.source != (uchar *)0x0) {
    done_string(&text);
  }
LAB_0809ae88:
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  if (link.content_type != (uchar *)0x0) {
    mem_free(link.content_type);
  }
  if (link.media != (uchar *)0x0) {
    mem_free(link.media);
  }
  if (link.href != (uchar *)0x0) {
    mem_free(link.href);
  }
  if (link.hreflang != (uchar *)0x0) {
    mem_free(link.hreflang);
  }
  if (link.title != (uchar *)0x0) {
    mem_free(link.title);
  }
  if (link.lang != (uchar *)0x0) {
    mem_free(link.lang);
  }
  if (link.name != (uchar *)0x0) {
    mem_free(link.name);
  }
  return;
}



// WARNING: Unknown calling convention

void html_iframe_do(uchar *a,uchar *object_src,html_context *html_context)

{
  uchar *link;
  uchar *url;
  uchar *linkname;
  uchar *name;
  
  if (((object_src != (uchar *)0x0) && (link = stracpy(object_src), link != (uchar *)0x0)) ||
     (link = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL), link != (uchar *)0x0)) {
    linkname = get_attr_value(a,"name",html_context->doc_cp,HTML_ATTR_NONE);
    if (((linkname != (uchar *)0x0) ||
        (linkname = get_attr_value(a,"id",html_context->doc_cp,HTML_ATTR_NONE),
        linkname != (uchar *)0x0)) || (linkname = stracpy(""), linkname != (uchar *)0x0)) {
      html_focusable(html_context,a);
      if (*linkname == '\0') {
        put_link_line("",(uchar *)"IFrame",link,html_context->options->framename,html_context);
      }
      else {
        put_link_line((uchar *)"IFrame: ",linkname,link,html_context->options->framename,
                      html_context);
      }
      mem_free(linkname);
    }
    mem_free(link);
  }
  return;
}



// WARNING: Unknown calling convention

void html_embed(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *object_src;
  uchar *extension;
  uchar *puVar1;
  uchar *type;
  int iVar2;
  
  object_src = get_attr_value(a,"src",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (object_src != (uchar *)0x0) {
    if (*object_src != '\0') {
      puVar1 = (uchar *)strrchr((char *)object_src,0x2e);
      if (puVar1 == (uchar *)0x0) {
        puVar1 = object_src;
      }
      puVar1 = get_extension_content_type(puVar1);
      if (puVar1 == (uchar *)0x0) {
        html_iframe_do(a,object_src,html_context);
      }
      else {
        iVar2 = c_strncasecmp((char *)puVar1,"image/",6);
        if (iVar2 == 0) {
          html_img_do(a,object_src,html_context);
        }
        else {
          html_iframe_do(a,object_src,html_context);
        }
        mem_free(puVar1);
      }
    }
    mem_free(object_src);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void html_iframe(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  html_iframe_do(a,(uchar *)0x0,html_context);
  return;
}



// WARNING: Unknown calling convention

void html_object(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *object_src;
  uchar *url;
  uchar *linkname;
  int iVar1;
  uchar *linkname_00;
  uchar *name;
  
  object_src = get_attr_value(a,"data",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (object_src == (uchar *)0x0) {
    object_src = get_attr_value(a,(uchar *)"codebase",html_context->doc_cp,HTML_ATTR_EAT_NL);
    if (object_src == (uchar *)0x0) {
      return;
    }
  }
  linkname = get_attr_value(a,"type",html_context->doc_cp,HTML_ATTR_NONE);
  if (linkname != (uchar *)0x0) {
    iVar1 = c_strncasecmp((char *)linkname,"text/",5);
    if (iVar1 == 0) {
      html_iframe_do(a,object_src,html_context);
      html_skip(html_context,a);
    }
    else {
      iVar1 = c_strncasecmp((char *)linkname,"image/",6);
      if (iVar1 == 0) {
        html_img_do(a,object_src,html_context);
      }
      else {
        linkname_00 = get_attr_value(a,(uchar *)"standby",html_context->doc_cp,HTML_ATTR_NONE);
        html_focusable(html_context,a);
        if (linkname_00 == (uchar *)0x0) {
          put_link_line((uchar *)"Object: ",linkname,object_src,html_context->options->framename,
                        html_context);
        }
        else {
          if (*linkname_00 == '\0') {
            put_link_line((uchar *)"Object: ",linkname,object_src,html_context->options->framename,
                          html_context);
          }
          else {
            put_link_line((uchar *)"Object: ",linkname_00,object_src,
                          html_context->options->framename,html_context);
          }
          mem_free(linkname_00);
        }
      }
    }
    mem_free(linkname);
  }
  mem_free(object_src);
  return;
}



// WARNING: Unknown calling convention

void html_applet(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *link;
  uchar *code;
  uchar *linkname;
  uchar *alt;
  
  link = get_attr_value(a,"code",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (link != (uchar *)0x0) {
    linkname = get_attr_value(a,"alt",html_context->doc_cp,HTML_ATTR_NONE);
    html_focusable(html_context,a);
    if (linkname == (uchar *)0x0) {
      put_link_line("",(uchar *)"Applet",link,html_context->options->framename,html_context);
    }
    else {
      if (*linkname == '\0') {
        put_link_line("",(uchar *)"Applet",link,html_context->options->framename,html_context);
      }
      else {
        put_link_line((uchar *)"Applet: ",linkname,link,html_context->options->framename,
                      html_context);
      }
      mem_free(linkname);
    }
    mem_free(link);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void html_a(html_context *html_context,uchar *a,uchar *xxx3,uchar *xxx4,uchar **xxx5)

{
  uchar *puVar1;
  uint *puVar2;
  uchar uVar3;
  uchar *puVar4;
  uchar *href;
  size_t sVar5;
  int l;
  uchar *target;
  global_history_item *pgVar6;
  bookmark *pbVar7;
  void *pvVar8;
  uchar *puVar9;
  uchar *puVar10;
  undefined4 uVar11;
  void *local_24;
  
  puVar4 = get_attr_value(a,"href",html_context->doc_cp,HTML_ATTR_EAT_NL);
  if (puVar4 == (uchar *)0x0) {
    kill_html_stack_item(html_context,(html_element *)(html_context->stack).next);
  }
  else {
    local_24 = (html_context->stack).next;
    if (*(void **)((int)local_24 + 0x1c) != (void *)0x0) {
      mem_free(*(void **)((int)local_24 + 0x1c));
      local_24 = (html_context->stack).next;
    }
    sVar5 = strlen((char *)puVar4);
    uVar3 = *puVar4;
    puVar9 = puVar4;
    while (uVar3 == ' ') {
      puVar9 = puVar9 + 1;
      sVar5 = sVar5 - 1;
      uVar3 = *puVar9;
    }
    if (sVar5 == 0) {
LAB_0809b7b3:
      sVar5 = 1;
    }
    else {
      puVar10 = puVar9 + sVar5;
      uVar3 = puVar9[sVar5 - 1];
      while (uVar3 == ' ') {
        sVar5 = sVar5 - 1;
        puVar10[-1] = '\0';
        if (sVar5 == 0) goto LAB_0809b7b3;
        puVar1 = puVar10 + -2;
        puVar10 = puVar10 + -1;
        uVar3 = *puVar1;
      }
      sVar5 = sVar5 + 1;
    }
    memmove(puVar4,puVar9,sVar5);
    puVar9 = join_urls(html_context->base_href,puVar4);
    *(uchar **)((int)local_24 + 0x1c) = puVar9;
    mem_free(puVar4);
    puVar4 = get_target(html_context->options,a);
    if (puVar4 == (uchar *)0x0) {
      pvVar8 = (html_context->stack).next;
      if (*(void **)((int)pvVar8 + 0x20) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar8 + 0x20));
        pvVar8 = (html_context->stack).next;
      }
      puVar4 = stracpy(html_context->base_target);
      *(uchar **)((int)pvVar8 + 0x20) = puVar4;
    }
    else {
      pvVar8 = (html_context->stack).next;
      if (*(void **)((int)pvVar8 + 0x20) != (void *)0x0) {
        mem_free(*(void **)((int)pvVar8 + 0x20));
        pvVar8 = (html_context->stack).next;
      }
      *(uchar **)((int)pvVar8 + 0x20) = puVar4;
    }
    pgVar6 = get_global_history_item(*(uchar **)((int)(html_context->stack).next + 0x1c));
    if (pgVar6 == (global_history_item *)0x0) {
      pbVar7 = get_bookmark(*(uchar **)((int)(html_context->stack).next + 0x1c));
      if (pbVar7 == (bookmark *)0x0) {
        pvVar8 = (html_context->stack).next;
        uVar11 = *(undefined4 *)((int)pvVar8 + 0x30);
      }
      else {
        pvVar8 = (html_context->stack).next;
        uVar11 = *(undefined4 *)((int)pvVar8 + 0x38);
      }
      *(undefined4 *)((int)pvVar8 + 0x10) = uVar11;
      puVar2 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar2 = *puVar2 & 0xfffffffd;
      puVar2 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar2 = *puVar2 | 1;
    }
    else {
      pvVar8 = (html_context->stack).next;
      *(undefined4 *)((int)pvVar8 + 0x10) = *(undefined4 *)((int)pvVar8 + 0x34);
      puVar2 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar2 = *puVar2 & 0xfffffffe;
      puVar2 = (uint *)((int)(html_context->stack).next + 0xb0);
      *puVar2 = *puVar2 | 2;
    }
    pvVar8 = (html_context->stack).next;
    if (*(void **)((int)pvVar8 + 0x28) != (void *)0x0) {
      mem_free(*(void **)((int)pvVar8 + 0x28));
      pvVar8 = (html_context->stack).next;
    }
    puVar4 = get_attr_value(a,"title",html_context->doc_cp,HTML_ATTR_NONE);
    *(uchar **)((int)pvVar8 + 0x28) = puVar4;
    html_focusable(html_context,a);
  }
  set_fragment_identifier(html_context,a,"name");
  return;
}



// WARNING: Unknown calling convention

void tags_list_reset(void)

{
  internal_pointer = elements;
  return;
}



// WARNING: Unknown calling convention

fastfind_key_value * tags_list_next(void)

{
  uchar **ppuVar1;
  fastfind_key_value *pfVar2;
  
  pfVar2 = (fastfind_key_value *)0x0;
  ppuVar1 = &internal_pointer->name;
  if (*ppuVar1 != (uchar *)0x0) {
    tags_list_next::kv.data = internal_pointer;
    internal_pointer = internal_pointer + 1;
    pfVar2 = &tags_list_next::kv;
    tags_list_next::kv.key = *ppuVar1;
  }
  return pfVar2;
}



// WARNING: Unknown calling convention

uchar * skip_comment(uchar *html,uchar *eof)

{
  byte *pbVar1;
  byte *pbVar2;
  uchar *puVar3;
  ushort **ppuVar4;
  byte bVar5;
  
  pbVar2 = html + 4;
  puVar3 = html + 2;
  if (((eof < pbVar2) || (puVar3 = html + 2, html[2] != '-')) || (html[3] != '-')) {
    for (; puVar3 < eof; puVar3 = puVar3 + 1) {
      if (*puVar3 == '>') {
        return puVar3 + 1;
      }
    }
  }
  else {
    for (; pbVar2 < eof; pbVar2 = pbVar2 + 1) {
      while (((pbVar2 + 2 <= eof && (*pbVar2 == 0x2d)) && (pbVar1 = pbVar2 + 2, pbVar2[1] == 0x2d)))
      {
        while( true ) {
          pbVar2 = pbVar1;
          if (eof <= pbVar2) {
            return eof;
          }
          bVar5 = *pbVar2;
          if (bVar5 != 0x2d) break;
          pbVar1 = pbVar2 + 1;
        }
        ppuVar4 = __ctype_b_loc();
        while ((*(byte *)((int)*ppuVar4 + (uint)bVar5 * 2 + 1) & 0x20) != 0) {
          pbVar2 = pbVar2 + 1;
          if (eof <= pbVar2) {
            return eof;
          }
          bVar5 = *pbVar2;
        }
        if (eof <= pbVar2) {
          return eof;
        }
        if (bVar5 == 0x3e) {
          return pbVar2 + 1;
        }
      }
    }
  }
  return eof;
}



// WARNING: Unknown calling convention

int parse_element(uchar *e,uchar *eof,uchar **name,int *namelen,uchar **attr,uchar **end)

{
  ushort uVar1;
  ushort **ppuVar2;
  byte *pbVar3;
  ushort *puVar4;
  byte bVar5;
  byte *pbVar6;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(eof == (uchar *)0x0 || e == (uchar *)0x0),
     eof == (uchar *)0x0 || e == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
    errline = 0x3c;
    elinks_internal((uchar *)"assertion e && eof failed!");
  }
  if (((e < eof) && (*e == '<')) && (pbVar6 = e + 1, pbVar6 != eof)) {
    if (name != (uchar **)0x0) {
      *name = pbVar6;
    }
    bVar5 = e[1];
    if (bVar5 == 0x2f) {
      pbVar6 = e + 2;
      if (pbVar6 == eof) {
        return -1;
      }
      bVar5 = *pbVar6;
    }
    if ((((byte)(bVar5 + 0x9f) < 0x1a) || ((byte)(bVar5 + 0xbf) < 0x1a)) ||
       (((byte)(bVar5 - 0x30) < 10 || ((bVar5 == 0x5f || (bVar5 == 0x2d)))))) {
      while (((byte)(bVar5 + 0x9f) < 0x1a ||
             (((((byte)(bVar5 + 0xbf) < 0x1a || ((byte)(bVar5 - 0x30) < 10)) || (bVar5 == 0x5f)) ||
              (bVar5 == 0x2d))))) {
        pbVar6 = pbVar6 + 1;
        if (pbVar6 == eof) {
          return -1;
        }
        bVar5 = *pbVar6;
      }
      ppuVar2 = __ctype_b_loc();
      puVar4 = *ppuVar2;
      uVar1 = puVar4[bVar5];
      if (((((uVar1 & 0x2000) != 0) || (bVar5 == 0x3c)) ||
          ((bVar5 == 0x3e || ((bVar5 == 0x2f || (bVar5 == 0x3a)))))) || (bVar5 == 0x3d)) {
        if ((namelen != (int *)0x0) && (name != (uchar **)0x0)) {
          *namelen = (int)pbVar6 - (int)*name;
          bVar5 = *pbVar6;
          puVar4 = *ppuVar2;
          uVar1 = puVar4[bVar5];
        }
        while ((((uVar1 & 0x2000) != 0 || (bVar5 == 0x2f)) || (bVar5 == 0x3a))) {
          pbVar6 = pbVar6 + 1;
          if (pbVar6 == eof) {
            return -1;
          }
          bVar5 = *pbVar6;
          uVar1 = puVar4[bVar5];
        }
        while ((((0x7e < bVar5 || ((bVar5 < 0x3f && ((bVar5 == 0x3d || (bVar5 < 0x21)))))) &&
                (bVar5 != 0x3c)) &&
               ((bVar5 != 0x3e && ((*(byte *)((int)puVar4 + (uint)bVar5 * 2 + 1) & 0x20) == 0))))) {
          pbVar6 = pbVar6 + 1;
          if (pbVar6 == eof) {
            return -1;
          }
          bVar5 = *pbVar6;
        }
        if (attr != (uchar **)0x0) {
          *attr = pbVar6;
          puVar4 = *ppuVar2;
          bVar5 = *pbVar6;
        }
        uVar1 = puVar4[bVar5];
        while( true ) {
          while ((uVar1 & 0x2000) != 0) {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
            uVar1 = puVar4[*pbVar6];
          }
          while (((0x7e < bVar5 || ((bVar5 < 0x3f && ((bVar5 == 0x3d || (bVar5 < 0x21)))))) &&
                 ((bVar5 != 0x3c &&
                  ((bVar5 != 0x3e && ((*(byte *)((int)puVar4 + (uint)bVar5 * 2 + 1) & 0x20) == 0))))
                 ))) {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
          }
          if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) break;
          while ((bVar5 < 0x7f &&
                 ((0x3e < bVar5 ||
                  ((((bVar5 != 0x3d && (0x20 < bVar5)) && (bVar5 != 0x3c)) && (bVar5 != 0x3e)))))))
          {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
          }
          while (uVar1 = puVar4[bVar5], (uVar1 & 0x2000) != 0) {
            pbVar6 = pbVar6 + 1;
            if (pbVar6 == eof) {
              return -1;
            }
            bVar5 = *pbVar6;
          }
          if (bVar5 == 0x3d) {
            do {
              pbVar3 = pbVar6;
              pbVar6 = pbVar3 + 1;
              if (pbVar6 == eof) {
                return -1;
              }
              bVar5 = *pbVar6;
            } while ((*(byte *)((int)puVar4 + (uint)bVar5 * 2 + 1) & 0x20) != 0);
            if ((bVar5 == 0x27) || (bVar5 == 0x22)) {
              pbVar3 = pbVar3 + 2;
              while( true ) {
                if (pbVar3 == eof) {
                  return -1;
                }
                if (bVar5 == *pbVar3) break;
                pbVar3 = pbVar3 + 1;
              }
              pbVar6 = pbVar3 + 1;
              if (pbVar6 == eof) {
                return -1;
              }
              bVar5 = pbVar3[1];
LAB_0809be4b:
              uVar1 = puVar4[bVar5];
            }
            else {
              do {
                if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) goto LAB_0809be4b;
                pbVar6 = pbVar6 + 1;
                if (pbVar6 == eof) {
                  return -1;
                }
                bVar5 = *pbVar6;
                uVar1 = puVar4[bVar5];
              } while ((uVar1 & 0x2000) == 0);
            }
            while ((uVar1 & 0x2000) != 0) {
              pbVar6 = pbVar6 + 1;
              if (pbVar6 == eof) {
                return -1;
              }
              bVar5 = *pbVar6;
              uVar1 = puVar4[bVar5];
            }
            if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) break;
          }
          else {
            if ((bVar5 == 0x3c) || (bVar5 == 0x3e)) break;
            bVar5 = *pbVar6;
          }
        }
        if (end != (uchar **)0x0) {
          *end = pbVar6 + (*pbVar6 == 0x3e);
          return 0;
        }
        return 0;
      }
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

void free_tags_lookup(void)

{
  fastfind_done(&ff_tags_index);
  return;
}



// WARNING: Unknown calling convention

void init_tags_lookup(void)

{
  fastfind_index(&ff_tags_index,FF_COMPRESS|FF_LOCALE_INDEP);
  return;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  size_t newsize;
  uint size;
  size_t oldsize;
  uint uVar2;
  
  size = new + 0xff & 0xffffff00;
  uVar2 = old + 0xff & 0xffffff00;
  if (uVar2 < size) {
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + uVar2),0,size - uVar2);
  }
  return *ptr;
}



// WARNING: Unknown calling convention

uchar * get_attr_value(uchar *e,uchar *name,int cp,html_attr_flags flags)

{
  byte bVar1;
  ushort uVar2;
  bool bVar3;
  byte bVar4;
  ushort **ppuVar5;
  void *p;
  int iVar6;
  int iVar7;
  void *pvVar8;
  ushort *puVar9;
  size_t sVar10;
  int found;
  size_t newsize;
  uchar *name_start;
  byte *pbVar11;
  uint size;
  size_t oldsize;
  uchar *n;
  byte *pbVar12;
  uint uVar13;
  int attrlen;
  uchar *in_stack_ffffff94;
  size_t in_stack_ffffff98;
  size_t local_34;
  uchar *local_20 [4];
  
  local_20[0] = (uchar *)0x0;
  ppuVar5 = __ctype_b_loc();
  puVar9 = *ppuVar5;
  bVar4 = *e;
  uVar2 = puVar9[bVar4];
LAB_0809bf58:
  while ((uVar2 & 0x2000) != 0) {
    bVar4 = e[1];
    e = e + 1;
    uVar2 = puVar9[bVar4];
  }
  if ((((bVar4 != 0x3c) && (bVar4 != 0x3e)) && (bVar4 < 0x7f)) &&
     ((0x3e < bVar4 || ((bVar4 != 0x3d && (0x20 < bVar4)))))) {
    bVar1 = *name;
    pbVar11 = e;
    pbVar12 = name;
    if (bVar1 < 0x7f) {
      do {
        if ((bVar1 < 0x3f) &&
           (((bVar1 == 0x3d || (bVar1 < 0x21)) || ((bVar1 == 0x3c || (bVar1 == 0x3e)))))) {
LAB_0809bff0:
          bVar1 = *pbVar12;
          bVar4 = *pbVar11;
LAB_0809bff8:
          if (bVar1 != 0) {
            bVar3 = false;
            puVar9 = *ppuVar5;
            goto LAB_0809c0a6;
          }
          if ((bVar4 < 0x7f) &&
             ((0x3e < bVar4 ||
              (((bVar4 != 0x3d && (0x20 < bVar4)) && ((bVar4 != 0x3c && (bVar4 != 0x3e)))))))) {
            bVar3 = false;
            puVar9 = *ppuVar5;
            goto LAB_0809c0b0;
          }
          if ((flags & HTML_ATTR_TEST) != HTML_ATTR_NONE) {
            return e;
          }
          bVar3 = true;
          puVar9 = *ppuVar5;
          goto LAB_0809c0a6;
        }
        if ((0x7e < bVar4) ||
           ((bVar4 < 0x3f &&
            ((((bVar4 == 0x3d || (bVar4 < 0x21)) || (bVar4 == 0x3c)) || (bVar4 == 0x3e)))))) {
          bVar1 = *pbVar12;
          goto LAB_0809bff8;
        }
        iVar6 = c_toupper((uint)bVar4);
        in_stack_ffffff94 = (uchar *)(uint)*pbVar12;
        iVar7 = c_toupper((int)in_stack_ffffff94);
        if (iVar6 != iVar7) goto LAB_0809bff0;
        pbVar11 = pbVar11 + 1;
        bVar1 = pbVar12[1];
        if (0x7e < bVar1) goto code_r0x0809c098;
        bVar4 = *pbVar11;
        pbVar12 = pbVar12 + 1;
      } while( true );
    }
    goto LAB_0809c0a2;
  }
  goto parse_error;
code_r0x0809c098:
  bVar4 = *pbVar11;
  puVar9 = *ppuVar5;
LAB_0809c0a2:
  bVar3 = false;
LAB_0809c0a6:
  if (0x7e < bVar4) goto LAB_0809c0e6;
LAB_0809c0b0:
  do {
    if (bVar4 < 0x3f) {
      if (bVar4 == 0x3d) goto LAB_0809c0e3;
      if (bVar4 < 0x21) goto LAB_0809c0e3;
      if (bVar4 == 0x3c) goto LAB_0809c0e3;
      if (bVar4 == 0x3e) goto LAB_0809c0e3;
    }
    pbVar11 = pbVar11 + 1;
    bVar4 = *pbVar11;
  } while (bVar4 < 0x7f);
  bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
  e = pbVar11;
  while ((bVar1 & 0x20) != 0) {
    pbVar11 = e + 1;
LAB_0809c0e3:
    bVar4 = *pbVar11;
LAB_0809c0e6:
    e = pbVar11;
    bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
  }
  if (bVar4 == 0x3d) {
    e = e + 1;
    bVar4 = *e;
    bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
    while ((bVar1 & 0x20) != 0) {
      e = e + 1;
      bVar4 = *e;
      bVar1 = *(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1);
    }
    if (!bVar3) {
      if ((bVar4 != 0x27) && (bVar4 != 0x22)) {
        uVar2 = puVar9[bVar4];
        if (((uVar2 & 0x2000) == 0) && (bVar4 != 0x3c)) {
          while (bVar4 != 0x3e) {
            if (bVar4 == 0) goto parse_error;
            e = e + 1;
            bVar4 = *e;
            uVar2 = puVar9[bVar4];
            if (((uVar2 & 0x2000) != 0) || (bVar4 == 0x3c)) break;
          }
        }
        goto LAB_0809bf58;
      }
      while( true ) {
        bVar1 = e[1];
        if (bVar4 == bVar1) break;
        e = e + 1;
        if (bVar1 == 0) goto parse_error;
      }
      e = e + 2;
LAB_0809c0fc:
      bVar4 = *e;
      uVar2 = puVar9[bVar4];
      goto LAB_0809bf58;
    }
    if ((bVar4 == 0x27) || (bVar4 == 0x22)) {
      local_34 = 0;
      goto LAB_0809c2f6;
    }
    if ((((*(byte *)((int)puVar9 + (uint)bVar4 * 2 + 1) & 0x20) == 0) && (bVar4 != 0x3e)) &&
       (bVar4 != 0x3c)) {
      local_34 = 0;
      goto joined_r0x0809c398;
    }
  }
  else if (!bVar3) goto LAB_0809c0fc;
  local_34 = 0;
  sVar10 = 1;
  goto LAB_0809c23c;
LAB_0809c2f6:
  e = e + 1;
  bVar1 = *e;
  if (bVar1 != bVar4) {
    if (bVar1 != 0) {
      if ((flags & HTML_ATTR_LITERAL_NL) == HTML_ATTR_NONE) goto code_r0x0809c314;
      goto LAB_0809c34e;
    }
    goto parse_error;
  }
  sVar10 = local_34 + 1;
  goto LAB_0809c23c;
code_r0x0809c314:
  if (bVar1 != 0xd) {
    if ((byte)(bVar1 - 9) < 2) {
      if ((flags & HTML_ATTR_EAT_NL) == HTML_ATTR_NONE) {
        pvVar8 = mem_align_alloc__(local_20,local_34,local_34 + 1,(size_t)in_stack_ffffff94,
                                   in_stack_ffffff98);
        if (pvVar8 == (void *)0x0) goto LAB_0809bf7d;
        local_20[0][local_34] = ' ';
        local_34 = local_34 + 1;
      }
    }
    else {
LAB_0809c34e:
      pvVar8 = mem_align_alloc__(local_20,local_34,local_34 + 1,(size_t)in_stack_ffffff94,
                                 in_stack_ffffff98);
      if (pvVar8 == (void *)0x0) goto LAB_0809bf7d;
      local_20[0][local_34] = *e;
      local_34 = local_34 + 1;
    }
  }
  goto LAB_0809c2f6;
parse_error:
  if (local_20[0] != (uchar *)0x0) {
    mem_free(local_20[0]);
    return (uchar *)0x0;
  }
  goto LAB_0809bf7d;
  while( true ) {
    local_34 = sVar10 + 1;
    size = sVar10 + 0x100 & 0xffffff00;
    uVar13 = sVar10 + 0xff & 0xffffff00;
    if (uVar13 < size) {
      local_20[0] = (uchar *)mem_realloc(local_20[0],size);
      if (local_20[0] == (uchar *)0x0) goto LAB_0809bf7d;
      in_stack_ffffff94 = local_20[0] + uVar13;
      in_stack_ffffff98 = 0;
      memset(in_stack_ffffff94,0,size - uVar13);
    }
    if (local_20[0] == (uchar *)0x0) goto LAB_0809bf7d;
    local_20[0][sVar10] = e[sVar10];
    bVar4 = e[local_34];
    if ((((*(byte *)((int)*ppuVar5 + (uint)bVar4 * 2 + 1) & 0x20) != 0) || (bVar4 == 0x3c)) ||
       (bVar4 == 0x3e)) break;
joined_r0x0809c398:
    sVar10 = local_34;
    if (bVar4 == 0) goto parse_error;
  }
  sVar10 = sVar10 + 2;
LAB_0809c23c:
  pvVar8 = mem_align_alloc__(local_20,local_34,sVar10,(size_t)in_stack_ffffff94,in_stack_ffffff98);
  name_start = local_20[0];
  if (pvVar8 == (void *)0x0) {
LAB_0809bf7d:
    newsize = 0;
    name_start = (uchar *)newsize;
  }
  else {
    local_20[0][local_34] = '\0';
    pvVar8 = memchr(local_20[0],0x26,local_34);
    if (pvVar8 != (void *)0x0) {
      local_20[0] = convert_string_elinks
                              ((conv_table *)0x0,name_start,local_34,cp,CSM_QUERY,(int *)0x0,
                               (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      mem_free(name_start);
      name_start = local_20[0];
    }
  }
  return name_start;
}



// WARNING: Unknown calling convention

void scan_http_equiv(uchar *s,uchar *eof,string *head,string *title,document_options *options)

{
  uint uVar1;
  uchar *eof_00;
  string *psVar2;
  uchar *s1;
  int iVar3;
  uint uVar4;
  uchar *puVar5;
  uchar *puVar6;
  uint size;
  int newlength;
  uchar *he;
  uchar *html;
  size_t __n;
  size_t local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  eof_00 = eof;
  if ((title == (string *)0x0) || (psVar2 = init_string(title), psVar2 != (string *)0x0)) {
    add_char_to_string(head,'\n');
LAB_0809c498:
    if (s < eof_00) {
      do {
        if (*s == '<') {
          if ((s + 2 <= eof_00) && ((s[1] == '?' || (s[1] == '!')))) {
            s = skip_comment(s,eof_00);
            goto LAB_0809c498;
          }
          iVar3 = parse_element(s,eof_00,local_20,(int *)&local_28,&local_24,&s);
          if (iVar3 == 0) goto LAB_0809c515;
        }
        s = s + 1;
        if (eof_00 <= s) {
          return;
        }
      } while( true );
    }
  }
  return;
LAB_0809c515:
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x433;
  iVar3 = elinks_strlcasecmp(local_20[0],local_28,"HEAD",4,1);
  if (iVar3 == 0) goto LAB_0809c498;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x434;
  iVar3 = elinks_strlcasecmp(local_20[0],local_28,(uchar *)"/HEAD",5,1);
  if (iVar3 == 0) {
    return;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x435;
  iVar3 = elinks_strlcasecmp(local_20[0],local_28,"BODY",4,1);
  if (iVar3 == 0) {
    return;
  }
  if ((title == (string *)0x0) || (title->length != 0)) {
LAB_0809c821:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
    errline = 0x44d;
    iVar3 = elinks_strlcasecmp(local_20[0],local_28,"META",4,1);
    if (iVar3 == 0) {
      puVar6 = get_attr_value(local_24,"charset",options->cp,HTML_ATTR_NONE);
      if (puVar6 != (uchar *)0x0) {
        add_to_string(head,"Charset: ");
        add_to_string(head,puVar6);
        mem_free(puVar6);
      }
      puVar6 = get_attr_value(local_24,(uchar *)"http-equiv",options->cp,HTML_ATTR_NONE);
      if (puVar6 != (uchar *)0x0) {
        add_to_string(head,puVar6);
        mem_free(puVar6);
        puVar6 = get_attr_value(local_24,"content",options->cp,HTML_ATTR_NONE);
        if (puVar6 != (uchar *)0x0) {
          add_to_string(head,": ");
          add_to_string(head,puVar6);
          mem_free(puVar6);
        }
        add_crlf_to_string(head);
      }
    }
    goto LAB_0809c498;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
  errline = 0x436;
  iVar3 = elinks_strlcasecmp(local_20[0],local_28,"TITLE",5,1);
  puVar6 = s;
  if (iVar3 != 0) goto LAB_0809c821;
LAB_0809c65b:
  for (; (s < eof_00 && (*s != '<')); s = s + 1) {
xsp:
  }
  html = puVar6;
  if (puVar6 != s) {
    if (assert_failed == 0) {
      __n = (int)s - (int)puVar6;
      if ((puVar6 == (uchar *)0x0) || ((int)__n < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_0809c728;
      }
      else {
        assert_failed = 0;
      }
      html = s;
      if (__n != 0) {
        iVar3 = __n + title->length;
        uVar4 = title->length + 0xff;
        uVar1 = uVar4 >> 8;
        uVar4 = uVar4 & 0xffffff00;
        size = iVar3 + 0x100U & 0xffffff00;
        if (uVar4 <= size && size + uVar1 * -0x100 != 0) {
          puVar5 = (uchar *)mem_realloc(title->source,size);
          html = s;
          if (puVar5 == (uchar *)0x0) goto LAB_0809c690;
          title->source = puVar5;
          memset(puVar5 + uVar4,0,size + uVar1 * -0x100);
        }
        html = s;
        if (title->source != (uchar *)0x0) {
          memcpy(title->source + title->length,puVar6,__n);
          title->source[iVar3] = '\0';
          title->length = iVar3;
          html = s;
        }
      }
    }
    else {
LAB_0809c728:
      assert_failed = 0;
      html = s;
    }
  }
LAB_0809c690:
  if (eof_00 <= html) {
    return;
  }
  if ((html + 2 <= eof_00) && ((html[1] == '?' || (html[1] == '!')))) {
    s = skip_comment(html,eof_00);
    puVar6 = s;
    goto LAB_0809c65b;
  }
  iVar3 = parse_element(html,eof_00,local_20,(int *)&local_28,&local_24,&s);
  puVar6 = s;
  if (iVar3 != 0) goto xsp;
  clr_spaces(title->source);
  goto LAB_0809c515;
}



// WARNING: Unknown calling convention

void parse_html(uchar *html,uchar *eof,part *part,uchar *head,html_context *html_context)

{
  int *piVar1;
  byte bVar2;
  text_style_format tVar3;
  color_T cVar4;
  format_list_flag fVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  format_align fVar10;
  bool bVar11;
  size_t n2;
  ushort **ppuVar12;
  int noupdate;
  int prev_was_cr;
  uchar *peek;
  uint uVar13;
  int endingtag;
  void *pvVar14;
  html_element *phVar15;
  uchar *puVar16;
  int iVar17;
  uchar *puVar18;
  int lnb;
  bool bVar19;
  list_head_elinks *html_stack;
  int iVar20;
  code *pcVar21;
  uchar *h;
  byte *pbVar22;
  byte *pbVar23;
  html_element *elt;
  html_element *e;
  html_element *phVar24;
  css_selector *pcVar25;
  css_selector *selector;
  void *pvVar26;
  uchar *a;
  byte *pbVar27;
  uchar *base_pos;
  size_t local_40;
  byte *local_34;
  byte *local_30;
  size_t local_2c;
  byte *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->line_breax = 2 - (uint)(html_context->table_level == 0);
  html_context->position = 0;
  html_context->was_li = 0;
  html_context->field_0x44 = html_context->field_0x44 & 0xee;
  html_context->eoff = eof;
  html_context->part = part;
  if (head != (uchar *)0x0) {
    process_head(html_context,head);
  }
  if (html < eof) {
    ppuVar12 = __ctype_b_loc();
    html_stack = &html_context->stack;
    bVar19 = false;
    pbVar27 = html;
LAB_0809ca00:
    do {
      if (!bVar19) {
        html_context->part = part;
        html_context->eoff = eof;
        html = pbVar27;
      }
      bVar2 = *pbVar27;
      pbVar23 = pbVar27;
      if ((*(byte *)((int)*ppuVar12 + (uint)bVar2 * 2 + 1) & 0x20) == 0) {
        if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) != 0) goto LAB_0809cc10;
        goto LAB_0809cb00;
      }
      if ((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0) {
        pbVar22 = pbVar27;
        if (pbVar27 < eof) {
          do {
            pbVar22 = pbVar22 + 1;
            if (eof <= pbVar22) break;
          } while ((*(byte *)((int)*ppuVar12 + (uint)*pbVar22 * 2 + 1) & 0x20) != 0);
        }
        if (((eof <= pbVar22 + 1) || (*pbVar22 != 0x3c)) ||
           ((pbVar22[1] != 0x2f ||
            (iVar20 = parse_element(pbVar22,eof,local_20,(int *)&local_2c,&local_24,&local_28),
            iVar20 != 0)))) {
          pbVar23 = pbVar27 + 1;
          iVar20 = ((int)pbVar23 - (int)html) + -1;
          if (iVar20 + html_context->position != 0) {
            if (*pbVar27 == 0x20) {
              if ((pbVar23 < eof) &&
                 (bVar19 = true, pbVar27 = pbVar23,
                 (*(byte *)((int)*ppuVar12 + (uint)*pbVar23 * 2 + 1) & 0x20) == 0))
              goto LAB_0809ca00;
              put_chrs(html_context,html,(int)pbVar23 - (int)html);
            }
            else {
              put_chrs(html_context,html,iVar20);
              put_chrs(html_context," ",1);
            }
          }
          if (eof <= pbVar23) goto LAB_0809cbd6;
          while ((*(byte *)((int)*ppuVar12 + (uint)*pbVar23 * 2 + 1) & 0x20) != 0) {
            pbVar23 = pbVar23 + 1;
            if (eof <= pbVar23) goto LAB_0809cbd6;
          }
          bVar19 = false;
          pbVar27 = pbVar23;
          goto LAB_0809ca00;
        }
        iVar20 = 0;
        put_chrs(html_context,html,(int)pbVar27 - (int)html);
        html_context->putsp = HTML_SPACE_ADD;
        html = pbVar22;
element:
        uVar13 = (uint)(*local_20[0] == '/');
        local_20[0] = local_20[0] + uVar13;
        local_2c = local_2c - uVar13;
        if (uVar13 == 0) {
          if ((html_context->putsp == HTML_SPACE_ADD) &&
             (*(int *)((int)(html_context->stack).next + 0x98) == 0)) {
            put_chrs(html_context," ",1);
          }
          put_chrs(html_context,html,iVar20);
          if (((*(byte *)((int)(html_context->stack).next + 0xc) & 0x20) == 0) &&
             (html_context->putsp == HTML_SPACE_NORMAL)) {
            local_30 = local_28;
            do {
              iVar20 = parse_element(local_30,eof,&local_34,(int *)0x0,(uchar **)0x0,&local_30);
              if (iVar20 != 0) {
                if ((local_30 < eof) &&
                   ((*(byte *)((int)*ppuVar12 + (uint)*local_30 * 2 + 1) & 0x20) != 0)) {
                  put_chrs(html_context," ",1);
                  bVar19 = true;
                  goto LAB_0809cef6;
                }
                break;
              }
            } while (*local_34 != 0x2f);
          }
          bVar19 = true;
        }
        else {
          put_chrs(html_context,html,iVar20);
          bVar19 = false;
        }
LAB_0809cef6:
        puVar18 = local_20[0];
        puVar16 = local_24;
        pbVar23 = local_28;
        n2 = local_2c;
        pbVar27 = local_28;
        pvVar14 = fastfind_search(&ff_tags_index,local_20[0],local_2c);
        if ((html_context->field_0x44 & 6) == 0) {
          if (pvVar14 == (void *)0x0) {
LAB_0809cda2:
            bVar19 = false;
            goto LAB_0809cbb5;
          }
          if (!bVar19) goto LAB_0809d22f;
          local_34 = pbVar23;
          phVar15 = (html_element *)(html_context->stack).next;
          if (phVar15->type == ELEMENT_WEAK) {
            kill_html_stack_item(html_context,phVar15);
            phVar15 = (html_element *)(html_context->stack).next;
          }
          if (phVar15->invisible == 0) {
            pcVar21 = *(code **)((int)pvVar14 + 4);
          }
          else if ((*(code **)((int)pvVar14 + 4) != html_script) ||
                  (pcVar21 = html_script, phVar15->invisible < 2)) {
            ln_break(html_context,*(int *)((int)pvVar14 + 0xc));
            puVar16 = get_attr_value(puVar16,"id",html_context->doc_cp,HTML_ATTR_NONE);
            if (puVar16 != (uchar *)0x0) {
              (*html_context->special_f)(html_context,0,puVar16);
              mem_free(puVar16);
            }
            goto LAB_0809d21d;
          }
          tVar3 = (phVar15->attr).style.attr;
          cVar4 = (phVar15->parattr).bgcolor;
          fVar5 = (phVar15->parattr).flags;
          iVar20 = (phVar15->parattr).dd_margin;
          uVar13 = (phVar15->parattr).list_number;
          iVar6 = (phVar15->parattr).list_level;
          iVar7 = (phVar15->parattr).width;
          iVar8 = (phVar15->parattr).rightmargin;
          iVar9 = (phVar15->parattr).leftmargin;
          fVar10 = (phVar15->parattr).align;
          if ((pcVar21 == html_meta) && ((html_context->field_0x44 & 0x10) != 0)) {
            html_handle_body_meta(html_context,puVar18 + -1,eof);
            html_context->field_0x44 = html_context->field_0x44 & 0xef;
            pcVar21 = *(code **)((int)pvVar14 + 4);
          }
          if ((pcVar21 == html_style) && ((html_context->options->field_0x44 & 1) != 0)) {
            css_parse_stylesheet(&html_context->css_styles,html_context->base_href,local_34,eof);
          }
          iVar17 = *(int *)((int)pvVar14 + 0x10);
          if (iVar17 == 3) {
            phVar24 = (html_element *)(html_context->stack).next;
            phVar15 = (html_element *)html_stack;
            if ((html_element *)html_stack != phVar24) {
              while (((phVar15 = phVar24, phVar24->linebreak < 1 ||
                      (*(int *)((int)pvVar14 + 0xc) != 0)) && (ELEMENT_DONT_KILL < phVar24->type)))
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
                errline = 0x364;
                iVar17 = elinks_strlcasecmp(phVar24->name,phVar24->namelen,puVar18,n2,1);
                if ((iVar17 == 0) ||
                   (phVar24 = phVar24->next, phVar15 = (html_element *)html_stack,
                   (html_element *)html_stack == phVar24)) break;
              }
            }
LAB_0809d40d:
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
            errline = 0x368;
            iVar17 = elinks_strlcasecmp(phVar15->name,phVar15->namelen,puVar18,n2,1);
            if (iVar17 == 0) {
              phVar24 = phVar15->prev;
              while ((html_element *)html_stack != phVar24) {
                kill_html_stack_item(html_context,phVar24);
                phVar24 = phVar15->prev;
              }
              if (phVar15->type != ELEMENT_IMMORTAL) {
                kill_html_stack_item(html_context,phVar15);
                iVar17 = *(int *)((int)pvVar14 + 0x10);
                goto LAB_0809d48c;
              }
            }
            iVar17 = *(int *)((int)pvVar14 + 0x10);
          }
          else if (iVar17 == 1) {
            phVar15 = (html_element *)(html_context->stack).next;
            while ((((phVar15 != (html_element *)html_stack && (ELEMENT_DONT_KILL < phVar15->type))
                    && (phVar15->linebreak < 1)) && (*(int *)((int)pvVar14 + 0xc) != 0))) {
              phVar15 = phVar15->next;
            }
            goto LAB_0809d40d;
          }
LAB_0809d48c:
          if (iVar17 != 2) {
            html_stack_dup(html_context,ELEMENT_KILLABLE);
            *(uchar **)((int)(html_context->stack).next + 0x9c) = puVar18;
            *(size_t *)((int)(html_context->stack).next + 0xa0) = n2;
            *(uchar **)((int)(html_context->stack).next + 0xa4) = puVar16;
            *(undefined4 *)((int)(html_context->stack).next + 0xa8) =
                 *(undefined4 *)((int)pvVar14 + 0xc);
          }
          pcVar25 = (css_selector *)0x0;
          pvVar26 = (html_context->stack).next;
          if ((*(int *)((int)pvVar26 + 0xa4) != 0) && ((html_context->options->field_0x44 & 1) != 0)
             ) {
            if (*(void **)((int)pvVar26 + 0x40) != (void *)0x0) {
              mem_free(*(void **)((int)pvVar26 + 0x40));
              pvVar26 = (html_context->stack).next;
            }
            puVar18 = get_attr_value(puVar16,"id",html_context->doc_cp,HTML_ATTR_NONE);
            *(uchar **)((int)pvVar26 + 0x40) = puVar18;
            pvVar26 = (html_context->stack).next;
            if (*(void **)((int)pvVar26 + 0x44) != (void *)0x0) {
              mem_free(*(void **)((int)pvVar26 + 0x44));
              pvVar26 = (html_context->stack).next;
            }
            puVar18 = get_attr_value(puVar16,(uchar *)"class",html_context->doc_cp,HTML_ATTR_NONE);
            *(uchar **)((int)pvVar26 + 0x44) = puVar18;
            pcVar25 = get_css_selector_for_element
                                (html_context,(html_element *)(html_context->stack).next,
                                 &html_context->css_styles,html_stack);
            if (pcVar25 != (css_selector *)0x0) {
              apply_css_selector_style
                        (html_context,(html_element *)(html_context->stack).next,pcVar25);
              done_css_selector(pcVar25);
            }
          }
          ln_break(html_context,*(int *)((int)pvVar14 + 0xc));
          puVar18 = get_attr_value(puVar16,"id",html_context->doc_cp,HTML_ATTR_NONE);
          if (puVar18 != (uchar *)0x0) {
            (*html_context->special_f)(html_context,0,puVar18);
            mem_free(puVar18);
          }
          if (*(code **)((int)pvVar14 + 4) != (code *)0x0) {
            (**(code **)((int)pvVar14 + 4))(html_context,puVar16,local_34,eof,&local_34);
          }
          if (((pcVar25 != (css_selector *)0x0) &&
              (phVar15 = (html_element *)(html_context->stack).next,
              phVar15->options != (uchar *)0x0)) &&
             (pcVar25 = get_css_selector_for_element
                                  (html_context,phVar15,&html_context->css_styles,html_stack),
             pcVar25 != (css_selector *)0x0)) {
            apply_css_selector_style
                      (html_context,(html_element *)(html_context->stack).next,pcVar25);
            done_css_selector(pcVar25);
          }
          if (*(code **)((int)pvVar14 + 4) != html_br) {
            html_context->field_0x44 = html_context->field_0x44 & 0xfe;
          }
          if ((tVar3 & AT_PREFORMATTED) != 0) {
            pvVar14 = (html_context->stack).next;
            *(color_T *)((int)pvVar14 + 0x94) = cVar4;
            *(format_list_flag *)((int)pvVar14 + 0x90) = fVar5;
            *(int *)((int)pvVar14 + 0x8c) = iVar20;
            *(uint *)((int)pvVar14 + 0x88) = uVar13;
            *(int *)((int)pvVar14 + 0x84) = iVar6;
            *(int *)((int)pvVar14 + 0x80) = iVar7;
            *(int *)((int)pvVar14 + 0x7c) = iVar8;
            *(int *)((int)pvVar14 + 0x78) = iVar9;
            *(format_align *)((int)pvVar14 + 0x74) = fVar10;
          }
        }
        else {
          if (((pvVar14 == (void *)0x0) ||
              ((*(code **)((int)pvVar14 + 4) != html_xmp &&
               (*(code **)((int)pvVar14 + 4) != html_style)))) || (bVar19)) {
            put_chrs(html_context,"<",1);
            bVar19 = false;
            pbVar23 = pbVar22 + 1;
            goto LAB_0809cbb5;
          }
LAB_0809d22f:
          local_34 = pbVar23;
          html_context->field_0x44 = html_context->field_0x44 & 0xfe;
          if (*(int *)((int)pvVar14 + 0x10) - 2U < 2) goto LAB_0809cda2;
          if (*(code **)((int)pvVar14 + 8) != (code *)0x0) {
            (**(code **)((int)pvVar14 + 8))(html_context,puVar16,pbVar23,eof,&local_34);
          }
          phVar15 = (html_element *)(html_context->stack).next;
          if ((html_element *)html_stack != phVar15) {
            bVar19 = false;
            while( true ) {
              if ((0 < phVar15->linebreak) && (*(int *)((int)pvVar14 + 0xc) == 0)) {
                bVar19 = true;
              }
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
              errline = 0x3d1;
              iVar20 = elinks_strlcasecmp(phVar15->name,phVar15->namelen,puVar18,n2,1);
              if (iVar20 == 0) break;
              if ((phVar15->type < ELEMENT_KILLABLE) ||
                 (phVar15 = phVar15->next, (html_element *)html_stack == phVar15))
              goto LAB_0809d21d;
            }
            iVar20 = 0;
            phVar24 = phVar15;
            if (bVar19) {
              kill_html_stack_item(html_context,phVar15);
            }
            else {
              while ((html_element *)html_stack != phVar24) {
                piVar1 = &phVar24->linebreak;
                phVar24 = phVar24->prev;
                if (iVar20 < *piVar1) {
                  iVar20 = *piVar1;
                }
              }
              if (html_context->was_li != 0) {
                html_context->line_breax = 0;
              }
              ln_break(html_context,iVar20);
              while ((html_element *)html_stack != phVar15->prev) {
                kill_html_stack_item(html_context,phVar15->prev);
              }
              kill_html_stack_item(html_context,phVar15);
            }
          }
        }
LAB_0809d21d:
        bVar19 = false;
        pbVar23 = local_34;
      }
      else {
LAB_0809cc10:
        html_context->putsp = HTML_SPACE_NORMAL;
        bVar2 = *pbVar27;
        if (bVar2 == 9) {
          put_chrs(html_context,html,(int)pbVar27 - (int)html);
          pbVar23 = pbVar27 + 1;
          uVar13 = (uint)(html_context->position >> 0x1f) >> 0x1d;
          put_chrs(html_context,"        ",(uVar13 - (html_context->position + uVar13 & 7)) + 8);
          bVar19 = false;
        }
        else {
          if ((bVar2 == 10) || (bVar2 == 0xd)) {
            put_chrs(html_context,html,(int)pbVar27 - (int)html);
            if ((pbVar27 == html) && (0 < html_context->line_breax)) {
              html_context->line_breax = html_context->line_breax + -1;
            }
            while( true ) {
              if ((*pbVar27 == 0xd) && (pbVar27 < eof + -1)) {
                pbVar23 = pbVar27 + 1;
                if (pbVar27[1] == 10) {
                  pbVar23 = pbVar27 + 2;
                }
              }
              else {
                pbVar23 = pbVar27 + 1;
              }
              ln_break(html_context,1);
              if ((*pbVar23 != 10) && (*pbVar23 != 0xd)) break;
              html_context->line_breax = 0;
              pbVar27 = pbVar23;
            }
            goto LAB_0809cda2;
          }
          if ((pbVar27 + 5 < eof) && (bVar2 == 0x26)) {
            local_40 = 0;
            bVar19 = false;
            while (pbVar23[1] == 0x23) {
              bVar2 = pbVar23[2];
              pbVar22 = pbVar23 + 2;
              if ((bVar2 == 0x58) || (bVar2 == 0x78)) {
                pbVar22 = pbVar23 + 3;
                if (pbVar22 < eof) {
                  bVar2 = pbVar23[3];
                  while ((bVar2 == 0x30 && (pbVar22 = pbVar22 + 1, pbVar22 < eof))) {
                    bVar2 = *pbVar22;
                  }
                }
                if (eof == pbVar22) break;
                bVar2 = *pbVar22;
                if ((bVar2 == 0x41) || (bVar2 == 0x61)) {
                  bVar11 = false;
                }
                else {
                  if ((bVar2 != 0x44) && (bVar2 != 100)) break;
                  bVar11 = true;
                }
                pbVar22 = pbVar22 + 1;
              }
              else {
                if (pbVar22 < eof) {
                  while ((bVar2 == 0x30 && (pbVar22 = pbVar22 + 1, pbVar22 < eof))) {
                    bVar2 = *pbVar22;
                  }
                }
                if (((int)eof - (int)pbVar22 < 2) || (*pbVar22 != 0x31)) break;
                bVar11 = false;
                if (pbVar22[1] != 0x30) {
                  if (pbVar22[1] != 0x33) break;
                  bVar11 = true;
                }
                pbVar22 = pbVar22 + 2;
              }
              if ((eof == pbVar22) || (*pbVar22 != 0x3b)) break;
              pbVar23 = pbVar22 + 1;
              if ((bVar11) || (!bVar19)) {
                local_40 = local_40 + 1;
              }
              if ((eof <= pbVar22 + 6) || (bVar19 = bVar11, *pbVar23 != 0x26)) break;
            }
            if (local_40 != 0) {
              put_chrs(html_context,html,(int)pbVar27 - (int)html);
              ln_break(html_context,local_40);
              bVar19 = false;
              goto LAB_0809cbb5;
            }
            bVar2 = *pbVar23;
          }
LAB_0809cb00:
          local_40 = 0;
          if (bVar2 < 0x20) {
            do {
              if (pbVar23 != html) {
                put_chrs(html_context,html,(int)pbVar23 - (int)html);
              }
              local_40 = local_40 + 1;
              pbVar27 = pbVar23 + 1;
              pbVar23 = pbVar23 + 1;
              html = pbVar23;
            } while (((*pbVar27 < 0x20) && (pbVar23 < eof)) &&
                    ((*(byte *)((int)*ppuVar12 + (uint)*pbVar27 * 2 + 1) & 0x20) == 0));
            puVar16 = (uchar *)mem_alloc(local_40);
            bVar19 = false;
            if (puVar16 != (uchar *)0x0) {
              memset(puVar16,0x2e,local_40);
              put_chrs(html_context,puVar16,local_40);
              mem_free(puVar16);
              bVar19 = false;
            }
          }
          else {
            if (eof < pbVar23 + 2) {
              if (bVar2 == 0x3c) {
LAB_0809ce86:
                iVar20 = parse_element(pbVar23,eof,local_20,(int *)&local_2c,&local_24,&local_28);
                if (iVar20 == 0) {
                  iVar20 = (int)pbVar23 - (int)html;
                  pbVar22 = pbVar23;
                  goto element;
                }
              }
            }
            else if (bVar2 == 0x3c) {
              if (((pbVar23[1] != 0x3f) && (pbVar23[1] != 0x21)) ||
                 ((html_context->field_0x44 & 6) != 0)) goto LAB_0809ce86;
              put_chrs(html_context,html,(int)pbVar23 - (int)html);
              pbVar23 = skip_comment(pbVar23,eof);
              bVar19 = false;
              goto LAB_0809cbb5;
            }
            pbVar23 = pbVar23 + 1;
            bVar19 = true;
          }
        }
      }
LAB_0809cbb5:
      pbVar27 = pbVar23;
    } while (pbVar23 < eof);
    if (bVar19) {
      put_chrs(html_context,html,(int)pbVar23 - (int)html);
    }
  }
LAB_0809cbd6:
  ln_break(html_context,1);
  html_context->field_0x44 = html_context->field_0x44 & 0xfe;
  html_context->part = part;
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->position = 0;
  return;
}



// WARNING: Unknown calling convention

int get_width(uchar *a,uchar *name,int limited,html_context *html_context)

{
  byte *pbVar1;
  ushort *puVar2;
  void *pvVar3;
  bool bVar4;
  byte *p;
  ushort **ppuVar5;
  int len;
  int iVar6;
  int iVar7;
  int *piVar8;
  ulong uVar9;
  byte *pbVar10;
  int maxwidth;
  long width;
  uchar *str;
  byte *__nptr;
  byte bVar11;
  int percentage;
  char *local_20 [4];
  
  p = get_attr_value(a,name,html_context->doc_cp,HTML_ATTR_NONE);
  if (p == (byte *)0x0) {
    return -1;
  }
  ppuVar5 = __ctype_b_loc();
  puVar2 = *ppuVar5;
  __nptr = p;
  while (bVar11 = *__nptr, (*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
    __nptr = __nptr + 1;
  }
  if ((bVar11 != 0x2c) && (bVar11 != 0)) {
    iVar6 = 0;
    do {
      iVar7 = iVar6;
      iVar6 = iVar7 + 1;
      if (__nptr[iVar6] == 0x2c) break;
    } while (__nptr[iVar6] != 0);
    if (iVar6 != 0) {
      bVar11 = __nptr[iVar7];
      if ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
        pbVar10 = __nptr + iVar6;
        do {
          iVar6 = iVar6 + -1;
          if (iVar6 == 0) goto LAB_0809da5e;
          bVar11 = pbVar10[-2];
          pbVar10 = pbVar10 + -1;
        } while ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0);
      }
      bVar4 = false;
      iVar7 = iVar6;
      if (bVar11 == 0x25) {
        iVar7 = iVar6 + -1;
        if (iVar7 == 0) {
LAB_0809dab3:
          mem_free(p);
          return -1;
        }
        bVar11 = __nptr[iVar6 + -2];
        bVar4 = true;
      }
      if ((*(byte *)((int)puVar2 + (uint)bVar11 * 2 + 1) & 0x20) != 0) {
        pbVar10 = __nptr + iVar7;
        do {
          iVar7 = iVar7 + -1;
          if (iVar7 == 0) goto LAB_0809dab3;
          pbVar1 = pbVar10 + -2;
          pbVar10 = pbVar10 + -1;
        } while ((*(byte *)((int)puVar2 + (uint)*pbVar1 * 2 + 1) & 0x20) != 0);
      }
      __nptr[iVar7] = 0;
      piVar8 = __errno_location();
      *piVar8 = 0;
      uVar9 = strtoul((char *)__nptr,local_20,10);
      if ((*piVar8 != 0) ||
         (((*local_20[0] != '.' && (*local_20[0] != '\0')) || (uVar9 == 0x7fffffff)))) {
        mem_free(p);
        return -1;
      }
      mem_free(p);
      if (limited == 0) {
        if (bVar4) {
          return -1;
        }
        iVar6 = (int)(uVar9 + 3) / 7;
      }
      else {
        pvVar3 = (html_context->stack).next;
        iVar6 = (-*(int *)((int)pvVar3 + 0x78) - *(int *)((int)pvVar3 + 0x7c)) +
                *(int *)((int)pvVar3 + 0x80);
        iVar7 = 0;
        if (-1 < iVar6) {
          iVar7 = iVar6;
        }
        if (bVar4) {
          iVar6 = (int)(uVar9 * iVar7) / 100;
        }
        else {
          iVar6 = (int)(uVar9 + 3) / 7;
        }
        if (iVar7 < iVar6) {
          return iVar7;
        }
      }
      if (iVar6 < 0) {
        iVar6 = 0;
      }
      return iVar6;
    }
  }
LAB_0809da5e:
  mem_free(p);
  return -1;
}



// WARNING: Unknown calling convention

int get_num(uchar *a,uchar *name,int cp)

{
  uchar *__nptr;
  uchar *al;
  int *piVar1;
  uchar *end;
  long lVar2;
  int result;
  char *local_10;
  
  lVar2 = -1;
  __nptr = get_attr_value(a,name,cp,HTML_ATTR_NONE);
  if (__nptr != (uchar *)0x0) {
    piVar1 = __errno_location();
    *piVar1 = 0;
    lVar2 = strtol((char *)__nptr,&local_10,10);
    if ((((*piVar1 != 0) || (*__nptr == '\0')) || (lVar2 < 0)) || (*local_10 != '\0')) {
      lVar2 = -1;
    }
    mem_free(__nptr);
  }
  return lVar2;
}



// WARNING: Unknown calling convention

html_element * search_html_stack(html_context *html_context,uchar *name)

{
  size_t n2;
  int iVar1;
  html_element *element;
  html_element *phVar2;
  
  if (assert_failed == 0) {
    if ((name == (uchar *)0x0) || (*name == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0x37;
      elinks_internal((uchar *)"assertion name && *name failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  n2 = strlen((char *)name);
  phVar2 = (html_element *)(html_context->stack).next;
  if (phVar2 == (html_element *)&html_context->stack) {
LAB_0809dd70:
    phVar2 = (html_element *)0x0;
  }
  else {
    do {
      do {
        phVar2 = phVar2->next;
        if (phVar2 == (html_element *)&html_context->stack) goto LAB_0809dd70;
      } while ((html_element *)(html_context->stack).next == phVar2);
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0x41;
      iVar1 = elinks_strlcasecmp(phVar2->name,phVar2->namelen,name,n2,1);
    } while (iVar1 != 0);
  }
  return phVar2;
}



// WARNING: Unknown calling convention

void html_stack_dup(html_context *html_context,html_element_mortality_type type)

{
  html_element *phVar1;
  html_element *phVar2;
  html_element *e;
  uchar *puVar3;
  int iVar4;
  html_element *ep;
  html_element *phVar5;
  byte bVar6;
  
  bVar6 = 0;
  phVar1 = (html_element *)(html_context->stack).next;
  if (assert_failed == 0) {
    if ((phVar1 == (html_element *)0x0) || ((html_element *)&html_context->stack == phVar1)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0x8c;
      elinks_internal((uchar *)
                      "assertion ep && (void *) ep != &html_context->stack failed: html stack empty"
                     );
      if (assert_failed != 0) goto LAB_0809df18;
    }
    else {
      assert_failed = 0;
    }
    phVar2 = (html_element *)mem_alloc(0xb4);
    if (phVar2 != (html_element *)0x0) {
      ep = phVar1;
      phVar5 = phVar2;
      for (iVar4 = 0x2d; iVar4 != 0; iVar4 = iVar4 + -1) {
        ep = (html_element *)((int)ep + (uint)bVar6 * -8 + 4);
        phVar5->next = ep->next;
        ep = ep;
        phVar5 = (html_element *)((int)phVar5 + ((uint)bVar6 * -2 + 1) * 4);
      }
      puVar3 = (phVar1->attr).link;
      if (puVar3 != (uchar *)0x0) {
        puVar3 = stracpy(puVar3);
        *(uchar **)((int)&phVar2->attr + 0x10) = puVar3;
      }
      puVar3 = (phVar1->attr).target;
      if (puVar3 != (uchar *)0x0) {
        puVar3 = stracpy(puVar3);
        *(uchar **)((int)&phVar2->attr + 0x14) = puVar3;
      }
      puVar3 = (phVar1->attr).image;
      if (puVar3 != (uchar *)0x0) {
        puVar3 = stracpy(puVar3);
        *(uchar **)((int)&phVar2->attr + 0x18) = puVar3;
      }
      puVar3 = (phVar1->attr).title;
      if (puVar3 != (uchar *)0x0) {
        puVar3 = stracpy(puVar3);
        *(uchar **)((int)&phVar2->attr + 0x1c) = puVar3;
      }
      puVar3 = (phVar1->attr).select;
      if (puVar3 != (uchar *)0x0) {
        puVar3 = stracpy(puVar3);
        *(uchar **)((int)&phVar2->attr + 0x3c) = puVar3;
      }
      *(undefined4 *)((int)&phVar2->attr + 0x38) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x34) = 0;
      *(undefined4 *)((int)&phVar2->attr + 100) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x60) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x5c) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x58) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x54) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x50) = 0;
      *(undefined4 *)((int)&phVar2->attr + 0x4c) = 0;
      phVar2->options = (uchar *)0x0;
      phVar2->name = (uchar *)0x0;
      phVar2->namelen = 0;
      phVar2->type = type;
      phVar1 = (html_element *)(html_context->stack).next;
      phVar2->prev = (html_element *)&html_context->stack;
      phVar2->next = phVar1;
      (html_context->stack).next = phVar2;
      phVar2->next->prev = phVar2;
      return;
    }
  }
  else {
LAB_0809df18:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void kill_html_stack_item(html_context *html_context,html_element *e)

{
  uchar *puVar1;
  void *p;
  void *p_1;
  void *p_2;
  void *p_3;
  void *p_4;
  void *p_5;
  void *p_6;
  void *p_7;
  void *p_8;
  void *p_9;
  void *p_10;
  void *p_11;
  void *p_12;
  void *p_13;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(e == (html_element *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 0x51;
    elinks_internal((uchar *)"assertion e failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = (int)((html_element *)&html_context->stack == e);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 0x53;
    elinks_internal((uchar *)
                    "assertion (void *) e != &html_context->stack failed: trying to free bad html element"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = (int)(e->type == ELEMENT_IMMORTAL);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 0x55;
    elinks_internal((uchar *)
                    "assertion e->type != ELEMENT_IMMORTAL failed: trying to kill unkillable element"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  puVar1 = (e->attr).link;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).target;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).image;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).title;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).select;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).id;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).class;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).onclick;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).ondblclick;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).onmouseover;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).onhover;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).onfocus;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).onmouseout;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  puVar1 = (e->attr).onblur;
  if (puVar1 != (uchar *)0x0) {
    mem_free(puVar1);
  }
  e->next->prev = e->prev;
  e->prev->next = e->next;
  mem_free(e);
  return;
}



// WARNING: Unknown calling convention

void kill_element(html_context *html_context,int ls,html_element *e)

{
  int *piVar1;
  int n;
  int l;
  
  n = 0;
  if (e != (html_element *)&html_context->stack) {
    do {
      if ((ls != 0) && ((html_element *)(html_context->stack).next == e)) break;
      piVar1 = &e->linebreak;
      e = e->prev;
      if (n < *piVar1) {
        n = *piVar1;
      }
      kill_html_stack_item(html_context,e->next);
    } while (e != (html_element *)&html_context->stack);
  }
  ln_break(html_context,n);
  return;
}



// WARNING: Unknown calling convention

void kill_html_stack_until(html_context *html_context,int ls,...)

{
  uchar *s2;
  uchar c;
  char cVar1;
  size_t n2;
  int iVar2;
  uchar *s;
  va_list arg;
  uchar **ppuVar3;
  html_element *e;
  int sk;
  int iVar4;
  html_element *local_20;
  
  local_20 = (html_element *)(html_context->stack).next;
  if (ls != 0) {
    local_20 = local_20->next;
  }
  if (local_20 != (html_element *)&html_context->stack) {
    while( true ) {
      ppuVar3 = (uchar **)&stack0x0000000c;
      iVar4 = 0;
      do {
        s2 = *ppuVar3;
        while( true ) {
          if (s2 == (uchar *)0x0) goto LAB_0809e1fc;
          ppuVar3 = ppuVar3 + 1;
          n2 = strlen((char *)s2);
          if (n2 != 0) break;
          iVar4 = iVar4 + 1;
          s2 = *ppuVar3;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
        errline = 0xdd;
        iVar2 = elinks_strlcasecmp(local_20->name,local_20->namelen,s2,n2,1);
      } while (iVar2 != 0);
      if (iVar4 == 0) break;
      if (iVar4 == 1) {
        kill_element(html_context,ls,local_20->prev);
        return;
      }
LAB_0809e1fc:
      if (local_20->type < ELEMENT_KILLABLE) {
        return;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 0xf3;
      iVar4 = elinks_strlcasecmp(local_20->name,local_20->namelen,"TABLE",5,1);
      if (iVar4 == 0) {
        return;
      }
      if ((local_20->namelen == 2) && (iVar4 = c_toupper((uint)*local_20->name), iVar4 == 0x54)) {
        iVar4 = c_toupper((uint)local_20->name[1]);
        cVar1 = (char)iVar4;
        if (cVar1 == 'H') {
          return;
        }
        if (cVar1 == 'D') {
          return;
        }
        if (cVar1 == 'R') {
          return;
        }
      }
      local_20 = local_20->next;
      if (local_20 == (html_element *)&html_context->stack) {
        return;
      }
    }
    if (ELEMENT_DONT_KILL < local_20->type) {
      kill_element(html_context,ls,local_20);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void add_table_bad_html_end(table_elinks *table_elinks,uchar *end)

{
  int iVar1;
  
  if (((table_elinks->caption).start != (uchar *)0x0) &&
     ((table_elinks->caption).end == (uchar *)0x0)) {
    (table_elinks->caption).end = end;
    return;
  }
  iVar1 = table_elinks->bad_html_size;
  if ((iVar1 != 0) && (table_elinks->bad_html[iVar1 + -1].end == (uchar *)0x0)) {
    table_elinks->bad_html[iVar1 + -1].end = end;
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void free_table(table_elinks *table_elinks)

{
  void *p;
  void *p_1;
  void *p_2;
  void *p_3;
  void *p_4;
  void *p_5;
  void *p_6;
  void *p_7;
  int iVar1;
  table_cell *ptVar2;
  table_cell *p_00;
  table_cell *ptVar3;
  int row;
  int iVar4;
  int iVar5;
  int col;
  
  if (table_elinks->min_cols_widths != (int *)0x0) {
    mem_free(table_elinks->min_cols_widths);
  }
  if (table_elinks->max_cols_widths != (int *)0x0) {
    mem_free(table_elinks->max_cols_widths);
  }
  if (table_elinks->cols_widths != (int *)0x0) {
    mem_free(table_elinks->cols_widths);
  }
  if (table_elinks->rows_heights != (int *)0x0) {
    mem_free(table_elinks->rows_heights);
  }
  if (table_elinks->fragment_id != (uchar *)0x0) {
    mem_free(table_elinks->fragment_id);
  }
  if (table_elinks->cols_x != (int *)0x0) {
    mem_free(table_elinks->cols_x);
  }
  if (table_elinks->bad_html != (html_start_end *)0x0) {
    mem_free(table_elinks->bad_html);
  }
  if (table_elinks->cols < 1) {
    p_00 = table_elinks->cells;
  }
  else {
    iVar5 = 0;
    ptVar2 = table_elinks->cells;
    ptVar3 = table_elinks->cells;
    do {
      while (p_00 = ptVar3, ptVar3 = p_00, table_elinks->rows < 1) {
        iVar5 = iVar5 + 1;
        ptVar2 = p_00;
        if (table_elinks->cols == iVar5 || table_elinks->cols < iVar5) goto LAB_0809e488;
      }
      iVar1 = table_elinks->real_cols;
      iVar4 = 0;
      while( true ) {
        if (ptVar3[iVar1 * iVar4 + iVar5].fragment_id != (uchar *)0x0) {
          mem_free(ptVar3[iVar1 * iVar4 + iVar5].fragment_id);
          ptVar2 = table_elinks->cells;
          ptVar3 = ptVar2;
        }
        iVar4 = iVar4 + 1;
        if (table_elinks->rows == iVar4 || table_elinks->rows < iVar4) break;
        iVar1 = table_elinks->real_cols;
      }
      iVar5 = iVar5 + 1;
      p_00 = ptVar2;
    } while (table_elinks->cols != iVar5 && iVar5 <= table_elinks->cols);
  }
LAB_0809e488:
  mem_free(p_00);
  mem_free(table_elinks->columns);
  mem_free(table_elinks);
  return;
}



// WARNING: Unknown calling convention

void get_align(html_context *html_context,uchar *attr,int *a)

{
  uchar *s1;
  uchar *al;
  int iVar1;
  
  s1 = get_attr_value(attr,"align",html_context->doc_cp,HTML_ATTR_NONE);
  if (s1 == (uchar *)0x0) {
    return;
  }
  iVar1 = c_strcasecmp((char *)s1,"left");
  if (iVar1 == 0) {
    *a = 0;
    goto LAB_0809e509;
  }
  iVar1 = c_strcasecmp((char *)s1,"right");
  if (iVar1 != 0) {
    iVar1 = c_strcasecmp((char *)s1,"center");
    if (iVar1 == 0) {
      *a = 1;
      goto LAB_0809e509;
    }
    iVar1 = c_strcasecmp((char *)s1,"justify");
    if (iVar1 == 0) {
      *a = 3;
      goto LAB_0809e509;
    }
    iVar1 = c_strcasecmp((char *)s1,"char");
    if (iVar1 != 0) goto LAB_0809e509;
  }
  *a = 2;
LAB_0809e509:
  mem_free(s1);
  return;
}



// WARNING: Unknown calling convention

void get_valign(html_context *html_context,uchar *attr,int *a)

{
  uchar *s1;
  uchar *al;
  int iVar1;
  
  s1 = get_attr_value(attr,(uchar *)"valign",html_context->doc_cp,HTML_ATTR_NONE);
  if (s1 == (uchar *)0x0) {
    return;
  }
  iVar1 = c_strcasecmp((char *)s1,"top");
  if (iVar1 != 0) {
    iVar1 = c_strcasecmp((char *)s1,"middle");
    if (iVar1 == 0) {
      *a = 1;
      goto LAB_0809e5d9;
    }
    iVar1 = c_strcasecmp((char *)s1,"bottom");
    if (iVar1 == 0) {
      *a = 2;
      goto LAB_0809e5d9;
    }
    iVar1 = c_strcasecmp((char *)s1,"baseline");
    if (iVar1 != 0) goto LAB_0809e5d9;
  }
  *a = 0;
LAB_0809e5d9:
  mem_free(s1);
  return;
}



// WARNING: Unknown calling convention

void set_td_width(table_elinks *table_elinks,int col,int width,int force)

{
  bool bVar1;
  int *new_cols_x;
  int i;
  int iVar2;
  int *piVar3;
  int iVar4;
  int iVar5;
  int n;
  
  iVar2 = table_elinks->cols_x_count;
  if (col < iVar2) {
    new_cols_x = table_elinks->cols_x;
  }
  else {
    iVar5 = iVar2;
    do {
      if (col + 1 <= iVar5) {
        if (iVar5 != 0) goto LAB_0809e6e3;
        break;
      }
      iVar4 = iVar5 * 2;
      if (0xffff < iVar5) {
        iVar4 = iVar5 + 0x10000;
      }
      bVar1 = iVar5 < iVar4;
      iVar5 = iVar4;
    } while (bVar1);
    iVar5 = col + 1;
    if (iVar2 != 0) {
      return;
    }
LAB_0809e6e3:
    new_cols_x = (int *)mem_realloc(table_elinks->cols_x,iVar5 * 4);
    if (new_cols_x == (int *)0x0) {
      return;
    }
    iVar2 = table_elinks->cols_x_count;
    if (iVar2 < iVar5) {
      piVar3 = new_cols_x + iVar2;
      do {
        iVar2 = iVar2 + 1;
        *piVar3 = -1;
        piVar3 = piVar3 + 1;
      } while (iVar2 < iVar5);
    }
    table_elinks->cols_x_count = iVar5;
    table_elinks->cols_x = new_cols_x;
  }
  if (force == 0) {
    piVar3 = new_cols_x + col;
    iVar2 = *piVar3;
    if (iVar2 != -1) {
      if (width == -1) {
        return;
      }
      if (width < 0) {
        if (-1 < iVar2) goto LAB_0809e696;
      }
      else if (iVar2 < 0) {
        return;
      }
      *piVar3 = iVar2 + width >> 1;
      return;
    }
  }
  else {
    piVar3 = table_elinks->cols_x + col;
  }
LAB_0809e696:
  *piVar3 = width;
  return;
}



// WARNING: Unknown calling convention

void get_column_width(uchar *attr,int *width,int sh,html_context *html_context)

{
  uchar *__s;
  uchar *al;
  size_t sVar1;
  int iVar2;
  int w;
  int n;
  int *piVar3;
  ulong uVar4;
  char *local_20 [4];
  
  __s = get_attr_value(attr,"width",html_context->doc_cp,HTML_ATTR_NONE);
  if (__s != (uchar *)0x0) {
    sVar1 = strlen((char *)__s);
    if ((sVar1 == 0) || (__s[sVar1 - 1] != '*')) {
      iVar2 = get_width(attr,"width",sh,html_context);
      if (-1 < iVar2) {
        *width = iVar2;
      }
    }
    else {
      __s[sVar1 - 1] = '\0';
      piVar3 = __errno_location();
      *piVar3 = 0;
      uVar4 = strtoul((char *)__s,local_20,10);
      if (((-1 < (int)uVar4) && (*piVar3 == 0)) && ((*local_20[0] == '.' || (*local_20[0] == '\0')))
         ) {
        *width = -2 - uVar4;
      }
    }
    mem_free(__s);
  }
  return;
}



// WARNING: Unknown calling convention

table_cell * new_cell(table_elinks *table_elinks,int dest_col,int dest_row)

{
  bool bVar1;
  table_cell *ptVar2;
  int iVar3;
  table_cell *cell;
  int iVar4;
  int iVar5;
  table_cell *cell_1;
  table_cell *cellp;
  table_cell *cellp_1;
  int limit;
  int iVar6;
  size_t __n;
  int row;
  int col;
  int row_2;
  int iVar7;
  int row_1;
  table_cell *ptVar8;
  int iVar9;
  int col_1;
  
  if ((table_elinks->cols != dest_col && dest_col <= table_elinks->cols) &&
     (table_elinks->rows != dest_row && dest_row <= table_elinks->rows)) {
    return table_elinks->cells + table_elinks->real_cols * dest_row + dest_col;
  }
  iVar4 = table_elinks->real_cols;
  while( true ) {
    if ((dest_col < iVar4) && (dest_row < table_elinks->real_rows)) {
      iVar9 = table_elinks->cols;
      if (iVar9 <= dest_col) {
        if ((iVar9 != 0) && (0 < table_elinks->rows)) {
          iVar3 = 0;
          while( true ) {
            ptVar2 = table_elinks->cells;
            iVar6 = iVar4 * iVar3 + iVar9 + -1;
            if ((ptVar2[iVar6].colspan == -1) &&
               (iVar7 = table_elinks->cols, ptVar8 = ptVar2, iVar7 <= dest_col)) {
              while( true ) {
                iVar5 = iVar4 * iVar3 + iVar7;
                iVar7 = iVar7 + 1;
                ptVar8[iVar5].field_0x3c = ptVar8[iVar5].field_0x3c | 3;
                iVar4 = ptVar2[iVar6].rowspan;
                ptVar8[iVar5].colspan = -1;
                ptVar8[iVar5].rowspan = iVar4;
                ptVar8[iVar5].col = ptVar2[iVar6].col;
                ptVar8[iVar5].row = ptVar2[iVar6].row;
                if (dest_col < iVar7) break;
                ptVar8 = table_elinks->cells;
                iVar4 = table_elinks->real_cols;
              }
            }
            iVar3 = iVar3 + 1;
            if (table_elinks->rows <= iVar3) break;
            iVar4 = table_elinks->real_cols;
          }
        }
        table_elinks->cols = dest_col + 1;
      }
      iVar4 = table_elinks->rows;
      if (iVar4 <= dest_row) {
        if ((iVar4 != 0) && (0 < table_elinks->cols)) {
          iVar9 = 0;
          do {
            iVar6 = table_elinks->real_cols;
            ptVar2 = table_elinks->cells;
            iVar3 = iVar9 + (iVar4 + -1) * iVar6;
            if ((ptVar2[iVar3].rowspan == -1) &&
               (iVar7 = table_elinks->rows, ptVar8 = ptVar2, iVar7 <= dest_row)) {
              while( true ) {
                iVar6 = iVar6 * iVar7;
                iVar7 = iVar7 + 1;
                iVar6 = iVar6 + iVar9;
                ptVar8[iVar6].field_0x3c = ptVar8[iVar6].field_0x3c | 3;
                ptVar8[iVar6].rowspan = -1;
                ptVar8[iVar6].colspan = ptVar2[iVar3].colspan;
                ptVar8[iVar6].col = ptVar2[iVar3].col;
                ptVar8[iVar6].row = ptVar2[iVar3].row;
                if (dest_row < iVar7) break;
                ptVar8 = table_elinks->cells;
                iVar6 = table_elinks->real_cols;
              }
            }
            iVar9 = iVar9 + 1;
          } while (iVar9 < table_elinks->cols);
        }
        table_elinks->rows = dest_row + 1;
      }
      return table_elinks->cells + dest_row * table_elinks->real_cols + dest_col;
    }
    while (iVar4 < dest_col + 1) {
      iVar9 = iVar4 * 2;
      if (0x7ff < iVar4) {
        iVar9 = iVar4 + 0x800;
      }
      bVar1 = iVar9 <= iVar4;
      iVar4 = iVar9;
      if (bVar1) {
        return (table_cell *)0x0;
      }
    }
    if (iVar4 == 0) {
      return (table_cell *)0x0;
    }
    iVar9 = table_elinks->real_rows;
    if (iVar9 < dest_row + 1) {
      iVar6 = (0x1000 - iVar4) * 0x40;
      iVar3 = 0x20000;
      if (0x1ffff < iVar6) {
        iVar3 = iVar6;
      }
      iVar6 = iVar9;
      do {
        iVar9 = iVar6 * 2;
        if (iVar3 >> 6 <= iVar6) {
          iVar9 = iVar6 + (iVar3 >> 6);
        }
        if (iVar9 <= iVar6) {
          return (table_cell *)0x0;
        }
        iVar6 = iVar9;
      } while (iVar9 < dest_row + 1);
    }
    if (iVar9 == 0) {
      return (table_cell *)0x0;
    }
    ptVar2 = (table_cell *)mem_calloc(iVar9 * iVar4,0x40);
    if (ptVar2 == (table_cell *)0x0) break;
    __n = table_elinks->cols << 6;
    if ((__n != 0) && (0 < table_elinks->rows)) {
      iVar3 = table_elinks->real_cols;
      iVar6 = 0;
      ptVar8 = ptVar2;
      while( true ) {
        iVar3 = iVar3 * iVar6;
        iVar6 = iVar6 + 1;
        memcpy(ptVar8,table_elinks->cells + iVar3,__n);
        ptVar8 = ptVar8 + iVar4;
        if (table_elinks->rows <= iVar6) break;
        iVar3 = table_elinks->real_cols;
      }
    }
    mem_free(table_elinks->cells);
    table_elinks->real_cols = iVar4;
    table_elinks->real_rows = iVar9;
    table_elinks->cells = ptVar2;
  }
  return (table_cell *)0x0;
}



// WARNING: Unknown calling convention

void new_columns(table_elinks *table_elinks,int span,int width,int align,int valign,int group)

{
  int iVar1;
  int n;
  table_column *column;
  int iVar2;
  table_column *ptVar3;
  int iVar4;
  
  iVar1 = table_elinks->columns_count + span;
  iVar2 = table_elinks->real_columns_count;
  if (table_elinks->real_columns_count < iVar1) {
    do {
      iVar4 = iVar2 * 2;
      if (0x3fff < iVar2) {
        iVar4 = iVar2 + 0x4000;
      }
      if (iVar4 <= iVar2) {
        return;
      }
      iVar2 = iVar4;
    } while (iVar4 < iVar1);
    if (iVar4 == 0) {
      return;
    }
    ptVar3 = (table_column *)mem_realloc(table_elinks->columns,iVar4 << 4);
    if (ptVar3 == (table_column *)0x0) {
      return;
    }
    table_elinks->real_columns_count = iVar4;
    table_elinks->columns = ptVar3;
  }
  if (span != 0) {
    do {
      iVar2 = table_elinks->columns_count;
      table_elinks->columns_count = iVar2 + 1;
      ptVar3 = table_elinks->columns + iVar2;
      ptVar3->align = align;
      ptVar3->group = group;
      group = 0;
      span = span + -1;
      ptVar3->width = width;
      ptVar3->valign = valign;
    } while (span != 0);
  }
  return;
}



// WARNING: Unknown calling convention

table_elinks *
parse_table(uchar *html,uchar *eof,uchar **end,uchar *attr,int sh,html_context *html_context)

{
  byte *pbVar1;
  uchar uVar2;
  void *pvVar3;
  int iVar4;
  char cVar5;
  table_elinks *table_elinks_00;
  table_cell *ptVar7;
  table_column *ptVar8;
  uchar *puVar9;
  uchar *at;
  int iVar10;
  uchar *al_1;
  uchar *al;
  table_cell *span_cell_1;
  table_cell *cell_1;
  int iVar11;
  size_t count;
  html_start_end *phVar12;
  int *piVar13;
  table_cell *span_cell;
  byte bVar6;
  int rowspan;
  int k;
  uint uVar14;
  size_t sVar15;
  int closing_tag_1;
  size_t newsize;
  int row;
  int iVar16;
  int i;
  uchar *puVar17;
  table_cell *cell;
  table_elinks *table_elinks;
  int colspan;
  uint uVar18;
  table_cell *ptVar19;
  bool bVar20;
  bool bVar21;
  byte bVar22;
  int local_80;
  int local_7c;
  uchar *local_78;
  int local_74;
  int local_70;
  int local_6c;
  int local_68;
  int local_64;
  size_t local_50;
  uchar *local_4c;
  uchar *local_48;
  size_t local_44;
  uchar *local_40;
  uchar *local_3c;
  int local_38;
  int local_34;
  size_t local_30;
  color_T local_2c;
  byte *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar22 = 0;
  local_34 = 0;
  local_38 = 1;
  local_3c = (uchar *)0xffffffff;
  local_40 = (uchar *)0xffffffff;
  local_44 = 0xffffffff;
  *end = html;
  table_elinks_00 = (table_elinks *)mem_calloc(1,0x94);
  if (table_elinks_00 == (table_elinks *)0x0) {
    return (table_elinks *)0x0;
  }
  ptVar7 = (table_cell *)mem_calloc(4,0x40);
  table_elinks_00->cells = ptVar7;
  if (ptVar7 == (table_cell *)0x0) {
    mem_free(table_elinks_00);
    return (table_elinks *)0x0;
  }
  table_elinks_00->real_cols = 2;
  table_elinks_00->real_rows = 2;
  ptVar8 = (table_column *)mem_calloc(2,0x10);
  table_elinks_00->columns = ptVar8;
  if (ptVar8 == (table_column *)0x0) {
    mem_free(table_elinks_00->cells);
    mem_free(table_elinks_00);
    return (table_elinks *)0x0;
  }
  table_elinks_00->real_columns_count = 2;
  puVar9 = get_attr_value(attr,"id",html_context->doc_cp,HTML_ATTR_NONE);
  table_elinks_00->fragment_id = puVar9;
  if (((html_context->options->color_mode != COLOR_MODE_MONO) &&
      (0 < html_context->options->use_document_colors)) &&
     ((puVar9 = get_attr_value(attr,(uchar *)"bordercolor",html_context->doc_cp,HTML_ATTR_NONE),
      puVar9 != (uchar *)0x0 ||
      ((puVar9 = get_attr_value(attr,(uchar *)"bordercolorlight",html_context->doc_cp,HTML_ATTR_NONE
                               ), puVar9 != (uchar *)0x0 ||
       (puVar9 = get_attr_value(attr,(uchar *)"bordercolordark",html_context->doc_cp,HTML_ATTR_NONE)
       , puVar9 != (uchar *)0x0)))))) {
    uVar14 = 0xffffffff;
    puVar17 = puVar9;
    do {
      if (uVar14 == 0) break;
      uVar14 = uVar14 - 1;
      uVar2 = *puVar17;
      puVar17 = puVar17 + (uint)bVar22 * -2 + 1;
    } while (uVar2 != '\0');
    decode_color(puVar9,~uVar14 - 1,&table_elinks_00->bordercolor);
    mem_free(puVar9);
  }
  iVar10 = get_width(attr,"width",sh,html_context);
  table_elinks_00->width = iVar10;
  if (iVar10 == -1) {
    pvVar3 = (html_context->stack).next;
    iVar11 = (-*(int *)((int)pvVar3 + 0x78) - *(int *)((int)pvVar3 + 0x7c)) +
             *(int *)((int)pvVar3 + 0x80);
    iVar10 = 0;
    if (-1 < iVar11) {
      iVar10 = iVar11;
    }
    table_elinks_00->width = iVar10;
    table_elinks_00->field_0x7c = table_elinks_00->field_0x7c | 1;
  }
  iVar10 = get_num(attr,(uchar *)"border",html_context->doc_cp);
  table_elinks_00->border = iVar10;
  if (iVar10 == -1) {
    puVar9 = get_attr_value(attr,(uchar *)"border",html_context->doc_cp,HTML_ATTR_TEST);
    iVar10 = 1;
    if (puVar9 == (uchar *)0x0) {
      puVar9 = get_attr_value(attr,(uchar *)"rules",html_context->doc_cp,HTML_ATTR_TEST);
      if (puVar9 == (uchar *)0x0) {
        puVar9 = get_attr_value(attr,"frame",html_context->doc_cp,HTML_ATTR_TEST);
        iVar10 = 0;
        if (puVar9 == (uchar *)0x0) goto LAB_0809f76a;
      }
      iVar10 = 1;
    }
LAB_0809f76a:
    table_elinks_00->border = iVar10;
  }
  if (iVar10 != 0) {
    if (2 < iVar10) {
      table_elinks_00->border = 2;
    }
    iVar10 = get_num(attr,(uchar *)"cellspacing",html_context->doc_cp);
    table_elinks_00->cellspacing = iVar10;
    if (iVar10 < 1) {
      table_elinks_00->cellspacing = 1;
    }
    else if (2 < iVar10) {
      table_elinks_00->cellspacing = 2;
    }
    if (table_elinks_00->border != 0) {
      table_elinks_00->frame = 0xf;
      puVar9 = get_attr_value(attr,"frame",html_context->doc_cp,HTML_ATTR_NONE);
      if (puVar9 != (uchar *)0x0) {
        iVar10 = c_strcasecmp((char *)puVar9,"void");
        if (iVar10 == 0) {
          table_elinks_00->frame = 0;
        }
        else {
          iVar10 = c_strcasecmp((char *)puVar9,"above");
          if (iVar10 == 0) {
            table_elinks_00->frame = 1;
          }
          else {
            iVar10 = c_strcasecmp((char *)puVar9,"below");
            if (iVar10 == 0) {
              table_elinks_00->frame = 2;
            }
            else {
              iVar10 = c_strcasecmp((char *)puVar9,"hsides");
              if (iVar10 == 0) {
                table_elinks_00->frame = 3;
              }
              else {
                iVar10 = c_strcasecmp((char *)puVar9,"vsides");
                if (iVar10 == 0) {
                  table_elinks_00->frame = 0xc;
                }
                else {
                  iVar10 = c_strcasecmp((char *)puVar9,"lhs");
                  if (iVar10 == 0) {
                    table_elinks_00->frame = 4;
                  }
                  else {
                    iVar10 = c_strcasecmp((char *)puVar9,"rhs");
                    if (iVar10 == 0) {
                      table_elinks_00->frame = 8;
                    }
                  }
                }
              }
            }
          }
        }
        mem_free(puVar9);
      }
      goto LAB_0809ee60;
    }
  }
  table_elinks_00->frame = 0;
LAB_0809ee60:
  iVar10 = get_num(attr,(uchar *)"cellpadding",html_context->doc_cp);
  table_elinks_00->cellpadding = iVar10;
  if (iVar10 == -1) {
    table_elinks_00->vcellpadding = 0;
    table_elinks_00->cellpadding = (uint)(table_elinks_00->border != 0);
  }
  else {
    table_elinks_00->vcellpadding = (uint)(6 < iVar10);
    table_elinks_00->cellpadding = (uint)(3 < iVar10);
  }
  table_elinks_00->rules = ~-(uint)(table_elinks_00->border == 0) & 3;
  puVar9 = get_attr_value(attr,(uchar *)"rules",html_context->doc_cp,HTML_ATTR_NONE);
  if (puVar9 != (uchar *)0x0) {
    iVar10 = c_strcasecmp((char *)puVar9,"none");
    if (iVar10 == 0) {
      table_elinks_00->rules = 0;
    }
    else {
      iVar10 = c_strcasecmp((char *)puVar9,"groups");
      if (iVar10 == 0) {
        table_elinks_00->rules = 4;
      }
      else {
        iVar10 = c_strcasecmp((char *)puVar9,"rows");
        if (iVar10 == 0) {
          table_elinks_00->rules = 1;
        }
        else {
          iVar10 = c_strcasecmp((char *)puVar9,"cols");
          if (iVar10 == 0) {
            table_elinks_00->rules = 2;
          }
          else {
            iVar10 = c_strcasecmp((char *)puVar9,"all");
            if (iVar10 == 0) {
              table_elinks_00->rules = 3;
            }
          }
        }
      }
    }
    mem_free(puVar9);
  }
  table_elinks_00->align = *(int *)((int)(html_context->stack).next + 0x74);
  get_align(html_context,attr,&table_elinks_00->align);
  table_elinks_00->bgcolor = *(color_T *)((int)(html_context->stack).next + 0x94);
  get_bgcolor(html_context,attr,&table_elinks_00->bgcolor);
  local_2c = table_elinks_00->bgcolor;
  local_78 = (uchar *)0x0;
  bVar21 = false;
  local_74 = -1;
  local_6c = 0;
  local_70 = 0;
  local_80 = 0;
  pbVar1 = local_28;
  puVar9 = html;
LAB_0809ef90:
  do {
    local_24 = puVar9;
    local_28 = pbVar1;
    puVar17 = local_24;
    if ((!bVar21) &&
       (((table_elinks_00->caption).start == (uchar *)0x0 ||
        ((table_elinks_00->caption).end != (uchar *)0x0)))) {
      iVar10 = table_elinks_00->bad_html_size;
      if (iVar10 == 0) {
        uVar18 = 0;
        phVar12 = table_elinks_00->bad_html;
        uVar14 = 0x100;
LAB_0809f1a0:
        phVar12 = (html_start_end *)mem_realloc(phVar12,uVar14 * 8);
        if (phVar12 != (html_start_end *)0x0) {
          table_elinks_00->bad_html = phVar12;
          memset(phVar12 + uVar18,0,uVar14 * 8 + uVar18 * -8);
          phVar12 = table_elinks_00->bad_html;
LAB_0809efe9:
          if (phVar12 != (html_start_end *)0x0) {
            iVar10 = table_elinks_00->bad_html_size;
            phVar12[iVar10].start = puVar17;
            table_elinks_00->bad_html_size = iVar10 + 1;
          }
        }
      }
      else {
        phVar12 = table_elinks_00->bad_html;
        if (phVar12[iVar10 + -1].end != (uchar *)0x0) {
          uVar14 = iVar10 + 0x100U & 0xffffff00;
          uVar18 = iVar10 + 0xffU & 0xffffff00;
          if (uVar18 < uVar14) goto LAB_0809f1a0;
          goto LAB_0809efe9;
        }
      }
    }
    while( true ) {
      if (eof <= puVar17) {
        if (bVar21) {
          table_elinks_00->cells[local_74 * table_elinks_00->real_cols + local_6c].end = puVar17;
        }
        goto scan_done;
      }
      if (*puVar17 == '<') break;
      puVar17 = puVar17 + 1;
    }
    if ((eof < puVar17 + 2) || ((puVar17[1] != '?' && (puVar17[1] != '!')))) {
      iVar10 = parse_element(puVar17,eof,&local_28,(int *)&local_30,local_20,&local_24);
      pbVar1 = local_28;
      if (iVar10 == 0) {
        puVar9 = local_24;
        if (local_30 != 0) {
          bVar20 = false;
          if (*local_28 == 0x2f) {
            local_30 = local_30 - 1;
            if (local_30 == 0) goto LAB_0809ef90;
            local_28 = local_28 + 1;
            bVar20 = true;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
          errline = 0x263;
          iVar10 = elinks_strlcasecmp(local_28,local_30,"TABLE",5,1);
          if (iVar10 == 0) {
            if (bVar20) {
              if (local_70 != 0) {
                new_columns(table_elinks_00,local_70,local_44,(int)local_3c,(int)local_40,1);
              }
              if (bVar21) {
                table_elinks_00->cells[local_74 * table_elinks_00->real_cols + local_6c].end =
                     puVar17;
              }
scan_done:
              add_table_bad_html_end(table_elinks_00,puVar17);
              *end = puVar17;
              if (local_78 != (uchar *)0x0) {
                mem_free(local_78);
              }
              if (table_elinks_00->cols < 1) {
                count = table_elinks_00->rows;
              }
              else {
                count = table_elinks_00->rows;
                iVar10 = 0;
                sVar15 = count;
                do {
                  if (0 < (int)sVar15) {
                    iVar11 = table_elinks_00->real_cols;
                    iVar16 = 0;
                    count = sVar15;
                    do {
                      iVar11 = iVar11 * iVar16 + iVar10;
                      ptVar7 = table_elinks_00->cells;
                      if ((ptVar7[iVar11].field_0x3c & 2) == 0) {
                        if (ptVar7[iVar11].colspan == -1) {
                          iVar4 = ptVar7[iVar11].rowspan;
                          ptVar7[iVar11].colspan = table_elinks_00->cols - iVar10;
                          count = table_elinks_00->rows;
                        }
                        else {
                          iVar4 = ptVar7[iVar11].rowspan;
                        }
                        if (iVar4 != -1) goto LAB_0809f0de;
                        ptVar7[iVar11].rowspan = count - iVar16;
                        count = table_elinks_00->rows;
                        sVar15 = count;
                        if ((int)count <= iVar16 + 1) break;
                      }
                      else {
LAB_0809f0de:
                        sVar15 = count;
                        if ((int)count <= iVar16 + 1) break;
                      }
                      iVar16 = iVar16 + 1;
                      iVar11 = table_elinks_00->real_cols;
                    } while( true );
                  }
                  iVar10 = iVar10 + 1;
                } while (table_elinks_00->cols != iVar10 && iVar10 <= table_elinks_00->cols);
              }
              if (count == 0) {
                table_elinks_00->rows_heights = (int *)0x0;
              }
              else {
                piVar13 = (int *)mem_calloc(count,4);
                table_elinks_00->rows_heights = piVar13;
                if (piVar13 == (int *)0x0) {
abort:
                  *end = eof;
                  free_table(table_elinks_00);
                  return (table_elinks *)0x0;
                }
              }
              if (0 < table_elinks_00->columns_count) {
                iVar10 = 0;
                do {
                  iVar11 = table_elinks_00->columns[iVar10].width;
                  if (iVar11 != -1) {
                    set_td_width(table_elinks_00,iVar10,iVar11,1);
                  }
                  iVar10 = iVar10 + 1;
                } while (table_elinks_00->columns_count != iVar10 &&
                         iVar10 <= table_elinks_00->columns_count);
              }
              set_td_width(table_elinks_00,table_elinks_00->cols,-1,0);
              return table_elinks_00;
            }
            local_68 = 1;
            for (local_48 = local_24; pbVar1 = local_28, puVar9 = eof, local_48 < eof;
                local_48 = local_48 + 1) {
              while ((*local_48 == '<' &&
                     (iVar10 = parse_element(local_48,eof,&local_4c,(int *)&local_50,(uchar **)0x0,
                                             &local_48), iVar10 == 0))) {
                pbVar1 = local_28;
                puVar9 = eof;
                if (eof <= local_48) goto LAB_0809ef90;
                if (local_50 != 0) {
                  bVar20 = false;
                  if (*local_4c == '/') {
                    local_4c = local_4c + 1;
                    local_50 = local_50 - 1;
                    if (local_50 != 0) {
                      bVar20 = true;
                      goto LAB_0809f2eb;
                    }
                  }
                  else {
LAB_0809f2eb:
                    errfile = 
                    "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                    errline = 0x212;
                    iVar10 = elinks_strlcasecmp(local_4c,local_50,"TABLE",5,1);
                    if (iVar10 == 0) {
                      if (bVar20) {
                        local_68 = local_68 + -1;
                        pbVar1 = local_28;
                        puVar9 = local_48;
                        if (local_68 == 0) goto LAB_0809ef90;
                      }
                      else {
                        local_68 = local_68 + 1;
                      }
                    }
                  }
                  pbVar1 = local_28;
                  puVar9 = eof;
                  if (eof <= local_48) goto LAB_0809ef90;
                }
              }
            }
            goto LAB_0809ef90;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
          errline = 0x272;
          iVar10 = elinks_strlcasecmp(local_28,local_30,(uchar *)"CAPTION",7,1);
          if (iVar10 == 0) {
            if (bVar20) {
              pbVar1 = local_28;
              puVar9 = local_24;
              if (((table_elinks_00->caption).start != (uchar *)0x0) &&
                 ((table_elinks_00->caption).end == (uchar *)0x0)) {
                (table_elinks_00->caption).end = puVar17;
              }
            }
            else {
              add_table_bad_html_end(table_elinks_00,puVar17);
              pbVar1 = local_28;
              puVar9 = local_24;
              if ((table_elinks_00->caption).start == (uchar *)0x0) {
                (table_elinks_00->caption).start = puVar17;
              }
            }
            goto LAB_0809ef90;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
          errline = 0x280;
          iVar10 = elinks_strlcasecmp(local_28,local_30,(uchar *)"COLGROUP",8,1);
          if (iVar10 != 0) {
            if (!bVar20) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
              errline = 0x29a;
              iVar10 = elinks_strlcasecmp(local_28,local_30,"COL",3,1);
              if (iVar10 == 0) {
                add_table_bad_html_end(table_elinks_00,puVar17);
                iVar11 = get_num(local_20[0],"span",html_context->doc_cp);
                iVar10 = 1;
                if ((iVar11 != -1) && (iVar10 = 0x8000, iVar11 < 0x8001)) {
                  iVar10 = iVar11;
                }
                local_50 = local_44;
                local_4c = local_3c;
                local_48 = local_40;
                get_align(html_context,local_20[0],(int *)&local_4c);
                get_valign(html_context,local_20[0],(int *)&local_48);
                get_column_width(local_20[0],(int *)&local_50,sh,html_context);
                new_columns(table_elinks_00,iVar10,local_50,(int)local_4c,(int)local_48,
                            (uint)(local_70 != 0));
                local_70 = 0;
                pbVar1 = local_28;
                puVar9 = local_24;
                goto LAB_0809ef90;
              }
            }
            iVar10 = c_toupper((uint)*local_28);
            pbVar1 = local_28;
            puVar9 = local_24;
            if (iVar10 == 0x54) {
              local_30 = local_30 - 1;
              pbVar1 = local_28 + 1;
              if (local_30 != 0) {
                pbVar1 = local_28 + 1;
                local_28 = local_28 + 1;
                iVar10 = c_toupper((uint)*pbVar1);
                cVar5 = (char)iVar10;
                if (bVar20) {
                  pbVar1 = local_28;
                  puVar9 = local_24;
                  if ((local_30 == 1) && (((cVar5 == 'D' || (cVar5 == 'R')) || (cVar5 == 'H')))) {
                    if (local_70 != 0) {
                      new_columns(table_elinks_00,local_70,local_44,(int)local_3c,(int)local_40,1);
                    }
                    if (bVar21) {
                      table_elinks_00->cells[local_74 * table_elinks_00->real_cols + local_6c].end =
                           puVar17;
                    }
                    add_table_bad_html_end(table_elinks_00,puVar17);
                    bVar21 = false;
                    pbVar1 = local_28;
                    puVar9 = local_24;
                  }
                }
                else if (local_30 == 4) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c"
                  ;
                  errline = 0x2cb;
                  iVar10 = elinks_strlcasecmp(local_28,4,"HEAD",4,1);
                  if (iVar10 != 0) {
                    errfile = 
                    "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                    errline = 0x2cc;
                    iVar10 = elinks_strlcasecmp(local_28,local_30,"BODY",4,1);
                    if (iVar10 != 0) {
                      errfile = 
                      "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
                      errline = 0x2cd;
                      iVar10 = elinks_strlcasecmp(local_28,local_30,"FOOT",4,1);
                      if (iVar10 != 0) goto LAB_0809f877;
                    }
                  }
                  if (local_70 != 0) {
                    new_columns(table_elinks_00,local_70,local_44,(int)local_3c,(int)local_40,1);
                  }
                  add_table_bad_html_end(table_elinks_00,puVar17);
                  local_80 = 2;
                  pbVar1 = local_28;
                  puVar9 = local_24;
                }
                else {
LAB_0809f877:
                  pbVar1 = local_28;
                  puVar9 = local_24;
                  if (local_30 == 1) {
                    if (cVar5 == 'R') {
                      if (local_70 != 0) {
                        new_columns(table_elinks_00,local_70,local_44,(int)local_3c,(int)local_40,1)
                        ;
                      }
                      if (bVar21) {
                        table_elinks_00->cells[local_74 * table_elinks_00->real_cols + local_6c].end
                             = puVar17;
                      }
                      add_table_bad_html_end(table_elinks_00,puVar17);
                      local_80 = local_80 + -1 + (uint)(local_80 == 0);
                      local_34 = 0;
                      local_38 = 1;
                      local_2c = table_elinks_00->bgcolor;
                      get_align(html_context,local_20[0],&local_34);
                      get_valign(html_context,local_20[0],&local_38);
                      get_bgcolor(html_context,local_20[0],&local_2c);
                      if (local_78 != (uchar *)0x0) {
                        mem_free(local_78);
                      }
                      local_78 = get_attr_value(local_20[0],"id",html_context->doc_cp,HTML_ATTR_NONE
                                               );
                      local_74 = local_74 + 1;
                      bVar21 = false;
                      local_6c = 0;
                      pbVar1 = local_28;
                      puVar9 = local_24;
                    }
                    else {
                      bVar20 = cVar5 == 'H';
                      if ((bVar20) || (cVar5 == 'D')) {
                        if (local_70 != 0) {
                          new_columns(table_elinks_00,local_70,local_44,(int)local_3c,(int)local_40,
                                      1);
                        }
                        add_table_bad_html_end(table_elinks_00,puVar17);
                        if (bVar21) {
                          table_elinks_00->cells[local_74 * table_elinks_00->real_cols + local_6c].
                          end = puVar17;
                        }
                        if (local_74 == -1) {
                          local_74 = 0;
                          local_6c = 0;
                        }
                        while (ptVar7 = new_cell(table_elinks_00,local_6c,local_74),
                              ptVar7 != (table_cell *)0x0) {
                          if ((ptVar7->field_0x3c & 1) == 0) {
                            ptVar7->col = local_6c;
                            ptVar7->field_0x3c = ptVar7->field_0x3c | 1;
                            ptVar7->row = local_74;
                            ptVar7->start = local_24;
                            ptVar7->align = local_34;
                            ptVar7->valign = local_38;
                            puVar9 = get_attr_value(local_20[0],"id",html_context->doc_cp,
                                                    HTML_ATTR_NONE);
                            ptVar7->fragment_id = puVar9;
                            if ((puVar9 == (uchar *)0x0) && (local_78 != (uchar *)0x0)) {
                              ptVar7->fragment_id = local_78;
                              local_78 = (uchar *)0x0;
                            }
                            bVar6 = ptVar7->field_0x3c & 0xfb | bVar20 << 2;
                            ptVar7->field_0x3c = bVar6;
                            if (bVar20) {
                              ptVar7->align = 1;
                            }
                            if (local_80 == 1) {
                              ptVar7->field_0x3c = bVar6 | 8;
                            }
                            if (table_elinks_00->columns_count != local_6c &&
                                local_6c <= table_elinks_00->columns_count) {
                              ptVar8 = table_elinks_00->columns + local_6c;
                              if (ptVar8->align != -1) {
                                ptVar7->align = ptVar8->align;
                                ptVar8 = table_elinks_00->columns + local_6c;
                              }
                              if (ptVar8->valign != -1) {
                                ptVar7->valign = ptVar8->valign;
                              }
                            }
                            ptVar7->bgcolor = local_2c;
                            get_align(html_context,local_20[0],&ptVar7->align);
                            get_valign(html_context,local_20[0],&ptVar7->valign);
                            get_bgcolor(html_context,local_20[0],&ptVar7->bgcolor);
                            iVar11 = get_num(local_20[0],(uchar *)"colspan",html_context->doc_cp);
                            iVar10 = 1;
                            if (((iVar11 != -1) && (iVar10 = -1, iVar11 != 0)) &&
                               (iVar10 = 0x8000, iVar11 < 0x8001)) {
                              iVar10 = iVar11;
                            }
                            iVar11 = get_num(local_20[0],(uchar *)"rowspan",html_context->doc_cp);
                            local_64 = 1;
                            if (((iVar11 != -1) && (local_64 = -1, iVar11 != 0)) &&
                               (local_64 = iVar11, 0x8000 < iVar11)) {
                              local_64 = 0x8000;
                            }
                            ptVar7->colspan = iVar10;
                            ptVar7->rowspan = local_64;
                            if (iVar10 == 1) {
                              local_48 = (uchar *)0xffffffff;
                              get_column_width(local_20[0],(int *)&local_48,sh,html_context);
                              if (local_48 != (uchar *)0xffffffff) {
                                set_td_width(table_elinks_00,local_6c,(int)local_48,0);
                              }
                            }
                            iVar16 = 1;
                            iVar11 = table_elinks_00->cols;
                            goto LAB_0809fbb6;
                          }
                          if (ptVar7->colspan == -1) break;
                          local_6c = local_6c + 1;
                        }
                        bVar21 = false;
                        pbVar1 = local_28;
                        puVar9 = local_24;
                      }
                    }
                  }
                }
              }
            }
            goto LAB_0809ef90;
          }
          if (local_70 != 0) {
            new_columns(table_elinks_00,local_70,local_44,(int)local_3c,(int)local_40,1);
          }
          add_table_bad_html_end(table_elinks_00,puVar17);
          local_3c = (uchar *)0xffffffff;
          local_40 = (uchar *)0xffffffff;
          local_44 = 0xffffffff;
          local_70 = 0;
          pbVar1 = local_28;
          puVar9 = local_24;
          if (!bVar20) {
            get_align(html_context,local_20[0],(int *)&local_3c);
            get_valign(html_context,local_20[0],(int *)&local_40);
            get_column_width(local_20[0],(int *)&local_44,sh,html_context);
            iVar10 = get_num(local_20[0],"span",html_context->doc_cp);
            pbVar1 = local_28;
            puVar9 = local_24;
            if (iVar10 == -1) {
              local_70 = 1;
            }
            else {
              local_70 = 0x8000;
              if (iVar10 < 0x8001) {
                local_70 = iVar10;
              }
            }
          }
        }
      }
      else {
        puVar9 = puVar17 + 1;
      }
      goto LAB_0809ef90;
    }
    puVar9 = skip_comment(puVar17,eof);
    pbVar1 = local_28;
  } while( true );
LAB_0809fbb6:
  iVar4 = iVar11;
  if (iVar10 != -1) {
    iVar4 = iVar10;
  }
  if (iVar4 <= iVar16) goto LAB_0809fc5c;
  ptVar7 = new_cell(table_elinks_00,iVar16 + local_6c,local_74);
  if (ptVar7 == (table_cell *)0x0) goto abort;
  if ((ptVar7->field_0x3c & 1) != 0) goto LAB_0809fc36;
  iVar16 = iVar16 + 1;
  ptVar7->field_0x3c = ptVar7->field_0x3c | 3;
  ptVar7->colspan = iVar10;
  ptVar7->rowspan = local_64;
  ptVar7->col = local_6c;
  ptVar7->row = local_74;
  goto LAB_0809fbb6;
LAB_0809fc36:
  for (k = 0; iVar10 = iVar16, k < iVar16; k = k + 1) {
    table_elinks_00->cells[local_74 * table_elinks_00->real_cols + local_6c + k].colspan = iVar16;
  }
LAB_0809fc5c:
  iVar11 = local_64;
  if (local_64 == -1) {
    iVar11 = table_elinks_00->rows;
  }
  if (0x80000 < (uint)(iVar11 * iVar16)) goto abort;
  for (local_68 = 1; local_68 < iVar11; local_68 = local_68 + 1) {
    for (local_7c = 0; local_7c < iVar16; local_7c = local_7c + 1) {
      ptVar7 = new_cell(table_elinks_00,local_7c + local_6c,local_68 + local_74);
      if (ptVar7 == (table_cell *)0x0) goto abort;
      if ((ptVar7->field_0x3c & 1) != 0) {
        if ((ptVar7->col == local_6c) && (local_74 == ptVar7->row)) goto LAB_0809fdba;
        for (local_64 = 0; local_64 < local_7c; local_64 = local_64 + 1) {
          uVar14 = 0x40;
          ptVar19 = table_elinks_00->cells +
                    (local_68 + local_74) * table_elinks_00->real_cols + local_6c + local_64;
          bVar21 = ((uint)ptVar19 & 1) != 0;
          ptVar7 = ptVar19;
          if (bVar21) {
            ptVar7 = (table_cell *)((int)ptVar19 + (uint)bVar22 * -2 + 1);
            *(undefined *)&ptVar19->start = 0;
            uVar14 = 0x3f;
          }
          ptVar19 = ptVar7;
          if (((uint)ptVar7 & 2) != 0) {
            ptVar19 = (table_cell *)((int)ptVar7 + (uint)bVar22 * -4 + 2);
            *(undefined2 *)&ptVar7->start = 0;
            uVar14 = uVar14 - 2;
          }
          for (uVar18 = uVar14 >> 2; uVar18 != 0; uVar18 = uVar18 - 1) {
            ptVar19->start = (uchar *)0x0;
            ptVar19 = (table_cell *)((int)ptVar19 + (uint)bVar22 * -8 + 4);
          }
          ptVar7 = ptVar19;
          if ((uVar14 & 2) != 0) {
            ptVar7 = (table_cell *)((int)ptVar19 + (uint)bVar22 * -4 + 2);
            *(undefined2 *)&ptVar19->start = 0;
          }
          if (bVar21) {
            *(undefined *)&ptVar7->start = 0;
          }
        }
        for (iVar10 = 0; iVar10 < iVar16; iVar10 = iVar10 + 1) {
          for (iVar11 = 0; iVar11 < local_68; iVar11 = iVar11 + 1) {
            table_elinks_00->cells
            [(iVar11 + local_74) * table_elinks_00->real_cols + local_6c + iVar10].rowspan =
                 local_68;
          }
        }
        goto LAB_0809fd50;
      }
      ptVar7->field_0x3c = ptVar7->field_0x3c | 3;
      ptVar7->colspan = iVar10;
      ptVar7->rowspan = local_64;
      ptVar7->col = local_6c;
      ptVar7->row = local_74;
LAB_0809fdba:
    }
  }
LAB_0809fd50:
  bVar21 = true;
  pbVar1 = local_28;
  puVar9 = local_24;
  goto LAB_0809ef90;
}



// WARNING: Unknown calling convention

screen_char * realloc_line(document *document,int x,int y)

{
  line *plVar1;
  line *line;
  screen_char *psVar2;
  size_t newsize;
  uint uVar3;
  size_t size;
  size_t oldsize;
  uint uVar4;
  
  plVar1 = realloc_lines(document,y);
  if (plVar1 == (line *)0x0) {
LAB_080a01b0:
    psVar2 = (screen_char *)0x0;
  }
  else {
    if (plVar1->length != x) {
      uVar4 = plVar1->length + 0xfU & 0xfffffff0;
      uVar3 = x + 0xfU & 0xfffffff0;
      if (uVar4 < uVar3) {
        size = uVar3 * 8;
        psVar2 = (screen_char *)mem_realloc(plVar1->chars,size);
        if (psVar2 == (screen_char *)0x0) goto LAB_080a01b0;
        plVar1->chars = psVar2;
        memset(psVar2 + uVar4,0,size + uVar4 * -8);
      }
      if (plVar1->chars == (screen_char *)0x0) goto LAB_080a01b0;
      plVar1->length = x;
    }
    psVar2 = plVar1->chars;
  }
  return psVar2;
}



// WARNING: Unknown calling convention

void render_plain_document(cache_entry *cached,document *document,string *buffer)

{
  uchar uVar1;
  byte bVar2;
  color_T cVar3;
  bool bVar4;
  bool bVar5;
  document *document_00;
  document *pdVar6;
  uchar uVar7;
  uchar uVar8;
  uchar uVar9;
  uchar next_char;
  uchar *head;
  uchar *puVar11;
  conv_table *convert_table;
  uint uVar12;
  int iVar13;
  int step;
  ushort **ppuVar14;
  unicode_val_T uVar15;
  unicode_val_T data_1;
  byte bVar10;
  int iVar16;
  uchar *p;
  unicode_val_T data;
  int cell;
  int iVar17;
  int iVar18;
  screen_char *psVar19;
  screen_char *pos;
  screen_char *psVar20;
  node *node;
  unicode_val_T uVar21;
  void **ppvVar22;
  byte *pbVar23;
  byte *pbVar24;
  uri_errno uVar25;
  size_t newsize_1;
  point *point;
  global_history_item *pgVar26;
  bookmark *pbVar27;
  size_t size;
  link *plVar28;
  point *ppVar29;
  byte *pbVar30;
  int tab_width_1;
  document *document_1;
  uchar saved_char;
  byte bVar31;
  void *pvVar32;
  int width;
  int iVar33;
  int iVar34;
  int added_chars;
  int added;
  int iVar35;
  void *pvVar36;
  size_t newsize;
  int screen_column;
  uchar *puVar37;
  int line_pos;
  int tab_width;
  uint uVar38;
  int lineno;
  bool bVar39;
  uint local_124;
  int local_120;
  int local_108;
  uchar *local_fc;
  unicode_val_T local_d0;
  int local_cc;
  int local_c8;
  uint local_c4;
  int local_b8;
  int local_b4;
  int local_b0;
  screen_char *local_ac;
  uchar *local_a8;
  int local_a4;
  uri test;
  plain_renderer renderer;
  screen_char template;
  byte *local_28;
  int local_24;
  undefined4 local_20;
  
  puVar11 = cached->head;
  if (puVar11 == (uchar *)0x0) {
    puVar11 = "";
  }
  renderer.convert_table =
       get_convert_table(puVar11,(document->options).cp,(document->options).assume_cp,&document->cp,
                         &document->cp_status,(document->options).hard_assume);
  renderer.source = buffer->source;
  renderer.length = buffer->length;
  renderer.document = document;
  renderer.lineno = 0;
  bVar10 = (document->options).field_0x45;
  renderer._32_1_ = renderer._32_1_ & 0xfe | bVar10 >> 3 & 1;
  renderer.max_width = 0x7fffffff;
  if ((char)bVar10 < '\0') {
    renderer.max_width = (document->options).box.width;
  }
  cVar3 = (document->options).default_style.bg;
  document->width = 0;
  document->bgcolor = cVar3;
  uVar12 = is_cp_utf8((document->options).cp);
  (document->options).field_0x5c = (document->options).field_0x5c & 0xef | (byte)((uVar12 & 1) << 4)
  ;
  get_screen_char_template(&renderer.template,&document->options,(document->options).default_style);
  iVar33 = renderer.length;
  local_a8 = renderer.source;
  local_b8 = renderer.length;
  iVar13 = is_cp_utf8((renderer.document)->cp);
  if (0 < iVar33) {
    bVar39 = false;
    bVar5 = false;
    do {
      iVar35 = 0;
      iVar33 = 0;
      local_ac = (screen_char *)0x0;
      local_b0 = 0;
      local_b4 = 0;
      bVar4 = true;
LAB_080a039c:
      do {
        if (renderer.max_width <= iVar35) break;
        pbVar30 = local_a8 + iVar33;
        bVar10 = *pbVar30;
        local_c4 = (uint)(bVar10 == 0xd);
        if (local_a8[local_c4 + iVar33] == '\n') {
          local_c4 = local_c4 + 1;
LAB_080a04b9:
          if (!bVar4) {
            if (local_b0 == 0) {
              bVar39 = false;
              bVar5 = false;
              goto LAB_080a0508;
            }
            iVar33 = iVar33 - local_b0;
            local_c4 = local_c4 + local_b0;
            bVar39 = local_c4 == 0;
            bVar5 = false;
            goto LAB_080a0491;
          }
          if ((bVar5) || ((bVar39 && ((renderer._32_1_ & 1) != 0)))) {
            local_b8 = local_b8 - (local_b4 + local_c4);
            local_a8 = local_a8 + local_b4 + local_c4;
            renderer.lineno = renderer.lineno + -1;
            if ((assert_failed == 0) &&
               (assert_failed = -(renderer.lineno >> 0x1f), assert_failed != 0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
              errline = 0x237;
              elinks_internal((uchar *)"assertion renderer->lineno >= 0 failed!");
            }
            goto joined_r0x080a08e4;
          }
          local_a8 = local_a8 + local_b4;
          local_b8 = local_b8 - local_b4;
          iVar33 = iVar33 - local_b4;
          bVar39 = true;
          goto LAB_080a0508;
        }
        if (local_c4 != 0) {
          local_c4 = 1;
          goto LAB_080a04b9;
        }
        ppuVar14 = __ctype_b_loc();
        if ((*(byte *)((int)*ppuVar14 + (uint)bVar10 * 2 + 1) & 0x20) != 0) {
          local_ac = (screen_char *)iVar33;
          if (!bVar4) {
            local_b0 = local_b0 + 1;
            goto LAB_080a037c;
          }
          local_b4 = local_b4 + 1;
          bVar4 = true;
          if (iVar13 != 0) goto LAB_080a0426;
LAB_080a038a:
          iVar35 = iVar35 + 1;
          iVar33 = iVar33 + 1;
          if (local_b8 <= iVar33) break;
          goto LAB_080a039c;
        }
        local_b0 = 0;
        bVar4 = false;
LAB_080a037c:
        if (iVar13 == 0) goto LAB_080a038a;
LAB_080a0426:
        local_20 = pbVar30;
        uVar15 = utf8_to_unicode((uchar **)&local_20,local_a8 + local_b8);
        if (uVar15 == 0xfffffffd) {
          return;
        }
        iVar16 = unicode_to_cell(uVar15);
        iVar35 = iVar35 + iVar16;
        iVar16 = utf8charlen(pbVar30);
        iVar33 = iVar33 + iVar16;
      } while (iVar33 < local_b8);
      bVar39 = true;
      bVar5 = true;
      local_c4 = 0;
LAB_080a0491:
      if ((iVar33 < local_b8) && (bVar39)) {
        bVar39 = false;
        if (local_ac != (screen_char *)0x0) {
          iVar33 = (int)local_ac;
        }
        local_c4 = (uint)(local_ac != (screen_char *)0x0);
      }
      else {
        bVar39 = false;
      }
LAB_080a0508:
      if ((assert_failed == 0) && (assert_failed = -(iVar33 >> 0x1f), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
        errline = 0x251;
        elinks_internal((uchar *)"assertion width >= 0 failed!");
      }
      puVar11 = memacpy(local_a8,iVar33);
      iVar35 = renderer.lineno;
      uVar15 = renderer.template.data;
      document_00 = renderer.document;
      if (puVar11 != (uchar *)0x0) {
        uVar9 = renderer.template.color[1];
        uVar8 = renderer.template.color[0];
        uVar7 = renderer.template.attr;
        bVar10 = (byte)((renderer.document)->options).field_0x5c >> 4;
        local_24 = iVar33;
        p = convert_string_elinks
                      (renderer.convert_table,puVar11,iVar33,((renderer.document)->options).cp,
                       CSM_NONE,&local_24,(_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        if (p != (uchar *)0x0) {
          iVar16 = 0;
          local_b4 = 0;
          local_ac = (screen_char *)0x0;
LAB_080a0605:
          iVar18 = local_24;
          if (iVar16 < local_24) {
            do {
              iVar17 = 1;
              bVar31 = p[iVar16];
              local_a4 = 1;
              local_20 = (byte *)CONCAT31(local_20._1_3_,bVar31);
              if ((bVar10 & 1) != 0) {
                local_28 = p + iVar16;
                local_a4 = utf8charlen((uchar *)&local_20);
                uVar21 = utf8_to_unicode(&local_28,p + local_24);
                if (uVar21 == 0xfffffffd) goto code_r0x080a09c5;
                iVar17 = unicode_to_cell(uVar21);
                iVar18 = local_24;
                bVar31 = (byte)local_20;
              }
              if ((bVar31 == 9) && ((iVar16 + local_a4 == iVar18 || (p[iVar16 + local_a4] != '\b')))
                 ) {
                local_b4 = local_b4 + (~(local_b4 + (int)local_ac) & 7U);
              }
              iVar16 = iVar16 + local_a4;
              local_ac = (screen_char *)((int)local_ac + iVar17);
              if (iVar18 <= iVar16) break;
            } while( true );
          }
          if ((assert_failed == 0) && (assert_failed = -(local_b4 >> 0x1f), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
            errline = 0x12e;
            elinks_internal((uchar *)"assertion expanded >= 0 failed!");
            iVar18 = local_24;
          }
          psVar19 = realloc_line(document_00,iVar18 + local_b4,iVar35);
          if (psVar19 == (screen_char *)0x0) {
            mem_free(p);
            goto LAB_080a0ebd;
          }
          local_c8 = 0;
          local_a4 = 0;
          iVar16 = local_24;
          iVar18 = 0;
          local_ac = psVar19;
          if (0 < local_24) {
            do {
              pbVar30 = p + iVar18;
              local_20 = (byte *)CONCAT31(local_20._1_3_,*pbVar30);
              if ((bVar10 & 1) == 0) {
                local_d0 = 0xfffffffd;
                local_cc = 1;
                local_b4 = 1;
                bVar31 = *pbVar30;
LAB_080a0702:
                uVar1 = '\0';
                if (0 < iVar18) {
                  uVar1 = p[iVar18 + -1];
                }
                bVar2 = 0;
                iVar17 = local_b4 + iVar18;
                if (((iVar17 < iVar16) && (bVar2 = p[iVar17], bVar2 == 8)) || (bVar31 != 9)) {
                  if (bVar31 == 8) {
                    if (local_c8 + local_a4 != 0) {
                      psVar20 = local_ac + -1;
                      if (local_ac <= psVar19) {
                        psVar20 = local_ac;
                      }
                      local_ac = psVar20;
                      if ((bVar2 == 0x5f) && (uVar1 != '_')) {
                        if (-1 < iVar18 + -1) {
                          p[iVar18 + -1] = '_';
                          iVar16 = local_24;
                        }
                        if (iVar17 < iVar16) {
                          p[iVar17] = uVar1;
                          iVar16 = local_24;
                        }
                        iVar17 = iVar18;
                        if (-1 < iVar18 + -2) {
                          local_a4 = local_a4 + -1;
                          iVar17 = iVar18 + -1;
                        }
                        goto LAB_080a07df;
                      }
                      iVar34 = local_c8 + -2;
                      if (iVar18 + -2 + local_c8 < 0) {
                        iVar34 = local_c8;
                      }
                      uVar21 = psVar20->data;
                      if (bVar2 != 0x5f) {
                        if (uVar21 != 0x5f) goto LAB_080a0b6a;
                        bVar31 = renderer.template.attr | 0x20;
                        renderer.template._4_4_ = renderer.template._4_4_ | 0x20;
                      }
                      else {
                        if (uVar21 == 0x5f) {
                          if (((-1 < iVar18 + iVar34) && (psVar19 <= psVar20 + -1)) &&
                             (psVar20[-1].attr != 0)) {
                            renderer.template.attr = psVar20[-1].attr | renderer.template.attr;
                            bVar31 = renderer.template.attr;
                            goto LAB_080a0b7d;
                          }
                        }
                        else {
LAB_080a0b6a:
                          bVar31 = renderer.template.attr;
                          if (uVar21 != bVar2) goto LAB_080a0b7d;
                        }
                        bVar31 = renderer.template.attr | 8;
                        renderer.template._4_4_ = renderer.template._4_4_ | 8;
                      }
LAB_080a0b7d:
                      local_c8 = iVar34;
                      if (bVar31 != 0) {
                        renderer.template.attr = bVar31 | psVar20->attr;
                      }
                    }
                  }
                  else {
                    if (((document_00->options).field_0x45 & 4) == 0) {
LAB_080a0968:
                      if ((bVar10 & 1) == 0) {
                        if (((byte)local_20 == 0x7f) || ((byte)local_20 < 0x20)) {
                          local_20 = (byte *)CONCAT31(local_20._1_3_,0x2e);
                          renderer.template.data = 0x2e;
                        }
                        else {
                          renderer.template.data = (uint)local_20 & 0xff;
                        }
                        local_ac->data = renderer.template.data;
                        local_ac->attr = renderer.template.attr;
                        local_ac->color[0] = renderer.template.color[0];
                        local_ac->color[1] = renderer.template.color[1];
                        local_ac->field_0x7 = renderer.template._7_1_;
                        psVar20 = local_ac + 1;
                        if (assert_failed == 0) {
                          assert_failed = (int)((byte)local_20 == '\0');
                          if ((byte)local_20 == '\0') {
                            errfile = 
                            "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
                            errline = 0x1ce;
                            elinks_internal((uchar *)"assertion line_char failed!");
                          }
                        }
                      }
                      else {
                        iVar16 = local_24;
                        if (local_d0 == 0xfffffffd) goto LAB_080a07df;
                        psVar20 = local_ac + 1;
                        local_ac->attr = renderer.template.attr;
                        local_ac->color[0] = renderer.template.color[0];
                        local_ac->color[1] = renderer.template.color[1];
                        local_ac->field_0x7 = renderer.template._7_1_;
                        local_ac->data = local_d0;
                        if (local_cc == 2) {
                          psVar20 = local_ac + 2;
                          local_ac[1].data = 0xfffffffd;
                          local_ac[1].attr = renderer.template.attr;
                          local_ac[1].color[0] = renderer.template.color[0];
                          local_ac[1].color[1] = renderer.template.color[1];
                          local_ac[1].field_0x7 = renderer.template._7_1_;
                        }
                      }
                    }
                    else {
                      ppuVar14 = __ctype_b_loc();
                      pdVar6 = renderer.document;
                      if (((*(byte *)((int)*ppuVar14 + (uint)bVar31 * 2 + 1) & 4) == 0) ||
                         ((*(byte *)((int)*ppuVar14 + (uint)bVar2 * 2 + 1) & 4) == 0))
                      goto LAB_080a0968;
                      if (((iVar16 - iVar18 < 1) ||
                          (((((bVar31 = *pbVar30, bVar31 == 0x3c || (bVar31 < 0x21)) ||
                             (bVar31 == 0x3e)) || ((bVar31 == 0x28 || (bVar31 == 0x29)))) ||
                           (bVar31 == 0x22)))) || (bVar31 == 0x27)) {
LAB_080a0e3d:
                        template.data = renderer.template.data;
                        template.attr = renderer.template.attr;
                        template.color[0] = renderer.template.color[0];
                        template.color[1] = renderer.template.color[1];
                        template._7_1_ = renderer.template._7_1_;
                        goto LAB_080a0968;
                      }
                      local_124 = 0;
                      do {
                        uVar12 = local_124;
                        local_124 = uVar12 + 1;
                        if (iVar16 - iVar18 <= (int)local_124) goto LAB_080a0dfd;
                        bVar31 = pbVar30[local_124];
                      } while ((((bVar31 != 0x3c) && (0x20 < bVar31)) &&
                               ((bVar31 != 0x3e &&
                                (((bVar31 != 0x28 && (bVar31 != 0x29)) && (bVar31 != 0x27)))))) &&
                              (bVar31 != 0x22));
                      if ((int)local_124 < 1) {
                        template.data = renderer.template.data;
                        template.attr = renderer.template.attr;
                        template.color[0] = renderer.template.color[0];
                        template.color[1] = renderer.template.color[1];
                        template._7_1_ = renderer.template._7_1_;
                        if (local_124 == 0) goto LAB_080a0968;
                      }
                      else {
LAB_080a0dfd:
                        if ((pbVar30[uVar12] == 0x2e) || (pbVar30[uVar12] == 0x2c)) {
                          pbVar23 = pbVar30 + local_124;
                          do {
                            local_124 = local_124 - 1;
                            if (local_124 == 0) goto LAB_080a0e3d;
                            pbVar24 = pbVar23 + -2;
                            pbVar23 = pbVar23 + -1;
                          } while ((*pbVar24 == 0x2c) || (*pbVar24 == 0x2e));
                        }
                      }
                      local_108 = local_124 + iVar18;
                      local_120 = local_c8 + local_a4;
                      template.attr = renderer.template.attr;
                      template.color[0] = renderer.template.color[0];
                      template.color[1] = renderer.template.color[1];
                      template._7_1_ = renderer.template._7_1_;
                      template.data = renderer.template.data;
                      pbVar24 = (byte *)memchr(pbVar30,0x40,local_124);
                      pbVar23 = pbVar30 + local_124;
                      bVar31 = *pbVar23;
                      if (assert_failed != 0) {
LAB_080a135a:
                        assert_failed = 0;
                        goto LAB_080a0968;
                      }
                      assert_failed = (int)(pdVar6 == (document *)0x0);
                      if (assert_failed != 0) {
                        errfile = 
                        "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
                        errline = 0x79;
                        elinks_internal((uchar *)"assertion document failed!");
                        if (assert_failed != 0) goto LAB_080a135a;
                      }
                      *pbVar23 = 0;
                      if (((pbVar30 < pbVar24) && (pbVar24 != (byte *)0x0)) &&
                         ((int)pbVar24 - (int)pbVar30 < (int)(local_124 - 1))) {
                        local_fc = straconcat((uchar *)"mailto:",pbVar30,0);
                      }
                      else {
                        uVar25 = parse_uri(&test,pbVar30);
                        if (((uVar25 != URI_ERRNO_OK) || (test.protocol == 0x12)) ||
                           (((test._48_4_ & 0xffff00) == 0 && (test._46_2_ == 0)))) {
                          *pbVar23 = bVar31;
                          goto LAB_080a0968;
                        }
                        local_fc = memacpy(pbVar30,local_124);
                      }
                      *pbVar23 = bVar31;
                      if (local_fc == (uchar *)0x0) goto LAB_080a0968;
                      normalize_uri((uri *)0x0,local_fc);
                      uVar12 = pdVar6->nlinks + 0x80U & 0xffffff80;
                      uVar38 = pdVar6->nlinks + 0x7fU & 0xffffff80;
                      if (uVar38 < uVar12) {
                        size = uVar12 * 0x34;
                        plVar28 = (link *)mem_realloc(pdVar6->links,size);
                        if (plVar28 != (link *)0x0) {
                          pdVar6->links = plVar28;
                          memset(plVar28 + uVar38,0,size + uVar38 * -0x34);
                          goto LAB_080a112f;
                        }
LAB_080a1377:
                        mem_free(local_fc);
                        goto LAB_080a0968;
                      }
LAB_080a112f:
                      plVar28 = pdVar6->links;
                      if (plVar28 == (link *)0x0) goto LAB_080a1377;
                      iVar16 = pdVar6->nlinks;
                      uVar12 = plVar28[iVar16].npoints;
                      if (uVar12 < local_124) {
                        ppVar29 = (point *)mem_realloc(plVar28[iVar16].points,local_124 * 8);
                        if (ppVar29 == (point *)0x0) goto LAB_080a1377;
                        plVar28[iVar16].points = ppVar29;
                        memset(ppVar29 + uVar12,0,local_124 * 8 + uVar12 * -8);
                      }
                      if (plVar28[iVar16].points == (point *)0x0) goto LAB_080a1377;
                      plVar28[iVar16].type = LINK_HYPERTEXT;
                      plVar28[iVar16].npoints = local_124;
                      plVar28[iVar16].where = local_fc;
                      plVar28[iVar16].color.background = (pdVar6->options).default_style.bg;
                      plVar28[iVar16].color.foreground = (pdVar6->options).default_link;
                      plVar28[iVar16].number = pdVar6->nlinks;
                      ppVar29 = plVar28[iVar16].points;
                      uVar12 = local_124;
                      if (0 < (int)local_124) {
                        do {
                          ppVar29->x = local_120;
                          local_120 = local_120 + 1;
                          ppVar29->y = iVar35;
                          ppVar29 = ppVar29 + 1;
                          uVar12 = uVar12 - 1;
                        } while (uVar12 != 0);
                      }
                      pdVar6->nlinks = pdVar6->nlinks + 1;
                      pdVar6->field_0x114 = pdVar6->field_0x114 & 0xfe;
                      puVar37 = p + local_108;
                      uVar1 = *puVar37;
                      *puVar37 = '\0';
                      pgVar26 = get_global_history_item(pbVar30);
                      if (pgVar26 == (global_history_item *)0x0) {
                        pbVar27 = get_bookmark(pbVar30);
                        if (pbVar27 == (bookmark *)0x0) {
                          plVar28[iVar16].color.foreground = (pdVar6->options).default_link;
                        }
                        else {
                          plVar28[iVar16].color.foreground = (pdVar6->options).default_bookmark_link
                          ;
                        }
                      }
                      else {
                        plVar28[iVar16].color.foreground = (pdVar6->options).default_vlink;
                      }
                      *puVar37 = uVar1;
                      plVar28[iVar16].color.background = (pdVar6->options).default_style.bg;
                      set_term_color(&template,&plVar28[iVar16].color,(pdVar6->options).color_flags,
                                     (pdVar6->options).color_mode);
                      uVar12 = 0;
                      do {
                        uVar38 = uVar12;
                        template.data = (unicode_val_T)*pbVar30;
                        pbVar30 = pbVar30 + 1;
                        psVar20 = local_ac + uVar38;
                        psVar20->attr = template.attr;
                        psVar20->color[0] = template.color[0];
                        psVar20->color[1] = template.color[1];
                        psVar20->field_0x7 = template._7_1_;
                        local_ac[uVar38].data = template.data;
                        uVar12 = uVar38 + 1;
                      } while (uVar12 != local_124);
                      local_a4 = local_a4 + uVar38;
                      psVar20 = local_ac + uVar12;
                      iVar17 = local_b4 + iVar18 + uVar38;
                    }
                    renderer.template._6_2_ = (uchar  [2])CONCAT11(renderer.template._7_1_,uVar9);
                    renderer.template._5_3_ = CONCAT21(renderer.template._6_2_,uVar8);
                    renderer.template._4_4_ = CONCAT31(renderer.template._5_3_,uVar7);
                    iVar16 = local_24;
                    local_ac = psVar20;
                    renderer.template.data = uVar15;
                  }
                }
                else {
                  tab_width = local_c8 + local_a4;
                  uVar38 = ~tab_width & 7;
                  psVar20 = local_ac;
                  uVar12 = uVar38;
                  do {
                    uVar12 = uVar12 - 1;
                    psVar20->data = 0x20;
                    psVar20->attr = renderer.template.attr;
                    psVar20->color[0] = renderer.template.color[0];
                    psVar20->color[1] = renderer.template.color[1];
                    psVar20->field_0x7 = renderer.template._7_1_;
                    psVar20 = psVar20 + 1;
                  } while (uVar12 != 0xffffffff);
                  renderer.template._6_2_ = (uchar  [2])CONCAT11(renderer.template._7_1_,uVar9);
                  renderer.template._5_3_ = CONCAT21(renderer.template._6_2_,uVar8);
                  renderer.template._4_4_ = CONCAT31(renderer.template._5_3_,uVar7);
                  iVar16 = local_24;
                  local_c8 = local_c8 + uVar38;
                  local_ac = local_ac + uVar38 + 1;
                  renderer.template.data = uVar15;
                }
                local_a4 = local_a4 + local_cc;
              }
              else {
                local_28 = pbVar30;
                local_b4 = utf8charlen((uchar *)&local_20);
                local_d0 = utf8_to_unicode(&local_28,p + local_24);
                if (local_d0 != 0xfffffffd) {
                  local_cc = unicode_to_cell(local_d0);
                  iVar16 = local_24;
                  bVar31 = (byte)local_20;
                  goto LAB_080a0702;
                }
                iVar16 = local_24;
                iVar17 = local_b4 + iVar18;
              }
LAB_080a07df:
              iVar18 = iVar17;
            } while (iVar17 < iVar16);
          }
          mem_free(p);
          realloc_line(document_00,(int)local_ac - (int)psVar19 >> 3,iVar35);
          pvVar36 = (void *)(local_c8 + local_24);
          mem_free(puVar11);
          if ((pvVar36 != (void *)0x0) &&
             (ppvVar22 = (void **)mem_alloc(0x18), ppvVar22 != (void **)0x0)) {
            ppvVar22[2] = (void *)0x0;
            ppvVar22[5] = (void *)0x1;
            pvVar32 = (void *)renderer.lineno;
            if (renderer.lineno < 0) {
              pvVar32 = (void *)0x0;
            }
            ppvVar22[3] = pvVar32;
            pvVar32 = (void *)0x0;
            if (-1 < (int)pvVar36) {
              pvVar32 = pvVar36;
            }
            ppvVar22[4] = pvVar32;
            if ((renderer.document)->width < (int)pvVar36) {
              (renderer.document)->width = (int)pvVar36;
              iVar35 = (renderer.document)->height;
            }
            else {
              iVar35 = (renderer.document)->height;
            }
            if (iVar35 < 1) {
              (renderer.document)->height = 1;
            }
            pvVar36 = ((renderer.document)->nodes).next;
            ppvVar22[1] = &(renderer.document)->nodes;
            *ppvVar22 = pvVar36;
            ((renderer.document)->nodes).next = ppvVar22;
            *(void ***)((int)*ppvVar22 + 4) = ppvVar22;
          }
          goto LAB_080a083a;
        }
LAB_080a0ebd:
        mem_free(puVar11);
LAB_080a083a:
        local_b8 = local_b8 - (iVar33 + local_c4);
        local_a8 = local_a8 + iVar33 + local_c4;
      }
joined_r0x080a08e4:
      renderer.lineno = renderer.lineno + 1;
    } while (0 < local_b8);
  }
  if ((assert_failed == 0) && (assert_failed = (int)(local_b8 != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
    errline = 0x265;
    elinks_internal((uchar *)"assertion !length failed!");
  }
  return;
code_r0x080a09c5:
  iVar16 = iVar16 + local_a4;
  goto LAB_080a0605;
}



// WARNING: Unknown calling convention

dom_config_flag parse_dom_config(uchar *flaglist,uchar separator)

{
  size_t sVar1;
  size_t sVar2;
  size_t n;
  int iVar3;
  dom_config_flag dVar4;
  int length;
  dom_config_info *pdVar5;
  int i;
  int iVar6;
  dom_config_flag local_24;
  char *local_20;
  
  local_24 = 0;
  if (flaglist != (uchar *)0x0) {
    do {
      if (separator == '\0') {
LAB_080a1602:
        sVar2 = strlen((char *)flaglist);
        local_20 = (char *)0x0;
      }
      else {
        local_20 = strchr((char *)flaglist,(uint)separator);
        if (local_20 == (char *)0x0) goto LAB_080a1602;
        sVar2 = (int)local_20 - (int)flaglist;
      }
      pdVar5 = dom_config_info;
      iVar6 = 0;
      do {
        sVar1 = (pdVar5->name).length;
        n = sVar1;
        if ((int)sVar2 <= (int)sVar1) {
          n = sVar2;
        }
        iVar3 = c_strncasecmp((char *)(pdVar5->name).string,(char *)flaglist,n);
        if ((iVar3 == 0) && (sVar2 == sVar1)) {
          dVar4 = dom_config_info[iVar6].flag;
          goto LAB_080a165a;
        }
        iVar6 = iVar6 + 1;
        pdVar5 = pdVar5 + 1;
      } while (iVar6 != 7);
      dVar4 = 0;
LAB_080a165a:
      local_24 = local_24 | dVar4;
    } while ((local_20 != (char *)0x0) &&
            (flaglist = (uchar *)(local_20 + 1), flaglist != (uchar *)0x0));
  }
  return local_24;
}



// WARNING: Unknown calling convention

dom_config * add_dom_config_normalizer(dom_stack *stack,dom_config *config,dom_config_flag flags)

{
  dom_stack_context *pdVar1;
  
  config->error_handler = (_func_void_dom_config_ptr_dom_error_ptr *)0x0;
  config->flags = flags;
  pdVar1 = add_dom_stack_context(stack,config,&dom_config_normalizer_context);
  if (pdVar1 == (dom_stack_context *)0x0) {
    config = (dom_config *)0x0;
  }
  return config;
}



// WARNING: Unknown calling convention

dom_code normalize_text_node_whitespace(dom_node *node)

{
  int iVar1;
  uchar *puVar2;
  bool bVar3;
  ushort **ppuVar4;
  uchar *puVar5;
  dom_code dVar6;
  byte bVar7;
  uint uVar8;
  int i;
  int j;
  uint __n;
  uchar data;
  int in_GS_OFFSET;
  uchar *local_140;
  uint local_13c;
  uchar buf [256];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  puVar2 = (node->string).string;
  if ((assert_failed == 0) && (assert_failed = (int)(node->type != 3), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/configuration.c";
    errline = 0x17;
    elinks_internal((uchar *)"assertion node->type == DOM_NODE_TEXT failed!");
  }
  uVar8 = 0;
  local_13c = 0;
  local_140 = (uchar *)0x0;
  bVar3 = false;
  if ((node->string).length != 0) {
    do {
      ppuVar4 = __ctype_b_loc();
      __n = 0;
      do {
        bVar7 = puVar2[uVar8];
        if ((*(byte *)((int)*ppuVar4 + (uint)bVar7 * 2 + 1) & 0x20) == 0) {
          bVar3 = false;
LAB_080a17a2:
          buf[__n] = bVar7;
          __n = __n + 1;
        }
        else if (!bVar3) {
          bVar7 = 0x20;
          bVar3 = true;
          goto LAB_080a17a2;
        }
        uVar8 = uVar8 + 1;
      } while ((__n < 0x100) && (uVar8 <= (node->string).length && (node->string).length != uVar8));
      puVar5 = (uchar *)mem_realloc(local_140,local_13c + 1 + __n);
      if (puVar5 == (uchar *)0x0) {
        dVar6 = DOM_CODE_ALLOC_ERR;
        if (local_140 != (uchar *)0x0) {
          mem_free(local_140);
          dVar6 = DOM_CODE_ALLOC_ERR;
        }
        goto LAB_080a18f2;
      }
      memcpy(puVar5 + local_13c,buf,__n);
      local_13c = local_13c + __n;
      puVar5[local_13c] = '\0';
      local_140 = puVar5;
    } while (uVar8 < (node->string).length);
  }
  bVar7 = node->field_0x2;
  if ((bVar7 & 1) != 0) {
    puVar2 = (node->string).string;
    if (puVar2 != (uchar *)0x0) {
      mem_free(puVar2);
      bVar7 = node->field_0x2;
    }
    (node->string).string = (uchar *)0x0;
    (node->string).length = 0;
  }
  (node->string).string = local_140;
  if (local_13c == 0xffffffff) {
    local_13c = strlen((char *)local_140);
  }
  (node->string).length = local_13c;
  dVar6 = DOM_CODE_OK;
  node->field_0x2 = bVar7 | 1;
LAB_080a18f2:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return dVar6;
}



// WARNING: Unknown calling convention

dom_code dom_normalize_text(dom_stack *stack,dom_node *node,void *data)

{
  dom_code dVar1;
  
                    // WARNING: Load size is inaccurate
  if ((*stack->current->data & 0x40) == 0) {
    return DOM_CODE_OK;
  }
  dVar1 = normalize_text_node_whitespace(node);
  return dVar1;
}



// WARNING: Unknown calling convention

dom_code append_node_text(dom_config *config,dom_node *node)

{
  int iVar1;
  ushort uVar2;
  uint16_t uVar3;
  uchar *__src;
  size_t __n;
  dom_node *node_00;
  uchar *puVar4;
  uchar *p;
  size_t sVar5;
  int iVar6;
  dom_node *prev;
  uchar *__s;
  size_t local_20;
  
  node_00 = get_dom_node_prev(node);
  __src = (node->string).string;
  __n = (node->string).length;
  if ((node_00 == (dom_node *)0x0) || (node_00->type != 3)) {
    if (node->type == 3) {
      return DOM_CODE_OK;
    }
    __s = (uchar *)0x0;
    local_20 = 0;
    node_00 = (dom_node *)0x0;
  }
  else if ((node_00->field_0x2 & 1) == 0) {
    local_20 = (node_00->string).length;
    puVar4 = (node_00->string).string;
    __s = (uchar *)mem_realloc((void *)0x0,local_20 + 1);
    if (__s == (uchar *)0x0) {
      return DOM_CODE_ALLOC_ERR;
    }
    memcpy(__s,puVar4,local_20);
    __s[local_20] = '\0';
    (node_00->string).string = __s;
    sVar5 = local_20;
    if (local_20 == 0xffffffff) {
      sVar5 = strlen((char *)__s);
    }
    (node_00->string).length = sVar5;
    node_00->field_0x2 = node_00->field_0x2 | 1;
  }
  else {
    local_20 = (node_00->string).length;
    __s = (node_00->string).string;
  }
  uVar2 = node->type;
  if (2 < uVar2) {
    if (uVar2 < 5) {
      puVar4 = (uchar *)mem_realloc(__s,local_20 + 1 + __n);
      if (puVar4 == (uchar *)0x0) {
LAB_080a1bb0:
        if (node_00 != (dom_node *)0x0) {
          (node_00->string).length = local_20;
          return DOM_CODE_ALLOC_ERR;
        }
        if (__s == (uchar *)0x0) {
          return DOM_CODE_ALLOC_ERR;
        }
        mem_free(__s);
        return DOM_CODE_ALLOC_ERR;
      }
      memcpy(puVar4 + local_20,__src,__n);
      local_20 = __n + local_20;
      puVar4[local_20] = '\0';
      goto joined_r0x080a1aff;
    }
    if (uVar2 == 5) {
      puVar4 = (uchar *)mem_realloc(__s,local_20 + 2);
      if (puVar4 != (uchar *)0x0) {
        puVar4[local_20] = '&';
        iVar6 = local_20 + 1;
        puVar4[iVar6] = '\0';
        iVar1 = __n + iVar6;
        p = (uchar *)mem_realloc(puVar4,iVar1 + 1U);
        __s = puVar4;
        if (p != (uchar *)0x0) {
          memcpy(p + iVar6,__src,__n);
          p[iVar1] = '\0';
          puVar4 = (uchar *)mem_realloc(p,iVar1 + 2);
          __s = p;
          if (puVar4 != (uchar *)0x0) {
            puVar4[iVar1] = ';';
            puVar4[iVar1 + 1] = '\0';
            local_20 = iVar1 + 1U;
            goto joined_r0x080a1aff;
          }
        }
      }
      goto LAB_080a1bb0;
    }
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/configuration.c";
  errline = 0x72;
  elinks_internal((uchar *)"Cannot append from node %d",(uint)node->type);
  puVar4 = __s;
joined_r0x080a1aff:
  if (node_00 != (dom_node *)0x0) {
    (node_00->string).length = local_20;
    (node_00->string).string = puVar4;
    if (((*(byte *)&config->flags & 0x40) != 0) && (node->type != 5)) {
      normalize_text_node_whitespace(node_00);
      return DOM_CODE_FREE_NODE;
    }
    return DOM_CODE_FREE_NODE;
  }
  uVar3 = node->type;
  (node->data).document.document = (dom_document *)0x0;
  node->type = 3;
  (node->data).document.children = (dom_node_list *)0x0;
  (node->data).document_type.subset = (dom_doctype_subset_infot *)0x0;
  (node->data).notation.system_id.string = (uchar *)0x0;
  node->field_0x2 = node->field_0x2 | 1;
  (node->string).length = local_20;
  (node->string).string = puVar4;
  if (((*(byte *)&config->flags & 0x40) != 0) && (uVar3 == 4)) {
    normalize_text_node_whitespace(node);
    return DOM_CODE_OK;
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code dom_normalize_node_end(dom_stack *stack,dom_node *node,void *data)

{
  uint16_t uVar1;
  dom_config *config_00;
  byte bVar2;
  dom_config *config;
  dom_code code;
  dom_code dVar3;
  
  config_00 = (dom_config *)stack->current->data;
  switch(node->type) {
  default:
    goto LAB_080a1cba;
  case 1:
  case 2:
    if ((*(byte *)&config_00->flags & 0x20) == 0) {
      code = DOM_CODE_OK;
      return code;
    }
    uVar1 = (node->data).element.type;
    break;
  case 3:
    if (((*(byte *)&config_00->flags & 4) == 0) && ((*(byte *)((int)&node->data + 4) & 1) != 0)) {
      return DOM_CODE_FREE_NODE;
    }
    goto LAB_080a1ce2;
  case 4:
    bVar2 = *(byte *)&config_00->flags & 1;
    goto joined_r0x080a1d00;
  case 5:
    bVar2 = *(byte *)&config_00->flags & 8;
joined_r0x080a1d00:
    if (bVar2 != 0) {
      code = DOM_CODE_OK;
      return code;
    }
LAB_080a1ce2:
    dVar3 = append_node_text(config_00,node);
    return dVar3;
  case 7:
    if ((*(byte *)&config_00->flags & 0x20) == 0) {
      code = DOM_CODE_OK;
      return code;
    }
    uVar1 = (node->data).element.namespace_offset;
    break;
  case 8:
    if ((*(byte *)&config_00->flags & 2) == 0) {
      return DOM_CODE_FREE_NODE;
    }
    goto LAB_080a1cba;
  }
  if (uVar1 == 0) {
    return DOM_CODE_FREE_NODE;
  }
LAB_080a1cba:
  code = DOM_CODE_OK;
  return code;
}



// WARNING: Unknown calling convention

dom_string * get_dom_node_type_name(dom_node_type type)

{
  if ((assert_failed == 0) && (assert_failed = (int)(DOM_NODE_NOTATION < type), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x24b;
    elinks_internal((uchar *)"assertion type < DOM_NODES failed!");
    return get_dom_node_type_name::dom_node_type_names + type;
  }
  return get_dom_node_type_name::dom_node_type_names + type;
}



// WARNING: Unknown calling convention

dom_string * get_dom_node_value(dom_node *node)

{
  ushort uVar1;
  dom_string *pdVar2;
  
  if ((assert_failed == 0) && (assert_failed = (int)(node == (dom_node *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x21e;
    elinks_internal((uchar *)"assertion node failed!");
    uVar1 = node->type;
  }
  else {
    uVar1 = node->type;
  }
  if (8 < uVar1) {
    return (dom_string *)0x0;
  }
                    // WARNING: Could not recover jumptable at 0x080a1ddb. Too many branches
                    // WARNING: Treating indirect jump as call
  pdVar2 = (dom_string *)(**(code **)(&DAT_081020b4 + (uint)node->type * 4))();
  return pdVar2;
}



// WARNING: Unknown calling convention

dom_string * get_dom_node_name(dom_node *node)

{
  if ((assert_failed == 0) && (assert_failed = (int)(node == (dom_node *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x1fd;
    elinks_internal((uchar *)"assertion node failed!");
  }
  switch(node->type) {
  case 3:
    return &get_dom_node_name::text_str;
  case 4:
    return &get_dom_node_name::cdata_section_str;
  default:
    return &node->string;
  case 8:
    return &get_dom_node_name::comment_str;
  case 9:
    return &get_dom_node_name::document_str;
  case 0xb:
    return &get_dom_node_name::document_fragment_str;
  }
}



// WARNING: Unknown calling convention

int get_dom_node_list_pos(dom_node_list *list,dom_node *node)

{
  uint uVar1;
  int i;
  dom_node *entry;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = (int)(list == (dom_node_list *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0xeb;
    elinks_internal((uchar *)"assertion list failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  if (list->size != 0) {
    uVar1 = 0;
    do {
      if ((list->entries[uVar1] != (dom_node *)0x0) && (list->entries[uVar1] == node)) {
        return uVar1;
      }
      uVar1 = uVar1 + 1;
    } while (uVar1 < list->size);
  }
  return -1;
}



// WARNING: Unknown calling convention

dom_node * get_dom_node_prev(dom_node *node)

{
  uint16_t uVar1;
  ushort uVar2;
  dom_node *pdVar3;
  int iVar4;
  int index;
  dom_node_list **list;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (dom_node *)0x0;
  }
  assert_failed = (int)(node->parent == (dom_node *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x104;
    elinks_internal((uchar *)"assertion node->parent failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  pdVar3 = node->parent;
  uVar1 = node->type;
  uVar2 = pdVar3->type;
  if (uVar2 == 7) {
    if (uVar1 != 2) {
      return (dom_node *)0x0;
    }
    list = &(pdVar3->data).proc_instruction.map;
  }
  else if (uVar2 < 8) {
    if (uVar2 != 1) {
      return (dom_node *)0x0;
    }
    list = (dom_node_list **)&pdVar3->data;
    if (uVar1 == 2) {
      list = &(pdVar3->data).document.children;
    }
  }
  else {
    if (uVar2 != 9) {
      if (uVar2 != 10) {
        return (dom_node *)0x0;
      }
      if (uVar1 == 6) {
        list = (dom_node_list **)&pdVar3->data;
        goto LAB_080a2019;
      }
      if (uVar1 != 0xc) {
        return (dom_node *)0x0;
      }
    }
    list = &(pdVar3->data).document.children;
  }
LAB_080a2019:
  if (list == (dom_node_list **)0x0) {
    return (dom_node *)0x0;
  }
  assert_failed = (int)(*list == (dom_node_list *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x10c;
    elinks_internal((uchar *)"assertion *list failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  iVar4 = get_dom_node_list_pos(*list,node);
  if (assert_failed != 0) {
    assert_failed = 0;
    return (dom_node *)0x0;
  }
  assert_failed = -(iVar4 >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x110;
    elinks_internal((uchar *)"assertion index >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  if (0 < iVar4) {
    return (*list)->entries[iVar4 + -1];
  }
  return (dom_node *)0x0;
}



// WARNING: Unknown calling convention

void del_from_dom_node_list(dom_node_list *list,dom_node *node)

{
  dom_node_list *pdVar1;
  size_t successors;
  dom_node *entry;
  uint uVar2;
  uint uVar3;
  
  if ((list != (dom_node_list *)0x0) && (uVar3 = list->size, uVar3 != 0)) {
    uVar2 = 1;
    pdVar1 = list;
    while( true ) {
      if ((list->entries[uVar2 - 1] != (dom_node *)0x0) && (list->entries[uVar2 - 1] == node)) {
        if (uVar3 - uVar2 != 0) {
          memmove(pdVar1->entries,pdVar1 + 1,(uVar3 - uVar2) * 4);
          uVar3 = list->size;
        }
        uVar3 = uVar3 - 1;
        list->size = uVar3;
      }
      if (uVar3 <= uVar2) break;
      uVar2 = uVar2 + 1;
      pdVar1 = (dom_node_list *)pdVar1->entries;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void done_dom_node_data(dom_node *node)

{
  ushort uVar1;
  uchar *p;
  dom_node_list *pdVar2;
  byte bVar3;
  
  if (assert_failed == 0) {
    assert_failed = (int)(node == (dom_node *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 0x19e;
      elinks_internal((uchar *)"assertion node failed!");
      if (assert_failed != 0) goto LAB_080a223d;
    }
    assert_failed = (int)(0xc < node->type);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 0x19f;
      elinks_internal((uchar *)"assertion node->type < DOM_NODES failed!");
    }
  }
LAB_080a223d:
  uVar1 = node->type;
  if (uVar1 == 2) {
LAB_080a22cf:
    bVar3 = node->field_0x2;
    if ((bVar3 & 1) == 0) goto LAB_080a227f;
    pdVar2 = (node->data).document.children;
    if (pdVar2 != (dom_node_list *)0x0) {
      mem_free(pdVar2);
      bVar3 = node->field_0x2;
    }
    (node->data).document.children = (dom_node_list *)0x0;
    (node->data).document.document = (dom_document *)0x0;
  }
  else if (uVar1 < 3) {
    if (uVar1 == 1) {
      pdVar2 = (node->data).document_type.entities;
      if (pdVar2 != (dom_node_list *)0x0) {
        done_dom_node_list(pdVar2);
      }
      pdVar2 = (node->data).document.children;
      if (pdVar2 != (dom_node_list *)0x0) {
        done_dom_node_list(pdVar2);
      }
    }
LAB_080a2256:
    bVar3 = node->field_0x2;
  }
  else {
    if (uVar1 == 7) {
      pdVar2 = (node->data).proc_instruction.map;
      if (pdVar2 != (dom_node_list *)0x0) {
        done_dom_node_list(pdVar2);
      }
      goto LAB_080a22cf;
    }
    if ((uVar1 != 9) || (pdVar2 = (node->data).document.children, pdVar2 == (dom_node_list *)0x0))
    goto LAB_080a2256;
    done_dom_node_list(pdVar2);
    bVar3 = node->field_0x2;
  }
  if ((bVar3 & 1) != 0) {
    p = (node->string).string;
    if (p != (uchar *)0x0) {
      mem_free(p);
    }
    (node->string).string = (uchar *)0x0;
    (node->string).length = 0;
  }
LAB_080a227f:
  node->type = 0xffff;
  mem_free(node);
  return;
}



// WARNING: Unknown calling convention

void done_dom_node_list(dom_node_list *list)

{
  dom_node *node;
  uint uVar1;
  int i;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(list == (dom_node_list *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x71;
    elinks_internal((uchar *)"assertion list failed!");
  }
  if (list->size != 0) {
    uVar1 = 0;
    do {
      if (list->entries[uVar1] != (dom_node *)0x0) {
        done_dom_node_data(list->entries[uVar1]);
      }
      uVar1 = uVar1 + 1;
    } while (uVar1 <= list->size && list->size != uVar1);
  }
  mem_free(list);
  return;
}



// WARNING: Unknown calling convention

void done_dom_node(dom_node *node)

{
  uint16_t uVar1;
  dom_node *pdVar2;
  
  if ((assert_failed == 0) && (assert_failed = (int)(node == (dom_node *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x1d5;
    elinks_internal((uchar *)"assertion node failed!");
  }
  pdVar2 = node->parent;
  if (pdVar2 != (dom_node *)0x0) {
    uVar1 = pdVar2->type;
    if (uVar1 == 7) {
      del_from_dom_node_list((pdVar2->data).proc_instruction.map,node);
      done_dom_node_data(node);
      return;
    }
    if (uVar1 != 9) {
      if (uVar1 != 1) goto LAB_080a2452;
      del_from_dom_node_list((pdVar2->data).document_type.entities,node);
    }
    del_from_dom_node_list((pdVar2->data).document.children,node);
    done_dom_node_data(node);
    return;
  }
LAB_080a2452:
  done_dom_node_data(node);
  return;
}



// WARNING: Unknown calling convention

int dom_node_casecmp(dom_node *node1,dom_node *node2)

{
  uint16_t uVar1;
  ushort uVar2;
  ushort uVar3;
  size_t sVar4;
  size_t n;
  int iVar5;
  
  uVar1 = node1->type;
  if (((uVar1 == node2->type) &&
      (((uVar1 == 1 || (uVar1 == 2)) && (uVar2 = (node1->data).element.type, uVar2 != 0)))) &&
     (uVar3 = (node2->data).element.type, uVar3 != 0)) {
    iVar5 = (uint)uVar2 - (uint)uVar3;
  }
  else {
    n = (node2->string).length;
    sVar4 = (node1->string).length;
    if ((int)sVar4 <= (int)n) {
      n = sVar4;
    }
    iVar5 = c_strncasecmp((char *)(node1->string).string,(char *)(node2->string).string,n);
    if (iVar5 == 0) {
      iVar5 = (node1->string).length - (node2->string).length;
    }
  }
  return iVar5;
}



// WARNING: Unknown calling convention

dom_node *
get_dom_node_map_entry(dom_node_list *list,dom_node_type type,uint16_t subtype,dom_string *name)

{
  dom_node *node2;
  undefined2 uVar1;
  uint uVar2;
  int iVar3;
  int difference;
  dom_node *node_1;
  uint uVar4;
  int pos;
  uint uVar5;
  dom_node node;
  
  node.string.length = name->length;
  node.string.string = name->string;
  uVar2 = 0;
  do {
    *(undefined4 *)((int)&node.type + uVar2) = 0;
    uVar2 = uVar2 + 4;
  } while (uVar2 < 0x20);
  node.type = (uint16_t)type;
  uVar2 = list->size;
  uVar1 = node.data.element.namespace_offset;
  if ((subtype != 0) &&
     ((type == DOM_NODE_ATTRIBUTE ||
      ((uVar1 = subtype, type != DOM_NODE_PROCESSING_INSTRUCTION &&
       (uVar1 = node.data.element.namespace_offset, type == DOM_NODE_ELEMENT)))))) {
    uVar1 = node.data.element.namespace_offset;
    node.data.element.type = subtype;
  }
  node.data.element.namespace_offset = uVar1;
  iVar3 = assert_failed;
  if ((assert_failed == 0) && (uVar4 = (uint)(uVar2 == 0), assert_failed = uVar4, uVar4 != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0xab;
    elinks_internal((uchar *)"assertion has_bsearch_node(search->from, search->to) failed!");
    iVar3 = assert_failed;
  }
  uVar4 = 0xffffffff;
  while( true ) {
    uVar5 = (int)(uVar2 - uVar4) / 2 + uVar4;
    if (iVar3 == 0) {
      if (((int)uVar5 < 0) || (list->size <= uVar5)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 0xa2;
        elinks_internal((uchar *)"assertion 0 <= pos && pos < list->size failed: pos %d",uVar5);
      }
      else {
        assert_failed = 0;
      }
    }
    node2 = list->entries[uVar5];
    iVar3 = dom_node_casecmp(&node,node2);
    if (iVar3 == 0) break;
    if (iVar3 < 0) {
      uVar2 = uVar5;
      uVar5 = uVar4;
    }
    uVar4 = uVar5;
    iVar3 = assert_failed;
    if (uVar2 <= uVar4 + 1) {
      return (dom_node *)0x0;
    }
  }
  return node2;
}



// WARNING: Unknown calling convention

dom_node_list * add_to_dom_node_list(dom_node_list **list_ptr,dom_node *node,int position)

{
  size_t newsize;
  uint uVar1;
  size_t size_00;
  dom_node_list *p;
  dom_node **offset;
  size_t size;
  size_t sVar2;
  undefined2 *puVar3;
  dom_node **ppdVar4;
  dom_node_list *list;
  size_t oldsize;
  uint uVar5;
  bool bVar6;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(node == (dom_node *)0x0 || list_ptr == (dom_node_list **)0x0),
     node == (dom_node *)0x0 || list_ptr == (dom_node_list **)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x3d;
    elinks_internal((uchar *)"assertion list_ptr && node failed!");
    p = *list_ptr;
    if (p != (dom_node_list *)0x0) goto LAB_080a2702;
LAB_080a27f0:
    size_00 = 0x24;
    uVar5 = 0;
    sVar2 = 0;
LAB_080a27f9:
    p = (dom_node_list *)mem_realloc(p,size_00);
    if (p == (dom_node_list *)0x0) {
      return (dom_node_list *)0x0;
    }
    if (sVar2 == 0) {
      p->size = 0;
    }
    ppdVar4 = p->entries + uVar5;
    uVar5 = 0x20;
    bVar6 = ((uint)ppdVar4 & 1) != 0;
    if (bVar6) {
      *(undefined *)ppdVar4 = 0;
      uVar5 = 0x1f;
      ppdVar4 = (dom_node **)((int)ppdVar4 + 1);
    }
    if (((uint)ppdVar4 & 2) != 0) {
      *(undefined2 *)ppdVar4 = 0;
      uVar5 = uVar5 - 2;
      ppdVar4 = (dom_node **)((int)ppdVar4 + 2);
    }
    uVar1 = 0;
    do {
      *(undefined4 *)((int)ppdVar4 + uVar1) = 0;
      uVar1 = uVar1 + 4;
    } while (uVar1 < (uVar5 & 0xfffffffc));
    puVar3 = (undefined2 *)((int)ppdVar4 + uVar1);
    if ((uVar5 & 2) != 0) {
      *puVar3 = 0;
      puVar3 = puVar3 + 1;
    }
    if (bVar6) {
      *(undefined *)puVar3 = 0;
    }
    *list_ptr = p;
  }
  else {
    p = *list_ptr;
    if (p == (dom_node_list *)0x0) goto LAB_080a27f0;
LAB_080a2702:
    sVar2 = p->size;
    uVar5 = sVar2 + 7 & 0xfffffff8;
    uVar1 = sVar2 + 8 & 0xfffffff8;
    if (uVar5 < uVar1) {
      size_00 = uVar1 * 4 + 4;
      goto LAB_080a27f9;
    }
  }
  if (assert_failed == 0) {
    if ((position < 0) || ((uint)position < p->size || position == p->size)) {
      assert_failed = 0;
      goto LAB_080a278a;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x43;
    elinks_internal((uchar *)
                    "assertion position < 0 || position <= list->size failed: position out of bound %d > %zu"
                    ,position,p->size);
  }
  else {
LAB_080a278a:
    if (position < 0) {
      uVar5 = p->size;
      position = uVar5;
      goto LAB_080a2764;
    }
  }
  uVar5 = p->size;
  if ((uint)position < uVar5) {
    memmove(p[1].entries + position + -1,p->entries + position,(uVar5 - position) * 4);
    uVar5 = p->size;
  }
LAB_080a2764:
  p->size = uVar5 + 1;
  p->entries[position] = node;
  return p;
}



// WARNING: Unknown calling convention

dom_node * get_dom_node_child(dom_node *parent,dom_node_type type,int16_t subtype)

{
  ushort uVar1;
  dom_node_list *pdVar2;
  dom_node *pdVar3;
  dom_node_list **list;
  dom_node_data *pdVar4;
  int index;
  uint uVar5;
  
  uVar1 = parent->type;
  if (uVar1 == 7) {
    if (type != DOM_NODE_ATTRIBUTE) {
      return (dom_node *)0x0;
    }
    pdVar4 = (dom_node_data *)&(parent->data).notation.system_id.string;
  }
  else if (uVar1 < 8) {
    if (uVar1 != 1) {
      return (dom_node *)0x0;
    }
    pdVar4 = &parent->data;
    if (type == DOM_NODE_ATTRIBUTE) {
      pdVar4 = (dom_node_data *)&(parent->data).attribute.value.string;
    }
  }
  else {
    if (uVar1 != 9) {
      if (uVar1 != 10) {
        return (dom_node *)0x0;
      }
      if (type == DOM_NODE_ENTITY) {
        pdVar4 = &parent->data;
        goto LAB_080a2912;
      }
      if (type != DOM_NODE_NOTATION) {
        return (dom_node *)0x0;
      }
    }
    pdVar4 = (dom_node_data *)&(parent->data).attribute.value.string;
  }
LAB_080a2912:
  if (((pdVar4 != (dom_node_data *)0x0) &&
      (pdVar2 = (pdVar4->document_type).entities, pdVar2 != (dom_node_list *)0x0)) &&
     (pdVar2->size != 0)) {
    uVar5 = 0;
    do {
      pdVar3 = pdVar2->entries[uVar5];
      if ((pdVar3 != (dom_node *)0x0) && (pdVar3->type == type)) {
        if (subtype == 0) {
          return pdVar3;
        }
        if (((type != DOM_NODE_ATTRIBUTE) && (type != DOM_NODE_PROCESSING_INSTRUCTION)) &&
           (type != DOM_NODE_ELEMENT)) {
          return pdVar3;
        }
        if ((uint)(pdVar3->data).element.type == (int)subtype) {
          return pdVar3;
        }
      }
      uVar5 = uVar5 + 1;
    } while (uVar5 < pdVar2->size);
  }
  return (dom_node *)0x0;
}



// WARNING: Unknown calling convention

int get_dom_node_list_index(dom_node *parent,dom_node *node)

{
  ushort uVar1;
  uint16_t uVar2;
  dom_node_list **list;
  int iVar3;
  
  uVar1 = parent->type;
  uVar2 = node->type;
  if (uVar1 == 7) {
    if (uVar2 != 2) {
      return -1;
    }
    list = &(parent->data).proc_instruction.map;
  }
  else if (uVar1 < 8) {
    if (uVar1 != 1) {
      return -1;
    }
    list = (dom_node_list **)&parent->data;
    if (uVar2 == 2) {
      list = &(parent->data).document.children;
    }
  }
  else {
    if (uVar1 != 9) {
      if (uVar1 != 10) {
        return -1;
      }
      if (uVar2 == 6) {
        list = (dom_node_list **)&parent->data;
        goto LAB_080a29eb;
      }
      if (uVar2 != 0xc) {
        return -1;
      }
    }
    list = &(parent->data).document.children;
  }
LAB_080a29eb:
  if ((list != (dom_node_list **)0x0) && (*list != (dom_node_list *)0x0)) {
    iVar3 = get_dom_node_list_pos(*list,node);
    return iVar3;
  }
  return -1;
}



// WARNING: Unknown calling convention

dom_node * get_dom_node_next(dom_node *node)

{
  uint16_t uVar1;
  ushort uVar2;
  dom_node *pdVar3;
  int iVar4;
  int index;
  dom_node_list **list;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (dom_node *)0x0;
  }
  assert_failed = (int)(node->parent == (dom_node *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x11f;
    elinks_internal((uchar *)"assertion node->parent failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
  }
  pdVar3 = node->parent;
  uVar1 = node->type;
  uVar2 = pdVar3->type;
  if (uVar2 == 7) {
    if (uVar1 != 2) {
      return (dom_node *)0x0;
    }
    list = &(pdVar3->data).proc_instruction.map;
  }
  else if (uVar2 < 8) {
    if (uVar2 != 1) {
      return (dom_node *)0x0;
    }
    list = (dom_node_list **)&pdVar3->data;
    if (uVar1 == 2) {
      list = &(pdVar3->data).document.children;
    }
  }
  else {
    if (uVar2 != 9) {
      if (uVar2 != 10) {
        return (dom_node *)0x0;
      }
      if (uVar1 == 6) {
        list = (dom_node_list **)&pdVar3->data;
        goto LAB_080a2ac9;
      }
      if (uVar1 != 0xc) {
        return (dom_node *)0x0;
      }
    }
    list = &(pdVar3->data).document.children;
  }
LAB_080a2ac9:
  if (list != (dom_node_list **)0x0) {
    assert_failed = (int)(*list == (dom_node_list *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 0x127;
      elinks_internal((uchar *)"assertion *list failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (dom_node *)0x0;
      }
    }
    iVar4 = get_dom_node_list_pos(*list,node);
    if (assert_failed != 0) {
      assert_failed = 0;
      return (dom_node *)0x0;
    }
    assert_failed = -(iVar4 >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 299;
      elinks_internal((uchar *)"assertion index >= 0 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (dom_node *)0x0;
      }
    }
    if (iVar4 + 1U < (*list)->size) {
      return (*list)[1].entries[iVar4 + -1];
    }
  }
  return (dom_node *)0x0;
}



// WARNING: Unknown calling convention

int get_dom_node_map_index(dom_node_list *list,dom_node *node)

{
  dom_node *node2;
  int iVar1;
  int difference;
  dom_node *match;
  uint uVar2;
  int pos;
  uint uVar3;
  uint uVar4;
  
  uVar4 = list->size;
  iVar1 = assert_failed;
  if ((assert_failed == 0) && (uVar2 = (uint)(uVar4 == 0), assert_failed = uVar2, uVar2 != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0xab;
    elinks_internal((uchar *)"assertion has_bsearch_node(search->from, search->to) failed!");
    iVar1 = assert_failed;
  }
  uVar2 = 0xffffffff;
  while( true ) {
    uVar3 = (int)(uVar4 - uVar2) / 2 + uVar2;
    if (iVar1 == 0) {
      if (((int)uVar3 < 0) || (list->size <= uVar3)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 0xa2;
        elinks_internal((uchar *)"assertion 0 <= pos && pos < list->size failed: pos %d",uVar3);
      }
      else {
        assert_failed = 0;
      }
    }
    node2 = list->entries[uVar3];
    iVar1 = dom_node_casecmp(node,node2);
    if (iVar1 == 0) break;
    if (iVar1 < 0) {
      uVar4 = uVar3;
      uVar3 = uVar2;
    }
    uVar2 = uVar3;
    iVar1 = assert_failed;
    if (uVar4 <= uVar2 + 1) {
      return uVar4;
    }
  }
  if (node2 == (dom_node *)0x0) {
    uVar3 = uVar4;
  }
  return uVar3;
}



// WARNING: Unknown calling convention

dom_node * init_dom_node_at(dom_node *parent,dom_node_type type,dom_string *string,int allocated)

{
  ushort uVar1;
  uint16_t uVar2;
  uchar *puVar3;
  size_t __n;
  byte bVar4;
  dom_node *node_00;
  dom_node *node;
  int index;
  dom_node_list *pdVar5;
  uchar *puVar6;
  uint uVar7;
  dom_node_list **list;
  
  node_00 = (dom_node *)mem_calloc(1,0x20);
  if (node_00 == (dom_node *)0x0) {
    return (dom_node *)0x0;
  }
  node_00->parent = parent;
  node_00->type = (uint16_t)type;
  if (allocated < 0) {
    if (parent == (dom_node *)0x0) {
      bVar4 = node_00->field_0x2;
    }
    else {
      bVar4 = node_00->field_0x2 & 0xfe | parent->field_0x2 & 1;
      node_00->field_0x2 = bVar4;
    }
  }
  else {
    bVar4 = node_00->field_0x2 & 0xfe | allocated != 0;
    node_00->field_0x2 = bVar4;
  }
  if ((bVar4 & 1) == 0) {
    uVar7 = string->length;
    puVar3 = string->string;
    (node_00->string).string = puVar3;
    if (uVar7 == 0xffffffff) {
      uVar7 = strlen((char *)puVar3);
    }
    (node_00->string).length = uVar7;
  }
  else {
    __n = string->length;
    puVar3 = string->string;
    puVar6 = (uchar *)mem_realloc((node_00->string).string,(node_00->string).length + __n + 1);
    if (puVar6 == (uchar *)0x0) goto LAB_080a2f70;
    (node_00->string).string = puVar6;
    memcpy(puVar6 + (node_00->string).length,puVar3,__n);
    uVar7 = __n + (node_00->string).length;
    (node_00->string).length = uVar7;
    (node_00->string).string[uVar7] = '\0';
  }
  if (parent == (dom_node *)0x0) {
    return node_00;
  }
  uVar1 = parent->type;
  uVar2 = node_00->type;
  if (uVar1 == 7) {
    list = &(parent->data).proc_instruction.map;
    if (uVar2 != 2) goto LAB_080a2dd0;
  }
  else if (uVar1 < 8) {
    if (uVar1 == 1) {
      list = (dom_node_list **)&parent->data;
      if (uVar2 == 2) {
        list = &(parent->data).document.children;
      }
    }
    else {
LAB_080a2dd0:
      list = (dom_node_list **)0x0;
    }
  }
  else {
    if (uVar1 != 9) {
      if (uVar1 == 10) {
        list = (dom_node_list **)&parent->data;
        if (uVar2 == 6) goto LAB_080a2dd2;
        if (uVar2 == 0xc) goto LAB_080a2ea7;
      }
      goto LAB_080a2dd0;
    }
LAB_080a2ea7:
    list = &(parent->data).document.children;
  }
LAB_080a2dd2:
  if ((assert_failed == 0) &&
     (assert_failed = (int)((dom_node_data *)list == (dom_node_data *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
    errline = 0x18b;
    elinks_internal((uchar *)"assertion list != NULL failed: Adding node %d to bad parent %d",
                    (uint)node_00->type,(uint)parent->type);
  }
  pdVar5 = *list;
  if (((pdVar5 == (dom_node_list *)0x0) || (type != DOM_NODE_ATTRIBUTE)) || (pdVar5->size == 0)) {
    index = -1;
  }
  else {
    index = get_dom_node_map_index(pdVar5,node_00);
  }
  pdVar5 = add_to_dom_node_list(list,node_00,index);
  if (pdVar5 != (dom_node_list *)0x0) {
    return node_00;
  }
LAB_080a2f70:
  done_dom_node(node_00);
  return (dom_node *)0x0;
}



// WARNING: Unknown calling convention

dom_scanner_token * skip_dom_scanner_tokens(dom_scanner *scanner,int skipto,int precedence)

{
  dom_scanner_token *pdVar1;
  dom_scanner_token *token;
  dom_scanner_token *pdVar2;
  dom_scanner_token *pdVar3;
  int iVar4;
  
  iVar4 = scanner->tokens;
  if (((0 < iVar4) && (pdVar3 = scanner->current, pdVar3 < scanner->table + iVar4)) &&
     (pdVar3 != (dom_scanner_token *)0x0)) {
    if (pdVar3->type == skipto) {
LAB_080a302b:
      if (0 < iVar4) {
        pdVar1 = scanner->current;
        pdVar3 = scanner->table + iVar4;
        if (pdVar1 < pdVar3) {
          pdVar2 = pdVar1 + 1;
          scanner->current = pdVar2;
          if (pdVar3 <= pdVar1 + 2) {
                    // WARNING: Could not recover jumptable at 0x080a3068. Too many branches
                    // WARNING: Treating indirect jump as call
            pdVar3 = (*scanner->info->scan)(scanner);
            return pdVar3;
          }
          if (pdVar2 < pdVar3) {
            return pdVar2;
          }
        }
      }
    }
    else if (pdVar3->precedence <= precedence) {
      while (pdVar1 = scanner->table + iVar4, pdVar3 < pdVar1) {
        pdVar2 = pdVar3 + 1;
        scanner->current = pdVar2;
        if (pdVar3 + 2 < pdVar1) {
          if (iVar4 < 1) {
            return (dom_scanner_token *)0x0;
          }
          if (pdVar1 <= pdVar2) {
            return (dom_scanner_token *)0x0;
          }
        }
        else {
          pdVar2 = (*scanner->info->scan)(scanner);
        }
        if (pdVar2 == (dom_scanner_token *)0x0) {
          return (dom_scanner_token *)0x0;
        }
        if (pdVar2->type == skipto) {
LAB_080a3028:
          iVar4 = scanner->tokens;
          goto LAB_080a302b;
        }
        if (pdVar2->precedence != precedence && precedence <= pdVar2->precedence) {
          if (skipto != pdVar2->type) {
            return (dom_scanner_token *)0x0;
          }
          goto LAB_080a3028;
        }
        iVar4 = scanner->tokens;
        if (iVar4 < 1) {
          return (dom_scanner_token *)0x0;
        }
        pdVar3 = scanner->current;
      }
    }
  }
  return (dom_scanner_token *)0x0;
}



// WARNING: Unknown calling convention

void init_dom_scanner(dom_scanner *scanner,dom_scanner_info *scanner_info,dom_string *string,
                     int state,int count_lines,int complete,int check_complete,int detect_errors)

{
  byte *pbVar1;
  uint uVar2;
  byte bVar3;
  uchar *puVar4;
  int iVar5;
  anon_enum_32 aVar6;
  dom_scan_table_info *info;
  dom_scan_table_info *pdVar7;
  int index;
  uint uVar8;
  dom_scanner *pdVar9;
  byte bVar10;
  dom_scan_table_info *local_20;
  
  bVar10 = 0;
  bVar3 = scanner_info->field_0x40c;
  if ((bVar3 & 1) == 0) {
    pdVar7 = scanner_info->scan_table_info;
    if ((pdVar7 != (dom_scan_table_info *)0x0) && (aVar6 = pdVar7->type, aVar6 != DOM_SCAN_END)) {
      local_20 = pdVar7 + 1;
      do {
        while (aVar6 != COMMON_DOWNLOAD_DO) {
          puVar4 = (pdVar7->data).string;
          uVar2 = (pdVar7->data).length;
          uVar8 = uVar2 - 1;
          if (assert_failed == 0) {
            assert_failed = (uint)(aVar6 != CONTINUE_DOWNLOAD_DO) | uVar8 >> 0x1f;
            if (assert_failed != 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
              errline = 0x93;
              elinks_internal((uchar *)
                              "assertion info[i].type == DOM_SCAN_STRING && pos >= 0 failed!");
              goto LAB_080a3288;
            }
          }
          else {
LAB_080a3288:
            if ((int)uVar8 < 0) goto LAB_080a3147;
          }
          puVar4 = puVar4 + uVar2;
          do {
            pbVar1 = puVar4 + -1;
            puVar4 = puVar4 + -1;
            scanner_info->scan_table[*pbVar1] = scanner_info->scan_table[*pbVar1] | pdVar7->bits;
            uVar8 = uVar8 - 1;
          } while (-1 < (int)uVar8);
          aVar6 = local_20->type;
          pdVar7 = local_20;
          local_20 = local_20 + 1;
          if (aVar6 == DOM_SCAN_END) goto LAB_080a3155;
        }
        uVar8 = (uint)*(pdVar7->data).string;
        if (assert_failed == 0) {
          assert_failed = (int)(uVar8 == 0);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 0x88;
            elinks_internal((uchar *)"assertion index > 0 failed!");
            if (assert_failed != 0) goto LAB_080a3132;
          }
          assert_failed = (int)(0xff < (pdVar7->data).length);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 0x89;
            elinks_internal((uchar *)"assertion data->length < DOM_SCAN_TABLE_SIZE failed!");
            if (assert_failed != 0) goto LAB_080a3132;
          }
          assert_failed = (int)((pdVar7->data).length <= uVar8 && uVar8 != (pdVar7->data).length);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 0x8a;
            elinks_internal((uchar *)"assertion index <= data->length failed!");
          }
        }
LAB_080a3132:
        if (uVar8 <= (pdVar7->data).length) {
          do {
            scanner_info->scan_table[uVar8] = scanner_info->scan_table[uVar8] | pdVar7->bits;
            uVar8 = uVar8 + 1;
          } while (uVar8 < (pdVar7->data).length || uVar8 == (pdVar7->data).length);
        }
LAB_080a3147:
        aVar6 = local_20->type;
        pdVar7 = local_20;
        local_20 = local_20 + 1;
      } while (aVar6 != DOM_SCAN_END);
LAB_080a3155:
      bVar3 = scanner_info->field_0x40c;
    }
    scanner_info->field_0x40c = bVar3 | 1;
  }
  pdVar9 = scanner;
  for (iVar5 = 0x3d; iVar5 != 0; iVar5 = iVar5 + -1) {
    pdVar9->string = (uchar *)0x0;
    pdVar9 = (dom_scanner *)((int)pdVar9 + (uint)bVar10 * -8 + 4);
  }
  scanner->string = string->string;
  scanner->position = string->string;
  puVar4 = string->string;
  uVar8 = string->length;
  scanner->info = scanner_info;
  scanner->end = puVar4 + uVar8;
  scanner->current = scanner->table;
  scanner->state = state;
  scanner->field_0x20 = scanner->field_0x20 & 0xfe | count_lines != 0;
  scanner->field_0x18 =
       (scanner->field_0x18 & 0xfc | (complete == 0) * '\x02') & 0xfb | check_complete != 0 |
       (detect_errors != 0) << 2;
  scanner->lineno = (uint)(count_lines != 0);
                    // WARNING: Could not recover jumptable at 0x080a31fb. Too many branches
                    // WARNING: Treating indirect jump as call
  (*scanner_info->scan)(scanner);
  return;
}



// WARNING: Unknown calling convention

int map_dom_scanner_string(dom_scanner *scanner,uchar *ident,uchar *end,int base_type)

{
  dom_scanner_string_mapping *pdVar1;
  uchar *s1;
  size_t n;
  int iVar2;
  dom_scanner_string_mapping *mappings;
  size_t sVar3;
  
  sVar3 = (int)end - (int)ident;
  pdVar1 = scanner->info->mappings;
  s1 = (pdVar1->name).string;
  while( true ) {
    if (s1 == (uchar *)0x0) {
      return base_type;
    }
    n = (pdVar1->name).length;
    if (n == 0) break;
    if (pdVar1->base_type == base_type) {
      if ((int)sVar3 < (int)n) {
        n = sVar3;
      }
      iVar2 = c_strncasecmp((char *)s1,(char *)ident,n);
      if ((iVar2 == 0) && (sVar3 == (pdVar1->name).length)) {
        return pdVar1->type;
      }
    }
    s1 = pdVar1[1].name.string;
    pdVar1 = pdVar1 + 1;
  }
  return base_type;
}



// WARNING: Unknown calling convention

dom_scanner_token * get_next_dom_scanner_token(dom_scanner *scanner)

{
  dom_scanner_token *pdVar1;
  dom_scanner_token *pdVar2;
  dom_scanner_token *pdVar3;
  
  if (0 < scanner->tokens) {
    pdVar2 = scanner->current;
    pdVar3 = scanner->table + scanner->tokens;
    if (pdVar2 < pdVar3) {
      pdVar1 = pdVar2 + 1;
      scanner->current = pdVar1;
      if (pdVar3 <= pdVar2 + 2) {
        pdVar3 = (*scanner->info->scan)(scanner);
        return pdVar3;
      }
      if (pdVar1 < pdVar3) {
        return pdVar1;
      }
    }
  }
  return (dom_scanner_token *)0x0;
}



// WARNING: Unknown calling convention

dom_code dom_select_pop_element(dom_stack *stack,dom_node *node,void *data)

{
  dom_stack *stack_00;
  dom_stack_context *pdVar1;
  size_t sVar2;
  int iVar3;
  dom_stack_state *target;
  dom_node **ppdVar4;
  size_t object_size;
  dom_select_data *select_data;
  int index;
  int local_30;
  
  stack_00 = (dom_stack *)stack->current->data;
  local_30 = stack_00->depth - 1;
  if (-1 < local_30) {
    iVar3 = stack_00->depth * 0xc;
    do {
      target = (dom_stack_state *)((int)&stack_00->states[-1].node + iVar3);
      if (target != (dom_stack_state *)0x0) {
        pdVar1 = *stack_00->contexts;
        sVar2 = pdVar1->info->object_size;
        ppdVar4 = (dom_node **)0x0;
        if (sVar2 != 0) {
          if ((assert_failed == 0) &&
             (assert_failed = (int)(pdVar1->state_objects == (uchar *)0x0), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 0xc6;
            elinks_internal((uchar *)"assertion context->state_objects failed!");
          }
          ppdVar4 = (dom_node **)(pdVar1->state_objects + target->depth * sVar2);
        }
        if (*ppdVar4 == node) {
          pop_dom_state(stack_00,target);
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 0x3b2;
          elinks_wdebug((uchar *)"Remove element.");
        }
      }
      local_30 = local_30 + -1;
      iVar3 = iVar3 + -0xc;
    } while (-1 < local_30);
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

void done_dom_select(dom_select *select)

{
  if (select->selector != (dom_select_node *)0x0) {
    done_dom_node(&select->selector->node);
  }
  mem_free(select);
  return;
}



// WARNING: Unknown calling convention

dom_code dom_select_push_text(dom_stack *stack,dom_node *node,void *data)

{
  int *piVar1;
  uint *puVar2;
  uint uVar3;
  int index;
  dom_node_list *children;
  dom_select_data *select_data;
  dom_node *node_1;
  
  piVar1 = (int *)stack->current->data;
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  puVar2 = *(uint **)(*(int *)(*piVar1 + (piVar1[1] * 3 + -3) * 4) + 0x10);
  if ((puVar2 != (uint *)0x0) && (*puVar2 != 0)) {
    uVar3 = 0;
    do {
      if (((short *)puVar2[uVar3 + 1] != (short *)0x0) && (*(short *)puVar2[uVar3 + 1] == 3)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
        errline = 0x3c6;
        elinks_wdebug((uchar *)"Text node: %d chars",(node->string).length);
        if ((ushort)(node->type - 3) < 3) {
          return DOM_CODE_OK;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
        errline = 0x3d3;
        elinks_error((uchar *)"Unhandled type");
        return DOM_CODE_OK;
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 < *puVar2);
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
  errline = 0x3c6;
  elinks_wdebug((uchar *)"Text node: %d chars",(node->string).length);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_node_list * select_dom_nodes(dom_select *select,dom_node *root)

{
  uint uVar1;
  dom_code dVar2;
  dom_select_data select_data;
  dom_stack stack;
  
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&select_data.stack.states + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x20);
  select_data.select = select;
  init_dom_stack(&stack,DOM_STACK_FLAG_NONE);
  add_dom_stack_context(&stack,&select_data,&dom_select_context_info);
  init_dom_stack(&select_data.stack,DOM_STACK_FLAG_NONE);
  add_dom_stack_context(&select_data.stack,&select_data,&dom_select_data_context_info);
  dVar2 = push_dom_node(&select_data.stack,&select->selector->node);
  if (dVar2 == DOM_CODE_OK) {
    select_data.stack.states[select_data.stack.depth - 1].field_0x8 =
         select_data.stack.states[select_data.stack.depth - 1].field_0x8 | 1;
    walk_dom_nodes(&stack,root);
  }
  done_dom_stack(&select_data.stack);
  done_dom_stack(&stack);
  return select_data.list;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

dom_code dom_select_push_element(dom_stack *stack,dom_node *node,void *data)

{
  dom_stack *stack_00;
  dom_node *pdVar1;
  dom_node_list *pdVar2;
  dom_node_list *list;
  dom_node *pdVar3;
  dom_stack_context *pdVar4;
  int iVar5;
  size_t *psVar6;
  ushort uVar7;
  dom_stack_state *state;
  size_t sVar8;
  uint uVar9;
  int do_compare;
  ushort *puVar10;
  ushort **ppuVar11;
  int iVar12;
  dom_node *pdVar13;
  dom_node **ppdVar14;
  int iVar15;
  dom_node_list *children;
  uint uVar16;
  dom_node **ppdVar17;
  dom_select_node *selector;
  size_t index;
  uint uVar18;
  dom_node *attr;
  dom_node_list *pdVar19;
  dom_select_data *select_data;
  dom_node *selnode;
  dom_node_list *attrs;
  bool bVar20;
  int local_30;
  uint local_2c;
  uint local_28;
  uint local_24;
  
  stack_00 = (dom_stack *)stack->current->data;
  if (stack_00->depth != 0) {
    local_24 = 0;
LAB_080a3722:
    do {
      if (stack_00->states + local_24 == (dom_stack_state *)0x0) {
LAB_080a3710:
        sVar8 = stack_00->depth;
      }
      else {
        pdVar1 = stack_00->states[local_24].node;
        if (assert_failed == 0) {
          if ((node == (dom_node *)0x0) || (node->type != 1)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
            errline = 0x357;
            elinks_internal((uchar *)"assertion node && node->type == DOM_NODE_ELEMENT failed!");
          }
          else {
            assert_failed = 0;
          }
        }
        uVar18 = pdVar1[1].data.attribute.value.length;
        if ((uVar18 & 8) == 0) {
          iVar12 = dom_node_casecmp(pdVar1,node);
          if (iVar12 == 0) {
            uVar18 = pdVar1[1].data.attribute.value.length;
            local_2c = uVar18 & 7;
            if (local_2c != 0) goto LAB_080a3ac8;
            goto LAB_080a3799;
          }
          goto LAB_080a3710;
        }
        local_2c = uVar18 & 7;
        if (local_2c == 0) {
LAB_080a3799:
          if (((((uVar18 & 0x10) == 0) || (pdVar3 = node->parent, pdVar3 == (dom_node *)0x0)) ||
              ((pdVar3->type == 9 && (((pdVar3->data).document.children)->size < 2)))) &&
             (((((uVar18 & 0x20) == 0 ||
                (pdVar2 = (node->data).document_type.entities, pdVar2 == (dom_node_list *)0x0)) ||
               (pdVar2->size == 0)) && ((uVar18 & 0xc0) == 0)))) {
            pdVar2 = (pdVar1->data).document.children;
            if (pdVar2 != (dom_node_list *)0x0) {
              list = (node->data).document.children;
              if (assert_failed == 0) {
                if ((pdVar1->type == 1) && (node->type == 1)) {
                  assert_failed = 0;
                }
                else {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                  errline = 0x2d8;
                  elinks_internal((uchar *)
                                  "assertion base->node.type == DOM_NODE_ELEMENT && node->type == DOM_NODE_ELEMENT failed!"
                                 );
                }
              }
              if (list == (dom_node_list *)0x0) goto LAB_080a3710;
              if (pdVar2->size != 0) {
                uVar18 = 0;
                do {
                  while (pdVar3 = pdVar2->entries[uVar18], pdVar3 == (dom_node *)0x0) {
LAB_080a38f0:
                    uVar18 = uVar18 + 1;
                    if (pdVar2->size <= uVar18) goto LAB_080a3904;
                  }
                  if (*(char *)&pdVar3[1].data < '\0') {
                    uVar16 = list->size;
                    if (uVar16 == 0) goto LAB_080a3710;
                    uVar9 = 0;
                    while ((pdVar13 = list->entries[uVar9], pdVar13 == (dom_node *)0x0 ||
                           ((*(byte *)((int)&pdVar13->data + 0xd) & 4) == 0))) {
                      uVar9 = uVar9 + 1;
                      if (uVar16 <= uVar9) goto LAB_080a3710;
                    }
                    if (uVar16 <= uVar9) goto LAB_080a3710;
                  }
                  else {
                    pdVar13 = get_dom_node_map_entry
                                        (list,DOM_NODE_ATTRIBUTE,(pdVar3->data).element.type,
                                         &pdVar3->string);
                    if (pdVar13 == (dom_node *)0x0) goto LAB_080a3710;
                  }
                  if ((*(byte *)&pdVar3[1].data & 1) != 0) goto LAB_080a38f0;
                  if ((assert_failed == 0) &&
                     (assert_failed = (int)((pdVar3->data).document.document == (dom_document *)0x0)
                     , assert_failed != 0)) {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                    errline = 0x26f;
                    elinks_internal((uchar *)"assertion selvalue->length failed!");
                  }
                  local_28 = (pdVar13->data).attribute.value.length;
                  uVar16 = (pdVar3->data).attribute.value.length;
                  if (local_28 < uVar16) goto LAB_080a3710;
                  uVar9 = pdVar3[1].data.attribute.value.length;
                  if ((uVar9 & 2) == 0) {
                    if ((uVar9 & 0x10) == 0) {
                      if ((uVar9 & 0x20) == 0) {
                        pdVar19 = (pdVar13->data).document.children;
                        if (local_28 == 0xffffffff) {
                          local_28 = strlen((char *)pdVar19);
                        }
                        if ((uVar9 & 4) != 0) {
                          uVar7 = 1;
                          do {
                            if ((uVar7 == 0) ||
                               (iVar12 = c_strncasecmp((char *)pdVar19,
                                                       (char *)(pdVar3->data).document.children,
                                                       uVar16), iVar12 != 0)) {
                              ppuVar11 = __ctype_b_loc();
                              uVar16 = (pdVar3->data).attribute.value.length;
                              puVar10 = *ppuVar11;
                            }
                            else {
                              uVar16 = (pdVar3->data).attribute.value.length;
                              if (uVar16 == local_28) goto LAB_080a38f0;
                              ppuVar11 = __ctype_b_loc();
                              puVar10 = *ppuVar11;
                              if ((*(byte *)((int)puVar10 +
                                            (uint)*(byte *)((int)pdVar19->entries + (local_28 - 4))
                                            * 2 + 1) & 0x20) != 0) goto LAB_080a38f0;
                            }
                            psVar6 = &pdVar19->size;
                            local_28 = local_28 - 1;
                            pdVar19 = (dom_node_list *)((int)&pdVar19->size + 1);
                            if (local_28 < uVar16) goto LAB_080a3710;
                            uVar7 = puVar10[*(byte *)psVar6] & 0x2000;
                          } while( true );
                        }
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                        errline = 0x29c;
                        elinks_internal((uchar *)"No attribute selector matching method defined");
                        goto LAB_080a3710;
                      }
                      pdVar19 = (dom_node_list *)
                                ((local_28 - uVar16) + (int)(pdVar13->data).document.children);
                    }
                    else {
                      pdVar19 = (pdVar13->data).document.children;
                    }
                    uVar9 = uVar16;
                    if (uVar16 == 0xffffffff) {
                      uVar9 = strlen((char *)pdVar19);
                    }
                    if ((int)uVar9 <= (int)uVar16) {
                      uVar16 = uVar9;
                    }
                    iVar12 = c_strncasecmp((char *)pdVar19,(char *)(pdVar3->data).document.children,
                                           uVar16);
                    if (iVar12 == 0) {
                      iVar12 = uVar9 - (pdVar3->data).attribute.value.length;
                    }
LAB_080a3a38:
                    if (iVar12 != 0) goto LAB_080a3710;
                  }
                  else {
                    if ((int)local_28 <= (int)uVar16) {
                      uVar16 = local_28;
                    }
                    iVar12 = c_strncasecmp((char *)(pdVar13->data).document.children,
                                           (char *)(pdVar3->data).document.children,uVar16);
                    if (iVar12 != 0) goto LAB_080a3a38;
                    if ((pdVar13->data).document.document != (pdVar3->data).document.document)
                    goto LAB_080a3710;
                  }
                  uVar18 = uVar18 + 1;
                } while (uVar18 < pdVar2->size);
              }
            }
LAB_080a3904:
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
            errline = 0x396;
            elinks_wdebug((uchar *)"Matched element: %.*s.",(node->string).length,
                          (node->string).string);
            pdVar2 = (pdVar1->data).document_type.entities;
            if (pdVar2 != (dom_node_list *)0x0) {
              uVar18 = 0;
              if (pdVar2->size != 0) {
                do {
                  pdVar1 = pdVar2->entries[uVar18];
                  if ((pdVar1 != (dom_node *)0x0) && (pdVar1->type == 1)) {
                    push_dom_node(stack_00,pdVar1);
                    local_24 = local_24 + 1;
                    if (stack_00->depth <= local_24) {
                      return DOM_CODE_OK;
                    }
                    goto LAB_080a3722;
                  }
                  uVar18 = uVar18 + 1;
                } while (uVar18 < pdVar2->size);
              }
            }
          }
          goto LAB_080a3710;
        }
LAB_080a3ac8:
        if (assert_failed == 0) {
          assert_failed = 0;
        }
        if (node->parent == (dom_node *)0x0) goto LAB_080a3710;
        if (local_2c == 1) {
          local_30 = -1;
        }
        else {
          local_30 = get_dom_node_list_index(node->parent,node);
          if (local_30 < 1) goto LAB_080a3710;
        }
        sVar8 = stack_00->depth;
        iVar12 = sVar8 - 1;
        if (-1 < iVar12) {
          iVar5 = sVar8 * 0xc;
          do {
            ppdVar14 = (dom_node **)((int)&stack_00->states[-1].node + iVar5);
            if ((ppdVar14 != (dom_node **)0x0) && (*ppdVar14 == pdVar1->parent)) {
              pdVar4 = *stack_00->contexts;
              sVar8 = pdVar4->info->object_size;
              ppdVar17 = (dom_node **)0x0;
              if (sVar8 != 0) {
                if ((assert_failed == 0) &&
                   (bVar20 = pdVar4->state_objects == (uchar *)0x0, assert_failed = (int)bVar20,
                   bVar20)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                  errline = 0xc6;
                  elinks_internal((uchar *)"assertion context->state_objects failed!");
                }
                ppdVar17 = (dom_node **)(pdVar4->state_objects + sVar8 * (int)ppdVar14[1]);
              }
              pdVar3 = *ppdVar17;
              if (local_2c == 1) {
                if (pdVar3 == node->parent) goto LAB_080a3bdb;
              }
              else if (pdVar3->parent == node->parent) {
                iVar15 = get_dom_node_list_index(pdVar3->parent,pdVar3);
                if (local_2c == 2) {
                  if (iVar15 + 1 == local_30) goto LAB_080a3bdb;
                }
                else if (iVar15 < local_30) {
LAB_080a3bdb:
                  uVar18 = pdVar1[1].data.attribute.value.length;
                  goto LAB_080a3799;
                }
              }
            }
            iVar12 = iVar12 + -1;
            iVar5 = iVar5 + -0xc;
          } while (-1 < iVar12);
          goto LAB_080a3710;
        }
      }
      local_24 = local_24 + 1;
    } while (local_24 < sVar8);
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code parse_dom_select_nth_arg(dom_select_nth_match *nth,dom_scanner *scanner)

{
  byte bVar1;
  dom_scanner_token *pdVar2;
  dom_scanner_token *token;
  dom_scanner_token *pdVar3;
  dom_scanner_token *pdVar4;
  byte *pbVar5;
  int iVar6;
  size_t number_2;
  uint uVar7;
  int number;
  int sign;
  int iVar8;
  uint uVar9;
  uint local_24;
  
  if (scanner->tokens < 1) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar2 = scanner->current;
  pdVar4 = scanner->table + scanner->tokens;
  if (pdVar4 <= pdVar2) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar3 = pdVar2 + 1;
  scanner->current = pdVar3;
  if (pdVar2 + 2 < pdVar4) {
    if (pdVar4 <= pdVar3) {
      return DOM_CODE_SYNTAX_ERR;
    }
  }
  else {
    pdVar3 = (*scanner->info->scan)(scanner);
  }
  if (pdVar3 == (dom_scanner_token *)0x0) {
    return DOM_CODE_SYNTAX_ERR;
  }
  if (pdVar3->type != 0x28) {
    return DOM_CODE_SYNTAX_ERR;
  }
  if (scanner->tokens < 1) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar2 = scanner->current;
  pdVar4 = scanner->table + scanner->tokens;
  if (pdVar4 <= pdVar2) {
    return DOM_CODE_SYNTAX_ERR;
  }
  pdVar3 = pdVar2 + 1;
  scanner->current = pdVar3;
  if (pdVar2 + 2 < pdVar4) {
    if (pdVar4 <= pdVar3) {
      return DOM_CODE_SYNTAX_ERR;
    }
  }
  else {
    pdVar3 = (*scanner->info->scan)(scanner);
  }
  if (pdVar3 == (dom_scanner_token *)0x0) {
    return DOM_CODE_SYNTAX_ERR;
  }
  iVar6 = pdVar3->type;
  if (iVar6 == 0x100) {
    uVar9 = (pdVar3->string).length;
    if (uVar9 == 4) {
      iVar6 = c_strncasecmp((char *)(pdVar3->string).string,"even",4);
      if (iVar6 == 0) {
        nth->step = 2;
        nth->index = 0;
        goto LAB_080a3eb0;
      }
      uVar9 = (pdVar3->string).length;
    }
    if ((uVar9 == 3) && (iVar6 = c_strncasecmp((char *)(pdVar3->string).string,"odd",3), iVar6 == 0)
       ) {
      nth->step = 2;
      nth->index = 1;
      goto LAB_080a3eb0;
    }
    iVar6 = pdVar3->type;
    local_24 = 0xffffffff;
    iVar8 = 1;
  }
  else if (iVar6 == 0x101) {
    if ((pdVar3->string).length == 0) {
LAB_080a3fd0:
      local_24 = 0;
    }
    else {
      pbVar5 = (pdVar3->string).string;
      uVar9 = 0;
      bVar1 = *pbVar5;
      if (9 < (byte)(bVar1 - 0x30)) goto LAB_080a3fd0;
      while( true ) {
        local_24 = (uint)bVar1;
        pbVar5 = pbVar5 + 1;
        (pdVar3->string).string = pbVar5;
        local_24 = (uVar9 - 0x30) + local_24;
        uVar9 = (pdVar3->string).length - 1;
        (pdVar3->string).length = uVar9;
        if ((uVar9 == 0) || (bVar1 = *pbVar5, 9 < (byte)(bVar1 - 0x30))) break;
        uVar9 = local_24 * 10;
        if (uVar9 < local_24) {
          return DOM_CODE_VALUE_ERR;
        }
      }
      if ((int)local_24 < 0) {
        return DOM_CODE_VALUE_ERR;
      }
    }
    pdVar3 = get_next_dom_scanner_token(scanner);
    if (pdVar3 == (dom_scanner_token *)0x0) {
      return DOM_CODE_SYNTAX_ERR;
    }
    iVar6 = pdVar3->type;
    iVar8 = 1;
  }
  else {
    if (iVar6 != 0x2d) {
      return DOM_CODE_SYNTAX_ERR;
    }
    pdVar3 = get_next_dom_scanner_token(scanner);
    if (pdVar3 == (dom_scanner_token *)0x0) {
      return DOM_CODE_SYNTAX_ERR;
    }
    iVar6 = pdVar3->type;
    local_24 = 0xffffffff;
    iVar8 = -1;
    if (iVar6 == 0x100) {
      return DOM_CODE_SYNTAX_ERR;
    }
  }
  if (iVar6 == 0x100) {
    if ((pdVar3->string).length != 1) {
      return DOM_CODE_SYNTAX_ERR;
    }
    iVar6 = c_strncasecmp((char *)(pdVar3->string).string,"n",1);
    if (iVar6 != 0) {
      return DOM_CODE_SYNTAX_ERR;
    }
    nth->step = local_24 * iVar8;
    pdVar4 = get_next_dom_scanner_token(scanner);
    if (pdVar4 == (dom_scanner_token *)0x0) {
      return DOM_CODE_SYNTAX_ERR;
    }
    if (pdVar4->type == 0x2b) {
      pdVar4 = get_next_dom_scanner_token(scanner);
      if (pdVar4 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      if (pdVar4->type == 0x101) {
        uVar9 = (pdVar4->string).length;
        uVar7 = 0;
        while (uVar9 != 0) {
          pbVar5 = (pdVar4->string).string;
          bVar1 = *pbVar5;
          if (9 < (byte)(bVar1 - 0x30)) break;
          if (uVar7 * 10 < uVar7) {
            return DOM_CODE_VALUE_ERR;
          }
          uVar7 = (uVar7 * 10 - 0x30) + (uint)bVar1;
          (pdVar4->string).string = pbVar5 + 1;
          uVar9 = uVar9 - 1;
          (pdVar4->string).length = uVar9;
        }
        if ((int)uVar7 < 0) {
          return DOM_CODE_VALUE_ERR;
        }
        nth->index = uVar7 * iVar8;
      }
    }
  }
  else {
    nth->step = 0;
    nth->index = local_24 * iVar8;
  }
LAB_080a3eb0:
  pdVar4 = skip_dom_scanner_tokens(scanner,0x29,0x80);
  if (pdVar4 == (dom_scanner_token *)0x0) {
    return DOM_CODE_SYNTAX_ERR;
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code parse_dom_select(dom_select *select,dom_stack *stack,dom_string *string)

{
  uchar **ppuVar1;
  uint16_t uVar2;
  ushort uVar3;
  dom_select_pseudo dVar4;
  dom_node *pdVar5;
  dom_code code;
  dom_select_node *pdVar6;
  dom_code dVar7;
  size_t sVar8;
  int iVar9;
  int index;
  dom_node_list *pdVar10;
  dom_scanner_token *pdVar11;
  size_t sVar12;
  undefined4 uVar13;
  dom_document *pdVar14;
  int iVar15;
  int i;
  dom_node_list **list;
  dom_node *parent;
  dom_stack_state *pdVar16;
  dom_scanner_token *token;
  dom_scanner_token *pdVar17;
  dom_scanner_token *token_2;
  dom_select_node *select_node;
  anon_struct_12_2_b9013266 *paVar18;
  byte bVar19;
  dom_scanner scanner;
  dom_select_node sel;
  
  bVar19 = 0;
  init_dom_scanner(&scanner,&dom_css_scanner_info,string,0,0,1,0,0);
  pdVar6 = &sel;
  for (iVar15 = 0xd; iVar15 != 0; iVar15 = iVar15 + -1) {
    *(undefined4 *)&pdVar6->node = 0;
    pdVar6 = (dom_select_node *)((int)pdVar6 + (uint)bVar19 * -8 + 4);
  }
  while ((0 < scanner.tokens && (scanner.current < scanner.table + scanner.tokens))) {
    pdVar17 = scanner.current;
    if (scanner.table + scanner.tokens <= scanner.current) {
      pdVar17 = (dom_scanner_token *)0x0;
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(pdVar17 == (dom_scanner_token *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
      errline = 0x193;
      elinks_internal((uchar *)"assertion token failed!");
    }
    iVar15 = pdVar17->type;
    if ((((iVar15 == 0x7d) || (iVar15 == 0x7b)) || (iVar15 == 0x3b)) || (iVar15 == 0x2c)) break;
    if (iVar15 == 0x5b) {
      sel.node.type = 2;
      iVar15 = iRam00000000;
      if ((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) {
        iVar15 = (scanner.current)->type;
      }
      if (iVar15 != 0x5b) {
        return DOM_CODE_SYNTAX_ERR;
      }
      if (scanner.tokens < 1) {
        return DOM_CODE_SYNTAX_ERR;
      }
      pdVar17 = scanner.table + scanner.tokens;
      if (pdVar17 <= scanner.current) {
        return DOM_CODE_SYNTAX_ERR;
      }
      pdVar11 = scanner.current + 1;
      if (scanner.current + 2 < pdVar17) {
        scanner.current = pdVar11;
        if (pdVar17 <= pdVar11) {
          return DOM_CODE_SYNTAX_ERR;
        }
      }
      else {
        scanner.current = pdVar11;
        pdVar11 = (*(scanner.info)->scan)(&scanner);
      }
      if (pdVar11 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      if (pdVar11->type != 0x100) {
        return DOM_CODE_SYNTAX_ERR;
      }
      sVar12 = (pdVar11->string).length;
      sel.node.string.string = (pdVar11->string).string;
      if (sVar12 == 0xffffffff) {
        sVar12 = strlen((char *)sel.node.string.string);
      }
      sel.node.string.length = sVar12;
      pdVar17 = get_next_dom_scanner_token(&scanner);
      if (pdVar17 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      iVar15 = pdVar17->type;
      if (iVar15 == 0x118) {
        sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_UNIVERSAL;
      }
      else if (iVar15 < 0x119) {
        if (iVar15 == 0x5d) {
          sel.match.element = sel.match.element | DOM_SELECT_RELATION_DIRECT_CHILD;
          uVar13 = sel.node.data.document.document;
          goto LAB_080a4348;
        }
        if (iVar15 != 0x117) {
          return DOM_CODE_SYNTAX_ERR;
        }
        sel.match.element = sel.match.element | DOM_SELECT_RELATION_INDIRECT_ADJACENT;
      }
      else if (iVar15 == 0x11a) {
        sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_EMPTY;
      }
      else if (iVar15 < 0x11a) {
        sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_ROOT;
      }
      else {
        if (iVar15 != 0x11b) {
          return DOM_CODE_SYNTAX_ERR;
        }
        sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_CHILD;
      }
      pdVar17 = get_next_dom_scanner_token(&scanner);
      if ((pdVar17 == (dom_scanner_token *)0x0) ||
         ((pdVar17->type != 0x100 && (pdVar17->type != 0x103)))) {
        return DOM_CODE_SYNTAX_ERR;
      }
      pdVar14 = (dom_document *)(pdVar17->string).length;
      sel.node.data.document.children = (dom_node_list *)(pdVar17->string).string;
      if (pdVar14 == (dom_document *)0xffffffff) {
        pdVar14 = (dom_document *)strlen((char *)sel.node.data.attribute.value.string);
      }
      sel.node.data.document.document = pdVar14;
      pdVar17 = get_next_dom_scanner_token(&scanner);
      if (pdVar17 == (dom_scanner_token *)0x0) {
        return DOM_CODE_SYNTAX_ERR;
      }
      uVar13 = sel.node.data.document.document;
      if (pdVar17->type != 0x5d) {
        return DOM_CODE_SYNTAX_ERR;
      }
    }
    else {
      uVar13 = sel.node.data.document.document;
      if (iVar15 < 0x5c) {
        if (iVar15 == 0x2e) {
          if (scanner.tokens < 1) {
            return DOM_CODE_SYNTAX_ERR;
          }
          if (scanner.table + scanner.tokens <= scanner.current) {
            return DOM_CODE_SYNTAX_ERR;
          }
          pdVar17 = scanner.current + 1;
          if (scanner.current + 2 < scanner.table + scanner.tokens) {
            if (scanner.tokens < 1) {
              return DOM_CODE_SYNTAX_ERR;
            }
            scanner.current = pdVar17;
            if (scanner.table + scanner.tokens <= pdVar17) {
              return DOM_CODE_SYNTAX_ERR;
            }
          }
          else {
            scanner.current = pdVar17;
            pdVar17 = (*(scanner.info)->scan)(&scanner);
          }
          if (pdVar17 == (dom_scanner_token *)0x0) {
            return DOM_CODE_SYNTAX_ERR;
          }
          if (pdVar17->type != 0x100) {
            return DOM_CODE_SYNTAX_ERR;
          }
          sel.match.element = sel.match.element | DOM_SELECT_RELATION_INDIRECT_ADJACENT;
          sel.node.type = 2;
          sel.node.string.string = "class";
          sel.node.string.length = 5;
          uVar13 = (dom_document *)(pdVar17->string).length;
          sel.node.data.document.children = (dom_node_list *)(pdVar17->string).string;
          if (uVar13 == (dom_document *)0xffffffff) {
            uVar13 = strlen((char *)sel.node.data.attribute.value.string);
          }
        }
        else if (iVar15 < 0x2f) {
          if (iVar15 != 0x2b) {
            return DOM_CODE_SYNTAX_ERR;
          }
          if ((sel.match.element & DOM_SELECT_RELATION_FLAGS) != DOM_SELECT_RELATION_DESCENDANT) {
            return DOM_CODE_SYNTAX_ERR;
          }
          sel.match.element = sel.match.element | DOM_SELECT_RELATION_DIRECT_ADJACENT;
        }
        else if (iVar15 == 0x3a) {
          do {
            if (scanner.tokens < 1) {
              return DOM_CODE_SYNTAX_ERR;
            }
            pdVar17 = scanner.table + scanner.tokens;
            if (pdVar17 <= scanner.current) {
              return DOM_CODE_SYNTAX_ERR;
            }
            pdVar11 = scanner.current + 1;
            if (scanner.current + 2 < pdVar17) {
              scanner.current = pdVar11;
              if (pdVar17 <= pdVar11) {
                return DOM_CODE_SYNTAX_ERR;
              }
            }
            else {
              scanner.current = pdVar11;
              pdVar11 = (*(scanner.info)->scan)(&scanner);
            }
            if (pdVar11 == (dom_scanner_token *)0x0) {
              return DOM_CODE_SYNTAX_ERR;
            }
          } while (pdVar11->type == 0x3a);
          if (pdVar11->type != 0x100) {
            return DOM_CODE_SYNTAX_ERR;
          }
          iVar15 = 0;
          paVar18 = get_dom_select_pseudo::pseudo_info;
          while( true ) {
            sVar8 = (paVar18->string).length;
            if ((int)(pdVar11->string).length < (int)sVar8) {
              sVar8 = (pdVar11->string).length;
            }
            iVar9 = c_strncasecmp((char *)(paVar18->string).string,(char *)(pdVar11->string).string,
                                  sVar8);
            if ((iVar9 == 0) && ((paVar18->string).length == (pdVar11->string).length)) break;
            iVar15 = iVar15 + 1;
            paVar18 = paVar18 + 1;
            if (iVar15 == 0x1c) {
              return DOM_CODE_ERR;
            }
          }
          dVar4 = get_dom_select_pseudo::pseudo_info[iVar15].pseudo;
          uVar13 = sel.node.data.document.document;
          if (dVar4 == DOM_SELECT_PSEUDO_ONLY_CHILD) {
            sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_CHILD;
            sel.nth_child.step = 0;
            sel.nth_child.index = 0;
          }
          else if (dVar4 < DOM_SELECT_PSEUDO_NTH_TYPE) {
            if (dVar4 < DOM_SELECT_PSEUDO_FIRST_CHILD) {
              if (dVar4 < DOM_SELECT_PSEUDO_NTH_CHILD) {
                if (dVar4 == DOM_SELECT_PSEUDO_UNKNOWN) {
                  return DOM_CODE_ERR;
                }
                if (dVar4 != DOM_SELECT_PSEUDO_CONTAINS) {
LAB_080a4799:
                  select->pseudo = select->pseudo | dVar4;
                }
              }
              else {
                dVar7 = parse_dom_select_nth_arg(&sel.nth_child,&scanner);
                if (dVar7 != DOM_CODE_OK) {
                  return dVar7;
                }
                sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_CHILD;
                uVar13 = sel.node.data.document.document;
              }
            }
            else if (dVar4 == DOM_SELECT_PSEUDO_FIRST_CHILD) {
              sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_CHILD;
              sel.nth_child.step = 0;
              sel.nth_child.index = 1;
            }
            else {
              if (dVar4 != DOM_SELECT_PSEUDO_LAST_CHILD) goto LAB_080a4799;
              sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_CHILD;
              sel.nth_child.step = 0;
              sel.nth_child.index = 0xffffffff;
            }
          }
          else if (dVar4 == DOM_SELECT_PSEUDO_LAST_TYPE) {
            sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_TYPE;
            sel.nth_type.step = 0;
            sel.nth_type.index = 0xffffffff;
          }
          else if (dVar4 < DOM_SELECT_PSEUDO_ONLY_TYPE) {
            if (dVar4 < DOM_SELECT_PSEUDO_FIRST_TYPE) {
              dVar7 = parse_dom_select_nth_arg(&sel.nth_type,&scanner);
              if (dVar7 != DOM_CODE_OK) {
                return dVar7;
              }
              sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_TYPE;
              uVar13 = sel.node.data.document.document;
            }
            else {
              sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_TYPE;
              sel.nth_type.step = 0;
              sel.nth_type.index = 1;
            }
          }
          else if (dVar4 == DOM_SELECT_PSEUDO_ROOT) {
            sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_ROOT;
          }
          else if (dVar4 < DOM_SELECT_PSEUDO_ROOT) {
            sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_TYPE;
            sel.nth_type.step = 0;
            sel.nth_type.index = 0;
          }
          else {
            if (dVar4 != DOM_SELECT_PSEUDO_EMPTY) goto LAB_080a4799;
            sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_EMPTY;
          }
        }
        else {
          if (iVar15 != 0x3e) {
            return DOM_CODE_SYNTAX_ERR;
          }
          if ((sel.match.element & DOM_SELECT_RELATION_FLAGS) != DOM_SELECT_RELATION_DESCENDANT) {
            return DOM_CODE_SYNTAX_ERR;
          }
          sel.match.element = sel.match.element | DOM_SELECT_RELATION_DIRECT_CHILD;
        }
      }
      else if (iVar15 == 0x100) {
        sel.node.type = 1;
        sVar12 = (pdVar17->string).length;
        sel.node.string.string = (pdVar17->string).string;
        if (sVar12 == 0xffffffff) {
          sVar12 = strlen((char *)sel.node.string.string);
        }
        sel.node.string.length = sVar12;
        uVar13 = sel.node.data.document.document;
        if (((pdVar17->string).length == 1) &&
           (iVar15 = c_strncasecmp((char *)(pdVar17->string).string,"*",1),
           uVar13 = sel.node.data.document.document, iVar15 == 0)) {
          sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_UNIVERSAL;
        }
      }
      else if (iVar15 < 0x101) {
        if (iVar15 != 0x7e) {
          return DOM_CODE_SYNTAX_ERR;
        }
        if ((sel.match.element & DOM_SELECT_RELATION_FLAGS) != DOM_SELECT_RELATION_DESCENDANT) {
          return DOM_CODE_SYNTAX_ERR;
        }
        sel.match.element = sel.match.element | DOM_SELECT_RELATION_INDIRECT_ADJACENT;
      }
      else {
        if (1 < iVar15 - 0x10bU) {
          return DOM_CODE_SYNTAX_ERR;
        }
        sel.match.element = sel.match.element | DOM_SELECT_ELEMENT_NTH_TYPE;
        sel.node.type = 2;
        ppuVar1 = &(pdVar17->string).string;
        *ppuVar1 = *ppuVar1 + 1;
        (pdVar17->string).length = (pdVar17->string).length - 1;
      }
    }
LAB_080a4348:
    sel.node.data.document.document = uVar13;
    if (((0 < scanner.tokens) && (scanner.current < scanner.table + scanner.tokens)) &&
       (pdVar17 = scanner.current + 1, pdVar11 = scanner.current + 2, scanner.current = pdVar17,
       scanner.table + scanner.tokens <= pdVar11)) {
      (*(scanner.info)->scan)(&scanner);
    }
    if (sel.node.type != 0) {
      pdVar6 = (dom_select_node *)mem_calloc(1,0x34);
      (pdVar6->node).type = sel.node.type;
      *(undefined2 *)&(pdVar6->node).field_0x2 = sel.node._2_2_;
      ((dom_string *)&pdVar6->node)->length = sel.node.string.length;
      ((dom_string *)&pdVar6->node)->string = sel.node.string.string;
      *(dom_node **)&pdVar6->node = sel.node.parent;
      (((dom_node_data *)&pdVar6->node)->document).document = sel.node.data.document.document;
      (((dom_node_data *)&pdVar6->node)->document).children = sel.node.data.document.children;
      (((dom_node_data *)&pdVar6->node)->document_type).subset = sel.node.data.document_type.subset;
      (((dom_node_data *)&pdVar6->node)->notation).system_id.string =
           sel.node.data.notation.system_id.string;
      (pdVar6->nth_child).step = sel.nth_child.step;
      (pdVar6->nth_child).index = sel.nth_child.index;
      (&(pdVar6->nth_child).index)[1] = sel.nth_type.step;
      (pdVar6->nth_type).index = sel.nth_type.index;
      pdVar6->match = sel.match;
      iVar15 = assert_failed;
      pdVar16 = stack->states;
      if ((pdVar16 == (dom_stack_state *)0x0) || (sVar8 = stack->depth, sVar8 == 0)) {
        if ((assert_failed == 0) &&
           (assert_failed = (int)(select->selector != (dom_select_node *)0x0), assert_failed != 0))
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 0x1f9;
          elinks_internal((uchar *)"assertion !select->selector failed!");
        }
        select->selector = pdVar6;
      }
      else {
        if (assert_failed == 0) {
          assert_failed = 0;
          pdVar16 = stack->states;
          sVar8 = stack->depth;
        }
        pdVar5 = pdVar16[sVar8 - 1].node;
        uVar2 = (pdVar6->node).type;
        uVar3 = pdVar5->type;
        if (uVar3 == 7) {
          list = &(pdVar5->data).proc_instruction.map;
          if (uVar2 != 2) goto LAB_080a480a;
        }
        else if (uVar3 < 8) {
          if (uVar3 == 1) {
            list = (dom_node_list **)&pdVar5->data;
            if (uVar2 == 2) {
              list = &(pdVar5->data).document.children;
            }
          }
          else {
LAB_080a480a:
            list = (dom_node_list **)0x0;
          }
        }
        else {
          if (uVar3 != 9) {
            if (uVar3 == 10) {
              list = (dom_node_list **)&pdVar5->data;
              if (uVar2 == 6) goto LAB_080a480c;
              if (uVar2 == 0xc) goto LAB_080a492d;
            }
            goto LAB_080a480a;
          }
LAB_080a492d:
          list = &(pdVar5->data).document.children;
        }
LAB_080a480c:
        if ((iVar15 == 0) &&
           (assert_failed = (int)((dom_node_data *)list == (dom_node_data *)0x0), assert_failed != 0
           )) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 0x1ec;
          elinks_internal((uchar *)
                          "assertion list != NULL failed: Adding node to bad parent [%d -> %d]",
                          (uint)(pdVar6->node).type,(uint)pdVar5->type);
        }
        pdVar10 = *list;
        if (((pdVar10 == (dom_node_list *)0x0) || (uVar2 != 2)) || (pdVar10->size == 0)) {
          index = -1;
        }
        else {
          index = get_dom_node_map_index(pdVar10,(dom_node *)pdVar6);
        }
        pdVar10 = add_to_dom_node_list(list,(dom_node *)pdVar6,index);
        if (pdVar10 == (dom_node_list *)0x0) {
          done_dom_node((dom_node *)pdVar6);
          return DOM_CODE_ALLOC_ERR;
        }
        *(dom_node **)&pdVar6->node = pdVar5;
      }
      dVar7 = push_dom_node(stack,(dom_node *)pdVar6);
      if (dVar7 != DOM_CODE_OK) {
        return dVar7;
      }
      if ((pdVar6->node).type != 1) {
        pop_dom_node(stack);
      }
      pdVar6 = &sel;
      for (iVar15 = 0xd; iVar15 != 0; iVar15 = iVar15 + -1) {
        *(undefined4 *)&pdVar6->node = 0;
        pdVar6 = (dom_select_node *)((int)pdVar6 + (uint)bVar19 * -8 + 4);
      }
    }
  }
  return -(uint)(select->selector == (dom_select_node *)0x0) & 0xfffffc18;
}



// WARNING: Unknown calling convention

dom_select * init_dom_select(dom_select_syntax syntax,dom_string *string)

{
  dom_select *select_00;
  dom_code dVar1;
  dom_select *select;
  dom_select *pdVar2;
  dom_code code;
  dom_stack stack;
  
  select_00 = (dom_select *)mem_calloc(1,4);
  init_dom_stack(&stack,DOM_STACK_FLAG_NONE);
  dVar1 = parse_dom_select(select_00,&stack,string);
  done_dom_stack(&stack);
  pdVar2 = select_00;
  if (dVar1 != DOM_CODE_OK) {
    pdVar2 = (dom_select *)0x0;
    done_dom_select(select_00);
  }
  return pdVar2;
}



// WARNING: Unknown calling convention

dom_stack_state * search_dom_stack(dom_stack *stack,dom_node_type type,dom_string *string)

{
  dom_node *pdVar1;
  size_t sVar2;
  int iVar3;
  size_t n;
  int iVar4;
  dom_node *parent;
  dom_stack_state *state;
  dom_stack_state *pdVar5;
  int local_20;
  
  local_20 = stack->depth - 1;
  if (-1 < local_20) {
    iVar3 = stack->depth * 0xc;
    do {
      pdVar5 = (dom_stack_state *)((int)&stack->states[-1].node + iVar3);
      if ((pdVar5 != (dom_stack_state *)0x0) && (pdVar1 = pdVar5->node, pdVar1->type == type)) {
        sVar2 = (pdVar1->string).length;
        n = string->length;
        if ((int)sVar2 <= (int)string->length) {
          n = sVar2;
        }
        iVar4 = c_strncasecmp((char *)(pdVar1->string).string,(char *)string->string,n);
        if ((iVar4 == 0) && ((pdVar1->string).length == string->length)) {
          return pdVar5;
        }
      }
      local_20 = local_20 + -1;
      iVar3 = iVar3 + -0xc;
    } while (-1 < local_20);
  }
  return (dom_stack_state *)0x0;
}



// WARNING: Unknown calling convention

void init_dom_stack(dom_stack *stack,dom_stack_flag flags)

{
  uint uVar1;
  
  if ((assert_failed == 0) && (assert_failed = (int)(stack == (dom_stack *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x38;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&stack->states + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x18);
  stack->flags = flags;
  return;
}



// WARNING: Unknown calling convention

void done_dom_stack(dom_stack *stack)

{
  dom_stack_context *p_00;
  void *p_1;
  void *p_2;
  void *p;
  int i;
  uint uVar1;
  
  if ((assert_failed == 0) && (assert_failed = (int)(stack == (dom_stack *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x44;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  if (stack->contexts_size != 0) {
    uVar1 = 0;
    do {
      p_00 = stack->contexts[uVar1];
      if (p_00->state_objects != (uchar *)0x0) {
        mem_free(p_00->state_objects);
        p_00 = stack->contexts[uVar1];
      }
      uVar1 = uVar1 + 1;
      mem_free(p_00);
    } while (uVar1 <= stack->contexts_size && stack->contexts_size != uVar1);
  }
  if (stack->contexts != (dom_stack_context **)0x0) {
    mem_free(stack->contexts);
  }
  if (stack->states != (dom_stack_state *)0x0) {
    mem_free(stack->states);
  }
  uVar1 = 0;
  do {
    *(undefined4 *)((int)&stack->states + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x18);
  return;
}



// WARNING: Unknown calling convention

void done_dom_stack_context(dom_stack *stack,dom_stack_context *context)

{
  uint uVar1;
  size_t sVar2;
  dom_stack_context *pdVar3;
  int iVar4;
  void *p;
  int iVar5;
  uint uVar6;
  size_t i;
  dom_stack_context **ppdVar7;
  void *__dest;
  dom_stack_context **pos;
  
  if (context->state_objects != (uchar *)0x0) {
    mem_free(context->state_objects);
  }
  mem_free(context);
  sVar2 = stack->contexts_size;
  uVar1 = sVar2 - 1;
  if (stack->contexts[uVar1] == context) {
    stack->contexts_size = uVar1;
    return;
  }
  ppdVar7 = stack->contexts + (sVar2 - 2);
  iVar4 = sVar2 * 4 + -8;
  uVar6 = uVar1;
  do {
    iVar5 = iVar4;
    pdVar3 = *ppdVar7;
    uVar6 = uVar6 - 1;
    ppdVar7 = ppdVar7 + -1;
    iVar4 = iVar5 + -4;
  } while (pdVar3 != context);
  stack->contexts_size = uVar1;
  if (uVar1 <= uVar6) {
    return;
  }
  __dest = (void *)(iVar5 + (int)stack->contexts);
  memmove(__dest,(void *)((int)__dest + 4),(uVar1 - uVar6) * 4);
  return;
}



// WARNING: Unknown calling convention

int call_dom_stack_callbacks(dom_stack *stack,dom_stack_state *state,dom_stack_action action)

{
  size_t sVar1;
  dom_stack_context *pdVar2;
  bool bVar3;
  int iVar4;
  dom_stack_context *context;
  dom_code dVar5;
  dom_stack_context_info *pdVar6;
  uchar *puVar7;
  void *data;
  dom_stack_callback_T callback;
  uint uVar8;
  int i;
  int local_20;
  
  local_20 = 0;
  if (stack->contexts_size != 0) {
    uVar8 = 0;
    do {
      pdVar2 = stack->contexts[uVar8];
      if (assert_failed != 0) {
        assert_failed = 0;
        return 0;
      }
      bVar3 = 0xc < state->node->type;
      assert_failed = (int)bVar3;
      if (bVar3) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
        errline = 0x8e;
        elinks_internal((uchar *)"assertion state->node->type < DOM_NODES failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return 0;
        }
      }
      if (action == DOM_STACK_PUSH) {
        pdVar6 = pdVar2->info;
        callback = pdVar6->push[state->node->type];
      }
      else {
        pdVar6 = pdVar2->info;
        callback = pdVar6->pop[state->node->type];
      }
      iVar4 = local_20;
      if (callback != (dom_stack_callback_T)0x0) {
        sVar1 = pdVar6->object_size;
        puVar7 = (uchar *)0x0;
        if (sVar1 != 0) {
          assert_failed = (int)(pdVar2->state_objects == (uchar *)0x0);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 0xc6;
            elinks_internal((uchar *)"assertion context->state_objects failed!");
          }
          puVar7 = pdVar2->state_objects + sVar1 * state->depth;
        }
        stack->current = pdVar2;
        dVar5 = (*callback)(stack,state->node,puVar7);
        stack->current = (dom_stack_context *)0x0;
        iVar4 = 1;
        if (dVar5 != DOM_CODE_FREE_NODE) {
          iVar4 = local_20;
        }
      }
      local_20 = iVar4;
      uVar8 = uVar8 + 1;
    } while (uVar8 <= stack->contexts_size && stack->contexts_size != uVar8);
  }
  return local_20;
}



// WARNING: Unknown calling convention

void pop_dom_node(dom_stack *stack)

{
  dom_stack_context *pdVar1;
  size_t sVar2;
  size_t sVar3;
  int iVar4;
  size_t __n;
  dom_stack_state *pdVar5;
  dom_stack_context *context;
  dom_stack_state *state;
  uint uVar6;
  int i;
  
  if ((assert_failed == 0) && (assert_failed = (int)(stack == (dom_stack *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0xe0;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  pdVar5 = stack->states;
  if ((pdVar5 != (dom_stack_state *)0x0) && (sVar3 = stack->depth, sVar3 != 0)) {
    if (assert_failed == 0) {
      assert_failed = 0;
      pdVar5 = stack->states;
      sVar3 = stack->depth;
    }
    pdVar5 = pdVar5 + (sVar3 - 1);
    if ((pdVar5->field_0x8 & 1) == 0) {
      iVar4 = call_dom_stack_callbacks(stack,pdVar5,DOM_STACK_POP);
      if ((iVar4 != 0) || ((*(byte *)&stack->flags & 1) != 0)) {
        done_dom_node(pdVar5->node);
      }
      stack->depth = stack->depth - 1;
      if (stack->contexts_size != 0) {
        uVar6 = 0;
        do {
          while( true ) {
            pdVar1 = stack->contexts[uVar6];
            sVar2 = pdVar1->info->object_size;
            if (sVar2 == 0) break;
            __n = sVar2;
            if (assert_failed == 0) {
              assert_failed = (int)(pdVar1->state_objects == (uchar *)0x0);
              if (assert_failed == 0) {
                __n = pdVar1->info->object_size;
              }
              else {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                errline = 0xc6;
                elinks_internal((uchar *)"assertion context->state_objects failed!");
                __n = pdVar1->info->object_size;
              }
            }
            uVar6 = uVar6 + 1;
            memset(pdVar1->state_objects + sVar2 * pdVar5->depth,0,__n);
            if (stack->contexts_size < uVar6 || stack->contexts_size == uVar6) goto LAB_080a5128;
          }
          uVar6 = uVar6 + 1;
        } while (uVar6 <= stack->contexts_size && stack->contexts_size != uVar6);
      }
LAB_080a5128:
      pdVar5->node = (dom_node *)0x0;
      pdVar5->depth = 0;
      *(undefined4 *)&pdVar5->field_0x8 = 0;
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void pop_dom_state(dom_stack *stack,dom_stack_state *target)

{
  int iVar1;
  dom_stack_state *pdVar2;
  int iVar3;
  dom_stack_state *state;
  dom_stack_state *pdVar4;
  
  if ((assert_failed == 0) && (assert_failed = (int)(stack == (dom_stack *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x112;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  if (((target != (dom_stack_state *)0x0) &&
      (pdVar2 = stack->states, pdVar2 != (dom_stack_state *)0x0)) && (stack->depth != 0)) {
    iVar1 = stack->depth * 0xc;
    while( true ) {
      do {
        iVar3 = iVar1 + -0xc;
        pdVar4 = (dom_stack_state *)((int)&pdVar2[-1].node + iVar1);
        iVar1 = iVar3;
      } while (pdVar4 == (dom_stack_state *)0x0);
      if (((pdVar4->field_0x8 & 1) != 0) || (pop_dom_node(stack), pdVar4 == target)) break;
      pdVar2 = stack->states;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void pop_dom_nodes(dom_stack *stack,dom_node_type type,dom_string *string)

{
  dom_stack_state *state;
  dom_stack_state *target;
  
  if ((assert_failed == 0) && (assert_failed = (int)(stack == (dom_stack *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x103;
    elinks_internal((uchar *)"assertion stack failed!");
  }
  if ((stack->states != (dom_stack_state *)0x0) && (stack->depth != 0)) {
    target = search_dom_stack(stack,type,string);
    if (target != (dom_stack_state *)0x0) {
      pop_dom_state(stack,target);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

dom_code push_dom_node(dom_stack *stack,dom_node *node)

{
  dom_stack_context *pdVar1;
  bool bVar2;
  size_t newsize;
  uint uVar3;
  size_t newsize_1;
  uint uVar4;
  size_t size;
  uchar *puVar5;
  dom_stack_state *pdVar6;
  size_t oldsize_1;
  dom_stack_state *state;
  int iVar7;
  int i;
  uint uVar8;
  uint uVar9;
  dom_stack_context *context;
  size_t sVar10;
  
  if (assert_failed == 0) {
    assert_failed = (int)(node == (dom_node *)0x0 || stack == (dom_stack *)0x0);
    if (node == (dom_node *)0x0 || stack == (dom_stack *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 0xb6;
      elinks_internal((uchar *)"assertion stack && node failed!");
      if (assert_failed != 0) goto LAB_080a5355;
    }
    bVar2 = 0xb < (ushort)(node->type - 1);
    assert_failed = (int)bVar2;
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 0xb7;
      elinks_internal((uchar *)"assertion 0 < node->type && node->type < DOM_NODES failed!");
    }
  }
LAB_080a5355:
  uVar8 = stack->depth;
  if (0x1000 < uVar8) {
    return DOM_CODE_MAX_DEPTH_ERR;
  }
  uVar3 = uVar8 + 8 & 0xfffffff8;
  uVar8 = uVar8 + 7 & 0xfffffff8;
  if (uVar8 < uVar3) {
    sVar10 = uVar3 * 0xc;
    pdVar6 = (dom_stack_state *)mem_realloc(stack->states,sVar10);
    if (pdVar6 == (dom_stack_state *)0x0) goto LAB_080a5518;
    stack->states = pdVar6;
    memset(pdVar6 + uVar8,0,sVar10 + uVar8 * -0xc);
  }
  pdVar6 = stack->states;
  if (pdVar6 != (dom_stack_state *)0x0) {
    uVar8 = stack->depth;
    uVar3 = uVar8;
    if (stack->contexts_size != 0) {
      uVar9 = 0;
      do {
        while( true ) {
          pdVar1 = stack->contexts[uVar9];
          sVar10 = pdVar1->info->object_size;
          if (sVar10 != 0) break;
          uVar9 = uVar9 + 1;
          if (stack->contexts_size < uVar9 || stack->contexts_size == uVar9) goto LAB_080a53ed;
        }
        uVar4 = uVar3 + 8 & 0xfffffff8;
        uVar3 = uVar3 + 7 & 0xfffffff8;
        if (uVar3 < uVar4) {
          size = uVar4 * sVar10;
          puVar5 = (uchar *)mem_realloc(pdVar1->state_objects,size);
          if (puVar5 == (uchar *)0x0) goto LAB_080a5478;
          pdVar1->state_objects = puVar5;
          iVar7 = sVar10 * uVar3;
          memset(puVar5 + iVar7,0,size - iVar7);
        }
        if (pdVar1->state_objects == (uchar *)0x0) {
LAB_080a5478:
          done_dom_node(node);
          return DOM_CODE_ALLOC_ERR;
        }
        uVar9 = uVar9 + 1;
        uVar3 = stack->depth;
      } while (uVar9 <= stack->contexts_size && stack->contexts_size != uVar9);
    }
LAB_080a53ed:
    pdVar6 = pdVar6 + uVar8;
    pdVar6->depth = uVar3;
    pdVar6->node = node;
    stack->depth = stack->depth + 1;
    call_dom_stack_callbacks(stack,pdVar6,DOM_STACK_PUSH);
    return DOM_CODE_OK;
  }
LAB_080a5518:
  done_dom_node(node);
  return DOM_CODE_ALLOC_ERR;
}



// WARNING: Unknown calling convention

dom_stack_context *
add_dom_stack_context(dom_stack *stack,void *data,dom_stack_context_info *context_info)

{
  dom_stack_context *context;
  dom_stack_context **ppdVar1;
  size_t oldsize;
  uint uVar2;
  size_t newsize;
  uint uVar3;
  size_t sVar4;
  
  uVar3 = stack->contexts_size + 8 & 0xfffffff8;
  uVar2 = stack->contexts_size + 7 & 0xfffffff8;
  if (uVar2 < uVar3) {
    sVar4 = uVar3 * 4;
    ppdVar1 = (dom_stack_context **)mem_realloc(stack->contexts,sVar4);
    if (ppdVar1 == (dom_stack_context **)0x0) {
      context = (dom_stack_context *)0x0;
      return context;
    }
    stack->contexts = ppdVar1;
    memset(ppdVar1 + uVar2,0,sVar4 + uVar2 * -4);
  }
  if (stack->contexts == (dom_stack_context **)0x0) {
    context = (dom_stack_context *)0x0;
    return context;
  }
  context = (dom_stack_context *)mem_calloc(1,0xc);
  if (context != (dom_stack_context *)0x0) {
    sVar4 = stack->contexts_size;
    stack->contexts[sVar4] = context;
    stack->contexts_size = sVar4 + 1;
    context->info = context_info;
    context->data = data;
    return context;
  }
  context = (dom_stack_context *)0x0;
  return context;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void walk_dom_nodes(dom_stack *stack,dom_node *root)

{
  ushort uVar1;
  size_t sVar2;
  dom_node *pdVar3;
  dom_node_list *pdVar4;
  dom_stack_context *context_00;
  dom_stack_context *context;
  dom_code dVar5;
  size_t sVar6;
  dom_node_list **ppdVar7;
  dom_node_list *pdVar8;
  dom_stack_state *pdVar9;
  size_t object_size;
  dom_node_list *list;
  dom_node *child;
  dom_stack_state *state;
  dom_node_list *local_30;
  dom_node_list *local_20;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(root == (dom_node *)0x0 || stack == (dom_stack *)0x0),
     root == (dom_node *)0x0 || stack == (dom_stack *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
    errline = 0x16c;
    elinks_internal((uchar *)"assertion root && stack failed!");
  }
  context_00 = add_dom_stack_context(stack,(void *)0x0,&dom_stack_walk_context_info);
  if ((context_00 == (dom_stack_context *)0x0) ||
     (dVar5 = push_dom_node(stack,root), dVar5 != DOM_CODE_OK)) {
    return;
  }
LAB_080a565b:
  pdVar9 = stack->states;
  do {
    if ((pdVar9 == (dom_stack_state *)0x0) || (sVar6 = stack->depth, sVar6 == 0)) {
      done_dom_stack_context(stack,context_00);
      return;
    }
    if (assert_failed == 0) {
      assert_failed = 0;
      pdVar9 = stack->states;
      sVar6 = stack->depth;
    }
    sVar2 = context_00->info->object_size;
    ppdVar7 = (dom_node_list **)0x0;
    if (sVar2 != 0) {
      if ((assert_failed == 0) &&
         (assert_failed = (int)(context_00->state_objects == (uchar *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 0xc6;
        elinks_internal((uchar *)"assertion context->state_objects failed!");
      }
      ppdVar7 = (dom_node_list **)(context_00->state_objects + pdVar9[sVar6 - 1].depth * sVar2);
    }
    pdVar3 = pdVar9[sVar6 - 1].node;
    pdVar4 = *ppdVar7;
    uVar1 = pdVar3->type;
    pdVar8 = pdVar4;
    if (uVar1 == 7) {
      if (pdVar4 == (dom_node_list *)0x0) {
        pdVar8 = (pdVar3->data).proc_instruction.map;
        goto LAB_080a56e6;
      }
LAB_080a56f9:
      pdVar4 = ppdVar7[1];
      if (pdVar4 < (dom_node_list *)pdVar8->size) {
        pdVar3 = pdVar8->entries[(int)&pdVar4->size];
        ppdVar7[1] = (dom_node_list *)((int)&pdVar4->size + 1);
        dVar5 = push_dom_node(stack,pdVar3);
        if (dVar5 == DOM_CODE_OK) goto LAB_080a565b;
      }
    }
    else {
      local_30 = pdVar4;
      if (uVar1 < 8) {
        if (uVar1 == 1) {
          if (pdVar4 == (dom_node_list *)0x0) {
            local_30 = (pdVar3->data).document.children;
          }
          local_20 = (pdVar3->data).document_type.entities;
          if (((local_20 == local_30) || (local_30 == (dom_node_list *)0x0)) ||
             (((dom_node_list *)local_30->size <= ppdVar7[1] ||
              (pdVar8 = (pdVar3->data).document.children, pdVar8 != local_30)))) {
LAB_080a5760:
            pdVar8 = local_20;
          }
        }
      }
      else if (uVar1 == 9) {
        if (pdVar4 != (dom_node_list *)0x0) goto LAB_080a56f9;
        pdVar8 = (pdVar3->data).document.children;
      }
      else if (uVar1 == 10) {
        if (pdVar4 == (dom_node_list *)0x0) {
          local_30 = (pdVar3->data).document_type.entities;
        }
        local_20 = (pdVar3->data).document.children;
        if (((local_20 == local_30) || (local_30 == (dom_node_list *)0x0)) ||
           ((dom_node_list *)local_30->size <= ppdVar7[1])) goto LAB_080a5760;
        pdVar8 = (pdVar3->data).document_type.entities;
        if (pdVar8 != local_30) {
          pdVar8 = local_20;
        }
      }
LAB_080a56e6:
      if (pdVar8 != pdVar4) {
        *ppdVar7 = pdVar8;
        ppdVar7[1] = (dom_node_list *)0x0;
      }
      if (pdVar8 != (dom_node_list *)0x0) goto LAB_080a56f9;
    }
    pop_dom_node(stack);
    pdVar9 = stack->states;
  } while( true );
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

dom_scanner_token * scan_css_tokens(dom_scanner *scanner)

{
  dom_scanner_token *__dest;
  byte *__s;
  byte bVar1;
  byte bVar2;
  dom_scanner_token *pdVar3;
  uint uVar4;
  byte bVar5;
  dom_scanner_token *table;
  size_t __n;
  uint uVar6;
  int iVar7;
  uchar *puVar8;
  void *pvVar9;
  int real_length;
  dom_scanner *pdVar10;
  uchar *to;
  dom_scanner_token *__src;
  byte *pbVar11;
  int hexdigits;
  int iVar12;
  int move_to_front;
  uchar *string;
  byte *pbVar13;
  css_token_type type;
  uchar *puVar14;
  dom_scanner *pdVar15;
  byte *pbVar16;
  byte *pbVar17;
  byte *local_30;
  dom_scanner *local_20;
  
  __dest = scanner->table;
  pdVar3 = scanner->current;
  iVar12 = ((int)scanner + ((scanner->tokens * 0x14 + 0x2c) - (int)pdVar3) >> 2) * -0x33333333;
  __src = pdVar3;
  if (iVar12 < 1) {
    iVar12 = 0;
    __src = __dest;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(pdVar3 == (dom_scanner_token *)0x0), pdVar3 == (dom_scanner_token *)0x0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
    errline = 0xfb;
    elinks_internal((uchar *)"assertion scanner->current failed!");
  }
  __n = 200;
  if (iVar12 != 0) {
    memmove(__dest,__src,iVar12 * 0x14);
    __src = scanner->table + iVar12;
    __n = iVar12 * -0x14 + 200;
  }
  memset(__src,0,__n);
  if (scanner->position == (uchar *)0x0) {
    if (iVar12 == 0) {
      iVar12 = -1;
    }
    scanner->tokens = iVar12;
    scanner->current = __dest;
    if (assert_failed == 0) {
      if ((iVar12 < 10) || (scanner->table + 1 < scanner->table + iVar12)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
        errline = 0x10a;
        elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
      }
    }
    iVar12 = scanner->tokens;
  }
  else {
    scanner->tokens = iVar12;
    if (__dest != (dom_scanner_token *)0x0) {
      local_20 = (dom_scanner *)(scanner->table + iVar12);
      pdVar15 = scanner + 1;
      if ((pdVar15 <= local_20) ||
         (pbVar16 = scanner->position, scanner->end < pbVar16 || scanner->end == pbVar16)) {
joined_r0x080a5f2f:
        if ((assert_failed == 0) && (assert_failed = (int)(pdVar15 < local_20), assert_failed != 0))
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
          errline = 0x11a;
          elinks_internal((uchar *)"assertion end <= scanner->table + DOM_SCANNER_TOKENS failed!");
        }
        iVar12 = (int)local_20 - (int)__dest >> 2;
        iVar7 = iVar12 * -0x33333333;
        scanner->tokens = iVar7;
        scanner->current = __dest;
        if (scanner->end <= scanner->position) {
          scanner->position = (uchar *)0x0;
        }
        if (assert_failed == 0) {
          if ((iVar7 < 10) ||
             (scanner->current + 1 < (dom_scanner_token *)(&scanner->table[0].type + iVar12))) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
            errline = 0x121;
            elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
          }
        }
        if (0 < scanner->tokens) {
          if (scanner->current < scanner->table + scanner->tokens) {
            return scanner->current;
          }
          return (dom_scanner_token *)0x0;
        }
        return (dom_scanner_token *)0x0;
      }
      do {
        bVar1 = *pbVar16;
        uVar6 = (uint)bVar1;
        pbVar13 = pbVar16;
        if ((*(byte *)((int)dom_css_scanner_info.scan_table + uVar6 * 4 + 1) & 4) != 0) {
          do {
            pbVar13 = pbVar13 + 1;
            scanner->position = pbVar13;
            if (scanner->end <= pbVar13) goto joined_r0x080a5f2f;
            bVar1 = *pbVar13;
            uVar6 = (uint)bVar1;
          } while ((*(byte *)((int)dom_css_scanner_info.scan_table + uVar6 * 4 + 1) & 4) != 0);
        }
        if ((assert_failed == 0) && (assert_failed = (int)(bVar1 == 0), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
          errline = 0x87;
          elinks_internal((uchar *)"assertion first_char failed!");
        }
        pbVar16 = pbVar13 + 1;
        local_20->tokens = (int)pbVar13;
        uVar4 = dom_css_scanner_info.scan_table[uVar6];
        if ((uVar4 & 0x100) != 0) {
          puVar14 = (uchar *)(uint)bVar1;
          goto LAB_080a5ae9;
        }
        if (((uVar4 & 2) == 0) && (bVar1 != 0x2e)) {
          if ((uVar4 & 0x10) == 0) {
            if ((uVar4 & 0x200) == 0) {
LAB_080a5da7:
              puVar14 = (uchar *)0x11c;
            }
            else {
              if (bVar1 == 0x23) {
                if ((dom_css_scanner_info.scan_table[*pbVar16] & 4U) == 0) {
                  if ((dom_css_scanner_info.scan_table[*pbVar16] & 8U) == 0) goto LAB_080a5da7;
                  pbVar13 = pbVar16;
                  if (pbVar16 < scanner->end) {
                    do {
                      pbVar16 = pbVar13 + 1;
                      if (scanner->end <= pbVar16) break;
                      pbVar11 = pbVar13 + 1;
                      pbVar13 = pbVar16;
                    } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar11) & 8) != 0);
                    goto LAB_080a5fb7;
                  }
                  puVar14 = (uchar *)0x10b;
                }
                else {
                  pbVar11 = scanner->end;
                  if (pbVar16 < pbVar11) {
                    do {
                      pbVar16 = pbVar16 + 1;
                      if (pbVar11 <= pbVar16) break;
                    } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar16) & 4) != 0);
                  }
                  if (((pbVar16 + ~(uint)pbVar13 == (byte *)0x6) ||
                      (pbVar16 + ~(uint)pbVar13 == (byte *)0x3)) &&
                     ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar16) & 8) == 0)) {
                    puVar14 = (uchar *)0x10c;
                  }
                  else if ((pbVar16 < pbVar11) &&
                          (pbVar13 = pbVar16,
                          (*(byte *)(dom_css_scanner_info.scan_table + *pbVar16) & 8) != 0)) {
                    do {
                      pbVar16 = pbVar13 + 1;
                      if (pbVar11 <= pbVar16) break;
                      pbVar17 = pbVar13 + 1;
                      pbVar13 = pbVar16;
                    } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar17) & 8) != 0);
LAB_080a5fb7:
                    puVar14 = (uchar *)0x10b;
                  }
                  else {
                    puVar14 = (uchar *)0x10b;
                  }
                }
                goto LAB_080a5ae9;
              }
              if (bVar1 != 0x40) {
                if (bVar1 == 0x2a) {
                  if (*pbVar16 != 0x3d) goto LAB_080a5c7e;
                  pbVar16 = pbVar13 + 2;
                  puVar14 = (uchar *)0x11b;
                  goto LAB_080a5ae9;
                }
                if (bVar1 == 0x5e) {
                  if (*pbVar16 != 0x3d) goto LAB_080a5da7;
                  pbVar16 = pbVar13 + 2;
                  puVar14 = (uchar *)0x119;
                  goto LAB_080a5ae9;
                }
                if (bVar1 == 0x24) {
                  if (*pbVar16 != 0x3d) goto LAB_080a5da7;
                  pbVar16 = pbVar13 + 2;
                  puVar14 = (uchar *)0x11a;
                  goto LAB_080a5ae9;
                }
                if (bVar1 == 0x7c) {
                  if (*pbVar16 != 0x3d) goto LAB_080a5da7;
                  pbVar16 = pbVar13 + 2;
                  puVar14 = (uchar *)0x118;
                  goto LAB_080a5ae9;
                }
                if (bVar1 == 0x21) {
                  if (pbVar16 < scanner->end) {
                    bVar1 = *(byte *)((int)dom_css_scanner_info.scan_table + (uint)*pbVar16 * 4 + 1)
                    ;
                    pbVar13 = pbVar16;
                    while ((pbVar16 = pbVar13, (bVar1 & 4) != 0 &&
                           (pbVar16 = pbVar13 + 1, pbVar16 < scanner->end))) {
                      bVar1 = *(byte *)((int)dom_css_scanner_info.scan_table +
                                       (uint)pbVar13[1] * 4 + 1);
                      pbVar13 = pbVar16;
                    }
                  }
                  iVar12 = c_strncasecmp((char *)pbVar16,"important",9);
                  if (iVar12 == 0) {
                    pbVar16 = pbVar16 + 9;
                    puVar14 = (uchar *)0x116;
                  }
                  else {
                    puVar14 = (uchar *)0x11c;
                  }
                  goto LAB_080a5ae9;
                }
                if ((bVar1 != 0x27) && (bVar1 != 0x22)) {
                  if ((bVar1 != 0x2d) && (bVar1 != 0x3c)) {
                    if (bVar1 == 0x2f) {
                      if (*pbVar16 == 0x2a) {
                        pbVar16 = pbVar13 + 3;
                        for (pbVar13 = pbVar13 + 2; pbVar13 < scanner->end; pbVar13 = pbVar13 + 1) {
                          if ((*pbVar13 == 0x2a) && (*pbVar16 == 0x2f)) {
                            pbVar16 = pbVar13 + 2;
                            puVar14 = (uchar *)0x11d;
                            goto LAB_080a5ae9;
                          }
                          pbVar16 = pbVar16 + 1;
                        }
                        goto LAB_080a65be;
                      }
                    }
                    else {
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                      errline = 0x15a;
                      elinks_internal((uchar *)
                                      "Someone forgot to put code for recognizing tokens which start with \'%c\'."
                                      ,uVar6);
                    }
                    goto LAB_080a5da7;
                  }
                  bVar2 = *pbVar16;
                  if (bVar2 == 0x2f) {
                    puVar14 = (uchar *)0x0;
                    goto LAB_080a5ae9;
                  }
                  if ((pbVar16 < scanner->end) &&
                     (pbVar13 = pbVar16, *(char *)(dom_css_scanner_info.scan_table + bVar2) < '\0'))
                  {
                    do {
                      pbVar11 = pbVar13;
                      pbVar13 = pbVar11 + 1;
                      if (scanner->end <= pbVar13) break;
                    } while (*(char *)(dom_css_scanner_info.scan_table + *pbVar13) < '\0');
                    if (1 < (int)pbVar13 - (int)pbVar16) {
                      if (bVar1 == 0x3c) {
                        if (bVar2 == 0x21) goto LAB_080a65be;
                      }
                      else if ((bVar1 == 0x2d) && (*pbVar11 == 0x3e)) {
LAB_080a65be:
                        pbVar16 = pbVar13;
                        puVar14 = (uchar *)0x11d;
                        goto LAB_080a5ae9;
                      }
                    }
                  }
LAB_080a631a:
                  puVar14 = (uchar *)0x11c;
                  goto LAB_080a5ae9;
                }
                pvVar9 = memchr(pbVar16,uVar6,(int)scanner->end - (int)pbVar16);
                if (pvVar9 == (void *)0x0) goto LAB_080a631a;
                puVar14 = (uchar *)0x103;
                real_length = (int)pvVar9 - (int)pbVar16;
                local_20->tokens = (int)pbVar16;
                pbVar16 = (byte *)((int)pvVar9 + 1);
                goto LAB_080a5ebf;
              }
              if ((dom_css_scanner_info.scan_table[*pbVar16] & 0x10U) == 0) goto LAB_080a5da7;
              pbVar11 = pbVar16;
              if ((pbVar16 < scanner->end) &&
                 ((dom_css_scanner_info.scan_table[*pbVar16] & 8U) != 0)) {
                do {
                  pbVar11 = pbVar11 + 1;
                  if (scanner->end <= pbVar11) break;
                } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar11) & 8) != 0);
              }
              iVar12 = 0x110;
              pbVar13 = pbVar16;
LAB_080a5c1c:
              pbVar16 = pbVar11;
              puVar14 = (uchar *)map_dom_scanner_string(scanner,pbVar13,pbVar16,iVar12);
            }
            goto LAB_080a5ae9;
          }
          pbVar11 = scanner->end;
          for (pbVar17 = pbVar16; pbVar17 < pbVar11; pbVar17 = pbVar17 + 1) {
            bVar1 = *pbVar17;
            if ((*(byte *)(dom_css_scanner_info.scan_table + bVar1) & 8) == 0)
            goto joined_r0x080a5c78;
          }
          bVar1 = *pbVar17;
joined_r0x080a5c78:
          pbVar16 = pbVar17;
          if (bVar1 != 0x28) {
LAB_080a5c7e:
            puVar14 = (uchar *)0x100;
            goto LAB_080a5ae9;
          }
          pbVar16 = pbVar17 + 1;
          local_30 = pbVar16;
          if (pbVar16 < pbVar11) {
            bVar1 = pbVar17[1];
            if (bVar1 == 0x29) goto LAB_080a6102;
            uVar6 = (uint)bVar1;
            if ((uVar6 != 0x7d) && (uVar6 != 0x7b)) {
              while (uVar6 != 0x3b) {
                if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                  __s = local_30 + 1;
                  pvVar9 = memchr(__s,uVar6,(int)pbVar11 - (int)local_30);
                  local_30 = (byte *)((int)pvVar9 + 1);
                  if (pvVar9 == (void *)0x0) {
                    local_30 = __s;
                  }
                }
                else {
                  local_30 = local_30 + 1;
                }
                if (pbVar11 <= local_30) goto LAB_080a608d;
                bVar1 = *local_30;
                if (bVar1 == 0x29) goto LAB_080a6102;
                uVar6 = (uint)bVar1;
                if ((uVar6 == 0x7d) || (uVar6 == 0x7b)) break;
              }
            }
LAB_080a5eb3:
            real_length = -1;
            puVar14 = (uchar *)0x11c;
          }
          else {
LAB_080a608d:
            if (*local_30 != 0x29) goto LAB_080a5eb3;
LAB_080a6102:
            puVar14 = (uchar *)map_dom_scanner_string(scanner,pbVar13,pbVar17,0x10d);
            if (puVar14 == (uchar *)0x10d) {
              real_length = -1;
              pbVar17 = local_30;
LAB_080a613b:
              local_30 = pbVar17;
              if (assert_failed == 0) {
                if ((puVar14 != (uchar *)0x10e) || (*local_30 == 0x28)) {
LAB_080a6157:
                  if ((puVar14 == (uchar *)0x10f) && (*local_30 != 0x29)) {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                    errline = 0xd7;
                    elinks_internal((uchar *)
                                    "assertion type != CSS_TOKEN_URL || *string == \')\' failed!");
                    if (assert_failed != 0) {
                      pbVar16 = local_30 + 1;
                      goto LAB_080a5ebf;
                    }
                  }
                  else {
LAB_080a6490:
                    if ((puVar14 == (uchar *)0x10d) && (*local_30 != 0x29)) {
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                      errline = 0xd8;
                      elinks_internal((uchar *)
                                      "assertion type != CSS_TOKEN_FUNCTION || *string == \')\' failed!"
                                     );
                      pbVar16 = local_30 + 1;
                      goto LAB_080a5ebf;
                    }
                  }
                  assert_failed = 0;
                  pbVar16 = local_30 + 1;
                  goto LAB_080a5ebf;
                }
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                errline = 0xd6;
                elinks_internal((uchar *)
                                "assertion type != CSS_TOKEN_RGB || *string == \'(\' failed!");
                if (assert_failed == 0) goto LAB_080a6490;
              }
            }
            else {
              real_length = -1;
              if (puVar14 != (uchar *)0x10f) goto LAB_080a613b;
              for (; pbVar16 < scanner->end; pbVar16 = pbVar16 + 1) {
                bVar1 = *pbVar16;
                if ((*(byte *)((int)dom_css_scanner_info.scan_table + (uint)bVar1 * 4 + 1) & 4) == 0
                   ) goto LAB_080a64fc;
              }
              bVar1 = *pbVar16;
LAB_080a64fc:
              pbVar13 = local_30;
              do {
                pbVar11 = pbVar13;
                pbVar13 = pbVar11 + -1;
                if (pbVar13 < scanner->string) {
                  bVar2 = *pbVar13;
                  break;
                }
                bVar2 = *pbVar13;
              } while ((*(byte *)((int)dom_css_scanner_info.scan_table + (uint)bVar2 * 4 + 1) & 4)
                       != 0);
              if ((bVar1 == 0x27) || (bVar1 == 0x22)) {
                pbVar16 = pbVar16 + 1;
              }
              if ((bVar2 == 0x27) || (bVar2 == 0x22)) {
                pbVar13 = pbVar11 + -2;
              }
              real_length = (int)(pbVar13 + (1 - (int)pbVar16));
              local_20->tokens = (int)pbVar16;
              if (assert_failed == 0) {
                assert_failed = -(real_length >> 0x1f);
                if (assert_failed != 0) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
                  errline = 0xd2;
                  elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                  pbVar17 = local_30;
                  goto LAB_080a613b;
                }
                goto LAB_080a6157;
              }
            }
            pbVar16 = local_30 + 1;
          }
LAB_080a5ebf:
          local_20->string = puVar14;
          if (real_length < 1) goto LAB_080a5aee;
        }
        else {
          pbVar13 = scanner->end;
          if (pbVar16 < pbVar13) {
            bVar5 = *pbVar16;
            bVar2 = *(byte *)(dom_css_scanner_info.scan_table + bVar5);
            while ((bVar2 & 2) != 0) {
              pbVar16 = pbVar16 + 1;
              if (pbVar13 <= pbVar16) goto LAB_080a5bb7;
              bVar5 = *pbVar16;
              bVar2 = *(byte *)(dom_css_scanner_info.scan_table + bVar5);
            }
          }
          else {
LAB_080a5bb7:
            bVar5 = *pbVar16;
          }
          if (bVar5 == 0x2e) {
            pbVar16 = pbVar16 + 1;
            bVar5 = *pbVar16;
            if ((*(byte *)(dom_css_scanner_info.scan_table + bVar5) & 2) == 0) goto LAB_080a5bc2;
            if (pbVar16 < pbVar13) {
              do {
                pbVar16 = pbVar16 + 1;
                if (pbVar13 <= pbVar16) {
                  bVar5 = *pbVar16;
                  puVar14 = (uchar *)0x101;
                  goto LAB_080a5bc7;
                }
                bVar5 = *pbVar16;
              } while ((*(byte *)(dom_css_scanner_info.scan_table + bVar5) & 2) != 0);
            }
            puVar14 = (uchar *)0x101;
          }
          else {
LAB_080a5bc2:
            puVar14 = (uchar *)0x11c;
          }
LAB_080a5bc7:
          if (bVar5 == 0x25) {
            if (bVar1 != 0x2e) {
              puVar14 = (uchar *)0x102;
            }
            pbVar16 = pbVar16 + 1;
          }
          else {
            if ((dom_css_scanner_info.scan_table[bVar5] & 0x10U) != 0) {
              pbVar11 = pbVar16;
              if ((pbVar16 < pbVar13) && ((dom_css_scanner_info.scan_table[bVar5] & 8U) != 0)) {
                do {
                  pbVar11 = pbVar11 + 1;
                  if (pbVar13 <= pbVar11) break;
                } while ((*(byte *)(dom_css_scanner_info.scan_table + *pbVar11) & 8) != 0);
              }
              iVar12 = 0x105;
              pbVar13 = pbVar16;
              goto LAB_080a5c1c;
            }
            puVar14 = (uchar *)0x101;
          }
LAB_080a5ae9:
          local_20->string = puVar14;
LAB_080a5aee:
          real_length = (int)pbVar16 - (int)local_20->tokens;
        }
        puVar8 = (uchar *)0x400;
        ((dom_string *)&local_20->current)->length = real_length;
        if ((((puVar14 != (uchar *)0x7d) && (puVar8 = (uchar *)0x200, puVar14 != (uchar *)0x7b)) &&
            (puVar8 = (uchar *)0x100, puVar14 != (uchar *)0x3b)) &&
           (puVar8 = (uchar *)0x0, puVar14 == (uchar *)0x29)) {
          puVar8 = (uchar *)0x80;
        }
        local_20->end = puVar8;
        scanner->position = pbVar16;
        if (local_20->string == (uchar *)0x0) {
          scanner->position = (uchar *)0x0;
          local_20 = (dom_scanner *)(local_20[-1].table + 9);
          goto joined_r0x080a5f2f;
        }
        pdVar10 = (dom_scanner *)(local_20[-1].table + 9);
        if (local_20->string != (uchar *)0x11d) {
          pdVar10 = local_20;
        }
        local_20 = (dom_scanner *)&pdVar10->info;
        if ((pdVar15 <= local_20) || (scanner->end < pbVar16 || scanner->end == pbVar16))
        goto joined_r0x080a5f2f;
      } while( true );
    }
  }
  if ((0 < iVar12) && (scanner->current < scanner->table + iVar12)) {
    return scanner->current;
  }
  return (dom_scanner_token *)0x0;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_element_pop(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"</%.*s>",(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_comment_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,&DAT_0812cbf4,(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_proc_instruction_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"<?%.*s %.*s?>",(node->string).length,(node->string).string,
                (node->data).document.document,(node->data).document.children);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_entity_ref_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"&%.*s;",(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_cdata_section_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,"<![CDATA[%.*s]]>",(node->string).length,
                (node->string).string);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_text_push(dom_stack *stack,dom_node *node,void *data)

{
  __fprintf_chk(stack->current->data,1,&DAT_0812cc2d,(node->string).length,(node->string).string);
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_element_push(dom_stack *stack,dom_node *node,void *data)

{
  void *pvVar1;
  dom_node_list *pdVar2;
  uint uVar3;
  uchar *puVar4;
  
  pvVar1 = stack->current->data;
  puVar4 = (node->string).string;
  uVar3 = (node->string).length;
  __fprintf_chk(pvVar1,1,"<%.*s",uVar3,puVar4);
  pdVar2 = (node->data).document.children;
  if ((pdVar2 == (dom_node_list *)0x0) || (pdVar2->size == 0)) {
    __fprintf_chk(pvVar1,1,&DAT_08130b5c,uVar3,puVar4);
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code sgml_file_dumper_attribute_push(dom_stack *stack,dom_node *node,void *data)

{
  byte bVar1;
  void *pvVar2;
  dom_node *pdVar3;
  dom_document *pdVar4;
  dom_node_list *pdVar5;
  dom_node_list *pdVar6;
  
  pvVar2 = stack->current->data;
  if (node->parent->type == 7) {
    return DOM_CODE_OK;
  }
  pdVar5 = (dom_node_list *)(node->string).string;
  pdVar4 = (dom_document *)(node->string).length;
  __fprintf_chk(pvVar2,1,&DAT_0812cc2c,pdVar4,pdVar5);
  pdVar6 = (node->data).document.children;
  if (pdVar6 != (dom_node_list *)0x0) {
    bVar1 = (node->data).attribute.quoted;
    if (bVar1 == 0) {
      pdVar4 = (node->data).document.document;
      __fprintf_chk(pvVar2,1,"=\"%.*s\"",pdVar4,pdVar6);
      pdVar3 = get_dom_node_next(node);
      pdVar5 = pdVar6;
      goto joined_r0x080a68d5;
    }
    pdVar4 = (dom_document *)(uint)bVar1;
    pdVar5 = (dom_node_list *)(node->data).document.document;
    __fprintf_chk(pvVar2,1,&DAT_0812cc32,pdVar4,pdVar5,pdVar6,pdVar4);
  }
  pdVar3 = get_dom_node_next(node);
joined_r0x080a68d5:
  if (pdVar3 == (dom_node *)0x0) {
    __fprintf_chk(pvVar2,1,&DAT_08130b5c,pdVar4,pdVar5);
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_stack_context * add_sgml_file_dumper(dom_stack *stack,FILE *file)

{
  dom_stack_context *pdVar1;
  
  pdVar1 = add_dom_stack_context(stack,file,&sgml_file_dumper);
  return pdVar1;
}



// WARNING: Unknown calling convention

void done_sgml_parser(sgml_parser *parser)

{
  dom_stack_state *pdVar1;
  uchar *p;
  
  pdVar1 = (parser->parsing).states;
  while ((pdVar1 != (dom_stack_state *)0x0 && ((parser->parsing).depth != 0))) {
    pop_dom_node(&parser->parsing);
    pdVar1 = (parser->parsing).states;
  }
  done_dom_stack(&parser->parsing);
  done_dom_stack(&parser->stack);
  p = (parser->uri).string;
  if (p != (uchar *)0x0) {
    mem_free(p);
  }
  (parser->uri).string = (uchar *)0x0;
  (parser->uri).length = 0;
  mem_free(parser);
  return;
}



// WARNING: Unknown calling convention

dom_string * add_to_dom_string(dom_string *string,uchar *str,size_t len)

{
  uchar *puVar1;
  uint uVar2;
  
  puVar1 = (uchar *)mem_realloc(string->string,len + 1 + string->length);
  if (puVar1 == (uchar *)0x0) {
    string = (dom_string *)0x0;
  }
  else {
    string->string = puVar1;
    memcpy(puVar1 + string->length,str,len);
    uVar2 = len + string->length;
    string->length = uVar2;
    string->string[uVar2] = '\0';
  }
  return string;
}



// WARNING: Unknown calling convention

dom_code check_sgml_incomplete
                   (dom_scanner *scanner,dom_scanner_token *start,dom_scanner_token *token)

{
  uchar *__s;
  size_t left;
  size_t sVar1;
  
  if (token == (dom_scanner_token *)0x0) {
    if ((scanner->field_0x18 & 3) == 3) {
      sVar1 = (int)scanner->end - (int)(start->string).string;
      if ((assert_failed == 0) && (assert_failed = (int)(sVar1 == 0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 0xbd;
        elinks_internal((uchar *)"assertion left > 0 failed!");
      }
      scanner->current = scanner->table;
      scanner->tokens = 1;
      scanner->table[0].type = 0x117;
      __s = (start->string).string;
      scanner->table[0].string.string = __s;
      if (sVar1 == 0xffffffff) {
        sVar1 = strlen((char *)__s);
      }
      scanner->table[0].string.length = sVar1;
      return DOM_CODE_INDEX_SIZE_ERR;
    }
  }
  else if (token->type == 0x117) {
    (token->string).length =
         (uint)((token->string).string + ((token->string).length - (int)(start->string).string));
    (token->string).string = (start->string).string;
    return DOM_CODE_INDEX_SIZE_ERR;
  }
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

dom_code parse_sgml(sgml_parser *parser,uchar *buf,size_t bufsize,int complete)

{
  undefined *puVar1;
  size_t sVar2;
  dom_stack_state *pdVar3;
  dom_node *pdVar4;
  dom_node *node;
  dom_code dVar5;
  dom_node *node_1;
  dom_string source;
  
  source.length = bufsize;
  source.string = buf;
  if (complete != 0) {
    parser->flags = parser->flags | SGML_PARSER_COMPLETE;
  }
  if (parser->root == (dom_node *)0x0) {
    pdVar4 = init_dom_node_at((dom_node *)0x0,DOM_NODE_DOCUMENT,&parser->uri,
                              parser->flags & SGML_PARSER_INCREMENTAL);
    if ((pdVar4 == (dom_node *)0x0) ||
       (dVar5 = push_dom_node(&parser->stack,pdVar4), dVar5 != DOM_CODE_OK)) {
      parser->root = (dom_node *)0x0;
      return DOM_CODE_ALLOC_ERR;
    }
    sVar2 = (parser->stack).depth;
    pdVar3 = (parser->stack).states;
    parser->root = pdVar4;
    puVar1 = &pdVar3[sVar2 - 1].field_0x8;
    *puVar1 = *puVar1 | 1;
  }
  pdVar4 = init_dom_node_at((dom_node *)0x0,DOM_NODE_TEXT,&source,0);
  if ((pdVar4 != (dom_node *)0x0) &&
     (dVar5 = push_dom_node(&parser->parsing,pdVar4), dVar5 == DOM_CODE_OK)) {
    return parser->code;
  }
  return DOM_CODE_ALLOC_ERR;
}



// WARNING: Unknown calling convention

dom_code sgml_parsing_pop(dom_stack *stack,dom_node *node,void *data)

{
  byte *pbVar1;
  void *pvVar2;
  sgml_parser *parser;
  
  pvVar2 = (*stack->contexts)->data;
  if (((*(byte *)((int)pvVar2 + 4) & 2) != 0) &&
     (*(uint *)((int)data + 0x100) < *(uint *)((int)pvVar2 + 0x24))) {
    do {
      pbVar1 = (byte *)(*(int *)((int)pvVar2 + 0x20) + 8 +
                       (*(int *)((int)pvVar2 + 0x24) * 3 + -3) * 4);
      *pbVar1 = *pbVar1 & 0xfe;
      pop_dom_node((dom_stack *)((int)pvVar2 + 0x20));
    } while (*(uint *)((int)data + 0x100) < *(uint *)((int)pvVar2 + 0x24));
  }
  if (*(void **)((int)data + 0xfc) != (void *)0x0) {
    mem_free(*(void **)((int)data + 0xfc));
  }
  *(undefined4 *)((int)data + 0xfc) = 0;
  *(undefined4 *)((int)data + 0xf8) = 0;
  return DOM_CODE_OK;
}



// WARNING: Unknown calling convention

uint get_sgml_parser_line_number(sgml_parser *parser)

{
  dom_stack_context *pdVar1;
  size_t sVar2;
  int *piVar3;
  uint uVar4;
  int iVar5;
  size_t object_size;
  uchar *puVar6;
  size_t sVar7;
  dom_stack_state *pdVar8;
  
  if ((assert_failed == 0) &&
     (assert_failed = parser->flags & SGML_PARSER_COUNT_LINES ^ SGML_PARSER_COUNT_LINES,
     assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
    errline = 0x26f;
    elinks_internal((uchar *)"assertion parser->flags & SGML_PARSER_COUNT_LINES failed!");
  }
  iVar5 = assert_failed;
  pdVar8 = (parser->parsing).states;
  if ((pdVar8 == (dom_stack_state *)0x0) || (sVar7 = (parser->parsing).depth, sVar7 == 0)) {
    uVar4 = 0;
  }
  else {
    if (assert_failed == 0) {
      assert_failed = 0;
      pdVar8 = (parser->parsing).states;
      sVar7 = (parser->parsing).depth;
    }
    puVar6 = (uchar *)0x0;
    pdVar1 = *(parser->parsing).contexts;
    sVar2 = pdVar1->info->object_size;
    if (sVar2 != 0) {
      if ((iVar5 == 0) &&
         (assert_failed = (int)(pdVar1->state_objects == (uchar *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 0xc6;
        elinks_internal((uchar *)"assertion context->state_objects failed!");
        iVar5 = assert_failed;
      }
      puVar6 = pdVar1->state_objects + sVar2 * pdVar8[sVar7 - 1].depth;
    }
    if (iVar5 == 0) {
      if (((puVar6[0x20] & 1) == 0) || (*(int *)(puVar6 + 0x24) == 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 0x277;
        elinks_internal((uchar *)
                        "assertion pstate->scanner.count_lines && pstate->scanner.lineno failed!");
      }
      else {
        assert_failed = 0;
      }
    }
    piVar3 = *(int **)(puVar6 + 0xc);
    if (((piVar3 == (int *)0x0) || (puVar6 + 0xf4 <= piVar3)) || (*piVar3 != 0x118)) {
      uVar4 = *(uint *)(puVar6 + 0x24);
    }
    else {
      uVar4 = piVar3[2];
    }
  }
  return uVar4;
}



// WARNING: Unknown calling convention

dom_code call_sgml_error_function(dom_stack *stack,dom_scanner_token *token)

{
  sgml_parser *parser_00;
  uint uVar1;
  uint line;
  sgml_parser *parser;
  
  parser_00 = (sgml_parser *)(*stack->contexts)->data;
  uVar1 = get_sgml_parser_line_number(parser_00);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(parser_00->error_func == (sgml_error_T)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
    errline = 0xa5;
    elinks_internal((uchar *)"assertion parser->error_func failed!");
  }
  line = (*parser_00->error_func)(parser_00,&token->string,uVar1);
  return line;
}



// WARNING: Unknown calling convention

sgml_parser *
init_sgml_parser(sgml_parser_type type,sgml_document_type doctype,dom_string *uri,
                sgml_parser_flag flags)

{
  uchar *__src;
  size_t __n;
  sgml_parser *p;
  sgml_parser *parser;
  uchar *puVar1;
  sgml_info *psVar2;
  sgml_parser *psVar3;
  uint uVar4;
  
  p = (sgml_parser *)mem_calloc(1,0x50);
  psVar3 = p;
  if (p != (sgml_parser *)0x0) {
    __src = uri->string;
    __n = uri->length;
    puVar1 = (uchar *)mem_realloc((p->uri).string,(p->uri).length + __n + 1);
    if (puVar1 == (uchar *)0x0) {
      psVar3 = (sgml_parser *)0x0;
      mem_free(p);
    }
    else {
      (p->uri).string = puVar1;
      memcpy(puVar1 + (p->uri).length,__src,__n);
      uVar4 = __n + (p->uri).length;
      (p->uri).length = uVar4;
      (p->uri).string[uVar4] = '\0';
      if ((flags & SGML_PARSER_DETECT_ERRORS) != 0) {
        flags = flags | SGML_PARSER_COUNT_LINES;
      }
      p->flags = flags;
      p->type = type;
      psVar2 = get_sgml_info(doctype);
      p->info = psVar2;
      init_dom_stack(&p->stack,(uint)(type == SGML_PARSER_STREAM));
      add_dom_stack_context(&p->stack,p,&sgml_parser_context_info);
      init_dom_stack(&p->parsing,DOM_STACK_FLAG_FREE_NODES);
      add_dom_stack_context(&p->parsing,p,&sgml_parsing_context_info);
    }
  }
  return psVar3;
}



// WARNING: Unknown calling convention
// Local variable node_1:dom_node *[EAX:4] conflicts with parameter, skipped.

dom_code parse_sgml_plain(dom_stack *stack,dom_scanner *scanner)

{
  byte *pbVar1;
  byte bVar2;
  dom_stack_context *pdVar3;
  void *pvVar4;
  byte bVar5;
  size_t *psVar6;
  dom_node *pdVar7;
  dom_node *node_5;
  dom_code dVar8;
  dom_code code;
  dom_code code_2;
  dom_node *node_3;
  dom_node *node_2;
  dom_stack_state *state;
  dom_stack_state *pdVar9;
  size_t *psVar10;
  void *match_2;
  size_t sVar11;
  size_t **ppsVar12;
  dom_node *parent_1;
  void *match_1;
  uint uVar13;
  dom_code code_1;
  dom_node *parent;
  dom_node *pdVar14;
  void *match;
  dom_string *pdVar15;
  dom_stack_state *state_1;
  size_t object_size;
  dom_scanner_token *token_00;
  int iVar16;
  dom_node *node_7;
  uchar *puVar17;
  dom_scanner_token *token;
  dom_scanner_token *pdVar18;
  dom_node *node;
  dom_scanner_token *pdVar19;
  sgml_node_info *info;
  sgml_node_info *info_1;
  dom_node_list *pdVar20;
  size_t *psVar21;
  byte bVar22;
  dom_node_type type;
  dom_scanner_token *local_144;
  dom_scanner attr_scanner;
  dom_scanner_token name;
  dom_scanner_token target;
  
  bVar22 = 0;
  iVar16 = scanner->tokens;
LAB_080a6fa0:
  if ((iVar16 < 1) || (pdVar19 = scanner->current, scanner->table + iVar16 <= pdVar19)) {
    return DOM_CODE_OK;
  }
  switch(pdVar19->type) {
  case 0x103:
  case 0x105:
  case 0x106:
  case 0x107:
  case 0x108:
    scanner->current = pdVar19 + 1;
    if (scanner->table + iVar16 <= pdVar19 + 2) goto LAB_080a715b;
    goto LAB_080a6fa0;
  case 0x104:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    type = DOM_NODE_COMMENT;
    sVar11 = stack->depth;
    break;
  case 0x109:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    type = DOM_NODE_CDATA_SECTION;
    sVar11 = stack->depth;
    break;
  case 0x10a:
  case 0x10b:
  case 0x10c:
    target.type = pdVar19->type;
    target.precedence = pdVar19->precedence;
    target.lineno = pdVar19->lineno;
    target.string.length = (pdVar19->string).length;
    target.string.string = (pdVar19->string).string;
    if (iVar16 < 1) {
      code_2 = DOM_CODE_INCOMPLETE;
      return code_2;
    }
    pdVar18 = scanner->table + iVar16;
    if (pdVar18 <= pdVar19) {
      code_2 = DOM_CODE_INCOMPLETE;
      return code_2;
    }
    local_144 = pdVar19 + 1;
    scanner->current = local_144;
    if (pdVar19 + 2 < pdVar18) {
      if (pdVar18 <= local_144) {
        code_2 = DOM_CODE_INCOMPLETE;
        return code_2;
      }
    }
    else {
      local_144 = (*scanner->info->scan)(scanner);
    }
    if (local_144 == (dom_scanner_token *)0x0) {
      code_2 = DOM_CODE_INCOMPLETE;
      return code_2;
    }
    iVar16 = local_144->type;
    if (iVar16 == 0x117) {
      code_2 = DOM_CODE_INCOMPLETE;
      return code_2;
    }
    if (iVar16 != 0x118) {
      if (assert_failed == 0) {
        assert_failed = (int)(iVar16 != 0x10d);
        if (iVar16 != 0x10d) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
          errline = 0x16e;
          elinks_internal((uchar *)"assertion token->type == SGML_TOKEN_PROCESS_DATA failed!");
          if (assert_failed != 0) goto LAB_080a7879;
        }
        assert_failed = 0;
      }
LAB_080a7879:
      pdVar7 = init_dom_node_at(stack->states[stack->depth - 1].node,DOM_NODE_PROCESSING_INSTRUCTION
                                ,&target.string,-1);
      if (pdVar7 == (dom_node *)0x0) {
        code_2 = DOM_CODE_ALLOC_ERR;
        return code_2;
      }
      bVar2 = pdVar7->field_0x2;
      if ((bVar2 & 1) == 0) {
        uVar13 = (local_144->string).length;
        pdVar20 = (dom_node_list *)(local_144->string).string;
        (pdVar7->data).document.children = pdVar20;
        if (uVar13 == 0xffffffff) {
          do {
            if (uVar13 == 0) break;
            uVar13 = uVar13 - 1;
            psVar6 = &pdVar20->size;
            pdVar20 = (dom_node_list *)((int)pdVar20 + (uint)bVar22 * -2 + 1);
          } while ((bVar2 & 1) != *(byte *)psVar6);
          uVar13 = ~uVar13 - 1;
        }
        (pdVar7->data).attribute.value.length = uVar13;
      }
      else {
        pdVar15 = add_to_dom_string((dom_string *)&(pdVar7->data).document,
                                    (local_144->string).string,(local_144->string).length);
        if (pdVar15 == (dom_string *)0x0) {
          done_dom_node(pdVar7);
          code_2 = DOM_CODE_ALLOC_ERR;
          return code_2;
        }
      }
      if (target.type == 0x10b) {
        (pdVar7->data).element.namespace_offset = 1;
      }
      else {
        (pdVar7->data).element.namespace_offset = (ushort)(target.type == 0x10c) * 2;
      }
      dVar8 = push_dom_node(stack,pdVar7);
      if (dVar8 != DOM_CODE_OK) {
        code_2 = DOM_CODE_ALLOC_ERR;
        return code_2;
      }
      if ((((target.type - 0x10bU < 2) && ((local_144->string).length != 0)) &&
          (init_dom_scanner(&attr_scanner,&sgml_scanner_info,&local_144->string,1,
                            (byte)scanner->field_0x20 & 1,1,0,0), 0 < attr_scanner.tokens)) &&
         (attr_scanner.current < attr_scanner.table + attr_scanner.tokens)) {
        while (pdVar19 = attr_scanner.current,
              attr_scanner.current < attr_scanner.table + attr_scanner.tokens) {
          if ((assert_failed == 0) &&
             (assert_failed = (int)(attr_scanner.current == (dom_scanner_token *)0x0),
             assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
            errline = 0xd1;
            elinks_internal((uchar *)"assertion token failed!");
          }
          iVar16 = pdVar19->type;
          if (iVar16 < 0x112) {
            if (0x10d < iVar16) break;
            if (iVar16 == 0x100) {
              pdVar18 = &name;
              for (iVar16 = 5; iVar16 != 0; iVar16 = iVar16 + -1) {
                pdVar18->type = pdVar19->type;
                pdVar19 = (dom_scanner_token *)((int)pdVar19 + (uint)bVar22 * -8 + 4);
                pdVar18 = (dom_scanner_token *)((int)pdVar18 + (uint)bVar22 * -8 + 4);
              }
              if ((attr_scanner.tokens < 1) ||
                 (pdVar19 = attr_scanner.table + attr_scanner.tokens,
                 pdVar19 <= attr_scanner.current)) {
LAB_080a8170:
                pdVar18 = (dom_scanner_token *)0x0;
LAB_080a7e36:
                dVar8 = check_sgml_incomplete(&attr_scanner,&name,pdVar18);
                if (dVar8 != DOM_CODE_OK) break;
LAB_080a7e4a:
                pdVar18 = (dom_scanner_token *)0x0;
              }
              else {
                pdVar18 = attr_scanner.current + 1;
                if (attr_scanner.current + 2 < pdVar19) {
                  attr_scanner.current = pdVar18;
                  if (pdVar19 <= pdVar18) goto LAB_080a8170;
                }
                else {
                  attr_scanner.current = pdVar18;
                  pdVar18 = (*(attr_scanner.info)->scan)(&attr_scanner);
                }
                if ((pdVar18 == (dom_scanner_token *)0x0) || (pdVar18->type != 0x3d))
                goto LAB_080a7e36;
                if ((attr_scanner.tokens < 1) ||
                   (pdVar19 = attr_scanner.table + attr_scanner.tokens,
                   pdVar19 <= attr_scanner.current)) {
LAB_080a80cc:
                  pdVar18 = (dom_scanner_token *)0x0;
                }
                else {
                  pdVar18 = attr_scanner.current + 1;
                  if (attr_scanner.current + 2 < pdVar19) {
                    attr_scanner.current = pdVar18;
                    if (pdVar19 <= pdVar18) goto LAB_080a80cc;
                  }
                  else {
                    attr_scanner.current = pdVar18;
                    pdVar18 = (*(attr_scanner.info)->scan)(&attr_scanner);
                  }
                }
                dVar8 = check_sgml_incomplete(&attr_scanner,&name,pdVar18);
                if (dVar8 != DOM_CODE_OK) break;
                if ((((pdVar18 != (dom_scanner_token *)0x0) &&
                     (iVar16 = pdVar18->type, iVar16 != 0x100)) && (iVar16 != 0x112)) &&
                   (iVar16 != 0x102)) goto LAB_080a7e4a;
              }
              pvVar4 = (*stack->contexts)->data;
              if (assert_failed == 0) {
                assert_failed = 0;
              }
              pdVar7 = stack->states[stack->depth - 1].node;
              if (pdVar18 == (dom_scanner_token *)0x0) {
                pdVar7 = init_dom_node_at(pdVar7,DOM_NODE_ATTRIBUTE,&name.string,-1);
              }
              else {
                pdVar14 = init_dom_node_at(pdVar7,DOM_NODE_ATTRIBUTE,&name.string,-1);
                pdVar7 = pdVar14;
                if (pdVar14 != (dom_node *)0x0) {
                  if ((pdVar14->field_0x2 & 1) == 0) {
                    uVar13 = (pdVar18->string).length;
                    pdVar20 = (dom_node_list *)(pdVar18->string).string;
                    (pdVar14->data).document.children = pdVar20;
                    if (uVar13 == 0xffffffff) {
                      do {
                        if (uVar13 == 0) break;
                        uVar13 = uVar13 - 1;
                        psVar6 = &pdVar20->size;
                        pdVar20 = (dom_node_list *)((int)pdVar20 + (uint)bVar22 * -2 + 1);
                      } while (*(char *)psVar6 != '\0');
                      uVar13 = ~uVar13 - 1;
                    }
                    (pdVar14->data).attribute.value.length = uVar13;
                  }
                  else {
                    pdVar15 = add_to_dom_string((dom_string *)&(pdVar14->data).document,
                                                (pdVar18->string).string,(pdVar18->string).length);
                    if (pdVar15 == (dom_string *)0x0) {
                      pdVar7 = (dom_node *)0x0;
                      done_dom_node(pdVar14);
                    }
                  }
                }
              }
              psVar21 = *(size_t **)(*(int *)((int)pvVar4 + 8) + 4);
              psVar10 = (size_t *)bsearch(pdVar7,psVar21 + 3,*psVar21,0xc,sgml_info_strcmp);
              if (psVar10 != (size_t *)0x0) {
                psVar21 = psVar10;
              }
              (pdVar7->data).element.type = *(uint16_t *)(psVar21 + 2);
              bVar2 = *(byte *)((int)&pdVar7->data + 0xd);
              bVar5 = (byte)((*(ushort *)((int)psVar21 + 10) & 1) << 2);
              *(byte *)((int)&pdVar7->data + 0xd) = bVar2 & 0xfb | bVar5;
              *(byte *)((int)&pdVar7->data + 0xd) =
                   bVar2 & 0xf3 | bVar5 | (byte)((*(ushort *)((int)psVar21 + 10) >> 1 & 1) << 3);
              if ((pdVar18 != (dom_scanner_token *)0x0) && (pdVar18->type == 0x102)) {
                (pdVar7->data).attribute.quoted = (pdVar18->string).string[-1];
              }
              dVar8 = push_dom_node(stack,pdVar7);
              if (dVar8 != DOM_CODE_OK) break;
              pop_dom_node(stack);
              if (pdVar18 != (dom_scanner_token *)0x0) {
                if (attr_scanner.tokens < 1) break;
                if ((attr_scanner.current < attr_scanner.table + attr_scanner.tokens) &&
                   (pdVar19 = attr_scanner.current + 1, pdVar18 = attr_scanner.current + 2,
                   attr_scanner.current = pdVar19,
                   attr_scanner.table + attr_scanner.tokens <= pdVar18)) {
                  (*(attr_scanner.info)->scan)(&attr_scanner);
                }
              }
            }
            else {
              if (iVar16 == 0x101) {
                if (((0 < attr_scanner.tokens) &&
                    (attr_scanner.current < attr_scanner.table + attr_scanner.tokens)) &&
                   (pdVar19 = attr_scanner.current + 1, pdVar18 = attr_scanner.current + 2,
                   attr_scanner.current = pdVar19,
                   attr_scanner.table + attr_scanner.tokens <= pdVar18)) {
                  (*(attr_scanner.info)->scan)(&attr_scanner);
                }
                break;
              }
LAB_080a7b5d:
              if (attr_scanner.tokens < 1) break;
              if ((attr_scanner.current < attr_scanner.table + attr_scanner.tokens) &&
                 (pdVar19 = attr_scanner.current + 1, pdVar18 = attr_scanner.current + 2,
                 attr_scanner.current = pdVar19, attr_scanner.table + attr_scanner.tokens <= pdVar18
                 )) {
                (*(attr_scanner.info)->scan)(&attr_scanner);
              }
            }
          }
          else {
            if (iVar16 == 0x117) break;
            if (iVar16 != 0x118) goto LAB_080a7b5d;
            dVar8 = call_sgml_error_function(stack,pdVar19);
            if ((dVar8 != DOM_CODE_OK) || (attr_scanner.tokens < 1)) break;
            if ((attr_scanner.current < attr_scanner.table + attr_scanner.tokens) &&
               (pdVar19 = attr_scanner.current + 1, pdVar18 = attr_scanner.current + 2,
               attr_scanner.current = pdVar19, attr_scanner.table + attr_scanner.tokens <= pdVar18))
            {
              (*(attr_scanner.info)->scan)(&attr_scanner);
            }
          }
          if (attr_scanner.tokens < 1) break;
        }
      }
      pop_dom_node(stack);
      iVar16 = scanner->tokens;
      goto joined_r0x080a7183;
    }
    goto switchD_080a7600_caseD_10e;
  default:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    pdVar7 = init_dom_node_at(stack->states[stack->depth - 1].node,DOM_NODE_TEXT,&pdVar19->string,-1
                             );
    if (pdVar7 != (dom_node *)0x0) {
      if (pdVar19->type == 0x115) {
        pbVar1 = (byte *)((int)&pdVar7->data + 4);
        *pbVar1 = *pbVar1 | 1;
      }
      dVar8 = push_dom_node(stack,pdVar7);
      if (dVar8 == DOM_CODE_OK) {
        pop_dom_node(stack);
      }
    }
    goto LAB_080a7039;
  case 0x10e:
  case 0x10f:
    pvVar4 = (*stack->contexts)->data;
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    pdVar7 = init_dom_node_at(stack->states[stack->depth - 1].node,DOM_NODE_ELEMENT,&pdVar19->string
                              ,-1);
    if (pdVar7 == (dom_node *)0x0) {
      code_2 = DOM_CODE_ALLOC_ERR;
      return code_2;
    }
    psVar21 = *(size_t **)(*(int *)((int)pvVar4 + 8) + 8);
    psVar10 = (size_t *)bsearch(pdVar7,psVar21 + 3,*psVar21,0xc,sgml_info_strcmp);
    if (psVar10 != (size_t *)0x0) {
      psVar21 = psVar10;
    }
    (pdVar7->data).element.type = *(uint16_t *)(psVar21 + 2);
    dVar8 = push_dom_node(stack,pdVar7);
    if (dVar8 != DOM_CODE_OK) {
      code_2 = DOM_CODE_ALLOC_ERR;
      return code_2;
    }
    if (assert_failed == 0) {
      pdVar9 = stack->states + (stack->depth - 1);
      assert_failed = (int)(pdVar7 != pdVar9->node);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 0x46;
        elinks_internal((uchar *)"assertion node == state->node failed!");
      }
    }
    else {
      pdVar9 = stack->states + (stack->depth - 1);
    }
    pdVar3 = *stack->contexts;
    sVar11 = pdVar3->info->object_size;
    ppsVar12 = (size_t **)0x0;
    if (sVar11 != 0) {
      if ((assert_failed == 0) &&
         (assert_failed = (int)(pdVar3->state_objects == (uchar *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 0xc6;
        elinks_internal((uchar *)"assertion context->state_objects failed!");
      }
      ppsVar12 = (size_t **)(pdVar3->state_objects + sVar11 * pdVar9->depth);
    }
    *ppsVar12 = psVar21;
    if (pdVar19->type == 0x10f) {
      iVar16 = scanner->tokens;
      if (0 < iVar16) {
        pdVar19 = scanner->current;
        if ((pdVar19 < scanner->table + iVar16) &&
           (scanner->current = pdVar19 + 1, scanner->table + iVar16 <= pdVar19 + 2))
        goto LAB_080a75ee;
        do {
          if ((iVar16 < 1) || (pdVar19 = scanner->current, scanner->table + iVar16 <= pdVar19))
          break;
          if ((assert_failed == 0) &&
             (assert_failed = (int)(pdVar19 == (dom_scanner_token *)0x0), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
            errline = 0xd1;
            elinks_internal((uchar *)"assertion token failed!");
          }
          switch(pdVar19->type) {
          case 0x100:
            name.type = pdVar19->type;
            name.precedence = pdVar19->precedence;
            name.lineno = pdVar19->lineno;
            name.string.length = (pdVar19->string).length;
            name.string.string = (pdVar19->string).string;
            if (scanner->tokens < 1) {
LAB_080a79d3:
              token_00 = (dom_scanner_token *)0x0;
LAB_080a7696:
              dVar8 = check_sgml_incomplete(scanner,&name,token_00);
              if (dVar8 != DOM_CODE_OK) {
                code_2 = DOM_CODE_INCOMPLETE;
                return code_2;
              }
LAB_080a76a8:
              local_144 = (dom_scanner_token *)0x0;
            }
            else {
              pdVar18 = scanner->current;
              pdVar19 = scanner->table + scanner->tokens;
              if (pdVar19 <= pdVar18) goto LAB_080a79d3;
              token_00 = pdVar18 + 1;
              scanner->current = token_00;
              if (pdVar18 + 2 < pdVar19) {
                if (pdVar19 <= token_00) goto LAB_080a79d3;
              }
              else {
                token_00 = (*scanner->info->scan)(scanner);
              }
              if ((token_00 == (dom_scanner_token *)0x0) || (token_00->type != 0x3d))
              goto LAB_080a7696;
              if (scanner->tokens < 1) {
LAB_080a7d30:
                local_144 = (dom_scanner_token *)0x0;
              }
              else {
                pdVar18 = scanner->current;
                pdVar19 = scanner->table + scanner->tokens;
                if (pdVar19 <= pdVar18) goto LAB_080a7d30;
                local_144 = pdVar18 + 1;
                scanner->current = local_144;
                if (pdVar18 + 2 < pdVar19) {
                  if (pdVar19 <= local_144) goto LAB_080a7d30;
                }
                else {
                  local_144 = (*scanner->info->scan)(scanner);
                }
              }
              dVar8 = check_sgml_incomplete(scanner,&name,local_144);
              if (dVar8 != DOM_CODE_OK) {
                code_2 = DOM_CODE_INCOMPLETE;
                return code_2;
              }
              if ((((local_144 != (dom_scanner_token *)0x0) &&
                   (iVar16 = local_144->type, iVar16 != 0x100)) && (iVar16 != 0x112)) &&
                 (iVar16 != 0x102)) goto LAB_080a76a8;
            }
            pvVar4 = (*stack->contexts)->data;
            if (assert_failed == 0) {
              assert_failed = 0;
            }
            pdVar7 = stack->states[stack->depth - 1].node;
            if (local_144 == (dom_scanner_token *)0x0) {
              pdVar7 = init_dom_node_at(pdVar7,DOM_NODE_ATTRIBUTE,&name.string,-1);
            }
            else {
              pdVar14 = init_dom_node_at(pdVar7,DOM_NODE_ATTRIBUTE,&name.string,-1);
              pdVar7 = pdVar14;
              if (pdVar14 != (dom_node *)0x0) {
                bVar2 = pdVar14->field_0x2;
                if ((bVar2 & 1) == 0) {
                  uVar13 = (local_144->string).length;
                  pdVar20 = (dom_node_list *)(local_144->string).string;
                  (pdVar14->data).document.children = pdVar20;
                  if (uVar13 == 0xffffffff) {
                    do {
                      if (uVar13 == 0) break;
                      uVar13 = uVar13 - 1;
                      psVar6 = &pdVar20->size;
                      pdVar20 = (dom_node_list *)((int)pdVar20 + (uint)bVar22 * -2 + 1);
                    } while ((bVar2 & 1) != *(byte *)psVar6);
                    uVar13 = ~uVar13 - 1;
                  }
                  (pdVar14->data).attribute.value.length = uVar13;
                }
                else {
                  pdVar15 = add_to_dom_string((dom_string *)&(pdVar14->data).document,
                                              (local_144->string).string,(local_144->string).length)
                  ;
                  if (pdVar15 == (dom_string *)0x0) {
                    pdVar7 = (dom_node *)0x0;
                    done_dom_node(pdVar14);
                  }
                }
              }
            }
            psVar21 = *(size_t **)(*(int *)((int)pvVar4 + 8) + 4);
            psVar10 = (size_t *)bsearch(pdVar7,psVar21 + 3,*psVar21,0xc,sgml_info_strcmp);
            if (psVar10 != (size_t *)0x0) {
              psVar21 = psVar10;
            }
            (pdVar7->data).element.type = *(uint16_t *)(psVar21 + 2);
            bVar2 = *(byte *)((int)&pdVar7->data + 0xd);
            bVar5 = (byte)((*(ushort *)((int)psVar21 + 10) & 1) << 2);
            *(byte *)((int)&pdVar7->data + 0xd) = bVar2 & 0xfb | bVar5;
            *(byte *)((int)&pdVar7->data + 0xd) =
                 bVar2 & 0xf3 | bVar5 | (byte)((*(ushort *)((int)psVar21 + 10) >> 1 & 1) << 3);
            if ((local_144 != (dom_scanner_token *)0x0) && (local_144->type == 0x102)) {
              (pdVar7->data).attribute.quoted = (local_144->string).string[-1];
            }
            dVar8 = push_dom_node(stack,pdVar7);
            if (dVar8 != DOM_CODE_OK) {
              code_2 = DOM_CODE_ALLOC_ERR;
              return code_2;
            }
            pop_dom_node(stack);
            if (local_144 == (dom_scanner_token *)0x0) goto LAB_080a75f7;
            iVar16 = scanner->tokens;
            if (0 < iVar16) {
              pdVar19 = scanner->current;
              if ((pdVar19 < scanner->table + iVar16) &&
                 (scanner->current = pdVar19 + 1, scanner->table + iVar16 <= pdVar19 + 2)) {
                (*scanner->info->scan)(scanner);
                iVar16 = scanner->tokens;
              }
            }
            break;
          case 0x101:
            iVar16 = scanner->tokens;
            if (0 < iVar16) goto LAB_080a7138;
            goto LAB_080a6fa0;
          case 0x10e:
          case 0x10f:
          case 0x110:
          case 0x111:
            goto switchD_080a7600_caseD_10e;
          case 0x117:
            goto switchD_080a7078_caseD_117;
          case 0x118:
            code_2 = call_sgml_error_function(stack,pdVar19);
            if (code_2 != DOM_CODE_OK) {
              return code_2;
            }
          default:
            iVar16 = scanner->tokens;
            if (0 < iVar16) {
              pdVar19 = scanner->current;
              if ((pdVar19 < scanner->table + iVar16) &&
                 (scanner->current = pdVar19 + 1, scanner->table + iVar16 <= pdVar19 + 2)) {
LAB_080a75ee:
                (*scanner->info->scan)(scanner);
LAB_080a75f7:
                iVar16 = scanner->tokens;
              }
            }
          }
        } while( true );
      }
    }
    else {
      iVar16 = scanner->tokens;
      if (iVar16 < 1) {
        return DOM_CODE_OK;
      }
      pdVar19 = scanner->current;
      if ((pdVar19 < scanner->table + iVar16) &&
         (scanner->current = pdVar19 + 1, scanner->table + iVar16 <= pdVar19 + 2))
      goto LAB_080a715b;
    }
    goto LAB_080a6fa0;
  case 0x110:
    uVar13 = (pdVar19->string).length;
    if (uVar13 == 0) {
      pop_dom_node(stack);
    }
    else {
      name.precedence = (int)(pdVar19->string).string;
      if (uVar13 == 0xffffffff) {
        uVar13 = strlen((char *)name.precedence);
      }
      name.type = uVar13;
      pdVar9 = search_dom_stack(stack,DOM_NODE_ELEMENT,(dom_string *)&name);
      if (pdVar9 != (dom_stack_state *)0x0) {
        pdVar3 = *stack->contexts;
        sVar11 = pdVar3->info->object_size;
        puVar17 = (uchar *)0x0;
        if (sVar11 != 0) {
          if ((assert_failed == 0) &&
             (assert_failed = (int)(pdVar3->state_objects == (uchar *)0x0), assert_failed != 0)) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 0xc6;
            elinks_internal((uchar *)"assertion context->state_objects failed!");
          }
          puVar17 = pdVar3->state_objects + pdVar9->depth * sVar11;
        }
        *(int *)(puVar17 + 4) = pdVar19->type;
        *(int *)(puVar17 + 8) = pdVar19->precedence;
        *(uint *)(puVar17 + 0xc) = pdVar19->lineno;
        *(uint *)(puVar17 + 0x10) = (pdVar19->string).length;
        *(uchar **)(puVar17 + 0x14) = (pdVar19->string).string;
        pop_dom_state(stack,pdVar9);
      }
    }
    goto LAB_080a7131;
  case 0x111:
    pop_dom_node(stack);
    iVar16 = scanner->tokens;
joined_r0x080a7183:
    if (iVar16 < 1) {
      return DOM_CODE_OK;
    }
    goto LAB_080a7138;
  case 0x113:
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    pdVar7 = init_dom_node_at(stack->states[stack->depth - 1].node,DOM_NODE_ENTITY_REFERENCE,
                              &pdVar19->string,-1);
    if (pdVar7 == (dom_node *)0x0) goto LAB_080a7131;
    iVar16 = pdVar19->type;
    goto joined_r0x080a7107;
  case 0x117:
switchD_080a7078_caseD_117:
    code_2 = DOM_CODE_INCOMPLETE;
    return code_2;
  case 0x118:
    code_2 = call_sgml_error_function(stack,pdVar19);
    if (code_2 != DOM_CODE_OK) {
      return code_2;
    }
LAB_080a7039:
    iVar16 = scanner->tokens;
    if (iVar16 < 1) {
      return DOM_CODE_OK;
    }
    pdVar19 = scanner->current;
    if ((pdVar19 < scanner->table + iVar16) &&
       (scanner->current = pdVar19 + 1, scanner->table + iVar16 <= pdVar19 + 2)) {
      (*scanner->info->scan)(scanner);
switchD_080a7600_caseD_10e:
      iVar16 = scanner->tokens;
    }
    goto LAB_080a6fa0;
  }
  pdVar7 = init_dom_node_at(stack->states[sVar11 - 1].node,type,&pdVar19->string,-1);
  if (pdVar7 == (dom_node *)0x0) {
    code_2 = DOM_CODE_ALLOC_ERR;
    return code_2;
  }
  iVar16 = pdVar19->type;
joined_r0x080a7107:
  if (iVar16 == 0x115) {
    pbVar1 = (byte *)((int)&pdVar7->data + 4);
    *pbVar1 = *pbVar1 | 1;
  }
  dVar8 = push_dom_node(stack,pdVar7);
  if (dVar8 == DOM_CODE_OK) {
    pop_dom_node(stack);
  }
LAB_080a7131:
  iVar16 = scanner->tokens;
  if (iVar16 < 1) {
    return DOM_CODE_OK;
  }
LAB_080a7138:
  pdVar19 = scanner->current;
  if ((pdVar19 < scanner->table + iVar16) &&
     (scanner->current = pdVar19 + 1, scanner->table + iVar16 <= pdVar19 + 2)) {
LAB_080a715b:
    (*scanner->info->scan)(scanner);
    iVar16 = scanner->tokens;
  }
  goto LAB_080a6fa0;
}



// WARNING: Unknown calling convention

dom_code sgml_parsing_push(dom_stack *stack,dom_node *node,void *data)

{
  dom_stack *stack_00;
  void *pvVar1;
  uint uVar2;
  uchar *puVar3;
  dom_scanner_token *pdVar4;
  dom_node_list *__s;
  byte bVar5;
  byte bVar6;
  uint uVar7;
  dom_code code;
  dom_scanner_token *token;
  uchar *__s_00;
  dom_scanner_token *pdVar8;
  dom_code dVar9;
  dom_node *parent_1;
  dom_node *node_00;
  dom_node *node_1;
  size_t *psVar10;
  void *match;
  void *pvVar11;
  size_t sVar12;
  dom_string *pdVar13;
  dom_document *pdVar14;
  int detect_errors;
  uint detect_errors_00;
  dom_scanner_token *token_00;
  sgml_node_info *info;
  size_t *psVar15;
  sgml_parser *parser;
  uint complete;
  sgml_parsing_state *parent;
  sgml_parsing_state *parsing;
  dom_scanner_token *token_1;
  int iVar16;
  dom_node *pdVar17;
  dom_string *local_50;
  dom_scanner_token *local_48;
  dom_scanner_token name;
  
  pvVar1 = (*stack->contexts)->data;
  uVar2 = *(uint *)((int)pvVar1 + 4);
  complete = uVar2 >> 1 & 1;
  uVar7 = uVar2 >> 2 & 1;
  local_50 = &node->string;
  detect_errors_00 = uVar2 >> 3 & 1;
  *(undefined4 *)((int)data + 0x100) = *(undefined4 *)((int)pvVar1 + 0x24);
  if (1 < stack->depth) {
    parent = (sgml_parsing_state *)((int)data + -0x108);
    bVar6 = *(byte *)((int)data + -4);
    if ((bVar6 & 1) == 0) goto LAB_080a82e0;
    if ((*(void **)((int)data + -0xc) != (void *)0x0) && (*(int *)((int)data + -0x10) != 0)) {
      sVar12 = (node->string).length;
      puVar3 = (node->string).string;
      pvVar11 = mem_realloc(*(void **)((int)data + -0xc),sVar12 + 1 + *(int *)((int)data + -0x10));
      if (pvVar11 == (void *)0x0) goto LAB_080a8850;
      local_50 = (dom_string *)((int)data + -0x10);
      *(void **)((int)data + -0xc) = pvVar11;
      memcpy((void *)((int)pvVar11 + *(int *)((int)data + -0x10)),puVar3,sVar12);
      iVar16 = sVar12 + *(int *)((int)data + -0x10);
      *(int *)((int)data + -0x10) = iVar16;
      *(undefined *)(*(int *)((int)data + -0xc) + iVar16) = 0;
      bVar6 = *(byte *)((int)data + -4);
    }
    iVar16 = *(int *)((int)data + -0xe0);
    *(byte *)((int)data + -4) = bVar6 & 0xfe;
    pop_dom_node(stack);
    init_dom_scanner((dom_scanner *)parent,&sgml_scanner_info,local_50,iVar16,uVar2 & 1,complete,
                     uVar7,detect_errors_00);
    if (iVar16 != 1) goto LAB_080a8321;
    stack_00 = (dom_stack *)((int)pvVar1 + 0x20);
    iVar16 = *(int *)((int)data + -0xf8);
LAB_080a8271:
    if ((iVar16 < 1) ||
       (pdVar8 = *(dom_scanner_token **)((int)data + -0xfc),
       (dom_scanner_token *)((int)data + iVar16 * 0x14 + -0xdc) <= pdVar8))
    goto switchD_080a83e0_caseD_10e;
    if ((assert_failed == 0) &&
       (assert_failed = (int)(pdVar8 == (dom_scanner_token *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
      errline = 0xd1;
      elinks_internal((uchar *)"assertion token failed!");
    }
    switch(pdVar8->type) {
    case 0x100:
      name.type = pdVar8->type;
      name.precedence = pdVar8->precedence;
      name.lineno = pdVar8->lineno;
      name.string.length = (pdVar8->string).length;
      name.string.string = (pdVar8->string).string;
      if (*(int *)((int)data + -0xf8) < 1) {
LAB_080a8668:
        token_00 = (dom_scanner_token *)0x0;
LAB_080a866a:
        dVar9 = check_sgml_incomplete((dom_scanner *)parent,&name,token_00);
        if (dVar9 != DOM_CODE_OK) goto switchD_080a83e0_caseD_117;
LAB_080a867c:
        local_48 = (dom_scanner_token *)0x0;
      }
      else {
        pdVar4 = *(dom_scanner_token **)((int)data + -0xfc);
        pdVar8 = (dom_scanner_token *)((int)data + *(int *)((int)data + -0xf8) * 0x14 + -0xdc);
        if (pdVar8 <= pdVar4) goto LAB_080a8668;
        token_00 = pdVar4 + 1;
        *(dom_scanner_token **)((int)data + -0xfc) = token_00;
        if (pdVar4 + 2 < pdVar8) {
          if (pdVar8 <= token_00) goto LAB_080a8668;
        }
        else {
          token_00 = (dom_scanner_token *)(**(code **)(*(int *)((int)data + -0xf4) + 8))(parent);
        }
        if ((token_00 == (dom_scanner_token *)0x0) || (token_00->type != 0x3d)) goto LAB_080a866a;
        if (*(int *)((int)data + -0xf8) < 1) {
LAB_080a891d:
          local_48 = (dom_scanner_token *)0x0;
        }
        else {
          pdVar4 = *(dom_scanner_token **)((int)data + -0xfc);
          pdVar8 = (dom_scanner_token *)((int)data + *(int *)((int)data + -0xf8) * 0x14 + -0xdc);
          if (pdVar8 <= pdVar4) goto LAB_080a891d;
          local_48 = pdVar4 + 1;
          *(dom_scanner_token **)((int)data + -0xfc) = local_48;
          if (pdVar4 + 2 < pdVar8) {
            if (pdVar8 <= local_48) goto LAB_080a891d;
          }
          else {
            local_48 = (dom_scanner_token *)(**(code **)(*(int *)((int)data + -0xf4) + 8))(parent);
          }
        }
        dVar9 = check_sgml_incomplete((dom_scanner *)parent,&name,local_48);
        if (dVar9 != DOM_CODE_OK) goto switchD_080a83e0_caseD_117;
        if ((((local_48 != (dom_scanner_token *)0x0) && (iVar16 = local_48->type, iVar16 != 0x100))
            && (iVar16 != 0x112)) && (iVar16 != 0x102)) goto LAB_080a867c;
      }
      iVar16 = ***(int ***)((int)pvVar1 + 0x2c);
      if (assert_failed == 0) {
        assert_failed = 0;
      }
      pdVar17 = stack_00->states[*(int *)((int)pvVar1 + 0x24) + -1].node;
      if (local_48 == (dom_scanner_token *)0x0) {
        pdVar17 = init_dom_node_at(pdVar17,DOM_NODE_ATTRIBUTE,&name.string,-1);
      }
      else {
        node_00 = init_dom_node_at(pdVar17,DOM_NODE_ATTRIBUTE,&name.string,-1);
        pdVar17 = node_00;
        if (node_00 != (dom_node *)0x0) {
          if ((node_00->field_0x2 & 1) == 0) {
            pdVar14 = (dom_document *)(local_48->string).length;
            __s = (dom_node_list *)(local_48->string).string;
            (node_00->data).document.children = __s;
            if (pdVar14 == (dom_document *)0xffffffff) {
              pdVar14 = (dom_document *)strlen((char *)__s);
            }
            (node_00->data).document.document = pdVar14;
          }
          else {
            pdVar13 = add_to_dom_string((dom_string *)&(node_00->data).document,
                                        (local_48->string).string,(local_48->string).length);
            if (pdVar13 == (dom_string *)0x0) {
              pdVar17 = (dom_node *)0x0;
              done_dom_node(node_00);
            }
          }
        }
      }
      psVar15 = *(size_t **)(*(int *)(iVar16 + 8) + 4);
      psVar10 = (size_t *)bsearch(pdVar17,psVar15 + 3,*psVar15,0xc,sgml_info_strcmp);
      if (psVar10 != (size_t *)0x0) {
        psVar15 = psVar10;
      }
      (pdVar17->data).element.type = *(uint16_t *)(psVar15 + 2);
      bVar6 = *(byte *)((int)&pdVar17->data + 0xd);
      bVar5 = (byte)((*(ushort *)((int)psVar15 + 10) & 1) << 2);
      *(byte *)((int)&pdVar17->data + 0xd) = bVar6 & 0xfb | bVar5;
      *(byte *)((int)&pdVar17->data + 0xd) =
           bVar6 & 0xf3 | bVar5 | (byte)((*(ushort *)((int)psVar15 + 10) >> 1 & 1) << 3);
      if ((local_48 != (dom_scanner_token *)0x0) && (local_48->type == 0x102)) {
        (pdVar17->data).attribute.quoted = (local_48->string).string[-1];
      }
      dVar9 = push_dom_node(stack_00,pdVar17);
      if (dVar9 != DOM_CODE_OK) {
        dVar9 = DOM_CODE_ALLOC_ERR;
        break;
      }
      pop_dom_node(stack_00);
      if (local_48 != (dom_scanner_token *)0x0) goto LAB_080a84fa;
      goto LAB_080a82d7;
    case 0x101:
      if (0 < *(int *)((int)data + -0xf8)) {
        uVar7 = *(uint *)((int)data + -0xfc);
        uVar2 = (int)data + *(int *)((int)data + -0xf8) * 0x14 + -0xdc;
        if ((uVar7 < uVar2) && (*(uint *)((int)data + -0xfc) = uVar7 + 0x14, uVar2 <= uVar7 + 0x28))
        {
          (**(code **)(*(int *)((int)data + -0xf4) + 8))(parent);
        }
      }
switchD_080a83e0_caseD_10e:
      *(undefined4 *)((int)pvVar1 + 0x18) = 0;
      dVar9 = parse_sgml_plain(stack_00,(dom_scanner *)parent);
      *(dom_code *)((int)pvVar1 + 0x18) = dVar9;
      goto LAB_080a832c;
    default:
      iVar16 = *(int *)((int)data + -0xf8);
      if (0 < iVar16) goto code_r0x080a82b3;
    case 0x10e:
    case 0x10f:
    case 0x110:
    case 0x111:
      goto switchD_080a83e0_caseD_10e;
    case 0x117:
switchD_080a83e0_caseD_117:
      dVar9 = DOM_CODE_INCOMPLETE;
      break;
    case 0x118:
      dVar9 = call_sgml_error_function(stack_00,pdVar8);
      if (dVar9 == DOM_CODE_OK) {
LAB_080a84fa:
        iVar16 = *(int *)((int)data + -0xf8);
        if (iVar16 < 1) goto switchD_080a83e0_caseD_10e;
        uVar7 = *(uint *)((int)data + -0xfc);
        uVar2 = (int)data + iVar16 * 0x14 + -0xdc;
        if ((uVar7 < uVar2) && (*(uint *)((int)data + -0xfc) = uVar7 + 0x14, uVar2 <= uVar7 + 0x28))
        {
          (**(code **)(*(int *)((int)data + -0xf4) + 8))(parent);
          iVar16 = *(int *)((int)data + -0xf8);
        }
        goto LAB_080a8271;
      }
    }
    *(dom_code *)((int)pvVar1 + 0x18) = dVar9;
    goto LAB_080a832c;
  }
LAB_080a82e0:
  init_dom_scanner((dom_scanner *)data,&sgml_scanner_info,local_50,0,uVar2 & 1,complete,uVar7,
                   detect_errors_00);
  parent = (sgml_parsing_state *)data;
LAB_080a8321:
  dVar9 = parse_sgml_plain((dom_stack *)((int)pvVar1 + 0x20),&parent->scanner);
  *(dom_code *)((int)pvVar1 + 0x18) = dVar9;
LAB_080a832c:
  if (complete == 0) {
    if (*(int *)((int)pvVar1 + 0x18) == -999) {
      iVar16 = (parent->scanner).tokens;
      if ((iVar16 < 1) ||
         (pdVar8 = (parent->scanner).current, (parent->scanner).table + iVar16 <= pdVar8)) {
        pdVar8 = (dom_scanner_token *)0x0;
      }
      if (assert_failed == 0) {
        if ((pdVar8 == (dom_scanner_token *)0x0) || (pdVar8->type != 0x117)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
          errline = 0x21b;
          elinks_internal((uchar *)"assertion token && token->type == SGML_TOKEN_INCOMPLETE failed!"
                         );
        }
        else {
          assert_failed = 0;
        }
      }
      sVar12 = (pdVar8->string).length;
      puVar3 = (pdVar8->string).string;
      __s_00 = (uchar *)mem_realloc((void *)0x0,sVar12 + 1);
      if (__s_00 != (uchar *)0x0) {
        memcpy(__s_00,puVar3,sVar12);
        __s_00[sVar12] = '\0';
        puVar3 = (parent->incomplete).string;
        if (puVar3 != (uchar *)0x0) {
          mem_free(puVar3);
        }
        (parent->incomplete).length = 0;
        (parent->incomplete).string = __s_00;
        if (sVar12 == 0xffffffff) {
          sVar12 = strlen((char *)__s_00);
        }
        parent->field_0x104 = parent->field_0x104 | 1;
        (parent->incomplete).length = sVar12;
        return DOM_CODE_OK;
      }
LAB_080a8850:
      *(undefined4 *)((int)pvVar1 + 0x18) = 0xfffffc1b;
      return DOM_CODE_OK;
    }
    if ((parent->scanner).state != 0) {
      puVar3 = (parent->incomplete).string;
      if (puVar3 != (uchar *)0x0) {
        mem_free(puVar3);
      }
      parent->field_0x104 = parent->field_0x104 | 1;
      (parent->incomplete).string = (uchar *)0x0;
      (parent->incomplete).length = 0;
      return DOM_CODE_OK;
    }
  }
  pop_dom_node((dom_stack *)((int)pvVar1 + 0x38));
  return DOM_CODE_OK;
code_r0x080a82b3:
  uVar7 = *(uint *)((int)data + -0xfc);
  uVar2 = (int)data + iVar16 * 0x14 + -0xdc;
  if ((uVar7 < uVar2) && (*(uint *)((int)data + -0xfc) = uVar7 + 0x14, uVar2 <= uVar7 + 0x28)) {
    (**(code **)(*(int *)((int)data + -0xf4) + 8))(parent);
LAB_080a82d7:
    iVar16 = *(int *)((int)data + -0xf8);
  }
  goto LAB_080a8271;
}



// WARNING: Unknown calling convention

void skip_sgml_space(dom_scanner *scanner,uchar **string)

{
  uchar *pos;
  byte *pbVar1;
  
  pbVar1 = *string;
  if ((scanner->field_0x20 & 1) == 0) {
    if ((pbVar1 < scanner->end) && ((*(byte *)(sgml_scanner_info.scan_table + *pbVar1) & 0x10) != 0)
       ) {
      while (pbVar1 = pbVar1 + 1, pbVar1 < scanner->end) {
        if ((*(byte *)(sgml_scanner_info.scan_table + *pbVar1) & 0x10) == 0) {
          *string = pbVar1;
          return;
        }
      }
    }
  }
  else {
    for (; pbVar1 < scanner->end; pbVar1 = pbVar1 + 1) {
      if ((sgml_scanner_info.scan_table[*pbVar1] & 0x10U) == 0) {
        *string = pbVar1;
        return;
      }
      if ((sgml_scanner_info.scan_table[*pbVar1] & 8U) != 0) {
        scanner->lineno = scanner->lineno + 1;
      }
    }
  }
  *string = pbVar1;
  return;
}



// WARNING: Unknown calling convention

uchar * skip_sgml_chars(dom_scanner *scanner,uchar *string,uchar skipto)

{
  byte bVar1;
  uchar *puVar2;
  int newlines;
  int iVar3;
  
  if (assert_failed == 0) {
    if ((scanner->position < string || scanner->position == string) &&
       (string < scanner->end || string == scanner->end)) {
      assert_failed = 0;
      bVar1 = scanner->field_0x20;
      goto joined_r0x080a8a28;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 0x131;
    elinks_internal((uchar *)
                    "assertion string >= scanner->position && string <= scanner->end failed!");
  }
  bVar1 = scanner->field_0x20;
joined_r0x080a8a28:
  if ((bVar1 & 1) == 0) {
    puVar2 = (uchar *)memchr(string,(uint)skipto,(int)scanner->end - (int)string);
  }
  else {
    iVar3 = 0;
    if (string < scanner->end) {
      do {
        iVar3 = (iVar3 + 1) - (uint)((sgml_scanner_info.scan_table[*string] & 8U) == 0);
        if (skipto == *string) {
          scanner->lineno = scanner->lineno + iVar3;
          return string;
        }
        string = string + 1;
      } while (string < scanner->end);
    }
    puVar2 = (uchar *)0x0;
  }
  return puVar2;
}



// WARNING: Unknown calling convention

void set_sgml_incomplete(dom_scanner *scanner,dom_scanner_token *token)

{
  uchar *__s;
  size_t left;
  
  left = (int)scanner->end - (int)scanner->position;
  if ((assert_failed == 0) && (assert_failed = (int)(left == 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 0x6f;
    elinks_internal((uchar *)"assertion left > 0 failed!");
  }
  token->type = 0x117;
  __s = scanner->position;
  (token->string).string = __s;
  if (left == 0xffffffff) {
    left = strlen((char *)__s);
  }
  (token->string).length = left;
  scanner->position = scanner->end;
  return;
}



// WARNING: Unknown calling convention

dom_scanner_token * set_sgml_error(dom_scanner *scanner,uchar *end)

{
  dom_scanner *pdVar1;
  uchar *__s;
  uint uVar2;
  dom_scanner *pdVar3;
  dom_scanner_token *token;
  dom_scanner_token *next;
  dom_scanner_token *pdVar4;
  
  pdVar1 = (dom_scanner *)scanner->current;
  pdVar3 = pdVar1;
  if (assert_failed == 0) {
    assert_failed = (int)(scanner->found_error != 0);
    if (assert_failed == 0) {
      pdVar3 = (dom_scanner *)scanner->current;
      goto LAB_080a8b86;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 0xb4;
    elinks_internal((uchar *)"assertion !scanner->found_error failed!");
    pdVar3 = (dom_scanner *)scanner->current;
    if (scanner + 1 <= pdVar3) goto LAB_080a8c28;
  }
  else {
LAB_080a8b86:
    if (scanner + 1 <= pdVar3) {
LAB_080a8c28:
      scanner->found_error = 1;
      pdVar4 = (dom_scanner_token *)0x0;
      goto LAB_080a8bb7;
    }
  }
  pdVar4 = (dom_scanner_token *)&pdVar3->info;
  scanner->current = pdVar4;
  pdVar3->info = (dom_scanner_info *)pdVar1->string;
  *(uchar **)&pdVar3->field_0x18 = pdVar1->end;
  pdVar3->found_error = (uint)pdVar1->position;
  *(uint *)&pdVar3->field_0x20 = ((dom_string *)&pdVar1->current)->length;
  pdVar3->lineno = (uint)pdVar1->tokens;
LAB_080a8bb7:
  pdVar1->string = (uchar *)0x118;
  pdVar1->position = (uchar *)scanner->lineno;
  __s = scanner->position;
  uVar2 = (int)end - (int)__s;
  pdVar1->tokens = (int)__s;
  if (uVar2 == 0xffffffff) {
    uVar2 = strlen((char *)__s);
  }
  ((dom_string *)&pdVar1->current)->length = uVar2;
  return pdVar4;
}



uchar * __regparm3 skip_sgml(dom_scanner *scanner,uchar **string,uchar skipto,int check_quoting)

{
  byte bVar1;
  uint __c;
  byte *pbVar2;
  undefined3 in_register_00000005;
  int newlines;
  uchar *pos;
  byte *__s;
  int iVar3;
  byte *pbVar4;
  
  __s = *string;
  pbVar4 = scanner->end;
LAB_080a8c58:
  do {
    if (pbVar4 <= __s) {
LAB_080a8d10:
      *string = __s;
      return (uchar *)0x0;
    }
    while( true ) {
      bVar1 = *__s;
      if (bVar1 == 0x3e) {
        *string = __s + 1;
        return __s;
      }
      __c = (uint)bVar1;
      if (__c == 0x3c) goto LAB_080a8d10;
      if ((CONCAT31(in_register_00000005,skipto) == 0) || ((bVar1 != 0x27 && (bVar1 != 0x22))))
      break;
      __s = __s + 1;
      if (assert_failed == 0) {
        if ((__s < scanner->position) || (pbVar4 < __s)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
          errline = 0x131;
          elinks_internal((uchar *)
                          "assertion string >= scanner->position && string <= scanner->end failed!")
          ;
          pbVar4 = scanner->end;
          goto LAB_080a8cdc;
        }
        assert_failed = 0;
        pbVar4 = scanner->end;
        if ((scanner->field_0x20 & 1) != 0) goto LAB_080a8d70;
LAB_080a8ce6:
        pbVar2 = (byte *)memchr(__s,__c,(int)pbVar4 - (int)__s);
      }
      else {
LAB_080a8cdc:
        if ((scanner->field_0x20 & 1) == 0) goto LAB_080a8ce6;
LAB_080a8d70:
        if (pbVar4 <= __s) goto LAB_080a8d10;
        iVar3 = 0;
        pbVar2 = __s;
        while (iVar3 = (iVar3 + 1) - (uint)((sgml_scanner_info.scan_table[*pbVar2] & 8U) == 0),
              bVar1 != *pbVar2) {
          pbVar2 = pbVar2 + 1;
          if (pbVar4 <= pbVar2) goto LAB_080a8c58;
        }
        scanner->lineno = scanner->lineno + iVar3;
      }
      if (pbVar2 != (byte *)0x0) {
        __s = pbVar2 + 1;
      }
      if (pbVar4 <= __s) goto LAB_080a8d10;
    }
    if (((scanner->field_0x20 & 1) != 0) &&
       ((*(byte *)(sgml_scanner_info.scan_table + __c) & 8) != 0)) {
      scanner->lineno = scanner->lineno + 1;
    }
    __s = __s + 1;
  } while( true );
}



// WARNING: Unknown calling convention

dom_scanner_token * scan_sgml_tokens(dom_scanner *scanner)

{
  dom_scanner_token *__dest;
  uchar **ppuVar1;
  uint uVar2;
  dom_scanner *ident;
  byte bVar3;
  dom_scanner_token *table;
  size_t __n;
  dom_scanner *pdVar4;
  uchar *pos;
  int iVar5;
  dom_scanner *pdVar6;
  uchar *pos_3;
  uchar *string_end;
  dom_scanner *pdVar7;
  dom_scanner_token *pdVar8;
  uchar first_char;
  uchar *pos_4;
  dom_scanner *end;
  byte bVar9;
  byte *pbVar10;
  uchar *pos_1;
  uint found_error_2;
  uint found_error_1;
  uint found_error;
  uchar *puVar11;
  int iVar12;
  int move_to_front;
  uchar *string;
  byte *pbVar13;
  sgml_token_type type;
  uchar *puVar14;
  uint uVar15;
  int newlines;
  bool bVar16;
  char *__src;
  int local_3c;
  dom_scanner *local_34;
  dom_scanner *local_30;
  dom_scanner *local_20 [4];
  
  __dest = scanner->table;
  pdVar4 = (dom_scanner *)scanner->current;
  iVar12 = ((int)scanner + ((scanner->tokens * 0x14 + 0x2c) - (int)pdVar4) >> 2) * -0x33333333;
  __src = (char *)pdVar4;
  if (iVar12 < 1) {
    iVar12 = 0;
    __src = (char *)__dest;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(pdVar4 == (dom_scanner *)0x0), pdVar4 == (dom_scanner *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
    errline = 0xfb;
    elinks_internal((uchar *)"assertion scanner->current failed!");
  }
  __n = 200;
  if (iVar12 != 0) {
    memmove(__dest,__src,iVar12 * 0x14);
    __src = (char *)(scanner->table + iVar12);
    __n = iVar12 * -0x14 + 200;
  }
  memset(__src,0,__n);
  if (scanner->position == (uchar *)0x0) {
    if (iVar12 == 0) {
      iVar12 = -1;
    }
    scanner->tokens = iVar12;
    scanner->current = __dest;
    if (assert_failed == 0) {
      if ((iVar12 < 10) || (scanner->table + 1 < scanner->table + iVar12)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
        errline = 0x10a;
        elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
      }
    }
    iVar12 = scanner->tokens;
  }
  else {
    scanner->tokens = iVar12;
    if (__dest != (dom_scanner_token *)0x0) {
      pdVar4 = scanner + 1;
      local_30 = (dom_scanner *)(scanner->table + iVar12);
      scanner->current = (dom_scanner_token *)local_30;
joined_r0x080a8e88:
      if (pdVar4 <= local_30) {
joined_r0x080a92e5:
        if ((assert_failed == 0) && (assert_failed = (int)(pdVar4 < local_30), pdVar4 < local_30)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
          errline = 0x11a;
          elinks_internal((uchar *)"assertion end <= scanner->table + DOM_SCANNER_TOKENS failed!");
        }
        iVar12 = (int)local_30 - (int)__dest >> 2;
        iVar5 = iVar12 * -0x33333333;
        scanner->tokens = iVar5;
        scanner->current = __dest;
        if (scanner->end <= scanner->position) {
          scanner->position = (uchar *)0x0;
        }
        if (assert_failed == 0) {
          if ((iVar5 < 10) ||
             (scanner->current + 1 < (dom_scanner_token *)(&scanner->table[0].type + iVar12))) {
            assert_failed = 0;
          }
          else {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
            errline = 0x121;
            elinks_internal((uchar *)"assertion check_dom_scanner(scanner) failed!");
          }
        }
        if (scanner->tokens < 1) {
          return (dom_scanner_token *)0x0;
        }
        if (scanner->table + scanner->tokens <= scanner->current) {
          return (dom_scanner_token *)0x0;
        }
        return scanner->current;
      }
      pdVar6 = (dom_scanner *)scanner->position;
      pdVar7 = (dom_scanner *)scanner->end;
      if (pdVar7 <= pdVar6) goto joined_r0x080a92e5;
      local_3c = scanner->state;
      if (local_3c != 1) {
        bVar3 = *(byte *)&pdVar6->string;
        if (bVar3 == 0x3c) {
          if (local_3c == 2) goto LAB_080a9080;
          goto LAB_080a9160;
        }
        if (local_3c != 0) {
LAB_080a9080:
          local_30->tokens = (int)pdVar6;
          do {
            pdVar6 = (dom_scanner *)((int)&pdVar6->string + 1);
            if (assert_failed != 0) {
LAB_080a909f:
              if ((scanner->field_0x20 & 1) == 0) goto LAB_080a90a5;
LAB_080a911a:
              local_34 = (dom_scanner *)scanner->end;
              if (pdVar6 < local_34) {
                iVar12 = 0;
                while (iVar12 = (iVar12 + 1) -
                                (uint)((sgml_scanner_info.scan_table[*(byte *)&pdVar6->string] & 8U)
                                      == 0), *(byte *)&pdVar6->string != 0x3e) {
                  pdVar6 = (dom_scanner *)((int)&pdVar6->string + 1);
                  if (local_34 <= pdVar6) goto LAB_080a92f8;
                }
                scanner->lineno = scanner->lineno + iVar12;
                goto LAB_080a90c0;
              }
LAB_080a92f8:
              puVar14 = (uchar *)0xffffffff;
              goto LAB_080a92fd;
            }
            if (((dom_scanner *)scanner->position <= pdVar6) &&
               (pdVar6 < (dom_scanner *)scanner->end || pdVar6 == (dom_scanner *)scanner->end)) {
              assert_failed = 0;
              goto LAB_080a909f;
            }
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
            errline = 0x131;
            __src = "assertion string >= scanner->position && string <= scanner->end failed!";
            elinks_internal((uchar *)
                            "assertion string >= scanner->position && string <= scanner->end failed!"
                           );
            if ((scanner->field_0x20 & 1) != 0) goto LAB_080a911a;
LAB_080a90a5:
            local_34 = (dom_scanner *)scanner->end;
            __src = (char *)pdVar6;
            pdVar6 = (dom_scanner *)memchr(pdVar6,0x3e,(int)local_34 - (int)pdVar6);
LAB_080a90c0:
            if (pdVar6 == (dom_scanner *)0x0) goto LAB_080a92f8;
          } while (*(char *)((int)&pdVar6[-1].table[9].string.string + 3) != '?');
          pdVar6 = (dom_scanner *)((int)&pdVar6->string + 1);
          puVar14 = (uchar *)((int)pdVar6 + (-2 - (int)local_30->tokens));
          if (pdVar6 == (dom_scanner *)0x0) {
LAB_080a92fd:
            if ((scanner->field_0x18 & 3) == 3) goto LAB_080a93e1;
            uVar15 = scanner->found_error;
            scanner->found_error = 0;
            pdVar6 = local_34;
            if (((uVar15 == 0 & (byte)scanner->field_0x18 >> 2) == 0) ||
               (local_30 = (dom_scanner *)set_sgml_error(scanner,(uchar *)local_34),
               local_30 != (dom_scanner *)0x0)) goto LAB_080a9330;
          }
          else {
LAB_080a9330:
            local_34 = pdVar6;
            local_30->string = (uchar *)0x10d;
            if ((int)puVar14 < 0) {
              puVar14 = (uchar *)((int)local_34 - (int)local_30->tokens);
            }
            ((dom_string *)&local_30->current)->length = (uint)puVar14;
            local_30->end = (uchar *)0x0;
            scanner->state = 0;
            scanner->position = (uchar *)local_34;
          }
LAB_080a935b:
          pdVar8 = scanner->current;
          goto LAB_080a8f4a;
        }
        local_30->tokens = (int)pdVar6;
        pbVar10 = (byte *)((int)&pdVar6->string + 1);
        if (bVar3 != 0x26) {
          if ((sgml_scanner_info.scan_table[bVar3] & 0x10U) != 0) {
            bVar9 = scanner->field_0x20;
            if ((bVar9 & 1) == 0) {
              pbVar13 = scanner->end;
              for (; pbVar10 < pbVar13; pbVar10 = pbVar10 + 1) {
                uVar15 = sgml_scanner_info.scan_table[*pbVar10];
                if ((uVar15 & 0x10) == 0) goto joined_r0x080a9570;
              }
            }
            else {
              if ((sgml_scanner_info.scan_table[bVar3] & 8U) != 0) {
                scanner->lineno = scanner->lineno + 1;
              }
              pbVar13 = scanner->end;
              for (; pbVar10 < pbVar13; pbVar10 = pbVar10 + 1) {
                uVar15 = sgml_scanner_info.scan_table[*pbVar10];
                if ((uVar15 & 0x10) == 0) goto joined_r0x080a9570;
                if ((uVar15 & 8) != 0) {
                  scanner->lineno = scanner->lineno + 1;
                }
              }
            }
            goto LAB_080a9448;
          }
          pbVar13 = scanner->end;
          puVar14 = (uchar *)0x114;
          bVar9 = scanner->field_0x20;
          goto LAB_080a8eee;
        }
        pbVar13 = pbVar10;
        if ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)((int)&pdVar6->string + 1)) & 2) == 0
           ) {
          uVar15 = 0xffffffff;
          puVar14 = (uchar *)0x116;
        }
        else {
          if (pbVar10 < scanner->end) {
            do {
              pbVar13 = pbVar13 + 1;
              if (scanner->end <= pbVar13) break;
            } while ((*(byte *)(sgml_scanner_info.scan_table + *pbVar13) & 2) != 0);
            uVar15 = (int)pbVar13 - (int)pbVar10;
          }
          else {
            uVar15 = 0;
          }
          local_30->tokens = (int)pbVar10;
          puVar14 = (uchar *)0x113;
        }
        pbVar10 = scanner->end;
        if ((pbVar13 < pbVar10) && (bVar3 = *pbVar13, bVar3 != 0x3c)) {
          while (bVar3 != 0x26) {
            if (bVar3 == 0x3b) {
              local_30->string = puVar14;
              pbVar10 = pbVar13 + 1;
              goto joined_r0x080a94fc;
            }
            pbVar13 = pbVar13 + 1;
            if ((pbVar10 <= pbVar13) || (bVar3 = *pbVar13, bVar3 == 0x3c)) break;
          }
        }
        if (((scanner->field_0x18 & 3) == 3) && (pbVar13 == pbVar10)) goto LAB_080a93e1;
        uVar2 = scanner->found_error;
        scanner->found_error = 0;
        pbVar10 = pbVar13;
        if ((uVar2 == 0 & (byte)scanner->field_0x18 >> 2) == 0) {
          local_30->string = puVar14;
        }
        else {
          local_30 = (dom_scanner *)set_sgml_error(scanner,pbVar13);
          if (local_30 == (dom_scanner *)0x0) goto LAB_080a935b;
          local_30->string = puVar14;
        }
joined_r0x080a94fc:
        if ((int)uVar15 < 0) goto LAB_080a8f2f;
        goto LAB_080a8f37;
      }
LAB_080a9160:
      if ((scanner->field_0x20 & 1) == 0) {
        while ((pdVar6 < pdVar7 &&
               ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&pdVar6->string) & 0x10) != 0)))
        {
          pdVar6 = (dom_scanner *)((int)&pdVar6->string + 1);
        }
LAB_080a9194:
        scanner->position = (uchar *)pdVar6;
        if ((dom_scanner *)scanner->end < pdVar6 || (dom_scanner *)scanner->end == pdVar6) {
LAB_080a92d7:
          local_30 = (dom_scanner *)scanner->current;
          goto joined_r0x080a92e5;
        }
      }
      else {
        for (; pdVar6 < pdVar7; pdVar6 = (dom_scanner *)((int)&pdVar6->string + 1)) {
          if ((sgml_scanner_info.scan_table[*(byte *)&pdVar6->string] & 0x10U) == 0)
          goto LAB_080a9194;
          if ((sgml_scanner_info.scan_table[*(byte *)&pdVar6->string] & 8U) != 0) {
            scanner->lineno = scanner->lineno + 1;
          }
        }
        scanner->position = (uchar *)pdVar6;
        if ((dom_scanner *)scanner->end < pdVar6 || (dom_scanner *)scanner->end == pdVar6)
        goto LAB_080a92d7;
      }
      pdVar8 = scanner->current;
      local_20[0] = (dom_scanner *)((int)&pdVar6->string + 1);
      bVar3 = *(byte *)&pdVar6->string;
      (pdVar8->string).string = (uchar *)pdVar6;
      if (bVar3 == 0x3c) {
        local_34 = local_20[0];
        if ((scanner->field_0x20 & 1) == 0) {
          if (local_20[0] < (dom_scanner *)scanner->end) {
            bVar3 = *(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string);
            while (((bVar3 & 0x10) != 0 &&
                   (local_34 = (dom_scanner *)((int)&local_34->string + 1),
                   local_34 < (dom_scanner *)scanner->end))) {
              bVar3 = *(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_34->string);
            }
          }
        }
        else if (local_20[0] < (dom_scanner *)scanner->end) {
          uVar15 = sgml_scanner_info.scan_table[*(byte *)&local_20[0]->string];
          while (local_34 = local_20[0], (uVar15 & 0x10) != 0) {
            if ((uVar15 & 8) != 0) {
              scanner->lineno = scanner->lineno + 1;
            }
            local_34 = (dom_scanner *)((int)&local_20[0]->string + 1);
            if ((dom_scanner *)scanner->end <= local_34) break;
            local_20[0] = local_34;
            uVar15 = sgml_scanner_info.scan_table[*(byte *)&local_34->string];
          }
        }
        local_20[0] = local_34;
        if (scanner->state == 1) {
          local_20[0] = (dom_scanner *)(pdVar8->string).string;
          local_3c = 0;
          local_34 = (dom_scanner *)0x0;
          local_30 = (dom_scanner *)0x101;
          goto LAB_080a9258;
        }
        if ((dom_scanner *)scanner->end == local_34) goto LAB_080a9209;
        bVar3 = *(byte *)&local_34->string;
        if ((*(byte *)(sgml_scanner_info.scan_table + bVar3) & 4) == 0) {
          if (bVar3 == 0x21) {
            local_20[0] = (dom_scanner *)((int)&local_34->string + 1);
            skip_sgml_space(scanner,(uchar **)local_20);
            ident = local_20[0];
            (pdVar8->string).string = (uchar *)local_20[0];
            pdVar7 = (dom_scanner *)scanner->end;
            pdVar6 = (dom_scanner *)((int)&local_20[0]->string + 1);
            if (((pdVar6 < pdVar7) && (*(char *)&local_20[0]->string == '-')) &&
               (*(uchar *)&pdVar6->string == '-')) {
              pdVar6 = (dom_scanner *)((int)&local_20[0]->string + 2);
              (pdVar8->string).string = (uchar *)pdVar6;
              local_20[0] = pdVar6;
              while (puVar14 = skip_sgml_chars(scanner,(uchar *)pdVar6,'>'), puVar14 != (uchar *)0x0
                    ) {
                if (puVar14[-2] == '-') {
                  if (puVar14[-1] == '-') {
                    if (local_20[0] <= (dom_scanner *)(puVar14 + -2)) {
                      local_34 = (dom_scanner *)
                                 ((int)(dom_scanner *)(puVar14 + -2) - (int)local_20[0]);
                      goto LAB_080aa112;
                    }
                  }
                  else if (((puVar14[-1] == '!') && (puVar14[-3] == '-')) &&
                          (local_20[0] <= (dom_scanner *)(puVar14 + -3))) {
                    local_34 = (dom_scanner *)
                               ((int)(dom_scanner *)(puVar14 + -3) - (int)local_20[0]);
LAB_080aa112:
                    pdVar6 = (dom_scanner *)(puVar14 + 1);
                    bVar16 = false;
                    if (pdVar6 != (dom_scanner *)0x0) goto LAB_080aa11c;
                    break;
                  }
                }
                pdVar6 = (dom_scanner *)(puVar14 + 1);
              }
              pdVar6 = (dom_scanner *)scanner->end;
              bVar16 = true;
              local_34 = (dom_scanner *)((int)pdVar6 - (int)local_20[0]);
LAB_080aa11c:
              local_20[0] = pdVar6;
              if ((assert_failed == 0) &&
                 (assert_failed = -((int)local_34 >> 0x1f), assert_failed != 0)) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                errline = 0x1f7;
                __src = "assertion real_length >= 0 failed!";
                elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                local_30 = (dom_scanner *)0x104;
              }
              else {
                local_30 = (dom_scanner *)0x104;
              }
            }
            else {
              if ((pdVar7 <= (dom_scanner *)((int)&local_20[0]->end + 2)) ||
                 (__src = (char *)local_20[0], iVar12 = memcmp(local_20[0],&DAT_0812cc5f,7),
                 iVar12 != 0)) {
                end = ident;
                if ((ident < pdVar7) &&
                   ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&ident->string) & 4) != 0)) {
                  while ((end = pdVar6, local_20[0] = pdVar6, pdVar6 < (dom_scanner *)scanner->end
                         && ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&pdVar6->string) & 4
                             ) != 0))) {
                    pdVar6 = (dom_scanner *)((int)&pdVar6->string + 1);
                  }
                }
                __src = (char *)scanner;
                local_30 = (dom_scanner *)
                           map_dom_scanner_string(scanner,(uchar *)ident,(uchar *)end,0x103);
                puVar14 = skip_sgml(scanner,(uchar **)local_20,'\0',(int)__src);
                if (puVar14 != (uchar *)0x0) {
                  local_34 = (dom_scanner *)0xffffffff;
                  goto LAB_080a9258;
                }
                goto LAB_080a9926;
              }
              pdVar6 = (dom_scanner *)((int)&ident->end + 3);
              (pdVar8->string).string = (uchar *)pdVar6;
              local_20[0] = pdVar6;
              while (puVar14 = skip_sgml_chars(scanner,(uchar *)pdVar6,'>'), puVar14 != (uchar *)0x0
                    ) {
                if ((puVar14[-2] == ']') && (puVar14[-1] == ']')) {
                  pdVar6 = (dom_scanner *)(puVar14 + 1);
                  if (pdVar6 != (dom_scanner *)0x0) {
                    bVar16 = false;
                    local_34 = (dom_scanner *)(puVar14 + (-2 - (int)local_20[0]));
                    goto LAB_080a9ee3;
                  }
                  break;
                }
                pdVar6 = (dom_scanner *)(puVar14 + 1);
              }
              pdVar6 = (dom_scanner *)scanner->end;
              bVar16 = true;
              local_34 = (dom_scanner *)((int)pdVar6 - (int)local_20[0]);
LAB_080a9ee3:
              local_20[0] = pdVar6;
              if ((assert_failed == 0) &&
                 (assert_failed = -((int)local_34 >> 0x1f), assert_failed != 0)) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                errline = 0x201;
                __src = "assertion real_length >= 0 failed!";
                elinks_internal((uchar *)"assertion real_length >= 0 failed!");
                local_30 = (dom_scanner *)0x109;
              }
              else {
                local_30 = (dom_scanner *)0x109;
              }
            }
            goto LAB_080a95cd;
          }
          if (bVar3 != 0x3f) {
            if (bVar3 == 0x2f) {
              local_20[0] = (dom_scanner *)((int)&local_34->string + 1);
              skip_sgml_space(scanner,(uchar **)local_20);
              if ((dom_scanner *)scanner->end != local_20[0]) {
                if ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string) & 4) ==
                    0) {
                  if (*(byte *)&local_20[0]->string != 0x3e) goto LAB_080a9209;
                  local_20[0] = (dom_scanner *)((int)&local_20[0]->string + 1);
                  bVar16 = false;
                  local_34 = (dom_scanner *)0x0;
                }
                else {
                  (pdVar8->string).string = (uchar *)local_20[0];
                  local_34 = local_20[0];
                  if ((local_20[0] < (dom_scanner *)scanner->end) &&
                     ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string) & 4)
                      != 0)) {
                    do {
                      local_20[0] = (dom_scanner *)((int)&local_20[0]->string + 1);
                      if ((dom_scanner *)scanner->end <= local_20[0]) break;
                    } while ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string
                                       ) & 4) != 0);
                    local_34 = (dom_scanner *)(pdVar8->string).string;
                  }
                  local_34 = (dom_scanner *)((int)local_20[0] - (int)local_34);
                  puVar14 = skip_sgml(scanner,(uchar **)local_20,'\x01',(int)__src);
                  bVar16 = puVar14 == (uchar *)0x0;
                }
                local_3c = 0;
                local_30 = (dom_scanner *)0x110;
                goto LAB_080a95cd;
              }
            }
            else {
              puVar14 = skip_sgml(scanner,(uchar **)local_20,'\0',(int)__src);
              if (puVar14 != (uchar *)0x0) {
                local_34 = (dom_scanner *)0xffffffff;
                local_30 = (dom_scanner *)0x116;
                goto LAB_080a9258;
              }
            }
            goto LAB_080a9209;
          }
          local_20[0] = (dom_scanner *)((int)&local_34->string + 1);
          skip_sgml_space(scanner,(uchar **)local_20);
          pdVar6 = local_20[0];
          (pdVar8->string).string = (uchar *)local_20[0];
          if (local_20[0] < (dom_scanner *)scanner->end) {
            do {
              if ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string) & 4) == 0
                 ) break;
              local_20[0] = (dom_scanner *)((int)&local_20[0]->string + 1);
            } while (local_20[0] < (dom_scanner *)scanner->end);
          }
          bVar16 = true;
          __src = (char *)scanner;
          local_30 = (dom_scanner *)
                     map_dom_scanner_string(scanner,(uchar *)pdVar6,(uchar *)local_20[0],0x10a);
          local_34 = (dom_scanner *)((int)local_20[0] - (int)(pdVar8->string).string);
          skip_sgml_space(scanner,(uchar **)local_20);
          if ((*(byte *)(sgml_scanner_info.scan_table +
                        *(byte *)((int)&local_20[0][-1].table[9].string.string + 3)) & 0x10) != 0) {
            bVar16 = (dom_scanner *)scanner->end <= local_20[0];
          }
          bVar3 = scanner->field_0x18;
          local_3c = 2;
          if ((bVar3 & 3) != 3) goto LAB_080a95cd;
          if ((pdVar4 <= (dom_scanner *)(pdVar8 + 1)) || (pdVar6 = local_20[0], bVar16)) {
LAB_080aa0d5:
            local_20[0] = (dom_scanner *)scanner->end;
            local_3c = 2;
            bVar9 = bVar3 & 3;
            goto joined_r0x080a95e1;
          }
          do {
            pdVar6 = (dom_scanner *)skip_sgml_chars(scanner,(uchar *)((int)&pdVar6->string + 1),'>')
            ;
            if (pdVar6 == (dom_scanner *)0x0) {
              bVar3 = scanner->field_0x18;
              goto LAB_080aa0d5;
            }
          } while (*(char *)((int)&pdVar6[-1].table[9].string.string + 3) != '?');
          local_3c = 2;
        }
        else {
          (pdVar8->string).string = (uchar *)local_34;
          if ((local_34 <= (dom_scanner *)scanner->end && (dom_scanner *)scanner->end != local_34)
             && ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_34->string) & 4) != 0)) {
            do {
              local_34 = (dom_scanner *)((int)&local_34->string + 1);
              local_20[0] = local_34;
              if ((dom_scanner *)scanner->end <= local_34) {
                local_34 = (dom_scanner *)(pdVar8->string).string;
                goto LAB_080a99c2;
              }
            } while ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_34->string) & 4) != 0
                    );
            local_34 = (dom_scanner *)(pdVar8->string).string;
          }
LAB_080a99c2:
          local_34 = (dom_scanner *)((int)local_20[0] - (int)local_34);
          skip_sgml_space(scanner,(uchar **)local_20);
          if (((dom_scanner *)scanner->end < local_20[0] ||
               (dom_scanner *)scanner->end == local_20[0]) ||
             (*(uchar *)&local_20[0]->string != '>')) {
            if ((*(byte *)(sgml_scanner_info.scan_table +
                          *(byte *)((int)&local_20[0][-1].table[9].string.string + 3)) & 0x10) == 0)
            {
              bVar3 = scanner->field_0x18;
              local_3c = 1;
              local_30 = (dom_scanner *)0x10f;
              bVar9 = bVar3 & 3;
              goto joined_r0x080a95e1;
            }
            local_3c = 1;
            local_30 = (dom_scanner *)0x10f;
          }
          else {
            local_20[0] = (dom_scanner *)((int)&local_20[0]->string + 1);
            local_30 = (dom_scanner *)0x10e;
          }
        }
LAB_080a9258:
        scanner->state = local_3c;
        pdVar8->type = (int)local_30;
        if ((int)local_34 < 0) {
          local_34 = (dom_scanner *)((int)local_20[0] - (int)(pdVar8->string).string);
        }
        (pdVar8->string).length = (uint)local_34;
        iVar12 = 0x800;
        if ((local_30 != (dom_scanner *)0x3c) && (iVar12 = 0, local_30 == (dom_scanner *)0x3e)) {
          iVar12 = 0x400;
        }
        pdVar8->precedence = iVar12;
        scanner->position = (uchar *)local_20[0];
      }
      else {
        if (bVar3 == 0x3d) {
          local_34 = (dom_scanner *)0xffffffff;
          local_30 = (dom_scanner *)0x3d;
          goto LAB_080a9258;
        }
        if ((byte)(bVar3 - 0x3e) < 2) {
          if (bVar3 == 0x3f) {
            puVar14 = skip_sgml(scanner,(uchar **)local_20,'\0',(int)__src);
            bVar16 = puVar14 == (uchar *)0x0;
            if (assert_failed == 0) goto LAB_080a95a2;
LAB_080a95b8:
            local_3c = 0;
            local_34 = (dom_scanner *)0xffffffff;
            local_30 = (dom_scanner *)0x101;
          }
          else {
            if (assert_failed != 0) {
              local_34 = (dom_scanner *)0xffffffff;
              local_3c = 0;
              local_30 = (dom_scanner *)0x101;
              goto LAB_080a9258;
            }
            bVar16 = false;
LAB_080a95a2:
            assert_failed = (int)(scanner->state != 1);
            if (assert_failed == 0) goto LAB_080a95b8;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
            errline = 0x274;
            __src = "assertion scanner->state == SGML_STATE_ELEMENT failed!";
            elinks_internal((uchar *)"assertion scanner->state == SGML_STATE_ELEMENT failed!");
            local_3c = 0;
            local_34 = (dom_scanner *)0xffffffff;
            local_30 = (dom_scanner *)0x101;
          }
LAB_080a95cd:
          if (!bVar16) goto LAB_080a9258;
          bVar3 = scanner->field_0x18;
          bVar9 = bVar3 & 3;
joined_r0x080a95e1:
          if (bVar9 == 3) goto LAB_080a95e7;
LAB_080a9229:
          uVar15 = scanner->found_error;
          scanner->found_error = 0;
          if (((uVar15 == 0 & bVar3 >> 2) == 0) ||
             (pdVar6 = (dom_scanner *)scanner->end, pdVar6 != local_20[0])) goto LAB_080a9258;
          switch(local_30) {
          case (dom_scanner *)0x104:
            pdVar7 = (dom_scanner *)(scanner->position + 4);
            break;
          case (dom_scanner *)0x105:
          case (dom_scanner *)0x106:
          case (dom_scanner *)0x108:
          case (dom_scanner *)0x109:
            pdVar7 = (dom_scanner *)(scanner->position + 9);
            if (pdVar6 <= (dom_scanner *)(scanner->position + 9)) {
              pdVar7 = pdVar6;
            }
            goto LAB_080a9b15;
          case (dom_scanner *)0x107:
            pdVar7 = (dom_scanner *)(scanner->position + 6);
            break;
          default:
            goto switchD_080a9b02_caseD_10a;
          case (dom_scanner *)0x10b:
            pdVar7 = (dom_scanner *)(scanner->position + 5);
            break;
          case (dom_scanner *)0x10c:
            pdVar7 = (dom_scanner *)(scanner->position + 0x10);
          }
          if (local_20[0] <= pdVar7) {
switchD_080a9b02_caseD_10a:
            pdVar7 = pdVar6;
          }
LAB_080a9b15:
          pdVar8 = set_sgml_error(scanner,(uchar *)pdVar7);
          if (pdVar8 != (dom_scanner_token *)0x0) goto LAB_080a9258;
        }
        else {
          if (bVar3 == 0x2f) {
            if (local_20[0] != (dom_scanner *)scanner->end) {
              if (*(byte *)&local_20[0]->string == 0x3e) {
                local_20[0] = (dom_scanner *)((int)&pdVar6->string + 2);
                if ((assert_failed == 0) &&
                   (assert_failed = (int)(scanner->state != 1), assert_failed != 0)) {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                  local_3c = 0;
                  errline = 0x288;
                  __src = "assertion scanner->state == SGML_STATE_ELEMENT failed!";
                  elinks_internal((uchar *)"assertion scanner->state == SGML_STATE_ELEMENT failed!")
                  ;
                  local_34 = (dom_scanner *)0x0;
                  local_30 = (dom_scanner *)0x111;
                }
                else {
                  local_3c = 0;
                  local_34 = (dom_scanner *)0x0;
                  local_30 = (dom_scanner *)0x111;
                }
              }
              else {
                if ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string) & 0x50)
                    != 0) goto LAB_080a9209;
                if (local_20[0] < (dom_scanner *)scanner->end) {
                  pdVar6 = (dom_scanner *)((int)&pdVar6->string + 2);
                  do {
                    local_20[0] = pdVar6;
                    if ((dom_scanner *)scanner->end <= local_20[0]) break;
                    pdVar6 = (dom_scanner *)((int)&local_20[0]->string + 1);
                  } while ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string)
                           & 0x50) == 0);
                }
                if ((*(char *)((int)&local_20[0][-1].table[9].string.string + 3) != '/') ||
                   (*(uchar *)&local_20[0]->string != '>')) goto LAB_080a9810;
                local_34 = (dom_scanner *)0xffffffff;
                local_30 = (dom_scanner *)0x112;
                local_20[0] = (dom_scanner *)((int)&local_20[0][-1].table[9].string.string + 3);
              }
              goto LAB_080a9258;
            }
LAB_080a9209:
            bVar3 = scanner->field_0x18;
            local_34 = (dom_scanner *)0xffffffff;
            local_30 = (dom_scanner *)0x116;
            bVar9 = bVar3 & 3;
            goto joined_r0x080a95e1;
          }
          if ((bVar3 != 0x27) && (bVar3 != 0x22)) {
            if ((sgml_scanner_info.scan_table[bVar3] & 0x50U) != 0) goto LAB_080a9209;
            if ((sgml_scanner_info.scan_table[bVar3] & 4U) == 0) {
              if ((dom_scanner *)scanner->end <= local_20[0]) goto LAB_080a9209;
              local_30 = (dom_scanner *)0x116;
              uVar15 = sgml_scanner_info.scan_table[*(byte *)&local_20[0]->string];
            }
            else {
              if ((dom_scanner *)scanner->end <= local_20[0]) {
LAB_080a9690:
                bVar3 = scanner->field_0x18;
                local_34 = (dom_scanner *)0xffffffff;
                local_30 = (dom_scanner *)0x100;
                bVar9 = bVar3 & 3;
                goto joined_r0x080a95e1;
              }
              uVar15 = sgml_scanner_info.scan_table[*(byte *)&local_20[0]->string];
              if ((uVar15 & 4) != 0) {
                pdVar6 = (dom_scanner *)((int)&pdVar6->string + 2);
                do {
                  local_20[0] = pdVar6;
                  if ((dom_scanner *)scanner->end <= local_20[0]) goto LAB_080a9690;
                  uVar15 = sgml_scanner_info.scan_table[*(byte *)&local_20[0]->string];
                  pdVar6 = (dom_scanner *)((int)&local_20[0]->string + 1);
                } while ((uVar15 & 4) != 0);
              }
              local_30 = (dom_scanner *)0x100;
            }
            if ((uVar15 & 0x50) == 0) {
              do {
                pdVar6 = local_20[0];
                local_20[0] = (dom_scanner *)((int)&pdVar6->string + 1);
                if ((dom_scanner *)scanner->end <= local_20[0]) break;
              } while ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)((int)&pdVar6->string + 1)
                                 ) & 0x50) == 0);
              if ((*(uchar *)&pdVar6->string != '/') || (*(uchar *)&local_20[0]->string != '>'))
              goto LAB_080a9810;
              local_34 = (dom_scanner *)0xffffffff;
              local_30 = (dom_scanner *)0x112;
              local_20[0] = pdVar6;
              goto LAB_080a9258;
            }
LAB_080a9926:
            bVar3 = scanner->field_0x18;
            local_34 = (dom_scanner *)0xffffffff;
            bVar9 = bVar3 & 3;
            goto joined_r0x080a95e1;
          }
          puVar14 = skip_sgml_chars(scanner,(uchar *)local_20[0],bVar3);
          if (puVar14 != (uchar *)0x0) {
            puVar11 = (pdVar8->string).string + 1;
            local_34 = (dom_scanner *)(puVar14 + -(int)puVar11);
            (pdVar8->string).string = puVar11;
            local_30 = (dom_scanner *)0x102;
            local_20[0] = (dom_scanner *)(puVar14 + 1);
            goto LAB_080a9258;
          }
          bVar3 = scanner->field_0x18;
          bVar9 = bVar3 & 3;
          if (bVar9 != 3) {
            if (((dom_scanner *)scanner->end < local_20[0] ||
                 (dom_scanner *)scanner->end == local_20[0]) ||
               ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string) & 0x50) !=
                0)) {
              local_34 = (dom_scanner *)0xffffffff;
              local_30 = (dom_scanner *)0x116;
            }
            else {
              ppuVar1 = &(pdVar8->string).string;
              *ppuVar1 = *ppuVar1 + 1;
              if (local_20[0] < (dom_scanner *)scanner->end) {
                do {
                  if ((*(byte *)(sgml_scanner_info.scan_table + *(byte *)&local_20[0]->string) &
                      0x50) != 0) break;
                  local_20[0] = (dom_scanner *)((int)&local_20[0]->string + 1);
                } while (local_20[0] < (dom_scanner *)scanner->end);
              }
LAB_080a9810:
              bVar3 = scanner->field_0x18;
              local_34 = (dom_scanner *)0xffffffff;
              local_30 = (dom_scanner *)0x112;
              bVar9 = bVar3 & 3;
            }
            goto joined_r0x080a95e1;
          }
          local_20[0] = (dom_scanner *)scanner->end;
          local_34 = (dom_scanner *)0xffffffff;
          local_30 = (dom_scanner *)0x116;
LAB_080a95e7:
          if ((dom_scanner *)scanner->end != local_20[0]) goto LAB_080a9229;
          set_sgml_incomplete(scanner,pdVar8);
        }
      }
      pdVar8 = scanner->current;
      if (pdVar8->type == 0x119) {
        pdVar8 = pdVar8 + -1;
        scanner->current = pdVar8;
      }
      goto LAB_080a8f4a;
    }
  }
  if ((0 < iVar12) && (scanner->current < scanner->table + iVar12)) {
    return scanner->current;
  }
  return (dom_scanner_token *)0x0;
joined_r0x080a9570:
  puVar14 = (uchar *)0x114;
  if ((uVar15 & 0x20) != 0) {
LAB_080a9448:
    puVar14 = (uchar *)0x115;
  }
LAB_080a8eee:
  if ((bVar9 & 1) == 0) {
    for (; ((pbVar10 < pbVar13 && (*pbVar10 != 0x3c)) && (*pbVar10 != 0x26)); pbVar10 = pbVar10 + 1)
    {
    }
  }
  else {
    for (; pbVar10 < pbVar13; pbVar10 = pbVar10 + 1) {
      bVar3 = *pbVar10;
      if (bVar3 == 0x3c) {
        bVar3 = scanner->field_0x18;
        goto joined_r0x080a93d2;
      }
      if (bVar3 == 0x26) break;
      if ((*(byte *)(sgml_scanner_info.scan_table + bVar3) & 8) != 0) {
        scanner->lineno = scanner->lineno + 1;
      }
    }
  }
  bVar3 = scanner->field_0x18;
joined_r0x080a93d2:
  if (((bVar3 & 3) == 3) && (scanner->end == pbVar10)) {
LAB_080a93e1:
    set_sgml_incomplete(scanner,(dom_scanner_token *)local_30);
    pdVar8 = scanner->current;
  }
  else {
    local_30->string = puVar14;
LAB_080a8f2f:
    uVar15 = (int)pbVar10 - (int)local_30->tokens;
LAB_080a8f37:
    ((dom_string *)&local_30->current)->length = uVar15;
    local_30->end = (uchar *)0x0;
    pdVar8 = scanner->current;
    scanner->position = pbVar10;
  }
LAB_080a8f4a:
  local_30 = (dom_scanner *)(pdVar8 + 1);
  scanner->current = (dom_scanner_token *)local_30;
  goto joined_r0x080a8e88;
}



// WARNING: Unknown calling convention

sgml_info * get_sgml_info(sgml_document_type doctype)

{
  sgml_info *psVar1;
  
  psVar1 = (sgml_info *)0x0;
  if (doctype < SGML_DOCTYPES) {
    psVar1 = sgml_info[doctype];
  }
  return psVar1;
}



// WARNING: Unknown calling convention

int sgml_info_strcmp(void *key_,void *node_)

{
  size_t n;
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  n = *node_;
  if ((int)*(size_t *)((int)key_ + 4) <= (int)*node_) {
    n = *(size_t *)((int)key_ + 4);
  }
  iVar1 = c_strncasecmp(*(char **)((int)key_ + 8),*(char **)((int)node_ + 4),n);
  if (iVar1 == 0) {
                    // WARNING: Load size is inaccurate
    iVar1 = *(int *)((int)key_ + 4) - *node_;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void bzip2_close(stream_encoded *stream)

{
  void *p;
  bz2_enc_data *data;
  
  p = stream->data;
  if (p != (void *)0x0) {
    BZ2_bzDecompressEnd(p);
    close(*(int *)((int)p + 0x30));
    mem_free(p);
    stream->data = (void *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

int bzip2_read(stream_encoded *stream,uchar *buf,int len)

{
  void **ppvVar1;
  int iVar2;
  int err;
  void *pvVar3;
  int l;
  int *piVar4;
  void *pvVar5;
  bz2_enc_data *data;
  bool bVar6;
  
  ppvVar1 = (void **)stream->data;
  if (ppvVar1 == (void **)0x0) {
LAB_080aa314:
    iVar2 = -1;
  }
  else {
    if ((assert_failed == 0) && (assert_failed = (int)(len < 1), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
      errline = 0x59;
      elinks_internal((uchar *)"assertion len > 0 failed!");
    }
    iVar2 = 0;
    if (ppvVar1[0xd] == (void *)0x0) {
      ppvVar1[5] = (void *)len;
      ppvVar1[4] = buf;
      while( true ) {
        if (ppvVar1[1] == (void *)0x0) {
          pvVar5 = ppvVar1[0xc];
          while (pvVar3 = (void *)read((int)pvVar5,ppvVar1 + 0xe,5000), pvVar3 == (void *)0xffffffff
                ) {
            piVar4 = __errno_location();
            if (*piVar4 != 4) {
              if (*piVar4 != 0xb) goto LAB_080aa314;
              pvVar5 = ppvVar1[5];
              goto joined_r0x080aa393;
            }
          }
          if (pvVar3 == (void *)0x0) goto LAB_080aa314;
          *ppvVar1 = ppvVar1 + 0xe;
          ppvVar1[1] = pvVar3;
        }
        iVar2 = BZ2_bzDecompress(ppvVar1);
        if (iVar2 == 4) break;
        if (iVar2 != 0) goto LAB_080aa314;
        if (ppvVar1[5] == (void *)0x0) {
          pvVar5 = (void *)0x0;
joined_r0x080aa393:
          if (assert_failed == 0) {
            bVar6 = len - (int)pvVar5 != (int)ppvVar1[4] - (int)buf;
            assert_failed = (int)bVar6;
            if (bVar6) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
              errline = 0x7c;
              elinks_internal((uchar *)
                              "assertion len - data->fbz_stream.avail_out == data->fbz_stream.next_out - (char *) buf failed!"
                             );
            }
            pvVar5 = ppvVar1[5];
          }
          return len - (int)pvVar5;
        }
      }
      ppvVar1[0xd] = (void *)0x1;
      pvVar5 = ppvVar1[5];
      goto joined_r0x080aa393;
    }
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int bzip2_open(stream_encoded *stream,int fd)

{
  bz2_enc_data *p;
  int iVar1;
  int err;
  bz2_enc_data *data;
  byte bVar2;
  
  bVar2 = 0;
  p = (bz2_enc_data *)mem_alloc(0x13c0);
  stream->data = (void *)0x0;
  iVar1 = -1;
  if (p != (bz2_enc_data *)0x0) {
    data = p;
    for (iVar1 = 0xc; iVar1 != 0; iVar1 = iVar1 + -1) {
      data = (bz2_enc_data *)((int)data + (uint)bVar2 * -8 + 4);
      (data->fbz_stream).next_in = (char *)0x0;
      data = data;
    }
    p->last_read = 0;
    p->fdread = fd;
    iVar1 = BZ2_bzDecompressInit(p,0,0);
    if (iVar1 == 0) {
      stream->data = p;
      iVar1 = 0;
    }
    else {
      mem_free(p);
      iVar1 = -1;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * bzip2_decode_buffer(uchar *data,int len,int *new_len)

{
  uint uVar1;
  int error;
  uchar *puVar2;
  uchar *new_buffer;
  int iVar3;
  bz_stream *pbVar4;
  uchar *buffer;
  uchar *local_50;
  bz_stream stream;
  
  *new_len = 0;
  pbVar4 = &stream;
  for (iVar3 = 0xc; iVar3 != 0; iVar3 = iVar3 + -1) {
    pbVar4->next_in = (char *)0x0;
    pbVar4 = (bz_stream *)&pbVar4->avail_in;
  }
  stream.next_in = (char *)data;
  stream.avail_in = len;
  iVar3 = BZ2_bzDecompressInit(&stream,0,0);
  local_50 = (uchar *)0x0;
  if (iVar3 != 0) {
    return (uchar *)0x0;
  }
  do {
    uVar1 = stream.total_out_lo32;
    if ((assert_failed == 0) &&
       (assert_failed = (int)(stream.total_out_hi32 != 0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
      errline = 0x9f;
      elinks_internal((uchar *)
                      "assertion !stream.total_out_hi32 failed: 64 bzip2 decoding not supported");
    }
    puVar2 = (uchar *)mem_realloc(local_50,uVar1 + 0x400);
    if (puVar2 == (uchar *)0x0) {
      BZ2_bzDecompressEnd(&stream);
      if (local_50 == (uchar *)0x0) {
        return (uchar *)0x0;
      }
LAB_080aa593:
      mem_free(local_50);
      return (uchar *)0x0;
    }
    stream.avail_out = 0x400;
    stream.next_out = (char *)(puVar2 + stream.total_out_lo32);
    iVar3 = BZ2_bzDecompress(&stream);
    if (iVar3 == 4) break;
    local_50 = puVar2;
    if (iVar3 != 0) {
      BZ2_bzDecompressEnd(&stream);
      goto LAB_080aa593;
    }
  } while (stream.avail_in != 0);
  BZ2_bzDecompressEnd(&stream);
  *new_len = stream.total_out_lo32;
  return puVar2;
}



// WARNING: Unknown calling convention

void deflate_close(stream_encoded *stream)

{
  void *p;
  deflate_enc_data *data;
  
  p = stream->data;
  if (p != (void *)0x0) {
    inflateEnd(p);
    close(*(int *)((int)p + 0x38));
    mem_free(p);
    stream->data = (void *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

int deflate_read(stream_encoded *stream,uchar *buf,int len)

{
  byte bVar1;
  void **ppvVar2;
  void *__fd;
  int iVar3;
  int err;
  int *piVar4;
  void *pvVar5;
  byte bVar6;
  deflate_enc_data *data;
  void *pvVar7;
  int l;
  bool bVar8;
  
  ppvVar2 = (void **)stream->data;
  if (ppvVar2 == (void **)0x0) {
LAB_080aa6ab:
    iVar3 = -1;
  }
  else {
    if ((assert_failed == 0) && (assert_failed = (int)(len < 1), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/deflate.c";
      errline = 100;
      elinks_internal((uchar *)"assertion len > 0 failed!");
    }
    iVar3 = 0;
    if ((*(byte *)(ppvVar2 + 0xf) & 1) == 0) {
      pvVar5 = (void *)((int)ppvVar2 + 0x3d);
      pvVar7 = (void *)0x0;
      ppvVar2[3] = buf;
      ppvVar2[4] = (void *)len;
      do {
        if (ppvVar2[1] == (void *)0x0) {
          __fd = ppvVar2[0xe];
          while (pvVar7 = (void *)read((int)__fd,pvVar5,5000), pvVar7 == (void *)0xffffffff) {
            piVar4 = __errno_location();
            if (*piVar4 != 4) {
              if (*piVar4 != 0xb) goto LAB_080aa6ab;
              pvVar5 = ppvVar2[4];
              goto joined_r0x080aa7c3;
            }
          }
          if (pvVar7 == (void *)0x0) goto LAB_080aa6ab;
          ppvVar2[1] = pvVar7;
          *ppvVar2 = pvVar5;
        }
        do {
          iVar3 = inflate(ppvVar2,2);
          if (iVar3 != -3) break;
          bVar6 = *(byte *)(ppvVar2 + 0xf);
          if (((bVar6 & 2) != 0) || ((uchar *)ppvVar2[3] != buf)) {
            bVar6 = bVar6 | 2;
            *(byte *)(ppvVar2 + 0xf) = bVar6;
            goto LAB_080aa7a6;
          }
          *(byte *)(ppvVar2 + 0xf) = bVar6 | 2;
          inflateEnd(ppvVar2);
          ppvVar2[3] = buf;
          ppvVar2[4] = (void *)len;
          ppvVar2[1] = pvVar7;
          *ppvVar2 = pvVar5;
          iVar3 = inflateInit2_(ppvVar2,0xfffffff1,"1.2.3.4",0x38);
        } while (iVar3 == 0);
        bVar1 = *(byte *)(ppvVar2 + 0xf);
        bVar6 = bVar1 | 2;
        *(byte *)(ppvVar2 + 0xf) = bVar6;
        if (iVar3 == 1) {
          pvVar5 = ppvVar2[4];
          *(byte *)(ppvVar2 + 0xf) = bVar1 | 3;
          goto joined_r0x080aa7c3;
        }
        if (iVar3 != 0) {
LAB_080aa7a6:
          pvVar5 = ppvVar2[4];
          *(byte *)(ppvVar2 + 0xf) = bVar6 | 1;
          goto joined_r0x080aa7c3;
        }
        if (ppvVar2[4] == (void *)0x0) {
          pvVar5 = (void *)0x0;
joined_r0x080aa7c3:
          if (assert_failed == 0) {
            bVar8 = len - (int)pvVar5 != (int)ppvVar2[3] - (int)buf;
            assert_failed = (int)bVar8;
            if (bVar8) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/deflate.c";
              errline = 0xa8;
              elinks_internal((uchar *)
                              "assertion len - data->deflate_stream.avail_out == data->deflate_stream.next_out - buf failed!"
                             );
            }
            pvVar5 = ppvVar2[4];
          }
          return len - (int)pvVar5;
        }
      } while( true );
    }
  }
  return iVar3;
}



// WARNING: Unknown calling convention

int deflate_gzip_open(stream_encoded *stream,int fd)

{
  deflate_enc_data *p;
  int iVar1;
  int err;
  deflate_enc_data *data;
  byte bVar2;
  
  bVar2 = 0;
  p = (deflate_enc_data *)mem_alloc(0x13c8);
  stream->data = (void *)0x0;
  iVar1 = -1;
  if (p != (deflate_enc_data *)0x0) {
    data = p;
    for (iVar1 = 0xe; iVar1 != 0; iVar1 = iVar1 + -1) {
      data = (deflate_enc_data *)((int)data + (uint)bVar2 * -8 + 4);
      (data->deflate_stream).next_in = (Bytef *)0x0;
      data = data;
    }
    p->field_0x3c = p->field_0x3c & 0xfc;
    p->fdread = fd;
    iVar1 = inflateInit2_(p,0x2f,"1.2.3.4",0x38);
    if (iVar1 == 0) {
      stream->data = p;
      iVar1 = 0;
    }
    else {
      mem_free(p);
      iVar1 = -1;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * deflate_decode_buffer(int window_size,uchar *data,int len,int *new_len)

{
  int error;
  uchar *puVar1;
  int iVar2;
  uchar *buffer;
  uchar *puVar3;
  z_stream *pzVar4;
  z_stream stream;
  
  *new_len = 0;
  if (len != 0) {
    pzVar4 = &stream;
    for (iVar2 = 0xe; iVar2 != 0; iVar2 = iVar2 + -1) {
      pzVar4->next_in = (Bytef *)0x0;
      pzVar4 = (z_stream *)&pzVar4->avail_in;
    }
    stream.next_in = data;
    stream.avail_in = len;
    iVar2 = inflateInit2_(&stream,window_size,"1.2.3.4",0x38);
    if (iVar2 == 0) {
      puVar3 = (uchar *)0x0;
      do {
        puVar1 = (uchar *)mem_realloc(puVar3,stream.total_out + 0x400);
        if (puVar1 == (uchar *)0x0) {
          inflateEnd(&stream);
          if (puVar3 == (uchar *)0x0) {
            return (uchar *)0x0;
          }
LAB_080aa9c3:
          mem_free(puVar3);
          return (uchar *)0x0;
        }
        stream.avail_out = 0x400;
        stream.next_out = puVar1 + stream.total_out;
        iVar2 = inflate(&stream,2);
        if (iVar2 == 1) break;
        puVar3 = puVar1;
        if (iVar2 != 0) {
          inflateEnd(&stream);
          goto LAB_080aa9c3;
        }
      } while (stream.avail_in != 0);
      inflateEnd(&stream);
      *new_len = stream.total_out;
      return puVar1;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * deflate_gzip_decode_buffer(uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
  puVar1 = deflate_decode_buffer(0x2f,data,len,new_len);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * deflate_raw_decode_buffer(uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
  puVar1 = deflate_decode_buffer(-0xf,data,len,new_len);
  return puVar1;
}



// WARNING: Unknown calling convention

int read_encoded(stream_encoded *stream,uchar *data,int len)

{
  int iVar1;
  
                    // WARNING: Could not recover jumptable at 0x080aaa46. Too many branches
                    // WARNING: Treating indirect jump as call
  iVar1 = (*decoding_backends[stream->encoding]->read)(stream,data,len);
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * decode_encoded_buffer(stream_encoding encoding,uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  
                    // WARNING: Could not recover jumptable at 0x080aaa7b. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar1 = (*decoding_backends[encoding]->decode_buffer)(data,len,new_len);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar ** listext_encoded(stream_encoding encoding)

{
  return decoding_backends[encoding]->extensions;
}



// WARNING: Unknown calling convention

uchar * get_encoding_name(stream_encoding encoding)

{
  return decoding_backends[encoding]->name;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080aab28;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080aab28:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

void dummy_close(stream_encoded *stream)

{
                    // WARNING: Load size is inaccurate
  close(*stream->data);
  mem_free(stream->data);
  return;
}



// WARNING: Unknown calling convention

void close_encoded(stream_encoded *stream)

{
  (*decoding_backends[stream->encoding]->close)(stream);
  mem_free(stream);
  return;
}



// WARNING: Unknown calling convention

uchar * dummy_decode_buffer(uchar *data,int len,int *new_len)

{
  uchar *puVar1;
  uchar *buffer;
  
  puVar1 = memacpy(data,len);
  if (puVar1 != (uchar *)0x0) {
    *new_len = len;
  }
  return puVar1;
}



// WARNING: Unknown calling convention

int dummy_read(stream_encoded *stream,uchar *data,int len)

{
  int __fd;
  ssize_t sVar1;
  int *piVar2;
  ssize_t r;
  
                    // WARNING: Load size is inaccurate
  __fd = *stream->data;
  do {
    sVar1 = read(__fd,data,len);
    if (sVar1 != -1) {
      return sVar1;
    }
    piVar2 = __errno_location();
  } while (*piVar2 == 4);
  return -1;
}



// WARNING: Unknown calling convention

int dummy_open(stream_encoded *stream,int fd)

{
  int *piVar1;
  int iVar2;
  
  piVar1 = (int *)mem_alloc(4);
  stream->data = piVar1;
  iVar2 = -1;
  if (piVar1 != (int *)0x0) {
    *piVar1 = fd;
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

stream_encoded * open_encoded(int fd,stream_encoding encoding)

{
  stream_encoded *p;
  stream_encoded *stream;
  int iVar1;
  stream_encoded *psVar2;
  
  p = (stream_encoded *)mem_alloc(8);
  psVar2 = p;
  if (p != (stream_encoded *)0x0) {
    p->encoding = encoding;
    iVar1 = (*decoding_backends[encoding]->open)(p,fd);
    if (iVar1 < 0) {
      psVar2 = (stream_encoded *)0x0;
      mem_free(p);
    }
  }
  return psVar2;
}



// WARNING: Unknown calling convention

stream_encoding guess_encoding(uchar *filename)

{
  uchar *__s;
  size_t sVar1;
  size_t sVar2;
  int iVar3;
  uchar **ext;
  uchar **ppuVar4;
  stream_encoding local_24;
  
  sVar1 = strlen((char *)filename);
  local_24 = ENCODING_GZIP;
  do {
    for (ppuVar4 = decoding_backends[local_24]->extensions;
        (ppuVar4 != (uchar **)0x0 && (__s = *ppuVar4, __s != (uchar *)0x0)); ppuVar4 = ppuVar4 + 1)
    {
      sVar2 = strlen((char *)__s);
      if (((int)sVar2 <= (int)sVar1) &&
         (iVar3 = strcmp((char *)(filename + (sVar1 - sVar2)),(char *)__s), iVar3 == 0)) {
        return local_24;
      }
    }
    local_24 = local_24 + ENCODING_GZIP;
    if (local_24 == ENCODINGS_KNOWN) {
      return ENCODING_NONE;
    }
  } while( true );
}



// WARNING: Unknown calling convention

connection_state read_file(stream_encoded *stream,int readsize,string *page)

{
  string *psVar1;
  int iVar2;
  int iVar3;
  int readlen;
  uchar *puVar4;
  int *piVar5;
  undefined4 uVar6;
  size_t newsize;
  uint size;
  size_t oldsize;
  uint uVar8;
  connection_state cVar9;
  connection_state cVar10;
  connection_state cVar11;
  undefined4 *in_stack_00000004;
  undefined4 *puVar7;
  
  psVar1 = init_string(page);
  if (psVar1 == (string *)0x0) {
    cVar11 = connection_state((connection_basic_state)in_stack_00000004);
    puVar7 = (undefined4 *)cVar11.syserr;
LAB_080aae83:
    cVar9.syserr = (int)puVar7;
    cVar9.basic = (connection_basic_state)in_stack_00000004;
    return cVar9;
  }
  iVar2 = 0x1000;
  if (readsize != 0) {
    iVar2 = readsize;
  }
  iVar3 = page->length;
  do {
    size = iVar3 + iVar2 + 0x100 & 0xffffff00;
    uVar8 = iVar3 + 0xffU & 0xffffff00;
    if (uVar8 < size) {
      puVar4 = (uchar *)mem_realloc(page->source,size);
      if (puVar4 == (uchar *)0x0) goto LAB_080aae20;
      page->source = puVar4;
      memset(puVar4 + uVar8,0,size - uVar8);
    }
    if (page->source == (uchar *)0x0) {
LAB_080aae20:
      done_string(page);
      if (assert_failed == 0) {
        uVar6 = 0xfffe795c;
      }
      else {
        uVar6 = 0xfffe795d;
      }
      assert_failed = 0;
      in_stack_00000004[1] = 0;
      *in_stack_00000004 = uVar6;
      cVar11.syserr = (int)in_stack_00000004;
      cVar11.basic = (connection_basic_state)in_stack_00000004;
      return cVar11;
    }
    iVar3 = (*decoding_backends[stream->encoding]->read)(stream,page->source + page->length,iVar2);
    if (iVar3 < 0) {
      done_string(page);
      piVar5 = __errno_location();
      if (*piVar5 == 0) {
        cVar11 = connection_state((connection_basic_state)in_stack_00000004);
        puVar7 = (undefined4 *)cVar11.syserr;
      }
      else {
        in_stack_00000004[1] = *piVar5;
        *in_stack_00000004 = 0xffffffff;
        puVar7 = in_stack_00000004;
      }
      goto LAB_080aae83;
    }
    if (iVar3 == 0) {
      puVar4 = page->source;
      puVar4[page->length] = '\0';
      if (assert_failed == 0) {
        uVar6 = 0xfffe7960;
      }
      else {
        uVar6 = 0xfffe795d;
      }
      assert_failed = 0;
      in_stack_00000004[1] = 0;
      *in_stack_00000004 = uVar6;
      cVar10.syserr = (int)puVar4;
      cVar10.basic = (connection_basic_state)in_stack_00000004;
      return cVar10;
    }
    iVar3 = page->length + iVar3;
    page->length = iVar3;
  } while( true );
}



// WARNING: Unknown calling convention

connection_state read_encoded_file(string *filename,string *page)

{
  int fd_00;
  int *piVar1;
  int iVar2;
  stream_encoded *stream_00;
  stream_encoded *stream;
  option_value *poVar3;
  undefined4 extraout_EDX;
  int length;
  int fd;
  undefined4 uVar4;
  uchar **ext;
  uchar **ppuVar5;
  bool bVar6;
  connection_state cVar7;
  connection_state cVar8;
  undefined4 *in_stack_00000004;
  stream_encoding local_94;
  stream_encoding local_90;
  int local_88;
  undefined4 local_84;
  int local_80;
  stat stt;
  
  fd_00 = open64((char *)filename->source,0x100);
  piVar1 = __errno_location();
  local_88 = *piVar1;
  if (fd_00 == -1) {
    poVar3 = get_opt_();
    if (poVar3->tree == (list_head_elinks *)0x0) {
LAB_080ab188:
      *in_stack_00000004 = 0xffffffff;
      in_stack_00000004[1] = local_88;
      cVar8.syserr = local_88;
      cVar8.basic = (connection_basic_state)in_stack_00000004;
      return cVar8;
    }
    iVar2 = filename->length;
    local_94 = ENCODING_GZIP;
    do {
      local_90 = local_94;
      for (ppuVar5 = decoding_backends[local_94]->extensions;
          (ppuVar5 != (uchar **)0x0 && (*ppuVar5 != (uchar *)0x0)); ppuVar5 = ppuVar5 + 1) {
        add_to_string(filename,*ppuVar5);
        fd_00 = open64((char *)filename->source,0x100);
        if (-1 < fd_00) goto LAB_080aaf6f;
        filename->source[iVar2] = '\0';
        filename->length = iVar2;
      }
      local_94 = local_94 + ENCODING_GZIP;
    } while (local_94 != ENCODINGS_KNOWN);
    if (fd_00 == -1) goto LAB_080ab188;
    local_90 = ENCODING_NONE;
  }
  else {
    local_90 = guess_encoding(filename->source);
  }
LAB_080aaf6f:
  set_bin(fd_00);
  iVar2 = __fxstat64(3,fd_00,(stat64 *)&stt);
  if (iVar2 == 0) {
    bVar6 = (stt.st_mode & 0xf000) != 0x8000;
    if (local_90 == ENCODING_NONE) {
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/encoding.c";
        errline = 0x11e;
        iVar2 = elinks_strlcmp(filename->source,filename->length,"/dev/stdin",10);
        if (((iVar2 != 0) ||
            (((stt.st_mode & 0xf000) != 0x1000 && ((stt.st_mode & 0xf000) != 0xc000)))) &&
           (poVar3 = get_opt_(), poVar3->tree == (list_head_elinks *)0x0)) {
          connection_state((connection_basic_state)&local_84);
          local_88 = local_80;
          uVar4 = local_84;
          goto LAB_080aafa5;
        }
      }
    }
    else {
      uVar4 = 0xffffffff;
      if (bVar6) goto LAB_080aafa5;
    }
    stream_00 = open_encoded(fd_00,local_90);
    if (stream_00 == (stream_encoded *)0x0) {
      connection_state((connection_basic_state)&local_84);
      local_88 = local_80;
      uVar4 = local_84;
    }
    else {
      if ((stt.st_size._4_4_ == (int)stt.st_size >> 0x1f) && (-1 < (int)stt.st_size)) {
        read_file(stream_00,(int)stt.st_size,page);
        local_88 = local_80;
      }
      else {
        local_88 = 0x1b;
        local_84 = 0xffffffff;
      }
      close_encoded(stream_00);
      uVar4 = local_84;
    }
  }
  else {
    local_88 = *piVar1;
    uVar4 = 0xffffffff;
  }
LAB_080aafa5:
  close(fd_00);
  *in_stack_00000004 = uVar4;
  in_stack_00000004[1] = local_88;
  cVar7.syserr = extraout_EDX;
  cVar7.basic = (connection_basic_state)in_stack_00000004;
  return cVar7;
}



// WARNING: Unknown calling convention

void lock_formhist_data(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_formhist_data(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_formhist_data_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

listbox_item * get_formhist_data_root(listbox_item *item)

{
  return (listbox_item *)0x0;
}



// WARNING: Unknown calling convention

int can_delete_formhist_data(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void delete_formhist_data(listbox_item *item,int last)

{
  formhist_data *form;
  formhist_data *formhist_data;
  
  form = (formhist_data *)item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)((form->object).refcount != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/formhist/dialogs.c";
    errline = 0x71;
    elinks_internal((uchar *)"assertion !is_object_used(formhist_data) failed!");
    delete_formhist_item(form);
    return;
  }
  delete_formhist_item(form);
  return;
}



// WARNING: Unknown calling convention

uri * get_formhist_data_uri(listbox_item *item)

{
  uri *puVar1;
  
  puVar1 = get_uri((uchar *)((int)item->udata + 0x15),0);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_formhist_data_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  string *psVar2;
  uchar *puVar3;
  submitted_value *sv;
  int *piVar4;
  string info;
  
  pvVar1 = item->udata;
  if (item->type != BI_FOLDER) {
    psVar2 = init_string(&info);
    if (psVar2 != (string *)0x0) {
      puVar3 = _("URL",term);
      add_format_to_string(&info,"%s: %s",puVar3,(int)pvVar1 + 0x15);
      add_char_to_string(&info,'\n');
      if ((*(byte *)((int)pvVar1 + 0x14) & 1) == 0) {
        puVar3 = _((uchar *)"Forms are saved for this URL.",term);
        add_to_string(&info,puVar3);
      }
      else {
        puVar3 = _((uchar *)"Forms are never saved for this URL.",term);
        add_to_string(&info,puVar3);
      }
      add_char_to_string(&info,'\n');
      piVar4 = (int *)**(int **)((int)pvVar1 + 0xc);
      if (piVar4 == *(int **)((int)pvVar1 + 0xc)) {
        return info.source;
      }
      do {
        puVar3 = form_type2str(piVar4[5]);
        add_format_to_string(&info,(uchar *)"\n[%8s] ",puVar3);
        add_to_string(&info,(uchar *)piVar4[2]);
        add_to_string(&info," = ");
        puVar3 = (uchar *)piVar4[3];
        if ((puVar3 != (uchar *)0x0) && (*puVar3 != '\0')) {
          if (piVar4[5] == 1) {
            add_to_string(&info,(uchar *)"********");
          }
          else {
            add_to_string(&info,puVar3);
          }
        }
        piVar4 = (int *)*piVar4;
      } while ((int *)*(int *)((int)pvVar1 + 0xc) != piVar4);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_formhist_data_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  puVar1 = stracpy((uchar *)((int)item->udata + 0x15));
  return puVar1;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_save_button(dialog_data *dlg_data,widget_data *button)

{
  save_formhist_to_file();
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_toggle_dontsave_button(dialog_data *dlg_data,widget_data *button)

{
  void *pvVar1;
  listbox_data *box;
  listbox_data *plVar2;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar2->sel != (listbox_item *)0x0) && (pvVar1 = plVar2->sel->udata, pvVar1 != (void *)0x0))
  {
    *(byte *)((int)pvVar1 + 0x14) =
         *(byte *)((int)pvVar1 + 0x14) & 0xfe | (*(byte *)((int)pvVar1 + 0x14) ^ 1) & 1;
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_login_button(dialog_data *dlg_data,widget_data *button)

{
  void *pvVar1;
  listbox_data *box;
  listbox_data *plVar2;
  terminal *term;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar2->sel != (listbox_item *)0x0) && (pvVar1 = plVar2->sel->udata, pvVar1 != (void *)0x0))
  {
    if ((*(byte *)((int)pvVar1 + 0x14) & 1) != 0) {
      info_box(dlg_data->win->term,0,(uchar *)"Form not saved",ALIGN_CENTER,
               (uchar *)
               "No saved information for this URL.\nIf you want to save passwords for this URL, enable it by pressing the \"Toggle saving\" button."
              );
      return EVENT_PROCESSED;
    }
    push_hierbox_goto_button(dlg_data,button);
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void formhist_manager(session *ses)

{
  load_formhist_from_file();
  hierbox_browser(&formhist_browser,ses);
  return;
}



// WARNING: Unknown calling convention

formhist_data * new_formhist_item(uchar *url)

{
  size_t __n;
  formhist_data *data;
  formhist_data *form;
  list_head_elinks *plVar1;
  listbox_item *plVar2;
  formhist_data *pfVar3;
  
  __n = strlen((char *)url);
  data = (formhist_data *)mem_calloc(1,__n + 0x18);
  pfVar3 = data;
  if (data != (formhist_data *)0x0) {
    memcpy(data->url,url,__n);
    plVar1 = (list_head_elinks *)mem_alloc(8);
    data->submit = plVar1;
    if (plVar1 != (list_head_elinks *)0x0) {
      plVar1->prev = plVar1;
      plVar1->next = plVar1;
      plVar2 = add_listbox_item(&formhist_browser,(listbox_item *)0x0,BI_LEAF,data,1);
      data->box_item = plVar2;
      if (plVar2 != (listbox_item *)0x0) {
        return data;
      }
      mem_free(data->submit);
    }
    pfVar3 = (formhist_data *)0x0;
    mem_free(data);
  }
  return pfVar3;
}



// WARNING: Unknown calling convention

void done_formhist_item(formhist_data *form)

{
  done_listbox_item(&formhist_browser,form->box_item);
  done_submitted_value_list(form->submit);
  mem_free(form->submit);
  mem_free(form);
  return;
}



// WARNING: Unknown calling convention

void dont_remember_form(void *form_)

{
  done_formhist_item((formhist_data *)form_);
  return;
}



// WARNING: Unknown calling convention

void delete_formhist_item(formhist_data *form)

{
  form->next->prev = form->prev;
  form->prev->next = form->next;
  done_formhist_item(form);
  return;
}



// WARNING: Unknown calling convention

void done_form_history(module *module)

{
  formhist_data *form;
  formhist_data *form_00;
  formhist_data *next;
  formhist_data *pfVar1;
  bool bVar2;
  
                    // WARNING: Load size is inaccurate
  form_00 = (formhist_data *)saved_forms.next;
  pfVar1 = *saved_forms.next;
  if ((list_head_elinks *)saved_forms.next != &saved_forms) {
    do {
      delete_formhist_item(form_00);
      bVar2 = pfVar1 != (formhist_data *)&saved_forms;
      form_00 = pfVar1;
      pfVar1 = pfVar1->next;
    } while (bVar2);
  }
  return;
}



// WARNING: Unknown calling convention

int save_formhist_to_file(void)

{
  int iVar1;
  option_value *poVar2;
  int r;
  uchar *puVar3;
  secure_save_info *ssi;
  uchar *puVar4;
  uchar *file;
  int *piVar5;
  uchar *encvalue;
  formhist_data *form;
  list_head_elinks *local_20;
  
  if (((elinks_home != (uchar *)0x0) &&
      (poVar2 = get_opt_(), poVar2->tree == (list_head_elinks *)0x0)) &&
     (puVar3 = straconcat(elinks_home,"formhist",0), puVar3 != (uchar *)0x0)) {
    ssi = secure_open(puVar3);
    mem_free(puVar3);
    if (ssi != (secure_save_info *)0x0) {
      if ((list_head_elinks *)saved_forms.next != &saved_forms) {
        local_20 = (list_head_elinks *)saved_forms.next;
        do {
          if ((*(byte *)&local_20[2].prev & 1) == 0) {
            secure_fprintf(ssi,"%s\n",(undefined *)((int)&local_20[2].prev + 1));
                    // WARNING: Load size is inaccurate
            piVar5 = *local_20[1].prev;
            if (piVar5 != (int *)local_20[1].prev) {
              do {
                puVar3 = (uchar *)piVar5[3];
                if ((puVar3 == (uchar *)0x0) || (*puVar3 == '\0')) {
                  puVar3 = stracpy("");
                }
                else {
                  puVar3 = base64_encode(puVar3);
                }
                if (puVar3 == (uchar *)0x0) {
                  r = 0;
                  return r;
                }
                iVar1 = piVar5[2];
                puVar4 = form_type2str(piVar5[5]);
                secure_fprintf(ssi,"%s\t%s\t%s\n",puVar4,iVar1,puVar3);
                mem_free(puVar3);
                piVar5 = (int *)*piVar5;
              } while ((int *)local_20[1].prev != piVar5);
            }
            secure_fputc(ssi,10);
          }
          else {
            secure_fprintf(ssi,"dontsave\t%s\n\n",(undefined *)((int)&local_20[2].prev + 1));
          }
          local_20 = (list_head_elinks *)local_20->next;
        } while (local_20 != &saved_forms);
      }
      r = secure_close(ssi);
      if (r == 0) {
        r = 0;
        loaded = 1;
        return r;
      }
      return r;
    }
  }
  r = 0;
  return r;
}



// WARNING: Unknown calling convention

void remember_form(void *form_)

{
  formhist_data *pfVar1;
  int iVar2;
  formhist_data *pfVar3;
  formhist_data *form;
  formhist_data *form_00;
  
                    // WARNING: Load size is inaccurate
  pfVar1 = *saved_forms.next;
  form_00 = (formhist_data *)saved_forms.next;
  if ((list_head_elinks *)saved_forms.next != &saved_forms) {
    do {
      pfVar3 = pfVar1;
      iVar2 = strcmp((char *)form_00->url,(char *)((int)form_ + 0x15));
      if (iVar2 == 0) {
        delete_formhist_item(form_00);
        pfVar1 = pfVar3->next;
      }
      else {
        pfVar1 = pfVar3->next;
      }
      form_00 = pfVar3;
    } while (pfVar3 != (formhist_data *)&saved_forms);
  }
  *(list_head_elinks **)((int)form_ + 4) = &saved_forms;
  *(void **)form_ = saved_forms.next;
  saved_forms.next = form_;
                    // WARNING: Load size is inaccurate
  *(void **)(*form_ + 4) = form_;
  save_formhist_to_file();
  return;
}



// WARNING: Unknown calling convention

void never_for_this_site(void *form_)

{
  *(byte *)((int)form_ + 0x14) = *(byte *)((int)form_ + 0x14) | 1;
  remember_form(form_);
  return;
}



// WARNING: Unknown calling convention

int load_formhist_from_file(void)

{
  uchar *puVar1;
  uchar *file;
  FILE *__stream;
  char *pcVar2;
  size_t sVar3;
  formhist_data *form_00;
  form_type type_00;
  submitted_value *psVar4;
  int iVar5;
  formhist_data *form;
  uchar *p;
  int dontsave;
  byte *pbVar6;
  uchar *type;
  byte *pbVar7;
  int in_GS_OFFSET;
  bool bVar8;
  bool bVar9;
  byte bVar10;
  uchar *local_434;
  uchar *local_430;
  uchar tmp [1024];
  int local_20;
  
  bVar10 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  iVar5 = 1;
  if (loaded == 0) {
    if ((elinks_home != (uchar *)0x0) &&
       (puVar1 = straconcat(elinks_home,"formhist",0), puVar1 != (uchar *)0x0)) {
      __stream = fopen64((char *)puVar1,"rb");
      mem_free(puVar1);
      if (__stream != (FILE *)0x0) {
LAB_080aba3e:
        while (pcVar2 = fgets((char *)tmp,0x400,__stream), pcVar2 != (char *)0x0) {
          if ((tmp[0] != '\n') || (tmp[1] != '\0')) {
            pcVar2 = strchr((char *)tmp,9);
            bVar8 = false;
            bVar9 = pcVar2 == (char *)0x0;
            if (bVar9) {
              iVar5 = 9;
              pbVar6 = tmp;
              pbVar7 = (byte *)"dontsave,";
              do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                bVar9 = *pbVar6 == *pbVar7;
                pbVar6 = pbVar6 + (uint)bVar10 * -2 + 1;
                pbVar7 = pbVar7 + (uint)bVar10 * -2 + 1;
              } while (bVar9);
              if (bVar9) {
                puVar1 = tmp + 9;
                bVar8 = true;
              }
              else {
                puVar1 = tmp;
                bVar8 = false;
              }
            }
            else {
              *pcVar2 = '\0';
              iVar5 = 9;
              puVar1 = (uchar *)(pcVar2 + 1);
              pbVar6 = tmp;
              pbVar7 = (byte *)"dontsave";
              do {
                if (iVar5 == 0) break;
                iVar5 = iVar5 + -1;
                bVar8 = *pbVar6 < *pbVar7;
                bVar9 = *pbVar6 == *pbVar7;
                pbVar6 = pbVar6 + (uint)bVar10 * -2 + 1;
                pbVar7 = pbVar7 + (uint)bVar10 * -2 + 1;
              } while (bVar9);
              bVar8 = (!bVar8 && !bVar9) == bVar8;
            }
            sVar3 = strlen((char *)puVar1);
            puVar1[sVar3 - 1] = '\0';
            form_00 = new_formhist_item(puVar1);
            if (form_00 != (formhist_data *)0x0) {
              if (bVar8) {
                form_00->field_0x14 = form_00->field_0x14 | 1;
              }
LAB_080abae8:
              do {
                pcVar2 = fgets((char *)tmp,0x400,__stream);
                if ((pcVar2 == (char *)0x0) || ((tmp[0] == '\n' && (tmp[1] == '\0'))))
                goto LAB_080abc4d;
                pcVar2 = strchr((char *)tmp,9);
                if (pcVar2 == (char *)0x0) goto fail;
                local_430 = (uchar *)(pcVar2 + 1);
                *pcVar2 = '\0';
                pcVar2 = strchr((char *)local_430,9);
                if (pcVar2 == (char *)0x0) {
                  if (tmp[0] == '*') {
                    local_434 = tmp + 1;
                    puVar1 = "password";
                  }
                  else {
                    local_434 = tmp;
                    puVar1 = "text";
                  }
                }
                else {
                  *pcVar2 = '\0';
                  puVar1 = tmp;
                  local_434 = local_430;
                  local_430 = (uchar *)(pcVar2 + 1);
                }
                pcVar2 = strchr((char *)local_430,10);
                if (pcVar2 == (char *)0x0) goto fail;
                *pcVar2 = '\0';
                type_00 = str2form_type(puVar1);
                if (type_00 == ~FC_TEXT) goto fail;
              } while ((form_00->field_0x14 & 1) != 0);
              if (*local_430 == '\0') {
                puVar1 = stracpy(local_430);
              }
              else {
                puVar1 = base64_decode(local_430);
              }
              if (puVar1 != (uchar *)0x0) {
                psVar4 = init_submitted_value(local_434,puVar1,type_00,(form_control *)0x0,0);
                mem_free(puVar1);
                if (psVar4 != (submitted_value *)0x0) {
                  psVar4->next = (submitted_value *)form_00->submit->next;
                  psVar4->prev = (submitted_value *)form_00->submit;
                  form_00->submit->next = psVar4;
                  psVar4->next->prev = psVar4;
                  goto LAB_080abae8;
                }
              }
fail:
              done_formhist_item(form_00);
              iVar5 = 0;
              goto LAB_080abc22;
            }
          }
        }
        fclose(__stream);
        iVar5 = 1;
        loaded = 1;
        goto LAB_080abc22;
      }
    }
    iVar5 = 0;
  }
LAB_080abc22:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar5;
LAB_080abc4d:
  form_00->prev = (formhist_data *)&saved_forms;
  form_00->next = (formhist_data *)saved_forms.next;
  saved_forms.next = form_00;
  form_00->next->prev = form_00;
  goto LAB_080aba3e;
}



// WARNING: Unknown calling convention

void memorize_form(session *ses,list_head_elinks *submit,form *forminfo)

{
  list_head_elinks *plVar1;
  int **ppiVar2;
  int **ppiVar3;
  int *piVar4;
  submitted_value *sv;
  formhist_data *form_00;
  submitted_value *sv2;
  submitted_value *psVar5;
  int iVar6;
  uchar *value;
  submitted_value *sv2_1;
  int **ppiVar7;
  formhist_data *form;
  int local_34;
  list_head_elinks *local_30;
  int local_28;
  list_head_elinks *local_20;
  
  plVar1 = (list_head_elinks *)submit->next;
  while( true ) {
    if (plVar1 == submit) {
      return;
    }
                    // WARNING: Load size is inaccurate
    if (((plVar1[2].prev == (void *)0x1) && ((char *)plVar1[1].prev != (char *)0x0)) &&
       (*plVar1[1].prev != '\0')) break;
    plVar1 = (list_head_elinks *)plVar1->next;
  }
  form_00 = new_formhist_item(forminfo->action);
  if (form_00 == (formhist_data *)0x0) {
    return;
  }
  plVar1 = (list_head_elinks *)submit->next;
  while (plVar1 != submit) {
    if (plVar1[2].prev < (void *)0x2) {
      psVar5 = init_submitted_value
                         ((uchar *)plVar1[1].next,(uchar *)plVar1[1].prev,(form_type)plVar1[2].prev,
                          (form_control *)0x0,0);
      if (psVar5 == (submitted_value *)0x0) goto fail;
      psVar5->next = (submitted_value *)form_00->submit->next;
      psVar5->prev = (submitted_value *)form_00->submit;
      form_00->submit->next = psVar5;
      psVar5->next->prev = psVar5;
      plVar1 = (list_head_elinks *)plVar1->next;
    }
    else {
      plVar1 = (list_head_elinks *)plVar1->next;
    }
  }
  iVar6 = load_formhist_from_file();
  if ((iVar6 != 0) &&
     (local_30 = (list_head_elinks *)saved_forms.next,
     (list_head_elinks *)saved_forms.next != &saved_forms)) {
    do {
      iVar6 = strcmp((char *)((int)&local_30[2].prev + 1),(char *)form_00->url);
      if (iVar6 == 0) {
        if ((*(byte *)&local_30[2].prev & 1) != 0) {
fail:
          done_formhist_item(form_00);
          return;
        }
        plVar1 = form_00->submit;
        local_20 = (list_head_elinks *)plVar1->next;
        if (local_20 != plVar1) {
          ppiVar2 = (int **)local_30[1].prev;
          ppiVar3 = (int **)*ppiVar2;
          local_34 = 0;
          local_28 = 0;
          do {
            if (ppiVar3 != ppiVar2) {
              piVar4 = (int *)local_20[2].prev;
              ppiVar7 = ppiVar3;
              do {
                if ((piVar4 == ppiVar7[5]) &&
                   (iVar6 = strcmp((char *)local_20[1].next,(char *)ppiVar7[2]), iVar6 == 0)) {
                  local_34 = local_34 + 1;
                  if ((ppiVar7[3] != (int *)0x0) &&
                     (iVar6 = strcmp((char *)local_20[1].prev,(char *)ppiVar7[3]), iVar6 != 0))
                  goto LAB_080abf3d;
                  break;
                }
                ppiVar7 = (int **)*ppiVar7;
              } while (ppiVar7 != ppiVar2);
            }
            local_28 = local_28 + 1;
            local_20 = (list_head_elinks *)local_20->next;
          } while (local_20 != plVar1);
          if (((local_34 != 0) && (local_28 != 0)) && (local_28 == local_34)) goto fail;
        }
      }
      local_30 = (list_head_elinks *)local_30->next;
    } while (local_30 != &saved_forms);
  }
LAB_080abf3d:
  msg_box(ses->tab->term,(memory_list *)0x0,0,"Form history",ALIGN_CENTER,
          (uchar *)
          "Should this login be remembered?\n\nPlease note that the password will be stored obscured (but unencrypted) in a file on your disk.\n\nIf you are using a valuable password, answer NO."
          ,form_00,3,&DAT_0812762b,remember_form,1,&DAT_08127627,dont_remember_form,2,
          "Ne~ver for this site",never_for_this_site,0);
  return;
}



// WARNING: Unknown calling convention

uchar * get_form_history_value(uchar *url,uchar *name)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int iVar3;
  submitted_value *sv;
  list_head_elinks *local_20;
  
  if ((((url != (uchar *)0x0) && (name != (uchar *)0x0)) && (*url != '\0')) &&
     ((*name != '\0' && (iVar3 = load_formhist_from_file(), iVar3 != 0)))) {
    for (local_20 = (list_head_elinks *)saved_forms.next; local_20 != &saved_forms;
        local_20 = (list_head_elinks *)local_20->next) {
      if (((*(byte *)&local_20[2].prev & 1) == 0) &&
         (iVar3 = strcmp((char *)((int)&local_20[2].prev + 1),(char *)url), iVar3 == 0)) {
        puVar1 = (undefined4 *)local_20[1].prev;
        for (puVar2 = (undefined4 *)*puVar1; puVar2 != puVar1; puVar2 = (undefined4 *)*puVar2) {
          iVar3 = strcmp((char *)puVar2[2],(char *)name);
          if (iVar3 == 0) {
            return (uchar *)puVar2[3];
          }
        }
      }
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void lock_globhist_item(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_globhist_item(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_globhist_item_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

listbox_item * get_globhist_item_root(listbox_item *box_item)

{
  return (listbox_item *)0x0;
}



// WARNING: Unknown calling convention

int can_delete_globhist_item(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void delete_globhist_item(listbox_item *item,int last)

{
  global_history_item *history_item;
  global_history_item *historyitem;
  
  history_item = (global_history_item *)item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)((history_item->object).refcount != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/globhist/dialogs.c";
    errline = 0x62;
    elinks_internal((uchar *)"assertion !is_object_used(historyitem) failed!");
    delete_global_history_item(history_item);
    return;
  }
  delete_global_history_item(history_item);
  return;
}



// WARNING: Unknown calling convention

uri * get_globhist_item_uri(listbox_item *item)

{
  uri *puVar1;
  
  puVar1 = get_uri(*(uchar **)((int)item->udata + 0x14),0);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_globhist_item_info(listbox_item *box_item,terminal *term)

{
  void *pvVar1;
  undefined4 uVar2;
  string *psVar3;
  uchar *puVar4;
  char *pcVar5;
  string info;
  
  pvVar1 = box_item->udata;
  if (box_item->type != BI_FOLDER) {
    psVar3 = init_string(&info);
    if (psVar3 != (string *)0x0) {
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x10);
      puVar4 = _((uchar *)"Title",term);
      add_format_to_string(&info,"%s: %s",puVar4,uVar2);
      uVar2 = *(undefined4 *)((int)pvVar1 + 0x14);
      puVar4 = _("URL",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar4,uVar2);
      pcVar5 = ctime((time_t *)((int)pvVar1 + 0x18));
      puVar4 = _((uchar *)"Last visit time",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s",puVar4,pcVar5);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_globhist_item_text(listbox_item *box_item,terminal *term)

{
  void *pvVar1;
  option_value *poVar2;
  uchar *puVar3;
  string *psVar4;
  global_history_item *item;
  string info;
  
  pvVar1 = box_item->udata;
  poVar2 = get_opt_();
  if ((poVar2->tree == (list_head_elinks *)0x0) ||
     (puVar3 = *(uchar **)((int)pvVar1 + 0x10), *puVar3 == '\0')) {
    psVar4 = init_string(&info);
    puVar3 = (uchar *)0x0;
    if (psVar4 != (string *)0x0) {
      add_string_uri_to_string(&info,*(uchar **)((int)pvVar1 + 0x14),URI_PUBLIC);
      return info.source;
    }
  }
  else {
    puVar3 = stracpy(puVar3);
  }
  return puVar3;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_toggle_display_button(dialog_data *dlg_data,widget_data *widget_data)

{
  option_value *poVar1;
  option_value oVar2;
  
  poVar1 = get_opt_();
  oVar2.number._1_3_ = 0;
  oVar2.number._0_1_ = poVar1->tree == (list_head_elinks *)0x0;
  *poVar1 = oVar2;
  update_hierbox_browser(&globhist_browser);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

widget_handler_status_T push_search_button(dialog_data *dlg_data,widget_data *widget_data)

{
  do_edit_dialog(dlg_data->win->term,1,(uchar *)"Search history",gh_last_searched_title,
                 gh_last_searched_url,(session *)dlg_data->dlg->udata,dlg_data,history_search_do,
                 (_func_void_dialog_ptr *)0x0,(void *)0x0,EDIT_DLG_SEARCH);
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void history_search_do(void *data)

{
  undefined4 *puVar1;
  void *pvVar2;
  listbox_data *box;
  int iVar3;
  listbox_item *item;
  
  pvVar2 = globhist_browser.root.child.next;
  iVar3 = globhist_simple_search(*(uchar **)((int)data + 0x60),*(uchar **)((int)data + 0x30));
  if ((iVar3 != 0) &&
     (puVar1 = (undefined4 *)globhist_browser.boxes.next,
     (list_head_elinks *)globhist_browser.root.child.next != &globhist_browser.root.child)) {
    for (; (list_head_elinks *)puVar1 != &globhist_browser.boxes; puVar1 = (undefined4 *)*puVar1) {
      puVar1[4] = pvVar2;
      puVar1[3] = pvVar2;
    }
  }
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T
push_bookmark_button(dialog_data *dlg_data,widget_data *some_useless_info_button)

{
  void *pvVar1;
  listbox_data *box;
  listbox_data *plVar2;
  global_history_item *historyitem;
  terminal *term;
  
  plVar2 = get_listbox_widget_data(dlg_data->widgets_data);
  if ((plVar2->sel != (listbox_item *)0x0) && (pvVar1 = plVar2->sel->udata, pvVar1 != (void *)0x0))
  {
    launch_bm_add_dialog
              (dlg_data->win->term,(dialog_data *)0x0,(session *)0x0,*(uchar **)((int)pvVar1 + 0x10)
               ,*(uchar **)((int)pvVar1 + 0x14));
  }
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

void history_manager(session *ses)

{
  if (gh_last_searched_title != (uchar *)0x0) {
    mem_free(gh_last_searched_title);
  }
  gh_last_searched_title = (uchar *)0x0;
  if (gh_last_searched_url != (uchar *)0x0) {
    mem_free(gh_last_searched_url);
  }
  gh_last_searched_url = (uchar *)0x0;
  hierbox_browser(&globhist_browser,ses);
  return;
}



// WARNING: Unknown calling convention

void reap_deleted_globhist_items(void)

{
  list_head_elinks *plVar1;
  bool bVar2;
  global_history_item *history_item;
  list_head_elinks *p;
  global_history_item *next;
  list_head_elinks *plVar3;
  
                    // WARNING: Load size is inaccurate
  p = (list_head_elinks *)global_history_reap_list.next;
  plVar3 = *global_history_reap_list.next;
  if ((list_head_elinks *)global_history_reap_list.next != &global_history_reap_list) {
    do {
      if (p[1].next == (void *)0x0) {
        *(void **)((int)p->next + 4) = p->prev;
        *(void **)p->prev = p->next;
        mem_free(p[2].next);
        mem_free(p[2].prev);
        mem_free(p);
        plVar1 = (list_head_elinks *)plVar3->next;
      }
      else {
        plVar1 = (list_head_elinks *)plVar3->next;
      }
      bVar2 = plVar3 != &global_history_reap_list;
      p = plVar3;
      plVar3 = plVar1;
    } while (bVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void write_global_history(void)

{
  option_value *poVar1;
  uchar *file_name;
  secure_save_info *ssi_00;
  int iVar2;
  global_history_item *history_item;
  input_history *piVar3;
  secure_save_info *ssi;
  
  if (((((global_history._12_1_ & 1) != 0) && (elinks_home != (uchar *)0x0)) &&
      (global_history_options[1].option_elinks.value.tree != (list_head_elinks *)0x0)) &&
     ((poVar1 = get_opt_(), poVar1->tree == (list_head_elinks *)0x0 &&
      (file_name = straconcat(elinks_home,"globhist",0), file_name != (uchar *)0x0)))) {
    ssi_00 = secure_open(file_name);
    mem_free(file_name);
    if (ssi_00 != (secure_save_info *)0x0) {
      piVar3 = (input_history *)global_history.entries.prev;
      if ((input_history *)global_history.entries.prev != &global_history) {
        do {
          iVar2 = secure_fprintf(ssi_00,"%s\t%s\t%ld\n",piVar3[1].entries.next,
                                 piVar3[1].entries.prev,piVar3[1].size);
          if (iVar2 < 0) break;
          piVar3 = (input_history *)(piVar3->entries).prev;
        } while (piVar3 != &global_history);
      }
      iVar2 = secure_close(ssi_00);
      if (iVar2 == 0) {
        global_history._12_1_ = global_history._12_1_ & 0xfe;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

evhook_status global_history_write_hook(va_list ap,void *data)

{
  write_global_history();
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

int globhist_simple_search(uchar *search_url,uchar *search_title)

{
  byte *pbVar1;
  uchar uVar2;
  char *pcVar3;
  input_history *piVar4;
  global_history_item *history_item;
  
  if ((search_title != (uchar *)0x0) && (search_url != (uchar *)0x0)) {
    if (gh_last_searched_title != (uchar *)0x0) {
      mem_free(gh_last_searched_title);
    }
    gh_last_searched_title = stracpy(search_title);
    if (gh_last_searched_title != (uchar *)0x0) {
      if (gh_last_searched_url != (uchar *)0x0) {
        mem_free(gh_last_searched_url);
      }
      gh_last_searched_url = stracpy(search_url);
      if (gh_last_searched_url != (uchar *)0x0) {
        uVar2 = *search_title;
        if ((uVar2 == '\0') && (*search_url == '\0')) {
          piVar4 = (input_history *)global_history.entries.next;
          if ((input_history *)global_history.entries.next != &global_history) {
            do {
              pbVar1 = (byte *)(*(int *)&piVar4->field_0xc + 0x18);
              *pbVar1 = *pbVar1 | 2;
              piVar4 = (input_history *)(piVar4->entries).next;
            } while (piVar4 != &global_history);
          }
        }
        else {
          piVar4 = (input_history *)global_history.entries.next;
          if ((input_history *)global_history.entries.next != &global_history) {
            while( true ) {
              if (((uVar2 == '\0') ||
                  (pcVar3 = strcasestr((char *)piVar4[1].entries.next,(char *)search_title),
                  pcVar3 == (char *)0x0)) &&
                 ((*search_url == '\0' ||
                  (pcVar3 = c_strcasestr((char *)piVar4[1].entries.prev,(char *)search_url),
                  pcVar3 == (char *)0x0)))) {
                pbVar1 = (byte *)(*(int *)&piVar4->field_0xc + 0x18);
                *pbVar1 = *pbVar1 & 0xfd;
                piVar4 = (input_history *)(piVar4->entries).next;
              }
              else {
                pbVar1 = (byte *)(*(int *)&piVar4->field_0xc + 0x18);
                *pbVar1 = *pbVar1 | 2;
                piVar4 = (input_history *)(piVar4->entries).next;
              }
              if (piVar4 == &global_history) break;
              uVar2 = *search_title;
            }
          }
        }
        return 1;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

global_history_item * get_global_history_item(uchar *url)

{
  hash *hash;
  hash_item *item;
  size_t keylen;
  hash_item *phVar1;
  
  hash = globhist_cache;
  if ((url != (uchar *)0x0) && (globhist_cache != (hash *)0x0)) {
    keylen = strlen((char *)url);
    phVar1 = get_hash_item(hash,url,keylen);
    if (phVar1 != (hash_item *)0x0) {
      return (global_history_item *)phVar1->value;
    }
  }
  return (global_history_item *)0x0;
}



// WARNING: Unknown calling convention

void delete_global_history_item(global_history_item *history_item)

{
  uchar *key;
  hash *hash;
  size_t keylen;
  hash_item *item_00;
  hash_item *item;
  
  history_item->next->prev = history_item->prev;
  history_item->prev->next = history_item->next;
  hash = globhist_cache;
  global_history.size = global_history.size + -1;
  if ((global_history._12_1_ & 2) == 0) {
    global_history._12_1_ = global_history._12_1_ | 1;
  }
  if (globhist_cache != (hash *)0x0) {
    key = history_item->url;
    keylen = strlen((char *)key);
    item_00 = get_hash_item(hash,key,keylen);
    if (item_00 != (hash_item *)0x0) {
      del_hash_item(globhist_cache,item_00);
      globhist_cache_entries = globhist_cache_entries + -1;
    }
  }
  done_listbox_item(&globhist_browser,history_item->box_item);
  history_item->box_item = (listbox_item *)0x0;
  history_item->prev = (global_history_item *)&global_history_reap_list;
  history_item->next = (global_history_item *)global_history_reap_list.next;
  global_history_reap_list.next = history_item;
  history_item->next->prev = history_item;
  return;
}



// WARNING: Unknown calling convention

void done_global_history(module *module)

{
  void *p;
  void *p_1;
  
  write_global_history();
  if (globhist_cache != (hash *)0x0) {
    free_hash(&globhist_cache);
    globhist_cache_entries = 0;
  }
  while ((input_history *)global_history.entries.next != &global_history) {
    delete_global_history_item((global_history_item *)global_history.entries.next);
  }
  reap_deleted_globhist_items();
  if (gh_last_searched_title != (uchar *)0x0) {
    mem_free(gh_last_searched_title);
  }
  if (gh_last_searched_url != (uchar *)0x0) {
    mem_free(gh_last_searched_url);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void add_global_history_item(uchar *url,uchar *title,time_t vtime)

{
  option_value oVar1;
  hash *hash;
  global_history_item *history_item_00;
  global_history_item *history_item_1;
  void **data;
  uchar *puVar2;
  int iVar3;
  listbox_item *plVar4;
  size_t keylen;
  hash_item *phVar5;
  void *p;
  void *p_00;
  int max_globhist_items;
  global_history_item *history_item;
  
  oVar1.tree = global_history_options[2].option_elinks.value.tree;
  if ((url == (uchar *)0x0) ||
     (global_history_options[1].option_elinks.value.tree == (list_head_elinks *)0x0)) {
    return;
  }
  history_item_00 = get_global_history_item(url);
  if (history_item_00 != (global_history_item *)0x0) {
    delete_global_history_item(history_item_00);
  }
  while (oVar1.number <= global_history.size) {
    if ((input_history *)global_history.entries.prev == &global_history) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/globhist/globhist.c";
      errline = 0xe9;
      elinks_internal((uchar *)"global history is empty");
      global_history.size = 0;
      return;
    }
    delete_global_history_item((global_history_item *)global_history.entries.prev);
  }
  reap_deleted_globhist_items();
  data = (void **)mem_calloc(1,0x1c);
  if (data == (void **)0x0) {
    return;
  }
  data[6] = (void *)vtime;
  puVar2 = "";
  if (title != (uchar *)0x0) {
    puVar2 = title;
  }
  puVar2 = stracpy(puVar2);
  data[4] = puVar2;
  if (puVar2 == (uchar *)0x0) goto LAB_080acb6c;
  sanitize_title(puVar2);
  puVar2 = stracpy(url);
  data[5] = puVar2;
  if (puVar2 != (uchar *)0x0) {
    iVar3 = sanitize_url(puVar2);
    if (iVar3 == 0) {
      p_00 = data[5];
      if (p_00 == (void *)0x0) goto LAB_080acb61;
    }
    else {
      plVar4 = add_listbox_item(&globhist_browser,(listbox_item *)0x0,BI_LEAF,data,1);
      data[3] = plVar4;
      if (plVar4 != (listbox_item *)0x0) {
        data[1] = &global_history;
        *data = global_history.entries.next;
        global_history.entries.next = data;
        *(void ***)((int)*data + 4) = data;
        global_history.size = global_history.size + 1;
        if ((global_history._12_1_ & 2) == 0) {
          global_history._12_1_ = global_history._12_1_ | 1;
        }
        if ((globhist_cache == (hash *)0x0) &&
           (globhist_cache = init_hash8(), globhist_cache == (hash *)0x0)) {
          return;
        }
        hash = globhist_cache;
        if (oVar1.number <= globhist_cache_entries) {
          return;
        }
        puVar2 = (uchar *)data[5];
        keylen = strlen((char *)puVar2);
        phVar5 = add_hash_item(hash,puVar2,keylen,data);
        if (phVar5 == (hash_item *)0x0) {
          return;
        }
        globhist_cache_entries = globhist_cache_entries + 1;
        return;
      }
      p_00 = data[5];
    }
    mem_free(p_00);
  }
LAB_080acb61:
  mem_free(data[4]);
LAB_080acb6c:
  mem_free(data);
  return;
}



// WARNING: Unknown calling convention

void read_global_history(void)

{
  int iVar1;
  option_value *poVar2;
  FILE *__stream;
  char *pcVar3;
  char *pcVar4;
  long vtime;
  uchar *file_name;
  char *pcVar5;
  uchar *url;
  int in_GS_OFFSET;
  uchar in_buffer [3072];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (global_history_options[1].option_elinks.value.tree != (list_head_elinks *)0x0) {
    poVar2 = get_opt_();
    if (poVar2->tree == (list_head_elinks *)0x0) {
      pcVar5 = "globhist";
      if (elinks_home != (uchar *)0x0) {
        pcVar5 = (char *)straconcat(elinks_home,"globhist",0);
        if ((uchar *)pcVar5 == (uchar *)0x0) goto LAB_080acbc0;
      }
      __stream = fopen64(pcVar5,"rb");
      if (elinks_home != (uchar *)0x0) {
        mem_free(pcVar5);
      }
      if (__stream != (FILE *)0x0) {
        global_history._12_1_ = global_history._12_1_ | 2;
        while( true ) {
          pcVar5 = fgets((char *)in_buffer,0xc00,__stream);
          if (pcVar5 == (char *)0x0) break;
          pcVar5 = strchr((char *)in_buffer,9);
          if (pcVar5 != (char *)0x0) {
            *pcVar5 = '\0';
            pcVar3 = strchr(pcVar5 + 1,9);
            if (pcVar3 != (char *)0x0) {
              *pcVar3 = '\0';
              pcVar4 = strchr(pcVar3 + 1,10);
              if (pcVar4 != (char *)0x0) {
                *pcVar4 = '\0';
                vtime = strtol(pcVar3 + 1,(char **)0x0,10);
                add_global_history_item((uchar *)(pcVar5 + 1),in_buffer,vtime);
              }
            }
          }
        }
        global_history._12_1_ = global_history._12_1_ & 0xfd;
        fclose(__stream);
      }
    }
  }
LAB_080acbc0:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void init_global_history(module *module)

{
  read_global_history();
  return;
}



// WARNING: Unknown calling convention

int utf8charlen(uchar *p)

{
  int iVar1;
  
  iVar1 = 0;
  if (p != (uchar *)0x0) {
    iVar1 = (int)"\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                 [*p];
  }
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * utf8_prevchar(uchar *current,int pos,uchar *start)

{
  if (((start == (uchar *)0x0) || (current == (uchar *)0x0)) || (pos < 0)) {
    current = (byte *)0x0;
  }
  else {
    while (current != start) {
      while( true ) {
        if (pos < 1) {
          return current;
        }
        current = current + -1;
        if (((char)*current < '\0') && ((*current & 0xc0) != 0xc0)) break;
        pos = pos + -1;
        if (current == start) {
          return current;
        }
      }
    }
  }
  return current;
}



// WARNING: Unknown calling convention

int unicode_to_cell(unicode_val_T c)

{
  if ((0x10ff < c) &&
     (((((c == 0x2329 || (c < 0x1160)) || (c == 0x232a)) ||
       ((((c - 0x2e80 < 0x7650 && (c != 0x303f)) ||
         ((c - 0xac00 < 0x2ba4 || ((c - 0xf900 < 0x200 || (c - 0xfe30 < 0x40)))))) ||
        (c - 0xff00 < 0x61)))) ||
      (((c - 0xffe0 < 7 || (c - 0x20000 < 0xfffe)) || (c - 0x30000 < 0xfffe)))))) {
    return 2;
  }
  return 1;
}



// WARNING: Unknown calling convention

int hits_cmp(void *v1,void *v2)

{
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
  if (*v1 == *v2) {
    return 0;
  }
  return -(uint)(*v2 < *v1) | 1;
}



// WARNING: Unknown calling convention

int compare_entities(void *key_,void *element_)

{
  byte bVar1;
  int length;
  int iVar2;
  uchar *first;
  byte *pbVar3;
  uchar *second;
  byte *pbVar4;
  
  iVar2 = *(int *)((int)key_ + 4);
                    // WARNING: Load size is inaccurate
  pbVar3 = *key_;
                    // WARNING: Load size is inaccurate
  pbVar4 = *element_;
  if (iVar2 == 0) {
LAB_080acee8:
    iVar2 = 0;
    if (*pbVar4 != 0) {
      return -1;
    }
  }
  else {
    for (; bVar1 = *pbVar4, *pbVar3 < bVar1 || *pbVar3 == bVar1; pbVar3 = pbVar3 + 1) {
      if (*pbVar3 < bVar1) {
        return -1;
      }
      pbVar4 = pbVar4 + 1;
      iVar2 = iVar2 + -1;
      if (iVar2 == 0) goto LAB_080acee8;
    }
    iVar2 = 1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void charsets_list_reset(void)

{
  i_name = 0;
  i_alias = 0;
  return;
}



// WARNING: Unknown calling convention

fastfind_key_value * charsets_list_next(void)

{
  fastfind_key_value *pfVar1;
  
  pfVar1 = (fastfind_key_value *)0x0;
  if (codepages[i_name].name != (uchar *)0x0) {
    charsets_list_next::kv.data = codepages + i_name;
    charsets_list_next::kv.key = codepages[i_name].aliases[i_alias];
    i_alias = i_alias + 1;
    if (codepages[i_name].aliases[i_alias] == (uchar *)0x0) {
      i_name = i_name + 1;
      i_alias = 0;
      return &charsets_list_next::kv;
    }
    pfVar1 = &charsets_list_next::kv;
  }
  return pfVar1;
}



// WARNING: Unknown calling convention

uchar * get_cp_name(int cp_index)

{
  char *pcVar1;
  
  pcVar1 = "none";
  if ((-1 < cp_index) && (pcVar1 = "System", -1 < (char)cp_index)) {
    pcVar1 = (char *)codepages[cp_index].name;
  }
  return (uchar *)pcVar1;
}



// WARNING: Unknown calling convention

uchar * get_cp_config_name(int cp_index)

{
  char *pcVar1;
  
  pcVar1 = "none";
  if ((-1 < cp_index) && (pcVar1 = "System", -1 < (char)cp_index)) {
    pcVar1 = (char *)0x0;
    if (codepages[cp_index].aliases != (uchar **)0x0) {
      return *codepages[cp_index].aliases;
    }
  }
  return (uchar *)pcVar1;
}



// WARNING: Unknown calling convention

uchar * get_cp_mime_name(int cp_index)

{
  uchar *puVar1;
  
  puVar1 = "none";
  if (-1 < cp_index) {
    puVar1 = (uchar *)0x0;
    if (codepages[cp_index & 0xffffff7f].aliases != (uchar **)0x0) {
      return *codepages[cp_index & 0xffffff7f].aliases;
    }
  }
  return puVar1;
}



// WARNING: Unknown calling convention

int is_cp_utf8(int cp_index)

{
  return (uint)(codepages[cp_index & 0xffffff7f].aliases == aliases_utf8);
}



// WARNING: Unknown calling convention

void free_charsets_lookup(void)

{
  fastfind_done(&ff_charsets_index);
  return;
}



// WARNING: Unknown calling convention

void init_charsets_lookup(void)

{
  fastfind_index(&ff_charsets_index,FF_COMPRESS);
  return;
}



// WARNING: Unknown calling convention

int get_cp_index(uchar *name)

{
  int iVar1;
  size_t key_len;
  codepage_desc *pcVar2;
  codepage_desc *codepage;
  uint uVar3;
  uint uVar4;
  int syscp;
  
  uVar4 = 0;
  iVar1 = c_strcasecmp((char *)name,"System");
  if (iVar1 == 0) {
    uVar4 = 0x80;
    name = (uchar *)nl_langinfo(0xe);
  }
  key_len = strlen((char *)name);
  pcVar2 = (codepage_desc *)fastfind_search(&ff_charsets_index,name,key_len);
  if (pcVar2 == (codepage_desc *)0x0) {
    uVar3 = 0xffffffff;
    if (uVar4 != 0) {
      uVar3 = get_cp_index((uchar *)"us-ascii");
      uVar3 = uVar3 | uVar4;
    }
  }
  else {
    if (assert_failed == 0) {
      if ((pcVar2 < codepages) ||
         ((codepage_desc *)((int)&codepages[0x22].table_elinks + 3) < pcVar2)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 0x585;
        elinks_internal((uchar *)
                        "assertion codepages <= codepage && codepage < codepages + N_CODEPAGES failed!"
                       );
      }
      else {
        assert_failed = 0;
      }
    }
    uVar3 = (int)(pcVar2 + -0x8104f8) >> 4 | uVar4;
  }
  return uVar3;
}



// WARNING: Unknown calling convention

unicode_val_T cp2u(int from,uchar c)

{
  unicode_val_T u;
  unicode_val_T uVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0xfffd;
  }
  assert_failed = (int)(codepages[from & 0xffffff7fU].aliases == aliases_utf8);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x2e8;
    elinks_internal((uchar *)"assertion !is_cp_ptr_utf8(&codepages[from]) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0xfffd;
    }
  }
  if ((char)c < '\0') {
    uVar1 = (unicode_val_T)codepages[from & 0xffffff7fU].highhalf[c - 0x80];
    if (uVar1 == 0xffff) {
      uVar1 = 0xfffd;
    }
    return uVar1;
  }
  return (uint)c;
}



// WARNING: Unknown calling convention

unicode_val_T utf8_to_unicode(uchar **string,uchar *end)

{
  byte bVar1;
  byte *pbVar2;
  unicode_val_T u;
  uint uVar3;
  byte *pbVar4;
  uchar *str;
  uint uVar5;
  
  pbVar2 = *string;
  bVar1 = *pbVar2;
  uVar5 = (uint)bVar1;
  if (end < pbVar2 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                     [uVar5]) {
    return 0xfffffffd;
  }
  switch("\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
         [uVar5]) {
  default:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x2cf;
    elinks_internal((uchar *)"utf8char_len_tab out of range");
    pbVar4 = *string + 1;
    break;
  case '\x01':
    uVar3 = (uint)bVar1;
    if (-1 < (char)bVar1) {
LAB_080ad390:
      *string = pbVar2 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                         [uVar5];
      return uVar3;
    }
    pbVar4 = pbVar2 + 1;
    break;
  case '\x02':
    pbVar4 = pbVar2 + 1;
    if (((pbVar2[1] & 0xc0) == 0x80) &&
       (uVar3 = (uVar5 & 0x1f) * 0x40 + (pbVar2[1] & 0x3f), 0x7f < uVar3)) goto LAB_080ad390;
    break;
  case '\x03':
    pbVar4 = pbVar2 + 1;
    if ((((pbVar2[1] & 0xc0) == 0x80) && ((pbVar2[2] & 0xc0) == 0x80)) &&
       ((uVar3 = (uVar5 & 0xf) * 0x1000 + (pbVar2[2] & 0x3f) + (pbVar2[1] & 0x3f) * 0x40,
        0x7ff < uVar3 && ((uVar3 & 0xfffff800) != 0xd800)))) goto LAB_080ad390;
    break;
  case '\x04':
    pbVar4 = pbVar2 + 1;
    if (((pbVar2[1] & 0xc0) == 0x80) &&
       ((((pbVar2[2] & 0xc0) == 0x80 && ((pbVar2[3] & 0xc0) == 0x80)) &&
        (uVar3 = (uVar5 & 0xf) * 0x40000 + (pbVar2[3] & 0x3f) + (pbVar2[1] & 0x3f) * 0x1000 +
                 (pbVar2[2] & 0x3f) * 0x40, 0xffff < uVar3)))) goto LAB_080ad390;
    break;
  case '\x05':
    pbVar4 = pbVar2 + 1;
    if ((((pbVar2[1] & 0xc0) == 0x80) && ((pbVar2[2] & 0xc0) == 0x80)) &&
       (((pbVar2[3] & 0xc0) == 0x80 &&
        (((pbVar2[4] & 0xc0) == 0x80 &&
         (uVar3 = (uVar5 & 0xf) * 0x1000000 + (pbVar2[4] & 0x3f) + (pbVar2[1] & 0x3f) * 0x40000 +
                  (pbVar2[2] & 0x3f) * 0x1000 + (pbVar2[3] & 0x3f) * 0x40, 0x1fffff < uVar3))))))
    goto LAB_080ad390;
    break;
  case '\x06':
    pbVar4 = pbVar2 + 1;
    if ((((((pbVar2[1] & 0xc0) == 0x80) && ((pbVar2[2] & 0xc0) == 0x80)) &&
         ((pbVar2[3] & 0xc0) == 0x80)) &&
        (((pbVar2[4] & 0xc0) == 0x80 && ((pbVar2[5] & 0xc0) == 0x80)))) &&
       (uVar3 = (uVar5 & 1) * 0x40000000 + (pbVar2[5] & 0x3f) + (pbVar2[1] & 0x3f) * 0x1000000 +
                (pbVar2[2] & 0x3f) * 0x40000 + (pbVar2[3] & 0x3f) * 0x1000 +
                (pbVar2[4] & 0x3f) * 0x40, 0x3ffffff < uVar3)) goto LAB_080ad390;
  }
  *string = pbVar4;
  return 0xfffd;
}



// WARNING: Unknown calling convention

unicode_val_T cp_to_unicode(int codepage,uchar **string,uchar *end)

{
  unicode_val_T uVar1;
  unicode_val_T ret;
  
  if (codepages[codepage & 0xffffff7f].aliases != aliases_utf8) {
    uVar1 = 0xfffffffd;
    if (*string < end) {
      uVar1 = cp2u(codepage,**string);
      *string = *string + 1;
    }
    return uVar1;
  }
  uVar1 = utf8_to_unicode(string,end);
  return uVar1;
}



// WARNING: Unknown calling convention

void free_translation_table(conv_table *p)

{
  conv_table *pcVar1;
  int iVar2;
  int i;
  
  iVar2 = 0;
  do {
    while (p[iVar2].t != 0) {
      pcVar1 = p + iVar2;
      iVar2 = iVar2 + 1;
      free_translation_table((pcVar1->u).tbl);
      if (iVar2 == 0x100) goto LAB_080ad616;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x100);
LAB_080ad616:
  mem_free(p);
  return;
}



// WARNING: Unknown calling convention

void new_translation_table(conv_table *p)

{
  conv_table *pcVar1;
  int iVar2;
  int i;
  
  iVar2 = 0;
  do {
    while (p[iVar2].t != 0) {
      pcVar1 = p + iVar2;
      iVar2 = iVar2 + 1;
      free_translation_table((pcVar1->u).tbl);
      if (iVar2 == 0x100) goto LAB_080ad666;
    }
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x100);
LAB_080ad666:
  iVar2 = 0;
  do {
    (&p->t)[iVar2] = 0;
    (&p->u)[iVar2].str = (uchar *)(strings + iVar2);
    iVar2 = iVar2 + 2;
  } while (iVar2 != 0x100);
  iVar2 = 0x80;
  do {
    p[iVar2].t = 0;
    p[iVar2].u.str = "*";
    iVar2 = iVar2 + 1;
  } while (iVar2 != 0x100);
  return;
}



// WARNING: Unknown calling convention

unicode_val_T unicode_fold_label_case(unicode_val_T c)

{
  wint_t wVar1;
  
  wVar1 = towlower(c);
  return wVar1;
}



// WARNING: Unknown calling convention

int utf8_ptr2chars(uchar *string,uchar *end)

{
  int iVar1;
  int chars;
  byte *pbVar2;
  
  if (((end != (uchar *)0x0) || (end = (uchar *)__rawmemchr(string,0), end != (byte *)0x0)) &&
     (string != (uchar *)0x0)) {
    iVar1 = 0;
    for (pbVar2 = string + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                           [*string]; pbVar2 <= end;
        pbVar2 = pbVar2 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                          [*pbVar2]) {
      iVar1 = iVar1 + 1;
    }
    return iVar1;
  }
  return -1;
}



// WARNING: Unknown calling convention

int strlen_utf8(uchar **str)

{
  byte *pbVar1;
  int iVar2;
  int x;
  uchar *end;
  uchar *s;
  byte *pbVar3;
  byte *pbVar4;
  
  pbVar4 = *str;
  pbVar1 = (byte *)__rawmemchr(pbVar4,0);
  iVar2 = 0;
  while ((pbVar3 = pbVar4, pbVar4 == (byte *)0x0 ||
         (pbVar3 = pbVar4 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                            [*pbVar4], pbVar3 <= pbVar1))) {
    iVar2 = iVar2 + 1;
    pbVar4 = pbVar3;
  }
  *str = pbVar4;
  return iVar2;
}



// WARNING: Unknown calling convention

void free_conv_table(void)

{
  int iVar1;
  int i;
  conv_table *pcVar2;
  byte bVar3;
  
  bVar3 = 0;
  if (utf_table_init == 0) {
    iVar1 = 0x80;
    do {
      pcVar2 = utf_table + iVar1;
      iVar1 = iVar1 + 1;
      mem_free((pcVar2->u).str);
    } while (iVar1 != 0x100);
  }
  if (first != 0) {
    pcVar2 = table_elinks;
    for (iVar1 = 0x200; iVar1 != 0; iVar1 = iVar1 + -1) {
      pcVar2->t = 0;
      pcVar2 = (conv_table *)&pcVar2[-(uint)bVar3].u;
    }
    first = 0;
  }
  new_translation_table(table_elinks);
  return;
}



// WARNING: Unknown calling convention

uchar * encode_utf8(unicode_val_T u)

{
  byte bVar1;
  uint uVar2;
  byte bVar3;
  
  utf_buffer[4] = '\0';
  utf_buffer[5] = '\0';
  utf_buffer[6] = '\0';
  bVar3 = (byte)u;
  if (u < 0x80) {
    utf_buffer._0_4_ = u & 0xff;
    return utf_buffer;
  }
  if (u < 0x800) {
    utf_buffer._0_4_ = (CONCAT11(bVar3,(char)(u >> 6)) & 0xff1f | 0xc0) & 0xffff3fff | 0x8000;
  }
  else {
    if (u < 0x10000) {
      uVar2 = (CONCAT12(bVar3,(short)(u >> 0xc)) & 0xff000f | 0xe0) & 0xff3fffff;
      utf_buffer[0] = (uchar)uVar2;
      utf_buffer._0_4_ =
           CONCAT22((short)(uVar2 >> 0x10),CONCAT11((char)(u >> 6),utf_buffer[0])) & 0xffff3fff |
           0x808000;
      return utf_buffer;
    }
    if (u < 0x200000) {
      utf_buffer._0_4_ =
           CONCAT13(bVar3,CONCAT12((char)(u >> 6),CONCAT11((char)(u >> 0xc),(char)(u >> 0x12)))) &
           0x3f3f3fff | 0x808080f0;
    }
    else {
      bVar1 = (byte)(u >> 0x18);
      if (u < 0x4000000) {
        utf_buffer._0_4_ =
             CONCAT13((char)(u >> 6),CONCAT12((char)(u >> 0xc),CONCAT11((char)(u >> 0x12),bVar1))) &
             0x3f3f3fff | 0x808080f8;
        utf_buffer._4_2_ = bVar3 & 0xff3f | 0x80;
      }
      else {
        utf_buffer._0_4_ =
             CONCAT13((char)(u >> 0xc),CONCAT12((char)(u >> 0x12),CONCAT11(bVar1,bVar1 >> 6))) &
             0x3f3f3f01 | 0x808080fc;
        utf_buffer._4_2_ = CONCAT11(bVar3,(char)(u >> 6)) & 0x3f3f | 0x8080;
      }
    }
  }
  return utf_buffer;
}



// WARNING: Unknown calling convention

uchar * u2cp_(unicode_val_T u,int to,nbsp_mode nbsp_mode)

{
  byte bVar1;
  ushort uVar2;
  uint uVar3;
  unicode_val_T strange;
  uchar *puVar4;
  int j;
  int iVar5;
  long _m;
  table_entry *ptVar6;
  int iVar7;
  long _e;
  int iVar8;
  
  strange = u;
  if (0x7f < u) {
    do {
      to = to & 0xffffff7f;
      if (codepages[to].aliases == aliases_utf8) {
        puVar4 = encode_utf8(strange);
        return puVar4;
      }
      if (strange == 0xa0) {
        if (nbsp_mode != NBSP_MODE_HACK) {
          return " ";
        }
        return "\x01";
      }
      if (strange == 0xad) {
        return "";
      }
      if (0x9f < strange) {
        if (strange < 0xffff) {
          iVar5 = 0;
          do {
            if (codepages[to].highhalf[iVar5] == strange) {
              return (uchar *)strings[iVar5 + 0x80];
            }
            iVar5 = iVar5 + 1;
          } while (iVar5 != 0x80);
        }
        ptVar6 = codepages[to].table_elinks;
        bVar1 = ptVar6->c;
        if (bVar1 != 0) {
          uVar2 = ptVar6->u;
          while( true ) {
            if (uVar2 == strange) {
              return (uchar *)strings[bVar1];
            }
            bVar1 = ptVar6[1].c;
            if (bVar1 == 0) break;
            uVar2 = ptVar6[1].u;
            ptVar6 = ptVar6 + 1;
          }
        }
        iVar8 = 0x993;
        iVar5 = 0;
        do {
          iVar7 = iVar5 + iVar8 >> 1;
          uVar3 = unicode_7b[iVar7].x;
          if (uVar3 == strange) {
            return unicode_7b[iVar7].s;
          }
          if (strange < uVar3) {
            iVar8 = iVar7 + -1;
          }
          if (uVar3 < strange) {
            iVar5 = iVar7 + 1;
          }
        } while (iVar5 <= iVar8);
        return "*";
      }
      strange = (&unicode_7b[0x978].x)[strange];
      if (strange == 0) {
        return (uchar *)0x0;
      }
      u = strange;
    } while (0x7f < strange);
  }
  return (uchar *)strings[u];
}



// WARNING: Unknown calling convention

uchar * get_entity_string(uchar *str,int strlen,int encoding)

{
  byte bVar1;
  uint uVar2;
  int i;
  int l;
  int iVar3;
  void *pvVar4;
  uint uVar5;
  ushort **ppuVar6;
  uint slen;
  size_t __n;
  int *piVar7;
  byte *pbVar8;
  uchar c;
  uchar *result;
  uchar *puVar9;
  unicode_val_T u;
  unicode_val_T n;
  uchar *st;
  entity_cache *ece;
  uchar *puVar10;
  uint *puVar11;
  bool bVar12;
  int local_38;
  string key;
  
  if (strlen < 1) {
    return (uchar *)0x0;
  }
  uVar2 = encoding & 0xffffff7f;
  if (codepages[uVar2].aliases == aliases_utf8) {
skip:
    local_38 = 0;
  }
  else {
    if (get_entity_string::first_time != 0) {
      puVar11 = get_entity_string::nb_entity_cache;
      for (iVar3 = 9; iVar3 != 0; iVar3 = iVar3 + -1) {
        *puVar11 = 0;
        puVar11 = puVar11 + 1;
      }
      get_entity_string::first_time = 0;
    }
    local_38 = strlen;
    if (6 < strlen - 2U) {
      if (8 < strlen) goto skip;
      local_38 = 0;
    }
    if (get_entity_string::nb_entity_cache[local_38] != 0) {
      uVar5 = 0;
      piVar7 = &get_entity_string::entity_cache[local_38][0].encoding;
      do {
        if (*piVar7 == uVar2) {
          bVar12 = true;
          iVar3 = strlen;
          puVar9 = str;
          puVar10 = get_entity_string::entity_cache[local_38][uVar5].str;
          do {
            if (iVar3 == 0) break;
            iVar3 = iVar3 + -1;
            bVar12 = *puVar9 == *puVar10;
            puVar9 = puVar9 + 1;
            puVar10 = puVar10 + 1;
          } while (bVar12);
          if (bVar12) {
            uVar2 = get_entity_string::entity_cache[local_38][uVar5].hits;
            if (uVar2 != 0xffffffff) {
              get_entity_string::entity_cache[local_38][uVar5].hits = uVar2 + 1;
            }
            return *(uchar **)(local_38 * 0x168 + 0x81494cc + uVar5 * 0x24);
          }
        }
        uVar5 = uVar5 + 1;
        piVar7 = piVar7 + 9;
      } while (uVar5 < get_entity_string::nb_entity_cache[local_38]);
    }
  }
  if (*str == '#') {
    puVar9 = (uchar *)0x0;
    __n = 1;
    if (strlen != 1) {
      st = str + 1;
      iVar3 = strlen + -1;
      bVar1 = str[1];
      if ((bVar1 | 0x20) == 0x78) {
        if ((iVar3 < 10) && (iVar3 != 1)) {
          iVar3 = strlen + -2;
          u = 0;
          pbVar8 = str + 2;
          do {
            bVar1 = *pbVar8;
            pbVar8 = pbVar8 + 1;
            uVar5 = bVar1 | 0x20;
            if ((byte)((char)uVar5 - 0x30U) < 10) {
              u = u << 4 | uVar5 - 0x30;
            }
            else {
              ppuVar6 = __ctype_b_loc();
              if ((*(byte *)((int)*ppuVar6 + uVar5 * 2 + 1) & 0x10) == 0) {
                puVar9 = (uchar *)0x0;
                goto LAB_080adc6a;
              }
              u = u << 4 | uVar5 - 0x57;
            }
            iVar3 = iVar3 + -1;
          } while (iVar3 != 0);
LAB_080adbec:
          puVar9 = u2cp_(u,uVar2,NBSP_MODE_HACK);
          goto LAB_080adc5e;
        }
      }
      else if (iVar3 < 0xb) {
        u = 0;
        while (((byte)(bVar1 - 0x30) < 10 && (u = (bVar1 - 0x30) + u * 10, u != 0xffffffff))) {
          iVar3 = iVar3 + -1;
          if (iVar3 == 0) goto LAB_080adbec;
          st = st + 1;
          bVar1 = *st;
        }
      }
      puVar9 = (uchar *)0x0;
      goto LAB_080adc6a;
    }
  }
  else {
    puVar9 = (uchar *)0x0;
    key.source = str;
    key.length = strlen;
    pvVar4 = bsearch(&key,entities,0x3e9,8,compare_entities);
    if (pvVar4 != (void *)0x0) {
      puVar9 = u2cp_(*(unicode_val_T *)((int)pvVar4 + 4),uVar2,NBSP_MODE_HACK);
    }
LAB_080adc5e:
    if (codepages[uVar2].aliases == aliases_utf8) {
      return puVar9;
    }
LAB_080adc6a:
    __n = strlen;
    if (0x13 < (uint)strlen) {
      return puVar9;
    }
  }
  uVar5 = get_entity_string::nb_entity_cache[local_38];
  if (1 < uVar5) {
    qsort(get_entity_string::entity_cache[local_38],uVar5,0x24,hits_cmp);
    uVar5 = get_entity_string::nb_entity_cache[local_38];
    if (9 < uVar5) goto LAB_080adc97;
  }
  uVar5 = uVar5 + 1;
  get_entity_string::nb_entity_cache[local_38] = uVar5;
LAB_080adc97:
  get_entity_string::entity_cache[local_38 + -1][uVar5 + 9].hits = 1;
  get_entity_string::entity_cache[local_38 + -1][uVar5 + 9].strlen = strlen;
  get_entity_string::entity_cache[local_38 + -1][uVar5 + 9].result = puVar9;
  get_entity_string::entity_cache[local_38 + -1][uVar5 + 9].encoding = uVar2;
  memcpy(get_entity_string::entity_cache[local_38 + -1][uVar5 + 9].str,str,__n);
  *(undefined *)(local_38 * 0x168 + uVar5 * 0x24 + 0x81494ac + strlen) = 0;
  return puVar9;
}



// WARNING: Unknown calling convention

uchar * convert_string_elinks
                  (conv_table *convert_table,uchar *chars,int charslen,int cp,
                  convert_string_mode mode,int *length,_func_void_void_ptr_uchar_ptr_int *callback,
                  void *callback_data)

{
  byte bVar1;
  byte bVar2;
  uchar uVar3;
  void *pvVar4;
  byte *pbVar5;
  int i_1;
  uchar *puVar6;
  uchar *puVar7;
  byte *pbVar8;
  int bufferpos;
  int iVar9;
  int iVar10;
  uchar *translit;
  conv_table *t;
  conv_table *pcVar11;
  uchar *local_24;
  int local_20;
  
  if ((convert_table == (conv_table *)0x0) &&
     (pvVar4 = memchr(chars,0x26,charslen), pvVar4 == (void *)0x0)) {
    if (callback == (_func_void_void_ptr_uchar_ptr_int *)0x0) {
      puVar6 = memacpy(chars,charslen);
      return puVar6;
    }
    local_24 = (uchar *)0x0;
    if (charslen != 0) {
      (*callback)(callback_data,chars,charslen);
      local_24 = (uchar *)0x0;
    }
  }
  else {
    local_24 = (uchar *)mem_alloc(0x101);
    if (local_24 != (uchar *)0x0) {
      iVar9 = 0;
      local_20 = 0;
      if (0 < charslen) {
        do {
          pbVar5 = chars + local_20;
          bVar1 = *pbVar5;
          if (bVar1 == 0x26) {
            if (mode + ~CSM_QUERY < 2) {
              local_24[iVar9] = '&';
              local_20 = local_20 + 1;
              goto flush;
            }
            local_20 = local_20 + 1;
            iVar10 = local_20;
            for (pbVar8 = pbVar5;
                (iVar10 < charslen &&
                ((((bVar1 = pbVar8[1], (byte)(bVar1 + 0x9f) < 0x1a || ((byte)(bVar1 + 0xbf) < 0x1a))
                  || ((byte)(bVar1 - 0x30) < 10)) || (bVar1 == 0x23)))); pbVar8 = pbVar8 + 1) {
              iVar10 = iVar10 + 1;
            }
            if (((mode == CSM_DEFAULT) || ((chars[iVar10] != '=' && (chars[iVar10] != '&')))) &&
               (local_20 < iVar10)) {
              uVar3 = chars[iVar10];
              if (((0x19 < (byte)(uVar3 + 0x9f)) && (0x19 < (byte)(uVar3 + 0xbf))) &&
                 (9 < (byte)(uVar3 - 0x30))) {
                puVar6 = get_entity_string(chars + local_20,iVar10 - local_20,cp);
                iVar10 = iVar10 - (uint)(chars[iVar10] != ';');
                if (puVar6 == (uchar *)0x0) {
                  local_24[iVar9] = *pbVar5;
                  goto flush;
                }
                local_20 = (uint)(iVar10 < charslen) + iVar10;
                goto LAB_080ae179;
              }
            }
            local_24[iVar9] = '&';
flush:
            iVar10 = iVar9 + 1;
            puVar6 = "";
            puVar7 = local_24;
            if ((char)iVar10 != '\0') goto LAB_080adfa9;
            do {
              if (callback == (_func_void_void_ptr_uchar_ptr_int *)0x0) {
                puVar7 = (uchar *)mem_realloc(local_24,iVar10 + 0x100);
                if (puVar7 == (uchar *)0x0) {
                  mem_free(local_24);
                  return (uchar *)0x0;
                }
              }
              else {
                local_24[iVar10] = '\0';
                (*callback)(callback_data,local_24,iVar10);
                iVar10 = 0;
                puVar7 = local_24;
              }
LAB_080adfa9:
              local_24 = puVar7;
              uVar3 = *puVar6;
              iVar9 = iVar10;
              while( true ) {
                if (uVar3 == '\0') goto LAB_080adfc9;
LAB_080adfb3:
                puVar6 = puVar6 + 1;
                iVar10 = iVar9 + 1;
                local_24[iVar9] = uVar3;
                if ((char)iVar10 == '\0') break;
                uVar3 = *puVar6;
                iVar9 = iVar10;
              }
            } while( true );
          }
          if ((-1 < (char)bVar1) ||
             (iVar10 = local_20, pcVar11 = convert_table, bVar2 = bVar1,
             convert_table == (conv_table *)0x0)) {
LAB_080adf66:
            local_24[iVar9] = bVar1;
            local_20 = local_20 + 1;
            goto flush;
          }
          while (pcVar11 = pcVar11 + bVar2, pcVar11->t != 0) {
            pbVar5 = pbVar5 + 1;
            if (charslen <= iVar10 + 1) goto LAB_080adf66;
            iVar10 = iVar10 + 1;
            pcVar11 = (conv_table *)(pcVar11->u).str;
            bVar2 = *pbVar5;
          }
          local_20 = iVar10 + 1;
          puVar6 = (pcVar11->u).str;
LAB_080ae179:
          uVar3 = *puVar6;
          if (uVar3 != '\0') {
            if (puVar6[1] != '\0') goto LAB_080adfb3;
            local_24[iVar9] = uVar3;
            goto flush;
          }
LAB_080adfc9:
        } while (local_20 < charslen);
      }
      local_24[iVar9] = '\0';
      if (length != (int *)0x0) {
        *length = iVar9;
      }
      if (callback != (_func_void_void_ptr_uchar_ptr_int *)0x0) {
        if (iVar9 != 0) {
          (*callback)(callback_data,local_24,iVar9);
        }
        mem_free(local_24);
        local_24 = (uchar *)0x0;
      }
    }
  }
  return local_24;
}



void __regparm3 add_utf8(conv_table *ct,unicode_val_T u,uchar *str)

{
  byte bVar1;
  byte bVar2;
  uchar *p;
  byte *pbVar3;
  conv_table *pcVar4;
  conv_table *pcVar5;
  bool bVar6;
  
  utf_buffer[4] = '\0';
  utf_buffer[5] = '\0';
  utf_buffer[6] = '\0';
  bVar2 = (byte)ct;
  if (ct < (conv_table *)0x80) {
    utf_buffer._0_4_ = (uint)ct & 0xff;
  }
  else if (ct < (conv_table *)0x800) {
    utf_buffer._0_4_ = (CONCAT11(bVar2,(char)((uint)ct >> 6)) & 0xff1f | 0xc0) & 0xffff3fff | 0x8000
    ;
  }
  else if (ct < (conv_table *)0x10000) {
    utf_buffer._0_4_ =
         (CONCAT12(bVar2,CONCAT11((char)((uint)ct >> 6),(char)((uint)ct >> 0xc))) & 0xff3f0f |
         0x80e0) & 0xff3fffff | 0x800000;
  }
  else if (ct < (conv_table *)0x200000) {
    utf_buffer._0_4_ =
         CONCAT13(bVar2,CONCAT12((char)((uint)ct >> 6),
                                 CONCAT11((char)((uint)ct >> 0xc),(char)((uint)ct >> 0x12)))) &
         0x3f3f3fff | 0x808080f0;
  }
  else {
    bVar1 = (byte)((uint)ct >> 0x18);
    if (ct < (conv_table *)0x4000000) {
      utf_buffer._0_4_ =
           CONCAT13((char)((uint)ct >> 6),
                    CONCAT12((char)((uint)ct >> 0xc),CONCAT11((char)((uint)ct >> 0x12),bVar1))) &
           0x3f3f3fff | 0x808080f8;
      utf_buffer._4_2_ = bVar2 & 0xff3f | 0x80;
    }
    else {
      utf_buffer._0_4_ =
           CONCAT13((char)((uint)ct >> 0xc),
                    CONCAT12((char)((uint)ct >> 0x12),CONCAT11(bVar1,bVar1 >> 6))) & 0x3f3f3f01 |
           0x808080fc;
      utf_buffer._4_2_ = CONCAT11(bVar2,(char)((uint)ct >> 6)) & 0x3f3f | 0x8080;
    }
  }
  pbVar3 = utf_buffer;
  pcVar5 = table_elinks;
  while (pbVar3[1] != 0) {
    pcVar4 = pcVar5 + *pbVar3;
    if (pcVar4->t == 0) {
      if (assert_failed != 0) goto LAB_080ae3c9;
      bVar6 = (pcVar4->u).str != "*";
      assert_failed = (int)bVar6;
      if (bVar6) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 0x316;
        elinks_internal((uchar *)"assertion ct[*p].u.str == no_str failed: bad utf encoding #1");
        if (assert_failed != 0) goto LAB_080ae3c9;
      }
      pcVar4 = (conv_table *)mem_calloc(0x100,8);
      if (pcVar4 == (conv_table *)0x0) {
        return;
      }
      new_translation_table(pcVar4);
      pcVar5[*pbVar3].t = 1;
      pcVar5[*pbVar3].u.tbl = pcVar4;
      pbVar3 = pbVar3 + 1;
      pcVar5 = pcVar4;
    }
    else {
      pcVar5 = (pcVar4->u).tbl;
      pbVar3 = pbVar3 + 1;
    }
  }
  if (assert_failed == 0) {
    bVar6 = pcVar5[*pbVar3].t != 0;
    assert_failed = (int)bVar6;
    if (bVar6) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x323;
      elinks_internal((uchar *)"assertion !ct[*p].t failed: bad utf encoding #2");
      if (assert_failed != 0) goto LAB_080ae3c9;
    }
    if (pcVar5[*pbVar3].u.str == "*") {
      pcVar5[*pbVar3].u = (anon_union_4_2_43af338e_for_u)u;
    }
  }
  else {
LAB_080ae3c9:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * cp2utf8(int from,int c)

{
  ushort uVar1;
  byte bVar2;
  unicode_val_T u;
  
  if ((c < 0x80) || (codepages[from & 0xffffff7fU].aliases == aliases_utf8)) {
    return (uchar *)strings[c];
  }
  uVar1 = codepages[from & 0xffffff7fU].highhalf[(c & 0xffU) - 0x80];
  if (uVar1 == 0xffff) {
    utf_buffer[2] = 0xbd;
    utf_buffer[1] = 0xbf;
    utf_buffer[0] = 0xef;
  }
  else {
    utf_buffer[4] = '\0';
    utf_buffer[5] = '\0';
    utf_buffer[6] = '\0';
    bVar2 = (byte)uVar1;
    if (uVar1 < 0x80) {
      utf_buffer[1] = '\0';
      utf_buffer[2] = '\0';
      utf_buffer[3] = '\0';
      utf_buffer[0] = bVar2;
      return utf_buffer;
    }
    if (uVar1 < 0x800) {
      utf_buffer._0_4_ = CONCAT11(bVar2,(char)(uVar1 >> 6)) & 0xffff3f1f | 0x80c0;
      return utf_buffer;
    }
    utf_buffer[0] = (byte)(uVar1 >> 0xc) | 0xe0;
    utf_buffer[1] = (byte)(uVar1 >> 6) & 0x3f | 0x80;
    utf_buffer[2] = bVar2 & 0x3f | 0x80;
  }
  utf_buffer[6] = '\0';
  utf_buffer[4] = '\0';
  utf_buffer[5] = '\0';
  utf_buffer[3] = '\0';
  return utf_buffer;
}



// WARNING: Unknown calling convention

uchar * utf8_step_backward(uchar *string,uchar *start,int max,utf8_step way,int *count)

{
  int iVar1;
  uchar *current;
  byte bVar2;
  unicode_val_T u;
  int steps;
  byte *pbVar3;
  byte *pbVar4;
  int iVar5;
  int width;
  unicode_val_T u_1;
  uint uVar6;
  byte *local_40;
  int local_20;
  
  if (assert_failed == 0) {
    assert_failed = (int)(string == (uchar *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1fe;
      elinks_internal((uchar *)"assertion string failed!");
      if (assert_failed != 0) goto LAB_080ae700;
    }
    assert_failed = (int)(start == (uchar *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1ff;
      elinks_internal((uchar *)"assertion start failed!");
      if (assert_failed != 0) goto LAB_080ae700;
    }
    assert_failed = -(max >> 0x1f);
    if (assert_failed != 0) {
      assert_failed = -(max >> 0x1f);
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x200;
      elinks_internal((uchar *)"assertion max >= 0 failed!");
      if (assert_failed != 0) goto LAB_080ae700;
    }
    local_20 = 0;
    if (way == UTF8_STEP_CHARACTERS) {
      local_20 = 0;
      while (start < string) {
        while( true ) {
          if (max <= local_20) goto LAB_080ae713;
          string = string + -1;
          if (((char)*string < '\0') && ((*string & 0xc0) != 0xc0)) break;
          local_20 = local_20 + 1;
          if (string <= start) goto LAB_080ae713;
        }
      }
    }
    else if (way < (UTF8_STEP_CELLS_FEWER|UTF8_STEP_CELLS_MORE)) {
      if ((0 < max) && (start < string)) {
        local_40 = string;
        do {
          pbVar3 = string;
          string = pbVar3 + -1;
          if (string <= start) goto LAB_080ae8f8;
LAB_080ae766:
          bVar2 = pbVar3[-1];
          uVar6 = (uint)bVar2;
          pbVar4 = pbVar3;
        } while (((char)bVar2 < '\0') && (uVar6 = (uint)bVar2, (uVar6 & 0xc0) != 0xc0));
        do {
          pbVar3 = string;
          if (local_40 <
              pbVar3 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                       [uVar6]) {
LAB_080ae858:
            iVar5 = 1;
            if (way == UTF8_STEP_CELLS_FEWER) goto LAB_080ae863;
LAB_080ae8d3:
            iVar1 = local_20 + iVar5;
          }
          else {
            switch("\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                   [uVar6]) {
            default:
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
              errline = 0x2cf;
              elinks_internal((uchar *)"utf8char_len_tab out of range");
              uVar6 = 0xfffd;
              goto LAB_080ae7d0;
            case '\x01':
              if ((char)bVar2 < '\0') break;
              uVar6 = (uint)bVar2;
LAB_080aeacb:
              if (uVar6 < 0x1100) goto LAB_080ae858;
              if (((uVar6 != 0x2329) && (0x115f < uVar6)) && (uVar6 != 0x232a)) goto LAB_080ae7d0;
              goto LAB_080ae8c8;
            case '\x02':
              if (((*pbVar4 & 0xc0) == 0x80) &&
                 (uVar6 = (*pbVar4 & 0x3f) + (uVar6 & 0x1f) * 0x40, 0x7f < uVar6)) {
LAB_080ae9a8:
                if (uVar6 != 0xfffffffd) goto LAB_080aeacb;
                goto LAB_080ae858;
              }
              break;
            case '\x03':
              if ((((*pbVar4 & 0xc0) == 0x80) && ((pbVar3[2] & 0xc0) == 0x80)) &&
                 ((uVar6 = (pbVar3[2] & 0x3f) + (uVar6 & 0xf) * 0x1000 + (*pbVar4 & 0x3f) * 0x40,
                  0x7ff < uVar6 && ((uVar6 & 0xfffff800) != 0xd800)))) goto LAB_080ae9a8;
              break;
            case '\x04':
              if (((*pbVar4 & 0xc0) == 0x80) &&
                 ((((pbVar3[2] & 0xc0) == 0x80 && ((pbVar3[3] & 0xc0) == 0x80)) &&
                  (uVar6 = (pbVar3[3] & 0x3f) + (uVar6 & 0xf) * 0x40000 + (*pbVar4 & 0x3f) * 0x1000
                           + (pbVar3[2] & 0x3f) * 0x40, 0xffff < uVar6)))) goto LAB_080ae9a8;
              break;
            case '\x05':
              if ((((*pbVar4 & 0xc0) == 0x80) && ((pbVar3[2] & 0xc0) == 0x80)) &&
                 (((pbVar3[3] & 0xc0) == 0x80 &&
                  (((pbVar3[4] & 0xc0) == 0x80 &&
                   (uVar6 = (pbVar3[4] & 0x3f) + (uVar6 & 0xf) * 0x1000000 +
                            (*pbVar4 & 0x3f) * 0x40000 + (pbVar3[2] & 0x3f) * 0x1000 +
                            (pbVar3[3] & 0x3f) * 0x40, 0x1fffff < uVar6)))))) goto LAB_080ae9a8;
              break;
            case '\x06':
              if ((((((*pbVar4 & 0xc0) == 0x80) && ((pbVar3[2] & 0xc0) == 0x80)) &&
                   ((pbVar3[3] & 0xc0) == 0x80)) &&
                  (((pbVar3[4] & 0xc0) == 0x80 && ((pbVar3[5] & 0xc0) == 0x80)))) &&
                 (uVar6 = (pbVar3[5] & 0x3f) + (uVar6 & 1) * 0x40000000 +
                          (*pbVar4 & 0x3f) * 0x1000000 + (pbVar3[2] & 0x3f) * 0x40000 +
                          (pbVar3[3] & 0x3f) * 0x1000 + (pbVar3[4] & 0x3f) * 0x40, 0x3ffffff < uVar6
                 )) goto LAB_080ae9a8;
            }
            uVar6 = 0xfffd;
LAB_080ae7d0:
            if (((((0x764f < uVar6 - 0x2e80) || (uVar6 == 0x303f)) &&
                 ((0x2ba3 < uVar6 - 0xac00 && ((0x1ff < uVar6 - 0xf900 && (0x3f < uVar6 - 0xfe30))))
                 )) && (0x60 < uVar6 - 0xff00)) &&
               (((6 < uVar6 - 0xffe0 && (0xfffd < uVar6 - 0x20000)) && (0xfffd < uVar6 - 0x30000))))
            goto LAB_080ae858;
LAB_080ae8c8:
            iVar5 = 2;
            if (way != UTF8_STEP_CELLS_FEWER) goto LAB_080ae8d3;
LAB_080ae863:
            string = local_40;
            iVar1 = iVar5 + local_20;
            if (max < iVar5 + local_20) goto LAB_080ae713;
          }
          local_20 = iVar1;
          string = pbVar3;
          if ((max <= local_20) || (pbVar3 <= start)) goto LAB_080ae713;
          string = pbVar3 + -1;
          local_40 = pbVar3;
          if (start < string) goto LAB_080ae766;
LAB_080ae8f8:
          bVar2 = pbVar3[-1];
          uVar6 = (uint)bVar2;
          pbVar4 = pbVar3;
        } while( true );
      }
      local_20 = 0;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x22e;
      elinks_internal((uchar *)"impossible enum utf8_step");
    }
  }
  else {
LAB_080ae700:
    assert_failed = 0;
    local_20 = 0;
  }
LAB_080ae713:
  if (count != (int *)0x0) {
    *count = local_20;
  }
  return string;
}



// WARNING: Removing unreachable block (ram,0x080af268)
// WARNING: Removing unreachable block (ram,0x080af274)
// WARNING: Removing unreachable block (ram,0x080aef63)
// WARNING: Removing unreachable block (ram,0x080aef68)
// WARNING: Unknown calling convention

uchar * utf8_step_forward(uchar *string,uchar *end,int max,utf8_step way,int *count)

{
  byte bVar1;
  int iVar2;
  int width;
  byte *pbVar3;
  uchar *puVar4;
  unicode_val_T u;
  int iVar5;
  int steps;
  uchar *current;
  unicode_val_T u_1;
  
  if (assert_failed == 0) {
    assert_failed = (int)(string == (uchar *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1ba;
      elinks_internal((uchar *)"assertion string failed!");
      if (assert_failed != 0) goto LAB_080aed38;
    }
    assert_failed = -(max >> 0x1f);
    if (assert_failed != 0) {
      assert_failed = -(max >> 0x1f);
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1bb;
      elinks_internal((uchar *)"assertion max >= 0 failed!");
      if (assert_failed != 0) goto LAB_080aed38;
    }
    if (end == (uchar *)0x0) {
      end = (uchar *)__rawmemchr(string,0);
    }
    iVar5 = 0;
    if (way == UTF8_STEP_CHARACTERS) {
      while (string < end) {
        while( true ) {
          if (max <= iVar5) goto invalid_arg;
          string = string + 1;
          if (((char)*string < '\0') && ((*string & 0xc0) != 0xc0)) break;
          iVar5 = iVar5 + 1;
          if (end <= string) goto invalid_arg;
        }
      }
    }
    else if (way < (UTF8_STEP_CELLS_FEWER|UTF8_STEP_CELLS_MORE)) {
      if ((string < end) && (0 < max)) {
        bVar1 = "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                [*string];
        iVar2 = iVar5;
        if (end < string + (char)bVar1) {
          iVar5 = 1;
          string = end;
        }
        else {
          do {
            iVar5 = iVar2;
            if (bVar1 < 7) {
                    // WARNING: Could not recover jumptable at 0x080aee98. Too many branches
                    // WARNING: Treating indirect jump as call
              puVar4 = (uchar *)(**(code **)(&DAT_081026b8 + (uint)bVar1 * 4))();
              return puVar4;
            }
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
            errline = 0x2cf;
            elinks_internal((uchar *)"utf8char_len_tab out of range");
            pbVar3 = string + 1;
            if (way == UTF8_STEP_CELLS_FEWER) {
              if (iVar5 + 1 <= max) {
                if (iVar5 + 1 < max) goto LAB_080aee62;
LAB_080aef88:
                iVar5 = iVar5 + 1;
                string = pbVar3;
              }
              goto invalid_arg;
            }
            if (max <= iVar5 + 1) goto LAB_080aef88;
LAB_080aee62:
            if (end <= pbVar3) goto LAB_080aef88;
            bVar1 = "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                    [*pbVar3];
            iVar2 = iVar5 + 1;
            string = pbVar3;
          } while (pbVar3 + (char)bVar1 <= end);
          iVar5 = iVar5 + 2;
          string = end;
        }
      }
      else {
        iVar5 = 0;
      }
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 0x1e5;
      elinks_internal((uchar *)"impossible enum utf8_step");
    }
  }
  else {
LAB_080aed38:
    assert_failed = 0;
    iVar5 = 0;
  }
invalid_arg:
  if (count != (int *)0x0) {
    *count = iVar5;
  }
  return string;
}



// WARNING: Unknown calling convention

conv_table * get_translation_table(int from,int to)

{
  byte bVar1;
  ushort uVar2;
  uint16_t *puVar3;
  undefined uVar4;
  uchar *u;
  uchar *puVar5;
  conv_table *pcVar6;
  unicode_val_T u_2;
  uchar *str;
  uchar *str_00;
  uchar *extraout_ECX;
  uchar *extraout_ECX_00;
  table_entry *ptVar7;
  table_entry *extraout_ECX_01;
  unicode_val_T u_1;
  uint uVar8;
  int i;
  int i_2;
  int i_3;
  uint uVar9;
  int iVar10;
  int i_1;
  byte bVar11;
  
  bVar11 = 0;
  uVar9 = from & 0xffffff7f;
  uVar8 = to & 0xffffff7f;
  if (first != 0) {
    pcVar6 = table_elinks;
    for (iVar10 = 0x200; iVar10 != 0; iVar10 = iVar10 + -1) {
      pcVar6->t = 0;
      pcVar6 = (conv_table *)&pcVar6->u;
    }
    first = 0;
  }
  if (codepages[uVar8].aliases == aliases_utf8) {
    if (uVar9 != get_translation_table_to_utf8::lfr_1) {
      iVar10 = 0x80;
      get_translation_table_to_utf8::lfr_1 = uVar9;
      if (utf_table_init == 0) {
        do {
          pcVar6 = utf_table + iVar10;
          iVar10 = iVar10 + 1;
          mem_free((pcVar6->u).str);
        } while (iVar10 != 0x100);
      }
      else {
        pcVar6 = utf_table;
        for (iVar10 = 0x200; iVar10 != 0; iVar10 = iVar10 + -1) {
          pcVar6->t = 0;
          pcVar6 = (conv_table *)&pcVar6->u;
        }
        utf_table_init = 0;
      }
      iVar10 = 0;
      do {
        (&utf_table[0].u)[iVar10].str = (uchar *)(strings + iVar10);
        iVar10 = iVar10 + 2;
      } while (iVar10 != 0x100);
      if (codepages[uVar9].aliases == aliases_utf8) {
        iVar10 = 0;
        do {
          puVar5 = stracpy((uchar *)(strings[0x80] + iVar10));
          (&utf_table[0x80].u)[iVar10].str = puVar5;
          iVar10 = iVar10 + 2;
        } while (iVar10 != 0x100);
      }
      else {
        puVar3 = codepages[uVar9].highhalf;
        iVar10 = 0x80;
        do {
          uVar2 = puVar3[iVar10 + -0x80];
          if (uVar2 == 0xffff) {
            utf_table[iVar10].u.str = (uchar *)0x0;
          }
          else {
            utf_buffer[4] = '\0';
            utf_buffer[5] = '\0';
            utf_buffer[6] = '\0';
            utf_buffer[0] = (uchar)uVar2;
            if (uVar2 < 0x80) {
              utf_buffer[1] = '\0';
              utf_buffer[2] = '\0';
              utf_buffer[3] = '\0';
            }
            else if (uVar2 < 0x800) {
              utf_buffer._0_4_ =
                   (CONCAT11(utf_buffer[0],(char)(uVar2 >> 6)) & 0xff1f | 0xc0) & 0xffff3fff |
                   0x8000;
            }
            else {
              utf_buffer._0_4_ =
                   (CONCAT12(utf_buffer[0],CONCAT11((char)(uVar2 >> 6),(byte)(uVar2 >> 0xc))) &
                    0xff3fff | 0x80e0) & 0xff3fffff | 0x800000;
            }
            puVar5 = stracpy(utf_buffer);
            utf_table[iVar10].u.str = puVar5;
          }
          iVar10 = iVar10 + 1;
        } while (iVar10 != 0x100);
        bVar1 = (codepages[uVar9].table_elinks)->c;
        ptVar7 = codepages[uVar9].table_elinks;
        while (bVar1 != 0) {
          uVar2 = ptVar7->u;
          if (utf_table[bVar1].u.str == (uchar *)0x0) {
            puVar5 = utf_buffer;
            for (iVar10 = 7; iVar10 != 0; iVar10 = iVar10 + -1) {
              *puVar5 = '\0';
              puVar5 = puVar5 + (uint)bVar11 * -2 + 1;
            }
            uVar4 = (undefined)uVar2;
            if (uVar2 < 0x80) {
              utf_buffer[0] = uVar4;
            }
            else if (uVar2 < 0x800) {
              uVar8 = CONCAT31(utf_buffer._1_3_,(char)(uVar2 >> 6)) & 0xffffff1f;
              utf_buffer._2_2_ = (undefined2)(uVar8 >> 0x10);
              utf_buffer._0_4_ =
                   CONCAT22(utf_buffer._2_2_,CONCAT11(uVar4,(char)uVar8)) & 0xffff3fff | 0x80c0;
            }
            else {
              uVar8 = CONCAT22(utf_buffer._2_2_,CONCAT11((char)(uVar2 >> 6),(byte)(uVar2 >> 0xc))) &
                      0xffff3fff;
              utf_buffer[3] = (uchar)(uVar8 >> 0x18);
              utf_buffer._0_4_ =
                   CONCAT13(utf_buffer[3],CONCAT12(uVar4,(short)uVar8)) & 0xff3fffff | 0x8080e0;
            }
            puVar5 = stracpy(utf_buffer);
            utf_table[bVar1].u.str = puVar5;
          }
          bVar1 = ptVar7[1].c;
          ptVar7 = ptVar7 + 1;
        }
        iVar10 = 0x80;
        do {
          if (utf_table[iVar10].u.str == (uchar *)0x0) {
            puVar5 = stracpy("*");
            utf_table[iVar10].u.str = puVar5;
          }
          iVar10 = iVar10 + 1;
        } while (iVar10 != 0x100);
      }
    }
    pcVar6 = utf_table;
  }
  else if ((uVar9 != get_translation_table::lfr) ||
          (pcVar6 = table_elinks, uVar8 != get_translation_table::lto)) {
    get_translation_table::lto = uVar8;
    get_translation_table::lfr = uVar9;
    new_translation_table(table_elinks);
    if (codepages[uVar9].aliases == aliases_utf8) {
      add_utf8((conv_table *)0xa0,0x8107122,str);
      add_utf8((conv_table *)0xad,(unicode_val_T)&DAT_0812e3d8,str_00);
      puVar3 = codepages[uVar8].highhalf;
      iVar10 = 0;
      puVar5 = extraout_ECX;
      do {
        uVar2 = *(ushort *)((int)puVar3 + iVar10);
        if (uVar2 != 0xffff) {
          add_utf8((conv_table *)(uint)uVar2,iVar10 + 0x8107220,puVar5);
          puVar5 = extraout_ECX_00;
        }
        iVar10 = iVar10 + 2;
      } while (iVar10 != 0x100);
      bVar11 = (codepages[uVar8].table_elinks)->c;
      ptVar7 = codepages[uVar8].table_elinks;
      while (bVar11 != 0) {
        add_utf8((conv_table *)(uint)ptVar7->u,(unicode_val_T)strings[bVar11],&ptVar7->c);
        bVar11 = ptVar7[1].c;
        ptVar7 = ptVar7 + 1;
      }
      iVar10 = 0;
      while( true ) {
        iVar10 = iVar10 + 1;
        pcVar6 = (conv_table *)unicode_7b[iVar10].x;
        if (pcVar6 == (conv_table *)0xffffffff) break;
        if ((conv_table *)0x7f < pcVar6) {
          add_utf8(pcVar6,(unicode_val_T)unicode_7b[iVar10].s,&ptVar7->c);
          ptVar7 = extraout_ECX_01;
        }
      }
    }
    else {
      puVar3 = codepages[uVar9].highhalf;
      iVar10 = 0x80;
      do {
        if ((puVar3[iVar10 + -0x80] != 0xffff) &&
           (puVar5 = u2cp_((uint)puVar3[iVar10 + -0x80],uVar8,NBSP_MODE_HACK),
           puVar5 != (uchar *)0x0)) {
          table_elinks[iVar10].u.str = puVar5;
        }
        iVar10 = iVar10 + 1;
      } while (iVar10 != 0x100);
    }
    pcVar6 = table_elinks;
  }
  return pcVar6;
}



// WARNING: Unknown calling convention

int utf8_char2cells(uchar *utf8_char,uchar *end)

{
  int iVar1;
  unicode_val_T u_1;
  unicode_val_T u;
  uint uVar2;
  uint uVar3;
  
  if (((end == (uchar *)0x0) && (end = (uchar *)__rawmemchr(utf8_char,0), end == (uchar *)0x0)) ||
     (utf8_char == (uchar *)0x0)) {
    return -1;
  }
  uVar3 = (uint)*utf8_char;
  uVar2 = 0xfffffffd;
  if (end < utf8_char +
            "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
            [uVar3]) goto LAB_080af7a8;
  switch("\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
         [uVar3]) {
  default:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x2cf;
    elinks_internal((uchar *)"utf8char_len_tab out of range");
    uVar2 = 0xfffd;
    goto LAB_080af7a8;
  case '\x01':
    if ((char)*utf8_char < '\0') break;
    goto LAB_080af82b;
  case '\x02':
    if (((utf8_char[1] & 0xc0) != 0x80) ||
       (uVar2 = (uVar3 & 0x1f) * 0x40 + (utf8_char[1] & 0x3f), uVar2 < 0x80)) break;
LAB_080af8a1:
    if (uVar2 < 0x1100) goto LAB_080af82b;
    if ((0x115f < uVar2) && (uVar2 != 0x2329)) goto LAB_080af9c2;
    goto LAB_080af8c8;
  case '\x03':
    if (((((utf8_char[1] & 0xc0) == 0x80) && ((utf8_char[2] & 0xc0) == 0x80)) &&
        (uVar2 = (uVar3 & 0xf) * 0x1000 + (utf8_char[2] & 0x3f) + (utf8_char[1] & 0x3f) * 0x40,
        0x7ff < uVar2)) && ((uVar2 & 0xfffff800) != 0xd800)) goto LAB_080af8a1;
    break;
  case '\x04':
    if ((((utf8_char[1] & 0xc0) != 0x80) ||
        (((utf8_char[2] & 0xc0) != 0x80 || ((utf8_char[3] & 0xc0) != 0x80)))) ||
       (uVar2 = (uVar3 & 0xf) * 0x40000 + (utf8_char[3] & 0x3f) + (utf8_char[1] & 0x3f) * 0x1000 +
                (utf8_char[2] & 0x3f) * 0x40, uVar2 < 0x10000)) break;
LAB_080af9c2:
    if (uVar2 == 0x232a) goto LAB_080af8c8;
    goto LAB_080af7a8;
  case '\x05':
    if (((((utf8_char[1] & 0xc0) == 0x80) && ((utf8_char[2] & 0xc0) == 0x80)) &&
        ((utf8_char[3] & 0xc0) == 0x80)) &&
       (((utf8_char[4] & 0xc0) == 0x80 &&
        (uVar2 = (uVar3 & 0xf) * 0x1000000 + (utf8_char[4] & 0x3f) + (utf8_char[1] & 0x3f) * 0x40000
                 + (utf8_char[2] & 0x3f) * 0x1000 + (utf8_char[3] & 0x3f) * 0x40, 0x1fffff < uVar2))
       )) goto LAB_080af9c2;
    break;
  case '\x06':
    if (((((utf8_char[1] & 0xc0) == 0x80) && ((utf8_char[2] & 0xc0) == 0x80)) &&
        (((utf8_char[3] & 0xc0) == 0x80 &&
         (((utf8_char[4] & 0xc0) == 0x80 && ((utf8_char[5] & 0xc0) == 0x80)))))) &&
       (uVar2 = (uVar3 & 1) * 0x40000000 + (utf8_char[5] & 0x3f) + (utf8_char[1] & 0x3f) * 0x1000000
                + (utf8_char[2] & 0x3f) * 0x40000 + (utf8_char[3] & 0x3f) * 0x1000 +
                (utf8_char[4] & 0x3f) * 0x40, 0x3ffffff < uVar2)) goto LAB_080af9c2;
  }
  uVar2 = 0xfffd;
LAB_080af7a8:
  if (((((uVar2 - 0x2e80 < 0x7650) && (uVar2 != 0x303f)) || (uVar2 - 0xac00 < 0x2ba4)) ||
      (((uVar2 - 0xf900 < 0x200 || (uVar2 - 0xfe30 < 0x40)) ||
       ((uVar2 - 0xff00 < 0x61 || ((uVar2 - 0xffe0 < 7 || (uVar2 - 0x20000 < 0xfffe)))))))) ||
     (uVar2 - 0x30000 < 0xfffe)) {
LAB_080af8c8:
    iVar1 = 2;
  }
  else {
LAB_080af82b:
    iVar1 = 1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int utf8_cells2bytes(uchar *string,int max_cells,uchar *end)

{
  int cell;
  int iVar1;
  uint bytes;
  int iVar2;
  uint cells;
  uint uVar3;
  byte *utf8_char;
  
  if ((assert_failed == 0) && (assert_failed = -(max_cells >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 0x18d;
    elinks_internal((uchar *)"assertion max_cells>=0 failed!");
  }
  if (((end == (uchar *)0x0) && (end = (uchar *)__rawmemchr(string,0), end == (byte *)0x0)) ||
     (string == (uchar *)0x0)) {
LAB_080afb48:
    cell = -1;
  }
  else {
    iVar2 = 0;
    uVar3 = 0;
    utf8_char = string;
    do {
      do {
        iVar1 = utf8_char2cells(utf8_char,end);
        if (iVar1 < 0) goto LAB_080afb48;
        uVar3 = uVar3 + iVar1;
        if ((uint)max_cells < uVar3) {
          return iVar2;
        }
      } while (utf8_char == (byte *)0x0);
      iVar2 = iVar2 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                      [*utf8_char];
      utf8_char = string + iVar2;
    } while (utf8_char <= end);
    cell = (int)end - (int)string;
  }
  return cell;
}



// WARNING: Unknown calling convention

int utf8_ptr2cells(uchar *string,uchar *end)

{
  byte *pbVar1;
  byte *pbVar2;
  int cell;
  int iVar3;
  int local_20;
  
  if (((end == (uchar *)0x0) && (end = (uchar *)__rawmemchr(string,0), end == (byte *)0x0)) ||
     (string == (uchar *)0x0)) {
LAB_080afc70:
    local_20 = -1;
  }
  else {
    local_20 = 0;
    pbVar2 = string + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                      [*string];
    while (pbVar1 = pbVar2, pbVar1 <= end) {
      iVar3 = utf8_char2cells(string,end);
      if (iVar3 < 0) goto LAB_080afc70;
      local_20 = local_20 + iVar3;
      string = pbVar1;
      pbVar2 = pbVar1 + "\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x04\x04\x04\x04\x04\x04\x04\x04\x05\x05\x05\x05\x06\x06\x01\x01"
                        [*pbVar1];
    }
  }
  return local_20;
}



// WARNING: Unknown calling convention

void set_binding_values(uchar *domainname,uchar **dirnamep,uchar **codesetp)

{
  binding *pbVar1;
  bool bVar2;
  uchar *puVar3;
  int compare;
  uchar *codeset;
  size_t sVar4;
  binding *pbVar5;
  uchar *puVar6;
  int iVar7;
  uchar *puVar8;
  uchar *__ptr;
  int modified;
  uchar *dirname_1;
  binding *pbVar9;
  uchar *codeset_1;
  binding *binding;
  
  if ((domainname == (uchar *)0x0) || (*domainname == '\0')) goto failed;
  pbVar5 = _nl_domain_bindings__;
  if (_nl_domain_bindings__ != (binding *)0x0) {
    while( true ) {
      iVar7 = strcmp((char *)domainname,(char *)pbVar5->domainname);
      if (iVar7 == 0) break;
      if ((iVar7 < 0) || (pbVar5 = pbVar5->next, pbVar5 == (binding *)0x0)) goto LAB_080afe18;
    }
    if (pbVar5 != (binding *)0x0) {
      bVar2 = false;
      if (dirnamep != (uchar **)0x0) {
        puVar8 = *dirnamep;
        if (puVar8 == (uchar *)0x0) {
          *dirnamep = pbVar5->dirname;
        }
        else {
          puVar6 = pbVar5->dirname;
          iVar7 = strcmp((char *)puVar8,(char *)puVar6);
          bVar2 = false;
          if (iVar7 != 0) {
            iVar7 = strcmp((char *)puVar8,(char *)"/usr/share/locale");
            puVar3 = "/usr/share/locale";
            __ptr = puVar6;
            if (iVar7 != 0) {
              puVar6 = (uchar *)__strdup(puVar8);
              bVar2 = false;
              if (puVar6 == (uchar *)0x0) goto LAB_080afd95;
              __ptr = pbVar5->dirname;
              puVar3 = puVar6;
            }
            puVar6 = puVar3;
            if (__ptr != "/usr/share/locale") {
              free(__ptr);
            }
            pbVar5->dirname = puVar6;
            bVar2 = true;
          }
LAB_080afd95:
          *dirnamep = puVar6;
        }
      }
      if (codesetp != (uchar **)0x0) {
        puVar8 = *codesetp;
        if (puVar8 == (uchar *)0x0) {
          *codesetp = pbVar5->codeset;
        }
        else {
          puVar6 = pbVar5->codeset;
          if (((puVar6 == (uchar *)0x0) ||
              (iVar7 = strcmp((char *)puVar8,(char *)puVar6), iVar7 != 0)) &&
             (puVar6 = (uchar *)__strdup(puVar8), puVar6 != (uchar *)0x0)) {
            if (pbVar5->codeset != (uchar *)0x0) {
              free(pbVar5->codeset);
            }
            pbVar5->codeset_cntr = pbVar5->codeset_cntr + 1;
            bVar2 = true;
            pbVar5->codeset = puVar6;
          }
          *codesetp = puVar6;
        }
      }
      if (!bVar2) {
        return;
      }
      goto LAB_080afe06;
    }
  }
LAB_080afe18:
  if (((dirnamep == (uchar **)0x0) || (*dirnamep == (uchar *)0x0)) &&
     ((codesetp == (uchar **)0x0 || (*codesetp == (uchar *)0x0)))) {
    if (dirnamep != (uchar **)0x0) {
      *dirnamep = "/usr/share/locale";
    }
    if (codesetp == (uchar **)0x0) {
      return;
    }
    *codesetp = (uchar *)0x0;
    return;
  }
  sVar4 = strlen((char *)domainname);
  pbVar5 = (binding *)malloc(sVar4 + 0x11);
  if (pbVar5 == (binding *)0x0) goto failed;
  memcpy(pbVar5->domainname,domainname,sVar4 + 1);
  if (dirnamep != (uchar **)0x0) {
    puVar8 = *dirnamep;
    puVar6 = "/usr/share/locale";
    if (puVar8 == (uchar *)0x0) {
LAB_080afe97:
      *dirnamep = puVar6;
      pbVar5->dirname = puVar6;
      goto LAB_080afe9c;
    }
    iVar7 = strcmp((char *)puVar8,(char *)"/usr/share/locale");
    puVar6 = "/usr/share/locale";
    if ((iVar7 == 0) || (puVar6 = (uchar *)__strdup(puVar8), puVar6 != (uchar *)0x0))
    goto LAB_080afe97;
failed_dirname:
    free(pbVar5);
failed:
    if (dirnamep != (uchar **)0x0) {
      *dirnamep = (uchar *)0x0;
    }
    if (codesetp != (uchar **)0x0) {
      *codesetp = (uchar *)0x0;
    }
    return;
  }
  pbVar5->dirname = "/usr/share/locale";
LAB_080afe9c:
  pbVar5->codeset_cntr = 0;
  if (codesetp == (uchar **)0x0) {
    pbVar5->codeset = (uchar *)0x0;
    goto LAB_080afed3;
  }
  puVar8 = *codesetp;
  if (puVar8 != (uchar *)0x0) {
    puVar8 = (uchar *)__strdup(puVar8);
    if (puVar8 == (uchar *)0x0) {
      if (pbVar5->dirname != "/usr/share/locale") {
        free(pbVar5->dirname);
      }
      goto failed_dirname;
    }
    pbVar5->codeset_cntr = pbVar5->codeset_cntr + 1;
  }
  *codesetp = puVar8;
  pbVar5->codeset = puVar8;
LAB_080afed3:
  pbVar1 = _nl_domain_bindings__;
  if ((_nl_domain_bindings__ == (binding *)0x0) ||
     (iVar7 = strcmp((char *)domainname,(char *)_nl_domain_bindings__->domainname), iVar7 < 0)) {
    pbVar5->next = pbVar1;
    _nl_domain_bindings__ = pbVar5;
  }
  else {
    do {
      pbVar9 = pbVar1;
      pbVar1 = pbVar9->next;
      if (pbVar1 == (binding *)0x0) break;
      iVar7 = strcmp((char *)domainname,(char *)pbVar1->domainname);
    } while (0 < iVar7);
    pbVar5->next = pbVar1;
    pbVar9->next = pbVar5;
  }
LAB_080afe06:
  _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
  return;
}



// WARNING: Unknown calling convention

uchar * bind_textdomain_codeset__(uchar *domainname,uchar *codeset)

{
  set_binding_values(domainname,(uchar **)0x0,&codeset);
  return codeset;
}



// WARNING: Unknown calling convention

uchar * bindtextdomain__(uchar *domainname,uchar *dirname)

{
  set_binding_values(domainname,&dirname,(uchar **)0x0);
  return dirname;
}



// WARNING: Unknown calling convention

uchar * dcgettext__(uchar *domainname,uchar *msgid,int category)

{
  uchar *puVar1;
  
  puVar1 = dcigettext__(domainname,msgid,(uchar *)0x0,0,0,category);
  return puVar1;
}



// WARNING: Unknown calling convention

ulong plural_eval(expression *pexp,ulong n)

{
  int iVar1;
  int iVar2;
  ulong uVar3;
  ulong boolarg;
  ulong arg;
  ulong uVar4;
  ulong rightarg;
  ulong leftarg;
  bool bVar5;
  
  iVar1 = pexp->nargs;
  iVar2 = iVar1 + -1;
  bVar5 = iVar1 == 1;
  while( true ) {
    if (bVar5) {
      uVar3 = plural_eval((pexp->val).args[0],n);
      arg = (ulong)(uVar3 == 0);
      return arg;
    }
    if (bVar5 || SBORROW4(iVar1,1) != iVar2 < 0) {
      if (iVar1 == 0) {
        if (pexp->operation == var) {
          return n;
        }
        if (pexp->operation == num) {
          return (pexp->val).num;
        }
      }
      return 0;
    }
    if (iVar1 == 2) break;
    if (iVar1 != 3) {
      return 0;
    }
    uVar3 = plural_eval((pexp->val).args[0],n);
    pexp = *(expression **)((int)&pexp->val + ~-(uint)(uVar3 == 0) * 4 + 8);
    iVar1 = pexp->nargs;
    iVar2 = iVar1 + -1;
    bVar5 = iVar2 == 0;
  }
  uVar3 = plural_eval((pexp->val).args[0],n);
  if (pexp->operation == lor) {
    if (uVar3 != 0) {
      return 1;
    }
  }
  else {
    if (pexp->operation != land) {
      uVar4 = plural_eval((pexp->val).args[1],n);
      switch(pexp->operation) {
      case mult:
        return uVar4 * uVar3;
      case divide:
        return uVar3 / uVar4;
      case module:
        return uVar3 % uVar4;
      case plus:
        return uVar4 + uVar3;
      case minus:
        return uVar3 - uVar4;
      case less_than:
        return (uint)(uVar3 < uVar4);
      case greater_than:
        return (uint)(uVar4 < uVar3);
      case less_or_equal:
        return (uint)(uVar3 <= uVar4);
      case greater_or_equal:
        return (uint)(uVar4 <= uVar3);
      case equal:
        return (uint)(uVar3 == uVar4);
      case not_equal:
        return (uint)(uVar3 != uVar4);
      default:
        return 0;
      }
    }
    if (uVar3 == 0) {
      return 0;
    }
  }
  uVar3 = plural_eval((pexp->val).args[1],n);
  return (uint)(uVar3 != 0);
}



// WARNING: Unknown calling convention

int transcmp(void *p1,void *p2)

{
  int iVar1;
  int result;
  
  iVar1 = strcmp((char *)((int)p1 + 0x18),(char *)((int)p2 + 0x18));
  if (iVar1 == 0) {
                    // WARNING: Load size is inaccurate
                    // WARNING: Load size is inaccurate
    iVar1 = strcmp(*p1,*p2);
    if (iVar1 == 0) {
      iVar1 = *(int *)((int)p1 + 4) - *(int *)((int)p2 + 4);
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * _nl_find_msg(loaded_l10nfile *domain_file,binding *domainbinding,uchar *msgid,
                    size_t *lengthp)

{
  loaded_domain *domain;
  nls_uint32 *pnVar1;
  uint uVar2;
  size_t sVar3;
  ulong g;
  nls_uint32 nVar4;
  nls_uint32 nVar5;
  int cmp_val;
  int iVar6;
  size_t *psVar7;
  transmem_block_t *newmem;
  uchar *outbuf;
  int *piVar8;
  uchar **ppuVar9;
  uint uVar10;
  nls_uint32 hash_val;
  ulong hval;
  transmem_block_t *transmem_list;
  string_desc *psVar11;
  byte *pbVar12;
  nls_uint32 idx;
  uchar *result;
  size_t *psVar13;
  uint uVar14;
  uchar *__ptr;
  size_t act;
  nls_uint32 nstr;
  int iVar15;
  size_t bottom;
  int malloc_count;
  uint uVar16;
  int iVar17;
  size_t top;
  size_t resultlen;
  bool bVar18;
  uchar *local_30;
  size_t local_2c;
  uchar *local_28;
  size_t local_24;
  size_t *local_20 [4];
  
  if (domain_file->decided == 0) {
    _nl_load_domain(domain_file,domainbinding);
  }
  domain = (loaded_domain *)domain_file->data;
  if (domain != (loaded_domain *)0x0) {
    uVar16 = domain->hash_size;
    if ((2 < uVar16) && (pnVar1 = domain->hash_tab, pnVar1 != (nls_uint32 *)0x0)) {
      sVar3 = strlen((char *)msgid);
      uVar10 = 0;
      for (pbVar12 = msgid; *pbVar12 != 0; pbVar12 = pbVar12 + 1) {
        uVar10 = uVar10 * 0x10 + (uint)*pbVar12;
        g = uVar10 & 0xf0000000;
        if (g != 0) {
          uVar10 = uVar10 ^ g ^ g >> 0x18;
        }
      }
      iVar17 = uVar10 % (uVar16 - 2) + 1;
      iVar6 = domain->must_swap;
      uVar10 = uVar10 % uVar16;
LAB_080b03db:
      if (iVar6 == 0) {
        nVar5 = pnVar1[uVar10];
      }
      else {
        uVar14 = pnVar1[uVar10];
        nVar5 = uVar14 >> 0x18 | uVar14 << 0x18 | (uVar14 & 0xff00) << 8 | uVar14 >> 8 & 0xff00;
      }
      if (nVar5 == 0) {
        return (uchar *)0x0;
      }
      if (iVar6 == 0) {
        psVar11 = domain->orig_tab;
        nVar4 = psVar11[nVar5 - 1].length;
      }
      else {
        iVar15 = nVar5 - 1;
        psVar11 = domain->orig_tab;
        nVar4 = psVar11[iVar15].length >> 0x18 | psVar11[iVar15].length << 0x18 |
                (psVar11[iVar15].length & 0xff00) << 8 | psVar11[iVar15].length >> 8 & 0xff00;
      }
      uVar14 = nVar5 - 1;
      if (sVar3 <= nVar4) {
        local_30 = domain->data;
        if (iVar6 == 0) {
          nVar5 = psVar11[uVar14].offset;
        }
        else {
          uVar2 = psVar11[uVar14].offset;
          nVar5 = uVar2 >> 0x18 | uVar2 << 0x18 | (uVar2 & 0xff00) << 8 | uVar2 >> 8 & 0xff00;
        }
        iVar15 = strcmp((char *)msgid,(char *)(local_30 + nVar5));
        if (iVar15 == 0) goto found;
      }
      bVar18 = uVar10 < uVar16 - iVar17;
      uVar14 = uVar10 + iVar17;
      uVar10 = uVar10 + (iVar17 - uVar16);
      if (bVar18) {
        uVar10 = uVar14;
      }
      goto LAB_080b03db;
    }
    nVar5 = domain->nstrings;
    uVar16 = 0;
    while (uVar16 < nVar5) {
      iVar6 = domain->must_swap;
      local_30 = domain->data;
      while( true ) {
        uVar14 = nVar5 + uVar16 >> 1;
        if (iVar6 == 0) {
          nVar4 = domain->orig_tab[uVar14].offset;
        }
        else {
          uVar10 = domain->orig_tab[uVar14].offset;
          nVar4 = uVar10 >> 0x18 | uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | uVar10 >> 8 & 0xff00;
        }
        iVar17 = strcmp((char *)msgid,(char *)(local_30 + nVar4));
        if (-1 < iVar17) break;
        nVar5 = uVar14;
        if (uVar14 <= uVar16) {
          return (uchar *)0x0;
        }
      }
      if (iVar17 == 0) goto found;
      uVar16 = uVar14 + 1;
    }
  }
  return (uchar *)0x0;
found:
  if (iVar6 == 0) {
    nVar5 = domain->trans_tab[uVar14].length;
    nVar4 = domain->trans_tab[uVar14].offset;
  }
  else {
    uVar16 = domain->trans_tab[uVar14].offset;
    uVar10 = domain->trans_tab[uVar14].length;
    nVar4 = uVar16 >> 0x18 | uVar16 << 0x18 | (uVar16 & 0xff00) << 8 | uVar16 >> 8 & 0xff00;
    nVar5 = uVar10 >> 0x18 | uVar10 << 0x18 | (uVar10 & 0xff00) << 8 | uVar10 >> 8 & 0xff00;
  }
  psVar13 = (size_t *)(local_30 + nVar4);
  resultlen = nVar5 + 1;
  iVar6 = 0;
  if (domainbinding != (binding *)0x0) {
    iVar6 = domainbinding->codeset_cntr;
  }
  if (domain->codeset_cntr != iVar6) {
    _nl_free_domain_conv(domain);
    _nl_init_domain_conv(domain_file,domain,domainbinding);
  }
  if (domain->conv != (iconv_t)0xffffffff) {
    ppuVar9 = domain->conv_tab;
    if (ppuVar9 == (uchar **)0x0) {
      ppuVar9 = (uchar **)calloc(domain->nstrings,4);
      domain->conv_tab = ppuVar9;
      if (ppuVar9 == (uchar **)0x0) {
        domain->conv_tab = (uchar **)0xffffffff;
        goto converted;
      }
    }
    if (ppuVar9 != (uchar **)0xffffffff) {
      psVar7 = (size_t *)ppuVar9[uVar14];
      if (psVar7 == (size_t *)0x0) {
        __ptr = (uchar *)0x0;
        iVar6 = 0;
        do {
          local_28 = _nl_find_msg::lexical_block_2::freemem + 4;
          local_24 = resultlen;
          local_20[0] = psVar13;
          if (3 < _nl_find_msg::lexical_block_2::freemem_size) {
            local_2c = _nl_find_msg::lexical_block_2::freemem_size - 4;
            sVar3 = iconv(domain->conv,(char **)local_20,&local_24,(char **)&local_28,&local_2c);
            if (sVar3 != 0xffffffff) {
              *(uchar **)_nl_find_msg::lexical_block_2::freemem =
                   local_28 + (-4 - (int)_nl_find_msg::lexical_block_2::freemem);
              domain->conv_tab[uVar14] = _nl_find_msg::lexical_block_2::freemem;
              iVar6 = _nl_find_msg::lexical_block_2::freemem_size - (int)local_28;
              _nl_find_msg::lexical_block_2::freemem_size =
                   (uint)(_nl_find_msg::lexical_block_2::freemem + iVar6) & 0xfffffffc;
              _nl_find_msg::lexical_block_2::freemem =
                   local_28 + ((uint)(_nl_find_msg::lexical_block_2::freemem + iVar6) & 3);
              psVar7 = (size_t *)domain->conv_tab[uVar14];
              goto LAB_080b04ab;
            }
            piVar8 = __errno_location();
            if (*piVar8 != 7) goto converted;
          }
          if (iVar6 == 0) {
            _nl_find_msg::lexical_block_2::freemem_size = 0xff0;
            iVar6 = 1;
            __ptr = (uchar *)malloc(0xff0);
          }
          else {
            iVar6 = iVar6 + 1;
            _nl_find_msg::lexical_block_2::freemem_size = iVar6 * 0xff0;
            __ptr = (uchar *)realloc(__ptr,_nl_find_msg::lexical_block_2::freemem_size);
          }
          _nl_find_msg::lexical_block_2::freemem = __ptr;
        } while (__ptr != (uchar *)0x0);
        _nl_find_msg::lexical_block_2::freemem = (uchar *)0x0;
        _nl_find_msg::lexical_block_2::freemem_size = 0;
      }
      else {
LAB_080b04ab:
        resultlen = *psVar7;
        psVar13 = psVar7 + 1;
      }
    }
  }
converted:
  *lengthp = resultlen;
  return (uchar *)psVar13;
}



// WARNING: Unknown calling convention

uchar * plural_lookup(loaded_l10nfile *domain,ulong n,uchar *translation,size_t translation_len)

{
  void *pvVar1;
  ulong uVar2;
  ulong indexx;
  uchar *p;
  int iVar3;
  uchar *puVar4;
  loaded_domain *domaindata;
  
  pvVar1 = domain->data;
  uVar2 = plural_eval(*(expression **)((int)pvVar1 + 0x30),n);
  if (*(uint *)((int)pvVar1 + 0x34) <= uVar2) {
    uVar2 = 0;
  }
  puVar4 = translation;
  do {
    if (uVar2 == 0) {
      return puVar4;
    }
    uVar2 = uVar2 - 1;
    iVar3 = __rawmemchr(puVar4,0);
    puVar4 = (uchar *)(iVar3 + 1);
  } while (puVar4 < translation + translation_len);
  return translation;
}



// WARNING: Unknown calling convention

uchar * dcigettext__(uchar *domainname,uchar *msgid1,uchar *msgid2,int plural,ulong n,int category)

{
  int iVar1;
  binding *pbVar2;
  int *piVar3;
  binding *pbVar4;
  uchar uVar5;
  size_t sVar6;
  int compare;
  int iVar7;
  char *pcVar8;
  undefined4 uVar9;
  __uid_t _Var10;
  __uid_t _Var11;
  uchar *puVar12;
  undefined4 *puVar13;
  loaded_l10nfile *plVar14;
  loaded_l10nfile *plVar15;
  void **ppvVar16;
  void *pvVar17;
  void **ppvVar18;
  __gid_t _Var19;
  __gid_t _Var20;
  uchar *cp;
  int iVar21;
  uchar *puVar22;
  binding *binding;
  uchar *dirname;
  uchar *puVar23;
  uchar *categoryvalue;
  undefined *puVar24;
  undefined *puVar25;
  uchar **ppuVar26;
  undefined *puVar27;
  uint uVar28;
  size_t path_max;
  uchar *categoryname;
  loaded_l10nfile *domain;
  uchar *retval;
  size_t dirname_len;
  int cnt;
  uchar *puVar29;
  int in_GS_OFFSET;
  bool bVar30;
  byte bVar31;
  int *piStackY_80;
  __compar_fn_t ap_Stack_74 [3];
  uchar *local_68;
  uchar *local_64;
  uchar *local_60 [2];
  size_t local_58;
  int local_54;
  int local_50;
  int *local_4c;
  uchar *local_48;
  int *local_44;
  loaded_l10nfile *local_40;
  uchar *local_3c;
  binding *local_38;
  uchar *local_34;
  binding *local_30;
  void *local_24;
  int local_20;
  
  bVar31 = 0;
  local_48 = domainname;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_34 = msgid1;
  local_60[1] = msgid2;
  puVar27 = &stack0xffffff84;
  puVar23 = (uchar *)0x0;
  if (msgid1 == (uchar *)0x0) goto LAB_080b09c8;
  if (domainname == (uchar *)0x0) {
    domainname = _nl_current_default_domain__;
  }
  piStackY_80 = (int *)0x80b081d;
  local_48 = domainname;
  sVar6 = strlen((char *)msgid1);
  puVar23 = local_34;
  iVar1 = -(sVar6 + 0x37 & 0xfffffff0);
  ppuVar26 = (uchar **)(&stack0xffffff84 + iVar1);
  local_54 = sVar6 + 1;
  *(size_t *)((int)ap_Stack_74 + iVar1) = sVar6 + 1;
  *(uchar **)(&stack0xffffff88 + iVar1) = puVar23;
  *(int *)(&stack0xffffff84 + iVar1) = (int)&local_48 + iVar1;
  *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b0848;
  memcpy(*(void **)(&stack0xffffff84 + iVar1),*(void **)(&stack0xffffff88 + iVar1),
         *(size_t *)((int)ap_Stack_74 + iVar1));
  *(uchar **)((int)local_60 + iVar1) = local_48;
  *(int *)((int)local_60 + iVar1 + 4) = category;
  *(code **)((int)ap_Stack_74 + iVar1) = transcmp;
  *(void ***)(&stack0xffffff88 + iVar1) = &root;
  *(uchar ***)(&stack0xffffff84 + iVar1) = (uchar **)((int)local_60 + iVar1);
  *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b086b;
  local_44 = (int *)tfind(*(void **)(&stack0xffffff84 + iVar1),*(void ***)(&stack0xffffff88 + iVar1)
                          ,*(__compar_fn_t *)((int)ap_Stack_74 + iVar1));
  if ((local_44 != (int *)0x0) && (iVar7 = *local_44, *(int *)(iVar7 + 8) == _nl_msg_cat_cntr)) {
    if (plural == 0) {
      puVar27 = &stack0xffffff84 + iVar1;
      puVar23 = *(uchar **)(iVar7 + 0x10);
    }
    else {
      puVar23 = *(uchar **)(iVar7 + 0x10);
      plVar14 = *(loaded_l10nfile **)(iVar7 + 0xc);
      *(undefined4 *)(&stack0xffffff84 + iVar1) = *(undefined4 *)(iVar7 + 0x14);
      *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b0d96;
      puVar23 = plural_lookup(plVar14,n,puVar23,*(size_t *)(&stack0xffffff84 + iVar1));
      puVar27 = &stack0xffffff84 + iVar1;
    }
    goto LAB_080b09c8;
  }
  *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b0888;
  local_4c = __errno_location();
  local_50 = *local_4c;
  pbVar2 = _nl_domain_bindings__;
  puVar23 = local_48;
  if (enable_secure == 0) {
    *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b09e7;
    _Var10 = getuid();
    *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b09ee;
    _Var11 = geteuid();
    if (_Var10 == _Var11) {
      *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b0dde;
      _Var19 = getgid();
      *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b0de5;
      _Var20 = getegid();
      if (_Var19 == _Var20) {
        enable_secure = -1;
        pbVar2 = _nl_domain_bindings__;
        puVar23 = local_48;
        goto joined_r0x080b08a6;
      }
    }
    enable_secure = 1;
    pbVar2 = _nl_domain_bindings__;
    puVar23 = local_48;
  }
joined_r0x080b08a6:
  for (; puVar12 = local_48, local_48 = puVar23, pbVar2 != (binding *)0x0; pbVar2 = pbVar2->next) {
    *(uchar **)(&stack0xffffff88 + iVar1) = pbVar2->domainname;
    *(uchar **)(&stack0xffffff84 + iVar1) = puVar12;
    *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b08d7;
    iVar7 = strcmp(*(char **)(&stack0xffffff84 + iVar1),*(char **)(&stack0xffffff88 + iVar1));
    if (iVar7 == 0) {
      local_30 = pbVar2;
      if (pbVar2 == (binding *)0x0) {
        local_3c = "/usr/share/locale";
        ppuVar26 = (uchar **)(&stack0xffffff84 + iVar1);
        goto LAB_080b098d;
      }
      local_3c = pbVar2->dirname;
      ppuVar26 = (uchar **)(&stack0xffffff84 + iVar1);
      if (*local_3c == '/') goto LAB_080b098d;
      *(uchar **)(&stack0xffffff84 + iVar1) = local_3c;
      uVar28 = 0x1002;
      *(undefined4 *)((int)&piStackY_80 + iVar1) = 0x80b0903;
      sVar6 = strlen(*(char **)(&stack0xffffff84 + iVar1));
      piVar3 = local_4c;
      local_38 = pbVar2;
      local_30 = (binding *)(sVar6 + 1);
      puVar24 = &stack0xffffff84 + iVar1;
      goto LAB_080b0929;
    }
    if (iVar7 < 0) break;
    puVar23 = local_48;
    local_48 = puVar12;
  }
  local_30 = (binding *)0x0;
  local_3c = "/usr/share/locale";
LAB_080b098d:
  pcVar8 = "LC_XXX";
  switch(category) {
  case 0:
    pcVar8 = "LC_CTYPE";
    break;
  case 1:
    pcVar8 = "LC_NUMERIC";
    break;
  case 2:
    pcVar8 = "LC_TIME";
    break;
  case 3:
    pcVar8 = "LC_COLLATE";
    break;
  case 4:
    pcVar8 = "LC_MONETARY";
    break;
  case 5:
    pcVar8 = "LC_MESSAGES";
    break;
  case 6:
    pcVar8 = "LC_ALL";
  }
  if ((LANGUAGE == (uchar *)0x0) || (puVar12 = LANGUAGE, *LANGUAGE == '\0')) {
    *ppuVar26 = (uchar *)"LANGUAGE";
    ppuVar26[-1] = (uchar *)0x80b0a2b;
    puVar12 = (uchar *)getenv((char *)*ppuVar26);
    if ((puVar12 == (uchar *)0x0) || (*puVar12 == '\0')) {
      ppuVar26[1] = (uchar *)0x0;
      *ppuVar26 = (uchar *)category;
      ppuVar26[-1] = (uchar *)0x80b0d7b;
      puVar12 = (uchar *)setlocale((int)*ppuVar26,(char *)ppuVar26[1]);
    }
  }
  *ppuVar26 = local_48;
  ppuVar26[-1] = (uchar *)0x80b0a49;
  local_58 = strlen((char *)*ppuVar26);
  *ppuVar26 = (uchar *)pcVar8;
  ppuVar26[-1] = (uchar *)0x80b0a54;
  sVar6 = strlen((char *)*ppuVar26);
  iVar1 = -(local_58 + 0x23 + sVar6 & 0xfffffff0);
  local_38 = (binding *)((int)ppuVar26 + iVar1 + 0x1f & 0xfffffff0);
  *(binding **)((int)ppuVar26 + iVar1) = local_38;
  *(char **)((int)ppuVar26 + iVar1 + 4) = pcVar8;
  *(undefined4 *)((int)ppuVar26 + iVar1 + -4) = 0x80b0a76;
  pcVar8 = stpcpy(*(char **)((int)ppuVar26 + iVar1),*(char **)((int)ppuVar26 + iVar1 + 4));
  *(undefined **)((int)ppuVar26 + iVar1 + 4) = &DAT_08132419;
  *(char **)((int)ppuVar26 + iVar1) = pcVar8;
  *(undefined4 *)((int)ppuVar26 + iVar1 + -4) = 0x80b0a86;
  pcVar8 = stpcpy(*(char **)((int)ppuVar26 + iVar1),*(char **)((int)ppuVar26 + iVar1 + 4));
  puVar23 = local_48;
  *(size_t *)((int)ppuVar26 + iVar1 + 8) = local_58;
  *(uchar **)((int)ppuVar26 + iVar1 + 4) = puVar23;
  *(char **)((int)ppuVar26 + iVar1) = pcVar8;
  *(undefined4 *)((int)ppuVar26 + iVar1 + -4) = 0x80b0a9c;
  puVar13 = (undefined4 *)
            mempcpy(*(void **)((int)ppuVar26 + iVar1),*(void **)((int)ppuVar26 + iVar1 + 4),
                    *(size_t *)((int)ppuVar26 + iVar1 + 8));
  *puVar13 = 0x6f6d2e;
  *(uchar **)((int)ppuVar26 + iVar1) = puVar12;
  *(undefined4 *)((int)ppuVar26 + iVar1 + -4) = 0x80b0aaa;
  sVar6 = strlen(*(char **)((int)ppuVar26 + iVar1));
  iVar7 = -(sVar6 + 0x1f & 0xfffffff0);
  puVar25 = (undefined *)((int)ppuVar26 + iVar7 + iVar1);
  puVar27 = (undefined *)((int)ppuVar26 + iVar7 + iVar1);
  puVar23 = (uchar *)((int)ppuVar26 + iVar7 + iVar1 + 0x1f & 0xfffffff0);
LAB_080b0ac0:
  do {
    uVar5 = *puVar12;
    while (uVar5 != ':') {
      puVar22 = puVar23;
      if (uVar5 == '\0') {
        *puVar23 = 'C';
        puVar23[1] = '\0';
LAB_080b0adc:
        pbVar4 = local_30;
        pbVar2 = local_38;
        bVar30 = *puVar23 == 'C';
        if ((bVar30) && (bVar30 = puVar23[1] == '\0', bVar30)) goto LAB_080b09a8;
        iVar21 = 6;
        puVar22 = puVar23;
        puVar29 = (uchar *)"POSIX";
        goto code_r0x080b0b03;
      }
      do {
        puVar12 = puVar12 + 1;
        *puVar22 = uVar5;
        uVar5 = *puVar12;
        puVar22 = puVar22 + 1;
        if (uVar5 == ':') break;
      } while (uVar5 != '\0');
      *puVar22 = '\0';
      if (enable_secure != 1) goto LAB_080b0adc;
      *(uchar **)((int)ppuVar26 + iVar7 + iVar1) = puVar23;
      *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + 4) = 0x2f;
      local_68 = puVar23;
      *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0bee;
      pcVar8 = strchr(*(char **)((int)ppuVar26 + iVar7 + iVar1),
                      *(int *)((int)ppuVar26 + iVar7 + iVar1 + 4));
      puVar23 = local_68;
      if (pcVar8 == (char *)0x0) goto LAB_080b0adc;
      uVar5 = *puVar12;
    }
    puVar12 = puVar12 + 1;
  } while( true );
LAB_080b0929:
  *piVar3 = 0;
  iVar1 = -((uint)(local_30[1].domainname + (uVar28 - 6)) & 0xfffffff0);
  puVar25 = puVar24 + iVar1;
  puVar27 = puVar24 + iVar1;
  puVar23 = (uchar *)((uint)(puVar24 + iVar1 + 0x1f) & 0xfffffff0);
  *(uint *)(puVar24 + iVar1 + 4) = uVar28;
  *(uchar **)(puVar24 + iVar1) = puVar23;
  *(undefined4 *)(puVar24 + iVar1 + -4) = 0x80b094e;
  pcVar8 = getcwd(*(char **)(puVar24 + iVar1),*(size_t *)(puVar24 + iVar1 + 4));
  pbVar2 = local_38;
  if (pcVar8 != (char *)0x0) goto code_r0x080b0952;
  if (*piVar3 != 0x22) {
    *local_4c = local_50;
    goto joined_r0x080b0d4b;
  }
  uVar28 = uVar28 + 0x20 + (uVar28 >> 1);
  puVar24 = puVar24 + iVar1;
  goto LAB_080b0929;
code_r0x080b0952:
  puVar12 = local_38->dirname;
  local_3c = puVar23;
  *(undefined4 *)(puVar24 + iVar1 + 4) = 0;
  *(uchar **)(puVar24 + iVar1) = puVar23;
  *(undefined4 *)(puVar24 + iVar1 + -4) = 0x80b096e;
  uVar9 = __rawmemchr();
  *(undefined **)(puVar24 + iVar1 + 4) = &DAT_08132419;
  *(undefined4 *)(puVar24 + iVar1) = uVar9;
  *(undefined4 *)(puVar24 + iVar1 + -4) = 0x80b097e;
  pcVar8 = stpcpy(*(char **)(puVar24 + iVar1),*(char **)(puVar24 + iVar1 + 4));
  *(uchar **)(puVar24 + iVar1 + 4) = puVar12;
  *(char **)(puVar24 + iVar1) = pcVar8;
  *(undefined4 *)(puVar24 + iVar1 + -4) = 0x80b098a;
  strcpy(*(char **)(puVar24 + iVar1),*(char **)(puVar24 + iVar1 + 4));
  local_30 = pbVar2;
  ppuVar26 = (uchar **)(puVar24 + iVar1);
  goto LAB_080b098d;
  while( true ) {
    iVar21 = iVar21 + -1;
    bVar30 = *puVar22 == *puVar29;
    puVar22 = puVar22 + (uint)bVar31 * -2 + 1;
    puVar29 = puVar29 + (uint)bVar31 * -2 + 1;
    if (!bVar30) break;
code_r0x080b0b03:
    if (iVar21 == 0) break;
  }
  if (bVar30) goto LAB_080b09a8;
  *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 4) = puVar23;
  local_68 = puVar23;
  *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 0xc) = pbVar4;
  puVar23 = local_3c;
  *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 8) = pbVar2;
  *(uchar **)((int)ppuVar26 + iVar7 + iVar1) = puVar23;
  *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0b2b;
  plVar14 = _nl_find_domain(*(uchar **)((int)ppuVar26 + iVar7 + iVar1),
                            *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 4),
                            *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 8),
                            *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 0xc));
  puVar22 = local_34;
  puVar23 = local_68;
  if (plVar14 != (loaded_l10nfile *)0x0) {
    *(void ***)((int)ppuVar26 + iVar7 + iVar1 + 0xc) = &local_24;
    pbVar2 = local_30;
    *(loaded_l10nfile **)((int)ppuVar26 + iVar7 + iVar1) = plVar14;
    *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 8) = puVar22;
    *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 4) = pbVar2;
    *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0b51;
    puVar23 = _nl_find_msg(*(loaded_l10nfile **)((int)ppuVar26 + iVar7 + iVar1),
                           *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 4),
                           *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 8),
                           *(size_t **)((int)ppuVar26 + iVar7 + iVar1 + 0xc));
    pbVar2 = local_30;
    puVar22 = local_34;
    if (puVar23 != (uchar *)0x0) {
      *local_4c = local_50;
joined_r0x080b0c75:
      if (local_44 == (int *)0x0) {
        *(size_t *)((int)ppuVar26 + iVar7 + iVar1) = local_54 + 0x19 + local_58;
        *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0c8d;
        ppvVar16 = (void **)malloc(*(size_t *)((int)ppuVar26 + iVar7 + iVar1));
        iVar21 = local_54;
        if (ppvVar16 != (void **)0x0) {
          *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 4) = local_34;
          *(int *)((int)ppuVar26 + iVar7 + iVar1 + 8) = iVar21;
          *(void ***)((int)ppuVar26 + iVar7 + iVar1) = ppvVar16 + 6;
          *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0cb0;
          pvVar17 = mempcpy(*(void **)((int)ppuVar26 + iVar7 + iVar1),
                            *(void **)((int)ppuVar26 + iVar7 + iVar1 + 4),
                            *(size_t *)((int)ppuVar26 + iVar7 + iVar1 + 8));
          sVar6 = local_58;
          *ppvVar16 = pvVar17;
          *(void **)((int)ppuVar26 + iVar7 + iVar1) = pvVar17;
          *(size_t *)((int)ppuVar26 + iVar7 + iVar1 + 8) = sVar6 + 1;
          *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 4) = local_48;
          *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0ccb;
          memcpy(*(void **)((int)ppuVar26 + iVar7 + iVar1),
                 *(void **)((int)ppuVar26 + iVar7 + iVar1 + 4),
                 *(size_t *)((int)ppuVar26 + iVar7 + iVar1 + 8));
          ppvVar16[1] = (void *)category;
          iVar21 = _nl_msg_cat_cntr;
          ppvVar16[3] = plVar14;
          ppvVar16[4] = puVar23;
          ppvVar16[2] = (void *)iVar21;
          ppvVar16[5] = local_24;
          *(code **)((int)ppuVar26 + iVar7 + iVar1 + 8) = transcmp;
          *(void ***)((int)ppuVar26 + iVar7 + iVar1 + 4) = &root;
          *(void ***)((int)ppuVar26 + iVar7 + iVar1) = ppvVar16;
          *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0cfd;
          ppvVar18 = (void **)tsearch(*(void **)((int)ppuVar26 + iVar7 + iVar1),
                                      *(void ***)((int)ppuVar26 + iVar7 + iVar1 + 4),
                                      *(__compar_fn_t *)((int)ppuVar26 + iVar7 + iVar1 + 8));
          if ((ppvVar18 == (void **)0x0) || ((void **)*ppvVar18 != ppvVar16)) {
            *(void ***)((int)ppuVar26 + iVar7 + iVar1) = ppvVar16;
            *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0d15;
            free(*(void **)((int)ppuVar26 + iVar7 + iVar1));
          }
        }
      }
      else {
        *(int *)(*local_44 + 8) = _nl_msg_cat_cntr;
        *(loaded_l10nfile **)(*local_44 + 0xc) = plVar14;
        *(uchar **)(*local_44 + 0x10) = puVar23;
        *(void **)(*local_44 + 0x14) = local_24;
      }
      puVar27 = (undefined *)((int)ppuVar26 + iVar7 + iVar1);
      if (plural != 0) {
        *(void **)((int)ppuVar26 + iVar7 + iVar1) = local_24;
        *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0bb1;
        puVar23 = plural_lookup(plVar14,n,puVar23,*(size_t *)((int)ppuVar26 + iVar7 + iVar1));
        puVar27 = (undefined *)((int)ppuVar26 + iVar7 + iVar1);
      }
      goto LAB_080b09c8;
    }
    plVar15 = plVar14->successor[0];
    puVar23 = local_68;
    if (plVar15 != (loaded_l10nfile *)0x0) {
      local_60[0] = puVar12;
      local_40 = plVar14;
      local_64 = local_68;
      iVar21 = 0;
      do {
        *(void ***)((int)ppuVar26 + iVar7 + iVar1 + 0xc) = &local_24;
        *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 8) = puVar22;
        *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 4) = pbVar2;
        *(loaded_l10nfile **)((int)ppuVar26 + iVar7 + iVar1) = plVar15;
        *(undefined4 *)((int)ppuVar26 + iVar7 + iVar1 + -4) = 0x80b0c59;
        puVar23 = _nl_find_msg(*(loaded_l10nfile **)((int)ppuVar26 + iVar7 + iVar1),
                               *(binding **)((int)ppuVar26 + iVar7 + iVar1 + 4),
                               *(uchar **)((int)ppuVar26 + iVar7 + iVar1 + 8),
                               *(size_t **)((int)ppuVar26 + iVar7 + iVar1 + 0xc));
        if (puVar23 != (uchar *)0x0) {
          plVar14 = local_40->successor[iVar21];
          *local_4c = local_50;
          goto joined_r0x080b0c75;
        }
        plVar15 = local_40[1].successor[iVar21 + -6];
        puVar23 = local_64;
        puVar12 = local_60[0];
        iVar21 = iVar21 + 1;
      } while (plVar15 != (loaded_l10nfile *)0x0);
    }
  }
  goto LAB_080b0ac0;
LAB_080b09a8:
  *local_4c = local_50;
joined_r0x080b0d4b:
  puVar23 = local_34;
  if ((plural != 0) && (puVar27 = puVar25, n != 1)) {
    puVar23 = local_60[1];
  }
LAB_080b09c8:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    *(undefined4 *)(puVar27 + -4) = 0x80b0e01;
    __stack_chk_fail();
  }
  return puVar23;
}



// WARNING: Unknown calling convention

uchar * dcngettext__(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n,int category)

{
  uchar *puVar1;
  
  puVar1 = dcigettext__(domainname,msgid1,msgid2,1,n,category);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * dgettext__(uchar *domainname,uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = dcgettext__(domainname,msgid,5);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * dngettext__(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = dcngettext__(domainname,msgid1,msgid2,n,5);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * _nl_find_language(uchar *name)

{
  uchar uVar1;
  
  uVar1 = *name;
  if ((uVar1 != '\0') && (uVar1 != '_')) {
    while ((uVar1 != '@' && ((uVar1 != '+' && (uVar1 != ','))))) {
      name = name + 1;
      uVar1 = *name;
      if (uVar1 == '_') {
        return name;
      }
      if (uVar1 == '\0') {
        return name;
      }
    }
  }
  return name;
}



// WARNING: Unknown calling convention

int _nl_explode_name(uchar *name,uchar **language,uchar **modifier,uchar **territory,uchar **codeset
                    ,uchar **normalized_codeset,uchar **special,uchar **sponsor,uchar **revision)

{
  bool bVar1;
  uint uVar2;
  int mask;
  int iVar3;
  uchar uVar4;
  uchar *cp;
  uchar *puVar5;
  uchar *puVar6;
  anon_enum_32 syntax;
  uchar local_2d;
  int local_20;
  
  *modifier = (uchar *)0x0;
  *territory = (uchar *)0x0;
  *codeset = (uchar *)0x0;
  *normalized_codeset = (uchar *)0x0;
  *special = (uchar *)0x0;
  *sponsor = (uchar *)0x0;
  *revision = (uchar *)0x0;
  *language = name;
  uVar4 = *name;
  if ((((uVar4 == '_') || (uVar4 == '\0')) || (uVar4 == '@')) ||
     ((uVar4 == '+' || (puVar5 = name, uVar4 == ',')))) {
LAB_080b12a8:
    bVar1 = false;
    puVar5 = (uchar *)__rawmemchr(name,0);
    local_2d = *puVar5;
    uVar2 = 0;
  }
  else {
    do {
      puVar6 = puVar5;
      puVar5 = puVar6 + 1;
      local_2d = *puVar5;
      if (((local_2d == '_') || ((local_2d == '\0' || (local_2d == '@')))) || (local_2d == '+'))
      break;
    } while (local_2d != ',');
    if (name == puVar5) goto LAB_080b12a8;
    uVar2 = 0;
    bVar1 = false;
    if (local_2d == '_') {
      *puVar5 = '\0';
      puVar5 = puVar6 + 2;
      *territory = puVar5;
      local_2d = *puVar5;
      while (local_2d != '.') {
        if ((((local_2d == '\0') || (local_2d == '@')) || (local_2d == '+')) ||
           ((local_2d == ',' || (local_2d == '_')))) {
          uVar2 = 0x20;
          bVar1 = false;
          goto LAB_080b0fc0;
        }
        puVar5 = puVar5 + 1;
        local_2d = *puVar5;
      }
      *puVar5 = '\0';
      puVar6 = puVar5 + 1;
      *codeset = puVar6;
      local_2d = *puVar6;
      if ((local_2d != '\0') && (puVar5 = puVar6, local_2d != '@')) {
        do {
          puVar5 = puVar5 + 1;
          if (*puVar5 == '@') break;
        } while (*puVar5 != '\0');
        if (puVar5 == puVar6) {
          uVar2 = 0x30;
          goto LAB_080b1028;
        }
        puVar6 = _nl_normalize_codeset(puVar6,(int)puVar5 - (int)puVar6);
        *normalized_codeset = puVar6;
        iVar3 = strcmp((char *)*codeset,(char *)puVar6);
        if (iVar3 != 0) {
          local_2d = *puVar5;
          bVar1 = true;
          uVar2 = 0x38;
          goto LAB_080b0fc0;
        }
        free(puVar6);
        local_2d = *puVar5;
        puVar6 = puVar5;
      }
      uVar2 = 0x30;
      bVar1 = true;
      puVar5 = puVar6;
    }
  }
LAB_080b0fc0:
  if (local_2d == '@') {
    *puVar5 = '\0';
    uVar2 = uVar2 | 0xc0;
    *modifier = puVar5 + 1;
  }
  else if (!bVar1) {
    local_20 = 0;
    puVar6 = puVar5;
    uVar4 = local_2d;
    if (local_2d == '+') {
      *puVar5 = '\0';
      puVar6 = puVar5 + 1;
      *modifier = puVar6;
      uVar4 = *puVar6;
      if ((((uVar4 == '\0') || (uVar4 == '+')) || (uVar4 == ',')) || (uVar4 == '_')) {
        uVar2 = uVar2 | 0xc0;
        local_20 = 2;
      }
      else {
        for (puVar6 = puVar5 + 2; uVar4 = *puVar6, uVar4 != '\0'; puVar6 = puVar6 + 1) {
          if (uVar4 == '+') goto LAB_080b11d9;
          if (uVar4 == ',') {
            local_2d = ',';
            goto LAB_080b11d9;
          }
          if (uVar4 == '_') {
            local_2d = '_';
            goto LAB_080b11d9;
          }
        }
        local_2d = '\0';
LAB_080b11d9:
        uVar2 = uVar2 | 0xc0;
        local_20 = 2;
        uVar4 = local_2d;
      }
    }
    if (((byte)(uVar4 - 0x2b) < 2) || (uVar4 == '_')) {
      if (uVar4 == '+') {
        *puVar6 = '\0';
        puVar6 = puVar6 + 1;
        *special = puVar6;
        uVar4 = *puVar6;
        if ((uVar4 != '\0') && (uVar4 != ',')) {
          while (uVar4 != '_') {
            puVar6 = puVar6 + 1;
            uVar4 = *puVar6;
            if ((uVar4 == ',') || (uVar4 == '\0')) break;
          }
        }
        uVar2 = uVar2 | 4;
      }
      if (uVar4 == ',') {
        *puVar6 = '\0';
        puVar6 = puVar6 + 1;
        *sponsor = puVar6;
        uVar4 = *puVar6;
        if ((uVar4 != '\0') && (uVar4 != '_')) {
          do {
            puVar6 = puVar6 + 1;
            uVar4 = *puVar6;
            if (uVar4 == '_') break;
          } while (uVar4 != '\0');
        }
        uVar2 = uVar2 | 2;
      }
      if (uVar4 != '_') {
        return uVar2;
      }
      *puVar6 = '\0';
      *revision = puVar6 + 1;
      return uVar2 | 1;
    }
    if (local_20 != 1) {
      return uVar2;
    }
  }
LAB_080b1028:
  if ((*territory != (uchar *)0x0) && (**territory == '\0')) {
    uVar2 = uVar2 & 0xffffffdf;
  }
  if ((*codeset != (uchar *)0x0) && (**codeset == '\0')) {
    uVar2 = uVar2 & 0xffffffef;
  }
  if (*modifier == (uchar *)0x0) {
    return uVar2;
  }
  if (**modifier == '\0') {
    uVar2 = uVar2 & 0xffffff7f;
  }
  return uVar2;
}



// WARNING: Unknown calling convention

loaded_l10nfile *
_nl_find_domain(uchar *dirname,uchar *locale,uchar *domainname,binding *domainbinding)

{
  void *pvVar1;
  size_t sVar2;
  loaded_l10nfile *domain_file;
  loaded_l10nfile *retval;
  loaded_l10nfile *plVar3;
  uchar *puVar4;
  uint mask;
  uchar *alias_value;
  int cnt;
  int iVar5;
  int iVar6;
  loaded_l10nfile *plVar7;
  uchar *local_3c;
  uchar *local_38;
  uchar *local_34;
  uchar *local_30;
  uchar *local_2c;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  sVar2 = strlen((char *)dirname);
  domain_file = _nl_make_l10nflist(&_nl_loaded_domains,dirname,sVar2 + 1,0,locale,(uchar *)0x0,
                                   (uchar *)0x0,(uchar *)0x0,(uchar *)0x0,(uchar *)0x0,(uchar *)0x0,
                                   (uchar *)0x0,domainname,0);
  if (domain_file == (loaded_l10nfile *)0x0) {
    puVar4 = _nl_expand_alias(locale);
    if ((puVar4 == (uchar *)0x0) || (locale = (uchar *)__strdup(puVar4), locale != (uchar *)0x0)) {
      mask = _nl_explode_name(locale,local_20,&local_24,&local_28,&local_2c,&local_30,&local_34,
                              &local_38,&local_3c);
      sVar2 = strlen((char *)dirname);
      domain_file = _nl_make_l10nflist(&_nl_loaded_domains,dirname,sVar2 + 1,mask,local_20[0],
                                       local_28,local_2c,local_30,local_24,local_34,local_38,
                                       local_3c,domainname,1);
      if (domain_file != (loaded_l10nfile *)0x0) {
        if (domain_file->decided == 0) {
          _nl_load_domain(domain_file,domainbinding);
        }
        if (domain_file->data == (void *)0x0) {
          plVar7 = domain_file;
          for (plVar3 = domain_file->successor[0]; plVar3 != (loaded_l10nfile *)0x0;
              plVar3 = (loaded_l10nfile *)plVar3->filename) {
            if (plVar3->decided == 0) {
              _nl_load_domain(plVar3,domainbinding);
            }
            if (plVar7->successor[0]->data != (void *)0x0) break;
            plVar3 = plVar7 + 1;
            plVar7 = (loaded_l10nfile *)&plVar7->langdirname;
          }
        }
        if (puVar4 != (uchar *)0x0) {
          free(locale);
        }
        if ((mask & 8) != 0) {
          free(local_30);
        }
      }
    }
  }
  else {
    if (domain_file->decided == 0) {
      _nl_load_domain(domain_file,domainbinding);
      pvVar1 = domain_file->data;
    }
    else {
      pvVar1 = domain_file->data;
    }
    if ((pvVar1 == (void *)0x0) &&
       (plVar3 = domain_file->successor[0], plVar3 != (loaded_l10nfile *)0x0)) {
      iVar6 = 0;
      do {
        if (plVar3->decided == 0) {
          _nl_load_domain(plVar3,domainbinding);
        }
        iVar5 = iVar6;
        if (domain_file->successor[iVar6]->data != (void *)0x0) break;
        iVar5 = iVar6 + 1;
        plVar3 = domain_file[1].successor[iVar6 + -6];
        iVar6 = iVar5;
      } while (plVar3 != (loaded_l10nfile *)0x0);
      if (iVar5 < 0) {
        domain_file = (loaded_l10nfile *)0x0;
      }
      return domain_file;
    }
  }
  return domain_file;
}



// WARNING: Unknown calling convention

uchar * gettext__(uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = dcgettext__((uchar *)0x0,msgid,5);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * bind_textdomain_codeset(uchar *domainname,uchar *codeset)

{
  uchar *puVar1;
  
  puVar1 = bind_textdomain_codeset__(domainname,codeset);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * bindtextdomain(uchar *domainname,uchar *dirname)

{
  uchar *puVar1;
  
  puVar1 = bindtextdomain__(domainname,dirname);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * textdomain(uchar *domainname)

{
  uchar *puVar1;
  
  puVar1 = textdomain__(domainname);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * dcngettext(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n,int category)

{
  uchar *puVar1;
  
  puVar1 = dcngettext__(domainname,msgid1,msgid2,n,category);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * dngettext(uchar *domainname,uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = dngettext__(domainname,msgid1,msgid2,n);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * ngettext(uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = ngettext__(msgid1,msgid2,n);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * dcgettext(uchar *domainname,uchar *msgid,int category)

{
  uchar *puVar1;
  
  puVar1 = dcgettext__(domainname,msgid,category);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * dgettext(uchar *domainname,uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = dgettext__(domainname,msgid);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * gettext(uchar *msgid)

{
  uchar *puVar1;
  
  puVar1 = gettext__(msgid);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * _nl_normalize_codeset(uchar *codeset,size_t name_len)

{
  byte bVar1;
  bool bVar2;
  ushort **ppuVar3;
  uint uVar4;
  size_t cnt;
  undefined4 *puVar5;
  size_t __size;
  int iVar6;
  int len;
  uchar *wp;
  int only_digit;
  undefined4 *puVar7;
  
  __size = 4;
  if (name_len != 0) {
    ppuVar3 = __ctype_b_loc();
    bVar2 = true;
    iVar6 = 0;
    uVar4 = 0;
    do {
      if ((((*ppuVar3)[codeset[uVar4]] & 8) != 0) &&
         (iVar6 = iVar6 + 1, ((*ppuVar3)[codeset[uVar4]] & 0x400) != 0)) {
        bVar2 = false;
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < name_len);
    if (!bVar2) {
      __size = iVar6 + 1;
      goto LAB_080b16be;
    }
    __size = iVar6 + 4;
  }
  bVar2 = true;
LAB_080b16be:
  puVar5 = (undefined4 *)malloc(__size);
  if (puVar5 != (undefined4 *)0x0) {
    puVar7 = puVar5;
    if (bVar2) {
      *puVar5 = 0x6f7369;
      puVar7 = (undefined4 *)((int)puVar5 + 3);
    }
    if (name_len != 0) {
      uVar4 = 0;
      ppuVar3 = __ctype_b_loc();
      do {
        while( true ) {
          bVar1 = codeset[uVar4];
          if ((*(byte *)((int)*ppuVar3 + (uint)bVar1 * 2 + 1) & 4) == 0) break;
          uVar4 = uVar4 + 1;
          iVar6 = c_tolower((uint)bVar1);
          *(char *)puVar7 = (char)iVar6;
          puVar7 = (undefined4 *)((int)puVar7 + 1);
          if (name_len <= uVar4) goto LAB_080b1737;
        }
        if ((byte)(bVar1 - 0x30) < 10) {
          *(byte *)puVar7 = bVar1;
          puVar7 = (undefined4 *)((int)puVar7 + 1);
        }
        uVar4 = uVar4 + 1;
      } while (uVar4 < name_len);
    }
LAB_080b1737:
    *(undefined *)puVar7 = 0;
  }
  return (uchar *)puVar5;
}



// WARNING: Removing unreachable block (ram,0x080b1cac)
// WARNING: Unknown calling convention

loaded_l10nfile *
_nl_make_l10nflist(loaded_l10nfile **l10nfile_list,uchar *dirlist,size_t dirlist_len,int mask,
                  uchar *language,uchar *territory,uchar *codeset,uchar *normalized_codeset,
                  uchar *modifier,uchar *special,uchar *sponsor,uchar *revision,uchar *filename,
                  int do_allocate)

{
  size_t sVar1;
  size_t sVar2;
  uchar *puVar3;
  uchar *cp;
  uchar *__dest;
  int compare;
  loaded_l10nfile *plVar4;
  size_t entries;
  uint uVar5;
  int iVar6;
  loaded_l10nfile *plVar7;
  loaded_l10nfile *retval;
  int iVar8;
  uchar *dir;
  int iVar9;
  loaded_l10nfile *last;
  int cnt;
  loaded_l10nfile *plVar10;
  loaded_l10nfile **pplVar11;
  int local_2c;
  int local_28;
  int local_24;
  char *local_20;
  
  sVar1 = strlen((char *)language);
  if ((mask & 0x20U) == 0) {
    local_2c = 0;
  }
  else {
    sVar2 = strlen((char *)territory);
    local_2c = sVar2 + 1;
  }
  if ((mask & 0x10U) == 0) {
    local_28 = 0;
  }
  else {
    sVar2 = strlen((char *)codeset);
    local_28 = sVar2 + 1;
  }
  if ((mask & 8U) == 0) {
    local_24 = 0;
  }
  else {
    sVar2 = strlen((char *)normalized_codeset);
    local_24 = sVar2 + 1;
  }
  iVar9 = 0;
  if ((mask & 0xc0U) != 0) {
    sVar2 = strlen((char *)modifier);
    iVar9 = sVar2 + 1;
  }
  if ((mask & 4U) == 0) {
    local_20 = (char *)0x0;
  }
  else {
    sVar2 = strlen((char *)special);
    local_20 = (char *)(sVar2 + 1);
  }
  iVar8 = 0;
  if ((mask & 3U) != 0) {
    iVar6 = 1;
    if ((mask & 2U) != 0) {
      sVar2 = strlen((char *)sponsor);
      iVar6 = sVar2 + 2;
    }
    iVar8 = 0;
    if ((mask & 1U) != 0) {
      sVar2 = strlen((char *)revision);
      iVar8 = sVar2 + 1;
    }
    iVar8 = iVar8 + iVar6;
  }
  sVar2 = strlen((char *)filename);
  puVar3 = (uchar *)malloc(dirlist_len + 2 + sVar1 + local_2c + local_28 + local_24 + iVar9 +
                           (int)local_20 + iVar8 + sVar2);
  plVar7 = (loaded_l10nfile *)0x0;
  if (puVar3 != (uchar *)0x0) {
    memcpy(puVar3,dirlist,dirlist_len);
    __argz_stringify(puVar3,dirlist_len,0x3a);
    puVar3[dirlist_len - 1] = '/';
    __dest = puVar3 + (dirlist_len - 1) + 1;
    local_20 = stpcpy((char *)__dest,(char *)language);
    if ((mask & 0x20U) != 0) {
      *local_20 = '_';
      local_20 = stpcpy(local_20 + 1,(char *)territory);
    }
    if ((mask & 0x10U) != 0) {
      *local_20 = '.';
      local_20 = stpcpy(local_20 + 1,(char *)codeset);
    }
    if ((mask & 8U) != 0) {
      *local_20 = '.';
      local_20 = stpcpy(local_20 + 1,(char *)normalized_codeset);
    }
    if ((mask & 0xc0U) != 0) {
      *local_20 = (-((mask & 0x40U) == 0) & 0x15U) + 0x2b;
      local_20 = stpcpy(local_20 + 1,(char *)modifier);
    }
    if ((mask & 4U) != 0) {
      *local_20 = '+';
      local_20 = stpcpy(local_20 + 1,(char *)special);
    }
    if ((mask & 3U) != 0) {
      *local_20 = ',';
      local_20 = local_20 + 1;
      if ((mask & 2U) != 0) {
        local_20 = stpcpy(local_20,(char *)sponsor);
      }
      if ((mask & 1U) != 0) {
        *local_20 = '_';
        local_20 = stpcpy(local_20 + 1,(char *)revision);
      }
    }
    *local_20 = '/';
    strcpy(local_20 + 1,(char *)filename);
    plVar7 = *l10nfile_list;
    plVar4 = plVar7;
    if (plVar7 != (loaded_l10nfile *)0x0) {
      plVar10 = (loaded_l10nfile *)0x0;
      do {
        plVar4 = plVar10;
        if (plVar7->filename != (uchar *)0x0) {
          iVar9 = strcmp((char *)plVar7->filename,(char *)puVar3);
          if (iVar9 == 0) {
            free(puVar3);
            return plVar7;
          }
          plVar4 = plVar7;
          if (iVar9 < 0) {
            plVar7 = (loaded_l10nfile *)0x0;
            plVar4 = plVar10;
            break;
          }
        }
        plVar7 = plVar7->next;
        plVar10 = plVar4;
      } while (plVar7 != (loaded_l10nfile *)0x0);
    }
    if (do_allocate == 0) {
      free(puVar3);
    }
    else {
      iVar9 = __argz_count(dirlist,dirlist_len);
      uVar5 = ((int)(mask & 0xffffaaaaU) >> 1) + (mask & 0x5555U);
      iVar8 = ((int)(uVar5 & 0xffffcccc) >> 2) + (uVar5 & 0x3333);
      uVar5 = (iVar8 >> 4) + iVar8 & 0xf0f;
      plVar7 = (loaded_l10nfile *)malloc((iVar9 << (char)(uVar5 >> 8) + (char)uVar5) * 4 + 0x1c);
      if (plVar7 != (loaded_l10nfile *)0x0) {
        plVar7->filename = puVar3;
        plVar7->langdirname = __dest;
        plVar7->langdirnamelen = (int)(local_20 + -(int)__dest);
        iVar9 = __argz_count(dirlist,dirlist_len);
        uVar5 = 1;
        if (iVar9 == 1) {
          uVar5 = (uint)((mask & 0x18U) == 0x18);
        }
        plVar7->decided = uVar5;
        plVar7->data = (void *)0x0;
        if (plVar4 == (loaded_l10nfile *)0x0) {
          plVar7->next = *l10nfile_list;
          *l10nfile_list = plVar7;
        }
        else {
          plVar7->next = plVar4->next;
          plVar4->next = plVar7;
        }
        iVar9 = __argz_count(dirlist,dirlist_len);
        uVar5 = mask - 1;
        if (iVar9 != 1) {
          uVar5 = mask;
        }
        iVar9 = 0;
        if (-1 < (int)uVar5) {
          do {
            if (((~mask & uVar5) == 0) &&
               ((((uVar5 & 0x47) == 0 || ((uVar5 & 0x98) == 0)) &&
                (pplVar11 = plVar7->successor + iVar9, (uVar5 & 0x18) != 0x18)))) {
              while (puVar3 = dirlist, dirlist_len != 0) {
                while( true ) {
                  if (puVar3 == (uchar *)0x0) goto LAB_080b1c6d;
                  iVar9 = iVar9 + 1;
                  sVar1 = strlen((char *)puVar3);
                  plVar4 = _nl_make_l10nflist(l10nfile_list,puVar3,sVar1 + 1,uVar5,language,
                                              territory,codeset,normalized_codeset,modifier,special,
                                              sponsor,revision,filename,1);
                  *pplVar11 = plVar4;
                  pplVar11 = pplVar11 + 1;
                  if (puVar3 == (uchar *)0x0) break;
                  if (dirlist + dirlist_len <= puVar3) goto LAB_080b1c6d;
                  iVar8 = __rawmemchr(puVar3,0);
                  puVar3 = (uchar *)(iVar8 + 1U);
                  if (dirlist + dirlist_len <= (uchar *)(iVar8 + 1U)) goto LAB_080b1c6d;
                }
              }
            }
LAB_080b1c6d:
            uVar5 = uVar5 - 1;
          } while (-1 < (int)uVar5);
        }
        plVar7->successor[iVar9] = (loaded_l10nfile *)0x0;
      }
    }
  }
  return plVar7;
}



// WARNING: Unknown calling convention

uchar * language_to_name(int language)

{
  return languages[language].name;
}



// WARNING: Unknown calling convention

int name_to_language(uchar *name)

{
  uchar *s1;
  int iVar1;
  int i;
  
  if (languages[0].name != (uchar *)0x0) {
    i = 0;
    s1 = languages[0].name;
    do {
      iVar1 = c_strcasecmp((char *)s1,(char *)name);
      if (iVar1 == 0) {
        return i;
      }
      i = i + 1;
      s1 = languages[i].name;
    } while (s1 != (uchar *)0x0);
  }
  return 1;
}



// WARNING: Unknown calling convention

int iso639_to_language(uchar *iso639)

{
  uchar *puVar1;
  uchar *__s;
  uchar *l;
  char *pcVar2;
  uchar *p;
  int iVar3;
  size_t sVar4;
  size_t __n;
  size_t __result;
  int i;
  int iVar5;
  int ll;
  
  __s = stracpy(iso639);
  if (__s == (uchar *)0x0) {
    return 1;
  }
  pcVar2 = strchr((char *)__s,0x2e);
  if (pcVar2 != (char *)0x0) {
    *pcVar2 = '\0';
  }
  pcVar2 = strchr((char *)__s,0x5f);
  if (pcVar2 == (char *)0x0) {
    pcVar2 = strchr((char *)__s,0x2d);
  }
  else {
    *pcVar2 = '-';
  }
  puVar1 = languages[0].name;
  if (languages[0].name != (uchar *)0x0) {
    iVar5 = 0;
    do {
      iVar3 = strcmp((char *)languages[iVar5].iso639,(char *)__s);
      if (iVar3 == 0) goto LAB_080b1f78;
      iVar5 = iVar5 + 1;
    } while (languages[iVar5].name != (uchar *)0x0);
  }
  if (pcVar2 == (char *)0x0) {
    sVar4 = strlen((char *)__s);
    if (puVar1 == (uchar *)0x0) goto LAB_080b1f57;
  }
  else {
    *pcVar2 = '\0';
    if (languages[0].name == (uchar *)0x0) goto LAB_080b1f57;
    iVar5 = 0;
    do {
      iVar3 = strcmp((char *)languages[iVar5].iso639,(char *)__s);
      if (iVar3 == 0) goto LAB_080b1f78;
      iVar5 = iVar5 + 1;
    } while (languages[iVar5].name != (uchar *)0x0);
    sVar4 = strlen((char *)__s);
  }
  iVar5 = 0;
  do {
    puVar1 = languages[iVar5].iso639;
    if ((*puVar1 == '\0') || (*puVar1 == '-')) {
      __n = 0;
    }
    else {
      __n = 0;
      do {
        __n = __n + 1;
        if (puVar1[__n] == '\0') break;
      } while (puVar1[__n] != '-');
    }
    if ((int)sVar4 < (int)__n) {
      __n = sVar4;
    }
    iVar3 = strncmp((char *)puVar1,(char *)__s,__n);
    if (iVar3 == 0) {
LAB_080b1f78:
      mem_free(__s);
      return iVar5;
    }
    iVar5 = iVar5 + 1;
  } while (languages[iVar5].name != (uchar *)0x0);
LAB_080b1f57:
  mem_free(__s);
  return 1;
}



// WARNING: Unknown calling convention

int get_system_language_index(void)

{
  uchar *iso639;
  uchar *l;
  int iVar1;
  
  iso639 = (uchar *)getenv("LANGUAGE");
  if (iso639 == (uchar *)0x0) {
    iso639 = (uchar *)getenv("LC_ALL");
    if (iso639 == (uchar *)0x0) {
      iso639 = (uchar *)getenv("LC_MESSAGES");
      if (iso639 == (uchar *)0x0) {
        iso639 = (uchar *)getenv("LANG");
        if (iso639 == (uchar *)0x0) {
          return 1;
        }
      }
    }
  }
  iVar1 = iso639_to_language(iso639);
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * language_to_iso639(int language)

{
  int iVar1;
  
  if ((language == 0) && (language = system_language, system_language == 0)) {
    iVar1 = get_system_language_index();
    return languages[iVar1].iso639;
  }
  return languages[language].iso639;
}



// WARNING: Unknown calling convention

void set_language(int language)

{
  uchar *__src;
  char *pcVar1;
  
  if (system_language == 0) {
    system_language = get_system_language_index();
  }
  if (language != current_language) {
    current_language = language;
    if (language == 0) {
      language = system_language;
    }
    if (LANGUAGE == (uchar *)0x0) {
      LANGUAGE = (uchar *)malloc(0x100);
    }
    __src = language_to_iso639(language);
    strcpy((char *)LANGUAGE,(char *)__src);
    pcVar1 = strchr((char *)LANGUAGE,0x2d);
    if (pcVar1 != (char *)0x0) {
      *pcVar1 = '_';
    }
    _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
  }
  return;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Unknown calling convention

void _nl_free_domain_conv(loaded_domain *domain)

{
  iconv_t __cd;
  
  if ((int)domain->conv_tab - 1U < 0xfffffffe) {
    free(domain->conv_tab);
    __cd = domain->conv;
  }
  else {
    __cd = domain->conv;
  }
  if (__cd != (iconv_t)0xffffffff) {
    iconv_close(__cd);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * _nl_init_domain_conv
                  (loaded_l10nfile *domain_file,loaded_domain *domain,binding *domainbinding)

{
  char cVar1;
  int iVar2;
  uchar *__haystack;
  char *pcVar3;
  char *__fromcode;
  undefined *puVar4;
  uchar *outcharset;
  iconv_t pvVar5;
  uchar *__tocode;
  size_t size;
  uchar *charsetstr;
  size_t len;
  size_t __n;
  size_t nullentrylen;
  size_t sVar6;
  
  iVar2 = 0;
  if (domainbinding != (binding *)0x0) {
    iVar2 = domainbinding->codeset_cntr;
  }
  domain->codeset_cntr = iVar2;
  domain->conv = (iconv_t)0xffffffff;
  domain->conv_tab = (uchar **)0x0;
  __haystack = _nl_find_msg(domain_file,domainbinding,"",&nullentrylen);
  if (__haystack != (uchar *)0x0) {
    pcVar3 = strstr((char *)__haystack,"charset=");
    if (pcVar3 != (char *)0x0) {
      cVar1 = pcVar3[8];
      if ((((cVar1 == '\0') || (cVar1 == ' ')) || (cVar1 == '\t')) || (cVar1 == '\n')) {
        size = 1;
        __n = 0;
      }
      else {
        __n = 0;
        while( true ) {
          sVar6 = __n;
          __n = sVar6 + 1;
          cVar1 = pcVar3[sVar6 + 9];
          if ((cVar1 == '\0') || (cVar1 == ' ')) break;
          if ((cVar1 == '\t') || (cVar1 == '\n')) break;
        }
        size = sVar6 + 2;
      }
      __fromcode = (char *)mem_alloc(size);
      puVar4 = (undefined *)mempcpy(__fromcode,pcVar3 + 8,__n);
      *puVar4 = 0;
      if ((domainbinding == (binding *)0x0) ||
         (__tocode = domainbinding->codeset, __tocode == (uchar *)0x0)) {
        __tocode = (uchar *)getenv("OUTPUT_CHARSET");
        if ((__tocode == (uchar *)0x0) || (*__tocode == '\0')) {
          __tocode = elinks_locale_charset();
        }
      }
      pvVar5 = iconv_open((char *)__tocode,__fromcode);
      domain->conv = pvVar5;
      mem_free(__fromcode);
    }
  }
  return __haystack;
}



// WARNING: Unknown calling convention

void _nl_load_domain(loaded_l10nfile *domain_file,binding *domainbinding)

{
  string *psVar1;
  char *pcVar2;
  int iVar3;
  int iVar4;
  long __result;
  int *__ptr;
  loaded_domain *domain;
  uint uVar5;
  uchar *puVar6;
  uchar *nullentry;
  char *pcVar7;
  ushort **ppuVar8;
  ssize_t sVar9;
  int *piVar10;
  ulong n;
  int use_mmap;
  ulong uVar11;
  uchar *endp;
  int fd;
  uchar *puVar12;
  mo_file_header *data;
  uchar *nplurals;
  uchar *puVar13;
  byte *pbVar14;
  bool bVar15;
  byte bVar16;
  int *local_98;
  size_t local_94;
  uint local_90;
  stat st;
  string filename;
  
  bVar16 = 0;
  domain_file->decided = 1;
  domain_file->data = (void *)0x0;
  psVar1 = init_string(&filename);
  puVar6 = program.path;
  if ((psVar1 == (string *)0x0) ||
     (pcVar2 = strrchr((char *)program.path,0x2f), pcVar2 == (char *)0x0)) {
LAB_080b245c:
    done_string(&filename);
  }
  else {
    pcVar2 = pcVar2 + (1 - (int)puVar6);
    bVar15 = pcVar2 == (char *)0x3;
    if (pcVar2 < (char *)0x4) goto LAB_080b245c;
    iVar3 = 3;
    puVar12 = puVar6 + (int)(pcVar2 + -4);
    puVar13 = "src";
    do {
      if (iVar3 == 0) break;
      iVar3 = iVar3 + -1;
      bVar15 = *puVar12 == *puVar13;
      puVar12 = puVar12 + (uint)bVar16 * -2 + 1;
      puVar13 = puVar13 + (uint)bVar16 * -2 + 1;
    } while (bVar15);
    if ((((!bVar15) ||
         (psVar1 = add_bytes_to_string__(&filename,puVar6,(int)pcVar2), psVar1 == (string *)0x0)) ||
        (psVar1 = add_to_string(&filename,"../po/"), psVar1 == (string *)0x0)) ||
       ((psVar1 = add_bytes_to_string__
                            (&filename,domain_file->langdirname,domain_file->langdirnamelen),
        psVar1 == (string *)0x0 ||
        (psVar1 = add_to_string(&filename,".gmo"), psVar1 == (string *)0x0)))) goto LAB_080b245c;
    iVar3 = open64((char *)filename.source,0);
    done_string(&filename);
    if (iVar3 != -1) goto source_success;
  }
  if (domain_file->filename == (uchar *)0x0) {
    return;
  }
  iVar3 = open64((char *)domain_file->filename,0);
  if (iVar3 == -1) {
    return;
  }
source_success:
  iVar4 = __fxstat64(3,iVar3,(stat64 *)&st);
  if (((iVar4 == 0) && (st.st_size._4_4_ == 0)) && (0x1b < (uint)st.st_size)) {
    __ptr = (int *)mmap64((void *)0x0,(uint)st.st_size,1,2,iVar3,0);
    if (__ptr != (int *)0xffffffff) {
      close(iVar3);
      use_mmap = 1;
LAB_080b251b:
      if ((*__ptr != -0x21edfb6b) && (*__ptr != -0x6afbed22)) {
        if (use_mmap != 0) {
          munmap(__ptr,(uint)st.st_size);
          return;
        }
        free(__ptr);
        return;
      }
      domain = (loaded_domain *)malloc(0x38);
      if (domain == (loaded_domain *)0x0) {
        return;
      }
      domain_file->data = domain;
      domain->data = (uchar *)__ptr;
      domain->use_mmap = use_mmap;
      domain->mmap_size = (uint)st.st_size;
      uVar5 = (uint)(*__ptr != -0x6afbed22);
      domain->must_swap = uVar5;
      if (uVar5 == 0) {
        local_90 = __ptr[1];
      }
      else {
        local_90 = (uint)__ptr[1] >> 0x18 | __ptr[1] << 0x18 | (__ptr[1] & 0xff00U) << 8 |
                   (uint)__ptr[1] >> 8 & 0xff00;
      }
      if (local_90 == 0) {
        if (uVar5 == 0) {
          domain->nstrings = __ptr[2];
          domain->orig_tab = (string_desc *)(__ptr[3] + (int)__ptr);
          domain->trans_tab = (string_desc *)(__ptr[4] + (int)__ptr);
          domain->hash_size = __ptr[5];
          uVar5 = __ptr[6];
        }
        else {
          uVar5 = __ptr[2];
          domain->nstrings =
               uVar5 >> 0x18 | uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | uVar5 >> 8 & 0xff00;
          uVar5 = __ptr[3];
          domain->orig_tab =
               (string_desc *)
               ((int)__ptr +
               (uVar5 >> 0x18 | uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | uVar5 >> 8 & 0xff00));
          uVar5 = __ptr[4];
          domain->trans_tab =
               (string_desc *)
               ((int)__ptr +
               (uVar5 >> 0x18 | uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | uVar5 >> 8 & 0xff00));
          uVar5 = __ptr[5];
          domain->hash_size =
               uVar5 >> 0x18 | uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | uVar5 >> 8 & 0xff00;
          uVar5 = __ptr[6];
          uVar5 = uVar5 >> 0x18 | uVar5 << 0x18 | (uVar5 & 0xff00) << 8 | uVar5 >> 8 & 0xff00;
        }
        domain->hash_tab = (nls_uint32 *)((int)__ptr + uVar5);
        puVar6 = _nl_init_domain_conv(domain_file,domain,domainbinding);
        if (puVar6 != (uchar *)0x0) {
          pcVar2 = strstr((char *)puVar6,"plural=");
          pcVar7 = strstr((char *)puVar6,"nplurals=");
          if ((pcVar7 != (char *)0x0) && (pcVar2 != (char *)0x0)) {
            pbVar14 = (byte *)(pcVar7 + 9);
            ppuVar8 = __ctype_b_loc();
            while (bVar16 = *pbVar14, (*(byte *)((int)*ppuVar8 + (uint)bVar16 * 2 + 1) & 0x20) != 0)
            {
              pbVar14 = pbVar14 + 1;
            }
            if ((byte)(bVar16 - 0x30) < 10) {
              uVar11 = 0;
              local_98 = (int *)pbVar14;
              do {
                local_98 = (int *)((int)local_98 + 1);
                uVar11 = (bVar16 - 0x30) + uVar11 * 10;
                bVar16 = *(byte *)local_98;
              } while ((byte)(bVar16 - 0x30) < 10);
              domain->nplurals = uVar11;
              if ((int *)pbVar14 != local_98) {
                filename.source = (uchar *)(pcVar2 + 7);
                iVar3 = gettext__parse(&filename);
                if (iVar3 == 0) {
                  domain->plural = (expression *)filename.length;
                  return;
                }
              }
            }
            else {
              domain->nplurals = 0;
            }
          }
        }
        if (plone.val.num == 0) {
          plvar.nargs = 0;
          plvar.operation = var;
          plone.nargs = 0;
          plone.operation = num;
          plone.val.num = 1;
          germanic_plural.nargs = 2;
          germanic_plural.operation = not_equal;
          germanic_plural.val.args[0] = &plvar;
          germanic_plural.val.args[1] = &plone;
        }
        domain->plural = &germanic_plural;
        domain->nplurals = 2;
        return;
      }
      if (use_mmap == 0) {
        free(__ptr);
      }
      else {
        munmap(__ptr,(uint)st.st_size);
      }
      free(domain);
      domain_file->data = (void *)0x0;
      return;
    }
    __ptr = (int *)malloc((uint)st.st_size);
    if (__ptr == (int *)0x0) {
      return;
    }
    local_94 = (uint)st.st_size;
    local_98 = __ptr;
    do {
      while (sVar9 = read(iVar3,local_98,local_94), sVar9 != -1) {
        if (sVar9 < 1) goto LAB_080b24a9;
        local_94 = local_94 - sVar9;
        if (local_94 == 0) {
          close(iVar3);
          use_mmap = 0;
          goto LAB_080b251b;
        }
        local_98 = (int *)((int)local_98 + sVar9);
      }
      piVar10 = __errno_location();
    } while (*piVar10 == 4);
  }
LAB_080b24a9:
  close(iVar3);
  return;
}



// WARNING: Unknown calling convention

uchar * elinks_locale_charset(void)

{
  int iVar1;
  uchar uVar2;
  uchar *__s1;
  uchar *codeset;
  size_t sVar3;
  int iVar4;
  size_t sVar5;
  undefined4 *__filename;
  FILE *__fp;
  int c;
  uchar *puVar6;
  uchar *aliases;
  FILE *fp;
  int in_GS_OFFSET;
  int local_90;
  uchar buf2 [51];
  uchar buf1 [51];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __s1 = (uchar *)nl_langinfo(0xe);
  puVar6 = charset_aliases;
  if (__s1 == (uchar *)0x0) {
    __s1 = "";
  }
  if (charset_aliases == (uchar *)0x0) {
    __filename = (undefined4 *)malloc(0x17);
    if (__filename == (undefined4 *)0x0) {
      charset_aliases = "";
    }
    else {
      *__filename = 0x7273752f;
      __filename[1] = 0x62696c2f;
      *(undefined *)(__filename + 2) = 0x2f;
      *(undefined4 *)((int)__filename + 9) = 0x72616863;
      *(undefined4 *)((int)__filename + 0xd) = 0x2e746573;
      *(undefined4 *)((int)__filename + 0x11) = 0x61696c61;
      *(undefined2 *)((int)__filename + 0x15) = 0x73;
      __fp = fopen64((char *)__filename,"rb");
      if (__fp != (FILE *)0x0) {
        local_90 = 0;
LAB_080b2b60:
        while (iVar4 = _IO_getc(__fp), iVar4 != -1) {
          while (((iVar4 != 0x20 && (iVar4 != 10)) && (iVar4 != 9))) {
            if (iVar4 == 0x23) goto LAB_080b2cb8;
            ungetc(iVar4,__fp);
            iVar4 = __isoc99_fscanf(__fp,"%50s %50s",buf1,buf2);
            if (iVar4 < 2) goto LAB_080b2c78;
            sVar5 = strlen((char *)buf1);
            sVar3 = strlen((char *)buf2);
            if (local_90 == 0) {
              local_90 = sVar5 + sVar3 + 2;
              puVar6 = (uchar *)malloc(sVar5 + sVar3 + 3);
            }
            else {
              local_90 = local_90 + 2 + sVar5 + sVar3;
              puVar6 = (uchar *)realloc(puVar6,local_90 + 1);
            }
            if (puVar6 == (uchar *)0x0) {
              fclose(__fp);
              goto LAB_080b2d1b;
            }
            strcpy((char *)(puVar6 + ((local_90 - sVar3) - sVar5) + -2),(char *)buf1);
            strcpy((char *)(puVar6 + (local_90 - sVar3) + -1),(char *)buf2);
            iVar4 = _IO_getc(__fp);
            if (iVar4 == -1) goto LAB_080b2c78;
          }
        }
LAB_080b2c78:
        fclose(__fp);
        if (local_90 != 0) {
          puVar6[local_90] = '\0';
          goto LAB_080b2c98;
        }
      }
LAB_080b2d1b:
      puVar6 = "";
LAB_080b2c98:
      free(__filename);
      charset_aliases = puVar6;
    }
  }
  uVar2 = *charset_aliases;
  puVar6 = charset_aliases;
  do {
    if (uVar2 == '\0') {
LAB_080b2aa1:
      if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
        __stack_chk_fail();
      }
      return __s1;
    }
    iVar4 = strcmp((char *)__s1,(char *)puVar6);
    if ((iVar4 == 0) || ((uVar2 == '*' && (puVar6[1] == '\0')))) {
      sVar5 = strlen((char *)puVar6);
      __s1 = puVar6 + sVar5 + 1;
      goto LAB_080b2aa1;
    }
    sVar5 = strlen((char *)puVar6);
    sVar3 = strlen((char *)(puVar6 + sVar5 + 1));
    puVar6 = puVar6 + sVar5 + 1 + sVar3 + 1;
    uVar2 = *puVar6;
  } while( true );
LAB_080b2cb8:
  iVar4 = _IO_getc(__fp);
  if (iVar4 == 10) goto LAB_080b2b60;
  if (iVar4 == -1) goto LAB_080b2c78;
  goto LAB_080b2cb8;
}



// WARNING: Unknown calling convention

size_t read_alias_file(uchar *fname,int fname_len)

{
  int iVar1;
  byte bVar2;
  byte bVar3;
  char *pcVar4;
  undefined4 *puVar5;
  FILE *__stream;
  ushort **ppuVar6;
  size_t sVar7;
  alias_map *paVar8;
  size_t sVar9;
  size_t __size;
  uchar *puVar11;
  size_t i;
  byte *pbVar12;
  ushort *puVar13;
  size_t new_size;
  uint uVar14;
  size_t sVar15;
  byte *__s;
  uchar *cp;
  byte *__s_00;
  FILE *fp;
  int in_GS_OFFSET;
  size_t local_4034;
  size_t local_4030;
  uchar altbuf [8192];
  uchar buf [8192];
  uint uVar10;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar4 = (char *)mem_alloc(fname_len + 0xe);
  puVar5 = (undefined4 *)mempcpy(pcVar4,fname,fname_len);
  *puVar5 = 0x636f6c2f;
  puVar5[1] = 0x2e656c61;
  puVar5[2] = 0x61696c61;
  *(undefined2 *)(puVar5 + 3) = 0x73;
  __stream = fopen64(pcVar4,"rb");
  mem_free(pcVar4);
  local_4034 = 0;
  if (__stream != (FILE *)0x0) {
    while (((*(byte *)&__stream->_flags & 0x10) == 0 &&
           (pcVar4 = fgets_unlocked((char *)buf,0x2000,__stream), pcVar4 != (char *)0x0))) {
      pcVar4 = strchr((char *)buf,10);
      while ((pcVar4 == (char *)0x0 &&
             (pcVar4 = fgets_unlocked((char *)altbuf,0x2000,__stream), pcVar4 != (char *)0x0))) {
        pcVar4 = strchr((char *)altbuf,10);
      }
      ppuVar6 = __ctype_b_loc();
      __s = buf;
      puVar13 = *ppuVar6;
      while (bVar3 = *__s, (*(byte *)((int)puVar13 + (uint)bVar3 * 2 + 1) & 0x20) != 0) {
        __s = __s + 1;
      }
      if ((bVar3 != 0x23) && (bVar3 != 0)) {
        __s_00 = __s + 1;
        bVar3 = __s[1];
        while (bVar3 != 0) {
          if ((*(byte *)((int)puVar13 + (uint)bVar3 * 2 + 1) & 0x20) != 0) {
            *__s_00 = 0;
            __s_00 = __s_00 + 1;
            puVar13 = *ppuVar6;
            bVar3 = *__s_00;
            goto LAB_080b2e66;
          }
          __s_00 = __s_00 + 1;
          bVar3 = *__s_00;
        }
        bVar3 = 0;
LAB_080b2e66:
        while ((*(byte *)((int)puVar13 + (uint)bVar3 * 2 + 1) & 0x20) != 0) {
          __s_00 = __s_00 + 1;
          bVar3 = *__s_00;
        }
        if (bVar3 != 0) {
          pbVar12 = __s_00 + 1;
          bVar3 = __s_00[1];
          if (bVar3 != 0) {
            bVar2 = *(byte *)((int)puVar13 + (uint)bVar3 * 2 + 1);
            while ((bVar2 & 0x20) == 0) {
              pbVar12 = pbVar12 + 1;
              bVar3 = *pbVar12;
              if (bVar3 == 0) goto LAB_080b2ec6;
              bVar2 = *(byte *)((int)puVar13 + (uint)bVar3 * 2 + 1);
            }
            if (bVar3 == 10) {
              *pbVar12 = 0;
              pbVar12[1] = 10;
            }
            else {
              *pbVar12 = 0;
            }
          }
LAB_080b2ec6:
          paVar8 = map;
          sVar15 = maxmap;
          if (maxmap <= nmap) {
            if (maxmap == 0) {
              sVar7 = 800;
              sVar15 = 100;
            }
            else {
              sVar15 = maxmap * 2;
              sVar7 = maxmap << 4;
            }
            paVar8 = (alias_map *)realloc(map,sVar7);
            if (paVar8 == (alias_map *)0x0) goto LAB_080b3095;
          }
          maxmap = sVar15;
          map = paVar8;
          sVar7 = strlen((char *)__s);
          sVar7 = sVar7 + 1;
          sVar9 = strlen((char *)__s_00);
          sVar9 = sVar9 + 1;
          uVar14 = sVar9 + sVar7;
          if (string_space_max < uVar14 + string_space_act) {
            uVar10 = 0x400;
            if (0x3ff < uVar14) {
              uVar10 = uVar14;
            }
            __size = uVar10 + string_space_max;
            puVar11 = (uchar *)realloc(string_space,__size);
            local_4030 = nmap;
            paVar8 = map;
            if (puVar11 == (uchar *)0x0) goto LAB_080b3095;
            if ((string_space != puVar11) && (nmap != 0)) {
              i = 0;
              do {
                paVar8[i].alias = paVar8[i].alias + ((int)puVar11 - (int)string_space);
                paVar8[i].value = paVar8[i].value + ((int)puVar11 - (int)string_space);
                i = i + 1;
              } while (i < local_4030);
            }
            string_space = puVar11;
            string_space_max = __size;
          }
          else {
            local_4030 = nmap;
            paVar8 = map;
          }
          puVar11 = (uchar *)memcpy(string_space + string_space_act,__s,sVar7);
          paVar8[local_4030].alias = puVar11;
          sVar15 = nmap;
          paVar8 = map;
          string_space_act = sVar7 + string_space_act;
          puVar11 = (uchar *)memcpy(string_space + string_space_act,__s_00,sVar9);
          paVar8[sVar15].value = puVar11;
          string_space_act = string_space_act + sVar9;
          nmap = nmap + 1;
          local_4034 = local_4034 + 1;
        }
      }
    }
    fclose(__stream);
    if (local_4034 != 0) {
      qsort(map,nmap,8,alias_compare);
    }
  }
LAB_080b3095:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return local_4034;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

uchar * _nl_expand_alias(uchar *name)

{
  uchar uVar1;
  uchar *fname;
  size_t added;
  size_t sVar2;
  uchar *result;
  void *pvVar3;
  uchar *start;
  alias_map item;
  
LAB_080b31df:
  item.alias = name;
  if ((nmap == 0) || (pvVar3 = bsearch(&item,map,nmap,8,alias_compare), pvVar3 == (void *)0x0)) {
    uVar1 = *_nl_expand_alias::locale_alias_path;
    fname = _nl_expand_alias::locale_alias_path;
    if (uVar1 != '\0') {
joined_r0x080b3205:
      while (_nl_expand_alias::locale_alias_path = fname, uVar1 == ':') {
        uVar1 = fname[1];
        fname = fname + 1;
      }
      do {
        if (uVar1 == '\0') break;
        _nl_expand_alias::locale_alias_path = _nl_expand_alias::locale_alias_path + 1;
        uVar1 = *_nl_expand_alias::locale_alias_path;
      } while (uVar1 != ':');
      if (fname < _nl_expand_alias::locale_alias_path) {
        sVar2 = read_alias_file(fname,(int)_nl_expand_alias::locale_alias_path - (int)fname);
        if (sVar2 != 0) goto LAB_080b31df;
        uVar1 = *_nl_expand_alias::locale_alias_path;
      }
      else {
        uVar1 = *_nl_expand_alias::locale_alias_path;
      }
      fname = _nl_expand_alias::locale_alias_path;
      if (uVar1 == '\0') goto LAB_080b3266;
      goto joined_r0x080b3205;
    }
LAB_080b3266:
    result = (uchar *)0x0;
  }
  else {
    result = *(uchar **)((int)pvVar3 + 4);
  }
  return result;
}



// WARNING: Unknown calling convention

int alias_compare(alias_map *map1,alias_map *map2)

{
  int iVar1;
  
  iVar1 = c_strcasecmp((char *)map1->alias,(char *)map2->alias);
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * ngettext__(uchar *msgid1,uchar *msgid2,ulong n)

{
  uchar *puVar1;
  
  puVar1 = dcngettext__((uchar *)0x0,msgid1,msgid2,n,5);
  return puVar1;
}



// WARNING: Unknown calling convention

void gettext_free_exp__(expression *exp)

{
  int iVar1;
  
  if (exp == (expression *)0x0) {
    return;
  }
  iVar1 = exp->nargs;
  if (iVar1 != 2) {
    if (iVar1 != 3) {
      if (iVar1 != 1) {
        free(exp);
        return;
      }
      goto LAB_080b3356;
    }
    gettext_free_exp__((exp->val).args[2]);
  }
  gettext_free_exp__((exp->val).args[1]);
LAB_080b3356:
  gettext_free_exp__((exp->val).args[0]);
  free(exp);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

expression * new_exp(int nargs,operator op,expression **args)

{
  expression *peVar1;
  int iVar2;
  expression *peVar3;
  expression *newp;
  expression *peVar4;
  expression **ppeVar5;
  int i;
  int iVar6;
  int local_24;
  
  iVar6 = nargs + -1;
  if (-1 < iVar6) {
    peVar3 = args[iVar6];
    if (peVar3 != (expression *)0x0) {
      ppeVar5 = args + nargs + -2;
      iVar2 = iVar6;
      do {
        iVar2 = iVar2 + -1;
        if (iVar2 < 0) goto LAB_080b33be;
        peVar4 = *ppeVar5;
        ppeVar5 = ppeVar5 + -1;
      } while (peVar4 != (expression *)0x0);
    }
LAB_080b3418:
    local_24 = nargs + -2;
    ppeVar5 = args + local_24;
    while( true ) {
      gettext_free_exp__(peVar3);
      iVar6 = iVar6 + -1;
      if (iVar6 < 0) break;
      peVar3 = *ppeVar5;
      ppeVar5 = ppeVar5 + -1;
    }
    return (expression *)0x0;
  }
LAB_080b33be:
  peVar3 = (expression *)malloc(0x14);
  if (peVar3 == (expression *)0x0) {
    if (-1 < iVar6) {
      peVar3 = args[iVar6];
      goto LAB_080b3418;
    }
  }
  else {
    peVar3->nargs = nargs;
    peVar3->operation = op;
    if (-1 < iVar6) {
      iVar6 = 0;
      peVar4 = (expression *)(&peVar3->operation + nargs);
      ppeVar5 = args + nargs + -1;
      do {
        peVar1 = *ppeVar5;
        iVar6 = iVar6 + 1;
        ppeVar5 = ppeVar5 + -1;
        peVar4->nargs = (int)peVar1;
        peVar4 = (expression *)((int)(peVar4 + 0xffffffff) + 0x10);
      } while (iVar6 != nargs);
    }
  }
  return peVar3;
}



// WARNING: Unknown calling convention

int gettext__parse(void *arg)

{
  byte bVar1;
  expression *op;
  int iVar2;
  short *yyss;
  short *psVar3;
  YYSTYPE yyval;
  int yyresult;
  uint uVar4;
  YYSTYPE YVar5;
  YYSTYPE *yyvs;
  YYSTYPE *pYVar6;
  int yystate;
  uchar *exp;
  uint uVar7;
  int yytoken;
  byte *pbVar8;
  ulong n;
  short *yyssp;
  uint yystacksize;
  short *psVar9;
  undefined *puVar10;
  undefined *puVar11;
  YYSTYPE *yyvsp;
  int iVar12;
  YYSTYPE *pYVar13;
  byte *pbVar14;
  short *psVar15;
  int in_GS_OFFSET;
  undefined auStack_52c [31];
  byte local_50d;
  YYSTYPE *local_504;
  YYSTYPE local_500;
  byte **local_4fc;
  int local_4f8;
  int local_4f4;
  uint local_4f0;
  uint local_4ec;
  uint local_4e8;
  YYSTYPE *local_4e4;
  uint local_4e0;
  YYSTYPE yyvsa [200];
  short yyssa [200];
  expression *args [2];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  psVar3 = yyssa;
  pYVar13 = yyvsa;
  local_4f8 = 0;
  local_4fc = (byte **)arg;
  local_4e0 = 0;
  local_4f0 = 0xfffffffe;
  local_4e8 = 200;
  local_4f4 = 199;
  pYVar6 = pYVar13;
  psVar9 = psVar3;
  puVar10 = auStack_52c;
  do {
    *psVar9 = (short)local_4e0;
    local_4e4 = pYVar6;
    puVar11 = puVar10;
    if (psVar3 + local_4f4 <= psVar9) {
      if (local_4e8 < 10000) {
        iVar12 = (int)psVar9 - (int)psVar3 >> 1;
        uVar7 = 10000;
        if (local_4e8 * 2 < 0x2711) {
          uVar7 = local_4e8 * 2;
        }
        local_4e8 = uVar7;
        iVar2 = -(uVar7 * 6 + 0x21 & 0xfffffff0);
        puVar11 = puVar10 + iVar2;
        psVar15 = (short *)((uint)(puVar10 + iVar2 + 0x1b) & 0xfffffff0);
        local_4ec = iVar12 + 1U;
        *(uint *)(puVar10 + iVar2 + 8) = (iVar12 + 1U) * 2;
        local_504 = pYVar6;
        *(short **)(puVar10 + iVar2 + 4) = psVar3;
        *(short **)(puVar10 + iVar2) = psVar15;
        *(undefined4 *)(puVar10 + iVar2 + -4) = 0x80b3549;
        memcpy(*(void **)(puVar10 + iVar2),*(void **)(puVar10 + iVar2 + 4),
               *(size_t *)(puVar10 + iVar2 + 8));
        uVar4 = local_4ec;
        pYVar13 = local_504;
        local_4e4 = (YYSTYPE *)(psVar15 + uVar7);
        *(YYSTYPE **)(puVar10 + iVar2) = (YYSTYPE *)(psVar15 + uVar7);
        psVar9 = psVar15 + iVar12;
        *(uint *)(puVar10 + iVar2 + 8) = uVar4 << 2;
        *(YYSTYPE **)(puVar10 + iVar2 + 4) = pYVar13;
        *(undefined4 *)(puVar10 + iVar2 + -4) = 0x80b3571;
        memcpy(*(void **)(puVar10 + iVar2),*(void **)(puVar10 + iVar2 + 4),
               *(size_t *)(puVar10 + iVar2 + 8));
        local_4f4 = local_4e8 - 1;
        if (psVar9 < psVar15 + (local_4e8 - 1)) {
          pYVar13 = local_4e4 + iVar12;
          puVar11 = puVar10 + iVar2;
          psVar3 = psVar15;
          goto yybackup;
        }
LAB_080b3760:
        yyresult = 1;
        puVar10 = puVar11;
      }
      else {
        yyresult = 2;
      }
      goto LAB_080b3765;
    }
yybackup:
    iVar12 = (int)yypact[local_4e0];
    puVar10 = puVar11;
    if (iVar12 == -10) {
yydefault:
      local_4e0 = (uint)""[local_4e0];
      if (local_4e0 == 0) {
yyerrlab:
        if (local_4f8 == 3) {
          if (local_4f0 == 0) goto LAB_080b3760;
          local_4f0 = 0xfffffffe;
        }
        while ((((iVar12 == -10 || (0x36 < iVar12 + 1U)) ||
                ("\x01\n\v\x04\r\x0e\b\t"[iVar12 + 1] != '\x01')) ||
               (uVar7 = (uint)"\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10"
                              [iVar12 + 1], uVar7 == 0))) {
          if (psVar9 == psVar3) goto LAB_080b3760;
          psVar9 = psVar9 + -1;
          pYVar13 = pYVar13 + -1;
          iVar12 = (int)yypact[*psVar9];
        }
        if (uVar7 == 9) goto LAB_080b3ba5;
        pYVar13 = pYVar13 + 1;
        *pYVar13 = local_500;
        local_4e0 = uVar7;
        local_4f8 = 3;
      }
      else {
        local_4ec = (uint)""[local_4e0];
        YVar5 = pYVar13[1 - (uint)""[local_4e0]];
        switch(local_4e0) {
        case 2:
          if ((expression *)pYVar13->num == (expression *)0x0) goto LAB_080b3760;
          local_4fc[1] = (byte *)(expression *)pYVar13->num;
          break;
        case 3:
          args[1] = pYVar13[-2].exp;
          args[0] = pYVar13[-4].exp;
          *(undefined4 *)(puVar11 + -4) = 0x80b389b;
          YVar5.exp = new_exp(3,qmop,args);
          break;
        case 4:
          args[1] = pYVar13->exp;
          args[0] = pYVar13[-2].exp;
          *(undefined4 *)(puVar11 + -4) = 0x80b38bd;
          YVar5.exp = new_exp(2,lor,args);
          break;
        case 5:
          args[1] = pYVar13->exp;
          args[0] = pYVar13[-2].exp;
          *(undefined4 *)(puVar11 + -4) = 0x80b38df;
          YVar5.exp = new_exp(2,land,args);
          break;
        case 6:
        case 7:
        case 8:
        case 9:
          args[1] = pYVar13->exp;
          args[0] = pYVar13[-2].exp;
          op = (expression *)pYVar13[-1].op;
          *(undefined4 *)(puVar11 + -4) = 0x80b3798;
          YVar5.exp = new_exp(2,(operator)op,args);
          break;
        case 10:
          args[0] = pYVar13->exp;
          *(undefined4 *)(puVar11 + -4) = 0x80b3933;
          YVar5.exp = new_exp(1,lnot,args);
          break;
        case 0xb:
          *(undefined4 *)(puVar11 + -4) = 0x80b3917;
          YVar5.exp = new_exp(0,var,(expression **)0x0);
          break;
        case 0xc:
          *(undefined4 *)(puVar11 + -4) = 0x80b38fa;
          YVar5.exp = new_exp(0,num,(expression **)0x0);
          if ((expression *)YVar5.num != (expression *)0x0) {
            ((YVar5.exp)->val).args[0] = (expression *)*(expression **)pYVar13;
          }
          break;
        case 0xd:
          YVar5 = pYVar13[-1];
        }
        psVar9 = psVar9 + -local_4ec;
        pYVar13[1 - local_4ec] = YVar5;
        pYVar13 = pYVar13 + (1 - local_4ec);
        uVar7 = (int)*psVar9 + (int)(char)""[""[local_4e0] + 0xc];
        if ((uVar7 < 0x37) && (*psVar9 == (short)"\x01\n\v\x04\r\x0e\b\t"[uVar7])) {
          local_4e0 = (uint)"\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10"
                            [uVar7];
        }
        else {
          local_4e0 = (int)(char)""[""[local_4e0] + 1];
        }
      }
    }
    else {
      if (local_4f0 == 0xfffffffe) {
        pbVar8 = *local_4fc;
        local_50d = *pbVar8;
        if (local_50d != 0) {
          if ((local_50d == 9) || (local_50d == 0x20)) {
            do {
              pbVar8 = pbVar8 + 1;
              bVar1 = *pbVar8;
              if (bVar1 == 0) goto LAB_080b37d8;
            } while ((bVar1 == 9) || (bVar1 == 0x20));
            local_50d = bVar1;
          }
          local_4f0 = (uint)local_50d;
          pbVar14 = pbVar8 + 1;
          switch(local_4f0) {
          case 0:
          case 10:
          case 0x3b:
            local_4f0 = 0;
            pbVar14 = pbVar8;
            break;
          default:
switchD_080b398b_caseD_1:
            local_4f0 = 0x100;
            break;
          case 0x21:
            if (*pbVar14 == 0x3d) {
              pbVar14 = pbVar8 + 2;
              local_500.num = (ulong)&DAT_0000000d;
              local_4f0 = 0x102;
            }
            break;
          case 0x25:
            local_500.num = (ulong)&DAT_00000005;
            local_4f0 = 0x105;
            break;
          case 0x26:
          case 0x7c:
            if (local_4f0 != *pbVar14) goto switchD_080b398b_caseD_1;
            pbVar14 = pbVar8 + 2;
            break;
          case 0x28:
          case 0x29:
          case 0x3a:
          case 0x3f:
          case 0x6e:
            break;
          case 0x2a:
            local_500.num = 3;
            local_4f0 = 0x105;
            break;
          case 0x2b:
            local_500.num = 6;
            local_4f0 = 0x104;
            break;
          case 0x2d:
            local_500.num = 7;
            local_4f0 = 0x104;
            break;
          case 0x2f:
            local_500.num = 4;
            local_4f0 = 0x105;
            break;
          case 0x30:
          case 0x31:
          case 0x32:
          case 0x33:
          case 0x34:
          case 0x35:
          case 0x36:
          case 0x37:
          case 0x38:
          case 0x39:
            local_500.exp = (expression *)(local_4f0 - 0x30);
            bVar1 = *pbVar14;
            while ((byte)(bVar1 - 0x30) < 10) {
              pbVar14 = pbVar14 + 1;
              local_500.exp = (expression *)((bVar1 - 0x30) + local_500.num * 10);
              bVar1 = *pbVar14;
            }
            local_4f0 = 0x106;
            break;
          case 0x3c:
            if (*pbVar14 == 0x3d) {
              local_500.num = 10;
              local_4f0 = 0x103;
              pbVar14 = pbVar8 + 2;
            }
            else {
              local_500.num = (ulong)&DAT_00000008;
              local_4f0 = 0x103;
            }
            break;
          case 0x3d:
            if (*pbVar14 != 0x3d) goto switchD_080b398b_caseD_1;
            local_500.num = (ulong)&DAT_0000000c;
            local_4f0 = 0x102;
            pbVar14 = pbVar8 + 2;
            break;
          case 0x3e:
            if (*pbVar14 == 0x3d) {
              local_500.num = 0xb;
              local_4f0 = 0x103;
              pbVar14 = pbVar8 + 2;
            }
            else {
              local_500.num = (ulong)&DAT_00000009;
              local_4f0 = 0x103;
            }
          }
          *local_4fc = pbVar14;
          goto LAB_080b35b3;
        }
LAB_080b37d8:
        *local_4fc = pbVar8;
        uVar7 = 0;
        local_4f0 = 0;
      }
      else {
LAB_080b35b3:
        if ((int)local_4f0 < 1) {
          uVar7 = 0;
          local_4f0 = 0;
        }
        else {
          uVar7 = 2;
          if (local_4f0 < 0x107) {
            uVar7 = (uint)""[local_4f0];
          }
        }
      }
      local_4ec = uVar7 + iVar12;
      if ((0x36 < local_4ec) || ((int)"\x01\n\v\x04\r\x0e\b\t"[local_4ec] != uVar7)) goto yydefault;
      uVar7 = (uint)"\a\x01\x02\b\x03\x04\x0f\x10\t\x12\x13\x14\x15\x16\x17\x18\n\v\f\r\x0e\x0f\x10\x10\x1a\x0e\x0f\x10\x11\n\v\f\r\x0e\x0f\x10"
                    [local_4ec];
      if (uVar7 == 0) goto yyerrlab;
      if (uVar7 == 9) {
LAB_080b3ba5:
        yyresult = 0;
LAB_080b3765:
        if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
          return yyresult;
        }
                    // WARNING: Subroutine does not return
        *(undefined4 *)(puVar10 + -4) = 0x80b3bec;
        __stack_chk_fail();
      }
      uVar4 = 0xfffffffe;
      if (local_4f0 == 0) {
        uVar4 = local_4f0;
      }
      pYVar13 = pYVar13 + 1;
      local_4f0 = uVar4;
      *pYVar13 = local_500;
      local_4e0 = uVar7;
      local_4f8 = local_4f8 + -1 + (uint)(local_4f8 == 0);
    }
    psVar9 = psVar9 + 1;
    pYVar6 = local_4e4;
  } while( true );
}



// WARNING: Unknown calling convention

uchar * textdomain__(uchar *domainname)

{
  uchar *__s2;
  int iVar1;
  uchar *puVar2;
  uchar *new_domain;
  uchar *puVar3;
  uchar *old_domain;
  
  __s2 = _nl_current_default_domain__;
  if (domainname == (uchar *)0x0) {
    return _nl_current_default_domain__;
  }
  if ((*domainname == '\0') || (iVar1 = strcmp((char *)domainname,(char *)"messages"), iVar1 == 0))
  {
    _nl_current_default_domain__ = "messages";
    puVar2 = _nl_current_default_domain__;
  }
  else {
    iVar1 = strcmp((char *)domainname,(char *)__s2);
    if (iVar1 == 0) {
      if (__s2 == (uchar *)0x0) {
        return (uchar *)0x0;
      }
      _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
      return __s2;
    }
    puVar2 = (uchar *)__strdup(domainname);
    if (puVar2 == (uchar *)0x0) {
      return (uchar *)0x0;
    }
  }
  _nl_current_default_domain__ = puVar2;
  puVar2 = _nl_current_default_domain__;
  _nl_msg_cat_cntr = _nl_msg_cat_cntr + 1;
  puVar3 = __s2;
  if ((__s2 != _nl_current_default_domain__) && (puVar3 = puVar2, __s2 != "messages")) {
    free(__s2);
  }
  return puVar3;
}



// WARNING: Unknown calling convention

uchar * get_event_name(int id)

{
  if ((-1 < id) && ((uint)id < eventssize)) {
    return events[id].name;
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void done_event(void)

{
  event *peVar1;
  void *p;
  int i;
  uint uVar2;
  
  if (eventssize != 0) {
    uVar2 = 0;
    do {
      peVar1 = events + uVar2;
      if (peVar1->handlers != (event_handler *)0x0) {
        mem_free(peVar1->handlers);
        peVar1 = events + uVar2;
      }
      uVar2 = uVar2 + 1;
      mem_free(peVar1->name);
    } while (uVar2 < eventssize);
  }
  if (events != (event *)0x0) {
    mem_free(events);
  }
  events = (event *)0x0;
  if (event_hash != (hash *)0x0) {
    free_hash(&event_hash);
  }
  eventssize = 0;
  return;
}



// WARNING: Unknown calling convention

void init_event(void)

{
  event_hash = init_hash8();
  return;
}



// WARNING: Unknown calling convention

void unregister_event_hook(int id,event_hook_T callback)

{
  event *peVar1;
  int i;
  uint uVar2;
  uint uVar4;
  event_handler *peVar5;
  int iVar6;
  event_handler *peVar7;
  event *event;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(callback == (event_hook_T)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 0xfa;
    elinks_internal((uchar *)"assertion callback failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  peVar1 = events;
  if ((-1 < id) && ((uint)id < eventssize)) {
    peVar5 = events[id].handlers;
    if ((peVar5 != (event_handler *)0x0) && (uVar4 = events[id].count, uVar4 != 0)) {
      peVar7 = peVar5;
      if (peVar5->callback == callback) {
        iVar6 = 0xc;
        uVar2 = 1;
      }
      else {
        uVar2 = 0;
        do {
          uVar3 = uVar2;
          peVar7 = peVar7 + 1;
          uVar2 = uVar3 + 1;
          if (uVar4 <= uVar2) {
            return;
          }
        } while (peVar7->callback != callback);
        uVar3 = uVar3 + 2;
        if ((int)uVar2 <= (int)uVar3) {
          uVar2 = uVar3;
        }
        iVar6 = uVar3 * 0xc;
      }
      memmove(peVar7,(void *)((int)&peVar5->callback + iVar6),(uVar4 - uVar2) * 0xc);
      uVar4 = peVar1[id].count - 1;
      peVar1[id].count = uVar4;
      if (uVar4 == 0) {
        mem_free(peVar1[id].handlers);
        peVar1[id].handlers = (event_handler *)0x0;
        return;
      }
      peVar5 = (event_handler *)mem_realloc(peVar1[id].handlers,uVar4 * 0xc);
      if (peVar5 != (event_handler *)0x0) {
        peVar1[id].handlers = peVar5;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void trigger_event_va(int id,va_list ap_init)

{
  evhook_status ret;
  evhook_status eVar1;
  event_handler *ev_handler;
  event_handler *peVar2;
  uint uVar3;
  int i;
  
  if ((-1 < id) && ((uint)id < eventssize)) {
    uVar3 = 0;
    peVar2 = events[id].handlers;
    if (events[id].count != 0) {
      while ((eVar1 = (*peVar2->callback)(ap_init,peVar2->data), eVar1 != EVENT_HOOK_STATUS_LAST &&
             (uVar3 = uVar3 + 1, uVar3 <= events[id].count && events[id].count != uVar3))) {
        peVar2 = peVar2 + 1;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void trigger_event(int id,...)

{
  trigger_event_va(id,&stack0x00000008);
  return;
}



// WARNING: Unknown calling convention

int get_event_id(uchar *name)

{
  void *pvVar1;
  hash *hash;
  hash_item *item;
  size_t keylen;
  hash_item *phVar2;
  
  if (assert_failed == 0) {
    if ((name == (uchar *)0x0) || (*name == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
      errline = 0x7d;
      elinks_internal((uchar *)"assertion name && name[0] failed: Empty or missing event name");
      if (assert_failed != 0) {
        assert_failed = 0;
        return -1;
      }
    }
    else {
      assert_failed = 0;
    }
    hash = event_hash;
    if (event_hash == (hash *)0x0) {
      return -1;
    }
    keylen = strlen((char *)name);
    phVar2 = get_hash_item(hash,name,keylen);
    if (phVar2 == (hash_item *)0x0) {
      return -1;
    }
    pvVar1 = phVar2->value;
    if (assert_failed == 0) {
      assert_failed = (int)(pvVar1 == (void *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
        errline = 0x87;
        elinks_internal((uchar *)"assertion event != NULL failed: Hash item with no value");
        if (assert_failed != 0) {
          assert_failed = 0;
          return -1;
        }
      }
      return *(int *)((int)pvVar1 + 0xc);
    }
  }
  assert_failed = 0;
  return -1;
}



// WARNING: Unknown calling convention

void unregister_event_hooks(event_hook_info *hooks)

{
  uchar *name;
  int id_00;
  int id;
  
  name = hooks->name;
  while (name != (uchar *)0x0) {
    id_00 = get_event_id(name);
    if (id_00 != -1) {
      unregister_event_hook(id_00,hooks->callback);
    }
    name = hooks[1].name;
    hooks = hooks + 1;
  }
  return;
}



// WARNING: Unknown calling convention

void trigger_event_name(uchar *name,...)

{
  int id;
  int id_00;
  
  id_00 = get_event_id(name);
  trigger_event_va(id_00,&stack0x00000008);
  return;
}



// WARNING: Unknown calling convention

int register_event(uchar *name)

{
  event *peVar1;
  uint uVar2;
  int id;
  hash_item *item;
  size_t sVar3;
  hash_item *phVar4;
  uchar *puVar5;
  event *peVar6;
  size_t newsize;
  uint uVar7;
  size_t size;
  event *event;
  uint uVar8;
  event *local_20;
  
  uVar2 = get_event_id(name);
  peVar1 = events;
  if (uVar2 == 0xffffffff) {
    uVar7 = eventssize + 8 & 0xfffffff8;
    uVar8 = eventssize + 7 & 0xfffffff8;
    local_20 = events;
    peVar6 = events;
    if (uVar8 < uVar7) {
      size = uVar7 * 0x10;
      peVar6 = (event *)mem_realloc(events,size);
      if (peVar6 == (event *)0x0) {
        return -1;
      }
      events = peVar6;
      memset(peVar6 + uVar8,0,size + uVar8 * -0x10);
    }
    if (peVar6 != (event *)0x0) {
      uVar7 = eventssize;
      if (peVar1 != peVar6) {
        uVar8 = 0;
        uVar7 = 0;
        local_20 = peVar6;
        if (eventssize != 0) {
          do {
            puVar5 = peVar6[uVar8].name;
            sVar3 = strlen((char *)puVar5);
            phVar4 = get_hash_item(event_hash,puVar5,sVar3);
            if (phVar4 != (hash_item *)0x0) {
              phVar4->value = events + uVar8;
            }
            uVar8 = uVar8 + 1;
            peVar6 = events;
          } while (uVar8 < eventssize);
          local_20 = events;
          uVar7 = eventssize;
        }
      }
      local_20 = local_20 + uVar7;
      sVar3 = strlen((char *)name);
      puVar5 = memacpy(name,sVar3);
      local_20->name = puVar5;
      if (puVar5 != (uchar *)0x0) {
        phVar4 = add_hash_item(event_hash,puVar5,sVar3,local_20);
        if (phVar4 == (hash_item *)0x0) {
          mem_free(local_20->name);
          local_20->name = (uchar *)0x0;
        }
        else {
          local_20->handlers = (event_handler *)0x0;
          local_20->count = 0;
          local_20->id = eventssize;
          uVar2 = eventssize;
          eventssize = eventssize + 1;
        }
      }
    }
  }
  return uVar2;
}



// WARNING: Unknown calling convention

int register_event_hook(int id,event_hook_T callback,int priority,void *data)

{
  event_handler *peVar1;
  event *peVar2;
  int i;
  uint uVar3;
  event_handler *eh;
  event_handler *peVar4;
  size_t size;
  uint uVar5;
  event_handler *peVar6;
  int iVar7;
  uint uVar8;
  int iVar9;
  uint local_28;
  uint local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = (int)(callback == (event_hook_T)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 0xd1;
    elinks_internal((uchar *)"assertion callback failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  peVar2 = events;
  if (id < 0) {
    return -1;
  }
  if (eventssize <= (uint)id) {
    return -1;
  }
  uVar8 = events[id].count;
  if (uVar8 == 0) {
    peVar4 = events[id].handlers;
    size = 0xc;
LAB_080b4510:
    peVar4 = (event_handler *)mem_realloc(peVar4,size);
    if (peVar4 == (event_handler *)0x0) {
      return -1;
    }
    peVar2[id].handlers = peVar4;
    local_28 = peVar2[id].count + 1;
    peVar2[id].count = local_28;
  }
  else {
    peVar4 = events[id].handlers;
    local_20 = 0;
    peVar6 = peVar4;
    if (peVar4->callback == callback) {
      local_20 = 0;
      iVar7 = 0xc;
      uVar5 = 1;
    }
    else {
      do {
        uVar3 = local_20;
        local_20 = uVar3 + 1;
        if (uVar8 <= local_20) break;
        peVar1 = peVar6 + 1;
        peVar6 = peVar6 + 1;
      } while (peVar1->callback != callback);
      if (local_20 == uVar8) {
        size = (uVar3 + 2) * 0xc;
        goto LAB_080b4510;
      }
      uVar3 = uVar3 + 2;
      uVar5 = local_20;
      if ((int)local_20 <= (int)uVar3) {
        uVar5 = uVar3;
      }
      local_20 = local_20 * 0xc;
      iVar7 = uVar3 * 0xc;
    }
    memmove((void *)((int)&peVar4->callback + local_20),(void *)((int)&peVar4->callback + iVar7),
            (uVar8 - uVar5) * 0xc);
    local_28 = peVar2[id].count;
    peVar4 = peVar2[id].handlers;
  }
  if (local_28 == 1) {
    iVar7 = 0xc;
    iVar9 = 0;
    peVar6 = peVar2[id].handlers;
    local_20 = 1;
  }
  else {
    uVar8 = 0;
    iVar7 = 0xc;
    if (peVar4->priority < priority) {
      iVar7 = 0xc;
      iVar9 = 0;
      local_20 = 1;
      peVar6 = peVar4;
    }
    else {
      do {
        iVar9 = iVar7;
        uVar5 = uVar8;
        uVar8 = uVar5 + 1;
        local_20 = uVar8;
        if (local_28 - 1 <= uVar8) {
          uVar5 = uVar5 + 2;
          if ((int)uVar8 <= (int)uVar5) {
            local_20 = uVar5;
          }
          iVar9 = uVar8 * 0xc;
          peVar6 = peVar4 + uVar8;
          iVar7 = uVar5 * 0xc;
          goto LAB_080b4412;
        }
        peVar6 = (event_handler *)((int)&peVar4->callback + iVar9);
        iVar7 = iVar9 + 0xc;
      } while (priority <= *(int *)((int)&peVar4->priority + iVar9));
      uVar5 = uVar5 + 2;
      if ((int)uVar8 <= (int)uVar5) {
        local_20 = uVar5;
      }
      iVar7 = uVar5 * 0xc;
    }
  }
LAB_080b4412:
  memmove((void *)((int)&peVar4->callback + iVar7),peVar6,(local_28 - local_20) * 0xc);
  *(event_hook_T *)((int)&(peVar2[id].handlers)->callback + iVar9) = callback;
  *(int *)((int)&(peVar2[id].handlers)->priority + iVar9) = priority;
  *(void **)((int)&(peVar2[id].handlers)->data + iVar9) = data;
  return id;
}



// WARNING: Unknown calling convention

void register_event_hooks(event_hook_info *hooks)

{
  uchar *name;
  int id_00;
  int id;
  
  name = hooks->name;
  while (name != (uchar *)0x0) {
    id_00 = register_event(name);
    if (id_00 != -1) {
      register_event_hook(id_00,hooks->callback,hooks->priority,hooks->data);
    }
    name = hooks[1].name;
    hooks = hooks + 1;
  }
  return;
}



// WARNING: Unknown calling convention

int get_address(socket_info *info,addr_type type)

{
  string *psVar1;
  option_value *poVar2;
  uint uVar3;
  sockaddr *psVar4;
  string path;
  
  if (assert_failed == 0) {
    assert_failed = (int)(info == (socket_info *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
      errline = 0x8b;
      elinks_internal((uchar *)"assertion info failed!");
      if (assert_failed != 0) goto LAB_080b46fe;
    }
    assert_failed = 0;
    if (elinks_home != (uchar *)0x0) {
      psVar1 = init_string(&path);
      if (psVar1 != (string *)0x0) {
        add_to_string(&path,elinks_home);
        add_to_string(&path,"socket");
        poVar2 = get_opt_();
        add_long_to_string(&path,poVar2->big_number);
        uVar3 = ~path.length;
        if ((int)(uVar3 + 0x6c) < 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
          errline = 0xae;
          elinks_internal((uchar *)"Socket path name \'%s\' is too long: %d >= %zu",path.source,
                          path.length,0x6c);
        }
        else {
          psVar4 = (sockaddr *)mem_calloc(1,0x6e);
          if (psVar4 != (sockaddr *)0x0) {
            memcpy(psVar4->sa_data,path.source,path.length);
            done_string(&path);
            psVar4->sa_family = 1;
            info->addr = psVar4;
            info->size = 0x6e - (uVar3 + 0x6c);
            return 1;
          }
        }
        done_string(&path);
        return -1;
      }
    }
  }
  else {
LAB_080b46fe:
    assert_failed = 0;
  }
  return -1;
}



// WARNING: Unknown calling convention

void report_af_unix_error(uchar *function,int error)

{
  char *pcVar1;
  uchar *fmt;
  
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
  errline = 0x149;
  pcVar1 = strerror(error);
  fmt = gettext((uchar *)"The call to %s failed: %d (%s)");
  elinks_error(fmt,function,error,pcVar1);
  return;
}



// WARNING: Unknown calling convention

void unlink_unix(sockaddr *addr)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(addr == (sockaddr *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
    errline = 0xe1;
    elinks_internal((uchar *)"assertion addr failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  unlink(addr->sa_data);
  return;
}



// WARNING: Unknown calling convention

void done_interlink(void)

{
  if (s_info_listen.addr != (sockaddr *)0x0) {
    if (s_info_listen.fd != -1) {
      close(s_info_listen.fd);
      s_info_listen.fd = -1;
    }
    unlink_unix(s_info_listen.addr);
    mem_free(s_info_listen.addr);
    s_info_listen.addr = (sockaddr *)0x0;
  }
  if (s_info_connect.addr != (sockaddr *)0x0) {
    if (s_info_connect.fd != -1) {
      close(s_info_connect.fd);
      s_info_connect.fd = -1;
    }
    mem_free(s_info_connect.addr);
    s_info_connect.addr = (sockaddr *)0x0;
  }
  if (s_info_accept.addr != (sockaddr *)0x0) {
    if (s_info_accept.fd != -1) {
      close(s_info_accept.fd);
      s_info_accept.fd = -1;
    }
    mem_free(s_info_accept.addr);
    s_info_accept.addr = (sockaddr *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void af_unix_connection(socket_info *info)

{
  int l;
  int fdin;
  int ns;
  int *piVar1;
  size_t local_10 [2];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(info == (socket_info *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
    errline = 0x154;
    elinks_internal((uchar *)"assertion info failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  local_10[0] = info->size;
  memset(info->addr,0,local_10[0]);
  fdin = accept(info->fd,(sockaddr *)info->addr,local_10);
  if (fdin < 0) {
    piVar1 = __errno_location();
    report_af_unix_error((uchar *)"accept()",*piVar1);
    return;
  }
  init_term(fdin,fdin);
  set_highpri();
  return;
}



// WARNING: Unknown calling convention

void elinks_usleep(ulong useconds)

{
  int iVar1;
  int __d0;
  int __d1;
  __fd_mask *p_Var2;
  fd_set dummy;
  timeval delay;
  
  iVar1 = 0x20;
  p_Var2 = dummy.__fds_bits;
  for (; iVar1 != 0; iVar1 = iVar1 + -1) {
    *p_Var2 = 0;
    p_Var2 = p_Var2 + 1;
  }
  delay.tv_sec = 0;
  delay.tv_usec = useconds;
  select(0,(fd_set *)&dummy,(fd_set *)&dummy,(fd_set *)&dummy,(timeval *)&delay);
  return;
}



// WARNING: Unknown calling convention

int init_interlink(void)

{
  int iVar1;
  int iVar2;
  int *piVar3;
  int fd;
  __mode_t __mask;
  int pf;
  sockaddr *psVar4;
  ulong uVar5;
  ulong uVar6;
  int attempts;
  int saved_errno;
  
  iVar1 = get_address(&s_info_connect,ADDR_IP_CLIENT);
  if (iVar1 != -1) {
    uVar5 = 50000;
    do {
      s_info_connect.fd = socket(iVar1,1,0);
      if (s_info_connect.fd == -1) {
        piVar3 = __errno_location();
        report_af_unix_error((uchar *)"socket()",*piVar3);
        break;
      }
      iVar2 = connect(s_info_connect.fd,(sockaddr *)s_info_connect.addr,s_info_connect.size);
      if (-1 < iVar2) {
        if (s_info_connect.fd != -1) {
          return s_info_connect.fd;
        }
        goto LAB_080b4b07;
      }
      piVar3 = __errno_location();
      iVar2 = *piVar3;
      close(s_info_connect.fd);
      if ((iVar2 != 2) && (iVar2 != 0x6f)) {
        report_af_unix_error((uchar *)"connect()",*piVar3);
        break;
      }
      uVar6 = uVar5 + 50000;
      elinks_usleep(uVar5);
      uVar5 = uVar6;
    } while (uVar6 != 200000);
  }
  if (s_info_connect.addr != (sockaddr *)0x0) {
    mem_free(s_info_connect.addr);
  }
  s_info_connect.addr = (sockaddr *)0x0;
LAB_080b4b07:
  __mask = umask(0x7f);
  iVar1 = get_address(&s_info_listen,ADDR_IP_SERVER);
  if (iVar1 != -1) {
    attempts = 0;
    uVar5 = 100000;
    while (s_info_listen.fd = socket(iVar1,1,0), s_info_listen.fd != -1) {
      iVar2 = bind(s_info_listen.fd,(sockaddr *)s_info_listen.addr,s_info_listen.size);
      if (-1 < iVar2) {
        if (assert_failed == 0) {
          assert_failed = 0;
          psVar4 = (sockaddr *)mem_calloc(1,0x6e);
          if (psVar4 != (sockaddr *)0x0) {
            s_info_accept.size = 0x6e;
            s_info_accept.fd = s_info_listen.fd;
            s_info_accept.addr = psVar4;
            iVar1 = listen(s_info_listen.fd,100);
            if (iVar1 == 0) {
              set_handlers(s_info_listen.fd,af_unix_connection,(select_handler_T)0x0,
                           (select_handler_T)0x0,&s_info_accept);
              umask(__mask);
              return -1;
            }
            piVar3 = __errno_location();
            report_af_unix_error((uchar *)"listen()",*piVar3);
          }
        }
        else {
          assert_failed = 0;
        }
        goto free_and_error;
      }
      piVar3 = __errno_location();
      if (*piVar3 != 0x62) {
        report_af_unix_error((uchar *)"bind()",*piVar3);
      }
      attempts = attempts + 1;
      if (attempts == 3) {
        unlink_unix(s_info_listen.addr);
      }
      else if (3 < attempts) goto free_and_error;
      elinks_usleep(uVar5);
      close(s_info_listen.fd);
      uVar5 = uVar5 + 100000;
    }
    piVar3 = __errno_location();
    report_af_unix_error((uchar *)"socket()",*piVar3);
  }
free_and_error:
  done_interlink();
  umask(__mask);
  return -1;
}



// WARNING: Unknown calling convention

void check_stdio(list_head_elinks *url_list)

{
  int iVar1;
  option_value *poVar2;
  option_value *poVar3;
  
  if ((assert_failed == 0) && (assert_failed = (int)(remote_session_flags != 0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion !remote_session_flags failed!");
  }
  iVar1 = isatty(0);
  if (iVar1 == 0) {
    if ((url_list != (list_head_elinks *)0x0) && ((list_head_elinks *)url_list->next == url_list)) {
      poVar2 = get_opt_();
      poVar2->number = 1;
      add_to_string_list(url_list,(uchar *)"file:///dev/stdin",0x11);
    }
    poVar2 = get_opt_();
    poVar2->number = 1;
  }
  iVar1 = isatty(1);
  if (iVar1 == 0) {
    poVar2 = get_opt_();
    if (poVar2->tree == (list_head_elinks *)0x0) {
      poVar3 = get_opt_();
      if (poVar3->tree == (list_head_elinks *)0x0) {
        poVar2->number = 1;
      }
    }
  }
  return;
}



int init(EVP_PKEY_CTX *ctx)

{
  remote_session_flags remote;
  uchar *puVar1;
  uchar *cwd;
  int iVar2;
  retval rVar3;
  retval ret;
  uchar *filename;
  option_value *poVar4;
  string *psVar5;
  int iVar6;
  int iVar7;
  int std_in;
  terminal *term;
  int fd;
  uchar *arg;
  char *pcVar8;
  char *pcVar9;
  string info;
  list_head_elinks url_list;
  
  url_list.next = &url_list;
  url_list.prev = &url_list;
  init_osdep();
  puVar1 = get_cwd();
  if ((puVar1 == (uchar *)0x0) || (iVar2 = file_is_dir(puVar1), iVar2 == 0)) {
    filename = (uchar *)getenv("HOME");
    if ((filename != (uchar *)0x0) && (iVar2 = file_is_dir(filename), iVar2 != 0)) {
      chdir((char *)filename);
    }
    if (puVar1 != (uchar *)0x0) goto LAB_080b4e76;
  }
  else {
LAB_080b4e76:
    mem_free(puVar1);
  }
  bindtextdomain("elinks",(uchar *)"/usr/share/locale");
  textdomain("elinks");
  set_language(0);
  init_event();
  init_charsets_lookup();
  init_colors_lookup();
  init_modules(main_modules);
  init_options();
  init_static_version();
  register_modules_options(main_modules);
  register_modules_options(builtin_modules);
  set_sigcld();
  get_system_name();
  iVar2 = check_terminal_pipes();
  if (iVar2 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
    errline = 0x88;
    puVar1 = gettext((uchar *)"Cannot create a pipe for internal communication.");
    elinks_error(puVar1);
    program.retval = RET_FATAL;
    program.terminate = 1;
    return (int)puVar1;
  }
  rVar3 = parse_options(ac + -1,av + 1,&url_list);
  if (rVar3 != RET_OK) {
    if (rVar3 != RET_COMMAND) {
      program.retval = rVar3;
    }
    program.terminate = 1;
    free_string_list(&url_list);
    return rVar3;
  }
  if (remote_session_flags == 0) {
    check_stdio(&url_list);
  }
  else {
    program.terminate = 1;
  }
  poVar4 = get_opt_();
  if (poVar4->tree == (list_head_elinks *)0x0) {
    init_home();
  }
  poVar4 = get_opt_();
  if ((((poVar4->tree != (list_head_elinks *)0x0) ||
       (poVar4 = get_opt_(), poVar4->tree != (list_head_elinks *)0x0)) ||
      (poVar4 = get_opt_(), poVar4->tree != (list_head_elinks *)0x0)) ||
     (iVar2 = init_interlink(), iVar2 == -1)) {
    load_config();
    update_options_visibility();
    parse_options(ac + -1,av + 1,(list_head_elinks *)0x0);
    if (remote_session_flags == 0) {
      check_stdio((list_head_elinks *)0x0);
    }
    init_b = 1;
    iVar2 = -1;
    init_modules(builtin_modules);
  }
  pcVar8 = "dump";
  term = (terminal *)get_opt_();
  if (((option_value *)&term->next)->tree == (list_head_elinks *)0x0) {
    pcVar9 = "source";
    term = (terminal *)get_opt_();
    if (((option_value *)&term->next)->tree != (list_head_elinks *)0x0) goto LAB_080b5051;
    if ((remote_session_flags & SES_REMOTE_PING) == 0) {
      if ((iVar2 == -1) && (remote_session_flags != 0)) {
        term = (terminal *)gettext((uchar *)"No remote session to connect to.");
        usrerror((uchar *)term,pcVar9);
        program.retval = RET_REMOTE;
      }
      else {
        psVar5 = encode_session_info(&info,&url_list);
        if (psVar5 == (string *)0x0) {
          errline = 0xe0;
          pcVar8 = "Unable to encode session info.";
LAB_080b5353:
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
          term = (terminal *)gettext((uchar *)pcVar8);
          elinks_error((uchar *)term);
          program.retval = RET_FATAL;
          program.terminate = 1;
        }
        else {
          if (iVar2 == -1) {
            iVar2 = get_ctl_handle();
            iVar6 = get_output_handle();
            iVar7 = get_input_handle();
            term = attach_terminal(iVar7,iVar6,iVar2,info.source,info.length);
            if (term == (terminal *)0x0) {
              errline = 0xf1;
              pcVar8 = "Unable to attach_terminal().";
              goto LAB_080b5353;
            }
          }
          else {
            close_terminal_pipes();
            remote = remote_session_flags;
            iVar6 = get_ctl_handle();
            iVar7 = get_output_handle();
            std_in = get_input_handle();
            handle_trm(std_in,iVar7,iVar2,iVar2,iVar6,info.source,info.length,remote);
            term = (terminal *)0x0;
          }
          if (program.terminate == 0) {
            handle_basic_signals(term);
          }
        }
        done_string(&info);
      }
    }
    else {
      term = (terminal *)remote_session_flags;
      if (iVar2 == -1) {
        term = (terminal *)gettext((uchar *)"No running ELinks found.");
        usrerror((uchar *)term,pcVar9);
        program.retval = RET_PING;
      }
    }
LAB_080b5062:
    if (program.terminate == 0) goto LAB_080b5070;
  }
  else {
LAB_080b5051:
    if (&url_list != (list_head_elinks *)url_list.next) {
      dump_next(&url_list);
      goto LAB_080b5062;
    }
    poVar4 = get_opt_();
    if (poVar4->tree == (list_head_elinks *)0x0) {
      pcVar8 = "source";
    }
    term = (terminal *)gettext((uchar *)"URL expected after -%s");
    usrerror((uchar *)term,pcVar8);
    program.retval = RET_SYNTAX;
    program.terminate = 1;
  }
  close_terminal_pipes();
LAB_080b5070:
  free_string_list(&url_list);
  return (int)term;
}



// WARNING: Unknown calling convention

void shrink_memory(int whole)

{
  shrink_dns_cache(whole);
  shrink_format_cache(whole);
  garbage_collection(whole);
  return;
}



// WARNING: Unknown calling convention

int main(int argc,char **argv)

{
  program.terminate = 0;
  program.retval = RET_OK;
  program.path = (uchar *)*argv;
  av = (uchar **)argv;
  ac = argc;
  select_loop(init);
  done_interlink();
  check_bottom_halves();
  abort_all_downloads();
  check_bottom_halves();
  destroy_all_terminals();
  check_bottom_halves();
  free_all_itrms();
  abort_all_connections();
  check_bottom_halves();
  abort_all_connections();
  if (init_b != 0) {
    trigger_event_name("quit");
    free_history_lists();
    done_modules(builtin_modules);
    done_saved_session_info();
  }
  shrink_memory(1);
  free_charsets_lookup();
  free_colors_lookup();
  done_modules(main_modules);
  free_conv_table();
  check_bottom_halves();
  done_home();
  done_state_message();
  done_bfu_colors();
  unregister_modules_options(builtin_modules);
  unregister_modules_options(main_modules);
  done_options();
  done_event();
  terminate_osdep();
  return program.retval;
}



// WARNING: Unknown calling convention

void done_module(module *module)

{
  module **ppmVar1;
  module *submodule;
  module *module_00;
  int i;
  int iVar2;
  int iVar3;
  
  ppmVar1 = module->submodules;
  if ((ppmVar1 != (module **)0x0) && (*ppmVar1 != (module *)0x0)) {
    iVar3 = 0;
    do {
      iVar2 = iVar3;
      iVar3 = iVar2 + 1;
    } while (ppmVar1[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module_00 = ppmVar1[iVar2], module_00 != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      iVar3 = iVar2 * 4;
      for (; done_module(module_00), iVar2 != -1; iVar2 = iVar2 + -1) {
        module_00 = *(module **)((int)module->submodules + iVar3);
        iVar3 = iVar3 + -4;
        if (module_00 == (module *)0x0) break;
      }
    }
  }
  if (module->hooks != (event_hook_info *)0x0) {
    unregister_event_hooks(module->hooks);
  }
  if (module->done == (_func_void_module_ptr *)0x0) {
    return;
  }
                    // WARNING: Could not recover jumptable at 0x080b5575. Too many branches
                    // WARNING: Treating indirect jump as call
  (*module->done)(module);
  return;
}



// WARNING: Unknown calling convention

void done_modules(module **modules)

{
  int iVar1;
  module *module;
  module *module_00;
  int i;
  int iVar2;
  module **ppmVar3;
  
  if ((modules != (module **)0x0) && (*modules != (module *)0x0)) {
    iVar1 = 0;
    do {
      iVar2 = iVar1;
      iVar1 = iVar2 + 1;
    } while (modules[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module_00 = modules[iVar2], module_00 != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      ppmVar3 = modules + iVar2;
      for (; done_module(module_00), iVar2 != -1; iVar2 = iVar2 + -1) {
        module_00 = *ppmVar3;
        ppmVar3 = ppmVar3 + -1;
        if (module_00 == (module *)0x0) {
          return;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void init_module(module *module)

{
  module *submodule;
  module *module_00;
  int iVar1;
  
  if (module->init != (_func_void_module_ptr *)0x0) {
    (*module->init)(module);
  }
  if (module->hooks != (event_hook_info *)0x0) {
    register_event_hooks(module->hooks);
  }
  if ((module->submodules != (module **)0x0) &&
     (module_00 = *module->submodules, module_00 != (module *)0x0)) {
    iVar1 = 4;
    do {
      init_module(module_00);
      module_00 = *(module **)((int)module->submodules + iVar1);
      iVar1 = iVar1 + 4;
    } while (module_00 != (module *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void init_modules(module **modules)

{
  module **ppmVar1;
  module *module_00;
  module *module;
  
  if (modules != (module **)0x0) {
    module_00 = *modules;
    while (module_00 != (module *)0x0) {
      init_module(module_00);
      ppmVar1 = modules + 1;
      modules = modules + 1;
      module_00 = *ppmVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void unregister_module_options(module *module)

{
  module **ppmVar1;
  module *submodule;
  module *module_00;
  int i;
  int iVar2;
  int iVar3;
  
  ppmVar1 = module->submodules;
  if ((ppmVar1 != (module **)0x0) && (*ppmVar1 != (module *)0x0)) {
    iVar3 = 0;
    do {
      iVar2 = iVar3;
      iVar3 = iVar2 + 1;
    } while (ppmVar1[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module_00 = ppmVar1[iVar2], module_00 != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      iVar3 = iVar2 * 4;
      for (; unregister_module_options(module_00), iVar2 != -1; iVar2 = iVar2 + -1) {
        module_00 = *(module **)((int)module->submodules + iVar3);
        iVar3 = iVar3 + -4;
        if (module_00 == (module *)0x0) break;
      }
    }
  }
  if (module->options != (option_info *)0x0) {
    unregister_options(module->options,config_options);
  }
  return;
}



// WARNING: Unknown calling convention

void unregister_modules_options(module **modules)

{
  int iVar1;
  module *module;
  module *module_00;
  int i;
  int iVar2;
  module **ppmVar3;
  
  if ((modules != (module **)0x0) && (*modules != (module *)0x0)) {
    iVar1 = 0;
    do {
      iVar2 = iVar1;
      iVar1 = iVar2 + 1;
    } while (modules[iVar2 + 1] != (module *)0x0);
    if ((iVar2 != -1) && (module_00 = modules[iVar2], module_00 != (module *)0x0)) {
      iVar2 = iVar2 + -1;
      ppmVar3 = modules + iVar2;
      for (; unregister_module_options(module_00), iVar2 != -1; iVar2 = iVar2 + -1) {
        module_00 = *ppmVar3;
        ppmVar3 = ppmVar3 + -1;
        if (module_00 == (module *)0x0) {
          return;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void register_module_options(module *module)

{
  module *submodule;
  module *module_00;
  int iVar1;
  
  if (module->options != (option_info *)0x0) {
    register_options(module->options,config_options);
  }
  if ((module->submodules != (module **)0x0) &&
     (module_00 = *module->submodules, module_00 != (module *)0x0)) {
    iVar1 = 4;
    do {
      register_module_options(module_00);
      module_00 = *(module **)((int)module->submodules + iVar1);
      iVar1 = iVar1 + 4;
    } while (module_00 != (module *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void register_modules_options(module **modules)

{
  module **ppmVar1;
  module *module_00;
  module *module;
  
  if (modules != (module **)0x0) {
    module_00 = *modules;
    while (module_00 != (module *)0x0) {
      register_module_options(module_00);
      ppmVar1 = modules + 1;
      modules = modules + 1;
      module_00 = *ppmVar1;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int get_file_handles_count(void)

{
  int i;
  int iVar1;
  int iVar2;
  
  iVar2 = 0;
  iVar1 = 0;
  do {
    while (((*(int *)((int)&threads[0].read_func + iVar2) == 0 &&
            (*(int *)((int)&threads[0].write_func + iVar2) == 0)) &&
           (*(int *)((int)&threads[0].error_func + iVar2) == 0))) {
      iVar2 = iVar2 + 0x10;
      if (iVar2 == 0x4000) {
        return iVar1;
      }
    }
    iVar2 = iVar2 + 0x10;
    iVar1 = iVar1 + 1;
  } while (iVar2 != 0x4000);
  return iVar1;
}



// WARNING: Unknown calling convention

int can_read_or_write(int fd,int write)

{
  byte bVar1;
  __fd_mask *__writefds;
  fd_set *rfds;
  int iVar2;
  int __d0;
  int __d1;
  __fd_mask *p_Var3;
  fd_set *wfds;
  fd_set fds;
  timeval tv;
  
  __writefds = (__fd_mask *)&fds;
  rfds = (fd_set *)0x0;
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  p_Var3 = __writefds;
  for (iVar2 = 0x20; iVar2 != 0; iVar2 = iVar2 + -1) {
    *p_Var3 = 0;
    p_Var3 = p_Var3 + 1;
  }
  iVar2 = fd + 0x1f;
  if (-1 < fd) {
    iVar2 = fd;
  }
  if (write == 0) {
    rfds = (fd_set *)__writefds;
    __writefds = ((fd_set *)0x0)->fds_bits;
  }
  bVar1 = (byte)(fd >> 0x1f);
  fds.__fds_bits[iVar2 >> 5] =
       fds.__fds_bits[iVar2 >> 5] | 1 << (((char)fd + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f);
  iVar2 = select(fd + 1,(fd_set *)rfds,(fd_set *)__writefds,(fd_set *)0x0,(timeval *)&tv);
  return iVar2;
}



// WARNING: Unknown calling convention

int can_write(int fd)

{
  int iVar1;
  
  iVar1 = can_read_or_write(fd,1);
  return iVar1;
}



// WARNING: Unknown calling convention

int can_read(int fd)

{
  int iVar1;
  
  iVar1 = can_read_or_write(fd,0);
  return iVar1;
}



// WARNING: Unknown calling convention

void set_handlers(int fd,select_handler_T read_func,select_handler_T write_func,
                 select_handler_T error_func,void *data)

{
  byte bVar1;
  int iVar2;
  int i;
  uint uVar3;
  uint uVar4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(0x3ff < (uint)fd);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
    errline = 0x95;
    elinks_internal((uchar *)
                    "assertion fd >= 0 && fd < FD_SETSIZE failed: set_handlers: handle %d >= FD_SETSIZE %d"
                    ,fd,0x400);
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  threads[fd].read_func = read_func;
  threads[fd].write_func = write_func;
  threads[fd].error_func = error_func;
  threads[fd].data = data;
  bVar1 = (byte)(fd >> 0x1f);
  if (read_func == (select_handler_T)0x0) {
    iVar2 = fd + 0x1f;
    if (-1 < fd) {
      iVar2 = fd;
    }
    uVar3 = 1 << (((char)fd + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f);
    iVar2 = iVar2 >> 5;
    w_read.__fds_bits[iVar2] = w_read.__fds_bits[iVar2] & ~uVar3;
    x_read.__fds_bits[iVar2] = x_read.__fds_bits[iVar2] & ~uVar3;
  }
  else {
    iVar2 = fd + 0x1f;
    if (-1 < fd) {
      iVar2 = fd;
    }
    iVar2 = iVar2 >> 5;
    uVar3 = 1 << (((char)fd + (bVar1 >> 3) & 0x1f) - (bVar1 >> 3) & 0x1f);
    w_read.__fds_bits[iVar2] = w_read.__fds_bits[iVar2] | uVar3;
  }
  if (write_func == (select_handler_T)0x0) {
    w_write.__fds_bits[iVar2] = w_write.__fds_bits[iVar2] & ~uVar3;
    x_write.__fds_bits[iVar2] = x_write.__fds_bits[iVar2] & ~uVar3;
  }
  else {
    w_write.__fds_bits[iVar2] = w_write.__fds_bits[iVar2] | uVar3;
  }
  if (error_func == (select_handler_T)0x0) {
    w_error.__fds_bits[iVar2] = w_error.__fds_bits[iVar2] & ~uVar3;
    x_error.__fds_bits[iVar2] = x_error.__fds_bits[iVar2] & ~uVar3;
  }
  else {
    w_error.__fds_bits[iVar2] = w_error.__fds_bits[iVar2] | uVar3;
  }
  if (((write_func == (select_handler_T)0x0) && (read_func == (select_handler_T)0x0)) &&
     (error_func == (select_handler_T)0x0)) {
    if (w_max + -1 == fd) {
      uVar3 = w_max - 2;
      if (-1 < (int)uVar3) {
        while( true ) {
          iVar2 = (int)uVar3 >> 5;
          uVar4 = uVar3 & 0x1f;
          if ((((uint)w_read.__fds_bits[iVar2] >> uVar4 & 1) != 0) ||
             (((uint)w_write.__fds_bits[iVar2] >> uVar4 & 1) != 0)) break;
          if ((((uint)w_error.__fds_bits[iVar2] >> uVar4 & 1) != 0) ||
             (uVar3 = uVar3 - 1, uVar3 == 0xffffffff)) break;
        }
      }
      w_max = uVar3 + 1;
    }
  }
  else if (w_max <= fd) {
    w_max = fd + 1;
  }
  return;
}



// WARNING: Unknown calling convention

select_handler_T get_handler(int fd,select_handler_type tp)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return (select_handler_T)0x0;
  }
  assert_failed = (int)(0x3ff < (uint)fd);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
    errline = 0x80;
    elinks_internal((uchar *)
                    "assertion fd >= 0 && fd < FD_SETSIZE failed: get_handler: handle %d >= FD_SETSIZE %d"
                    ,fd,0x400);
    if (assert_failed != 0) {
      assert_failed = 0;
      return (select_handler_T)0x0;
    }
  }
  if (tp == SELECT_HANDLER_WRITE) {
    assert_failed = 0;
    return threads[fd].write_func;
  }
  assert_failed = 0;
  if (tp == SELECT_HANDLER_READ) {
    return threads[fd].read_func;
  }
  if (tp != SELECT_HANDLER_ERROR) {
    if (tp != SELECT_HANDLER_DATA) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
      errline = 0x8a;
      assert_failed = 0;
      elinks_internal((uchar *)"get_handler: bad type %d",tp);
      return (select_handler_T)0x0;
    }
    return (select_handler_T)threads[fd].data;
  }
  return threads[fd].error_func;
}



// WARNING: Unknown calling convention

void check_bottom_halves(void)

{
  undefined4 uVar1;
  code *pcVar2;
  void *p;
  bottom_half *bh;
  select_handler_T fn;
  void *data;
  
  if ((list_head_elinks *)bottom_halves.next != &bottom_halves) {
    do {
      p = bottom_halves.prev;
                    // WARNING: Load size is inaccurate
      uVar1 = *(undefined4 *)((int)bottom_halves.prev + 0xc);
      pcVar2 = *(code **)((int)bottom_halves.prev + 8);
      *(undefined4 *)(*bottom_halves.prev + 4) = *(undefined4 *)((int)bottom_halves.prev + 4);
                    // WARNING: Load size is inaccurate
      **(undefined4 **)((int)p + 4) = *p;
      mem_free(p);
      (*pcVar2)(uVar1);
    } while ((list_head_elinks *)bottom_halves.next != &bottom_halves);
  }
  return;
}



// WARNING: Unknown calling convention

void select_loop(_func_void *init)

{
  int k;
  int iVar1;
  timeval_T *__timeout;
  timeval *timeout;
  int iVar2;
  int *piVar3;
  char *pcVar4;
  uchar *puVar5;
  int iVar6;
  int __d0;
  int __d0_1;
  int __d0_2;
  void **ppvVar7;
  int errno_from_select;
  int has_timer;
  uint uVar8;
  int i;
  fd_set *pfVar9;
  int __d1;
  int __d1_1;
  int __d1_2;
  __fd_mask *p_Var10;
  fd_set *pfVar11;
  byte bVar12;
  int local_34;
  int local_30;
  timeval_T t;
  timeval_T last_time;
  
  clear_signal_mask_and_handlers();
  iVar6 = 0x20;
  p_Var10 = w_read.__fds_bits;
  for (; iVar6 != 0; iVar6 = iVar6 + -1) {
    *p_Var10 = 0;
    p_Var10 = p_Var10 + 1;
  }
  iVar6 = 0x20;
  p_Var10 = w_write.__fds_bits;
  for (; iVar6 != 0; iVar6 = iVar6 + -1) {
    *p_Var10 = 0;
    p_Var10 = p_Var10 + 1;
  }
  bVar12 = 0;
  iVar6 = 0x20;
  p_Var10 = w_error.__fds_bits;
  for (; iVar6 != 0; iVar6 = iVar6 + -1) {
    *p_Var10 = 0;
    p_Var10 = p_Var10 + 1;
  }
  w_max = 0;
  timeval_now(&last_time);
  signal(0xd,(__sighandler_t)0x1);
  (*init)();
  check_bottom_halves();
  local_34 = 0;
  do {
    while( true ) {
      while( true ) {
        if (program.terminate != 0) {
          return;
        }
        check_signals();
        check_timers(&last_time);
        redraw_all_terminals();
        pfVar9 = &w_read;
        pfVar11 = &x_read;
        for (iVar6 = 0x20; iVar6 != 0; iVar6 = iVar6 + -1) {
          pfVar11->__fds_bits[0] = pfVar9->__fds_bits[0];
          pfVar9 = (fd_set *)((int)pfVar9 + ((uint)bVar12 * -2 + 1) * 4);
          pfVar11 = (fd_set *)((int)pfVar11 + ((uint)bVar12 * -2 + 1) * 4);
        }
        pfVar9 = &w_write;
        pfVar11 = &x_write;
        for (iVar6 = 0x20; iVar6 != 0; iVar6 = iVar6 + -1) {
          pfVar11->__fds_bits[0] = pfVar9->__fds_bits[0];
          pfVar9 = (fd_set *)((int)pfVar9 + ((uint)bVar12 * -2 + 1) * 4);
          pfVar11 = (fd_set *)((int)pfVar11 + ((uint)bVar12 * -2 + 1) * 4);
        }
        pfVar9 = &w_error;
        pfVar11 = &x_error;
        for (iVar6 = 0x20; iVar6 != 0; iVar6 = iVar6 + -1) {
          pfVar11->__fds_bits[0] = pfVar9->__fds_bits[0];
          pfVar9 = (fd_set *)((int)pfVar9 + ((uint)bVar12 * -2 + 1) * 4);
          pfVar11 = (fd_set *)((int)pfVar11 + ((uint)bVar12 * -2 + 1) * 4);
        }
        if (program.terminate != 0) {
          return;
        }
        iVar6 = get_next_timer_time(&t);
        if ((iVar6 == 0) && (w_max == 0)) {
          return;
        }
        critical_section = 1;
        iVar1 = check_signals();
        if (iVar1 == 0) break;
        critical_section = 0;
      }
      __timeout = (timeval_T *)0x0;
      if (iVar6 != 0) {
        timeval_limit_to_zero_or_one(&t);
        __timeout = &t;
      }
      local_30 = select(w_max,(fd_set *)&x_read,(fd_set *)&x_write,(fd_set *)&x_error,
                        (timeval *)__timeout);
      if (-1 < local_30) break;
      piVar3 = __errno_location();
      iVar6 = *piVar3;
      critical_section = 0;
      uninstall_alarm();
      if (iVar6 != 4) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
        errline = 0x117;
        pcVar4 = strerror(iVar6);
        puVar5 = gettext((uchar *)"The call to %s failed: %d (%s)");
        elinks_error(puVar5,"select()",iVar6,pcVar4);
        local_34 = local_34 + 1;
        if (10 < local_34) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
          errline = 0x11a;
          puVar5 = gettext((uchar *)"%d select() failures.");
          elinks_internal(puVar5,local_34);
        }
      }
    }
    critical_section = 0;
    uninstall_alarm();
    check_signals();
    check_timers(&last_time);
    if ((local_30 != 0) && (0 < w_max)) {
      ppvVar7 = &threads[0].data;
      iVar6 = 0;
      do {
        iVar1 = iVar6 + 0x1f;
        if (-1 < iVar6) {
          iVar1 = iVar6;
        }
        iVar1 = iVar1 >> 5;
        uVar8 = iVar6 % 0x20;
        iVar2 = 0;
        if (((uint)x_read.__fds_bits[iVar1] >> (uVar8 & 0x1f) & 1) != 0) {
          iVar2 = 1;
          if (((thread *)(ppvVar7 + -3))->read_func != (select_handler_T)0x0) {
            (*((thread *)(ppvVar7 + -3))->read_func)(*ppvVar7);
            check_bottom_halves();
            iVar2 = 1;
          }
        }
        if (((uint)x_write.__fds_bits[iVar1] >> (uVar8 & 0x1f) & 1) != 0) {
          iVar2 = 1;
          if ((select_handler_T)ppvVar7[-2] != (select_handler_T)0x0) {
            (*(code *)ppvVar7[-2])(*ppvVar7);
            check_bottom_halves();
            iVar2 = 1;
          }
        }
        if (((uint)x_error.__fds_bits[iVar1] >> (uVar8 & 0x1f) & 1) != 0) {
          iVar2 = 1;
          if ((select_handler_T)ppvVar7[-1] != (select_handler_T)0x0) {
            (*(code *)ppvVar7[-1])(*ppvVar7);
            check_bottom_halves();
            iVar2 = 1;
          }
        }
        local_30 = local_30 - iVar2;
        if (local_30 == 0) break;
        iVar6 = iVar6 + 1;
        ppvVar7 = ppvVar7 + 4;
      } while (iVar6 < w_max);
    }
    local_34 = 0;
  } while( true );
}



// WARNING: Unknown calling convention

int register_bottom_half_do(select_handler_T fn,void *data)

{
  void *pvVar1;
  void **ppvVar2;
  int iVar3;
  bottom_half *bh;
  list_head_elinks *plVar4;
  
  plVar4 = (list_head_elinks *)bottom_halves.next;
  if ((list_head_elinks *)bottom_halves.next == &bottom_halves) {
    plVar4 = &bottom_halves;
  }
  else {
    do {
      if (((select_handler_T)plVar4[1].next == fn) && (plVar4[1].prev == data)) goto LAB_080b6058;
      plVar4 = (list_head_elinks *)plVar4->next;
    } while (plVar4 != &bottom_halves);
  }
  ppvVar2 = (void **)mem_alloc(0x10);
  iVar3 = -1;
  if (ppvVar2 != (void **)0x0) {
    ppvVar2[2] = fn;
    ppvVar2[3] = data;
    pvVar1 = plVar4->next;
    ppvVar2[1] = plVar4;
    *ppvVar2 = pvVar1;
    plVar4->next = ppvVar2;
    *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
LAB_080b6058:
    iVar3 = 0;
  }
  return iVar3;
}



// WARNING: Unknown calling convention

int get_timers_count(void)

{
  void **ppvVar1;
  int iVar2;
  int size;
  list_head_elinks *item;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)timers.next;
  if ((list_head_elinks *)timers.next != &timers) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &timers);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_next_timer_time(timeval_T *t)

{
  long lVar1;
  bool bVar2;
  
  bVar2 = (list_head_elinks *)timers.next != &timers;
  if (bVar2) {
    lVar1 = *(long *)((int)timers.next + 0xc);
    t->sec = *(long *)((int)timers.next + 8);
    t->usec = lVar1;
  }
  return (uint)bVar2;
}



// WARNING: Unknown calling convention

void kill_timer(timer_id_T *id)

{
  timer_id_T p;
  
  if ((assert_failed == 0) && (assert_failed = (int)(id == (timer_id_T *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
    errline = 0x6b;
    elinks_internal((uchar *)"assertion id != NULL failed!");
  }
  p = *id;
  if (p != (timer_id_T)0x0) {
    p->next->prev = p->prev;
    p->prev->next = p->next;
    mem_free(p);
    *id = (timer_id_T)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void install_timer(timer_id_T *id,milliseconds_T delay,_func_void_void_ptr *func,void *data)

{
  timer_id_T ptVar1;
  timer *new_timer;
  int iVar2;
  timer *timer;
  list_head_elinks *plVar3;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(delay < 1 || id == (timer_id_T *)0x0),
     delay < 1 || id == (timer_id_T *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
    errline = 0x54;
    elinks_internal((uchar *)"assertion id && delay > 0 failed!");
  }
  ptVar1 = (timer_id_T)mem_alloc(0x18);
  *id = ptVar1;
  if (ptVar1 != (timer_id_T)0x0) {
    timeval_from_milliseconds(&ptVar1->interval,delay);
    ptVar1->func = func;
    ptVar1->data = data;
    plVar3 = (list_head_elinks *)timers.next;
    if ((list_head_elinks *)timers.next != &timers) {
      do {
        iVar2 = timeval_cmp((timeval_T *)(plVar3 + 1),&ptVar1->interval);
        if (-1 < iVar2) break;
        plVar3 = (list_head_elinks *)plVar3->next;
      } while (plVar3 != &timers);
    }
                    // WARNING: Load size is inaccurate
    ptVar1->next = *plVar3->prev;
    ptVar1->prev = (timer *)plVar3->prev;
    *(timer_id_T *)plVar3->prev = ptVar1;
    ptVar1->next->prev = ptVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void check_timers(timeval_T *last_time)

{
  list_head_elinks *p;
  int iVar1;
  timer *timer;
  list_head_elinks *plVar2;
  timeval_T interval;
  timeval_T now;
  
  timeval_now(&now);
  timeval_sub(&interval,last_time,&now);
  plVar2 = (list_head_elinks *)timers.next;
  if ((list_head_elinks *)timers.next != &timers) {
    do {
      timeval_sub_interval((timeval_T *)(plVar2 + 1),&interval);
      plVar2 = (list_head_elinks *)plVar2->next;
      p = (list_head_elinks *)timers.next;
    } while (plVar2 != &timers);
    while ((timers.next = p, p != &timers &&
           (iVar1 = timeval_is_positive((timeval_T *)(p + 1)), iVar1 == 0))) {
      *(void **)((int)p->next + 4) = p->prev;
      *(void **)p->prev = p->next;
      (*(code *)p[2].next)(p[2].prev);
      mem_free(p);
      check_bottom_halves();
      p = (list_head_elinks *)timers.next;
    }
  }
  last_time->sec = now.sec;
  last_time->usec = now.usec;
  return;
}



// WARNING: Unknown calling convention

void add_module_to_string(string *string,module *module,terminal *term)

{
  int iVar1;
  int new_charset;
  uchar *codeset;
  uchar *msgid;
  int i;
  module *submodule;
  module *module_00;
  
  msgid = module->name;
  if (msgid != (uchar *)0x0) {
    if (*msgid != '\0') {
      if (term != (terminal *)0x0) {
        iVar1 = get_terminal_codepage(term);
        if (iVar1 != current_charset) {
          codeset = get_cp_mime_name(iVar1);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = iVar1;
        }
      }
      msgid = gettext(msgid);
    }
    add_to_string(string,msgid);
  }
  if (module->submodules != (module **)0x0) {
    add_to_string(string," (");
    if ((module->submodules != (module **)0x0) &&
       (module_00 = *module->submodules, module_00 != (module *)0x0)) {
      iVar1 = 0;
      while( true ) {
        iVar1 = iVar1 + 1;
        add_module_to_string(string,module_00,term);
        module_00 = module->submodules[iVar1];
        if (module_00 == (module *)0x0) break;
        if (iVar1 != 0) {
          add_to_string(string,", ");
        }
      }
    }
    add_to_string(string,")");
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_dyn_full_version(terminal *term,int more)

{
  string *psVar1;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  int new_charset_1;
  uchar *puVar4;
  int new_charset_2;
  uchar *puVar5;
  uchar *last_pos;
  char *pcVar6;
  int new_charset_3;
  int i;
  module *module;
  module *module_00;
  uchar *pos;
  char *pcVar7;
  int start_at;
  string string;
  
  psVar1 = init_string(&string);
  puVar4 = (uchar *)0x0;
  if (psVar1 != (string *)0x0) {
    add_format_to_string(&string,(uchar *)"ELinks %s","0.12pre5");
    if (*build_id != '\0') {
      add_char_to_string(&string,(-(more == 0) & 0x16U) + 10);
      add_format_to_string(&string,"%s",build_id);
    }
    add_char_to_string(&string,'\n');
    puVar5 = build_time;
    puVar4 = build_date;
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Built on %s %s");
    add_format_to_string(&string,puVar3,puVar4,puVar5);
    if (more != 0) {
      add_to_string(&string,"\n\n");
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar2;
      }
      puVar4 = gettext((uchar *)"Text WWW browser");
      add_to_string(&string,puVar4);
    }
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar4 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = iVar2;
    }
    puVar4 = gettext((uchar *)"Standard");
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar5 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar2;
    }
    puVar5 = gettext((uchar *)"Features:");
    iVar2 = 0;
    string_concat(&string,&DAT_081281ca,puVar5,&DAT_08131ec3,puVar4,", ",&DAT_08131634,", ","gzip",
                  ", ","bzip2",", ","UTF-8",", ",0);
    module_00 = builtin_modules[0];
    if (builtin_modules[0] != (module *)0x0) {
      while( true ) {
        iVar2 = iVar2 + 1;
        add_module_to_string(&string,module_00,term);
        module_00 = builtin_modules[iVar2];
        if (module_00 == (module *)0x0) break;
        if (iVar2 != 0) {
          add_to_string(&string,", ");
        }
      }
    }
    puVar5 = string.source;
    puVar4 = string.source;
    if (more == 0) {
      pcVar7 = (char *)0x0;
      pcVar6 = strrchr((char *)string.source,10);
      if (pcVar6 != (char *)0x0) {
        pcVar7 = pcVar6 + (1 - (int)puVar5);
      }
      if (assert_failed != 0) {
        assert_failed = 0;
        return puVar5;
      }
      if ((puVar5 == (uchar *)0x0) || (string.length <= (int)pcVar7)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/version.c";
        errline = 0x43;
        elinks_internal((uchar *)
                        "assertion string && string->source && start_at < string->length failed!");
        puVar5 = string.source;
        if (assert_failed != 0) {
          assert_failed = 0;
          return string.source;
        }
      }
      else {
        assert_failed = 0;
      }
      puVar5 = puVar5 + (int)pcVar7;
      pcVar7 = (char *)0x0;
      puVar3 = puVar5;
      do {
        pcVar6 = strchr((char *)puVar5,0x20);
        if (pcVar6 == (char *)0x0) {
          return string.source;
        }
        if ((int)pcVar6 - (int)puVar3 < 0x48) {
          puVar5 = (uchar *)(pcVar6 + 1);
        }
        else {
          if (pcVar7 != (char *)0x0) {
            *pcVar7 = '\n';
          }
          puVar5 = (uchar *)(pcVar7 + 1);
          pcVar6 = pcVar7;
          puVar3 = puVar5;
        }
        pcVar7 = pcVar6;
        puVar4 = string.source;
      } while (*puVar5 != '\0');
    }
  }
  return puVar4;
}



// WARNING: Unknown calling convention

void init_static_version(void)

{
  uchar *src;
  uchar *s;
  
  src = get_dyn_full_version((terminal *)0x0,0);
  if (src != (uchar *)0x0) {
    safe_strncpy(full_static_version,src,0x400);
    mem_free(src);
  }
  return;
}



// WARNING: Unknown calling convention

void menu_list_ext(terminal *term,void *fn_,void *xxx)

{
  list_head_elinks *plVar1;
  option_value *poVar2;
  string *psVar3;
  size_t len;
  uchar *puVar4;
  uchar *rtext;
  uchar *optptr2;
  int iVar5;
  option_elinks *opt;
  list_head_elinks *plVar6;
  uchar *translated2;
  char *pcVar7;
  char *pcVar8;
  bool bVar9;
  byte bVar10;
  string translated;
  menu_item *local_20 [4];
  
  bVar10 = 0;
  poVar2 = get_opt_();
  plVar1 = poVar2->tree;
  local_20[0] = (menu_item *)0x0;
  plVar6 = (list_head_elinks *)plVar1->prev;
  bVar9 = plVar6 == plVar1;
  if (!bVar9) {
LAB_080b6874:
    do {
      iVar5 = 0xb;
      pcVar7 = (char *)plVar6[1].prev;
      pcVar8 = "_template_";
      do {
        if (iVar5 == 0) break;
        iVar5 = iVar5 + -1;
        bVar9 = *pcVar7 == *pcVar8;
        pcVar7 = pcVar7 + (uint)bVar10 * -2 + 1;
        pcVar8 = pcVar8 + (uint)bVar10 * -2 + 1;
      } while (bVar9);
      if (!bVar9) {
        psVar3 = init_string(&translated);
        if (psVar3 != (string *)0x0) {
          puVar4 = (uchar *)plVar6[1].prev;
          len = strlen((char *)puVar4);
          psVar3 = add_string_replace(&translated,puVar4,len,'*','.');
          if (psVar3 != (string *)0x0) {
            if ((local_20[0] == (menu_item *)0x0) &&
               (local_20[0] = new_menu(FREE_LIST|FREE_TEXT|FREE_RTEXT|FREE_DATA|NO_INTL),
               local_20[0] == (menu_item *)0x0)) {
              done_string(&translated);
              return;
            }
            puVar4 = memacpy(translated.source,translated.length);
            rtext = stracpy((uchar *)plVar6[4].next);
            if (rtext == (uchar *)0x0) {
              if (puVar4 != (uchar *)0x0) {
                mem_free(puVar4);
              }
            }
            else {
              if (puVar4 != (uchar *)0x0) {
                add_to_menu(local_20,translated.source,rtext,ACT_MAIN_NONE,(menu_func_T)fn_,puVar4,
                            NO_FLAG);
                goto LAB_080b6868;
              }
              mem_free(rtext);
            }
            done_string(&translated);
            plVar6 = (list_head_elinks *)plVar6->prev;
            bVar9 = plVar6 == plVar1;
            if (bVar9) break;
            goto LAB_080b6874;
          }
        }
        done_string(&translated);
      }
LAB_080b6868:
      plVar6 = (list_head_elinks *)plVar6->prev;
      bVar9 = plVar6 == plVar1;
    } while (!bVar9);
    if (local_20[0] != (menu_item *)0x0) goto LAB_080b6933;
  }
  local_20[0] = mi_no_ext;
LAB_080b6933:
  do_menu(term,local_20[0],(void *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

option_elinks * get_real_opt(uchar *base,uchar *id)

{
  option_elinks *tree;
  string *psVar1;
  size_t len;
  option_elinks *opt;
  string translated;
  
  tree = get_opt_rec_real(config_options,base);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(tree == (option_elinks *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/dialogs.c";
    errline = 0x1d;
    elinks_internal((uchar *)"assertion opt failed!");
  }
  psVar1 = init_string(&translated);
  if (psVar1 != (string *)0x0) {
    len = strlen((char *)id);
    psVar1 = add_string_replace(&translated,id,len,'.','*');
    if (psVar1 != (string *)0x0) {
      tree = get_opt_rec_real(tree,translated.source);
    }
  }
  done_string(&translated);
  return tree;
}



// WARNING: Unknown calling convention

void really_del_ext(void *fcp)

{
  option_elinks *option_elinks;
  option_elinks *opt;
  
  option_elinks = get_real_opt((uchar *)"mime.extension",(uchar *)fcp);
  if (option_elinks != (option_elinks *)0x0) {
    delete_option(option_elinks);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void add_mime_extension(void *data)

{
  string *psVar1;
  size_t len;
  option_value *poVar2;
  option_elinks *option_elinks;
  string name;
  
  if (data != (void *)0x0) {
    psVar1 = init_string(&name);
    if (psVar1 != (string *)0x0) {
      add_to_string(&name,(uchar *)"mime.extension.");
      len = strlen((char *)(uchar *)((int)data + 0x400));
      add_string_replace(&name,(uchar *)((int)data + 0x400),len,'.','*');
      really_del_ext(data);
      poVar2 = get_opt_();
      safe_strncpy(poVar2->string,(uchar *)((int)data + 0x800),0x400);
      option_elinks = get_opt_rec(config_options,name.source);
      option_changed((session *)0x0,option_elinks);
      done_string(&name);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void menu_del_ext(terminal *term,void *fcp,void *xxx2)

{
  option_elinks *poVar1;
  option_elinks *opt;
  uchar *text;
  memory_list *ml;
  
  if (fcp != (void *)0x0) {
    poVar1 = get_real_opt((uchar *)"mime.extension",(uchar *)fcp);
    if (poVar1 == (option_elinks *)0x0) {
      mem_free(fcp);
      return;
    }
    text = msg_text(term,(uchar *)"Delete extension %s -> %s?",fcp,(poVar1->value).tree);
    ml = getml(fcp,0);
    msg_box(term,ml,MSGBOX_FREE_TEXT,(uchar *)"Delete extension",ALIGN_CENTER,text,fcp,2,
            &DAT_0812762b,really_del_ext,1,&DAT_08127627,0,2);
  }
  return;
}



// WARNING: Unknown calling convention

void menu_add_ext(terminal *term,void *fcp,void *xxx2)

{
  dialog *dlg_00;
  dialog *dlg;
  int *dst;
  option_elinks *poVar1;
  option_elinks *opt;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  memory_list *ml;
  
  dlg_00 = (dialog *)mem_calloc(1,0xce4);
  if (dlg_00 != (dialog *)0x0) {
    dst = &dlg_00[2].widgets[0].info.checkbox.gnum;
    if (fcp != (void *)0x0) {
      poVar1 = get_real_opt((uchar *)"mime.extension",(uchar *)fcp);
      if (poVar1 != (option_elinks *)0x0) {
        safe_strncpy((uchar *)((int)&dlg_00[0xe].widgets[0].info + 0x14),(uchar *)fcp,0x400);
        safe_strncpy((uchar *)&dlg_00[0x1b].udata2,(poVar1->value).string,0x400);
        safe_strncpy((uchar *)dst,(uchar *)fcp,0x400);
      }
      mem_free(fcp);
    }
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Extension");
    dlg_00->title = puVar3;
    dlg_00->layouter = generic_dialog_layouter;
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Extension(s)");
    add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar3,0,0,check_nonempty,0x400,
                     (void *)((int)&dlg_00[0xe].widgets[0].info + 0x14),(input_history *)0x0,
                     INPFIELD_NONE);
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"Content-Type");
    add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar3,0,0,check_nonempty,0x400,&dlg_00[0x1b].udata2,
                     (input_history *)0x0,INPFIELD_NONE);
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext("~OK");
    add_dlg_button_do(dlg_00,puVar3,1,ok_dialog,(void *)0x0,add_mime_extension,dst);
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"~Cancel");
    add_dlg_button_do(dlg_00,puVar3,2,cancel_dialog,(void *)0x0,(done_handler_T *)0x0,(void *)0x0);
    if ((assert_failed == 0) &&
       (assert_failed = (int)(dlg_00->number_of_widgets != 4), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/dialogs.c";
      errline = 0x87;
      elinks_internal((uchar *)"assertion 4 == (dlg)->number_of_widgets failed!");
    }
    ml = getml(dlg_00,0);
    do_dialog(term,dlg_00,ml);
    return;
  }
  if (fcp == (void *)0x0) {
    return;
  }
  mem_free(fcp);
  return;
}



// WARNING: Unknown calling convention

uchar * get_content_filename(uri *uri,cache_entry *cached)

{
  uchar *puVar1;
  size_t sVar2;
  uchar *__s;
  uchar *pos;
  uchar *local_10;
  
  if ((((cached == (cache_entry *)0x0) &&
       (cached = find_in_cache(uri), cached == (cache_entry *)0x0)) ||
      (cached->head == (uchar *)0x0)) ||
     (puVar1 = parse_header(cached->head,(uchar *)"Content-Disposition",(uchar **)0x0),
     puVar1 == (uchar *)0x0)) {
    pos = (uchar *)0x0;
  }
  else {
    parse_header_param(puVar1,(uchar *)"filename",&local_10);
    mem_free(puVar1);
    puVar1 = local_10;
    pos = local_10;
    if (local_10 != (uchar *)0x0) {
      if (*local_10 == '\"') {
        sVar2 = strlen((char *)local_10);
        if ((1 < (int)sVar2) && (puVar1[sVar2 - 1] == '\"')) {
          puVar1[sVar2 - 1] = '\0';
          memmove(local_10,local_10 + 1,sVar2);
          puVar1 = local_10;
        }
        if (puVar1[1] == '\0') {
          mem_free(puVar1);
          return (uchar *)0x0;
        }
      }
      __s = get_filename_position(puVar1);
      puVar1 = local_10;
      if (*__s == '\0') {
        pos = (uchar *)0x0;
        mem_free(local_10);
      }
      else {
        pos = local_10;
        if (local_10 < __s) {
          sVar2 = strlen((char *)__s);
          memmove(puVar1,__s,sVar2 + 1);
          pos = local_10;
        }
      }
    }
  }
  return pos;
}



// WARNING: Unknown calling convention

string * add_mime_filename_to_string(string *string,uri *uri)

{
  uchar *cmd;
  size_t cmdlen;
  uchar *filename;
  
  cmd = get_content_filename(uri,(cache_entry *)0x0);
  if ((assert_failed == 0) && (assert_failed = (int)(uri->data == (uchar *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/mime.c";
    errline = 0x14b;
    elinks_internal((uchar *)"assertion uri->data failed!");
  }
  if (cmd == (uchar *)0x0) {
    string = add_uri_to_string(string,uri,URI_FILENAME);
  }
  else {
    cmdlen = strlen((char *)cmd);
    add_shell_safe_to_string(string,cmd,cmdlen);
    mem_free(cmd);
  }
  return string;
}



// WARNING: Unknown calling convention

mime_handler * get_mime_type_handler(uchar *content_type,int xwin)

{
  mime_handler *pmVar1;
  uchar *in_stack_00000004;
  
  pmVar1 = get_mime_handler_backends(in_stack_00000004,xwin);
  return pmVar1;
}



// WARNING: Unknown calling convention

uchar * get_extension_content_type(uchar *extension)

{
  uchar *puVar1;
  uchar *ctype;
  uchar *last_extension;
  stream_encoding encoding_00;
  char *__s2;
  uchar *puVar2;
  mime_handler *p;
  mime_handler *handler;
  uchar **ppuVar3;
  int iVar4;
  stream_encoding encoding;
  
  if (assert_failed == 0) {
    if ((extension != (uchar *)0x0) && (*extension != '\0')) {
      assert_failed = 0;
      puVar1 = get_content_type_backends(extension);
      goto joined_r0x080b7316;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/mime.c";
    errline = 0xb3;
    elinks_internal((uchar *)"assertion extension && *extension failed!");
  }
  puVar1 = get_content_type_backends(extension);
joined_r0x080b7316:
  if (puVar1 == (uchar *)0x0) {
    encoding_00 = guess_encoding(extension);
    __s2 = strrchr((char *)extension,0x2e);
    if (__s2 != (char *)0x0) {
      if (encoding_00 != ENCODING_NONE) {
        ppuVar3 = listext_encoded(encoding_00);
        while( true ) {
          if ((ppuVar3 == (uchar **)0x0) || (*ppuVar3 == (uchar *)0x0)) goto LAB_080b73b1;
          iVar4 = strcmp((char *)*ppuVar3,__s2);
          if (iVar4 == 0) break;
          ppuVar3 = ppuVar3 + 1;
        }
        *__s2 = '\0';
        puVar2 = get_content_type_backends(extension);
        *__s2 = '.';
        if (puVar2 != (uchar *)0x0) {
          return puVar2;
        }
LAB_080b73b1:
        __s2 = strrchr((char *)extension,0x2e);
      }
      if ((__s2 != (char *)0x0) &&
         (puVar2 = straconcat((uchar *)"application/x-",__s2 + 1,0), puVar1 = puVar2,
         puVar2 != (uchar *)0x0)) {
        p = get_mime_handler_backends(puVar2,1);
        if (p == (mime_handler *)0x0) {
          puVar1 = (uchar *)0x0;
          mem_free(puVar2);
        }
        else {
          mem_free(p);
        }
      }
    }
  }
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * get_cache_header_content_type(cache_entry *cached)

{
  byte *pbVar1;
  uchar *puVar2;
  char *pcVar3;
  size_t sVar4;
  byte *pbVar5;
  byte *pbVar6;
  int ctypelen;
  int iVar7;
  uchar *extension;
  uchar *local_20;
  
  puVar2 = parse_header(cached->head,(uchar *)"Content-Type",(uchar **)0x0);
  if (puVar2 != (uchar *)0x0) {
    pcVar3 = strchr((char *)puVar2,0x3b);
    if (pcVar3 != (char *)0x0) {
      *pcVar3 = '\0';
    }
    sVar4 = strlen((char *)puVar2);
    if (sVar4 != 0) {
      iVar7 = sVar4 - 1;
      if (puVar2[iVar7] < 0x21) {
        pbVar1 = puVar2 + (sVar4 - 2);
        pbVar6 = puVar2 + iVar7;
        do {
          pbVar5 = pbVar1;
          *pbVar6 = 0;
          if (iVar7 == 0) break;
          iVar7 = iVar7 + -1;
          pbVar1 = pbVar5 + -1;
          pbVar6 = pbVar5;
        } while (*pbVar5 < 0x21);
      }
    }
    if (*puVar2 != '\0') {
      return puVar2;
    }
    mem_free(puVar2);
  }
  puVar2 = get_content_filename(cached->uri,cached);
  local_20 = (uchar *)0x0;
  if (puVar2 != (uchar *)0x0) {
    local_20 = get_extension_content_type(puVar2);
    mem_free(puVar2);
  }
  return local_20;
}



// WARNING: Unknown calling convention

uchar * get_content_type(cache_entry *cached)

{
  undefined *puVar1;
  uchar *ctype;
  uchar *puVar2;
  uchar *puVar3;
  size_t sVar4;
  int iVar5;
  char *pcVar6;
  uint len;
  uchar *sample;
  int iVar7;
  
  if (cached->content_type != (uchar *)0x0) {
    return cached->content_type;
  }
  if ((cached->head != (uchar *)0x0) &&
     (puVar2 = get_cache_header_content_type(cached), puVar2 != (uchar *)0x0)) {
    if (*puVar2 != '\0') goto LAB_080b75c3;
    mem_free(puVar2);
  }
  puVar3 = get_extension_from_uri(cached->uri);
  if (puVar3 != (uchar *)0x0) {
    sVar4 = strlen((char *)puVar3);
    iVar7 = sVar4 - 1;
    if (-1 < iVar7) {
      puVar2 = puVar3 + sVar4;
      do {
        while (iVar5 = c_isupper((uint)puVar2[-1]), iVar5 == 0) {
          puVar2 = puVar2 + -1;
          iVar7 = iVar7 + -1;
          if (iVar7 < 0) goto LAB_080b7577;
        }
        iVar5 = c_tolower((uint)puVar2[-1]);
        puVar2[-1] = (uchar)iVar5;
        puVar2 = puVar2 + -1;
        iVar7 = iVar7 + -1;
      } while (-1 < iVar7);
    }
LAB_080b7577:
    puVar2 = get_extension_content_type(puVar3);
    mem_free(puVar3);
    if (puVar2 != (uchar *)0x0) {
      if (*puVar2 != '\0') goto LAB_080b75c3;
      mem_free(puVar2);
    }
  }
  puVar1 = (undefined *)(cached->frag).next;
  if (((list_head_elinks *)puVar1 != &cached->frag) &&
     ((*(uint *)(puVar1 + 0xc) | *(uint *)(puVar1 + 8)) == 0)) {
    len = *(uint *)(puVar1 + 0x10);
    if ((-1 < *(int *)(puVar1 + 0x14)) && ((0 < *(int *)(puVar1 + 0x14) || (0x400 < len)))) {
      len = 0x400;
    }
    puVar3 = memacpy(puVar1 + 0x20,len);
    if (puVar3 != (uchar *)0x0) {
      pcVar6 = c_strcasestr((char *)puVar3,"<html>");
      if (pcVar6 == (char *)0x0) {
        mem_free(puVar3);
      }
      else {
        puVar2 = stracpy((uchar *)"text/html");
        mem_free(puVar3);
        if ((puVar2 != (uchar *)0x0) && (*puVar2 != '\0')) goto LAB_080b75c3;
      }
    }
  }
  puVar2 = stracpy(mime_options[1].option_elinks.value.string);
LAB_080b75c3:
  cached->content_type = puVar2;
  return puVar2;
}



// WARNING: Unknown calling convention

uchar * get_content_type_backends(uchar *extension)

{
  mime_backend *pmVar1;
  mime_backend *backend;
  uchar *puVar2;
  uchar *content_type;
  int iVar3;
  int i;
  
  pmVar1 = &default_mime_backend;
  iVar3 = 0;
  while ((pmVar1->get_content_type == (_func_uchar_ptr_uchar_ptr *)0x0 ||
         (puVar2 = (*pmVar1->get_content_type)(extension), puVar2 == (uchar *)0x0))) {
    iVar3 = iVar3 + 1;
    pmVar1 = mime_backends[iVar3];
    if (pmVar1 == (mime_backend *)0x0) {
      return (uchar *)0x0;
    }
  }
  return puVar2;
}



// WARNING: Unknown calling convention

mime_handler * get_mime_handler_backends(uchar *ctype,int have_x)

{
  mime_backend *pmVar1;
  mime_backend *backend;
  mime_handler *pmVar2;
  mime_handler *handler;
  int iVar3;
  int i;
  
  pmVar1 = &default_mime_backend;
  iVar3 = 0;
  while ((pmVar1->get_mime_handler == (_func_mime_handler_ptr_uchar_ptr_int *)0x0 ||
         (pmVar2 = (*pmVar1->get_mime_handler)(ctype,have_x), pmVar2 == (mime_handler *)0x0))) {
    iVar3 = iVar3 + 1;
    pmVar1 = mime_backends[iVar3];
    if (pmVar1 == (mime_backend *)0x0) {
      return (mime_handler *)0x0;
    }
  }
  return pmVar2;
}



// WARNING: Unknown calling convention

mime_handler *
init_mime_handler(uchar *program,uchar *description,uchar *backend_name,int ask,int block)

{
  size_t __n;
  mime_handler *pmVar1;
  mime_handler *handler;
  
  __n = strlen((char *)program);
  pmVar1 = (mime_handler *)mem_calloc(1,__n + 0xc);
  if (pmVar1 != (mime_handler *)0x0) {
    memcpy(pmVar1->program,program,__n);
    if (description == (uchar *)0x0) {
      description = "";
    }
    pmVar1->description = description;
    pmVar1->backend_name = backend_name;
    pmVar1->field_0x8 = pmVar1->field_0x8 & 0xfc | ((byte)block & 1) * '\x02' | (byte)ask & 1;
  }
  return pmVar1;
}



// WARNING: Unknown calling convention

uchar * get_next_path_filename(uchar **path_ptr,uchar separator)

{
  uchar *puVar1;
  uchar *filename;
  uchar *puVar2;
  uchar *path;
  uchar *tmp;
  int local_30;
  
  puVar2 = *path_ptr;
  local_30 = 0;
  puVar1 = puVar2;
  if (*puVar2 == '\0') {
LAB_080b77cb:
    *path_ptr = puVar1;
  }
  else {
    if (*puVar2 != separator) {
      do {
        puVar1 = puVar1 + 1;
        if (*puVar1 == '\0') {
          local_30 = (int)puVar1 - (int)puVar2;
          goto LAB_080b77cb;
        }
      } while (*puVar1 != separator);
      local_30 = (int)puVar1 - (int)puVar2;
    }
    *path_ptr = puVar1 + 1;
  }
  if ((local_30 < 1) || (puVar2 = memacpy(puVar2,local_30), puVar2 == (uchar *)0x0)) {
    filename = (uchar *)0x0;
  }
  else {
    filename = expand_tilde(puVar2);
    mem_free(puVar2);
  }
  return filename;
}



// WARNING: Unknown calling convention

mime_handler * get_mime_handler_default(uchar *type,int have_x)

{
  int block;
  int ask;
  uchar *backend_name;
  option_elinks *poVar1;
  option_elinks *opt;
  string *psVar2;
  size_t len;
  char *pcVar3;
  option_elinks *poVar4;
  uchar *puVar5;
  option_value *poVar6;
  mime_handler *pmVar7;
  option_elinks *handler_opt;
  option_elinks *type_opt;
  string name;
  
  poVar1 = get_opt_rec_real(config_options,(uchar *)"mime.type");
  if (poVar1 != (option_elinks *)0x0) {
    psVar2 = init_string(&name);
    if (psVar2 != (string *)0x0) {
      len = strlen((char *)type);
      psVar2 = add_string_replace(&name,type,len,'.','*');
      if ((psVar2 == (string *)0x0) ||
         (pcVar3 = strchr((char *)name.source,0x2f), pcVar3 == (char *)0x0)) {
        done_string(&name);
        return (mime_handler *)0x0;
      }
      *pcVar3 = '.';
      poVar1 = get_opt_rec_real(poVar1,name.source);
      done_string(&name);
      if (poVar1 != (option_elinks *)0x0) {
        if (assert_failed == 0) {
          assert_failed = 0;
        }
        poVar4 = get_opt_rec_real(config_options,(uchar *)"mime.handler");
        if ((poVar4 != (option_elinks *)0x0) &&
           (poVar4 = get_opt_rec_real(poVar4,(poVar1->value).string), poVar4 != (option_elinks *)0x0
           )) {
          puVar5 = get_system_str(have_x);
          poVar4 = get_opt_rec_real(poVar4,puVar5);
          if (poVar4 != (option_elinks *)0x0) {
            poVar6 = get_opt_();
            block = poVar6->number;
            poVar6 = get_opt_();
            backend_name = default_mime_module.name;
            puVar5 = (poVar1->value).string;
            ask = poVar6->number;
            poVar6 = get_opt_();
            pmVar7 = init_mime_handler(poVar6->string,puVar5,backend_name,ask,block);
            return pmVar7;
          }
        }
      }
    }
  }
  return (mime_handler *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_content_type_default(uchar *extension)

{
  list_head_elinks *plVar1;
  uchar *__s;
  option_elinks *opt_tree;
  size_t sVar2;
  option_elinks *poVar3;
  list_head_elinks *plVar4;
  size_t sVar5;
  uchar *extpos;
  uchar *puVar6;
  uchar *puVar7;
  uchar uVar8;
  uchar *namepos;
  
  sVar2 = strlen((char *)extension);
  if (extension <= extension + (sVar2 - 1)) {
    poVar3 = get_opt_rec_real(config_options,(uchar *)"mime.extension");
    plVar1 = (poVar3->value).tree;
    plVar4 = plVar1;
    while (plVar4 = (list_head_elinks *)plVar4->next, plVar4 != plVar1) {
      __s = (uchar *)plVar4[1].prev;
      sVar5 = strlen((char *)__s);
      puVar7 = __s + (sVar5 - 1);
      puVar6 = extension + (sVar2 - 1);
      do {
        if (puVar7 < __s) goto LAB_080b7a5a;
        uVar8 = '.';
        if (*puVar7 != '*') {
          uVar8 = *puVar7;
        }
        if (*puVar6 != uVar8) break;
        puVar6 = puVar6 + -1;
        puVar7 = puVar7 + -1;
      } while (extension <= puVar6);
      if (puVar7 < __s) {
LAB_080b7a5a:
        if ((puVar6 < extension) || (*puVar6 == '.')) {
          puVar7 = stracpy((uchar *)plVar4[4].next);
          return puVar7;
        }
      }
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void done_mailcap_entry(mailcap_entry *entry)

{
  void *p;
  void *p_1;
  
  if (entry != (mailcap_entry *)0x0) {
    if (entry->testcommand != (uchar *)0x0) {
      mem_free(entry->testcommand);
    }
    if (entry->description != (uchar *)0x0) {
      mem_free(entry->description);
    }
    mem_free(entry);
  }
  return;
}



// WARNING: Unknown calling convention

void init_mailcap(module *module)

{
  option_value *poVar1;
  
  register_change_hooks(init_mailcap::mimetypes_change_hooks);
  poVar1 = get_opt_();
  if (poVar1->tree != (list_head_elinks *)0x0) {
    mailcap_options[1].option_elinks.value.tree = (list_head_elinks *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_mailcap_field(uchar **next)

{
  ushort **ppuVar1;
  byte *pbVar2;
  size_t sVar3;
  byte bVar4;
  uchar *fieldend;
  byte *pbVar5;
  byte *__s;
  uchar *field;
  
  __s = (byte *)0x0;
  if ((next != (uchar **)0x0) && (__s = *next, __s != (byte *)0x0)) {
    ppuVar1 = __ctype_b_loc();
    while (bVar4 = *__s, pbVar2 = __s, (*(byte *)((int)*ppuVar1 + (uint)bVar4 * 2 + 1) & 0x20) != 0)
    {
      __s = __s + 1;
    }
    while (pbVar2 = (byte *)strchr((char *)(pbVar2 + (bVar4 == 0x3b)),0x3b), pbVar2 != (byte *)0x0)
    {
      pbVar5 = pbVar2 + -1;
      if (pbVar2[-1] != 0x5c) {
        *pbVar2 = 0;
        *next = pbVar2 + 1;
        if ((*(byte *)((int)*ppuVar1 + (uint)pbVar2[1] * 2 + 1) & 0x20) != 0) {
          pbVar2 = pbVar2 + 2;
          do {
            *next = pbVar2;
            bVar4 = *pbVar2;
            pbVar2 = pbVar2 + 1;
          } while ((*(byte *)((int)*ppuVar1 + (uint)bVar4 * 2 + 1) & 0x20) != 0);
        }
        goto joined_r0x080b7bc6;
      }
      bVar4 = *pbVar2;
    }
    *next = (uchar *)0x0;
    sVar3 = strlen((char *)__s);
    pbVar5 = __s + (sVar3 - 1);
joined_r0x080b7bc6:
    for (; __s <= pbVar5; pbVar5 = pbVar5 + -1) {
      if ((*(byte *)((int)*ppuVar1 + (uint)*pbVar5 * 2 + 1) & 0x20) == 0) {
        return __s;
      }
      *pbVar5 = 0;
    }
  }
  return __s;
}



// WARNING: Unknown calling convention

uchar * get_mailcap_field_text(uchar *field)

{
  byte bVar1;
  ushort *puVar2;
  ushort **ppuVar3;
  byte *src;
  uchar *puVar4;
  
  ppuVar3 = __ctype_b_loc();
  puVar2 = *ppuVar3;
  while ((*(byte *)((int)puVar2 + (uint)*field * 2 + 1) & 0x20) != 0) {
    field = field + 1;
  }
  if (*field == 0x3d) {
    src = field + 1;
    bVar1 = *(byte *)((int)puVar2 + (uint)field[1] * 2 + 1);
    while ((bVar1 & 0x20) != 0) {
      src = src + 1;
      bVar1 = *(byte *)((int)puVar2 + (uint)*src * 2 + 1);
    }
    puVar4 = stracpy(src);
    return puVar4;
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * format_command(uchar *command,uchar *type,int copiousoutput)

{
  uint uVar1;
  uchar uVar2;
  string *psVar3;
  uint uVar4;
  uchar *puVar5;
  char *source;
  int newlength;
  int iVar6;
  size_t newsize;
  uint size;
  uchar *pager;
  uchar *puVar7;
  uchar *puVar8;
  size_t __n;
  bool bVar9;
  byte bVar10;
  string cmd;
  uchar *__src;
  
  bVar10 = 0;
  psVar3 = init_string(&cmd);
  if (psVar3 == (string *)0x0) {
    return (uchar *)0x0;
  }
LAB_080b7ca8:
  uVar2 = *command;
  __src = command;
LAB_080b7cb0:
  if (uVar2 == '\0') goto LAB_080b7dc6;
  puVar8 = __src;
  if (uVar2 == '%') {
joined_r0x080b7e29:
    __src = puVar8;
    if (uVar2 != '\'') {
      if (uVar2 == '\\') goto LAB_080b7db8;
      if (uVar2 == '%') {
        uVar2 = __src[1];
        if (uVar2 == '\0') {
LAB_080b7f59:
          done_string(&cmd);
          return (uchar *)0x0;
        }
        if (uVar2 == 's') {
          add_char_to_string(&cmd,'%');
        }
        else if (uVar2 == 't') {
          if (type == (uchar *)0x0) goto LAB_080b7f59;
          add_to_string(&cmd,type);
        }
        uVar2 = __src[2];
        __src = __src + 2;
      }
      goto LAB_080b7cb0;
    }
  }
  else {
    if (uVar2 == '\\') goto LAB_080b7db8;
    if (uVar2 != '\'') {
      do {
        puVar8 = puVar8 + 1;
        uVar2 = *puVar8;
        if (((uVar2 == '%') || (uVar2 == '\0')) || (uVar2 == '\\')) break;
      } while (uVar2 != '\'');
      if (__src < puVar8) {
        if (assert_failed == 0) {
          __n = (int)puVar8 - (int)__src;
          if ((__src == (uchar *)0x0) || ((int)__n < 0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080b7e18;
          }
          else {
            assert_failed = 0;
          }
          if (__n != 0) {
            iVar6 = __n + cmd.length;
            uVar1 = cmd.length + 0xffU >> 8;
            uVar4 = cmd.length + 0xffU & 0xffffff00;
            size = iVar6 + 0x100U & 0xffffff00;
            if (uVar4 <= size && size + uVar1 * -0x100 != 0) {
              puVar5 = (uchar *)mem_realloc(cmd.source,size);
              if (puVar5 == (uchar *)0x0) {
                uVar2 = *puVar8;
                goto joined_r0x080b7e29;
              }
              cmd.source = puVar5;
              memset(puVar5 + uVar4,0,size + uVar1 * -0x100);
            }
            if (cmd.source != (uchar *)0x0) {
              memcpy(cmd.source + cmd.length,__src,__n);
              cmd.source[iVar6] = '\0';
              cmd.length = iVar6;
            }
          }
          uVar2 = *puVar8;
        }
        else {
LAB_080b7e18:
          assert_failed = 0;
          uVar2 = *puVar8;
        }
      }
      goto joined_r0x080b7e29;
    }
  }
  puVar7 = __src + 1;
  bVar9 = puVar7 == (uchar *)0x0;
  iVar6 = 3;
  puVar8 = puVar7;
  puVar5 = "%s\'";
  do {
    if (iVar6 == 0) break;
    iVar6 = iVar6 + -1;
    bVar9 = *puVar8 == *puVar5;
    puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
    puVar5 = puVar5 + (uint)bVar10 * -2 + 1;
  } while (bVar9);
  if (bVar9) {
    add_char_to_string(&cmd,'%');
    uVar2 = __src[4];
    __src = __src + 4;
  }
  else {
    add_char_to_string(&cmd,'\'');
    uVar2 = *puVar7;
    __src = puVar7;
  }
  goto LAB_080b7cb0;
LAB_080b7db8:
  if (__src[1] == '\0') {
LAB_080b7dc6:
    if (copiousoutput == 0) {
      return cmd.source;
    }
    source = getenv("PAGER");
    if ((uchar *)source == (uchar *)0x0) {
      source = "/usr/bin/pager";
      iVar6 = file_exists((uchar *)"/usr/bin/pager");
      if (iVar6 == 0) {
        source = "/usr/bin/less";
        iVar6 = file_exists((uchar *)"/usr/bin/less");
        if (iVar6 == 0) {
          source = "/usr/bin/more";
          iVar6 = file_exists((uchar *)"/usr/bin/more");
          if (iVar6 == 0) {
            return cmd.source;
          }
        }
      }
    }
    add_char_to_string(&cmd,'|');
    add_to_string(&cmd,(uchar *)source);
    return cmd.source;
  }
  command = __src + 2;
  add_char_to_string(&cmd,__src[1]);
  goto LAB_080b7ca8;
}



// WARNING: Unknown calling convention

mailcap_entry * check_entries(mailcap_hash_item *item)

{
  mailcap_entry *pmVar1;
  uchar *path;
  int iVar2;
  int exitcode;
  mailcap_entry *entry;
  uchar *test;
  
  pmVar1 = (mailcap_entry *)(item->entries).next;
  while( true ) {
    if (pmVar1 == (mailcap_entry *)item) {
      return (mailcap_entry *)0x0;
    }
    if (pmVar1->testcommand == (uchar *)0x0) break;
    path = format_command(pmVar1->testcommand,(uchar *)0x0,0);
    if (path != (uchar *)0x0) {
      iVar2 = exe(path);
      mem_free(path);
      if (iVar2 == 0) {
        return pmVar1;
      }
    }
    pmVar1 = (mailcap_entry *)((list_head_elinks *)&pmVar1->next)->next;
  }
  return pmVar1;
}



// WARNING: Unknown calling convention

void done_mailcap(module *module)

{
  int **p_00;
  int **p_01;
  void *p;
  void *p_1;
  hash *phVar1;
  hash *phVar2;
  mailcap_hash_item *mitem;
  hash_item *item;
  int *piVar3;
  int local_24;
  
  if (mailcap_map == (hash *)0x0) {
    return;
  }
  if (0 < 1 << ((byte)mailcap_map->width & 0x1f)) {
    local_24 = 0;
    phVar1 = mailcap_map;
    phVar2 = mailcap_map;
    do {
      piVar3 = (int *)phVar2->hash[local_24].next;
      if ((list_head_elinks *)piVar3 != phVar2->hash + local_24) {
        do {
          p_00 = (int **)piVar3[4];
          if (p_00 != (int **)0x0) {
            while (p_01 = (int **)*p_00, p_01 != p_00) {
              (*p_01)[1] = (int)p_01[1];
              *p_01[1] = (int)*p_01;
              if (p_01[2] != (int *)0x0) {
                mem_free(p_01[2]);
              }
              if (p_01[3] != (int *)0x0) {
                mem_free(p_01[3]);
              }
              mem_free(p_01);
            }
            mem_free(p_00);
            phVar1 = mailcap_map;
          }
          piVar3 = (int *)*piVar3;
          phVar2 = phVar1;
        } while (phVar1->hash + local_24 != (list_head_elinks *)piVar3);
      }
      local_24 = local_24 + 1;
    } while (local_24 < 1 << ((byte)phVar2->width & 0x1f));
  }
  free_hash(&mailcap_map);
  return;
}



// WARNING: Unknown calling convention

int change_hook_mailcap(session *ses,option_elinks *current,option_elinks *changed)

{
  if (((option_info *)changed != mailcap_options + 2) &&
     (((option_info *)changed != mailcap_options + 1 ||
      (mailcap_options[1].option_elinks.value.tree != (list_head_elinks *)0x0)))) {
    return 0;
  }
  done_mailcap(&mailcap_mime_module);
  return 0;
}



// WARNING: Unknown calling convention

mime_handler * get_mime_handler_mailcap(uchar *type,int options)

{
  hash *hash;
  uchar uVar1;
  size_t sVar2;
  hash_item *phVar3;
  hash_item *item;
  mailcap_entry *pmVar4;
  mailcap_entry *entry;
  uchar *puVar5;
  uchar *program;
  char *pcVar6;
  mime_handler *handler;
  FILE *file;
  uchar *key;
  uchar *puVar7;
  int iVar8;
  hash_item *item_1;
  hash_item *item_2;
  void *p_1;
  void *p;
  uint keylen;
  void *p_2;
  void *p_3;
  mailcap_entry *pmVar9;
  void *value;
  uchar *puVar10;
  uchar *command;
  uchar *field;
  mailcap_entry *entry_1;
  uchar *wildtype;
  int wildlen;
  int in_GS_OFFSET;
  uint local_94;
  uchar *local_80;
  uchar *local_74;
  uchar *local_70;
  int local_6c;
  size_t local_68;
  option_value local_64;
  uchar implicitwild [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (mailcap_options[1].option_elinks.value.tree != (list_head_elinks *)0x0) {
    if (mailcap_map == (hash *)0x0) {
      mailcap_map = init_hash8();
      if (mailcap_map != (hash *)0x0) {
        local_64 = mailcap_options[2].option_elinks.value;
        if ((mailcap_options[2].option_elinks.value.tree == (list_head_elinks *)0x0) ||
           (uVar1 = *mailcap_options[2].option_elinks.value.string, uVar1 == '\0')) {
          local_64.string = (uchar *)getenv("MAILCAP");
          if (local_64.tree == (list_head_elinks *)0x0) {
            local_64.tree = (list_head_elinks *)0x811ed68;
            uVar1 = '~';
          }
          else {
            uVar1 = *local_64.string;
          }
        }
        local_94 = 0;
        while (uVar1 != '\0') {
          puVar5 = get_next_path_filename(&local_64.string,':');
          if (puVar5 != (uchar *)0x0) {
            file = fopen64((char *)puVar5,"rb");
            local_68 = 0x400;
            local_6c = 1;
            if (file != (FILE *)0x0) {
              local_80 = (uchar *)0x0;
LAB_080b8320:
              local_80 = file_read_line(local_80,&local_68,(FILE *)file,&local_6c);
              if (local_80 != (uchar *)0x0) {
                if (((*local_80 != '#') &&
                    (local_70 = local_80, key = get_mailcap_field(&local_70), key != (uchar *)0x0))
                   && (puVar7 = get_mailcap_field(&local_70), puVar7 != (uchar *)0x0)) {
                  sVar2 = strlen((char *)puVar7);
                  pmVar4 = (mailcap_entry *)mem_calloc(1,sVar2 + 0x18);
                  if (pmVar4 != (mailcap_entry *)0x0) {
                    memcpy(pmVar4->command,puVar7,sVar2);
                    pmVar4->priority = local_94;
                    local_74 = local_70;
LAB_080b83d0:
                    puVar7 = get_mailcap_field(&local_74);
                    do {
                      if (puVar7 == (uchar *)0x0) {
                        pcVar6 = strchr((char *)key,0x2f);
                        sVar2 = strlen((char *)key);
                        if (pcVar6 == (char *)0x0) {
                          keylen = sVar2 + 3;
                          if (keylen < 0x41) {
                            __memcpy_chk(implicitwild,key,sVar2,0x40);
                            implicitwild[sVar2] = '/';
                            implicitwild[sVar2 + 1] = '*';
                            implicitwild[sVar2 + 2] = '\0';
                            item_2 = get_hash_item(mailcap_map,implicitwild,keylen);
                            if (item_2 != (hash_item *)0x0) goto LAB_080b8464;
                            value = mem_alloc(sVar2 + 0xf);
                            if (value == (void *)0x0) goto LAB_080b886a;
                            safe_strncpy((uchar *)((int)value + 8),implicitwild,sVar2 + 4);
                            *(void **)((int)value + 4) = value;
                            *(void **)value = value;
                            phVar3 = add_hash_item(mailcap_map,(uchar *)((int)value + 8),keylen,
                                                   value);
                            if (phVar3 == (hash_item *)0x0) {
                              mem_free(value);
                              done_mailcap_entry(pmVar4);
                            }
                            else {
LAB_080b846f:
                              pmVar4->next = **(mailcap_entry ***)((int)value + 4);
                              pmVar4->prev = *(mailcap_entry **)((int)value + 4);
                              **(mailcap_entry ***)((int)value + 4) = pmVar4;
                              pmVar4->next->prev = pmVar4;
                            }
                          }
                          else {
                            if (pmVar4->testcommand != (uchar *)0x0) {
                              mem_free(pmVar4->testcommand);
                            }
                            if (pmVar4->description != (uchar *)0x0) {
                              mem_free(pmVar4->description);
                            }
                            mem_free(pmVar4);
                          }
                        }
                        else {
                          item_2 = get_hash_item(mailcap_map,key,sVar2);
                          if (item_2 == (hash_item *)0x0) {
                            value = mem_alloc(sVar2 + 0xc);
                            if (value != (void *)0x0) {
                              safe_strncpy((uchar *)((int)value + 8),key,sVar2 + 1);
                              *(void **)((int)value + 4) = value;
                              *(void **)value = value;
                              phVar3 = add_hash_item(mailcap_map,(uchar *)((int)value + 8),sVar2,
                                                     value);
                              if (phVar3 != (hash_item *)0x0) goto LAB_080b846f;
                              mem_free(value);
                            }
                          }
                          else {
LAB_080b8464:
                            value = item_2->value;
                            if (value != (void *)0x0) goto LAB_080b846f;
                          }
LAB_080b886a:
                          done_mailcap_entry(pmVar4);
                        }
                        break;
                      }
                      iVar8 = c_strncasecmp((char *)puVar7,"needsterminal",0xd);
                      if (iVar8 != 0) goto LAB_080b8490;
                      pmVar4->field_0x14 = pmVar4->field_0x14 | 1;
                      puVar7 = get_mailcap_field(&local_74);
                    } while( true );
                  }
                }
                goto LAB_080b8320;
              }
              fclose(file);
            }
            local_94 = local_94 + 1;
            mem_free(puVar5);
          }
          uVar1 = *local_64.string;
        }
        if (mailcap_map != (hash *)0x0) goto LAB_080b818d;
      }
    }
    else {
LAB_080b818d:
      hash = mailcap_map;
      sVar2 = strlen((char *)type);
      phVar3 = get_hash_item(hash,type,sVar2);
      if ((phVar3 == (hash_item *)0x0) ||
         ((mailcap_hash_item *)phVar3->value == (mailcap_hash_item *)0x0)) {
        pmVar4 = (mailcap_entry *)0x0;
LAB_080b823a:
        pcVar6 = strchr((char *)type,0x2f);
        if (pcVar6 != (char *)0x0) {
          puVar5 = memacpy(type,(int)(pcVar6 + (3 - (int)type)));
          if (puVar5 == (uchar *)0x0) goto LAB_080b8260;
          puVar5[(int)(pcVar6 + (1 - (int)type))] = '*';
          puVar5[(int)(pcVar6 + (2 - (int)type))] = '\0';
          phVar3 = get_hash_item(mailcap_map,puVar5,(uint)(pcVar6 + (2 - (int)type)));
          mem_free(puVar5);
          if (((phVar3 != (hash_item *)0x0) &&
              ((mailcap_hash_item *)phVar3->value != (mailcap_hash_item *)0x0)) &&
             (pmVar9 = check_entries((mailcap_hash_item *)phVar3->value),
             pmVar9 != (mailcap_entry *)0x0)) {
            if ((pmVar4 == (mailcap_entry *)0x0) || (pmVar9->priority < pmVar4->priority)) {
              pmVar4 = pmVar9;
            }
            goto LAB_080b81d5;
          }
        }
        if (pmVar4 == (mailcap_entry *)0x0) goto LAB_080b8260;
      }
      else {
        pmVar4 = check_entries((mailcap_hash_item *)phVar3->value);
        if ((pmVar4 == (mailcap_entry *)0x0) ||
           (mailcap_options[5].option_elinks.value.tree != (list_head_elinks *)0x0))
        goto LAB_080b823a;
      }
LAB_080b81d5:
      puVar5 = format_command(pmVar4->command,type,(byte)pmVar4->field_0x14 >> 1 & 1);
      if (puVar5 != (uchar *)0x0) {
        handler = init_mime_handler(puVar5,pmVar4->description,mailcap_mime_module.name,
                                    mailcap_options[3].option_elinks.value.number,
                                    (uint)((pmVar4->field_0x14 & 3) != 0));
        mem_free(puVar5);
        goto LAB_080b8262;
      }
    }
  }
LAB_080b8260:
  handler = (mime_handler *)0x0;
LAB_080b8262:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return handler;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080b8490:
  iVar8 = c_strncasecmp((char *)puVar7,"copiousoutput",0xd);
  if (iVar8 == 0) {
    pmVar4->field_0x14 = pmVar4->field_0x14 | 2;
    goto LAB_080b83d0;
  }
  iVar8 = c_strncasecmp((char *)puVar7,"test",4);
  if (iVar8 == 0) {
    puVar7 = get_mailcap_field_text(puVar7 + 4);
    pmVar4->testcommand = puVar7;
    if (puVar7 == (uchar *)0x0) goto LAB_080b852a;
    uVar1 = *puVar7;
    puVar10 = puVar7;
    while (uVar1 != '\0') {
      puVar10 = puVar10 + 1;
      if (uVar1 == '%') {
        uVar1 = *puVar10;
        if (uVar1 == 's') {
          mem_free(puVar7);
          goto LAB_080b851b;
        }
      }
      else {
        uVar1 = *puVar10;
      }
    }
    goto LAB_080b83d0;
  }
  iVar8 = c_strncasecmp((char *)puVar7,"description",0xb);
  if (iVar8 != 0) goto LAB_080b83d0;
  puVar7 = get_mailcap_field_text(puVar7 + 0xb);
  pmVar4->description = puVar7;
  if (puVar7 == (uchar *)0x0) goto LAB_080b851b;
  goto LAB_080b83d0;
LAB_080b851b:
  if (pmVar4->testcommand != (uchar *)0x0) {
    mem_free(pmVar4->testcommand);
  }
LAB_080b852a:
  if (pmVar4->description != (uchar *)0x0) {
    mem_free(pmVar4->description);
  }
  mem_free(pmVar4);
  iVar8 = local_6c;
  puVar7 = gettext((uchar *)"Badly formated mailcap entry for type %s in \"%s\" line %d");
  usrerror(puVar7,key,puVar5,iVar8);
  goto LAB_080b8320;
}



// WARNING: Unknown calling convention

void done_mimetypes_entry(mimetypes_entry *entry)

{
  void *p;
  
  if (entry != (mimetypes_entry *)0x0) {
    if (entry->content_type != (uchar *)0x0) {
      mem_free(entry->content_type);
    }
    mem_free(entry);
  }
  return;
}



// WARNING: Unknown calling convention

void done_mimetypes(module *module)

{
  hash *phVar1;
  hash *phVar2;
  hash_item *item;
  int *piVar3;
  int iVar4;
  int i;
  
  if (mimetypes_map == (hash *)0x0) {
    return;
  }
  if (0 < 1 << ((byte)mimetypes_map->width & 0x1f)) {
    iVar4 = 0;
    phVar1 = mimetypes_map;
    phVar2 = mimetypes_map;
    do {
      piVar3 = (int *)phVar1->hash[iVar4].next;
      if ((list_head_elinks *)piVar3 != phVar1->hash + iVar4) {
        do {
          phVar1 = phVar2;
          if ((mimetypes_entry *)piVar3[4] != (mimetypes_entry *)0x0) {
            done_mimetypes_entry((mimetypes_entry *)piVar3[4]);
            phVar1 = mimetypes_map;
          }
          piVar3 = (int *)*piVar3;
          phVar2 = phVar1;
        } while (phVar1->hash + iVar4 != (list_head_elinks *)piVar3);
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < 1 << ((byte)phVar1->width & 0x1f));
  }
  free_hash(&mimetypes_map);
  return;
}



// WARNING: Unknown calling convention

int change_hook_mimetypes(session *ses,option_elinks *current,option_elinks *changed)

{
  if (((option_info *)changed != mimetypes_options + 2) &&
     (((option_info *)changed != mimetypes_options + 1 ||
      (mimetypes_options[1].option_elinks.value.tree != (list_head_elinks *)0x0)))) {
    return 0;
  }
  done_mimetypes(&mimetypes_mime_module);
  return 0;
}



// WARNING: Unknown calling convention

void init_mimetypes(module *module)

{
  option_value *poVar1;
  
  register_change_hooks(init_mimetypes::mimetypes_change_hooks);
  poVar1 = get_opt_();
  if (poVar1->tree != (list_head_elinks *)0x0) {
    mimetypes_options[1].option_elinks.value.tree = (list_head_elinks *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void parse_mimetypes_file(uchar *filename)

{
  ushort *puVar1;
  FILE *__stream;
  char *pcVar2;
  ushort **ppuVar3;
  size_t len;
  hash_item *item;
  size_t keylen;
  hash_item *phVar4;
  mimetypes_entry *entry;
  uchar *puVar5;
  uchar *token;
  byte *pbVar6;
  byte *pbVar8;
  uchar *ctype;
  byte *src;
  int in_GS_OFFSET;
  uchar line [1024];
  int local_20;
  byte *pbVar7;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  __stream = fopen64((char *)filename,"rb");
  if (__stream != (FILE *)0x0) {
LAB_080b8a18:
    pcVar2 = fgets((char *)line,0x3ff,__stream);
    if (pcVar2 != (char *)0x0) {
      pcVar2 = strchr((char *)line,0x23);
      if (pcVar2 != (char *)0x0) {
        *pcVar2 = '\0';
      }
      ppuVar3 = __ctype_b_loc();
      src = line;
      while ((*(byte *)((int)*ppuVar3 + (uint)*src * 2 + 1) & 0x20) != 0) {
        src = src + 1;
      }
      pbVar6 = src;
      if (*src != 0) {
        do {
          pbVar7 = pbVar6;
          pbVar6 = pbVar7 + 1;
          if (*pbVar6 == 0) goto LAB_080b8a18;
        } while ((*(byte *)((int)*ppuVar3 + (uint)*pbVar6 * 2 + 1) & 0x20) == 0);
        *pbVar6 = 0;
        pcVar2 = strchr((char *)src,0x2f);
        if (pcVar2 != (char *)0x0) {
          len = strlen((char *)src);
LAB_080b8ae0:
          pbVar6 = pbVar7 + 2;
          if (*pbVar6 != 0) {
            puVar1 = *ppuVar3;
            pbVar8 = pbVar6;
            if ((*(byte *)((int)puVar1 + (uint)*pbVar6 * 2 + 1) & 0x20) != 0) {
              do {
                pbVar6 = pbVar6 + 1;
              } while ((*(byte *)((int)puVar1 + (uint)*pbVar6 * 2 + 1) & 0x20) != 0);
              pbVar8 = pbVar6;
              if (*pbVar6 == 0) goto LAB_080b8a18;
            }
            do {
              pbVar7 = pbVar8;
              pbVar8 = pbVar7 + 1;
              if (*pbVar8 == 0) goto LAB_080b8a18;
            } while ((*(byte *)((int)puVar1 + (uint)*pbVar8 * 2 + 1) & 0x20) == 0);
            *pbVar8 = 0;
            keylen = strlen((char *)pbVar6);
            phVar4 = get_hash_item(mimetypes_map,pbVar6,keylen);
            if ((phVar4 == (hash_item *)0x0) &&
               (entry = (mimetypes_entry *)mem_calloc(1,keylen + 8), entry != (mimetypes_entry *)0x0
               )) {
              puVar5 = memacpy(src,len);
              entry->content_type = puVar5;
              if (puVar5 != (uchar *)0x0) {
                memcpy(entry->extension,pbVar6,keylen);
                phVar4 = add_hash_item(mimetypes_map,entry->extension,keylen,entry);
                if (phVar4 != (hash_item *)0x0) goto LAB_080b8ae0;
              }
              done_mimetypes_entry(entry);
            }
            goto LAB_080b8ae0;
          }
        }
      }
      goto LAB_080b8a18;
    }
    fclose(__stream);
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_content_type_mimetypes(uchar *extension)

{
  uchar uVar1;
  size_t keylen;
  int extensionlen;
  hash_item *item;
  char *pcVar2;
  hash_item *phVar3;
  uchar *filename;
  uchar *puVar4;
  option_value local_10;
  
  if (mimetypes_options[1].option_elinks.value.tree == (list_head_elinks *)0x0) {
    return (uchar *)0x0;
  }
  if (mimetypes_map == (hash *)0x0) {
    mimetypes_map = init_hash8();
    if (mimetypes_map == (hash *)0x0) {
      return (uchar *)0x0;
    }
    local_10 = mimetypes_options[2].option_elinks.value;
    if ((mimetypes_options[2].option_elinks.value.tree != (list_head_elinks *)0x0) &&
       (*mimetypes_options[2].option_elinks.value.string != '\0')) goto LAB_080b8d10;
    local_10.tree = (list_head_elinks *)0x811f00c;
    uVar1 = '~';
    while (uVar1 != '\0') {
LAB_080b8d10:
      puVar4 = get_next_path_filename(&local_10.string,':');
      if (puVar4 != (uchar *)0x0) {
        parse_mimetypes_file(puVar4);
        mem_free(puVar4);
      }
      uVar1 = *local_10.string;
    }
    if (mimetypes_map == (hash *)0x0) {
      return (uchar *)0x0;
    }
  }
  puVar4 = extension + 1;
  keylen = strlen((char *)puVar4);
  if (keylen != 0) {
    while( true ) {
      phVar3 = get_hash_item(mimetypes_map,puVar4,keylen);
      if ((phVar3 != (hash_item *)0x0) && ((uchar **)phVar3->value != (uchar **)0x0)) {
                    // WARNING: Load size is inaccurate
        puVar4 = stracpy(*phVar3->value);
        return puVar4;
      }
      pcVar2 = strchr((char *)puVar4,0x2e);
      if ((pcVar2 == (char *)0x0) || (keylen = keylen + ~((int)pcVar2 - (int)puVar4), keylen == 0))
      break;
      puVar4 = (uchar *)(pcVar2 + 1);
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

int get_connections_count(void)

{
  void **ppvVar1;
  int iVar2;
  int size;
  list_head_elinks *item;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &connection_queue);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_keepalive_connections_count(void)

{
  void **ppvVar1;
  int iVar2;
  int size;
  list_head_elinks *item;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)keepalive_connections.next;
  if ((list_head_elinks *)keepalive_connections.next != &keepalive_connections) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + 1;
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &keepalive_connections);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_connections_connecting_count(void)

{
  void **ppvVar1;
  int iVar2;
  int i;
  connection *conn;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + (uint)((int)plVar3[10].next - 1U < 7);
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &connection_queue);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_connections_transfering_count(void)

{
  void **ppvVar1;
  int iVar2;
  int i;
  connection *conn;
  list_head_elinks *plVar3;
  
  iVar2 = 0;
  plVar3 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      ppvVar1 = &plVar3->next;
      iVar2 = iVar2 + (uint)(7 < (int)plVar3[10].next);
      plVar3 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != &connection_queue);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void notify_connection_callbacks(connection *conn)

{
  connection_basic_state cVar1;
  uint uVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  download *download;
  connection *c;
  connection *pcVar6;
  download *next;
  uint id;
  
  cVar1 = (conn->state).basic;
  uVar2 = conn->id;
  puVar3 = (undefined4 *)(conn->downloads).next;
  puVar5 = (undefined4 *)*puVar3;
  do {
    puVar4 = puVar5;
    if ((list_head_elinks *)puVar3 == &conn->downloads) {
      return;
    }
    puVar3[3] = conn->cached;
    if ((code *)puVar3[4] != (code *)0x0) {
      (*(code *)puVar3[4])(puVar3,puVar3[5]);
    }
    if (S_ERRNO < cVar1) {
      pcVar6 = (connection *)connection_queue.next;
      if ((list_head_elinks *)connection_queue.next == &connection_queue) {
        return;
      }
      while ((conn != pcVar6 || (uVar2 != conn->id))) {
        pcVar6 = pcVar6->next;
        if (pcVar6 == (connection *)&connection_queue) {
          return;
        }
      }
    }
    puVar5 = (undefined4 *)*puVar4;
    puVar3 = puVar4;
  } while( true );
}



// WARNING: Unknown calling convention

int is_entry_used(cache_entry *cached)

{
  connection *conn;
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      if ((cache_entry *)plVar1[4].prev == cached) {
        return 1;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &connection_queue);
  }
  return 0;
}



// WARNING: Unknown calling convention

connection_priority get_priority(connection *conn)

{
  int iVar1;
  connection_priority cVar2;
  connection_priority priority;
  
  iVar1 = 0;
  cVar2 = PRI_DOWNLOAD;
  do {
    if (conn->pri[cVar2] != 0) break;
    iVar1 = iVar1 + 1;
    cVar2 = cVar2 + PRI_FRAME;
  } while (iVar1 != 7);
  if ((assert_failed == 0) && (assert_failed = (int)(cVar2 == PRIORITIES), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x4f;
    elinks_internal((uchar *)"assertion priority != PRIORITIES failed: Connection has no owner");
    return cVar2;
  }
  return cVar2;
}



// WARNING: Unknown calling convention

void add_to_queue(connection *conn)

{
  connection_priority cVar1;
  connection_priority cVar2;
  connection *c;
  connection *conn_00;
  connection_priority priority;
  
  cVar1 = get_priority(conn);
  conn_00 = (connection *)connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      cVar2 = get_priority(conn_00);
      if (cVar1 < cVar2) break;
      conn_00 = conn_00->next;
    } while (conn_00 != (connection *)&connection_queue);
  }
  conn->next = conn_00->prev->next;
  conn->prev = conn_00->prev;
  conn_00->prev->next = conn;
  conn->next->prev = conn;
  return;
}



// WARNING: Unknown calling convention

void sort_queue(void)

{
  connection *pcVar1;
  bool bVar2;
  connection_priority cVar3;
  connection_priority cVar5;
  connection *c;
  connection *conn;
  connection *conn_00;
  int swp;
  connection *pcVar4;
  
  while( true ) {
    if ((list_head_elinks *)connection_queue.next == &connection_queue) {
      return;
    }
                    // WARNING: Load size is inaccurate
    pcVar4 = *connection_queue.next;
    if (pcVar4 == (connection *)&connection_queue) break;
    bVar2 = false;
    conn_00 = (connection *)connection_queue.next;
    do {
      cVar3 = get_priority(pcVar4);
      cVar5 = get_priority(conn_00);
      if (cVar3 < cVar5) {
        pcVar4 = conn_00->next;
        bVar2 = true;
        pcVar4->prev = conn_00->prev;
        conn_00->prev->next = conn_00->next;
        pcVar1 = pcVar4->next;
        conn_00->prev = pcVar4;
        conn_00->next = pcVar1;
        pcVar4->next = conn_00;
        conn_00->next->prev = conn_00;
      }
      conn_00 = conn_00->next;
    } while ((conn_00 != (connection *)&connection_queue) &&
            (pcVar4 = conn_00->next, pcVar4 != (connection *)&connection_queue));
    if (!bVar2) {
      return;
    }
  }
  return;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080b90b8;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080b90b8:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

connection *
init_connection(uri *uri,uri *proxied_uri,uri *referrer,off_t start,cache_mode cache_mode,
               connection_priority priority)

{
  connection *conn_00;
  connection *conn;
  socket *psVar1;
  progress *ppVar2;
  connection *pcVar3;
  
  conn_00 = (connection *)mem_calloc(1,0x9c);
  pcVar3 = conn_00;
  if (conn_00 != (connection *)0x0) {
    if ((assert_failed == 0) &&
       (assert_failed = (int)(proxied_uri->protocol == 0xf), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 0x117;
      elinks_internal((uchar *)"assertion proxied_uri->protocol != PROTOCOL_PROXY failed!");
    }
    psVar1 = init_socket(conn_00,&init_connection::connection_socket_operations);
    conn_00->socket = psVar1;
    if (psVar1 != (socket *)0x0) {
      psVar1 = init_socket(conn_00,&init_connection::connection_socket_operations);
      conn_00->data_socket = psVar1;
      if (psVar1 != (socket *)0x0) {
        ppVar2 = init_progress(start);
        conn_00->progress = ppVar2;
        if (ppVar2 == (progress *)0x0) {
          mem_free(conn_00->data_socket);
          mem_free(conn_00->socket);
          mem_free(conn_00);
          return (connection *)0x0;
        }
        conn_00->proxied_uri = proxied_uri;
        conn_00->uri = uri;
        conn_00->id = connection_id;
        connection_id = connection_id + 1;
        conn_00->pri[priority] = 1;
        conn_00->content_encoding = ENCODING_NONE;
        conn_00->stream_pipes[1] = -1;
        conn_00->stream_pipes[0] = -1;
        conn_00->cache_mode = cache_mode;
        (conn_00->downloads).prev = &conn_00->downloads;
        (conn_00->downloads).next = &conn_00->downloads;
        *(undefined4 *)&conn_00->est_length = 0xffffffff;
        *(undefined4 *)((int)&conn_00->est_length + 4) = 0xffffffff;
        conn_00->timer = (timer_id_T)0x0;
        if (referrer == (uri *)0x0) {
          return conn_00;
        }
        if ((referrer->protocol == 4) && (uri->protocol != 4)) {
          return conn_00;
        }
        (referrer->object).refcount = (referrer->object).refcount + 1;
        conn_00->referrer = referrer;
        return conn_00;
      }
      mem_free(conn_00->socket);
    }
    pcVar3 = (connection *)0x0;
    mem_free(conn_00);
  }
  return pcVar3;
}



// WARNING: Unknown calling convention

host_connection * get_host_connection(connection *conn)

{
  uri *b;
  int iVar1;
  host_connection *host_conn;
  
  b = conn->uri;
  if ((b->host == (uchar *)0x0) ||
     (host_conn = (host_connection *)host_connections.next,
     (list_head_elinks *)host_connections.next == &host_connections)) {
LAB_080b92a4:
    host_conn = (host_connection *)0x0;
  }
  else {
    while (iVar1 = compare_uri(host_conn->uri,b,URI_HOST), iVar1 == 0) {
      host_conn = host_conn->next;
      if (host_conn == (host_connection *)&host_connections) goto LAB_080b92a4;
      b = conn->uri;
    }
  }
  return host_conn;
}



// WARNING: Unknown calling convention

int add_host_connection(connection *conn)

{
  object *poVar1;
  uri *puVar2;
  host_connection *phVar3;
  host_connection *host_conn;
  
  phVar3 = get_host_connection(conn);
  if (phVar3 == (host_connection *)0x0) {
    if (conn->uri->host == (uchar *)0x0) {
      return 1;
    }
    phVar3 = (host_connection *)mem_calloc(1,0x10);
    if (phVar3 == (host_connection *)0x0) {
      return 0;
    }
    puVar2 = conn->uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    phVar3->uri = puVar2;
    phVar3->prev = (host_connection *)&host_connections;
    phVar3->next = (host_connection *)host_connections.next;
    host_connections.next = phVar3;
    phVar3->next->prev = phVar3;
  }
  (phVar3->object).refcount = (phVar3->object).refcount + 1;
  return 1;
}



// WARNING: Unknown calling convention

void set_connection_timeout(connection *conn)

{
  int iVar1;
  option_value *poVar2;
  
  kill_timer(&conn->timer);
  if ((conn->field_0x78 & 2) == 0) {
    poVar2 = get_opt_();
    iVar1 = poVar2->number;
  }
  else {
    poVar2 = get_opt_();
    iVar1 = poVar2->number;
  }
  install_timer(&conn->timer,iVar1 * 500,connection_timeout_1,conn);
  return;
}



// WARNING: Unknown calling convention

void set_connection_socket_timeout(socket *socket,connection_state state)

{
  if ((assert_failed == 0) && (assert_failed = (int)(socket == (socket *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0xf6;
    elinks_internal((uchar *)"assertion socket failed!");
    set_connection_timeout((connection *)socket->conn);
    return;
  }
  set_connection_timeout((connection *)socket->conn);
  return;
}



// WARNING: Unknown calling convention

void connection_timeout_1(connection *conn)

{
  int iVar1;
  option_value *poVar2;
  
  if ((conn->field_0x78 & 2) == 0) {
    poVar2 = get_opt_();
    iVar1 = poVar2->number;
  }
  else {
    poVar2 = get_opt_();
    iVar1 = poVar2->number;
  }
  install_timer(&conn->timer,iVar1 * 500,connection_timeout,conn);
  return;
}



// WARNING: Unknown calling convention

void connection_timeout(connection *conn)

{
  conn->timer = (timer_id_T)0x0;
  timeout_socket(conn->socket);
  return;
}



// WARNING: Unknown calling convention

void detach_connection(download *download,off_t pos)

{
  undefined *puVar1;
  connection *pcVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  option_value *poVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  connection *conn;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  bool bVar15;
  char *pcVar16;
  
  pcVar2 = download->conn;
  if (S_ERRNO < (download->state).basic) {
    if ((pcVar2->field_0x78 & 4) != 0) {
LAB_080b9625:
      free_entry_to(pcVar2->cached,pos);
      return;
    }
    if (pcVar2->cached != (cache_entry *)0x0) {
      uVar14 = *(uint *)&pcVar2->est_length;
      uVar12 = *(uint *)((int)&pcVar2->est_length + 4);
      if ((uVar14 & uVar12) == 0xffffffff) {
        uVar14 = *(uint *)&pcVar2->from;
        uVar12 = *(uint *)((int)&pcVar2->from + 4);
      }
      pcVar16 = "document.cache.memory.size";
      poVar7 = get_opt_();
      uVar3 = (poVar7->number * 0x19) / 100;
      iVar11 = (int)uVar3 >> 0x1f;
      if ((iVar11 <= (int)uVar12) && ((iVar11 < (int)uVar12 || (uVar3 <= uVar14)))) {
        uVar14 = pcVar2->pri[1];
        uVar12 = pcVar2->pri[0];
        uVar3 = pcVar2->pri[2];
        uVar8 = uVar12 + uVar14 + uVar3;
        uVar4 = pcVar2->pri[3];
        uVar9 = uVar8 + uVar4;
        uVar5 = pcVar2->pri[4];
        uVar10 = uVar9 + uVar5;
        uVar6 = pcVar2->pri[5];
        uVar13 = uVar6 + uVar10;
        uVar14 = ((int)uVar6 >> 0x1f) +
                 ((int)uVar12 >> 0x1f) + ((int)uVar14 >> 0x1f) + (uint)CARRY4(uVar12,uVar14) +
                 ((int)uVar3 >> 0x1f) + (uint)CARRY4(uVar12 + uVar14,uVar3) + ((int)uVar4 >> 0x1f) +
                 (uint)CARRY4(uVar8,uVar4) + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar9,uVar5) +
                 (uint)CARRY4(uVar6,uVar10);
        if ((assert_failed == 0) &&
           (bVar15 = (uVar13 | uVar14) == 0, assert_failed = (int)bVar15, bVar15)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
          errline = 0x459;
          elinks_internal((uchar *)"assertion total_pri failed: detaching free connection",pcVar16);
        }
        shrink_format_cache(0);
        if (((uVar13 ^ 1 | uVar14) == 0) && ((pcVar2->cached->object).refcount == 0)) {
          puVar1 = &pcVar2->cached->field_0x5c;
          *puVar1 = *puVar1 & 0xef;
          pcVar2->field_0x78 = pcVar2->field_0x78 | 4;
          goto LAB_080b9625;
        }
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int register_check_queue(void)

{
  int iVar1;
  
  iVar1 = register_bottom_half_do(check_queue,(void *)0x0);
  return iVar1;
}



// WARNING: Unknown calling convention

void shutdown_connection_stream(connection *conn)

{
  if (conn->stream == (stream_encoded *)0x0) {
    if (-1 < conn->stream_pipes[0]) {
      close(conn->stream_pipes[0]);
    }
  }
  else {
    close_encoded(conn->stream);
    conn->stream = (stream_encoded *)0x0;
  }
  if (-1 < conn->stream_pipes[1]) {
    close(conn->stream_pipes[1]);
  }
  conn->stream_pipes[1] = -1;
  conn->stream_pipes[0] = -1;
  return;
}



// WARNING: Unknown calling convention

void free_connection_data(connection *conn)

{
  socket *socket;
  uchar *puVar1;
  host_connection *host_conn;
  host_connection *p;
  int iVar2;
  cache_entry *pcVar3;
  
  if ((assert_failed == 0) && (assert_failed = ((byte)conn->field_0x78 ^ 1) & 1, assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x18d;
    elinks_internal((uchar *)"assertion conn->running failed: connection already suspended");
  }
  conn->field_0x78 = conn->field_0x78 & 0xfe;
  active_connections = active_connections + -1;
  if (assert_failed == 0) {
    assert_failed = -(active_connections >> 0x1f);
    if (assert_failed == 0) goto LAB_080b9769;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x193;
    elinks_internal((uchar *)
                    "assertion active_connections >= 0 failed: active connections underflow");
    if (assert_failed == 0) goto LAB_080b9769;
  }
  assert_failed = 0;
  active_connections = 0;
LAB_080b9769:
  socket = conn->socket;
  if ((socket->ssl != (void *)0x0) && (pcVar3 = conn->cached, pcVar3 != (cache_entry *)0x0)) {
    if (pcVar3->ssl_info != (uchar *)0x0) {
      mem_free(pcVar3->ssl_info);
      pcVar3 = conn->cached;
      socket = conn->socket;
    }
    puVar1 = get_ssl_connection_cipher(socket);
    pcVar3->ssl_info = puVar1;
  }
  if (conn->done != (_func_void_connection_ptr *)0x0) {
    (*conn->done)(conn);
  }
  done_socket(conn->socket);
  done_socket(conn->data_socket);
  shutdown_connection_stream(conn);
  if (conn->info != (void *)0x0) {
    mem_free(conn->info);
  }
  conn->info = (void *)0x0;
  kill_timer(&conn->timer);
  if ((conn->state).basic != S_WAIT) {
    p = get_host_connection(conn);
    if ((p != (host_connection *)0x0) &&
       (iVar2 = (p->object).refcount + -1, (p->object).refcount = iVar2, iVar2 == 0)) {
      p->next->prev = p->prev;
      p->prev->next = p->next;
      done_uri(p->uri);
      mem_free(p);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void set_connection_state(connection *conn,connection_state state)

{
  progress *progress_00;
  uint uVar1;
  undefined4 *puVar2;
  int iVar3;
  progress *progress;
  connection *c;
  connection *pcVar4;
  download *download;
  uint id;
  
  progress_00 = conn->progress;
  if ((conn->state).basic < S_WAIT) {
    if (S_ERRNO < state.basic) {
      iVar3 = (conn->state).syserr;
      (conn->prev_error).basic = (conn->state).basic;
      (conn->prev_error).syserr = iVar3;
      goto LAB_080b98e0;
    }
    conn->state = state;
  }
  else {
LAB_080b98e0:
    conn->state = state;
    if (state.basic == S_TRANS) {
      if (progress_00->timer == (timer_id_T)0x0) {
        uVar1 = conn->id;
        start_update_progress(progress_00,stat_timer,conn);
        update_progress(conn->progress,conn->received,conn->est_length,conn->from);
        pcVar4 = (connection *)connection_queue.next;
        if ((list_head_elinks *)connection_queue.next == &connection_queue) {
          return;
        }
        while ((conn != pcVar4 || (uVar1 != conn->id))) {
          pcVar4 = pcVar4->next;
          if (pcVar4 == (connection *)&connection_queue) {
            return;
          }
        }
      }
      goto LAB_080b99a1;
    }
  }
  kill_timer(&progress_00->timer);
LAB_080b99a1:
  for (puVar2 = (undefined4 *)(conn->downloads).next; (list_head_elinks *)puVar2 != &conn->downloads
      ; puVar2 = (undefined4 *)*puVar2) {
    *(connection_state *)(puVar2 + 7) = state;
    iVar3 = (conn->prev_error).syserr;
    puVar2[9] = (conn->prev_error).basic;
    puVar2[10] = iVar3;
  }
  if (state.basic < S_WAIT) {
    return;
  }
  notify_connection_callbacks(conn);
  return;
}



// WARNING: Unknown calling convention

void set_connection_socket_state(socket *socket,connection_state state)

{
  if ((assert_failed == 0) && (assert_failed = (int)(socket == (socket *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0xef;
    elinks_internal((uchar *)"assertion socket failed!");
  }
  set_connection_state((connection *)socket->conn,state);
  return;
}



// WARNING: Unknown calling convention

void stat_timer(connection *conn)

{
  update_progress(conn->progress,conn->received,conn->est_length,conn->from);
  notify_connection_callbacks(conn);
  return;
}



// WARNING: Unknown calling convention

int try_to_suspend_connection(connection *conn,uri *uri)

{
  connection *conn_00;
  connection_state state;
  connection_priority cVar1;
  connection_priority cVar2;
  int iVar3;
  uint uVar4;
  connection *c;
  connection_priority priority;
  
  cVar1 = get_priority(conn);
  conn_00 = (connection *)connection_queue.prev;
  while( true ) {
    if ((conn_00 == (connection *)&connection_queue) ||
       (cVar2 = get_priority(conn_00), cVar2 <= cVar1)) {
      return -1;
    }
    if ((((conn_00->state).basic != S_WAIT) &&
        ((conn_00->uri->post == (uchar *)0x0 || (cVar2 = get_priority(conn_00), PRI_PRELOAD < cVar2)
         ))) && ((uri == (uri *)0x0 || (iVar3 = compare_uri(uri,conn_00->uri,URI_HOST), iVar3 != 0))
                )) break;
    conn_00 = conn_00->prev;
  }
  free_connection_data(conn_00);
  if (assert_failed == 0) {
    uVar4 = 0;
  }
  else {
    uVar4 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar4;
  set_connection_state(conn_00,state);
  return 0;
}



// WARNING: Unknown calling convention

int load_uri(uri *uri,uri *referrer,download *download,connection_priority pri,cache_mode cache_mode
            ,off_t start)

{
  download_callback_T *pdVar1;
  void *pvVar2;
  progress *ppVar3;
  download *pdVar4;
  connection_state state;
  connection_basic_state cVar5;
  cache_entry *pcVar6;
  cache_entry *cached;
  uri *uri_00;
  uri *b;
  int iVar7;
  connection_priority cVar8;
  connection *pcVar9;
  connection *conn;
  connection_basic_state local_34;
  int local_30;
  connection_state error_state;
  
  if (assert_failed == 0) {
    error_state.basic = S_OK;
  }
  else {
    error_state.basic = S_INTERNAL;
  }
  assert_failed = 0;
  error_state.syserr = 0;
  if (download != (download *)0x0) {
    download->conn = (connection *)0x0;
    download->cached = (cache_entry *)0x0;
    download->pri = pri;
    if (assert_failed == 0) {
      cVar5 = S_OUT_OF_MEM;
    }
    else {
      cVar5 = S_INTERNAL;
    }
    assert_failed = 0;
    (download->state).basic = cVar5;
    (download->state).syserr = 0;
    if (assert_failed == 0) {
      cVar5 = S_WAIT;
    }
    else {
      cVar5 = S_INTERNAL;
    }
    assert_failed = 0;
    (download->prev_error).basic = cVar5;
    (download->prev_error).syserr = 0;
  }
  pcVar6 = get_validated_cache_entry(uri,cache_mode);
  if (pcVar6 == (cache_entry *)0x0) {
    uri_00 = get_proxied_uri(uri);
    b = get_proxy_uri(uri,&error_state);
    if (((uri_00 == (uri *)0x0) || (b == (uri *)0x0)) ||
       ((iVar7 = get_protocol_need_slash_after_host(b->protocol), iVar7 != 0 &&
        (*(short *)&b->field_0x2e == 0)))) {
      if (download != (download *)0x0) {
        if (error_state.basic == S_OK) {
          connection_state((connection_basic_state)&local_34);
          error_state.basic = local_34;
          error_state.syserr = local_30;
        }
        (download->state).basic = error_state.basic;
        pvVar2 = download->data;
        (download->state).syserr = error_state.syserr;
        (*download->callback)(download,pvVar2);
      }
      if (b != (uri *)0x0) {
        done_uri(b);
      }
      if (uri_00 == (uri *)0x0) {
        return -1;
      }
    }
    else {
      pcVar9 = (connection *)connection_queue.next;
      if ((list_head_elinks *)connection_queue.next != &connection_queue) {
        do {
          if (((pcVar9->field_0x78 & 4) == 0) && (iVar7 = compare_uri(pcVar9->uri,b,0), iVar7 != 0))
          {
            done_uri(b);
            done_uri(uri_00);
            cVar8 = get_priority(pcVar9);
            if (pri < cVar8) {
              pcVar9->next->prev = pcVar9->prev;
              pcVar9->prev->next = pcVar9->next;
              pcVar9->pri[pri] = pcVar9->pri[pri] + 1;
              add_to_queue(pcVar9);
              register_check_queue();
            }
            else {
              pcVar9->pri[pri] = pcVar9->pri[pri] + 1;
            }
            if (download != (download *)0x0) {
              ppVar3 = pcVar9->progress;
              download->conn = pcVar9;
              download->progress = ppVar3;
              download->cached = pcVar9->cached;
              pdVar4 = (download *)(pcVar9->downloads).next;
              download->prev = (download *)&pcVar9->downloads;
              download->next = pdVar4;
              (pcVar9->downloads).next = download;
              download->next->prev = download;
              set_connection_state(pcVar9,pcVar9->state);
              return 0;
            }
            return 0;
          }
          pcVar9 = pcVar9->next;
        } while (pcVar9 != (connection *)&connection_queue);
      }
      pcVar9 = init_connection(b,uri_00,referrer,start,cache_mode,pri);
      if (pcVar9 != (connection *)0x0) {
        if (download != (download *)0x0) {
          ppVar3 = pcVar9->progress;
          download->conn = pcVar9;
          download->cached = (cache_entry *)0x0;
          download->progress = ppVar3;
          connection_state((connection_basic_state)&local_34);
          (download->state).basic = local_34;
          (download->state).syserr = local_30;
          pdVar4 = (download *)(pcVar9->downloads).next;
          download->prev = (download *)&pcVar9->downloads;
          download->next = pdVar4;
          (pcVar9->downloads).next = download;
          download->next->prev = download;
        }
        add_to_queue(pcVar9);
        connection_state((connection_basic_state)&local_34);
        state.syserr = local_30;
        state.basic = local_34;
        set_connection_state(pcVar9,state);
        register_check_queue();
        return 0;
      }
      if (download != (download *)0x0) {
        connection_state((connection_basic_state)&local_34);
        (download->state).basic = local_34;
        pvVar2 = download->data;
        (download->state).syserr = local_30;
        (*download->callback)(download,pvVar2);
      }
      done_uri(b);
    }
    done_uri(uri_00);
    return -1;
  }
  if (download != (download *)0x0) {
    download->cached = pcVar6;
    if (assert_failed == 0) {
      cVar5 = S_OK;
    }
    else {
      cVar5 = S_INTERNAL;
    }
    assert_failed = 0;
    (download->state).basic = cVar5;
    pdVar1 = download->callback;
    (download->state).syserr = 0;
    if (pdVar1 != (download_callback_T *)0x0) {
      (*pdVar1)(download,download->data);
      return 0;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void done_connection(connection *conn)

{
  if (S_ERRNO < (conn->state).basic) {
    assert_failed = 0;
    set_connection_state(conn,(connection_state)0xfffe795d);
  }
  conn->next->prev = conn->prev;
  conn->prev->next = conn->next;
  notify_connection_callbacks(conn);
  if (conn->referrer != (uri *)0x0) {
    done_uri(conn->referrer);
  }
  done_uri(conn->uri);
  done_uri(conn->proxied_uri);
  mem_free(conn->socket);
  mem_free(conn->data_socket);
  done_progress(conn->progress);
  mem_free(conn);
  return;
}



// WARNING: Unknown calling convention

int do_keepalive_connection_callback(keepalive_connection *keep_conn)

{
  _func_void_connection_ptr *p_Var1;
  uri *proxied_uri_00;
  uri *uri;
  connection *conn;
  connection_priority cVar2;
  int iVar3;
  connection_priority cVar4;
  connection *c;
  connection *conn_00;
  uri *proxy_uri;
  connection_priority priority;
  uri *proxied_uri;
  _func_void_connection_ptr *done;
  
  proxied_uri_00 = get_proxied_uri(keep_conn->uri);
  uri = get_proxy_uri(keep_conn->uri,(connection_state *)0x0);
  if (uri != (uri *)0x0) {
    if (proxied_uri_00 == (uri *)0x0) goto LAB_080ba0c6;
    conn = init_connection(uri,proxied_uri_00,(uri *)0x0,0,CACHE_MODE_NEVER,PRI_CANCEL);
    if (conn != (connection *)0x0) {
      p_Var1 = keep_conn->done;
      cVar2 = get_priority(conn);
      conn_00 = (connection *)connection_queue.next;
      if ((list_head_elinks *)connection_queue.next != &connection_queue) {
        do {
          cVar4 = get_priority(conn_00);
          if (cVar2 < cVar4) break;
          conn_00 = conn_00->next;
        } while (conn_00 != (connection *)&connection_queue);
      }
      conn->next = conn_00->prev->next;
      conn->prev = conn_00->prev;
      conn_00->prev->next = conn;
      conn->next->prev = conn;
      iVar3 = has_keepalive_connection(conn);
      if ((iVar3 != 0) && (iVar3 = add_host_connection(conn), iVar3 != 0)) {
        active_connections = active_connections + 1;
        conn->field_0x78 = conn->field_0x78 | 1;
        (*p_Var1)(conn);
        return 1;
      }
      free_connection_data(conn);
      done_connection(conn);
      return 0;
    }
  }
  else if (proxied_uri_00 == (uri *)0x0) {
    return 0;
  }
  done_uri(proxied_uri_00);
LAB_080ba0c6:
  if (uri != (uri *)0x0) {
    done_uri(uri);
  }
  return 0;
}



// WARNING: Unknown calling convention

int has_keepalive_connection(connection *conn)

{
  void *pvVar1;
  uri *b;
  int iVar2;
  keepalive_connection *keep_conn;
  list_head_elinks *p;
  
  b = conn->uri;
  if ((b->host != (uchar *)0x0) &&
     (p = (list_head_elinks *)keepalive_connections.next,
     (list_head_elinks *)keepalive_connections.next != &keepalive_connections)) {
    while( true ) {
      iVar2 = compare_uri((uri *)p[1].next,b,URI_KEEPALIVE);
      if (iVar2 != 0) {
        conn->socket->fd = (int)p[4].prev;
        conn->socket->field_0x24 = conn->socket->field_0x24 & 0xfe | *(byte *)&p[4].next & 1;
        pvVar1 = p->next;
        p[4].prev = (void *)0xffffffff;
        p[1].prev = (void *)0x0;
        *(void **)((int)pvVar1 + 4) = p->prev;
        *(void **)p->prev = p->next;
        if (p[4].prev != (void *)0xffffffff) {
          close((int)p[4].prev);
        }
        done_uri((uri *)p[1].next);
        mem_free(p);
        return 1;
      }
      p = (list_head_elinks *)p->next;
      if (p == &keepalive_connections) break;
      b = conn->uri;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void check_keepalive_connections(void)

{
  void *p_00;
  int iVar1;
  keepalive_connection *keep_conn;
  keepalive_connection *keep_conn_00;
  int iVar2;
  int p;
  keepalive_connection *next;
  keepalive_connection *pkVar3;
  bool bVar4;
  timeval_T age;
  timeval_T now;
  
  timeval_now(&now);
  kill_timer(&keepalive_timeout);
                    // WARNING: Load size is inaccurate
  if ((list_head_elinks *)keepalive_connections.next != &keepalive_connections) {
    iVar2 = 0;
    keep_conn_00 = (keepalive_connection *)keepalive_connections.next;
    pkVar3 = *keepalive_connections.next;
    do {
      iVar1 = can_read(keep_conn_00->socket);
      if (iVar1 == 0) {
        timeval_sub(&age,&keep_conn_00->creation_time,&now);
        iVar1 = timeval_cmp(&age,&keep_conn_00->timeout);
        if (0 < iVar1) goto LAB_080ba32c;
        iVar2 = iVar2 + 1;
      }
      else {
LAB_080ba32c:
        if ((keep_conn_00->done == (_func_void_connection_ptr *)0x0) ||
           (iVar1 = do_keepalive_connection_callback(keep_conn_00), iVar1 == 0)) {
          keep_conn_00->next->prev = keep_conn_00->prev;
          keep_conn_00->prev->next = keep_conn_00->next;
          if (keep_conn_00->socket != -1) {
            close(keep_conn_00->socket);
          }
          done_uri(keep_conn_00->uri);
          mem_free(keep_conn_00);
        }
      }
      bVar4 = pkVar3 != (keepalive_connection *)&keepalive_connections;
      keep_conn_00 = pkVar3;
      pkVar3 = pkVar3->next;
    } while (bVar4);
    for (; 0x1e < iVar2; iVar2 = iVar2 + -1) {
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
      assert_failed =
           (int)((list_head_elinks *)keepalive_connections.next == &keepalive_connections);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 0x290;
        elinks_internal((uchar *)
                        "assertion !list_empty(keepalive_connections) failed: keepalive list empty")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      p_00 = keepalive_connections.prev;
      if ((*(int *)((int)keepalive_connections.prev + 0xc) == 0) ||
         (iVar1 = do_keepalive_connection_callback
                            ((keepalive_connection *)keepalive_connections.prev), iVar1 == 0)) {
                    // WARNING: Load size is inaccurate
        *(undefined4 *)(*p_00 + 4) = *(undefined4 *)((int)p_00 + 4);
                    // WARNING: Load size is inaccurate
        **(undefined4 **)((int)p_00 + 4) = *p_00;
        if (*(int *)((int)p_00 + 0x24) != -1) {
          close(*(int *)((int)p_00 + 0x24));
        }
        done_uri(*(uri **)((int)p_00 + 8));
        mem_free(p_00);
      }
    }
    if ((list_head_elinks *)keepalive_connections.next != &keepalive_connections) {
      install_timer(&keepalive_timeout,20000,keepalive_timer,(void *)0x0);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void keepalive_timer(void *x)

{
  keepalive_timeout = (timer_id_T)0x0;
  check_keepalive_connections();
  return;
}



// WARNING: Unknown calling convention

void add_keepalive_connection
               (connection *conn,long timeout_in_seconds,_func_void_connection_ptr *done)

{
  uri *puVar1;
  void **ppvVar2;
  uri *uri;
  bool bVar3;
  
  if (assert_failed != 0) {
LAB_080ba658:
    assert_failed = 0;
    goto done;
  }
  bVar3 = conn->socket->fd == -1;
  assert_failed = (int)bVar3;
  if (bVar3) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x252;
    elinks_internal((uchar *)
                    "assertion conn->socket->fd != -1 failed: keepalive connection not connected");
    if (assert_failed != 0) goto LAB_080ba658;
  }
  puVar1 = conn->uri;
  assert_failed = (int)(puVar1->host == (uchar *)0x0);
  if (assert_failed == 0) {
LAB_080ba4ec:
    ppvVar2 = (void **)mem_calloc(1,0x28);
    if (ppvVar2 != (void **)0x0) {
      (puVar1->object).refcount = (puVar1->object).refcount + 1;
      ppvVar2[3] = done;
      ppvVar2[2] = puVar1;
      *(byte *)(ppvVar2 + 8) = *(byte *)(ppvVar2 + 8) & 0xfe | conn->socket->field_0x24 & 1;
      ppvVar2[9] = (void *)conn->socket->fd;
      timeval_from_seconds((timeval_T *)(ppvVar2 + 4),timeout_in_seconds);
      timeval_now((timeval_T *)(ppvVar2 + 6));
      set_handlers(conn->socket->fd,(select_handler_T)0x0,(select_handler_T)0x0,
                   (select_handler_T)0x0,(void *)0x0);
      conn->socket->fd = -1;
      ppvVar2[1] = &keepalive_connections;
      *ppvVar2 = keepalive_connections.next;
      keepalive_connections.next = ppvVar2;
      *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
      goto done;
    }
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x21b;
    elinks_internal((uchar *)"assertion uri->host failed!");
    if (assert_failed == 0) goto LAB_080ba4ec;
    assert_failed = 0;
  }
  if (done != (_func_void_connection_ptr *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080ba619. Too many branches
                    // WARNING: Treating indirect jump as call
    (*done)(conn);
    return;
  }
done:
  free_connection_data(conn);
  done_connection(conn);
  register_check_queue();
  return;
}



// WARNING: Unknown calling convention

void abort_connection(connection *conn,connection_state state)

{
  if ((assert_failed == 0) && (assert_failed = -(~state.basic >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2e3;
    elinks_internal((uchar *)
                    "assertion is_in_result_state(state) failed: connection didn\'t end in result state (%d)"
                    ,state.basic,state.syserr);
  }
  if ((state.basic == S_OK) && (conn->cached != (cache_entry *)0x0)) {
    normalize_cache_entry(conn->cached,conn->from);
  }
  set_connection_state(conn,state);
  if ((conn->field_0x78 & 1) != 0) {
    free_connection_data(conn);
  }
  done_connection(conn);
  register_check_queue();
  return;
}



// WARNING: Unknown calling convention

void abort_background_connections(void)

{
  connection *pcVar1;
  connection_state state;
  bool bVar2;
  connection_priority cVar3;
  uint uVar4;
  connection *conn;
  connection *conn_00;
  connection *next;
  connection *pcVar5;
  
                    // WARNING: Load size is inaccurate
  conn_00 = (connection *)connection_queue.next;
  pcVar5 = *connection_queue.next;
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      cVar3 = get_priority(conn_00);
      if (cVar3 < PRI_CANCEL) {
        pcVar1 = pcVar5->next;
      }
      else {
        if (assert_failed == 0) {
          uVar4 = 0xfffe795f;
        }
        else {
          uVar4 = 0xfffe795d;
        }
        assert_failed = 0;
        state.syserr = 0;
        state.basic = uVar4;
        abort_connection(conn_00,state);
        pcVar1 = pcVar5->next;
      }
      bVar2 = pcVar5 != (connection *)&connection_queue;
      conn_00 = pcVar5;
      pcVar5 = pcVar1;
    } while (bVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void abort_all_connections(void)

{
  connection_state state;
  keepalive_connection *keep_conn;
  int iVar1;
  uint uVar2;
  
  if ((list_head_elinks *)connection_queue.next != &connection_queue) {
    do {
      if (assert_failed == 0) {
        uVar2 = 0xfffe795f;
      }
      else {
        uVar2 = 0xfffe795d;
      }
      assert_failed = 0;
      state.syserr = 0;
      state.basic = uVar2;
      abort_connection((connection *)connection_queue.next,state);
    } while ((list_head_elinks *)connection_queue.next != &connection_queue);
  }
  while (keep_conn = (keepalive_connection *)keepalive_connections.next,
        keepalive_connections.next = keep_conn,
        keep_conn != (keepalive_connection *)&keepalive_connections) {
    if ((keep_conn->done == (_func_void_connection_ptr *)0x0) ||
       (iVar1 = do_keepalive_connection_callback(keep_conn), iVar1 == 0)) {
      keep_conn->next->prev = keep_conn->prev;
      keep_conn->prev->next = keep_conn->next;
      if (keep_conn->socket != -1) {
        close(keep_conn->socket);
      }
      done_uri(keep_conn->uri);
      mem_free(keep_conn);
    }
  }
  check_keepalive_connections();
  return;
}



// WARNING: Unknown calling convention

void done_connection_socket(socket *socket,connection_state state)

{
  if ((assert_failed == 0) && (assert_failed = (int)(socket == (socket *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x104;
    elinks_internal((uchar *)"assertion socket failed!");
  }
  abort_connection((connection *)socket->conn,state);
  return;
}



// WARNING: Unknown calling convention

void cancel_download(download *download,int interrupt)

{
  download *pdVar1;
  connection *conn_00;
  connection_state state;
  connection_basic_state cVar2;
  connection *conn;
  undefined4 local_24;
  undefined4 local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(download == (download *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x3ee;
    elinks_internal((uchar *)"assertion download failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if ((download->state).basic < S_WAIT) {
    return;
  }
  assert_failed = (int)(download->conn == (connection *)0x0);
  if (assert_failed == 0) {
LAB_080ba979:
    cVar2 = S_INTERRUPTED;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x3f5;
    elinks_internal((uchar *)"assertion download->conn != NULL failed: last state is %d",
                    (download->state).basic,(download->state).syserr);
    if (assert_failed == 0) goto LAB_080ba979;
    cVar2 = S_INTERNAL;
  }
  assert_failed = 0;
  (download->state).basic = cVar2;
  pdVar1 = download->next;
  (download->state).syserr = 0;
  pdVar1->prev = download->prev;
  download->prev->next = download->next;
  conn_00 = download->conn;
  conn_00->pri[download->pri] = conn_00->pri[download->pri] + -1;
  if (assert_failed == 0) {
    assert_failed = -(conn_00->pri[download->pri] >> 0x1f);
    if (assert_failed == 0) goto LAB_080ba9cd;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x3ff;
    elinks_internal((uchar *)
                    "assertion conn->pri[download->pri] >= 0 failed: priority counter underflow");
    if (assert_failed == 0) goto LAB_080ba9cd;
  }
  assert_failed = 0;
  conn_00->pri[download->pri] = 0;
LAB_080ba9cd:
  if (((list_head_elinks *)(conn_00->downloads).next == &conn_00->downloads) &&
     ((conn_00->pri[6] = conn_00->pri[6] + 1, interrupt != 0 || ((conn_00->field_0x78 & 4) != 0))))
  {
    connection_state((connection_basic_state)&local_24);
    state.syserr = local_20;
    state.basic = local_24;
    abort_connection(conn_00,state);
  }
  sort_queue();
  register_check_queue();
  return;
}



// WARNING: Unknown calling convention

void move_download(download *old,download *new,connection_priority newpri)

{
  connection *pcVar1;
  int iVar2;
  connection_basic_state cVar3;
  download *pdVar4;
  connection *conn;
  
  if ((assert_failed == 0) && (assert_failed = (int)(old == (download *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x416;
    elinks_internal((uchar *)"assertion old failed!");
  }
  pcVar1 = old->conn;
  new->conn = pcVar1;
  new->cached = old->cached;
  iVar2 = (old->prev_error).syserr;
  (new->prev_error).basic = (old->prev_error).basic;
  (new->prev_error).syserr = iVar2;
  new->progress = old->progress;
  cVar3 = (old->state).basic;
  iVar2 = (old->state).syserr;
  new->pri = newpri;
  (new->state).basic = cVar3;
  (new->state).syserr = iVar2;
  if (S_ERRNO < (old->state).basic) {
    if (assert_failed == 0) {
      assert_failed = (int)(old->conn == (connection *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 0x430;
        elinks_internal((uchar *)"assertion old->conn != NULL failed: last state is %d",
                        (old->state).basic,(old->state).syserr);
      }
      newpri = new->pri;
    }
    pcVar1->pri[newpri] = pcVar1->pri[newpri] + 1;
    pdVar4 = (download *)(pcVar1->downloads).next;
    new->prev = (download *)&pcVar1->downloads;
    new->next = pdVar4;
    (pcVar1->downloads).next = new;
    new->next->prev = new;
    sort_queue();
    cancel_download(old,0);
    return;
  }
  if (new->callback != (download_callback_T *)0x0) {
    new->conn = (connection *)0x0;
    new->progress = (progress *)0x0;
                    // WARNING: Could not recover jumptable at 0x080bac15. Too many branches
                    // WARNING: Treating indirect jump as call
    (*new->callback)(new,new->data);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void run_connection(connection *conn)

{
  byte bVar1;
  connection_state state;
  code *pcVar2;
  int iVar3;
  uint uVar4;
  undefined1 *func;
  
  pcVar2 = (code *)get_protocol_handler(conn->uri->protocol);
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(pcVar2 == (code *)0x0);
  if (assert_failed == 0) {
    bVar1 = conn->field_0x78;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2cd;
    elinks_internal((uchar *)"assertion func failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    bVar1 = conn->field_0x78;
  }
  assert_failed = bVar1 & 1;
  if ((bVar1 & 1) != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2cf;
    elinks_internal((uchar *)"assertion !conn->running failed: connection already running");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar3 = add_host_connection(conn);
  if (iVar3 == 0) {
    if (assert_failed == 0) {
      uVar4 = 0xfffe795c;
    }
    else {
      uVar4 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar4;
    set_connection_state(conn,state);
    done_connection(conn);
    return;
  }
  active_connections = active_connections + 1;
  conn->field_0x78 = conn->field_0x78 | 1;
  (*pcVar2)(conn);
  return;
}



// WARNING: Unknown calling convention

void retry_connection(connection *conn,connection_state state)

{
  int iVar1;
  option_value *poVar2;
  int iVar3;
  
  poVar2 = get_opt_();
  iVar1 = poVar2->number;
  if ((assert_failed == 0) && (assert_failed = -(~state.basic >> 0x1f), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0x2f6;
    elinks_internal((uchar *)
                    "assertion is_in_result_state(state) failed: connection didn\'t end in result state (%d)"
                    ,state.basic,state.syserr);
  }
  set_connection_state(conn,state);
  free_connection_data(conn);
  if (conn->uri->post != (uchar *)0x0) {
LAB_080bae4c:
    done_connection(conn);
    register_check_queue();
    return;
  }
  if (iVar1 != 0) {
    iVar3 = conn->tries + 1;
    conn->tries = iVar3;
    if (iVar1 <= iVar3) goto LAB_080bae4c;
  }
  iVar1 = (conn->state).syserr;
  (conn->prev_error).basic = (conn->state).basic;
  (conn->prev_error).syserr = iVar1;
  run_connection(conn);
  return;
}



// WARNING: Unknown calling convention

void retry_connection_socket(socket *socket,connection_state state)

{
  if ((assert_failed == 0) && (assert_failed = (int)(socket == (socket *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 0xfd;
    elinks_internal((uchar *)"assertion socket failed!");
  }
  retry_connection((connection *)socket->conn,state);
  return;
}



// WARNING: Unknown calling convention

void check_queue(void)

{
  int iVar1;
  int iVar2;
  connection *conn_00;
  connection_state state;
  option_value *poVar3;
  connection_priority cVar4;
  connection_priority cVar5;
  uri *b;
  int iVar6;
  host_connection *phVar7;
  host_connection *host_conn_1;
  host_connection *host_conn;
  uint uVar8;
  keepalive_connection *keep_conn;
  connection *c;
  list_head_elinks *plVar9;
  connection *pcVar10;
  connection *conn_01;
  connection *conn;
  connection_priority pri;
  
  poVar3 = get_opt_();
  iVar1 = poVar3->number;
  poVar3 = get_opt_();
  iVar2 = poVar3->number;
LAB_080baf90:
  pcVar10 = (connection *)connection_queue.next;
  check_keepalive_connections();
joined_r0x080bafa4:
  if (pcVar10 == (connection *)&connection_queue) {
LAB_080bb0f9:
    do {
      pcVar10 = (connection *)connection_queue.prev;
      if ((list_head_elinks *)connection_queue.prev == &connection_queue) {
        return;
      }
      while( true ) {
        cVar4 = get_priority(pcVar10);
        if (cVar4 < PRI_CANCEL) {
          return;
        }
        if ((pcVar10->state).basic == S_WAIT) break;
        pcVar10 = pcVar10->prev;
        if (pcVar10 == (connection *)&connection_queue) {
          return;
        }
      }
      if (assert_failed == 0) {
        uVar8 = 0xfffe795f;
      }
      else {
        uVar8 = 0xfffe795d;
      }
      assert_failed = 0;
      state.syserr = 0;
      state.basic = uVar8;
      set_connection_state(pcVar10,state);
      done_connection(pcVar10);
    } while( true );
  }
  cVar4 = get_priority(pcVar10);
  cVar5 = get_priority(pcVar10);
  plVar9 = (list_head_elinks *)keepalive_connections.next;
  conn_01 = pcVar10;
  while (keepalive_connections.next = plVar9, cVar4 == cVar5) {
    conn_00 = conn_01->next;
    if ((((conn_01->state).basic == S_WAIT) && (b = conn_01->uri, b->host != (uchar *)0x0)) &&
       (plVar9 != &keepalive_connections)) {
      while (iVar6 = compare_uri((uri *)plVar9[1].next,b,URI_KEEPALIVE), iVar6 == 0) {
        plVar9 = (list_head_elinks *)plVar9->next;
        if (plVar9 == &keepalive_connections) goto LAB_080bb070;
        b = conn_01->uri;
      }
      phVar7 = get_host_connection(conn_01);
      if ((phVar7 == (host_connection *)0x0) || ((phVar7->object).refcount < iVar1)) {
        if (active_connections < iVar2) goto LAB_080bb130;
        iVar6 = try_to_suspend_connection(conn_01,(uri *)0x0);
      }
      else {
        iVar6 = try_to_suspend_connection(conn_01,phVar7->uri);
      }
      if (iVar6 == 0) goto LAB_080baf90;
    }
LAB_080bb070:
    if (conn_00 == (connection *)&connection_queue) break;
    cVar5 = get_priority(conn_00);
    plVar9 = (list_head_elinks *)keepalive_connections.next;
    conn_01 = conn_00;
  }
  do {
    conn_01 = pcVar10;
    cVar5 = get_priority(conn_01);
    pcVar10 = conn_01;
    if (cVar4 != cVar5) goto joined_r0x080bafa4;
    pcVar10 = conn_01->next;
    if ((conn_01->state).basic == S_WAIT) {
      phVar7 = get_host_connection(conn_01);
      if ((phVar7 == (host_connection *)0x0) || ((phVar7->object).refcount < iVar1)) {
        if (active_connections < iVar2) break;
        iVar6 = try_to_suspend_connection(conn_01,(uri *)0x0);
      }
      else {
        iVar6 = try_to_suspend_connection(conn_01,phVar7->uri);
      }
      if (iVar6 == 0) goto LAB_080baf90;
    }
    if (pcVar10 == (connection *)&connection_queue) goto LAB_080bb0f9;
  } while( true );
LAB_080bb130:
  run_connection(conn_01);
  goto LAB_080baf90;
}



// WARNING: Unknown calling convention

void del_dns_cache_entry(dnsentry *dnsentry)

{
  void *p;
  
  dnsentry->next->prev = dnsentry->prev;
  dnsentry->prev->next = dnsentry->next;
  if (dnsentry->addr != (sockaddr_storage *)0x0) {
    mem_free(dnsentry->addr);
  }
  mem_free(dnsentry);
  return;
}



// WARNING: Unknown calling convention

void shrink_dns_cache(int whole)

{
  dnsentry *dnsentry;
  dnsentry *pdVar1;
  int iVar2;
  dnsentry *next;
  dnsentry *pdVar3;
  bool bVar4;
  timeval_T age;
  timeval_T max_age;
  timeval_T now;
  
  if (whole == 0) {
    timeval_from_seconds(&max_age,0xe10);
    timeval_now(&now);
                    // WARNING: Load size is inaccurate
    if ((list_head_elinks *)dns_cache.next != &dns_cache) {
      pdVar1 = (dnsentry *)dns_cache.next;
      pdVar3 = *dns_cache.next;
      do {
        timeval_sub(&age,&pdVar1->creation_time,&now);
        iVar2 = timeval_cmp(&age,&max_age);
        if (0 < iVar2) {
          del_dns_cache_entry(pdVar1);
        }
        bVar4 = pdVar3 != (dnsentry *)&dns_cache;
        pdVar1 = pdVar3;
        pdVar3 = pdVar3->next;
      } while (bVar4);
      return;
    }
  }
  else {
                    // WARNING: Load size is inaccurate
    pdVar1 = (dnsentry *)dns_cache.next;
    pdVar3 = *dns_cache.next;
    if ((list_head_elinks *)dns_cache.next != &dns_cache) {
      do {
        del_dns_cache_entry(pdVar1);
        bVar4 = pdVar3 != (dnsentry *)&dns_cache;
        pdVar1 = pdVar3;
        pdVar3 = pdVar3->next;
      } while (bVar4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void done_dns_lookup(dnsquery *query,dns_result result)

{
  uchar *s2;
  sockaddr_storage *__src;
  int iVar1;
  size_t __n;
  dnsentry *p;
  sockaddr_storage *psVar2;
  dnsentry *dnsentry;
  list_head_elinks *dnsentry_00;
  
  if (query->h != -1) {
    set_handlers(query->h,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
                 (void *)0x0);
    close(query->h);
    query->h = -1;
  }
  *query->queryref = (dnsquery *)0x0;
  if (query->done != (dns_callback_T)0x0) {
    s2 = query->name;
    dnsentry_00 = (list_head_elinks *)dns_cache.next;
    if ((list_head_elinks *)dns_cache.next == &dns_cache) {
      dnsentry_00 = &dns_cache;
    }
    else {
      do {
        iVar1 = c_strcasecmp((char *)((int)dnsentry_00 + 0x18),(char *)s2);
        if (iVar1 == 0) {
          if (dnsentry_00 != (list_head_elinks *)dns_cache.next) {
            ((dnsentry *)dnsentry_00)->next->prev = ((dnsentry *)dnsentry_00)->prev;
            ((dnsentry *)dnsentry_00)->prev->next = ((dnsentry *)dnsentry_00)->next;
            ((dnsentry *)dnsentry_00)->prev = (dnsentry *)&dns_cache;
            ((dnsentry *)dnsentry_00)->next = (dnsentry *)dns_cache.next;
            dns_cache.next = dnsentry_00;
            ((dnsentry *)dnsentry_00)->next->prev = (dnsentry *)dnsentry_00;
          }
          if ((dnsentry *)dnsentry_00 != (dnsentry *)0x0) {
            if (result == DNS_ERROR) {
              (*query->done)(query->data,*(sockaddr_storage **)((int)dnsentry_00 + 8),
                             *(int *)((int)dnsentry_00 + 0xc));
              goto done;
            }
            del_dns_cache_entry((dnsentry *)dnsentry_00);
          }
          dnsentry_00 = &dns_cache;
          break;
        }
        dnsentry_00 = (list_head_elinks *)((dnsentry *)dnsentry_00)->next;
      } while (dnsentry_00 != &dns_cache);
    }
    if (result == DNS_SUCCESS) {
      iVar1 = query->addrno;
      __src = query->addr;
      __n = strlen((char *)s2);
      if ((assert_failed == 0) && (assert_failed = (int)(iVar1 < 1), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
        errline = 0x6b;
        elinks_internal((uchar *)"assertion addrno > 0 failed!");
      }
      p = (dnsentry *)mem_calloc(1,__n + 0x1c);
      if (p != (dnsentry *)0x0) {
        psVar2 = (sockaddr_storage *)mem_alloc(iVar1 << 7);
        p->addr = psVar2;
        if (psVar2 == (sockaddr_storage *)0x0) {
          mem_free(p);
        }
        else {
          memcpy(p->name,s2,__n);
          memcpy(p->addr,__src,iVar1 << 7);
          p->addrno = iVar1;
          timeval_now(&p->creation_time);
          p->next = ((dnsentry *)dnsentry_00)->next;
          p->prev = (dnsentry *)dnsentry_00;
          ((dnsentry *)dnsentry_00)->next = p;
          p->next->prev = p;
        }
      }
    }
    (*query->done)(query->data,query->addr,query->addrno);
  }
done:
  if (query->addr != (sockaddr_storage *)0x0) {
    mem_free(query->addr);
  }
  query->addr = (sockaddr_storage *)0x0;
  mem_free(query);
  return;
}



// WARNING: Unknown calling convention

void kill_dns_request(void **queryref)

{
  dnsquery *query_00;
  dnsquery *query;
  
  query_00 = (dnsquery *)*queryref;
  if ((assert_failed == 0) &&
     (assert_failed = (int)(query_00 == (dnsquery *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x216;
    elinks_internal((uchar *)"assertion query failed!");
  }
  query_00->done = (dns_callback_T)0x0;
  done_dns_lookup(query_00,DNS_ERROR);
  return;
}



// WARNING: Unknown calling convention

void async_dns_error(dnsquery *query)

{
  done_dns_lookup(query,DNS_ERROR);
  return;
}



// WARNING: Unknown calling convention

dns_result read_dns_data(int h,void *data,size_t datalen)

{
  ssize_t r;
  ssize_t sVar1;
  uint uVar2;
  size_t done;
  
  uVar2 = 0;
  do {
    sVar1 = read(h,(void *)((int)data + uVar2),datalen - uVar2);
    if (sVar1 < 1) {
      return DNS_ERROR;
    }
    uVar2 = uVar2 + sVar1;
  } while (uVar2 < datalen);
  if ((assert_failed == 0) && (assert_failed = (int)(uVar2 != datalen), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x12f;
    elinks_internal((uchar *)"assertion done == datalen failed!");
    return DNS_SUCCESS;
  }
  return DNS_SUCCESS;
}



// WARNING: Unknown calling convention

void async_dns_reader(dnsquery *query)

{
  int iVar1;
  dns_result dVar2;
  sockaddr_storage *psVar3;
  dns_result result;
  int i;
  
  iVar1 = set_blocking_fd(query->h);
  if ((-1 < iVar1) && (dVar2 = read_dns_data(query->h,&query->addrno,4), dVar2 != DNS_ERROR)) {
    psVar3 = (sockaddr_storage *)mem_calloc(query->addrno,0x80);
    query->addr = psVar3;
    if (psVar3 == (sockaddr_storage *)0x0) goto LAB_080bb6ef;
    if (query->addrno < 1) {
LAB_080bb708:
      done_dns_lookup(query,DNS_SUCCESS);
      return;
    }
    iVar1 = 0;
    while (dVar2 = read_dns_data(query->h,psVar3 + iVar1,0x80), dVar2 != DNS_ERROR) {
      iVar1 = iVar1 + 1;
      if (query->addrno == iVar1 || query->addrno < iVar1) goto LAB_080bb708;
      psVar3 = query->addr;
    }
  }
  if (query->addr != (sockaddr_storage *)0x0) {
    mem_free(query->addr);
  }
LAB_080bb6ef:
  query->addr = (sockaddr_storage *)0x0;
  done_dns_lookup(query,DNS_ERROR);
  return;
}



// WARNING: Unknown calling convention

dns_result write_dns_data(int h,void *data,size_t datalen)

{
  int w;
  ssize_t sVar1;
  uint uVar2;
  size_t done;
  
  uVar2 = 0;
  do {
    sVar1 = write(h,(void *)((int)data + uVar2),datalen - uVar2);
    if (sVar1 < 0) {
      return DNS_ERROR;
    }
    uVar2 = uVar2 + sVar1;
  } while (uVar2 < datalen);
  if ((assert_failed == 0) && (assert_failed = (int)(uVar2 != datalen), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x100;
    elinks_internal((uchar *)"assertion done == datalen failed!");
    return DNS_SUCCESS;
  }
  return DNS_SUCCESS;
}



// WARNING: Unknown calling convention

dns_result do_real_lookup(uchar *name,sockaddr_storage **addrs,int *addrno,int in_thread)

{
  addrinfo *paVar1;
  addrinfo *__ai;
  int iVar2;
  sockaddr_storage *psVar3;
  uint uVar4;
  int i;
  addrinfo *ai_cur;
  size_t count;
  int local_50;
  addrinfo hint;
  addrinfo *local_20 [4];
  
  if (((addrs != (sockaddr_storage **)0x0) && (name != (uchar *)0x0)) && (addrno != (int *)0x0)) {
    uVar4 = 0;
    do {
      *(undefined4 *)((int)&((addrinfo *)&hint)->ai_flags + uVar4) = 0;
      uVar4 = uVar4 + 4;
    } while (uVar4 < 0x20);
    hint.ai_family = 0;
    hint.ai_socktype = 1;
    iVar2 = getaddrinfo((char *)name,(char *)0x0,(addrinfo *)&hint,local_20);
    if (iVar2 == 0) {
      count = 0;
      for (paVar1 = local_20[0]; paVar1 != (addrinfo *)0x0; paVar1 = paVar1->ai_next) {
        count = count + 1;
      }
      if (in_thread == 0) {
        psVar3 = (sockaddr_storage *)mem_calloc(count,0x80);
      }
      else {
        psVar3 = (sockaddr_storage *)calloc(count,0x80);
      }
      *addrs = psVar3;
      if (psVar3 != (sockaddr_storage *)0x0) {
        *addrno = count;
        local_50 = 0;
        __ai = (addrinfo *)0x0;
        paVar1 = local_20[0];
        while( true ) {
          if (paVar1 == (addrinfo *)0x0) {
            freeaddrinfo(__ai);
            return DNS_SUCCESS;
          }
          psVar3 = *addrs;
          if (assert_failed != 0) break;
          assert_failed = (int)(0x80 < paVar1->ai_addrlen);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
            errline = 0xd3;
            elinks_internal((uchar *)"assertion ai_cur->ai_addrlen <= sizeof(*addr) failed!");
            if (assert_failed != 0) break;
          }
          memcpy(psVar3->__ss_padding + local_50 + -8,paVar1->ai_addr,paVar1->ai_addrlen);
          paVar1 = paVar1->ai_next;
          local_50 = local_50 + 0x80;
          __ai = local_20[0];
        }
        assert_failed = 0;
        freeaddrinfo(local_20[0]);
        if (in_thread == 0) {
          mem_free(*addrs);
        }
        else {
          free(*addrs);
        }
        *addrs = (sockaddr_storage *)0x0;
        *addrno = 0;
        return DNS_ERROR;
      }
    }
  }
  return DNS_ERROR;
}



// WARNING: Unknown calling convention

void async_dns_writer(void *data,int h)

{
  dns_result dVar1;
  int iVar2;
  int i;
  int local_14;
  sockaddr_storage *local_10;
  
  dVar1 = do_real_lookup((uchar *)data,&local_10,&local_14,1);
  if (((dVar1 != DNS_ERROR) && (iVar2 = set_blocking_fd(h), -1 < iVar2)) &&
     (dVar1 = write_dns_data(h,&local_14,4), dVar1 != DNS_ERROR)) {
    if (0 < local_14) {
      iVar2 = 0;
      do {
        dVar1 = write_dns_data(h,local_10 + iVar2,0x80);
        if (dVar1 == DNS_ERROR) {
          return;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < local_14);
    }
    free(local_10);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

dns_result init_dns_lookup(uchar *name,void **queryref,dns_callback_T done,void *data)

{
  uchar *name_00;
  size_t sVar1;
  dnsquery *query_00;
  dnsquery *query;
  option_value *poVar2;
  int fd;
  dns_result result_00;
  dns_result result;
  
  sVar1 = strlen((char *)name);
  query_00 = (dnsquery *)mem_calloc(1,sVar1 + 0x1c);
  if (query_00 == (dnsquery *)0x0) {
    (*done)(data,(sockaddr_storage *)0x0,0);
    return DNS_ERROR;
  }
  query_00->done = done;
  name_00 = query_00->name;
  query_00->data = data;
  memcpy(name_00,name,sVar1);
  query_00->queryref = (dnsquery **)queryref;
  *queryref = query_00;
  poVar2 = get_opt_();
  if (poVar2->tree == (list_head_elinks *)0x0) {
    query_00->h = -1;
  }
  else {
    sVar1 = strlen((char *)name_00);
    fd = start_thread(async_dns_writer,name_00,sVar1 + 1);
    query_00->h = fd;
    if (fd != -1) {
      set_handlers(fd,async_dns_reader,(select_handler_T)0x0,async_dns_error,query_00);
      return DNS_ASYNC;
    }
  }
  result_00 = do_real_lookup(name_00,&query_00->addr,&query_00->addrno,0);
  done_dns_lookup(query_00,result_00);
  return result_00;
}



// WARNING: Unknown calling convention

dns_result find_host(uchar *name,void **queryref,dns_callback_T done,void *data,int no_cache)

{
  int iVar1;
  dns_result dVar2;
  dnsentry *dnsentry;
  list_head_elinks *plVar3;
  timeval_T max_age;
  timeval_T now;
  timeval_T age;
  
  if ((assert_failed == 0) && (assert_failed = (int)(queryref == (void **)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
    errline = 0x1f5;
    elinks_internal((uchar *)"assertion queryref failed!");
  }
  *queryref = (void *)0x0;
  if ((no_cache == 0) &&
     (plVar3 = (list_head_elinks *)dns_cache.next, (list_head_elinks *)dns_cache.next != &dns_cache)
     ) {
    do {
      iVar1 = c_strcasecmp((char *)(plVar3 + 3),(char *)name);
      if (iVar1 == 0) {
        if (plVar3 != (list_head_elinks *)dns_cache.next) {
          *(void **)((int)plVar3->next + 4) = plVar3->prev;
          *(void **)plVar3->prev = plVar3->next;
          plVar3->prev = &dns_cache;
          plVar3->next = dns_cache.next;
          dns_cache.next = plVar3;
          *(list_head_elinks **)((int)plVar3->next + 4) = plVar3;
        }
        if (plVar3 != (list_head_elinks *)0x0) {
          if (assert_failed == 0) {
            if ((int)plVar3[1].prev < 1) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
              errline = 0x202;
              elinks_internal((uchar *)"assertion dnsentry && dnsentry->addrno > 0 failed!");
            }
            else {
              assert_failed = 0;
            }
          }
          timeval_from_seconds(&max_age,0xe10);
          timeval_now(&now);
          timeval_sub(&age,(timeval_T *)(plVar3 + 2),&now);
          iVar1 = timeval_cmp(&age,&max_age);
          if (iVar1 < 1) {
            (*done)(data,(sockaddr_storage *)plVar3[1].next,(int)plVar3[1].prev);
            return DNS_SUCCESS;
          }
        }
        break;
      }
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &dns_cache);
  }
  dVar2 = init_dns_lookup(name,queryref,done,data);
  return dVar2;
}



// WARNING: Unknown calling convention

int has_progress(progress *progress)

{
  uint uVar1;
  timeval_T current_speed_after;
  
  timeval_from_milliseconds(&current_speed_after,100);
  uVar1 = timeval_cmp(&progress->elapsed,&current_speed_after);
  return ~uVar1 >> 0x1f;
}



// WARNING: Removing unreachable block (ram,0x080bbf80)
// WARNING: Unknown calling convention

void update_progress(progress *progress,off_t loaded,off_t size,off_t pos)

{
  timeval_T *t;
  off_t *poVar1;
  int *piVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  milliseconds_T milliseconds;
  int iVar6;
  long seconds;
  int iVar7;
  uint uVar8;
  timeval_T dis_b_interval;
  timeval_T dis_b_max;
  timeval_T elapsed;
  timeval_T now;
  
  timeval_now(&now);
  timeval_sub(&elapsed,&progress->last_time,&now);
  (progress->last_time).sec = now.sec;
  (progress->last_time).usec = now.usec;
  uVar4 = *(uint *)&progress->last_loaded;
  uVar8 = (uint)loaded - *(int *)&progress->last_loaded;
  iVar7 = *(int *)((int)&progress->last_loaded + 4);
  progress->loaded = loaded;
  t = &progress->dis_b;
  progress->last_loaded = loaded;
  timeval_add_interval(&progress->elapsed,&elapsed);
  timeval_add_interval(t,&elapsed);
  milliseconds = mult_ms(100,0x32);
  timeval_from_milliseconds(&dis_b_max,milliseconds);
  timeval_from_milliseconds(&dis_b_interval,100);
  while (iVar6 = timeval_cmp(t,&dis_b_max), -1 < iVar6) {
    uVar5 = progress->data_in_secs[0];
    poVar1 = &progress->cur_loaded;
    uVar3 = *(uint *)poVar1;
    *(uint *)poVar1 = *(int *)poVar1 - uVar5;
    piVar2 = (int *)((int)&progress->cur_loaded + 4);
    *piVar2 = (*piVar2 - ((int)uVar5 >> 0x1f)) - (uint)(uVar3 < uVar5);
    memmove(progress->data_in_secs,progress->data_in_secs + 1,0xc4);
    progress->data_in_secs[0x31] = 0;
    timeval_sub_interval(t,&dis_b_interval);
  }
  progress->data_in_secs[0x31] = progress->data_in_secs[0x31] + uVar8;
  iVar6 = uVar8 + *(int *)&progress->cur_loaded;
  iVar7 = ((loaded._4_4_ - iVar7) - (uint)((uint)loaded < uVar4)) +
          *(int *)((int)&progress->cur_loaded + 4) +
          (uint)CARRY4(uVar8,*(uint *)&progress->cur_loaded);
  *(int *)&progress->cur_loaded = iVar6;
  *(int *)((int)&progress->cur_loaded + 4) = iVar7;
  iVar7 = __divdi3(iVar6,iVar7,5,0);
  progress->current_speed = iVar7;
  progress->pos = pos;
  progress->size = size;
  if ((size != -1) && (size < pos)) {
    progress->size = pos;
  }
  iVar7 = timeval_div_off_t(progress->loaded,&progress->elapsed);
  progress->average_speed = iVar7;
  if (iVar7 != 0) {
    seconds = __divdi3(*(uint *)&progress->size - *(int *)&progress->pos,
                       (*(int *)((int)&progress->size + 4) - *(int *)((int)&progress->pos + 4)) -
                       (uint)(*(uint *)&progress->size < *(uint *)&progress->pos),iVar7,
                       iVar7 >> 0x1f);
    timeval_from_seconds(&progress->estimated_time,seconds);
  }
  install_timer(&progress->timer,100,(_func_void_void_ptr *)progress->timer_func,
                progress->timer_func_data);
  return;
}



// WARNING: Unknown calling convention

void done_progress(progress *progress)

{
  if ((assert_failed == 0) &&
     (assert_failed = (int)(progress->timer != (timer_id_T)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/progress.c";
    errline = 0x2c;
    elinks_internal((uchar *)"assertion progress->timer == TIMER_ID_UNDEF failed!");
    mem_free(progress);
    return;
  }
  mem_free(progress);
  return;
}



// WARNING: Unknown calling convention

progress * init_progress(off_t start)

{
  progress *ppVar1;
  progress *progress;
  
  ppVar1 = (progress *)mem_calloc(1,0x138);
  if (ppVar1 != (progress *)0x0) {
    ppVar1->start = start;
    ppVar1->timer = (timer_id_T)0x0;
  }
  return ppVar1;
}



// WARNING: Unknown calling convention

void start_update_progress(progress *progress,done_handler_T *timer_func,void *timer_func_data)

{
  undefined4 uVar1;
  int iVar2;
  progress *ppVar3;
  progress *ppVar4;
  progress tmp;
  
  if ((progress->field_0x28 & 1) == 0) {
    ppVar3 = &tmp;
    for (iVar2 = 0x4e; iVar2 != 0; iVar2 = iVar2 + -1) {
      (ppVar3->elapsed).sec = 0;
      ppVar3 = (progress *)&(ppVar3->elapsed).usec;
    }
    tmp.start._0_4_ = *(undefined4 *)&progress->start;
    tmp.start._4_4_ = *(undefined4 *)((int)&progress->start + 4);
    tmp._40_1_ = tmp._40_1_ | 1;
    tmp.seek._0_4_ = *(undefined4 *)&progress->seek;
    tmp.seek._4_4_ = *(undefined4 *)((int)&progress->seek + 4);
    ppVar3 = &tmp;
    ppVar4 = progress;
    for (iVar2 = 0x4e; iVar2 != 0; iVar2 = iVar2 + -1) {
      (ppVar4->elapsed).sec = (ppVar3->elapsed).sec;
      ppVar3 = (progress *)&(ppVar3->elapsed).usec;
      ppVar4 = (progress *)&(ppVar4->elapsed).usec;
    }
  }
  timeval_now(&progress->last_time);
  uVar1 = *(undefined4 *)((int)&progress->loaded + 4);
  *(undefined4 *)&progress->last_loaded = *(undefined4 *)&progress->loaded;
  *(undefined4 *)((int)&progress->last_loaded + 4) = uVar1;
  progress->timer_func = timer_func;
  progress->timer_func_data = timer_func_data;
  return;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080bc148;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080bc148:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

void kill_buffer_data(read_buffer *rb,int n)

{
  size_t __n;
  
  if (assert_failed == 0) {
    if ((n < 0) || (rb->length < n)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x3f4;
      elinks_internal((uchar *)"assertion n >= 0 && n <= rb->length failed: bad number of bytes: %d"
                      ,n);
      if (assert_failed != 0) goto LAB_080bc208;
    }
    else {
      assert_failed = 0;
    }
    if (n != 0) {
      __n = rb->length - n;
      rb->length = __n;
      memmove(rb->data,rb->data + n,__n);
      rb->freespace = rb->freespace + n;
      return;
    }
  }
  else {
LAB_080bc208:
    assert_failed = 0;
    rb->length = 0;
  }
  return;
}



// WARNING: Unknown calling convention

read_buffer * alloc_read_buffer(socket *socket)

{
  socket_operation_T p_Var1;
  connection_state cVar2;
  read_buffer *prVar3;
  read_buffer *rb;
  undefined4 local_24;
  undefined4 local_20;
  
  prVar3 = (read_buffer *)mem_calloc(1,0x5000);
  if (prVar3 == (read_buffer *)0x0) {
    p_Var1 = socket->ops->done;
    connection_state((connection_basic_state)&local_24);
    cVar2.syserr = local_20;
    cVar2.basic = local_24;
    (*p_Var1)(socket,cVar2);
  }
  else {
    prVar3->freespace = 0x4ff0;
  }
  return prVar3;
}



// WARNING: Unknown calling convention

socket * init_socket(void *conn,socket_operations *ops)

{
  socket *psVar1;
  socket *socket;
  
  psVar1 = (socket *)mem_calloc(1,0x28);
  if (psVar1 != (socket *)0x0) {
    psVar1->fd = -1;
    psVar1->conn = conn;
    psVar1->ops = ops;
  }
  return psVar1;
}



// WARNING: Unknown calling convention

connect_info * init_connection_info(uri *uri,socket *socket,socket_connect_T connect_done)

{
  connect_info *pcVar1;
  connect_info *connect_info;
  int iVar2;
  
  pcVar1 = (connect_info *)mem_calloc(1,0x20);
  if (pcVar1 != (connect_info *)0x0) {
    pcVar1->done = connect_done;
    iVar2 = get_uri_port(uri);
    pcVar1->port = iVar2;
    iVar2 = uri->ip_family;
    pcVar1->triedno = -1;
    pcVar1->addr = (sockaddr_storage *)0x0;
    pcVar1->ip_family = iVar2;
    (uri->object).refcount = (uri->object).refcount + 1;
    pcVar1->uri = uri;
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

void done_connection_info(socket *socket)

{
  connect_info *pcVar1;
  void *p;
  connect_info *connect_info;
  
  pcVar1 = socket->connect_info;
  if ((assert_failed == 0) &&
     (assert_failed = (int)(pcVar1 == (connect_info *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x81;
    elinks_internal((uchar *)"assertion socket->connect_info failed!");
  }
  if (pcVar1->dnsquery != (void *)0x0) {
    kill_dns_request(&pcVar1->dnsquery);
  }
  if (pcVar1->addr != (sockaddr_storage *)0x0) {
    mem_free(pcVar1->addr);
  }
  done_uri(pcVar1->uri);
  if (socket->connect_info != (connect_info *)0x0) {
    mem_free(socket->connect_info);
  }
  socket->connect_info = (connect_info *)0x0;
  return;
}



// WARNING: Unknown calling convention

void complete_connect_socket(socket *socket,uri *uri,socket_connect_T done)

{
  byte bVar1;
  uri *uri_00;
  socket_operation_T UNRECOVERED_JUMPTABLE;
  connection_state cVar2;
  int iVar3;
  connect_info *pcVar4;
  connect_info *connect_info;
  undefined4 local_24;
  undefined4 local_20;
  
  pcVar4 = socket->connect_info;
  if (pcVar4 == (connect_info *)0x0) {
    if ((assert_failed == 0) && (assert_failed = (int)(uri == (uri *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x1d8;
      elinks_internal((uchar *)"assertion uri && socket failed!");
    }
    pcVar4 = init_connection_info(uri,socket,done);
    if (pcVar4 == (connect_info *)0x0) {
      UNRECOVERED_JUMPTABLE = socket->ops->done;
      connection_state((connection_basic_state)&local_24);
      cVar2.syserr = local_20;
      cVar2.basic = local_24;
                    // WARNING: Could not recover jumptable at 0x080bc520. Too many branches
                    // WARNING: Treating indirect jump as call
      (*UNRECOVERED_JUMPTABLE)(socket,cVar2);
      return;
    }
    bVar1 = socket->field_0x24;
    socket->connect_info = pcVar4;
  }
  else {
    uri_00 = pcVar4->uri;
    if (uri_00 != (uri *)0x0) {
      if ((socket->field_0x24 & 4) == 0) {
        del_blacklist_entry(uri_00,SERVER_BLACKLIST_NO_TLS);
        bVar1 = socket->field_0x24;
        goto joined_r0x080bc48c;
      }
      add_blacklist_entry(uri_00,SERVER_BLACKLIST_NO_TLS);
    }
    bVar1 = socket->field_0x24;
  }
joined_r0x080bc48c:
  if ((((bVar1 & 2) != 0) && (socket->ssl == (void *)0x0)) &&
     (iVar3 = ssl_connect(socket), iVar3 < 0)) {
    return;
  }
  if (pcVar4->done != (socket_connect_T)0x0) {
    (*pcVar4->done)(socket);
  }
  done_connection_info(socket);
  return;
}



// WARNING: Unknown calling convention

int get_pasv_socket(socket *ctrl_socket,sockaddr_storage *addr)

{
  int iVar1;
  socket_operation_T p_Var2;
  connection_state cVar3;
  int iVar4;
  int sock;
  int *piVar5;
  int iVar6;
  int syspf;
  size_t addrlen;
  int in_GS_OFFSET;
  sockaddr_in6 *local_64;
  size_t local_50;
  sockaddr_in6 bind_addr6;
  sockaddr_in bind_addr4;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if ((ctrl_socket->field_0x24 & 1) == 0) {
    local_64 = (sockaddr_in6 *)&bind_addr4;
    iVar6 = 2;
    addrlen = 0x10;
  }
  else {
    local_64 = &bind_addr6;
    iVar6 = 10;
    addrlen = 0x1c;
  }
  memset(addr,0,addrlen);
  memset(local_64,0,addrlen);
  local_50 = addrlen;
  iVar4 = getsockname(ctrl_socket->fd,(sockaddr *)addr,&local_50);
  if (iVar4 == 0) {
    iVar6 = socket(iVar6,1,6);
    if (iVar6 < 0) {
      if (iVar6 == -1) goto LAB_080bc6b0;
    }
    else {
      iVar4 = set_nonblocking_fd(iVar6);
      if (-1 < iVar4) {
        memcpy(local_64,addr,addrlen);
        if ((ctrl_socket->field_0x24 & 1) == 0) {
          bind_addr4.sin_port = 0;
        }
        else {
          bind_addr6.sin6_port = 0;
        }
        iVar4 = bind(iVar6,(sockaddr *)local_64,addrlen);
        if (((iVar4 == 0) &&
            (local_50 = addrlen, iVar4 = getsockname(iVar6,(sockaddr *)addr,&local_50), iVar4 == 0))
           && (iVar4 = listen(iVar6,1), iVar4 == 0)) {
          set_ip_tos_throughput(iVar6);
          goto LAB_080bc667;
        }
      }
    }
    close(iVar6);
  }
LAB_080bc6b0:
  p_Var2 = ctrl_socket->ops->retry;
  piVar5 = __errno_location();
  cVar3.syserr = *piVar5;
  cVar3.basic = 0xffffffff;
  (*p_Var2)(ctrl_socket,cVar3);
  iVar6 = -1;
LAB_080bc667:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar6;
}



// WARNING: Unknown calling convention

void close_socket(socket *socket)

{
  int __fd;
  
  __fd = socket->fd;
  if (__fd != -1) {
    if (socket->ssl != (void *)0x0) {
      ssl_close(socket);
      __fd = socket->fd;
    }
    close(__fd);
    set_handlers(socket->fd,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
                 (void *)0x0);
    socket->fd = -1;
  }
  return;
}



// WARNING: Unknown calling convention

void done_socket(socket *socket)

{
  socket_weak_ref *ref;
  list_head_elinks *plVar1;
  
  close_socket(socket);
  if (socket->connect_info != (connect_info *)0x0) {
    done_connection_info(socket);
  }
  if (socket->read_buffer != (read_buffer *)0x0) {
    mem_free(socket->read_buffer);
  }
  socket->read_buffer = (read_buffer *)0x0;
  if (socket->write_buffer != (void *)0x0) {
    mem_free(socket->write_buffer);
  }
  socket->write_buffer = (void *)0x0;
  plVar1 = (list_head_elinks *)socket_weak_refs.next;
  if ((list_head_elinks *)socket_weak_refs.next != &socket_weak_refs) {
    do {
      while ((socket *)plVar1[1].next != socket) {
        plVar1 = (list_head_elinks *)plVar1->next;
        if (plVar1 == &socket_weak_refs) {
          return;
        }
      }
      plVar1[1].next = (void *)0x0;
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &socket_weak_refs);
  }
  return;
}



// WARNING: Unknown calling convention

void exception(socket *socket)

{
  connection_state cVar1;
  uint uVar2;
  
  if (assert_failed == 0) {
    uVar2 = 0xfffe795e;
  }
  else {
    uVar2 = 0xfffe795d;
  }
  assert_failed = 0;
  cVar1.syserr = 0;
  cVar1.basic = uVar2;
  (*socket->ops->retry)(socket,cVar1);
  return;
}



// WARNING: Unknown calling convention

void read_from_socket(socket *socket,read_buffer *buffer,connection_state state,socket_read_T done)

{
  socket_weak_ref **ppsVar1;
  read_buffer *prVar2;
  connection_state cVar3;
  select_handler_T write_func;
  select_handler_T write_handler;
  uint uVar4;
  socket_weak_ref ref;
  
  prVar2 = socket->read_buffer;
  ref.socket = socket;
  ref.prev = (socket_weak_ref *)&socket_weak_refs;
  ref.next = (socket_weak_ref *)socket_weak_refs.next;
  ppsVar1 = (socket_weak_ref **)((int)socket_weak_refs.next + 4);
  socket_weak_refs.next = &ref;
  *ppsVar1 = &ref;
  buffer->done = done;
  if (assert_failed == 0) {
    uVar4 = 0;
  }
  else {
    uVar4 = 0xfffe795d;
  }
  assert_failed = 0;
  cVar3.syserr = 0;
  cVar3.basic = uVar4;
  (*socket->ops->set_timeout)(socket,cVar3);
  (*socket->ops->set_state)(socket,state);
  (ref.next)->prev = ref.prev;
  (ref.prev)->next = ref.next;
  if (ref.socket == (socket *)0x0) {
    if (prVar2 != buffer) {
      mem_free(buffer);
      return;
    }
  }
  else {
    prVar2 = socket->read_buffer;
    if ((prVar2 != (read_buffer *)0x0) && (buffer != prVar2)) {
      mem_free(prVar2);
    }
    write_func = (select_handler_T)0x0;
    socket->read_buffer = buffer;
    if ((socket->field_0x24 & 0x10) != 0) {
      write_func = get_handler(socket->fd,SELECT_HANDLER_WRITE);
    }
    set_handlers(socket->fd,read_select,write_func,exception,socket);
  }
  return;
}



// WARNING: Unknown calling convention

void read_response_from_socket(socket *socket)

{
  connection_state state;
  read_buffer *buffer;
  read_buffer *rb;
  uint uVar1;
  
  buffer = alloc_read_buffer(socket);
  if (buffer != (read_buffer *)0x0) {
    if (assert_failed == 0) {
      uVar1 = 4;
    }
    else {
      uVar1 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar1;
    read_from_socket(socket,buffer,state,socket->read_done);
  }
  return;
}



void write_to_socket(socket *socket,uchar *data,int len,connection_state state,
                    socket_write_T write_done)

{
  socket_write_T *pp_Var1;
  write_buffer *wb;
  select_handler_T read_func;
  select_handler_T read_handler;
  socket_operation_T UNRECOVERED_JUMPTABLE;
  undefined4 local_24;
  undefined4 local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(len < 1);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x32a;
    elinks_internal((uchar *)"assertion len > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)0x0);
  pp_Var1 = (socket_write_T *)mem_alloc(len + 0x10);
  if (pp_Var1 == (socket_write_T *)0x0) {
    UNRECOVERED_JUMPTABLE = socket->ops->done;
    connection_state((connection_basic_state)&local_24);
    state.syserr = local_20;
    state.basic = local_24;
  }
  else {
    pp_Var1[1] = (socket_write_T)len;
    pp_Var1[2] = (socket_write_T)0x0;
    *pp_Var1 = write_done;
    memcpy(pp_Var1 + 3,data,len);
    if (socket->write_buffer != (void *)0x0) {
      mem_free(socket->write_buffer);
    }
    read_func = (select_handler_T)0x0;
    socket->write_buffer = pp_Var1;
    if ((socket->field_0x24 & 0x10) != 0) {
      read_func = get_handler(socket->fd,SELECT_HANDLER_READ);
    }
    set_handlers(socket->fd,read_func,write_select,exception,socket);
    UNRECOVERED_JUMPTABLE = socket->ops->set_state;
  }
                    // WARNING: Could not recover jumptable at 0x080bcaf2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(socket,state);
  return;
}



// WARNING: Unknown calling convention

void request_from_socket(socket *socket,uchar *data,int datalen,connection_state state,
                        socket_state sock_state,socket_read_T read_done)

{
  socket->read_done = read_done;
  socket->state = sock_state;
  write_to_socket(socket,data,datalen,state,read_response_from_socket);
  return;
}



// WARNING: Unknown calling convention

void read_select(socket *socket)

{
  void *pvVar1;
  int __fd;
  connection_state cVar2;
  connection_state cVar3;
  connection_state cVar4;
  connection_state state;
  ssize_t rd;
  int *piVar5;
  read_buffer *buffer;
  ssize_t sVar6;
  uint *puVar7;
  ssize_t rd_1;
  int iVar8;
  read_buffer *rb;
  socket_operation_T p_Var9;
  size_t __nbytes;
  uint uVar10;
  undefined4 local_24;
  undefined4 local_20;
  
  buffer = socket->read_buffer;
  if (assert_failed != 0) {
LAB_080bccbe:
    assert_failed = 0;
    (*socket->ops->done)(socket,(connection_state)0xfffe795d);
    return;
  }
  assert_failed = (int)(buffer == (read_buffer *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x35a;
    elinks_internal((uchar *)"assertion rb != NULL failed: read socket has no buffer");
    if (assert_failed != 0) goto LAB_080bccbe;
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)0x0);
  if ((socket->field_0x24 & 0x10) == 0) {
    set_handlers(socket->fd,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
                 (void *)0x0);
    __nbytes = buffer->freespace;
    if (__nbytes != 0) goto LAB_080bcc1b;
LAB_080bcd65:
    uVar10 = buffer->length + 0x5010U & 0xfffff000;
    buffer = (read_buffer *)mem_realloc(buffer,uVar10);
    if (buffer == (read_buffer *)0x0) {
      p_Var9 = socket->ops->done;
      goto LAB_080bcf16;
    }
    iVar8 = (uVar10 - buffer->length) + -0x10;
    buffer->freespace = iVar8;
    if ((assert_failed == 0) && (assert_failed = (int)(iVar8 < 1), iVar8 < 1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x371;
      elinks_internal((uchar *)"assertion rb->freespace > 0 failed!");
    }
    pvVar1 = socket->ssl;
    socket->read_buffer = buffer;
    __nbytes = buffer->freespace;
  }
  else {
    __nbytes = buffer->freespace;
    if (__nbytes == 0) goto LAB_080bcd65;
LAB_080bcc1b:
    pvVar1 = socket->ssl;
  }
  if (pvVar1 == (void *)0x0) {
    iVar8 = buffer->length;
    __fd = socket->fd;
    do {
      sVar6 = read(__fd,buffer->data + iVar8,__nbytes);
      if (sVar6 != -1) {
        if (sVar6 == 0) goto LAB_080bce58;
        rd = -1;
        if (-1 < sVar6) {
          rd = sVar6;
        }
        goto LAB_080bcc3e;
      }
      piVar5 = __errno_location();
    } while (*piVar5 == 4);
LAB_080bcc66:
    p_Var9 = socket->ops->retry;
    piVar5 = __errno_location();
    cVar2.syserr = *piVar5;
    cVar2.basic = 0xffffffff;
    (*p_Var9)(socket,cVar2);
    return;
  }
  rd = ssl_read(socket,buffer->data + buffer->length,__nbytes);
LAB_080bcc3e:
  if (rd == -3) {
    if (assert_failed == 0) {
      uVar10 = 8;
    }
    else {
      uVar10 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar10;
    read_from_socket(socket,buffer,state,buffer->done);
    return;
  }
  if (rd < -2) {
    if (rd == -4) {
LAB_080bce58:
      if (socket->state != SOCKET_RETRY_ONCLOSE) {
        socket->state = SOCKET_CLOSED;
        (*buffer->done)(socket,buffer);
        return;
      }
      p_Var9 = socket->ops->retry;
LAB_080bcf16:
      connection_state((connection_basic_state)&local_24);
      cVar4.syserr = local_20;
      cVar4.basic = local_24;
      (*p_Var9)(socket,cVar4);
      return;
    }
LAB_080bccf9:
    buffer->length = buffer->length + rd;
    iVar8 = buffer->freespace - rd;
    buffer->freespace = iVar8;
    if ((assert_failed == 0) && (assert_failed = -(iVar8 >> 0x1f), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x39d;
      elinks_internal((uchar *)"assertion rb->freespace >= 0 failed!");
    }
    (*buffer->done)(socket,buffer);
    return;
  }
  if (rd != -2) {
    if (rd == -1) goto LAB_080bcc66;
    goto LAB_080bccf9;
  }
  p_Var9 = socket->ops->done;
  puVar7 = (uint *)__errno_location();
  uVar10 = *puVar7;
  if (assert_failed == 0) {
    assert_failed = (int)(uVar10 == 0xffffffff);
    if (assert_failed == 0) goto LAB_080bce3a;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
    errline = 0x84;
    elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
    if (assert_failed == 0) goto LAB_080bce3a;
  }
  assert_failed = 0;
  uVar10 = 0xfffe795d;
LAB_080bce3a:
  cVar3.syserr = 0;
  cVar3.basic = uVar10;
  (*p_Var9)(socket,cVar3);
  return;
}



// WARNING: Unknown calling convention

void write_select(socket *socket)

{
  code **ppcVar1;
  code *UNRECOVERED_JUMPTABLE;
  int __fd;
  socket_operation_T p_Var2;
  connection_state cVar3;
  connection_state cVar4;
  connection_state cVar5;
  int wr;
  select_handler_T read_func;
  select_handler_T read_handler;
  ssize_t sVar6;
  int *piVar7;
  uint *puVar8;
  int wr_1;
  code *pcVar9;
  select_handler_T error_handler;
  uint uVar10;
  socket_write_T done;
  bool bVar11;
  
  ppcVar1 = (code **)socket->write_buffer;
  if (assert_failed != 0) {
LAB_080bd11e:
    assert_failed = 0;
    (*socket->ops->done)(socket,(connection_state)0xfffe795d);
    return;
  }
  assert_failed = (int)(ppcVar1 == (code **)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x2d8;
    elinks_internal((uchar *)"assertion wb != NULL failed: write socket has no buffer");
    if (assert_failed != 0) goto LAB_080bd11e;
  }
  assert_failed = 0;
  (*socket->ops->set_timeout)(socket,(connection_state)0x0);
  if (socket->ssl == (void *)0x0) {
    if ((assert_failed == 0) &&
       (UNRECOVERED_JUMPTABLE = ppcVar1[1], pcVar9 = ppcVar1[2],
       bVar11 = (int)UNRECOVERED_JUMPTABLE - (int)pcVar9 < 0,
       assert_failed = (int)(UNRECOVERED_JUMPTABLE == pcVar9 || bVar11),
       UNRECOVERED_JUMPTABLE == pcVar9 || bVar11)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0x2ef;
      elinks_internal((uchar *)"assertion wb->length - wb->pos > 0 failed!");
    }
    UNRECOVERED_JUMPTABLE = ppcVar1[2];
    pcVar9 = ppcVar1[1];
    __fd = socket->fd;
    do {
      sVar6 = write(__fd,UNRECOVERED_JUMPTABLE + 0xc + (int)ppcVar1,
                    (int)pcVar9 - (int)UNRECOVERED_JUMPTABLE);
      if (sVar6 != -1) {
        if (sVar6 == 0) goto LAB_080bd240;
        wr = -1;
        if (-1 < sVar6) {
          wr = sVar6;
        }
        goto LAB_080bd04d;
      }
      piVar7 = __errno_location();
    } while (*piVar7 == 4);
LAB_080bd1d7:
    p_Var2 = socket->ops->retry;
    piVar7 = __errno_location();
    cVar3.syserr = *piVar7;
    cVar3.basic = 0xffffffff;
    (*p_Var2)(socket,cVar3);
    return;
  }
  wr = ssl_write(socket,(uchar *)(ppcVar1[2] + 0xc + (int)ppcVar1),(int)ppcVar1[1] - (int)ppcVar1[2]
                );
LAB_080bd04d:
  if (wr != -2) {
    if (wr != -1) {
      if (wr != -5) {
        if (wr < 0) {
          return;
        }
        UNRECOVERED_JUMPTABLE = ppcVar1[2];
        ppcVar1[2] = UNRECOVERED_JUMPTABLE + wr;
        if (UNRECOVERED_JUMPTABLE + wr != ppcVar1[1]) {
          return;
        }
        UNRECOVERED_JUMPTABLE = *ppcVar1;
        if ((socket->field_0x24 & 0x10) == 0) {
          set_handlers(socket->fd,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
                       (void *)0x0);
        }
        else {
          read_func = get_handler(socket->fd,SELECT_HANDLER_READ);
          pcVar9 = (select_handler_T)0x0;
          if (read_func != (select_handler_T)0x0) {
            pcVar9 = exception;
          }
          set_handlers(socket->fd,read_func,(select_handler_T)0x0,pcVar9,socket);
        }
        if (socket->write_buffer != (void *)0x0) {
          mem_free(socket->write_buffer);
        }
        socket->write_buffer = (void *)0x0;
                    // WARNING: Could not recover jumptable at 0x080bd0e9. Too many branches
                    // WARNING: Treating indirect jump as call
        (*UNRECOVERED_JUMPTABLE)();
        return;
      }
LAB_080bd240:
      if (assert_failed == 0) {
        uVar10 = 0xfffe795a;
      }
      else {
        uVar10 = 0xfffe795d;
      }
      assert_failed = 0;
      cVar5.syserr = 0;
      cVar5.basic = uVar10;
      (*socket->ops->retry)(socket,cVar5);
      return;
    }
    goto LAB_080bd1d7;
  }
  p_Var2 = socket->ops->done;
  puVar8 = (uint *)__errno_location();
  uVar10 = *puVar8;
  if (assert_failed == 0) {
    assert_failed = (int)(uVar10 == 0xffffffff);
    if (assert_failed == 0) goto LAB_080bd226;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
    errline = 0x84;
    elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
    if (assert_failed == 0) goto LAB_080bd226;
  }
  assert_failed = 0;
  uVar10 = 0xfffe795d;
LAB_080bd226:
  cVar4.syserr = 0;
  cVar4.basic = uVar10;
  (*p_Var2)(socket,cVar4);
  return;
}



// WARNING: Unknown calling convention

void connect_socket(socket *csocket,connection_state state)

{
  int iVar1;
  connect_info *pcVar2;
  int iVar3;
  list_head_elinks *plVar4;
  list_head_elinks *plVar5;
  list_head_elinks *plVar6;
  sockaddr_storage *psVar7;
  connection_state cVar8;
  bool bVar9;
  bool bVar10;
  ushort uVar11;
  ushort __v;
  option_value *poVar12;
  int pf;
  int iVar13;
  int *piVar14;
  ifaddrs *ifa;
  int **ppiVar15;
  ifaddrs *ifa_1;
  int iVar16;
  int iVar17;
  uint uVar18;
  connect_info *connect_info;
  int iVar19;
  socket_operation_T p_Var20;
  int local;
  int saved_errno;
  in6_addr *piVar21;
  sockaddr_in6 *psVar22;
  uint32_t *puVar23;
  int sock;
  int in_GS_OFFSET;
  bool bVar24;
  bool bVar25;
  byte bVar26;
  socklen_t __len;
  uint local_88;
  int local_60;
  int local_58;
  undefined4 local_54;
  undefined4 local_50;
  int **local_44;
  sockaddr_in6 *local_40;
  sockaddr_in6 addr;
  
  bVar26 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar2 = csocket->connect_info;
  iVar3 = pcVar2->triedno;
  poVar12 = get_opt_();
  plVar4 = poVar12->tree;
  poVar12 = get_opt_();
  plVar5 = poVar12->tree;
  poVar12 = get_opt_();
  plVar6 = poVar12->tree;
  (*csocket->ops->set_state)(csocket,state);
  if (-1 < csocket->fd) {
    close_socket(csocket);
  }
  local_58 = pcVar2->triedno + 1;
  if (pcVar2->addrno != local_58 && local_58 <= pcVar2->addrno) {
    iVar19 = local_58 * 0x80;
    bVar10 = false;
    bVar9 = false;
    local_60 = 0;
LAB_080bd453:
    psVar7 = pcVar2->addr;
    addr._0_4_ = *(undefined4 *)(psVar7->__ss_padding + iVar19 + -8);
    addr.sin6_flowinfo = *(uint32_t *)(psVar7->__ss_padding + iVar19 + -4);
    addr.sin6_addr.__in6_u.__u6_addr32[0] = *(undefined4 *)(psVar7->__ss_padding + iVar19);
    addr.sin6_addr.__in6_u.__u6_addr32[1] = *(undefined4 *)(psVar7->__ss_padding + iVar19 + 4);
    addr.sin6_addr.__in6_u.__u6_addr32[2] = *(undefined4 *)(psVar7->__ss_padding + iVar19 + 8);
    addr.sin6_addr.__in6_u.__u6_addr32[3] = *(undefined4 *)(psVar7->__ss_padding + iVar19 + 0xc);
    uVar18 = addr._0_4_ & 0xffff;
    addr.sin6_scope_id = *(uint32_t *)(psVar7->__ss_padding + iVar19 + 0x10);
    iVar13 = pcVar2->ip_family;
    pcVar2->triedno = pcVar2->triedno + 1;
    iVar17 = local_60;
    if (plVar4 == (list_head_elinks *)0x0) goto LAB_080bd4b7;
    if (uVar18 != 10) {
      if ((addr.sin6_flowinfo & 0xff) == 0x7f) goto LAB_080bd4b7;
      iVar16 = getifaddrs(&local_44);
      ppiVar15 = local_44;
      if (iVar16 != 0) goto LAB_080bd632;
      for (; ppiVar15 != (int **)0x0; ppiVar15 = (int **)*ppiVar15) {
        piVar14 = ppiVar15[3];
        if ((piVar14 != (int *)0x0) && (*(short *)piVar14 == 2)) {
          bVar25 = piVar14 + 1 == (int *)0x0;
          iVar16 = 4;
          puVar23 = &addr.sin6_flowinfo;
          piVar14 = piVar14 + 1;
          do {
            if (iVar16 == 0) break;
            iVar16 = iVar16 + -1;
            bVar25 = *(char *)puVar23 == *(char *)piVar14;
            puVar23 = (uint32_t *)((int)puVar23 + (uint)bVar26 * -2 + 1);
            piVar14 = (int *)((int)piVar14 + (uint)bVar26 * -2 + 1);
          } while (bVar25);
          if (bVar25) goto LAB_080bd608;
        }
      }
LAB_080bd676:
      bVar25 = false;
      goto LAB_080bd613;
    }
    local_40 = &addr;
    if ((((addr.sin6_addr.__in6_u.__u6_addr32[0] == 0) &&
         (addr.sin6_addr.__in6_u.__u6_addr32[1] == 0)) &&
        (addr.sin6_addr.__in6_u.__u6_addr32[2] == 0)) &&
       (addr.sin6_addr.__in6_u.__u6_addr32[3] == 0x1000000)) goto LAB_080bd4c1;
    iVar16 = getifaddrs(&local_44);
    ppiVar15 = local_44;
    if (iVar16 == 0) {
joined_r0x080bd5bb:
      if (ppiVar15 != (int **)0x0) {
        while (piVar14 = ppiVar15[3], piVar14 != (int *)0x0) {
          if (*(short *)piVar14 == 10) {
            iVar16 = 0x10;
            bVar25 = &local_40->sin6_addr == (in6_addr *)0x0;
            piVar21 = &local_40->sin6_addr;
            piVar14 = piVar14 + 2;
            goto code_r0x080bd5fe;
          }
          if (*(short *)piVar14 != 2) break;
          iVar16 = 4;
          bVar25 = (int *)0xfffffffb < piVar14;
          bVar24 = piVar14 + 1 == (int *)0x0;
          psVar22 = &addr;
          piVar14 = piVar14 + 1;
          do {
            if (iVar16 == 0) break;
            iVar16 = iVar16 + -1;
            bVar25 = *(byte *)&psVar22->sin6_family < *(byte *)piVar14;
            bVar24 = *(byte *)&psVar22->sin6_family == *(byte *)piVar14;
            psVar22 = (sockaddr_in6 *)((int)psVar22 + (uint)bVar26 * -2 + 1);
            piVar14 = (int *)((int)piVar14 + (uint)bVar26 * -2 + 1);
          } while (bVar24);
          if ((!bVar25 && !bVar24) == bVar25) goto LAB_080bd608;
          ppiVar15 = (int **)*ppiVar15;
          if (ppiVar15 == (int **)0x0) goto LAB_080bd676;
        }
        goto LAB_080bd5d6;
      }
      goto LAB_080bd676;
    }
    goto LAB_080bd632;
  }
  bVar25 = true;
  bVar10 = false;
  bVar9 = false;
LAB_080bd7ad:
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  if (((bVar25) && (plVar4 != (list_head_elinks *)0x0)) && (bVar9)) {
    p_Var20 = csocket->ops->done;
LAB_080bd8c5:
    connection_state((connection_basic_state)&local_54);
    cVar8.syserr = local_50;
    cVar8.basic = local_54;
    (*p_Var20)(csocket,cVar8);
  }
  else {
    if ((bVar10) || (pcVar2->triedno == iVar3)) {
      if ((bVar10) && (iVar3 == -1)) {
        if (assert_failed == 0) {
          local_88 = 0xfffe794d;
        }
        else {
          local_88 = 0xfffe795d;
        }
        assert_failed = 0;
        state.syserr = 0;
        state.basic = local_88;
      }
    }
    else {
      piVar14 = __errno_location();
      state.syserr = *piVar14;
      state.basic = 0xffffffff;
    }
    (*csocket->ops->retry)(csocket,state);
  }
LAB_080bd823:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
  while( true ) {
    iVar16 = iVar16 + -1;
    bVar25 = (piVar21->__in6_u).__u6_addr8[0] == *(uint8_t *)piVar14;
    piVar21 = (in6_addr *)((int)piVar21 + (uint)bVar26 * -2 + 1);
    piVar14 = (int *)((int)piVar14 + (uint)bVar26 * -2 + 1);
    if (!bVar25) break;
code_r0x080bd5fe:
    if (iVar16 == 0) break;
  }
  if (bVar25) goto LAB_080bd608;
LAB_080bd5d6:
  ppiVar15 = (int **)*ppiVar15;
  goto joined_r0x080bd5bb;
LAB_080bd608:
  bVar25 = true;
LAB_080bd613:
  freeifaddrs(local_44);
  if (!bVar25) {
LAB_080bd632:
    bVar9 = true;
    goto LAB_080bd43d;
  }
LAB_080bd4b7:
  if (uVar18 == 10) {
LAB_080bd4c1:
    if ((plVar5 == (list_head_elinks *)0x0) || ((iVar13 != 6 && (iVar13 != 0)))) {
LAB_080bd540:
      bVar10 = true;
      goto LAB_080bd43d;
    }
    pf = 10;
  }
  else {
    if (uVar18 != 2) goto LAB_080bd43d;
    if ((plVar6 == (list_head_elinks *)0x0) || ((iVar13 != 4 && (iVar13 != 0)))) goto LAB_080bd540;
    pf = 2;
  }
  iVar13 = socket(pf,1,6);
  if (iVar13 == -1) {
    piVar14 = __errno_location();
    if ((*piVar14 == 0) || (bVar10 = false, iVar17 = *piVar14, local_60 != 0)) {
      bVar10 = false;
      iVar17 = local_60;
    }
    goto LAB_080bd43d;
  }
  iVar17 = set_nonblocking_fd(iVar13);
  if (iVar17 < 0) {
    piVar14 = __errno_location();
    iVar17 = *piVar14;
    if (iVar17 != 0) goto LAB_080bd77a;
LAB_080bd782:
    iVar17 = local_60;
  }
  else {
    csocket->fd = iVar13;
    uVar11 = (ushort)pcVar2->port;
    addr.sin6_port = uVar11 >> 8 | uVar11 << 8;
    if (uVar18 == 10) {
      csocket->field_0x24 = csocket->field_0x24 | 1;
      __len = 0x1c;
    }
    else {
      csocket->field_0x24 = csocket->field_0x24 & 0xfe;
      __len = 0x10;
    }
    iVar17 = connect(iVar13,(sockaddr *)&addr,__len);
    if (iVar17 == 0) {
      complete_connect_socket(csocket,(uri *)0x0,(socket_connect_T)0x0);
      goto LAB_080bd823;
    }
    piVar14 = __errno_location();
    iVar17 = *piVar14;
    if (((iVar17 == 0xb) || (iVar17 == 0x72)) || (iVar17 == 0x73)) {
      set_handlers(iVar13,(select_handler_T)0x0,connected,dns_exception,csocket);
      p_Var20 = csocket->ops->set_state;
      goto LAB_080bd8c5;
    }
    if (iVar17 == 0) goto LAB_080bd782;
LAB_080bd77a:
    if (local_60 != 0) goto LAB_080bd782;
  }
  close(iVar13);
  bVar10 = false;
LAB_080bd43d:
  local_58 = local_58 + 1;
  iVar19 = iVar19 + 0x80;
  local_60 = iVar17;
  if (pcVar2->addrno == local_58 || pcVar2->addrno < local_58) goto LAB_080bd7a8;
  goto LAB_080bd453;
LAB_080bd7a8:
  bVar25 = iVar17 == 0;
  goto LAB_080bd7ad;
}



// WARNING: Unknown calling convention

void dns_found(socket *socket,sockaddr_storage *addr,int addrlen)

{
  connect_info *pcVar1;
  connection_state state;
  connection_state cVar2;
  sockaddr_storage *__dest;
  uint uVar3;
  connect_info *connect_info;
  socket_operation_T UNRECOVERED_JUMPTABLE;
  undefined4 local_24;
  undefined4 local_20;
  
  pcVar1 = socket->connect_info;
  if (addr == (sockaddr_storage *)0x0) {
    UNRECOVERED_JUMPTABLE = socket->ops->done;
  }
  else {
    if ((assert_failed == 0) &&
       (assert_failed = (int)(pcVar1 == (connect_info *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 0xe9;
      elinks_internal((uchar *)"assertion connect_info failed!");
    }
    __dest = (sockaddr_storage *)mem_alloc(addrlen << 7);
    pcVar1->addr = __dest;
    if (__dest != (sockaddr_storage *)0x0) {
      memcpy(__dest,addr,addrlen << 7);
      pcVar1->addrno = addrlen;
      if (assert_failed == 0) {
        uVar3 = 2;
      }
      else {
        uVar3 = 0xfffe795d;
      }
      assert_failed = 0;
      state.syserr = 0;
      state.basic = uVar3;
      connect_socket(socket,state);
      return;
    }
    UNRECOVERED_JUMPTABLE = socket->ops->done;
  }
  connection_state((connection_basic_state)&local_24);
  cVar2.syserr = local_20;
  cVar2.basic = local_24;
                    // WARNING: Could not recover jumptable at 0x080bdaa0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(socket,cVar2);
  return;
}



// WARNING: Unknown calling convention

void timeout_socket(socket *socket)

{
  connection_state cVar1;
  connection_state state;
  connection_state cVar2;
  socket_operation_T p_Var3;
  uint uVar4;
  undefined4 local_14;
  undefined4 local_10;
  
  if (socket->connect_info == (connect_info *)0x0) {
    p_Var3 = socket->ops->retry;
    connection_state((connection_basic_state)&local_14);
    cVar2.syserr = local_10;
    cVar2.basic = local_14;
    (*p_Var3)(socket,cVar2);
    return;
  }
  if (socket->connect_info->dnsquery == (void *)0x0) {
    if (assert_failed == 0) {
      uVar4 = 0xfffe7956;
    }
    else {
      uVar4 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar4;
    connect_socket(socket,state);
    if (socket->connect_info == (connect_info *)0x0) {
      return;
    }
    p_Var3 = socket->ops->set_timeout;
    if (assert_failed == 0) {
      uVar4 = 0;
      goto LAB_080bdb00;
    }
  }
  else {
    p_Var3 = socket->ops->done;
    if (assert_failed == 0) {
      uVar4 = 0xfffe7956;
      goto LAB_080bdb00;
    }
  }
  uVar4 = 0xfffe795d;
LAB_080bdb00:
  assert_failed = 0;
  cVar1.syserr = 0;
  cVar1.basic = uVar4;
  (*p_Var3)(socket,cVar1);
  return;
}



// WARNING: Unknown calling convention

void dns_exception(socket *socket)

{
  connection_state state;
  uint uVar1;
  
  if (assert_failed == 0) {
    uVar1 = 0xfffe795e;
  }
  else {
    uVar1 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar1;
  connect_socket(socket,state);
  return;
}



// WARNING: Unknown calling convention

void connected(socket *socket)

{
  connection_state state;
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  socklen_t local_14;
  int local_10 [2];
  
  local_10[0] = 0;
  local_14 = 4;
  assert_failed = (int)(socket->connect_info == (connect_info *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
    errline = 0x1fa;
    elinks_internal((uchar *)"assertion socket->connect_info != NULL failed: Lost connect_info!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar1 = getsockopt(socket->fd,1,4,local_10,&local_14);
  if (iVar1 == 0) {
    if (9999 < local_10[0]) {
      local_10[0] = local_10[0] + -10000;
    }
    iVar1 = local_10[0];
    if (local_10[0] == 0) {
      if (assert_failed == 0) {
        assert_failed = 0;
        complete_connect_socket(socket,(uri *)0x0,(socket_connect_T)0x0);
        return;
      }
      goto LAB_080bdd70;
    }
  }
  else {
    piVar2 = __errno_location();
    iVar1 = *piVar2;
    if (iVar1 == 0) {
      if (assert_failed == 0) {
        assert_failed = 0;
        uVar3 = 0xfffe7954;
        goto LAB_080bdcab;
      }
LAB_080bdd70:
      assert_failed = 0;
      uVar3 = 0xfffe795d;
      goto LAB_080bdcab;
    }
  }
  uVar3 = 0xffffffff;
LAB_080bdcab:
  state.syserr = iVar1;
  state.basic = uVar3;
  connect_socket(socket,state);
  return;
}



// WARNING: Unknown calling convention

void make_connection(socket *socket,uri *uri,socket_connect_T connect_done,int no_cache)

{
  byte bVar1;
  connection_state cVar2;
  connection_state cVar3;
  uchar *name;
  connect_info *pcVar4;
  connect_info *connect_info;
  int iVar5;
  dns_result dVar6;
  blacklist_flags bVar7;
  socket_operation_T UNRECOVERED_JUMPTABLE;
  uint uVar8;
  dns_result result;
  uchar *host;
  uri *local_24;
  socket_connect_T local_20;
  
  name = get_uri_string(uri,URI_DNS_HOST);
  if (assert_failed == 0) {
    uVar8 = 0;
  }
  else {
    uVar8 = 0xfffe795d;
  }
  assert_failed = 0;
  cVar3.syserr = 0;
  cVar3.basic = uVar8;
  (*socket->ops->set_timeout)(socket,cVar3);
  if (name == (uchar *)0x0) {
    UNRECOVERED_JUMPTABLE = socket->ops->retry;
    if (assert_failed == 0) {
      uri = (uri *)0xfffe795c;
    }
    else {
LAB_080bdee8:
      uri = (uri *)0xfffe795d;
    }
  }
  else {
    pcVar4 = init_connection_info(uri,socket,connect_done);
    if (pcVar4 == (connect_info *)0x0) {
      mem_free(name);
      UNRECOVERED_JUMPTABLE = socket->ops->retry;
      connection_state((connection_basic_state)&local_24);
      connect_done = local_20;
      uri = local_24;
      goto LAB_080bdedb;
    }
    socket->connect_info = pcVar4;
    iVar5 = get_protocol_need_ssl(uri->protocol);
    bVar1 = socket->field_0x24;
    socket->field_0x24 = bVar1 & 0xfd | ((byte)iVar5 & 1) * '\x02';
    if ((bVar1 & 8) == 0) {
      bVar7 = get_blacklist_flags(uri);
      socket->field_0x24 = socket->field_0x24 & 0xfb | (byte)((bVar7 >> 2 & 1) << 2) | 8;
    }
    dVar6 = find_host(name,&pcVar4->dnsquery,dns_found,socket,no_cache);
    mem_free(name);
    if (dVar6 != DNS_ASYNC) {
      return;
    }
    UNRECOVERED_JUMPTABLE = socket->ops->set_state;
    if (assert_failed != 0) goto LAB_080bdee8;
    uri = (uri *)0x1;
  }
  assert_failed = 0;
  connect_done = (socket_connect_T)0x0;
LAB_080bdedb:
  cVar2.syserr = (int)connect_done;
  cVar2.basic = (connection_basic_state)uri;
                    // WARNING: Could not recover jumptable at 0x080bdee2. Too many branches
                    // WARNING: Treating indirect jump as call
  (*UNRECOVERED_JUMPTABLE)(socket,cVar2);
  return;
}



// WARNING: Unknown calling convention

void done_state_message(void)

{
  void **ppvVar1;
  xlist_head *head;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  xlist_head *next;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)strerror_buf.next;
  if ((list_head_elinks *)strerror_buf.next != &strerror_buf) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &strerror_buf);
  }
  plVar2 = (list_head_elinks *)strerror_buf.prev;
  if ((list_head_elinks *)strerror_buf.prev != plVar3) {
    do {
      ppvVar1 = &plVar2->prev;
      plVar2 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != plVar3);
  }
                    // WARNING: Load size is inaccurate
  plVar2 = *strerror_buf.next;
  p = (list_head_elinks *)strerror_buf.next;
  if ((list_head_elinks *)strerror_buf.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_state_message(connection_state state,terminal *term)

{
  void *pvVar1;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  void **msgid;
  int i;
  int new_charset_1;
  size_t n2;
  void **ppvVar4;
  strerror_val *s;
  list_head_elinks *plVar5;
  uchar *unknown_error;
  
  if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset))
  {
    puVar3 = get_cp_mime_name(iVar2);
    bind_textdomain_codeset("elinks",puVar3);
    current_charset = iVar2;
  }
  msgid = (void **)gettext((uchar *)"Unknown error");
  if (state.basic == S_ERRNO) {
    puVar3 = (uchar *)strerror(state.syserr);
    if ((puVar3 != (uchar *)0x0) && (*puVar3 != '\0')) {
      n2 = strlen((char *)puVar3);
      plVar5 = (list_head_elinks *)strerror_buf.next;
      if ((list_head_elinks *)strerror_buf.next != &strerror_buf) {
        do {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.c";
          errline = 0xb0;
          iVar2 = elinks_strlcmp((uchar *)(plVar5 + 1),0xffffffff,puVar3,n2);
          if (iVar2 == 0) {
            return (uchar *)(plVar5 + 1);
          }
          plVar5 = (list_head_elinks *)plVar5->next;
        } while (plVar5 != &strerror_buf);
      }
      ppvVar4 = (void **)mem_calloc(1,n2 + 0xc);
      if (ppvVar4 != (void **)0x0) {
        msgid = ppvVar4 + 2;
        memcpy(msgid,puVar3,n2 + 1);
        pvVar1 = plVar5->next;
        ppvVar4[1] = plVar5;
        *ppvVar4 = pvVar1;
        plVar5->next = ppvVar4;
        *(void ***)((int)*ppvVar4 + 4) = ppvVar4;
      }
    }
  }
  else {
    iVar2 = 0;
    ppvVar4 = (void **)"Waiting in queue";
    if (state.basic != S_WAIT) {
      do {
        iVar2 = iVar2 + 1;
        if ((void **)msg_dsc[iVar2].msg == (void **)0x0) {
          return (uchar *)msgid;
        }
        ppvVar4 = (void **)msg_dsc[iVar2].msg;
      } while (msg_dsc[iVar2].n != state.basic);
    }
    msgid = ppvVar4;
    if (*(char *)msgid != '\0') {
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar3 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar3);
        current_charset = iVar2;
      }
      puVar3 = gettext((uchar *)msgid);
      return puVar3;
    }
  }
  return (uchar *)msgid;
}



// WARNING: Unknown calling convention

int ssl_close(socket *socket)

{
                    // WARNING: Load size is inaccurate
  gnutls_bye(*socket->ssl,0);
  done_ssl_connection(socket);
  return 0;
}



// WARNING: Unknown calling convention

ssize_t ssl_read(socket *socket,uchar *data,int len)

{
  ssize_t sVar1;
  ssize_t rd;
  int *piVar2;
  
                    // WARNING: Load size is inaccurate
  sVar1 = gnutls_record_recv(*socket->ssl,data,len);
  if (0 < sVar1) {
    return sVar1;
  }
  if (sVar1 != -0x25) {
    if ((sVar1 == -0x34) || (sVar1 == -0x1c)) {
      return -3;
    }
    if (sVar1 == 0) {
      return -4;
    }
    if (sVar1 != -0x36) {
      piVar2 = __errno_location();
      *piVar2 = -0x186b2;
      return -2;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

ssize_t ssl_write(socket *socket,uchar *data,int len)

{
  ssize_t sVar1;
  ssize_t wr;
  int *piVar2;
  
                    // WARNING: Load size is inaccurate
  sVar1 = gnutls_record_send(*socket->ssl,data,len);
  if (0 < sVar1) {
    return sVar1;
  }
  if ((sVar1 != -0x34) && (sVar1 != -0x1c)) {
    if (sVar1 == 0) {
      return -5;
    }
    if (sVar1 != -0x35) {
      piVar2 = __errno_location();
      *piVar2 = -0x186b2;
      return -2;
    }
  }
  return -1;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080be328;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080be328:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

void ssl_want_read(socket *socket)

{
  socket_operation_T p_Var1;
  connection_state cVar2;
  connection_state cVar3;
  int iVar4;
  option_value *poVar5;
  uint uVar6;
  char *pcVar7;
  undefined4 local_14;
  undefined4 local_10;
  
  if ((socket->field_0x24 & 4) != 0) {
                    // WARNING: Load size is inaccurate
    gnutls_protocol_set_priority(*socket->ssl,ssl_set_no_tls::lexical_block_0::protocol_priority);
  }
                    // WARNING: Load size is inaccurate
  iVar4 = gnutls_handshake(*socket->ssl);
  if (iVar4 != -0x1c) {
    if (iVar4 == 0) {
      pcVar7 = "connection.ssl.cert_verify";
      poVar5 = get_opt_();
                    // WARNING: Load size is inaccurate
      if ((poVar5->tree != (list_head_elinks *)0x0) &&
         (iVar4 = gnutls_certificate_verify_peers(*socket->ssl,pcVar7), iVar4 != 0)) {
        p_Var1 = socket->ops->retry;
        connection_state((connection_basic_state)&local_14);
        cVar3.syserr = local_10;
        cVar3.basic = local_14;
        (*p_Var1)(socket,cVar3);
        return;
      }
      complete_connect_socket(socket,(uri *)0x0,(socket_connect_T)0x0);
    }
    else if (iVar4 != -0x34) {
      socket->field_0x24 =
           socket->field_0x24 & 0xfb | (byte)((((byte)socket->field_0x24 >> 2 ^ 1) & 1) << 2);
      if (assert_failed == 0) {
        uVar6 = 0xfffe794e;
      }
      else {
        uVar6 = 0xfffe795d;
      }
      assert_failed = 0;
      cVar2.syserr = 0;
      cVar2.basic = uVar6;
      (*socket->ops->retry)(socket,cVar2);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int ssl_connect(socket *socket)

{
  socket_operation_T p_Var1;
  connection_state state;
  connection_state cVar2;
  connection_state cVar3;
  int iVar4;
  int ret;
  uint uVar5;
  option_value *poVar6;
  char *pcVar7;
  undefined4 local_14;
  undefined4 local_10;
  
  iVar4 = init_ssl_connection(socket);
  if (iVar4 == -0x186b2) {
    p_Var1 = socket->ops->done;
    connection_state((connection_basic_state)&local_14);
    cVar3.syserr = local_10;
    cVar3.basic = local_14;
    (*p_Var1)(socket,cVar3);
    return -1;
  }
  if ((socket->field_0x24 & 4) != 0) {
                    // WARNING: Load size is inaccurate
    gnutls_protocol_set_priority(*socket->ssl,ssl_set_no_tls::lexical_block_0::protocol_priority);
  }
                    // WARNING: Load size is inaccurate
  gnutls_transport_set_ptr(*socket->ssl,socket->fd);
                    // WARNING: Load size is inaccurate
  iVar4 = gnutls_handshake(*socket->ssl);
  if (iVar4 != -0x1c) {
    if (iVar4 == 0) {
      pcVar7 = "connection.ssl.cert_verify";
      poVar6 = get_opt_();
                    // WARNING: Load size is inaccurate
      if ((poVar6->tree == (list_head_elinks *)0x0) ||
         (iVar4 = gnutls_certificate_verify_peers(*socket->ssl,pcVar7), iVar4 == 0)) {
        return 0;
      }
    }
    else {
      if (iVar4 == -0x34) goto LAB_080be578;
      if (iVar4 != 0) {
        socket->field_0x24 =
             socket->field_0x24 & 0xfb | (byte)((((byte)socket->field_0x24 >> 2 ^ 1) & 1) << 2);
      }
    }
    if (assert_failed == 0) {
      uVar5 = 0xfffe794e;
    }
    else {
      uVar5 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar5;
    connect_socket(socket,state);
    return -1;
  }
LAB_080be578:
  if (assert_failed == 0) {
    uVar5 = 3;
  }
  else {
    uVar5 = 0xfffe795d;
  }
  assert_failed = 0;
  cVar2.syserr = 0;
  cVar2.basic = uVar5;
  (*socket->ops->set_state)(socket,cVar2);
  set_handlers(socket->fd,ssl_want_read,(select_handler_T)0x0,dns_exception,socket);
  return -1;
}



// WARNING: Unknown calling convention

void done_gnutls(module *module)

{
  if (xcred != (gnutls_certificate_credentials_t)0x0) {
    gnutls_certificate_free_credentials(xcred);
  }
  if (anon_cred != (gnutls_anon_client_credentials_t)0x0) {
    gnutls_anon_free_client_credentials(anon_cred);
  }
  gnutls_global_deinit();
  return;
}



// WARNING: Unknown calling convention

void init_gnutls(module *module)

{
  uchar *puVar1;
  int iVar2;
  option_value *poVar3;
  undefined4 uVar4;
  uchar *ca_file;
  int ret;
  char *pcVar5;
  
  iVar2 = gnutls_global_init();
  pcVar5 = "connection.ssl.trusted_ca_file";
  poVar3 = get_opt_();
  puVar1 = poVar3->string;
  if (iVar2 < 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 0x81;
    pcVar5 = (char *)gnutls_strerror(iVar2,pcVar5);
    elinks_internal((uchar *)"GNUTLS init failed: %s",pcVar5);
    iVar2 = gnutls_anon_allocate_client_credentials(&anon_cred);
  }
  else {
    iVar2 = gnutls_anon_allocate_client_credentials(&anon_cred);
  }
  if (iVar2 < 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 0x85;
    pcVar5 = (char *)gnutls_strerror(iVar2,pcVar5);
    elinks_internal((uchar *)"GNUTLS anon credentials alloc failed: %s",pcVar5);
  }
  iVar2 = gnutls_certificate_allocate_credentials(&xcred);
  if (iVar2 < 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 0x8a;
    uVar4 = gnutls_strerror(iVar2,pcVar5);
    elinks_internal((uchar *)"GNUTLS X509 credentials alloc failed: %s",uVar4);
  }
  if (*puVar1 != '\0') {
    gnutls_certificate_set_x509_trust_file(xcred,puVar1,1);
    gnutls_certificate_set_verify_flags(xcred,2);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_ssl_connection_cipher(socket *socket)

{
  undefined4 *puVar1;
  string *psVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  uchar *puVar9;
  string str;
  
  puVar1 = (undefined4 *)socket->ssl;
  psVar2 = init_string(&str);
  puVar9 = (uchar *)0x0;
  if (psVar2 != (string *)0x0) {
    uVar3 = gnutls_compression_get(*puVar1);
    uVar3 = gnutls_compression_get_name(uVar3);
    uVar4 = gnutls_certificate_type_get(*puVar1);
    uVar4 = gnutls_certificate_type_get_name(uVar4);
    uVar5 = gnutls_mac_get(*puVar1);
    uVar5 = gnutls_mac_get_name(uVar5);
    uVar6 = gnutls_cipher_get(*puVar1);
    uVar6 = gnutls_cipher_get_name(uVar6);
    uVar7 = gnutls_kx_get(*puVar1);
    uVar7 = gnutls_kx_get_name(uVar7);
    uVar8 = gnutls_protocol_get_version(*puVar1);
    uVar8 = gnutls_protocol_get_name(uVar8);
    add_format_to_string
              (&str,(uchar *)"%s - %s - %s - %s - %s (compr: %s)",uVar8,uVar7,uVar6,uVar5,uVar4,
               uVar3);
    puVar9 = str.source;
  }
  return puVar9;
}



// WARNING: Unknown calling convention

void done_ssl_connection(socket *socket)

{
  undefined4 *p;
  gnutls_session_t *ssl;
  
  p = (undefined4 *)socket->ssl;
  if (p != (undefined4 *)0x0) {
    gnutls_deinit(*p);
    mem_free(p);
    socket->ssl = (void *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

int init_ssl_connection(socket *socket)

{
  undefined4 *p;
  int iVar1;
  
  p = (undefined4 *)mem_alloc(4);
  if (p == (undefined4 *)0x0) {
    return -0x186b2;
  }
  iVar1 = gnutls_init(p,2);
  if (-1 < iVar1) {
    iVar1 = gnutls_credentials_set(*p,2,anon_cred);
    if (-1 < iVar1) {
      iVar1 = gnutls_credentials_set(*p,1,xcred);
      if ((-1 < iVar1) &&
         (iVar1 = gnutls_priority_set_direct(*p,"NORMAL:-CTYPE-OPENPGP",0), iVar1 == 0)) {
        gnutls_cipher_set_priority(*p,cipher_priority);
        gnutls_kx_set_priority(*p,kx_priority);
        socket->ssl = p;
        return -100000;
      }
      gnutls_deinit(*p);
      mem_free(p);
      return -0x186b2;
    }
    gnutls_deinit(*p);
  }
  mem_free(p);
  return -0x186b2;
}



// WARNING: Unknown calling convention

int can_open_in_new(terminal *term)

{
  int possibilities;
  int iVar1;
  open_in_new *poVar2;
  term_env_type tVar3;
  uint uVar4;
  
  poVar2 = open_in_new;
  tVar3 = ENV_XWIN;
  iVar1 = 0;
  do {
    poVar2 = poVar2 + 1;
    uVar4 = tVar3 & term->environment;
    tVar3 = poVar2->env;
    iVar1 = (iVar1 + 1) - (uint)(uVar4 == 0);
  } while (tVar3 != ~ENV_ANY);
  return iVar1;
}



// WARNING: Unknown calling convention

void open_new_window(terminal *term,uchar *exe_name,term_env_type environment,uchar *param)

{
  uint uVar1;
  open_in_new *poVar2;
  uchar *puVar3;
  uchar *puVar4;
  int iVar5;
  int i;
  uchar *command;
  
  iVar5 = 0;
  poVar2 = open_in_new;
  uVar1 = environment & 2U;
  do {
    poVar2 = poVar2 + 1;
    if (uVar1 != 0) {
      command = open_in_new[iVar5].command;
LAB_080beaa6:
      if ((assert_failed == 0) &&
         (assert_failed = (int)(command == (uchar *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/osdep/newwin.c";
        errline = 0x4a;
        elinks_internal((uchar *)"assertion command failed!");
      }
      if ((environment & 2U) == 0) {
        puVar3 = command;
        if ((((environment & 0x20U) != 0) &&
            (puVar3 = (uchar *)getenv("ELINKS_TWTERM"), puVar3 == (uchar *)0x0)) &&
           (puVar4 = (uchar *)getenv("LINKS_TWTERM"), puVar3 = command, puVar4 != (uchar *)0x0)) {
          puVar3 = puVar4;
        }
      }
      else {
        puVar3 = (uchar *)getenv("ELINKS_XTERM");
        if ((puVar3 == (uchar *)0x0) &&
           (puVar4 = (uchar *)getenv("LINKS_XTERM"), puVar3 = command, puVar4 != (uchar *)0x0)) {
          puVar3 = puVar4;
        }
      }
      puVar3 = straconcat(puVar3,&DAT_08134f9c,exe_name,&DAT_08134f9c,param,0);
      if (puVar3 != (uchar *)0x0) {
        exec_on_terminal(term,puVar3,"",TERM_EXEC_NEWWIN);
        mem_free(puVar3);
        return;
      }
      return;
    }
    iVar5 = iVar5 + 1;
    if (poVar2->env == ~ENV_ANY) {
      command = (uchar *)0x0;
      goto LAB_080beaa6;
    }
    uVar1 = environment & poVar2->env;
  } while( true );
}



// WARNING: Unknown calling convention

void sigwinch(void *s)

{
                    // WARNING: Could not recover jumptable at 0x080bebea. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)s)();
  return;
}



// WARNING: Unknown calling convention

void set_bin(int fd)

{
  return;
}



// WARNING: Unknown calling convention

int resize_window(int width,int height,int old_width,int old_height)

{
  return -1;
}



// WARNING: Unknown calling convention

void want_draw(void)

{
  return;
}



// WARNING: Unknown calling convention

void done_draw(void)

{
  return;
}



// WARNING: Unknown calling convention

int get_output_handle(void)

{
  return 1;
}



// WARNING: Unknown calling convention

void terminate_osdep(void)

{
  return;
}



// WARNING: Unknown calling convention

void block_stdin(void)

{
  return;
}



// WARNING: Unknown calling convention

void unblock_stdin(void)

{
  return;
}



// WARNING: Unknown calling convention

void elinks_cfmakeraw(termios *t)

{
  t->c_iflag = t->c_iflag & 0xfffffe14;
  t->c_oflag = t->c_oflag & 0xfffffffe;
  t->c_lflag = t->c_lflag & 0xffff7fb4;
  t->c_cc[6] = '\x01';
  t->c_cc[5] = '\0';
  return;
}



// WARNING: Unknown calling convention

int can_resize_window(int environment)

{
  return (uint)((environment & 10U) != 0);
}



// WARNING: Unknown calling convention

int can_open_os_shell(int environment)

{
  return 1;
}



// WARNING: Unknown calling convention

void set_highpri(void)

{
  return;
}



// WARNING: Unknown calling convention

uchar * get_system_str(int xwin)

{
  char *pcVar1;
  
  pcVar1 = "unix-xwin";
  if (xwin == 0) {
    pcVar1 = "unix";
  }
  return (uchar *)pcVar1;
}



// WARNING: Unknown calling convention

void init_osdep(void)

{
  setlocale(6,"");
  return;
}



// WARNING: Unknown calling convention

int get_ctl_handle(void)

{
  int iVar1;
  int iVar2;
  
  iVar1 = isatty(0);
  iVar2 = 0;
  if ((iVar1 == 0) && (iVar2 = get_ctl_handle::fd, get_ctl_handle::fd < 0)) {
    get_ctl_handle::fd = open64("/dev/tty",0);
    return get_ctl_handle::fd;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_input_handle(void)

{
  int iVar1;
  
  iVar1 = get_ctl_handle();
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * get_window_title(void)

{
  uchar *puVar1;
  
  puVar1 = stracpy("");
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * get_clipboard_text(void)

{
  uchar *puVar1;
  
  puVar1 = clipboard;
  if (clipboard == (uchar *)0x0) {
    puVar1 = "";
  }
  puVar1 = stracpy(puVar1);
  return puVar1;
}



// WARNING: Unknown calling convention

int exe(uchar *path)

{
  int iVar1;
  
  iVar1 = system((char *)path);
  return iVar1;
}



// WARNING: Unknown calling convention

int is_xterm(void)

{
  char *pcVar1;
  char *pcVar2;
  uchar *windowid;
  uchar *display;
  
  if (is_xterm::xt != -1) {
    return is_xterm::xt;
  }
  pcVar1 = getenv("DISPLAY");
  pcVar2 = getenv("WINDOWID");
  if ((pcVar2 == (char *)0x0) || (*pcVar2 == '\0')) {
    pcVar2 = getenv("KONSOLE_DCOP_SESSION");
  }
  if (((pcVar1 == (char *)0x0) || (pcVar2 == (char *)0x0)) || (*pcVar1 == '\0')) {
    is_xterm::xt = 0;
  }
  else {
    is_xterm::xt = (int)(*pcVar2 != '\0');
  }
  return is_xterm::xt;
}



// WARNING: Unknown calling convention

int is_gnuscreen(void)

{
  char *pcVar1;
  
  if (is_gnuscreen::screen != -1) {
    return is_gnuscreen::screen;
  }
  pcVar1 = getenv("STY");
  is_gnuscreen::screen = (uint)(pcVar1 != (char *)0x0);
  return (uint)(pcVar1 != (char *)0x0);
}



// WARNING: Unknown calling convention

void set_window_title(uchar *title,int codepage)

{
  uint uVar1;
  uchar *puVar2;
  int iVar3;
  string *psVar4;
  size_t sVar5;
  unicode_val_T unicode;
  unicode_val_T uVar6;
  uint uVar7;
  uchar *puVar8;
  int newlength;
  size_t newsize;
  uint size;
  uchar *__src;
  int charlen;
  size_t __n;
  string filtered;
  uchar *local_20 [4];
  
  iVar3 = is_xterm();
  if (((iVar3 != 0) || (iVar3 = is_gnuscreen(), iVar3 != 0)) &&
     (psVar4 = init_string(&filtered), psVar4 != (string *)0x0)) {
    if (title != (uchar *)0x0) {
      local_20[0] = title;
      sVar5 = strlen((char *)title);
      puVar2 = title;
LAB_080beed8:
      __src = puVar2;
      uVar6 = cp_to_unicode(codepage,local_20,title + sVar5);
      if (uVar6 != 0xfffffffd) {
        __n = (int)local_20[0] - (int)__src;
        puVar2 = local_20[0];
        if ((0x20 < uVar6 - 0x7f) && (puVar2 = local_20[0], 0x1f < uVar6)) {
          if (0x254 < (int)(filtered.length + __n)) {
            add_to_string(&filtered,"...");
            goto LAB_080befbb;
          }
          if (assert_failed != 0) {
LAB_080bf038:
            assert_failed = 0;
            puVar2 = local_20[0];
            goto LAB_080beed8;
          }
          if ((__src == (uchar *)0x0) || ((int)__n < 0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080bf038;
          }
          else {
            assert_failed = 0;
          }
          puVar2 = local_20[0];
          if (__n != 0) {
            iVar3 = __n + filtered.length;
            uVar1 = filtered.length + 0xffU >> 8;
            uVar7 = filtered.length + 0xffU & 0xffffff00;
            size = iVar3 + 0x100U & 0xffffff00;
            if (uVar7 <= size && size + uVar1 * -0x100 != 0) {
              puVar8 = (uchar *)mem_realloc(filtered.source,size);
              puVar2 = local_20[0];
              if (puVar8 == (uchar *)0x0) goto LAB_080beed8;
              filtered.source = puVar8;
              memset(puVar8 + uVar7,0,size + uVar1 * -0x100);
            }
            puVar2 = local_20[0];
            if (filtered.source != (uchar *)0x0) {
              memcpy(filtered.source + filtered.length,__src,__n);
              filtered.source[iVar3] = '\0';
              puVar2 = local_20[0];
              filtered.length = iVar3;
            }
          }
        }
        goto LAB_080beed8;
      }
    }
LAB_080befbb:
    __printf_chk(1,&DAT_08131e7e,filtered.source);
    fflush(stdout);
    done_string(&filtered);
  }
  return;
}



// WARNING: Unknown calling convention

void set_clipboard_text(uchar *data)

{
  int iVar1;
  string *psVar2;
  size_t len;
  string str;
  
  iVar1 = is_gnuscreen();
  if (iVar1 != 0) {
    psVar2 = init_string(&str);
    if (psVar2 == (string *)0x0) {
      return;
    }
    add_to_string(&str,(uchar *)"screen -X register . ");
    len = strlen((char *)data);
    add_shell_quoted_to_string(&str,data,len);
    if (str.length != 0) {
      system((char *)str.source);
    }
    if (str.source != (uchar *)0x0) {
      done_string(&str);
    }
  }
  if (clipboard != (uchar *)0x0) {
    free(clipboard);
  }
  clipboard = (uchar *)__strdup(data);
  return;
}



// WARNING: Unknown calling convention

int is_twterm(void)

{
  char *pcVar1;
  
  if (is_twterm::tw != -1) {
    return is_twterm::tw;
  }
  pcVar1 = getenv("TWDISPLAY");
  is_twterm::tw = (uint)(pcVar1 != (char *)0x0);
  return (uint)(pcVar1 != (char *)0x0);
}



// WARNING: Unknown calling convention

int get_system_env(void)

{
  int iVar1;
  int iVar2;
  int env;
  uint uVar3;
  
  iVar1 = is_xterm();
  iVar2 = is_twterm();
  uVar3 = ~-(uint)(iVar1 == 0) & 2;
  if (iVar2 != 0) {
    uVar3 = uVar3 | 0x20;
  }
  iVar1 = is_gnuscreen();
  if (iVar1 != 0) {
    uVar3 = uVar3 | 4;
  }
  return uVar3 | 1;
}



// WARNING: Unknown calling convention

uchar * get_shell(void)

{
  uchar *puVar1;
  uchar *shell;
  
  puVar1 = (uchar *)getenv("SHELL");
  if ((puVar1 == (uchar *)0x0) || (*puVar1 == '\0')) {
    puVar1 = "/bin/sh";
  }
  return puVar1;
}



// WARNING: Unknown calling convention

int c_pipe(int *fd)

{
  int iVar1;
  
  iVar1 = pipe(fd);
  return iVar1;
}



// WARNING: Unknown calling convention

void unhandle_terminal_resize(int fd)

{
  install_signal_handler(0x1c,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

void handle_terminal_resize(int fd,_func_void *fn)

{
  install_signal_handler(0x1c,sigwinch,fn,0);
  return;
}



// WARNING: Unknown calling convention

void set_cwd(uchar *path)

{
  int iVar1;
  int *piVar2;
  
  if (path != (uchar *)0x0) {
    do {
      iVar1 = chdir((char *)path);
      if (iVar1 == 0) {
        return;
      }
      piVar2 = __errno_location();
    } while (*piVar2 == 4);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_cwd(void)

{
  uchar *__buf;
  char *pcVar1;
  int *piVar2;
  uchar *buf;
  size_t size;
  int bufsize;
  
  size = 0x80;
  do {
    __buf = (uchar *)mem_alloc(size);
    while( true ) {
      if ((__buf == (uchar *)0x0) || (pcVar1 = getcwd((char *)__buf,size), pcVar1 != (char *)0x0)) {
        return __buf;
      }
      mem_free(__buf);
      piVar2 = __errno_location();
      if (*piVar2 == 4) break;
      if (*piVar2 != 0x22) {
        return (uchar *)0x0;
      }
      size = size + 0x80;
      __buf = (uchar *)mem_alloc(size);
    }
  } while( true );
}



// WARNING: Unknown calling convention

int get_e(uchar *env)

{
  char *__nptr;
  int iVar1;
  char *v;
  
  __nptr = getenv((char *)env);
  iVar1 = 0;
  if (__nptr != (char *)0x0) {
    iVar1 = strtol(__nptr,(char **)0x0,10);
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void get_terminal_size(int fd,int *x,int *y)

{
  int iVar1;
  int iVar2;
  winsize ws;
  
  iVar1 = ioctl(1,0x5413,&ws);
  if (iVar1 == -1) {
    *x = 0;
    *y = 0;
  }
  else {
    *x = (uint)ws.ws_col;
    *y = (uint)ws.ws_row;
  }
  if (*x == 0) {
    iVar2 = get_e((uchar *)"COLUMNS");
    iVar1 = 0x50;
    if (iVar2 != 0) {
      iVar1 = iVar2;
    }
    *x = iVar1;
  }
  if (*y == 0) {
    iVar2 = get_e((uchar *)"LINES");
    iVar1 = 0x19;
    if (iVar2 != 0) {
      iVar1 = iVar2;
    }
    *y = iVar1;
  }
  return;
}



// WARNING: Unknown calling convention

void set_ip_tos_throughput(int socket)

{
  undefined4 local_10 [3];
  
  local_10[0] = 8;
  setsockopt(socket,0,1,local_10,4);
  return;
}



// WARNING: Unknown calling convention

int set_blocking_fd(int fd)

{
  uint uVar1;
  int iVar2;
  int flags;
  
  uVar1 = fcntl(fd,3,0);
  iVar2 = -1;
  if (-1 < (int)uVar1) {
    iVar2 = fcntl(fd,4,uVar1 & 0xfffff7ff);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int set_nonblocking_fd(int fd)

{
  uint uVar1;
  int iVar2;
  int flags;
  
  uVar1 = fcntl(fd,3,0);
  iVar2 = -1;
  if (-1 < (int)uVar1) {
    iVar2 = fcntl(fd,4,uVar1 | 0x800);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int start_thread(_func_void_void_ptr_int *fn,void *ptr,int l)

{
  int iVar1;
  __pid_t _Var2;
  terminal *term;
  int p [2];
  
  iVar1 = pipe(p);
  if (((iVar1 < 0) || (iVar1 = set_nonblocking_fd(p[0]), iVar1 < 0)) ||
     (iVar1 = set_nonblocking_fd(p[1]), iVar1 < 0)) {
    p[0] = -1;
  }
  else {
    _Var2 = fork();
    term = (terminal *)terminals.next;
    if (_Var2 == 0) {
      for (; term != (terminal *)&terminals; term = term->next) {
        if (0 < term->fdin) {
          close(term->fdin);
        }
      }
      close(p[0]);
      (*fn)(ptr,p[1]);
      write(p[1],&DAT_0813532d,1);
      close(p[1]);
                    // WARNING: Subroutine does not return
      _exit(0);
    }
    if (_Var2 == -1) {
      close(p[0]);
      close(p[1]);
      p[0] = -1;
    }
    else {
      close(p[1]);
    }
  }
  return p[0];
}



// WARNING: Unknown calling convention

void sig_ign(void *x)

{
  return;
}



// WARNING: Unknown calling convention

int check_signals(void)

{
  code *pcVar1;
  int iVar2;
  int r;
  int iVar3;
  
  iVar2 = 0;
  iVar3 = 0;
  do {
    if (*(int *)((int)&signal_info[0].mask + iVar3) != 0) {
      pcVar1 = *(code **)((int)&signal_info[0].handler + iVar3);
      *(undefined4 *)((int)&signal_info[0].mask + iVar3) = 0;
      if (pcVar1 != (code *)0x0) {
        (*pcVar1)(*(undefined4 *)((int)&signal_info[0].data + iVar3));
      }
      check_bottom_halves();
      iVar2 = 1;
    }
    iVar3 = iVar3 + 0x10;
  } while (iVar3 != 0x200);
  return iVar2;
}



// WARNING: Unknown calling convention

void sig_chld(void *p)

{
  __pid_t _Var1;
  
  do {
    _Var1 = waitpid(-1,(int *)0x0,1);
  } while (0 < _Var1);
  return;
}



// WARNING: Unknown calling convention

void uninstall_alarm(void)

{
  pending_alarm = 0;
  alarm(0);
  return;
}



// WARNING: Unknown calling convention

void sig_segv(terminal *term)

{
  fputc(7,stderr);
  fflush(stderr);
  sleep(1);
  fwrite(&DAT_08131ec2,1,2,stderr);
  fwrite("ELinks crashed. That shouldn\'t happen. Please report this incident to\nthe developers. If you would like to help to debug the problem you just\nuncovered, please keep the core you just got and send the developers\nthe output of \'bt\' command entered inside of gdb (which you run as:\ngdb elinks core). Thanks a lot for your cooperation!\n\n"
         ,1,0x14d,stderr);
  fputs((char *)full_static_version,stderr);
  fwrite(&DAT_081281ca,1,2,stderr);
  dump_backtrace((FILE *)stderr,1);
                    // WARNING: Subroutine does not return
  abort();
}



// WARNING: Unknown calling convention

void sig_cont(terminal *term)

{
  int iVar1;
  
  iVar1 = unblock_itrm();
  if (iVar1 != 0) {
    return;
  }
  resize_terminal();
  return;
}



// WARNING: Unknown calling convention

void sig_tstp(terminal *term)

{
  __pid_t __pid;
  __pid_t _Var1;
  pid_t pid;
  
  __pid = getpid();
  block_itrm();
  _Var1 = fork();
  if (_Var1 != 0) {
    raise(0x13);
    return;
  }
  sleep(1);
  kill(__pid,0x12);
                    // WARNING: Subroutine does not return
  _exit(0);
}



// WARNING: Unknown calling convention

void sig_ctrl_c(terminal *term)

{
  int iVar1;
  
  iVar1 = is_blocked();
  if (iVar1 != 0) {
    return;
  }
  kbd_ctrl_c();
  return;
}



// WARNING: Unknown calling convention

void clear_signal_mask_and_handlers(void)

{
  int iVar1;
  signal_info *psVar2;
  
  psVar2 = signal_info;
  for (iVar1 = 0x80; iVar1 != 0; iVar1 = iVar1 + -1) {
    psVar2->handler = (_func_void_void_ptr *)0x0;
    psVar2 = (signal_info *)&psVar2->data;
  }
  return;
}



// WARNING: Unknown calling convention

void install_signal_handler(int sig,_func_void_void_ptr *fn,void *data,int critical)

{
  int iVar1;
  sigaction *psVar2;
  byte bVar3;
  sigaction sa;
  
  bVar3 = 0;
  if (assert_failed == 0) {
    assert_failed = (int)(0x1f < (uint)sig);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c";
      errline = 0x105;
      elinks_internal((uchar *)
                      "assertion sig >= 0 && sig < NUM_SIGNALS failed: bad signal number: %d",sig);
      if (assert_failed != 0) goto LAB_080bf922;
    }
    psVar2 = (sigaction *)&sa;
    for (iVar1 = 0x23; iVar1 != 0; iVar1 = iVar1 + -1) {
      (psVar2->__sigaction_handler).sa_handler = (__sighandler_t)0x0;
      psVar2 = (sigaction *)((int)psVar2 + (uint)bVar3 * -8 + 4);
    }
    if (fn == (_func_void_void_ptr *)0x0) {
      sa.__sigaction_handler = (anon_union_4_2_5ad2d23e_for___sigaction_handler)0x1;
      sigfillset((sigset_t *)&sa.sa_mask);
      sigaction(sig,(sigaction *)&sa,(sigaction *)0x0);
      signal_info[sig].handler = (_func_void_void_ptr *)0x0;
      signal_info[sig].data = data;
      signal_info[sig].critical = critical;
    }
    else {
      sa.__sigaction_handler.sa_handler = got_signal;
      sigfillset((sigset_t *)&sa.sa_mask);
      signal_info[sig].handler = fn;
      signal_info[sig].data = data;
      signal_info[sig].critical = critical;
      sigaction(sig,(sigaction *)&sa,(sigaction *)0x0);
    }
  }
  else {
LAB_080bf922:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void set_sigcld(void)

{
  install_signal_handler(0x11,sig_chld,(void *)0x0,1);
  return;
}



// WARNING: Unknown calling convention

void check_for_select_race(void)

{
  if (critical_section == 0) {
    return;
  }
  install_signal_handler(0xe,alarm_handler,(void *)0x0,1);
  pending_alarm = 1;
  alarm(1);
  return;
}



// WARNING: Unknown calling convention

void alarm_handler(void *x)

{
  pending_alarm = 0;
  check_for_select_race();
  return;
}



// WARNING: Unknown calling convention

void got_signal(int sig)

{
  int iVar1;
  int *piVar2;
  signal_info *s;
  int saved_errno;
  
  piVar2 = __errno_location();
  iVar1 = *piVar2;
  if ((uint)sig < 0x20) {
    if (signal_info[sig].handler != (_func_void_void_ptr *)0x0) {
      if (signal_info[sig].critical == 0) {
        signal_info[sig].mask = 1;
        check_for_select_race();
        *piVar2 = iVar1;
      }
      else {
        (*signal_info[sig].handler)(signal_info[sig].data);
        *piVar2 = iVar1;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void unhandle_terminal_signals(terminal *term)

{
  install_signal_handler(1,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(2,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x14,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x15,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x16,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x12,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0xb,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

void handle_basic_signals(terminal *term)

{
  install_signal_handler(1,sig_intr,term,0);
  install_signal_handler(2,sig_ctrl_c,term,0);
  install_signal_handler(0xf,sig_terminate,term,0);
  install_signal_handler(0x14,sig_tstp,term,0);
  install_signal_handler(0x15,sig_tstp,term,0);
  install_signal_handler(0x16,sig_ign,term,0);
  install_signal_handler(0x12,sig_cont,term,0);
  install_signal_handler(0xb,sig_segv,term,1);
  return;
}



// WARNING: Unknown calling convention

void unhandle_basic_signals(terminal *term)

{
  install_signal_handler(1,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(2,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0xf,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x14,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x15,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x16,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0x12,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  install_signal_handler(0xb,(_func_void_void_ptr *)0x0,(void *)0x0,0);
  return;
}



// WARNING: Unknown calling convention

void sig_terminate(terminal *term)

{
  unhandle_basic_signals(term);
  program.terminate = 1;
  program.retval = RET_SIGNAL;
  return;
}



// WARNING: Unknown calling convention

void sig_intr(terminal *term)

{
  unhandle_basic_signals(term);
  if (term != (terminal *)0x0) {
    register_bottom_half_do(destroy_terminal,term);
    return;
  }
  program.terminate = 1;
  return;
}



// WARNING: Unknown calling convention

void get_system_name(void)

{
  int iVar1;
  byte bVar2;
  int iVar3;
  FILE *__stream;
  FILE *f;
  size_t sVar4;
  uchar *p;
  uchar *puVar5;
  int in_GS_OFFSET;
  utsname name;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  iVar3 = uname((utsname *)&name);
  if (iVar3 == 0) {
    __snprintf_chk(system_name,0x400,1,0x400,"%s %s %s",&name,name.release,name.machine);
  }
  else {
    __stream = popen("uname -srm","r");
    if (__stream != (FILE *)0x0) {
      sVar4 = fread(system_name,1,0x3ff,__stream);
      if (sVar4 == 0) {
        pclose(__stream);
      }
      else {
        pclose(__stream);
        puVar5 = system_name;
        system_name[1023] = '\0';
        bVar2 = system_name[0];
        while (0x1f < bVar2) {
          puVar5 = puVar5 + 1;
          bVar2 = *puVar5;
        }
        *puVar5 = 0;
        if (system_name[0] != '\0') goto LAB_080bfef1;
      }
    }
    safe_strncpy(system_name,"Unix",0x400);
  }
LAB_080bfef1:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int init_mouse(int cons,int suspend)

{
  int iVar1;
  Gpm_Connect conn;
  
  if (suspend == 0) {
    conn.eventMask = 0xffff;
    conn.maxMod = 0;
    conn.defaultMask = 0;
    conn.minMod = 0;
  }
  else {
    conn.eventMask = 0;
    conn.maxMod = 0xffff;
    conn.defaultMask = 0xffff;
    conn.minMod = 0xffff;
  }
  gpm_visiblepointer = 1;
  iVar1 = Gpm_Open(&conn,cons);
  return iVar1;
}



// WARNING: Unknown calling convention

void resume_mouse(void *h)

{
  int fd;
  
  if (h != (void *)0x0) {
    fd = init_mouse(*(int *)((int)h + 4),0);
    *(int *)h = fd;
    if (-1 < fd) {
      set_handlers(fd,gpm_mouse_in,(select_handler_T)0x0,(select_handler_T)0x0,h);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void suspend_mouse(void *h)

{
  int fd;
  
  if (h != (void *)0x0) {
    fd = init_mouse(*(int *)((int)h + 4),1);
    *(int *)h = fd;
    if (-1 < fd) {
      set_handlers(fd,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,(void *)0x0)
      ;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void unhandle_mouse(void *h)

{
  if (h != (void *)0x0) {
                    // WARNING: Load size is inaccurate
    set_handlers(*h,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,(void *)0x0);
    mem_free(h);
    Gpm_Close();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void * handle_mouse(int cons,_func_void_void_ptr_uchar_ptr_int *fn,void *data)

{
  int fd;
  int h;
  int *data_00;
  
  fd = init_mouse(cons,0);
  if ((-1 < fd) && (data_00 = (int *)mem_alloc(0x10), data_00 != (int *)0x0)) {
    *data_00 = fd;
    data_00[1] = cons;
    data_00[2] = (int)fn;
    data_00[3] = (int)data;
    set_handlers(fd,gpm_mouse_in,(select_handler_T)0x0,(select_handler_T)0x0,data_00);
    return data_00;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void gpm_mouse_in(gpm_mouse_spec *gms)

{
  short *psVar1;
  int iVar2;
  short sVar3;
  Gpm_Event gev;
  interlink_event ev;
  
  iVar2 = Gpm_GetEvent(&gev);
  psVar1 = _gpm_arg;
  if (iVar2 < 1) {
    set_handlers(gms->h,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
                 (void *)0x0);
  }
  else {
    _gpm_buf[1] = 2;
    sVar3 = gev.x + (short)gpm_zerobased;
    _gpm_arg[2] = sVar3;
    *psVar1 = sVar3;
    psVar1 = _gpm_arg;
    sVar3 = (short)gpm_zerobased + gev.y;
    _gpm_arg[3] = sVar3;
    psVar1[1] = sVar3;
    _gpm_arg[4] = 3;
    ioctl(1,0x541c,0x8148c81);
    ev.info.mouse.button = 0;
    if ((((gev.buttons & 4) == 0) && (ev.info.mouse.button = 1, (gev.buttons & 2) == 0)) &&
       (ev.info.mouse.button = 2, (gev.buttons & 1) == 0)) {
      ev.info.mouse.button = 4;
      if (-1 < gev.wdy) {
        if (gev.wdy == 0) {
          return;
        }
        ev.info.mouse.button = 3;
      }
    }
    if ((gev.type & GPM_DOWN) == 0) {
      if ((gev.type & GPM_UP) == 0) {
        if ((gev.type & GPM_DRAG) == 0) {
          if (gev.wdy == 0) {
            return;
          }
        }
        else {
          ev.info.mouse.button = ev.info.mouse.button | 0x40;
        }
      }
      else {
        ev.info.mouse.button = ev.info.mouse.button | 0x20;
      }
    }
    ev.info.mouse.x = gev.x + -1;
    if (ev.info.mouse.x < 0) {
      ev.info.mouse.x = 0;
    }
    ev.info.mouse.y = 0;
    if (-1 < gev.y + -1) {
      ev.info.mouse.y = gev.y + -1;
    }
    ev.ev = EVENT_MOUSE;
    (*gms->fn)(gms->data,(uchar *)&ev,0x10);
  }
  return;
}



// WARNING: Unknown calling convention

void about_protocol_handler(connection *conn)

{
  connection_state state;
  cache_entry *cached_00;
  cache_entry *cached;
  uint uVar1;
  char *__s2;
  int iVar2;
  uchar *puVar3;
  size_t length;
  uchar *str;
  about_page *page;
  about_page *paVar4;
  
  cached_00 = get_cache_entry(conn->uri);
  if ((cached_00 != (cache_entry *)0x0) && (cached_00->content_type == (uchar *)0x0)) {
    __s2 = "bloat";
    paVar4 = about_pages;
    puVar3 = conn->uri->data;
    do {
      iVar2 = strcmp((char *)puVar3,__s2);
      if (iVar2 == 0) {
        puVar3 = paVar4->string;
        length = strlen((char *)puVar3);
        add_fragment(cached_00,0,puVar3,length);
        *(size_t *)&conn->from = length;
        *(int *)((int)&conn->from + 4) = (int)length >> 0x1f;
        if (cached_00->content_type != (uchar *)0x0) {
          mem_free(cached_00->content_type);
        }
        break;
      }
      paVar4 = paVar4 + 1;
      __s2 = (char *)paVar4->name;
    } while ((uchar *)__s2 != (uchar *)0x0);
    puVar3 = stracpy((uchar *)"text/html");
    cached_00->content_type = puVar3;
  }
  conn->cached = cached_00;
  if (assert_failed == 0) {
    uVar1 = 0xfffe7960;
  }
  else {
    uVar1 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar1;
  abort_connection(conn,state);
  return;
}



// WARNING: Unknown calling convention

void close_all_non_term_fd(void)

{
  int iVar1;
  int n;
  int iVar2;
  int max;
  rlimit lim;
  
  iVar1 = getrlimit64(RLIMIT_NOFILE,(rlimit64 *)&lim);
  if (iVar1 == 0) {
    max = (int)lim.rlim_max;
    if ((int)lim.rlim_max < 4) {
      return;
    }
  }
  else {
    max = 0x400;
  }
  iVar1 = 3;
  do {
    iVar2 = iVar1 + 1;
    close(iVar1);
    iVar1 = iVar2;
  } while (iVar2 < max);
  return;
}



// WARNING: Unknown calling convention

connection_state init_directory_listing(string *page,uri *uri)

{
  int iVar1;
  uint uVar2;
  string *psVar3;
  char *pcVar4;
  uchar *info;
  uchar *slash;
  uint uVar5;
  undefined4 uVar6;
  uchar *puVar7;
  size_t newsize;
  uint size;
  size_t __n;
  undefined4 extraout_EDX;
  uchar *__s;
  bool bVar8;
  connection_state cVar9;
  connection_state cVar10;
  undefined4 *in_stack_00000004;
  string *local_40;
  string location;
  string decoded;
  string dirpath;
  uchar local_1d [13];
  
  dirpath.source = (uchar *)0x0;
  dirpath.length = 0;
  decoded.source = (uchar *)0x0;
  decoded.length = 0;
  location.source = (uchar *)0x0;
  location.length = 0;
  iVar1 = uri->protocol;
  psVar3 = init_string(page);
  if (psVar3 != (string *)0x0) {
    psVar3 = init_string(&dirpath);
    if (((((psVar3 != (string *)0x0) && (psVar3 = init_string(&decoded), psVar3 != (string *)0x0))
         && (psVar3 = init_string(&location), psVar3 != (string *)0x0)) &&
        (((psVar3 = add_uri_to_string(&dirpath,uri,URI_DATA), psVar3 != (string *)0x0 &&
          (psVar3 = add_uri_to_string(&location,uri,URI_DIR_LOCATION), psVar3 != (string *)0x0)) &&
         ((dirpath.length < 1 ||
          ((dirpath.source[dirpath.length + -1] == '/' ||
           (psVar3 = add_char_to_string(&dirpath,'/'), psVar3 != (string *)0x0)))))))) &&
       (psVar3 = add_string_to_string(&decoded,&dirpath), psVar3 != (string *)0x0)) {
      bVar8 = iVar1 == 4;
      decode_uri_string(&decoded);
      if (((((bVar8) || (psVar3 = add_char_to_string(&location,'/'), psVar3 != (string *)0x0)) &&
           (psVar3 = add_to_string(page,(uchar *)"<html>\n<head><title>"), psVar3 != (string *)0x0))
          && (((bVar8 || (psVar3 = add_html_to_string(page,location.source,location.length),
                         psVar3 != (string *)0x0)) &&
              (((psVar3 = add_html_to_string(page,decoded.source,decoded.length),
                psVar3 != (string *)0x0 &&
                ((psVar3 = add_to_string(page,(uchar *)"</title>\n<base href=\""),
                 psVar3 != (string *)0x0 &&
                 (psVar3 = add_html_to_string(page,location.source,location.length),
                 psVar3 != (string *)0x0)))) &&
               (psVar3 = add_html_to_string(page,dirpath.source,dirpath.length),
               psVar3 != (string *)0x0)))))) &&
         (psVar3 = add_to_string(page,(uchar *)"\" />\n</head>\n<body>\n<h2>"),
         psVar3 != (string *)0x0)) {
        switch(uri->protocol) {
        case 4:
          pcVar4 = "Local";
          break;
        default:
          pcVar4 = "?";
          break;
        case 6:
          pcVar4 = "FSP";
          break;
        case 7:
          pcVar4 = "FTP";
          break;
        case 8:
          pcVar4 = "Gopher";
          break;
        case 0x10:
          pcVar4 = "Samba";
        }
        psVar3 = add_to_string(page,(uchar *)pcVar4);
        if (((psVar3 != (string *)0x0) &&
            (psVar3 = add_to_string(page,(uchar *)" directory "), psVar3 != (string *)0x0)) &&
           ((bVar8 || (psVar3 = add_string_to_string(page,&location), psVar3 != (string *)0x0)))) {
          local_1d[0] = '/';
          __s = dirpath.source;
          while( true ) {
            pcVar4 = strchr((char *)__s,0x2f);
            if (pcVar4 == (char *)0x0) {
              psVar3 = add_to_string(page,(uchar *)"</h2>\n<pre>");
              if (psVar3 != (string *)0x0) goto LAB_080c0848;
              goto out_of_memory;
            }
            done_string(&decoded);
            psVar3 = init_string(&decoded);
            if (psVar3 == (string *)0x0) goto out_of_memory;
            if (assert_failed != 0) break;
            __n = (int)pcVar4 - (int)__s;
            if ((__s == (uchar *)0x0) || ((int)__n < 0)) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) break;
            }
            else {
              assert_failed = 0;
            }
            if (__n != 0) {
              iVar1 = __n + decoded.length;
              uVar2 = decoded.length + 0xffU >> 8;
              uVar5 = decoded.length + 0xffU & 0xffffff00;
              size = iVar1 + 0x100U & 0xffffff00;
              if (uVar5 <= size && size + uVar2 * -0x100 != 0) {
                puVar7 = (uchar *)mem_realloc(decoded.source,size);
                if (puVar7 == (uchar *)0x0) goto out_of_memory;
                decoded.source = puVar7;
                memset(puVar7 + uVar5,0,size + uVar2 * -0x100);
              }
              if (decoded.source == (uchar *)0x0) goto out_of_memory;
              memcpy(decoded.source + decoded.length,__s,__n);
              decoded.source[iVar1] = '\0';
              decoded.length = iVar1;
            }
            decode_uri_string(&decoded);
            psVar3 = add_to_string(page,(uchar *)"<a href=\"");
            if ((psVar3 == (string *)0x0) ||
               (psVar3 = add_html_to_string(page,location.source,location.length),
               psVar3 == (string *)0x0)) goto out_of_memory;
            __s = (uchar *)(pcVar4 + 1);
            psVar3 = add_html_to_string(page,dirpath.source,(int)__s - (int)dirpath.source);
            if ((psVar3 == (string *)0x0) ||
               ((((psVar3 = add_to_string(page,"\">"), psVar3 == (string *)0x0 ||
                  (psVar3 = add_html_to_string(page,decoded.source,decoded.length),
                  psVar3 == (string *)0x0)) ||
                 (psVar3 = add_to_string(page,"</a>"), psVar3 == (string *)0x0)) ||
                (psVar3 = add_html_to_string(page,local_1d,1), psVar3 == (string *)0x0))))
            goto out_of_memory;
          }
          assert_failed = 0;
        }
      }
    }
  }
out_of_memory:
  done_string(page);
LAB_080c0848:
  local_40 = &dirpath;
  done_string(local_40);
  done_string(&decoded);
  done_string(&location);
  if (0 < page->length) {
    if (assert_failed == 0) {
      uVar6 = 0xfffe7960;
    }
    else {
      uVar6 = 0xfffe795d;
    }
    assert_failed = 0;
    in_stack_00000004[1] = 0;
    *in_stack_00000004 = uVar6;
    cVar9.syserr = (int)in_stack_00000004;
    cVar9.basic = (connection_basic_state)in_stack_00000004;
    return cVar9;
  }
  if (assert_failed == 0) {
    uVar6 = 0xfffe795c;
  }
  else {
    uVar6 = 0xfffe795d;
  }
  assert_failed = 0;
  in_stack_00000004[1] = 0;
  *in_stack_00000004 = uVar6;
  cVar10.syserr = extraout_EDX;
  cVar10.basic = (connection_basic_state)in_stack_00000004;
  return cVar10;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080c0ac8;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080c0ac8:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

void data_protocol_handler(connection *conn)

{
  off_t *poVar1;
  int *piVar2;
  uri *uri;
  uri *puVar3;
  connection_state state;
  connection_state state_00;
  cache_entry *cached;
  void *pvVar4;
  uchar *puVar5;
  uchar *puVar6;
  uchar *data;
  uchar *decoded;
  size_t length;
  uint uVar7;
  void *pvVar8;
  int iVar9;
  uchar *type;
  char *src;
  uchar *data_start;
  uchar *head;
  char *pcVar10;
  char *pcVar11;
  bool bVar12;
  byte bVar13;
  size_t local_2c;
  undefined4 local_24;
  undefined4 local_20;
  
  bVar13 = 0;
  uri = conn->uri;
  cached = get_cache_entry(uri);
  if (cached == (cache_entry *)0x0) {
    if (assert_failed == 0) {
      uVar7 = 0xfffe795c;
      goto LAB_080c0caf;
    }
  }
  else {
    puVar3 = conn->uri;
    conn->cached = cached;
    src = (char *)puVar3->data;
    pvVar4 = memchr(src,0x2c,(uint)*(ushort *)&puVar3->field_0x31);
    if (pvVar4 == (void *)0x0) {
      src = "text/plain;charset=US-ASCII";
      bVar12 = false;
      local_2c = 0x1b;
    }
    else {
      local_2c = (int)pvVar4 - (int)src;
      if (local_2c < 7) {
LAB_080c0b5e:
        bVar12 = false;
      }
      else {
        iVar9 = 7;
        bVar12 = (char *)((int)pvVar4 + -7) == (char *)0x0;
        pcVar10 = ";base64";
        pcVar11 = (char *)((int)pvVar4 + -7);
        do {
          if (iVar9 == 0) break;
          iVar9 = iVar9 + -1;
          bVar12 = *pcVar10 == *pcVar11;
          pcVar10 = pcVar10 + (uint)bVar13 * -2 + 1;
          pcVar11 = pcVar11 + (uint)bVar13 * -2 + 1;
        } while (bVar12);
        if (!bVar12) goto LAB_080c0b5e;
        local_2c = local_2c - 7;
        bVar12 = true;
      }
      if (((int)local_2c < 3) || (pvVar8 = memchr(src,0x2f,local_2c), pvVar8 == (void *)0x0)) {
        src = "text/plain;charset=US-ASCII";
        local_2c = 0x1b;
      }
    }
    if (assert_failed == 0) {
      assert_failed = 0;
    }
    puVar5 = memacpy((uchar *)src,local_2c);
    if (puVar5 == (uchar *)0x0) {
LAB_080c0d50:
      connection_state((connection_basic_state)&local_24);
      state_00.syserr = local_20;
      state_00.basic = local_24;
      abort_connection(conn,state_00);
      return;
    }
    puVar6 = straconcat((uchar *)"\r\nContent-Type: ",puVar5,&DAT_081352f5,0);
    mem_free(puVar5);
    if (puVar6 == (uchar *)0x0) goto LAB_080c0d50;
    if (cached->head != (uchar *)0x0) {
      mem_free(cached->head);
    }
    cached->head = puVar6;
    if (pvVar4 == (void *)0x0) {
      data_start = puVar3->data;
    }
    else {
      data_start = (uchar *)((int)pvVar4 + 1);
    }
    if ((data_start == (uchar *)0x0) ||
       (puVar5 = memacpy(data_start,
                         (int)(uri->data + ((uint)*(ushort *)&uri->field_0x31 - (int)data_start))),
       puVar5 == (uchar *)0x0)) goto LAB_080c0d50;
    if (bVar12) {
      puVar6 = base64_encode(puVar5);
      if (puVar6 == (uchar *)0x0) goto LAB_080c0d50;
      mem_free(puVar5);
      puVar5 = puVar6;
    }
    else {
      decode_uri(puVar5);
    }
    length = strlen((char *)puVar5);
    add_fragment(cached,conn->from,puVar5,length);
    poVar1 = &conn->from;
    uVar7 = *(uint *)poVar1;
    *(size_t *)poVar1 = *(int *)poVar1 + length;
    piVar2 = (int *)((int)&conn->from + 4);
    *piVar2 = *piVar2 + ((int)length >> 0x1f) + (uint)CARRY4(uVar7,length);
    mem_free(puVar5);
    if (assert_failed == 0) {
      uVar7 = 0xfffe7960;
      goto LAB_080c0caf;
    }
  }
  uVar7 = 0xfffe795d;
LAB_080c0caf:
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar7;
  abort_connection(conn,state);
  return;
}



// WARNING: Unknown calling convention

int parse_year(uchar **date_p,uchar *end)

{
  byte *pbVar1;
  byte *pbVar2;
  int year;
  uchar *date;
  byte *pbVar3;
  
  pbVar3 = *date_p;
  if ((((end == (uchar *)0x0) || (pbVar3 + 1 < end)) && ((byte)(*pbVar3 - 0x30) < 10)) &&
     ((byte)(pbVar3[1] - 0x30) < 10)) {
    year = (pbVar3[1] - 0x210) + (uint)*pbVar3 * 10;
    if (((end == (uchar *)0x0) || (pbVar3 + 3 < end)) &&
       ((pbVar1 = pbVar3 + 2, (byte)(*pbVar1 - 0x30) < 10 &&
        (pbVar2 = pbVar3 + 3, (byte)(*pbVar2 - 0x30) < 10)))) {
      pbVar3 = pbVar3 + 4;
      year = (year * 10 + -0x30 + (uint)*pbVar1) * 10 + -0x79c + (uint)*pbVar2;
    }
    else if (year < 0x46) {
      *date_p = pbVar3 + 2;
      year = year + 100;
      return year;
    }
    *date_p = pbVar3;
  }
  else {
    year = -1;
  }
  return year;
}



// WARNING: Unknown calling convention

int parse_day(uchar **date_p,uchar *end)

{
  byte *pbVar1;
  int iVar2;
  int day;
  uchar *date;
  
  pbVar1 = *date_p;
  if (((pbVar1 < end) || (end == (uchar *)0x0)) && ((byte)(*pbVar1 - 0x30) < 10)) {
    iVar2 = *pbVar1 - 0x30;
    if (((pbVar1 + 1 < end) || (end == (uchar *)0x0)) && ((byte)(pbVar1[1] - 0x30) < 10)) {
      iVar2 = (pbVar1[1] - 0x30) + iVar2 * 10;
      *date_p = pbVar1 + 2;
    }
    else {
      *date_p = pbVar1 + 1;
    }
  }
  else {
    iVar2 = 0x20;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int parse_time(uchar **time,tm *tm,uchar *end)

{
  int iVar1;
  byte bVar2;
  byte *pbVar3;
  uchar *date;
  uchar s1;
  uchar h1;
  uchar s2;
  byte bVar4;
  uchar h2;
  uchar m2;
  uchar m1;
  byte *local_18;
  
  pbVar3 = *time;
  if (((((end == (uchar *)0x0) || (pbVar3 + 5 <= end)) && ((byte)(*pbVar3 - 0x30) < 10)) &&
      (((byte)(pbVar3[1] - 0x30) < 10 && (pbVar3[2] == 0x3a)))) &&
     ((bVar4 = pbVar3[3], (byte)(bVar4 - 0x30) < 10 &&
      (bVar2 = pbVar3[4], (byte)(bVar2 - 0x30) < 10)))) {
    iVar1 = (pbVar3[1] - 0x210) + (uint)*pbVar3 * 10;
    local_18 = pbVar3 + 5;
    tm->tm_hour = iVar1;
    tm->tm_min = (bVar2 - 0x210) + (uint)bVar4 * 10;
    tm->tm_sec = 0;
    if ((end == (uchar *)0x0) || (pbVar3 + 7 < end)) {
      bVar4 = pbVar3[5];
      if (bVar4 == 0x3a) {
        if ((end != (uchar *)0x0) && (end <= pbVar3 + 8)) {
          return 0;
        }
        if (9 < (byte)(pbVar3[6] - 0x30)) {
          return 0;
        }
        if (9 < (byte)(pbVar3[7] - 0x30)) {
          return 0;
        }
        local_18 = pbVar3 + 8;
        tm->tm_sec = (pbVar3[7] - 0x210) + (uint)pbVar3[6] * 10;
      }
      else if ((bVar4 == 0x50) || (bVar4 == 0x41)) {
        if (iVar1 == 0xc) {
          tm->tm_hour = 0;
          bVar4 = pbVar3[5];
        }
        if (bVar4 == 0x50) {
          tm->tm_hour = tm->tm_hour + 0xc;
        }
        if (pbVar3[6] != 0x4d) {
          return 0;
        }
        local_18 = pbVar3 + 7;
      }
      *time = local_18;
      if ((tm->tm_hour < 0x18) && (tm->tm_min < 0x3c)) {
        return (uint)(tm->tm_sec < 0x3c);
      }
    }
    else {
      *time = local_18;
      if ((tm->tm_hour < 0x18) && (tm->tm_min < 0x3c)) {
        return (uint)(tm->tm_sec < 0x3c);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int parse_month(uchar **buf,uchar *end)

{
  uchar *str;
  int monthnum;
  uchar *month;
  
  str = *buf;
  if ((((end == (uchar *)0x0) || (str + 2 <= end)) && (*str != '\0')) &&
     ((str[1] != '\0' && (str[2] != '\0')))) {
    monthnum = month2num(str);
    if (monthnum != -1) {
      *buf = *buf + 3;
    }
  }
  else {
    monthnum = -1;
  }
  return monthnum;
}



// WARNING: Unknown calling convention

time_t parse_date(uchar **date_pos,uchar *end,int update_pos,int skip_week_day)

{
  uchar *puVar1;
  time_t t;
  int iVar2;
  int iVar3;
  int iVar4;
  uchar uVar5;
  uchar *puVar6;
  bool bVar7;
  tm tm;
  uchar *local_20 [4];
  
  local_20[0] = *date_pos;
  if (local_20[0] == (uchar *)0x0) {
    return 0;
  }
  if (skip_week_day == 0) goto LAB_080c11bd;
  bVar7 = end == (uchar *)0x0;
  if ((!bVar7) && (end <= local_20[0])) {
    return 0;
  }
  uVar5 = *local_20[0];
  puVar6 = local_20[0];
  if (uVar5 == ' ') {
LAB_080c1358:
    do {
      local_20[0] = local_20[0] + 1;
      if (local_20[0] < end) {
        uVar5 = *local_20[0];
      }
      else {
        if (!bVar7) break;
        uVar5 = *local_20[0];
      }
    } while ((uVar5 == '-') || (uVar5 == ' '));
  }
  else {
    do {
      if (uVar5 == '\0') {
        return 0;
      }
      local_20[0] = local_20[0] + 1;
      puVar6 = local_20[0];
      if ((end <= local_20[0]) && (!bVar7)) goto LAB_080c11b6;
      uVar5 = *local_20[0];
    } while (uVar5 != ' ');
    if (local_20[0] < end || bVar7) goto LAB_080c1358;
  }
LAB_080c11b6:
  if (puVar6 == local_20[0]) {
    return 0;
  }
LAB_080c11bd:
  if ((byte)(*local_20[0] - 0x30) < 10) {
    tm.tm_mday = parse_day(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (0x1f < tm.tm_mday) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    tm.tm_mon = parse_month(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (tm.tm_mon < 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    tm.tm_year = parse_year(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (tm.tm_year < 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    iVar2 = parse_time(local_20,&tm,end);
    if (iVar2 == 0) {
      return 0;
    }
  }
  else {
    tm.tm_mon = parse_month(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (tm.tm_mon < 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    tm.tm_mday = parse_day(local_20,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (0x1f < tm.tm_mday) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (puVar6 == local_20[0]) {
      return 0;
    }
    iVar2 = parse_time(local_20,&tm,end);
    puVar6 = local_20[0];
    puVar1 = local_20[0];
    if (iVar2 == 0) {
      return 0;
    }
    do {
      local_20[0] = puVar1;
      if ((end != (uchar *)0x0) && (end <= local_20[0])) break;
      puVar1 = local_20[0] + 1;
    } while ((*local_20[0] == '-') || (*local_20[0] == ' '));
    if (local_20[0] == puVar6) {
      return 0;
    }
    tm.tm_year = parse_year(local_20,end);
    if (tm.tm_year < 0) {
      return 0;
    }
  }
  if (update_pos != 0) {
    *date_pos = local_20[0];
  }
  iVar2 = tm.tm_mon + -2;
  if (iVar2 < 0) {
    iVar2 = tm.tm_mon + 10;
    tm.tm_year = tm.tm_year + -1;
  }
  iVar3 = (tm.tm_year + -0x44) * 0x5b5;
  iVar4 = iVar3 + 3;
  if (-1 < iVar3) {
    iVar4 = iVar3;
  }
  iVar2 = tm.tm_hour * 0xe10 + tm.tm_min * 0x3c + tm.tm_sec +
          ((iVar4 >> 2) + tm.tm_mday + -0x2a0 + (iVar2 * 0x99 + 2) / 5) * 0x15180;
  if (iVar2 == -1) {
    return 0;
  }
  return iVar2;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

uchar * get_header_param(uchar *e,uchar *name)

{
  byte bVar1;
  ushort *puVar2;
  int iVar3;
  int iVar4;
  ushort **ppuVar5;
  byte *pbVar6;
  byte *pbVar7;
  byte *pbVar8;
  byte bVar9;
  byte *pbVar10;
  uchar *start;
  uchar *n;
  byte *pbVar11;
  
  do {
    do {
      bVar9 = *e;
      if (bVar9 == 0) {
        return (uchar *)0x0;
      }
      e = e + 1;
      iVar3 = c_toupper((uint)bVar9);
      iVar4 = c_toupper((uint)*name);
    } while (iVar3 != iVar4);
    bVar9 = *e;
    if (bVar9 == 0) {
      return (uchar *)0x0;
    }
    pbVar6 = name + 1;
    if (name[1] == 0) goto LAB_080c156b;
    while( true ) {
      iVar3 = c_toupper((uint)bVar9);
      iVar4 = c_toupper((uint)*pbVar6);
      if (iVar3 != iVar4) break;
      pbVar6 = pbVar6 + 1;
      e = e + 1;
      if (*pbVar6 == 0) goto LAB_080c1568;
      bVar9 = *e;
    }
  } while (*pbVar6 != 0);
LAB_080c1568:
  bVar9 = *e;
LAB_080c156b:
  ppuVar5 = __ctype_b_loc();
  puVar2 = *ppuVar5;
  while ((*(byte *)((int)puVar2 + (uint)bVar9 * 2 + 1) & 0x20) != 0) {
    e = e + 1;
    bVar9 = *e;
  }
  if (bVar9 == 0x3d) {
    bVar9 = e[1];
    pbVar6 = e + 1;
    bVar1 = *(byte *)((int)puVar2 + (uint)bVar9 * 2 + 1);
    while ((bVar1 & 0x20) != 0) {
      pbVar6 = pbVar6 + 1;
      bVar9 = *pbVar6;
      bVar1 = *(byte *)((int)puVar2 + (uint)bVar9 * 2 + 1);
    }
    if ((bVar9 == 0x27) || (bVar9 == 0x22)) {
      pbVar6 = pbVar6 + 1;
      bVar1 = *pbVar6;
      pbVar10 = pbVar6;
      if (bVar1 != bVar9) {
        do {
          if (bVar1 == 0) {
            return (uchar *)0x0;
          }
          pbVar10 = pbVar10 + 1;
          bVar1 = *pbVar10;
        } while (bVar1 != bVar9);
        goto joined_r0x080c15fe;
      }
    }
    else {
      pbVar10 = pbVar6;
      if ((*pbVar6 != 0) && ((*(byte *)((int)puVar2 + (uint)*pbVar6 * 2 + 1) & 0x20) == 0)) {
        do {
          pbVar10 = pbVar10 + 1;
          if (*pbVar10 == 0) break;
        } while ((*(byte *)((int)puVar2 + (uint)*pbVar10 * 2 + 1) & 0x20) == 0);
joined_r0x080c15fe:
        if (pbVar6 < pbVar10) {
          if (*pbVar6 == 0x20) goto LAB_080c1608;
          bVar9 = pbVar10[-1];
          pbVar7 = pbVar10;
          while ((pbVar10 = pbVar7, bVar9 == 0x20 && (pbVar10 = pbVar7 + -1, pbVar6 < pbVar10))) {
            bVar9 = pbVar7[-2];
            pbVar7 = pbVar10;
          }
        }
      }
    }
    if (pbVar6 != pbVar10) {
      pbVar7 = (byte *)mem_alloc((size_t)(pbVar10 + (1 - (int)pbVar6)));
      if (pbVar7 != (byte *)0x0) {
        iVar3 = 0;
        pbVar8 = pbVar6;
        pbVar11 = pbVar7;
        if (pbVar6 < pbVar10) {
          do {
            bVar9 = *pbVar8;
            if (bVar9 < 0x20) {
              bVar9 = 0x2e;
            }
            pbVar8 = pbVar8 + 1;
            *pbVar11 = bVar9;
            pbVar11 = pbVar11 + 1;
          } while (pbVar8 < pbVar10);
          iVar3 = (int)pbVar10 - (int)pbVar6;
        }
        pbVar7[iVar3] = 0;
        return pbVar7;
      }
      return (uchar *)0x0;
    }
  }
  return (uchar *)0x0;
LAB_080c1608:
  pbVar6 = pbVar6 + 1;
  goto joined_r0x080c15fe;
}



// WARNING: Unknown calling convention

parse_header_param parse_header_param(uchar *str,uchar *name,uchar **ret)

{
  byte *pbVar1;
  uchar uVar2;
  byte bVar3;
  size_t n;
  size_t sVar4;
  int iVar5;
  int plen;
  byte *pbVar6;
  uchar *puVar7;
  uchar *p;
  byte *src;
  
  if (ret != (uchar **)0x0) {
    *ret = (uchar *)0x0;
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return HEADER_PARAM_NOT_FOUND;
  }
  if (((name == (uchar *)0x0) || (str == (uchar *)0x0)) || (*name == '\0')) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/header.c";
    errline = 0xd8;
    elinks_internal((uchar *)"assertion str && name && *name failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return HEADER_PARAM_NOT_FOUND;
    }
    uVar2 = *str;
  }
  else {
    uVar2 = *str;
  }
  if (uVar2 == '\0') {
    assert_failed = 0;
    return HEADER_PARAM_NOT_FOUND;
  }
  assert_failed = 0;
  n = strlen((char *)name);
  do {
    str = (uchar *)strchr((char *)str,0x3b);
    if (str == (byte *)0x0) {
      return HEADER_PARAM_NOT_FOUND;
    }
    for (; (bVar3 = *str, bVar3 != 0 && ((bVar3 < 0x21 || (bVar3 == 0x3b)))); str = str + 1) {
    }
    sVar4 = strlen((char *)str);
    if (sVar4 < n) {
      return HEADER_PARAM_NOT_FOUND;
    }
    iVar5 = c_strncasecmp((char *)str,(char *)name,n);
  } while (iVar5 != 0);
  src = str + n;
  bVar3 = *src;
  if (bVar3 != 0) {
    if ((bVar3 < 0x21) || (bVar3 == 0x3d)) {
      do {
        src = src + 1;
        bVar3 = *src;
        if (bVar3 == 0) goto LAB_080c17e2;
      } while ((bVar3 == 0x3d) || (bVar3 < 0x21));
    }
    iVar5 = 0;
    do {
      bVar3 = src[iVar5];
      if (bVar3 < 0x21) {
        if ((bVar3 != 9) && (bVar3 != 0x20)) goto LAB_080c189a;
      }
      else if (bVar3 == 0x3b) goto LAB_080c189a;
      iVar5 = iVar5 + 1;
    } while( true );
  }
LAB_080c17e2:
  if (ret == (uchar **)0x0) {
    return HEADER_PARAM_FOUND;
  }
  puVar7 = stracpy("");
  *ret = puVar7;
  goto joined_r0x080c17fc;
LAB_080c189a:
  if (iVar5 != 0) {
    if ((src[iVar5 + -1] == 9) || (src[iVar5 + -1] == 0x20)) {
      pbVar6 = src + iVar5;
      do {
        iVar5 = iVar5 + -1;
        if (iVar5 == 0) goto LAB_080c18cb;
        pbVar1 = pbVar6 + -2;
        pbVar6 = pbVar6 + -1;
      } while ((*pbVar1 == 9) || (*pbVar1 == 0x20));
    }
    if ((1 < iVar5) && ((*src == 0x27 && (pbVar6 = src + iVar5, src[iVar5 + -1] == 0x27)))) {
      while( true ) {
        iVar5 = iVar5 + -2;
        src = src + 1;
        if (iVar5 < 2) break;
        if ((*src != 0x27) || (pbVar1 = pbVar6 + -2, pbVar6 = pbVar6 + -1, *pbVar1 != 0x27)) break;
      }
    }
  }
LAB_080c18cb:
  if (ret == (uchar **)0x0) {
    return HEADER_PARAM_FOUND;
  }
  puVar7 = memacpy(src,iVar5);
  *ret = puVar7;
joined_r0x080c17fc:
  if (puVar7 != (uchar *)0x0) {
    return HEADER_PARAM_FOUND;
  }
  return HEADER_PARAM_OUT_OF_MEMORY;
}



// WARNING: Unknown calling convention

uchar * parse_header(uchar *head,uchar *item,uchar **ptr)

{
  byte bVar1;
  uchar *value;
  int iVar2;
  int iVar3;
  uchar *end;
  byte *pbVar4;
  byte bVar5;
  byte bVar6;
  uchar *pos;
  byte *pbVar7;
  uchar *itempos;
  byte *pbVar8;
  
  if (head == (uchar *)0x0) {
    value = (uchar *)0x0;
    return value;
  }
LAB_080c19ae:
  pbVar7 = head;
  bVar5 = *head;
  do {
    do {
      do {
        if (bVar5 == 0) {
          value = (uchar *)0x0;
          return value;
        }
        pbVar4 = pbVar7;
        if (bVar5 != 10) {
          while( true ) {
            pbVar7 = pbVar7 + 1;
            pbVar4 = pbVar7;
            if (*pbVar7 == 10) break;
            if (*pbVar7 == 0) {
              value = (uchar *)0x0;
              return value;
            }
          }
        }
        pbVar7 = pbVar4 + 1;
        bVar5 = *item;
        pbVar8 = item;
        if (bVar5 != 0) {
          bVar6 = pbVar4[1];
          while( true ) {
            if (bVar6 == 0) {
              value = (uchar *)0x0;
              return value;
            }
            iVar2 = c_toupper((uint)bVar5);
            iVar3 = c_toupper((uint)*pbVar7);
            if (iVar2 != iVar3) break;
            pbVar8 = pbVar8 + 1;
            pbVar7 = pbVar7 + 1;
            bVar5 = *pbVar8;
            if (bVar5 == 0) break;
            bVar6 = *pbVar7;
          }
        }
        bVar5 = *pbVar7;
        if (bVar5 == 0) {
          value = (uchar *)0x0;
          return value;
        }
      } while (*pbVar8 != 0);
      head = pbVar7;
      if ((bVar5 == 0x20) || (bVar6 = bVar5, bVar5 == 9)) {
        do {
          do {
            head = head + 1;
            bVar6 = *head;
          } while (bVar6 == 9);
        } while (bVar6 == 0x20);
        if (bVar6 == 0) {
          value = (uchar *)0x0;
          return value;
        }
      }
      if ((bVar6 == 0x3d) || (bVar6 == 0x3a)) {
        head = head + 1;
      }
      bVar6 = *head;
      if (bVar6 == 0) {
        value = (uchar *)0x0;
        return value;
      }
      if ((bVar6 == 9) || (bVar6 == 0x20)) {
        do {
          do {
            head = head + 1;
            bVar6 = *head;
          } while (bVar6 == 9);
        } while (bVar6 == 0x20);
        if (bVar6 == 0) {
          value = (uchar *)0x0;
          return value;
        }
      }
      pbVar4 = head;
      bVar1 = bVar6;
    } while (pbVar7 == head);
    while (pbVar7 = head, bVar5 = bVar6, bVar1 != 0x7f) {
      if (((bVar1 < 0x21) && (bVar1 != 9)) && (bVar1 != 0x20)) {
        if (bVar1 == 0) {
          value = (uchar *)0x0;
          return value;
        }
        if ((bVar1 == 10) || (bVar1 == 0xd)) {
          if ((pbVar4 <= head) || ((pbVar7 = pbVar4, pbVar4[-1] != 0x20 && (pbVar4[-1] != 9))))
          goto LAB_080c1b1c;
          goto joined_r0x080c1b04;
        }
        break;
      }
      pbVar4 = pbVar4 + 1;
      bVar1 = *pbVar4;
    }
  } while( true );
  while ((pbVar8 = pbVar7 + -2, pbVar7 = pbVar4, *pbVar8 == 9 || (*pbVar8 == 0x20))) {
joined_r0x080c1b04:
    pbVar4 = pbVar7 + -1;
    if (pbVar4 <= head) break;
  }
LAB_080c1b1c:
  if (assert_failed != 0) {
    value = (uchar *)0x0;
    assert_failed = 0;
    return value;
  }
  iVar2 = (int)pbVar4 - (int)head;
  assert_failed = -(iVar2 >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/header.c";
    errline = 0xb3;
    elinks_internal((uchar *)"assertion len >= 0 failed!");
    if (assert_failed != 0) {
      value = (uchar *)0x0;
      assert_failed = 0;
      return value;
    }
  }
  if (iVar2 != 0) {
    value = memacpy(head,iVar2);
    if (value == (uchar *)0x0) {
      value = (uchar *)0x0;
      return value;
    }
    if (ptr != (uchar **)0x0) {
      *ptr = head;
      return value;
    }
    return value;
  }
  goto LAB_080c19ae;
}



// WARNING: Unknown calling convention

undefined1 * get_protocol_handler(protocol protocol)

{
  undefined1 *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (undefined1 *)0x0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed == 0) {
    puVar1 = protocol_backends[protocol].handler;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xce;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (undefined1 *)0x0;
    }
    puVar1 = protocol_backends[protocol].handler;
  }
  return puVar1;
}



// WARNING: Unknown calling convention

int get_protocol_need_ssl(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xc6;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (byte)protocol_backends[protocol].field_0xc >> 3 & 1;
}



// WARNING: Unknown calling convention

int get_protocol_free_syntax(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xbe;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (byte)protocol_backends[protocol].field_0xc >> 2 & 1;
}



// WARNING: Unknown calling convention

int get_protocol_keep_double_slashes(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xb6;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (byte)protocol_backends[protocol].field_0xc >> 4 & 1;
}



// WARNING: Unknown calling convention

int get_protocol_need_slash_after_host(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xae;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (byte)protocol_backends[protocol].field_0xc >> 1 & 1;
}



// WARNING: Unknown calling convention

int get_protocol_need_slashes(protocol protocol)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0xa6;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return (byte)protocol_backends[protocol].field_0xc & 1;
}



// WARNING: Unknown calling convention

int get_protocol_port(protocol protocol)

{
  uint uVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(PROTOCOL_LUA < protocol);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0x9a;
    elinks_internal((uchar *)"assertion VALID_PROTOCOL(protocol) failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  uVar1 = protocol_backends[protocol].port;
  assert_failed = (int)(0xffff < uVar1);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 0x9d;
    elinks_internal((uchar *)"assertion uri_port_is_valid(protocol_backends[protocol].port) failed!"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  return uVar1;
}



// WARNING: Unknown calling convention

protocol_external_handler_T * get_protocol_external_handler(terminal *term,uri *uri)

{
  code *pcVar1;
  uchar *puVar2;
  uchar *prog;
  
  if (assert_failed == 0) {
    if ((uri == (uri *)0x0) || (0x14 < (uint)uri->protocol)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
      errline = 0x102;
      elinks_internal((uchar *)"assertion uri && VALID_PROTOCOL(uri->protocol) failed!");
      if (assert_failed != 0) goto LAB_080c2014;
    }
    else {
      assert_failed = 0;
    }
    puVar2 = get_user_program(term,uri->string,(uint)*(ushort *)&uri->field_0x28);
    if ((puVar2 == (uchar *)0x0) || (pcVar1 = user_protocol_handler, *puVar2 == '\0')) {
      pcVar1 = (protocol_external_handler_T *)0x0;
      if (protocol_backends[uri->protocol].handler == (undefined1 *)0x0) {
        pcVar1 = generic_external_protocol_handler;
      }
      return pcVar1;
    }
  }
  else {
LAB_080c2014:
    assert_failed = 0;
    pcVar1 = (protocol_external_handler_T *)0x0;
  }
  return pcVar1;
}



// WARNING: Unknown calling convention

protocol get_protocol(uchar *name,int namelen)

{
  size_t sVar1;
  size_t n;
  int iVar2;
  int compare;
  uchar *puVar3;
  int iVar4;
  int end;
  protocol pVar5;
  protocol protocol;
  bool bVar6;
  bool bVar7;
  int local_20;
  
  if (assert_failed == 0) {
    assert_failed = 0;
  }
  pVar5 = PROTOCOL_HTTP;
  iVar4 = 0x11;
  local_20 = 0;
  while( true ) {
    puVar3 = protocol_backends[pVar5].name;
    sVar1 = strlen((char *)puVar3);
    n = namelen;
    if ((int)sVar1 <= namelen) {
      n = sVar1;
    }
    iVar2 = c_strncasecmp((char *)puVar3,(char *)name,n);
    bVar7 = false;
    bVar6 = iVar2 == 0;
    if (bVar6) {
      bVar7 = SBORROW4(sVar1,namelen);
      iVar2 = sVar1 - namelen;
      bVar6 = sVar1 == namelen;
      if (bVar6) {
        return pVar5;
      }
    }
    if (bVar6 || bVar7 != iVar2 < 0) {
      local_20 = pVar5 + PROTOCOL_BITTORRENT;
    }
    else {
      iVar4 = pVar5 + ~PROTOCOL_ABOUT;
    }
    if (iVar4 < local_20) break;
    pVar5 = (iVar4 + local_20) / 2;
  }
  puVar3 = get_user_program((terminal *)0x0,name,namelen);
  return PROTOCOL_USER - (puVar3 == (uchar *)0x0);
}



// WARNING: Unknown calling convention

void generic_external_protocol_handler(session *ses,uri *uri)

{
  int iVar1;
  connection_state state;
  uchar *text;
  uint uVar2;
  
  iVar1 = uri->protocol;
  if (iVar1 == 0xb) {
    if (assert_failed == 0) {
      uVar2 = 0xfffe7708;
      goto LAB_080c2251;
    }
  }
  else {
    if (iVar1 != 0x12) {
      text = msg_text(ses->tab->term,
                      (uchar *)"This version of ELinks does not contain %s protocol support",
                      protocol_backends[iVar1].name);
      msg_box(ses->tab->term,(memory_list *)0x0,MSGBOX_FREE_TEXT,"Error",ALIGN_CENTER,text,ses,1,
              &DAT_081275e4,0,3);
      return;
    }
    if (assert_failed == 0) {
      uVar2 = 0xfffe7951;
      goto LAB_080c2251;
    }
  }
  uVar2 = 0xfffe795d;
LAB_080c2251:
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar2;
  print_error_dialog(ses,state,uri,PRI_CANCEL);
  return;
}



// WARNING: Unknown calling convention

uri * get_proxied_uri(uri *uri)

{
  uri *puVar1;
  
  if (uri->protocol != 0xf) {
    puVar1 = get_composed_uri(uri,URI_BASE);
    return puVar1;
  }
  puVar1 = get_uri(uri->data,URI_BASE);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * strip_proxy_protocol(uchar *proxy,uchar *strip1,uchar *strip2)

{
  size_t sVar1;
  int iVar2;
  
  if (assert_failed == 0) {
    if ((proxy == (uchar *)0x0) || (*proxy == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c";
      errline = 0x57;
      elinks_internal((uchar *)"assertion proxy && *proxy failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  sVar1 = strlen((char *)strip1);
  iVar2 = c_strncasecmp((char *)proxy,(char *)strip1,sVar1);
  if (iVar2 == 0) {
    sVar1 = strlen((char *)strip1);
    proxy = proxy + sVar1;
  }
  else if (strip2 != (uchar *)0x0) {
    sVar1 = strlen((char *)strip2);
    iVar2 = c_strncasecmp((char *)proxy,(char *)strip2,sVar1);
    if (iVar2 == 0) {
      sVar1 = strlen((char *)strip2);
      proxy = proxy + sVar1;
    }
  }
  return proxy;
}



// WARNING: Unknown calling convention

uchar * get_protocol_proxy(uchar *opt,uchar *env1,uchar *env2,uchar *strip1,uchar *strip2)

{
  option_value *poVar1;
  uchar *proxy;
  uchar *puVar2;
  
  poVar1 = get_opt_();
  puVar2 = poVar1->string;
  if (*puVar2 == '\0') {
    puVar2 = (uchar *)getenv((char *)env1);
  }
  if ((puVar2 == (uchar *)0x0) || (*puVar2 == '\0')) {
    puVar2 = (uchar *)getenv((char *)env2);
    if ((puVar2 == (uchar *)0x0) || (*puVar2 == '\0')) {
      return puVar2;
    }
  }
  puVar2 = strip_proxy_protocol(puVar2,strip1,strip2);
  return puVar2;
}



// WARNING: Unknown calling convention

uri * proxy_uri(uri *uri,uchar *proxy,connection_state *error_state)

{
  string *psVar1;
  uri *puVar2;
  connection_basic_state cVar3;
  string string;
  
  psVar1 = init_string(&string);
  if (psVar1 != (string *)0x0) {
    psVar1 = string_concat(&string,"proxy://",proxy,&DAT_08132419,0);
    if (psVar1 != (string *)0x0) {
      psVar1 = add_uri_to_string(&string,uri,URI_BASE);
      if (psVar1 != (string *)0x0) {
        puVar2 = get_uri(string.source,0);
        if (puVar2 == (uri *)0x0) {
          if (assert_failed == 0) {
            cVar3 = S_PROXY_ERROR;
          }
          else {
            cVar3 = S_INTERNAL;
          }
          assert_failed = 0;
          error_state->basic = cVar3;
          error_state->syserr = 0;
        }
        goto LAB_080c24ce;
      }
    }
  }
  if (assert_failed == 0) {
    cVar3 = S_OUT_OF_MEM;
  }
  else {
    cVar3 = S_INTERNAL;
  }
  assert_failed = 0;
  puVar2 = (uri *)0x0;
  error_state->basic = cVar3;
  error_state->syserr = 0;
LAB_080c24ce:
  done_string(&string);
  return puVar2;
}



// WARNING: Unknown calling convention

uri * get_proxy_uri(uri *uri,connection_state *error_state)

{
  int iVar1;
  uri *puVar2;
  uchar *puVar3;
  char *pcVar4;
  option_value *poVar5;
  byte *__s;
  ushort **ppuVar6;
  char *pcVar7;
  char *pcVar8;
  void *p;
  byte bVar9;
  uchar *no_proxy;
  uchar *local_3c;
  uchar *local_20 [4];
  
  if (uri->protocol == 0xf) {
    puVar2 = get_composed_uri(uri,URI_BASE);
    return puVar2;
  }
  local_20[0] = (uchar *)0x0;
  if (get_proxy_uri::lexical_block_0::get_proxy_event_id == -1) {
    get_proxy_uri::lexical_block_0::get_proxy_event_id = get_event_id((uchar *)"get-proxy");
  }
  trigger_event(get_proxy_uri::lexical_block_0::get_proxy_event_id,local_20,uri->string);
  if (local_20[0] == (uchar *)0x0) {
    iVar1 = uri->protocol;
    if (iVar1 == 9) {
      local_3c = get_protocol_proxy((uchar *)"protocol.http.proxy.host",(uchar *)"HTTP_PROXY",
                                    (uchar *)"http_proxy",(uchar *)"http://",(uchar *)0x0);
    }
    else if (iVar1 == 10) {
      local_3c = get_protocol_proxy((uchar *)"protocol.https.proxy.host",(uchar *)"HTTPS_PROXY",
                                    (uchar *)"https_proxy",(uchar *)"http://",(uchar *)0x0);
    }
    else {
      if (iVar1 != 7) goto LAB_080c25bc;
      local_3c = get_protocol_proxy((uchar *)"protocol.ftp.proxy.host",(uchar *)"FTP_PROXY",
                                    (uchar *)"ftp_proxy",(uchar *)"ftp://",(uchar *)"http://");
    }
    if ((local_3c != (uchar *)0x0) && (*local_3c != '\0')) {
      pcVar4 = strchr((char *)local_3c,0x2f);
      if (pcVar4 != (char *)0x0) {
        *pcVar4 = '\0';
      }
      poVar5 = get_opt_();
      __s = poVar5->string;
      if (*__s == 0) {
        __s = (byte *)getenv("NO_PROXY");
      }
      if ((__s == (byte *)0x0) || (*__s == 0)) {
        __s = (byte *)getenv("no_proxy");
      }
      puVar3 = uri->host;
      pcVar4 = strchr((char *)puVar3,0x2f);
      if (pcVar4 != (char *)0x0) {
        *pcVar4 = '\0';
      }
      if ((__s != (byte *)0x0) && (bVar9 = *__s, bVar9 != 0)) {
        ppuVar6 = __ctype_b_loc();
        while( true ) {
          pcVar7 = strchr((char *)__s,0x2c);
          while ((*(byte *)((int)*ppuVar6 + (uint)bVar9 * 2 + 1) & 0x20) != 0) {
            __s = __s + 1;
            bVar9 = *__s;
          }
          if (pcVar7 != (char *)0x0) {
            *pcVar7 = '\0';
          }
          pcVar8 = c_strcasestr((char *)puVar3,(char *)__s);
          if (pcVar8 != (char *)0x0) {
            if (pcVar7 != (char *)0x0) {
              *pcVar7 = ',';
            }
            if (pcVar4 != (char *)0x0) {
              *pcVar4 = '/';
            }
            goto LAB_080c25bc;
          }
          if (pcVar7 == (char *)0x0) break;
          __s = (byte *)(pcVar7 + 1);
          *pcVar7 = ',';
          if ((__s == (byte *)0x0) || (bVar9 = pcVar7[1], bVar9 == 0)) break;
        }
      }
      if (pcVar4 != (char *)0x0) {
        *pcVar4 = '/';
      }
      puVar2 = proxy_uri(uri,local_3c,error_state);
      goto LAB_080c25cc;
    }
  }
  else if (*local_20[0] != '\0') {
    puVar3 = strip_proxy_protocol(local_20[0],(uchar *)"http://",(uchar *)"ftp://");
    puVar2 = proxy_uri(uri,puVar3,error_state);
    goto LAB_080c25cc;
  }
LAB_080c25bc:
  puVar2 = get_composed_uri(uri,URI_BASE);
LAB_080c25cc:
  if (local_20[0] != (uchar *)0x0) {
    mem_free(local_20[0]);
  }
  return puVar2;
}



// WARNING: Unknown calling convention

void decode_uri(uchar *src)

{
  byte *pbVar1;
  byte *pbVar2;
  uchar c;
  byte bVar3;
  int x2;
  int iVar4;
  int x1;
  uint uVar5;
  int iVar6;
  
  pbVar2 = src + 1;
  pbVar1 = pbVar2;
  do {
    bVar3 = *src;
    if (bVar3 == 0x25) {
      bVar3 = *pbVar1;
      uVar5 = (uint)bVar3;
      if ((byte)(bVar3 - 0x30) < 10) {
        iVar6 = uVar5 - 0x30;
LAB_080c2895:
        if (-1 < iVar6) {
          bVar3 = pbVar1[1];
          uVar5 = (uint)bVar3;
          if ((byte)(bVar3 - 0x30) < 10) {
            iVar4 = uVar5 - 0x30;
          }
          else if ((byte)(bVar3 + 0x9f) < 6) {
            iVar4 = uVar5 - 0x57;
          }
          else {
            if (5 < (byte)(bVar3 + 0xbf)) goto LAB_080c28f8;
            iVar4 = uVar5 - 0x37;
          }
          if ((-1 < iVar4) && (iVar4 = iVar4 + iVar6 * 0x10, iVar4 != 0)) {
            bVar3 = (byte)iVar4;
            pbVar1 = pbVar1 + 2;
            pbVar2[-1] = bVar3;
            if (bVar3 == 0) {
              return;
            }
            goto LAB_080c286f;
          }
        }
      }
      else {
        if ((byte)(bVar3 + 0x9f) < 6) {
          iVar6 = uVar5 - 0x57;
          goto LAB_080c2895;
        }
        if ((byte)(bVar3 + 0xbf) < 6) {
          iVar6 = uVar5 - 0x37;
          goto LAB_080c2895;
        }
      }
LAB_080c28f8:
      pbVar2[-1] = 0x25;
    }
    else {
      pbVar2[-1] = bVar3;
      if (bVar3 == 0) {
        return;
      }
    }
LAB_080c286f:
    pbVar2 = pbVar2 + 1;
    src = pbVar1;
    pbVar1 = pbVar1 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

void decode_uri_string(string *string)

{
  size_t sVar1;
  
  decode_uri(string->source);
  sVar1 = strlen((char *)string->source);
  string->length = sVar1;
  return;
}



// WARNING: Unknown calling convention

void done_uri(uri *uri)

{
  uchar *key;
  size_t keylen;
  hash_item *item_00;
  hash_item *item;
  int iVar1;
  uri_cache_entry *entry;
  void *p;
  uchar *string;
  
  key = uri->string;
  keylen = strlen((char *)key);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(uri_cache.object.refcount == 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x64d;
    elinks_internal((uchar *)"assertion is_object_used(&uri_cache) failed!");
  }
  iVar1 = (uri->object).refcount + -1;
  (uri->object).refcount = iVar1;
  if (iVar1 == 0) {
    p = (void *)0x0;
    item_00 = get_hash_item(uri_cache.map,key,keylen);
    if (item_00 != (hash_item *)0x0) {
      p = item_00->value;
    }
    if ((assert_failed == 0) && (assert_failed = (int)(p == (void *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x655;
      elinks_internal((uchar *)"assertion entry != NULL failed: Releasing unknown URI [%s]",key);
    }
    del_hash_item(uri_cache.map,item_00);
    mem_free(p);
    uri_cache.object.refcount = uri_cache.object.refcount + -1;
    if (uri_cache.object.refcount == 0) {
      free_hash(&uri_cache.map);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void free_uri_list(uri_list *list)

{
  uri *uri;
  uri **p;
  int iVar1;
  int index;
  
  p = list->uris;
  if (p == (uri **)0x0) {
    return;
  }
  if (0 < list->size) {
    iVar1 = 0;
    do {
      if (p[iVar1] != (uri *)0x0) {
        done_uri(p[iVar1]);
        p = list->uris;
      }
      iVar1 = iVar1 + 1;
    } while (list->size != iVar1 && iVar1 <= list->size);
    if (p == (uri **)0x0) goto LAB_080c2b05;
  }
  mem_free(p);
LAB_080c2b05:
  list->uris = (uri **)0x0;
  list->size = 0;
  return;
}



// WARNING: Unknown calling convention

void * mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  size_t newsize;
  uint uVar2;
  size_t size;
  size_t oldsize;
  uint uVar3;
  int iVar4;
  
  uVar2 = mask + new & ~mask;
  uVar3 = mask + old & ~mask;
  if (uVar3 < uVar2) {
    size = uVar2 * objsize;
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    iVar4 = uVar3 * objsize;
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + iVar4),0,size - iVar4);
  }
  return *ptr;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  void *pvVar2;
  
  if (assert_failed == 0) {
    if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080c2bbf;
    }
    else {
      assert_failed = 0;
    }
    if (length != 0) {
      iVar1 = length + string->length;
      pvVar2 = mem_align_alloc__(&string->source,string->length,iVar1 + 1,1,0xff);
      if (pvVar2 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memcpy(string->source + string->length,bytes,length);
        string->source[iVar1] = '\0';
        string->length = iVar1;
      }
    }
  }
  else {
LAB_080c2bbf:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



// WARNING: Unknown calling convention

void decode_uri_for_display(uchar *src)

{
  ushort **ppuVar1;
  byte bVar2;
  
  decode_uri(src);
  bVar2 = *src;
  if (bVar2 != 0) {
    ppuVar1 = __ctype_b_loc();
    do {
      if (((*ppuVar1)[bVar2] & 0x4002) != 0x4000) {
        *src = 0x2a;
      }
      src = src + 1;
      bVar2 = *src;
    } while (bVar2 != 0);
  }
  return;
}



// WARNING: Unknown calling convention

void decode_uri_string_for_display(string *string)

{
  size_t sVar1;
  
  decode_uri_for_display(string->source);
  sVar1 = strlen((char *)string->source);
  string->length = sVar1;
  return;
}



// WARNING: Unknown calling convention

uchar * get_extension_from_uri(uri *uri)

{
  uchar uVar1;
  uchar *extension;
  uchar *puVar2;
  uchar *src;
  int afterslash;
  uchar *pos;
  uchar *puVar3;
  bool bVar4;
  
  puVar3 = uri->data;
  if ((assert_failed == 0) && (assert_failed = (int)(puVar3 == (uchar *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x52a;
    elinks_internal((uchar *)"assertion pos failed!");
  }
  uVar1 = *puVar3;
  if ((((uVar1 != '\0') && (uVar1 != '\x01')) && (uVar1 != '#')) && (uVar1 != '?')) {
    bVar4 = true;
    puVar2 = (uchar *)0x0;
    do {
      if ((((puVar2 != (uchar *)0x0) || (bVar4)) || (src = puVar3, uVar1 != '.')) &&
         (bVar4 = uVar1 == '/', src = puVar2, bVar4)) {
        src = (uchar *)0x0;
      }
      puVar3 = puVar3 + 1;
      uVar1 = *puVar3;
    } while (((uVar1 != '\0') && (uVar1 != '#')) &&
            ((uVar1 != '\x01' && (puVar2 = src, uVar1 != '?'))));
    if ((src < puVar3) && (src != (uchar *)0x0)) {
      puVar3 = memacpy(src,(int)puVar3 - (int)src);
      return puVar3;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

int end_with_known_tld(uchar *s,int slen)

{
  size_t n;
  int iVar1;
  int pos;
  int iVar2;
  uchar *__s;
  int local_20;
  
  if (slen != 0) {
    if (slen < 0) {
      slen = strlen((char *)s);
    }
    __s = "com";
    local_20 = 0;
    do {
      n = strlen((char *)__s);
      iVar2 = slen - n;
      if ((-1 < iVar2) && (iVar1 = c_strncasecmp((char *)(s + iVar2),(char *)__s,n), iVar1 == 0)) {
        return iVar2;
      }
      local_20 = local_20 + 1;
      __s = end_with_known_tld::tld[local_20];
    } while (__s != (uchar *)0x0);
  }
  return -1;
}



// WARNING: Unknown calling convention

int is_in_domain(uchar *domain,uchar *server,int server_len)

{
  size_t n;
  uint uVar1;
  int iVar2;
  
  n = strlen((char *)domain);
  if (server_len < (int)n) {
LAB_080c2ef2:
    uVar1 = 0;
  }
  else {
    if (n != server_len) {
      if (server[(server_len - n) + -1] != '.') goto LAB_080c2ef2;
      server = server + (server_len - n);
    }
    iVar2 = c_strncasecmp((char *)domain,(char *)server,n);
    uVar1 = (uint)(iVar2 == 0);
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int check_whether_file_exists(uchar *name)

{
  byte bVar1;
  size_t __n;
  int iVar2;
  int namelen;
  int exists;
  byte *pbVar3;
  int iVar4;
  int i;
  
  __n = strlen((char *)name);
  iVar2 = file_exists(name);
  if (iVar2 == 0) {
    iVar2 = 0;
    do {
      bVar1 = "\x01#?"[iVar2];
      pbVar3 = (byte *)memchr(name,(uint)bVar1,__n);
      if (pbVar3 != (byte *)0x0) {
        *pbVar3 = 0;
        iVar4 = file_exists(name);
        *pbVar3 = bVar1;
        if (iVar4 != 0) {
          return (int)pbVar3 - (int)name;
        }
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 != 3);
    __n = 0xffffffff;
  }
  return __n;
}



// WARNING: Unknown calling convention

protocol find_uri_protocol(uchar *newurl)

{
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  size_t sVar4;
  uchar *host_end;
  char *pcVar5;
  char *pcVar6;
  uchar *domain;
  uchar *s;
  uchar *ipscan;
  uchar *ch;
  uchar *puVar7;
  
  iVar3 = check_whether_file_exists(newurl);
  if (-1 < iVar3) {
    return PROTOCOL_FILE;
  }
  sVar4 = strcspn((char *)newurl,".:/@");
  puVar7 = newurl + sVar4;
  if ((*puVar7 == '@') ||
     ((((*puVar7 == ':' && (*newurl != '[')) &&
       (pcVar5 = strchr((char *)newurl,0x40), pcVar5 != (char *)0x0)) ||
      (iVar3 = c_strncasecmp((char *)newurl,"ftp.",4), iVar3 == 0)))) {
    return PROTOCOL_FTP;
  }
  if (*newurl == '[') {
    uVar2 = *puVar7;
    if (uVar2 == ':') {
      pcVar5 = strchr((char *)(puVar7 + 1),0x5d);
      pcVar6 = strchr((char *)(puVar7 + 1),0x3a);
      if (pcVar6 == (char *)0x0) {
        return PROTOCOL_UNKNOWN;
      }
      if (pcVar5 != (char *)0x0) {
        if (pcVar6 < pcVar5) {
          return PROTOCOL_HTTP;
        }
        return PROTOCOL_UNKNOWN;
      }
      return PROTOCOL_UNKNOWN;
    }
  }
  else {
    if (*newurl == '.') {
      return PROTOCOL_UNKNOWN;
    }
    uVar2 = *puVar7;
  }
  puVar1 = puVar7;
  if (uVar2 != '.') {
    return PROTOCOL_UNKNOWN;
  }
  do {
    s = puVar1 + 1;
    sVar4 = strcspn((char *)s,".:/?");
    puVar1 = s + sVar4;
  } while (*puVar1 == '.');
  do {
    do {
      puVar7 = puVar7 + 1;
      uVar2 = *puVar7;
    } while ((byte)(uVar2 - 0x30) < 10);
  } while (uVar2 == '.');
  if (((uVar2 != ':') && (uVar2 != '\0')) &&
     ((uVar2 != '/' &&
      (((int)puVar1 - (int)s != 2 && (iVar3 = end_with_known_tld(s,(int)puVar1 - (int)s), iVar3 < 0)
       ))))) {
    return PROTOCOL_UNKNOWN;
  }
  return PROTOCOL_HTTP;
}



// WARNING: Unknown calling convention

int compare_component(uchar *a,int alen,uchar *b,int blen)

{
  uint uVar1;
  bool bVar2;
  
  if ((alen == blen) && ((b != (uchar *)0x0) == (a != (uchar *)0x0))) {
    if ((alen == 0) || (a == (uchar *)0x0)) {
      uVar1 = 1;
    }
    else {
      bVar2 = true;
      do {
        if (alen == 0) break;
        alen = alen + -1;
        bVar2 = *a == *b;
        a = a + 1;
        b = b + 1;
      } while (bVar2);
      uVar1 = (uint)bVar2;
    }
  }
  else {
    uVar1 = 0;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

int compare_uri(uri *a,uri *b,uri_component components)

{
  uchar *b_00;
  uchar *a_00;
  int iVar1;
  size_t blen;
  size_t alen;
  
  if (a == b) {
LAB_080c3300:
    iVar1 = 1;
  }
  else {
    if (components != 0) {
      if ((assert_failed == 0) &&
         (assert_failed = (int)((components & 0x7840U) != 0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x1d4;
        elinks_internal((uchar *)
                        "assertion can_compare_uri_components(components) failed: compare_uri() is a work in progress. Component unsupported"
                       );
      }
      if ((((((((components & 1U) == 0) || (a->protocol == b->protocol)) &&
             (((components & 2U) == 0 || (a->ip_family == b->ip_family)))) &&
            (((components & 4U) == 0 ||
             (iVar1 = compare_component(a->user,(uint)*(ushort *)&a->field_0x2a,b->user,
                                        (uint)*(ushort *)&b->field_0x2a), iVar1 != 0)))) &&
           (((components & 8U) == 0 ||
            (iVar1 = compare_component(a->password,(uint)*(ushort *)&a->field_0x2c,b->password,
                                       (uint)*(ushort *)&b->field_0x2c), iVar1 != 0)))) &&
          (((((components & 0x10U) == 0 ||
             (iVar1 = compare_component(a->host,(uint)*(ushort *)&a->field_0x2e,b->host,
                                        (uint)*(ushort *)&b->field_0x2e), iVar1 != 0)) &&
            (((components & 0x20U) == 0 ||
             (iVar1 = compare_component(a->port,(uint)(byte)a->field_0x30,b->port,
                                        (uint)(byte)b->field_0x30), iVar1 != 0)))) &&
           ((-1 < (char)components ||
            (iVar1 = compare_component(a->data,(uint)*(ushort *)&a->field_0x31,b->data,
                                       (uint)*(ushort *)&b->field_0x31), iVar1 != 0)))))) &&
         (((components & 0x100U) == 0 ||
          (iVar1 = compare_component(a->fragment,(uint)*(ushort *)&a->field_0x34,b->fragment,
                                     (uint)*(ushort *)&b->field_0x34), iVar1 != 0)))) {
        if ((components & 0x200U) != 0) {
          b_00 = b->post;
          blen = 0;
          if (b_00 != (uchar *)0x0) {
            blen = strlen((char *)b_00);
          }
          a_00 = a->post;
          alen = 0;
          if (a_00 != (uchar *)0x0) {
            alen = strlen((char *)a_00);
          }
          iVar1 = compare_component(a_00,alen,b_00,blen);
          return (uint)(iVar1 != 0);
        }
        goto LAB_080c3300;
      }
    }
    iVar1 = 0;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int get_uri_port(uri *uri)

{
  uchar *__nptr;
  uchar *end;
  int port;
  uchar *local_10 [2];
  
  __nptr = uri->port;
  if (((__nptr == (uchar *)0x0) || (uri->field_0x30 == '\0')) ||
     (local_10[0] = __nptr, port = strtol((char *)__nptr,(char **)local_10,10),
     uri->port == local_10[0])) {
    port = get_protocol_port(uri->protocol);
    return port;
  }
  if (assert_failed != 0) {
    return port;
  }
  assert_failed = (int)(0xffff < (uint)port);
  if (assert_failed == 0) {
    return port;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
  errline = 0x1b2;
  elinks_internal((uchar *)"assertion uri_port_is_valid(port) failed!");
  return port;
}



// WARNING: Unknown calling convention

uri_errno parse_uri(uri *uri,uchar *uristring)

{
  byte bVar1;
  ushort uVar2;
  ushort **ppuVar3;
  protocol pVar4;
  byte *pbVar5;
  uri_errno uVar6;
  size_t __result;
  size_t __result_1;
  size_t __result_2;
  size_t __result_4;
  byte *pbVar7;
  int addrlen;
  uint uVar8;
  size_t sVar9;
  size_t __result_5;
  int iVar10;
  int n;
  uchar *frag_or_post;
  size_t __result_7;
  int *piVar11;
  int iVar12;
  uchar *prefix_end;
  uint uVar13;
  byte bVar14;
  short sVar15;
  uchar *rbracket;
  uint uVar16;
  size_t __result_3;
  size_t __result_6;
  uchar *host_end;
  int datalen;
  uri *puVar17;
  char *local_2c;
  byte local_25;
  byte *local_24;
  byte *local_20;
  
  bVar1 = 0;
  if ((assert_failed == 0) && (assert_failed = (int)(uristring == (uchar *)0x0), assert_failed != 0)
     ) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0xd4;
    elinks_internal((uchar *)"assertion uristring != NULL failed: No uri to parse.");
  }
  puVar17 = uri;
  for (iVar12 = 0xf; iVar12 != 0; iVar12 = iVar12 + -1) {
    puVar17->string = (uchar *)0x0;
    puVar17 = (uri *)((int)puVar17 + (uint)bVar1 * -8 + 4);
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    return URI_ERRNO_OK;
  }
  if (*uristring == '\0') {
    return URI_ERRNO_EMPTY;
  }
  uri->string = uristring;
  ppuVar3 = __ctype_b_loc();
  for (pbVar5 = uristring;
      (((bVar14 = *pbVar5, (*(byte *)(*ppuVar3 + bVar14) & 8) != 0 || (bVar14 == 0x2b)) ||
       (bVar14 == 0x2d)) || (bVar14 == 0x2e)); pbVar5 = pbVar5 + 1) {
  }
  if (((uristring == pbVar5) || (pbVar7 = pbVar5 + -1, 9 < (byte)(pbVar5[-1] - 0x30))) &&
     (pbVar7 = pbVar5, 10 < (byte)(bVar14 - 0x30))) {
    *(undefined2 *)&uri->field_0x28 = 0;
    return URI_ERRNO_INVALID_PROTOCOL;
  }
  sVar15 = (short)((int)pbVar7 - (int)uristring);
  *(short *)&uri->field_0x28 = sVar15;
  if (sVar15 == 0) {
    return URI_ERRNO_INVALID_PROTOCOL;
  }
  pVar4 = get_protocol(uristring,(int)pbVar7 - (int)uristring & 0xffff);
  uri->protocol = pVar4;
  pbVar5 = uristring + *(ushort *)&uri->field_0x28;
  bVar14 = *pbVar5;
  if ((byte)(bVar14 - 0x30) < 10) {
    pbVar5 = pbVar5 + 1;
    uri->ip_family = bVar14 - 0x30;
    bVar14 = *pbVar5;
  }
  if (bVar14 != 0x3a) {
    return URI_ERRNO_INVALID_PROTOCOL;
  }
  local_20 = pbVar5 + 1;
  if ((pbVar5[1] == 0x2f) && (pbVar5[2] == 0x2f)) {
    local_20 = pbVar5 + 3;
    if (pbVar5[3] == 0x2f) {
      iVar12 = get_protocol_need_slash_after_host(uri->protocol);
      uVar6 = URI_ERRNO_TOO_MANY_SLASHES;
      goto joined_r0x080c35c0;
    }
  }
  else {
    iVar12 = get_protocol_need_slashes(uri->protocol);
    uVar6 = URI_ERRNO_NO_SLASHES;
joined_r0x080c35c0:
    if (iVar12 != 0) {
      return uVar6;
    }
  }
  iVar12 = get_protocol_free_syntax(uri->protocol);
  if (iVar12 != 0) {
    uri->data = local_20;
    sVar9 = strlen((char *)local_20);
    *(uint *)&uri->field_0x30 = *(uint *)&uri->field_0x30 & 0xff0000ff | (sVar9 & 0xffff) << 8;
    return URI_ERRNO_OK;
  }
  if (uri->protocol == 4) {
    bVar14 = *local_20;
    if (((bVar14 == 0) || (bVar14 == 0x23)) || (bVar14 == 1)) {
      uVar8 = 0;
      frag_or_post = local_20;
    }
    else {
      uVar8 = 0;
      do {
        uVar8 = uVar8 + 1;
        bVar14 = local_20[uVar8];
        if ((bVar14 == 0) || (bVar14 == 0x23)) break;
      } while (bVar14 != 1);
      if ((int)uVar8 < 0) {
        uVar8 = 0xffffffff;
        pbVar5 = local_20;
        do {
          if (uVar8 == 0) break;
          uVar8 = uVar8 - 1;
          bVar14 = *pbVar5;
          pbVar5 = pbVar5 + (uint)bVar1 * -2 + 1;
        } while (bVar14 != 0);
        uVar8 = ~uVar8 - 1;
        goto LAB_080c3ae1;
      }
      frag_or_post = local_20 + uVar8;
    }
    bVar1 = *frag_or_post;
    if (bVar1 == 0x23) {
      uri->fragment = frag_or_post + 1;
      if ((frag_or_post[1] == 0) || (frag_or_post[1] == 1)) {
        uVar16 = 0;
        uVar13 = 0;
      }
      else {
        uVar16 = 0;
        do {
          uVar13 = uVar16 + 1;
          iVar12 = uVar16 + 2;
          if (frag_or_post[iVar12] == 0) break;
          uVar16 = uVar13;
        } while (frag_or_post[iVar12] != 1);
        uVar16 = uVar13 & 0xffff;
      }
      frag_or_post = frag_or_post + 1 + uVar16;
      *(short *)&uri->field_0x34 = (short)uVar13;
      bVar1 = *frag_or_post;
    }
    if (bVar1 == 1) {
      uri->post = frag_or_post + 1;
    }
LAB_080c3ae1:
    if ((9 < (int)uVar8) && (iVar12 = c_strncasecmp((char *)local_20,"localhost/",10), iVar12 == 0))
    {
      local_20 = local_20 + 9;
      uVar8 = uVar8 - 9;
    }
    *(uint *)&uri->field_0x30 = *(uint *)&uri->field_0x30 & 0xff0000ff | (uVar8 & 0xffff) << 8;
    uri->data = local_20;
    return URI_ERRNO_OK;
  }
  local_2c = strchr((char *)local_20,0x5b);
  if (local_2c == (char *)0x0) {
    bVar1 = *local_20;
    local_24 = (byte *)0x0;
    local_25 = uri->field_0x36;
  }
  else {
    local_24 = (byte *)strchr(local_2c,0x5d);
    if (local_24 == (byte *)0x0) {
      bVar1 = *local_20;
      local_2c = (char *)0x0;
      local_25 = uri->field_0x36;
    }
    else {
      bVar1 = *local_20;
      if ((bVar1 == 0) || (bVar1 == 0x2f)) {
        iVar12 = 0;
      }
      else {
        iVar12 = 0;
        do {
          iVar12 = iVar12 + 1;
          if (local_20[iVar12] == 0) break;
        } while (local_20[iVar12] != 0x2f);
      }
      if (local_24 < local_20 + iVar12) {
        local_25 = uri->field_0x36 | 1;
        uri->field_0x36 = local_25;
        bVar1 = *local_20;
      }
      else {
        local_24 = (byte *)0x0;
        local_2c = (char *)0x0;
        local_25 = uri->field_0x36;
      }
    }
  }
  if (bVar1 != 0) {
    iVar12 = 0;
    pbVar5 = local_20;
    if (bVar1 == 0x40) {
LAB_080c36ae:
      iVar12 = 0;
      do {
        iVar12 = iVar12 + 1;
        if (local_20[iVar12] == 0) break;
      } while (local_20[iVar12] != 0x2f);
    }
    else {
      do {
        iVar12 = iVar12 + 1;
        if (local_20[iVar12] == 0) break;
      } while (local_20[iVar12] != 0x40);
      pbVar5 = local_20 + iVar12;
      iVar12 = 0;
      if (bVar1 != 0x2f) goto LAB_080c36ae;
    }
    if ((pbVar5 < local_20 + iVar12) && (*pbVar5 != 0)) {
      for (; bVar1 = pbVar5[1], bVar1 != 0; pbVar5 = pbVar5 + iVar12) {
        uVar16 = 0;
        uVar8 = uVar16;
        if (bVar1 != 0x40) {
          do {
            uVar16 = uVar8 + 1;
            iVar12 = uVar8 + 2;
            if (pbVar5[iVar12] == 0) break;
            uVar8 = uVar16;
          } while (pbVar5[iVar12] != 0x40);
          if ((bVar1 == 0x2f) || (bVar1 == 0x3f)) break;
        }
        uVar8 = 0;
        do {
          uVar13 = uVar8 + 1;
          bVar14 = pbVar5[uVar8 + 2];
          if ((bVar14 == 0) || (bVar14 == 0x2f)) break;
          uVar8 = uVar13;
        } while (bVar14 != 0x3f);
        if (uVar13 <= uVar16) break;
        iVar12 = 1;
        iVar10 = 0;
        if (bVar1 != 0x40) {
          do {
            iVar12 = iVar10;
            if (pbVar5[iVar12 + 2] == 0) break;
            iVar10 = iVar12 + 1;
          } while (pbVar5[iVar12 + 2] != 0x40);
          iVar12 = iVar12 + 2;
        }
      }
      pbVar7 = (byte *)strchr((char *)local_20,0x3a);
      if ((pbVar5 < pbVar7) || (pbVar7 == (byte *)0x0)) {
        uri->user = local_20;
        *(short *)&uri->field_0x2a = (short)pbVar5 - (short)local_20;
      }
      else {
        uri->user = local_20;
        uri->password = pbVar7 + 1;
        *(short *)&uri->field_0x2a = (short)pbVar7 - (short)local_20;
        *(short *)&uri->field_0x2c = ((short)pbVar5 + -1) - (short)pbVar7;
      }
      local_20 = pbVar5 + 1;
    }
  }
  if ((local_25 & 1) == 0) {
    bVar1 = *local_20;
    if ((((bVar1 == 0) || (bVar1 == 0x3a)) || (bVar1 == 0x2f)) || (bVar1 == 0x3f)) {
      iVar12 = 0;
    }
    else {
      iVar12 = 0;
      while( true ) {
        iVar12 = iVar12 + 1;
        bVar1 = local_20[iVar12];
        if ((bVar1 == 0) || (bVar1 == 0x3a)) break;
        if ((bVar1 == 0x2f) || (bVar1 == 0x3f)) break;
      }
    }
    local_24 = local_20 + iVar12;
    uVar2 = (short)local_24 - (short)local_20;
    uri->host = local_20;
    *(ushort *)&uri->field_0x2e = uVar2;
    if ((uVar2 != 0) && (local_20[uVar2 - 1] == 0x2e)) {
      return URI_ERRNO_TRAILING_DOTS;
    }
  }
  else {
    bVar1 = *local_24;
    if ((((bVar1 == 0) || (bVar1 == 0x3a)) || (bVar1 == 0x2f)) || (bVar1 == 0x3f)) {
      iVar12 = 0;
    }
    else {
      iVar12 = 0;
      while( true ) {
        iVar12 = iVar12 + 1;
        bVar1 = local_24[iVar12];
        if ((bVar1 == 0) || (bVar1 == 0x3a)) break;
        if ((bVar1 == 0x2f) || (bVar1 == 0x3f)) break;
      }
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return URI_ERRNO_IPV6_SECURITY;
    }
    pbVar5 = local_24 + (-1 - (int)local_2c);
    assert_failed = (int)((byte *)0x400 < pbVar5);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x15b;
      elinks_internal((uchar *)
                      "assertion addrlen >= 0 && addrlen < NI_MAXHOST failed: parse_uri(): addrlen value is bad (%d) for URL \'%s\'. Problems are likely to be encountered. Please report this, it is a security bug!"
                      ,pbVar5,uristring);
      if (assert_failed != 0) {
        assert_failed = 0;
        return URI_ERRNO_IPV6_SECURITY;
      }
    }
    *(short *)&uri->field_0x2e = (short)pbVar5;
    local_24 = local_24 + iVar12;
    uri->host = (uchar *)(local_2c + 1);
  }
  bVar1 = *local_24;
  if (bVar1 == 0x3a) {
    if ((local_24[1] == 0) || (iVar12 = 0, local_24[1] == 0x2f)) {
      uri->port = local_24 + 1;
      uri->field_0x30 = 0;
      return URI_ERRNO_NO_PORT_COLON;
    }
    do {
      iVar10 = iVar12;
      if (local_24[iVar10 + 2] == 0) {
        pbVar5 = local_24 + iVar10 + 2;
        bVar1 = (char)pbVar5 - ((char)local_24 + '\x01');
        goto LAB_080c39df;
      }
      iVar12 = iVar10 + 1;
    } while (local_24[iVar10 + 2] != 0x2f);
    pbVar5 = local_24 + iVar10 + 2;
    bVar1 = (char)pbVar5 - ((char)local_24 + '\x01');
LAB_080c39df:
    pbVar7 = local_24 + 1;
    uri->field_0x30 = bVar1;
    uri->port = pbVar7;
    if (bVar1 == 0) {
      return URI_ERRNO_NO_PORT_COLON;
    }
    if ((uint)bVar1 == (int)pbVar5 - (int)pbVar7) {
      local_24 = pbVar7;
      if (pbVar5 <= pbVar7) {
LAB_080c3c9d:
        if (pbVar7 != (byte *)0x0) {
          piVar11 = __errno_location();
          *piVar11 = 0;
          uVar8 = strtol((char *)uri->port,(char **)0x0,10);
          if (0xffff < uVar8) {
            return URI_ERRNO_INVALID_PORT;
          }
          if (*piVar11 != 0) {
            return URI_ERRNO_INVALID_PORT;
          }
        }
        bVar1 = *local_24;
        goto LAB_080c387c;
      }
      bVar1 = *pbVar7;
      while ((byte)(bVar1 - 0x30) < 10) {
        local_24 = local_24 + 1;
        if (pbVar5 <= local_24) goto LAB_080c3c9d;
        bVar1 = *local_24;
      }
    }
    return URI_ERRNO_INVALID_PORT;
  }
LAB_080c387c:
  if (bVar1 == 0x2f) {
    local_24 = local_24 + 1;
  }
  else {
    iVar12 = get_protocol_need_slash_after_host(uri->protocol);
    if (iVar12 != 0) {
      return (-(uint)(*(short *)&uri->field_0x2e == 0) & 0xfffffffe) + URI_ERRNO_NO_HOST_SLASH;
    }
  }
  bVar1 = *local_24;
  if (((bVar1 == 0) || (bVar1 == 0x23)) || (bVar1 == 1)) {
    uVar8 = 0;
  }
  else {
    uVar8 = 0;
    do {
      uVar8 = uVar8 + 1;
      bVar1 = local_24[uVar8];
      if ((bVar1 == 0) || (bVar1 == 0x23)) break;
    } while (bVar1 != 1);
  }
  pbVar5 = local_24 + uVar8;
  uri->data = local_24;
  *(uint *)&uri->field_0x30 = *(uint *)&uri->field_0x30 & 0xff0000ff | (uVar8 & 0xffff) << 8;
  bVar1 = *pbVar5;
  if (bVar1 == 0x23) {
    uri->fragment = pbVar5 + 1;
    if ((pbVar5[1] == 0) || (pbVar5[1] == 1)) {
      uVar16 = 0;
      uVar8 = 0;
    }
    else {
      uVar16 = 0;
      do {
        uVar8 = uVar16 + 1;
        iVar12 = uVar16 + 2;
        if (pbVar5[iVar12] == 0) break;
        uVar16 = uVar8;
      } while (pbVar5[iVar12] != 1);
      uVar16 = uVar8 & 0xffff;
    }
    pbVar5 = pbVar5 + 1 + uVar16;
    *(short *)&uri->field_0x34 = (short)uVar8;
    bVar1 = *pbVar5;
  }
  if (bVar1 == 1) {
    uri->post = pbVar5 + 1;
    return URI_ERRNO_OK;
  }
  return URI_ERRNO_OK;
}



// WARNING: Unknown calling convention

int is_ip_address(uchar *address,int addresslen)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  int in_GS_OFFSET;
  in_addr addr4;
  uchar buffer [46];
  sockaddr_in6 addr6;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  uVar2 = 0;
  if ((uint)addresslen < 0x2e) {
    safe_strncpy(buffer,address,addresslen + 1);
    iVar3 = inet_pton(10,(char *)buffer,&addr6.sin6_addr);
    uVar2 = 1;
    if (iVar3 < 1) {
      iVar3 = inet_pton(2,(char *)buffer,&addr4);
      uVar2 = (uint)(0 < iVar3);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return uVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

uchar * normalize_uri(uri *uri,uchar *uristring)

{
  uchar uVar1;
  uchar uVar2;
  int iVar3;
  int iVar4;
  uri_errno uVar5;
  size_t sVar6;
  uchar uVar7;
  uchar *dest;
  uchar *parse_string;
  uri *uri_00;
  byte *pbVar8;
  uchar *src;
  int need_slash;
  uchar *puVar9;
  uchar *__s;
  int iVar10;
  uchar *local_80;
  int local_74;
  uchar *local_60;
  uri uri_struct;
  
  uri_00 = &uri_struct;
  puVar9 = uristring;
  if (uri != (uri *)0x0) goto LAB_080c3de5;
  do {
    uVar5 = parse_uri(uri_00,puVar9);
    uri = uri_00;
    if (uVar5 != URI_ERRNO_OK) {
      return uristring;
    }
LAB_080c3de5:
    uri_00 = uri;
    if ((assert_failed == 0) &&
       (assert_failed = (int)(uri_00->data == (uchar *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x2c4;
      elinks_internal((uchar *)"assertion uri->data failed!");
    }
    iVar3 = *(ushort *)&uri_00->field_0x28 - 1;
    if (iVar3 != -1) {
      pbVar8 = uri_00->string + iVar3;
      iVar10 = 0;
      do {
        while (iVar4 = c_isupper((uint)*pbVar8), iVar4 != 0) {
          iVar10 = iVar10 + -1;
          iVar4 = c_tolower((uint)*pbVar8);
          *pbVar8 = (byte)iVar4;
          pbVar8 = pbVar8 + -1;
          if (iVar3 + iVar10 == -1) goto LAB_080c3e5b;
        }
        iVar10 = iVar10 + -1;
        pbVar8 = pbVar8 + -1;
      } while (iVar3 + iVar10 != -1);
    }
LAB_080c3e5b:
    if (*(ushort *)&uri_00->field_0x2e != 0) {
      iVar3 = *(ushort *)&uri_00->field_0x2e - 1;
      if (-1 < iVar3) {
        pbVar8 = uri_00->host + iVar3;
        iVar10 = 0;
        do {
          while (iVar4 = c_isupper((uint)*pbVar8), iVar4 != 0) {
            iVar10 = iVar10 + -1;
            iVar4 = c_tolower((uint)*pbVar8);
            *pbVar8 = (byte)iVar4;
            pbVar8 = pbVar8 + -1;
            if (iVar3 + iVar10 < 0) goto LAB_080c3e68;
          }
          iVar10 = iVar10 + -1;
          pbVar8 = pbVar8 + -1;
        } while (-1 < iVar3 + iVar10);
      }
    }
LAB_080c3e68:
    puVar9 = uri_00->data;
  } while (uri_00->protocol == PROTOCOL_PROXY);
  iVar3 = get_protocol_free_syntax(uri_00->protocol);
  if (iVar3 == 0) {
    iVar3 = 0;
    local_74 = 1;
    if (uri_00->protocol != PROTOCOL_UNKNOWN) {
      iVar3 = get_protocol_need_slash_after_host(uri_00->protocol);
      iVar3 = -iVar3;
      local_74 = get_protocol_keep_double_slashes(uri_00->protocol);
    }
    puVar9 = uri_00->data + iVar3;
    uVar7 = *puVar9;
    local_80 = puVar9;
    local_60 = puVar9;
LAB_080c3ee0:
    while (__s = local_80, uVar7 != '\0') {
      uVar1 = *__s;
      if (((uVar1 == '#') || (uVar1 == '\x01')) || (uVar1 == '?')) {
        sVar6 = strlen((char *)__s);
        memmove(local_60,__s,sVar6 + 1);
        return uristring;
      }
      if (uVar1 != '/') goto LAB_080c3f3a;
      if (__s[1] != '.') goto code_r0x080c3f6b;
      uVar2 = __s[2];
      if (uVar2 == '\0') {
LAB_080c407d:
        *local_60 = '/';
        local_60[1] = '\0';
        return uristring;
      }
      local_80 = __s + 2;
      if (uVar2 != '/') {
        if (uVar2 != '.') goto LAB_080c3f3a;
        local_80 = __s + 3;
        uVar7 = __s[3];
        if ((uVar7 != '/') && (uVar7 != '\0')) goto LAB_080c3f3a;
        do {
          if (local_60 <= puVar9) break;
          local_60 = local_60 + -1;
        } while (*local_60 != '/');
        if (uVar7 == '\0') goto LAB_080c407d;
        goto LAB_080c3f4c;
      }
    }
  }
  return uristring;
code_r0x080c3f6b:
  if ((__s[1] != '/') || (local_80 = __s + 1, local_74 != 0)) {
LAB_080c3f3a:
    local_80 = __s + 1;
    *local_60 = uVar1;
    uVar7 = '\0';
    if (uVar1 != '\0') {
      local_60 = local_60 + 1;
LAB_080c3f4c:
      uVar7 = *local_60;
    }
  }
  goto LAB_080c3ee0;
}



// WARNING: Unknown calling convention

uri * add_to_uri_list(uri_list *list,uri *uri)

{
  int iVar1;
  uri **ppuVar2;
  size_t newsize;
  uint uVar3;
  size_t size;
  size_t oldsize;
  uint uVar4;
  
  uVar3 = list->size + 4U & 0xfffffffc;
  uVar4 = list->size + 3U & 0xfffffffc;
  if (uVar4 < uVar3) {
    size = uVar3 * 4;
    ppuVar2 = (uri **)mem_realloc(list->uris,size);
    if (ppuVar2 == (uri **)0x0) {
      return (uri *)0x0;
    }
    list->uris = ppuVar2;
    memset(ppuVar2 + uVar4,0,size + uVar4 * -4);
  }
  ppuVar2 = list->uris;
  if (ppuVar2 == (uri **)0x0) {
    return (uri *)0x0;
  }
  iVar1 = list->size;
  (uri->object).refcount = (uri->object).refcount + 1;
  ppuVar2[iVar1] = uri;
  list->size = iVar1 + 1;
  return uri;
}



// WARNING: Unknown calling convention

void encode_win32_uri_string(string *string,uchar *name,int namelen)

{
  byte *pbVar1;
  int iVar2;
  uint uVar3;
  byte bVar4;
  undefined2 *puVar5;
  uchar *puVar6;
  size_t oldsize;
  uint uVar7;
  char cVar8;
  uchar uVar9;
  size_t newsize;
  uint size;
  uchar n [4];
  
  n[0] = '%';
  n[1] = '\0';
  if (namelen < 0) {
    namelen = strlen((char *)name);
  }
  pbVar1 = name + namelen;
  if (name < pbVar1) {
    do {
      while (((((bVar4 = *name, 0x19 < (byte)(bVar4 + 0x9f) && (0x19 < (byte)(bVar4 + 0xbf))) &&
               (9 < (byte)(bVar4 - 0x30))) &&
              ((((bVar4 != 0x5f && (bVar4 != 0x2e)) &&
                ((bVar4 != 0x2d && ((bVar4 != 0x7e && (bVar4 != 0x21)))))) && (bVar4 != 0x27)))) &&
             ((((bVar4 != 0x2a && (bVar4 != 0x29)) && (bVar4 != 0x28)) &&
              ((bVar4 != 0x3a && (bVar4 != 0x5c))))))) {
        bVar4 = bVar4 >> 4;
        cVar8 = bVar4 + 0x57;
        if (bVar4 < 10) {
          cVar8 = bVar4 + 0x30;
        }
        n[1] = cVar8;
        bVar4 = *name & 0xf;
        uVar9 = bVar4 + 0x57;
        if (bVar4 < 10) {
          uVar9 = bVar4 + 0x30;
        }
        if (assert_failed != 0) {
LAB_080c423a:
          assert_failed = 0;
          goto joined_r0x080c424a;
        }
        if (string == (string *)0x0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c423a;
        }
        else {
          assert_failed = 0;
        }
        iVar2 = string->length;
        size = iVar2 + 0x103U & 0xffffff00;
        uVar3 = iVar2 + 0xffU >> 8;
        uVar7 = iVar2 + 0xffU & 0xffffff00;
        if (uVar7 <= size && size + uVar3 * -0x100 != 0) {
          puVar6 = (uchar *)mem_realloc(string->source,size);
          if (puVar6 == (uchar *)0x0) goto joined_r0x080c424a;
          string->source = puVar6;
          memset(puVar6 + uVar7,0,size + uVar3 * -0x100);
        }
        if (string->source == (uchar *)0x0) goto joined_r0x080c424a;
        name = name + 1;
        puVar5 = (undefined2 *)(string->source + string->length);
        *puVar5 = n._0_2_;
        *(uchar *)(puVar5 + 1) = uVar9;
        string->source[iVar2 + 3] = '\0';
        string->length = iVar2 + 3;
        if (pbVar1 <= name) {
          return;
        }
      }
      add_char_to_string(string,bVar4);
joined_r0x080c424a:
      name = name + 1;
    } while (name < pbVar1);
  }
  return;
}



// WARNING: Unknown calling convention

void encode_uri_string(string *string,uchar *name,int namelen,int convert_slashes)

{
  byte *pbVar1;
  int iVar2;
  uint uVar3;
  char cVar4;
  undefined2 *puVar5;
  uchar *puVar6;
  size_t oldsize;
  uint uVar7;
  byte bVar8;
  uchar uVar9;
  size_t newsize;
  uint size;
  uchar n [4];
  
  n[0] = '%';
  n[1] = '\0';
  if (namelen < 0) {
    namelen = strlen((char *)name);
  }
  pbVar1 = name + namelen;
  if (name < pbVar1) {
    do {
      bVar8 = *name;
      if ((((((byte)(bVar8 + 0x9f) < 0x1a) || ((byte)(bVar8 + 0xbf) < 0x1a)) ||
           ((byte)(bVar8 - 0x30) < 10)) ||
          ((((bVar8 == 0x5f || (bVar8 == 0x2e)) ||
            ((bVar8 == 0x2d || ((bVar8 == 0x7e || (bVar8 == 0x21)))))) || (bVar8 == 0x27)))) ||
         ((((bVar8 == 0x2a || (bVar8 == 0x29)) || (bVar8 == 0x28)) ||
          ((convert_slashes == 0 && (bVar8 == 0x2f)))))) {
        add_char_to_string(string,bVar8);
      }
      else {
        bVar8 = bVar8 >> 4;
        cVar4 = bVar8 + 0x57;
        if (bVar8 < 10) {
          cVar4 = bVar8 + 0x30;
        }
        n[1] = cVar4;
        bVar8 = *name & 0xf;
        uVar9 = bVar8 + 0x57;
        if (bVar8 < 10) {
          uVar9 = bVar8 + 0x30;
        }
        if (assert_failed == 0) {
          if (string == (string *)0x0) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080c4453;
          }
          else {
            assert_failed = 0;
          }
          iVar2 = string->length;
          size = iVar2 + 0x103U & 0xffffff00;
          uVar3 = iVar2 + 0xffU >> 8;
          uVar7 = iVar2 + 0xffU & 0xffffff00;
          if (uVar7 <= size && size + uVar3 * -0x100 != 0) {
            puVar6 = (uchar *)mem_realloc(string->source,size);
            if (puVar6 == (uchar *)0x0) goto LAB_080c4460;
            string->source = puVar6;
            memset(puVar6 + uVar7,0,size + uVar3 * -0x100);
          }
          if (string->source != (uchar *)0x0) {
            puVar5 = (undefined2 *)(string->source + string->length);
            *puVar5 = n._0_2_;
            *(uchar *)(puVar5 + 1) = uVar9;
            string->source[iVar2 + 3] = '\0';
            string->length = iVar2 + 3;
          }
        }
        else {
LAB_080c4453:
          assert_failed = 0;
        }
      }
LAB_080c4460:
      name = name + 1;
    } while (name < pbVar1);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * translate_url(uchar *url,uchar *cwd)

{
  uchar uVar1;
  uri_errno uVar2;
  uri_errno uri_errno;
  size_t sVar3;
  int slashes;
  protocol pVar4;
  string *psVar5;
  int iVar6;
  uchar *puVar7;
  uint uVar8;
  int pos;
  protocol protocol;
  uri_errno prev_errno;
  uri_errno uVar9;
  int offset;
  uchar *to;
  uchar *__dest;
  uchar *from_1;
  int retries;
  int iVar10;
  uchar *from;
  uchar *puVar11;
  byte bVar12;
  uri uri;
  string str;
  uchar *local_20 [4];
  
  bVar12 = 0;
  uVar1 = *url;
  while (uVar1 == ' ') {
    url = url + 1;
    uVar1 = *url;
  }
  if ((uVar1 == '\0') || (local_20[0] = expand_tilde(url), local_20[0] == (uchar *)0x0)) {
    return (uchar *)0x0;
  }
  uVar9 = URI_ERRNO_EMPTY;
  iVar10 = 0;
  do {
    uVar2 = parse_uri(&uri,local_20[0]);
    iVar6 = assert_failed;
    if (uVar9 == uVar2) {
      if (0x20 < iVar10) {
LAB_080c4a6e:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x449;
        elinks_error((uchar *)"Maximum number of parsing attempts exceeded for %s.",url);
      }
switchD_080c4618_caseD_1:
      mem_free(local_20[0]);
      return (uchar *)0x0;
    }
    iVar10 = iVar10 + 1;
    if (iVar10 == 0x22) goto LAB_080c4a6e;
    switch(uVar2) {
    case URI_ERRNO_OK:
      if ((uri.protocol != 0x12) ||
         (pVar4 = find_uri_protocol(local_20[0]), pVar4 == PROTOCOL_UNKNOWN)) {
        puVar7 = uri.data;
        if (uri.protocol == 4) {
          if ((cwd == (uchar *)0x0) || (*cwd == '\0')) goto LAB_080c4bef;
          if (assert_failed == 0) {
            if (uri.data == (uchar *)0x0) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
              errline = 0x32e;
              elinks_internal((uchar *)
                              "assertion uri->protocol == PROTOCOL_FILE && uri->data failed!");
            }
            else {
              assert_failed = 0;
            }
          }
          uVar1 = *puVar7;
          if ((uVar1 != '\0') && (uVar1 != '.')) goto LAB_080c4cb2;
          psVar5 = init_string(&str);
          if (psVar5 != (string *)0x0) {
            encode_uri_string(&str,cwd,-1,0);
            if (*puVar7 == '.') {
              *puVar7 = '/';
            }
            insert_in_string(&uri.string,7,str.source,str.length);
            done_string(&str);
            goto LAB_080c4cd4;
          }
        }
        if (uri.protocol != 0xf) {
LAB_080c4bef:
          puVar7 = normalize_uri(&uri,uri.string);
          return puVar7;
        }
        puVar7 = translate_url(uri.data,cwd);
        if (puVar7 == (uchar *)0x0) goto switchD_080c4618_caseD_1;
        *uri.data = '\0';
        uVar8 = 0xffffffff;
        puVar11 = puVar7;
        goto code_r0x080c4c38;
      }
      psVar5 = init_string(&str);
      if (psVar5 == (string *)0x0) {
        return (uchar *)0x0;
      }
      if (pVar4 == PROTOCOL_HTTP) {
        add_to_string(&str,(uchar *)"http://");
        add_to_string(&str,local_20[0]);
      }
      else if (pVar4 != PROTOCOL_UNKNOWN) {
        if (pVar4 == PROTOCOL_FTP) {
          add_to_string(&str,(uchar *)"ftp://");
          encode_uri_string(&str,local_20[0],-1,0);
        }
        else {
          add_to_string(&str,(uchar *)"file://");
          if (*local_20[0] != '/') {
            add_to_string(&str,"./");
          }
          add_to_string(&str,local_20[0]);
        }
      }
      uVar9 = URI_ERRNO_EMPTY;
      mem_free(local_20[0]);
      local_20[0] = str.source;
      break;
    default:
      goto switchD_080c4618_caseD_1;
    case URI_ERRNO_INVALID_PROTOCOL:
      pVar4 = find_uri_protocol(local_20[0]);
      psVar5 = init_string(&str);
      if (psVar5 == (string *)0x0) {
        return (uchar *)0x0;
      }
      if (pVar4 == PROTOCOL_FTP) {
        add_to_string(&str,(uchar *)"ftp://");
        encode_uri_string(&str,local_20[0],-1,0);
      }
      else if (pVar4 == PROTOCOL_HTTP) {
        add_to_string(&str,(uchar *)"http://");
        add_to_string(&str,local_20[0]);
      }
      else {
        add_to_string(&str,(uchar *)"file://");
        if (*local_20[0] != '/') {
          add_to_string(&str,"./");
        }
        puVar7 = local_20[0];
        iVar6 = check_whether_file_exists(local_20[0]);
        encode_uri_string(&str,puVar7,iVar6,0);
        if (0 < iVar6) {
          add_to_string(&str,puVar7 + iVar6);
        }
      }
      uVar9 = URI_ERRNO_INVALID_PROTOCOL;
      mem_free(local_20[0]);
      local_20[0] = str.source;
      break;
    case URI_ERRNO_NO_SLASHES:
      uVar9 = URI_ERRNO_NO_SLASHES;
      slashes = (uri.string[(ushort)uri._40_2_ + 1] != '/') + 1;
      insert_in_string(local_20,(ushort)uri._40_2_ + 1,"//",slashes);
      break;
    case URI_ERRNO_TOO_MANY_SLASHES:
      if (assert_failed == 0) {
        uVar8 = (uint)(ushort)uri._40_2_;
        if (((uri.string[uVar8] == ':') && (uri.string[uVar8 + 1] == '/')) &&
           (uri.string[uVar8 + 2] == '/')) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 0x499;
          elinks_internal((uchar *)
                          "assertion uri.string[uri.protocollen] == \':\' && uri.string[uri.protocollen + 1] == \'/\' && uri.string[uri.protocollen + 2] == \'/\' failed!"
                         );
          uVar8 = (uint)(ushort)uri._40_2_;
          iVar6 = assert_failed;
        }
      }
      else {
        uVar8 = (uint)(ushort)uri._40_2_;
      }
      puVar7 = uri.string + uVar8 + 3;
      uVar1 = *puVar7;
      puVar11 = puVar7;
      while (uVar1 == '/') {
        puVar11 = puVar11 + 1;
        uVar1 = *puVar11;
      }
      if ((iVar6 == 0) && (assert_failed = (int)(puVar11 <= puVar7), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x49e;
        elinks_internal((uchar *)"assertion to < from failed!");
      }
      sVar3 = strlen((char *)puVar11);
      uVar9 = URI_ERRNO_TOO_MANY_SLASHES;
      memmove(puVar7,puVar11,sVar3 + 1);
      break;
    case URI_ERRNO_TRAILING_DOTS:
      puVar7 = uri.host + (ushort)uri._46_2_;
      puVar11 = puVar7;
      if (assert_failed == 0) {
        if (((uri.host < puVar7) && (puVar7[-1] == '.')) && (*puVar7 != '.')) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 0x4b4;
          elinks_internal((uchar *)
                          "assertion uri.host < to && to[-1] == \'.\' && *from != \'.\' failed!");
          iVar6 = assert_failed;
        }
      }
      do {
        __dest = puVar11;
        if (__dest <= uri.host) break;
        puVar11 = __dest + -1;
      } while (__dest[-1] == '.');
      if ((iVar6 == 0) && (assert_failed = (int)(puVar7 <= __dest), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x4b8;
        elinks_internal((uchar *)"assertion to < from failed!");
      }
      sVar3 = strlen((char *)puVar7);
      uVar9 = URI_ERRNO_TRAILING_DOTS;
      memmove(__dest,puVar7,sVar3 + 1);
      break;
    case URI_ERRNO_NO_PORT_COLON:
      if (assert_failed == 0) {
        if (((uri._48_1_ == '\0') && (uri.string < uri.port)) && (uri.port[-1] == ':')) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 0x4bf;
          elinks_internal((uchar *)
                          "assertion uri.portlen == 0 && uri.string < uri.port && uri.port[-1] == \':\' failed!"
                         );
        }
      }
      puVar7 = uri.port;
      puVar11 = uri.port + -1;
      sVar3 = strlen((char *)uri.port);
      uVar9 = URI_ERRNO_NO_PORT_COLON;
      memmove(puVar11,puVar7,sVar3 + 1);
      break;
    case URI_ERRNO_NO_HOST_SLASH:
      if (uri.port == (uchar *)0x0) {
        offset = (int)(uri.host +
                      (((byte)uri._54_1_ & 1) - (int)uri.string) + (uint)(ushort)uri._46_2_);
      }
      else {
        offset = (int)uri.port + ((uint)(byte)uri._48_1_ - (int)uri.string);
      }
      if ((assert_failed == 0) &&
         (assert_failed = (int)(uri.host == (uchar *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x4ca;
        elinks_internal((uchar *)
                        "assertion uri.host != NULL failed: uri.host not set after no host slash error"
                       );
      }
      uVar9 = URI_ERRNO_NO_HOST_SLASH;
      insert_in_string(local_20,offset,"/",1);
    }
  } while( true );
  while( true ) {
    puVar7 = puVar7 + 1;
    uVar1 = *puVar7;
    if (uVar1 == '\0') break;
LAB_080c4cb2:
    if (uVar1 == '/') break;
  }
  uVar8 = 0xffffffff;
  puVar11 = puVar7;
  do {
    if (uVar8 == 0) break;
    uVar8 = uVar8 - 1;
    uVar1 = *puVar11;
    puVar11 = puVar11 + (uint)bVar12 * -2 + 1;
  } while (uVar1 != '\0');
  memmove(uri.data,puVar7,~uVar8);
LAB_080c4cd4:
  puVar7 = normalize_uri((uri *)0x0,uri.string);
  return puVar7;
  while( true ) {
    uVar8 = uVar8 - 1;
    uVar1 = *puVar11;
    puVar11 = puVar11 + (uint)bVar12 * -2 + 1;
    if (uVar1 == '\0') break;
code_r0x080c4c38:
    if (uVar8 == 0) break;
  }
  insert_in_string(&uri.string,(int)uri.data - (int)uri.string,puVar7,~uVar8 - 1);
  mem_free(puVar7);
  puVar7 = normalize_uri((uri *)0x0,uri.string);
  return puVar7;
}



// WARNING: Unknown calling convention

uchar * join_urls(uri *base,uchar *rel)

{
  byte bVar1;
  uchar uVar2;
  ushort **ppuVar3;
  byte *pbVar4;
  byte *pbVar5;
  uchar *translated;
  uchar *path;
  size_t sVar6;
  protocol pVar7;
  int iVar8;
  uchar *puVar9;
  int add_slash;
  int length;
  uchar *puVar10;
  size_t __n;
  uint uVar11;
  int translate;
  bool bVar12;
  uchar *local_20 [4];
  
  bVar1 = *rel;
  if (bVar1 == 0x23) {
    puVar9 = base->fragment;
    if ((puVar9 == (uchar *)0x0) && (puVar9 = base->post, puVar9 == (uchar *)0x0)) {
      uVar11 = 0xffffffff;
      puVar9 = base->string;
      do {
        if (uVar11 == 0) break;
        uVar11 = uVar11 - 1;
        uVar2 = *puVar9;
        puVar9 = puVar9 + 1;
      } while (uVar2 != '\0');
      puVar9 = (uchar *)(~uVar11 - 1);
    }
    else {
      puVar9 = puVar9 + (-1 - (int)base->string);
    }
joined_r0x080c5007:
    if (puVar9 == (uchar *)0x0) {
LAB_080c4daf:
      ppuVar3 = __ctype_b_loc();
      pbVar4 = rel;
      while (((((*(byte *)(*ppuVar3 + bVar1) & 8) != 0 || (bVar1 == 0x2b)) || (bVar1 == 0x2d)) ||
             (bVar1 == 0x2e))) {
        pbVar4 = pbVar4 + 1;
        bVar1 = *pbVar4;
      }
      if ((((rel != pbVar4) && (pbVar5 = pbVar4 + -1, (byte)(pbVar4[-1] - 0x30) < 10)) ||
          (pbVar5 = pbVar4, (byte)(bVar1 - 0x30) < 0xb)) &&
         ((((int)pbVar5 - (int)rel != 0 &&
           (pVar7 = get_protocol(rel,(int)pbVar5 - (int)rel), pVar7 != PROTOCOL_PROXY)) &&
          (pVar7 != PROTOCOL_UNKNOWN)))) {
        puVar9 = translate_url(rel,(uchar *)0x0);
        if (puVar9 != (uchar *)0x0) {
          return puVar9;
        }
        local_20[0] = (uchar *)0x0;
      }
      if (assert_failed != 0) {
        assert_failed = 0;
        return (uchar *)0x0;
      }
      assert_failed = (int)(base->data == (uchar *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 0x3b4;
        elinks_internal((uchar *)"assertion base->data != NULL failed: bad base url");
        if (assert_failed != 0) {
          assert_failed = 0;
          return (uchar *)0x0;
        }
      }
      puVar9 = base->data;
      if (*puVar9 == '\0') {
        puVar10 = puVar9 + -1;
        if (puVar9[-1] != '/') goto LAB_080c4fee;
      }
      else {
        puVar10 = puVar9 + -1;
        if (*puVar9 == '/') {
LAB_080c4fee:
          puVar10 = puVar9;
        }
      }
      uVar11 = 0;
      if (*rel != '/') {
        uVar2 = *puVar10;
        uVar11 = (uint)(uVar2 == '\0');
        if (((uVar2 != '\0') && (uVar2 != '\x01')) && (puVar9 = puVar10, uVar2 != '#')) {
          while (uVar2 != '?') {
            puVar9 = puVar9 + 1;
            bVar12 = uVar2 == '/';
            uVar2 = *puVar9;
            if (bVar12) {
              puVar10 = puVar9;
            }
            if (((uVar2 == '\0') || (uVar2 == '#')) || (uVar2 == '\x01')) break;
          }
        }
      }
      sVar6 = strlen((char *)rel);
      __n = (int)puVar10 - (int)base->string;
      local_20[0] = (uchar *)mem_alloc(uVar11 + 1 + sVar6 + __n);
      if (local_20[0] == (uchar *)0x0) {
        return (uchar *)0x0;
      }
      memcpy(local_20[0],base->string,__n);
      if (uVar11 != 0) {
        local_20[0][__n] = '/';
      }
      strcpy((char *)(local_20[0] + __n + uVar11),(char *)rel);
      goto LAB_080c4f1c;
    }
    bVar12 = false;
  }
  else {
    if (bVar1 == 0x3f) {
      puVar9 = base->fragment;
      if ((puVar9 == (uchar *)0x0) && (puVar9 = base->post, puVar9 == (uchar *)0x0)) {
        uVar11 = 0xffffffff;
        puVar9 = base->string;
        do {
          if (uVar11 == 0) break;
          uVar11 = uVar11 - 1;
          uVar2 = *puVar9;
          puVar9 = puVar9 + 1;
        } while (uVar2 != '\0');
        puVar9 = (uchar *)(~uVar11 - 1);
      }
      else {
        puVar9 = puVar9 + (-1 - (int)base->string);
      }
      local_20[0] = (uchar *)memchr(base->data,0x3f,(uint)*(ushort *)&base->field_0x31);
      if (local_20[0] != (uchar *)0x0) {
        puVar9 = local_20[0] + -(int)base->string;
      }
      goto joined_r0x080c5007;
    }
    if ((bVar1 != 0x2f) || (rel[1] != '/')) goto LAB_080c4daf;
    iVar8 = get_protocol_need_slashes(base->protocol);
    if (iVar8 == 0) {
      return (uchar *)0x0;
    }
    bVar12 = true;
    puVar9 = (uchar *)(*(ushort *)&base->field_0x28 + 1);
  }
  local_20[0] = memacpy(base->string,(int)puVar9);
  if (local_20[0] == (uchar *)0x0) {
    return (uchar *)0x0;
  }
  add_to_strn(local_20,rel);
  if (bVar12) {
    puVar9 = translate_url(local_20[0],(uchar *)0x0);
    mem_free(local_20[0]);
    return puVar9;
  }
LAB_080c4f1c:
  puVar9 = normalize_uri((uri *)0x0,local_20[0]);
  return puVar9;
}



// WARNING: Unknown calling convention

string * add_uri_to_string(string *string,uri *uri,uri_component components)

{
  char cVar1;
  uchar uVar2;
  ushort uVar3;
  int iVar4;
  uchar *puVar5;
  int code;
  void *pvVar6;
  string *psVar7;
  void *pvVar8;
  uchar *puVar9;
  size_t sVar10;
  size_t sVar11;
  int newlength;
  int newlength_3;
  int newlength_2;
  uchar *host;
  int port;
  uchar *filename;
  int newlength_1;
  uchar *puVar12;
  uint uVar13;
  bool bVar14;
  byte bVar15;
  uri_component uVar16;
  uchar *local_20 [4];
  
  bVar15 = 0;
  if (uri->protocol == 0x12) {
    psVar7 = add_to_string(string,uri->string);
    return psVar7;
  }
  if ((components & 1U) != 0) {
    puVar5 = uri->string;
    uVar13 = (uint)*(ushort *)&uri->field_0x28;
    if (assert_failed == 0) {
      if ((string == (string *)0x0) || (puVar5 == (uchar *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c5aa8;
      }
      else {
        assert_failed = 0;
      }
      if (uVar13 != 0) {
        iVar4 = uVar13 + string->length;
        pvVar6 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
        if (pvVar6 != (void *)0x0) {
          memcpy(string->source + string->length,puVar5,uVar13);
          string->source[iVar4] = '\0';
          string->length = iVar4;
        }
      }
    }
    else {
LAB_080c5aa8:
      assert_failed = 0;
    }
    if (((components & 2U) != 0) && (uri->ip_family != 0)) {
      add_long_to_string(string,uri->ip_family);
    }
    add_char_to_string(string,':');
    iVar4 = get_protocol_need_slashes(uri->protocol);
    if (iVar4 != 0) {
      add_to_string(string,"//");
    }
  }
  if (((components & 4U) == 0) || (uVar3 = *(ushort *)&uri->field_0x2a, uVar3 == 0)) {
    if (((components & 8U) != 0) && (uVar3 = *(ushort *)&uri->field_0x2c, uVar3 != 0)) {
      puVar5 = uri->password;
      if (assert_failed == 0) {
        if ((string == (string *)0x0) || (puVar5 == (uchar *)0x0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c55a4;
        }
        else {
          assert_failed = 0;
        }
        iVar4 = (uint)uVar3 + string->length;
        pvVar6 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
        if (pvVar6 != (void *)0x0) {
          memcpy(string->source + string->length,puVar5,(uint)uVar3);
          string->source[iVar4] = '\0';
          string->length = iVar4;
        }
      }
      else {
LAB_080c55a4:
        assert_failed = 0;
      }
    }
  }
  else {
    puVar5 = uri->user;
    if (assert_failed == 0) {
      if ((string == (string *)0x0) || (puVar5 == (uchar *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c554c;
      }
      else {
        assert_failed = 0;
      }
      iVar4 = (uint)uVar3 + string->length;
      pvVar6 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
      if (pvVar6 != (void *)0x0) {
        memcpy(string->source + string->length,puVar5,(uint)uVar3);
        string->source[iVar4] = '\0';
        string->length = iVar4;
      }
    }
    else {
LAB_080c554c:
      assert_failed = 0;
    }
    if (((components & 8U) != 0) && (*(short *)&uri->field_0x2c != 0)) {
      add_char_to_string(string,':');
      add_bytes_to_string__(string,uri->password,(uint)*(ushort *)&uri->field_0x2c);
    }
    add_char_to_string(string,'@');
  }
  if (((components & 0x10U) != 0) && (uVar3 = *(ushort *)&uri->field_0x2e, uVar3 != 0)) {
    if (((uri->field_0x36 & 1) != 0) && ((components & 0x20U) != 0)) {
      add_char_to_string(string,'[');
      uVar3 = *(ushort *)&uri->field_0x2e;
    }
    if ((components & 0x800U) == 0) {
LAB_080c51ae:
      add_bytes_to_string__(string,uri->host,(uint)uVar3);
    }
    else {
      puVar5 = memacpy(uri->host,(uint)uVar3);
      if (puVar5 == (uchar *)0x0) {
LAB_080c563f:
        uVar3 = *(ushort *)&uri->field_0x2e;
        goto LAB_080c51ae;
      }
      iVar4 = idna_to_ascii_lz(puVar5,local_20,0);
      if (iVar4 != 0) {
        mem_free(puVar5);
        goto LAB_080c563f;
      }
      add_to_string(string,local_20[0]);
      free(local_20[0]);
      mem_free(puVar5);
    }
    if (((uri->field_0x36 & 1) != 0) && ((components & 0x20U) != 0)) {
      add_char_to_string(string,']');
    }
  }
  if ((components & 0x60U) != 0) {
    if (uri->field_0x30 == '\0') {
      if (((components & 0x40U) != 0) && (uri->protocol != PROTOCOL_USER)) {
        iVar4 = get_protocol_port(uri->protocol);
        add_char_to_string(string,':');
        add_long_to_string(string,iVar4);
      }
    }
    else {
      add_char_to_string(string,':');
      puVar5 = uri->port;
      uVar13 = (uint)(byte)uri->field_0x30;
      if (assert_failed == 0) {
        if ((string == (string *)0x0) || (puVar5 == (uchar *)0x0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c5783;
        }
        else {
          assert_failed = 0;
        }
        if (uVar13 != 0) {
          iVar4 = uVar13 + string->length;
          pvVar6 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
          if (pvVar6 != (void *)0x0) {
            memcpy(string->source + string->length,puVar5,uVar13);
            string->source[iVar4] = '\0';
            string->length = iVar4;
          }
        }
      }
      else {
LAB_080c5783:
        assert_failed = 0;
      }
    }
  }
  if (((((components & 0x280U) != 0) || (components == URI_HTTP_REFERRER_HOST)) &&
      ((components & 0xffffff5fU) != 0)) &&
     (iVar4 = get_protocol_need_slash_after_host(uri->protocol), iVar4 != 0)) {
    add_char_to_string(string,'/');
  }
  if (((char)components < '\0') && ((*(uint *)&uri->field_0x30 & 0xffff00) != 0)) {
    puVar5 = uri->data;
    uVar13 = (uint)*(ushort *)&uri->field_0x31;
    if (assert_failed == 0) {
      if ((string == (string *)0x0) || (puVar5 == (uchar *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c57af;
      }
      else {
        assert_failed = 0;
      }
      if (uVar13 != 0) {
        iVar4 = uVar13 + string->length;
        pvVar6 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
        if (pvVar6 != (void *)0x0) {
          memcpy(string->source + string->length,puVar5,uVar13);
          string->source[iVar4] = '\0';
          string->length = iVar4;
        }
      }
    }
    else {
LAB_080c57af:
      assert_failed = 0;
    }
  }
  if ((components & 0x3000U) != 0) {
    puVar5 = uri->data;
    if ((assert_failed == 0) &&
       (assert_failed = (uint)components >> 0xd & (uint)(components != URI_FILENAME),
       assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x25a;
      elinks_internal((uchar *)
                      "assertion !wants(URI_FILENAME) || components == URI_FILENAME failed: URI_FILENAME should be used alone %d"
                      ,components);
    }
    if (((components & 0x1000U) != 0) && (*puVar5 != '/')) {
      add_char_to_string(string,'/');
    }
    if ((*(uint *)&uri->field_0x30 & 0xffff00) == 0) {
      return string;
    }
    uVar2 = *puVar5;
    if ((((uVar2 == '\0') || (uVar2 == '#')) || (uVar2 == '\x01')) || (uVar2 == '?')) {
      sVar10 = 0;
    }
    else {
      puVar9 = puVar5;
      do {
        puVar9 = puVar9 + 1;
        if (((components & 0x2000U) != 0) && (uVar2 == '/')) {
          puVar5 = puVar9;
        }
        uVar2 = *puVar9;
        if (((uVar2 == '\0') || (uVar2 == '#')) || (uVar2 == '\x01')) {
          sVar10 = (int)puVar9 - (int)puVar5;
          goto LAB_080c52d0;
        }
      } while (uVar2 != '?');
      sVar10 = (int)puVar9 - (int)puVar5;
    }
LAB_080c52d0:
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
    if (((puVar5 == (uchar *)0x0) || (string == (string *)0x0)) || ((int)sVar10 < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (string *)0x0;
      }
    }
    else {
      assert_failed = 0;
    }
    if (sVar10 != 0) {
      iVar4 = sVar10 + string->length;
      pvVar6 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
      if (pvVar6 == (void *)0x0) {
        return (string *)0x0;
      }
      memcpy(string->source + string->length,puVar5,sVar10);
      string->source[iVar4] = '\0';
      string->length = iVar4;
      return string;
    }
    return string;
  }
  if (((components & 0x4000U) == 0) || ((*(uint *)&uri->field_0x30 & 0xffff00) == 0)) {
    if (((components & 0x100U) != 0) && (*(short *)&uri->field_0x34 != 0)) {
      add_char_to_string(string,'#');
      add_bytes_to_string__(string,uri->fragment,(uint)*(ushort *)&uri->field_0x34);
    }
    if (((components & 0x200U) != 0) && (uri->post != (uchar *)0x0)) {
      add_char_to_string(string,'\x01');
      add_to_string(string,uri->post);
      return string;
    }
    if ((components & 0x400U) == 0) {
      return string;
    }
    puVar5 = uri->post;
    bVar14 = puVar5 == (uchar *)0x0;
    if (bVar14) {
      return string;
    }
    iVar4 = 10;
    puVar9 = puVar5;
    puVar12 = (uchar *)"text/plain";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar14 = *puVar9 == *puVar12;
      puVar9 = puVar9 + (uint)bVar15 * -2 + 1;
      puVar12 = puVar12 + (uint)bVar15 * -2 + 1;
    } while (bVar14);
    if (bVar14) {
      add_to_string(string,(uchar *)" (PLAIN TEXT DATA)");
      return string;
    }
    iVar4 = 0x14;
    puVar9 = (uchar *)"multipart/form-data;";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar14 = *puVar5 == *puVar9;
      puVar5 = puVar5 + (uint)bVar15 * -2 + 1;
      puVar9 = puVar9 + (uint)bVar15 * -2 + 1;
    } while (bVar14);
    if (bVar14) {
      add_to_string(string,(uchar *)" (MULTIPART FORM DATA)");
      return string;
    }
    add_to_string(string,(uchar *)" (POST DATA)");
    return string;
  }
  uVar16 = 0x3f;
  pvVar6 = memchr(uri->data,0x3f,(uint)*(ushort *)&uri->field_0x31);
  if ((assert_failed == 0) && (assert_failed = (int)(components != URI_QUERY), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x271;
    elinks_internal((uchar *)
                    "assertion URI_QUERY == components failed: URI_QUERY should be used alone %d",
                    components);
    uVar16 = components;
  }
  if (pvVar6 == (void *)0x0) {
    return string;
  }
  cVar1 = *(char *)((int)pvVar6 + 1);
  if (((cVar1 == '\0') || (cVar1 == '#')) || (cVar1 == '\x01')) {
    sVar10 = 0;
  }
  else {
    sVar11 = 0;
    do {
      sVar10 = sVar11 + 1;
      cVar1 = *(char *)((int)pvVar6 + sVar11 + 2);
      if ((cVar1 == '\0') || (cVar1 == '#')) break;
      sVar11 = sVar10;
    } while (cVar1 != '\x01');
  }
  if (assert_failed == 0) {
    if ((string == (string *)0x0) || ((int)sVar10 < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]",
                      uVar16);
      if (assert_failed != 0) goto LAB_080c53b3;
    }
    else {
      assert_failed = 0;
    }
    if (sVar10 == 0) {
      return string;
    }
    iVar4 = sVar10 + string->length;
    pvVar8 = mem_align_alloc__(&string->source,string->length,iVar4 + 1,1,0xff);
    if (pvVar8 != (void *)0x0) {
      memcpy(string->source + string->length,(void *)((int)pvVar6 + 1),sVar10);
      string->source[iVar4] = '\0';
      string->length = iVar4;
      return string;
    }
  }
  else {
LAB_080c53b3:
    assert_failed = 0;
  }
  return (string *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_uri_string(uri *uri,uri_component components)

{
  string *psVar1;
  string string;
  
  psVar1 = init_string(&string);
  if ((psVar1 == (string *)0x0) ||
     (psVar1 = add_uri_to_string(&string,uri,components), psVar1 == (string *)0x0)) {
    done_string(&string);
    string.source = (uchar *)0x0;
  }
  return string.source;
}



// WARNING: Unknown calling convention

uri * get_composed_uri(uri *uri,uri_component components)

{
  uchar *string_00;
  uri *puVar1;
  uchar *string;
  
  if (assert_failed == 0) {
    assert_failed = (int)(uri == (uri *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x508;
      elinks_internal((uchar *)"assertion uri failed!");
      if (assert_failed != 0) goto LAB_080c5e7a;
    }
    string_00 = get_uri_string(uri,components);
    if (string_00 != (uchar *)0x0) {
      puVar1 = get_uri(string_00,0);
      mem_free(string_00);
      return puVar1;
    }
  }
  else {
LAB_080c5e7a:
    assert_failed = 0;
  }
  return (uri *)0x0;
}



// WARNING: Unknown calling convention

uri * get_uri(uchar *string,uri_component components)

{
  size_t keylen;
  hash_item *phVar1;
  hash_item *item;
  uri *puVar2;
  uri *uristring;
  uri_errno uVar3;
  uri_cache_entry *entry;
  uri uri;
  
  if ((assert_failed == 0) && (assert_failed = (int)(string == (uchar *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
    errline = 0x626;
    elinks_internal((uchar *)"assertion string failed!");
  }
  if (components != 0) {
    uVar3 = parse_uri(&uri,string);
    if (uVar3 != URI_ERRNO_OK) {
      return (uri *)0x0;
    }
    puVar2 = get_composed_uri(&uri,components);
    return puVar2;
  }
  if ((uri_cache.object.refcount == 0) &&
     (uri_cache.map = init_hash8(), uri_cache.map == (hash *)0x0)) {
    return (uri *)0x0;
  }
  keylen = strlen((char *)string);
  if (assert_failed == 0) {
    assert_failed = (int)((int)keylen < 1 || string == (uchar *)0x0);
    if ((int)keylen < 1 || string == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 0x607;
      elinks_internal((uchar *)"assertion string && length > 0 failed!");
      if (assert_failed != 0) goto LAB_080c5f69;
    }
    phVar1 = get_hash_item(uri_cache.map,string,keylen);
    if (phVar1 == (hash_item *)0x0) {
      puVar2 = (uri *)mem_calloc(1,keylen + 0x40);
      if (puVar2 != (uri *)0x0) {
        uristring = puVar2 + 1;
        memcpy(uristring,string,keylen);
        uVar3 = parse_uri(puVar2,(uchar *)uristring);
        if ((uVar3 == URI_ERRNO_OK) &&
           (phVar1 = add_hash_item(uri_cache.map,(uchar *)uristring,keylen,puVar2),
           phVar1 != (hash_item *)0x0)) {
          uri_cache.object.refcount = uri_cache.object.refcount + 1;
          goto LAB_080c5f29;
        }
        mem_free(puVar2);
      }
    }
    else {
      puVar2 = (uri *)phVar1->value;
      if (puVar2 != (uri *)0x0) {
LAB_080c5f29:
        (puVar2->object).refcount = (puVar2->object).refcount + 1;
        return puVar2;
      }
    }
  }
  else {
LAB_080c5f69:
    assert_failed = 0;
  }
  if (uri_cache.object.refcount != 0) {
    return (uri *)0x0;
  }
  free_hash(&uri_cache.map);
  return (uri *)0x0;
}



// WARNING: Unknown calling convention

uri * get_translated_uri(uchar *uristring,uchar *cwd)

{
  uchar *string;
  uri *puVar1;
  uri *uri;
  
  puVar1 = (uri *)0x0;
  string = translate_url(uristring,cwd);
  if (string != (uchar *)0x0) {
    puVar1 = get_uri(string,0);
    mem_free(string);
  }
  return puVar1;
}



// WARNING: Unknown calling convention

string * add_string_uri_to_string(string *string,uchar *uristring,uri_component components)

{
  uri_errno uVar1;
  string *psVar2;
  uri uri;
  
  uVar1 = parse_uri(&uri,uristring);
  psVar2 = (string *)0x0;
  if (uVar1 == URI_ERRNO_OK) {
    psVar2 = add_uri_to_string(string,&uri,components);
  }
  return psVar2;
}



// WARNING: Unknown calling convention

uchar * get_user_program(terminal *term,uchar *progid,int progidlen)

{
  uint uVar1;
  string *psVar2;
  int iVar3;
  option_elinks *poVar4;
  int newlength;
  size_t newsize;
  int iVar5;
  uint size;
  uint xwin_00;
  int xwin;
  option_elinks *opt;
  uchar *puVar6;
  string name;
  
  xwin_00 = 0;
  if (term != (terminal *)0x0) {
    xwin_00 = term->environment & 2;
  }
  psVar2 = init_string(&name);
  if (psVar2 == (string *)0x0) {
    return (uchar *)0x0;
  }
  add_to_string(&name,(uchar *)"protocol.user.");
  if (assert_failed == 0) {
    if ((progid == (uchar *)0x0) || (progidlen < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080c6168;
    }
    else {
      assert_failed = 0;
    }
    if (progidlen == 0) goto LAB_080c61dd;
    iVar5 = progidlen + name.length;
    uVar1 = name.length + 0xffU & 0xffffff00;
    size = iVar5 + 0x100U & 0xffffff00;
    if (uVar1 < size) {
      puVar6 = (uchar *)mem_realloc(name.source,size);
      if (puVar6 == (uchar *)0x0) goto LAB_080c6175;
      name.source = puVar6;
      memset(puVar6 + uVar1,0,size - uVar1);
    }
    if (name.source != (uchar *)0x0) {
      memcpy(name.source + name.length,progid,progidlen);
      name.source[iVar5] = '\0';
      name.length = iVar5;
    }
  }
  else {
LAB_080c6168:
    assert_failed = 0;
  }
LAB_080c6175:
  iVar5 = progidlen + -1;
  if (-1 < iVar5) {
    puVar6 = name.source + progidlen;
    do {
      while (iVar3 = c_isupper((uint)puVar6[0xd]), iVar3 == 0) {
        puVar6 = puVar6 + -1;
        iVar5 = iVar5 + -1;
        if (iVar5 < 0) goto LAB_080c61dd;
      }
      iVar3 = c_tolower((uint)puVar6[0xd]);
      puVar6[0xd] = (uchar)iVar3;
      puVar6 = puVar6 + -1;
      iVar5 = iVar5 + -1;
    } while (-1 < iVar5);
  }
LAB_080c61dd:
  add_char_to_string(&name,'.');
  puVar6 = get_system_str(xwin_00);
  add_to_string(&name,puVar6);
  poVar4 = get_opt_rec_real(config_options,name.source);
  done_string(&name);
  if (poVar4 == (option_elinks *)0x0) {
    return (uchar *)0x0;
  }
  return (uchar *)(poVar4->value).tree;
}



// WARNING: Unknown calling convention

void user_protocol_handler(session *ses,uri *uri)

{
  ushort uVar1;
  uint uVar2;
  char cVar3;
  undefined2 *__src;
  uchar *prog;
  int iVar4;
  char *pcVar5;
  size_t sVar6;
  string *psVar7;
  int length;
  uint uVar8;
  uchar *puVar9;
  FILE *__s;
  FILE *fp;
  size_t nmemb;
  int iVar10;
  size_t __result;
  int p;
  size_t sVar11;
  uchar *subject;
  uchar *puVar12;
  size_t newsize;
  uint uVar13;
  uchar *protocol;
  uchar *formdata;
  undefined2 *puVar14;
  uchar *url;
  uchar *puVar15;
  bool bVar16;
  byte bVar17;
  uchar *local_38;
  uchar *local_30;
  string string;
  
  bVar17 = 0;
  __src = (undefined2 *)
          get_user_program(ses->tab->term,uri->string,(uint)*(ushort *)&uri->field_0x28);
  if ((__src == (undefined2 *)0x0) || (*(char *)__src == '\0')) {
    puVar9 = memacpy(uri->string,(uint)*(ushort *)&uri->field_0x28);
    if (puVar9 == (uchar *)0x0) {
      puVar9 = msg_text(ses->tab->term,(uchar *)"No program specified for protocol %s.",
                        &DAT_0812e3d8);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"No program",ALIGN_CENTER,puVar9);
      return;
    }
    puVar12 = msg_text(ses->tab->term,(uchar *)"No program specified for protocol %s.",puVar9);
    info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"No program",ALIGN_CENTER,puVar12);
    mem_free(puVar9);
    return;
  }
  if ((uri->data == (uchar *)0x0) || ((*(uint *)&uri->field_0x30 & 0xffff00) == 0)) {
LAB_080c6375:
    local_38 = (uchar *)0x0;
  }
  else {
    puVar9 = get_uri_string(uri,URI_QUERY);
    bVar16 = puVar9 == (uchar *)0x0;
    if (bVar16) goto LAB_080c6375;
    iVar4 = 8;
    puVar12 = puVar9;
    puVar15 = "subject=";
    do {
      if (iVar4 == 0) break;
      iVar4 = iVar4 + -1;
      bVar16 = *puVar12 == *puVar15;
      puVar12 = puVar12 + (uint)bVar17 * -2 + 1;
      puVar15 = puVar15 + (uint)bVar17 * -2 + 1;
    } while (bVar16);
    if (bVar16) {
      puVar12 = puVar9 + 8;
LAB_080c694b:
      if ((*puVar12 == '\0') || (*puVar12 == '&')) {
        iVar4 = 0;
      }
      else {
        iVar4 = 0;
        do {
          iVar4 = iVar4 + 1;
          if (puVar12[iVar4] == '\0') break;
        } while (puVar12[iVar4] != '&');
      }
      local_38 = memacpy(puVar12,iVar4);
      mem_free(puVar9);
      if (local_38 != (uchar *)0x0) {
        decode_uri(local_38);
      }
    }
    else {
      pcVar5 = strstr((char *)puVar9,"&subject=");
      puVar12 = (uchar *)(pcVar5 + 9);
      if (pcVar5 != (char *)0x0) goto LAB_080c694b;
      mem_free(puVar9);
      local_38 = (uchar *)0x0;
    }
  }
  local_30 = get_tempdir_filename((uchar *)"elinks-XXXXXX");
  if (local_30 != (uchar *)0x0) {
    iVar4 = safe_mkstemp(local_30);
    if (iVar4 < 0) {
      mem_free(local_30);
      local_30 = (uchar *)0x0;
    }
    else {
      puVar9 = uri->post;
      if (puVar9 != (uchar *)0x0) {
        pcVar5 = strchr((char *)puVar9,10);
        if (pcVar5 != (char *)0x0) {
          puVar9 = (uchar *)(pcVar5 + 1);
        }
        sVar6 = strlen((char *)puVar9);
        if (sVar6 != 0) {
          __s = fdopen(iVar4,"w");
          if (__s != (FILE *)0x0) {
            sVar6 = fwrite(puVar9,sVar6,1,__s);
            if (sVar6 == 1) {
              iVar10 = fclose(__s);
              if (iVar10 == 0) goto LAB_080c63d6;
            }
            else {
              fclose(__s);
            }
          }
          unlink((char *)local_30);
          mem_free(local_30);
          close(iVar4);
          local_30 = (uchar *)0x0;
        }
      }
    }
  }
LAB_080c63d6:
  psVar7 = init_string(&string);
  puVar9 = (uchar *)0x0;
  if (psVar7 != (string *)0x0) {
    while (puVar9 = string.source, *(char *)__src != '\0') {
      sVar11 = 0;
      sVar6 = 0;
      puVar14 = __src;
      if (*(char *)__src != '%') {
        do {
          sVar11 = sVar11 + 1;
          puVar14 = (undefined2 *)(sVar11 + (int)__src);
          sVar6 = sVar11;
          if (*(char *)((int)__src + sVar11) == '%') break;
        } while (*(char *)((int)__src + sVar11) != '\0');
      }
      if (assert_failed == 0) {
        if ((int)sVar6 < 0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080c642a;
        }
        else {
          assert_failed = 0;
        }
        if (sVar6 != 0) {
          iVar4 = sVar6 + string.length;
          uVar2 = string.length + 0xffU >> 8;
          uVar8 = string.length + 0xffU & 0xffffff00;
          uVar13 = iVar4 + 0x100U & 0xffffff00;
          if (uVar8 <= uVar13 && uVar13 + uVar2 * -0x100 != 0) {
            puVar9 = (uchar *)mem_realloc(string.source,uVar13);
            if (puVar9 == (uchar *)0x0) goto LAB_080c6438;
            string.source = puVar9;
            memset(puVar9 + uVar8,0,uVar13 + uVar2 * -0x100);
          }
          if (string.source != (uchar *)0x0) {
            memcpy(string.source + string.length,__src,sVar6);
            string.source[iVar4] = '\0';
            string.length = iVar4;
          }
        }
      }
      else {
LAB_080c642a:
        assert_failed = 0;
      }
LAB_080c6438:
      iVar4 = string.length;
      puVar9 = string.source;
      if (*(char *)puVar14 != '%') break;
      pcVar5 = (char *)((int)puVar14 + 1);
      switch(*(char *)((int)puVar14 + 1)) {
      case 'd':
        if ((*(uint *)&uri->field_0x30 & 0xffff00) != 0) {
          uVar1 = *(ushort *)&uri->field_0x31;
          puVar9 = uri->data;
LAB_080c6639:
          add_shell_safe_to_string(&string,puVar9,(uint)uVar1);
          cVar3 = *pcVar5;
          break;
        }
        goto LAB_080c6606;
      default:
        if (assert_failed == 0) {
          assert_failed = 0;
          uVar13 = string.length + 0x102U & 0xffffff00;
          uVar2 = string.length + 0xffU >> 8;
          uVar8 = string.length + 0xffU & 0xffffff00;
          iVar10 = string.length + 2;
          if (uVar13 < uVar8 || uVar13 + uVar2 * -0x100 == 0) {
LAB_080c6487:
            if (string.source != (uchar *)0x0) {
              *(undefined2 *)(string.source + string.length) = *puVar14;
              string.source[iVar4 + 2] = '\0';
              string.length = iVar10;
            }
          }
          else {
            puVar9 = (uchar *)mem_realloc(string.source,uVar13);
            if (puVar9 != (uchar *)0x0) {
              string.source = puVar9;
              memset(puVar9 + uVar8,0,uVar13 + uVar2 * -0x100);
              goto LAB_080c6487;
            }
          }
          cVar3 = *pcVar5;
        }
        else {
          assert_failed = 0;
          cVar3 = *pcVar5;
        }
        break;
      case 'f':
        if (local_30 == (uchar *)0x0) goto LAB_080c6606;
        add_to_string(&string,local_30);
        cVar3 = *pcVar5;
        break;
      case 'h':
        if ((*(short *)&uri->field_0x2a == 0) || (*(ushort *)&uri->field_0x2e == 0)) {
          puVar9 = uri->host;
          if (puVar9 != (uchar *)0x0) {
            uVar1 = *(ushort *)&uri->field_0x2e;
            goto LAB_080c6639;
          }
          goto LAB_080c6606;
        }
        add_shell_safe_to_string
                  (&string,uri->user,
                   (int)(uri->host + ((uint)*(ushort *)&uri->field_0x2e - (int)uri->user)));
        cVar3 = *pcVar5;
        break;
      case 'p':
        if (uri->field_0x30 == 0) goto LAB_080c6606;
        add_shell_safe_to_string(&string,uri->port,(uint)(byte)uri->field_0x30);
        cVar3 = *pcVar5;
        break;
      case 's':
        if (local_38 == (uchar *)0x0) goto LAB_080c6606;
        sVar6 = strlen((char *)local_38);
        add_shell_safe_to_string(&string,local_38,sVar6);
        cVar3 = *pcVar5;
        break;
      case 'u':
        puVar9 = uri->string;
        if (uri->post == (uchar *)0x0) {
          length = strlen((char *)puVar9);
        }
        else {
          length = (int)uri->post + (-1 - (int)puVar9);
        }
        add_shell_safe_to_string(&string,puVar9,length);
        cVar3 = *pcVar5;
      }
      puVar9 = string.source;
      if (cVar3 == '\0') break;
LAB_080c6606:
      __src = puVar14 + 1;
    }
  }
  if (local_38 != (uchar *)0x0) {
    mem_free(local_38);
  }
  if (puVar9 == (uchar *)0x0) {
    if (local_30 == (uchar *)0x0) {
      return;
    }
    unlink((char *)local_30);
  }
  else {
    if (local_30 == (uchar *)0x0) {
      exec_on_terminal(ses->tab->term,puVar9,"",TERM_EXEC_FG);
      mem_free(puVar9);
      return;
    }
    exec_on_terminal(ses->tab->term,puVar9,local_30,TERM_EXEC_FG);
    mem_free(puVar9);
  }
  mem_free(local_30);
  return;
}



// WARNING: Unknown calling convention

auth_entry * get_invalid_auth_entry(void)

{
  auth_entry *entry;
  auth_entry *paVar1;
  
  paVar1 = (auth_entry *)auth_entry_list.next;
  if ((list_head_elinks *)auth_entry_list.next != &auth_entry_list) {
    do {
      if ((paVar1->field_0x70 & 2) == 0) {
        return paVar1;
      }
      paVar1 = paVar1->next;
    } while (paVar1 != (auth_entry *)&auth_entry_list);
  }
  return (auth_entry *)0x0;
}



// WARNING: Unknown calling convention

void done_auth_entry(auth_entry *entry)

{
  void *p;
  void *p_1;
  void *p_2;
  
  if (entry->box_item != (listbox_item *)0x0) {
    done_listbox_item(&auth_browser,entry->box_item);
  }
  done_uri(entry->uri);
  if (entry->realm != (uchar *)0x0) {
    mem_free(entry->realm);
  }
  if (entry->nonce != (uchar *)0x0) {
    mem_free(entry->nonce);
  }
  if (entry->opaque != (uchar *)0x0) {
    mem_free(entry->opaque);
  }
  mem_free(entry);
  return;
}



// WARNING: Unknown calling convention

void del_auth_entry(auth_entry *entry)

{
  entry->next->prev = entry->prev;
  entry->prev->next = entry->next;
  done_auth_entry(entry);
  return;
}



// WARNING: Unknown calling convention

void free_auth(void)

{
  list_head_elinks *plVar1;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  xlist_head *head;
  list_head_elinks *plVar4;
  xlist_head *next;
  
  if ((list_head_elinks *)auth_entry_list.next != &auth_entry_list) {
    do {
      del_auth_entry((auth_entry *)auth_entry_list.next);
    } while ((list_head_elinks *)auth_entry_list.next != &auth_entry_list);
  }
  plVar4 = (list_head_elinks *)questions_queue.next;
  plVar1 = (list_head_elinks *)questions_queue.prev;
  if ((list_head_elinks *)questions_queue.next != &questions_queue) {
    do {
      plVar4 = (list_head_elinks *)plVar4->next;
    } while (plVar4 != &questions_queue);
  }
  for (; plVar1 != plVar4; plVar1 = (list_head_elinks *)plVar1->prev) {
  }
                    // WARNING: Load size is inaccurate
  plVar3 = *questions_queue.next;
  plVar1 = (list_head_elinks *)questions_queue.next;
  while (plVar2 = plVar3, plVar1 != plVar4) {
    plVar2->prev = plVar1->prev;
    *(void **)plVar1->prev = plVar1->next;
    mem_free(plVar1);
    plVar3 = (list_head_elinks *)plVar2->next;
    plVar1 = plVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void done_auth(module *xxx)

{
  free_auth();
  return;
}



// WARNING: Unknown calling convention

auth_entry * find_auth_entry(uri *uri,uchar *realm)

{
  auth_entry **ppaVar1;
  int iVar2;
  auth_entry *entry;
  auth_entry *paVar3;
  auth_entry *local_24;
  
  local_24 = (auth_entry *)0x0;
  paVar3 = (auth_entry *)auth_entry_list.next;
  if ((list_head_elinks *)auth_entry_list.next != &auth_entry_list) {
    do {
      iVar2 = compare_uri(paVar3->uri,uri,URI_HTTP_AUTH);
      if ((iVar2 != 0) &&
         ((realm == (uchar *)0x0 ||
          ((local_24 = paVar3, paVar3->realm != (uchar *)0x0 &&
           (iVar2 = strcmp((char *)paVar3->realm,(char *)realm), iVar2 == 0)))))) {
        return paVar3;
      }
      ppaVar1 = &paVar3->next;
      paVar3 = *ppaVar1;
    } while (*ppaVar1 != (auth_entry *)&auth_entry_list);
  }
  return local_24;
}



// WARNING: Unknown calling convention

void set_auth_user(auth_entry *entry,uri *uri)

{
  uint __n;
  int userlen;
  
  __n = (uint)*(ushort *)&uri->field_0x2a;
  if (__n < 0x27) {
    if (__n == 0) goto LAB_080c6c97;
  }
  else {
    __n = 0x27;
  }
  memcpy(entry->user,uri->user,__n);
LAB_080c6c97:
  entry->user[__n] = '\0';
  return;
}



// WARNING: Unknown calling convention

void set_auth_password(auth_entry *entry,uri *uri)

{
  uint __n;
  int passwordlen;
  
  __n = (uint)*(ushort *)&uri->field_0x2c;
  if (__n < 0x27) {
    if (__n == 0) goto LAB_080c6ce7;
  }
  else {
    __n = 0x27;
  }
  memcpy(entry->password,uri->password,__n);
LAB_080c6ce7:
  entry->password[__n] = '\0';
  return;
}



// WARNING: Unknown calling convention

auth_entry * add_auth_entry(uri *uri,uchar *realm,uchar *nonce,uchar *opaque,uint digest)

{
  byte bVar1;
  auth_entry *entry_00;
  auth_entry *entry;
  uchar *puVar2;
  int iVar3;
  listbox_item *plVar4;
  bool bVar5;
  
  entry_00 = find_auth_entry(uri,realm);
  if (entry_00 == (auth_entry *)0x0) {
    entry_00 = (auth_entry *)mem_calloc(1,0x74);
    if (entry_00 == (auth_entry *)0x0) {
      return (auth_entry *)0x0;
    }
    (uri->object).refcount = (uri->object).refcount + 1;
    entry_00->uri = uri;
    if (realm != (uchar *)0x0) {
      puVar2 = stracpy(realm);
      entry_00->realm = puVar2;
      if (puVar2 == (uchar *)0x0) {
        mem_free(entry_00);
        return (auth_entry *)0x0;
      }
    }
    set_auth_user(entry_00,uri);
    set_auth_password(entry_00,uri);
    plVar4 = add_listbox_item(&auth_browser,(listbox_item *)0x0,BI_LEAF,entry_00,1);
    entry_00->box_item = plVar4;
    if (plVar4 == (listbox_item *)0x0) {
      done_auth_entry(entry_00);
      return (auth_entry *)0x0;
    }
    entry_00->prev = (auth_entry *)&auth_entry_list;
    entry_00->next = (auth_entry *)auth_entry_list.next;
    auth_entry_list.next = entry_00;
    entry_00->next->prev = entry_00;
    if (nonce != (uchar *)0x0) {
      puVar2 = stracpy(nonce);
      entry_00->nonce = puVar2;
      if (puVar2 == (uchar *)0x0) goto LAB_080c704a;
    }
    if (opaque != (uchar *)0x0) {
      puVar2 = stracpy(opaque);
      entry_00->opaque = puVar2;
      if (puVar2 == (uchar *)0x0) {
LAB_080c704a:
        del_auth_entry(entry_00);
        return (auth_entry *)0x0;
      }
    }
    entry_00->field_0x70 = entry_00->field_0x70 & 0xfb | (byte)((digest & 1) << 2);
    goto LAB_080c6e3d;
  }
  bVar1 = entry_00->field_0x70;
  if ((bVar1 & 1) != 0) {
    return (auth_entry *)0x0;
  }
  bVar5 = realm != (uchar *)0x0;
  puVar2 = entry_00->realm;
  if (bVar5 == (puVar2 != (uchar *)0x0)) {
    if (((bVar5) && (puVar2 != (uchar *)0x0)) &&
       (iVar3 = strcmp((char *)realm,(char *)puVar2), iVar3 != 0)) {
      bVar1 = entry_00->field_0x70;
      puVar2 = entry_00->realm;
      goto LAB_080c6d4a;
    }
  }
  else {
LAB_080c6d4a:
    entry_00->field_0x70 = bVar1 & 0xfd;
    if (puVar2 != (uchar *)0x0) {
      mem_free(puVar2);
    }
    entry_00->realm = (uchar *)0x0;
    if (bVar5) {
      puVar2 = stracpy(realm);
      entry_00->realm = puVar2;
      if (puVar2 == (uchar *)0x0) {
LAB_080c7073:
        del_auth_entry(entry_00);
        return (auth_entry *)0x0;
      }
      if (nonce != (uchar *)0x0) {
        if (entry_00->nonce != (uchar *)0x0) {
          mem_free(entry_00->nonce);
        }
        puVar2 = stracpy(nonce);
        entry_00->nonce = puVar2;
        if (puVar2 == (uchar *)0x0) goto LAB_080c7073;
      }
      if (opaque != (uchar *)0x0) {
        if (entry_00->opaque != (uchar *)0x0) {
          mem_free(entry_00->opaque);
        }
        puVar2 = stracpy(opaque);
        entry_00->opaque = puVar2;
        if (puVar2 == (uchar *)0x0) {
          del_auth_entry(entry_00);
          return (auth_entry *)0x0;
        }
      }
      entry_00->field_0x70 = entry_00->field_0x70 & 0xfb | (byte)((digest & 1) << 2);
    }
  }
  if (((entry_00->user[0] == '\0') || (uri->user == (uchar *)0x0)) ||
     (*(short *)&uri->field_0x2a == 0)) {
LAB_080c6e09:
    entry_00->field_0x70 = entry_00->field_0x70 & 0xfd;
    set_auth_user(entry_00,uri);
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
    errline = 0xb9;
    iVar3 = elinks_strlcmp(entry_00->user,0xffffffff,uri->user,(uint)*(ushort *)&uri->field_0x2a);
    if (iVar3 != 0) goto LAB_080c6e09;
  }
  if (((entry_00->password[0] != '\0') && (uri->password != (uchar *)0x0)) &&
     (*(short *)&uri->field_0x2c != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
    errline = 0xc0;
    iVar3 = elinks_strlcmp(entry_00->password,0xffffffff,uri->password,
                           (uint)*(ushort *)&uri->field_0x2c);
    if (iVar3 == 0) goto LAB_080c6e3d;
  }
  entry_00->field_0x70 = entry_00->field_0x70 & 0xfd;
  set_auth_password(entry_00,uri);
LAB_080c6e3d:
  if (((entry_00->field_0x70 & 2) == 0) && (entry_00->realm != (uchar *)0x0)) {
    add_questions_entry(do_auth_dialog,entry_00);
    return entry_00;
  }
  return entry_00;
}



// WARNING: Unknown calling convention

auth_entry * find_auth(uri *uri)

{
  uchar *puVar1;
  auth_entry *entry_00;
  int iVar2;
  auth_entry *entry;
  
  entry_00 = find_auth_entry(uri,(uchar *)0x0);
  if ((*(short *)&uri->field_0x2a != 0) || (*(short *)&uri->field_0x2c != 0)) {
    if (entry_00 != (auth_entry *)0x0) {
      if (*(short *)&uri->field_0x2a == 0) {
        puVar1 = uri->password;
      }
      else {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
        errline = 0xf9;
        iVar2 = elinks_strlcmp(entry_00->user,0xffffffff,uri->user,(uint)*(ushort *)&uri->field_0x2a
                              );
        if (iVar2 != 0) goto LAB_080c7120;
        puVar1 = uri->password;
      }
      if (puVar1 == (uchar *)0x0) goto LAB_080c71a0;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
      errline = 0xfa;
      iVar2 = elinks_strlcmp(entry_00->password,0xffffffff,uri->password,
                             (uint)*(ushort *)&uri->field_0x2c);
      if (iVar2 == 0) goto LAB_080c71a0;
    }
LAB_080c7120:
    entry_00 = add_auth_entry(uri,(uchar *)0x0,(uchar *)0x0,(uchar *)0x0,0);
  }
  if (entry_00 == (auth_entry *)0x0) {
    return (auth_entry *)0x0;
  }
LAB_080c71a0:
  if ((entry_00->field_0x70 & 1) == 0) {
    if ((entry_00->user[0] != '\0') || (entry_00->password[0] != '\0')) {
      return entry_00;
    }
    del_auth_entry(entry_00);
  }
  return (auth_entry *)0x0;
}



// WARNING: Unknown calling convention

void lock_auth_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + 1;
  return;
}



// WARNING: Unknown calling convention

void unlock_auth_entry(listbox_item *item)

{
  int *piVar1;
  
  piVar1 = (int *)((int)item->udata + 8);
  *piVar1 = *piVar1 + -1;
  return;
}



// WARNING: Unknown calling convention

int is_auth_entry_used(listbox_item *item)

{
  return (uint)(*(int *)((int)item->udata + 8) != 0);
}



// WARNING: Unknown calling convention

listbox_item * get_auth_entry_root(listbox_item *box_item)

{
  return (listbox_item *)0x0;
}



// WARNING: Unknown calling convention

int can_delete_auth_entry(listbox_item *item)

{
  return 1;
}



// WARNING: Unknown calling convention

void delete_auth_entry(listbox_item *item,int last)

{
  auth_entry *entry;
  auth_entry *auth_entry;
  
  entry = (auth_entry *)item->udata;
  if ((assert_failed == 0) &&
     (assert_failed = (int)((entry->object).refcount != 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 0xd4;
    elinks_internal((uchar *)"assertion !is_object_used(auth_entry) failed!");
    del_auth_entry(entry);
    return;
  }
  del_auth_entry(entry);
  return;
}



// WARNING: Unknown calling convention

void auth_cancel(void *data)

{
  *(byte *)((int)data + 0x70) = *(byte *)((int)data + 0x70) & 0xfe;
  del_auth_entry((auth_entry *)data);
  return;
}



// WARNING: Unknown calling convention

uri * get_auth_entry_uri(listbox_item *item)

{
  uri *puVar1;
  
  puVar1 = get_composed_uri(*(uri **)((int)item->udata + 0xc),URI_HTTP_AUTH);
  return puVar1;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



uchar * __regparm3 _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_auth_entry_info(listbox_item *item,terminal *term)

{
  void *pvVar1;
  string *psVar2;
  uchar *puVar3;
  size_t length;
  uchar *puVar4;
  string info;
  
  pvVar1 = item->udata;
  if (item->type != BI_FOLDER) {
    psVar2 = init_string(&info);
    if (psVar2 != (string *)0x0) {
      puVar3 = _("URL",term);
      add_format_to_string(&info,"%s: ",puVar3);
      add_uri_to_string(&info,*(uri **)((int)pvVar1 + 0xc),URI_HTTP_AUTH);
      puVar3 = _((uchar *)"Realm",term);
      add_format_to_string(&info,"\n%s: ",puVar3);
      puVar3 = *(uchar **)((int)pvVar1 + 0x10);
      if (puVar3 == (uchar *)0x0) {
        puVar3 = _("none",term);
        add_to_string(&info,puVar3);
      }
      else {
        length = strlen((char *)puVar3);
        if ((int)length < 0x200) {
          add_bytes_to_string__(&info,puVar3,length);
        }
        else {
          add_bytes_to_string__(&info,puVar3,0x200);
          add_to_string(&info,"...");
        }
      }
      if ((*(byte *)((int)pvVar1 + 0x70) & 2) == 0) {
        puVar3 = _((uchar *)"invalid",term);
      }
      else {
        puVar3 = _("valid",term);
      }
      puVar4 = _((uchar *)"State",term);
      add_format_to_string(&info,(uchar *)"\n%s: %s\n",puVar4,puVar3);
      return info.source;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_auth_entry_text(listbox_item *item,terminal *term)

{
  uchar *puVar1;
  
  puVar1 = get_uri_string(*(uri **)((int)item->udata + 0xc),URI_HTTP_AUTH);
  return puVar1;
}



// WARNING: Unknown calling convention

void auth_manager(session *ses)

{
  hierbox_browser(&auth_browser,ses);
  return;
}



// WARNING: Unknown calling convention

void auth_ok(void *data)

{
  byte bVar1;
  session *ses_00;
  location *plVar2;
  int iVar3;
  uri *puVar4;
  int iVar5;
  auth_entry *entry;
  uri *uri;
  session *ses;
  bool bVar6;
  
  bVar6 = true;
  iVar3 = *(int *)((int)data + 8);
  ses_00 = *(session **)((int)data + 4);
  bVar1 = *(byte *)(iVar3 + 0x70);
  *(byte *)(iVar3 + 0x70) = bVar1 & 0xfe;
  if (*(char *)(iVar3 + 0x20) == '\0') {
    bVar6 = *(char *)(iVar3 + 0x48) != '\0';
  }
  *(byte *)(iVar3 + 0x70) = bVar1 & 0xfc | bVar6 * '\x02';
  if (((bVar6 * '\x02' & 2U) == 0) ||
     (plVar2 = (ses_00->history).current, plVar2 == (location *)0x0)) goto LAB_080c7740;
  puVar4 = (plVar2->vs).uri;
  if (*(short *)&puVar4->field_0x2a == 0) {
LAB_080c76af:
    if (puVar4->password == (uchar *)0x0) goto LAB_080c7740;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 0x2e;
    iVar3 = elinks_strlcmp((uchar *)(iVar3 + 0x48),0xffffffff,puVar4->password,
                           (uint)*(ushort *)&puVar4->field_0x2c);
    if (iVar3 == 0) goto LAB_080c7740;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 0x2d;
    iVar5 = elinks_strlcmp((uchar *)(iVar3 + 0x20),0xffffffff,puVar4->user,
                           (uint)*(ushort *)&puVar4->field_0x2a);
    if (iVar5 == 0) goto LAB_080c76af;
  }
  puVar4 = get_composed_uri(puVar4,0xffff82b3);
  if (puVar4 != (uri *)0x0) {
    goto_uri_frame(ses_00,puVar4,(uchar *)0x0,CACHE_MODE_INCREMENT);
    done_uri(puVar4);
    return;
  }
LAB_080c7740:
  reload(ses_00,CACHE_MODE_INCREMENT);
  return;
}



// WARNING: Unknown calling convention

void do_auth_dialog(session *ses,void *data)

{
  int iVar1;
  terminal *term_00;
  uchar *puVar2;
  auth_entry *done_data;
  auth_entry *a;
  dialog_data *dlg_data;
  uchar *puVar3;
  int cp_index;
  int new_charset;
  uchar *puVar4;
  uint __n;
  dialog *dlg;
  memory_list *ml;
  dialog_data *dlg_data_00;
  uchar *text;
  terminal *term;
  int in_GS_OFFSET;
  uchar sticker [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  term_00 = ses->tab->term;
  done_data = get_invalid_auth_entry();
  if (((done_data != (auth_entry *)0x0) && ((done_data->field_0x70 & 1) == 0)) &&
     (puVar3 = get_uri_string(done_data->uri,URI_HTTP_AUTH), puVar3 != (uchar *)0x0)) {
    puVar2 = done_data->realm;
    if ((term_00 != (terminal *)0x0) &&
       (cp_index = get_terminal_codepage(term_00), cp_index != current_charset)) {
      puVar4 = get_cp_mime_name(cp_index);
      bind_textdomain_codeset("elinks",puVar4);
      current_charset = cp_index;
    }
    puVar4 = gettext((uchar *)"Authentication required for %s at %s");
    __n = __snprintf_chk(sticker,0x400,1,0x400,puVar4,puVar2,puVar3);
    mem_free(puVar3);
    if ((__n < 0x401) && (dlg = (dialog *)mem_calloc(1,__n + 0x115), dlg != (dialog *)0x0)) {
      done_data->field_0x70 = done_data->field_0x70 | 1;
      puVar3 = _((uchar *)"Authentication required",term_00);
      dlg->layouter = generic_dialog_layouter;
      dlg->title = puVar3;
      memcpy(&dlg[3].abort,sticker,__n);
      dlg->udata = ses;
      dlg->udata2 = done_data;
      add_dlg_text(dlg,(uchar *)&dlg[3].abort,ALIGN_LEFT,0);
      puVar3 = _("Login",term_00);
      add_dlg_field_do(dlg,WIDGET_FIELD,puVar3,0,0,(widget_handler_T *)0x0,0x28,done_data->user,
                       (input_history *)0x0,INPFIELD_FLOAT);
      puVar3 = _((uchar *)"Password",term_00);
      add_dlg_field_do(dlg,WIDGET_FIELD_PASS,puVar3,0,0,(widget_handler_T *)0x0,0x28,
                       done_data->password,(input_history *)0x0,INPFIELD_FLOAT);
      puVar3 = _("~OK",term_00);
      add_dlg_button_do(dlg,puVar3,1,ok_dialog,(void *)0x0,auth_ok,dlg);
      puVar3 = _((uchar *)"~Cancel",term_00);
      add_dlg_button_do(dlg,puVar3,2,ok_dialog,(void *)0x0,auth_cancel,done_data);
      if ((assert_failed == 0) &&
         (assert_failed = (int)(dlg->number_of_widgets != 5), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
        errline = 0x76;
        elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
      }
      ml = getml(dlg,0);
      dlg_data_00 = do_dialog(term_00,dlg,ml);
      if (((dlg_data_00 != (dialog_data *)0x0) && (done_data->user[0] != '\0')) &&
         (done_data->password[0] == '\0')) {
        select_widget_by_id(dlg_data_00,1);
      }
    }
  }
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention
// Local variable i:int[EAX:4] conflicts with parameter, skipped.

void convert_to_md5_digest_hex_T(uchar *bin,uchar *hex)

{
  byte bVar1;
  uchar uVar2;
  int iVar3;
  
  iVar3 = 0;
  do {
    bVar1 = bin[iVar3] >> 4;
    uVar2 = bVar1 + 0x57;
    if (bVar1 < 10) {
      uVar2 = bVar1 + 0x30;
    }
    hex[iVar3 * 2] = uVar2;
    bVar1 = bin[iVar3] & 0xf;
    uVar2 = bVar1 + 0x57;
    if (bVar1 < 10) {
      uVar2 = bVar1 + 0x30;
    }
    hex[iVar3 * 2 + 1] = uVar2;
    iVar3 = iVar3 + 1;
  } while (iVar3 != 0x10);
  return;
}



// WARNING: Unknown calling convention

uchar * get_http_auth_digest_response(auth_entry *entry,uri *uri)

{
  int iVar1;
  int iVar2;
  ushort uVar3;
  int iVar4;
  string *psVar5;
  uint uVar6;
  uint uVar7;
  size_t sVar8;
  undefined4 *puVar9;
  uint uVar10;
  uchar *puVar11;
  uchar *puVar12;
  size_t newsize;
  size_t oldsize;
  size_t oldsize_1;
  uint size;
  uchar *puVar13;
  uchar *puVar14;
  size_t newsize_1;
  size_t newsize_2;
  int in_GS_OFFSET;
  bool bVar15;
  string string;
  int local_174;
  MD5_CTX MD5Ctx_1;
  MD5_CTX MD5Ctx;
  md5_digest_hex_T Ha2_hex;
  md5_digest_hex_T ha1;
  md5_digest_hex_T response;
  md5_digest_hex_T cnonce;
  md5_digest_bin_T skey;
  md5_digest_bin_T md5;
  
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  psVar5 = init_string(&string);
  puVar11 = (uchar *)0x0;
  if (psVar5 == (string *)0x0) goto LAB_080c81f6;
  uVar6 = time((time_t *)0x0);
  srand(uVar6);
  local_174 = rand();
  digest_md5((uchar *)&local_174,4,md5);
  convert_to_md5_digest_hex_T(md5,cnonce);
  init_md5(&MD5Ctx_1);
  puVar11 = entry->user;
  puVar12 = puVar11;
  do {
    puVar14 = puVar12;
    uVar7 = *(uint *)puVar14 + 0xfefefeff & ~*(uint *)puVar14;
    uVar6 = uVar7 & 0x80808080;
    puVar12 = puVar14 + 4;
  } while (uVar6 == 0);
  bVar15 = (uVar7 & 0x8080) == 0;
  if (bVar15) {
    uVar6 = uVar6 >> 0x10;
  }
  if (bVar15) {
    puVar12 = puVar14 + 6;
  }
  update_md5(&MD5Ctx_1,puVar11,
             (ulong)(puVar12 + ((-3 - (uint)CARRY1((byte)uVar6,(byte)uVar6)) - (int)puVar11)));
  update_md5(&MD5Ctx_1,":",1);
  puVar12 = entry->realm;
  sVar8 = strlen((char *)puVar12);
  update_md5(&MD5Ctx_1,puVar12,sVar8);
  update_md5(&MD5Ctx_1,":",1);
  puVar12 = entry->password;
  puVar14 = puVar12;
  do {
    puVar13 = puVar14;
    uVar7 = *(uint *)puVar13 + 0xfefefeff & ~*(uint *)puVar13;
    uVar6 = uVar7 & 0x80808080;
    puVar14 = puVar13 + 4;
  } while (uVar6 == 0);
  bVar15 = (uVar7 & 0x8080) == 0;
  if (bVar15) {
    uVar6 = uVar6 >> 0x10;
  }
  if (bVar15) {
    puVar14 = puVar13 + 6;
  }
  update_md5(&MD5Ctx_1,puVar12,
             (ulong)(puVar14 + ((-3 - (uint)CARRY1((byte)uVar6,(byte)uVar6)) - (int)puVar12)));
  done_md5(&MD5Ctx_1,skey);
  convert_to_md5_digest_hex_T(skey,ha1);
  init_md5(&MD5Ctx_1);
  update_md5(&MD5Ctx_1,"GET",3);
  update_md5(&MD5Ctx_1,":/",2);
  update_md5(&MD5Ctx_1,uri->data,(uint)*(ushort *)&uri->field_0x31);
  done_md5(&MD5Ctx_1,skey);
  convert_to_md5_digest_hex_T(skey,Ha2_hex);
  init_md5(&MD5Ctx);
  update_md5(&MD5Ctx,ha1,0x20);
  update_md5(&MD5Ctx,":",1);
  puVar12 = entry->nonce;
  if (puVar12 != (uchar *)0x0) {
    sVar8 = strlen((char *)puVar12);
    update_md5(&MD5Ctx,puVar12,sVar8);
  }
  update_md5(&MD5Ctx,":",1);
  update_md5(&MD5Ctx,(uchar *)"00000001",8);
  update_md5(&MD5Ctx,":",1);
  update_md5(&MD5Ctx,cnonce,0x20);
  update_md5(&MD5Ctx,":",1);
  update_md5(&MD5Ctx,"auth",4);
  update_md5(&MD5Ctx,":",1);
  update_md5(&MD5Ctx,Ha2_hex,0x20);
  done_md5(&MD5Ctx,md5);
  convert_to_md5_digest_hex_T(md5,response);
  add_to_string(&string,(uchar *)"username=\"");
  add_to_string(&string,puVar11);
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"realm=\"");
  if (entry->realm != (uchar *)0x0) {
    add_to_string(&string,entry->realm);
  }
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"nonce=\"");
  if (entry->nonce != (uchar *)0x0) {
    add_to_string(&string,entry->nonce);
  }
  add_to_string(&string,"\", ");
  add_to_string(&string,"uri=\"/");
  uVar3 = *(ushort *)&uri->field_0x31;
  puVar11 = uri->data;
  if (assert_failed == 0) {
    if (puVar11 == (uchar *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080c8024;
    }
    else {
      assert_failed = 0;
    }
    uVar6 = (uint)uVar3;
    if (uVar6 != 0) {
      iVar2 = uVar6 + string.length;
      uVar7 = string.length + 0xffU >> 8;
      uVar10 = string.length + 0xffU & 0xffffff00;
      size = iVar2 + 0x100U & 0xffffff00;
      if (uVar10 <= size && size + uVar7 * -0x100 != 0) {
        puVar12 = (uchar *)mem_realloc(string.source,size);
        if (puVar12 == (uchar *)0x0) goto LAB_080c8030;
        string.source = puVar12;
        memset(puVar12 + uVar10,0,size + uVar7 * -0x100);
      }
      if (string.source != (uchar *)0x0) {
        memcpy(string.source + string.length,puVar11,uVar6);
        string.source[iVar2] = '\0';
        string.length = iVar2;
      }
    }
  }
  else {
LAB_080c8024:
    assert_failed = 0;
  }
LAB_080c8030:
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"qop=auth, nc=00000001, ");
  add_to_string(&string,"cnonce=\"");
  iVar2 = string.length;
  if (assert_failed == 0) {
    assert_failed = 0;
    iVar1 = string.length + 0x20;
    uVar10 = string.length + 0x120U & 0xffffff00;
    uVar6 = string.length + 0xffU >> 8;
    uVar7 = string.length + 0xffU & 0xffffff00;
    if (uVar7 <= uVar10 && uVar10 + uVar6 * -0x100 != 0) {
      puVar11 = (uchar *)mem_realloc(string.source,uVar10);
      if (puVar11 == (uchar *)0x0) goto LAB_080c80f5;
      string.source = puVar11;
      memset(puVar11 + uVar7,0,uVar10 + uVar6 * -0x100);
    }
    if (string.source != (uchar *)0x0) {
      puVar9 = (undefined4 *)(string.source + string.length);
      *puVar9 = cnonce._0_4_;
      puVar9[1] = cnonce._4_4_;
      puVar9[2] = cnonce._8_4_;
      puVar9[3] = cnonce._12_4_;
      puVar9[4] = cnonce._16_4_;
      puVar9[5] = cnonce._20_4_;
      puVar9[6] = cnonce._24_4_;
      puVar9[7] = cnonce._28_4_;
      string.source[iVar2 + 0x20] = '\0';
      string.length = iVar1;
    }
  }
  else {
    assert_failed = 0;
  }
LAB_080c80f5:
  add_to_string(&string,"\", ");
  add_to_string(&string,(uchar *)"response=\"");
  iVar2 = string.length;
  if (assert_failed == 0) {
    assert_failed = 0;
    iVar1 = string.length + 0x20;
    uVar6 = string.length + 0xffU >> 8;
    uVar7 = string.length + 0xffU & 0xffffff00;
    uVar10 = string.length + 0x120U & 0xffffff00;
    if (uVar7 <= uVar10 && uVar10 + uVar6 * -0x100 != 0) {
      puVar11 = (uchar *)mem_realloc(string.source,uVar10);
      if (puVar11 == (uchar *)0x0) goto LAB_080c81aa;
      string.source = puVar11;
      memset(puVar11 + uVar7,0,uVar10 + uVar6 * -0x100);
    }
    if (string.source != (uchar *)0x0) {
      puVar9 = (undefined4 *)(string.source + string.length);
      *puVar9 = response._0_4_;
      puVar9[1] = response._4_4_;
      puVar9[2] = response._8_4_;
      puVar9[3] = response._12_4_;
      puVar9[4] = response._16_4_;
      puVar9[5] = response._20_4_;
      puVar9[6] = response._24_4_;
      puVar9[7] = response._28_4_;
      string.source[iVar2 + 0x20] = '\0';
      string.length = iVar1;
    }
  }
  else {
    assert_failed = 0;
  }
LAB_080c81aa:
  add_to_string(&string,"\"");
  puVar11 = string.source;
  if (entry->opaque != (uchar *)0x0) {
    add_to_string(&string,(uchar *)", opaque=\"");
    add_to_string(&string,entry->opaque);
    add_to_string(&string,"\"");
    puVar11 = string.source;
  }
LAB_080c81f6:
  if (iVar4 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return puVar11;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080c8488;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080c8488:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

void close_pipe_and_read(socket *data_socket)

{
  void *pvVar1;
  connection_state state;
  read_buffer *buffer;
  read_buffer *rb;
  uint uVar2;
  connection *conn;
  
  pvVar1 = data_socket->conn;
  buffer = alloc_read_buffer(*(socket **)((int)pvVar1 + 0x60));
  if (buffer != (read_buffer *)0x0) {
    *(undefined4 *)buffer->data = 0x50545448;
    buffer[1].done = (socket_read_T)0x302e312f;
    buffer[1].length = 0x30303220;
    buffer[1].freespace = 0xd4b4f20;
    buffer[1].data[0] = '\n';
    buffer->freespace = buffer->freespace + -0x11;
    buffer->length = 0x11;
    *(byte *)((int)pvVar1 + 0x78) = *(byte *)((int)pvVar1 + 0x78) | 2;
    close(data_socket->fd);
    data_socket->fd = -1;
    *(undefined4 *)(*(int *)((int)pvVar1 + 0x60) + 4) = 1;
    if (assert_failed == 0) {
      uVar2 = 4;
    }
    else {
      uVar2 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar2;
    read_from_socket(*(socket **)((int)pvVar1 + 0x60),buffer,state,http_got_header);
  }
  return;
}



// WARNING: Unknown calling convention

void send_post_data(connection *conn)

{
  int iVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  undefined2 uVar5;
  connection_state state;
  connection_state state_00;
  string *psVar6;
  char *pcVar7;
  uint uVar8;
  undefined4 *puVar9;
  int iVar10;
  uchar *puVar11;
  char cVar12;
  size_t oldsize_1;
  uchar *post;
  byte *__s;
  int newlength;
  size_t __n;
  int n;
  size_t newsize;
  undefined4 *puVar13;
  int h1;
  int h2;
  size_t oldsize;
  uint uVar14;
  size_t newsize_1;
  undefined4 *puVar15;
  int in_GS_OFFSET;
  bool bVar16;
  byte bVar17;
  uint local_1040;
  undefined4 local_1034;
  undefined4 local_1030;
  string data;
  uchar buffer [4096];
  
  bVar17 = 0;
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  __s = conn->uri->post;
  psVar6 = init_string(&data);
  if (psVar6 == (string *)0x0) {
    connection_state((connection_basic_state)&local_1034);
    state.syserr = local_1030;
    state.basic = local_1034;
    abort_connection(conn,state);
    goto LAB_080c8879;
  }
  pcVar7 = strchr((char *)__s,10);
  if (pcVar7 != (char *)0x0) {
    __s = (byte *)(pcVar7 + 1);
  }
  __n = 0;
  while( true ) {
    bVar4 = *__s;
    uVar8 = (uint)bVar4;
    if ((bVar4 == 0) || (__s[1] == 0)) break;
    uVar14 = uVar8 - 0x30;
    if ((9 < (byte)(bVar4 - 0x30)) && (uVar14 = uVar8 - 0x57, 5 < (byte)(bVar4 + 0x9f))) {
      uVar14 = 0xffffffff;
      if ((byte)(bVar4 + 0xbf) < 6) {
        uVar14 = uVar8 - 0x37;
      }
    }
    if (assert_failed == 0) {
      assert_failed = (int)(0xf < uVar14);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/file/cgi.c";
        errline = 0x6b;
        elinks_internal((uchar *)"assertion h1 >= 0 && h1 < 16 failed!");
        if (assert_failed != 0) goto LAB_080c869f;
      }
      uVar8 = (uint)__s[1];
      cVar12 = (char)(uVar14 << 4);
      if (9 < (byte)(__s[1] - 0x30)) goto LAB_080c86be;
LAB_080c861d:
      h2 = uVar8 - 0x30;
LAB_080c8620:
      assert_failed = (int)(0xf < (uint)h2);
      if (assert_failed != 0) goto LAB_080c871f;
    }
    else {
LAB_080c869f:
      uVar8 = (uint)__s[1];
      cVar12 = '\0';
      if ((byte)(__s[1] - 0x30) < 10) goto LAB_080c861d;
LAB_080c86be:
      if ((byte)((char)uVar8 + 0x9fU) < 6) {
        h2 = uVar8 - 0x57;
        goto LAB_080c8620;
      }
      if ((byte)((char)uVar8 + 0xbfU) < 6) {
        h2 = uVar8 - 0x37;
        goto LAB_080c8620;
      }
      assert_failed = 1;
      h2 = -1;
LAB_080c871f:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/file/cgi.c";
      errline = 0x6f;
      elinks_internal((uchar *)"assertion h2 >= 0 && h2 < 16 failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        h2 = 0;
      }
    }
    iVar2 = data.length;
    buffer[__n] = (char)h2 + cVar12;
    __n = __n + 1;
    if (__n == 0x1000) {
      if (assert_failed == 0) {
        assert_failed = 0;
        uVar8 = data.length + 0x1100U & 0xffffff00;
        uVar14 = data.length + 0xffU & 0xffffff00;
        iVar1 = data.length + 0x1000;
        if (uVar14 < uVar8) {
          puVar11 = (uchar *)mem_realloc(data.source,uVar8);
          if (puVar11 != (uchar *)0x0) {
            data.source = puVar11;
            memset(puVar11 + uVar14,0,uVar8 - uVar14);
            goto LAB_080c87ba;
          }
        }
        else {
LAB_080c87ba:
          if (data.source != (uchar *)0x0) {
            puVar9 = (undefined4 *)(data.source + data.length);
            puVar13 = (undefined4 *)buffer;
            local_1040 = 0x1000;
            bVar16 = ((uint)puVar9 & 1) != 0;
            puVar15 = puVar9;
            if (bVar16) {
              puVar15 = (undefined4 *)((int)puVar9 + 1);
              puVar13 = (undefined4 *)(buffer + 1);
              *(uchar *)puVar9 = buffer[0];
              local_1040 = 0xfff;
            }
            if (((uint)puVar15 & 2) != 0) {
              uVar5 = *(undefined2 *)puVar13;
              puVar13 = (undefined4 *)((int)puVar13 + 2);
              *(undefined2 *)puVar15 = uVar5;
              puVar15 = (undefined4 *)((int)puVar15 + 2);
              local_1040 = local_1040 - 2;
            }
            iVar10 = 0;
            for (uVar8 = local_1040 >> 2; uVar8 != 0; uVar8 = uVar8 - 1) {
              *puVar15 = *puVar13;
              puVar13 = puVar13 + (uint)bVar17 * -2 + 1;
              puVar15 = puVar15 + (uint)bVar17 * -2 + 1;
            }
            if ((local_1040 & 2) != 0) {
              *(undefined2 *)puVar15 = *(undefined2 *)puVar13;
              iVar10 = 2;
            }
            if (bVar16) {
              *(undefined *)((int)puVar15 + iVar10) = *(undefined *)((int)puVar13 + iVar10);
            }
            __n = 0;
            data.source[iVar2 + 0x1000] = '\0';
            data.length = iVar1;
            goto LAB_080c8650;
          }
        }
        __n = 0;
      }
      else {
        assert_failed = 0;
        __n = 0;
      }
    }
LAB_080c8650:
    __s = __s + 2;
  }
  if (__n != 0) {
    if (assert_failed == 0) {
      if ((int)__n < 0) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080c8a30;
      }
      else {
        assert_failed = 0;
      }
      iVar2 = __n + data.length;
      uVar14 = iVar2 + 0x100U & 0xffffff00;
      uVar8 = data.length + 0xffU & 0xffffff00;
      if (uVar8 < uVar14) {
        puVar11 = (uchar *)mem_realloc(data.source,uVar14);
        if (puVar11 == (uchar *)0x0) goto LAB_080c8856;
        data.source = puVar11;
        memset(puVar11 + uVar8,0,uVar14 - uVar8);
      }
      if (data.source != (uchar *)0x0) {
        memcpy(data.source + data.length,buffer,__n);
        data.source[iVar2] = '\0';
        data.length = iVar2;
      }
    }
    else {
LAB_080c8a30:
      assert_failed = 0;
    }
  }
LAB_080c8856:
  if (data.length == 0) {
    close_pipe_and_read(conn->data_socket);
  }
  else {
    if (assert_failed == 0) {
      uVar8 = 4;
    }
    else {
      uVar8 = 0xfffe795d;
    }
    assert_failed = 0;
    state_00.syserr = 0;
    state_00.basic = uVar8;
    write_to_socket(conn->data_socket,data.source,data.length,state_00,close_pipe_and_read);
  }
  done_string(&data);
LAB_080c8879:
  if (iVar3 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

int execute_cgi(connection *conn)

{
  uchar uVar1;
  char cVar2;
  list_head_elinks *plVar3;
  cache_entry *pcVar4;
  connection_state state;
  void *pvVar5;
  option_value *poVar6;
  int iVar7;
  connection *data_socket;
  uchar *puVar8;
  size_t __n;
  int filelen;
  int *piVar9;
  __pid_t _Var10;
  uchar *query;
  int res;
  char *pcVar11;
  http_connection_info *phVar12;
  uchar *ustr;
  string *string;
  string *cookies;
  uri *puVar13;
  uint uVar14;
  terminal *term;
  uchar *script;
  undefined4 *puVar15;
  uchar *str;
  int in_GS_OFFSET;
  byte bVar16;
  char *pcVar17;
  connection *pcVar18;
  uchar *local_f0;
  connection *local_e8;
  connection *local_e4;
  int local_e0;
  stat buf;
  int pipe_write [2];
  int pipe_read [2];
  uchar *local_68;
  option_value local_64;
  uchar buf_1 [16];
  int local_20;
  
  bVar16 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (assert_failed == 0) {
    local_e8 = (connection *)0xfffe7960;
  }
  else {
    local_e8 = (connection *)0xfffe795d;
  }
  assert_failed = 0;
  pcVar17 = "protocol.file.cgi.policy";
  data_socket = (connection *)config_options;
  poVar6 = get_opt_();
  if ((poVar6->tree == (list_head_elinks *)0x0) ||
     ((conn->referrer != (uri *)0x0 && (conn->referrer->protocol != 4)))) {
    iVar7 = 1;
    local_e8 = (connection *)pcVar17;
    goto LAB_080c8b8a;
  }
  data_socket = (connection *)get_uri_string(conn->uri,URI_PATH);
  if (data_socket == (connection *)0x0) {
    connection_state((connection_basic_state)&local_e4);
    local_e8 = local_e4;
end2:
    state.syserr = local_e0;
    state.basic = (connection_basic_state)local_e8;
    abort_connection(conn,state);
    iVar7 = 0;
    data_socket = conn;
  }
  else {
    decode_uri((uchar *)data_socket);
    pcVar18 = data_socket;
    iVar7 = __xstat64(3,(char *)data_socket,(stat64 *)&buf);
    if ((iVar7 == 0) && ((buf.st_mode & 0xf040) == 0x8040)) {
      pcVar18 = (connection *)0x2f;
      pcVar17 = strrchr((char *)data_socket,0x2f);
      if (pcVar17 != (char *)0x0) {
        cVar2 = pcVar17[1];
        pcVar17[1] = '\0';
        poVar6 = get_opt_();
        local_64 = *poVar6;
        do {
          pcVar18 = (connection *)0x3a;
          puVar8 = get_next_path_filename(&local_64.string,':');
          local_68 = puVar8;
          if (puVar8 == (uchar *)0x0) {
            pcVar17[1] = cVar2;
            goto LAB_080c8c15;
          }
          __n = strlen((char *)puVar8);
          if (puVar8[__n - 1] != '/') {
            add_to_strn(&local_68,"/");
            __n = __n + 1;
            puVar8 = local_68;
          }
          iVar7 = strncmp((char *)data_socket,(char *)puVar8,__n);
          mem_free(puVar8);
        } while (iVar7 != 0);
        pcVar17[1] = cVar2;
        iVar7 = c_pipe(pipe_read);
        if ((iVar7 == 0) && (iVar7 = c_pipe(pipe_write), iVar7 == 0)) {
          _Var10 = fork();
          if (_Var10 < 0) {
            piVar9 = __errno_location();
            local_e0 = *piVar9;
            local_e8 = (connection *)0xffffffff;
          }
          else {
            if (_Var10 != 0) {
              mem_free(data_socket);
              local_e8 = (connection *)0x1;
              phVar12 = init_http_connection_info(conn,1,0,1);
              if (phVar12 == (http_connection_info *)0x0) {
                close(pipe_read[0]);
                close(pipe_read[1]);
                close(pipe_write[0]);
                close(pipe_write[1]);
                iVar7 = 0;
                data_socket = (connection *)pipe_write[1];
              }
              else {
                close(pipe_read[1]);
                close(pipe_write[0]);
                conn->socket->fd = pipe_read[0];
                conn->data_socket->fd = pipe_write[1];
                conn->field_0x78 = conn->field_0x78 | 8;
                set_nonblocking_fd(conn->socket->fd);
                data_socket = (connection *)conn->data_socket->fd;
                set_nonblocking_fd((int)data_socket);
                if (conn->uri->post == (uchar *)0x0) {
                  data_socket = (connection *)conn->data_socket;
                  close_pipe_and_read((socket *)data_socket);
                  iVar7 = 0;
                }
                else {
                  send_post_data(conn);
                  iVar7 = 0;
                }
              }
              goto LAB_080c8b8a;
            }
            local_f0 = conn->uri->post;
            puVar8 = get_uri_string(conn->uri,URI_QUERY);
            if (puVar8 == (uchar *)0x0) {
              iVar7 = env_set((uchar *)"QUERY_STRING","",-1);
            }
            else {
              iVar7 = env_set((uchar *)"QUERY_STRING",puVar8,-1);
              mem_free(puVar8);
            }
            if (iVar7 != 0) goto LAB_080c8e57;
            if (local_f0 == (uchar *)0x0) {
LAB_080c955a:
              puVar8 = "GET";
            }
            else {
              pcVar11 = strchr((char *)local_f0,10);
              if (pcVar11 != (char *)0x0) {
                iVar7 = env_set((uchar *)"CONTENT_TYPE",local_f0,(int)pcVar11 - (int)local_f0);
                if (iVar7 != 0) goto LAB_080c8e57;
                local_f0 = (uchar *)(pcVar11 + 1);
              }
              uVar14 = 0xffffffff;
              puVar8 = local_f0;
              do {
                if (uVar14 == 0) break;
                uVar14 = uVar14 - 1;
                uVar1 = *puVar8;
                puVar8 = puVar8 + (uint)bVar16 * -2 + 1;
              } while (uVar1 != '\0');
              __snprintf_chk(buf_1,0x10,1,0x10,"%d",(int)(~uVar14 - 1) / 2);
              iVar7 = env_set((uchar *)"CONTENT_LENGTH",buf_1,-1);
              if (iVar7 != 0) goto LAB_080c8e57;
              puVar8 = "POST";
              if (local_f0 == (uchar *)0x0) goto LAB_080c955a;
            }
            iVar7 = env_set((uchar *)"REQUEST_METHOD",puVar8,-1);
            if ((((((iVar7 != 0) ||
                   (iVar7 = env_set((uchar *)"SERVER_SOFTWARE",(uchar *)"ELinks/0.12pre5",-1),
                   iVar7 != 0)) ||
                  (iVar7 = env_set((uchar *)"SERVER_PROTOCOL","HTTP/1.0",-1), iVar7 != 0)) ||
                 (((iVar7 = env_set((uchar *)"SERVER_NAME",(uchar *)"localhost",-1), iVar7 != 0 ||
                   (iVar7 = env_set((uchar *)"REMOTE_ADDR",(uchar *)"127.0.0.1",-1), iVar7 != 0)) ||
                  ((iVar7 = env_set((uchar *)"GATEWAY_INTERFACE",(uchar *)"CGI/1.1",-1), iVar7 != 0
                   || ((iVar7 = env_set((uchar *)"SCRIPT_NAME",(uchar *)data_socket,-1), iVar7 != 0
                       || (iVar7 = env_set((uchar *)"SCRIPT_FILENAME",(uchar *)data_socket,-1),
                          iVar7 != 0)))))))) ||
                (iVar7 = env_set((uchar *)"PATH_TRANSLATED",(uchar *)data_socket,-1), iVar7 != 0))
               || (iVar7 = env_set((uchar *)"REDIRECT_STATUS","1",-1), iVar7 != 0)) {
LAB_080c8e57:
                    // WARNING: Subroutine does not return
              _exit(1);
            }
            poVar6 = get_opt_();
            pvVar5 = terminals.prev;
            puVar8 = poVar6->string;
            if ((*puVar8 != '\0') && ((*puVar8 != ' ' || (puVar8[1] != '\0')))) {
              puVar15 = (undefined4 *)(buf_1 + 4);
              for (iVar7 = 0xf; iVar7 != 0; iVar7 = iVar7 + -1) {
                *puVar15 = 0;
                puVar15 = puVar15 + (uint)bVar16 * -2 + 1;
              }
              buf_1[0] = '\0';
              buf_1[1] = '\0';
              buf_1[2] = '\0';
              buf_1[3] = '\0';
              if ((list_head_elinks *)terminals.next != &terminals) {
                local_68 = (uchar *)0x0;
                elinks_ulongcat(buf_1,(uint *)&local_68,*(ulong *)((int)terminals.prev + 0x2c),3,
                                '\0',10,0);
                buf_1[(int)local_68] = 'x';
                local_68 = local_68 + 1;
                elinks_ulongcat(buf_1,(uint *)&local_68,*(ulong *)((int)pvVar5 + 0x30),3,'\0',10,0);
              }
              puVar8 = subst_user_agent(puVar8,"0.12pre5",system_name,buf_1);
              if (puVar8 != (uchar *)0x0) {
                env_set((uchar *)"HTTP_USER_AGENT",puVar8,-1);
                mem_free(puVar8);
              }
            }
            poVar6 = get_opt_();
            plVar3 = poVar6->tree;
            if (plVar3 == (list_head_elinks *)0x2) {
              puVar13 = (uri *)get_opt_();
LAB_080c9524:
              env_set((uchar *)"HTTP_REFERER",((option_value *)&puVar13->string)->string,-1);
            }
            else if (plVar3 == (list_head_elinks *)0x3) {
              puVar13 = conn->referrer;
              if (puVar13 != (uri *)0x0) goto LAB_080c9524;
            }
            else if ((plVar3 == (list_head_elinks *)0x1) &&
                    (puVar8 = get_uri_string(conn->uri,URI_HTTP_REFERRER), puVar8 != (uchar *)0x0))
            {
              env_set((uchar *)"HTTP_REFERER",puVar8,-1);
              mem_free(puVar8);
            }
            env_set((uchar *)"HTTP_ACCEPT","*/*",-1);
            poVar6 = get_opt_();
            puVar8 = poVar6->string;
            if (*puVar8 == '\0') {
              poVar6 = get_opt_();
              if (poVar6->tree != (list_head_elinks *)0x0) {
                puVar8 = language_to_iso639(current_language);
                goto LAB_080c94a2;
              }
            }
            else {
LAB_080c94a2:
              env_set((uchar *)"HTTP_ACCEPT_LANGUAGE",puVar8,-1);
            }
            pcVar4 = conn->cached;
            if ((((pcVar4 == (cache_entry *)0x0) || ((pcVar4->field_0x5c & 8) != 0)) ||
                (pcVar4->head == (uchar *)0x0)) || (pcVar4->last_modified == (uchar *)0x0)) {
LAB_080c9486:
              if (CACHE_MODE_CHECK_IF_MODIFIED < conn->cache_mode) goto LAB_080c938b;
            }
            else {
              if (conn->cache_mode < CACHE_MODE_FORCE_RELOAD) {
                env_set((uchar *)"HTTP_IF_MODIFIED_SINCE",pcVar4->last_modified,-1);
                goto LAB_080c9486;
              }
LAB_080c938b:
              env_set((uchar *)"HTTP_PRAGMA","no-cache",-1);
              env_set((uchar *)"HTTP_CACHE_CONTROL","no-cache",-1);
            }
            string = send_cookies(conn->uri);
            if (string != (string *)0x0) {
              env_set((uchar *)"HTTP_COOKIE",string->source,-1);
              done_string(string);
            }
            iVar7 = dup2(pipe_write[0],0);
            if ((iVar7 < 0) || (iVar7 = dup2(pipe_read[1],1), iVar7 < 0)) {
                    // WARNING: Subroutine does not return
              _exit(2);
            }
            close_all_non_term_fd();
            *pcVar17 = '\0';
            set_cwd((uchar *)data_socket);
            *pcVar17 = '/';
            iVar7 = execl((char *)data_socket,(char *)data_socket,0);
            if (iVar7 != 0) {
                    // WARNING: Subroutine does not return
              _exit(3);
            }
            local_e0 = 0;
          }
          close(pipe_read[0]);
          close(pipe_read[1]);
          close(pipe_write[0]);
          close(pipe_write[1]);
        }
        else {
          piVar9 = __errno_location();
          local_e0 = *piVar9;
          local_e8 = (connection *)0xffffffff;
        }
        mem_free(data_socket);
        goto end2;
      }
    }
LAB_080c8c15:
    local_e8 = pcVar18;
    mem_free(data_socket);
    iVar7 = 1;
  }
LAB_080c8b8a:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(data_socket,local_e8);
  }
  return iVar7;
}



// WARNING: Unknown calling convention

void add_dir_entry(directory_entry *entry,string *page,int pathlen,uchar *dircolor)

{
  uchar *src;
  string *psVar1;
  size_t sVar2;
  ssize_t sVar3;
  int readlen;
  int iVar4;
  int in_GS_OFFSET;
  uchar *local_4a0;
  stat st;
  string uri_encoded_name;
  string html_encoded_name;
  uchar buf [1024];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  psVar1 = init_string(&html_encoded_name);
  if (psVar1 != (string *)0x0) {
    psVar1 = init_string(&uri_encoded_name);
    if (psVar1 == (string *)0x0) {
      done_string(&html_encoded_name);
    }
    else {
      encode_uri_string(&uri_encoded_name,entry->name + pathlen,-1,1);
      sVar2 = strlen((char *)entry->name);
      add_html_to_string(&html_encoded_name,entry->name + pathlen,sVar2 - pathlen);
      src = entry->attrib;
      sVar2 = strlen((char *)src);
      add_html_to_string(page,src,sVar2);
      add_to_string(page,(uchar *)"<a href=\"");
      add_string_to_string(page,&uri_encoded_name);
      if (*entry->attrib == 'd') {
        add_char_to_string(page,'/');
        local_4a0 = (uchar *)0x0;
      }
      else {
        local_4a0 = (uchar *)0x0;
        if (*entry->attrib == 'l') {
          sVar3 = readlink((char *)entry->name,(char *)buf,0x400);
          if ((sVar3 == 0x400) || (sVar3 < 1)) {
            local_4a0 = (uchar *)0x0;
          }
          else {
            buf[sVar3] = '\0';
            local_4a0 = straconcat(" -> ",buf,0);
          }
          iVar4 = __xstat64(3,(char *)entry->name,(stat64 *)&st);
          if ((iVar4 == 0) && ((st.st_mode & 0xf000) == 0x4000)) {
            add_char_to_string(page,'/');
          }
        }
      }
      add_to_string(page,"\">");
      if ((*entry->attrib == 'd') && (*dircolor != '\0')) {
        string_concat(page,"<font color=\"",dircolor,"\"><b>",0);
      }
      add_string_to_string(page,&html_encoded_name);
      done_string(&uri_encoded_name);
      done_string(&html_encoded_name);
      if ((*entry->attrib == 'd') && (*dircolor != '\0')) {
        add_to_string(page,(uchar *)"</b></font>");
      }
      add_to_string(page,"</a>");
      if (local_4a0 != (uchar *)0x0) {
        sVar2 = strlen((char *)local_4a0);
        add_html_to_string(page,local_4a0,sVar2);
        mem_free(local_4a0);
      }
      add_char_to_string(page,'\n');
    }
  }
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080c9908;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080c9908:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

void file_protocol_handler(connection *connection)

{
  off_t *poVar1;
  uint uVar2;
  int iVar3;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  directory_entry *pdVar4;
  option_value *poVar5;
  string *psVar6;
  int *piVar7;
  directory_entry *p;
  size_t pathlen;
  cache_entry *cached;
  uri *puVar8;
  uchar *puVar9;
  int iVar10;
  int show_hidden_files;
  uchar *puVar11;
  directory_entry *entries;
  directory_entry *entry;
  int in_GS_OFFSET;
  bool bVar12;
  byte bVar13;
  connection *pcVar14;
  char *pcVar15;
  uchar *local_4c;
  int local_48;
  char *local_44;
  int local_40;
  string name;
  string page;
  uchar dircolor [8];
  
  bVar13 = 0;
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  pcVar15 = "anonymous";
  poVar5 = get_opt_();
  bVar12 = poVar5->tree == (list_head_elinks *)0x0;
  if (!bVar12) {
    iVar10 = 0x12;
    puVar9 = connection->uri->string;
    puVar11 = (uchar *)"file:///dev/stdin";
    do {
      if (iVar10 == 0) break;
      iVar10 = iVar10 + -1;
      bVar12 = *puVar9 == *puVar11;
      puVar9 = puVar9 + (uint)bVar13 * -2 + 1;
      puVar11 = puVar11 + (uint)bVar13 * -2 + 1;
    } while (bVar12);
    if ((!bVar12) || (iVar10 = isatty(0), iVar10 != 0)) {
      if (assert_failed == 0) {
        pcVar15 = (char *)0xfffe7895;
      }
      else {
        pcVar15 = (char *)0xfffe795d;
      }
      assert_failed = 0;
      state.syserr = 0;
      state.basic = (connection_basic_state)pcVar15;
      abort_connection(connection,state);
      pcVar14 = connection;
      goto LAB_080c9992;
    }
  }
  pcVar14 = connection;
  iVar10 = execute_cgi(connection);
  if (iVar10 == 0) goto LAB_080c9992;
  psVar6 = init_string(&name);
  if ((psVar6 == (string *)0x0) ||
     (psVar6 = add_uri_to_string(&name,connection->uri,URI_PATH), psVar6 == (string *)0x0)) {
    done_string(&name);
    connection_state((connection_basic_state)&local_44);
    state_01.syserr = local_40;
    state_01.basic = (connection_basic_state)local_44;
    abort_connection(connection,state_01);
    pcVar14 = connection;
    pcVar15 = local_44;
    goto LAB_080c9992;
  }
  decode_uri_string(&name);
  if (((name.length < 1) || (name.source[name.length + -1] != '/')) &&
     (iVar10 = file_is_dir(name.source), iVar10 == 0)) {
    read_encoded_file(&name,&page);
    bVar12 = false;
    local_4c = (uchar *)0x0;
    local_48 = local_40;
    pcVar15 = local_44;
  }
  else if ((*name.source == '\0') || (name.source[name.length + -1] == '/')) {
    poVar5 = get_opt_();
    iVar10 = poVar5->number;
    piVar7 = __errno_location();
    *piVar7 = 0;
    p = get_directory_entries(name.source,iVar10);
    if (p == (directory_entry *)0x0) {
      local_48 = *piVar7;
      pcVar15 = (char *)0xffffffff;
      if (*piVar7 == 0) {
        connection_state((connection_basic_state)&local_44);
        local_48 = local_40;
        pcVar15 = local_44;
      }
    }
    else {
      init_directory_listing(&page,connection->uri);
      if (local_44 == (char *)0xfffe7960) {
        pathlen = strlen((char *)name.source);
        poVar5 = get_opt_();
        if (poVar5->tree == (list_head_elinks *)0x0) {
          dircolor[0] = '\0';
        }
        else {
          poVar5 = get_opt_();
          color_to_string(poVar5->color,dircolor);
        }
        if (p->name != (uchar *)0x0) {
          entry = p;
          do {
            add_dir_entry(entry,&page,pathlen,dircolor);
            mem_free(entry->attrib);
            mem_free(entry->name);
            pdVar4 = entry + 1;
            entry = entry + 1;
          } while (pdVar4->name != (uchar *)0x0);
        }
        mem_free(p);
        psVar6 = add_to_string(&page,(uchar *)"</pre>\n<hr/>\n</body>\n</html>\n");
        if (psVar6 != (string *)0x0) {
          connection_state((connection_basic_state)&local_44);
          local_48 = local_40;
          pcVar15 = local_44;
          goto LAB_080c9b45;
        }
        done_string(&page);
      }
      connection_state((connection_basic_state)&local_44);
      local_48 = local_40;
      pcVar15 = local_44;
    }
LAB_080c9b45:
    bVar12 = true;
    local_4c = (uchar *)0x0;
  }
  else {
    local_4c = "/";
    connection_state((connection_basic_state)&local_44);
    bVar12 = false;
    local_48 = local_40;
    pcVar15 = local_44;
  }
  done_string(&name);
  if (pcVar15 == (char *)0xfffe7960) {
    cached = get_cache_entry(connection->uri);
    connection->cached = cached;
    if (cached == (cache_entry *)0x0) {
      if (local_4c == (uchar *)0x0) {
        done_string(&page);
      }
LAB_080c9d02:
      connection_state((connection_basic_state)&local_44);
      local_48 = local_40;
      pcVar15 = local_44;
    }
    else if (local_4c == (uchar *)0x0) {
      add_fragment(cached,0,page.source,page.length);
      poVar1 = &connection->from;
      uVar2 = *(uint *)poVar1;
      *(int *)poVar1 = *(int *)poVar1 + page.length;
      piVar7 = (int *)((int)&connection->from + 4);
      *piVar7 = *piVar7 + (page.length >> 0x1f) + (uint)CARRY4(uVar2,page.length);
      if ((bVar12) && (cached->head == (uchar *)0x0)) {
        iVar10 = get_cp_index((uchar *)"System");
        puVar9 = get_cp_mime_name(iVar10);
        puVar9 = straconcat((uchar *)"\r\nContent-Type: text/html; charset=",puVar9,&DAT_081352f5,0)
        ;
        if (puVar9 == (uchar *)0x0) {
          connection_state((connection_basic_state)&local_44);
          local_48 = local_40;
          pcVar15 = local_44;
        }
        if (cached->head != (uchar *)0x0) {
          mem_free(cached->head);
        }
        cached->head = puVar9;
      }
      done_string(&page);
    }
    else {
      puVar8 = redirect_cache(cached,local_4c,1,0);
      if (puVar8 == (uri *)0x0) goto LAB_080c9d02;
    }
  }
  state_00.syserr = local_48;
  state_00.basic = (connection_basic_state)pcVar15;
  abort_connection(connection,state_00);
  pcVar14 = connection;
LAB_080c9992:
  if (iVar3 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail(pcVar14,pcVar15);
  }
  return;
}



// WARNING: Unknown calling convention

void finger_protocol_handler(connection *conn)

{
  cache_mode cVar1;
  
  cVar1 = conn->cache_mode;
  *(undefined4 *)&conn->from = 0;
  *(undefined4 *)((int)&conn->from + 4) = 0;
  make_connection(conn->socket,conn->uri,finger_send_request,
                  (uint)(CACHE_MODE_CHECK_IF_MODIFIED < cVar1));
  return;
}



// WARNING: Unknown calling convention

void finger_send_request(socket *socket)

{
  ushort uVar1;
  void *pvVar2;
  int iVar3;
  uint uVar4;
  connection_state state;
  string *psVar5;
  uint uVar6;
  uchar *puVar7;
  size_t newsize;
  uint size;
  uint uVar8;
  string req;
  
  pvVar2 = socket->conn;
  psVar5 = init_string(&req);
  if (psVar5 == (string *)0x0) {
    return;
  }
  if (*(int *)(*(int *)((int)pvVar2 + 0x14) + 0xc) == 0) goto LAB_080c9f40;
  add_char_to_string(&req,' ');
  iVar3 = *(int *)((int)pvVar2 + 0x14);
  uVar1 = *(ushort *)(iVar3 + 0x2a);
  pvVar2 = *(void **)(iVar3 + 0xc);
  if (assert_failed == 0) {
    if (pvVar2 == (void *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ca000;
    }
    else {
      assert_failed = 0;
    }
    uVar8 = (uint)uVar1;
    if (uVar8 != 0) {
      iVar3 = uVar8 + req.length;
      uVar4 = req.length + 0xffU >> 8;
      uVar6 = req.length + 0xffU & 0xffffff00;
      size = iVar3 + 0x100U & 0xffffff00;
      if (uVar6 <= size && size + uVar4 * -0x100 != 0) {
        puVar7 = (uchar *)mem_realloc(req.source,size);
        if (puVar7 == (uchar *)0x0) goto LAB_080c9f40;
        req.source = puVar7;
        memset(puVar7 + uVar6,0,size + uVar4 * -0x100);
      }
      if (req.source != (uchar *)0x0) {
        memcpy(req.source + req.length,pvVar2,uVar8);
        req.source[iVar3] = '\0';
        req.length = iVar3;
      }
    }
  }
  else {
LAB_080ca000:
    assert_failed = 0;
  }
LAB_080c9f40:
  add_crlf_to_string(&req);
  if (assert_failed == 0) {
    uVar8 = 4;
  }
  else {
    uVar8 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar8;
  request_from_socket(socket,req.source,req.length,state,SOCKET_END_ONCLOSE,finger_get_response);
  done_string(&req);
  return;
}



// WARNING: Unknown calling convention

void finger_get_response(socket *socket,read_buffer *rb)

{
  off_t *poVar1;
  int *piVar2;
  connection *conn_00;
  uint length;
  connection_state state;
  connection_state state_00;
  cache_entry *cached_00;
  cache_entry *cached;
  int iVar3;
  uint uVar4;
  connection *conn;
  
  conn_00 = (connection *)socket->conn;
  cached_00 = get_cache_entry(conn_00->uri);
  if (cached_00 == (cache_entry *)0x0) {
    if (assert_failed == 0) {
      uVar4 = 0xfffe795c;
      goto LAB_080ca189;
    }
  }
  else {
    conn_00->cached = cached_00;
    if (socket->state != SOCKET_CLOSED) {
      length = rb->length;
      poVar1 = &conn_00->received;
      uVar4 = *(uint *)poVar1;
      *(uint *)poVar1 = *(int *)poVar1 + length;
      piVar2 = (int *)((int)&conn_00->received + 4);
      *piVar2 = *piVar2 + ((int)length >> 0x1f) + (uint)CARRY4(uVar4,length);
      iVar3 = add_fragment(cached_00,conn_00->from,rb->data,length);
      if (iVar3 == 1) {
        conn_00->tries = 0;
      }
      poVar1 = &conn_00->from;
      uVar4 = *(uint *)poVar1;
      *(uint *)poVar1 = *(int *)poVar1 + length;
      piVar2 = (int *)((int)&conn_00->from + 4);
      *piVar2 = *piVar2 + ((int)length >> 0x1f) + (uint)CARRY4(uVar4,length);
      kill_buffer_data(rb,length);
      if (assert_failed == 0) {
        uVar4 = 8;
      }
      else {
        uVar4 = 0xfffe795d;
      }
      assert_failed = 0;
      state_00.syserr = 0;
      state_00.basic = uVar4;
      read_from_socket(conn_00->socket,rb,state_00,finger_get_response);
      return;
    }
    if (assert_failed == 0) {
      uVar4 = 0xfffe7960;
      goto LAB_080ca189;
    }
  }
  uVar4 = 0xfffe795d;
LAB_080ca189:
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar4;
  abort_connection(conn_00,state);
  return;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080ca248;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080ca248:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



// WARNING: Unknown calling convention

int parse_psv_resp(uchar *data,int *n,int max_value)

{
  uint uVar1;
  byte *pbVar2;
  uchar *p;
  byte bVar3;
  int x;
  int iVar4;
  int iVar5;
  int i;
  int iVar6;
  
  uVar1 = 0;
  do {
    *(undefined4 *)((int)n + uVar1) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x18);
  pbVar2 = data;
  if (0x1f < *data) {
    do {
      pbVar2 = pbVar2 + 1;
    } while (0x1f < *pbVar2);
    if (data != pbVar2) {
      do {
        pbVar2 = pbVar2 + -1;
        if (data == pbVar2) {
          return 0;
        }
        bVar3 = *pbVar2;
      } while (9 < (byte)(bVar3 - 0x30));
      iVar6 = 5;
      do {
        if ((byte)(bVar3 - 0x30) < 10) {
          iVar4 = n[iVar6] + -0x30 + (uint)bVar3;
          n[iVar6] = iVar4;
          if (max_value < iVar4) {
            return 0;
          }
          iVar4 = 1;
          while( true ) {
            pbVar2 = pbVar2 + -1;
            if (data == pbVar2) goto LAB_080ca32c;
            if (9 < (byte)(*pbVar2 - 0x30)) break;
            iVar4 = iVar4 * 10;
            iVar5 = (*pbVar2 - 0x30) * iVar4 + n[iVar6];
            n[iVar6] = iVar5;
            if (max_value < iVar5) {
              return 0;
            }
          }
        }
        do {
          pbVar2 = pbVar2 + -1;
          if (data == pbVar2) {
LAB_080ca32c:
            return 6 - iVar6;
          }
          bVar3 = *pbVar2;
        } while (9 < (byte)(bVar3 - 0x30));
        iVar6 = iVar6 + -1;
      } while (iVar6 != -1);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void send_cmd(connection *conn,string *cmd,void *callback,connection_state state)

{
  request_from_socket(conn->socket,cmd->source,cmd->length,state,SOCKET_RETRY_ONCLOSE,
                      (socket_read_T)callback);
  done_string(cmd);
  return;
}



// WARNING: Unknown calling convention

int ftp_data_connect(connection *conn,int pf,sockaddr_storage *sa,int size_of_sockaddr)

{
  connection_state state;
  int fd_00;
  int fd;
  int iVar1;
  undefined4 local_24;
  undefined4 local_20;
  
  if (((conn->data_socket->fd == -1) && (fd_00 = socket(pf,1,0), -1 < fd_00)) &&
     (iVar1 = set_nonblocking_fd(fd_00), -1 < iVar1)) {
    set_ip_tos_throughput(fd_00);
    conn->data_socket->fd = fd_00;
    connect(fd_00,(sockaddr *)sa,size_of_sockaddr);
    return 0;
  }
  connection_state((connection_basic_state)&local_24);
  state.syserr = local_20;
  state.basic = local_24;
  abort_connection(conn,state);
  return -1;
}



// WARNING: Unknown calling convention

int get_ftp_response(connection *conn,read_buffer *rb,int part,sockaddr_storage *sa)

{
  uchar *__nptr;
  uchar uVar1;
  ushort __v;
  ushort __v_2;
  void *pvVar2;
  int *piVar3;
  ulong uVar4;
  uchar *puVar5;
  int iVar6;
  int iVar7;
  uint uVar8;
  uint __v_1;
  int iVar9;
  undefined *data;
  int pos;
  int i;
  uchar *puVar10;
  bool bVar11;
  byte bVar12;
  int n [6];
  socklen_t local_24;
  uchar *local_20 [4];
  
  bVar12 = 0;
  __nptr = rb->data;
  data = &rb->field_0xf;
LAB_080ca4a3:
  pvVar2 = memchr(__nptr,10,rb->length);
  if (pvVar2 == (void *)0x0) {
    return 0;
  }
  piVar3 = __errno_location();
  *piVar3 = 0;
  uVar4 = strtoul((char *)__nptr,(char **)local_20,10);
  if (*piVar3 != 0) {
    return -1;
  }
  if ((int)uVar4 < 100) {
    return -1;
  }
  if (data != local_20[0]) {
    return -1;
  }
  if ((uVar4 != 0xe3) || (sa == (sockaddr_storage *)0x0)) {
    puVar5 = data;
    if ((uVar4 == 0xe5) && (sa != (sockaddr_storage *)0x0)) {
      local_24 = 0x1c;
      iVar7 = parse_psv_resp(data,n,0xffff);
      if (iVar7 != 1) {
        return -1;
      }
      uVar8 = 0;
      do {
        *(undefined4 *)(sa->__ss_padding + (uVar8 - 8)) = 0;
        uVar8 = uVar8 + 4;
      } while (uVar8 < 0x1c);
      iVar7 = getpeername(conn->socket->fd,(sockaddr *)sa,&local_24);
      if (iVar7 != 0) {
        return -1;
      }
      sa->ss_family = 10;
      __v = (ushort)n[5] >> 8 | (ushort)n[5] << 8;
      *(ushort *)&sa->field_0x2 = __v;
      puVar5 = local_20[0];
    }
  }
  else {
    iVar7 = parse_psv_resp(data,n,0xff);
    if (iVar7 != 6) {
      return -1;
    }
    sa->__ss_align = 0;
    *(undefined4 *)sa->__ss_padding = 0;
    *(undefined4 *)(sa->__ss_padding + 4) = 0;
    sa->ss_family = 2;
    uVar8 = n[0] * 0x1000000 + n[1] * 0x10000 + n[3] + n[2] * 0x100;
    __v_1 = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | n[3] * 0x1000000;
    sa->__ss_align = __v_1;
    __v_2 = (ushort)(n[4] << 8);
    __v_2 = __v_2 + (ushort)n[5];
    *(ushort *)&sa->field_0x2 = __v_2 >> 8 | (ushort)n[5] * 0x100;
    puVar5 = local_20[0];
  }
  i = (int)pvVar2 - (int)__nptr;
  if (*puVar5 == '-') {
    iVar7 = rb->length;
    if (iVar7 + -5 < 1) {
      return 0;
    }
    iVar6 = 0;
    do {
      if (rb->data[iVar6] == '\n') {
        iVar9 = 3;
        bVar11 = rb->data + iVar6 + 1 == (uchar *)0x0;
        puVar5 = rb->data + iVar6 + 1;
        puVar10 = __nptr;
        do {
          if (iVar9 == 0) break;
          iVar9 = iVar9 + -1;
          bVar11 = *puVar5 == *puVar10;
          puVar5 = puVar5 + (uint)bVar12 * -2 + 1;
          puVar10 = puVar10 + (uint)bVar12 * -2 + 1;
        } while (bVar11);
        if ((bVar11) && (rb[1].data[iVar6 + -0xc] == ' ')) goto code_r0x080ca5b7;
      }
      iVar6 = iVar6 + 1;
      if (iVar7 + -5 <= iVar6) {
        return 0;
      }
    } while( true );
  }
  goto LAB_080ca540;
code_r0x080ca5b7:
  i = iVar6 + 1;
  if (iVar7 <= i) {
    return 0;
  }
  uVar1 = rb->data[iVar6 + 1];
  puVar5 = rb->data + iVar6 + 2;
  while (uVar1 != '\n') {
    i = i + 1;
    if (iVar7 <= i) {
      return 0;
    }
    uVar1 = *puVar5;
    puVar5 = puVar5 + 1;
  }
LAB_080ca540:
  if (part == 2) {
    return uVar4;
  }
  kill_buffer_data(rb,i + 1);
  if (part != 0) {
    return uVar4;
  }
  if (199 < (int)uVar4) {
    return uVar4;
  }
  goto LAB_080ca4a3;
}



void __regparm3 ftp_end_request(connection *conn,connection_state state)

{
  connection_state state_00;
  undefined4 in_ECX;
  int in_EDX;
  
  if ((in_EDX == -100000) && (conn->cached != (cache_entry *)0x0)) {
    normalize_cache_entry(conn->cached,conn->from);
  }
  state_00.syserr = in_ECX;
  state_00.basic = in_EDX;
  set_connection_state(conn,state_00);
  add_keepalive_connection(conn,600000,(_func_void_connection_ptr *)0x0);
  return;
}



// WARNING: Unknown calling convention

void ftp_data_accept(connection *conn)

{
  void *pvVar1;
  byte bVar2;
  connection_state state;
  socket *psVar3;
  int *piVar4;
  int newsock;
  
  pvVar1 = conn->info;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -(conn->data_socket->fd >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
    errline = 0x581;
    elinks_internal((uchar *)"assertion conn->data_socket->fd >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  set_connection_timeout(conn);
  set_handlers(conn->data_socket->fd,(select_handler_T)0x0,(select_handler_T)0x0,
               (select_handler_T)0x0,(void *)0x0);
  if ((conn->socket->field_0x24 & 1) == 0) {
    bVar2 = *(byte *)((int)pvVar1 + 0x10) & 4;
  }
  else {
    bVar2 = *(byte *)((int)pvVar1 + 0x10) & 8;
  }
  if (bVar2 == 0) {
    newsock = accept(conn->data_socket->fd,(sockaddr *)0x0,(socklen_t *)0x0);
    if (newsock < 0) {
      piVar4 = __errno_location();
      state.syserr = *piVar4;
      state.basic = 0xffffffff;
      retry_connection(conn,state);
      return;
    }
    close(conn->data_socket->fd);
    psVar3 = conn->data_socket;
  }
  else {
    psVar3 = conn->data_socket;
    newsock = psVar3->fd;
  }
  psVar3->fd = newsock;
  set_handlers(newsock,got_something_from_data_connection,(select_handler_T)0x0,
               (select_handler_T)0x0,conn);
  return;
}



// WARNING: Unknown calling convention

int display_dir_entry(cache_entry *cached,off_t *pos,int *tries,ftp_dir_html_format *format,
                     ftp_file_info *ftp_info)

{
  int iVar1;
  uint uVar2;
  string *psVar3;
  int iVar4;
  time_t tVar5;
  tm *__tp;
  tm *when_tm;
  size_t len;
  char *__format;
  uchar *fmt;
  int in_GS_OFFSET;
  string string;
  time_t local_80;
  uchar date [80];
  uchar permissions [10];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  permissions[0] = '-';
  permissions[1] = '-';
  permissions[2] = '-';
  permissions[3] = '-';
  permissions[4] = '-';
  permissions[5] = '-';
  permissions[6] = '-';
  permissions[7] = '-';
  permissions[8] = '-';
  permissions[9] = '\0';
  psVar3 = init_string(&string);
  iVar4 = -1;
  if (psVar3 == (string *)0x0) goto LAB_080cab4b;
  add_char_to_string(&string,*(uchar *)&ftp_info->type);
  uVar2 = ftp_info->permissions;
  if (uVar2 != 0) {
    if ((uVar2 & 0x100) != 0) {
      permissions[0] = 0x72;
    }
    if ((char)uVar2 < '\0') {
      permissions[1] = 0x77;
    }
    if ((uVar2 & 0x40) != 0) {
      permissions[2] = 0x78;
    }
    if ((uVar2 & 0x800) != 0) {
      permissions[2] = (-((uVar2 & 0x40) == 0) & 0xe0U) + 0x73;
    }
    if ((uVar2 & 0x20) != 0) {
      permissions[3] = 0x72;
    }
    if ((uVar2 & 0x10) != 0) {
      permissions[4] = 0x77;
    }
    if ((uVar2 & 8) != 0) {
      permissions._4_2_ = CONCAT11(0x78,permissions[4]);
    }
    if ((uVar2 & 0x400) != 0) {
      permissions._4_2_ = CONCAT11((-((uVar2 & 8) == 0) & 0xe0U) + 0x73,permissions[4]);
    }
    if ((uVar2 & 4) != 0) {
      permissions._4_3_ = CONCAT12(0x72,permissions._4_2_);
    }
    if ((uVar2 & 2) != 0) {
      permissions[7] = 0x77;
    }
    if ((uVar2 & 1) != 0) {
      permissions[8] = 'x';
    }
    if ((uVar2 & 0x200) != 0) {
      permissions[8] = (-((uVar2 & 1) == 0) & 0xe0U) + 0x74;
    }
  }
  add_to_string(&string,permissions);
  add_char_to_string(&string,' ');
  add_to_string(&string,(uchar *)"   1 ftp      ftp ");
  uVar2 = *(uint *)((int)&ftp_info->size + 4);
  if ((*(uint *)&ftp_info->size & uVar2) == 0xffffffff) {
    add_to_string(&string,"           - ");
    if (ftp_info->mtime < 1) goto LAB_080cac6b;
LAB_080ca9b2:
    tVar5 = time((time_t *)0x0);
    local_80 = ftp_info->mtime;
    if ((ftp_info->field_0x20 & 1) == 0) {
      __tp = gmtime(&local_80);
    }
    else {
      __tp = localtime(&local_80);
    }
    if ((local_80 + 0xed4e00 < tVar5) || (__format = "%b %e %H:%M", tVar5 < local_80 + -0xe10)) {
      __format = "%b %e  %Y";
    }
    len = strftime((char *)date,0x50,__format,__tp);
    add_cp_html_to_string(&string,format->libc_codepage,date,len);
  }
  else {
    add_format_to_string(&string,(uchar *)"%12lld ",*(uint *)&ftp_info->size,uVar2);
    if (0 < ftp_info->mtime) goto LAB_080ca9b2;
LAB_080cac6b:
    add_to_string(&string,"            ");
  }
  add_char_to_string(&string,' ');
  if ((ftp_info->type == FTP_FILE_DIRECTORY) && (format->colorize_dir != 0)) {
    add_to_string(&string,(uchar *)"<font color=\"");
    add_to_string(&string,format->dircolor);
    add_to_string(&string,(uchar *)"\"><b>");
  }
  add_to_string(&string,(uchar *)"<a href=\"");
  encode_uri_string(&string,(ftp_info->name).source,(ftp_info->name).length,0);
  if (ftp_info->type == FTP_FILE_DIRECTORY) {
    add_char_to_string(&string,'/');
  }
  add_to_string(&string,"\">");
  add_html_to_string(&string,(ftp_info->name).source,(ftp_info->name).length);
  add_to_string(&string,"</a>");
  if ((ftp_info->type == FTP_FILE_DIRECTORY) && (format->colorize_dir != 0)) {
    add_to_string(&string,(uchar *)"</b></font>");
  }
  if ((ftp_info->symlink).length != 0) {
    add_to_string(&string," -&gt; ");
    add_html_to_string(&string,(ftp_info->symlink).source,(ftp_info->symlink).length);
  }
  add_char_to_string(&string,'\n');
  iVar4 = add_fragment(cached,*pos,string.source,string.length);
  if (iVar4 != 0) {
    *tries = 0;
  }
  uVar2 = *(uint *)pos;
  *(int *)pos = *(int *)pos + string.length;
  *(int *)((int)pos + 4) =
       *(int *)((int)pos + 4) + (string.length >> 0x1f) + (uint)CARRY4(uVar2,string.length);
  done_string(&string);
  iVar4 = 0;
LAB_080cab4b:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return iVar4;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int ftp_process_dirlist(cache_entry *cached,off_t *pos,uchar *buffer,int buflen,int last,int *tries,
                       ftp_dir_html_format *format)

{
  uint uVar1;
  int retv;
  void *pvVar2;
  ftp_file_info *pfVar3;
  int iVar4;
  string *psVar5;
  int frag_ret;
  int line_length;
  int iVar6;
  int ret;
  int bufl;
  size_t sVar7;
  size_t sVar8;
  uchar *buf;
  uchar *src;
  ftp_file_info ftp_info;
  string string;
  
  iVar6 = 0;
  do {
    while( true ) {
      sVar7 = buflen - iVar6;
      if (sVar7 == 0) {
        return iVar6;
      }
      ftp_info._32_1_ = ftp_info._32_1_ & 0xfe;
      ftp_info.type = FTP_FILE_UNKNOWN;
      src = buffer + iVar6;
      ftp_info.name.source = "";
      ftp_info.name.length = 0;
      ftp_info.symlink.source = "";
      ftp_info.symlink.length = 0;
      ftp_info.size._0_4_ = 0xffffffff;
      ftp_info.size._4_4_ = 0xffffffff;
      ftp_info.mtime = 0;
      ftp_info.permissions = 0x1a4;
      pvVar2 = memchr(src,10,sVar7);
      if (pvVar2 == (void *)0x0) {
        sVar8 = sVar7;
        if (((int)sVar7 < 0x4000) && (last == 0)) {
          return iVar6;
        }
      }
      else {
        line_length = (int)pvVar2 - (int)src;
        sVar7 = line_length;
        if (line_length == 0) {
          sVar8 = 1;
        }
        else {
          sVar8 = line_length + 1;
          if (*(char *)((int)pvVar2 + -1) == '\r') {
            sVar7 = line_length - 1;
            sVar8 = line_length + 1;
          }
        }
      }
      iVar6 = iVar6 + sVar8;
      pfVar3 = parse_ftp_file_info(&ftp_info,src,sVar7);
      if (pfVar3 != (ftp_file_info *)0x0) break;
      psVar5 = init_string(&string);
      if ((((psVar5 == (string *)0x0) ||
           (psVar5 = add_html_to_string(&string,src,sVar7), psVar5 == (string *)0x0)) ||
          (psVar5 = add_char_to_string(&string,'\n'), psVar5 == (string *)0x0)) ||
         (iVar4 = add_fragment(cached,*pos,string.source,string.length), iVar4 == -1)) {
        done_string(&string);
        return -1;
      }
      uVar1 = *(uint *)pos;
      *(int *)pos = *(int *)pos + string.length;
      *(int *)((int)pos + 4) =
           *(int *)((int)pos + 4) + (string.length >> 0x1f) + (uint)CARRY4(uVar1,string.length);
      if (iVar4 == 1) {
        *tries = 0;
      }
      done_string(&string);
    }
  } while (((*ftp_info.name.source == '.') &&
           ((ftp_info.name.length == 1 ||
            ((ftp_info.name.length == 2 && (ftp_info.name.source[1] == '.')))))) ||
          (iVar4 = display_dir_entry(cached,pos,tries,format,&ftp_info), -1 < iVar4));
  return iVar6;
}



// WARNING: Unknown calling convention

void got_something_from_data_connection(connection *conn)

{
  off_t *poVar1;
  uint uVar2;
  int iVar3;
  void *pvVar4;
  int __fd;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  connection_state state_03;
  connection_state state_04;
  connection_state state_05;
  uint uVar5;
  ssize_t len;
  int *piVar6;
  int iVar7;
  option_value *poVar8;
  uchar *puVar9;
  cache_entry *pcVar10;
  int proceeded;
  int iVar11;
  size_t __n;
  int in_GS_OFFSET;
  socket *socket;
  undefined4 uVar12;
  int local_74;
  undefined4 local_70;
  ftp_file_info ftp_info;
  string string;
  ftp_dir_html_format format;
  
  iVar3 = *(int *)(in_GS_OFFSET + 0x14);
  pvVar4 = conn->info;
  if (assert_failed != 0) {
LAB_080cb036:
    assert_failed = 0;
    goto LAB_080caff0;
  }
  assert_failed = -(conn->data_socket->fd >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
    errline = 0x5aa;
    elinks_internal((uchar *)"assertion conn->data_socket->fd >= 0 failed!");
    if (assert_failed != 0) goto LAB_080cb036;
  }
  set_connection_timeout(conn);
  if (conn->cached == (cache_entry *)0x0) {
    pcVar10 = get_cache_entry(conn->uri);
    conn->cached = pcVar10;
    if (pcVar10 == (cache_entry *)0x0) {
LAB_080cb1fe:
      if (assert_failed == 0) {
        uVar5 = 0xfffe795c;
      }
      else {
        uVar5 = 0xfffe795d;
      }
      assert_failed = 0;
      state_02.syserr = 0;
      state_02.basic = uVar5;
      abort_connection(conn,state_02);
      goto LAB_080caff0;
    }
  }
  if ((*(byte *)((int)pvVar4 + 0x10) & 1) != 0) {
    format.libc_codepage = get_cp_index((uchar *)"System");
    poVar8 = get_opt_();
    format.colorize_dir = poVar8->number;
    if (format.colorize_dir != 0) {
      poVar8 = get_opt_();
      color_to_string(poVar8->color,format.dircolor);
    }
    if (((*(byte *)((int)pvVar4 + 0x10) & 1) != 0) &&
       ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0)) {
      if (conn->uri->data == (uchar *)0x0) {
        connection_state((connection_basic_state)&local_74);
        state_05.syserr = local_70;
        state_05.basic = local_74;
        abort_connection(conn,state_05);
        goto LAB_080caff0;
      }
      init_directory_listing(&string,conn->uri);
      if (local_74 != -100000) {
        state_01.syserr = local_70;
        state_01.basic = local_74;
        abort_connection(conn,state_01);
        goto LAB_080caff0;
      }
      add_fragment(conn->cached,conn->from,string.source,string.length);
      poVar1 = &conn->from;
      uVar5 = *(uint *)poVar1;
      *(int *)poVar1 = *(int *)poVar1 + string.length;
      piVar6 = (int *)((int)&conn->from + 4);
      *piVar6 = *piVar6 + (string.length >> 0x1f) + (uint)CARRY4(uVar5,string.length);
      done_string(&string);
      if ((*(uint *)&conn->uri->field_0x30 & 0xffff00) != 0) {
        ftp_info._32_1_ = ftp_info._32_1_ & 0xfe;
        ftp_info.type = FTP_FILE_DIRECTORY;
        ftp_info.name.source = "..";
        ftp_info.name.length = 2;
        ftp_info.symlink.source = "";
        ftp_info.symlink.length = 0;
        ftp_info.size._0_4_ = 0xffffffff;
        ftp_info.size._4_4_ = 0xffffffff;
        ftp_info.mtime = 0;
        ftp_info.permissions = 0x1ed;
        display_dir_entry(conn->cached,&conn->from,&conn->tries,&format,&ftp_info);
      }
      pcVar10 = conn->cached;
      if (pcVar10->content_type != (uchar *)0x0) {
        mem_free(pcVar10->content_type);
        pcVar10 = conn->cached;
      }
      puVar9 = stracpy((uchar *)"text/html");
      pcVar10->content_type = puVar9;
    }
  }
  iVar11 = *(int *)((int)pvVar4 + 0xc);
  puVar9 = (uchar *)((int)pvVar4 + 0x11);
  __fd = conn->data_socket->fd;
  do {
    uVar5 = read(__fd,puVar9 + iVar11,0x4000 - iVar11);
    if (uVar5 != 0xffffffff) {
      if (-1 < (int)uVar5) {
        if (uVar5 == 0) {
          uVar12 = 1;
          iVar11 = ftp_process_dirlist(conn->cached,&conn->from,puVar9,*(int *)((int)pvVar4 + 0xc),1
                                       ,&conn->tries,&format);
          if (iVar11 == -1) goto LAB_080cb1fe;
          if ((*(byte *)((int)pvVar4 + 0x10) & 1) != 0) {
            uVar12 = *(undefined4 *)&conn->from;
            add_fragment(conn->cached,conn->from,(uchar *)"</pre>\n<hr/>\n</body>\n</html>",0x1c);
            poVar1 = &conn->from;
            uVar5 = *(uint *)poVar1;
            *(int *)poVar1 = *(int *)poVar1 + 0x1c;
            piVar6 = (int *)((int)&conn->from + 4);
            *piVar6 = *piVar6 + (uint)(0xffffffe3 < uVar5);
          }
          socket = conn->data_socket;
          close_socket(socket);
          if (*(int *)((int)pvVar4 + 8) == 1) {
            connection_state((connection_basic_state)&local_74);
            state.syserr = uVar12;
            state.basic = (connection_basic_state)socket;
            ftp_end_request(conn,state);
          }
          else {
            *(undefined4 *)((int)pvVar4 + 8) = 2;
            connection_state((connection_basic_state)&local_74);
            state_04.syserr = local_70;
            state_04.basic = local_74;
            set_connection_state(conn,state_04);
          }
        }
        else {
          poVar1 = &conn->received;
          uVar2 = *(uint *)poVar1;
          *(uint *)poVar1 = *(int *)poVar1 + uVar5;
          piVar6 = (int *)((int)&conn->received + 4);
          *piVar6 = *piVar6 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar2,uVar5);
          if ((*(byte *)((int)pvVar4 + 0x10) & 1) == 0) {
            iVar11 = add_fragment(conn->cached,conn->from,puVar9,uVar5);
            if (iVar11 == 1) {
              conn->tries = 0;
            }
            poVar1 = &conn->from;
            uVar2 = *(uint *)poVar1;
            *(uint *)poVar1 = *(int *)poVar1 + uVar5;
            piVar6 = (int *)((int)&conn->from + 4);
            *piVar6 = *piVar6 + ((int)uVar5 >> 0x1f) + (uint)CARRY4(uVar2,uVar5);
            if (assert_failed == 0) goto LAB_080cb2bf;
LAB_080cb349:
            uVar5 = 0xfffe795d;
          }
          else {
            iVar11 = ftp_process_dirlist(conn->cached,&conn->from,puVar9,
                                         *(int *)((int)pvVar4 + 0xc) + uVar5,0,&conn->tries,&format)
            ;
            if (iVar11 == -1) goto LAB_080cb1fe;
            __n = (uVar5 + *(int *)((int)pvVar4 + 0xc)) - iVar11;
            *(size_t *)((int)pvVar4 + 0xc) = __n;
            memmove(puVar9,puVar9 + iVar11,__n);
            if (assert_failed != 0) goto LAB_080cb349;
LAB_080cb2bf:
            uVar5 = 8;
          }
          assert_failed = 0;
          state_03.syserr = 0;
          state_03.basic = uVar5;
          set_connection_state(conn,state_03);
        }
        goto LAB_080caff0;
      }
      piVar6 = __errno_location();
      iVar7 = *piVar6;
      break;
    }
    piVar6 = __errno_location();
    iVar7 = *piVar6;
  } while (iVar7 == 4);
  state_00.syserr = iVar7;
  state_00.basic = 0xffffffff;
  retry_connection(conn,state_00);
LAB_080caff0:
  if (iVar3 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



void __regparm3 ftp_send_retr_req(connection *conn,connection_state state)

{
  uchar *source;
  int iVar1;
  byte bVar2;
  socket *ctrl_socket;
  uri *puVar3;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  connection_state state_03;
  connection_state state_04;
  connection_state state_05;
  ushort __v;
  string *psVar4;
  char *pcVar5;
  int *p;
  option_value *poVar6;
  int i;
  void *pvVar7;
  uint uVar8;
  int iVar9;
  uint uVar10;
  uchar *puVar11;
  int data_sock_1;
  int data_sock;
  undefined4 in_ECX;
  size_t sVar12;
  undefined4 in_EDX;
  uchar *nl;
  ftp_connection_info *ftp;
  sockaddr_storage *psVar13;
  int in_GS_OFFSET;
  byte bVar14;
  string *local_118;
  string *local_110;
  string *local_10c;
  undefined4 local_104;
  undefined4 local_100;
  string pathname;
  string ftp_data_command;
  string command;
  string cmd;
  uchar pc [6];
  sockaddr_storage data_addr;
  sockaddr_in sa;
  
  bVar14 = 0;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  psVar4 = init_string(&cmd);
  if (psVar4 == (string *)0x0) {
    connection_state((connection_basic_state)&local_104);
    state_02.syserr = local_100;
    state_02.basic = local_104;
    abort_connection(conn,state_02);
    goto LAB_080cb5bf;
  }
  pvVar7 = conn->info;
  if (pvVar7 == (void *)0x0) {
    command.source = (uchar *)0x0;
    command.length = 0;
    ftp_data_command.source = (uchar *)0x0;
    ftp_data_command.length = 0;
    pathname.source = (uchar *)0x0;
    pathname.length = 0;
    if (conn->uri->data == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
      errline = 0x2a8;
      elinks_internal((uchar *)"conn->uri->data empty");
      assert_failed = 0;
      abort_connection(conn,(connection_state)0xfffe795d);
    }
    else {
      p = (int *)mem_calloc(1,0x4014);
      if (p == (int *)0x0) {
        if (assert_failed == 0) {
          uVar8 = 0xfffe795c;
        }
        else {
          uVar8 = 0xfffe795d;
        }
        assert_failed = 0;
        state_03.syserr = 0;
        state_03.basic = uVar8;
        abort_connection(conn,state_03);
      }
      else {
        conn->info = p;
        psVar4 = init_string(&command);
        if (psVar4 != (string *)0x0) {
          psVar4 = init_string(&ftp_data_command);
          if ((psVar4 != (string *)0x0) &&
             (psVar4 = init_string(&pathname), psVar4 != (string *)0x0)) {
            pvVar7 = conn->info;
            poVar6 = get_opt_();
            *(byte *)((int)pvVar7 + 0x10) =
                 *(byte *)((int)pvVar7 + 0x10) & 0xfb | ((byte)poVar6->color & 1) * '\x04';
            poVar6 = get_opt_();
            uVar8 = (poVar6->color & 1) * 8;
            bVar2 = *(byte *)((int)pvVar7 + 0x10);
            *(byte *)((int)pvVar7 + 0x10) = bVar2 & 0xf7 | (byte)uVar8;
            ctrl_socket = conn->socket;
            if ((ctrl_socket->field_0x24 & 1) == 0) {
              if ((bVar2 & 4) == 0) {
                iVar9 = get_pasv_socket(ctrl_socket,(sockaddr_storage *)&sa);
                if (iVar9 < 0) goto LAB_080cc0df;
                conn->data_socket->fd = iVar9;
                add_to_string(&ftp_data_command,(uchar *)"PORT ");
                add_long_to_string(&ftp_data_command,sa.sin_addr.s_addr & 0xff);
                add_char_to_string(&ftp_data_command,',');
                add_long_to_string(&ftp_data_command,sa.sin_addr.s_addr >> 8 & 0xff);
                add_char_to_string(&ftp_data_command,',');
                add_long_to_string(&ftp_data_command,sa.sin_addr.s_addr >> 0x10 & 0xff);
                add_char_to_string(&ftp_data_command,',');
                add_long_to_string(&ftp_data_command,sa.sin_addr.s_addr >> 0x18);
                add_char_to_string(&ftp_data_command,',');
                pc[4] = (uchar)sa.sin_port;
                add_long_to_string(&ftp_data_command,(uint)pc[4]);
                add_char_to_string(&ftp_data_command,',');
                pc[5] = (uchar)(sa.sin_port >> 8);
                add_long_to_string(&ftp_data_command,(uint)pc[5]);
              }
              else {
                add_to_string(&ftp_data_command,"PASV");
              }
            }
            else if ((uVar8 & 8) == 0) {
              psVar13 = &data_addr;
              for (iVar9 = 0x20; iVar9 != 0; iVar9 = iVar9 + -1) {
                *(undefined4 *)psVar13 = 0;
                psVar13 = (sockaddr_storage *)((int)psVar13 + (uint)bVar14 * -8 + 4);
              }
              iVar9 = get_pasv_socket(ctrl_socket,&data_addr);
              if (iVar9 < 0) {
LAB_080cc0df:
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
                errline = 0x2c2;
                elinks_internal((uchar *)"Ftp data socket failure");
                assert_failed = 0;
                abort_connection(conn,(connection_state)0xfffe795d);
                goto ret;
              }
              conn->data_socket->fd = iVar9;
              inet_ntop(10,data_addr.__ss_padding,(char *)&sa,0x2e);
              add_to_string(&ftp_data_command,"EPRT |2|");
              add_to_string(&ftp_data_command,(uchar *)&sa);
              add_char_to_string(&ftp_data_command,'|');
              __v = (ushort)data_addr._2_2_ >> 8 | data_addr._2_2_ << 8;
              add_long_to_string(&ftp_data_command,(uint)__v);
              add_char_to_string(&ftp_data_command,'|');
            }
            else {
              add_to_string(&ftp_data_command,"EPSV");
            }
            local_110 = &pathname;
            add_crlf_to_string(&ftp_data_command);
            psVar4 = add_uri_to_string(local_110,conn->uri,URI_PATH);
            if (psVar4 == (string *)0x0) {
LAB_080cc0a8:
              connection_state((connection_basic_state)&local_104);
              state_05.syserr = local_100;
              state_05.basic = local_104;
              abort_connection(conn,state_05);
            }
            else {
              decode_uri_string(local_110);
              if (pathname.length < 1) {
LAB_080cb826:
                puVar3 = conn->uri;
                if (((*(uint *)&puVar3->field_0x30 & 0xffff00) == 0) ||
                   (puVar3->data[*(ushort *)&puVar3->field_0x31 - 1] == '/')) {
                  *(byte *)(p + 4) = *(byte *)(p + 4) | 1;
                  *p = 4;
                  psVar4 = add_to_string(&command,(uchar *)"TYPE A");
                  if (((((psVar4 == (string *)0x0) ||
                        (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0)) ||
                       ((psVar4 = add_string_to_string(&command,&ftp_data_command),
                        psVar4 == (string *)0x0 ||
                        ((psVar4 = add_to_string(&command,"CWD "), psVar4 == (string *)0x0 ||
                         (psVar4 = add_string_to_string(&command,local_110), psVar4 == (string *)0x0
                         )))))) || (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))
                     || ((psVar4 = add_to_string(&command,"LIST"), psVar4 == (string *)0x0 ||
                         (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))))
                  goto LAB_080cbf78;
                  *(undefined4 *)&conn->from = 0;
                  *(undefined4 *)((int)&conn->from + 4) = 0;
                }
                else {
                  *(byte *)(p + 4) = *(byte *)(p + 4) & 0xfe;
                  *p = 3;
                  psVar4 = add_to_string(&command,(uchar *)"TYPE I");
                  if ((psVar4 == (string *)0x0) ||
                     ((psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0 ||
                      (psVar4 = add_string_to_string(&command,&ftp_data_command),
                      psVar4 == (string *)0x0)))) goto LAB_080cc0a8;
                  uVar8 = *(uint *)&conn->from;
                  if ((*(uint *)((int)&conn->from + 4) | uVar8) == 0) {
                    iVar9 = *(int *)((int)&conn->progress->start + 4);
                    uVar8 = *(uint *)&conn->progress->start;
                    if ((-1 < iVar9) && ((0 < iVar9 || (uVar8 != 0)))) goto LAB_080cb8d4;
                  }
                  else {
LAB_080cb8d4:
                    psVar4 = add_to_string(&command,(uchar *)"REST ");
                    if ((psVar4 == (string *)0x0) ||
                       ((psVar4 = add_long_to_string(&command,uVar8), psVar4 == (string *)0x0 ||
                        (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))))
                    goto LAB_080cc0a8;
                    *(byte *)(p + 4) = *(byte *)(p + 4) | 2;
                    *p = *p + 1;
                  }
                  psVar4 = add_to_string(&command,(uchar *)"RETR ");
                  if (((psVar4 == (string *)0x0) ||
                      (psVar4 = add_string_to_string(&command,local_110), psVar4 == (string *)0x0))
                     || (psVar4 = add_crlf_to_string(&command), psVar4 == (string *)0x0))
                  goto LAB_080cc0a8;
                }
                p[1] = *p;
                pvVar7 = mem_realloc(p,command.length + 0x4014);
                if (pvVar7 != (void *)0x0) {
                  conn->info = pvVar7;
                  memcpy((void *)((int)pvVar7 + 0x4011),command.source,command.length + 1);
                  done_string(local_110);
                  done_string(&ftp_data_command);
                  done_string(&command);
                  pvVar7 = conn->info;
                  goto LAB_080cb4db;
                }
              }
              else if ((*pathname.source != '\n') && (iVar9 = 0, *pathname.source != '\r')) {
                do {
                  iVar9 = iVar9 + 1;
                  if (pathname.length <= iVar9) goto LAB_080cb826;
                } while ((pathname.source[iVar9] != '\r') && (pathname.source[iVar9] != '\n'));
              }
LAB_080cbf78:
              connection_state((connection_basic_state)&local_104);
              state_04.syserr = local_100;
              state_04.basic = local_104;
              abort_connection(conn,state_04);
            }
            goto ret;
          }
        }
        if (assert_failed == 0) {
          uVar8 = 0xfffe795c;
        }
        else {
          uVar8 = 0xfffe795d;
        }
        assert_failed = 0;
        state_01.syserr = 0;
        state_01.basic = uVar8;
        abort_connection(conn,state_01);
      }
    }
ret:
    local_10c = &ftp_data_command;
    local_118 = &command;
    local_110 = &pathname;
    done_string(local_110);
    done_string(local_10c);
    done_string(local_118);
    done_string(&cmd);
    goto LAB_080cb5bf;
  }
LAB_080cb4db:
  source = (uchar *)((int)pvVar7 + 0x4011);
  pcVar5 = strchr((char *)source,10);
  if (pcVar5 == (char *)0x0) {
    add_to_string(&cmd,source);
  }
  else {
    pcVar5 = pcVar5 + 1;
    if (assert_failed == 0) {
      sVar12 = (int)pcVar5 - (int)source;
      if ((source == (uchar *)0x0) || ((int)sVar12 < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080cb5e0;
      }
      else {
        assert_failed = 0;
      }
      if (sVar12 != 0) {
        iVar9 = cmd.length + sVar12;
        uVar8 = iVar9 + 0x100U & 0xffffff00;
        uVar10 = cmd.length + 0xffU & 0xffffff00;
        if (uVar10 < uVar8) {
          puVar11 = (uchar *)mem_realloc(cmd.source,uVar8);
          if (puVar11 == (uchar *)0x0) goto LAB_080cb57b;
          cmd.source = puVar11;
          memset(puVar11 + uVar10,0,uVar8 - uVar10);
        }
        if (cmd.source != (uchar *)0x0) {
          memcpy(cmd.source + cmd.length,source,sVar12);
          cmd.source[iVar9] = '\0';
          cmd.length = iVar9;
        }
      }
    }
    else {
LAB_080cb5e0:
      assert_failed = 0;
    }
LAB_080cb57b:
    sVar12 = strlen(pcVar5);
    memmove(source,pcVar5,sVar12 + 1);
  }
  state_00.syserr = in_ECX;
  state_00.basic = in_EDX;
  send_cmd(conn,&cmd,ftp_retr_file,state_00);
LAB_080cb5bf:
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void ftp_protocol_handler(connection *conn)

{
  connection_state state;
  connection_state state_00;
  int iVar1;
  undefined4 in_stack_00000008;
  
  iVar1 = has_keepalive_connection(conn);
  if (iVar1 == 0) {
    make_connection(conn->socket,conn->uri,ftp_login,
                    (uint)(CACHE_MODE_CHECK_IF_MODIFIED < conn->cache_mode));
    return;
  }
  if (assert_failed != 0) {
    assert_failed = 0;
    state.syserr = in_stack_00000008;
    state.basic = (connection_basic_state)conn;
    ftp_send_retr_req(conn,state);
    return;
  }
  assert_failed = 0;
  state_00.syserr = in_stack_00000008;
  state_00.basic = (connection_basic_state)conn;
  ftp_send_retr_req(conn,state_00);
  return;
}



// WARNING: Unknown calling convention

void ftp_got_final_response(socket *socket,read_buffer *rb)

{
  connection *conn_00;
  void *pvVar1;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  connection_state state_03;
  int iVar2;
  int response;
  uri *puVar3;
  uint uVar4;
  cache_entry *cached;
  undefined4 uVar5;
  connection *conn;
  undefined4 local_24;
  undefined4 local_20;
  
  conn_00 = (connection *)socket->conn;
  pvVar1 = conn_00->info;
  iVar2 = get_ftp_response(conn_00,rb,0,(sockaddr_storage *)0x0);
  if (iVar2 != -1) {
    if (iVar2 == 0) {
      if ((conn_00->state).basic == S_TRANS) {
        iVar2 = (conn_00->state).syserr;
        uVar5 = 8;
      }
      else if (assert_failed == 0) {
        assert_failed = 0;
        uVar5 = 6;
        iVar2 = 0;
      }
      else {
        assert_failed = 0;
        uVar5 = 0xfffe795d;
        iVar2 = 0;
      }
      state_03.syserr = iVar2;
      state_03.basic = uVar5;
      read_from_socket(conn_00->socket,rb,state_03,ftp_got_final_response);
      return;
    }
    if ((iVar2 == 0x1c2) || (0x225 < iVar2)) {
      cached = conn_00->cached;
      if (cached == (cache_entry *)0x0) {
        cached = get_cache_entry(conn_00->uri);
        conn_00->cached = cached;
        if (cached == (cache_entry *)0x0) goto LAB_080cc390;
      }
      puVar3 = redirect_cache(cached,"/",1,0);
      if (puVar3 != (uri *)0x0) {
        if (assert_failed == 0) {
          uVar4 = 0xfffe7960;
        }
        else {
          uVar4 = 0xfffe795d;
        }
        assert_failed = 0;
        state_00.syserr = 0;
        state_00.basic = uVar4;
        abort_connection(conn_00,state_00);
        return;
      }
    }
    else if (iVar2 < 400) {
      if (*(int *)((int)pvVar1 + 8) == 2) {
        connection_state((connection_basic_state)&local_24);
        state.syserr = (int)rb;
        state.basic = (connection_basic_state)socket;
        ftp_end_request(conn_00,state);
        return;
      }
      *(undefined4 *)((int)pvVar1 + 8) = 1;
      if ((conn_00->state).basic == S_TRANS) {
        return;
      }
      if (assert_failed == 0) {
        uVar4 = 6;
      }
      else {
        uVar4 = 0xfffe795d;
      }
      assert_failed = 0;
      state_01.syserr = 0;
      state_01.basic = uVar4;
      set_connection_state(conn_00,state_01);
      return;
    }
  }
LAB_080cc390:
  connection_state((connection_basic_state)&local_24);
  state_02.syserr = local_20;
  state_02.basic = local_24;
  abort_connection(conn_00,state_02);
  return;
}



// WARNING: Removing unreachable block (ram,0x080cca52)
// WARNING: Unknown calling convention

void ftp_retr_file(socket *socket,read_buffer *rb)

{
  off_t *poVar1;
  longlong lVar2;
  char cVar3;
  int iVar4;
  connection *conn_00;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  bool bVar5;
  int iVar6;
  int response;
  int iVar7;
  int iVar8;
  int pos;
  int iVar9;
  uint uVar10;
  progress *ppVar11;
  int *piVar12;
  long lVar13;
  int pos_file_len;
  int res;
  undefined4 uVar14;
  uchar uVar15;
  uchar *__haystack;
  uchar *puVar16;
  uchar *kbytes;
  undefined4 uVar17;
  char *pcVar18;
  connection *conn;
  ftp_connection_info *ftp;
  int in_GS_OFFSET;
  double size;
  double dVar19;
  char *pcVar20;
  undefined4 in_stack_fffffef8;
  undefined4 local_b4;
  undefined4 local_b0;
  char *local_a4;
  sockaddr_storage sa;
  
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  conn_00 = (connection *)socket->conn;
  piVar12 = (int *)conn_00->info;
  if (*piVar12 < 2) {
    iVar6 = get_ftp_response(conn_00,rb,2,(sockaddr_storage *)0x0);
    if (iVar6 == -1) goto LAB_080cc78b;
    if (iVar6 == 0) {
      connection_state((connection_basic_state)&local_b4);
      state_01.syserr = local_b0;
      state_01.basic = local_b4;
      read_from_socket(conn_00->socket,rb,state_01,ftp_retr_file);
      goto LAB_080cc50e;
    }
    if (((99 < iVar6 - 100U) || ((*(byte *)(piVar12 + 4) & 1) != 0)) ||
       ((*(uint *)&conn_00->est_length & *(uint *)((int)&conn_00->est_length + 4)) != 0xffffffff))
    goto LAB_080cc658;
    iVar6 = rb->length;
    __haystack = rb->data;
    if ((iVar6 < 1) || (uVar15 = rb->data[0], uVar15 == '\n')) {
LAB_080cc8aa:
      uVar15 = rb->data[iVar6 + -1];
      rb->data[iVar6 + -1] = '\0';
      pcVar20 = strstr((char *)__haystack,"kbytes");
      rb->data[iVar6 + -1] = uVar15;
      if (pcVar20 != (char *)0x0) {
        pcVar18 = pcVar20 + -2;
        if (pcVar18 < __haystack) {
LAB_080cc920:
          if (*pcVar18 != ' ') goto LAB_080cc658;
        }
        else {
          cVar3 = pcVar20[-2];
          while (cVar3 != ' ') {
            pcVar18 = pcVar18 + -1;
            if (pcVar18 < __haystack) goto LAB_080cc920;
            cVar3 = *pcVar18;
          }
        }
        dVar19 = strtod(pcVar18 + 1,&local_a4);
        if (pcVar18 + 1 != local_a4) {
          bVar5 = true;
          lVar2 = (longlong)ROUND(dVar19 * 1024.0);
          goto LAB_080cc989;
        }
      }
    }
    else {
      iVar7 = 0;
      iVar8 = 0;
      do {
        if (uVar15 == '(') {
          iVar7 = iVar8;
        }
        iVar8 = iVar8 + 1;
      } while ((iVar8 < iVar6) && (uVar15 = __haystack[iVar8], uVar15 != '\n'));
      if ((iVar7 == 0) || (iVar7 == iVar6 + -1)) goto LAB_080cc8aa;
      iVar8 = iVar7 + 1;
      if ((9 < (byte)(rb->data[iVar7 + 1] - 0x30)) ||
         (puVar16 = rb->data + iVar7, iVar7 = iVar8, iVar6 <= iVar8)) goto LAB_080cc658;
      do {
        iVar9 = iVar7;
        iVar7 = iVar9 + 1;
        if (iVar6 <= iVar7) goto LAB_080cc658;
        pcVar20 = (char *)(puVar16 + 2);
        puVar16 = puVar16 + 1;
      } while ((byte)(*pcVar20 - 0x30U) < 10);
      uVar15 = rb->data[iVar9 + 1];
      puVar16 = rb->data + iVar9 + 1;
      while ((uVar15 == ' ' && (iVar7 = iVar7 + 1, iVar7 < iVar6))) {
        uVar15 = puVar16[1];
        puVar16 = puVar16 + 1;
      }
      if ((iVar6 < iVar7 + 4) ||
         (iVar6 = c_strncasecmp((char *)(__haystack + iVar7),"byte",4), iVar6 != 0))
      goto LAB_080cc658;
      piVar12 = __errno_location();
      *piVar12 = 0;
      lVar13 = strtol((char *)(__haystack + iVar8),(char **)0x0,10);
      if (*piVar12 != 0) goto LAB_080cc658;
      bVar5 = false;
      lVar2 = (longlong)lVar13;
LAB_080cc989:
      if (0 < lVar2) {
        if (bVar5) {
          poVar1 = &conn_00->progress->start;
          lVar2 = CONCAT44((int)((ulonglong)lVar2 >> 0x20) +
                           *(int *)((int)&conn_00->progress->start + 4) +
                           (uint)CARRY4((uint)lVar2,*(uint *)poVar1),(uint)lVar2 + *(int *)poVar1);
        }
        conn_00->est_length = lVar2;
      }
    }
LAB_080cc658:
    iVar6 = conn_00->data_socket->fd;
    if (iVar6 != -1) {
      set_handlers(iVar6,ftp_data_accept,(select_handler_T)0x0,(select_handler_T)0x0,conn_00);
      ftp_got_final_response(socket,rb);
      goto LAB_080cc50e;
    }
  }
  else {
    pcVar20 = (char *)&sa;
    iVar6 = get_ftp_response(conn_00,rb,0,(sockaddr_storage *)pcVar20);
    if (iVar6 != -1) {
      if (iVar6 == 0) {
        if (assert_failed == 0) {
          uVar10 = 6;
        }
        else {
          uVar10 = 0xfffe795d;
        }
        assert_failed = 0;
        state_02.syserr = 0;
        state_02.basic = uVar10;
        read_from_socket(conn_00->socket,rb,state_02,ftp_retr_file);
        goto LAB_080cc50e;
      }
      if (iVar6 == 0xe3) {
        pcVar20 = &DAT_00000010;
        iVar7 = ftp_data_connect(conn_00,2,&sa,0x10);
joined_r0x080cc6db:
        if (iVar7 != 0) goto LAB_080cc50e;
      }
      else if (iVar6 == 0xe5) {
        pcVar20 = (char *)0x1c;
        iVar7 = ftp_data_connect(conn_00,10,&sa,0x1c);
        goto joined_r0x080cc6db;
      }
      iVar7 = piVar12[1] - (*piVar12 + -1);
      *piVar12 = *piVar12 + -1;
      if (iVar7 == 2) {
        if (399 < iVar6) goto LAB_080cc78b;
      }
      else if (iVar7 == 3) {
        if (iVar6 < 400) {
          if ((*(byte *)(piVar12 + 4) & 2) != 0) {
            if (iVar6 == 0x15e) {
              ppVar11 = conn_00->progress;
              uVar17 = *(undefined4 *)&ppVar11->start;
              uVar14 = *(undefined4 *)((int)&ppVar11->start + 4);
              *(undefined4 *)&conn_00->from = uVar17;
              *(undefined4 *)((int)&conn_00->from + 4) = uVar14;
            }
            else {
              ppVar11 = conn_00->progress;
              uVar17 = *(undefined4 *)&conn_00->from;
              uVar14 = *(undefined4 *)((int)&conn_00->from + 4);
            }
            if (-1 < *(int *)((int)&ppVar11->start + 4)) {
              *(undefined4 *)&ppVar11->seek = uVar17;
              *(undefined4 *)((int)&ppVar11->seek + 4) = uVar14;
              ppVar11 = conn_00->progress;
              uVar17 = *(undefined4 *)&conn_00->from;
              uVar14 = *(undefined4 *)((int)&conn_00->from + 4);
            }
            *(undefined4 *)&ppVar11->start = uVar17;
            *(undefined4 *)((int)&ppVar11->start + 4) = uVar14;
          }
        }
        else {
          if ((*(byte *)(piVar12 + 4) & 1) != 0) goto LAB_080cc78b;
          *(undefined4 *)&conn_00->from = 0;
          *(undefined4 *)((int)&conn_00->from + 4) = 0;
        }
      }
      else if (iVar7 != 1) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
        errline = 0x3fa;
        pcVar20 = "WHAT???";
        elinks_internal((uchar *)"WHAT???");
      }
      assert_failed = 0;
      state.syserr = in_stack_fffffef8;
      state.basic = (connection_basic_state)pcVar20;
      ftp_send_retr_req(conn_00,state);
      goto LAB_080cc50e;
    }
  }
LAB_080cc78b:
  connection_state((connection_basic_state)&local_b4);
  state_00.syserr = local_b0;
  state_00.basic = local_b4;
  abort_connection(conn_00,state_00);
LAB_080cc50e:
  if (iVar4 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void prompt_username_pw(connection *conn)

{
  connection_state state;
  connection_state state_00;
  uchar *puVar1;
  uint uVar2;
  cache_entry *pcVar3;
  undefined4 local_14;
  undefined4 local_10;
  
  pcVar3 = conn->cached;
  if (pcVar3 == (cache_entry *)0x0) {
    pcVar3 = get_cache_entry(conn->uri);
    conn->cached = pcVar3;
    if (pcVar3 == (cache_entry *)0x0) {
      connection_state((connection_basic_state)&local_14);
      state_00.syserr = local_10;
      state_00.basic = local_14;
      abort_connection(conn,state_00);
      return;
    }
  }
  if (pcVar3->content_type != (uchar *)0x0) {
    mem_free(pcVar3->content_type);
    pcVar3 = conn->cached;
  }
  puVar1 = stracpy((uchar *)"text/html");
  pcVar3->content_type = puVar1;
  if (conn->cached->content_type == (uchar *)0x0) {
    if (assert_failed == 0) {
      uVar2 = 0xfffe795c;
      goto LAB_080ccae3;
    }
  }
  else {
    add_auth_entry(conn->uri,(uchar *)"FTP Login",(uchar *)0x0,(uchar *)0x0,0);
    if (assert_failed == 0) {
      uVar2 = 0xfffe7960;
      goto LAB_080ccae3;
    }
  }
  uVar2 = 0xfffe795d;
LAB_080ccae3:
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar2;
  abort_connection(conn,state);
  return;
}



// WARNING: Unknown calling convention

void ftp_pass_info(socket *socket,read_buffer *rb)

{
  connection *conn_00;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  connection_state state_03;
  int iVar1;
  int response;
  uint uVar2;
  connection *conn;
  undefined4 local_14;
  undefined4 local_10;
  
  conn_00 = (connection *)socket->conn;
  iVar1 = get_ftp_response(conn_00,rb,0,(sockaddr_storage *)0x0);
  if (iVar1 == -1) {
    connection_state((connection_basic_state)&local_14);
    state_02.syserr = local_10;
    state_02.basic = local_14;
    abort_connection(conn_00,state_02);
  }
  else {
    if (iVar1 == 0) {
      if (assert_failed == 0) {
        uVar2 = 5;
      }
      else {
        uVar2 = 0xfffe795d;
      }
      assert_failed = 0;
      state_03.syserr = 0;
      state_03.basic = uVar2;
      read_from_socket(conn_00->socket,rb,state_03,ftp_pass_info);
      return;
    }
    if ((499 < iVar1) || (iVar1 == 0x14c)) {
      prompt_username_pw(conn_00);
      return;
    }
    if (iVar1 < 400) {
      if (assert_failed != 0) {
        assert_failed = 0;
        state.syserr = (int)rb;
        state.basic = (connection_basic_state)socket;
        ftp_send_retr_req(conn_00,state);
        return;
      }
      assert_failed = 0;
      state_00.syserr = (int)rb;
      state_00.basic = (connection_basic_state)socket;
      ftp_send_retr_req(conn_00,state_00);
      return;
    }
    if (assert_failed == 0) {
      uVar2 = 0xfffe7833;
    }
    else {
      uVar2 = 0xfffe795d;
    }
    assert_failed = 0;
    state_01.syserr = 0;
    state_01.basic = uVar2;
    abort_connection(conn_00,state_01);
  }
  return;
}



// WARNING: Unknown calling convention

void ftp_login(socket *socket)

{
  ushort uVar1;
  connection *conn_00;
  uchar *__src;
  connection_state state;
  connection_state state_00;
  auth_entry *paVar2;
  string *psVar3;
  uint uVar4;
  uchar *puVar5;
  int newlength;
  int iVar6;
  size_t oldsize;
  connection *conn;
  auth_entry *auth;
  size_t newsize;
  uint size;
  string cmd;
  
  conn_00 = (connection *)socket->conn;
  paVar2 = find_auth(conn_00->uri);
  psVar3 = init_string(&cmd);
  if (psVar3 == (string *)0x0) {
    if (assert_failed == 0) {
      uVar4 = 0xfffe795c;
    }
    else {
      uVar4 = 0xfffe795d;
    }
    assert_failed = 0;
    state_00.syserr = 0;
    state_00.basic = uVar4;
    abort_connection(conn_00,state_00);
    return;
  }
  add_to_string(&cmd,(uchar *)"USER ");
  uVar1 = *(ushort *)&conn_00->uri->field_0x2a;
  if (uVar1 == 0) {
    if ((paVar2 == (auth_entry *)0x0) || ((paVar2->field_0x70 & 2) == 0)) {
      add_to_string(&cmd,(uchar *)"anonymous");
    }
    else {
      add_to_string(&cmd,paVar2->user);
    }
    goto LAB_080ccd69;
  }
  __src = conn_00->uri->user;
  if (assert_failed == 0) {
    if (__src == (uchar *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ccee8;
    }
    else {
      assert_failed = 0;
    }
    iVar6 = (uint)uVar1 + cmd.length;
    uVar4 = cmd.length + 0xffU & 0xffffff00;
    size = iVar6 + 0x100U & 0xffffff00;
    if (uVar4 < size) {
      puVar5 = (uchar *)mem_realloc(cmd.source,size);
      if (puVar5 == (uchar *)0x0) goto LAB_080ccd69;
      cmd.source = puVar5;
      memset(puVar5 + uVar4,0,size - uVar4);
    }
    if (cmd.source != (uchar *)0x0) {
      memcpy(cmd.source + cmd.length,__src,(uint)uVar1);
      cmd.source[iVar6] = '\0';
      cmd.length = iVar6;
    }
  }
  else {
LAB_080ccee8:
    assert_failed = 0;
  }
LAB_080ccd69:
  add_crlf_to_string(&cmd);
  if (assert_failed == 0) {
    uVar4 = 4;
  }
  else {
    uVar4 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar4;
  send_cmd(conn_00,&cmd,ftp_got_info,state);
  return;
}



// WARNING: Unknown calling convention

void ftp_got_user_info(socket *socket,read_buffer *rb)

{
  ushort uVar1;
  connection *conn_00;
  uri *puVar2;
  uchar *__src;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  int iVar3;
  int response;
  auth_entry *paVar4;
  string *psVar5;
  option_value *poVar6;
  uint uVar7;
  uchar *puVar8;
  int newlength;
  size_t oldsize;
  connection *conn;
  auth_entry *auth;
  size_t newsize;
  uint size;
  undefined4 uVar9;
  undefined4 in_stack_ffffff98;
  undefined4 local_34;
  undefined4 local_30;
  string cmd;
  
  conn_00 = (connection *)socket->conn;
  uVar9 = 0;
  iVar3 = get_ftp_response(conn_00,rb,0,(sockaddr_storage *)0x0);
  if (iVar3 == -1) {
    connection_state((connection_basic_state)&local_34);
    state_02.syserr = local_30;
    state_02.basic = local_34;
    abort_connection(conn_00,state_02);
    return;
  }
  if (iVar3 == 0) {
    read_from_socket(conn_00->socket,rb,conn_00->state,ftp_got_user_info);
    return;
  }
  if ((499 < iVar3) || (iVar3 == 0x14c)) {
LAB_080cd0d0:
    prompt_username_pw(conn_00);
    return;
  }
  if (iVar3 < 400) {
    if (iVar3 == 0xe6) {
      connection_state((connection_basic_state)&local_34);
      state_00.syserr = in_stack_ffffff98;
      state_00.basic = uVar9;
      ftp_send_retr_req(conn_00,state_00);
      return;
    }
    paVar4 = find_auth(conn_00->uri);
    psVar5 = init_string(&cmd);
    if (psVar5 != (string *)0x0) {
      add_to_string(&cmd,(uchar *)"PASS ");
      puVar2 = conn_00->uri;
      uVar1 = *(ushort *)&puVar2->field_0x2c;
      if (uVar1 == 0) {
        if ((paVar4 == (auth_entry *)0x0) || ((paVar4->field_0x70 & 2) == 0)) {
          poVar6 = get_opt_();
          add_to_string(&cmd,poVar6->string);
        }
        else {
          if (*(short *)&puVar2->field_0x2a != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
            errline = 0x12f;
            iVar3 = elinks_strlcasecmp(paVar4->user,0xffffffff,puVar2->user,
                                       (uint)*(ushort *)&puVar2->field_0x2a,1);
            if (iVar3 != 0) goto LAB_080cd0d0;
          }
          add_to_string(&cmd,paVar4->password);
        }
        goto LAB_080cd047;
      }
      __src = puVar2->password;
      if (assert_failed == 0) {
        if (__src == (uchar *)0x0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080cd2b8;
        }
        else {
          assert_failed = 0;
        }
        iVar3 = (uint)uVar1 + cmd.length;
        uVar7 = cmd.length + 0xffU & 0xffffff00;
        size = iVar3 + 0x100U & 0xffffff00;
        if (uVar7 < size) {
          puVar8 = (uchar *)mem_realloc(cmd.source,size);
          if (puVar8 == (uchar *)0x0) goto LAB_080cd047;
          cmd.source = puVar8;
          memset(puVar8 + uVar7,0,size - uVar7);
        }
        if (cmd.source != (uchar *)0x0) {
          memcpy(cmd.source + cmd.length,__src,(uint)uVar1);
          cmd.source[iVar3] = '\0';
          cmd.length = iVar3;
        }
      }
      else {
LAB_080cd2b8:
        assert_failed = 0;
      }
LAB_080cd047:
      add_crlf_to_string(&cmd);
      if (assert_failed == 0) {
        uVar7 = 5;
      }
      else {
        uVar7 = 0xfffe795d;
      }
      assert_failed = 0;
      state.syserr = 0;
      state.basic = uVar7;
      send_cmd(conn_00,&cmd,ftp_pass_info,state);
      return;
    }
    if (assert_failed == 0) {
      uVar7 = 0xfffe795c;
      goto LAB_080cd105;
    }
  }
  else if (assert_failed == 0) {
    uVar7 = 0xfffe7833;
    goto LAB_080cd105;
  }
  uVar7 = 0xfffe795d;
LAB_080cd105:
  assert_failed = 0;
  state_01.syserr = 0;
  state_01.basic = uVar7;
  abort_connection(conn_00,state_01);
  return;
}



// WARNING: Unknown calling convention

void ftp_got_info(socket *socket,read_buffer *rb)

{
  connection *conn_00;
  connection_state state;
  connection_state state_00;
  int iVar1;
  int response;
  uint uVar2;
  connection *conn;
  undefined4 local_24;
  undefined4 local_20;
  
  conn_00 = (connection *)socket->conn;
  iVar1 = get_ftp_response(conn_00,rb,0,(sockaddr_storage *)0x0);
  if (iVar1 == -1) {
    connection_state((connection_basic_state)&local_24);
    state_00.syserr = local_20;
    state_00.basic = local_24;
    abort_connection(conn_00,state_00);
  }
  else if (iVar1 == 0) {
    read_from_socket(conn_00->socket,rb,conn_00->state,ftp_got_info);
  }
  else {
    if (iVar1 == 0xdc) {
      ftp_got_user_info(socket,rb);
      return;
    }
    if (assert_failed == 0) {
      uVar2 = 0xfffe7833;
    }
    else {
      uVar2 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar2;
    retry_connection(conn_00,state);
  }
  return;
}



// WARNING: Unknown calling convention

ftp_file_info * parse_ftp_winnt_response(ftp_file_info *info,uchar *src,int len)

{
  byte *end_00;
  byte bVar1;
  uchar uVar2;
  ulonglong uVar3;
  uchar *puVar4;
  uint uVar5;
  uint uVar6;
  time_t tVar7;
  uchar *pos;
  uchar *pos_1;
  int iVar8;
  uchar *end;
  tm *ptVar9;
  uint local_6c;
  int local_68;
  tm mtime;
  
  if (len < 0x28) {
    return (ftp_file_info *)0x0;
  }
  end_00 = src + len;
  (info->name).source = src + 0x27;
  (info->name).length = (int)(end_00 + (-0x27 - (int)src));
  ptVar9 = &mtime;
  for (iVar8 = 0xb; iVar8 != 0; iVar8 = iVar8 + -1) {
    ptVar9->tm_sec = 0;
    ptVar9 = (tm *)&ptVar9->tm_min;
  }
  mtime.tm_isdst = -1;
  if ((src < end_00) && (bVar1 = *src, (byte)(bVar1 - 0x30) < 10)) {
    local_6c = 0;
    local_68 = 0;
    do {
      uVar3 = (ulonglong)local_6c;
      uVar5 = (uint)(uVar3 * 10);
      uVar6 = bVar1 - 0x30;
      local_6c = uVar6 + uVar5;
      local_68 = ((int)uVar6 >> 0x1f) + (int)(uVar3 * 10 >> 0x20) + local_68 * 10 +
                 (uint)CARRY4(uVar6,uVar5);
      src = src + 1;
      if (end_00 <= src) break;
      bVar1 = *src;
    } while ((byte)(bVar1 - 0x30) < 10);
    if (((0 < local_68) || ((-1 < local_68 && (0xc < local_6c)))) ||
       ((local_68 < 1 && ((local_68 < 0 || (local_6c == 0)))))) {
      local_6c = 0xffffffff;
    }
  }
  else {
    local_6c = 0xffffffff;
  }
  if (end_00 <= src + 2) {
    return (ftp_file_info *)0x0;
  }
  if (*src != 0x2d) {
    return (ftp_file_info *)0x0;
  }
  src = src + 1;
  mtime.tm_mon = local_6c;
  mtime.tm_mday = parse_day(&src,end_00);
  if (end_00 <= src + 2) {
    return (ftp_file_info *)0x0;
  }
  if (*src != '-') {
    return (ftp_file_info *)0x0;
  }
  src = src + 1;
  mtime.tm_year = parse_year(&src,end_00);
  if (end_00 <= src) {
    return (ftp_file_info *)0x0;
  }
  if (mtime.tm_year == -1) {
    return (ftp_file_info *)0x0;
  }
  while (*src == ' ') {
    src = src + 1;
    if (end_00 <= src) {
      return (ftp_file_info *)0x0;
    }
  }
  iVar8 = parse_time(&src,&mtime,end_00);
  if (iVar8 == 0) {
    return (ftp_file_info *)0x0;
  }
  tVar7 = mktime((tm *)&mtime);
  info->mtime = tVar7;
  do {
    puVar4 = src;
    if (end_00 <= src) break;
    uVar2 = *src;
    src = src + 1;
  } while (uVar2 != ' ');
  do {
    src = puVar4;
    if (end_00 <= src) {
      return (ftp_file_info *)0x0;
    }
    uVar2 = *src;
    puVar4 = src + 1;
  } while (uVar2 == ' ');
  if (uVar2 == '<') {
    info->type = FTP_FILE_DIRECTORY;
    info->permissions = 0x1ed;
  }
  else if ((byte)(uVar2 - 0x30) < 10) {
    info->type = FTP_FILE_PLAINFILE;
    local_6c = 0;
    local_68 = 0;
    for (; (src < end_00 && ((byte)(*src - 0x30) < 10)); src = src + 1) {
      uVar3 = (ulonglong)local_6c;
      uVar5 = (uint)(uVar3 * 10);
      uVar6 = *src - 0x30;
      local_6c = uVar6 + uVar5;
      local_68 = ((int)uVar6 >> 0x1f) + (int)(uVar3 * 10 >> 0x20) + local_68 * 10 +
                 (uint)CARRY4(uVar6,uVar5);
    }
    if (local_68 < 0) {
      local_6c = 0xffffffff;
      local_68 = -1;
    }
    *(uint *)&info->size = local_6c;
    *(int *)((int)&info->size + 4) = local_68;
    info->permissions = 0x1a4;
  }
  else {
    info->type = FTP_FILE_UNKNOWN;
  }
  return info;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

ftp_file_info * parse_ftp_file_info(ftp_file_info *info,uchar *src,int len)

{
  ftp_file_type fVar1;
  ulonglong uVar2;
  void *pvVar3;
  byte *pbVar4;
  uchar *pos;
  tm *now;
  time_t tVar5;
  byte *pbVar6;
  uint uVar7;
  uint uVar8;
  ftp_file_info *pfVar9;
  tm *ptVar10;
  time_t tVar11;
  int perms;
  byte bVar12;
  int pos_1;
  uchar *pos_3;
  int iVar13;
  int iVar14;
  uchar *end;
  uchar *end_1;
  mode_t perms_1;
  uchar *pos_2;
  byte *pbVar15;
  tm *ptVar16;
  byte *pbVar17;
  bool bVar18;
  byte bVar19;
  uint local_8c;
  int local_88;
  undefined4 local_68;
  uint local_64;
  tm mtime;
  time_t local_24;
  byte *local_20 [4];
  
  bVar19 = 0;
  if (assert_failed != 0) {
    assert_failed = 0;
    return (ftp_file_info *)0x0;
  }
  if (((src == (uchar *)0x0) || (info == (ftp_file_info *)0x0)) || (len < 1)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/parse.c";
    errline = 0x25d;
    elinks_internal((uchar *)"assertion info && src && len > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (ftp_file_info *)0;
    }
    bVar12 = *src;
    if (bVar12 < 0x65) goto LAB_080cd798;
LAB_080cd850:
    if (((bVar12 == 0x70) || (bVar12 == 0x73)) || (bVar12 == 0x6c)) goto LAB_080cd868;
  }
  else {
    assert_failed = 0;
    bVar12 = *src;
    if (100 < bVar12) goto LAB_080cd850;
LAB_080cd798:
    if (0x61 < bVar12) goto LAB_080cd868;
    if (bVar12 == 0x2b) {
      pbVar4 = src + len;
      pbVar15 = src + 1;
      if (pbVar4 <= pbVar15) {
        return (ftp_file_info *)0x0;
      }
      do {
        pbVar6 = (byte *)memchr(pbVar15,0x2c,(int)pbVar4 - (int)pbVar15);
        bVar19 = *pbVar15;
        pbVar15 = pbVar15 + 1;
        if (pbVar6 == (byte *)0x0) {
          pbVar6 = pbVar4;
        }
        if (bVar19 == 0x72) {
          info->type = FTP_FILE_PLAINFILE;
        }
        else if (bVar19 < 0x73) {
          if (bVar19 == 0x6d) {
            if (pbVar15 < pbVar6) {
              bVar19 = *pbVar15;
              local_64 = 0;
              if ((byte)(bVar19 - 0x30) < 10) {
                local_8c = 0;
                local_88 = 0;
                do {
                  uVar7 = (uint)((ulonglong)local_8c * 10);
                  uVar8 = bVar19 - 0x30;
                  local_64 = uVar8 + uVar7;
                  local_88 = ((int)uVar8 >> 0x1f) +
                             (int)((ulonglong)local_8c * 10 >> 0x20) + local_88 * 10 +
                             (uint)CARRY4(uVar8,uVar7);
                  pbVar15 = pbVar15 + 1;
                  if (pbVar6 <= pbVar15) break;
                  bVar19 = *pbVar15;
                  local_8c = local_64;
                } while ((byte)(bVar19 - 0x30) < 10);
                if (((0 < local_88) || (local_88 < 0)) ||
                   ((0x7fffffff < local_64 || (local_88 < 0)))) {
                  local_64 = 0xffffffff;
                }
              }
              info->mtime = local_64;
            }
          }
          else if (bVar19 < 0x6e) {
            if (bVar19 == 9) {
              if (pbVar15 < pbVar4) {
                (info->name).source = pbVar15;
                (info->name).length = (int)pbVar4 - (int)pbVar15;
                return info;
              }
            }
            else if (bVar19 == 0x2f) {
              info->type = FTP_FILE_DIRECTORY;
            }
          }
        }
        else if ((bVar19 == 0x73) && (pbVar15 < pbVar6)) {
          bVar19 = *pbVar15;
          local_8c = 0;
          local_88 = 0;
          if ((byte)(bVar19 - 0x30) < 10) {
            do {
              uVar2 = (ulonglong)local_8c;
              uVar7 = (uint)(uVar2 * 10);
              uVar8 = bVar19 - 0x30;
              local_8c = uVar8 + uVar7;
              local_88 = ((int)uVar8 >> 0x1f) + (int)(uVar2 * 10 >> 0x20) + local_88 * 10 +
                         (uint)CARRY4(uVar8,uVar7);
              pbVar15 = pbVar15 + 1;
              if (pbVar6 <= pbVar15) break;
              bVar19 = *pbVar15;
            } while ((byte)(bVar19 - 0x30) < 10);
            if (local_88 < 0) {
              local_8c = 0xffffffff;
              local_88 = -1;
            }
          }
          *(uint *)&info->size = local_8c;
          *(int *)((int)&info->size + 4) = local_88;
        }
        pbVar15 = pbVar6 + 1;
        if (pbVar4 <= pbVar15) {
          return (ftp_file_info *)0x0;
        }
        if (pbVar6 == (byte *)0x0) {
          return (ftp_file_info *)0x0;
        }
      } while( true );
    }
    if (bVar12 == 0x2d) goto LAB_080cd868;
  }
  pvVar3 = memchr(src,0x3b,len);
  if (pvVar3 == (void *)0x0) {
    if ((byte)(bVar12 - 0x30) < 10) {
      pfVar9 = parse_ftp_winnt_response(info,src,len);
      return pfVar9;
    }
LAB_080cd868:
    pbVar15 = src + len;
    pbVar4 = src + 1;
    if (((bVar12 == 100) || (bVar12 == 0x6c)) || (bVar12 == 0x2d)) {
      info->type = (uint)bVar12;
    }
    else {
      info->type = FTP_FILE_UNKNOWN;
    }
    local_68 = 0;
    ptVar16 = &mtime;
    for (iVar13 = 0xb; iVar13 != 0; iVar13 = iVar13 + -1) {
      ptVar16->tm_sec = 0;
      ptVar16 = (tm *)((int)ptVar16 + (uint)bVar19 * -8 + 4);
    }
    mtime.tm_isdst = -1;
    local_20[0] = pbVar4;
    if (pbVar15 <= pbVar4) {
      return (ftp_file_info *)0x0;
    }
    do {
      for (; (pbVar4 < pbVar15 && (*pbVar4 != 0x20)); pbVar4 = pbVar4 + 1) {
      }
      switch(local_68) {
      case 0:
        local_68 = 1;
        if ((int)pbVar4 - (int)local_20[0] == 9) {
          if (*local_20[0] == 0x2d) {
            perms_1 = 0;
LAB_080ce024:
            if (local_20[0][1] != 0x2d) {
              if (local_20[0][1] != 0x77) goto LAB_080cd9c2;
              perms_1 = perms_1 | 0x80;
            }
            bVar12 = local_20[0][2];
            if (bVar12 == 0x73) {
              perms_1 = perms_1 | 0x800;
LAB_080ce1a8:
              perms_1 = perms_1 | 0x40;
            }
            else {
              if (0x73 < bVar12) {
                if (bVar12 != 0x78) goto LAB_080cd9c2;
                goto LAB_080ce1a8;
              }
              if (bVar12 != 0x2d) {
                if (bVar12 != 0x53) goto LAB_080cd9c2;
                perms_1 = perms_1 | 0x800;
              }
            }
            if (local_20[0][3] != 0x2d) {
              if (local_20[0][3] != 0x72) goto LAB_080cd9c2;
              perms_1 = perms_1 | 0x20;
            }
            if (local_20[0][4] != 0x2d) {
              if (local_20[0][4] != 0x77) goto LAB_080cd9c2;
              perms_1 = perms_1 | 0x10;
            }
            bVar12 = local_20[0][5];
            if (bVar12 == 0x73) {
              perms_1 = perms_1 | 0x400;
LAB_080ce1bd:
              perms_1 = perms_1 | 8;
            }
            else {
              if (0x73 < bVar12) {
                if (bVar12 != 0x78) goto LAB_080cd9c2;
                goto LAB_080ce1bd;
              }
              if (bVar12 != 0x2d) {
                if (bVar12 != 0x53) goto LAB_080cd9c2;
                perms_1 = perms_1 | 0x400;
              }
            }
            if (local_20[0][6] != 0x2d) {
              if (local_20[0][6] != 0x72) goto LAB_080cd9c2;
              perms_1 = perms_1 | 4;
            }
            if (local_20[0][7] != 0x2d) {
              if (local_20[0][7] != 0x77) goto LAB_080cd9c2;
              perms_1 = perms_1 | 2;
            }
            bVar12 = local_20[0][8];
            if (bVar12 == 0x6c) {
LAB_080ce1ee:
              perms_1 = perms_1 & 0xfffffff7 | 0x400;
            }
            else if (bVar12 < 0x6d) {
              if (bVar12 == 0x4c) goto LAB_080ce1ee;
              if (bVar12 == 0x54) {
                perms_1 = perms_1 | 0x200;
              }
              else if (bVar12 != 0x2d) goto LAB_080cd9c2;
            }
            else {
              if (bVar12 == 0x74) {
                perms_1 = perms_1 | 0x200;
              }
              else if (bVar12 != 0x78) goto LAB_080cd9c2;
              perms_1 = perms_1 | 1;
            }
          }
          else {
            perms_1 = 0x100;
            if (*local_20[0] == 0x72) goto LAB_080ce024;
LAB_080cd9c2:
            perms_1 = 0;
          }
          info->permissions = perms_1;
          local_68 = 1;
        }
        break;
      case 1:
        if ((((*(uint *)&info->size & *(uint *)((int)&info->size + 4)) == 0xffffffff) ||
            ((int)pbVar4 - (int)local_20[0] != 3)) ||
           (iVar13 = parse_month(local_20,pbVar4), iVar13 == -1)) {
          bVar12 = *local_20[0];
          if ((byte)(bVar12 - 0x30) < 10) {
            local_8c = 0;
            local_88 = 0;
            if (local_20[0] < pbVar4) {
              local_8c = 0;
              local_88 = 0;
              do {
                uVar2 = (ulonglong)local_8c;
                uVar7 = (uint)(uVar2 * 10);
                uVar8 = bVar12 - 0x30;
                local_8c = uVar8 + uVar7;
                local_88 = ((int)uVar8 >> 0x1f) + (int)(uVar2 * 10 >> 0x20) + local_88 * 10 +
                           (uint)CARRY4(uVar8,uVar7);
                local_20[0] = local_20[0] + 1;
                if (pbVar4 <= local_20[0]) break;
                bVar12 = *local_20[0];
              } while ((byte)(bVar12 - 0x30) < 10);
              if (local_88 < 0) {
                local_8c = 0xffffffff;
                local_88 = -1;
              }
            }
            *(uint *)&info->size = local_8c;
            *(int *)((int)&info->size + 4) = local_88;
          }
          else {
            *(undefined4 *)&info->size = 0xffffffff;
            *(undefined4 *)((int)&info->size + 4) = 0xffffffff;
          }
        }
        else {
          local_68 = 2;
          mtime.tm_mon = iVar13;
        }
        break;
      case 2:
        mtime.tm_mday = parse_day(local_20,pbVar4);
        local_68 = 3;
        break;
      case 3:
        if ((byte)(*local_20[0] - 0x30) < 10) {
          pvVar3 = memchr(local_20[0],0x3a,(int)pbVar4 - (int)local_20[0]);
          if (pvVar3 == (void *)0x0) {
            mtime.tm_year = parse_year(local_20,pbVar4);
          }
          else {
            iVar13 = parse_time(local_20,&mtime,pbVar4);
            if (iVar13 == 0) {
              mtime.tm_sec = 0;
              mtime.tm_min = 0;
              mtime.tm_hour = 0;
              local_68 = 4;
              break;
            }
          }
        }
        local_68 = 4;
        break;
      case 4:
        fVar1 = info->type;
        (info->name).source = local_20[0];
        iVar13 = (int)pbVar15 - (int)local_20[0];
        (info->name).length = iVar13;
        if (fVar1 == FTP_FILE_DIRECTORY) {
          if ((0 < iVar13) && (local_20[0][iVar13 + -1] == 0x2f)) {
            (info->name).length = iVar13 + -1;
          }
        }
        else {
          if (fVar1 == FTP_FILE_SYMLINK) goto joined_r0x080cde47;
          if ((((fVar1 == FTP_FILE_PLAINFILE) && ((*(byte *)&info->permissions & 0x49) != 0)) &&
              (0 < iVar13)) && (local_20[0][iVar13 + -1] == 0x2a)) {
            (info->name).length = iVar13 + -1;
          }
        }
        goto LAB_080cda01;
      }
      while( true ) {
        if (pbVar15 <= pbVar4) {
          return (ftp_file_info *)0x0;
        }
        local_20[0] = pbVar4;
        if (*pbVar4 != 0x20) break;
        pbVar4 = pbVar4 + 1;
      }
    } while( true );
  }
  pbVar15 = src + len;
  local_20[0] = src;
  pbVar4 = (byte *)memchr(src,0x3b,len);
  if (pbVar4 == (byte *)0x0) {
    return (ftp_file_info *)0x0;
  }
  (info->name).source = src;
  iVar13 = (int)pbVar4 - (int)local_20[0];
  (info->name).length = iVar13;
  if (4 < iVar13) {
    iVar14 = 4;
    bVar18 = pbVar4 + -4 == (byte *)0x0;
    pbVar6 = pbVar4 + -4;
    pbVar17 = &DAT_0813297d;
    do {
      if (iVar14 == 0) break;
      iVar14 = iVar14 + -1;
      bVar18 = *pbVar6 == *pbVar17;
      pbVar6 = pbVar6 + (uint)bVar19 * -2 + 1;
      pbVar17 = pbVar17 + (uint)bVar19 * -2 + 1;
    } while (bVar18);
    if (bVar18) {
      info->type = FTP_FILE_DIRECTORY;
      (info->name).length = iVar13 + -4;
      goto LAB_080cdf41;
    }
  }
  info->type = FTP_FILE_PLAINFILE;
LAB_080cdf41:
  if (pbVar15 <= pbVar4) {
    return (ftp_file_info *)0x0;
  }
  bVar19 = *pbVar4;
  local_20[0] = pbVar4;
  while (bVar19 != 0x20) {
    local_20[0] = local_20[0] + 1;
    if (pbVar15 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
    bVar19 = *local_20[0];
  }
  do {
    local_20[0] = local_20[0] + 1;
    if (pbVar15 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
  } while (*local_20[0] == 0x20);
  while (*local_20[0] != 0x20) {
    local_20[0] = local_20[0] + 1;
    if (pbVar15 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
  }
  do {
    local_20[0] = local_20[0] + 1;
    if (pbVar15 <= local_20[0]) {
      return (ftp_file_info *)0x0;
    }
  } while (*local_20[0] == 0x20);
  tVar11 = parse_date(local_20,pbVar15,1,0);
  info->mtime = tVar11;
  pbVar4 = local_20[0];
  if (tVar11 == 0) {
    return (ftp_file_info *)0x0;
  }
  do {
    local_20[0] = pbVar4;
    if (pbVar15 <= local_20[0]) break;
    pbVar4 = local_20[0] + 1;
  } while (*local_20[0] == 0x20);
  do {
    pbVar4 = local_20[0];
    if (pbVar15 <= local_20[0]) break;
    bVar19 = *local_20[0];
    local_20[0] = local_20[0] + 1;
  } while (bVar19 != 0x20);
  do {
    local_20[0] = pbVar4;
    if (pbVar15 <= local_20[0]) {
      return info;
    }
    pbVar4 = local_20[0] + 1;
  } while (*local_20[0] == 0x20);
  pbVar4 = (byte *)memchr(local_20[0],0x28,(int)pbVar15 - (int)local_20[0]);
  if (pbVar4 == (byte *)0x0) {
    return info;
  }
  if (pbVar15 <= pbVar4) {
    return info;
  }
  pbVar6 = pbVar4 + 1;
  local_20[0] = pbVar6;
  pvVar3 = memchr(pbVar6,0x29,(int)pbVar15 - (int)pbVar6);
  if (pvVar3 == (void *)0x0) {
    return info;
  }
  iVar13 = 0;
  perms = 0;
  do {
    if ((int)pvVar3 - (int)pbVar6 <= iVar13) {
LAB_080ce27c:
      info->permissions = perms;
      return info;
    }
    bVar19 = pbVar4[iVar13 + 1];
    if (bVar19 == 0x45) {
      perms = perms | 1;
    }
    else if (bVar19 < 0x46) {
      if (bVar19 == 0x2c) {
        perms = perms << 3;
      }
      else {
        if (bVar19 != 0x44) {
LAB_080ce27a:
          perms = 0;
          goto LAB_080ce27c;
        }
LAB_080ce299:
        perms = perms | 2;
      }
    }
    else {
      if (bVar19 != 0x52) {
        if (bVar19 != 0x57) goto LAB_080ce27a;
        goto LAB_080ce299;
      }
      perms = perms | 4;
    }
    iVar13 = iVar13 + 1;
  } while( true );
joined_r0x080cde47:
  if (pbVar4 == (byte *)0x0) {
    pbVar6 = (info->symlink).source;
LAB_080cdeb9:
    if (pbVar6 == (byte *)0x0) {
      return (ftp_file_info *)0x0;
    }
    iVar13 = (info->name).length;
    if ((0 < iVar13) && ((info->name).source[iVar13 + -1] == '@')) {
      (info->name).length = iVar13 + -1;
    }
    iVar13 = (info->symlink).length;
    if ((0 < iVar13) && ((info->symlink).source[iVar13 + -1] == '/')) {
      (info->symlink).length = iVar13 + -1;
    }
LAB_080cda01:
    if (mtime.tm_year == 0) {
      local_24 = time((time_t *)0x0);
      ptVar10 = localtime(&local_24);
      mtime.tm_year = ptVar10->tm_year;
      if (ptVar10->tm_mon < mtime.tm_mon) {
        mtime.tm_year = mtime.tm_year + -1;
      }
    }
    tVar5 = mktime((tm *)&mtime);
    info->field_0x20 = info->field_0x20 | 1;
    info->mtime = tVar5;
    return info;
  }
  if (pbVar15 <= pbVar4 + 3) {
    pbVar6 = (info->symlink).source;
    goto LAB_080cdeb9;
  }
  bVar18 = pbVar15 == pbVar4 + 3;
  iVar13 = 4;
  pbVar6 = pbVar4;
  pbVar17 = &DAT_081326ac;
  do {
    if (iVar13 == 0) break;
    iVar13 = iVar13 + -1;
    bVar18 = *pbVar6 == *pbVar17;
    pbVar6 = pbVar6 + (uint)bVar19 * -2 + 1;
    pbVar17 = pbVar17 + (uint)bVar19 * -2 + 1;
  } while (bVar18);
  if (bVar18) {
    pbVar6 = pbVar4 + 4;
    (info->symlink).source = pbVar6;
    (info->symlink).length = (int)(pbVar15 + (-4 - (int)pbVar4));
    (info->name).length = (int)pbVar4 - (int)local_20[0];
    goto LAB_080cdeb9;
  }
  pbVar4 = (byte *)memchr(pbVar4 + 1,0x20,(int)pbVar15 - (int)pbVar4);
  goto joined_r0x080cde47;
}



// WARNING: Unknown calling convention

void free_blacklist(void)

{
  void **ppvVar1;
  xlist_head *head;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  xlist_head *next;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)blacklist.next;
  if ((list_head_elinks *)blacklist.next != &blacklist) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &blacklist);
  }
  plVar2 = (list_head_elinks *)blacklist.prev;
  if ((list_head_elinks *)blacklist.prev != plVar3) {
    do {
      ppvVar1 = &plVar2->prev;
      plVar2 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != plVar3);
  }
                    // WARNING: Load size is inaccurate
  plVar2 = *blacklist.next;
  p = (list_head_elinks *)blacklist.next;
  if ((list_head_elinks *)blacklist.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  return;
}



// WARNING: Unknown calling convention

blacklist_entry * get_blacklist_entry(uri *uri)

{
  int iVar1;
  blacklist_entry *entry;
  blacklist_entry *pbVar2;
  
  if (assert_failed == 0) {
    if ((uri == (uri *)0x0) || (*(short *)&uri->field_0x2e == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/blacklist.c";
      errline = 0x21;
      elinks_internal((uchar *)"assertion uri && uri->hostlen > 0 failed!");
      pbVar2 = (blacklist_entry *)blacklist.next;
      if (assert_failed != 0) goto LAB_080ce3f0;
    }
    else {
      assert_failed = 0;
      pbVar2 = (blacklist_entry *)blacklist.next;
    }
    while( true ) {
      if (pbVar2 == (blacklist_entry *)&blacklist) {
        return (blacklist_entry *)0x0;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/blacklist.c";
      errline = 0x25;
      iVar1 = elinks_strlcasecmp(pbVar2->host,0xffffffff,uri->host,(uint)*(ushort *)&uri->field_0x2e
                                 ,1);
      if (iVar1 == 0) break;
      pbVar2 = pbVar2->next;
    }
  }
  else {
LAB_080ce3f0:
    assert_failed = 0;
    pbVar2 = (blacklist_entry *)0x0;
  }
  return pbVar2;
}



// WARNING: Unknown calling convention

blacklist_flags get_blacklist_flags(uri *uri)

{
  blacklist_entry *pbVar1;
  blacklist_flags bVar2;
  blacklist_entry *entry;
  
  pbVar1 = get_blacklist_entry(uri);
  bVar2 = SERVER_BLACKLIST_NONE;
  if (pbVar1 != (blacklist_entry *)0x0) {
    bVar2 = pbVar1->flags;
  }
  return bVar2;
}



// WARNING: Unknown calling convention

void del_blacklist_entry(uri *uri,blacklist_flags flags)

{
  blacklist_entry *p;
  blacklist_entry *entry;
  blacklist_flags bVar1;
  
  p = get_blacklist_entry(uri);
  if ((p != (blacklist_entry *)0x0) &&
     (bVar1 = ~flags & p->flags, p->flags = bVar1, bVar1 == SERVER_BLACKLIST_NONE)) {
    p->next->prev = p->prev;
    p->prev->next = p->next;
    mem_free(p);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void add_blacklist_entry(uri *uri,blacklist_flags flags)

{
  blacklist_entry *pbVar1;
  blacklist_entry *entry;
  void **ppvVar2;
  
  pbVar1 = get_blacklist_entry(uri);
  if (pbVar1 == (blacklist_entry *)0x0) {
    ppvVar2 = (void **)mem_alloc(*(ushort *)&uri->field_0x2e + 0x10);
    if (ppvVar2 != (void **)0x0) {
      ppvVar2[2] = (void *)flags;
      safe_strncpy((uchar *)(ppvVar2 + 3),uri->host,*(ushort *)&uri->field_0x2e + 1);
      ppvVar2[1] = &blacklist;
      *ppvVar2 = blacklist.next;
      blacklist.next = ppvVar2;
      *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
    }
  }
  else {
    pbVar1->flags = pbVar1->flags | flags;
  }
  return;
}



// WARNING: Unknown calling convention

int compare_http_codes(void *key,void *element)

{
                    // WARNING: Load size is inaccurate
  return (int)key - *element;
}



// WARNING: Unknown calling convention

void http_error_document(connection *conn,int code)

{
  object *poVar1;
  uri *puVar2;
  int *data;
  
  if (assert_failed == 0) {
    if ((conn == (connection *)0x0) || (conn->uri == (uri *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/codes.c";
      errline = 0xca;
      elinks_internal((uchar *)"assertion conn && conn->uri failed!");
    }
    else {
      assert_failed = 0;
    }
  }
  data = (int *)mem_calloc(1,8);
  if (data != (int *)0x0) {
    *data = code;
    puVar2 = conn->uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    data[1] = (int)puVar2;
    add_questions_entry(show_http_error_document,data);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void show_http_error_document(session *ses,void *data)

{
  terminal *term;
  void *__key;
  undefined4 *puVar1;
  cache_entry *pcVar2;
  void *pvVar3;
  int iVar4;
  int new_charset_1;
  uchar *puVar5;
  char *pcVar6;
  string *psVar7;
  int new_charset;
  uchar *puVar8;
  size_t length;
  cache_entry *cached;
  cache_entry *cache;
  uchar *str;
  uchar *puVar9;
  uchar *puVar10;
  char *local_30;
  string string;
  
  term = ses->tab->term;
  pcVar2 = find_in_cache(*(uri **)((int)data + 4));
  cached = pcVar2;
  if ((pcVar2 != (cache_entry *)0x0) ||
     (cached = get_cache_entry(*(uri **)((int)data + 4)), cached != (cache_entry *)0x0)) {
                    // WARNING: Load size is inaccurate
    __key = *data;
    puVar1 = *(undefined4 **)((int)data + 4);
    pvVar3 = bsearch(__key,http_code,0x29,8,compare_http_codes);
    local_30 = (char *)0x0;
    if (pvVar3 != (void *)0x0) {
      local_30 = *(char **)((int)pvVar3 + 4);
    }
    if ((term != (terminal *)0x0) && (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)
       ) {
      puVar5 = get_cp_mime_name(iVar4);
      bind_textdomain_codeset("elinks",puVar5);
      current_charset = iVar4;
    }
    puVar5 = gettext((uchar *)"HTTP error %03d");
    puVar5 = asprintfa((char *)puVar5,__key);
    pcVar6 = "Unknown error";
    if (local_30 != (char *)0x0) {
      pcVar6 = local_30;
    }
    psVar7 = init_string(&string);
    if (psVar7 == (string *)0x0) {
      if (puVar5 != (uchar *)0x0) {
        mem_free(puVar5);
      }
    }
    else {
      puVar9 = puVar5;
      puVar10 = puVar5;
      add_format_to_string
                (&string,(uchar *)
                         "<html>\n <head><title>%s</title></head>\n <body>\n  <h1 align=\"left\">%s: %s</h1>\n  <hr />\n  <p>\n"
                 ,puVar5,puVar5,pcVar6);
      if ((term != (terminal *)0x0) &&
         (iVar4 = get_terminal_codepage(term), iVar4 != current_charset)) {
        puVar8 = get_cp_mime_name(iVar4);
        bind_textdomain_codeset("elinks",puVar8);
        current_charset = iVar4;
      }
      puVar8 = gettext((uchar *)
                       "  An error occurred on the server while fetching the document you\n  requested. However, the server did not send back any explanation of what\n  happened, so it is unknown what went wrong. Please contact the web\n  server administrator about this, if you believe that this error should\n  not occur since it is not a nice behaviour from the web server at all\n  and indicates that there is some much deeper problem with the web server\n  software.\n"
                      );
      add_format_to_string(&string,puVar8,puVar9,puVar10,pcVar6);
      add_format_to_string
                (&string,(uchar *)"  </p>\n  <p>\n  URI: <a href=\"%s\">%s</a>\n",*puVar1,*puVar1);
      add_format_to_string(&string,(uchar *)" </p>\n <hr />\n </body>\n</html>\n");
      if (puVar5 != (uchar *)0x0) {
        mem_free(puVar5);
      }
      if (string.source != (uchar *)0x0) {
        iVar4 = get_terminal_codepage(term);
        if (pcVar2 != (cache_entry *)0x0) {
          delete_entry_content(cached);
        }
        if (cached->content_type != (uchar *)0x0) {
          mem_free(cached->content_type);
        }
        puVar5 = stracpy((uchar *)"text/html");
        cached->content_type = puVar5;
        if (cached->head != (uchar *)0x0) {
          mem_free(cached->head);
        }
        puVar5 = get_cp_mime_name(iVar4);
        puVar5 = straconcat((uchar *)"\r\nContent-Type: text/html; charset=",puVar5,&DAT_081352f5,0)
        ;
        cached->head = puVar5;
        length = strlen((char *)string.source);
        add_fragment(cached,0,string.source,length);
        mem_free(string.source);
        draw_formatted(ses,1);
      }
    }
  }
  done_uri(*(uri **)((int)data + 4));
  mem_free(data);
  return;
}



// WARNING: Unknown calling convention

void done_http(void)

{
  void *p;
  void *p_1;
  void *p_2;
  
  if (proxy_auth.realm != (uchar *)0x0) {
    mem_free(proxy_auth.realm);
  }
  if (proxy_auth.nonce != (uchar *)0x0) {
    mem_free(proxy_auth.nonce);
  }
  if (proxy_auth.opaque != (uchar *)0x0) {
    mem_free(proxy_auth.opaque);
  }
  free_blacklist();
  if (accept_charset != (uchar *)0x0) {
    mem_free(accept_charset);
  }
  return;
}



connection_state __regparm3 connection_state(connection_basic_state basic)

{
  int in_EDX;
  connection_state cVar1;
  connection_state cVar2;
  
  if (assert_failed == 0) {
    assert_failed = (int)(in_EDX == -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h";
      errline = 0x84;
      elinks_internal((uchar *)"assertion basic != S_ERRNO failed!");
      if (assert_failed != 0) goto LAB_080ce978;
    }
    *(undefined4 *)(basic + S_SENT) = 0;
    *(int *)basic = in_EDX;
    cVar1.syserr = in_EDX;
    cVar1.basic = basic;
    return cVar1;
  }
LAB_080ce978:
  assert_failed = 0;
  *(undefined4 *)(basic + S_SENT) = 0;
  *(undefined4 *)basic = 0xfffe795d;
  cVar2.syserr = 0xfffe795d;
  cVar2.basic = basic;
  return cVar2;
}



void __regparm3 http_end_request(connection *conn,connection_state state,int notrunc)

{
  connection_state state_00;
  connection_state state_01;
  option_value *poVar1;
  undefined4 in_ECX;
  undefined4 uVar2;
  undefined4 uVar3;
  
  shutdown_connection_stream(conn);
  if ((((conn->info != (void *)0x0) && (*(int *)((int)conn->info + 0x14) == 0)) &&
      (conn->socket->ssl == (void *)0x0)) &&
     ((poVar1 = get_opt_(), poVar1->tree == (list_head_elinks *)0x0 ||
      (conn->uri->post == (uchar *)0x0)))) {
    if ((notrunc == -100000) && (conn->cached != (cache_entry *)0x0)) {
      uVar3 = 0xffffffff;
      uVar2 = 0xffffffff;
      if (state.basic == S_WAIT) {
        uVar3 = *(undefined4 *)&conn->from;
        uVar2 = *(undefined4 *)((int)&conn->from + 4);
      }
      normalize_cache_entry(conn->cached,CONCAT44(uVar2,uVar3));
    }
    state_01.syserr = in_ECX;
    state_01.basic = notrunc;
    set_connection_state(conn,state_01);
    add_keepalive_connection(conn,60000,(_func_void_connection_ptr *)0x0);
    return;
  }
  state_00.syserr = in_ECX;
  state_00.basic = notrunc;
  abort_connection(conn,state_00);
  return;
}



// WARNING: Unknown calling convention

uchar * decompress_data(connection *conn,uchar *data,int len,int *new_len)

{
  void *pvVar1;
  int did_read;
  int written;
  uchar *puVar2;
  int iVar3;
  ssize_t sVar4;
  int *piVar5;
  stream_encoded *psVar6;
  bool bVar7;
  int *local_34;
  uchar *local_28;
  uchar *local_24;
  size_t local_20;
  
  pvVar1 = conn->info;
  if (*(int *)((int)pvVar1 + 0x18) == -2) {
    bVar7 = *(int *)((int)pvVar1 + 0x1c) == -2;
    local_34 = (int *)((int)pvVar1 + 0x1c);
  }
  else {
    local_34 = (int *)((int)pvVar1 + 0x18);
    bVar7 = *(int *)((int)pvVar1 + 0x18) == 0;
  }
  local_28 = data;
  if (conn->content_encoding == ENCODING_NONE) {
    *new_len = len;
    if (0 < *local_34) {
      *local_34 = *local_34 - len;
    }
  }
  else {
    *new_len = 0;
    if ((conn->stream_pipes[0] == -1) &&
       (((iVar3 = c_pipe(conn->stream_pipes), iVar3 < 0 ||
         (iVar3 = set_nonblocking_fd(conn->stream_pipes[0]), iVar3 < 0)) ||
        (iVar3 = set_nonblocking_fd(conn->stream_pipes[1]), iVar3 < 0)))) {
LAB_080cec6e:
      local_28 = (uchar *)0x0;
    }
    else {
      local_24 = (uchar *)0x0;
      local_20 = len;
      do {
        if (bVar7) {
LAB_080ceb18:
          bVar7 = true;
        }
        else {
          iVar3 = conn->stream_pipes[1];
          do {
            sVar4 = write(iVar3,local_28,local_20);
            if (sVar4 != -1) {
              if (-1 < sVar4) {
                local_28 = local_28 + sVar4;
                local_20 = local_20 - sVar4;
                if (0 < *local_34) {
                  *local_34 = *local_34 - sVar4;
                }
                if (*(int *)((int)pvVar1 + 0x18) == 0) goto LAB_080ceb18;
                if (local_20 == 0) {
                  return local_24;
                }
              }
              break;
            }
            piVar5 = __errno_location();
          } while (*piVar5 == 4);
        }
        if (conn->stream == (stream_encoded *)0x0) {
          psVar6 = open_encoded(conn->stream_pipes[0],conn->content_encoding);
          conn->stream = psVar6;
          if (psVar6 == (stream_encoded *)0x0) goto LAB_080cec6e;
        }
        puVar2 = (uchar *)mem_realloc(local_24,*new_len + 0xa0000);
        if (puVar2 == (uchar *)0x0) break;
        iVar3 = read_encoded(conn->stream,puVar2 + *new_len,0xa0000);
        local_24 = puVar2;
        if (iVar3 < 0) goto LAB_080cebf3;
        *new_len = *new_len + iVar3;
      } while ((iVar3 == 0xa0000) || (local_20 != 0));
      if (!bVar7) {
        return local_24;
      }
LAB_080cebf3:
      shutdown_connection_stream(conn);
      local_28 = local_24;
    }
  }
  return local_28;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Unknown calling convention

http_connection_info * init_http_connection_info(connection *conn,int major,int minor,int close)

{
  http_connection_info *phVar1;
  http_connection_info *http;
  blacklist_flags bVar2;
  option_value *poVar3;
  uint uVar4;
  int local_14 [2];
  
  uVar4 = 0x24;
  phVar1 = (http_connection_info *)mem_calloc(1,0x24);
  if (phVar1 != (http_connection_info *)0x0) {
    (phVar1->sent_version).major = major;
    (phVar1->sent_version).minor = minor;
    phVar1->close = close;
    if (conn->proxied_uri->protocol == 4) {
      bVar2 = phVar1->bl_flags;
    }
    else {
      bVar2 = get_blacklist_flags(conn->proxied_uri);
      phVar1->bl_flags = bVar2;
    }
    if (((bVar2 & SERVER_BLACKLIST_HTTP10) != SERVER_BLACKLIST_NONE) ||
       (poVar3 = get_opt_(), poVar3->tree != (list_head_elinks *)0x0)) {
      (phVar1->sent_version).major = 1;
      (phVar1->sent_version).minor = 0;
    }
    if (conn->info != (void *)0x0) {
      mem_free(conn->info);
    }
    conn->info = phVar1;
    return phVar1;
  }
  connection_state((connection_basic_state)local_14);
  http_end_request(conn,(connection_state)((ulonglong)uVar4 << 0x20),local_14[0]);
  return (http_connection_info *)0x0;
}



// WARNING: Unknown calling convention

void read_http_data_done(connection *conn)

{
  uint in_stack_ffffffd8;
  uint code;
  
  if (((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0) &&
     (code = *(uint *)((int)conn->info + 0x20), 399 < (int)code)) {
    http_error_document(conn,code);
    in_stack_ffffffd8 = code;
  }
  if (assert_failed == 0) {
    assert_failed = 0;
    http_end_request(conn,(connection_state)((ulonglong)in_stack_ffffffd8 << 0x20),-100000);
    return;
  }
  assert_failed = 0;
  http_end_request(conn,(connection_state)((ulonglong)in_stack_ffffffd8 << 0x20),-0x186a3);
  return;
}



// WARNING: Unknown calling convention

void read_more_http_data(connection *conn,read_buffer *rb,int already_got_anything)

{
  connection_state state;
  int iVar1;
  connection_basic_state cVar2;
  
  if (already_got_anything == 0) {
    cVar2 = (conn->state).basic;
    iVar1 = (conn->state).syserr;
  }
  else if (assert_failed == 0) {
    assert_failed = 0;
    cVar2 = S_TRANS;
    iVar1 = 0;
  }
  else {
    assert_failed = 0;
    cVar2 = S_INTERNAL;
    iVar1 = 0;
  }
  state.syserr = iVar1;
  state.basic = cVar2;
  read_from_socket(conn->socket,rb,state,read_http_data);
  return;
}



// WARNING: Unknown calling convention

void read_http_data(socket *socket,read_buffer *rb)

{
  off_t *poVar1;
  byte bVar2;
  connection *conn_00;
  socket_state sVar3;
  connection_state state;
  uchar *puVar4;
  int iVar5;
  int ret;
  int l_3;
  int l_1;
  uint uVar6;
  uchar *data_00;
  int *piVar7;
  uchar *data;
  uchar *data_1;
  int l;
  connection *conn;
  int len;
  int len_1;
  uint uVar8;
  bool bVar9;
  uchar *local_3c;
  int local_34;
  void *local_30;
  uchar *local_20 [4];
  
  conn_00 = (connection *)socket->conn;
  local_30 = conn_00->info;
  if (socket->state == SOCKET_CLOSED) {
    if (conn_00->content_encoding == ENCODING_NONE) goto LAB_080cf0b7;
    *(undefined4 *)((int)local_30 + 0x18) = 0;
    local_30 = conn_00->info;
    uVar6 = *(uint *)((int)local_30 + 0x18);
LAB_080cefe4:
    uVar8 = rb->length;
    if ((-1 < (int)uVar6) && ((int)uVar6 < (int)uVar8)) {
      uVar8 = uVar6;
    }
    poVar1 = &conn_00->received;
    uVar6 = *(uint *)poVar1;
    *(uint *)poVar1 = *(int *)poVar1 + uVar8;
    piVar7 = (int *)((int)&conn_00->received + 4);
    *piVar7 = *piVar7 + ((int)uVar8 >> 0x1f) + (uint)CARRY4(uVar6,uVar8);
    puVar4 = decompress_data(conn_00,rb->data,uVar8,(int *)local_20);
    iVar5 = add_fragment(conn_00->cached,conn_00->from,puVar4,(ssize_t)local_20[0]);
    if (iVar5 == 1) {
      conn_00->tries = 0;
    }
    if ((puVar4 != (uchar *)0x0) && (rb->data != puVar4)) {
      mem_free(puVar4);
    }
    poVar1 = &conn_00->from;
    uVar6 = *(uint *)poVar1;
    *(uchar **)poVar1 = local_20[0] + *(int *)poVar1;
    piVar7 = (int *)((int)&conn_00->from + 4);
    *piVar7 = *piVar7 + ((int)local_20[0] >> 0x1f) + (uint)CARRY4(uVar6,(uint)local_20[0]);
    kill_buffer_data(rb,uVar8);
    local_3c = local_20[0];
    if ((*(int *)((int)local_30 + 0x18) == 0) &&
       ((sVar3 = conn_00->socket->state, sVar3 == SOCKET_CLOSED || (sVar3 == SOCKET_RETRY_ONCLOSE)))
       ) {
LAB_080cf0b7:
      read_http_data_done(conn_00);
      return;
    }
LAB_080cf088:
    uVar6 = (uint)(local_3c != (uchar *)0x0);
    if (uVar6 == 1) {
      read_more_http_data(conn_00,rb,1);
      return;
    }
    if (uVar6 == 0) {
      read_more_http_data(conn_00,rb,0);
      return;
    }
  }
  else {
    uVar6 = *(uint *)((int)local_30 + 0x18);
    if (uVar6 != 0xfffffffe) goto LAB_080cefe4;
    puVar4 = rb->data;
    uVar6 = *(uint *)((int)local_30 + 0x1c);
    local_3c = (uchar *)0x0;
LAB_080cf1a3:
    if (uVar6 != 0xfffffffd) {
      if (uVar6 == 0xffffffff) goto LAB_080cf310;
      do {
        bVar9 = uVar6 == 0xfffffffe;
        if (bVar9) {
          uVar6 = 0;
        }
        uVar8 = rb->length;
        if ((int)uVar6 <= rb->length) {
          uVar8 = uVar6;
        }
        poVar1 = &conn_00->received;
        uVar6 = *(uint *)poVar1;
        *(uint *)poVar1 = *(int *)poVar1 + uVar8;
        piVar7 = (int *)((int)&conn_00->received + 4);
        *piVar7 = *piVar7 + ((int)uVar8 >> 0x1f) + (uint)CARRY4(uVar6,uVar8);
        data_00 = decompress_data(conn_00,puVar4,uVar8,(int *)local_20);
        iVar5 = add_fragment(conn_00->cached,conn_00->from,data_00,(ssize_t)local_20[0]);
        if (iVar5 == 1) {
          conn_00->tries = 0;
        }
        if ((data_00 != (uchar *)0x0) && (puVar4 != data_00)) {
          mem_free(data_00);
        }
        poVar1 = &conn_00->from;
        uVar6 = *(uint *)poVar1;
        *(uchar **)poVar1 = local_20[0] + *(int *)poVar1;
        piVar7 = (int *)((int)&conn_00->from + 4);
        *piVar7 = *piVar7 + ((int)local_20[0] >> 0x1f) + (uint)CARRY4(uVar6,(uint)local_20[0]);
        local_3c = local_3c + (int)local_20[0];
        kill_buffer_data(rb,uVar8);
        if (bVar9) {
          *(undefined4 *)((int)local_30 + 0x1c) = 0xfffffffd;
          break;
        }
        if ((*(int *)((int)local_30 + 0x1c) != 0) || (rb->length < 1)) goto LAB_080cf088;
        if (rb->data[0] == '\n') {
          kill_buffer_data(rb,1);
        }
        else {
          if (rb->data[0] != '\r') goto LAB_080cf0e7;
          if (rb->length == 1) goto LAB_080cf088;
          if (rb->field_0xd != '\n') goto LAB_080cf0e7;
          kill_buffer_data(rb,2);
        }
        *(undefined4 *)((int)local_30 + 0x1c) = 0xffffffff;
LAB_080cf310:
        iVar5 = rb->length;
        if (iVar5 < 1) goto LAB_080cf088;
        bVar2 = rb->data[0];
        if (bVar2 == 10) {
          local_34 = 1;
        }
        else {
          l_1 = 0;
          local_34 = 1;
          if (bVar2 != 0xd) {
            if (bVar2 < 0x20) goto LAB_080cf0e7;
            local_34 = 0;
            while( true ) {
              l_1 = local_34 + 1;
              if (iVar5 <= l_1) goto LAB_080cf088;
              bVar2 = rb->data[local_34 + 1];
              if (bVar2 == 10) {
                local_34 = local_34 + 2;
                if (local_34 == 0) goto LAB_080cf088;
                goto LAB_080cf39a;
              }
              if (bVar2 == 0xd) break;
              local_34 = l_1;
              if (bVar2 < 0x20) goto LAB_080cf0e7;
            }
            local_34 = local_34 + 2;
          }
          if (rb->data[local_34] != '\n') goto LAB_080cf0dc;
          iVar5 = iVar5 + -1;
          if (iVar5 <= l_1) goto LAB_080cf0df;
          local_34 = l_1 + 2;
LAB_080cf39a:
          if (local_34 == -1) goto LAB_080cf0e7;
        }
        piVar7 = __errno_location();
        *piVar7 = 0;
        uVar6 = strtol((char *)puVar4,(char **)local_20,0x10);
        if (((*piVar7 != 0) || (*local_20[0] == '\0')) || (local_20[0] == puVar4))
        goto LAB_080cf0e7;
        kill_buffer_data(rb,local_34);
        *(uint *)((int)local_30 + 0x1c) = uVar6;
        if (uVar6 != 0) goto LAB_080cf1a3;
        *(undefined4 *)((int)local_30 + 0x1c) = 0xfffffffe;
        uVar6 = 0xfffffffe;
      } while( true );
    }
    iVar5 = rb->length;
    if (iVar5 < 1) goto LAB_080cf088;
    bVar2 = rb->data[0];
    if (bVar2 == 10) {
      local_34 = 1;
LAB_080cf437:
      kill_buffer_data(rb,local_34);
      if (local_34 < 3) goto LAB_080cf0b7;
      uVar6 = *(uint *)((int)local_30 + 0x1c);
      goto LAB_080cf1a3;
    }
    l_1 = 0;
    local_34 = 1;
    if (bVar2 != 0xd) {
      if (bVar2 < 0x20) goto LAB_080cf0e7;
      local_34 = 0;
      while( true ) {
        l_1 = local_34 + 1;
        if (iVar5 <= l_1) goto LAB_080cf088;
        bVar2 = rb->data[local_34 + 1];
        if (bVar2 == 10) {
          local_34 = local_34 + 2;
          if (local_34 == 0) goto LAB_080cf088;
          goto LAB_080cf42e;
        }
        if (bVar2 == 0xd) break;
        local_34 = l_1;
        if (bVar2 < 0x20) goto LAB_080cf0e7;
      }
      local_34 = local_34 + 2;
    }
    if (rb->data[local_34] == '\n') {
      iVar5 = iVar5 + -1;
      if (l_1 < iVar5) {
        local_34 = l_1 + 2;
LAB_080cf42e:
        if (local_34 != -1) goto LAB_080cf437;
        goto LAB_080cf0e7;
      }
    }
    else {
LAB_080cf0dc:
      iVar5 = iVar5 + -1;
    }
LAB_080cf0df:
    if (l_1 == iVar5) goto LAB_080cf088;
LAB_080cf0e7:
    uVar6 = 0xffffffff;
  }
  if (assert_failed == 0) {
    assert_failed = (int)(uVar6 != 0xffffffff);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
      errline = 0x56c;
      elinks_internal((uchar *)"assertion ret == -1 failed: Unexpected return value: %d",uVar6);
      if (assert_failed != 0) goto LAB_080cf49a;
    }
    uVar6 = 0xfffe78fc;
  }
  else {
LAB_080cf49a:
    uVar6 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar6;
  abort_connection(conn_00,state);
  return;
}



// WARNING: Unknown calling convention

void add_url_to_http_string(string *header,uri *uri,int components)

{
  int iVar1;
  uchar *__s;
  uchar uVar2;
  uint uVar3;
  uchar *p;
  size_t __n;
  uint uVar4;
  uchar *puVar5;
  int newlength;
  size_t newsize;
  uint size;
  uchar *data;
  
  p = get_uri_string(uri,components);
  if (p != (uchar *)0x0) {
    uVar2 = *p;
    __s = p;
    while (uVar2 != '\0') {
      __n = strcspn((char *)__s," \t\r\n\\");
      if (assert_failed == 0) {
        if ((header == (string *)0x0) || ((int)__n < 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080cf568;
        }
        else {
          assert_failed = 0;
        }
        if (__n == 0) goto LAB_080cf578;
        iVar1 = __n + header->length;
        uVar4 = header->length + 0xff;
        uVar3 = uVar4 >> 8;
        uVar4 = uVar4 & 0xffffff00;
        size = iVar1 + 0x100U & 0xffffff00;
        if (uVar4 <= size && size + uVar3 * -0x100 != 0) {
          puVar5 = (uchar *)mem_realloc(header->source,size);
          if (puVar5 == (uchar *)0x0) goto LAB_080cf578;
          header->source = puVar5;
          memset(puVar5 + uVar4,0,size + uVar3 * -0x100);
        }
        if (header->source == (uchar *)0x0) goto LAB_080cf578;
        memcpy(header->source + header->length,__s,__n);
        header->source[iVar1] = '\0';
        header->length = iVar1;
        uVar2 = __s[__n];
      }
      else {
LAB_080cf568:
        assert_failed = 0;
LAB_080cf578:
        uVar2 = __s[__n];
      }
      if (uVar2 == '\0') break;
      if (uVar2 == '\\') {
        add_char_to_string(header,'/');
      }
      else {
        add_to_string(header,"%20");
      }
      __s = __s + __n + 1;
      uVar2 = *__s;
    }
    mem_free(p);
  }
  return;
}



// WARNING: Unknown calling convention

void http_got_header(socket *socket,read_buffer *rb)

{
  int iVar1;
  byte *pbVar2;
  uchar uVar3;
  uchar uVar4;
  connection *conn;
  byte *pbVar5;
  uri *uri_00;
  socket_state sVar6;
  connection_state state;
  connection_state state_00;
  connection_state state_01;
  connection_state state_02;
  connection_state state_03;
  connection_state state_04;
  connection_state state_05;
  connection_state state_06;
  connection_state state_07;
  connection_state state_08;
  connection_state state_09;
  int i;
  int iVar7;
  uint uVar8;
  option_value *poVar9;
  uchar *puVar10;
  char *pcVar11;
  uchar *head;
  cache_entry *pcVar12;
  int f;
  int *piVar13;
  int l;
  uchar *puVar14;
  uchar *old_tag;
  uchar *realm_3;
  time_t seconds;
  byte *pbVar15;
  uchar *opaque;
  long lVar16;
  byte bVar17;
  uint uVar18;
  progress *ppVar19;
  uri *uri_01;
  void *p;
  uchar *server;
  uri *uri;
  uchar a1;
  uchar *head_1;
  uchar *puVar20;
  char *pcVar21;
  int h2;
  uchar *new_tag;
  cache_entry *cached;
  int use_get_method;
  uchar *realm;
  uint uVar22;
  byte *pbVar23;
  byte *pbVar24;
  uchar *cookie;
  int q;
  uchar **ppuVar25;
  uchar **s;
  stream_encoding file_encoding;
  uchar *nonce;
  stream_encoding sVar26;
  time_t expires;
  byte bVar27;
  int local_70;
  int local_6c;
  int local_50;
  int local_4c;
  uint local_48;
  int local_44;
  undefined4 local_40;
  timeval_T max_age;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar27 = 0;
  conn = (connection *)socket->conn;
  pbVar5 = (byte *)conn->info;
  uri_00 = conn->proxied_uri;
  if ((conn->state).basic == S_PROC) {
    if (assert_failed != 0) goto LAB_080cf73f;
    local_48 = 7;
  }
  else {
    if (assert_failed == 0) {
      local_48 = 6;
      sVar6 = socket->state;
      goto joined_r0x080cfbc8;
    }
LAB_080cf73f:
    local_48 = 0xfffe795d;
  }
  sVar6 = socket->state;
joined_r0x080cfbc8:
  if (sVar6 == SOCKET_CLOSED) {
    assert_failed = 0;
    if ((conn->tries == 0) && (uri_00->host != (uchar *)0x0)) {
      if ((*pbVar5 & 2) == 0) {
        add_blacklist_entry(uri_00,SERVER_BLACKLIST_NO_CHARSET);
        conn->tries = -1;
      }
      else {
        del_blacklist_entry(uri_00,SERVER_BLACKLIST_NO_CHARSET);
      }
    }
    if (assert_failed == 0) {
      uVar8 = 0xfffe7959;
    }
    else {
      uVar8 = 0xfffe795d;
    }
    assert_failed = 0;
    state_02.syserr = 0;
    state_02.basic = uVar8;
    retry_connection(conn,state_02);
    return;
  }
  assert_failed = 0;
  puVar14 = rb->data;
  socket->state = SOCKET_RETRY_ONCLOSE;
  local_6c = 0;
  local_70 = 9;
  local_50 = 200;
LAB_080cf788:
  iVar7 = rb->length;
  if (iVar7 < 5) {
LAB_080cf790:
    local_4c = 0;
    if (0 < iVar7) {
      do {
        uVar3 = rb->data[local_4c];
        iVar1 = local_4c + 1;
        uVar4 = rb->data[local_4c + 1];
        if (uVar3 == '\0') {
          rb->data[local_4c] = ' ';
          iVar7 = rb->length;
        }
        else if ((uVar4 == '\n') && (uVar3 == '\n')) {
          if (local_4c < iVar7 + -1) goto code_r0x080cf841;
        }
        else if ((uVar3 == '\r') && ((local_4c < iVar7 + -3 && (uVar4 != '\r')))) {
          if (uVar4 != '\n') goto LAB_080cf916;
          if (rb->data[local_4c + 2] == '\r') {
            if (rb->data[local_4c + 3] != '\n') goto LAB_080cf916;
            local_4c = local_4c + 4;
            goto LAB_080cf847;
          }
        }
        local_4c = iVar1;
        if (iVar7 <= iVar1) break;
      } while( true );
    }
    goto LAB_080cf7bc;
  }
  iVar7 = c_strncasecmp((char *)puVar14,"HTTP/",5);
  if (iVar7 == 0) {
    iVar7 = rb->length;
    goto LAB_080cf790;
  }
  goto LAB_080cf950;
LAB_080cfc8c:
  if (local_50 < 200) {
    mem_free(puVar20);
    connection_state((connection_basic_state)&local_44);
    state_07.syserr = local_40;
    state_07.basic = local_44;
    abort_connection(conn,state_07);
    return;
  }
  if (local_50 == 0x130) {
    mem_free(puVar20);
    connection_state((connection_basic_state)&local_44);
    state.syserr = (int)pcVar21;
    state.basic = 1;
    http_end_request(conn,state,local_44);
    return;
  }
  if (local_50 == 0xcc) {
    mem_free(puVar20);
    connection_state((connection_basic_state)&local_44);
    http_end_request(conn,(connection_state)(ZEXT48(pcVar21) << 0x20),local_44);
    return;
  }
  if (local_50 == 200) {
    uri_01 = conn->uri;
    if (((uri_01->protocol == 0xf) && (conn->proxied_uri->protocol == 10)) &&
       (conn->socket->ssl == (void *)0x0)) {
      mem_free(puVar20);
      socket->field_0x24 = socket->field_0x24 | 2;
      complete_connect_socket(socket,uri_00,http_send_header);
      return;
    }
  }
  else {
    uri_01 = conn->uri;
  }
  pcVar12 = get_cache_entry(uri_01);
  conn->cached = pcVar12;
  if (pcVar12 == (cache_entry *)0x0) {
    mem_free(puVar20);
LAB_080d0986:
    connection_state((connection_basic_state)&local_44);
    state_08.syserr = local_40;
    state_08.basic = local_44;
    abort_connection(conn,state_08);
    return;
  }
  pcVar12->field_0x5c = pcVar12->field_0x5c & 0xbf | (byte)(((byte)conn->field_0x78 & 8) << 3);
  pcVar12 = conn->cached;
  if (pcVar12->head != (uchar *)0x0) {
    mem_free(pcVar12->head);
    pcVar12 = conn->cached;
  }
  pcVar12->head = puVar20;
  poVar9 = get_opt_();
  if (poVar9->tree == (list_head_elinks *)0x0) {
    pcVar12 = conn->cached;
    local_24 = parse_header(pcVar12->head,(uchar *)"Expires",(uchar **)0x0);
    if (local_24 != (uchar *)0x0) {
      seconds = parse_date(&local_24,(uchar *)0x0,0,1);
      mem_free(local_24);
      if ((seconds != 0) && (pcVar12->cache_mode != CACHE_MODE_NEVER)) {
        timeval_from_seconds(&pcVar12->max_age,seconds);
        pcVar12->field_0x5c = pcVar12->field_0x5c | 1;
      }
    }
    puVar14 = parse_header(pcVar12->head,(uchar *)"Pragma",(uchar **)0x0);
    local_24 = puVar14;
    if (puVar14 != (uchar *)0x0) {
      pcVar21 = strstr((char *)puVar14,"no-cache");
      if (pcVar21 != (char *)0x0) {
        pcVar12->field_0x5c = pcVar12->field_0x5c & 0xfe;
        pcVar12->cache_mode = CACHE_MODE_NEVER;
        puVar14 = local_24;
      }
      mem_free(puVar14);
    }
    if ((pcVar12->cache_mode != CACHE_MODE_NEVER) &&
       (puVar14 = parse_header(pcVar12->head,(uchar *)"Cache-Control",(uchar **)0x0),
       local_24 = puVar14, puVar14 != (uchar *)0x0)) {
      pcVar21 = strstr((char *)puVar14,"no-cache");
      if ((pcVar21 == (char *)0x0) &&
         (pcVar21 = strstr((char *)puVar14,"must-revalidate"), pcVar21 == (char *)0x0)) {
        pcVar21 = strstr((char *)puVar14,"max-age=");
        if ((assert_failed == 0) &&
           (assert_failed = (int)(pcVar12->cache_mode == CACHE_MODE_NEVER), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
          errline = 0x683;
          elinks_internal((uchar *)"assertion cached->cache_mode != CACHE_MODE_NEVER failed!");
        }
        if (pcVar21 != (char *)0x0) {
          lVar16 = strtol(pcVar21 + 8,(char **)0x0,10);
          timeval_from_seconds(&max_age,lVar16);
          timeval_now(&pcVar12->max_age);
          timeval_add_interval(&pcVar12->max_age,&max_age);
          pcVar12->field_0x5c = pcVar12->field_0x5c | 1;
        }
      }
      else {
        pcVar12->field_0x5c = pcVar12->field_0x5c & 0xfe;
        pcVar12->cache_mode = CACHE_MODE_NEVER;
      }
      mem_free(local_24);
    }
  }
  if (((((local_50 == 0x12d) || (local_50 == 0xc9)) || (local_50 == 0x12e)) ||
      ((local_50 == 0x12f || (local_50 == 0x133)))) &&
     (local_24 = parse_header(conn->cached->head,(uchar *)"Location",(uchar **)0x0),
     local_24 != (uchar *)0x0)) {
    uVar8 = (uint)(local_50 == 0x12f);
    if ((local_50 == 0x12e) && (poVar9 = get_opt_(), poVar9->tree != (list_head_elinks *)0x0)) {
      uVar8 = 1;
    }
    redirect_cache(conn->cached,local_24,uVar8,-1);
    mem_free(local_24);
  }
  if (local_50 == 0x191) {
    puVar14 = parse_header(conn->cached->head,(uchar *)"WWW-Authenticate",&local_28);
    while (puVar14 != (uchar *)0x0) {
      iVar7 = c_strncasecmp((char *)puVar14,"Basic",5);
      if (iVar7 != 0) {
        iVar7 = c_strncasecmp((char *)puVar14,"Digest",6);
        if (iVar7 == 0) {
          puVar20 = get_header_param(puVar14,(uchar *)"realm");
          puVar10 = get_header_param(puVar14,(uchar *)"nonce");
          opaque = get_header_param(puVar14,(uchar *)"opaque");
          add_auth_entry(uri_00,puVar20,puVar10,opaque,1);
          if (puVar20 != (uchar *)0x0) {
            mem_free(puVar20);
          }
          if (puVar10 != (uchar *)0x0) {
            mem_free(puVar10);
          }
          if (opaque != (uchar *)0x0) {
            mem_free(opaque);
          }
          mem_free(puVar14);
        }
        else {
          iVar7 = c_strncasecmp((char *)puVar14,"GSS-Negotiate",0xe);
          if (iVar7 == 0) {
            iVar7 = 1;
          }
          else {
            iVar7 = c_strncasecmp((char *)puVar14,"Negotiate",10);
            if (iVar7 != 0) goto LAB_080d0698;
            iVar7 = 2;
          }
          iVar7 = http_negotiate_input(conn,uri_00,iVar7,local_28);
          mem_free(puVar14);
          if (iVar7 == 0) goto LAB_080d077e;
        }
        break;
      }
      puVar20 = get_header_param(puVar14,(uchar *)"realm");
      if (puVar20 != (uchar *)0x0) {
        add_auth_entry(uri_00,puVar20,(uchar *)0x0,(uchar *)0x0,0);
        mem_free(puVar20);
        mem_free(puVar14);
        break;
      }
LAB_080d0698:
      mem_free(puVar14);
      puVar14 = parse_header(local_28,(uchar *)"WWW-Authenticate",&local_28);
    }
  }
  else if (local_50 == 0x197) {
    local_24 = parse_header(conn->cached->head,(uchar *)"Proxy-Authenticate",&local_28);
    while (local_24 != (uchar *)0x0) {
      iVar7 = c_strncasecmp((char *)local_24,"Basic",5);
      if (iVar7 == 0) {
        puVar14 = get_header_param(local_24,(uchar *)"realm");
        if (puVar14 != (uchar *)0x0) {
          if (proxy_auth.realm != (uchar *)0x0) {
            mem_free(proxy_auth.realm);
          }
          proxy_auth._112_1_ = proxy_auth._112_1_ & 0xfb;
          proxy_auth.realm = puVar14;
          mem_free(local_24);
          break;
        }
      }
      else {
        iVar7 = c_strncasecmp((char *)local_24,"Digest",6);
        if (iVar7 == 0) {
          puVar14 = get_header_param(local_24,(uchar *)"realm");
          puVar20 = get_header_param(local_24,(uchar *)"nonce");
          puVar10 = get_header_param(local_24,(uchar *)"opaque");
          if (proxy_auth.realm != (uchar *)0x0) {
            mem_free(proxy_auth.realm);
          }
          proxy_auth.realm = puVar14;
          if (proxy_auth.nonce != (uchar *)0x0) {
            mem_free(proxy_auth.nonce);
          }
          proxy_auth.nonce = puVar20;
          if (proxy_auth.opaque != (uchar *)0x0) {
            mem_free(proxy_auth.opaque);
          }
          proxy_auth._112_1_ = proxy_auth._112_1_ | 4;
          proxy_auth.opaque = puVar10;
          mem_free(local_24);
          break;
        }
      }
      mem_free(local_24);
      local_24 = parse_header(local_28,(uchar *)"Proxy-Authenticate",&local_28);
    }
  }
  kill_buffer_data(rb,local_4c);
  *(undefined4 *)(pbVar5 + 0x14) = 0;
  *(undefined4 *)(pbVar5 + 0x18) = 0xffffffff;
  *(int *)(pbVar5 + 8) = local_70;
  *(int *)(pbVar5 + 4) = local_6c;
  local_24 = parse_header(conn->cached->head,"Connection",(uchar **)0x0);
  if ((local_24 == (uchar *)0x0) &&
     (local_24 = parse_header(conn->cached->head,(uchar *)"Proxy-Connection",(uchar **)0x0),
     local_24 == (uchar *)0x0)) {
    if ((local_6c < 1) || ((local_6c == 1 && (local_70 == 0)))) {
      *(undefined4 *)(pbVar5 + 0x14) = 1;
    }
  }
  else {
    iVar7 = c_strcasecmp((char *)local_24,"close");
    if (iVar7 == 0) {
      *(undefined4 *)(pbVar5 + 0x14) = 1;
    }
    mem_free(local_24);
  }
  uVar8 = *(uint *)&conn->from;
  *(undefined4 *)&conn->from = 0;
  *(undefined4 *)((int)&conn->from + 4) = 0;
  local_24 = parse_header(conn->cached->head,(uchar *)"Content-Range",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    uVar18 = 0xffffffff;
    puVar14 = local_24;
    do {
      if (uVar18 == 0) break;
      uVar18 = uVar18 - 1;
      uVar3 = *puVar14;
      puVar14 = puVar14 + (uint)bVar27 * -2 + 1;
    } while (uVar3 != '\0');
    if (((6 < ~uVar18 - 1) && (local_24[5] = '\0', (byte)(local_24[6] - 0x30) < 10)) &&
       (iVar7 = c_strcasecmp((char *)local_24,"bytes"), iVar7 == 0)) {
      piVar13 = __errno_location();
      *piVar13 = 0;
      lVar16 = strtol((char *)(local_24 + 6),(char **)0x0,10);
      if ((*piVar13 == 0) && (-1 < lVar16)) {
        *(long *)&conn->from = lVar16;
        *(long *)((int)&conn->from + 4) = lVar16 >> 0x1f;
      }
    }
    mem_free(local_24);
  }
  if (uVar8 == 0) {
    uVar18 = *(uint *)&conn->from;
    uVar22 = *(uint *)((int)&conn->from + 4);
  }
  else {
    uVar22 = *(uint *)((int)&conn->from + 4);
    uVar18 = *(uint *)&conn->from;
    if (((uVar22 | uVar18) == 0) && ((conn->field_0x78 & 2) == 0)) {
      conn->field_0x78 = conn->field_0x78 | 2;
    }
  }
  ppVar19 = conn->progress;
  iVar7 = *(int *)((int)&ppVar19->start + 4);
  if ((((iVar7 < 1) && ((iVar7 < 0 || (*(int *)&ppVar19->start == 0)))) &&
      (((int)uVar8 >> 0x1f < (int)uVar22 ||
       (((int)uVar8 >> 0x1f <= (int)uVar22 && (uVar8 < uVar18)))))) || ((int)uVar22 < 0)) {
    connection_state((connection_basic_state)&local_44);
    state_05.syserr = local_40;
    state_05.basic = local_44;
    abort_connection(conn,state_05);
    return;
  }
  if (-1 < iVar7) {
    *(uint *)&ppVar19->seek = uVar18;
    *(uint *)((int)&ppVar19->seek + 4) = uVar22;
    ppVar19 = conn->progress;
    uVar18 = *(uint *)&conn->from;
    uVar22 = *(uint *)((int)&conn->from + 4);
  }
  *(uint *)&ppVar19->start = uVar18;
  *(uint *)((int)&ppVar19->start + 4) = uVar22;
  local_24 = parse_header(conn->cached->head,(uchar *)"Content-Length",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    piVar13 = __errno_location();
    *piVar13 = 0;
    uVar8 = strtol((char *)local_24,(char **)&local_28,10);
    if (((*piVar13 == 0) && (-1 < (int)uVar8)) && (*local_28 == '\0')) {
      if (((*(int *)(pbVar5 + 0x14) == 0) || (1 < local_6c)) || ((local_6c == 1 && (0 < local_70))))
      {
        *(uint *)(pbVar5 + 0x18) = uVar8;
      }
      iVar7 = *(int *)((int)&conn->from + 4);
      *(uint *)&conn->est_length = uVar8 + *(int *)&conn->from;
      *(uint *)((int)&conn->est_length + 4) =
           ((int)uVar8 >> 0x1f) + iVar7 + (uint)CARRY4(uVar8,*(uint *)&conn->from);
    }
    mem_free(local_24);
  }
  if ((conn->field_0x78 & 2) == 0) {
    local_24 = parse_header(conn->cached->head,(uchar *)"Accept-Ranges",(uchar **)0x0);
    if (local_24 == (uchar *)0x0) {
      if ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) == 0) {
        conn->field_0x78 = conn->field_0x78 | 2;
      }
    }
    else {
      iVar7 = c_strcasecmp((char *)local_24,"none");
      if (iVar7 == 0) {
        conn->field_0x78 = conn->field_0x78 | 2;
      }
      mem_free(local_24);
    }
  }
  local_24 = parse_header(conn->cached->head,(uchar *)"Transfer-Encoding",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    iVar7 = c_strcasecmp((char *)local_24,"chunked");
    if (iVar7 == 0) {
      *(undefined4 *)(pbVar5 + 0x18) = 0xfffffffe;
      *(undefined4 *)(pbVar5 + 0x1c) = 0xffffffff;
    }
    mem_free(local_24);
  }
  if ((*(int *)(pbVar5 + 0x14) == 0) && (*(int *)(pbVar5 + 0x18) == -1)) {
    *(undefined4 *)(pbVar5 + 0x14) = 1;
  }
  local_24 = parse_header(conn->cached->head,(uchar *)"Last-Modified",(uchar **)0x0);
  if (local_24 != (uchar *)0x0) {
    pcVar12 = conn->cached;
    if (pcVar12->last_modified != (uchar *)0x0) {
      iVar7 = c_strcasecmp((char *)pcVar12->last_modified,(char *)local_24);
      if ((iVar7 != 0) &&
         (delete_entry_content(conn->cached),
         (*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) != 0)) {
        *(undefined4 *)&conn->from = 0;
        *(undefined4 *)((int)&conn->from + 4) = 0;
        mem_free(local_24);
        connection_state((connection_basic_state)&local_44);
        state_04.syserr = local_40;
        state_04.basic = local_44;
        retry_connection(conn,state_04);
        return;
      }
      pcVar12 = conn->cached;
      if (pcVar12->last_modified != (uchar *)0x0) {
        mem_free(local_24);
        goto LAB_080d00ad;
      }
    }
    pcVar12->last_modified = local_24;
  }
LAB_080d00ad:
  pcVar12 = conn->cached;
  if (pcVar12->last_modified == (uchar *)0x0) {
    local_24 = parse_header(pcVar12->head,"Date",(uchar **)0x0);
    if (local_24 == (uchar *)0x0) {
      pcVar12 = conn->cached;
    }
    else {
      conn->cached->last_modified = local_24;
      pcVar12 = conn->cached;
    }
  }
  puVar14 = parse_header(pcVar12->head,"ETag",(uchar **)0x0);
  local_24 = puVar14;
  if (puVar14 != (uchar *)0x0) {
    pcVar12 = conn->cached;
    puVar20 = pcVar12->etag;
    if (puVar20 == (uchar *)0x0) {
LAB_080d0350:
      pcVar12->etag = local_24;
    }
    else {
      puVar10 = puVar14;
      if ((*puVar14 == 'W') && (puVar14[1] == '/')) {
        puVar10 = puVar14 + 2;
      }
      if ((*puVar20 == 'W') && (puVar20[1] == '/')) {
        puVar20 = puVar20 + 2;
      }
      iVar7 = strcmp((char *)puVar10,(char *)puVar20);
      if (iVar7 != 0) {
        delete_entry_content(pcVar12);
        if ((*(uint *)((int)&conn->from + 4) | *(uint *)&conn->from) != 0) {
          *(undefined4 *)&conn->from = 0;
          *(undefined4 *)((int)&conn->from + 4) = 0;
          mem_free(local_24);
LAB_080d077e:
          connection_state((connection_basic_state)&local_44);
          state_06.syserr = local_40;
          state_06.basic = local_44;
          retry_connection(conn,state_06);
          return;
        }
        pcVar12 = conn->cached;
        puVar14 = local_24;
        if (pcVar12->etag == (uchar *)0x0) goto LAB_080d0350;
      }
      mem_free(puVar14);
    }
  }
  local_24 = parse_header(conn->cached->head,(uchar *)"Content-Encoding",(uchar **)0x0);
  if (local_24 == (uchar *)0x0) goto LAB_080d01da;
  sVar26 = ENCODING_NONE;
  puVar14 = get_extension_from_uri(uri_00);
  if (puVar14 == (uchar *)0x0) {
LAB_080d02fc:
    iVar7 = c_strcasecmp((char *)local_24,"gzip");
    if ((iVar7 == 0) || (iVar7 = c_strcasecmp((char *)local_24,"x-gzip"), iVar7 == 0)) {
      conn->content_encoding = ENCODING_GZIP;
    }
  }
  else {
    sVar26 = guess_encoding(puVar14);
    mem_free(puVar14);
    if (sVar26 != ENCODING_GZIP) goto LAB_080d02fc;
  }
  iVar7 = c_strcasecmp((char *)local_24,"deflate");
  if ((iVar7 == 0) || (iVar7 = c_strcasecmp((char *)local_24,"x-deflate"), iVar7 == 0)) {
    conn->content_encoding = ENCODING_DEFLATE;
  }
  if ((sVar26 != ENCODING_BZIP2) &&
     ((iVar7 = c_strcasecmp((char *)local_24,"bzip2"), iVar7 == 0 ||
      (iVar7 = c_strcasecmp((char *)local_24,"x-bzip2"), iVar7 == 0)))) {
    conn->content_encoding = ENCODING_BZIP2;
  }
  mem_free(local_24);
LAB_080d01da:
  sVar26 = conn->content_encoding;
  if (sVar26 != ENCODING_NONE) {
    pcVar12 = conn->cached;
    if (pcVar12->encoding_info != (uchar *)0x0) {
      mem_free(pcVar12->encoding_info);
      pcVar12 = conn->cached;
      sVar26 = conn->content_encoding;
    }
    puVar14 = get_encoding_name(sVar26);
    puVar14 = stracpy(puVar14);
    pcVar12->encoding_info = puVar14;
  }
  if ((*(int *)(pbVar5 + 0x18) == -1) || (*(int *)(pbVar5 + 0x14) != 0)) {
    socket->state = SOCKET_END_ONCLOSE;
  }
  read_http_data(socket,rb);
  return;
code_r0x080cf841:
  local_4c = local_4c + 2;
LAB_080cf847:
  if (local_4c == -1) {
LAB_080cf916:
    if (assert_failed == 0) {
      uVar8 = 0xfffe78fc;
    }
    else {
      uVar8 = 0xfffe795d;
    }
    assert_failed = 0;
    state_01.syserr = 0;
    state_01.basic = uVar8;
    abort_connection(conn,state_01);
    return;
  }
  if (local_4c == 0) {
LAB_080cf7bc:
    state_09.syserr = 0;
    state_09.basic = local_48;
    read_from_socket(conn->socket,rb,state_09,http_got_header);
    return;
  }
  if (local_4c == -2) {
LAB_080cf950:
    local_4c = 0;
LAB_080cf957:
    if (local_50 == 0x65) goto LAB_080cf896;
    if (local_4c == 0) {
      puVar20 = stracpy((uchar *)"\r\nContent-Type: text/html\r\n");
    }
    else {
      puVar20 = memacpy(puVar14,local_4c);
    }
    if (puVar20 != (uchar *)0x0) {
      poVar9 = get_opt_();
      if (((poVar9->tree == (list_head_elinks *)0x0) ||
          ((*(int *)(pbVar5 + 0xc) == 1 && (*(int *)(pbVar5 + 0x10) == 0)))) ||
         (puVar10 = parse_header(puVar20,(uchar *)"Server",(uchar **)0x0), puVar10 == (uchar *)0x0))
      {
LAB_080cfa38:
        iVar7 = uri_00->protocol;
      }
      else {
        pcVar21 = "mod_czech/3.1.0";
        ppuVar25 = check_http_server_bugs::buggy_servers;
        do {
          pcVar11 = strstr((char *)puVar10,pcVar21);
          if (pcVar11 != (char *)0x0) {
            add_blacklist_entry(uri_00,SERVER_BLACKLIST_HTTP10);
            mem_free(puVar10);
            if ((uchar *)pcVar21 != (uchar *)0x0) {
              mem_free(puVar20);
              if (assert_failed == 0) {
                uVar8 = 0xfffe7955;
              }
              else {
                uVar8 = 0xfffe795d;
              }
              assert_failed = 0;
              state_03.syserr = 0;
              state_03.basic = uVar8;
              retry_connection(conn,state_03);
              return;
            }
            goto LAB_080cfa38;
          }
          ppuVar25 = ppuVar25 + 1;
          pcVar21 = (char *)*ppuVar25;
        } while ((uchar *)pcVar21 != (uchar *)0x0);
        mem_free(puVar10);
        iVar7 = uri_00->protocol;
      }
      puVar10 = puVar20;
      if ((iVar7 == 4) &&
         (local_24 = parse_header(puVar20,(uchar *)"Status",(uchar **)0x0), local_24 != (uchar *)0x0
         )) {
        lVar16 = strtol((char *)local_24,(char **)0x0,10);
        mem_free(local_24);
        if ((lVar16 - 100U < 500) && (local_50 = lVar16, lVar16 == 0x65)) {
          mem_free(puVar20);
          goto LAB_080d0986;
        }
      }
      while( true ) {
        local_20[0] = puVar10;
        pcVar21 = "Set-Cookie";
        puVar10 = parse_header(local_20[0],(uchar *)"Set-Cookie",local_20);
        if (puVar10 == (uchar *)0x0) break;
        set_cookie(uri_00,puVar10);
        mem_free(puVar10);
        puVar10 = local_20[0];
      }
      *(int *)(pbVar5 + 0x20) = local_50;
      if (local_50 != 100) goto LAB_080cfc8c;
      mem_free(puVar20);
      if (assert_failed == 0) {
        local_48 = 7;
      }
      else {
        local_48 = 0xfffe795d;
      }
      assert_failed = 0;
      kill_buffer_data(rb,local_4c);
      goto LAB_080cf788;
    }
    if (assert_failed == 0) {
      uVar8 = 0xfffe795c;
      goto LAB_080cf8b2;
    }
  }
  else {
    bVar17 = rb->data[0];
    puVar20 = puVar14;
    while (bVar17 == 0x20) {
      puVar20 = puVar20 + 1;
      bVar17 = *puVar20;
    }
    iVar7 = c_toupper((uint)bVar17);
    if ((((iVar7 == 0x48) && (iVar7 = c_toupper((uint)puVar20[1]), iVar7 == 0x54)) &&
        (iVar7 = c_toupper((uint)puVar20[2]), iVar7 == 0x54)) &&
       ((iVar7 = c_toupper((uint)puVar20[3]), iVar7 == 0x50 && (puVar20[4] == 0x2f)))) {
      pbVar24 = puVar20 + 5;
      for (pbVar15 = pbVar24; (bVar17 = *pbVar15, bVar17 != 0x2e && (bVar17 != 0));
          pbVar15 = pbVar15 + 1) {
      }
      if ((((pbVar24 != pbVar15) && (bVar17 != 0)) && ((int)pbVar15 - (int)pbVar24 < 5)) &&
         (pbVar2 = pbVar15 + 1, (byte)(pbVar15[1] - 0x30) < 10)) {
        local_6c = 0;
        local_50 = 1;
        pbVar23 = pbVar15;
        while( true ) {
          pbVar23 = pbVar23 + -1;
          if (9 < (byte)(*pbVar23 - 0x30)) goto LAB_080cf896;
          local_6c = local_6c + (*pbVar23 - 0x30) * local_50;
          if (pbVar23 <= pbVar24) break;
          local_50 = local_50 * 10;
        }
        while ((bVar17 != 0x20 && (bVar17 != 0))) {
          pbVar15 = pbVar15 + 1;
          bVar17 = *pbVar15;
        }
        if (((pbVar2 != pbVar15) && (bVar17 != 0)) && ((int)pbVar15 - (int)pbVar2 < 5)) {
          iVar7 = 1;
          local_70 = 0;
          pbVar24 = pbVar15;
          while( true ) {
            pbVar24 = pbVar24 + -1;
            if (9 < (byte)(*pbVar24 - 0x30)) goto LAB_080cf896;
            local_70 = local_70 + (*pbVar24 - 0x30) * iVar7;
            if (pbVar24 <= pbVar2) break;
            iVar7 = iVar7 * 10;
          }
          while (bVar17 == 0x20) {
            pbVar15 = pbVar15 + 1;
            bVar17 = *pbVar15;
          }
          if ((((byte)(bVar17 - 0x31) < 9) && ((byte)(pbVar15[1] - 0x30) < 10)) &&
             ((byte)(pbVar15[2] - 0x30) < 10)) {
            local_50 = (uint)bVar17 * 100 + -0x14d0 + (uint)pbVar15[2] + (uint)pbVar15[1] * 10;
            goto LAB_080cf957;
          }
        }
      }
    }
LAB_080cf896:
    if (assert_failed == 0) {
      uVar8 = 0xfffe78fc;
      goto LAB_080cf8b2;
    }
  }
  uVar8 = 0xfffe795d;
LAB_080cf8b2:
  assert_failed = 0;
  state_00.syserr = 0;
  state_00.basic = uVar8;
  abort_connection(conn,state_00);
  return;
}



// WARNING: Unknown calling convention

uchar * subst_user_agent(uchar *fmt,uchar *version,uchar *sysname,uchar *termsize)

{
  int iVar1;
  byte bVar2;
  uint uVar3;
  char cVar4;
  string *psVar5;
  uint uVar6;
  session *ses;
  uchar *puVar7;
  int p;
  size_t sVar8;
  int iVar9;
  size_t newsize;
  uint uVar10;
  undefined2 *puVar11;
  size_t __n;
  string agent;
  uint local_24;
  uchar bs [4];
  
  psVar5 = init_string(&agent);
  if (psVar5 == (string *)0x0) {
    return (uchar *)0x0;
  }
  do {
    cVar4 = *fmt;
    do {
      do {
        if (cVar4 == '\0') {
          return agent.source;
        }
        sVar8 = 0;
        __n = 0;
        puVar11 = (undefined2 *)fmt;
        if (cVar4 != '%') {
          do {
            sVar8 = sVar8 + 1;
            puVar11 = (undefined2 *)(sVar8 + (int)fmt);
            __n = sVar8;
            if (*(char *)((int)fmt + sVar8) == '%') break;
          } while (*(char *)((int)fmt + sVar8) != '\0');
        }
        if (assert_failed == 0) {
          if ((int)__n < 0) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080d0f92;
          }
          else {
            assert_failed = 0;
          }
          if (__n != 0) {
            iVar9 = __n + agent.length;
            uVar3 = agent.length + 0xffU >> 8;
            uVar6 = agent.length + 0xffU & 0xffffff00;
            uVar10 = iVar9 + 0x100U & 0xffffff00;
            if (uVar6 <= uVar10 && uVar10 + uVar3 * -0x100 != 0) {
              puVar7 = (uchar *)mem_realloc(agent.source,uVar10);
              if (puVar7 == (uchar *)0x0) goto LAB_080d0fa0;
              agent.source = puVar7;
              memset(puVar7 + uVar6,0,uVar10 + uVar3 * -0x100);
            }
            if (agent.source != (uchar *)0x0) {
              memcpy(agent.source + agent.length,fmt,__n);
              agent.source[iVar9] = '\0';
              agent.length = iVar9;
            }
          }
        }
        else {
LAB_080d0f92:
          assert_failed = 0;
        }
LAB_080d0fa0:
        iVar9 = agent.length;
        cVar4 = *(char *)puVar11;
        fmt = (uchar *)puVar11;
      } while (cVar4 != '%');
      bVar2 = *(byte *)((int)puVar11 + 1);
      fmt = (uchar *)((int)puVar11 + 1);
      if (bVar2 == 0x73) {
        add_to_string(&agent,sysname);
        cVar4 = *(char *)((int)puVar11 + 1);
      }
      else {
        if (bVar2 < 0x74) {
          if (bVar2 != 0x62) {
LAB_080d0fc6:
            if (assert_failed != 0) {
              assert_failed = 0;
              cVar4 = *fmt;
              goto LAB_080d1108;
            }
            assert_failed = 0;
            uVar10 = agent.length + 0x102U & 0xffffff00;
            uVar3 = agent.length + 0xffU >> 8;
            uVar6 = agent.length + 0xffU & 0xffffff00;
            iVar1 = agent.length + 2;
            if (uVar10 < uVar6 || uVar10 + uVar3 * -0x100 == 0) {
LAB_080d1001:
              if (agent.source != (uchar *)0x0) {
                *(undefined2 *)(agent.source + agent.length) = *puVar11;
                agent.source[iVar9 + 2] = '\0';
                agent.length = iVar1;
              }
            }
            else {
              puVar7 = (uchar *)mem_realloc(agent.source,uVar10);
              if (puVar7 != (uchar *)0x0) {
                agent.source = puVar7;
                memset(puVar7 + uVar6,0,uVar10 + uVar3 * -0x100);
                goto LAB_080d1001;
              }
            }
            cVar4 = *fmt;
            goto LAB_080d1108;
          }
          if ((list_head_elinks *)sessions.next == &sessions) break;
          local_24 = 0;
          bs[0] = '\0';
          bs[1] = '\0';
          bs[2] = '\0';
          bs[3] = '\0';
          bVar2 = *(byte *)((int)sessions.prev + 0xa8);
          elinks_ulongcat(bs,&local_24,(bVar2 & 1) + (bVar2 >> 1 & 1) + (bVar2 >> 2 & 1),2,'\0',10,0
                         );
          puVar7 = bs;
        }
        else if (bVar2 == 0x74) {
          puVar7 = termsize;
          if (termsize == (uchar *)0x0) break;
        }
        else {
          puVar7 = version;
          if (bVar2 != 0x76) goto LAB_080d0fc6;
        }
        add_to_string(&agent,puVar7);
        cVar4 = *fmt;
      }
LAB_080d1108:
    } while (cVar4 == '\0');
    fmt = (uchar *)(puVar11 + 1);
  } while( true );
}



// WARNING: Unknown calling convention

void http_send_header(socket *socket)

{
  int iVar1;
  byte bVar2;
  undefined2 uVar3;
  connection *conn_00;
  uri *uri_00;
  list_head_elinks *plVar4;
  connection_state state;
  bool bVar5;
  void *pvVar6;
  int iVar7;
  option_value *poVar8;
  http_connection_info *phVar9;
  string *psVar10;
  uchar *puVar11;
  uchar *proxy_data;
  uchar *puVar12;
  uchar *proxy_64;
  uchar *ustr;
  auth_entry *entry;
  size_t sVar13;
  undefined4 *puVar14;
  int userlen;
  size_t sVar15;
  int passwordlen;
  auth_entry *entry_00;
  cache_entry *pcVar16;
  char cVar17;
  int iVar18;
  uchar *optstr;
  int i;
  uri *uri_01;
  connection *conn;
  uchar *post_data;
  uchar *response_1;
  byte *__s;
  uri *uri;
  string *cookies;
  size_t newsize;
  undefined4 *puVar19;
  int trace;
  int h2;
  uchar *response;
  terminal *term;
  uchar *cs;
  uchar *code;
  int h1;
  uint uVar20;
  undefined4 *puVar21;
  int in_GS_OFFSET;
  bool bVar22;
  byte bVar23;
  char *pcVar24;
  uint uVar25;
  uint local_1050;
  int local_1044 [4];
  string ac;
  string header;
  uint local_1024;
  uchar ts [64];
  int local_20;
  
  bVar23 = 0;
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  conn_00 = (connection *)socket->conn;
  pcVar24 = "protocol.http.trace";
  poVar8 = get_opt_();
  uri_00 = conn_00->proxied_uri;
  plVar4 = poVar8->tree;
  if ((((uri_00 == (uri *)0x0) || (uri_00->host == (uchar *)0x0)) || (*uri_00->host == '\0')) ||
     (*(short *)&uri_00->field_0x2e == 0)) {
    if (assert_failed == 0) {
      iVar18 = -0x186a9;
    }
    else {
      iVar18 = -0x186a3;
    }
    assert_failed = 0;
    http_end_request(conn_00,(connection_state)(ZEXT48(pcVar24) << 0x20),iVar18);
    goto LAB_080d12de;
  }
  uVar25 = 1;
  phVar9 = init_http_connection_info(conn_00,1,1,0);
  if (phVar9 == (http_connection_info *)0x0) goto LAB_080d12de;
  psVar10 = init_string(&header);
  if (psVar10 == (string *)0x0) {
    connection_state((connection_basic_state)local_1044);
    http_end_request(conn_00,(connection_state)((ulonglong)uVar25 << 0x20),local_1044[0]);
    goto LAB_080d12de;
  }
  if (conn_00->cached == (cache_entry *)0x0) {
    pcVar16 = find_in_cache(uri_00);
    conn_00->cached = pcVar16;
  }
  bVar22 = false;
  if (((conn_00->uri->protocol != 0xf) ||
      (bVar22 = conn_00->socket->ssl == (void *)0x0, conn_00->proxied_uri->protocol != 10)) ||
     (bVar5 = true, !bVar22)) {
    bVar5 = false;
  }
  if (plVar4 == (list_head_elinks *)0x0) {
    if (bVar5) {
      add_to_string(&header,(uchar *)"CONNECT ");
    }
    else if (uri_00->post == (uchar *)0x0) {
      add_to_string(&header,"GET ");
    }
    else {
      add_to_string(&header,(uchar *)"POST ");
      conn_00->field_0x78 = conn_00->field_0x78 | 2;
    }
  }
  else {
    add_to_string(&header,(uchar *)"TRACE ");
  }
  if (!bVar22) {
    add_char_to_string(&header,'/');
  }
  if (bVar5) {
    add_uri_to_string(&header,uri_00,URI_HTTP_CONNECT);
LAB_080d202a:
    add_to_string(&header," HTTP/");
    add_long_to_string(&header,(phVar9->sent_version).major);
    add_char_to_string(&header,'.');
    add_long_to_string(&header,(phVar9->sent_version).minor);
    add_crlf_to_string(&header);
    add_to_string(&header,(uchar *)"Host: ");
    add_uri_to_string(&header,uri_00,URI_HTTP_HOST);
    add_crlf_to_string(&header);
    if (bVar22) {
LAB_080d14b6:
      poVar8 = get_opt_();
      puVar11 = poVar8->string;
      poVar8 = get_opt_();
      puVar12 = poVar8->string;
      if ((proxy_auth._112_1_ & 4) == 0) {
        if ((*puVar11 != '\0') &&
           (puVar11 = straconcat(puVar11,":",puVar12,0), puVar11 != (uchar *)0x0)) {
          puVar12 = base64_encode(puVar11);
          if (puVar12 != (uchar *)0x0) {
            add_to_string(&header,(uchar *)"Proxy-Authorization: Basic ");
            add_to_string(&header,puVar12);
            add_crlf_to_string(&header);
            mem_free(puVar12);
          }
          mem_free(puVar11);
        }
      }
      else {
        sVar13 = strlen((char *)puVar11);
        if (0x26 < (int)sVar13) {
          sVar13 = 0x27;
        }
        sVar15 = strlen((char *)puVar12);
        if (0x26 < (int)sVar15) {
          sVar15 = 0x27;
        }
        if (sVar13 != 0) {
          __memcpy_chk(0x814f000,puVar11,sVar13,0x54);
        }
        proxy_auth.user[sVar13] = '\0';
        if (sVar15 != 0) {
          __memcpy_chk(0x814f028,puVar12,sVar15,0x2c);
        }
        proxy_auth.password[sVar15] = '\0';
        puVar11 = get_http_auth_digest_response(&proxy_auth,uri_00);
        if (puVar11 != (uchar *)0x0) {
          add_to_string(&header,(uchar *)"Proxy-Authorization: Digest ");
          add_to_string(&header,puVar11);
          add_crlf_to_string(&header);
          mem_free(puVar11);
        }
      }
    }
  }
  else {
    if (((conn_00->uri->protocol == 0xf) && (conn_00->proxied_uri->protocol == 10)) &&
       (conn_00->socket->ssl != (void *)0x0)) {
      add_url_to_http_string(&header,uri_00,0x80);
      goto LAB_080d202a;
    }
    if (bVar22) {
      add_url_to_http_string(&header,uri_00,-0x7741);
      add_to_string(&header," HTTP/");
      add_long_to_string(&header,(phVar9->sent_version).major);
      add_char_to_string(&header,'.');
      add_long_to_string(&header,(phVar9->sent_version).minor);
      add_crlf_to_string(&header);
      add_to_string(&header,(uchar *)"Host: ");
      add_uri_to_string(&header,uri_00,URI_HTTP_HOST);
      add_crlf_to_string(&header);
      goto LAB_080d14b6;
    }
    add_url_to_http_string(&header,conn_00->uri,0x80);
    add_to_string(&header," HTTP/");
    add_long_to_string(&header,(phVar9->sent_version).major);
    add_char_to_string(&header,'.');
    add_long_to_string(&header,(phVar9->sent_version).minor);
    add_crlf_to_string(&header);
    add_to_string(&header,(uchar *)"Host: ");
    add_uri_to_string(&header,uri_00,URI_HTTP_HOST);
    add_crlf_to_string(&header);
  }
  poVar8 = get_opt_();
  puVar11 = poVar8->string;
  if ((*puVar11 != '\0') && ((*puVar11 != ' ' || (puVar11[1] != '\0')))) {
    puVar19 = (undefined4 *)(ts + 4);
    for (iVar18 = 0xf; iVar18 != 0; iVar18 = iVar18 + -1) {
      *puVar19 = 0;
      puVar19 = puVar19 + (uint)bVar23 * -2 + 1;
    }
    ts[0] = '\0';
    ts[1] = '\0';
    ts[2] = '\0';
    ts[3] = '\0';
    add_to_string(&header,(uchar *)"User-Agent: ");
    pvVar6 = terminals.prev;
    if ((list_head_elinks *)terminals.next != &terminals) {
      local_1024 = 0;
      elinks_ulongcat(ts,&local_1024,*(ulong *)((int)terminals.prev + 0x2c),3,'\0',10,0);
      ts[local_1024] = 'x';
      local_1024 = local_1024 + 1;
      elinks_ulongcat(ts,&local_1024,*(ulong *)((int)pvVar6 + 0x30),3,'\0',10,0);
    }
    puVar11 = subst_user_agent(puVar11,"0.12pre5",system_name,ts);
    if (puVar11 != (uchar *)0x0) {
      add_to_string(&header,puVar11);
      mem_free(puVar11);
    }
    add_crlf_to_string(&header);
  }
  if (!bVar5) {
    poVar8 = get_opt_();
    plVar4 = poVar8->tree;
    if (plVar4 == (list_head_elinks *)0x2) {
      poVar8 = get_opt_();
      puVar11 = poVar8->string;
      if (*puVar11 != '\0') {
        add_to_string(&header,(uchar *)"Referer: ");
        add_to_string(&header,puVar11);
        add_crlf_to_string(&header);
      }
    }
    else if (plVar4 == (list_head_elinks *)0x3) {
      if (conn_00->referrer != (uri *)0x0) {
        add_to_string(&header,(uchar *)"Referer: ");
        uri_01 = conn_00->referrer;
        goto LAB_080d2287;
      }
    }
    else if (plVar4 == (list_head_elinks *)0x1) {
      add_to_string(&header,(uchar *)"Referer: ");
      uri_01 = uri_00;
LAB_080d2287:
      add_url_to_http_string(&header,uri_01,0xb1);
      add_crlf_to_string(&header);
    }
  }
  add_to_string(&header,(uchar *)"Accept: */*");
  add_crlf_to_string(&header);
  poVar8 = get_opt_();
  if (poVar8->tree != (list_head_elinks *)0x0) {
    add_to_string(&header,(uchar *)"Accept-Encoding: ");
    add_to_string(&header,(uchar *)"bzip2");
    add_to_string(&header,", ");
    add_to_string(&header,(uchar *)"deflate, gzip");
    add_crlf_to_string(&header);
  }
  if ((accept_charset == (uchar *)0x0) && (psVar10 = init_string(&ac), psVar10 != (string *)0x0)) {
    iVar18 = 0;
    while (puVar11 = get_cp_mime_name(iVar18), puVar11 != (uchar *)0x0) {
      if (ac.length == 0) {
        add_to_string(&ac,(uchar *)"Accept-Charset: ");
      }
      else {
        add_to_string(&ac,", ");
      }
      iVar18 = iVar18 + 1;
      add_to_string(&ac,puVar11);
    }
    iVar18 = 0;
    if (ac.length != 0) {
      add_crlf_to_string(&ac);
      iVar18 = ac.length;
    }
    accept_charset = memacpy(ac.source,iVar18);
    done_string(&ac);
  }
  if ((((*(byte *)&phVar9->bl_flags & 2) == 0) &&
      (poVar8 = get_opt_(), poVar8->tree == (list_head_elinks *)0x0)) &&
     (accept_charset != (uchar *)0x0)) {
    add_to_string(&header,accept_charset);
  }
  poVar8 = get_opt_();
  puVar11 = poVar8->string;
  if (*puVar11 == '\0') {
    poVar8 = get_opt_();
    if ((poVar8->tree != (list_head_elinks *)0x0) &&
       (puVar11 = language_to_iso639(current_language), puVar11 != (uchar *)0x0)) {
      add_to_string(&header,(uchar *)"Accept-Language: ");
      add_to_string(&header,puVar11);
      add_crlf_to_string(&header);
    }
  }
  else {
    add_to_string(&header,(uchar *)"Accept-Language: ");
    add_to_string(&header,puVar11);
    add_crlf_to_string(&header);
  }
  if (((phVar9->sent_version).major == 1) && ((phVar9->sent_version).minor == 1)) {
    if (conn_00->uri->protocol == 0xf) {
      add_to_string(&header,(uchar *)"Proxy-Connection: ");
    }
    else {
      add_to_string(&header,"Connection: ");
    }
    if ((uri_00->post == (uchar *)0x0) ||
       (poVar8 = get_opt_(), poVar8->tree == (list_head_elinks *)0x0)) {
      add_to_string(&header,(uchar *)"Keep-Alive");
    }
    else {
      add_to_string(&header,"close");
    }
    add_crlf_to_string(&header);
  }
  if ((((bVar5) || (pcVar16 = conn_00->cached, pcVar16 == (cache_entry *)0x0)) ||
      ((pcVar16->field_0x5c & 8) != 0)) || (pcVar16->head == (uchar *)0x0)) {
LAB_080d1988:
    if (CACHE_MODE_CHECK_IF_MODIFIED < conn_00->cache_mode) goto LAB_080d21e8;
  }
  else {
    if (conn_00->cache_mode < CACHE_MODE_FORCE_RELOAD) {
      if (pcVar16->last_modified != (uchar *)0x0) {
        add_to_string(&header,(uchar *)"If-Modified-Since: ");
        add_to_string(&header,conn_00->cached->last_modified);
        add_crlf_to_string(&header);
        pcVar16 = conn_00->cached;
      }
      if (pcVar16->etag != (uchar *)0x0) {
        add_to_string(&header,(uchar *)"If-None-Match: ");
        add_to_string(&header,conn_00->cached->etag);
        add_crlf_to_string(&header);
      }
      goto LAB_080d1988;
    }
LAB_080d21e8:
    add_to_string(&header,(uchar *)"Pragma: no-cache");
    add_crlf_to_string(&header);
    add_to_string(&header,(uchar *)"Cache-Control: no-cache");
    add_crlf_to_string(&header);
  }
  if (bVar5) {
    add_crlf_to_string(&header);
  }
  else {
    if ((*(uint *)((int)&conn_00->from + 4) | *(uint *)&conn_00->from) == 0) {
      iVar18 = *(int *)((int)&conn_00->progress->start + 4);
      if ((-1 < iVar18) && ((0 < iVar18 || (*(int *)&conn_00->progress->start != 0))))
      goto LAB_080d1ee0;
    }
    else {
LAB_080d1ee0:
      add_to_string(&header,(uchar *)"Range: bytes=");
      uVar25 = *(uint *)&conn_00->from;
      if ((*(uint *)((int)&conn_00->from + 4) | uVar25) == 0) {
        uVar25 = *(uint *)&conn_00->progress->start;
      }
      add_long_to_string(&header,uVar25);
      add_char_to_string(&header,'-');
      add_crlf_to_string(&header);
    }
    iVar18 = http_negotiate_output(uri_00,&header);
    if ((iVar18 != 0) && (entry_00 = find_auth(uri_00), entry_00 != (auth_entry *)0x0)) {
      if ((entry_00->field_0x70 & 4) == 0) {
        puVar11 = straconcat(entry_00->user,":",entry_00->password,0);
        if (puVar11 != (uchar *)0x0) {
          puVar12 = base64_encode(puVar11);
          mem_free(puVar11);
          if (puVar12 != (uchar *)0x0) {
            add_to_string(&header,"Authorization: Basic ");
            add_to_string(&header,puVar12);
            add_crlf_to_string(&header);
            mem_free(puVar12);
          }
        }
      }
      else {
        puVar11 = get_http_auth_digest_response(entry_00,uri_00);
        if (puVar11 != (uchar *)0x0) {
          add_to_string(&header,"Authorization: Digest ");
          add_to_string(&header,puVar11);
          add_crlf_to_string(&header);
          mem_free(puVar11);
        }
      }
    }
    __s = uri_00->post;
    if (__s != (byte *)0x0) {
      pcVar24 = strchr((char *)__s,10);
      if (pcVar24 != (char *)0x0) {
        __s = (byte *)(pcVar24 + 1);
        add_to_string(&header,"Content-Type: ");
        add_bytes_to_string__(&header,uri_00->post,(int)pcVar24 - (int)uri_00->post);
        add_crlf_to_string(&header);
      }
      add_to_string(&header,(uchar *)"Content-Length: ");
      sVar13 = strlen((char *)__s);
      add_long_to_string(&header,sVar13 >> 1);
      add_crlf_to_string(&header);
    }
    psVar10 = send_cookies(uri_00);
    if (psVar10 != (string *)0x0) {
      add_to_string(&header,(uchar *)"Cookie: ");
      add_string_to_string(&header,psVar10);
      add_crlf_to_string(&header);
      done_string(psVar10);
    }
    add_crlf_to_string(&header);
    if (__s != (byte *)0x0) {
      if (assert_failed == 0) {
        assert_failed = 0;
      }
      iVar18 = 0;
      while( true ) {
        bVar2 = *__s;
        uVar25 = (uint)bVar2;
        if ((bVar2 == 0) || (__s[1] == 0)) break;
        if ((byte)(bVar2 - 0x30) < 10) {
          h1 = uVar25 - 0x30;
LAB_080d1afb:
          if (assert_failed != 0) goto LAB_080d1ba9;
LAB_080d1b09:
          assert_failed = (int)(0xf < (uint)h1);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
            errline = 0x3e6;
            elinks_internal((uchar *)
                            "assertion h1 >= 0 && h1 < 16 failed: h1 in the POST buffer is %d (%d/%c)"
                            ,h1,(uint)*__s,(uint)*__s);
            if (assert_failed != 0) goto LAB_080d1ba9;
          }
          uVar25 = (uint)__s[1];
          cVar17 = (char)(h1 << 4);
          if (9 < (byte)(__s[1] - 0x30)) goto LAB_080d1bc8;
LAB_080d1b36:
          uVar25 = uVar25 - 0x30;
LAB_080d1b39:
          assert_failed = (int)(0xf < uVar25);
          if (assert_failed != 0) goto LAB_080d1c57;
        }
        else {
          if (5 < (byte)(bVar2 + 0x9f)) {
            h1 = uVar25 - 0x37;
            if (5 < (byte)(bVar2 + 0xbf)) {
              h1 = -1;
            }
            goto LAB_080d1afb;
          }
          h1 = uVar25 - 0x57;
          if (assert_failed == 0) goto LAB_080d1b09;
LAB_080d1ba9:
          uVar25 = (uint)__s[1];
          cVar17 = '\0';
          if ((byte)(__s[1] - 0x30) < 10) goto LAB_080d1b36;
LAB_080d1bc8:
          if ((byte)((char)uVar25 + 0x9fU) < 6) {
            uVar25 = uVar25 - 0x57;
            goto LAB_080d1b39;
          }
          if ((byte)((char)uVar25 + 0xbfU) < 6) {
            uVar25 = uVar25 - 0x37;
            goto LAB_080d1b39;
          }
          assert_failed = 1;
          uVar25 = 0xffffffff;
LAB_080d1c57:
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
          errline = 0x3ea;
          elinks_internal((uchar *)
                          "assertion h2 >= 0 && h2 < 16 failed: h2 in the POST buffer is %d (%d/%c)"
                          ,uVar25,(uint)__s[1],(uint)__s[1]);
          if (assert_failed != 0) {
            assert_failed = 0;
            uVar25 = 0;
          }
        }
        iVar7 = header.length;
        ts[iVar18] = (char)uVar25 + cVar17;
        iVar18 = iVar18 + 1;
        if (iVar18 == 0x1000) {
          if (assert_failed == 0) {
            assert_failed = 0;
            uVar25 = header.length + 0x1100U & 0xffffff00;
            uVar20 = header.length + 0xffU & 0xffffff00;
            iVar1 = header.length + 0x1000;
            if (uVar20 < uVar25) {
              puVar11 = (uchar *)mem_realloc(header.source,uVar25);
              if (puVar11 != (uchar *)0x0) {
                header.source = puVar11;
                memset(puVar11 + uVar20,0,uVar25 - uVar20);
                goto LAB_080d1d02;
              }
            }
            else {
LAB_080d1d02:
              if (header.source != (uchar *)0x0) {
                puVar14 = (undefined4 *)(header.source + header.length);
                puVar19 = (undefined4 *)ts;
                local_1050 = 0x1000;
                bVar22 = ((uint)puVar14 & 1) != 0;
                puVar21 = puVar14;
                if (bVar22) {
                  puVar21 = (undefined4 *)((int)puVar14 + 1);
                  puVar19 = (undefined4 *)(ts + 1);
                  *(uchar *)puVar14 = ts[0];
                  local_1050 = 0xfff;
                }
                if (((uint)puVar21 & 2) != 0) {
                  uVar3 = *(undefined2 *)puVar19;
                  puVar19 = (undefined4 *)((int)puVar19 + 2);
                  *(undefined2 *)puVar21 = uVar3;
                  puVar21 = (undefined4 *)((int)puVar21 + 2);
                  local_1050 = local_1050 - 2;
                }
                iVar18 = 0;
                for (uVar25 = local_1050 >> 2; uVar25 != 0; uVar25 = uVar25 - 1) {
                  *puVar21 = *puVar19;
                  puVar19 = puVar19 + (uint)bVar23 * -2 + 1;
                  puVar21 = puVar21 + (uint)bVar23 * -2 + 1;
                }
                if ((local_1050 & 2) != 0) {
                  *(undefined2 *)puVar21 = *(undefined2 *)puVar19;
                  iVar18 = 2;
                }
                if (bVar22) {
                  *(undefined *)((int)puVar21 + iVar18) = *(undefined *)((int)puVar19 + iVar18);
                }
                iVar18 = 0;
                header.source[iVar7 + 0x1000] = '\0';
                header.length = iVar1;
                goto LAB_080d1b69;
              }
            }
            iVar18 = 0;
          }
          else {
            assert_failed = 0;
            iVar18 = 0;
          }
        }
LAB_080d1b69:
        __s = __s + 2;
      }
      if (iVar18 != 0) {
        add_bytes_to_string__(&header,ts,iVar18);
      }
    }
  }
  if (assert_failed == 0) {
    uVar25 = 4;
  }
  else {
    uVar25 = 0xfffe795d;
  }
  assert_failed = 0;
  state.syserr = 0;
  state.basic = uVar25;
  request_from_socket(socket,header.source,header.length,state,SOCKET_END_ONCLOSE,http_got_header);
  done_string(&header);
LAB_080d12de:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
}



// WARNING: Unknown calling convention

void http_protocol_handler(connection *conn)

{
  int iVar1;
  
  iVar1 = has_keepalive_connection(conn);
  if (iVar1 != 0) {
    http_send_header(conn->socket);
    return;
  }
  make_connection(conn->socket,conn->uri,http_send_header,
                  (uint)(CACHE_MODE_CHECK_IF_MODIFIED < conn->cache_mode));
  return;
}



// WARNING: Unknown calling convention

void proxy_protocol_handler(connection *conn)

{
  http_protocol_handler(conn);
  return;
}



// WARNING: Unknown calling convention

negotiate * http_negotiate_get(uri *uri,int *isnew,int alloc)

{
  int iVar1;
  negotiate *neg;
  negotiate *pnVar2;
  
  pnVar2 = (negotiate *)negotiate_list.next;
  if ((list_head_elinks *)negotiate_list.next != &negotiate_list) {
    do {
      iVar1 = compare_uri(pnVar2->uri,uri,URI_HTTP_REFERRER_HOST);
      if (iVar1 != 0) {
        return pnVar2;
      }
      pnVar2 = pnVar2->next;
    } while (pnVar2 != (negotiate *)&negotiate_list);
  }
  pnVar2 = (negotiate *)0x0;
  if ((alloc != 0) && (pnVar2 = (negotiate *)mem_calloc(1,0x30), pnVar2 != (negotiate *)0x0)) {
    (uri->object).refcount = (uri->object).refcount + 1;
    pnVar2->uri = uri;
    if (isnew != (int *)0x0) {
      *isnew = 1;
    }
  }
  return pnVar2;
}



// WARNING: Unknown calling convention

int http_negotiate_create_context(negotiate *neg)

{
  uint uVar1;
  OM_uint32 major_status;
  int iVar2;
  OM_uint32 minor_status;
  
  uVar1 = gss_init_sec_context
                    (&minor_status,0,&neg->context,neg->server_name,0,1,0,0,&neg->input_token,0,
                     &neg->output_token,0,0);
  neg->status = uVar1;
  if (((uVar1 & 0xffff0000) != 0) || (iVar2 = 0, (neg->output_token).length == 0)) {
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

void http_negotiate_cleanup(negotiate *neg,int full)

{
  int iVar1;
  byte bVar2;
  OM_uint32 minor_status;
  
  bVar2 = 0;
  if (neg->context != (gss_ctx_id_t)0x0) {
    gss_delete_sec_context(&minor_status,&neg->context,0);
  }
  if ((neg->output_token).length != 0) {
    gss_release_buffer(&minor_status,&neg->output_token);
  }
  if (full != 0) {
    if (neg->server_name != (gss_name_t)0x0) {
      gss_release_name(&minor_status,&neg->server_name);
    }
    if ((neg->input_token).length != 0) {
      mem_free((neg->input_token).value);
      (neg->input_token).length = 0;
    }
    for (iVar1 = 0xc; iVar1 != 0; iVar1 = iVar1 + -1) {
      neg->next = (negotiate *)0x0;
      neg = (negotiate *)((int)neg + (uint)bVar2 * -8 + 4);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int http_negotiate_output(uri *uri,string *header)

{
  negotiate *neg_00;
  negotiate *neg;
  int iVar1;
  size_t inlen;
  uchar *source;
  char *source_00;
  int local_20 [4];
  
  local_20[0] = 0;
  neg_00 = http_negotiate_get(uri,(int *)0x0,0);
  if (neg_00 != (negotiate *)0x0) {
    inlen = (neg_00->output_token).length;
    if (inlen == 0) {
      iVar1 = http_negotiate_create_context(neg_00);
      if (iVar1 < 0) {
        http_negotiate_cleanup(neg_00,1);
        return -1;
      }
      inlen = (neg_00->output_token).length;
    }
    source = base64_encode_bin((uchar *)(neg_00->output_token).value,inlen,local_20);
    if ((source != (uchar *)0x0) && (local_20[0] != 0)) {
      add_to_string(header,(uchar *)"Authorization: ");
      source_00 = "GSS-Negotiate";
      if (neg_00->type != 1) {
        source_00 = "Negotiate";
      }
      add_to_string(header,(uchar *)source_00);
      add_char_to_string(header,' ');
      add_to_string(header,source);
      add_crlf_to_string(header);
      http_negotiate_cleanup(neg_00,0);
      mem_free(source);
      return 0;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

int http_negotiate_get_name(connection *conn,negotiate *neg)

{
  size_t sVar1;
  int iVar2;
  uri *puVar3;
  char *service;
  int iVar4;
  uint uVar5;
  uri *uri;
  OM_uint32 major_status;
  int in_GS_OFFSET;
  gss_buffer_desc token;
  OM_uint32 minor_status;
  char name [2048];
  
  iVar2 = *(int *)(in_GS_OFFSET + 0x14);
  token.length = 0;
  token.value = (void *)0x0;
  puVar3 = conn->proxied_uri;
  service = "HTTP";
  if (neg->type == 1) {
    service = "KHTTP";
  }
  sVar1 = (neg->type == 1) + 6 + (uint)*(ushort *)&puVar3->field_0x2e;
  if (sVar1 + 1 < 0x801) {
    token.length = sVar1;
    __snprintf_chk(name,sVar1,1,0x800,&DAT_08133183,service,*(undefined2 *)&puVar3->field_0x2e,
                   puVar3->host);
    token.value = name;
    uVar5 = gss_import_name(&minor_status,&token,GSS_C_NT_HOSTBASED_SERVICE,&neg->server_name);
    iVar4 = 0;
    if ((uVar5 & 0xffff0000) == 0) goto LAB_080d2b33;
  }
  iVar4 = -1;
LAB_080d2b33:
  if (iVar2 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar4;
}



// WARNING: Unknown calling convention

int http_negotiate_input(connection *conn,uri *uri,int type,uchar *data)

{
  negotiate *neg_00;
  int iVar1;
  int ret;
  ushort **ppuVar2;
  uchar *puVar3;
  int len;
  byte *in;
  byte *pbVar4;
  byte bVar5;
  negotiate *neg;
  uchar *end;
  int local_20 [4];
  
  local_20[0] = 0;
  neg_00 = http_negotiate_get(uri,local_20,1);
  if ((type == 1) || (neg_00->context == (gss_ctx_id_t)0x0)) {
    neg_00->type = type;
    if ((neg_00->context != (gss_ctx_id_t)0x0) && (neg_00->status == 0)) {
      http_negotiate_cleanup(neg_00,1);
      return -1;
    }
    if ((neg_00->server_name != (gss_name_t)0x0) ||
       (iVar1 = http_negotiate_get_name(conn,neg_00), -1 < iVar1)) {
      if ((data != (uchar *)0x0) && (*data != '\0')) {
        in = data + 0xe;
        if (type != 1) {
          in = data + 10;
        }
        bVar5 = *in;
        if (bVar5 != 0) {
          ppuVar2 = __ctype_b_loc();
          do {
            if ((*(byte *)((int)*ppuVar2 + (uint)bVar5 * 2 + 1) & 0x20) == 0) {
              if (((bVar5 != 0xd) && (bVar5 != 0)) && (pbVar4 = in, bVar5 != 10)) {
                while (((*(byte *)(*ppuVar2 + bVar5) & 8) != 0 || (bVar5 == 0x3d))) {
                  pbVar4 = pbVar4 + 1;
                  bVar5 = *pbVar4;
                }
                if (((bVar5 == 10) || (bVar5 == 0xd)) && ((int)pbVar4 - (int)in != 0)) {
                  puVar3 = base64_decode_bin(in,(int)pbVar4 - (int)in,(int *)&neg_00->input_token);
                  (neg_00->input_token).value = puVar3;
                  if (puVar3 == (uchar *)0x0) {
                    return -1;
                  }
                }
              }
              break;
            }
            in = in + 1;
            bVar5 = *in;
          } while (bVar5 != 0);
        }
      }
      iVar1 = http_negotiate_create_context(neg_00);
      if ((iVar1 == 0) && (local_20[0] != 0)) {
        neg_00->prev = (negotiate *)&negotiate_list;
        neg_00->next = (negotiate *)negotiate_list.next;
        negotiate_list.next = neg_00;
        neg_00->next->prev = neg_00;
      }
      return iVar1;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

uchar * get_uri_rewrite_prefix(uri_rewrite_type type,uchar *url)

{
  uchar *puVar1;
  option_elinks *poVar2;
  option_elinks *opt;
  uchar *exp;
  uri_rewrite_option tree;
  int iVar3;
  
  tree = -(uint)(type == URI_REWRITE_DUMB) & 0xfffffffe;
  iVar3 = tree + URI_REWRITE_SMART_TREE;
  if ((assert_failed == 0) && (assert_failed = (int)(iVar3 != 3 && iVar3 != 5), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/rewrite/rewrite.c";
    errline = 0xe6;
    elinks_internal((uchar *)
                    "assertion tree == URI_REWRITE_DUMB_TREE || tree == URI_REWRITE_SMART_TREE failed!"
                   );
  }
  poVar2 = get_opt_rec_real(&uri_rewrite_options[iVar3].option_elinks,url);
  if (poVar2 != (option_elinks *)0x0) {
    puVar1 = (poVar2->value).string;
    if ((puVar1 == (uchar *)0x0) || (*puVar1 != '\0')) {
      return puVar1;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

evhook_status goto_url_hook(va_list ap,void *data)

{
  uchar uVar1;
  uchar **ppuVar2;
  uint uVar3;
  string *psVar4;
  uchar *arg;
  char *pcVar5;
  int value;
  uint uVar6;
  option_value *poVar7;
  byte bVar8;
  int i;
  int newlength;
  size_t oldsize;
  int iVar9;
  int argc;
  int p;
  size_t sVar10;
  uint uVar11;
  uchar *uu;
  session *ses;
  int iVar12;
  int iVar13;
  undefined2 *puVar14;
  uchar *puVar15;
  uchar *argstart;
  size_t __n;
  int local_90;
  uri *local_8c;
  uchar *local_88;
  int argslen [10];
  uchar *args [10];
  string n;
  
  ppuVar2 = *(uchar ***)ap;
  iVar12 = *(int *)(ap + 4);
  local_88 = "";
  puVar15 = *ppuVar2;
  uVar1 = *puVar15;
  if (((uVar1 == '\0') || (uVar1 == ' ')) || (uVar1 == ':')) {
    iVar9 = 0;
  }
  else {
    iVar9 = 0;
    do {
      iVar9 = iVar9 + 1;
      uVar1 = puVar15[iVar9];
      if ((uVar1 == '\0') || (uVar1 == ' ')) break;
    } while (uVar1 != ':');
  }
  puVar15 = puVar15 + iVar9;
  if ((uri_rewrite_options[2].option_elinks.value.tree == (list_head_elinks *)0x0) ||
     (uVar1 = *puVar15, uVar1 == '\0')) {
    uu = (uchar *)0x0;
LAB_080d2e96:
    if (uri_rewrite_options[1].option_elinks.value.tree == (list_head_elinks *)0x0)
    goto LAB_080d2ea3;
    if (*puVar15 == '\0') {
      uu = get_uri_rewrite_prefix(URI_REWRITE_DUMB,*ppuVar2);
      goto LAB_080d2ea3;
    }
  }
  else {
    *puVar15 = '\0';
    uu = get_uri_rewrite_prefix(URI_REWRITE_SMART,*ppuVar2);
    local_88 = puVar15 + 1;
    *puVar15 = uVar1;
    if ((undefined2 *)uu == (undefined2 *)0x0) goto LAB_080d2e96;
LAB_080d2ea3:
    if ((undefined2 *)uu != (undefined2 *)0x0) goto LAB_080d2eab;
  }
  puVar15 = *ppuVar2;
  pcVar5 = strchr((char *)puVar15,0x3a);
  if (pcVar5 != (char *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  pcVar5 = strchr((char *)puVar15,0x2e);
  if (pcVar5 != (char *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  pcVar5 = strchr((char *)puVar15,0x2f);
  if (pcVar5 != (char *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  poVar7 = get_opt_();
  uu = (uchar *)poVar7->command;
  if ((undefined2 *)uu == (undefined2 *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  if (*uu == 0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  local_88 = *ppuVar2;
LAB_080d2eab:
  if ((iVar12 == 0) || (iVar12 = *(int *)(iVar12 + 0x14), iVar12 == 0)) {
    local_8c = (uri *)0x0;
  }
  else {
    local_8c = *(uri **)(iVar12 + 0x44);
  }
  n.source = (uchar *)0x0;
  n.length = 0;
  psVar4 = init_string(&n);
  if (psVar4 == (string *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  iVar9 = 0;
  iVar12 = 0;
  args[0] = local_88;
  arg = local_88;
  do {
    arg = arg + iVar9;
    if (*arg == ' ') {
      argslen[iVar12] = iVar9;
      iVar13 = iVar12 + 1;
      if (iVar13 == 10) {
        newlength = (int)*uu;
        goto LAB_080d2f78;
      }
      do {
        arg = arg + 1;
      } while (*arg == ' ');
      args[iVar13] = arg;
      iVar9 = 1;
      iVar12 = iVar13;
    }
    else {
      if (*arg == '\0') {
        argslen[iVar12] = iVar9;
        newlength = (int)*uu;
LAB_080d2f78:
        local_90 = iVar12 + 1;
        bVar8 = (byte)newlength;
        puVar15 = n.source;
        do {
          n.source = puVar15;
          if (bVar8 == 0) {
            if (puVar15 != (uchar *)0x0) {
              mem_free(*ppuVar2);
              *ppuVar2 = puVar15;
              return EVENT_HOOK_STATUS_NEXT;
            }
            return EVENT_HOOK_STATUS_NEXT;
          }
          sVar10 = 0;
          __n = 0;
          puVar14 = (undefined2 *)uu;
          if ((char)newlength != '%') {
            do {
              sVar10 = sVar10 + 1;
              puVar14 = (undefined2 *)((int)uu + sVar10);
              __n = sVar10;
              if (*(byte *)((int)uu + sVar10) == 0x25) break;
            } while (*(byte *)((int)uu + sVar10) != 0);
          }
          if (assert_failed == 0) {
            if ((int)__n < 0) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) goto LAB_080d2fae;
            }
            else {
              assert_failed = 0;
            }
            if (__n != 0) {
              iVar9 = __n + n.length;
              uVar3 = n.length + 0xffU >> 8;
              uVar6 = n.length + 0xffU & 0xffffff00;
              uVar11 = iVar9 + 0x100U & 0xffffff00;
              if (uVar6 <= uVar11 && uVar11 + uVar3 * -0x100 != 0) {
                puVar15 = (uchar *)mem_realloc(n.source,uVar11);
                if (puVar15 == (uchar *)0x0) goto LAB_080d2fb8;
                n.source = puVar15;
                memset(puVar15 + uVar6,0,uVar11 + uVar3 * -0x100);
              }
              if (n.source != (uchar *)0x0) {
                memcpy(n.source + n.length,uu,__n);
                n.source[iVar9] = '\0';
                n.length = iVar9;
              }
            }
          }
          else {
LAB_080d2fae:
            assert_failed = 0;
          }
LAB_080d2fb8:
          iVar9 = n.length;
          newlength = (int)*(byte *)puVar14;
          uu = (uchar *)puVar14;
          if (*(byte *)puVar14 != 0x25) goto LAB_080d2f78;
          bVar8 = *(byte *)((int)puVar14 + 1);
          uu = (uchar *)((int)puVar14 + 1);
          if (bVar8 < 0x3a) {
            if (bVar8 < 0x30) {
              if (bVar8 == 0x25) {
                add_char_to_string(&n,'%');
                newlength = (int)*uu;
              }
              else {
LAB_080d30ee:
                if (assert_failed == 0) {
                  assert_failed = 0;
                  iVar13 = n.length + 2;
                  uVar3 = n.length + 0xffU >> 8;
                  uVar6 = n.length + 0xffU & 0xffffff00;
                  uVar11 = n.length + 0x102U & 0xffffff00;
                  if (uVar11 < uVar6 || uVar11 + uVar3 * -0x100 == 0) {
LAB_080d3162:
                    if (n.source != (uchar *)0x0) {
                      *(undefined2 *)(n.source + n.length) = *puVar14;
                      n.source[iVar9 + 2] = '\0';
                      n.length = iVar13;
                    }
                  }
                  else {
                    puVar15 = (uchar *)mem_realloc(n.source,uVar11);
                    if (puVar15 != (uchar *)0x0) {
                      n.source = puVar15;
                      memset(puVar15 + uVar6,0,uVar11 + uVar3 * -0x100);
                      goto LAB_080d3162;
                    }
                  }
                  newlength = (int)*uu;
                }
                else {
                  assert_failed = 0;
                  newlength = (int)*uu;
                }
              }
            }
            else {
              iVar9 = bVar8 - 0x30;
              if (local_90 <= iVar9) goto LAB_080d2feb;
              encode_uri_string(&n,args[iVar9],argslen[iVar9],1);
              newlength = (int)*uu;
            }
LAB_080d3108:
            if ((char)newlength == '\0') goto LAB_080d2f78;
            bVar8 = *(byte *)(puVar14 + 1);
          }
          else {
            if (bVar8 != 99) {
              if (bVar8 != 0x73) goto LAB_080d30ee;
              if (local_88 == (uchar *)0x0) goto LAB_080d2feb;
              encode_uri_string(&n,local_88,-1,1);
              newlength = (int)*uu;
              goto LAB_080d3108;
            }
            if (local_8c != (uri *)0x0) {
              add_uri_to_string(&n,local_8c,URI_ORIGINAL);
              newlength = (int)*uu;
              goto LAB_080d3108;
            }
LAB_080d2feb:
            bVar8 = *(byte *)(puVar14 + 1);
          }
          uu = (uchar *)(puVar14 + 1);
          newlength = (int)bVar8;
          puVar15 = n.source;
        } while( true );
      }
      iVar9 = iVar9 + 1;
    }
    arg = args[iVar12];
  } while( true );
}



// WARNING: Unknown calling convention

void report_scripting_error(module *module,session *ses,uchar *msg)

{
  string *psVar1;
  int iVar2;
  int new_charset;
  uchar *puVar3;
  uchar *puVar4;
  int new_charset_1;
  terminal *term;
  string string;
  
  if (ses == (session *)0x0) {
    term = (terminal *)terminals.next;
    if ((list_head_elinks *)terminals.next == &terminals) {
      puVar4 = gettext(module->name);
      puVar3 = gettext((uchar *)"[%s error] %s");
      usrerror(puVar3,puVar4,msg);
      sleep(3);
      return;
    }
  }
  else {
    term = ses->tab->term;
  }
  psVar1 = init_string(&string);
  if (psVar1 != (string *)0x0) {
    puVar4 = module->name;
    if ((puVar4 != (uchar *)0x0) && (*puVar4 != '\0')) {
      if ((term != (terminal *)0x0) &&
         (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)) {
        puVar3 = get_cp_mime_name(iVar2);
        bind_textdomain_codeset("elinks",puVar3);
        current_charset = iVar2;
      }
      puVar4 = gettext(puVar4);
    }
    if ((term != (terminal *)0x0) && (iVar2 = get_terminal_codepage(term), iVar2 != current_charset)
       ) {
      puVar3 = get_cp_mime_name(iVar2);
      bind_textdomain_codeset("elinks",puVar3);
      current_charset = iVar2;
    }
    puVar3 = gettext((uchar *)"An error occurred while running a %s script");
    add_format_to_string(&string,puVar3,puVar4);
    add_format_to_string(&string,":\n\n%s",msg);
    info_box(term,MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL,(uchar *)"Browser scripting error",ALIGN_LEFT
             ,string.source);
  }
  return;
}



// WARNING: Unknown calling convention

VALUE erb_module_method_missing(VALUE self,VALUE arg)

{
  return 4;
}



// WARNING: Unknown calling convention

VALUE erb_stdout_p(int argc,VALUE *argv,VALUE self)

{
  uint uVar1;
  string *psVar2;
  int iVar3;
  VALUE substr;
  uint uVar4;
  uchar *puVar5;
  int newlength;
  size_t newsize;
  uint size;
  int len;
  size_t __n;
  uchar *ptr;
  char *__src;
  int iVar6;
  int i;
  string string;
  
  psVar2 = init_string(&string);
  if (psVar2 != (string *)0x0) {
    iVar6 = 0;
    if (0 < argc) {
      do {
        iVar3 = rb_inspect(argv[iVar6]);
        __src = *(char **)(iVar3 + 0xc);
        iVar3 = *(int *)(iVar3 + 8);
        if (*__src == '\"') {
          __src = __src + 1;
          iVar3 = iVar3 + -1;
        }
        __n = iVar3 - (uint)(__src[iVar3 + -1] == '\"');
        if (assert_failed == 0) {
          if ((__src == (char *)0x0) || ((int)__n < 0)) {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
            errline = 0xff;
            elinks_internal((uchar *)
                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                           );
            if (assert_failed != 0) goto LAB_080d3650;
          }
          else {
            assert_failed = 0;
          }
          if (__n != 0) {
            iVar3 = __n + string.length;
            uVar1 = string.length + 0xffU >> 8;
            uVar4 = string.length + 0xffU & 0xffffff00;
            size = iVar3 + 0x100U & 0xffffff00;
            if (uVar4 <= size && size + uVar1 * -0x100 != 0) {
              puVar5 = (uchar *)mem_realloc(string.source,size);
              if (puVar5 == (uchar *)0x0) goto joined_r0x080d3660;
              string.source = puVar5;
              memset(puVar5 + uVar4,0,size + uVar1 * -0x100);
            }
            if (string.source != (uchar *)0x0) {
              memcpy(string.source + string.length,__src,__n);
              string.source[iVar3] = '\0';
              string.length = iVar3;
            }
          }
        }
        else {
LAB_080d3650:
          assert_failed = 0;
        }
joined_r0x080d3660:
        if (argc <= iVar6 + 1) break;
        iVar6 = iVar6 + 1;
        add_to_string(&string,", ");
      } while( true );
    }
    if ((list_head_elinks *)terminals.next == &terminals) {
      usrerror((uchar *)"[Ruby] %s",string.source);
      done_string(&string);
    }
    else {
      info_box((terminal *)terminals.next,MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL,
               (uchar *)"Ruby Message",ALIGN_LEFT,string.source);
    }
  }
  return 4;
}



// WARNING: Unknown calling convention

VALUE erb_module_message(VALUE self,VALUE str)

{
  int iVar1;
  uchar *text;
  uchar *message;
  char *pcVar2;
  
  iVar1 = rb_obj_as_string(str);
  text = memacpy(*(uchar **)(iVar1 + 0xc),*(int *)(iVar1 + 8));
  if (text != (uchar *)0x0) {
    pcVar2 = strchr((char *)text,10);
    if (pcVar2 != (char *)0x0) {
      *pcVar2 = '\0';
    }
    if ((list_head_elinks *)terminals.next == &terminals) {
      usrerror((uchar *)"[Ruby] %s",text);
      mem_free(text);
    }
    else {
      info_box((terminal *)terminals.next,MSGBOX_FREE_TEXT|MSGBOX_NO_TEXT_INTL,
               (uchar *)"Ruby Message",ALIGN_LEFT,text);
    }
  }
  return 4;
}



// WARNING: Unknown calling convention

void alert_ruby_error(session *ses,uchar *msg)

{
  report_scripting_error(&ruby_scripting_module,ses,msg);
  return;
}



// WARNING: Unknown calling convention

void erb_report_error(session *ses,int error)

{
  int iVar1;
  VALUE epath;
  int iVar2;
  int iVar3;
  char *pcVar4;
  uchar *msg;
  char *msg_00;
  VALUE einfo;
  VALUE eclass;
  int in_GS_OFFSET;
  uchar buff [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  switch(error) {
  default:
    msg_00 = (char *)buff;
    __snprintf_chk(msg_00,0x400,1,0x400,"unknown longjmp status %d",error);
    break;
  case 1:
    msg_00 = "unexpected return";
    break;
  case 2:
    msg_00 = "unexpected break";
    break;
  case 3:
    msg_00 = "unexpected next";
    break;
  case 4:
    msg_00 = "retry outside of rescue clause";
    break;
  case 5:
    msg_00 = "unexpected redo";
    break;
  case 6:
  case 8:
    iVar3 = rb_cFixnum;
    if (((((ruby_errinfo & 1) == 0) && (iVar3 = rb_cNilClass, ruby_errinfo != 4)) &&
        (iVar3 = rb_cFalseClass, ruby_errinfo != 0)) &&
       ((iVar3 = rb_cTrueClass, ruby_errinfo != 2 &&
        (iVar3 = rb_cSymbol, (char)ruby_errinfo != '\x0e')))) {
      iVar3 = *(int *)(ruby_errinfo + 4);
    }
    iVar2 = rb_obj_as_string(ruby_errinfo);
    if ((rb_eRuntimeError != iVar3) || (msg_00 = "unhandled exception", *(int *)(iVar2 + 8) != 0)) {
      iVar3 = rb_class_path(iVar3);
      msg_00 = (char *)buff;
      __snprintf_chk(msg_00,0x400,1,0x400,"%s: %s",*(undefined4 *)(iVar3 + 0xc),
                     *(undefined4 *)(iVar2 + 0xc));
      pcVar4 = strchr(msg_00,10);
      if (pcVar4 != (char *)0x0) {
        *pcVar4 = '\0';
      }
    }
  }
  alert_ruby_error(ses,(uchar *)msg_00);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void init_ruby(module *module)

{
  undefined4 uVar1;
  uchar *home;
  uchar *puVar2;
  int iVar3;
  uchar *path;
  int local_10 [2];
  
  ruby_init();
  ruby_script("ELinks-ruby");
  ruby_init_loadpath();
  rb_define_singleton_method(rb_stdout,"write",erb_module_message,1);
  rb_define_global_function(&DAT_08132310,erb_stdout_p,0xffffffff);
  erb_module = rb_define_module("ELinks");
  uVar1 = rb_str_new2("0.12pre5");
  rb_define_const(erb_module,"VERSION",uVar1);
  puVar2 = elinks_home;
  if (elinks_home == (uchar *)0x0) {
    puVar2 = (uchar *)"/etc/elinks";
  }
  uVar1 = rb_str_new2(puVar2);
  rb_define_const(erb_module,&DAT_0813381e,uVar1);
  rb_define_module_function(erb_module,"message",erb_module_message,1);
  rb_define_module_function(erb_module,"method_missing",erb_module_method_missing,0xffffffff);
  rb_define_module_function(erb_module,&DAT_08132310,erb_stdout_p,0xffffffff);
  if (elinks_home == (uchar *)0x0) {
    path = stracpy((uchar *)"/etc/elinks/hooks.rb");
  }
  else {
    path = straconcat(elinks_home,"hooks.rb",0);
  }
  if (path != (uchar *)0x0) {
    iVar3 = file_can_read(path);
    if (iVar3 != 0) {
      uVar1 = rb_str_new2(path);
      rb_load_protect(uVar1,0,local_10);
      if (local_10[0] != 0) {
        erb_report_error((session *)0x0,local_10[0]);
      }
    }
    mem_free(path);
  }
  return;
}



// WARNING: Unknown calling convention

evhook_status script_hook_quit(va_list ap,void *data)

{
  erb_protect_info info;
  int local_14;
  VALUE args [1];
  
  info.args = args;
  info.name = "quit_hook";
  info.argc = 0;
  rb_protect(do_erb_protected_method_call,&info,&local_14);
  if (local_14 != 0) {
    erb_report_error((session *)0x0,local_14);
  }
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

VALUE do_erb_protected_method_call(VALUE data)

{
  undefined4 uVar1;
  ID method_id;
  VALUE VVar2;
  
  if ((assert_failed == 0) && (assert_failed = (int)(data == 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/scripting/ruby/hooks.c";
    errline = 0x26;
    elinks_internal((uchar *)"assertion info failed!");
  }
  uVar1 = rb_intern(*(undefined4 *)data);
  VVar2 = rb_funcall3(erb_module,uVar1,*(undefined4 *)(data + 4),*(undefined4 *)(data + 8));
  return VVar2;
}



// WARNING: Unknown calling convention

evhook_status script_hook_get_proxy(va_list ap,void *data)

{
  char *__s;
  uchar **ppuVar1;
  VALUE result;
  size_t sVar2;
  uint *puVar3;
  uchar *puVar4;
  uchar *url;
  uchar *proxy;
  uchar **new_proxy_url;
  erb_protect_info info;
  VALUE args [1];
  int local_10;
  
  __s = *(char **)(ap + 4);
  ppuVar1 = *(uchar ***)ap;
  if ((__s != (char *)0x0) && (ppuVar1 != (uchar **)0x0)) {
    sVar2 = strlen(__s);
    args[0] = rb_str_new(__s,sVar2);
    info.name = "proxy_hook";
    info.argc = 1;
    info.args = args;
    puVar3 = (uint *)rb_protect(do_erb_protected_method_call,&info,&local_10);
    if (local_10 == 0) {
      if (((uint)puVar3 & 1) != 0) {
LAB_080d3d40:
        alert_ruby_error((session *)0x0,(uchar *)"proxy_hook must return a string or nil");
        return EVENT_HOOK_STATUS_NEXT;
      }
      if (puVar3 != (uint *)0x4) {
        if ((((puVar3 == (uint *)0x0) || (puVar3 == (uint *)0x2)) || (puVar3 == (uint *)0x6)) ||
           ((char)puVar3 == '\x0e')) goto LAB_080d3d40;
        if ((*puVar3 & 0x3f) != 1) {
          if ((*puVar3 & 0x3f) != 7) goto LAB_080d3d40;
          puVar4 = memacpy((uchar *)puVar3[3],puVar3[2]);
          if (puVar4 != (uchar *)0x0) {
            if (*ppuVar1 != (uchar *)0x0) {
              mem_free(*ppuVar1);
            }
            *ppuVar1 = puVar4;
          }
        }
      }
    }
    else {
      erb_report_error((session *)0x0,local_10);
    }
  }
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

evhook_status script_hook_follow_url(va_list ap,void *data)

{
  uchar **ppuVar1;
  session *ses_00;
  VALUE result;
  size_t sVar2;
  uint *puVar3;
  uchar *puVar4;
  uchar *new_url;
  uchar **url;
  session *ses;
  erb_protect_info info;
  VALUE args [1];
  int local_20 [4];
  
  ppuVar1 = *(uchar ***)ap;
  ses_00 = *(session **)(ap + 4);
  puVar4 = *ppuVar1;
  if (puVar4 != (uchar *)0x0) {
    sVar2 = strlen((char *)puVar4);
    args[0] = rb_str_new(puVar4,sVar2);
    info.name = "follow_url_hook";
    info.argc = 1;
    info.args = args;
    puVar3 = (uint *)rb_protect(do_erb_protected_method_call,&info,local_20);
    if (local_20[0] == 0) {
      if (((uint)puVar3 & 1) == 0) {
        if (puVar3 == (uint *)0x4) {
          return EVENT_HOOK_STATUS_NEXT;
        }
        if ((((puVar3 != (uint *)0x0) && (puVar3 != (uint *)0x2)) && (puVar3 != (uint *)0x6)) &&
           ((char)puVar3 != '\x0e')) {
          if ((*puVar3 & 0x3f) == 1) {
            return EVENT_HOOK_STATUS_NEXT;
          }
          if ((*puVar3 & 0x3f) == 7) {
            puVar4 = memacpy((uchar *)puVar3[3],puVar3[2]);
            if (puVar4 == (uchar *)0x0) {
              return EVENT_HOOK_STATUS_NEXT;
            }
            if (*ppuVar1 != (uchar *)0x0) {
              mem_free(*ppuVar1);
            }
            *ppuVar1 = puVar4;
            return EVENT_HOOK_STATUS_NEXT;
          }
        }
      }
      alert_ruby_error(ses_00,(uchar *)"follow_url_hook must return a string or nil");
    }
    else {
      erb_report_error(ses_00,local_20[0]);
    }
  }
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

evhook_status script_hook_goto_url(va_list ap,void *data)

{
  uchar **ppuVar1;
  session *ses_00;
  location *plVar2;
  VALUE result;
  size_t sVar3;
  uint *puVar4;
  uchar *puVar5;
  uchar *new_url;
  session *ses;
  uchar **url;
  erb_protect_info info;
  VALUE args [2];
  int local_20 [4];
  
  ppuVar1 = *(uchar ***)ap;
  ses_00 = *(session **)(ap + 4);
  puVar5 = *ppuVar1;
  if (puVar5 == (uchar *)0x0) {
    return EVENT_HOOK_STATUS_NEXT;
  }
  sVar3 = strlen((char *)puVar5);
  args[0] = rb_str_new(puVar5,sVar3);
  if ((ses_00 == (session *)0x0) || (plVar2 = (ses_00->history).current, plVar2 == (location *)0x0))
  {
    args[1] = 4;
  }
  else {
    puVar5 = ((plVar2->vs).uri)->string;
    sVar3 = strlen((char *)puVar5);
    args[1] = rb_str_new(puVar5,sVar3);
  }
  info.args = args;
  info.name = "goto_url_hook";
  info.argc = 2;
  puVar4 = (uint *)rb_protect(do_erb_protected_method_call,&info,local_20);
  if (local_20[0] != 0) {
    erb_report_error(ses_00,local_20[0]);
    return EVENT_HOOK_STATUS_NEXT;
  }
  if (((uint)puVar4 & 1) == 0) {
    if (puVar4 == (uint *)0x4) {
      return EVENT_HOOK_STATUS_NEXT;
    }
    if ((((puVar4 != (uint *)0x0) && (puVar4 != (uint *)0x2)) && (puVar4 != (uint *)0x6)) &&
       ((char)puVar4 != '\x0e')) {
      if ((*puVar4 & 0x3f) == 1) {
        return EVENT_HOOK_STATUS_NEXT;
      }
      if ((*puVar4 & 0x3f) == 7) {
        puVar5 = memacpy((uchar *)puVar4[3],puVar4[2]);
        if (puVar5 == (uchar *)0x0) {
          return EVENT_HOOK_STATUS_NEXT;
        }
        if (*ppuVar1 != (uchar *)0x0) {
          mem_free(*ppuVar1);
        }
        *ppuVar1 = puVar5;
        return EVENT_HOOK_STATUS_NEXT;
      }
    }
  }
  alert_ruby_error(ses_00,(uchar *)"goto_url_hook must return a string or nil");
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

evhook_status script_hook_pre_format_html(va_list ap,void *data)

{
  cache_entry *cached_00;
  session *ses_00;
  uint length;
  VALUE result;
  fragment *pfVar1;
  uint *puVar2;
  uchar *url;
  cache_entry *cached;
  fragment *fragment;
  int len;
  session *ses;
  erb_protect_info info;
  VALUE args [2];
  int local_20 [4];
  
  cached_00 = *(cache_entry **)(ap + 4);
  ses_00 = *(session **)ap;
  pfVar1 = get_cache_fragment(cached_00);
  if (((*(uint *)((int)&cached_00->length + 4) | *(uint *)&cached_00->length) != 0) &&
     (pfVar1->data[0] != '\0')) {
    args[0] = rb_str_new2(cached_00->uri->string);
    args[1] = rb_str_new(pfVar1->data,*(undefined4 *)&pfVar1->length);
    info.name = "pre_format_html_hook";
    info.argc = 2;
    info.args = args;
    puVar2 = (uint *)rb_protect(do_erb_protected_method_call,&info,local_20);
    if (local_20[0] == 0) {
      if (((uint)puVar2 & 1) == 0) {
        if (puVar2 == (uint *)0x4) {
          return EVENT_HOOK_STATUS_NEXT;
        }
        if ((((puVar2 != (uint *)0x0) && (puVar2 != (uint *)0x2)) && (puVar2 != (uint *)0x6)) &&
           ((char)puVar2 != '\x0e')) {
          if ((*puVar2 & 0x3f) == 1) {
            return EVENT_HOOK_STATUS_NEXT;
          }
          if ((*puVar2 & 0x3f) == 7) {
            length = puVar2[2];
            add_fragment(cached_00,0,(uchar *)puVar2[3],length);
            normalize_cache_entry(cached_00,(longlong)(int)length);
            return EVENT_HOOK_STATUS_NEXT;
          }
        }
      }
      alert_ruby_error(ses_00,(uchar *)"pre_format_html_hook must return a string or nil");
    }
    else {
      erb_report_error(ses_00,local_20[0]);
    }
  }
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

int are_there_downloads(void)

{
  file_download *file_download;
  list_head_elinks *plVar1;
  
  plVar1 = (list_head_elinks *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (plVar1[2].prev == (void *)0x0) {
        return 1;
      }
      plVar1 = (list_head_elinks *)plVar1->next;
    } while (plVar1 != &downloads);
  }
  return 0;
}



// WARNING: Unknown calling convention

void lun_cancel(void *lun_hop_)

{
  void *p;
  void *p_1;
  lun_hop *lun_hop;
  
                    // WARNING: Load size is inaccurate
  (**(code **)((int)lun_hop_ + 0xc))(*lun_hop_,0,*(undefined4 *)((int)lun_hop_ + 0x10),0);
  if (*(void **)((int)lun_hop_ + 4) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 4));
  }
  if (*(void **)((int)lun_hop_ + 8) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 8));
  }
  mem_free(lun_hop_);
  return;
}



// WARNING: Unknown calling convention

void lun_overwrite(void *lun_hop_)

{
  void *p;
  lun_hop *lun_hop;
  
                    // WARNING: Load size is inaccurate
  (**(code **)((int)lun_hop_ + 0xc))
            (*lun_hop_,*(undefined4 *)((int)lun_hop_ + 4),*(undefined4 *)((int)lun_hop_ + 0x10),0);
  if (*(void **)((int)lun_hop_ + 8) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 8));
  }
  mem_free(lun_hop_);
  return;
}



// WARNING: Unknown calling convention

void lun_alternate(void *lun_hop_)

{
  void *p;
  lun_hop *lun_hop;
  
                    // WARNING: Load size is inaccurate
  (**(code **)((int)lun_hop_ + 0xc))
            (*lun_hop_,*(undefined4 *)((int)lun_hop_ + 8),*(undefined4 *)((int)lun_hop_ + 0x10),0);
  if (*(void **)((int)lun_hop_ + 4) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 4));
  }
  mem_free(lun_hop_);
  return;
}



// WARNING: Unknown calling convention

widget_handler_status_T tp_show_header(dialog_data *dlg_data,widget_data *widget_data)

{
  void *pvVar1;
  type_query *type_query;
  
  pvVar1 = widget_data->widget->data;
  cached_header_dialog(*(session **)((int)pvVar1 + 0x3c),*(cache_entry **)((int)pvVar1 + 0x38));
  return EVENT_PROCESSED;
}



// WARNING: Unknown calling convention

uchar * subst_file(uchar *prog,uchar *file)

{
  uchar uVar1;
  bool bVar2;
  string *psVar3;
  int p;
  size_t sVar4;
  int iVar5;
  uchar *puVar6;
  size_t oldsize;
  uint uVar7;
  uint uVar8;
  uchar uVar9;
  size_t newsize;
  uint size;
  size_t sVar10;
  uchar *puVar11;
  byte bVar12;
  string s;
  string name;
  
  bVar12 = 0;
  psVar3 = init_string(&name);
  bVar2 = true;
  if (psVar3 == (string *)0x0) {
    return (uchar *)0x0;
  }
LAB_080d42ac:
  uVar9 = *prog;
  if (uVar9 != '\0') {
    do {
      sVar4 = 0;
      sVar10 = 0;
      puVar11 = prog;
      if (uVar9 != '%') {
        do {
          sVar4 = sVar4 + 1;
          sVar10 = sVar4;
          puVar11 = prog + sVar4;
          if (prog[sVar4] == '%') break;
        } while (prog[sVar4] != '\0');
      }
      if (assert_failed == 0) {
        if ((int)sVar10 < 0) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 0xff;
          elinks_internal((uchar *)
                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if (assert_failed != 0) goto LAB_080d43b8;
        }
        else {
          assert_failed = 0;
        }
        if (sVar10 != 0) {
          iVar5 = sVar10 + name.length;
          uVar8 = name.length + 0xffU >> 8;
          uVar7 = name.length + 0xffU & 0xffffff00;
          size = iVar5 + 0x100U & 0xffffff00;
          if (uVar7 <= size && size + uVar8 * -0x100 != 0) {
            puVar6 = (uchar *)mem_realloc(name.source,size);
            if (puVar6 == (uchar *)0x0) goto LAB_080d434a;
            name.source = puVar6;
            memset(puVar6 + uVar7,0,size + uVar8 * -0x100);
          }
          if (name.source != (uchar *)0x0) {
            memcpy(name.source + name.length,prog,sVar10);
            name.source[iVar5] = '\0';
            name.length = iVar5;
          }
        }
LAB_080d434a:
        uVar9 = *puVar11;
      }
      else {
LAB_080d43b8:
        assert_failed = 0;
        uVar9 = *puVar11;
      }
      if (uVar9 == '%') goto LAB_080d43ca;
      prog = puVar11;
      if (uVar9 == '\0') break;
    } while( true );
  }
  if (!bVar2) {
    return name.source;
  }
  psVar3 = init_string(&s);
  if (psVar3 == (string *)0x0) {
    return name.source;
  }
  add_to_string(&s,(uchar *)"/bin/cat ");
  uVar8 = 0xffffffff;
  puVar11 = file;
  do {
    if (uVar8 == 0) break;
    uVar8 = uVar8 - 1;
    uVar1 = *puVar11;
    puVar11 = puVar11 + (uint)bVar12 * -2 + 1;
  } while (uVar9 != uVar1);
  add_shell_quoted_to_string(&s,file,~uVar8 - 1);
  add_to_string(&s," | ");
  add_string_to_string(&s,&name);
  done_string(&name);
  return s.source;
LAB_080d43ca:
  prog = puVar11 + 1;
  sVar10 = strlen((char *)file);
  add_shell_quoted_to_string(&name,file,sVar10);
  bVar2 = false;
  goto LAB_080d42ac;
}



// WARNING: Unknown calling convention

void tp_save(type_query *type_query)

{
  if (type_query->external_handler != (uchar *)0x0) {
    mem_free(type_query->external_handler);
  }
  type_query->external_handler = (uchar *)0x0;
  query_file(type_query->ses,type_query->uri,type_query,continue_download,tp_cancel,1);
  return;
}



// WARNING: Unknown calling convention

void done_type_query(type_query *type_query)

{
  object *poVar1;
  void *p;
  void *p_1;
  
  cancel_download(&type_query->download,0);
  poVar1 = &type_query->cached->object;
  poVar1->refcount = poVar1->refcount + -1;
  done_uri(type_query->uri);
  if (type_query->external_handler != (uchar *)0x0) {
    mem_free(type_query->external_handler);
  }
  if (type_query->target_frame != (uchar *)0x0) {
    mem_free(type_query->target_frame);
  }
  type_query->next->prev = type_query->prev;
  type_query->prev->next = type_query->next;
  mem_free(type_query);
  return;
}



// WARNING: Unknown calling convention

void tp_display(type_query *type_query)

{
  session *ses_00;
  uri *puVar1;
  uchar *puVar2;
  location *plVar3;
  view_state *pvVar4;
  view_state *vs;
  uri *loading_uri;
  session *ses;
  uchar *target_frame;
  
  ses_00 = type_query->ses;
  puVar1 = ses_00->loading_uri;
  ses_00->loading_uri = type_query->uri;
  puVar2 = (ses_00->task).target.frame;
  (ses_00->task).target.frame = type_query->target_frame;
  pvVar4 = ses_forward(ses_00,0);
  if (pvVar4 != (view_state *)0x0) {
    pvVar4->plain = 1;
  }
  plVar3 = (ses_00->history).current;
  ses_00->loading_uri = puVar1;
  (ses_00->task).target.frame = puVar2;
  (plVar3->download).data = ses_00;
  (plVar3->download).callback = doc_loading_callback;
  move_download(&type_query->download,&plVar3->download,PRI_DOWNLOAD);
  display_timer(ses_00);
  done_type_query(type_query);
  return;
}



// WARNING: Unknown calling convention

void tp_cancel(void *data)

{
  cancel_download((download *)((int)data + 8),1);
  done_type_query((type_query *)data);
  return;
}



// WARNING: Unknown calling convention

void lun_resume(void *lun_hop_)

{
  int *piVar1;
  void *p_00;
  void *data;
  int iVar2;
  int iVar3;
  undefined4 *puVar4;
  void *p;
  undefined4 *puVar5;
  type_query *type_query;
  void *p_1;
  lun_hop *lun_hop;
  cdf_hop *cdf_hop;
  cmdw_hop *cmdw_hop;
  
  puVar4 = *(undefined4 **)((int)lun_hop_ + 0x10);
  if (*(int *)puVar4[3] == 1) {
    puVar5 = (undefined4 *)mem_calloc(1,0xc);
    if (puVar5 == (undefined4 *)0x0) {
      lun_cancel(lun_hop_);
      return;
    }
    p_00 = (void *)puVar4[3];
    data = *(void **)((int)p_00 + 4);
    *puVar5 = 0;
    iVar2 = *(int *)((int)data + 0x3c);
    puVar5[1] = iVar2;
    iVar3 = *(int *)((int)data + 0x40);
    piVar1 = (int *)(iVar3 + 0x38);
    *piVar1 = *piVar1 + 1;
    *(int *)(iVar2 + 0x68) = iVar3;
    if ((*(int *)((int)data + 0x48) != 0) && (*(void **)((int)p_00 + 0xc) != (void *)0x0)) {
      mem_free(*(void **)((int)p_00 + 0xc));
    }
    tp_cancel(data);
    mem_free(p_00);
    *puVar4 = puVar5 + 2;
    puVar4[3] = puVar5;
    puVar4[2] = common_download_do;
    puVar4 = *(undefined4 **)((int)lun_hop_ + 0x10);
  }
                    // WARNING: Load size is inaccurate
  (**(code **)((int)lun_hop_ + 0xc))(*lun_hop_,*(undefined4 *)((int)lun_hop_ + 4),puVar4,1);
  if (*(void **)((int)lun_hop_ + 8) != (void *)0x0) {
    mem_free(*(void **)((int)lun_hop_ + 8));
  }
  mem_free(lun_hop_);
  return;
}



// WARNING: Unknown calling convention

void download_error_dialog(file_download *file_download,int saved_errno)

{
  terminal *term_00;
  char *pcVar1;
  uchar *text;
  terminal *term;
  
  pcVar1 = strerror(saved_errno);
  term_00 = file_download->term;
  if (file_download->ses != (session *)0x0) {
    text = msg_text(term_00,(uchar *)"Could not create file \'%s\':\n%s",file_download->file,pcVar1)
    ;
    info_box(term_00,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,text);
  }
  return;
}



// WARNING: Unknown calling convention

void create_download_file_do(terminal *term,uchar *file,void *data,int resume)

{
  uchar *puVar1;
  uchar uVar2;
  int iVar3;
  uchar *puVar4;
  int *piVar5;
  option_value *poVar6;
  int i;
  char *pcVar7;
  int sf;
  uchar *puVar8;
  int iVar9;
  int h;
  size_t local_2c;
  
  iVar9 = -1;
  iVar3 = *(int *)((int)data + 4);
  if (file != (uchar *)0x0) {
    puVar4 = get_cwd();
    set_cwd(term->cwd);
    mkalldirs(file);
    iVar9 = 0x41;
    if (resume == 0) {
      iVar9 = (-(uint)(iVar3 == 0) & 0xffffff80) + 0x2c1;
    }
    iVar9 = open64((char *)file,iVar9,(-(uint)(iVar3 == 0) & 0x36) + 0x180);
    piVar5 = __errno_location();
    iVar3 = *piVar5;
    if (puVar4 != (uchar *)0x0) {
      set_cwd(puVar4);
      mem_free(puVar4);
    }
    if (iVar9 == -1) {
      pcVar7 = strerror(iVar3);
      puVar4 = msg_text(term,(uchar *)"Could not create file \'%s\':\n%s",file,pcVar7);
      info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,puVar4);
      mem_free(file);
    }
    else {
      set_bin(iVar9);
      if (*(int *)((int)data + 4) == 0) {
        poVar6 = get_opt_();
        puVar4 = poVar6->string;
        safe_strncpy(puVar4,file,0x400);
        local_2c = strlen((char *)puVar4);
        if (-1 < (int)local_2c) {
          puVar8 = puVar4 + local_2c;
          uVar2 = *puVar8;
          while (uVar2 != '/') {
            local_2c = local_2c - 1;
            if (local_2c == 0xffffffff) {
              local_2c = 0xffffffff;
              break;
            }
            puVar1 = puVar8 + -1;
            puVar8 = puVar8 + -1;
            uVar2 = *puVar1;
          }
        }
        puVar4[local_2c + 1] = '\0';
      }
                    // WARNING: Load size is inaccurate
      if (*data == (uchar **)0x0) {
        mem_free(file);
      }
      else {
        **data = file;
      }
    }
  }
  (**(code **)((int)data + 8))(term,iVar9,*(undefined4 *)((int)data + 0xc),resume);
  mem_free(data);
  return;
}



// WARNING: Unknown calling convention

void abort_download(file_download *file_download)

{
  void *p;
  uchar *__name;
  
  done_download_display(file_download);
  if (file_download->ses != (session *)0x0) {
    check_questions_queue(file_download->ses);
  }
  if (file_download->dlg_data != (dialog_data *)0x0) {
    cancel_dialog(file_download->dlg_data,(widget_data *)0x0);
  }
  cancel_download(&file_download->download,(byte)file_download->field_0x68 >> 1 & 1);
  if (file_download->uri != (uri *)0x0) {
    done_uri(file_download->uri);
  }
  if (file_download->handle != -1) {
    close(file_download->handle);
  }
  if (file_download->external_handler != (uchar *)0x0) {
    mem_free(file_download->external_handler);
  }
  __name = file_download->file;
  if (__name != (uchar *)0x0) {
    if ((file_download->field_0x68 & 1) != 0) {
      unlink((char *)__name);
      __name = file_download->file;
    }
    mem_free(__name);
  }
  file_download->next->prev = file_download->prev;
  file_download->prev->next = file_download->next;
  mem_free(file_download);
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

void kill_downloads_to_file(uchar *file)

{
  int iVar1;
  file_download *file_download;
  file_download *pfVar2;
  
  pfVar2 = (file_download *)downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      while (iVar1 = strcmp((char *)pfVar2->file,(char *)file), iVar1 == 0) {
        pfVar2 = pfVar2->prev;
        abort_download(pfVar2->next);
        pfVar2 = pfVar2->next;
        if (pfVar2 == (file_download *)&downloads) {
          return;
        }
      }
      pfVar2 = pfVar2->next;
    } while (pfVar2 != (file_download *)&downloads);
  }
  return;
}



// WARNING: Unknown calling convention

void detach_downloads_from_terminal(terminal *term)

{
  file_download *pfVar1;
  bool bVar2;
  file_download *file_download;
  file_download *file_download_00;
  file_download *next;
  file_download *pfVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(term == (terminal *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
    errline = 0xe3;
    elinks_internal((uchar *)"assertion term != NULL failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
                    // WARNING: Load size is inaccurate
  file_download_00 = (file_download *)downloads.next;
  pfVar3 = *downloads.next;
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      if (file_download_00->term == term) {
        if (file_download_00->external_handler == (uchar *)0x0) {
          file_download_00->term = (terminal *)0x0;
          if ((file_download_00->ses != (session *)0x0) &&
             (term == file_download_00->ses->tab->term)) {
            file_download_00->ses = (session *)0x0;
          }
          goto LAB_080d4b50;
        }
        abort_download(file_download_00);
        pfVar1 = pfVar3->next;
      }
      else {
LAB_080d4b50:
        pfVar1 = pfVar3->next;
      }
      bVar2 = pfVar3 != (file_download *)&downloads;
      file_download_00 = pfVar3;
      pfVar3 = pfVar1;
    } while (bVar2);
  }
  return;
}



// WARNING: Unknown calling convention

void destroy_downloads(session *ses)

{
  file_download *file_download;
  list_head_elinks *plVar1;
  file_download *file_download_00;
  session *s;
  session *psVar2;
  file_download *next;
  file_download *pfVar3;
  bool bVar4;
  
  psVar2 = (session *)sessions.next;
  if ((list_head_elinks *)sessions.next != &sessions) {
    do {
      if ((psVar2 != ses) && (psVar2->tab->term == ses->tab->term)) {
        plVar1 = (list_head_elinks *)downloads.next;
        if ((list_head_elinks *)downloads.next == &downloads) {
          return;
        }
        do {
          while ((session *)plVar1[3].next != ses) {
            plVar1 = (list_head_elinks *)plVar1->next;
            if (plVar1 == &downloads) {
              return;
            }
          }
          plVar1[3].next = psVar2;
          plVar1 = (list_head_elinks *)plVar1->next;
        } while (plVar1 != &downloads);
        return;
      }
      psVar2 = psVar2->next;
    } while (psVar2 != (session *)&sessions);
  }
                    // WARNING: Load size is inaccurate
  file_download_00 = (file_download *)downloads.next;
  pfVar3 = *downloads.next;
  if ((list_head_elinks *)downloads.next == &downloads) {
    return;
  }
  do {
    if (file_download_00->ses == ses) {
      if (file_download_00->external_handler == (uchar *)0x0) {
        file_download_00->ses = (session *)0x0;
      }
      else {
        abort_download(file_download_00);
      }
    }
    bVar4 = pfVar3 != (file_download *)&downloads;
    file_download_00 = pfVar3;
    pfVar3 = pfVar3->next;
  } while (bVar4);
  return;
}



// WARNING: Unknown calling convention

void abort_all_downloads(void)

{
  if ((list_head_elinks *)downloads.next != &downloads) {
    do {
      abort_download((file_download *)downloads.next);
    } while ((list_head_elinks *)downloads.next != &downloads);
  }
  return;
}



// WARNING: Unknown calling convention

file_download * init_file_download(uri *uri,session *ses,uchar *file,int fd)

{
  file_download *file_download_00;
  file_download *file_download;
  uri *puVar1;
  file_download *pfVar2;
  
  file_download_00 = (file_download *)mem_calloc(1,0x74);
  pfVar2 = file_download_00;
  if (file_download_00 != (file_download *)0x0) {
    puVar1 = get_composed_uri(uri,URI_BASE);
    file_download_00->uri = puVar1;
    if (puVar1 == (uri *)0x0) {
      pfVar2 = (file_download *)0x0;
      mem_free(file_download_00);
    }
    else {
      init_download_display(file_download_00);
      file_download_00->file = file;
      (file_download_00->download).callback = download_data;
      (file_download_00->download).data = file_download_00;
      file_download_00->ses = ses;
      file_download_00->handle = fd;
      file_download_00->term = ses->tab->term;
      file_download_00->prev = (file_download *)&downloads;
      file_download_00->next = (file_download *)downloads.next;
      downloads.next = file_download_00;
      file_download_00->next->prev = file_download_00;
    }
  }
  return pfVar2;
}



// WARNING: Unknown calling convention

void continue_download_do(terminal *term,int fd,void *data,int resume)

{
  type_query *type_query_00;
  file_download *file_download_00;
  file_download *file_download;
  uchar *puVar1;
  void *p;
  codw_hop *codw_hop;
  type_query *type_query;
  
  if (assert_failed == 0) {
    assert_failed = (int)(data == (void *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x379;
      elinks_internal((uchar *)"assertion codw_hop failed!");
      if (assert_failed != 0) goto LAB_080d4e1e;
    }
    assert_failed = (int)(*(int *)((int)data + 4) == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x37a;
      elinks_internal((uchar *)"assertion codw_hop->type_query failed!");
      if (assert_failed != 0) goto LAB_080d4e1e;
    }
    assert_failed = (int)(*(int *)(*(int *)((int)data + 4) + 0x40) == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x37b;
      elinks_internal((uchar *)"assertion codw_hop->type_query->uri failed!");
      if (assert_failed != 0) goto LAB_080d4e1e;
    }
    assert_failed = (int)(*(int *)(*(int *)((int)data + 4) + 0x3c) == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
      errline = 0x37c;
      elinks_internal((uchar *)"assertion codw_hop->type_query->ses failed!");
    }
  }
LAB_080d4e1e:
  type_query_00 = *(type_query **)((int)data + 4);
  if ((*(uchar **)((int)data + 8) != (uchar *)0x0) &&
     (file_download_00 =
           init_file_download(type_query_00->uri,type_query_00->ses,*(uchar **)((int)data + 8),fd),
     file_download_00 != (file_download *)0x0)) {
    if (type_query_00->external_handler != (uchar *)0x0) {
      puVar1 = subst_file(type_query_00->external_handler,*(uchar **)((int)data + 0xc));
      file_download_00->field_0x68 = file_download_00->field_0x68 | 1;
      file_download_00->external_handler = puVar1;
      mem_free(*(void **)((int)data + 0xc));
      if (type_query_00->external_handler != (uchar *)0x0) {
        mem_free(type_query_00->external_handler);
      }
      type_query_00->external_handler = (uchar *)0x0;
    }
    file_download_00->field_0x68 =
         file_download_00->field_0x68 & 0xfb | (type_query_00->block != 0) << 2;
    display_download(term,file_download_00,type_query_00->ses);
    move_download(&type_query_00->download,&file_download_00->download,PRI_DOWNLOAD);
    done_type_query(type_query_00);
    mem_free(data);
    return;
  }
  if ((type_query_00->external_handler != (uchar *)0x0) &&
     (*(void **)((int)data + 0xc) != (void *)0x0)) {
    mem_free(*(void **)((int)data + 0xc));
  }
  tp_cancel(type_query_00);
  mem_free(data);
  return;
}



// WARNING: Unknown calling convention

void common_download_do(terminal *term,int fd,void *data,int resume)

{
  uchar *file_00;
  session *ses_00;
  int iVar1;
  file_download *file_download_00;
  session *ses;
  uchar *file;
  file_download *file_download;
  stat buf;
  
  file_00 = *(uchar **)((int)data + 8);
  ses_00 = *(session **)((int)data + 4);
  mem_free(data);
  if (file_00 != (uchar *)0x0) {
    iVar1 = __fxstat64(3,fd,(stat64 *)&buf);
    if (iVar1 == 0) {
      file_download_00 = init_file_download(ses_00->download_uri,ses_00,file_00,fd);
      if (file_download_00 != (file_download *)0x0) {
        if (resume != 0) {
          *(undefined4 *)&file_download_00->seek = (undefined4)buf.st_size;
          *(undefined4 *)((int)&file_download_00->seek + 4) = buf.st_size._4_4_;
        }
        display_download(ses_00->tab->term,file_download_00,ses_00);
        load_uri(file_download_00->uri,ses_00->referrer,&file_download_00->download,PRI_DOWNLOAD,
                 CACHE_MODE_NORMAL,file_download_00->seek);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void abort_download_and_beep(file_download *file_download,terminal *term)

{
  option_value *poVar1;
  
  if (term != (terminal *)0x0) {
    poVar1 = get_opt_();
    if (1 < (int)&poVar1->tree->next + file_download->notify) {
      beep_terminal(term);
    }
  }
  abort_download(file_download);
  return;
}



// WARNING: Unknown calling convention

void download_data_store(download *download,file_download *file_download)

{
  terminal *suspect;
  connection_basic_state cVar1;
  connection_state state;
  uchar *puVar2;
  uchar *puVar3;
  option_value *poVar4;
  terminal *term;
  uchar *url;
  utimbuf foo;
  
  suspect = file_download->term;
  assert_terminal_ptr_not_dangling(suspect);
  if (assert_failed == 0) {
    if (suspect != (terminal *)0x0) {
      cVar1 = (download->state).basic;
      if (S_ERRNO < cVar1) {
        if (file_download->dlg_data == (dialog_data *)0x0) {
          return;
        }
        redraw_dialog(file_download->dlg_data,1);
        return;
      }
      if (cVar1 == S_OK) {
        if (file_download->external_handler != (uchar *)0x0) {
          close(file_download->handle);
          file_download->handle = -1;
          exec_on_terminal(suspect,file_download->external_handler,file_download->file,
                           (byte)file_download->field_0x68 >> 2 & TERM_EXEC_FG);
          file_download->field_0x68 = file_download->field_0x68 & 0xfe;
          abort_download_and_beep(file_download,suspect);
          return;
        }
        if (file_download->notify != 0) {
          puVar2 = get_uri_string(file_download->uri,URI_PUBLIC);
          done_download_display(file_download);
          if (puVar2 != (uchar *)0x0) {
            puVar3 = msg_text(suspect,(uchar *)"Download complete:\n%s",puVar2);
            info_box(suspect,MSGBOX_FREE_TEXT,(uchar *)"Download",ALIGN_CENTER,puVar3);
            mem_free(puVar2);
          }
        }
        if ((file_download->remotetime != 0) &&
           (poVar4 = get_opt_(), poVar4->tree != (list_head_elinks *)0x0)) {
          foo.actime = file_download->remotetime;
          foo.modtime = foo.actime;
          utime((char *)file_download->file,(utimbuf *)&foo);
        }
        abort_download_and_beep(file_download,suspect);
        return;
      }
      puVar2 = get_uri_string(file_download->uri,URI_PUBLIC);
      state = download->state;
      abort_download_and_beep(file_download,suspect);
      if (puVar2 == (uchar *)0x0) {
        return;
      }
      puVar3 = get_state_message(state,suspect);
      puVar3 = msg_text(suspect,(uchar *)"Error downloading %s:\n\n%s",puVar2,puVar3);
      info_box(suspect,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,puVar3);
      mem_free(puVar2);
      return;
    }
  }
  else {
    assert_failed = 0;
    file_download->term = (terminal *)0x0;
  }
  abort_download(file_download);
  return;
}



// WARNING: Unknown calling convention

void download_data(download *download,file_download *file_download)

{
  object *poVar1;
  cache_entry *pcVar2;
  progress *ppVar3;
  uint uVar4;
  uri *puVar5;
  dialog_data *dlg_data;
  time_t tVar6;
  uint uVar7;
  uint uVar8;
  ssize_t w;
  int *piVar9;
  connection_basic_state cVar10;
  undefined4 uVar11;
  int *piVar12;
  int iVar13;
  undefined4 uVar14;
  fragment *frag;
  cache_entry *cached;
  __off64_t _Var15;
  uint local_24;
  int local_20;
  
  pcVar2 = download->cached;
  if ((pcVar2 != (cache_entry *)0x0) && (7 < (uint)(download->state).basic)) {
    if (pcVar2->last_modified != (uchar *)0x0) {
      tVar6 = parse_date(&pcVar2->last_modified,(uchar *)0x0,0,1);
      file_download->remotetime = tVar6;
    }
    if ((pcVar2->redirect != (uri *)0x0) &&
       (iVar13 = file_download->redirect_cnt, file_download->redirect_cnt = iVar13 + 1, iVar13 < 10)
       ) {
      cancel_download(&file_download->download,0);
      if (assert_failed == 0) {
        iVar13 = compare_uri(pcVar2->uri,file_download->uri,0);
        assert_failed = (int)(iVar13 == 0);
        if (iVar13 == 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
          errline = 0x1a5;
          elinks_internal((uchar *)
                          "assertion compare_uri(cached->uri, file_download->uri, 0) failed: Redirecting using bad base URI"
                         );
        }
      }
      done_uri(file_download->uri);
      puVar5 = pcVar2->redirect;
      poVar1 = &puVar5->object;
      poVar1->refcount = poVar1->refcount + 1;
      file_download->uri = puVar5;
      if (assert_failed == 0) {
        cVar10 = S_WAIT_REDIR;
      }
      else {
        cVar10 = S_INTERNAL;
      }
      assert_failed = 0;
      (file_download->download).state.basic = cVar10;
      dlg_data = file_download->dlg_data;
      (file_download->download).state.syserr = 0;
      if (dlg_data != (dialog_data *)0x0) {
        redraw_dialog(dlg_data,1);
      }
      uVar11 = 0;
      ppVar3 = download->progress;
      uVar14 = 0;
      if (ppVar3 != (progress *)0x0) {
        uVar11 = *(undefined4 *)&ppVar3->start;
        uVar14 = *(undefined4 *)((int)&ppVar3->start + 4);
      }
      load_uri(file_download->uri,pcVar2->uri,&file_download->download,PRI_DOWNLOAD,
               CACHE_MODE_NORMAL,CONCAT44(uVar14,uVar11));
      return;
    }
    ppVar3 = (file_download->download).progress;
    if (ppVar3 != (progress *)0x0) {
      uVar7 = *(uint *)((int)&ppVar3->seek + 4);
      if ((uVar7 | *(uint *)&ppVar3->seek) != 0) {
        *(uint *)&file_download->seek = *(uint *)&ppVar3->seek;
        *(uint *)((int)&file_download->seek + 4) = uVar7;
        *(undefined4 *)&ppVar3->seek = 0;
        *(undefined4 *)((int)&ppVar3->seek + 4) = 0;
        _Var15 = lseek64(file_download->handle,file_download->seek,0);
        if (_Var15 < 0) {
          piVar12 = __errno_location();
          download_error_dialog(file_download,*piVar12);
LAB_080d5474:
          detach_connection(download,file_download->seek);
          abort_download(file_download);
          return;
        }
      }
    }
    piVar12 = (int *)(pcVar2->frag).next;
    if (&pcVar2->frag == (list_head_elinks *)piVar12) {
      local_24 = *(uint *)&file_download->seek;
      local_20 = *(int *)((int)&file_download->seek + 4);
    }
    else {
      local_24 = *(uint *)&file_download->seek;
      local_20 = *(int *)((int)&file_download->seek + 4);
      do {
        uVar7 = local_24 - piVar12[2];
        iVar13 = (local_20 - piVar12[3]) - (uint)(local_24 < (uint)piVar12[2]);
        if (-1 < iVar13) {
          uVar4 = piVar12[4];
          if ((iVar13 <= piVar12[5]) && ((iVar13 < piVar12[5] || (uVar7 < uVar4)))) {
            iVar13 = file_download->handle;
            while (uVar8 = write(iVar13,(void *)((int)piVar12 + uVar7 + 0x20),uVar4 - uVar7),
                  uVar8 == 0xffffffff) {
              piVar9 = __errno_location();
              if (*piVar9 != 4) {
                download_error_dialog(file_download,*piVar9);
                goto LAB_080d5474;
              }
            }
            local_24 = uVar8 + *(uint *)&file_download->seek;
            local_20 = ((int)uVar8 >> 0x1f) + *(int *)((int)&file_download->seek + 4) +
                       (uint)CARRY4(uVar8,*(uint *)&file_download->seek);
            *(uint *)&file_download->seek = local_24;
            *(int *)((int)&file_download->seek + 4) = local_20;
          }
        }
        piVar12 = (int *)*piVar12;
      } while (&pcVar2->frag != (list_head_elinks *)piVar12);
    }
    detach_connection(download,CONCAT44(local_20,local_24));
  }
  download_data_store(download,file_download);
  return;
}



// WARNING: Unknown calling convention

int download_is_progressing(download *download)

{
  int iVar1;
  
  if ((download != (download *)0x0) && ((download->state).basic == S_TRANS)) {
    iVar1 = has_progress(download->progress);
    return (uint)(iVar1 != 0);
  }
  return 0;
}



// WARNING: Unknown calling convention

void create_download_file
               (terminal *term,uchar *fi,uchar **real_file,int safe,int resume,
               _func_void_terminal_ptr_int_void_ptr_int *callback,void *data)

{
  list_head_elinks *plVar1;
  terminal *data_00;
  uchar *path;
  terminal *file;
  option_value *poVar2;
  int iVar3;
  terminal *file_00;
  terminal **udata;
  lun_hop *lun_hop;
  uchar *puVar4;
  int overwrite;
  uchar *wd;
  
  data_00 = (terminal *)mem_calloc(1,0x10);
  if (data_00 == (terminal *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080d59ce. Too many branches
                    // WARNING: Treating indirect jump as call
    (*callback)(term,-1,data,0);
    return;
  }
  data_00->next = (terminal *)real_file;
  data_00->prev = (terminal *)safe;
  (data_00->windows).prev = data;
  (data_00->windows).next = callback;
  path = get_cwd();
  set_cwd(term->cwd);
  file = (terminal *)expand_tilde(fi);
  if (resume != 0) {
    create_download_file_do(term,(uchar *)file,data_00,resume);
    goto joined_r0x080d5909;
  }
  poVar2 = get_opt_();
  plVar1 = poVar2->tree;
  if (plVar1 == (list_head_elinks *)0x0) {
    create_download_file_do(term,(uchar *)file,data_00,0);
    goto joined_r0x080d5909;
  }
  iVar3 = file_is_dir((uchar *)file);
  if (iVar3 == 0) {
    file_00 = (terminal *)get_unique_name((uchar *)file);
    if ((file_00 == (terminal *)0x0) || (plVar1 == (list_head_elinks *)0x1)) {
      if (file != file_00) {
        mem_free(file);
      }
    }
    else if (file != file_00) {
      udata = (terminal **)mem_calloc(1,0x14);
      if (udata != (terminal **)0x0) {
        *udata = term;
        udata[1] = file;
        udata[4] = data_00;
        udata[3] = (terminal *)create_download_file_do;
        udata[2] = file_00;
        if (file == (terminal *)0x0) {
          file = (terminal *)&DAT_0812e3d8;
        }
        puVar4 = msg_text(term,(uchar *)
                               "This file already exists:\n%s\n\nThe alternative filename is:\n%s",
                          file,file_00);
        msg_box(term,(memory_list *)0x0,MSGBOX_FREE_TEXT,(uchar *)"File exists",ALIGN_CENTER,puVar4,
                udata,4,"Sa~ve under the alternative name",lun_alternate,1,
                "~Overwrite the original file",lun_overwrite,0,
                "~Resume download of the original file",lun_resume,0,"~Cancel",lun_cancel,2);
        goto joined_r0x080d5909;
      }
      mem_free(file_00);
      goto LAB_080d5980;
    }
    create_download_file_do(term,(uchar *)file_00,data_00,0);
  }
  else {
    puVar4 = msg_text(term,(uchar *)"\'%s\' is a directory.",file);
    info_box(term,MSGBOX_FREE_TEXT,(uchar *)"Download error",ALIGN_CENTER,puVar4);
LAB_080d5980:
    mem_free(file);
    create_download_file_do(term,(uchar *)0x0,data_00,0);
  }
joined_r0x080d5909:
  if (path == (uchar *)0x0) {
    return;
  }
  set_cwd(path);
  mem_free(path);
  return;
}



// WARNING: Unknown calling convention

void continue_download(void *data,uchar *file)

{
  uri *uri;
  undefined4 *p;
  codw_hop *codw_hop;
  uchar *puVar1;
  string *psVar2;
  uchar *extension;
  size_t cmdlen;
  string name;
  
  p = (undefined4 *)mem_calloc(1,0x10);
  if (p != (undefined4 *)0x0) {
    if (*(int *)((int)data + 0x48) == 0) {
LAB_080d5aa1:
      p[1] = data;
      p[3] = file;
      *p = 1;
      kill_downloads_to_file(file);
      create_download_file
                (*(terminal **)(*(int *)(*(int *)((int)data + 0x3c) + 8) + 0x14),file,
                 (uchar **)(p + 2),(uint)(*(int *)((int)data + 0x48) != 0),0,continue_download_do,p)
      ;
      return;
    }
    uri = *(uri **)((int)data + 0x40);
    puVar1 = (uchar *)tempnam((char *)0x0,"elinks");
    if (puVar1 != (uchar *)0x0) {
      psVar2 = init_string(&name);
      if (psVar2 == (string *)0x0) {
        free(puVar1);
      }
      else {
        add_to_string(&name,puVar1);
        free(puVar1);
        puVar1 = get_extension_from_uri(uri);
        if (puVar1 != (uchar *)0x0) {
          cmdlen = strlen((char *)puVar1);
          add_shell_safe_to_string(&name,puVar1,cmdlen);
          mem_free(puVar1);
        }
        file = name.source;
        if (name.source != (uchar *)0x0) goto LAB_080d5aa1;
      }
    }
    mem_free(p);
  }
  tp_cancel(data);
  return;
}



// WARNING: Unknown calling convention

void tp_open(type_query *type_query)

{
  uchar *src;
  uchar *file;
  uchar *path;
  uchar *handler;
  
  if ((type_query->external_handler == (uchar *)0x0) || (*type_query->external_handler == '\0')) {
    tp_display(type_query);
    return;
  }
  if ((type_query->uri->protocol == 4) && ((type_query->field_0x50 & 1) == 0)) {
    src = get_uri_string(type_query->uri,URI_PATH);
    if (src != (uchar *)0x0) {
      decode_uri(src);
      path = subst_file(type_query->external_handler,src);
      mem_free(src);
      if (path != (uchar *)0x0) {
        exec_on_terminal(type_query->ses->tab->term,path,"",(uint)(type_query->block != 0));
        mem_free(path);
      }
    }
    done_type_query(type_query);
    return;
  }
  continue_download(type_query,"");
  return;
}



// WARNING: Unknown calling convention

void common_download(session *ses,uchar *file,int resume)

{
  undefined4 *data;
  
  if (ses->download_uri != (uri *)0x0) {
    data = (undefined4 *)mem_calloc(1,0xc);
    if (data != (undefined4 *)0x0) {
      data[1] = ses;
      *data = 0;
      kill_downloads_to_file(file);
      create_download_file
                (ses->tab->term,file,(uchar **)(data + 2),0,resume,common_download_do,data);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void resume_download(void *ses,uchar *file)

{
  common_download((session *)ses,file,1);
  return;
}



// WARNING: Unknown calling convention

void start_download(void *ses,uchar *file)

{
  common_download((session *)ses,file,0);
  return;
}



// WARNING: Unknown calling convention

int setup_download_handler(session *ses,download *loading,cache_entry *cached,int frame)

{
  object *poVar1;
  dialog *text;
  type_query *ptVar2;
  uri *puVar3;
  type_query *ptVar4;
  terminal *term_00;
  uchar *puVar5;
  uchar *ctype;
  view_state *pvVar6;
  int ret;
  char *s2;
  int iVar7;
  uchar *puVar8;
  mime_handler *p;
  type_query *type_query_00;
  uchar *puVar9;
  connection_basic_state cVar10;
  dialog *dlg_00;
  string *psVar11;
  uchar *format;
  int new_charset_4;
  int new_charset_5;
  option_value *poVar12;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  int new_charset_9;
  int new_charset_10;
  memory_list *ml_00;
  memory_list *ml;
  dialog_data *dlg_data_00;
  dialog_data *dlg_data;
  size_t sVar13;
  int new_charset_3;
  int new_charset_1;
  int new_charset_2;
  int new_charset;
  view_state *vs;
  int i;
  int plaintext;
  type_query *type_query;
  int iVar14;
  dialog *dlg;
  terminal *term;
  uchar *local_44;
  char *local_3c;
  undefined1 *local_30;
  string filename;
  
  puVar5 = get_content_type(cached);
  if ((puVar5 == (uchar *)0x0) || (*puVar5 == '\0')) {
plaintext_follow:
    plaintext = 1;
LAB_080d5d07:
    pvVar6 = ses_forward(ses,frame);
    if (pvVar6 != (view_state *)0x0) {
      pvVar6->plain = plaintext;
    }
    return 0;
  }
  s2 = "text/html";
  iVar14 = 0;
  do {
    iVar7 = c_strcasecmp((char *)puVar5,s2);
    if (iVar7 == 0) {
      plaintext = (byte)known_types[iVar14].field_0x4 & 1;
      goto LAB_080d5d07;
    }
    iVar14 = iVar14 + 1;
    s2 = (char *)known_types[iVar14].type;
  } while ((uchar *)s2 != (uchar *)0x0);
  puVar8 = (uchar *)(ses->tab->term->environment & 2);
  p = get_mime_type_handler(puVar8,(int)puVar8);
  if (((p == (mime_handler *)0x0) && (sVar13 = strlen((char *)puVar5), 3 < sVar13)) &&
     (iVar14 = c_strncasecmp((char *)puVar5,"text",4), iVar14 == 0)) goto plaintext_follow;
  for (ptVar2 = (type_query *)(ses->type_queries).next; ptVar2 != (type_query *)&ses->type_queries;
      ptVar2 = ptVar2->next) {
    iVar14 = compare_uri(ptVar2->uri,ses->loading_uri,0);
    if (iVar14 != 0) goto LAB_080d5dcc;
  }
  type_query_00 = (type_query *)mem_calloc(1,0x54);
  if (type_query_00 == (type_query *)0x0) {
LAB_080d5dcc:
    iVar14 = 0;
  }
  else {
    puVar3 = ses->loading_uri;
    poVar1 = &puVar3->object;
    poVar1->refcount = poVar1->refcount + 1;
    type_query_00->uri = puVar3;
    puVar9 = (uchar *)0x0;
    type_query_00->ses = ses;
    puVar8 = (ses->task).target.frame;
    if (puVar8 != (uchar *)0x0) {
      puVar9 = stracpy(puVar8);
    }
    type_query_00->target_frame = puVar9;
    type_query_00->cached = cached;
    type_query_00->field_0x50 = type_query_00->field_0x50 & 0xfe | (byte)cached->field_0x5c >> 6 & 1
    ;
    (cached->object).refcount = (cached->object).refcount + 1;
    move_download(loading,&type_query_00->download,PRI_DOWNLOAD);
    if (assert_failed == 0) {
      cVar10 = S_OK;
    }
    else {
      cVar10 = S_INTERNAL;
    }
    assert_failed = 0;
    (loading->state).basic = cVar10;
    (loading->state).syserr = 0;
    ptVar4 = ptVar2->next;
    type_query_00->prev = ptVar2;
    type_query_00->next = ptVar4;
    ptVar2->next = type_query_00;
    type_query_00->next->prev = type_query_00;
    term_00 = type_query_00->ses->tab->term;
    if (type_query_00->external_handler != (uchar *)0x0) {
      mem_free(type_query_00->external_handler);
    }
    type_query_00->external_handler = (uchar *)0x0;
    if (p != (mime_handler *)0x0) {
      type_query_00->block = (byte)p->field_0x8 >> 1 & 1;
      if ((p->field_0x8 & 1) != 0) {
        local_44 = p->description;
        local_30 = &DAT_0812e3d8;
        if (*local_44 != '\0') {
          local_30 = &DAT_081327c1;
        }
        local_3c = "What to do?";
        goto LAB_080d5f3e;
      }
      puVar5 = stracpy(p->program);
      type_query_00->external_handler = puVar5;
      tp_open(type_query_00);
LAB_080d679b:
      iVar14 = 1;
      goto LAB_080d5dd9;
    }
    local_3c = "Unknown type";
    local_30 = &DAT_0812e3d8;
    local_44 = "";
LAB_080d5f3e:
    dlg_00 = (dialog *)mem_calloc(1,0x9a4);
    if (dlg_00 == (dialog *)0x0) {
LAB_080d6494:
      iVar14 = 1;
    }
    else {
      psVar11 = init_string(&filename);
      if (psVar11 != (string *)0x0) {
        add_mime_filename_to_string(&filename,type_query_00->uri);
        if ((term_00->field_0x38 & 2) == 0) {
          decode_uri_string_for_display(&filename);
        }
        else {
          decode_uri_string(&filename);
        }
      }
      text = dlg_00 + 5;
      if (filename.length == 0) {
        if ((term_00 != (terminal *)0x0) &&
           (iVar14 = get_terminal_codepage(term_00), iVar14 != current_charset)) {
          puVar8 = get_cp_mime_name(iVar14);
          bind_textdomain_codeset("elinks",puVar8);
          current_charset = iVar14;
        }
        puVar8 = gettext((uchar *)"What would you like to do with the file (type: %s%s%s)?");
        __snprintf_chk(text,0x400,1,0xffffffff,puVar8,puVar5,local_30,local_44);
      }
      else {
        if ((term_00 != (terminal *)0x0) &&
           (iVar14 = get_terminal_codepage(term_00), iVar14 != current_charset)) {
          puVar8 = get_cp_mime_name(iVar14);
          bind_textdomain_codeset("elinks",puVar8);
          current_charset = iVar14;
        }
        puVar8 = gettext((uchar *)"What would you like to do with the file \'%s\' (type: %s%s%s)?");
        __snprintf_chk(text,0x400,1,0xffffffff,puVar8,filename.source,puVar5,local_30,local_44);
      }
      done_string(&filename);
      if (*local_3c != '\0') {
        if ((term_00 != (terminal *)0x0) &&
           (iVar14 = get_terminal_codepage(term_00), iVar14 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar14);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar14;
        }
        local_3c = (char *)gettext((uchar *)local_3c);
      }
      *(byte *)&dlg_00->layout = *(byte *)&dlg_00->layout | 6;
      dlg_00->layouter = generic_dialog_layouter;
      dlg_00->title = (uchar *)local_3c;
      dlg_00->udata2 = type_query_00;
      add_dlg_text(dlg_00,(uchar *)text,ALIGN_LEFT,0);
      poVar12 = get_opt_();
      if (poVar12->tree == (list_head_elinks *)0x0) {
        puVar5 = (uchar *)mem_calloc(1,0x400);
        if (puVar5 != (uchar *)0x0) {
          if (p != (mime_handler *)0x0) {
            safe_strncpy(puVar5,p->program,0x400);
          }
          if ((term_00 != (terminal *)0x0) &&
             (iVar14 = get_terminal_codepage(term_00), iVar14 != current_charset)) {
            puVar8 = get_cp_mime_name(iVar14);
            bind_textdomain_codeset("elinks",puVar8);
            current_charset = iVar14;
          }
          puVar8 = gettext((uchar *)"Program (\'%\' will be replaced by the filename)");
          add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar8,0,0,(widget_handler_T *)0x0,0x400,puVar5,
                           (input_history *)0x0,INPFIELD_NONE);
          type_query_00->external_handler = puVar5;
          if ((term_00 != (terminal *)0x0) &&
             (iVar14 = get_terminal_codepage(term_00), iVar14 != current_charset)) {
            puVar5 = get_cp_mime_name(iVar14);
            bind_textdomain_codeset("elinks",puVar5);
            current_charset = iVar14;
          }
          puVar5 = gettext((uchar *)"Block the terminal");
          iVar14 = 8;
          add_dlg_radio_do(dlg_00,puVar5,0,0,&type_query_00->block);
          local_30 = (undefined1 *)0x3;
          goto LAB_080d61bb;
        }
      }
      else {
        if (p == (mime_handler *)0x0) {
          local_30 = (undefined1 *)0x1;
          iVar14 = 6;
        }
        else {
          if ((term_00 != (terminal *)0x0) &&
             (iVar14 = get_terminal_codepage(term_00), iVar14 != current_charset)) {
            puVar5 = get_cp_mime_name(iVar14);
            bind_textdomain_codeset("elinks",puVar5);
            current_charset = iVar14;
          }
          puVar5 = gettext((uchar *)"The file will be opened with the program \'%s\'.");
          __snprintf_chk(&dlg_00[0x11].layouter,0x400,1,0xffffffff,puVar5,p->program);
          add_dlg_text(dlg_00,(uchar *)&dlg_00[0x11].layouter,ALIGN_LEFT,0);
          iVar14 = 7;
          puVar5 = stracpy(p->program);
          type_query_00->external_handler = puVar5;
          local_30 = (undefined1 *)0x2;
          if (puVar5 == (uchar *)0x0) {
            mem_free(dlg_00);
            goto LAB_080d679b;
          }
        }
LAB_080d61bb:
        poVar12 = get_opt_();
        if ((poVar12->tree == (list_head_elinks *)0x0) || (p != (mime_handler *)0x0)) {
          if ((term_00 != (terminal *)0x0) &&
             (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
            puVar5 = get_cp_mime_name(iVar7);
            bind_textdomain_codeset("elinks",puVar5);
            current_charset = iVar7;
          }
          puVar5 = gettext((uchar *)"~Open");
          add_dlg_button_do(dlg_00,puVar5,1,ok_dialog,(void *)0x0,tp_open,type_query_00);
        }
        else {
          iVar14 = iVar14 + -1;
        }
        poVar12 = get_opt_();
        if (poVar12->tree == (list_head_elinks *)0x0) {
          if ((term_00 != (terminal *)0x0) &&
             (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
            puVar5 = get_cp_mime_name(iVar7);
            bind_textdomain_codeset("elinks",puVar5);
            current_charset = iVar7;
          }
          puVar5 = gettext((uchar *)"Sa~ve");
          add_dlg_button_do(dlg_00,puVar5,1,ok_dialog,(void *)0x0,tp_save,type_query_00);
        }
        else {
          iVar14 = iVar14 + -1;
        }
        if ((term_00 != (terminal *)0x0) &&
           (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar7);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar7;
        }
        puVar5 = gettext((uchar *)"~Display");
        add_dlg_button_do(dlg_00,puVar5,1,ok_dialog,(void *)0x0,tp_display,type_query_00);
        if ((type_query_00->cached == (cache_entry *)0x0) ||
           (type_query_00->cached->head == (uchar *)0x0)) {
          iVar14 = iVar14 + -1;
        }
        else {
          if ((term_00 != (terminal *)0x0) &&
             (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
            puVar5 = get_cp_mime_name(iVar7);
            bind_textdomain_codeset("elinks",puVar5);
            current_charset = iVar7;
          }
          puVar5 = gettext((uchar *)"Show ~header");
          add_dlg_button_do(dlg_00,puVar5,1,tp_show_header,type_query_00,(done_handler_T *)0x0,
                            (void *)0x0);
        }
        if ((term_00 != (terminal *)0x0) &&
           (iVar7 = get_terminal_codepage(term_00), iVar7 != current_charset)) {
          puVar5 = get_cp_mime_name(iVar7);
          bind_textdomain_codeset("elinks",puVar5);
          current_charset = iVar7;
        }
        puVar5 = gettext((uchar *)"~Cancel");
        add_dlg_button_do(dlg_00,puVar5,2,ok_dialog,(void *)0x0,tp_cancel,type_query_00);
        if ((assert_failed == 0) &&
           (assert_failed = (int)(dlg_00->number_of_widgets != iVar14), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
          errline = 0x4e0;
          elinks_internal((uchar *)"assertion widgets == (dlg)->number_of_widgets failed!");
        }
        ml_00 = getml(dlg_00,0);
        if (ml_00 != (memory_list *)0x0) {
          dlg_data_00 = do_dialog(term_00,dlg_00,ml_00);
          if (dlg_data_00 != (dialog_data *)0x0) {
            select_widget_by_id(dlg_data_00,(int)local_30);
            iVar14 = 1;
            goto LAB_080d5dce;
          }
          goto LAB_080d6494;
        }
      }
      mem_free(dlg_00);
      iVar14 = 1;
    }
  }
LAB_080d5dce:
  if (p == (mime_handler *)0x0) {
    return iVar14;
  }
LAB_080d5dd9:
  mem_free(p);
  return iVar14;
}



// WARNING: Unknown calling convention

void create_history(ses_history *history)

{
  (history->history).prev = history;
  (history->history).next = history;
  history->current = (location *)0x0;
  return;
}



// WARNING: Unknown calling convention

void add_to_history(ses_history *history,location *loc)

{
  location *plVar1;
  
  if (history->current != (location *)0x0) {
    loc->next = history->current->next;
    loc->prev = history->current;
    history->current->next = loc;
    loc->next->prev = loc;
    history->current = loc;
    return;
  }
  plVar1 = (location *)(history->history).next;
  loc->prev = (location *)history;
  loc->next = plVar1;
  (history->history).next = loc;
  loc->next->prev = loc;
  history->current = loc;
  return;
}



// WARNING: Unknown calling convention

void del_from_history(ses_history *history,location *loc)

{
  location *plVar1;
  
  plVar1 = history->current;
  if (plVar1 == loc) {
    plVar1 = plVar1->prev;
    history->current = plVar1;
  }
  if ((location *)history == plVar1) {
    plVar1 = (location *)0x0;
    if ((location *)history != loc->next) {
      plVar1 = loc->next;
    }
    history->current = plVar1;
  }
  loc->next->prev = loc->prev;
  loc->prev->next = loc->next;
  return;
}



// WARNING: Unknown calling convention

void go_history(session *ses,location *loc)

{
  task_type tVar1;
  
  tVar1 = (ses->task).type;
  ses->reloadlevel = CACHE_MODE_NORMAL;
  if (tVar1 == TASK_NONE) {
    if (((ses->history).current != (location *)0x0) && ((location *)&ses->history != loc)) {
      abort_loading(ses,0);
      set_session_referrer(ses,(uri *)0x0);
      ses_goto(ses,(loc->vs).uri,(uchar *)0x0,loc,CACHE_MODE_ALWAYS,TASK_HISTORY,0);
    }
    return;
  }
  abort_loading(ses,0);
  print_screen_status(ses);
  reload(ses,CACHE_MODE_NORMAL);
  return;
}



// WARNING: Unknown calling convention

void go_history_by_n(session *ses,int n)

{
  location *plVar1;
  location *loc;
  location *plVar2;
  location *loc_00;
  
  plVar2 = (ses->history).current;
  if (plVar2 == (location *)0x0) {
    return;
  }
  if (n < 1) {
    do {
      loc_00 = plVar2;
      if (n == 0) {
        go_history(ses,loc_00);
        return;
      }
      n = n + 1;
      plVar2 = loc_00->prev;
    } while (loc_00->prev != (location *)&ses->history);
  }
  else {
    do {
      n = n + -1;
      plVar1 = plVar2->next;
      loc_00 = plVar2;
      if (plVar1 == (location *)&ses->history) break;
      loc_00 = plVar1;
      plVar2 = plVar1;
    } while (n != 0);
  }
  go_history(ses,loc_00);
  return;
}



// WARNING: Unknown calling convention

void go_unback(session *ses)

{
  go_history_by_n(ses,1);
  return;
}



// WARNING: Unknown calling convention

void go_back(session *ses)

{
  go_history_by_n(ses,-1);
  return;
}



// WARNING: Unknown calling convention

void clean_unhistory(ses_history *history)

{
  location *plVar1;
  
  plVar1 = history->current;
  if (plVar1 != (location *)0x0) {
    while (plVar1 = plVar1->next, plVar1 != (location *)history) {
      plVar1->next->prev = plVar1->prev;
      plVar1->prev->next = plVar1->next;
      destroy_location(plVar1);
      plVar1 = history->current;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void destroy_history(ses_history *history)

{
  location *loc;
  
  loc = (location *)(history->history).next;
  while ((location *)history != loc) {
    loc->next->prev = loc->prev;
    loc->prev->next = loc->next;
    destroy_location(loc);
    loc = (location *)(history->history).next;
  }
  history->current = (location *)0x0;
  return;
}



// WARNING: Unknown calling convention

void ses_history_move(session *ses)

{
  ses_history *history;
  location *plVar1;
  int iVar2;
  option_value *poVar3;
  location *plVar4;
  
  free_files(ses);
  if (ses->search_word != (uchar *)0x0) {
    mem_free(ses->search_word);
  }
  plVar1 = (ses->history).current;
  ses->search_word = (uchar *)0x0;
  if (((plVar1 != (location *)0x0) &&
      (plVar1 = (ses->task).target.location, plVar1 != (location *)0x0)) &&
     (history = &ses->history, plVar1 != (location *)history)) {
    (ses->history).current = plVar1;
    iVar2 = compare_uri((plVar1->vs).uri,ses->loading_uri,0);
    if (iVar2 == 0) {
      plVar4 = (ses->history).current;
      if (plVar1 == plVar4) {
        plVar4 = plVar1->prev;
        (ses->history).current = plVar4;
      }
      if ((location *)history == plVar4) {
        plVar4 = (location *)0x0;
        if ((location *)history != plVar1->next) {
          plVar4 = plVar1->next;
        }
        (ses->history).current = plVar4;
      }
      plVar1->next->prev = plVar1->prev;
      plVar1->prev->next = plVar1->next;
      destroy_location(plVar1);
      ses_forward(ses,0);
      poVar3 = get_opt_();
      if (poVar3->tree != (list_head_elinks *)0x0) {
        clean_unhistory(history);
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void destroy_location(location *loc)

{
  list_head_elinks *plVar1;
  undefined *puVar2;
  int **ppiVar3;
  xlist_head *head;
  int **p;
  frame *frame;
  int **ppiVar4;
  xlist_head *next;
  
  ppiVar4 = (int **)(loc->frames).next;
  plVar1 = &loc->frames;
  p = ppiVar4;
  if ((list_head_elinks *)ppiVar4 != plVar1) {
    do {
      destroy_vs((view_state *)((int *)ppiVar4 + 4),1);
      mem_free((void *)((int *)ppiVar4)[2]);
      ppiVar4 = (int **)*ppiVar4;
    } while ((list_head_elinks *)ppiVar4 != plVar1);
    ppiVar4 = (int **)(loc->frames).next;
    p = ppiVar4;
  }
  for (; (list_head_elinks *)ppiVar4 != plVar1; ppiVar4 = (int **)*ppiVar4) {
  }
  for (puVar2 = (undefined *)(loc->frames).prev; (list_head_elinks *)puVar2 != plVar1;
      puVar2 = *(undefined **)(puVar2 + 4)) {
  }
  ppiVar4 = (int **)*p;
  while (ppiVar3 = ppiVar4, (list_head_elinks *)p != plVar1) {
    ppiVar3[1] = p[1];
    *p[1] = (int)*p;
    mem_free(p);
    ppiVar4 = (int **)*ppiVar3;
    p = ppiVar3;
  }
  destroy_vs(&loc->vs,1);
  mem_free(loc);
  return;
}



// WARNING: Unknown calling convention

void copy_location(location *dst,location *src)

{
  undefined *puVar1;
  void *pvVar2;
  void **p;
  uchar *puVar3;
  frame *frame;
  list_head_elinks *plVar4;
  
  plVar4 = &dst->frames;
  (dst->frames).prev = plVar4;
  (dst->frames).next = plVar4;
  puVar1 = (undefined *)(src->frames).prev;
  do {
    if ((list_head_elinks *)puVar1 == &src->frames) {
      copy_vs(&dst->vs,&src->vs);
      return;
    }
    p = (void **)mem_calloc(1,0x40);
    if (p != (void **)0x0) {
      puVar3 = stracpy(*(uchar **)(puVar1 + 8));
      p[2] = puVar3;
      if (puVar3 == (uchar *)0x0) {
        mem_free(p);
        return;
      }
      p[3] = (void *)0x0;
      copy_vs((view_state *)(p + 4),(view_state *)(puVar1 + 0x10));
      pvVar2 = plVar4->next;
      p[1] = plVar4;
      *p = pvVar2;
      plVar4->next = p;
      *(void ***)((int)*p + 4) = p;
    }
    puVar1 = *(undefined **)(puVar1 + 4);
  } while( true );
}



// WARNING: Unknown calling convention

download * get_current_download(session *ses)

{
  location *plVar1;
  connection_basic_state cVar2;
  download *pdVar3;
  download *download;
  file_to_load *ftl;
  int *piVar4;
  
  if (ses == (session *)0x0) {
    return (download *)0x0;
  }
  if ((ses->task).type == TASK_NONE) {
    plVar1 = (ses->history).current;
    if (plVar1 == (location *)0x0) {
      return (download *)0x0;
    }
    pdVar3 = &plVar1->download;
    cVar2 = (plVar1->download).state.basic;
  }
  else {
    pdVar3 = &ses->loading;
    cVar2 = (ses->loading).state.basic;
  }
  if (cVar2 == S_OK) {
    piVar4 = (int *)(ses->more_files).next;
    if ((list_head_elinks *)piVar4 != &ses->more_files) {
      while (((*(byte *)(piVar4 + 3) & 1) == 0 || (piVar4[0xf] < 0))) {
        piVar4 = (int *)*piVar4;
        if ((list_head_elinks *)piVar4 == &ses->more_files) {
          return pdVar3;
        }
      }
      return (download *)(piVar4 + 8);
    }
  }
  return pdVar3;
}



// WARNING: Unknown calling convention

link * get_current_link_in_view(document_view *doc_view)

{
  int iVar1;
  link *link;
  link *plVar2;
  
  if ((((doc_view == (document_view *)0x0) || (iVar1 = doc_view->vs->current_link, iVar1 < 0)) ||
      (doc_view->document->nlinks <= iVar1)) ||
     ((plVar2 = doc_view->document->links + iVar1, plVar2 != (link *)0x0 &&
      (LINK_MAP < plVar2->type)))) {
    plVar2 = (link *)0x0;
  }
  return plVar2;
}



// WARNING: Unknown calling convention

int eat_kbd_repeat_count(session *ses)

{
  int iVar1;
  int count;
  
  iVar1 = (ses->kbdprefix).repeat_count;
  (ses->kbdprefix).repeat_count = 0;
  print_screen_status(ses);
  return iVar1;
}



// WARNING: Unknown calling convention

link * get_current_session_link(session *ses)

{
  int iVar1;
  document_view *pdVar2;
  link *link;
  link *plVar3;
  
  pdVar2 = current_frame(ses);
  if ((((pdVar2 == (document_view *)0x0) || (iVar1 = pdVar2->vs->current_link, iVar1 < 0)) ||
      (pdVar2->document->nlinks <= iVar1)) ||
     ((plVar3 = pdVar2->document->links + iVar1, plVar3 != (link *)0x0 && (LINK_MAP < plVar3->type))
     )) {
    plVar3 = (link *)0x0;
  }
  return plVar3;
}



// WARNING: Unknown calling convention

uchar * get_current_link_name(session *ses,uchar *str,size_t str_size)

{
  link *plVar1;
  global_history_item *pgVar2;
  global_history_item *item;
  uchar *name;
  uchar *src;
  uchar *puVar3;
  link *link;
  uchar *where;
  
  plVar1 = get_current_session_link(ses);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x56b;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
  }
  if (plVar1 == (link *)0x0) {
    return (uchar *)0x0;
  }
  puVar3 = plVar1->where;
  if (puVar3 == (uchar *)0x0) {
    puVar3 = plVar1->where_img;
    pgVar2 = get_global_history_item(puVar3);
  }
  else {
    pgVar2 = get_global_history_item(puVar3);
  }
  if ((((pgVar2 == (global_history_item *)0x0) ||
       (src = pgVar2->title, pgVar2->title == (uchar *)0x0)) &&
      (src = puVar3, plVar1->type < LINK_BUTTON)) &&
     (src = (plVar1->data).name, (plVar1->data).name == (uchar *)0x0)) {
    src = puVar3;
  }
  puVar3 = safe_strncpy(str,src,str_size);
  return puVar3;
}



// WARNING: Unknown calling convention

uchar * get_current_link_url(session *ses,uchar *str,size_t str_size)

{
  link *plVar1;
  link *link;
  uchar *puVar2;
  
  plVar1 = get_current_session_link(ses);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x55a;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
  }
  if (plVar1 == (link *)0x0) {
    return (uchar *)0x0;
  }
  puVar2 = plVar1->where;
  if (puVar2 == (uchar *)0x0) {
    puVar2 = plVar1->where_img;
  }
  puVar2 = safe_strncpy(str,puVar2,str_size);
  return puVar2;
}



// WARNING: Unknown calling convention

uchar * get_current_title(session *ses,uchar *str,size_t str_size)

{
  document_view *pdVar1;
  document_view *doc_view;
  uchar *puVar2;
  
  pdVar1 = current_frame(ses);
  if ((assert_failed == 0) &&
     (assert_failed = (int)(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x546;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
  }
  if ((pdVar1 != (document_view *)0x0) && (puVar2 = pdVar1->document->title, puVar2 != (uchar *)0x0)
     ) {
    puVar2 = safe_strncpy(str,puVar2,str_size);
    return puVar2;
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_current_url(session *ses,uchar *str,size_t str_size)

{
  location *plVar1;
  uri *puVar2;
  int length;
  uchar *puVar3;
  uri *uri;
  size_t sVar4;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(str_size == 0 || str == (uchar *)0x0),
     str_size == 0 || str == (uchar *)0x0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x52d;
    elinks_internal((uchar *)"assertion str && str_size > 0 failed!");
    plVar1 = (ses->history).current;
  }
  else {
    plVar1 = (ses->history).current;
  }
  if (plVar1 == (location *)0x0) {
    puVar2 = ses->loading_uri;
  }
  else {
    puVar2 = (plVar1->vs).uri;
  }
  if (puVar2 != (uri *)0x0) {
    if (puVar2->post == (uchar *)0x0) {
      puVar3 = puVar2->string;
      length = strlen((char *)puVar3);
    }
    else {
      puVar3 = puVar2->string;
      length = (int)puVar2->post + (-1 - (int)puVar3);
    }
    sVar4 = str_size - 1;
    if (length <= (int)(str_size - 1)) {
      sVar4 = length;
    }
    puVar3 = safe_strncpy(str,puVar3,sVar4 + 1);
    return puVar3;
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void set_session_referrer(session *ses,uri *referrer)

{
  if (ses->referrer != (uri *)0x0) {
    done_uri(ses->referrer);
  }
  if (referrer != (uri *)0x0) {
    (referrer->object).refcount = (referrer->object).refcount + 1;
  }
  ses->referrer = referrer;
  return;
}



// WARNING: Unknown calling convention

frame * ses_find_frame(session *ses,uchar *name)

{
  location *plVar1;
  frame *pfVar2;
  int iVar3;
  frame *frame;
  location *loc;
  
  plVar1 = (ses->history).current;
  if (assert_failed != 0) {
    assert_failed = 0;
    return (frame *)0x0;
  }
  assert_failed = (int)(plVar1 == (location *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 0x4ed;
    elinks_internal((uchar *)
                    "assertion have_location(ses) failed: ses_request_frame: no location yet");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (frame *)0x0;
    }
  }
  pfVar2 = (frame *)(plVar1->frames).prev;
  while( true ) {
    if (pfVar2 == (frame *)&plVar1->frames) {
      return (frame *)0x0;
    }
    iVar3 = c_strcasecmp((char *)pfVar2->name,(char *)name);
    if (iVar3 == 0) break;
    pfVar2 = pfVar2->prev;
  }
  return pfVar2;
}



// WARNING: Unknown calling convention

void load_additional_file(file_to_load *ftl,cache_mode cache_mode)

{
  document_view *pdVar1;
  document_view *doc_view;
  uri *referrer;
  
  pdVar1 = current_frame(ftl->ses);
  if ((pdVar1 == (document_view *)0x0) || (pdVar1->document == (document *)0x0)) {
    referrer = (uri *)0x0;
  }
  else {
    referrer = pdVar1->document->uri;
  }
  load_uri(ftl->uri,referrer,&ftl->download,ftl->pri,cache_mode,-1);
  return;
}



// WARNING: Unknown calling convention

void process_file_requests(session *ses)

{
  list_head_elinks *plVar1;
  undefined *puVar2;
  byte bVar3;
  bool bVar4;
  int more;
  file_to_load *ftl;
  file_to_load *ftl_00;
  
  bVar3 = (ses->status).field_0x34;
  if ((bVar3 & 2) == 0) {
    (ses->status).field_0x34 = bVar3 | 2;
    plVar1 = &ses->more_files;
    do {
      ftl_00 = (file_to_load *)(ses->more_files).next;
      if (ftl_00 == (file_to_load *)plVar1) break;
      bVar4 = false;
      do {
        while ((ftl_00->field_0xc & 1) == 0) {
          ftl_00->field_0xc = ftl_00->field_0xc | 1;
          load_additional_file(ftl_00,CACHE_MODE_NORMAL);
          ftl_00 = ftl_00->next;
          bVar4 = true;
          if (ftl_00 == (file_to_load *)plVar1) goto LAB_080d7353;
        }
        ftl_00 = ftl_00->next;
      } while (ftl_00 != (file_to_load *)plVar1);
LAB_080d7353:
    } while (bVar4);
    puVar2 = &(ses->status).field_0x34;
    *puVar2 = *puVar2 & 0xfd;
  }
  return;
}



// WARNING: Unknown calling convention

void abort_loading(session *ses,int interrupt)

{
  location *plVar1;
  bool bVar2;
  int more;
  file_to_load *ftl;
  int *piVar3;
  
  plVar1 = (ses->history).current;
  if (plVar1 != (location *)0x0) {
    cancel_download(&plVar1->download,interrupt);
    do {
      piVar3 = (int *)(ses->more_files).next;
      if ((list_head_elinks *)piVar3 == &ses->more_files) break;
      bVar2 = false;
      do {
        if (((*(byte *)(piVar3 + 3) & 1) != 0) && (-1 < piVar3[0xf])) {
          cancel_download((download *)(piVar3 + 8),interrupt);
          bVar2 = true;
        }
        piVar3 = (int *)*piVar3;
      } while ((list_head_elinks *)piVar3 != &ses->more_files);
    } while (bVar2);
  }
  abort_preloading(ses,interrupt);
  return;
}



// WARNING: Unknown calling convention

void reload(session *ses,cache_mode cache_mode)

{
  location *plVar1;
  file_to_load *ftl;
  file_to_load *ftl_00;
  
  abort_loading(ses,0);
  if (cache_mode == CACHE_MODE_INCREMENT) {
    cache_mode = CACHE_MODE_NEVER;
    if (ses->reloadlevel < CACHE_MODE_NEVER) {
      cache_mode = ses->reloadlevel + CACHE_MODE_NORMAL;
      ses->reloadlevel = cache_mode;
    }
  }
  else {
    ses->reloadlevel = cache_mode;
  }
  plVar1 = (ses->history).current;
  if (plVar1 != (location *)0x0) {
    (plVar1->download).data = ses;
    (plVar1->download).callback = doc_loading_callback;
    load_uri((plVar1->vs).uri,ses->referrer,&plVar1->download,PRI_DOWNLOAD,cache_mode,-1);
    for (ftl_00 = (file_to_load *)(ses->more_files).next; (file_to_load *)&ses->more_files != ftl_00
        ; ftl_00 = ftl_00->next) {
      while (((ftl_00->field_0xc & 1) != 0 && (S_ERRNO < (ftl_00->download).state.basic))) {
        ftl_00 = ftl_00->next;
        if ((file_to_load *)&ses->more_files == ftl_00) {
          return;
        }
      }
      (ftl_00->download).data = ftl_00;
      (ftl_00->download).callback = file_loading_callback;
      load_additional_file(ftl_00,cache_mode);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void check_questions_queue(session *ses)

{
  void *p;
  
  if ((list_head_elinks *)questions_queue.next != &questions_queue) {
    do {
      p = questions_queue.next;
      (**(code **)((int)questions_queue.next + 8))
                (ses,*(undefined4 *)((int)questions_queue.next + 0xc));
                    // WARNING: Load size is inaccurate
      *(undefined4 *)(*p + 4) = *(undefined4 *)((int)p + 4);
                    // WARNING: Load size is inaccurate
      **(undefined4 **)((int)p + 4) = *p;
      mem_free(p);
    } while ((list_head_elinks *)questions_queue.next != &questions_queue);
  }
  return;
}



// WARNING: Unknown calling convention

void free_files(session *ses)

{
  list_head_elinks *plVar1;
  int *piVar2;
  undefined *puVar3;
  bool bVar4;
  int **ppiVar5;
  int more;
  void *p;
  xlist_head *head;
  int **p_00;
  file_to_load *ftl_1;
  file_to_load *ftl;
  int **ppiVar6;
  xlist_head *next;
  
  plVar1 = &ses->more_files;
  do {
    ppiVar6 = (int **)(ses->more_files).next;
    p_00 = ppiVar6;
    if ((list_head_elinks *)ppiVar6 == plVar1) goto joined_r0x080d75be;
    bVar4 = false;
    do {
      if (((*(byte *)((int *)ppiVar6 + 3) & 1) != 0) && (-1 < ((int *)ppiVar6)[0xf])) {
        cancel_download((download *)((int *)ppiVar6 + 8),0);
        bVar4 = true;
      }
      ppiVar6 = (int **)*ppiVar6;
    } while ((list_head_elinks *)ppiVar6 != plVar1);
  } while (bVar4);
  ppiVar6 = (int **)(ses->more_files).next;
  p_00 = ppiVar6;
  if ((list_head_elinks *)ppiVar6 != plVar1) {
    do {
      if (ppiVar6[5] != (int *)0x0) {
        piVar2 = ppiVar6[5] + 2;
        *piVar2 = *piVar2 + -1;
      }
      if ((uri *)ppiVar6[7] != (uri *)0x0) {
        done_uri((uri *)ppiVar6[7]);
      }
      if (ppiVar6[6] != (int *)0x0) {
        mem_free(ppiVar6[6]);
      }
      ppiVar6 = (int **)*ppiVar6;
    } while ((list_head_elinks *)ppiVar6 != plVar1);
    ppiVar6 = (int **)(ses->more_files).next;
    p_00 = ppiVar6;
  }
joined_r0x080d75be:
  for (; (list_head_elinks *)ppiVar6 != plVar1; ppiVar6 = (int **)*ppiVar6) {
  }
  for (puVar3 = (undefined *)(ses->more_files).prev; (list_head_elinks *)puVar3 != plVar1;
      puVar3 = *(undefined **)(puVar3 + 4)) {
  }
  ppiVar6 = (int **)*p_00;
  while (ppiVar5 = ppiVar6, (list_head_elinks *)p_00 != plVar1) {
    ppiVar5[1] = p_00[1];
    *p_00[1] = (int)*p_00;
    mem_free(p_00);
    ppiVar6 = (int **)*ppiVar5;
    p_00 = ppiVar5;
  }
  return;
}



// WARNING: Unknown calling convention

void done_session_info(session_info *info)

{
  info->next->prev = info->prev;
  info->prev->next = info->next;
  kill_timer(&info->timer);
  if (info->uri != (uri *)0x0) {
    done_uri(info->uri);
  }
  if (info->referrer != (uri *)0x0) {
    done_uri(info->referrer);
  }
  mem_free(info);
  return;
}



// WARNING: Unknown calling convention

void session_info_timeout(int id)

{
  session_info *info;
  session_info *info_00;
  session *ses;
  session *psVar1;
  
  info_00 = (session_info *)session_info.next;
  if ((list_head_elinks *)session_info.next != &session_info) {
    do {
      if (id == info_00->id) {
        if ((list_head_elinks *)sessions.next == &sessions) goto LAB_080d76ae;
        psVar1 = (session *)sessions.next;
        if ((session *)sessions.next == info_00->ses) goto LAB_080d76b5;
        goto LAB_080d76a4;
      }
      info_00 = info_00->next;
    } while (info_00 != (session_info *)&session_info);
  }
  return;
LAB_080d76ae:
  info_00->ses = (session *)0x0;
  goto LAB_080d76b5;
  while (psVar1 != info_00->ses) {
LAB_080d76a4:
    psVar1 = psVar1->next;
    if (psVar1 == (session *)&sessions) goto LAB_080d76ae;
  }
LAB_080d76b5:
  info_00->timer = (timer_id_T)0x0;
  done_session_info(info_00);
  return;
}



// WARNING: Unknown calling convention

void done_saved_session_info(void)

{
  if ((list_head_elinks *)session_info.next != &session_info) {
    do {
      done_session_info((session_info *)session_info.next);
    } while ((list_head_elinks *)session_info.next != &session_info);
  }
  return;
}



// WARNING: Unknown calling convention

void dialog_goto_url_open(void *data)

{
  dialog_goto_url((session *)data,(uchar *)0x0);
  return;
}



// WARNING: Unknown calling convention

void init_remote_session(session *ses,remote_session_flags *remote_ptr,uri *uri)

{
  remote_session_flags rVar1;
  uchar *text_00;
  uchar *text;
  remote_session_flags rVar2;
  int iVar3;
  int uri_cp;
  remote_session_flags remote;
  
  rVar1 = *remote_ptr;
  if ((rVar1 & SES_REMOTE_CURRENT_TAB) != 0) {
    goto_uri(ses,uri);
    rVar2 = SES_REMOTE_NEW_TAB;
    if ((rVar1 & ~SES_REMOTE_CURRENT_TAB) != 0) {
      rVar2 = rVar1 & ~SES_REMOTE_CURRENT_TAB;
    }
    *remote_ptr = rVar2;
    return;
  }
  if ((rVar1 & SES_REMOTE_NEW_TAB) == 0) {
    if ((rVar1 & SES_REMOTE_NEW_WINDOW) != 0) {
      iVar3 = can_open_in_new(ses->tab->term);
      if (iVar3 == 0) {
        return;
      }
      open_uri_in_new_window
                (ses,uri,(uri *)0x0,ses->tab->term->environment,CACHE_MODE_NORMAL,TASK_NONE);
      return;
    }
    if ((rVar1 & SES_REMOTE_ADD_BOOKMARK) != 0) {
      if (uri == (uri *)0x0) {
        return;
      }
      iVar3 = get_cp_index((uchar *)"System");
      add_bookmark_cp((bookmark *)0x0,1,iVar3,uri->string,uri->string);
      return;
    }
    if ((rVar1 & SES_REMOTE_INFO_BOX) != 0) {
      if (uri == (uri *)0x0) {
        return;
      }
      text_00 = memacpy(uri->data,(uint)*(ushort *)&uri->field_0x31);
      if (text_00 == (uchar *)0x0) {
        return;
      }
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,"Error",ALIGN_CENTER,text_00);
      return;
    }
  }
  else {
    open_uri_in_new_tab(ses,uri,0,1);
  }
  if ((rVar1 & SES_REMOTE_PROMPT_URL) != 0) {
    dialog_goto_url_open(ses);
  }
  return;
}



// WARNING: Unknown calling convention

string * encode_session_info(string *info,list_head_elinks *url_list)

{
  int iVar1;
  list_head_elinks *plVar2;
  void *__src;
  uint uVar3;
  string *psVar4;
  uint uVar5;
  uchar *puVar6;
  size_t newsize;
  uint size;
  string_list_item *url;
  size_t __n;
  
  psVar4 = init_string(info);
  if (psVar4 == (string *)0x0) {
    return (string *)0x0;
  }
  plVar2 = (list_head_elinks *)url_list->next;
  do {
    while( true ) {
      if (plVar2 == url_list) {
        return info;
      }
      __src = plVar2[1].next;
      if (assert_failed == 0) break;
LAB_080d798e:
      assert_failed = 0;
      plVar2 = (list_head_elinks *)plVar2->next;
    }
    __n = (int)plVar2[1].prev + 1;
    if (((info == (string *)0x0) || (__src == (void *)0x0)) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080d798e;
    }
    else {
      assert_failed = 0;
    }
    if (__n != 0) {
      iVar1 = __n + info->length;
      uVar5 = info->length + 0xff;
      uVar3 = uVar5 >> 8;
      uVar5 = uVar5 & 0xffffff00;
      size = iVar1 + 0x100U & 0xffffff00;
      if (uVar5 <= size && size + uVar3 * -0x100 != 0) {
        puVar6 = (uchar *)mem_realloc(info->source,size);
        if (puVar6 == (uchar *)0x0) goto LAB_080d7974;
        info->source = puVar6;
        memset(puVar6 + uVar5,0,size + uVar3 * -0x100);
      }
      if (info->source != (uchar *)0x0) {
        memcpy(info->source + info->length,__src,__n);
        info->source[iVar1] = '\0';
        info->length = iVar1;
      }
    }
LAB_080d7974:
    plVar2 = (list_head_elinks *)plVar2->next;
  } while( true );
}



// WARNING: Unknown calling convention

session * init_session(session *base_session,terminal *term,uri *uri,int in_background)

{
  object *poVar1;
  location *plVar2;
  uri *uri_00;
  view_state *vs;
  terminal *term_00;
  session *ses_00;
  session *ses;
  window *pwVar3;
  led *plVar4;
  int iVar5;
  option_value *poVar6;
  uchar *foldername;
  option_elinks *option_elinks;
  option_elinks *opt;
  uchar *folder;
  
  ses_00 = (session *)mem_calloc(1,0xe0);
  if (ses_00 == (session *)0x0) {
    return (session *)0x0;
  }
  pwVar3 = init_tab(term,ses_00,tabwin_func);
  ses_00->tab = pwVar3;
  if (pwVar3 == (window *)0x0) {
    mem_free(ses_00);
    return (session *)0x0;
  }
  create_history(&ses_00->history);
  (ses_00->scrn_frames).prev = &ses_00->scrn_frames;
  (ses_00->scrn_frames).next = &ses_00->scrn_frames;
  (ses_00->more_files).prev = &ses_00->more_files;
  (ses_00->more_files).next = &ses_00->more_files;
  (ses_00->type_queries).prev = &ses_00->type_queries;
  (ses_00->type_queries).next = &ses_00->type_queries;
  (ses_00->task).type = TASK_NONE;
  ses_00->display_timer = (timer_id_T)0x0;
  init_led_panel(&(ses_00->status).leds);
  plVar4 = register_led(ses_00,0);
  (ses_00->status).ssl_led = plVar4;
  plVar4 = register_led(ses_00,1);
  (ses_00->status).insert_mode_led = plVar4;
  plVar4 = register_led(ses_00,2);
  (ses_00->status).ecmascript_led = plVar4;
  plVar4 = register_led(ses_00,3);
  *(byte *)&ses_00->status = *(byte *)&ses_00->status | 0x78;
  (ses_00->status).popup_led = plVar4;
  ses_00->prev = (session *)&sessions;
  ses_00->next = (session *)sessions.next;
  sessions.next = ses_00;
  ses_00->next->prev = ses_00;
  update_status();
  if (sessions.next == sessions.prev) {
    term_00 = ses_00->tab->term;
    poVar6 = get_opt_();
    if (*poVar6->string == '\0') {
      info_box(term_00,0,(uchar *)"Warning",ALIGN_CENTER,
               (uchar *)
               "You have an empty string in protocol.http.user_agent - this was a default value in the past, substituted by default ELinks User-Agent string. However, currently this means that NO User-Agent HEADER WILL BE SENT AT ALL - if this is really what you want, set its value to \" \", otherwise please delete the line with this setting from your configuration file (if you have no idea what I\'m talking about, just do this), so that the correct default setting will be used. Apologies for any inconvience caused."
              );
    }
    poVar6 = get_opt_();
    if (poVar6->tree == (list_head_elinks *)0x0) {
      option_elinks = get_opt_rec(config_options,(uchar *)"config.saving_style_w");
      (option_elinks->value).number = 1;
      option_changed(ses_00,option_elinks);
      poVar6 = get_opt_();
      if (poVar6->tree != (list_head_elinks *)0x3) {
        info_box(term_00,0,(uchar *)"Warning",ALIGN_CENTER,
                 (uchar *)
                 "You have option config.saving_style set to a de facto obsolete value. The configuration saving algorithms of ELinks were changed from the last time you upgraded ELinks. Now, only those options which you actually changed are saved to the configuration file, instead of all the options. This simplifies our situation greatly when we see that some option has an inappropriate default value or we need to change the semantics of some option in a subtle way. Thus, we recommend you change the value of config.saving_style option to 3 in order to get the \"right\" behaviour. Apologies for any inconvience caused."
                );
      }
    }
    if (first_use == 0) {
      if ((uri == (uri *)0x0) && (poVar6 = get_opt_(), poVar6->tree != (list_head_elinks *)0x0)) {
        foldername = get_auto_save_bookmark_foldername_utf8();
        if (foldername != (uchar *)0x0) {
          open_bookmark_folder(ses_00,foldername);
          mem_free(foldername);
        }
        goto LAB_080d7c21;
      }
    }
    else {
      if (uri == (uri *)0x0) {
        first_use = 0;
        msg_box(term_00,(memory_list *)0x0,0,(uchar *)"Welcome",ALIGN_CENTER,
                (uchar *)
                "Welcome to ELinks!\n\nPress ESC for menu. Documentation is available in Help menu."
                ,ses_00,1,&DAT_081275e4,dialog_goto_url_open,3);
        goto LAB_080d7c21;
      }
      first_use = 0;
      msg_box(term_00,(memory_list *)0x0,0,(uchar *)"Welcome",ALIGN_CENTER,
              (uchar *)
              "Welcome to ELinks!\n\nPress ESC for menu. Documentation is available in Help menu.",
              ses_00,1,&DAT_081275e4,0,3);
    }
  }
  if ((base_session != (session *)0x0) &&
     (plVar2 = (base_session->history).current, plVar2 != (location *)0x0)) {
    uri_00 = (plVar2->vs).uri;
    poVar1 = &uri_00->object;
    poVar1->refcount = poVar1->refcount + 1;
    ses_load(ses_00,uri_00,(uchar *)0x0,(location *)0x0,CACHE_MODE_ALWAYS,TASK_FORWARD);
    if ((ses_00->doc_view != (document_view *)0x0) &&
       (((vs = ses_00->doc_view->vs, vs != (view_state *)0x0 &&
         (base_session->doc_view != (document_view *)0x0)) &&
        (base_session->doc_view->vs != (view_state *)0x0)))) {
      destroy_vs(vs,1);
      copy_vs(vs,base_session->doc_view->vs);
      ses_00->doc_view->vs = vs;
    }
  }
  if (uri == (uri *)0x0) {
    iVar5 = goto_url_home(ses_00);
    if ((iVar5 == 0) && (poVar6 = get_opt_(), poVar6->tree != (list_head_elinks *)0x0)) {
      dialog_goto_url_open(ses_00);
    }
  }
  else {
    goto_uri(ses_00,uri);
  }
LAB_080d7c21:
  if (in_background == 0) {
    iVar5 = get_tab_number(ses_00->tab);
    switch_to_tab(term,iVar5,-1);
  }
  if (term->main_menu == (menu *)0x0) {
    activate_bfu_technology(ses_00,-1);
  }
  return ses_00;
}



// WARNING: Unknown calling convention

file_to_load * request_additional_file(session *ses,uchar *name,uri *uri,int pri)

{
  file_to_load *pfVar1;
  file_to_load *pfVar2;
  protocol_external_handler_T *ppVar3;
  int iVar4;
  uchar *puVar5;
  file_to_load *pfVar6;
  file_to_load *ftl;
  
  if ((uri->protocol == 0x12) ||
     (ppVar3 = get_protocol_external_handler(ses->tab->term,uri),
     ppVar3 != (protocol_external_handler_T *)0x0)) {
LAB_080d7f17:
    pfVar6 = (file_to_load *)0x0;
  }
  else {
    for (pfVar1 = (file_to_load *)(ses->more_files).next; pfVar1 != (file_to_load *)&ses->more_files
        ; pfVar1 = pfVar1->next) {
      iVar4 = compare_uri(pfVar1->uri,uri,URI_BASE);
      if (iVar4 != 0) {
        if (pfVar1->pri != pri && pri <= pfVar1->pri) {
          pfVar1->pri = pri;
          move_download(&pfVar1->download,&pfVar1->download,pri);
          return (file_to_load *)0x0;
        }
        goto LAB_080d7f17;
      }
    }
    pfVar6 = (file_to_load *)mem_calloc(1,0x50);
    if (pfVar6 != (file_to_load *)0x0) {
      (uri->object).refcount = (uri->object).refcount + 1;
      pfVar6->uri = uri;
      puVar5 = stracpy(name);
      (pfVar6->download).callback = file_loading_callback;
      (pfVar6->download).data = pfVar6;
      pfVar6->target_frame = puVar5;
      pfVar6->ses = ses;
      pfVar6->pri = pri;
      pfVar2 = pfVar1->next;
      pfVar6->prev = pfVar1;
      pfVar6->next = pfVar2;
      pfVar1->next = pfVar6;
      pfVar6->next->prev = pfVar6;
    }
  }
  return pfVar6;
}



// WARNING: Unknown calling convention

int session_is_loading(session *ses)

{
  download *pdVar1;
  download *download;
  int iVar2;
  cache_entry *pcVar3;
  
  pdVar1 = get_current_download(ses);
  if (pdVar1 != (download *)0x0) {
    if (S_ERRNO < (pdVar1->state).basic) {
      return 1;
    }
    if ((pdVar1->cached != (cache_entry *)0x0) &&
       (iVar2 = cache_entry_is_valid(pdVar1->cached), iVar2 != 0)) {
      pcVar3 = pdVar1->cached;
      if ((assert_failed == 0) &&
         (assert_failed = (int)(pcVar3 == (cache_entry *)0x0), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
        errline = 0x22b;
        elinks_internal((uchar *)"assertion cached failed!");
      }
      pcVar3 = follow_cached_redirects(pcVar3);
      if ((pcVar3 != (cache_entry *)0x0) && (pcVar3->redirect == (uri *)0x0)) {
        return (uint)((pcVar3->field_0x5c & 8) != 0);
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void add_questions_entry(_func_void_session_ptr_void_ptr *callback,void *data)

{
  void **ppvVar1;
  
  ppvVar1 = (void **)mem_alloc(0x10);
  if (ppvVar1 != (void **)0x0) {
    ppvVar1[2] = callback;
    ppvVar1[3] = data;
    ppvVar1[1] = &questions_queue;
    *ppvVar1 = questions_queue.next;
    questions_queue.next = ppvVar1;
    *(void ***)((int)*ppvVar1 + 4) = ppvVar1;
  }
  return;
}



// WARNING: Unknown calling convention

int add_session_info(session *ses,uri *uri,uri *referrer,cache_mode cache_mode,task_type task)

{
  int data;
  void **ppvVar1;
  void *pvVar2;
  session_info *info;
  
  ppvVar1 = (void **)mem_calloc(1,0x24);
  data = session_info_id;
  pvVar2 = (void *)0xffffffff;
  if (ppvVar1 != (void **)0x0) {
    ppvVar1[2] = (void *)session_info_id;
    session_info_id = session_info_id + 1;
    install_timer((timer_id_T *)(ppvVar1 + 3),10000,session_info_timeout,(void *)data);
    ppvVar1[4] = ses;
    ppvVar1[7] = (void *)task;
    ppvVar1[8] = (void *)cache_mode;
    if (uri != (uri *)0x0) {
      (uri->object).refcount = (uri->object).refcount + 1;
      ppvVar1[5] = uri;
    }
    if (referrer != (uri *)0x0) {
      (referrer->object).refcount = (referrer->object).refcount + 1;
      ppvVar1[6] = referrer;
    }
    ppvVar1[1] = &session_info;
    *ppvVar1 = session_info.next;
    session_info.next = ppvVar1;
    *(void ***)((int)*ppvVar1 + 4) = ppvVar1;
    pvVar2 = ppvVar1[2];
  }
  return (int)pvVar2;
}



// WARNING: Unknown calling convention

void request_frameset(session *ses,frameset_desc *frameset_desc,int depth)

{
  uchar *name;
  uri *uri;
  location *plVar1;
  int **ppiVar2;
  document_view *doc_view;
  location *loc;
  int iVar3;
  int **p;
  int *piVar4;
  frameset_desc *frameset_desc_00;
  frameset_desc *pfVar5;
  frame *frame;
  int iVar6;
  int i;
  
  if ((5 < depth) || (frameset_desc->n < 1)) {
    return;
  }
  iVar6 = 0;
  pfVar5 = frameset_desc;
LAB_080d8224:
  frameset_desc_00 = pfVar5->frame_desc[0].subframe;
  if (frameset_desc_00 == (frameset_desc *)0x0) {
    name = pfVar5->frame_desc[0].name;
    if ((name != (uchar *)0x0) && (uri = pfVar5->frame_desc[0].uri, uri != (uri *)0x0)) {
      plVar1 = (ses->history).current;
      if (assert_failed == 0) {
        assert_failed = (int)(plVar1 == (location *)0x0);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
          errline = 0x153;
          elinks_internal((uchar *)"assertion have_location(ses) failed: request_frame: no location"
                         );
          if (assert_failed != 0) goto LAB_080d83d0;
        }
        for (ppiVar2 = (int **)(plVar1->frames).next; (list_head_elinks *)ppiVar2 != &plVar1->frames
            ; ppiVar2 = (int **)*ppiVar2) {
          iVar3 = c_strcasecmp((char *)ppiVar2[2],(char *)name);
          if (iVar3 == 0) {
            piVar4 = (int *)(ses->scrn_frames).next;
            if ((list_head_elinks *)piVar4 == &ses->scrn_frames) goto LAB_080d8378;
            goto LAB_080d835e;
          }
        }
        p = (int **)mem_calloc(1,0x40);
        if (p != (int **)0x0) {
          piVar4 = (int *)stracpy(name);
          p[2] = piVar4;
          if (piVar4 == (int *)0x0) {
            mem_free(p);
          }
          else {
            init_vs((view_state *)(p + 4),uri,-1);
            piVar4 = *ppiVar2;
            p[1] = (int *)ppiVar2;
            *p = piVar4;
            *ppiVar2 = (int *)p;
            (*p)[1] = (int)p;
            request_additional_file(ses,name,(uri *)p[5],1);
          }
        }
      }
      else {
LAB_080d83d0:
        assert_failed = 0;
      }
    }
  }
  else {
LAB_080d8208:
    request_frameset(ses,frameset_desc_00,depth + 1);
  }
  goto LAB_080d8213;
  while (piVar4 = (int *)*piVar4, (list_head_elinks *)piVar4 != &ses->scrn_frames) {
LAB_080d835e:
    if (((int **)piVar4[6] == ppiVar2 + 4) &&
       (frameset_desc_00 = *(frameset_desc **)(piVar4[5] + 200),
       frameset_desc_00 != (frameset_desc *)0x0)) goto LAB_080d8208;
  }
LAB_080d8378:
  request_additional_file(ses,name,(uri *)ppiVar2[5],1);
LAB_080d8213:
  iVar6 = iVar6 + 1;
  pfVar5 = (frameset_desc *)pfVar5->frame_desc;
  if (frameset_desc->n == iVar6 || frameset_desc->n < iVar6) {
    return;
  }
  goto LAB_080d8224;
}



// WARNING: Unknown calling convention

void print_error_dialog(session *ses,connection_state state,uri *uri,connection_priority priority)

{
  terminal *term;
  string *psVar1;
  uchar *puVar2;
  uchar *uristring;
  int cp_index;
  int new_charset;
  uchar *puVar3;
  string msg;
  
  if (priority != PRI_CSS) {
    psVar1 = init_string(&msg);
    if (psVar1 != (string *)0x0) {
      if ((uri != (uri *)0x0) && (puVar2 = get_uri_string(uri,URI_PUBLIC), puVar2 != (uchar *)0x0))
      {
        if ((ses->tab->term->field_0x38 & 2) == 0) {
          decode_uri_for_display(puVar2);
        }
        else {
          decode_uri(puVar2);
        }
        term = ses->tab->term;
        if ((term != (terminal *)0x0) &&
           (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
          puVar3 = get_cp_mime_name(cp_index);
          bind_textdomain_codeset("elinks",puVar3);
          current_charset = cp_index;
        }
        puVar3 = gettext((uchar *)"Unable to retrieve %s");
        add_format_to_string(&msg,puVar3,puVar2);
        mem_free(puVar2);
        add_to_string(&msg,":\n\n");
      }
      puVar2 = get_state_message(state,ses->tab->term);
      add_to_string(&msg,puVar2);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,"Error",ALIGN_CENTER,msg.source);
    }
  }
  return;
}



// WARNING: Unknown calling convention

int decode_session_info(terminal *term,terminal_info *info)

{
  byte bVar1;
  undefined *puVar2;
  terminal *term_00;
  list_head_elinks *plVar3;
  connection_state state;
  session *ses;
  void *pvVar4;
  uchar *uristring_00;
  session *psVar5;
  session *ses_3;
  window *current_tab;
  session *ses_2;
  session *ses_1;
  uri *puVar6;
  window *pwVar7;
  uchar *uristring;
  uint uVar8;
  size_t __n;
  session_info *info_1;
  session_info *info_00;
  uri *uri;
  uri *uri_00;
  int len;
  int iVar9;
  int urilength;
  size_t sVar10;
  session *local_38;
  uchar *local_30;
  remote_session_flags local_20 [4];
  
  __n = info->length;
  local_20[0] = 0;
  sVar10 = info->magic;
  if (sVar10 == 0xfffffeff) {
    if (info->session_info == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
      errline = 0x42f;
      elinks_internal((uchar *)"Remote magic with no remote flags");
      return 0;
    }
    if ((list_head_elinks *)sessions.next == &sessions) {
      return 0;
    }
    term_00 = *(terminal **)(*(int *)((int)sessions.next + 8) + 0x14);
    bVar1 = term_00->field_0x38;
    plVar3 = (list_head_elinks *)sessions.next;
    while ((bVar1 & 1) == 0) {
      plVar3 = (list_head_elinks *)plVar3->next;
      if (plVar3 == &sessions) {
        return 0;
      }
      term_00 = *(terminal **)((int)plVar3[1].next + 0x14);
      bVar1 = term_00->field_0x38;
    }
    local_20[0] = info->session_info;
    pwVar7 = get_tab_by_number(term_00,term_00->current_tab);
    if (pwVar7 == (window *)0x0) {
      return 0;
    }
    local_38 = (session *)pwVar7->data;
    if (local_38 == (session *)0x0) {
      return 0;
    }
    goto LAB_080d893d;
  }
  if (sVar10 == 0xffffff00) {
    info_00 = (session_info *)session_info.next;
    if ((list_head_elinks *)session_info.next != &session_info) {
      do {
        if (info->session_info == info_00->id) {
          if ((list_head_elinks *)sessions.next == &sessions) goto LAB_080d87da;
          psVar5 = (session *)sessions.next;
          if (info_00->ses == (session *)sessions.next) goto LAB_080d87e1;
          goto LAB_080d87d4;
        }
        info_00 = info_00->next;
      } while (info_00 != (session_info *)&session_info);
    }
    goto LAB_080d8707;
  }
  if ((0 < (int)sVar10) &&
     (iVar9 = __n - 8, local_38 = (session *)0x0, __n = sVar10, (int)sVar10 <= iVar9))
  goto LAB_080d85a1;
  local_38 = (session *)0x0;
  goto LAB_080d884f;
LAB_080d87da:
  info_00->ses = (session *)0x0;
  goto LAB_080d87e1;
  while (info_00->ses != psVar5) {
LAB_080d87d4:
    psVar5 = psVar5->next;
    if (psVar5 == (session *)&sessions) goto LAB_080d87da;
  }
LAB_080d87e1:
  psVar5 = init_session(info_00->ses,term,info_00->uri,0);
  if (psVar5 != (session *)0x0) {
    if ((info_00->uri != (uri *)0x0) && (info_00->task != TASK_NONE)) {
      abort_loading(psVar5,1);
      psVar5->reloadlevel = info_00->cache_mode;
      set_session_referrer(psVar5,info_00->referrer);
      ses_goto(psVar5,info_00->uri,(uchar *)0x0,(location *)0x0,info_00->cache_mode,info_00->task,0)
      ;
    }
    done_session_info(info_00);
    return 1;
  }
  done_session_info(info_00);
LAB_080d8707:
  local_38 = (session *)0x0;
LAB_080d893d:
  if (0 < (int)__n) {
LAB_080d85a1:
    local_30 = info->data;
    do {
      pvVar4 = memchr(local_30,0,__n);
      sVar10 = __n;
      if (pvVar4 != (void *)0x0) {
        sVar10 = (int)pvVar4 - (int)local_30;
      }
      uri_00 = (uri *)0x0;
      uristring_00 = memacpy(local_30,sVar10);
      if (uristring_00 != (uchar *)0x0) {
        uri_00 = get_hooked_uri(uristring_00,local_38,term->cwd);
        mem_free(uristring_00);
      }
      __n = __n + ~sVar10;
      puVar6 = uri_00;
      if (local_20[0] == 0) {
        puVar2 = (undefined *)(term->windows).next;
        if (uri_00 == (uri *)0x0) {
          puVar6 = get_uri((uchar *)"about:blank",0);
        }
        psVar5 = init_session(local_38,term,puVar6,
                              (uint)((list_head_elinks *)puVar2 != &term->windows));
        if (psVar5 == (session *)0x0) {
          __n = 0;
        }
        else if (uri_00 == (uri *)0x0) {
          if (assert_failed == 0) {
            uVar8 = 0xfffe7957;
          }
          else {
            uVar8 = 0xfffe795d;
          }
          assert_failed = 0;
          state.syserr = 0;
          state.basic = uVar8;
          print_error_dialog(psVar5,state,(uri *)0x0,PRI_DOWNLOAD);
        }
        if (puVar6 != (uri *)0x0) {
LAB_080d85d1:
          done_uri(puVar6);
        }
      }
      else if (uri_00 != (uri *)0x0) {
        init_remote_session(local_38,local_20,uri_00);
        goto LAB_080d85d1;
      }
      if ((int)__n < 1) {
        if (local_20[0] == 0) {
          return (uint)(&term->windows != (list_head_elinks *)(term->windows).next);
        }
        return 0;
      }
      local_30 = local_30 + sVar10 + 1;
    } while( true );
  }
  if (local_20[0] == 0) {
LAB_080d884f:
    psVar5 = init_session(local_38,term,(uri *)0x0,0);
    uVar8 = (uint)(psVar5 != (session *)0x0);
  }
  else {
    init_remote_session(local_38,local_20,(uri *)0x0);
    uVar8 = 0;
  }
  return uVar8;
}



void load_frames(session *ses,document_view *doc_view)

{
  frameset_desc *frameset_desc;
  undefined4 *puVar1;
  int iVar2;
  uri *uri_00;
  document *document;
  uri *uri;
  int index;
  int iVar3;
  document *document_1;
  
  if ((doc_view->document != (document *)0x0) &&
     (frameset_desc = doc_view->document->frame_desc, frameset_desc != (frameset_desc *)0x0)) {
    request_frameset(ses,frameset_desc,0);
    for (puVar1 = (undefined4 *)(ses->scrn_frames).next;
        (list_head_elinks *)puVar1 != &ses->scrn_frames; puVar1 = (undefined4 *)*puVar1) {
      iVar2 = puVar1[5];
      if ((iVar2 != 0) && (0 < *(int *)(iVar2 + 0xac))) {
        iVar3 = 0;
        do {
          uri_00 = *(uri **)(*(int *)(iVar2 + 0xb0) + iVar3 * 4);
          if (uri_00 != (uri *)0x0) {
            request_additional_file(ses,"",uri_00,2);
          }
          iVar3 = iVar3 + 1;
        } while (iVar3 < *(int *)(iVar2 + 0xac));
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void tabwin_func(window *tab,term_event *ev)

{
  list_head_elinks *plVar1;
  session *ses_00;
  window *pwVar2;
  terminal *term;
  undefined *puVar3;
  type_query *type_query;
  uchar *p_00;
  document_view *pdVar4;
  window *pwVar5;
  void *p_2;
  void *p_1;
  void *p;
  document_view *p_01;
  session *ses;
  xlist_head *head;
  document_view *doc_view;
  document_view *pdVar6;
  
  ses_00 = (session *)tab->data;
  if (ev->ev < 6) {
    switch(ev->ev) {
    default:
      tab->field_0x28 = tab->field_0x28 | 1;
    case EVENT_REDRAW:
      if ((ses_00 != (session *)0x0) &&
         (pwVar2 = ses_00->tab, term = pwVar2->term,
         pwVar5 = get_tab_by_number(term,term->current_tab), pwVar2 == pwVar5)) {
        draw_formatted(ses_00,(byte)tab->field_0x28 & 1);
        if ((tab->field_0x28 & 1) != 0) {
          load_frames(ses_00,ses_00->doc_view);
          process_file_requests(ses_00);
          tab->field_0x28 = tab->field_0x28 & 0xfe;
        }
        print_screen_status(ses_00);
        return;
      }
      break;
    case EVENT_KBD:
    case EVENT_MOUSE:
      if (ses_00 != (session *)0x0) {
        if (assert_failed == 0) {
          pwVar2 = ses_00->tab;
          pwVar5 = get_tab_by_number(pwVar2->term,pwVar2->term->current_tab);
          assert_failed = (int)(pwVar2 != pwVar5);
          if (pwVar2 != pwVar5) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
            errline = 0x51c;
            elinks_internal((uchar *)"assertion ses->tab == get_current_tab(ses->tab->term) failed!"
                           );
          }
        }
        send_event(ses_00,ev);
        return;
      }
      break;
    case EVENT_ABORT:
      if (ses_00 != (session *)0x0) {
        if (assert_failed == 0) {
          assert_failed = 0;
          destroy_downloads(ses_00);
          abort_loading(ses_00,0);
          free_files(ses_00);
          if (ses_00->doc_view != (document_view *)0x0) {
            detach_formatted(ses_00->doc_view);
            mem_free(ses_00->doc_view);
          }
          pdVar6 = (document_view *)(ses_00->scrn_frames).next;
          plVar1 = &ses_00->scrn_frames;
          p_01 = pdVar6;
          if (pdVar6 != (document_view *)plVar1) {
            do {
              detach_formatted(pdVar6);
              pdVar6 = pdVar6->next;
            } while (pdVar6 != (document_view *)plVar1);
            pdVar6 = (document_view *)(ses_00->scrn_frames).next;
            p_01 = pdVar6;
          }
          for (; (document_view *)plVar1 != pdVar6; pdVar6 = pdVar6->next) {
          }
          for (puVar3 = (undefined *)(ses_00->scrn_frames).prev;
              (list_head_elinks *)puVar3 != plVar1; puVar3 = *(undefined **)(puVar3 + 4)) {
          }
          pdVar6 = p_01->next;
          while (pdVar4 = pdVar6, p_01 != (document_view *)plVar1) {
            pdVar4->prev = p_01->prev;
            p_01->prev->next = p_01->next;
            mem_free(p_01);
            pdVar6 = pdVar4->next;
            p_01 = pdVar4;
          }
          destroy_history(&ses_00->history);
          set_session_referrer(ses_00,(uri *)0x0);
          if (ses_00->loading_uri != (uri *)0x0) {
            done_uri(ses_00->loading_uri);
          }
          kill_timer(&ses_00->display_timer);
          type_query = (type_query *)(ses_00->type_queries).next;
          while (type_query != (type_query *)&ses_00->type_queries) {
            done_type_query(type_query);
            type_query = (type_query *)(ses_00->type_queries).next;
          }
          if (ses_00->download_uri != (uri *)0x0) {
            done_uri(ses_00->download_uri);
          }
          if (ses_00->search_word != (uchar *)0x0) {
            mem_free(ses_00->search_word);
          }
          if (ses_00->last_search_word != (uchar *)0x0) {
            mem_free(ses_00->last_search_word);
          }
          p_00 = (ses_00->status).last_title;
          if (p_00 != (uchar *)0x0) {
            mem_free(p_00);
          }
          ses_00->next->prev = ses_00->prev;
          ses_00->prev->next = ses_00->next;
        }
        else {
          assert_failed = 0;
        }
      }
      if ((list_head_elinks *)sessions.next != &sessions) {
        update_status();
        return;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void display_timer(session *ses)

{
  undefined4 *puVar1;
  uri *puVar2;
  milliseconds_T a;
  milliseconds_T t;
  uri *uri;
  uri *uri_1;
  int index;
  int iVar3;
  int iVar4;
  int index_1;
  document *document_1;
  document *document;
  document *pdVar5;
  timeval_T duration;
  timeval_T stop;
  timeval_T start;
  
  timeval_now(&start);
  draw_formatted(ses,3);
  timeval_now(&stop);
  timeval_sub(&duration,&start,&stop);
  a = timeval_to_milliseconds(&duration);
  t = mult_ms(a,0x14);
  if (t < 200) {
    t = 200;
  }
  install_timer(&ses->display_timer,t,display_timer,ses);
  pdVar5 = ses->doc_view->document;
  if (pdVar5 != (document *)0x0) {
    if (pdVar5->frame_desc != (frameset_desc *)0x0) {
      request_frameset(ses,pdVar5->frame_desc,0);
      for (puVar1 = (undefined4 *)(ses->scrn_frames).next;
          (list_head_elinks *)puVar1 != &ses->scrn_frames; puVar1 = (undefined4 *)*puVar1) {
        iVar4 = puVar1[5];
        if ((iVar4 != 0) && (0 < *(int *)(iVar4 + 0xac))) {
          iVar3 = 0;
          do {
            puVar2 = *(uri **)(*(int *)(iVar4 + 0xb0) + iVar3 * 4);
            if (puVar2 != (uri *)0x0) {
              request_additional_file(ses,"",puVar2,2);
            }
            iVar3 = iVar3 + 1;
          } while (iVar3 < *(int *)(iVar4 + 0xac));
        }
      }
      pdVar5 = ses->doc_view->document;
      if (pdVar5 == (document *)0x0) goto LAB_080d8e6b;
    }
    if (0 < (pdVar5->css_imports).size) {
      iVar4 = 0;
      do {
        puVar2 = (pdVar5->css_imports).uris[iVar4];
        if (puVar2 != (uri *)0x0) {
          request_additional_file(ses,"",puVar2,2);
        }
        iVar4 = iVar4 + 1;
      } while (iVar4 < (pdVar5->css_imports).size);
    }
  }
LAB_080d8e6b:
  process_file_requests(ses);
  return;
}



// WARNING: Unknown calling convention

void doc_loading_callback(download *download,session *ses)

{
  connection_basic_state cVar1;
  uchar *title_00;
  cache_entry *cached;
  undefined4 *puVar2;
  uri *puVar3;
  bool bVar4;
  time_t vtime;
  fragment *fragment;
  option_value *poVar5;
  fragment *pfVar6;
  uri *uri_1;
  uri *uri_2;
  document *document_1;
  uchar *title;
  int index;
  int iVar7;
  document *pdVar8;
  document *document;
  uri *uri;
  int iVar9;
  
  cVar1 = (download->state).basic;
  if (cVar1 < S_WAIT) {
    cached = download->cached;
    if ((cached != (cache_entry *)0x0) && ((cached->field_0x5c & 2) == 0)) {
      (cached->object).refcount = (cached->object).refcount + 1;
      pfVar6 = get_cache_fragment(cached);
      if ((pfVar6 != (fragment *)0x0) && ((cached->frag).next == (cached->frag).prev)) {
        if (maybe_pre_format_html::pre_format_html_event == -1) {
          maybe_pre_format_html::pre_format_html_event = get_event_id((uchar *)"pre-format-html");
        }
        trigger_event(maybe_pre_format_html::pre_format_html_event,ses,cached);
        cached->field_0x5c = cached->field_0x5c | 2;
      }
      (cached->object).refcount = (cached->object).refcount + -1;
    }
    kill_timer(&ses->display_timer);
    draw_formatted(ses,1);
    poVar5 = get_opt_();
    if (poVar5->tree == (list_head_elinks *)0x0) {
      pdVar8 = ses->doc_view->document;
      bVar4 = false;
    }
    else {
      pdVar8 = ses->doc_view->document;
      bVar4 = false;
      if ((list_head_elinks *)(pdVar8->forms).next != &pdVar8->forms) {
        poVar5 = get_opt_();
        poVar5->tree = (list_head_elinks *)0x0;
        pdVar8 = ses->doc_view->document;
        bVar4 = true;
      }
    }
    if (pdVar8 != (document *)0x0) {
      if (pdVar8->frame_desc != (frameset_desc *)0x0) {
        request_frameset(ses,pdVar8->frame_desc,0);
        for (puVar2 = (undefined4 *)(ses->scrn_frames).next;
            (list_head_elinks *)puVar2 != &ses->scrn_frames; puVar2 = (undefined4 *)*puVar2) {
          iVar9 = puVar2[5];
          if ((iVar9 != 0) && (0 < *(int *)(iVar9 + 0xac))) {
            iVar7 = 0;
            do {
              puVar3 = *(uri **)(*(int *)(iVar9 + 0xb0) + iVar7 * 4);
              if (puVar3 != (uri *)0x0) {
                request_additional_file(ses,"",puVar3,2);
              }
              iVar7 = iVar7 + 1;
            } while (iVar7 < *(int *)(iVar9 + 0xac));
          }
        }
        pdVar8 = ses->doc_view->document;
        if (pdVar8 == (document *)0x0) goto LAB_080d9063;
      }
      if (0 < (pdVar8->css_imports).size) {
        iVar9 = 0;
        do {
          puVar3 = (pdVar8->css_imports).uris[iVar9];
          if (puVar3 != (uri *)0x0) {
            request_additional_file(ses,"",puVar3,2);
          }
          iVar9 = iVar9 + 1;
        } while (iVar9 < (pdVar8->css_imports).size);
      }
    }
LAB_080d9063:
    process_file_requests(ses);
    start_document_refreshes(ses);
    if ((download->state).basic != S_OK) {
      print_error_dialog(ses,download->state,ses->doc_view->document->uri,download->pri);
    }
  }
  else if ((cVar1 < S_TRANS) || (ses->display_timer != (timer_id_T)0x0)) {
    bVar4 = false;
  }
  else {
    display_timer(ses);
    bVar4 = false;
  }
  check_questions_queue(ses);
  print_screen_status(ses);
  if (download->pri != PRI_CSS) {
    title_00 = ses->doc_view->document->title;
    if (download->conn == (connection *)0x0) {
      if (download->cached == (cache_entry *)0x0) goto LAB_080d8f03;
      uri = download->cached->uri;
    }
    else {
      uri = download->conn->proxied_uri;
    }
    if (uri != (uri *)0x0) {
      vtime = time((time_t *)0x0);
      add_global_history_item(uri->string,title_00,vtime);
    }
  }
LAB_080d8f03:
  if (bVar4) {
    auto_submit_form(ses);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void file_loading_callback(download *download,file_to_load *ftl)

{
  cache_entry *pcVar1;
  session *ses_00;
  uri *puVar2;
  uchar *puVar3;
  cache_entry *pcVar4;
  uchar *target_frame;
  uri *loading_uri;
  session *ses;
  
  pcVar4 = (ftl->download).cached;
  if (pcVar4 != (cache_entry *)0x0) {
    pcVar1 = ftl->cached;
    if (pcVar4 == pcVar1) goto LAB_080d91a8;
    if (pcVar1 != (cache_entry *)0x0) {
      (pcVar1->object).refcount = (pcVar1->object).refcount + -1;
      pcVar4 = (ftl->download).cached;
    }
    ftl->cached = pcVar4;
    (pcVar4->object).refcount = (pcVar4->object).refcount + 1;
  }
  pcVar4 = ftl->cached;
LAB_080d91a8:
  if (((pcVar4 != (cache_entry *)0x0) && ((pcVar4->field_0x5c & 4) == 0)) &&
     (download->pri != PRI_CSS)) {
    ses_00 = ftl->ses;
    puVar2 = ses_00->loading_uri;
    ses_00->loading_uri = ftl->uri;
    puVar3 = (ses_00->task).target.frame;
    (ses_00->task).target.frame = ftl->target_frame;
    setup_download_handler(ses_00,&ftl->download,ftl->cached,1);
    ses_00->loading_uri = puVar2;
    (ses_00->task).target.frame = puVar3;
  }
  doc_loading_callback(download,ftl->ses);
  return;
}



// WARNING: Unknown calling convention

void free_task(session *ses)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)((ses->task).type == TASK_NONE);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x2c;
    elinks_internal((uchar *)"assertion ses->task.type failed: Session has no task");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (ses->loading_uri != (uri *)0x0) {
    done_uri(ses->loading_uri);
    ses->loading_uri = (uri *)0x0;
  }
  (ses->task).type = TASK_NONE;
  return;
}



// WARNING: Unknown calling convention

uri * get_hooked_uri(uchar *uristring,session *ses,uchar *cwd)

{
  uri *uri;
  uri *puVar1;
  
  uristring = stracpy(uristring);
  if (uristring != (uchar *)0x0) {
    if (get_hooked_uri::goto_url_event_id == -1) {
      get_hooked_uri::goto_url_event_id = get_event_id((uchar *)"goto-url");
    }
    trigger_event(get_hooked_uri::goto_url_event_id,&uristring,ses);
    if (uristring != (uchar *)0x0) {
      puVar1 = (uri *)0x0;
      if (*uristring != '\0') {
        puVar1 = get_translated_uri(uristring,cwd);
      }
      mem_free(uristring);
      return puVar1;
    }
  }
  return (uri *)0x0;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

view_state * ses_forward(session *ses,int loaded_in_frame)

{
  ses_history *history;
  object *poVar1;
  undefined *puVar2;
  uchar *puVar3;
  uri *puVar4;
  document_view *pdVar5;
  frame *frame;
  frame *pfVar6;
  view_state *vs;
  view_state *vs_00;
  location *dst;
  location *loc;
  
  if (loaded_in_frame == 0) {
    free_files(ses);
    if (ses->search_word != (uchar *)0x0) {
      mem_free(ses->search_word);
    }
    ses->search_word = (uchar *)0x0;
  }
  history = &ses->history;
  dst = (location *)0x0;
  if (loaded_in_frame == 0) goto LAB_080d93fd;
LAB_080d9378:
  puVar3 = (ses->task).target.frame;
  do {
    if ((puVar3 == (uchar *)0x0) || (*puVar3 == '\0')) {
      if (assert_failed != 0) {
        assert_failed = 0;
        return (view_state *)0x0;
      }
      assert_failed = (int)(dst == (location *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
        errline = 0x15d;
        elinks_internal((uchar *)"assertion loc failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return (view_state *)0x0;
        }
      }
      (dst->frames).prev = &dst->frames;
      vs_00 = &dst->vs;
      (dst->frames).next = &dst->frames;
      init_vs(vs_00,ses->loading_uri,(dst->vs).plain);
      add_to_history(history,dst);
LAB_080d94c8:
      puVar2 = &(ses->status).field_0x34;
      *puVar2 = *puVar2 & 0xfe;
      if ((ses->task).type == TASK_FORWARD) {
        clean_unhistory(history);
        return vs_00;
      }
      return vs_00;
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return (view_state *)0x0;
    }
    assert_failed = (int)((ses->history).current == (location *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 0x137;
      elinks_internal((uchar *)"assertion have_location(ses) failed: no location yet");
      if (assert_failed != 0) {
        assert_failed = 0;
        return (view_state *)0;
      }
    }
    if (loaded_in_frame == 0) {
      copy_location(dst,(ses->history).current);
      add_to_history(history,dst);
    }
    pfVar6 = ses_find_frame(ses,(ses->task).target.frame);
    if (pfVar6 != (frame *)0x0) {
      vs_00 = &pfVar6->vs;
      if (loaded_in_frame == 0) {
        destroy_vs(vs_00,1);
        init_vs(vs_00,ses->loading_uri,(pfVar6->vs).plain);
      }
      else {
        done_uri((pfVar6->vs).uri);
        puVar4 = ses->loading_uri;
        poVar1 = &puVar4->object;
        poVar1->refcount = poVar1->refcount + 1;
        (pfVar6->vs).uri = puVar4;
        pdVar5 = (pfVar6->vs).doc_view;
        if (pdVar5 != (document_view *)0x0) {
          pdVar5->vs = (view_state *)0x0;
          (pfVar6->vs).doc_view = (document_view *)0x0;
        }
      }
      goto LAB_080d94c8;
    }
    if (loaded_in_frame == 0) {
      del_from_history(history,dst);
      destroy_location(dst);
    }
    (ses->task).target.frame = (uchar *)0x0;
    if (loaded_in_frame != 0) goto LAB_080d9378;
LAB_080d93fd:
    dst = (location *)mem_calloc(1,0x70);
    if (dst == (location *)0x0) {
      return (view_state *)0x0;
    }
    (dst->download).next = (ses->loading).next;
    (dst->download).prev = (ses->loading).prev;
    (dst->download).conn = (ses->loading).conn;
    (dst->download).cached = (ses->loading).cached;
    (dst->download).callback = (ses->loading).callback;
    (dst->download).data = (ses->loading).data;
    (dst->download).progress = (ses->loading).progress;
    (dst->download).state.basic = (ses->loading).state.basic;
    (dst->download).state.syserr = (ses->loading).state.syserr;
    (dst->download).prev_error.basic = (ses->loading).prev_error.basic;
    (dst->download).prev_error.syserr = (ses->loading).prev_error.syserr;
    (dst->download).pri = (ses->loading).pri;
    puVar3 = (ses->task).target.frame;
  } while( true );
}



// WARNING: Unknown calling convention

void post_no(void *task_)

{
                    // WARNING: Load size is inaccurate
  reload(*task_,CACHE_MODE_NORMAL);
  done_uri(*(uri **)((int)task_ + 4));
  return;
}



// WARNING: Unknown calling convention

void ses_load(session *ses,uri *uri,uchar *target_frame,location *target_location,
             cache_mode cache_mode,task_type task_type)

{
  (ses->loading).callback = loading_callback;
  (ses->loading).data = ses;
  ses->loading_uri = uri;
  (ses->task).type = task_type;
  (ses->task).target.frame = target_frame;
  (ses->task).target.location = target_location;
  load_uri(uri,ses->referrer,&ses->loading,PRI_DOWNLOAD,cache_mode,-1);
  return;
}



// WARNING: Unknown calling convention

void ses_goto(session *ses,uri *uri,uchar *target_frame,location *target_location,
             cache_mode cache_mode,task_type task_type,int redir)

{
  byte *pbVar1;
  document *pdVar2;
  document_refresh *refresh;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  cache_entry *pcVar6;
  cache_entry *cached;
  session **p;
  task *task;
  uchar *uristring;
  memory_list *ml;
  option_value *poVar7;
  byte *src;
  ushort **ppuVar8;
  int iVar9;
  int length;
  int slen;
  uchar *p_00;
  uchar *p_01;
  byte *pbVar10;
  byte bVar11;
  int iVar12;
  int trailing_dots;
  byte *pbVar13;
  uchar *pos;
  int malicious_uri;
  char *pcVar14;
  uchar *m1;
  uchar *message;
  byte *s;
  int referrer_incomplete;
  uchar *uristring_1;
  
  if ((uri->field_0x36 & 2) == 0) {
LAB_080d9750:
    bVar5 = false;
  }
  else {
    poVar7 = get_opt_();
    bVar5 = true;
    if (poVar7->tree == (list_head_elinks *)0x0) goto LAB_080d9750;
  }
  if (((ses->doc_view != (document_view *)0x0) &&
      (pdVar2 = ses->doc_view->document, pdVar2 != (document *)0x0)) &&
     (refresh = pdVar2->refresh, refresh != (document_refresh *)0x0)) {
    kill_document_refresh(refresh);
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(ses->loading_uri != (uri *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0xb6;
    elinks_internal((uchar *)"assertion !ses->loading_uri failed: Buggy URI reference counting");
  }
  if (redir == 0) {
    ses->redirect_cnt = 0;
  }
  if ((uri->user != (uchar *)0x0) && (*(short *)&uri->field_0x2a != 0)) {
    pcVar14 = "document.browse.links.warn_malicious";
    poVar7 = get_opt_();
    if (poVar7->tree != (list_head_elinks *)0x0) {
      if (assert_failed == 0) {
        if ((uri->user == (uchar *)0x0) || (*(short *)&uri->field_0x2a == 0)) {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
          errline = 0x7e;
          elinks_internal((uchar *)"assertion uri->user && uri->userlen failed!",pcVar14);
        }
        else {
          assert_failed = 0;
        }
      }
      src = memacpy(uri->user,(uint)*(ushort *)&uri->field_0x2a);
      if (src != (byte *)0x0) {
        decode_uri_for_display(src);
        bVar11 = *src;
        s = src;
LAB_080d99f8:
        if (bVar11 != 0) {
          ppuVar8 = __ctype_b_loc();
          iVar9 = 0;
          pbVar13 = s;
          do {
            if (((*(byte *)(*ppuVar8 + bVar11) & 8) == 0) && (bVar11 != 0x2e)) break;
            iVar9 = iVar9 + 1;
            bVar11 = s[iVar9];
            pbVar13 = s + iVar9;
          } while (bVar11 != 0);
          slen = iVar9;
          if ((iVar9 != 0) && (s[iVar9 + -1] == 0x2e)) {
            pbVar10 = s + iVar9;
            iVar12 = 0;
            do {
              iVar12 = iVar12 + 1;
              if (iVar9 <= iVar12) {
                slen = iVar9 - iVar12;
                break;
              }
              pbVar1 = pbVar10 + -2;
              pbVar10 = pbVar10 + -1;
              slen = iVar9 - iVar12;
            } while (*pbVar1 == 0x2e);
          }
          iVar9 = end_with_known_tld(s,slen);
          if (iVar9 != -1) {
            bVar3 = true;
            bVar4 = false;
            mem_free(src);
            goto LAB_080d984b;
          }
          bVar11 = *pbVar13;
          if (bVar11 != 0) {
            do {
              if (((*(byte *)(*ppuVar8 + bVar11) & 8) != 0) && (s = pbVar13, bVar11 != 0x2e))
              goto LAB_080d99f8;
              pbVar13 = pbVar13 + 1;
              bVar11 = *pbVar13;
            } while (bVar11 != 0);
          }
          bVar11 = 0;
          s = pbVar13;
          goto LAB_080d99f8;
        }
        mem_free(src);
      }
    }
  }
  if ((uri->field_0x36 & 2) != 0) {
    if ((ses->referrer != (uri *)0x0) &&
       (pcVar6 = find_in_cache(ses->referrer), pcVar6 != (cache_entry *)0x0)) {
      bVar3 = false;
      bVar4 = true;
      if ((pcVar6->field_0x5c & 8) != 0) goto LAB_080d984b;
    }
    pcVar6 = get_validated_cache_entry(uri,cache_mode);
    if (pcVar6 != (cache_entry *)0x0) goto LAB_080d9806;
  }
  if (bVar5) {
    bVar3 = false;
    bVar4 = false;
LAB_080d984b:
    p = (session **)mem_alloc(0x18);
    if (p != (session **)0x0) {
      *p = ses;
      (uri->object).refcount = (uri->object).refcount + 1;
      p[1] = (session *)uri;
      p[2] = (session *)cache_mode;
      p[3] = (session *)task_type;
      p[4] = (session *)target_frame;
      p[5] = (session *)target_location;
      if (bVar3) {
        p_00 = memacpy(uri->host,(uint)*(ushort *)&uri->field_0x2e);
        p_01 = memacpy(uri->user,(uint)*(ushort *)&uri->field_0x2a);
        uristring_1 = get_uri_string(uri,URI_PUBLIC);
        message = msg_text(ses->tab->term,
                           (uchar *)
                           "The URL you are about to follow might be maliciously crafted in order to confuse you. By following the URL you will be connecting to host \"%s\" as user \"%s\".\n\nDo you want to go to URL %s?"
                           ,p_00,p_01,uristring_1);
        if (p_00 != (uchar *)0x0) {
          mem_free(p_00);
        }
        if (p_01 != (uchar *)0x0) {
          mem_free(p_01);
        }
      }
      else {
        pcVar14 = "Do you want to follow the redirect and post form data to URL %s?";
        if (((redir == 0) &&
            (pcVar14 = 
             "The form data you are about to post might be incomplete.\nDo you want to post to URL %s?"
            , !bVar4)) &&
           (pcVar14 = "Do you want to post form data to URL %s?", task_type != TASK_FORWARD)) {
          pcVar14 = "Do you want to repost form data to URL %s?";
        }
        uristring_1 = get_uri_string(uri,URI_PUBLIC);
        message = msg_text(ses->tab->term,(uchar *)pcVar14,uristring_1);
      }
      if (uristring_1 != (uchar *)0x0) {
        mem_free(uristring_1);
      }
      ml = getml(p,0);
      msg_box(ses->tab->term,ml,MSGBOX_FREE_TEXT,(uchar *)"Warning",ALIGN_CENTER,message,p,2,
              &DAT_0812762b,post_yes,1,&DAT_08127627,post_no,2);
    }
    return;
  }
LAB_080d9806:
  (uri->object).refcount = (uri->object).refcount + 1;
  ses_load(ses,uri,target_frame,target_location,cache_mode,task_type);
  return;
}



// WARNING: Unknown calling convention

void do_follow_url(session *ses,uri *uri,uchar *target,task_type task,cache_mode cache_mode,
                  int do_referrer)

{
  connection_state state;
  protocol_external_handler_T *UNRECOVERED_JUMPTABLE;
  protocol_external_handler_T *external_handler;
  document_view *doc_view;
  session *new_ses;
  uint uVar1;
  document_view *pdVar2;
  option_value *poVar3;
  session *psVar4;
  int iVar5;
  int iVar6;
  uchar *puVar7;
  int mode;
  uchar *puVar8;
  bool bVar9;
  byte bVar10;
  uri *local_2c;
  
  bVar10 = 0;
  if (uri == (uri *)0x0) {
    if (assert_failed == 0) {
      uVar1 = 0xfffe7957;
    }
    else {
      uVar1 = 0xfffe795d;
    }
    assert_failed = 0;
    state.syserr = 0;
    state.basic = uVar1;
    print_error_dialog(ses,state,(uri *)0x0,PRI_CANCEL);
    return;
  }
  UNRECOVERED_JUMPTABLE = get_protocol_external_handler(ses->tab->term,uri);
  if (UNRECOVERED_JUMPTABLE != (protocol_external_handler_T *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080d9c99. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)(ses,uri);
    return;
  }
  if (((do_referrer == 0) || (pdVar2 = current_frame(ses), pdVar2 == (document_view *)0x0)) ||
     (pdVar2->document == (document *)0x0)) {
    local_2c = (uri *)0x0;
  }
  else {
    local_2c = pdVar2->document->uri;
  }
  bVar9 = target == (uchar *)0x0;
  if (!bVar9) {
    iVar6 = 7;
    puVar7 = target;
    puVar8 = "_blank";
    do {
      if (iVar6 == 0) break;
      iVar6 = iVar6 + -1;
      bVar9 = *puVar7 == *puVar8;
      puVar7 = puVar7 + (uint)bVar10 * -2 + 1;
      puVar8 = puVar8 + (uint)bVar10 * -2 + 1;
    } while (bVar9);
    if (bVar9) {
      poVar3 = get_opt_();
      iVar6 = poVar3->number;
      if (iVar6 == 3) {
        poVar3 = get_opt_();
        if (((poVar3->tree == (list_head_elinks *)0x0) &&
            (iVar5 = can_open_in_new(ses->tab->term), iVar5 != 0)) &&
           ((poVar3 = get_opt_(), poVar3->tree == (list_head_elinks *)0x0 &&
            (poVar3 = get_opt_(), poVar3->tree == (list_head_elinks *)0x0)))) {
          open_uri_in_new_window(ses,uri,local_2c,ses->tab->term->environment,cache_mode,task);
          return;
        }
      }
      else if (iVar6 < 1) goto LAB_080d9ccb;
      psVar4 = init_session(ses,ses->tab->term,uri,(uint)(iVar6 == 2));
      if (psVar4 != (session *)0x0) {
        ses = psVar4;
      }
    }
  }
LAB_080d9ccb:
  ses->reloadlevel = cache_mode;
  if (((ses->task).type != task) || (iVar6 = compare_uri(ses->loading_uri,uri,0), iVar6 == 0)) {
    abort_loading(ses,0);
    set_session_referrer(ses,local_2c);
    ses_goto(ses,uri,target,(location *)0x0,cache_mode,task,0);
  }
  return;
}



// WARNING: Unknown calling convention

void follow_url(session *ses,uri *uri,uchar *target,task_type task,cache_mode cache_mode,
               int referrer)

{
  uchar *uristring;
  uri *uri_00;
  uchar *local_20 [4];
  
  if (uri == (uri *)0x0) {
    local_20[0] = (uchar *)0x0;
  }
  else {
    local_20[0] = get_uri_string(uri,0xffff83bf);
    if (local_20[0] != (uchar *)0x0) {
      if (follow_url::follow_url_event_id == -1) {
        follow_url::follow_url_event_id = get_event_id((uchar *)"follow-url");
      }
      trigger_event(follow_url::follow_url_event_id,local_20,ses);
      if (local_20[0] == (uchar *)0x0) {
        return;
      }
      if (*local_20[0] == '\0') {
        mem_free(local_20[0]);
        return;
      }
      uri_00 = get_translated_uri(local_20[0],ses->tab->term->cwd);
      mem_free(local_20[0]);
      do_follow_url(ses,uri_00,target,task,cache_mode,referrer);
      if (uri_00 == (uri *)0x0) {
        return;
      }
      done_uri(uri_00);
      return;
    }
  }
  do_follow_url(ses,uri,target,task,cache_mode,referrer);
  return;
}



// WARNING: Unknown calling convention

void goto_imgmap(session *ses,uri *uri,uchar *target)

{
  follow_url(ses,uri,target,TASK_IMGMAP,CACHE_MODE_NORMAL,1);
  return;
}



// WARNING: Unknown calling convention

void goto_uri_frame(session *ses,uri *uri,uchar *target,cache_mode cache_mode)

{
  follow_url(ses,uri,target,TASK_FORWARD,cache_mode,1);
  return;
}



// WARNING: Unknown calling convention

void map_selected(terminal *term,void *ld_,void *ses_)

{
  uri *uri_00;
  uri *uri;
  
                    // WARNING: Load size is inaccurate
  uri_00 = get_uri(*ld_,0);
  goto_uri_frame((session *)ses_,uri_00,*(uchar **)((int)ld_ + 4),CACHE_MODE_NORMAL);
  if (uri_00 != (uri *)0x0) {
    done_uri(uri_00);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void delayed_goto_uri_frame(void *data)

{
  frame *pfVar1;
  frame *frame;
  delayed_open *deo;
  uchar *target;
  
  if ((assert_failed == 0) && (assert_failed = (int)(data == (void *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x2a8;
    elinks_internal((uchar *)"assertion deo failed!");
  }
                    // WARNING: Load size is inaccurate
  pfVar1 = ses_find_frame(*data,*(uchar **)((int)data + 8));
  if (pfVar1 == (frame *)0x0) {
    target = (uchar *)0x0;
  }
  else {
    target = pfVar1->name;
  }
                    // WARNING: Load size is inaccurate
  goto_uri_frame(*data,*(uri **)((int)data + 4),target,CACHE_MODE_NORMAL);
  done_uri(*(uri **)((int)data + 4));
  mem_free(*(void **)((int)data + 8));
  mem_free(data);
  return;
}



// WARNING: Unknown calling convention

void goto_uri(session *ses,uri *uri)

{
  follow_url(ses,uri,(uchar *)0x0,TASK_FORWARD,CACHE_MODE_NORMAL,0);
  return;
}



// WARNING: Unknown calling convention

void goto_url_with_hook(session *ses,uchar *url)

{
  uri *uri_00;
  uri *uri;
  
  if (*url != '\0') {
    uri_00 = get_hooked_uri(url,ses,ses->tab->term->cwd);
    if (uri_00 != (uri *)0x0) {
      goto_uri(ses,uri_00);
      done_uri(uri_00);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

int goto_url_home(session *ses)

{
  option_value *poVar1;
  uchar *homepage;
  uchar *url;
  
  poVar1 = get_opt_();
  url = poVar1->string;
  if (*url == '\0') {
    url = (uchar *)getenv("WWW_HOME");
  }
  if ((url != (uchar *)0x0) && (*url != '\0')) {
    goto_url_with_hook(ses,url);
    return 1;
  }
  return 0;
}



// WARNING: Unknown calling convention

void goto_url(session *ses,uchar *url)

{
  uri *uri_00;
  uri *uri;
  
  uri_00 = get_uri(url,0);
  goto_uri(ses,uri_00);
  if (uri_00 != (uri *)0x0) {
    done_uri(uri_00);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void loading_callback(download *download,session *ses)

{
  connection_basic_state cVar1;
  int def;
  protocol_external_handler_T *ppVar2;
  protocol_external_handler_T *fn;
  cache_entry *pcVar3;
  document_view *pdVar4;
  fragment *pfVar5;
  option_value *poVar6;
  int to;
  document_view *doc_view;
  uri *puVar7;
  uri *uri;
  cache_entry *cached;
  fragment *fragment;
  int iVar8;
  do_move d;
  task_type task;
  cache_entry *cached_1;
  uchar *target_frame;
  location *plVar9;
  cache_mode cache_mode;
  task_type tVar10;
  menu_item *local_24;
  memory_list *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)((ses->task).type == TASK_NONE);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x211;
    elinks_internal((uchar *)"assertion ses->task.type failed: loading_callback: no ses->task");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (download == (download *)0x0) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x1d2;
    elinks_internal((uchar *)"assertion download_p && *download_p failed!");
    if (assert_failed == 0) goto LAB_080da336;
LAB_080da55e:
    assert_failed = 0;
    iVar8 = 0;
    goto LAB_080da3f9;
  }
LAB_080da336:
  assert_failed = (int)(ses->loading_uri == (uri *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 0x1d3;
    elinks_internal((uchar *)"assertion ses->loading_uri != NULL failed: no ses->loading_uri");
    if (assert_failed != 0) goto LAB_080da55e;
  }
  if (ses->loading_uri->protocol == 0x12) {
    iVar8 = 0;
    goto LAB_080da3f9;
  }
  if ((((ses->task).type == TASK_IMGMAP) && (S_ERRNO < (download->state).basic)) ||
     (pcVar3 = download->cached, pcVar3 == (cache_entry *)0x0)) {
    iVar8 = 0;
    goto LAB_080da3f9;
  }
  if (((pcVar3->redirect == (uri *)0x0) ||
      (iVar8 = ses->redirect_cnt, ses->redirect_cnt = iVar8 + 1, 9 < iVar8)) ||
     ((tVar10 = (ses->task).type, tVar10 == TASK_HISTORY &&
      ((ses->history).current == (location *)0x0)))) goto LAB_080da38b;
  if (assert_failed == 0) {
    iVar8 = compare_uri(pcVar3->uri,ses->loading_uri,URI_BASE);
    assert_failed = (int)(iVar8 == 0);
    if (iVar8 == 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 0x19f;
      elinks_internal((uchar *)
                      "assertion compare_uri(cached->uri, ses->loading_uri, URI_BASE) failed: Redirecting using bad base URI"
                     );
    }
  }
  if (pcVar3->redirect->protocol == 0x12) {
    iVar8 = 0;
    goto LAB_080da3f9;
  }
  abort_loading(ses,0);
  plVar9 = (ses->history).current;
  if (plVar9 == (location *)0x0) {
    download = (download *)0x0;
  }
  else {
    download = &plVar9->download;
  }
  set_session_referrer(ses,pcVar3->uri);
  if (tVar10 == TASK_IMGMAP) {
LAB_080da960:
    cache_mode = CACHE_MODE_NORMAL;
    plVar9 = (location *)0x0;
    target_frame = (ses->task).target.frame;
  }
  else {
    if (tVar10 < TASK_RELOAD) {
      if (tVar10 != TASK_FORWARD) {
LAB_080da38b:
        kill_timer(&ses->display_timer);
        tVar10 = (ses->task).type;
        if (tVar10 == TASK_IMGMAP) {
          pcVar3 = find_in_cache(ses->loading_uri);
          pdVar4 = current_frame(ses);
          if (pcVar3 == (cache_entry *)0x0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
            errline = 0x179;
            elinks_internal((uchar *)"can\'t find cache entry");
          }
          else {
            pfVar5 = get_cache_fragment(pcVar3);
            if (((pfVar5 != (fragment *)0x0) && (pdVar4 != (document_view *)0x0)) &&
               (pdVar4->document != (document *)0x0)) {
              poVar6 = get_opt_();
              iVar8 = poVar6->number;
              poVar6 = get_opt_();
              def = poVar6->number;
              to = get_terminal_codepage(ses->tab->term);
              iVar8 = get_image_map(pcVar3->head,pfVar5->data,pfVar5->data + *(int *)&pfVar5->length
                                    ,&local_24,local_20,ses->loading_uri,&pdVar4->document->options,
                                    (ses->task).target.frame,to,def,iVar8);
              if (iVar8 == 0) {
                add_empty_window(ses->tab->term,freeml,local_20[0]);
                do_menu(ses->tab->term,local_24,ses,0);
              }
            }
          }
        }
        else if (tVar10 < TASK_RELOAD) {
          if ((tVar10 == TASK_FORWARD) &&
             (iVar8 = setup_download_handler(ses,&ses->loading,pcVar3,0), iVar8 != 0)) {
            iVar8 = 2;
            free_task(ses);
            reload(ses,CACHE_MODE_NORMAL);
            goto LAB_080da3f9;
          }
        }
        else if (tVar10 == TASK_RELOAD) {
          (ses->task).target.location = ((ses->history).current)->prev;
          ses_history_move(ses);
          ses_forward(ses,0);
        }
        else if (tVar10 == TASK_HISTORY) {
          ses_history_move(ses);
        }
        if ((download->state).basic < S_WAIT) {
          plVar9 = (ses->history).current;
          if (plVar9 != (location *)0x0) {
            iVar8 = (ses->loading).state.syserr;
            (plVar9->download).state.basic = (ses->loading).state.basic;
            (plVar9->download).state.syserr = iVar8;
          }
        }
        else {
          plVar9 = (ses->history).current;
          if (plVar9 != (location *)0x0) {
            download = &plVar9->download;
          }
          move_download(&ses->loading,download,PRI_DOWNLOAD);
        }
        iVar8 = 1;
        free_task(ses);
        goto LAB_080da3f9;
      }
      puVar7 = pcVar3->redirect;
      ppVar2 = get_protocol_external_handler(ses->tab->term,puVar7);
      if (ppVar2 != (protocol_external_handler_T *)0x0) {
        (*ppVar2)(ses,puVar7);
        download = (download *)0x0;
        iVar8 = 0;
        goto LAB_080da3f9;
      }
      goto LAB_080da960;
    }
    if (tVar10 == TASK_RELOAD) {
      cache_mode = ses->reloadlevel;
      plVar9 = (location *)0x0;
    }
    else {
      if (tVar10 != TASK_HISTORY) goto LAB_080da38b;
      cache_mode = CACHE_MODE_NORMAL;
      plVar9 = (ses->task).target.location;
    }
    tVar10 = TASK_RELOAD;
    target_frame = (uchar *)0x0;
  }
  iVar8 = 2;
  ses_goto(ses,pcVar3->redirect,target_frame,plVar9,cache_mode,tVar10,1);
LAB_080da3f9:
  if (download != (download *)0x0) {
    if (iVar8 != 2) {
      if (iVar8 == 1) {
        download->callback = doc_loading_callback;
        download->data = ses;
        display_timer(ses);
      }
      if ((download->state).basic < S_WAIT) {
        if ((ses->task).type != TASK_NONE) {
          free_task(ses);
        }
        if (iVar8 == 1) {
          doc_loading_callback(download,ses);
        }
        cVar1 = (download->state).basic;
        if ((cVar1 != S_OK) && (cVar1 < S_WAIT)) {
          puVar7 = (uri *)0x0;
          if (download->conn != (connection *)0x0) {
            puVar7 = download->conn->uri;
          }
          print_error_dialog(ses,download->state,puVar7,download->pri);
          if (iVar8 == 0) {
            reload(ses,CACHE_MODE_NORMAL);
          }
        }
      }
    }
    check_questions_queue(ses);
    print_screen_status(ses);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void abort_preloading(session *ses,int interrupt)

{
  if ((ses->task).type == TASK_NONE) {
    return;
  }
  cancel_download(&ses->loading,interrupt);
  free_task(ses);
  return;
}



// WARNING: Unknown calling convention

void post_yes(void *task_)

{
                    // WARNING: Load size is inaccurate
  abort_preloading(*task_,0);
                    // WARNING: Load size is inaccurate
  ses_load(*task_,*(uri **)((int)task_ + 4),*(uchar **)((int)task_ + 0x10),
           *(location **)((int)task_ + 0x14),*(cache_mode *)((int)task_ + 8),
           *(task_type *)((int)task_ + 0xc));
  return;
}



// WARNING: Unknown calling convention

void set_term_color16(screen_char *schar,color_flags flags,uchar fg,uchar bg)

{
  uchar *puVar1;
  byte bVar2;
  byte bVar3;
  uint uVar4;
  uchar contrastbg;
  uint uVar5;
  byte bVar6;
  uint uVar7;
  
  uVar4 = (uint)fg;
  uVar7 = (uint)bg;
  if ((flags & COLOR_INCREASE_CONTRAST) != 0) {
    uVar4 = (uint)fg_color[uVar4][uVar7];
  }
  bVar2 = schar->attr;
  if (bVar2 != 0) {
    if ((bVar2 & 0x10) != 0) {
      uVar4 = uVar4 ^ 1;
    }
    if ((bVar2 & 8) != 0) {
      uVar4 = uVar4 | 8;
    }
    if (((bVar2 & 0x20) != 0) && ((flags & COLOR_ENHANCE_UNDERLINE) != 0)) {
      uVar4 = (uVar4 | 8) ^ 4;
    }
  }
  bVar6 = bg;
  if (((flags & COLOR_INCREASE_CONTRAST) != 0) ||
     ((uVar5 = uVar4, bVar3 = (byte)uVar4, bg == (byte)uVar4 &&
      (uVar5 = uVar7, bVar3 = bg, (flags & COLOR_ENSURE_CONTRAST) != 0)))) {
    if ((flags & COLOR_ENSURE_INVERTED_CONTRAST) == 0) {
      uVar5 = (uint)fg_color[uVar4][uVar7];
      bVar3 = fg_color[uVar4][uVar7];
    }
    else {
      puVar1 = fg_color[uVar4] + uVar7;
      uVar5 = uVar7;
      uVar7 = (uint)*puVar1;
      bVar6 = *puVar1;
      bVar3 = bg;
    }
  }
  if ((uVar5 & 8) != 0) {
    schar->attr = bVar2 | 8;
  }
  if (((int)(uVar5 & 7) >> 2 | (uVar5 & 7) * 2 & 7) < (((uint)(bVar6 >> 2) | uVar7 * 2) & 7)) {
    schar->attr = schar->attr | 0x40;
  }
  schar->color[0] = bVar3 | (byte)(uVar7 << 4);
  return;
}



// WARNING: Unknown calling convention

void set_term_color(screen_char *schar,color_pair *pair,color_flags flags,color_mode color_mode)

{
  byte bVar1;
  color_mode_info *pcVar2;
  int iVar3;
  uchar fg;
  rgb *prVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  int i;
  int i_1;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uchar bg;
  byte bVar11;
  int iVar12;
  int iVar13;
  int min_dist;
  int iVar14;
  int min_dist_1;
  int local_80;
  int local_68;
  int local_60;
  byte local_5c;
  byte local_2d;
  
  if ((assert_failed == 0) &&
     (assert_failed = (int)(5 < (uint)(color_mode + COLOR_MODE_16)), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
    errline = 299;
    elinks_internal((uchar *)
                    "assertion color_mode >= COLOR_MODE_DUMP && color_mode < COLOR_MODES failed!");
  }
  switch(color_mode + COLOR_MODE_16) {
  case COLOR_MODE_MONO:
  case 6:
    goto switchD_080dafb8_caseD_0;
  case COLOR_MODE_16:
    if ((flags & COLOR_DECREASE_LIGHTNESS) == 0) goto switchD_080dafb8_caseD_3;
    schar->attr = schar->attr | 0x40;
    local_68 = 1;
    break;
  default:
    local_68 = 1;
    if ((flags & COLOR_DECREASE_LIGHTNESS) != 0) break;
  case COLOR_MODE_256:
  case 4:
switchD_080dafb8_caseD_3:
    local_68 = 0;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(schar == (screen_char *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
    errline = 0x16e;
    elinks_internal((uchar *)"assertion schar failed!");
  }
  pcVar2 = color_modes[color_mode];
  iVar3 = pcVar2->palette_range[local_68].fg;
  uVar10 = pair->foreground;
  prVar4 = pcVar2->palette;
  uVar6 = (uVar10 & 0xff0000) >> 0x10;
  uVar5 = uVar10 >> 8 & 0xff;
  uVar8 = iVar3 + uVar5 * 4 + uVar6 * 8 + (uVar10 & 0xff) & 0xfff;
  if (((get_color::cache[uVar8].level == 0) || (iVar3 != get_color::cache[uVar8].level)) ||
     (uVar10 != get_color::cache[uVar8].rgb)) {
    uVar9 = 0;
    local_5c = 0;
    if (1 < iVar3) {
      iVar7 = (uVar10 & 0xff) - (uint)prVar4->b;
      iVar12 = uVar5 - prVar4->g;
      iVar13 = uVar6 - prVar4->r;
      local_2d = 0;
      local_80 = iVar13 * iVar13 * 3 + iVar12 * iVar12 * 4 + iVar7 * iVar7 * 2;
      iVar7 = 1;
      while( true ) {
        iVar12 = uVar6 - prVar4[iVar7].r;
        iVar13 = uVar5 - prVar4[iVar7].g;
        iVar14 = (uVar10 & 0xff) - (uint)prVar4[iVar7].b;
        iVar12 = iVar12 * iVar12 * 3 + iVar13 * iVar13 * 4 + iVar14 * iVar14 * 2;
        local_5c = local_2d;
        if (iVar12 < local_80) {
          local_5c = (byte)iVar7;
          local_80 = iVar12;
        }
        if (iVar7 + 1 == iVar3) break;
        iVar7 = iVar7 + 1;
        local_2d = local_5c;
      }
      uVar9 = (uint)local_5c;
    }
    get_color::cache[uVar8].color = uVar9;
    get_color::cache[uVar8].level = iVar3;
    get_color::cache[uVar8].rgb = uVar10;
    prVar4 = pcVar2->palette;
  }
  else {
    local_5c = *(byte *)&get_color::cache[uVar8].color;
  }
  iVar3 = pcVar2->palette_range[local_68].bg;
  uVar10 = pair->background;
  uVar6 = (uVar10 & 0xff0000) >> 0x10;
  uVar8 = uVar10 >> 8 & 0xff;
  uVar5 = iVar3 + uVar8 * 4 + uVar6 * 8 + (uVar10 & 0xff) & 0xfff;
  if (((get_color::cache[uVar5].level == 0) || (iVar3 != get_color::cache[uVar5].level)) ||
     (uVar10 != get_color::cache[uVar5].rgb)) {
    uVar9 = 0;
    if (1 < iVar3) {
      iVar7 = (uVar10 & 0xff) - (uint)prVar4->b;
      iVar13 = uVar6 - prVar4->r;
      iVar12 = uVar8 - prVar4->g;
      local_2d = 0;
      local_60 = iVar13 * iVar13 * 3 + iVar12 * iVar12 * 4 + iVar7 * iVar7 * 2;
      iVar7 = 1;
      while( true ) {
        iVar12 = uVar6 - prVar4[iVar7].r;
        iVar13 = uVar8 - prVar4[iVar7].g;
        iVar14 = (uVar10 & 0xff) - (uint)prVar4[iVar7].b;
        iVar12 = iVar12 * iVar12 * 3 + iVar13 * iVar13 * 4 + iVar14 * iVar14 * 2;
        if (iVar12 < local_60) {
          local_2d = (byte)iVar7;
          local_60 = iVar12;
        }
        if (iVar7 + 1 == iVar3) break;
        iVar7 = iVar7 + 1;
      }
      uVar9 = (uint)local_2d;
    }
    get_color::cache[uVar5].color = uVar9;
    get_color::cache[uVar5].level = iVar3;
    get_color::cache[uVar5].rgb = uVar10;
  }
  else {
    uVar9 = (uint)*(byte *)&get_color::cache[uVar5].color;
  }
  bVar11 = (byte)uVar9;
  if (color_mode < 4) {
    if (COLOR_MODE_16 < color_mode) {
      if ((local_5c == bVar11) && (bVar11 = local_5c, (flags & COLOR_ENSURE_CONTRAST) != 0)) {
        if ((flags & COLOR_ENSURE_INVERTED_CONTRAST) == 0) {
          if (local_5c == 0) {
            local_5c = 0xf;
          }
          else {
            local_5c = 0;
          }
        }
        else {
          bVar11 = -(local_5c == 0) & 0xf;
        }
      }
      schar->color[0] = local_5c;
      schar->color[1] = bVar11;
      return;
    }
    if (color_mode == COLOR_MODE_DUMP) goto LAB_080db080;
  }
  else if (color_mode == COLOR_MODES) {
LAB_080db080:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
    errline = 0x177;
    elinks_internal((uchar *)"Bad color mode, it should _never_ occur here.");
    return;
  }
  if ((flags & COLOR_INCREASE_CONTRAST) != 0) {
    local_5c = fg_color[local_5c][uVar9];
  }
  bVar1 = schar->attr;
  if (bVar1 != 0) {
    if ((bVar1 & 0x10) != 0) {
      local_5c = local_5c ^ 1;
    }
    if ((bVar1 & 8) != 0) {
      local_5c = local_5c | 8;
    }
    if (((bVar1 & 0x20) != 0) && ((flags & COLOR_ENHANCE_UNDERLINE) != 0)) {
      local_5c = (local_5c | 8) ^ 4;
    }
  }
  uVar10 = uVar9;
  uVar5 = uVar9;
  if ((flags & COLOR_INCREASE_CONTRAST) == 0) {
    if (local_5c == bVar11) {
      if ((flags & COLOR_ENSURE_CONTRAST) != 0) goto LAB_080daf40;
      uVar5 = (uint)local_5c;
    }
    else {
      uVar10 = (uint)local_5c;
    }
  }
  else {
LAB_080daf40:
    if ((flags & COLOR_ENSURE_INVERTED_CONTRAST) == 0) {
      local_5c = fg_color[local_5c][uVar9];
      uVar10 = (uint)local_5c;
    }
    else {
      uVar9 = (uint)fg_color[local_5c][uVar9];
      uVar5 = (uint)fg_color[local_5c][uVar9];
      local_5c = bVar11;
    }
  }
  if ((uVar10 & 8) != 0) {
    schar->attr = bVar1 | 8;
  }
  if (((int)(uVar10 & 7) >> 2 | (uVar10 & 7) * 2 & 7) < ((uVar5 >> 2 | uVar9 * 2) & 7)) {
    schar->attr = schar->attr | 0x40;
  }
  schar->color[0] = (byte)(uVar9 << 4) | local_5c;
switchD_080dafb8_caseD_0:
  return;
}



// WARNING: Unknown calling convention

screen_char * get_char(terminal *term,int x,int y)

{
  screen_char *psVar1;
  int iVar2;
  int iVar3;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db1b2;
    }
    else {
      assert_failed = 0;
    }
    iVar3 = 0;
    if ((-1 < x) && (iVar3 = term->width + -1, x <= iVar3)) {
      iVar3 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    psVar1 = term->screen->image + iVar2 + iVar3;
  }
  else {
LAB_080db1b2:
    assert_failed = 0;
    psVar1 = (screen_char *)0x0;
  }
  return psVar1;
}



// WARNING: Unknown calling convention

void set_cursor(terminal *term,int x,int y,int blockable)

{
  terminal_screen *ptVar1;
  option_value *poVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x234;
    elinks_internal((uchar *)"assertion term && term->screen failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if ((blockable == 0) || (poVar2 = get_opt_(), poVar2->tree == (list_head_elinks *)0x0)) {
    ptVar1 = term->screen;
    if (ptVar1->cx != x) goto LAB_080db2b6;
  }
  else {
    ptVar1 = term->screen;
    x = term->width + -1;
    y = term->height + -1;
    if (ptVar1->cx != x) {
LAB_080db2b6:
      iVar4 = ptVar1->cy;
      goto LAB_080db2b9;
    }
  }
  iVar4 = ptVar1->cy;
  if (iVar4 == y) {
    return;
  }
LAB_080db2b9:
  iVar3 = 0;
  if ((-1 < x) && (iVar3 = term->width + -1, x <= iVar3)) {
    iVar3 = x;
  }
  iVar5 = 0;
  if ((-1 < y) && (iVar5 = term->height + -1, y <= iVar5)) {
    iVar5 = y;
  }
  iVar6 = iVar4;
  if (iVar4 <= iVar5) {
    iVar6 = iVar5;
  }
  if (iVar5 <= iVar4) {
    iVar4 = iVar5;
  }
  if (iVar4 < ptVar1->dirty_from) {
    ptVar1->dirty_from = iVar4;
  }
  if (ptVar1->dirty_to < iVar6) {
    ptVar1->dirty_to = iVar6;
  }
  term->screen->cx = iVar3;
  term->screen->cy = iVar5;
  return;
}



// WARNING: Unknown calling convention

void draw_box(terminal *term,box *box,uchar data,screen_char_attr attr,color_pair *color)

{
  terminal_screen *ptVar1;
  screen_char *psVar2;
  uchar uVar3;
  uchar uVar4;
  undefined uVar5;
  int iVar6;
  option_value *poVar7;
  int height;
  screen_char *__src;
  int iVar8;
  screen_char *end;
  int iVar9;
  screen_char *pos;
  int iVar10;
  screen_char *psVar11;
  screen_char *line;
  
  iVar9 = box->y;
  iVar10 = box->x;
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db3d4;
    }
    else {
      assert_failed = 0;
    }
    iVar6 = term->width;
    iVar8 = 0;
    if ((-1 < iVar10) && (iVar8 = iVar6 + -1, iVar10 < iVar6 + -1)) {
      iVar8 = iVar10;
    }
    iVar10 = 0;
    if ((-1 < iVar9) && (iVar10 = term->height + -1, iVar9 < iVar10)) {
      iVar10 = iVar9;
    }
    __src = term->screen->image + iVar10 * iVar6 + iVar8;
    if (__src != (screen_char *)0x0) {
      iVar10 = term->height - box->y;
      iVar9 = box->height;
      if (iVar10 <= box->height) {
        iVar9 = iVar10;
      }
      iVar6 = iVar6 - box->x;
      iVar10 = box->width;
      if (iVar6 <= box->width) {
        iVar10 = iVar6;
      }
      if ((0 < iVar10) && (0 < iVar9)) {
        psVar11 = __src + iVar10 + -1;
        psVar11->attr = (uchar)attr;
        psVar11->data = (uint)data;
        psVar2 = __src;
        if (color == (color_pair *)0x0) {
          *(undefined2 *)psVar11->color = 0;
        }
        else {
          poVar7 = get_opt_();
          set_term_color(psVar11,color,0,poVar7->number);
        }
        for (; psVar2 < psVar11; psVar2 = psVar2 + 1) {
          psVar2->data = psVar11->data;
          uVar3 = psVar11->color[0];
          uVar4 = psVar11->color[1];
          uVar5 = psVar11->field_0x7;
          psVar2->attr = psVar11->attr;
          psVar2->color[0] = uVar3;
          psVar2->color[1] = uVar4;
          psVar2->field_0x7 = uVar5;
        }
        iVar9 = iVar9 + -1;
        if (iVar9 != 0) {
          psVar11 = __src;
          do {
            psVar11 = psVar11 + term->width;
            memcpy(psVar11,__src,iVar10 << 3);
            iVar9 = iVar9 + -1;
          } while (iVar9 != 0);
        }
        ptVar1 = term->screen;
        iVar9 = box->y;
        iVar10 = box->height + iVar9;
        if (iVar9 < ptVar1->dirty_from) {
          ptVar1->dirty_from = iVar9;
        }
        if (ptVar1->dirty_to < iVar10) {
          ptVar1->dirty_to = iVar10;
          return;
        }
      }
    }
  }
  else {
LAB_080db3d4:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void clear_terminal(terminal *term)

{
  box box;
  
  box.width = term->width;
  box.x = 0;
  if (box.width < 0) {
    box.width = 0;
  }
  box.height = 0;
  if (-1 < term->height) {
    box.height = term->height;
  }
  box.y = 0;
  draw_box(term,&box,' ',0,(color_pair *)0x0);
  set_cursor(term,0,0,1);
  return;
}



// WARNING: Unknown calling convention

void draw_shadow(terminal *term,box *box,color_pair *color,int width,int height)

{
  box dbox;
  
  dbox.y = box->height + box->y;
  dbox.x = width + box->x;
  if (dbox.x < 0) {
    dbox.x = 0;
  }
  if (dbox.y < 0) {
    dbox.y = 0;
  }
  dbox.width = box->width - width;
  if (dbox.width < 0) {
    dbox.width = 0;
  }
  dbox.height = 0;
  if (-1 < height) {
    dbox.height = height;
  }
  draw_box(term,&dbox,' ',0,color);
  dbox.y = height + box->y;
  dbox.x = box->width + box->x;
  if (dbox.x < 0) {
    dbox.x = 0;
  }
  if (dbox.y < 0) {
    dbox.y = 0;
  }
  if (width < 0) {
    width = 0;
  }
  dbox.height = 0;
  if (-1 < box->height) {
    dbox.height = box->height;
  }
  dbox.width = width;
  draw_box(term,&dbox,' ',0,color);
  return;
}



// WARNING: Unknown calling convention

void draw_char_data(terminal *term,int x,int y,unicode_val_T data)

{
  terminal_screen *ptVar1;
  screen_char *screen_char;
  int iVar2;
  screen_char *psVar3;
  int iVar4;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db725;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    psVar3 = term->screen->image + iVar2 + iVar4;
    if (psVar3 != (screen_char *)0x0) {
      psVar3->data = data;
      if (data == 0xfffffffd) {
        psVar3->attr = '\0';
      }
      ptVar1 = term->screen;
      if (y < ptVar1->dirty_from) {
        ptVar1->dirty_from = y;
      }
      if (ptVar1->dirty_to < y) {
        ptVar1->dirty_to = y;
      }
    }
  }
  else {
LAB_080db725:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_char(terminal *term,int x,int y,unicode_val_T data,screen_char_attr attr,color_pair *color
              )

{
  terminal_screen *ptVar1;
  int iVar2;
  option_value *poVar3;
  int iVar4;
  screen_char *screen_char;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080db81c;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    schar = term->screen->image + iVar2 + iVar4;
    if (schar != (screen_char *)0x0) {
      schar->data = data;
      schar->attr = (uchar)attr;
      poVar3 = get_opt_();
      set_term_color(schar,color,0,poVar3->number);
      ptVar1 = term->screen;
      if (y < ptVar1->dirty_from) {
        ptVar1->dirty_from = y;
      }
      if (ptVar1->dirty_to < y) {
        ptVar1->dirty_to = y;
        return;
      }
    }
  }
  else {
LAB_080db81c:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_line(terminal *term,int x,int y,int l,screen_char *line)

{
  screen_char *psVar1;
  terminal_screen *ptVar2;
  unicode_val_T uVar3;
  uchar uVar4;
  uchar uVar5;
  undefined uVar6;
  int iVar7;
  unicode_val_T data_save;
  int iVar8;
  int size;
  screen_char *screen_char;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dba88;
    }
    iVar7 = 0;
    if ((-1 < x) && (iVar7 = term->width + -1, x <= iVar7)) {
      iVar7 = x;
    }
    iVar8 = 0;
    if (-1 < y) {
      iVar8 = term->height + -1;
      if (y <= iVar8) {
        iVar8 = y;
      }
      iVar8 = iVar8 * term->width;
    }
    screen_char = term->screen->image + iVar8 + iVar7;
  }
  else {
LAB_080dba88:
    screen_char = (screen_char *)0x0;
  }
  assert_failed = (int)(line == (screen_char *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x97;
    elinks_internal((uchar *)"assertion line failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (screen_char == (screen_char *)0x0) {
    return;
  }
  size = term->width - x;
  if (l <= size) {
    size = l;
  }
  if (size == 0) {
    return;
  }
  if ((term->field_0x38 & 2) == 0) {
    memcpy(screen_char,line,size << 3);
  }
  else {
    if ((x == 0) && (line->data == 0xfffffffd)) {
      screen_char->data = 0x20;
      uVar4 = line->color[0];
      uVar5 = line->color[1];
      uVar6 = line->field_0x7;
      size = size + -1;
      screen_char->attr = line->attr;
      screen_char->color[0] = uVar4;
      screen_char->color[1] = uVar5;
      screen_char->field_0x7 = uVar6;
      screen_char = screen_char + 1;
      line->data = 0xfffffffd;
      line = line + 1;
    }
    if (0 < size + -1) {
      psVar1 = line + size + -1;
      iVar7 = unicode_to_cell(psVar1->data);
      if (iVar7 == 2) {
        uVar3 = psVar1->data;
        psVar1->data = 0x20;
        memcpy(screen_char,line,size << 3);
        psVar1->data = uVar3;
        goto LAB_080dba2a;
      }
    }
    memcpy(screen_char,line,size << 3);
  }
LAB_080dba2a:
  ptVar2 = term->screen;
  if (y < ptVar2->dirty_from) {
    ptVar2->dirty_from = y;
  }
  if (ptVar2->dirty_to < y) {
    ptVar2->dirty_to = y;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_char_color(terminal *term,int x,int y,color_pair *color)

{
  terminal_screen *ptVar1;
  int iVar2;
  option_value *poVar3;
  int iVar4;
  screen_char *screen_char;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dbb7c;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    schar = term->screen->image + iVar2 + iVar4;
    if (schar != (screen_char *)0x0) {
      poVar3 = get_opt_();
      set_term_color(schar,color,0,poVar3->number);
      ptVar1 = term->screen;
      if (y < ptVar1->dirty_from) {
        ptVar1->dirty_from = y;
      }
      if (ptVar1->dirty_to < y) {
        ptVar1->dirty_to = y;
        return;
      }
    }
  }
  else {
LAB_080dbb7c:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_border_char(terminal *term,int x,int y,border_char border,color_pair *color)

{
  terminal_screen *ptVar1;
  int iVar2;
  option_value *poVar3;
  int iVar4;
  screen_char *screen_char;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dbc9c;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = term->height + -1;
      if (y <= iVar2) {
        iVar2 = y;
      }
      iVar2 = iVar2 * term->width;
    }
    schar = term->screen->image + iVar2 + iVar4;
    if (schar != (screen_char *)0x0) {
      schar->attr = 0x80;
      schar->data = border & 0xff;
      poVar3 = get_opt_();
      set_term_color(schar,color,0,poVar3->number);
      ptVar1 = term->screen;
      if (y < ptVar1->dirty_from) {
        ptVar1->dirty_from = y;
      }
      if (ptVar1->dirty_to < y) {
        ptVar1->dirty_to = y;
        return;
      }
    }
  }
  else {
LAB_080dbc9c:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_border(terminal *term,box *box,color_pair *color,int width)

{
  uchar uVar1;
  int iVar2;
  terminal_screen *ptVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int x;
  int y;
  border_char *pbVar7;
  border_char *p;
  box bbox;
  
  pbVar7 = draw_border::p1;
  if (1 < width) {
    pbVar7 = draw_border::p2;
  }
  iVar2 = box->width;
  iVar6 = box->x;
  x = iVar6 + -1;
  if (x < 0) {
    x = 0;
  }
  y = box->y + -1;
  if (y < 0) {
    y = 0;
  }
  iVar4 = iVar2 + 2;
  if (iVar4 < 0) {
    iVar4 = 0;
  }
  iVar5 = box->height + 2;
  if (iVar5 < 0) {
    iVar5 = 0;
  }
  if (2 < iVar4) {
    bbox.height = 1;
    if (iVar6 < 0) {
      iVar6 = 0;
    }
    bbox.width = 0;
    if (-1 < iVar2) {
      bbox.width = iVar2;
    }
    uVar1 = *(uchar *)(pbVar7 + 5);
    bbox.x = iVar6;
    bbox.y = y;
    draw_box(term,&bbox,uVar1,SCREEN_ATTR_FRAME,color);
    bbox.y = iVar5 + -1 + bbox.y;
    draw_box(term,&bbox,uVar1,SCREEN_ATTR_FRAME,color);
  }
  if (2 < iVar5) {
    bbox.y = box->y;
    bbox.width = 1;
    if (bbox.y < 0) {
      bbox.y = 0;
    }
    bbox.height = 0;
    if (-1 < box->height) {
      bbox.height = box->height;
    }
    uVar1 = *(uchar *)(pbVar7 + 4);
    bbox.x = x;
    draw_box(term,&bbox,uVar1,SCREEN_ATTR_FRAME,color);
    bbox.x = iVar4 + -1 + bbox.x;
    draw_box(term,&bbox,uVar1,SCREEN_ATTR_FRAME,color);
  }
  if ((1 < iVar4) && (1 < iVar5)) {
    iVar6 = iVar4 + -1 + x;
    iVar2 = y + iVar5 + -1;
    draw_border_char(term,x,y,*pbVar7,color);
    draw_border_char(term,iVar6,y,pbVar7[1],color);
    draw_border_char(term,x,iVar2,pbVar7[2],color);
    draw_border_char(term,iVar6,iVar2,pbVar7[3],color);
  }
  ptVar3 = term->screen;
  if (ptVar3->dirty_from != y && y <= ptVar3->dirty_from) {
    ptVar3->dirty_from = y;
  }
  if (ptVar3->dirty_to < y + iVar5) {
    ptVar3->dirty_to = y + iVar5;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_border_cross(terminal *term,int x,int y,border_cross_direction dir,color_pair *color)

{
  int iVar1;
  uint d;
  uint uVar2;
  option_value *poVar3;
  int iVar4;
  screen_char *screen_char;
  screen_char *schar;
  
  if (assert_failed == 0) {
    if (((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) ||
       (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dc04b;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    if ((-1 < x) && (iVar4 = term->width + -1, x <= iVar4)) {
      iVar4 = x;
    }
    iVar1 = 0;
    if (-1 < y) {
      iVar1 = term->height + -1;
      if (y <= iVar1) {
        iVar1 = y;
      }
      iVar1 = iVar1 * term->width;
    }
    schar = term->screen->image + iVar1 + iVar4;
    if ((schar != (screen_char *)0x0) && ((char)schar->attr < '\0')) {
      uVar2 = dir >> 1;
      if (schar->data == (uint)draw_border_cross::border_trans[uVar2][0]) {
        schar->data = (uint)*(byte *)((dir & 1) + 0x810d4b1 + uVar2 * 4);
      }
      else if (schar->data ==
               (uint)*(byte *)((int)draw_border_cross::border_trans + (uVar2 * 4 - (dir & 1)) + 2))
      {
        schar->data = 0xc5;
      }
      poVar3 = get_opt_();
      set_term_color(schar,color,0,poVar3->number);
      return;
    }
  }
  else {
LAB_080dc04b:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_text(terminal *term,int x,int y,uchar *text,int length,screen_char_attr attr,
              color_pair *color)

{
  screen_char *schar;
  terminal_screen *ptVar1;
  uchar uVar2;
  uchar uVar3;
  undefined uVar4;
  byte bVar5;
  option_value *poVar6;
  unicode_val_T uVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  screen_char *pos;
  screen_char *pos_1;
  screen_char *psVar11;
  unicode_val_T data;
  int end_pos;
  screen_char *end;
  int local_3c;
  screen_char *local_38;
  terminal_screen *local_34;
  screen_char *local_30;
  uchar *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  uVar9 = (uint)length >> 0x1f | (uint)(text == (uchar *)0x0);
  assert_failed = uVar9;
  if (uVar9 == 0) {
    if (term->width == x || term->width < x) {
      return;
    }
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x1f7;
    elinks_internal((uchar *)"assertion text && length >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    if (term->width == x || term->width < x) {
      return;
    }
  }
  if (term->height == y || term->height < y) {
    return;
  }
  if ((term->field_0x38 & 2) == 0) {
    if (length < 1) {
      return;
    }
    if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar8 = term->width;
    local_3c = 0;
    if ((-1 < x) && (local_3c = iVar8 + -1, x <= local_3c)) {
      local_3c = x;
    }
    iVar10 = 0;
    if ((-1 < y) && (iVar10 = term->height + -1, y <= iVar10)) {
      iVar10 = y;
    }
    local_34 = term->screen;
    psVar11 = local_34->image + iVar8 * iVar10 + local_3c;
    if (psVar11 == (screen_char *)0x0) {
      return;
    }
    if (iVar8 - x < length) {
      length = iVar8 - x;
    }
    iVar8 = 0;
    if (-1 < length + -1) {
      iVar8 = length + -1;
    }
    schar = psVar11 + iVar8;
    if (color == (color_pair *)0x0) {
      if ((psVar11 <= schar) && (bVar5 = *text, bVar5 != 0)) {
        do {
          psVar11->data = (uint)bVar5;
          psVar11 = psVar11 + 1;
          if (schar < psVar11) break;
          text = text + 1;
          bVar5 = *text;
        } while (bVar5 != 0);
        local_34 = term->screen;
      }
    }
    else {
      schar->attr = (uchar)attr;
      poVar6 = get_opt_();
      set_term_color(schar,color,0,poVar6->number);
      if (psVar11 < schar) {
        bVar5 = *text;
        while (bVar5 != 0) {
          text = text + 1;
          schar->data = (uint)bVar5;
          psVar11->data = (uint)bVar5;
          uVar2 = schar->color[0];
          uVar3 = schar->color[1];
          uVar4 = schar->field_0x7;
          psVar11->attr = schar->attr;
          psVar11->color[0] = uVar2;
          psVar11->color[1] = uVar3;
          psVar11->field_0x7 = uVar4;
          psVar11 = psVar11 + 1;
          if (schar <= psVar11) goto LAB_080dc332;
          bVar5 = *text;
        }
        bVar5 = 0;
      }
      else {
LAB_080dc332:
        bVar5 = *text;
      }
      schar->data = (uint)bVar5;
      local_34 = term->screen;
    }
    if (y < local_34->dirty_from) {
      local_34->dirty_from = y;
    }
    if (y <= local_34->dirty_to) {
      return;
    }
    local_34->dirty_to = y;
    return;
  }
  local_20[0] = text;
  assert_failed = uVar9;
  if (uVar9 != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 0x1af;
    elinks_internal((uchar *)"assertion text && length >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (length < 1) {
    return;
  }
  if (term->width <= x) {
    return;
  }
  uVar7 = utf8_to_unicode(local_20,text + length);
  if (uVar7 == 0xfffffffd) {
    return;
  }
  if (assert_failed == 0) {
    if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dc459;
    }
    else {
      assert_failed = 0;
    }
    local_38 = (screen_char *)0x0;
    if ((-1 < x) && (local_38 = (screen_char *)(term->width + -1), x <= (int)local_38)) {
      local_38 = (screen_char *)x;
    }
    iVar8 = 0;
    if (-1 < y) {
      iVar8 = term->height + -1;
      if (y <= iVar8) {
        iVar8 = y;
      }
      iVar8 = iVar8 * term->width;
    }
    local_30 = term->screen->image + iVar8 + (int)local_38;
    local_38 = local_30 + 1;
  }
  else {
LAB_080dc459:
    assert_failed = 0;
    local_38 = (screen_char *)&DAT_00000008;
    local_30 = (screen_char *)0x0;
  }
  if (color != (color_pair *)0x0) {
    local_30->attr = (uchar)attr;
    poVar6 = get_opt_();
    set_term_color(local_30,color,0,poVar6->number);
  }
  if ((local_30->data == 0xfffffffd) && (0 < x + -1)) {
    draw_char_data(term,x + -1,y,0x20);
  }
  iVar8 = unicode_to_cell(uVar7);
  if (iVar8 == 2) {
    iVar8 = x + 1;
    if (iVar8 < term->width) {
      local_30->data = uVar7;
      iVar8 = x + 2;
      local_38->data = 0xfffffffd;
      local_38->attr = '\0';
      local_38 = local_38 + 1;
    }
    else {
      local_30->data = 0x20;
    }
  }
  else {
    local_30->data = uVar7;
    iVar8 = x + 1;
  }
  if (iVar8 < term->width) {
    while (uVar7 = utf8_to_unicode(local_20,text + length), uVar7 != 0xfffffffd) {
      if (color != (color_pair *)0x0) {
        local_38->data = local_30->data;
        uVar2 = local_30->color[0];
        uVar3 = local_30->color[1];
        uVar4 = local_30->field_0x7;
        local_38->attr = local_30->attr;
        local_38->color[0] = uVar2;
        local_38->color[1] = uVar3;
        local_38->field_0x7 = uVar4;
      }
      iVar10 = unicode_to_cell(uVar7);
      if (iVar10 == 2) {
        iVar10 = iVar8 + 1;
        if (iVar10 < term->width) {
          local_38->data = uVar7;
          iVar10 = iVar8 + 2;
          local_38[1].data = 0xfffffffd;
          local_38[1].attr = '\0';
          local_38 = local_38 + 1;
        }
        else {
          local_38->data = 0x20;
        }
      }
      else {
        local_38->data = uVar7;
        iVar10 = iVar8 + 1;
      }
      if (term->width == iVar10 || term->width < iVar10) break;
      local_38 = local_38 + 1;
      iVar8 = iVar10;
    }
  }
  ptVar1 = term->screen;
  if (y < ptVar1->dirty_from) {
    ptVar1->dirty_from = y;
  }
  if (ptVar1->dirty_to < y) {
    ptVar1->dirty_to = y;
  }
  return;
}



// WARNING: Unknown calling convention

void fix_dwchar_around_box(terminal *term,box *box,int border,int shadow_width,int shadow_height)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int y;
  screen_char *psVar4;
  int x;
  screen_char *schar;
  int height;
  int iVar5;
  
  if ((term->field_0x38 & 2) == 0) {
    return;
  }
  iVar5 = box->x;
  iVar3 = iVar5 + -1;
  x = iVar3 - border;
  if (x < 1) {
LAB_080dc8f0:
    iVar1 = term->width;
    iVar3 = (shadow_width - border) + iVar3;
  }
  else {
    iVar3 = box->y;
    iVar5 = border * 2 + box->height;
    if (assert_failed == 0) {
      if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
        errline = 0x27;
        elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
        if (assert_failed != 0) goto LAB_080dcb38;
      }
      else {
        assert_failed = 0;
      }
      iVar1 = 0;
      iVar3 = iVar3 - border;
      if (-1 < iVar3) {
        iVar1 = term->height + -1;
        if (iVar3 <= iVar1) {
          iVar1 = iVar3;
        }
        iVar1 = iVar1 * term->width;
      }
      iVar3 = term->width + -1;
      if (iVar3 < x) {
        x = iVar3;
      }
      schar = term->screen->image + iVar1 + x;
    }
    else {
LAB_080dcb38:
      assert_failed = 0;
      schar = (screen_char *)0x0;
    }
    if (iVar5 == 0) {
      iVar5 = box->x;
      iVar3 = iVar5 + -1;
      goto LAB_080dc8f0;
    }
    while( true ) {
      iVar5 = iVar5 + -1;
      iVar3 = unicode_to_cell(schar->data);
      if (iVar3 == 2) {
        schar->data = 0x20;
        iVar1 = term->width;
      }
      else {
        iVar1 = term->width;
      }
      if (iVar5 == 0) break;
      schar = schar + iVar1;
    }
    iVar5 = box->x;
    iVar3 = (shadow_width - border) + iVar5 + -1;
  }
  if (iVar3 < 1) {
    iVar5 = border + box->width + iVar5;
    if (iVar1 <= iVar5) goto LAB_080dc922;
LAB_080dc874:
    iVar3 = box->y;
    if (assert_failed == 0) {
      if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
        errline = 0x27;
        elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
        if (assert_failed != 0) goto LAB_080dc884;
      }
      else {
        assert_failed = 0;
      }
      iVar1 = 0;
      if ((-1 < iVar5) && (iVar1 = term->width + -1, iVar5 <= iVar1)) {
        iVar1 = iVar5;
      }
      iVar5 = 0;
      iVar3 = iVar3 - border;
      if (-1 < iVar3) {
        iVar5 = term->height + -1;
        if (iVar3 <= iVar5) {
          iVar5 = iVar3;
        }
        iVar5 = iVar5 * term->width;
      }
      psVar4 = term->screen->image + iVar5 + iVar1;
    }
    else {
LAB_080dc884:
      assert_failed = 0;
      psVar4 = (screen_char *)0x0;
    }
    iVar3 = shadow_height;
    if (shadow_height == 0) {
      iVar1 = term->width;
      iVar5 = box->width + box->x + border;
      goto LAB_080dc922;
    }
    while( true ) {
      if (psVar4->data == 0xfffffffd) {
        psVar4->data = 0x20;
        iVar1 = term->width;
      }
      else {
        iVar1 = term->width;
      }
      if (iVar3 + -1 == 0) break;
      psVar4 = psVar4 + iVar1;
      iVar3 = iVar3 + -1;
    }
    iVar5 = box->width + box->x + border + shadow_width;
    if (iVar1 <= iVar5) {
      return;
    }
  }
  else {
    if (iVar3 < iVar1) {
      iVar5 = box->y;
      iVar1 = box->height;
      if (assert_failed == 0) {
        if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0))
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
          errline = 0x27;
          elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
          if (assert_failed != 0) goto LAB_080dc9e7;
        }
        else {
          assert_failed = 0;
        }
        iVar2 = 0;
        iVar5 = iVar1 + iVar5 + border;
        if (-1 < iVar5) {
          iVar2 = term->height + -1;
          if (iVar5 <= iVar2) {
            iVar2 = iVar5;
          }
          iVar2 = iVar2 * term->width;
        }
        iVar5 = term->width + -1;
        if (iVar3 <= iVar5) {
          iVar5 = iVar3;
        }
        psVar4 = term->screen->image + iVar2 + iVar5;
      }
      else {
LAB_080dc9e7:
        assert_failed = 0;
        psVar4 = (screen_char *)0x0;
      }
      iVar3 = shadow_height;
      if (shadow_height == 0) {
        iVar1 = term->width;
        iVar5 = box->x;
      }
      else {
        while( true ) {
          iVar5 = unicode_to_cell(psVar4->data);
          if (iVar5 == 2) {
            psVar4->data = 0x20;
            iVar1 = term->width;
          }
          else {
            iVar1 = term->width;
          }
          if (iVar3 + -1 == 0) break;
          psVar4 = psVar4 + iVar1;
          iVar3 = iVar3 + -1;
        }
        iVar5 = box->x;
      }
    }
    iVar5 = border + box->width + iVar5;
    if (iVar5 < iVar1) goto LAB_080dc874;
LAB_080dc922:
    iVar5 = iVar5 + shadow_width;
    if (iVar1 <= iVar5) {
      return;
    }
  }
  iVar3 = box->y;
  iVar1 = border * 2 + box->height;
  if (assert_failed == 0) {
    if ((term->screen == (terminal_screen *)0x0) || (term->screen->image == (screen_char *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 0x27;
      elinks_internal((uchar *)"assertion term && term->screen && term->screen->image failed!");
      if (assert_failed != 0) goto LAB_080dcb88;
    }
    else {
      assert_failed = 0;
    }
    iVar2 = 0;
    if ((-1 < iVar5) && (iVar2 = term->width + -1, iVar5 <= iVar2)) {
      iVar2 = iVar5;
    }
    iVar5 = 0;
    iVar3 = (iVar3 - border) + shadow_height;
    if (-1 < iVar3) {
      iVar5 = term->height + -1;
      if (iVar3 <= iVar5) {
        iVar5 = iVar3;
      }
      iVar5 = iVar5 * term->width;
    }
    psVar4 = term->screen->image + iVar5 + iVar2;
  }
  else {
LAB_080dcb88:
    assert_failed = 0;
    psVar4 = (screen_char *)0x0;
  }
  if (iVar1 != 0) {
    while( true ) {
      iVar1 = iVar1 + -1;
      if (psVar4->data == 0xfffffffd) {
        psVar4->data = 0x20;
      }
      if (iVar1 == 0) break;
      psVar4 = psVar4 + term->width;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void term_send_event(terminal *term,term_event *ev)

{
  int height_00;
  int width_00;
  undefined *puVar1;
  term_event_type tVar2;
  uint uVar3;
  window *pwVar4;
  uchar *fmt;
  window *pwVar5;
  int width;
  int height;
  window *win;
  bool bVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(ev == (term_event *)0x0 || term == (terminal *)0x0);
  if (ev == (term_event *)0x0 || term == (terminal *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 0x44;
    elinks_internal((uchar *)"assertion ev && term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    tVar2 = ev->ev;
    assert_failed = 0;
  }
  else {
    tVar2 = ev->ev;
  }
  if (EVENT_ABORT < tVar2) {
    return;
  }
  uVar3 = 1 << ((byte)ev->ev & 0x1f);
  if ((uVar3 & 0x26) != 0) {
    bVar6 = (list_head_elinks *)(term->windows).next == &term->windows;
    assert_failed = (int)bVar6;
    if (bVar6) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
      errline = 0x79;
      elinks_internal((uchar *)"assertion !list_empty(term->windows) failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    pwVar5 = (window *)(term->windows).next;
    if (pwVar5->type == WINDOW_TAB) {
      pwVar5 = get_tab_by_number(term,term->current_tab);
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
      assert_failed = (int)(pwVar5 == (window *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
        errline = 0x81;
        elinks_internal((uchar *)"assertion win != NULL failed: No tab to send the event to!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
    }
                    // WARNING: Could not recover jumptable at 0x080dce06. Too many branches
                    // WARNING: Treating indirect jump as call
    (*pwVar5->handler)(pwVar5,ev);
    return;
  }
  if ((uVar3 & 0x11) == 0) {
    if ((uVar3 & 8) == 0) {
      return;
    }
  }
  else {
    height_00 = (ev->info).mouse.y;
    width_00 = (ev->info).mouse.x;
    if ((height_00 < 0) || (width_00 < 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
      errline = 0x4f;
      fmt = gettext((uchar *)"Bad terminal size: %d, %d");
      elinks_error(fmt,width_00,height_00);
      return;
    }
    resize_screen(term,width_00,height_00);
    erase_screen(term);
  }
  if (term->screen->image != (screen_char *)0x0) {
    clear_terminal(term);
    term->redrawing = TREDRAW_DELAYED;
    if (ev->ev == EVENT_RESIZE) {
      for (puVar1 = (undefined *)(term->windows).prev; &term->windows != (list_head_elinks *)puVar1;
          puVar1 = *(undefined **)(puVar1 + 4)) {
        (**(code **)(puVar1 + 0xc))(puVar1,ev);
      }
    }
    else {
      for (pwVar5 = (window *)(term->windows).prev; pwVar5 != (window *)&term->windows;
          pwVar5 = pwVar5->prev) {
        while ((pwVar5->type == WINDOW_NORMAL ||
               (pwVar4 = get_tab_by_number(pwVar5->term,pwVar5->term->current_tab), pwVar4 == pwVar5
               ))) {
          (*pwVar5->handler)(pwVar5,ev);
          pwVar5 = pwVar5->prev;
          if (pwVar5 == (window *)&term->windows) goto LAB_080dcd47;
        }
      }
    }
LAB_080dcd47:
    term->redrawing = TREDRAW_READY;
  }
  return;
}



// WARNING: Unknown calling convention

void term_send_ucs(terminal *term,unicode_val_T u,term_event_modifier_T modifier)

{
  term_event ev;
  
  ev.info.mouse.button = 0;
  ev.ev = EVENT_KBD;
  ev.info.mouse.x = u;
  ev.info.keyboard.modifier = modifier;
  term_send_event(term,&ev);
  return;
}



// WARNING: Unknown calling convention

void in_term(terminal *term)

{
  uint uVar1;
  object *poVar2;
  char cVar3;
  undefined2 uVar4;
  int iVar5;
  int __fd;
  undefined4 uVar6;
  terminal_interlink *ptVar7;
  term_event_modifier_T modifier;
  byte bVar8;
  size_t size;
  terminal_interlink *p;
  ssize_t sVar9;
  ssize_t r;
  int *piVar10;
  char *pcVar11;
  uchar *puVar12;
  uchar *puVar13;
  uchar *puVar14;
  int iVar15;
  int new_charset_1;
  term_event_type tVar16;
  option_elinks *poVar17;
  uint uVar18;
  option_value *poVar19;
  int len;
  int event_size;
  unicode_val_T u;
  unicode_val_T uVar20;
  uint mask;
  terminal_interlink *interlink;
  int new_charset;
  uint uVar21;
  size_t sVar22;
  terminal_info *info;
  unicode_val_T *puVar23;
  int key;
  unicode_val_T *puVar24;
  int in_GS_OFFSET;
  bool bVar25;
  byte bVar26;
  term_event tev;
  uchar name [42];
  
  bVar26 = 0;
  uVar21 = 0x100;
  iVar5 = *(int *)(in_GS_OFFSET + 0x14);
  p = term->interlink;
  size = 0x11c;
  if (p == (terminal_interlink *)0x0) {
LAB_080dcf8a:
    p = (terminal_interlink *)mem_realloc(p,size);
    if (p == (terminal_interlink *)0x0) {
switchD_080dd16c_caseD_5:
      destroy_terminal(term);
      goto LAB_080dd058;
    }
    if (term->interlink == (terminal_interlink *)0x0) {
      uVar18 = 0;
      do {
        *(undefined4 *)(p->input_queue + (uVar18 - 0x18)) = 0;
        uVar18 = uVar18 + 4;
      } while (uVar18 < 0x1c);
    }
    term->interlink = p;
    iVar15 = p->qlen;
    sVar22 = uVar21 - iVar15;
    p->qfreespace = sVar22;
  }
  else {
    sVar22 = p->qfreespace;
    if (sVar22 == 0) {
      iVar15 = p->qlen;
LAB_080dcf7b:
      uVar21 = iVar15 + 0x100U & 0xffffff00;
      size = uVar21 + 0x1c;
      goto LAB_080dcf8a;
    }
    iVar15 = p->qlen;
    if (0x100 < (int)(sVar22 - iVar15)) goto LAB_080dcf7b;
  }
  puVar12 = p->input_queue;
  __fd = term->fdin;
  do {
    sVar9 = read(__fd,p->input_queue + iVar15,sVar22);
    if (sVar9 != -1) {
      if (sVar9 < 1) goto LAB_080dd048;
      p->qfreespace = p->qfreespace - sVar9;
      uVar21 = p->qlen + sVar9;
      p->qlen = uVar21;
      if (uVar21 < 0x10) goto LAB_080dd058;
      puVar24 = &p[2].utf8.min;
      puVar13 = term->cwd;
      goto LAB_080dd159;
    }
    piVar10 = __errno_location();
  } while (*piVar10 == 4);
  if (*piVar10 != 0x68) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 0x1e3;
    pcVar11 = strerror(*piVar10);
    iVar15 = *piVar10;
    puVar12 = gettext((uchar *)"Could not read event: %d (%s)");
    elinks_error(puVar12,iVar15,pcVar11);
  }
LAB_080dd048:
  destroy_terminal(term);
LAB_080dd058:
  if (iVar5 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080dd159:
  ptVar7 = term->interlink;
  tVar16 = *(term_event_type *)puVar12;
  switch(tVar16) {
  case EVENT_INIT:
    if ((0x13f < (uint)ptVar7->qlen) && (*(int *)p[0xb].input_queue + 0x140U <= (uint)ptVar7->qlen))
    {
      cVar3 = *(char *)&p[1].utf8.len;
      *(undefined *)((int)&p[2].utf8.len + 3) = 0;
      puVar14 = puVar12;
      while (cVar3 != '\0') {
        if ((((0x19 < (byte)(cVar3 + 0x9fU)) && (0x19 < (byte)(cVar3 + 0xbfU))) &&
            (9 < (byte)(cVar3 - 0x30U))) && ((cVar3 != '_' && (cVar3 != '-')))) {
          iVar15 = get_terminal_codepage(term);
          if (iVar15 != current_charset) {
            puVar14 = get_cp_mime_name(iVar15);
            bind_textdomain_codeset("elinks",puVar14);
            current_charset = iVar15;
          }
          puVar14 = gettext((uchar *)"Warning: terminal name contains illicit chars.");
          usrerror(puVar14);
          goto LAB_080dd3ac;
        }
        pcVar11 = (char *)(puVar14 + 0x11);
        puVar14 = puVar14 + 1;
        cVar3 = *pcVar11;
      }
      __snprintf_chk(name,0x2a,1,0x2a,"terminal.%s",&p[1].utf8.len);
      poVar2 = &term->spec->object;
      poVar2->refcount = poVar2->refcount + -1;
      poVar17 = get_opt_rec(config_options,name);
      term->spec = poVar17;
      (poVar17->object).refcount = (poVar17->object).refcount + 1;
      iVar15 = get_terminal_codepage(term);
      uVar21 = is_cp_utf8(iVar15);
      uVar21 = (uVar21 & 1) * 2;
      bVar8 = term->field_0x38 & 0xfd | (byte)uVar21;
      term->field_0x38 = bVar8;
      if ((uVar21 & 2) == 0) {
        poVar19 = get_opt_();
        if (poVar19->tree != (list_head_elinks *)0x0) {
          bVar8 = term->field_0x38;
          goto LAB_080dd6c7;
        }
        iVar15 = 0;
        bVar8 = term->field_0x38;
      }
      else {
LAB_080dd6c7:
        iVar15 = 1;
      }
      term->field_0x38 = bVar8 & 0xfb | (byte)(iVar15 << 2);
LAB_080dd3ac:
      uVar21 = 0x100;
      bVar25 = ((uint)puVar13 & 1) != 0;
      puVar23 = puVar24;
      puVar14 = puVar13;
      if (bVar25) {
        uVar21 = 0xff;
        *puVar13 = *(uchar *)puVar24;
        puVar23 = (unicode_val_T *)((int)&p[2].utf8.min + 1);
        puVar14 = term->cwd + 1;
      }
      if (((uint)puVar14 & 2) != 0) {
        uVar4 = *(undefined2 *)puVar23;
        uVar21 = uVar21 - 2;
        puVar23 = (unicode_val_T *)((int)puVar23 + 2);
        *(undefined2 *)puVar14 = uVar4;
        puVar14 = puVar14 + 2;
      }
      iVar15 = 0;
      for (uVar18 = uVar21 >> 2; uVar18 != 0; uVar18 = uVar18 - 1) {
        *(unicode_val_T *)puVar14 = *puVar23;
        puVar23 = puVar23 + (uint)bVar26 * -2 + 1;
        puVar14 = puVar14 + (uint)bVar26 * -8 + 4;
      }
      if ((uVar21 & 2) != 0) {
        *(undefined2 *)puVar14 = *(undefined2 *)puVar23;
        iVar15 = 2;
      }
      if (bVar25) {
        puVar14[iVar15] = *(uchar *)((int)puVar23 + iVar15);
      }
      term->cwd[0xff] = '\0';
      term->environment = p[0xb].utf8.modifier;
      tev.info.mouse.y = p[1].qfreespace;
      tev.info.mouse.x = p[1].qlen;
      tev.info.mouse.button = 0;
      tev.ev = EVENT_INIT;
      term_send_event(term,&tev);
      iVar15 = decode_session_info(term,(terminal_info *)puVar12);
      if (iVar15 != 0) {
        *(undefined4 *)puVar12 = 3;
        tVar16 = EVENT_REDRAW;
        puVar14 = puVar12;
        goto LAB_080dd17a;
      }
      destroy_terminal(term);
      if (program.terminate != 0) {
        iVar15 = get_terminal_codepage(term);
        if (iVar15 != current_charset) {
          puVar12 = get_cp_mime_name(iVar15);
          bind_textdomain_codeset("elinks",puVar12);
          current_charset = iVar15;
        }
        puVar12 = gettext((uchar *)"Failed to create session.");
        usrerror(puVar12);
        program.retval = RET_FATAL;
      }
    }
    goto LAB_080dd058;
  case EVENT_KBD:
    uVar21 = p[1].qlen;
    modifier = p[1].qfreespace;
    if (0xff < (int)uVar21) {
      uVar21 = -uVar21;
    }
    reset_timer();
    if ((modifier == KBD_MOD_CTRL) && ((uVar21 == 0x4c || (uVar21 == 0x6c)))) {
      redraw_terminal_cls(term);
    }
    else {
      if (uVar21 == 0xfffffe00) {
        destroy_terminal(term);
        goto LAB_080dd058;
      }
      bVar8 = (byte)term->field_0x38 >> 2;
      if ((ptVar7->utf8).len != 0) {
        if ((uVar21 - 0x80 < 0x40) && ((bVar8 & 1) != 0)) {
          uVar18 = (ptVar7->utf8).ucs << 6;
          uVar20 = uVar21 & 0x3f | uVar18;
          (ptVar7->utf8).ucs = uVar20;
          iVar15 = (ptVar7->utf8).len + -1;
          (ptVar7->utf8).len = iVar15;
          if (iVar15 == 0) {
            if ((uVar20 < (ptVar7->utf8).min) || ((uVar18 & 0xfffff800) == 0xd800)) {
              uVar20 = 0xfffd;
            }
            term_send_ucs(term,uVar20,(term->interlink->utf8).modifier);
          }
          break;
        }
        (ptVar7->utf8).len = 0;
        term_send_ucs(term,0xfffd,(term->interlink->utf8).modifier);
      }
      bVar25 = (bVar8 & 1) != 0;
      if (((int)uVar21 < 0x80) || (!bVar25)) {
        if (((int)uVar21 < 0) || (bVar25)) {
          tev.info.mouse.button = 0;
          tev.ev = EVENT_KBD;
          tev.info.mouse.x = uVar21;
          tev.info.keyboard.modifier = modifier;
          term_send_event(term,&tev);
        }
        else {
          iVar15 = get_terminal_codepage(term);
          uVar20 = cp2u(iVar15,(uchar)uVar21);
          term_send_ucs(term,uVar20,modifier);
        }
      }
      else {
        if (((uVar21 & 0xc0) == 0xc0) && ((uVar21 & 0xfe) != 0xfe)) {
          iVar15 = 0;
          uVar18 = 0x80;
          if ((char)(uchar)uVar21 < '\0') {
            do {
              uVar18 = uVar18 >> 1;
              iVar15 = iVar15 + 1;
            } while ((uVar18 & uVar21) != 0);
          }
          if (assert_failed == 0) {
            uVar1 = iVar15 - 2;
            assert_failed = (int)(4 < uVar1);
            if (4 < uVar1) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
              errline = 0x1a7;
              elinks_internal((uchar *)"assertion len >= 2 && len <= 6 failed!");
              if (assert_failed != 0) goto LAB_080dd5c1;
            }
            (ptVar7->utf8).len = iVar15 + -1;
            (ptVar7->utf8).ucs = uVar18 - 1 & uVar21;
            (ptVar7->utf8).min =
                 handle_interlink_event::lexical_block_0::lexical_block_0_1::min[uVar1];
            (ptVar7->utf8).modifier = modifier;
            break;
          }
LAB_080dd5c1:
          assert_failed = 0;
        }
        term_send_ucs(term,0xfffd,modifier);
      }
    }
    break;
  case EVENT_MOUSE:
    reset_timer();
    tev.ev = *(term_event_type *)puVar12;
    tev.info.mouse.x = p[1].qlen;
    tev.info.mouse.y = p[1].qfreespace;
    tev.info.mouse.button = p[1].utf8.ucs;
    if ((((tev.info.mouse.button & 0x20) == 0) || (tev.info.mouse.y != (term->prev_mouse_event).y))
       || (((tev.info.mouse.button ^ (term->prev_mouse_event).button) & 0xffffffdf) != 0)) {
      (term->prev_mouse_event).x = tev.info.mouse.x;
      (term->prev_mouse_event).y = tev.info.mouse.y;
      (term->prev_mouse_event).button = tev.info.mouse.button;
      term_send_event(term,&tev);
    }
    else {
      (term->prev_mouse_event).x = 0;
      (term->prev_mouse_event).y = 0;
      (term->prev_mouse_event).button = 0;
    }
    break;
  case EVENT_REDRAW:
  case EVENT_RESIZE:
    puVar14 = (uchar *)0x0;
LAB_080dd17a:
    tev.info.mouse.y = p[1].qfreespace;
    tev.info.mouse.x = p[1].qlen;
    tev.info.mouse.button = 0;
    tev.ev = tVar16;
    term_send_event(term,&tev);
    if (puVar14 == (uchar *)0x0) break;
    u = *(int *)((int)puVar14 + 0x134) + 0x140;
    if (u != 0) goto LAB_080dd128;
    goto LAB_080dd058;
  case EVENT_ABORT:
    goto switchD_080dd16c_caseD_5;
  default:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 0x1bb;
    uVar6 = *(undefined4 *)puVar12;
    puVar14 = gettext((uchar *)"Bad event %d");
    elinks_error(puVar14,uVar6);
  }
  u = 0x10;
LAB_080dd128:
  p->qfreespace = p->qfreespace + u;
  sVar22 = p->qlen - u;
  p->qlen = sVar22;
  if ((sVar22 == 0) || (memmove(puVar12,p->input_queue + u,sVar22), (uint)p->qlen < 0x10))
  goto LAB_080dd058;
  goto LAB_080dd159;
}



// WARNING: Unknown calling convention

ssize_t hard_read(int fd,uchar *data,size_t datalen)

{
  ssize_t readlen;
  ssize_t sVar1;
  int *piVar2;
  size_t __nbytes;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = (int)(data == (uchar *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c";
    errline = 0x84;
    elinks_internal((uchar *)"assertion data && datalen >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  __nbytes = datalen;
  if (datalen != 0) {
    while( true ) {
      while (sVar1 = read(fd,data,__nbytes), sVar1 == -1) {
        piVar2 = __errno_location();
        if (*piVar2 != 4) {
          return -1;
        }
      }
      if (sVar1 < 1) break;
      __nbytes = __nbytes - sVar1;
      if (__nbytes == 0) goto LAB_080dd888;
      data = data + sVar1;
    }
    if (sVar1 != 0) {
      return -1;
    }
  }
LAB_080dd888:
  return datalen - __nbytes;
}



// WARNING: Unknown calling convention

ssize_t hard_write(int fd,uchar *data,size_t datalen)

{
  ssize_t written;
  ssize_t sVar1;
  int *piVar2;
  size_t __n;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return -1;
  }
  assert_failed = (int)(data == (uchar *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c";
    errline = 0x66;
    elinks_internal((uchar *)"assertion data && datalen >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
  }
  __n = datalen;
  if (datalen != 0) {
    while( true ) {
      while (sVar1 = write(fd,data,__n), sVar1 == -1) {
        piVar2 = __errno_location();
        if (*piVar2 != 4) {
          return -1;
        }
      }
      if (sVar1 < 1) break;
      __n = __n - sVar1;
      if (__n == 0) goto LAB_080dd968;
      data = data + sVar1;
    }
    if (sVar1 != 0) {
      return -1;
    }
  }
LAB_080dd968:
  return datalen - __n;
}



// WARNING: Unknown calling convention

int is_blocked(void)

{
  uint uVar1;
  
  uVar1 = 0;
  if (ditrm != (itrm *)0x0) {
    uVar1 = (byte)ditrm->field_0x74 & 1;
  }
  return uVar1;
}



// WARNING: Unknown calling convention

void send_done_sequence(int h,int altscreen)

{
  hard_write(h,"\x1b[2J",4);
  send_mouse_done_sequence(h);
  if (altscreen != 0) {
    hard_write(h,"\x1b[?47l",6);
  }
  hard_write(h,"\x1b8\r \b",5);
  return;
}



// WARNING: Unknown calling convention

void unhandle_itrm_stdin(itrm *itrm)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -((itrm->in).std >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x4d5;
    elinks_internal((uchar *)"assertion itrm->in.std >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  set_handlers((itrm->in).std,(select_handler_T)0x0,(select_handler_T)0x0,free_itrm,itrm);
  return;
}



// WARNING: Unknown calling convention

void block_itrm(void)

{
  if (ditrm != (itrm *)0x0) {
    ditrm->field_0x74 = ditrm->field_0x74 | 1;
    block_stdin();
    kill_timer(&ditrm->timer);
    (ditrm->in).queue.len = 0;
    unhandle_terminal_resize((ditrm->in).ctl);
    send_done_sequence((ditrm->out).std,(byte)ditrm->field_0x74 >> 1 & 1);
    tcsetattr((ditrm->in).ctl,0,(termios *)&ditrm->t);
    unhandle_itrm_stdin(ditrm);
    suspend_mouse(ditrm->mouse_h);
  }
  return;
}



// WARNING: Unknown calling convention

void handle_itrm_stdin(itrm *itrm)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = -((itrm->in).std >> 0x1f);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x4c8;
    elinks_internal((uchar *)"assertion itrm->in.std >= 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  set_handlers((itrm->in).std,in_kbd,(select_handler_T)0x0,free_itrm,itrm);
  return;
}



// WARNING: Unknown calling convention

void set_kbd_interlink_event(interlink_event *ev,int key,term_event_modifier_T modifier)

{
  if (key < -0xff) {
    key = -key;
  }
  (ev->info).mouse.button = 0;
  ev->ev = EVENT_KBD;
  (ev->info).mouse.x = key;
  (ev->info).mouse.y = modifier;
  return;
}



// WARNING: Unknown calling convention

void send_init_sequence(int h,int altscreen)

{
  hard_write(h,"\x1b)0\x1b7",5);
  if (altscreen != 0) {
    hard_write(h,"\x1b[?47h",6);
  }
  send_mouse_init_sequence(h);
  return;
}



// WARNING: Unknown calling convention

void get_terminal_name(uchar *name)

{
  uchar *puVar1;
  uint uVar2;
  uint uVar3;
  int i;
  int iVar4;
  uchar uVar5;
  undefined2 *puVar6;
  int iVar7;
  bool bVar8;
  
  puVar1 = (uchar *)getenv("TERM");
  uVar3 = 0x20;
  bVar8 = ((uint)name & 1) != 0;
  if (bVar8) {
    uVar3 = 0x1f;
    uVar2 = (uint)(name + 1) & 2;
    *name = '\0';
    puVar6 = (undefined2 *)(name + 1);
  }
  else {
    uVar2 = (uint)name & 2;
    puVar6 = (undefined2 *)name;
  }
  if (uVar2 != 0) {
    *puVar6 = 0;
    uVar3 = uVar3 - 2;
    puVar6 = puVar6 + 1;
  }
  uVar2 = 0;
  do {
    *(undefined4 *)((int)puVar6 + uVar2) = 0;
    uVar2 = uVar2 + 4;
  } while (uVar2 < (uVar3 & 0xfffffffc));
  puVar6 = (undefined2 *)((int)puVar6 + uVar2);
  if ((uVar3 & 2) != 0) {
    *puVar6 = 0;
    puVar6 = puVar6 + 1;
  }
  if (bVar8) {
    *(undefined *)puVar6 = 0;
  }
  if ((puVar1 != (uchar *)0x0) && (uVar5 = *puVar1, uVar5 != '\0')) {
    iVar7 = 0;
    do {
      if ((((0x19 < (byte)(uVar5 + 0x9f)) && (0x19 < (byte)(uVar5 + 0xbf))) &&
          (9 < (byte)(uVar5 - 0x30))) && (uVar5 != '_')) {
        uVar5 = '-';
      }
      iVar4 = iVar7 + 1;
      name[iVar7] = uVar5;
      uVar5 = puVar1[iVar4];
    } while ((iVar4 < 0x1f) && (iVar7 = iVar4, uVar5 != '\0'));
  }
  return;
}



// WARNING: Unknown calling convention

void free_itrm(itrm *itrm)

{
  int iVar1;
  uchar *puVar2;
  void *p;
  void *p_1;
  int iVar3;
  int in_GS_OFFSET;
  uchar title [32];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (itrm == (itrm *)0x0) goto LAB_080ddf01;
  if ((itrm->field_0x74 & 8) == 0) {
    puVar2 = itrm->orig_title;
    if ((puVar2 == (uchar *)0x0) || (*puVar2 == '\0')) {
      if ((itrm->field_0x74 & 4) != 0) {
        get_terminal_name(title);
        if (title[0] != '\0') {
          iVar3 = get_cp_index("US-ASCII");
          set_window_title(title,iVar3);
        }
      }
    }
    else {
      set_window_title(puVar2,itrm->title_codepage);
    }
    unhandle_terminal_resize((itrm->in).ctl);
    disable_mouse();
    send_done_sequence((itrm->out).std,(byte)itrm->field_0x74 >> 1 & 1);
    tcsetattr((itrm->in).ctl,0,(termios *)&itrm->t);
  }
  if (itrm->orig_title != (uchar *)0x0) {
    mem_free(itrm->orig_title);
  }
  itrm->orig_title = (uchar *)0x0;
  if ((itrm->field_0x74 & 8) == 0) {
    iVar3 = (itrm->in).std;
LAB_080dde1f:
    set_handlers(iVar3,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,(void *)0x0
                );
  }
  else {
    iVar3 = (itrm->in).std;
    if (-1 < iVar3) goto LAB_080dde1f;
  }
  set_handlers((itrm->in).sock,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
               (void *)0x0);
  set_handlers((itrm->out).std,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
               (void *)0x0);
  set_handlers((itrm->out).sock,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
               (void *)0x0);
  kill_timer(&itrm->timer);
  if (itrm == ditrm) {
    ditrm = (itrm *)0x0;
  }
  puVar2 = (itrm->out).queue.data;
  if (puVar2 != (uchar *)0x0) {
    mem_free(puVar2);
  }
  puVar2 = (itrm->in).queue.data;
  if (puVar2 != (uchar *)0x0) {
    mem_free(puVar2);
  }
  mem_free(itrm);
LAB_080ddf01:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void free_all_itrms(void)

{
  if (ditrm != (itrm *)0x0) {
    free_itrm(ditrm);
  }
  return;
}



// WARNING: Unknown calling convention

void itrm_queue_event(itrm *itrm,uchar *data,int len)

{
  int *piVar1;
  uchar *puVar2;
  select_handler_T read_func;
  int iVar3;
  int left;
  size_t __n;
  int w;
  
  if (len == 0) {
    return;
  }
  if (((itrm->out).queue.len == 0) && (iVar3 = can_write((itrm->out).sock), iVar3 != 0)) {
    w = write((itrm->out).sock,data,len);
    if (w < 1) {
      register_bottom_half_do(free_itrm,itrm);
      return;
    }
  }
  else {
    w = 0;
  }
  if (w < len) {
    __n = len - w;
    puVar2 = (uchar *)mem_realloc((itrm->out).queue.data,(itrm->out).queue.len + __n);
    if (puVar2 == (uchar *)0x0) {
      free_itrm(itrm);
      return;
    }
    (itrm->out).queue.data = puVar2;
    memcpy(puVar2 + (itrm->out).queue.len,data + w,__n);
    piVar1 = &(itrm->out).queue.len;
    *piVar1 = *piVar1 + __n;
    read_func = get_handler((itrm->out).sock,SELECT_HANDLER_READ);
    set_handlers((itrm->out).sock,read_func,itrm_queue_write,free_itrm,itrm);
  }
  return;
}



// WARNING: Unknown calling convention

void itrm_queue_write(itrm *itrm)

{
  uchar *__dest;
  ssize_t sVar1;
  int written;
  select_handler_T data;
  select_handler_T error_func;
  select_handler_T read_func;
  int qlen;
  size_t sVar2;
  
  sVar2 = (itrm->out).queue.len;
  if (0x7f < (int)sVar2) {
    sVar2 = 0x80;
  }
  if (assert_failed == 0) {
    assert_failed = (int)(sVar2 == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x55;
      elinks_internal((uchar *)"assertion qlen failed: event queue empty");
      if (assert_failed != 0) goto LAB_080de1ae;
    }
    sVar1 = write((itrm->out).sock,(itrm->out).queue.data,sVar2);
    if (sVar1 < 1) {
      if (sVar1 != 0) {
        free_itrm(itrm);
        return;
      }
    }
    else {
      sVar2 = (itrm->out).queue.len - sVar1;
      (itrm->out).queue.len = sVar2;
      if (sVar2 == 0) {
        data = get_handler((itrm->out).sock,SELECT_HANDLER_DATA);
        error_func = get_handler((itrm->out).sock,SELECT_HANDLER_ERROR);
        read_func = get_handler((itrm->out).sock,SELECT_HANDLER_READ);
        set_handlers((itrm->out).sock,read_func,(select_handler_T)0x0,error_func,data);
      }
      else {
        if (assert_failed == 0) {
          assert_failed = (int)((int)sVar2 < 1);
          if ((int)sVar2 < 1) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
            errline = 0x67;
            elinks_internal((uchar *)"assertion itrm->out.queue.len > 0 failed!");
            sVar2 = (itrm->out).queue.len;
          }
          else {
            sVar2 = (itrm->out).queue.len;
          }
        }
        __dest = (itrm->out).queue.data;
        memmove(__dest,__dest + sVar1,sVar2);
      }
    }
  }
  else {
LAB_080de1ae:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

int setraw(itrm *itrm,int save_orig)

{
  int iVar1;
  int iVar2;
  termios *ptVar3;
  int in_GS_OFFSET;
  termios t;
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  ptVar3 = &t;
  for (iVar2 = 0xf; iVar2 != 0; iVar2 = iVar2 + -1) {
    ptVar3->c_iflag = 0;
    ptVar3 = (termios *)&ptVar3->c_oflag;
  }
  iVar2 = tcgetattr((itrm->in).ctl,(termios *)&t);
  if (iVar2 == 0) {
    if (save_orig != 0) {
      (itrm->t).c_iflag = t.c_iflag;
      (itrm->t).c_oflag = t.c_oflag;
      (itrm->t).c_cflag = t.c_cflag;
      (itrm->t).c_lflag = t.c_lflag;
      (itrm->t).c_line = t.c_line;
      (itrm->t).c_cc[0] = t.c_cc[0];
      (itrm->t).c_cc[1] = t.c_cc[1];
      (itrm->t).c_cc[2] = t.c_cc[2];
      *(undefined4 *)((itrm->t).c_cc + 3) = t.c_cc._3_4_;
      *(undefined4 *)((itrm->t).c_cc + 7) = t.c_cc._7_4_;
      *(undefined4 *)((itrm->t).c_cc + 0xb) = t.c_cc._11_4_;
      *(undefined4 *)((itrm->t).c_cc + 0xf) = t.c_cc._15_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x13) = t.c_cc._19_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x17) = t.c_cc._23_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x1b) = t.c_cc._27_4_;
      *(undefined4 *)((itrm->t).c_cc + 0x1f) = t._48_4_;
      (itrm->t).c_ispeed = t.c_ispeed;
      (itrm->t).c_ospeed = t.c_ospeed;
    }
    if (t.c_cc[2] == '\0') {
      itrm->verase = -1;
    }
    else {
      itrm->verase = (uint)t.c_cc[2];
    }
    elinks_cfmakeraw(&t);
    t.c_lflag = t.c_lflag | 0x101;
    t.c_oflag = t.c_oflag | 1;
    iVar1 = tcsetattr((itrm->in).ctl,0,(termios *)&t);
    iVar2 = 0;
    if (iVar1 == 0) goto LAB_080de2c3;
  }
  iVar2 = -1;
LAB_080de2c3:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int unblock_itrm(void)

{
  int iVar1;
  
  if ((ditrm != (itrm *)0x0) && (((ditrm->in).ctl < 0 || (iVar1 = setraw(ditrm,0), iVar1 == 0)))) {
    ditrm->field_0x74 = ditrm->field_0x74 & 0xfe;
    send_init_sequence((ditrm->out).std,(byte)ditrm->field_0x74 >> 1 & 1);
    handle_itrm_stdin(ditrm);
    resume_mouse(ditrm->mouse_h);
    handle_terminal_resize((ditrm->in).ctl,resize_terminal);
    unblock_stdin();
    return 0;
  }
  return -1;
}



// WARNING: Unknown calling convention

void handle_trm(int std_in,int std_out,int sock_in,int sock_out,int ctl_in,void *init_string,
               int init_len,int remote)

{
  int iVar1;
  itrm *itrm_00;
  itrm *itrm;
  uchar *puVar2;
  uchar *ts;
  size_t sVar3;
  option_value *poVar4;
  int iVar5;
  size_t sVar6;
  terminal_info *ptVar7;
  int in_GS_OFFSET;
  terminal_info info;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  ptVar7 = &info;
  for (iVar5 = 0x51; iVar5 != 0; iVar5 = iVar5 + -1) {
    (ptVar7->event).ev = EVENT_INIT;
    ptVar7 = (terminal_info *)&(ptVar7->event).info;
  }
  get_terminal_size(ctl_in,(int *)&info.event.info,&info.event.info.mouse.y);
  info.event.ev = EVENT_INIT;
  info.system_env = get_system_env();
  info.length = init_len;
  if (remote == 0) {
    poVar4 = get_opt_();
    info.session_info = poVar4->number;
    info.magic = -0x100;
  }
  else {
    info.session_info = remote;
    info.magic = -0x101;
  }
  itrm_00 = (itrm *)mem_calloc(1,0x78);
  if (itrm_00 != (itrm *)0x0) {
    puVar2 = (uchar *)mem_calloc(1,0x40);
    (itrm_00->in).queue.data = puVar2;
    if (puVar2 == (uchar *)0x0) {
      mem_free(itrm_00);
    }
    else {
      ditrm = itrm_00;
      (itrm_00->in).std = std_in;
      (itrm_00->out).std = std_out;
      (itrm_00->in).sock = sock_in;
      (itrm_00->out).sock = sock_out;
      itrm_00->timer = (timer_id_T)0x0;
      (itrm_00->in).ctl = ctl_in;
      itrm_00->field_0x74 = itrm_00->field_0x74 & 0xf7 | (remote != 0) << 3;
      iVar5 = get_cp_index((uchar *)"ISO-8859-1");
      itrm_00->title_codepage = iVar5;
      if ((info.system_env & 6U) != 0) {
        itrm_00->field_0x74 = itrm_00->field_0x74 | 2;
      }
      if (remote == 0) {
        if (-1 < ctl_in) {
          setraw(itrm_00,1);
        }
        send_init_sequence(std_out,(byte)itrm_00->field_0x74 >> 1 & 1);
        handle_terminal_resize(ctl_in,resize_terminal);
        enable_mouse();
        handle_itrm_stdin(itrm_00);
      }
      else if (-1 < std_in) {
        handle_itrm_stdin(itrm_00);
      }
      if (sock_in != std_out) {
        set_handlers(sock_in,in_sock,(select_handler_T)0x0,free_itrm,itrm_00);
      }
      get_terminal_name(info.name);
      puVar2 = get_cwd();
      if (puVar2 != (uchar *)0x0) {
        sVar3 = strlen((char *)puVar2);
        sVar6 = 0x100;
        if ((int)sVar3 < 0x100) {
          sVar6 = sVar3;
        }
        __memcpy_chk(info.cwd,puVar2,sVar6,0x114);
        mem_free(puVar2);
      }
      itrm_queue_event(itrm_00,(uchar *)&info,0x140);
      itrm_queue_event(itrm_00,(uchar *)init_string,init_len);
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void resize_terminal(void)

{
  interlink_event ev;
  int local_14;
  int local_10 [3];
  
  get_terminal_size((ditrm->out).std,local_10,&local_14);
  ev.info.mouse.button = 0;
  ev.ev = EVENT_RESIZE;
  ev.info.mouse.x = local_10[0];
  ev.info.mouse.y = local_14;
  itrm_queue_event(ditrm,(uchar *)&ev,0x10);
  return;
}



// WARNING: Unknown calling convention

void dispatch_special(uchar *text)

{
  uchar uVar1;
  itrm *piVar2;
  uchar *puVar3;
  byte bVar4;
  int cp;
  long lVar5;
  char *pcVar6;
  int iVar7;
  uchar *puVar8;
  anon_enum_32 i;
  int iVar9;
  int numbers [4];
  
  piVar2 = ditrm;
  uVar1 = *text;
  if (uVar1 == '\x02') {
    if ((ditrm != (itrm *)0x0) && ((ditrm->field_0x74 & 8) != 0)) {
      return;
    }
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    puVar8 = text + 1;
    if ((puVar8 == (uchar *)0x0) || (text[1] == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x1d7;
      elinks_internal((uchar *)"assertion text && *text failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar9 = 0;
    iVar7 = 0;
    do {
      pcVar6 = strchr((char *)puVar8,0x2c);
      if (pcVar6 == (char *)0x0) {
        if (iVar7 != 3) {
          return;
        }
        numbers[3] = strtol((char *)puVar8,(char **)0x0,10);
LAB_080de881:
        puVar3 = puVar8;
      }
      else {
        *pcVar6 = '\0';
        lVar5 = strtol((char *)puVar8,(char **)0x0,10);
        numbers[iVar7] = lVar5;
        puVar3 = (uchar *)(pcVar6 + 1);
        if ((uchar *)(pcVar6 + 1) == (uchar *)0x0) goto LAB_080de881;
      }
      puVar8 = puVar3;
      if (iVar9 == 3) {
        resize_window(numbers[0],numbers[1],numbers[2],numbers[3]);
        resize_terminal();
        return;
      }
      iVar9 = iVar9 + 1;
      iVar7 = iVar7 + 1;
    } while( true );
  }
  if (uVar1 == '\x03') {
    if (ditrm != (itrm *)0x0) {
      iVar7 = get_cp_index(text + 1);
      if (iVar7 == -1) {
        iVar7 = get_cp_index("US-ASCII");
      }
      ditrm->title_codepage = iVar7;
      return;
    }
    return;
  }
  if (uVar1 != '\x01') {
    return;
  }
  if (ditrm != (itrm *)0x0) {
    bVar4 = ditrm->field_0x74;
    if ((bVar4 & 8) != 0) {
      return;
    }
    if (ditrm->orig_title == (uchar *)0x0) {
      puVar8 = get_window_title();
      piVar2->orig_title = puVar8;
      bVar4 = ditrm->field_0x74;
    }
    ditrm->field_0x74 = bVar4 | 4;
    if (ditrm != (itrm *)0x0) {
      iVar7 = ditrm->title_codepage;
      goto LAB_080de77f;
    }
  }
  iVar7 = get_cp_index("US-ASCII");
LAB_080de77f:
  set_window_title(text + 1,iVar7);
  return;
}



// WARNING: Unknown calling convention

void unblock_itrm_x(void *h)

{
  close_handle(h);
  if (ditrm != (itrm *)0x0) {
    unblock_itrm();
    resize_terminal();
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void set_kbd_event(itrm *itrm,interlink_event *ev,int key,term_event_modifier_T modifier)

{
  int iVar1;
  
  if (itrm->verase == key) {
    key = 0x101;
    goto LAB_080dea00;
  }
  if (key == 0xd) {
LAB_080de9fa:
    key = 0x100;
  }
  else {
    if (key < 0xe) {
      if (key == 9) {
        key = 0x102;
        goto LAB_080dea00;
      }
      if (key == 10) goto LAB_080de9fa;
    }
    else {
      if (key == 0x1b) {
        key = 0x103;
        goto LAB_080dea00;
      }
      if (key == 0x7f) {
        key = 0x109;
        goto LAB_080dea00;
      }
    }
    if (key < 0x20) {
      iVar1 = key + 0x40;
      (ev->info).mouse.x = 0;
      (ev->info).mouse.y = 0;
      (ev->info).mouse.button = 0;
      ev->ev = EVENT_KBD;
      if (iVar1 < -0xff) {
        iVar1 = -iVar1;
      }
      (ev->info).mouse.y = modifier | KBD_MOD_CTRL;
      (ev->info).mouse.x = iVar1;
      return;
    }
  }
LAB_080dea00:
  (ev->info).mouse.x = 0;
  (ev->info).mouse.y = 0;
  (ev->info).mouse.button = 0;
  (ev->info).mouse.y = modifier;
  ev->ev = EVENT_KBD;
  (ev->info).mouse.x = key;
  return;
}



// WARNING: Unknown calling convention

void in_sock(itrm *itrm)

{
  int iVar1;
  int iVar2;
  uchar uVar3;
  size_t sVar4;
  ssize_t bytes_read;
  string *psVar5;
  ssize_t sVar6;
  uchar *ptr;
  uchar *param;
  int iVar7;
  int blockh;
  int path_len;
  int iVar8;
  int iVar9;
  ssize_t p;
  ssize_t i;
  size_t sVar10;
  int in_GS_OFFSET;
  string delete;
  string path;
  uchar local_4021;
  uchar buf [16384];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  sVar4 = read((itrm->in).sock,buf,0x4000);
  if ((int)sVar4 < 1) {
free_and_return:
    free_itrm(itrm);
  }
  else {
    do {
      p = 0;
      if (buf[0] == '\0') {
        iVar8 = 0x3fff;
        iVar7 = 1;
      }
      else {
        do {
          sVar10 = p;
          p = sVar10 + 1;
          if ((int)sVar4 <= p) goto LAB_080deac5;
        } while (buf[p] != '\0');
        if (p == 0) {
          iVar7 = 1;
          iVar8 = 0x3fff;
        }
        else {
          iVar8 = (itrm->out).std;
          if ((ditrm == (itrm *)0x0) || ((ditrm->field_0x74 & 1) == 0)) {
            want_draw();
            hard_write(iVar8,buf,p);
            done_draw();
          }
          iVar7 = sVar10 + 2;
          iVar8 = 0x4000 - iVar7;
        }
      }
      if ((assert_failed == 0) && (assert_failed = (int)(iVar8 < 1), iVar8 < 1)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 0x23d;
        elinks_internal((uchar *)"assertion ITRM_OUT_QUEUE_SIZE - i > 0 failed!");
      }
      iVar9 = sVar4 - iVar7;
      __memmove_chk(buf,buf + iVar7,iVar8,0x4000);
      if (iVar9 < 1) {
        sVar6 = hard_read((itrm->in).sock,&local_4021,1);
        if (sVar6 < 1) goto free_and_return;
        iVar8 = 0;
      }
      else {
        iVar8 = 1;
        local_4021 = buf[0];
      }
      uVar3 = local_4021;
      psVar5 = init_string(&path);
      if (psVar5 == (string *)0x0) goto free_and_return;
      while( true ) {
        if (iVar8 < iVar9) {
          local_4021 = buf[iVar8];
          iVar8 = iVar8 + 1;
        }
        else {
          sVar6 = hard_read((itrm->in).sock,&local_4021,1);
          if (sVar6 < 1) goto free_and_return;
        }
        if (local_4021 == '\0') break;
        add_char_to_string(&path,local_4021);
      }
      psVar5 = init_string(&delete);
      if (psVar5 == (string *)0x0) {
        done_string(&path);
        goto free_and_return;
      }
      while( true ) {
        if (iVar8 < iVar9) {
          local_4021 = buf[iVar8];
          iVar8 = iVar8 + 1;
          iVar7 = delete.length;
          iVar2 = path.length;
        }
        else {
          sVar6 = hard_read((itrm->in).sock,&local_4021,1);
          iVar7 = delete.length;
          iVar2 = path.length;
          if (sVar6 < 1) goto free_and_return;
        }
        delete.length = iVar7;
        path.length = iVar2;
        if (local_4021 == '\0') break;
        add_char_to_string(&delete,local_4021);
      }
      if (*path.source == '\0') {
        dispatch_special(delete.source);
      }
      else if (((ditrm == (itrm *)0x0) || ((ditrm->field_0x74 & 1) == 0)) || (uVar3 == '\0')) {
        sVar4 = iVar7 + 3 + iVar2;
        ptr = (uchar *)mem_alloc(sVar4);
        if (ptr != (uchar *)0x0) {
          *ptr = uVar3;
          memcpy(ptr + 1,path.source,iVar2 + 1);
          memcpy(ptr + iVar2 + 2,delete.source,iVar7 + 1);
          if (uVar3 == '\x01') {
            block_itrm();
          }
          iVar7 = start_thread(exec_thread,ptr,sVar4);
          mem_free(ptr);
          if (iVar7 == -1) {
            if (uVar3 == '\x01') {
              unblock_itrm();
            }
          }
          else if (uVar3 == '\x01') {
            set_handlers(iVar7,unblock_itrm_x,(select_handler_T)0x0,unblock_itrm_x,(void *)iVar7);
          }
          else {
            set_handlers(iVar7,close_handle,(select_handler_T)0x0,close_handle,(void *)iVar7);
          }
        }
      }
      else if (*delete.source != '\0') {
        unlink((char *)delete.source);
      }
      done_string(&path);
      done_string(&delete);
      if (assert_failed == 0) {
        iVar7 = 0x4000 - iVar8;
        assert_failed = (int)(iVar7 < 1);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
          errline = 0x299;
          elinks_internal((uchar *)"assertion ITRM_OUT_QUEUE_SIZE - p > 0 failed!");
        }
      }
      else {
        iVar7 = 0x4000 - iVar8;
      }
      sVar4 = iVar9 - iVar8;
      __memmove_chk(buf,buf + iVar8,iVar7,0x4000);
    } while (0 < (int)sVar4);
LAB_080deac5:
    iVar8 = (itrm->out).std;
    if ((ditrm == (itrm *)0x0) || ((ditrm->field_0x74 & 1) == 0)) {
      want_draw();
      hard_write(iVar8,buf,sVar4);
      done_draw();
    }
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void kbd_ctrl_c(void)

{
  interlink_event ev;
  
  if (ditrm != (itrm *)0x0) {
    ev.info.mouse.button = 0;
    ev.ev = EVENT_KBD;
    ev.info.mouse.x = 0x200;
    ev.info.mouse.y = 0;
    itrm_queue_event(ditrm,(uchar *)&ev,0x10);
  }
  return;
}



// WARNING: Unknown calling convention

int process_queue(itrm *itrm)

{
  uchar *__dest;
  size_t __n;
  int v;
  int iVar1;
  byte *pbVar2;
  uchar c;
  byte bVar3;
  int el;
  int pos;
  int iVar4;
  byte *pbVar5;
  interlink_event *piVar6;
  bool bVar7;
  byte bVar8;
  int local_34;
  byte local_2d;
  interlink_event ev;
  
  bVar8 = 0;
  local_34 = 0;
  if ((itrm->in).queue.len == 0) goto LAB_080df178;
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (byte)itrm->field_0x74 & 1;
  if ((itrm->field_0x74 & 1) != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x424;
    elinks_internal((uchar *)"assertion !itrm->blocked failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  ev.info.mouse.button = 0;
  ev.ev = EVENT_KBD;
  ev.info.mouse.x = -1;
  ev.info.mouse.y = 0;
  pbVar2 = (itrm->in).queue.data;
  bVar3 = *pbVar2;
  if (bVar3 != 0x1b) {
    if (bVar3 != 0) {
      local_34 = 1;
      set_kbd_event(itrm,&ev,(uint)bVar3,KBD_MOD_NONE);
      goto LAB_080df125;
    }
    local_34 = -1;
    if (1 < (itrm->in).queue.len) {
      local_34 = 2;
      set_kbd_interlink_event
                (&ev,process_queue::lexical_block_0::os2xtd[pbVar2[1]].key,
                 process_queue::lexical_block_0::os2xtd[pbVar2[1]].modifier);
      goto LAB_080df125;
    }
    goto LAB_080df12a;
  }
  iVar1 = (itrm->in).queue.len;
  if (iVar1 < 2) goto LAB_080df310;
  bVar3 = pbVar2[1];
  if (bVar3 != 0x5b) {
    if (bVar3 == 0x4f) {
      if (assert_failed != 0) {
LAB_080df456:
        assert_failed = 0;
        goto LAB_080df362;
      }
      bVar7 = *(itrm->in).queue.data != '\x1b';
      assert_failed = (int)bVar7;
      if (bVar7) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 0x3a5;
        elinks_internal((uchar *)"assertion itrm->in.queue.data[0] == ASCII_ESC failed!");
        if (assert_failed != 0) goto LAB_080df456;
      }
      bVar7 = (itrm->in).queue.data[1] != 'O';
      assert_failed = (int)bVar7;
      if (bVar7) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 0x3a6;
        elinks_internal((uchar *)"assertion itrm->in.queue.data[1] == 0x4F failed!");
        if (assert_failed != 0) goto LAB_080df456;
      }
      if ((itrm->in).queue.len < 3) goto LAB_080df310;
      bVar8 = (itrm->in).queue.data[2];
      if (0x5d < (byte)(bVar8 - 0x21)) goto LAB_080df362;
      if (bVar8 == 0x4d) {
        iVar1 = -0x100;
LAB_080df40e:
        ev.info.mouse.y = 0;
        ev.info.mouse.x = iVar1;
      }
      else {
        if (bVar8 < 0x4e) {
          if (bVar8 == 0x44) {
            iVar1 = -0x104;
          }
          else if (bVar8 < 0x45) {
            if (bVar8 == 0x42) {
              iVar1 = -0x107;
            }
            else {
              iVar1 = -0x105;
              if (bVar8 < 0x43) {
                if (bVar8 != 0x41) goto LAB_080df418;
                iVar1 = -0x106;
              }
            }
          }
          else if (bVar8 == 0x48) {
            iVar1 = -0x10a;
          }
          else if (bVar8 == 0x49) {
            iVar1 = -0x102;
          }
          else {
            if (bVar8 != 0x46) goto LAB_080df418;
            iVar1 = -0x10b;
          }
          goto LAB_080df40e;
        }
        if (bVar8 == 0x53) {
          iVar1 = -0x123;
          goto LAB_080df40e;
        }
        if (bVar8 < 0x54) {
          if (bVar8 == 0x51) {
            iVar1 = -0x121;
          }
          else {
            iVar1 = -0x122;
            if (bVar8 < 0x52) {
              if (bVar8 != 0x50) goto LAB_080df418;
              iVar1 = -0x120;
            }
          }
          goto LAB_080df40e;
        }
        if (bVar8 == 0x58) {
          iVar1 = 0x3d;
          goto LAB_080df40e;
        }
        if ((0x57 < bVar8) && ((byte)(bVar8 + 0x96) < 0x10)) {
          iVar1 = bVar8 - 0x40;
          goto LAB_080df40e;
        }
      }
LAB_080df418:
      local_34 = 3;
      goto LAB_080df125;
    }
    if (bVar3 == 0x1b) {
      if (iVar1 != 2) {
        if ((pbVar2[2] == 0x4f) || (pbVar2[2] == 0x5b)) {
          local_34 = 1;
          set_kbd_event(itrm,&ev,0x1b,KBD_MOD_NONE);
        }
        else {
          local_34 = 2;
          set_kbd_event(itrm,&ev,0x1b,KBD_MOD_ALT);
        }
        goto LAB_080df125;
      }
      goto LAB_080df310;
    }
    goto LAB_080df2b2;
  }
  if (iVar1 == 2) {
LAB_080df310:
    local_34 = -1;
    goto LAB_080df125;
  }
  local_2d = pbVar2[2];
  if (local_2d == 0x5b) {
    if (((iVar1 != 3) && (bVar8 = pbVar2[3], 0x40 < bVar8)) && (bVar8 < 0x4d)) {
      local_34 = 4;
      set_kbd_interlink_event(&ev,-0xdf - (uint)bVar8,KBD_MOD_NONE);
      goto LAB_080df125;
    }
    goto LAB_080df310;
  }
  iVar4 = 2;
  bVar3 = local_2d;
  while ((0x2f < bVar3 && (bVar3 < 0x40))) {
    iVar4 = iVar4 + 1;
    if (iVar1 <= iVar4) goto LAB_080df35d;
    bVar3 = pbVar2[iVar4];
  }
  if (iVar1 <= iVar4) {
LAB_080df35d:
    if (iVar1 != 0x40) goto LAB_080df310;
    goto LAB_080df362;
  }
  local_34 = iVar4;
  if ((0x1f < bVar3) && (bVar3 < 0x30)) {
    pbVar5 = pbVar2 + iVar4;
    do {
      local_34 = local_34 + 1;
      if (iVar1 <= local_34) goto LAB_080df35d;
      bVar3 = pbVar5[1];
    } while ((0x1f < bVar3) && (pbVar5 = pbVar5 + 1, bVar3 < 0x30));
  }
  if (0x3e < (byte)(bVar3 - 0x40)) goto LAB_080df362;
  iVar1 = 0;
  if ((byte)(local_2d - 0x30) < 10) {
    iVar1 = 0;
    do {
      iVar1 = (local_2d - 0x30) + iVar1 * 10;
      local_2d = pbVar2[3];
      pbVar2 = pbVar2 + 1;
    } while ((byte)(local_2d - 0x30) < 10);
  }
  if (local_2d == 0x3a) {
    iVar1 = 0;
  }
  if (iVar4 != local_34) {
    local_34 = local_34 + 1;
    goto switchD_080df581_caseD_45;
  }
  local_34 = iVar4 + 1;
  switch(bVar3) {
  case 0x41:
    iVar1 = -0x106;
LAB_080df80a:
    ev.info.mouse.y = 0;
    ev.info.mouse.x = -iVar1;
    piVar6 = &ev;
    for (iVar1 = 4; iVar1 != 0; iVar1 = iVar1 + -1) {
      piVar6->ev = EVENT_INIT;
      piVar6 = (interlink_event *)((int)piVar6 + (uint)bVar8 * -8 + 4);
    }
    break;
  case 0x42:
    ev.info.mouse.x = 0x107;
    ev.info.mouse.y = 0;
    break;
  case 0x43:
    ev.info.mouse.x = 0x105;
    ev.info.mouse.y = 0;
    break;
  case 0x44:
    ev.info.mouse.x = 0x104;
    ev.info.mouse.y = 0;
    break;
  default:
    goto switchD_080df581_caseD_45;
  case 0x46:
  case 0x65:
switchD_080df581_caseD_46:
    ev.info.mouse.x = 0x10b;
    ev.info.mouse.y = 0;
    break;
  case 0x47:
switchD_080df581_caseD_47:
    ev.info.mouse.x = 0x10d;
    ev.info.mouse.y = 0;
    break;
  case 0x48:
switchD_080df581_caseD_48:
    ev.info.mouse.x = 0x10a;
    ev.info.mouse.y = 0;
    break;
  case 0x49:
switchD_080df581_caseD_49:
    ev.info.mouse.x = 0x10c;
    ev.info.mouse.y = 0;
    break;
  case 0x4c:
switchD_080df581_caseD_4c:
    ev.info.mouse.x = 0x108;
    ev.info.mouse.y = 0;
    break;
  case 0x4d:
    local_34 = decode_terminal_mouse_escape_sequence(itrm,&ev,local_34,iVar1);
    goto switchD_080df581_caseD_45;
  case 0x4e:
switchD_080df581_caseD_4e:
    ev.info.mouse.x = 0x121;
    ev.info.mouse.y = 0;
    break;
  case 0x4f:
switchD_080df581_caseD_4f:
    ev.info.mouse.x = 0x122;
    ev.info.mouse.y = 0;
    break;
  case 0x50:
switchD_080df581_caseD_50:
    ev.info.mouse.x = 0x123;
    ev.info.mouse.y = 0;
    break;
  case 0x51:
switchD_080df581_caseD_51:
    ev.info.mouse.x = 0x124;
    ev.info.mouse.y = 0;
    break;
  case 0x52:
    resize_terminal();
    goto switchD_080df581_caseD_45;
  case 0x53:
switchD_080df581_caseD_53:
    ev.info.mouse.x = 0x126;
    ev.info.mouse.y = 0;
    break;
  case 0x54:
switchD_080df581_caseD_54:
    ev.info.mouse.x = 0x127;
    ev.info.mouse.y = 0;
    break;
  case 0x55:
switchD_080df581_caseD_55:
    ev.info.mouse.x = 0x128;
    ev.info.mouse.y = 0;
    break;
  case 0x56:
switchD_080df581_caseD_56:
    ev.info.mouse.x = 0x129;
    ev.info.mouse.y = 0;
    break;
  case 0x57:
switchD_080df581_caseD_57:
    ev.info.mouse.x = 0x12a;
    ev.info.mouse.y = 0;
    break;
  case 0x58:
switchD_080df581_caseD_58:
    ev.info.mouse.x = 299;
    ev.info.mouse.y = 0;
    break;
  case 0x5a:
    ev.info.mouse.x = 0x102;
    ev.info.mouse.y = 1;
    break;
  case 0x7a:
    if (iVar1 == 0xdc) goto switchD_080df581_caseD_46;
    if (iVar1 < 0xdd) {
      if (iVar1 == 0xd6) goto switchD_080df581_caseD_48;
      if (iVar1 == 0xd8) goto switchD_080df581_caseD_49;
    }
    else {
      if (iVar1 == 0xf7) {
        iVar1 = -0x108;
        goto LAB_080df80a;
      }
      if (iVar1 == 0xf9) goto switchD_080df5ba_caseD_3;
      if (iVar1 == 0xde) goto switchD_080df581_caseD_47;
    }
    goto switchD_080df581_caseD_45;
  case 0x7e:
    switch(iVar1) {
    case 1:
    case 7:
      iVar1 = -0x10a;
      goto LAB_080df80a;
    case 2:
      goto switchD_080df581_caseD_4c;
    case 3:
switchD_080df5ba_caseD_3:
      ev.info.mouse.x = 0x109;
      ev.info.mouse.y = 0;
      break;
    case 4:
    case 8:
      goto switchD_080df581_caseD_46;
    case 5:
      goto switchD_080df581_caseD_49;
    case 6:
      goto switchD_080df581_caseD_47;
    default:
      goto switchD_080df581_caseD_45;
    case 0xb:
      ev.info.mouse.x = 0x120;
      ev.info.mouse.y = 0;
      break;
    case 0xc:
      goto switchD_080df581_caseD_4e;
    case 0xd:
      goto switchD_080df581_caseD_4f;
    case 0xe:
      goto switchD_080df581_caseD_50;
    case 0xf:
      goto switchD_080df581_caseD_51;
    case 0x11:
      ev.info.mouse.x = 0x125;
      ev.info.mouse.y = 0;
      break;
    case 0x12:
      goto switchD_080df581_caseD_53;
    case 0x13:
      goto switchD_080df581_caseD_54;
    case 0x14:
      goto switchD_080df581_caseD_55;
    case 0x15:
      goto switchD_080df581_caseD_56;
    case 0x17:
      goto switchD_080df581_caseD_57;
    case 0x18:
      goto switchD_080df581_caseD_58;
    case 0x19:
      ev.info.mouse.x = 0x122;
      ev.info.mouse.y = 1;
      break;
    case 0x1a:
      ev.info.mouse.x = 0x123;
      ev.info.mouse.y = 1;
      break;
    case 0x1c:
      ev.info.mouse.x = 0x124;
      ev.info.mouse.y = 1;
      break;
    case 0x1d:
      ev.info.mouse.x = 0x125;
      ev.info.mouse.y = 1;
      break;
    case 0x1f:
      ev.info.mouse.x = 0x126;
      ev.info.mouse.y = 1;
      break;
    case 0x20:
      ev.info.mouse.x = 0x127;
      ev.info.mouse.y = 1;
      break;
    case 0x21:
      ev.info.mouse.x = 0x128;
      ev.info.mouse.y = 1;
      break;
    case 0x22:
      ev.info.mouse.x = 0x129;
      ev.info.mouse.y = 1;
    }
  }
  ev.info.mouse.button = 0;
  ev.ev = EVENT_KBD;
switchD_080df581_caseD_45:
  if (local_34 == 0) {
LAB_080df362:
    bVar3 = (itrm->in).queue.data[1];
LAB_080df2b2:
    local_34 = 2;
    set_kbd_event(itrm,&ev,(uint)bVar3,KBD_MOD_ALT);
  }
LAB_080df125:
  if (ev.ev == EVENT_MOUSE) {
LAB_080df130:
    itrm_queue_event(itrm,(uchar *)&ev,0x10);
  }
  else {
LAB_080df12a:
    if (ev.info.mouse.x != -1) goto LAB_080df130;
  }
  if (local_34 == -1) {
    install_timer(&itrm->timer,200,kbd_timeout,itrm);
    return 0;
  }
LAB_080df178:
  if (assert_failed == 0) {
    assert_failed = (int)((itrm->in).queue.len < local_34);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x491;
      elinks_internal((uchar *)"assertion itrm->in.queue.len >= el failed: event queue underflow");
      if (assert_failed != 0) goto LAB_080df1f0;
    }
    __n = (itrm->in).queue.len - local_34;
    (itrm->in).queue.len = __n;
    if ((__n != 0) &&
       (__dest = (itrm->in).queue.data, memmove(__dest,__dest + local_34,__n),
       0x3f < (itrm->in).queue.len)) {
      return local_34;
    }
  }
  else {
LAB_080df1f0:
    assert_failed = 0;
    (itrm->in).queue.len = 0;
  }
  handle_itrm_stdin(itrm);
  return local_34;
}



// WARNING: Unknown calling convention

void in_kbd(itrm *itrm)

{
  int iVar1;
  ssize_t sVar2;
  int r;
  uchar *fmt;
  
  iVar1 = can_read((itrm->in).std);
  if (iVar1 != 0) {
    kill_timer(&itrm->timer);
    iVar1 = (itrm->in).queue.len;
    if (0x3f < iVar1) {
      unhandle_itrm_stdin(itrm);
      do {
        iVar1 = process_queue(itrm);
      } while (iVar1 != 0);
      return;
    }
    sVar2 = read((itrm->in).std,(itrm->in).queue.data + iVar1,0x40 - iVar1);
    if (sVar2 < 1) {
      free_itrm(itrm);
      return;
    }
    iVar1 = sVar2 + (itrm->in).queue.len;
    (itrm->in).queue.len = iVar1;
    if (0x40 < iVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 0x4ba;
      fmt = gettext((uchar *)"Too many bytes read from the itrm!");
      elinks_error(fmt);
      (itrm->in).queue.len = 0x40;
    }
    do {
      iVar1 = process_queue(itrm);
      if (iVar1 == 0) {
        return;
      }
      iVar1 = process_queue(itrm);
    } while (iVar1 != 0);
  }
  return;
}



// WARNING: Unknown calling convention

void kbd_timeout(itrm *itrm)

{
  byte *pbVar1;
  uchar *__dest;
  int iVar2;
  size_t __n;
  byte bVar3;
  int el;
  interlink_event ev;
  
  itrm->timer = (timer_id_T)0x0;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)((itrm->in).queue.len == 0);
  if (assert_failed == 0) {
    bVar3 = itrm->field_0x74;
  }
  else {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x3fd;
    elinks_internal((uchar *)"assertion itrm->in.queue.len failed: timeout on empty queue");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    bVar3 = itrm->field_0x74;
  }
  assert_failed = bVar3 & 1;
  if ((bVar3 & 1) != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 0x3fe;
    elinks_internal((uchar *)"assertion !itrm->blocked failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar2 = can_read((itrm->in).std);
  if (iVar2 != 0) {
    in_kbd(itrm);
    return;
  }
  if ((itrm->in).queue.len < 2) {
    bVar3 = *(itrm->in).queue.data;
  }
  else {
    pbVar1 = (itrm->in).queue.data;
    bVar3 = *pbVar1;
    if (bVar3 == 0x1b) {
      iVar2 = 2;
      set_kbd_event(itrm,&ev,(uint)pbVar1[1],KBD_MOD_ALT);
      goto LAB_080dfa92;
    }
  }
  iVar2 = 1;
  set_kbd_event(itrm,&ev,(uint)bVar3,KBD_MOD_NONE);
LAB_080dfa92:
  itrm_queue_event(itrm,(uchar *)&ev,0x10);
  __n = (itrm->in).queue.len - iVar2;
  (itrm->in).queue.len = __n;
  if (__n != 0) {
    __dest = (itrm->in).queue.data;
    memmove(__dest,__dest + iVar2,__n);
  }
  do {
    iVar2 = process_queue(itrm);
  } while (iVar2 != 0);
  return;
}



// WARNING: Unknown calling convention

int decode_terminal_mouse_escape_sequence(itrm *itrm,interlink_event *ev,int el,int v)

{
  uchar *puVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  
  iVar2 = (itrm->in).queue.len - el;
  if (iVar2 < 3) {
    return -1;
  }
  if (v == 5) {
    if (decode_terminal_mouse_escape_sequence::xterm_button == -1) {
      decode_terminal_mouse_escape_sequence::xterm_button = 0;
    }
    if (iVar2 < 5) {
      return -1;
    }
    puVar1 = (itrm->in).queue.data;
    uVar5 = (uint)puVar1[el + 2] * 0x80 + -0x10a1 + (uint)puVar1[el + 1];
    if ((uVar5 & 0x2000) != 0) {
      uVar5 = 0;
    }
    uVar6 = (uint)puVar1[el + 4] * 0x80 + -0x10a1 + (uint)puVar1[el + 3];
    if ((uVar6 & 0x2000) != 0) {
      uVar6 = 0;
    }
    uVar4 = decode_terminal_mouse_escape_sequence::xterm_button ^ puVar1[el] - 0x20;
    if (uVar4 == 1) {
      uVar3 = 0x20;
      if ((decode_terminal_mouse_escape_sequence::xterm_button & 1U) == 0) {
LAB_080dfd2a:
        uVar3 = 0;
      }
    }
    else if ((int)uVar4 < 2) {
      uVar3 = 0x40;
      if (uVar4 != 0) goto LAB_080dfd2a;
    }
    else if (uVar4 == 2) {
      uVar3 = (-(uint)((decode_terminal_mouse_escape_sequence::xterm_button & 2U) == 0) & 0xffffffe0
              ) + 0x21;
    }
    else {
      if (uVar4 != 4) goto LAB_080dfd2a;
      uVar3 = (-(uint)((decode_terminal_mouse_escape_sequence::xterm_button & 4U) == 0) & 0xffffffe0
              ) + 0x22;
    }
    iVar2 = el + 5;
    decode_terminal_mouse_escape_sequence::xterm_button = puVar1[el] - 0x20;
    goto LAB_080dfc39;
  }
  puVar1 = (itrm->in).queue.data;
  uVar5 = (uint)puVar1[el];
  uVar3 = uVar5 & 7;
  if (uVar3 == 3) {
    if (decode_terminal_mouse_escape_sequence::xterm_button != -1) {
      uVar3 = decode_terminal_mouse_escape_sequence::xterm_button | 0x20;
    }
    if ((uVar5 & 0x60) != 0x60) goto LAB_080dfc17;
LAB_080dfc60:
    uVar3 = 4 - ((puVar1[el] & 1) == 0);
    decode_terminal_mouse_escape_sequence::xterm_button = uVar3;
  }
  else {
    if ((uVar5 & 0x60) == 0x60) goto LAB_080dfc60;
LAB_080dfc17:
    decode_terminal_mouse_escape_sequence::xterm_button = -1;
    if ((uVar3 & 0x20) == 0) {
      decode_terminal_mouse_escape_sequence::xterm_button = uVar3 & 7;
    }
  }
  iVar2 = el + 3;
  uVar5 = puVar1[el + 1] - 0x21;
  uVar6 = puVar1[el + 2] - 0x21;
LAB_080dfc39:
  ev->ev = EVENT_MOUSE;
  (ev->info).mouse.x = uVar5;
  (ev->info).mouse.y = uVar6;
  (ev->info).mouse.button = uVar3;
  return iVar2;
}



// WARNING: Unknown calling convention

void send_mouse_done_sequence(int h)

{
  hard_write(h,"\x1b[?9l",5);
  hard_write(h,"\x1b[?1000l",8);
  return;
}



// WARNING: Unknown calling convention

void disable_mouse(void)

{
  int h_00;
  int iVar1;
  int h;
  
  h_00 = get_output_handle();
  if (mouse_enabled == 0) {
    return;
  }
  unhandle_mouse(ditrm->mouse_h);
  iVar1 = is_xterm();
  if (iVar1 != 0) {
    send_mouse_done_sequence(h_00);
  }
  mouse_enabled = 0;
  return;
}



// WARNING: Unknown calling convention

void send_mouse_init_sequence(int h)

{
  hard_write(h,"\x1b[?9h",5);
  hard_write(h,"\x1b[?1000h",8);
  return;
}



// WARNING: Unknown calling convention

void enable_mouse(void)

{
  itrm *piVar1;
  int h_00;
  int iVar2;
  void *pvVar3;
  int h;
  
  h_00 = get_output_handle();
  if (mouse_enabled != 0) {
    return;
  }
  iVar2 = is_xterm();
  if (iVar2 != 0) {
    send_mouse_init_sequence(h_00);
  }
  piVar1 = ditrm;
  pvVar3 = handle_mouse(0,itrm_queue_event,ditrm);
  piVar1->mouse_h = pvVar3;
  mouse_enabled = 1;
  return;
}



// WARNING: Unknown calling convention

void toggle_mouse(void)

{
  if (mouse_enabled == 0) {
    enable_mouse();
    return;
  }
  disable_mouse();
  return;
}



// WARNING: Unknown calling convention

void done_screen(terminal_screen *screen)

{
  void *p;
  
  if (screen->image != (screen_char *)0x0) {
    mem_free(screen->image);
  }
  mem_free(screen);
  return;
}



// WARNING: Unknown calling convention

void done_screen_drivers(module *xxx)

{
  void **ppvVar1;
  xlist_head *head;
  list_head_elinks *p;
  list_head_elinks *plVar2;
  list_head_elinks *plVar3;
  xlist_head *next;
  bool bVar4;
  
  plVar3 = (list_head_elinks *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != &active_screen_drivers) {
    do {
      plVar3 = (list_head_elinks *)plVar3->next;
    } while (plVar3 != &active_screen_drivers);
  }
  plVar2 = (list_head_elinks *)active_screen_drivers.prev;
  if ((list_head_elinks *)active_screen_drivers.prev != plVar3) {
    do {
      ppvVar1 = &plVar2->prev;
      plVar2 = (list_head_elinks *)*ppvVar1;
    } while ((list_head_elinks *)*ppvVar1 != plVar3);
  }
                    // WARNING: Load size is inaccurate
  plVar2 = *active_screen_drivers.next;
  p = (list_head_elinks *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != plVar3) {
    do {
      plVar2->prev = p->prev;
      *(void **)p->prev = p->next;
      mem_free(p);
      bVar4 = plVar2 != plVar3;
      p = plVar2;
      plVar2 = (list_head_elinks *)plVar2->next;
    } while (bVar4);
  }
  return;
}



// WARNING: Unknown calling convention

void resize_screen(terminal *term,int width,int height)

{
  size_t size;
  int iVar1;
  screen_char *__s;
  terminal_screen *screen;
  
  if (assert_failed == 0) {
    if ((term == (terminal *)0x0) || (term->screen == (terminal_screen *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
      errline = 0x49a;
      elinks_internal((uchar *)"assertion term && term->screen failed!");
      screen = term->screen;
      if (assert_failed != 0) goto joined_r0x080e00c3;
    }
    else {
      screen = term->screen;
    }
    assert_failed = -(width >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
      errline = 0x49e;
      elinks_internal((uchar *)"assertion width >= 0 failed!");
      if (assert_failed != 0) goto joined_r0x080e00c3;
    }
    assert_failed = -(height >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
      errline = 0x49f;
      elinks_internal((uchar *)"assertion height >= 0 failed!");
    }
  }
  else {
    screen = term->screen;
  }
joined_r0x080e00c3:
  if (width * height != 0) {
    iVar1 = width * height;
    __s = (screen_char *)mem_realloc(screen->image,iVar1 * 0x10);
    if (__s != (screen_char *)0x0) {
      screen->image = __s;
      screen->last_image = __s + iVar1;
      memset(__s,0,iVar1 * 8);
      memset(screen->last_image,0xff,iVar1 * 8);
      term->height = height;
      term->width = width;
      if (0 < screen->dirty_from) {
        screen->dirty_from = 0;
      }
      if (screen->dirty_to < height) {
        screen->dirty_to = height;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

terminal_screen * init_screen(void)

{
  terminal_screen *ptVar1;
  terminal_screen *screen;
  
  ptVar1 = (terminal_screen *)mem_calloc(1,0x20);
  if (ptVar1 != (terminal_screen *)0x0) {
    ptVar1->lcx = -1;
    ptVar1->lcy = -1;
  }
  return ptVar1;
}



// WARNING: Unknown calling convention

void beep_terminal(terminal *term)

{
  hard_write(term->fdout,"\a",1);
  return;
}



// WARNING: Unknown calling convention

void erase_screen(terminal *term)

{
  int iVar1;
  
  if ((term->field_0x38 & 1) != 0) {
    iVar1 = is_blocked();
    if (iVar1 != 0) {
      return;
    }
    want_draw();
  }
  hard_write(term->fdout,"\x1b[2J\x1b[1;1H",10);
  if ((term->field_0x38 & 1) == 0) {
    return;
  }
  done_draw();
  return;
}



// WARNING: Unknown calling convention

void set_screen_driver_opt(screen_driver *driver,option_elinks *term_spec)

{
  undefined *puVar1;
  screen_driver_opt *psVar2;
  term_mode_type tVar3;
  option_value *poVar4;
  int iVar5;
  int iVar6;
  string *psVar7;
  int cp;
  list_head_elinks *local_20;
  
  poVar4 = get_opt_();
  iVar6 = poVar4->number;
  poVar4 = get_opt_();
  local_20 = poVar4->tree;
  psVar2 = screen_driver_opts[driver->type];
  (driver->opt).charsets[0] = psVar2->charsets[0];
  (driver->opt).charsets[1] = psVar2->charsets[1];
  (driver->opt).frame = psVar2->frame;
  (driver->opt).frame_seqs = psVar2->frame_seqs;
  (driver->opt).underline = psVar2->underline;
  (driver->opt).color_mode = psVar2->color_mode;
  *(undefined4 *)&(driver->opt).field_0x18 = *(undefined4 *)&psVar2->field_0x18;
  iVar5 = is_cp_utf8(iVar6);
  if (iVar5 == 0) {
    puVar1 = &(driver->opt).field_0x18;
    *puVar1 = *puVar1 & 0xfd;
  }
  else {
    puVar1 = &(driver->opt).field_0x18;
    *puVar1 = *puVar1 | 2;
    local_20 = (list_head_elinks *)0x1;
  }
  poVar4 = get_opt_();
  (driver->opt).color_mode = (color_mode)*poVar4;
  poVar4 = get_opt_();
  (driver->opt).field_0x18 = (driver->opt).field_0x18 & 0xfe | (byte)poVar4->color & 1;
  poVar4 = get_opt_();
  psVar7 = (string *)0x0;
  if (poVar4->tree != (list_head_elinks *)0x0) {
    psVar7 = underline_seqs;
  }
  (driver->opt).underline = psVar7;
  if (local_20 == (list_head_elinks *)0x0) {
    tVar3 = driver->type;
    (driver->opt).charsets[0] = -1;
    if (tVar3 == TERM_LINUX) {
      poVar4 = get_opt_();
      if (poVar4->tree != (list_head_elinks *)0x0) {
        (driver->opt).frame = frame_restrict;
      }
    }
    else if (tVar3 != TERM_FREEBSD) {
      if (tVar3 != TERM_VT100) {
        return;
      }
      (driver->opt).frame = "aaaxuuukkuxkjjjkmvwtqnttmlvwtqnvvwwmmllnnjla    ";
      return;
    }
    poVar4 = get_opt_();
    if (poVar4->tree != (list_head_elinks *)0x0) {
      (driver->opt).frame_seqs = m11_hack_frame_seqs;
    }
    return;
  }
  tVar3 = driver->type;
  (driver->opt).charsets[0] = iVar6;
  (driver->opt).frame_seqs = (string *)0x0;
  if (tVar3 == TERM_LINUX) {
    poVar4 = get_opt_();
    if (poVar4->tree != (list_head_elinks *)0x0) {
      (driver->opt).frame = frame_restrict;
    }
  }
  else {
    if (tVar3 != TERM_FREEBSD) {
      if (tVar3 == TERM_VT100) {
        (driver->opt).frame = frame_vt100_u;
        iVar6 = get_cp_index((uchar *)"cp437");
        (driver->opt).charsets[1] = iVar6;
        return;
      }
      if (tVar3 != TERM_KOI8) {
        if (((driver->opt).field_0x18 & 2) == 0) {
          (driver->opt).charsets[1] = iVar6;
          return;
        }
        iVar6 = get_cp_index("US-ASCII");
        (driver->opt).charsets[1] = iVar6;
        return;
      }
      iVar6 = get_cp_index("koi8-r");
      (driver->opt).charsets[1] = iVar6;
      return;
    }
    (driver->opt).frame = frame_freebsd_u;
  }
  iVar6 = get_cp_index((uchar *)"cp437");
  (driver->opt).charsets[1] = iVar6;
  return;
}



// WARNING: Unknown calling convention

int screen_driver_change_hook(session *ses,option_elinks *term_spec,option_elinks *changed)

{
  list_head_elinks *plVar1;
  uchar *__s2;
  option_value *poVar2;
  int iVar3;
  screen_driver *driver;
  screen_driver *driver_00;
  term_mode_type type;
  uchar *name;
  
  poVar2 = get_opt_();
  plVar1 = poVar2->tree;
  __s2 = term_spec->name;
  driver_00 = (screen_driver *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next != &active_screen_drivers) {
    do {
      if (((list_head_elinks *)driver_00->type == plVar1) &&
         (iVar3 = strcmp((char *)driver_00->name,(char *)__s2), iVar3 == 0)) {
        set_screen_driver_opt(driver_00,term_spec);
        return 0;
      }
      driver_00 = driver_00->next;
    } while (driver_00 != (screen_driver *)&active_screen_drivers);
  }
  return 0;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Unknown calling convention

void redraw_screen(terminal *term)

{
  ulong uVar1;
  uchar **ppuVar2;
  ulong uVar3;
  uchar uVar4;
  byte bVar5;
  byte bVar6;
  terminal_screen *ptVar7;
  list_head_elinks *plVar8;
  undefined *puVar9;
  terminal_screen *ptVar10;
  ulong uVar11;
  screen_driver *psVar12;
  byte bVar13;
  void *pvVar14;
  uchar bgcolor;
  byte bVar16;
  option_value *poVar17;
  size_t sVar18;
  string *psVar19;
  int y;
  uchar uVar15;
  uint uVar20;
  uchar *puVar21;
  int prev_y;
  int iVar22;
  int iVar23;
  uint uVar24;
  uchar *puVar25;
  screen_driver *driver_00;
  ulong uVar26;
  byte bVar27;
  ulong uVar28;
  size_t newsize;
  int y_1;
  size_t newsize_2;
  uint uVar29;
  int seq_pos_1;
  int color_len_1;
  int seq_pos;
  int iVar30;
  int color_len;
  int seq_pos_3;
  int color_len_3;
  int seq_pos_2;
  int color_len_2;
  byte bVar31;
  int charset;
  size_t newsize_1;
  int charset_1;
  byte bVar32;
  byte bVar33;
  int charset_2;
  screen_driver *driver;
  screen_char *psVar34;
  screen_char *prev_pos;
  screen_char *prev_pos_1;
  screen_driver *psVar35;
  byte bVar36;
  term_mode_type type;
  int in_GS_OFFSET;
  bool bVar37;
  byte local_bd;
  ulong local_98;
  screen_char *local_88;
  ulong local_84;
  uchar *local_7c;
  screen_char *local_78;
  screen_char *local_74;
  byte local_64;
  unicode_val_T local_60;
  string image;
  uchar code_1 [6];
  uint local_40;
  uchar code [25];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  ptVar7 = term->screen;
  if (((ptVar7 == (terminal_screen *)0x0) || (ptVar7->dirty_to < ptVar7->dirty_from)) ||
     (((term->field_0x38 & 1) != 0 && (iVar23 = is_blocked(), iVar23 != 0)))) goto LAB_080e0cb5;
  poVar17 = get_opt_();
  plVar8 = poVar17->tree;
  puVar21 = term->spec->name;
  sVar18 = strlen((char *)puVar21);
  pvVar14 = active_screen_drivers.next;
  driver_00 = (screen_driver *)active_screen_drivers.next;
  if ((list_head_elinks *)active_screen_drivers.next == &active_screen_drivers) {
    psVar35 = (screen_driver *)&active_screen_drivers;
  }
  else {
    do {
      if ((plVar8 == (list_head_elinks *)driver_00->type) &&
         (iVar23 = strcmp((char *)driver_00->name,(char *)puVar21), iVar23 == 0)) {
        if ((screen_driver *)pvVar14 != driver_00) {
          driver_00->next->prev = driver_00->prev;
          driver_00->prev->next = driver_00->next;
          driver_00->prev = (screen_driver *)&active_screen_drivers;
          driver_00->next = (screen_driver *)active_screen_drivers.next;
          active_screen_drivers.next = driver_00;
          driver_00->next->prev = driver_00;
        }
        bVar5 = term->field_0x38;
        bVar16 = (driver_00->opt).field_0x18 & 2;
        term->field_0x38 = bVar5 & 0xfd | bVar16;
        term->field_0x38 = bVar5 & 0xf9 | bVar16 | ((driver_00->opt).charsets[0] != -1) << 2;
        goto LAB_080e073b;
      }
      driver_00 = driver_00->next;
      psVar35 = driver_00;
    } while (driver_00 != (screen_driver *)&active_screen_drivers);
  }
  driver_00 = (screen_driver *)mem_alloc(sVar18 + 0x2c);
  if (driver_00 == (screen_driver *)0x0) goto LAB_080e0cb5;
  psVar12 = psVar35->next;
  driver_00->prev = psVar35;
  driver_00->next = psVar12;
  psVar35->next = driver_00;
  driver_00->next->prev = driver_00;
  driver_00->type = (term_mode_type)plVar8;
  set_screen_driver_opt(driver_00,term->spec);
  memcpy(driver_00->name,term->spec->name,sVar18 + 1);
  term->spec->change_hook = screen_driver_change_hook;
  bVar5 = term->field_0x38;
  bVar16 = (driver_00->opt).field_0x18 & 2;
  term->field_0x38 = bVar5 & 0xfd | bVar16;
  term->field_0x38 = bVar5 & 0xf9 | bVar16 | ((driver_00->opt).charsets[0] != -1) << 2;
LAB_080e073b:
  psVar19 = init_string(&image);
  if (psVar19 == (string *)0x0) goto LAB_080e0cb5;
  puVar9 = (undefined *)(driver_00->opt).color_mode;
  if (puVar9 == (undefined *)0x2) {
    ptVar10 = term->screen;
    uVar11 = ptVar10->dirty_from;
    iVar23 = term->width;
    uVar1 = iVar23 - 1;
    uVar28 = term->height - 1;
    if ((int)uVar28 < ptVar10->dirty_to) {
      ptVar10->dirty_to = uVar28;
    }
    if (ptVar10->dirty_to < (int)uVar11) goto LAB_080e26b5;
    uVar26 = 0xffffffff;
    bVar16 = 0xff;
    local_88 = ptVar10->last_image + iVar23 * uVar11;
    local_74 = ptVar10->image + iVar23 * uVar11;
    psVar34 = (screen_char *)0x0;
    bVar5 = 0;
    bVar33 = 0xff;
    uVar15 = 0xff;
    do {
      local_98 = uVar11 + 1;
      if ((-1 < (int)uVar1) && ((uVar28 != uVar11 || (iVar23 != 1)))) {
        local_84 = 1;
LAB_080e1f18:
        if (local_74->color[1] == local_88->color[1]) {
          if (local_74->color[0] == local_88->color[0]) {
            local_60 = local_74->data;
            if ((local_60 != local_88->data) || (local_74->attr != local_88->attr))
            goto LAB_080e2632;
          }
          else {
            local_60 = local_74->data;
LAB_080e2632:
            if (((0x20 < local_60) || (0x20 < local_88->data)) || (local_74->attr != local_88->attr)
               ) goto LAB_080e1f2e;
          }
        }
        else {
LAB_080e1f2e:
          if ((uVar11 != uVar26) || (psVar34 + 10 <= local_74)) {
            local_40 = 2;
            code[0] = '\x1b';
            code[1] = '[';
            iVar22 = elinks_ulongcat(code,&local_40,local_98,10,'\0',10,0);
            psVar34 = local_74;
            if (-1 < iVar22) {
              code[local_40] = ';';
              local_40 = local_40 + 1;
              iVar22 = elinks_ulongcat(code,&local_40,local_84,10,'\0',10,0);
              if (-1 < iVar22) {
                uVar20 = local_40 + 1;
                code[local_40] = 'H';
                local_40 = uVar20;
                add_bytes_to_string__(&image,code,uVar20);
              }
            }
LAB_080e1f58:
            do {
              bVar32 = (driver_00->opt).field_0x18;
              bVar31 = psVar34->attr;
              if (((bVar32 & 2) == 0) || (psVar34->data != 0xfffffffd)) {
                bVar6 = bVar5 ^ bVar31;
                if (bVar6 != 0) {
                  if (((char)bVar6 < '\0') &&
                     (psVar19 = (driver_00->opt).frame_seqs, psVar19 != (string *)0x0)) {
                    bVar16 = bVar31 >> 7;
                    psVar19 = psVar19 + bVar16;
                    add_bytes_to_string__(&image,psVar19->source,psVar19->length);
                    bVar31 = psVar34->attr;
                  }
                  if (((bVar6 & 0x20) != 0) &&
                     (psVar19 = (driver_00->opt).underline, psVar19 != (string *)0x0)) {
                    ppuVar2 = (uchar **)((int)&psVar19->source + (bVar31 >> 2 & 8));
                    add_bytes_to_string__(&image,*ppuVar2,(int)ppuVar2[1]);
                    bVar31 = psVar34->attr;
                  }
                  bVar5 = bVar31;
                  if ((bVar6 & 8) != 0) {
                    if ((bVar31 & 8) == 0) {
                      bVar33 = psVar34->color[0] + 1;
                    }
                    else {
                      add_bytes_to_string__(&image,"\x1b[1m",4);
                      bVar5 = psVar34->attr;
                    }
                  }
                  bVar32 = (driver_00->opt).field_0x18;
                }
                if (((bVar32 & 2) != 0) && (psVar34->data == 0xfffffffd)) goto LAB_080e2360;
                bVar31 = psVar34->color[0];
                if (bVar33 == bVar31) {
                  uVar4 = psVar34->color[1];
                  if (uVar4 != uVar15) goto LAB_080e200a;
                  bVar6 = psVar34->attr;
                  uVar20 = psVar34->data;
                  uVar15 = uVar4;
                }
                else {
                  uVar4 = psVar34->color[1];
LAB_080e200a:
                  iVar22 = 0;
                  do {
                    iVar30 = iVar22;
                    iVar22 = iVar30 + 1;
                  } while ((&DAT_081339b1)[iVar30] != '%');
                  add_bytes_to_string__(&image,"\x1b[0;38;5;%dm",iVar30 + 1);
                  if (bVar31 < 10) {
                    local_78 = (screen_char *)(code_1 + 2);
                    iVar22 = 1;
                    local_bd = bVar31;
                  }
                  else {
                    if (bVar31 < 100) {
                      local_78 = (screen_char *)(code_1 + 1);
                      iVar22 = 2;
                      bVar33 = bVar31;
                    }
                    else if (bVar31 < 200) {
                      local_78 = (screen_char *)code_1;
                      iVar22 = 3;
                      code_1[0] = 0x31;
                      bVar33 = bVar31 + 0x9c;
                    }
                    else {
                      local_78 = (screen_char *)code_1;
                      iVar22 = 3;
                      code_1[0] = 0x32;
                      bVar33 = bVar31 + 0x38;
                    }
                    code_1[1] = bVar33 / 10 + 0x30;
                    local_bd = bVar33 % 10;
                  }
                  code_1[2] = local_bd + 0x30;
                  add_bytes_to_string__(&image,(uchar *)local_78,iVar22);
                  add_bytes_to_string__(&image,(uchar *)(";38;5;%dm" + iVar30),0xc - (iVar30 + 3));
                  if (((driver_00->opt).field_0x18 & 1) == 0) {
                    local_64 = psVar34->color[1];
LAB_080e20e2:
                    iVar22 = 0;
                    do {
                      iVar30 = iVar22;
                      iVar22 = iVar30 + 1;
                    } while ((&DAT_081339be)[iVar30] != '%');
                    add_bytes_to_string__(&image,"\x1b[48;5;%dm",iVar30 + 1);
                    if (local_64 < 10) {
                      local_7c = code_1 + 2;
                      iVar22 = 1;
                      local_bd = local_64;
                    }
                    else {
                      iVar22 = 2;
                      local_7c = code_1 + 1;
                      if (99 < local_64) {
                        if (local_64 < 200) {
                          local_64 = local_64 + 0x9c;
                          iVar22 = 3;
                          local_7c = code_1;
                          code_1[0] = 0x31;
                        }
                        else {
                          local_7c = code_1;
                          iVar22 = 3;
                          code_1[0] = 0x32;
                          local_64 = local_64 + 0x38;
                        }
                      }
                      local_bd = local_64 % 10;
                      code_1[1] = local_64 / 10 + 0x30;
                    }
                    code_1[2] = local_bd + 0x30;
                    add_bytes_to_string__(&image,local_7c,iVar22);
                    add_bytes_to_string__(&image,(uchar *)("8;5;%dm" + iVar30),10 - (iVar30 + 3));
                  }
                  else {
                    local_64 = psVar34->color[1];
                    if (local_64 != 0) goto LAB_080e20e2;
                  }
                  bVar6 = psVar34->attr;
                  if ((bVar6 & 8) != 0) {
                    add_bytes_to_string__(&image,"\x1b[1m",4);
                    bVar6 = psVar34->attr;
                  }
                  bVar33 = bVar31;
                  uVar15 = uVar4;
                  if ((bVar6 & 0x20) != 0) {
                    psVar19 = (driver_00->opt).underline;
                    if (psVar19 == (string *)0x0) {
                      uVar20 = psVar34->data;
                      bVar32 = (driver_00->opt).field_0x18;
                      goto LAB_080e2207;
                    }
                    add_bytes_to_string__(&image,psVar19[1].source,psVar19[1].length);
                    bVar6 = psVar34->attr;
                  }
                  uVar20 = psVar34->data;
                  bVar32 = (driver_00->opt).field_0x18;
                }
              }
              else {
LAB_080e2360:
                bVar6 = psVar34->attr;
                uVar20 = 0xfffffffd;
              }
LAB_080e2207:
              if (((((bVar6 & 0x80) != 0) && (puVar21 = (driver_00->opt).frame, 0xaf < uVar20)) &&
                  (puVar21 != (uchar *)0x0)) && (uVar20 < 0xe0)) {
                uVar20 = (uint)puVar21[uVar20 - 0xb0];
              }
              if ((bVar32 & 2) == 0) {
                if ((driver_00->opt).charsets[0] == -1) {
                  if (((bVar6 & 0x80) == 0) && ((uVar20 == 0x7f || (uVar20 < 0x20)))) {
                    add_char_to_string(&image,' ');
                  }
                  else {
                    add_char_to_string(&image,(uchar)uVar20);
                  }
                }
                else if (((bVar6 & 0x80) == 0) && ((uVar20 == 0x7f || (uVar20 < 0x20)))) {
                  add_char_to_string(&image,' ');
                }
                else {
                  puVar21 = cp2utf8(*(int *)((int)(driver_00->opt).charsets +
                                            (~-(uint)((bVar6 & 0x80) == 0) & 4)),uVar20);
                  add_to_string(&image,puVar21);
                }
              }
              else {
                if ((bVar6 & 0x80) != 0) {
                  uVar20 = cp2u((driver_00->opt).charsets[1],(uchar)uVar20);
                }
                if (uVar20 != 0xfffffffd) {
                  if ((0x5e < uVar20 - 0x20) && (uVar20 < 0xa0)) {
                    uVar20 = 0x20;
                  }
                  puVar21 = encode_utf8(uVar20);
                  add_to_string(&image,puVar21);
                }
              }
              if (local_74 < psVar34 + 1) goto LAB_080e22e4;
              psVar34 = psVar34 + 1;
            } while( true );
          }
          uVar26 = uVar11;
          if (psVar34 <= local_74) goto LAB_080e1f58;
        }
        goto LAB_080e22f1;
      }
LAB_080e232a:
      uVar11 = local_98;
    } while ((int)local_98 <= ptVar10->dirty_to);
  }
  else {
    if ((int)puVar9 < 3) {
      if (puVar9 == (undefined *)0xffffffff) {
LAB_080e0cfe:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
        errline = 0x443;
        elinks_internal((uchar *)"Invalid color mode (%d).",(driver_00->opt).color_mode);
        goto LAB_080e0cb5;
      }
    }
    else {
      if (puVar9 == (undefined *)0x3) {
        ptVar10 = term->screen;
        iVar23 = term->width;
        uVar11 = ptVar10->dirty_from;
        uVar1 = iVar23 - 1;
        uVar26 = term->height - 1;
        uVar28 = ptVar10->dirty_to;
        if ((int)uVar26 < ptVar10->dirty_to) {
          ptVar10->dirty_to = uVar26;
          uVar28 = uVar26;
        }
        if ((int)uVar28 < (int)uVar11) goto LAB_080e26b5;
        uVar28 = 0xffffffff;
        bVar16 = 0xff;
        bVar5 = 0;
        local_88 = ptVar10->last_image + iVar23 * uVar11;
        local_74 = ptVar10->image + iVar23 * uVar11;
        psVar34 = (screen_char *)0x0;
        bVar33 = 0xff;
        uVar15 = 0xff;
        do {
          local_98 = uVar11 + 1;
          if ((-1 < (int)uVar1) && ((uVar26 != uVar11 || (iVar23 != 1)))) {
            local_84 = 1;
LAB_080e16a0:
            if (local_74->color[1] == local_88->color[1]) {
              if (local_74->color[0] == local_88->color[0]) {
                local_60 = local_74->data;
                if ((local_60 != local_88->data) || (local_74->attr != local_88->attr))
                goto LAB_080e1dba;
              }
              else {
                local_60 = local_74->data;
LAB_080e1dba:
                if (((0x20 < local_60) || (0x20 < local_88->data)) ||
                   (local_74->attr != local_88->attr)) goto LAB_080e16b6;
              }
            }
            else {
LAB_080e16b6:
              if ((uVar28 != uVar11) || (psVar34 + 10 <= local_74)) {
                local_40 = 2;
                code[0] = '\x1b';
                code[1] = '[';
                iVar22 = elinks_ulongcat(code,&local_40,local_98,10,'\0',10,0);
                psVar34 = local_74;
                if (-1 < iVar22) {
                  code[local_40] = ';';
                  local_40 = local_40 + 1;
                  iVar22 = elinks_ulongcat(code,&local_40,local_84,10,'\0',10,0);
                  if (-1 < iVar22) {
                    uVar20 = local_40 + 1;
                    code[local_40] = 'H';
                    local_40 = uVar20;
                    add_bytes_to_string__(&image,code,uVar20);
                  }
                }
LAB_080e16e0:
                do {
                  bVar32 = (driver_00->opt).field_0x18;
                  bVar31 = psVar34->attr;
                  if (((bVar32 & 2) == 0) || (psVar34->data != 0xfffffffd)) {
                    bVar6 = bVar5 ^ bVar31;
                    if (bVar6 != 0) {
                      if (((char)bVar6 < '\0') &&
                         (psVar19 = (driver_00->opt).frame_seqs, psVar19 != (string *)0x0)) {
                        bVar16 = bVar31 >> 7;
                        psVar19 = psVar19 + bVar16;
                        add_bytes_to_string__(&image,psVar19->source,psVar19->length);
                        bVar31 = psVar34->attr;
                      }
                      if (((bVar6 & 0x20) != 0) &&
                         (psVar19 = (driver_00->opt).underline, psVar19 != (string *)0x0)) {
                        ppuVar2 = (uchar **)((int)&psVar19->source + (bVar31 >> 2 & 8));
                        add_bytes_to_string__(&image,*ppuVar2,(int)ppuVar2[1]);
                        bVar31 = psVar34->attr;
                      }
                      bVar5 = bVar31;
                      if ((bVar6 & 8) != 0) {
                        if ((bVar31 & 8) == 0) {
                          bVar33 = psVar34->color[0] + 1;
                        }
                        else {
                          add_bytes_to_string__(&image,"\x1b[1m",4);
                          bVar5 = psVar34->attr;
                        }
                      }
                      bVar32 = (driver_00->opt).field_0x18;
                    }
                    if (((bVar32 & 2) != 0) && (psVar34->data == 0xfffffffd)) goto LAB_080e1ae8;
                    bVar31 = psVar34->color[0];
                    if (bVar33 == bVar31) {
                      uVar4 = psVar34->color[1];
                      if (uVar4 != uVar15) goto LAB_080e1792;
                      bVar6 = psVar34->attr;
                      uVar20 = psVar34->data;
                      uVar15 = uVar4;
                    }
                    else {
                      uVar4 = psVar34->color[1];
LAB_080e1792:
                      iVar22 = 0;
                      do {
                        iVar30 = iVar22;
                        iVar22 = iVar30 + 1;
                      } while ((&DAT_081339b1)[iVar30] != '%');
                      add_bytes_to_string__(&image,"\x1b[0;38;5;%dm",iVar30 + 1);
                      if (bVar31 < 10) {
                        local_78 = (screen_char *)(code_1 + 2);
                        iVar22 = 1;
                        local_bd = bVar31;
                      }
                      else {
                        if (bVar31 < 100) {
                          local_78 = (screen_char *)(code_1 + 1);
                          iVar22 = 2;
                          bVar33 = bVar31;
                        }
                        else if (bVar31 < 200) {
                          local_78 = (screen_char *)code_1;
                          iVar22 = 3;
                          code_1[0] = 0x31;
                          bVar33 = bVar31 + 0x9c;
                        }
                        else {
                          local_78 = (screen_char *)code_1;
                          iVar22 = 3;
                          code_1[0] = 0x32;
                          bVar33 = bVar31 + 0x38;
                        }
                        code_1[1] = bVar33 / 10 + 0x30;
                        local_bd = bVar33 % 10;
                      }
                      code_1[2] = local_bd + 0x30;
                      add_bytes_to_string__(&image,(uchar *)local_78,iVar22);
                      add_bytes_to_string__
                                (&image,(uchar *)(";38;5;%dm" + iVar30),0xc - (iVar30 + 3));
                      if (((driver_00->opt).field_0x18 & 1) == 0) {
                        local_64 = psVar34->color[1];
LAB_080e186a:
                        iVar22 = 0;
                        do {
                          iVar30 = iVar22;
                          iVar22 = iVar30 + 1;
                        } while ((&DAT_081339be)[iVar30] != '%');
                        add_bytes_to_string__(&image,"\x1b[48;5;%dm",iVar30 + 1);
                        if (local_64 < 10) {
                          local_7c = code_1 + 2;
                          iVar22 = 1;
                          local_bd = local_64;
                        }
                        else {
                          iVar22 = 2;
                          local_7c = code_1 + 1;
                          if (99 < local_64) {
                            if (local_64 < 200) {
                              local_64 = local_64 + 0x9c;
                              iVar22 = 3;
                              local_7c = code_1;
                              code_1[0] = 0x31;
                            }
                            else {
                              local_7c = code_1;
                              iVar22 = 3;
                              code_1[0] = 0x32;
                              local_64 = local_64 + 0x38;
                            }
                          }
                          local_bd = local_64 % 10;
                          code_1[1] = local_64 / 10 + 0x30;
                        }
                        code_1[2] = local_bd + 0x30;
                        add_bytes_to_string__(&image,local_7c,iVar22);
                        add_bytes_to_string__
                                  (&image,(uchar *)("8;5;%dm" + iVar30),10 - (iVar30 + 3));
                      }
                      else {
                        local_64 = psVar34->color[1];
                        if (local_64 != 0) goto LAB_080e186a;
                      }
                      bVar6 = psVar34->attr;
                      if ((bVar6 & 8) != 0) {
                        add_bytes_to_string__(&image,"\x1b[1m",4);
                        bVar6 = psVar34->attr;
                      }
                      bVar33 = bVar31;
                      uVar15 = uVar4;
                      if ((bVar6 & 0x20) != 0) {
                        psVar19 = (driver_00->opt).underline;
                        if (psVar19 == (string *)0x0) {
                          uVar20 = psVar34->data;
                          bVar32 = (driver_00->opt).field_0x18;
                          goto LAB_080e198f;
                        }
                        add_bytes_to_string__(&image,psVar19[1].source,psVar19[1].length);
                        bVar6 = psVar34->attr;
                      }
                      uVar20 = psVar34->data;
                      bVar32 = (driver_00->opt).field_0x18;
                    }
                  }
                  else {
LAB_080e1ae8:
                    bVar6 = psVar34->attr;
                    uVar20 = 0xfffffffd;
                  }
LAB_080e198f:
                  if (((((bVar6 & 0x80) != 0) && (puVar21 = (driver_00->opt).frame, 0xaf < uVar20))
                      && (puVar21 != (uchar *)0x0)) && (uVar20 < 0xe0)) {
                    uVar20 = (uint)puVar21[uVar20 - 0xb0];
                  }
                  if ((bVar32 & 2) == 0) {
                    if ((driver_00->opt).charsets[0] == -1) {
                      if (((bVar6 & 0x80) == 0) && ((uVar20 == 0x7f || (uVar20 < 0x20)))) {
                        add_char_to_string(&image,' ');
                      }
                      else {
                        add_char_to_string(&image,(uchar)uVar20);
                      }
                    }
                    else if (((bVar6 & 0x80) == 0) && ((uVar20 == 0x7f || (uVar20 < 0x20)))) {
                      add_char_to_string(&image,' ');
                    }
                    else {
                      puVar21 = cp2utf8(*(int *)((int)(driver_00->opt).charsets +
                                                (~-(uint)((bVar6 & 0x80) == 0) & 4)),uVar20);
                      add_to_string(&image,puVar21);
                    }
                  }
                  else {
                    if ((bVar6 & 0x80) != 0) {
                      uVar20 = cp2u((driver_00->opt).charsets[1],(uchar)uVar20);
                    }
                    if (uVar20 != 0xfffffffd) {
                      if ((0x5e < uVar20 - 0x20) && (uVar20 < 0xa0)) {
                        uVar20 = 0x20;
                      }
                      puVar21 = encode_utf8(uVar20);
                      add_to_string(&image,puVar21);
                    }
                  }
                  if (local_74 < psVar34 + 1) goto LAB_080e1a6c;
                  psVar34 = psVar34 + 1;
                } while( true );
              }
              if (psVar34 <= local_74) goto LAB_080e16e0;
            }
            goto LAB_080e1a79;
          }
LAB_080e1ab2:
          uVar11 = local_98;
        } while ((int)local_98 <= ptVar10->dirty_to);
        goto LAB_080e0b28;
      }
      if (puVar9 == &DAT_00000005) goto LAB_080e0cfe;
    }
    ptVar10 = term->screen;
    iVar23 = term->width;
    uVar11 = ptVar10->dirty_from;
    uVar1 = iVar23 - 1;
    uVar28 = term->height - 1;
    if ((int)uVar28 < ptVar10->dirty_to) {
      ptVar10->dirty_to = uVar28;
    }
    if (ptVar10->dirty_to < (int)uVar11) {
LAB_080e26b5:
      bVar16 = 0xff;
    }
    else {
      bVar16 = 0xff;
      bVar5 = 0xff;
      local_88 = ptVar10->last_image + iVar23 * uVar11;
      local_78 = ptVar10->image + iVar23 * uVar11;
      psVar34 = (screen_char *)0x0;
      bVar33 = 0xff;
      uVar15 = 0xff;
      local_60 = 0xffffffff;
      do {
        local_98 = uVar11 + 1;
        if ((-1 < (int)uVar1) && ((uVar11 != uVar28 || (iVar23 != 1)))) {
          local_84 = 1;
          do {
            if (((local_78->color[0] ^ local_88->color[0]) >> 4 & 7) != 0) goto LAB_080e08c0;
            if (((local_88->color[0] ^ local_78->color[0]) & 7) == 0) {
              uVar20 = local_78->data;
              if ((uVar20 != local_88->data) || (local_78->attr != local_88->attr))
              goto LAB_080e088b;
            }
            else {
              uVar20 = local_78->data;
LAB_080e088b:
              if ((0x20 < uVar20) || ((0x20 < local_88->data || (local_78->attr != local_88->attr)))
                 ) {
LAB_080e08c0:
                if ((uVar11 != local_60) || (psVar34 + 10 <= local_78)) {
                  local_40 = 2;
                  code[0] = '\x1b';
                  code[1] = '[';
                  iVar22 = elinks_ulongcat(code,&local_40,local_98,10,'\0',10,0);
                  psVar34 = local_78;
                  if (iVar22 < 0) goto LAB_080e093a;
                  code[local_40] = ';';
                  local_40 = local_40 + 1;
                  iVar22 = elinks_ulongcat(code,&local_40,local_84,10,'\0',10,0);
                  if (iVar22 < 0) goto LAB_080e093a;
                  code[local_40] = 'H';
                  local_40 = local_40 + 1;
                  add_bytes_to_string__(&image,code,local_40);
                  goto LAB_080e093a;
                }
joined_r0x080e08e7:
                do {
                  local_60 = uVar11;
                  if (local_78 < psVar34) break;
LAB_080e093a:
                  bVar31 = psVar34->attr;
                  bVar36 = bVar31 & 0x80;
                  bVar6 = bVar31 & 0x20;
                  bVar13 = bVar31 & 8;
                  bVar32 = (driver_00->opt).field_0x18;
                  bVar27 = bVar32 & 2;
                  if (((bVar32 & 2) == 0) || (psVar34->data != 0xfffffffd)) {
                    if (bVar36 == bVar16) {
LAB_080e0d5b:
                      bVar16 = bVar31 & 0x80;
                    }
                    else {
                      psVar19 = (driver_00->opt).frame_seqs;
                      if (psVar19 != (string *)0x0) {
                        if (bVar36 != 0) {
                          psVar19 = psVar19 + 1;
                        }
                        sVar18 = psVar19->length;
                        puVar21 = psVar19->source;
                        if (assert_failed == 0) {
                          if ((puVar21 == (uchar *)0x0) || ((int)sVar18 < 0)) {
                            assert_failed = 1;
                            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                            errline = 0xff;
                            elinks_internal((uchar *)
                                            "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                           );
                            if (assert_failed != 0) goto LAB_080e0994;
                          }
                          assert_failed = 0;
                          if (sVar18 != 0) {
                            assert_failed = 0;
                            iVar22 = image.length + sVar18;
                            uVar20 = iVar22 + 0x100U & 0xffffff00;
                            uVar24 = image.length + 0xffU & 0xffffff00;
                            if (uVar24 < uVar20) {
                              puVar25 = (uchar *)mem_realloc(image.source,uVar20);
                              if (puVar25 == (uchar *)0x0) goto LAB_080e0d50;
                              image.source = puVar25;
                              memset(puVar25 + uVar24,0,uVar20 - uVar24);
                            }
                            if (image.source != (uchar *)0x0) {
                              memcpy(image.source + image.length,puVar21,sVar18);
                              image.source[iVar22] = '\0';
                              image.length = iVar22;
                            }
                          }
LAB_080e0d50:
                          bVar32 = (driver_00->opt).field_0x18;
                          bVar27 = bVar32 & 2;
                          goto LAB_080e0d5b;
                        }
LAB_080e0994:
                        assert_failed = 0;
                        bVar32 = (driver_00->opt).field_0x18;
                        bVar16 = bVar31 & 0x80;
                        bVar27 = bVar32 & 2;
                      }
                    }
                    if ((bVar27 != 0) && (psVar34->data == 0xfffffffd)) goto LAB_080e0d70;
                    iVar22 = image.length;
                    bVar31 = bVar6;
                    if ((bVar6 != bVar5) &&
                       (psVar19 = (driver_00->opt).underline, bVar31 = bVar5,
                       psVar19 != (string *)0x0)) {
                      if (bVar6 != 0) {
                        psVar19 = psVar19 + 1;
                      }
                      sVar18 = psVar19->length;
                      puVar21 = psVar19->source;
                      if (assert_failed == 0) {
                        if ((puVar21 == (uchar *)0x0) || ((int)sVar18 < 0)) {
                          assert_failed = 1;
                          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                          errline = 0xff;
                          elinks_internal((uchar *)
                                          "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                         );
                          if (assert_failed != 0) goto LAB_080e09e7;
                        }
                        assert_failed = 0;
                        if (sVar18 != 0) {
                          assert_failed = 0;
                          iVar22 = image.length + sVar18;
                          uVar20 = iVar22 + 0x100U & 0xffffff00;
                          uVar24 = image.length + 0xffU & 0xffffff00;
                          if (uVar24 < uVar20) {
                            puVar25 = (uchar *)mem_realloc(image.source,uVar20);
                            if (puVar25 == (uchar *)0x0) goto LAB_080e0da2;
                            image.source = puVar25;
                            memset(puVar25 + uVar24,0,uVar20 - uVar24);
                          }
                          if (image.source != (uchar *)0x0) {
                            memcpy(image.source + image.length,puVar21,sVar18);
                            image.source[iVar22] = '\0';
                            bVar32 = (driver_00->opt).field_0x18;
                            bVar31 = bVar6;
                            goto joined_r0x080e0db0;
                          }
                        }
LAB_080e0da2:
                        bVar32 = (driver_00->opt).field_0x18;
                        iVar22 = image.length;
                        bVar31 = bVar6;
                      }
                      else {
LAB_080e09e7:
                        assert_failed = 0;
                        bVar32 = (driver_00->opt).field_0x18;
                        iVar22 = image.length;
                        bVar31 = bVar6;
                      }
                    }
joined_r0x080e0db0:
                    bVar5 = bVar31;
                    image.length = iVar22;
                    if (((bVar32 & 2) != 0) && (psVar34->data == 0xfffffffd)) goto LAB_080e0d70;
                    if (bVar33 != bVar13) {
                      if (bVar13 == 0) {
                        uVar15 = psVar34->color[0] + '\x01';
                        bVar33 = 0;
                      }
                      else {
                        bVar33 = bVar13;
                        if (assert_failed == 0) {
                          assert_failed = 0;
                          uVar29 = iVar22 + 0x104U & 0xffffff00;
                          uVar20 = iVar22 + 0xffU >> 8;
                          uVar24 = iVar22 + 0xffU & 0xffffff00;
                          if (uVar29 < uVar24 || uVar29 + uVar20 * -0x100 == 0) {
joined_r0x080e1352:
                            if (image.source != (uchar *)0x0) {
                              *(undefined4 *)(image.source + image.length) = 0x6d315b1b;
                              image.source[iVar22 + 4] = '\0';
                              bVar32 = (driver_00->opt).field_0x18;
                              image.length = iVar22 + 4;
                              goto LAB_080e0a27;
                            }
                          }
                          else {
                            puVar21 = (uchar *)mem_realloc(image.source,uVar29);
                            if (puVar21 != (uchar *)0x0) {
                              image.source = puVar21;
                              memset(puVar21 + uVar24,0,uVar29 + uVar20 * -0x100);
                              goto joined_r0x080e1352;
                            }
                          }
                          bVar32 = (driver_00->opt).field_0x18;
                        }
                        else {
                          assert_failed = 0;
                          bVar32 = (driver_00->opt).field_0x18;
                        }
                      }
                    }
LAB_080e0a27:
                    iVar22 = image.length;
                    if (((bVar32 & 2) != 0) && (psVar34->data == 0xfffffffd)) goto LAB_080e0d70;
                    uVar4 = psVar34->color[0];
                    if (uVar15 == uVar4) {
                      uVar20 = psVar34->data;
                    }
                    else {
                      if (assert_failed == 0) {
                        assert_failed = 0;
                        iVar30 = image.length + 3;
                        uVar29 = image.length + 0x103U & 0xffffff00;
                        uVar20 = image.length + 0xffU >> 8;
                        uVar24 = image.length + 0xffU & 0xffffff00;
                        if (uVar29 < uVar24 || uVar29 + uVar20 * -0x100 == 0) {
LAB_080e0e04:
                          if (image.source != (uchar *)0x0) {
                            *(undefined2 *)(image.source + image.length) = 0x5b1b;
                            *(undefined *)((int)(image.source + image.length) + 2) = 0x30;
                            image.source[iVar22 + 3] = '\0';
                            image.length = iVar30;
                          }
                        }
                        else {
                          puVar21 = (uchar *)mem_realloc(image.source,uVar29);
                          if (puVar21 != (uchar *)0x0) {
                            image.source = puVar21;
                            memset(puVar21 + uVar24,0,uVar29 + uVar20 * -0x100);
                            goto LAB_080e0e04;
                          }
                        }
                        if ((driver_00->opt).color_mode != COLOR_MODE_MONO) goto LAB_080e0e30;
LAB_080e0f2d:
                        if ((psVar34->attr & 0x40) != 0) {
                          add_bytes_to_string__(&image,";7",2);
                        }
                      }
                      else {
                        assert_failed = 0;
                        if ((driver_00->opt).color_mode == COLOR_MODE_MONO) goto LAB_080e0f2d;
LAB_080e0e30:
                        code_1[4] = '4';
                        code_1[5] = '0';
                        bVar31 = psVar34->color[0] >> 4;
                        code_1[2] = (psVar34->color[0] & 7) + 0x30;
                        code_1[0] = ';';
                        code_1[1] = '3';
                        code_1[3] = 0x3b;
                        bgcolor = bVar31 & 7;
                        if (((bVar31 & 7) == 0) && (((driver_00->opt).field_0x18 & 1) != 0)) {
                          add_bytes_to_string__(&image,code_1,3);
                        }
                        else {
                          code_1[5] = bgcolor + '0';
                          code_1[4] = 0x34;
                          add_bytes_to_string__(&image,code_1,6);
                        }
                      }
                      iVar22 = image.length;
                      if ((bVar6 != 0) && ((driver_00->opt).underline != (string *)0x0)) {
                        if (assert_failed == 0) {
                          assert_failed = 0;
                          iVar30 = image.length + 2;
                          uVar29 = image.length + 0x102U & 0xffffff00;
                          uVar20 = image.length + 0xffU >> 8;
                          uVar24 = image.length + 0xffU & 0xffffff00;
                          if (uVar24 <= uVar29 && uVar29 + uVar20 * -0x100 != 0) {
                            puVar21 = (uchar *)mem_realloc(image.source,uVar29);
                            if (puVar21 == (uchar *)0x0) goto LAB_080e0ed5;
                            image.source = puVar21;
                            memset(puVar21 + uVar24,0,uVar29 + uVar20 * -0x100);
                          }
                          if (image.source != (uchar *)0x0) {
                            *(undefined2 *)(image.source + image.length) = 0x343b;
                            image.source[iVar22 + 2] = '\0';
                            image.length = iVar30;
                          }
                        }
                        else {
                          assert_failed = 0;
                        }
                      }
LAB_080e0ed5:
                      if (bVar13 != 0) {
                        add_bytes_to_string__(&image,";1",2);
                      }
                      add_bytes_to_string__(&image,"m",1);
                      uVar20 = psVar34->data;
                      bVar32 = (driver_00->opt).field_0x18;
                      uVar15 = uVar4;
                    }
                  }
                  else {
LAB_080e0d70:
                    uVar20 = 0xfffffffd;
                  }
                  if ((((bVar36 != 0) && (puVar21 = (driver_00->opt).frame, 0xaf < uVar20)) &&
                      (puVar21 != (uchar *)0x0)) && (uVar20 < 0xe0)) {
                    uVar20 = (uint)puVar21[uVar20 - 0xb0];
                  }
                  if ((bVar32 & 2) == 0) {
                    if ((driver_00->opt).charsets[0] == -1) {
                      if ((bVar36 == 0) && ((uVar20 == 0x7f || (uVar20 < 0x20)))) {
                        add_char_to_string(&image,' ');
                      }
                      else {
                        add_char_to_string(&image,(uchar)uVar20);
                      }
                    }
                    else {
                      if ((bVar36 != 0) || ((uVar20 != 0x7f && (0x1f < uVar20)))) {
                        psVar34 = psVar34 + 1;
                        puVar21 = cp2utf8(*(int *)((int)(driver_00->opt).charsets +
                                                  (~-(uint)(bVar36 == 0) & 4)),uVar20);
                        add_to_string(&image,puVar21);
                        goto joined_r0x080e08e7;
                      }
                      add_char_to_string(&image,' ');
                    }
                  }
                  else {
                    if (bVar36 != 0) {
                      uVar20 = cp2u((driver_00->opt).charsets[1],(uchar)uVar20);
                    }
                    if (uVar20 != 0xfffffffd) {
                      if ((0x5e < uVar20 - 0x20) && (uVar20 < 0xa0)) {
                        uVar20 = 0x20;
                      }
                      puVar21 = encode_utf8(uVar20);
                      add_to_string(&image,puVar21);
                    }
                  }
                  psVar34 = psVar34 + 1;
                } while( true );
              }
            }
            local_88 = local_88 + 1;
            local_78 = local_78 + 1;
          } while (((int)local_84 <= (int)uVar1) &&
                  ((uVar26 = local_84 + 1, bVar37 = uVar1 != local_84, local_84 = uVar26, bVar37 ||
                   (uVar11 != uVar28))));
        }
        uVar11 = local_98;
      } while ((int)local_98 <= ptVar10->dirty_to);
    }
  }
LAB_080e0b28:
  if (image.length == 0) {
LAB_080e1507:
    iVar23 = ptVar7->cx;
    if (iVar23 != ptVar7->lcx) {
      iVar22 = ptVar7->cy;
      goto LAB_080e0b7e;
    }
    iVar22 = ptVar7->cy;
    if (iVar22 != ptVar7->lcy) goto LAB_080e0b7e;
  }
  else {
    if ((driver_00->opt).color_mode != COLOR_MODE_MONO) {
      add_bytes_to_string__(&image,"\x1b[37;40m",8);
    }
    add_bytes_to_string__(&image,"\x1b[0m",4);
    if ((bVar16 != 0) && (psVar19 = (driver_00->opt).frame_seqs, psVar19 != (string *)0x0)) {
      add_bytes_to_string__(&image,psVar19->source,psVar19->length);
    }
    if (image.length == 0) goto LAB_080e1507;
    iVar23 = ptVar7->cx;
    iVar22 = ptVar7->cy;
LAB_080e0b7e:
    ptVar7->lcy = iVar22;
    ptVar7->lcx = iVar23;
    local_40 = 2;
    code[0] = '\x1b';
    code[1] = '[';
    iVar22 = elinks_ulongcat(code,&local_40,iVar22 + 1,10,'\0',10,0);
    if (-1 < iVar22) {
      code[local_40] = ';';
      local_40 = local_40 + 1;
      iVar23 = elinks_ulongcat(code,&local_40,iVar23 + 1,10,'\0',10,0);
      if (-1 < iVar23) {
        code[local_40] = 'H';
        local_40 = local_40 + 1;
        add_bytes_to_string__(&image,code,local_40);
      }
    }
    if (image.length != 0) {
      if ((term->field_0x38 & 1) != 0) {
        want_draw();
      }
      hard_write(term->fdout,image.source,image.length);
      if ((term->field_0x38 & 1) != 0) {
        done_draw();
      }
    }
  }
  done_string(&image);
  memcpy(ptVar7->last_image,ptVar7->image,term->height * term->width * 8);
  iVar23 = term->height;
  ptVar7->dirty_to = 0;
  ptVar7->dirty_from = iVar23;
LAB_080e0cb5:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
LAB_080e22e4:
  psVar34 = psVar34 + 1;
  uVar26 = uVar11;
LAB_080e22f1:
  local_88 = local_88 + 1;
  local_74 = local_74 + 1;
  if (((int)uVar1 < (int)local_84) ||
     ((uVar3 = local_84 + 1, bVar37 = uVar1 == local_84, local_84 = uVar3, bVar37 &&
      (uVar28 == uVar11)))) goto LAB_080e232a;
  goto LAB_080e1f18;
LAB_080e1a6c:
  psVar34 = psVar34 + 1;
  uVar28 = uVar11;
LAB_080e1a79:
  local_88 = local_88 + 1;
  local_74 = local_74 + 1;
  if (((int)uVar1 < (int)local_84) ||
     ((uVar3 = local_84 + 1, bVar37 = uVar1 == local_84, local_84 = uVar3, bVar37 &&
      (uVar26 == uVar11)))) goto LAB_080e1ab2;
  goto LAB_080e16a0;
}



// WARNING: Unknown calling convention

int number_of_tabs(terminal *term)

{
  undefined4 *puVar1;
  int iVar2;
  int result;
  window *win;
  
  iVar2 = 0;
  for (puVar1 = (undefined4 *)(term->windows).next; (list_head_elinks *)puVar1 != &term->windows;
      puVar1 = (undefined4 *)*puVar1) {
    iVar2 = iVar2 + (uint)(puVar1[2] == 1);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int get_tab_number(window *window)

{
  int current;
  int num;
  terminal *term;
  list_head_elinks *plVar1;
  window *win;
  window *pwVar2;
  
  pwVar2 = (window *)(window->term->windows).prev;
  plVar1 = &window->term->windows;
  if (pwVar2 != (window *)plVar1) {
    num = 0;
    do {
      while (pwVar2->type != WINDOW_TAB) {
        pwVar2 = pwVar2->prev;
        if (pwVar2 == (window *)plVar1) {
          num = 0;
          return num;
        }
      }
      if (pwVar2 == window) {
        return num;
      }
      pwVar2 = pwVar2->prev;
      num = num + 1;
    } while (pwVar2 != (window *)plVar1);
  }
  num = 0;
  return num;
}



// WARNING: Unknown calling convention

int get_tab_number_by_xpos(terminal *term,int xpos)

{
  int iVar1;
  int num;
  window *win;
  undefined *puVar2;
  
  puVar2 = (undefined *)(term->windows).prev;
  if ((list_head_elinks *)puVar2 != &term->windows) {
    iVar1 = 0;
    do {
      if (*(int *)(puVar2 + 8) == 1) {
        if ((*(int *)(puVar2 + 0x18) <= xpos) &&
           (xpos < *(int *)(puVar2 + 0x18) + *(int *)(puVar2 + 0x1c))) {
          return iVar1;
        }
        iVar1 = iVar1 + 1;
      }
      puVar2 = *(undefined **)(puVar2 + 4);
    } while (&term->windows != (list_head_elinks *)puVar2);
  }
  return -1;
}



// WARNING: Unknown calling convention

window * get_tab_by_number(terminal *term,int num)

{
  list_head_elinks *plVar1;
  window *win;
  window *pwVar2;
  
  plVar1 = &term->windows;
  for (pwVar2 = (window *)(term->windows).prev; pwVar2 != (window *)plVar1; pwVar2 = pwVar2->prev) {
    while (pwVar2->type != WINDOW_TAB) {
      pwVar2 = pwVar2->prev;
      if (pwVar2 == (window *)plVar1) goto LAB_080e2830;
    }
    if (num == 0) break;
    num = num + -1;
  }
LAB_080e2830:
  if (assert_failed == 0) {
    assert_failed = (int)(pwVar2 == (window *)plVar1);
    if (pwVar2 == (window *)plVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x6f;
      elinks_internal((uchar *)
                      "assertion (LIST_OF(struct window) *) win != &term->windows failed: tab number out of range"
                     );
      if (assert_failed != 0) goto LAB_080e2888;
    }
    return pwVar2;
  }
LAB_080e2888:
  assert_failed = 0;
  return (window *)(term->windows).next;
}



// WARNING: Unknown calling convention

void open_uri_in_new_tab(session *ses,uri *uri,int in_background,int based)

{
  window **ppwVar1;
  
  if ((assert_failed == 0) && (assert_failed = (int)(ses == (session *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0x105;
    elinks_internal((uchar *)"assertion ses failed!");
  }
  ppwVar1 = &ses->tab;
  if (based == 0) {
    ses = (session *)0x0;
  }
  init_session(ses,(*ppwVar1)->term,uri,in_background);
  return;
}



// WARNING: Unknown calling convention

void open_current_link_in_new_tab(session *ses,int in_background)

{
  int iVar1;
  document_view *doc_view_00;
  document_view *doc_view;
  uri *uri_00;
  link *link_00;
  link *link;
  uri *uri;
  
  doc_view_00 = current_frame(ses);
  if (doc_view_00 == (document_view *)0x0) {
LAB_080e2a20:
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    if (doc_view_00 == (document_view *)0x0) goto LAB_080e2a50;
  }
  else {
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
    if ((doc_view_00->vs == (view_state *)0x0) || (doc_view_00->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x11d;
      elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
      goto LAB_080e2a20;
    }
    assert_failed = 0;
  }
  iVar1 = doc_view_00->vs->current_link;
  if (((-1 < iVar1) && (iVar1 < doc_view_00->document->nlinks)) &&
     (link_00 = doc_view_00->document->links + iVar1, link_00 != (link *)0x0)) {
    uri_00 = get_link_uri(ses,doc_view_00,link_00);
    open_uri_in_new_tab(ses,uri_00,in_background,1);
    if (uri_00 != (uri *)0x0) {
      done_uri(uri_00);
      return;
    }
    return;
  }
LAB_080e2a50:
  open_uri_in_new_tab(ses,(uri *)0x0,in_background,1);
  return;
}



// WARNING: Unknown calling convention

void delayed_open(void *data)

{
  delayed_open *deo;
  
  if ((assert_failed == 0) && (assert_failed = (int)(data == (void *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0x110;
    elinks_internal((uchar *)"assertion deo failed!");
  }
                    // WARNING: Load size is inaccurate
  open_uri_in_new_tab(*data,*(uri **)((int)data + 4),0,0);
  done_uri(*(uri **)((int)data + 4));
  mem_free(data);
  return;
}



// WARNING: Unknown calling convention

void really_close_tabs(void *ses_)

{
  terminal *term_00;
  window *pwVar1;
  terminal *term;
  window *tab;
  window *pwVar2;
  
  term_00 = *(terminal **)(*(int *)((int)ses_ + 8) + 0x14);
  pwVar1 = get_tab_by_number(term_00,term_00->current_tab);
  for (pwVar2 = (window *)(term_00->windows).next; pwVar2 != (window *)&term_00->windows;
      pwVar2 = pwVar2->next) {
    while ((pwVar2->type != WINDOW_TAB || (pwVar2 == pwVar1))) {
      pwVar2 = pwVar2->next;
      if (pwVar2 == (window *)&term_00->windows) goto LAB_080e2b62;
    }
    if (0 < term_00->current_tab) {
      term_00->current_tab = term_00->current_tab + -1;
    }
    pwVar2 = pwVar2->prev;
    delete_window(pwVar2->next);
  }
LAB_080e2b62:
  redraw_terminal(term_00);
  return;
}



// WARNING: Unknown calling convention

void close_all_tabs_but_current(session *ses)

{
  option_value *poVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(ses == (session *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0xf0;
    elinks_internal((uchar *)"assertion ses failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  poVar1 = get_opt_();
  if (poVar1->tree == (list_head_elinks *)0x0) {
    really_close_tabs(ses);
    return;
  }
  msg_box(ses->tab->term,(memory_list *)0x0,0,"Close tab",ALIGN_CENTER,
          (uchar *)"Do you really want to close all except the current tab?",ses,2,&DAT_0812762b,
          really_close_tabs,1,&DAT_08127627,0,2);
  return;
}



// WARNING: Unknown calling convention

void switch_to_tab(terminal *term,int tab,int tabs_count)

{
  int *piVar1;
  terminal_screen *ptVar2;
  int iVar3;
  window *win;
  option_value *poVar4;
  int *piVar5;
  
  if (tabs_count < 0) {
    piVar5 = (int *)(term->windows).next;
    if ((list_head_elinks *)piVar5 != &term->windows) {
      tabs_count = 0;
      do {
        piVar1 = piVar5 + 2;
        piVar5 = (int *)*piVar5;
        tabs_count = tabs_count + (uint)(*piVar1 == 1);
      } while ((list_head_elinks *)piVar5 != &term->windows);
      goto LAB_080e2cb6;
    }
LAB_080e2cf8:
    tab = 0;
  }
  else {
LAB_080e2cb6:
    if (tabs_count < 2) goto LAB_080e2cf8;
    poVar4 = get_opt_();
    if (poVar4->tree == (list_head_elinks *)0x0) {
      if (-1 < tab) {
        if (tabs_count + -1 < tab) {
          tab = tabs_count + -1;
        }
        if (term->current_tab == tab) {
          return;
        }
        goto LAB_080e2d02;
      }
      goto LAB_080e2cf8;
    }
    tab = tab % tabs_count;
    if (tab < 0) {
      tab = tab + tabs_count;
    }
  }
  if (term->current_tab == tab) {
    return;
  }
LAB_080e2d02:
  ptVar2 = term->screen;
  term->current_tab = tab;
  iVar3 = term->height;
  if (0 < ptVar2->dirty_from) {
    ptVar2->dirty_from = 0;
  }
  if (ptVar2->dirty_to < iVar3) {
    ptVar2->dirty_to = iVar3;
  }
  redraw_terminal(term);
  return;
}



// WARNING: Unknown calling convention

void move_current_tab(session *ses,int direction)

{
  terminal *term_00;
  void **ppvVar1;
  window *win;
  window *pwVar2;
  int iVar3;
  int count;
  option_value *poVar4;
  window *pwVar5;
  window *tab;
  int new_pos;
  int tabs_count;
  int tabs;
  window *current_tab;
  terminal *term;
  char *pcVar6;
  
  tabs_count = 0;
  term_00 = ses->tab->term;
  for (ppvVar1 = (void **)(term_00->windows).next; (list_head_elinks *)ppvVar1 != &term_00->windows;
      ppvVar1 = (void **)*ppvVar1) {
    tabs_count = tabs_count + (uint)(ppvVar1[2] == (void *)0x1);
  }
  pwVar2 = get_tab_by_number(term_00,term_00->current_tab);
  if ((assert_failed == 0) && (assert_failed = (int)(direction == 0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 0x131;
    elinks_internal((uchar *)"assertion ses && direction failed!");
  }
  iVar3 = eat_kbd_repeat_count(ses);
  new_pos = direction * iVar3;
  if (iVar3 == 0) {
    new_pos = direction;
  }
  new_pos = new_pos + term_00->current_tab;
  pcVar6 = "ui.tabs.wraparound";
  poVar4 = get_opt_();
  if (poVar4->tree == (list_head_elinks *)0x0) {
    iVar3 = 0;
    if ((-1 < new_pos) && (iVar3 = tabs_count + -1, new_pos <= tabs_count + -1)) {
      iVar3 = new_pos;
    }
  }
  else {
    iVar3 = new_pos % tabs_count;
    if (iVar3 < 0) {
      iVar3 = iVar3 + tabs_count;
    }
  }
  if (assert_failed == 0) {
    if ((iVar3 < 0) || (tabs_count <= iVar3)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x13e;
      elinks_internal((uchar *)"assertion 0 <= new_pos && new_pos < tabs failed!",pcVar6);
    }
    else {
      assert_failed = 0;
    }
  }
  if (term_00->current_tab != iVar3) {
    pwVar2->next->prev = pwVar2->prev;
    pwVar2->prev->next = pwVar2->next;
    if (iVar3 == 0) {
      tab = get_tab_by_number(term_00,0);
    }
    else {
      pwVar5 = get_tab_by_number(term_00,iVar3 + -1);
      tab = pwVar5->prev;
    }
    pwVar5 = tab->next;
    pwVar2->prev = tab;
    pwVar2->next = pwVar5;
    tab->next = pwVar2;
    pwVar2->next->prev = pwVar2;
    switch_to_tab(term_00,iVar3,tabs_count);
  }
  return;
}



// WARNING: Unknown calling convention

void really_close_tab(void *ses_)

{
  void **ppvVar1;
  terminal *term_00;
  window *pwVar2;
  window *current_tab;
  window *win;
  void **ppvVar3;
  int tabs_count_00;
  window *win_00;
  int iVar4;
  int tabs_count;
  terminal *term;
  session *ses;
  
  term_00 = *(terminal **)(*(int *)((int)ses_ + 8) + 0x14);
  pwVar2 = get_tab_by_number(term_00,term_00->current_tab);
  win_00 = *(window **)((int)ses_ + 8);
  if (pwVar2 == win_00) {
    ppvVar3 = (void **)(term_00->windows).next;
    iVar4 = 0;
    tabs_count_00 = -1;
    if ((list_head_elinks *)ppvVar3 != &term_00->windows) {
      do {
        ppvVar1 = ppvVar3 + 2;
        ppvVar3 = (void **)*ppvVar3;
        iVar4 = iVar4 + (uint)(*ppvVar1 == (void *)0x1);
      } while ((list_head_elinks *)ppvVar3 != &term_00->windows);
      tabs_count_00 = iVar4 + -1;
    }
    switch_to_tab(term_00,term_00->current_tab + -1,tabs_count_00);
    win_00 = *(window **)((int)ses_ + 8);
  }
  delete_window(win_00);
  return;
}



// WARNING: Unknown calling convention

void switch_current_tab(session *ses,int direction)

{
  void **ppvVar1;
  terminal *term_00;
  window *win;
  void **ppvVar2;
  int iVar3;
  int count;
  int tabs_count_00;
  int tabs_count;
  terminal *term;
  
  term_00 = ses->tab->term;
  ppvVar2 = (void **)(term_00->windows).next;
  if ((list_head_elinks *)ppvVar2 != &term_00->windows) {
    tabs_count_00 = 0;
    do {
      ppvVar1 = ppvVar2 + 2;
      ppvVar2 = (void **)*ppvVar2;
      tabs_count_00 = tabs_count_00 + (uint)(*ppvVar1 == (void *)0x1);
    } while ((list_head_elinks *)ppvVar2 != &term_00->windows);
    if (1 < tabs_count_00) {
      iVar3 = eat_kbd_repeat_count(ses);
      if (iVar3 != 0) {
        direction = direction * iVar3;
      }
      switch_to_tab(term_00,direction + term_00->current_tab,tabs_count_00);
    }
  }
  return;
}



// WARNING: Unknown calling convention

void close_tab(terminal *term,session *ses)

{
  int *piVar1;
  window *win;
  int *piVar2;
  option_value *poVar3;
  int iVar4;
  int tabs_count;
  
  piVar2 = (int *)(term->windows).next;
  if ((list_head_elinks *)piVar2 != &term->windows) {
    iVar4 = 0;
    do {
      piVar1 = piVar2 + 2;
      piVar2 = (int *)*piVar2;
      iVar4 = iVar4 + (uint)(*piVar1 == 1);
    } while ((list_head_elinks *)piVar2 != &term->windows);
    if (1 < iVar4) {
      poVar3 = get_opt_();
      if (poVar3->tree != (list_head_elinks *)0x0) {
        msg_box(term,(memory_list *)0x0,0,"Close tab",ALIGN_CENTER,
                (uchar *)"Do you really want to close the current tab?",ses,2,&DAT_0812762b,
                really_close_tab,1,&DAT_08127627,0,2);
        return;
      }
      really_close_tab(ses);
      return;
    }
  }
  query_exit(ses);
  return;
}



// WARNING: Unknown calling convention

window * init_tab(terminal *term,void *data,window_handler_T *handler)

{
  undefined4 *puVar1;
  window *pwVar2;
  window *pwVar3;
  window *win;
  window *pos;
  window *pwVar4;
  
  pwVar3 = (window *)mem_calloc(1,0x2c);
  if (pwVar3 != (window *)0x0) {
    pwVar3->term = term;
    pwVar3->handler = handler;
    pwVar3->field_0x28 = pwVar3->field_0x28 | 1;
    pwVar3->type = WINDOW_TAB;
    pwVar3->data = data;
    for (puVar1 = (undefined4 *)(term->windows).next; (list_head_elinks *)puVar1 != &term->windows;
        puVar1 = (undefined4 *)*puVar1) {
      if (puVar1[2] == 1) {
        pwVar4 = (window *)puVar1[1];
        goto found_pos;
      }
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(term->main_menu != (menu *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 0x35;
      elinks_internal((uchar *)"assertion term->main_menu == NULL failed!");
    }
    pwVar4 = (window *)(term->windows).prev;
found_pos:
    pwVar2 = pwVar4->next;
    pwVar3->prev = pwVar4;
    pwVar3->next = pwVar2;
    pwVar4->next = pwVar3;
    pwVar3->next->prev = pwVar3;
  }
  return pwVar3;
}



// WARNING: Unknown calling convention

void close_terminal_pipes(void)

{
  close(terminal_pipe[0]);
  close(terminal_pipe[1]);
  return;
}



// WARNING: Unknown calling convention

int check_terminal_pipes(void)

{
  int iVar1;
  
  iVar1 = c_pipe(terminal_pipe);
  return iVar1;
}



// WARNING: Unknown calling convention

int get_terminal_codepage(terminal *term)

{
  option_value *poVar1;
  
  poVar1 = get_opt_();
  return (int)poVar1->tree;
}



// WARNING: Unknown calling convention

void close_handle(void *h)

{
  close((int)h);
  set_handlers((int)h,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,(void *)0x0)
  ;
  return;
}



// WARNING: Unknown calling convention

void exec_on_terminal(terminal *term,uchar *path,uchar *delete,term_exec fg)

{
  size_t sVar1;
  int iVar2;
  size_t sVar3;
  size_t sVar4;
  uchar *puVar5;
  uchar *param;
  int blockh;
  
  if (path == (uchar *)0x0) {
    path = "";
  }
  else if (*path == '\0') {
    return;
  }
  if ((term->field_0x38 & 1) == 0) {
    sVar3 = strlen((char *)delete);
    sVar4 = strlen((char *)path);
    sVar1 = sVar3 + 4 + sVar4;
    puVar5 = (uchar *)mem_alloc(sVar1);
    if (puVar5 != (uchar *)0x0) {
      *puVar5 = '\0';
      puVar5[1] = (uchar)fg;
      memcpy(puVar5 + 2,path,sVar4 + 1);
      memcpy(puVar5 + sVar4 + 3,delete,sVar3 + 1);
      hard_write(term->fdout,puVar5,sVar1);
      mem_free(puVar5);
      return;
    }
  }
  else {
    if (*path == '\0') {
      dispatch_special(delete);
      return;
    }
    if ((fg != TERM_EXEC_BG) && (iVar2 = is_blocked(), iVar2 != 0)) {
      unlink((char *)delete);
      return;
    }
    sVar3 = strlen((char *)delete);
    sVar4 = strlen((char *)path);
    sVar1 = sVar3 + 3 + sVar4;
    puVar5 = (uchar *)mem_alloc(sVar1);
    if (puVar5 != (uchar *)0x0) {
      *puVar5 = (uchar)fg;
      memcpy(puVar5 + 1,path,sVar4 + 1);
      memcpy(puVar5 + sVar4 + 2,delete,sVar3 + 1);
      if (fg == TERM_EXEC_FG) {
        block_itrm();
      }
      iVar2 = start_thread(exec_thread,puVar5,sVar1);
      mem_free(puVar5);
      if (iVar2 == -1) {
        if (fg == TERM_EXEC_FG) {
          unblock_itrm();
          return;
        }
      }
      else if (fg == TERM_EXEC_FG) {
        term->blocked = iVar2;
        set_handlers(iVar2,unblock_terminal,(select_handler_T)0x0,unblock_terminal,term);
        set_handlers(term->fdin,(select_handler_T)0x0,(select_handler_T)0x0,destroy_terminal,term);
      }
      else {
        set_handlers(iVar2,close_handle,(select_handler_T)0x0,close_handle,(void *)iVar2);
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

void do_terminal_function(terminal *term,uchar code,uchar *data)

{
  size_t sVar1;
  uchar *delete;
  
  sVar1 = strlen((char *)data);
  delete = (uchar *)mem_alloc(sVar1 + 2);
  if (delete != (uchar *)0x0) {
    *delete = code;
    memcpy(delete + 1,data,sVar1 + 1);
    exec_on_terminal(term,(uchar *)0x0,delete,TERM_EXEC_BG);
    mem_free(delete);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

int set_terminal_title(terminal *term,uchar *title)

{
  int iVar1;
  option_value *poVar2;
  uchar *puVar3;
  conv_table *convert_table_00;
  size_t charslen;
  int from_cp;
  uchar *converted;
  conv_table *convert_table;
  int local_20;
  
  if ((term->title != (uchar *)0x0) &&
     (iVar1 = strcmp((char *)title,(char *)term->title), iVar1 == 0)) {
    return 0;
  }
  iVar1 = get_terminal_codepage(term);
  poVar2 = get_opt_();
  if (poVar2->tree == (list_head_elinks *)0x0) {
    poVar2 = get_opt_();
    if (poVar2->tree != (list_head_elinks *)0x0) {
      local_20 = get_cp_index("UTF-8");
      goto LAB_080e36ff;
    }
  }
  else {
    local_20 = get_cp_index((uchar *)"ISO-8859-1");
LAB_080e36ff:
    if (local_20 != iVar1) {
      convert_table_00 = get_translation_table(iVar1,local_20);
      if (convert_table_00 == (conv_table *)0x0) {
        return -1;
      }
      charslen = strlen((char *)title);
      converted = convert_string_elinks
                            (convert_table_00,title,charslen,local_20,CSM_NONE,(int *)0x0,
                             (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
      if (converted == (uchar *)0x0) {
        return -1;
      }
      goto LAB_080e3687;
    }
  }
  converted = (uchar *)0x0;
  local_20 = iVar1;
LAB_080e3687:
  if (term->title != (uchar *)0x0) {
    mem_free(term->title);
  }
  puVar3 = stracpy(title);
  term->title = puVar3;
  puVar3 = get_cp_mime_name(local_20);
  do_terminal_function(term,'\x03',puVar3);
  if (converted == (uchar *)0x0) {
    do_terminal_function(term,'\x01',title);
  }
  else {
    do_terminal_function(term,'\x01',converted);
    mem_free(converted);
  }
  return 0;
}



// WARNING: Unknown calling convention

void exec_shell(terminal *term)

{
  int iVar1;
  uchar *sh;
  uchar *path;
  
  iVar1 = can_open_os_shell(term->environment);
  if (iVar1 != 0) {
    path = get_shell();
    if ((path != (uchar *)0x0) && (*path != '\0')) {
      exec_on_terminal(term,path,"",TERM_EXEC_FG);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void assert_terminal_ptr_not_dangling(terminal *suspect)

{
  terminal *term;
  terminal *ptVar1;
  
  if (suspect != (terminal *)0x0) {
    ptVar1 = (terminal *)terminals.next;
    if ((list_head_elinks *)terminals.next != &terminals) {
      do {
        if (suspect == ptVar1) {
          return;
        }
        ptVar1 = ptVar1->next;
      } while (ptVar1 != (terminal *)&terminals);
    }
    if (assert_failed == 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c";
      errline = 0xf2;
      elinks_internal((uchar *)"assertion 0 failed: Dangling pointer to struct terminal");
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void exec_thread(uchar *path,int p)

{
  size_t sVar1;
  
  sVar1 = strlen((char *)(path + 1));
  if (*path == '\x02') {
    setpgid(0,0);
  }
  exe(path + 1);
  if (path[sVar1 + 2] == '\0') {
    return;
  }
  unlink((char *)(path + sVar1 + 2));
  return;
}



// WARNING: Unknown calling convention

void destroy_terminal(terminal *term)

{
  object *poVar1;
  window *win;
  int __fd;
  void *p;
  void *p_1;
  option_value *poVar2;
  __pid_t _Var3;
  
  bookmark_auto_save_tabs(term);
  detach_downloads_from_terminal(term);
  win = (window *)(term->windows).next;
  term->current_tab = 0;
  while (win != (window *)&term->windows) {
    delete_window(win);
    win = (window *)(term->windows).next;
  }
  if (term->title != (uchar *)0x0) {
    mem_free(term->title);
  }
  if (term->screen != (terminal_screen *)0x0) {
    done_screen(term->screen);
  }
  set_handlers(term->fdin,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
               (void *)0x0);
  if (term->interlink != (terminal_interlink *)0x0) {
    mem_free(term->interlink);
  }
  if (term->blocked != -1) {
    close(term->blocked);
    set_handlers(term->blocked,(select_handler_T)0x0,(select_handler_T)0x0,(select_handler_T)0x0,
                 (void *)0x0);
  }
  term->next->prev = term->prev;
  term->prev->next = term->next;
  close(term->fdin);
  __fd = term->fdout;
  if (__fd == 1) {
    unhandle_terminal_signals(term);
    free_all_itrms();
    if (((list_head_elinks *)terminals.next != &terminals) && (_Var3 = fork(), _Var3 != 0)) {
                    // WARNING: Subroutine does not return
      exit(0);
    }
  }
  else if (__fd != term->fdin) {
    close(__fd);
  }
  poVar1 = &term->spec->object;
  poVar1->refcount = poVar1->refcount + -1;
  mem_free(term);
  if (((list_head_elinks *)terminals.next == &terminals) &&
     (poVar2 = get_opt_(), poVar2->tree == (list_head_elinks *)0x0)) {
    program.terminate = 1;
    return;
  }
  program.terminate = 0;
  return;
}



// WARNING: Unknown calling convention

void destroy_all_terminals(void)

{
  if ((list_head_elinks *)terminals.next != &terminals) {
    do {
      destroy_terminal((terminal *)terminals.next);
    } while ((list_head_elinks *)terminals.next != &terminals);
  }
  return;
}



// WARNING: Unknown calling convention

void redraw_all_terminals(void)

{
  terminal **pptVar1;
  terminal *term;
  terminal *term_00;
  
  term_00 = (terminal *)terminals.next;
  if ((list_head_elinks *)terminals.next != &terminals) {
    do {
      redraw_screen(term_00);
      pptVar1 = &term_00->next;
      term_00 = *pptVar1;
    } while (*pptVar1 != (terminal *)&terminals);
  }
  return;
}



// WARNING: Removing unreachable block (ram,0x080e3b40)
// WARNING: Removing unreachable block (ram,0x080e3c28)
// WARNING: Removing unreachable block (ram,0x080e3b4d)
// WARNING: Unknown calling convention

terminal * init_term(int fdin,int fdout)

{
  uint uVar1;
  terminal *p;
  terminal *term;
  terminal_screen *ptVar2;
  int iVar3;
  option_elinks *poVar4;
  option_value *poVar5;
  int in_GS_OFFSET;
  terminal *ptVar6;
  code *pcVar7;
  char *pcVar8;
  uchar name [41];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  name[0] = 't';
  name[1] = 'e';
  name[2] = 'r';
  name[3] = 'm';
  name[4] = 'i';
  name[5] = 'n';
  name[6] = 'a';
  name[7] = 'l';
  name[8] = '.';
  name[9] = '\0';
  name[10] = '\0';
  name[11] = '\0';
  name[12] = '\0';
  uVar1 = 0;
  do {
    *(undefined4 *)(name + uVar1 + 0xd) = 0;
    uVar1 = uVar1 + 4;
  } while (uVar1 < 0x1c);
  pcVar7 = (code *)0x158;
  ptVar6 = (terminal *)0x1;
  p = (terminal *)mem_calloc(1,0x158);
  if (p == (terminal *)0x0) {
    fdin = (int)ptVar6;
    if ((list_head_elinks *)terminals.next == &terminals) {
      pcVar8 = "ui.sessions.keep_session_active";
      fdin = (int)config_options;
      poVar5 = get_opt_();
      program.terminate = 1;
      pcVar7 = (code *)pcVar8;
      if (poVar5->tree == (list_head_elinks *)0x0) goto LAB_080e3c0d;
    }
    program.terminate = 0;
  }
  else {
    ptVar2 = init_screen();
    p->screen = ptVar2;
    if (ptVar2 == (terminal_screen *)0x0) {
      fdin = (int)p;
      mem_free(p);
      p = (terminal *)0x0;
    }
    else {
      p->fdout = fdout;
      (p->windows).prev = &p->windows;
      (p->windows).next = &p->windows;
      ((option_value *)&p->fdin)->number = fdin;
      iVar3 = get_output_handle();
      p->blocked = -1;
      p->field_0x38 = p->field_0x38 & 0xfe | fdout == iVar3;
      get_terminal_name(name + 9);
      poVar4 = get_opt_rec(config_options,name);
      p->spec = poVar4;
      (poVar4->object).refcount = (poVar4->object).refcount + 1;
      p->prev = (terminal *)&terminals;
      p->next = (terminal *)terminals.next;
      terminals.next = p;
      p->next->prev = p;
      pcVar7 = in_term;
      set_handlers(fdin,in_term,(select_handler_T)0x0,destroy_terminal,p);
    }
  }
LAB_080e3c0d:
  if (local_20 == *(int *)(in_GS_OFFSET + 0x14)) {
    return p;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail(fdin,pcVar7);
}



// WARNING: Unknown calling convention

terminal * attach_terminal(int in,int out,int ctl,void *info,int len)

{
  int iVar1;
  terminal *term;
  
  iVar1 = set_nonblocking_fd(terminal_pipe[0]);
  if ((-1 < iVar1) && (iVar1 = set_nonblocking_fd(terminal_pipe[1]), -1 < iVar1)) {
    handle_trm(in,out,out,terminal_pipe[1],ctl,info,len,0);
    term = init_term(terminal_pipe[0],out);
    if (term != (terminal *)0x0) {
      return term;
    }
    close_terminal_pipes();
    term = (terminal *)0x0;
    return term;
  }
  term = (terminal *)0x0;
  return term;
}



// WARNING: Unknown calling convention

void redraw_terminal(terminal *term)

{
  term_event ev;
  
  ev.info.mouse.x = term->width;
  ev.info.mouse.y = term->height;
  ev.info.mouse.button = 0;
  ev.ev = EVENT_REDRAW;
  term_send_event(term,&ev);
  return;
}



// WARNING: Unknown calling convention

void redraw_terminal_cls(terminal *term)

{
  term_event ev;
  
  ev.info.mouse.x = term->width;
  ev.info.mouse.y = term->height;
  ev.info.mouse.button = 0;
  ev.ev = EVENT_RESIZE;
  term_send_event(term,&ev);
  return;
}



// WARNING: Unknown calling convention

void unblock_terminal(terminal *term)

{
  close_handle((void *)term->blocked);
  term->blocked = -1;
  set_handlers(term->fdin,in_term,(select_handler_T)0x0,destroy_terminal,term);
  unblock_itrm();
  redraw_terminal_cls(term);
  if (textarea_editor != 0) {
    textarea_edit(1,(terminal *)0x0,(form_state *)0x0,(document_view *)0x0,(link *)0x0);
  }
  return;
}



// WARNING: Unknown calling convention

void cls_redraw_all_terminals(void)

{
  terminal **pptVar1;
  terminal *term;
  terminal *term_00;
  
  term_00 = (terminal *)terminals.next;
  if ((list_head_elinks *)terminals.next != &terminals) {
    do {
      redraw_terminal_cls(term_00);
      pptVar1 = &term_00->next;
      term_00 = *pptVar1;
    } while (*pptVar1 != (terminal *)&terminals);
  }
  return;
}



// WARNING: Unknown calling convention

void get_parent_ptr(window *win,int *x,int *y)

{
  window *parent;
  window *pwVar1;
  
  pwVar1 = win->next;
  if (pwVar1->type == WINDOW_TAB) {
    pwVar1 = get_tab_by_number(win->term,win->term->current_tab);
  }
  if (pwVar1 != (window *)0x0) {
    *x = pwVar1->x;
    *y = pwVar1->y;
    return;
  }
  *x = 0;
  *y = 0;
  return;
}



// WARNING: Unknown calling convention

void redraw_from_window(window *win)

{
  terminal *ptVar1;
  window *pwVar2;
  window *pwVar3;
  window *end;
  terminal *term;
  term_event ev;
  
  ptVar1 = win->term;
  if (ptVar1->redrawing != TREDRAW_READY) {
    return;
  }
  ev.info.mouse.y = ptVar1->height;
  ev.info.mouse.x = ptVar1->width;
  ev.info.mouse.button = 0;
  ev.ev = EVENT_REDRAW;
  ptVar1->redrawing = TREDRAW_BUSY;
  for (pwVar3 = win->prev; (window *)&ptVar1->windows != pwVar3; pwVar3 = pwVar3->prev) {
    while ((pwVar3->type != WINDOW_NORMAL &&
           (pwVar2 = get_tab_by_number(pwVar3->term,pwVar3->term->current_tab), pwVar2 != pwVar3)))
    {
      pwVar3 = pwVar3->prev;
      if ((window *)&ptVar1->windows == pwVar3) goto LAB_080e3f68;
    }
    (*pwVar3->handler)(pwVar3,&ev);
  }
LAB_080e3f68:
  ptVar1->redrawing = TREDRAW_READY;
  return;
}



// WARNING: Unknown calling convention

void delete_window(window *win)

{
  void *p;
  term_event ev;
  
  win->next->prev = win->prev;
  win->prev->next = win->next;
  ev.info.mouse.x = 0;
  ev.info.mouse.y = 0;
  ev.info.mouse.button = 0;
  ev.ev = EVENT_ABORT;
  (*win->handler)(win,&ev);
  if (win->data != (void *)0x0) {
    mem_free(win->data);
  }
  redraw_terminal(win->term);
  mem_free(win);
  return;
}



// WARNING: Unknown calling convention

void empty_window_handler(window *win,term_event *ev)

{
  terminal *term;
  code **ppcVar1;
  code *UNRECOVERED_JUMPTABLE;
  code *pcVar2;
  term_event_type tVar3;
  ewd *ewd;
  void *data;
  
  term = win->term;
  ppcVar1 = (code **)win->data;
  UNRECOVERED_JUMPTABLE = *ppcVar1;
  pcVar2 = ppcVar1[1];
  if ((*(byte *)(ppcVar1 + 2) & 1) != 0) {
    return;
  }
  tVar3 = ev->ev;
  if (tVar3 < EVENT_ABORT) {
    if ((EVENT_MOUSE < tVar3) || (tVar3 == EVENT_INIT)) {
      get_parent_ptr(win,&win->x,&win->y);
      return;
    }
  }
  else if (tVar3 == EVENT_ABORT) {
                    // WARNING: Could not recover jumptable at 0x080e409a. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  *(byte *)(ppcVar1 + 2) = *(byte *)(ppcVar1 + 2) | 1;
  delete_window(win);
  (*UNRECOVERED_JUMPTABLE)(pcVar2);
  term_send_event(term,ev);
  return;
}



// WARNING: Unknown calling convention

void delete_window_ev(window *win,term_event *ev)

{
  window *pwVar1;
  window *pwVar2;
  window *w;
  bool bVar3;
  
  pwVar1 = win->next;
  bVar3 = pwVar1 == (window *)&win->term->windows;
  pwVar2 = pwVar1;
  if (bVar3) {
    pwVar2 = (window *)0x0;
  }
  delete_window(win);
  if ((!bVar3 && pwVar1 != (window *)0x0) && (ev != (term_event *)0x0)) {
    if (pwVar2->type == WINDOW_TAB) {
      pwVar2 = get_tab_by_number(pwVar2->term,pwVar2->term->current_tab);
    }
    if (pwVar2 != (window *)0x0) {
                    // WARNING: Could not recover jumptable at 0x080e410b. Too many branches
                    // WARNING: Treating indirect jump as call
      (*pwVar2->handler)(pwVar2,ev);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void add_window(terminal *term,window_handler_T *handler,void *data)

{
  void *pvVar1;
  void **ppvVar2;
  term_event ev;
  
  ppvVar2 = (void **)mem_calloc(1,0x2c);
  if (ppvVar2 == (void **)0x0) {
    if (data != (void *)0x0) {
      mem_free(data);
      return;
    }
  }
  else {
    ppvVar2[4] = data;
    ppvVar2[5] = term;
    ppvVar2[2] = (void *)0x0;
    ppvVar2[3] = handler;
    pvVar1 = (term->windows).next;
    ppvVar2[1] = &term->windows;
    *ppvVar2 = pvVar1;
    (term->windows).next = ppvVar2;
    *(void ***)((int)*ppvVar2 + 4) = ppvVar2;
    ev.info.mouse.y = term->height;
    ev.info.mouse.x = term->width;
    ev.info.mouse.button = 0;
    ev.ev = EVENT_INIT;
    (*(code *)ppvVar2[3])(ppvVar2,&ev);
  }
  return;
}



// WARNING: Unknown calling convention

void add_empty_window(terminal *term,_func_void_void_ptr *fn,void *data)

{
  _func_void_void_ptr **data_00;
  
  data_00 = (_func_void_void_ptr **)mem_alloc(0xc);
  if (data_00 != (_func_void_void_ptr **)0x0) {
    *(byte *)(data_00 + 2) = *(byte *)(data_00 + 2) & 0xfe;
    *data_00 = fn;
    data_00[1] = (_func_void_void_ptr *)data;
    add_window(term,empty_window_handler,data_00);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void redraw_below_window(window *win)

{
  terminal *ptVar1;
  term_redrawing_state tVar2;
  window *pwVar3;
  window *pwVar4;
  terminal *term;
  term_event ev;
  
  ptVar1 = win->term;
  tVar2 = ptVar1->redrawing;
  if (tVar2 != TREDRAW_DELAYED) {
    ev.info.mouse.y = ptVar1->height;
    ev.info.mouse.x = ptVar1->width;
    ev.info.mouse.button = 0;
    ev.ev = EVENT_REDRAW;
    pwVar4 = (window *)(ptVar1->windows).prev;
    ptVar1->redrawing = TREDRAW_DELAYED;
    for (; win != pwVar4; pwVar4 = pwVar4->prev) {
      while ((pwVar4->type != WINDOW_NORMAL &&
             (pwVar3 = get_tab_by_number(pwVar4->term,pwVar4->term->current_tab), pwVar3 != pwVar4))
            ) {
        pwVar4 = pwVar4->prev;
        if (win == pwVar4) goto LAB_080e42d0;
      }
      (*pwVar4->handler)(pwVar4,&ev);
    }
LAB_080e42d0:
    ptVar1->redrawing = tVar2;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * base64_encode_bin(uchar *in,int inlen,int *outlen)

{
  byte *pbVar1;
  byte bVar2;
  uchar *outstr;
  uchar *out;
  uchar *puVar3;
  
  if (assert_failed == 0) {
    if ((in == (uchar *)0x0) || (*in == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
      errline = 0x21;
      elinks_internal((uchar *)"assertion in && *in failed!");
      if (assert_failed != 0) goto LAB_080e4335;
    }
    else {
      assert_failed = 0;
    }
    outstr = (uchar *)mem_alloc((inlen / 3) * 4 + 5);
    if (outstr != (uchar *)0x0) {
      puVar3 = outstr;
      if (2 < inlen) {
        do {
          inlen = inlen + -3;
          *puVar3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[*in >> 2];
          puVar3[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [(uint)(in[1] >> 4) | (*in & 3) << 4];
          puVar3[2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [(uint)(in[2] >> 6) | (in[1] & 0xf) << 2];
          pbVar1 = in + 2;
          in = in + 3;
          puVar3[3] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                      [*pbVar1 & 0x3f];
          puVar3 = puVar3 + 4;
        } while (2 < inlen);
      }
      if (inlen == 1) {
        *puVar3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[*in >> 2];
        bVar2 = *in;
        puVar3[2] = '=';
        puVar3[3] = '=';
        puVar3[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                    [(bVar2 & 3) * 0x10];
        puVar3 = puVar3 + 4;
      }
      else if (inlen == 2) {
        *puVar3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[*in >> 2];
        puVar3[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                    [(uint)(in[1] >> 4) | (*in & 3) << 4];
        bVar2 = in[1];
        puVar3[3] = '=';
        puVar3[2] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
                    [(bVar2 & 0xf) * 4];
        puVar3 = puVar3 + 4;
      }
      *puVar3 = '\0';
      if (outlen != (int *)0x0) {
        *outlen = (int)puVar3 - (int)outstr;
        return outstr;
      }
    }
  }
  else {
LAB_080e4335:
    assert_failed = 0;
    outstr = (uchar *)0x0;
  }
  return outstr;
}



// WARNING: Unknown calling convention

uchar * base64_decode_bin(uchar *in,int inlen,int *outlen)

{
  byte bVar1;
  uchar *out;
  uchar *p;
  int iVar2;
  int count;
  uchar *outstr;
  int i;
  uint uVar3;
  int iVar4;
  uint bits;
  uint uVar5;
  uchar *puVar6;
  
  if (assert_failed == 0) {
    if ((in == (uchar *)0x0) || (*in == '\0')) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
      errline = 0x61;
      elinks_internal((uchar *)"assertion in && *in failed!");
      if (assert_failed != 0) goto LAB_080e4505;
    }
    else {
      assert_failed = 0;
    }
    if (inlen < 0) {
      inlen = inlen + 3;
    }
    p = (uchar *)mem_alloc((inlen >> 2) * 3 + 1);
    outstr = (uchar *)0x0;
    if (p != (uchar *)0x0) {
      if (base64_decode_bin::once == 0) {
        iVar2 = 0x40;
        do {
          bVar1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[iVar2];
          base64_decode_bin::decode[bVar1] = (uchar)iVar2;
          iVar2 = iVar2 + -1;
          base64_decode_bin::is_base64_char[bVar1] = '\x01';
        } while (iVar2 != -1);
        base64_decode_bin::once = 1;
      }
      bVar1 = *in;
      puVar6 = p;
      if ((bVar1 != 0) && (bVar1 != 0x3d)) {
        uVar3 = (uint)bVar1;
        if (base64_decode_bin::is_base64_char[uVar3] != '\0') {
          uVar5 = 0;
          iVar2 = 0;
          do {
            iVar2 = iVar2 + 1;
            iVar4 = base64_decode_bin::decode[uVar3] + uVar5;
            if (iVar2 == 4) {
              uVar5 = 0;
              *puVar6 = (uchar)((uint)iVar4 >> 0x10);
              puVar6[1] = (uchar)((uint)iVar4 >> 8);
              iVar2 = 0;
              puVar6[2] = (uchar)iVar4;
              bVar1 = in[1];
              puVar6 = puVar6 + 3;
            }
            else {
              bVar1 = in[1];
              uVar5 = iVar4 * 0x40;
            }
            if (bVar1 == 0) {
              if (iVar2 == 0) goto LAB_080e45e8;
              break;
            }
            in = in + 1;
            if (bVar1 == 0x3d) {
              if (iVar2 == 2) {
                *puVar6 = (uchar)(uVar5 >> 10);
                puVar6 = puVar6 + 1;
                goto LAB_080e45e8;
              }
              if (iVar2 == 3) {
                *puVar6 = (uchar)(uVar5 >> 0x10);
                puVar6[1] = (uchar)(uVar5 >> 8);
                puVar6 = puVar6 + 2;
                goto LAB_080e45e8;
              }
              if (iVar2 != 1) goto LAB_080e45e8;
              break;
            }
            uVar3 = (uint)bVar1;
          } while (base64_decode_bin::is_base64_char[uVar3] != '\0');
        }
        mem_free(p);
        return (uchar *)0x0;
      }
LAB_080e45e8:
      *puVar6 = '\0';
      outstr = p;
      if (outlen != (int *)0x0) {
        *outlen = (int)puVar6 - (int)p;
        return p;
      }
    }
  }
  else {
LAB_080e4505:
    assert_failed = 0;
    outstr = (uchar *)0x0;
  }
  return outstr;
}



// WARNING: Unknown calling convention

uchar * base64_decode(uchar *in)

{
  size_t inlen;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((in == (uchar *)0x0) || (*in == '\0')) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 0x49;
    elinks_internal((uchar *)"assertion in && *in failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  inlen = strlen((char *)in);
  puVar1 = base64_decode_bin(in,inlen,(int *)0x0);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * base64_encode(uchar *in)

{
  size_t inlen;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((in == (uchar *)0x0) || (*in == '\0')) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 0x15;
    elinks_internal((uchar *)"assertion in && *in failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  inlen = strlen((char *)in);
  puVar1 = base64_encode_bin(in,inlen,(int *)0x0);
  return puVar1;
}



// WARNING: Unknown calling convention

void colors_list_reset(void)

{
  internal_pointer = color_specs;
  return;
}



// WARNING: Unknown calling convention

fastfind_key_value * colors_list_next(void)

{
  char **ppcVar1;
  fastfind_key_value *pfVar2;
  
  pfVar2 = (fastfind_key_value *)0x0;
  ppcVar1 = &internal_pointer->name;
  if ((uchar *)*ppcVar1 != (uchar *)0x0) {
    colors_list_next::kv.data = internal_pointer;
    internal_pointer = internal_pointer + 1;
    pfVar2 = &colors_list_next::kv;
    colors_list_next::kv.key = (uchar *)*ppcVar1;
  }
  return pfVar2;
}



// WARNING: Unknown calling convention

void color_to_string(color_T color,uchar *str)

{
  *str = '#';
  elinks_ulongcat(str + 1,(uint *)0x0,color,6,'0',0x10,0);
  return;
}



// WARNING: Unknown calling convention

uchar * get_color_string(color_T color,uchar *hexcolor)

{
  color_spec *pcVar1;
  char *pcVar2;
  color_spec *cs;
  color_spec *pcVar3;
  
  pcVar2 = "aliceblue";
  pcVar3 = color_specs;
  if (color != 0xf0f8ff) {
    do {
      pcVar2 = pcVar3[1].name;
      if ((uchar *)pcVar2 == (uchar *)0x0) {
        color_to_string(color,hexcolor);
        return hexcolor;
      }
      pcVar1 = pcVar3 + 1;
      pcVar3 = pcVar3 + 1;
    } while (pcVar1->rgb != color);
  }
  return (uchar *)pcVar2;
}



// WARNING: Unknown calling convention

int decode_color(uchar *str,int slen,color_T *color)

{
  int *piVar1;
  color_T string_color;
  int len;
  int iVar2;
  ushort **ppuVar3;
  uchar buffer [7];
  uchar *local_20 [4];
  
  if ((*str == '#') && ((slen == 4 || (slen == 7)))) {
    str = str + 1;
  }
  else {
    piVar1 = (int *)fastfind_search(&ff_colors_index,str,slen);
    if ((piVar1 != (int *)0x0) && (*piVar1 != 0)) {
      string_color = piVar1[1];
      goto LAB_080e490e;
    }
    if ((slen != 3) && (slen != 6)) {
      return -1;
    }
    iVar2 = 0;
    if (0 < slen) {
      ppuVar3 = __ctype_b_loc();
      iVar2 = 0;
      do {
        if ((*(byte *)((int)*ppuVar3 + (uint)str[iVar2] * 2 + 1) & 0x10) == 0) break;
        iVar2 = iVar2 + 1;
      } while (iVar2 < slen);
    }
    if (iVar2 != slen) {
      return -1;
    }
  }
  if (slen == 4) {
    buffer[0] = *str;
    buffer[2] = str[1];
    buffer[4] = str[2];
    str = buffer;
    buffer[6] = '\0';
    buffer[1] = buffer[0];
    buffer[3] = buffer[2];
    buffer[5] = buffer[4];
  }
  piVar1 = __errno_location();
  *piVar1 = 0;
  string_color = strtoul((char *)str,(char **)local_20,0x10);
  if (((*piVar1 != 0) || (str + 6 != local_20[0])) || (0xffffff < string_color)) {
    return -1;
  }
LAB_080e490e:
  *color = string_color;
  return 0;
}



// WARNING: Unknown calling convention

void free_colors_lookup(void)

{
  fastfind_done(&ff_colors_index);
  return;
}



// WARNING: Unknown calling convention

void init_colors_lookup(void)

{
  fastfind_index(&ff_colors_index,FF_COMPRESS|FF_LOCALE_INDEP);
  return;
}



int elinks_ulongcat(uchar *s,uint *slen,ulong number,uint width,uchar fillchar,uint base,uint upper)

{
  uint uVar1;
  ulong q;
  ulong uVar2;
  int iVar3;
  uchar *puVar4;
  uchar *puVar5;
  uchar *to_num;
  int iVar6;
  uint pad;
  int ret;
  uint nlen;
  uint uVar7;
  uint start;
  uint pos;
  uint local_1c;
  
  puVar5 = "0123456789abcdef";
  if (upper != 0) {
    puVar5 = "0123456789ABCDEF";
  }
  uVar7 = 0;
  if (slen != (uint *)0x0) {
    uVar7 = *slen;
  }
  if ((((width == 0) || (s == (uchar *)0x0)) || (0x10 < base)) || (base < 2)) {
    ret = -1;
  }
  else {
    local_1c = 1;
    if (base - 1 < number) {
      local_1c = 1;
      uVar2 = number;
      do {
        local_1c = local_1c + 1;
        uVar2 = uVar2 / base;
      } while (base - 1 < uVar2);
    }
    uVar1 = local_1c;
    ret = 0;
    if (width < local_1c) {
      local_1c = width;
      ret = uVar1;
    }
    if (slen != (uint *)0x0) {
      *slen = *slen + local_1c;
    }
    if ((fillchar != '\0') && (iVar3 = width - local_1c, iVar3 != 0)) {
      if (slen != (uint *)0x0) {
        *slen = *slen + iVar3;
      }
      puVar4 = s + iVar3 + -1 + uVar7;
      iVar6 = iVar3;
      do {
        *puVar4 = fillchar;
        puVar4 = puVar4 + -1;
        iVar6 = iVar6 + -1;
      } while (iVar6 != 0);
      uVar7 = uVar7 + iVar3;
    }
    s[uVar7 + local_1c] = '\0';
    if (local_1c != 0) {
      iVar3 = local_1c - 1;
      puVar4 = s + iVar3 + uVar7;
      while( true ) {
        *puVar4 = puVar5[number % base];
        puVar4 = puVar4 + -1;
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        number = number / base;
      }
    }
  }
  return ret;
}



// WARNING: Unknown calling convention

int month2num(uchar *str)

{
  byte bVar1;
  byte bVar2;
  
  bVar1 = str[1] | 0x20;
  bVar2 = str[2] | 0x20;
  switch(*str | 0x20) {
  case 0x61:
    if (bVar1 == 0x70) {
      if (bVar2 == 0x72) {
        return 3;
      }
    }
    else if ((bVar1 == 0x75) && (bVar2 == 0x67)) {
      return 7;
    }
    break;
  case 100:
    if ((bVar1 == 0x65) && (bVar2 == 99)) {
      return 0xb;
    }
    break;
  case 0x66:
    if ((bVar1 == 0x65) && (bVar2 == 0x62)) {
      return 1;
    }
    break;
  case 0x6a:
    if (bVar1 == 0x61) {
      if (bVar2 == 0x6e) {
        return 0;
      }
    }
    else if (bVar1 == 0x75) {
      if (bVar2 == 0x6e) {
        return 5;
      }
      if (bVar2 == 0x6c) {
        return 6;
      }
    }
    break;
  case 0x6d:
    if (bVar1 == 0x61) {
      if (bVar2 == 0x72) {
        return 2;
      }
      if (bVar2 == 0x79) {
        return 4;
      }
    }
    break;
  case 0x6e:
    if ((bVar1 == 0x6f) && (bVar2 == 0x76)) {
      return 10;
    }
    break;
  case 0x6f:
    if ((bVar1 == 99) && (bVar2 == 0x74)) {
      return 9;
    }
    break;
  case 0x73:
    if ((bVar1 == 0x65) && (bVar2 == 0x70)) {
      return 8;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

int c_tolower(int c)

{
  switch(c) {
  case 0x41:
    return 0x61;
  case 0x42:
    c = 0x62;
    break;
  case 0x43:
    return 99;
  case 0x44:
    return 100;
  case 0x45:
    return 0x65;
  case 0x46:
    return 0x66;
  case 0x47:
    return 0x67;
  case 0x48:
    return 0x68;
  case 0x49:
    return 0x69;
  case 0x4a:
    return 0x6a;
  case 0x4b:
    return 0x6b;
  case 0x4c:
    return 0x6c;
  case 0x4d:
    return 0x6d;
  case 0x4e:
    return 0x6e;
  case 0x4f:
    return 0x6f;
  case 0x50:
    return 0x70;
  case 0x51:
    return 0x71;
  case 0x52:
    return 0x72;
  case 0x53:
    return 0x73;
  case 0x54:
    return 0x74;
  case 0x55:
    return 0x75;
  case 0x56:
    return 0x76;
  case 0x57:
    return 0x77;
  case 0x58:
    return 0x78;
  case 0x59:
    return 0x79;
  case 0x5a:
    return 0x7a;
  }
  return c;
}



// WARNING: Unknown calling convention

int c_toupper(int c)

{
  switch(c) {
  case 0x61:
    return 0x41;
  case 0x62:
    c = 0x42;
    break;
  case 99:
    return 0x43;
  case 100:
    return 0x44;
  case 0x65:
    return 0x45;
  case 0x66:
    return 0x46;
  case 0x67:
    return 0x47;
  case 0x68:
    return 0x48;
  case 0x69:
    return 0x49;
  case 0x6a:
    return 0x4a;
  case 0x6b:
    return 0x4b;
  case 0x6c:
    return 0x4c;
  case 0x6d:
    return 0x4d;
  case 0x6e:
    return 0x4e;
  case 0x6f:
    return 0x4f;
  case 0x70:
    return 0x50;
  case 0x71:
    return 0x51;
  case 0x72:
    return 0x52;
  case 0x73:
    return 0x53;
  case 0x74:
    return 0x54;
  case 0x75:
    return 0x55;
  case 0x76:
    return 0x56;
  case 0x77:
    return 0x57;
  case 0x78:
    return 0x58;
  case 0x79:
    return 0x59;
  case 0x7a:
    return 0x5a;
  }
  return c;
}



// WARNING: Unknown calling convention

int c_isupper(int c)

{
  return (uint)(c - 0x41U < 0x1a);
}



// WARNING: Unknown calling convention

int c_islower(int c)

{
  return (uint)(c - 0x61U < 0x1a);
}



// WARNING: Unknown calling convention

void clr_spaces(uchar *str)

{
  uchar uVar1;
  uchar *s;
  byte *pbVar2;
  uchar *dest;
  uchar *puVar3;
  byte bVar4;
  uchar *puVar5;
  
  if ((assert_failed == 0) && (assert_failed = (int)(str == (uchar *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
    errline = 0x1df;
    elinks_internal((uchar *)"assertion str failed!");
  }
  bVar4 = *str;
  pbVar2 = str;
  puVar3 = str;
  if (bVar4 != 0) {
    do {
      if (bVar4 < 0x20) {
        *pbVar2 = 0x20;
      }
      bVar4 = pbVar2[1];
      pbVar2 = pbVar2 + 1;
    } while (bVar4 != 0);
    uVar1 = *str;
    puVar5 = str;
    while (uVar1 != '\0') {
      do {
        puVar5 = puVar5 + 1;
        if (uVar1 != ' ') goto LAB_080e50d0;
        if (puVar3 == str) goto LAB_080e50d5;
      } while (*puVar5 == ' ');
      if (*puVar5 == '\0') break;
LAB_080e50d0:
      *puVar3 = uVar1;
      puVar3 = puVar3 + 1;
LAB_080e50d5:
      uVar1 = *puVar5;
    }
  }
  *puVar3 = '\0';
  return;
}



// WARNING: Unknown calling convention

long strtolx(uchar *str,uchar **end)

{
  byte *pbVar1;
  uchar postfix;
  int *piVar2;
  long lVar3;
  int iVar4;
  long num;
  
  piVar2 = __errno_location();
  *piVar2 = 0;
  lVar3 = strtol((char *)str,(char **)end,10);
  if (*piVar2 != 0) {
    return 0;
  }
  pbVar1 = *end;
  if (pbVar1 == (byte *)0x0) {
    return lVar3;
  }
  iVar4 = c_toupper((uint)*pbVar1);
  if ((char)iVar4 == 'K') {
    *end = pbVar1 + 1;
    if (lVar3 < -0x1fffff) {
      return -0x7fffffff;
    }
    if (lVar3 < 0x200000) {
      return lVar3 << 10;
    }
  }
  else {
    if ((char)iVar4 != 'M') {
      return lVar3;
    }
    *end = pbVar1 + 1;
    if (lVar3 < -0x7ff) {
      return -0x7fffffff;
    }
    if (lVar3 < 0x800) {
      return lVar3 << 0x14;
    }
  }
  return 0x7fffffff;
}



// WARNING: Unknown calling convention

string * add_shell_safe_to_string(string *string,uchar *cmd,int cmdlen)

{
  bool bVar1;
  uchar uVar2;
  byte bVar3;
  int prev_safe;
  int iVar4;
  
  if (cmdlen != 0) {
    iVar4 = 0;
    uVar2 = *cmd;
    while( true ) {
      if ((byte)(uVar2 + 0x9f) < 0x1a) goto LAB_080e5240;
      if ((byte)(uVar2 + 0xbf) < 0x1a) goto LAB_080e5240;
      if ((byte)(uVar2 - 0x30) < 10) goto LAB_080e5240;
      if (uVar2 == '@') goto LAB_080e5240;
      if (uVar2 == '.') goto LAB_080e5240;
      if (uVar2 == '+') goto LAB_080e5240;
      if (uVar2 == ':') goto LAB_080e5240;
      if (uVar2 == '/') goto LAB_080e5240;
      if (uVar2 == '_') goto LAB_080e5240;
      add_char_to_string(string,'%');
      bVar3 = cmd[iVar4] >> 4;
      uVar2 = bVar3 + 0x30;
      if (9 < bVar3) {
        uVar2 = bVar3 + 0x57;
      }
      add_char_to_string(string,uVar2);
      bVar3 = cmd[iVar4] & 0xf;
      uVar2 = bVar3 + 0x57;
      if (bVar3 < 10) {
        uVar2 = bVar3 + 0x30;
      }
      iVar4 = iVar4 + 1;
      add_char_to_string(string,uVar2);
      bVar1 = false;
      if (cmdlen == iVar4) break;
      while ((uVar2 = cmd[iVar4], bVar1 && (uVar2 == '-'))) {
LAB_080e5240:
        iVar4 = iVar4 + 1;
        add_char_to_string(string,uVar2);
        bVar1 = true;
        if (cmdlen == iVar4) {
          return string;
        }
      }
    }
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_quoted_to_string(string *string,uchar *src,int len)

{
  uchar character;
  int iVar1;
  
  if (len != 0) {
    iVar1 = 0;
    do {
      character = src[iVar1];
      if (((character == '\'') || (character == '\"')) || (character == '\\')) {
        add_char_to_string(string,'\\');
        character = src[iVar1];
      }
      iVar1 = iVar1 + 1;
      add_char_to_string(string,character);
    } while (iVar1 != len);
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_shell_quoted_to_string(string *string,uchar *src,int len)

{
  uchar *puVar1;
  int iVar2;
  
  add_char_to_string(string,'\'');
  if (len != 0) {
    iVar2 = 0;
    do {
      while (puVar1 = src + iVar2, *puVar1 == '\'') {
        iVar2 = iVar2 + 1;
        add_to_string(string,"\'\\\'\'");
        if (iVar2 == len) goto LAB_080e53e0;
      }
      iVar2 = iVar2 + 1;
      add_char_to_string(string,*puVar1);
    } while (iVar2 != len);
  }
LAB_080e53e0:
  add_char_to_string(string,'\'');
  return string;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  uint uVar2;
  uchar *puVar3;
  size_t newsize;
  uint size;
  int newlength;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (length == 0) {
    return string;
  }
  iVar1 = length + string->length;
  uVar2 = string->length + 0xffU & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar2 < size) {
    puVar3 = (uchar *)mem_realloc(string->source,size);
    if (puVar3 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar3;
    memset(puVar3 + uVar2,0,size - uVar2);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,bytes,length);
  string->source[iVar1] = '\0';
  string->length = iVar1;
  return string;
}



// WARNING: Unknown calling convention

string * add_date_to_string(string *string,uchar *fmt,time_t *date)

{
  int iVar1;
  time_t when_time;
  tm *__tp;
  tm *when_local;
  string *psVar2;
  int in_GS_OFFSET;
  time_t local_414;
  uchar buffer [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (date == (time_t *)0x0) {
    local_414 = time((time_t *)0x0);
  }
  else {
    local_414 = *date;
  }
  __tp = localtime(&local_414);
  when_local = (tm *)strftime((char *)buffer,0x400,(char *)fmt,__tp);
  psVar2 = (string *)0x0;
  if (when_local != (tm *)0x0) {
    psVar2 = add_to_string(string,buffer);
  }
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return psVar2;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

int sanitize_url(uchar *url)

{
  uchar *puVar1;
  uchar uVar2;
  size_t sVar3;
  int len;
  size_t sVar4;
  uchar *puVar5;
  uchar *puVar6;
  
  sVar3 = strlen((char *)url);
  if (sVar3 == 0) {
    return 1;
  }
  puVar5 = url + sVar3;
  sVar4 = sVar3;
  do {
    sVar4 = sVar4 - 1;
    if (puVar5[-1] < 0x20) {
      return 0;
    }
    puVar5 = puVar5 + -1;
  } while (sVar4 != 0);
  puVar5 = url;
  if (*url == ' ') {
    do {
      puVar5 = puVar5 + 1;
      sVar3 = sVar3 - 1;
    } while (*puVar5 == ' ');
    if (sVar3 == 0) {
LAB_080e5677:
      sVar3 = 1;
      goto LAB_080e567c;
    }
  }
  puVar6 = puVar5 + sVar3;
  uVar2 = puVar5[sVar3 - 1];
  while (uVar2 == ' ') {
    sVar3 = sVar3 - 1;
    puVar6[-1] = '\0';
    if (sVar3 == 0) goto LAB_080e5677;
    puVar1 = puVar6 + -2;
    puVar6 = puVar6 + -1;
    uVar2 = *puVar1;
  }
  sVar3 = sVar3 + 1;
LAB_080e567c:
  memmove(url,puVar5,sVar3);
  return 1;
}



// WARNING: Unknown calling convention

void sanitize_title(uchar *title)

{
  uchar *puVar1;
  uchar uVar2;
  size_t sVar3;
  uchar *puVar4;
  int l;
  int len;
  uchar *puVar5;
  
  sVar3 = strlen((char *)title);
  if (sVar3 != 0) {
    puVar4 = title + sVar3;
    do {
      sVar3 = sVar3 - 1;
      if (puVar4[-1] < 0x20) {
        puVar4[-1] = ' ';
      }
      puVar4 = puVar4 + -1;
    } while (sVar3 != 0);
    sVar3 = strlen((char *)title);
    uVar2 = *title;
    puVar4 = title;
    while (uVar2 == ' ') {
      puVar4 = puVar4 + 1;
      sVar3 = sVar3 - 1;
      uVar2 = *puVar4;
    }
    if (sVar3 == 0) {
LAB_080e572f:
      sVar3 = 1;
    }
    else {
      puVar5 = puVar4 + sVar3;
      uVar2 = puVar4[sVar3 - 1];
      while (uVar2 == ' ') {
        sVar3 = sVar3 - 1;
        puVar5[-1] = '\0';
        if (sVar3 == 0) goto LAB_080e572f;
        puVar1 = puVar5 + -2;
        puVar5 = puVar5 + -1;
        uVar2 = *puVar1;
      }
      sVar3 = sVar3 + 1;
    }
    memmove(title,puVar4,sVar3);
  }
  return;
}



// WARNING: Unknown calling convention

int elinks_longcat(uchar *s,uint *slen,long number,uint width,uchar fillchar,uint base,uint upper)

{
  uint uVar1;
  uchar *puVar2;
  uint pad;
  int iVar3;
  int iVar4;
  uchar *puVar5;
  uchar *to_num;
  int ret;
  uchar *p;
  uint local_20;
  uint local_18;
  
  if ((width != 0) && (number < 0)) {
    if (slen == (uint *)0x0) {
      *s = '-';
      p = s + 1;
    }
    else {
      uVar1 = *slen;
      s[uVar1] = '-';
      *slen = uVar1 + 1;
      p = s;
    }
    width = width - 1;
    number = -number;
    s = p;
  }
  puVar5 = "0123456789abcdef";
  local_18 = 0;
  if (upper != 0) {
    puVar5 = "0123456789ABCDEF";
  }
  if (slen != (uint *)0x0) {
    local_18 = *slen;
  }
  if ((((s == (uchar *)0x0) || (width == 0)) || (0x10 < base)) || (base < 2)) {
    ret = -1;
  }
  else {
    local_20 = 1;
    if (base - 1 < (uint)number) {
      local_20 = 1;
      uVar1 = number;
      do {
        local_20 = local_20 + 1;
        uVar1 = uVar1 / base;
      } while (base - 1 < uVar1);
    }
    uVar1 = local_20;
    ret = 0;
    if (width < local_20) {
      local_20 = width;
      ret = uVar1;
    }
    if (slen != (uint *)0x0) {
      *slen = *slen + local_20;
    }
    if ((fillchar != '\0') && (iVar3 = width - local_20, iVar3 != 0)) {
      if (slen != (uint *)0x0) {
        *slen = *slen + iVar3;
      }
      puVar2 = s + iVar3 + -1 + local_18;
      iVar4 = iVar3;
      do {
        *puVar2 = fillchar;
        puVar2 = puVar2 + -1;
        iVar4 = iVar4 + -1;
      } while (iVar4 != 0);
      local_18 = local_18 + iVar3;
    }
    s[local_20 + local_18] = '\0';
    if (local_20 != 0) {
      iVar3 = local_20 - 1;
      puVar2 = s + iVar3 + local_18;
      while( true ) {
        *puVar2 = puVar5[(uint)number % base];
        puVar2 = puVar2 + -1;
        if (iVar3 == 0) break;
        iVar3 = iVar3 + -1;
        number = (uint)number / base;
      }
    }
  }
  return ret;
}



// WARNING: Unknown calling convention

string * add_knum_to_string(string *string,long num)

{
  uint uVar1;
  uint nlen;
  uint uVar2;
  int iVar3;
  int ret;
  int in_GS_OFFSET;
  bool bVar4;
  uint local_58;
  uint local_50;
  uint local_44;
  uchar t [32];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_44 = 0;
  if (num == 0) {
    uVar2 = 0;
    num = 0;
LAB_080e590f:
    local_44 = uVar2 + 1;
    t[uVar2 + 1] = '\0';
    local_50 = 1;
    uVar1 = 0;
    goto LAB_080e5925;
  }
  iVar3 = num + 0xfffff;
  if (-1 < num) {
    iVar3 = num;
  }
  if ((iVar3 >> 0x14) << 0x14 == num) {
    uVar1 = elinks_longcat(t,&local_44,iVar3 >> 0x14,0x1e,'\0',10,0);
    t[local_44] = 'M';
    t[local_44 + 1] = '\0';
    local_44 = local_44 + 1;
LAB_080e5a63:
    if (-1 < (int)uVar1) goto LAB_080e5a80;
  }
  else {
    iVar3 = num + 0x3ff;
    if (-1 < num) {
      iVar3 = num;
    }
    if ((iVar3 >> 10) << 10 == num) {
      uVar1 = elinks_longcat(t,&local_44,iVar3 >> 10,0x1e,'\0',10,0);
      t[local_44] = 'k';
      t[local_44 + 1] = '\0';
      local_44 = local_44 + 1;
      goto LAB_080e5a63;
    }
    bVar4 = num < 0;
    local_58 = 0x1f;
    if (bVar4) {
      t[0] = '-';
      num = -num;
      local_58 = 0x1e;
    }
    uVar2 = (uint)bVar4;
    if ((uint)num < 10) goto LAB_080e590f;
    local_50 = 1;
    uVar1 = num;
    do {
      local_50 = local_50 + 1;
      uVar1 = uVar1 / 10;
    } while (9 < uVar1);
    if (local_58 < local_50) {
      local_44 = local_58 + uVar2;
      t[local_44] = '\0';
      uVar1 = local_50;
      local_50 = local_58;
LAB_080e5925:
      iVar3 = (local_50 - 1) + uVar2;
      do {
        t[iVar3] = "0123456789abcdef"[(uint)num % 10];
        iVar3 = iVar3 + -1;
        local_50 = local_50 - 1;
        num = (uint)num / 10;
      } while (local_50 != 0);
      goto LAB_080e5a63;
    }
    local_44 = uVar2 + local_50;
    t[local_44] = '\0';
    if (local_50 != 0) {
      uVar1 = 0;
      goto LAB_080e5925;
    }
LAB_080e5a80:
    if (local_44 != 0) {
      add_bytes_to_string__(string,t,local_44);
      goto LAB_080e5a69;
    }
  }
  string = (string *)0x0;
LAB_080e5a69:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_string_replace(string *string,uchar *src,int len,uchar replaceable,uchar replacement)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  uint size;
  int iVar4;
  uchar *puVar5;
  uint uVar6;
  int oldlength;
  
  iVar2 = string->length;
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  if ((src == (uchar *)0x0) || (len < 0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 0xff;
    elinks_internal((uchar *)
                    "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  if (len == 0) {
    return string;
  }
  iVar1 = string->length + len;
  uVar6 = string->length + 0xff;
  uVar3 = uVar6 >> 8;
  uVar6 = uVar6 & 0xffffff00;
  size = iVar1 + 0x100U & 0xffffff00;
  if (uVar6 <= size && size + uVar3 * -0x100 != 0) {
    puVar5 = (uchar *)mem_realloc(string->source,size);
    if (puVar5 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar5;
    memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  memcpy(string->source + string->length,src,len);
  string->source[iVar1] = '\0';
  iVar4 = 0;
  string->length = iVar1;
  puVar5 = string->source;
  do {
    if (puVar5[iVar4 + iVar2] == replaceable) {
      puVar5[iVar4 + iVar2] = replacement;
    }
    iVar4 = iVar4 + 1;
  } while (len != iVar4);
  return string;
}



// WARNING: Unknown calling convention

string * add_duration_to_string(string *string,long seconds)

{
  uint pad;
  int iVar1;
  uint uVar2;
  uint pad_1;
  int iVar3;
  uint uVar4;
  uchar *puVar5;
  uint nlen_2;
  uint uVar6;
  uint nlen_3;
  uint nlen_4;
  int iVar7;
  uint nlen;
  uint nlen_1;
  int in_GS_OFFSET;
  int local_a0;
  int local_80;
  int local_74;
  undefined4 local_64;
  uchar q [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_64 = 0;
  if (seconds < 0) {
    uVar4 = 0;
    uVar2 = 0;
LAB_080e5e92:
    iVar7 = 1;
    local_64 = 1;
    q[1] = '\0';
LAB_080e5d18:
    puVar5 = q + iVar7;
    do {
      puVar5[-1] = "0123456789abcdef"[uVar2 % 10];
      puVar5 = puVar5 + -1;
      iVar7 = iVar7 + -1;
      uVar2 = uVar2 / 10;
    } while (iVar7 != 0);
  }
  else {
    if (seconds < 0x15180) {
      if (seconds < 0xe10) {
        uVar2 = seconds / 0x3c;
        uVar4 = seconds % 0x3c;
        if (uVar2 < 10) goto LAB_080e5e92;
        local_64 = 2;
        iVar7 = 2;
        q[2] = '\0';
        goto LAB_080e5d18;
      }
    }
    else {
      uVar2 = seconds / 0x15180;
      if (uVar2 < 10) {
        local_64 = 1;
        q[1] = '\0';
LAB_080e6160:
        puVar5 = q + local_64;
        uVar4 = local_64;
        do {
          puVar5[-1] = "0123456789abcdef"[uVar2 % 10];
          puVar5 = puVar5 + -1;
          uVar4 = uVar4 - 1;
          uVar2 = uVar2 / 10;
        } while (uVar4 != 0);
      }
      else {
        uVar6 = 1;
        uVar4 = uVar2;
        do {
          uVar6 = uVar6 + 1;
          uVar4 = uVar4 / 10;
        } while (9 < uVar4);
        local_64 = 5;
        if (uVar6 < 6) {
          local_64 = uVar6;
        }
        q[local_64] = '\0';
        if (local_64 != 0) goto LAB_080e6160;
      }
      q[local_64] = 'd';
      q[local_64 + 1] = ' ';
      local_64 = local_64 + 2;
    }
    iVar7 = local_64;
    iVar3 = seconds % 0x15180;
    uVar2 = iVar3 / 0xe10;
    if (uVar2 < 10) {
      uVar4 = 1;
      q[local_64 + 1] = '\0';
      local_64 = local_64 + 1;
LAB_080e6090:
      puVar5 = q + uVar4 + iVar7 + -1;
      do {
        *puVar5 = "0123456789abcdef"[uVar2 % 10];
        puVar5 = puVar5 + -1;
        uVar4 = uVar4 - 1;
        uVar2 = uVar2 / 10;
      } while (uVar4 != 0);
    }
    else {
      uVar6 = 1;
      uVar4 = uVar2;
      do {
        uVar6 = uVar6 + 1;
        uVar4 = uVar4 / 10;
      } while (9 < uVar4);
      uVar4 = 4;
      if (uVar6 < 5) {
        uVar4 = uVar6;
      }
      local_64 = uVar4 + local_64;
      q[local_64] = '\0';
      if (uVar4 != 0) goto LAB_080e6090;
    }
    iVar7 = local_64;
    local_80 = local_64 + 1;
    q[local_64] = ':';
    uVar2 = (iVar3 / 0x3c) % 0x3c;
    if (uVar2 < 10) {
      local_64 = local_64 + 2;
      nlen_4 = 1;
      local_a0 = 1;
LAB_080e60e7:
      local_64 = local_a0 + local_64;
      local_80 = local_80 + local_a0;
      puVar5 = q + local_a0 + iVar7;
      do {
        *puVar5 = '0';
        puVar5 = puVar5 + -1;
        local_a0 = local_a0 + -1;
      } while (local_a0 != 0);
      iVar1 = local_80 + nlen_4;
LAB_080e6128:
      q[iVar1] = '\0';
      if (nlen_4 == 0) {
        uVar4 = iVar3 % 0x3c;
        goto LAB_080e5d4d;
      }
    }
    else {
      nlen_4 = 1;
      uVar4 = uVar2;
      do {
        nlen_4 = nlen_4 + 1;
        uVar4 = uVar4 / 10;
      } while (9 < uVar4);
      if (nlen_4 < 3) {
        iVar1 = nlen_4 + local_80;
        local_a0 = 2 - nlen_4;
        local_64 = iVar1;
        if (local_a0 != 0) goto LAB_080e60e7;
        goto LAB_080e6128;
      }
      nlen_4 = 2;
      q[local_64 + 3] = '\0';
      local_64 = local_64 + 3;
    }
    puVar5 = q + local_80 + nlen_4 + -1;
    do {
      *puVar5 = "0123456789abcdef"[uVar2 % 10];
      puVar5 = puVar5 + -1;
      nlen_4 = nlen_4 - 1;
      uVar2 = uVar2 / 10;
    } while (nlen_4 != 0);
    uVar4 = iVar3 % 0x3c;
  }
LAB_080e5d4d:
  iVar7 = local_64;
  local_74 = local_64 + 1;
  q[local_64] = ':';
  if (uVar4 < 10) {
    local_64 = local_64 + 2;
    nlen_1 = 1;
    local_80 = 1;
LAB_080e6034:
    local_64 = local_80 + local_64;
    local_74 = local_74 + local_80;
    puVar5 = q + local_80 + iVar7;
    do {
      *puVar5 = '0';
      puVar5 = puVar5 + -1;
      local_80 = local_80 + -1;
    } while (local_80 != 0);
    iVar3 = local_74 + nlen_1;
LAB_080e6060:
    q[iVar3] = '\0';
    if (nlen_1 == 0) goto LAB_080e5dd1;
  }
  else {
    nlen_1 = 1;
    uVar2 = uVar4;
    do {
      nlen_1 = nlen_1 + 1;
      uVar2 = uVar2 / 10;
    } while (9 < uVar2);
    if (nlen_1 < 3) {
      iVar3 = local_74 + nlen_1;
      local_80 = 2 - nlen_1;
      local_64 = iVar3;
      if (local_80 != 0) goto LAB_080e6034;
      goto LAB_080e6060;
    }
    nlen_1 = 2;
    q[local_64 + 3] = '\0';
    local_64 = local_64 + 3;
  }
  puVar5 = q + (nlen_1 - 1) + local_74;
  do {
    *puVar5 = "0123456789abcdef"[uVar4 % 10];
    puVar5 = puVar5 + -1;
    nlen_1 = nlen_1 - 1;
    uVar4 = uVar4 / 10;
  } while (nlen_1 != 0);
LAB_080e5dd1:
  add_to_string(string,q);
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_timeval_to_string(string *string,timeval_T *timeval)

{
  long seconds;
  string *psVar1;
  
  seconds = timeval_to_seconds(timeval);
  psVar1 = add_duration_to_string(string,seconds);
  return psVar1;
}



// WARNING: Unknown calling convention

string * add_long_to_string(string *string,long number)

{
  string *psVar1;
  int iVar2;
  uchar *puVar3;
  uint uVar4;
  uint nlen;
  int in_GS_OFFSET;
  uint local_54;
  uint local_50;
  undefined4 local_44;
  uchar buffer [32];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  if (assert_failed != 0) {
LAB_080e6322:
    assert_failed = 0;
    psVar1 = (string *)0x0;
    goto LAB_080e632e;
  }
  assert_failed = (int)(string == (string *)0x0);
  local_44 = 0;
  iVar2 = 0;
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
    errline = 0x8a;
    elinks_internal((uchar *)"assertion string failed!");
    iVar2 = local_44;
    if (assert_failed != 0) goto LAB_080e6322;
  }
  local_50 = 0x1f;
  if (number < 0) {
    buffer[iVar2] = '-';
    number = -number;
    iVar2 = iVar2 + 1;
    local_50 = 0x1e;
  }
  if ((uint)number < 10) {
    local_44 = iVar2 + 1;
    local_50 = 1;
    buffer[iVar2 + 1] = '\0';
    local_54 = 0;
LAB_080e62b8:
    puVar3 = buffer + local_50 + iVar2 + -1;
    do {
      *puVar3 = "0123456789abcdef"[(uint)number % 10];
      puVar3 = puVar3 + -1;
      local_50 = local_50 - 1;
      number = (uint)number / 10;
    } while (local_50 != 0);
    if (-1 < (int)local_54) goto LAB_080e62eb;
  }
  else {
    nlen = 1;
    uVar4 = number;
    do {
      nlen = nlen + 1;
      uVar4 = uVar4 / 10;
    } while (9 < uVar4);
    if (local_50 < nlen) {
      local_44 = local_50 + iVar2;
      buffer[local_44] = '\0';
      local_54 = nlen;
      goto LAB_080e62b8;
    }
    local_44 = nlen + iVar2;
    buffer[local_44] = '\0';
    if (nlen != 0) {
      local_54 = 0;
      local_50 = nlen;
      goto LAB_080e62b8;
    }
LAB_080e62eb:
    if (local_44 != 0) {
      psVar1 = add_bytes_to_string__(string,buffer,local_44);
      goto LAB_080e632e;
    }
  }
  psVar1 = (string *)0x0;
LAB_080e632e:
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return psVar1;
}



// WARNING: Unknown calling convention

string * add_cp_html_to_string(string *string,int src_codepage,uchar *src,int len)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  string *psVar4;
  unicode_val_T number;
  uchar *puVar5;
  size_t oldsize;
  uint uVar6;
  size_t newsize;
  uint size;
  unicode_val_T unicode;
  
  len = (int)(src + len);
  do {
    while( true ) {
      number = cp_to_unicode(src_codepage,&src,(uchar *)len);
      if (number == 0xfffffffd) {
        return string;
      }
      if (((((0x5e < number - 0x20) || (number == 0x3c)) || (number == 0x26)) ||
          ((number == 0x3e || (number == 0x27)))) || (number == 0x22)) break;
      psVar4 = add_char_to_string(string,(uchar)number);
      if (psVar4 == (string *)0x0) {
        return (string *)0x0;
      }
    }
    iVar2 = string->length;
    if (assert_failed != 0) {
      assert_failed = 0;
      puVar5 = string->source;
      goto LAB_080e6490;
    }
    assert_failed = 0;
    iVar1 = string->length;
    uVar3 = iVar1 + 0xffU >> 8;
    uVar6 = iVar1 + 0xffU & 0xffffff00;
    size = iVar1 + 0x102U & 0xffffff00;
    if (uVar6 <= size && size + uVar3 * -0x100 != 0) {
      puVar5 = (uchar *)mem_realloc(string->source,size);
      if (puVar5 == (uchar *)0x0) {
LAB_080e64e8:
        puVar5 = string->source;
LAB_080e6490:
        string->length = iVar2;
        puVar5[iVar2] = '\0';
        return (string *)0x0;
      }
      string->source = puVar5;
      memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
    }
    puVar5 = string->source;
    if (puVar5 == (uchar *)0x0) goto LAB_080e6490;
    *(undefined2 *)(puVar5 + string->length) = 0x2326;
    string->source[iVar1 + 2] = '\0';
    string->length = iVar1 + 2;
    psVar4 = add_long_to_string(string,number);
    if ((psVar4 == (string *)0x0) ||
       (psVar4 = add_char_to_string(string,';'), psVar4 == (string *)0x0)) goto LAB_080e64e8;
  } while( true );
}



// WARNING: Unknown calling convention

string * add_html_to_string(string *string,uchar *src,int len)

{
  byte character;
  int iVar1;
  int iVar2;
  uint uVar3;
  string *psVar4;
  uchar *puVar5;
  size_t oldsize;
  uint uVar6;
  size_t newsize;
  uint size;
  int iVar7;
  
  if (len != 0) {
    iVar7 = 0;
    do {
      character = src[iVar7];
      if (((((character == 0x3c) || (character < 0x20)) || (character == 0x3e)) ||
          ((character == 0x26 || (character == 0x22)))) || (character == 0x27)) {
        iVar2 = string->length;
        if (assert_failed != 0) {
          assert_failed = 0;
          puVar5 = string->source;
          goto LAB_080e660a;
        }
        assert_failed = 0;
        iVar1 = string->length;
        uVar3 = iVar1 + 0xffU >> 8;
        uVar6 = iVar1 + 0xffU & 0xffffff00;
        size = iVar1 + 0x102U & 0xffffff00;
        if (size < uVar6 || size + uVar3 * -0x100 == 0) {
LAB_080e656b:
          puVar5 = string->source;
          if (puVar5 == (uchar *)0x0) goto LAB_080e660a;
          *(undefined2 *)(puVar5 + string->length) = 0x2326;
          string->source[iVar1 + 2] = '\0';
          string->length = iVar1 + 2;
          psVar4 = add_long_to_string(string,(uint)src[iVar7]);
          if ((psVar4 != (string *)0x0) &&
             (psVar4 = add_char_to_string(string,';'), psVar4 != (string *)0x0)) goto LAB_080e65bd;
        }
        else {
          puVar5 = (uchar *)mem_realloc(string->source,size);
          if (puVar5 != (uchar *)0x0) {
            string->source = puVar5;
            memset(puVar5 + uVar6,0,size + uVar3 * -0x100);
            goto LAB_080e656b;
          }
        }
        puVar5 = string->source;
LAB_080e660a:
        string->length = iVar2;
        puVar5[iVar2] = '\0';
        return (string *)0x0;
      }
      psVar4 = add_char_to_string(string,character);
      if (psVar4 == (string *)0x0) {
        return (string *)0x0;
      }
LAB_080e65bd:
      iVar7 = iVar7 + 1;
    } while (iVar7 != len);
  }
  return string;
}



// WARNING: Removing unreachable block (ram,0x080e67c0)
// WARNING: Removing unreachable block (ram,0x080e68ca)
// WARNING: Unknown calling convention

string * add_xnum_to_string(string *string,off_t xnum)

{
  bool bVar1;
  byte bVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  bool bVar6;
  longlong lVar7;
  long local_34;
  uchar suff [3];
  
  suff[0] = '\0';
  suff[1] = 'i';
  suff[2] = '\0';
  if (xnum < 0x100000) {
    if (xnum < 0x400) {
      bVar1 = false;
      local_34 = -1;
      goto LAB_080e6751;
    }
    lVar7 = xnum * 10;
    xnum = xnum >> 10;
    suff[0] = 'K';
    suff[1] = 'i';
    iVar4 = (int)((ulonglong)lVar7 >> 0x20);
    lVar7 = __moddi3((uint)lVar7 >> 10 | iVar4 * 0x400000,iVar4 >> 10,10,0);
  }
  else {
    lVar7 = (xnum & 0xffffffffU) * 10;
    uVar3 = (uint)lVar7;
    iVar4 = xnum._4_4_ * 10 + (int)((ulonglong)lVar7 >> 0x20);
    uVar5 = iVar4 >> 0x1f & 0xfffff;
    iVar4 = iVar4 + (uint)CARRY4(uVar5,uVar3);
    xnum = xnum >> 0x14;
    suff[0] = 'M';
    suff[1] = 'i';
    lVar7 = __moddi3(uVar5 + uVar3 >> 0x14 | iVar4 * 0x1000,iVar4 >> 0x14,10,0);
  }
  local_34 = (long)lVar7;
  bVar2 = 1;
  if (-1 < xnum) {
    if (xnum < 0x100000000) {
      if (9 < (uint)xnum) {
        bVar2 = 0;
      }
    }
    else {
      bVar2 = 0;
    }
  }
  bVar1 = (bool)(lVar7 != -1 & bVar2);
LAB_080e6751:
  if ((assert_failed == 0) &&
     (bVar6 = (int)xnum >> 0x1f != (int)((ulonglong)xnum >> 0x20), assert_failed = (int)bVar6, bVar6
     )) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
    errline = 0xc2;
    elinks_internal((uchar *)"assertion xnum == (long) xnum failed!");
  }
  add_long_to_string(string,(int)xnum);
  if (bVar1) {
    add_char_to_string(string,'.');
    add_long_to_string(string,local_34);
  }
  add_char_to_string(string,' ');
  if (suff[0] != '\0') {
    add_to_string(string,suff);
  }
  add_char_to_string(string,'B');
  return string;
}



// WARNING: Unknown calling convention

int env_set(uchar *name,uchar *value,int length)

{
  int ret;
  size_t sVar1;
  uchar *__value;
  int iVar2;
  
  if (((value != (uchar *)0x0) && (name != (uchar *)0x0)) && (*name != '\0')) {
    sVar1 = strlen((char *)value);
    if (((uint)~length >> 0x1f & (uint)(length < (int)sVar1)) == 0) {
      iVar2 = setenv((char *)name,(char *)value,1);
      return iVar2;
    }
    __value = memacpy(value,length);
    if (__value != (uchar *)0x0) {
      ret = setenv((char *)name,(char *)__value,1);
      mem_free(__value);
      return ret;
    }
  }
  ret = -1;
  return ret;
}



// WARNING: Unknown calling convention

void do_not_optimize_here(void *p)

{
  return;
}



// WARNING: Unknown calling convention

void dump_backtrace(FILE *f,int trouble)

{
  void **ppvVar1;
  uint uVar2;
  void *__ptr;
  int iVar3;
  char **strings;
  uint uVar4;
  size_t i;
  void *stack [20];
  
  uVar2 = backtrace(stack,0x14);
  if (trouble == 0) {
    __ptr = (void *)backtrace_symbols(stack,uVar2);
    __fprintf_chk(f,1,"Obtained %d stack frames:\n",uVar2);
    if (uVar2 != 0) {
      uVar4 = 0;
      do {
        iVar3 = uVar4 * 4;
        ppvVar1 = stack + uVar4;
        uVar4 = uVar4 + 1;
        __fprintf_chk(f,1,"[%p] %s\n",*ppvVar1,*(undefined4 *)((int)__ptr + iVar3));
      } while (uVar4 < uVar2);
    }
    free(__ptr);
    fflush((FILE *)f);
    return;
  }
  iVar3 = fileno((FILE *)f);
  backtrace_symbols_fd(stack,uVar2,iVar3);
  return;
}



// WARNING: Unknown calling convention

void usrerror(uchar *fmt,...)

{
  fwrite("ELinks: ",1,8,stderr);
  __vfprintf_chk(stderr,1,fmt,&stack0x00000008);
  fputc(10,stderr);
  fflush(stderr);
  return;
}



// WARNING: Unknown calling convention

void er(int bell,int shall_sleep,uchar *fmt,va_list params)

{
  if (bell != 0) {
    fputc(7,stderr);
  }
  __vfprintf_chk(stderr,1,fmt,params);
  fputc(10,stderr);
  fflush(stderr);
  if (shall_sleep == 0) {
    return;
  }
  sleep(1);
  return;
}



// WARNING: Unknown calling convention

void elinks_internal(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,&DAT_08125598,errfile,errline,fmt);
  er(1,1,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void elinks_assertm(int x,uchar *fmt,...)

{
  void *local_10 [3];
  
  local_10[0] = (void *)0x0;
  if ((assert_failed == 0) && (assert_failed = (int)(x == 0), assert_failed != 0)) {
    __vasprintf_chk(local_10,1,fmt,&stack0x0000000c);
    elinks_internal((uchar *)"assertion failed: %s",local_10[0]);
    if (local_10[0] != (void *)0x0) {
      free(local_10[0]);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void elinks_error(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,"ERROR at %s:%d: %s",errfile,errline,fmt);
  er(1,1,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void elinks_wdebug(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,"DEBUG MESSAGE at %s:%d: %s",errfile,errline,fmt);
  er(0,1,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void elinks_debug(uchar *fmt,...)

{
  int iVar1;
  int in_GS_OFFSET;
  uchar errbuf [4096];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(errbuf,0x1000,1,0x1000,"DEBUG MESSAGE at %s:%d: %s",errfile,errline,fmt);
  er(0,0,errbuf,&stack0x00000008);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void fastfind_done(fastfind_index *index)

{
  void **p_00;
  void *p_01;
  void *p;
  void *pvVar1;
  void *p_2;
  void *p_02;
  void *p_1;
  fastfind_info *info;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(index == (fastfind_index *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 0x283;
    elinks_internal((uchar *)"assertion index failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  p_00 = (void **)index->handle;
  if (p_00 != (void **)0x0) {
    if (*p_00 != (void *)0x0) {
      mem_free(*p_00);
    }
    pvVar1 = p_00[8];
    if (pvVar1 == (void *)0x0) {
      p_02 = p_00[1];
    }
    else {
      p_02 = p_00[1];
      do {
        p_01 = *(void **)((int)p_02 + (int)pvVar1 * 4);
        if (p_01 != (void *)0x0) {
          mem_free(p_01);
          pvVar1 = p_00[8];
          p_02 = p_00[1];
        }
        pvVar1 = (void *)((int)pvVar1 + -1);
        p_00[8] = pvVar1;
      } while (pvVar1 != (void *)0x0);
    }
    if (p_02 != (void *)0x0) {
      mem_free(p_02);
    }
    mem_free(p_00);
    index->handle = (void *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void * fastfind_search(fastfind_index *index,uchar *key,int key_len)

{
  byte bVar1;
  int *piVar2;
  int __res;
  __int32_t **pp_Var3;
  ff_data *data;
  ff_data *data_1;
  int iVar4;
  ff_data *data_2;
  int i;
  int iVar5;
  ff_node_c *current;
  uint *puVar6;
  fastfind_info *info;
  int lidx;
  uint uVar7;
  int i_1;
  
  if (assert_failed == 0) {
    assert_failed = (int)(index == (fastfind_index *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x25a;
      elinks_internal((uchar *)"assertion index failed!");
      if (assert_failed != 0) goto LAB_080e6fe0;
    }
    piVar2 = (int *)index->handle;
    assert_failed = (int)(piVar2 == (int *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x25f;
      elinks_internal((uchar *)"assertion info != NULL failed: FastFind index %s not initialized",
                      index->comment);
      if (assert_failed != 0) goto LAB_080e6fe0;
    }
    if (((key != (uchar *)0x0) && (key_len <= piVar2[4])) && (piVar2[3] <= key_len)) {
      puVar6 = (uint *)piVar2[2];
      if ((*(byte *)(piVar2 + 9) & 1) == 0) {
        if ((*(byte *)(piVar2 + 9) & 2) == 0) {
          if (0 < key_len) {
            pp_Var3 = __ctype_toupper_loc();
            iVar5 = 0;
            do {
              if (0x7f < (*pp_Var3)[key[iVar5]]) {
                return (void *)0x0;
              }
              uVar7 = piVar2[(*pp_Var3)[key[iVar5]] + 10];
              if ((int)uVar7 < 0) {
                return (void *)0x0;
              }
              bVar1 = *(byte *)puVar6;
              if ((bVar1 & 2) == 0) {
                puVar6 = puVar6 + uVar7;
                bVar1 = *(byte *)puVar6;
              }
              else if (*(byte *)((int)puVar6 + 3) >> 1 != uVar7) {
                return (void *)0x0;
              }
              if (((bVar1 & 1) != 0) &&
                 (data = (ff_data *)((*(ushort *)puVar6 >> 2 & 0x3ff) * 8 + *piVar2), data_2 = data,
                 data->keylen == key_len)) goto LAB_080e71c8;
              if ((*puVar6 & 0x1fff000) == 0) {
                return (void *)0x0;
              }
              iVar5 = iVar5 + 1;
              puVar6 = *(uint **)((*puVar6 >> 10 & 0x7ffc) + piVar2[1]);
            } while (iVar5 < key_len);
          }
        }
        else if (0 < key_len) {
          iVar5 = 0;
          do {
            iVar4 = c_toupper((uint)key[iVar5]);
            if (0x7f < iVar4) {
              return (void *)0x0;
            }
            uVar7 = piVar2[iVar4 + 10];
            if ((int)uVar7 < 0) {
              return (void *)0x0;
            }
            bVar1 = *(byte *)puVar6;
            if ((bVar1 & 2) == 0) {
              puVar6 = puVar6 + uVar7;
              bVar1 = *(byte *)puVar6;
            }
            else if (*(byte *)((int)puVar6 + 3) >> 1 != uVar7) {
              return (void *)0x0;
            }
            if (((bVar1 & 1) != 0) &&
               (data_1 = (ff_data *)((*(ushort *)puVar6 >> 2 & 0x3ff) * 8 + *piVar2),
               data_2 = data_1, data_1->keylen == key_len)) goto LAB_080e71c8;
            if ((*puVar6 & 0x1fff000) == 0) {
              return (void *)0x0;
            }
            iVar5 = iVar5 + 1;
            puVar6 = *(uint **)((*puVar6 >> 10 & 0x7ffc) + piVar2[1]);
          } while (iVar5 < key_len);
        }
      }
      else if (((0 < key_len) && (*key < 0x80)) && (uVar7 = piVar2[*key + 10], -1 < (int)uVar7)) {
        iVar5 = 0;
        while( true ) {
          bVar1 = *(byte *)puVar6;
          if ((bVar1 & 2) == 0) {
            puVar6 = puVar6 + uVar7;
            bVar1 = *(byte *)puVar6;
          }
          else if (*(byte *)((int)puVar6 + 3) >> 1 != uVar7) {
            return (void *)0x0;
          }
          if (((bVar1 & 1) != 0) &&
             (data_2 = (ff_data *)((*(ushort *)puVar6 >> 2 & 0x3ff) * 8 + *piVar2),
             data_2->keylen == key_len)) break;
          if ((*puVar6 & 0x1fff000) == 0) {
            return (void *)0x0;
          }
          iVar5 = iVar5 + 1;
          puVar6 = *(uint **)((*puVar6 >> 10 & 0x7ffc) + piVar2[1]);
          if (key_len <= iVar5) {
            return (void *)0x0;
          }
          if (0x7f < key[iVar5]) {
            return (void *)0x0;
          }
          uVar7 = piVar2[key[iVar5] + 10];
          if ((int)uVar7 < 0) {
            return (void *)0x0;
          }
        }
LAB_080e71c8:
        return data_2->pointer;
      }
    }
  }
  else {
LAB_080e6fe0:
    assert_failed = 0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

int alloc_leafset(fastfind_info *info)

{
  ff_node_c **ppfVar1;
  ff_node_c *pfVar2;
  int iVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  assert_failed = (int)(0x1ffe < info->leafsets_count);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 0x158;
    elinks_internal((uchar *)"assertion info->leafsets_count < FF_MAX_LEAFSETS failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  ppfVar1 = (ff_node_c **)mem_realloc(info->leafsets,info->leafsets_count * 4 + 8);
  if (ppfVar1 != (ff_node_c **)0x0) {
    info->leafsets = ppfVar1;
    pfVar2 = (ff_node_c *)mem_calloc(info->uniq_chars_count,4);
    if (pfVar2 != (ff_node_c *)0x0) {
      iVar3 = info->leafsets_count + 1;
      info->leafsets_count = iVar3;
      info->leafsets[iVar3] = pfVar2;
      return 1;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void compress_tree(ff_node_c *leafset,fastfind_info *info)

{
  byte bVar1;
  ff_node_c fVar2;
  ff_node_c *new;
  uint *puVar3;
  int iVar4;
  int cnt;
  uint **ppuVar5;
  ff_node_c *pfVar6;
  int iVar7;
  int i;
  int local_20;
  
  if (assert_failed == 0) {
    assert_failed = (int)(info == (fastfind_info *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x19c;
      elinks_internal((uchar *)"assertion info failed!");
      if (assert_failed != 0) goto LAB_080e7420;
    }
    if (0 < info->uniq_chars_count) {
      iVar7 = 0;
      iVar4 = 0;
      local_20 = 0;
      pfVar6 = leafset;
      do {
        if ((*(byte *)pfVar6 & 2) == 0) {
          fVar2 = *pfVar6;
          if (((uint)fVar2 & 0x1fff000) != 0) {
            compress_tree(info->leafsets[(uint)fVar2 >> 0xc & 0x1fff],info);
            fVar2 = *pfVar6;
          }
          if (((uint)fVar2 & 0x1fff001) != 0) {
            iVar4 = iVar4 + 1;
            local_20 = iVar7;
          }
        }
        iVar7 = iVar7 + 1;
        pfVar6 = pfVar6 + 1;
      } while (info->uniq_chars_count != iVar7 && iVar7 <= info->uniq_chars_count);
      if (((iVar4 == 1) && (pfVar6 = leafset + local_20, (*(byte *)pfVar6 & 2) == 0)) &&
         (1 < info->leafsets_count)) {
        iVar4 = 4;
        if (info->leafsets[1] != leafset) {
          iVar7 = 1;
          do {
            iVar7 = iVar7 + 1;
            if (info->leafsets_count <= iVar7) {
              return;
            }
            iVar4 = iVar7 * 4;
          } while (info->leafsets[iVar7] != leafset);
        }
        puVar3 = (uint *)mem_alloc(4);
        if (puVar3 != (uint *)0x0) {
          bVar1 = *(byte *)puVar3;
          *(byte *)puVar3 = bVar1 | 2;
          *(byte *)puVar3 = bVar1 & 0xfe | 2 | *(byte *)pfVar6 & 1;
          *(ushort *)puVar3 = *(ushort *)puVar3 & 0xf003 | *(ushort *)pfVar6 & 0xffc;
          fVar2 = *pfVar6;
          *puVar3 = *puVar3 & 0xfe000fff | (uint)fVar2 & 0x1fff000;
          *(byte *)((int)puVar3 + 3) = fVar2._3_1_ & 1 | (char)local_20 * '\x02';
          ppuVar5 = (uint **)((int)info->leafsets + iVar4);
          if (*ppuVar5 != (uint *)0x0) {
            mem_free(*ppuVar5);
            ppuVar5 = (uint **)((int)info->leafsets + iVar4);
          }
          *ppuVar5 = puVar3;
        }
      }
    }
  }
  else {
LAB_080e7420:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

fastfind_index * fastfind_index(fastfind_index *index,fastfind_flags flags)

{
  size_t __n;
  bool bVar1;
  fastfind_info *info_00;
  fastfind_info *info;
  fastfind_key_value *pfVar2;
  size_t sVar3;
  void *pvVar4;
  __int32_t **pp_Var5;
  uint uVar6;
  ff_data *pfVar7;
  ff_data *data;
  int __res;
  ff_node_c fVar8;
  int __res_1;
  int iVar9;
  ff_node_c *leafset;
  uchar *puVar10;
  ff_node_c *pfVar11;
  int i;
  int iVar12;
  int i_1;
  int i_2;
  int k;
  
  if (assert_failed != 0) goto LAB_080e76d2;
  if (((index == (fastfind_index *)0x0) || (index->reset == (_func_void *)0x0)) ||
     (index->next == (_func_fastfind_key_value_ptr *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 0x1c0;
    elinks_internal((uchar *)"assertion index && index->reset && index->next failed!");
    if (assert_failed != 0) goto LAB_080e76d2;
  }
  else {
    assert_failed = 0;
  }
  info_00 = (fastfind_info *)mem_calloc(1,0x2a8);
  index->handle = info_00;
  if (info_00 == (fastfind_info *)0x0) goto return_error;
  info_00->min_key_len = 0xff;
  info_00->field_0x24 =
       info_00->field_0x24 & 0xf8 | (byte)flags & 1 | ((byte)(flags >> 2) & 1) * '\x02' |
       ((byte)(flags >> 1) & 1) * '\x04';
  (*index->reset)();
  puVar10 = info_00->uniq_chars;
  while (pfVar2 = (*index->next)(), pfVar2 != (fastfind_key_value *)0x0) {
    sVar3 = strlen((char *)pfVar2->key);
    if (assert_failed != 0) goto LAB_080e76d2;
    bVar1 = 0xfe < sVar3 - 1;
    assert_failed = (int)bVar1;
    if (bVar1) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x1cd;
      elinks_internal((uchar *)"assertion key_len > 0 && key_len <= FF_MAX_KEYLEN failed!");
      if (assert_failed != 0) goto LAB_080e76d2;
    }
    if ((int)sVar3 < info_00->min_key_len) {
      info_00->min_key_len = sVar3;
    }
    if (info_00->max_key_len < (int)sVar3) {
      info_00->max_key_len = sVar3;
    }
    if (0 < (int)sVar3) {
      iVar12 = 0;
      do {
        while( true ) {
          if ((info_00->field_0x24 & 1) == 0) {
            if ((info_00->field_0x24 & 2) == 0) {
              pp_Var5 = __ctype_toupper_loc();
              uVar6 = (*pp_Var5)[pfVar2->key[iVar12]];
            }
            else {
              uVar6 = c_toupper((uint)pfVar2->key[iVar12]);
            }
          }
          else {
            uVar6 = (uint)pfVar2->key[iVar12];
          }
          if (assert_failed != 0) goto LAB_080e76d2;
          assert_failed = (int)(0x7f < (int)uVar6);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
            errline = 0x1dd;
            elinks_internal((uchar *)"assertion k < FF_MAX_CHARS failed!");
            if (assert_failed != 0) goto LAB_080e76d2;
          }
          __n = info_00->uniq_chars_count;
          pvVar4 = memchr(puVar10,uVar6 & 0xff,__n);
          if ((pvVar4 == (void *)0x0) || ((int)pvVar4 - (int)puVar10 == -1)) break;
          iVar12 = iVar12 + 1;
          if ((int)sVar3 <= iVar12) goto LAB_080e7777;
        }
        assert_failed = (int)(0x7f < (int)__n);
        if (assert_failed != 0) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
          errline = 0x1e1;
          elinks_internal((uchar *)"assertion info->uniq_chars_count < FF_MAX_CHARS failed!");
          if (assert_failed != 0) goto LAB_080e76d2;
        }
        iVar9 = info_00->uniq_chars_count;
        iVar12 = iVar12 + 1;
        info_00->uniq_chars[iVar9] = (uchar)uVar6;
        info_00->uniq_chars_count = iVar9 + 1;
      } while (iVar12 < (int)sVar3);
    }
LAB_080e7777:
    info_00->count = info_00->count + 1;
  }
  iVar12 = 0;
  if (info_00->count == 0) {
    return (fastfind_index *)0x0;
  }
  do {
    pvVar4 = memchr(puVar10,iVar12,info_00->uniq_chars_count);
    iVar9 = (int)pvVar4 - (int)puVar10;
    if (pvVar4 == (void *)0x0) {
      iVar9 = -1;
    }
    info_00->idxtab[iVar12] = iVar9;
    iVar12 = iVar12 + 1;
  } while (iVar12 != 0x80);
  iVar12 = alloc_leafset(info_00);
  if (iVar12 == 0) goto return_error;
  info_00->root_leafset = info_00->leafsets[info_00->leafsets_count];
  if (assert_failed == 0) {
    assert_failed = (int)(0x3ff < info_00->count);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 0x138;
      elinks_internal((uchar *)"assertion info->count < FF_MAX_KEYS failed!");
      if (assert_failed != 0) goto LAB_080e76d2;
    }
    pfVar7 = (ff_data *)mem_calloc(info_00->count,8);
    if (pfVar7 != (ff_data *)0x0) {
      info_00->data = pfVar7;
      (*index->reset)();
LAB_080e78d7:
      pfVar2 = (*index->next)();
      if (pfVar2 == (fastfind_key_value *)0x0) {
        if ((info_00->field_0x24 & 4) != 0) {
          compress_tree(info_00->root_leafset,info_00);
          return index;
        }
        return index;
      }
      iVar12 = 0;
      puVar10 = pfVar2->key;
      sVar3 = strlen((char *)puVar10);
      iVar9 = 0;
      pfVar11 = info_00->root_leafset;
      if (0 < (int)(sVar3 - 1)) {
        do {
          if ((info_00->field_0x24 & 1) == 0) {
            if ((info_00->field_0x24 & 2) != 0) {
              __res = c_toupper((uint)puVar10[iVar12]);
              goto LAB_080e791c;
            }
            pp_Var5 = __ctype_toupper_loc();
            pfVar11 = pfVar11 + info_00->idxtab[(*pp_Var5)[puVar10[iVar12]]];
            fVar8 = *pfVar11;
            if (((uint)fVar8 & 0x1fff000) != 0) goto LAB_080e792c;
LAB_080e7977:
            iVar9 = alloc_leafset(info_00);
            if (iVar9 == 0) goto return_error;
            uVar6 = *(ushort *)&info_00->leafsets_count & 0x1fff;
            *pfVar11 = (ff_node_c)((uint)*pfVar11 & 0xfe000fff | uVar6 << 0xc);
          }
          else {
            __res = (int)puVar10[iVar12];
LAB_080e791c:
            pfVar11 = pfVar11 + info_00->idxtab[__res];
            fVar8 = *pfVar11;
            if (((uint)fVar8 & 0x1fff000) == 0) goto LAB_080e7977;
LAB_080e792c:
            uVar6 = (uint)fVar8 >> 0xc & 0x1fff;
          }
          iVar9 = iVar12 + 1;
          pfVar11 = info_00->leafsets[uVar6];
          if ((int)(sVar3 - 1) <= iVar9) goto LAB_080e79b3;
          puVar10 = pfVar2->key;
          iVar12 = iVar9;
        } while( true );
      }
      goto LAB_080e79bc;
    }
  }
  else {
LAB_080e76d2:
    assert_failed = 0;
  }
return_error:
  fastfind_done(index);
  return (fastfind_index *)0x0;
LAB_080e79b3:
  puVar10 = pfVar2->key;
LAB_080e79bc:
  if ((info_00->field_0x24 & 1) == 0) {
    if ((info_00->field_0x24 & 2) == 0) {
      pp_Var5 = __ctype_toupper_loc();
      __res_1 = (*pp_Var5)[puVar10[iVar9]];
    }
    else {
      __res_1 = c_toupper((uint)puVar10[iVar9]);
    }
  }
  else {
    __res_1 = (int)puVar10[iVar9];
  }
  pfVar11 = pfVar11 + info_00->idxtab[__res_1];
  *(byte *)pfVar11 = *(byte *)pfVar11 | 1;
  *(ushort *)pfVar11 =
       *(ushort *)pfVar11 & 0xf003 | (ushort)((info_00->pointers_count & 0xffff03ffU) << 2);
  pvVar4 = pfVar2->data;
  iVar12 = info_00->pointers_count;
  pfVar7 = info_00->data;
  info_00->pointers_count = iVar12 + 1;
  pfVar7[iVar12].pointer = pvVar4;
  pfVar7[iVar12].keylen = sVar3;
  goto LAB_080e78d7;
}



// WARNING: Unknown calling convention

int mkalldirs(uchar *path)

{
  char cVar1;
  size_t sVar2;
  char *__path;
  int *piVar3;
  char *pcVar4;
  int ret;
  int iVar5;
  char *pcVar6;
  uchar *p;
  
  if (*path != '\0') {
    sVar2 = strlen((char *)path);
    __path = (char *)mem_alloc(sVar2 + 1);
    if (__path != (char *)0x0) {
      iVar5 = 0;
      memcpy(__path,path,sVar2 + 1);
      cVar1 = __path[1];
      if (cVar1 != '\0') {
        pcVar4 = __path + 1;
        pcVar6 = __path + 2;
        do {
          if (cVar1 == '/') {
            *pcVar4 = '\0';
            iVar5 = mkdir(__path,0x1c0);
            *pcVar4 = '/';
            if (iVar5 < 0) {
              piVar3 = __errno_location();
              if (*piVar3 != 0x11) break;
              iVar5 = 0;
            }
          }
          cVar1 = *pcVar6;
          pcVar4 = pcVar6;
          pcVar6 = pcVar6 + 1;
        } while (cVar1 != '\0');
      }
      mem_free(__path);
      return iVar5;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

directory_entry * get_directory_entries(uchar *dirname,int get_hidden)

{
  DIR *__dirp;
  DIR *directory;
  dirent64 *pdVar1;
  dirent *entry;
  directory_entry *pdVar2;
  uchar *__filename;
  string *psVar3;
  int iVar4;
  uint uVar5;
  mode_t m;
  passwd *ppVar6;
  passwd *pwd;
  group *pgVar7;
  group *grp;
  time_t tVar8;
  time_t current_time;
  int width;
  uint shift;
  uchar *fmt;
  uchar character;
  mode_t mode;
  directory_entry *entries;
  int in_GS_OFFSET;
  uint local_e4;
  directory_entry *local_d8;
  size_t local_d4;
  stat st;
  string attrib;
  __time_t local_64;
  uchar size [64];
  int local_20;
  
  local_20 = *(int *)(in_GS_OFFSET + 0x14);
  local_e4 = 0;
  if (*dirname == '/') {
    local_e4 = (uint)(dirname[1] == '\0');
  }
  __dirp = opendir((char *)dirname);
  local_d4 = 0;
  local_d8 = (directory_entry *)0x0;
  pdVar2 = (directory_entry *)0x0;
  if (__dirp != (DIR *)0x0) {
LAB_080e7bd8:
    pdVar1 = readdir64(__dirp);
    if (pdVar1 != (dirent64 *)0x0) {
      while( true ) {
        if (pdVar1->d_name[0] == '.') {
          if (pdVar1->d_name[1] == '\0') goto LAB_080e7bd8;
          if ((pdVar1->d_name[1] != '.') || (uVar5 = local_e4 ^ 1, pdVar1->d_name[2] != '\0')) {
            uVar5 = get_hidden;
          }
          if (uVar5 == 0) goto LAB_080e7bd8;
        }
        pdVar2 = (directory_entry *)mem_realloc(local_d8,local_d4 * 8 + 0x10);
        if ((pdVar2 == (directory_entry *)0x0) ||
           (__filename = straconcat(dirname,pdVar1->d_name,0), local_d8 = pdVar2,
           __filename == (uchar *)0x0)) goto LAB_080e7bd8;
        psVar3 = init_string(&attrib);
        if (psVar3 == (string *)0x0) break;
        iVar4 = __lxstat64(3,(char *)__filename,(stat64 *)&st);
        if (iVar4 == 0) {
          character = 'd';
          uVar5 = st.st_mode & 0xf000;
          if (((((uVar5 != 0x4000) && (character = '-', uVar5 != 0x8000)) &&
               (character = 'b', uVar5 != 0x6000)) &&
              ((character = 'c', uVar5 != 0x2000 && (character = 'p', uVar5 != 0x1000)))) &&
             ((character = 'l', uVar5 != 0xa000 && (character = '?', uVar5 == 0xc000)))) {
            character = 's';
          }
          add_char_to_string(&attrib,character);
          iVar4 = 0;
          size[0] = '-';
          size[1] = '-';
          size[2] = '-';
          size[3] = '-';
          size[4] = '-';
          size[5] = '-';
          size[6] = '-';
          size[7] = '-';
          size[8] = '-';
          size[9] = '\0';
          do {
            uVar5 = st.st_mode << ((byte)iVar4 & 0x1f);
            if ((uVar5 & 0x100) != 0) {
              size[iVar4] = 'r';
            }
            if ((char)uVar5 < '\0') {
              size[iVar4 + 1] = 'w';
            }
            if ((uVar5 & 0x40) != 0) {
              size[iVar4 + 2] = 'x';
            }
            iVar4 = iVar4 + 3;
          } while (iVar4 != 9);
          if ((st.st_mode & 0x800) != 0) {
            size[2] = (-((st.st_mode & 0x40) == 0) & 0xe0U) + 0x73;
          }
          if ((st.st_mode & 0x400) != 0) {
            size._4_2_ = CONCAT11((-((st.st_mode & 8) == 0) & 0xe0U) + 0x73,size[4]);
          }
          if ((st.st_mode & 0x200) != 0) {
            size[8] = (-((st.st_mode & 1) == 0) & 0xe0U) + 0x74;
          }
          add_to_string(&attrib,size);
          add_char_to_string(&attrib,' ');
          elinks_ulongcat(size,(uint *)0x0,st.st_nlink,3,' ',10,0);
          add_to_string(&attrib,size);
          add_char_to_string(&attrib,' ');
          if (st.st_uid != stat_user::last_uid) {
            ppVar6 = getpwuid(st.st_uid);
            if ((ppVar6 == (passwd *)0x0) || (ppVar6->pw_name == (char *)0x0)) {
              __sprintf_chk(stat_user::last_user,1,0x40,&DAT_08134f9e,st.st_uid);
            }
            else {
              __sprintf_chk(stat_user::last_user,1,0x40,"%-8.8s",ppVar6->pw_name);
            }
            stat_user::last_uid = st.st_uid;
          }
          add_to_string(&attrib,stat_user::last_user);
          add_char_to_string(&attrib,' ');
          if (st.st_gid != stat_group::last_gid) {
            pgVar7 = getgrgid(st.st_gid);
            if ((pgVar7 == (group *)0x0) || (pgVar7->gr_name == (char *)0x0)) {
              __sprintf_chk(stat_group::last_group,1,0x40,&DAT_08134f9e,st.st_gid);
            }
            else {
              __sprintf_chk(stat_group::last_group,1,0x40,"%-8.8s",pgVar7->gr_name);
            }
            stat_group::last_gid = st.st_gid;
          }
          add_to_string(&attrib,stat_group::last_group);
          add_char_to_string(&attrib,' ');
          if (st.st_size._4_4_ == 0) {
            uVar5 = elinks_ulongcat(size,(uint *)0x0,(ulong)st.st_size,9,' ',10,0);
            if (uVar5 - 1 < 0x3f) {
              elinks_ulongcat(size,(uint *)0x0,(ulong)st.st_size,uVar5,' ',10,0);
            }
            add_to_string(&attrib,size);
            add_char_to_string(&attrib,' ');
          }
          else {
            add_to_string(&attrib,"         ");
          }
          tVar8 = time((time_t *)0x0);
          if ((st.st_mtim.tv_sec + 0xed4e00 < tVar8) ||
             (fmt = "%b %e %H:%M", tVar8 < st.st_mtim.tv_sec + -0xe10)) {
            fmt = "%b %e  %Y";
          }
          local_64 = st.st_mtim.tv_sec;
          add_date_to_string(&attrib,fmt,&local_64);
          add_char_to_string(&attrib,' ');
        }
        else {
          add_char_to_string(&attrib,'?');
          size[0] = '-';
          size[1] = '-';
          size[2] = '-';
          size[3] = '-';
          size[4] = '-';
          size[5] = '-';
          size[6] = '-';
          size[7] = '-';
          size[8] = '-';
          size[9] = '\0';
          add_to_string(&attrib,size);
          add_char_to_string(&attrib,' ');
          add_to_string(&attrib,"    ");
          add_to_string(&attrib,"         ");
          add_to_string(&attrib,"         ");
          add_to_string(&attrib,"         ");
          add_to_string(&attrib,"             ");
        }
        pdVar2[local_d4].name = __filename;
        pdVar2[local_d4].attrib = attrib.source;
        local_d4 = local_d4 + 1;
        pdVar1 = readdir64(__dirp);
        if (pdVar1 == (dirent64 *)0x0) goto LAB_080e7f98;
      }
      mem_free(__filename);
      goto LAB_080e7bd8;
    }
LAB_080e7f98:
    closedir(__dirp);
    pdVar2 = local_d8;
    if (local_d4 == 0) {
      if (local_d8 != (directory_entry *)0x0) {
        pdVar2 = (directory_entry *)0x0;
        mem_free(local_d8);
      }
    }
    else {
      qsort(local_d8,local_d4,8,compare_dir_entries);
      local_d8[local_d4].attrib = (uchar *)0x0;
      local_d8[local_d4].name = (uchar *)0x0;
    }
  }
  if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return pdVar2;
}



// WARNING: Unknown calling convention

int compare_dir_entries(void *v1,void *v2)

{
  char *__s1;
  char *__s2;
  int iVar1;
  
  __s1 = *(char **)((int)v1 + 4);
  if (((*__s1 == '.') && (__s1[1] == '.')) && (__s1[2] == '\0')) {
LAB_080e82c0:
    iVar1 = -1;
  }
  else {
    __s2 = *(char **)((int)v2 + 4);
    if (((*__s2 != '.') || (__s2[1] != '.')) || (__s2[2] != '\0')) {
                    // WARNING: Load size is inaccurate
      if (**v1 == 'd') {
                    // WARNING: Load size is inaccurate
        if (**v2 == 'd') goto LAB_080e829b;
        goto LAB_080e82c0;
      }
                    // WARNING: Load size is inaccurate
      if (**v2 != 'd') {
LAB_080e829b:
        iVar1 = strcmp(__s1,__s2);
        return iVar1;
      }
    }
    iVar1 = 1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

int safe_mkstemp(uchar *template)

{
  __mode_t __mask;
  int iVar1;
  int fd;
  mode_t saved_mask;
  
  __mask = umask(0x7f);
  iVar1 = mkstemp64((char *)template);
  umask(__mask);
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * file_read_line(uchar *line,size_t *size,FILE *file,int *lineno)

{
  byte bVar1;
  size_t sVar2;
  char *pcVar3;
  uchar *linepos;
  ushort **ppuVar4;
  int __c;
  int next;
  byte *pbVar5;
  size_t sVar6;
  byte *pbVar7;
  size_t offset;
  
  if (line == (uchar *)0x0) {
    line = (uchar *)mem_alloc(0x400);
    if (line == (byte *)0x0) {
      return (uchar *)0x0;
    }
    *size = 0x400;
    sVar6 = 0x400;
  }
  else {
    sVar6 = *size;
  }
  pbVar7 = (byte *)0x0;
  while( true ) {
    pcVar3 = fgets((char *)(line + (int)pbVar7),sVar6 - (int)pbVar7,(FILE *)file);
    if (pcVar3 == (char *)0x0) break;
    pbVar7 = (byte *)strchr((char *)(line + (int)pbVar7),10);
    if (pbVar7 == (byte *)0x0) {
      __c = _IO_getc((_IO_FILE *)file);
      if (__c == -1) {
        *lineno = *lineno + 1;
        return line;
      }
      ungetc(__c,(FILE *)file);
      sVar2 = *size;
      sVar6 = sVar2 + 0x400;
      *size = sVar6;
      pbVar5 = (byte *)mem_realloc(line,sVar6);
      if (pbVar5 == (byte *)0x0) break;
      pbVar7 = (byte *)(sVar2 - 1);
    }
    else {
      *lineno = *lineno + 1;
      if (line < pbVar7) {
        ppuVar4 = __ctype_b_loc();
        do {
          bVar1 = *pbVar7;
          if ((*(byte *)((int)*ppuVar4 + (uint)bVar1 * 2 + 1) & 0x20) == 0) goto joined_r0x080e83be;
          pbVar7 = pbVar7 + -1;
        } while (line < pbVar7);
      }
      bVar1 = *pbVar7;
joined_r0x080e83be:
      if (bVar1 != 0x5c) {
        pbVar7[1] = 0;
        return line;
      }
      pbVar7 = pbVar7 + ~(uint)line;
      pbVar5 = line;
    }
    sVar6 = *size;
    line = pbVar5;
  }
  mem_free(line);
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_tempdir_filename(uchar *name)

{
  uchar *puVar1;
  uchar *tmpdir;
  
  puVar1 = (uchar *)getenv("TMPDIR");
  if ((puVar1 == (uchar *)0x0) || (*puVar1 == '\0')) {
    puVar1 = (uchar *)getenv("TMP");
    if ((puVar1 == (uchar *)0x0) || (*puVar1 == '\0')) {
      puVar1 = (uchar *)getenv("TEMPDIR");
      if ((puVar1 == (uchar *)0x0) || (*puVar1 == '\0')) {
        puVar1 = (uchar *)getenv("TEMP");
        if ((puVar1 == (uchar *)0x0) || (*puVar1 == '\0')) {
          puVar1 = "/tmp";
        }
      }
    }
  }
  puVar1 = straconcat(puVar1,&DAT_08132419,name,0);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * get_filename_position(uchar *filename)

{
  uchar uVar1;
  uchar *puVar2;
  bool bVar3;
  
  if (assert_failed == 0) {
    assert_failed = (int)(filename == (uchar *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/file.c";
      errline = 0x62;
      elinks_internal((uchar *)"assertion filename failed!");
      if (assert_failed != 0) goto LAB_080e8503;
    }
    uVar1 = *filename;
    puVar2 = filename;
    if (uVar1 != '\0') {
      do {
        puVar2 = puVar2 + 1;
        bVar3 = uVar1 == '/';
        uVar1 = *puVar2;
        if (bVar3) {
          filename = puVar2;
        }
      } while (uVar1 != '\0');
      return filename;
    }
  }
  else {
LAB_080e8503:
    assert_failed = 0;
    filename = (uchar *)0x0;
  }
  return filename;
}



// WARNING: Unknown calling convention

uchar * expand_tilde(uchar *filename)

{
  int iVar1;
  string *psVar2;
  passwd *passwd;
  passwd *ppVar3;
  uchar *puVar4;
  int userlen;
  int iVar5;
  string file;
  
  psVar2 = init_string(&file);
  puVar4 = (uchar *)0x0;
  if (psVar2 != (string *)0x0) {
    if (*filename == '~') {
      if ((filename[1] == '\0') || (iVar1 = 0, filename[1] == '/')) {
        puVar4 = (uchar *)getenv("HOME");
        if (puVar4 != (uchar *)0x0) {
          add_to_string(&file,puVar4);
          filename = filename + 1;
        }
      }
      else {
        do {
          iVar5 = iVar1;
          if (filename[iVar5 + 2] == '\0') break;
          iVar1 = iVar5 + 1;
        } while (filename[iVar5 + 2] != '/');
        puVar4 = memacpy(filename + 1,iVar5 + 1);
        if (puVar4 != (uchar *)0x0) {
          ppVar3 = getpwnam((char *)puVar4);
          mem_free(puVar4);
          if ((ppVar3 != (passwd *)0x0) && ((uchar *)ppVar3->pw_dir != (uchar *)0x0)) {
            add_to_string(&file,(uchar *)ppVar3->pw_dir);
            filename = filename + iVar5 + 2;
          }
        }
      }
    }
    add_to_string(&file,filename);
    puVar4 = file.source;
  }
  return puVar4;
}



// WARNING: Unknown calling convention

int file_is_dir(uchar *filename)

{
  int iVar1;
  uint uVar2;
  stat st;
  
  iVar1 = __xstat64(3,(char *)filename,(stat64 *)&st);
  uVar2 = 0;
  if (iVar1 == 0) {
    uVar2 = (uint)((st.st_mode & 0xf000) == 0x4000);
  }
  return uVar2;
}



// WARNING: Unknown calling convention

int file_can_read(uchar *filename)

{
  uint uVar1;
  
  uVar1 = access((char *)filename,4);
  return ~uVar1 >> 0x1f;
}



// WARNING: Unknown calling convention

int file_exists(uchar *filename)

{
  uint uVar1;
  
  uVar1 = access((char *)filename,0);
  return ~uVar1 >> 0x1f;
}



// WARNING: Unknown calling convention

uchar * get_unique_name(uchar *fileprefix)

{
  size_t __n;
  int iVar1;
  uchar *filename;
  int suffix;
  int number;
  uchar *file;
  int iVar2;
  int digits;
  int local_20;
  
  iVar2 = 0;
  __n = strlen((char *)fileprefix);
  local_20 = 1;
  number = 1;
  filename = fileprefix;
  do {
    iVar1 = file_exists(filename);
    if (iVar1 == 0) {
      return filename;
    }
    if (local_20 <= number) {
      if (9999 < number) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/file.c";
        errline = 0xa2;
        elinks_internal((uchar *)"Too big suffix in get_unique_name().");
      }
      iVar2 = iVar2 + 1;
      if (filename != fileprefix) {
        mem_free(filename);
      }
      filename = (uchar *)mem_alloc(__n + 2 + iVar2);
      if (filename == (uchar *)0x0) {
        return (uchar *)0x0;
      }
      local_20 = local_20 * 10;
      memcpy(filename,fileprefix,__n);
      filename[__n] = '.';
    }
    elinks_longcat(filename + __n + 1,(uint *)0x0,number,iVar2 + 1,'\0',10,0);
    number = number + 1;
  } while( true );
}



// WARNING: Unknown calling convention

hash_value_T strhash(uchar *k,uint length,hash_value_T initval)

{
  hash_value_T hVar1;
  bool bVar2;
  int iVar3;
  hash_value_T h;
  uint i;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return initval;
  }
  bVar2 = length == 0 || k == (uchar *)0x0;
  assert_failed = (int)bVar2;
  if (bVar2) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 0xa2;
    elinks_internal((uchar *)"assertion k && length > 0 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return initval;
    }
  }
  i = 0;
  h = initval;
  do {
    hVar1 = h * 0x1f + (uint)k[i];
    if (i + 1 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[i + 1];
    if (i + 2 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[i + 2];
    if (i + 3 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[i + 3];
    if (i + 4 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[i + 4];
    if (i + 5 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[i + 5];
    if (i + 6 == length) {
      return hVar1;
    }
    hVar1 = hVar1 * 0x1f + (uint)k[i + 6];
    if (i + 7 == length) {
      return hVar1;
    }
    iVar3 = i + 7;
    i = i + 8;
    h = hVar1 * 0x1f + (uint)k[iVar3];
  } while (length != i);
  return h;
}



// WARNING: Unknown calling convention

void del_hash_item(hash *hash,hash_item *item)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(item == (hash_item *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 0x8b;
    elinks_internal((uchar *)"assertion item failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  item->next->prev = item->prev;
  item->prev->next = item->next;
  mem_free(item);
  return;
}



// WARNING: Unknown calling convention

void free_hash(hash **hashp)

{
  hash *p;
  xlist_head *head;
  undefined4 *p_00;
  list_head_elinks *plVar1;
  xlist_head *next;
  undefined4 *puVar2;
  bool bVar3;
  uint local_24;
  uint local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((hashp == (hash **)0x0) || (*hashp == (hash *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion hashp && *hashp failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  p = *hashp;
  local_24 = p->width;
  plVar1 = p->hash;
  local_20 = 0;
  if (1 << ((byte)local_24 & 0x1f) != 0) {
    do {
      p_00 = (undefined4 *)p->hash[local_20].next;
      for (puVar2 = p_00; (list_head_elinks *)puVar2 != plVar1 + local_20;
          puVar2 = (undefined4 *)*puVar2) {
      }
      for (puVar2 = (undefined4 *)p->hash[local_20].prev;
          (list_head_elinks *)puVar2 != plVar1 + local_20; puVar2 = (undefined4 *)puVar2[1]) {
      }
      puVar2 = (undefined4 *)*p_00;
      if ((list_head_elinks *)p_00 != plVar1 + local_20) {
        do {
          puVar2[1] = p_00[1];
          *(undefined4 *)p_00[1] = *p_00;
          mem_free(p_00);
          p = *hashp;
          plVar1 = p->hash;
          bVar3 = plVar1 + local_20 != (list_head_elinks *)puVar2;
          p_00 = puVar2;
          puVar2 = (undefined4 *)*puVar2;
        } while (bVar3);
        local_24 = p->width;
      }
      local_20 = local_20 + 1;
    } while (local_20 < (uint)(1 << ((byte)local_24 & 0x1f)));
  }
  mem_free(p);
  *hashp = (hash *)0x0;
  return;
}



// WARNING: Unknown calling convention

hash_item * get_hash_item(hash *hash,uchar *key,uint keylen)

{
  hash_item *phVar1;
  hash_item *phVar2;
  hash_value_T hVar3;
  hash_item *item;
  uint uVar4;
  hash_value_T hashval;
  uint uVar5;
  uchar *puVar6;
  uchar *puVar7;
  bool bVar8;
  byte bVar9;
  
  bVar9 = 0;
  hVar3 = (*hash->func)(key,keylen,0xdeadbeef);
  uVar5 = hVar3 & (1 << ((byte)hash->width & 0x1f)) - 1U;
  phVar1 = (hash_item *)hash->hash[uVar5].next;
  phVar2 = phVar1;
  do {
    if (phVar2 == (hash_item *)(hash->hash + uVar5)) {
      return (hash_item *)0x0;
    }
    if (phVar2->keylen == keylen) {
      bVar8 = true;
      uVar4 = keylen;
      puVar6 = key;
      puVar7 = phVar2->key;
      do {
        if (uVar4 == 0) break;
        uVar4 = uVar4 - 1;
        bVar8 = *puVar6 == *puVar7;
        puVar6 = puVar6 + (uint)bVar9 * -2 + 1;
        puVar7 = puVar7 + (uint)bVar9 * -2 + 1;
      } while (bVar8);
      if (bVar8) {
        if (phVar2 == phVar1) {
          return phVar2;
        }
        phVar2->next->prev = phVar2->prev;
        phVar2->prev->next = phVar2->next;
        phVar2->next = (hash_item *)hash->hash[uVar5].next;
        phVar2->prev = (hash_item *)(hash->hash + uVar5);
        hash->hash[uVar5].next = phVar2;
        phVar2->next->prev = phVar2;
        return phVar2;
      }
    }
    phVar2 = phVar2->next;
  } while( true );
}



// WARNING: Unknown calling convention

hash_item * add_hash_item(hash *hash,uchar *key,uint keylen,void *value)

{
  hash_item *phVar1;
  uint uVar2;
  hash_item *phVar3;
  hash_item *phVar4;
  hash_item *item;
  hash_value_T hVar5;
  hash_value_T hashval;
  
  phVar4 = (hash_item *)mem_alloc(0x14);
  if (phVar4 != (hash_item *)0x0) {
    hVar5 = (*hash->func)(key,keylen,0xdeadbeef);
    uVar2 = hash->width;
    phVar4->key = key;
    phVar1 = (hash_item *)(hash->hash + (hVar5 & (1 << ((byte)uVar2 & 0x1f)) - 1U));
    phVar4->keylen = keylen;
    phVar4->value = value;
    phVar3 = phVar1->next;
    phVar4->prev = phVar1;
    phVar4->next = phVar3;
    phVar1->next = phVar4;
    phVar4->next->prev = phVar4;
  }
  return phVar4;
}



// WARNING: Unknown calling convention

hash * init_hash8(void)

{
  int iVar1;
  hash *phVar2;
  hash *hash;
  int iVar3;
  
  if (assert_failed == 0) {
    assert_failed = 0;
    phVar2 = (hash *)mem_alloc(0x808);
    if (phVar2 != (hash *)0x0) {
      phVar2->width = 8;
      iVar3 = 0;
      phVar2->func = strhash;
      do {
        iVar1 = (int)&phVar2->hash[0].next + iVar3;
        *(int *)((int)&phVar2->hash[0].prev + iVar3) = iVar1;
        *(int *)((int)&phVar2->hash[0].next + iVar3) = iVar1;
        iVar3 = iVar3 + 8;
      } while (iVar3 != 0x800);
    }
    return phVar2;
  }
  assert_failed = 0;
  return (hash *)0x0;
}



// WARNING: Unknown calling convention

void init_md5(md5_context *ctx)

{
  ctx->buf[0] = 0x67452301;
  ctx->buf[1] = 0xefcdab89;
  ctx->buf[2] = 0x98badcfe;
  ctx->buf[3] = 0x10325476;
  ctx->bits[0] = 0;
  ctx->bits[1] = 0;
  return;
}



// WARNING: Unknown calling convention

void transform_md5(uint32_t *buf,uint32_t *in)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint32_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  uint32_t uVar10;
  uint32_t uVar11;
  uint32_t uVar12;
  uint32_t uVar13;
  uint32_t uVar14;
  uint32_t uVar15;
  uint32_t uVar16;
  uint uVar17;
  uint32_t a;
  uint32_t d;
  uint uVar18;
  uint uVar19;
  uint uVar20;
  uint32_t b;
  uint uVar21;
  uint uVar22;
  uint32_t c;
  
  uVar1 = *in;
  uVar20 = buf[1];
  uVar21 = buf[2];
  uVar18 = buf[3];
  uVar17 = ((uVar18 ^ uVar21) & uVar20 ^ uVar18) + *buf + 0xd76aa478 + uVar1;
  uVar2 = in[1];
  uVar17 = (uVar17 >> 0x19 | uVar17 * 0x80) + uVar20;
  uVar18 = uVar18 + 0xe8c7b756 + uVar2 + ((uVar21 ^ uVar20) & uVar17 ^ uVar21);
  uVar3 = in[2];
  uVar19 = (uVar18 >> 0x14 | uVar18 * 0x1000) + uVar17;
  uVar21 = uVar21 + 0x242070db + uVar3 + ((uVar17 ^ uVar20) & uVar19 ^ uVar20);
  uVar4 = in[3];
  uVar18 = (uVar21 >> 0xf | uVar21 * 0x20000) + uVar19;
  uVar5 = in[4];
  uVar21 = ((uVar19 ^ uVar17) & uVar18 ^ uVar17) + uVar20 + 0xc1bdceee + uVar4;
  uVar22 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar18;
  uVar6 = in[5];
  uVar21 = ((uVar18 ^ uVar19) & uVar22 ^ uVar19) + uVar17 + 0xf57c0faf + uVar5;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar22;
  uVar7 = in[6];
  uVar20 = ((uVar22 ^ uVar18) & uVar21 ^ uVar18) + uVar19 + 0x4787c62a + uVar6;
  uVar8 = in[7];
  uVar17 = (uVar20 >> 0x14 | uVar20 * 0x1000) + uVar21;
  uVar20 = ((uVar21 ^ uVar22) & uVar17 ^ uVar22) + uVar18 + 0xa8304613 + uVar7;
  uVar20 = (uVar20 >> 0xf | uVar20 * 0x20000) + uVar17;
  uVar9 = in[8];
  uVar18 = ((uVar17 ^ uVar21) & uVar20 ^ uVar21) + uVar22 + 0xfd469501 + uVar8;
  uVar19 = (uVar18 >> 10 | uVar18 * 0x400000) + uVar20;
  uVar10 = in[9];
  uVar21 = ((uVar20 ^ uVar17) & uVar19 ^ uVar17) + uVar21 + 0x698098d8 + uVar9;
  uVar21 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar19;
  uVar11 = in[10];
  uVar18 = ((uVar19 ^ uVar20) & uVar21 ^ uVar20) + uVar17 + 0x8b44f7af + uVar10;
  uVar17 = (uVar18 >> 0x14 | uVar18 * 0x1000) + uVar21;
  uVar12 = in[0xb];
  uVar20 = ((uVar21 ^ uVar19) & uVar17 ^ uVar19) + (uVar20 - 0xa44f) + uVar11;
  uVar18 = (uVar20 >> 0xf | uVar20 * 0x20000) + uVar17;
  uVar13 = in[0xc];
  uVar20 = ((uVar17 ^ uVar21) & uVar18 ^ uVar21) + uVar19 + 0x895cd7be + uVar12;
  uVar22 = (uVar20 >> 10 | uVar20 * 0x400000) + uVar18;
  uVar14 = in[0xd];
  uVar21 = ((uVar18 ^ uVar17) & uVar22 ^ uVar17) + uVar21 + 0x6b901122 + uVar13;
  uVar20 = (uVar21 >> 0x19 | uVar21 * 0x80) + uVar22;
  uVar15 = in[0xe];
  uVar21 = ((uVar22 ^ uVar18) & uVar20 ^ uVar18) + uVar17 + 0xfd987193 + uVar14;
  uVar19 = (uVar21 >> 0x14 | uVar21 * 0x1000) + uVar20;
  uVar16 = in[0xf];
  uVar21 = ((uVar20 ^ uVar22) & uVar19 ^ uVar22) + uVar18 + 0xa679438e + uVar15;
  uVar18 = (uVar21 >> 0xf | uVar21 * 0x20000) + uVar19;
  uVar21 = uVar22 + 0x49b40821 + uVar16 + ((uVar19 ^ uVar20) & uVar18 ^ uVar20);
  uVar17 = (uVar21 >> 10 | uVar21 * 0x400000) + uVar18;
  uVar21 = uVar20 + 0xf61e2562 + uVar2 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0xc040b340 + uVar7 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0x265e5a51 + uVar12 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = uVar17 + 0xe9b6c7aa + uVar1 + ((uVar18 ^ uVar19) & uVar20 ^ uVar19);
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = uVar20 + 0xd62f105d + uVar6 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0x2441453 + uVar11 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0xd8a1e681 + uVar16 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = uVar17 + 0xe7d3fbc8 + uVar5 + ((uVar18 ^ uVar19) & uVar20 ^ uVar19);
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = uVar20 + 0x21e1cde6 + uVar10 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0xc33707d6 + uVar15 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0xf4d50d87 + uVar4 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = uVar17 + 0x455a14ed + uVar9 + ((uVar18 ^ uVar19) & uVar20 ^ uVar19);
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = uVar20 + 0xa9e3e905 + uVar14 + ((uVar17 ^ uVar18) & uVar19 ^ uVar18);
  uVar20 = (uVar21 >> 0x1b | uVar21 * 0x20) + uVar17;
  uVar21 = uVar19 + 0xfcefa3f8 + uVar3 + ((uVar20 ^ uVar17) & uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x17 | uVar21 * 0x200) + uVar20;
  uVar21 = uVar18 + 0x676f02d9 + uVar8 + ((uVar19 ^ uVar20) & uVar17 ^ uVar20);
  uVar18 = (uVar21 >> 0x12 | uVar21 * 0x4000) + uVar19;
  uVar21 = ((uVar18 ^ uVar19) & uVar20 ^ uVar19) + uVar17 + 0x8d2a4c8a + uVar13;
  uVar17 = (uVar21 >> 0xc | uVar21 * 0x100000) + uVar18;
  uVar21 = (uVar20 - 0x5c6be) + uVar6 + (uVar18 ^ uVar19 ^ uVar17);
  uVar20 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar17;
  uVar21 = uVar19 + 0x8771f681 + uVar9 + (uVar17 ^ uVar18 ^ uVar20);
  uVar19 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar20;
  uVar21 = uVar18 + 0x6d9d6122 + uVar12 + (uVar20 ^ uVar17 ^ uVar19);
  uVar18 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar19;
  uVar21 = uVar17 + 0xfde5380c + uVar15 + (uVar19 ^ uVar20 ^ uVar18);
  uVar17 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar18;
  uVar21 = uVar20 + 0xa4beea44 + uVar2 + (uVar18 ^ uVar19 ^ uVar17);
  uVar20 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar17;
  uVar21 = uVar19 + 0x4bdecfa9 + uVar5 + (uVar17 ^ uVar18 ^ uVar20);
  uVar19 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar20;
  uVar21 = uVar18 + 0xf6bb4b60 + uVar8 + (uVar20 ^ uVar17 ^ uVar19);
  uVar18 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar19;
  uVar21 = uVar17 + 0xbebfbc70 + uVar11 + (uVar19 ^ uVar20 ^ uVar18);
  uVar17 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar18;
  uVar21 = uVar20 + 0x289b7ec6 + uVar14 + (uVar18 ^ uVar19 ^ uVar17);
  uVar22 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar17;
  uVar21 = uVar19 + 0xeaa127fa + uVar1 + (uVar17 ^ uVar18 ^ uVar22);
  uVar19 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar22;
  uVar21 = uVar18 + 0xd4ef3085 + uVar4 + (uVar22 ^ uVar17 ^ uVar19);
  uVar20 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar19;
  uVar21 = uVar17 + 0x4881d05 + uVar7 + (uVar19 ^ uVar22 ^ uVar20);
  uVar18 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar20;
  uVar21 = uVar22 + 0xd9d4d039 + uVar10 + (uVar20 ^ uVar19 ^ uVar18);
  uVar22 = (uVar21 >> 0x1c | uVar21 * 0x10) + uVar18;
  uVar21 = uVar19 + 0xe6db99e5 + uVar13 + (uVar18 ^ uVar20 ^ uVar22);
  uVar17 = (uVar21 >> 0x15 | uVar21 * 0x800) + uVar22;
  uVar21 = uVar20 + 0x1fa27cf8 + uVar16 + (uVar22 ^ uVar18 ^ uVar17);
  uVar19 = (uVar21 >> 0x10 | uVar21 * 0x10000) + uVar17;
  uVar21 = uVar18 + 0xc4ac5665 + uVar3 + (uVar17 ^ uVar22 ^ uVar19);
  uVar18 = (uVar21 >> 9 | uVar21 * 0x800000) + uVar19;
  uVar21 = uVar22 + 0xf4292244 + uVar1 + ((~uVar17 | uVar18) ^ uVar19);
  uVar20 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar18;
  uVar21 = uVar17 + 0x432aff97 + uVar8 + ((~uVar19 | uVar20) ^ uVar18);
  uVar17 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar20;
  uVar21 = uVar19 + 0xab9423a7 + uVar15 + ((~uVar18 | uVar17) ^ uVar20);
  uVar19 = (uVar21 >> 0x11 | uVar21 * 0x8000) + uVar17;
  uVar21 = uVar18 + 0xfc93a039 + uVar6 + ((~uVar20 | uVar19) ^ uVar17);
  uVar21 = (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;
  uVar20 = uVar20 + 0x655b59c3 + uVar13 + ((~uVar17 | uVar21) ^ uVar19);
  uVar18 = (uVar20 >> 0x1a | uVar20 * 0x40) + uVar21;
  uVar20 = uVar17 + 0x8f0ccc92 + uVar4 + ((~uVar19 | uVar18) ^ uVar21);
  uVar17 = (uVar20 >> 0x16 | uVar20 * 0x400) + uVar18;
  uVar20 = (uVar19 - 0x100b83) + uVar11 + ((~uVar21 | uVar17) ^ uVar18);
  uVar19 = (uVar20 >> 0x11 | uVar20 * 0x8000) + uVar17;
  uVar21 = uVar21 + 0x85845dd1 + uVar2 + ((~uVar18 | uVar19) ^ uVar17);
  uVar20 = (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;
  uVar21 = uVar18 + 0x6fa87e4f + uVar9 + ((~uVar17 | uVar20) ^ uVar19);
  uVar18 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar20;
  uVar21 = uVar17 + 0xfe2ce6e0 + uVar16 + ((~uVar19 | uVar18) ^ uVar20);
  uVar17 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar18;
  uVar21 = uVar19 + 0xa3014314 + uVar7 + ((~uVar20 | uVar17) ^ uVar18);
  uVar19 = (uVar21 >> 0x11 | uVar21 * 0x8000) + uVar17;
  uVar21 = uVar20 + 0x4e0811a1 + uVar14 + ((~uVar18 | uVar19) ^ uVar17);
  uVar20 = (uVar21 >> 0xb | uVar21 * 0x200000) + uVar19;
  uVar21 = uVar18 + 0xf7537e82 + uVar5 + ((~uVar17 | uVar20) ^ uVar19);
  uVar18 = (uVar21 >> 0x1a | uVar21 * 0x40) + uVar20;
  uVar21 = uVar17 + 0xbd3af235 + uVar12 + ((~uVar19 | uVar18) ^ uVar20);
  uVar22 = (uVar21 >> 0x16 | uVar21 * 0x400) + uVar18;
  uVar21 = uVar19 + 0x2ad7d2bb + uVar3 + ((~uVar20 | uVar22) ^ uVar18);
  uVar17 = (uVar21 >> 0x11 | uVar21 * 0x8000) + uVar22;
  uVar21 = uVar20 + 0xeb86d391 + uVar10 + ((~uVar18 | uVar17) ^ uVar22);
  *buf = uVar18 + *buf;
  buf[2] = buf[2] + uVar17;
  buf[3] = buf[3] + uVar22;
  buf[1] = buf[1] + uVar17 + (uVar21 >> 0xb | uVar21 * 0x200000);
  return;
}



// WARNING: Unknown calling convention

void update_md5(md5_context *ctx,uchar *buf,ulong len)

{
  uchar *in;
  uint uVar1;
  uint32_t t;
  uint uVar2;
  int iVar3;
  int iVar4;
  uchar *p;
  uint32_t uVar5;
  uchar *local_28;
  uint local_20;
  
  local_20 = len;
  local_28 = buf;
  uVar1 = ctx->bits[0];
  uVar2 = uVar1 + len * 8;
  ctx->bits[0] = uVar2;
  if (uVar2 < uVar1) {
    uVar5 = ctx->bits[1] + 1;
    ctx->bits[1] = uVar5;
  }
  else {
    uVar5 = ctx->bits[1];
  }
  uVar2 = uVar1 >> 3 & 0x3f;
  ctx->bits[1] = uVar5 + (len >> 0x1d);
  in = ctx->in;
  if (uVar2 != 0) {
    local_20 = 0x40 - uVar2;
    if (len < local_20) {
      memmove(ctx->in + uVar2,buf,len);
      return;
    }
    memmove(ctx->in + uVar2,buf,local_20);
    iVar3 = 0;
    do {
      *(uint *)(in + iVar3) =
           CONCAT22(CONCAT11(ctx->in[iVar3 + 3],ctx->in[iVar3 + 2]),
                    CONCAT11(ctx->in[iVar3 + 1],in[iVar3]));
      iVar3 = iVar3 + 4;
    } while (iVar3 != 0x40);
    transform_md5(ctx->buf,(uint32_t *)in);
    local_28 = buf + local_20;
    local_20 = len - local_20;
  }
  if (0x3f < local_20) {
    iVar3 = 0;
    do {
      memmove(in,local_28 + iVar3,0x40);
      iVar4 = 0;
      do {
        *(uint *)(in + iVar4) =
             CONCAT22(CONCAT11(ctx->in[iVar4 + 3],ctx->in[iVar4 + 2]),
                      CONCAT11(ctx->in[iVar4 + 1],in[iVar4]));
        iVar4 = iVar4 + 4;
      } while (iVar4 != 0x40);
      iVar3 = iVar3 + 0x40;
      transform_md5(ctx->buf,(uint32_t *)in);
    } while (0x3f < local_20 - iVar3);
    uVar2 = local_20 - 0x40;
    local_20 = uVar2 & 0x3f;
    local_28 = local_28 + (uVar2 & 0xffffffc0) + 0x40;
  }
  memmove(in,local_28,local_20);
  return;
}



// WARNING: Unknown calling convention

void done_md5(md5_context *ctx,uchar *digest)

{
  uint uVar1;
  int iVar2;
  md5_context *pmVar3;
  uchar *p;
  uint count;
  uint uVar4;
  uchar *puVar5;
  bool bVar6;
  byte bVar7;
  
  bVar7 = 0;
  uVar1 = ctx->bits[0] >> 3 & 0x3f;
  uVar4 = -uVar1 + 0x3f;
  ctx->in[uVar1] = 0x80;
  if (uVar4 < 8) {
    puVar5 = ctx->in;
    memset(ctx->in + uVar1 + 1,0,uVar4);
    iVar2 = 0;
    do {
      *(uint *)(puVar5 + iVar2) =
           CONCAT22(CONCAT11(ctx->in[iVar2 + 3],ctx->in[iVar2 + 2]),
                    CONCAT11(ctx->in[iVar2 + 1],puVar5[iVar2]));
      iVar2 = iVar2 + 4;
    } while (iVar2 != 0x40);
    transform_md5(ctx->buf,(uint32_t *)puVar5);
    bVar6 = ((uint)puVar5 & 1) != 0;
    uVar1 = 0x38;
    if (bVar6) {
      ctx->in[0] = '\0';
      puVar5 = ctx->in + 1;
      uVar1 = 0x37;
    }
    if (((uint)puVar5 & 2) != 0) {
      *(undefined2 *)puVar5 = 0;
      uVar1 = uVar1 - 2;
      puVar5 = puVar5 + 2;
    }
    for (uVar4 = uVar1 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
      *(undefined4 *)puVar5 = 0;
      puVar5 = puVar5 + (uint)bVar7 * -8 + 4;
    }
    if ((uVar1 & 2) != 0) {
      *(undefined2 *)puVar5 = 0;
      puVar5 = puVar5 + 2;
    }
    if (bVar6) {
      *puVar5 = '\0';
    }
  }
  else {
    memset(ctx->in + uVar1 + 1,0,-uVar1 + 0x37);
  }
  puVar5 = ctx->in;
  iVar2 = 0;
  do {
    *(uint *)(puVar5 + iVar2) =
         CONCAT22(CONCAT11(ctx->in[iVar2 + 3],ctx->in[iVar2 + 2]),
                  CONCAT11(ctx->in[iVar2 + 1],puVar5[iVar2]));
    iVar2 = iVar2 + 4;
  } while (iVar2 != 0x38);
  *(uint32_t *)(ctx->in + 0x38) = ctx->bits[0];
  *(uint32_t *)(ctx->in + 0x3c) = ctx->bits[1];
  transform_md5(ctx->buf,(uint32_t *)puVar5);
  pmVar3 = ctx;
  do {
    pmVar3->buf[0] = pmVar3->buf[0];
    pmVar3 = (md5_context *)(pmVar3->buf + 1);
  } while (pmVar3 != (md5_context *)ctx->bits);
  memmove(digest,ctx,0x10);
  for (iVar2 = 0x16; iVar2 != 0; iVar2 = iVar2 + -1) {
    ctx->buf[0] = 0;
    ctx = (md5_context *)((int)ctx + (uint)bVar7 * -8 + 4);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * digest_md5(uchar *data,ulong length,uchar *digest)

{
  int iVar1;
  int in_GS_OFFSET;
  md5_context ctx;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  ctx.buf[0] = 0x67452301;
  ctx.buf[1] = 0xefcdab89;
  ctx.buf[2] = 0x98badcfe;
  ctx.buf[3] = 0x10325476;
  ctx.bits[0] = 0;
  ctx.bits[1] = 0;
  if (length != 0) {
    update_md5(&ctx,data,length);
  }
  done_md5(&ctx,digest);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return digest;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void freeml(memory_list *ml)

{
  void **ppvVar1;
  int iVar2;
  int i;
  
  if (ml != (memory_list *)0x0) {
    if (0 < ml->n) {
      iVar2 = 0;
      do {
        ppvVar1 = ml->p + iVar2;
        iVar2 = iVar2 + 1;
        mem_free(*ppvVar1);
      } while (ml->n != iVar2 && iVar2 <= ml->n);
    }
    mem_free(ml);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void add_one_to_ml(memory_list **ml,void *p)

{
  int iVar1;
  memory_list *pmVar2;
  memory_list *nml;
  
  if (p != (void *)0x0) {
    pmVar2 = *ml;
    if (pmVar2 == (memory_list *)0x0) {
      pmVar2 = (memory_list *)mem_alloc(0xc);
      *ml = pmVar2;
      if (pmVar2 == (memory_list *)0x0) {
        return;
      }
      pmVar2->n = 0;
      pmVar2 = *ml;
    }
    else {
      pmVar2 = (memory_list *)mem_realloc(pmVar2,pmVar2->n * 4 + 0xc);
      if (pmVar2 == (memory_list *)0x0) {
        return;
      }
      *ml = pmVar2;
    }
    iVar1 = pmVar2->n;
    pmVar2->p[iVar1] = p;
    pmVar2->n = iVar1 + 1;
  }
  return;
}



// WARNING: Unknown calling convention

void add_to_ml(memory_list **ml,...)

{
  void **ppvVar1;
  int iVar2;
  int n;
  memory_list *pmVar3;
  va_list ap;
  void *q;
  void *in_stack_00000008;
  
  if (in_stack_00000008 != (void *)0x0) {
    iVar2 = 0;
    do {
      iVar2 = iVar2 + 1;
    } while ((&stack0x00000008)[iVar2] != (void *)0x0);
    if (iVar2 != 0) {
      pmVar3 = *ml;
      if (pmVar3 == (memory_list *)0x0) {
        pmVar3 = (memory_list *)mem_alloc(iVar2 * 4 + 8);
        *ml = pmVar3;
        if (pmVar3 == (memory_list *)0x0) {
          return;
        }
        pmVar3->n = 0;
      }
      else {
        pmVar3 = (memory_list *)mem_realloc(pmVar3,(iVar2 + pmVar3->n) * 4 + 8);
        if (pmVar3 == (memory_list *)0x0) {
          return;
        }
        *ml = pmVar3;
      }
      ppvVar1 = (void **)&stack0x0000000c;
      while (in_stack_00000008 != (void *)0x0) {
        pmVar3 = *ml;
        iVar2 = pmVar3->n;
        pmVar3->p[iVar2] = in_stack_00000008;
        pmVar3->n = iVar2 + 1;
        in_stack_00000008 = *ppvVar1;
        ppvVar1 = ppvVar1 + 1;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

memory_list * getml(void *p,...)

{
  void *pvVar1;
  memory_list *pmVar2;
  memory_list *ml;
  int iVar3;
  int n;
  va_list ap;
  size_t size;
  int *piVar4;
  void *q;
  memory_list *pmVar5;
  int in_stack_00000008;
  
  pvVar1 = p;
  pmVar2 = (memory_list *)0x0;
  if (p != (void *)0x0) {
    iVar3 = 1;
    size = 0xc;
    if (in_stack_00000008 != 0) {
      do {
        iVar3 = iVar3 + 1;
      } while ((&p)[iVar3] != (void *)0x0);
      size = iVar3 * 4 + 8;
    }
    pmVar2 = (memory_list *)mem_alloc(size);
    if (pmVar2 != (memory_list *)0x0) {
      pmVar2->n = 1;
      pmVar2->p[0] = pvVar1;
      if (in_stack_00000008 != 0) {
        pmVar5 = pmVar2 + 1;
        iVar3 = 1;
        piVar4 = (int *)&stack0x0000000c;
        do {
          iVar3 = iVar3 + 1;
          pmVar5->n = in_stack_00000008;
          pmVar5 = (memory_list *)pmVar5->p;
          pmVar2->n = iVar3;
          in_stack_00000008 = *piVar4;
          piVar4 = piVar4 + 1;
        } while (in_stack_00000008 != 0);
        return pmVar2;
      }
    }
  }
  return pmVar2;
}



// WARNING: Unknown calling convention

size_t round_size(size_t size)

{
  if (page_size == 0) {
    page_size = sysconf(0x1e);
  }
  if (page_size < 1) {
    page_size = 1;
  }
  return (size / (uint)page_size + 1) * page_size;
}



// WARNING: Unknown calling convention

void mem_mmap_free(void *p,size_t size)

{
  size_t __len;
  
  if (p != (void *)0x0) {
    __len = round_size(size);
    munmap(p,__len);
    return;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  errline = 0xa7;
  elinks_internal((uchar *)"mem_mmap_free(NULL)");
  return;
}



// WARNING: Unknown calling convention

void * mem_mmap_alloc(size_t size)

{
  void *p;
  size_t __len;
  void *pvVar1;
  
  if (size != 0) {
    __len = round_size(size);
    pvVar1 = mmap64((void *)0x0,__len,3,0x21,-1,0);
    if (pvVar1 != (void *)0xffffffff) {
      return pvVar1;
    }
  }
  p = (void *)0x0;
  return p;
}



// WARNING: Unknown calling convention

void * mem_mmap_realloc(void *p,size_t old_size,size_t new_size)

{
  size_t sVar1;
  size_t sVar2;
  void *pvVar3;
  void *p2;
  void *pvVar4;
  
  if (p != (void *)0x0) {
    sVar1 = round_size(old_size);
    sVar2 = round_size(new_size);
    pvVar4 = p;
    if (sVar1 != sVar2) {
      if (new_size == 0) {
        pvVar4 = (void *)0x0;
        mem_mmap_free(p,old_size);
      }
      else {
        sVar1 = round_size(new_size);
        sVar2 = round_size(old_size);
        pvVar3 = mremap(p,sVar2,sVar1,1);
        pvVar4 = (void *)0x0;
        if (pvVar3 != (void *)0xffffffff) {
          pvVar4 = pvVar3;
        }
      }
    }
    return pvVar4;
  }
  pvVar4 = mem_mmap_alloc(new_size);
  return pvVar4;
}



// WARNING: Unknown calling convention

int patience(uchar *of)

{
  alloc_try = alloc_try + 1;
  if (2 < alloc_try) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    errline = 0x2e;
    elinks_error((uchar *)
                 "Out of memory (%s returned NULL) after %d tries, I give up and try to continue. Pray for me, please."
                 ,of,alloc_try);
    alloc_try = 0;
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  errline = 0x22;
  elinks_error((uchar *)
               "Out of memory (%s returned NULL): retry #%d/%d, I still exercise my patience and retry tirelessly."
               ,of,alloc_try,3);
  sleep(3);
  return alloc_try;
}



// WARNING: Unknown calling convention

void mem_free(void *p)

{
  if (p != (void *)0x0) {
    free(p);
    return;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  errline = 0x5a;
  elinks_internal((uchar *)"mem_free(NULL)");
  return;
}



// WARNING: Unknown calling convention

void * mem_calloc(size_t count,size_t eltsize)

{
  void *pvVar1;
  int iVar2;
  void *p;
  
  if ((eltsize != 0) && (count != 0)) {
    do {
      pvVar1 = calloc(count,eltsize);
      if (pvVar1 != (void *)0x0) {
        return pvVar1;
      }
      iVar2 = patience((uchar *)"calloc");
    } while (iVar2 != 0);
    return (void *)0x0;
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * mem_alloc(size_t size)

{
  void *pvVar1;
  int iVar2;
  void *p;
  
  if (size != 0) {
    do {
      pvVar1 = malloc(size);
      if (pvVar1 != (void *)0x0) {
        return pvVar1;
      }
      iVar2 = patience((uchar *)"malloc");
    } while (iVar2 != 0);
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

void * mem_realloc(void *p,size_t size)

{
  void *pvVar1;
  int iVar2;
  void *p2;
  
  if (p == (void *)0x0) {
    pvVar1 = mem_alloc(size);
    return pvVar1;
  }
  if (size == 0) {
    mem_free(p);
  }
  else {
    do {
      pvVar1 = realloc(p,size);
      if (pvVar1 != (void *)0x0) {
        return pvVar1;
      }
      iVar2 = patience((uchar *)"realloc");
    } while (iVar2 != 0);
  }
  return (void *)0x0;
}



// WARNING: Unknown calling convention

scanner_token * skip_scanner_tokens(scanner *scanner,int skipto,int precedence)

{
  scanner_token *psVar1;
  scanner_token *token;
  scanner_token *psVar2;
  scanner_token *psVar3;
  int iVar4;
  
  iVar4 = scanner->tokens;
  if (((0 < iVar4) && (psVar3 = scanner->current, psVar3 < scanner->table + iVar4)) &&
     (psVar3 != (scanner_token *)0x0)) {
    if (psVar3->type == skipto) {
LAB_080e9e3b:
      if (0 < iVar4) {
        psVar2 = scanner->current;
        psVar3 = scanner->table + iVar4;
        if (psVar2 < psVar3) {
          psVar1 = psVar2 + 1;
          scanner->current = psVar1;
          if (psVar3 <= psVar2 + 2) {
                    // WARNING: Could not recover jumptable at 0x080e9e78. Too many branches
                    // WARNING: Treating indirect jump as call
            psVar3 = (*scanner->info->scan)(scanner);
            return psVar3;
          }
          if (psVar1 < psVar3) {
            return psVar1;
          }
        }
      }
    }
    else if (psVar3->precedence <= precedence) {
      while (psVar3 < scanner->table + iVar4) {
        psVar2 = psVar3 + 1;
        scanner->current = psVar2;
        if (psVar3 + 2 < scanner->table + iVar4) {
          if (iVar4 < 1) {
            return (scanner_token *)0x0;
          }
          if (scanner->table + iVar4 <= psVar2) {
            return (scanner_token *)0x0;
          }
        }
        else {
          psVar2 = (*scanner->info->scan)(scanner);
        }
        if (psVar2 == (scanner_token *)0x0) {
          return (scanner_token *)0x0;
        }
        if (psVar2->type == skipto) {
LAB_080e9e38:
          iVar4 = scanner->tokens;
          goto LAB_080e9e3b;
        }
        if (psVar2->precedence != precedence && precedence <= psVar2->precedence) {
          if (skipto != psVar2->type) {
            return (scanner_token *)0x0;
          }
          goto LAB_080e9e38;
        }
        iVar4 = scanner->tokens;
        if (iVar4 < 1) {
          return (scanner_token *)0x0;
        }
        psVar3 = scanner->current;
      }
    }
  }
  return (scanner_token *)0x0;
}



// WARNING: Unknown calling convention

void init_scanner(scanner *scanner,scanner_info *scanner_info,uchar *string,uchar *end)

{
  byte *pbVar1;
  uchar *puVar2;
  byte bVar3;
  int *piVar4;
  uchar *puVar5;
  size_t sVar6;
  int iVar7;
  anon_enum_32 aVar8;
  scan_table_info *info;
  scan_table_info *psVar9;
  int index;
  uint uVar10;
  scanner *psVar11;
  byte bVar12;
  uchar *local_2c;
  scan_table_info *local_20;
  
  bVar12 = 0;
  local_2c = end;
  bVar3 = scanner_info->field_0x40c;
  if ((bVar3 & 1) == 0) {
    psVar9 = scanner_info->scan_table_info;
    if ((psVar9 != (scan_table_info *)0x0) && (aVar8 = psVar9->type, aVar8 != DOM_SCAN_END)) {
      local_20 = psVar9 + 1;
      do {
        while (aVar8 != COMMON_DOWNLOAD_DO) {
          iVar7 = (psVar9->data).string.length;
          puVar2 = (psVar9->data).string.source;
          uVar10 = iVar7 - 1;
          if (assert_failed == 0) {
            assert_failed = (uint)(aVar8 != CONTINUE_DOWNLOAD_DO) | uVar10 >> 0x1f;
            if (assert_failed != 0) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
              errline = 0x96;
              elinks_internal((uchar *)"assertion info[i].type == SCAN_STRING && pos >= 0 failed!");
              goto LAB_080ea03f;
            }
          }
          else {
LAB_080ea03f:
            if ((int)uVar10 < 0) goto LAB_080e9f50;
          }
          puVar5 = puVar2 + iVar7;
          do {
            pbVar1 = puVar5 + -1;
            puVar5 = puVar5 + -1;
            scanner_info->scan_table[*pbVar1] = scanner_info->scan_table[*pbVar1] | psVar9->bits;
          } while (puVar5 != puVar2);
          aVar8 = local_20->type;
          psVar9 = local_20;
          local_20 = local_20 + 1;
          if (aVar8 == DOM_SCAN_END) goto LAB_080e9f62;
        }
        bVar3 = *(psVar9->data).string.source;
        uVar10 = (uint)bVar3;
        if (assert_failed == 0) {
          assert_failed = (int)(uVar10 == 0);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 0x8b;
            elinks_internal((uchar *)"assertion index > 0 failed!");
            if (assert_failed != 0) goto LAB_080e9f30;
          }
          assert_failed = (int)(0xff < (psVar9->data).string.length);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 0x8c;
            elinks_internal((uchar *)"assertion data->range.end < SCAN_TABLE_SIZE failed!");
            if (assert_failed != 0) goto LAB_080e9f30;
          }
          assert_failed = (int)((psVar9->data).string.length < (int)uVar10);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 0x8d;
            elinks_internal((uchar *)"assertion index <= data->range.end failed!");
          }
        }
LAB_080e9f30:
        if ((int)uVar10 <= (psVar9->data).string.length) {
          piVar4 = scanner_info->scan_table + bVar3;
          do {
            uVar10 = uVar10 + 1;
            *piVar4 = *piVar4 | psVar9->bits;
            piVar4 = piVar4 + 1;
          } while ((int)uVar10 <= (psVar9->data).string.length);
        }
LAB_080e9f50:
        aVar8 = local_20->type;
        psVar9 = local_20;
        local_20 = local_20 + 1;
      } while (aVar8 != DOM_SCAN_END);
LAB_080e9f62:
      bVar3 = scanner_info->field_0x40c;
    }
    scanner_info->field_0x40c = bVar3 | 1;
  }
  psVar11 = scanner;
  for (iVar7 = 0x2f; iVar7 != 0; iVar7 = iVar7 + -1) {
    psVar11->string = (uchar *)0x0;
    psVar11 = (scanner *)((int)psVar11 + (uint)bVar12 * -8 + 4);
  }
  scanner->string = string;
  scanner->position = string;
  if (end == (uchar *)0x0) {
    sVar6 = strlen((char *)string);
    local_2c = string + sVar6;
  }
  scanner->info = scanner_info;
  scanner->end = local_2c;
  scanner->current = scanner->table;
                    // WARNING: Could not recover jumptable at 0x080e9fb5. Too many branches
                    // WARNING: Treating indirect jump as call
  (*scanner_info->scan)(scanner);
  return;
}



// WARNING: Unknown calling convention

int map_scanner_string(scanner *scanner,uchar *ident,uchar *end,int base_type)

{
  uchar *puVar1;
  int iVar2;
  scanner_string_mapping *mappings;
  scanner_string_mapping *psVar3;
  int length;
  
  length = (int)end - (int)ident;
  psVar3 = scanner->info->mappings;
  puVar1 = psVar3->name;
  do {
    if (puVar1 == (uchar *)0x0) {
      return base_type;
    }
    if (psVar3->base_type == base_type) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
      errline = 0x1c;
      iVar2 = elinks_strlcasecmp(psVar3->name,0xffffffff,ident,length,1);
      if (iVar2 == 0) {
        return psVar3->type;
      }
    }
    psVar3 = psVar3 + 1;
    puVar1 = psVar3->name;
  } while( true );
}



// WARNING: Unknown calling convention

int secure_fprintf(secure_save_info *ssi,char *format,...)

{
  int *piVar1;
  int ret;
  
  if (((ssi == (secure_save_info *)0x0) || (ssi->fp == (FILE *)0x0)) || (ssi->err != 0)) {
    ret = -1;
  }
  else {
    ret = __vfprintf_chk(ssi->fp,1,format,&stack0x0000000c);
    if (ret < 0) {
      piVar1 = __errno_location();
      ssi->err = *piVar1;
    }
  }
  return ret;
}



// WARNING: Unknown calling convention

int secure_fputc(secure_save_info *ssi,int c)

{
  int *piVar1;
  int ret;
  
  if (((ssi == (secure_save_info *)0x0) || ((FILE *)ssi->fp == (FILE *)0x0)) || (ssi->err != 0)) {
    ret = -1;
  }
  else {
    ret = fputc(c,(FILE *)ssi->fp);
    if (ret == -1) {
      piVar1 = __errno_location();
      ssi->err = *piVar1;
      secsave_errno = SS_ERR_OTHER;
    }
  }
  return ret;
}



// WARNING: Unknown calling convention

int secure_fputs(secure_save_info *ssi,char *s)

{
  int *piVar1;
  int ret;
  
  if (((ssi == (secure_save_info *)0x0) || ((FILE *)ssi->fp == (FILE *)0x0)) || (ssi->err != 0)) {
    ret = -1;
  }
  else {
    ret = fputs(s,(FILE *)ssi->fp);
    if (ret == -1) {
      secsave_errno = SS_ERR_OTHER;
      piVar1 = __errno_location();
      ssi->err = *piVar1;
    }
  }
  return ret;
}



// WARNING: Unknown calling convention

int secure_close(secure_save_info *ssi)

{
  FILE *__stream;
  int iVar1;
  void *p;
  uchar *__new;
  int fail;
  int *piVar2;
  option_value *poVar3;
  int iVar4;
  int ret;
  
  iVar4 = -1;
  if (ssi == (secure_save_info *)0x0) {
    return -1;
  }
  __stream = (FILE *)ssi->fp;
  if (__stream == (FILE *)0x0) {
free:
    if (ssi->tmp_file_name != (uchar *)0x0) {
      mem_free(ssi->tmp_file_name);
    }
    __new = ssi->file_name;
    if (__new == (uchar *)0x0) goto LAB_080ea34e;
  }
  else {
    iVar4 = ssi->err;
    if (iVar4 != 0) {
LAB_080ea380:
      fclose(__stream);
      goto free;
    }
    if (ssi->secure_save != 0) {
      iVar1 = fflush(__stream);
      if (iVar1 == -1) {
LAB_080ea36d:
        fail = (int)__errno_location();
        iVar4 = *(int *)fail;
        secsave_errno = SS_ERR_OTHER;
        __stream = (FILE *)ssi->fp;
        goto LAB_080ea380;
      }
      poVar3 = get_opt_();
      if (poVar3->tree == (list_head_elinks *)0x0) {
        __stream = (FILE *)ssi->fp;
      }
      else {
        iVar1 = fileno((FILE *)ssi->fp);
        iVar1 = fsync(iVar1);
        if (iVar1 != 0) goto LAB_080ea36d;
        __stream = (FILE *)ssi->fp;
      }
    }
    iVar1 = fclose(__stream);
    if (iVar1 == -1) {
      piVar2 = __errno_location();
      iVar4 = *piVar2;
      secsave_errno = SS_ERR_OTHER;
      goto free;
    }
    if ((ssi->secure_save == 0) || (__new = ssi->file_name, __new == (uchar *)0x0)) goto free;
    if (ssi->tmp_file_name != (uchar *)0x0) {
      iVar1 = rename((char *)ssi->tmp_file_name,(char *)__new);
      if (iVar1 == -1) {
        piVar2 = __errno_location();
        iVar4 = *piVar2;
        secsave_errno = SS_ERR_RENAME;
      }
      goto free;
    }
  }
  mem_free(__new);
LAB_080ea34e:
  mem_free(ssi);
  return iVar4;
}



// WARNING: Unknown calling convention

secure_save_info * secure_open(uchar *file_name)

{
  __mode_t __mask;
  option_value *poVar1;
  secure_save_info *p;
  secure_save_info *ssi;
  uchar *puVar2;
  int iVar3;
  int *piVar4;
  uchar *randname;
  int fd;
  FILE *pFVar5;
  mode_t saved_mask;
  stat st;
  
  __mask = umask(0x7f);
  secsave_errno = SS_ERR_NONE;
  poVar1 = get_opt_();
  if (poVar1->tree == (list_head_elinks *)0x0) {
    poVar1 = get_opt_();
    if (poVar1->tree != (list_head_elinks *)0x0) goto LAB_080ea570;
  }
  else {
LAB_080ea570:
    poVar1 = get_opt_();
    if (poVar1->tree == (list_head_elinks *)0x0) {
      secsave_errno = SS_ERR_DISABLED;
      p = (secure_save_info *)0x0;
      goto LAB_080ea5d3;
    }
  }
  p = (secure_save_info *)mem_calloc(1,0x14);
  if (p == (secure_save_info *)0x0) {
    secsave_errno = SS_ERR_OUT_OF_MEM;
    goto LAB_080ea5d3;
  }
  poVar1 = get_opt_();
  p->secure_save = (int)*poVar1;
  puVar2 = stracpy(file_name);
  p->file_name = puVar2;
  if (puVar2 == (uchar *)0x0) {
    secsave_errno = SS_ERR_OUT_OF_MEM;
  }
  else {
    iVar3 = __lxstat64(3,(char *)puVar2,(stat64 *)&st);
    if (iVar3 == 0) {
      if ((st.st_mode & 0xf000) == 0x8000) {
        iVar3 = access((char *)p->file_name,6);
        if (-1 < iVar3) goto LAB_080ea50c;
        piVar4 = __errno_location();
        p->err = *piVar4;
        secsave_errno = SS_ERR_ACCESS;
      }
      else {
        p->secure_save = 0;
LAB_080ea5b6:
        pFVar5 = fopen64((char *)p->file_name,"wb");
        p->fp = (FILE *)pFVar5;
        if (pFVar5 != (FILE *)0x0) goto LAB_080ea5d3;
        secsave_errno = SS_ERR_OPEN_WRITE;
        piVar4 = __errno_location();
        p->err = *piVar4;
      }
    }
    else {
      piVar4 = __errno_location();
      if (*piVar4 == 2) {
LAB_080ea50c:
        if (p->secure_save == 0) goto LAB_080ea5b6;
        puVar2 = straconcat(p->file_name,".tmp_XXXXXX",0);
        if (puVar2 == (uchar *)0x0) {
          secsave_errno = SS_ERR_OUT_OF_MEM;
        }
        else {
          iVar3 = mkstemp64((char *)puVar2);
          if (iVar3 == -1) {
            secsave_errno = SS_ERR_MKSTEMP;
            mem_free(puVar2);
          }
          else {
            pFVar5 = fdopen(iVar3,"w");
            p->fp = (FILE *)pFVar5;
            if (pFVar5 != (FILE *)0x0) {
              p->tmp_file_name = puVar2;
              goto LAB_080ea5d3;
            }
            secsave_errno = SS_ERR_OPEN_WRITE;
            piVar4 = __errno_location();
            p->err = *piVar4;
            mem_free(puVar2);
          }
        }
      }
      else {
        p->err = *piVar4;
        secsave_errno = SS_ERR_STAT;
      }
    }
    mem_free(p->file_name);
    p->file_name = (uchar *)0x0;
  }
  mem_free(p);
  p = (secure_save_info *)0x0;
LAB_080ea5d3:
  umask(__mask);
  return p;
}



// WARNING: Removing unreachable block (ram,0x080ea750)
// WARNING: Unknown calling convention

uchar * secsave_strerror(secsave_errno secsave_error,terminal *term)

{
  int iVar1;
  int new_charset;
  uchar *puVar2;
  int new_charset_1;
  int new_charset_2;
  int new_charset_3;
  int new_charset_4;
  int new_charset_5;
  int new_charset_6;
  int new_charset_7;
  int new_charset_8;
  
  switch(secsave_error) {
  default:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Secure file saving error");
    return puVar2;
  case SS_ERR_DISABLED:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"File saving disabled by option");
    return puVar2;
  case SS_ERR_OUT_OF_MEM:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    break;
  case SS_ERR_OPEN_READ:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Cannot read the file");
    return puVar2;
  case SS_ERR_OPEN_WRITE:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Cannot write the file");
    return puVar2;
  case SS_ERR_STAT:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Cannot get file status");
    return puVar2;
  case SS_ERR_ACCESS:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Cannot access the file");
    return puVar2;
  case SS_ERR_MKSTEMP:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Cannot create temp file");
    return puVar2;
  case SS_ERR_RENAME:
    if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)
       ) {
      puVar2 = get_cp_mime_name(iVar1);
      bind_textdomain_codeset("elinks",puVar2);
      current_charset = iVar1;
    }
    puVar2 = gettext((uchar *)"Cannot rename the file");
    return puVar2;
  }
  puVar2 = gettext((uchar *)"Out of memory");
  return puVar2;
}



// WARNING: Unknown calling convention

void dummy_snprintf(void)

{
  return;
}



// WARNING: Unknown calling convention

uchar * asprintfa(char *fmt,...)

{
  int iVar1;
  size_t sVar2;
  uchar *__dest;
  uchar *str;
  char *local_10;
  
  __dest = (uchar *)0x0;
  iVar1 = vasprintf(&local_10,fmt,&stack0x00000008);
  if (-1 < iVar1) {
    sVar2 = strlen(local_10);
    __dest = (uchar *)mem_alloc(sVar2 + 1);
    if (__dest != (uchar *)0x0) {
      memcpy(__dest,local_10,sVar2 + 1);
    }
    free(local_10);
  }
  return __dest;
}



// WARNING: Unknown calling convention

string * init_string(string *string)

{
  uchar *puVar1;
  
  if (assert_failed == 0) {
    assert_failed = (int)(string == (string *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x133;
      elinks_internal((uchar *)"assertion string != NULL failed: [init_string]");
      if (assert_failed != 0) goto LAB_080eab11;
    }
    string->length = 0;
    puVar1 = (uchar *)mem_alloc(0x100);
    string->source = puVar1;
    if (puVar1 != (uchar *)0x0) {
      *puVar1 = '\0';
      return string;
    }
  }
  else {
LAB_080eab11:
    assert_failed = 0;
  }
  return (string *)0x0;
}



// WARNING: Unknown calling convention

int elinks_strlcmp(uchar *s1,size_t n1,uchar *s2,size_t n2)

{
  int d;
  int iVar1;
  size_t sVar2;
  int iVar3;
  uint uVar4;
  size_t p;
  
  if ((s2 == (uchar *)0x0) || (s1 == (uchar *)0x0)) {
    return 1;
  }
  if (n1 == 0xffffffff) {
    n1 = strlen((char *)s1);
  }
  if (n2 == 0xffffffff) {
    sVar2 = strlen((char *)s2);
    iVar3 = -sVar2;
  }
  else {
    iVar3 = -n2;
  }
  iVar3 = n1 + iVar3;
  if ((((iVar3 == 0) && (n1 != 0)) && (*s1 != 0)) &&
     ((*s2 != 0 && (iVar3 = (uint)*s1 - (uint)*s2, iVar3 == 0)))) {
    uVar4 = 0;
    while ((uVar4 = uVar4 + 1, uVar4 < n1 && (s1[uVar4] != 0))) {
      if (s2[uVar4] == 0) {
        assert_failed = 0;
        return 0;
      }
      iVar1 = (uint)s1[uVar4] - (uint)s2[uVar4];
      if (iVar1 != 0) {
        assert_failed = 0;
        return iVar1;
      }
    }
  }
  assert_failed = 0;
  return iVar3;
}



// WARNING: Unknown calling convention

void done_string(string *string)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(string == (string *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x148;
    elinks_internal((uchar *)"assertion string != NULL failed: [done_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (string->source != (uchar *)0x0) {
    mem_free(string->source);
  }
  string->source = (uchar *)0x0;
  string->length = 0;
  return;
}



// WARNING: Unknown calling convention

void add_to_strn(uchar **dst,uchar *src)

{
  size_t sVar1;
  size_t sVar2;
  uchar *puVar3;
  
  if (assert_failed == 0) {
    assert_failed = (int)(src == (uchar *)0x0 || *dst == (uchar *)0x0);
    if (src == (uchar *)0x0 || *dst == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x6c;
      elinks_internal((uchar *)"assertion *dst && src failed: [add_to_strn]");
      if (assert_failed != 0) goto LAB_080ead66;
    }
    puVar3 = *dst;
    sVar1 = strlen((char *)puVar3);
    sVar2 = strlen((char *)src);
    puVar3 = (uchar *)mem_realloc(puVar3,sVar2 + 1 + sVar1);
    if (puVar3 != (uchar *)0x0) {
      memcpy(puVar3 + sVar1,src,sVar2 + 1);
      *dst = puVar3;
    }
  }
  else {
LAB_080ead66:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * memacpy(uchar *src,int len)

{
  uchar *__dest;
  uchar *m;
  size_t size;
  
  if (assert_failed == 0) {
    assert_failed = -(len >> 0x1f);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x4d;
      elinks_internal((uchar *)"assertion len >= 0 failed: [memacpy]");
      if (assert_failed != 0) goto LAB_080eae08;
    }
    size = len + 1;
  }
  else {
LAB_080eae08:
    assert_failed = 0;
    size = 1;
    len = 0;
  }
  __dest = (uchar *)mem_alloc(size);
  if (__dest != (uchar *)0x0) {
    if ((len != 0) && (src != (uchar *)0x0)) {
      memcpy(__dest,src,len);
    }
    __dest[len] = '\0';
  }
  return __dest;
}



// WARNING: Unknown calling convention

uchar * stracpy(uchar *src)

{
  size_t len;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  assert_failed = (int)(src == (uchar *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x5c;
    elinks_internal((uchar *)"assertion src failed: [stracpy]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  len = strlen((char *)src);
  puVar1 = memacpy(src,len);
  return puVar1;
}



// WARNING: Unknown calling convention

uchar * straconcat(uchar *str,...)

{
  size_t __n;
  size_t sVar1;
  uchar *puVar2;
  uchar *a;
  char *__s;
  va_list ap;
  char **ppcVar3;
  size_t local_24;
  uchar *local_20;
  
  if (assert_failed == 0) {
    assert_failed = (int)(str == (uchar *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x90;
      elinks_internal((uchar *)"assertion str != NULL failed: [straconcat]");
      if (assert_failed != 0) goto LAB_080eafde;
    }
    local_24 = strlen((char *)str);
    local_20 = (uchar *)mem_alloc(local_24 + 1);
    if (local_20 != (uchar *)0x0) {
      if (local_24 != 0) {
        memcpy(local_20,str,local_24);
      }
      ppcVar3 = (char **)&stack0x00000008;
      while (__s = *ppcVar3, __s != (char *)0x0) {
        while( true ) {
          ppcVar3 = ppcVar3 + 1;
          __n = strlen(__s);
          if (__n == 0) break;
          sVar1 = local_24 + __n;
          puVar2 = (uchar *)mem_realloc(local_20,sVar1 + 1);
          if (puVar2 == (uchar *)0x0) {
            mem_free(local_20);
            return (uchar *)0x0;
          }
          memcpy(puVar2 + local_24,__s,__n);
          __s = *ppcVar3;
          local_24 = sVar1;
          local_20 = puVar2;
          if (__s == (char *)0x0) goto LAB_080eaf96;
        }
      }
LAB_080eaf96:
      local_20[local_24] = '\0';
      return local_20;
    }
  }
  else {
LAB_080eafde:
    assert_failed = 0;
    local_20 = (uchar *)0x0;
  }
  return local_20;
}



// WARNING: Unknown calling convention

int c_strncasecmp(char *s1,char *s2,size_t n)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  size_t sVar4;
  uchar c1;
  
  if (n != 0) {
    sVar4 = 0;
    do {
      iVar1 = c_tolower((uint)(byte)s1[sVar4]);
      iVar2 = c_tolower((uint)(byte)s2[sVar4]);
      bVar3 = (byte)iVar1;
      if (bVar3 != (byte)iVar2) {
        return -(uint)(bVar3 < (byte)iVar2) | 1;
      }
    } while ((bVar3 != 0) && (sVar4 = sVar4 + 1, n != sVar4));
  }
  return 0;
}



// WARNING: Unknown calling convention

char * c_strcasestr(char *haystack,char *needle)

{
  size_t sVar1;
  size_t n;
  int iVar2;
  int i;
  int iVar3;
  
  sVar1 = strlen(haystack);
  n = strlen(needle);
  if ((sVar1 < n) || (iVar3 = (sVar1 + 1) - n, iVar3 == 0)) {
LAB_080eb0dd:
    haystack = (char *)0x0;
  }
  else {
    while (iVar2 = c_strncasecmp(haystack,needle,n), iVar2 != 0) {
      iVar3 = iVar3 + -1;
      if (iVar3 == 0) goto LAB_080eb0dd;
      haystack = haystack + 1;
    }
  }
  return haystack;
}



// WARNING: Unknown calling convention

int c_strcasecmp(char *s1,char *s2)

{
  int iVar1;
  int iVar2;
  byte bVar3;
  int iVar4;
  uchar c1;
  
  iVar4 = 0;
  do {
    iVar1 = c_tolower((uint)(byte)s1[iVar4]);
    iVar2 = c_tolower((uint)(byte)s2[iVar4]);
    bVar3 = (byte)iVar1;
    if (bVar3 != (byte)iVar2) {
      return -(uint)(bVar3 < (byte)iVar2) | 1;
    }
    iVar4 = iVar4 + 1;
  } while (bVar3 != 0);
  return 0;
}



// WARNING: Unknown calling convention

int elinks_strlcasecmp(uchar *s1,size_t n1,uchar *s2,size_t n2,int locale_indep)

{
  int d;
  int iVar1;
  int iVar2;
  int d_1;
  __int32_t **pp_Var3;
  byte bVar4;
  size_t p_1;
  byte bVar5;
  uint uVar6;
  size_t p;
  byte *pbVar7;
  
  if (locale_indep == 0) {
    if ((s2 != (uchar *)0x0) && (s1 != (uchar *)0x0)) {
      if (n1 == 0xffffffff) {
        n1 = strlen((char *)s1);
      }
      if (n2 == 0xffffffff) {
        n2 = strlen((char *)s2);
      }
      assert_failed = 0;
      if (n1 - n2 != 0) {
        assert_failed = 0;
        return n1 - n2;
      }
      if (((n1 != 0) && (bVar4 = *s1, bVar4 != 0)) && (bVar5 = *s2, bVar5 != 0)) {
        pp_Var3 = __ctype_toupper_loc();
        uVar6 = 0;
        do {
          iVar1 = (*pp_Var3)[bVar4] - (*pp_Var3)[bVar5];
          if (iVar1 != 0) {
            return iVar1;
          }
          uVar6 = uVar6 + 1;
        } while (((uVar6 < n1) && (bVar4 = s1[uVar6], bVar4 != 0)) &&
                (bVar5 = s2[uVar6], bVar5 != 0));
      }
      return 0;
    }
  }
  else if ((s2 != (uchar *)0x0) && (s1 != (uchar *)0x0)) {
    if (n1 == 0xffffffff) {
      n1 = strlen((char *)s1);
    }
    if (n2 == 0xffffffff) {
      n2 = strlen((char *)s2);
    }
    assert_failed = 0;
    if (n1 - n2 != 0) {
      assert_failed = 0;
      return n1 - n2;
    }
    if (n1 == 0) {
      assert_failed = 0;
      return 0;
    }
    bVar4 = *s1;
    if (bVar4 == 0) {
      assert_failed = 0;
      return 0;
    }
    if (*s2 == '\0') {
      assert_failed = 0;
      return 0;
    }
    uVar6 = 0;
    pbVar7 = s2;
    do {
      iVar1 = c_toupper((uint)bVar4);
      iVar2 = c_toupper((uint)*pbVar7);
      if ((iVar1 - iVar2 != 0) || (uVar6 = uVar6 + 1, n1 <= uVar6)) {
        return iVar1 - iVar2;
      }
      bVar4 = s1[uVar6];
      if (bVar4 == 0) {
        return 0;
      }
      pbVar7 = s2 + uVar6;
    } while (s2[uVar6] != '\0');
    return 0;
  }
  return 1;
}



// WARNING: Unknown calling convention

uchar * safe_strncpy(uchar *dst,uchar *src,size_t dst_size)

{
  if (assert_failed == 0) {
    if (((src == (uchar *)0x0) || (dst == (uchar *)0x0)) || (dst_size == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0xbc;
      elinks_internal((uchar *)"assertion dst && src && dst_size > 0 failed: [safe_strncpy]");
      if (assert_failed != 0) goto LAB_080eb372;
    }
    else {
      assert_failed = 0;
    }
    strncpy((char *)dst,(char *)src,dst_size);
    dst[dst_size - 1] = '\0';
  }
  else {
LAB_080eb372:
    assert_failed = 0;
    dst = (uchar *)0x0;
  }
  return dst;
}



// WARNING: Unknown calling convention

int xstrcmp(uchar *s1,uchar *s2)

{
  int iVar1;
  
  if (s1 == (uchar *)0x0) {
    iVar1 = -(uint)(s2 != (uchar *)0x0);
  }
  else {
    iVar1 = 1;
    if (s2 != (uchar *)0x0) {
      iVar1 = strcmp((char *)s1,(char *)s2);
      return iVar1;
    }
  }
  return iVar1;
}



// WARNING: Unknown calling convention

uchar * insert_in_string(uchar **dst,int pos,uchar *seq,int seqlen)

{
  size_t sVar1;
  uchar *puVar2;
  uchar *string;
  
  puVar2 = *dst;
  sVar1 = strlen((char *)puVar2);
  puVar2 = (uchar *)mem_realloc(puVar2,seqlen + 1 + sVar1);
  if (puVar2 != (uchar *)0x0) {
    memmove(puVar2 + seqlen + pos,puVar2 + pos,(sVar1 - pos) + 1);
    memcpy(puVar2 + pos,seq,seqlen);
    *dst = puVar2;
  }
  return puVar2;
}



void * __regparm3 mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  size_t newsize;
  uint size;
  size_t oldsize;
  uint uVar2;
  
  size = new + 0xff & 0xffffff00;
  uVar2 = old + 0xff & 0xffffff00;
  if (uVar2 < size) {
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + uVar2),0,size - uVar2);
  }
  return *ptr;
}



// WARNING: Unknown calling convention

string * add_format_to_string(string *string,uchar *format,...)

{
  int iVar1;
  int width;
  int iVar2;
  void *pvVar3;
  size_t objsize;
  size_t mask;
  
  if (assert_failed == 0) {
    assert_failed = (int)(format == (uchar *)0x0 || string == (string *)0x0);
    if (format == (uchar *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x1f6;
      elinks_internal((uchar *)"assertion string && format failed: [add_format_to_string]");
      if (assert_failed != 0) goto LAB_080eb5ea;
    }
    mask = 0;
    objsize = 0;
    iVar1 = __vsnprintf_chk(0,0,1,0xffffffff,format,&stack0x0000000c);
    if (0 < iVar1) {
      iVar2 = iVar1 + string->length;
      pvVar3 = mem_align_alloc__(&string->source,string->length,iVar2 + 1,objsize,mask);
      if (pvVar3 != (void *)0x0) {
        __vsnprintf_chk(string->source + string->length,iVar1 + 1,1,0xffffffff,format,
                        &stack0x0000000c);
        string->length = iVar2;
        string->source[iVar2] = '\0';
        return string;
      }
    }
  }
  else {
LAB_080eb5ea:
    assert_failed = 0;
  }
  return (string *)0x0;
}



// WARNING: Unknown calling convention

string * add_xchar_to_string(string *string,uchar character,int times)

{
  int iVar1;
  void *pvVar2;
  char *in_stack_ffffffc4;
  size_t in_stack_ffffffc8;
  
  if (assert_failed == 0) {
    if (((character == '\0') || (string == (string *)0x0)) || (times < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x1dc;
      in_stack_ffffffc4 =
           "assertion string && character && times >= 0 failed: [add_xchar_to_string]";
      elinks_internal((uchar *)
                      "assertion string && character && times >= 0 failed: [add_xchar_to_string]");
      if (assert_failed != 0) goto LAB_080eb683;
    }
    else {
      assert_failed = 0;
    }
    if (times != 0) {
      iVar1 = times + string->length;
      pvVar2 = mem_align_alloc__(&string->source,string->length,iVar1 + 1,(size_t)in_stack_ffffffc4,
                                 in_stack_ffffffc8);
      if (pvVar2 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memset(string->source + string->length,(uint)character,times);
        string->length = iVar1;
        string->source[iVar1] = '\0';
      }
    }
  }
  else {
LAB_080eb683:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



// WARNING: Unknown calling convention

void free_string_list(list_head_elinks *list)

{
  list_head_elinks *p;
  
  if (assert_failed == 0) {
    assert_failed = (int)(list == (list_head_elinks *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x22d;
      elinks_internal((uchar *)"assertion list != NULL failed: [free_string_list]");
      if (assert_failed != 0) goto LAB_080eb7a0;
    }
    while (p = (list_head_elinks *)list->next, p != list) {
      *(void **)((int)p->next + 4) = p->prev;
      *(void **)p->prev = p->next;
      if (assert_failed == 0) {
        assert_failed = 0;
        if (p[1].next != (void *)0x0) {
          mem_free(p[1].next);
        }
        p[1].next = (void *)0x0;
        p[1].prev = (void *)0x0;
      }
      else {
        assert_failed = 0;
      }
      mem_free(p);
    }
  }
  else {
LAB_080eb7a0:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

string * add_to_string_list(list_head_elinks *list,uchar *source,int length)

{
  int *p;
  string_list_item *item;
  string *string_00;
  undefined *puVar1;
  int iVar2;
  void *pvVar3;
  string *string;
  char *objsize;
  size_t in_stack_ffffffc8;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = (int)(source == (uchar *)0x0 || list == (list_head_elinks *)0x0);
  if (source == (uchar *)0x0 || list == (list_head_elinks *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x215;
    elinks_internal((uchar *)"assertion list && source failed: [add_to_string_list]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  p = (int *)mem_alloc(0x10);
  if (p == (int *)0x0) {
    return (string *)0x0;
  }
  string_00 = (string *)(p + 2);
  if (length < 0) {
    length = strlen((char *)source);
  }
  if (assert_failed == 0) {
    assert_failed = 0;
    p[3] = 0;
    objsize = (char *)0x100;
    puVar1 = (undefined *)mem_alloc(0x100);
    p[2] = (int)puVar1;
    if (puVar1 == (undefined *)0x0) goto LAB_080eb9aa;
    *puVar1 = 0;
    if (assert_failed == 0) {
      if ((source == (uchar *)0x0) || (length < 0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        objsize = "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]";
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080eb9a0;
      }
      else {
        assert_failed = 0;
      }
      if (length == 0) {
LAB_080eb8fc:
                    // WARNING: Load size is inaccurate
        *p = *list->prev;
        p[1] = (int)list->prev;
        *(int **)list->prev = p;
        *(int **)(*p + 4) = p;
        return string_00;
      }
      iVar2 = length + p[3];
      pvVar3 = mem_align_alloc__((void **)string_00,p[3],iVar2 + 1,(size_t)objsize,in_stack_ffffffc8
                                );
      if (pvVar3 != (void *)0x0) {
        memcpy((void *)(p[2] + p[3]),source,length);
        *(undefined *)(p[2] + iVar2) = 0;
        p[3] = iVar2;
        goto LAB_080eb8fc;
      }
      goto LAB_080eb9aa;
    }
  }
LAB_080eb9a0:
  assert_failed = 0;
LAB_080eb9aa:
  done_string(string_00);
  mem_free(p);
  return (string *)0x0;
}



// WARNING: Unknown calling convention

string * string_concat(string *string,...)

{
  size_t __n;
  int iVar1;
  void *pvVar2;
  uchar *source;
  va_list ap;
  char **ppcVar3;
  uint uVar4;
  bool bVar5;
  char *objsize;
  char *in_stack_ffffffc8;
  char *__s;
  
  if (assert_failed == 0) {
    bVar5 = string == (string *)0x0;
    uVar4 = (uint)bVar5;
    assert_failed = uVar4;
    if (bVar5) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x1b6;
      elinks_internal((uchar *)"assertion string != NULL failed: [string_concat]");
      if (assert_failed != 0) goto LAB_080eba43;
    }
    ppcVar3 = (char **)&stack0x00000008;
    while (__s = *ppcVar3, __s != (char *)0x0) {
      ppcVar3 = ppcVar3 + 1;
      if (*__s != '\0') {
        if (assert_failed == 0) {
          assert_failed = uVar4;
          if (bVar5) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
            errline = 0x15b;
            elinks_internal((uchar *)"assertion string && source failed: [add_to_string]");
            if (assert_failed != 0) goto LAB_080ebaa0;
          }
          if (*__s != '\0') {
            objsize = __s;
            __n = strlen(__s);
            if ((string == (string *)0x0) || ((int)__n < 0)) {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 0xff;
              objsize = "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]";
              elinks_internal((uchar *)
                              "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                             );
              if (assert_failed != 0) goto LAB_080ebaa0;
            }
            assert_failed = 0;
            if (__n != 0) {
              iVar1 = __n + string->length;
              pvVar2 = mem_align_alloc__(&string->source,string->length,iVar1 + 1,(size_t)objsize,
                                         (size_t)in_stack_ffffffc8);
              if (pvVar2 != (void *)0x0) {
                memcpy(string->source + string->length,__s,__n);
                string->source[iVar1] = '\0';
                string->length = iVar1;
                in_stack_ffffffc8 = __s;
              }
            }
          }
        }
        else {
LAB_080ebaa0:
          assert_failed = 0;
        }
      }
    }
  }
  else {
LAB_080eba43:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_crlf_to_string(string *string)

{
  int iVar1;
  uchar *puVar2;
  size_t newsize;
  uint size;
  size_t oldsize;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = (int)(string == (string *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x169;
    elinks_internal((uchar *)"assertion string != NULL failed: [add_crlf_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  size = string->length + 0x102U & 0xffffff00;
  uVar3 = string->length + 0xffU & 0xffffff00;
  if (uVar3 < size) {
    puVar2 = (uchar *)mem_realloc(string->source,size);
    if (puVar2 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar2;
    memset(puVar2 + uVar3,0,size - uVar3);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  iVar1 = string->length;
  string->source[iVar1] = '\r';
  string->source[iVar1 + 1] = '\n';
  string->length = iVar1 + 2;
  string->source[iVar1 + 2] = '\0';
  return string;
}



// WARNING: Unknown calling convention

string * add_char_to_string(string *string,uchar character)

{
  int iVar1;
  uchar *puVar2;
  size_t newsize;
  uint size;
  size_t oldsize;
  uint uVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = (int)(character == '\0' || string == (string *)0x0);
  if (character == '\0' || string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 0x1c9;
    elinks_internal((uchar *)"assertion string && character failed: [add_char_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  size = string->length + 0x101U & 0xffffff00;
  uVar3 = string->length + 0xffU & 0xffffff00;
  if (uVar3 < size) {
    puVar2 = (uchar *)mem_realloc(string->source,size);
    if (puVar2 == (uchar *)0x0) {
      return (string *)0x0;
    }
    string->source = puVar2;
    memset(puVar2 + uVar3,0,size - uVar3);
  }
  if (string->source == (uchar *)0x0) {
    return (string *)0x0;
  }
  iVar1 = string->length;
  string->source[iVar1] = character;
  string->length = iVar1 + 1;
  string->source[iVar1 + 1] = '\0';
  return string;
}



// WARNING: Unknown calling convention

string * add_to_string(string *string,uchar *source)

{
  int iVar1;
  uchar uVar2;
  size_t __n;
  void *pvVar3;
  char *objsize;
  size_t in_stack_ffffffc8;
  
  if (assert_failed == 0) {
    assert_failed = (int)(source == (uchar *)0x0 || string == (string *)0x0);
    if (source == (uchar *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x15b;
      elinks_internal((uchar *)"assertion string && source failed: [add_to_string]");
      if (assert_failed != 0) goto LAB_080ebe3f;
      uVar2 = *source;
      assert_failed = 0;
    }
    else {
      uVar2 = *source;
    }
    if (uVar2 == '\0') {
      return string;
    }
    objsize = (char *)source;
    __n = strlen((char *)source);
    if ((string == (string *)0x0) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      objsize = "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]";
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ebe3f;
    }
    else {
      assert_failed = 0;
    }
    if (__n != 0) {
      iVar1 = __n + string->length;
      pvVar3 = mem_align_alloc__(&string->source,string->length,iVar1 + 1,(size_t)objsize,
                                 in_stack_ffffffc8);
      if (pvVar3 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memcpy(string->source + string->length,source,__n);
        string->source[iVar1] = '\0';
        string->length = iVar1;
      }
    }
  }
  else {
LAB_080ebe3f:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_string_to_string(string *string,string *from)

{
  int iVar1;
  size_t __n;
  uchar *__src;
  void *pvVar2;
  int newlength;
  char *in_stack_ffffffc4;
  size_t in_stack_ffffffc8;
  
  if (assert_failed == 0) {
    assert_failed = (int)(from == (string *)0x0 || string == (string *)0x0);
    if (from == (string *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
      errline = 0x17c;
      in_stack_ffffffc4 = "assertion string && from failed: [add_string_to_string]";
      elinks_internal((uchar *)"assertion string && from failed: [add_string_to_string]");
      if (assert_failed != 0) goto LAB_080ebf9f;
      __n = from->length;
      assert_failed = 0;
    }
    else {
      __n = from->length;
    }
    if (__n == 0) {
      return string;
    }
    __src = from->source;
    if (((string == (string *)0x0) || (__src == (uchar *)0x0)) || ((int)__n < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      in_stack_ffffffc4 = "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]";
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080ebf9f;
    }
    else {
      assert_failed = 0;
    }
    iVar1 = string->length + __n;
    pvVar2 = mem_align_alloc__(&string->source,string->length,iVar1 + 1,(size_t)in_stack_ffffffc4,
                               in_stack_ffffffc8);
    if (pvVar2 == (void *)0x0) {
      string = (string *)0x0;
    }
    else {
      memcpy(string->source + string->length,__src,__n);
      string->source[iVar1] = '\0';
      string->length = iVar1;
    }
  }
  else {
LAB_080ebf9f:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



// WARNING: Unknown calling convention

string * add_file_to_string(string *string,uchar *filename)

{
  int iVar1;
  uint uVar2;
  FILE *__stream;
  FILE *file;
  int iVar3;
  size_t sVar4;
  uchar *puVar5;
  uint uVar6;
  size_t oldsize;
  size_t newsize;
  uint size;
  __off64_t _Var7;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (string *)0x0;
  }
  assert_failed = (int)(filename == (uchar *)0x0 || string == (string *)0x0);
  if (filename == (uchar *)0x0 || string == (string *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 399;
    elinks_internal((uchar *)"assertion string && filename failed: [add_file_to_string]");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (string *)0x0;
    }
  }
  __stream = fopen64((char *)filename,"rb");
  if (__stream == (FILE *)0x0) {
    return (string *)0x0;
  }
  iVar3 = fseeko64(__stream,0,2);
  if (iVar3 == 0) {
    _Var7 = ftello64(__stream);
    if ((_Var7 != -1) && (iVar3 = fseeko64(__stream,0,0), iVar3 == 0)) {
      iVar3 = (size_t)_Var7 + string->length;
      uVar6 = string->length + 0xff;
      uVar2 = uVar6 >> 8;
      uVar6 = uVar6 & 0xffffff00;
      size = iVar3 + 0x100U & 0xffffff00;
      if (uVar6 <= size && size + uVar2 * -0x100 != 0) {
        puVar5 = (uchar *)mem_realloc(string->source,size);
        if (puVar5 == (uchar *)0x0) goto err;
        string->source = puVar5;
        memset(puVar5 + uVar6,0,size + uVar2 * -0x100);
      }
      if (string->source != (uchar *)0x0) {
        iVar1 = string->length;
        sVar4 = fread(string->source + iVar1,1,(size_t)_Var7,__stream);
        iVar1 = sVar4 + iVar1;
        string->length = iVar1;
        string->source[iVar1] = '\0';
        fclose(__stream);
        if (string->length == iVar3) {
          return string;
        }
      }
    }
  }
err:
  fclose(__stream);
  return (string *)0x0;
}



// WARNING: Unknown calling convention

timeval_T * timeval_sub_interval(timeval_T *t,timeval_T *interval)

{
  int iVar1;
  int iVar2;
  
  iVar1 = t->sec - interval->sec;
  t->sec = iVar1;
  if (iVar1 < 0) {
LAB_080ec2d8:
    t->sec = 0;
    t->usec = 0;
    return t;
  }
  iVar2 = t->usec - interval->usec;
  t->usec = iVar2;
  if (iVar2 < 0) {
    do {
      iVar1 = iVar1 + -1;
      iVar2 = iVar2 + 1000000;
    } while (iVar2 < 0);
    t->usec = iVar2;
    t->sec = iVar1;
    if (iVar1 < 0) goto LAB_080ec2d8;
  }
  return t;
}



// WARNING: Unknown calling convention

timeval_T * timeval_sub(timeval_T *res,timeval_T *older,timeval_T *newer)

{
  int iVar1;
  int iVar2;
  
  iVar1 = newer->sec - older->sec;
  res->sec = iVar1;
  iVar2 = newer->usec - older->usec;
  res->usec = iVar2;
  if (iVar2 < 0) {
    do {
      iVar1 = iVar1 + -1;
      iVar2 = iVar2 + 1000000;
    } while (iVar2 < 0);
    res->usec = iVar2;
    res->sec = iVar1;
  }
  return res;
}



// WARNING: Unknown calling convention

timeval_T * timeval_add(timeval_T *res,timeval_T *base,timeval_T *t)

{
  int iVar1;
  int iVar2;
  
  iVar1 = t->sec + base->sec;
  res->sec = iVar1;
  iVar2 = t->usec + base->usec;
  res->usec = iVar2;
  if (999999 < iVar2) {
    do {
      iVar2 = iVar2 + -1000000;
      iVar1 = iVar1 + 1;
    } while (999999 < iVar2);
    res->usec = iVar2;
    res->sec = iVar1;
  }
  return res;
}



// WARNING: Unknown calling convention

timeval_T * timeval_add_interval(timeval_T *t,timeval_T *interval)

{
  int iVar1;
  int iVar2;
  
  t->sec = t->sec + interval->sec;
  iVar2 = t->usec + interval->usec;
  t->usec = iVar2;
  if (999999 < iVar2) {
    iVar1 = t->sec;
    do {
      iVar2 = iVar2 + -1000000;
      iVar1 = iVar1 + 1;
    } while (999999 < iVar2);
    t->usec = iVar2;
    t->sec = iVar1;
  }
  return t;
}



// WARNING: Unknown calling convention

timeval_T * timeval_from_double(timeval_T *t,double x)

{
  t->sec = (int)ROUND(x);
  t->usec = (int)ROUND((x - (double)(int)ROUND(x)) * 1000000.0);
  return t;
}



// WARNING: Unknown calling convention

timeval_T * timeval_from_milliseconds(timeval_T *t,milliseconds_T milliseconds)

{
  t->sec = milliseconds / 1000;
  t->usec = (milliseconds % 1000) * 1000;
  return t;
}



// WARNING: Unknown calling convention

timeval_T * timeval_from_seconds(timeval_T *t,long seconds)

{
  t->usec = 0;
  t->sec = seconds;
  return t;
}



// WARNING: Unknown calling convention

long timeval_to_seconds(timeval_T *t)

{
  return t->usec / 1000000 + t->sec;
}



// WARNING: Unknown calling convention

int timeval_is_positive(timeval_T *t)

{
  if (0 < t->sec) {
    return 1;
  }
  if (t->sec == 0) {
    return (uint)(0 < t->usec);
  }
  return 0;
}



// WARNING: Unknown calling convention

void timeval_limit_to_zero_or_one(timeval_T *t)

{
  if (t->sec < 0) {
    t->sec = 0;
  }
  if (-1 < t->usec) {
    return;
  }
  t->usec = 0;
  return;
}



// WARNING: Unknown calling convention

int timeval_cmp(timeval_T *t1,timeval_T *t2)

{
  int iVar1;
  int iVar2;
  
  iVar2 = 1;
  iVar1 = t2->sec;
  if (t1->sec == iVar1 || t1->sec < iVar1) {
    if (t1->sec < iVar1) {
      iVar2 = -1;
    }
    else {
      iVar2 = t1->usec - t2->usec;
    }
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int timeval_div_off_t(off_t n,timeval_T *t)

{
  longlong lVar1;
  int iVar2;
  
  iVar2 = 0x7fffffff;
  lVar1 = (longlong)t->sec * 1000 + (longlong)(t->usec / 1000);
  if (lVar1 != 0) {
    iVar2 = __divdi3(n * 1000,lVar1);
  }
  return iVar2;
}



// WARNING: Unknown calling convention

milliseconds_T mult_ms(milliseconds_T a,long lb)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0x20c49b;
  }
  if (((lb < 0) || (a < 0)) || ((int)(0x7fffffff / (longlong)lb) <= a)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 0xb7;
    elinks_internal((uchar *)"assertion la >= 0 && lb >= 0 && la < LONG_MAX / lb failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0x20c49b;
    }
  }
  else {
    assert_failed = 0;
  }
  return lb * a;
}



// WARNING: Unknown calling convention

milliseconds_T add_ms_to_ms(milliseconds_T a,milliseconds_T b)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0x20c49b;
  }
  if (((b < 0) || (a < 0)) || (0x7fffffff - a <= b)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 0xac;
    elinks_internal((uchar *)"assertion la >= 0 && lb >= 0 && lb < LONG_MAX - la failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0x20c49b;
    }
  }
  else {
    assert_failed = 0;
  }
  return b + a;
}



// WARNING: Unknown calling convention

milliseconds_T sec_to_ms(long sec)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0x20c49b;
  }
  assert_failed = (int)(0x20c49a < (uint)sec);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 0xa0;
    elinks_internal((uchar *)"assertion sec >= 0 && sec < LONG_MAX / 1000L failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0x20c49b;
    }
  }
  return sec * 1000;
}



// WARNING: Unknown calling convention

milliseconds_T timeval_to_milliseconds(timeval_T *t)

{
  milliseconds_T mVar1;
  milliseconds_T a;
  
  mVar1 = sec_to_ms(t->sec);
  mVar1 = add_ms_to_ms(mVar1,t->usec / 1000);
  return mVar1;
}



// WARNING: Unknown calling convention

timeval_T * timeval_now(timeval_T *t)

{
  timeval tv;
  
  gettimeofday((timeval *)&tv,(__timezone_ptr_t)0x0);
  t->sec = tv.tv_sec;
  t->usec = tv.tv_usec;
  return t;
}



// WARNING: Unknown calling convention

void goto_url_action(session *ses,_func_uchar_ptr_session_ptr_uchar_ptr_size_t *get_url)

{
  int iVar1;
  uchar *puVar2;
  int in_GS_OFFSET;
  uchar url [1024];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  if (get_url != (_func_uchar_ptr_session_ptr_uchar_ptr_size_t *)0x0) {
    puVar2 = (*get_url)(ses,url,0x400);
    if (puVar2 != (uchar *)0x0) goto LAB_080ec87b;
  }
  url[0] = '\0';
LAB_080ec87b:
  dialog_goto_url(ses,url);
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

frame_event_status do_action(session *ses,main_action action_id,int verbose)

{
  terminal *term;
  window *pwVar1;
  insert_mode iVar2;
  document_view *doc_view_00;
  action *paVar3;
  action *action;
  action *action_1;
  action *action_2;
  frame_event_status status;
  action *action_3;
  action *action_4;
  action *action_5;
  frame_event_status fVar4;
  int iVar5;
  option_value *poVar6;
  uchar *puVar7;
  int count;
  int iVar8;
  int count_1;
  window *pwVar9;
  document_view *doc_view;
  link *link;
  bool bVar10;
  link *local_24;
  
  term = ses->tab->term;
  doc_view_00 = current_frame(ses);
  if (action_id == ~ACT_MAIN_NONE) {
    link = (link *)0x0;
unknown_action:
    fVar4 = FRAME_EVENT_IGNORED;
    bVar10 = false;
    if (verbose != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/action.c";
      errline = 0x27b;
      puVar7 = get_action_name(KEYMAP_MAIN,action_id);
      elinks_internal((uchar *)"No action handling defined for \'%s\'.",puVar7);
      fVar4 = FRAME_EVENT_IGNORED;
      bVar10 = false;
    }
    goto LAB_080ec9e9;
  }
  if ((doc_view_00 == (document_view *)0x0) || (doc_view_00->vs == (view_state *)0x0)) {
    paVar3 = get_action(KEYMAP_MAIN,action_id);
    if ((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 2) != 0))
    goto LAB_080eca45;
LAB_080ec926:
    link = (link *)0x0;
  }
  else {
    paVar3 = get_action(KEYMAP_MAIN,action_id);
    if (((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 8) != 0)) &&
       (iVar5 = try_jump_to_link_number(ses,doc_view_00), iVar5 == 0)) {
LAB_080eca45:
      bVar10 = false;
      link = (link *)0x0;
      fVar4 = FRAME_EVENT_OK;
      iVar2 = ses->insert_mode;
      goto joined_r0x080eca57;
    }
    iVar5 = doc_view_00->vs->current_link;
    if ((iVar5 < 0) || (doc_view_00->document->nlinks <= iVar5)) goto LAB_080ec926;
    link = doc_view_00->document->links + iVar5;
  }
  paVar3 = get_action(KEYMAP_MAIN,action_id);
  if (((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 4) != 0)) &&
     ((ses->history).current == (location *)0x0)) {
    return FRAME_EVENT_OK;
  }
  paVar3 = get_action(KEYMAP_MAIN,action_id);
  if (((((paVar3 != (action *)0x0) && ((*(byte *)((int)&paVar3->flags + 2) & 0x10) != 0)) &&
       (link == (link *)0x0)) ||
      (((paVar3 = get_action(KEYMAP_MAIN,action_id), paVar3 != (action *)0x0 &&
        ((*(byte *)((int)&paVar3->flags + 2) & 0x20) != 0)) &&
       ((link == (link *)0x0 || (link->type < LINK_BUTTON)))))) ||
     (((paVar3 = get_action(KEYMAP_MAIN,action_id), paVar3 == (action *)0x0 ||
       ((*(byte *)((int)&paVar3->flags + 2) & 1) != 0)) &&
      (poVar6 = get_opt_(), poVar6->tree != (list_head_elinks *)0x0))))
  goto switchD_080ecb10_caseD_10;
  switch(action_id) {
  default:
    goto unknown_action;
  case ACT_MAIN_ABORT_CONNECTION:
    abort_loading(ses,1);
    print_screen_status(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_ADD_BOOKMARK:
    launch_bm_add_doc_dialog(term,(dialog_data *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_ADD_BOOKMARK_LINK:
    launch_bm_add_link_dialog(term,(dialog_data *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_ADD_BOOKMARK_TABS:
    bookmark_terminal_tabs_dialog(term);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_AUTH_MANAGER:
    auth_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_BACKSPACE_PREFIX:
    if ((ses->kbdprefix).repeat_count != 0) {
      draw_formatted(ses,0);
      iVar5 = (ses->kbdprefix).repeat_count / 10;
      (ses->kbdprefix).repeat_count = iVar5;
      if (iVar5 != 0) {
        highlight_links_with_prefixes_that_start_with_n(term,doc_view_00,iVar5);
      }
      print_screen_status(ses);
      return FRAME_EVENT_SESSION_DESTROYED;
    }
    goto switchD_080ecb10_caseD_10;
  case ACT_MAIN_BOOKMARK_MANAGER:
    bookmark_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_CACHE_MANAGER:
    cache_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_CACHE_MINIMIZE:
    goto switchD_080ecb10_caseD_a;
  case ACT_MAIN_COOKIE_MANAGER:
    cookie_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_COOKIES_LOAD:
    poVar6 = get_opt_();
    if (poVar6->tree == (list_head_elinks *)0x0) goto switchD_080ecb10_caseD_10;
    load_cookies();
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_COPY_CLIPBOARD:
    fVar4 = copy_current_link_to_clipboard(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_DOCUMENT_INFO:
    document_info_dialog(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_DOWNLOAD_MANAGER:
    download_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_EXMODE:
  case ACT_MAIN_JUMP_TO_LINK:
  case ACT_MAIN_LUA_CONSOLE:
    goto switchD_080ecb10_caseD_10;
  case ACT_MAIN_FILE_MENU:
    activate_bfu_technology(ses,0);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_FIND_NEXT:
    fVar4 = find_next(ses,doc_view_00,1);
    goto ignore_action;
  case ACT_MAIN_FIND_NEXT_BACK:
    fVar4 = find_next(ses,doc_view_00,-1);
    goto ignore_action;
  case ACT_MAIN_FORGET_CREDENTIALS:
    free_auth();
    goto switchD_080ecb10_caseD_a;
  case ACT_MAIN_FORMHIST_MANAGER:
    formhist_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_FRAME_EXTERNAL_COMMAND:
    fVar4 = pass_uri_to_command(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_FRAME_MAXIMIZE:
    fVar4 = set_frame(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_FRAME_NEXT:
    iVar5 = 1;
    goto LAB_080ed5ee;
  case ACT_MAIN_FRAME_PREV:
    iVar5 = -1;
LAB_080ed5ee:
    next_frame(ses,iVar5);
    draw_formatted(ses,0);
    goto switchD_080ecb10_caseD_10;
  case ACT_MAIN_GOTO_URL:
    goto_url_action(ses,(_func_uchar_ptr_session_ptr_uchar_ptr_size_t *)0x0);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_GOTO_URL_CURRENT:
    goto_url_action(ses,get_current_url);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_GOTO_URL_CURRENT_LINK:
    goto_url_action(ses,get_current_link_url);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_GOTO_URL_HOME:
    goto_url_home(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_HEADER_INFO:
    protocol_header_dialog(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_HISTORY_MANAGER:
    history_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_HISTORY_MOVE_BACK:
    iVar8 = eat_kbd_repeat_count(ses);
    iVar5 = -1;
    if (0 < iVar8) {
      iVar5 = -iVar8;
    }
    go_history_by_n(ses,iVar5);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_HISTORY_MOVE_FORWARD:
    count = eat_kbd_repeat_count(ses);
    if (count < 1) {
      count = 1;
    }
    go_history_by_n(ses,count);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_KEYBINDING_MANAGER:
    keybinding_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_KILL_BACKGROUNDED_CONNECTIONS:
    abort_background_connections();
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_LINK_DOWNLOAD:
  case ACT_MAIN_LINK_DOWNLOAD_IMAGE:
  case ACT_MAIN_LINK_DOWNLOAD_RESUME:
    fVar4 = download_link(ses,doc_view_00,action_id);
    goto ignore_action;
  case ACT_MAIN_LINK_EXTERNAL_COMMAND:
    fVar4 = pass_uri_to_command(ses,doc_view_00,1);
    goto ignore_action;
  case ACT_MAIN_LINK_FOLLOW:
    fVar4 = enter(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_LINK_FOLLOW_RELOAD:
    fVar4 = enter(ses,doc_view_00,1);
    goto ignore_action;
  case ACT_MAIN_LINK_MENU:
    link_menu(term,(void *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_LINK_FORM_MENU:
    link_form_menu(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_MARK_GOTO:
    bVar10 = doc_view_00 != (document_view *)0x0;
    fVar4 = FRAME_EVENT_REFRESH;
    (ses->kbdprefix).mark = DOM_SCAN_END;
    break;
  case ACT_MAIN_MARK_SET:
    bVar10 = doc_view_00 != (document_view *)0x0;
    fVar4 = FRAME_EVENT_REFRESH;
    (ses->kbdprefix).mark = CONTINUE_DOWNLOAD_DO;
    break;
  case ACT_MAIN_MENU:
    activate_bfu_technology(ses,-1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_MOVE_CURSOR_DOWN:
    fVar4 = move_cursor_down(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_LEFT:
    fVar4 = move_cursor_left(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_LINE_START:
    fVar4 = move_cursor_line_start(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_RIGHT:
    fVar4 = move_cursor_right(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_CURSOR_UP:
    fVar4 = move_cursor_up(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_DOCUMENT_END:
    fVar4 = move_document_end(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_DOCUMENT_START:
    fVar4 = move_document_start(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_DOWN:
    fVar4 = move_link_dir(ses,doc_view_00,0,1);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_DOWN_LINE:
    fVar4 = move_link_down_line(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_LEFT:
    fVar4 = move_link_dir(ses,doc_view_00,-1,0);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_LEFT_LINE:
    fVar4 = move_link_prev_line(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_NEXT:
    fVar4 = move_link(ses,doc_view_00,1,doc_view_00->document->nlinks + -1,0);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_PREV:
    fVar4 = move_link(ses,doc_view_00,-1,0,doc_view_00->document->nlinks + -1);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_RIGHT:
    fVar4 = move_link_dir(ses,doc_view_00,1,0);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_RIGHT_LINE:
    fVar4 = move_link_next_line(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_UP:
    fVar4 = move_link_dir(ses,doc_view_00,0,-1);
    goto ignore_action;
  case ACT_MAIN_MOVE_LINK_UP_LINE:
    fVar4 = move_link_up_line(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_PAGE_DOWN:
    fVar4 = move_page_down(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_MOVE_PAGE_UP:
    fVar4 = move_page_up(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_OPEN_LINK_IN_NEW_TAB:
    open_current_link_in_new_tab(ses,0);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND:
    open_current_link_in_new_tab(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW:
    open_in_new_window(term,send_open_in_new_window,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_OPEN_NEW_TAB:
    iVar5 = 0;
    goto LAB_080ecac0;
  case ACT_MAIN_OPEN_NEW_TAB_IN_BACKGROUND:
    iVar5 = 1;
LAB_080ecac0:
    open_uri_in_new_tab(ses,(uri *)0x0,iVar5,1);
switchD_080ecb10_caseD_10:
    bVar10 = false;
    fVar4 = FRAME_EVENT_OK;
    break;
  case ACT_MAIN_OPEN_NEW_WINDOW:
    open_in_new_window(term,send_open_new_window,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_OPEN_OS_SHELL:
    exec_shell(term);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_OPTIONS_MANAGER:
    options_manager(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_QUIT:
    exit_prog(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_REALLY_QUIT:
    exit_prog(ses,0);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_REDRAW:
    redraw_terminal_cls(term);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_RELOAD:
    reload(ses,CACHE_MODE_INCREMENT);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_RERENDER:
    draw_formatted(ses,2);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_RESET_FORM:
    fVar4 = reset_form(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_RESOURCE_INFO:
    resource_info(term);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_SAVE_AS:
    fVar4 = save_as(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_SAVE_FORMATTED:
    fVar4 = save_formatted_dlg(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_SAVE_OPTIONS:
    write_config(term);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_SAVE_URL_AS:
    save_url_as(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_SCROLL_DOWN:
    fVar4 = scroll_down(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_SCROLL_LEFT:
    fVar4 = scroll_left(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_SCROLL_RIGHT:
    fVar4 = scroll_right(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_SCROLL_UP:
    fVar4 = scroll_up(ses,doc_view_00);
    goto ignore_action;
  case ACT_MAIN_SEARCH:
    fVar4 = search_dlg(ses,doc_view_00,1);
    goto ignore_action;
  case ACT_MAIN_SEARCH_BACK:
    fVar4 = search_dlg(ses,doc_view_00,-1);
    goto ignore_action;
  case ACT_MAIN_SEARCH_TYPEAHEAD:
  case ACT_MAIN_SEARCH_TYPEAHEAD_LINK:
  case ACT_MAIN_SEARCH_TYPEAHEAD_TEXT:
  case ACT_MAIN_SEARCH_TYPEAHEAD_TEXT_BACK:
    fVar4 = search_typeahead(ses,doc_view_00,action_id);
    goto ignore_action;
  case ACT_MAIN_SHOW_TERM_OPTIONS:
    terminal_options(term,(void *)0x0,ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_SUBMIT_FORM:
    fVar4 = submit_form(ses,doc_view_00,0);
    goto ignore_action;
  case ACT_MAIN_SUBMIT_FORM_RELOAD:
    fVar4 = submit_form(ses,doc_view_00,1);
    goto ignore_action;
  case ACT_MAIN_TAB_CLOSE:
    close_tab(term,ses);
    return FRAME_EVENT_SESSION_DESTROYED;
  case ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT:
    close_all_tabs_but_current(ses);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TAB_EXTERNAL_COMMAND:
    fVar4 = pass_uri_to_command(ses,doc_view_00,2);
    goto ignore_action;
  case ACT_MAIN_TAB_MENU:
    if (assert_failed == 0) {
      pwVar1 = ses->tab;
      pwVar9 = get_tab_by_number(term,term->current_tab);
      bVar10 = pwVar1 != pwVar9;
      assert_failed = (int)bVar10;
      if (bVar10) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/action.c";
        errline = 0x231;
        elinks_internal((uchar *)"assertion ses->tab == get_current_tab(term) failed!");
      }
    }
    if ((*(byte *)&ses->status & 1) == 0) {
      tab_menu(ses,0,0,0);
      fVar4 = FRAME_EVENT_OK;
      bVar10 = false;
    }
    else {
      tab_menu(ses,ses->tab->xpos,(term->height + -1) - (*(byte *)&ses->status >> 1 & 1),1);
      fVar4 = FRAME_EVENT_OK;
      bVar10 = false;
    }
    break;
  case ACT_MAIN_TAB_MOVE_LEFT:
    move_current_tab(ses,-1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TAB_MOVE_RIGHT:
    move_current_tab(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TAB_NEXT:
    switch_current_tab(ses,1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TAB_PREV:
    switch_current_tab(ses,-1);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TERMINAL_RESIZE:
    resize_terminal_dialog(term);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_CSS:
    toggle_document_option(ses,(uchar *)"document.css.enable");
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_DISPLAY_IMAGES:
    toggle_document_option(ses,(uchar *)"document.browse.images.show_as_links");
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_DISPLAY_TABLES:
    toggle_document_option(ses,(uchar *)"document.html.display_tables");
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_DOCUMENT_COLORS:
    toggle_document_option(ses,(uchar *)"document.colors.use_document_colors");
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_HTML_PLAIN:
    toggle_plain_html(ses,ses->doc_view,0);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_MOUSE:
    toggle_mouse();
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_NUMBERED_LINKS:
    toggle_document_option(ses,(uchar *)"document.browse.links.numbering");
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES:
    toggle_document_option(ses,(uchar *)"document.plain.compress_empty_lines");
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_TOGGLE_WRAP_TEXT:
    toggle_wrap_text(ses,ses->doc_view,0);
    fVar4 = FRAME_EVENT_OK;
    bVar10 = false;
    break;
  case ACT_MAIN_VIEW_IMAGE:
    fVar4 = view_image(ses,doc_view_00,0);
ignore_action:
    if (fVar4 == FRAME_EVENT_SESSION_DESTROYED) {
      return FRAME_EVENT_SESSION_DESTROYED;
    }
    bVar10 = fVar4 == FRAME_EVENT_REFRESH && doc_view_00 != (document_view *)0x0;
  }
LAB_080ec9e9:
  iVar2 = ses->insert_mode;
joined_r0x080eca57:
  if (iVar2 == INSERT_MODE_ON) {
    if (((doc_view_00 == (document_view *)0x0) || (iVar5 = doc_view_00->vs->current_link, iVar5 < 0)
        ) || (doc_view_00->document->nlinks <= iVar5)) {
      local_24 = (link *)0x0;
    }
    else {
      local_24 = doc_view_00->document->links + iVar5;
    }
    if (local_24 != link) {
      ses->insert_mode = INSERT_MODE_OFF;
    }
  }
  if (bVar10) {
    refresh_view(ses,doc_view_00,0);
    fVar4 = FRAME_EVENT_REFRESH;
  }
  return fVar4;
switchD_080ecb10_caseD_a:
  shrink_memory(1);
  goto switchD_080ecb10_caseD_10;
}



// WARNING: Unknown calling convention

int get_timer_duration(void)

{
  return timer_duration;
}



// WARNING: Unknown calling convention

void done_timer(module *module)

{
  kill_timer(&countdown);
  return;
}



// WARNING: Unknown calling convention

void reset_timer(void)

{
  option_value *poVar1;
  
  kill_timer(&countdown);
  poVar1 = get_opt_();
  if (poVar1->tree == (list_head_elinks *)0x0) {
    return;
  }
  poVar1 = get_opt_();
  timer_duration = poVar1->number;
  install_timer(&countdown,1000,count_down,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

void init_timer(module *module)

{
  reset_timer();
  return;
}



// WARNING: Unknown calling convention

void count_down(void *xxx)

{
  option_value *poVar1;
  keybinding *pkVar2;
  keybinding *keybinding;
  terminal *terminal;
  terminal *term;
  term_event ev;
  
  timer_duration = timer_duration + -1;
  if (timer_duration == 0) {
    countdown = (timer_id_T)0x0;
    poVar1 = get_opt_();
    pkVar2 = kbd_nm_lookup(KEYMAP_MAIN,poVar1->string);
    if (pkVar2 != (keybinding *)0x0) {
      ev.info.mouse.y = (pkVar2->kbd).modifier;
      ev.info.mouse.x = (pkVar2->kbd).key;
      ev.info.mouse.button = 0;
      ev.ev = EVENT_KBD;
      if ((list_head_elinks *)terminals.next != &terminals) {
        term = (terminal *)terminals.next;
        do {
          term_send_event(term,&ev);
          term = term->next;
        } while (term != (terminal *)&terminals);
      }
    }
    reset_timer();
    return;
  }
  install_timer(&countdown,1000,count_down,(void *)0x0);
  return;
}



// WARNING: Unknown calling convention

dump_output * dump_output_alloc(int fd,string *string)

{
  dump_output *out;
  
  if (assert_failed == 0) {
    assert_failed = (int)((string == (string *)0x0) != (fd != -1));
    if ((string == (string *)0x0) != (fd != -1)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x5e;
      elinks_internal((uchar *)"assertion (fd == -1) ^ (string == NULL) failed!");
      if (assert_failed != 0) goto LAB_080ed99a;
    }
    out = (dump_output *)mem_alloc(0x1000c);
    if (out != (dump_output *)0x0) {
      out->fd = fd;
      out->string = string;
      out->bufpos = 0;
      return out;
    }
  }
  else {
LAB_080ed99a:
    assert_failed = 0;
    out = (dump_output *)0x0;
  }
  return out;
}



// WARNING: Unknown calling convention

int dump_output_flush(dump_output *out)

{
  int iVar1;
  uint uVar2;
  string *psVar3;
  size_t __n;
  size_t sVar4;
  uchar *puVar5;
  int newlength;
  size_t newsize;
  uint size;
  
  psVar3 = out->string;
  if (psVar3 == (string *)0x0) {
    sVar4 = hard_write(out->fd,out->buf,out->bufpos);
    if (sVar4 != out->bufpos) {
      return -1;
    }
  }
  else {
    __n = out->bufpos;
    if (assert_failed != 0) {
      assert_failed = 0;
      return -1;
    }
    if ((int)__n < 0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) {
        assert_failed = 0;
        return -1;
      }
    }
    else {
      assert_failed = 0;
      if (__n == 0) goto LAB_080eda5c;
    }
    iVar1 = __n + psVar3->length;
    uVar2 = psVar3->length + 0xffU & 0xffffff00;
    size = iVar1 + 0x100U & 0xffffff00;
    if (uVar2 < size) {
      puVar5 = (uchar *)mem_realloc(psVar3->source,size);
      if (puVar5 == (uchar *)0x0) {
        return -1;
      }
      psVar3->source = puVar5;
      memset(puVar5 + uVar2,0,size - uVar2);
    }
    if (psVar3->source == (uchar *)0x0) {
      return -1;
    }
    memcpy(psVar3->source + psVar3->length,out->buf,__n);
    psVar3->source[iVar1] = '\0';
    psVar3->length = iVar1;
  }
LAB_080eda5c:
  out->bufpos = 0;
  return 0;
}



// WARNING: Unknown calling convention

int write_char(uchar c,dump_output *out)

{
  uint uVar1;
  int iVar2;
  
  uVar1 = out->bufpos;
  if (0xffff < uVar1) {
    iVar2 = dump_output_flush(out);
    if (iVar2 != 0) {
      return -1;
    }
    uVar1 = out->bufpos;
  }
  out->buf[uVar1] = c;
  out->bufpos = uVar1 + 1;
  return 0;
}



// WARNING: Unknown calling convention

int write_color_16(uchar color,dump_output *out)

{
  int iVar1;
  int iVar2;
  int background;
  uchar *data;
  uchar *puVar3;
  int in_GS_OFFSET;
  uchar bufor [11];
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  bufor[5] = (color & 7) + 0x30;
  bufor[4] = 0x33;
  bufor[6] = ';';
  bufor[7] = '4';
  bufor[0] = '\x1b';
  bufor[1] = '[';
  bufor[2] = '0';
  bufor[3] = ';';
  bufor[8] = '0';
  bufor[9] = 'm';
  bufor[10] = '\0';
  if ((color >> 4 & 7) == 0) {
    bufor._4_3_ = CONCAT12(0x6d,bufor._4_2_);
    bufor[7] = '\0';
  }
  else {
    bufor[9] = 0x6d;
    bufor[8] = (color >> 4 & 7) + 0x30;
  }
  puVar3 = bufor;
  do {
    if (*puVar3 == '\0') {
      iVar2 = 0;
LAB_080edc45:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return iVar2;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    iVar2 = write_char(*puVar3,out);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_080edc45;
    }
    puVar3 = puVar3 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int dump_nocolor(document *document,dump_output *out)

{
  uchar attr;
  int iVar1;
  line *plVar2;
  int iVar3;
  uchar *puVar4;
  int white;
  int white_1;
  uchar c;
  byte c_00;
  unicode_val_T c_1;
  uint u;
  int local_2c;
  int local_20;
  
  iVar1 = is_cp_utf8((document->options).cp);
  if (iVar1 == 0) {
    local_2c = 0;
    if (0 < document->height) {
      do {
        iVar1 = 0;
        plVar2 = document->data + local_2c;
        local_20 = 0;
        if (0 < plVar2->length) {
          do {
            c_00 = *(byte *)&plVar2->chars[local_20].data;
            if (((c_00 < 0xb0) || (-1 < (char)plVar2->chars[local_20].attr)) || (0xdf < c_00)) {
              if (c_00 != 0x7f) goto LAB_080edd58;
LAB_080edcf9:
              iVar1 = iVar1 + 1;
            }
            else {
              c_00 = *(byte *)((int)&process_queue::lexical_block_0::os2xtd[0xea].key + (uint)c_00);
              if (c_00 == 0x7f) goto LAB_080edcf9;
LAB_080edd58:
              if ((c_00 < 0x20) || (c_00 == 0x20)) goto LAB_080edcf9;
              for (; iVar1 != 0; iVar1 = iVar1 + -1) {
                iVar3 = write_char(' ',out);
                if (iVar3 != 0) goto LAB_080edd8a;
              }
              iVar1 = write_char(c_00,out);
              if (iVar1 != 0) goto LAB_080edd8a;
              iVar1 = 0;
            }
            local_20 = local_20 + 1;
            plVar2 = document->data + local_2c;
          } while (local_20 < plVar2->length);
        }
        iVar1 = write_char('\n',out);
        if (iVar1 != 0) goto LAB_080edd8a;
        local_2c = local_2c + 1;
      } while (local_2c < document->height);
    }
  }
  else {
    local_2c = 0;
    if (0 < document->height) {
      do {
        iVar1 = 0;
        plVar2 = document->data + local_2c;
        local_20 = 0;
        if (0 < plVar2->length) {
          do {
            u = plVar2->chars[local_20].data;
            if (u != 0xfffffffd) {
              if ((((char)plVar2->chars[local_20].attr < '\0') && (0xaf < u)) && (u < 0xe0)) {
                u = (uint)*(byte *)((int)&process_queue::lexical_block_0::os2xtd[0xea].key + u);
              }
              if (((u - 0x20 < 0x5f) || (0x9f < u)) && (u != 0x20)) {
                for (; iVar1 != 0; iVar1 = iVar1 + -1) {
                  iVar3 = write_char(' ',out);
                  if (iVar3 != 0) goto LAB_080edd8a;
                }
                for (puVar4 = encode_utf8(u); *puVar4 != '\0'; puVar4 = puVar4 + 1) {
                  iVar1 = write_char(*puVar4,out);
                  if (iVar1 != 0) goto LAB_080edd8a;
                }
                iVar1 = 0;
              }
              else {
                iVar1 = iVar1 + 1;
              }
            }
            local_20 = local_20 + 1;
            plVar2 = document->data + local_2c;
          } while (local_20 < plVar2->length);
        }
        iVar1 = write_char('\n',out);
        if (iVar1 != 0) goto LAB_080edd8a;
        local_2c = local_2c + 1;
      } while (local_2c < document->height);
    }
  }
  iVar3 = dump_output_flush(out);
  iVar1 = 0;
  if (iVar3 != 0) {
LAB_080edd8a:
    iVar1 = -1;
  }
  return iVar1;
}



// WARNING: Unknown calling convention

string * add_document_to_string(string *string,document *document)

{
  dump_output *out_00;
  dump_output *out;
  int iVar1;
  int error;
  
  if (assert_failed == 0) {
    assert_failed = (int)(document == (document *)0x0 || string == (string *)0x0);
    if (document == (document *)0x0 || string == (string *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x262;
      elinks_internal((uchar *)"assertion string && document failed!");
      if (assert_failed != 0) goto LAB_080edfb2;
    }
    out_00 = dump_output_alloc(-1,string);
    if (out_00 != (dump_output *)0x0) {
      iVar1 = dump_nocolor(document,out_00);
      mem_free(out_00);
      if (iVar1 == 0) {
        return string;
      }
    }
  }
  else {
LAB_080edfb2:
    assert_failed = 0;
  }
  return (string *)0x0;
}



// WARNING: Unknown calling convention

int write_color_256(uchar *str,uchar color,dump_output *out)

{
  int iVar1;
  int iVar2;
  uchar *data;
  uchar *puVar3;
  int in_GS_OFFSET;
  uchar bufor [16];
  
  puVar3 = bufor;
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  __snprintf_chk(puVar3,0x10,1,0x10,&DAT_08135123,str,color);
  do {
    if (*puVar3 == '\0') {
      iVar2 = 0;
LAB_080ee03d:
      if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
        return iVar2;
      }
                    // WARNING: Subroutine does not return
      __stack_chk_fail();
    }
    iVar2 = write_char(*puVar3,out);
    if (iVar2 != 0) {
      iVar2 = -1;
      goto LAB_080ee03d;
    }
    puVar3 = puVar3 + 1;
  } while( true );
}



// WARNING: Unknown calling convention

int dump_256color(document *document,dump_output *out)

{
  uchar uVar1;
  uchar color;
  uchar c;
  uchar uVar8;
  uchar foreground_1;
  int iVar2;
  option_value *poVar3;
  screen_char *psVar4;
  int iVar5;
  uchar *puVar6;
  line *plVar7;
  int x;
  int iVar9;
  unicode_val_T c_1;
  uint uVar10;
  uchar background;
  uchar uVar11;
  uchar background_1;
  uchar foreground;
  int width;
  int local_38;
  byte local_24;
  uchar local_1d;
  
  iVar2 = is_cp_utf8((document->options).cp);
  if (iVar2 == 0) {
    poVar3 = get_opt_();
    iVar2 = poVar3->number;
    if (0 < document->height) {
      local_38 = 0;
      uVar11 = '\0';
      foreground = '\0';
      do {
        write_color_256("38",foreground,out);
        write_color_256("48",uVar11,out);
        plVar7 = document->data + local_38;
        if (plVar7->length < 1) {
          iVar9 = 0;
        }
        else {
          iVar9 = 0;
          uVar8 = foreground;
          local_1d = uVar11;
          do {
            psVar4 = plVar7->chars + iVar9;
            uVar1 = psVar4->attr;
            foreground = psVar4->color[0];
            uVar11 = psVar4->color[1];
            uVar10 = psVar4->data;
            if (((foreground != uVar8) && (iVar5 = write_color_256("38",foreground,out), iVar5 != 0)
                ) || ((uVar11 != local_1d && (iVar5 = write_color_256("48",uVar11,out), iVar5 != 0))
                     )) goto LAB_080ee1c0;
            local_24 = (byte)uVar10;
            if (((0xaf < local_24) && ((char)uVar1 < '\0')) && (local_24 < 0xe0)) {
              local_24 = *(byte *)((int)&process_queue::lexical_block_0::os2xtd[0xea].key +
                                  (uVar10 & 0xff));
            }
            if ((local_24 == 0x7f) || (local_24 < 0x20)) {
              iVar5 = write_char(' ',out);
            }
            else {
              iVar5 = write_char(local_24,out);
            }
            if (iVar5 != 0) goto LAB_080ee1c0;
            iVar9 = iVar9 + 1;
            plVar7 = document->data + local_38;
            uVar8 = foreground;
            local_1d = uVar11;
          } while (iVar9 < plVar7->length);
        }
        for (; iVar9 < iVar2; iVar9 = iVar9 + 1) {
          iVar5 = write_char(' ',out);
          if (iVar5 != 0) goto LAB_080ee1c0;
        }
        iVar9 = write_char('\n',out);
        if (iVar9 != 0) goto LAB_080ee1c0;
        local_38 = local_38 + 1;
      } while (local_38 < document->height);
    }
  }
  else {
    poVar3 = get_opt_();
    iVar2 = poVar3->number;
    if (0 < document->height) {
      local_38 = 0;
      uVar11 = '\0';
      local_1d = '\0';
      do {
        write_color_256("38",local_1d,out);
        write_color_256("48",uVar11,out);
        plVar7 = document->data + local_38;
        if (plVar7->length < 1) {
          iVar9 = 0;
        }
        else {
          iVar9 = 0;
          do {
            psVar4 = plVar7->chars + iVar9;
            uVar8 = psVar4->attr;
            uVar1 = psVar4->color[0];
            uVar10 = psVar4->data;
            color = psVar4->color[1];
            if (uVar10 != 0xfffffffd) {
              if (((uVar1 != local_1d) && (iVar5 = write_color_256("38",uVar1,out), iVar5 != 0)) ||
                 ((color != uVar11 && (iVar5 = write_color_256("48",color,out), iVar5 != 0))))
              goto LAB_080ee1c0;
              if ((((char)uVar8 < '\0') && (0xaf < uVar10)) && (uVar10 < 0xe0)) {
                uVar10 = (uint)*(byte *)((int)&process_queue::lexical_block_0::os2xtd[0xea].key +
                                        uVar10);
              }
              if ((0x5e < uVar10 - 0x20) && (uVar10 < 0xa0)) {
                uVar10 = 0x20;
              }
              for (puVar6 = encode_utf8(uVar10); uVar11 = color, local_1d = uVar1, *puVar6 != '\0';
                  puVar6 = puVar6 + 1) {
                iVar5 = write_char(*puVar6,out);
                if (iVar5 != 0) goto LAB_080ee1c0;
              }
            }
            iVar9 = iVar9 + 1;
            plVar7 = document->data + local_38;
          } while (iVar9 < plVar7->length);
        }
        for (; iVar9 < iVar2; iVar9 = iVar9 + 1) {
          iVar5 = write_char(' ',out);
          if (iVar5 != 0) goto LAB_080ee1c0;
        }
        iVar9 = write_char('\n',out);
        if (iVar9 != 0) goto LAB_080ee1c0;
        local_38 = local_38 + 1;
      } while (local_38 < document->height);
    }
  }
  iVar9 = dump_output_flush(out);
  iVar2 = 0;
  if (iVar9 != 0) {
LAB_080ee1c0:
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

int dump_references(document *document,int fd,uchar *buf)

{
  link *plVar1;
  int iVar2;
  bool bVar3;
  int x;
  option_value *poVar4;
  ssize_t sVar5;
  uchar *where;
  size_t datalen;
  size_t sVar6;
  link *link;
  int iVar7;
  char *pcVar8;
  bool bVar9;
  char *pcVar10;
  char *pcVar11;
  
  if ((document->nlinks != 0) && (poVar4 = get_opt_(), poVar4->tree != (list_head_elinks *)0x0)) {
    sVar5 = hard_write(fd,(uchar *)"\nReferences\n\n   Visible links\n",0x1e);
    if (sVar5 != 0x1e) {
      return -1;
    }
    if (0 < document->nlinks) {
      iVar7 = 0;
      pcVar8 = (char *)0x1;
      do {
        plVar1 = document->links;
        iVar2 = *(int *)((int)&plVar1->where + iVar7);
        if (iVar2 != 0) {
          if (((document->options).field_0x45 & 0x10) == 0) {
            pcVar11 = *(char **)((int)&plVar1->title + iVar7);
            if ((pcVar11 != (char *)0x0) && (*pcVar11 != '\0')) {
              pcVar10 = "   . %s\n\t%s\n";
              goto LAB_080ee549;
            }
            __snprintf_chk(buf,0x10000,1,0xffffffff,"   . %s\n",iVar2);
          }
          else {
            pcVar11 = *(char **)((int)&plVar1->title + iVar7);
            if ((pcVar11 == (char *)0x0) || (*pcVar11 == '\0')) {
              pcVar10 = "%4d. %s\n";
              pcVar11 = pcVar8;
LAB_080ee549:
              __snprintf_chk(buf,0x10000,1,0xffffffff,pcVar10,pcVar11,iVar2);
            }
            else {
              __snprintf_chk(buf,0x10000,1,0xffffffff,"%4d. %s\n\t%s\n",pcVar8,pcVar11,iVar2);
            }
          }
          datalen = strlen((char *)buf);
          sVar6 = hard_write(fd,buf,datalen);
          if (sVar6 != datalen) {
            return -1;
          }
        }
        iVar7 = iVar7 + 0x34;
        bVar9 = (char *)document->nlinks != pcVar8;
        bVar3 = (int)pcVar8 <= document->nlinks;
        pcVar8 = pcVar8 + 1;
      } while (bVar9 && bVar3);
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int dump_to_file(document *document,int fd)

{
  dump_output *out_00;
  int iVar1;
  int error;
  dump_output *out;
  
  out_00 = dump_output_alloc(fd,(string *)0x0);
  iVar1 = -1;
  if (out_00 != (dump_output *)0x0) {
    iVar1 = dump_nocolor(document,out_00);
    if (iVar1 == 0) {
      iVar1 = dump_references(document,fd,out_00->buf);
    }
    mem_free(out_00);
  }
  return iVar1;
}



// WARNING: Unknown calling convention

void dump_print(uchar *option_elinks,string *url)

{
  uint uVar1;
  uchar ch;
  option_value *poVar2;
  string *psVar3;
  string *psVar4;
  uchar *puVar5;
  int p;
  size_t __n;
  int iVar6;
  code cVar7;
  size_t newsize;
  string *size;
  uchar *str;
  string *__src;
  uchar *realstr;
  string string;
  
  poVar2 = get_opt_();
  __src = (string *)poVar2->command;
  if ((__src == (string *)0x0) || (psVar3 = init_string(&string), psVar3 == (string *)0x0)) {
    return;
  }
LAB_080ee6f0:
  cVar7 = *(code *)&__src->source;
  do {
    if (cVar7 == (code)0x0) goto LAB_080ee763;
    if ((cVar7 == (code)0x25) || (__n = 0, cVar7 == (code)0x5c)) {
      __n = 0;
      psVar3 = __src;
    }
    else {
      do {
        __n = __n + 1;
        cVar7 = *(code *)((int)&__src->source + __n);
        psVar3 = (string *)((int)&__src->source + __n);
        if ((cVar7 == (code)0x25) || (cVar7 == (code)0x0)) break;
      } while (cVar7 != (code)0x5c);
    }
    if (assert_failed == 0) {
      if ((int)__n < 0) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]",
                        option_elinks);
        if (assert_failed != 0) goto LAB_080ee737;
      }
      else {
        assert_failed = 0;
      }
      if (__n != 0) {
        iVar6 = __n + string.length;
        uVar1 = string.length + 0xffU >> 8;
        psVar4 = (string *)(string.length + 0xffU & 0xffffff00);
        size = (string *)(iVar6 + 0x100U & 0xffffff00);
        if (psVar4 <= size && size + uVar1 * -0x20 != (string *)0x0) {
          option_elinks = (uchar *)size;
          puVar5 = (uchar *)mem_realloc(string.source,(size_t)size);
          if (puVar5 == (uchar *)0x0) goto LAB_080ee748;
          option_elinks = (uchar *)0x0;
          string.source = puVar5;
          memset(puVar5 + (int)psVar4,0,(size_t)(size + uVar1 * -0x20));
        }
        if (string.source != (uchar *)0x0) {
          memcpy(string.source + string.length,__src,__n);
          string.source[iVar6] = '\0';
          option_elinks = (uchar *)__src;
          string.length = iVar6;
        }
      }
    }
    else {
LAB_080ee737:
      assert_failed = 0;
    }
LAB_080ee748:
    if (*(code *)&psVar3->source != (code)0x5c) break;
    cVar7 = *(code *)((int)&psVar3->source + 1);
    if (cVar7 == (code)0x6e) {
      option_elinks = (uchar *)0xa;
    }
    else if (cVar7 == (code)0x74) {
      option_elinks = &DAT_00000009;
    }
    else if (cVar7 == (code)0x66) {
      option_elinks = &DAT_0000000c;
    }
    else {
      if (cVar7 == (code)0x0) goto LAB_080ee763;
      option_elinks = (uchar *)(uint)(byte)cVar7;
    }
    __src = (string *)((int)&psVar3->source + 2);
    add_char_to_string(&string,(uchar)option_elinks);
    cVar7 = *(code *)&__src->source;
  } while( true );
  if (*(code *)&psVar3->source != (code)0x25) {
LAB_080ee763:
    puVar5 = string.source;
    if (string.source == (uchar *)0x0) {
      return;
    }
    __printf_chk(1,"%s",string.source);
    fflush(stdout);
    mem_free(puVar5);
    return;
  }
  cVar7 = *(code *)((int)&psVar3->source + 1);
  if (cVar7 == (code)0x75) {
    if (url == (string *)0x0) goto LAB_080ee7a0;
    option_elinks = (uchar *)url;
    add_string_to_string(&string,url);
    cVar7 = *(code *)((int)&psVar3->source + 1);
  }
  if (cVar7 == (code)0x0) goto LAB_080ee763;
LAB_080ee7a0:
  __src = (string *)((int)&psVar3->source + 2);
  goto LAB_080ee6f0;
}



// WARNING: Unknown calling convention

void dump_next(list_head_elinks *url_list)

{
  list_head_elinks *plVar1;
  uchar *uristring;
  void *pvVar2;
  uchar *puVar3;
  uri *uri_00;
  protocol_external_handler_T *ppVar4;
  int iVar5;
  uri *uri;
  uchar *wd;
  
  if (url_list != (list_head_elinks *)0x0) {
    while (plVar1 = (list_head_elinks *)url_list->next, plVar1 != url_list) {
      *(void **)((int)plVar1->next + 4) = plVar1->prev;
      *(void **)plVar1->prev = plVar1->next;
                    // WARNING: Load size is inaccurate
      plVar1->next = *dump_next::todo_list.prev;
      plVar1->prev = dump_next::todo_list.prev;
      *(list_head_elinks **)dump_next::todo_list.prev = plVar1;
      *(list_head_elinks **)((int)plVar1->next + 4) = plVar1;
    }
  }
  pvVar2 = dump_next::todo_list.next;
  if ((list_head_elinks *)dump_next::todo_list.next == &dump_next::todo_list) {
    free_string_list(&dump_next::done_list);
    program.terminate = 1;
    return;
  }
  program.terminate = 0;
                    // WARNING: Load size is inaccurate
  *(undefined4 *)(*dump_next::todo_list.next + 4) =
       *(undefined4 *)((int)dump_next::todo_list.next + 4);
                    // WARNING: Load size is inaccurate
  **(undefined4 **)((int)pvVar2 + 4) = *pvVar2;
  *(list_head_elinks **)((int)pvVar2 + 4) = &dump_next::done_list;
  *(void **)pvVar2 = dump_next::done_list.next;
  dump_next::done_list.next = pvVar2;
                    // WARNING: Load size is inaccurate
  *(void **)(*pvVar2 + 4) = pvVar2;
  if (dump_next::lexical_block_0::first == 0) {
    dump_print((uchar *)"document.dump.separator",(string *)0x0);
  }
  else {
    dump_next::lexical_block_0::first = 0;
  }
  dump_print((uchar *)"document.dump.header",(string *)((int)pvVar2 + 8));
  uristring = *(uchar **)((int)pvVar2 + 8);
  puVar3 = get_cwd();
  uri_00 = get_translated_uri(uristring,puVar3);
  if (puVar3 != (uchar *)0x0) {
    mem_free(puVar3);
  }
  if ((uri_00 == (uri *)0x0) ||
     (ppVar4 = get_protocol_external_handler((terminal *)0x0,uri_00),
     ppVar4 != (protocol_external_handler_T *)0x0)) {
    puVar3 = gettext((uchar *)"URL protocol not supported (%s).");
    usrerror(puVar3,uristring);
    dump_next((list_head_elinks *)0x0);
    program.terminate = 1;
    program.retval = RET_SYNTAX;
    if (uri_00 == (uri *)0x0) goto LAB_080eea75;
  }
  else {
    dump_download.callback = dump_loading_callback;
    dump_pos = 0;
    iVar5 = load_uri(uri_00,(uri *)0x0,&dump_download,PRI_DOWNLOAD,CACHE_MODE_ALWAYS,-1);
    if (iVar5 != 0) {
      dump_next((list_head_elinks *)0x0);
      program.terminate = 1;
      program.retval = RET_SYNTAX;
    }
  }
  done_uri(uri_00);
LAB_080eea75:
  dump_print((uchar *)"document.dump.footer",(string *)((int)pvVar2 + 8));
  return;
}



// WARNING: Unknown calling convention

void dump_loading_callback(download *download,void *p)

{
  uchar uVar1;
  cache_entry *pcVar2;
  uri *uri_00;
  bool bVar3;
  document *pdVar4;
  uchar c;
  uchar uVar5;
  int fd;
  option_value *poVar6;
  int width;
  dump_output *out_00;
  dump_output *out;
  uchar *puVar7;
  int iVar8;
  int error;
  connection_basic_state cVar9;
  fragment *frag;
  size_t sVar10;
  int w;
  int iVar11;
  int *piVar12;
  char *pcVar13;
  uchar attr_1;
  uchar attr;
  int iVar14;
  line *plVar15;
  screen_char *psVar16;
  cache_entry *cached;
  int x_1;
  uint uVar17;
  int x;
  uri *uri;
  int width_1;
  uchar color_1;
  uchar color;
  uchar uVar18;
  document_view *pdVar19;
  size_t datalen;
  byte bVar20;
  int local_130;
  int local_124;
  document_options o;
  document_view formatted;
  view_state vs;
  
  bVar20 = 0;
  pcVar2 = download->cached;
  fd = get_output_handle();
  if (fd == -1) {
    return;
  }
  if (((pcVar2 != (cache_entry *)0x0) && (pcVar2->redirect != (uri *)0x0)) &&
     (iVar14 = dump_redir_count + 1, bVar3 = dump_redir_count < 10, dump_redir_count = iVar14, bVar3
     )) {
    uri_00 = pcVar2->redirect;
    cancel_download(download,0);
    load_uri(uri_00,pcVar2->uri,download,PRI_DOWNLOAD,CACHE_MODE_ALWAYS,-1);
    return;
  }
  if ((uint)(download->state).basic < 8) {
    return;
  }
  poVar6 = get_opt_();
  if (poVar6->tree == (list_head_elinks *)0x0) {
    if (pcVar2 != (cache_entry *)0x0) {
LAB_080eef27:
      piVar12 = (int *)(pcVar2->frag).next;
      if ((list_head_elinks *)piVar12 != &pcVar2->frag) {
        do {
          uVar17 = dump_pos - piVar12[2];
          if (-1 < (int)uVar17) {
            iVar8 = (int)uVar17 >> 0x1f;
            iVar14 = piVar12[5];
            if ((piVar12[5] != iVar8 && iVar8 <= iVar14) ||
               ((iVar8 <= iVar14 && (uVar17 < (uint)piVar12[4])))) goto LAB_080eef56;
          }
          piVar12 = (int *)*piVar12;
          if ((list_head_elinks *)piVar12 == &pcVar2->frag) break;
        } while( true );
      }
    }
    cVar9 = (download->state).basic;
    if (S_ERRNO < cVar9) {
      return;
    }
    goto LAB_080eee5f;
  }
  cVar9 = (download->state).basic;
  if (S_PROC < cVar9) {
    return;
  }
  if (pcVar2 == (cache_entry *)0x0) goto LAB_080eee5f;
  pdVar19 = &formatted;
  for (iVar14 = 0xf; iVar14 != 0; iVar14 = iVar14 + -1) {
    pdVar19->next = (document_view *)0x0;
    pdVar19 = (document_view *)((int)pdVar19 + (uint)bVar20 * -8 + 4);
  }
  init_document_options(&o);
  poVar6 = get_opt_();
  o.box.x = 0;
  o.box.y = 1;
  o.box.height = 0x19;
  o.box.width = poVar6->number;
  if (poVar6->number < 0) {
    o.box.width = 0;
  }
  poVar6 = get_opt_();
  o.cp = poVar6->number;
  poVar6 = get_opt_();
  o.color_mode = poVar6->number;
  o._69_1_ = o._69_1_ & 0xbf;
  o._68_1_ = o._68_1_ & 0xef;
  poVar6 = get_opt_();
  o._69_1_ = o._69_1_ & 0xef | (byte)((poVar6->color & 1) << 4);
  init_vs(&vs,pcVar2->uri,-1);
  render_document(&vs,&formatted,&o);
  out_00 = dump_output_alloc(fd,(string *)0x0);
  pdVar4 = formatted.document;
  if (out_00 != (dump_output *)0x0) {
    if (o.color_mode == COLOR_MODE_88) {
LAB_080eefd9:
      iVar14 = dump_256color(formatted.document,out_00);
    }
    else {
      if (o.color_mode < COLOR_MODE_256) {
        if ((uint)(o.color_mode + COLOR_MODE_16) < 2) {
          iVar14 = dump_nocolor(formatted.document,out_00);
          goto joined_r0x080eefe7;
        }
      }
      else if (o.color_mode == COLOR_MODE_256) goto LAB_080eefd9;
      iVar14 = is_cp_utf8(((formatted.document)->options).cp);
      if (iVar14 == 0) {
        poVar6 = get_opt_();
        iVar14 = poVar6->number;
        if (0 < pdVar4->height) {
          local_130 = 0;
          uVar18 = '\0';
          do {
            write_color_16(uVar18,out_00);
            plVar15 = pdVar4->data + local_130;
            if (plVar15->length < 1) {
              iVar8 = 0;
            }
            else {
              iVar8 = 0;
              uVar5 = uVar18;
              do {
                psVar16 = plVar15->chars + iVar8;
                uVar18 = psVar16->color[0];
                uVar1 = psVar16->attr;
                uVar17 = psVar16->data;
                if ((uVar18 != uVar5) && (iVar11 = write_color_16(uVar18,out_00), iVar11 != 0))
                goto LAB_080eee30;
                c = (uchar)uVar17;
                if ((0xaf < c) && (((char)uVar1 < '\0' && (c < 0xe0)))) {
                  c = *(byte *)((int)&process_queue::lexical_block_0::os2xtd[0xea].key +
                               (uVar17 & 0xff));
                }
                if ((c == 0x7f) || (c < 0x20)) {
                  c = ' ';
                }
                iVar11 = write_char(c,out_00);
                if (iVar11 != 0) goto LAB_080eee30;
                iVar8 = iVar8 + 1;
                plVar15 = pdVar4->data + local_130;
                uVar5 = uVar18;
              } while (iVar8 < plVar15->length);
            }
            for (; iVar8 < iVar14; iVar8 = iVar8 + 1) {
              iVar11 = write_char(' ',out_00);
              if (iVar11 != 0) goto LAB_080eee30;
            }
            iVar8 = write_char('\n',out_00);
            if (iVar8 != 0) goto LAB_080eee30;
            local_130 = local_130 + 1;
          } while (local_130 < pdVar4->height);
        }
      }
      else {
        poVar6 = get_opt_();
        iVar14 = poVar6->number;
        if (0 < pdVar4->height) {
          local_130 = 0;
          color_1 = '\0';
          do {
            write_color_16(color_1,out_00);
            plVar15 = pdVar4->data + local_130;
            if (plVar15->length < 1) {
              local_124 = 0;
            }
            else {
              local_124 = 0;
              do {
                psVar16 = plVar15->chars + local_124;
                uVar17 = psVar16->data;
                uVar18 = psVar16->attr;
                uVar5 = psVar16->color[0];
                if (uVar17 != 0xfffffffd) {
                  if ((uVar5 != color_1) && (iVar8 = write_color_16(uVar5,out_00), iVar8 != 0))
                  goto LAB_080eee30;
                  if (((char)uVar18 < '\0') && ((0xaf < uVar17 && (uVar17 < 0xe0)))) {
                    uVar17 = (uint)*(byte *)((int)&process_queue::lexical_block_0::os2xtd[0xea].key
                                            + uVar17);
                  }
                  if ((0x5e < uVar17 - 0x20) && (uVar17 < 0xa0)) {
                    uVar17 = 0x20;
                  }
                  for (puVar7 = encode_utf8(uVar17); color_1 = uVar5, *puVar7 != '\0';
                      puVar7 = puVar7 + 1) {
                    iVar8 = write_char(*puVar7,out_00);
                    if (iVar8 != 0) goto LAB_080eee30;
                  }
                }
                local_124 = local_124 + 1;
                plVar15 = pdVar4->data + local_130;
              } while (local_124 < plVar15->length);
            }
            for (; local_124 < iVar14; local_124 = local_124 + 1) {
              iVar8 = write_char(' ',out_00);
              if (iVar8 != 0) goto LAB_080eee30;
            }
            iVar8 = write_char('\n',out_00);
            if (iVar8 != 0) goto LAB_080eee30;
            local_130 = local_130 + 1;
          } while (local_130 < pdVar4->height);
        }
      }
      iVar14 = dump_output_flush(out_00);
    }
joined_r0x080eefe7:
    if (iVar14 == 0) {
      dump_references(formatted.document,fd,out_00->buf);
    }
LAB_080eee30:
    mem_free(out_00);
  }
  detach_formatted(&formatted);
  destroy_vs(&vs,1);
  cVar9 = (download->state).basic;
LAB_080eee5f:
  if (cVar9 != S_OK) {
    puVar7 = get_state_message(download->state,(terminal *)0x0);
    usrerror(puVar7);
LAB_080eee8b:
    program.retval = RET_ERROR;
  }
  program.terminate = 1;
  dump_next((list_head_elinks *)0x0);
  return;
LAB_080eef56:
  datalen = piVar12[4] - uVar17;
  sVar10 = hard_write(fd,(uchar *)(uVar17 + 0x20 + (int)piVar12),datalen);
  if (datalen != sVar10) {
    detach_connection(download,(longlong)dump_pos);
    if ((int)sVar10 < 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x191;
      piVar12 = __errno_location();
      pcVar13 = strerror(*piVar12);
      puVar7 = gettext((uchar *)"Can\'t write to stdout: %s");
      elinks_error(puVar7,pcVar13);
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
      errline = 0x194;
      puVar7 = gettext((uchar *)"Can\'t write to stdout.");
      elinks_error(puVar7);
    }
    goto LAB_080eee8b;
  }
  dump_pos = datalen + dump_pos;
  detach_connection(download,(longlong)dump_pos);
  goto LAB_080eef27;
}



// WARNING: Unknown calling convention

void draw_frame_lines(terminal *term,frameset_desc *frameset_desc,int xp,int yp,color_pair *colors)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int x_00;
  int iVar5;
  int pj;
  int x_1;
  int width;
  int x;
  frameset_desc *pfVar6;
  int i;
  int iVar7;
  frame_desc *pfVar8;
  int local_4c;
  int local_44;
  int local_3c;
  int local_38;
  frameset_desc *local_30;
  box box;
  
  if (assert_failed == 0) {
    if ((frameset_desc == (frameset_desc *)0x0) || (term == (terminal *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x61;
      elinks_internal((uchar *)
                      "assertion term && frameset_desc && frameset_desc->frame_desc failed!");
      if (assert_failed != 0) goto LAB_080ef3a5;
    }
    else {
      assert_failed = 0;
    }
    if (0 < (frameset_desc->box).height) {
      local_4c = yp + -1;
      iVar5 = (frameset_desc->box).width;
      local_38 = 0;
      local_3c = local_4c;
LAB_080ef3f0:
      iVar3 = frameset_desc->frame_desc[local_38 * iVar5].height;
      if (0 < iVar5) {
        iVar7 = 0;
        iVar2 = local_3c + 1 + iVar3;
        iVar5 = xp + -1;
        local_30 = frameset_desc;
        do {
          iVar4 = local_30->frame_desc[0].width;
          if (iVar7 == 0) {
            x_00 = iVar5 + 1 + iVar4;
            if (local_38 == 0) goto LAB_080ef4d4;
            if (-1 < iVar5) {
              draw_border_cross(term,iVar5,local_3c,BORDER_X_RIGHT,colors);
            }
LAB_080ef52b:
            box.x = iVar5 + 1;
            if (box.x < 0) {
              box.x = 0;
            }
            box.height = 1;
            box.y = local_3c;
            if (local_3c < 0) {
              box.y = 0;
            }
            box.width = 0;
            if (-1 < iVar4) {
              box.width = iVar4;
            }
            draw_box(term,&box,0xc4,SCREEN_ATTR_FRAME,colors);
            x_00 = iVar5 + 1 + iVar4;
            if (((frameset_desc->box).width + -1 == iVar7) && (x_00 < term->width)) {
              draw_border_cross(term,x_00,local_3c,BORDER_X_LEFT,colors);
            }
            if ((iVar7 == 0) || (local_38 == 0)) goto LAB_080ef4d4;
            draw_border_char(term,iVar5,local_3c,BORDER_SCROSS,colors);
            piVar1 = &(frameset_desc->box).width;
            if (*piVar1 == iVar7 + 1 || *piVar1 < iVar7 + 1) goto LAB_080ef5e0;
          }
          else {
            box.x = 0;
            if (-1 < iVar5) {
              box.x = iVar5;
            }
            box.width = 1;
            box.y = local_3c + 1;
            if (local_3c + 1 < 0) {
              box.y = 0;
            }
            box.height = 0;
            if (-1 < iVar3) {
              box.height = iVar3;
            }
            draw_box(term,&box,0xb3,SCREEN_ATTR_FRAME,colors);
            if ((frameset_desc->box).height + -1 == local_38) {
              draw_border_cross(term,iVar5,iVar2,BORDER_X_UP,colors);
            }
            if (local_38 != 0) goto LAB_080ef52b;
            draw_border_cross(term,iVar5,local_3c,BORDER_X_DOWN,colors);
            x_00 = iVar5 + 1 + iVar4;
LAB_080ef4d4:
            piVar1 = &(frameset_desc->box).width;
            if (*piVar1 == iVar7 + 1 || *piVar1 < iVar7 + 1) goto LAB_080ef5e0;
          }
          local_30 = (frameset_desc *)local_30->frame_desc;
          iVar7 = iVar7 + 1;
          iVar5 = x_00;
        } while( true );
      }
      local_3c = local_3c + 1 + iVar3;
      iVar5 = (frameset_desc->box).height;
      if (local_38 + 1 < iVar5) goto LAB_080ef5f9;
LAB_080ef68f:
      if (0 < iVar5) {
        iVar5 = (frameset_desc->box).width;
        local_44 = 0;
        while( true ) {
          iVar3 = frameset_desc->frame_desc[local_44 * iVar5].height;
          if (0 < iVar5) {
            local_30 = (frameset_desc *)0x0;
            pfVar8 = frameset_desc->frame_desc + local_44 * iVar5;
            iVar5 = xp + -1;
            pfVar6 = frameset_desc;
            while( true ) {
              iVar2 = pfVar6->frame_desc[0].width;
              if (pfVar8->subframe != (frameset_desc *)0x0) {
                draw_frame_lines(term,pfVar8->subframe,iVar5 + 1,local_4c + 1,colors);
              }
              pfVar6 = (frameset_desc *)pfVar6->frame_desc;
              pfVar8 = pfVar8 + 1;
              local_30 = (frameset_desc *)((int)local_30 + 1);
              piVar1 = &(frameset_desc->box).width;
              if ((frameset_desc *)*piVar1 == local_30 || *piVar1 < (int)local_30) break;
              iVar5 = iVar2 + 1 + iVar5;
            }
          }
          local_44 = local_44 + 1;
          piVar1 = &(frameset_desc->box).height;
          if (*piVar1 == local_44 || *piVar1 < local_44) break;
          local_4c = local_4c + 1 + iVar3;
          iVar5 = (frameset_desc->box).width;
        }
      }
    }
  }
  else {
LAB_080ef3a5:
    assert_failed = 0;
  }
  return;
LAB_080ef5e0:
  iVar5 = (frameset_desc->box).height;
  local_3c = iVar2;
  if (iVar5 <= local_38 + 1) goto LAB_080ef68f;
LAB_080ef5f9:
  local_38 = local_38 + 1;
  iVar5 = (frameset_desc->box).width;
  goto LAB_080ef3f0;
}



// WARNING: Unknown calling convention

void draw_view_status(session *ses,document_view *doc_view,int active)

{
  terminal *term_00;
  terminal *term;
  
  term_00 = ses->tab->term;
  draw_forms(term_00,doc_view);
  if (active != 0) {
    draw_searched(term_00,doc_view);
    draw_current_link(ses,doc_view);
  }
  return;
}



// WARNING: Unknown calling convention

void draw_doc(session *ses,document_view *doc_view,int active)

{
  box *box_00;
  window *pwVar1;
  terminal *term;
  view_state *pvVar2;
  uri *uri;
  cache_entry *pcVar3;
  option_value *poVar4;
  string *psVar5;
  int iVar6;
  int vy;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  link *plVar11;
  uchar *puVar12;
  int *piVar13;
  cache_entry *cached;
  link *link;
  document *pdVar14;
  view_state *vs;
  int y;
  int iVar15;
  box *box;
  bool bVar16;
  char *x;
  link *local_38;
  string fragment;
  color_pair color;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) ||
      (doc_view == (document_view *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
    errline = 0xd0;
    elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && doc_view failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar6 = (doc_view->box).width;
  pwVar1 = ses->tab;
  term = pwVar1->term;
  if (iVar6 < 2) {
    return;
  }
  iVar7 = (doc_view->box).height;
  if (iVar7 < 2) {
    return;
  }
  if (active != 0) {
    if (ses->navigate_mode == NAVIGATE_CURSOR_ROUTING) {
      set_cursor(term,pwVar1->x,pwVar1->y,0);
    }
    else {
      set_cursor(term,iVar6 + (doc_view->box).x + -1,iVar7 + (doc_view->box).y + -1,1);
      ses->tab->x = (doc_view->box).x;
      ses->tab->y = (doc_view->box).y;
    }
  }
  x = "document.colors.text";
  poVar4 = get_opt_();
  color.foreground = poVar4->color;
  if (doc_view->document->height == 0) {
    x = "document.colors.background";
    poVar4 = get_opt_();
    color.background = poVar4->color;
  }
  else {
    color.background = doc_view->document->bgcolor;
  }
  pvVar2 = doc_view->vs;
  box_00 = &doc_view->box;
  if (pvVar2 == (view_state *)0x0) {
    draw_box(term,box_00,' ',0,&color);
    return;
  }
  if ((doc_view->document != (document *)0x0) &&
     (doc_view->document->frame_desc != (frameset_desc *)0x0)) {
    draw_box(term,box_00,' ',0,&color);
    draw_frame_lines(term,doc_view->document->frame_desc,(doc_view->box).x,(doc_view->box).y,&color)
    ;
    if (pvVar2->current_link == -1) {
      pvVar2->current_link = 0;
      return;
    }
    return;
  }
  if (ses->navigate_mode == NAVIGATE_LINKWISE) {
    check_vs(doc_view);
  }
  else {
    x = (char *)(ses->tab->x - (doc_view->box).x);
    plVar11 = get_link_at_coordinates(doc_view,(int)x,ses->tab->y - (doc_view->box).y);
    if (plVar11 != (link *)0x0) {
      iVar6 = doc_view->vs->current_link;
      if (iVar6 < 0) {
        local_38 = doc_view->document->links;
      }
      else {
        pdVar14 = doc_view->document;
        if (iVar6 < pdVar14->nlinks) {
          local_38 = pdVar14->links;
          if (plVar11 == local_38 + iVar6) goto LAB_080ef979;
        }
        else {
          local_38 = pdVar14->links;
        }
      }
      doc_view->vs->current_link = ((int)plVar11 - (int)local_38 >> 2) * -0x3b13b13b;
    }
  }
LAB_080ef979:
  if ((pvVar2->field_0x2c & 2) != 0) goto LAB_080efa71;
  pdVar14 = doc_view->document;
  uri = doc_view->vs->uri;
  if ((assert_failed == 0) &&
     (bVar16 = *(short *)&uri->field_0x34 == 0, assert_failed = (int)bVar16, bVar16)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
    errline = 0x35;
    elinks_internal((uchar *)"assertion uri->fragmentlen failed!",x);
  }
  psVar5 = init_string(&fragment);
  if (psVar5 == (string *)0x0) goto LAB_080efa71;
  psVar5 = add_uri_to_string(&fragment,uri,URI_FRAGMENT);
  if (psVar5 == (string *)0x0) {
    done_string(&fragment);
    goto LAB_080efa71;
  }
  decode_uri_string(&fragment);
  if (assert_failed == 0) {
    assert_failed = (int)(fragment.length == 0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x3d;
      elinks_internal((uchar *)"assertion fragment.length failed!");
      if (assert_failed != 0) goto LAB_080efa05;
    }
    assert_failed = (int)(*fragment.source == '\0');
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x3e;
      elinks_internal((uchar *)"assertion *fragment.source failed!");
    }
  }
LAB_080efa05:
  iVar6 = find_tag(pdVar14,fragment.source + 1,fragment.length + -1);
  if (iVar6 == -1) {
    pcVar3 = pdVar14->cached;
    if ((assert_failed == 0) &&
       (assert_failed = (int)(pcVar3 == (cache_entry *)0x0), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x45;
      elinks_internal((uchar *)"assertion cached failed!");
    }
    if (((pcVar3->field_0x5c & 8) != 0) || (pcVar3->cache_id != pdVar14->cache_id)) {
      done_string(&fragment);
      goto LAB_080efa71;
    }
    poVar4 = get_opt_();
    if (poVar4->tree != (list_head_elinks *)0x0) {
      puVar12 = msg_text(ses->tab->term,(uchar *)"The requested fragment \"%s\" doesn\'t exist.",
                         fragment.source);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"Missing fragment",ALIGN_CENTER,puVar12);
    }
LAB_080efe6c:
    done_string(&fragment);
  }
  else {
    if (iVar6 < 0) {
      iVar6 = 0;
      goto LAB_080efe6c;
    }
    iVar7 = pdVar14->height + -1;
    if (iVar7 < iVar6) {
      iVar6 = iVar7;
    }
    done_string(&fragment);
    if (iVar6 == -2) goto LAB_080efa71;
  }
  pvVar2->field_0x2c = pvVar2->field_0x2c | 2;
  if (-1 < iVar6) {
    doc_view->vs->y = iVar6;
    set_link(doc_view);
  }
LAB_080efa71:
  iVar6 = pvVar2->x;
  iVar7 = pvVar2->y;
  if ((((doc_view->last_x == -1) || (iVar6 != doc_view->last_x)) || (doc_view->last_y != iVar7)) ||
     (((doc_view->search_word != (uchar **)0x0 &&
       (puVar12 = *doc_view->search_word, puVar12 != (uchar *)0x0)) && (*puVar12 != '\0')))) {
    doc_view->last_y = iVar7;
    doc_view->last_x = iVar6;
    draw_box(term,box_00,' ',0,&color);
    iVar15 = doc_view->document->height;
    if (iVar15 != 0) {
      iVar8 = pvVar2->y;
      if (iVar15 <= iVar8) {
        do {
          iVar8 = iVar8 - (doc_view->box).height;
          pvVar2->y = iVar8;
          piVar13 = &doc_view->document->height;
        } while (*piVar13 == iVar8 || *piVar13 < iVar8);
      }
      if (iVar8 < 0) {
        pvVar2->y = 0;
        iVar15 = 0;
        local_38 = (link *)0x0;
      }
      else {
        local_38 = (link *)pvVar2->y;
        iVar15 = 0;
        if (-1 < (int)local_38) {
          iVar15 = (int)local_38;
        }
      }
      if (((link *)iVar7 != local_38) && (ses->navigate_mode == NAVIGATE_LINKWISE)) {
        check_vs(doc_view);
      }
      pdVar14 = doc_view->document;
      iVar7 = (int)local_38 + (doc_view->box).height;
      if (pdVar14->height < iVar7) {
        iVar7 = pdVar14->height;
      }
      if (iVar15 < iVar7) {
        iVar7 = iVar15 * 8;
        iVar8 = 0;
        if (-1 < iVar6) {
          iVar8 = iVar6;
        }
        do {
          iVar9 = iVar6 + (doc_view->box).width;
          piVar13 = (int *)((int)&pdVar14->data->chars + iVar7);
          iVar10 = piVar13[1];
          if (iVar9 <= iVar10) {
            iVar10 = iVar9;
          }
          if (0 < iVar10 - iVar8) {
            draw_line(term,(iVar8 - iVar6) + (doc_view->box).x,
                      (iVar15 - (int)local_38) + (doc_view->box).y,iVar10 - iVar8,
                      (screen_char *)(iVar8 * 8 + *piVar13));
            pdVar14 = doc_view->document;
          }
          iVar15 = iVar15 + 1;
          iVar7 = iVar7 + 8;
          iVar9 = (int)local_38 + (doc_view->box).height;
          iVar10 = pdVar14->height;
          if (iVar9 <= pdVar14->height) {
            iVar10 = iVar9;
          }
        } while (iVar15 < iVar10);
      }
      draw_view_status(ses,doc_view,active);
      if (((doc_view->search_word != (uchar **)0x0) &&
          (puVar12 = *doc_view->search_word, puVar12 != (uchar *)0x0)) && (*puVar12 != '\0')) {
        doc_view->last_y = -1;
        doc_view->last_x = -1;
      }
    }
  }
  else {
    clear_link(term,doc_view);
    draw_view_status(ses,doc_view,active);
  }
  return;
}



// WARNING: Unknown calling convention

void refresh_view(session *ses,document_view *doc_view,int frames)

{
  int *piVar1;
  window *pwVar2;
  terminal *term;
  document *pdVar3;
  location *plVar4;
  bool bVar5;
  window *pwVar6;
  int iVar7;
  int n;
  document_view *pdVar8;
  int d;
  int iVar9;
  document_view *doc_view_1;
  document_view *doc_view_00;
  int more;
  int iVar10;
  bool bVar11;
  document_view *local_20;
  
  pwVar2 = ses->tab;
  term = pwVar2->term;
  pwVar6 = get_tab_by_number(term,term->current_tab);
  if ((pwVar2 != pwVar6) || (draw_doc(ses,doc_view,1), frames == 0)) goto LAB_080effb1;
  if (assert_failed == 0) {
    if ((ses->doc_view == (document_view *)0x0) || (ses->doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x135;
      elinks_internal((uchar *)"assertion ses && ses->doc_view && ses->doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f010c;
    }
    else {
      assert_failed = 0;
    }
    pdVar3 = ses->doc_view->document;
    if ((pdVar3 != (document *)0x0) && (pdVar3->frame_desc != (frameset_desc *)0x0)) {
      local_20 = (document_view *)(ses->scrn_frames).next;
      iVar7 = 0;
      iVar10 = 1;
      if (local_20 != (document_view *)&ses->scrn_frames) {
        do {
          local_20->last_y = -1;
          iVar7 = iVar7 + 1;
          local_20->last_x = -1;
          local_20 = local_20->next;
        } while (local_20 != (document_view *)&ses->scrn_frames);
        iVar10 = 1;
        if (0 < iVar7) {
          iVar10 = iVar7;
        }
      }
      plVar4 = (ses->history).current;
      iVar7 = (plVar4->vs).current_link;
      iVar9 = 0;
      if (-1 < iVar7) {
        iVar9 = iVar7;
      }
      (plVar4->vs).current_link = iVar9 % iVar10;
      pdVar8 = current_frame(ses);
      iVar10 = 0;
      while (doc_view_00 = (document_view *)(ses->scrn_frames).next, doc_view_00 != local_20) {
        bVar5 = false;
        do {
          while( true ) {
            piVar1 = &doc_view_00->depth;
            bVar11 = *piVar1 != iVar10;
            if (bVar11) break;
            draw_doc(ses,doc_view_00,(uint)(pdVar8 == doc_view_00));
            doc_view_00 = doc_view_00->next;
            if (doc_view_00 == local_20) goto LAB_080f00c0;
          }
          doc_view_00 = doc_view_00->next;
          if (bVar11 && iVar10 <= *piVar1) {
            bVar5 = true;
          }
        } while (doc_view_00 != local_20);
LAB_080f00c0:
        if (!bVar5) break;
        iVar10 = iVar10 + 1;
      }
    }
  }
  else {
LAB_080f010c:
    assert_failed = 0;
  }
LAB_080effb1:
  print_screen_status(ses);
  return;
}



// WARNING: Unknown calling convention

void draw_formatted(session *ses,int rerender)

{
  window *pwVar1;
  terminal *ptVar2;
  location *plVar3;
  window *pwVar4;
  document_view *pdVar5;
  int iVar6;
  uint no_cache;
  box box;
  
  if (assert_failed == 0) {
    if ((ses == (session *)0x0) || (ses->tab == (window *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 0x157;
      elinks_internal((uchar *)"assertion ses && ses->tab failed!");
      if (assert_failed != 0) goto LAB_080f0228;
    }
    else {
      assert_failed = 0;
    }
    if (rerender != 0) {
      no_cache = rerender - 1;
      if ((no_cache & 2) == 0) {
        iVar6 = session_is_loading(ses);
        if (iVar6 != 0) {
          no_cache = no_cache | 2;
        }
      }
      render_document_frames(ses,no_cache);
      start_document_refreshes(ses);
    }
    pwVar1 = ses->tab;
    ptVar2 = pwVar1->term;
    pwVar4 = get_tab_by_number(ptVar2,ptVar2->current_tab);
    if (pwVar1 == pwVar4) {
      pdVar5 = ses->doc_view;
      if ((pdVar5 != (document_view *)0x0) && (pdVar5->document != (document *)0x0)) {
        if ((pdVar5->vs == (view_state *)0x0) &&
           (plVar3 = (ses->history).current, plVar3 != (location *)0x0)) {
          pdVar5->vs = &plVar3->vs;
          pdVar5 = ses->doc_view;
        }
        pdVar5->last_y = -1;
        pdVar5->last_x = -1;
        refresh_view(ses,ses->doc_view,1);
        return;
      }
      ptVar2 = ses->tab->term;
      box.width = ptVar2->width;
      box.x = 0;
      box.y = 1;
      if (box.width < 0) {
        box.width = 0;
      }
      iVar6 = ptVar2->height + -2;
      box.height = 0;
      if (-1 < iVar6) {
        box.height = iVar6;
      }
      draw_box(ses->tab->term,&box,' ',0,(color_pair *)0x0);
    }
  }
  else {
LAB_080f0228:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

form_control * find_form_control(document *document,form_state *fs)

{
  int iVar1;
  form_control *fc;
  form_control *pfVar2;
  form *form;
  int *piVar3;
  
  piVar3 = (int *)(document->forms).next;
  if ((list_head_elinks *)piVar3 == &document->forms) {
LAB_080f0318:
    piVar3 = (int *)0x0;
  }
  else {
    iVar1 = piVar3[2];
    while (iVar1 != fs->form_view->form_num) {
      piVar3 = (int *)*piVar3;
      if ((list_head_elinks *)piVar3 == &document->forms) goto LAB_080f0318;
      iVar1 = piVar3[2];
    }
  }
  pfVar2 = (form_control *)piVar3[9];
  if (pfVar2 != (form_control *)(piVar3 + 9)) {
    do {
      if (((pfVar2->g_ctrl_num == fs->g_ctrl_num) && (fs->position == pfVar2->position)) &&
         (fs->type == pfVar2->type)) {
        return pfVar2;
      }
      pfVar2 = pfVar2->next;
    } while (pfVar2 != (form_control *)(piVar3 + 9));
  }
  return (form_control *)0x0;
}



// WARNING: Unknown calling convention

form * find_form_by_form_view(document *document,form_view *fv)

{
  int iVar1;
  form *form;
  form *pfVar2;
  
  pfVar2 = (form *)(document->forms).next;
  if (pfVar2 == (form *)&document->forms) {
LAB_080f0383:
    pfVar2 = (form *)0x0;
  }
  else {
    iVar1 = pfVar2->form_num;
    while (iVar1 != fv->form_num) {
      pfVar2 = pfVar2->next;
      if (pfVar2 == (form *)&document->forms) goto LAB_080f0383;
      iVar1 = pfVar2->form_num;
    }
  }
  return pfVar2;
}



// WARNING: Unknown calling convention

uchar * get_form_label(form_control *fc)

{
  form_type fVar1;
  uchar *puVar2;
  
  if ((assert_failed == 0) && (assert_failed = (int)(fc->form == (form *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x751;
    elinks_internal((uchar *)"assertion fc->form failed!");
    fVar1 = fc->type;
  }
  else {
    fVar1 = fc->type;
  }
  if (FC_BUTTON < fVar1) {
    return (uchar *)0x0;
  }
                    // WARNING: Could not recover jumptable at 0x080f03c3. Too many branches
                    // WARNING: Treating indirect jump as call
  puVar2 = (uchar *)(*(code *)(&PTR_LAB_0810f7a0)[fc->type])();
  return puVar2;
}



// WARNING: Unknown calling convention

uchar * _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

void done_form_view(form_view *fv)

{
  mem_free(fv);
  return;
}



// WARNING: Unknown calling convention

void done_form_state(form_state *fs)

{
  void *p;
  
  if (fs->value != (uchar *)0x0) {
    mem_free(fs->value);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void done_submitted_value(submitted_value *sv)

{
  void *p;
  void *p_1;
  
  if (sv != (submitted_value *)0x0) {
    if (sv->value != (uchar *)0x0) {
      mem_free(sv->value);
    }
    if (sv->name != (uchar *)0x0) {
      mem_free(sv->name);
    }
    mem_free(sv);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void done_submitted_value_list(list_head_elinks *list)

{
  submitted_value *sv_00;
  submitted_value *psVar1;
  submitted_value *sv;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(list == (list_head_elinks *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x299;
    elinks_internal((uchar *)"assertion list failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  sv_00 = (submitted_value *)list->next;
  while (sv_00 != (submitted_value *)list) {
    psVar1 = sv_00->prev;
    sv_00->next->prev = psVar1;
    sv_00->prev->next = sv_00->next;
    done_submitted_value(sv_00);
    sv_00 = psVar1->next;
  }
  return;
}



// WARNING: Unknown calling convention

void link_form_menu_func(terminal *term,void *link_number_,void *ses_)

{
  int n;
  document_view *doc_view_00;
  document_view *doc_view;
  int link_number;
  
                    // WARNING: Load size is inaccurate
  n = *link_number_;
  mem_free(link_number_);
  if (assert_failed == 0) {
    assert_failed = (int)(ses_ == (void *)0x0 || term == (terminal *)0x0);
    if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x80c;
      elinks_internal((uchar *)"assertion term && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view_00 = current_frame((session *)ses_);
    if (doc_view_00 == (document_view *)0x0) {
      return;
    }
    if (assert_failed == 0) {
      if ((doc_view_00->vs == (view_state *)0x0) || (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x812;
        elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      jump_to_link_number((session *)ses_,doc_view_00,n);
      refresh_view((session *)ses_,doc_view_00,0);
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

frame_event_status submit_form(session *ses,document_view *doc_view,int do_reload)

{
  goto_current_link(ses,doc_view,do_reload);
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

void file_form_menu(terminal *term,void *path_,void *fs_)

{
  auto_complete_file(term,0,(uchar *)path_,set_file_form_state,file_form_menu,fs_);
  return;
}



// WARNING: Unknown calling convention

void set_file_form_state(terminal *term,void *filename_,void *fs_)

{
  size_t sVar1;
  
  if (*(void **)((int)fs_ + 0x10) != (void *)0x0) {
    mem_free(*(void **)((int)fs_ + 0x10));
  }
  *(void **)((int)fs_ + 0x10) = filename_;
  sVar1 = strlen((char *)filename_);
  *(size_t *)((int)fs_ + 0x14) = sVar1;
  redraw_terminal(term);
  return;
}



// WARNING: Unknown calling convention

void fixup_select_state(form_control *fc,form_state *fs)

{
  uchar **ppuVar1;
  int iVar2;
  uchar *puVar3;
  int iVar4;
  int i;
  int iVar5;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(fs == (form_state *)0x0 || fc == (form_control *)0x0);
  if (fs == (form_state *)0x0 || fc == (form_control *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x65;
    elinks_internal((uchar *)"assertion fc && fs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar4 = fs->state;
  if (iVar4 < 0) {
    puVar3 = fs->value;
    iVar5 = fc->nvalues;
  }
  else {
    iVar5 = fc->nvalues;
    if (iVar4 < iVar5) {
      puVar3 = fs->value;
      iVar4 = strcmp((char *)fc->values[iVar4],(char *)puVar3);
      if (iVar4 == 0) {
        return;
      }
    }
    else {
      puVar3 = fs->value;
    }
  }
  if (0 < iVar5) {
    iVar4 = 0;
    ppuVar1 = fc->values;
    do {
      iVar2 = strcmp((char *)ppuVar1[iVar4],(char *)puVar3);
      if (iVar2 == 0) {
        fs->state = iVar4;
        return;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar5);
  }
  fs->state = 0;
  if (puVar3 != (uchar *)0x0) {
    mem_free(puVar3);
  }
  puVar3 = "";
  if (fc->nvalues != 0) {
    puVar3 = *fc->values;
  }
  puVar3 = stracpy(puVar3);
  fs->value = puVar3;
  return;
}



// WARNING: Unknown calling convention

submitted_value *
init_submitted_value(uchar *name,uchar *value,form_type type,form_control *fc,int position)

{
  submitted_value *p;
  submitted_value *sv;
  uchar *puVar1;
  submitted_value *psVar2;
  
  p = (submitted_value *)mem_alloc(0x1c);
  psVar2 = p;
  if (p != (submitted_value *)0x0) {
    puVar1 = stracpy(value);
    p->value = puVar1;
    if (puVar1 != (uchar *)0x0) {
      puVar1 = stracpy(name);
      p->name = puVar1;
      if (puVar1 != (uchar *)0x0) {
        p->type = type;
        p->form_control = fc;
        p->position = position;
        return p;
      }
      mem_free(p->value);
    }
    psVar2 = (submitted_value *)0x0;
    mem_free(p);
  }
  return psVar2;
}



// WARNING: Unknown calling convention

uchar * encode_crlf(submitted_value *sv)

{
  uchar character;
  string *psVar1;
  uchar *puVar2;
  int iVar3;
  int i;
  string newtext;
  
  if (assert_failed == 0) {
    if ((sv == (submitted_value *)0x0) || (sv->value == (uchar *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x324;
      elinks_internal((uchar *)"assertion sv && sv->value failed!");
      if (assert_failed != 0) goto LAB_080f0ae0;
    }
    else {
      assert_failed = 0;
    }
    psVar1 = init_string(&newtext);
    if (psVar1 != (string *)0x0) {
      puVar2 = sv->value;
      character = *puVar2;
      if (character != '\0') {
        iVar3 = 0;
        do {
          while (character == '\r') {
            if (puVar2[iVar3 + 1] == '\n') goto LAB_080f0a66;
LAB_080f0a7e:
            iVar3 = iVar3 + 1;
            add_crlf_to_string(&newtext);
            puVar2 = sv->value;
            character = puVar2[iVar3];
            if (character == '\0') {
              return newtext.source;
            }
          }
          if (character == '\n') goto LAB_080f0a7e;
          add_char_to_string(&newtext,character);
          puVar2 = sv->value;
LAB_080f0a66:
          iVar3 = iVar3 + 1;
          character = puVar2[iVar3];
        } while (character != '\0');
      }
      return newtext.source;
    }
  }
  else {
LAB_080f0ae0:
    assert_failed = 0;
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

void * mem_align_alloc__(void **ptr,size_t old,size_t new,size_t objsize,size_t mask)

{
  void *pvVar1;
  size_t newsize;
  uint uVar2;
  size_t size;
  size_t oldsize;
  uint uVar3;
  int iVar4;
  
  uVar2 = mask + new & ~mask;
  uVar3 = mask + old & ~mask;
  if (uVar3 < uVar2) {
    size = uVar2 * objsize;
    pvVar1 = mem_realloc(*ptr,size);
    if (pvVar1 == (void *)0x0) {
      return (void *)0x0;
    }
    iVar4 = uVar3 * objsize;
    *ptr = pvVar1;
    memset((void *)((int)pvVar1 + iVar4),0,size - iVar4);
  }
  return *ptr;
}



// WARNING: Unknown calling convention

string * add_bytes_to_string__(string *string,uchar *bytes,int length)

{
  int iVar1;
  void *pvVar2;
  
  if (assert_failed == 0) {
    if (((bytes == (uchar *)0x0) || (string == (string *)0x0)) || (length < 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080f0b9e;
    }
    else {
      assert_failed = 0;
    }
    if (length != 0) {
      iVar1 = length + string->length;
      pvVar2 = mem_align_alloc__(&string->source,string->length,iVar1 + 1,1,0xff);
      if (pvVar2 == (void *)0x0) {
        string = (string *)0x0;
      }
      else {
        memcpy(string->source + string->length,bytes,length);
        string->source[iVar1] = '\0';
        string->length = iVar1;
      }
    }
  }
  else {
LAB_080f0b9e:
    assert_failed = 0;
    string = (string *)0x0;
  }
  return string;
}



// WARNING: Unknown calling convention

void init_form_state(document_view *doc_view,form_control *fc,form_state *fs)

{
  int from;
  int to;
  uchar *puVar1;
  size_t sVar2;
  conv_table *pcVar3;
  uchar *__s;
  int doc_cp;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(fs == (form_state *)0x0 || fc == (form_control *)0x0);
  if (fs == (form_state *)0x0 || fc == (form_control *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0xa3;
    elinks_internal((uchar *)"assertion fc && fs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  from = doc_view->document->cp;
  to = get_terminal_codepage(doc_view->session->tab->term);
  if (fs->value != (uchar *)0x0) {
    mem_free(fs->value);
  }
  fs->value = (uchar *)0x0;
  if (FC_HIDDEN < fc->type) {
    return;
  }
  switch(fc->type) {
  case FC_TEXT:
  case FC_PASSWORD:
    puVar1 = get_form_history_value(fc->form->action,fc->name);
    __s = (uchar *)0x0;
    if (puVar1 != (uchar *)0x0) {
      puVar1 = get_form_history_value(fc->form->action,fc->name);
      __s = stracpy(puVar1);
    }
    fs->value = __s;
    if (__s == (uchar *)0x0) goto switchD_080f0d43_caseD_3;
LAB_080f0e51:
    __s = (uchar *)strlen((char *)__s);
    break;
  case FC_FILE:
    puVar1 = stracpy("");
    fs->state = 0;
    fs->value = puVar1;
    goto LAB_080f0dfe;
  case FC_TEXTAREA:
switchD_080f0d43_caseD_3:
    puVar1 = fc->default_value;
    sVar2 = strlen((char *)puVar1);
    pcVar3 = get_translation_table(from,to);
    __s = convert_string_elinks
                    (pcVar3,puVar1,sVar2,to,CSM_FORM,&fs->state,
                     (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    fs->value = __s;
    if (__s != (uchar *)0x0) goto LAB_080f0e51;
    break;
  case FC_CHECKBOX:
  case FC_RADIO:
    fs->state = fc->default_state;
  default:
    puVar1 = stracpy(fc->default_value);
    fs->value = puVar1;
    return;
  case FC_SELECT:
    puVar1 = fc->default_value;
    sVar2 = strlen((char *)puVar1);
    pcVar3 = get_translation_table(from,to);
    puVar1 = convert_string_elinks
                       (pcVar3,puVar1,sVar2,to,CSM_FORM,&fs->state,
                        (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
    fs->value = puVar1;
    fs->state = fc->default_state;
    fixup_select_state(fc,fs);
    return;
  }
  fs->state = (int)__s;
  if (fc->type == FC_TEXTAREA) {
    fs->state_cell = 0;
  }
LAB_080f0dfe:
  fs->vpos = 0;
  return;
}



// WARNING: Unknown calling convention

form_view * find_form_view_in_vs(view_state *vs,int form_num)

{
  form_view *pfVar1;
  form_view *fv;
  form_view *pfVar2;
  
  if ((assert_failed == 0) && (assert_failed = (int)(vs == (view_state *)0x0), assert_failed != 0))
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x134;
    elinks_internal((uchar *)"assertion vs failed!");
  }
  pfVar1 = (form_view *)(vs->forms).next;
  while( true ) {
    if ((form_view *)&vs->forms == pfVar1) {
      pfVar2 = (form_view *)mem_calloc(1,0xc);
      pfVar2->form_num = form_num;
      pfVar1 = (form_view *)(vs->forms).next;
      pfVar2->prev = (form_view *)&vs->forms;
      pfVar2->next = pfVar1;
      (vs->forms).next = pfVar2;
      pfVar2->next->prev = pfVar2;
      return pfVar2;
    }
    if (pfVar1->form_num == form_num) break;
    pfVar1 = pfVar1->next;
  }
  return pfVar1;
}



// WARNING: Unknown calling convention

form_view * find_form_view(document_view *doc_view,form *form)

{
  form_view *pfVar1;
  
  pfVar1 = find_form_view_in_vs(doc_view->vs,form->form_num);
  return pfVar1;
}



// WARNING: Unknown calling convention

form_state * find_form_state(document_view *doc_view,form_control *fc)

{
  view_state *pvVar1;
  void *p;
  form_view *pfVar2;
  form_state *pfVar3;
  int iVar4;
  form_state *fs;
  int n;
  byte bVar5;
  
  bVar5 = 0;
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (fc == (form_control *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0xeb;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && fc failed!");
      if (assert_failed != 0) goto LAB_080f0fc6;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    iVar4 = fc->g_ctrl_num;
    if (iVar4 < pvVar1->form_info_len) {
      pfVar3 = pvVar1->form_info;
    }
    else {
      pfVar3 = (form_state *)
               mem_align_alloc__(&pvVar1->form_info,pvVar1->form_info_len,iVar4 + 1U,0x24,0);
      if (pfVar3 == (form_state *)0x0) {
        return (form_state *)0x0;
      }
      pvVar1->form_info = pfVar3;
      pvVar1->form_info_len = iVar4 + 1U;
    }
    fs = pfVar3 + iVar4;
    if (((fs->form_view == (form_view *)0x0) || (fs->form_view->form_num != fc->form->form_num)) ||
       ((fs->g_ctrl_num != fc->g_ctrl_num ||
        ((fs->position != fc->position || (fs->type != fc->type)))))) {
      if (fs->value != (uchar *)0x0) {
        mem_free(fs->value);
      }
      pfVar3 = fs;
      for (iVar4 = 9; iVar4 != 0; iVar4 = iVar4 + -1) {
        pfVar3->form_view = (form_view *)0x0;
        pfVar3 = (form_state *)((int)pfVar3 + (uint)bVar5 * -8 + 4);
      }
      pfVar2 = find_form_view_in_vs(doc_view->vs,fc->form->form_num);
      fs->form_view = pfVar2;
      fs->g_ctrl_num = fc->g_ctrl_num;
      fs->position = fc->position;
      fs->type = fc->type;
      init_form_state(doc_view,fc,fs);
      return fs;
    }
  }
  else {
LAB_080f0fc6:
    assert_failed = 0;
    fs = (form_state *)0x0;
  }
  return fs;
}



// WARNING: Unknown calling convention

frame_event_status field_op(session *ses,document_view *doc_view,link *link,term_event *ev)

{
  char cVar1;
  uchar uVar2;
  ushort uVar3;
  frame_event_status status;
  action_id_T aVar4;
  form_state *fs_00;
  frame_event_status fVar5;
  size_t sVar6;
  ushort **ppuVar7;
  int iVar8;
  char *pcVar9;
  byte *pbVar10;
  byte *pbVar11;
  option_value *poVar12;
  link *plVar13;
  int iVar14;
  uchar *puVar15;
  uchar *puVar16;
  ushort *puVar17;
  uint uVar18;
  byte bVar19;
  int utf8;
  uchar *new_value;
  uint uVar20;
  size_t sVar21;
  char *__src;
  form_control *fc;
  form_control *fc_00;
  uchar *text_1;
  byte *pbVar22;
  uchar *text;
  form_state *fs;
  byte *pbVar23;
  uchar *ctext;
  byte bVar24;
  byte *local_20 [4];
  
  bVar24 = 0;
  bVar19 = ses->tab->term->field_0x38;
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((doc_view == (document_view *)0x0) || (ev == (term_event *)0x0)) || (link == (link *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x5b7;
    elinks_internal((uchar *)"assertion ses && doc_view && link && ev failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  if (link->type < LINK_BUTTON) {
    assert_failed = 1;
    fc_00 = (form_control *)0x0;
LAB_080f11fc:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x5bb;
    elinks_internal((uchar *)"assertion fc != NULL failed: link has no form control");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    fc_00 = (link->data).form_control;
    assert_failed = (int)(fc_00 == (form_control *)0x0);
    if (assert_failed != 0) goto LAB_080f11fc;
  }
  if (fc_00->mode == FORM_MODE_DISABLED) {
    return FRAME_EVENT_IGNORED;
  }
  if (ev->ev != EVENT_KBD) {
    return FRAME_EVENT_IGNORED;
  }
  if (ses->insert_mode == INSERT_MODE_OFF) {
    return FRAME_EVENT_IGNORED;
  }
  aVar4 = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
  fs_00 = find_form_state(doc_view,fc_00);
  if ((fs_00 == (form_state *)0x0) || (pbVar22 = fs_00->value, pbVar22 == (byte *)0x0)) {
    return FRAME_EVENT_OK;
  }
  uVar20 = (uint)(bVar19 >> 1 & 1);
  switch(aVar4) {
  default:
    if ((0x1f < (ev->info).mouse.x) && ((ev->info).mouse.y == 0)) {
      if (fc_00->mode != FORM_MODE_NORMAL) {
        return FRAME_EVENT_OK;
      }
      iVar14 = get_terminal_codepage(ses->tab->term);
      puVar15 = u2cp_((ev->info).mouse.x,iVar14,NBSP_MODE_ASCII);
      uVar20 = 0xffffffff;
      puVar16 = puVar15;
      do {
        if (uVar20 == 0) break;
        uVar20 = uVar20 - 1;
        uVar2 = *puVar16;
        puVar16 = puVar16 + (uint)bVar24 * -2 + 1;
      } while (uVar2 != '\0');
      iVar14 = ~uVar20 - 1;
      uVar18 = 0xffffffff;
      puVar16 = fs_00->value;
      do {
        if (uVar18 == 0) break;
        uVar18 = uVar18 - 1;
        uVar2 = *puVar16;
        puVar16 = puVar16 + (uint)bVar24 * -2 + 1;
      } while (uVar2 != '\0');
      uVar20 = (~uVar20 - 2) + ~uVar18;
      if ((uint)fc_00->maxlength <= uVar20 && uVar20 != fc_00->maxlength) {
        return FRAME_EVENT_OK;
      }
      puVar16 = insert_in_string(&fs_00->value,fs_00->state,puVar15,iVar14);
      if (puVar16 == (uchar *)0x0) {
        return FRAME_EVENT_OK;
      }
      fs_00->state = fs_00->state + iVar14;
      if (fc_00->type != FC_TEXTAREA) {
        return FRAME_EVENT_REFRESH;
      }
      fs_00->state_cell = 0;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 2:
    if ((fc_00->type == FC_FILE) && (fc_00->mode == FORM_MODE_NORMAL)) {
      file_form_menu(ses->tab->term,pbVar22,fs_00);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 5:
    if (fc_00->mode == FORM_MODE_NORMAL) {
      iVar14 = fs_00->state;
      if (iVar14 == 0) {
        return FRAME_EVENT_OK;
      }
      if (uVar20 == 0) {
        pbVar22 = pbVar22 + iVar14;
        uVar20 = 0xffffffff;
        pbVar23 = pbVar22;
        do {
          if (uVar20 == 0) break;
          uVar20 = uVar20 - 1;
          bVar19 = *pbVar23;
          pbVar23 = pbVar23 + (uint)bVar24 * -2 + 1;
        } while (bVar19 != 0);
        memmove(pbVar22 + -1,pbVar22,~uVar20);
        fs_00->state = fs_00->state + -1;
        return FRAME_EVENT_REFRESH;
      }
      puVar16 = utf8_prevchar(pbVar22 + iVar14,1,pbVar22);
      iVar8 = (int)puVar16 - (int)fs_00->value;
      fs_00->state = iVar8;
      if (iVar14 == iVar8) {
        return FRAME_EVENT_REFRESH;
      }
      if (fc_00->type == FC_TEXTAREA) {
        fs_00->state_cell = 0;
      }
      uVar20 = 0xffffffff;
      puVar15 = fs_00->value + iVar14;
      do {
        if (uVar20 == 0) break;
        uVar20 = uVar20 - 1;
        uVar2 = *puVar15;
        puVar15 = puVar15 + (uint)bVar24 * -2 + 1;
      } while (uVar2 != '\0');
      memmove(puVar16,fs_00->value + iVar14,~uVar20);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 6:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_bob(fs_00,fc_00,uVar20);
      fs_00->state_cell = 0;
      return fVar5;
    }
    fs_00->state = 0;
    return FRAME_EVENT_REFRESH;
  case 7:
    if (ses->insert_mode == INSERT_MODE_ON) {
      ses->insert_mode = INSERT_MODE_OFF;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 8:
    set_clipboard_text(pbVar22);
    return FRAME_EVENT_OK;
  case 9:
    set_clipboard_text(pbVar22);
    if (fc_00->mode == FORM_MODE_NORMAL) {
      *fs_00->value = '\0';
    }
    fs_00->state = 0;
    if (fc_00->type != FC_TEXTAREA) {
      return FRAME_EVENT_REFRESH;
    }
    fs_00->state_cell = 0;
    return FRAME_EVENT_REFRESH;
  case 10:
    if (fc_00->mode == FORM_MODE_NORMAL) {
      sVar6 = strlen((char *)pbVar22);
      iVar14 = fs_00->state;
      if ((int)sVar6 <= iVar14) {
        return FRAME_EVENT_OK;
      }
      if (uVar20 != 0) {
        pbVar23 = pbVar22 + iVar14;
        local_20[0] = pbVar23;
        utf8_to_unicode(local_20,pbVar22 + sVar6);
        if (pbVar23 == local_20[0]) {
          return FRAME_EVENT_REFRESH;
        }
        memmove(pbVar23,local_20[0],(size_t)(pbVar22 + sVar6 + (1 - (int)local_20[0])));
        return FRAME_EVENT_REFRESH;
      }
      memmove(pbVar22 + iVar14,pbVar22 + iVar14 + 1,sVar6 - iVar14);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0xb:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_down(fs_00,fc_00,uVar20);
      return fVar5;
    }
    break;
  case 0xc:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_end(fs_00,fc_00,uVar20);
      return fVar5;
    }
    sVar6 = strlen((char *)pbVar22);
    fs_00->state = sVar6;
    return FRAME_EVENT_REFRESH;
  case 0xd:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_eob(fs_00,fc_00,uVar20);
      return fVar5;
    }
    sVar6 = strlen((char *)pbVar22);
    fs_00->state = sVar6;
    return FRAME_EVENT_REFRESH;
  case 0xe:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_enter(fs_00,fc_00,uVar20);
      return fVar5;
    }
    iVar14 = has_form_submit(fc_00->form);
    if (((iVar14 == 0) || (poVar12 = get_opt_(), poVar12->tree != (list_head_elinks *)0x0)) &&
       (plVar13 = goto_current_link(ses,doc_view,0), plVar13 == (link *)0x0)) {
      return FRAME_EVENT_REFRESH;
    }
    if (ses->insert_mode != INSERT_MODE_ON) {
      return FRAME_EVENT_OK;
    }
    ses->insert_mode = INSERT_MODE_OFF;
    return FRAME_EVENT_OK;
  case 0xf:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_home(fs_00,fc_00,uVar20);
      return fVar5;
    }
    fs_00->state = 0;
    return FRAME_EVENT_REFRESH;
  case 0x10:
    if (fc_00->mode == FORM_MODE_NORMAL) {
      sVar6 = fs_00->state;
      if ((int)sVar6 < 1) {
        return FRAME_EVENT_OK;
      }
      pbVar10 = (byte *)memrchr(pbVar22,10,sVar6);
      pbVar23 = pbVar22;
      if (pbVar10 != (byte *)0x0) {
        pbVar23 = pbVar22 + (sVar6 - 1);
        if (pbVar22 + (sVar6 - 1) != pbVar10) {
          pbVar23 = pbVar10 + 1;
        }
      }
      sVar21 = strlen((char *)(pbVar22 + sVar6));
      memmove(pbVar23,pbVar22 + sVar6,sVar21 + 1);
      fs_00->state = (int)pbVar23 - (int)fs_00->value;
      if (uVar20 == 0) {
        return FRAME_EVENT_REFRESH;
      }
      if (fc_00->type != FC_TEXTAREA) {
        return FRAME_EVENT_REFRESH;
      }
      fs_00->state_cell = 0;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x11:
    if (fc_00->mode == FORM_MODE_NORMAL) {
      pbVar22 = pbVar22 + fs_00->state;
      bVar19 = *pbVar22;
      if (bVar19 == 0) {
        return FRAME_EVENT_OK;
      }
      pcVar9 = strchr((char *)pbVar22,10);
      if (pcVar9 == (char *)0x0) {
        *pbVar22 = 0;
        return FRAME_EVENT_REFRESH;
      }
      __src = pcVar9 + 1;
      if (bVar19 != 10) {
        __src = pcVar9;
      }
      uVar20 = 0xffffffff;
      pcVar9 = __src;
      do {
        if (uVar20 == 0) break;
        uVar20 = uVar20 - 1;
        cVar1 = *pcVar9;
        pcVar9 = pcVar9 + (uint)bVar24 * -2 + 1;
      } while (cVar1 != '\0');
      memmove(pbVar22,__src,~uVar20);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x12:
    if (fc_00->mode == FORM_MODE_NORMAL) {
      iVar14 = fs_00->state;
      if (iVar14 < 1) {
        return FRAME_EVENT_OK;
      }
      pbVar23 = pbVar22 + iVar14;
      if (pbVar22 < pbVar23) {
        ppuVar7 = __ctype_b_loc();
        pbVar11 = pbVar23;
        do {
          bVar19 = pbVar11[-1];
          pbVar10 = pbVar11 + -1;
          uVar3 = (*ppuVar7)[bVar19];
          if ((uVar3 & 0x2000) == 0) {
            if (pbVar22 < pbVar11) goto LAB_080f1792;
            goto LAB_080f1797;
          }
          pbVar11 = pbVar10;
        } while (pbVar22 < pbVar10);
      }
      else {
        bVar19 = *pbVar23;
        pbVar10 = pbVar23;
      }
LAB_080f179a:
      pbVar11 = pbVar10;
      if (bVar19 == 10) {
        pbVar11 = pbVar22 + iVar14 + -1;
        if (pbVar22 + iVar14 + -1 != pbVar10) {
          pbVar11 = pbVar10 + 1;
        }
      }
      sVar6 = strlen((char *)pbVar23);
      memmove(pbVar11,pbVar23,sVar6 + 1);
      fs_00->state = (int)pbVar11 - (int)fs_00->value;
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x13:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_left(fs_00,fc_00,uVar20);
      return fVar5;
    }
    if (uVar20 != 0) {
      puVar16 = utf8_prevchar(pbVar22 + fs_00->state,1,pbVar22);
      fs_00->state = (int)puVar16 - (int)fs_00->value;
      return FRAME_EVENT_REFRESH;
    }
    iVar8 = fs_00->state + -1;
    iVar14 = 0;
    if (-1 < iVar8) {
      iVar14 = iVar8;
    }
    fs_00->state = iVar14;
    return FRAME_EVENT_REFRESH;
  case 0x14:
    iVar14 = fs_00->state;
    if (iVar14 < 1) {
      return FRAME_EVENT_REFRESH;
    }
    ppuVar7 = __ctype_b_loc();
    do {
      iVar14 = iVar14 + -1;
      puVar17 = *ppuVar7;
      if ((*(byte *)((int)puVar17 + (uint)pbVar22[iVar14] * 2 + 1) & 0x20) == 0) {
        iVar14 = fs_00->state;
        if (iVar14 < 1) {
          return FRAME_EVENT_REFRESH;
        }
        while( true ) {
          iVar14 = iVar14 + -1;
          if ((*(byte *)((int)puVar17 + (uint)pbVar22[iVar14] * 2 + 1) & 0x20) != 0) {
            return FRAME_EVENT_REFRESH;
          }
          fs_00->state = iVar14;
          if (iVar14 < 1) break;
          puVar17 = *ppuVar7;
        }
        return FRAME_EVENT_REFRESH;
      }
      fs_00->state = iVar14;
    } while (0 < iVar14);
    return FRAME_EVENT_REFRESH;
  case 0x15:
    ppuVar7 = __ctype_b_loc();
    iVar14 = fs_00->state;
    while( true ) {
      if ((*(byte *)((int)*ppuVar7 + (uint)pbVar22[iVar14] * 2 + 1) & 0x20) == 0) break;
      fs_00->state = iVar14 + 1;
      iVar14 = iVar14 + 1;
    }
    if (pbVar22[iVar14] == 0) {
      return FRAME_EVENT_REFRESH;
    }
    puVar16 = fs_00->value + iVar14;
    do {
      iVar14 = iVar14 + 1;
      fs_00->state = iVar14;
      pbVar22 = puVar16 + 1;
      if (*pbVar22 == 0) {
        if ((*(byte *)((int)*ppuVar7 + 1) & 0x20) == 0) {
          return FRAME_EVENT_REFRESH;
        }
        break;
      }
      puVar16 = puVar16 + 1;
    } while ((*(byte *)((int)*ppuVar7 + (uint)*pbVar22 * 2 + 1) & 0x20) == 0);
    puVar16 = fs_00->value + iVar14;
    do {
      iVar14 = iVar14 + 1;
      fs_00->state = iVar14;
      pbVar22 = puVar16 + 1;
      puVar16 = puVar16 + 1;
    } while ((*(byte *)((int)*ppuVar7 + (uint)*pbVar22 * 2 + 1) & 0x20) != 0);
    return FRAME_EVENT_REFRESH;
  case 0x17:
    if (fc_00->mode == FORM_MODE_NORMAL) {
      if (fc_00->type != FC_TEXTAREA) {
        return FRAME_EVENT_REFRESH;
      }
      textarea_edit(0,ses->tab->term,fs_00,doc_view,link);
      return FRAME_EVENT_REFRESH;
    }
    break;
  case 0x18:
    if ((fc_00->mode != FORM_MODE_NORMAL) ||
       (puVar16 = get_clipboard_text(), puVar16 == (uchar *)0x0)) {
      return FRAME_EVENT_REFRESH;
    }
    sVar6 = strlen((char *)puVar16);
    if ((int)sVar6 <= fc_00->maxlength) {
      puVar15 = (uchar *)mem_realloc(fs_00->value,sVar6 + 1);
      if (puVar15 != (uchar *)0x0) {
        fs_00->value = puVar15;
        memmove(puVar15,puVar16,sVar6 + 1);
        uVar18 = 0xffffffff;
        puVar15 = fs_00->value;
        do {
          if (uVar18 == 0) break;
          uVar18 = uVar18 - 1;
          uVar2 = *puVar15;
          puVar15 = puVar15 + (uint)bVar24 * -2 + 1;
        } while (uVar2 != '\0');
        fs_00->state = ~uVar18 - 1;
        if ((uVar20 != 0) && (fc_00->type == FC_TEXTAREA)) {
          fs_00->state_cell = 0;
        }
      }
    }
    mem_free(puVar16);
    return FRAME_EVENT_REFRESH;
  case 0x1a:
    redraw_terminal_cls(ses->tab->term);
    return FRAME_EVENT_OK;
  case 0x1b:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_right(fs_00,fc_00,uVar20);
      return fVar5;
    }
    if (uVar20 != 0) {
      local_20[0] = pbVar22 + fs_00->state;
      puVar16 = (uchar *)__rawmemchr(local_20[0],0);
      utf8_to_unicode(local_20,puVar16);
      fs_00->state = (int)local_20[0] - (int)fs_00->value;
      return FRAME_EVENT_REFRESH;
    }
    sVar6 = strlen((char *)pbVar22);
    sVar21 = fs_00->state + 1;
    if ((int)sVar21 < (int)sVar6) {
      sVar6 = sVar21;
    }
    fs_00->state = sVar6;
    return FRAME_EVENT_REFRESH;
  case 0x1d:
    if (fc_00->type == FC_TEXTAREA) {
      fVar5 = textarea_op_up(fs_00,fc_00,uVar20);
      return fVar5;
    }
  }
  return FRAME_EVENT_IGNORED;
LAB_080f1792:
  if ((uVar3 & 0x2000) != 0) goto LAB_080f1797;
  pbVar10 = pbVar11 + -1;
  if (pbVar10 <= pbVar22) goto LAB_080f179a;
  bVar19 = pbVar11[-2];
  uVar3 = (*ppuVar7)[bVar19];
  pbVar11 = pbVar10;
  goto LAB_080f1792;
LAB_080f1797:
  bVar19 = *pbVar11;
  pbVar10 = pbVar11;
  goto LAB_080f179a;
}



// WARNING: Unknown calling convention

void do_reset_form(document_view *doc_view,form *form)

{
  form_state *fs;
  form_state *fs_00;
  form_control *fc;
  form_control *fc_00;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x4ac;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f1d78;
    }
    else {
      assert_failed = 0;
    }
    fc_00 = (form_control *)(form->items).next;
    if (fc_00 != (form_control *)&form->items) {
      do {
        fs_00 = find_form_state(doc_view,fc_00);
        if (fs_00 != (form_state *)0x0) {
          init_form_state(doc_view,fc_00,fs_00);
        }
        fc_00 = fc_00->next;
      } while (fc_00 != (form_control *)&form->items);
      return;
    }
  }
  else {
LAB_080f1d78:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_form_entry(terminal *term,document_view *doc_view,link *link)

{
  uchar uVar1;
  form_type fVar2;
  uchar *puVar3;
  form_state *fs;
  view_state *vs;
  form_control *fc;
  int iVar4;
  size_t sVar5;
  unicode_val_T data;
  int iVar6;
  uchar *puVar7;
  int cell_1;
  uint uVar8;
  int iVar9;
  size_t sVar10;
  int y;
  unicode_val_T data_1;
  unicode_val_T uVar11;
  size_t sVar12;
  int iVar13;
  int x;
  int cells;
  int cell;
  int iVar14;
  int iVar15;
  int len;
  int iVar16;
  int cells_1;
  int iVar17;
  byte bVar18;
  size_t local_40;
  uchar *local_3c;
  form_control *local_38;
  int local_34;
  int local_30;
  uchar *local_28;
  uchar *local_24;
  uchar *local_20 [4];
  
  bVar18 = 0;
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (term == (terminal *)0x0)) ||
        (doc_view->document == (document *)0x0)) ||
       ((link == (link *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x18a;
      elinks_internal((uchar *)
                      "assertion term && doc_view && doc_view->document && doc_view->vs && link failed!"
                     );
      if (assert_failed != 0) goto LAB_080f1ec8;
    }
    if (link->type < LINK_BUTTON) {
      assert_failed = 1;
      local_38 = (form_control *)0x0;
LAB_080f1e81:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x18e;
      elinks_internal((uchar *)"assertion fc != NULL failed: link %d has no form control",
                      ((int)link - (int)doc_view->document->links >> 2) * -0x3b13b13b);
      if (assert_failed != 0) goto LAB_080f1ec8;
    }
    else {
      local_38 = (link->data).form_control;
      assert_failed = (int)(local_38 == (form_control *)0x0);
      if (local_38 == (form_control *)0x0) goto LAB_080f1e81;
    }
    fs = find_form_state(doc_view,local_38);
    if (fs != (form_state *)0x0) {
      iVar16 = (doc_view->box).x;
      iVar14 = iVar16 - doc_view->vs->x;
      iVar6 = (doc_view->box).y;
      iVar15 = iVar6 - doc_view->vs->y;
      if (local_38->type < FC_SUBMIT) {
        switch(local_38->type) {
        default:
          if (link->npoints != 0) {
            iVar15 = iVar15 + link->points->y;
            if ((iVar6 <= iVar15) && (iVar15 < iVar6 + (doc_view->box).height)) {
              iVar14 = iVar14 + link->points->x;
              if ((term->field_0x38 & 2) != 0) {
                do {
                  local_24 = fs->value;
                  if (local_24 == (uchar *)0x0) {
                    local_24 = "";
                  }
                  sVar5 = strlen((char *)local_24);
                  sVar10 = fs->state;
                  if ((int)sVar10 < 0) {
                    fs->state = 0;
                    sVar10 = 0;
                  }
                  else if ((int)sVar5 < (int)sVar10) {
                    fs->state = sVar5;
                    sVar10 = sVar5;
                  }
                  sVar12 = fs->vpos;
                  if ((int)sVar12 < 0) {
                    fs->vpos = 0;
                    sVar12 = 0;
                  }
                  else if ((int)sVar10 < (int)sVar12) {
                    fs->vpos = sVar10;
                    sVar12 = sVar10;
                  }
                  puVar7 = local_24 + sVar5;
                  local_34 = local_38->size;
                  local_30 = 0;
                  local_3c = (uchar *)0x0;
                  iVar16 = local_30;
                  local_24 = local_24 + sVar12;
                  while (local_30 = iVar16, puVar3 = local_24, local_30 < local_34) {
                    uVar11 = utf8_to_unicode(&local_24,puVar7);
                    if (uVar11 == 0xfffffffd) {
                      uVar11 = 0x5f;
                    }
                    else if (local_38->type == FC_PASSWORD) {
                      uVar11 = 0x2a;
                    }
                    iVar6 = unicode_to_cell(uVar11);
                    iVar16 = local_30 + iVar6;
                    local_34 = local_38->size;
                    if (local_34 < iVar16) {
LAB_080f234e:
                      if (0 < iVar6) {
                        iVar4 = 0;
                        do {
                          iVar9 = (doc_view->box).x;
                          iVar13 = iVar4 + local_30 + iVar14;
                          if (((iVar9 <= iVar13) && (iVar13 < iVar9 + (doc_view->box).width)) &&
                             (local_30 + iVar4 < local_34)) {
                            draw_char_data(term,iVar13,iVar15,0x20);
                            local_34 = local_38->size;
                          }
                          iVar4 = iVar4 + 1;
                        } while (iVar4 < iVar6);
                      }
                    }
                    else {
                      iVar13 = local_30 + iVar14;
                      iVar4 = (doc_view->box).x;
                      if ((iVar13 < iVar4) || (iVar4 + (doc_view->box).width < iVar6 + iVar13)) {
                        local_3c = puVar3;
                        goto LAB_080f234e;
                      }
                      draw_char_data(term,iVar13,iVar15,uVar11);
                      if (iVar6 < 2) {
                        local_3c = puVar3;
                        local_34 = local_38->size;
                      }
                      else {
                        iVar4 = 1;
                        do {
                          iVar9 = iVar4 + iVar13;
                          iVar4 = iVar4 + 1;
                          draw_char_data(term,iVar9,iVar15,0xfffffffd);
                        } while (iVar4 < iVar6);
                        local_34 = local_38->size;
                        local_3c = puVar3;
                      }
                    }
                  }
                  if (local_3c == (uchar *)0x0) {
                    return;
                  }
                  if (fs->value == (uchar *)0x0) {
                    return;
                  }
                  local_28 = fs->value + fs->state;
                  if (local_28 <= local_3c) {
                    return;
                  }
                  iVar16 = local_38->size;
                  fVar2 = local_38->type;
                  uVar11 = utf8_to_unicode(&local_28,puVar7);
                  local_28 = utf8_step_backward(local_28,fs->value,
                                                iVar16 - (uint)(uVar11 == 0xfffffffd),
                                                (uint)(fVar2 != FC_PASSWORD),(int *)0x0);
                  iVar16 = (int)local_28 - (int)fs->value;
                  if (fs->vpos == iVar16) {
                    return;
                  }
                  fs->vpos = iVar16;
                } while( true );
              }
              iVar16 = fs->state;
              iVar4 = local_38->size;
              iVar6 = fs->vpos;
              iVar13 = (iVar16 + 1) - iVar4;
              if (iVar6 < iVar13) {
                fs->vpos = iVar13;
                iVar4 = local_38->size;
                iVar6 = iVar13;
              }
              else if (iVar16 < iVar6) {
                fs->vpos = iVar16;
                iVar4 = local_38->size;
                iVar6 = iVar16;
              }
              uVar8 = 0xffffffff;
              puVar7 = fs->value;
              do {
                if (uVar8 == 0) break;
                uVar8 = uVar8 - 1;
                uVar1 = *puVar7;
                puVar7 = puVar7 + (uint)bVar18 * -2 + 1;
              } while (uVar1 != '\0');
              if (0 < iVar4) {
                iVar16 = 0;
                while( true ) {
                  iVar4 = (doc_view->box).x;
                  if ((iVar4 <= iVar14) && (iVar14 < iVar4 + (doc_view->box).width)) {
                    if ((fs->value == (uchar *)0x0) ||
                       ((iVar4 = fs->vpos, (int)((~uVar8 - 1) - iVar6) <= iVar16 ||
                        (-iVar16 != iVar4 && iVar16 <= -iVar4)))) {
                      uVar11 = 0x5f;
                    }
                    else {
                      uVar11 = 0x2a;
                      if (local_38->type != FC_PASSWORD) {
                        uVar11 = (unicode_val_T)fs->value[iVar16 + iVar4];
                      }
                    }
                    draw_char_data(term,iVar14,iVar15,uVar11);
                  }
                  iVar16 = iVar16 + 1;
                  if (local_38->size == iVar16 || local_38->size < iVar16) break;
                  iVar14 = iVar14 + 1;
                }
              }
            }
          }
          break;
        case FC_TEXTAREA:
          draw_textarea(term,fs,doc_view,link);
          return;
        case FC_CHECKBOX:
        case FC_RADIO:
          if (1 < link->npoints) {
            iVar14 = iVar14 + link->points[1].x;
            if (((iVar16 <= iVar14) && (iVar15 = link->points[1].y + iVar15, iVar6 <= iVar15)) &&
               ((iVar14 < iVar16 + (doc_view->box).width &&
                (iVar15 < iVar6 + (doc_view->box).height)))) {
              draw_char_data(term,iVar14,iVar15,(-(uint)(fs->state == 0) & 0xffffffc8) + 0x58);
            }
          }
          break;
        case FC_SELECT:
          fixup_select_state(local_38,fs);
          if (fs->state < local_38->nvalues) {
            local_20[0] = local_38->labels[fs->state];
          }
          else {
            local_20[0] = "";
          }
          if ((term->field_0x38 & 2) == 0) {
            local_40 = 0;
            if (local_20[0] != (uchar *)0x0) {
              local_40 = strlen((char *)local_20[0]);
            }
            if (0 < link->npoints) {
              iVar16 = 0;
              do {
                iVar4 = iVar14 + link->points[iVar16].x;
                iVar6 = (doc_view->box).x;
                if (iVar6 <= iVar4) {
                  iVar9 = link->points[iVar16].y + iVar15;
                  iVar13 = (doc_view->box).y;
                  if (((iVar13 <= iVar9) && (iVar4 < iVar6 + (doc_view->box).width)) &&
                     (iVar9 < (doc_view->box).height + iVar13)) {
                    uVar11 = 0x5f;
                    if (iVar16 < (int)local_40) {
                      uVar11 = (unicode_val_T)local_20[0][iVar16];
                    }
                    draw_char_data(term,iVar4,iVar9,uVar11);
                  }
                }
                iVar16 = iVar16 + 1;
              } while (link->npoints != iVar16 && iVar16 <= link->npoints);
            }
          }
          else {
            local_24 = local_20[0];
            puVar7 = (uchar *)__rawmemchr(local_20[0],0);
            iVar16 = utf8_ptr2cells(local_24,puVar7);
            if (0 < link->npoints) {
              iVar6 = 0;
              do {
                iVar13 = iVar14 + link->points[iVar6].x;
                iVar4 = (doc_view->box).x;
                if (iVar13 < iVar4) {
LAB_080f24a1:
                  iVar17 = iVar6 + 1;
                }
                else {
                  y = link->points[iVar6].y + iVar15;
                  iVar9 = (doc_view->box).y;
                  if (((y < iVar9) || (iVar4 + (doc_view->box).width <= iVar13)) ||
                     (iVar9 + (doc_view->box).height <= y)) goto LAB_080f24a1;
                  iVar4 = iVar13;
                  if (iVar6 < iVar16) {
                    iVar17 = iVar6 + 1;
                    data_1 = utf8_to_unicode(local_20,puVar7);
                    iVar9 = unicode_to_cell(data_1);
                    if (iVar9 == 2) {
                      if (iVar17 < iVar16) {
                        iVar4 = iVar13 + 1;
                        iVar17 = iVar6 + 2;
                        draw_char_data(term,iVar13,y,data_1);
                        data_1 = 0xfffffffd;
                      }
                      else {
                        data_1 = 0x20;
                      }
                    }
                  }
                  else {
                    iVar17 = iVar6 + 1;
                    data_1 = 0x5f;
                  }
                  draw_char_data(term,iVar4,y,data_1);
                }
                iVar6 = iVar17;
              } while (iVar17 < link->npoints);
            }
          }
        }
      }
    }
  }
  else {
LAB_080f1ec8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void draw_forms(terminal *term,document_view *doc_view)

{
  link *link;
  link *plVar1;
  link *l2;
  link *l1;
  
  if (assert_failed == 0) {
    assert_failed = (int)(doc_view == (document_view *)0x0 || term == (terminal *)0x0);
    if (doc_view == (document_view *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x27e;
      elinks_internal((uchar *)"assertion term && doc_view failed!");
      if (assert_failed != 0) goto LAB_080f261d;
    }
    link = get_first_link(doc_view);
    plVar1 = get_last_link(doc_view);
    if ((plVar1 != (link *)0x0) && (link != (link *)0x0)) {
      while( true ) {
        if ((LINK_MAP < link->type) && ((link->data).name != (uchar *)0x0)) {
          draw_form_entry(term,doc_view,link);
        }
        if (plVar1 <= link) break;
        link = link + 1;
      }
      return;
    }
    if ((assert_failed == 0) &&
       (assert_failed = (int)(plVar1 != (link *)0x0 || link != (link *)0x0),
       plVar1 != (link *)0x0 || link != (link *)0x0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x285;
      elinks_internal((uchar *)
                      "assertion !l1 && !l2 failed: get_first_link == %p, get_last_link == %p",link,
                      plVar1);
    }
  }
  else {
LAB_080f261d:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status reset_form(session *ses,document_view *doc_view,int a)

{
  int iVar1;
  link *plVar2;
  link *link;
  form_control *pfVar3;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     (plVar2 = doc_view->document->links + iVar1, plVar2 != (link *)0x0)) {
    pfVar3 = (form_control *)0x0;
    if (LINK_MAP < plVar2->type) {
      pfVar3 = (plVar2->data).form_control;
    }
    do_reset_form(doc_view,pfVar3->form);
    draw_forms(ses->tab->term,doc_view);
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

int get_current_state(session *ses)

{
  int iVar1;
  document_view *doc_view_00;
  document_view *doc_view;
  form_state *fs;
  form_state *pfVar2;
  link *plVar3;
  link *link;
  
  if (assert_failed == 0) {
    assert_failed = (int)(ses == (session *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x171;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return -1;
      }
    }
    doc_view_00 = current_frame(ses);
    if (assert_failed == 0) {
      if (((doc_view_00 == (document_view *)0x0) || (doc_view_00->vs == (view_state *)0x0)) ||
         (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x175;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return -1;
        }
        if (doc_view_00 == (document_view *)0x0) {
          return -1;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view_00->vs->current_link;
      if (((-1 < iVar1) && (iVar1 < doc_view_00->document->nlinks)) &&
         ((plVar3 = doc_view_00->document->links + iVar1, plVar3 != (link *)0x0 &&
          ((plVar3->type == LINK_SELECT &&
           (pfVar2 = find_form_state(doc_view_00,(plVar3->data).form_control),
           pfVar2 != (form_state *)0x0)))))) {
        return pfVar2->state;
      }
      return -1;
    }
  }
  assert_failed = 0;
  return -1;
}



// WARNING: Unknown calling convention

void selected_item(terminal *term,void *item_,void *ses_)

{
  int iVar1;
  form_control *fc_00;
  document_view *doc_view_00;
  link *plVar2;
  link *link;
  form_state *fs_00;
  form_state *fs;
  uchar *puVar3;
  form_control *fc;
  document_view *doc_view;
  
  if (assert_failed == 0) {
    assert_failed = (int)(ses_ == (void *)0x0 || term == (terminal *)0x0);
    if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x85;
      elinks_internal((uchar *)"assertion term && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view_00 = current_frame((session *)ses_);
    if (assert_failed == 0) {
      if (((doc_view_00 == (document_view *)0x0) || (doc_view_00->vs == (view_state *)0x0)) ||
         (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x89;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
        if (doc_view_00 == (document_view *)0x0) {
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view_00->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (iVar1 < doc_view_00->document->nlinks) {
        plVar2 = doc_view_00->document->links + iVar1;
        if (plVar2 == (link *)0x0) {
          return;
        }
        if (plVar2->type == LINK_SELECT) {
          fc_00 = (plVar2->data).form_control;
          fs_00 = find_form_state(doc_view_00,fc_00);
          if (fs_00 != (form_state *)0x0) {
            if ((-1 < (int)item_) && ((int)item_ < fc_00->nvalues)) {
              fs_00->state = (int)item_;
              if (fs_00->value != (uchar *)0x0) {
                mem_free(fs_00->value);
              }
              puVar3 = stracpy(fc_00->values[(int)item_]);
              fs_00->value = puVar3;
            }
            fixup_select_state(fc_00,fs_00);
          }
          refresh_view((session *)ses_,doc_view_00,0);
          return;
        }
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void add_form_attr_to_string(string *string,terminal *term,uchar *name,uchar *value)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  add_to_string(string,", ");
  if ((name != (uchar *)0x0) && (*name != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    name = gettext(name);
  }
  add_to_string(string,name);
  if (value != (uchar *)0x0) {
    add_char_to_string(string,' ');
    add_to_string(string,value);
  }
  return;
}



// WARNING: Unknown calling convention

void link_form_menu(session *ses)

{
  form *pfVar1;
  form_control *fc_00;
  terminal *term;
  form_type fVar2;
  document_view *pdVar3;
  form_control *fc;
  char *msgid;
  int iVar4;
  string *psVar5;
  int cp_index;
  int new_charset;
  uchar *puVar6;
  int *data;
  int *p;
  link *plVar7;
  link *link;
  uchar *text;
  int link_number;
  string str;
  menu_item *local_20 [4];
  
  if (assert_failed == 0) {
    assert_failed = (int)(ses == (session *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x822;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    pdVar3 = current_frame(ses);
    if (pdVar3 == (document_view *)0x0) {
      return;
    }
    if (assert_failed == 0) {
      if ((pdVar3->vs == (view_state *)0x0) || (pdVar3->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x828;
        elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar4 = pdVar3->vs->current_link;
      if (iVar4 < 0) {
        return;
      }
      if (pdVar3->document->nlinks <= iVar4) {
        return;
      }
      plVar7 = pdVar3->document->links + iVar4;
      if (plVar7 == (link *)0x0) {
        return;
      }
      assert_failed = (int)(plVar7->type < LINK_BUTTON);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 0x82e;
        elinks_internal((uchar *)"assertion link_is_form(link) failed!");
      }
      if (plVar7->type < LINK_BUTTON) {
        return;
      }
      if ((plVar7->data).form_control == (form_control *)0x0) {
        return;
      }
      pfVar1 = ((plVar7->data).form_control)->form;
      local_20[0] = new_menu(FREE_LIST|FREE_TEXT|NO_INTL);
      if (local_20[0] == (menu_item *)0x0) {
        return;
      }
      fc_00 = (form_control *)(pfVar1->items).next;
      do {
        while( true ) {
          if ((form_control *)&pfVar1->items == fc_00) {
            do_menu(ses->tab->term,local_20[0],ses,1);
            return;
          }
          fVar2 = fc_00->type;
          if (FC_SELECT < fVar2) break;
LAB_080f2bc8:
          msgid = (char *)get_form_label(fc_00);
LAB_080f2bd1:
          iVar4 = get_form_control_link(pdVar3->document,fc_00);
          if ((-1 < iVar4) && (psVar5 = init_string(&str), psVar5 != (string *)0x0)) {
            if ((assert_failed == 0) &&
               (assert_failed = (int)((uchar *)msgid == (uchar *)0x0), assert_failed != 0)) {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
              errline = 0x853;
              elinks_internal((uchar *)"assertion text failed!");
            }
            term = ses->tab->term;
            if (((uchar *)msgid != (uchar *)0x0) && (*msgid != '\0')) {
              if ((term != (terminal *)0x0) &&
                 (cp_index = get_terminal_codepage(term), cp_index != current_charset)) {
                puVar6 = get_cp_mime_name(cp_index);
                bind_textdomain_codeset("elinks",puVar6);
                current_charset = cp_index;
              }
              msgid = (char *)gettext((uchar *)msgid);
            }
            add_to_string(&str,(uchar *)msgid);
            puVar6 = fc_00->name;
            if (puVar6 == (uchar *)0x0) {
              puVar6 = fc_00->alt;
            }
            data = (int *)mem_alloc(4);
            if (data != (int *)0x0) {
              *data = iVar4;
            }
            add_to_menu(local_20,str.source,puVar6,ACT_MAIN_NONE,link_form_menu_func,data,FREE_DATA)
            ;
          }
          fc_00 = fc_00->next;
        }
        if (fVar2 < FC_RESET) {
          msgid = "Useless button";
          if (pfVar1->action != (uchar *)0x0) {
            msgid = "Submit button";
          }
          goto LAB_080f2bd1;
        }
        if (fVar2 != FC_HIDDEN) goto LAB_080f2bc8;
        fc_00 = fc_00->next;
      } while( true );
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void encode_multipart(session *ses,list_head_elinks *l,string *data,boundary_info *boundary,
                     int cp_from,int cp_to)

{
  int *piVar1;
  byte *pbVar2;
  byte bVar3;
  int iVar4;
  size_t sVar5;
  uchar *puVar6;
  uchar *p;
  size_t newsize_1;
  undefined4 *puVar7;
  uchar *type;
  option_value *poVar8;
  uchar *filename;
  void *p_1;
  char *pcVar9;
  uchar *puVar10;
  void *pvVar11;
  int *piVar12;
  int iVar13;
  size_t newsize;
  int newlength;
  int i;
  int iVar14;
  size_t oldsize;
  uint uVar15;
  size_t newsize_2;
  uchar *pos;
  byte *pbVar16;
  int j;
  submitted_value *sv;
  list_head_elinks *plVar17;
  size_t oldsize_2;
  long __result;
  uint uVar18;
  byte *pbVar19;
  boundary_info *pbVar20;
  size_t oldsize_1;
  size_t newsize_3;
  uint uVar21;
  int newlength_1;
  size_t sVar22;
  int in_GS_OFFSET;
  bool bVar23;
  bool bVar24;
  byte bVar25;
  conv_table *local_440;
  int local_43c;
  uchar buffer [1024];
  
  bVar25 = 0;
  iVar4 = *(int *)(in_GS_OFFSET + 0x14);
  if (assert_failed != 0) {
LAB_080f3170:
    assert_failed = 0;
    goto LAB_080f317a;
  }
  if ((((l == (list_head_elinks *)0x0) || (ses == (session *)0x0)) ||
      (boundary == (boundary_info *)0x0)) || (data == (string *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x3d9;
    elinks_internal((uchar *)"assertion ses && l && data && boundary failed!");
    if (assert_failed != 0) goto LAB_080f3170;
  }
  else {
    assert_failed = 0;
  }
  pbVar20 = boundary;
  for (iVar13 = 10; iVar13 != 0; iVar13 = iVar13 + -1) {
    pbVar20->count = 0;
    pbVar20 = (boundary_info *)((int)pbVar20 + (uint)bVar25 * -8 + 4);
  }
  puVar10 = boundary->string;
  *(undefined4 *)boundary->string = 0x30303030;
  *(undefined4 *)(boundary->string + 4) = 0x30303030;
  *(undefined4 *)(boundary->string + 8) = 0x30303030;
  *(undefined4 *)(boundary->string + 0xc) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x10) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x14) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x18) = 0x30303030;
  *(undefined4 *)(boundary->string + 0x1c) = 0x30303030;
  plVar17 = (list_head_elinks *)l->next;
  if (plVar17 != l) {
    local_440 = (conv_table *)0x0;
LAB_080f3052:
    add_to_string(data,"--");
    uVar18 = boundary->count + 0x100;
    uVar15 = boundary->count + 0xff;
    uVar21 = uVar18 & 0xffffff00;
    if (uVar21 < (uVar15 & 0xffffff00) || uVar21 + (uVar15 >> 8) * -0x100 == 0) {
LAB_080f3082:
      if (boundary->offsets != (int *)0x0) {
        iVar13 = boundary->count;
        boundary->offsets[iVar13] = data->length;
        boundary->count = iVar13 + 1;
      }
    }
    else {
      sVar22 = (uVar18 >> 8) * 0x400;
      piVar12 = (int *)mem_realloc(boundary->offsets,sVar22);
      if (piVar12 != (int *)0x0) {
        boundary->offsets = piVar12;
        memset(piVar12 + (uVar15 & 0xffffff00),0,sVar22 + (uVar15 >> 8) * -0x400);
        goto LAB_080f3082;
      }
    }
    if (assert_failed == 0) {
      if (data == (string *)0x0) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 0xff;
        elinks_internal((uchar *)
                        "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if (assert_failed != 0) goto LAB_080f2f48;
      }
      else {
        assert_failed = 0;
      }
      iVar13 = data->length;
      uVar18 = iVar13 + 0xffU >> 8;
      uVar21 = iVar13 + 0xffU & 0xffffff00;
      uVar15 = iVar13 + 0x120U & 0xffffff00;
      if (uVar21 <= uVar15 && uVar15 + uVar18 * -0x100 != 0) {
        puVar6 = (uchar *)mem_realloc(data->source,uVar15);
        if (puVar6 == (uchar *)0x0) goto LAB_080f2f58;
        data->source = puVar6;
        memset(puVar6 + uVar21,0,uVar15 + uVar18 * -0x100);
      }
      if (data->source != (uchar *)0x0) {
        puVar7 = (undefined4 *)(data->source + data->length);
        *puVar7 = *(undefined4 *)puVar10;
        puVar7[1] = *(undefined4 *)(boundary->string + 4);
        puVar7[2] = *(undefined4 *)(boundary->string + 8);
        puVar7[3] = *(undefined4 *)(boundary->string + 0xc);
        puVar7[4] = *(undefined4 *)(boundary->string + 0x10);
        puVar7[5] = *(undefined4 *)(boundary->string + 0x14);
        puVar7[6] = *(undefined4 *)(boundary->string + 0x18);
        puVar7[7] = *(undefined4 *)(boundary->string + 0x1c);
        data->source[iVar13 + 0x20] = '\0';
        data->length = iVar13 + 0x20;
      }
    }
    else {
LAB_080f2f48:
      assert_failed = 0;
    }
LAB_080f2f58:
    add_crlf_to_string(data);
    add_to_string(data,(uchar *)"Content-Disposition: form-data; name=\"");
    add_to_string(data,(uchar *)plVar17[1].next);
    add_char_to_string(data,'\"');
    if (plVar17[2].prev != (void *)0x2) {
      add_crlf_to_string(data);
      add_crlf_to_string(data);
      if ((plVar17[2].prev == (void *)0x3) || (plVar17[2].prev < (void *)0x2)) {
        if (local_440 == (conv_table *)0x0) {
          local_440 = get_translation_table(cp_from,cp_to);
        }
        puVar6 = (uchar *)plVar17[1].prev;
        sVar5 = strlen((char *)puVar6);
        puVar6 = convert_string_elinks
                           (local_440,puVar6,sVar5,-1,CSM_FORM,(int *)0x0,
                            (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
        if (puVar6 != (uchar *)0x0) {
          add_to_string(data,puVar6);
          mem_free(puVar6);
        }
      }
      else {
        add_to_string(data,(uchar *)plVar17[1].prev);
      }
      goto LAB_080f303c;
    }
    add_to_string(data,(uchar *)"; filename=\"");
    puVar6 = get_filename_position((uchar *)plVar17[1].prev);
    add_to_string(data,puVar6);
    add_char_to_string(data,'\"');
    puVar6 = (uchar *)strrchr((char *)plVar17[1].prev,0x2e);
    if ((puVar6 != (uchar *)0x0) &&
       (puVar6 = get_extension_content_type(puVar6), puVar6 != (uchar *)0x0)) {
      add_crlf_to_string(data);
      add_to_string(data,"Content-Type: ");
      add_to_string(data,puVar6);
      mem_free(puVar6);
    }
    add_crlf_to_string(data);
    add_crlf_to_string(data);
                    // WARNING: Load size is inaccurate
    if (*plVar17[1].prev != '\0') {
      poVar8 = get_opt_();
      if (poVar8->tree == (list_head_elinks *)0x0) {
        puVar6 = expand_tilde((uchar *)plVar17[1].prev);
        if (puVar6 != (uchar *)0x0) {
          iVar13 = open64((char *)puVar6,0);
          mem_free(puVar6);
          if (iVar13 != -1) {
            set_bin(iVar13);
LAB_080f32ff:
            do {
              while (sVar5 = read(iVar13,buffer,0x400), sVar5 == 0xffffffff) {
                piVar12 = __errno_location();
                if (*piVar12 != 4) {
                  close(iVar13);
                  goto encode_error;
                }
              }
              if (sVar5 == 0) goto LAB_080f35c0;
              if (assert_failed == 0) {
                if ((data == (string *)0x0) || ((int)sVar5 < 0)) {
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 0xff;
                  elinks_internal((uchar *)
                                  "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]"
                                 );
                  if (assert_failed != 0) goto LAB_080f333c;
                }
                else {
                  assert_failed = 0;
                }
                iVar14 = sVar5 + data->length;
                uVar21 = data->length + 0xffU & 0xffffff00;
                uVar18 = iVar14 + 0x100U & 0xffffff00;
                if (uVar21 < uVar18) {
                  puVar6 = (uchar *)mem_realloc(data->source,uVar18);
                  if (puVar6 == (uchar *)0x0) goto LAB_080f32ff;
                  data->source = puVar6;
                  memset(puVar6 + uVar21,0,uVar18 - uVar21);
                }
                if (data->source != (uchar *)0x0) {
                  memcpy(data->source + data->length,buffer,sVar5);
                  data->source[iVar14] = '\0';
                  data->length = iVar14;
                }
                goto LAB_080f32ff;
              }
LAB_080f333c:
              assert_failed = 0;
            } while( true );
          }
        }
        piVar12 = __errno_location();
      }
      else {
        piVar12 = __errno_location();
        *piVar12 = 1;
      }
encode_error:
      if (boundary->offsets != (int *)0x0) {
        mem_free(boundary->offsets);
      }
      done_string(data);
      pcVar9 = strerror(*piVar12);
      puVar10 = msg_text(ses->tab->term,(uchar *)"Could not load file %s: %s",plVar17[1].prev,pcVar9
                        );
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"Error while posting form",ALIGN_CENTER,
               puVar10);
      goto LAB_080f317a;
    }
LAB_080f303c:
    add_crlf_to_string(data);
    plVar17 = (list_head_elinks *)plVar17->next;
    if (plVar17 == l) goto LAB_080f35fd;
    goto LAB_080f3052;
  }
LAB_080f35fd:
  add_to_string(data,"--");
  uVar21 = boundary->count + 0x100U & 0xffffff00;
  uVar18 = boundary->count + 0xffU & 0xffffff00;
  if (uVar18 < uVar21) {
    sVar22 = uVar21 * 4;
    piVar12 = (int *)mem_realloc(boundary->offsets,sVar22);
    if (piVar12 != (int *)0x0) {
      boundary->offsets = piVar12;
      memset(piVar12 + uVar18,0,sVar22 + uVar18 * -4);
      goto LAB_080f3635;
    }
  }
  else {
LAB_080f3635:
    if (boundary->offsets != (int *)0x0) {
      iVar13 = boundary->count;
      boundary->offsets[iVar13] = data->length;
      boundary->count = iVar13 + 1;
    }
  }
  if (assert_failed == 0) {
    if (data == (string *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 0xff;
      elinks_internal((uchar *)
                      "assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if (assert_failed != 0) goto LAB_080f365d;
    }
    else {
      assert_failed = 0;
    }
    sVar22 = data->length;
    pvVar11 = mem_align_alloc__(&data->source,sVar22,sVar22 + 0x21,1,0xff);
    if (pvVar11 != (void *)0x0) {
      puVar7 = (undefined4 *)(data->source + data->length);
      *puVar7 = *(undefined4 *)boundary->string;
      puVar7[1] = *(undefined4 *)(boundary->string + 4);
      puVar7[2] = *(undefined4 *)(boundary->string + 8);
      puVar7[3] = *(undefined4 *)(boundary->string + 0xc);
      puVar7[4] = *(undefined4 *)(boundary->string + 0x10);
      puVar7[5] = *(undefined4 *)(boundary->string + 0x14);
      puVar7[6] = *(undefined4 *)(boundary->string + 0x18);
      puVar7[7] = *(undefined4 *)(boundary->string + 0x1c);
      data->source[sVar22 + 0x20] = '\0';
      data->length = sVar22 + 0x20;
    }
  }
  else {
LAB_080f365d:
    assert_failed = 0;
  }
  add_to_string(data,"--\r\n");
  local_43c = boundary->count;
  if (local_43c != 1 && -1 < local_43c + -1) {
    piVar12 = boundary->offsets;
    iVar13 = 0;
LAB_080f36b0:
    piVar1 = piVar12 + iVar13;
    iVar13 = iVar13 + 1;
    pbVar16 = data->source + *piVar1 + 0x48;
    pbVar2 = data->source + piVar12[iVar13] + -0x22;
    bVar23 = pbVar16 < pbVar2;
    if (pbVar16 <= pbVar2) {
      do {
        bVar24 = pbVar16 == pbVar2;
        iVar14 = 0x20;
        pbVar19 = pbVar16;
        puVar6 = puVar10;
        do {
          if (iVar14 == 0) break;
          iVar14 = iVar14 + -1;
          bVar23 = *pbVar19 < *puVar6;
          bVar24 = *pbVar19 == *puVar6;
          pbVar19 = pbVar19 + (uint)bVar25 * -2 + 1;
          puVar6 = puVar6 + (uint)bVar25 * -2 + 1;
        } while (bVar24);
        if ((!bVar23 && !bVar24) == bVar23) {
          iVar13 = 0x1f;
          goto LAB_080f37c5;
        }
        pbVar16 = pbVar16 + 1;
        bVar23 = pbVar2 < pbVar16;
      } while (!bVar23);
    }
    goto LAB_080f3720;
  }
  piVar12 = boundary->offsets;
LAB_080f3735:
  if (0 < local_43c) {
    iVar13 = 0;
    while( true ) {
      puVar7 = (undefined4 *)(data->source + piVar12[iVar13]);
      iVar13 = iVar13 + 1;
      *puVar7 = *(undefined4 *)puVar10;
      puVar7[1] = *(undefined4 *)(boundary->string + 4);
      puVar7[2] = *(undefined4 *)(boundary->string + 8);
      puVar7[3] = *(undefined4 *)(boundary->string + 0xc);
      puVar7[4] = *(undefined4 *)(boundary->string + 0x10);
      puVar7[5] = *(undefined4 *)(boundary->string + 0x14);
      puVar7[6] = *(undefined4 *)(boundary->string + 0x18);
      puVar7[7] = *(undefined4 *)(boundary->string + 0x1c);
      if (boundary->count <= iVar13) break;
      piVar12 = boundary->offsets;
    }
    piVar12 = boundary->offsets;
  }
LAB_080f3798:
  if (piVar12 != (int *)0x0) {
    mem_free(piVar12);
  }
LAB_080f317a:
  if (iVar4 != *(int *)(in_GS_OFFSET + 0x14)) {
                    // WARNING: Subroutine does not return
    __stack_chk_fail();
  }
  return;
LAB_080f35c0:
  close(iVar13);
  goto LAB_080f303c;
LAB_080f37c5:
  bVar3 = boundary->string[iVar13];
  boundary->string[iVar13] = bVar3 + 1;
  if (bVar3 < 0x39) goto code_r0x080f37d6;
  boundary->string[iVar13] = '0';
  iVar13 = iVar13 + -1;
  if (iVar13 == -1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x39d;
    elinks_internal((uchar *)"Form data boundary counter overflow");
    piVar12 = boundary->offsets;
    goto LAB_080f3798;
  }
  goto LAB_080f37c5;
code_r0x080f37d6:
  local_43c = boundary->count;
  iVar13 = 1;
  piVar12 = boundary->offsets;
LAB_080f3720:
  if (local_43c + -1 <= iVar13) goto LAB_080f3735;
  goto LAB_080f36b0;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// WARNING: Unknown calling convention

uri * get_form_uri(session *ses,document_view *doc_view,form_control *fc)

{
  int iVar1;
  form *form;
  form_method fVar2;
  submitted_value *psVar3;
  form_type fVar4;
  uint uVar5;
  bool bVar6;
  undefined2 uVar7;
  byte bVar8;
  uri *puVar9;
  uri *uri;
  string *psVar10;
  submitted_value *sub;
  form_state *fs_00;
  submitted_value *sub_1;
  int cp_from;
  option_value *poVar11;
  uchar *puVar12;
  char *pcVar13;
  submitted_value *psVar14;
  submitted_value *psVar15;
  conv_table *convert_table;
  size_t sVar16;
  uint uVar17;
  uchar *puVar18;
  form_state *fs;
  submitted_value *psVar19;
  size_t newsize;
  uint size;
  form *pfVar20;
  uchar *p;
  form_control *fc2;
  form_control *fc_00;
  int iVar21;
  byte *pbVar22;
  int changed;
  uchar *p2;
  int in_GS_OFFSET;
  byte *local_74;
  conv_table *local_70;
  string go;
  string data;
  list_head_elinks submit;
  uchar p_1 [3];
  boundary_info boundary;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  submit.next = (submitted_value *)&submit;
  submit.prev = (submitted_value *)&submit;
  if (assert_failed != 0) {
LAB_080f39fa:
    assert_failed = 0;
    puVar9 = (uri *)0x0;
    goto LAB_080f3a08;
  }
  if (((ses == (session *)0x0) || (ses->tab == (window *)0x0)) ||
     (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x4d1;
    elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term failed!");
    if (assert_failed != 0) goto LAB_080f39fa;
  }
  if (((doc_view == (document_view *)0x0) || (fc == (form_control *)0x0)) ||
     ((doc_view->document == (document *)0x0 || (fc->form == (form *)0x0)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x4d3;
    elinks_internal((uchar *)"assertion doc_view && doc_view->document && fc && fc->form failed!");
    if (assert_failed != 0) goto LAB_080f39fa;
    form = fc->form;
    fVar4 = fc->type;
  }
  else {
    form = fc->form;
    fVar4 = fc->type;
  }
  if (fVar4 == FC_RESET) {
    assert_failed = 0;
    do_reset_form(doc_view,form);
    puVar9 = (uri *)0x0;
    goto LAB_080f3a08;
  }
  assert_failed = 0;
  if ((form->action == (uchar *)0x0) || (psVar10 = init_string(&data), psVar10 == (string *)0x0)) {
    puVar9 = (uri *)0x0;
    goto LAB_080f3a08;
  }
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (fc->form == (form *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 0x30a;
      elinks_internal((uchar *)"assertion doc_view && fc && fc->form && list failed!");
      if (assert_failed != 0) goto LAB_080f3c38;
    }
    else {
      assert_failed = 0;
    }
    pfVar20 = fc->form;
    fc_00 = (form_control *)(pfVar20->items).next;
    if (fc_00 != (form_control *)&pfVar20->items) {
      do {
        if ((((fc == fc_00) || (3 < fc_00->type + ~FC_SELECT)) && (fc_00->name != (uchar *)0x0)) &&
           (*fc_00->name != '\0')) {
          fs_00 = find_form_state(doc_view,fc_00);
          if (fs_00 != (form_state *)0x0) {
            if (assert_failed == 0) {
              assert_failed = 0;
            }
            puVar18 = fc_00->name;
            iVar21 = fc_00->position;
            switch(fc_00->type) {
            case FC_TEXT:
            case FC_PASSWORD:
            case FC_FILE:
            case FC_TEXTAREA:
            case FC_SUBMIT:
            case FC_RESET:
            case FC_BUTTON:
            case FC_HIDDEN:
switchD_080f3bb4_caseD_0:
              psVar15 = init_submitted_value(puVar18,fs_00->value,fc_00->type,fc_00,iVar21);
              if (psVar15 != (submitted_value *)0x0) {
LAB_080f3fa1:
                psVar15->prev = (submitted_value *)&submit;
                psVar15->next = (submitted_value *)submit.next;
                psVar15->next->prev = psVar15;
                pfVar20 = fc->form;
                submit.next = psVar15;
                goto LAB_080f3b48;
              }
              break;
            case FC_CHECKBOX:
            case FC_RADIO:
              if (fs_00->state != 0) goto switchD_080f3bb4_caseD_0;
              break;
            case FC_SELECT:
              if (fc_00->nvalues != 0) {
                fixup_select_state(fc_00,fs_00);
                psVar15 = init_submitted_value(puVar18,fs_00->value,FC_SELECT,fc_00,iVar21);
                if (psVar15 == (submitted_value *)0x0) break;
                goto LAB_080f3fa1;
              }
              break;
            case FC_IMAGE:
              puVar18 = straconcat(puVar18,&DAT_0813532c,0);
              if (puVar18 != (uchar *)0x0) {
                psVar15 = init_submitted_value(puVar18,"0",FC_IMAGE,fc_00,iVar21);
                mem_free(puVar18);
                if (psVar15 != (submitted_value *)0x0) {
                  psVar15->prev = (submitted_value *)&submit;
                  psVar15->next = (submitted_value *)submit.next;
                  psVar15->next->prev = psVar15;
                  submit.next = psVar15;
                }
                puVar18 = straconcat(fc_00->name,&DAT_0813532f,0);
                if (puVar18 != (uchar *)0x0) {
                  psVar15 = init_submitted_value(puVar18,"0",FC_IMAGE,fc_00,iVar21);
                  mem_free(puVar18);
                  if (psVar15 != (submitted_value *)0x0) {
                    psVar15->prev = (submitted_value *)&submit;
                    psVar15->next = (submitted_value *)submit.next;
                    psVar15->next->prev = psVar15;
                    submit.next = psVar15;
                  }
                }
              }
            }
          }
          pfVar20 = fc->form;
        }
LAB_080f3b48:
        fc_00 = fc_00->next;
      } while (fc_00 != (form_control *)&pfVar20->items);
    }
    do {
      bVar6 = false;
      psVar15 = (submitted_value *)submit.next;
      while (psVar14 = psVar15, psVar19 = (submitted_value *)submit.prev,
            psVar14 != (submitted_value *)&submit) {
        while ((psVar15 = psVar14->next, (submitted_value *)&submit != psVar15 &&
               (psVar15->position < psVar14->position))) {
          bVar6 = true;
          psVar15->prev = psVar14->prev;
          psVar14->prev->next = psVar14->next;
          psVar3 = psVar15->next;
          psVar14->prev = psVar15;
          psVar14->next = psVar3;
          psVar15->next = psVar14;
          psVar14->next->prev = psVar14;
          psVar14 = psVar15->next;
          if (psVar14 == (submitted_value *)&submit) goto joined_r0x080f3f25;
        }
      }
joined_r0x080f3f25:
      for (; psVar19 != psVar14; psVar19 = psVar19->prev) {
        psVar15 = psVar19->next;
        if (((submitted_value *)&submit != psVar15) && (psVar15->position < psVar19->position)) {
          psVar15->prev = psVar19->prev;
          psVar19->prev->next = psVar19->next;
          psVar3 = psVar15->next;
          bVar6 = true;
          psVar19->prev = psVar15;
          psVar19->next = psVar3;
          psVar15->next = psVar19;
          psVar19->next->prev = psVar19;
          psVar19 = psVar15;
        }
      }
    } while (bVar6);
  }
  else {
LAB_080f3c38:
    assert_failed = 0;
  }
  cp_from = get_terminal_codepage(ses->tab->term);
  iVar21 = doc_view->document->cp;
  fVar2 = form->method;
  if (fVar2 == FORM_METHOD_POST_MP) {
    encode_multipart(ses,(list_head_elinks *)(submitted_value *)&submit,&data,&boundary,cp_from,
                     iVar21);
  }
  else if (fVar2 < FORM_METHOD_POST_MP) {
    if (assert_failed == 0) {
      assert_failed = 0;
      local_70 = (conv_table *)0x0;
      psVar15 = (submitted_value *)submit.next;
      if ((submitted_value *)&submit != (submitted_value *)submit.next) {
        do {
          puVar18 = psVar15->name;
          sVar16 = strlen((char *)puVar18);
          encode_uri_string(&data,puVar18,sVar16,1);
          add_char_to_string(&data,'=');
          fVar4 = psVar15->type;
          if (fVar4 == FC_TEXTAREA) {
            puVar18 = encode_textarea(psVar15);
            if (puVar18 != (uchar *)0x0) {
              if (local_70 == (conv_table *)0x0) {
                local_70 = get_translation_table(cp_from,iVar21);
              }
              sVar16 = strlen((char *)puVar18);
              puVar12 = convert_string_elinks
                                  (local_70,puVar18,sVar16,-1,CSM_FORM,(int *)0x0,
                                   (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
              mem_free(puVar18);
              goto LAB_080f3dde;
            }
          }
          else {
            if (fVar4 < FC_FILE) {
              if (local_70 == (conv_table *)0x0) {
                local_70 = get_translation_table(cp_from,iVar21);
              }
              puVar18 = psVar15->value;
              sVar16 = strlen((char *)puVar18);
              puVar12 = convert_string_elinks
                                  (local_70,puVar18,sVar16,-1,CSM_FORM,(int *)0x0,
                                   (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
            }
            else if (fVar4 == FC_HIDDEN) {
              puVar12 = encode_crlf(psVar15);
            }
            else {
              puVar12 = stracpy(psVar15->value);
            }
LAB_080f3dde:
            if (puVar12 != (uchar *)0x0) {
              sVar16 = strlen((char *)puVar12);
              encode_uri_string(&data,puVar12,sVar16,1);
              mem_free(puVar12);
            }
          }
          psVar15 = psVar15->next;
          if ((submitted_value *)&submit == psVar15) break;
          add_char_to_string(&data,'&');
        } while( true );
      }
    }
    else {
LAB_080f4276:
      assert_failed = 0;
    }
  }
  else if (fVar2 == FORM_METHOD_POST_TEXT_PLAIN) {
    convert_table = get_translation_table(cp_from,iVar21);
    if (assert_failed != 0) goto LAB_080f4276;
    assert_failed = 0;
    for (psVar15 = (submitted_value *)submit.next; psVar15 != (submitted_value *)&submit;
        psVar15 = psVar15->next) {
      local_74 = psVar15->value;
      add_to_string(&data,psVar15->name);
      add_char_to_string(&data,'=');
      fVar4 = psVar15->type;
      if (fVar4 == FC_TEXTAREA) {
        pbVar22 = encode_textarea(psVar15);
        local_74 = pbVar22;
        if (pbVar22 != (byte *)0x0) goto LAB_080f4321;
      }
      else {
        if (fVar4 < FC_CHECKBOX) {
          if (fVar4 < FC_FILE) {
            pbVar22 = (byte *)0x0;
LAB_080f4321:
            sVar16 = strlen((char *)local_74);
            local_74 = convert_string_elinks
                                 (convert_table,local_74,sVar16,-1,CSM_FORM,(int *)0x0,
                                  (_func_void_void_ptr_uchar_ptr_int *)0x0,(void *)0x0);
            if (pbVar22 != (byte *)0x0) {
              mem_free(pbVar22);
            }
          }
        }
        else if (fVar4 == FC_HIDDEN) {
          pbVar22 = encode_crlf(psVar15);
          local_74 = pbVar22;
          if (pbVar22 == (byte *)0x0) goto LAB_080f4487;
          goto LAB_080f4321;
        }
        if (local_74 != (byte *)0x0) {
          bVar8 = *local_74;
          pbVar22 = local_74;
          iVar21 = data.length;
          while (data.length = iVar21, bVar8 != 0) {
            while( true ) {
              if ((bVar8 != 0xd) && (bVar8 != 10)) {
                add_char_to_string(&data,bVar8);
                goto LAB_080f4403;
              }
              bVar8 = *pbVar22 >> 4;
              p_1[1] = bVar8 + 0x57;
              if (bVar8 < 10) {
                p_1[1] = bVar8 + 0x30;
              }
              p_1[0] = 0x25;
              uVar7 = p_1._0_2_;
              bVar8 = *pbVar22 & 0xf;
              p_1[2] = bVar8 + 0x57;
              if (bVar8 < 10) {
                p_1[2] = bVar8 + 0x30;
              }
              if (assert_failed == 0) break;
              pbVar22 = pbVar22 + 1;
              assert_failed = 0;
              bVar8 = *pbVar22;
              if (bVar8 == 0) goto LAB_080f4468;
            }
            assert_failed = 0;
            size = iVar21 + 0x103U & 0xffffff00;
            uVar5 = iVar21 + 0xffU >> 8;
            uVar17 = iVar21 + 0xffU & 0xffffff00;
            p_1._0_2_ = uVar7;
            if (size < uVar17 || size + uVar5 * -0x100 == 0) {
LAB_080f43de:
              if (data.source != (uchar *)0x0) {
                *(undefined2 *)(data.source + data.length) = uVar7;
                *(uchar *)((int)(data.source + data.length) + 2) = p_1[2];
                data.source[iVar21 + 3] = '\0';
                data.length = iVar21 + 3;
              }
            }
            else {
              puVar18 = (uchar *)mem_realloc(data.source,size);
              p_1[0] = '%';
              if (puVar18 != (uchar *)0x0) {
                data.source = puVar18;
                memset(puVar18 + uVar17,0,size + uVar5 * -0x100);
                goto LAB_080f43de;
              }
            }
LAB_080f4403:
            pbVar22 = pbVar22 + 1;
            iVar21 = data.length;
            bVar8 = *pbVar22;
          }
LAB_080f4468:
          if (local_74 != psVar15->value) {
            mem_free(local_74);
          }
        }
      }
LAB_080f4487:
      add_crlf_to_string(&data);
    }
  }
  if ((data.source != (uchar *)0x0) &&
     (poVar11 = get_opt_(), poVar11->tree != (list_head_elinks *)0x0)) {
    memorize_form(ses,(list_head_elinks *)(submitted_value *)&submit,form);
  }
  done_submitted_value_list((list_head_elinks *)(submitted_value *)&submit);
  if (data.source != (uchar *)0x0) {
    psVar10 = init_string(&go);
    if (psVar10 != (string *)0x0) {
      if (form->method == FORM_METHOD_GET) {
        puVar18 = form->action;
        puVar12 = (uchar *)strchr((char *)puVar18,0x23);
        if (puVar12 == (uchar *)0x0) {
          add_to_string(&go,puVar18);
        }
        else {
          add_bytes_to_string__(&go,puVar18,(int)puVar12 - (int)puVar18);
        }
        pcVar13 = strchr((char *)go.source,0x3f);
        if (pcVar13 == (char *)0x0) {
          add_char_to_string(&go,'?');
        }
        else {
          add_char_to_string(&go,'&');
        }
        add_string_to_string(&go,&data);
        if (puVar12 != (uchar *)0x0) {
          add_to_string(&go,puVar12);
        }
      }
      else if (form->method < 4) {
        add_to_string(&go,form->action);
        add_char_to_string(&go,'\x01');
        if (form->method == FORM_METHOD_POST) {
          add_to_string(&go,(uchar *)"application/x-www-form-urlencoded\n");
        }
        else {
          if (form->method == FORM_METHOD_POST_TEXT_PLAIN) {
            add_to_string(&go,(uchar *)"text/plain\n");
            add_to_string(&go,data.source);
            goto LAB_080f3d54;
          }
          add_to_string(&go,(uchar *)"multipart/form-data; boundary=");
          add_bytes_to_string__(&go,boundary.string,0x20);
          add_char_to_string(&go,'\n');
        }
        if (0 < data.length) {
          iVar21 = 0;
          do {
            pbVar22 = data.source + iVar21;
            iVar21 = iVar21 + 1;
            elinks_ulongcat(p_1,(uint *)0x0,(uint)*pbVar22,2,'0',0x10,0);
            add_to_string(&go,p_1);
          } while (iVar21 < data.length);
        }
      }
LAB_080f3d54:
      done_string(&data);
      puVar9 = get_uri(go.source,0);
      done_string(&go);
      if (puVar9 != (uri *)0x0) {
        puVar9->field_0x36 = puVar9->field_0x36 | 2;
      }
      goto LAB_080f3a08;
    }
  }
  done_string(&data);
  puVar9 = (uri *)0x0;
LAB_080f3a08:
  if (iVar1 == *(int *)(in_GS_OFFSET + 0x14)) {
    return puVar9;
  }
                    // WARNING: Subroutine does not return
  __stack_chk_fail();
}



// WARNING: Unknown calling convention

void submit_given_form(session *ses,document_view *doc_view,form *form,int do_reload)

{
  form_control *fc;
  uri *uri_00;
  uri *uri;
  cache_mode mode;
  
  fc = (form_control *)(form->items).next;
  if ((fc != (form_control *)&form->items) &&
     (mode = -(uint)(do_reload == 0) & 0xfffffffe, fc != (form_control *)0x0)) {
    uri_00 = get_form_uri(ses,doc_view,fc);
    if (uri_00 != (uri *)0x0) {
      goto_uri_frame(ses,uri_00,form->target,mode + CACHE_MODE_FORCE_RELOAD);
      done_uri(uri_00);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void auto_submit_form(session *ses)

{
  document *pdVar1;
  form *form;
  document *document;
  
  pdVar1 = ses->doc_view->document;
  form = (form *)(pdVar1->forms).next;
  if (form != (form *)&pdVar1->forms) {
    submit_given_form(ses,ses->doc_view,form,0);
  }
  return;
}



// WARNING: Unknown calling convention

uchar * get_form_info(session *ses,document_view *doc_view)

{
  terminal *term;
  form_state *fs;
  uchar *puVar1;
  uchar *label;
  string *psVar2;
  int iVar3;
  int new_charset;
  uchar *puVar4;
  uint uVar5;
  option_value *poVar6;
  uri *uri_00;
  uri *uri;
  uchar *key;
  uchar *format;
  form_state *pfVar7;
  link *link;
  form_control *fc_00;
  form_control *fc;
  char *pcVar8;
  term_event_keyboard kbd;
  string str;
  
  term = ses->tab->term;
  if (((doc_view == (document_view *)0x0) || (iVar3 = doc_view->vs->current_link, iVar3 < 0)) ||
     (doc_view->document->nlinks <= iVar3)) {
    link = (link *)0x0;
  }
  else {
    link = doc_view->document->links + iVar3;
  }
  if ((assert_failed == 0) && (assert_failed = (int)(link == (link *)0x0), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 0x788;
    elinks_internal((uchar *)"assertion link failed!");
  }
  fc_00 = (form_control *)0x0;
  if (LINK_MAP < link->type) {
    fc_00 = (link->data).form_control;
  }
  puVar1 = get_form_label(fc_00);
  if ((puVar1 == (uchar *)0x0) || (psVar2 = init_string(&str), psVar2 == (string *)0x0)) {
    str.source = (uchar *)0x0;
  }
  else {
    if (*puVar1 != '\0') {
      if ((term != (terminal *)0x0) &&
         (iVar3 = get_terminal_codepage(term), iVar3 != current_charset)) {
        puVar4 = get_cp_mime_name(iVar3);
        bind_textdomain_codeset("elinks",puVar4);
        current_charset = iVar3;
      }
      puVar1 = gettext(puVar1);
    }
    add_to_string(&str,puVar1);
    if (((link->type != LINK_BUTTON) && (puVar1 = fc_00->name, puVar1 != (uchar *)0x0)) &&
       (*puVar1 != '\0')) {
      add_form_attr_to_string(&str,term,"name",puVar1);
    }
    if (fc_00->type < FC_RESET) {
      uVar5 = 1 << ((byte)fc_00->type & 0x1f);
      if ((uVar5 & 0x180) == 0) {
        if ((uVar5 & 0x30) == 0) {
          if ((uVar5 & 0xf) != 0) {
            if (fc_00->mode != FORM_MODE_NORMAL) {
              add_form_attr_to_string(&str,term,(uchar *)"read only",(uchar *)0x0);
            }
            if (ses->insert_mode == INSERT_MODE_OFF) {
              puVar1 = get_keystroke(0xe,KEYMAP_EDIT);
              if (puVar1 != (uchar *)0x0) {
                pcVar8 = "press %s to navigate";
                if (fc_00->mode == FORM_MODE_NORMAL) {
                  pcVar8 = "press %s to edit";
                }
                add_to_string(&str," (");
                puVar4 = _((uchar *)pcVar8,term);
                add_format_to_string(&str,puVar4,puVar1);
                add_char_to_string(&str,')');
                mem_free(puVar1);
              }
            }
            else if (fc_00->type != FC_TEXTAREA) {
              if ((assert_failed == 0) &&
                 (assert_failed = (int)(fc_00->form == (form *)0x0), assert_failed != 0)) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
                errline = 0x7c6;
                elinks_internal((uchar *)"assertion fc->form failed!");
              }
              if ((fc_00->form->action != (uchar *)0x0) &&
                 (((iVar3 = has_form_submit(fc_00->form), iVar3 == 0 ||
                   (poVar6 = get_opt_(), poVar6->tree != (list_head_elinks *)0x0)) &&
                  (uri_00 = get_uri(fc_00->form->action,0), uri_00 != (uri *)0x0)))) {
                puVar1 = get_uri_string(uri_00,URI_PUBLIC);
                done_uri(uri_00);
                if (puVar1 != (uchar *)0x0) {
                  puVar4 = get_keystroke(0xe,KEYMAP_EDIT);
                  if (puVar4 == (uchar *)0x0) {
                    mem_free(puVar1);
                  }
                  else {
                    pcVar8 = "press %s to submit to %s";
                    if (fc_00->form->method != FORM_METHOD_GET) {
                      pcVar8 = "press %s to post to %s";
                    }
                    add_to_string(&str," (");
                    format = _((uchar *)pcVar8,term);
                    add_format_to_string(&str,format,puVar4,puVar1);
                    mem_free(puVar1);
                    mem_free(puVar4);
                    add_char_to_string(&str,')');
                  }
                }
              }
            }
          }
        }
        else {
          pfVar7 = find_form_state(doc_view,fc_00);
          puVar1 = pfVar7->value;
          if ((puVar1 != (uchar *)0x0) && (*puVar1 != '\0')) {
            add_form_attr_to_string(&str,term,(uchar *)"value",puVar1);
          }
        }
      }
      else {
        add_char_to_string(&str,' ');
        if ((assert_failed == 0) &&
           (assert_failed = (int)(fc_00->form == (form *)0x0), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
          errline = 0x7ed;
          elinks_internal((uchar *)"assertion fc->form failed!");
        }
        add_string_uri_to_string(&str,fc_00->form->action,URI_PUBLIC);
      }
    }
    if ((link->accesskey != 0) && (poVar6 = get_opt_(), poVar6->tree != (list_head_elinks *)0x0)) {
      add_to_string(&str," (");
      kbd.key = link->accesskey;
      kbd.modifier = KBD_MOD_ALT;
      add_keystroke_to_string(&str,&kbd,0);
      add_char_to_string(&str,')');
    }
  }
  return str.source;
}



// WARNING: Unknown calling convention

void get_link_x_bounds(link *link,int y,int *min_x,int *max_x)

{
  int iVar1;
  int iVar2;
  int point;
  int iVar3;
  
  if (min_x != (int *)0x0) {
    *min_x = 0x7fffffff;
  }
  if (max_x != (int *)0x0) {
    *max_x = 0;
  }
  if (link->npoints < 1) {
    return;
  }
  iVar2 = 0;
  iVar3 = 0;
  do {
    while ((-1 < y && (*(int *)((int)&link->points->y + iVar2) != y))) {
LAB_080f4cb9:
      iVar3 = iVar3 + 1;
      iVar2 = iVar2 + 8;
      if (link->npoints == iVar3 || link->npoints < iVar3) {
        return;
      }
    }
    if ((min_x != (int *)0x0) && (iVar1 = *(int *)((int)&link->points->x + iVar2), iVar1 < *min_x))
    {
      *min_x = iVar1;
    }
    if ((max_x == (int *)0x0) || (iVar1 = *(int *)((int)&link->points->x + iVar2), iVar1 <= *max_x))
    goto LAB_080f4cb9;
    *max_x = iVar1;
    iVar3 = iVar3 + 1;
    iVar2 = iVar2 + 8;
    if (link->npoints == iVar3 || link->npoints < iVar3) {
      return;
    }
  } while( true );
}



// WARNING: Unknown calling convention

link * get_link_at_coordinates(document_view *doc_view,int x,int y)

{
  document *pdVar1;
  int iVar2;
  link *plVar3;
  link *plVar4;
  link *link;
  int i;
  int iVar5;
  link *l2;
  link *plVar6;
  int height;
  int iVar7;
  int local_28;
  link *local_24;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) ||
       (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x44f;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f4d98;
    }
    else {
      assert_failed = 0;
    }
    pdVar1 = doc_view->document;
    if (((pdVar1->nlinks != 0) && (-1 < x)) &&
       ((x < (doc_view->box).width && ((-1 < y && (iVar5 = (doc_view->box).height, y < iVar5)))))) {
      plVar6 = pdVar1->links;
      local_24 = plVar6 + pdVar1->nlinks;
      iVar2 = doc_view->vs->y;
      iVar5 = iVar2 + iVar5;
      iVar7 = pdVar1->height;
      if (iVar5 <= pdVar1->height) {
        iVar7 = iVar5;
      }
      iVar5 = iVar2 * 4;
      for (local_28 = iVar2; local_28 < iVar7; local_28 = local_28 + 1) {
        plVar3 = *(link **)((int)pdVar1->lines1 + iVar5);
        plVar4 = local_24;
        if ((plVar3 != (link *)0x0) && (plVar4 = plVar3, local_24 <= plVar3)) {
          plVar4 = local_24;
        }
        local_24 = plVar4;
        plVar3 = *(link **)((int)pdVar1->lines2 + iVar5);
        if ((plVar3 != (link *)0x0) && (plVar6 < plVar3)) {
          plVar6 = plVar3;
        }
        iVar5 = iVar5 + 4;
      }
      for (; local_24 <= plVar6; local_24 = local_24 + 1) {
        if (0 < local_24->npoints) {
          iVar5 = 0;
          do {
            if ((local_24->points[iVar5].x == x + doc_view->vs->x) &&
               (local_24->points[iVar5].y == iVar2 + y)) {
              return local_24;
            }
            iVar5 = iVar5 + 1;
          } while (iVar5 < local_24->npoints);
        }
      }
    }
  }
  else {
LAB_080f4d98:
    assert_failed = 0;
  }
  return (link *)0x0;
}



// WARNING: Unknown calling convention

void set_pos_y(document_view *doc_view,link *link)

{
  int iVar1;
  view_state *pvVar2;
  int iVar3;
  int i;
  int iVar4;
  int ym;
  int iVar5;
  int height;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
        (link == (link *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x300;
      elinks_internal((uchar *)
                      "assertion doc_view && doc_view->document && doc_view->vs && link failed!");
      if (assert_failed != 0) goto LAB_080f4f80;
    }
    else {
      assert_failed = 0;
    }
    iVar4 = 0;
    iVar5 = doc_view->document->height;
    if (0 < link->npoints) {
      iVar3 = 0;
      do {
        iVar1 = link->points[iVar3].y;
        if (iVar4 < iVar1 + 1) {
          iVar4 = iVar1 + 1;
        }
        if (iVar1 < iVar5) {
          iVar5 = iVar1;
        }
        iVar3 = iVar3 + 1;
      } while (iVar3 != link->npoints);
    }
    doc_view->vs->y = ((iVar5 + iVar4) - (doc_view->box).height) / 2;
    pvVar2 = doc_view->vs;
    if (pvVar2->y < 0) {
      pvVar2->y = 0;
      return;
    }
    iVar5 = doc_view->document->height - (doc_view->box).height;
    if (iVar5 < pvVar2->y) {
      pvVar2->y = iVar5;
      return;
    }
  }
  else {
LAB_080f4f80:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void set_pos_x(document_view *doc_view,link *link)

{
  view_state *pvVar1;
  point *ppVar2;
  int iVar3;
  int i;
  int iVar4;
  int xl;
  int iVar5;
  int y;
  int iVar6;
  int xm;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(link == (link *)0x0 || doc_view == (document_view *)0x0);
  if (link == (link *)0x0 || doc_view == (document_view *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x2e9;
    elinks_internal((uchar *)"assertion doc_view && link failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (0 < link->npoints) {
    pvVar1 = doc_view->vs;
    iVar6 = 0;
    ppVar2 = link->points;
    iVar4 = 0x7fffffff;
    iVar3 = 0;
    iVar5 = ppVar2->y - pvVar1->y;
    while( true ) {
      if ((-1 < iVar5) && (iVar5 < (doc_view->box).height)) {
        iVar5 = ppVar2[iVar3].x;
        if (iVar6 < iVar5 + 1) {
          iVar6 = iVar5 + 1;
        }
        if (iVar5 < iVar4) {
          iVar4 = iVar5;
        }
      }
      iVar3 = iVar3 + 1;
      if (iVar3 == link->npoints) break;
      iVar5 = ppVar2[iVar3].y - pvVar1->y;
    }
    if (iVar4 != 0x7fffffff) {
      iVar6 = iVar6 - (doc_view->box).width;
      if (pvVar1->x < iVar6) {
        pvVar1->x = iVar6;
        return;
      }
      if (iVar4 < pvVar1->x) {
        pvVar1->x = iVar4;
      }
    }
  }
  return;
}



// WARNING: Unknown calling convention

int next_link_in_dir(document_view *doc_view,int dir_x,int dir_y)

{
  document *pdVar1;
  view_state *pvVar2;
  int top;
  int iVar3;
  int point_1;
  int point;
  int iVar4;
  int bottom;
  int iVar5;
  link **pplVar6;
  int y;
  int iVar7;
  link *link;
  link *plVar8;
  int y_1;
  int iVar9;
  bool bVar10;
  int local_58;
  int local_54;
  link **local_50;
  int local_38;
  link *local_30;
  int local_2c;
  int local_28;
  int local_24;
  int local_20 [4];
  
  if (assert_failed == 0) {
    local_20[0] = 0x7fffffff;
    local_24 = 0;
    if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x261;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f5198;
    }
    bVar10 = (dir_y | dir_x) == 0;
    assert_failed = (int)bVar10;
    if (bVar10) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x263;
      elinks_internal((uchar *)"assertion dir_x || dir_y failed!");
      if (assert_failed != 0) goto LAB_080f5198;
    }
    pdVar1 = doc_view->document;
    pvVar2 = doc_view->vs;
    iVar7 = pvVar2->current_link;
    if (((-1 < iVar7) && (iVar7 < pdVar1->nlinks)) &&
       (plVar8 = pdVar1->links + iVar7, plVar8 != (link *)0x0)) {
      get_link_x_bounds(plVar8,-1,local_20,&local_24);
      iVar7 = plVar8->points->y;
      iVar9 = plVar8->points[plVar8->npoints + -1].y;
      if (dir_y != 0) {
        if (0 < dir_y) {
          iVar7 = iVar9;
        }
        iVar7 = dir_y + iVar7;
        iVar9 = iVar7 * 4;
        iVar3 = doc_view->vs->y;
        iVar4 = 0;
        if (-1 < iVar3) {
          iVar4 = iVar3;
        }
        iVar3 = iVar3 + (doc_view->box).height;
        iVar5 = pdVar1->height;
        if (iVar3 <= pdVar1->height) {
          iVar5 = iVar3;
        }
        if (dir_y < 1) goto LAB_080f52e3;
LAB_080f523f:
        bVar10 = iVar7 < iVar5;
        do {
          if (!bVar10) {
            if (iVar7 == 0) {
              return 0;
            }
            if (pdVar1->height == iVar7) {
              return 0;
            }
            pvVar2->current_link = -1;
            return 0;
          }
          plVar8 = *(link **)((int)pdVar1->lines1 + iVar9);
          if ((plVar8 != (link *)0x0) &&
             (pplVar6 = pdVar1->lines2,
             plVar8 < *(link **)((int)pplVar6 + iVar9) || plVar8 == *(link **)((int)pplVar6 + iVar9)
             )) {
            local_30 = (link *)0x0;
            do {
              while ((iVar7 < plVar8->points->y || (plVar8->points[plVar8->npoints + -1].y < iVar7))
                    ) {
LAB_080f5278:
                plVar8 = plVar8 + 1;
                if (*(link **)((int)pplVar6 + iVar9) < plVar8) goto LAB_080f52cb;
              }
              get_link_x_bounds(plVar8,iVar7,&local_28,&local_2c);
              if (local_28 <= local_24) {
                local_30 = plVar8;
                if (local_2c < local_20[0]) {
LAB_080f52f6:
                  pplVar6 = pdVar1->lines2;
                  local_30 = plVar8;
                  goto LAB_080f5278;
                }
                goto chose_link;
              }
              if (local_30 == (link *)0x0) goto LAB_080f52f6;
              plVar8 = plVar8 + 1;
              pplVar6 = pdVar1->lines2;
            } while (plVar8 <= *(link **)((int)pplVar6 + iVar9));
LAB_080f52cb:
            if (local_30 != (link *)0x0) {
chose_link:
              pvVar2->current_link = ((int)local_30 - (int)pdVar1->links >> 2) * -0x3b13b13b;
              set_pos_x(doc_view,local_30);
              return 1;
            }
          }
          iVar7 = iVar7 + dir_y;
          iVar9 = iVar9 + dir_y * 4;
          if (0 < dir_y) goto LAB_080f523f;
LAB_080f52e3:
          bVar10 = iVar4 <= iVar7;
        } while( true );
      }
      iVar3 = local_20[0];
      if (0 < dir_x) {
        iVar3 = local_24;
      }
      local_38 = 0;
      for (iVar3 = iVar3 + dir_x * 2; (local_38 < (iVar9 + 1) - iVar7 && (-1 < iVar3));
          iVar3 = iVar3 + dir_x) {
        local_38 = 0;
        if (iVar7 <= iVar9) {
          local_50 = pdVar1->lines1 + iVar7;
          local_58 = iVar7 * 4;
          local_54 = iVar7;
          do {
            local_30 = *local_50;
            if (local_30 != (link *)0x0) {
              plVar8 = *(link **)((int)pdVar1->lines2 + local_58);
              for (; local_30 <= plVar8; local_30 = local_30 + 1) {
                if (0 < local_30->npoints) {
                  iVar4 = 0;
                  do {
                    if (((local_30->points[iVar4].x == iVar3) &&
                        (iVar5 = local_30->points[iVar4].y, iVar7 <= iVar5)) && (iVar5 <= iVar9)) {
                      if (iVar5 != -1) goto chose_link;
                      break;
                    }
                    iVar4 = iVar4 + 1;
                  } while (iVar4 < local_30->npoints);
                }
              }
              if (0 < plVar8->npoints) {
                iVar4 = 0;
                do {
                  if ((local_54 == plVar8->points[iVar4].y) &&
                     (iVar5 = plVar8->points[iVar4].x, iVar3 <= iVar5)) {
                    if (iVar5 != -1) goto LAB_080f5459;
                    break;
                  }
                  iVar4 = iVar4 + 1;
                } while (iVar4 < plVar8->npoints);
              }
              local_38 = local_38 + 1;
            }
LAB_080f5459:
            local_54 = local_54 + 1;
            local_50 = local_50 + 1;
            local_58 = local_58 + 4;
          } while (local_54 <= iVar9);
        }
      }
    }
  }
  else {
LAB_080f5198:
    assert_failed = 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

int next_link_in_view_(document_view *doc_view,int current,int direction,
                      _func_int_document_view_ptr_link_ptr *fn,
                      _func_void_document_view_ptr_link_ptr *cntr)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  int height;
  link **pplVar4;
  int y;
  int iVar5;
  int iVar6;
  link **pplVar7;
  int iVar8;
  int end;
  document *document;
  int local_24;
  int local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  if ((((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
      (fn == (_func_int_document_view_ptr_link_ptr *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x1fc;
    elinks_internal((uchar *)
                    "assertion doc_view && doc_view->document && doc_view->vs && fn failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  pdVar2 = doc_view->document;
  iVar8 = pvVar1->y;
  iVar3 = (doc_view->box).height + iVar8;
  iVar6 = pdVar2->height;
  if (iVar3 <= pdVar2->height) {
    iVar6 = iVar3;
  }
  local_20 = pdVar2->nlinks + -1;
  iVar3 = 0;
  if (-1 < iVar8) {
    iVar3 = iVar8;
  }
  iVar8 = 0;
  if (iVar3 < iVar6) {
    pplVar7 = pdVar2->lines1 + iVar3;
    pplVar4 = pdVar2->lines2 + iVar3;
    do {
      iVar5 = local_20;
      if ((*pplVar7 != (link *)0x0) &&
         (iVar5 = ((int)*pplVar7 - (int)pdVar2->links >> 2) * -0x3b13b13b, local_20 <= iVar5)) {
        iVar5 = local_20;
      }
      local_20 = iVar5;
      if ((*pplVar4 != (link *)0x0) &&
         (iVar5 = ((int)*pplVar4 - (int)pdVar2->links >> 2) * -0x3b13b13b, iVar8 < iVar5)) {
        iVar8 = iVar5;
      }
      iVar3 = iVar3 + 1;
      pplVar7 = pplVar7 + 1;
      pplVar4 = pplVar4 + 1;
    } while (iVar3 < iVar6);
  }
  if ((local_20 <= current) && (current <= iVar8)) {
    iVar6 = current * 0x34;
    iVar3 = direction + current;
    local_24 = current;
    do {
      iVar5 = (*fn)(doc_view,(link *)((int)&pdVar2->links->accesskey + iVar6));
      if (iVar5 != 0) {
        pvVar1->current_link = local_24;
        if (cntr != (_func_void_document_view_ptr_link_ptr *)0x0) {
          (*cntr)(doc_view,(link *)((int)&pdVar2->links->accesskey + iVar6));
          return 1;
        }
        return 1;
      }
      local_24 = local_24 + direction;
      if (iVar3 < local_20) break;
      iVar3 = iVar3 + direction;
      iVar6 = iVar6 + direction * 0x34;
    } while (iVar3 - direction <= iVar8);
  }
  pvVar1->current_link = -1;
  return 0;
}



// WARNING: Unknown calling convention

int next_link_in_view_y(document_view *doc_view,int current,int direction)

{
  int iVar1;
  
  iVar1 = next_link_in_view_(doc_view,current,direction,link_in_view_y,set_pos_x);
  return iVar1;
}



// WARNING: Unknown calling convention

int next_link_in_view(document_view *doc_view,int current,int direction)

{
  int iVar1;
  
  iVar1 = next_link_in_view_(doc_view,current,direction,link_in_view,
                             (_func_void_document_view_ptr_link_ptr *)0x0);
  return iVar1;
}



// WARNING: Unknown calling convention

void find_link(document_view *doc_view,int direction,int page_mode)

{
  link *plVar1;
  int iVar2;
  link *cur;
  link *cur_1;
  int iVar3;
  int ymax;
  int iVar4;
  link **line;
  link *link_00;
  link *link;
  int iVar5;
  link **pplVar6;
  int y;
  int ymin;
  int iVar7;
  view_state *local_28;
  document *local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x318;
    elinks_internal((uchar *)"assertion doc_view && doc_view->document && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if (direction == -1) {
    local_20 = doc_view->document;
    if (local_20->lines2 == (link **)0x0) goto LAB_080f58d3;
    local_28 = doc_view->vs;
    iVar3 = local_28->y;
    iVar2 = local_20->height;
    iVar5 = (doc_view->box).height + iVar3;
    iVar4 = iVar5 + -1;
    if (iVar2 + -1 < iVar5 + -1) {
      iVar4 = iVar2 + -1;
    }
    if (iVar4 < 0) goto LAB_080f58d9;
    iVar7 = 0;
    if (-1 < iVar3) {
      iVar7 = iVar3;
    }
    if (iVar5 <= iVar2) {
      iVar2 = iVar5;
    }
    link_00 = (link *)0x0;
    pplVar6 = local_20->lines2 + iVar4;
    do {
      plVar1 = *pplVar6;
      iVar4 = iVar4 + -1;
      if ((plVar1 != (link *)0x0) && ((link_00 < plVar1 || (link_00 == (link *)0x0)))) {
        link_00 = plVar1;
      }
    } while ((iVar7 <= iVar4) && (pplVar6 = pplVar6 + -1, iVar4 < iVar2));
  }
  else {
    local_20 = doc_view->document;
    if (local_20->lines1 == (link **)0x0) {
LAB_080f58d3:
      local_28 = doc_view->vs;
      goto LAB_080f58d9;
    }
    local_28 = doc_view->vs;
    iVar3 = local_28->y;
    iVar2 = local_20->height;
    iVar4 = 0;
    if (-1 < iVar3) {
      iVar4 = iVar3;
    }
    if (iVar2 <= iVar4) goto LAB_080f58d9;
    iVar3 = iVar3 + (doc_view->box).height;
    pplVar6 = local_20->lines1 + iVar4;
    if (iVar3 <= iVar2) {
      iVar2 = iVar3;
    }
    link_00 = (link *)0x0;
    iVar3 = iVar4;
    do {
      plVar1 = *pplVar6;
      iVar3 = iVar3 + 1;
      if ((plVar1 != (link *)0x0) && ((plVar1 < link_00 || (link_00 == (link *)0x0)))) {
        link_00 = plVar1;
      }
    } while ((iVar4 <= iVar3) && (pplVar6 = pplVar6 + 1, iVar3 < iVar2));
  }
  if (link_00 != (link *)0x0) {
    iVar3 = ((int)link_00 - (int)local_20->links >> 2) * -0x3b13b13b;
    if (page_mode != 0) {
      next_link_in_view(doc_view,iVar3,direction);
      return;
    }
    local_28->current_link = iVar3;
    set_pos_x(doc_view,link_00);
    return;
  }
LAB_080f58d9:
  local_28->current_link = -1;
  return;
}



// WARNING: Unknown calling convention

void find_link_page_down(document_view *doc_view)

{
  find_link(doc_view,1,1);
  return;
}



// WARNING: Unknown calling convention

void find_link_down(document_view *doc_view)

{
  find_link(doc_view,1,0);
  return;
}



// WARNING: Unknown calling convention

void find_link_page_up(document_view *doc_view)

{
  find_link(doc_view,-1,1);
  return;
}



// WARNING: Unknown calling convention

void find_link_up(document_view *doc_view)

{
  find_link(doc_view,-1,0);
  return;
}



// WARNING: Unknown calling convention

int link_in_view_y(document_view *doc_view,link *link)

{
  int iVar1;
  bool bVar2;
  int y;
  int iVar3;
  int i;
  int iVar4;
  int iVar5;
  int height;
  int dy;
  
  if (assert_failed == 0) {
    bVar2 = link == (link *)0x0 || doc_view == (document_view *)0x0;
    assert_failed = (int)bVar2;
    if (bVar2) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x1b7;
      elinks_internal((uchar *)"assertion doc_view && link failed!");
      if (assert_failed != 0) goto LAB_080f5aa8;
    }
    iVar4 = (doc_view->box).height;
    iVar1 = doc_view->vs->y;
    if (link->npoints < 1) {
      return 0;
    }
    y = link->points->y - iVar1;
    if ((iVar4 <= y) || (y < 0)) {
      iVar3 = 0;
      do {
        iVar3 = iVar3 + 1;
        if (link->npoints <= iVar3) {
          return 0;
        }
        iVar5 = link->points[iVar3].y - iVar1;
      } while ((iVar4 <= iVar5) || (iVar5 < 0));
    }
    iVar4 = 1;
  }
  else {
LAB_080f5aa8:
    assert_failed = 0;
    iVar4 = 0;
  }
  return iVar4;
}



// WARNING: Unknown calling convention

int link_in_view(document_view *doc_view,link *link)

{
  int iVar1;
  bool bVar2;
  int iVar3;
  int x;
  int iVar4;
  int i;
  int iVar5;
  uint uVar6;
  int dx;
  int width;
  
  if (assert_failed == 0) {
    bVar2 = doc_view == (document_view *)0x0 || link == (link *)0x0;
    uVar6 = (uint)bVar2;
    assert_failed = uVar6;
    if (doc_view == (document_view *)0x0 || link == (link *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x1ca;
      elinks_internal((uchar *)"assertion doc_view && link failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return 0;
      }
    }
    iVar3 = link_in_view_y(doc_view,link);
    if (iVar3 == 0) {
      return 0;
    }
    if (assert_failed == 0) {
      assert_failed = uVar6;
      if (bVar2) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
        errline = 0x1a2;
        elinks_internal((uchar *)"assertion doc_view && link failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return 0;
        }
      }
      iVar3 = (doc_view->box).width;
      iVar1 = doc_view->vs->x;
      if (0 < link->npoints) {
        x = link->points->x - iVar1;
        if ((iVar3 <= x) || (x < 0)) {
          iVar4 = 0;
          do {
            iVar4 = iVar4 + 1;
            if (link->npoints <= iVar4) {
              return 0;
            }
            iVar5 = link->points[iVar4].x - iVar1;
          } while ((iVar3 <= iVar5) || (iVar5 < 0));
        }
        return 1;
      }
      return 0;
    }
  }
  assert_failed = 0;
  return 0;
}



// WARNING: Unknown calling convention

int current_link_is_visible(document_view *doc_view)

{
  link *link;
  link *link_00;
  int iVar1;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x1d4;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f5c78;
      if (doc_view == (document_view *)0x0) {
        return 0;
      }
    }
    else {
      assert_failed = 0;
    }
    iVar1 = doc_view->vs->current_link;
    if (((-1 < iVar1) && (iVar1 < doc_view->document->nlinks)) &&
       (link_00 = doc_view->document->links + iVar1, link_00 != (link *)0x0)) {
      iVar1 = link_in_view(doc_view,link_00);
      return (uint)(iVar1 != 0);
    }
  }
  else {
LAB_080f5c78:
    assert_failed = 0;
  }
  return 0;
}



// WARNING: Unknown calling convention

link * get_last_link(document_view *doc_view)

{
  int iVar1;
  link *plVar2;
  link *link;
  document *document;
  link **pplVar3;
  int i;
  int iVar4;
  int height;
  int iVar5;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x18b;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f5dc0;
    }
    else {
      assert_failed = 0;
    }
    pplVar3 = doc_view->document->lines2;
    if (pplVar3 != (link **)0x0) {
      iVar1 = doc_view->vs->y;
      iVar5 = (doc_view->box).height + iVar1;
      iVar4 = 0;
      if (-1 < iVar1) {
        iVar4 = iVar1;
      }
      iVar1 = doc_view->document->height;
      if (iVar1 < iVar5) {
        iVar5 = iVar1;
      }
      if (iVar4 < iVar5) {
        pplVar3 = pplVar3 + iVar4;
        plVar2 = (link *)0x0;
        do {
          if (plVar2 < *pplVar3) {
            plVar2 = *pplVar3;
          }
          iVar4 = iVar4 + 1;
          pplVar3 = pplVar3 + 1;
        } while (iVar4 < iVar5);
        return plVar2;
      }
    }
  }
  else {
LAB_080f5dc0:
    assert_failed = 0;
  }
  return (link *)0x0;
}



// WARNING: Unknown calling convention

link * get_first_link(document_view *doc_view)

{
  document *pdVar1;
  int iVar2;
  link *plVar3;
  document *document;
  link *link;
  int i;
  int iVar4;
  link **pplVar5;
  int height;
  int iVar6;
  link *undef;
  
  if (assert_failed == 0) {
    if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x16e;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f5eb0;
    }
    else {
      assert_failed = 0;
    }
    pdVar1 = doc_view->document;
    if (pdVar1->lines1 != (link **)0x0) {
      iVar2 = doc_view->vs->y;
      iVar6 = iVar2 + (doc_view->box).height;
      iVar4 = 0;
      if (-1 < iVar2) {
        iVar4 = iVar2;
      }
      if (pdVar1->height < iVar6) {
        iVar6 = pdVar1->height;
      }
      if (iVar4 < iVar6) {
        pplVar5 = pdVar1->lines1 + iVar4;
        link = pdVar1->links + pdVar1->nlinks;
        do {
          plVar3 = *pplVar5;
          if ((plVar3 != (link *)0x0) && (plVar3 < link)) {
            link = plVar3;
          }
          iVar4 = iVar4 + 1;
          pplVar5 = pplVar5 + 1;
        } while (iVar4 < iVar6);
        if (link != pdVar1->links + pdVar1->nlinks) {
          return link;
        }
      }
    }
  }
  else {
LAB_080f5eb0:
    assert_failed = 0;
  }
  return (link *)0x0;
}



// WARNING: Unknown calling convention

void set_link(document_view *doc_view)

{
  int iVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(doc_view == (document_view *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x68;
    elinks_internal((uchar *)"assertion doc_view failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  iVar1 = current_link_is_visible(doc_view);
  if (iVar1 == 0) {
    find_link_page_down(doc_view);
    return;
  }
  return;
}



// WARNING: Unknown calling convention

uchar * _(uchar *msg,terminal *term)

{
  int cp_index;
  int new_charset;
  uchar *codeset;
  
  if ((msg != (uchar *)0x0) && (*msg != '\0')) {
    if (term != (terminal *)0x0) {
      cp_index = get_terminal_codepage(term);
      if (cp_index != current_charset) {
        codeset = get_cp_mime_name(cp_index);
        bind_textdomain_codeset("elinks",codeset);
        current_charset = cp_index;
      }
    }
    msg = gettext(msg);
  }
  return msg;
}



// WARNING: Unknown calling convention

uchar * get_current_link_info(session *ses,document_view *doc_view)

{
  document *pdVar1;
  int iVar2;
  terminal *term_00;
  uchar *puVar3;
  string *psVar4;
  option_value *poVar5;
  link *link;
  link *plVar6;
  terminal *term;
  uchar *local_30;
  term_event_keyboard kbd;
  string str;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->document == (document *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x5a0;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->document && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  pdVar1 = doc_view->document;
  if (((pdVar1->frame_desc == (frameset_desc *)0x0) &&
      (iVar2 = doc_view->vs->current_link, -1 < iVar2)) &&
     ((iVar2 < pdVar1->nlinks && (plVar6 = pdVar1->links + iVar2, plVar6 != (link *)0x0)))) {
    if (plVar6->type < LINK_BUTTON) {
      term_00 = ses->tab->term;
      local_30 = plVar6->where;
      psVar4 = init_string(&str);
      if (psVar4 != (string *)0x0) {
        if ((plVar6->where == (uchar *)0x0) && (plVar6->where_img != (uchar *)0x0)) {
          puVar3 = _((uchar *)"Image",term_00);
          add_to_string(&str,puVar3);
          add_char_to_string(&str,' ');
          local_30 = plVar6->where_img;
        }
        else if (plVar6->type == LINK_MAP) {
          puVar3 = _((uchar *)"Usemap",term_00);
          add_to_string(&str,puVar3);
          add_char_to_string(&str,' ');
        }
        add_string_uri_to_string(&str,local_30,URI_PUBLIC);
        if ((plVar6->accesskey != 0) &&
           (poVar5 = get_opt_(), poVar5->tree != (list_head_elinks *)0x0)) {
          add_to_string(&str," (");
          kbd.key = plVar6->accesskey;
          kbd.modifier = KBD_MOD_ALT;
          add_keystroke_to_string(&str,&kbd,0);
          add_char_to_string(&str,')');
        }
        if ((term_00->field_0x38 & 2) == 0) {
          decode_uri_string_for_display(&str);
          return str.source;
        }
        decode_uri_string(&str);
        return str.source;
      }
    }
    else if ((plVar6->data).name != (uchar *)0x0) {
      puVar3 = get_form_info(ses,doc_view);
      return puVar3;
    }
  }
  return (uchar *)0x0;
}



// WARNING: Unknown calling convention

uchar * get_current_link_title(document_view *doc_view)

{
  uchar uVar1;
  document *pdVar2;
  int iVar3;
  conv_table *convert_table_00;
  ushort **ppuVar4;
  uint uVar5;
  uchar *src;
  byte *pbVar6;
  byte *pbVar7;
  uchar *link_title;
  conv_table *convert_table;
  link *link;
  link *plVar8;
  uchar *puVar9;
  byte bVar10;
  
  bVar10 = 0;
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x57a;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f6278;
    }
    else {
      assert_failed = 0;
    }
    pdVar2 = doc_view->document;
    if ((((pdVar2->frame_desc == (frameset_desc *)0x0) &&
         (iVar3 = doc_view->vs->current_link, -1 < iVar3)) &&
        ((iVar3 < pdVar2->nlinks &&
         ((plVar8 = pdVar2->links + iVar3, plVar8 != (link *)0x0 && (plVar8->title != (uchar *)0x0))
         )))) && (*plVar8->title != '\0')) {
      convert_table_00 = get_translation_table(pdVar2->cp,(pdVar2->options).cp);
      uVar5 = 0xffffffff;
      puVar9 = plVar8->title;
      do {
        if (uVar5 == 0) break;
        uVar5 = uVar5 - 1;
        uVar1 = *puVar9;
        puVar9 = puVar9 + (uint)bVar10 * -2 + 1;
      } while (uVar1 != '\0');
      pbVar7 = convert_string_elinks
                         (convert_table_00,plVar8->title,~uVar5 - 1,(doc_view->document->options).cp
                          ,CSM_DEFAULT,(int *)0x0,(_func_void_void_ptr_uchar_ptr_int *)0x0,
                          (void *)0x0);
      if (((pbVar7 != (byte *)0x0) && (((doc_view->document->options).field_0x5c & 0x10) == 0)) &&
         (bVar10 = *pbVar7, bVar10 != 0)) {
        ppuVar4 = __ctype_b_loc();
        pbVar6 = pbVar7;
        do {
          if (((*ppuVar4)[bVar10] & 0x4002) != 0x4000) {
            *pbVar6 = 0x2a;
          }
          pbVar6 = pbVar6 + 1;
          bVar10 = *pbVar6;
        } while (bVar10 != 0);
      }
    }
    else {
      pbVar7 = (byte *)0x0;
    }
  }
  else {
LAB_080f6278:
    assert_failed = 0;
    pbVar7 = (byte *)0x0;
  }
  return pbVar7;
}



// WARNING: Unknown calling convention

void link_menu(terminal *term,void *xxx,void *ses_)

{
  int iVar1;
  form_control *pfVar2;
  document_view *pdVar3;
  option_value *poVar4;
  string *psVar5;
  form_control *fc;
  document_view *doc_view;
  link *plVar6;
  link *link;
  string keystroke;
  menu_item *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(ses_ == (void *)0x0 || term == (terminal *)0x0);
  if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x4f7;
    elinks_internal((uchar *)"assertion term && ses failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  pdVar3 = current_frame((session *)ses_);
  local_20[0] = new_menu(FREE_LIST);
  if (local_20[0] == (menu_item *)0x0) {
    return;
  }
  if (pdVar3 == (document_view *)0x0) goto end;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((pdVar3->vs == (view_state *)0x0) || (pdVar3->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x4ff;
    elinks_internal((uchar *)"assertion doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar1 = pdVar3->vs->current_link;
  if (((iVar1 < 0) || (pdVar3->document->nlinks <= iVar1)) ||
     (plVar6 = pdVar3->document->links + iVar1, plVar6 == (link *)0x0)) goto end;
  if (plVar6->where == (uchar *)0x0) {
LAB_080f6898:
    if (LINK_MAP < plVar6->type) goto LAB_080f6451;
  }
  else {
    if (plVar6->type < LINK_BUTTON) {
      if (plVar6->type == LINK_MAP) {
        add_to_menu(local_20,(uchar *)"Display ~usemap",(uchar *)0x0,ACT_MAIN_LINK_FOLLOW,
                    (menu_func_T)0x0,(void *)0x0,SUBMENU);
      }
      else {
        add_to_menu(local_20,(uchar *)"~Follow link",(uchar *)0x0,ACT_MAIN_LINK_FOLLOW,
                    (menu_func_T)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Follow link and r~eload",(uchar *)0x0,
                    ACT_MAIN_LINK_FOLLOW_RELOAD,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T)0x0,(void *)0x0,NO_SELECT);
        add_new_win_to_menu(local_20,(uchar *)"Open in new ~window",term);
        add_to_menu(local_20,(uchar *)"Open in new ~tab",(uchar *)0x0,ACT_MAIN_OPEN_LINK_IN_NEW_TAB,
                    (menu_func_T)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Open in new tab in ~background",(uchar *)0x0,
                    ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND,(menu_func_T)0x0,(void *)0x0,NO_FLAG
                   );
        poVar4 = get_opt_();
        if (poVar4->tree == (list_head_elinks *)0x0) {
          add_to_menu(local_20,"",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T)0x0,(void *)0x0,NO_SELECT)
          ;
          add_to_menu(local_20,(uchar *)"~Download link",(uchar *)0x0,ACT_MAIN_LINK_DOWNLOAD,
                      (menu_func_T)0x0,(void *)0x0,NO_FLAG);
          add_to_menu(local_20,(uchar *)"~Add link to bookmarks",(uchar *)0x0,
                      ACT_MAIN_ADD_BOOKMARK_LINK,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
          add_uri_command_to_menu
                    (local_20,PASS_URI_LINK,(uchar *)"Pass link URI to e~xternal command");
        }
      }
      goto LAB_080f6898;
    }
LAB_080f6451:
    pfVar2 = (plVar6->data).form_control;
    if (pfVar2 != (form_control *)0x0) {
      if (pfVar2->type == FC_TEXTAREA) {
        if (pfVar2->mode == FORM_MODE_NORMAL) {
          psVar5 = init_string(&keystroke);
          if (psVar5 != (string *)0x0) {
            add_keystroke_action_to_string(&keystroke,0x17,KEYMAP_EDIT);
          }
          add_to_menu(local_20,(uchar *)"Open in ~external editor",keystroke.source,ACT_MAIN_NONE,
                      menu_textarea_edit,(void *)0x0,FREE_RTEXT);
        }
LAB_080f6474:
        add_to_menu(local_20,(uchar *)"~Submit form",(uchar *)0x0,ACT_MAIN_SUBMIT_FORM,
                    (menu_func_T)0x0,(void *)0x0,NO_FLAG);
        add_to_menu(local_20,(uchar *)"Submit form and rel~oad",(uchar *)0x0,
                    ACT_MAIN_SUBMIT_FORM_RELOAD,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
        if ((assert_failed == 0) &&
           (assert_failed = (int)(pfVar2->form == (form *)0x0), assert_failed != 0)) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
          errline = 0x548;
          elinks_internal((uchar *)"assertion fc->form failed!");
        }
        if (pfVar2->form->method == FORM_METHOD_GET) {
          add_new_win_to_menu(local_20,(uchar *)"Submit form and open in new ~window",term);
          add_to_menu(local_20,(uchar *)"Submit form and open in new ~tab",(uchar *)0x0,
                      ACT_MAIN_OPEN_LINK_IN_NEW_TAB,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
          add_to_menu(local_20,(uchar *)"Submit form and open in new tab in ~background",
                      (uchar *)0x0,ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND,(menu_func_T)0x0,
                      (void *)0x0,NO_FLAG);
        }
        poVar4 = get_opt_();
        if (poVar4->tree == (list_head_elinks *)0x0) {
          add_to_menu(local_20,(uchar *)"Submit form and ~download",(uchar *)0x0,
                      ACT_MAIN_LINK_DOWNLOAD,(menu_func_T)0x0,(void *)0x0,NO_FLAG);
        }
      }
      else if (pfVar2->type != FC_RESET) goto LAB_080f6474;
      add_to_menu(local_20,(uchar *)"~Reset form",(uchar *)0x0,ACT_MAIN_RESET_FORM,(menu_func_T)0x0,
                  (void *)0x0,NO_FLAG);
      add_to_menu(local_20,(uchar *)"Form f~ields",(uchar *)0x0,ACT_MAIN_LINK_FORM_MENU,
                  (menu_func_T)0x0,(void *)0x0,SUBMENU);
    }
  }
  if (plVar6->where_img != (uchar *)0x0) {
    add_to_menu(local_20,(uchar *)"V~iew image",(uchar *)0x0,ACT_MAIN_VIEW_IMAGE,(menu_func_T)0x0,
                (void *)0x0,NO_FLAG);
    poVar4 = get_opt_();
    if (poVar4->tree == (list_head_elinks *)0x0) {
      add_to_menu(local_20,(uchar *)"Download ima~ge",(uchar *)0x0,ACT_MAIN_LINK_DOWNLOAD_IMAGE,
                  (menu_func_T)0x0,(void *)0x0,NO_FLAG);
    }
  }
end:
  if (local_20[0]->text == (uchar *)0x0) {
    add_to_menu(local_20,(uchar *)"No link selected",(uchar *)0x0,ACT_MAIN_NONE,(menu_func_T)0x0,
                (void *)0x0,NO_SELECT);
  }
  do_menu(term,local_20[0],ses_,1);
  return;
}



// WARNING: Unknown calling convention

void jump_to_link_number(session *ses,document_view *doc_view,int n)

{
  link_type lVar1;
  form_control *fc_00;
  uchar *puVar2;
  int offset;
  int iVar3;
  form_state *pfVar4;
  uchar *point;
  form_state *fs;
  form_control *fc;
  byte bVar5;
  int utf8;
  uchar *scroll;
  link *link;
  link *plVar6;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x480;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  if (n < 0) {
    return;
  }
  if (doc_view->document->nlinks <= n) {
    return;
  }
  doc_view->vs->current_link = n;
  if (ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) goto LAB_080f6bda;
  iVar3 = doc_view->vs->current_link;
  if ((iVar3 < 0) || (doc_view->document->nlinks <= iVar3)) {
    plVar6 = (link *)0x0;
  }
  else {
    plVar6 = doc_view->document->links + iVar3;
  }
  lVar1 = plVar6->type;
  iVar3 = 1;
  bVar5 = (byte)doc_view->session->tab->term->field_0x38 >> 1;
  if (lVar1 != LINK_CHECKBOX) {
    if (lVar1 < LINK_SELECT) {
      iVar3 = 2;
      if (lVar1 != LINK_BUTTON) {
        iVar3 = 0;
      }
    }
    else {
      if (lVar1 == LINK_FIELD) {
        pfVar4 = find_form_state(doc_view,(plVar6->data).form_control);
        if ((pfVar4 != (form_state *)0x0) && (puVar2 = pfVar4->value, puVar2 != (uchar *)0x0)) {
          if ((bVar5 & 1) == 0) {
            iVar3 = pfVar4->state - pfVar4->vpos;
          }
          else {
            scroll = puVar2 + pfVar4->vpos;
            if (pfVar4->type == FC_PASSWORD) {
              iVar3 = utf8_ptr2chars(scroll,puVar2 + pfVar4->state);
            }
            else {
              iVar3 = utf8_ptr2cells(scroll,puVar2 + pfVar4->state);
            }
          }
          goto LAB_080f6c40;
        }
      }
      else if (lVar1 == LINK_AREA) {
        fc_00 = (plVar6->data).form_control;
        pfVar4 = find_form_state(doc_view,fc_00);
        if (pfVar4 != (form_state *)0x0) {
          iVar3 = area_cursor(fc_00,pfVar4,bVar5 & 1);
          goto LAB_080f6c40;
        }
      }
      iVar3 = 0;
    }
  }
LAB_080f6c40:
  if (plVar6->npoints != iVar3 && iVar3 <= plVar6->npoints) {
    move_cursor(ses,doc_view,((doc_view->box).x + plVar6->points[iVar3].x) - doc_view->vs->x,
                ((doc_view->box).y + plVar6->points[iVar3].y) - doc_view->vs->y);
  }
LAB_080f6bda:
  check_vs(doc_view);
  return;
}



// WARNING: Unknown calling convention

uri * get_link_uri(session *ses,document_view *doc_view,link *link)

{
  link_type lVar1;
  uchar *string;
  uri *puVar2;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uri *)0x0;
  }
  if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) || (link == (link *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x371;
    elinks_internal((uchar *)"assertion ses && doc_view && link failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uri *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  lVar1 = link->type;
  if (lVar1 != LINK_BUTTON) {
    if (lVar1 < LINK_BUTTON) {
      string = link->where;
      if (string == (uchar *)0x0) {
        string = link->where_img;
      }
      puVar2 = get_uri(string,0);
      return puVar2;
    }
    if (lVar1 != LINK_FIELD) {
      return (uri *)0x0;
    }
  }
  puVar2 = get_form_uri(ses,doc_view,(link->data).form_control);
  return puVar2;
}



// WARNING: Unknown calling convention

link * goto_current_link(session *ses,document_view *doc_view,int do_reload)

{
  int iVar1;
  form_control *fc_00;
  uri *puVar2;
  uri *uri_1;
  cache_mode mode_1;
  uchar *target;
  cache_mode mode;
  link *link_00;
  link *link;
  form_control *fc;
  uri *uri;
  
  if (assert_failed == 0) {
    assert_failed = (int)(doc_view == (document_view *)0x0 || ses == (session *)0x0);
    if (doc_view == (document_view *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x3c2;
      elinks_internal((uchar *)"assertion doc_view && ses failed!");
      if (assert_failed != 0) goto LAB_080f6f78;
      assert_failed = 0;
    }
    if (doc_view == (document_view *)0x0) {
      return (link *)0x0;
    }
    iVar1 = doc_view->vs->current_link;
    if (iVar1 < 0) {
      return (link *)0x0;
    }
    if (doc_view->document->nlinks <= iVar1) {
      return (link *)0x0;
    }
    link_00 = doc_view->document->links + iVar1;
    if (link_00 == (link *)0x0) {
      return (link *)0x0;
    }
    if (link_00->type < LINK_BUTTON) {
      puVar2 = get_link_uri(ses,doc_view,link_00);
      if (puVar2 == (uri *)0x0) {
        return (link *)0x0;
      }
      if (link_00->type == LINK_MAP) {
        target = (uchar *)0x0;
        if (link_00->target != (uchar *)0x0) {
          target = stracpy(link_00->target);
        }
        goto_imgmap(ses,puVar2,target);
      }
      else {
        mode_1 = -(uint)(do_reload == 0) & 0xfffffffe;
        goto_uri_frame(ses,puVar2,link_00->target,mode_1 + CACHE_MODE_FORCE_RELOAD);
      }
      done_uri(puVar2);
      return link_00;
    }
    fc_00 = (link_00->data).form_control;
    if (fc_00->type == FC_BUTTON) {
      return link_00;
    }
    assert_failed = (int)(fc_00->form == (form *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x38b;
      elinks_internal((uchar *)"assertion fc->form failed!");
      if (assert_failed != 0) goto LAB_080f6f78;
    }
    puVar2 = get_form_uri(ses,doc_view,fc_00);
    if (puVar2 != (uri *)0x0) {
      goto_uri_frame(ses,puVar2,fc_00->form->target,
                     (-(uint)(do_reload == 0) & 0xfffffffe) + CACHE_MODE_FORCE_RELOAD);
      done_uri(puVar2);
      return link_00;
    }
  }
  else {
LAB_080f6f78:
    assert_failed = 0;
  }
  return (link *)0x0;
}



// WARNING: Unknown calling convention

frame_event_status enter(session *ses,document_view *doc_view,int do_reload)

{
  form_control *pfVar1;
  form_state *fs;
  link *plVar2;
  form_state *pfVar3;
  document *pdVar4;
  int iVar5;
  link *link;
  form_control *fc;
  uint uVar6;
  form_control *fc_00;
  form *form;
  form *pfVar7;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_REFRESH;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x438;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_REFRESH;
    }
  }
  else {
    assert_failed = 0;
  }
  if (((doc_view == (document_view *)0x0) || (iVar5 = doc_view->vs->current_link, iVar5 < 0)) ||
     ((pdVar4 = doc_view->document, pdVar4->nlinks <= iVar5 ||
      (plVar2 = pdVar4->links + iVar5, plVar2 == (link *)0x0)))) {
LAB_080f70fd:
    fs = (form_state *)0x1;
  }
  else {
    if (LINK_AREA < plVar2->type) {
LAB_080f7119:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x42d;
      elinks_internal((uchar *)"bad link type %d",plVar2->type);
      return FRAME_EVENT_REFRESH;
    }
    uVar6 = 1 << ((byte)plVar2->type & 0x1f);
    if ((uVar6 & 0x67) == 0) {
      if ((uVar6 & 0x10) == 0) {
        if ((uVar6 & 8) == 0) goto LAB_080f7119;
        pfVar1 = (plVar2->data).form_control;
        if ((pfVar1->mode == FORM_MODE_NORMAL) &&
           (pfVar3 = find_form_state(doc_view,pfVar1), pfVar3 != (form_state *)0x0)) {
          if (pfVar1->type == FC_CHECKBOX) {
            pfVar3->state = (uint)(pfVar3->state == 0);
            return FRAME_EVENT_REFRESH;
          }
          pfVar3->state = 1;
          pdVar4 = doc_view->document;
          pfVar7 = (form *)(pdVar4->forms).next;
          if (pfVar7 != (form *)&pdVar4->forms) {
            do {
              if (pfVar1->form == pfVar7) {
                fc_00 = (form_control *)(pfVar7->items).next;
                if (fc_00 != (form_control *)&pfVar7->items) {
                  do {
                    if ((((fc_00->type == FC_RADIO) &&
                         (iVar5 = xstrcmp(fc_00->name,pfVar1->name), iVar5 == 0)) &&
                        (pfVar1 != fc_00)) &&
                       (pfVar3 = find_form_state(doc_view,fc_00), pfVar3 != (form_state *)0x0)) {
                      pfVar3->state = 0;
                    }
                    fc_00 = fc_00->next;
                  } while (fc_00 != (form_control *)&pfVar7->items);
                  pdVar4 = doc_view->document;
                }
              }
              pfVar7 = pfVar7->next;
            } while (pfVar7 != (form *)&pdVar4->forms);
          }
          goto LAB_080f70fd;
        }
      }
      else {
        pfVar1 = (plVar2->data).form_control;
        if (pfVar1->mode == FORM_MODE_NORMAL) {
          (pdVar4->object).refcount = (pdVar4->object).refcount + 1;
          add_empty_window(ses->tab->term,release_document,doc_view->document);
          do_select_submenu(ses->tab->term,pfVar1->menu,ses);
          return FRAME_EVENT_REFRESH;
        }
      }
    }
    else {
      plVar2 = goto_current_link(ses,doc_view,do_reload);
      if (plVar2 == (link *)0x0) goto LAB_080f70fd;
    }
    fs = (form_state *)0x2;
  }
  return (frame_event_status)fs;
}



// WARNING: Unknown calling convention

void goto_link_number_do(session *ses,document_view *doc_view,int n)

{
  option_value *poVar1;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
       (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x49d;
      elinks_internal((uchar *)"assertion ses && doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080f7338;
    }
    else {
      assert_failed = 0;
    }
    if ((-1 < n) && (n < doc_view->document->nlinks)) {
      jump_to_link_number(ses,doc_view,n);
      if (1 < doc_view->document->links[n].type + ~LINK_SELECT) {
        poVar1 = get_opt_();
        if (poVar1->tree != (list_head_elinks *)0x0) {
          enter(ses,doc_view,0);
        }
      }
    }
  }
  else {
LAB_080f7338:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status try_document_key(session *ses,document_view *doc_view,term_event *ev)

{
  unicode_val_T uVar1;
  int iVar2;
  document *pdVar3;
  unicode_val_T uVar4;
  unicode_val_T *puVar5;
  link *plVar6;
  int i;
  int iVar7;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_IGNORED;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->document == (document *)0x0)) ||
     ((ev == (term_event *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 0x4bd;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->document && doc_view->vs && ev failed!")
    ;
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_IGNORED;
    }
    iVar7 = (ev->info).mouse.y;
  }
  else {
    iVar7 = (ev->info).mouse.y;
  }
  if (iVar7 == 4) {
    assert_failed = 0;
    uVar1 = (ev->info).mouse.x;
    if (-1 < (int)uVar1) {
      iVar2 = doc_view->vs->current_link;
      pdVar3 = doc_view->document;
      iVar7 = iVar2 + 1;
      if (iVar7 < pdVar3->nlinks) {
        if (pdVar3->links[iVar7].accesskey != uVar1) {
          plVar6 = pdVar3->links + iVar2 + 2;
          do {
            iVar7 = iVar7 + 1;
            if (pdVar3->nlinks <= iVar7) goto LAB_080f74d0;
            puVar5 = &plVar6->accesskey;
            plVar6 = plVar6 + 1;
          } while (*puVar5 != uVar1);
        }
        (ses->kbdprefix).repeat_count = 0;
        goto_link_number_do(ses,doc_view,iVar7);
        return FRAME_EVENT_REFRESH;
      }
LAB_080f74d0:
      if (-1 < iVar2) {
        iVar7 = 0;
        plVar6 = pdVar3->links;
        uVar4 = plVar6->accesskey;
        while( true ) {
          if (uVar4 == uVar1) {
            (ses->kbdprefix).repeat_count = 0;
            goto_link_number_do(ses,doc_view,iVar7);
            return FRAME_EVENT_REFRESH;
          }
          iVar7 = iVar7 + 1;
          if (iVar2 < iVar7) break;
          uVar4 = plVar6[1].accesskey;
          plVar6 = plVar6 + 1;
        }
        assert_failed = 0;
        return FRAME_EVENT_IGNORED;
      }
    }
  }
  assert_failed = 0;
  return FRAME_EVENT_IGNORED;
}



// WARNING: Unknown calling convention

void goto_link_number(session *ses,uchar *num)

{
  document_view *doc_view_00;
  long lVar1;
  document_view *doc_view;
  
  if (assert_failed == 0) {
    assert_failed = (int)(num == (uchar *)0x0 || ses == (session *)0x0);
    if (num == (uchar *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0x4ad;
      elinks_internal((uchar *)"assertion ses && num failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view_00 = current_frame(ses);
    if (assert_failed == 0) {
      assert_failed = (int)(doc_view_00 == (document_view *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
        errline = 0x4b0;
        elinks_internal((uchar *)"assertion doc_view failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      lVar1 = strtol((char *)num,(char **)0x0,10);
      goto_link_number_do(ses,doc_view_00,lVar1 + -1);
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void highlight_links_with_prefixes_that_start_with_n(terminal *term,document_view *doc_view,int n)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  document *pdVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  color_pair *color;
  int x;
  int x_00;
  int y;
  int i;
  int iVar9;
  link *link;
  link *plVar10;
  int local_38;
  int local_30;
  int local_2c;
  
  color = get_bfu_color(term,"searched");
  iVar1 = (doc_view->box).x;
  iVar2 = doc_view->vs->x;
  iVar3 = doc_view->vs->y;
  iVar4 = (doc_view->box).y;
  pdVar5 = doc_view->document;
  iVar9 = pdVar5->nlinks;
  if (n <= iVar9) {
    local_38 = n + 1;
    local_2c = n;
    while( true ) {
      iVar8 = local_2c;
      if ((local_2c < local_38) && (local_2c <= iVar9)) {
        plVar10 = pdVar5->links + local_2c + -1;
        local_30 = local_2c * 0x34;
        while( true ) {
          if (0 < plVar10->npoints) {
            iVar9 = 0;
            do {
              x_00 = (iVar1 - iVar2) + plVar10->points[iVar9].x;
              iVar6 = (doc_view->box).x;
              if (iVar6 <= x_00) {
                y = plVar10->points[iVar9].y + (iVar4 - iVar3);
                iVar7 = (doc_view->box).y;
                if (((iVar7 <= y) && (x_00 < iVar6 + (doc_view->box).width)) &&
                   (y < iVar7 + (doc_view->box).height)) {
                  draw_char_color(term,x_00,y,color);
                }
              }
              iVar9 = iVar9 + 1;
            } while (plVar10->npoints != iVar9 && iVar9 <= plVar10->npoints);
            iVar9 = pdVar5->nlinks;
          }
          local_2c = local_2c + 1;
          if ((local_38 <= local_2c) || (iVar9 < local_2c)) break;
          plVar10 = (link *)((int)&pdVar5->links->accesskey + local_30);
          local_30 = local_30 + 0x34;
        }
      }
      local_2c = iVar8 * 10;
      if (iVar9 < local_2c) break;
      local_38 = local_38 * 10;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void clear_link(terminal *term,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  screen_char *psVar6;
  terminal_screen *ptVar7;
  screen_char *psVar8;
  uchar uVar9;
  uchar uVar10;
  uchar uVar11;
  undefined uVar12;
  int y;
  screen_char *psVar13;
  int x_00;
  int iVar14;
  view_state *pvVar15;
  link *link;
  int iVar16;
  int iVar17;
  int i;
  link *last;
  int x;
  
  if (doc_view != (document_view *)0x0) {
    pvVar15 = doc_view->vs;
    iVar17 = pvVar15->current_link;
    if ((iVar17 < 0) || (doc_view->document->nlinks <= iVar17)) {
      link = (link *)0x0;
    }
    else {
      link = doc_view->document->links + iVar17;
    }
    iVar14 = pvVar15->old_current_link;
    if ((((iVar14 < 0) || (doc_view->document->nlinks <= iVar14)) ||
        (last = doc_view->document->links + iVar14, link == last)) || (last == (link *)0x0))
    goto LAB_080f7941;
    iVar14 = (doc_view->box).x;
    iVar16 = iVar14 - pvVar15->x;
    iVar1 = (doc_view->box).y;
    iVar2 = pvVar15->y;
    if (last->npoints < 1) goto LAB_080f7941;
    iVar17 = 0;
    while( true ) {
      iVar3 = last->points[iVar17].x;
      iVar4 = last->points[iVar17].y;
      x_00 = iVar16 + iVar3;
      if (iVar14 <= x_00) {
        y = (iVar1 - iVar2) + iVar4;
        iVar5 = (doc_view->box).y;
        if (((iVar5 <= y) && (x_00 < iVar14 + (doc_view->box).width)) &&
           (y < iVar5 + (doc_view->box).height)) {
          psVar13 = get_char(term,x_00,y);
          psVar6 = doc_view->document->data[iVar4].chars;
          psVar8 = psVar6 + iVar3;
          uVar9 = psVar8->attr;
          uVar10 = psVar8->color[0];
          uVar11 = psVar8->color[1];
          uVar12 = psVar8->field_0x7;
          psVar13->data = psVar6[iVar3].data;
          psVar13->attr = uVar9;
          psVar13->color[0] = uVar10;
          psVar13->color[1] = uVar11;
          psVar13->field_0x7 = uVar12;
          ptVar7 = term->screen;
          if (y < ptVar7->dirty_from) {
            ptVar7->dirty_from = y;
          }
          if (ptVar7->dirty_to < y) {
            ptVar7->dirty_to = y;
          }
        }
      }
      iVar17 = iVar17 + 1;
      if (last->npoints <= iVar17) break;
      iVar14 = (doc_view->box).x;
    }
  }
  pvVar15 = doc_view->vs;
  iVar17 = pvVar15->current_link;
LAB_080f7941:
  pvVar15->old_current_link = iVar17;
  return;
}



// WARNING: Unknown calling convention

void draw_current_link(session *ses,document_view *doc_view)

{
  terminal *term;
  window *pwVar1;
  int iVar2;
  document *pdVar3;
  color_flags cVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  link_type lVar8;
  form_control *fc_00;
  int iVar9;
  int iVar10;
  unicode_val_T uVar11;
  terminal_screen *ptVar12;
  color_T cVar13;
  color_T cVar14;
  uchar *puVar15;
  uchar uVar16;
  uchar uVar17;
  undefined uVar18;
  byte bVar19;
  window *pwVar20;
  form_state *pfVar21;
  form_state *fs;
  screen_char *psVar22;
  color_T swap_register_;
  color_flags color_flags;
  color_flags flags;
  int y;
  uchar *scroll;
  form_control *fc;
  uchar *point;
  int i;
  int utf8;
  int iVar23;
  link *link;
  link *plVar24;
  int x;
  int x_00;
  bool bVar25;
  int local_50;
  color_pair colors;
  
  term = ses->tab->term;
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (term == (terminal *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0xee;
      elinks_internal((uchar *)"assertion term && doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f79c0;
    }
    else {
      assert_failed = 0;
    }
    pwVar1 = ses->tab;
    pwVar20 = get_tab_by_number(term,term->current_tab);
    bVar25 = pwVar1 != pwVar20;
    assert_failed = (int)bVar25;
    if (bVar25) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 0xf1;
      elinks_internal((uchar *)"assertion ses->tab == get_current_tab(term) failed!");
      if (assert_failed != 0) goto LAB_080f79c0;
    }
    if (((doc_view != (document_view *)0x0) && (iVar2 = doc_view->vs->current_link, -1 < iVar2)) &&
       ((iVar2 < doc_view->document->nlinks &&
        (plVar24 = doc_view->document->links + iVar2, plVar24 != (link *)0x0)))) {
      bVar25 = true;
      if (plVar24->type + ~LINK_SELECT < 2) {
        bVar25 = ses->insert_mode == INSERT_MODE_OFF;
      }
      init_link_drawing::template.attr = 0x40;
      pdVar3 = doc_view->document;
      cVar4 = (pdVar3->options).color_flags;
      bVar19 = *(byte *)&(pdVar3->options).active_link;
      flags = cVar4 | COLOR_DECREASE_LIGHTNESS;
      if ((bVar19 & 2) != 0) {
        init_link_drawing::template.attr = 0x60;
        bVar19 = *(byte *)&(pdVar3->options).active_link;
      }
      if ((bVar19 & 4) != 0) {
        init_link_drawing::template._4_4_ = init_link_drawing::template._4_4_ | 8;
        bVar19 = *(byte *)&(pdVar3->options).active_link;
      }
      if ((bVar19 & 1) == 0) {
        colors.foreground = (plVar24->color).foreground;
        colors.background = (plVar24->color).background;
      }
      else {
        colors.foreground = (pdVar3->options).active_link.fg;
        colors.background = (pdVar3->options).active_link.bg;
      }
      cVar14 = colors.background;
      if ((bVar25) && ((*(byte *)&(pdVar3->options).active_link & 8) != 0)) {
        cVar13 = colors.foreground;
        colors.background = colors.foreground;
        colors.foreground = cVar14;
        if (plVar24->type + ~LINK_SELECT < 2) {
          flags = cVar4 & ~COLOR_INCREASE_CONTRAST |
                  (COLOR_DECREASE_LIGHTNESS|COLOR_ENSURE_INVERTED_CONTRAST);
        }
      }
      set_term_color(&init_link_drawing::template,&colors,flags,(pdVar3->options).color_mode);
      iVar2 = (doc_view->box).x;
      iVar5 = doc_view->vs->x;
      iVar6 = doc_view->vs->y;
      iVar7 = (doc_view->box).y;
      if ((ses->insert_mode != INSERT_MODE_OFF) ||
         (local_50 = -1, ses->navigate_mode != NAVIGATE_CURSOR_ROUTING)) {
        bVar19 = (byte)doc_view->session->tab->term->field_0x38 >> 1;
        lVar8 = plVar24->type;
        local_50 = 1;
        if (lVar8 != LINK_CHECKBOX) {
          if (lVar8 < LINK_SELECT) {
            local_50 = 2;
            if (lVar8 == LINK_BUTTON) goto LAB_080f7b70;
          }
          else if (lVar8 == LINK_FIELD) {
            pfVar21 = find_form_state(doc_view,(plVar24->data).form_control);
            if ((pfVar21 != (form_state *)0x0) &&
               (puVar15 = pfVar21->value, puVar15 != (uchar *)0x0)) {
              if ((bVar19 & 1) == 0) {
                local_50 = pfVar21->state - pfVar21->vpos;
              }
              else {
                scroll = puVar15 + pfVar21->vpos;
                if (pfVar21->type == FC_PASSWORD) {
                  local_50 = utf8_ptr2chars(scroll,puVar15 + pfVar21->state);
                }
                else {
                  local_50 = utf8_ptr2cells(scroll,puVar15 + pfVar21->state);
                }
              }
              goto LAB_080f7b70;
            }
          }
          else if (lVar8 == LINK_AREA) {
            fc_00 = (plVar24->data).form_control;
            pfVar21 = find_form_state(doc_view,fc_00);
            if (pfVar21 != (form_state *)0x0) {
              local_50 = area_cursor(fc_00,pfVar21,bVar19 & 1);
              goto LAB_080f7b70;
            }
          }
          local_50 = 0;
        }
      }
LAB_080f7b70:
      if (0 < plVar24->npoints) {
        iVar23 = 0;
        do {
          x_00 = (iVar2 - iVar5) + plVar24->points[iVar23].x;
          iVar9 = (doc_view->box).x;
          if (iVar9 <= x_00) {
            y = plVar24->points[iVar23].y + (iVar7 - iVar6);
            iVar10 = (doc_view->box).y;
            if (((iVar10 <= y) && (x_00 < iVar9 + (doc_view->box).width)) &&
               (y < (doc_view->box).height + iVar10)) {
              psVar22 = get_char(term,x_00,y);
              if (iVar23 == local_50) {
                set_cursor(term,x_00,y,
                           (uint)(1 < plVar24->type + ~LINK_SELECT &&
                                 psVar22 != &init_link_drawing::template));
                ses->tab->x = x_00;
                ses->tab->y = y;
              }
              uVar11 = psVar22->data;
              uVar16 = init_link_drawing::template.color[0];
              uVar17 = init_link_drawing::template.color[1];
              uVar18 = init_link_drawing::template._7_1_;
              init_link_drawing::template.data = uVar11;
              psVar22->attr = init_link_drawing::template.attr;
              psVar22->color[0] = uVar16;
              psVar22->color[1] = uVar17;
              psVar22->field_0x7 = uVar18;
              psVar22->data = uVar11;
              ptVar12 = term->screen;
              if (y < ptVar12->dirty_from) {
                ptVar12->dirty_from = y;
              }
              if (ptVar12->dirty_to < y) {
                ptVar12->dirty_to = y;
              }
            }
          }
          iVar23 = iVar23 + 1;
        } while (plVar24->npoints != iVar23 && iVar23 <= plVar24->npoints);
      }
      doc_view->vs->old_current_link = doc_view->vs->current_link;
      return;
    }
  }
  else {
LAB_080f79c0:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

void free_mark_by_index(int i)

{
  if ((assert_failed == 0) && (assert_failed = (int)(0x33 < (uint)i), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x76;
    elinks_internal((uchar *)"assertion is_valid_mark_index(i) failed!");
  }
  if (marks[i] != (view_state *)0x0) {
    destroy_vs(marks[i],1);
    if (marks[i] != (view_state *)0x0) {
      mem_free(marks[i]);
    }
    marks[i] = (view_state *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void done_marks(module *xxx)

{
  int i;
  int i_00;
  int iVar1;
  
  i_00 = 0;
  do {
    iVar1 = i_00 + 1;
    free_mark_by_index(i_00);
    i_00 = iVar1;
  } while (iVar1 != 0x34);
  return;
}



// WARNING: Unknown calling convention

void goto_mark(uchar mark,view_state *vs)

{
  document_view *pdVar1;
  int old_current_link;
  int iVar2;
  byte bVar3;
  byte bVar4;
  int i;
  uint uVar5;
  document_view *doc_view;
  
  iVar2 = assert_failed;
  bVar4 = mark + 0x9f;
  bVar3 = mark + 0xbf;
  if ((0x19 < bVar4) && (0x19 < bVar3)) {
    return;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(0x19 < bVar3 && 0x19 < bVar4), 0x19 < bVar3 && 0x19 < bVar4)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion is_valid_mark_char(mark) failed!");
  }
  else if (bVar3 < 0x1a) {
    uVar5 = mark - 0x41;
    goto LAB_080f7f10;
  }
  uVar5 = mark - 0x47;
  iVar2 = assert_failed;
LAB_080f7f10:
  if ((iVar2 == 0) && (assert_failed = (int)(0x33 < uVar5), assert_failed != 0)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x5a;
    elinks_internal((uchar *)"assertion is_valid_mark_index(i) failed!");
  }
  if ((marks[uVar5] != (view_state *)0x0) &&
     (iVar2 = compare_uri(marks[uVar5]->uri,vs->uri,0), iVar2 != 0)) {
    iVar2 = vs->current_link;
    pdVar1 = vs->doc_view;
    destroy_vs(vs,0);
    copy_vs(vs,marks[uVar5]);
    vs->doc_view = pdVar1;
    pdVar1->vs = vs;
    vs->old_current_link = iVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void set_mark(uchar mark,view_state *mark_vs)

{
  view_state *dst;
  byte bVar1;
  byte bVar2;
  int i;
  int i_00;
  
  bVar2 = mark + 0x9f;
  bVar1 = mark + 0xbf;
  if ((0x19 < bVar2) && (0x19 < bVar1)) {
    return;
  }
  if ((assert_failed == 0) &&
     (assert_failed = (int)(0x19 < bVar1 && 0x19 < bVar2), 0x19 < bVar1 && 0x19 < bVar2)) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
    errline = 0x43;
    elinks_internal((uchar *)"assertion is_valid_mark_char(mark) failed!");
  }
  else if (bVar1 < 0x1a) {
    i_00 = mark - 0x41;
    goto LAB_080f8056;
  }
  i_00 = mark - 0x47;
LAB_080f8056:
  free_mark_by_index(i_00);
  if ((mark_vs != (view_state *)0x0) &&
     (dst = (view_state *)mem_calloc(1,0x30), dst != (view_state *)0x0)) {
    copy_vs(dst,mark_vs);
    marks[i_00] = dst;
  }
  return;
}



// WARNING: Unknown calling convention

evhook_status search_history_write_hook(va_list ap,void *data)

{
  save_input_history(&search_history,(uchar *)"searchhist");
  return EVENT_HOOK_STATUS_NEXT;
}



// WARNING: Unknown calling convention

void done_search_history(module *module)

{
  input_history *piVar1;
  input_history *piVar2;
  input_history *piVar3;
  xlist_head *head;
  input_history *piVar4;
  xlist_head *next;
  
  save_input_history(&search_history,(uchar *)"searchhist");
  piVar4 = (input_history *)search_history.entries.next;
  piVar1 = (input_history *)search_history.entries.prev;
  if ((input_history *)search_history.entries.next != &search_history) {
    do {
      piVar4 = (input_history *)(piVar4->entries).next;
    } while (piVar4 != &search_history);
  }
  for (; piVar1 != piVar4; piVar1 = (input_history *)(piVar1->entries).prev) {
  }
                    // WARNING: Load size is inaccurate
  piVar3 = *search_history.entries.next;
  piVar1 = (input_history *)search_history.entries.next;
  while (piVar2 = piVar3, piVar1 != piVar4) {
    (piVar2->entries).prev = (piVar1->entries).prev;
    *(void **)(piVar1->entries).prev = (piVar1->entries).next;
    mem_free(piVar1);
    piVar3 = (input_history *)(piVar2->entries).next;
    piVar1 = piVar2;
  }
  return;
}



// WARNING: Unknown calling convention

void init_search_history(module *module)

{
  load_input_history(&search_history,(uchar *)"searchhist");
  return;
}



// WARNING: Unknown calling convention

int get_range(document *document,int y,int height,int l,search **s1,search **s2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int i;
  search *psVar4;
  
  if (assert_failed == 0) {
    if (((s1 == (search **)0x0) || (document == (document *)0x0)) || (s2 == (search **)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0xf4;
      elinks_internal((uchar *)"assertion document && s1 && s2 failed!");
      if (assert_failed != 0) goto LAB_080f8188;
    }
    else {
      assert_failed = 0;
    }
    *s2 = (search *)0x0;
    iVar2 = 0;
    if (-1 < y) {
      iVar2 = y;
    }
    iVar1 = iVar2 + height;
    *s1 = (search *)0x0;
    if ((iVar2 < iVar1) && (document->height != iVar2 && iVar2 <= document->height)) {
      iVar3 = iVar2 * 4;
      do {
        psVar4 = *(search **)((int)document->slines1 + iVar3);
        if ((psVar4 != (search *)0x0) && ((*s1 == (search *)0x0 || (psVar4 < *s1)))) {
          *s1 = psVar4;
        }
        psVar4 = *(search **)((int)document->slines2 + iVar3);
        if ((psVar4 != (search *)0x0) && ((*s2 == (search *)0x0 || (*s2 < psVar4)))) {
          *s2 = psVar4;
        }
        iVar2 = iVar2 + 1;
      } while ((iVar2 < iVar1) &&
              (iVar3 = iVar3 + 4, document->height != iVar2 && iVar2 <= document->height));
      if ((*s1 != (search *)0x0) && (*s2 != (search *)0x0)) {
        psVar4 = *s1 + -l;
        *s1 = psVar4;
        if (psVar4 < document->search) {
          psVar4 = document->search;
        }
        *s1 = psVar4;
        psVar4 = document->search + ((document->nsearch + 1) - l);
        if (*s2 < psVar4 || *s2 == psVar4) {
          psVar4 = *s2;
        }
        *s2 = psVar4;
        if (psVar4 < *s1) {
          *s2 = (search *)0x0;
          *s1 = (search *)0x0;
          return 1;
        }
        if (*s1 != (search *)0x0) {
          return (uint)(psVar4 == (search *)0x0);
        }
      }
    }
    iVar2 = 1;
  }
  else {
LAB_080f8188:
    assert_failed = 0;
    iVar2 = -1;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

widget_handler_status_T search_dlg_cancel(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  done_handler_T *fn;
  widget_handler_status_T wVar2;
  void *data;
  
  pcVar1 = (code *)widget_data->widget->data;
                    // WARNING: Load size is inaccurate
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(*dlg_data->dlg->udata2);
  }
  wVar2 = cancel_dialog(dlg_data,widget_data);
  return wVar2;
}



// WARNING: Unknown calling convention

widget_handler_status_T search_dlg_ok(dialog_data *dlg_data,widget_data *widget_data)

{
  code *pcVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  uchar *data;
  option_elinks *root;
  int iVar4;
  widget_handler_status_T wVar5;
  search_dlg_hop *hop;
  
  pcVar1 = (code *)widget_data->widget->data;
  puVar2 = (undefined4 *)dlg_data->dlg->udata2;
  uVar3 = *puVar2;
  data = dlg_data->widgets_data[0].cdata;
  update_dialog_data(dlg_data);
  root = get_opt_rec(config_options,(uchar *)"document.browse.search");
  commit_option_values(resolvers,root,(option_value *)(puVar2 + 1),1);
  iVar4 = check_dialog(dlg_data);
  if (iVar4 != 0) {
    return EVENT_NOT_PROCESSED;
  }
  add_to_input_history(dlg_data->dlg->widgets[0].info.field.history,data,1);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)(uVar3,data);
  }
  wVar5 = cancel_dialog(dlg_data,widget_data);
  return wVar5;
}



// WARNING: Unknown calling convention

int strlen_u(uchar *text,int utf8)

{
  size_t sVar1;
  int iVar2;
  uchar *local_10 [3];
  
  local_10[0] = text;
  if (utf8 == 0) {
    sVar1 = strlen((char *)text);
    return sVar1;
  }
  iVar2 = strlen_utf8(local_10);
  return iVar2;
}



// WARNING: Unknown calling convention

unicode_val_T * memacpy_u(uchar *text,int textlen,int utf8)

{
  unicode_val_T *puVar1;
  unicode_val_T uVar2;
  int i_1;
  int iVar3;
  int i;
  uchar *local_20 [4];
  
  local_20[0] = text;
  puVar1 = (unicode_val_T *)mem_alloc(textlen * 4 + 4);
  if (puVar1 != (unicode_val_T *)0x0) {
    if (utf8 == 0) {
      iVar3 = 0;
      if (0 < textlen) {
        do {
          puVar1[iVar3] = (uint)local_20[0][iVar3];
          iVar3 = iVar3 + 1;
        } while (iVar3 != textlen);
        puVar1[textlen] = 0;
        return puVar1;
      }
    }
    else if (0 < textlen) {
      iVar3 = 0;
      do {
        uVar2 = utf8_to_unicode(local_20,local_20[0] + 7);
        puVar1[iVar3] = uVar2;
        iVar3 = iVar3 + 1;
      } while (iVar3 < textlen);
    }
    puVar1[textlen] = 0;
  }
  return puVar1;
}



// WARNING: Unknown calling convention

unicode_val_T * lowered_string(uchar *text,int textlen,int utf8)

{
  unicode_val_T *puVar1;
  wint_t wVar2;
  __int32_t **pp_Var3;
  int __res;
  wint_t *pwVar4;
  
  if (textlen < 0) {
    textlen = strlen_u(text,utf8);
  }
  puVar1 = memacpy_u(text,textlen,utf8);
  if ((textlen != 0) && (puVar1 != (unicode_val_T *)0x0)) {
    pwVar4 = puVar1 + textlen;
    while( true ) {
      if (utf8 == 0) {
        wVar2 = *pwVar4;
        if (wVar2 + 0x80 < 0x180) {
          pp_Var3 = __ctype_tolower_loc();
          wVar2 = (*pp_Var3)[wVar2];
        }
        *pwVar4 = wVar2;
      }
      else {
        wVar2 = towlower(*pwVar4);
        *pwVar4 = wVar2;
      }
      if (textlen == 0) break;
      pwVar4 = pwVar4 + -1;
      textlen = textlen + -1;
    }
  }
  return puVar1;
}



// WARNING: Unknown calling convention

void print_find_error_not_found(session *ses,uchar *title,uchar *message,uchar *search_string)

{
  option_value *poVar1;
  uchar *text;
  
  poVar1 = get_opt_();
  if (poVar1->tree != (list_head_elinks *)0x1) {
    if (poVar1->tree == (list_head_elinks *)0x2) {
      text = msg_text(ses->tab->term,message,search_string);
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,title,ALIGN_CENTER,text);
    }
    return;
  }
  beep_terminal(ses->tab->term);
  return;
}



// WARNING: Unknown calling convention

void print_find_error(session *ses,find_error find_error)

{
  bool bVar1;
  uchar *message;
  option_value *poVar2;
  char *pcVar3;
  int hit_top;
  
  switch(find_error) {
  default:
    goto switchD_080f8653_caseD_0;
  case FIND_ERROR_NO_PREVIOUS_SEARCH:
    message = (uchar *)"No previous search";
    goto LAB_080f8665;
  case FIND_ERROR_HIT_TOP:
    bVar1 = true;
    break;
  case FIND_ERROR_HIT_BOTTOM:
    bVar1 = false;
    break;
  case FIND_ERROR_NOT_FOUND:
    print_find_error_not_found
              (ses,"Search",(uchar *)"Search string \'%s\' not found",ses->search_word);
    return;
  case FIND_ERROR_REGEX:
    print_find_error_not_found
              (ses,"Search",(uchar *)"Could not compile regular expression \'%s\'",ses->search_word)
    ;
    return;
  }
  poVar2 = get_opt_();
  if (poVar2->tree != (list_head_elinks *)0x0) {
    pcVar3 = "Search hit bottom, continuing at top.";
    if (bVar1) {
      pcVar3 = "Search hit top, continuing at bottom.";
    }
    message = (uchar *)pcVar3;
    if ((uchar *)pcVar3 != (uchar *)0x0) {
LAB_080f8665:
      info_box(ses->tab->term,0,"Search",ALIGN_CENTER,message);
    }
  }
switchD_080f8653_caseD_0:
  return;
}



// WARNING: Unknown calling convention

frame_event_status search_typeahead(session *ses,document_view *doc_view,action_id_T action_id)

{
  code *handler_00;
  input_line_handler_T handler;
  uchar *puVar1;
  uchar *prompt;
  uchar *data_00;
  uchar *data;
  
  puVar1 = "#";
  if (action_id == 0x5f) {
    data_00 = "/";
    handler_00 = text_typeahead_handler;
    puVar1 = "/";
  }
  else if (action_id == 0x60) {
    puVar1 = "?";
    handler_00 = text_typeahead_handler;
    data_00 = puVar1;
  }
  else {
    data_00 = (uchar *)0x0;
    if (action_id == 0x5e) {
      data_00 = "#";
    }
    handler_00 = link_typeahead_handler;
    if (doc_view->document->nlinks == 0) {
      puVar1 = msg_text(ses->tab->term,(uchar *)"No links in current document");
      info_box(ses->tab->term,MSGBOX_FREE_TEXT,(uchar *)"Typeahead",ALIGN_CENTER,puVar1);
      return FRAME_EVENT_OK;
    }
  }
  input_field_line(ses,puVar1,data_00,&search_history,handler_00);
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

int match_link_text(link *link,uchar *text,int textlen,int case_sensitive)

{
  size_t sVar1;
  char *pcVar2;
  uchar *match;
  uchar *__s;
  
  if ((LINK_MAP < link->type) || (__s = (link->data).name, __s == (uchar *)0x0)) {
    __s = link->where;
    if ((__s == (uchar *)0x0) && (__s = link->where_img, __s == (uchar *)0x0)) {
      __s = "";
    }
    if (LINK_MAP < link->type) {
      return -1;
    }
  }
  sVar1 = strlen((char *)__s);
  if ((uint)textlen <= sVar1) {
    if (case_sensitive == 0) {
      pcVar2 = strcasestr((char *)__s,(char *)text);
    }
    else {
      pcVar2 = strstr((char *)__s,(char *)text);
    }
    if (pcVar2 != (char *)0x0) {
      return (int)pcVar2 - (int)__s;
    }
  }
  return -1;
}



// WARNING: Unknown calling convention

void draw_typeahead_match(terminal *term,document_view *doc_view,int chars,int offset)

{
  view_state *pvVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  link_type lVar8;
  color_pair *color;
  int y;
  byte bVar9;
  int iVar10;
  int i;
  uchar *text;
  form_control *pfVar11;
  line *plVar12;
  link *local_2c;
  int local_20;
  
  color = get_bfu_color(term,"searched");
  pvVar1 = doc_view->vs;
  iVar2 = (doc_view->box).x;
  iVar3 = pvVar1->x;
  iVar4 = (doc_view->box).y;
  iVar5 = pvVar1->y;
  iVar10 = pvVar1->current_link;
  if ((iVar10 < 0) || (doc_view->document->nlinks <= iVar10)) {
    local_2c = (link *)0x0;
    lVar8 = lRam00000004;
  }
  else {
    local_2c = doc_view->document->links + iVar10;
    lVar8 = local_2c->type;
  }
  if ((((LINK_MAP < lVar8) ||
       (pfVar11 = (local_2c->data).form_control, pfVar11 == (form_control *)0x0)) &&
      (pfVar11 = (form_control *)local_2c->where, pfVar11 == (form_control *)0x0)) &&
     (pfVar11 = (form_control *)local_2c->where_img, pfVar11 == (form_control *)0x0)) {
    pfVar11 = (form_control *)&DAT_0812e3d8;
  }
  local_20 = chars + offset;
  bVar9 = *(byte *)&pfVar11->next;
  if ((bVar9 != 0) && (0 < local_20)) {
    iVar10 = 0;
    do {
      iVar6 = local_2c->points[iVar10].x;
      iVar7 = local_2c->points[iVar10].y;
      if (((iVar7 < doc_view->document->height) &&
          (plVar12 = doc_view->document->data + iVar7, iVar6 < plVar12->length)) &&
         ((uint)bVar9 == plVar12->chars[iVar6].data)) {
        if (offset <= iVar10) {
          draw_char_color(term,(iVar2 - iVar3) + iVar6,iVar7 + (iVar4 - iVar5),color);
        }
        iVar10 = iVar10 + 1;
        bVar9 = *(byte *)((int)&pfVar11->next + 1);
        if (local_20 <= iVar10) {
          return;
        }
      }
      else {
        local_20 = local_20 + -1;
        offset = offset + -1;
        bVar9 = *(byte *)((int)&pfVar11->next + 1);
        if (local_20 <= iVar10) {
          return;
        }
      }
      pfVar11 = (form_control *)((int)&pfVar11->next + 1);
    } while (bVar9 != 0);
  }
  return;
}



// WARNING: Unknown calling convention

input_line_code link_typeahead_handler(input_line *line,int action_id)

{
  uchar *text;
  int *piVar1;
  session *ses;
  document *pdVar2;
  int case_sensitive;
  byte bVar3;
  document_view *doc_view_00;
  main_action action_id_1;
  int match;
  option_value *poVar4;
  size_t sVar5;
  int iVar6;
  int offset;
  int offset_00;
  int iVar7;
  int offset_1;
  int iVar8;
  link *link;
  link *plVar9;
  int wraparound;
  list_head_elinks *plVar10;
  document_view *doc_view;
  bool bVar11;
  char *pcVar12;
  int local_28;
  int local_20;
  
  ses = line->ses;
  doc_view_00 = current_frame(ses);
  if (assert_failed != 0) {
    assert_failed = 0;
    return INPUT_LINE_CANCEL;
  }
  assert_failed = (int)(doc_view_00 == (document_view *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x5be;
    elinks_internal((uchar *)"assertion doc_view != NULL failed: document not formatted");
    if (assert_failed != 0) {
      assert_failed = 0;
      return INPUT_LINE_CANCEL;
    }
  }
  if (line->buffer[0] == '\0') {
    if (line->data == (void *)0x0) {
      return INPUT_LINE_PROCEED;
    }
    draw_formatted(ses,0);
    return INPUT_LINE_PROCEED;
  }
  text = line->buffer;
  if (action_id == 0x1a) {
    iVar7 = doc_view_00->vs->current_link;
    if (iVar7 < 0) {
      return INPUT_LINE_PROCEED;
    }
    sVar5 = strlen((char *)text);
    poVar4 = get_opt_();
    iVar7 = match_link_text(doc_view_00->document->links + iVar7,text,sVar5,poVar4->number);
    if (iVar7 < 0) {
      return INPUT_LINE_PROCEED;
    }
    draw_typeahead_match(ses->tab->term,doc_view_00,sVar5,iVar7);
    return INPUT_LINE_PROCEED;
  }
  if (line->data == (void *)0x0) {
    bVar3 = line->buffer[0] - 0x23;
    if ((bVar3 < 0x1d) && (*(int *)(CSWTCH_247 + (uint)bVar3 * 4) != 0)) {
      search_typeahead(ses,doc_view_00,*(int *)(CSWTCH_247 + (uint)bVar3 * 4));
      return INPUT_LINE_CANCEL;
    }
    line->data = &DAT_0812cc9a;
  }
  iVar7 = doc_view_00->vs->current_link;
  if (iVar7 < 0) {
    iVar7 = 0;
  }
  pdVar2 = doc_view_00->document;
  switch(action_id) {
  case 0xb:
  case 0x16:
    bVar11 = true;
    local_20 = 1;
    iVar8 = iVar7 + 1;
    if (iVar8 < pdVar2->nlinks) break;
    poVar4 = get_opt_();
    if (poVar4->tree != (list_head_elinks *)0x0) {
      local_20 = 1;
      bVar11 = iVar7 != 0;
      iVar8 = 0;
      break;
    }
search_hit_boundary:
    offset_00 = 0;
    poVar4 = get_opt_();
    sVar5 = strlen((char *)text);
    iVar7 = match_link_text(pdVar2->links + iVar7,text,sVar5,poVar4->number);
    if (iVar7 < 0) goto LAB_080f8f36;
    goto LAB_080f8efa;
  default:
    bVar11 = false;
    local_20 = 1;
    iVar8 = iVar7;
    break;
  case 0xe:
    goto_current_link(ses,doc_view_00,0);
    return INPUT_LINE_CANCEL;
  case 0x19:
  case 0x1d:
    iVar8 = iVar7 + -1;
    if (iVar8 == -1) {
      poVar4 = get_opt_();
      if (poVar4->tree == (list_head_elinks *)0x0) goto search_hit_boundary;
      iVar8 = doc_view_00->document->nlinks + -1;
    }
    bVar11 = iVar7 != iVar8;
    local_20 = -1;
  }
  poVar4 = get_opt_();
  case_sensitive = poVar4->number;
  pcVar12 = "document.browse.search.wraparound";
  poVar4 = get_opt_();
  plVar10 = poVar4->tree;
  sVar5 = strlen((char *)text);
  if (assert_failed == 0) {
    if ((sVar5 == 0) || (local_20 == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x4c0;
      elinks_internal((uchar *)"assertion textlen && direction && offset failed!",pcVar12);
    }
    else {
      assert_failed = 0;
    }
  }
  if (local_20 == 1) {
    local_28 = iVar8 + -1;
    iVar6 = pdVar2->nlinks;
  }
  else {
    iVar6 = iVar8 + 1;
    local_28 = -1;
  }
  if ((local_28 < iVar8) && (iVar8 < iVar6)) {
    plVar9 = pdVar2->links;
    do {
      offset_00 = match_link_text(plVar9 + iVar8,text,sVar5,case_sensitive);
      if (-1 < offset_00) goto LAB_080f8d5a;
      if (plVar10 != (list_head_elinks *)0x0) {
        if (local_20 == 1) {
          if (iVar8 == iVar6 + -1) {
            plVar10 = (list_head_elinks *)0x0;
            iVar8 = -1;
            local_28 = -1;
            iVar6 = iVar7 + 1;
          }
        }
        else if (iVar8 == local_28 + 1) {
          plVar10 = (list_head_elinks *)0x0;
          iVar8 = pdVar2->nlinks;
          iVar6 = iVar8;
          local_28 = iVar7 + -1;
        }
      }
      iVar8 = iVar8 + local_20;
    } while ((iVar8 < iVar6) && (local_28 < iVar8));
  }
  offset_00 = 0;
  iVar8 = -1;
LAB_080f8d5a:
  if ((iVar7 != iVar8) || (!bVar11)) {
    if (-1 < iVar8) {
      if (assert_failed == 0) {
        if (iVar8 < doc_view_00->document->nlinks) {
          assert_failed = 0;
        }
        else {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
          errline = 0x565;
          elinks_internal((uchar *)
                          "assertion match >= 0 && match < doc_view->document->nlinks failed!");
        }
      }
      doc_view_00->vs->current_link = iVar8;
      plVar9 = doc_view_00->document->links + doc_view_00->vs->current_link;
      piVar1 = &(doc_view_00->box).height;
      *piVar1 = *piVar1 + -1;
      set_pos_x(doc_view_00,plVar9);
      set_pos_y(doc_view_00,plVar9);
      piVar1 = &(doc_view_00->box).height;
      *piVar1 = *piVar1 + 1;
      draw_formatted(ses,0);
      goto LAB_080f8dff;
    }
    if (!bVar11) {
LAB_080f8f36:
      print_find_error_not_found
                (ses,(uchar *)"Typeahead",(uchar *)"Could not find a link with the text \'%s\'.",
                 text);
      return INPUT_LINE_REWIND;
    }
  }
LAB_080f8efa:
  print_find_error_not_found
            (ses,(uchar *)"Typeahead",(uchar *)"No further matches for \'%s\'.",text);
LAB_080f8dff:
  sVar5 = strlen((char *)text);
  draw_typeahead_match(ses->tab->term,doc_view_00,sVar5,offset_00);
  return INPUT_LINE_PROCEED;
}



// WARNING: Unknown calling convention

int get_srch(document *document)

{
  undefined *puVar1;
  search *psVar2;
  int height;
  int x;
  int iVar3;
  int xx;
  int *piVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int width;
  uint *puVar10;
  int local_2c;
  int local_28;
  int local_24;
  
  if (assert_failed == 0) {
    if ((document == (document *)0x0) || (document->nsearch != 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x99;
      elinks_internal((uchar *)"assertion document && document->nsearch == 0 failed!");
      if (assert_failed != 0) goto LAB_080f91a6;
    }
    else {
      assert_failed = 0;
    }
    for (puVar1 = (undefined *)(document->nodes).prev;
        (list_head_elinks *)puVar1 != &document->nodes; puVar1 = *(undefined **)(puVar1 + 4)) {
      local_28 = *(int *)(puVar1 + 0xc);
      iVar3 = document->height;
      if (*(int *)(puVar1 + 0x14) + local_28 <= document->height) {
        iVar3 = *(int *)(puVar1 + 0x14) + local_28;
      }
      if (local_28 < iVar3) {
        local_24 = local_28 << 3;
        do {
          piVar4 = (int *)((int)&document->data->chars + local_24);
          iVar7 = *(int *)(puVar1 + 8);
          iVar8 = piVar4[1];
          if (*(int *)(puVar1 + 0x10) + iVar7 <= iVar8) {
            iVar8 = *(int *)(puVar1 + 0x10) + iVar7;
          }
          if (iVar7 < iVar8) {
            iVar9 = *piVar4;
            uVar5 = *(uint *)(iVar9 + iVar7 * 8);
            if (0x20 < uVar5) {
LAB_080f9282:
              do {
                if (((*(byte *)(iVar9 + 4 + iVar7 * 8) & 1) == 0) && (uVar5 != 0xfffffffd)) {
                  if (uVar5 < 0x21) {
                    iVar6 = iVar7 + 1;
                    if (iVar6 < iVar8) {
                      uVar5 = *(uint *)(iVar9 + iVar6 * 8);
                      puVar10 = (uint *)(iVar9 + 0x10 + iVar7 * 8);
                      while (uVar5 < 0x20) {
                        iVar6 = iVar6 + 1;
                        if (iVar8 <= iVar6) goto LAB_080f9376;
                        uVar5 = *puVar10;
                        puVar10 = puVar10 + 2;
                      }
                      local_2c = iVar6 - iVar7;
                    }
                    else {
LAB_080f9376:
                      local_2c = 0;
                    }
                    if (assert_failed == 0) {
                      assert_failed = 0;
                      iVar9 = document->nsearch;
                      if (iVar9 != 0) {
                        psVar2 = document->search;
                        if (psVar2 != (search *)0x0) {
                          if (psVar2[iVar9 + -1].c == 0x20) goto LAB_080f925e;
                          psVar2[iVar9].c = 0x20;
                          document->search[iVar9].x = iVar7;
                          document->search[iVar9].y = local_28;
                          document->search[iVar9].n = local_2c;
                          iVar9 = document->nsearch;
                        }
                        document->nsearch = iVar9 + 1;
                      }
                    }
                    else {
                      assert_failed = 0;
                    }
LAB_080f925e:
                    iVar7 = iVar6 + -1;
                  }
                  else if (assert_failed == 0) {
                    assert_failed = 0;
                    if (document->search != (search *)0x0) {
                      iVar9 = document->nsearch;
                      document->search[iVar9].c = uVar5;
                      document->search[iVar9].x = iVar7;
                      document->search[iVar9].y = local_28;
                      document->search[iVar9].n = 1;
                    }
                    document->nsearch = document->nsearch + 1;
                  }
                  else {
                    assert_failed = 0;
                  }
                }
                iVar7 = iVar7 + 1;
                if (iVar8 <= iVar7) goto LAB_080f9105;
                iVar9 = *(int *)((int)&document->data->chars + local_24);
                uVar5 = *(uint *)(iVar9 + iVar7 * 8);
              } while( true );
            }
            iVar7 = iVar7 + 1;
            puVar10 = (uint *)(iVar9 + iVar7 * 8);
            for (; iVar7 < iVar8; iVar7 = iVar7 + 1) {
              uVar5 = *puVar10;
              puVar10 = puVar10 + 2;
              if (0x20 < uVar5) goto LAB_080f9282;
            }
          }
LAB_080f9105:
          if (assert_failed == 0) {
            assert_failed = 0;
            iVar8 = document->nsearch;
            if (iVar8 != 0) {
              psVar2 = document->search;
              if (psVar2 != (search *)0x0) {
                if (psVar2[iVar8 + -1].c == 0x20) goto LAB_080f9176;
                psVar2[iVar8].c = 0x20;
                document->search[iVar8].x = iVar7;
                document->search[iVar8].y = local_28;
                document->search[iVar8].n = 0;
                iVar8 = document->nsearch;
              }
              document->nsearch = iVar8 + 1;
            }
          }
          else {
            assert_failed = 0;
          }
LAB_080f9176:
          local_28 = local_28 + 1;
          local_24 = local_24 + 8;
        } while (local_28 < iVar3);
      }
    }
    iVar3 = document->nsearch;
  }
  else {
LAB_080f91a6:
    assert_failed = 0;
    iVar3 = 0;
  }
  return iVar3;
}



// WARNING: Unknown calling convention

void get_search_data(document *document)

{
  int *piVar1;
  int n;
  int iVar2;
  search *psVar3;
  search **ppsVar4;
  void *p;
  void *p_00;
  int i;
  search *s;
  int iVar5;
  int iVar6;
  int iVar7;
  
  if (assert_failed == 0) {
    assert_failed = (int)(document == (document *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0xd3;
      elinks_internal((uchar *)"assertion document failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if (document->search != (search *)0x0) {
      return;
    }
    iVar2 = get_srch(document);
    if (iVar2 == 0) {
      return;
    }
    document->nsearch = 0;
    psVar3 = (search *)mem_alloc(iVar2 << 4);
    document->search = psVar3;
    if (psVar3 == (search *)0x0) {
      return;
    }
    get_srch(document);
    iVar2 = document->nsearch;
    iVar7 = (iVar2 + -1) * 0x10;
    do {
      if (iVar2 == 0) break;
      iVar2 = iVar2 + -1;
      document->nsearch = iVar2;
      piVar1 = (int *)((int)&document->search->c + iVar7);
      iVar7 = iVar7 + -0x10;
    } while (*piVar1 == 0x20);
    if (assert_failed == 0) {
      assert_failed = 0;
      ppsVar4 = (search **)mem_calloc(document->height,4);
      document->slines1 = ppsVar4;
      if (ppsVar4 == (search **)0x0) {
        return;
      }
      ppsVar4 = (search **)mem_calloc(document->height,4);
      document->slines2 = ppsVar4;
      if (ppsVar4 == (search **)0x0) {
        mem_free(document->slines1);
        return;
      }
      p = mem_calloc(document->height,4);
      if (p == (void *)0x0) {
        mem_free(document->slines1);
        mem_free(document->slines2);
        return;
      }
      p_00 = mem_calloc(document->height,4);
      if (p_00 == (void *)0x0) {
        mem_free(document->slines1);
        mem_free(document->slines2);
        mem_free(p);
        return;
      }
      iVar2 = 0;
      if (0 < document->height) {
        do {
          *(undefined4 *)((int)p + iVar2 * 4) = 0x7fffffff;
          *(undefined4 *)((int)p_00 + iVar2 * 4) = 0;
          iVar2 = iVar2 + 1;
        } while (iVar2 < document->height);
      }
      if (0 < document->nsearch) {
        iVar2 = 0;
        do {
          psVar3 = document->search + iVar2;
          iVar7 = psVar3->x;
          iVar5 = psVar3->n + iVar7;
          iVar6 = psVar3->y * 4;
          if (iVar7 < *(int *)((int)p + iVar6)) {
            *(int *)((int)p + iVar6) = iVar7;
            document->slines1[psVar3->y] = psVar3;
            iVar6 = psVar3->y << 2;
          }
          if (*(int *)(iVar6 + (int)p_00) < iVar5) {
            *(int *)(iVar6 + (int)p_00) = iVar5;
            document->slines2[psVar3->y] = psVar3;
          }
          iVar2 = iVar2 + 1;
        } while (iVar2 < document->nsearch);
      }
      mem_free(p);
      mem_free(p_00);
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void get_searched(document_view *doc_view,point **pt,int *pl,int utf8)

{
  uchar *puVar1;
  list_head_elinks *plVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  int l;
  int iVar6;
  option_value *poVar7;
  int y;
  wint_t wVar8;
  int iVar9;
  uint uVar10;
  uint uVar11;
  int iVar12;
  unicode_val_T uVar13;
  __int32_t **pp_Var14;
  size_t size;
  point *ppVar15;
  int __res;
  search *psVar16;
  int sx;
  int iVar17;
  int j;
  int iVar18;
  int len;
  int __res_1;
  int i;
  int iVar19;
  int local_54;
  unicode_val_T *local_30;
  point *local_28;
  search *local_24;
  search *local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (pt == (point **)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (pl == (int *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x2fe;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && pt && pl failed!");
      if (assert_failed != 0) goto LAB_080f9708;
    }
    else {
      assert_failed = 0;
    }
    if (((doc_view->search_word != (uchar **)0x0) &&
        (puVar1 = *doc_view->search_word, puVar1 != (uchar *)0x0)) && (*puVar1 != '\0')) {
      get_search_data(doc_view->document);
      l = strlen_u(*doc_view->search_word,utf8);
      iVar6 = get_range(doc_view->document,doc_view->vs->y,(doc_view->box).height,l,local_20,
                        &local_24);
      if (iVar6 != 0) {
        *pt = (point *)0x0;
        *pl = 0;
        return;
      }
      local_28 = (point *)0x0;
      poVar7 = get_opt_();
      plVar2 = poVar7->tree;
      if (plVar2 == (list_head_elinks *)0x0) {
        local_30 = lowered_string(*doc_view->search_word,l,utf8);
      }
      else {
        local_30 = memacpy_u(*doc_view->search_word,l,utf8);
      }
      if (local_30 != (unicode_val_T *)0x0) {
        iVar18 = 0;
        iVar6 = (doc_view->box).x;
        iVar3 = doc_view->vs->x;
        iVar4 = (doc_view->box).y;
        iVar5 = doc_view->vs->y;
        if (local_24 < local_20[0]) {
LAB_080f9920:
          mem_free(local_30);
          *pt = local_28;
          *pl = iVar18;
          return;
        }
        iVar18 = 0;
        if (plVar2 == (list_head_elinks *)0x0) goto LAB_080f97e1;
        iVar18 = 0;
LAB_080f97c0:
        uVar13 = local_20[0]->c;
LAB_080f97c3:
        if (*local_30 == uVar13) goto LAB_080f97fe;
LAB_080f97cc:
        do {
          local_20[0] = local_20[0] + 1;
          if (local_24 < local_20[0]) goto LAB_080f9920;
          if (plVar2 != (list_head_elinks *)0x0) goto LAB_080f97c0;
LAB_080f97e1:
          if (utf8 == 0) goto LAB_080f98d8;
          wVar8 = towlower(local_20[0]->c);
          if (*local_30 == wVar8) {
LAB_080f97fe:
            if (l < 2) {
              if (l < 1) goto LAB_080f97cc;
            }
            else {
              iVar19 = 1;
              psVar16 = local_20[0];
              do {
                if (plVar2 == (list_head_elinks *)0x0) {
                  if (utf8 == 0) {
                    uVar13 = psVar16[1].c;
                    if (uVar13 + 0x80 < 0x180) {
                      pp_Var14 = __ctype_tolower_loc();
                      uVar13 = (*pp_Var14)[uVar13];
                    }
                  }
                  else {
                    uVar13 = towlower(psVar16[1].c);
                  }
                }
                else {
                  uVar13 = psVar16[1].c;
                }
                if (local_30[iVar19] != uVar13) goto LAB_080f97cc;
                iVar19 = iVar19 + 1;
                psVar16 = psVar16 + 1;
              } while (iVar19 < l);
            }
            local_54 = 0;
            psVar16 = local_20[0];
            do {
              iVar9 = (iVar4 - iVar5) + psVar16->y;
              iVar19 = (doc_view->box).y;
              if (((iVar19 <= iVar9) && (iVar9 < iVar19 + (doc_view->box).height)) &&
                 (0 < psVar16->n)) {
                iVar19 = 0;
                do {
                  iVar17 = psVar16->x + iVar19;
                  iVar12 = (iVar6 - iVar3) + iVar17;
                  iVar9 = (doc_view->box).x;
                  if ((iVar9 <= iVar12) && (iVar12 < iVar9 + (doc_view->box).width)) {
                    uVar10 = iVar18 + 0x100U & 0xffffff00;
                    uVar11 = iVar18 + 0xffU & 0xffffff00;
                    if (uVar11 < uVar10) {
                      size = uVar10 * 8;
                      ppVar15 = (point *)mem_realloc(local_28,size);
                      if (ppVar15 == (point *)0x0) goto LAB_080f98ae;
                      memset(ppVar15 + uVar11,0,size + uVar11 * -8);
                      local_28 = ppVar15;
                    }
                    if (local_28 != (point *)0x0) {
                      local_28[iVar18].x = iVar17;
                      local_28[iVar18].y = psVar16->y;
                      iVar18 = iVar18 + 1;
                    }
                  }
LAB_080f98ae:
                  iVar19 = iVar19 + 1;
                } while (iVar19 < psVar16->n);
              }
              local_54 = local_54 + 1;
              psVar16 = psVar16 + 1;
            } while (local_54 < l);
          }
        } while( true );
      }
    }
  }
  else {
LAB_080f9708:
    assert_failed = 0;
  }
  return;
LAB_080f98d8:
  uVar13 = local_20[0]->c;
  if (uVar13 + 0x80 < 0x180) {
    pp_Var14 = __ctype_tolower_loc();
    uVar13 = (*pp_Var14)[uVar13];
  }
  goto LAB_080f97c3;
}



// WARNING: Unknown calling convention

int find_next_link_in_search(document_view *doc_view,int direction)

{
  point *ppVar1;
  byte bVar2;
  link *plVar3;
  point *ppVar4;
  point *ppVar5;
  int iVar6;
  point *ppVar7;
  int iVar8;
  int j;
  int iVar9;
  int iVar10;
  int i;
  link *link;
  undefined4 *puVar11;
  byte bVar12;
  int local_34;
  int local_24;
  point *local_20 [4];
  
  bVar12 = 0;
  bVar2 = (doc_view->document->options).field_0x5c;
  if (assert_failed == 0) {
    if (doc_view->vs == (view_state *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x3be;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080f9c10;
    }
    else {
      assert_failed = 0;
    }
    if ((direction != 2) && (local_34 = direction, direction != -2)) goto LAB_080f9c3e;
    local_34 = direction / 2;
    if (local_34 < 0) {
      find_link_page_up(doc_view);
    }
    else {
      find_link_page_down(doc_view);
    }
    iVar10 = doc_view->vs->current_link;
    iVar8 = 1;
    if (iVar10 != -1) {
      do {
        plVar3 = doc_view->document->links;
        get_searched(doc_view,local_20,&local_24,(uint)(bVar2 >> 4 & 1));
        ppVar7 = local_20[0];
        iVar6 = local_24;
        iVar8 = plVar3[iVar10].npoints;
        ppVar4 = plVar3[iVar10].points;
        if (assert_failed == 0) {
          assert_failed = (int)(ppVar4 == (point *)0x0);
          if (assert_failed != 0) {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
            errline = 0x394;
            elinks_internal((uchar *)"assertion p2 failed!");
            if (assert_failed != 0) goto LAB_080f9c28;
          }
          if (point_intersect::first_time != 0) {
            puVar11 = (undefined4 *)point_intersect::hash;
            for (iVar10 = 0x400; iVar10 != 0; iVar10 = iVar10 + -1) {
              *puVar11 = 0;
              puVar11 = puVar11 + (uint)bVar12 * -2 + 1;
            }
            point_intersect::first_time = 0;
          }
          if (0 < iVar6) {
            iVar10 = 0;
            do {
              ppVar5 = ppVar7 + iVar10;
              ppVar1 = ppVar7 + iVar10;
              iVar10 = iVar10 + 1;
              point_intersect::hash[ppVar5->y * 0x40 + ppVar1->x & 0xfff] = '\x01';
            } while (iVar10 != iVar6);
          }
          if (0 < iVar8) {
            iVar10 = 0;
            do {
              if ((point_intersect::hash[ppVar4[iVar10].y * 0x40 + ppVar4[iVar10].x & 0xfff] != '\0'
                  ) && (0 < iVar6)) {
                iVar9 = 0;
                do {
                  if ((ppVar4[iVar10].x == ppVar7[iVar9].x) && (ppVar4[iVar10].y == ppVar7[iVar9].y)
                     ) {
                    iVar8 = 0;
                    do {
                      ppVar1 = ppVar7 + iVar8;
                      ppVar4 = ppVar7 + iVar8;
                      iVar8 = iVar8 + 1;
                      point_intersect::hash[ppVar1->y * 0x40 + ppVar4->x & 0xfff] = '\0';
                    } while (iVar8 != iVar6);
                    mem_free(local_20[0]);
                    return 0;
                  }
                  iVar9 = iVar9 + 1;
                } while (iVar9 < iVar6);
              }
              iVar10 = iVar10 + 1;
            } while (iVar10 < iVar8);
          }
          iVar8 = 0;
          if (0 < iVar6) {
            do {
              ppVar1 = ppVar7 + iVar8;
              ppVar4 = ppVar7 + iVar8;
              iVar8 = iVar8 + 1;
              point_intersect::hash[ppVar1->y * 0x40 + ppVar4->x & 0xfff] = '\0';
            } while (iVar8 != iVar6);
          }
        }
        else {
LAB_080f9c28:
          assert_failed = 0;
        }
        if (local_20[0] != (point *)0x0) {
          mem_free(local_20[0]);
        }
LAB_080f9c3e:
        iVar8 = doc_view->vs->current_link;
        if ((iVar8 == -1) ||
           (iVar8 = next_link_in_view(doc_view,iVar8 + local_34,local_34), iVar8 == 0)) {
          if (local_34 < 0) {
            find_link_page_up(doc_view);
            return 1;
          }
          find_link_page_down(doc_view);
          return 1;
        }
        local_20[0] = (point *)0x0;
        iVar10 = doc_view->vs->current_link;
      } while( true );
    }
  }
  else {
LAB_080f9c10:
    assert_failed = 0;
    iVar8 = 0;
  }
  return iVar8;
}



// WARNING: Unknown calling convention

void draw_searched(terminal *term,document_view *doc_view)

{
  uchar *puVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  void *p;
  color_pair *color_00;
  color_pair *color;
  int i;
  int iVar6;
  int iVar7;
  int xoffset;
  int local_24;
  point *local_20 [4];
  
  if (assert_failed == 0) {
    assert_failed = (int)(doc_view == (document_view *)0x0 || term == (terminal *)0x0);
    local_20[0] = (point *)0x0;
    local_24 = 0;
    if (doc_view == (document_view *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x31e;
      elinks_internal((uchar *)"assertion term && doc_view failed!");
      if (assert_failed != 0) goto LAB_080f9e30;
    }
    if (((doc_view->search_word != (uchar **)0x0) &&
        (puVar1 = *doc_view->search_word, puVar1 != (uchar *)0x0)) && (*puVar1 != '\0')) {
      get_searched(doc_view,local_20,&local_24,
                   (byte)(doc_view->document->options).field_0x5c >> 4 & 1);
      if (local_24 != 0) {
        color_00 = get_bfu_color(term,"searched");
        iVar2 = (doc_view->box).x;
        iVar3 = (doc_view->box).y;
        iVar4 = doc_view->vs->x;
        iVar5 = doc_view->vs->y;
        if (0 < local_24) {
          iVar6 = 0;
          do {
            iVar7 = iVar6 + 1;
            draw_char_color(term,(iVar2 - iVar4) + local_20[0][iVar6].x,
                            (iVar3 - iVar5) + local_20[0][iVar6].y,color_00);
            iVar6 = iVar7;
          } while (iVar7 < local_24);
        }
      }
      if (local_20[0] != (point *)0x0) {
        mem_free(local_20[0]);
      }
    }
  }
  else {
LAB_080f9e30:
    assert_failed = 0;
  }
  return;
}



// WARNING: Type propagation algorithm not settling
// WARNING: Unknown calling convention

find_error find_next_do(session *ses,document_view *doc_view,int direction)

{
  int iVar1;
  list_head_elinks *plVar2;
  unicode_val_T uVar3;
  int iVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  search *psVar8;
  byte bVar9;
  int iVar10;
  int iVar11;
  option_value *poVar12;
  unicode_val_T *p_00;
  unicode_val_T uVar13;
  int iVar14;
  wint_t wVar15;
  __int32_t **pp_Var16;
  uchar *puVar17;
  int direction_00;
  int i;
  int iVar18;
  uint utf8;
  int __res;
  search *psVar19;
  search *psVar20;
  document *document;
  int max;
  search *psVar21;
  int height;
  int iVar22;
  int p;
  int min;
  int local_74;
  int local_44;
  int local_34;
  search *local_24;
  search *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FIND_ERROR_NONE;
  }
  if (((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) ||
       (doc_view == (document_view *)0x0)) ||
      ((ses->tab->term == (terminal *)0x0 || (direction == 0)))) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x3ed;
    elinks_internal((uchar *)
                    "assertion ses && ses->tab && ses->tab->term && doc_view && doc_view->vs && direction failed!"
                   );
    if (assert_failed != 0) {
      assert_failed = 0;
      return FIND_ERROR_NONE;
    }
  }
  else {
    assert_failed = 0;
  }
  direction_00 = direction * ses->search_direction;
  local_34 = doc_view->vs->y;
  iVar1 = (doc_view->box).height;
  if (ses->search_word != (uchar *)0x0) {
    iVar10 = find_next_link_in_search(doc_view,direction_00);
    if (iVar10 == 0) {
      return FIND_ERROR_NONE;
    }
    local_34 = local_34 + direction_00 * iVar1;
    if (ses->search_word != (uchar *)0x0) goto LAB_080f9f98;
  }
  if (ses->last_search_word == (uchar *)0x0) {
    return FIND_ERROR_NO_PREVIOUS_SEARCH;
  }
  puVar17 = stracpy(ses->last_search_word);
  ses->search_word = puVar17;
  if (puVar17 == (uchar *)0x0) {
    return FIND_ERROR_NONE;
  }
LAB_080f9f98:
  get_search_data(doc_view->document);
  document = doc_view->document;
  bVar6 = false;
  bVar7 = false;
  local_44 = 0;
  do {
    puVar17 = ses->search_word;
    if (assert_failed != 0) {
      assert_failed = 0;
      return FIND_ERROR_MEMORY;
    }
    if ((document == (document *)0x0) || (puVar17 == (uchar *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 599;
      elinks_internal((uchar *)"assertion document && text && min && max failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return FIND_ERROR_MEMORY;
      }
    }
    else {
      assert_failed = 0;
    }
    bVar9 = (byte)(document->options).field_0x5c >> 4;
    utf8 = bVar9 & 1;
    iVar10 = strlen_u(puVar17,utf8);
    iVar11 = get_range(document,local_34,iVar1,iVar10,local_20,&local_24);
    psVar21 = local_20[0];
    psVar8 = local_24;
    if (iVar11 == 0) {
      poVar12 = get_opt_();
      plVar2 = poVar12->tree;
      if (plVar2 == (list_head_elinks *)0x0) {
        p_00 = lowered_string(puVar17,iVar10,utf8);
      }
      else {
        p_00 = memacpy_u(puVar17,iVar10,utf8);
      }
      if (p_00 == (unicode_val_T *)0x0) {
        return FIND_ERROR_MEMORY;
      }
      if (psVar21 <= psVar8) {
        uVar3 = *p_00;
        local_74 = 0x7fffffff;
        bVar5 = false;
        iVar11 = 0;
        if (plVar2 == (list_head_elinks *)0x0) goto LAB_080fa16c;
        do {
          uVar13 = psVar21->c;
joined_r0x080fa156:
          if (uVar13 == uVar3) {
            iVar18 = 1;
            iVar14 = 0x10;
            psVar19 = psVar21;
            if (1 < iVar10) {
              do {
                if (plVar2 == (list_head_elinks *)0x0) {
                  if ((bVar9 & 1) == 0) {
                    uVar13 = psVar19[1].c;
                    if (uVar13 + 0x80 < 0x180) {
                      pp_Var16 = __ctype_tolower_loc();
                      uVar13 = (*pp_Var16)[uVar13];
                    }
                    goto LAB_080fa1a3;
                  }
                  wVar15 = towlower(psVar19[1].c);
                  if (p_00[iVar18] != wVar15) goto LAB_080fa15a;
                }
                else {
                  uVar13 = psVar19[1].c;
LAB_080fa1a3:
                  if (p_00[iVar18] != uVar13) goto LAB_080fa15a;
                }
                iVar18 = iVar18 + 1;
                psVar19 = psVar19 + 1;
              } while (iVar18 < iVar10);
              iVar14 = iVar18 * 0x10;
            }
            iVar14 = *(int *)((int)&psVar21->y + iVar14);
            if ((local_34 <= iVar14) && (iVar14 < local_34 + iVar1)) {
              iVar14 = 0;
              bVar5 = true;
              if (0 < iVar10) {
                iVar18 = psVar21->n;
                psVar19 = psVar21;
                iVar22 = iVar11;
                if (iVar18 == 0) goto LAB_080fa27e;
                do {
                  iVar4 = psVar19->x;
                  iVar11 = iVar4 + iVar18;
                  if (iVar4 < local_74) {
                    local_74 = iVar4;
                  }
                  psVar20 = psVar19;
                  if (iVar11 <= iVar22) goto LAB_080fa27e;
                  while( true ) {
                    iVar14 = iVar14 + 1;
                    psVar19 = psVar20 + 1;
                    if (iVar14 == iVar10) {
                      bVar5 = true;
                      goto LAB_080fa15a;
                    }
                    iVar18 = psVar20[1].n;
                    iVar22 = iVar11;
                    if (iVar18 != 0) break;
LAB_080fa27e:
                    iVar11 = iVar22;
                    psVar20 = psVar19;
                  }
                } while( true );
              }
            }
          }
LAB_080fa15a:
          psVar21 = psVar21 + 1;
          if (psVar8 < psVar21) {
            mem_free(p_00);
            if (bVar5) {
              doc_view->vs->y = local_34;
              if (local_74 <= iVar11) {
                iVar11 = iVar11 - (doc_view->box).width;
                iVar1 = doc_view->vs->x;
                if (iVar11 < iVar1) {
                  iVar11 = iVar1;
                }
                if (local_74 < iVar11) {
                  iVar11 = local_74;
                }
                doc_view->vs->x = iVar11;
              }
              set_link(doc_view);
              find_next_link_in_search(doc_view,direction_00 * 2);
              if (!bVar6) {
                if (!bVar7) {
                  return FIND_ERROR_NONE;
                }
                return FIND_ERROR_HIT_BOTTOM;
              }
              return FIND_ERROR_HIT_TOP;
            }
            goto LAB_080fa060;
          }
        } while (plVar2 != (list_head_elinks *)0x0);
LAB_080fa16c:
        if ((bVar9 & 1) == 0) {
          uVar13 = psVar21->c;
          if (uVar13 + 0x80 < 0x180) {
            pp_Var16 = __ctype_tolower_loc();
            uVar13 = (*pp_Var16)[uVar13];
          }
        }
        else {
          uVar13 = towlower(psVar21->c);
        }
        goto joined_r0x080fa156;
      }
      mem_free(p_00);
    }
LAB_080fa060:
    local_34 = local_34 + direction_00 * iVar1;
    document = doc_view->document;
    iVar10 = document->height;
    if (iVar10 < local_34) {
      bVar7 = true;
      local_34 = 0;
    }
    else if (local_34 < 0) {
      local_34 = 0;
      iVar11 = iVar1;
      if (0 < iVar10) {
        do {
          local_34 = iVar11;
          iVar11 = local_34 + iVar1;
        } while ((local_34 + iVar1) - iVar1 < iVar10);
      }
      local_34 = local_34 - iVar1;
      bVar6 = true;
    }
    local_44 = local_44 + iVar1;
    if (iVar10 + iVar1 <= local_44) {
      return FIND_ERROR_NOT_FOUND;
    }
  } while( true );
}



// WARNING: Unknown calling convention

find_error search_for_do(session *ses,uchar *str,int direction,int report_errors)

{
  document_view *doc_view_00;
  uchar *puVar1;
  find_error find_error;
  find_error error;
  document_view *doc_view;
  
  if (assert_failed == 0) {
    assert_failed = (int)(str == (uchar *)0x0 || ses == (session *)0x0);
    if (str == (uchar *)0x0 || ses == (session *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 0x35a;
      elinks_internal((uchar *)"assertion ses && str failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return FIND_ERROR_NOT_FOUND;
      }
    }
    doc_view_00 = current_frame(ses);
    if (assert_failed == 0) {
      assert_failed = (int)(doc_view_00 == (document_view *)0x0);
      if (assert_failed != 0) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
        errline = 0x35f;
        elinks_internal((uchar *)"assertion doc_view failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return FIND_ERROR_NOT_FOUND;
        }
      }
      if (ses->search_word != (uchar *)0x0) {
        mem_free(ses->search_word);
      }
      ses->search_word = (uchar *)0x0;
      if (ses->last_search_word != (uchar *)0x0) {
        mem_free(ses->last_search_word);
      }
      ses->last_search_word = (uchar *)0x0;
      if (*str != '\0') {
        puVar1 = stracpy(str);
        ses->last_search_word = puVar1;
        if (puVar1 != (uchar *)0x0) {
          ses->search_direction = direction;
          find_error = find_next_do(ses,doc_view_00,1);
          if (report_errors != 0) {
            print_find_error(ses,find_error);
            return find_error;
          }
          return find_error;
        }
      }
      return FIND_ERROR_NOT_FOUND;
    }
  }
  assert_failed = 0;
  return FIND_ERROR_NOT_FOUND;
}



// WARNING: Unknown calling convention

void search_for_back(session *ses,uchar *str)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(str == (uchar *)0x0 || ses == (session *)0x0);
  if (str == (uchar *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x37a;
    elinks_internal((uchar *)"assertion ses && str failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  search_for_do(ses,str,-1,1);
  return;
}



// WARNING: Unknown calling convention

void search_for(session *ses,uchar *str)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(str == (uchar *)0x0 || ses == (session *)0x0);
  if (str == (uchar *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 899;
    elinks_internal((uchar *)"assertion ses && str failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  search_for_do(ses,str,1,1);
  return;
}



// WARNING: Unknown calling convention

frame_event_status find_next(session *ses,document_view *doc_view,int direction)

{
  find_error find_error;
  
  find_error = find_next_do(ses,doc_view,direction);
  print_find_error(ses,find_error);
  return FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

input_line_code text_typeahead_handler(input_line *line,int action_id)

{
  int direction_00;
  session *ses_00;
  document_view *doc_view_00;
  document_view *doc_view;
  find_error find_error;
  find_error error;
  option_elinks *option_elinks;
  option_elinks *opt;
  int direction;
  session *ses;
  
  ses_00 = line->ses;
  doc_view_00 = current_frame(ses_00);
                    // WARNING: Load size is inaccurate
  direction_00 = (uint)(*line->data == '/') * 2 + -1;
  if (assert_failed != 0) {
    assert_failed = 0;
    return INPUT_LINE_CANCEL;
  }
  assert_failed = (int)(doc_view_00 == (document_view *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x57b;
    elinks_internal((uchar *)"assertion doc_view != NULL failed: document not formatted");
    if (assert_failed != 0) {
      assert_failed = 0;
      return INPUT_LINE_CANCEL;
    }
  }
  switch(action_id) {
  case 0xe:
    if (line->buffer[0] == '\0') {
      search_for_do(ses_00,line->buffer,direction_00,0);
      return INPUT_LINE_CANCEL;
    }
    return INPUT_LINE_CANCEL;
  case 0x16:
    find_next(ses_00,doc_view_00,1);
    break;
  case 0x19:
    find_next(ses_00,doc_view_00,-1);
    break;
  case 0x1a:
    goto switchD_080fa820_caseD_1a;
  case 0x1c:
    option_elinks = get_opt_rec(config_options,(uchar *)"document.browse.search.regex");
    if (option_elinks != (option_elinks *)0x0) {
      (option_elinks->value).number =
           (int)((int)&((option_elinks->value).tree)->next + 1) % (option_elinks->max + 1);
      option_changed(ses_00,option_elinks);
    }
  default:
    find_error = search_for_do(ses_00,line->buffer,direction_00,0);
    if (find_error != FIND_ERROR_REGEX) {
      if (action_id == -1) {
        print_find_error(ses_00,find_error);
      }
      if (((1 < find_error + ~FIND_ERROR_NO_PREVIOUS_SEARCH) && (find_error != FIND_ERROR_NONE)) &&
         (line->buffer[0] != '\0')) {
        return INPUT_LINE_REWIND;
      }
    }
  }
  draw_formatted(ses_00,0);
switchD_080fa820_caseD_1a:
  return INPUT_LINE_PROCEED;
}



// WARNING: Unknown calling convention

frame_event_status search_dlg(session *ses,document_view *doc_view,int direction)

{
  terminal *term;
  code *data;
  int iVar1;
  int new_charset_5;
  uchar *puVar2;
  session **p;
  option_elinks *root;
  option_elinks *search_options;
  dialog *dlg_00;
  dialog *dlg;
  int new_charset_4;
  uchar *codeset;
  int new_charset_3;
  int new_charset_2;
  int new_charset_1;
  int new_charset;
  option_value *values;
  char *msgid;
  uchar *title;
  memory_list *local_20 [4];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  assert_failed = (int)(direction == 0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 0x6bd;
    elinks_internal((uchar *)"assertion direction failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  msgid = "Search";
  if (direction < 1) {
    msgid = "Search backward";
  }
  data = search_for_back;
  if (0 < direction) {
    data = search_for;
  }
  term = ses->tab->term;
  local_20[0] = (memory_list *)0x0;
  if ((term != (terminal *)0x0) && (iVar1 = get_terminal_codepage(term), iVar1 != current_charset))
  {
    puVar2 = get_cp_mime_name(iVar1);
    bind_textdomain_codeset("elinks",puVar2);
    current_charset = iVar1;
  }
  puVar2 = gettext((uchar *)"Search for text");
  p = (session **)mem_calloc(1,8);
  if (p != (session **)0x0) {
    root = get_opt_rec(config_options,(uchar *)"document.browse.search");
    values = (option_value *)(p + 1);
    checkout_option_values(resolvers,root,values,1);
    *p = ses;
    dlg_00 = (dialog *)mem_calloc(1,0x514);
    if (dlg_00 == (dialog *)0x0) {
      mem_free(p);
    }
    else {
      if (*msgid != '\0') {
        if ((term != (terminal *)0x0) &&
           (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
          codeset = get_cp_mime_name(iVar1);
          bind_textdomain_codeset("elinks",codeset);
          current_charset = iVar1;
        }
        msgid = (char *)gettext((uchar *)msgid);
      }
      *(byte *)&dlg_00->layout = *(byte *)&dlg_00->layout | 0xc;
      dlg_00->title = (uchar *)msgid;
      dlg_00->layouter = generic_dialog_layouter;
      dlg_00->udata = puVar2;
      dlg_00->udata2 = p;
      add_to_ml(local_20,p,0);
      add_dlg_field_do(dlg_00,WIDGET_FIELD,puVar2,0,0,(widget_handler_T *)0x0,0x400,&dlg_00[3].abort
                       ,&search_history,INPFIELD_NONE);
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"Case sensitive");
      add_dlg_radio_do(dlg_00,puVar2,2,1,&values->number);
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"Case insensitive");
      add_dlg_radio_do(dlg_00,puVar2,2,0,&values->number);
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext("~OK");
      add_dlg_button_do(dlg_00,puVar2,1,search_dlg_ok,data,(done_handler_T *)0x0,(void *)0x0);
      if ((term != (terminal *)0x0) &&
         (iVar1 = get_terminal_codepage(term), iVar1 != current_charset)) {
        puVar2 = get_cp_mime_name(iVar1);
        bind_textdomain_codeset("elinks",puVar2);
        current_charset = iVar1;
      }
      puVar2 = gettext((uchar *)"~Cancel");
      add_dlg_button_do(dlg_00,puVar2,2,search_dlg_cancel,(void *)0x0,(done_handler_T *)0x0,
                        (void *)0x0);
      if ((assert_failed == 0) &&
         (assert_failed = (int)(dlg_00->number_of_widgets != 5), assert_failed != 0)) {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
        errline = 0x6b1;
        elinks_internal((uchar *)"assertion 5 == (dlg)->number_of_widgets failed!");
      }
      add_to_ml(local_20,dlg_00,0);
      do_dialog(term,dlg_00,local_20[0]);
    }
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

int get_textarea_line_number(line_info *line,int cursor_position)

{
  int iVar1;
  int idx;
  int iVar2;
  line_info *plVar3;
  line_info *local_14;
  
  iVar1 = line->start;
  if (iVar1 != -1) {
    iVar2 = 0;
    plVar3 = line;
    local_14 = line + 1;
    do {
      if ((iVar1 <= cursor_position) &&
         (cursor_position < (int)((uint)(line[iVar2 + 1].start != plVar3->end) + plVar3->end))) {
        return iVar2;
      }
      iVar2 = iVar2 + 1;
      iVar1 = local_14->start;
      plVar3 = local_14;
      local_14 = local_14 + 1;
    } while (iVar1 != -1);
  }
  return -1;
}



// WARNING: Unknown calling convention

int do_op_home(form_state *fs,line_info *line,int current,int utf8)

{
  if (current != -1) {
    if (utf8 != 0) {
      fs->state = line[current - (uint)(fs->state_cell != 0)].start;
      return 0;
    }
    fs->state = line[current].start;
  }
  return 0;
}



// WARNING: Unknown calling convention

int do_op_bob(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  
  if (current != -1) {
    iVar1 = fs->state - line[current].start;
    fs->state = iVar1;
    if (line->end < iVar1) {
      fs->state = line->end;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int do_op_eob(form_state *fs,line_info *line,int current,int utf8)

{
  size_t sVar1;
  int iVar2;
  int last;
  int iVar3;
  
  if (current == -1) {
    sVar1 = strlen((char *)fs->value);
    fs->state = sVar1;
  }
  else {
    sVar1 = strlen((char *)fs->value);
    iVar2 = get_textarea_line_number(line,sVar1);
    if ((assert_failed == 0) && (assert_failed = (int)(iVar2 == -1), assert_failed != 0)) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x3da;
      elinks_internal((uchar *)"assertion last != -1 failed: line info corrupt");
    }
    iVar3 = (line[iVar2].start + fs->state) - line[current].start;
    fs->state = iVar3;
    iVar2 = line[iVar2].end;
    if (iVar2 < iVar3) {
      fs->state = iVar2;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int do_op_right(form_state *fs,line_info *line,int current,int utf8)

{
  size_t sVar1;
  uchar *end;
  int iVar2;
  size_t sVar3;
  int old_state;
  int iVar4;
  uchar *local_20 [4];
  
  if (utf8 == 0) {
    sVar1 = strlen((char *)fs->value);
    sVar3 = fs->state + 1;
    if ((int)sVar1 <= (int)sVar3) {
      sVar3 = sVar1;
    }
    fs->state = sVar3;
    return 0;
  }
  if (fs->state_cell == 0) {
    local_20[0] = fs->value + fs->state;
    end = (uchar *)__rawmemchr(local_20[0],0);
    iVar4 = fs->state;
    utf8_to_unicode(local_20,end);
    iVar2 = (int)local_20[0] - (int)fs->value;
    fs->state = iVar2;
    if (iVar4 == iVar2) {
      if ((line[current].field_0xc & 2) != 0) {
        return 0;
      }
    }
    else if ((line[current].field_0xc & 2) != 0) {
      if (iVar2 != line[current].end) {
        iVar4 = 0;
      }
      fs->state_cell = iVar4;
      return 0;
    }
  }
  fs->state_cell = 0;
  return 0;
}



// WARNING: Unknown calling convention

int do_op_left(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  int new_state;
  uchar *puVar2;
  int iVar3;
  int old_state;
  
  if (utf8 == 0) {
    iVar3 = fs->state + -1;
    iVar1 = 0;
    if (-1 < iVar3) {
      iVar1 = iVar3;
    }
    fs->state = iVar1;
  }
  else {
    if (fs->state_cell != 0) {
      fs->state = fs->state_cell;
      fs->state_cell = 0;
      return 0;
    }
    iVar1 = fs->state;
    puVar2 = utf8_prevchar(fs->value + iVar1,1,fs->value);
    iVar3 = (int)puVar2 - (int)fs->value;
    if (iVar1 != iVar3) {
      if ((line[current].start != iVar1) || ((line[current].field_0xc & 1) == 0)) {
        fs->state = iVar3;
        return 0;
      }
      fs->state_cell = iVar3;
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int do_op_end(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  size_t sVar2;
  uchar *puVar3;
  int iVar4;
  
  if (current == -1) {
    sVar2 = strlen((char *)fs->value);
    fs->state = sVar2;
    return 0;
  }
  if (utf8 != 0) {
    iVar1 = current - (uint)(fs->state_cell != 0);
    iVar4 = line[iVar1].end;
    fs->state = iVar4;
    if ((line[iVar1].field_0xc & 2) == 0) {
      fs->state_cell = 0;
    }
    else {
      puVar3 = utf8_prevchar(fs->value + iVar4,1,fs->value);
      fs->state_cell = (int)puVar3 - (int)fs->value;
    }
    return 0;
  }
  iVar1 = line[current].end - (uint)(line[current + 1].start == line[current].end);
  iVar4 = 0;
  if (-1 < iVar1) {
    iVar4 = iVar1;
  }
  fs->state = iVar4;
  return 0;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_enter(form_state *fs,form_control *fc,int utf8)

{
  size_t sVar1;
  uchar *puVar2;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((fs == (form_state *)0x0) || (fc == (form_control *)0x0)) || (fs->value == (uchar *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x443;
    elinks_internal((uchar *)"assertion fs && fs->value && fc failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  if (((fc->mode == FORM_MODE_NORMAL) &&
      (sVar1 = strlen((char *)fs->value), sVar1 < (uint)fc->maxlength)) &&
     (puVar2 = insert_in_string(&fs->value,fs->state,"\n",1), puVar2 != (uchar *)0x0)) {
    fs->state = fs->state + 1;
    return FRAME_EVENT_REFRESH;
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

void new_pos(form_state *fs,line_info *line,int current,int max_cells)

{
  unicode_val_T data;
  int iVar1;
  unicode_val_T c;
  uchar *puVar2;
  int iVar3;
  int cells;
  uchar *end;
  uchar *local_20 [4];
  
  puVar2 = fs->value;
  local_20[0] = puVar2 + line[current].start;
  end = puVar2 + line[current].end;
  if (0 < max_cells) {
    iVar3 = 0;
    do {
      c = utf8_to_unicode(local_20,end);
      if (c == 0xfffffffd) break;
      iVar1 = unicode_to_cell(c);
      iVar3 = iVar3 + iVar1;
    } while (iVar3 < max_cells);
    puVar2 = fs->value;
  }
  fs->state = (int)local_20[0] - (int)puVar2;
  return;
}



// WARNING: Unknown calling convention

int do_op_down(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int len;
  uchar *puVar4;
  int old_state;
  
  if (current != -1) {
    iVar1 = current + 1;
    iVar3 = fs->state_cell;
    if (line[iVar1 - (uint)(iVar3 != 0)].start == -1) {
      return 1;
    }
    if (utf8 == 0) {
      iVar3 = (line[iVar1].start + fs->state) - line[current].start;
      fs->state = iVar3;
      iVar1 = line[iVar1].end;
      if (iVar1 < iVar3) {
        fs->state = iVar1;
        return 0;
      }
    }
    else {
      iVar2 = fs->state;
      if (iVar3 == 0) {
        iVar3 = utf8_ptr2cells(fs->value + line[current].start,fs->value + iVar2);
        new_pos(fs,line,iVar1,iVar3);
      }
      else {
        iVar3 = utf8_ptr2cells(fs->value + line[current + -1].start,fs->value + iVar3);
        new_pos(fs,line,current,iVar3 + line[current + -1].last_char_width);
      }
      iVar3 = fs->state;
      if (iVar3 != iVar2) {
        if ((fs->state_cell != 0) && (iVar3 == line[iVar1].start)) {
          puVar4 = utf8_prevchar(fs->value + iVar3,1,fs->value);
          fs->state_cell = (int)puVar4 - (int)fs->value;
          return 0;
        }
        fs->state_cell = 0;
        return 0;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

int do_op_up(form_state *fs,line_info *line,int current,int utf8)

{
  int iVar1;
  int iVar2;
  int len;
  uchar *puVar3;
  int old_state;
  int current_00;
  int local_30;
  
  if (current != -1) {
    iVar2 = fs->state_cell;
    if ((uint)(iVar2 != 0) == current) {
      return 1;
    }
    if (utf8 == 0) {
      iVar1 = (line[current + -1].start + fs->state) - line[current].start;
      fs->state = iVar1;
      iVar2 = line[current + -1].end;
      if (iVar2 < iVar1) {
        fs->state = iVar2;
        return 0;
      }
    }
    else {
      iVar1 = fs->state;
      if (iVar2 == 0) {
        current_00 = current + -1;
        iVar2 = utf8_ptr2cells(fs->value + line[current].start,fs->value + iVar1);
      }
      else {
        current_00 = current + -2;
        iVar2 = utf8_ptr2cells(fs->value + line[current + -1].start,fs->value + iVar2);
        iVar2 = iVar2 + line[current + -1].last_char_width;
      }
      local_30 = current + -1;
      new_pos(fs,line,current_00,iVar2);
      iVar2 = fs->state;
      if (iVar2 != iVar1) {
        if ((fs->state_cell != 0) && (iVar2 == line[local_30].start)) {
          puVar3 = utf8_prevchar(fs->value + iVar2,1,fs->value);
          fs->state_cell = (int)puVar3 - (int)fs->value;
          return 0;
        }
        fs->state_cell = 0;
        return 0;
      }
    }
  }
  return 0;
}



// WARNING: Unknown calling convention

void textarea_edit(int op,terminal *term_,form_state *fs_,document_view *doc_view_,link *link_)

{
  uchar *__s;
  form_state *pfVar1;
  size_t sVar2;
  string *psVar3;
  option_value *poVar4;
  int __fd;
  size_t sVar5;
  form_control *pfVar6;
  uchar *puVar7;
  FILE *__s_00;
  FILE *fp;
  size_t nmemb;
  int iVar8;
  uchar *ex;
  uchar *ed;
  char *text;
  uchar *local_30;
  string file;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(1 < (uint)op);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x241;
    elinks_internal((uchar *)"assertion op == 0 || op == 1 failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  assert_failed = (int)(op != 1 && term_ == (terminal *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x243;
    elinks_internal((uchar *)"assertion op == 1 || term_ failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (op == 0) {
    poVar4 = get_opt_();
    if (poVar4->tree == (list_head_elinks *)0x0) {
      if ((term_->field_0x38 & 1) != 0) {
        if (textarea_editor != 0) {
          return;
        }
        poVar4 = get_opt_();
        puVar7 = poVar4->string;
        __s = fs_->value;
        local_30 = get_tempdir_filename((uchar *)"elinks-area-XXXXXX");
        if (local_30 == (uchar *)0x0) {
          textarea_edit::fn = (uchar *)0x0;
          return;
        }
        __fd = safe_mkstemp(local_30);
        if (__fd < 0) {
          mem_free(local_30);
          textarea_edit::fn = (uchar *)0x0;
          return;
        }
        sVar5 = strlen((char *)__s);
        if (sVar5 != 0) {
          __s_00 = fdopen(__fd,"w");
          if (__s_00 == (FILE *)0x0) {
error:
            unlink((char *)local_30);
            mem_free(local_30);
            close(__fd);
            textarea_edit::fn = (uchar *)0x0;
            return;
          }
          sVar5 = fwrite(__s,sVar5,1,__s_00);
          if (sVar5 != 1) {
            fclose(__s_00);
            goto error;
          }
          iVar8 = fclose(__s_00);
          if (iVar8 != 0) goto error;
        }
        if ((puVar7 == (uchar *)0x0) || (*puVar7 == '\0')) {
          textarea_edit::fn = local_30;
          puVar7 = (uchar *)getenv("EDITOR");
          if ((puVar7 == (uchar *)0x0) || (*puVar7 == '\0')) {
            puVar7 = "vi";
          }
          local_30 = textarea_edit::fn;
        }
        textarea_edit::fn = local_30;
        puVar7 = straconcat(puVar7,&DAT_08134f9c,local_30,0);
        if (puVar7 != (uchar *)0x0) {
          textarea_edit::fs = fs_;
          if (doc_view_ != (document_view *)0x0) {
            textarea_edit::doc_view = doc_view_;
          }
          if (link_ != (link *)0x0) {
            textarea_edit::link = link_;
            pfVar6 = (form_control *)0x0;
            if (LINK_MAP < link_->type) {
              pfVar6 = (link_->data).form_control;
            }
            textarea_edit::fc_maxlength = pfVar6->maxlength;
          }
          textarea_edit::term = term_;
          exec_on_terminal(term_,puVar7,"",TERM_EXEC_FG);
          mem_free(puVar7);
          textarea_editor = 1;
          return;
        }
        unlink((char *)textarea_edit::fn);
        goto free_and_return;
      }
      text = "You can do this only on the master terminal";
    }
    else {
      text = "You cannot launch an external editor in the anonymous mode.";
    }
    info_box(term_,0,"Error",ALIGN_CENTER,(uchar *)text);
  }
  else {
    if (op != 1) {
      return;
    }
    if (textarea_edit::fs == (form_state *)0x0) {
      return;
    }
    psVar3 = init_string(&file);
    if ((psVar3 != (string *)0x0) &&
       (psVar3 = add_file_to_string(&file,textarea_edit::fn), sVar2 = textarea_edit::fc_maxlength,
       psVar3 != (string *)0x0)) {
      if (textarea_edit::fc_maxlength < (uint)file.length) {
        file.source[textarea_edit::fc_maxlength] = '\0';
        puVar7 = msg_text(textarea_edit::term,
                          (uchar *)
                          "You have exceeded the textarea\'s size limit: your input is %d bytes, but the maximum is %u bytes.\n\nYour input has been truncated, but you can still recover the text that you entered from this file: %s"
                          ,file.length,sVar2,textarea_edit::fn);
        info_box(textarea_edit::term,MSGBOX_FREE_TEXT,(uchar *)"Warning",ALIGN_CENTER,puVar7);
      }
      else {
        unlink((char *)textarea_edit::fn);
      }
      mem_free(textarea_edit::fs->value);
      pfVar1 = textarea_edit::fs;
      textarea_edit::fs->value = file.source;
      pfVar1->state = file.length;
      if ((textarea_edit::doc_view != (document_view *)0x0) && (textarea_edit::link != (link *)0x0))
      {
        draw_form_entry(textarea_edit::term,textarea_edit::doc_view,textarea_edit::link);
      }
    }
    textarea_editor = 0;
free_and_return:
    if (textarea_edit::fn != (uchar *)0x0) {
      mem_free(textarea_edit::fn);
    }
    textarea_edit::fn = (uchar *)0x0;
    textarea_edit::fs = (form_state *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void menu_textarea_edit(terminal *term,void *xxx,void *ses_)

{
  int iVar1;
  document_view *doc_view_00;
  form_control *fc_00;
  form_control *fc;
  form_state *fs_;
  form_state *fs;
  document_view *doc_view;
  link *link_;
  link *link;
  
  if (assert_failed == 0) {
    assert_failed = (int)(ses_ == (void *)0x0 || term == (terminal *)0x0);
    if (ses_ == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x2ad;
      elinks_internal((uchar *)"assertion term && ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    doc_view_00 = current_frame((session *)ses_);
    if (assert_failed == 0) {
      if (((doc_view_00 == (document_view *)0x0) || (doc_view_00->vs == (view_state *)0x0)) ||
         (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
        errline = 0x2b2;
        elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!")
        ;
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
        if (doc_view_00 == (document_view *)0x0) {
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      iVar1 = doc_view_00->vs->current_link;
      if (iVar1 < 0) {
        return;
      }
      if (iVar1 < doc_view_00->document->nlinks) {
        link_ = doc_view_00->document->links + iVar1;
        if (link_ == (link *)0x0) {
          return;
        }
        fc_00 = (form_control *)0x0;
        if (LINK_MAP < link_->type) {
          fc_00 = (link_->data).form_control;
        }
        if (fc_00->mode == FORM_MODE_NORMAL) {
          fs_ = find_form_state(doc_view_00,fc_00);
          if (fs_ != (form_state *)0x0) {
            textarea_edit(0,term,fs_,doc_view_00,link_);
            return;
          }
          return;
        }
        return;
      }
      return;
    }
  }
  assert_failed = 0;
  return;
}



line_info * __regparm3 format_textutf8(uchar *text,int width,form_wrap wrap,int format)

{
  uchar uVar1;
  uchar *puVar2;
  size_t sVar3;
  int iVar4;
  size_t newsize;
  uint uVar5;
  size_t size;
  uint uVar6;
  int skip;
  uint uVar7;
  int char_cells;
  uchar *wrappos;
  uchar *utf8_char;
  size_t oldsize;
  int iVar8;
  int pos;
  line_info *plVar9;
  int iVar10;
  int line_number;
  uchar *data;
  bool bVar11;
  byte bVar12;
  int local_44;
  uchar *local_34;
  int local_30;
  line_info *local_20;
  
  bVar12 = 0;
  if (assert_failed == 0) {
    assert_failed = (int)(text == (uchar *)0x0);
    if (text == (uchar *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4e;
      elinks_internal((uchar *)"assertion text failed!");
      if (assert_failed != 0) goto LAB_080fbdd6;
    }
    local_20 = (line_info *)mem_realloc((void *)0x0,0x1000);
    if (local_20 != (line_info *)0x0) {
      bVar11 = ((uint)local_20 & 1) != 0;
      uVar7 = 0x1000;
      plVar9 = local_20;
      if (bVar11) {
        *(undefined *)&local_20->start = 0;
        plVar9 = (line_info *)((int)&local_20->start + 1);
        uVar7 = 0xfff;
      }
      if (((uint)plVar9 & 2) != 0) {
        *(undefined2 *)&plVar9->start = 0;
        uVar7 = uVar7 - 2;
        plVar9 = (line_info *)((int)&plVar9->start + 2);
      }
      for (uVar6 = uVar7 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
        plVar9->start = 0;
        plVar9 = (line_info *)((int)plVar9 + (uint)bVar12 * -8 + 4);
      }
      if ((uVar7 & 2) != 0) {
        *(undefined2 *)&plVar9->start = 0;
        plVar9 = (line_info *)((int)&plVar9->start + 2);
      }
      if (bVar11) {
        *(undefined *)&plVar9->start = 0;
      }
      if (local_20 != (line_info *)0x0) {
        iVar8 = 0;
        iVar10 = 0;
        sVar3 = strlen((char *)text);
        local_30 = 0;
        local_34 = (uchar *)0x0;
        local_44 = 0;
LAB_080fbc60:
        utf8_char = text + iVar8;
        uVar1 = *utf8_char;
        puVar2 = local_34;
        plVar9 = local_20;
        do {
          if (uVar1 == '\0') {
            plVar9[iVar10].field_0xc = plVar9[iVar10].field_0xc & 0xfd;
            plVar9[iVar10].start = local_44;
            plVar9[iVar10].end = iVar8;
            plVar9[iVar10 + 1].end = -1;
            plVar9[iVar10 + 1].start = -1;
            plVar9[iVar10 + 1].field_0xc = plVar9[iVar10 + 1].field_0xc & 0xfc;
            plVar9->field_0xc = plVar9->field_0xc & 0xfe;
            return plVar9;
          }
          iVar4 = utf8_char2cells(utf8_char,text + sVar3);
          local_34 = utf8_char;
          local_20 = plVar9;
          if ((*utf8_char == ' ') || (uVar7 = 1, local_34 = puVar2, *utf8_char != '\n')) {
            if ((wrap == FORM_WRAP_NONE) || (local_30 + iVar4 < width)) goto LAB_080fbdfb;
            if (local_34 != (uchar *)0x0) {
              iVar8 = (int)local_34 - (int)text;
            }
            uVar7 = (uint)(local_34 != (uchar *)0x0);
          }
          uVar6 = iVar10 + 0xff;
          uVar5 = iVar10 + 0x102U & 0xffffff00;
          if ((uVar6 & 0xffffff00) <= uVar5 && uVar5 + (uVar6 >> 8) * -0x100 != 0) {
            size = (iVar10 + 0x102U >> 8) * 0x1000;
            local_20 = (line_info *)mem_realloc(plVar9,size);
            if (local_20 == (line_info *)0x0) {
              if (plVar9 == (line_info *)0x0) {
                return (line_info *)0x0;
              }
              mem_free(plVar9);
              return (line_info *)0x0;
            }
            memset(local_20 + (uVar6 & 0xffffff00),0,size + (uVar6 >> 8) * -0x1000);
          }
          if (local_20 == (line_info *)0x0) {
            return (line_info *)0x0;
          }
          local_20[iVar10].last_char_width = iVar4;
          iVar4 = iVar10 + 1;
          local_20[iVar10].field_0xc = local_20[iVar10].field_0xc & 0xfd | (uVar7 == 0) * '\x02';
          local_20[iVar10].start = local_44;
          local_20[iVar10].end = iVar8;
          iVar8 = iVar8 + uVar7;
          local_20[iVar4].field_0xc = local_20[iVar4].field_0xc & 0xfe | uVar7 == 0;
          local_30 = 0;
          local_34 = (uchar *)0x0;
          utf8_char = text + iVar8;
          uVar1 = *utf8_char;
          iVar10 = iVar4;
          local_44 = iVar8;
          puVar2 = local_34;
          plVar9 = local_20;
        } while( true );
      }
    }
  }
  else {
LAB_080fbdd6:
    assert_failed = 0;
  }
  return (line_info *)0x0;
LAB_080fbdfb:
  local_30 = local_30 + iVar4;
  iVar4 = utf8charlen(utf8_char);
  iVar8 = iVar8 + iVar4;
  goto LAB_080fbc60;
}



// WARNING: Unknown calling convention

line_info * format_text(uchar *text,int width,form_wrap wrap,int format)

{
  uchar uVar1;
  undefined *puVar2;
  uchar *wrappos;
  size_t newsize;
  uint uVar3;
  size_t size;
  uint uVar4;
  size_t oldsize;
  uint uVar5;
  int skip;
  int pos;
  int iVar6;
  line_info *plVar7;
  int iVar8;
  int line_number;
  uchar *data;
  bool bVar9;
  byte bVar10;
  int local_30;
  line_info *local_20;
  
  bVar10 = 0;
  if (assert_failed == 0) {
    assert_failed = (int)(text == (uchar *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0xa2;
      elinks_internal((uchar *)"assertion text failed!");
      if (assert_failed != 0) goto LAB_080fc08e;
    }
    local_20 = (line_info *)mem_realloc((void *)0x0,0x1000);
    if (local_20 != (line_info *)0x0) {
      bVar9 = ((uint)local_20 & 1) != 0;
      uVar5 = 0x1000;
      plVar7 = local_20;
      if (bVar9) {
        *(undefined *)&local_20->start = 0;
        plVar7 = (line_info *)((int)&local_20->start + 1);
        uVar5 = 0xfff;
      }
      if (((uint)plVar7 & 2) != 0) {
        *(undefined2 *)&plVar7->start = 0;
        uVar5 = uVar5 - 2;
        plVar7 = (line_info *)((int)&plVar7->start + 2);
      }
      for (uVar4 = uVar5 >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
        plVar7->start = 0;
        plVar7 = (line_info *)((int)plVar7 + (uint)bVar10 * -8 + 4);
      }
      if ((uVar5 & 2) != 0) {
        *(undefined2 *)&plVar7->start = 0;
        plVar7 = (line_info *)((int)&plVar7->start + 2);
      }
      if (bVar9) {
        *(undefined *)&plVar7->start = 0;
      }
      if (local_20 != (line_info *)0x0) {
        iVar8 = 0;
        local_30 = 0;
        iVar6 = 0;
LAB_080fbf60:
        uVar1 = text[iVar6];
        plVar7 = local_20;
        do {
          if (uVar1 == '\0') {
            plVar7[iVar8].start = local_30;
            plVar7[iVar8].end = iVar6;
            plVar7[iVar8 + 1].end = -1;
            plVar7[iVar8 + 1].start = -1;
            return plVar7;
          }
          uVar5 = 1;
          local_20 = plVar7;
          if (uVar1 != '\n') {
            if ((wrap == FORM_WRAP_NONE) || (iVar6 - local_30 < width)) goto LAB_080fc0b8;
            puVar2 = (undefined *)memrchr(text + local_30,0x20,iVar6 - local_30);
            if (puVar2 != (undefined *)0x0) {
              if ((format != 0) && (wrap == FORM_WRAP_HARD)) {
                *puVar2 = 10;
              }
              iVar6 = (int)puVar2 - (int)text;
            }
            uVar5 = (uint)(puVar2 != (undefined *)0x0);
          }
          uVar4 = iVar8 + 0xff;
          uVar3 = iVar8 + 0x102U & 0xffffff00;
          if ((uVar4 & 0xffffff00) <= uVar3 && uVar3 + (uVar4 >> 8) * -0x100 != 0) {
            size = (iVar8 + 0x102U >> 8) * 0x1000;
            local_20 = (line_info *)mem_realloc(plVar7,size);
            if (local_20 == (line_info *)0x0) {
              if (plVar7 == (line_info *)0x0) {
                return (line_info *)0x0;
              }
              mem_free(plVar7);
              return (line_info *)0x0;
            }
            memset(local_20 + (uVar4 & 0xffffff00),0,size + (uVar4 >> 8) * -0x1000);
          }
          if (local_20 == (line_info *)0x0) {
            return (line_info *)0x0;
          }
          local_20[iVar8].start = local_30;
          local_20[iVar8].end = iVar6;
          iVar6 = iVar6 + uVar5;
          uVar1 = text[iVar6];
          iVar8 = iVar8 + 1;
          local_30 = iVar6;
          plVar7 = local_20;
        } while( true );
      }
    }
  }
  else {
LAB_080fc08e:
    assert_failed = 0;
  }
  return (line_info *)0x0;
LAB_080fc0b8:
  iVar6 = iVar6 + 1;
  goto LAB_080fbf60;
}



// WARNING: Unknown calling convention

frame_event_status
textarea_op(form_state *fs,form_control *fc,int utf8,
           _func_int_form_state_ptr_line_info_ptr_int_int *do_op)

{
  int iVar1;
  int iVar2;
  line_info *line_00;
  int iVar3;
  int current;
  line_info *line;
  char *in_stack_ffffffc4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((fs == (form_state *)0x0) || (fc == (form_control *)0x0)) || (fs->value == (uchar *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x2cb;
    in_stack_ffffffc4 = "assertion fs && fs->value && fc failed!";
    elinks_internal((uchar *)"assertion fs && fs->value && fc failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  if (utf8 == 0) {
    assert_failed = 0;
    line_00 = format_text(fs->value,fc->cols,fc->wrap,0);
  }
  else {
    assert_failed = 0;
    line_00 = format_textutf8(fs->value,fc->cols,fc->wrap,(int)in_stack_ffffffc4);
  }
  if (line_00 != (line_info *)0x0) {
    iVar3 = get_textarea_line_number(line_00,fs->state);
    iVar1 = fs->state;
    iVar2 = fs->state_cell;
    iVar3 = (*do_op)(fs,line_00,iVar3,utf8);
    if (iVar3 != 0) {
      mem_free(line_00);
      return FRAME_EVENT_IGNORED;
    }
    mem_free(line_00);
    if ((fs->state != iVar1) || (fs->state_cell != iVar2)) {
      return FRAME_EVENT_REFRESH;
    }
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_right(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_right);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_left(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_left);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_eob(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_eob);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_bob(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_bob);
  return fVar1;
}



// WARNING: Unknown calling convention

void set_textarea(document_view *doc_view,int direction)

{
  byte bVar1;
  int iVar2;
  form_control *fc_00;
  form_state *fs_00;
  form_state *fs;
  link *plVar3;
  link *link;
  uint utf8_00;
  int utf8;
  form_control *fc;
  
  bVar1 = (doc_view->document->options).field_0x5c;
  if (assert_failed == 0) {
    if (doc_view->vs == (view_state *)0x0) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4a9;
      elinks_internal((uchar *)"assertion doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fc430;
    }
    assert_failed = (int)(direction != 1 && direction != -1);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4aa;
      elinks_internal((uchar *)"assertion direction == 1 || direction == -1 failed!");
      if (assert_failed != 0) goto LAB_080fc430;
    }
    iVar2 = doc_view->vs->current_link;
    if (iVar2 < 0) {
      return;
    }
    if (doc_view->document->nlinks <= iVar2) {
      return;
    }
    plVar3 = doc_view->document->links + iVar2;
    if (plVar3 == (link *)0x0) {
      return;
    }
    if (plVar3->type != LINK_AREA) {
      return;
    }
    fc_00 = (plVar3->data).form_control;
    assert_failed = (int)(fc_00 == (form_control *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x4b2;
      elinks_internal((uchar *)"assertion fc != NULL failed: link has no form control");
      if (assert_failed != 0) goto LAB_080fc430;
    }
    if (((fc_00->mode != FORM_MODE_DISABLED) &&
        (fs_00 = find_form_state(doc_view,fc_00), fs_00 != (form_state *)0x0)) &&
       (fs_00->value != (uchar *)0x0)) {
      utf8_00 = (uint)(bVar1 >> 4 & 1);
      if (direction == 1) {
        textarea_op_eob(fs_00,fc_00,utf8_00);
      }
      else {
        textarea_op_bob(fs_00,fc_00,utf8_00);
      }
    }
  }
  else {
LAB_080fc430:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_end(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_end);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_down(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_down);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_up(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_up);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status textarea_op_home(form_state *fs,form_control *fc,int utf8)

{
  frame_event_status fVar1;
  
  fVar1 = textarea_op(fs,fc,utf8,do_op_home);
  return fVar1;
}



// WARNING: Unknown calling convention

int area_cursor(form_control *fc,form_state *fs,int utf8)

{
  bool bVar1;
  int iVar2;
  int y;
  int iVar3;
  int x;
  int iVar4;
  line_info *line;
  char *in_stack_ffffffc4;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return 0;
  }
  bVar1 = fs == (form_state *)0x0 || fc == (form_control *)0x0;
  assert_failed = (int)bVar1;
  if (bVar1) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0xf3;
    in_stack_ffffffc4 = "assertion fc && fs failed!";
    elinks_internal((uchar *)"assertion fc && fs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return 0;
    }
  }
  if (utf8 == 0) {
    line = format_text(fs->value,fc->cols,fc->wrap,0);
  }
  else {
    line = format_textutf8(fs->value,fc->cols,fc->wrap,(int)in_stack_ffffffc4);
  }
  if (line == (line_info *)0x0) {
    return 0;
  }
  iVar2 = fs->state_cell;
  if (iVar2 == 0) {
    iVar2 = fs->state;
  }
  iVar2 = get_textarea_line_number(line,iVar2);
  if (iVar2 == -1) {
    mem_free(line);
    return 0;
  }
  if (utf8 == 0) {
    x = fs->state - line[iVar2].start;
    if (fc->wrap != FORM_WRAP_NONE) {
      x = x - (uint)(fc->cols == x);
    }
  }
  else if (fs->state_cell == 0) {
    x = utf8_ptr2cells(fs->value + line[iVar2].start,fs->value + fs->state);
  }
  else {
    iVar3 = utf8_ptr2cells(fs->value + line[iVar2].start,fs->value + fs->state_cell);
    x = iVar3 + line[iVar2].last_char_width;
  }
  mem_free(line);
  iVar3 = (x - fc->cols) + 1;
  if (fs->vpos < iVar3) {
    fs->vpos = iVar3;
LAB_080fc64c:
    iVar3 = fs->vypos;
    iVar4 = (iVar2 - fc->rows) + 1;
    if (iVar4 <= iVar3) {
LAB_080fc71e:
      if (iVar2 < iVar3) {
        fs->vypos = iVar2;
        iVar2 = 0;
      }
      else {
        iVar2 = (iVar2 - iVar3) * fc->cols;
      }
      goto LAB_080fc668;
    }
  }
  else {
    if (fs->vpos <= x) goto LAB_080fc64c;
    fs->vpos = x;
    iVar3 = fs->vypos;
    iVar4 = (iVar2 - fc->rows) + 1;
    if (iVar4 <= iVar3) goto LAB_080fc71e;
  }
  fs->vypos = iVar4;
  iVar2 = (iVar2 - iVar4) * fc->cols;
LAB_080fc668:
  return (x - fs->vpos) + iVar2;
}



// WARNING: Unknown calling convention

uchar * encode_textarea(submitted_value *sv)

{
  form_control *fc;
  line_info *p;
  void *blabla;
  uchar *puVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return (uchar *)0x0;
  }
  if ((sv == (submitted_value *)0x0) || (sv->value == (uchar *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x1ef;
    elinks_internal((uchar *)"assertion sv && sv->value failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return (uchar *)0x0;
    }
  }
  else {
    assert_failed = 0;
  }
  p = format_text(sv->value,sv->form_control->cols,sv->form_control->wrap,1);
  if (p != (line_info *)0x0) {
    mem_free(p);
  }
  puVar1 = encode_crlf(sv);
  return puVar1;
}



// WARNING: Unknown calling convention

void draw_textarea(terminal *term,form_state *fs,document_view *doc_view,link *link)

{
  line_info *plVar1;
  int sl;
  int iVar2;
  int iVar3;
  int xi;
  int xi_1;
  int iVar4;
  form_control *fc_1;
  line_info *line;
  int x;
  int iVar5;
  int sl_1;
  int cell;
  int y_1;
  uchar *end;
  uchar *end_00;
  unicode_val_T c;
  unicode_val_T data;
  int i;
  int x_1;
  int i_3;
  uchar *string;
  int vx;
  int y;
  int iVar6;
  int vx_1;
  form_control *fc;
  line_info *line_1;
  int iVar7;
  bool bVar8;
  form_control *format;
  line_info *local_40;
  form_control *local_3c;
  int local_38;
  form_control *local_34;
  line_info *local_30;
  uchar *local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (term == (terminal *)0x0)) ||
        (doc_view->document == (document *)0x0)) ||
       ((link == (link *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x1a1;
      elinks_internal((uchar *)
                      "assertion term && doc_view && doc_view->document && doc_view->vs && link failed!"
                     );
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if ((term->field_0x38 & 2) == 0) {
      if (link->type < LINK_BUTTON) {
        assert_failed = 1;
        local_34 = (form_control *)0x0;
      }
      else {
        local_34 = (link->data).form_control;
        assert_failed = (int)(local_34 == (form_control *)0x0);
        if (assert_failed == 0) goto LAB_080fc8e0;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x1ab;
      elinks_internal((uchar *)"assertion fc != NULL failed: link %d has no form control",
                      ((int)link - (int)doc_view->document->links >> 2) * -0x3b13b13b);
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
LAB_080fc8e0:
      iVar5 = doc_view->vs->x;
      iVar6 = doc_view->vs->y;
      if (link->npoints == 0) {
        return;
      }
      area_cursor(local_34,fs,0);
      plVar1 = format_text(fs->value,local_34->cols,local_34->wrap,0);
      if (plVar1 == (line_info *)0x0) {
        return;
      }
      iVar2 = fs->vypos;
      iVar7 = plVar1->start;
      local_30 = plVar1;
      while ((iVar2 != 0 && (iVar7 != -1))) {
        local_30 = local_30 + 1;
        iVar2 = iVar2 + -1;
        iVar7 = local_30->start;
      }
      iVar2 = (doc_view->box).y;
      x = (doc_view->box).x + link->points->x;
      iVar5 = x - iVar5;
      iVar6 = (link->points->y + iVar2) - iVar6;
      iVar3 = local_34->rows + iVar6;
      if ((iVar7 != -1) && (iVar6 < iVar3)) {
        while( true ) {
          if ((iVar2 <= iVar6) && ((iVar6 < iVar2 + (doc_view->box).height && (0 < local_34->cols)))
             ) {
            iVar2 = 0;
            do {
              iVar4 = (doc_view->box).x;
              iVar7 = iVar2 + iVar5;
              if ((iVar4 <= iVar7) && (iVar7 < iVar4 + (doc_view->box).width)) {
                iVar4 = fs->vpos;
                if ((-iVar2 == iVar4 || -iVar4 < iVar2) &&
                   (iVar4 + iVar2 < local_30->end - local_30->start)) {
                  local_3c = (form_control *)(uint)fs->value[local_30->start + iVar2 + iVar4];
                }
                else {
                  local_3c = (form_control *)0x5f;
                }
                draw_char_data(term,iVar7,iVar6,(unicode_val_T)local_3c);
              }
              iVar2 = iVar2 + 1;
            } while (local_34->cols != iVar2 && iVar2 <= local_34->cols);
          }
          local_30 = local_30 + 1;
          iVar6 = iVar6 + 1;
          if (iVar3 <= iVar6) goto LAB_080fcb87;
          if (local_30->start == -1) break;
          iVar2 = (doc_view->box).y;
        }
      }
      for (; iVar6 < iVar3; iVar6 = iVar6 + 1) {
        iVar2 = (doc_view->box).y;
        if (((iVar2 <= iVar6) && (iVar6 < iVar2 + (doc_view->box).height)) && (0 < local_34->cols))
        {
          iVar2 = 0;
          do {
            iVar4 = (doc_view->box).x;
            iVar7 = iVar2 + iVar5;
            if ((iVar4 <= iVar7) && (iVar7 < iVar4 + (doc_view->box).width)) {
              draw_char_data(term,iVar7,iVar6,0x5f);
            }
            iVar2 = iVar2 + 1;
          } while (local_34->cols != iVar2 && iVar2 <= local_34->cols);
        }
      }
LAB_080fcb87:
      mem_free(plVar1);
      return;
    }
    if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
       ((link == (link *)0x0 || (doc_view->vs == (view_state *)0x0)))) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
      errline = 0x14f;
      elinks_internal((uchar *)
                      "assertion term && doc_view && doc_view->document && doc_view->vs && link failed!"
                     );
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    if (link->type < LINK_BUTTON) {
      assert_failed = 1;
      local_3c = (form_control *)0x0;
    }
    else {
      local_3c = (link->data).form_control;
      assert_failed = (int)(local_3c == (form_control *)0x0);
      if (assert_failed == 0) goto LAB_080fcc4f;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 0x152;
    elinks_internal((uchar *)"assertion fc != NULL failed: link %d has no form control",
                    ((int)link - (int)doc_view->document->links >> 2) * -0x3b13b13b);
    if (assert_failed == 0) {
LAB_080fcc4f:
      iVar6 = doc_view->vs->x;
      local_38 = doc_view->vs->y;
      if (link->npoints == 0) {
        return;
      }
      format = local_3c;
      area_cursor(local_3c,fs,1);
      plVar1 = format_textutf8(fs->value,local_3c->cols,local_3c->wrap,(int)format);
      if (plVar1 == (line_info *)0x0) {
        return;
      }
      iVar5 = fs->vypos;
      iVar2 = plVar1->start;
      bVar8 = iVar2 != -1;
      local_40 = plVar1;
      if ((bVar8) && (iVar5 != 0)) {
        do {
          local_40 = local_40 + 1;
          iVar2 = local_40->start;
          bVar8 = iVar2 != -1;
          iVar5 = iVar5 + -1;
          if (iVar5 == 0) break;
        } while (bVar8);
      }
      iVar6 = ((doc_view->box).x + link->points->x) - iVar6;
      local_38 = ((doc_view->box).y + link->points->y) - local_38;
      iVar5 = local_38 + local_3c->rows;
      if ((bVar8) && (local_38 < iVar5)) {
        do {
          string = fs->value + iVar2;
          end_00 = fs->value + local_40->end;
          local_20[0] = string;
          iVar2 = utf8_cells2bytes(string,fs->vpos,end_00);
          local_20[0] = string + iVar2;
          iVar2 = (doc_view->box).y;
          if ((iVar2 <= local_38) &&
             ((local_38 < iVar2 + (doc_view->box).height && (0 < local_3c->cols)))) {
            iVar7 = 0;
            iVar2 = iVar6;
            do {
              if ((local_20[0] < end_00) && (-iVar7 == fs->vpos || -fs->vpos < iVar7)) {
                c = utf8_to_unicode(local_20,end_00);
              }
              else {
                c = 0x5f;
              }
              iVar4 = (doc_view->box).x;
              iVar3 = iVar2;
              if ((iVar2 < iVar4) || (iVar4 + (doc_view->box).width <= iVar2)) {
                iVar7 = iVar7 + 1;
                if (local_3c->cols <= iVar7) break;
              }
              else {
                iVar4 = unicode_to_cell(c);
                data = c;
                if (iVar4 == 2) {
                  iVar3 = iVar2 + 1;
                  iVar7 = iVar7 + 1;
                  data = 0xfffffffd;
                  draw_char_data(term,iVar2,local_38,c);
                }
                iVar7 = iVar7 + 1;
                draw_char_data(term,iVar3,local_38,data);
                if (local_3c->cols <= iVar7) break;
              }
              iVar2 = iVar3 + 1;
            } while( true );
          }
          local_40 = local_40 + 1;
          local_38 = local_38 + 1;
          iVar2 = local_40->start;
          if (iVar5 <= local_38) goto LAB_080fcea8;
        } while (iVar2 != -1);
      }
      for (; local_38 < iVar5; local_38 = local_38 + 1) {
        iVar2 = (doc_view->box).y;
        if (((iVar2 <= local_38) && (local_38 < iVar2 + (doc_view->box).height)) &&
           (0 < local_3c->cols)) {
          iVar7 = 0;
          iVar2 = iVar6;
          while( true ) {
            iVar3 = (doc_view->box).x;
            if ((iVar3 <= iVar2) && (iVar2 < iVar3 + (doc_view->box).width)) {
              draw_char_data(term,iVar2,local_38,0x5f);
            }
            iVar7 = iVar7 + 1;
            if (local_3c->cols <= iVar7) break;
            iVar2 = iVar2 + 1;
          }
        }
      }
LAB_080fcea8:
      mem_free(plVar1);
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

frame_event_status save_formatted_dlg(session *ses,document_view *doc_view,int xxxx)

{
  query_file(ses,doc_view->vs->uri,ses,save_formatted,(_func_void_void_ptr *)0x0,1);
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

document_view * current_frame(session *ses)

{
  location *plVar1;
  document_view *doc_view;
  document_view *pdVar2;
  int current_frame_number;
  int iVar3;
  
  if (assert_failed == 0) {
    assert_failed = (int)(ses == (session *)0x0);
    if (assert_failed == 0) {
      plVar1 = (ses->history).current;
    }
    else {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x4e5;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) goto LAB_080fd0c0;
      plVar1 = (ses->history).current;
    }
    if (plVar1 == (location *)0x0) {
      assert_failed = 0;
      return (document_view *)0x0;
    }
    iVar3 = (plVar1->vs).current_link;
    if (iVar3 == -1) {
      iVar3 = 0;
    }
    for (pdVar2 = (document_view *)(ses->scrn_frames).next;
        pdVar2 != (document_view *)&ses->scrn_frames; pdVar2 = pdVar2->next) {
      while ((pdVar2->document == (document *)0x0 ||
             (pdVar2->document->frame_desc == (frameset_desc *)0x0))) {
        if (iVar3 == 0) {
          assert_failed = 0;
          return pdVar2;
        }
        pdVar2 = pdVar2->next;
        iVar3 = iVar3 + -1;
        if ((document_view *)&ses->scrn_frames == pdVar2) goto LAB_080fd058;
      }
    }
LAB_080fd058:
    pdVar2 = ses->doc_view;
    if ((pdVar2 == (document_view *)0x0) || (pdVar2->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x4f4;
      elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fd0c0;
    }
    else {
      assert_failed = 0;
    }
    if (pdVar2->document == (document *)0x0) {
      return pdVar2;
    }
    if (pdVar2->document->frame_desc == (frameset_desc *)0x0) {
      return pdVar2;
    }
  }
  else {
LAB_080fd0c0:
    assert_failed = 0;
  }
  return (document_view *)0x0;
}



// WARNING: Unknown calling convention

void save_formatted(void *data,uchar *file)

{
  document_view *pdVar1;
  document_view *doc_view;
  
  if (assert_failed == 0) {
    if ((((data == (void *)0x0) || (*(int *)((int)data + 8) == 0)) || (file == (uchar *)0x0)) ||
       (*(int *)(*(int *)((int)data + 8) + 0x14) == 0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x668;
      elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && file failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return;
      }
    }
    else {
      assert_failed = 0;
    }
    pdVar1 = current_frame((session *)data);
    if (assert_failed == 0) {
      if ((pdVar1 == (document_view *)0x0) || (pdVar1->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x66b;
        elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
        if (assert_failed != 0) {
          assert_failed = 0;
          return;
        }
      }
      else {
        assert_failed = 0;
      }
      create_download_file
                (*(terminal **)(*(int *)((int)data + 8) + 0x14),file,(uchar **)0x0,0,0,
                 save_formatted_finish,pdVar1->document);
      return;
    }
  }
  assert_failed = 0;
  return;
}



// WARNING: Unknown calling convention

void save_formatted_finish(terminal *term,int h,void *data,int resume)

{
  int iVar1;
  
  if (assert_failed == 0) {
    assert_failed = (int)(data == (void *)0x0 || term == (terminal *)0x0);
    if (data == (void *)0x0 || term == (terminal *)0x0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x657;
      elinks_internal((uchar *)"assertion term && document failed!");
      if (assert_failed != 0) goto LAB_080fd2f8;
    }
    if (h != -1) {
      iVar1 = dump_to_file((document *)data,h);
      if (iVar1 != 0) {
        info_box(term,0,(uchar *)"Save error",ALIGN_CENTER,(uchar *)"Error writing to file");
      }
      close(h);
      return;
    }
  }
  else {
LAB_080fd2f8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status save_as(session *ses,document_view *doc_view,int magic)

{
  object *poVar1;
  uri *puVar2;
  location *plVar3;
  
  if (assert_failed == 0) {
    assert_failed = (int)(ses == (session *)0x0);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x641;
      elinks_internal((uchar *)"assertion ses failed!");
      if (assert_failed != 0) {
        assert_failed = 0;
        return FRAME_EVENT_OK;
      }
    }
    plVar3 = (ses->history).current;
    if (plVar3 == (location *)0x0) {
      return FRAME_EVENT_OK;
    }
    if (ses->download_uri != (uri *)0x0) {
      done_uri(ses->download_uri);
      plVar3 = (ses->history).current;
    }
    puVar2 = (plVar3->vs).uri;
    poVar1 = &puVar2->object;
    poVar1->refcount = poVar1->refcount + 1;
    ses->download_uri = puVar2;
    if (assert_failed == 0) {
      if (((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) ||
         (doc_view->document->uri == (uri *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x649;
        elinks_internal((uchar *)
                        "assertion doc_view && doc_view->document && doc_view->document->uri failed!"
                       );
        if (assert_failed != 0) {
          assert_failed = 0;
          return FRAME_EVENT_OK;
        }
      }
      else {
        assert_failed = 0;
      }
      set_session_referrer(ses,doc_view->document->uri);
      query_file(ses,ses->download_uri,ses,start_download,(_func_void_void_ptr *)0x0,1);
      return FRAME_EVENT_OK;
    }
  }
  assert_failed = 0;
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

frame_event_status view_image(session *ses,document_view *doc_view,int xxxx)

{
  int iVar1;
  uchar *url;
  link *plVar2;
  link *link;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     ((plVar2 = doc_view->document->links + iVar1, plVar2 != (link *)0x0 &&
      (url = plVar2->where_img, url != (uchar *)0x0)))) {
    goto_url(ses,url);
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

frame_event_status download_link(session *ses,document_view *doc_view,action_id_T action_id)

{
  int iVar1;
  link *link;
  uri *puVar2;
  _func_void_void_ptr_uchar_ptr *download;
  code *std;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     (link = doc_view->document->links + iVar1, link != (link *)0x0)) {
    if (ses->download_uri != (uri *)0x0) {
      done_uri(ses->download_uri);
      ses->download_uri = (uri *)0x0;
    }
    if (action_id == 0x26) {
      if (link->where_img == (uchar *)0x0) {
        puVar2 = ses->download_uri;
        std = start_download;
      }
      else {
        std = start_download;
        puVar2 = get_uri(link->where_img,0);
        ses->download_uri = puVar2;
      }
    }
    else {
      if (action_id == 0x27) {
        std = resume_download;
      }
      else {
        if (action_id != 0x25) {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
          errline = 0x627;
          elinks_internal((uchar *)"I think you forgot to take your medication, mental boy!");
          return FRAME_EVENT_OK;
        }
        std = start_download;
      }
      puVar2 = get_link_uri(ses,doc_view,link);
      ses->download_uri = puVar2;
    }
    if (puVar2 != (uri *)0x0) {
      set_session_referrer(ses,doc_view->document->uri);
      query_file(ses,ses->download_uri,ses,std,(_func_void_void_ptr *)0x0,1);
    }
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

frame_event_status horizontal_scroll(session *ses,document_view *doc_view,int steps)

{
  frame_event_status fVar1;
  option_value *poVar2;
  int iVar3;
  int max;
  int iVar4;
  int iVar5;
  int x;
  int iVar6;
  view_state *pvVar7;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x132;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fd690;
    }
    else {
      assert_failed = 0;
    }
    iVar6 = doc_view->vs->x + steps;
    poVar2 = get_opt_();
    if (poVar2->tree == (list_head_elinks *)0x0) {
      pvVar7 = doc_view->vs;
      iVar4 = pvVar7->x;
      iVar3 = doc_view->document->width - (doc_view->box).width;
      if (iVar3 < iVar4) {
        iVar3 = iVar4;
      }
    }
    else {
      pvVar7 = doc_view->vs;
      iVar4 = pvVar7->x;
      iVar3 = doc_view->document->width + -1;
    }
    iVar5 = 0;
    if ((-1 < iVar6) && (iVar5 = iVar6, iVar3 <= iVar6)) {
      iVar5 = iVar3;
    }
    fVar1 = FRAME_EVENT_OK;
    if (iVar5 != iVar4) {
      pvVar7->x = iVar5;
      iVar6 = current_link_is_visible(doc_view);
      fVar1 = FRAME_EVENT_REFRESH;
      if (iVar6 == 0) {
        find_link_page_down(doc_view);
        fVar1 = FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fd690:
    assert_failed = 0;
    fVar1 = FRAME_EVENT_OK;
  }
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status vertical_scroll(session *ses,document_view *doc_view,int steps)

{
  int iVar1;
  int iVar2;
  int y;
  int iVar3;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x10f;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  iVar1 = doc_view->vs->y;
  iVar2 = steps + iVar1;
  if (0 < steps) {
    iVar3 = doc_view->document->height - (doc_view->box).height;
    if (iVar3 <= iVar1) {
      return FRAME_EVENT_OK;
    }
    if (iVar3 < iVar2) {
      iVar2 = iVar3;
    }
  }
  iVar3 = 0;
  if (-1 < iVar2) {
    iVar3 = iVar2;
  }
  if (iVar1 == iVar3) {
    return FRAME_EVENT_OK;
  }
  doc_view->vs->y = iVar3;
  iVar2 = current_link_is_visible(doc_view);
  if (iVar2 != 0) {
    return FRAME_EVENT_REFRESH;
  }
  if (steps < 1) {
    find_link_page_up(doc_view);
    return FRAME_EVENT_REFRESH;
  }
  find_link_page_down(doc_view);
  return FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

frame_event_status scroll_mouse_up(session *ses,document_view *doc_view)

{
  option_value *poVar1;
  frame_event_status fVar2;
  
  poVar1 = get_opt_();
  fVar2 = vertical_scroll(ses,doc_view,-poVar1->number);
  return fVar2;
}



// WARNING: Unknown calling convention

frame_event_status scroll_mouse_down(session *ses,document_view *doc_view)

{
  option_value *poVar1;
  frame_event_status fVar2;
  
  poVar1 = get_opt_();
  fVar2 = vertical_scroll(ses,doc_view,poVar1->number);
  return fVar2;
}



// WARNING: Unknown calling convention

frame_event_status try_mark_key(session *ses,document_view *doc_view,term_event *ev)

{
  anon_enum_32 aVar1;
  term_event_key_T key;
  uchar mark;
  uint uVar2;
  
  aVar1 = (ses->kbdprefix).mark;
  uVar2 = 0;
  if (*(uint *)&ev->info < 0x80) {
    uVar2 = *(uint *)&ev->info;
  }
  if (aVar1 == CONTINUE_DOWNLOAD_DO) {
    set_mark((uchar)uVar2,doc_view->vs);
  }
  else {
    if (aVar1 == COMMON_DOWNLOAD_DO) {
      return FRAME_EVENT_IGNORED;
    }
    if (aVar1 == DOM_SCAN_END) {
      goto_mark((uchar)uVar2,doc_view->vs);
    }
  }
  (ses->kbdprefix).repeat_count = 0;
  (ses->kbdprefix).mark = COMMON_DOWNLOAD_DO;
  return FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

frame_event_status send_to_frame(session *ses,document_view *doc_view,term_event *ev)

{
  document *pdVar1;
  int iVar2;
  terminal *ptVar3;
  bool bVar4;
  uint uVar5;
  int digit;
  frame_event_status fVar6;
  uint uVar7;
  link *plVar8;
  link *link_1;
  action_id_T aVar9;
  int scrollmargin;
  option_value *poVar10;
  int nlinks;
  int iVar11;
  link *plVar12;
  int length;
  int iVar13;
  frame_event_status status;
  uchar local_30;
  uchar d [2];
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_IGNORED;
  }
  if ((((ses == (session *)0x0) || (ses->tab == (window *)0x0)) || (ev == (term_event *)0x0)) ||
     (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x501;
    elinks_internal((uchar *)"assertion ses && ses->tab && ses->tab->term && ev failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_IGNORED;
    }
  }
  if ((doc_view == (document_view *)0x0) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x4ca;
    elinks_internal((uchar *)
                    "assertion doc_view && doc_view->document failed: document not formatted");
    if (assert_failed == 0) goto LAB_080fda3d;
LAB_080fdc34:
    assert_failed = 0;
  }
  else {
LAB_080fda3d:
    bVar4 = ev == (term_event *)0x0 || ses == (session *)0x0;
    assert_failed = (int)bVar4;
    if (bVar4) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x4cd;
      elinks_internal((uchar *)"assertion ses && ev failed!");
      if (assert_failed != 0) goto LAB_080fdc34;
    }
    if (doc_view->vs != (view_state *)0x0) {
      if (ev->ev == EVENT_KBD) {
        iVar11 = doc_view->vs->current_link;
        if (((-1 < iVar11) && (iVar11 < doc_view->document->nlinks)) &&
           (plVar8 = doc_view->document->links + iVar11, plVar8 != (link *)0x0)) {
          if (plVar8->type + ~LINK_SELECT < 2) {
            aVar9 = kbd_action(KEYMAP_EDIT,ev,(int *)0x0);
            if ((ses->insert_mode == INSERT_MODE_OFF) && (aVar9 == 0xe)) {
              ses->insert_mode = INSERT_MODE_ON;
              digit = FRAME_EVENT_REFRESH;
              goto LAB_080fdbe0;
            }
            if (assert_failed == 0) goto LAB_080fdb03;
          }
          else {
LAB_080fdb03:
            assert_failed = 0;
          }
          if ((plVar8->type + ~LINK_SELECT < 2) &&
             (digit = field_op(ses,doc_view,plVar8,ev), digit != FRAME_EVENT_IGNORED)) {
            if ((ses->insert_mode == INSERT_MODE_ON) && (assert_failed == 0)) {
              iVar11 = doc_view->vs->current_link;
              if ((iVar11 < 0) || (doc_view->document->nlinks <= iVar11)) {
                plVar12 = (link *)0x0;
              }
              else {
                plVar12 = doc_view->document->links + iVar11;
              }
              assert_failed = (int)(plVar8 != plVar12);
              if (plVar8 != plVar12) {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
                errline = 0x442;
                elinks_internal((uchar *)"assertion link == get_current_link(doc_view) failed!");
              }
            }
            goto LAB_080fdbd7;
          }
        }
        fVar6 = try_mark_key(ses,doc_view,ev);
        digit = fVar6;
        if (fVar6 == FRAME_EVENT_IGNORED) {
          poVar10 = get_opt_();
          iVar11 = poVar10->number;
          if ((iVar11 < 2) ||
             (digit = try_document_key(ses,doc_view,ev), digit == FRAME_EVENT_IGNORED)) {
            pdVar1 = doc_view->document;
            iVar13 = (ev->info).mouse.x;
            uVar7 = iVar13 - 0x30;
            if (uVar7 < 10) {
              if ((ev->info).mouse.y == 0) {
                if ((ses->kbdprefix).repeat_count == 0) {
                  iVar2 = (pdVar1->options).num_links_key;
                  if ((iVar2 == 0) || ((iVar2 == 1 && (((pdVar1->options).field_0x45 & 0x10) == 0)))
                     ) goto LAB_080fdefa;
                  if (uVar7 != 0) {
                    local_30 = (uchar)iVar13;
                    d[0] = local_30;
                    iVar11 = pdVar1->nlinks;
                    d[1] = '\0';
                    (ses->kbdprefix).repeat_count = 0;
                    if (iVar11 != 0) {
                      iVar13 = 1;
                      do {
                        iVar13 = iVar13 + 1;
                        iVar11 = iVar11 / 10;
                      } while (iVar11 != 0);
                      input_dialog(ses->tab->term,(memory_list *)0x0,(uchar *)"Go to link",
                                   (uchar *)"Enter link number",ses,(input_history *)0x0,iVar13,d,1,
                                   pdVar1->nlinks,check_number,goto_link_number,
                                   (done_handler_T *)0x0);
                    }
                    goto LAB_080fdab6;
                  }
                  goto LAB_080fdece;
                }
LAB_080fdf86:
                draw_formatted(ses,0);
                uVar7 = uVar7 + (ses->kbdprefix).repeat_count * 10;
                (ses->kbdprefix).repeat_count = uVar7;
                if (99999 < (int)uVar7) {
                  (ses->kbdprefix).repeat_count = 0;
                  goto LAB_080fdab6;
                }
              }
              else {
                if ((ses->kbdprefix).repeat_count != 0) goto LAB_080fdf86;
LAB_080fdefa:
                (ses->kbdprefix).repeat_count = uVar7;
              }
              if (uVar7 != 0) {
                highlight_links_with_prefixes_that_start_with_n(ses->tab->term,doc_view,uVar7);
              }
              goto LAB_080fdab6;
            }
LAB_080fdece:
            digit = fVar6;
            if (iVar11 == 1) {
              digit = try_document_key(ses,doc_view,ev);
            }
          }
        }
      }
      else {
        if (ev->ev != EVENT_MOUSE) goto LAB_080fda6c;
        iVar11 = (ev->info).mouse.x;
        uVar7 = (ev->info).mouse.button;
        iVar13 = (ev->info).mouse.y;
        uVar5 = uVar7 & 7;
        if (uVar5 < 3) {
          plVar8 = get_link_at_coordinates(doc_view,iVar11,iVar13);
          if (plVar8 == (link *)0x0) {
            digit = FRAME_EVENT_IGNORED;
            if ((*(byte *)((int)&ev->info + 8) & 7) != 0) goto LAB_080fda6e;
            poVar10 = get_opt_();
            iVar2 = poVar10->number;
            if (iVar13 < iVar2) goto LAB_080fdf50;
            if ((doc_view->box).height - iVar2 <= iVar13) goto LAB_080fdec0;
            if (iVar11 < iVar2 * 2) {
              poVar10 = get_opt_();
              digit = horizontal_scroll(ses,doc_view,-poVar10->number);
            }
            else {
              if (iVar11 < iVar2 * -2 + (doc_view->box).width) goto LAB_080fdab6;
              poVar10 = get_opt_();
              digit = horizontal_scroll(ses,doc_view,poVar10->number);
            }
          }
          else {
            doc_view->vs->current_link =
                 ((int)plVar8 - (int)doc_view->document->links >> 2) * -0x3b13b13b;
            ses->navigate_mode = NAVIGATE_LINKWISE;
            digit = FRAME_EVENT_REFRESH;
            if (plVar8->type + ~LINK_SELECT < 2) goto LAB_080fdbe0;
            refresh_view(ses,doc_view,0);
            uVar7 = (ev->info).mouse.button;
            uVar5 = uVar7 & 7;
            if (1 < uVar5) {
              link_menu(ses->tab->term,(void *)0x0,ses);
              digit = FRAME_EVENT_OK;
              goto LAB_080fda6e;
            }
            if ((uVar7 & 0x20) == 0) {
              ptVar3 = ses->tab->term;
              (ptVar3->prev_mouse_event).x = 0;
              (ptVar3->prev_mouse_event).y = 0;
              (ptVar3->prev_mouse_event).button = 0;
              digit = FRAME_EVENT_OK;
              goto LAB_080fda6e;
            }
            if (uVar5 != 0) {
              open_current_link_in_new_tab(ses,1);
              digit = FRAME_EVENT_OK;
              goto LAB_080fda6e;
            }
            digit = enter(ses,doc_view,0);
          }
        }
        else {
          if ((uVar7 & 0x20) != 0) {
LAB_080fdab6:
            digit = 2;
            goto LAB_080fda6e;
          }
          if (uVar5 == 3) {
LAB_080fdf50:
            digit = scroll_mouse_up(ses,doc_view);
          }
          else {
            if (uVar5 != 4) goto LAB_080fdab6;
LAB_080fdec0:
            digit = scroll_mouse_down(ses,doc_view);
          }
        }
      }
LAB_080fdbd7:
      if (digit == FRAME_EVENT_REFRESH) {
LAB_080fdbe0:
        refresh_view(ses,doc_view,0);
        return digit;
      }
      goto LAB_080fda6e;
    }
  }
LAB_080fda6c:
  digit = FRAME_EVENT_IGNORED;
LAB_080fda6e:
  print_screen_status(ses);
  return digit;
}



// WARNING: Unknown calling convention

frame_event_status scroll_right(session *ses,document_view *doc_view)

{
  int steps_00;
  int steps;
  option_value *poVar1;
  frame_event_status fVar2;
  
  steps_00 = eat_kbd_repeat_count(ses);
  if (steps_00 == 0) {
    poVar1 = get_opt_();
    steps_00 = poVar1->number;
  }
  fVar2 = horizontal_scroll(ses,doc_view,steps_00);
  return fVar2;
}



// WARNING: Unknown calling convention

frame_event_status scroll_left(session *ses,document_view *doc_view)

{
  int iVar1;
  int steps;
  option_value *poVar2;
  frame_event_status fVar3;
  
  iVar1 = eat_kbd_repeat_count(ses);
  if (iVar1 == 0) {
    poVar2 = get_opt_();
    iVar1 = poVar2->number;
  }
  fVar3 = horizontal_scroll(ses,doc_view,-iVar1);
  return fVar3;
}



// WARNING: Unknown calling convention

frame_event_status scroll_down(session *ses,document_view *doc_view)

{
  int steps_00;
  int steps;
  option_value *poVar1;
  frame_event_status fVar2;
  
  steps_00 = eat_kbd_repeat_count(ses);
  if (steps_00 == 0) {
    poVar1 = get_opt_();
    steps_00 = poVar1->number;
  }
  fVar2 = vertical_scroll(ses,doc_view,steps_00);
  return fVar2;
}



// WARNING: Unknown calling convention

frame_event_status scroll_up(session *ses,document_view *doc_view)

{
  int iVar1;
  int steps;
  option_value *poVar2;
  frame_event_status fVar3;
  
  iVar1 = eat_kbd_repeat_count(ses);
  if (iVar1 == 0) {
    poVar2 = get_opt_();
    iVar1 = poVar2->number;
  }
  fVar3 = vertical_scroll(ses,doc_view,-iVar1);
  return fVar3;
}



// WARNING: Unknown calling convention

int try_jump_to_link_number(session *ses,document_view *doc_view)

{
  int iVar1;
  int link_number;
  int iVar2;
  
  iVar1 = eat_kbd_repeat_count(ses);
  iVar2 = 1;
  iVar1 = iVar1 + -1;
  if (-1 < iVar1) {
    if ((doc_view != (document_view *)0x0) && (iVar1 < doc_view->document->nlinks)) {
      jump_to_link_number(ses,doc_view,iVar1);
      refresh_view(ses,doc_view,0);
      return 1;
    }
    iVar2 = 0;
  }
  return iVar2;
}



// WARNING: Unknown calling convention

frame_event_status copy_current_link_to_clipboard(session *ses,document_view *doc_view,int xxx)

{
  int iVar1;
  uri *uri_00;
  uri *uri;
  uchar *data;
  link *link_00;
  link *link;
  uchar *uristring;
  
  if ((((doc_view != (document_view *)0x0) && (iVar1 = doc_view->vs->current_link, -1 < iVar1)) &&
      (iVar1 < doc_view->document->nlinks)) &&
     (link_00 = doc_view->document->links + iVar1, link_00 != (link *)0x0)) {
    uri_00 = get_link_uri(ses,doc_view,link_00);
    if (uri_00 != (uri *)0x0) {
      data = get_uri_string(uri_00,URI_ORIGINAL);
      done_uri(uri_00);
      if (data != (uchar *)0x0) {
        set_clipboard_text(data);
        mem_free(data);
      }
    }
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor(session *ses,document_view *doc_view,int x,int y)

{
  terminal *term;
  frame_event_status fVar1;
  frame_event_status status;
  int iVar2;
  int iVar3;
  link *plVar4;
  link *link;
  int iVar5;
  int y_00;
  int iVar6;
  int local_40;
  int local_24;
  
  term = ses->tab->term;
  iVar2 = (doc_view->box).x;
  if (x < iVar2) {
    iVar5 = (doc_view->box).y;
    if (iVar5 <= y) {
      iVar3 = doc_view->document->height - doc_view->vs->y;
      iVar6 = doc_view->document->width - doc_view->vs->x;
      local_24 = (doc_view->box).height + iVar5;
      y_00 = iVar5;
      goto joined_r0x080fe3b5;
    }
LAB_080fe33e:
    fVar1 = vertical_scroll(ses,doc_view,y - iVar5);
LAB_080fe34e:
    if (fVar1 != FRAME_EVENT_REFRESH) {
      return fVar1;
    }
    iVar3 = (doc_view->box).x;
    if (iVar3 <= x) {
      y_00 = (doc_view->box).y;
      iVar3 = (doc_view->box).width + -1 + iVar3;
      local_24 = (doc_view->box).height + y_00;
      goto LAB_080fe3d2;
    }
    y_00 = (doc_view->box).y;
    local_24 = (doc_view->box).height + y_00;
  }
  else {
    iVar5 = (doc_view->box).y;
    if (y < iVar5) goto LAB_080fe33e;
    if (x < (doc_view->box).width + iVar2) {
      local_40 = (doc_view->box).height + iVar5;
      y_00 = y;
      iVar3 = x;
      if (y < local_40) goto LAB_080fe3f8;
    }
    else {
      local_40 = (doc_view->box).height + iVar5;
    }
    iVar3 = doc_view->document->height - doc_view->vs->y;
    iVar6 = doc_view->document->width - doc_view->vs->x;
    y_00 = iVar5;
    local_24 = local_40;
joined_r0x080fe3b5:
    if ((local_24 <= y) && (y <= iVar3)) {
      fVar1 = vertical_scroll(ses,doc_view,(y + 1) - local_24);
      goto LAB_080fe34e;
    }
    if (x < iVar2) {
      fVar1 = horizontal_scroll(ses,doc_view,x - iVar2);
      goto LAB_080fe34e;
    }
    iVar2 = iVar2 + (doc_view->box).width;
    if ((x <= iVar6) && (iVar2 <= x)) {
      fVar1 = horizontal_scroll(ses,doc_view,(x - iVar2) + 1);
      goto LAB_080fe34e;
    }
    iVar3 = iVar2 + -1;
LAB_080fe3d2:
    if (x < iVar3) {
      iVar3 = x;
    }
  }
  if ((y_00 <= y) && (y_00 = local_24 + -1, y <= y_00)) {
    y_00 = y;
  }
LAB_080fe3f8:
  ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
  plVar4 = get_link_at_coordinates(doc_view,iVar3 - (doc_view->box).x,y_00 - (doc_view->box).y);
  if (plVar4 == (link *)0x0) {
    doc_view->vs->current_link = -1;
  }
  else {
    doc_view->vs->current_link = ((int)plVar4 - (int)doc_view->document->links >> 2) * -0x3b13b13b;
  }
  set_cursor(term,iVar3,y_00,0);
  ses->tab->x = iVar3;
  ses->tab->y = y_00;
  return FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor_rel(session *ses,document_view *view,int rx,int ry)

{
  int count;
  frame_event_status fVar1;
  
  count = eat_kbd_repeat_count(ses);
  if (count < 1) {
    count = 1;
  }
  fVar1 = move_cursor(ses,view,rx * count + ses->tab->x,ry * count + ses->tab->y);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor_line_start(session *ses,document_view *doc_view)

{
  frame_event_status fVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x37f;
    elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  fVar1 = move_cursor_rel(ses,doc_view,-((ses->tab->x + doc_view->vs->x) - (doc_view->box).x),0);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor_down(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,0,1);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor_up(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,0,-1);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor_right(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,1,0);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status move_cursor_left(session *ses,document_view *view)

{
  frame_event_status fVar1;
  
  fVar1 = move_cursor_rel(ses,view,-1,0);
  return fVar1;
}



// WARNING: Unknown calling convention

frame_event_status move_link_next_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  link *plVar4;
  uint uVar5;
  frame_event_status status;
  int iVar6;
  link *plVar7;
  int mini;
  int iVar8;
  point *ppVar9;
  int max_y;
  int y;
  link *link;
  int iVar10;
  int iVar11;
  link *last;
  link *plVar12;
  link *plVar13;
  int iVar14;
  int iVar15;
  int y_00;
  int local_30;
  int local_24;
  int local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x333;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fe76d;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      iVar11 = (doc_view->box).height + pvVar1->y;
      if (iVar11 < pdVar2->height) {
        pvVar1->y = iVar11;
        return FRAME_EVENT_REFRESH;
      }
    }
    else {
      y_00 = (ses->tab->y + pvVar1->y) - (doc_view->box).y;
      iVar6 = (ses->tab->x + pvVar1->x) - (doc_view->box).x;
      iVar11 = pvVar1->current_link;
      iVar8 = iVar6;
      iVar15 = iVar6;
      if (((-1 < iVar11) && (iVar11 < pdVar2->nlinks)) &&
         (link = pdVar2->links + iVar11, link != (link *)0x0)) {
        get_link_x_bounds(link,y_00,local_20,&local_24);
        iVar8 = local_24;
        iVar15 = local_20[0];
      }
      local_20[0] = iVar15;
      local_24 = iVar8;
      iVar15 = pdVar2->height;
      iVar14 = pvVar1->y;
      iVar11 = iVar15 + -1;
      iVar3 = (doc_view->box).height;
      iVar8 = iVar14 + -1 + iVar3 * 2;
      iVar10 = y_00;
      if (iVar11 < y_00) {
        iVar10 = iVar11;
      }
      if (iVar8 <= iVar11) {
        iVar11 = iVar8;
      }
      if (iVar10 <= iVar11) {
        local_30 = iVar10 * 4;
        do {
          plVar7 = *(link **)((int)pdVar2->lines1 + local_30);
          if ((plVar7 != (link *)0x0) &&
             (plVar4 = *(link **)((int)pdVar2->lines2 + local_30), plVar7 <= plVar4)) {
            plVar12 = (link *)0x0;
            do {
              while (((plVar13 = plVar7, plVar13->points->y != iVar10 ||
                      (iVar8 = plVar13->points->x, iVar8 <= local_20[0])) ||
                     ((plVar12 != (link *)0x0 && (plVar12->points->x <= iVar8))))) {
                plVar7 = plVar13 + 1;
                plVar13 = plVar12;
                if (plVar4 < plVar7) goto LAB_080fe8e8;
              }
              plVar7 = plVar13 + 1;
              plVar12 = plVar13;
            } while (plVar13 + 1 <= plVar4);
LAB_080fe8e8:
            if (plVar13 != (link *)0x0) {
              ppVar9 = plVar13->points;
              uVar5 = pvVar1->y;
              iVar11 = ppVar9->y;
              if ((int)(iVar3 + uVar5) <= iVar11) {
                mini = ~uVar5;
                iVar8 = mini + pdVar2->height;
                if (iVar3 < iVar8) {
                  iVar8 = iVar3;
                }
                iVar11 = iVar11 - iVar8;
                pvVar1->y = iVar8 + uVar5;
                ppVar9 = plVar13->points;
              }
              status = move_cursor(ses,doc_view,(ses->tab->x + ppVar9->x) - iVar6,
                                   (iVar11 - y_00) + ses->tab->y);
              iVar11 = doc_view->vs->current_link;
              if (iVar11 < 0) {
                return status;
              }
              if (doc_view->document->nlinks <= iVar11) {
                return status;
              }
              if (doc_view->document->links + iVar11 == plVar13) {
                ses->navigate_mode = NAVIGATE_LINKWISE;
                return status;
              }
              return status;
            }
          }
          iVar10 = iVar10 + 1;
          local_30 = local_30 + 4;
          local_20[0] = -1;
        } while (iVar10 <= iVar11);
        iVar14 = pvVar1->y;
        iVar15 = pdVar2->height;
      }
      if (iVar14 + iVar3 < iVar15) {
        pvVar1->y = iVar14 + iVar3;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        return FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fe76d:
    assert_failed = 0;
  }
  status = FRAME_EVENT_OK;
  return status;
}



// WARNING: Unknown calling convention

frame_event_status move_link_prev_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  link *plVar3;
  frame_event_status status;
  int iVar4;
  link *plVar5;
  int iVar6;
  int mini;
  point *ppVar7;
  int min_y;
  int y_00;
  int iVar8;
  int y;
  link *link;
  int iVar9;
  link *last;
  link *plVar10;
  link *plVar11;
  int local_30;
  int local_24;
  int local_20 [4];
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x2e3;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fea6d;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      if (pvVar1->y != 0) {
        iVar6 = pvVar1->y - (doc_view->box).height;
        pvVar1->y = iVar6;
        if (iVar6 < 0) {
          pvVar1->y = 0;
          status = FRAME_EVENT_REFRESH;
          return status;
        }
        status = FRAME_EVENT_REFRESH;
        return status;
      }
    }
    else {
      y_00 = (ses->tab->y + pvVar1->y) - (doc_view->box).y;
      iVar4 = (ses->tab->x + pvVar1->x) - (doc_view->box).x;
      iVar6 = pvVar1->current_link;
      iVar9 = iVar4;
      iVar8 = iVar4;
      if (((-1 < iVar6) && (iVar6 < pdVar2->nlinks)) &&
         (link = pdVar2->links + iVar6, link != (link *)0x0)) {
        get_link_x_bounds(link,y_00,local_20,&local_24);
        iVar9 = local_24;
        iVar8 = local_20[0];
      }
      local_20[0] = iVar8;
      local_24 = iVar9;
      iVar6 = pvVar1->y;
      iVar9 = pdVar2->height + -1;
      if (y_00 <= iVar9) {
        iVar9 = y_00;
      }
      iVar8 = iVar6 - (doc_view->box).height;
      if (iVar8 < 0) {
        iVar8 = 0;
      }
      if (iVar8 <= iVar9) {
        local_30 = iVar9 * 4;
        do {
          plVar5 = *(link **)((int)pdVar2->lines1 + local_30);
          if ((plVar5 != (link *)0x0) &&
             (plVar3 = *(link **)((int)pdVar2->lines2 + local_30), plVar5 <= plVar3)) {
            plVar10 = (link *)0x0;
            do {
              while (((plVar11 = plVar5, plVar11->points->y != iVar9 ||
                      (iVar6 = plVar11->points->x, local_20[0] <= iVar6)) ||
                     ((plVar10 != (link *)0x0 && (iVar6 <= plVar10->points->x))))) {
                plVar5 = plVar11 + 1;
                plVar11 = plVar10;
                if (plVar3 < plVar5) goto LAB_080febe8;
              }
              plVar5 = plVar11 + 1;
              plVar10 = plVar11;
            } while (plVar11 + 1 <= plVar3);
LAB_080febe8:
            if (plVar11 != (link *)0x0) {
              ppVar7 = plVar11->points;
              iVar6 = ppVar7->y;
              iVar9 = pvVar1->y;
              if (iVar6 < iVar9) {
                iVar8 = (doc_view->box).height;
                if (iVar9 < iVar8) {
                  iVar8 = iVar9;
                }
                iVar6 = iVar6 + iVar8;
                pvVar1->y = iVar9 - iVar8;
                ppVar7 = plVar11->points;
              }
              status = move_cursor(ses,doc_view,(ses->tab->x + ppVar7->x) - iVar4,
                                   (iVar6 - y_00) + ses->tab->y);
              iVar6 = doc_view->vs->current_link;
              if (iVar6 < 0) {
                return status;
              }
              if (doc_view->document->nlinks <= iVar6) {
                return status;
              }
              if (doc_view->document->links + iVar6 == plVar11) {
                ses->navigate_mode = NAVIGATE_LINKWISE;
                return status;
              }
              return status;
            }
          }
          iVar9 = iVar9 + -1;
          local_30 = local_30 + -4;
          local_20[0] = 0x7fffffff;
        } while (iVar8 <= iVar9);
        iVar6 = pvVar1->y;
      }
      if (iVar6 != 0) {
        iVar6 = iVar6 - (doc_view->box).height;
        iVar9 = 0;
        if (-1 < iVar6) {
          iVar9 = iVar6;
        }
        pvVar1->y = iVar9;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        return FRAME_EVENT_REFRESH;
      }
    }
  }
  else {
LAB_080fea6d:
    assert_failed = 0;
  }
  status = FRAME_EVENT_OK;
  return status;
}



// WARNING: Unknown calling convention

frame_event_status move_link_down_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  int iVar4;
  link *plVar5;
  int iVar6;
  frame_event_status status;
  int max_y;
  int y;
  int mini;
  int iVar7;
  document *document;
  link *plVar8;
  link *link;
  int iVar9;
  int iVar10;
  window *pwVar11;
  link **local_40;
  int local_38;
  int local_30;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x2a4;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fed70;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      iVar7 = (doc_view->box).height + pvVar1->y;
      if (iVar7 < pdVar2->height) {
        pvVar1->y = iVar7;
        status = FRAME_EVENT_REFRESH;
        return status;
      }
    }
    else {
      iVar3 = pvVar1->y;
      iVar4 = (doc_view->box).height;
      iVar7 = iVar3 + -1 + iVar4 * 2;
      iVar9 = pdVar2->height + -1;
      if (iVar9 < iVar7) {
        iVar7 = iVar9;
      }
      pwVar11 = ses->tab;
      local_38 = pwVar11->y;
      iVar10 = (local_38 + iVar3) - (doc_view->box).y;
      y = iVar10 + 1;
      if (y <= iVar7) {
        local_30 = y * 4;
        local_40 = pdVar2->lines1 + y;
        do {
          plVar5 = *local_40;
          if ((plVar5 != (link *)0x0) &&
             (plVar8 = *(link **)((int)pdVar2->lines2 + local_30), plVar5 <= plVar8)) {
            iVar6 = plVar5->points->y;
            while( true ) {
              if (iVar6 == y) {
                if (iVar4 + iVar3 <= iVar6) {
                  iVar7 = iVar9 - iVar3;
                  if (iVar4 < iVar9 - iVar3) {
                    iVar7 = iVar4;
                  }
                  y = iVar6 - iVar7;
                  pvVar1->y = iVar7 + iVar3;
                  pwVar11 = ses->tab;
                  local_38 = pwVar11->y;
                }
                status = move_cursor(ses,doc_view,pwVar11->x,(y + local_38) - iVar10);
                iVar7 = doc_view->vs->current_link;
                if ((iVar7 < 0) || (doc_view->document->nlinks <= iVar7)) {
                  plVar8 = (link *)0x0;
                }
                else {
                  plVar8 = doc_view->document->links + iVar7;
                }
                if (plVar8 == plVar5) {
                  ses->navigate_mode = NAVIGATE_LINKWISE;
                  return status;
                }
                return status;
              }
              if (plVar8 < plVar5 + 1) break;
              iVar6 = (plVar5[1].points)->y;
              plVar5 = plVar5 + 1;
            }
          }
          y = y + 1;
          local_40 = local_40 + 1;
          local_30 = local_30 + 4;
        } while (y <= iVar7);
      }
      if (iVar4 + iVar3 < pdVar2->height) {
        pvVar1->y = iVar4 + iVar3;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        status = FRAME_EVENT_REFRESH;
        return status;
      }
    }
  }
  else {
LAB_080fed70:
    assert_failed = 0;
  }
  status = FRAME_EVENT_OK;
  return status;
}



// WARNING: Unknown calling convention

frame_event_status move_link_up_line(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  document *pdVar2;
  int iVar3;
  link *plVar4;
  int iVar5;
  frame_event_status status;
  int iVar6;
  int iVar7;
  int y;
  int min_y;
  link *plVar8;
  int iVar9;
  link *link;
  int iVar10;
  document *document;
  link **local_40;
  int local_3c;
  int local_34;
  window *local_30;
  
  if (assert_failed == 0) {
    if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
        (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x263;
      elinks_internal((uchar *)
                      "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
      if (assert_failed != 0) goto LAB_080fefd0;
    }
    else {
      assert_failed = 0;
    }
    pvVar1 = doc_view->vs;
    pdVar2 = doc_view->document;
    if (pdVar2->lines1 == (link **)0x0) {
      if (pvVar1->y != 0) {
        iVar9 = pvVar1->y - (doc_view->box).height;
        pvVar1->y = iVar9;
        if (iVar9 < 0) {
          pvVar1->y = 0;
          status = FRAME_EVENT_REFRESH;
          return status;
        }
        status = FRAME_EVENT_REFRESH;
        return status;
      }
    }
    else {
      iVar9 = pvVar1->y;
      iVar3 = (doc_view->box).height;
      iVar6 = iVar9 - iVar3;
      iVar10 = 0;
      if (-1 < iVar6) {
        iVar10 = iVar6;
      }
      local_30 = ses->tab;
      local_3c = local_30->y;
      y = (local_3c + iVar9) - (doc_view->box).y;
      iVar7 = pdVar2->height + -1;
      if (y <= iVar7) {
        iVar7 = y;
      }
      iVar7 = iVar7 + -1;
      if (iVar10 <= iVar7) {
        local_34 = iVar7 * 4;
        local_40 = pdVar2->lines1 + iVar7;
        do {
          plVar4 = *local_40;
          if ((plVar4 != (link *)0x0) &&
             (plVar8 = *(link **)((int)pdVar2->lines2 + local_34), plVar4 <= plVar8)) {
            iVar5 = plVar4->points->y;
            while( true ) {
              if (iVar5 == iVar7) {
                if (iVar5 < iVar9) {
                  iVar7 = iVar9;
                  if (iVar3 <= iVar9) {
                    iVar7 = iVar3;
                  }
                  pvVar1->y = iVar9 - iVar7;
                  iVar7 = iVar5 + iVar7;
                  local_30 = ses->tab;
                  local_3c = local_30->y;
                }
                status = move_cursor(ses,doc_view,local_30->x,(iVar7 + local_3c) - y);
                iVar9 = doc_view->vs->current_link;
                if ((iVar9 < 0) || (doc_view->document->nlinks <= iVar9)) {
                  plVar8 = (link *)0x0;
                }
                else {
                  plVar8 = doc_view->document->links + iVar9;
                }
                if (plVar8 == plVar4) {
                  ses->navigate_mode = NAVIGATE_LINKWISE;
                  return status;
                }
                return status;
              }
              if (plVar8 < plVar4 + 1) break;
              iVar5 = (plVar4[1].points)->y;
              plVar4 = plVar4 + 1;
            }
          }
          iVar7 = iVar7 + -1;
          local_40 = local_40 + -1;
          local_34 = local_34 + -4;
        } while (iVar10 <= iVar7);
      }
      if (iVar9 != 0) {
        iVar9 = 0;
        if (-1 < iVar6) {
          iVar9 = iVar6;
        }
        pvVar1->y = iVar9;
        ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
        status = FRAME_EVENT_REFRESH;
        return status;
      }
    }
  }
  else {
LAB_080fefd0:
    assert_failed = 0;
  }
  status = FRAME_EVENT_OK;
  return status;
}



// WARNING: Unknown calling convention

frame_event_status move_document_end(session *ses,document_view *doc_view)

{
  int max_height;
  int iVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x1b0;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  max_height = doc_view->document->height - (doc_view->box).height;
  doc_view->vs->x = 0;
  iVar1 = 0;
  if (-1 < max_height) {
    iVar1 = max_height;
  }
  if (doc_view->vs->y < iVar1) {
    doc_view->vs->y = iVar1;
  }
  if (ses->navigate_mode == NAVIGATE_CURSOR_ROUTING) {
    move_cursor(ses,doc_view,ses->tab->x,doc_view->document->height - doc_view->vs->y);
    return FRAME_EVENT_REFRESH;
  }
  find_link_page_up(doc_view);
  return FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

frame_event_status move_document_start(session *ses,document_view *doc_view)

{
  view_state *pvVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
     (doc_view->vs == (view_state *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x19c;
    elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  pvVar1->x = 0;
  pvVar1->y = 0;
  if (ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) {
    find_link_page_down(doc_view);
    return FRAME_EVENT_REFRESH;
  }
  move_cursor(ses,doc_view,(doc_view->box).x,(doc_view->box).y);
  return FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

void toggle_wrap_text(session *ses,document_view *doc_view,int xxxx)

{
  view_state *pvVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (ses->tab == (window *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x1e5;
    elinks_internal((uchar *)"assertion ses && doc_view && ses->tab && ses->tab->term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  if (pvVar1 != (view_state *)0x0) {
    pvVar1->field_0x2c = pvVar1->field_0x2c & 0xfe | (pvVar1->field_0x2c ^ 1) & 1;
    draw_formatted(ses,1);
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)0x0);
  return;
}



// WARNING: Unknown calling convention

void toggle_plain_html(session *ses,document_view *doc_view,int xxxx)

{
  view_state *pvVar1;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (ses->tab == (window *)0x0)) || (ses->tab->term == (terminal *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x1d6;
    elinks_internal((uchar *)"assertion ses && doc_view && ses->tab && ses->tab->term failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  else {
    assert_failed = 0;
  }
  pvVar1 = doc_view->vs;
  if (pvVar1 != (view_state *)0x0) {
    pvVar1->plain = (uint)(pvVar1->plain == 0);
    draw_formatted(ses,1);
    return;
  }
  nowhere_box(ses->tab->term,(uchar *)0x0);
  return;
}



// WARNING: Unknown calling convention

frame_event_status set_frame(session *ses,document_view *doc_view,int xxxx)

{
  if (assert_failed == 0) {
    if ((((ses == (session *)0x0) || (doc_view == (document_view *)0x0)) ||
        (ses->doc_view == (document_view *)0x0)) || (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x1c8;
      elinks_internal((uchar *)"assertion ses && ses->doc_view && doc_view && doc_view->vs failed!")
      ;
      if (assert_failed != 0) goto LAB_080ff630;
    }
    else {
      assert_failed = 0;
    }
    if (ses->doc_view != doc_view) {
      goto_uri(ses,doc_view->vs->uri);
      ses->navigate_mode = NAVIGATE_LINKWISE;
    }
  }
  else {
LAB_080ff630:
    assert_failed = 0;
  }
  return FRAME_EVENT_OK;
}



// WARNING: Unknown calling convention

void move_down(session *ses,document_view *doc_view,int type)

{
  int newpos;
  int iVar1;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x5c;
      elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080ff6c8;
    }
    assert_failed = (int)(ses->navigate_mode != NAVIGATE_LINKWISE);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x5f;
      elinks_internal((uchar *)"assertion ses->navigate_mode == NAVIGATE_LINKWISE failed!");
    }
    newpos = (doc_view->box).height + doc_view->vs->y;
    if (newpos < doc_view->document->height) {
      doc_view->vs->y = newpos;
    }
    iVar1 = current_link_is_visible(doc_view);
    if (iVar1 == 0) {
      if (type != 0) {
        find_link_down(doc_view);
        return;
      }
      find_link_page_down(doc_view);
      return;
    }
  }
  else {
LAB_080ff6c8:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status move_page_down(session *ses,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  int count;
  
  iVar1 = doc_view->vs->y;
  iVar2 = eat_kbd_repeat_count(ses);
  ses->navigate_mode = NAVIGATE_LINKWISE;
  do {
    iVar2 = iVar2 + -1;
    move_down(ses,doc_view,0);
  } while (0 < iVar2);
  return (doc_view->vs->y == iVar1) + FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

void move_up(session *ses,document_view *doc_view,int type)

{
  int iVar1;
  
  if (assert_failed == 0) {
    if (((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
       (doc_view->vs == (view_state *)0x0)) {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x82;
      elinks_internal((uchar *)"assertion ses && doc_view && doc_view->vs failed!");
      if (assert_failed != 0) goto LAB_080ff838;
    }
    assert_failed = (int)(ses->navigate_mode != NAVIGATE_LINKWISE);
    if (assert_failed != 0) {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 0x85;
      elinks_internal((uchar *)"assertion ses->navigate_mode == NAVIGATE_LINKWISE failed!");
    }
    iVar1 = doc_view->vs->y;
    if (iVar1 != 0) {
      doc_view->vs->y = iVar1 - (doc_view->box).height;
      if (doc_view->vs->y < 0) {
        doc_view->vs->y = 0;
      }
      iVar1 = current_link_is_visible(doc_view);
      if (iVar1 == 0) {
        if (type != 0) {
          find_link_up(doc_view);
          return;
        }
        find_link_page_up(doc_view);
        return;
      }
    }
  }
  else {
LAB_080ff838:
    assert_failed = 0;
  }
  return;
}



// WARNING: Unknown calling convention

frame_event_status move_link_dir(session *ses,document_view *doc_view,int dir_x,int dir_y)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int count;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0xee;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  ses->navigate_mode = NAVIGATE_LINKWISE;
  iVar2 = eat_kbd_repeat_count(ses);
  do {
    iVar1 = doc_view->vs->current_link;
    iVar3 = next_link_in_dir(doc_view,dir_x,dir_y);
    if (iVar3 == 0) {
      if (dir_y < 1) {
        if (dir_y == 0) goto LAB_080ff9e0;
        move_up(ses,doc_view,1);
      }
      else {
        move_down(ses,doc_view,1);
      }
      if (doc_view->vs->current_link != iVar1) {
        set_textarea(doc_view,-dir_y);
      }
    }
LAB_080ff9e0:
    iVar2 = iVar2 + -1;
    if (iVar2 < 1) {
      return FRAME_EVENT_REFRESH;
    }
  } while( true );
}



// WARNING: Unknown calling convention

frame_event_status move_page_up(session *ses,document_view *doc_view)

{
  int iVar1;
  int iVar2;
  int count;
  
  iVar1 = doc_view->vs->y;
  iVar2 = eat_kbd_repeat_count(ses);
  ses->navigate_mode = NAVIGATE_LINKWISE;
  do {
    iVar2 = iVar2 + -1;
    move_up(ses,doc_view,0);
  } while (0 < iVar2);
  return (doc_view->vs->y == iVar1) + FRAME_EVENT_REFRESH;
}



// WARNING: Unknown calling convention

frame_event_status
move_link(session *ses,document_view *doc_view,int direction,int wraparound_bound,
         int wraparound_link)

{
  int iVar1;
  option_value *poVar2;
  int iVar3;
  int iVar4;
  int current_link;
  int count;
  list_head_elinks *local_20;
  
  if (assert_failed != 0) {
    assert_failed = 0;
    return FRAME_EVENT_OK;
  }
  if ((((doc_view == (document_view *)0x0) || (ses == (session *)0x0)) ||
      (doc_view->vs == (view_state *)0x0)) || (doc_view->document == (document *)0x0)) {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0xac;
    elinks_internal((uchar *)
                    "assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return FRAME_EVENT_OK;
    }
  }
  else {
    assert_failed = 0;
  }
  ses->navigate_mode = NAVIGATE_LINKWISE;
  if (doc_view->document->nlinks < 2) {
    local_20 = (list_head_elinks *)0x0;
    wraparound_bound = -1;
  }
  else {
    poVar2 = get_opt_();
    local_20 = poVar2->tree;
  }
  iVar3 = eat_kbd_repeat_count(ses);
  do {
    while( true ) {
      iVar1 = doc_view->vs->current_link;
      if (iVar1 == wraparound_bound) break;
      iVar4 = next_link_in_view_y(doc_view,direction + iVar1,direction);
      if (iVar4 == 0) {
        doc_view->vs->current_link = iVar1;
        if (direction < 1) goto LAB_080ffbf0;
LAB_080ffb8d:
        move_down(ses,doc_view,1);
LAB_080ffb9c:
        if ((iVar1 != wraparound_bound) && (doc_view->vs->current_link != iVar1)) {
          set_textarea(doc_view,-direction);
        }
      }
      iVar3 = iVar3 + -1;
      if (iVar3 < 1) {
        return FRAME_EVENT_REFRESH;
      }
    }
    if (local_20 == (list_head_elinks *)0x0) {
      doc_view->vs->current_link = iVar1;
      if (0 < direction) goto LAB_080ffb8d;
LAB_080ffbf0:
      move_up(ses,doc_view,1);
      goto LAB_080ffb9c;
    }
    iVar3 = iVar3 + -1;
    jump_to_link_number(ses,doc_view,wraparound_link);
    if (iVar3 < 1) {
      return FRAME_EVENT_REFRESH;
    }
  } while( true );
}



// WARNING: Unknown calling convention

void detach_formatted(document_view *doc_view)

{
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(doc_view == (document_view *)0x0);
  if (assert_failed != 0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x42;
    elinks_internal((uchar *)"assertion doc_view failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (doc_view->document != (document *)0x0) {
    release_document(doc_view->document);
    doc_view->document = (document *)0x0;
  }
  if (doc_view->vs != (view_state *)0x0) {
    doc_view->vs->doc_view = (document_view *)0x0;
    doc_view->vs = (view_state *)0x0;
  }
  if (doc_view->name != (uchar *)0x0) {
    mem_free(doc_view->name);
  }
  doc_view->name = (uchar *)0x0;
  return;
}



// WARNING: Unknown calling convention

void send_event(session *ses,term_event *ev)

{
  term_event_modifier_T *ptVar1;
  byte bVar2;
  term_event_modifier_T tVar3;
  list_head_elinks *plVar4;
  terminal *term;
  uint uVar5;
  void *pvVar6;
  main_action action_id_00;
  option_value *poVar7;
  document_view *pdVar8;
  window *m;
  int iVar9;
  window *pwVar10;
  window *current_tab;
  int iVar11;
  frame_event_status fVar12;
  document_view *doc_view_00;
  window *pwVar13;
  window *win;
  int y;
  uint uVar14;
  window *pwVar15;
  main_action action_id;
  document_view *doc_view;
  document_view *doc_view_1;
  term_event_mouse *ptVar16;
  byte bVar17;
  char *pcVar18;
  int local_48;
  int local_44;
  term_event evv;
  int local_20 [4];
  
  bVar17 = 0;
  if (assert_failed != 0) {
    assert_failed = 0;
    return;
  }
  assert_failed = (int)(ev == (term_event *)0x0 || ses == (session *)0x0);
  if (ev == (term_event *)0x0 || ses == (session *)0x0) {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 0x5f8;
    elinks_internal((uchar *)"assertion ses && ev failed!");
    if (assert_failed != 0) {
      assert_failed = 0;
      return;
    }
  }
  if (ev->ev == EVENT_KBD) {
    pdVar8 = current_frame(ses);
    if ((pdVar8 != (document_view *)0x0) &&
       (fVar12 = send_to_frame(ses,pdVar8,ev), fVar12 != FRAME_EVENT_IGNORED)) {
      return;
    }
    action_id_00 = kbd_action(KEYMAP_MAIN,ev,local_20);
    if ((action_id_00 == ACT_MAIN_QUIT) && ((ev->info).mouse.x == -0x200)) {
      action_id_00 = ACT_MAIN_REALLY_QUIT;
    }
    while( true ) {
      fVar12 = do_action(ses,action_id_00,0);
      if (fVar12 != FRAME_EVENT_IGNORED) {
        if (fVar12 < FRAME_EVENT_SESSION_DESTROYED) goto LAB_080ffd46;
        if (fVar12 == FRAME_EVENT_SESSION_DESTROYED) {
          return;
        }
      }
      if (action_id_00 == ACT_MAIN_SCRIPTING_FUNCTION) {
        trigger_event(local_20[0],ses);
        return;
      }
      if ((ev->info).mouse.x != -0x200) break;
      action_id_00 = ACT_MAIN_REALLY_QUIT;
    }
    tVar3 = (ev->info).keyboard.modifier;
    if (tVar3 != KBD_MOD_ALT) {
      if ((tVar3 & KBD_MOD_CTRL) != KBD_MOD_NONE) {
        return;
      }
      if (pdVar8 != (document_view *)0x0) {
        pcVar18 = "document.browse.search.typeahead";
        poVar7 = get_opt_();
        plVar4 = poVar7->tree;
        if (plVar4 == (list_head_elinks *)0x1) {
          action_id_00 = ACT_MAIN_SEARCH_TYPEAHEAD_LINK;
        }
        else if (plVar4 == (list_head_elinks *)0x2) {
          action_id_00 = ACT_MAIN_SEARCH_TYPEAHEAD_TEXT;
        }
        else {
          if (plVar4 == (list_head_elinks *)0x0) {
            return;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
          errline = 0x59f;
          elinks_internal((uchar *)"invalid value for document.browse.search.typeahead",pcVar18);
        }
        search_typeahead(ses,pdVar8,action_id_00);
        term_send_event(ses->tab->term,ev);
        return;
      }
      return;
    }
    (ev->info).mouse.y = 0;
    activate_bfu_technology(ses,-1);
    pwVar10 = (window *)(ses->tab->term->windows).next;
    (*pwVar10->handler)(pwVar10,ev);
    pwVar15 = ses->tab;
    pwVar13 = (window *)(pwVar15->term->windows).next;
    if (pwVar10 == pwVar13) {
      deselect_mainmenu(pwVar13->term,(menu *)pwVar13->data);
      print_screen_status(ses);
      pwVar15 = ses->tab;
      pwVar13 = (window *)(pwVar15->term->windows).next;
    }
    if (pwVar15 != pwVar13) {
      return;
    }
    ptVar1 = &(ev->info).keyboard.modifier;
    *ptVar1 = *ptVar1 | KBD_MOD_ALT;
    if (((pdVar8 != (document_view *)0x0) && (poVar7 = get_opt_(), poVar7->number < 1)) &&
       (fVar12 = try_document_key(ses,pdVar8,ev), fVar12 == FRAME_EVENT_REFRESH)) {
      refresh_view(ses,pdVar8,0);
      return;
    }
LAB_080ffd46:
    if (ses != (session *)0x0) {
      (ses->kbdprefix).repeat_count = 0;
    }
    return;
  }
  if (ev->ev != EVENT_MOUSE) goto LAB_080ffd46;
  pdVar8 = current_frame(ses);
  term = ses->tab->term;
  uVar14 = (ev->info).mouse.y;
  if (((uVar14 == 0) && (uVar5 = (ev->info).mouse.button, (uVar5 & 0x20) == 0)) && ((uVar5 & 7) < 3)
     ) {
    activate_bfu_technology(ses,-1);
    pvVar6 = (term->windows).next;
    (**(code **)((int)pvVar6 + 0xc))(pvVar6,ev);
    goto LAB_080ffd46;
  }
  bVar2 = *(byte *)&ses->status;
  if ((bVar2 & 1) != 0) {
    if (((ses->status).field_0x34 & 4) == 0) {
      y = (term->height + -1) - (bVar2 >> 1 & 1);
    }
    else {
      y = bVar2 >> 2 & 1;
    }
    if (uVar14 == y) {
      iVar9 = get_tab_number_by_xpos(term,(ev->info).mouse.x);
      pwVar10 = get_tab_by_number(term,term->current_tab);
      uVar14 = (ev->info).mouse.button;
      if ((uVar14 & 0x20) == 0) {
        if ((uVar14 & 7) == 3) {
          switch_current_tab(ses,-1);
        }
        else if ((uVar14 & 7) == 4) {
          switch_current_tab(ses,1);
        }
        else if (iVar9 != -1) {
          switch_to_tab(term,iVar9,-1);
          uVar14 = (ev->info).mouse.button & 7;
          if (uVar14 == 1) {
            ptVar16 = &term->prev_mouse_event;
            for (iVar9 = 3; iVar9 != 0; iVar9 = iVar9 + -1) {
              ptVar16->x = 0;
              ptVar16 = (term_event_mouse *)((int)ptVar16 + (uint)bVar17 * -8 + 4);
            }
          }
          else if (uVar14 == 2) {
            tab_menu((session *)pwVar10->data,(ev->info).mouse.x,(ev->info).mouse.y,1);
          }
        }
      }
      else if ((((uVar14 & 7) == 1) && (iVar9 == term->current_tab)) &&
              ((ev->info).mouse.y == (term->prev_mouse_event).y)) {
        if (ses == (session *)pwVar10->data) {
          ses = (session *)0x0;
        }
        close_tab(term,(session *)pwVar10->data);
      }
      goto LAB_080ffd46;
    }
  }
  if (assert_failed == 0) {
    assert_failed = 0;
    doc_view_00 = pdVar8;
    if (pdVar8 == (document_view *)0x0) goto LAB_08100117;
    do {
      if ((doc_view_00 == (document_view *)0x0) || (doc_view_00->document == (document *)0x0)) {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x51c;
        elinks_internal((uchar *)"assertion doc_view && doc_view->document failed!");
        if (assert_failed != 0) break;
      }
      if (((doc_view_00->document->options).box.x == (doc_view_00->box).x) &&
         ((doc_view_00->document->options).box.y == (doc_view_00->box).y)) {
        assert_failed = 0;
      }
      else {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
        errline = 0x521;
        elinks_internal((uchar *)
                        "assertion doc_view->document->options.box.x == doc_view->box.x && doc_view->document->options.box.y == doc_view->box.y failed: Jonas\' 1.565 -> 1.566 patch sucks"
                       );
        if (assert_failed != 0) break;
      }
      local_48 = (ev->info).mouse.y;
      iVar9 = (ev->info).mouse.x;
      iVar11 = (doc_view_00->box).x;
      if ((((iVar11 <= iVar9) && (local_44 = (doc_view_00->box).y, local_44 <= local_48)) &&
          (iVar9 < (doc_view_00->box).width + iVar11)) &&
         (local_48 < local_44 + (doc_view_00->box).height)) {
        if (pdVar8 != doc_view_00) {
          draw_formatted(ses,0);
          local_48 = (ev->info).mouse.y;
          local_44 = (doc_view_00->box).y;
          iVar9 = (ev->info).mouse.x;
          iVar11 = (doc_view_00->box).x;
        }
        evv.info.mouse.x = iVar9 - iVar11;
        evv.info.mouse.y = local_48 - local_44;
        evv.ev = EVENT_MOUSE;
        evv.info.mouse.button = (ev->info).mouse.button;
        fVar12 = send_to_frame(ses,doc_view_00,&evv);
        if (fVar12 == FRAME_EVENT_IGNORED) goto LAB_08100117;
        goto LAB_08100126;
      }
      next_frame(ses,1);
      doc_view_00 = current_frame(ses);
      if (pdVar8 == doc_view_00) goto LAB_08100117;
    } while (assert_failed == 0);
  }
  assert_failed = 0;
LAB_08100117:
  if (((ev->info).mouse.button & 7) == 2) {
    tab_menu(ses,(ev->info).mouse.x,(ev->info).mouse.y,0);
    return;
  }
LAB_08100126:
  if (((ses->status).field_0x8 & 1) == 0) {
    return;
  }
  if ((ev->info).mouse.y == term->height + -1) {
    if (term->width + -9 <= (ev->info).mouse.x) {
      menu_leds_info(term,(void *)0x0,(void *)0x0);
      return;
    }
    return;
  }
  return;
}



// WARNING: Unknown calling convention

void next_frame(session *ses,int p)

{
  document *pdVar1;
  location *plVar2;
  int iVar3;
  document_view *doc_view;
  int **ppiVar4;
  int iVar5;
  int iVar6;
  int n;
  list_head_elinks *plVar7;
  
  if (((ses->history).current != (location *)0x0) &&
     ((ses->doc_view == (document_view *)0x0 ||
      ((pdVar1 = ses->doc_view->document, pdVar1 != (document *)0x0 &&
       (pdVar1->frame_desc != (frameset_desc *)0x0)))))) {
    ppiVar4 = (int **)(ses->scrn_frames).next;
    ses->navigate_mode = NAVIGATE_LINKWISE;
    plVar2 = (ses->history).current;
    plVar7 = &ses->scrn_frames;
    if (plVar7 == (list_head_elinks *)ppiVar4) {
      iVar5 = p + (plVar2->vs).current_link;
      iVar6 = 1;
      (plVar2->vs).current_link = iVar5;
    }
    else {
      iVar6 = 0;
      do {
        while ((ppiVar4[5] == (int *)0x0 || (ppiVar4[5][0x32] == 0))) {
          ppiVar4 = (int **)*ppiVar4;
          iVar6 = iVar6 + 1;
          if (plVar7 == (list_head_elinks *)ppiVar4) goto LAB_08100470;
        }
        ppiVar4 = (int **)*ppiVar4;
      } while (plVar7 != (list_head_elinks *)ppiVar4);
LAB_08100470:
      iVar5 = p + (plVar2->vs).current_link;
      if (iVar6 == 0) {
        iVar6 = 1;
      }
      (plVar2->vs).current_link = iVar5;
    }
    if (iVar5 < 0) {
      iVar3 = iVar5 + iVar6;
      do {
        iVar5 = iVar3;
        iVar3 = iVar5 + iVar6;
      } while ((iVar5 + iVar6) - iVar6 < 0);
      (plVar2->vs).current_link = iVar5;
    }
    (plVar2->vs).current_link = iVar5 % iVar6;
  }
  return;
}



// WARNING: Unknown calling convention

void check_vs(document_view *doc_view)

{
  view_state *pvVar1;
  link *plVar2;
  int iVar3;
  int iVar4;
  view_state *vs;
  link *links;
  
  pvVar1 = doc_view->vs;
  iVar4 = doc_view->document->nlinks + -1;
  iVar3 = pvVar1->current_link;
  if (iVar4 < pvVar1->current_link) {
    pvVar1->current_link = iVar4;
    iVar3 = iVar4;
  }
  if (iVar3 != -1) {
    iVar3 = current_link_is_visible(doc_view);
    if (iVar3 == 0) {
      plVar2 = doc_view->document->links;
      set_pos_x(doc_view,plVar2 + pvVar1->current_link);
      set_pos_y(doc_view,plVar2 + pvVar1->current_link);
    }
    return;
  }
  find_link_page_down(doc_view);
  return;
}



// WARNING: Unknown calling convention

void copy_vs(view_state *dst,view_state *src)

{
  object *poVar1;
  list_head_elinks *plVar2;
  undefined4 uVar3;
  uri *puVar4;
  undefined4 *puVar5;
  void *pvVar6;
  uchar *src_00;
  int iVar7;
  void **ppvVar8;
  form_state *__dest;
  int i;
  form_view **ppfVar9;
  form_view *pfVar10;
  int iVar11;
  form_state *srcfs;
  int *piVar12;
  form_view *fv;
  int iVar13;
  
  dst->doc_view = src->doc_view;
  dst->uri = src->uri;
  (dst->forms).next = (src->forms).next;
  (dst->forms).prev = (src->forms).prev;
  dst->form_info = src->form_info;
  dst->form_info_len = src->form_info_len;
  dst->x = src->x;
  dst->y = src->y;
  dst->current_link = src->current_link;
  dst->old_current_link = src->old_current_link;
  dst->plain = src->plain;
  uVar3 = *(undefined4 *)&src->field_0x2c;
  dst->form_info = (form_state *)0x0;
  dst->doc_view = (document_view *)0x0;
  *(undefined4 *)&dst->field_0x2c = uVar3;
  puVar4 = src->uri;
  poVar1 = &puVar4->object;
  poVar1->refcount = poVar1->refcount + 1;
  dst->uri = puVar4;
  plVar2 = &dst->forms;
  dst->field_0x2c = dst->field_0x2c & 0xfd | (*(short *)&src->uri->field_0x34 == 0) * '\x02';
  (dst->forms).prev = plVar2;
  (dst->forms).next = plVar2;
  for (puVar5 = (undefined4 *)(src->forms).next; (list_head_elinks *)puVar5 != &src->forms;
      puVar5 = (undefined4 *)*puVar5) {
    ppvVar8 = (void **)mem_calloc(1,0xc);
    if (ppvVar8 != (void **)0x0) {
      ppvVar8[2] = (void *)puVar5[2];
      pvVar6 = plVar2->next;
      ppvVar8[1] = plVar2;
      *ppvVar8 = pvVar6;
      plVar2->next = ppvVar8;
      *(void ***)((int)*ppvVar8 + 4) = ppvVar8;
    }
  }
  if (src->form_info_len != 0) {
    __dest = (form_state *)mem_alloc(src->form_info_len * 0x24);
    dst->form_info = __dest;
    if ((__dest != (form_state *)0x0) &&
       (memcpy(__dest,src->form_info,src->form_info_len * 0x24), 0 < src->form_info_len)) {
      iVar13 = 0;
      iVar11 = 0;
      do {
        piVar12 = (int *)((int)&src->form_info->form_view + iVar13);
        ppfVar9 = (form_view **)((int)&dst->form_info->form_view + iVar13);
        src_00 = (uchar *)piVar12[4];
        if (src_00 != (uchar *)0x0) {
          pfVar10 = (form_view *)stracpy(src_00);
          ppfVar9[4] = pfVar10;
        }
        iVar7 = *piVar12;
        pfVar10 = (form_view *)0x0;
        if (iVar7 != 0) {
          pfVar10 = find_form_view_in_vs(dst,*(int *)(iVar7 + 8));
        }
        iVar11 = iVar11 + 1;
        iVar13 = iVar13 + 0x24;
        *ppfVar9 = pfVar10;
      } while (src->form_info_len != iVar11 && iVar11 <= src->form_info_len);
      return;
    }
  }
  return;
}



// WARNING: Unknown calling convention

void destroy_vs(view_state *vs,int blast_ecmascript)

{
  form_view *fv_00;
  form_view *pfVar1;
  form_view *pfVar2;
  int iVar3;
  form_view *fv;
  form_view *next;
  
  iVar3 = vs->form_info_len;
  while (0 < iVar3) {
    done_form_state(vs->form_info + iVar3 + -1);
    iVar3 = vs->form_info_len + -1;
    vs->form_info_len = iVar3;
  }
  if (vs->form_info != (form_state *)0x0) {
    mem_free(vs->form_info);
  }
  fv_00 = (form_view *)(vs->forms).next;
  vs->form_info = (form_state *)0x0;
  pfVar2 = fv_00->next;
  while (pfVar1 = pfVar2, fv_00 != (form_view *)&vs->forms) {
    pfVar1->prev = fv_00->prev;
    fv_00->prev->next = fv_00->next;
    done_form_view(fv_00);
    pfVar2 = pfVar1->next;
    fv_00 = pfVar1;
  }
  if (vs->uri != (uri *)0x0) {
    done_uri(vs->uri);
  }
  if (vs->doc_view != (document_view *)0x0) {
    vs->doc_view->vs = (view_state *)0x0;
    vs->doc_view = (document_view *)0x0;
  }
  return;
}



// WARNING: Unknown calling convention

void init_vs(view_state *vs,uri *uri,int plain)

{
  uri *puVar1;
  int iVar2;
  view_state *pvVar3;
  
  pvVar3 = vs;
  for (iVar2 = 0xc; iVar2 != 0; iVar2 = iVar2 + -1) {
    pvVar3->doc_view = (document_view *)0x0;
    pvVar3 = (view_state *)&pvVar3->uri;
  }
  vs->current_link = -1;
  vs->old_current_link = -1;
  vs->plain = plain;
  puVar1 = (uri *)0x0;
  if (uri != (uri *)0x0) {
    (uri->object).refcount = (uri->object).refcount + 1;
    puVar1 = uri;
  }
  vs->uri = puVar1;
  vs->field_0x2c = vs->field_0x2c & 0xfd | (*(short *)&uri->field_0x34 == 0) * '\x02';
  (vs->forms).prev = &vs->forms;
  (vs->forms).next = &vs->forms;
  return;
}



undefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  int iVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  bool bVar9;
  byte bStack_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  
  local_14 = param_3;
  local_10 = param_4;
  local_18 = 0;
  if ((int)param_2 < 0) {
    bVar9 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar9);
    local_18 = 0xffffffff;
  }
  if ((int)param_4 < 0) {
    local_14 = -param_3;
    local_18 = ~local_18;
    local_10 = -(param_4 + (param_3 != 0));
  }
  if (local_10 == 0) {
    if (param_2 < local_14) {
      uVar8 = 0;
      iVar5 = (int)(CONCAT44(param_2,param_1) / (ulonglong)local_14);
    }
    else {
      if (local_14 == 0) {
        local_14 = (uint)(1 / 0);
      }
      uVar8 = param_2 / local_14;
      iVar5 = (int)(((ulonglong)param_2 % (ulonglong)local_14 << 0x20 | (ulonglong)param_1) /
                   (ulonglong)local_14);
    }
    goto LAB_08100860;
  }
  if (local_10 <= param_2) {
    uVar8 = 0x1f;
    if (local_10 != 0) {
      for (; local_10 >> uVar8 == 0; uVar8 = uVar8 - 1) {
      }
    }
    if ((uVar8 ^ 0x1f) != 0) {
      bStack_1c = (byte)(uVar8 ^ 0x1f);
      bVar6 = 0x20 - bStack_1c;
      uVar1 = (ulonglong)(local_14 >> (bVar6 & 0x1f) | local_10 << (bStack_1c & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar6 & 0x1f),
                       param_2 << (bStack_1c & 0x1f) | param_1 >> (bVar6 & 0x1f));
      uVar3 = uVar2 / uVar1;
      iVar5 = (int)uVar3;
      uVar8 = (uint)(uVar2 % uVar1);
      lVar4 = (uVar3 & 0xffffffff) * (ulonglong)(local_14 << (bStack_1c & 0x1f));
      uVar7 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar8 < uVar7) || ((param_1 << (bStack_1c & 0x1f) < (uint)lVar4 && (uVar8 == uVar7)))) {
        iVar5 = iVar5 + -1;
        uVar8 = 0;
      }
      else {
        uVar8 = 0;
      }
      goto LAB_08100860;
    }
    if ((local_14 <= param_1) || (local_10 < param_2)) {
      uVar8 = 0;
      iVar5 = 1;
      goto LAB_08100860;
    }
  }
  uVar8 = 0;
  iVar5 = 0;
LAB_08100860:
  if (local_18 != 0) {
    bVar9 = iVar5 != 0;
    iVar5 = -iVar5;
    uVar8 = -(uVar8 + bVar9);
  }
  return CONCAT44(uVar8,iVar5);
}



undefined8 __moddi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  bool bVar7;
  int local_30;
  byte local_2c;
  uint local_28;
  uint local_24;
  uint local_20;
  uint local_10;
  
  local_24 = param_3;
  local_20 = param_4;
  local_30 = 0;
  if ((int)param_2 < 0) {
    bVar7 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(param_2 + bVar7);
    local_30 = -1;
  }
  if ((int)param_4 < 0) {
    local_24 = -param_3;
    local_20 = -(param_4 + (param_3 != 0));
  }
  uVar4 = local_24;
  local_28 = local_24;
  if (local_20 == 0) {
    if (param_2 < local_24) {
      param_1 = (uint)(CONCAT44(param_2,param_1) % (ulonglong)local_24);
    }
    else {
      if (local_24 == 0) {
        local_28 = (uint)(1 / 0);
      }
      param_1 = (uint)(((ulonglong)param_2 % (ulonglong)local_28 << 0x20 | (ulonglong)param_1) %
                      (ulonglong)local_28);
    }
    local_10 = 0;
  }
  else {
    local_10 = param_2;
    if (local_20 <= param_2) {
      uVar3 = 0x1f;
      if (local_20 != 0) {
        for (; local_20 >> uVar3 == 0; uVar3 = uVar3 - 1) {
        }
      }
      if ((uVar3 ^ 0x1f) == 0) {
        if ((local_24 <= param_1) || (local_20 < param_2)) {
          bVar7 = param_1 < local_24;
          param_1 = param_1 - local_24;
          local_10 = (param_2 - local_20) - (uint)bVar7;
        }
      }
      else {
        local_24._0_1_ = (byte)(uVar3 ^ 0x1f);
        local_2c = 0x20 - (byte)local_24;
        uVar3 = uVar4 >> (local_2c & 0x1f) | local_20 << ((byte)local_24 & 0x1f);
        uVar4 = uVar4 << ((byte)local_24 & 0x1f);
        uVar1 = CONCAT44(param_2 >> (local_2c & 0x1f),
                         param_1 >> (local_2c & 0x1f) | param_2 << ((byte)local_24 & 0x1f));
        uVar5 = (uint)(uVar1 % (ulonglong)uVar3);
        param_1 = param_1 << ((byte)local_24 & 0x1f);
        lVar2 = (uVar1 / uVar3 & 0xffffffff) * (ulonglong)uVar4;
        uVar6 = (uint)((ulonglong)lVar2 >> 0x20);
        if ((uVar5 < uVar6) || ((param_1 < (uint)lVar2 && (uVar5 == uVar6)))) {
          lVar2 = lVar2 - CONCAT44(uVar3,uVar4);
        }
        local_10 = (uVar5 - (int)((ulonglong)lVar2 >> 0x20)) - (uint)(param_1 < (uint)lVar2);
        param_1 = local_10 << (local_2c & 0x1f) | param_1 - (uint)lVar2 >> ((byte)local_24 & 0x1f);
        local_10 = local_10 >> ((byte)local_24 & 0x1f);
      }
    }
  }
  if (local_30 == 0) {
    return CONCAT44(local_10,param_1);
  }
  return CONCAT44(-(local_10 + (param_1 != 0)),-param_1);
}



ulonglong __udivdi3(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  ulonglong uVar2;
  ulonglong uVar3;
  longlong lVar4;
  byte bVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  byte bStack_10;
  
  if (param_4 == 0) {
    if (param_2 < param_3) {
      return CONCAT44(param_2,param_1) / (ulonglong)param_3 & 0xffffffff;
    }
    if (param_3 == 0) {
      param_3 = (uint)(1 / 0);
    }
    return CONCAT44(param_2 / param_3,
                    (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                         (ulonglong)param_3));
  }
  if (param_4 <= param_2) {
    uVar6 = 0x1f;
    if (param_4 != 0) {
      for (; param_4 >> uVar6 == 0; uVar6 = uVar6 - 1) {
      }
    }
    if ((uVar6 ^ 0x1f) != 0) {
      bStack_10 = (byte)(uVar6 ^ 0x1f);
      bVar5 = 0x20 - bStack_10;
      uVar1 = (ulonglong)(param_3 >> (bVar5 & 0x1f) | param_4 << (bStack_10 & 0x1f));
      uVar2 = CONCAT44(param_2 >> (bVar5 & 0x1f),
                       param_2 << (bStack_10 & 0x1f) | param_1 >> (bVar5 & 0x1f));
      uVar3 = uVar2 / uVar1;
      uVar6 = (uint)uVar3;
      uVar7 = (uint)(uVar2 % uVar1);
      lVar4 = (uVar3 & 0xffffffff) * (ulonglong)(param_3 << (bStack_10 & 0x1f));
      uVar8 = (uint)((ulonglong)lVar4 >> 0x20);
      if ((uVar7 < uVar8) || ((param_1 << (bStack_10 & 0x1f) < (uint)lVar4 && (uVar7 == uVar8)))) {
        return (ulonglong)(uVar6 - 1);
      }
      goto LAB_08100bc4;
    }
    if ((param_3 <= param_1) || (param_4 < param_2)) {
      uVar6 = 1;
      goto LAB_08100bc4;
    }
  }
  uVar6 = 0;
LAB_08100bc4:
  return (ulonglong)uVar6;
}



void __libc_csu_fini(void)

{
  return;
}



// WARNING: Function: __i686.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx
// WARNING: Removing unreachable block (ram,0x08100cbe)
// WARNING: Removing unreachable block (ram,0x08100cc0)

void __libc_csu_init(void)

{
  _init();
  return;
}



// WARNING: This is an inlined function

void __i686_get_pc_thunk_bx(void)

{
  return;
}



// WARNING: Removing unreachable block (ram,0x08100d01)
// WARNING: Removing unreachable block (ram,0x08100d08)

void __do_global_ctors_aux(void)

{
  return;
}



void _fini(void)

{
  __do_global_dtors_aux();
  return;
}


