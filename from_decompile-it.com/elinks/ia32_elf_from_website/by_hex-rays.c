/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int sub_8058BF8();
// int fileno(FILE *stream);
// int fputs(const char *s, FILE *stream);
// void abort(void);
// int *__errno_location(void);
// int __cdecl gnutls_mac_get(_DWORD); weak
// const char *inet_ntop(int af, const void *cp, char *buf, socklen_t len);
// int gnutls_global_init(void); weak
// FILE *popen(const char *command, const char *modes);
// void srand(unsigned int seed);
// size_t __argz_count(const char *argz, size_t len);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// int __cdecl rb_define_global_function(_DWORD, _DWORD, _DWORD); weak
// __pid_t getpid(void);
// int __cdecl gss_release_name(_DWORD, _DWORD); weak
// int mkdir(const char *path, __mode_t mode);
// char *strerror(int errnum);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int sysconf(int name);
// int memcmp(const void *s1, const void *s2, size_t n);
// int __cdecl gnutls_certificate_type_get_name(_DWORD); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// void freeaddrinfo(struct addrinfo *ai);
// int __cdecl gnutls_record_recv(_DWORD, _DWORD, _DWORD); weak
// XML_Parser XML_ParserCreate(const XML_Char *encoding);
// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int inflateEnd(z_streamp strm);
// int __cdecl gss_release_buffer(_DWORD, _DWORD); weak
// int __isoc99_fscanf(_DWORD, const char *, ...); weak
// int __cdecl gnutls_record_send(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gnutls_handshake(_DWORD); weak
// int __fprintf_chk(_DWORD, _DWORD, const char *, ...); weak
// int __cdecl gnutls_protocol_get_name(_DWORD); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl gnutls_certificate_set_x509_trust_file(_DWORD, _DWORD, _DWORD); weak
// void *realloc(void *ptr, size_t size);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int __cdecl gnutls_compression_get(_DWORD); weak
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// struct tm *localtime(const time_t *timer);
// void __argz_stringify(char *argz, size_t len, int sep);
// int __printf_chk(_DWORD, const char *, ...); weak
// double strtod(const char *nptr, char **endptr);
// char *strchr(const char *s, int c);
// char *getenv(const char *name);
// void *calloc(size_t nmemb, size_t size);
// int __cdecl gnutls_certificate_allocate_credentials(_DWORD); weak
// int system(const char *command);
// char *strncpy(char *dest, const char *src, size_t n);
// int __cdecl gnutls_transport_set_ptr(_DWORD, _DWORD); weak
// int ruby_init(void); weak
// int __cdecl mremap(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gnutls_certificate_set_verify_flags(_DWORD, _DWORD); weak
// ssize_t write(int fd, const void *buf, size_t n);
// int listen(int fd, int n);
// int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// enum XML_Error XML_GetErrorCode(XML_Parser parser);
// char *fgets(char *s, int n, FILE *stream);
// int rename(const char *old, const char *new);
// int __cdecl rb_protect(_DWORD, _DWORD, _DWORD); weak
// void *memset(void *s, int c, size_t n);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int ruby_init_loadpath(void); weak
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int execl(const char *path, const char *arg, ...);
// int _IO_getc(_IO_FILE *fp);
// int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// void _exit(int status);
// char *strrchr(const char *s, int c);
// int uname(struct utsname *name);
// int tcgetattr(int fd, struct termios *termios_p);
// int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __vsnprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl rb_str_new(_DWORD, _DWORD); weak
// int __cdecl idna_to_ascii_lz(_DWORD, _DWORD, _DWORD); weak
// XML_Size XML_GetCurrentColumnNumber(XML_Parser parser);
// int __cdecl gnutls_cipher_set_priority(_DWORD, _DWORD); weak
// ssize_t read(int fd, void *buf, size_t nbytes);
// int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size);
// int __cdecl __strcat_chk(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gnutls_anon_free_client_credentials(_DWORD); weak
// int __cdecl gnutls_credentials_set(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gnutls_cipher_get_name(_DWORD); weak
// int ungetc(int c, FILE *stream);
// int __cdecl gnutls_init(_DWORD, _DWORD); weak
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int inflate(z_streamp strm, int flush);
// int strtol(const char *nptr, char **endptr, int base);
// FILE *fdopen(int fd, const char *modes);
// const __int32_t **__ctype_toupper_loc(void);
// void free(void *ptr);
// int __cdecl rb_define_singleton_method(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int inet_pton(int af, const char *cp, void *buf);
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// char **backtrace_symbols(void *const *array, int size);
// int __cdecl fgets_unlocked(_DWORD, _DWORD, _DWORD); weak
// int setpgid(__pid_t pid, __pid_t pgid);
// int access(const char *name, int type);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int fflush(FILE *stream);
// int __cdecl __vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// DIR *opendir(const char *name);
// int __cdecl rb_define_module(_DWORD); weak
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int ioctl(int fd, unsigned int request, ...);
// int socket(int domain, int type, int protocol);
// int dup2(int fd, int fd2);
// const unsigned __int16 **__ctype_b_loc(void);
// int isatty(int fd);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// __mode_t umask(__mode_t mask);
// int fclose(FILE *stream);
// __int64 __cdecl ftello64(_DWORD); weak
// time_t mktime(struct tm *tp);
// int fsync(int fd);
// int __cdecl readdir64(_DWORD); weak
// void *tfind(const void *key, void *const *rootp, __compar_fn_t compar);
// void *memcpy(void *dest, const void *src, size_t n);
// int __cdecl gnutls_kx_set_priority(_DWORD, _DWORD); weak
// int utime(const char *file, const struct utimbuf *file_times);
// int __cdecl gnutls_protocol_set_priority(_DWORD, _DWORD); weak
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// size_t strlen(const char *s);
// int __cdecl gnutls_protocol_get_version(_DWORD); weak
// int __cdecl gnutls_deinit(_DWORD); weak
// int __cdecl rb_load_protect(_DWORD, _DWORD, _DWORD); weak
// unsigned int alarm(unsigned int seconds);
// int __cdecl gnutls_anon_allocate_client_credentials(_DWORD); weak
// int __cdecl rb_class_path(_DWORD); weak
// int unlink(const char *name);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// struct passwd *getpwuid(__uid_t uid);
// int BZ2_bzDecompress(bz_stream *strm);
// int getifaddrs(struct ifaddrs **ifap);
// char *setlocale(int category, const char *locale);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// int feof(FILE *stream);
// char *strcpy(char *dest, const char *src);
// __gid_t getegid(void);
// XML_Size XML_GetCurrentLineNumber(XML_Parser parser);
// int __cdecl rb_inspect(_DWORD); weak
// int chdir(const char *path);
// int __cdecl gnutls_mac_get_name(_DWORD); weak
// int __cdecl ruby_script(_DWORD); weak
// char *ctime(const time_t *timer);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int raise(int sig);
// int __cdecl gnutls_certificate_verify_peers(_DWORD); weak
// int Gpm_GetEvent(Gpm_Event *);
// int __cdecl mkstemp64(_DWORD); weak
// int __cdecl gnutls_compression_get_name(_DWORD); weak
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int closedir(DIR *dirp);
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// char *strstr(const char *haystack, const char *needle);
// time_t time(time_t *timer);
// int __cdecl gnutls_certificate_free_credentials(_DWORD); weak
// int BZ2_bzDecompressEnd(bz_stream *strm);
// char *nl_langinfo(nl_item item);
// void *malloc(size_t size);
// const XML_LChar *XML_ErrorString(enum XML_Error code);
// int __cdecl rb_obj_as_string(_DWORD); weak
// int Gpm_Close(void);
// int iconv_close(iconv_t cd);
// int fputc(int c, FILE *stream);
// int __cdecl memrchr(_DWORD, _DWORD, _DWORD); weak
// int __cdecl rb_define_module_function(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl gss_delete_sec_context(_DWORD, _DWORD, _DWORD); weak
// int __cdecl strcasestr(_DWORD, _DWORD); weak
// void freeifaddrs(struct ifaddrs *ifa);
// struct group *getgrgid(__gid_t gid);
// unsigned int sleep(unsigned int seconds);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int backtrace(void **array, int size);
// void *memmove(void *dest, const void *src, size_t n);
// void XML_ParserFree(XML_Parser parser);
// const __int32_t **__ctype_tolower_loc(void);
// wint_t towlower(wint_t wc);
// int __cdecl gnutls_certificate_type_get(_DWORD); weak
// char *getcwd(char *buf, size_t size);
// int sigfillset(sigset_t *set);
// int vasprintf(char **, const char *, va_list);
// int __cdecl __rawmemchr(_DWORD, _DWORD); weak
// void XML_SetElementHandler(XML_Parser parser, XML_StartElementHandler start, XML_EndElementHandler end);
// int __cdecl gnutls_priority_set_direct(_DWORD, _DWORD, _DWORD); weak
// __pid_t fork(void);
// int __cdecl gnutls_kx_get(_DWORD); weak
// int __cdecl gnutls_kx_get_name(_DWORD); weak
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gss_import_name(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl rb_str_new2(_DWORD); weak
// enum XML_Status XML_Parse(XML_Parser parser, const char *s, int len, int isFinal);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int __cdecl rb_intern(_DWORD); weak
// int fcntl(int fd, int cmd, ...);
// int __cdecl getrlimit64(_DWORD, _DWORD); weak
// int rand(void);
// struct tm *gmtime(const time_t *timer);
// int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...); weak
// void *memchr(const void *s, int c, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// int __cdecl open64(_DWORD, _DWORD); weak
// int __cdecl rb_funcall3(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...); weak
// int _IO_putc(int c, _IO_FILE *fp);
// int munmap(void *addr, size_t len);
// int pipe(int pipedes[2]);
// int Gpm_Open(Gpm_Connect *, int);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);
// void __cdecl gnutls_global_deinit(module *module); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int kill(__pid_t pid, int sig);
// int __cdecl mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// char *tempnam(const char *dir, const char *pfx);
// size_t strcspn(const char *s, const char *reject);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// int BZ2_bzDecompressInit(bz_stream *strm, int verbosity, int small);
// int ferror(FILE *stream);
// struct passwd *getpwnam(const char *name);
// int __cdecl gss_init_sec_context(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int strcmp(const char *s1, const char *s2);
// void XML_SetCharacterDataHandler(XML_Parser parser, XML_CharacterDataHandler handler);
// int __cdecl gnutls_cipher_get(_DWORD); weak
// void herror(const char *str);
// int __thiscall __strdup(_DWORD, _DWORD); weak
// int setenv(const char *name, const char *value, int replace);
// void exit(int status);
// int __cdecl gnutls_bye(_DWORD, _DWORD); weak
// int __cdecl rb_define_const(_DWORD, _DWORD, _DWORD); weak
// int __cdecl gnutls_strerror(_DWORD); weak
// int pclose(FILE *stream);
// void backtrace_symbols_fd(void *const *array, int size, int fd);
// int __cdecl __vasprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// __gid_t getgid(void);
// void *tsearch(const void *key, void **rootp, __compar_fn_t compar);
// __uid_t geteuid(void);
widget_handler_status_T __cdecl select_button(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl mouse_button(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl display_button(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl add_dlg_button_do(dialog *dlg, unsigned __int8 *text, int flags, widget_handler_T *handler, void *data, done_handler_T *done, void *done_data);
// void __usercall buttons_width(int@<eax>, int@<edx>, int *@<ecx>, widget_data *widget_data);
void __cdecl dlg_format_buttons(terminal *term, widget_data *widget_data, int n, int x, int *y, int w, int *rw, format_align align, int format_only);
void __cdecl add_dlg_radio_do(dialog *dlg, unsigned __int8 *text, int groupid, int groupnum, int *data);
widget_handler_status_T __cdecl init_checkbox(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl select_checkbox(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl mouse_checkbox(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl display_checkbox(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl dlg_format_checkbox(terminal *term, widget_data *widget_data, int x, int *y, int w, int *rw, format_align align, int format_only);
void __cdecl refresh_dialog(dialog_data *dlg_data, dialog_refresh_handler_T handler, void *data);
void __cdecl draw_dialog(dialog_data *dlg_data, int width, int height);
// void __usercall format_widgets(terminal *term@<eax>, dialog_data *dlg_data@<edx>, int x@<ecx>, int *y, int w, int h, int *rw, int format_only); idb
void __cdecl generic_dialog_layouter(dialog_data *dlg_data);
int __cdecl update_dialog_data(dialog_data *dlg_data);
widget_handler_status_T __cdecl cancel_dialog(dialog_data *dlg_data, widget_data *xxx);
void __cdecl select_widget(dialog_data *dlg_data, widget_data *widget_data);
widget_data *__cdecl select_widget_by_id(dialog_data *dlg_data, int i);
// void __usercall select_dlg_item(dialog_data *dlg_data@<eax>, widget_data *widget_data@<edx>); idb
// void __usercall cycle_widget_focus(dialog_data *dlg_data@<eax>, int direction@<edx>); idb
void __cdecl redraw_dialog(dialog_data *dlg_data, int layout);
void __cdecl do_refresh_dialog(dialog_data *dlg_data);
widget_handler_status_T __cdecl clear_dialog(dialog_data *dlg_data, widget_data *xxx);
int __cdecl check_dialog(dialog_data *dlg_data);
widget_handler_status_T __cdecl ok_dialog(dialog_data *dlg_data, widget_data *widget_data);
dialog_data *__cdecl do_dialog(terminal *term, dialog *dlg, memory_list *ml);
void __cdecl dialog_func(window *win, term_event *ev);
void __cdecl dlg_format_group(terminal *term, widget_data *widget_data, int n, int x, int *y, int w, int *rw, int format_only);
void __cdecl group_layouter(dialog_data *dlg_data);
// void __usercall recursively_set_expanded(listbox_item *item@<eax>, int expanded@<edx>); idb
int __cdecl scan_for_marks(listbox_item *item, void *info_, int *offset);
int __cdecl scan_for_used(listbox_item *item, void *info_, int *offset);
void __cdecl done_listbox_context(void *context_);
int __cdecl scan_for_matches(listbox_item *item, void *info_, int *offset);
int __cdecl mark_visible(listbox_item *item, void *xxx, int *offset);
widget_handler_status_T __cdecl push_hierbox_search_button(dialog_data *dlg_data, widget_data *button);
void __cdecl do_clear_browser(void *context_);
// listbox_context *__usercall init_listbox_context@<eax>(listbox_data *box@<eax>, terminal *term@<edx>, listbox_item *item@<ecx>, int (*scanner)(listbox_item *, void *, int *)); idb
void __cdecl search_hierbox_browser(void *data, unsigned __int8 *text);
widget_handler_status_T __cdecl push_hierbox_info_button(dialog_data *dlg_data, widget_data *button);
// void __usercall print_delete_error(listbox_item *item@<eax>, terminal *term@<edx>, const listbox_ops *ops@<ecx>, delete_error err); idb
widget_handler_status_T __cdecl push_hierbox_clear_button(dialog_data *dlg_data, widget_data *button);
// void __usercall do_delete_item(listbox_item *item@<eax>, listbox_context *info@<edx>, int last@<ecx>); idb
int __cdecl delete_unused(listbox_item *item, void *data_, int *offset);
int __cdecl delete_marked(listbox_item *item, void *data_, int *offset);
// widget_handler_status_T __usercall query_delete_selected_item@<eax>(void *context_@<eax>); idb
widget_handler_status_T __cdecl push_hierbox_delete_button(dialog_data *dlg_data, widget_data *button);
void __cdecl dont_delete_marked_items(void *const context_);
void __cdecl push_ok_delete_button(void *context_);
// void __usercall recursively_goto_listbox(session *ses@<eax>, listbox_item *item@<edx>, listbox_data *box@<ecx>); idb
widget_handler_status_T __cdecl push_hierbox_goto_button(dialog_data *dlg_data, widget_data *button);
int __cdecl goto_marked(listbox_item *item, void *data_, int *offset);
widget_handler_status_T __cdecl hierbox_dialog_event_handler(dialog_data *dlg_data);
void __cdecl update_hierbox_browser(hierbox_browser *browser);
listbox_item *__cdecl add_listbox_item(hierbox_browser *browser, listbox_item *root, listbox_item_type type, void *data, int add_position);
void __cdecl done_listbox_item(hierbox_browser *browser, listbox_item *item);
dialog_data *__cdecl hierbox_browser_0(hierbox_browser *browser, session *ses);
void __cdecl clear_hotkeys_cache(menu *menu);
void __cdecl init_hotkeys(terminal *term, menu *menu);
void __cdecl refresh_hotkeys(terminal *term, menu *menu);
// int __usercall check_hotkeys_common@<eax>(menu *menu@<eax>, term_event_char_T hotkey@<edx>, terminal *term@<ecx>, int check_mode); idb
int __cdecl check_not_so_hot_keys(menu *menu, term_event_char_T key, terminal *term);
int __cdecl check_hotkeys(menu *menu, term_event_char_T key, terminal *term);
void __cdecl add_dlg_field_do(dialog *dlg, widget_type type, unsigned __int8 *label, int min, int max, widget_handler_T *handler, int datalen, void *data, input_history *history, inpfield_flags flags);
// widget_handler_status_T __usercall display_field_do@<eax>(dialog_data *dlg_data@<eax>, widget_data *widget_data@<edx>, int hide@<ecx>); idb
widget_handler_status_T __cdecl display_field_pass(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl display_field(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl clear_field(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl kbd_field(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl mouse_field(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl init_field(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl input_field_line(session *ses, unsigned __int8 *prompt, void *data, input_history *history, input_line_handler_T handler);
widget_handler_status_T __cdecl input_line_event_handler(dialog_data *dlg_data);
widget_handler_status_T __cdecl input_field_cancel(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl input_field_ok(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl dlg_format_field(terminal *term, widget_data *widget_data, int x, int *y, int w, int *rw, format_align align, int format_only);
void __cdecl input_line_layouter(dialog_data *dlg_data);
widget_handler_status_T __cdecl check_nonempty(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl check_number(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl input_field(terminal *term, memory_list *ml, int intl, unsigned __int8 *title, unsigned __int8 *text, unsigned __int8 *okbutton, unsigned __int8 *cancelbutton, void *data, input_history *history, int l, unsigned __int8 *def, int min, int max, widget_handler_T *check, void (*fn)(void *, unsigned __int8 *), void (*cancelfn)(void *));
void __cdecl input_dialog(terminal *term, memory_list *ml, unsigned __int8 *title, unsigned __int8 *text, void *data, input_history *history, int l, unsigned __int8 *def, int min, int max, widget_handler_T *check, void (*fn)(void *, unsigned __int8 *), void (*cancelfn)(void *));
void __cdecl dlg_set_history(widget_data *widget_data);
int __cdecl save_input_history(input_history *history, unsigned __int8 *filename);
void __cdecl add_to_input_history(input_history *history, unsigned __int8 *data, int check_duplicate);
int __cdecl load_input_history(input_history *history, unsigned __int8 *filename);
void __cdecl tab_complete_file_menu(terminal *term, void *path_, void *dlg_data_);
void __cdecl do_tab_compl_file(dialog_data *dlg_data, list_head_elinks *history);
void __cdecl set_complete_file_menu(terminal *term, void *filename_, void *dlg_data_);
// void __usercall tab_compl_n(dialog_data *dlg_data@<eax>, unsigned __int8 *item@<edx>, int len@<ecx>); idb
void __cdecl menu_tab_compl(terminal *term, void *item_, void *dlg_data_);
void __cdecl do_tab_compl_unambiguous(dialog_data *dlg_data, list_head_elinks *history);
void __cdecl do_tab_compl(dialog_data *dlg_data, list_head_elinks *history);
void __cdecl init_leds(module *module);
void __cdecl set_led_value(led *led, unsigned __int8 value);
void __cdecl unset_led_value(led *led);
void __cdecl init_led_panel(led_panel *leds);
led *__cdecl register_led(session *ses, int number);
void __cdecl unregister_led(led *led);
void __cdecl menu_leds_info(terminal *term, void *xxx, void *xxxx);
void __cdecl draw_leds(session *ses);
void __cdecl redraw_leds(void *xxx);
void __cdecl done_leds(module *module);
void __cdecl add_dlg_listbox(dialog *dlg, void *box_data);
listbox_item *__cdecl traverse_listbox_items_list(listbox_item *item, listbox_data *box, int offset, int follow_visible, int (*fn)(listbox_item *, void *, int *), void *d);
int __cdecl calc_dist(listbox_item *item, void *data_, int *offset);
int __cdecl test_search(listbox_item *item, void *data_, int *offset);
int __cdecl check_old_state(listbox_item *item, void *info_, int *offset);
listbox_data *__cdecl get_listbox_widget_data(widget_data *widget_data);
widget_handler_status_T __cdecl init_listbox(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl listbox_sel_move(widget_data *widget_data, int dist);
widget_handler_status_T __cdecl kbd_listbox(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl mouse_listbox(dialog_data *dlg_data, widget_data *widget_data);
int __cdecl display_listbox_item(listbox_item *item, void *data_, int *offset);
void __cdecl dlg_format_listbox(terminal *term, widget_data *widget_data, int x, int *y, int w, int max_height, int *rw, format_align align, int format_only);
// int __usercall listbox_item_offset@<eax>(listbox_data *box@<eax>, listbox_item *item@<edx>); idb
void __cdecl listbox_sel(widget_data *widget_data, listbox_item *item);
widget_handler_status_T __cdecl display_listbox(dialog_data *dlg_data, widget_data *widget_data);
// _BOOL4 __usercall menu_contains@<eax>(menu_item *m@<eax>, int f@<edx>);
void __cdecl menu_labels(menu_item *items, unsigned __int8 *base, unsigned __int8 **lbls);
menu_item *__cdecl detach_menu(list_menu *menu);
void __cdecl free_menu(menu_item *m);
void __cdecl destroy_menu(list_menu *menu);
void __cdecl new_menu_item(list_menu *menu, unsigned __int8 *name, int data, int fullname);
void __cdecl add_select_item(list_menu *menu, string *string, string *orig_string, unsigned __int8 **value, int order, int dont_add);
void __cdecl init_menu(list_menu *menu);
void __cdecl do_select_submenu(terminal *term, void *menu_, void *ses_);
void __cdecl deselect_mainmenu(terminal *term, menu *menu);
// void __usercall set_menu_selection(menu *menu@<eax>, int pos@<edx>); idb
// void __usercall scroll_menu(menu *menu@<eax>, int steps@<edx>, int wrap@<ecx>); idb
// unsigned __int8 *__usercall _@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
// void __usercall select_menu_item(terminal *term@<eax>, menu_item *it@<edx>, void *data@<ecx>); idb
// void __usercall free_menu_items(menu_item *items@<eax>); idb
void __cdecl do_menu_selected(terminal *term, menu_item *items, void *data, int selected, int hotkeys);
void __cdecl do_menu(terminal *term, menu_item *items, void *data, int hotkeys);
void __cdecl add_to_menu(menu_item **mi, unsigned __int8 *text, unsigned __int8 *rtext, main_action action_id, menu_func_T func, void *data, menu_item_flags flags);
menu_item *__cdecl new_menu(menu_item_flags flags);
// void __usercall display_menu(terminal *term@<eax>, menu *menu@<edx>); idb
// void __usercall display_mainmenu(terminal *term@<eax>, menu *menu@<edx>); idb
void __cdecl do_mainmenu(terminal *term, menu_item *items, void *data, int sel);
void __cdecl mainmenu_handler(window *win, term_event *ev);
input_line_code __cdecl menu_search_handler(input_line *line, int action_id);
void __cdecl menu_handler(window *win, term_event *ev);
void __cdecl abort_refreshed_msg_box_handler(dialog_data *dlg_data);
dlg_refresh_code __cdecl refresh_msg_box(dialog_data *dlg_data, void *data);
unsigned __int8 *msg_text(terminal *term, unsigned __int8 *format, ...);
dialog_data *msg_box(terminal *term, memory_list *ml, msgbox_flags flags, unsigned __int8 *title, format_align align, unsigned __int8 *text, void *udata, int buttons, ...);
dialog_data *__cdecl info_box(terminal *term, msgbox_flags flags, unsigned __int8 *title, format_align align, unsigned __int8 *text);
void __cdecl refreshed_msg_box(terminal *term, msgbox_flags flags, unsigned __int8 *title, format_align align, unsigned __int8 *(*get_info)(terminal *, void *), void *data);
void done_bfu_colors(); // idb
color_pair *__cdecl get_bfu_color(terminal *term, unsigned __int8 *stylename);
void __cdecl add_dlg_text(dialog *dlg, unsigned __int8 *text, format_align align, int bottom_pad);
widget_handler_status_T __cdecl display_text(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl dlg_format_text_do(terminal *term, unsigned __int8 *text, int x, int *y, int width, int *real_width, color_pair *color, format_align align, int format_only);
void __cdecl dlg_format_text(terminal *term, widget_data *widget_data, int x, int *y, int width, int *real_width, int max_height, int format_only);
// void __usercall format_and_display_text(widget_data *widget_data@<eax>, dialog_data *dlg_data@<edx>, int current@<ecx>); idb
widget_handler_status_T __cdecl kbd_text(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl mouse_text(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl display_widget(dialog_data *dlg_data, widget_data *widget_data);
evhook_status __cdecl bookmark_change_hook(va_list ap, void *data);
int __cdecl change_hook_folder_state(session *ses, option_elinks *current, option_elinks *changed);
void bookmarks_set_dirty(); // idb
void bookmarks_unset_dirty(); // idb
_BOOL4 bookmarks_are_dirty();
// void __usercall free_bookmarks(list_head_elinks *bookmarks_list@<eax>, list_head_elinks *box_items@<edx>); idb
bookmark *__cdecl get_bookmark_by_name(bookmark *folder, unsigned __int8 *title);
void __cdecl open_bookmark_folder(session *ses, unsigned __int8 *foldername);
unsigned __int8 *get_auto_save_bookmark_foldername_utf8(); // idb
bookmark *__cdecl get_bookmark(unsigned __int8 *url);
int __cdecl update_bookmark(bookmark *bm, int codepage, unsigned __int8 *title, unsigned __int8 *url);
bookmark *__cdecl add_bookmark(bookmark *root, int place, unsigned __int8 *title, unsigned __int8 *url);
bookmark *__cdecl add_bookmark_cp(bookmark *root, int place, int codepage, unsigned __int8 *title, unsigned __int8 *url);
// void __usercall bookmark_terminal(terminal *term@<eax>, bookmark *folder@<edx>); idb
void __cdecl bookmark_terminal_tabs(terminal *term, unsigned __int8 *foldername);
void __cdecl delete_bookmark(bookmark *bm);
void __cdecl bookmark_auto_save_tabs(terminal *term);
void write_bookmarks(); // idb
void __cdecl done_bookmarks(module *module);
evhook_status __cdecl bookmark_write_hook(va_list ap, void *data);
void read_bookmarks(); // idb
void __cdecl init_bookmarks(module *module);
void __cdecl lock_bookmark(listbox_item *item);
void __cdecl unlock_bookmark(listbox_item *item);
int __cdecl is_bookmark_used(listbox_item *item);
listbox_item *__cdecl get_bookmark_root(listbox_item *item);
int __cdecl can_delete_bookmark(listbox_item *item);
void __cdecl bookmark_edit_cancel(dialog *dlg);
// void __usercall update_depths(listbox_item *parent@<eax>); idb
void __cdecl delete_bookmark_item(listbox_item *item, int last);
uri *__cdecl get_bookmark_uri(listbox_item *item);
unsigned __int8 *__cdecl get_bookmark_text(listbox_item *item, terminal *term);
// unsigned __int8 *__usercall _0@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_bookmark_info(listbox_item *item, terminal *term);
void __cdecl add_converted_bytes_to_string(void *data, unsigned __int8 *buf, int buflen);
void free_last_searched_bookmark(); // idb
widget_handler_status_T __cdecl push_search_button(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl launch_bm_add_dialog(terminal *term, dialog_data *parent, session *ses, unsigned __int8 *title, unsigned __int8 *url);
void __cdecl launch_bm_add_doc_dialog(terminal *term, dialog_data *parent, session *ses);
widget_handler_status_T __cdecl push_add_button(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl push_edit_button(dialog_data *dlg_data, widget_data *edit_btn);
void __cdecl bookmark_search_do(void *data);
int __cdecl test_search_0(listbox_item *item, void *data_, int *offset);
// move_bookmark_flags __usercall do_move_bookmark@<eax>(bookmark *dest@<eax>, int insert_as_child@<edx>, list_head_elinks *src@<ecx>, listbox_data *box); idb
widget_handler_status_T __cdecl push_move_button(dialog_data *dlg_data, widget_data *blah);
widget_handler_status_T __cdecl push_add_folder_button(dialog_data *dlg_data, widget_data *widget_data);
// void __usercall do_add_bookmark(terminal *term@<eax>, dialog_data *dlg_data@<edx>, unsigned __int8 *title@<ecx>, unsigned __int8 *url); idb
void __cdecl do_add_folder(dialog_data *dlg_data, unsigned __int8 *foldername);
void __cdecl bookmark_add_add(void *data);
widget_handler_status_T __cdecl push_add_separator_button(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl bookmark_edit_done(void *data);
void __cdecl bookmark_terminal_tabs_ok(void *term_void, unsigned __int8 *foldername);
void __cdecl launch_bm_add_link_dialog(terminal *term, dialog_data *parent, session *ses);
void __cdecl bookmark_manager(session *ses);
void __cdecl bookmark_terminal_tabs_dialog(terminal *term);
void __cdecl bookmarks_write(list_head_elinks *bookmarks_list);
void bookmarks_read(); // idb
unsigned __int8 *__cdecl filename_bookmarks_default(int writing);
// void __usercall write_bookmarks_default_inner(const write_bookmarks_default *out@<eax>, list_head_elinks *bookmarks_list@<edx>); idb
void __cdecl write_bookmarks_default_0(secure_save_info *ssi, list_head_elinks *bookmarks_list);
void __cdecl read_bookmarks_default(FILE *f);
unsigned __int8 *__cdecl filename_bookmarks_xbel(int writing);
void __cdecl on_element_close(void *data, const char *name);
// void __usercall print_xml_entities(secure_save_info *ssi@<eax>, const unsigned __int8 *str@<edx>); idb
// void __usercall write_bookmarks_list(secure_save_info *ssi@<eax>, list_head_elinks *bookmarks_list@<edx>, int n@<ecx>, int folder_state); idb
void __cdecl write_bookmarks_xbel(secure_save_info *ssi, list_head_elinks *bookmarks_list);
// void __usercall free_node(tree_node *node@<eax>); idb
// void __usercall free_xbeltree(tree_node *node@<eax>); idb
void __cdecl on_text(void *data, const XML_Char *text, int len);
void __cdecl on_element_open(void *data, const char *name, const char **attr);
// int __usercall xbeltree_to_bookmarks_list@<eax>(const read_bookmarks_xbel *preload@<eax>, tree_node *node@<edx>, bookmark *current_parent@<ecx>); idb
void __cdecl read_bookmarks_xbel_0(FILE *f);
unsigned __int64 get_cache_size(); // idb
int get_cache_entry_count(); // idb
int get_cache_entry_used_count(); // idb
int __cdecl cache_entry_is_valid(cache_entry *cached);
int get_cache_entry_loading_count(); // idb
uri *__cdecl redirect_cache(cache_entry *cached, unsigned __int8 *location, int get, int incomplete);
// fragment *__usercall frag_alloc@<eax>(size_t size@<eax>); idb
fragment *__cdecl get_cache_fragment(cache_entry *cached);
cache_entry *__cdecl find_in_cache(uri *uri);
cache_entry *__cdecl follow_cached_redirects(cache_entry *cached);
cache_entry *__cdecl get_redirected_cache_entry(uri *uri);
cache_entry *__cdecl get_cache_entry(uri *uri);
void __cdecl free_entry_to(cache_entry *cached, off_t offset);
// void __usercall remove_overlaps(cache_entry *cached@<eax>, fragment *f@<edx>, int *trunc@<ecx>); idb
void __cdecl delete_entry_content(cache_entry *cached);
void __cdecl delete_cache_entry(cache_entry *cached);
void __cdecl garbage_collection(int whole);
cache_entry *__cdecl get_validated_cache_entry(uri *uri, cache_mode cache_mode);
// void __usercall truncate_entry(cache_entry *cached@<eax>, off_t offset@<0:edx, 4:ecx>, int final); idb
void __cdecl normalize_cache_entry(cache_entry *cached, off_t truncate_length);
int __cdecl add_fragment(cache_entry *cached, off_t offset, const unsigned __int8 *data, ssize_t length);
void __cdecl lock_cache_entry(listbox_item *item);
void __cdecl unlock_cache_entry(listbox_item *item);
int __cdecl is_cache_entry_used(listbox_item *item);
uri *__cdecl get_cache_entry_uri(listbox_item *item);
listbox_item *__cdecl get_cache_entry_root(listbox_item *item);
int __cdecl can_delete_cache_entry(listbox_item *item);
void __cdecl delete_cache_entry_item(listbox_item *item, int last);
listbox_match __cdecl match_cache_entry(listbox_item *item, terminal *term, unsigned __int8 *text);
// unsigned __int8 *__usercall _1@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_cache_entry_info(listbox_item *item, terminal *term);
unsigned __int8 *__cdecl get_cache_entry_text(listbox_item *item, terminal *term);
void __cdecl cache_manager(session *ses);
unsigned __int8 *__cdecl version_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl remote_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl lookup_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl forcehtml_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl eval_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
// void __usercall print_full_help_inner(option_elinks *tree@<eax>, unsigned __int8 *path@<edx>, int trees@<ecx>); idb
// void __usercall print_full_help_outer(option_elinks *tree@<eax>, unsigned __int8 *path@<edx>); idb
unsigned __int8 *__cdecl printconfigdump_cmd(option_elinks *option_elinks, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl redir_cmd(option_elinks *option_elinks, unsigned __int8 ***argv, int *argc);
retval __cdecl parse_options(int argc, unsigned __int8 **argv, list_head_elinks *url_list);
unsigned __int8 *__cdecl printhelp_cmd(option_elinks *option_elinks, unsigned __int8 ***argv, int *argc);
// void __usercall skip_quoted(conf_parsing_pos *pos@<eax>); idb
// void __usercall skip_option_value(conf_parsing_pos *pos@<eax>); idb
// string *__usercall add_bytes_to_string__@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
// void __usercall add_cfg_header_to_string(string *string@<eax>, unsigned __int8 *text@<edx>); idb
// void __usercall skip_white(conf_parsing_pos *pos@<eax>); idb
// parse_error __usercall show_parse_error@<eax>(const conf_parsing_state *state@<eax>, parse_error err@<edx>); idb
parse_error __cdecl parse_bind(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf);
parse_error __cdecl parse_unset(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf);
parse_error __cdecl parse_set(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf);
string *__cdecl wrap_option_desc(string *out, const unsigned __int8 *src, const string *indent, int maxwidth);
void __cdecl smart_config_output_fn(string *string, option_elinks *option_elinks, unsigned __int8 *path, int depth, int do_print_comment, int action, int i18n);
// unsigned __int8 *__usercall read_config_file@<eax>(unsigned __int8 *name@<eax>); idb
void __cdecl parse_config_file(option_elinks *options, unsigned __int8 *name, unsigned __int8 *file, string *mirror, int is_system_conf);
// int __usercall load_config_file@<eax>(unsigned __int8 *prefix@<eax>, unsigned __int8 *name@<edx>, option_elinks *options@<ecx>, string *mirror, int is_system_conf); idb
unsigned __int8 *__cdecl create_config_string(unsigned __int8 *prefix, unsigned __int8 *name, option_elinks *options);
int __cdecl write_config(terminal *term);
void load_config(); // idb
parse_error __cdecl parse_include(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf);
void __cdecl lock_option(listbox_item *item);
void __cdecl unlock_option(listbox_item *item);
int __cdecl is_option_used(listbox_item *item);
listbox_item *__cdecl get_option_root(listbox_item *item);
int __cdecl can_delete_option(listbox_item *item);
void __cdecl lock_keybinding(listbox_item *item);
void __cdecl unlock_keybinding(listbox_item *item);
int __cdecl is_keybinding_used(listbox_item *item);
int __cdecl can_delete_keybinding(listbox_item *item);
listbox_item *__cdecl get_keybinding_action_box_item(keymap_id keymap_id, action_id_T action_id);
listbox_item *__cdecl get_keybinding_root(listbox_item *item);
void __cdecl delete_keybinding_item(listbox_item *item, int last);
// unsigned __int8 *__usercall _2@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_keybinding_info(listbox_item *item, terminal *term);
widget_handler_status_T __cdecl push_kbdbind_save_button(dialog_data *dlg_data, widget_data *some_useless_info_button);
widget_handler_status_T __cdecl push_kbdbind_toggle_display_button(dialog_data *dlg_data, widget_data *some_useless_info_button);
widget_handler_status_T __cdecl check_option_name(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl push_kbdbind_add_button(dialog_data *dlg_data, widget_data *some_useless_info_button);
widget_handler_status_T __cdecl push_add_button_0(dialog_data *dlg_data, widget_data *some_useless_info_button);
void __cdecl really_really_add_keybinding(void *data);
void __cdecl really_add_keybinding(void *data, unsigned __int8 *keystroke);
widget_handler_status_T __cdecl check_keystroke(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl delete_option_item(listbox_item *item, int last);
void done_keybinding_listboxes(); // idb
// unsigned __int8 *__usercall get_range_string@<eax>(option_elinks *option_elinks@<eax>); idb
widget_handler_status_T __cdecl push_save_button(dialog_data *dlg_data, widget_data *some_useless_info_button);
void __cdecl add_option_to_tree(void *data, unsigned __int8 *name);
widget_handler_status_T __cdecl check_valid_option(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl keybinding_manager(session *ses);
void __cdecl options_manager(session *ses);
void __cdecl init_keybinding_listboxes(keymap *keymap_table, action_list *actions);
void __cdecl disable_success_msgbox(void *dummy);
void __cdecl write_config_dialog(terminal *term, unsigned __int8 *config_file, int secsave_error, int stdio_error);
unsigned __int8 *__cdecl get_option_text(listbox_item *item, terminal *term);
widget_handler_status_T __cdecl push_edit_button_0(dialog_data *dlg_data, widget_data *some_useless_info_button);
unsigned __int8 *__cdecl get_keybinding_text(listbox_item *item, terminal *term);
listbox_match __cdecl match_option(listbox_item *item, terminal *term, unsigned __int8 *text);
listbox_match __cdecl match_keybinding(listbox_item *item, terminal *term, unsigned __int8 *text);
unsigned __int8 *__cdecl get_option_info(listbox_item *item, terminal *term);
void done_home(); // idb
// const char *__usercall test_confdir@<eax>(unsigned __int8 *home@<eax>, unsigned __int8 *path@<edx>, unsigned __int8 *error_message@<ecx>);
void init_home(); // idb
int __cdecl keybinding_exists(keymap_id keymap_id, term_event_keyboard *kbd, action_id_T *action_id);
action_id_T __cdecl kbd_action(keymap_id keymap_id, term_event *ev, int *event);
keybinding *__cdecl kbd_ev_lookup(keymap_id keymap_id, term_event_keyboard *kbd, int *event);
void __cdecl free_keymaps(module *xxx);
unsigned __int8 *__cdecl get_keymap_name(keymap_id keymap_id);
action *__cdecl get_action(keymap_id keymap_id, action_id_T action_id);
unsigned __int8 *__cdecl get_action_name(keymap_id keymap_id, action_id_T action_id);
action_id_T __cdecl get_action_from_string(keymap_id keymap_id, unsigned __int8 *str);
keybinding *__cdecl kbd_nm_lookup(keymap_id keymap_id, unsigned __int8 *name);
void __cdecl add_keystroke_to_string(string *str, term_event_keyboard *kbd, int escape);
void __cdecl bind_config_string(string *file);
void __cdecl add_keystroke_action_to_string(string *string, action_id_T action_id, keymap_id keymap_id);
unsigned __int8 *__cdecl get_keystroke(action_id_T action_id, keymap_id keymap_id);
term_event_key_T __cdecl read_key(const unsigned __int8 *key_str);
int __cdecl parse_keystroke(const unsigned __int8 *s, term_event_keyboard *kbd);
unsigned __int8 *__cdecl bind_act(unsigned __int8 *keymap_str, const unsigned __int8 *keystroke_str);
unsigned __int8 *__cdecl get_action_name_from_keystroke(keymap_id keymap_id, const unsigned __int8 *keystroke_str);
void __cdecl free_keybinding(keybinding *keybinding);
keybinding *__cdecl add_keybinding(keymap_id keymap_id, action_id_T action_id, term_event_keyboard *kbd, int event);
void __cdecl init_keymaps(module *xxx);
int __cdecl bind_do(unsigned __int8 *keymap_str, const unsigned __int8 *keystroke_str, unsigned __int8 *action_str, int is_system_conf);
int __cdecl bind_key_to_event_name(unsigned __int8 *ckmap, const unsigned __int8 *ckey, unsigned __int8 *event_name, unsigned __int8 **err);
void __cdecl add_actions_to_string(string *string, action_id_T *action_ids, keymap_id keymap_id, terminal *term);
void __cdecl prepare_mustsave_flags(list_head_elinks *tree, int set_all);
void __cdecl untouch_options(list_head_elinks *tree);
// int __usercall check_nonempty_tree@<eax>(list_head_elinks *options@<eax>); idb
int __cdecl change_hook_html(session *ses, option_elinks *current, option_elinks *changed);
void __cdecl call_change_hooks(session *ses, option_elinks *current, option_elinks *option_elinks);
void __cdecl option_changed(session *ses, option_elinks *option_elinks);
// void __usercall delete_option_do(option_elinks *option_elinks@<eax>, int recursive@<edx>); idb
void __cdecl unregister_options(option_info *info, option_elinks *tree);
void done_options(); // idb
void __cdecl delete_option(option_elinks *option_elinks);
list_head_elinks *init_options_tree(); // idb
void __cdecl toggle_option(session *ses, option_elinks *option_elinks);
void __cdecl mark_option_as_deleted(option_elinks *option_elinks);
// void __usercall update_visibility(list_head_elinks *tree@<eax>, int show@<edx>); idb
int __cdecl change_hook_stemplate(session *ses, option_elinks *current, option_elinks *changed);
void __cdecl smart_config_string(string *str, int print_comment, int i18n, list_head_elinks *options, unsigned __int8 *path, int depth, void (*fn)(string *, option_elinks *, unsigned __int8 *, int, int, int, int));
int __cdecl change_hook_ui(session *ses, option_elinks *current, option_elinks *changed);
int __cdecl change_hook_insert_mode(session *ses, option_elinks *current, option_elinks *changed);
int __cdecl change_hook_language(session *ses, option_elinks *current, option_elinks *changed);
int __cdecl change_hook_terminal(session *ses, option_elinks *current, option_elinks *changed);
int __cdecl change_hook_cache(session *ses, option_elinks *current, option_elinks *changed);
int __cdecl change_hook_active_link(session *ses, option_elinks *current, option_elinks *changed);
int __cdecl change_hook_connection(session *ses, option_elinks *current, option_elinks *changed);
option_elinks *__cdecl copy_option(option_elinks *template);
option_elinks *__cdecl get_opt_rec(option_elinks *tree, const unsigned __int8 *name_);
void __cdecl checkout_option_values(option_resolver *resolvers, option_elinks *root, option_value *values, int size);
int __cdecl commit_option_values(option_resolver *resolvers, option_elinks *root, option_value *values, int size);
void __cdecl register_change_hooks(const change_hook_info *change_hooks);
option_value *__cdecl get_opt_(option_elinks *tree, unsigned __int8 *name);
// void __usercall add_opt_rec(option_elinks *tree@<eax>, unsigned __int8 *path@<edx>, option_elinks *option_elinks@<ecx>); idb
void __cdecl register_options(option_info *info, option_elinks *tree);
option_elinks *__cdecl add_opt(option_elinks *tree, unsigned __int8 *path, unsigned __int8 *capt, unsigned __int8 *name, option_flags flags, option_type type, int min, int max, longptr_T value, unsigned __int8 *desc);
void update_options_visibility(); // idb
void init_options(); // idb
option_elinks *__cdecl indirect_option(option_elinks *alias);
option_elinks *__cdecl get_opt_rec_real(option_elinks *tree, const unsigned __int8 *name);
unsigned __int8 *__cdecl bool_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl exec_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
int __cdecl num_set(option_elinks *opt, unsigned __int8 *str);
int __cdecl num_eq(option_elinks *opt, const unsigned __int8 *str);
int __cdecl long_set(option_elinks *opt, unsigned __int8 *str);
int __cdecl long_eq(option_elinks *opt, const unsigned __int8 *str);
int __cdecl str_eq(option_elinks *opt, const unsigned __int8 *str);
void __cdecl tree_dup(option_elinks *opt, option_elinks *template);
int __cdecl redir_eq(option_elinks *opt, const unsigned __int8 *str);
int __cdecl redir_set(option_elinks *opt, unsigned __int8 *str);
void __cdecl redir_wr(option_elinks *opt, string *string);
unsigned __int8 *__cdecl redir_rd(option_elinks *opt, unsigned __int8 **file, int *line);
unsigned __int8 *__cdecl redir_cmd_0(option_elinks *opt, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl get_option_type_name(option_type type);
int __cdecl color_eq(option_elinks *opt, const unsigned __int8 *str);
int __cdecl color_set(option_elinks *opt, unsigned __int8 *str);
// void __usercall add_optstring_to_string(string *s@<eax>, const unsigned __int8 *q@<edx>, int qlen@<ecx>); idb
void __cdecl color_wr(option_elinks *opt, string *str);
void __cdecl str_wr(option_elinks *o, string *s);
int __cdecl lang_eq(option_elinks *opt, const unsigned __int8 *str);
int __cdecl lang_set(option_elinks *opt, unsigned __int8 *str);
void __cdecl lang_wr(option_elinks *o, string *s);
int __cdecl cp_eq(option_elinks *opt, const unsigned __int8 *str);
int __cdecl cp_set(option_elinks *opt, unsigned __int8 *str);
void __cdecl cp_wr(option_elinks *o, string *s);
int __cdecl str_set(option_elinks *opt, unsigned __int8 *str);
void __cdecl str_dup(option_elinks *opt, option_elinks *template);
unsigned __int8 *__cdecl str_rd(option_elinks *opt, unsigned __int8 **file, int *line);
void __cdecl long_wr(option_elinks *option_elinks, string *string);
void __cdecl num_wr(option_elinks *option_elinks, string *string);
unsigned __int8 *__cdecl gen_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc);
unsigned __int8 *__cdecl num_rd(option_elinks *opt, unsigned __int8 **file, int *line);
void __cdecl done_timer(module *module);
void __cdecl periodic_save_handler(void *xxx);
void __cdecl init_timer(module *module);
int __cdecl periodic_save_change_hook(session *ses, option_elinks *current, option_elinks *changed);
evhook_status __cdecl goto_url_history_write_hook(va_list ap, void *data);
void __cdecl done_url_history(module *module);
void __cdecl init_url_history(module *module);
void __cdecl save_cookies(terminal *term);
void __cdecl resave_cookies_bottom_half(void *always_null);
void set_cookies_dirty(); // idb
cookie_server *__cdecl get_cookie_server(unsigned __int8 *host, int hostlen);
// void __usercall done_cookie_server(cookie_server *cs_0@<eax>); idb
cookie *__cdecl init_cookie(unsigned __int8 *name, unsigned __int8 *value, unsigned __int8 *path, unsigned __int8 *domain, cookie_server *server);
void __cdecl done_cookie(cookie *c);
void __cdecl delete_cookie(cookie *c);
void __cdecl done_cookies(module *module);
string *__cdecl send_cookies(uri *uri);
void __cdecl accept_cookie(cookie *cookie);
void load_cookies(); // idb
void __cdecl init_cookies(module *module);
void __cdecl set_cookie(uri *uri, unsigned __int8 *str);
void __cdecl lock_cookie(listbox_item *item);
void __cdecl unlock_cookie(listbox_item *item);
int __cdecl is_cookie_used(listbox_item *item);
listbox_item *__cdecl get_cookie_root(listbox_item *item);
int __cdecl can_delete_cookie(listbox_item *item);
void __cdecl delete_cookie_item(listbox_item *item, int last);
unsigned __int8 *__cdecl get_cookie_text(listbox_item *item, terminal *term);
widget_handler_status_T __cdecl push_save_button_0(dialog_data *dlg_data, widget_data *button);
widget_handler_status_T __cdecl set_cookie_domain(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl set_cookie_value(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl set_cookie_name(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl set_cookie_secure(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl set_cookie_expires(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl add_server_do(void *data);
void __cdecl accept_cookie_in_msg_box(void *cookie_);
void __cdecl cookie_manager(session *ses);
void __cdecl reject_cookie_in_msg_box(void *cookie_);
widget_handler_status_T __cdecl push_add_server_button(dialog_data *dlg_data, widget_data *button);
// void __usercall build_edit_dialog(terminal *term@<eax>, cookie *cookie@<edx>); idb
widget_handler_status_T __cdecl push_edit_button_1(dialog_data *dlg_data, widget_data *button);
widget_handler_status_T __cdecl push_add_button_1(dialog_data *dlg_data, widget_data *button);
// void __usercall add_cookie_info_to_string(string *string@<eax>, cookie *cookie@<edx>, terminal *term@<ecx>); idb
unsigned __int8 *__cdecl get_cookie_info(listbox_item *item, terminal *term);
void __cdecl accept_cookie_dialog(session *ses, void *data);
cookie_str *__cdecl parse_cookie_str(cookie_str *cstr, unsigned __int8 *str);
void __cdecl cached_header_dialog(session *ses, cache_entry *cached);
void __cdecl nowhere_box(terminal *term, unsigned __int8 *title);
void __cdecl protocol_header_dialog(session *ses);
// unsigned __int8 *__usercall _3@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
void __cdecl document_info_dialog(session *ses);
void __cdecl download_abort_function(dialog_data *dlg_data);
void __cdecl lock_file_download(listbox_item *item);
void __cdecl unlock_file_download(listbox_item *item);
int __cdecl is_file_download_used(listbox_item *item);
unsigned __int8 *__cdecl get_file_download_info(listbox_item *item, terminal *term);
uri *__cdecl get_file_download_uri(listbox_item *item);
listbox_item *__cdecl get_file_download_root(listbox_item *item);
int __cdecl can_delete_file_download(listbox_item *item);
void __cdecl done_download_display(file_download *file_download);
dlg_refresh_code __cdecl refresh_file_download(dialog_data *dlg_data, void *data);
void __cdecl delete_file_download(listbox_item *item, int last);
widget_handler_status_T __cdecl push_delete_button(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl dlg_abort_download(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl dlg_undisplay_download(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl do_abort_download(file_download *file_download);
unsigned __int8 *__cdecl get_file_download_text(listbox_item *item, terminal *term);
void __cdecl draw_file_download(listbox_item *item, listbox_context *context, int x, int y, int width);
void __cdecl init_download_display(file_download *file_download);
void __cdecl download_manager(session *ses);
void __cdecl undisplay_download(file_download *file_download);
widget_handler_status_T __cdecl dlg_set_notify(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl download_dialog_layouter(dialog_data *dlg_data);
void __cdecl display_download(terminal *term, file_download *file_download, session *ses);
widget_handler_status_T __cdecl push_info_button(dialog_data *dlg_data, widget_data *button);
widget_handler_status_T __cdecl my_cancel_dialog(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl do_edit_dialog(terminal *term, int intl, unsigned __int8 *title, const unsigned __int8 *src_name, const unsigned __int8 *src_url, session *ses, dialog_data *parent, done_handler_T *when_done, void (*when_cancel)(dialog *), void *done_data, edit_dialog_type dialog_type);
void __cdecl resource_info(terminal *term);
void __cdecl menu_copying(terminal *term, void *xxx, void *xxxx);
void __cdecl menu_keys(terminal *term, void *d_, void *xxx);
void __cdecl push_toggle_keys_display_button(void *data);
void __cdecl menu_about(terminal *term, void *xxx, void *xxxx);
unsigned __int8 *__cdecl get_resource_info(terminal *term, void *data);
void __cdecl dont_exit_prog(void *ses_);
void __cdecl add_uri_command_to_menu(menu_item **mi, pass_uri_type type, unsigned __int8 *text);
void __cdecl do_setup_menu(terminal *term, void *xxx, void *ses_);
void __cdecl do_submenu(terminal *term, void *menu_, void *ses_);
// void __usercall history_menu_common(terminal *term@<eax>, session *ses@<edx>, int unhist@<ecx>); idb
void __cdecl unhistory_menu(terminal *term, void *xxx, void *ses_);
void __cdecl history_menu(terminal *term, void *xxx, void *ses_);
void __cdecl do_pass_uri_to_command(terminal *term, void *command_, void *xxx);
void __cdecl add_new_win_to_menu(menu_item **mi, unsigned __int8 *text, terminal *term);
void __cdecl open_in_new_window(terminal *term, void *func_, void *ses_);
// void __usercall add_cmdline_bool_option(string *string@<eax>, unsigned __int8 *name@<edx>); idb
void __cdecl open_uri_in_new_window(session *ses, uri *uri, uri *referrer, term_env_type env, cache_mode cache_mode, task_type task);
void __cdecl send_open_new_window(terminal *term, const open_in_new *open, session *ses);
void __cdecl send_open_in_new_window(terminal *term, const open_in_new *open, session *ses);
void free_history_lists(); // idb
void __cdecl dialog_goto_url(session *ses, unsigned __int8 *url);
void __cdecl save_url_as(session *ses);
void __cdecl activate_bfu_technology(session *ses, int item);
void __cdecl menu_url_shortcut(terminal *term, void *url_, void *ses_);
void __cdecl do_file_menu(terminal *term, void *xxx, void *ses_);
void __cdecl go_historywards(terminal *term, void *target_, void *ses_);
void __cdecl tab_menu(session *ses, int x, int y, int place_above_cursor);
void __cdecl really_exit_prog(void *ses_);
void __cdecl query_exit(session *ses);
void __cdecl exit_prog(session *ses, int query);
frame_event_status __cdecl pass_uri_to_command(session *ses, document_view *doc_view, int which_type);
void __cdecl query_file(session *ses, uri *uri, void *data, void (*std)(void *, unsigned __int8 *), void (*cancel)(void *), int interactive);
void __cdecl save_url(session *ses, unsigned __int8 *url);
void __cdecl auto_complete_file(terminal *term, int no_elevator, unsigned __int8 *path, menu_func_T file_func, menu_func_T dir_func, void *data);
void __cdecl push_resize_button(void *data);
void __cdecl menu_language_list(terminal *term, void *xxx, void *ses);
void __cdecl menu_set_language(terminal *term, void *pcp_, void *xxx);
widget_handler_status_T __cdecl push_ok_button(dialog_data *dlg_data, widget_data *button);
widget_handler_status_T __cdecl push_save_button_1(dialog_data *dlg_data, widget_data *button);
void __cdecl charset_list(terminal *term, void *xxx, void *ses_);
void __cdecl display_codepage(terminal *term, void *name_, void *xxx);
void __cdecl resize_terminal_dialog(terminal *term);
void __cdecl terminal_options(terminal *term, void *xxx, session *ses);
void __cdecl draw_progress_bar(progress *progress, terminal *term, int x, int y, int width, unsigned __int8 *text, color_pair *meter_color);
unsigned __int8 *__cdecl get_progress_msg(progress *progress, terminal *term, int wide, int full, unsigned __int8 *separator);
// string *__usercall add_bytes_to_string___0@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
void update_status(); // idb
unsigned __int8 *__cdecl get_download_msg(download *download, terminal *term, int wide, int full, unsigned __int8 *separator);
void __cdecl print_screen_status(session *ses);
line *__cdecl realloc_lines(document *document, int y);
int get_format_cache_size(); // idb
int get_format_cache_used_count(); // idb
int get_format_cache_refresh_count(); // idb
void __cdecl done_documents(module *module);
void __cdecl init_documents(module *module);
unsigned int __cdecl get_document_css_magic(document *document);
int __cdecl find_tag(document *document, unsigned __int8 *name, int namelen);
void __cdecl release_document(document *document);
// void __usercall free_frameset_desc(frameset_desc *frameset_desc@<eax>); idb
void __cdecl done_link_members(link *link);
void __cdecl done_document(document *document);
void __cdecl shrink_format_cache(int whole);
document *__cdecl get_cached_document(cache_entry *cached, document_options *options);
document *__cdecl init_document(cache_entry *cached, document_options *options);
void update_cached_document_options(); // idb
void __cdecl get_screen_char_template(screen_char *template, document_options *options, text_style style);
unsigned __int8 *__cdecl form_type2str(form_type num);
int __cdecl has_form_submit(form *form);
void __cdecl done_form_control(form_control *fc);
void __cdecl done_form(form *form);
int __cdecl get_form_control_link(document *document, form_control *fc);
form *init_form(); // idb
int __cdecl str2form_type(unsigned __int8 *s);
void __cdecl toggle_document_option(session *ses, unsigned __int8 *option_name);
void __cdecl done_document_options(document_options *options);
void __cdecl copy_opt(document_options *o1, document_options *o2);
int __cdecl compare_opt(document_options *o1, document_options *o2);
void __cdecl init_document_options(document_options *doo);
void __cdecl start_document_refreshes(session *ses);
void __cdecl do_document_refresh(void *data);
void __cdecl kill_document_refresh(document_refresh *refresh);
void __cdecl done_document_refresh(document_refresh *refresh);
document_refresh *__cdecl init_document_refresh(unsigned __int8 *url, unsigned int seconds);
int __cdecl comp_links(const void *v1, const void *v2);
conv_table *__cdecl get_convert_table(unsigned __int8 *head, int to_cp, int default_cp, int *from_cp, cp_status *cp_status, int ignore_server_cp);
void __cdecl sort_links(document *document);
void __cdecl render_document(view_state *vs, document_view *doc_view, document_options *options);
void __cdecl render_document_frames(session *ses, int no_cache);
void __cdecl apply_css_selector_style(html_context *html_context, html_element *element, css_selector *selector);
void __cdecl css_apply_text_align(html_context *html_context, html_element *element, css_property *prop);
void __cdecl css_apply_font_attribute(html_context *html_context, html_element *element, css_property *prop);
void __cdecl css_apply_display(html_context *html_context, html_element *element, css_property *prop);
void __cdecl css_apply_color(html_context *html_context, html_element *element, css_property *prop);
void __cdecl css_apply_background_color(html_context *html_context, html_element *element, css_property *prop);
// void __usercall examine_element(html_context *html_context@<eax>, css_selector *base@<edx>, css_selector_type seltype@<ecx>, css_selector_relation rel, list_head_elinks *selectors, html_element *element); idb
css_selector *__cdecl get_css_selector_for_element(html_context *html_context, html_element *element, css_stylesheet *css, list_head_elinks *html_stack);
void __cdecl css_apply(html_context *html_context, html_element *element, css_stylesheet *css, list_head_elinks *html_stack);
void __cdecl done_css(module *module);
void __cdecl import_css_file(css_stylesheet *css, uri *base_uri, const unsigned __int8 *url, int urllen);
void import_default_css(); // idb
void __cdecl init_css(module *module);
int __cdecl change_hook_css(session *ses, option_elinks *current, option_elinks *changed);
void __cdecl import_css(css_stylesheet *css, uri *uri);
// css_selector *__usercall reparent_selector@<eax>(list_head_elinks *sels@<eax>, css_selector *selector@<edx>, css_selector **watch@<ecx>); idb
void __cdecl css_parse_properties(list_head_elinks *props, scanner *scanner);
// void __usercall skip_css_block(scanner *scanner@<eax>); idb
void __cdecl css_parse_stylesheet(css_stylesheet *css, uri *base_uri, unsigned __int8 *string, unsigned __int8 *end);
scanner_token *__cdecl scan_css_tokens(scanner *scanner);
css_stylesheet *__cdecl init_css_stylesheet(css_stylesheet_importer_T importer, void *import_data);
void __cdecl done_css_selector(css_selector *selector);
void __cdecl done_css_stylesheet(css_stylesheet *css);
void __cdecl merge_css_selectors(css_selector *sel1, css_selector *sel2);
void __cdecl add_selector_properties(css_selector *selector, list_head_elinks *properties);
css_selector *__cdecl init_css_selector(list_head_elinks *sels, css_selector_type type, const unsigned __int8 *name, int namelen);
void __cdecl mirror_css_stylesheet(css_stylesheet *css1, css_stylesheet *css2);
css_selector *__cdecl find_css_selector(list_head_elinks *sels, css_selector_type type, css_selector_relation rel, const unsigned __int8 *name, int namelen);
css_selector *__cdecl get_css_selector(list_head_elinks *sels, css_selector_type type, css_selector_relation rel, const unsigned __int8 *name, int namelen);
int __cdecl css_parse_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_display_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_white_space_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_text_decoration_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_text_align_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_font_style_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_font_weight_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_color_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
int __cdecl css_parse_background_value(css_property_info *propinfo, css_property_value *value, scanner *scanner);
// screen_char *__usercall realloc_line@<eax>(document *document@<eax>, int x@<edx>, int y@<ecx>); idb
// void __usercall render_dom_text(dom_renderer *renderer@<eax>, screen_char *template@<edx>, unsigned __int8 *string@<ecx>, int length); idb
// void __usercall render_dom_flush(dom_renderer *renderer@<eax>, unsigned __int8 *string@<edx>); idb
dom_code __cdecl render_dom_element_end_source(dom_stack *stack, dom_node *node, void *data);
// dom_string *__usercall get_rss_text@<eax>(dom_node *node@<eax>, rss_element_type type@<edx>); idb
dom_code __cdecl dom_rss_pop_element(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl dom_rss_push_element(dom_stack *stack, dom_node *node, void *data);
void __cdecl render_dom_document(cache_entry *cached, document *document, string *buffer);
// void __usercall render_rss_item(dom_renderer *renderer@<eax>, dom_node *item@<edx>); idb
dom_code __cdecl dom_rss_pop_document(dom_stack *stack, dom_node *root, void *data);
dom_code __cdecl render_dom_document_end(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl render_dom_node_source(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl render_dom_element_source(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl render_dom_cdata_source(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl render_dom_attribute_source(dom_stack *stack, dom_node *node, void *data);
// int __usercall distribute_rows_or_cols@<eax>(int *val_@<eax>, int max_value@<edx>, int *values@<ecx>, int values_count); idb
void __cdecl parse_frame_widths(unsigned __int8 *str, int max_value, int pixels_per_char, int **new_values, int *new_values_count);
void __cdecl format_frames(session *ses, frameset_desc *fsd, document_options *op, int depth);
void __cdecl add_frameset_entry(frameset_desc *frameset_desc, frameset_desc *subframe, unsigned __int8 *name, unsigned __int8 *url);
frameset_desc *__cdecl create_frameset(frameset_param *fp);
void __cdecl ln_break(html_context *html_context, int n);
void __cdecl add_fragment_identifier(html_context *html_context, part *part, unsigned __int8 *attr);
void __cdecl html_skip(html_context *html_context, unsigned __int8 *a);
void __cdecl done_html_parser_state(html_context *html_context, void *state);
void __cdecl done_html_parser(html_context *html_context);
html_context *__cdecl init_html_parser(uri *uri, document_options *options, unsigned __int8 *start, unsigned __int8 *end, string *head, string *title, void (*put_chars)(html_context *, unsigned __int8 *, int), void (*line_break)(html_context *), void *(*special)(html_context *, html_special_type, ...));
void *__cdecl init_html_parser_state(html_context *html_context, html_element_mortality_type type, int align, int margin, int width);
void __cdecl set_fragment_identifier(html_context *html_context, unsigned __int8 *attr_name, unsigned __int8 *attr);
void __cdecl put_chrs(html_context *html_context, unsigned __int8 *start, int len);
void __cdecl html_focusable(html_context *html_context, unsigned __int8 *a);
void __cdecl process_head(html_context *html_context, unsigned __int8 *head);
void __cdecl import_css_stylesheet(css_stylesheet *css, uri *base_uri, const unsigned __int8 *unterminated_url, int len);
unsigned __int8 *__cdecl get_target(document_options *options, unsigned __int8 *a);
int __cdecl get_image_map(unsigned __int8 *head, unsigned __int8 *pos, unsigned __int8 *eof, menu_item **menu, memory_list **ml, uri *uri, document_options *options, unsigned __int8 *target_base, int to, int def, int hdef);
int __cdecl get_color(html_context *html_context, unsigned __int8 *a, unsigned __int8 *c, color_T *rgb);
int __cdecl get_bgcolor(html_context *html_context, unsigned __int8 *a, color_T *rgb);
void __cdecl check_html_form_hierarchy(part *part);
void *html_special(html_context *html_context, html_special_type c, ...);
// void __usercall move_links(html_context *html_context@<eax>, int xf@<edx>, int yf@<ecx>, int xt, int yt); idb
// void __usercall del_chars(html_context *html_context@<eax>, int x@<edx>, int y@<ecx>); idb
// void *__usercall mem_align_alloc__@<eax>(void **ptr@<eax>, size_t old@<edx>, size_t new@<ecx>, size_t objsize, size_t mask); idb
// int __usercall realloc_line_0@<eax>(html_context *html_context@<eax>, document *document@<edx>, int y@<ecx>, int length); idb
void __cdecl draw_frame_hchars(part *part, int x, int y, int width, unsigned __int8 data, color_T bgcolor, color_T fgcolor, html_context *html_context);
void __cdecl expand_lines(html_context *html_context, part *part, int x, int y, int lines, color_T bgcolor);
// void __usercall align_line(html_context *html_context@<eax>, int y@<edx>, int last@<ecx>); idb
void __cdecl line_break(html_context *html_context);
void free_table_cache(); // idb
part *__cdecl format_html_part(html_context *html_context, unsigned __int8 *start, unsigned __int8 *end, int align, int margin, int width, document *document, int x, int y, unsigned __int8 *head, int link_num);
void __cdecl render_html_document(cache_entry *cached, document *document, string *buffer);
void __cdecl draw_frame_vchars(part *part, int x, int y, int height, unsigned __int8 data, color_T bgcolor, color_T fgcolor, html_context *html_context);
// int __usercall split_line_at@<eax>(html_context *html_context@<eax>, int width@<edx>); idb
void __cdecl put_chars(html_context *html_context, unsigned __int8 *chars, int charslen);
void __cdecl put_chars_conv(html_context *html_context, unsigned __int8 *chars, int charslen);
// int __usercall get_hline_width@<eax>(table_elinks *table_elinks@<eax>, int row@<edx>); idb
// void __usercall get_table_frames(table_elinks *table_elinks@<eax>, table_frames *result@<edx>); idb
// void __usercall draw_table_frames(table_elinks *table_elinks@<eax>, int indent@<edx>, int y@<ecx>, html_context *html_context); idb
void __cdecl format_table(unsigned __int8 *attr, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end, html_context *html_context);
// form_control *__usercall init_form_control@<eax>(form_type type@<eax>, unsigned __int8 *attr@<edx>, html_context *html_context@<ecx>); idb
void __cdecl html_textarea(html_context *html_context, unsigned __int8 *attr, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_option(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_button(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_input(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_form(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_select(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_span(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_bold(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_italic(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_underline(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_fixed(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_style_close(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_html(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_head(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_meta(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_title(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_center(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_address(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_blockquote(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_pre(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_xmp(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_xmp_close(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_tt(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_noscript(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_frameset(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_frame(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_noframes(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_style(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_script(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_dd(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_dt(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_dl(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_td(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_th(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_quote_close(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_quote(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_superscript(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_subscript_close(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_subscript(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_ol(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_li(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_ul(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_linebrk(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_tr(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h(int h, unsigned __int8 *a, format_align default_align, html_context *html_context, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h6(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h5(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h4(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h3(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h2(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_h1(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_p(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_br(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_base(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_table(html_context *html_context, unsigned __int8 *attr, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_hr(html_context *html_context, unsigned __int8 *a, unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end);
void __cdecl html_handle_body_meta(html_context *html_context, unsigned __int8 *meta, unsigned __int8 *eof);
void __cdecl html_apply_canvas_bgcolor(html_context *html_context);
void __cdecl html_html_close(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_body(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_font(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
// unsigned __int8 *__usercall truncate_label@<eax>(unsigned __int8 *label@<eax>, int max_len@<edx>); idb
// unsigned __int8 *__usercall get_image_filename_from_src@<eax>(int max_len@<eax>, unsigned __int8 *src@<edx>); idb
// void __usercall put_image_label(unsigned __int8 *a@<eax>, unsigned __int8 *label@<edx>, html_context *html_context@<ecx>); idb
// void __usercall html_img_do(unsigned __int8 *a@<eax>, unsigned __int8 *object_src@<edx>, html_context *html_context@<ecx>); idb
void __cdecl html_img(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl put_link_line(unsigned __int8 *prefix, unsigned __int8 *linkname, unsigned __int8 *link, unsigned __int8 *target, html_context *html_context);
void __cdecl html_link(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
// void __usercall html_iframe_do(unsigned __int8 *a@<eax>, unsigned __int8 *object_src@<edx>, html_context *html_context@<ecx>); idb
void __cdecl html_embed(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_iframe(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_object(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_applet(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void __cdecl html_a(html_context *html_context, unsigned __int8 *a, unsigned __int8 *xxx3, unsigned __int8 *xxx4, unsigned __int8 **xxx5);
void tags_list_reset(); // idb
fastfind_key_value *tags_list_next(); // idb
unsigned __int8 *__cdecl skip_comment(unsigned __int8 *html, unsigned __int8 *eof);
int __cdecl parse_element(unsigned __int8 *e, unsigned __int8 *eof, unsigned __int8 **name, int *namelen, unsigned __int8 **attr, unsigned __int8 **end);
void free_tags_lookup(); // idb
void init_tags_lookup(); // idb
// void *__usercall mem_align_alloc___2@<eax>(void **@<eax>, int@<edx>, int@<ecx>);
unsigned __int8 *__cdecl get_attr_value(unsigned __int8 *e, unsigned __int8 *name, int cp, html_attr_flags flags);
void __cdecl scan_http_equiv(unsigned __int8 *s, unsigned __int8 *eof, string *head, string *title, document_options *options);
void __cdecl parse_html(unsigned __int8 *html, unsigned __int8 *eof, part *part, unsigned __int8 *head, html_context *html_context);
int __cdecl get_width(unsigned __int8 *a, unsigned __int8 *name, int limited, html_context *html_context);
int __cdecl get_num(unsigned __int8 *a, unsigned __int8 *name, int cp);
html_element *__cdecl search_html_stack(html_context *html_context, unsigned __int8 *name);
void __cdecl html_stack_dup(html_context *html_context, html_element_mortality_type type);
void __cdecl kill_html_stack_item(html_context *html_context, html_element *e);
// void __usercall kill_element(html_context *html_context@<eax>, int ls@<edx>, html_element *e@<ecx>); idb
void kill_html_stack_until(html_context *html_context, int ls, ...);
// void __usercall add_table_bad_html_end(table_elinks *table_elinks@<eax>, unsigned __int8 *end@<edx>); idb
void __cdecl free_table(table_elinks *table_elinks);
// void __usercall get_align(html_context *html_context@<eax>, unsigned __int8 *attr@<edx>, int *a@<ecx>); idb
// void __usercall get_valign(html_context *html_context@<eax>, unsigned __int8 *attr@<edx>, int *a@<ecx>); idb
// void __usercall set_td_width(table_elinks *table_elinks@<eax>, int col@<edx>, int width@<ecx>, int force); idb
// void __usercall get_column_width(unsigned __int8 *attr@<eax>, int *width@<edx>, int sh@<ecx>, html_context *html_context); idb
// table_cell *__usercall new_cell@<eax>(table_elinks *table_elinks@<eax>, int dest_col@<edx>, int dest_row@<ecx>); idb
// void __usercall new_columns(table_elinks *table_elinks@<eax>, int span@<edx>, int width@<ecx>, int align, int valign, int group); idb
table_elinks *__cdecl parse_table(unsigned __int8 *html, unsigned __int8 *eof, unsigned __int8 **end, unsigned __int8 *attr, int sh, html_context *html_context);
// screen_char *__usercall realloc_line_1@<eax>(document *document@<eax>, int x@<edx>, int y@<ecx>); idb
void __cdecl render_plain_document(cache_entry *cached, document *document, string *buffer);
dom_config_flag __cdecl parse_dom_config(unsigned __int8 *flaglist, unsigned __int8 separator);
dom_config *__cdecl add_dom_config_normalizer(dom_stack *stack, dom_config *config, dom_config_flag flags);
// dom_code __usercall normalize_text_node_whitespace@<eax>(dom_node *node@<eax>); idb
dom_code __cdecl dom_normalize_text(dom_stack *stack, dom_node *node, void *data);
// int __usercall append_node_text@<eax>(dom_config *config@<eax>, dom_node *node@<edx>);
dom_code __cdecl dom_normalize_node_end(dom_stack *stack, dom_node *node, void *data);
dom_string *__cdecl get_dom_node_type_name(dom_node_type type);
dom_string *__cdecl get_dom_node_value(dom_node *node);
dom_string *__cdecl get_dom_node_name(dom_node *node);
// int __usercall get_dom_node_list_pos@<eax>(dom_node_list *list@<eax>, dom_node *node@<edx>); idb
dom_node *__cdecl get_dom_node_prev(dom_node *node);
// void __usercall del_from_dom_node_list(dom_node_list *list@<eax>, dom_node *node@<edx>); idb
// void __usercall done_dom_node_data(dom_node *node@<eax>); idb
void __cdecl done_dom_node_list(dom_node_list *list);
void __cdecl done_dom_node(dom_node *node);
int __cdecl dom_node_casecmp(dom_node *node1, dom_node *node2);
dom_node *__cdecl get_dom_node_map_entry(dom_node_list *list, dom_node_type type, uint16_t subtype, dom_string *name);
dom_node_list *__cdecl add_to_dom_node_list(dom_node_list **list_ptr, dom_node *node, int position);
dom_node *__cdecl get_dom_node_child(dom_node *parent, dom_node_type type, int16_t subtype);
int __cdecl get_dom_node_list_index(dom_node *parent, dom_node *node);
dom_node *__cdecl get_dom_node_next(dom_node *node);
int __cdecl get_dom_node_map_index(dom_node_list *list, dom_node *node);
dom_node *__cdecl init_dom_node_at(dom_node *parent, dom_node_type type, dom_string *string, int allocated);
dom_scanner_token *__cdecl skip_dom_scanner_tokens(dom_scanner *scanner, int skipto, int precedence);
void __cdecl init_dom_scanner(dom_scanner *scanner, dom_scanner_info *scanner_info, dom_string *string, int state, int count_lines, int complete, int check_complete, int detect_errors);
int __cdecl map_dom_scanner_string(dom_scanner *scanner, unsigned __int8 *ident, unsigned __int8 *end, int base_type);
// dom_scanner_token *__usercall get_next_dom_scanner_token@<eax>(dom_scanner *scanner@<eax>); idb
dom_code __cdecl dom_select_pop_element(dom_stack *stack, dom_node *node, void *data);
void __cdecl done_dom_select(dom_select *select);
dom_code __cdecl dom_select_push_text(dom_stack *stack, dom_node *node, void *data);
dom_node_list *__cdecl select_dom_nodes(dom_select *select, dom_node *root);
dom_code __cdecl dom_select_push_element(dom_stack *stack, dom_node *node, void *data);
// int __usercall parse_dom_select_nth_arg@<eax>(dom_select_nth_match *nth@<eax>, dom_scanner *scanner@<edx>);
// dom_code __usercall parse_dom_select@<eax>(dom_select *select@<eax>, dom_stack *stack@<edx>, dom_string *string@<ecx>); idb
dom_select *__cdecl init_dom_select(dom_select_syntax syntax, dom_string *string);
dom_stack_state *__cdecl search_dom_stack(dom_stack *stack, dom_node_type type, dom_string *string);
void __cdecl init_dom_stack(dom_stack *stack, dom_stack_flag flags);
void __cdecl done_dom_stack(dom_stack *stack);
void __cdecl done_dom_stack_context(dom_stack *stack, dom_stack_context *context);
// int __usercall call_dom_stack_callbacks@<eax>(dom_stack *stack@<eax>, dom_stack_state *state@<edx>, dom_stack_action action@<ecx>); idb
void __cdecl pop_dom_node(dom_stack *stack);
void __cdecl pop_dom_state(dom_stack *stack, dom_stack_state *target);
void __cdecl pop_dom_nodes(dom_stack *stack, dom_node_type type, dom_string *string);
dom_code __cdecl push_dom_node(dom_stack *stack, dom_node *node);
dom_stack_context *__cdecl add_dom_stack_context(dom_stack *stack, void *data, dom_stack_context_info *context_info);
void __cdecl walk_dom_nodes(dom_stack *stack, dom_node *root);
dom_scanner_token *__cdecl scan_css_tokens_0(dom_scanner *scanner);
dom_code __cdecl sgml_file_dumper_element_pop(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_comment_push(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_proc_instruction_push(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_entity_ref_push(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_cdata_section_push(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_text_push(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_element_push(dom_stack *stack, dom_node *node, void *data);
dom_code __cdecl sgml_file_dumper_attribute_push(dom_stack *stack, dom_node *node, void *data);
dom_stack_context *__cdecl add_sgml_file_dumper(dom_stack *stack, FILE *file);
void __cdecl done_sgml_parser(sgml_parser *parser);
// dom_string *__usercall add_to_dom_string@<eax>(dom_string *string@<eax>, unsigned __int8 *str@<edx>, size_t len@<ecx>); idb
// int __usercall check_sgml_incomplete@<eax>(dom_scanner *scanner@<eax>, dom_scanner_token *start@<edx>, dom_scanner_token *token@<ecx>);
dom_code __cdecl parse_sgml(sgml_parser *parser, unsigned __int8 *buf, size_t bufsize, int complete);
dom_code __cdecl sgml_parsing_pop(dom_stack *stack, dom_node *node, void *data);
unsigned int __cdecl get_sgml_parser_line_number(sgml_parser *parser);
// dom_code __usercall call_sgml_error_function@<eax>(dom_stack *stack@<eax>, dom_scanner_token *token@<edx>);
sgml_parser *__cdecl init_sgml_parser(sgml_parser_type type, sgml_document_type doctype, dom_string *uri, sgml_parser_flag flags);
// dom_code __usercall parse_sgml_plain@<eax>(dom_stack *stack@<eax>, dom_scanner *scanner@<edx>);
dom_code __cdecl sgml_parsing_push(dom_stack *stack, dom_node *node, void *data);
// void __usercall skip_sgml_space(dom_scanner *scanner@<eax>, unsigned __int8 **string@<edx>); idb
// unsigned __int8 *__usercall skip_sgml_chars@<eax>(dom_scanner *scanner@<eax>, unsigned __int8 *string@<edx>, unsigned __int8 skipto@<cl>); idb
// void __usercall set_sgml_incomplete(dom_scanner *scanner@<eax>, dom_scanner_token *token@<edx>); idb
// dom_scanner_token *__usercall set_sgml_error@<eax>(dom_scanner *scanner@<eax>, unsigned __int8 *end@<edx>); idb
// unsigned __int8 *__usercall skip_sgml@<eax>(int@<eax>, unsigned __int8 **@<edx>, int@<ecx>);
dom_scanner_token *__cdecl scan_sgml_tokens(dom_scanner *scanner);
sgml_info *__cdecl get_sgml_info(sgml_document_type doctype);
int __cdecl sgml_info_strcmp(const void *key_, const void *node_);
void __cdecl bzip2_close(stream_encoded *stream);
int __cdecl bzip2_read(stream_encoded *stream, unsigned __int8 *buf, int len);
int __cdecl bzip2_open(stream_encoded *stream, int fd);
unsigned __int8 *__cdecl bzip2_decode_buffer(unsigned __int8 *data, int len, int *new_len);
void __cdecl deflate_close(stream_encoded *stream);
int __cdecl deflate_read(stream_encoded *stream, unsigned __int8 *buf, int len);
int __cdecl deflate_gzip_open(stream_encoded *stream, int fd);
// unsigned __int8 *__usercall deflate_decode_buffer@<eax>(int window_size@<eax>, unsigned __int8 *data@<edx>, int len@<ecx>, int *new_len); idb
unsigned __int8 *__cdecl deflate_gzip_decode_buffer(unsigned __int8 *data, int len, int *new_len);
unsigned __int8 *__cdecl deflate_raw_decode_buffer(unsigned __int8 *data, int len, int *new_len);
int __cdecl read_encoded(stream_encoded *stream, unsigned __int8 *data, int len);
unsigned __int8 *__cdecl decode_encoded_buffer(stream_encoding encoding, unsigned __int8 *data, int len, int *new_len);
const unsigned __int8 *const *__cdecl listext_encoded(stream_encoding encoding);
const unsigned __int8 *__cdecl get_encoding_name(stream_encoding encoding);
// connection_basic_state *__usercall connection_state_8@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
void __cdecl dummy_close(stream_encoded *stream);
void __cdecl close_encoded(stream_encoded *stream);
unsigned __int8 *__cdecl dummy_decode_buffer(unsigned __int8 *data, int len, int *new_len);
int __cdecl dummy_read(stream_encoded *stream, unsigned __int8 *data, int len);
int __cdecl dummy_open(stream_encoded *stream, int fd);
stream_encoded *__cdecl open_encoded(int fd, stream_encoding encoding);
stream_encoding __cdecl guess_encoding(unsigned __int8 *filename);
// connection_state *__userpurge read_file@<eax>(connection_state *retstr, stream_encoded *stream, int readsize, string *page);
// connection_state *__userpurge read_encoded_file@<eax>(connection_state *retstr, string *filename, string *page);
void __cdecl lock_formhist_data(listbox_item *item);
void __cdecl unlock_formhist_data(listbox_item *item);
int __cdecl is_formhist_data_used(listbox_item *item);
listbox_item *__cdecl get_formhist_data_root(listbox_item *item);
int __cdecl can_delete_formhist_data(listbox_item *item);
void __cdecl delete_formhist_data(listbox_item *item, int last);
uri *__cdecl get_formhist_data_uri(listbox_item *item);
// unsigned __int8 *__usercall _4@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_formhist_data_info(listbox_item *item, terminal *term);
unsigned __int8 *__cdecl get_formhist_data_text(listbox_item *item, terminal *term);
widget_handler_status_T __cdecl push_save_button_2(dialog_data *dlg_data, widget_data *button);
widget_handler_status_T __cdecl push_toggle_dontsave_button(dialog_data *dlg_data, widget_data *button);
widget_handler_status_T __cdecl push_login_button(dialog_data *dlg_data, widget_data *button);
void __cdecl formhist_manager(session *ses);
// formhist_data *__usercall new_formhist_item@<eax>(unsigned __int8 *url@<eax>); idb
// void __usercall done_formhist_item(formhist_data *form@<eax>); idb
void __cdecl dont_remember_form(void *form_);
void __cdecl delete_formhist_item(formhist_data *form);
void __cdecl done_form_history(module *module);
int save_formhist_to_file(); // idb
void __cdecl remember_form(void *form_);
void __cdecl never_for_this_site(void *form_);
int load_formhist_from_file(); // idb
void __cdecl memorize_form(session *ses, list_head_elinks *submit, form *forminfo);
unsigned __int8 *__cdecl get_form_history_value(unsigned __int8 *url, unsigned __int8 *name);
void __cdecl lock_globhist_item(listbox_item *item);
void __cdecl unlock_globhist_item(listbox_item *item);
int __cdecl is_globhist_item_used(listbox_item *item);
listbox_item *__cdecl get_globhist_item_root(listbox_item *box_item);
int __cdecl can_delete_globhist_item(listbox_item *item);
void __cdecl delete_globhist_item(listbox_item *item, int last);
uri *__cdecl get_globhist_item_uri(listbox_item *item);
// unsigned __int8 *__usercall _5@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_globhist_item_info(listbox_item *box_item, terminal *term);
unsigned __int8 *__cdecl get_globhist_item_text(listbox_item *box_item, terminal *term);
widget_handler_status_T __cdecl push_toggle_display_button(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl push_search_button_0(dialog_data *dlg_data, widget_data *widget_data);
void __cdecl history_search_do(void *data);
widget_handler_status_T __cdecl push_bookmark_button(dialog_data *dlg_data, widget_data *some_useless_info_button);
void __cdecl history_manager(session *ses);
void reap_deleted_globhist_items(); // idb
void write_global_history(); // idb
evhook_status __cdecl global_history_write_hook(va_list ap, void *data);
int __cdecl globhist_simple_search(unsigned __int8 *search_url, unsigned __int8 *search_title);
global_history_item *__cdecl get_global_history_item(unsigned __int8 *url);
void __cdecl delete_global_history_item(global_history_item *history_item);
void __cdecl done_global_history(module *module);
void __cdecl add_global_history_item(unsigned __int8 *url, unsigned __int8 *title, time_t vtime);
void read_global_history(); // idb
void __cdecl init_global_history(module *module);
int __cdecl utf8charlen(const unsigned __int8 *p);
unsigned __int8 *__cdecl utf8_prevchar(unsigned __int8 *current, int pos, unsigned __int8 *start);
int __cdecl unicode_to_cell(unicode_val_T c);
int __cdecl hits_cmp(const void *v1, const void *v2);
int __cdecl compare_entities(const void *key_, const void *element_);
void charsets_list_reset(); // idb
fastfind_key_value *charsets_list_next(); // idb
unsigned __int8 *__cdecl get_cp_name(int cp_index);
unsigned __int8 *__cdecl get_cp_config_name(int cp_index);
unsigned __int8 *__cdecl get_cp_mime_name(int cp_index);
int __cdecl is_cp_utf8(int cp_index);
void free_charsets_lookup(); // idb
void init_charsets_lookup(); // idb
int __cdecl get_cp_index(const unsigned __int8 *name);
unicode_val_T __cdecl cp2u(int from, unsigned __int8 c);
unicode_val_T __cdecl utf8_to_unicode(unsigned __int8 **string, const unsigned __int8 *end);
unicode_val_T __cdecl cp_to_unicode(int codepage, unsigned __int8 **string, const unsigned __int8 *end);
// void __usercall free_translation_table(conv_table *p@<eax>); idb
// void __usercall new_translation_table(conv_table *p@<eax>); idb
unicode_val_T __cdecl unicode_fold_label_case(unicode_val_T c);
int __cdecl utf8_ptr2chars(unsigned __int8 *string, unsigned __int8 *end);
int __cdecl strlen_utf8(unsigned __int8 **str);
void free_conv_table(); // idb
unsigned __int8 *__cdecl encode_utf8(unicode_val_T u);
const unsigned __int8 *__cdecl u2cp_(unicode_val_T u, int to, nbsp_mode nbsp_mode);
const unsigned __int8 *__cdecl get_entity_string(const unsigned __int8 *str, const int strlen, int encoding);
unsigned __int8 *__cdecl convert_string_elinks(conv_table *convert_table, unsigned __int8 *chars, int charslen, int cp, convert_string_mode mode, int *length, void (*callback)(void *, unsigned __int8 *, int), void *callback_data);
// void __usercall add_utf8(unsigned int@<eax>, const unsigned __int8 *@<edx>);
const unsigned __int8 *__cdecl cp2utf8(int from, int c);
unsigned __int8 *__cdecl utf8_step_backward(unsigned __int8 *string, unsigned __int8 *start, int max, utf8_step way, int *count);
unsigned __int8 *__cdecl utf8_step_forward(unsigned __int8 *string, unsigned __int8 *end, int max, utf8_step way, int *count);
conv_table *__cdecl get_translation_table(int from, int to);
int __cdecl utf8_char2cells(unsigned __int8 *utf8_char, unsigned __int8 *end);
int __cdecl utf8_cells2bytes(unsigned __int8 *string, int max_cells, unsigned __int8 *end);
int __cdecl utf8_ptr2cells(unsigned __int8 *string, unsigned __int8 *end);
// void __usercall set_binding_values(const unsigned __int8 *domainname@<eax>, const unsigned __int8 **dirnamep@<edx>, const unsigned __int8 **codesetp@<ecx>); idb
unsigned __int8 *__cdecl bind_textdomain_codeset__(const unsigned __int8 *domainname, const unsigned __int8 *codeset);
unsigned __int8 *__cdecl bindtextdomain__(const unsigned __int8 *domainname, const unsigned __int8 *dirname);
unsigned __int8 *__cdecl dcgettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid, int category);
// unsigned int __usercall plural_eval@<eax>(expression *pexp@<eax>, unsigned int n@<edx>); idb
int __cdecl transcmp(const void *p1, const void *p2);
unsigned __int8 *__cdecl nl_find_msg(loaded_l10nfile *domain_file, binding *domainbinding, const unsigned __int8 *msgid, size_t *lengthp);
// unsigned __int8 *__usercall plural_lookup@<eax>(loaded_l10nfile *domain@<eax>, unsigned int n@<edx>, const unsigned __int8 *translation@<ecx>, size_t translation_len); idb
unsigned __int8 *__cdecl dcigettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, int plural, unsigned int n, int category);
unsigned __int8 *__cdecl dcngettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n, int category);
unsigned __int8 *__cdecl dgettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid);
unsigned __int8 *__cdecl dngettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n);
unsigned __int8 *__cdecl nl_find_language(const unsigned __int8 *name);
int __cdecl nl_explode_name(unsigned __int8 *name, const unsigned __int8 **language, const unsigned __int8 **modifier, const unsigned __int8 **territory, const unsigned __int8 **codeset, const unsigned __int8 **normalized_codeset, const unsigned __int8 **special, const unsigned __int8 **sponsor, const unsigned __int8 **revision);
loaded_l10nfile *__cdecl nl_find_domain(const unsigned __int8 *dirname, unsigned __int8 *locale, const unsigned __int8 *domainname, binding *domainbinding);
unsigned __int8 *__cdecl gettext__(const unsigned __int8 *msgid);
unsigned __int8 *__cdecl bind_textdomain_codeset(const unsigned __int8 *domainname, const unsigned __int8 *codeset);
unsigned __int8 *__cdecl bindtextdomain(const unsigned __int8 *domainname, const unsigned __int8 *dirname);
unsigned __int8 *__cdecl textdomain(const unsigned __int8 *domainname);
unsigned __int8 *__cdecl dcngettext(const unsigned __int8 *domainname, const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n, int category);
unsigned __int8 *__cdecl dngettext(const unsigned __int8 *domainname, const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n);
unsigned __int8 *__cdecl ngettext(const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n);
unsigned __int8 *__cdecl dcgettext(const unsigned __int8 *domainname, const unsigned __int8 *msgid, int category);
unsigned __int8 *__cdecl dgettext(const unsigned __int8 *domainname, const unsigned __int8 *msgid);
unsigned __int8 *__cdecl gettext(const unsigned __int8 *msgid);
const unsigned __int8 *__cdecl nl_normalize_codeset(const unsigned __int8 *codeset, size_t name_len);
loaded_l10nfile *__cdecl nl_make_l10nflist(loaded_l10nfile **l10nfile_list, const unsigned __int8 *dirlist, size_t dirlist_len, int mask, const unsigned __int8 *language, const unsigned __int8 *territory, const unsigned __int8 *codeset, const unsigned __int8 *normalized_codeset, const unsigned __int8 *modifier, const unsigned __int8 *special, const unsigned __int8 *sponsor, const unsigned __int8 *revision, const unsigned __int8 *filename, int do_allocate);
unsigned __int8 *__cdecl language_to_name(int language);
int __cdecl name_to_language(const unsigned __int8 *name);
int __cdecl iso639_to_language(unsigned __int8 *iso639);
int get_system_language_index(); // idb
unsigned __int8 *__cdecl language_to_iso639(int language);
void __cdecl set_language(int language);
// string *__usercall add_bytes_to_string___1@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
void __cdecl nl_free_domain_conv(loaded_domain *domain);
const unsigned __int8 *__cdecl nl_init_domain_conv(loaded_l10nfile *domain_file, loaded_domain *domain, binding *domainbinding);
void __cdecl nl_load_domain(loaded_l10nfile *domain_file, binding *domainbinding);
char *elinks_locale_charset();
// __int64 __usercall read_alias_file@<edx:eax>(const unsigned __int8 *fname@<eax>, int fname_len@<edx>);
const unsigned __int8 *__cdecl nl_expand_alias(const unsigned __int8 *name);
int __cdecl alias_compare(const alias_map *map1, const alias_map *map2);
unsigned __int8 *__cdecl ngettext__(const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n);
void __cdecl gettext_free_exp__(expression *exp);
// expression *__usercall new_exp@<eax>(int nargs@<eax>, operator op@<edx>, expression *const *args@<ecx>); idb
int __cdecl gettext__parse(void *arg);
unsigned __int8 *__cdecl textdomain__(const unsigned __int8 *domainname);
unsigned __int8 *__cdecl get_event_name(int id);
void done_event(); // idb
void init_event(); // idb
void __cdecl unregister_event_hook(int id, event_hook_T callback);
// void __usercall trigger_event_va(int id@<eax>, va_list ap_init@<edx>); idb
void trigger_event(int id, ...);
int __cdecl get_event_id(unsigned __int8 *name);
void __cdecl unregister_event_hooks(event_hook_info *hooks);
void trigger_event_name(unsigned __int8 *name, ...);
int __cdecl register_event(unsigned __int8 *name);
int __cdecl register_event_hook(int id, event_hook_T callback, int priority, void *data);
void __cdecl register_event_hooks(event_hook_info *hooks);
// int __usercall get_address@<eax>(socket_info *info@<eax>);
// void __usercall report_af_unix_error(unsigned __int8 *function@<eax>, int error@<edx>); idb
// void __usercall unlink_unix(sockaddr *addr@<eax>); idb
void done_interlink(); // idb
void __cdecl af_unix_connection(socket_info *info);
void __cdecl elinks_usleep(unsigned int useconds);
int init_interlink(); // idb
// void __usercall check_stdio(list_head_elinks *url_list@<eax>); idb
void init(); // idb
void __cdecl shrink_memory(int whole);
int __cdecl main(int argc, const char **argv, const char **envp);
void __cdecl done_module(module *module);
void __cdecl done_modules(module **modules);
void __cdecl init_module(module *module);
void __cdecl init_modules(module **modules);
void __cdecl unregister_module_options(module *module);
void __cdecl unregister_modules_options(module **modules);
void __cdecl register_module_options(module *module);
void __cdecl register_modules_options(module **modules);
int get_file_handles_count(); // idb
// int __usercall can_read_or_write@<eax>(int fd@<eax>, int write@<edx>); idb
int __cdecl can_write(int fd);
int __cdecl can_read(int fd);
void __cdecl set_handlers(int fd, select_handler_T read_func, select_handler_T write_func, select_handler_T error_func, void *data);
select_handler_T __cdecl get_handler(int fd, select_handler_type tp);
void check_bottom_halves(); // idb
void __cdecl select_loop(void (*init)(void));
int __cdecl register_bottom_half_do(select_handler_T fn, void *data);
int get_timers_count(); // idb
int __cdecl get_next_timer_time(timeval_T *t);
void __cdecl kill_timer(timer_id_T *id);
void __cdecl install_timer(timer_id_T *id, milliseconds_T delay, void (*func)(void *), void *data);
void __cdecl check_timers(timeval_T *last_time);
// void __usercall add_module_to_string(string *string@<eax>, module *module@<edx>, terminal *term@<ecx>); idb
unsigned __int8 *__cdecl get_dyn_full_version(terminal *term, int more);
void init_static_version(); // idb
void __cdecl menu_list_ext(terminal *term, void *fn_, void *xxx);
// option_elinks *__usercall get_real_opt@<eax>(unsigned __int8 *base@<eax>, unsigned __int8 *id@<edx>); idb
void __cdecl really_del_ext(void *fcp);
void __cdecl add_mime_extension(void *data);
void __cdecl menu_del_ext(terminal *term, void *fcp, void *xxx2);
void __cdecl menu_add_ext(terminal *term, void *fcp, void *xxx2);
// unsigned __int8 *__usercall get_content_filename@<eax>(uri *uri@<eax>, cache_entry *cached@<edx>); idb
string *__cdecl add_mime_filename_to_string(string *string, uri *uri);
mime_handler *__cdecl get_mime_type_handler(unsigned __int8 *content_type, int xwin);
unsigned __int8 *__cdecl get_extension_content_type(unsigned __int8 *extension);
unsigned __int8 *__cdecl get_cache_header_content_type(cache_entry *cached);
unsigned __int8 *__cdecl get_content_type(cache_entry *cached);
unsigned __int8 *__cdecl get_content_type_backends(unsigned __int8 *extension);
mime_handler *__cdecl get_mime_handler_backends(unsigned __int8 *ctype, int have_x);
mime_handler *__cdecl init_mime_handler(unsigned __int8 *program, unsigned __int8 *description, unsigned __int8 *backend_name, int ask, int block);
unsigned __int8 *__cdecl get_next_path_filename(unsigned __int8 **path_ptr, unsigned __int8 separator);
mime_handler *__cdecl get_mime_handler_default(unsigned __int8 *type, int have_x);
unsigned __int8 *__cdecl get_content_type_default(unsigned __int8 *extension);
// void __usercall done_mailcap_entry(mailcap_entry *entry@<eax>); idb
void __cdecl init_mailcap(module *module);
// const char *__usercall get_mailcap_field@<eax>(unsigned __int8 **next@<eax>);
// unsigned __int8 *__usercall get_mailcap_field_text@<eax>(unsigned __int8 *field@<eax>); idb
// unsigned __int8 *__usercall format_command@<eax>(unsigned __int8 *command@<eax>, unsigned __int8 *type@<edx>, int copiousoutput@<ecx>); idb
// mailcap_hash_item *__usercall check_entries@<eax>(mailcap_hash_item *item@<eax>);
void __cdecl done_mailcap(module *module);
int __cdecl change_hook_mailcap(session *ses, option_elinks *current, option_elinks *changed);
mime_handler *__cdecl get_mime_handler_mailcap(unsigned __int8 *type, int options);
// void __usercall done_mimetypes_entry(mimetypes_entry *entry@<eax>); idb
void __cdecl done_mimetypes(module *module);
int __cdecl change_hook_mimetypes(session *ses, option_elinks *current, option_elinks *changed);
void __cdecl init_mimetypes(module *module);
// void __usercall parse_mimetypes_file(unsigned __int8 *filename@<eax>); idb
unsigned __int8 *__cdecl get_content_type_mimetypes(unsigned __int8 *extension);
int get_connections_count(); // idb
int get_keepalive_connections_count(); // idb
int get_connections_connecting_count(); // idb
int get_connections_transfering_count(); // idb
// void __usercall notify_connection_callbacks(connection *conn@<eax>); idb
int __cdecl is_entry_used(cache_entry *cached);
// int __usercall get_priority@<eax>(connection *conn@<eax>);
// void __usercall add_to_queue(connection *conn@<eax>); idb
void sort_queue(); // idb
// connection_basic_state *__usercall connection_state_0@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
// connection *__usercall init_connection@<eax>(uri *uri@<eax>, uri *proxied_uri@<edx>, uri *referrer@<ecx>, off_t start, cache_mode cache_mode, connection_priority priority); idb
// const uri *__usercall get_host_connection@<eax>(connection *conn@<eax>);
// int __usercall add_host_connection@<eax>(connection *conn@<eax>); idb
void __cdecl set_connection_timeout(connection *conn);
void __cdecl set_connection_socket_timeout(socket *socket, connection_state state);
void __cdecl connection_timeout_1(connection *conn);
void __cdecl connection_timeout(connection *conn);
void __cdecl detach_connection(download *download, off_t pos);
int register_check_queue(); // idb
void __cdecl shutdown_connection_stream(connection *conn);
// void __usercall free_connection_data(connection *conn@<eax>); idb
void __cdecl set_connection_state(connection *conn, connection_state state);
void __cdecl set_connection_socket_state(socket *socket, connection_state state);
void __cdecl stat_timer(connection *conn);
// int __usercall try_to_suspend_connection@<eax>(connection *conn@<eax>, uri *uri@<edx>); idb
int __cdecl load_uri(uri *uri, uri *referrer, download *download, connection_priority pri, cache_mode cache_mode, off_t start);
// void __usercall done_connection(connection *conn@<eax>); idb
// int __usercall do_keepalive_connection_callback@<eax>(keepalive_connection *keep_conn@<eax>); idb
int __cdecl has_keepalive_connection(connection *conn);
void check_keepalive_connections(); // idb
void __cdecl keepalive_timer(void *x);
void __cdecl add_keepalive_connection(connection *conn, int timeout_in_seconds, void (*done)(connection *));
void __cdecl abort_connection(connection *conn, connection_state state);
void abort_background_connections(); // idb
void abort_all_connections(); // idb
void __cdecl done_connection_socket(socket *socket, connection_state state);
void __cdecl cancel_download(download *download, int interrupt);
void __cdecl move_download(download *old, download *new, connection_priority newpri);
// void __usercall run_connection(connection *conn@<eax>); idb
void __cdecl retry_connection(connection *conn, connection_state state);
void __cdecl retry_connection_socket(socket *socket, connection_state state);
void check_queue(); // idb
// void __usercall del_dns_cache_entry(dnsentry *dnsentry@<eax>); idb
void __cdecl shrink_dns_cache(int whole);
// void __usercall done_dns_lookup(dnsquery *query@<eax>, dns_result result@<edx>); idb
void __cdecl kill_dns_request(void **queryref);
void __cdecl async_dns_error(dnsquery *query);
// int __usercall read_dns_data@<eax>(int h@<eax>, void *data@<edx>, size_t datalen@<ecx>);
void __cdecl async_dns_reader(dnsquery *query);
// int __usercall write_dns_data@<eax>(int h@<eax>, void *data@<edx>, size_t datalen@<ecx>);
dns_result __cdecl do_real_lookup(unsigned __int8 *name, sockaddr_storage **addrs, int *addrno, int in_thread);
void __cdecl async_dns_writer(void *data, int h);
// dns_result __usercall init_dns_lookup@<eax>(unsigned __int8 *name@<eax>, void **queryref@<edx>, dns_callback_T done@<ecx>, void *data); idb
dns_result __cdecl find_host(unsigned __int8 *name, void **queryref, dns_callback_T done, void *data, int no_cache);
int __cdecl has_progress(progress *progress);
void __cdecl update_progress(progress *progress, off_t loaded, off_t size, off_t pos);
void __cdecl done_progress(progress *progress);
progress *__cdecl init_progress(off_t start);
void __cdecl start_update_progress(progress *progress, void (*timer_func)(void *), void *timer_func_data);
// connection_basic_state *__usercall connection_state_1@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
void __cdecl kill_buffer_data(read_buffer *rb, int n);
read_buffer *__cdecl alloc_read_buffer(socket *socket);
socket *__cdecl init_socket(void *conn, socket_operations *ops);
// connect_info *__usercall init_connection_info@<eax>(uri *uri@<eax>, socket_connect_T connect_done@<ecx>);
// void __usercall done_connection_info(socket *socket@<eax>); idb
void __cdecl complete_connect_socket(socket *socket, uri *uri, socket_connect_T done);
int __cdecl get_pasv_socket(socket *ctrl_socket, sockaddr_storage *addr);
void __cdecl close_socket(socket *socket);
void __cdecl done_socket(socket *socket);
void __cdecl exception(socket *socket);
void __cdecl read_from_socket(socket *socket, read_buffer *buffer, connection_state state, socket_read_T done);
void __cdecl read_response_from_socket(socket *socket);
void __cdecl write_to_socket(socket *socket, unsigned __int8 *data, int len, connection_state state, socket_write_T write_done);
void __cdecl request_from_socket(socket *socket, unsigned __int8 *data, int datalen, connection_state state, socket_state sock_state, socket_read_T read_done);
void __cdecl read_select(socket *socket);
void __cdecl write_select(socket *socket);
void __cdecl connect_socket(socket *csocket, connection_state state);
void __cdecl dns_found(socket *socket, sockaddr_storage *addr, int addrlen);
void __cdecl timeout_socket(socket *socket);
void __cdecl dns_exception(socket *socket);
void __cdecl connected(socket *socket);
void __cdecl make_connection(socket *socket, uri *uri, socket_connect_T connect_done, int no_cache);
void done_state_message(); // idb
unsigned __int8 *__cdecl get_state_message(connection_state state, terminal *term);
int __cdecl ssl_close(socket *socket);
ssize_t __cdecl ssl_read(socket *socket, unsigned __int8 *data, int len);
ssize_t __cdecl ssl_write(socket *socket, unsigned __int8 *data, int len);
// connection_basic_state *__usercall connection_state_2@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
void __cdecl ssl_want_read(socket *socket);
int __cdecl ssl_connect(socket *socket);
void __cdecl done_gnutls(module *module);
void __cdecl init_gnutls(module *module);
unsigned __int8 *__cdecl get_ssl_connection_cipher(socket *socket);
void __cdecl done_ssl_connection(socket *socket);
int __cdecl init_ssl_connection(socket *socket);
int __cdecl can_open_in_new(terminal *term);
void __cdecl open_new_window(terminal *term, unsigned __int8 *exe_name, term_env_type environment, unsigned __int8 *param);
void __cdecl sigwinch(void *s);
void __cdecl set_bin(int fd);
int __cdecl resize_window(int width, int height, int old_width, int old_height);
void want_draw(); // idb
void done_draw(); // idb
int get_output_handle(); // idb
void terminate_osdep(); // idb
void block_stdin(); // idb
void unblock_stdin(); // idb
void __cdecl elinks_cfmakeraw(termios *t);
int __cdecl can_resize_window(int environment);
int __cdecl can_open_os_shell(int environment);
void set_highpri(); // idb
unsigned __int8 *__cdecl get_system_str(int xwin);
void init_osdep(); // idb
int get_ctl_handle(); // idb
int get_input_handle(); // idb
unsigned __int8 *get_window_title(); // idb
unsigned __int8 *get_clipboard_text(); // idb
int __cdecl exe(unsigned __int8 *path);
int is_xterm(); // idb
int is_gnuscreen(); // idb
void __cdecl set_window_title(unsigned __int8 *title, int codepage);
void __cdecl set_clipboard_text(unsigned __int8 *data);
int is_twterm(); // idb
int get_system_env(); // idb
char *get_shell();
int __cdecl c_pipe(int *fd);
void __cdecl unhandle_terminal_resize(int fd);
void __cdecl handle_terminal_resize(int fd, void (*fn)(void));
void __cdecl set_cwd(unsigned __int8 *path);
char *get_cwd();
int __cdecl get_e(unsigned __int8 *env);
void __cdecl get_terminal_size(int fd, int *x, int *y);
void __cdecl set_ip_tos_throughput(int socket);
int __cdecl set_blocking_fd(int fd);
int __cdecl set_nonblocking_fd(int fd);
int __cdecl start_thread(void (*fn)(void *, int), void *ptr, int l);
void __cdecl sig_ign(void *x);
int check_signals(); // idb
void __cdecl sig_chld(void *p);
void uninstall_alarm(); // idb
void __cdecl sig_segv(terminal *term);
void __cdecl sig_cont(terminal *term);
void __cdecl sig_tstp(terminal *term);
void __cdecl sig_ctrl_c(terminal *term);
void clear_signal_mask_and_handlers(); // idb
void __cdecl install_signal_handler(int sig, void (*fn)(void *), void *data, int critical);
void set_sigcld(); // idb
void check_for_select_race(); // idb
void __cdecl alarm_handler(void *x);
void __cdecl got_signal(int sig);
void __cdecl unhandle_terminal_signals(terminal *term);
void __cdecl handle_basic_signals(terminal *term);
void unhandle_basic_signals();
void __cdecl sig_terminate(terminal *term);
void __cdecl sig_intr(terminal *term);
void get_system_name(); // idb
// int __usercall init_mouse@<eax>(int cons@<eax>, int suspend@<edx>); idb
void __cdecl resume_mouse(void *h);
void __cdecl suspend_mouse(void *h);
void __cdecl unhandle_mouse(void *h);
void *__cdecl handle_mouse(int cons, void (*fn)(void *, unsigned __int8 *, int), void *data);
void __cdecl gpm_mouse_in(gpm_mouse_spec *gms);
void __cdecl about_protocol_handler(connection *conn);
void close_all_non_term_fd(); // idb
// connection_state *__userpurge init_directory_listing@<eax>(connection_state *retstr, string *page, uri *uri);
// connection_basic_state *__usercall connection_state_3@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
void __cdecl data_protocol_handler(connection *conn);
int __cdecl parse_year(const unsigned __int8 **date_p, unsigned __int8 *end);
int __cdecl parse_day(const unsigned __int8 **date_p, unsigned __int8 *end);
int __cdecl parse_time(const unsigned __int8 **time, tm *tm, unsigned __int8 *end);
int __cdecl parse_month(const unsigned __int8 **buf, unsigned __int8 *end);
time_t __cdecl parse_date(unsigned __int8 **date_pos, unsigned __int8 *end, int update_pos, int skip_week_day);
unsigned __int8 *__cdecl get_header_param(unsigned __int8 *e, unsigned __int8 *name);
parse_header_param __cdecl parse_header_param_0(unsigned __int8 *str, unsigned __int8 *name, unsigned __int8 **ret);
unsigned __int8 *__cdecl parse_header(unsigned __int8 *head, unsigned __int8 *item, unsigned __int8 **ptr);
protocol_handler_T *__cdecl get_protocol_handler(protocol protocol);
int __cdecl get_protocol_need_ssl(protocol protocol);
int __cdecl get_protocol_free_syntax(protocol protocol);
int __cdecl get_protocol_keep_double_slashes(protocol protocol);
int __cdecl get_protocol_need_slash_after_host(protocol protocol);
int __cdecl get_protocol_need_slashes(protocol protocol);
int __cdecl get_protocol_port(protocol protocol);
protocol_external_handler_T *__cdecl get_protocol_external_handler(terminal *term, uri *uri);
protocol __cdecl get_protocol(unsigned __int8 *name, int namelen);
void __cdecl generic_external_protocol_handler(session *ses, uri *uri);
uri *__cdecl get_proxied_uri(uri *uri);
// unsigned __int8 *__usercall strip_proxy_protocol@<eax>(unsigned __int8 *proxy@<eax>, unsigned __int8 *strip1@<edx>, unsigned __int8 *strip2@<ecx>); idb
// unsigned __int8 *__usercall get_protocol_proxy@<eax>(unsigned __int8 *opt@<eax>, unsigned __int8 *env1@<edx>, unsigned __int8 *env2@<ecx>, unsigned __int8 *strip1, unsigned __int8 *strip2); idb
// uri *__usercall proxy_uri@<eax>(uri *uri@<eax>, unsigned __int8 *proxy@<edx>, connection_state *error_state@<ecx>); idb
uri *__cdecl get_proxy_uri(uri *uri, connection_state *error_state);
void __cdecl decode_uri(unsigned __int8 *src);
void __cdecl decode_uri_string(string *string);
void __cdecl done_uri(uri *uri);
void __cdecl free_uri_list(uri_list *list);
// void *__usercall mem_align_alloc___0@<eax>(void **ptr@<eax>, size_t old@<edx>, size_t new@<ecx>, size_t objsize, size_t mask); idb
// string *__usercall add_bytes_to_string___2@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
void __cdecl decode_uri_for_display(unsigned __int8 *src);
void __cdecl decode_uri_string_for_display(string *string);
unsigned __int8 *__cdecl get_extension_from_uri(uri *uri);
int __cdecl end_with_known_tld(const unsigned __int8 *s, int slen);
int __cdecl is_in_domain(unsigned __int8 *domain, unsigned __int8 *server, int server_len);
// int __usercall check_whether_file_exists@<eax>(unsigned __int8 *name@<eax>); idb
// protocol __usercall find_uri_protocol@<eax>(unsigned __int8 *newurl@<eax>); idb
// _BOOL4 __usercall compare_component@<eax>(const unsigned __int8 *a@<eax>, int alen@<edx>, const unsigned __int8 *b@<ecx>, int blen);
int __cdecl compare_uri(const uri *a, const uri *b, uri_component components);
int __cdecl get_uri_port(const uri *uri);
uri_errno __cdecl parse_uri(uri *uri, unsigned __int8 *uristring);
int __cdecl is_ip_address(const unsigned __int8 *address, int addresslen);
unsigned __int8 *__cdecl normalize_uri(uri *uri, unsigned __int8 *uristring);
uri *__cdecl add_to_uri_list(uri_list *list, uri *uri);
void __cdecl encode_win32_uri_string(string *string, unsigned __int8 *name, int namelen);
void __cdecl encode_uri_string(string *string, const unsigned __int8 *name, int namelen, int convert_slashes);
// unsigned __int8 *__usercall translate_url@<eax>(unsigned __int8 *url@<eax>, unsigned __int8 *cwd@<edx>); idb
unsigned __int8 *__cdecl join_urls(uri *base, unsigned __int8 *rel);
string *__cdecl add_uri_to_string(string *string, const uri *uri, uri_component components);
unsigned __int8 *__cdecl get_uri_string(const uri *uri, uri_component components);
uri *__cdecl get_composed_uri(uri *uri, uri_component components);
uri *__cdecl get_uri(unsigned __int8 *string, uri_component components);
uri *__cdecl get_translated_uri(unsigned __int8 *uristring, unsigned __int8 *cwd);
string *__cdecl add_string_uri_to_string(string *string, unsigned __int8 *uristring, uri_component components);
unsigned __int8 *__cdecl get_user_program(terminal *term, unsigned __int8 *progid, int progidlen);
void __cdecl user_protocol_handler(session *ses, uri *uri);
list_head_elinks *get_invalid_auth_entry();
// void __usercall done_auth_entry(auth_entry *entry@<eax>); idb
void __cdecl del_auth_entry(auth_entry *entry);
void free_auth(); // idb
void __cdecl done_auth(module *xxx);
// auth_entry *__usercall find_auth_entry@<eax>(uri *uri@<eax>, unsigned __int8 *realm@<edx>); idb
// void __usercall set_auth_user(auth_entry *entry@<eax>, uri *uri@<edx>); idb
// void __usercall set_auth_password(auth_entry *entry@<eax>, uri *uri@<edx>); idb
auth_entry *__cdecl add_auth_entry(uri *uri, unsigned __int8 *realm, unsigned __int8 *nonce, unsigned __int8 *opaque, unsigned int digest);
auth_entry *__cdecl find_auth(uri *uri);
void __cdecl lock_auth_entry(listbox_item *item);
void __cdecl unlock_auth_entry(listbox_item *item);
int __cdecl is_auth_entry_used(listbox_item *item);
listbox_item *__cdecl get_auth_entry_root(listbox_item *box_item);
int __cdecl can_delete_auth_entry(listbox_item *item);
void __cdecl delete_auth_entry(listbox_item *item, int last);
void __cdecl auth_cancel(void *data);
uri *__cdecl get_auth_entry_uri(listbox_item *item);
// string *__usercall add_bytes_to_string___3@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
// unsigned __int8 *__usercall _6@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_auth_entry_info(listbox_item *item, terminal *term);
unsigned __int8 *__cdecl get_auth_entry_text(listbox_item *item, terminal *term);
void __cdecl auth_manager(session *ses);
void __cdecl auth_ok(void *data);
void __cdecl do_auth_dialog(session *ses, void *data);
// void __usercall convert_to_md5_digest_hex_T(unsigned __int8 *bin@<eax>, unsigned __int8 *hex@<edx>); idb
unsigned __int8 *__cdecl get_http_auth_digest_response(auth_entry *entry, uri *uri);
// connection_basic_state *__usercall connection_state_4@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
void __cdecl close_pipe_and_read(socket *data_socket);
// void __usercall send_post_data(connection *conn@<eax>); idb
int __cdecl execute_cgi(connection *conn);
// void __usercall add_dir_entry(directory_entry *entry@<eax>, string *page@<edx>, int pathlen@<ecx>, unsigned __int8 *dircolor); idb
// connection_basic_state *__usercall connection_state_5@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
void __cdecl file_protocol_handler(connection *connection);
void __cdecl finger_protocol_handler(connection *conn);
void __cdecl finger_send_request(socket *socket);
void __cdecl finger_get_response(socket *socket, read_buffer *rb);
// connection_basic_state *__usercall connection_state_6@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
// int __usercall parse_psv_resp@<eax>(unsigned __int8 *data@<eax>, int *n@<edx>, int max_value@<ecx>); idb
// void __usercall send_cmd(connection *conn@<eax>, string *cmd@<edx>, void *callback@<ecx>, connection_state state); idb
// int __usercall ftp_data_connect@<eax>(connection *conn@<eax>, int pf_0@<edx>, sockaddr_storage *sa@<ecx>, int size_of_sockaddr); idb
// int __usercall get_ftp_response@<eax>(connection *conn@<eax>, read_buffer *rb@<edx>, int part@<ecx>, sockaddr_storage *sa); idb
// void __usercall ftp_end_request(connection *conn@<eax>, connection_state state@<0:edx, 4:ecx>); idb
void __cdecl ftp_data_accept(connection *conn);
// int __usercall display_dir_entry@<eax>(cache_entry *cached@<eax>, off_t *pos@<edx>, int *tries@<ecx>, const ftp_dir_html_format *format, ftp_file_info *ftp_info); idb
// int __usercall ftp_process_dirlist@<eax>(cache_entry *cached@<eax>, off_t *pos@<edx>, unsigned __int8 *buffer@<ecx>, int buflen, int last, int *tries, const ftp_dir_html_format *format); idb
void __cdecl got_something_from_data_connection(connection *conn);
// void __usercall ftp_send_retr_req(connection *conn@<eax>, connection_state state@<0:edx, 4:ecx>); idb
void __cdecl ftp_protocol_handler(connection *conn);
void __cdecl ftp_got_final_response(socket *socket, read_buffer *rb);
void __cdecl ftp_retr_file(socket *socket, read_buffer *rb);
// void __usercall prompt_username_pw(connection *conn@<eax>); idb
void __cdecl ftp_pass_info(socket *socket, read_buffer *rb);
void __cdecl ftp_login(socket *socket);
void __cdecl ftp_got_user_info(socket *socket, read_buffer *rb);
void __cdecl ftp_got_info(socket *socket, read_buffer *rb);
ftp_file_info *__cdecl parse_ftp_winnt_response(ftp_file_info *info, unsigned __int8 *src, int len);
ftp_file_info *__cdecl parse_ftp_file_info(ftp_file_info *info, unsigned __int8 *src, int len);
void free_blacklist(); // idb
// blacklist_entry *__usercall get_blacklist_entry@<eax>(uri *uri@<eax>); idb
blacklist_flags __cdecl get_blacklist_flags(uri *uri);
void __cdecl del_blacklist_entry(uri *uri, blacklist_flags flags);
void __cdecl add_blacklist_entry(uri *uri, blacklist_flags flags);
int __cdecl compare_http_codes(const void *key, const void *element);
void __cdecl http_error_document(connection *conn, int code);
void __cdecl show_http_error_document(session *ses, void *data);
void done_http(); // idb
// connection_basic_state *__usercall connection_state_7@<eax>(connection_basic_state basic@<edx>, connection_basic_state *result@<eax>);
// void __usercall http_end_request(connection *conn@<eax>, connection_state state@<0:edx, 4:ecx>, int notrunc); idb
// unsigned __int8 *__usercall decompress_data@<eax>(connection *conn@<eax>, unsigned __int8 *data@<edx>, int len@<ecx>, int *new_len); idb
// string *__usercall add_bytes_to_string___4@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
http_connection_info *__cdecl init_http_connection_info(connection *conn, int major, int minor, int close);
// void __usercall read_http_data_done(connection *conn@<eax>); idb
// void __usercall read_more_http_data(connection *conn@<eax>, read_buffer *rb@<edx>, int already_got_anything@<ecx>); idb
void __cdecl read_http_data(socket *socket, read_buffer *rb);
// void __usercall add_url_to_http_string(string *header@<eax>, uri *uri@<edx>, int components@<ecx>); idb
void __cdecl http_got_header(socket *socket, read_buffer *rb);
unsigned __int8 *__cdecl subst_user_agent(unsigned __int8 *fmt, unsigned __int8 *version, unsigned __int8 *sysname, unsigned __int8 *termsize);
void __cdecl http_send_header(socket *socket);
void __cdecl http_protocol_handler(connection *conn);
void __cdecl proxy_protocol_handler(connection *conn);
// const uri *__usercall http_negotiate_get@<eax>(uri *uri@<eax>, int *isnew@<edx>, int alloc@<ecx>);
// int __usercall http_negotiate_create_context@<eax>(negotiate *neg@<eax>); idb
// void __usercall http_negotiate_cleanup(negotiate *neg@<eax>, int full@<edx>); idb
int __cdecl http_negotiate_output(uri *uri, string *header);
// int __usercall http_negotiate_get_name@<eax>(connection *conn@<eax>, negotiate *neg@<edx>); idb
int __cdecl http_negotiate_input(connection *conn, uri *uri, int type, unsigned __int8 *data);
// unsigned __int8 *__usercall get_uri_rewrite_prefix@<eax>(uri_rewrite_type type@<eax>, unsigned __int8 *url@<edx>); idb
evhook_status __cdecl goto_url_hook(va_list ap, void *data);
void __cdecl report_scripting_error(module *module, session *ses, unsigned __int8 *msg);
VALUE __cdecl erb_module_method_missing(VALUE self, VALUE arg);
VALUE __cdecl erb_stdout_p(int argc, VALUE *argv, VALUE self);
VALUE __cdecl erb_module_message(VALUE self, VALUE str);
void __cdecl alert_ruby_error(session *ses, unsigned __int8 *msg);
void __cdecl erb_report_error(session *ses, int error);
void __cdecl init_ruby(module *module);
evhook_status __cdecl script_hook_quit(va_list ap, void *data);
VALUE __cdecl do_erb_protected_method_call(VALUE data);
evhook_status __cdecl script_hook_get_proxy(va_list ap, void *data);
evhook_status __cdecl script_hook_follow_url(va_list ap, void *data);
evhook_status __cdecl script_hook_goto_url(va_list ap, void *data);
evhook_status __cdecl script_hook_pre_format_html(va_list ap, void *data);
int are_there_downloads(); // idb
void __cdecl lun_cancel(void *lun_hop_);
void __cdecl lun_overwrite(void *lun_hop_);
void __cdecl lun_alternate(void *lun_hop_);
widget_handler_status_T __cdecl tp_show_header(dialog_data *dlg_data, widget_data *widget_data);
// unsigned __int8 *__usercall subst_file@<eax>(unsigned __int8 *prog@<eax>, unsigned __int8 *file@<edx>); idb
void __cdecl tp_save(type_query *type_query);
void __cdecl done_type_query(type_query *type_query);
void __cdecl tp_display(type_query *type_query);
void __cdecl tp_cancel(void *data);
void __cdecl lun_resume(void *lun_hop_);
// void __usercall download_error_dialog(file_download *file_download@<eax>, int saved_errno@<edx>); idb
void __cdecl create_download_file_do(terminal *term, unsigned __int8 *file, void *data, int resume);
void __cdecl abort_download(file_download *file_download);
// void __usercall kill_downloads_to_file(unsigned __int8 *file@<eax>); idb
void __cdecl detach_downloads_from_terminal(terminal *term);
void __cdecl destroy_downloads(session *ses);
void abort_all_downloads(); // idb
file_download *__cdecl init_file_download(uri *uri, session *ses, unsigned __int8 *file, int fd);
void __cdecl continue_download_do(terminal *term, int fd, void *data, int resume);
void __cdecl common_download_do(terminal *term, int fd, void *data, int resume);
// void __usercall abort_download_and_beep(file_download *file_download@<eax>, terminal *term@<edx>); idb
// void __usercall download_data_store(download *download@<eax>, file_download *file_download@<edx>); idb
void __cdecl download_data(download *download, file_download *file_download);
int __cdecl download_is_progressing(download *download);
void __cdecl create_download_file(terminal *term, unsigned __int8 *fi, unsigned __int8 **real_file, int safe, int resume, void (*callback)(terminal *, int, void *, int), void *data);
void __cdecl continue_download(void *data, unsigned __int8 *file);
void __cdecl tp_open(type_query *type_query);
// void __usercall common_download(session *ses@<eax>, unsigned __int8 *file@<edx>, int resume@<ecx>); idb
void __cdecl resume_download(void *ses, unsigned __int8 *file);
void __cdecl start_download(void *ses, unsigned __int8 *file);
int __cdecl setup_download_handler(session *ses, download *loading, cache_entry *cached, int frame);
void __cdecl create_history(ses_history *history);
void __cdecl add_to_history(ses_history *history, location *loc);
void __cdecl del_from_history(ses_history *history, location *loc);
void __cdecl go_history(session *ses, location *loc);
void __cdecl go_history_by_n(session *ses, int n);
void __cdecl go_unback(session *ses);
void __cdecl go_back(session *ses);
void __cdecl clean_unhistory(ses_history *history);
void __cdecl destroy_history(ses_history *history);
void __cdecl ses_history_move(session *ses);
void __cdecl destroy_location(location *loc);
void __cdecl copy_location(location *dst, location *src);
download *__cdecl get_current_download(session *ses);
link *__cdecl get_current_link_in_view(document_view *doc_view);
int __cdecl eat_kbd_repeat_count(session *ses);
link *__cdecl get_current_session_link(session *ses);
unsigned __int8 *__cdecl get_current_link_name(session *ses, unsigned __int8 *str, size_t str_size);
unsigned __int8 *__cdecl get_current_link_url(session *ses, unsigned __int8 *str, size_t str_size);
unsigned __int8 *__cdecl get_current_title(session *ses, unsigned __int8 *str, size_t str_size);
unsigned __int8 *__cdecl get_current_url(session *ses, unsigned __int8 *str, size_t str_size);
void __cdecl set_session_referrer(session *ses, uri *referrer);
frame *__cdecl ses_find_frame(session *ses, unsigned __int8 *name);
// void __usercall load_additional_file(file_to_load *ftl@<eax>, cache_mode cache_mode@<edx>); idb
void __cdecl process_file_requests(session *ses);
void __cdecl abort_loading(session *ses, int interrupt);
void __cdecl reload(session *ses, cache_mode cache_mode);
void __cdecl check_questions_queue(session *ses);
void __cdecl free_files(session *ses);
// void __usercall done_session_info(session_info *info@<eax>); idb
void __cdecl session_info_timeout(int id);
void done_saved_session_info(); // idb
void __cdecl dialog_goto_url_open(void *data);
// void __usercall init_remote_session(session *ses@<eax>, remote_session_flags *remote_ptr@<edx>, uri *uri@<ecx>); idb
string *__cdecl encode_session_info(string *info, list_head_elinks *url_list);
session *__cdecl init_session(session *base_session, terminal *term, uri *uri, int in_background);
// const uri **__usercall request_additional_file@<eax>(session *ses@<eax>, unsigned __int8 *name@<edx>, uri *uri@<ecx>, int pri);
int __cdecl session_is_loading(session *ses);
void __cdecl add_questions_entry(void (*callback)(session *, void *), void *data);
int __cdecl add_session_info(session *ses, uri *uri, uri *referrer, cache_mode cache_mode, task_type task);
// void __usercall request_frameset(session *ses@<eax>, frameset_desc *frameset_desc@<edx>, int depth@<ecx>); idb
void __cdecl print_error_dialog(session *ses, connection_state state, uri *uri, connection_priority priority);
int __cdecl decode_session_info(terminal *term, terminal_info *info);
void __cdecl load_frames(session *ses, document_view *doc_view);
void __cdecl tabwin_func(window *tab, term_event *ev);
void __cdecl display_timer(session *ses);
void __cdecl doc_loading_callback(download *download, session *ses);
void __cdecl file_loading_callback(download *download, file_to_load *ftl);
// void __usercall free_task(session *ses@<eax>); idb
uri *__cdecl get_hooked_uri(unsigned __int8 *uristring, session *ses, unsigned __int8 *cwd);
view_state *__cdecl ses_forward(session *ses, int loaded_in_frame);
void __cdecl post_no(void *task_);
void __cdecl ses_load(session *ses, uri *uri, unsigned __int8 *target_frame, location *target_location, cache_mode cache_mode, task_type task_type);
void __cdecl ses_goto(session *ses, uri *uri, unsigned __int8 *target_frame, location *target_location, cache_mode cache_mode, task_type task_type, int redir);
// void __usercall do_follow_url(session *ses@<eax>, uri *uri@<edx>, unsigned __int8 *target@<ecx>, task_type task, cache_mode cache_mode, int do_referrer); idb
// void __usercall follow_url(session *ses@<eax>, uri *uri@<edx>, unsigned __int8 *target@<ecx>, task_type task, cache_mode cache_mode, int referrer); idb
void __cdecl goto_imgmap(session *ses, uri *uri, unsigned __int8 *target);
void __cdecl goto_uri_frame(session *ses, uri *uri, unsigned __int8 *target, cache_mode cache_mode);
void __cdecl map_selected(terminal *term, void *ld_, void *ses_);
void __cdecl delayed_goto_uri_frame(void *data);
void __cdecl goto_uri(session *ses, uri *uri);
void __cdecl goto_url_with_hook(session *ses, unsigned __int8 *url);
int __cdecl goto_url_home(session *ses);
void __cdecl goto_url(session *ses, unsigned __int8 *url);
void __cdecl loading_callback(download *download, session *ses);
void __cdecl abort_preloading(session *ses, int interrupt);
void __cdecl post_yes(void *task_);
void __cdecl set_term_color16(screen_char *schar, color_flags flags, unsigned __int8 fg, unsigned __int8 bg);
void __cdecl set_term_color(screen_char *schar, color_pair *pair, color_flags flags, color_mode color_mode);
screen_char *__cdecl get_char(terminal *term, int x, int y);
void __cdecl set_cursor(terminal *term, int x, int y, int blockable);
void __cdecl draw_box(terminal *term, box *box, unsigned __int8 data, screen_char_attr attr, color_pair *color);
void __cdecl clear_terminal(terminal *term);
void __cdecl draw_shadow(terminal *term, box *box, color_pair *color, int width, int height);
void __cdecl draw_char_data(terminal *term, int x, int y, unicode_val_T data);
void __cdecl draw_char(terminal *term, int x, int y, unicode_val_T data, screen_char_attr attr, color_pair *color);
void __cdecl draw_line(terminal *term, int x, int y, int l, screen_char *line);
void __cdecl draw_char_color(terminal *term, int x, int y, color_pair *color);
void __cdecl draw_border_char(terminal *term, int x, int y, border_char border, color_pair *color);
void __cdecl draw_border(terminal *term, box *box, color_pair *color, int width);
void __cdecl draw_border_cross(terminal *term, int x, int y, border_cross_direction dir, color_pair *color);
void __cdecl draw_text(terminal *term, int x, int y, unsigned __int8 *text, int length, screen_char_attr attr, color_pair *color);
void __cdecl fix_dwchar_around_box(terminal *term, box *box, int border, int shadow_width, int shadow_height);
void __cdecl term_send_event(terminal *term, term_event *ev);
// void __usercall term_send_ucs(terminal *term@<eax>, unicode_val_T u@<edx>, term_event_modifier_T modifier@<ecx>); idb
void __cdecl in_term(terminal *term);
ssize_t __cdecl hard_read(int fd, unsigned __int8 *data, size_t datalen);
ssize_t __cdecl hard_write(int fd, unsigned __int8 *data, size_t datalen);
int is_blocked(); // idb
// void __usercall send_done_sequence(int h@<eax>, int altscreen@<edx>); idb
// void __usercall unhandle_itrm_stdin(itrm *itrm@<eax>); idb
void block_itrm(); // idb
// void __usercall handle_itrm_stdin(itrm *itrm@<eax>); idb
// void __usercall set_kbd_interlink_event(interlink_event *ev@<eax>, int key@<edx>, term_event_modifier_T modifier@<ecx>); idb
// void __usercall send_init_sequence(int h@<eax>, int altscreen@<edx>); idb
void __cdecl get_terminal_name(unsigned __int8 *name);
void __cdecl free_itrm(itrm *itrm);
void free_all_itrms(); // idb
void __cdecl itrm_queue_event(itrm *itrm, unsigned __int8 *data, int len);
void __cdecl itrm_queue_write(itrm *itrm);
// int __usercall setraw@<eax>(itrm *itrm@<eax>, int save_orig@<edx>); idb
int unblock_itrm(); // idb
void __cdecl handle_trm(int std_in, int std_out, int sock_in, int sock_out, int ctl_in, void *init_string, int init_len, int remote);
void resize_terminal(); // idb
void __cdecl dispatch_special(unsigned __int8 *text);
void __cdecl unblock_itrm_x(void *h);
// void __usercall set_kbd_event(const itrm *itrm@<eax>, interlink_event *ev@<edx>, int key@<ecx>, term_event_modifier_T modifier); idb
void __cdecl in_sock(itrm *itrm);
void kbd_ctrl_c(); // idb
// int __usercall process_queue@<eax>(itrm *itrm@<eax>); idb
void __cdecl in_kbd(itrm *itrm);
void __cdecl kbd_timeout(itrm *itrm);
int __cdecl decode_terminal_mouse_escape_sequence(itrm *itrm, interlink_event *ev, int el, int v);
void __cdecl send_mouse_done_sequence(int h);
void disable_mouse(); // idb
void __cdecl send_mouse_init_sequence(int h);
void enable_mouse(); // idb
void toggle_mouse(); // idb
void __cdecl done_screen(terminal_screen *screen);
void __cdecl done_screen_drivers(module *xxx);
void __cdecl resize_screen(terminal *term, int width, int height);
terminal_screen *init_screen(); // idb
void __cdecl beep_terminal(terminal *term);
void __cdecl erase_screen(terminal *term);
// void __usercall set_screen_driver_opt(screen_driver *driver@<eax>, option_elinks *term_spec@<edx>); idb
int __cdecl screen_driver_change_hook(session *ses, option_elinks *term_spec, option_elinks *changed);
// string *__usercall add_bytes_to_string___5@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
void __cdecl redraw_screen(terminal *term);
int __cdecl number_of_tabs(terminal *term);
int __cdecl get_tab_number(window *window);
int __cdecl get_tab_number_by_xpos(terminal *term, int xpos);
window *__cdecl get_tab_by_number(terminal *term, int num);
void __cdecl open_uri_in_new_tab(session *ses, uri *uri, int in_background, int based);
void __cdecl open_current_link_in_new_tab(session *ses, int in_background);
void __cdecl delayed_open_0(void *data);
void __cdecl really_close_tabs(void *ses_);
void __cdecl close_all_tabs_but_current(session *ses);
void __cdecl switch_to_tab(terminal *term, int tab, int tabs_count);
void __cdecl move_current_tab(session *ses, int direction);
void __cdecl really_close_tab(void *ses_);
void __cdecl switch_current_tab(session *ses, int direction);
void __cdecl close_tab(terminal *term, session *ses);
window *__cdecl init_tab(terminal *term, void *data, window_handler_T *handler);
void close_terminal_pipes(); // idb
int check_terminal_pipes(); // idb
int __cdecl get_terminal_codepage(const terminal *term);
void __cdecl close_handle(void *h);
void __cdecl exec_on_terminal(terminal *term, unsigned __int8 *path, unsigned __int8 *delete, term_exec fg);
void __cdecl do_terminal_function(terminal *term, unsigned __int8 code, unsigned __int8 *data);
int __cdecl set_terminal_title(terminal *term, unsigned __int8 *title);
void __cdecl exec_shell(terminal *term);
void __cdecl assert_terminal_ptr_not_dangling(const terminal *suspect);
void __cdecl exec_thread(unsigned __int8 *path, int p);
void __cdecl destroy_terminal(terminal *term);
void destroy_all_terminals(); // idb
void redraw_all_terminals(); // idb
terminal *__cdecl init_term(int fdin, int fdout);
terminal *__cdecl attach_terminal(int in, int out, int ctl, void *info, int len);
void __cdecl redraw_terminal(terminal *term);
void __cdecl redraw_terminal_cls(terminal *term);
void __cdecl unblock_terminal(terminal *term);
void cls_redraw_all_terminals(); // idb
void __cdecl get_parent_ptr(window *win, int *x, int *y);
void __cdecl redraw_from_window(window *win);
void __cdecl delete_window(window *win);
void __cdecl empty_window_handler(window *win, term_event *ev);
void __cdecl delete_window_ev(window *win, term_event *ev);
void __cdecl add_window(terminal *term, window_handler_T *handler, void *data);
void __cdecl add_empty_window(terminal *term, void (*fn)(void *), void *data);
void __cdecl redraw_below_window(window *win);
unsigned __int8 *__cdecl base64_encode_bin(unsigned __int8 *in, int inlen, int *outlen);
unsigned __int8 *__cdecl base64_decode_bin(unsigned __int8 *in, int inlen, int *outlen);
unsigned __int8 *__cdecl base64_decode(unsigned __int8 *in);
unsigned __int8 *__cdecl base64_encode(unsigned __int8 *in);
void colors_list_reset(); // idb
fastfind_key_value *colors_list_next(); // idb
void __cdecl color_to_string(color_T color, unsigned __int8 *str);
const unsigned __int8 *__cdecl get_color_string(color_T color, unsigned __int8 *hexcolor);
int __cdecl decode_color(const unsigned __int8 *str, int slen, color_T *color);
void free_colors_lookup(); // idb
void init_colors_lookup(); // idb
int __cdecl elinks_ulongcat(unsigned __int8 *s, unsigned int *slen, unsigned int number, unsigned int width, unsigned __int8 fillchar, unsigned int base, unsigned int upper);
int __cdecl month2num(const unsigned __int8 *str);
int __cdecl c_tolower(int c);
int __cdecl c_toupper(int c);
int __cdecl c_isupper(int c);
int __cdecl c_islower(int c);
void __cdecl clr_spaces(unsigned __int8 *str);
int __cdecl strtolx(unsigned __int8 *str, unsigned __int8 **end);
string *__cdecl add_shell_safe_to_string(string *string, unsigned __int8 *cmd, int cmdlen);
string *__cdecl add_quoted_to_string(string *string, const unsigned __int8 *src, int len);
string *__cdecl add_shell_quoted_to_string(string *string, unsigned __int8 *src, int len);
// string *__usercall add_bytes_to_string___6@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
string *__cdecl add_date_to_string(string *string, const unsigned __int8 *fmt, const time_t *date);
int __cdecl sanitize_url(unsigned __int8 *url);
void __cdecl sanitize_title(unsigned __int8 *title);
int __cdecl elinks_longcat(unsigned __int8 *s, unsigned int *slen, int number, unsigned int width, unsigned __int8 fillchar, unsigned int base, unsigned int upper);
string *__cdecl add_knum_to_string(string *string, int num);
string *__cdecl add_string_replace(string *string, unsigned __int8 *src, int len, unsigned __int8 replaceable, unsigned __int8 replacement);
string *__cdecl add_duration_to_string(string *string, int seconds);
string *__cdecl add_timeval_to_string(string *string, timeval_T *timeval);
string *__cdecl add_long_to_string(string *string, int number);
string *__cdecl add_cp_html_to_string(string *string, int src_codepage, const unsigned __int8 *src, int len);
string *__cdecl add_html_to_string(string *string, const unsigned __int8 *src, int len);
string *__cdecl add_xnum_to_string(string *string, off_t xnum);
int __cdecl env_set(unsigned __int8 *name, unsigned __int8 *value, int length);
void __cdecl do_not_optimize_here(void *p);
void __cdecl dump_backtrace(FILE *f, int trouble);
void usrerror(unsigned __int8 *fmt, ...);
// void __usercall er(int bell@<eax>, int shall_sleep@<edx>, unsigned __int8 *fmt@<ecx>, va_list params); idb
void elinks_internal(unsigned __int8 *fmt, ...);
void elinks_assertm(int x, unsigned __int8 *fmt, ...);
void elinks_error(unsigned __int8 *fmt, ...);
void elinks_wdebug(unsigned __int8 *fmt, ...);
void elinks_debug(unsigned __int8 *fmt, ...);
void __cdecl fastfind_done(fastfind_index *index);
void *__cdecl fastfind_search(fastfind_index *index, const unsigned __int8 *key, int key_len);
// int __usercall alloc_leafset@<eax>(fastfind_info *info@<eax>); idb
// void __usercall compress_tree(ff_node_c *leafset@<eax>, fastfind_info *info@<edx>); idb
fastfind_index *__cdecl fastfind_index_0(fastfind_index *index, fastfind_flags flags);
int __cdecl mkalldirs(const unsigned __int8 *path);
directory_entry *__cdecl get_directory_entries(unsigned __int8 *dirname, int get_hidden);
int __cdecl compare_dir_entries(const void *v1, const void *v2);
int __cdecl safe_mkstemp(unsigned __int8 *template);
unsigned __int8 *__cdecl file_read_line(unsigned __int8 *line, size_t *size, FILE *file, int *lineno);
unsigned __int8 *__cdecl get_tempdir_filename(unsigned __int8 *name);
unsigned __int8 *__cdecl get_filename_position(unsigned __int8 *filename);
unsigned __int8 *__cdecl expand_tilde(unsigned __int8 *filename);
int __cdecl file_is_dir(const unsigned __int8 *filename);
int __cdecl file_can_read(const unsigned __int8 *filename);
int __cdecl file_exists(const unsigned __int8 *filename);
unsigned __int8 *__cdecl get_unique_name(unsigned __int8 *fileprefix);
hash_value_T __cdecl strhash(unsigned __int8 *k, unsigned int length, hash_value_T initval);
void __cdecl del_hash_item(hash *hash, hash_item *item);
void __cdecl free_hash(hash **hashp);
hash_item *__cdecl get_hash_item(hash *hash, unsigned __int8 *key, unsigned int keylen);
hash_item *__cdecl add_hash_item(hash *hash, unsigned __int8 *key, unsigned int keylen, void *value);
hash *init_hash8(); // idb
void __cdecl init_md5(md5_context *ctx);
// void __usercall transform_md5(uint32_t *buf@<eax>, const uint32_t *in@<edx>); idb
void __cdecl update_md5(md5_context *ctx, const unsigned __int8 *buf, unsigned int len);
void __cdecl done_md5(md5_context *ctx, unsigned __int8 *digest);
unsigned __int8 *__cdecl digest_md5(const unsigned __int8 *data, unsigned int length, unsigned __int8 *digest);
void __cdecl freeml(memory_list *ml);
void __cdecl add_one_to_ml(memory_list **ml, void *p);
void add_to_ml(memory_list **ml, ...);
memory_list *getml(void *p, ...);
// size_t __usercall round_size@<eax>(size_t size@<eax>); idb
void __cdecl mem_mmap_free(void *p, size_t size);
void *__cdecl mem_mmap_alloc(size_t size);
void *__cdecl mem_mmap_realloc(void *p, size_t old_size, size_t new_size);
// int __usercall patience@<eax>(unsigned __int8 *of_0@<eax>); idb
void __cdecl mem_free(void *p);
void *__cdecl mem_calloc(size_t count, size_t eltsize);
void *__cdecl mem_alloc(size_t size);
void *__cdecl mem_realloc(void *p, size_t size);
scanner_token *__cdecl skip_scanner_tokens(scanner *scanner, int skipto, int precedence);
void __cdecl init_scanner(scanner *scanner, scanner_info *scanner_info, unsigned __int8 *string, unsigned __int8 *end);
int __cdecl map_scanner_string(scanner *scanner, const unsigned __int8 *ident, const unsigned __int8 *end, int base_type);
int secure_fprintf(secure_save_info *ssi, const char *format, ...);
int __cdecl secure_fputc(secure_save_info *ssi, int c);
int __cdecl secure_fputs(secure_save_info *ssi, const char *s);
int __cdecl secure_close(secure_save_info *ssi);
secure_save_info *__cdecl secure_open(unsigned __int8 *file_name);
unsigned __int8 *__cdecl secsave_strerror(secsave_errno secsave_error, terminal *term);
void dummy_snprintf(); // idb
unsigned __int8 *asprintfa(const char *fmt, ...);
string *__cdecl init_string(string *string);
int __cdecl elinks_strlcmp(const unsigned __int8 *s1, size_t n1, const unsigned __int8 *s2, size_t n2);
void __cdecl done_string(string *string);
void __cdecl add_to_strn(unsigned __int8 **dst, const unsigned __int8 *src);
unsigned __int8 *__cdecl memacpy(const unsigned __int8 *src, int len);
unsigned __int8 *__cdecl stracpy(const unsigned __int8 *src);
unsigned __int8 *straconcat(const unsigned __int8 *str, ...);
int __cdecl c_strncasecmp(const char *s1, const char *s2, size_t n);
char *__cdecl c_strcasestr(const char *haystack, const char *needle);
int __cdecl c_strcasecmp(const char *s1, const char *s2);
int __cdecl elinks_strlcasecmp(const unsigned __int8 *s1, size_t n1, const unsigned __int8 *s2, size_t n2, const int locale_indep);
unsigned __int8 *__cdecl safe_strncpy(unsigned __int8 *dst, const unsigned __int8 *src, size_t dst_size);
int __cdecl xstrcmp(const unsigned __int8 *s1, const unsigned __int8 *s2);
unsigned __int8 *__cdecl insert_in_string(unsigned __int8 **dst, int pos, const unsigned __int8 *seq, int seqlen);
// void *__usercall mem_align_alloc___3@<eax>(void **@<eax>, int@<edx>, int@<ecx>);
string *add_format_to_string(string *string, const unsigned __int8 *format, ...);
string *__cdecl add_xchar_to_string(string *string, unsigned __int8 character, int times);
void __cdecl free_string_list(list_head_elinks *list);
string *__cdecl add_to_string_list(list_head_elinks *list, const unsigned __int8 *source, int length);
string *string_concat(string *string, ...);
string *__cdecl add_crlf_to_string(string *string);
string *__cdecl add_char_to_string(string *string, unsigned __int8 character);
string *__cdecl add_to_string(string *string, const unsigned __int8 *source);
string *__cdecl add_string_to_string(string *string, const string *from);
string *__cdecl add_file_to_string(string *string, const unsigned __int8 *filename);
timeval_T *__cdecl timeval_sub_interval(timeval_T *t, timeval_T *interval);
timeval_T *__cdecl timeval_sub(timeval_T *res, timeval_T *older, timeval_T *newer);
timeval_T *__cdecl timeval_add(timeval_T *res, timeval_T *base, timeval_T *t);
timeval_T *__cdecl timeval_add_interval(timeval_T *t, timeval_T *interval);
timeval_T *__cdecl timeval_from_double(timeval_T *t, double x);
timeval_T *__cdecl timeval_from_milliseconds(timeval_T *t, milliseconds_T milliseconds);
timeval_T *__cdecl timeval_from_seconds(timeval_T *t, int seconds);
int __cdecl timeval_to_seconds(timeval_T *t);
int __cdecl timeval_is_positive(timeval_T *t);
void __cdecl timeval_limit_to_zero_or_one(timeval_T *t);
int __cdecl timeval_cmp(timeval_T *t1, timeval_T *t2);
int __cdecl timeval_div_off_t(off_t n, timeval_T *t);
milliseconds_T __cdecl mult_ms(milliseconds_T a, int lb);
milliseconds_T __cdecl add_ms_to_ms(milliseconds_T a, milliseconds_T b);
milliseconds_T __cdecl sec_to_ms(int sec);
milliseconds_T __cdecl timeval_to_milliseconds(timeval_T *t);
timeval_T *__cdecl timeval_now(timeval_T *t);
// void __usercall goto_url_action(session *ses@<eax>, unsigned __int8 *(*get_url)(session *, unsigned __int8 *, size_t)@<edx>); idb
frame_event_status __cdecl do_action(session *ses, main_action action_id, int verbose);
int get_timer_duration(); // idb
void __cdecl done_timer_0(module *module);
void reset_timer(); // idb
void __cdecl init_timer_0(module *module);
void __cdecl count_down(void *xxx);
// dump_output *__usercall dump_output_alloc@<eax>(int fd@<eax>, string *string@<edx>); idb
// int __usercall dump_output_flush@<eax>(dump_output *out@<eax>); idb
// int __usercall write_char@<eax>(unsigned __int8 c@<al>, dump_output *out@<edx>); idb
// int __usercall write_color_16@<eax>(unsigned __int8 color@<al>, dump_output *out@<edx>); idb
// int __usercall dump_nocolor@<eax>(document *document@<eax>, dump_output *out@<edx>); idb
string *__cdecl add_document_to_string(string *string, document *document);
// int __usercall write_color_256@<eax>(const unsigned __int8 *str@<eax>, unsigned __int8 color@<dl>, dump_output *out@<ecx>); idb
// int __usercall dump_256color@<eax>(document *document@<eax>, dump_output *out@<edx>); idb
// int __usercall dump_references@<eax>(document *document@<eax>, int fd@<edx>, unsigned __int8 *buf@<ecx>); idb
int __cdecl dump_to_file(document *document, int fd);
// void __usercall dump_print(unsigned __int8 *option_elinks@<eax>, string *url@<edx>); idb
void __cdecl dump_next(list_head_elinks *url_list);
void __cdecl dump_loading_callback(download *download, void *p);
// void __usercall draw_frame_lines(terminal *term@<eax>, frameset_desc *frameset_desc@<edx>, int xp@<ecx>, int yp, color_pair *colors); idb
// void __usercall draw_view_status(session *ses@<eax>, document_view *doc_view@<edx>, int active@<ecx>); idb
// void __usercall draw_doc(session *ses@<eax>, document_view *doc_view@<edx>, int active@<ecx>); idb
void __cdecl refresh_view(session *ses, document_view *doc_view, int frames);
void __cdecl draw_formatted(session *ses, int rerender);
form_control *__cdecl find_form_control(document *document, form_state *fs_0);
form *__cdecl find_form_by_form_view(document *document, form_view *fv);
// const char *__usercall get_form_label@<eax>(form_control *fc@<eax>);
// unsigned __int8 *__usercall _7@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
void __cdecl done_form_view(form_view *fv);
void __cdecl done_form_state(form_state *fs_0);
void __cdecl done_submitted_value(submitted_value *sv);
void __cdecl done_submitted_value_list(list_head_elinks *list);
void __cdecl link_form_menu_func(terminal *term, void *link_number_, void *ses_);
frame_event_status __cdecl submit_form(session *ses, document_view *doc_view, int do_reload);
void __cdecl file_form_menu(terminal *term, void *path_, void *fs_);
void __cdecl set_file_form_state(terminal *term, void *filename_, void *fs_);
// void __usercall fixup_select_state(form_control *fc@<eax>, form_state *fs_0@<edx>); idb
submitted_value *__cdecl init_submitted_value(unsigned __int8 *name, unsigned __int8 *value, form_type type, form_control *fc, int position);
unsigned __int8 *__cdecl encode_crlf(submitted_value *sv);
// void *__usercall mem_align_alloc___1@<eax>(void **ptr@<eax>, size_t old@<edx>, size_t new@<ecx>, size_t objsize, size_t mask); idb
// string *__usercall add_bytes_to_string___7@<eax>(string *string@<eax>, const unsigned __int8 *bytes@<edx>, int length@<ecx>); idb
// void __usercall init_form_state(document_view *doc_view@<eax>, form_control *fc@<edx>, form_state *fs_0@<ecx>); idb
form_view *__cdecl find_form_view_in_vs(view_state *vs, int form_num);
form_view *__cdecl find_form_view(document_view *doc_view, form *form);
form_state *__cdecl find_form_state(document_view *doc_view, form_control *fc);
frame_event_status __cdecl field_op(session *ses, document_view *doc_view, link *link, term_event *ev);
void __cdecl do_reset_form(document_view *doc_view, form *form);
void __cdecl draw_form_entry(terminal *term, document_view *doc_view, link *link);
void __cdecl draw_forms(terminal *term, document_view *doc_view);
frame_event_status __cdecl reset_form(session *ses, document_view *doc_view, int a);
int __cdecl get_current_state(session *ses);
void __cdecl selected_item(terminal *term, void *item_, void *ses_);
// void __usercall add_form_attr_to_string(string *string@<eax>, terminal *term@<edx>, unsigned __int8 *name@<ecx>, unsigned __int8 *value); idb
void __cdecl link_form_menu(session *ses);
// void __usercall encode_multipart(session *ses@<eax>, list_head_elinks *l@<edx>, string *data@<ecx>, boundary_info *boundary, int cp_from, int cp_to); idb
uri *__cdecl get_form_uri(session *ses, document_view *doc_view, form_control *fc);
void __cdecl submit_given_form(session *ses, document_view *doc_view, form *form, int do_reload);
void __cdecl auto_submit_form(session *ses);
unsigned __int8 *__cdecl get_form_info(session *ses, document_view *doc_view);
void __cdecl get_link_x_bounds(link *link, int y, int *min_x, int *max_x);
link *__cdecl get_link_at_coordinates(document_view *doc_view, int x, int y);
void __cdecl set_pos_y(document_view *doc_view, link *link);
void __cdecl set_pos_x(document_view *doc_view, link *link);
int __cdecl next_link_in_dir(document_view *doc_view, int dir_x, int dir_y);
// int __usercall next_link_in_view_@<eax>(document_view *doc_view@<eax>, int current@<edx>, int direction@<ecx>, int (*fn)(document_view *, link *), void (*cntr)(document_view *, link *)); idb
int __cdecl next_link_in_view_y(document_view *doc_view, int current, int direction);
int __cdecl next_link_in_view(document_view *doc_view, int current, int direction);
// void __usercall find_link(document_view *doc_view@<eax>, int direction@<edx>, int page_mode@<ecx>); idb
void __cdecl find_link_page_down(document_view *doc_view);
void __cdecl find_link_down(document_view *doc_view);
void __cdecl find_link_page_up(document_view *doc_view);
void __cdecl find_link_up(document_view *doc_view);
int __cdecl link_in_view_y(document_view *doc_view, link *link);
int __cdecl link_in_view(document_view *doc_view, link *link);
int __cdecl current_link_is_visible(document_view *doc_view);
link *__cdecl get_last_link(document_view *doc_view);
link *__cdecl get_first_link(document_view *doc_view);
void __cdecl set_link(document_view *doc_view);
// unsigned __int8 *__usercall _8@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>); idb
unsigned __int8 *__cdecl get_current_link_info(session *ses, document_view *doc_view);
unsigned __int8 *__cdecl get_current_link_title(document_view *doc_view);
void __cdecl link_menu(terminal *term, void *xxx, void *ses_);
void __cdecl jump_to_link_number(session *ses, document_view *doc_view, int n);
uri *__cdecl get_link_uri(session *ses, document_view *doc_view, link *link);
link *__cdecl goto_current_link(session *ses, document_view *doc_view, int do_reload);
frame_event_status __cdecl enter(session *ses, document_view *doc_view, int do_reload);
// void __usercall goto_link_number_do(session *ses@<eax>, document_view *doc_view@<edx>, int n@<ecx>); idb
frame_event_status __cdecl try_document_key(session *ses, document_view *doc_view, term_event *ev);
void __cdecl goto_link_number(session *ses, unsigned __int8 *num);
void __cdecl highlight_links_with_prefixes_that_start_with_n(terminal *term, document_view *doc_view, int n);
void __cdecl clear_link(terminal *term, document_view *doc_view);
void __cdecl draw_current_link(session *ses, document_view *doc_view);
// void __usercall free_mark_by_index(int i@<eax>); idb
void __cdecl done_marks(module *xxx);
void __cdecl goto_mark(unsigned __int8 mark, view_state *vs);
void __cdecl set_mark(unsigned __int8 mark, view_state *mark_vs);
evhook_status __cdecl search_history_write_hook(va_list ap, void *data);
void __cdecl done_search_history(module *module);
void __cdecl init_search_history(module *module);
// int __usercall get_range@<eax>(document *document@<eax>, int y@<edx>, int height@<ecx>, int l, search **s1, search **s2); idb
widget_handler_status_T __cdecl search_dlg_cancel(dialog_data *dlg_data, widget_data *widget_data);
widget_handler_status_T __cdecl search_dlg_ok(dialog_data *dlg_data, widget_data *widget_data);
// int __usercall strlen_u@<eax>(unsigned __int8 *text@<eax>, int utf8@<edx>); idb
// unicode_val_T *__usercall memacpy_u@<eax>(unsigned __int8 *text@<eax>, int textlen@<edx>, int utf8@<ecx>); idb
// unicode_val_T *__usercall lowered_string@<eax>(unsigned __int8 *text@<eax>, int textlen@<edx>, int utf8@<ecx>); idb
// void __usercall print_find_error_not_found(session *ses@<eax>, unsigned __int8 *title@<edx>, unsigned __int8 *message@<ecx>, unsigned __int8 *search_string); idb
// void __usercall print_find_error(session *ses@<eax>, find_error find_error@<edx>); idb
frame_event_status __cdecl search_typeahead(session *ses, document_view *doc_view, action_id_T action_id);
// int __usercall match_link_text@<eax>(link *link@<eax>, unsigned __int8 *text@<edx>, int textlen@<ecx>, int case_sensitive); idb
// void __usercall draw_typeahead_match(terminal *term@<eax>, document_view *doc_view@<edx>, int chars@<ecx>, int offset); idb
input_line_code __cdecl link_typeahead_handler(input_line *line, int action_id);
// int __usercall get_srch@<eax>(document *document@<eax>); idb
// void __usercall get_search_data(document *document@<eax>); idb
// void __usercall get_searched(document_view *doc_view@<eax>, point **pt@<edx>, int *pl@<ecx>, int utf8); idb
// int __usercall find_next_link_in_search@<eax>(document_view *doc_view@<eax>, int direction@<edx>); idb
void __cdecl draw_searched(terminal *term, document_view *doc_view);
// char __usercall find_next_do@<al>(session *ses@<eax>, document_view *doc_view@<edx>, int direction@<ecx>);
// find_error __usercall search_for_do@<eax>(session *ses@<eax>, unsigned __int8 *str@<edx>, int direction@<ecx>, int report_errors);
void __cdecl search_for_back(session *ses, unsigned __int8 *str);
void __cdecl search_for(session *ses, unsigned __int8 *str);
frame_event_status __cdecl find_next(session *ses, document_view *doc_view, int direction);
input_line_code __cdecl text_typeahead_handler(input_line *line, int action_id);
frame_event_status __cdecl search_dlg(session *ses, document_view *doc_view, int direction);
// int __usercall get_textarea_line_number@<eax>(line_info *line@<eax>, int cursor_position@<edx>); idb
int __cdecl do_op_home(form_state *fs_0, line_info *line, int current, int utf8);
int __cdecl do_op_bob(form_state *fs_0, line_info *line, int current, int utf8);
int __cdecl do_op_eob(form_state *fs_0, line_info *line, int current, int utf8);
int __cdecl do_op_right(form_state *fs_0, line_info *line, int current, int utf8);
int __cdecl do_op_left(form_state *fs_0, line_info *line, int current, int utf8);
int __cdecl do_op_end(form_state *fs_0, line_info *line, int current, int utf8);
frame_event_status __cdecl textarea_op_enter(form_state *fs_0, form_control *fc, int utf8);
void __cdecl new_pos(form_state *fs_0, line_info *line, int current, int max_cells);
int __cdecl do_op_down(form_state *fs_0, line_info *line, int current, int utf8);
int __cdecl do_op_up(form_state *fs_0, line_info *line, int current, int utf8);
void __cdecl textarea_edit(int op, terminal *term_, form_state *fs_, document_view *doc_view_, link *link_);
void __cdecl menu_textarea_edit(terminal *term, void *xxx, void *ses_);
// line_info *__usercall format_textutf8@<eax>(const char *@<eax>, int@<edx>, int@<ecx>);
// line_info *__usercall format_text@<eax>(unsigned __int8 *text@<eax>, int width@<edx>, form_wrap wrap@<ecx>, int format); idb
// int __usercall textarea_op@<eax>(form_state *fs_0@<eax>, form_control *fc@<edx>, int utf8@<ecx>, int (*do_op)(form_state *, line_info *, int, int));
frame_event_status __cdecl textarea_op_right(form_state *fs_0, form_control *fc, int utf8);
frame_event_status __cdecl textarea_op_left(form_state *fs_0, form_control *fc, int utf8);
frame_event_status __cdecl textarea_op_eob(form_state *fs_0, form_control *fc, int utf8);
frame_event_status __cdecl textarea_op_bob(form_state *fs_0, form_control *fc, int utf8);
void __cdecl set_textarea(document_view *doc_view, int direction);
frame_event_status __cdecl textarea_op_end(form_state *fs_0, form_control *fc, int utf8);
frame_event_status __cdecl textarea_op_down(form_state *fs_0, form_control *fc, int utf8);
frame_event_status __cdecl textarea_op_up(form_state *fs_0, form_control *fc, int utf8);
frame_event_status __cdecl textarea_op_home(form_state *fs_0, form_control *fc, int utf8);
int __cdecl area_cursor(form_control *fc, form_state *fs_0, int utf8);
unsigned __int8 *__cdecl encode_textarea(submitted_value *sv);
void __cdecl draw_textarea(terminal *term, form_state *fs_0, document_view *doc_view, link *link);
frame_event_status __cdecl save_formatted_dlg(session *ses, document_view *doc_view, int xxxx);
document_view *__cdecl current_frame(session *ses);
void __cdecl save_formatted(void *data, unsigned __int8 *file);
void __cdecl save_formatted_finish(terminal *term, int h, void *data, int resume);
frame_event_status __cdecl save_as(session *ses, document_view *doc_view, int magic);
frame_event_status __cdecl view_image(session *ses, document_view *doc_view, int xxxx);
frame_event_status __cdecl download_link(session *ses, document_view *doc_view, action_id_T action_id);
// frame_event_status __usercall horizontal_scroll@<eax>(session *ses@<eax>, document_view *doc_view@<edx>, int steps@<ecx>); idb
// frame_event_status __usercall vertical_scroll@<eax>(session *ses@<eax>, document_view *doc_view@<edx>, int steps@<ecx>); idb
// frame_event_status __usercall scroll_mouse_up@<eax>(session *ses@<eax>, document_view *doc_view@<edx>); idb
// frame_event_status __usercall scroll_mouse_down@<eax>(session *ses@<eax>, document_view *doc_view@<edx>); idb
frame_event_status __cdecl try_mark_key(session *ses, document_view *doc_view, term_event *ev);
// term_event *__usercall send_to_frame@<eax>(session *ses@<eax>, document_view *doc_view@<edx>, term_event *ev@<ecx>);
frame_event_status __cdecl scroll_right(session *ses, document_view *doc_view);
frame_event_status __cdecl scroll_left(session *ses, document_view *doc_view);
frame_event_status __cdecl scroll_down(session *ses, document_view *doc_view);
frame_event_status __cdecl scroll_up(session *ses, document_view *doc_view);
int __cdecl try_jump_to_link_number(session *ses, document_view *doc_view);
frame_event_status __cdecl copy_current_link_to_clipboard(session *ses, document_view *doc_view, int xxx);
frame_event_status __cdecl move_cursor(session *ses, document_view *doc_view, int x, int y);
// frame_event_status __usercall move_cursor_rel@<eax>(session *ses@<eax>, document_view *view@<edx>, int rx@<ecx>, int ry); idb
frame_event_status __cdecl move_cursor_line_start(session *ses, document_view *doc_view);
frame_event_status __cdecl move_cursor_down(session *ses, document_view *view);
frame_event_status __cdecl move_cursor_up(session *ses, document_view *view);
frame_event_status __cdecl move_cursor_right(session *ses, document_view *view);
frame_event_status __cdecl move_cursor_left(session *ses, document_view *view);
frame_event_status __cdecl move_link_next_line(session *ses, document_view *doc_view);
frame_event_status __cdecl move_link_prev_line(session *ses, document_view *doc_view);
frame_event_status __cdecl move_link_down_line(session *ses, document_view *doc_view);
frame_event_status __cdecl move_link_up_line(session *ses, document_view *doc_view);
frame_event_status __cdecl move_document_end(session *ses, document_view *doc_view);
frame_event_status __cdecl move_document_start(session *ses, document_view *doc_view);
void __cdecl toggle_wrap_text(session *ses, document_view *doc_view, int xxxx);
void __cdecl toggle_plain_html(session *ses, document_view *doc_view, int xxxx);
frame_event_status __cdecl set_frame(session *ses, document_view *doc_view, int xxxx);
// void __usercall move_down(session *ses@<eax>, document_view *doc_view@<edx>, int type@<ecx>); idb
frame_event_status __cdecl move_page_down(session *ses, document_view *doc_view);
// void __usercall move_up(session *ses@<eax>, document_view *doc_view@<edx>, int type@<ecx>); idb
frame_event_status __cdecl move_link_dir(session *ses, document_view *doc_view, int dir_x, int dir_y);
frame_event_status __cdecl move_page_up(session *ses, document_view *doc_view);
frame_event_status __cdecl move_link(session *ses, document_view *doc_view, int direction, int wraparound_bound, int wraparound_link);
void __cdecl detach_formatted(document_view *doc_view);
void __cdecl send_event(session *ses, term_event *ev);
void __cdecl next_frame(session *ses, int p);
void __cdecl check_vs(document_view *doc_view);
void __cdecl copy_vs(view_state *dst, view_state *src);
void __cdecl destroy_vs(view_state *vs, int blast_ecmascript);
void __cdecl init_vs(view_state *vs, uri *uri, int plain);

//-------------------------------------------------------------------------
// Data declarations

const widget_ops *const widget_type_to_ops[6] =
{
  &checkbox_ops,
  &field_ops,
  &field_pass_ops,
  &button_ops,
  &listbox_ops_0,
  &text_ops
}; // idb
const listbox_ops_messages default_listbox_ops_messages =
{
  &aSorryButTheIte,
  &aSorryButTheIte_0,
  &aSorryButTheFol,
  &aSorryButTheFol_0,
  &aDeleteMarkedIt,
  &aDeleteMarkedIt_0,
  &aDeleteFolder,
  &aDeleteTheFolde,
  &aDeleteItem,
  &aDeleteSS,
  &aClearAllItems,
  &aDoYouReallyWan_3
}; // idb
const change_hook_info bookmarks_change_hooks_7301[2] = { { &aBookmarksFolde, &change_hook_folder_state }, { NULL, NULL } }; // idb
bookmarks_backend *const bookmarks_backends[2] = { &default_bookmarks_backend, &xbel_bookmarks_backend }; // idb
const string indent_7640 = { &byte_8134F91, 12 }; // idb
const parse_handler parse_handlers[5] =
{
  { (const unsigned __int8 *)0x812BD0E, &parse_set },
  { &aUnset, &parse_unset },
  { &aBind_2, &parse_bind },
  { &aInclude, &parse_include },
  { NULL, NULL }
}; // idb
const unsigned __int8 error_msg_8620[6][40] =
{
  {
    110u,
    111u,
    32u,
    101u,
    114u,
    114u,
    111u,
    114u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    117u,
    110u,
    107u,
    110u,
    111u,
    119u,
    110u,
    32u,
    99u,
    111u,
    109u,
    109u,
    97u,
    110u,
    100u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    112u,
    97u,
    114u,
    115u,
    101u,
    32u,
    101u,
    114u,
    114u,
    111u,
    114u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    117u,
    110u,
    107u,
    110u,
    111u,
    119u,
    110u,
    32u,
    111u,
    112u,
    116u,
    105u,
    111u,
    110u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    98u,
    97u,
    100u,
    32u,
    118u,
    97u,
    108u,
    117u,
    101u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  },
  {
    110u,
    111u,
    32u,
    109u,
    101u,
    109u,
    111u,
    114u,
    121u,
    32u,
    108u,
    101u,
    102u,
    116u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u,
    0u
  }
}; // idb
default_kb *const default_keybindings[3] = { &default_main_keymap, &default_edit_keymap, &default_menu_keymap }; // idb
action_alias *const action_aliases[3] = { &main_action_aliases, &edit_action_aliases, NULL }; // idb
const named_key key_table[28] =
{
  { &aEnter, -256 },
  { &aSpace, 32 },
  { &aBackspace, -257 },
  { &aTab, -258 },
  { &aEscape, -259 },
  { &aLeft_0, -260 },
  { &aRight_0, -261 },
  { (const unsigned __int8 *)0x8128533, -262 },
  { &aDown, -263 },
  { &aInsert, -264 },
  { (const unsigned __int8 *)0x8127A4B, -265 },
  { &aHome_0, -266 },
  { &aEnd, -267 },
  { &aPageup, -268 },
  { &unk_8128536, -269 },
  { &aF1, -288 },
  { &aF2, -289 },
  { &aF3, -290 },
  { &aF4, -291 },
  { &aF5, -292 },
  { &aF6, -293 },
  { &aF7, -294 },
  { &aF8, -295 },
  { &aF9, -296 },
  { &aF10, -297 },
  { &aF11, -298 },
  { &aF12, -299 },
  { NULL, -1 }
}; // idb
const change_hook_info change_hooks[14] =
{
  { &aConfigShowTemp, &change_hook_stemplate },
  { &aConnection_1, &change_hook_connection },
  { &aDocumentBrowse_45, &change_hook_html },
  { &aDocumentBrowse_0, &change_hook_insert_mode },
  { &aDocumentBrowse_46, &change_hook_active_link },
  { &aDocumentCache, &change_hook_cache },
  { &aDocumentCodepa_1, &change_hook_html },
  { &aDocumentColors_9, &change_hook_html },
  { &aDocumentHtml, &change_hook_html },
  { &aDocumentPlain, &change_hook_html },
  { &aTerminal, &change_hook_terminal },
  { &aUiLanguage, &change_hook_language },
  { &aUi, &change_hook_ui },
  { NULL, NULL }
}; // idb
const option_type_info option_types[10] =
{
  { &aBoolean, &bool_cmd, &num_rd, &num_wr, NULL, &num_set, &num_eq, &a01 },
  { &aInteger, &gen_cmd, &num_rd, &num_wr, NULL, &num_set, &num_eq, &aNum },
  { &aLongint, &gen_cmd, &num_rd, &long_wr, NULL, &long_set, &long_eq, &aNum },
  { &aString, &gen_cmd, &str_rd, &str_wr, &str_dup, &str_set, &str_eq, &aStr },
  {
    &byte_812A18A,
    &gen_cmd,
    &str_rd,
    &cp_wr,
    NULL,
    &cp_set,
    &cp_eq,
    &aCodepage
  },
  {
    &aLanguage_1,
    &gen_cmd,
    &str_rd,
    &lang_wr,
    NULL,
    &lang_set,
    &lang_eq,
    &aLanguage_2
  },
  {
    &aColor_0,
    &gen_cmd,
    &str_rd,
    &color_wr,
    NULL,
    &color_set,
    &color_eq,
    &aColorRrggbb
  },
  { &aSpecial, &exec_cmd, NULL, NULL, NULL, NULL, NULL, &delete },
  {
    &aAlias,
    &redir_cmd_0,
    &redir_rd,
    &redir_wr,
    NULL,
    &redir_set,
    &redir_eq,
    &delete
  },
  { &aFolder_0, NULL, NULL, NULL, &tree_dup, NULL, NULL, &delete }
}; // idb
const change_hook_info timer_change_hooks_4871[2] = { { &aInfofilesSaveI, &periodic_save_change_hook }, { NULL, NULL } }; // idb
int CSWTCH_174[4] = { 22, 40, 0, 0 }; // weak
const form_type_name form_type2name[10] =
{
  { FC_TEXT, &aText },
  { FC_PASSWORD, &aPassword },
  { FC_FILE, &aFile },
  { FC_TEXTAREA, &aTextarea_0 },
  { FC_CHECKBOX, &aCheckbox },
  { FC_RADIO, &aRadio },
  { FC_SELECT, &aSelect_1 },
  { FC_SUBMIT, &aSubmit },
  { FC_IMAGE, &aImage },
  { FC_HIDDEN, &aHidden }
}; // idb
const css_applier_T css_appliers[10] =
{
  NULL,
  &css_apply_background_color,
  &css_apply_background_color,
  &css_apply_color,
  &css_apply_display,
  &css_apply_font_attribute,
  &css_apply_font_attribute,
  &css_apply_text_align,
  &css_apply_font_attribute,
  &css_apply_font_attribute
}; // idb
const change_hook_info css_change_hooks_7084[2] = { { &aDocumentCss, &change_hook_css }, { NULL, NULL } }; // idb
const unsigned __int8 end = 0u; // idb
char hltable_7258[4] = { ' ', '\xC4', '\xCD', '\0' }; // weak
char border_chars_7192[] = { '\0' }; // weak
char vltable_7304[28] =
{
  ' ',
  '\xB3',
  '\xBA',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
const $B61BDA9A0133AB4182D9AB8097D55C3F roman_tbl[20] =
{
  { 1000, (unsigned __int8 *)0x81339A8 },
  { 999, (unsigned __int8 *)0x812F408 },
  { 990, &aXm },
  { 900, &aCm },
  { 500, (unsigned __int8 *)0x813389E },
  { 499, (unsigned __int8 *)0x81334C7 },
  { 490, &aXd },
  { 400, &aCd },
  { 100, (unsigned __int8 *)0x812CC3A },
  { 99, (unsigned __int8 *)0x812E6C9 },
  { 90, &aXc },
  { 50, (unsigned __int8 *)0x813391D },
  { 49, (unsigned __int8 *)0x812ED66 },
  { 40, &aXl },
  { 10, (unsigned __int8 *)0x813532D },
  { 9, (unsigned __int8 *)0x812C6F2 },
  { 5, (unsigned __int8 *)0x8130B4C },
  { 4, (unsigned __int8 *)0x812F25B },
  { 1, (unsigned __int8 *)0x8131077 },
  { 0, NULL }
}; // idb
unsigned __int8 *const quote_char[2] = { (unsigned __int8 *const)0x8128449, (unsigned __int8 *const)0x8130A20 }; // idb
const dom_config_info dom_config_info_0[7] =
{
  { { 14u, &aCdataSections }, DOM_CONFIG_CDATA_SECTIONS },
  { { 8u, (unsigned __int8 *)0x8128220 }, DOM_CONFIG_COMMENTS },
  { { 26u, &aElementContent }, DOM_CONFIG_ELEMENT_CONTENT_WHITESPACE },
  { { 8u, &aEntities }, DOM_CONFIG_ENTITIES },
  { { 20u, &aNormalizeChara }, DOM_CONFIG_NORMALIZE_CHARACTERS },
  { { 7u, &aUnknown_0 }, DOM_CONFIG_UNKNOWN },
  { { 20u, &aNormalizeWhite }, DOM_CONFIG_NORMALIZE_WHITESPACE }
}; // idb
const decoding_backend *const decoding_backends[5] =
{
  &dummy_decoding_backend,
  &gzip_decoding_backend,
  &bzip2_decoding_backend,
  &dummy_decoding_backend,
  &deflate_decoding_backend
}; // idb
unsigned __int8 *const aliases_utf8[3] = { &aUtf8_0, &aUtf8_1, NULL }; // idb
const codepage_desc codepages[36] =
{
  { &a7BitAscii, &aliases_7bit, &highhalf_NULL, &table_NULL },
  { &unk_812EB75, &aliases_8859_1, &highhalf_8859_1, &table_NULL },
  { &unk_812EB80, &aliases_8859_2, &highhalf_8859_2, &table_NULL },
  { &unk_812EB8B, &aliases_8859_3, &highhalf_8859_3, &table_NULL },
  { &unk_812EB96, &aliases_8859_4, &highhalf_8859_4, &table_NULL },
  { &unk_812EBA1, &aliases_8859_5, &highhalf_8859_5, &table_NULL },
  { &unk_812EBAC, &aliases_8859_6, &highhalf_8859_6, &table_NULL },
  { &unk_812EBB7, &aliases_8859_7, &highhalf_8859_7, &table_NULL },
  { &unk_812EBC2, &aliases_8859_8, &highhalf_8859_8, &table_NULL },
  { &unk_812EBCD, &aliases_8859_9, &highhalf_8859_9, &table_NULL },
  { &unk_812EBD8, &aliases_8859_10, &highhalf_8859_10, &table_NULL },
  { &unk_812EBE4, &aliases_8859_13, &highhalf_8859_13, &table_NULL },
  { &unk_812EBF0, &aliases_8859_14, &highhalf_8859_14, &table_NULL },
  { &unk_812EBFC, &aliases_8859_15, &highhalf_8859_15, &table_NULL },
  { &unk_812EC08, &aliases_8859_16, &highhalf_8859_16, &table_NULL },
  { &unk_812EC14, &aliases_cp1250, &highhalf_cp1250, &table_NULL },
  { &unk_812EC21, &aliases_cp1251, &highhalf_cp1251, &table_NULL },
  { &unk_812EC2E, &aliases_cp1252, &highhalf_cp1252, &table_NULL },
  { &unk_812EC3B, &aliases_cp1256, &highhalf_cp1256, &table_NULL },
  { &unk_812EC48, &aliases_cp1257, &highhalf_cp1257, &table_NULL },
  { &aCp437_0, &aliases_cp437, &highhalf_cp437, &table_NULL },
  { &aCp737_0, &aliases_cp737, &highhalf_cp737, &table_NULL },
  { &aCp850_0, &aliases_cp850, &highhalf_cp850, &table_NULL },
  { &aCp852_0, &aliases_cp852, &highhalf_cp852, &table_NULL },
  { &aCp866_0, &aliases_cp866, &highhalf_cp866, &table_NULL },
  { &aCp1125Ukrainia, &aliases_cp1125, &highhalf_cp1125, &table_NULL },
  { &aMacroman2000, &aliases_macroman, &highhalf_macroman, &table_NULL },
  { &aMacLatin2, &aliases_mac_lat2, &highhalf_mac_lat2, &table_NULL },
  { &aKamenickyBroth, &aliases_kamen, &highhalf_kamen, &table_NULL },
  { &aKoi8R_0, &aliases_koi8_r, &highhalf_koi8_r, &table_NULL },
  { &aKoi8U_0, &aliases_koi8_u, &highhalf_koi8_u, &table_NULL },
  { &aKoi8Ru_0, &aliases_koi8_ru, &highhalf_koi8_ru, &table_NULL },
  { &aTcvn5712, &aliases_tcvn5712, &highhalf_tcvn5712, &table_tcvn5712 },
  { &aViscii, &aliases_viscii, &highhalf_viscii, &table_viscii },
  { &unk_812ECCF, &aliases_utf8, &highhalf_NULL, &table_NULL },
  { NULL, NULL, NULL, NULL }
}; // idb
const entity entities[1002] =
{
  { "AElig", 198u },
  { "Aacgr", 902u },
  { "Aacute", 193u },
  { "Abreve", 258u },
  { "Acirc", 194u },
  { (char *)0x812F0C8, 1040u },
  { "Agr", 913u },
  { "Agrave", 192u },
  { "Alpha", 913u },
  { "Amacr", 256u },
  { "Aogon", 260u },
  { "Aring", 197u },
  { "Atilde", 195u },
  { "Auml", 196u },
  { "Barwed", 8966u },
  { "Bcy", 1041u },
  { "Beta", 914u },
  { "Bgr", 914u },
  { "CHcy", 1063u },
  { "Cacute", 262u },
  { "Cap", 8914u },
  { "Ccaron", 268u },
  { "Ccedil", 199u },
  { "Ccirc", 264u },
  { "Cdot", 266u },
  { "Chi", 935u },
  { "Cup", 8915u },
  { "DJcy", 1026u },
  { "DScy", 1029u },
  { "DZcy", 1039u },
  { "Dagger", 8225u },
  { "Dcaron", 270u },
  { (char *)0x812EE2F, 1044u },
  { "Delta", 916u },
  { "Dgr", 916u },
  { (char *)0x812F56F, 168u },
  { "DotDot", 8412u },
  { "Dstrok", 272u },
  { "EEacgr", 905u },
  { "EEgr", 919u },
  { "ENG", 330u },
  { "ETH", 208u },
  { (char *)0x812EDAC, 904u },
  { "Eacute", 201u },
  { "Ecaron", 282u },
  { "Ecirc", 202u },
  { (char *)0x812EE41, 1069u },
  { "Edot", 278u },
  { (char *)0x812EDB3, 917u },
  { "Egrave", 200u },
  { "Emacr", 274u },
  { "Eogon", 280u },
  { "Epsilon", 917u },
  { "Eta", 919u },
  { "Euml", 203u },
  { "Fcy", 1060u },
  { "GJcy", 1027u },
  { "Gamma", 915u },
  { "Gbreve", 286u },
  { "Gcedil", 290u },
  { "Gcirc", 284u },
  { "Gcy", 1043u },
  { "Gdot", 288u },
  { "Gg", 8921u },
  { "Ggr", 915u },
  { "Gt", 8811u },
  { "HARDcy", 1066u },
  { "Hcirc", 292u },
  { "Hstrok", 294u },
  { "IEcy", 1045u },
  { "IJlig", 306u },
  { "IOcy", 1025u },
  { "Iacgr", 906u },
  { "Iacute", 205u },
  { "Icirc", 206u },
  { (char *)0x812F0CD, 1048u },
  { "Idigr", 938u },
  { "Idot", 304u },
  { "Igr", 921u },
  { "Igrave", 204u },
  { "Imacr", 298u },
  { "Iogon", 302u },
  { "Iota", 921u },
  { "Itilde", 296u },
  { "Iukcy", 1030u },
  { "Iuml", 207u },
  { "Jcirc", 308u },
  { (char *)0x812ED7D, 1049u },
  { "Jsercy", 1032u },
  { "Jukcy", 1028u },
  { "KHcy", 1061u },
  { "KHgr", 935u },
  { "KJcy", 1036u },
  { "Kappa", 922u },
  { "Kcedil", 310u },
  { "Kcy", 1050u },
  { "Kgr", 922u },
  { "LJcy", 1033u },
  { "Lacute", 313u },
  { "Lambda", 923u },
  { "Larr", 8606u },
  { "Lcaron", 317u },
  { "Lcedil", 315u },
  { "Lcy", 1051u },
  { "Lgr", 923u },
  { "Ll", 8920u },
  { "Lmidot", 319u },
  { "Lstrok", 321u },
  { "Lt", 8810u },
  { "Mcy", 1052u },
  { "Mgr", 924u },
  { "Mu", 924u },
  { "NJcy", 1034u },
  { "Nacute", 323u },
  { "Ncaron", 327u },
  { "Ncedil", 325u },
  { "Ncy", 1053u },
  { "Ngr", 925u },
  { "Ntilde", 209u },
  { "Nu", 925u },
  { "OElig", 338u },
  { "OHacgr", 911u },
  { "OHgr", 937u },
  { "Oacgr", 908u },
  { "Oacute", 211u },
  { "Ocirc", 212u },
  { (char *)0x812EE4C, 1054u },
  { "Odblac", 336u },
  { "Ogr", 927u },
  { "Ograve", 210u },
  { "Omacr", 332u },
  { "Omega", 937u },
  { "Omicron", 927u },
  { "Oslash", 216u },
  { "Otilde", 213u },
  { "Ouml", 214u },
  { "PHgr", 934u },
  { "PSgr", 936u },
  { "Pcy", 1055u },
  { "Pgr", 928u },
  { (char *)0x812F1A7, 934u },
  { (char *)0x812F1AD, 928u },
  { "Prime", 8243u },
  { (char *)0x812F1B2, 936u },
  { "Racute", 340u },
  { "Rarr", 8608u },
  { "Rcaron", 344u },
  { "Rcedil", 342u },
  { "Rcy", 1056u },
  { "Rgr", 929u },
  { "Rho", 929u },
  { &unk_812EFDB, 1065u },
  { "SHcy", 1064u },
  { "SOFTcy", 1068u },
  { "Sacute", 346u },
  { "Scaron", 352u },
  { "Scedil", 350u },
  { "Scirc", 348u },
  { "Scomma", 536u },
  { (char *)0x812ED82, 1057u },
  { (char *)0x812EFA3, 931u },
  { "Sigma", 931u },
  { "Sub", 8912u },
  { "Sup", 8913u },
  { "THORN", 222u },
  { "THgr", 920u },
  { &unk_812F01E, 1035u },
  { "TScy", 1062u },
  { "Tau", 932u },
  { "Tcaron", 356u },
  { "Tcedil", 354u },
  { "Tcomma", 538u },
  { (char *)0x812EFE5, 1058u },
  { "Tgr", 932u },
  { "Theta", 920u },
  { "Tstrok", 358u },
  { "Uacgr", 910u },
  { "Uacute", 218u },
  { "Ubrcy", 1038u },
  { "Ubreve", 364u },
  { "Ucirc", 219u },
  { (char *)0x812F0D2, 1059u },
  { "Udblac", 368u },
  { "Udigr", 939u },
  { "Ugr", 933u },
  { "Ugrave", 217u },
  { "Umacr", 362u },
  { "Uogon", 370u },
  { "Upsi", 933u },
  { "Upsilon", 933u },
  { "Uring", 366u },
  { "Utilde", 360u },
  { "Uuml", 220u },
  { "Vcy", 1042u },
  { "Vdash", 8873u },
  { "Verbar", 8214u },
  { "Vvdash", 8874u },
  { "Wcirc", 372u },
  { "Xgr", 926u },
  { (char *)0x812F1CF, 926u },
  { "YAcy", 1071u },
  { "YIcy", 1031u },
  { "YUcy", 1070u },
  { "Yacute", 221u },
  { "Ycirc", 374u },
  { "Ycy", 1067u },
  { "Yuml", 376u },
  { "ZHcy", 1046u },
  { "Zacute", 377u },
  { "Zcaron", 381u },
  { (char *)0x812ED87, 1047u },
  { "Zdot", 379u },
  { "Zeta", 918u },
  { "Zgr", 918u },
  { "aacgr", 940u },
  { "aacute", 225u },
  { "abreve", 259u },
  { "acirc", 226u },
  { (char *)0x812ECFA, 180u },
  { (char *)0x812FF5D, 1072u },
  { "aelig", 230u },
  { (char *)0x812F77B, 945u },
  { "agrave", 224u },
  { "alefsym", 8501u },
  { "aleph", 8501u },
  { "alpha", 945u },
  { "amacr", 257u },
  { "amalg", 8720u },
  { "amp", 38u },
  { (char *)0x8127CE8, 8743u },
  { (char *)0x812C633, 8736u },
  { "ang90", 8735u },
  { "angmsd", 8737u },
  { "angsph", 8738u },
  { "angst", 8491u },
  { "aogon", 261u },
  { (char *)0x812ED58, 8776u },
  { (char *)0x8128510, 8778u },
  { "apos", 700u },
  { "aring", 229u },
  { (char *)0x812FAA9, 42u },
  { "asymp", 8776u },
  { "atilde", 227u },
  { "auml", 228u },
  { &unk_812F184, 916u },
  { &unk_812F18C, 915u },
  { &unk_812F194, 923u },
  { &unk_812F19D, 937u },
  { "b.Phi", 934u },
  { "b.Pi", 928u },
  { "b.Psi", 936u },
  { &unk_812F1B6, 931u },
  { &unk_812F1BE, 920u },
  { &unk_812F1C6, 933u },
  { "b.Xi", 926u },
  { &unk_812F1D2, 945u },
  { "b.beta", 946u },
  { "b.chi", 967u },
  { "b.delta", 948u },
  { "b.epsi", 949u },
  { "b.epsis", 949u },
  { "b.epsiv", 949u },
  { "b.eta", 951u },
  { "b.gamma", 947u },
  { "b.gammad", 988u },
  { "b.iota", 953u },
  { "b.kappa", 954u },
  { "b.kappav", 1008u },
  { "b.lambda", 955u },
  { "b.mu", 956u },
  { "b.nu", 957u },
  { "b.omega", 974u },
  { "b.phis", 966u },
  { "b.phiv", 981u },
  { "b.pi", 960u },
  { "b.piv", 982u },
  { "b.psi", 968u },
  { "b.rho", 961u },
  { "b.rhov", 1009u },
  { "b.sigma", 963u },
  { "b.sigmav", 962u },
  { "b.tau", 964u },
  { "b.thetas", 952u },
  { "b.thetav", 977u },
  { "b.upsi", 965u },
  { "b.xi", 958u },
  { "b.zeta", 950u },
  { "barwed", 8892u },
  { "bcong", 8780u },
  { "bcy", 1073u },
  { "bdquo", 8222u },
  { "becaus", 8757u },
  { "bepsi", 8717u },
  { "bernou", 8492u },
  { (char *)0x812F1DC, 946u },
  { "beth", 8502u },
  { "bgr", 946u },
  { (char *)0x812C33A, 9251u },
  { "blk12", 9618u },
  { "blk14", 9617u },
  { "blk34", 9619u },
  { (char *)0x812C2C2, 9608u },
  { "bottom", 8869u },
  { "bowtie", 8904u },
  { "boxDL", 9559u },
  { "boxDR", 9556u },
  { "boxDl", 9558u },
  { "boxDr", 9555u },
  { "boxH", 9552u },
  { "boxHD", 9574u },
  { "boxHU", 9577u },
  { "boxHd", 9572u },
  { "boxHu", 9575u },
  { "boxUL", 9565u },
  { "boxUR", 9562u },
  { "boxUl", 9564u },
  { "boxUr", 9561u },
  { "boxV", 9553u },
  { "boxVH", 9580u },
  { "boxVL", 9571u },
  { "boxVR", 9568u },
  { "boxVh", 9579u },
  { "boxVl", 9570u },
  { "boxVr", 9567u },
  { "boxdL", 9557u },
  { "boxdR", 9554u },
  { "boxdl", 9488u },
  { "boxdr", 9484u },
  { "boxh", 9472u },
  { "boxhD", 9573u },
  { "boxhU", 9576u },
  { "boxhd", 9516u },
  { "boxhu", 9524u },
  { "boxuL", 9563u },
  { "boxuR", 9560u },
  { "boxul", 9496u },
  { "boxur", 9492u },
  { "boxv", 9474u },
  { "boxvH", 9578u },
  { "boxvL", 9569u },
  { "boxvR", 9566u },
  { "boxvh", 9532u },
  { "boxvl", 9508u },
  { "boxvr", 9500u },
  { "bprime", 8245u },
  { (char *)0x812ED01, 728u },
  { "brkbar", 166u },
  { "brvbar", 166u },
  { "bsim", 8765u },
  { "bsime", 8909u },
  { "bsol", 92u },
  { "bull", 8226u },
  { "bump", 8782u },
  { "bumpe", 8783u },
  { "cacute", 263u },
  { (char *)0x81318E2, 8745u },
  { "caret", 8257u },
  { (char *)0x812ED5C, 711u },
  { "ccaron", 269u },
  { "ccedil", 231u },
  { "ccirc", 265u },
  { "cdot", 267u },
  { (char *)0x812ED63, 184u },
  { "cent", 162u },
  { "chcy", 1095u },
  { "check", 10003u },
  { (char *)0x812F1E3, 967u },
  { (char *)0x812F582, 9675u },
  { (char *)0x812ED08, 710u },
  { "cire", 8791u },
  { "clubs", 9827u },
  { "colon", 58u },
  { "colone", 8788u },
  { (char *)0x812F005, 44u },
  { "commat", 64u },
  { "comp", 8705u },
  { "compfn", 8728u },
  { (char *)0x812F2C0, 8773u },
  { "conint", 8750u },
  { "coprod", 8720u },
  { "copy", 169u },
  { "copysr", 8471u },
  { "crarr", 8629u },
  { "cross", 10007u },
  { "cuepr", 8926u },
  { "cuesc", 8927u },
  { "cularr", 8630u },
  { (char *)0x812FD1E, 8746u },
  { "cupre", 8828u },
  { "curarr", 8631u },
  { "curren", 164u },
  { "cuvee", 8910u },
  { "cuwed", 8911u },
  { "dArr", 8659u },
  { "dagger", 8224u },
  { "daleth", 8504u },
  { "darr", 8595u },
  { "darr2", 8650u },
  { (char *)0x812F96E, 8208u },
  { "dashv", 8867u },
  { (char *)0x812EF6B, 733u },
  { "dcaron", 271u },
  { (char *)0x812F725, 1076u },
  { "deg", 176u },
  { (char *)0x812F1E9, 948u },
  { "dgr", 948u },
  { "dharl", 8643u },
  { "dharr", 8642u },
  { "diam", 8900u },
  { "diams", 9830u },
  { "die", 168u },
  { "divide", 247u },
  { "divonx", 8903u },
  { "djcy", 1106u },
  { "dlarr", 8601u },
  { "dlcorn", 8990u },
  { "dlcrop", 8973u },
  { "dollar", 36u },
  { (char *)0x812ED70, 729u },
  { "drarr", 8600u },
  { "drcorn", 8991u },
  { "drcrop", 8972u },
  { "dscy", 1109u },
  { "dstrok", 273u },
  { "dtri", 9663u },
  { "dtrif", 9662u },
  { "dzcy", 1119u },
  { "eDot", 8785u },
  { "eacgr", 941u },
  { "eacute", 233u },
  { "ecaron", 283u },
  { "ecir", 8790u },
  { "ecirc", 234u },
  { &unk_812F58C, 8789u },
  { (char *)0x812F786, 1101u },
  { "edot", 279u },
  { &unk_812F598, 942u },
  { "eegr", 951u },
  { "efDot", 8786u },
  { (char *)0x812F5A0, 949u },
  { "egrave", 232u },
  { "egs", 8925u },
  { (char *)0x813367A, 8467u },
  { (char *)0x812F95B, 8924u },
  { "emacr", 275u },
  { "emdash", 8212u },
  { "empty", 8709u },
  { "emsp", 8195u },
  { "emsp13", 8196u },
  { "emsp14", 8197u },
  { "endash", 8211u },
  { "eng", 331u },
  { "ensp", 8194u },
  { "eogon", 281u },
  { (char *)0x812F1F1, 949u },
  { "epsilon", 949u },
  { (char *)0x812F1F8, 8714u },
  { "equals", 61u },
  { (char *)0x812C760, 8801u },
  { "erDot", 8787u },
  { "esdot", 8784u },
  { (char *)0x812F208, 951u },
  { (char *)0x812F2E4, 240u },
  { "euml", 235u },
  { "euro", 8364u },
  { "excl", 33u },
  { "exist", 8707u },
  { "fcy", 1092u },
  { "female", 9792u },
  { "ffilig", 64259u },
  { "fflig", 64256u },
  { "ffllig", 64260u },
  { (char *)0x812F61C, 64257u },
  { "flat", 9837u },
  { (char *)0x812F629, 64258u },
  { &unk_812F634, 402u },
  { "forall", 8704u },
  { "fork", 8916u },
  { "frac12", 189u },
  { "frac13", 8531u },
  { "frac14", 188u },
  { "frac15", 8533u },
  { "frac16", 8537u },
  { "frac18", 8539u },
  { "frac23", 8532u },
  { "frac25", 8534u },
  { "frac34", 190u },
  { "frac35", 8535u },
  { "frac38", 8540u },
  { "frac45", 8536u },
  { "frac56", 8538u },
  { "frac58", 8541u },
  { "frac78", 8542u },
  { "frasl", 8260u },
  { "frown", 8994u },
  { "gE", 8807u },
  { "gacute", 501u },
  { (char *)0x812F20E, 947u },
  { (char *)0x812F216, 988u },
  { "gbreve", 287u },
  { "gcedil", 291u },
  { "gcirc", 285u },
  { "gcy", 1075u },
  { "gdot", 289u },
  { (char *)0x812B262, 8805u },
  { "gel", 8923u },
  { (char *)0x81298FD, 8805u },
  { "ggr", 947u },
  { "gimel", 8503u },
  { "gjcy", 1107u },
  { "gl", 8823u },
  { "gnE", 8809u },
  { "gne", 8809u },
  { "gnsim", 8935u },
  { (char *)0x812ED12, 96u },
  { "gsdot", 8919u },
  { "gsim", 8819u },
  { (char *)0x812F9BD, 62u },
  { "gvnE", 8809u },
  { "hArr", 8660u },
  { "hairsp", 8202u },
  { "half", 189u },
  { "hamilt", 8459u },
  { "hardcy", 1098u },
  { (char *)0x812F501, 8596u },
  { "harrw", 8621u },
  { "hcirc", 293u },
  { "hearts", 9829u },
  { "hellip", 8230u },
  { "hibar", 175u },
  { "horbar", 8213u },
  { "hstrok", 295u },
  { &unk_812F757, 8259u },
  { "hyphen", 45u },
  { "iacgr", 943u },
  { "iacute", 237u },
  { "icirc", 238u },
  { (char *)0x8133043, 1080u },
  { "idiagr", 912u },
  { "idigr", 970u },
  { "iecy", 1077u },
  { &unk_812F78A, 161u },
  { "iff", 8660u },
  { (char *)0x812EE65, 953u },
  { "igrave", 236u },
  { "ijlig", 307u },
  { "imacr", 299u },
  { "image", 8465u },
  { "incare", 8453u },
  { "infin", 8734u },
  { "inodot", 305u },
  { (char *)0x8130BDF, 8747u },
  { "intcal", 8890u },
  { "iocy", 1105u },
  { "iogon", 303u },
  { (char *)0x812F21F, 953u },
  { "iquest", 191u },
  { "isin", 8712u },
  { "itilde", 297u },
  { "iukcy", 1110u },
  { "iuml", 239u },
  { "jcirc", 309u },
  { (char *)0x812F524, 1081u },
  { "jsercy", 1112u },
  { "jukcy", 1108u },
  { (char *)0x812F226, 954u },
  { (char *)0x812F22E, 1008u },
  { "kcedil", 311u },
  { (char *)0x812EE93, 1082u },
  { "kgr", 954u },
  { "kgreen", 312u },
  { "khcy", 1093u },
  { "khgr", 967u },
  { "kjcy", 1116u },
  { "lAarr", 8666u },
  { "lArr", 8656u },
  { "lE", 8806u },
  { "lacute", 314u },
  { "lagran", 8466u },
  { (char *)0x812F237, 955u },
  { "lang", 9001u },
  { "laquo", 171u },
  { (char *)0x812F529, 8592u },
  { "larr2", 8647u },
  { "larrhk", 8617u },
  { "larrlp", 8619u },
  { "larrtl", 8610u },
  { "lcaron", 318u },
  { "lcedil", 316u },
  { "lceil", 8968u },
  { "lcub", 123u },
  { "lcy", 1083u },
  { "ldot", 8918u },
  { "ldquo", 8220u },
  { "ldquor", 8222u },
  { (char *)0x81314CB, 8804u },
  { "leg", 8922u },
  { (char *)0x812910F, 8804u },
  { "lfloor", 8970u },
  { (char *)0x812FC92, 8822u },
  { "lgr", 955u },
  { &unk_812F888, 8637u },
  { "lharu", 8636u },
  { "lhblk", 9604u },
  { "ljcy", 1113u },
  { "lmidot", 320u },
  { "lnE", 8808u },
  { "lne", 8808u },
  { "lnsim", 8934u },
  { "lowast", 8727u },
  { "lowbar", 95u },
  { "loz", 9674u },
  { "loz", 10023u },
  { "lozf", 10022u },
  { "lpar", 40u },
  { "lrarr2", 8646u },
  { "lrhar2", 8651u },
  { "lrm", 8206u },
  { "lsaquo", 8249u },
  { "lsh", 8624u },
  { "lsim", 8818u },
  { "lsqb", 91u },
  { "lsquo", 8216u },
  { "lsquor", 8218u },
  { "lstrok", 322u },
  { (char *)0x812845D, 60u },
  { "lthree", 8907u },
  { "ltimes", 8905u },
  { "ltri", 9667u },
  { "ltrie", 8884u },
  { "ltrif", 9666u },
  { "lvnE", 8808u },
  { (char *)0x812ED1F, 175u },
  { (char *)0x812F616, 9794u },
  { "malt", 10016u },
  { (char *)0x81353D9, 8614u },
  { "marker", 9646u },
  { "mcy", 1084u },
  { (char *)0x812F5BC, 8212u },
  { "mgr", 956u },
  { "micro", 181u },
  { (char *)0x812FA00, 8739u },
  { "middot", 183u },
  { "minus", 8722u },
  { "minusb", 8863u },
  { "mldr", 8230u },
  { "mnplus", 8723u },
  { "models", 8871u },
  { (char *)0x812F240, 956u },
  { "mumap", 8888u },
  { "nVDash", 8879u },
  { &unk_812F96C, 8878u },
  { "nabla", 8711u },
  { "nacute", 324u },
  { "nap", 8777u },
  { &unk_812F984, 329u },
  { "natur", 9838u },
  { (char *)0x812BF73, 160u },
  { "ncaron", 328u },
  { "ncedil", 326u },
  { "ncong", 8775u },
  { (char *)0x812A45B, 1085u },
  { (char *)0x812F5D6, 8211u },
  { (char *)0x812FEFB, 8800u },
  { "nearr", 8599u },
  { "nequiv", 8802u },
  { &unk_812F9B1, 8708u },
  { (char *)0x8132CC8, 8817u },
  { (char *)0x8132CE4, 8817u },
  { "ngr", 957u },
  { "ngt", 8815u },
  { &unk_812F9C0, 8654u },
  { "nharr", 8622u },
  { "ni", 8715u },
  { "njcy", 1114u },
  { &unk_812F9D4, 8653u },
  { "nlarr", 8602u },
  { "nldr", 8229u },
  { "nle", 8816u },
  { "nles", 8816u },
  { "nlt", 8814u },
  { &unk_812F9F2, 8938u },
  { &unk_812F9F8, 8940u },
  { "nmid", 8740u },
  { "not", 172u },
  { "notin", 8713u },
  { "npar", 8742u },
  { "npr", 8832u },
  { "npre", 8928u },
  { "nrArr", 8655u },
  { "nrarr", 8603u },
  { "nrtri", 8939u },
  { "nrtrie", 8941u },
  { "nsc", 8833u },
  { "nsce", 8929u },
  { "nsim", 8769u },
  { "nsime", 8772u },
  { "nspar", 8742u },
  { "nsub", 8836u },
  { "nsubE", 8840u },
  { "nsube", 8840u },
  { "nsup", 8837u },
  { "nsupE", 8841u },
  { "nsupe", 8841u },
  { "ntilde", 241u },
  { (char *)0x812F245, 957u },
  { "num", 35u },
  { "numero", 8470u },
  { "numsp", 8199u },
  { "nvDash", 8877u },
  { "nvdash", 8876u },
  { "nwarr", 8598u },
  { "oS", 9416u },
  { "oacgr", 972u },
  { "oacute", 243u },
  { "oast", 8859u },
  { "ocir", 8858u },
  { "ocirc", 244u },
  { (char *)0x812F7C3, 1086u },
  { "odash", 8861u },
  { "odblac", 337u },
  { (char *)0x812F7B6, 8857u },
  { "oelig", 339u },
  { (char *)0x812ED25, 731u },
  { "ogr", 959u },
  { "ograve", 242u },
  { "ohacgr", 974u },
  { "ohgr", 969u },
  { "ohm", 8486u },
  { "olarr", 8634u },
  { "oline", 8254u },
  { "omacr", 333u },
  { (char *)0x812F24A, 969u },
  { "omicron", 959u },
  { &unk_812FB00, 8854u },
  { "oplus", 8853u },
  { (char *)0x812C72C, 8744u },
  { "orarr", 8635u },
  { "order", 8500u },
  { "ordf", 170u },
  { "ordm", 186u },
  { "oslash", 248u },
  { "osol", 8856u },
  { "otilde", 245u },
  { "otimes", 8855u },
  { "ouml", 246u },
  { (char *)0x812F8CC, 8741u },
  { "para", 182u },
  { "part", 8706u },
  { "pcy", 1087u },
  { "percnt", 37u },
  { "period", 46u },
  { "permil", 8240u },
  { "perp", 8869u },
  { "pgr", 960u },
  { "phgr", 966u },
  { "phi", 966u },
  { (char *)0x812F252, 966u },
  { (char *)0x812F259, 981u },
  { "phmmat", 8499u },
  { "phone", 9742u },
  { (char *)0x812F260, 960u },
  { (char *)0x812F265, 982u },
  { "planck", 8463u },
  { (char *)0x812F953, 43u },
  { "plusb", 8862u },
  { "plusdo", 8724u },
  { "plusmn", 177u },
  { "pound", 163u },
  { (char *)0x812F49B, 8826u },
  { (char *)0x812FA18, 8828u },
  { (char *)0x812F3F2, 8242u },
  { "prnsim", 8936u },
  { "prod", 8719u },
  { "prop", 8733u },
  { "prsim", 8830u },
  { "psgr", 968u },
  { (char *)0x812F26B, 968u },
  { "puncsp", 8200u },
  { "quest", 63u },
  { "quot", 34u },
  { "rAarr", 8667u },
  { (char *)0x812FA1D, 8658u },
  { "racute", 341u },
  { "radic", 8730u },
  { "rang", 9002u },
  { "raquo", 187u },
  { (char *)0x812F48D, 8594u },
  { (char *)0x812F8D1, 8649u },
  { "rarrhk", 8618u },
  { "rarrlp", 8620u },
  { "rarrtl", 8611u },
  { "rarrw", 8605u },
  { "rcaron", 345u },
  { "rcedil", 343u },
  { "rceil", 8969u },
  { "rcub", 125u },
  { (char *)0x812F05C, 1088u },
  { "rdquo", 8221u },
  { "rdquor", 8220u },
  { "real", 8476u },
  { (char *)0x8132A62, 9645u },
  { "reg", 174u },
  { "rfloor", 8971u },
  { "rgr", 961u },
  { "rhard", 8641u },
  { "rharu", 8640u },
  { (char *)0x812F271, 961u },
  { (char *)0x812F277, 1009u },
  { (char *)0x8128193, 730u },
  { &unk_812FC3C, 8644u },
  { "rlhar2", 8652u },
  { "rlm", 8207u },
  { "rpar", 41u },
  { "rsaquo", 8250u },
  { "rsh", 8625u },
  { "rsqb", 93u },
  { "rsquo", 8217u },
  { "rsquor", 8216u },
  { "rthree", 8908u },
  { "rtimes", 8906u },
  { (char *)0x812FA29, 9657u },
  { (char *)0x812FA2F, 8885u },
  { "rtrif", 9656u },
  { "rx", 8478u },
  { "sacute", 347u },
  { &unk_812FC8E, 8720u },
  { "sbquo", 8218u },
  { &unk_812FC9B, 92u },
  { (char *)0x812F4A1, 8827u },
  { "scaron", 353u },
  { "sccue", 8829u },
  { (char *)0x812FA3A, 8829u },
  { "scedil", 351u },
  { "scirc", 349u },
  { &unk_812FCBB, 8937u },
  { "scomma", 537u },
  { "scsim", 8831u },
  { (char *)0x812F558, 1089u },
  { (char *)0x812F601, 8901u },
  { "sdotb", 8865u },
  { "sect", 167u },
  { "semi", 59u },
  { "setmn", 8726u },
  { "sext", 10038u },
  { "sfgr", 962u },
  { &unk_812FCE9, 8994u },
  { (char *)0x812FBAD, 963u },
  { "sharp", 9839u },
  { &unk_812FCF6, 1097u },
  { "shcy", 1096u },
  { "shy", 173u },
  { (char *)0x812F27E, 963u },
  { "sigmaf", 962u },
  { (char *)0x812F286, 962u },
  { (char *)0x812F407, 8764u },
  { (char *)0x812F40C, 8771u },
  { "smile", 8995u },
  { "softcy", 1100u },
  { (char *)0x812FC9D, 47u },
  { "spades", 9824u },
  { (char *)0x812FA45, 8741u },
  { "sqcap", 8851u },
  { "sqcup", 8852u },
  { "sqsub", 8847u },
  { "sqsube", 8849u },
  { "sqsup", 8848u },
  { "sqsupe", 8850u },
  { "squ", 9633u },
  { "square", 9633u },
  { "squf", 9642u },
  { &unk_812FD45, 8726u },
  { &unk_812FD4C, 8995u },
  { "sstarf", 8902u },
  { "star", 9734u },
  { (char *)0x812FD54, 9733u },
  { (char *)0x812FA4B, 8834u },
  { (char *)0x812FA50, 8838u },
  { (char *)0x812FA56, 8838u },
  { "subnE", 8842u },
  { "subne", 8842u },
  { (char *)0x8130BA2, 8721u },
  { "sung", 9834u },
  { (char *)0x812FA5C, 8835u },
  { "sup1", 185u },
  { "sup2", 178u },
  { "sup3", 179u },
  { (char *)0x812FA61, 8839u },
  { (char *)0x812FA67, 8839u },
  { "supnE", 8843u },
  { "supne", 8843u },
  { "szlig", 223u },
  { "target", 8982u },
  { (char *)0x812F28F, 964u },
  { "tcaron", 357u },
  { "tcedil", 355u },
  { "tcomma", 539u },
  { (char *)0x812FD0B, 1090u },
  { "tdot", 8411u },
  { "telrec", 8981u },
  { "tgr", 964u },
  { "there4", 8756u },
  { "theta", 952u },
  { (char *)0x812F295, 952u },
  { "thetasym", 977u },
  { (char *)0x812F29E, 977u },
  { "thgr", 952u },
  { "thinsp", 8201u },
  { "thkap", 8776u },
  { "thksim", 8764u },
  { "thorn", 254u },
  { (char *)0x812ED31, 732u },
  { (char *)0x812F913, 215u },
  { "timesb", 8864u },
  { (char *)0x812AF9F, 8868u },
  { "tprime", 8244u },
  { "trade", 8482u },
  { (char *)0x812F9FA, 8796u },
  { "tscy", 1094u },
  { &unk_812FDEC, 1115u },
  { "tstrok", 359u },
  { "twixt", 8812u },
  { "uArr", 8657u },
  { "uacgr", 973u },
  { "uacute", 250u },
  { "uarr", 8593u },
  { "uarr2", 8648u },
  { "ubrcy", 1118u },
  { "ubreve", 365u },
  { "ucirc", 251u },
  { (char *)0x812FF75, 1091u },
  { "udblac", 369u },
  { "udiagr", 944u },
  { "udigr", 971u },
  { "ugr", 965u },
  { "ugrave", 249u },
  { "uharl", 8639u },
  { "uharr", 8638u },
  { "uhblk", 9600u },
  { "ulcorn", 8988u },
  { "ulcrop", 8975u },
  { "umacr", 363u },
  { (char *)0x812ED38, 168u },
  { "uogon", 371u },
  { "uplus", 8846u },
  { (char *)0x812F2A7, 965u },
  { "upsih", 978u },
  { "upsilon", 965u },
  { "urcorn", 8989u },
  { "urcrop", 8974u },
  { "uring", 367u },
  { "utilde", 361u },
  { "utri", 9653u },
  { "utrif", 9652u },
  { "uuml", 252u },
  { "vArr", 8661u },
  { (char *)0x812FA85, 8872u },
  { "varr", 8597u },
  { "vcy", 1074u },
  { (char *)0x812F0B7, 8866u },
  { "veebar", 8891u },
  { "vellip", 8942u },
  { "verbar", 124u },
  { "vltri", 8882u },
  { "vprime", 8242u },
  { &unk_812FEE4, 8733u },
  { "vrtri", 8883u },
  { &unk_812FEF0, 8842u },
  { &unk_812FEF7, 8842u },
  { &unk_812FEFE, 8843u },
  { &unk_812FF05, 8843u },
  { "wcirc", 373u },
  { "wedgeq", 8793u },
  { "weierp", 8472u },
  { "wreath", 8768u },
  { "xcirc", 9675u },
  { &unk_812FF2D, 9661u },
  { "xgr", 958u },
  { "xhArr", 8596u },
  { "xharr", 8596u },
  { (char *)0x812F2AE, 958u },
  { "xlArr", 8656u },
  { "xrArr", 8658u },
  { &unk_812FF4F, 9651u },
  { "yacute", 253u },
  { "yacy", 1103u },
  { "ycirc", 375u },
  { "ycy", 1099u },
  { "yen", 165u },
  { "yicy", 1111u },
  { "yucy", 1102u },
  { "yuml", 255u },
  { "zacute", 378u },
  { "zcaron", 382u },
  { (char *)0x812F56A, 1079u },
  { "zdot", 380u },
  { (char *)0x812F2B3, 950u },
  { "zgr", 950u },
  { "zhcy", 1078u },
  { "zwj", 8205u },
  { "zwnj", 8204u },
  { NULL, 0u }
}; // idb
const char strings[512] =
{
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x02',
  '\0',
  '\x03',
  '\0',
  '\x04',
  '\0',
  '\x05',
  '\0',
  '\x06',
  '\0',
  '\a',
  '\0',
  '\b',
  '\0',
  '\t',
  '\0',
  '\n',
  '\0',
  '\v',
  '\0',
  '\f',
  '\0',
  '\r',
  '\0',
  '\x0E',
  '\0',
  '\x0F',
  '\0',
  '\x10',
  '\0',
  '\x11',
  '\0',
  '\x12',
  '\0',
  '\x13',
  '\0',
  '\x14',
  '\0',
  '\x15',
  '\0',
  '\x16',
  '\0',
  '\x1B',
  '\0',
  '\x18',
  '\0',
  '\x19',
  '\0',
  '\x1A',
  '\0',
  '\x1B',
  '\0',
  '\x1C',
  '\0',
  '\x1D',
  '\0',
  '\x1E',
  '\0',
  '\x1B',
  '\0',
  ' ',
  '\0',
  '!',
  '\0',
  '\"',
  '\0',
  '#',
  '\0',
  '$',
  '\0',
  '%',
  '\0',
  '&',
  '\0',
  '\'',
  '\0',
  '(',
  '\0',
  ')',
  '\0',
  '*',
  '\0',
  '+',
  '\0',
  ',',
  '\0',
  '-',
  '\0',
  '.',
  '\0',
  '/',
  '\0',
  '0',
  '\0',
  '1',
  '\0',
  '2',
  '\0',
  '3',
  '\0',
  '4',
  '\0',
  '5',
  '\0',
  '6',
  '\0',
  '7',
  '\0',
  '8',
  '\0',
  '9',
  '\0',
  ':',
  '\0',
  ';',
  '\0',
  '<',
  '\0',
  '=',
  '\0',
  '>',
  '\0',
  '?',
  '\0',
  '@',
  '\0',
  'A',
  '\0',
  'B',
  '\0',
  'C',
  '\0',
  'D',
  '\0',
  'E',
  '\0',
  'F',
  '\0',
  'G',
  '\0',
  'H',
  '\0',
  'I',
  '\0',
  'J',
  '\0',
  'K',
  '\0',
  'L',
  '\0',
  'M',
  '\0',
  'N',
  '\0',
  'O',
  '\0',
  'P',
  '\0',
  'Q',
  '\0',
  'R',
  '\0',
  'S',
  '\0',
  'T',
  '\0',
  'U',
  '\0',
  'V',
  '\0',
  'W',
  '\0',
  'X',
  '\0',
  'Y',
  '\0',
  'Z',
  '\0',
  '[',
  '\0',
  '\\',
  '\0',
  ']',
  '\0',
  '^',
  '\0',
  '_',
  '\0',
  '`',
  '\0',
  'a',
  '\0',
  'b',
  '\0',
  'c',
  '\0',
  'd',
  '\0',
  'e',
  '\0',
  'f',
  '\0',
  'g',
  '\0',
  'h',
  '\0',
  'i',
  '\0',
  'j',
  '\0',
  'k',
  '\0',
  'l',
  '\0',
  'm',
  '\0',
  'n',
  '\0',
  'o',
  '\0',
  'p',
  '\0',
  'q',
  '\0',
  'r',
  '\0',
  's',
  '\0',
  't',
  '\0',
  'u',
  '\0',
  'v',
  '\0',
  'w',
  '\0',
  'x',
  '\0',
  'y',
  '\0',
  'z',
  '\0',
  '{',
  '\0',
  '|',
  '\0',
  '}',
  '\0',
  '~',
  '\0',
  '\x7F',
  '\0',
  '\x80',
  '\0',
  '\x81',
  '\0',
  '\x82',
  '\0',
  '\x83',
  '\0',
  '\x84',
  '\0',
  '\x85',
  '\0',
  '\x86',
  '\0',
  '\x87',
  '\0',
  '\x88',
  '\0',
  '\x89',
  '\0',
  '\x8A',
  '\0',
  '\x8B',
  '\0',
  '\x8C',
  '\0',
  '\x8D',
  '\0',
  '\x8E',
  '\0',
  '\x8F',
  '\0',
  '\x90',
  '\0',
  '\x91',
  '\0',
  '\x92',
  '\0',
  '\x93',
  '\0',
  '\x94',
  '\0',
  '\x95',
  '\0',
  '\x96',
  '\0',
  '\x97',
  '\0',
  '\x98',
  '\0',
  '\x99',
  '\0',
  '\x9A',
  '\0',
  '\x9B',
  '\0',
  '\x9C',
  '\0',
  '\x9D',
  '\0',
  '\x9E',
  '\0',
  '\x9F',
  '\0',
  '\xA0',
  '\0',
  '\xA1',
  '\0',
  '\xA2',
  '\0',
  '\xA3',
  '\0',
  '\xA4',
  '\0',
  '\xA5',
  '\0',
  '\xA6',
  '\0',
  '\xA7',
  '\0',
  '\xA8',
  '\0',
  '\xA9',
  '\0',
  '\xAA',
  '\0',
  '\xAB',
  '\0',
  '\xAC',
  '\0',
  '\xAD',
  '\0',
  '\xAE',
  '\0',
  '\xAF',
  '\0',
  '\xB0',
  '\0',
  '\xB1',
  '\0',
  '\xB2',
  '\0',
  '\xB3',
  '\0',
  '\xB4',
  '\0',
  '\xB5',
  '\0',
  '\xB6',
  '\0',
  '\xB7',
  '\0',
  '\xB8',
  '\0',
  '\xB9',
  '\0',
  '\xBA',
  '\0',
  '\xBB',
  '\0',
  '\xBC',
  '\0',
  '\xBD',
  '\0',
  '\xBE',
  '\0',
  '\xBF',
  '\0',
  '\xC0',
  '\0',
  '\xC1',
  '\0',
  '\xC2',
  '\0',
  '\xC3',
  '\0',
  '\xC4',
  '\0',
  '\xC5',
  '\0',
  '\xC6',
  '\0',
  '\xC7',
  '\0',
  '\xC8',
  '\0',
  '\xC9',
  '\0',
  '\xCA',
  '\0',
  '\xCB',
  '\0',
  '\xCC',
  '\0',
  '\xCD',
  '\0',
  '\xCE',
  '\0',
  '\xCF',
  '\0',
  '\xD0',
  '\0',
  '\xD1',
  '\0',
  '\xD2',
  '\0',
  '\xD3',
  '\0',
  '\xD4',
  '\0',
  '\xD5',
  '\0',
  '\xD6',
  '\0',
  '\xD7',
  '\0',
  '\xD8',
  '\0',
  '\xD9',
  '\0',
  '\xDA',
  '\0',
  '\xDB',
  '\0',
  '\xDC',
  '\0',
  '\xDD',
  '\0',
  '\xDE',
  '\0',
  '\xDF',
  '\0',
  '\xE0',
  '\0',
  '\xE1',
  '\0',
  '\xE2',
  '\0',
  '\xE3',
  '\0',
  '\xE4',
  '\0',
  '\xE5',
  '\0',
  '\xE6',
  '\0',
  '\xE7',
  '\0',
  '\xE8',
  '\0',
  '\xE9',
  '\0',
  '\xEA',
  '\0',
  '\xEB',
  '\0',
  '\xEC',
  '\0',
  '\xED',
  '\0',
  '\xEE',
  '\0',
  '\xEF',
  '\0',
  '\xF0',
  '\0',
  '\xF1',
  '\0',
  '\xF2',
  '\0',
  '\xF3',
  '\0',
  '\xF4',
  '\0',
  '\xF5',
  '\0',
  '\xF6',
  '\0',
  '\xF7',
  '\0',
  '\xF8',
  '\0',
  '\xF9',
  '\0',
  '\xFA',
  '\0',
  '\xFB',
  '\0',
  '\xFC',
  '\0',
  '\xFD',
  '\0',
  '\xFE',
  '\0',
  '\xFF',
  '\0'
}; // idb
const $062DE5076BD46B3EBBEAB0AA0483CD44 unicode_7b[2453] =
{
  { 0u, &aNul },
  { 1u, &aSh },
  { 2u, &aSx },
  { 3u, (unsigned __int8 *)0x812E024 },
  { 4u, (unsigned __int8 *)0x812DC8B },
  { 5u, &aEnq },
  { 6u, (unsigned __int8 *)0x812FFD1 },
  { 7u, (unsigned __int8 *)0x812D419 },
  { 8u, &aBs },
  { 9u, (unsigned __int8 *)0x812DF60 },
  { 10u, &aLf },
  { 11u, &aVt },
  { 12u, (unsigned __int8 *)0x812CCF7 },
  { 13u, &aCr },
  { 14u, (unsigned __int8 *)0x812D544 },
  { 15u, &aSi },
  { 16u, (unsigned __int8 *)0x812F308 },
  { 17u, &aDc1 },
  { 18u, &aDc2 },
  { 19u, &aDc3 },
  { 20u, &aDc4 },
  { 21u, &aNak },
  { 22u, &aSyn },
  { 23u, &aEb },
  { 24u, &aCn },
  { 25u, (unsigned __int8 *)0x812DD1A },
  { 26u, &aSb },
  { 27u, (unsigned __int8 *)0x812DF52 },
  { 28u, (unsigned __int8 *)0x812CCC4 },
  { 29u, (unsigned __int8 *)0x812DE12 },
  { 30u, (unsigned __int8 *)0x812CDD6 },
  { 31u, (unsigned __int8 *)0x812E476 },
  { 127u, &aDt_0 },
  { 133u, &a012 },
  { 160u, &a001 },
  { 161u, (unsigned __int8 *)0x8130B54 },
  { 162u, &aC },
  { 163u, &asc_812FFEA },
  { 164u, &aCur },
  { 165u, &aYen_0 },
  { 166u, (unsigned __int8 *)0x813282F },
  { 167u, (unsigned __int8 *)0x8130F43 },
  { 168u, (unsigned __int8 *)0x8128449 },
  { 169u, &aC_0 },
  { 170u, &aA_0 },
  { 171u, (unsigned __int8 *)0x8130D06 },
  { 172u, &aNot_0 },
  { 173u, &delete },
  { 173u, &delete },
  { 174u, &aR },
  { 175u, (unsigned __int8 *)0x8127DCF },
  { 176u, &aDeg_0 },
  { 177u, (unsigned __int8 *)0x813113C },
  { 178u, &a2 },
  { 179u, &a3 },
  { 180u, (unsigned __int8 *)0x8130A20 },
  { 181u, (unsigned __int8 *)0x813228F },
  { 182u, (unsigned __int8 *)0x812D943 },
  { 183u, (unsigned __int8 *)0x813015E },
  { 184u, (unsigned __int8 *)0x813114D },
  { 185u, &a1_0 },
  { 186u, (unsigned __int8 *)0x8130D4F },
  { 187u, (unsigned __int8 *)0x8130D0A },
  { 188u, &a14 },
  { 189u, &a12 },
  { 190u, &a34 },
  { 191u, (unsigned __int8 *)0x8130A2D },
  { 192u, (unsigned __int8 *)0x8132859 },
  { 193u, (unsigned __int8 *)0x8132859 },
  { 194u, (unsigned __int8 *)0x8132859 },
  { 195u, (unsigned __int8 *)0x8132859 },
  { 196u, &aAe },
  { 197u, &aAa },
  { 198u, &aAe_0 },
  { 199u, &aC_1 },
  { 200u, (unsigned __int8 *)0x8130028 },
  { 201u, (unsigned __int8 *)0x8130028 },
  { 202u, (unsigned __int8 *)0x8130028 },
  { 203u, (unsigned __int8 *)0x8130028 },
  { 204u, (unsigned __int8 *)0x8132865 },
  { 205u, (unsigned __int8 *)0x8132865 },
  { 206u, (unsigned __int8 *)0x8132865 },
  { 207u, (unsigned __int8 *)0x8132865 },
  { 208u, (unsigned __int8 *)0x8130B63 },
  { 209u, (unsigned __int8 *)0x812D7DC },
  { 210u, (unsigned __int8 *)0x812A3FF },
  { 211u, (unsigned __int8 *)0x812A3FF },
  { 212u, (unsigned __int8 *)0x812A3FF },
  { 213u, (unsigned __int8 *)0x812A3FF },
  { 214u, &aOe },
  { 215u, &asc_8130030 },
  { 216u, &aO },
  { 217u, (unsigned __int8 *)0x8130BD9 },
  { 218u, (unsigned __int8 *)0x8130BD9 },
  { 219u, (unsigned __int8 *)0x8130BD9 },
  { 220u, &aUe },
  { 221u, (unsigned __int8 *)0x81327BA },
  { 222u, (unsigned __int8 *)0x812CF4A },
  { 223u, (unsigned __int8 *)0x812C769 },
  { 224u, (unsigned __int8 *)0x81309B0 },
  { 225u, (unsigned __int8 *)0x812FFFB },
  { 226u, (unsigned __int8 *)0x812FFFB },
  { 227u, (unsigned __int8 *)0x812FFFB },
  { 228u, &aAe_1 },
  { 229u, &aAa_0 },
  { 230u, &aAe_1 },
  { 231u, &aC_2 },
  { 232u, (unsigned __int8 *)0x8131E32 },
  { 233u, (unsigned __int8 *)0x8131E32 },
  { 234u, (unsigned __int8 *)0x8131E32 },
  { 235u, (unsigned __int8 *)0x8131E32 },
  { 236u, &aI },
  { 237u, (unsigned __int8 *)0x8131077 },
  { 238u, (unsigned __int8 *)0x8131077 },
  { 239u, (unsigned __int8 *)0x8131077 },
  { 240u, (unsigned __int8 *)0x81311FC },
  { 241u, (unsigned __int8 *)0x8130076 },
  { 242u, (unsigned __int8 *)0x8130A05 },
  { 243u, (unsigned __int8 *)0x8130A05 },
  { 244u, (unsigned __int8 *)0x8130A05 },
  { 245u, (unsigned __int8 *)0x8130A05 },
  { 246u, &aOe_0 },
  { 247u, (unsigned __int8 *)0x8127DCF },
  { 248u, (unsigned __int8 *)0x813148F },
  { 249u, (unsigned __int8 *)0x813228F },
  { 250u, (unsigned __int8 *)0x813228F },
  { 251u, (unsigned __int8 *)0x813228F },
  { 252u, (unsigned __int8 *)0x812FCAB },
  { 253u, (unsigned __int8 *)0x8135330 },
  { 254u, &unk_812B2C7 },
  { 255u, (unsigned __int8 *)0x8135330 },
  { 256u, (unsigned __int8 *)0x8132859 },
  { 257u, (unsigned __int8 *)0x812FFFB },
  { 258u, (unsigned __int8 *)0x8132859 },
  { 259u, (unsigned __int8 *)0x812FFFB },
  { 260u, (unsigned __int8 *)0x8132859 },
  { 261u, (unsigned __int8 *)0x812FFFB },
  { 262u, &byte_8130C3E },
  { 263u, (unsigned __int8 *)0x812CC3A },
  { 264u, (unsigned __int8 *)0x812CCBB },
  { 265u, (unsigned __int8 *)0x81313AA },
  { 266u, &byte_8130C3E },
  { 267u, (unsigned __int8 *)0x812CC3A },
  { 268u, &byte_8130C3E },
  { 269u, (unsigned __int8 *)0x812CC3A },
  { 270u, (unsigned __int8 *)0x812C759 },
  { 271u, (unsigned __int8 *)0x813389E },
  { 272u, &aD_0 },
  { 273u, &aD_1 },
  { 274u, (unsigned __int8 *)0x8130028 },
  { 275u, (unsigned __int8 *)0x8131E32 },
  { 276u, (unsigned __int8 *)0x8130028 },
  { 277u, (unsigned __int8 *)0x8131E32 },
  { 278u, (unsigned __int8 *)0x8130028 },
  { 279u, (unsigned __int8 *)0x8131E32 },
  { 280u, (unsigned __int8 *)0x8130028 },
  { 281u, (unsigned __int8 *)0x8131E32 },
  { 282u, (unsigned __int8 *)0x8130028 },
  { 283u, (unsigned __int8 *)0x8131E32 },
  { 284u, &aGh },
  { 285u, &aGh_0 },
  { 286u, (unsigned __int8 *)0x812CF8F },
  { 287u, (unsigned __int8 *)0x812EE23 },
  { 288u, (unsigned __int8 *)0x812CF8F },
  { 289u, (unsigned __int8 *)0x812EE23 },
  { 290u, (unsigned __int8 *)0x812CF8F },
  { 291u, (unsigned __int8 *)0x812EE23 },
  { 292u, &aHh },
  { 293u, &aHh_0 },
  { 294u, &asc_813005A },
  { 295u, (unsigned __int8 *)0x8133955 },
  { 296u, (unsigned __int8 *)0x8132865 },
  { 297u, (unsigned __int8 *)0x8131077 },
  { 298u, (unsigned __int8 *)0x8132865 },
  { 299u, (unsigned __int8 *)0x8131077 },
  { 300u, (unsigned __int8 *)0x8132865 },
  { 301u, (unsigned __int8 *)0x8131077 },
  { 302u, (unsigned __int8 *)0x8132865 },
  { 303u, (unsigned __int8 *)0x8131077 },
  { 304u, (unsigned __int8 *)0x8132865 },
  { 305u, (unsigned __int8 *)0x8131077 },
  { 306u, &aIj },
  { 307u, &aIj_0 },
  { 308u, &aJh },
  { 309u, &aJh_0 },
  { 310u, (unsigned __int8 *)0x812FFD2 },
  { 311u, (unsigned __int8 *)0x8133548 },
  { 312u, &aKk },
  { 313u, (unsigned __int8 *)0x8130BCE },
  { 314u, (unsigned __int8 *)0x813391D },
  { 315u, (unsigned __int8 *)0x8130BCE },
  { 316u, (unsigned __int8 *)0x813391D },
  { 317u, (unsigned __int8 *)0x8130BCE },
  { 318u, (unsigned __int8 *)0x813391D },
  { 319u, (unsigned __int8 *)0x812E130 },
  { 320u, &asc_813006C },
  { 321u, &asc_813006F },
  { 322u, &asc_8130072 },
  { 323u, (unsigned __int8 *)0x812D7DC },
  { 324u, (unsigned __int8 *)0x8130076 },
  { 325u, (unsigned __int8 *)0x812D7DC },
  { 326u, (unsigned __int8 *)0x8130076 },
  { 327u, (unsigned __int8 *)0x812D7DC },
  { 328u, (unsigned __int8 *)0x8130076 },
  { 329u, &aN },
  { 330u, (unsigned __int8 *)0x812DF38 },
  { 331u, (unsigned __int8 *)0x812D7DC },
  { 332u, (unsigned __int8 *)0x812A3FF },
  { 333u, (unsigned __int8 *)0x8130A05 },
  { 334u, (unsigned __int8 *)0x812A3FF },
  { 335u, (unsigned __int8 *)0x8130A05 },
  { 336u, &aO_0 },
  { 337u, &aO_1 },
  { 338u, &aOe_1 },
  { 339u, &aOe_0 },
  { 340u, (unsigned __int8 *)0x812ECBE },
  { 341u, (unsigned __int8 *)0x812EAD0 },
  { 342u, (unsigned __int8 *)0x812ECBE },
  { 343u, (unsigned __int8 *)0x812EAD0 },
  { 344u, (unsigned __int8 *)0x812ECBE },
  { 345u, (unsigned __int8 *)0x812EAD0 },
  { 346u, (unsigned __int8 *)0x8130F43 },
  { 347u, (unsigned __int8 *)0x8133696 },
  { 348u, &aSh },
  { 349u, (unsigned __int8 *)0x8131EB1 },
  { 350u, (unsigned __int8 *)0x8130F43 },
  { 351u, (unsigned __int8 *)0x8133696 },
  { 352u, (unsigned __int8 *)0x8130F43 },
  { 353u, (unsigned __int8 *)0x8133696 },
  { 354u, (unsigned __int8 *)0x8130C7C },
  { 355u, (unsigned __int8 *)0x812EE2A },
  { 356u, (unsigned __int8 *)0x8130C7C },
  { 357u, (unsigned __int8 *)0x812EE2A },
  { 358u, &aT },
  { 359u, (unsigned __int8 *)0x81332F2 },
  { 360u, (unsigned __int8 *)0x8130BD9 },
  { 361u, (unsigned __int8 *)0x813228F },
  { 362u, (unsigned __int8 *)0x8130BD9 },
  { 363u, (unsigned __int8 *)0x813228F },
  { 364u, (unsigned __int8 *)0x8130BD9 },
  { 365u, (unsigned __int8 *)0x813228F },
  { 366u, (unsigned __int8 *)0x8130BD9 },
  { 367u, (unsigned __int8 *)0x813228F },
  { 368u, &aU },
  { 369u, &aU_0 },
  { 370u, (unsigned __int8 *)0x8130BD9 },
  { 371u, (unsigned __int8 *)0x813228F },
  { 372u, (unsigned __int8 *)0x812E77D },
  { 373u, (unsigned __int8 *)0x8130F79 },
  { 374u, (unsigned __int8 *)0x81327BA },
  { 375u, (unsigned __int8 *)0x8135330 },
  { 376u, (unsigned __int8 *)0x81327BA },
  { 377u, (unsigned __int8 *)0x8130255 },
  { 378u, (unsigned __int8 *)0x812C24C },
  { 379u, (unsigned __int8 *)0x8130255 },
  { 380u, (unsigned __int8 *)0x812C24C },
  { 381u, (unsigned __int8 *)0x8130255 },
  { 382u, (unsigned __int8 *)0x812C24C },
  { 383u, &aS1 },
  { 391u, (unsigned __int8 *)0x812FFC5 },
  { 392u, &aC2 },
  { 401u, &aF2 },
  { 402u, &asc_8130090 },
  { 408u, &aK2 },
  { 409u, (unsigned __int8 *)0x813428C },
  { 416u, &aO9 },
  { 417u, &aO9_0 },
  { 418u, &aOi },
  { 419u, &aOi_0 },
  { 422u, &aYr },
  { 431u, &aU9 },
  { 432u, &aU9_0 },
  { 437u, &aZ },
  { 438u, (unsigned __int8 *)0x812BAA3 },
  { 439u, (unsigned __int8 *)0x812C7BC },
  { 461u, (unsigned __int8 *)0x8132859 },
  { 462u, (unsigned __int8 *)0x812FFFB },
  { 463u, (unsigned __int8 *)0x8132865 },
  { 464u, (unsigned __int8 *)0x8131077 },
  { 465u, (unsigned __int8 *)0x812A3FF },
  { 466u, (unsigned __int8 *)0x8130A05 },
  { 467u, (unsigned __int8 *)0x8130BD9 },
  { 468u, (unsigned __int8 *)0x813228F },
  { 469u, (unsigned __int8 *)0x8130BD9 },
  { 470u, (unsigned __int8 *)0x813228F },
  { 471u, (unsigned __int8 *)0x8130BD9 },
  { 472u, (unsigned __int8 *)0x813228F },
  { 473u, (unsigned __int8 *)0x8130BD9 },
  { 474u, (unsigned __int8 *)0x813228F },
  { 475u, (unsigned __int8 *)0x8130BD9 },
  { 476u, (unsigned __int8 *)0x813228F },
  { 478u, &aA1 },
  { 479u, (unsigned __int8 *)0x8134DF3 },
  { 480u, &aA7 },
  { 481u, &aA7_0 },
  { 482u, &aA3 },
  { 483u, (unsigned __int8 *)0x8134E03 },
  { 484u, &aG },
  { 485u, (unsigned __int8 *)0x8133389 },
  { 486u, (unsigned __int8 *)0x812CF8F },
  { 487u, (unsigned __int8 *)0x812EE23 },
  { 488u, (unsigned __int8 *)0x812FFD2 },
  { 489u, (unsigned __int8 *)0x8133548 },
  { 490u, (unsigned __int8 *)0x812A3FF },
  { 491u, (unsigned __int8 *)0x8130A05 },
  { 492u, &aO1 },
  { 493u, (unsigned __int8 *)0x8134E8F },
  { 494u, &aEz },
  { 495u, &aEz_0 },
  { 496u, (unsigned __int8 *)0x8130D42 },
  { 500u, (unsigned __int8 *)0x812CF8F },
  { 501u, (unsigned __int8 *)0x812EE23 },
  { 506u, &aAa_1 },
  { 507u, &aAa_2 },
  { 508u, &aAe_2 },
  { 509u, &aAe_3 },
  { 510u, &aO_2 },
  { 511u, &aO_3 },
  { 512u, &aA_1 },
  { 513u, &aA_2 },
  { 514u, (unsigned __int8 *)0x81321B9 },
  { 515u, (unsigned __int8 *)0x8130E0C },
  { 516u, &aE },
  { 517u, &aE_0 },
  { 518u, &aE_1 },
  { 519u, (unsigned __int8 *)0x8130E18 },
  { 520u, &aI_0 },
  { 521u, &aI_1 },
  { 522u, &aI_2 },
  { 523u, (unsigned __int8 *)0x8130E28 },
  { 524u, &aO_4 },
  { 525u, &aO_5 },
  { 526u, &aO_6 },
  { 527u, (unsigned __int8 *)0x8130C60 },
  { 528u, &aR_0 },
  { 529u, &aR_1 },
  { 530u, (unsigned __int8 *)0x8130002 },
  { 531u, (unsigned __int8 *)0x8130E48 },
  { 532u, &aU_1 },
  { 533u, &aU_2 },
  { 534u, (unsigned __int8 *)0x81310F7 },
  { 535u, (unsigned __int8 *)0x8130E50 },
  { 541u, (unsigned __int8 *)0x8130255 },
  { 593u, (unsigned __int8 *)0x8132859 },
  { 594u, &aA_3 },
  { 595u, &aB_0 },
  { 596u, (unsigned __int8 *)0x812A3FF },
  { 598u, (unsigned __int8 *)0x8131200 },
  { 599u, &aD_2 },
  { 600u, &aUmd },
  { 601u, (unsigned __int8 *)0x8132142 },
  { 602u, (unsigned __int8 *)0x812ECBE },
  { 603u, (unsigned __int8 *)0x8130028 },
  { 604u, &aV },
  { 605u, &aRUmd },
  { 606u, &aO_0 },
  { 607u, (unsigned __int8 *)0x81338F4 },
  { 608u, &aG_0 },
  { 609u, (unsigned __int8 *)0x812EE23 },
  { 610u, (unsigned __int8 *)0x812CF8F },
  { 611u, (unsigned __int8 *)0x812FFAF },
  { 612u, &aO_7 },
  { 613u, &aJRnd },
  { 614u, &asc_813013E },
  { 616u, &aI_3 },
  { 617u, (unsigned __int8 *)0x8132865 },
  { 618u, (unsigned __int8 *)0x8132865 },
  { 619u, (unsigned __int8 *)0x8130BCE },
  { 620u, (unsigned __int8 *)0x8130BCE },
  { 621u, &asc_813006C },
  { 622u, &aZLat },
  { 623u, &aU_3 },
  { 624u, &aJVel },
  { 625u, (unsigned __int8 *)0x812B0D5 },
  { 627u, (unsigned __int8 *)0x812B016 },
  { 628u, &aN_0 },
  { 629u, &asc_813015A },
  { 630u, &asc_813015D },
  { 631u, (unsigned __int8 *)0x8130BD9 },
  { 633u, (unsigned __int8 *)0x812EAD0 },
  { 634u, &aLat },
  { 635u, (unsigned __int8 *)0x8133088 },
  { 637u, &asc_8130167 },
  { 638u, (unsigned __int8 *)0x8130031 },
  { 640u, (unsigned __int8 *)0x812ECBE },
  { 640u, &aR_2 },
  { 641u, &aG_1 },
  { 642u, (unsigned __int8 *)0x812CB0D },
  { 643u, (unsigned __int8 *)0x8130F43 },
  { 644u, &aJ },
  { 647u, &aT_0 },
  { 648u, (unsigned __int8 *)0x81280B0 },
  { 649u, &aU_0 },
  { 650u, (unsigned __int8 *)0x8130BD9 },
  { 651u, &aRLbd },
  { 652u, (unsigned __int8 *)0x8130BD1 },
  { 653u, &aWVls },
  { 654u, &asc_8130184 },
  { 655u, &aI_4 },
  { 656u, &aZ_0 },
  { 658u, (unsigned __int8 *)0x8130255 },
  { 660u, (unsigned __int8 *)0x8130A2D },
  { 661u, &aHVcd },
  { 662u, &asc_8130194 },
  { 663u, &aC_3 },
  { 664u, &aP },
  { 665u, &aBTrl },
  { 667u, &aG_2 },
  { 669u, (unsigned __int8 *)0x8130D42 },
  { 670u, &aK },
  { 671u, (unsigned __int8 *)0x8130BCE },
  { 672u, &aQ },
  { 676u, (unsigned __int8 *)0x8134C2F },
  { 678u, (unsigned __int8 *)0x8132FD7 },
  { 679u, &aTs },
  { 688u, &asc_81301B0 },
  { 689u, (unsigned __int8 *)0x813013F },
  { 690u, (unsigned __int8 *)0x81301CF },
  { 691u, &aR_3 },
  { 695u, &aW },
  { 699u, &aS_9 },
  { 700u, (unsigned __int8 *)0x81301A5 },
  { 710u, (unsigned __int8 *)0x8130B49 },
  { 711u, &asc_81301BF },
  { 712u, (unsigned __int8 *)0x813282F },
  { 713u, &a1_1 },
  { 715u, &a1_2 },
  { 720u, &buf },
  { 721u, &delete },
  { 726u, (unsigned __int8 *)0x8130362 },
  { 727u, (unsigned __int8 *)0x8127DCF },
  { 728u, &asc_81301C8 },
  { 729u, (unsigned __int8 *)0x81307C3 },
  { 730u, &a0 },
  { 731u, &asc_81301CE },
  { 732u, (unsigned __int8 *)0x812C288 },
  { 733u, &asc_81301D1 },
  { 741u, &aT_1 },
  { 742u, &asc_81301D7 },
  { 743u, &aM },
  { 744u, &asc_81301DD },
  { 745u, &aB_1 },
  { 748u, &aV_0 },
  { 750u, (unsigned __int8 *)0x8130A1F },
  { 768u, (unsigned __int8 *)0x81301A5 },
  { 769u, (unsigned __int8 *)0x8130A20 },
  { 770u, (unsigned __int8 *)0x8130B49 },
  { 771u, (unsigned __int8 *)0x812C288 },
  { 779u, (unsigned __int8 *)0x8130A1F },
  { 781u, (unsigned __int8 *)0x813282F },
  { 782u, &asc_81301E6 },
  { 783u, (unsigned __int8 *)0x8130A23 },
  { 801u, (unsigned __int8 *)0x81301CF },
  { 802u, (unsigned __int8 *)0x813015E },
  { 803u, (unsigned __int8 *)0x813015E },
  { 804u, (unsigned __int8 *)0x813013F },
  { 805u, &aO_8 },
  { 806u, (unsigned __int8 *)0x813114D },
  { 807u, (unsigned __int8 *)0x813114D },
  { 809u, (unsigned __int8 *)0x8127DCF },
  { 810u, (unsigned __int8 *)0x812CC65 },
  { 811u, &aW },
  { 820u, &asc_81301ED },
  { 820u, (unsigned __int8 *)0x812C288 },
  { 823u, (unsigned __int8 *)0x8132419 },
  { 824u, (unsigned __int8 *)0x8132419 },
  { 832u, (unsigned __int8 *)0x81301A5 },
  { 833u, (unsigned __int8 *)0x8130A20 },
  { 834u, (unsigned __int8 *)0x812C288 },
  { 836u, &asc_81301F1 },
  { 837u, &aJ3 },
  { 839u, (unsigned __int8 *)0x8130C01 },
  { 864u, &asc_81301F7 },
  { 884u, (unsigned __int8 *)0x8130A20 },
  { 885u, (unsigned __int8 *)0x813114D },
  { 890u, &aJ3 },
  { 894u, &asc_81301FA },
  { 900u, &asc_81301FD },
  { 901u, &asc_81301F1 },
  { 902u, (unsigned __int8 *)0x81300C7 },
  { 903u, &asc_8130200 },
  { 904u, (unsigned __int8 *)0x81300CF },
  { 905u, &aY_0 },
  { 906u, &aI_5 },
  { 908u, &aO_9 },
  { 910u, &aU_4 },
  { 911u, &aW_0 },
  { 912u, (unsigned __int8 *)0x81346F5 },
  { 913u, (unsigned __int8 *)0x8132859 },
  { 914u, (unsigned __int8 *)0x812D2D6 },
  { 915u, (unsigned __int8 *)0x812CF8F },
  { 916u, (unsigned __int8 *)0x812C759 },
  { 917u, (unsigned __int8 *)0x8130028 },
  { 918u, (unsigned __int8 *)0x8130255 },
  { 919u, (unsigned __int8 *)0x81327BA },
  { 920u, (unsigned __int8 *)0x812CF4A },
  { 921u, (unsigned __int8 *)0x8132865 },
  { 922u, (unsigned __int8 *)0x812FFD2 },
  { 923u, (unsigned __int8 *)0x8130BCE },
  { 924u, (unsigned __int8 *)0x812B0D5 },
  { 925u, (unsigned __int8 *)0x812D7DC },
  { 926u, &byte_8130C3E },
  { 927u, (unsigned __int8 *)0x812A3FF },
  { 928u, (unsigned __int8 *)0x812D943 },
  { 929u, (unsigned __int8 *)0x812ECBE },
  { 931u, (unsigned __int8 *)0x8130F43 },
  { 932u, (unsigned __int8 *)0x8130C7C },
  { 933u, (unsigned __int8 *)0x8130BD9 },
  { 934u, (unsigned __int8 *)0x812D4BB },
  { 935u, (unsigned __int8 *)0x8130FD7 },
  { 936u, (unsigned __int8 *)0x812FFAF },
  { 937u, &aW_1 },
  { 938u, (unsigned __int8 *)0x81338F4 },
  { 939u, &aV_1 },
  { 940u, (unsigned __int8 *)0x81300CB },
  { 941u, (unsigned __int8 *)0x81300D3 },
  { 942u, &aY_1 },
  { 943u, &aI_6 },
  { 944u, &aU3 },
  { 945u, (unsigned __int8 *)0x812FFFB },
  { 946u, (unsigned __int8 *)0x8130F76 },
  { 947u, (unsigned __int8 *)0x812EE23 },
  { 948u, (unsigned __int8 *)0x813389E },
  { 949u, (unsigned __int8 *)0x8131E32 },
  { 950u, (unsigned __int8 *)0x812C24C },
  { 951u, (unsigned __int8 *)0x8135330 },
  { 952u, &unk_812B2C7 },
  { 953u, (unsigned __int8 *)0x8131077 },
  { 954u, (unsigned __int8 *)0x8133548 },
  { 955u, (unsigned __int8 *)0x813391D },
  { 956u, (unsigned __int8 *)0x81339A8 },
  { 957u, (unsigned __int8 *)0x8130076 },
  { 958u, (unsigned __int8 *)0x812CC3A },
  { 959u, (unsigned __int8 *)0x8130A05 },
  { 960u, (unsigned __int8 *)0x8132310 },
  { 961u, (unsigned __int8 *)0x812EAD0 },
  { 962u, (unsigned __int8 *)0x8133187 },
  { 963u, (unsigned __int8 *)0x8133696 },
  { 964u, (unsigned __int8 *)0x812EE2A },
  { 965u, (unsigned __int8 *)0x813228F },
  { 966u, (unsigned __int8 *)0x8130091 },
  { 967u, (unsigned __int8 *)0x813532D },
  { 968u, (unsigned __int8 *)0x812FF17 },
  { 969u, (unsigned __int8 *)0x8130F79 },
  { 970u, (unsigned __int8 *)0x8130D42 },
  { 971u, &aV_2 },
  { 972u, &aO_10 },
  { 973u, &aU_5 },
  { 974u, &aW_2 },
  { 976u, (unsigned __int8 *)0x812F1DC },
  { 977u, &aTheta_0 },
  { 978u, (unsigned __int8 *)0x812F2A7 },
  { 981u, &aPhi },
  { 982u, (unsigned __int8 *)0x812F260 },
  { 983u, (unsigned __int8 *)0x81311B8 },
  { 986u, (unsigned __int8 *)0x812DA9C },
  { 987u, (unsigned __int8 *)0x8134EBC },
  { 988u, &aM3 },
  { 989u, (unsigned __int8 *)0x8134D61 },
  { 990u, &aK3 },
  { 991u, (unsigned __int8 *)0x8134297 },
  { 992u, &aP3 },
  { 993u, (unsigned __int8 *)0x812FD70 },
  { 1008u, (unsigned __int8 *)0x812F226 },
  { 1009u, (unsigned __int8 *)0x812F271 },
  { 1011u, (unsigned __int8 *)0x81338F4 },
  { 1012u, &asc_81301F1 },
  { 1013u, &aJ3 },
  { 1025u, &aIo },
  { 1026u, &aD_3 },
  { 1027u, &aG_3 },
  { 1028u, (unsigned __int8 *)0x812DBAF },
  { 1029u, (unsigned __int8 *)0x812CE00 },
  { 1030u, (unsigned __int8 *)0x812EB72 },
  { 1031u, &aYi },
  { 1032u, &aJ_0 },
  { 1033u, &aLj },
  { 1034u, &aNj },
  { 1035u, &aTs_0 },
  { 1036u, &aKj },
  { 1038u, &aV_3 },
  { 1039u, &aDz },
  { 1040u, (unsigned __int8 *)0x8132859 },
  { 1041u, (unsigned __int8 *)0x812D2D6 },
  { 1042u, (unsigned __int8 *)0x8130BD1 },
  { 1043u, (unsigned __int8 *)0x812CF8F },
  { 1044u, (unsigned __int8 *)0x812C759 },
  { 1045u, (unsigned __int8 *)0x8130028 },
  { 1046u, &aZh },
  { 1047u, (unsigned __int8 *)0x8130255 },
  { 1048u, (unsigned __int8 *)0x8132865 },
  { 1049u, (unsigned __int8 *)0x81338F4 },
  { 1050u, (unsigned __int8 *)0x812FFD2 },
  { 1051u, (unsigned __int8 *)0x8130BCE },
  { 1052u, (unsigned __int8 *)0x812B0D5 },
  { 1053u, (unsigned __int8 *)0x812D7DC },
  { 1054u, (unsigned __int8 *)0x812A3FF },
  { 1055u, (unsigned __int8 *)0x812D943 },
  { 1056u, (unsigned __int8 *)0x812ECBE },
  { 1057u, (unsigned __int8 *)0x8130F43 },
  { 1058u, (unsigned __int8 *)0x8130C7C },
  { 1059u, (unsigned __int8 *)0x8130BD9 },
  { 1060u, (unsigned __int8 *)0x812D4BB },
  { 1061u, (unsigned __int8 *)0x8133955 },
  { 1062u, &byte_8130C3E },
  { 1063u, (unsigned __int8 *)0x812CCBB },
  { 1064u, &aSh },
  { 1065u, &aSch },
  { 1066u, (unsigned __int8 *)0x8128449 },
  { 1067u, (unsigned __int8 *)0x81327BA },
  { 1068u, (unsigned __int8 *)0x8130A20 },
  { 1069u, &aE_2 },
  { 1070u, &aYu },
  { 1071u, &aYa },
  { 1072u, (unsigned __int8 *)0x812FFFB },
  { 1073u, (unsigned __int8 *)0x8130F76 },
  { 1074u, (unsigned __int8 *)0x8130B4C },
  { 1075u, (unsigned __int8 *)0x812EE23 },
  { 1076u, (unsigned __int8 *)0x813389E },
  { 1077u, (unsigned __int8 *)0x8131E32 },
  { 1078u, &aZh_0 },
  { 1079u, (unsigned __int8 *)0x812C24C },
  { 1080u, (unsigned __int8 *)0x8131077 },
  { 1081u, (unsigned __int8 *)0x8130D42 },
  { 1082u, (unsigned __int8 *)0x8133548 },
  { 1083u, (unsigned __int8 *)0x813391D },
  { 1084u, (unsigned __int8 *)0x81339A8 },
  { 1085u, (unsigned __int8 *)0x8130076 },
  { 1086u, (unsigned __int8 *)0x8130A05 },
  { 1087u, (unsigned __int8 *)0x8132310 },
  { 1088u, (unsigned __int8 *)0x812EAD0 },
  { 1089u, (unsigned __int8 *)0x8133696 },
  { 1090u, (unsigned __int8 *)0x812EE2A },
  { 1091u, (unsigned __int8 *)0x813228F },
  { 1092u, (unsigned __int8 *)0x8130091 },
  { 1093u, (unsigned __int8 *)0x813392C },
  { 1094u, (unsigned __int8 *)0x812CC3A },
  { 1095u, (unsigned __int8 *)0x81313AA },
  { 1096u, (unsigned __int8 *)0x8131EB1 },
  { 1097u, &aSch_0 },
  { 1098u, (unsigned __int8 *)0x8128449 },
  { 1099u, (unsigned __int8 *)0x8135330 },
  { 1100u, (unsigned __int8 *)0x8130A20 },
  { 1101u, &aE_3 },
  { 1102u, &aYu_0 },
  { 1103u, &aYa_0 },
  { 1105u, (unsigned __int8 *)0x812A3F4 },
  { 1106u, &aD_4 },
  { 1107u, &aG_4 },
  { 1108u, (unsigned __int8 *)0x812F512 },
  { 1109u, (unsigned __int8 *)0x812BA59 },
  { 1110u, (unsigned __int8 *)0x812E3B6 },
  { 1111u, &aYi_0 },
  { 1112u, &aJ_1 },
  { 1113u, &aLj_0 },
  { 1114u, (unsigned __int8 *)0x812FFA0 },
  { 1115u, (unsigned __int8 *)0x8132FD7 },
  { 1116u, &aKj_0 },
  { 1118u, &aV_4 },
  { 1119u, &aDz_0 },
  { 1122u, &aY3 },
  { 1123u, (unsigned __int8 *)0x813421E },
  { 1130u, &aO3 },
  { 1131u, (unsigned __int8 *)0x8134E9F },
  { 1138u, &aF3 },
  { 1139u, (unsigned __int8 *)0x8134D44 },
  { 1140u, &aV3 },
  { 1141u, &aV3_0 },
  { 1152u, (unsigned __int8 *)0x812FFC9 },
  { 1153u, &aC3 },
  { 1168u, &aG3 },
  { 1169u, &aG3_0 },
  { 1236u, &aAe_0 },
  { 1237u, &aAe_1 },
  { 1460u, (unsigned __int8 *)0x8131077 },
  { 1463u, (unsigned __int8 *)0x812FFFB },
  { 1464u, (unsigned __int8 *)0x8130A05 },
  { 1468u, (unsigned __int8 *)0x813228F },
  { 1471u, (unsigned __int8 *)0x813392C },
  { 1474u, &buf },
  { 1488u, &prompt },
  { 1489u, &aB_2 },
  { 1490u, &aG_5 },
  { 1491u, &aD_5 },
  { 1492u, &asc_81302AD },
  { 1493u, &aW_3 },
  { 1494u, &aZ_1 },
  { 1495u, &asc_81302B6 },
  { 1496u, &aTj },
  { 1497u, &aJ_2 },
  { 1498u, &aK_0 },
  { 1499u, &aK_1 },
  { 1500u, &asc_81302C5 },
  { 1501u, &aM_0 },
  { 1502u, &aM_1 },
  { 1503u, &aN_1 },
  { 1504u, &aN_2 },
  { 1505u, &aS_10 },
  { 1506u, &aE_4 },
  { 1507u, &aP_0 },
  { 1508u, &aP_1 },
  { 1509u, &aZj },
  { 1510u, &aZj_0 },
  { 1511u, &aQ_0 },
  { 1512u, &aR_4 },
  { 1513u, &aSh_0 },
  { 1514u, &aT_2 },
  { 1520u, (unsigned __int8 *)0x8130B4C },
  { 1521u, &aOy },
  { 1522u, (unsigned __int8 *)0x8129835 },
  { 1548u, &asc_81302F5 },
  { 1563u, &asc_81302F8 },
  { 1567u, &asc_81302FB },
  { 1569u, &asc_81302FE },
  { 1570u, &aAm },
  { 1571u, &aAh },
  { 1572u, &aWh },
  { 1573u, (unsigned __int8 *)0x8133405 },
  { 1574u, &aYh },
  { 1575u, &aA_4 },
  { 1576u, &aB_3 },
  { 1577u, (unsigned __int8 *)0x8131868 },
  { 1578u, &aT_3 },
  { 1579u, &aTk },
  { 1580u, &aG_6 },
  { 1581u, (unsigned __int8 *)0x812F839 },
  { 1582u, &asc_813031C },
  { 1583u, &aD_6 },
  { 1584u, &aDk },
  { 1585u, &aR_5 },
  { 1586u, &aZ_2 },
  { 1587u, &aS_11 },
  { 1588u, &aSn },
  { 1589u, &aC_4 },
  { 1590u, (unsigned __int8 *)0x8127A54 },
  { 1591u, &aTj_0 },
  { 1592u, &aZh_1 },
  { 1593u, &aE_5 },
  { 1594u, &aI_7 },
  { 1600u, &asc_8130340 },
  { 1601u, &asc_8130343 },
  { 1602u, &aQ_1 },
  { 1603u, &aK_2 },
  { 1604u, &asc_813034C },
  { 1605u, &aM_2 },
  { 1606u, &aN_3 },
  { 1607u, &asc_8130355 },
  { 1608u, &aW_4 },
  { 1609u, &aJ_3 },
  { 1610u, &aY_2 },
  { 1611u, &delete },
  { 1612u, &asc_8130361 },
  { 1613u, &asc_8130364 },
  { 1614u, (unsigned __int8 *)0x8130BA7 },
  { 1615u, &asc_8130367 },
  { 1616u, &a1_3 },
  { 1617u, &a3_0 },
  { 1618u, &a0_0 },
  { 1632u, &a0a },
  { 1633u, &a1a },
  { 1634u, &a2a },
  { 1635u, &a3a },
  { 1636u, &a4a },
  { 1637u, &a5a },
  { 1638u, &a6a },
  { 1639u, &a7a },
  { 1640u, &a8a },
  { 1641u, &a9a },
  { 1648u, &aAs },
  { 1662u, &aP_2 },
  { 1665u, &aHh_1 },
  { 1670u, &aTc },
  { 1688u, &aZj_1 },
  { 1700u, &aV_5 },
  { 1711u, &aGf },
  { 1776u, &a0a },
  { 1777u, &a1a },
  { 1778u, &a2a },
  { 1779u, &a3a },
  { 1780u, &a4a },
  { 1781u, &a5a },
  { 1782u, &a6a },
  { 1783u, &a7a },
  { 1784u, &a8a },
  { 1785u, &a9a },
  { 4608u, (unsigned __int8 *)0x813048F },
  { 4609u, (unsigned __int8 *)0x8130493 },
  { 4610u, (unsigned __int8 *)0x812ED75 },
  { 4611u, (unsigned __int8 *)0x813049B },
  { 4612u, (unsigned __int8 *)0x813049F },
  { 4613u, (unsigned __int8 *)0x813392C },
  { 4614u, (unsigned __int8 *)0x812EFD8 },
  { 4616u, (unsigned __int8 *)0x81314CB },
  { 4617u, &aLu },
  { 4618u, &aLi },
  { 4619u, (unsigned __int8 *)0x8130B89 },
  { 4620u, &aLe },
  { 4621u, (unsigned __int8 *)0x813391D },
  { 4622u, &aLo },
  { 4623u, &aLwa },
  { 4624u, &aHe },
  { 4625u, (unsigned __int8 *)0x812F337 },
  { 4626u, &aHi },
  { 4627u, &aHa },
  { 4628u, &aHe_0 },
  { 4629u, (unsigned __int8 *)0x8133955 },
  { 4630u, &aHo },
  { 4631u, &aHwa },
  { 4632u, &unk_81275A9 },
  { 4633u, (unsigned __int8 *)0x812F240 },
  { 4634u, (unsigned __int8 *)0x812FCDC },
  { 4635u, (unsigned __int8 *)0x812C3AC },
  { 4636u, &aMe },
  { 4637u, (unsigned __int8 *)0x81339A8 },
  { 4638u, (unsigned __int8 *)0x8131494 },
  { 4639u, &aMwa },
  { 4640u, &aSe },
  { 4641u, &aSu },
  { 4642u, &aSi_0 },
  { 4643u, &aSa },
  { 4644u, &aSe_0 },
  { 4645u, &aS_12 },
  { 4646u, &aSo },
  { 4647u, &aSwa },
  { 4648u, (unsigned __int8 *)0x812F7AB },
  { 4649u, (unsigned __int8 *)0x812EAE6 },
  { 4650u, (unsigned __int8 *)0x812FF30 },
  { 4651u, (unsigned __int8 *)0x812FB3E },
  { 4652u, &aRe },
  { 4653u, (unsigned __int8 *)0x812EAD0 },
  { 4654u, (unsigned __int8 *)0x812F93B },
  { 4655u, &aRwa },
  { 4656u, (unsigned __int8 *)0x81303CE },
  { 4657u, (unsigned __int8 *)0x81303D2 },
  { 4658u, (unsigned __int8 *)0x812F1B3 },
  { 4659u, (unsigned __int8 *)0x81303DA },
  { 4660u, (unsigned __int8 *)0x81303DE },
  { 4661u, (unsigned __int8 *)0x8133696 },
  { 4662u, (unsigned __int8 *)0x81303E5 },
  { 4663u, (unsigned __int8 *)0x81303E9 },
  { 4664u, &aXe },
  { 4665u, &aXu },
  { 4666u, (unsigned __int8 *)0x812F2AE },
  { 4667u, &aXa },
  { 4668u, &aXe_0 },
  { 4669u, &aXa },
  { 4670u, &aXo },
  { 4671u, &aXwa },
  { 4672u, &aQe },
  { 4673u, (unsigned __int8 *)0x812FD3D },
  { 4674u, &aQi },
  { 4675u, &aQa },
  { 4676u, &aQe_0 },
  { 4677u, (unsigned __int8 *)0x812FF17 },
  { 4678u, &aQo },
  { 4680u, &aQwe },
  { 4682u, &aQwi },
  { 4683u, &aQwa },
  { 4684u, &aQwe_0 },
  { 4685u, &aQw },
  { 4688u, &aQe_1 },
  { 4689u, &aQu },
  { 4690u, &aQi_0 },
  { 4691u, &aQa_0 },
  { 4692u, &aQe_2 },
  { 4693u, (unsigned __int8 *)0x812FFAF },
  { 4694u, &aQo_0 },
  { 4696u, &aQwe_1 },
  { 4698u, &aQwi_0 },
  { 4699u, &aQwa_0 },
  { 4700u, &aQwe_2 },
  { 4701u, &aQw_0 },
  { 4704u, (unsigned __int8 *)0x812FA58 },
  { 4705u, &aBu },
  { 4706u, &aBi },
  { 4707u, (unsigned __int8 *)0x8131F4D },
  { 4708u, (unsigned __int8 *)0x812FA52 },
  { 4709u, (unsigned __int8 *)0x8130F76 },
  { 4710u, &aBo },
  { 4711u, &aBwa },
  { 4712u, (unsigned __int8 *)0x812ED15 },
  { 4713u, &aVu },
  { 4714u, &aVi },
  { 4715u, &aVa },
  { 4716u, &aVe },
  { 4717u, (unsigned __int8 *)0x8130B4C },
  { 4718u, &aVo },
  { 4719u, &aVwa },
  { 4720u, &unk_812B3D8 },
  { 4721u, &aTu },
  { 4722u, &aTi },
  { 4723u, (unsigned __int8 *)0x812EDF4 },
  { 4724u, &aTe },
  { 4725u, (unsigned __int8 *)0x812EE2A },
  { 4726u, (unsigned __int8 *)0x8135215 },
  { 4727u, &aTwa },
  { 4728u, (unsigned __int8 *)0x812EAA1 },
  { 4729u, &aCu },
  { 4730u, &aCi },
  { 4731u, &aCa },
  { 4732u, &aCe },
  { 4733u, (unsigned __int8 *)0x812CC3A },
  { 4734u, &aCo },
  { 4735u, &aCwa },
  { 4736u, &aHe_1 },
  { 4737u, &aHu },
  { 4738u, &aHi_0 },
  { 4739u, &aHa_0 },
  { 4740u, &aHe_2 },
  { 4741u, &asc_81304A2 },
  { 4742u, &aHo_0 },
  { 4744u, &aHwe },
  { 4746u, &aHwi },
  { 4747u, &aHwa_0 },
  { 4748u, &aHwe_0 },
  { 4749u, &aHw },
  { 4752u, (unsigned __int8 *)0x8133E4A },
  { 4753u, (unsigned __int8 *)0x812F245 },
  { 4754u, &aNi },
  { 4755u, (unsigned __int8 *)0x8133E4A },
  { 4756u, (unsigned __int8 *)0x812FEF4 },
  { 4757u, (unsigned __int8 *)0x8130076 },
  { 4758u, &byte_812785C },
  { 4759u, &aNwa },
  { 4760u, &aNe },
  { 4761u, &aNu },
  { 4762u, &aNi_0 },
  { 4763u, &aNa },
  { 4764u, (unsigned __int8 *)0x812D8DD },
  { 4765u, (unsigned __int8 *)0x812D7DC },
  { 4766u, (unsigned __int8 *)0x8127628 },
  { 4767u, &aNwa_0 },
  { 4768u, (unsigned __int8 *)0x8131E32 },
  { 4769u, (unsigned __int8 *)0x813228F },
  { 4770u, (unsigned __int8 *)0x8131077 },
  { 4771u, (unsigned __int8 *)0x812FFFB },
  { 4772u, (unsigned __int8 *)0x8130028 },
  { 4773u, (unsigned __int8 *)0x8132865 },
  { 4774u, (unsigned __int8 *)0x8130A05 },
  { 4775u, (unsigned __int8 *)0x813414D },
  { 4776u, (unsigned __int8 *)0x81325C5 },
  { 4777u, &aKu },
  { 4778u, (unsigned __int8 *)0x81340D0 },
  { 4779u, &aKa },
  { 4780u, &aKe },
  { 4781u, (unsigned __int8 *)0x8133548 },
  { 4782u, &aKo },
  { 4784u, &aKwe },
  { 4786u, &aKwi },
  { 4787u, &aKwa },
  { 4788u, &aKwe_0 },
  { 4789u, &aKw },
  { 4792u, &aKe_0 },
  { 4793u, &aKu_0 },
  { 4794u, &aKi },
  { 4795u, &aKa_0 },
  { 4796u, (unsigned __int8 *)0x812C80C },
  { 4797u, (unsigned __int8 *)0x812FFD2 },
  { 4798u, &aKo_0 },
  { 4800u, &aKwe_1 },
  { 4802u, &aKwi_0 },
  { 4803u, &aKwa_0 },
  { 4804u, &aKwe_2 },
  { 4805u, &aKw_0 },
  { 4808u, &aWe },
  { 4809u, &aWu },
  { 4810u, &aWi },
  { 4811u, &aWa },
  { 4812u, &aWe_0 },
  { 4813u, (unsigned __int8 *)0x8130F79 },
  { 4814u, &aWo },
  { 4816u, &aE_3 },
  { 4817u, &aU_6 },
  { 4818u, &aI },
  { 4819u, (unsigned __int8 *)0x81309B0 },
  { 4820u, &aE_2 },
  { 4821u, &aI_8 },
  { 4822u, &aO_11 },
  { 4824u, &unk_8127BDD },
  { 4825u, &aZu },
  { 4826u, &aZi },
  { 4827u, &aZa },
  { 4828u, &aZe },
  { 4829u, (unsigned __int8 *)0x812C24C },
  { 4830u, &aZo },
  { 4831u, &aZwa },
  { 4832u, &aZe_0 },
  { 4833u, &aZu_0 },
  { 4834u, &aZi_0 },
  { 4835u, &aZa_0 },
  { 4836u, (unsigned __int8 *)0x812DF95 },
  { 4837u, (unsigned __int8 *)0x8130255 },
  { 4838u, &aZo_0 },
  { 4839u, &aZwa_0 },
  { 4840u, &aYe },
  { 4841u, &aYu_0 },
  { 4842u, &aYi_0 },
  { 4843u, &aYa_0 },
  { 4844u, &aYe_0 },
  { 4845u, (unsigned __int8 *)0x8135330 },
  { 4846u, &aYo },
  { 4847u, &aYwa },
  { 4848u, (unsigned __int8 *)0x812C731 },
  { 4849u, (unsigned __int8 *)0x81321E0 },
  { 4850u, &aDi },
  { 4851u, (unsigned __int8 *)0x812F19A },
  { 4852u, &aDe },
  { 4853u, (unsigned __int8 *)0x813389E },
  { 4854u, (unsigned __int8 *)0x8133557 },
  { 4855u, &aDwa },
  { 4856u, &aDe_0 },
  { 4857u, &aDu },
  { 4858u, &aDi_0 },
  { 4859u, &aDa },
  { 4860u, (unsigned __int8 *)0x812DF9D },
  { 4861u, (unsigned __int8 *)0x812C759 },
  { 4862u, &aDo },
  { 4863u, &aDwa_0 },
  { 4864u, &aJe },
  { 4865u, &aJu },
  { 4866u, &aJi },
  { 4867u, &aJa },
  { 4868u, &aJe_0 },
  { 4869u, (unsigned __int8 *)0x8130D42 },
  { 4870u, &aJo },
  { 4871u, &aJwa },
  { 4872u, (unsigned __int8 *)0x812F1A2 },
  { 4873u, &aGu },
  { 4874u, (unsigned __int8 *)0x8132699 },
  { 4875u, (unsigned __int8 *)0x812F1A2 },
  { 4876u, &aGe },
  { 4877u, (unsigned __int8 *)0x812EE23 },
  { 4878u, (unsigned __int8 *)0x8133BDE },
  { 4880u, &aGwu },
  { 4882u, &aGwi },
  { 4883u, &aGwa },
  { 4884u, &aGwe },
  { 4885u, &aGw },
  { 4888u, &aGe_0 },
  { 4889u, &aGu_0 },
  { 4890u, &aGi },
  { 4891u, &aGa },
  { 4892u, (unsigned __int8 *)0x812D714 },
  { 4893u, (unsigned __int8 *)0x812CF8F },
  { 4894u, &aGo },
  { 4895u, &aGwa_0 },
  { 4896u, &aTe_0 },
  { 4897u, &aTu_0 },
  { 4898u, &aTi_0 },
  { 4899u, &aTa },
  { 4900u, (unsigned __int8 *)0x812D9A2 },
  { 4901u, (unsigned __int8 *)0x8130C7C },
  { 4902u, &aTo },
  { 4903u, &aTwa_0 },
  { 4904u, &aCe_0 },
  { 4905u, &aCa_0 },
  { 4906u, &aCu_0 },
  { 4907u, &aCa_0 },
  { 4908u, (unsigned __int8 *)0x812D8F2 },
  { 4909u, &byte_8130C3E },
  { 4910u, &aCo_0 },
  { 4911u, &aCwa_0 },
  { 4912u, &aPe },
  { 4913u, &aPu },
  { 4914u, (unsigned __int8 *)0x812F1AD },
  { 4915u, &aPa },
  { 4916u, (unsigned __int8 *)0x812E009 },
  { 4917u, (unsigned __int8 *)0x812D943 },
  { 4918u, &aPo_0 },
  { 4919u, &aPwa },
  { 4920u, &aSwe },
  { 4921u, &aSwu },
  { 4922u, &aSwi },
  { 4923u, &aSwa_0 },
  { 4924u, &aSwe_0 },
  { 4925u, &aSw },
  { 4926u, &aSwo },
  { 4927u, &aSwa_0 },
  { 4928u, &aSa_0 },
  { 4929u, &aSu_0 },
  { 4930u, &aSi_1 },
  { 4931u, &aSa_0 },
  { 4932u, &aSe_1 },
  { 4933u, &aS_13 },
  { 4934u, &aSo_0 },
  { 4936u, &aFa },
  { 4937u, &aFu },
  { 4938u, (unsigned __int8 *)0x8131121 },
  { 4939u, &aFa },
  { 4940u, &aFe },
  { 4941u, (unsigned __int8 *)0x8130A05 },
  { 4942u, (unsigned __int8 *)0x8127C5B },
  { 4943u, &aFwa },
  { 4944u, (unsigned __int8 *)0x8128511 },
  { 4945u, &aPu_0 },
  { 4946u, (unsigned __int8 *)0x812F260 },
  { 4947u, (unsigned __int8 *)0x812EEC1 },
  { 4948u, (unsigned __int8 *)0x812FA63 },
  { 4949u, (unsigned __int8 *)0x8132310 },
  { 4950u, &aPo_1 },
  { 4951u, &aPwa_0 },
  { 4952u, &aMya },
  { 4953u, &aRya },
  { 4954u, &aFya },
  { 4960u, &start },
  { 4961u, &buf },
  { 4962u, &delete },
  { 4963u, (unsigned __int8 *)0x813114D },
  { 4964u, (unsigned __int8 *)0x81301CF },
  { 4965u, (unsigned __int8 *)0x8127DCF },
  { 4966u, &delete },
  { 4967u, &asc_8130640 },
  { 4968u, &delete },
  { 4969u, &a1_4 },
  { 4970u, &a2_0 },
  { 4971u, &a3_1 },
  { 4972u, &a4 },
  { 4973u, &a5 },
  { 4974u, &a6 },
  { 4975u, &a7_0 },
  { 4976u, &a8_0 },
  { 4977u, &a9 },
  { 4978u, &a10 },
  { 4979u, &a20 },
  { 4980u, &a30 },
  { 4981u, &a40 },
  { 4982u, &a50 },
  { 4983u, &a60 },
  { 4984u, &a70 },
  { 4985u, &a80 },
  { 4986u, &a90 },
  { 4987u, &a100_0 },
  { 4988u, &a10000 },
  { 7680u, &aA0 },
  { 7681u, &aA0_0 },
  { 7682u, &aB_4 },
  { 7683u, &aB_5 },
  { 7684u, &aB_6 },
  { 7685u, &aB_7 },
  { 7686u, &aB_8 },
  { 7687u, &aB_9 },
  { 7688u, &aC_5 },
  { 7689u, &aC_6 },
  { 7690u, &aD_7 },
  { 7691u, (unsigned __int8 *)0x8131200 },
  { 7692u, &aD_8 },
  { 7693u, &aD_9 },
  { 7694u, &aD_10 },
  { 7695u, &aD_11 },
  { 7696u, &aD_12 },
  { 7697u, (unsigned __int8 *)0x8131204 },
  { 7698u, &aD_13 },
  { 7699u, &aD_14 },
  { 7700u, &aE_6 },
  { 7701u, &aE_7 },
  { 7702u, &aE_8 },
  { 7703u, &aE_9 },
  { 7704u, &aE_10 },
  { 7705u, &aE_11 },
  { 7706u, &aE_12 },
  { 7707u, &aE_13 },
  { 7708u, &aE_14 },
  { 7709u, &aE_15 },
  { 7710u, &asc_81306F6 },
  { 7711u, &asc_81306F9 },
  { 7712u, &aG_7 },
  { 7713u, &aG_8 },
  { 7714u, (unsigned __int8 *)0x8131134 },
  { 7715u, (unsigned __int8 *)0x8131138 },
  { 7716u, &asc_8130702 },
  { 7717u, &asc_8130706 },
  { 7718u, (unsigned __int8 *)0x8133955 },
  { 7719u, (unsigned __int8 *)0x813392C },
  { 7720u, (unsigned __int8 *)0x8131224 },
  { 7721u, &asc_813070A },
  { 7722u, &asc_813070D },
  { 7723u, &asc_8130711 },
  { 7724u, &aI_9 },
  { 7725u, &aI_10 },
  { 7726u, (unsigned __int8 *)0x8132865 },
  { 7727u, (unsigned __int8 *)0x8131077 },
  { 7728u, &aK_3 },
  { 7729u, &aK_4 },
  { 7730u, &aK_5 },
  { 7731u, &aK_6 },
  { 7732u, &aK_7 },
  { 7733u, &aK_8 },
  { 7734u, &asc_8130731 },
  { 7735u, &asc_8130735 },
  { 7736u, &asc_8130739 },
  { 7737u, &asc_813073E },
  { 7738u, &asc_8130743 },
  { 7739u, &asc_8130746 },
  { 7740u, &asc_8130749 },
  { 7741u, &asc_813074D },
  { 7742u, &aM_3 },
  { 7743u, &aM_4 },
  { 7744u, (unsigned __int8 *)0x8131130 },
  { 7745u, (unsigned __int8 *)0x8131158 },
  { 7746u, &aM_5 },
  { 7747u, &aM_6 },
  { 7748u, &aN_4 },
  { 7749u, (unsigned __int8 *)0x812B016 },
  { 7750u, &aN_5 },
  { 7751u, &aN_6 },
  { 7752u, &aN_7 },
  { 7753u, &aN_8 },
  { 7754u, &aN_9 },
  { 7755u, &aN_10 },
  { 7756u, &aO_12 },
  { 7757u, &aO_13 },
  { 7758u, &aO_14 },
  { 7759u, (unsigned __int8 *)0x8133711 },
  { 7760u, &aO_15 },
  { 7761u, &aO_16 },
  { 7762u, &aO_17 },
  { 7763u, &aO_18 },
  { 7764u, &aP_3 },
  { 7765u, &aP_4 },
  { 7766u, &aP_5 },
  { 7767u, (unsigned __int8 *)0x8128036 },
  { 7768u, &aR_6 },
  { 7769u, (unsigned __int8 *)0x8133088 },
  { 7770u, &aR_7 },
  { 7771u, &aR_8 },
  { 7772u, &aR_9 },
  { 7773u, &aR_10 },
  { 7774u, &aR_11 },
  { 7775u, &aR_12 },
  { 7776u, &aS_14 },
  { 7777u, (unsigned __int8 *)0x812CB0D },
  { 7778u, &aS_15 },
  { 7779u, &aS_16 },
  { 7780u, &aS_17 },
  { 7781u, (unsigned __int8 *)0x81355A9 },
  { 7782u, &aS_18 },
  { 7783u, &aS_19 },
  { 7784u, &aS_20 },
  { 7785u, &aS_21 },
  { 7786u, &aT_4 },
  { 7787u, (unsigned __int8 *)0x81280B0 },
  { 7788u, &aT_5 },
  { 7789u, &aT_6 },
  { 7790u, &aT_7 },
  { 7791u, &aT_8 },
  { 7792u, &aT_9 },
  { 7793u, &aT_10 },
  { 7794u, &aU_7 },
  { 7795u, &aU_8 },
  { 7796u, &aU_9 },
  { 7797u, &aU_10 },
  { 7798u, &aU_11 },
  { 7799u, &aU_12 },
  { 7800u, &aU_13 },
  { 7801u, &aU_14 },
  { 7802u, &aU_15 },
  { 7803u, &aU_3 },
  { 7804u, &aV_6 },
  { 7805u, &aV_7 },
  { 7806u, &aV_8 },
  { 7807u, &aV_9 },
  { 7808u, &aW_5 },
  { 7809u, &aW_6 },
  { 7810u, &aW_7 },
  { 7811u, &aW_8 },
  { 7812u, (unsigned __int8 *)0x812E77D },
  { 7813u, (unsigned __int8 *)0x8130F79 },
  { 7814u, &aW_9 },
  { 7815u, &aW_10 },
  { 7816u, &aW_11 },
  { 7817u, &aW_12 },
  { 7818u, &asc_813083C },
  { 7819u, &asc_813083F },
  { 7820u, (unsigned __int8 *)0x8130FD7 },
  { 7821u, (unsigned __int8 *)0x813532D },
  { 7822u, &aY_3 },
  { 7823u, (unsigned __int8 *)0x81336DC },
  { 7824u, &aZ_3 },
  { 7825u, &aZ_4 },
  { 7826u, &aZ_5 },
  { 7827u, &aZ_6 },
  { 7828u, &aZ_7 },
  { 7829u, &aZ_8 },
  { 7830u, &asc_8130859 },
  { 7831u, (unsigned __int8 *)0x812EE2A },
  { 7832u, &aW0 },
  { 7833u, &aY0 },
  { 7840u, &aA_5 },
  { 7841u, &aA_6 },
  { 7842u, &aA2 },
  { 7843u, (unsigned __int8 *)0x8134DFB },
  { 7844u, &aA_7 },
  { 7845u, &aA_8 },
  { 7846u, &aA_9 },
  { 7847u, &aA_10 },
  { 7848u, &aA2_0 },
  { 7849u, &aA2_1 },
  { 7850u, &aA_11 },
  { 7851u, &aA_12 },
  { 7852u, &aA_13 },
  { 7853u, &aA_14 },
  { 7854u, &aA_15 },
  { 7855u, &aA_16 },
  { 7856u, &aA_17 },
  { 7857u, &aA_18 },
  { 7858u, &aA2_2 },
  { 7859u, &aA2_3 },
  { 7860u, &aA_19 },
  { 7861u, &aA_20 },
  { 7862u, &aA_21 },
  { 7863u, &aA_22 },
  { 7864u, &aE_16 },
  { 7865u, &aE_17 },
  { 7866u, &aE2 },
  { 7867u, (unsigned __int8 *)0x8134141 },
  { 7868u, &aE_18 },
  { 7869u, (unsigned __int8 *)0x812B37C },
  { 7870u, &aE_19 },
  { 7871u, &aE_20 },
  { 7872u, &aE_21 },
  { 7873u, &aE_22 },
  { 7874u, &aE2_0 },
  { 7875u, &aE2_1 },
  { 7876u, &aE_23 },
  { 7877u, &aE_24 },
  { 7878u, &aE_25 },
  { 7879u, &aE_26 },
  { 7880u, &aI2 },
  { 7881u, (unsigned __int8 *)0x81346EE },
  { 7882u, &aI_11 },
  { 7883u, &aI_12 },
  { 7884u, &aO_19 },
  { 7885u, &aO_20 },
  { 7886u, &aO2 },
  { 7887u, (unsigned __int8 *)0x8134E97 },
  { 7888u, &aO_21 },
  { 7889u, &aO_22 },
  { 7890u, &aO_23 },
  { 7891u, &aO_24 },
  { 7892u, &aO2_0 },
  { 7893u, &aO2_1 },
  { 7894u, &aO_25 },
  { 7895u, &aO_26 },
  { 7896u, &aO_27 },
  { 7897u, &aO_28 },
  { 7898u, &aO9_1 },
  { 7899u, &aO9_2 },
  { 7900u, &aO9_3 },
  { 7901u, &aO9_4 },
  { 7902u, &aO92 },
  { 7903u, &aO92_0 },
  { 7904u, &aO9_5 },
  { 7905u, &aO9_6 },
  { 7906u, &aO9_7 },
  { 7907u, &aO9_8 },
  { 7908u, &aU_16 },
  { 7909u, &aU_17 },
  { 7910u, &aU2 },
  { 7911u, &aU2_0 },
  { 7912u, &aU9_1 },
  { 7913u, &aU9_2 },
  { 7914u, &aU9_3 },
  { 7915u, &aU9_4 },
  { 7916u, &aU92 },
  { 7917u, &aU92_0 },
  { 7918u, &aU9_5 },
  { 7919u, &aU9_6 },
  { 7920u, &aU9_7 },
  { 7921u, &aU9_8 },
  { 7922u, &aY_4 },
  { 7923u, &aY_5 },
  { 7924u, &aY_6 },
  { 7925u, &aY_7 },
  { 7926u, &aY2 },
  { 7927u, (unsigned __int8 *)0x813420F },
  { 7928u, &aY_8 },
  { 7929u, (unsigned __int8 *)0x8127CC0 },
  { 7936u, (unsigned __int8 *)0x812FFFB },
  { 7937u, (unsigned __int8 *)0x813049B },
  { 7938u, (unsigned __int8 *)0x81309B0 },
  { 7939u, &aHA },
  { 7940u, (unsigned __int8 *)0x81300CB },
  { 7941u, &aHa_1 },
  { 7942u, (unsigned __int8 *)0x81309B8 },
  { 7943u, &aHa_2 },
  { 7944u, (unsigned __int8 *)0x8132859 },
  { 7945u, &aHa_3 },
  { 7946u, (unsigned __int8 *)0x81309BF },
  { 7947u, &aHA_0 },
  { 7948u, (unsigned __int8 *)0x81300C7 },
  { 7949u, &aHa_4 },
  { 7950u, (unsigned __int8 *)0x81309C7 },
  { 7951u, &aHa_5 },
  { 7953u, (unsigned __int8 *)0x813048F },
  { 7961u, (unsigned __int8 *)0x813049F },
  { 7985u, (unsigned __int8 *)0x812ED75 },
  { 7993u, &aHi_1 },
  { 8001u, (unsigned __int8 *)0x812EFD8 },
  { 8009u, &aHo_1 },
  { 8017u, (unsigned __int8 *)0x8130493 },
  { 8025u, (unsigned __int8 *)0x812F3A1 },
  { 8127u, &asc_81309D0 },
  { 8128u, &asc_81309D3 },
  { 8129u, (unsigned __int8 *)0x8130A2D },
  { 8141u, &asc_81309D6 },
  { 8142u, (unsigned __int8 *)0x81306AB },
  { 8143u, &asc_81309D9 },
  { 8157u, &asc_81309DC },
  { 8158u, &asc_81309DF },
  { 8159u, &asc_81309E2 },
  { 8165u, &aRh },
  { 8172u, &aRh_0 },
  { 8173u, (unsigned __int8 *)0x8130B54 },
  { 8175u, &asc_81309EB },
  { 8190u, &asc_81309EE },
  { 8192u, &start },
  { 8193u, &delete },
  { 8194u, &start },
  { 8195u, &delete },
  { 8196u, &start },
  { 8197u, &start },
  { 8198u, &start },
  { 8199u, &start },
  { 8200u, &start },
  { 8201u, &start },
  { 8202u, &delete },
  { 8206u, &asc_81309F1 },
  { 8207u, &asc_81309F6 },
  { 8208u, (unsigned __int8 *)0x8127DCF },
  { 8209u, (unsigned __int8 *)0x8127DCF },
  { 8211u, (unsigned __int8 *)0x8127DCF },
  { 8212u, (unsigned __int8 *)0x8130FA1 },
  { 8213u, (unsigned __int8 *)0x8127DCF },
  { 8214u, &asc_81301E6 },
  { 8215u, &a2_1 },
  { 8216u, (unsigned __int8 *)0x81301A5 },
  { 8217u, (unsigned __int8 *)0x8130A20 },
  { 8218u, (unsigned __int8 *)0x8130A20 },
  { 8219u, (unsigned __int8 *)0x8130A20 },
  { 8220u, (unsigned __int8 *)0x8128449 },
  { 8221u, (unsigned __int8 *)0x8128449 },
  { 8222u, (unsigned __int8 *)0x8128449 },
  { 8223u, (unsigned __int8 *)0x8128449 },
  { 8224u, &asc_81309FE },
  { 8225u, &asc_8130A01 },
  { 8226u, &aO_29 },
  { 8228u, (unsigned __int8 *)0x813015E },
  { 8229u, &byte_812B444 },
  { 8230u, &bytes },
  { 8231u, (unsigned __int8 *)0x813015E },
  { 8232u, &a015 },
  { 8233u, &unk_8130A0D },
  { 8236u, &delete },
  { 8237u, &delete },
  { 8239u, &delete },
  { 8240u, &a000 },
  { 8242u, (unsigned __int8 *)0x8130A20 },
  { 8243u, (unsigned __int8 *)0x8130A1F },
  { 8244u, &asc_8130A1E },
  { 8245u, (unsigned __int8 *)0x81301A5 },
  { 8246u, (unsigned __int8 *)0x8130A23 },
  { 8247u, &asc_8130A22 },
  { 8248u, &aCa_0 },
  { 8249u, (unsigned __int8 *)0x8130C31 },
  { 8250u, (unsigned __int8 *)0x8130B5C },
  { 8251u, &delete },
  { 8252u, (unsigned __int8 *)0x8130B53 },
  { 8254u, &asc_8130A26 },
  { 8259u, (unsigned __int8 *)0x8127DCF },
  { 8260u, (unsigned __int8 *)0x8132419 },
  { 8264u, &asc_8130A29 },
  { 8265u, &asc_8130A2C },
  { 8304u, &a0_1 },
  { 8308u, &a4_0 },
  { 8309u, &a5_0 },
  { 8310u, &a6_0 },
  { 8311u, &a7_1 },
  { 8312u, &a8_1 },
  { 8313u, &a9_0 },
  { 8314u, &asc_8130A44 },
  { 8315u, &asc_8130A47 },
  { 8316u, &asc_8130A4A },
  { 8317u, &asc_8130A4D },
  { 8318u, &asc_8130A50 },
  { 8319u, &aN_11 },
  { 8320u, &a0_2 },
  { 8321u, (unsigned __int8 *)0x812E504 },
  { 8322u, (unsigned __int8 *)0x812E559 },
  { 8323u, (unsigned __int8 *)0x812E5B1 },
  { 8324u, (unsigned __int8 *)0x812E60D },
  { 8325u, (unsigned __int8 *)0x812E66E },
  { 8326u, (unsigned __int8 *)0x812E6DD },
  { 8327u, (unsigned __int8 *)0x812E74F },
  { 8328u, (unsigned __int8 *)0x812E7A1 },
  { 8329u, (unsigned __int8 *)0x812E7EE },
  { 8330u, &asc_8130A59 },
  { 8331u, &asc_8130A5C },
  { 8332u, &asc_8130A5F },
  { 8333u, (unsigned __int8 *)0x812839F },
  { 8334u, &byte_812757C },
  { 8355u, &aFf },
  { 8356u, &aLi_0 },
  { 8359u, &aPt },
  { 8361u, &aW_13 },
  { 8364u, &aEur },
  { 8448u, &aAC },
  { 8449u, &aAS },
  { 8451u, &aOc },
  { 8453u, &aCO },
  { 8454u, &aCU },
  { 8457u, &aOf },
  { 8458u, (unsigned __int8 *)0x812EE23 },
  { 8462u, (unsigned __int8 *)0x813392C },
  { 8463u, &aHbar },
  { 8465u, &aIm },
  { 8467u, (unsigned __int8 *)0x813391D },
  { 8470u, &aNo_0 },
  { 8471u, &aPo_2 },
  { 8472u, (unsigned __int8 *)0x812D943 },
  { 8476u, &aRe_0 },
  { 8478u, &aRx_0 },
  { 8480u, &aSm },
  { 8481u, &aTel },
  { 8482u, &aTm },
  { 8486u, &aOhm_0 },
  { 8490u, (unsigned __int8 *)0x812FFD2 },
  { 8491u, &aAng },
  { 8494u, &aEst },
  { 8500u, (unsigned __int8 *)0x8130A05 },
  { 8501u, &aAleph_0 },
  { 8502u, &aBet },
  { 8503u, &aGimel_0 },
  { 8504u, &aDalet },
  { 8531u, &a13 },
  { 8532u, &a23 },
  { 8533u, &a15 },
  { 8534u, &a25 },
  { 8535u, &a35 },
  { 8536u, &a45 },
  { 8537u, &a16 },
  { 8538u, &a56 },
  { 8539u, &a18 },
  { 8540u, &a38 },
  { 8541u, &a58 },
  { 8542u, &a78 },
  { 8543u, &a1_5 },
  { 8544u, (unsigned __int8 *)0x8132865 },
  { 8545u, (unsigned __int8 *)0x812EB72 },
  { 8546u, (unsigned __int8 *)0x8130B18 },
  { 8547u, (unsigned __int8 *)0x812D9CE },
  { 8548u, (unsigned __int8 *)0x8130BD1 },
  { 8549u, &aVi_0 },
  { 8550u, &aVii },
  { 8551u, &aViii },
  { 8552u, (unsigned __int8 *)0x812D0F8 },
  { 8553u, (unsigned __int8 *)0x8130FD7 },
  { 8554u, &aXi },
  { 8555u, &aXii },
  { 8556u, (unsigned __int8 *)0x8130BCE },
  { 8557u, &byte_8130C3E },
  { 8558u, (unsigned __int8 *)0x812C759 },
  { 8559u, (unsigned __int8 *)0x812B0D5 },
  { 8560u, (unsigned __int8 *)0x8131077 },
  { 8561u, (unsigned __int8 *)0x812E3B6 },
  { 8562u, (unsigned __int8 *)0x8130B28 },
  { 8563u, (unsigned __int8 *)0x812F25B },
  { 8564u, (unsigned __int8 *)0x8130B4C },
  { 8565u, &aVi },
  { 8566u, &aVii_0 },
  { 8567u, &aViii_0 },
  { 8568u, (unsigned __int8 *)0x812C6F2 },
  { 8569u, (unsigned __int8 *)0x813532D },
  { 8570u, (unsigned __int8 *)0x812F2AE },
  { 8571u, &aXii_0 },
  { 8572u, (unsigned __int8 *)0x813391D },
  { 8573u, (unsigned __int8 *)0x812CC3A },
  { 8574u, (unsigned __int8 *)0x813389E },
  { 8575u, (unsigned __int8 *)0x81339A8 },
  { 8576u, &a1000rcd },
  { 8577u, &a5000r },
  { 8578u, &a10000r },
  { 8592u, &asc_8130B45 },
  { 8593u, &asc_8130B48 },
  { 8594u, (unsigned __int8 *)0x812CBFD },
  { 8595u, &aV_10 },
  { 8596u, &asc_8130B4E },
  { 8597u, (unsigned __int8 *)0x812D7D1 },
  { 8598u, &asc_8130B52 },
  { 8599u, &asc_8130B56 },
  { 8600u, &asc_8130B5A },
  { 8601u, &asc_8130B5E },
  { 8616u, &aUd },
  { 8629u, &aRet },
  { 8640u, &aV_11 },
  { 8656u, &asc_8130B6D },
  { 8657u, &asc_8130B70 },
  { 8658u, &unk_812CCAA },
  { 8659u, &aVv },
  { 8660u, &unk_812CCA9 },
  { 8704u, &aFa_0 },
  { 8706u, &aPartial },
  { 8707u, (unsigned __int8 *)0x812D9A2 },
  { 8709u, &asc_8130B83 },
  { 8710u, &aDelta },
  { 8711u, &aNabla_0 },
  { 8712u, (unsigned __int8 *)0x8130B8D },
  { 8713u, &asc_8130B8C },
  { 8714u, (unsigned __int8 *)0x8130B8D },
  { 8715u, (unsigned __int8 *)0x8130B91 },
  { 8716u, &asc_8130B90 },
  { 8717u, (unsigned __int8 *)0x8130B91 },
  { 8718u, &aQed },
  { 8719u, &unk_8130B99 },
  { 8721u, &aSum },
  { 8722u, (unsigned __int8 *)0x8127DCE },
  { 8723u, &asc_8130BA6 },
  { 8724u, &asc_8130BAA },
  { 8725u, (unsigned __int8 *)0x8132419 },
  { 8726u, (unsigned __int8 *)0x8127DCE },
  { 8727u, (unsigned __int8 *)0x8130031 },
  { 8728u, &aOb },
  { 8729u, (unsigned __int8 *)0x812FDD7 },
  { 8730u, &aSqrt },
  { 8731u, &aRoot3 },
  { 8732u, &aRoot4 },
  { 8733u, &a0_3 },
  { 8734u, &aInfty },
  { 8735u, &asc_8130BCD },
  { 8736u, &aV_12 },
  { 8741u, (unsigned __int8 *)0x8130BD5 },
  { 8742u, &aPp },
  { 8743u, (unsigned __int8 *)0x812D2F8 },
  { 8744u, (unsigned __int8 *)0x812D094 },
  { 8745u, &aU_18 },
  { 8746u, &aU_19 },
  { 8747u, &aInt },
  { 8748u, &aDi_1 },
  { 8750u, &aIo_0 },
  { 8756u, (unsigned __int8 *)0x813015E },
  { 8757u, &delete },
  { 8758u, &delete },
  { 8759u, &delete },
  { 8764u, &a1_6 },
  { 8766u, &aCg },
  { 8771u, &asc_8130BEF },
  { 8773u, &asc_8130BF2 },
  { 8776u, (unsigned __int8 *)0x8130BF7 },
  { 8777u, &asc_8130BF5 },
  { 8780u, &asc_8130BFA },
  { 8787u, &aHi_2 },
  { 8788u, &delete },
  { 8789u, (unsigned __int8 *)0x8130C01 },
  { 8800u, &asc_8130C00 },
  { 8801u, (unsigned __int8 *)0x8130C05 },
  { 8802u, &a3_2 },
  { 8804u, &asc_8130C08 },
  { 8805u, &asc_8130C0B },
  { 8806u, &aLe_0 },
  { 8807u, &aGe_1 },
  { 8808u, &aLtNotEq },
  { 8809u, &aGtNotEq },
  { 8810u, (unsigned __int8 *)0x8130D06 },
  { 8811u, (unsigned __int8 *)0x8130D0A },
  { 8814u, &asc_8130C30 },
  { 8815u, (unsigned __int8 *)0x8130B5B },
  { 8822u, &asc_8130C33 },
  { 8823u, &asc_8130C37 },
  { 8834u, &unk_8130C3D },
  { 8835u, (unsigned __int8 *)0x8130C42 },
  { 8836u, &unk_8130C3B },
  { 8837u, &aC_7 },
  { 8838u, &asc_8130C45 },
  { 8839u, &asc_8130C48 },
  { 8853u, &asc_8130C4B },
  { 8854u, &asc_8130C4F },
  { 8855u, &asc_8130C53 },
  { 8856u, &asc_8130C57 },
  { 8857u, &asc_8130C5B },
  { 8858u, &aO_30 },
  { 8859u, &asc_8130C63 },
  { 8860u, &asc_8130C67 },
  { 8861u, &asc_8130C4F },
  { 8862u, &asc_8130C6B },
  { 8863u, &asc_8130C6F },
  { 8864u, &asc_8130C73 },
  { 8865u, &asc_8130C77 },
  { 8869u, &aT_11 },
  { 8871u, &aModels_0 },
  { 8872u, &aTrue },
  { 8873u, &aForces },
  { 8876u, &aProves },
  { 8877u, &unk_8130C97 },
  { 8878u, &aForces_0 },
  { 8882u, &aNormalSubgroup },
  { 8883u, &aContainsAsNorm },
  { 8884u, &aNormalSubgroup_0 },
  { 8885u, &aContainsAsNorm_0 },
  { 8888u, &aMultimap },
  { 8890u, &aIntercalate },
  { 8891u, &aXor },
  { 8892u, &aNand },
  { 8901u, &aDot },
  { 8918u, (unsigned __int8 *)0x81307C7 },
  { 8919u, &asc_8130D02 },
  { 8920u, &asc_8130D05 },
  { 8921u, &asc_8130D09 },
  { 8942u, &delete },
  { 8943u, &a3_3 },
  { 8962u, &aEh },
  { 8967u, &asc_81301F7 },
  { 8968u, &a7_2 },
  { 8969u, &a7_3 },
  { 8970u, &a7_4 },
  { 8971u, &a7_5 },
  { 8976u, &aNi_1 },
  { 8978u, &aA_23 },
  { 8981u, (unsigned __int8 *)0x812D05C },
  { 8984u, (unsigned __int8 *)0x812E574 },
  { 8992u, &aIu },
  { 8993u, &aIl },
  { 8994u, &delete },
  { 8995u, &delete },
  { 8996u, &asc_8130D2B },
  { 8999u, &asc_812756E },
  { 9001u, &asc_8130D2F },
  { 9002u, (unsigned __int8 *)0x8130B57 },
  { 9251u, &aVs },
  { 9280u, &a1h },
  { 9281u, &a3h },
  { 9282u, &a2h },
  { 9283u, &a4h },
  { 9286u, &a1j },
  { 9287u, &a2j_0 },
  { 9288u, &a3j },
  { 9289u, &a4j },
  { 9312u, (unsigned __int8 *)0x8130D53 },
  { 9313u, (unsigned __int8 *)0x8130D58 },
  { 9314u, (unsigned __int8 *)0x8130D5D },
  { 9315u, (unsigned __int8 *)0x8130D62 },
  { 9316u, (unsigned __int8 *)0x8130D67 },
  { 9317u, (unsigned __int8 *)0x8130D6C },
  { 9318u, (unsigned __int8 *)0x8130D71 },
  { 9319u, (unsigned __int8 *)0x8130D76 },
  { 9320u, (unsigned __int8 *)0x8130D7B },
  { 9321u, &a10O },
  { 9322u, &a11O },
  { 9323u, &a12O },
  { 9324u, &a13O },
  { 9325u, &a14O },
  { 9326u, &a15O },
  { 9327u, &a16O },
  { 9328u, &a17O },
  { 9329u, &a18O },
  { 9330u, &a19O },
  { 9331u, &a20O },
  { 9332u, &a1_7 },
  { 9333u, &a2_2 },
  { 9334u, &a3_4 },
  { 9335u, &a4_1 },
  { 9336u, &a5_1 },
  { 9337u, &a6_1 },
  { 9338u, &a7_6 },
  { 9339u, &a8_2 },
  { 9340u, &a9_1 },
  { 9341u, &a10_0 },
  { 9342u, &a11 },
  { 9343u, &a12_0 },
  { 9344u, &a13_0 },
  { 9345u, &a14_0 },
  { 9346u, &a15_0 },
  { 9347u, &a16_0 },
  { 9348u, &a17 },
  { 9349u, &a18_0 },
  { 9350u, &a19 },
  { 9351u, &a20_0 },
  { 9352u, (unsigned __int8 *)0x8130DE4 },
  { 9353u, (unsigned __int8 *)0x8130DE8 },
  { 9354u, (unsigned __int8 *)0x8130DEC },
  { 9355u, (unsigned __int8 *)0x8130DF0 },
  { 9356u, (unsigned __int8 *)0x8130DF4 },
  { 9357u, (unsigned __int8 *)0x8130DF8 },
  { 9358u, (unsigned __int8 *)0x8130DFC },
  { 9359u, (unsigned __int8 *)0x8130E00 },
  { 9360u, (unsigned __int8 *)0x8130E04 },
  { 9361u, &a10_1 },
  { 9362u, &a11_0 },
  { 9363u, &a12_1 },
  { 9364u, &a13_1 },
  { 9365u, &a14_1 },
  { 9366u, &a15_1 },
  { 9367u, &a16_1 },
  { 9368u, &a17_0 },
  { 9369u, &a18_1 },
  { 9370u, &a19_0 },
  { 9371u, &a20_1 },
  { 9372u, &aA_24 },
  { 9373u, &aB_10 },
  { 9374u, &aC_0 },
  { 9375u, &aD_15 },
  { 9376u, &aE_27 },
  { 9377u, &asc_8130E1B },
  { 9378u, &aG_9 },
  { 9379u, &asc_8130E23 },
  { 9380u, &aI_13 },
  { 9381u, &aJ_4 },
  { 9382u, &aK_9 },
  { 9383u, &asc_8130E33 },
  { 9384u, &aM_7 },
  { 9385u, &aN_12 },
  { 9386u, &aO_30 },
  { 9387u, &aP_6 },
  { 9388u, &aQ_2 },
  { 9389u, &aR_13 },
  { 9390u, (unsigned __int8 *)0x81316AD },
  { 9391u, &aT_12 },
  { 9392u, &aU_20 },
  { 9393u, &aV_13 },
  { 9394u, &aW_14 },
  { 9395u, &asc_8130C53 },
  { 9396u, &aY_9 },
  { 9397u, &aZ_9 },
  { 9398u, &aAO },
  { 9399u, &aBO },
  { 9400u, &aCO_0 },
  { 9401u, &aDO },
  { 9402u, &aEO },
  { 9403u, &aFO },
  { 9404u, &aGO },
  { 9405u, &aHO },
  { 9406u, &aIO },
  { 9407u, &aJO },
  { 9408u, &aKO },
  { 9409u, &aLO },
  { 9410u, &aMO },
  { 9411u, &aNO },
  { 9412u, &aOO },
  { 9413u, &aPO },
  { 9414u, &aQO },
  { 9415u, &aRO },
  { 9416u, &aSO },
  { 9417u, &aTO },
  { 9418u, &aUO },
  { 9419u, &aVO },
  { 9420u, &aWO },
  { 9421u, &aXO },
  { 9422u, &aYO },
  { 9423u, &aZO },
  { 9424u, &aAO_0 },
  { 9425u, &aBO_0 },
  { 9426u, &aCO_1 },
  { 9427u, &aDO_0 },
  { 9428u, &aEO_0 },
  { 9429u, &aFO_0 },
  { 9430u, &aGO_0 },
  { 9431u, &aHO_0 },
  { 9432u, &aIO_0 },
  { 9433u, &aJO_0 },
  { 9434u, &aKO_0 },
  { 9435u, &aLO_0 },
  { 9436u, &aMO_0 },
  { 9437u, &aNO_0 },
  { 9438u, &aOO_0 },
  { 9439u, &aPO_0 },
  { 9440u, &aQO_0 },
  { 9441u, &aRO_0 },
  { 9442u, &aSO_0 },
  { 9443u, &aTO_0 },
  { 9444u, &aUO_0 },
  { 9445u, &aVO_0 },
  { 9446u, &aWO_0 },
  { 9447u, &aXO_0 },
  { 9448u, &aYO_0 },
  { 9449u, &aZO_0 },
  { 9450u, (unsigned __int8 *)0x8130D4E },
  { 9472u, (unsigned __int8 *)0x8127DCF },
  { 9473u, (unsigned __int8 *)0x8130C01 },
  { 9474u, (unsigned __int8 *)0x813282F },
  { 9475u, (unsigned __int8 *)0x813282F },
  { 9476u, (unsigned __int8 *)0x8127DCF },
  { 9477u, (unsigned __int8 *)0x8130C01 },
  { 9478u, (unsigned __int8 *)0x813282F },
  { 9479u, (unsigned __int8 *)0x813282F },
  { 9480u, (unsigned __int8 *)0x8127DCF },
  { 9481u, (unsigned __int8 *)0x8130C01 },
  { 9482u, (unsigned __int8 *)0x813282F },
  { 9483u, (unsigned __int8 *)0x813282F },
  { 9484u, (unsigned __int8 *)0x8130362 },
  { 9485u, (unsigned __int8 *)0x8130362 },
  { 9486u, (unsigned __int8 *)0x8130362 },
  { 9487u, (unsigned __int8 *)0x8130362 },
  { 9488u, (unsigned __int8 *)0x8130362 },
  { 9489u, (unsigned __int8 *)0x8130362 },
  { 9490u, (unsigned __int8 *)0x8130362 },
  { 9491u, (unsigned __int8 *)0x8130362 },
  { 9492u, (unsigned __int8 *)0x8130362 },
  { 9493u, (unsigned __int8 *)0x8130362 },
  { 9494u, (unsigned __int8 *)0x8130362 },
  { 9495u, (unsigned __int8 *)0x8130362 },
  { 9496u, (unsigned __int8 *)0x8130362 },
  { 9497u, (unsigned __int8 *)0x8130362 },
  { 9498u, (unsigned __int8 *)0x8130362 },
  { 9499u, (unsigned __int8 *)0x8130362 },
  { 9500u, (unsigned __int8 *)0x8130362 },
  { 9501u, (unsigned __int8 *)0x8130362 },
  { 9502u, (unsigned __int8 *)0x8130362 },
  { 9503u, (unsigned __int8 *)0x8130362 },
  { 9504u, (unsigned __int8 *)0x8130362 },
  { 9505u, (unsigned __int8 *)0x8130362 },
  { 9506u, (unsigned __int8 *)0x8130362 },
  { 9507u, (unsigned __int8 *)0x8130362 },
  { 9508u, (unsigned __int8 *)0x8130362 },
  { 9509u, (unsigned __int8 *)0x8130362 },
  { 9510u, (unsigned __int8 *)0x8130362 },
  { 9511u, (unsigned __int8 *)0x8130362 },
  { 9512u, (unsigned __int8 *)0x8130362 },
  { 9513u, (unsigned __int8 *)0x8130362 },
  { 9514u, (unsigned __int8 *)0x8130362 },
  { 9515u, (unsigned __int8 *)0x8130362 },
  { 9516u, (unsigned __int8 *)0x8130362 },
  { 9517u, (unsigned __int8 *)0x8130362 },
  { 9518u, (unsigned __int8 *)0x8130362 },
  { 9519u, (unsigned __int8 *)0x8130362 },
  { 9520u, (unsigned __int8 *)0x8130362 },
  { 9521u, (unsigned __int8 *)0x8130362 },
  { 9522u, (unsigned __int8 *)0x8130362 },
  { 9523u, (unsigned __int8 *)0x8130362 },
  { 9524u, (unsigned __int8 *)0x8130362 },
  { 9525u, (unsigned __int8 *)0x8130362 },
  { 9526u, (unsigned __int8 *)0x8130362 },
  { 9527u, (unsigned __int8 *)0x8130362 },
  { 9528u, (unsigned __int8 *)0x8130362 },
  { 9529u, (unsigned __int8 *)0x8130362 },
  { 9530u, (unsigned __int8 *)0x8130362 },
  { 9531u, (unsigned __int8 *)0x8130362 },
  { 9532u, (unsigned __int8 *)0x8130362 },
  { 9533u, (unsigned __int8 *)0x8130362 },
  { 9534u, (unsigned __int8 *)0x8130362 },
  { 9535u, (unsigned __int8 *)0x8130362 },
  { 9536u, (unsigned __int8 *)0x8130362 },
  { 9537u, (unsigned __int8 *)0x8130362 },
  { 9538u, (unsigned __int8 *)0x8130362 },
  { 9539u, (unsigned __int8 *)0x8130362 },
  { 9540u, (unsigned __int8 *)0x8130362 },
  { 9541u, (unsigned __int8 *)0x8130362 },
  { 9542u, (unsigned __int8 *)0x8130362 },
  { 9543u, (unsigned __int8 *)0x8130362 },
  { 9544u, (unsigned __int8 *)0x8130362 },
  { 9545u, (unsigned __int8 *)0x8130362 },
  { 9546u, (unsigned __int8 *)0x8130362 },
  { 9547u, (unsigned __int8 *)0x8130362 },
  { 9548u, (unsigned __int8 *)0x8130362 },
  { 9549u, (unsigned __int8 *)0x8130362 },
  { 9550u, (unsigned __int8 *)0x8130362 },
  { 9551u, (unsigned __int8 *)0x8130362 },
  { 9552u, (unsigned __int8 *)0x8130362 },
  { 9553u, (unsigned __int8 *)0x8130362 },
  { 9554u, (unsigned __int8 *)0x8130362 },
  { 9555u, (unsigned __int8 *)0x8130362 },
  { 9556u, (unsigned __int8 *)0x8130362 },
  { 9557u, (unsigned __int8 *)0x8130362 },
  { 9558u, (unsigned __int8 *)0x8130362 },
  { 9559u, (unsigned __int8 *)0x8130362 },
  { 9560u, (unsigned __int8 *)0x8130362 },
  { 9561u, (unsigned __int8 *)0x8130362 },
  { 9562u, (unsigned __int8 *)0x8130362 },
  { 9563u, (unsigned __int8 *)0x8130362 },
  { 9564u, (unsigned __int8 *)0x8130362 },
  { 9565u, (unsigned __int8 *)0x8130362 },
  { 9566u, (unsigned __int8 *)0x8130362 },
  { 9567u, (unsigned __int8 *)0x8130362 },
  { 9568u, (unsigned __int8 *)0x8130362 },
  { 9569u, (unsigned __int8 *)0x8130362 },
  { 9570u, (unsigned __int8 *)0x8130362 },
  { 9571u, (unsigned __int8 *)0x8130362 },
  { 9572u, (unsigned __int8 *)0x8130362 },
  { 9573u, (unsigned __int8 *)0x8130362 },
  { 9574u, (unsigned __int8 *)0x8130362 },
  { 9575u, (unsigned __int8 *)0x8130362 },
  { 9576u, (unsigned __int8 *)0x8130362 },
  { 9577u, (unsigned __int8 *)0x8130362 },
  { 9578u, (unsigned __int8 *)0x8130362 },
  { 9579u, (unsigned __int8 *)0x8130362 },
  { 9580u, (unsigned __int8 *)0x8130362 },
  { 9585u, (unsigned __int8 *)0x8132419 },
  { 9586u, &asc_8130F33 },
  { 9600u, &aTb },
  { 9604u, &aLb },
  { 9608u, &aFb },
  { 9612u, &aLb_0 },
  { 9616u, (unsigned __int8 *)0x812D8CC },
  { 9617u, &aS_22 },
  { 9618u, &delete },
  { 9619u, &aS_23 },
  { 9632u, &aFs },
  { 9633u, &aOs_0 },
  { 9634u, (unsigned __int8 *)0x812D8C0 },
  { 9635u, &aRr },
  { 9636u, &aRf },
  { 9637u, (unsigned __int8 *)0x812DB73 },
  { 9638u, &aRh_1 },
  { 9639u, &aRz },
  { 9640u, (unsigned __int8 *)0x812DDFA },
  { 9641u, &aRx_1 },
  { 9642u, &aSb_0 },
  { 9644u, &aSr },
  { 9645u, &aOr },
  { 9650u, (unsigned __int8 *)0x8130B49 },
  { 9651u, &aUt },
  { 9654u, &asc_8130F66 },
  { 9655u, &aTr },
  { 9658u, &asc_8130F66 },
  { 9660u, (unsigned __int8 *)0x8130B4C },
  { 9661u, &aDt },
  { 9664u, &asc_8130F6F },
  { 9665u, &aTl },
  { 9668u, &asc_8130F6F },
  { 9670u, &aDb },
  { 9671u, &aDw },
  { 9674u, &aLz },
  { 9675u, (unsigned __int8 *)0x81339A7 },
  { 9678u, &a0o },
  { 9679u, &a0m_0 },
  { 9680u, &a0l },
  { 9681u, (unsigned __int8 *)0x8130B42 },
  { 9688u, &aSn_0 },
  { 9689u, &aIc },
  { 9698u, &aFd },
  { 9699u, &aBd },
  { 9711u, &aCi_0 },
  { 9733u, &a2_3 },
  { 9734u, &a1_8 },
  { 9742u, &aTel },
  { 9743u, &aTel_0 },
  { 9756u, &asc_8130FA0 },
  { 9758u, (unsigned __int8 *)0x812CBFC },
  { 9761u, &aCaution },
  { 9767u, &aXp },
  { 9785u, &delete },
  { 9786u, &delete },
  { 9787u, (unsigned __int8 *)0x8130B8D },
  { 9788u, &aSu_1 },
  { 9792u, &asc_81306F9 },
  { 9794u, (unsigned __int8 *)0x8131158 },
  { 9824u, &aCs },
  { 9825u, &aCh },
  { 9826u, &aCd_0 },
  { 9827u, &aCc },
  { 9828u, &aCs_0 },
  { 9829u, &aCh_0 },
  { 9830u, &aCd_1 },
  { 9831u, &aCc_0 },
  { 9833u, &aMd },
  { 9834u, &aM8 },
  { 9835u, &aM2 },
  { 9836u, &aM16 },
  { 9837u, (unsigned __int8 *)0x8130F76 },
  { 9838u, &aMx },
  { 9839u, &prompt },
  { 10003u, (unsigned __int8 *)0x8130FD7 },
  { 10007u, (unsigned __int8 *)0x8130FD7 },
  { 10016u, &asc_8130FD6 },
  { 12288u, &start },
  { 12289u, &asc_8130FD9 },
  { 12290u, &asc_8130FDC },
  { 12291u, &asc_8130FDF },
  { 12292u, &aJis },
  { 12293u, &asc_8130FE6 },
  { 12294u, &asc_8130FE9 },
  { 12295u, &a0_4 },
  { 12298u, &asc_8130FEF },
  { 12299u, &asc_8130FF2 },
  { 12300u, &asc_8130FF5 },
  { 12301u, (unsigned __int8 *)0x813086E },
  { 12302u, &asc_8130FF8 },
  { 12303u, &asc_8130FFB },
  { 12304u, &asc_8130FFE },
  { 12305u, &asc_8131001 },
  { 12306u, &aT_13 },
  { 12307u, &asc_8131007 },
  { 12308u, (unsigned __int8 *)0x8130898 },
  { 12309u, &asc_813100A },
  { 12310u, &aI_14 },
  { 12311u, &aI_15 },
  { 12314u, &asc_8131013 },
  { 12315u, &asc_8131016 },
  { 12316u, (unsigned __int8 *)0x81306E7 },
  { 12320u, &aT_13 },
  { 12351u, &start },
  { 12353u, &aA5 },
  { 12354u, &aA5_0 },
  { 12355u, &aI5 },
  { 12356u, &aI5_0 },
  { 12357u, &aU5 },
  { 12358u, &aU5_0 },
  { 12359u, &aE5 },
  { 12360u, (unsigned __int8 *)0x81324CC },
  { 12361u, &aO5 },
  { 12362u, &aO5_0 },
  { 12363u, &aKa },
  { 12364u, (unsigned __int8 *)0x812F1A2 },
  { 12365u, (unsigned __int8 *)0x81340D0 },
  { 12366u, (unsigned __int8 *)0x8132699 },
  { 12367u, &aKu },
  { 12368u, &aGu },
  { 12369u, (unsigned __int8 *)0x81325C5 },
  { 12370u, (unsigned __int8 *)0x812B262 },
  { 12371u, &aKo },
  { 12372u, (unsigned __int8 *)0x8133BDE },
  { 12373u, (unsigned __int8 *)0x81303DA },
  { 12374u, &aZa },
  { 12375u, (unsigned __int8 *)0x812F1B3 },
  { 12376u, &aZi },
  { 12377u, (unsigned __int8 *)0x81303D2 },
  { 12378u, &aZu },
  { 12379u, (unsigned __int8 *)0x81303CE },
  { 12380u, &unk_8127BDD },
  { 12381u, (unsigned __int8 *)0x81303E5 },
  { 12382u, &aZo },
  { 12383u, (unsigned __int8 *)0x812EDF4 },
  { 12384u, (unsigned __int8 *)0x812F19A },
  { 12385u, &aTi },
  { 12386u, &aDi },
  { 12387u, &aTu_1 },
  { 12388u, &aTu },
  { 12389u, (unsigned __int8 *)0x81321E0 },
  { 12390u, &unk_812B3D8 },
  { 12391u, (unsigned __int8 *)0x812C731 },
  { 12392u, (unsigned __int8 *)0x8135215 },
  { 12393u, (unsigned __int8 *)0x8133557 },
  { 12394u, (unsigned __int8 *)0x8133E4A },
  { 12395u, &aNi },
  { 12396u, (unsigned __int8 *)0x812F245 },
  { 12397u, (unsigned __int8 *)0x812FEFB },
  { 12398u, &byte_812785C },
  { 12399u, (unsigned __int8 *)0x813049B },
  { 12400u, (unsigned __int8 *)0x8131F4D },
  { 12401u, (unsigned __int8 *)0x812EEC1 },
  { 12402u, (unsigned __int8 *)0x812ED75 },
  { 12403u, &aBi },
  { 12404u, (unsigned __int8 *)0x812F260 },
  { 12405u, (unsigned __int8 *)0x8130493 },
  { 12406u, &aBu },
  { 12407u, &aPu_0 },
  { 12408u, (unsigned __int8 *)0x813048F },
  { 12409u, (unsigned __int8 *)0x812FA58 },
  { 12410u, (unsigned __int8 *)0x8128511 },
  { 12411u, (unsigned __int8 *)0x812EFD8 },
  { 12412u, &aBo },
  { 12413u, &aPo_1 },
  { 12414u, (unsigned __int8 *)0x812C3AC },
  { 12415u, (unsigned __int8 *)0x812FCDC },
  { 12416u, (unsigned __int8 *)0x812F240 },
  { 12417u, &unk_81275A9 },
  { 12418u, (unsigned __int8 *)0x8131494 },
  { 12419u, &aYa_1 },
  { 12420u, &aYa_0 },
  { 12421u, &aYu_1 },
  { 12422u, &aYu_0 },
  { 12423u, &aYo_0 },
  { 12424u, &aYo },
  { 12425u, (unsigned __int8 *)0x812FB3E },
  { 12426u, (unsigned __int8 *)0x812FF30 },
  { 12427u, (unsigned __int8 *)0x812EAE6 },
  { 12428u, (unsigned __int8 *)0x812F7AB },
  { 12429u, (unsigned __int8 *)0x812F93B },
  { 12430u, &aWa_0 },
  { 12431u, &aWa },
  { 12432u, &aWi },
  { 12433u, &aWe },
  { 12434u, &aWo },
  { 12435u, (unsigned __int8 *)0x812E7E4 },
  { 12436u, &aVu },
  { 12443u, &a5_2 },
  { 12444u, &a05 },
  { 12445u, &a5_3 },
  { 12446u, &a5_4 },
  { 12449u, &aA6 },
  { 12450u, &aA6_0 },
  { 12451u, &aI6 },
  { 12452u, &aI6_0 },
  { 12453u, &aU6 },
  { 12454u, &aU6_0 },
  { 12455u, &aE6 },
  { 12456u, &aE6_0 },
  { 12457u, &aO6 },
  { 12458u, &aO6_0 },
  { 12459u, &aKa_0 },
  { 12460u, &aGa },
  { 12461u, &aKi },
  { 12462u, &aGi },
  { 12463u, &aKu_0 },
  { 12464u, &aGu_0 },
  { 12465u, &aKe_0 },
  { 12466u, &aGe_0 },
  { 12467u, &aKo_0 },
  { 12468u, &aGo },
  { 12469u, (unsigned __int8 *)0x8130607 },
  { 12470u, &aZa_0 },
  { 12471u, (unsigned __int8 *)0x813060F },
  { 12472u, &aZi_0 },
  { 12473u, (unsigned __int8 *)0x813060B },
  { 12474u, &aZu_0 },
  { 12475u, &aSe_2 },
  { 12476u, &aZe_0 },
  { 12477u, (unsigned __int8 *)0x813061A },
  { 12478u, &aZo_0 },
  { 12479u, &aTa },
  { 12480u, &aDa },
  { 12481u, &aTi_0 },
  { 12482u, &aDi_0 },
  { 12483u, &aTu_2 },
  { 12484u, &aTu_0 },
  { 12485u, &aDu },
  { 12486u, &aTe_0 },
  { 12487u, &aDe_0 },
  { 12488u, &aTo },
  { 12489u, &aDo },
  { 12490u, &aNa },
  { 12491u, &aNi_0 },
  { 12492u, &aNu },
  { 12493u, &aNe },
  { 12494u, (unsigned __int8 *)0x8127628 },
  { 12495u, &aHa },
  { 12496u, &aBa },
  { 12497u, &aPa },
  { 12498u, &aHi },
  { 12499u, &aBi_0 },
  { 12500u, (unsigned __int8 *)0x812F1AD },
  { 12501u, (unsigned __int8 *)0x812F337 },
  { 12502u, &aBu_0 },
  { 12503u, &aPu },
  { 12504u, &aHe },
  { 12505u, &aBe },
  { 12506u, &aPe },
  { 12507u, &aHo },
  { 12508u, &aBo_0 },
  { 12509u, &aPo_0 },
  { 12510u, &aMa },
  { 12511u, &aMi },
  { 12512u, &aMu },
  { 12513u, &aMe_0 },
  { 12514u, &aMo },
  { 12515u, &aYa },
  { 12516u, (unsigned __int8 *)0x813063D },
  { 12517u, &aYu },
  { 12518u, &aYu_2 },
  { 12519u, &aYo_1 },
  { 12520u, &aYo_2 },
  { 12521u, &aRa },
  { 12522u, &aRi },
  { 12523u, &aRu },
  { 12524u, &aRe_0 },
  { 12525u, &aRo },
  { 12526u, &aWa_1 },
  { 12527u, (unsigned __int8 *)0x81305D8 },
  { 12528u, (unsigned __int8 *)0x8130500 },
  { 12529u, (unsigned __int8 *)0x81304FC },
  { 12530u, (unsigned __int8 *)0x8130603 },
  { 12531u, (unsigned __int8 *)0x812E81D },
  { 12532u, &aVu_0 },
  { 12533u, &aKa_1 },
  { 12534u, (unsigned __int8 *)0x812C80C },
  { 12535u, &aVa_0 },
  { 12536u, &aVi_1 },
  { 12537u, &aVe_0 },
  { 12538u, &aVo_0 },
  { 12539u, &a6_2 },
  { 12540u, (unsigned __int8 *)0x812EBB4 },
  { 12541u, &a6_3 },
  { 12542u, &a6_4 },
  { 12549u, (unsigned __int8 *)0x8134C03 },
  { 12550u, &aP4 },
  { 12551u, (unsigned __int8 *)0x8134D67 },
  { 12552u, (unsigned __int8 *)0x8134D4F },
  { 12553u, (unsigned __int8 *)0x8134C3A },
  { 12554u, (unsigned __int8 *)0x8134EC3 },
  { 12555u, (unsigned __int8 *)0x8134E63 },
  { 12556u, (unsigned __int8 *)0x8134011 },
  { 12557u, &aG4 },
  { 12558u, (unsigned __int8 *)0x81342A2 },
  { 12559u, (unsigned __int8 *)0x81310DD },
  { 12560u, &aJ4 },
  { 12561u, &aQ4 },
  { 12562u, &aX4 },
  { 12563u, &aZh_0 },
  { 12564u, (unsigned __int8 *)0x81313AA },
  { 12565u, (unsigned __int8 *)0x8131EB1 },
  { 12566u, &aR4 },
  { 12567u, &aZ4 },
  { 12568u, &aC4 },
  { 12569u, &aS4 },
  { 12570u, (unsigned __int8 *)0x8134E0B },
  { 12571u, (unsigned __int8 *)0x8134EA7 },
  { 12572u, (unsigned __int8 *)0x8134159 },
  { 12573u, &aEh4 },
  { 12574u, &aAi },
  { 12575u, &aEi },
  { 12576u, (unsigned __int8 *)0x812F02A },
  { 12577u, (unsigned __int8 *)0x812F2E0 },
  { 12578u, (unsigned __int8 *)0x812B139 },
  { 12579u, (unsigned __int8 *)0x81333B5 },
  { 12580u, &aAn },
  { 12581u, &aEn },
  { 12582u, (unsigned __int8 *)0x8129E7C },
  { 12583u, (unsigned __int8 *)0x81346FC },
  { 12584u, &aU4 },
  { 12585u, &aIu_0 },
  { 12586u, (unsigned __int8 *)0x8131AEA },
  { 12587u, &aNg },
  { 12588u, (unsigned __int8 *)0x812C1F8 },
  { 12828u, &aJu_0 },
  { 12832u, &a1c },
  { 12833u, &a2c },
  { 12834u, &a3c },
  { 12835u, &a4c },
  { 12836u, &a5c },
  { 12837u, &a6c },
  { 12838u, &a7c },
  { 12839u, &a8c },
  { 12840u, &a9c },
  { 12841u, &a10c },
  { 12927u, &aKsc },
  { 13250u, (unsigned __int8 *)0x8134B4B },
  { 13272u, &aPm },
  { 64256u, (unsigned __int8 *)0x8129A7C },
  { 64257u, (unsigned __int8 *)0x8131121 },
  { 64258u, (unsigned __int8 *)0x8131125 },
  { 64259u, &aFfi },
  { 64260u, &aFfl },
  { 64261u, &aSt },
  { 64262u, (unsigned __int8 *)0x812FAAA },
  { 65149u, &a3_5 },
  { 65154u, &aAm_0 },
  { 65156u, &aAh_0 },
  { 65160u, &aAh_1 },
  { 65165u, &aA_25 },
  { 65166u, &aA_26 },
  { 65167u, &aB_11 },
  { 65168u, &aB_12 },
  { 65169u, &aB_13 },
  { 65170u, &aB_14 },
  { 65171u, &aTm_0 },
  { 65172u, &aTm_1 },
  { 65173u, &aT_14 },
  { 65174u, &aT_15 },
  { 65175u, &aT_16 },
  { 65176u, &aT_17 },
  { 65177u, &aTk_0 },
  { 65178u, &aTk_1 },
  { 65179u, &aTk_2 },
  { 65180u, &aTk_3 },
  { 65181u, &aG_10 },
  { 65182u, &aG_11 },
  { 65183u, &aG_12 },
  { 65184u, &aG_13 },
  { 65185u, &aHk },
  { 65186u, &aHk_0 },
  { 65187u, &aHk_1 },
  { 65188u, &aHk_2 },
  { 65189u, &asc_813119B },
  { 65190u, &asc_813119F },
  { 65191u, &asc_81311A3 },
  { 65192u, &asc_81311A7 },
  { 65193u, &aD_16 },
  { 65194u, &aD_17 },
  { 65195u, &aDk_0 },
  { 65196u, &aDk_1 },
  { 65197u, &aR_14 },
  { 65198u, &aR_15 },
  { 65199u, &aZ_10 },
  { 65200u, &aZ_11 },
  { 65201u, &aS_24 },
  { 65202u, &aS_25 },
  { 65203u, &aS_26 },
  { 65204u, &aS_27 },
  { 65205u, &aSn_1 },
  { 65206u, &aSn_2 },
  { 65207u, &aSn_3 },
  { 65208u, &aSn_4 },
  { 65209u, &aC_8 },
  { 65210u, &aC_9 },
  { 65211u, &aC_10 },
  { 65212u, &aC_11 },
  { 65213u, &aDd },
  { 65214u, &aDd_0 },
  { 65215u, &aDd_1 },
  { 65216u, &aDd_2 },
  { 65217u, &aTj_1 },
  { 65218u, &aTj_2 },
  { 65219u, &aTj_3 },
  { 65220u, &aTj_4 },
  { 65221u, &aZh_2 },
  { 65222u, &aZh_3 },
  { 65223u, &aZh_4 },
  { 65224u, &aZh_5 },
  { 65225u, &aE_28 },
  { 65226u, &aE_29 },
  { 65227u, &aE_30 },
  { 65228u, &aE_31 },
  { 65229u, &aI_16 },
  { 65230u, &aI_17 },
  { 65231u, &aI_18 },
  { 65232u, &aI_19 },
  { 65233u, &asc_813124B },
  { 65234u, &asc_813124F },
  { 65235u, &asc_8131253 },
  { 65236u, &asc_8131257 },
  { 65237u, &aQ_3 },
  { 65238u, &aQ_4 },
  { 65239u, &aQ_5 },
  { 65240u, &aQ_6 },
  { 65241u, &aK_10 },
  { 65242u, &aK_11 },
  { 65243u, &aK_12 },
  { 65244u, &aK_13 },
  { 65245u, &asc_813127B },
  { 65246u, &asc_813127F },
  { 65247u, &asc_8131283 },
  { 65248u, &asc_8131287 },
  { 65249u, &aM_8 },
  { 65250u, &aM_9 },
  { 65251u, &aM_10 },
  { 65252u, &aM_11 },
  { 65253u, &aN_13 },
  { 65254u, &aN_14 },
  { 65255u, &aN_15 },
  { 65256u, &aN_16 },
  { 65257u, &asc_81312AB },
  { 65258u, &asc_81312AF },
  { 65259u, &asc_81312B3 },
  { 65260u, &asc_81312B7 },
  { 65261u, &aW_15 },
  { 65262u, &aW_16 },
  { 65263u, &aJ_5 },
  { 65264u, &aJ_6 },
  { 65265u, &aY_10 },
  { 65266u, &aY_11 },
  { 65267u, &aY_12 },
  { 65268u, &aY_13 },
  { 65269u, &aLm },
  { 65270u, &aLm_0 },
  { 65271u, &aLh },
  { 65272u, &aLh_0 },
  { 65273u, &aLh_1 },
  { 65274u, &aLh_2 },
  { 65275u, &aLa },
  { 65276u, &aLa_0 },
  { 65279u, &delete },
  { 65377u, (unsigned __int8 *)0x813015E },
  { 65378u, (unsigned __int8 *)0x8128449 },
  { 65379u, (unsigned __int8 *)0x8128449 },
  { 65380u, (unsigned __int8 *)0x813114D },
  { 4294967295u, NULL }
}; // idb
const unsigned __int8 no_str[2] = { 42u, 0u }; // idb
const char utf8char_len_tab[256] =
{
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x04',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x06',
  '\x06',
  '\x01',
  '\x01'
}; // idb
const unsigned __int8 nl_default_default_domain__[9] = { 109u, 101u, 115u, 115u, 97u, 103u, 101u, 115u, 0u }; // idb
const unsigned __int8 nl_default_dirname__[18] =
{
  47u,
  117u,
  115u,
  114u,
  47u,
  115u,
  104u,
  97u,
  114u,
  101u,
  47u,
  108u,
  111u,
  99u,
  97u,
  108u,
  101u,
  0u
}; // idb
const yysigned_char yypact[27] =
{
  '\xF7',
  '\xF7',
  '\xF6',
  '\xF6',
  '\xF7',
  '\b',
  '$',
  '\xF6',
  '\r',
  '\xF6',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF6',
  '\x1A',
  ')',
  '-',
  '\x12',
  '\xFE',
  '\x0E',
  '\xF6',
  '\xF7',
  '$'
}; // idb
const unsigned __int8 yytranslate[263] =
{
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  10u,
  2u,
  2u,
  2u,
  2u,
  5u,
  2u,
  14u,
  15u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  12u,
  2u,
  2u,
  2u,
  2u,
  3u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  13u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  4u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  6u,
  7u,
  8u,
  9u,
  11u
}; // idb
const yysigned_char yycheck[55] =
{
  '\x01',
  '\n',
  '\v',
  '\x04',
  '\r',
  '\x0E',
  '\b',
  '\t',
  '\0',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\t',
  '\x19',
  '\a',
  '\b',
  '\t',
  '\x0F',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\xFF',
  '\xFF',
  '\f',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x06',
  '\a',
  '\b',
  '\t'
}; // idb
const unsigned __int8 yytable[55] =
{
  7u,
  1u,
  2u,
  8u,
  3u,
  4u,
  15u,
  16u,
  9u,
  18u,
  19u,
  20u,
  21u,
  22u,
  23u,
  24u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  16u,
  26u,
  14u,
  15u,
  16u,
  17u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  0u,
  0u,
  25u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  12u,
  13u,
  14u,
  15u,
  16u,
  13u,
  14u,
  15u,
  16u
}; // idb
const unsigned __int8 yydefact[27] =
{
  0u,
  0u,
  12u,
  11u,
  0u,
  0u,
  2u,
  10u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  13u,
  0u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  0u,
  3u
}; // idb
const unsigned __int8 yyr2[14] = { 0u, 2u, 1u, 5u, 3u, 3u, 3u, 3u, 3u, 3u, 2u, 1u, 1u, 3u }; // idb
const unsigned __int8 yyr1[14] = { 0u, 16u, 17u, 18u, 18u, 18u, 18u, 18u, 18u, 18u, 18u, 18u, 18u, 18u }; // idb
const yysigned_char yypgoto[3] = { '\xF6', '\xF6', '\xFF' }; // idb
const yysigned_char yydefgoto[3] = { '\xFF', '\x05', '\x06' }; // idb
const unsigned __int8 comma_6159[3] = { 44u, 32u, 0u }; // idb
const mime_backend *const mime_backends[4] = { &default_mime_backend, &mailcap_mime_backend, &mimetypes_mime_backend, NULL }; // idb
const mime_backend default_mime_backend = { &get_content_type_default, &get_mime_handler_default }; // idb
const change_hook_info mimetypes_change_hooks_7155[2] = { { &aMimeMailcap, &change_hook_mailcap }, { NULL, NULL } }; // idb
const change_hook_info mimetypes_change_hooks_6816[2] = { { &aMimeMimetypes, &change_hook_mimetypes }, { NULL, NULL } }; // idb
const s_msg_dsc msg_dsc[45] =
{
  { 0, &aWaitingInQueue },
  { 1, &aLookingUpHost },
  { 2, &aMakingConnecti },
  { 3, &aSslNegotiation },
  { 4, &aRequestSent },
  { 5, &aLoggingIn },
  { 6, &aGettingHeaders },
  { 7, &aServerIsProces },
  { 8, &aTransferring },
  { -100013, &aWaitingForRedi },
  { -100000, (unsigned __int8 *)0x812CF45 },
  { -100001, &aInterrupted },
  { -100002, &aSocketExceptio },
  { -100003, &aInternalError },
  { -100004, &byte_8127CFF },
  { -100005, &aHostNotFound },
  { -100006, &aErrorWritingTo_0 },
  { -100007, &unk_8131BE3 },
  { -100008, &unk_8131BFD },
  { -100009, &aBadUrlSyntax },
  { -100010, &aReceiveTimeout },
  { -100011, &aRequestMustBeR },
  { -100012, &aCanTGetSocketS },
  { -100014, &aOnlyLocalConne },
  { -100019, &aNoHostInTheSpe },
  { -100017, &aErrorWhileDeco },
  { -100015, &aThisUrlContain },
  { -100016, &aThisUrlContain_0 },
  { -100100, &aBadHttpRespons },
  { -100101, &unk_8131C5D },
  { -100200, &aUnknownFileTyp },
  { -100201, &aErrorOpeningFi },
  { -100202, &unk_8131C8D },
  { -100203, &aLocalFileAcces },
  { -100300, &aBadFtpResponse },
  { -100301, &aFtpServiceUnav },
  { -100302, &aBadFtpLogin },
  { -100303, &aFtpPortCommand },
  { -100304, &aFileNotFound },
  { -100305, &aFtpFileError },
  { -100018, &unk_8131D15 },
  { -100600, &aJavascriptSupp },
  { -100700, &aConfigurationO_0 },
  { -100900, &aFspServerNotFo },
  { 0, NULL }
}; // idb
_UNKNOWN protocol_priority_7093; // weak
const int cipher_priority[16] = { 4, 2, 3, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
const int kx_priority[16] = { 1, 2, 3, 5, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
const open_in_new open_in_new_0[4] =
{
  { ENV_XWIN, &aXTerminalEmula, &aXterm },
  { ENV_TWIN, &aTwtermE, &aTWterm },
  { ENV_SCREEN, (unsigned __int8 *)0x812B74B, &aScreen },
  { 0, NULL, NULL }
}; // idb
const about_page about_pages[5] =
{
  { &aBloat, &aHtmlBodyPBloat },
  { &aLinks, &aHtmlBodyPreDW },
  { &aMozilla, &aHtmlBodyTextWh },
  { &aFear, &aHtmlBodyTextYe },
  { NULL, NULL }
}; // idb
const protocol_backend protocol_backends[21] =
{
  { &aAbout_1, 0, &about_protocol_handler, 0u, 0u, 1u, 0u, 1u },
  { &aBittorrent, 0, NULL, 0u, 0u, 1u, 0u, 1u },
  { &aBittorrentPeer, 0, NULL, 1u, 1u, 0u, 0u, 1u },
  {
    (unsigned __int8 *)0x812C58C,
    0,
    &data_protocol_handler,
    0u,
    0u,
    1u,
    0u,
    1u
  },
  { &aFile, 0, &file_protocol_handler, 1u, 0u, 0u, 0u, 0u },
  { &aFinger, 79, &finger_protocol_handler, 1u, 1u, 0u, 0u, 1u },
  { &aFsp, 21, NULL, 1u, 1u, 0u, 0u, 1u },
  {
    (unsigned __int8 *)0x81328FD,
    21,
    &ftp_protocol_handler,
    1u,
    1u,
    0u,
    0u,
    0u
  },
  { &aGopher_0, 70, NULL, 1u, 1u, 0u, 0u, 1u },
  { &aHttp_1, 80, &http_protocol_handler, 1u, 1u, 0u, 0u, 1u },
  { &aHttps, 443, &http_protocol_handler, 1u, 1u, 0u, 1u, 1u },
  { &aJavascript, 0, NULL, 0u, 0u, 1u, 0u, 1u },
  { &aNews, 0, NULL, 0u, 0u, 1u, 0u, 1u },
  { &aNntp, 119, NULL, 1u, 1u, 0u, 0u, 0u },
  { &aNntps, 563, NULL, 1u, 1u, 0u, 1u, 0u },
  {
    (unsigned __int8 *)0x8132068,
    3128,
    &proxy_protocol_handler,
    1u,
    1u,
    0u,
    0u,
    1u
  },
  { &aSmb, 139, NULL, 1u, 1u, 0u, 0u, 1u },
  { &aSnews, 0, NULL, 0u, 0u, 1u, 0u, 1u },
  { NULL, 0, NULL, 0u, 0u, 1u, 0u, 1u },
  { &aUser_0, 0, NULL, 0u, 0u, 0u, 0u, 1u },
  { &aCustom, 0, NULL, 0u, 0u, 1u, 0u, 1u }
}; // idb
const unsigned __int8 chars_7182[4] = { 1u, 35u, 63u, 0u }; // idb
const unsigned __int8 *const tld_7154[16] =
{
  &aCom,
  &aEdu,
  (const unsigned __int8 *const)0x8132301,
  (const unsigned __int8 *const)0x813329F,
  &aGov,
  (const unsigned __int8 *const)0x812FB5B,
  (const unsigned __int8 *const)0x8130BDF,
  &aBiz,
  &aArpa,
  &aAero,
  &aCoop,
  (const unsigned __int8 *const)0x812B3A8,
  &aMuseum,
  (const unsigned __int8 *const)0x81279EF,
  &aPro,
  NULL
}; // idb
const http_code http_code_0[41] =
{
  { 100, &aContinue },
  { 101, &unk_813299B },
  { 200, (const unsigned __int8 *)0x812CF45 },
  { 201, &aCreated },
  { 202, &aAccepted },
  { 203, &aNonAuthoritati },
  { 204, &aNoContent },
  { 205, &aResetContent },
  { 206, &aPartialContent },
  { 300, &aMultipleChoice },
  { 301, &aMovedPermanent },
  { 302, &aFound },
  { 303, &aSeeOther },
  { 304, &aNotModified },
  { 305, &aUseProxy },
  { 306, &aUnused },
  { 307, &unk_8132A54 },
  { 400, &unk_8132A67 },
  { 401, &aUnauthorized },
  { 402, &aPaymentRequire },
  { 403, &aForbidden },
  { 404, &unk_8132A9B },
  { 405, &aMethodNotAllow },
  { 406, &aNotAcceptable },
  { 407, &aProxyAuthentic_0 },
  { 408, &aRequestTimeout },
  { 409, &aConflict },
  { 410, &aGone },
  { 411, &aLengthRequired },
  { 412, &aPreconditionFa },
  { 413, &aRequestEntityT },
  { 414, &aRequestUriTooL },
  { 415, &unk_8132B55 },
  { 416, &aRequestedRange },
  { 417, &aExpectationFai },
  { 500, &unk_8132B7F },
  { 501, &aNotImplemented },
  { 502, &aBadGateway },
  { 503, &aServiceUnavail },
  { 504, &aGatewayTimeout },
  { 505, &aHttpVersionNot }
}; // idb
char *buggy_servers_9226[3] = { "mod_czech/3.1.0", "Purveyor", "Netscape-Enterprise" }; // weak
const $2958037E501FB749D017A29D9F57B781 known_types[9] =
{
  { &s1, 0u },
  { &aTextPlain, 1u },
  { &aApplicationXht, 0u },
  { &aApplicationDoc, 1u },
  { &aApplicationRss, 0u },
  { &aApplicationXbe, 1u },
  { &aApplicationXbe_0, 1u },
  { &aApplicationXXb, 1u },
  { NULL, 1u }
}; // idb
const color_mode_info *const color_modes[5] =
{
  &color_mode_16,
  &color_mode_16,
  &color_mode_88,
  &color_mode_256,
  &color_mode_16
}; // idb
const unsigned __int8 fg_color[16][8] =
{
  { 7u, 0u, 0u, 0u, 7u, 0u, 0u, 0u },
  { 1u, 9u, 1u, 9u, 9u, 9u, 1u, 1u },
  { 2u, 2u, 10u, 2u, 2u, 2u, 10u, 10u },
  { 3u, 11u, 3u, 11u, 3u, 11u, 3u, 3u },
  { 12u, 12u, 6u, 4u, 12u, 6u, 4u, 4u },
  { 5u, 13u, 5u, 13u, 13u, 13u, 5u, 5u },
  { 6u, 6u, 14u, 6u, 6u, 6u, 14u, 14u },
  { 7u, 7u, 0u, 7u, 7u, 7u, 0u, 0u },
  { 15u, 15u, 8u, 15u, 15u, 15u, 8u, 8u },
  { 9u, 9u, 1u, 9u, 9u, 9u, 1u, 9u },
  { 10u, 10u, 10u, 10u, 10u, 10u, 10u, 10u },
  { 11u, 11u, 11u, 11u, 11u, 11u, 11u, 11u },
  { 12u, 12u, 6u, 4u, 6u, 6u, 4u, 12u },
  { 13u, 13u, 5u, 13u, 13u, 13u, 5u, 5u },
  { 14u, 14u, 14u, 14u, 14u, 14u, 14u, 14u },
  { 15u, 15u, 15u, 15u, 15u, 15u, 15u, 15u }
}; // idb
const border_char p2_4831[6] =
{
  BORDER_DULCORNER,
  BORDER_DURCORNER,
  BORDER_DDLCORNER,
  BORDER_DDRCORNER,
  BORDER_DVLINE,
  BORDER_DHLINE
}; // idb
const border_char p1_4830[6] =
{
  BORDER_SULCORNER,
  BORDER_SURCORNER,
  BORDER_SDLCORNER,
  BORDER_SDRCORNER,
  BORDER_SVLINE,
  BORDER_SHLINE
}; // idb
const unsigned __int8 border_trans_4691[2][4] = { { 179u, 195u, 180u, 0u }, { 196u, 194u, 193u, 0u } }; // idb
char byte_810D4B1[] = { '\xC3' }; // weak
char byte_810D4B2[] = { '\xB4' }; // weak
int min_8206[12] = { 128, 2048, 65536, 2097152, 67108864, 0, 0, 0, 0, 0, 0, 0 }; // weak
const term_event_keyboard os2xtd_7283[256] =
{
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { 32, KBD_MOD_CTRL },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -257, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { 81, KBD_MOD_ALT },
  { 87, KBD_MOD_ALT },
  { 69, KBD_MOD_ALT },
  { 82, KBD_MOD_ALT },
  { 84, KBD_MOD_ALT },
  { 89, KBD_MOD_ALT },
  { 85, KBD_MOD_ALT },
  { 73, KBD_MOD_ALT },
  { 79, KBD_MOD_ALT },
  { 80, KBD_MOD_ALT },
  { 91, KBD_MOD_ALT },
  { 93, KBD_MOD_ALT },
  { -256, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { 65, KBD_MOD_ALT },
  { 83, KBD_MOD_ALT },
  { 68, KBD_MOD_ALT },
  { 70, KBD_MOD_ALT },
  { 71, KBD_MOD_ALT },
  { 72, KBD_MOD_ALT },
  { 74, KBD_MOD_ALT },
  { 75, KBD_MOD_ALT },
  { 76, KBD_MOD_ALT },
  { 59, KBD_MOD_ALT },
  { 39, KBD_MOD_ALT },
  { 96, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { 92, KBD_MOD_ALT },
  { 90, KBD_MOD_ALT },
  { 88, KBD_MOD_ALT },
  { 67, KBD_MOD_ALT },
  { 86, KBD_MOD_ALT },
  { 66, KBD_MOD_ALT },
  { 78, KBD_MOD_ALT },
  { 77, KBD_MOD_ALT },
  { 44, KBD_MOD_ALT },
  { 46, KBD_MOD_ALT },
  { 47, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { 42, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { 32, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -288, KBD_MOD_NONE },
  { -289, KBD_MOD_NONE },
  { -290, KBD_MOD_NONE },
  { -291, KBD_MOD_NONE },
  { -292, KBD_MOD_NONE },
  { -293, KBD_MOD_NONE },
  { -294, KBD_MOD_NONE },
  { -295, KBD_MOD_NONE },
  { -296, KBD_MOD_NONE },
  { -297, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -266, KBD_MOD_NONE },
  { -262, KBD_MOD_NONE },
  { -268, KBD_MOD_NONE },
  { 45, KBD_MOD_ALT },
  { -260, KBD_MOD_NONE },
  { 53, KBD_MOD_NONE },
  { -261, KBD_MOD_NONE },
  { 43, KBD_MOD_ALT },
  { -267, KBD_MOD_NONE },
  { -263, KBD_MOD_NONE },
  { -269, KBD_MOD_NONE },
  { -264, KBD_MOD_NONE },
  { -265, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -288, KBD_MOD_CTRL },
  { -289, KBD_MOD_CTRL },
  { -290, KBD_MOD_CTRL },
  { -291, KBD_MOD_CTRL },
  { -292, KBD_MOD_CTRL },
  { -293, KBD_MOD_CTRL },
  { -294, KBD_MOD_CTRL },
  { -295, KBD_MOD_CTRL },
  { -296, KBD_MOD_CTRL },
  { -297, KBD_MOD_CTRL },
  { -288, KBD_MOD_ALT },
  { -289, KBD_MOD_ALT },
  { -290, KBD_MOD_ALT },
  { -291, KBD_MOD_ALT },
  { -292, KBD_MOD_ALT },
  { -293, KBD_MOD_ALT },
  { -294, KBD_MOD_ALT },
  { -295, KBD_MOD_ALT },
  { -296, KBD_MOD_ALT },
  { -297, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -260, KBD_MOD_CTRL },
  { -261, KBD_MOD_CTRL },
  { -267, KBD_MOD_CTRL },
  { -269, KBD_MOD_CTRL },
  { -266, KBD_MOD_CTRL },
  { 49, KBD_MOD_ALT },
  { 50, KBD_MOD_ALT },
  { 51, KBD_MOD_ALT },
  { 52, KBD_MOD_ALT },
  { 53, KBD_MOD_ALT },
  { 54, KBD_MOD_ALT },
  { 55, KBD_MOD_ALT },
  { 56, KBD_MOD_ALT },
  { 57, KBD_MOD_ALT },
  { 48, KBD_MOD_ALT },
  { 45, KBD_MOD_ALT },
  { 61, KBD_MOD_ALT },
  { -268, KBD_MOD_CTRL },
  { -298, KBD_MOD_NONE },
  { -299, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -298, KBD_MOD_CTRL },
  { -299, KBD_MOD_CTRL },
  { -298, KBD_MOD_ALT },
  { -299, KBD_MOD_ALT },
  { -262, KBD_MOD_CTRL },
  { 45, KBD_MOD_CTRL },
  { 53, KBD_MOD_CTRL },
  { 43, KBD_MOD_CTRL },
  { -263, KBD_MOD_CTRL },
  { -264, KBD_MOD_CTRL },
  { -265, KBD_MOD_CTRL },
  { -258, KBD_MOD_CTRL },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -266, KBD_MOD_ALT },
  { -262, KBD_MOD_ALT },
  { -268, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -260, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -261, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -267, KBD_MOD_ALT },
  { -263, KBD_MOD_ALT },
  { -269, KBD_MOD_ALT },
  { -264, KBD_MOD_ALT },
  { -265, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -258, KBD_MOD_ALT },
  { -256, KBD_MOD_ALT },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE },
  { -1, KBD_MOD_NONE }
}; // idb
term_event_modifier_T modifier[467] =
{
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  32,
  KBD_MOD_CTRL,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -257,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  81,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|KBD_MOD_SHIFT|0x50,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_SHIFT|0x40,
  KBD_MOD_ALT,
  82,
  KBD_MOD_ALT,
  84,
  KBD_MOD_ALT,
  89,
  KBD_MOD_ALT,
  85,
  KBD_MOD_ALT,
  73,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|KBD_MOD_SHIFT|0x48,
  KBD_MOD_ALT,
  80,
  KBD_MOD_ALT,
  91,
  KBD_MOD_ALT,
  93,
  KBD_MOD_ALT,
  -256,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  65,
  KBD_MOD_ALT,
  83,
  KBD_MOD_ALT,
  68,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|0x40,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|KBD_MOD_SHIFT|0x40,
  KBD_MOD_ALT,
  72,
  KBD_MOD_ALT,
  74,
  KBD_MOD_ALT,
  75,
  KBD_MOD_ALT,
  76,
  KBD_MOD_ALT,
  59,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|KBD_MOD_SHIFT|0x20,
  KBD_MOD_ALT,
  96,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  92,
  KBD_MOD_ALT,
  90,
  KBD_MOD_ALT,
  88,
  KBD_MOD_ALT,
  KBD_MOD_CTRL|KBD_MOD_SHIFT|0x40,
  KBD_MOD_ALT,
  86,
  KBD_MOD_ALT,
  66,
  KBD_MOD_ALT,
  78,
  KBD_MOD_ALT,
  77,
  KBD_MOD_ALT,
  44,
  KBD_MOD_ALT,
  46,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|KBD_MOD_SHIFT|0x28,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  42,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  32,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -288,
  KBD_MOD_NONE,
  -289,
  KBD_MOD_NONE,
  -290,
  KBD_MOD_NONE,
  -291,
  KBD_MOD_NONE,
  -292,
  KBD_MOD_NONE,
  -293,
  KBD_MOD_NONE,
  -294,
  KBD_MOD_NONE,
  -295,
  KBD_MOD_NONE,
  -296,
  KBD_MOD_NONE,
  -297,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -266,
  KBD_MOD_NONE,
  -262,
  KBD_MOD_NONE,
  -268,
  KBD_MOD_NONE,
  45,
  KBD_MOD_ALT,
  -260,
  KBD_MOD_NONE,
  53,
  KBD_MOD_NONE,
  -261,
  KBD_MOD_NONE,
  43,
  KBD_MOD_ALT,
  -267,
  KBD_MOD_NONE,
  -263,
  KBD_MOD_NONE,
  -269,
  KBD_MOD_NONE,
  -264,
  KBD_MOD_NONE,
  -265,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -288,
  KBD_MOD_CTRL,
  -289,
  KBD_MOD_CTRL,
  -290,
  KBD_MOD_CTRL,
  -291,
  KBD_MOD_CTRL,
  -292,
  KBD_MOD_CTRL,
  -293,
  KBD_MOD_CTRL,
  -294,
  KBD_MOD_CTRL,
  -295,
  KBD_MOD_CTRL,
  -296,
  KBD_MOD_CTRL,
  -297,
  KBD_MOD_CTRL,
  -288,
  KBD_MOD_ALT,
  -289,
  KBD_MOD_ALT,
  -290,
  KBD_MOD_ALT,
  -291,
  KBD_MOD_ALT,
  -292,
  KBD_MOD_ALT,
  -293,
  KBD_MOD_ALT,
  -294,
  KBD_MOD_ALT,
  -295,
  KBD_MOD_ALT,
  -296,
  KBD_MOD_ALT,
  -297,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -260,
  KBD_MOD_CTRL,
  -261,
  KBD_MOD_CTRL,
  -267,
  KBD_MOD_CTRL,
  -269,
  KBD_MOD_CTRL,
  -266,
  KBD_MOD_CTRL,
  49,
  KBD_MOD_ALT,
  50,
  KBD_MOD_ALT,
  51,
  KBD_MOD_ALT,
  52,
  KBD_MOD_ALT,
  53,
  KBD_MOD_ALT,
  54,
  KBD_MOD_ALT,
  KBD_MOD_ALT|KBD_MOD_CTRL|KBD_MOD_SHIFT|0x30,
  KBD_MOD_ALT,
  56,
  KBD_MOD_ALT,
  57,
  KBD_MOD_ALT,
  48,
  KBD_MOD_ALT,
  45,
  KBD_MOD_ALT,
  61,
  KBD_MOD_ALT,
  -268,
  KBD_MOD_CTRL,
  -298,
  KBD_MOD_NONE,
  -299,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -298,
  KBD_MOD_CTRL,
  -299,
  KBD_MOD_CTRL,
  -298,
  KBD_MOD_ALT,
  -299,
  KBD_MOD_ALT,
  -262,
  KBD_MOD_CTRL,
  45,
  KBD_MOD_CTRL,
  53,
  KBD_MOD_CTRL,
  43,
  KBD_MOD_CTRL,
  -263,
  KBD_MOD_CTRL,
  -264,
  KBD_MOD_CTRL,
  -265,
  KBD_MOD_CTRL,
  -258,
  KBD_MOD_CTRL,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -266,
  KBD_MOD_ALT,
  -262,
  KBD_MOD_ALT,
  -268,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -260,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -261,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -267,
  KBD_MOD_ALT,
  -263,
  KBD_MOD_ALT,
  -269,
  KBD_MOD_ALT,
  -264,
  KBD_MOD_ALT,
  -265,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -258,
  KBD_MOD_ALT,
  -256,
  KBD_MOD_ALT,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE,
  -1,
  KBD_MOD_NONE
}; // weak
char byte_810DDD0[176] =
{
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
const screen_driver_opt *const screen_driver_opts[5] =
{
  &dumb_screen_driver_opt,
  &vt100_screen_driver_opt,
  &linux_screen_driver_opt,
  &koi8_screen_driver_opt,
  &freebsd_screen_driver_opt
}; // idb
const string underline_seqs[2] = { { &a24m, 5 }, { &a4m, 4 } }; // idb
const unsigned __int8 frame_restrict[48] =
{
  176u,
  177u,
  178u,
  179u,
  180u,
  179u,
  186u,
  186u,
  205u,
  185u,
  186u,
  187u,
  188u,
  186u,
  205u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  179u,
  186u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  205u,
  196u,
  205u,
  196u,
  186u,
  205u,
  205u,
  186u,
  186u,
  179u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u
}; // idb
const unsigned __int8 frame_freebsd_u[48] =
{
  177u,
  177u,
  219u,
  179u,
  180u,
  180u,
  180u,
  191u,
  191u,
  180u,
  179u,
  191u,
  217u,
  217u,
  217u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  195u,
  195u,
  192u,
  218u,
  193u,
  194u,
  195u,
  196u,
  197u,
  193u,
  193u,
  194u,
  194u,
  192u,
  192u,
  218u,
  218u,
  197u,
  197u,
  217u,
  218u,
  219u,
  219u,
  219u,
  219u,
  219u
}; // idb
const unsigned __int8 frame_vt100_u[48] =
{
  177u,
  177u,
  177u,
  179u,
  180u,
  180u,
  180u,
  191u,
  191u,
  180u,
  179u,
  191u,
  217u,
  217u,
  217u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  195u,
  195u,
  192u,
  218u,
  193u,
  194u,
  195u,
  196u,
  197u,
  193u,
  193u,
  194u,
  194u,
  192u,
  192u,
  218u,
  218u,
  197u,
  197u,
  217u,
  218u,
  177u,
  32u,
  32u,
  32u,
  32u
}; // idb
const string m11_hack_frame_seqs[2] = { { &a10m, 5 }, { &a11m, 5 } }; // idb
const unsigned __int8 frame_vt100[48] =
{
  97u,
  97u,
  97u,
  120u,
  117u,
  117u,
  117u,
  107u,
  107u,
  117u,
  120u,
  107u,
  106u,
  106u,
  106u,
  107u,
  109u,
  118u,
  119u,
  116u,
  113u,
  110u,
  116u,
  116u,
  109u,
  108u,
  118u,
  119u,
  116u,
  113u,
  110u,
  118u,
  118u,
  119u,
  119u,
  109u,
  109u,
  108u,
  108u,
  110u,
  110u,
  106u,
  108u,
  97u,
  32u,
  32u,
  32u,
  32u
}; // idb
const string color256_seqs[2] = { { &a0385Dm, 12 }, { &a485Dm, 10 } }; // idb
const unsigned __int8 base64_chars[65] =
{
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  43u,
  47u,
  0u
}; // idb
const color_spec color_specs[607] =
{
  { "aliceblue", 15792383u },
  { "antiquewhite", 16444375u },
  { "aqua", 65535u },
  { "aquamarine", 8388564u },
  { "azure", 15794175u },
  { "beige", 16119260u },
  { "bisque", 16770244u },
  { "black", 0u },
  { "blanchedalmond", 16772045u },
  { "blue", 255u },
  { "blueviolet", 9055202u },
  { "brown", 10824234u },
  { "burlywood", 14596231u },
  { "cadetblue", 6266528u },
  { "chartreuse", 8388352u },
  { "chocolate", 13789470u },
  { "coral", 16744272u },
  { "cornflowerblue", 6591981u },
  { "cornsilk", 16775388u },
  { "crimson", 14423100u },
  { "cyan", 65535u },
  { "darkblue", 139u },
  { "darkcyan", 35723u },
  { "darkgoldenrod", 12092939u },
  { "darkgray", 11119017u },
  { &unk_8133ACC, 25600u },
  { "darkkhaki", 12433259u },
  { "darkmagenta", 9109643u },
  { "darkolivegreen", 5597999u },
  { "darkorange", 16747520u },
  { "darkorchid", 10040012u },
  { "darkred", 9109504u },
  { "darksalmon", 15308410u },
  { "darkseagreen", 9419919u },
  { "darkslateblue", 4734347u },
  { "darkslategray", 3100495u },
  { "darkturquoise", 52945u },
  { "darkviolet", 9699539u },
  { "deeppink", 16716947u },
  { "deepskyblue", 49151u },
  { "dimgray", 6908265u },
  { "dodgerblue", 2003199u },
  { "firebrick", 11674146u },
  { "floralwhite", 16775920u },
  { "forestgreen", 2263842u },
  { "fuchsia", 16711935u },
  { "gainsboro", 14474460u },
  { "ghostwhite", 16316671u },
  { "gold", 16766720u },
  { "goldenrod", 14329120u },
  { "gray", 12500670u },
  { "green", 32768u },
  { "greenyellow", 11403055u },
  { "honeydew", 15794160u },
  { "hotpink", 16738740u },
  { "indianred", 13458524u },
  { "indigo", 4915330u },
  { "ivory", 16777200u },
  { "khaki", 15787660u },
  { "lavender", 15132410u },
  { "lavenderblush", 16773365u },
  { "lawngreen", 8190976u },
  { "lemonchiffon", 16775885u },
  { "lightblue", 11393254u },
  { "lightcoral", 15761536u },
  { "lightcyan", 14745599u },
  { "lightgoldenrodyellow", 16448210u },
  { "lightgreen", 9498256u },
  { "lightgrey", 13882323u },
  { "lightpink", 16758465u },
  { "lightsalmon", 16752762u },
  { "lightseagreen", 2142890u },
  { "lightskyblue", 8900346u },
  { "lightslategray", 7833753u },
  { "lightsteelblue", 11584734u },
  { "lightyellow", 16777184u },
  { "lime", 65280u },
  { "limegreen", 3329330u },
  { "linen", 16445670u },
  { "magenta", 16711935u },
  { "maroon", 8388608u },
  { "mediumaquamarine", 6737322u },
  { "mediumblue", 205u },
  { "mediumorchid", 12211667u },
  { "mediumpurple", 9662683u },
  { "mediumseagreen", 3978097u },
  { "mediumslateblue", 8087790u },
  { "mediumspringgreen", 64154u },
  { "mediumturquoise", 4772300u },
  { "mediumvioletred", 13047173u },
  { "midnightblue", 1644912u },
  { "mintcream", 16121850u },
  { "mistyrose", 16770273u },
  { "moccasin", 16770229u },
  { "navajowhite", 16768685u },
  { "navy", 128u },
  { "oldlace", 16643558u },
  { "olive", 8421376u },
  { "olivedrab", 7048739u },
  { "orange", 16753920u },
  { "orangered", 16729344u },
  { "orchid", 14315734u },
  { "palegoldenrod", 15657130u },
  { "palegreen", 10025880u },
  { "paleturquoise", 11529966u },
  { "palevioletred", 14381203u },
  { "papayawhip", 16773077u },
  { "peachpuff", 16767673u },
  { "peru", 13468991u },
  { "pink", 16761035u },
  { "plum", 14524637u },
  { "powderblue", 11591910u },
  { "purple", 8388736u },
  { (const char *)0x8134C0D, 16711680u },
  { "rosybrown", 12357519u },
  { "royalblue", 4286945u },
  { "saddlebrown", 9127187u },
  { "salmon", 16416882u },
  { "sandybrown", 16032864u },
  { (const char *)0x8133B11, 3050327u },
  { "seashell", 16774638u },
  { "sienna", 10506797u },
  { "silver", 12632256u },
  { (const char *)0x8133B5C, 8900331u },
  { (const char *)0x8133B1E, 6970061u },
  { (const char *)0x8133B2C, 7372944u },
  { "snow", 16775930u },
  { (const char *)0x8133D2B, 65407u },
  { (const char *)0x8133CA3, 4620980u },
  { "tan", 13808780u },
  { "teal", 32896u },
  { "thistle", 14204888u },
  { "tomato", 16737095u },
  { "turquoise", 4251856u },
  { "violet", 15631086u },
  { "wheat", 16113331u },
  { "white", 16777215u },
  { "whitesmoke", 16119285u },
  { "yellow", 16776960u },
  { "yellowgreen", 10145074u },
  { &unk_8133E8E, 15792383u },
  { &unk_8133E99, 16444375u },
  { "antiquewhite1", 16773083u },
  { "antiquewhite2", 15654860u },
  { "antiquewhite3", 13484208u },
  { "antiquewhite4", 9143160u },
  { "aquamarine1", 8388564u },
  { "aquamarine2", 7794374u },
  { "aquamarine3", 6737322u },
  { "azure1", 15794175u },
  { "azure2", 14741230u },
  { "azure3", 12701133u },
  { "azure4", 8620939u },
  { "bisque1", 16770244u },
  { "bisque2", 15652279u },
  { "bisque3", 13481886u },
  { "bisque4", 9141611u },
  { "blanched almond", 16772045u },
  { &unk_8133F4F, 9055202u },
  { "brown1", 16728128u },
  { "brown2", 15612731u },
  { "brown3", 13447987u },
  { "brown4", 9118499u },
  { "burlywood1", 16765851u },
  { "burlywood2", 15648145u },
  { "burlywood3", 13478525u },
  { "burlywood4", 9139029u },
  { "cadetblue1", 10024447u },
  { "cadetblue2", 9364974u },
  { "cadetblue3", 8046029u },
  { "chartreuse1", 8388352u },
  { "chartreuse2", 7794176u },
  { "chartreuse3", 6737152u },
  { "chocolate1", 16744228u },
  { "chocolate2", 15627809u },
  { "chocolate3", 13461021u },
  { "chocolate4", 9127187u },
  { "coral1", 16740950u },
  { "coral2", 15624784u },
  { "coral3", 13458245u },
  { "coral4", 9125423u },
  { "cornflower blue", 6591981u },
  { "cornsilk1", 16775388u },
  { "cornsilk2", 15657165u },
  { "cornsilk3", 13486257u },
  { "cornsilk4", 9144440u },
  { "dark blue", 139u },
  { &unk_8134056, 35723u },
  { "dark goldenrod", 12092939u },
  { "darkgoldenrod1", 16759055u },
  { "darkgoldenrod2", 15641870u },
  { "darkgoldenrod3", 13473036u },
  { "darkgoldenrod4", 9135368u },
  { "dark gray", 11119017u },
  { "dark grey", 11119017u },
  { "darkgrey", 11119017u },
  { &unk_81340C8, 12433259u },
  { &unk_81340D3, 9109643u },
  { "darkolivegreen1", 13303664u },
  { "darkolivegreen2", 12381800u },
  { "darkolivegreen3", 10669402u },
  { "darkolivegreen4", 7244605u },
  { &unk_8134120, 16747520u },
  { "darkorange1", 16744192u },
  { "darkorange2", 15627776u },
  { "darkorange3", 13460992u },
  { "darkorange4", 9127168u },
  { &unk_813415C, 10040012u },
  { "darkorchid1", 12533503u },
  { "darkorchid2", 11680494u },
  { "darkorchid3", 10105549u },
  { "darkorchid4", 6824587u },
  { "dark red", 9109504u },
  { &unk_81341A1, 15308410u },
  { &unk_81341AD, 9419919u },
  { "darkseagreen1", 12713921u },
  { "darkseagreen2", 11857588u },
  { "darkseagreen3", 10210715u },
  { "darkseagreen4", 6916969u },
  { "darkslategray1", 9961471u },
  { "darkslategray2", 9301742u },
  { "darkslategray3", 7982541u },
  { "dark violet", 9699539u },
  { &unk_813422D, 16716947u },
  { "deeppink1", 16716947u },
  { "deeppink2", 15602313u },
  { "deeppink3", 13439094u },
  { "deeppink4", 9112144u },
  { "dim gray", 6908265u },
  { "dim grey", 6908265u },
  { "dimgrey", 6908265u },
  { "firebrick1", 16724016u },
  { "firebrick2", 15608876u },
  { "firebrick3", 13444646u },
  { "firebrick4", 9116186u },
  { "floral white", 16775920u },
  { "ghost white", 16316671u },
  { "gold1", 16766720u },
  { "gold2", 15649024u },
  { "gold3", 13479168u },
  { "gold4", 9139456u },
  { (const char *)0x8134073, 16761125u },
  { (const char *)0x8134082, 15643682u },
  { (const char *)0x8134091, 13474589u },
  { (const char *)0x81340A0, 9136404u },
  { "gray100", 16777215u },
  { "gray40", 6710886u },
  { "gray41", 6908265u },
  { "gray42", 7039851u },
  { "gray43", 7237230u },
  { "gray44", 7368816u },
  { "gray45", 7566195u },
  { "gray46", 7697781u },
  { "gray47", 7895160u },
  { "gray48", 8026746u },
  { "gray49", 8224125u },
  { "gray50", 8355711u },
  { "gray51", 8553090u },
  { "gray52", 8750469u },
  { "gray53", 8882055u },
  { "gray54", 9079434u },
  { "gray55", 9211020u },
  { "gray56", 9408399u },
  { "gray57", 9539985u },
  { "gray58", 9737364u },
  { "gray59", 9868950u },
  { "gray60", 10066329u },
  { "gray61", 10263708u },
  { "gray62", 10395294u },
  { "gray63", 10592673u },
  { "gray64", 10724259u },
  { "gray65", 10921638u },
  { "gray66", 11053224u },
  { "gray67", 11250603u },
  { "gray68", 11382189u },
  { "gray69", 11579568u },
  { "gray70", 11776947u },
  { "gray71", 11908533u },
  { "gray72", 12105912u },
  { "gray73", 12237498u },
  { "gray74", 12434877u },
  { "gray75", 12566463u },
  { "gray76", 12763842u },
  { "gray77", 12895428u },
  { "gray78", 13092807u },
  { "gray79", 13224393u },
  { "gray80", 13421772u },
  { "gray81", 13619151u },
  { "gray82", 13750737u },
  { "gray83", 13948116u },
  { "gray84", 14079702u },
  { "gray85", 14277081u },
  { "gray86", 14408667u },
  { "gray87", 14606046u },
  { "gray88", 14737632u },
  { "gray89", 14935011u },
  { "gray90", 15066597u },
  { "gray91", 15263976u },
  { "gray92", 15461355u },
  { "gray93", 15592941u },
  { "gray94", 15790320u },
  { "gray95", 15921906u },
  { "gray96", 16119285u },
  { "gray97", 16250871u },
  { "gray98", 16448250u },
  { "gray99", 16579836u },
  { "green yellow", 11403055u },
  { "grey", 12500670u },
  { "grey100", 16777215u },
  { "grey40", 6710886u },
  { "grey41", 6908265u },
  { "grey42", 7039851u },
  { "grey43", 7237230u },
  { "grey44", 7368816u },
  { "grey45", 7566195u },
  { "grey46", 7697781u },
  { "grey47", 7895160u },
  { "grey48", 8026746u },
  { "grey49", 8224125u },
  { "grey50", 8355711u },
  { "grey51", 8553090u },
  { "grey52", 8750469u },
  { "grey53", 8882055u },
  { "grey54", 9079434u },
  { "grey55", 9211020u },
  { "grey56", 9408399u },
  { "grey57", 9539985u },
  { "grey58", 9737364u },
  { "grey59", 9868950u },
  { "grey60", 10066329u },
  { "grey61", 10263708u },
  { "grey62", 10395294u },
  { "grey63", 10592673u },
  { "grey64", 10724259u },
  { "grey65", 10921638u },
  { "grey66", 11053224u },
  { "grey67", 11250603u },
  { "grey68", 11382189u },
  { "grey69", 11579568u },
  { "grey70", 11776947u },
  { "grey71", 11908533u },
  { "grey72", 12105912u },
  { "grey73", 12237498u },
  { "grey74", 12434877u },
  { "grey75", 12566463u },
  { "grey76", 12763842u },
  { "grey77", 12895428u },
  { "grey78", 13092807u },
  { "grey79", 13224393u },
  { "grey80", 13421772u },
  { "grey81", 13619151u },
  { "grey82", 13750737u },
  { "grey83", 13948116u },
  { "grey84", 14079702u },
  { "grey85", 14277081u },
  { "grey86", 14408667u },
  { "grey87", 14606046u },
  { "grey88", 14737632u },
  { "grey89", 14935011u },
  { "grey90", 15066597u },
  { "grey91", 15263976u },
  { "grey92", 15461355u },
  { "grey93", 15592941u },
  { "grey94", 15790320u },
  { "grey95", 15921906u },
  { "grey96", 16119285u },
  { "grey97", 16250871u },
  { "grey98", 16448250u },
  { "grey99", 16579836u },
  { "honeydew1", 15794160u },
  { "honeydew2", 14741216u },
  { "honeydew3", 12701121u },
  { "honeydew4", 8620931u },
  { "hot pink", 16738740u },
  { "hotpink1", 16740020u },
  { "hotpink2", 15624871u },
  { "hotpink3", 13459600u },
  { "hotpink4", 9124450u },
  { "indian red", 13458524u },
  { "indianred1", 16738922u },
  { "indianred2", 15623011u },
  { "indianred3", 13456725u },
  { "indianred4", 9124410u },
  { "ivory1", 16777200u },
  { "ivory2", 15658720u },
  { "ivory3", 13487553u },
  { "ivory4", 9145219u },
  { "khaki1", 16774799u },
  { "khaki2", 15656581u },
  { "khaki3", 13485683u },
  { "khaki4", 9143886u },
  { "lavender blush", 16773365u },
  { "lavenderblush1", 16773365u },
  { "lavenderblush2", 15655141u },
  { "lavenderblush3", 13484485u },
  { "lavenderblush4", 9143174u },
  { "lawn green", 8190976u },
  { "lemon chiffon", 16775885u },
  { "lemonchiffon1", 16775885u },
  { "lemonchiffon2", 15657407u },
  { "lemonchiffon3", 13486501u },
  { "lemonchiffon4", 9144688u },
  { "light blue", 11393254u },
  { "lightblue1", 12578815u },
  { "lightblue2", 11722734u },
  { "lightblue3", 10141901u },
  { "lightblue4", 6849419u },
  { &unk_81347D2, 15761536u },
  { "light cyan", 14745599u },
  { "lightcyan1", 14745599u },
  { "lightcyan2", 13758190u },
  { "lightcyan3", 11849165u },
  { "lightcyan4", 8031115u },
  { "light goldenrod", 15654274u },
  { "lightgoldenrod", 15654274u },
  { "lightgoldenrod1", 16772235u },
  { "lightgoldenrod2", 15654018u },
  { "lightgoldenrod3", 13483632u },
  { "lightgoldenrod4", 9142604u },
  { &unk_8134874, 16448210u },
  { "light gray", 13882323u },
  { "lightgray", 13882323u },
  { "light green", 9498256u },
  { "light grey", 13882323u },
  { "light pink", 16758465u },
  { "lightpink1", 16756409u },
  { "lightpink2", 15639213u },
  { "lightpink3", 13470869u },
  { "lightpink4", 9133925u },
  { "light salmon", 16752762u },
  { "lightsalmon1", 16752762u },
  { "lightsalmon2", 15635826u },
  { "lightsalmon3", 13468002u },
  { "lightsalmon4", 9131842u },
  { "light sky blue", 8900346u },
  { "lightskyblue1", 11592447u },
  { "lightskyblue2", 10802158u },
  { "lightskyblue3", 9287373u },
  { "light slate blue", 8679679u },
  { "lightslateblue", 8679679u },
  { &unk_8134988, 7833753u },
  { &unk_8134999, 7833753u },
  { "lightslategrey", 7833753u },
  { "light steel blue", 11584734u },
  { "lightsteelblue1", 13296127u },
  { "lightsteelblue2", 12374766u },
  { "lightsteelblue3", 10663373u },
  { "lightsteelblue4", 7240587u },
  { "light yellow", 16777184u },
  { "lightyellow1", 16777184u },
  { "lightyellow2", 15658705u },
  { "lightyellow3", 13487540u },
  { "lightyellow4", 9145210u },
  { "magenta1", 16711935u },
  { "magenta2", 15597806u },
  { "magenta3", 13435085u },
  { "magenta4", 9109643u },
  { "maroon1", 16725171u },
  { "maroon2", 15610023u },
  { "maroon3", 13445520u },
  { "maroon4", 9116770u },
  { &unk_8134A8F, 6737322u },
  { "medium orchid", 12211667u },
  { "mediumorchid1", 14706431u },
  { "mediumorchid2", 13721582u },
  { "mediumorchid3", 11817677u },
  { "mediumorchid4", 8009611u },
  { &unk_8134AE7, 9662683u },
  { "mediumpurple1", 11240191u },
  { "mediumpurple2", 10451438u },
  { "mediumpurple3", 9005261u },
  { "medium slate blue", 8087790u },
  { "medium violet red", 13047173u },
  { "mint cream", 16121850u },
  { "misty rose", 16770273u },
  { "mistyrose1", 16770273u },
  { "mistyrose2", 15652306u },
  { "mistyrose3", 13481909u },
  { "mistyrose4", 9141627u },
  { "navajo white", 16768685u },
  { "navajowhite1", 16768685u },
  { "navajowhite2", 15650721u },
  { "navajowhite3", 13480843u },
  { "navajowhite4", 9140574u },
  { "old lace", 16643558u },
  { "olive drab", 7048739u },
  { "olivedrab1", 12648254u },
  { "olivedrab2", 11791930u },
  { "olivedrab3", 10145074u },
  { "olivedrab4", 6916898u },
  { (const char *)0x8134130, 16753920u },
  { (const char *)0x813413C, 15636992u },
  { (const char *)0x8134148, 13468928u },
  { (const char *)0x8134154, 9132544u },
  { "orange red", 16729344u },
  { "orangered1", 16729344u },
  { "orangered2", 15613952u },
  { "orangered3", 13448960u },
  { "orangered4", 9118976u },
  { (const char *)0x813416C, 16745466u },
  { (const char *)0x8134178, 15629033u },
  { (const char *)0x8134184, 13461961u },
  { (const char *)0x8134190, 9127817u },
  { &unk_8134C3D, 15657130u },
  { "pale green", 10025880u },
  { "palegreen1", 10157978u },
  { "palegreen2", 9498256u },
  { "palegreen3", 8179068u },
  { &unk_8134C78, 11529966u },
  { "paleturquoise1", 12320767u },
  { "paleturquoise2", 11464430u },
  { "paleturquoise3", 9883085u },
  { "paleturquoise4", 6720395u },
  { "pale violet red", 14381203u },
  { "palevioletred1", 16745131u },
  { "palevioletred2", 15628703u },
  { "palevioletred3", 13461641u },
  { "palevioletred4", 9127773u },
  { "papaya whip", 16773077u },
  { "peach puff", 16767673u },
  { "peachpuff1", 16767673u },
  { "peachpuff2", 15649709u },
  { "peachpuff3", 13479829u },
  { "peachpuff4", 9140069u },
  { (const char *)0x813423B, 16758213u },
  { (const char *)0x8134245, 15641016u },
  { (const char *)0x813424F, 13472158u },
  { (const char *)0x8134259, 9134956u },
  { "plum1", 16759807u },
  { "plum2", 15642350u },
  { "plum3", 13473485u },
  { "plum4", 9135755u },
  { "powder blue", 11591910u },
  { (const char *)0x8134AFB, 10170623u },
  { (const char *)0x8134B09, 9514222u },
  { (const char *)0x8134B17, 8201933u },
  { (const char *)0x8134C17, 16711680u },
  { (const char *)0x8134C22, 15597568u },
  { (const char *)0x8134C2D, 13434880u },
  { (const char *)0x8134C38, 9109504u },
  { "rosy brown", 12357519u },
  { &unk_8134D81, 16761281u },
  { &unk_8134D8C, 15643828u },
  { &unk_8134D97, 13474715u },
  { &unk_8134DA2, 9136489u },
  { &unk_8134DAD, 9127187u },
  { (const char *)0x8134900, 16747625u },
  { (const char *)0x813490D, 15630946u },
  { (const char *)0x813491A, 13463636u },
  { (const char *)0x8134927, 9129017u },
  { "sandy brown", 16032864u },
  { "seashell1", 16774638u },
  { "seashell2", 15656414u },
  { "seashell3", 13485503u },
  { "seashell4", 9143938u },
  { "sienna1", 16745031u },
  { "sienna2", 15628610u },
  { "sienna3", 13461561u },
  { "sienna4", 9127718u },
  { (const char *)0x8134935, 8900331u },
  { (const char *)0x8134943, 8900351u },
  { (const char *)0x8134951, 8306926u },
  { (const char *)0x813495F, 7120589u },
  { (const char *)0x8134B26, 6970061u },
  { "slateblue1", 8613887u },
  { "slateblue2", 8021998u },
  { "slateblue3", 6904269u },
  { &unk_813498E, 7372944u },
  { (const char *)0x81341F8, 13034239u },
  { (const char *)0x8134207, 12178414u },
  { (const char *)0x8134216, 10467021u },
  { "slategray4", 7109515u },
  { &unk_813499F, 7372944u },
  { (const char *)0x81349AF, 7372944u },
  { "snow1", 16775930u },
  { "snow2", 15657449u },
  { "snow3", 13486537u },
  { "snow4", 9144713u },
  { "tan1", 16753999u },
  { "tan2", 15637065u },
  { "tan3", 13468991u },
  { "tan4", 9132587u },
  { "thistle1", 16769535u },
  { "thistle2", 15651566u },
  { "thistle3", 13481421u },
  { "thistle4", 9141131u },
  { "tomato1", 16737095u },
  { "tomato2", 15621186u },
  { "tomato3", 13455161u },
  { "tomato4", 9123366u },
  { (const char *)0x8134CC8, 13639824u },
  { (const char *)0x8133DDE, 13639824u },
  { (const char *)0x8134CD7, 16727702u },
  { (const char *)0x8134CE6, 15612556u },
  { (const char *)0x8134CF5, 13447800u },
  { (const char *)0x8134D04, 9118290u },
  { "wheat1", 16771002u },
  { "wheat2", 15653038u },
  { "wheat3", 13482646u },
  { "wheat4", 9141862u },
  { "white smoke", 16119285u },
  { (const char *)0x8134A1C, 16776960u },
  { (const char *)0x8134A29, 15658496u },
  { (const char *)0x8134A36, 13487360u },
  { (const char *)0x8134A43, 9145088u },
  { "yellow green", 10145074u },
  { NULL, 0u }
}; // idb
const unsigned __int8 lnum_5845[17] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  0u
}; // idb
const unsigned __int8 unum_5844[17] =
{
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  0u
}; // idb
action_id_T CSWTCH_247[29] =
{
  94,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  95,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  96
}; // weak
const unsigned __int8 byte_8113370 = 10u; // idb
const unsigned __int8 byte_811A318 = 68u; // idb
const unsigned __int8 byte_811AAEC = 84u; // idb
char byte_811ED68 = '~'; // weak
char byte_811F00C = '~'; // weak
const unsigned __int8 byte_812122C = 65u; // idb
const unsigned __int8 byte_8121994 = 32u; // idb
const unsigned __int8 byte_8123E44 = 65u; // idb
const unsigned __int8 byte_812419C = 87u; // idb
const unsigned __int8 byte_81241DC = 87u; // idb
const unsigned __int8 byte_8124214 = 80u; // idb
const unsigned __int8 byte_8124244 = 84u; // idb
const unsigned __int8 byte_8124F48 = 87u; // idb
char byte_8125A54 = 'F'; // weak
const unsigned __int8 byte_812757A = 40u; // idb
const unsigned __int8 byte_812757C = 41u; // idb
const unsigned __int8 str = 78u; // idb
const unsigned __int8 okbutton = 126u; // idb
const unsigned __int8 msgid = 67u; // idb
const unsigned __int8 cancelbutton = 126u; // idb
const unsigned __int8 byte_8127850 = 117u; // idb
const char byte_812785C = 'n'; // idb
const unsigned __int8 byte_81279A0 = 84u; // idb
const unsigned __int8 byte_81279A6 = 10u; // idb
const unsigned __int8 byte_81279FF = 83u; // idb
const unsigned __int8 byte_8127A45 = 69u; // idb
const unsigned __int8 byte_8127BDB = 83u; // idb
const unsigned __int8 byte_8127C0B = 76u; // idb
const unsigned __int8 byte_8127C1E = 83u; // idb
const unsigned __int8 byte_8127C2F = 105u; // idb
const unsigned __int8 byte_8127C42 = 69u; // idb
char byte_8127CFF[7] = { 'O', 'u', 't', ' ', 'o', 'f', ' ' }; // weak
const unsigned __int8 byte_8127F34 = 97u; // idb
const unsigned __int8 byte_81281C9 = 10u; // idb
const unsigned __int8 ptr = 10u; // idb
const unsigned __int8 byte_81281CD = 10u; // idb
const unsigned __int8 byte_81281D1 = 35u; // idb
const unsigned __int8 byte_81281E4 = 117u; // idb
const unsigned __int8 byte_81283B4 = 68u; // idb
const unsigned __int8 label = 86u; // idb
const unsigned __int8 byte_81283CA = 40u; // idb
const unsigned __int8 byte_81283FD = 83u; // idb
const unsigned __int8 path = 46u; // idb
const unsigned __int8 byte_81296C1 = 67u; // idb
const unsigned __int8 byte_8129B1D = 85u; // idb
const unsigned __int8 byte_8129ED7 = 77u; // idb
const unsigned __int8 byte_812A18A = 67u; // idb
const unsigned __int8 byte_812A3D0 = 83u; // idb
const unsigned __int8 byte_812A3F7 = 85u; // idb
const unsigned __int8 byte_812A40E = 82u; // idb
const unsigned __int8 byte_812A438 = 66u; // idb
const unsigned __int8 byte_812A452 = 84u; // idb
const unsigned __int8 byte_812B299 = 65u; // idb
const unsigned __int8 byte_812B2A4 = 83u; // idb
const unsigned __int8 item = 83u; // idb
const unsigned __int8 byte_812B2B7 = 68u; // idb
const unsigned __int8 byte_812B2BE = 83u; // idb
const unsigned __int8 byte_812B2C5 = 80u; // idb
const unsigned __int8 byte_812B2CA = 97u; // idb
const unsigned __int8 byte_812B311 = 67u; // idb
const unsigned __int8 byte_812B3D6 = 68u; // idb
const unsigned __int8 byte_812B3DB = 76u; // idb
const unsigned __int8 byte_812B3F3 = 76u; // idb
const unsigned __int8 byte_812B3FE = 76u; // idb
const unsigned __int8 byte_812B409 = 76u; // idb
const unsigned __int8 byte_812B429 = 76u; // idb
const unsigned __int8 bytes = 46u; // idb
char byte_812B444 = '.'; // weak
const unsigned __int8 byte_812B447 = 68u; // idb
const unsigned __int8 byte_812B450 = 126u; // idb
const unsigned __int8 byte_812B45C = 66u; // idb
const unsigned __int8 byte_812B474 = 126u; // idb
const unsigned __int8 byte_812B47B = 65u; // idb
const unsigned __int8 byte_812B51E = 82u; // idb
const unsigned __int8 msgid1 = 37u; // idb
const unsigned __int8 byte_812B53F = 37u; // idb
const unsigned __int8 byte_812B557 = 37u; // idb
const unsigned __int8 byte_812B576 = 37u; // idb
const unsigned __int8 byte_812B585 = 37u; // idb
const unsigned __int8 byte_812B596 = 37u; // idb
const unsigned __int8 byte_812B5A4 = 37u; // idb
const unsigned __int8 byte_812B5B7 = 37u; // idb
const unsigned __int8 byte_812B5CA = 37u; // idb
const unsigned __int8 byte_812B5D5 = 37u; // idb
const unsigned __int8 byte_812B5E1 = 68u; // idb
const unsigned __int8 byte_812B5F0 = 37u; // idb
const unsigned __int8 byte_812B5FE = 37u; // idb
const unsigned __int8 byte_812B60D = 73u; // idb
const unsigned __int8 byte_812B61A = 109u; // idb
const unsigned __int8 byte_812B62A = 115u; // idb
const unsigned __int8 byte_812B639 = 37u; // idb
const unsigned __int8 byte_812B654 = 37u; // idb
const unsigned __int8 byte_812B6C4 = 83u; // idb
const unsigned __int8 byte_812B6C9 = 85u; // idb
const unsigned __int8 byte_812B7D6 = 68u; // idb
const unsigned __int8 byte_812B7E3 = 70u; // idb
const unsigned __int8 byte_812B807 = 76u; // idb
const unsigned __int8 byte_812B83A = 84u; // idb
const unsigned __int8 byte_812BB28 = 82u; // idb
const unsigned __int8 byte_812BB38 = 87u; // idb
const unsigned __int8 byte_812BB3F = 72u; // idb
const unsigned __int8 byte_812BB47 = 70u; // idb
const unsigned __int8 byte_812BB57 = 78u; // idb
const unsigned __int8 byte_812BB61 = 86u; // idb
const unsigned __int8 byte_812BB6F = 76u; // idb
const unsigned __int8 byte_812BB84 = 70u; // idb
const unsigned __int8 byte_812BB93 = 75u; // idb
const unsigned __int8 byte_812BBA1 = 67u; // idb
const unsigned __int8 buf = 58u; // idb
const unsigned __int8 byte_812BBAD = 78u; // idb
const unsigned __int8 byte_812BBBE = 49u; // idb
const unsigned __int8 byte_812BBC8 = 56u; // idb
const unsigned __int8 byte_812BBD2 = 50u; // idb
const unsigned __int8 byte_812BBDD = 82u; // idb
_UNKNOWN unk_812BBF4; // weak
const unsigned __int8 byte_812BC2E = 69u; // idb
const unsigned __int8 byte_812BD8B = 85u; // idb
const unsigned __int8 byte_812BD94 = 78u; // idb
_UNKNOWN unk_812BDA0; // weak
const unsigned __int8 byte_812C04C = 67u; // idb
const unsigned __int8 byte_812C403 = 47u; // idb
const unsigned __int8 byte_812C4E0 = 110u; // idb
const unsigned __int8 byte_812C537 = 91u; // idb
const unsigned __int8 byte_812C62E = 104u; // idb
const unsigned __int8 byte_812C668 = 73u; // idb
const unsigned __int8 byte_812C755 = 47u; // idb
const unsigned __int8 byte_812C8D7 = 99u; // idb
const unsigned __int8 byte_812CAEA = 85u; // idb
const unsigned __int8 byte_812E2FC = 103u; // idb
_UNKNOWN unk_812E3D7; // weak
const char delete = '\0'; // idb
const unsigned __int8 byte_812F636 = 111u; // idb
char byte_8131543[7] = { 'f', 'i', 'l', 'e', ':', '/', '/' }; // weak
const unsigned __int8 byte_813154A = 47u; // idb
const unsigned __int8 byte_8131601 = 66u; // idb
const unsigned __int8 byte_8131610 = 84u; // idb
const unsigned __int8 byte_8131621 = 83u; // idb
const unsigned __int8 byte_813162A = 70u; // idb
const unsigned __int8 byte_813169A = 69u; // idb
const unsigned __int8 byte_81316A4 = 69u; // idb
const unsigned __int8 byte_8131AED = 85u; // idb
const unsigned __int8 byte_8131C02 = 109u; // idb
const unsigned __int8 byte_8131EF1 = 60u; // idb
const unsigned __int8 byte_8132214 = 78u; // idb
const unsigned __int8 byte_81323EC = 58u; // idb
const unsigned __int8 byte_8132433 = 99u; // idb
const unsigned __int8 byte_81324BF = 69u; // idb
const unsigned __int8 byte_81325FF = 72u; // idb
const unsigned __int8 byte_81327E1 = 99u; // idb
const unsigned __int8 realm = 70u; // idb
const char byte_8132982 = 'H'; // idb
const unsigned __int8 byte_8132B67 = 84u; // idb
const unsigned __int8 byte_8132C10 = 37u; // idb
const unsigned __int8 byte_8132CAD = 80u; // idb
const unsigned __int8 byte_8132CE9 = 84u; // idb
const unsigned __int8 byte_8132CF2 = 69u; // idb
const unsigned __int8 byte_8132D6A = 32u; // idb
const unsigned __int8 byte_8132E34 = 100u; // idb
const unsigned __int8 byte_8132E42 = 65u; // idb
const unsigned __int8 byte_8132E65 = 80u; // idb
const unsigned __int8 byte_8132EA7 = 80u; // idb
const unsigned __int8 byte_81335AB = 47u; // idb
const unsigned __int8 byte_813367E = 69u; // idb
const unsigned __int8 byte_8133692 = 58u; // idb
const unsigned __int8 byte_8133721 = 66u; // idb
const unsigned __int8 byte_8133734 = 126u; // idb
const unsigned __int8 byte_813373A = 126u; // idb
const unsigned __int8 byte_8133743 = 83u; // idb
const unsigned __int8 byte_81337BF = 85u; // idb
const unsigned __int8 byte_81337D5 = 58u; // idb
const unsigned __int8 byte_81338CA = 70u; // idb
const unsigned __int8 byte_8134F90 = 32u; // idb
const unsigned __int8 byte_8134F91 = 32u; // idb
const unsigned __int8 byte_8134F94 = 32u; // idb
const unsigned __int8 byte_8134F95 = 32u; // idb
const unsigned __int8 byte_8134F98 = 32u; // idb
const char s[3] = "   "; // idb
const unsigned __int8 start = 32u; // idb
char byte_8135046 = 'C'; // weak
char byte_813505B[16] =
{
  'C',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'g',
  'e',
  't',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' '
}; // weak
char byte_8135072 = 'C'; // weak
char byte_8135089 = 'C'; // weak
char byte_81350A1 = 'C'; // weak
char byte_81350B8 = 'C'; // weak
char byte_81350CE = 'S'; // weak
const unsigned __int8 byte_8135106 = 117u; // idb
const unsigned __int8 byte_81353DD = 68u; // idb
const unsigned __int8 byte_8135437 = 126u; // idb
const unsigned __int8 byte_813545D = 126u; // idb
const unsigned __int8 byte_81354EA = 78u; // idb
const unsigned __int8 byte_8135628 = 83u; // idb
const unsigned __int8 byte_8135638 = 67u; // idb
const unsigned __int8 byte_8135647 = 67u; // idb
int (*dword_8136FFC)(void) = NULL; // weak
option_info led_options[7] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &aClock,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDigitalClockIn,
      &aClock_0,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812774B,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhetherToDispl,
      &aEnable,
      NULL,
      NULL,
      NULL
    },
    &unk_812777A
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFormat,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHM },
      &aFormatStringFo,
      &aFormat_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812777A
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aClock,
      0,
      OPT_ALIAS,
      0,
      8,
      { &unk_812777A },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aUiTimer
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLeds,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aLedsVisualIndi,
      &aLeds_0,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812774B,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aEnableLedsThes,
      &aEnable,
      NULL,
      NULL,
      NULL
    },
    &unk_81277A0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
unsigned __int8 m_submenu[3] = { 62u, 62u, 0u }; // idb
list_head_elinks bookmarks = { &bookmarks, &bookmarks }; // idb
int update_bookmark_event_id_7606 = -1; // idb
int delete_bookmark_event_id_7397 = -1; // idb
hierbox_browser bookmark_browser =
{
  &aBookmarkManage_0,
  NULL,
  &bookmark_buttons,
  8u,
  { (void *)0x81377D0, (void *)0x81377D0 },
  { (void *)0x81377D8, (void *)0x81377D8 },
  {
    NULL,
    NULL,
    { (void *)0x81377E8, (void *)0x81377E8 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &bookmarks_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
int move_bookmark_event_id_7252 = -1; // idb
int loaded_backend_num = -1; // idb
int readok = 1; // idb
list_head_elinks cache_entries = { &cache_entries, &cache_entries }; // idb
int id_counter = 1; // idb
hierbox_browser cache_browser =
{
  &aCacheManager_0,
  NULL,
  &cache_buttons,
  4u,
  { (void *)0x81378D0, (void *)0x81378D0 },
  { (void *)0x81378D8, (void *)0x81378D8 },
  {
    NULL,
    NULL,
    { (void *)0x81378E8, (void *)0x81378E8 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &cache_entry_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
option_info cmdline_options_info[35] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAnonymous,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aRestrictsElink,
      &aRestrictToAnon,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &byte_8127F34,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aAutomaticallyS_2,
      &aAutosubmitFirs,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBaseSession,
      0,
      OPT_INT,
      0,
      2147483647,
      { NULL },
      &aUsedInternally,
      &aCloneInternalS,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConfdir,
      OPT_HIDDEN,
      OPT_COMMAND,
      0,
      0,
      { &redir_cmd },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &name_,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aPathOfTheDirec,
      &aNameOfDirector,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConfigDump,
      0,
      OPT_COMMAND,
      0,
      0,
      { &printconfigdump_cmd },
      &aPrintAConfigur,
      &aPrintDefaultCo,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConffile,
      OPT_HIDDEN,
      OPT_COMMAND,
      0,
      0,
      { &redir_cmd },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConfigFile,
      0,
      OPT_STRING,
      0,
      1024,
      { &aElinksConf },
      &aNameOfTheConfi,
      &aNameOfConfigur,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConfigHelp,
      0,
      OPT_COMMAND,
      0,
      0,
      { &printhelp_cmd },
      &aPrintHelpForCo,
      &aPrintHelpForCo_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDefaultMimeTyp,
      0,
      OPT_ALIAS,
      0,
      17,
      { &aMimeDefaultTyp },
      &aTheDefaultMime,
      &aMimeTypeAssume,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDefaultKeys,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhenSetAllKeyb,
      &aIgnoreUserDefi,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDump,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aPrintFormatted,
      &aPrintFormatted_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_8127FB5,
      0,
      OPT_ALIAS,
      0,
      22,
      { &aDocumentDumpCo },
      &aCodepageUsedWh,
      &aCodepageToUseW,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDumpColorMode,
      0,
      OPT_ALIAS,
      0,
      24,
      { &aDocumentDumpCo_0 },
      &aColorModeUsedW,
      &unk_8128039,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_8128054,
      0,
      OPT_ALIAS,
      0,
      19,
      { &aDocumentDumpWi },
      &aWidthOfTheDump,
      &aWidthOfDocumen,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127DAD,
      0,
      OPT_COMMAND,
      0,
      0,
      { &eval_cmd },
      &aSpecifyConfigu,
      &aEvaluateConfig,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aForceHtml,
      0,
      OPT_COMMAND,
      0,
      0,
      { &forcehtml_cmd },
      &aMakesElinksAss,
      &aInterpretDocum,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8130A2D,
      0,
      OPT_COMMAND,
      0,
      0,
      { &printhelp_cmd },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813392C,
      0,
      OPT_COMMAND,
      0,
      0,
      { &printhelp_cmd },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127ED3,
      0,
      OPT_COMMAND,
      0,
      0,
      { &printhelp_cmd },
      &aPrintUsageHelp,
      &aPrintUsageHelp_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLocalhost,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aRestrictsElink_0,
      &aOnlyPermitLoca,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLongHelp,
      0,
      OPT_COMMAND,
      0,
      0,
      { &printhelp_cmd },
      &aPrintDetailedU,
      &aPrintDetailedU_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLookup,
      0,
      OPT_COMMAND,
      0,
      0,
      { &lookup_cmd },
      &aLookUpSpecifie,
      &aLookUpSpecifie_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNoConnect,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aRunElinksAsASe,
      &aRunAsSeparateI,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNoHome,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aDisablesCreati,
      &aDisableUseOfFi,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNoNumbering,
      OPT_ALIAS_NEGATE,
      OPT_ALIAS,
      0,
      23,
      { &aDocumentDumpNu },
      &aPreventsPrinti,
      &aDisableLinkNum,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNoReferences,
      OPT_ALIAS_NEGATE,
      OPT_ALIAS,
      0,
      24,
      { &aDocumentDumpRe },
      &aPreventsPrinti_0,
      &aDisablePrintin,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRemote,
      0,
      OPT_COMMAND,
      0,
      0,
      { &remote_cmd },
      &aControlARemote,
      &aControlAnAlrea,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSessionRing,
      0,
      OPT_INT,
      0,
      2147483647,
      { NULL },
      &aIdOfSessionRin,
      &aConnectToSessi,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSource,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aPrintGivenUrls,
      &aPrintTheSource,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aStdin,
      OPT_HIDDEN,
      OPT_COMMAND,
      0,
      0,
      { &redir_cmd },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTouchFiles,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhenEnabledRun,
      &aTouchFilesInEl,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aVerbose,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)1 },
      &aTheVerboseLeve,
      &aVerboseLevel,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aVersion_0,
      0,
      OPT_COMMAND,
      0,
      0,
      { &version_cmd },
      &aPrintElinksVer,
      &aPrintVersionIn,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
int indentation = 2; // idb
int comments = 3; // idb
hierbox_browser option_browser =
{
  &aOptionManager,
  NULL,
  &option_buttons,
  6u,
  { (void *)0x81381D0, (void *)0x81381D0 },
  { (void *)0x81381D8, (void *)0x81381D8 },
  {
    NULL,
    NULL,
    { (void *)0x81381E8, (void *)0x81381E8 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &options_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
hierbox_browser keybinding_browser =
{
  &aKeybindingMana_0,
  NULL,
  &keybinding_buttons,
  5u,
  { (void *)0x8138250, (void *)0x8138250 },
  { (void *)0x8138258, (void *)0x8138258 },
  {
    NULL,
    NULL,
    { (void *)0x8138268, (void *)0x8138268 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &keybinding_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
keymap keymap_table[3] =
{
  { &aMain, KEYMAP_MAIN, &unk_81284CC },
  { (unsigned __int8 *)0x8135380, KEYMAP_EDIT, &aEditMapping },
  { &aMenu, KEYMAP_MENU, &aMenuMapping }
}; // idb
action_list action_table[3] =
{
  { &main_action_table, 120 },
  { &edit_action_table, 31 },
  { &menu_action_table, 22 }
}; // idb
option_info config_options_info[414] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConfig,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aConfigurationH,
      &aConfigurationS,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128220,
      0,
      OPT_INT,
      0,
      3,
      { (list_head_elinks *)3 },
      &aAmountOfCommen,
      &aComments,
      NULL,
      NULL,
      NULL
    },
    &aConfig
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812820D,
      0,
      OPT_INT,
      0,
      16,
      { (list_head_elinks *)2 },
      &aShiftWidthOfOn,
      &aIndentation,
      NULL,
      NULL,
      NULL
    },
    &aConfig
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127E36,
      0,
      OPT_INT,
      0,
      3,
      { (list_head_elinks *)3 },
      &aDeterminesWhat,
      &unk_8129666,
      NULL,
      NULL,
      NULL
    },
    &aConfig
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81281FD,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aIfSetTo1Commen,
      &aCommentsLocali,
      NULL,
      NULL,
      NULL
    },
    &aConfig
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813375F,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aThisIsInternal,
      &aSavingStyleWar,
      NULL,
      NULL,
      NULL
    },
    &aConfig
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81294C7,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aShowTemplateOp,
      &aShowTemplate,
      NULL,
      NULL,
      NULL
    },
    &aConfig
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConnection_1,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aConnectionOpti,
      &byte_81296C1,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8131AA0,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToUseAs,
      &aAsynchronousDn,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8131A50,
      0,
      OPT_INT,
      1,
      16,
      { (list_head_elinks *)0xA },
      &aMaximumNumberO_0,
      &aMaximumConnect,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMaxConnections,
      0,
      OPT_INT,
      1,
      8,
      { (list_head_elinks *)2 },
      &aMaximumNumberO_1,
      &aMaximumConnect_0,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRetries,
      0,
      OPT_INT,
      0,
      16,
      { (list_head_elinks *)3 },
      &aNumberOfTriesT,
      &unk_8129727,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81319A5,
      0,
      OPT_INT,
      1,
      1800,
      { (list_head_elinks *)0x78 },
      &aReceiveTimeout_0,
      &aReceiveTimeout,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8131AE4,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToTryTo,
      &aTryIpv4WhenCon,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8131AD0,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToTryTo_0,
      &aTryIpv6WhenCon,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aUnrestartableR,
      0,
      OPT_INT,
      1,
      1800,
      { (list_head_elinks *)0x258 },
      &aTimeoutForNonR,
      &aTimeoutForNonR_0,
      NULL,
      NULL,
      NULL
    },
    &aConnection_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDocument,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDocumentOption,
      &aDocument_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81297F1,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDocumentBrowsi,
      &aBrowsing,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAccesskey,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForHand,
      &aAccessKeys,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAutoFollow,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aAutomaticallyF,
      &aAutomaticLinks,
      NULL,
      NULL,
      NULL
    },
    &unk_812981E
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812840B,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aDisplayAccessK,
      &aDisplayAccessK_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812981E
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPriority,
      0,
      OPT_INT,
      0,
      2,
      { NULL },
      &aPriorityOfAcce,
      &unk_8129838,
      NULL,
      NULL,
      NULL
    },
    &unk_812981E
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aForms,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForHand_0,
      &aForms_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAutoSubmit,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aAutomagicallyS,
      &aSubmitFormAuto,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_47
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aConfirmSubmit,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aAskForConfirma,
      &aConfirmSubmiss,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_47
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aInputSize,
      0,
      OPT_INT,
      3,
      300,
      { (list_head_elinks *)0x14 },
      &aDefaultFormInp,
      &aDefaultFormInp_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_47
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aInsertMode,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aTheSettingForT,
      &aInsertMode_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_47
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEditor_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aPathToTheExecu,
      &unk_81298EA,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_47
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aImages,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForHand_1,
      &aImages_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDisplayStyle,
      0,
      OPT_INT,
      0,
      3,
      { (list_head_elinks *)2 },
      &aDisplayStyleFo,
      &aDisplayStyleFo_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFilenameMaxlen,
      0,
      OPT_INT,
      0,
      500,
      { NULL },
      &aMaximumLengthO,
      &aMaximumLengthF,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFileTags,
      0,
      OPT_ALIAS,
      0,
      38,
      { &aDocumentBrowse_16 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aImageLinkTaggi,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)1 },
      &aWhenToEncloseI,
      &aImageLinksTagg,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aImageLinkPrefi,
      0,
      OPT_STRING,
      0,
      1024,
      { (list_head_elinks *)0x812CC65 },
      &aPrefixStringTo,
      &aImageLinkPrefi_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aImageLinkSuffi,
      0,
      OPT_STRING,
      0,
      1024,
      { (list_head_elinks *)0x8127578 },
      &aSuffixStringTo,
      &aImageLinkSuffi_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLabelMaxlen,
      0,
      OPT_INT,
      0,
      500,
      { NULL },
      &aMaximumLengthO_0,
      &aMaximumLengthF_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aShowAsLinks,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aDisplayLinksTo,
      &aDisplayLinksTo_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aShowAnyAsLinks,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aDisplayLinksTo_1,
      &unk_81299F9,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_48
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLinks,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForHand_2,
      (unsigned __int8 *)0x812BDA4,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aActiveLink,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForTheA,
      &aActiveLink_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aColors,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aActiveLinkColo,
      &aColors_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_46
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &a0000ff },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_50
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_50
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEnableColor,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aEnableUseOfThe,
      &aEnableColor_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_46
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBold,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aMakeTheActiveL,
      &aBold_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_46
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aInvert,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aInvertTheForeA,
      &aInvertColors,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_46
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81295A5,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aUnderlineTheAc,
      &byte_8129B1D,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_46
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aColorDirs,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aHighlightLinks_0,
      &aDirectoryHighl,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNumbering,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aDisplayNumbers,
      &aNumberLinks,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTargetBlank,
      0,
      OPT_INT,
      0,
      3,
      { NULL },
      &aDefineHowToHan,
      &unk_8129B63,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTypeaheadWrapa,
      0,
      OPT_ALIAS,
      0,
      33,
      { &aDocumentBrowse_35 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTypeaheadError,
      0,
      OPT_ALIAS,
      0,
      37,
      { &aDocumentBrowse },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aUseTabindex,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToNavig,
      &unk_8129BAF,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMissingFragmen_0,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aOpenAMessageBo,
      &aMissingFragmen_1,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNumberKeysSele,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)1 },
      &aNumberKeysSele_0,
      &aNumberKeysSele_1,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aWarnMalicious,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhenFollowingA,
      &aWarnAboutMalic,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81339EA,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhenPressingDo,
      &aWrapAroundLink,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_49
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aScrolling,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aScrollingOptio,
      &aScrolling_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHorizontalStep,
      0,
      OPT_INT,
      1,
      9999,
      { (list_head_elinks *)8 },
      &aNumberOfColumn,
      &aHorizontalStep_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_51
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHorizontalExte,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToAllow,
      &unk_8129CAD,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_51
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMargin,
      0,
      OPT_INT,
      0,
      20,
      { (list_head_elinks *)3 },
      &aSizeOfTheVirtu,
      &aMargin_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_51
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aVerticalStep,
      0,
      OPT_INT,
      1,
      9999,
      { (list_head_elinks *)2 },
      &aNumberOfLinesT,
      &aVerticalStep_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_51
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSearch_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForSear,
      &aSearching,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813558B,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhetherTheSear,
      &aCaseSensitivit,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_32
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_8129D37,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToShowA,
      &aShowSearchHitT,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_32
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81339EA,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWrapAroundWhen,
      &aWraparound,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_32
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aShowNotFound,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)2 },
      &aHowToInformThe,
      &aShowNotFound_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_32
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128F62,
      0,
      OPT_INT,
      0,
      2,
      { NULL },
      &aStartTypeahead,
      &aTypeaheadSearc,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_32
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BE4B,
      0,
      OPT_INT,
      0,
      9,
      { (list_head_elinks *)3 },
      &aHorizontalText,
      &unk_8129DA0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRefresh_1,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aAutomaticallyF_0,
      &unk_8129DB7,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMinimumRefresh,
      0,
      OPT_INT,
      0,
      2147483647,
      { (list_head_elinks *)0x3E8 },
      &aTheMinimumNumb,
      &aDocumentMetaRe,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTableMoveOrder,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aMoveByColumnsI,
      &unk_8129DF3,
      NULL,
      NULL,
      NULL
    },
    &aDocumentBrowse_45
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCache,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aCacheOptions,
      &aCache_0,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCacheRedirects,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aCacheEvenRedir,
      &aCacheInformati,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCache
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aIgnoreCacheCon,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aIgnoreCacheCon_0,
      &aIgnoreCacheCon_1,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCache
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFormat,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aFormatCacheOpt,
      &aFormattedDocum,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCache
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127BF1,
      0,
      OPT_INT,
      0,
      256,
      { (list_head_elinks *)5 },
      &aNumberOfCached,
      &aNumber,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCacheF_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRevalidationIn,
      0,
      OPT_INT,
      -1,
      86400,
      { (list_head_elinks *)0xFFFFFFFF },
      &aPeriodInSecond,
      &aRevalidationIn_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCache
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMemory,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMemoryCacheOpt,
      &byte_8129ED7,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCache
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127BF1,
      0,
      OPT_LONG,
      0,
      2147483647,
      { (list_head_elinks *)0x100000 },
      &aMemoryCacheSiz,
      &byte_8127BDB,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCacheM_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCodepage_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aCharsetOptions,
      (unsigned __int8 *)0x812C061,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BE34,
      0,
      OPT_CODEPAGE,
      0,
      0,
      { &aSystem_0 },
      &aDefaultDocumen,
      &unk_8129F29,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCodepa_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_8129F4C,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aIgnoreCharsetI,
      &aIgnoreCharsetI_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentCodepa_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aColors,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDefaultDocumen_0,
      &aDefaultColorSe,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBfbfbf },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &a000000 },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLink,
      0,
      OPT_COLOR,
      0,
      0,
      { &a0000ff },
      &aDefaultLinkCol,
      &aLinkColor,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BEC8,
      0,
      OPT_COLOR,
      0,
      0,
      { &aFfff00 },
      &aDefaultVisited,
      &aVisitedLinkCol,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aImage,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkolivegreen },
      &aDefaultImageLi,
      &aImageLinkColor,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81279C1,
      0,
      OPT_COLOR,
      0,
      0,
      { &aHotpink },
      &aDefaultBookmar_0,
      &aBookmarkedLink,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81326E1,
      0,
      OPT_COLOR,
      0,
      0,
      { &aFfff00 },
      &aDefaultDirecto,
      &aDirectoryColor,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_812A04F,
      OPT_ALIAS_NEGATE,
      OPT_ALIAS,
      0,
      33,
      { &aDocumentColors_6 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aIncreaseContra,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aIncreaseTheCon,
      &aIncreaseContra_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEnsureContrast,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aMakesSureThatT,
      &aEnsureContrast_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aUseDocumentCol,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)2 },
      &aUseColorsSpeci,
      &aUseDocumentSpe,
      NULL,
      NULL,
      NULL
    },
    &aDocumentColors_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDownload,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsRegardi,
      &aDownloading,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDirectory_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &uristring },
      &aDefaultDownloa,
      &unk_812A104,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDownlo_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSetOriginalTim,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aSetTheTimestam,
      &aSetOriginalTim_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDownlo_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81336C0,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)2 },
      &aPreventOverwri,
      &aPreventOverwri_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDownlo_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8133672,
      0,
      OPT_INT,
      0,
      2,
      { NULL },
      &aAudioNotificat,
      &aNotifyDownload,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDownlo_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDump,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDumpOutputOpti,
      &aDumpOutput,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCodepage_0,
      0,
      OPT_CODEPAGE,
      0,
      0,
      { &aSystem_0 },
      &aCodepageUsedIn,
      &byte_812A18A,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128012,
      0,
      OPT_INT,
      -1,
      4,
      { (list_head_elinks *)0xFFFFFFFF },
      &aColorModeForDu,
      &aColorMode,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8135195,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aFooterStringUs,
      &aFooter,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHeader,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aHeaderStringUs,
      &aHeader_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aNumbering,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToPrint,
      &aNumbering_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128160,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherToPrint_0,
      &aReferences,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSeparator_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &ptr },
      &aStringWhichSep,
      &aSeparator_1,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aWidth,
      0,
      OPT_INT,
      1,
      65536,
      { (list_head_elinks *)0x50 },
      &aWidthOfScreenI,
      &aWidth_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentDump
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812E257,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aHistoryOptions,
      &aHistory,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aKeepUnhistory,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aKeepUnhistoryF,
      &aKeepUnhistory_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHistor_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128093,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsConcern,
      &aHtmlRendering,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BFA3,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aDisplayFrames,
      &aDisplayFrames_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BF86,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aDisplayTables,
      &aDisplayTables_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BFC0,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aDisplaySubscri,
      &aDisplaySubscri_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BFDB,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aDisplaySupersc,
      &aDisplaySupersc_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BE66,
      0,
      OPT_INT,
      0,
      5,
      { (list_head_elinks *)2 },
      &aHowToRenderLin,
      &aRenderingOfHtm,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BF50,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aUnderlineLinks,
      &unk_812A2B3,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BF6E,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aIfSetDoNotHono,
      &aWrapNonBreakin,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHtml
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8129136,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsConcern_0,
      &aPlainRendering,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BF34,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aDisplayUrisInT,
      &aDisplayUris,
      NULL,
      NULL,
      NULL
    },
    &aDocumentPlain
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCompressEmptyL,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aCompressSucces,
      &aCompressEmptyL_0,
      NULL,
      NULL,
      NULL
    },
    &aDocumentPlain
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812A346,
      OPT_SORT|OPT_AUTOCREATE,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aRulesForPassin,
      &aUriPassing,
      NULL,
      NULL,
      NULL
    },
    &aDocument
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTemplate,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aARuleForPassin,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aDocumentUriPas
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aInfofiles,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForInfo,
      &aInformationFil,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812B1AA,
      0,
      OPT_INT,
      0,
      2147483647,
      { (list_head_elinks *)0x12C },
      &aIntervalAtWhic,
      &aSaveInterval,
      NULL,
      NULL,
      NULL
    },
    &aInfofiles
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812B111,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aFirstWriteData,
      &aUseSecureFileS,
      NULL,
      NULL,
      NULL
    },
    &aInfofiles
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8135025,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhenUsingSecur,
      &aUseFsync3WithS,
      NULL,
      NULL,
      NULL
    },
    &aInfofiles
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTerminal,
      OPT_AUTOCREATE,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTerminalOption_0,
      &aTerminals,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTemplate,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsSpecifi,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aTerminal
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aType,
      0,
      OPT_INT,
      0,
      4,
      { NULL },
      &aTerminalTypeMa,
      &byte_8132B67,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLatin1Title,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhenUpdatingTh,
      &aAlwaysEncodeXt,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8129551,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aSwitchFontsWhe,
      &byte_812A3D0,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aUtf8Io,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aEnableIOInUtf8,
      &byte_812A3F7,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRestrict852,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aRestrictTheCha,
      &byte_812A40E,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBlockCursor,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aMoveCursorToBo,
      &byte_812A438,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aColors,
      0,
      OPT_INT,
      0,
      4,
      { NULL },
      &aTheColorModeCo,
      &aColorMode,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTransparency,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aIfWeShouldNotS,
      &byte_812A452,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81295A5,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aIfWeShouldUseU,
      &byte_8129B1D,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCharset,
      0,
      OPT_CODEPAGE,
      0,
      0,
      { &aSystem_0 },
      &aCodepageOfChar,
      &byte_812A18A,
      NULL,
      NULL,
      NULL
    },
    &aTerminalTempla
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aUi,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUserInterfaceO,
      &aUserInterface,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aColors,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDefaultUserInt,
      &aColorSettings,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aColor,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aColorSettingsF,
      &aColorTerminals,
      NULL,
      NULL,
      NULL
    },
    &aUiColors
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_812785A,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aColorSettingsF_0,
      &aNonColorTermin,
      NULL,
      NULL,
      NULL
    },
    &aUiColors
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMainmenu,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuBarCol,
      &aMainMenuBar,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMainmenu,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuBarCol,
      &aMainMenuBar,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUnselectedMain,
      &aUnselectedMain_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUnselectedMain,
      &aUnselectedMain_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812A51E
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSelectedMainMe,
      &aSelectedMainMe_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSelectedMainMe,
      &aSelectedMainMe_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812A51E
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHotkey,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuHotkey,
      &aHotkey_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHotkey,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuHotkey,
      &aHotkey_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812A51E
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuUnsele,
      &aUnselectedHotk,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuUnsele,
      &aUnselectedHotk,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuSelect,
      &unk_812A58C,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMainMenuSelect,
      &unk_812A58C,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMa_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMenu,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuBarColors,
      &aMenuBar,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMenu,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuBarColors,
      &aMenuBar,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUnselectedMenu,
      &aUnselectedMenu_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUnselectedMenu,
      &aUnselectedMenu_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A62D
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A62D
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSelectedMenuIt,
      &aSelectedMenuIt_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSelectedMenuIt,
      &aSelectedMenuIt_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A694
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A694
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812A70B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMarkedMenuItem,
      &aMarkedMenuItem_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { (list_head_elinks *)0x8134C0D },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_8
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_8
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812A70B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMarkedMenuItem,
      &aMarkedMenuItem_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A6F7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A6F7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHotkey,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuItemHotkey,
      &aHotkey_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aHotkey,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuItemHotkey,
      &aHotkey_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuItemUnsele,
      &aUnselectedHotk,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_10
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_10
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuItemUnsele,
      &aUnselectedHotk,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuItemSelect,
      &unk_812A58C,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_11
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_11
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuItemSelect,
      &unk_812A58C,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFrame_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuFrameColor,
      &aMenuFrame_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_12
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorM_12
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFrame_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMenuFrameColor,
      &aMenuFrame_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoMe
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A79B
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A79B
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128FDB,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogColors,
      &aDialog,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128FDB,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogColors,
      &aDialog,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_ALIAS,
      0,
      41,
      { &aUiColorsColorD },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_ALIAS,
      0,
      40,
      { &aUiColorsMonoDi },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812A82D,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGenericDialogC,
      &aGeneric,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812A82D,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGenericDialogC,
      &aGeneric,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A817
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A817
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFrame_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogFrameCol,
      (unsigned __int8 *)0x812C672,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFrame_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogFrameCol,
      (unsigned __int8 *)0x812C672,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A867
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A867
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aScrollbar,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aScrollbarColor,
      &aScrollbar_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aScrollbar,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aScrollbarColor,
      &aScrollbar_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127877,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aScrollbarSelec,
      &unk_812A8BA,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127877,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aScrollbarSelec,
      &unk_812A8BA,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTitle_1,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogTitleCol,
      &byte_81279A0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTitle_1,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogTitleCol,
      &byte_81279A0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A8FF
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A8FF
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogTextColo,
      &aText_1,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogTextColo,
      &aText_1,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812A950
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812A950
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCheckbox,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogCheckbox_2,
      &aCheckbox_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCheckbox,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogCheckbox_2,
      &aCheckbox_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812754C,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogSelected,
      &unk_812A98C,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aYellow },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_8
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_8
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812754C,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogSelected,
      &unk_812A98C,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127585,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogCheckbox_3,
      &unk_812A9BC,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127585,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogCheckbox_3,
      &unk_812A9BC,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aButton,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogButtonCo,
      &aButton_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_10
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_10
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aButton,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogButtonCo,
      &aButton_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AA06
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AA06
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81274EB,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogSelected_0,
      &unk_812AA23,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aYellow },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_11
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_11
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81274EB,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogSelected_0,
      &unk_812AA23,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127502,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogButtonCo,
      &aButtonShortcut,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aYellow },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_12
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_12
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127502,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogButtonCo,
      &aButtonShortcut,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aButtonShortcut_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogSelected_0,
      &aSelectedButton,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_8118F68
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_8118F68
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aButtonShortcut_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogSelected_0,
      &aSelectedButton,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_8
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_8
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813525E,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogTextFiel,
      &aTextField,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_13
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_13
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813525E,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogTextFiel,
      &aTextField,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AAB7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AAB7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81276C2,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogFieldTex_0,
      &unk_812AAED,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aYellow },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_14
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_14
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81276C2,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogFieldTex_0,
      &unk_812AAED,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_9
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AB4B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogMeterCol,
      &aMeter,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_15
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlue },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_15
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AB4B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogMeterCol,
      &aMeter,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AB35
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AB35
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AB8C,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogShadowCo,
      &aShadow,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_16
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorD_16
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AB8C,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogShadowCo,
      &aShadow,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoDi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AB76
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AB76
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTitle_1,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTitleBarColors,
      &aTitleBar,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTitle_1,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTitleBarColors,
      &aTitleBar,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BCC6,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGenericTitleBa,
      &aGenericTitleBa_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BCC6,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGenericTitleBa,
      &aGenericTitleBa_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTi_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BCDF,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTitleBarTextCo,
      &aTitleBarText,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BCDF,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTitleBarTextCo,
      &aTitleBarText,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTi_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTi_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aStatus_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aStatusBarColor,
      &aStatusBar,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aStatus_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aStatusBarColor,
      &aStatusBar,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BD80,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGenericStatusB,
      &aGenericStatusB_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BD80,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGenericStatusB,
      &aGenericStatusB_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoSt
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoSt_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoSt_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127759,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aStatusBarTextC,
      &aStatusBarText,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127759,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aStatusBarTextC,
      &aStatusBarText,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoSt
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoSt_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoSt_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127A28,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabsBarColors,
      &aTabsBar,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127A28,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabsBarColors,
      &aTabsBar,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD3B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabColorsForTa,
      &aUnvisitedTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkblue },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_3
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD3B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabColorsForTa,
      &aUnvisitedTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AD27
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AD27
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUnselectedTabC,
      &aUnselectedTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_4
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AD9B,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aUnselectedTabC,
      &aUnselectedTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AD87
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AD87
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLoading,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabColorsForTa_0,
      &aLoadingTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aDarkred },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLoading,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabColorsForTa_0,
      &aLoadingTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812ADCB
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812ADCB
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSelectedTabCol,
      &aSelectedTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGreen },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_6
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSelected,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSelectedTabCol,
      &aSelectedTab,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AE27
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AE27
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSeparator_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabSeparatorCo,
      &unk_812AE5A,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBrown },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorT_7
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSeparator_0,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTabSeparatorCo,
      &unk_812AE5A,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsMonoTa
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aGray },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AE68
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AE68
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSearched,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSearchedString,
      &aSearchedString_0,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColor
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aLime },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &aUiColorsColorS_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSearched,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSearchedString,
      &aSearchedString_0,
      NULL,
      NULL,
      NULL
    },
    &byte_8127850
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aText,
      0,
      OPT_COLOR,
      0,
      0,
      { &aBlack },
      &aDefaultTextCol,
      &aTextColor,
      NULL,
      NULL,
      NULL
    },
    &unk_812AEB5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBackground,
      0,
      OPT_COLOR,
      0,
      0,
      { &aWhite },
      &aDefaultBackgro,
      &unk_8129A99,
      NULL,
      NULL,
      NULL
    },
    &unk_812AEB5
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDialogs,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDialogsSpecifi,
      &aDialogSettings,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81277C5,
      0,
      OPT_INT,
      1,
      20,
      { (list_head_elinks *)0xA },
      &aMinimalHeightO,
      &aMinimalHeightO_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812AEDD
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aShadows,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aMakeDialogsDro,
      &unk_812AEE8,
      NULL,
      NULL,
      NULL
    },
    &unk_812AEDD
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812780B,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhetherToUnder,
      &aUnderlineMenuH,
      NULL,
      NULL,
      NULL
    },
    &unk_812AEDD
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aUnderlineButto,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhetherToUnder_0,
      &aUnderlineButto_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812AEDD
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTimer,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aTimedActionAft,
      &aTimerOptions,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812774B,
      0,
      OPT_INT,
      0,
      2,
      { NULL },
      &aWhetherToEnabl,
      &aEnable,
      NULL,
      NULL,
      NULL
    },
    &aUiTimer
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81350FD,
      0,
      OPT_INT,
      1,
      86400,
      { (list_head_elinks *)0x15180 },
      &aInactivityTime,
      &aDuration,
      NULL,
      NULL,
      NULL
    },
    &aUiTimer
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAction_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aKeybindingActi,
      &aAction,
      NULL,
      NULL,
      NULL
    },
    &aUiTimer
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127A28,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aWindowTabsSett,
      &aWindowTabs,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BC74,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)1 },
      &aShowTabsBarOnT,
      &aDisplayTabsBar,
      NULL,
      NULL,
      NULL
    },
    &aUiTabs
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812AF9F,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhetherDisplay,
      &aTabBarAtTop,
      NULL,
      NULL,
      NULL
    },
    &aUiTabs
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81339EA,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhenMovingRigh,
      &aWrapAroundTabs,
      NULL,
      NULL,
      NULL
    },
    &aUiTabs
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81339D4,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhenClosingATa,
      &aConfirmTabClos,
      NULL,
      NULL,
      NULL
    },
    &aUiTabs
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLanguage_3,
      0,
      OPT_LANGUAGE,
      0,
      0,
      { NULL },
      &aLanguageOfUser,
      &aLanguage_1,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BCAB,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aAlwaysShowMenu,
      &aDisplayMenuBar,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BC5C,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aShowStatusBarO,
      &aDisplayStatusB,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BC4A,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aShowTitleBarOn,
      &aDisplayTitleBa,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8133792,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aPopUpGotoDialo,
      &aDisplayGotoDia,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8128365,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhenYouPressed,
      &aShowAMessageBo,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812B664,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSessionsSettin,
      &aSessions_0,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aKeepSessionAct,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aKeepTheSession,
      &aKeepSessionAct_0,
      NULL,
      NULL,
      NULL
    },
    &aUiSessions
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81278DA,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aAutomaticallyS_3,
      &aAutoSaveSessio,
      NULL,
      NULL,
      NULL
    },
    &aUiSessions
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8133782,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aAutomaticallyR,
      &aAutoRestoreSes,
      NULL,
      NULL,
      NULL
    },
    &aUiSessions
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAutoSaveFolder,
      0,
      OPT_STRING,
      0,
      1024,
      { &aAutoSavedSessi },
      &aNameOfTheBookm,
      &aAutoSaveAndRes,
      NULL,
      NULL,
      NULL
    },
    &aUiSessions
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81288C2,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aTheUriToLoadEi,
      &aHomepageUri,
      NULL,
      NULL,
      NULL
    },
    &aUiSessions
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812790D,
      0,
      OPT_STRING,
      0,
      1024,
      { &aBEHM },
      &aDateFormatToUs,
      &aDateFormat,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812BC9B,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aSetTheWindowTi,
      &aSetWindowTitle_0,
      NULL,
      NULL,
      NULL
    },
    &aUi
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSecureFileSavi,
      0,
      OPT_ALIAS,
      0,
      21,
      { &aInfofilesSecur_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
list_head_elinks options_root_tree = { &options_root_tree, &options_root_tree }; // idb
option_elinks options_root =
{
  NULL,
  NULL,
  { 0 },
  &delete,
  0,
  OPT_TREE,
  0,
  0,
  { &options_root_tree },
  &delete,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
int periodic_save_event_id_4824 = -1; // idb
input_history goto_url_history = { { &goto_url_history, &goto_url_history }, 0, 0u, 0u }; // idb
module cookies_module =
{
  &aCookies_0,
  &cookies_options,
  NULL,
  NULL,
  NULL,
  &init_cookies,
  &done_cookies
}; // idb
option_info cookies_options[7] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCookies,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aCookiesOptions,
      &aCookies_0,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAcceptPolicy,
      0,
      OPT_INT,
      0,
      2,
      { (list_head_elinks *)2 },
      &aCookiesAccepti,
      &aAcceptPolicy_0,
      NULL,
      NULL,
      NULL
    },
    &aCookies
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMaxAge_0,
      0,
      OPT_INT,
      -1,
      10000,
      { (list_head_elinks *)0xFFFFFFFF },
      &aCookieMaximumA,
      &aMaximumAge,
      NULL,
      NULL,
      NULL
    },
    &aCookies
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aParanoidSecuri,
      0,
      OPT_BOOL,
      0,
      1,
      { NULL },
      &aWhenEnabledWeL,
      &aParanoidSecuri_0,
      NULL,
      NULL,
      NULL
    },
    &aCookies
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81350EF,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aWhetherCookies,
      (unsigned __int8 *)0x812B1C1,
      NULL,
      NULL,
      NULL
    },
    &aCookies
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aResave,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aSaveCookiesAft,
      &aResaving,
      NULL,
      NULL,
      NULL
    },
    &aCookies
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
list_head_elinks c_domains = { &c_domains, &c_domains }; // idb
list_head_elinks cookies = { &cookies, &cookies }; // idb
list_head_elinks cookie_servers = { &cookie_servers, &cookie_servers }; // idb
list_head_elinks cookie_queries = { &cookie_queries, &cookie_queries }; // idb
hierbox_browser cookie_browser =
{
  &aCookieManager_1,
  NULL,
  &cookie_buttons,
  7u,
  { (void *)0x813FCD0, (void *)0x813FCD0 },
  { (void *)0x813FCD8, (void *)0x813FCD8 },
  {
    NULL,
    NULL,
    { (void *)0x813FCE8, (void *)0x813FCE8 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &cookies_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
hierbox_browser download_browser =
{
  &aDownloadManage_1,
  NULL,
  &download_buttons,
  3u,
  { (void *)0x813FD90, (void *)0x813FD90 },
  { (void *)0x813FD98, (void *)0x813FD98 },
  {
    NULL,
    NULL,
    { (void *)0x813FDA8, (void *)0x813FDA8 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &downloads_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
menu_item empty_directory_menu[2] =
{
  { &aEmptyDirectory, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
input_history file_history = { { &file_history, &file_history }, 0, 0u, 0u }; // idb
menu_item main_menu[7] =
{
  {
    &aFile_1,
    NULL,
    ACT_MAIN_NONE,
    &do_file_menu,
    NULL,
    SUBMENU|FREE_LIST,
    HKS_SHOW,
    0
  },
  {
    &aView,
    NULL,
    ACT_MAIN_NONE,
    &do_submenu,
    &view_menu,
    SUBMENU|FREE_LIST,
    HKS_SHOW,
    0
  },
  {
    &unk_812B806,
    NULL,
    ACT_MAIN_NONE,
    &link_menu,
    NULL,
    SUBMENU|FREE_LIST,
    HKS_SHOW,
    0
  },
  {
    &aTools,
    NULL,
    ACT_MAIN_NONE,
    &do_submenu,
    &tools_menu,
    SUBMENU|FREE_LIST,
    HKS_SHOW,
    0
  },
  {
    &aSetup,
    NULL,
    ACT_MAIN_NONE,
    &do_setup_menu,
    NULL,
    SUBMENU|FREE_LIST,
    HKS_SHOW,
    0
  },
  {
    &aHelp,
    NULL,
    ACT_MAIN_NONE,
    &do_submenu,
    &help_menu,
    SUBMENU|FREE_LIST,
    HKS_SHOW,
    0
  },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
menu_item setup_menu[9] =
{
  {
    &unk_812B820,
    NULL,
    ACT_MAIN_NONE,
    &menu_language_list,
    NULL,
    SUBMENU,
    HKS_SHOW,
    0
  },
  {
    &aCHaracterSet,
    NULL,
    ACT_MAIN_NONE,
    &charset_list,
    NULL,
    SUBMENU,
    HKS_SHOW,
    0
  },
  {
    &unk_812B839,
    NULL,
    ACT_MAIN_SHOW_TERM_OPTIONS,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aFileExtensions,
    NULL,
    ACT_MAIN_NONE,
    &do_submenu,
    &ext_menu,
    SUBMENU,
    HKS_SHOW,
    0
  },
  { &delete, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  {
    &aOptionsManager_1,
    NULL,
    ACT_MAIN_OPTIONS_MANAGER,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &unk_812B86D,
    NULL,
    ACT_MAIN_KEYBINDING_MANAGER,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &unk_812B881,
    NULL,
    ACT_MAIN_SAVE_OPTIONS,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
menu_item setup_menu_anon[4] =
{
  {
    &unk_812B820,
    NULL,
    ACT_MAIN_NONE,
    &menu_language_list,
    NULL,
    SUBMENU,
    HKS_SHOW,
    0
  },
  {
    &aCHaracterSet,
    NULL,
    ACT_MAIN_NONE,
    &charset_list,
    NULL,
    SUBMENU,
    HKS_SHOW,
    0
  },
  {
    &unk_812B839,
    NULL,
    ACT_MAIN_SHOW_TERM_OPTIONS,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
menu_item file_menu11[7] =
{
  {
    &aOpenNewTab,
    NULL,
    ACT_MAIN_OPEN_NEW_TAB,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aOpenNewTabInBa,
    NULL,
    ACT_MAIN_OPEN_NEW_TAB_IN_BACKGROUND,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  { &unk_812B8B9, NULL, ACT_MAIN_GOTO_URL, NULL, NULL, NO_FLAG, HKS_SHOW, 0 },
  {
    &aGoBack_0,
    NULL,
    ACT_MAIN_HISTORY_MOVE_BACK,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aGoForward,
    NULL,
    ACT_MAIN_HISTORY_MOVE_FORWARD,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aHistory_0,
    NULL,
    ACT_MAIN_NONE,
    &history_menu,
    NULL,
    SUBMENU,
    HKS_SHOW,
    0
  },
  {
    &aUnhistory,
    NULL,
    ACT_MAIN_NONE,
    &unhistory_menu,
    NULL,
    SUBMENU,
    HKS_SHOW,
    0
  }
}; // idb
menu_item file_menu21[5] =
{
  { &delete, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  { &aSaveAs_1, NULL, ACT_MAIN_SAVE_AS, NULL, NULL, NO_FLAG, HKS_SHOW, 0 },
  { &aSaveUrLAs, NULL, ACT_MAIN_SAVE_URL_AS, NULL, NULL, NO_FLAG, HKS_SHOW, 0 },
  {
    &aSaVeFormattedD,
    NULL,
    ACT_MAIN_SAVE_FORMATTED,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aBookmArkDocume,
    NULL,
    ACT_MAIN_ADD_BOOKMARK,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  }
}; // idb
menu_item file_menu22[5] =
{
  { &delete, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  {
    &aKillBackground_0,
    NULL,
    ACT_MAIN_KILL_BACKGROUNDED_CONNECTIONS,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aFlushAllCaches,
    NULL,
    ACT_MAIN_CACHE_MINIMIZE,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  {
    &aResourceInfo_1,
    NULL,
    ACT_MAIN_RESOURCE_INFO,
    NULL,
    NULL,
    NO_FLAG,
    HKS_SHOW,
    0
  },
  { &delete, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 }
}; // idb
menu_item file_menu3[3] =
{
  { &delete, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  { &aEXit, NULL, ACT_MAIN_QUIT, NULL, NULL, NO_FLAG, HKS_SHOW, 0 },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
menu_item no_hist_menu[2] =
{
  { &aNoHistory, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
option_resolver resolvers[8] =
{
  { 0, &aType },
  { 1, (unsigned __int8 *)0x8129551 },
  { 2, &aRestrict852 },
  { 3, &aBlockCursor },
  { 4, &aColors },
  { 6, &aTransparency },
  { 5, &aUtf8Io },
  { 7, (unsigned __int8 *)0x81295A5 }
}; // idb
unsigned __int8 s_6003[32] =
{
  63u,
  63u,
  63u,
  63u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
list_head_elinks format_cache = { &format_cache, &format_cache }; // idb
css_stylesheet default_stylesheet = { &import_css_file, NULL, { (void *)0x8140B54, (void *)0x8140B54 }, 0 }; // idb
css_property_info css_property_info_0[10] =
{
  {
    &aBackground,
    CSS_PT_BACKGROUND,
    CSS_VT_COLOR,
    &css_parse_background_value,
    NULL
  },
  {
    &aBackgroundColo,
    CSS_PT_BACKGROUND_COLOR,
    CSS_VT_COLOR,
    &css_parse_color_value,
    NULL
  },
  { &aColor, CSS_PT_COLOR, CSS_VT_COLOR, &css_parse_color_value, NULL },
  {
    (unsigned __int8 *)0x812840B,
    CSS_PT_DISPLAY,
    CSS_VT_DISPLAY,
    &css_parse_display_value,
    NULL
  },
  {
    &aFontStyle,
    CSS_PT_FONT_STYLE,
    CSS_VT_FONT_ATTRIBUTE,
    &css_parse_font_style_value,
    NULL
  },
  {
    &aFontWeight,
    CSS_PT_FONT_WEIGHT,
    CSS_VT_FONT_ATTRIBUTE,
    &css_parse_font_weight_value,
    NULL
  },
  {
    &unk_812C1F0,
    CSS_PT_TEXT_ALIGN,
    CSS_VT_TEXT_ALIGN,
    &css_parse_text_align_value,
    NULL
  },
  {
    &aTextDecoration,
    CSS_PT_TEXT_DECORATION,
    CSS_VT_FONT_ATTRIBUTE,
    &css_parse_text_decoration_value,
    NULL
  },
  {
    &aWhiteSpace,
    CSS_PT_WHITE_SPACE,
    CSS_VT_FONT_ATTRIBUTE,
    &css_parse_white_space_value,
    NULL
  },
  { NULL, CSS_PT_NONE, CSS_VT_NONE, NULL, NULL }
}; // idb
scanner_info css_scanner_info =
{
  &css_string_mappings,
  &css_scan_table_info,
  &scan_css_tokens,
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  },
  0u
}; // idb
dom_stack_context_info dom_source_renderer_context_info =
{
  0u,
  {
    NULL,
    &render_dom_element_source,
    &render_dom_attribute_source,
    &render_dom_node_source,
    &render_dom_cdata_source,
    &render_dom_node_source,
    &render_dom_node_source,
    &render_dom_element_source,
    &render_dom_node_source,
    NULL,
    &render_dom_node_source,
    &render_dom_node_source,
    &render_dom_node_source
  },
  {
    NULL,
    &render_dom_element_end_source,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &render_dom_document_end,
    NULL,
    NULL,
    NULL
  }
}; // idb
dom_stack_context_info dom_rss_renderer_context_info =
{
  0u,
  {
    NULL,
    &dom_rss_push_element,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    &dom_rss_pop_element,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &dom_rss_pop_document,
    NULL,
    NULL,
    NULL
  }
}; // idb
int ta_cache_8356 = -1; // weak
int dword_8141184 = 0; // weak
int dword_8141188 = 0; // weak
lt_default_name lt_names[32] =
{
  { LT_START, &aStart },
  { LT_START, (unsigned __int8 *)0x812AF9F },
  { LT_START, (unsigned __int8 *)0x81288B3 },
  { LT_PARENT, &aParent },
  { LT_PARENT, (unsigned __int8 *)0x8128CDA },
  { LT_NEXT, (unsigned __int8 *)0x8133534 },
  { LT_PREV, (unsigned __int8 *)0x812B984 },
  { LT_PREV, (unsigned __int8 *)0x812909F },
  { LT_CONTENTS, &aContents },
  { LT_CONTENTS, &aToc },
  { LT_INDEX, (unsigned __int8 *)0x8129BB6 },
  { LT_GLOSSARY, &aGlossary },
  { LT_CHAPTER, &aChapter },
  { LT_SECTION, &aSection },
  { LT_SUBSECTION, &aSubsection },
  { LT_SUBSECTION, &aChild },
  { LT_SUBSECTION, &aSibling },
  { LT_APPENDIX, &aAppendix },
  { LT_HELP, (unsigned __int8 *)0x8127ED3 },
  { LT_SEARCH, &aSearch_0 },
  { LT_BOOKMARK, (unsigned __int8 *)0x81279C1 },
  { LT_ALTERNATE_LANG, &unk_812C6F5 },
  { LT_ALTERNATE_MEDIA, &unk_812C703 },
  { LT_ALTERNATE_STYLESHEET, &unk_812C70E },
  { LT_STYLESHEET, &aStylesheet },
  { LT_ALTERNATE, &aAlternate },
  { LT_COPYRIGHT, &aCopyright },
  { LT_AUTHOR, &aAuthor },
  { LT_AUTHOR, &aMade },
  { LT_AUTHOR, &aOwner },
  { LT_ICON, &aIcon },
  { LT_UNKNOWN, NULL }
}; // idb
fastfind_index ff_tags_index = { &unk_812C76C, &tags_list_reset, &tags_list_next, NULL }; // idb
element_info elements[73] =
{
  { (unsigned __int8 *)0x8132859, &html_a, NULL, 0, ET_NON_NESTABLE },
  { &aAbbr, &html_italic, NULL, 0, ET_NESTABLE },
  { &aAddress, &html_address, NULL, 2, ET_NESTABLE },
  { &aApplet_1, &html_applet, NULL, 1, ET_NON_PAIRABLE },
  { (unsigned __int8 *)0x812D2D6, &html_bold, NULL, 0, ET_NESTABLE },
  { &aBase, &html_base, NULL, 0, ET_NON_PAIRABLE },
  { &aBasefont, &html_font, NULL, 0, ET_NON_PAIRABLE },
  { &aBlockquote, &html_blockquote, NULL, 2, ET_NESTABLE },
  { &aBody, &html_body, NULL, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x8131383, &html_br, NULL, 1, ET_NON_PAIRABLE },
  { &aButton_1, &html_button, NULL, 0, ET_NESTABLE },
  { &aCaption, &html_center, NULL, 1, ET_NESTABLE },
  { &aCenter_0, &html_center, NULL, 1, ET_NESTABLE },
  { &aCode_0, &html_fixed, NULL, 0, ET_NESTABLE },
  { &aDd_3, &html_dd, NULL, 1, ET_NON_PAIRABLE },
  { &aDfn, &html_bold, NULL, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x813297E, &html_ul, NULL, 2, ET_NESTABLE },
  { (unsigned __int8 *)0x812D9CD, &html_linebrk, NULL, 1, ET_NESTABLE },
  { (unsigned __int8 *)0x812F308, &html_dl, NULL, 2, ET_NESTABLE },
  { &aDt_0, &html_dt, NULL, 1, ET_NON_PAIRABLE },
  { (unsigned __int8 *)0x812DD1A, &html_italic, NULL, 0, ET_NESTABLE },
  { &aEmbed, &html_embed, NULL, 0, ET_NON_PAIRABLE },
  { &aFixed, &html_fixed, NULL, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x812C790, &html_font, NULL, 0, ET_NESTABLE },
  { &aForm, &html_form, NULL, 1, ET_NESTABLE },
  { &aFrame_1, &html_frame, NULL, 1, ET_NON_PAIRABLE },
  { &aFrameset_0, &html_frameset, NULL, 1, ET_NESTABLE },
  { &aH1, &html_h1, NULL, 2, ET_NON_NESTABLE },
  { &aH2, &html_h2, NULL, 2, ET_NON_NESTABLE },
  { &aH3, &html_h3, NULL, 2, ET_NON_NESTABLE },
  { &aH4, &html_h4, NULL, 2, ET_NON_NESTABLE },
  { &aH5, &html_h5, NULL, 2, ET_NON_NESTABLE },
  { &aH6, &html_h6, NULL, 2, ET_NON_NESTABLE },
  { &aHead, &html_head, NULL, 0, ET_NESTABLE },
  { &aHr, &html_hr, NULL, 2, ET_NON_PAIRABLE },
  { &aHtml_0, &html_html, &html_html_close, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x8132865, &html_italic, NULL, 0, ET_NESTABLE },
  { &unk_812C7E8, &html_iframe, NULL, 1, ET_NON_PAIRABLE },
  { &aImg, &html_img, NULL, 0, ET_NON_PAIRABLE },
  { &aInput, &html_input, NULL, 0, ET_NON_PAIRABLE },
  { &aLi_1, &html_li, NULL, 1, ET_LI },
  { &aLink_2, &html_link, NULL, 1, ET_NON_PAIRABLE },
  { &aListing, &html_pre, NULL, 2, ET_NESTABLE },
  { &aMenu_0, &html_ul, NULL, 2, ET_NESTABLE },
  { &aMeta, &html_meta, NULL, 0, ET_NON_PAIRABLE },
  { &aNoframes, &html_noframes, NULL, 0, ET_NESTABLE },
  { &aNoscript, &html_noscript, NULL, 0, ET_NESTABLE },
  { &aObject_0, &html_object, NULL, 1, ET_NON_PAIRABLE },
  { (unsigned __int8 *)0x812DCF0, &html_ol, NULL, 2, ET_NESTABLE },
  { &aOption, &html_option, NULL, 1, ET_NON_PAIRABLE },
  { (unsigned __int8 *)0x812D943, &html_p, NULL, 2, ET_NON_NESTABLE },
  { &aPre, &html_pre, NULL, 2, ET_NESTABLE },
  {
    (unsigned __int8 *)0x812FFAF,
    &html_quote,
    &html_quote_close,
    0,
    ET_NESTABLE
  },
  { (unsigned __int8 *)0x8130F43, &html_underline, NULL, 0, ET_NESTABLE },
  { &aScript, &html_script, NULL, 0, ET_NESTABLE },
  { &aSelect, &html_select, NULL, 0, ET_NESTABLE },
  { &aSpan_0, &html_span, NULL, 0, ET_NESTABLE },
  { &aStrike, &html_underline, NULL, 0, ET_NESTABLE },
  { &aStrong, &html_bold, NULL, 0, ET_NESTABLE },
  { &aStyle_0, &html_style, &html_style_close, 0, ET_NESTABLE },
  {
    (unsigned __int8 *)0x812D810,
    &html_subscript,
    &html_subscript_close,
    0,
    ET_NESTABLE
  },
  { &aSup_0, &html_superscript, NULL, 0, ET_NESTABLE },
  { &aTable, &html_table, NULL, 2, ET_NESTABLE },
  { &aTd, &html_td, NULL, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x812C4BC, &html_textarea, NULL, 0, ET_NON_PAIRABLE },
  { (unsigned __int8 *)0x812CF4A, &html_th, NULL, 0, ET_NESTABLE },
  { &aTitle_2, &html_title, NULL, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x812D05C, &html_tr, NULL, 1, ET_NESTABLE },
  { &unk_812BC2F, &html_tt, NULL, 0, ET_NON_NESTABLE },
  { (unsigned __int8 *)0x8130BD9, &html_underline, NULL, 0, ET_NESTABLE },
  { (unsigned __int8 *)0x812FFA4, &html_ul, NULL, 2, ET_NESTABLE },
  { &aXmp, &html_xmp, &html_xmp_close, 2, ET_NESTABLE },
  { NULL, NULL, NULL, 0, ET_NESTABLE }
}; // idb
dom_stack_context_info dom_config_normalizer_context =
{
  0u,
  {
    NULL,
    NULL,
    NULL,
    &dom_normalize_text,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end,
    &dom_normalize_node_end
  }
}; // idb
dom_string dom_node_type_names_5671[13] =
{
  { 0u, NULL },
  { 7u, &aElement },
  { 9u, &aAttribute },
  { 4u, &aText },
  { 13u, &unk_812CA9C },
  { 16u, &aEntityReferenc },
  { 6u, &aEntity },
  { 16u, &aProcInstructio },
  { 7u, &aComment },
  { 8u, &aDocument },
  { 13u, &aDocumentType },
  { 17u, &aDocumentFragme },
  { 8u, &aNotation }
}; // idb
dom_string text_str_5616 = { 5u, &aText_2 }; // idb
dom_string document_fragment_str_5615 = { 18u, &unk_812CA75 }; // idb
dom_string document_str_5614 = { 9u, &aDocument_1 }; // idb
dom_string comment_str_5613 = { 8u, &unk_812CA92 }; // idb
dom_string cdata_section_str_5612 = { 14u, &unk_812CA9B }; // idb
dom_stack_context_info dom_select_context_info =
{
  0u,
  {
    NULL,
    &dom_select_push_element,
    NULL,
    &dom_select_push_text,
    &dom_select_push_text,
    &dom_select_push_text,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    &dom_select_pop_element,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  }
}; // idb
dom_stack_context_info dom_select_data_context_info =
{
  4u,
  {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  }
}; // idb
_UNKNOWN pseudo_info_4973; // weak
int dword_8141AA8[86] =
{
  1,
  12,
  135449380,
  2,
  9,
  135449393,
  4,
  5,
  135449403,
  8,
  6,
  135449409,
  16,
  4,
  135484481,
  32,
  7,
  135441725,
  64,
  6,
  135442536,
  128,
  5,
  135447414,
  256,
  5,
  135447422,
  512,
  6,
  135447537,
  1024,
  7,
  135449416,
  2048,
  8,
  135447721,
  4096,
  7,
  135447855,
  8192,
  13,
  135449424,
  16384,
  8,
  135449438,
  10000,
  9,
  135449447,
  10001,
  14,
  135449457,
  10002,
  11,
  135449472,
  10003,
  10,
  135449461,
  10004,
  10,
  135449484,
  10005,
  11,
  135449495,
  10006,
  16,
  135449507,
  10007,
  13,
  135449524,
  10008,
  12,
  135449511,
  10009,
  12,
  135449538,
  10010,
  4,
  135449551,
  10011,
  5,
  135473137,
  10012,
  0,
  0,
  0,
  0
}; // weak
dom_stack_context_info dom_stack_walk_context_info =
{
  8u,
  {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  }
}; // idb
dom_scanner_info dom_css_scanner_info =
{
  &css_string_mappings_0,
  &css_scan_table_info_0,
  &scan_css_tokens_0,
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  },
  0u
}; // idb
dom_stack_context_info sgml_file_dumper =
{
  0u,
  {
    NULL,
    &sgml_file_dumper_element_push,
    &sgml_file_dumper_attribute_push,
    &sgml_file_dumper_text_push,
    &sgml_file_dumper_cdata_section_push,
    &sgml_file_dumper_entity_ref_push,
    NULL,
    &sgml_file_dumper_proc_instruction_push,
    &sgml_file_dumper_comment_push,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    &sgml_file_dumper_element_pop,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  }
}; // idb
dom_stack_context_info sgml_parser_context_info =
{
  24u,
  {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  }
}; // idb
dom_stack_context_info sgml_parsing_context_info =
{
  264u,
  {
    NULL,
    NULL,
    NULL,
    &sgml_parsing_push,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    NULL,
    NULL,
    NULL,
    &sgml_parsing_pop,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
  }
}; // idb
dom_scanner_info sgml_scanner_info =
{
  &sgml_string_mappings,
  &sgml_scan_table_info,
  &scan_sgml_tokens,
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  },
  0u
}; // idb
sgml_info *sgml_info_0[4] = { &sgml_docbook_info, &sgml_html_info, &sgml_rss_info, &sgml_xbel_info }; // idb
hierbox_browser formhist_browser =
{
  &aFormHistoryMan,
  NULL,
  &formhist_buttons,
  6u,
  { (void *)0x8144E10, (void *)0x8144E10 },
  { (void *)0x8144E18, (void *)0x8144E18 },
  {
    NULL,
    NULL,
    { (void *)0x8144E28, (void *)0x8144E28 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &formhist_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
list_head_elinks saved_forms = { &saved_forms, &saved_forms }; // idb
hierbox_browser globhist_browser =
{
  &aGlobalHistoryM_0,
  NULL,
  &globhist_buttons,
  7u,
  { (void *)0x8144F90, (void *)0x8144F90 },
  { (void *)0x8144F98, (void *)0x8144F98 },
  {
    NULL,
    NULL,
    { (void *)0x8144FA8, (void *)0x8144FA8 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &gh_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
input_history global_history = { { &global_history, &global_history }, 0, 0u, 0u }; // idb
list_head_elinks global_history_reap_list = { &global_history_reap_list, &global_history_reap_list }; // idb
option_info global_history_options_0[6] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGlobal,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aGlobalHistoryO,
      &aGlobalHistory_2,
      NULL,
      NULL,
      NULL
    },
    &aDocumentHistor_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812774B,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aEnableGlobalHi,
      &aEnable,
      NULL,
      NULL,
      NULL
    },
    &unk_812E34A
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMaxItems,
      0,
      OPT_INT,
      1,
      2147483647,
      { (list_head_elinks *)0x400 },
      &aMaximumNumberO_2,
      &aMaximumNumberO_3,
      NULL,
      NULL,
      NULL
    },
    &unk_812E34A
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDisplayType,
      0,
      OPT_INT,
      0,
      1,
      { NULL },
      &aWhatToDisplayI,
      &aDisplayStyle_0,
      NULL,
      NULL,
      NULL
    },
    &unk_812E34A
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aWriteInterval,
      0,
      OPT_ALIAS,
      0,
      23,
      { &aInfofilesSaveI },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &unk_812E34A
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
int utf_table_init = 1; // idb
fastfind_index ff_charsets_index = { &aCharsetsLookup, &charsets_list_reset, &charsets_list_next, NULL }; // idb
int first_time_7079 = 1; // idb
int first = 1; // idb
int lto_6933 = -1; // idb
int lfr_6932 = -1; // idb
int lfr_6850 = -1; // weak
char *nl_current_default_domain__ = &nl_default_default_domain__; // idb
int current_charset = -1; // idb
language languages[34] =
{
  { &aSystem_0, (unsigned __int8 *)0x812964A },
  { &aEnglish, (unsigned __int8 *)0x81333B5 },
  { &aAfrikaans, (unsigned __int8 *)0x812FD05 },
  { &aBelarusian, (unsigned __int8 *)0x812FA58 },
  { &aBrazilianPortu, &aPtBr },
  { &aBulgarian, &aBg },
  { &aCatalan, &aCa },
  { &aCroatian, &aHr_0 },
  { &aCzech, (unsigned __int8 *)0x812EABC },
  { &aDanish, (unsigned __int8 *)0x812F19A },
  { &aDutch, &aNl },
  { &aEstonian, (unsigned __int8 *)0x8130AC1 },
  { &aFinnish, (unsigned __int8 *)0x8131121 },
  { &aFrench, (unsigned __int8 *)0x81333BE },
  { &aGalician, &aGl },
  { &aGerman, (unsigned __int8 *)0x812C731 },
  { (unsigned __int8 *)0x812E742, (unsigned __int8 *)0x812A9C8 },
  { &aHungarian, (unsigned __int8 *)0x8130493 },
  { &aIcelandic, (unsigned __int8 *)0x812F254 },
  { &aIndonesian, (unsigned __int8 *)0x81334C7 },
  { &aItalian, (unsigned __int8 *)0x812E42E },
  { &aLithuanian, (unsigned __int8 *)0x812845D },
  { &aNorwegian, &byte_812785C },
  { &aPolish, &aPl },
  { (unsigned __int8 *)0x8131375, (unsigned __int8 *)0x812B2E4 },
  { &aRomanian, (unsigned __int8 *)0x812F93B },
  { &aRussian, (unsigned __int8 *)0x812EAE6 },
  { &aSerbian, (unsigned __int8 *)0x812F489 },
  { &aSlovak, (unsigned __int8 *)0x813175B },
  { &aSpanish, (unsigned __int8 *)0x812762D },
  { &aSwedish, (unsigned __int8 *)0x813280A },
  { &aTurkish, &aTr_0 },
  { &aUkrainian, &aUk },
  { NULL, NULL }
}; // idb
const unsigned __int8 *locale_alias_path_4921 = &dirname; // idb
module *main_modules[4] = { &document_module, &kbdbind_module, &terminal_module, NULL }; // idb
module *builtin_modules[14] =
{
  &periodic_saving_module,
  &viewer_module,
  &css_module,
  &protocol_module,
  &ssl_module,
  &mime_module,
  &leds_module,
  &bookmarks_module,
  &cookies_module,
  &forms_history_module,
  &global_history_module,
  &scripting_module,
  &goto_url_history_module,
  NULL
}; // idb
list_head_elinks bottom_halves = { &bottom_halves, &bottom_halves }; // idb
list_head_elinks timers = { &timers, &timers }; // idb
menu_item mi_no_ext[2] =
{
  { &aNoExtensions, NULL, ACT_MAIN_NONE, NULL, NULL, NO_SELECT, HKS_SHOW, 0 },
  { NULL, NULL, ACT_MAIN_NONE, NULL, NULL, NO_FLAG, HKS_SHOW, 0 }
}; // idb
option_info mime_options_0[3] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMime_0,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aMimeRelatedOpt,
      &aMime,
      NULL,
      NULL,
      NULL
    },
    &delete
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8127D95,
      0,
      OPT_STRING,
      0,
      1024,
      { &aApplicationOct },
      &aDocumentMimeTy,
      &aDefaultMimeTyp_0,
      NULL,
      NULL,
      NULL
    },
    &aMime_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
module default_mime_module = { &aOptionSystem, &default_mime_options, NULL, NULL, NULL, NULL, NULL }; // idb
module mailcap_mime_module =
{
  &aMailcap_0,
  &mailcap_options,
  NULL,
  NULL,
  NULL,
  &init_mailcap,
  &done_mailcap
}; // idb
option_info mailcap_options[7] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8131920,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForMail,
      &aMailcap_0,
      NULL,
      NULL,
      NULL
    },
    &aMime_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812774B,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aEnableMailcapS,
      &aEnable,
      NULL,
      NULL,
      NULL
    },
    &aMimeMailcap
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPath,
      0,
      OPT_STRING,
      0,
      1024,
      { &byte_811ED68 },
      &aMailcapSearchP,
      &byte_812B2C5,
      NULL,
      NULL,
      NULL
    },
    &aMimeMailcap
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aAsk,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aAskBeforeUsing,
      &aAskBeforeOpeni_0,
      NULL,
      NULL,
      NULL
    },
    &aMimeMailcap
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDescription,
      0,
      OPT_INT,
      0,
      2,
      { NULL },
      &aTypeOfDescript,
      &aTypeQueryStrin,
      NULL,
      NULL,
      NULL
    },
    &aMimeMailcap
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPrioritize,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aPrioritizeEntr,
      &aPrioritizeEntr_0,
      NULL,
      NULL,
      NULL
    },
    &aMimeMailcap
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
module mimetypes_mime_module =
{
  &aMimetypesFiles,
  &mimetypes_options,
  NULL,
  NULL,
  NULL,
  &init_mimetypes,
  &done_mimetypes
}; // idb
option_info mimetypes_options[4] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8131990,
      0,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aOptionsForTheS,
      &aMimetypesFiles,
      NULL,
      NULL,
      NULL
    },
    &aMime_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812774B,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aEnableMimeType,
      &aEnable,
      NULL,
      NULL,
      NULL
    },
    &aMimeMimetypes
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPath,
      0,
      OPT_STRING,
      0,
      1024,
      { &byte_811F00C },
      &aTheSearchPathF,
      &byte_812B2C5,
      NULL,
      NULL,
      NULL
    },
    &aMimeMimetypes
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
list_head_elinks connection_queue = { &connection_queue, &connection_queue }; // idb
list_head_elinks keepalive_connections = { &keepalive_connections, &keepalive_connections }; // idb
socket_operations connection_socket_operations_8784 =
{
  &set_connection_socket_state,
  &set_connection_socket_timeout,
  &retry_connection_socket,
  &done_connection_socket
}; // idb
list_head_elinks host_connections = { &host_connections, &host_connections }; // idb
list_head_elinks dns_cache = { &dns_cache, &dns_cache }; // idb
list_head_elinks socket_weak_refs = { &socket_weak_refs, &socket_weak_refs }; // idb
list_head_elinks strerror_buf = { &strerror_buf, &strerror_buf }; // idb
int fd_7506 = -1; // idb
int xt_7330 = -1; // idb
int screen_7320 = -1; // idb
int tw_7310 = -1; // idb
int get_proxy_event_id_5943 = -1; // idb
list_head_elinks auth_entry_list = { &auth_entry_list, &auth_entry_list }; // idb
hierbox_browser auth_browser =
{
  &aAuthentication_1,
  NULL,
  &auth_buttons,
  4u,
  { (void *)0x8146510, (void *)0x8146510 },
  { (void *)0x8146518, (void *)0x8146518 },
  {
    NULL,
    NULL,
    { (void *)0x8146528, (void *)0x8146528 },
    BI_FOLDER,
    -1,
    1u,
    0u,
    0u,
    NULL
  },
  &auth_listbox_ops,
  { NULL, NULL, NULL, NULL, NULL, 0, NULL },
  0u
}; // idb
list_head_elinks blacklist = { &blacklist, &blacklist }; // idb
list_head_elinks negotiate_list = { &negotiate_list, &negotiate_list }; // idb
option_info uri_rewrite_options[92] =
{
  {
    {
      NULL,
      NULL,
      { 0 },
      &unk_813318E,
      OPT_SORT,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aRulesForRewrit,
      &aUriRewriting,
      NULL,
      NULL,
      NULL
    },
    &aProtocol_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEnableDumb,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aEnableDumbPref,
      &aEnableDumbPref_0,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEnableSmart,
      0,
      OPT_BOOL,
      0,
      1,
      { (list_head_elinks *)1 },
      &aEnableSmartPre,
      &aEnableSmartPre_0,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81331AB,
      OPT_SORT|OPT_AUTOCREATE,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aDumbPrefixesSe,
      &aDumbPrefixes,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTemplate,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aReplacementUri,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81331DD,
      OPT_SORT|OPT_AUTOCREATE,
      OPT_TREE,
      0,
      0,
      { NULL },
      &aSmartPrefixesS,
      &aSmartPrefixes,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aTemplate,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aReplacementUri_0,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDefaultTemplat,
      0,
      OPT_STRING,
      0,
      1024,
      { &delete },
      &aDefaultUriTemp,
      &aDefaultTemplat_0,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_0
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &domainname,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpElinksCz },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDocumentation_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpElinksCzDo },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812E101,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBugsDebian },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81332F6,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBugsDebian },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aArc,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWebArchive },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCia,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpCiaNaviCx },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8130F76,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBabelfishA },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813389E,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwDictOrg },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812EE23,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGg_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8133BDE,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFm,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpFreshmeatN },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSf,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwSourcef },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDbug,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBugsDebian_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDpkg,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpPackagesDe },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLua,
      0,
      OPT_STRING,
      0,
      1024,
      { &aFileUsrShareDo },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPycur,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwPythonO },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPydev,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwPythonO_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPyhelp,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpStarshipPy },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPyvault,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwVexNetP },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8134141,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwEveryth },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81334B8,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSlashdotOr },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aVhtml,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpValidatorW },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aVcss,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpJigsawW3Or },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_1
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81332F6,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBugsDebian_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aArc,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWebArchive_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBb,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBabelfishA_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBbFrEn,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBabelfishA_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aBbEnFr,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBabelfishA_2 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCambridge,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpDictionary },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCliki,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwClikiNe },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x813389E,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwDictOrg_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDmoz,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSearchDmoz },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFoldoc,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWombatDocI },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812EE23,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGd,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGg_0,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8132699,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpImagesGoog },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812C1F8,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpNewsGoogle },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8133BDE,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812ED0E,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpGroupsGoog },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGoogle,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGoogleC_2 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGwho,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGooglis },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGwhat,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGooglis_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGwhere,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGooglis_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aGwhen,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwGooglis_2 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFm,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpFreshmeatN_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSavannah,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSavannahNo },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSf,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSourceforg },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSfp,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSourceforg_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81334B8,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSlashdotOr_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSdc,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSlashdotOr_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSdu,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSlashdotOr_2 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSdp,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSlashdotOr_3 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aSdj,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpSlashdotOr_4 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDbug,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpBugsDebian_2 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDpkg,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpPackagesDe_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEmacs,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwEmacswi },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLyrics,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpMusicLycos },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aLxr,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpLxrLinuxNo },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aOnelook,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpOnelookCom },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812F482,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpStarshipPy_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPydev,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpStarshipPy_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aPyvault,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpPyVaultsCa },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x8134141,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwEveryth_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aEncz,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwSlovnik },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aCzen,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwSlovnik_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDict,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpDictionary_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aThes,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpThesaurusR },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812FFFB,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpAcronymfin },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aImdb,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwImdbCom },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMw,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwMWComCg },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aMwt,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwMWComCg_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aWhatis,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpUptimeNetc },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aWiki,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpEnWikipedi },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812853C,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwCogsciP },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aFsd,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpDirectoryF },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRfc,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwRfcEdit },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRfcs,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwRfcEdit_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x812ED21,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwRfcEdit_0 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aRfcid,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwRfcEdit_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      (unsigned __int8 *)0x81334C7,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwRfcEdit_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      &aDraft,
      0,
      OPT_STRING,
      0,
      1024,
      { &aHttpWwwRfcEdit_1 },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    &aProtocolRewrit_2
  },
  {
    {
      NULL,
      NULL,
      { 0 },
      NULL,
      0,
      OPT_BOOL,
      0,
      0,
      { NULL },
      NULL,
      NULL,
      NULL,
      NULL,
      NULL
    },
    NULL
  }
}; // idb
module ruby_scripting_module = { &aRuby, NULL, &ruby_scripting_hooks, NULL, NULL, &init_ruby, NULL }; // idb
list_head_elinks downloads = { &downloads, &downloads }; // idb
list_head_elinks sessions = { &sessions, &sessions }; // idb
list_head_elinks questions_queue = { &questions_queue, &questions_queue }; // idb
list_head_elinks session_info_0 = { &session_info_0, &session_info_0 }; // idb
int pre_format_html_event_9516 = -1; // idb
void *session_info_id = (void *)1; // idb
int follow_url_event_id_9029 = -1; // idb
int goto_url_event_id_9115 = -1; // idb
int xterm_button_6476 = -1; // idb
list_head_elinks active_screen_drivers = { &active_screen_drivers, &active_screen_drivers }; // idb
list_head_elinks terminals = { &terminals, &terminals }; // idb
fastfind_index ff_colors_index = { &aColorsLookup, &colors_list_reset, &colors_list_next, NULL }; // idb
unsigned __int8 full_static_version[1024] =
{
  69u,
  76u,
  105u,
  110u,
  107u,
  115u,
  32u,
  48u,
  46u,
  49u,
  50u,
  112u,
  114u,
  101u,
  53u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
int last_uid_6521 = -1; // weak
int last_gid_6546 = -1; // weak
int first_8843 = 1; // idb
list_head_elinks done_list_8838 = { &done_list_8838, &done_list_8838 }; // idb
list_head_elinks todo_list_8837 = { &todo_list_8837, &todo_list_8837 }; // idb
input_history search_history = { { &search_history, &search_history }, 0, 0u, 0u }; // idb
option_resolver resolvers_0[1] = { { 0, (unsigned __int8 *)0x813558B } }; // idb
int first_time_9390 = 1; // weak
unsigned __int8 *build_date = &aMar242011; // idb
unsigned __int8 *build_time = &a174850; // idb
unsigned __int8 *build_id = &delete; // idb
int ruby_errinfo; // weak
int rb_cFixnum; // weak
int rb_cTrueClass; // weak
int rb_eRuntimeError; // weak
int gpm_visiblepointer; // weak
int rb_stdout; // weak
FILE *stderr; // idb
int rb_cSymbol; // weak
int gpm_zerobased; // weak
char byte_8148C81; // weak
int gpm_arg; // weak
int rb_cNilClass; // weak
FILE *stdout; // idb
int GSS_C_NT_HOSTBASED_SERVICE__GSS_1_0_0; // weak
int rb_cFalseClass; // weak
int *prev_y_8446; // idb
int max_label_width_8445; // idb
int drawing; // idb
timer_id_T redraw_timer; // idb
int timer_duration_backup; // idb
hash *bfu_colors; // idb
color_mode last_color_mode_4585; // idb
hash *bookmark_cache; // idb
int bookmarks_dirty; // idb
bookmark *bm_snapshot_last_folder; // idb
char *bm_last_searched_title; // idb
char *bm_last_searched_url; // idb
bookmark *move_cache_root_avoid; // idb
tree_node *root_node; // idb
bookmark *lastbm_8068; // idb
tree_node *current_node; // idb
unsigned __int64 cache_size; // idb
int complained_8041; // idb
unsigned __int8 *remote_url; // idb
int keybinding_text_toggle; // idb
listbox_item *action_box_items[3][128]; // idb
char *elinks_home; // idb
int first_use; // idb
list_head_elinks keymaps[3]; // idb
int no_autocreate; // idb
int commandline; // idb
timer_id_T periodic_save_timer; // idb
int cookies_nosave; // idb
int cookies_dirty; // idb
string header_8344; // idb
unsigned __int8 width_str[4]; // idb
unsigned __int8 height_str[4]; // idb
int last_ses_9168; // weak
int last_current_link_8807; // weak
int i_want_struct_module_for_dom_7054; // weak
screen_char schar_cache_8357; // idb
int table_cache_entries; // idb
hash *table_cache; // idb
renderer_context renderer_context_0; // idb
list_menu lnk_menu; // idb
fastfind_key_value kv_7440; // idb
element_info *internal_pointer; // idb
int loaded; // idb
unsigned __int8 *gh_last_searched_title; // idb
unsigned __int8 *gh_last_searched_url; // idb
hash *globhist_cache; // idb
int globhist_cache_entries; // idb
unsigned int i_name; // idb
unsigned int i_alias; // idb
fastfind_key_value kv_7347; // idb
unsigned int nb_entity_cache_7078[9]; // idb
unsigned __int8 utf_buffer[7]; // idb
conv_table table_elinks_0[256]; // idb
char *LANGUAGE; // idb
size_t freemem_size_7307; // idb
unsigned __int8 *freemem_7306; // idb
void *root; // idb
int enable_secure; // idb
loaded_l10nfile *nl_loaded_domains; // idb
int system_language; // idb
int current_language; // idb
expression plvar; // idb
expression plone; // idb
expression germanic_plural; // idb
char *charset_aliases; // idb
unsigned __int8 *string_space; // idb
size_t string_space_act; // idb
size_t string_space_max; // idb
alias_map *map; // idb
size_t nmap; // idb
size_t maxmap; // idb
event *events; // idb
unsigned int eventssize; // idb
hash *event_hash; // idb
socket_info s_info_accept; // idb
socket_info s_info_listen; // idb
socket_info s_info_connect; // idb
int init_b; // idb
int ac; // idb
unsigned __int8 **av; // idb
thread threads[1024]; // idb
fd_set w_read; // idb
fd_set w_write; // idb
fd_set w_error; // idb
fd_set x_read; // idb
fd_set x_write; // idb
fd_set x_error; // idb
int w_max; // idb
hash *mailcap_map; // idb
hash *mimetypes_map; // idb
int active_connections; // idb
unsigned int connection_id; // idb
timer_id_T keepalive_timeout; // idb
gnutls_anon_client_credentials_t anon_cred; // idb
gnutls_certificate_credentials_t xcred; // idb
unsigned __int8 *clipboard; // idb
volatile int critical_section; // idb
volatile int pending_alarm; // idb
signal_info signal_info_0[32]; // idb
uri_cache uri_cache_0; // idb
unsigned __int8 *accept_charset; // idb
auth_entry proxy_auth; // idb
int cache_3940[]; // weak
_UNKNOWN unk_814F064; // weak
_DWORD dword_814F068[12286]; // weak
itrm *ditrm; // idb
int mouse_enabled; // idb
int terminal_pipe[2]; // idb
int once_3804; // idb
unsigned __int8 decode_3799[256]; // idb
unsigned __int8 is_base64_char_3798[256]; // idb
fastfind_key_value kv_5773; // idb
const color_spec *internal_pointer_0; // idb
int assert_failed; // idb
unsigned __int8 last_user_6520; // idb
unsigned __int8 last_group_6545; // idb
int alloc_try; // idb
int page_size; // idb
secsave_errno secsave_errno_0; // idb
timer_id_T countdown; // idb
int timer_duration; // idb
int dump_redir_count; // idb
off_t dump_pos; // idb
download dump_download; // idb
screen_char template_8980; // idb
view_state *marks[52]; // idb
char hash_9389[4096]; // weak
int textarea_editor; // idb
char *fn_10339; // idb
link *link_10338; // idb
document_view *doc_view_10337; // idb
terminal *term_10336; // idb
form_state *fs_10335; // idb
size_t fc_maxlength_10334; // idb
const unsigned __int8 *errfile; // idb
binding *nl_domain_bindings__; // idb
conv_table utf_table[256]; // idb
unsigned __int8 system_name[1024]; // idb
remote_session_flags remote_session_flags_0; // idb
program program_0; // idb
VALUE erb_module; // idb
listbox_item *keymap_box_item[3]; // idb
option_elinks *config_options; // idb
option_elinks *cmdline_options; // idb
int nl_msg_cat_cntr; // idb
int errline; // idb


//----- (08058BF8) --------------------------------------------------------
int sub_8058BF8()
{
  return dword_8136FFC();
}
// 8136FFC: using guessed type int (*dword_8136FFC)(void);

//----- (08059C10) --------------------------------------------------------
widget_handler_status_T __cdecl select_button(dialog_data *dlg_data, widget_data *widget_data)
{
  return ((int (*)(void))widget_data->widget->handler)();
}

//----- (08059C30) --------------------------------------------------------
widget_handler_status_T __cdecl mouse_button(dialog_data *dlg_data, widget_data *widget_data)
{
  term_event *term_event; // ebx
  int x; // eax
  int v4; // edx
  int v6; // ecx
  widget_handler_T *select; // eax
  terminal *term; // [esp+1Ch] [ebp-2Ch]
  int y; // [esp+2Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  term_event = dlg_data->term_event;
  if ( (term_event->info.mouse.button & 7) > 2 )
    return 1;
  y = term_event->info.mouse.y;
  x = term_event->info.mouse.x;
  v4 = widget_data->box.x;
  if ( x < v4 )
    return 1;
  v6 = widget_data->box.y;
  if ( y < v6 || x >= widget_data->box.width + v4 || y >= v6 + widget_data->box.height )
    return 1;
  select_widget(dlg_data, widget_data);
  term->prev_mouse_event.x = 0;
  term->prev_mouse_event.y = 0;
  term->prev_mouse_event.button = 0;
  if ( (*(_BYTE *)(&term_event->info.size + 1) & 0x20) != 0 && (select = widget_data->widget->ops->select) != 0 )
    return select(dlg_data, widget_data);
  else
    return 0;
}

//----- (08059D00) --------------------------------------------------------
widget_handler_status_T __cdecl display_button(dialog_data *dlg_data, widget_data *widget_data)
{
  terminal *term; // esi
  int v3; // eax
  option_value *opt; // eax
  int v5; // edx
  int v6; // eax
  screen_char_attr v7; // edx
  int v8; // ecx
  int v9; // eax
  int v11; // ecx
  int length; // [esp+2Ch] [ebp-4Ch]
  int lengtha; // [esp+2Ch] [ebp-4Ch]
  int lengthb; // [esp+2Ch] [ebp-4Ch]
  int lengthd; // [esp+2Ch] [ebp-4Ch]
  int lengthc; // [esp+2Ch] [ebp-4Ch]
  screen_char_attr attr; // [esp+30h] [ebp-48h]
  int attra; // [esp+30h] [ebp-48h]
  screen_char_attr attrc; // [esp+30h] [ebp-48h]
  screen_char_attr attrb; // [esp+30h] [ebp-48h]
  int hk_cells; // [esp+34h] [ebp-44h]
  int hk_bytes; // [esp+38h] [ebp-40h]
  int len_to_display; // [esp+3Ch] [ebp-3Ch]
  int len_to_displaya; // [esp+3Ch] [ebp-3Ch]
  int len_to_displayb; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *utf8_char; // [esp+40h] [ebp-38h]
  unsigned __int8 *text; // [esp+44h] [ebp-34h]
  int x; // [esp+48h] [ebp-30h]
  int hk_width; // [esp+4Ch] [ebp-2Ch]
  int hk_widtha; // [esp+4Ch] [ebp-2Ch]
  color_pair *shortcut_color; // [esp+50h] [ebp-28h]
  int sel; // [esp+54h] [ebp-24h]
  int len; // [esp+58h] [ebp-20h]
  int lena; // [esp+58h] [ebp-20h]
  color_pair *color; // [esp+5Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  sel = &dlg_data->widgets_data[dlg_data->selected_widget_id] == widget_data;
  if ( &dlg_data->widgets_data[dlg_data->selected_widget_id] == widget_data )
  {
    shortcut_color = get_bfu_color(term, "dialog.button-shortcut-selected");
    color = get_bfu_color(term, "dialog.button-selected");
  }
  else
  {
    shortcut_color = get_bfu_color(term, "dialog.button-shortcut");
    color = get_bfu_color(term, "dialog.button");
  }
  if ( shortcut_color && color )
  {
    if ( (*((_BYTE *)term + 56) & 2) != 0 )
    {
      attra = utf8_ptr2cells("[ ", 0);
      lena = utf8_ptr2cells((unsigned __int8 *)" ]", 0);
      v3 = widget_data->box.x;
      x = attra + v3;
      len = widget_data->box.width + -lena - attra;
    }
    else
    {
      v3 = widget_data->box.x;
      x = v3 + 2;
      len = widget_data->box.width - 4;
    }
    draw_text(term, v3, widget_data->box.y, "[ ", 2, (screen_char_attr)0, color);
    if ( len > 0 )
    {
      text = widget_data->widget->text;
      hk_width = widget_data->widget->info.checkbox.gnum;
      opt = get_opt_(config_options, "ui.dialogs.underline_button_shortcuts");
      v5 = opt->number != 0 ? 0x20 : 0;
      if ( (*((_BYTE *)term + 56) & 2) != 0 )
      {
        if ( hk_width < 0 )
        {
          attrc = opt->number != 0 ? SCREEN_ATTR_UNDERLINE : 0;
          hk_widtha = utf8_char2cells(text, 0);
          lengthd = utf8charlen(text);
          len_to_displayb = utf8_cells2bytes(&text[lengthd], len - hk_widtha, 0);
          draw_text(term, x, widget_data->box.y, text, lengthd, attrc, shortcut_color);
          draw_text(
            term,
            x + hk_widtha,
            widget_data->box.y,
            &text[lengthd],
            len_to_displayb,
            (screen_char_attr)0,
            color);
        }
        else
        {
          attr = opt->number != 0 ? SCREEN_ATTR_UNDERLINE : 0;
          utf8_char = &text[hk_width + 1];
          hk_bytes = utf8charlen(utf8_char);
          len_to_display = utf8_ptr2cells(text, &text[hk_width]);
          length = widget_data->widget->info.button.truetextlen - hk_width - hk_bytes;
          v6 = utf8_char2cells(utf8_char, 0);
          v7 = attr;
          v8 = length;
          hk_cells = v6;
          if ( hk_width )
          {
            draw_text(term, x, widget_data->box.y, text, hk_width, (screen_char_attr)0, color);
            v8 = length;
            v7 = attr;
          }
          len_to_displaya = x + len_to_display;
          lengtha = v8;
          draw_text(term, len_to_displaya, widget_data->box.y, utf8_char, hk_bytes, v7, shortcut_color);
          if ( lengtha > 1 )
            draw_text(
              term,
              hk_cells + len_to_displaya,
              widget_data->box.y,
              &text[hk_bytes + 1 + hk_width],
              lengtha - 1,
              (screen_char_attr)0,
              color);
        }
      }
      else if ( hk_width < 0 )
      {
        draw_text(
          term,
          x,
          widget_data->box.y,
          text,
          1,
          opt->number != 0 ? SCREEN_ATTR_UNDERLINE : (screen_char_attr)0,
          shortcut_color);
        draw_text(term, x + 1, widget_data->box.y, text + 1, len - 1, (screen_char_attr)0, color);
      }
      else
      {
        v11 = widget_data->widget->info.button.truetextlen + ~hk_width;
        if ( hk_width )
        {
          attrb = opt->number != 0 ? SCREEN_ATTR_UNDERLINE : 0;
          lengthc = widget_data->widget->info.button.truetextlen + ~hk_width;
          draw_text(term, x, widget_data->box.y, text, hk_width, (screen_char_attr)0, color);
          v11 = lengthc;
          v5 = attrb;
        }
        lengthb = v11;
        draw_text(term, hk_width + x, widget_data->box.y, &text[hk_width + 1], 1, (screen_char_attr)v5, shortcut_color);
        if ( lengthb > 1 )
          draw_text(
            term,
            hk_width + x + 1,
            widget_data->box.y,
            &text[hk_width + 2],
            lengthb - 1,
            (screen_char_attr)0,
            color);
      }
    }
    if ( (*((_BYTE *)term + 56) & 2) != 0 )
    {
      v9 = utf8_ptr2cells(widget_data->widget->text, 0);
      draw_text(
        term,
        v9 + x - (widget_data->widget->info.checkbox.gnum >= 0),
        widget_data->box.y,
        (unsigned __int8 *)" ]",
        2,
        (screen_char_attr)0,
        color);
    }
    else
    {
      draw_text(term, len + x, widget_data->box.y, (unsigned __int8 *)" ]", 2, (screen_char_attr)0, color);
    }
    if ( sel )
    {
      set_cursor(term, x, widget_data->box.y, 1);
      dlg_data->win->x = widget_data->box.x;
      dlg_data->win->y = widget_data->box.y;
    }
  }
  return 0;
}

//----- (0805A2E0) --------------------------------------------------------
void __cdecl add_dlg_button_do(
        dialog *dlg,
        unsigned __int8 *text,
        int flags,
        widget_handler_T *handler,
        void *data,
        done_handler_T *done,
        void *done_data)
{
  signed int v7; // eax
  int number_of_widgets; // edx
  int v9; // ecx
  unsigned __int8 **v10; // edx
  unsigned __int8 **v11; // ebx
  _BYTE *v12; // eax

  v7 = strlen((const char *)text);
  number_of_widgets = dlg->number_of_widgets;
  v9 = number_of_widgets + 1;
  v10 = &dlg->title + 12 * number_of_widgets;
  dlg->number_of_widgets = v9;
  v10[20] = (unsigned __int8 *)3;
  v10[10] = text;
  v11 = &dlg->title + 12 * v9;
  v10[11] = (unsigned __int8 *)handler;
  v10[12] = (unsigned __int8 *)data;
  v11[2] = (unsigned __int8 *)flags;
  v10[18] = (unsigned __int8 *)done;
  v10[19] = (unsigned __int8 *)done_data;
  v11[3] = (unsigned __int8 *)-1;
  v11[4] = (unsigned __int8 *)v7;
  v11[5] = (unsigned __int8 *)v7;
  if ( v7 > 1 )
  {
    v12 = memchr(text, 126, v7 - 1);
    if ( v12 )
    {
      --v11[4];
      v11[3] = (unsigned __int8 *)(v12 - text);
    }
  }
}

//----- (0805A390) --------------------------------------------------------
void __usercall buttons_width(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, widget_data *widget_data)
{
  int v5; // esi
  int v6; // eax
  int v7; // esi
  int v8; // ebx
  int v9; // edi
  int v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edx
  widget_data *v16; // [esp+14h] [ebp-24h]
  int v17; // [esp+14h] [ebp-24h]
  int v20; // [esp+1Ch] [ebp-1Ch]

  v5 = utf8_ptr2cells("[ ", 0);
  v6 = v5 + utf8_ptr2cells((unsigned __int8 *)" ]", 0);
  if ( assert_failed
    || (assert_failed = a2 <= 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/button.c",
        errline = 96,
        v17 = v6,
        elinks_internal("assertion n > 0 failed!"),
        v6 = v17,
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  if ( !a2 )
  {
    v15 = -2;
    goto LABEL_10;
  }
  v7 = a1;
  v20 = v6 + 2;
  v8 = a2 - 1;
  v9 = -2;
  v11 = v7 + 48;
  while ( !widget_data )
  {
    v12 = *(_DWORD *)(v11 - 48);
    v11 += 48;
    v9 += *(_DWORD *)(v12 + 28) + 6;
    if ( !v8 )
      goto LABEL_9;
LABEL_6:
    --v8;
  }
  v13 = *(_DWORD *)(v11 - 48);
  v11 += 48;
  v16 = widget_data;
  v14 = utf8_ptr2cells(*(unsigned __int8 **)(v13 + 4), 0);
  widget_data = v16;
  v9 += v20 + v14;
  if ( v8 )
    goto LABEL_6;
LABEL_9:
  v15 = v9;
LABEL_10:
  if ( a3 )
  {
    if ( *a3 < v15 )
      *a3 = v15;
  }
}

//----- (0805A4D0) --------------------------------------------------------
void __cdecl dlg_format_buttons(
        terminal *term,
        widget_data *widget_data,
        int n,
        int x,
        int *y,
        int w,
        int *rw,
        format_align align,
        int format_only)
{
  int v10; // ebx
  int v11; // esi
  int v12; // esi
  int v13; // eax
  int v14; // edx
  widget_data *v15; // esi
  int v16; // edi
  int i; // ebx
  int v18; // edx
  int v19; // ecx
  input_history *history; // eax
  int p_prev; // eax
  int v22; // ecx
  int v23; // eax
  int v24; // edx
  bool v25; // sf
  int v26; // ecx
  int button_lr_lena; // [esp+14h] [ebp-34h]
  int button_lr_len; // [esp+14h] [ebp-34h]
  int i1; // [esp+18h] [ebp-30h]
  terminal *i1a; // [esp+18h] [ebp-30h]
  widget_data *widget_data1; // [esp+1Ch] [ebp-2Ch]
  widget_data *widget_data1a; // [esp+1Ch] [ebp-2Ch]
  int mw[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( n > 0 )
  {
    i1 = 0;
    do
    {
      v10 = i1 + 1;
      widget_data1 = &widget_data[i1];
      if ( n > i1 + 1 )
      {
        v11 = 2;
        do
        {
          mw[0] = 0;
          buttons_width((int)widget_data1, v11, mw, (widget_data *)((*((_BYTE *)term + 56) & 2) != 0));
          if ( mw[0] > w )
            break;
          ++v10;
          ++v11;
        }
        while ( n > v10 );
      }
      mw[0] = 0;
      buttons_width((int)widget_data1, v10 - i1, mw, (widget_data *)((*((_BYTE *)term + 56) & 2) != 0));
      if ( rw )
      {
        if ( mw[0] <= *rw )
        {
          if ( w < *rw )
            *rw = w;
        }
        else
        {
          *rw = mw[0];
        }
      }
      if ( !format_only )
      {
        v12 = 0;
        if ( align == ALIGN_CENTER )
          v12 = (w - mw[0]) / 2;
        button_lr_lena = utf8_ptr2cells("[ ", 0);
        button_lr_len = button_lr_lena + utf8_ptr2cells((unsigned __int8 *)" ]", 0);
        if ( v10 > i1 )
        {
          v13 = i1;
          i1a = term;
          v14 = v12 + x;
          v15 = widget_data1;
          v16 = v13;
          widget_data1a = (widget_data *)v10;
          for ( i = v14; ; i += p_prev + 2 )
          {
            if ( (*((_BYTE *)i1a + 56) & 2) != 0 )
            {
              v22 = utf8_ptr2cells(v15->widget->text, 0);
              v23 = *y;
              v24 = 0;
              if ( i >= 0 )
                v24 = i;
              v15->box.x = v24;
              if ( v23 < 0 )
                v23 = 0;
              v15->box.y = v23;
              p_prev = 0;
              v25 = button_lr_len + v22 < 0;
              v26 = button_lr_len + v22;
              v15->box.height = 1;
              if ( !v25 )
                p_prev = v26;
              ++v16;
              v15->box.width = p_prev;
              ++v15;
              if ( (int)widget_data1a <= v16 )
                goto LABEL_31;
            }
            else
            {
              v18 = *y;
              v19 = 0;
              history = v15->widget->info.field.history;
              if ( i >= 0 )
                v19 = i;
              v15->box.x = v19;
              v15->box.height = 1;
              if ( v18 < 0 )
                v18 = 0;
              p_prev = (int)&history->entries.prev;
              if ( p_prev < 0 )
                p_prev = 0;
              ++v16;
              v15->box.y = v18;
              v15->box.width = p_prev;
              ++v15;
              if ( (int)widget_data1a <= v16 )
              {
LABEL_31:
                v10 = (int)widget_data1a;
                term = i1a;
                break;
              }
            }
          }
        }
      }
      *y += 2;
      i1 = v10;
    }
    while ( n > v10 );
  }
}

//----- (0805A6E0) --------------------------------------------------------
void __cdecl add_dlg_radio_do(dialog *dlg, unsigned __int8 *text, int groupid, int groupnum, int *data)
{
  int number_of_widgets; // edx
  int v6; // ecx
  unsigned __int8 **v7; // edx
  unsigned __int8 **v8; // eax

  number_of_widgets = dlg->number_of_widgets;
  v6 = number_of_widgets + 1;
  v7 = &dlg->title + 12 * number_of_widgets;
  dlg->number_of_widgets = v6;
  v7[20] = 0;
  v8 = &dlg->title + 12 * v6;
  v7[10] = text;
  v8[1] = (unsigned __int8 *)4;
  v7[12] = (unsigned __int8 *)data;
  v8[2] = (unsigned __int8 *)groupid;
  v8[3] = (unsigned __int8 *)groupnum;
}

//----- (0805A730) --------------------------------------------------------
widget_handler_status_T __cdecl init_checkbox(dialog_data *dlg_data, widget_data *widget_data)
{
  unsigned __int8 *cdata; // esi

  cdata = widget_data->cdata;
  if ( !assert_failed )
  {
    assert_failed = cdata == 0;
    if ( !cdata )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
      errline = 96;
      elinks_internal("assertion cdata failed!");
    }
  }
  if ( widget_data->widget->info.checkbox.gid )
  {
    if ( *(_DWORD *)cdata != widget_data->widget->info.checkbox.gnum )
      return 0;
  }
  else if ( !*(_DWORD *)cdata )
  {
    return 0;
  }
  widget_data->info.field.vpos = 1;
  return 0;
}

//----- (0805A7C0) --------------------------------------------------------
widget_handler_status_T __cdecl select_checkbox(dialog_data *dlg_data, widget_data *widget_data)
{
  widget_data *v2; // edi
  unsigned __int8 *v3; // ebx
  int v4; // eax
  int number_of_widgets; // edx
  widget_data *widgets_data; // ebx
  widget *widget; // ecx
  _DWORD *cdata; // [esp+1Ch] [ebp-2Ch]

  v2 = widget_data;
  if ( widget_data->widget->info.checkbox.gid )
  {
    number_of_widgets = dlg_data->number_of_widgets;
    widgets_data = dlg_data->widgets_data;
    if ( dlg_data->widgets_data != &dlg_data->widgets_data[number_of_widgets] )
    {
      do
      {
        cdata = widgets_data->cdata;
        if ( widgets_data->widget->type == WIDGET_CHECKBOX )
        {
          widget = widget_data->widget;
          if ( widgets_data->widget->info.checkbox.gid == widget_data->widget->info.checkbox.gid )
          {
            if ( !assert_failed )
            {
              assert_failed = cdata == 0;
              if ( !cdata )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
                errline = 154;
                elinks_internal("assertion cdata failed!");
              }
              widget = widget_data->widget;
            }
            *cdata = widget->info.checkbox.gnum;
            widgets_data->info.field.vpos = 0;
            display_widget(dlg_data, widgets_data);
            number_of_widgets = dlg_data->number_of_widgets;
          }
        }
        ++widgets_data;
      }
      while ( &dlg_data->widgets_data[number_of_widgets] != widgets_data );
      v2 = widget_data;
    }
    v2->info.field.vpos = 1;
  }
  else
  {
    v3 = widget_data->cdata;
    if ( !assert_failed )
    {
      assert_failed = v3 == 0;
      if ( !v3 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/checkbox.c";
        errline = 136;
        elinks_internal("assertion cdata failed!");
      }
    }
    v4 = *(_DWORD *)v3 == 0;
    *(_DWORD *)v3 = v4;
    widget_data->info.field.vpos = v4;
  }
  display_widget(dlg_data, v2);
  return 0;
}

//----- (0805A920) --------------------------------------------------------
widget_handler_status_T __cdecl mouse_checkbox(dialog_data *dlg_data, widget_data *widget_data)
{
  term_event *term_event; // ebx
  int x; // eax
  int v4; // edx
  int v6; // ecx
  widget_handler_T *select; // eax
  terminal *term; // [esp+1Ch] [ebp-2Ch]
  int y; // [esp+2Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  term_event = dlg_data->term_event;
  if ( (term_event->info.mouse.button & 7) > 2 )
    return 1;
  y = term_event->info.mouse.y;
  x = term_event->info.mouse.x;
  v4 = widget_data->box.x;
  if ( x < v4 )
    return 1;
  v6 = widget_data->box.y;
  if ( y < v6 || x >= widget_data->box.width + v4 || y >= v6 + widget_data->box.height )
    return 1;
  select_widget(dlg_data, widget_data);
  term->prev_mouse_event.x = 0;
  term->prev_mouse_event.y = 0;
  term->prev_mouse_event.button = 0;
  if ( (*(_BYTE *)(&term_event->info.size + 1) & 0x20) == 0 )
    return 0;
  select = widget_data->widget->ops->select;
  if ( !select )
    return 0;
  select(dlg_data, widget_data);
  return 0;
}

//----- (0805A9F0) --------------------------------------------------------
widget_handler_status_T __cdecl display_checkbox(dialog_data *dlg_data, widget_data *widget_data)
{
  terminal *term; // edi
  color_pair *bfu_color; // eax
  unsigned __int8 *v4; // edx
  int selected; // [esp+2Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  selected = &dlg_data->widgets_data[dlg_data->selected_widget_id] == widget_data;
  if ( &dlg_data->widgets_data[dlg_data->selected_widget_id] == widget_data )
    bfu_color = get_bfu_color(term, "dialog.checkbox-selected");
  else
    bfu_color = get_bfu_color(term, "dialog.checkbox");
  if ( bfu_color )
  {
    if ( widget_data->info.field.vpos )
    {
      v4 = "[X]";
      if ( widget_data->widget->info.checkbox.gid )
        v4 = "(X)";
    }
    else
    {
      v4 = "[ ]";
      if ( widget_data->widget->info.checkbox.gid )
        v4 = (unsigned __int8 *)&byte_812757A;
    }
    draw_text(term, widget_data->box.x, widget_data->box.y, v4, 3, (screen_char_attr)0, bfu_color);
    if ( selected )
    {
      set_cursor(term, widget_data->box.x + 1, widget_data->box.y, 1);
      dlg_data->win->x = widget_data->box.x;
      dlg_data->win->y = widget_data->box.y;
    }
  }
  return 0;
}

//----- (0805AB10) --------------------------------------------------------
void __cdecl dlg_format_checkbox(
        terminal *term,
        widget_data *widget_data,
        int x,
        int *y,
        int w,
        int *rw,
        format_align align,
        int format_only)
{
  unsigned __int8 *text; // esi
  int v9; // ecx
  int v10; // edx
  int v11; // edi
  color_pair *bfu_color; // [esp+18h] [ebp-30h]
  color_pair *v13; // [esp+18h] [ebp-30h]

  text = widget_data->widget->text;
  v9 = *y;
  v10 = 0;
  v11 = 0;
  if ( x >= 0 )
    v11 = x;
  widget_data->box.x = v11;
  if ( v9 >= 0 )
    v10 = v9;
  widget_data->box.y = v10;
  widget_data->box.width = 3;
  widget_data->box.height = 1;
  if ( w > 4 && text && *text )
  {
    if ( rw )
    {
      *rw -= 4;
      bfu_color = get_bfu_color(term, "dialog.checkbox-label");
      dlg_format_text_do(term, text, x + 4, y, w - 4, rw, bfu_color, align, format_only);
      *rw += 4;
    }
    else
    {
      v13 = get_bfu_color(term, "dialog.checkbox-label");
      dlg_format_text_do(term, text, x + 4, y, w - 4, 0, v13, align, format_only);
    }
  }
}

//----- (0805AC30) --------------------------------------------------------
void __cdecl refresh_dialog(dialog_data *dlg_data, dialog_refresh_handler_T handler, void *data)
{
  dialog_refresh *refresh; // esi
  timer_id_T *p_timer; // edi

  refresh = dlg_data->dlg->refresh;
  if ( refresh )
  {
    p_timer = &refresh->timer;
    kill_timer(&refresh->timer);
LABEL_3:
    refresh->handler = handler;
    refresh->data = data;
    install_timer(p_timer, 100, (void (*)(void *))do_refresh_dialog, dlg_data);
    return;
  }
  refresh = (dialog_refresh *)mem_calloc(1u, 0xCu);
  if ( refresh )
  {
    p_timer = &refresh->timer;
    dlg_data->dlg->refresh = refresh;
    goto LABEL_3;
  }
}

//----- (0805ACC0) --------------------------------------------------------
void __cdecl draw_dialog(dialog_data *dlg_data, int width, int height)
{
  int v3; // edx
  terminal *term; // esi
  int v5; // edi
  int v6; // eax
  int v7; // edi
  int v8; // edi
  box *p_box; // ebx
  color_pair *bfu_color; // eax
  color_pair *v11; // eax
  signed int v12; // [esp+2Ch] [ebp-1Ch]

  v3 = width + 12;
  term = dlg_data->win->term;
  v5 = term->height;
  if ( width + 12 > term->width )
    v3 = term->width;
  v6 = height + 4;
  if ( height + 4 > v5 )
    v6 = term->height;
  v12 = ((unsigned int)(v5 - v6) >> 31) + v5 - v6;
  v7 = (term->width - v3) / 2;
  if ( v7 < 0 )
    v7 = 0;
  dlg_data->box.x = v7;
  v8 = v12 >> 1;
  if ( v12 >> 1 < 0 )
    v8 = 0;
  if ( v3 < 0 )
    v3 = 0;
  if ( v6 < 0 )
    v6 = 0;
  dlg_data->box.width = v3;
  dlg_data->box.y = v8;
  dlg_data->box.height = v6;
  p_box = &dlg_data->box;
  bfu_color = get_bfu_color(term, "dialog.generic");
  draw_box(term, &dlg_data->box, 0x20u, (screen_char_attr)0, bfu_color);
  if ( get_opt_(config_options, "ui.dialogs.shadows")->number )
  {
    v11 = get_bfu_color(term, "dialog.shadow");
    draw_shadow(term, p_box, v11, 2, 1);
    if ( (*((_BYTE *)term + 56) & 2) != 0 )
      fix_dwchar_around_box(term, p_box, 0, 2, 1);
  }
  else if ( (*((_BYTE *)term + 56) & 2) != 0 )
  {
    fix_dwchar_around_box(term, p_box, 0, 0, 0);
  }
}

//----- (0805AE20) --------------------------------------------------------
void __usercall format_widgets(
        terminal *term@<eax>,
        dialog_data *dlg_data@<edx>,
        int x@<ecx>,
        int *y,
        int w,
        int h,
        int *rw,
        int format_only)
{
  widget_data *widgets_data; // esi
  int number_of_widgets; // ebx
  widget *widget; // eax
  int v11; // eax
  widget_data *v12; // eax
  int v13; // ecx
  widget *v14; // edx
  widget_data *v15; // [esp+4h] [ebp-74h]
  widget_data *v16; // [esp+4h] [ebp-74h]
  widget_data *v17; // [esp+4h] [ebp-74h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  int group; // [esp+50h] [ebp-28h]

  widgets_data = dlg_data->widgets_data;
  number_of_widgets = dlg_data->number_of_widgets;
  if ( number_of_widgets > 0 )
  {
    while ( 1 )
    {
      widget = widgets_data->widget;
      switch ( widget->type )
      {
        case WIDGET_CHECKBOX:
          group = widget->info.checkbox.gid;
          if ( group > 0 && (*(_BYTE *)&dlg_data->dlg->layout & 8) != 0 )
          {
            v12 = widgets_data;
            v13 = 1;
            while ( 1 )
            {
              v14 = v12[1].widget;
              if ( v14->type || group != v14->info.checkbox.gid )
                break;
              ++v13;
              ++v12;
              if ( !--number_of_widgets )
              {
                number_of_widgets = -1;
                goto LABEL_19;
              }
            }
            --number_of_widgets;
LABEL_19:
            v18 = v13;
            dlg_format_group(term, widgets_data, v13, x, y, w, rw, format_only);
            widgets_data += v18;
            v11 = *y;
            goto LABEL_5;
          }
          dlg_format_checkbox(term, widgets_data, x, y, w, rw, ALIGN_LEFT, format_only);
          if ( number_of_widgets == 1 )
          {
            ++*y;
            return;
          }
          ++widgets_data;
          if ( widgets_data->widget->type )
          {
            if ( group == -1 )
              goto LABEL_23;
          }
          else if ( widgets_data->widget->info.checkbox.gid == group )
          {
LABEL_23:
            --number_of_widgets;
            v11 = *y - 1;
            *y = v11;
            goto LABEL_5;
          }
LABEL_4:
          v11 = *y;
          --number_of_widgets;
LABEL_5:
          *y = v11 + 1;
          if ( number_of_widgets <= 0 )
            return;
          break;
        case WIDGET_FIELD:
        case WIDGET_FIELD_PASS:
          --number_of_widgets;
          v16 = widgets_data++;
          dlg_format_field(term, v16, x, y, w, rw, ALIGN_LEFT, format_only);
          v11 = *y;
          goto LABEL_5;
        case WIDGET_BUTTON:
          dlg_format_buttons(term, widgets_data, number_of_widgets, x, y, w, rw, ALIGN_CENTER, format_only);
          return;
        case WIDGET_LISTBOX:
          --number_of_widgets;
          v15 = widgets_data++;
          dlg_format_listbox(term, v15, x, y, w, h, rw, ALIGN_LEFT, format_only);
          v11 = *y;
          goto LABEL_5;
        case WIDGET_TEXT:
          --number_of_widgets;
          v17 = widgets_data++;
          dlg_format_text(term, v17, x, y, w, rw, h, format_only);
          v11 = *y;
          goto LABEL_5;
        default:
          ++widgets_data;
          goto LABEL_4;
      }
    }
  }
}

//----- (0805B0E0) --------------------------------------------------------
void __cdecl generic_dialog_layouter(dialog_data *dlg_data)
{
  terminal *term; // esi
  int width; // ecx
  int v3; // edi
  int v4; // edx
  int v5; // ecx
  int height; // ecx
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  dialog *dlg; // edx
  dialog *v12; // edx
  char layout; // al
  int datalen; // eax
  int v15; // eax
  dialog *v16; // [esp+28h] [ebp-30h]
  int v17; // [esp+28h] [ebp-30h]
  int h; // [esp+2Ch] [ebp-2Ch]
  int rw; // [esp+38h] [ebp-20h] BYREF
  int y[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  term = dlg_data->win->term;
  width = term->width;
  v3 = 1;
  v4 = 9 * width / 10 - 12;
  if ( v4 > 0 )
  {
    v5 = width - 12;
    if ( v5 > 0 )
      v3 = v5;
    if ( v4 <= v3 )
      v3 = v4;
  }
  height = term->height;
  h = 1;
  v7 = 9 * height / 10 - 4;
  if ( v7 > 0 )
  {
    v8 = height - 4;
    v9 = 1;
    if ( v8 > 0 )
      v9 = v8;
    if ( v7 <= v9 )
      v9 = v7;
    h = v9;
  }
  if ( (*((_BYTE *)term + 56) & 2) != 0 )
  {
    v15 = utf8_ptr2cells(dlg_data->dlg->title, 0);
    if ( v15 > v3 )
      v15 = v3;
    rw = v15;
    dlg = dlg_data->dlg;
  }
  else
  {
    v16 = dlg_data->dlg;
    v10 = strlen((const char *)v16->title);
    dlg = v16;
    if ( v10 > v3 )
      v10 = v3;
    rw = v10;
  }
  y[0] = -((*(_BYTE *)&dlg->layout & 2) == 0);
  format_widgets(term, dlg_data, 0, y, v3, h, &rw, 1);
  v12 = dlg_data->dlg;
  layout = (char)v12->layout;
  if ( (layout & 4) == 0 )
  {
    if ( (layout & 1) == 0 )
    {
      datalen = rw;
      goto LABEL_23;
    }
    goto LABEL_20;
  }
  datalen = v12->widgets[0].datalen;
  if ( datalen > rw )
    rw = v12->widgets[0].datalen;
  else
    datalen = rw;
  if ( v3 <= datalen )
LABEL_20:
    datalen = v3;
LABEL_23:
  v17 = datalen;
  draw_dialog(dlg_data, datalen, y[0]);
  y[0] = dlg_data->box.y + ((*(_BYTE *)&dlg_data->dlg->layout & 2) != 0) + 2;
  format_widgets(term, dlg_data, dlg_data->box.x + 6, y, v17, h, 0, 0);
}

//----- (0805B280) --------------------------------------------------------
int __cdecl update_dialog_data(dialog_data *dlg_data)
{
  int number_of_widgets; // edx
  dialog_data *i; // ebx

  number_of_widgets = dlg_data->number_of_widgets;
  for ( i = (dialog_data *)dlg_data->widgets_data;
        &dlg_data->widgets_data[number_of_widgets] != (widget_data *)i;
        i = (dialog_data *)((char *)i + 48) )
  {
    if ( i->win->data )
    {
      memcpy(i->win->handler, i->dlg, (size_t)i->win->data);
      number_of_widgets = dlg_data->number_of_widgets;
    }
  }
  return 0;
}

//----- (0805B2F0) --------------------------------------------------------
widget_handler_status_T __cdecl cancel_dialog(dialog_data *dlg_data, widget_data *xxx)
{
  delete_window(dlg_data->win);
  return 0;
}

//----- (0805B310) --------------------------------------------------------
void __cdecl select_widget(dialog_data *dlg_data, widget_data *widget_data)
{
  widget_data *v2; // edx

  v2 = &dlg_data->widgets_data[dlg_data->selected_widget_id];
  dlg_data->selected_widget_id = -1431655765 * (((char *)widget_data - (char *)dlg_data->widgets_data) >> 4);
  display_widget(dlg_data, v2);
  display_widget(dlg_data, widget_data);
}

//----- (0805B370) --------------------------------------------------------
widget_data *__cdecl select_widget_by_id(dialog_data *dlg_data, int i)
{
  widget_data *v2; // ebx

  v2 = 0;
  if ( dlg_data->number_of_widgets > i )
  {
    v2 = &dlg_data->widgets_data[i];
    select_widget(dlg_data, v2);
  }
  return v2;
}

//----- (0805B3B0) --------------------------------------------------------
void __usercall select_dlg_item(dialog_data *dlg_data@<eax>, widget_data *widget_data@<edx>)
{
  widget_handler_T *select; // eax

  select_widget(dlg_data, widget_data);
  select = widget_data->widget->ops->select;
  if ( select )
    select(dlg_data, widget_data);
}

//----- (0805B3F0) --------------------------------------------------------
void __usercall cycle_widget_focus(dialog_data *dlg_data@<eax>, int direction@<edx>)
{
  int number_of_widgets; // edx
  int selected_widget_id; // eax
  int v5; // edx
  char *v6; // edi
  int v7; // esi
  int v8; // ecx
  int v9; // ecx
  int cpos; // edx
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+14h] [ebp-24h]
  int v14; // [esp+1Ch] [ebp-1Ch]

  number_of_widgets = dlg_data->number_of_widgets;
  selected_widget_id = dlg_data->selected_widget_id;
  v14 = number_of_widgets;
  v12 = selected_widget_id;
  v11 = number_of_widgets - 1;
  do
  {
    selected_widget_id += direction;
    dlg_data->selected_widget_id = selected_widget_id;
    if ( selected_widget_id < v14 )
    {
      v5 = selected_widget_id;
      if ( selected_widget_id < 0 )
      {
        selected_widget_id = v11;
        dlg_data->selected_widget_id = v11;
        v5 = v11;
      }
    }
    else
    {
      dlg_data->selected_widget_id = 0;
      v5 = 0;
      selected_widget_id = 0;
    }
    v6 = (char *)dlg_data + 48 * v5;
    v7 = *((_DWORD *)v6 + 10);
    v8 = *(_DWORD *)(v7 + 44);
    if ( v8 != 4 )
    {
      if ( v8 != 5 )
        break;
      if ( (*(_BYTE *)(v7 + 24) & 2) != 0 )
      {
        v9 = *((_DWORD *)v6 + 15);
        if ( v9 > 0 )
        {
          cpos = dlg_data->widgets_data[v5].info.field.cpos;
          if ( cpos > 0 && v9 < cpos )
            break;
        }
      }
    }
  }
  while ( v12 != selected_widget_id );
  display_widget(dlg_data, &dlg_data->widgets_data[v12]);
  display_widget(dlg_data, &dlg_data->widgets_data[dlg_data->selected_widget_id]);
  redraw_from_window(dlg_data->win);
}

//----- (0805B4D0) --------------------------------------------------------
void __cdecl redraw_dialog(dialog_data *dlg_data, int layout)
{
  terminal *term; // esi
  int v3; // eax
  int v4; // edi
  int v5; // ecx
  int v6; // edx
  color_pair *bfu_color; // eax
  unsigned __int8 *v8; // edi
  color_pair *v9; // edi
  size_t v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  dialog_data *i; // esi
  int selected_widget_id; // edx
  char *v16; // eax
  int v17; // edi
  int v18; // ecx
  int v19; // ecx
  int cpos; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  widget_data *v24; // [esp+4h] [ebp-64h]
  int length; // [esp+2Ch] [ebp-3Ch]
  int lengtha; // [esp+2Ch] [ebp-3Ch]
  int width; // [esp+30h] [ebp-38h]
  int v28; // [esp+30h] [ebp-38h]
  int max_cells; // [esp+34h] [ebp-34h]
  int max_cellsa; // [esp+34h] [ebp-34h]
  unsigned __int8 *title; // [esp+38h] [ebp-30h]
  int y; // [esp+3Ch] [ebp-2Ch]
  box box; // [esp+40h] [ebp-28h] BYREF

  term = dlg_data->win->term;
  if ( layout )
  {
    dlg_data->dlg->layouter(dlg_data);
    selected_widget_id = dlg_data->selected_widget_id;
    v16 = (char *)dlg_data + 48 * selected_widget_id;
    v17 = *((_DWORD *)v16 + 10);
    v18 = *(_DWORD *)(v17 + 44);
    if ( v18 == 4
      || v18 == 5
      && ((*(_BYTE *)(v17 + 24) & 2) == 0
       || (v19 = *((_DWORD *)v16 + 15), v19 <= 0)
       || (cpos = dlg_data->widgets_data[selected_widget_id].info.field.cpos, cpos <= 0)
       || v19 >= cpos) )
    {
      cycle_widget_focus(dlg_data, 1);
    }
  }
  if ( (*(_BYTE *)&dlg_data->dlg->layout & 0x10) == 0 )
  {
    v3 = 0;
    v4 = dlg_data->box.x + 4;
    if ( v4 < 0 )
      v4 = 0;
    v5 = dlg_data->box.y + 2;
    if ( v5 < 0 )
      v5 = 0;
    v6 = dlg_data->box.width - 8;
    if ( v6 < 0 )
      v6 = 0;
    box.y = v5;
    box.x = v4;
    box.width = v6;
    if ( dlg_data->box.height - 4 >= 0 )
      v3 = dlg_data->box.height - 4;
    box.height = v3;
    bfu_color = get_bfu_color(term, "dialog.frame");
    draw_border(term, &box, bfu_color, 2);
    if ( !assert_failed )
    {
      v8 = dlg_data->dlg->title;
      assert_failed = v8 == 0;
      if ( !v8 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
        errline = 95;
        elinks_internal("assertion dlg_data->dlg->title failed!");
      }
    }
    v9 = get_bfu_color(term, "dialog.title");
    if ( v9 && box.width > 2 )
    {
      width = box.width;
      title = dlg_data->dlg->title;
      v10 = strlen((const char *)title);
      v11 = width;
      v12 = v10;
      if ( (*((_BYTE *)term + 56) & 2) != 0 )
      {
        lengtha = v10;
        v21 = utf8_ptr2cells(title, &title[v10]);
        v11 = box.width;
        v12 = lengtha;
        max_cellsa = v21;
        v22 = box.width - 2;
        if ( max_cellsa <= box.width - 2 )
          v22 = max_cellsa;
        max_cells = v22;
        if ( (*((_BYTE *)term + 56) & 2) != 0 )
        {
          v23 = utf8_cells2bytes(title, v22, 0);
          v11 = box.width;
          v12 = v23;
        }
      }
      else
      {
        v13 = width - 2;
        if ( v12 <= width - 2 )
          v13 = v12;
        max_cells = v13;
      }
      length = v12;
      y = box.y - 1;
      v28 = box.x + (v11 - max_cells) / 2;
      draw_text(term, v28 - 1, box.y - 1, (unsigned __int8 *)&start, 1, (screen_char_attr)0, v9);
      draw_text(term, v28, y, title, length, (screen_char_attr)0, v9);
      draw_text(term, max_cells + v28, y, (unsigned __int8 *)&start, 1, (screen_char_attr)0, v9);
    }
  }
  for ( i = (dialog_data *)&dlg_data->widgets_data[dlg_data->number_of_widgets - 1];
        i != (dialog_data *)&dlg_data[-1].widgets_data[0].info.text.scroller_y;
        i = (dialog_data *)((char *)i - 48) )
  {
    v24 = (widget_data *)i;
    display_widget(dlg_data, v24);
  }
  redraw_from_window(dlg_data->win);
}

//----- (0805B7A0) --------------------------------------------------------
void __cdecl do_refresh_dialog(dialog_data *dlg_data)
{
  dialog_refresh *refresh; // ebx
  int v2; // eax

  refresh = dlg_data->dlg->refresh;
  if ( !assert_failed )
  {
    if ( refresh && refresh->handler )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c";
      errline = 685;
      elinks_internal("assertion refresh && refresh->handler failed!");
    }
  }
  v2 = refresh->handler(dlg_data, refresh->data);
  if ( v2 == 3 || v2 == 1 )
  {
    refresh->timer = 0;
    if ( v2 == 1 )
      delete_window(dlg_data->win);
  }
  else
  {
    if ( !v2 )
      redraw_dialog(dlg_data, 1);
    install_timer(&refresh->timer, 100, (void (*)(void *))do_refresh_dialog, dlg_data);
  }
}

//----- (0805B890) --------------------------------------------------------
widget_handler_status_T __cdecl clear_dialog(dialog_data *dlg_data, widget_data *xxx)
{
  int number_of_widgets; // edx
  dialog_data *i; // ebx
  terminal *term; // eax

  number_of_widgets = dlg_data->number_of_widgets;
  for ( i = (dialog_data *)dlg_data->widgets_data;
        &dlg_data->widgets_data[number_of_widgets] != (widget_data *)i;
        i = (dialog_data *)((char *)i + 48) )
  {
    term = i->win->next->term;
    if ( term )
    {
      ((void (__cdecl *)(dialog_data *, dialog_data *))term)(dlg_data, i);
      number_of_widgets = dlg_data->number_of_widgets;
    }
  }
  select_widget_by_id(dlg_data, 0);
  redraw_dialog(dlg_data, 0);
  return 0;
}

//----- (0805B910) --------------------------------------------------------
int __cdecl check_dialog(dialog_data *dlg_data)
{
  int number_of_widgets; // edx
  dialog_data *widgets_data; // ebx
  int (__cdecl *type)(dialog_data *, dialog_data *); // eax

  number_of_widgets = dlg_data->number_of_widgets;
  widgets_data = (dialog_data *)dlg_data->widgets_data;
  if ( dlg_data->widgets_data == &dlg_data->widgets_data[number_of_widgets] )
    return 0;
  while ( 1 )
  {
    if ( widgets_data->win[1].next > (window *)2 )
      goto LABEL_6;
    type = (int (__cdecl *)(dialog_data *, dialog_data *))widgets_data->win->type;
    if ( !type )
      goto LABEL_6;
    if ( type(dlg_data, widgets_data) == 1 )
      break;
    number_of_widgets = dlg_data->number_of_widgets;
LABEL_6:
    widgets_data = (dialog_data *)((char *)widgets_data + 48);
    if ( &dlg_data->widgets_data[number_of_widgets] == (widget_data *)widgets_data )
      return 0;
  }
  select_widget(dlg_data, (widget_data *)widgets_data);
  redraw_dialog(dlg_data, 0);
  return 1;
}

//----- (0805B9A0) --------------------------------------------------------
widget_handler_status_T __cdecl ok_dialog(dialog_data *dlg_data, widget_data *widget_data)
{
  done_handler_T *done; // esi
  void *done_data; // edi
  int v4; // edx
  widget_handler_status_T result; // eax

  done = widget_data->widget->info.button.done;
  done_data = widget_data->widget->info.button.done_data;
  v4 = check_dialog(dlg_data);
  result = EVENT_NOT_PROCESSED;
  if ( !v4 )
  {
    update_dialog_data(dlg_data);
    if ( done )
      done(done_data);
    delete_window(dlg_data->win);
    return 0;
  }
  return result;
}

//----- (0805BA00) --------------------------------------------------------
dialog_data *__cdecl do_dialog(terminal *term, dialog *dlg, memory_list *ml)
{
  dialog_data *v3; // eax
  dialog_data *v4; // edi
  int number_of_widgets; // eax

  v3 = (dialog_data *)mem_calloc(1u, 48 * dlg->number_of_widgets + 88);
  v4 = v3;
  if ( v3 )
  {
    v3->dlg = dlg;
    number_of_widgets = dlg->number_of_widgets;
    v4->ml = ml;
    v4->number_of_widgets = number_of_widgets;
    add_window(term, dialog_func, v4);
  }
  else
  {
    freeml(ml);
  }
  return v4;
}

//----- (0805BA80) --------------------------------------------------------
void __cdecl dialog_func(window *win, term_event *ev)
{
  dialog_data *data; // ebx
  dialog *dlg; // eax
  widget_handler_status_T (*handle_event)(dialog_data *); // eax
  dialog_data *v5; // esi
  int v6; // eax
  int (__cdecl *type)(dialog_data *, dialog_data *); // edx
  int selected_widget_id; // esi
  const widget_ops *ops; // edi
  widget_handler_T *kbd; // eax
  term_event *v11; // eax
  signed int v12; // edx
  int v13; // eax
  dialog_data *v14; // esi
  int number_of_widgets; // eax
  unsigned __int8 *prev; // eax
  int xpos; // edx
  const unsigned __int8 *v18; // eax
  unicode_val_T v19; // eax
  int v20; // edx
  int *v21; // esi
  int v22; // ebx
  void (__cdecl *v23)(term_event *, char *); // edx
  int v24; // eax
  int v25; // edx
  int v26; // edx
  int x; // ecx
  int v28; // eax
  int p_y; // edx
  dialog *v30; // eax
  timer_id_T *refresh; // esi
  void (*abort)(dialog_data *); // eax
  widget_data *v33; // ebx
  int *next; // eax
  int *p_max_width; // edi
  int *v36; // edx
  int *i; // edx
  int *v38; // esi
  int *v39; // edx
  int v40; // eax
  int v41; // edx
  void *v42; // eax
  widget_handler_T *select; // eax
  widget_data *widgets_data; // edx
  int v45; // ecx
  int y; // eax
  int v47; // ecx
  term_event *term_event; // [esp+18h] [ebp-30h]
  term_event *v49; // [esp+18h] [ebp-30h]
  term_event *v50; // [esp+18h] [ebp-30h]
  widget_data *codepage; // [esp+1Ch] [ebp-2Ch]
  int codepagea; // [esp+1Ch] [ebp-2Ch]
  char *codepageb; // [esp+1Ch] [ebp-2Ch]
  int codepagec; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *string; // [esp+2Ch] [ebp-1Ch] BYREF

  data = (dialog_data *)win->data;
  data->win = win;
  dlg = data->dlg;
  data->term_event = ev;
  handle_event = dlg->handle_event;
  if ( !handle_event || handle_event(data) )
  {
    switch ( ev->ev )
    {
      case EVENT_INIT:
        v20 = data->number_of_widgets - 1;
        if ( v20 < 0 )
          goto LABEL_7;
        v21 = (int *)&data->widgets_data[v20];
        v50 = (term_event *)data;
        v22 = data->number_of_widgets - 1;
        while ( 1 )
        {
          v26 = 48 * v22 + 32;
          codepageb = (char *)&v50->info.size.height + v26;
          memset(codepageb, 0, 0x30u);
          x = v50->info.mouse.x;
          v28 = x + v26 + 4;
          *v21 = v28;
          if ( !*(_DWORD *)(x + 48 * (v22 + 1) + 4) )
            goto LABEL_41;
          v42 = mem_alloc(*(_DWORD *)(x + 48 * (v22 + 1) + 4));
          v21[1] = (int)v42;
          if ( v42 )
            break;
LABEL_39:
          v21 -= 12;
          if ( --v22 < 0 )
          {
            data = (dialog_data *)v50;
            goto LABEL_7;
          }
        }
        memcpy(v42, *(const void **)(*v21 + 12), *(_DWORD *)(*v21 + 16));
        v28 = *v21;
LABEL_41:
        *(const widget_ops **)v28 = widget_type_to_ops[*(_DWORD *)(v28 + 44)];
        v24 = *v21;
        if ( *(_DWORD *)(*v21 + 44) == 1 && *(_DWORD *)(v24 + 28) )
        {
          p_y = (int)&v50[3 * v22 + 4].info.mouse.y;
          v21[9] = p_y;
          v21[8] = p_y;
          v21[10] = p_y;
        }
        v23 = *(void (__cdecl **)(term_event *, char *))(*(_DWORD *)v24 + 4);
        if ( v23 )
        {
          v23(v50, codepageb);
          v24 = *v21;
        }
        v25 = *(_DWORD *)(v24 + 44);
        if ( v25 != 4 )
        {
          if ( v25 != 5
            || (*(_BYTE *)(v24 + 24) & 2) != 0 && (v40 = v21[5], v40 > 0) && (v41 = v21[7], v41 > 0) && v40 < v41 )
          {
            v50[2].ev = v22;
          }
        }
        goto LABEL_39;
      case EVENT_KBD:
        selected_widget_id = data->selected_widget_id;
        codepage = &data->widgets_data[selected_widget_id];
        ops = codepage->widget->ops;
        term_event = data->term_event;
        kbd = ops->kbd;
        if ( kbd && kbd(data, &data->widgets_data[selected_widget_id]) == EVENT_PROCESSED )
          return;
        switch ( kbd_action(KEYMAP_MENU, term_event, 0) )
        {
          case 2:
            widgets_data = data->widgets_data;
            v45 = (int)&data->widgets_data[data->number_of_widgets];
            if ( data->widgets_data != (widget_data *)v45 )
            {
              do
              {
                if ( widgets_data->widget->type == WIDGET_BUTTON && (widgets_data->widget->info.checkbox.gid & 2) != 0 )
                  goto LABEL_87;
                ++widgets_data;
              }
              while ( widgets_data != (widget_data *)v45 );
            }
            return;
          case 4:
          case 11:
          case 16:
            cycle_widget_focus(data, 1);
            return;
          case 6:
            select = ops->select;
            if ( select )
              goto LABEL_76;
            if ( (unsigned int)(data->widgets_data[selected_widget_id].widget->type - 1) <= 1
              || (y = term_event->info.mouse.y, y == 2)
              || y == 4 )
            {
              widgets_data = data->widgets_data;
              v47 = (int)&data->widgets_data[data->number_of_widgets];
              if ( data->widgets_data != (widget_data *)v47 )
              {
                do
                {
                  if ( widgets_data->widget->type == WIDGET_BUTTON && (widgets_data->widget->info.checkbox.gid & 1) != 0 )
                    goto LABEL_87;
                  ++widgets_data;
                }
                while ( widgets_data != (widget_data *)v47 );
              }
            }
            return;
          case 9:
          case 14:
          case 20:
            cycle_widget_focus(data, -1);
            return;
          case 15:
            redraw_terminal_cls(data->win->term);
            return;
          case 18:
            select = ops->select;
            if ( select )
LABEL_76:
              select(data, codepage);
            return;
          default:
            v11 = data->term_event;
            v12 = v11->info.mouse.x;
            if ( v12 <= 32 )
              return;
            v13 = v11->info.mouse.y;
            if ( v13 != 4 )
            {
              if ( v13 )
                return;
            }
            v14 = (dialog_data *)data->widgets_data;
            v49 = (term_event *)unicode_fold_label_case(v12);
            codepagea = get_terminal_codepage(data->win->term);
            number_of_widgets = data->number_of_widgets;
            if ( data->widgets_data == &data->widgets_data[number_of_widgets] )
              return;
            break;
        }
        while ( 2 )
        {
          if ( v14->win[1].next != (window *)3 )
            goto LABEL_23;
          prev = (unsigned __int8 *)v14->win->prev;
          string = prev;
          if ( !*prev )
            goto LABEL_31;
          xpos = v14->win->xpos;
          if ( xpos >= 0 )
          {
            prev += xpos + 1;
            string = prev;
          }
          v18 = (const unsigned __int8 *)__rawmemchr(prev, 0);
          v19 = cp_to_unicode(codepagea, &string, v18);
          if ( assert_failed
            || (assert_failed = v19 == -3) != 0
            && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/dialog.c",
                errline = 329,
                elinks_internal("assertion hk_char != UCS_NO_CHAR failed!"),
                v19 = -3,
                assert_failed) )
          {
            assert_failed = 0;
            goto LABEL_31;
          }
          if ( v49 != (term_event *)unicode_fold_label_case(v19) )
          {
LABEL_31:
            number_of_widgets = data->number_of_widgets;
LABEL_23:
            v14 = (dialog_data *)((char *)v14 + 48);
            if ( v14 == (dialog_data *)&data->widgets_data[number_of_widgets] )
              return;
            continue;
          }
          break;
        }
        widgets_data = (widget_data *)v14;
LABEL_87:
        select_dlg_item(data, widgets_data);
        break;
      case EVENT_MOUSE:
        v5 = (dialog_data *)data->widgets_data;
        v6 = data->number_of_widgets;
        while ( 2 )
        {
          if ( v5 == (dialog_data *)&data->widgets_data[v6] )
            return;
          type = (int (__cdecl *)(dialog_data *, dialog_data *))v5->win->next->type;
          if ( !type )
            goto LABEL_12;
          if ( type(data, v5) )
          {
            v6 = data->number_of_widgets;
LABEL_12:
            v5 = (dialog_data *)((char *)v5 + 48);
            continue;
          }
          return;
        }
      case EVENT_REDRAW:
      case EVENT_RESIZE:
LABEL_7:
        redraw_dialog(data, 1);
        return;
      case EVENT_ABORT:
        v30 = data->dlg;
        refresh = (timer_id_T *)v30->refresh;
        if ( refresh )
        {
          kill_timer(refresh + 2);
          mem_free(refresh);
          v30 = data->dlg;
        }
        abort = v30->abort;
        if ( abort )
          abort(data);
        if ( &data->widgets_data[data->number_of_widgets] != data->widgets_data )
        {
          codepagec = (int)data;
          v33 = data->widgets_data;
          do
          {
            if ( v33->cdata )
              mem_free(v33->cdata);
            if ( v33->widget->type == WIDGET_FIELD && v33->widget->info.button.textlen )
            {
              next = (int *)v33->info.field.history.next;
              p_max_width = &v33->info.text.max_width;
              if ( &v33->info.text.max_width != next )
              {
                v36 = (int *)v33->info.field.history.next;
                do
                  v36 = (int *)*v36;
                while ( p_max_width != v36 );
              }
              for ( i = (int *)v33->info.field.history.prev; p_max_width != i; i = (int *)i[1] )
                ;
              v38 = (int *)*next;
              if ( p_max_width != next )
              {
                v39 = (int *)*next;
                while ( 1 )
                {
                  v39[1] = next[1];
                  *(_DWORD *)next[1] = *next;
                  mem_free(next);
                  v39 = (int *)*v38;
                  if ( v38 == p_max_width )
                    break;
                  next = v38;
                  v38 = (int *)*v38;
                }
              }
            }
            ++v33;
          }
          while ( v33 != (widget_data *)(codepagec + 48 * *(_DWORD *)(codepagec + 28) + 40) );
          data = (dialog_data *)codepagec;
        }
        freeml(data->ml);
        return;
      default:
        return;
    }
  }
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (0805C030) --------------------------------------------------------
void __cdecl dlg_format_group(
        terminal *term,
        widget_data *widget_data,
        int n,
        int x,
        int *y,
        int w,
        int *rw,
        int format_only)
{
  int v8; // ecx
  widget_data *i; // ebx
  int v10; // edx
  widget_type type; // eax
  widget *widget; // edi
  unsigned __int8 *text; // esi
  signed int v14; // eax
  int v15; // edi
  widget_type v16; // eax
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // [esp+10h] [ebp-48h]
  int v27; // [esp+10h] [ebp-48h]
  int v28; // [esp+24h] [ebp-34h]
  int v29; // [esp+28h] [ebp-30h]
  int v30; // [esp+28h] [ebp-30h]
  int v31; // [esp+28h] [ebp-30h]
  int v32; // [esp+28h] [ebp-30h]
  int v33; // [esp+28h] [ebp-30h]
  color_pair *color; // [esp+2Ch] [ebp-2Ch]
  int max_cells; // [esp+30h] [ebp-28h]
  _BOOL4 v36; // [esp+34h] [ebp-24h]
  int width; // [esp+38h] [ebp-20h]
  int xpos; // [esp+3Ch] [ebp-1Ch]
  int xposa; // [esp+3Ch] [ebp-1Ch]

  color = get_bfu_color(term, "dialog.text");
  if ( !assert_failed )
  {
    assert_failed = n <= 0;
    if ( n > 0
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/group.c",
          errline = 32,
          elinks_internal("assertion n > 0 failed!"),
          !assert_failed) )
    {
      v8 = n;
      xpos = 0;
      for ( i = widget_data + 1; ; ++i )
      {
        if ( !v8 )
        {
          ++*y;
          return;
        }
        widget = i[-1].widget;
        text = widget->text;
        if ( (*((_BYTE *)term + 56) & 2) != 0 )
          break;
        if ( !text || !*text )
          goto LABEL_6;
        v29 = v8;
        v14 = strlen((const char *)widget->text);
        v8 = v29;
        v10 = v14;
        v36 = v14 > 0;
        type = widget->type;
        width = 3;
        if ( type == WIDGET_CHECKBOX )
          goto LABEL_15;
LABEL_8:
        if ( (unsigned int)(type - 1) > 1 )
          goto LABEL_9;
        if ( (*((_BYTE *)term + 56) & 2) != 0 )
        {
          v28 = v10;
          v33 = v8;
          v25 = utf8_ptr2cells((unsigned __int8 *)widget->data, 0);
          v10 = v28;
          v8 = v33;
          width = v25;
        }
        else
        {
          width = widget->datalen;
        }
LABEL_15:
        max_cells = 0;
        if ( v10 >= 0 )
        {
          if ( w - width - v36 <= v10 )
            v10 = w - width - v36;
          max_cells = v10;
        }
        v15 = v36 + width + max_cells;
        if ( w < v15 + xpos )
        {
          *y += 2;
          xpos = 0;
        }
        else
        {
          v15 += xpos;
        }
        if ( !format_only )
        {
          xposa = x + xpos;
          v16 = i[-1].widget->type;
          if ( v16 )
          {
            if ( (unsigned int)(v16 - 1) <= 1 )
            {
              if ( max_cells )
              {
                v31 = v8;
                if ( (*((_BYTE *)term + 56) & 2) != 0 )
                {
                  v27 = utf8_cells2bytes(text, max_cells, 0);
                  draw_text(term, xposa, *y, text, v27, (screen_char_attr)0, color);
                }
                else
                {
                  draw_text(term, xposa, *y, text, max_cells, (screen_char_attr)0, color);
                }
                v8 = v31;
              }
              v20 = xposa + v36 + max_cells;
              v21 = *y;
              if ( v20 < 0 )
                v20 = 0;
              i[-1].box.x = v20;
              v22 = 0;
              if ( v21 >= 0 )
                v22 = v21;
              i[-1].box.y = v22;
              v23 = 0;
              if ( width >= 0 )
                v23 = width;
              i[-1].box.height = 1;
              i[-1].box.width = v23;
            }
          }
          else
          {
            if ( max_cells )
            {
              v30 = v8;
              if ( (*((_BYTE *)term + 56) & 2) != 0 )
              {
                v26 = utf8_cells2bytes(text, max_cells, 0);
                draw_text(term, xposa + v36 + width, *y, text, v26, (screen_char_attr)0, color);
              }
              else
              {
                draw_text(term, xposa + v36 + width, *y, text, max_cells, (screen_char_attr)0, color);
              }
              v8 = v30;
            }
            v17 = 0;
            v18 = *y;
            if ( xposa >= 0 )
              v17 = xposa;
            i[-1].box.x = v17;
            v19 = 0;
            if ( v18 < 0 )
              v18 = 0;
            i[-1].box.y = v18;
            if ( width >= 0 )
              v19 = width;
            i[-1].box.height = 1;
            i[-1].box.width = v19;
          }
        }
        if ( rw )
        {
          if ( *rw >= v15 )
          {
            if ( w < *rw )
              *rw = w;
          }
          else
          {
            *rw = v15;
          }
        }
        xpos = v15 + 1;
LABEL_9:
        --v8;
      }
      if ( text && *text )
      {
        v32 = v8;
        v24 = utf8_ptr2cells(text, 0);
        v8 = v32;
        v10 = v24;
        v36 = v24 > 0;
        widget = i[-1].widget;
      }
      else
      {
LABEL_6:
        v36 = 0;
        v10 = 0;
      }
      type = widget->type;
      width = 3;
      if ( type == WIDGET_CHECKBOX )
        goto LABEL_15;
      goto LABEL_8;
    }
  }
  assert_failed = 0;
}

//----- (0805C440) --------------------------------------------------------
void __cdecl group_layouter(dialog_data *dlg_data)
{
  terminal *term; // esi
  int width; // ecx
  int v3; // edi
  int v4; // edx
  int v5; // ecx
  signed int v6; // eax
  int v7; // edi
  int v8; // eax
  int n; // [esp+4Ch] [ebp-2Ch]
  int y; // [esp+58h] [ebp-20h] BYREF
  int rw[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  term = dlg_data->win->term;
  width = term->width;
  v3 = 1;
  v4 = 9 * width / 10 - 12;
  if ( v4 > 0 )
  {
    v5 = width - 12;
    if ( v5 > 0 )
      v3 = v5;
    if ( v4 <= v3 )
      v3 = v4;
  }
  y = 0;
  n = dlg_data->number_of_widgets - 2;
  if ( (*((_BYTE *)term + 56) & 2) != 0 )
  {
    v8 = utf8_ptr2cells(dlg_data->dlg->title, 0);
    if ( v8 > v3 )
      v8 = v3;
    rw[0] = v8;
  }
  else
  {
    v6 = strlen((const char *)dlg_data->dlg->title);
    if ( v6 > v3 )
      v6 = v3;
    rw[0] = v6;
  }
  dlg_format_group(term, dlg_data->widgets_data, n, 0, &y, v3, rw, 1);
  ++y;
  dlg_format_buttons(term, &dlg_data->widgets_data[n], 2, 0, &y, v3, rw, ALIGN_CENTER, 1);
  v7 = rw[0];
  draw_dialog(dlg_data, rw[0], y);
  y = dlg_data->box.y + 3;
  dlg_format_group(term, dlg_data->widgets_data, n, dlg_data->box.x + 6, &y, v7, 0, 0);
  ++y;
  dlg_format_buttons(term, &dlg_data->widgets_data[n], 2, dlg_data->box.x + 6, &y, v7, rw, ALIGN_CENTER, 0);
}

//----- (0805C620) --------------------------------------------------------
void __usercall recursively_set_expanded(listbox_item *item@<eax>, int expanded@<edx>)
{
  listbox_item *next; // ebx
  list_head_elinks *p_child; // edi

  if ( item->type == BI_FOLDER )
  {
    next = (listbox_item *)item->child.next;
    p_child = &item->child;
    for ( *((_BYTE *)item + 24) = expanded & 1 | *((_BYTE *)item + 24) & 0xFE;
          next != (listbox_item *)p_child;
          next = next->next )
    {
      recursively_set_expanded(next, expanded);
    }
  }
}

//----- (0805C680) --------------------------------------------------------
int __cdecl scan_for_marks(listbox_item *item, void *info_, int *offset)
{
  if ( (*((_BYTE *)item + 24) & 4) != 0 )
  {
    *((_DWORD *)info_ + 1) = 0;
    *offset = 0;
  }
  return 0;
}

//----- (0805C6B0) --------------------------------------------------------
int __cdecl scan_for_used(listbox_item *item, void *info_, int *offset)
{
  if ( (*(int (__cdecl **)(listbox_item *))(*(_DWORD *)(*((_DWORD *)info_ + 2) + 8) + 8))(item) )
  {
    *((_DWORD *)info_ + 1) = item;
    *offset = 0;
  }
  return 0;
}

//----- (0805C6F0) --------------------------------------------------------
void __cdecl done_listbox_context(void *context_)
{
  if ( *((_DWORD *)context_ + 1) )
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(*((_DWORD *)context_ + 2) + 8) + 4))(*((_DWORD *)context_ + 1));
}

//----- (0805C720) --------------------------------------------------------
int __cdecl scan_for_matches(listbox_item *item, void *info_, int *offset)
{
  int v4; // eax

  if ( !**((_BYTE **)info_ + 4) )
    goto LABEL_2;
  v4 = (*(int (__cdecl **)(listbox_item *, _DWORD, _DWORD))(*(_DWORD *)(*((_DWORD *)info_ + 2) + 8) + 28))(
         item,
         *(_DWORD *)info_,
         *((_DWORD *)info_ + 4));
  if ( !v4 )
  {
    *((_DWORD *)info_ + 1) = item;
LABEL_2:
    *((_BYTE *)item + 24) |= 2u;
    return 0;
  }
  if ( v4 != 1 )
    return 0;
  *((_BYTE *)item + 24) &= ~2u;
  return 0;
}

//----- (0805C790) --------------------------------------------------------
int __cdecl mark_visible(listbox_item *item, void *xxx, int *offset)
{
  *((_BYTE *)item + 24) |= 2u;
  return 0;
}

//----- (0805C7A0) --------------------------------------------------------
widget_handler_status_T __cdecl push_hierbox_search_button(dialog_data *dlg_data, widget_data *button)
{
  terminal *term; // esi
  listbox_data *listbox_widget_data; // eax

  term = dlg_data->win->term;
  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  if ( listbox_widget_data->sel )
  {
    if ( !assert_failed )
    {
      assert_failed = listbox_widget_data->ops->match == 0;
      if ( assert_failed )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 974;
        elinks_internal("assertion box->ops->match failed!");
      }
    }
    input_dialog(
      term,
      0,
      "Search",
      (unsigned __int8 *)&str,
      dlg_data,
      0,
      1024,
      (unsigned __int8 *)&delete,
      0,
      0,
      0,
      search_hierbox_browser,
      0);
  }
  return 0;
}

//----- (0805C880) --------------------------------------------------------
void __cdecl do_clear_browser(void *context_)
{
  traverse_listbox_items_list(
    **(listbox_item ***)(*((_DWORD *)context_ + 2) + 24),
    *((listbox_data **)context_ + 2),
    0,
    0,
    delete_unused,
    context_);
}

//----- (0805C8C0) --------------------------------------------------------
listbox_context *__usercall init_listbox_context@<eax>(
        listbox_data *box@<eax>,
        terminal *term@<edx>,
        listbox_item *item@<ecx>,
        int (*scanner)(listbox_item *, void *, int *))
{
  _DWORD *v5; // eax
  void *v6; // esi
  bool v8; // zf

  v5 = mem_calloc(1u, 0x1Cu);
  v6 = v5;
  if ( v5 )
  {
    v5[1] = item;
    *v5 = term;
    v5[2] = box;
    if ( scanner )
    {
      if ( !assert_failed )
      {
        v8 = box->items != box->items->next;
        assert_failed = box->items == box->items->next;
        if ( !v8 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
          errline = 389;
          elinks_internal("assertion !list_empty(*box->items) failed!");
        }
      }
      traverse_listbox_items_list((listbox_item *)box->items->next, box, 0, 0, scanner, v6);
    }
  }
  return (listbox_context *)v6;
}

//----- (0805C980) --------------------------------------------------------
void __cdecl search_hierbox_browser(void *data, unsigned __int8 *text)
{
  listbox_data *listbox_widget_data; // ebx
  terminal *v3; // edi
  listbox_context *inited; // eax
  listbox_context *v5; // edx
  option_value *opt; // eax
  listbox_context *v7; // edx
  int number; // eax
  unsigned __int8 *v9; // eax
  listbox_context *v10; // [esp+2Ch] [ebp-1Ch]
  listbox_context *v11; // [esp+2Ch] [ebp-1Ch]

  listbox_widget_data = get_listbox_widget_data((widget_data *)((char *)data + 40));
  v3 = *(terminal **)(*(_DWORD *)data + 20);
  inited = init_listbox_context(listbox_widget_data, v3, 0, 0);
  if ( inited )
  {
    inited->widget_data = (widget_data *)text;
    v10 = inited;
    traverse_listbox_items_list(
      (listbox_item *)listbox_widget_data->items->next,
      listbox_widget_data,
      0,
      0,
      scan_for_matches,
      inited);
    v5 = v10;
    if ( !v10->item && *text )
    {
      opt = get_opt_(config_options, "document.browse.search.show_not_found");
      v7 = v10;
      number = opt->number;
      if ( number == 1 )
      {
        beep_terminal(v3);
        v7 = v10;
      }
      else if ( number == 2 )
      {
        v9 = msg_text(v3, "Search string '%s' not found", (const char *)text);
        info_box(v3, MSGBOX_FREE_TEXT, "Search", ALIGN_CENTER, v9);
        v7 = v10;
      }
      v11 = v7;
      traverse_listbox_items_list(
        (listbox_item *)listbox_widget_data->items->next,
        listbox_widget_data,
        0,
        0,
        mark_visible,
        0);
      v5 = v11;
    }
    mem_free(v5);
  }
}

//----- (0805CAD0) --------------------------------------------------------
widget_handler_status_T __cdecl push_hierbox_info_button(dialog_data *dlg_data, widget_data *button)
{
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // esi
  listbox_data *v4; // ebx
  terminal *term; // edi
  int v6; // edx
  memory_list *v7; // eax
  const listbox_ops *ops; // edx
  unsigned __int8 *text; // [esp+38h] [ebp-20h]
  listbox_context *context; // [esp+3Ch] [ebp-1Ch]

  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  sel = listbox_widget_data->sel;
  v4 = listbox_widget_data;
  term = dlg_data->win->term;
  if ( sel )
  {
    if ( !assert_failed )
    {
      ops = listbox_widget_data->ops;
      assert_failed = ops == 0;
      if ( !ops )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 420;
        elinks_internal("assertion box->ops failed!");
      }
    }
    context = init_listbox_context(v4, term, sel, 0);
    if ( context )
    {
      v6 = (int)v4->ops->get_info(sel, term);
      if ( v6 )
      {
        text = (unsigned __int8 *)v6;
        v4->ops->lock(sel);
        v7 = getml(context, 0);
        msg_box(term, v7, MSGBOX_FREE_TEXT, "Info", ALIGN_LEFT, text, context, 1, &okbutton, done_listbox_context, 3);
      }
      else
      {
        mem_free(context);
        if ( sel->type == BI_FOLDER )
          info_box(term, (msgbox_flags)0, "Info", ALIGN_CENTER, "Press space to expand this folder.");
      }
    }
  }
  return 0;
}

//----- (0805CC40) --------------------------------------------------------
void __usercall print_delete_error(
        listbox_item *item@<eax>,
        terminal *term@<edx>,
        const listbox_ops *ops@<ecx>,
        delete_error err)
{
  listbox_ops_messages *v6; // eax
  unsigned __int8 *cant_delete_used_folder; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  listbox_ops_messages *v10; // eax
  listbox_ops_messages *v11; // eax
  const char *v12; // eax
  char *v13; // ebx
  listbox_ops_messages *messages; // eax
  int v15; // [esp+24h] [ebp-34h]
  unsigned __int8 *text; // [esp+28h] [ebp-30h]
  string msg; // [esp+38h] [ebp-20h] BYREF

  if ( err )
  {
    if ( err != DELETE_LOCKED )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 619;
      elinks_internal("Bad delete error code (%d)!", err);
      return;
    }
    if ( item->type == BI_FOLDER )
    {
      messages = ops->messages;
      if ( !messages || (cant_delete_used_folder = messages->cant_delete_used_folder) == 0 )
        cant_delete_used_folder = default_listbox_ops_messages.cant_delete_used_folder;
    }
    else
    {
      v10 = ops->messages;
      if ( !v10 || (cant_delete_used_folder = v10->cant_delete_used_item) == 0 )
        cant_delete_used_folder = default_listbox_ops_messages.cant_delete_used_item;
    }
  }
  else if ( item->type == BI_FOLDER )
  {
    v11 = ops->messages;
    if ( !v11 || (cant_delete_used_folder = v11->cant_delete_folder) == 0 )
      cant_delete_used_folder = default_listbox_ops_messages.cant_delete_folder;
  }
  else
  {
    v6 = ops->messages;
    if ( !v6 || (cant_delete_used_folder = v6->cant_delete_item) == 0 )
      cant_delete_used_folder = default_listbox_ops_messages.cant_delete_item;
  }
  text = ops->get_text(item, term);
  if ( text )
  {
    if ( init_string(&msg) )
    {
      if ( cant_delete_used_folder && *cant_delete_used_folder )
      {
        if ( term )
        {
          terminal_codepage = get_terminal_codepage(term);
          if ( terminal_codepage != current_charset )
          {
            v15 = terminal_codepage;
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            current_charset = v15;
          }
        }
        cant_delete_used_folder = gettext(cant_delete_used_folder);
      }
      add_format_to_string(&msg, cant_delete_used_folder, text);
      mem_free(text);
      if ( item->type == BI_LEAF )
      {
        v12 = (const char *)ops->get_info(item, term);
        v13 = (char *)v12;
        if ( v12 )
        {
          add_format_to_string(&msg, "\n\n%s", v12);
          mem_free(v13);
        }
      }
      info_box(term, MSGBOX_FREE_TEXT, "Delete error", ALIGN_LEFT, msg.source);
    }
    else
    {
      mem_free(text);
    }
  }
}

//----- (0805CE60) --------------------------------------------------------
widget_handler_status_T __cdecl push_hierbox_clear_button(dialog_data *dlg_data, widget_data *button)
{
  listbox_data *listbox_widget_data; // eax
  terminal *term; // esi
  const listbox_ops *ops; // edi
  listbox_context *inited; // eax
  listbox_context *v6; // ebx
  listbox_item *item; // eax
  listbox_ops_messages *messages; // eax
  unsigned __int8 *clear_all_items; // edi
  unsigned __int8 *clear_all_items_title; // edx
  memory_list *v12; // eax
  unsigned __int8 *title; // [esp+4Ch] [ebp-1Ch]
  unsigned __int8 *titlea; // [esp+4Ch] [ebp-1Ch]

  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  ops = listbox_widget_data->ops;
  if ( listbox_widget_data->sel )
  {
    if ( !assert_failed )
    {
      assert_failed = ops == 0;
      if ( !ops )
      {
        title = (unsigned __int8 *)listbox_widget_data;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 857;
        elinks_internal("assertion ops failed!");
        listbox_widget_data = (listbox_data *)title;
      }
    }
    inited = init_listbox_context(listbox_widget_data, term, 0, scan_for_used);
    v6 = inited;
    if ( inited )
    {
      item = inited->item;
      if ( item )
      {
        print_delete_error(item, term, ops, DELETE_LOCKED);
        mem_free(v6);
        return 0;
      }
      messages = ops->messages;
      if ( messages )
      {
        clear_all_items = messages->clear_all_items;
        clear_all_items_title = messages->clear_all_items_title;
        if ( !clear_all_items )
          clear_all_items = default_listbox_ops_messages.clear_all_items;
        if ( clear_all_items_title )
          goto LABEL_13;
      }
      else
      {
        clear_all_items = default_listbox_ops_messages.clear_all_items;
      }
      clear_all_items_title = default_listbox_ops_messages.clear_all_items_title;
LABEL_13:
      titlea = clear_all_items_title;
      v12 = getml(v6, 0);
      msg_box(
        term,
        v12,
        (msgbox_flags)0,
        titlea,
        ALIGN_CENTER,
        clear_all_items,
        v6,
        2,
        "~Yes",
        do_clear_browser,
        1,
        "~No",
        0,
        2);
    }
  }
  return 0;
}

//----- (0805CFE0) --------------------------------------------------------
void __usercall do_delete_item(listbox_item *item@<eax>, listbox_context *info@<edx>, int last@<ecx>)
{
  const listbox_ops *ops; // edi

  ops = info->box->ops;
  if ( !assert_failed )
  {
    assert_failed = item == 0;
    if ( !item )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 652;
      elinks_internal("assertion item failed!");
    }
  }
  if ( ops->can_delete(item) )
  {
    if ( ops->is_used(item) )
      print_delete_error(item, info->term, ops, DELETE_LOCKED);
    else
      ops->delete(item, last);
  }
  else
  {
    print_delete_error(item, info->term, ops, DELETE_IMPOSSIBLE);
  }
}

//----- (0805D0A0) --------------------------------------------------------
int __cdecl delete_unused(listbox_item *item, void *data_, int *offset)
{
  int v3; // edx
  int result; // eax

  v3 = (*(int (__cdecl **)(listbox_item *))(*(_DWORD *)(*((_DWORD *)data_ + 2) + 8) + 8))(item);
  result = 0;
  if ( !v3 )
  {
    do_delete_item(item, (listbox_context *)data_, 0);
    return 1;
  }
  return result;
}

//----- (0805D0E0) --------------------------------------------------------
int __cdecl delete_marked(listbox_item *item, void *data_, int *offset)
{
  int result; // eax

  if ( (*((_BYTE *)item + 24) & 4) == 0 )
    return 0;
  result = (*(int (__cdecl **)(listbox_item *))(*(_DWORD *)(*((_DWORD *)data_ + 2) + 8) + 8))(item);
  if ( result )
    return 0;
  if ( *((_DWORD *)data_ + 1) )
  {
    do_delete_item(item, (listbox_context *)data_, 0);
    return 1;
  }
  else
  {
    *((_DWORD *)data_ + 1) = item;
    LOBYTE(result) = 1;
  }
  return result;
}

//----- (0805D150) --------------------------------------------------------
widget_handler_status_T __usercall query_delete_selected_item@<eax>(void *context_@<eax>)
{
  const listbox_ops *ops; // esi
  listbox_item *sel; // ebx
  int v4; // eax
  _BOOL4 v5; // edx
  int v6; // eax
  unsigned __int8 *v8; // edi
  const char *v9; // eax
  listbox_ops_messages *v10; // edx
  unsigned __int8 *delete_item; // edx
  unsigned __int8 *v12; // eax
  unsigned __int8 *v13; // edx
  listbox_ops_messages *v14; // eax
  unsigned __int8 *delete_item_title; // ebx
  memory_list *v16; // eax
  listbox_ops_messages *messages; // eax
  unsigned __int8 *delete_folder; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // edx
  listbox_ops_messages *v21; // eax
  unsigned __int8 *delete_folder_title; // ebx
  memory_list *v23; // eax
  _BOOL4 v24; // [esp+40h] [ebp-28h]
  unsigned __int8 *v25; // [esp+40h] [ebp-28h]
  unsigned __int8 *v26; // [esp+40h] [ebp-28h]
  char *p; // [esp+44h] [ebp-24h]
  terminal *term; // [esp+48h] [ebp-20h]
  listbox_data *box; // [esp+4Ch] [ebp-1Ch]
  listbox_data *boxa; // [esp+4Ch] [ebp-1Ch]

  term = *(terminal **)context_;
  box = (listbox_data *)*((_DWORD *)context_ + 2);
  ops = box->ops;
  sel = box->sel;
  if ( !assert_failed )
  {
    assert_failed = sel == 0;
    if ( !sel )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
      errline = 728;
      elinks_internal("assertion item failed!");
    }
  }
  v4 = ops->can_delete(sel);
  v5 = v4 != 0;
  if ( !v4 || (v24 = v4 != 0, v6 = ops->is_used(sel), v5 = v24, v6) )
  {
    print_delete_error(sel, term, ops, (delete_error)v5);
    return 0;
  }
  boxa = (listbox_data *)init_listbox_context(box, term, sel, 0);
  if ( !boxa )
    return 0;
  boxa->top = (listbox_item *)*((_DWORD *)context_ + 4);
  v8 = ops->get_text(sel, term);
  if ( !v8 )
  {
    mem_free(boxa);
    return 0;
  }
  if ( sel->type == BI_FOLDER )
  {
    ops->lock(sel);
    messages = ops->messages;
    if ( messages && (delete_folder = messages->delete_folder) != 0 )
      v19 = msg_text(term, delete_folder, v8);
    else
      v19 = msg_text(term, default_listbox_ops_messages.delete_folder, v8);
    v20 = v19;
    v21 = ops->messages;
    if ( !v21 || (delete_folder_title = v21->delete_folder_title) == 0 )
      delete_folder_title = default_listbox_ops_messages.delete_folder_title;
    v26 = v20;
    v23 = getml(boxa, 0);
    msg_box(
      term,
      v23,
      MSGBOX_FREE_TEXT,
      delete_folder_title,
      ALIGN_CENTER,
      v26,
      boxa,
      2,
      "~Yes",
      push_ok_delete_button,
      1,
      "~No",
      done_listbox_context,
      2);
  }
  else
  {
    p = (char *)ops->get_info(sel, term);
    ops->lock(sel);
    v9 = &delete;
    v10 = ops->messages;
    if ( p )
      v9 = p;
    if ( v10 && (delete_item = v10->delete_item) != 0 )
      v12 = msg_text(term, delete_item, v8, v9);
    else
      v12 = msg_text(term, default_listbox_ops_messages.delete_item, v8, v9);
    v13 = v12;
    v14 = ops->messages;
    if ( !v14 || (delete_item_title = v14->delete_item_title) == 0 )
      delete_item_title = default_listbox_ops_messages.delete_item_title;
    v25 = v13;
    v16 = getml(boxa, 0);
    msg_box(
      term,
      v16,
      MSGBOX_FREE_TEXT,
      delete_item_title,
      ALIGN_LEFT,
      v25,
      boxa,
      2,
      "~Yes",
      push_ok_delete_button,
      1,
      "~No",
      done_listbox_context,
      2);
    if ( p )
      mem_free(p);
  }
  mem_free(v8);
  return 0;
}

//----- (0805D460) --------------------------------------------------------
widget_handler_status_T __cdecl push_hierbox_delete_button(dialog_data *dlg_data, widget_data *button)
{
  terminal *term; // edi
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // ecx
  const listbox_ops *ops; // esi
  listbox_context *inited; // eax
  listbox_context *v7; // edx
  listbox_item *item; // ecx
  listbox_ops_messages *messages; // eax
  unsigned __int8 *delete_marked_items; // ebx
  unsigned __int8 *delete_marked_items_title; // esi
  memory_list *v13; // eax
  listbox_context *v14; // [esp+0h] [ebp-68h]
  listbox_item *v15; // [esp+48h] [ebp-20h]
  void *p; // [esp+4Ch] [ebp-1Ch]
  listbox_context *pa; // [esp+4Ch] [ebp-1Ch]
  listbox_data *pb; // [esp+4Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  sel = listbox_widget_data->sel;
  ops = listbox_widget_data->ops;
  if ( sel )
  {
    if ( !assert_failed )
    {
      if ( ops && ops->can_delete && ops->delete )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 794;
        pb = listbox_widget_data;
        v15 = sel;
        elinks_internal("assertion ops && ops->can_delete && ops->delete failed!");
        sel = v15;
        listbox_widget_data = pb;
      }
    }
    inited = init_listbox_context(listbox_widget_data, term, sel, scan_for_marks);
    v7 = inited;
    if ( inited )
    {
      item = inited->item;
      inited->widget_data = dlg_data->widgets_data;
      if ( item )
      {
        v14 = inited;
        p = (void *)query_delete_selected_item(inited);
        mem_free(v14);
        return (widget_handler_status_T)p;
      }
      messages = ops->messages;
      if ( messages )
      {
        delete_marked_items = messages->delete_marked_items;
        delete_marked_items_title = messages->delete_marked_items_title;
        if ( !delete_marked_items )
          delete_marked_items = default_listbox_ops_messages.delete_marked_items;
        if ( delete_marked_items_title )
          goto LABEL_14;
      }
      else
      {
        delete_marked_items = default_listbox_ops_messages.delete_marked_items;
      }
      delete_marked_items_title = default_listbox_ops_messages.delete_marked_items_title;
LABEL_14:
      pa = v7;
      v13 = getml(v7, 0);
      msg_box(
        term,
        v13,
        (msgbox_flags)0,
        delete_marked_items_title,
        ALIGN_CENTER,
        delete_marked_items,
        pa,
        2,
        "~Yes",
        push_ok_delete_button,
        1,
        "~No",
        dont_delete_marked_items,
        2);
      return 0;
    }
  }
  return 0;
}

//----- (0805D610) --------------------------------------------------------
void __cdecl dont_delete_marked_items(void *const context_)
{
  query_delete_selected_item(context_);
}

//----- (0805D620) --------------------------------------------------------
void __cdecl push_ok_delete_button(void *context_)
{
  int v1; // eax
  listbox_item *v2; // esi
  listbox_item *v3; // edi

  if ( *((_DWORD *)context_ + 1) )
  {
    (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(*((_DWORD *)context_ + 2) + 8) + 4))(*((_DWORD *)context_ + 1));
    v1 = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)(*((_DWORD *)context_ + 2) + 8) + 24))(*((_DWORD *)context_ + 1));
    if ( v1 )
      goto LABEL_3;
LABEL_8:
    do_delete_item(*((listbox_item **)context_ + 1), (listbox_context *)context_, 1);
    return;
  }
  traverse_listbox_items_list(
    **(listbox_item ***)(*((_DWORD *)context_ + 2) + 24),
    *((listbox_data **)context_ + 2),
    0,
    0,
    delete_marked,
    context_);
  if ( !*((_DWORD *)context_ + 1) )
    return;
  v1 = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)(*((_DWORD *)context_ + 2) + 8) + 24))(*((_DWORD *)context_ + 1));
  if ( !v1 )
    goto LABEL_8;
LABEL_3:
  v2 = (listbox_item *)*((_DWORD *)context_ + 1);
  v3 = *(listbox_item **)(v1 + 12);
  do_delete_item(v2, (listbox_context *)context_, 1);
  if ( v2 == v3 )
    listbox_sel_move(*((widget_data **)context_ + 4), -1);
}

//----- (0805D710) --------------------------------------------------------
void __usercall recursively_goto_listbox(session *ses@<eax>, listbox_item *item@<edx>, listbox_data *box@<ecx>)
{
  listbox_item_type type; // eax
  uri *v6; // eax
  uri *v7; // ebx
  listbox_item *next; // ebx
  list_head_elinks *i; // [esp+1Ch] [ebp-1Ch]

  type = item->type;
  if ( type == BI_FOLDER )
  {
    next = (listbox_item *)item->child.next;
    for ( i = &item->child; next != (listbox_item *)i; next = next->next )
      recursively_goto_listbox(ses, next, box);
  }
  else if ( type == BI_LEAF )
  {
    v6 = box->ops->get_uri(item);
    v7 = v6;
    if ( v6 )
    {
      open_uri_in_new_tab(ses, v6, 1, 0);
      done_uri(v7);
    }
  }
}

//----- (0805D7A0) --------------------------------------------------------
widget_handler_status_T __cdecl push_hierbox_goto_button(dialog_data *dlg_data, widget_data *button)
{
  dialog_data *v2; // esi
  listbox_data *listbox_widget_data; // edi
  listbox_context *inited; // eax
  listbox_item_type type; // eax
  uri *v6; // eax
  uri *v7; // ebx
  listbox_item *next; // ebx
  session *ses; // [esp+24h] [ebp-24h]
  listbox_context *context; // [esp+28h] [ebp-20h]
  listbox_item *item; // [esp+2Ch] [ebp-1Ch]
  listbox_item *itema; // [esp+2Ch] [ebp-1Ch]

  v2 = dlg_data;
  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  item = listbox_widget_data->sel;
  ses = (session *)dlg_data->dlg->udata;
  if ( !item )
    return 0;
  inited = init_listbox_context(listbox_widget_data, dlg_data->win->term, item, scan_for_marks);
  context = inited;
  if ( !inited )
    return 0;
  if ( !inited->item )
  {
    inited->dlg_data = dlg_data;
    traverse_listbox_items_list((listbox_item *)inited->box->items->next, inited->box, 0, 0, goto_marked, inited);
LABEL_8:
    mem_free(context);
    delete_window(v2->win);
    return 0;
  }
  type = item->type;
  if ( type == BI_FOLDER )
  {
    next = (listbox_item *)item->child.next;
    itema = (listbox_item *)&item->child;
    if ( next != itema )
    {
      do
      {
        recursively_goto_listbox(ses, next, listbox_widget_data);
        next = next->next;
      }
      while ( next != itema );
      v2 = dlg_data;
    }
    goto LABEL_8;
  }
  if ( type == BI_LEAF )
  {
    v6 = listbox_widget_data->ops->get_uri(item);
    v7 = v6;
    if ( v6 )
    {
      goto_uri(ses, v6);
      done_uri(v7);
    }
    goto LABEL_8;
  }
  mem_free(context);
  return 0;
}

//----- (0805D8E0) --------------------------------------------------------
int __cdecl goto_marked(listbox_item *item, void *data_, int *offset)
{
  if ( (*((_BYTE *)item + 24) & 4) != 0 )
    recursively_goto_listbox(
      *(session **)(*(_DWORD *)(*((_DWORD *)data_ + 3) + 4) + 4),
      item,
      *((listbox_data **)data_ + 2));
  return 0;
}

//----- (0805D910) --------------------------------------------------------
widget_handler_status_T __cdecl hierbox_dialog_event_handler(dialog_data *dlg_data)
{
  term_event *term_event; // edx
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // ecx
  char *v5; // eax
  char *i; // esi
  widget_handler_T *kbd; // eax
  int v9; // eax
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // edi
  unsigned int v12; // eax
  listbox_data *v13; // eax
  _DWORD *v14; // edx
  dialog_data **v15; // eax
  dialog_data **v16; // edx
  void (*v17)(void); // eax
  listbox_item *v18; // eax
  term_event *v19; // [esp+4h] [ebp-34h]
  term_event *v20; // [esp+18h] [ebp-20h]
  term_event *v21; // [esp+18h] [ebp-20h]
  term_event *v22; // [esp+18h] [ebp-20h]
  void *udata2; // [esp+1Ch] [ebp-1Ch]

  term_event = dlg_data->term_event;
  if ( term_event->ev == EVENT_KBD )
  {
    udata2 = dlg_data->dlg->udata2;
    kbd = dlg_data->widgets_data[0].widget->ops->kbd;
    if ( kbd )
    {
      v20 = dlg_data->term_event;
      v9 = kbd(dlg_data, dlg_data->widgets_data);
      term_event = v20;
      if ( !v9 )
        return 0;
    }
    v21 = term_event;
    listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
    sel = listbox_widget_data->sel;
    v19 = v21;
    v22 = (term_event *)listbox_widget_data;
    v12 = kbd_action(KEYMAP_MENU, v19, 0);
    if ( v12 == 17 )
    {
      if ( *(_DWORD *)(v22->info.mouse.y + 28) )
      {
        push_hierbox_search_button(dlg_data, 0);
        return 0;
      }
    }
    else if ( v12 > 0x11 )
    {
      if ( v12 == 18 )
      {
        if ( !sel )
          return 0;
        if ( sel->type == BI_FOLDER )
        {
          *((_BYTE *)sel + 24) = (*((_BYTE *)sel + 24) ^ 1) & 1 | *((_BYTE *)sel + 24) & 0xFE;
          goto LABEL_33;
        }
      }
      else if ( v12 == 19 )
      {
        if ( sel )
        {
          if ( sel->child.next == &sel->child || (*((_BYTE *)sel + 24) & 1) == 0 )
          {
            v18 = (listbox_item *)(*(int (__cdecl **)(listbox_item *))(v22->info.mouse.y + 24))(sel);
            if ( v18 )
              listbox_sel(dlg_data->widgets_data, v18);
          }
          else if ( sel->type == BI_FOLDER )
          {
            recursively_set_expanded(sel, 0);
          }
          goto LABEL_33;
        }
        return 0;
      }
    }
    else if ( v12 == 7 )
    {
      if ( sel && sel->type == BI_FOLDER )
      {
        recursively_set_expanded(sel, 1);
LABEL_33:
        v17 = (void (*)(void))*((_DWORD *)udata2 + 1);
        if ( v17 )
          v17();
        display_widget(dlg_data, dlg_data->widgets_data);
        return 0;
      }
      return 0;
    }
    return 1;
  }
  if ( term_event->ev == EVENT_INIT )
  {
    v2 = dlg_data->dlg->udata2;
    v3 = mem_alloc(0xCu);
    if ( v3 )
    {
      v3[2] = dlg_data;
      v4 = v2[6];
      v3[1] = v2 + 6;
      *v3 = v4;
      v2[6] = v3;
      *(_DWORD *)(*v3 + 4) = v3;
    }
    v5 = (char *)v2[10];
    for ( i = (char *)(v2 + 10); v5 != i; v5 = *(char **)v5 )
      v5[24] |= 2u;
    return 1;
  }
  if ( term_event->ev != EVENT_ABORT )
    return 1;
  v13 = get_listbox_widget_data(dlg_data->widgets_data);
  v14 = dlg_data->dlg->udata2;
  if ( (v14[24] & 1) == 0 )
  {
    v14[17] = v13->next;
    v14[18] = v13->prev;
    v14[19] = v13->ops;
    v14[20] = v13->sel;
    v14[21] = v13->top;
    v14[22] = v13->sel_offset;
    v14[23] = v13->items;
  }
  v13->next->prev = v13->prev;
  v13->prev->next = v13->next;
  v15 = (dialog_data **)v14[6];
  v16 = (dialog_data **)(v14 + 6);
  if ( v15 == v16 )
    return 1;
  while ( dlg_data != v15[2] )
  {
    v15 = (dialog_data **)*v15;
    if ( v15 == v16 )
      return 1;
  }
  (*v15)->dlg = (dialog *)v15[1];
  v15[1]->win = (window *)*v15;
  mem_free(v15);
  return 1;
}

//----- (0805DBA0) --------------------------------------------------------
void __cdecl update_hierbox_browser(hierbox_browser *browser)
{
  window ***i; // ebx

  for ( i = (window ***)browser->dialogs.next; i != (window ***)&browser->dialogs; i = (window ***)*i )
    redraw_from_window((*i[2])->next);
}

//----- (0805DBE0) --------------------------------------------------------
listbox_item *__cdecl add_listbox_item(
        hierbox_browser *browser,
        listbox_item *root,
        listbox_item_type type,
        void *data,
        int add_position)
{
  listbox_item *p_root; // ebx
  listbox_item *result; // eax
  listbox_item *next; // ecx
  listbox_item *v8; // [esp+1Ch] [ebp-Ch]

  p_root = root;
  if ( !root )
  {
    if ( !assert_failed )
    {
      assert_failed = browser == 0;
      if ( !browser )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 46;
        elinks_internal("assertion browser != NULL failed: Nowhere to add new list box item");
      }
    }
    p_root = &browser->root;
  }
  result = (listbox_item *)mem_calloc(1u, 0x20u);
  if ( result )
  {
    *((_BYTE *)result + 24) |= 2u;
    result->child.prev = &result->child;
    result->child.next = &result->child;
    result->udata = data;
    result->type = type;
    result->depth = p_root->depth + 1;
    if ( add_position < 0 )
    {
      result->next = *(listbox_item **)p_root->child.prev;
      result->prev = (listbox_item *)p_root->child.prev;
      *(_DWORD *)p_root->child.prev = result;
    }
    else
    {
      next = (listbox_item *)p_root->child.next;
      result->prev = (listbox_item *)&p_root->child;
      result->next = next;
      p_root->child.next = result;
    }
    result->next->prev = result;
    if ( browser )
    {
      v8 = result;
      update_hierbox_browser(browser);
      return v8;
    }
  }
  return result;
}

//----- (0805DCE0) --------------------------------------------------------
void __cdecl done_listbox_item(hierbox_browser *browser, listbox_item *item)
{
  hierbox_browser *v2; // edx
  listbox_item *next; // eax
  listbox_data *v4; // ebx
  list_head_elinks *p_boxes; // edi
  listbox_item *v6; // eax
  listbox_item *v7; // eax
  hierbox_browser *v8; // [esp+2Ch] [ebp-1Ch]
  hierbox_browser *v9; // [esp+2Ch] [ebp-1Ch]

  v2 = browser;
  if ( assert_failed )
    goto LABEL_13;
  if ( item && item->child.next == &item->child )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
  errline = 92;
  elinks_internal("assertion item && list_empty(item->child) failed!");
  v2 = browser;
  if ( assert_failed )
  {
LABEL_13:
    assert_failed = 0;
    return;
  }
LABEL_5:
  next = item->next;
  if ( item->next )
  {
    v4 = (listbox_data *)v2->boxes.next;
    p_boxes = &v2->boxes;
    if ( v4 != (listbox_data *)&v2->boxes )
    {
      do
      {
        if ( v4->sel == item )
        {
          v9 = v2;
          v7 = traverse_listbox_items_list(item, v4, 1, 1, 0, 0);
          v2 = v9;
          if ( item == v7 )
          {
            v7 = traverse_listbox_items_list(item, v4, -1, 1, 0, 0);
            v2 = v9;
            if ( item == v7 )
              v7 = 0;
          }
          v4->sel = v7;
        }
        if ( v4->top == item )
        {
          v8 = v2;
          v6 = traverse_listbox_items_list(item, v4, 1, 1, 0, 0);
          v2 = v8;
          if ( item == v6 )
          {
            v6 = traverse_listbox_items_list(item, v4, -1, 1, 0, 0);
            v2 = v8;
            if ( item == v6 )
              v6 = 0;
          }
          v4->top = v6;
        }
        v4 = v4->next;
      }
      while ( v4 != (listbox_data *)p_boxes );
      next = item->next;
    }
    next->prev = item->prev;
    item->prev->next = item->next;
    update_hierbox_browser(v2);
  }
  mem_free(item);
}

//----- (0805DEC0) --------------------------------------------------------
dialog_data *__cdecl hierbox_browser_0(hierbox_browser *browser, session *ses)
{
  size_t buttons_size; // ebx
  int v3; // ebx
  dialog_data *result; // eax
  unsigned __int8 *title; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  char *v8; // eax
  size_t v9; // ebx
  size_t v10; // eax
  const hierbox_browser_button *v11; // eax
  unsigned __int8 *label; // esi
  int v13; // eax
  unsigned __int8 *v14; // eax
  int v15; // eax
  int v16; // esi
  unsigned __int8 *v17; // eax
  int v18; // eax
  size_t v19; // ebx
  bool v20; // zf
  unsigned __int8 *v21; // [esp+4h] [ebp-54h]
  memory_list *v22; // [esp+8h] [ebp-50h]
  int v23; // [esp+2Ch] [ebp-2Ch]
  int v24; // [esp+2Ch] [ebp-2Ch]
  terminal *term; // [esp+30h] [ebp-28h]
  widget_handler_T *handler; // [esp+34h] [ebp-24h]
  int number; // [esp+38h] [ebp-20h]
  dialog *dlg; // [esp+3Ch] [ebp-1Ch]

  term = ses->tab->term;
  buttons_size = browser->buttons_size;
  number = get_opt_(cmdline_options, "anonymous")->number;
  if ( !assert_failed )
    assert_failed = 0;
  v3 = 16 * (3 * buttons_size + 3);
  dlg = (dialog *)mem_calloc(1u, v3 + 112);
  result = 0;
  if ( dlg )
  {
    title = browser->title;
    if ( browser->title && *title )
    {
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        if ( terminal_codepage != current_charset )
        {
          v23 = terminal_codepage;
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v23;
        }
      }
      title = gettext(title);
    }
    *(_BYTE *)&dlg->layout |= 3u;
    dlg->title = title;
    dlg->layouter = generic_dialog_layouter;
    dlg->handle_event = hierbox_dialog_event_handler;
    dlg->udata2 = browser;
    dlg->udata = ses;
    v8 = (char *)&dlg[1] + v3;
    v9 = 0;
    add_dlg_listbox(dlg, v8);
    v10 = 0;
    if ( browser->buttons_size )
    {
      do
      {
        while ( 1 )
        {
          v11 = &browser->buttons[v10];
          if ( !number || (*((_BYTE *)v11 + 8) & 1) != 0 )
            break;
          ++number;
          v10 = ++v9;
          if ( browser->buttons_size <= v9 )
            goto LABEL_22;
        }
        handler = v11->handler;
        label = v11->label;
        if ( v11->label && *label )
        {
          if ( term )
          {
            v13 = get_terminal_codepage(term);
            if ( v13 != current_charset )
            {
              v24 = v13;
              v14 = get_cp_mime_name(v13);
              bind_textdomain_codeset("elinks", v14);
              current_charset = v24;
            }
          }
          label = gettext(label);
        }
        ++v9;
        add_dlg_button_do(dlg, label, 1, handler, 0, 0, 0);
        v10 = v9;
      }
      while ( browser->buttons_size > v9 );
    }
LABEL_22:
    if ( term )
    {
      v15 = get_terminal_codepage(term);
      v16 = v15;
      if ( v15 != current_charset )
      {
        v17 = get_cp_mime_name(v15);
        bind_textdomain_codeset("elinks", v17);
        current_charset = v16;
      }
    }
    v21 = gettext(&msgid);
    add_dlg_button_do(dlg, v21, 2, cancel_dialog, 0, 0, 0);
    if ( !assert_failed )
    {
      v18 = 0;
      if ( number )
        v18 = number - 1;
      v19 = v9 + 2 - v18;
      v20 = v19 == dlg->number_of_widgets;
      assert_failed = v19 != dlg->number_of_widgets;
      if ( !v20 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hierbox.c";
        errline = 336;
        elinks_internal("assertion button + 2 - (anonymous ? anonymous - 1 : 0) == (dlg)->number_of_widgets failed!");
      }
    }
    v22 = getml(dlg, 0);
    return do_dialog(term, dlg, v22);
  }
  return result;
}

//----- (0805E1B0) --------------------------------------------------------
void __cdecl clear_hotkeys_cache(menu *menu)
{
  menu_item *i; // eax
  bool v2; // zf

  for ( i = menu->items; i->text; ++i )
  {
    v2 = menu->hotkeys == 0;
    i->hotkey_pos = 0;
    i->hotkey_state = v2;
  }
}

//----- (0805E1E0) --------------------------------------------------------
void __cdecl init_hotkeys(terminal *term, menu *menu)
{
  menu_item *items; // ebx
  unsigned __int8 *text; // esi
  char *v4; // eax
  int v5; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  int v8; // [esp+1Ch] [ebp-1Ch]

  items = menu->items;
  text = items->text;
  if ( items->text )
  {
    while ( menu->hotkeys )
    {
      if ( items->hotkey_state == HKS_CACHED || items->hotkey_pos || !*text )
        goto LABEL_4;
      if ( (items->flags & 0x40) == 0 )
      {
        if ( term )
        {
          terminal_codepage = get_terminal_codepage(term);
          if ( terminal_codepage != current_charset )
          {
            v8 = terminal_codepage;
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            current_charset = v8;
          }
        }
        text = gettext(text);
        if ( !*text )
          goto LABEL_4;
      }
      v4 = strchr((const char *)text, 126);
      if ( !v4 )
      {
        items->hotkey_pos = 0;
        goto LABEL_4;
      }
      v5 = v4 - (char *)text + 1;
      items->hotkey_pos = v5;
      if ( v5 )
      {
        items->hotkey_state = HKS_CACHED;
        ++items;
        text = items->text;
        if ( !items->text )
          return;
      }
      else
      {
LABEL_4:
        ++items;
        text = items->text;
        if ( !items->text )
          return;
      }
    }
    items->hotkey_pos = 0;
    items->hotkey_state = HKS_IGNORE;
    goto LABEL_4;
  }
}

//----- (0805E2D0) --------------------------------------------------------
void __cdecl refresh_hotkeys(terminal *term, menu *menu)
{
  menu_item *i; // eax
  int hotkeys; // ecx

  if ( menu->lang != current_language )
  {
    for ( i = menu->items; i->text; ++i )
    {
      hotkeys = menu->hotkeys;
      i->hotkey_pos = 0;
      i->hotkey_state = hotkeys == 0;
    }
    init_hotkeys(term, menu);
    menu->lang = current_language;
  }
}

//----- (0805E330) --------------------------------------------------------
int __usercall check_hotkeys_common@<eax>(
        menu *menu@<eax>,
        term_event_char_T hotkey@<edx>,
        terminal *term@<ecx>,
        int check_mode)
{
  int size; // ecx
  int selected; // eax
  menu *v7; // edx
  int v8; // esi
  int i; // ebx
  menu_item *v10; // ebx
  unsigned __int8 *v11; // edi
  int hotkey_pos; // eax
  unsigned __int8 *v13; // edi
  const unsigned __int8 *v14; // eax
  unicode_val_T v15; // eax
  unicode_val_T v16; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v20; // eax
  int v21; // [esp+18h] [ebp-40h]
  menu *v22; // [esp+1Ch] [ebp-3Ch]
  menu *v23; // [esp+1Ch] [ebp-3Ch]
  menu *v24; // [esp+1Ch] [ebp-3Ch]
  menu *v25; // [esp+1Ch] [ebp-3Ch]
  unicode_val_T key; // [esp+20h] [ebp-38h]
  int codepage; // [esp+24h] [ebp-34h]
  int v29; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *text; // [esp+3Ch] [ebp-1Ch] BYREF

  key = unicode_fold_label_case(hotkey);
  codepage = get_terminal_codepage(term);
  size = menu->size;
  selected = menu->selected;
  if ( size <= 0 )
    return 0;
  v29 = selected % size;
  if ( selected % size < 0 )
    v29 = size + selected % size;
  v7 = menu;
  v8 = v29 + 1;
  if ( v29 + 1 == size )
    goto LABEL_18;
LABEL_5:
  for ( i = v8; ; i = 0 )
  {
    v10 = &v7->items[i];
    v11 = v10->text;
    if ( !v10->text || !*v11 )
      goto LABEL_16;
    text = v10->text;
    if ( (v10->flags & 0x40) != 0 )
      goto LABEL_9;
    if ( !*v11 )
      break;
    if ( term )
    {
      v24 = v7;
      terminal_codepage = get_terminal_codepage(term);
      v7 = v24;
      if ( terminal_codepage != current_charset )
      {
        v21 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        v7 = v24;
        current_charset = v21;
      }
    }
    v25 = v7;
    v20 = gettext(v11);
    v7 = v25;
    v11 = v20;
    text = v20;
    if ( v20 )
      goto LABEL_9;
LABEL_16:
    if ( v29 == v8 )
      return 0;
    if ( ++v8 != v7->size )
      goto LABEL_5;
LABEL_18:
    v8 = 0;
  }
  text = v11;
LABEL_9:
  if ( !*v11 )
    goto LABEL_16;
  if ( check_mode )
  {
    v13 = text;
  }
  else
  {
    hotkey_pos = v10->hotkey_pos;
    if ( !hotkey_pos )
      goto LABEL_16;
    v13 = &v11[hotkey_pos];
    text = v13;
  }
  v22 = v7;
  v14 = (const unsigned __int8 *)__rawmemchr(v13, 0);
  v15 = cp_to_unicode(codepage, &text, v14);
  v7 = v22;
  if ( assert_failed
    || (assert_failed = v15 == -3) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/hotkey.c",
        errline = 184,
        elinks_internal("assertion items_hotkey != UCS_NO_CHAR failed!"),
        v15 = -3,
        v7 = v22,
        assert_failed) )
  {
    assert_failed = 0;
    goto LABEL_16;
  }
  v23 = v7;
  v16 = unicode_fold_label_case(v15);
  v7 = v23;
  if ( key != v16 )
    goto LABEL_16;
  v23->selected = v8;
  return 1;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (0805E550) --------------------------------------------------------
int __cdecl check_not_so_hot_keys(menu *menu, term_event_char_T key, terminal *term)
{
  return check_hotkeys_common(menu, key, term, 1);
}

//----- (0805E570) --------------------------------------------------------
int __cdecl check_hotkeys(menu *menu, term_event_char_T key, terminal *term)
{
  return check_hotkeys_common(menu, key, term, 0);
}

//----- (0805E590) --------------------------------------------------------
void __cdecl add_dlg_field_do(
        dialog *dlg,
        widget_type type,
        unsigned __int8 *label,
        int min,
        int max,
        widget_handler_T *handler,
        int datalen,
        void *data,
        input_history *history,
        inpfield_flags flags)
{
  int number_of_widgets; // edx
  int v11; // ecx
  unsigned __int8 **v12; // edx
  unsigned __int8 **v13; // eax

  number_of_widgets = dlg->number_of_widgets;
  v11 = number_of_widgets + 1;
  dlg->number_of_widgets = number_of_widgets + 1;
  v12 = &dlg->title + 12 * number_of_widgets;
  v12[20] = (unsigned __int8 *)type;
  v13 = &dlg->title + 12 * v11;
  v12[10] = label;
  v12[11] = (unsigned __int8 *)handler;
  v13[1] = (unsigned __int8 *)datalen;
  v12[12] = (unsigned __int8 *)data;
  v13[4] = (unsigned __int8 *)history;
  v13[5] = (unsigned __int8 *)flags;
  v13[2] = (unsigned __int8 *)min;
  v13[3] = (unsigned __int8 *)max;
}

//----- (0805E5F0) --------------------------------------------------------
widget_handler_status_T __usercall display_field_do@<eax>(
        dialog_data *dlg_data@<eax>,
        widget_data *widget_data@<edx>,
        int hide@<ecx>)
{
  terminal *term; // edi
  int cpos; // edx
  int vpos; // ecx
  int v8; // eax
  color_pair *bfu_color; // eax
  color_pair *v10; // ecx
  unsigned __int8 *v11; // edx
  size_t v12; // eax
  color_pair *v13; // ecx
  unsigned __int8 *v14; // edx
  int width; // eax
  int v16; // eax
  int v18; // eax
  int height; // edx
  int v20; // eax
  int v21; // edx
  char *v22; // esi
  int v23; // eax
  color_pair *v24; // [esp+24h] [ebp-44h]
  color_pair *v25; // [esp+24h] [ebp-44h]
  color_pair *v26; // [esp+24h] [ebp-44h]
  color_pair *v27; // [esp+24h] [ebp-44h]
  unsigned __int8 *stringa; // [esp+28h] [ebp-40h]
  unsigned __int8 *string; // [esp+28h] [ebp-40h]
  unsigned __int8 *stringb; // [esp+28h] [ebp-40h]
  unsigned __int8 *stringc; // [esp+28h] [ebp-40h]
  unsigned __int8 *stringd; // [esp+28h] [ebp-40h]
  bool v33; // [esp+2Fh] [ebp-39h]
  int len; // [esp+30h] [ebp-38h]
  int left; // [esp+34h] [ebp-34h]
  int selected_widget_id; // [esp+38h] [ebp-30h]
  int len_0a; // [esp+3Ch] [ebp-2Ch]
  int len_0b; // [esp+3Ch] [ebp-2Ch]
  box box; // [esp+40h] [ebp-28h] BYREF

  term = dlg_data->win->term;
  selected_widget_id = dlg_data->selected_widget_id;
  if ( (*((_BYTE *)term + 56) & 2) != 0 )
  {
    string = widget_data->cdata;
    len = utf8_ptr2cells(string, &string[widget_data->info.field.cpos]);
    v18 = 0;
    if ( len - widget_data->box.width + 1 > 0 )
      v18 = len - widget_data->box.width + 1;
    left = v18;
    widget_data->info.field.vpos = utf8_cells2bytes(string, v18, 0);
  }
  else
  {
    cpos = widget_data->info.field.cpos;
    vpos = widget_data->info.field.vpos;
    v8 = cpos + 1 - widget_data->box.width;
    if ( v8 <= vpos )
    {
      if ( cpos >= vpos )
        cpos = widget_data->info.field.vpos;
      else
        widget_data->info.field.vpos = cpos;
    }
    else
    {
      widget_data->info.field.vpos = v8;
      cpos = v8;
    }
    left = 0;
    len = 0;
    if ( cpos < 0 )
    {
      widget_data->info.field.vpos = 0;
      left = 0;
      len = 0;
    }
  }
  bfu_color = get_bfu_color(term, "dialog.field");
  if ( bfu_color )
    draw_box(term, &widget_data->box, 0x20u, (screen_char_attr)0, bfu_color);
  v10 = get_bfu_color(term, "dialog.field-text");
  if ( !v10 )
    goto LABEL_17;
  v11 = &widget_data->cdata[widget_data->info.field.vpos];
  v33 = hide == 0;
  if ( hide )
  {
    if ( (*((_BYTE *)term + 56) & 2) != 0 )
    {
      stringd = &widget_data->cdata[widget_data->info.field.vpos];
      v27 = v10;
      v23 = utf8_ptr2chars(v11, 0);
      v14 = stringd;
      v13 = v27;
      len_0a = v23;
      goto LABEL_12;
    }
  }
  else if ( (*((_BYTE *)term + 56) & 2) != 0 )
  {
    stringb = &widget_data->cdata[widget_data->info.field.vpos];
    v25 = v10;
    v20 = utf8_ptr2cells(v11, 0);
    v14 = stringb;
    v13 = v25;
    len_0b = v20;
    width = widget_data->box.width;
    if ( len_0b <= width )
      width = len_0b;
    if ( (*((_BYTE *)term + 56) & 2) == 0 )
      goto LABEL_16;
    goto LABEL_29;
  }
  stringa = &widget_data->cdata[widget_data->info.field.vpos];
  v24 = v10;
  v12 = strlen((const char *)v11);
  v13 = v24;
  v14 = stringa;
  len_0a = v12;
LABEL_12:
  width = widget_data->box.width;
  if ( len_0a <= width )
    width = len_0a;
  if ( v33 )
  {
    if ( (*((_BYTE *)term + 56) & 2) == 0 )
    {
LABEL_16:
      draw_text(term, widget_data->box.x, widget_data->box.y, v14, width, (screen_char_attr)0, v13);
      goto LABEL_17;
    }
LABEL_29:
    stringc = v14;
    v26 = v13;
    width = utf8_cells2bytes(v14, width, 0);
    v13 = v26;
    v14 = stringc;
    goto LABEL_16;
  }
  box.x = widget_data->box.x;
  box.y = widget_data->box.y;
  height = widget_data->box.height;
  box.width = width;
  box.height = height;
  draw_box(term, &box, 0x2Au, (screen_char_attr)0, v13);
LABEL_17:
  v16 = selected_widget_id;
  if ( &dlg_data->widgets_data[selected_widget_id] != widget_data )
    return 0;
  if ( (*((_BYTE *)term + 56) & 2) != 0 )
    v21 = dlg_data->widgets_data[v16].box.x + len - left;
  else
    v21 = dlg_data->widgets_data[v16].box.x
        + dlg_data->widgets_data[selected_widget_id].info.field.cpos
        - dlg_data->widgets_data[selected_widget_id].info.field.vpos;
  v22 = (char *)dlg_data + 48 * selected_widget_id;
  set_cursor(term, v21, *((_DWORD *)v22 + 13), 0);
  dlg_data->win->x = *((_DWORD *)v22 + 12);
  dlg_data->win->y = *((_DWORD *)v22 + 13);
  return 0;
}

//----- (0805E900) --------------------------------------------------------
widget_handler_status_T __cdecl display_field_pass(dialog_data *dlg_data, widget_data *widget_data)
{
  return display_field_do(dlg_data, widget_data, 1);
}

//----- (0805E920) --------------------------------------------------------
widget_handler_status_T __cdecl display_field(dialog_data *dlg_data, widget_data *widget_data)
{
  return display_field_do(dlg_data, widget_data, 0);
}

//----- (0805E940) --------------------------------------------------------
widget_handler_status_T __cdecl clear_field(dialog_data *dlg_data, widget_data *widget_data)
{
  widget *widget; // edx
  size_t datalen; // edx

  widget = widget_data->widget;
  widget_data->info.field.cpos = 0;
  datalen = widget->datalen;
  if ( datalen )
    memset(widget_data->cdata, 0, datalen);
  return 0;
}

//----- (0805E980) --------------------------------------------------------
widget_handler_status_T __cdecl kbd_field(dialog_data *dlg_data, widget_data *widget_data)
{
  dialog_data *v2; // esi
  widget_data *v3; // ebx
  action_id_T v4; // eax
  action_id_T v5; // edi
  action *action; // eax
  int terminal_codepage; // eax
  size_t v8; // edi
  int v9; // eax
  widget_data *widget; // eax
  unsigned __int8 *v12; // edi
  size_t v13; // eax
  unsigned __int8 *cpos; // edi
  size_t v15; // eax
  unsigned __int8 *v16; // edi
  signed int v17; // eax
  int v18; // ecx
  const unsigned __int8 *v19; // edx
  unsigned __int8 *v20; // edi
  widget_data *cur_hist; // eax
  int v22; // edi
  const unsigned __int16 *v23; // edx
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // eax
  int v26; // eax
  unsigned __int8 *v27; // edi
  unsigned __int8 *v28; // edx
  unsigned __int8 v29; // cl
  int v30; // edi
  unsigned __int8 *v31; // edx
  const unsigned __int16 *v32; // eax
  int v33; // edx
  int i; // edx
  unsigned __int8 *clipboard_text; // edi
  unsigned int v36; // edi
  const unsigned __int16 **v37; // eax
  int v38; // ecx
  unsigned __int8 *v39; // ebx
  int v40; // edx
  unsigned __int8 v41; // cl
  int v42; // edi
  unsigned __int8 *v43; // ecx
  unsigned __int8 v44; // di
  unsigned __int8 *v45; // ecx
  int v46; // edi
  const unsigned __int8 *v47; // ebx
  unsigned __int8 *cdata; // edx
  bool v49; // zf
  const char *v50; // edi
  size_t v51; // eax
  const unsigned __int8 *v52; // eax
  unsigned __int8 *v53; // [esp+0h] [ebp-58h]
  unsigned __int8 v54; // [esp+18h] [ebp-40h]
  unsigned __int8 *dest; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *destc; // [esp+1Ch] [ebp-3Ch]
  const char *destd; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *deste; // [esp+1Ch] [ebp-3Ch]
  const unsigned __int8 *desta; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *destf; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *destb; // [esp+1Ch] [ebp-3Ch]
  char *destg; // [esp+1Ch] [ebp-3Ch]
  size_t v63; // [esp+20h] [ebp-38h]
  void *src; // [esp+24h] [ebp-34h]
  unsigned __int8 *srca; // [esp+24h] [ebp-34h]
  terminal *term; // [esp+28h] [ebp-30h]
  unsigned __int8 *terma; // [esp+28h] [ebp-30h]
  unsigned __int8 *termb; // [esp+28h] [ebp-30h]
  term_event *ins; // [esp+2Ch] [ebp-2Ch]
  const unsigned __int8 *insa; // [esp+2Ch] [ebp-2Ch]
  const unsigned __int8 *insb; // [esp+2Ch] [ebp-2Ch]
  const unsigned __int16 **insc; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 insd; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *next[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v2 = dlg_data;
  v3 = widget_data;
  term = dlg_data->win->term;
  ins = dlg_data->term_event;
  v4 = kbd_action(KEYMAP_EDIT, ins, 0);
  v5 = v4;
  if ( v4 != -1 )
  {
    action = get_action(KEYMAP_EDIT, v4);
    if ( action && (action->flags & 0x10000) == 0 || !get_opt_(cmdline_options, "anonymous")->number )
    {
      switch ( v5 )
      {
        case 2:
          if ( widget_data->widget->type != WIDGET_FIELD || !widget_data->widget->info.button.textlen )
            return 1;
          do_tab_compl(dlg_data, &widget_data->info.field.history);
          goto display_field;
        case 3:
          if ( widget_data->widget->type != WIDGET_FIELD || !widget_data->widget->info.button.textlen )
            return 1;
          do_tab_compl_file(dlg_data, &widget_data->info.field.history);
          goto display_field;
        case 4:
          if ( widget_data->widget->type != WIDGET_FIELD || !widget_data->widget->info.button.textlen )
            return 1;
          do_tab_compl_unambiguous(dlg_data, &widget_data->info.field.history);
          goto display_field;
        case 5:
          cpos = (unsigned __int8 *)widget_data->info.field.cpos;
          if ( cpos )
          {
            if ( (*((_BYTE *)term + 56) & 2) != 0 )
            {
              next[0] = widget_data->cdata;
              v47 = &widget_data->cdata[(unsigned int)(cpos - 1)];
              while ( utf8_to_unicode(next, v47) != -3 )
                ;
              v3 = widget_data;
              cdata = widget_data->cdata;
              v49 = cpos == (unsigned __int8 *)(next[0] - cdata);
              widget_data->info.field.cpos = next[0] - cdata;
              if ( !v49 )
              {
                v50 = (const char *)&cpos[(_DWORD)cdata];
                next[0] = cdata;
                destg = (char *)cdata;
                v51 = strlen(v50);
                memmove(&destg[widget_data->info.field.cpos], v50, v51 + 1);
              }
            }
            else
            {
              deste = widget_data->cdata;
              v15 = strlen((const char *)deste);
              memmove(&cpos[(_DWORD)deste - 1], &cpos[(_DWORD)deste], v15 - (_DWORD)cpos + 1);
              --widget_data->info.field.cpos;
            }
          }
          goto display_field;
        case 8:
          set_clipboard_text(widget_data->cdata);
          return 0;
        case 9:
          set_clipboard_text(widget_data->cdata);
          *widget_data->cdata = 0;
          widget_data->info.field.cpos = 0;
          goto display_field;
        case 10:
          v16 = widget_data->cdata;
          v17 = strlen((const char *)v16);
          v18 = widget_data->info.field.cpos;
          if ( v17 > v18 )
          {
            if ( (*((_BYTE *)term + 56) & 2) != 0 )
            {
              v19 = &v16[v17];
              v20 = &v16[v18];
              next[0] = v20;
              desta = v19;
              utf8_to_unicode(next, v19);
              if ( v20 != next[0] )
                memmove(v20, next[0], desta - next[0] + 1);
            }
            else
            {
              memmove(&v16[v18], &v16[v18 + 1], v17 - v18 + 1);
            }
          }
          goto display_field;
        case 11:
          if ( widget_data->widget->type != WIDGET_FIELD )
            return 1;
          if ( !widget_data->widget->info.button.textlen )
            return 1;
          cur_hist = (widget_data *)widget_data->info.field.cur_hist;
          if ( cur_hist == (widget_data *)&widget_data->info.text.max_width )
            return 1;
          widget = (widget_data *)cur_hist->widget;
          goto LABEL_40;
        case 12:
          widget_data->info.field.cpos = strlen((const char *)widget_data->cdata);
          goto display_field;
        case 15:
          goto LABEL_16;
        case 16:
          v12 = widget_data->cdata;
          destd = (const char *)&v12[widget_data->info.field.cpos];
          v13 = strlen(destd);
          memmove(v12, destd, v13 + 1);
LABEL_16:
          widget_data->info.field.cpos = 0;
          goto display_field;
        case 17:
          widget_data->cdata[widget_data->info.field.cpos] = 0;
          goto display_field;
        case 18:
          terma = widget_data->cdata;
          v63 = strlen((const char *)terma);
          insb = (const unsigned __int8 *)widget_data->info.field.cpos;
          if ( (int)insb <= 0 )
          {
            v22 = widget_data->info.field.cpos;
            srca = &terma[(_DWORD)insb];
          }
          else
          {
            v22 = widget_data->info.field.cpos;
            v23 = *__ctype_b_loc();
            v24 = &terma[(_DWORD)insb];
            srca = &terma[(_DWORD)insb];
            while ( (v23[*(v24 - 1)] & 0x2000) != 0 )
            {
              --v22;
              --v24;
              if ( v22 <= 0 )
                goto LABEL_49;
            }
            if ( v22 > 0 )
            {
              v25 = &terma[v22];
              do
              {
                if ( (v23[*(v25 - 1)] & 0x2000) != 0 )
                  break;
                --v22;
                --v25;
              }
              while ( v22 > 0 );
            }
          }
LABEL_49:
          memmove(&terma[v22], srca, v63 - (_DWORD)insb + 1);
          widget_data->info.field.cpos = v22;
          goto display_field;
        case 19:
          v26 = widget_data->info.field.cpos;
          if ( v26 > 0 )
            widget_data->info.field.cpos = --v26;
          if ( v26 && (*((_BYTE *)term + 56) & 2) != 0 )
          {
            v27 = widget_data->cdata;
            next[0] = v27;
            v28 = &v27[widget_data->info.field.cpos];
            v29 = *v28;
            *v28 = 0;
            destf = v28;
            v54 = v29;
            strlen_utf8(next);
            *destf = v54;
            widget_data->info.field.cpos = next[0] - v27;
          }
          goto display_field;
        case 20:
          v30 = widget_data->info.field.cpos;
          if ( v30 <= 0 )
            goto display_field;
          insc = __ctype_b_loc();
          termb = widget_data->cdata;
          v31 = &termb[v30];
          while ( 1 )
          {
            v32 = *insc;
            if ( ((*insc)[*(v31 - 1)] & 0x2000) == 0 )
              break;
            --v30;
            --v31;
            widget_data->info.field.cpos = v30;
            if ( v30 <= 0 )
              goto LABEL_64;
          }
          v33 = widget_data->info.field.cpos;
          v2 = dlg_data;
          if ( v33 <= 0 )
            goto display_field;
          for ( i = v33 - 1; (v32[termb[i]] & 0x2000) == 0; --i )
          {
            widget_data->info.field.cpos = i;
            if ( i <= 0 )
              break;
            v32 = *insc;
          }
LABEL_64:
          v2 = dlg_data;
          goto display_field;
        case 21:
          v37 = __ctype_b_loc();
          v38 = widget_data->info.field.cpos;
          v39 = &widget_data->cdata[v38];
          while ( 1 )
          {
            v40 = v38;
            v41 = *v39++;
            insd = v41;
            v42 = v41;
            v38 = v40 + 1;
            if ( ((*v37)[v42] & 0x2000) == 0 )
              break;
            widget_data->info.field.cpos = v38;
          }
          v3 = widget_data;
          if ( !insd )
            goto display_field;
          v43 = &widget_data->cdata[v40];
          break;
        case 24:
          clipboard_text = get_clipboard_text();
          if ( clipboard_text )
          {
            safe_strncpy(widget_data->cdata, clipboard_text, widget_data->widget->datalen);
            widget_data->info.field.cpos = strlen((const char *)widget_data->cdata);
            mem_free(clipboard_text);
          }
          goto display_field;
        case 26:
          redraw_terminal_cls(term);
          return 0;
        case 27:
          v36 = widget_data->info.field.cpos;
          destb = widget_data->cdata;
          if ( v36 < strlen((const char *)destb) )
          {
            if ( (*((_BYTE *)term + 56) & 2) != 0 )
            {
              next[0] = &destb[v36];
              v52 = (const unsigned __int8 *)__rawmemchr(&destb[v36], 0);
              utf8_to_unicode(next, v52);
              widget_data->info.field.cpos = next[0] - widget_data->cdata;
            }
            else
            {
              widget_data->info.field.cpos = v36 + 1;
            }
          }
          goto display_field;
        case 29:
          if ( widget_data->widget->type != WIDGET_FIELD )
            return 1;
          if ( !widget_data->widget->info.button.textlen )
            return 1;
          widget = *(widget_data **)(widget_data->info.text.scroller_y + 4);
          if ( widget == (widget_data *)&widget_data->info.text.max_width )
            return 1;
LABEL_40:
          widget_data->info.text.scroller_y = (int)widget;
          dlg_set_history(widget_data);
          goto display_field;
        default:
          goto LABEL_6;
      }
      while ( 1 )
      {
        widget_data->info.field.cpos = ++v40;
        v44 = v43[1];
        if ( !v44 )
          break;
        ++v43;
        if ( ((*v37)[v44] & 0x2000) != 0 )
        {
          v2 = dlg_data;
          v3 = widget_data;
          goto LABEL_81;
        }
      }
      v2 = dlg_data;
      v3 = widget_data;
      if ( (*((_BYTE *)*v37 + 1) & 0x20) == 0 )
        goto display_field;
LABEL_81:
      v45 = &v3->cdata[v40];
      do
      {
        v3->info.field.cpos = ++v40;
        v46 = *++v45;
      }
      while ( ((*v37)[v46] & 0x2000) != 0 );
      goto display_field;
    }
    return 1;
  }
LABEL_6:
  if ( ins->info.mouse.x <= 31 || ins->info.mouse.y )
    return 1;
  dest = widget_data->cdata;
  src = (void *)strlen((const char *)dest);
  terminal_codepage = get_terminal_codepage(term);
  insa = u2cp_(ins->info.mouse.x, terminal_codepage, NBSP_MODE_ASCII);
  v8 = strlen((const char *)insa);
  if ( (int)src < (int)(widget_data->widget->datalen - v8) )
  {
    v9 = widget_data->info.field.cpos;
    v53 = &dest[v9 + v8];
    destc = &dest[v9];
    memmove(v53, destc, (size_t)src - v9 + 1);
    memcpy(destc, insa, v8);
    widget_data->info.field.cpos += v8;
  }
display_field:
  display_widget(v2, v3);
  redraw_from_window(v2->win);
  return 0;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (0805F0B0) --------------------------------------------------------
widget_handler_status_T __cdecl mouse_field(dialog_data *dlg_data, widget_data *widget_data)
{
  term_event *term_event; // eax
  int x; // edx
  int v4; // ecx
  int y; // edi
  unsigned int button; // eax
  int v8; // edi
  unsigned __int8 *cdata; // eax
  int v10; // edi
  int v11; // eax
  widget_data *v12; // eax
  int *cur_hist; // eax

  term_event = dlg_data->term_event;
  x = widget_data->box.x;
  v4 = term_event->info.mouse.x;
  y = term_event->info.mouse.y;
  if ( v4 < x
    || y < widget_data->box.y
    || v4 >= x + widget_data->box.width
    || y >= widget_data->box.height + widget_data->box.y )
  {
    return 1;
  }
  button = term_event->info.mouse.button;
  v8 = button & 7;
  if ( v8 == 3 )
  {
    if ( (button & 0x20) == 0 && widget_data->widget->type == WIDGET_FIELD )
    {
      if ( widget_data->widget->info.button.textlen )
      {
        v12 = *(widget_data **)(widget_data->info.text.scroller_y + 4);
        if ( v12 != (widget_data *)&widget_data->info.text.max_width )
        {
          widget_data->info.text.scroller_y = (int)v12;
          dlg_set_history(widget_data);
          select_widget(dlg_data, widget_data);
          return 0;
        }
      }
    }
    return 1;
  }
  if ( v8 == 4 )
  {
    if ( (button & 0x20) == 0 && widget_data->widget->type == WIDGET_FIELD )
    {
      if ( widget_data->widget->info.button.textlen )
      {
        cur_hist = (int *)widget_data->info.field.cur_hist;
        if ( cur_hist != &widget_data->info.text.max_width )
        {
          widget_data->info.text.scroller_y = *cur_hist;
          dlg_set_history(widget_data);
          select_widget(dlg_data, widget_data);
          return 0;
        }
      }
    }
    return 1;
  }
  cdata = widget_data->cdata;
  v10 = v4 + widget_data->info.field.vpos - x;
  widget_data->info.field.cpos = v10;
  v11 = strlen((const char *)cdata);
  if ( v10 > v11 )
    widget_data->info.field.cpos = v11;
  select_widget(dlg_data, widget_data);
  return 0;
}

//----- (0805F200) --------------------------------------------------------
widget_handler_status_T __cdecl init_field(dialog_data *dlg_data, widget_data *widget_data)
{
  widget_data *v2; // edi
  input_history *history; // eax
  const char *next; // esi
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  void *v8; // eax
  size_t v9; // [esp+14h] [ebp-24h]
  list_head_elinks *p_history; // [esp+1Ch] [ebp-1Ch]

  v2 = widget_data;
  if ( widget_data->widget->type == WIDGET_FIELD )
  {
    history = widget_data->widget->info.field.history;
    if ( history )
    {
      next = (const char *)history->entries.next;
      if ( history->entries.next != history )
      {
        p_history = &widget_data->info.field.history;
        do
        {
          v9 = strlen(next + 8);
          v6 = mem_alloc(v9 + 12);
          v7 = v6;
          if ( v6 )
          {
            memcpy(v6 + 2, next + 8, v9 + 1);
            v8 = p_history->next;
            v7[1] = p_history;
            *v7 = v8;
            p_history->next = v7;
            *(_DWORD *)(*v7 + 4) = v7;
          }
          next = *(const char **)next;
        }
        while ( (const char *)widget_data->widget->info.field.history != next );
        v2 = widget_data;
      }
    }
  }
  v2->info.field.cpos = strlen((const char *)v2->cdata);
  return 0;
}

//----- (0805F2B0) --------------------------------------------------------
void __cdecl input_field_line(
        session *ses,
        unsigned __int8 *prompt,
        void *data,
        input_history *history,
        input_line_handler_T handler)
{
  _DWORD *v5; // eax
  _DWORD *v6; // ebx
  char *v7; // eax
  int v8; // edx
  int v9; // eax
  _DWORD *v10; // edx
  _DWORD *v11; // eax
  memory_list *v12; // eax

  if ( !assert_failed )
  {
    assert_failed = ses == 0;
    if ( !ses )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inpfield.c";
      errline = 880;
      elinks_internal("assertion ses failed!");
    }
  }
  v5 = mem_calloc(1u, 0x160u);
  v6 = v5;
  if ( v5 )
  {
    v5[21] = ses;
    v7 = (char *)(v5 + 21);
    *((_DWORD *)v7 + 1) = handler;
    *((_DWORD *)v7 + 2) = data;
    v8 = v6[8];
    v6[1] = v7;
    *((_BYTE *)v6 + 28) |= 0x10u;
    v9 = v8 + 1;
    v10 = &v6[12 * v8];
    v6[8] = v9;
    v6[5] = input_line_event_handler;
    v6[4] = input_line_layouter;
    v11 = &v6[12 * v9];
    v10[20] = 1;
    v10[11] = 0;
    v10[10] = prompt;
    v11[1] = 256;
    v10[12] = v6 + 24;
    v11[5] = 2;
    v11[2] = 0;
    v11[3] = 0;
    v11[4] = history;
    v12 = getml(v6, 0);
    do_dialog(ses->tab->term, (dialog *)v6, v12);
  }
}

//----- (0805F3E0) --------------------------------------------------------
widget_handler_status_T __cdecl input_line_event_handler(dialog_data *dlg_data)
{
  char *udata; // esi
  term_event *term_event; // edx
  term_event_type ev; // eax
  _BOOL4 v4; // edi
  _BOOL4 v6; // edi
  input_line *v7; // edi
  int v8; // eax
  widget *widget; // eax
  int cpos; // edi
  int *v11; // ecx
  int v12; // edx
  unsigned int v13; // eax
  unsigned __int8 *cdata; // esi
  size_t v15; // eax
  widget *v16; // eax
  input_history *history; // eax
  widget_handler_status_T v18; // [esp+1Ch] [ebp-2Ch]
  int v19; // [esp+20h] [ebp-28h]
  action_id_T action_id; // [esp+24h] [ebp-24h]
  widget_data *widget_data; // [esp+28h] [ebp-20h]
  input_line_handler_T handler; // [esp+2Ch] [ebp-1Ch]

  udata = (char *)dlg_data->dlg->udata;
  handler = (input_line_handler_T)*((_DWORD *)udata + 1);
  widget_data = dlg_data->widgets_data;
  term_event = dlg_data->term_event;
  ev = term_event->ev;
  if ( term_event->ev == EVENT_MOUSE )
  {
    if ( term_event->info.mouse.y != dlg_data->win->y )
    {
      v4 = 0;
      delete_window_ev(dlg_data->win, dlg_data->term_event);
      return v4;
    }
    return 1;
  }
  if ( term_event->ev > (unsigned int)EVENT_MOUSE )
  {
    if ( ev == EVENT_REDRAW )
    {
      widget = dlg_data->widgets_data[0].widget;
      if ( widget->type != WIDGET_FIELD )
        return 1;
      if ( !widget->info.button.textlen )
        return 1;
      cpos = dlg_data->widgets_data[0].info.field.cpos;
      if ( cpos <= 0 )
        return 1;
      v11 = (int *)(udata + 12);
      do
      {
        v12 = *v11++;
        v13 = ~v12 & (v12 - 16843009) & 0x80808080;
      }
      while ( !v13 );
      if ( (~v12 & (v12 - 16843009) & 0x8080) == 0 )
        v13 >>= 16;
      if ( (~v12 & (v12 - 16843009) & 0x8080) == 0 )
        v11 = (int *)((char *)v11 + 2);
      if ( cpos <= (unsigned int)((char *)v11 - __CFADD__((_BYTE)v13, (_BYTE)v13) - 3 - (udata + 12)) )
        return 1;
    }
    else if ( ev != EVENT_RESIZE )
    {
      return 1;
    }
    v6 = 1;
    v19 = 26;
    action_id = 26;
  }
  else
  {
    if ( ev != EVENT_KBD )
      return 1;
    action_id = kbd_action(KEYMAP_EDIT, term_event, 0);
    switch ( action_id )
    {
      case 5:
        if ( udata[12] )
          goto LABEL_29;
        goto cancel_input_line;
      case 7:
cancel_input_line:
        v4 = 0;
        goto LABEL_12;
      case 14:
      case 22:
      case 25:
        v16 = dlg_data->widgets_data[0].widget;
        if ( v16->type == WIDGET_FIELD )
        {
          history = v16->info.field.history;
          if ( history )
            add_to_input_history(history, (unsigned __int8 *)udata + 12, 1);
        }
        goto LABEL_29;
      default:
LABEL_29:
        kbd_field(dlg_data, widget_data);
        v19 = action_id;
        v6 = action_id == 26;
        break;
    }
  }
  update_dialog_data(dlg_data);
  v18 = v6;
  v7 = (input_line *)udata;
  while ( 1 )
  {
    v8 = handler(v7, v19);
    if ( !v8 )
      break;
    if ( v8 != 2 )
      return v18;
    cdata = dlg_data->widgets_data[0].cdata;
    v15 = strlen((const char *)cdata);
    memmove(
      &cdata[dlg_data->widgets_data[0].info.field.cpos - 1],
      &cdata[dlg_data->widgets_data[0].info.field.cpos],
      1 - dlg_data->widgets_data[0].info.field.cpos + v15);
    --dlg_data->widgets_data[0].info.field.cpos;
    update_dialog_data(dlg_data);
  }
  v4 = action_id == 26;
LABEL_12:
  cancel_dialog(dlg_data, widget_data);
  return v4;
}

//----- (0805F620) --------------------------------------------------------
widget_handler_status_T __cdecl input_field_cancel(dialog_data *dlg_data, widget_data *widget_data)
{
  void (__cdecl *data)(void *); // eax

  data = (void (__cdecl *)(void *))widget_data->widget->data;
  if ( data )
    data(dlg_data->dlg->udata2);
  return cancel_dialog(dlg_data, widget_data);
}

//----- (0805F660) --------------------------------------------------------
widget_handler_status_T __cdecl input_field_ok(dialog_data *dlg_data, widget_data *widget_data)
{
  void (__cdecl *v2)(void *, unsigned __int8 *); // edi
  widget *widget; // eax
  void *data; // [esp+18h] [ebp-20h]
  unsigned __int8 *text; // [esp+1Ch] [ebp-1Ch]

  v2 = (void (__cdecl *)(void *, unsigned __int8 *))widget_data->widget->data;
  data = dlg_data->dlg->udata2;
  text = dlg_data->widgets_data[0].cdata;
  if ( !check_dialog(dlg_data) )
  {
    widget = dlg_data->widgets_data[0].widget;
    if ( widget->type == WIDGET_FIELD && widget->info.button.textlen )
    {
      add_to_input_history(dlg_data->dlg->widgets[0].info.field.history, text, 1);
      if ( !v2 )
        return cancel_dialog(dlg_data, widget_data);
    }
    else if ( !v2 )
    {
      return cancel_dialog(dlg_data, widget_data);
    }
    v2(data, text);
    return cancel_dialog(dlg_data, widget_data);
  }
  return 1;
}

//----- (0805F710) --------------------------------------------------------
void __cdecl dlg_format_field(
        terminal *term,
        widget_data *widget_data,
        int x,
        int *y,
        int w,
        int *rw,
        format_align align,
        int format_only)
{
  int v8; // ecx
  int v9; // ebx
  char *v10; // edx
  inpfield_flags flags; // eax
  signed int v12; // eax
  int v13; // eax
  int v14; // edx
  color_pair *bfu_color; // eax
  int v16; // [esp+10h] [ebp-68h]
  unsigned __int8 *texta; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *text; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *textb; // [esp+4Ch] [ebp-2Ch]
  int v20; // [esp+50h] [ebp-28h]
  int v21; // [esp+50h] [ebp-28h]
  bool v22; // [esp+57h] [ebp-21h]
  color_pair *text_color; // [esp+58h] [ebp-20h]
  color_pair *text_colora; // [esp+58h] [ebp-20h]
  int label_width; // [esp+5Ch] [ebp-1Ch]

  v8 = x;
  v9 = w;
  v10 = (char *)widget_data->widget->text;
  flags = widget_data->widget->info.field.flags;
  if ( v10 )
  {
    v22 = (flags & 3) != 0;
    if ( (flags & 3) != 0 )
    {
      if ( !*v10 )
        goto LABEL_15;
      texta = widget_data->widget->text;
      v12 = strlen(v10);
      v10 = (char *)texta;
      label_width = v12;
      if ( prev_y_8446 == y )
      {
        text_color = (color_pair *)max_label_width_8445;
        if ( v12 > max_label_width_8445 )
        {
          max_label_width_8445 = v12;
          text_color = (color_pair *)v12;
        }
      }
      else
      {
        prev_y_8446 = y;
        max_label_width_8445 = v12;
        text_color = (color_pair *)v12;
      }
      v8 = (int)text_color + x - v12;
      v9 = v12 + w - (_DWORD)text_color;
    }
    else
    {
      if ( !*v10 )
        goto LABEL_15;
      label_width = 0;
    }
    text_colora = 0;
    if ( !format_only )
    {
      textb = (unsigned __int8 *)v10;
      v21 = v8;
      bfu_color = get_bfu_color(term, "dialog.text");
      v8 = v21;
      v10 = (char *)textb;
      text_colora = bfu_color;
    }
    text = (unsigned __int8 *)v10;
    v20 = v8;
    dlg_format_text_do(term, (unsigned __int8 *)v10, v8, y, v9, rw, text_colora, ALIGN_LEFT, format_only);
    v8 = v20;
    if ( v22 && *text )
    {
      if ( (*((_BYTE *)&widget_data->widget->info.text + 12) & 1) != 0 )
      {
        --*y;
        v16 = v9;
        v9 -= 2;
        dlg_format_text_do(
          term,
          (unsigned __int8 *)&buf,
          v20 + label_width,
          y,
          v16,
          rw,
          text_colora,
          ALIGN_LEFT,
          format_only);
        v8 = v20 + 2;
      }
      if ( v9 - 5 > label_width )
      {
        --*y;
        v9 -= label_width;
        v8 += label_width;
      }
    }
  }
LABEL_15:
  if ( rw )
  {
    v13 = 42;
    if ( v9 < 42 )
      v13 = v9;
    if ( v13 > *rw )
      *rw = v13;
  }
  v14 = *y;
  if ( v8 < 0 )
    v8 = 0;
  widget_data->box.x = v8;
  widget_data->box.height = 1;
  if ( v14 < 0 )
    v14 = 0;
  if ( v9 < 0 )
    v9 = 0;
  widget_data->box.y = v14;
  widget_data->box.width = v9;
  ++*y;
}

//----- (0805F930) --------------------------------------------------------
void __cdecl input_line_layouter(dialog_data *dlg_data)
{
  window *win; // ecx
  char v2; // bl
  int y[3]; // [esp+2Ch] [ebp-Ch] BYREF

  win = dlg_data->win;
  v2 = *(_BYTE *)(*(_DWORD *)dlg_data->dlg->udata + 168);
  y[0] = dlg_data->win->term->height - 1 - (v2 & 1) - ((v2 & 2) != 0);
  dlg_format_field(win->term, dlg_data->widgets_data, 0, y, win->term->width, 0, ALIGN_LEFT, 0);
}
// 805F930: using guessed type int y[3];

//----- (0805F9B0) --------------------------------------------------------
widget_handler_status_T __cdecl check_nonempty(dialog_data *dlg_data, widget_data *widget_data)
{
  unsigned __int8 *cdata; // eax
  unsigned __int8 v3; // dl

  cdata = widget_data->cdata;
  v3 = *cdata;
  if ( *cdata )
  {
    while ( v3 <= 0x20u )
    {
      v3 = *++cdata;
      if ( !*cdata )
        goto LABEL_6;
    }
    return 0;
  }
  else
  {
LABEL_6:
    info_box(dlg_data->win->term, (msgbox_flags)0, "Bad string", ALIGN_CENTER, "Empty string not allowed");
    return 1;
  }
}

//----- (0805FA20) --------------------------------------------------------
widget_handler_status_T __cdecl check_number(dialog_data *dlg_data, widget_data *widget_data)
{
  int *v2; // eax
  int *v3; // esi
  int v4; // edx
  int gid; // ecx
  int gnum; // ebx
  widget_handler_status_T result; // eax
  unsigned __int8 *v8; // eax
  widget *widget; // [esp+2Ch] [ebp-2Ch]
  char *end; // [esp+3Ch] [ebp-1Ch] BYREF

  widget = widget_data->widget;
  v2 = __errno_location();
  *v2 = 0;
  v3 = v2;
  v4 = strtol((const char *)widget_data->cdata, &end, 10);
  if ( *v3 || !*widget_data->cdata || *end )
  {
    info_box(dlg_data->win->term, (msgbox_flags)0, "Bad number", ALIGN_CENTER, "Number expected in field");
  }
  else
  {
    gid = widget->info.checkbox.gid;
    if ( v4 < gid )
    {
      gnum = widget->info.checkbox.gnum;
    }
    else
    {
      gnum = widget->info.checkbox.gnum;
      result = EVENT_PROCESSED;
      if ( v4 <= gnum )
        return result;
    }
    v8 = msg_text(dlg_data->win->term, "Number should be in the range from %d to %d.", gid, gnum);
    info_box(dlg_data->win->term, MSGBOX_FREE_TEXT, "Bad number", ALIGN_CENTER, v8);
  }
  return 1;
}

//----- (0805FB20) --------------------------------------------------------
void __cdecl input_field(
        terminal *term,
        memory_list *ml,
        int intl,
        unsigned __int8 *title,
        unsigned __int8 *text,
        unsigned __int8 *okbutton,
        unsigned __int8 *cancelbutton,
        void *data,
        input_history *history,
        int l,
        unsigned __int8 *def,
        int min,
        int max,
        widget_handler_T *check,
        void (*fn)(void *, unsigned __int8 *),
        void (*cancelfn)(void *))
{
  int v16; // esi
  unsigned __int8 *v17; // edi
  char *v18; // eax
  dialog *v19; // ebx
  signed int v20; // eax
  unsigned __int8 *v21; // eax
  int number_of_widgets; // eax
  int v23; // edx
  char *v24; // eax
  char *v25; // edx
  input_history *v26; // eax
  bool v27; // zf
  int terminal_codepage; // eax
  int v29; // ebx
  unsigned __int8 *cp_mime_name; // eax
  int v31; // eax
  int v32; // ebx
  unsigned __int8 *v33; // eax
  int v34; // eax
  int v35; // ebx
  unsigned __int8 *v36; // eax
  int v37; // eax
  int v38; // ebx
  unsigned __int8 *v39; // eax
  unsigned __int8 *field; // [esp+2Ch] [ebp-1Ch]

  v16 = l;
  v17 = def;
  if ( intl )
  {
    if ( title && *title )
    {
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        v29 = terminal_codepage;
        if ( terminal_codepage != current_charset )
        {
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v29;
        }
      }
      title = gettext(title);
    }
    if ( text && *text )
    {
      if ( term )
      {
        v31 = get_terminal_codepage(term);
        v32 = v31;
        if ( v31 != current_charset )
        {
          v33 = get_cp_mime_name(v31);
          bind_textdomain_codeset("elinks", v33);
          current_charset = v32;
        }
      }
      text = gettext(text);
    }
    if ( okbutton && *okbutton )
    {
      if ( term )
      {
        v34 = get_terminal_codepage(term);
        v35 = v34;
        if ( v34 != current_charset )
        {
          v36 = get_cp_mime_name(v34);
          bind_textdomain_codeset("elinks", v36);
          current_charset = v35;
        }
      }
      okbutton = gettext(okbutton);
    }
    if ( cancelbutton && *cancelbutton )
    {
      if ( term )
      {
        v37 = get_terminal_codepage(term);
        v38 = v37;
        if ( v37 != current_charset )
        {
          v39 = get_cp_mime_name(v37);
          bind_textdomain_codeset("elinks", v39);
          current_charset = v38;
        }
      }
      cancelbutton = gettext(cancelbutton);
    }
  }
  v18 = (char *)mem_calloc(1u, v16 + 180);
  v19 = (dialog *)v18;
  if ( v18 )
  {
    field = (unsigned __int8 *)(v18 + 180);
    if ( v17 )
    {
      v20 = strlen((const char *)v17) + 1;
      if ( v16 < v20 )
        v20 = v16 - 1;
      memcpy(field, v17, v20);
    }
    v21 = title;
    *(_BYTE *)&v19->layout |= 4u;
    v19->layouter = generic_dialog_layouter;
    v19->title = v21;
    v19->udata2 = data;
    number_of_widgets = v19->number_of_widgets;
    v23 = number_of_widgets + 1;
    v24 = (char *)v19 + 48 * number_of_widgets;
    v19->number_of_widgets = v23;
    *((_DWORD *)v24 + 20) = 1;
    v25 = (char *)v19 + 48 * v23;
    *((_DWORD *)v24 + 10) = text;
    *((_DWORD *)v24 + 11) = check;
    *((_DWORD *)v25 + 1) = v16;
    *((_DWORD *)v24 + 12) = field;
    v26 = history;
    *((_DWORD *)v25 + 5) = 0;
    *((_DWORD *)v25 + 4) = v26;
    *((_DWORD *)v25 + 2) = min;
    *((_DWORD *)v25 + 3) = max;
    add_dlg_button_do(v19, okbutton, 1, input_field_ok, fn, 0, 0);
    add_dlg_button_do(v19, cancelbutton, 2, input_field_cancel, cancelfn, 0, 0);
    if ( !assert_failed )
    {
      v27 = v19->number_of_widgets == 3;
      assert_failed = v19->number_of_widgets != 3;
      if ( !v27 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inpfield.c";
        errline = 239;
        elinks_internal("assertion 3 == (dlg)->number_of_widgets failed!");
      }
    }
    add_to_ml(&ml, v19, 0);
    do_dialog(term, v19, ml);
  }
}

//----- (0805FE50) --------------------------------------------------------
void __cdecl input_dialog(
        terminal *term,
        memory_list *ml,
        unsigned __int8 *title,
        unsigned __int8 *text,
        void *data,
        input_history *history,
        int l,
        unsigned __int8 *def,
        int min,
        int max,
        widget_handler_T *check,
        void (*fn)(void *, unsigned __int8 *),
        void (*cancelfn)(void *))
{
  input_field(
    term,
    ml,
    1,
    title,
    text,
    (unsigned __int8 *)&okbutton,
    (unsigned __int8 *)&cancelbutton,
    data,
    history,
    l,
    def,
    min,
    max,
    check,
    fn,
    cancelfn);
}

//----- (0805FED0) --------------------------------------------------------
void __cdecl dlg_set_history(widget_data *widget_data)
{
  widget_data *cur_hist; // edi
  const char *p_box; // edi
  int datalen; // esi
  signed int v4; // eax
  signed int v5; // esi
  int cpos; // eax
  int v7; // eax
  bool v8; // zf

  if ( !assert_failed )
  {
    if ( widget_data->widget->type == WIDGET_FIELD && widget_data->widget->info.button.textlen )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
      errline = 357;
      elinks_internal("assertion widget_has_history(widget_data) failed!");
      if ( assert_failed )
        goto LABEL_4;
    }
    v8 = widget_data->widget->datalen > 0;
    assert_failed = widget_data->widget->datalen <= 0;
    if ( !v8 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
      errline = 358;
      elinks_internal("assertion widget_data->widget->datalen > 0 failed!");
      cur_hist = (widget_data *)widget_data->info.field.cur_hist;
      if ( cur_hist == (widget_data *)&widget_data->info.text.max_width )
        goto LABEL_16;
      goto LABEL_5;
    }
  }
LABEL_4:
  cur_hist = (widget_data *)widget_data->info.field.cur_hist;
  if ( cur_hist == (widget_data *)&widget_data->info.text.max_width )
  {
LABEL_16:
    widget_data->info.field.cpos = 0;
    cpos = 0;
    goto LABEL_9;
  }
LABEL_5:
  p_box = (const char *)&cur_hist->box;
  datalen = widget_data->widget->datalen;
  v4 = strlen(p_box);
  v5 = datalen - 1;
  if ( v4 <= v5 )
    v5 = v4;
  cpos = 0;
  widget_data->info.field.cpos = v5;
  if ( v5 )
  {
    memcpy(widget_data->cdata, p_box, v5);
    cpos = widget_data->info.field.cpos;
  }
LABEL_9:
  widget_data->cdata[cpos] = 0;
  v7 = 0;
  if ( widget_data->info.field.cpos - widget_data->box.width >= 0 )
    v7 = widget_data->info.field.cpos - widget_data->box.width;
  widget_data->info.field.vpos = v7;
}

//----- (08060010) --------------------------------------------------------
int __cdecl save_input_history(input_history *history, unsigned __int8 *filename)
{
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // esi
  secure_save_info *v5; // edi
  const char *prev; // esi
  int v7; // edx
  int v8; // [esp+1Ch] [ebp-1Ch]

  if ( (*((_BYTE *)history + 12) & 1) == 0 || !elinks_home || get_opt_(cmdline_options, "anonymous")->number )
    return 0;
  v3 = straconcat((const unsigned __int8 *)elinks_home, filename, 0);
  v4 = v3;
  if ( !v3 )
    return -1;
  v5 = secure_open(v3);
  mem_free(v4);
  if ( !v5 )
    return -1;
  prev = (const char *)history->entries.prev;
  v7 = 1;
  if ( prev == (const char *)history )
  {
    if ( !v5->err )
LABEL_16:
      *((_BYTE *)history + 12) &= ~1u;
  }
  else
  {
    while ( 1 )
    {
      v8 = v7;
      secure_fputs(v5, prev + 8);
      secure_fputc(v5, 10);
      if ( v5->err )
        break;
      prev = (const char *)*((_DWORD *)prev + 1);
      if ( prev == (const char *)history || v8 == 257 )
        goto LABEL_16;
      v7 = v8 + 1;
    }
  }
  return secure_close(v5);
}

//----- (08060120) --------------------------------------------------------
void __cdecl add_to_input_history(input_history *history, unsigned __int8 *data, int check_duplicate)
{
  unsigned __int8 *v3; // edi
  size_t v4; // ebx
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // edx
  char v7; // cl
  void *next; // ebx
  void *v9; // edi
  input_history **v10; // eax
  input_history *v11; // eax
  char v12; // dl
  _DWORD *v13; // eax
  _DWORD *v14; // ebx
  void *v15; // eax
  char v16; // dl
  int v17; // eax
  _DWORD *prev; // eax
  char v19; // dl
  _DWORD *v20; // edx
  bool v21; // zf
  void *v22; // eax
  char v23; // al
  void *v24; // [esp+0h] [ebp-38h]
  unsigned __int8 v25; // [esp+10h] [ebp-28h]
  input_history **v26; // [esp+10h] [ebp-28h]
  size_t v27; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]

  v3 = data;
  if ( data && history && *data )
  {
    v25 = *data;
    v4 = strlen((const char *)data);
    v5 = data;
    if ( v25 == 32 )
    {
      do
      {
        ++v5;
        --v4;
      }
      while ( *v5 == 32 );
    }
    if ( !v4 )
    {
LABEL_11:
      *data = *v5;
      return;
    }
    if ( v5[v4 - 1] == 32 )
    {
      v6 = &v5[v4];
      do
      {
        --v4;
        *(v6 - 1) = 0;
        if ( !v4 )
          goto LABEL_11;
        v7 = *(v6 - 2);
        --v6;
      }
      while ( v7 == 32 );
    }
    n = v4 + 1;
    memmove(data, v5, v4 + 1);
    if ( !check_duplicate || !*data || history->entries.next == history )
      goto LABEL_25;
    v27 = v4;
    next = history->entries.next;
    v9 = 0;
    while ( 1 )
    {
      if ( !strcmp((const char *)next + 8, (const char *)data) )
      {
        v10 = (input_history **)*((_DWORD *)next + 1);
        *(_DWORD *)(*(_DWORD *)next + 4) = v10;
        **((_DWORD **)next + 1) = *(_DWORD *)next;
        v12 = *((_BYTE *)history + 12);
        --history->size;
        if ( (v12 & 2) == 0 )
          *((_BYTE *)history + 12) = v12 | 1;
        if ( v9 )
        {
          v24 = next;
          next = v9;
          v26 = v10;
          mem_free(v24);
          v10 = v26;
        }
      }
      else
      {
        v10 = (input_history **)next;
        next = v9;
      }
      v11 = *v10;
      if ( v11 == history )
        break;
      v9 = next;
      next = v11;
    }
    v20 = next;
    v3 = data;
    v21 = next == 0;
    v4 = v27;
    if ( v21 )
    {
LABEL_25:
      v13 = mem_alloc(v4 + 12);
      v14 = v13;
      if ( v13 )
      {
        memcpy(v13 + 2, v3, n);
        v15 = history->entries.next;
        v14[1] = history;
        *v14 = v15;
        history->entries.next = v14;
        *(_DWORD *)(*v14 + 4) = v14;
        v16 = *((_BYTE *)history + 12);
        v17 = history->size + 1;
        history->size = v17;
        if ( (v16 & 2) == 0 )
          *((_BYTE *)history + 12) = v16 | 1;
        if ( v17 > 256 )
        {
          while ( history != history->entries.next )
          {
            prev = history->entries.prev;
            *(_DWORD *)(*prev + 4) = prev[1];
            *(_DWORD *)prev[1] = *prev;
            v19 = *((_BYTE *)history + 12);
            --history->size;
            if ( (v19 & 2) == 0 )
              *((_BYTE *)history + 12) = v19 | 1;
            mem_free(prev);
            if ( history->size <= 256 )
              return;
          }
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
          errline = 274;
          elinks_internal("history is empty");
          history->size = 0;
        }
      }
    }
    else
    {
      v22 = history->entries.next;
      v20[1] = history;
      *v20 = v22;
      history->entries.next = v20;
      *(_DWORD *)(*v20 + 4) = v20;
      v23 = *((_BYTE *)history + 12);
      ++history->size;
      if ( (v23 & 2) == 0 )
        *((_BYTE *)history + 12) = v23 | 1;
    }
  }
}

//----- (08060340) --------------------------------------------------------
int __cdecl load_input_history(input_history *history, unsigned __int8 *filename)
{
  unsigned __int8 *v2; // ebx
  FILE *v3; // edi
  unsigned __int8 line[1024]; // [esp+1Ch] [ebp-41Ch] BYREF
  unsigned int v7; // [esp+41Ch] [ebp-1Ch]

  v7 = __readgsdword(0x14u);
  if ( !get_opt_(cmdline_options, "anonymous")->number )
  {
    v2 = filename;
    if ( !elinks_home || (v2 = straconcat((const unsigned __int8 *)elinks_home, filename, 0)) != 0 )
    {
      v3 = (FILE *)fopen64(v2, "rb");
      if ( elinks_home )
        mem_free(v2);
      if ( v3 )
      {
        *((_BYTE *)history + 12) |= 2u;
        while ( fgets((char *)line, 1024, v3) )
        {
          if ( line[0] )
            line[strlen((const char *)line) - 1] = 0;
          add_to_input_history(history, line, 0);
        }
        *((_BYTE *)history + 12) &= ~2u;
        fclose(v3);
      }
    }
  }
  return 0;
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08060480) --------------------------------------------------------
void __cdecl tab_complete_file_menu(terminal *term, void *path_, void *dlg_data_)
{
  auto_complete_file(term, 0, (unsigned __int8 *)path_, set_complete_file_menu, tab_complete_file_menu, dlg_data_);
}

//----- (080604C0) --------------------------------------------------------
void __cdecl do_tab_compl_file(dialog_data *dlg_data, list_head_elinks *history)
{
  int selected_widget_id; // esi

  selected_widget_id = dlg_data->selected_widget_id;
  if ( !get_opt_(cmdline_options, "anonymous")->number )
    tab_complete_file_menu(dlg_data->win->term, dlg_data->widgets_data[selected_widget_id].cdata, dlg_data);
}

//----- (08060520) --------------------------------------------------------
void __cdecl set_complete_file_menu(terminal *term, void *filename_, void *dlg_data_)
{
  int v3; // ebx
  bool v4; // zf
  signed int v5; // eax
  char *v6; // edx
  signed int v7; // edi
  char *v8; // eax

  v3 = *((_DWORD *)dlg_data_ + 8);
  if ( !assert_failed )
  {
    v4 = (unsigned int)(*(_DWORD *)(*((_DWORD *)dlg_data_ + 12 * v3 + 10) + 44) - 1) <= 1;
    assert_failed = (unsigned int)(*(_DWORD *)(*((_DWORD *)dlg_data_ + 12 * v3 + 10) + 44) - 1) > 1;
    if ( !v4 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
      errline = 166;
      elinks_internal("assertion widget_is_textfield(widget_data) failed!");
    }
  }
  v5 = strlen((const char *)filename_);
  v6 = (char *)dlg_data_ + 48 * v3;
  v7 = *(_DWORD *)(*((_DWORD *)v6 + 10) + 16) - 1;
  if ( v5 <= v7 )
    v7 = v5;
  memcpy(*((void **)v6 + 11), filename_, v7);
  *(_BYTE *)(*((_DWORD *)dlg_data_ + 12 * v3 + 11) + v7) = 0;
  v8 = (char *)dlg_data_ + 48 * v3 + 48;
  *((_DWORD *)v8 + 5) = v7;
  *((_DWORD *)v8 + 4) = 0;
  mem_free(filename_);
  redraw_dialog((dialog_data *)dlg_data_, 1);
}

//----- (08060610) --------------------------------------------------------
void __usercall tab_compl_n(dialog_data *dlg_data@<eax>, unsigned __int8 *item@<edx>, int len@<ecx>)
{
  unsigned __int8 *v4; // eax
  int selected_widget_id; // esi
  bool v6; // zf
  char *v7; // edx
  signed int v8; // edi
  box *p_box; // eax
  int v10; // [esp+18h] [ebp-20h]

  v4 = item;
  selected_widget_id = dlg_data->selected_widget_id;
  if ( !assert_failed )
  {
    v6 = (unsigned int)(dlg_data->widgets_data[selected_widget_id].widget->type - 1) <= 1;
    assert_failed = (unsigned int)(dlg_data->widgets_data[selected_widget_id].widget->type - 1) > 1;
    if ( !v6 )
    {
      v10 = len;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/inphist.c";
      errline = 31;
      elinks_internal("assertion widget_is_textfield(widget_data) failed!");
      len = v10;
      v4 = item;
    }
  }
  v7 = (char *)dlg_data + 48 * selected_widget_id;
  v8 = *(_DWORD *)(*((_DWORD *)v7 + 10) + 16) - 1;
  if ( len <= v8 )
    v8 = len;
  memcpy(*((void **)v7 + 11), v4, v8);
  dlg_data->widgets_data[selected_widget_id].cdata[v8] = 0;
  p_box = &dlg_data->widgets_data[selected_widget_id].box;
  p_box[1].y = v8;
  p_box[1].x = 0;
  redraw_dialog(dlg_data, 1);
}

//----- (08060700) --------------------------------------------------------
void __cdecl menu_tab_compl(terminal *term, void *item_, void *dlg_data_)
{
  int v3; // eax

  v3 = strlen((const char *)item_);
  tab_compl_n((dialog_data *)dlg_data_, (unsigned __int8 *)item_, v3);
}

//----- (08060730) --------------------------------------------------------
void __cdecl do_tab_compl_unambiguous(dialog_data *dlg_data, list_head_elinks *history)
{
  list_head_elinks *next; // edx
  unsigned __int8 *v3; // esi
  list_head_elinks *v4; // edi
  char v5; // al
  list_head_elinks *v6; // eax
  unsigned __int8 *cdata; // ecx
  int v8; // eax
  signed int v9; // ebx
  list_head_elinks *v10; // ebx
  unsigned int v11; // eax
  unsigned int v12; // ecx
  bool v13; // zf
  list_head_elinks *v14; // eax
  unsigned int v15; // ecx
  size_t v16; // edx
  unsigned __int8 *v17; // eax
  size_t v18; // [esp+14h] [ebp-44h]
  unsigned int v19; // [esp+18h] [ebp-40h]
  int selected_widget_id; // [esp+24h] [ebp-34h]
  int v21; // [esp+2Ch] [ebp-2Ch]
  int v22; // [esp+2Ch] [ebp-2Ch]
  string completion; // [esp+38h] [ebp-20h] BYREF

  selected_widget_id = dlg_data->selected_widget_id;
  next = (list_head_elinks *)history->next;
  if ( history->next == history )
    return;
  v3 = 0;
  v21 = 0;
  v4 = next + 1;
LABEL_15:
  cdata = dlg_data->widgets_data[selected_widget_id].cdata;
  v5 = (char)next[1].next;
  if ( !v5 )
  {
LABEL_16:
    v8 = 0;
    goto LABEL_9;
  }
  while ( 1 )
  {
    if ( v5 != *cdata )
      goto LABEL_16;
    v6 = v4;
    do
    {
      v6 = (list_head_elinks *)((char *)v6 + 1);
      if ( !LOBYTE(v6->next) )
        break;
      ++cdata;
    }
    while ( LOBYTE(v6->next) == *cdata );
    v8 = (char *)v6 - (char *)v4;
LABEL_9:
    if ( dlg_data->widgets_data[selected_widget_id].info.field.cpos > v8 )
      goto LABEL_12;
    if ( v3 )
    {
      if ( v8 < v21 )
        goto LABEL_13;
LABEL_12:
      v8 = v21;
      goto LABEL_13;
    }
    v10 = v4;
    do
    {
      v11 = (unsigned int)v10->next;
      v10 = (list_head_elinks *)((char *)v10 + 4);
      v12 = ~v11 & (v11 - 16843009) & 0x80808080;
    }
    while ( !v12 );
    v3 = (unsigned __int8 *)v4;
    v13 = (~v11 & (v11 - 16843009) & 0x8080) == 0;
    if ( (~v11 & (v11 - 16843009) & 0x8080) == 0 )
      v12 >>= 16;
    v14 = (list_head_elinks *)((char *)&v10->next + 2);
    if ( !v13 )
      v14 = v10;
    v8 = (char *)v14 - __CFADD__((_BYTE)v12, (_BYTE)v12) - 3 - (char *)v4;
LABEL_13:
    next = (list_head_elinks *)next->next;
    if ( next == history )
      break;
    cdata = v3;
    v21 = v8;
    v4 = next + 1;
    if ( !v3 )
      goto LABEL_15;
    v5 = (char)next[1].next;
    if ( !v5 )
      goto LABEL_16;
  }
  v9 = v8;
  if ( v3 && init_string(&completion) )
  {
    if ( assert_failed )
      goto LABEL_20;
    if ( v9 < 0 )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
      {
LABEL_20:
        assert_failed = 0;
        goto LABEL_21;
      }
LABEL_32:
      v15 = completion.length + 255;
      v22 = v9 + completion.length;
      v16 = v9 + completion.length + 256;
      LOBYTE(v15) = 0;
      LOBYTE(v16) = 0;
      if ( v16 > v15 )
      {
        v18 = v16;
        v19 = v15;
        v17 = (unsigned __int8 *)mem_realloc(completion.source, v16);
        if ( !v17 )
          goto LABEL_21;
        completion.source = v17;
        memset(&v17[v19], 0, v18 - v19);
      }
      if ( completion.source )
      {
        memcpy(&completion.source[completion.length], v3, v9);
        completion.source[v22] = 0;
        completion.length = v22;
      }
    }
    else
    {
      assert_failed = 0;
      if ( v9 )
        goto LABEL_32;
    }
LABEL_21:
    add_to_string(
      &completion,
      &dlg_data->widgets_data[selected_widget_id].cdata[dlg_data->widgets_data[selected_widget_id].info.field.cpos]);
    tab_compl_n(dlg_data, completion.source, completion.length);
    done_string(&completion);
  }
}

//----- (08060990) --------------------------------------------------------
void __cdecl do_tab_compl(dialog_data *dlg_data, list_head_elinks *history)
{
  int selected_widget_id; // esi
  int cpos; // edi
  menu_item *v4; // eax
  const char *next; // ebx
  char *data; // ebx
  int v7; // eax
  terminal *term; // [esp+24h] [ebp-34h]
  int n; // [esp+28h] [ebp-30h]
  menu_item *items; // [esp+3Ch] [ebp-1Ch] BYREF

  term = dlg_data->win->term;
  selected_widget_id = dlg_data->selected_widget_id;
  cpos = dlg_data->widgets_data[selected_widget_id].info.field.cpos;
  v4 = new_menu(NO_INTL|FREE_LIST);
  if ( v4 )
  {
    items = v4;
    next = (const char *)history->next;
    if ( history->next != history )
    {
      n = 0;
      do
      {
        while ( strncmp((const char *)dlg_data->widgets_data[selected_widget_id].cdata, next + 8, cpos) )
        {
          next = *(const char **)next;
          if ( next == (const char *)history )
            goto LABEL_7;
        }
        add_to_menu(&items, (unsigned __int8 *)next + 8, 0, ACT_MAIN_NONE, menu_tab_compl, (void *)(next + 8), NO_FLAG);
        ++n;
        next = *(const char **)next;
      }
      while ( next != (const char *)history );
LABEL_7:
      if ( n > 1 )
      {
        do_menu_selected(term, items, dlg_data, n - 1, 0);
        return;
      }
      v4 = items;
      if ( n == 1 )
      {
        data = (char *)items->data;
        v7 = strlen(data);
        tab_compl_n(dlg_data, (unsigned __int8 *)data, v7);
        v4 = items;
      }
    }
    mem_free(v4);
  }
}

//----- (08060AC0) --------------------------------------------------------
void __cdecl init_leds(module *module)
{
  timer_duration_backup = 0;
}

//----- (08060AD0) --------------------------------------------------------
void __cdecl set_led_value(led *led, unsigned __int8 value)
{
  __int16 v2; // ax

  if ( (unsigned __int8)(*(_WORD *)led >> 2) != value )
  {
    v2 = (4 * value) | *(_WORD *)led & 0xFC03;
    *(_WORD *)led = v2;
    *(_BYTE *)led = v2 | 2;
  }
}

//----- (08060B00) --------------------------------------------------------
void __cdecl unset_led_value(led *led)
{
  __int16 v1; // ax

  if ( (unsigned __int8)(*(_WORD *)led >> 2) != 45 )
  {
    v1 = *(_WORD *)led & 0xFC03;
    LOBYTE(v1) = v1 | 0xB4;
    *(_WORD *)led = v1;
    *(_BYTE *)led = v1 | 2;
  }
}

//----- (08060B30) --------------------------------------------------------
void __cdecl init_led_panel(led_panel *leds)
{
  int i; // eax
  __int16 v2; // cx

  for ( i = 0; i != 6; ++i )
  {
    *(_BYTE *)&leds->leds[i] &= ~1u;
    if ( (unsigned __int8)(*(_WORD *)&leds->leds[i] >> 2) != 45 )
    {
      v2 = *(_WORD *)&leds->leds[i] & 0xFC03;
      LOBYTE(v2) = v2 | 0xB4;
      *(_WORD *)&leds->leds[i] = v2;
      *(_BYTE *)&leds->leds[i] = v2 | 2;
    }
  }
}

//----- (08060B70) --------------------------------------------------------
led *__cdecl register_led(session *ses, int number)
{
  led *result; // eax
  char v3; // bl

  if ( (unsigned int)number > 5 )
    return 0;
  v3 = (char)ses->status.leds.leds[number];
  if ( (v3 & 1) != 0 )
    return 0;
  result = &ses->status.leds.leds[number];
  *(_BYTE *)result = v3 | 1;
  return result;
}

//----- (08060BB0) --------------------------------------------------------
void __cdecl unregister_led(led *led)
{
  int v1; // eax
  __int16 v2; // ax

  if ( !assert_failed )
  {
    v1 = (*(_BYTE *)led ^ 1) & 1;
    assert_failed = v1;
    if ( v1 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/leds.c";
      errline = 341;
      elinks_internal("assertion led->used__ failed: Attempted to unregister unused led!");
    }
  }
  *(_BYTE *)led &= ~1u;
  if ( (unsigned __int8)(*(_WORD *)led >> 2) != 45 )
  {
    v2 = *(_WORD *)led & 0xFC03;
    LOBYTE(v2) = v2 | 0xB4;
    *(_WORD *)led = v2;
    *(_BYTE *)led = v2 | 2;
  }
}

//----- (08060C30) --------------------------------------------------------
void __cdecl menu_leds_info(terminal *term, void *xxx, void *xxxx)
{
  unsigned __int8 *v3; // eax

  v3 = msg_text(
         term,
         "What the different LEDs indicate:\n"
         "\n"
         "[SIJP--]\n"
         " |||||`- Unused\n"
         " ||||`-- Unused\n"
         " |||`--- A JavaScript pop-up window was blocked\n"
         " ||`---- A JavaScript error has occurred\n"
         " |`----- The state of insert mode for text-input form-fields\n"
         " |       'i' means modeless, 'I' means insert mode is on\n"
         " `------ Whether an SSL connection was used\n"
         "\n"
         "'-' generally indicates that the LED is off.");
  info_box(term, MSGBOX_SCROLLABLE|MSGBOX_FREE_TEXT, "LED indicators", ALIGN_LEFT, v3);
}

//----- (08060C80) --------------------------------------------------------
void __cdecl draw_leds(session *ses)
{
  color_pair *bfu_color; // esi
  terminal *term; // ebx
  int height; // edi
  int v4; // edi
  int v5; // esi
  session *v6; // eax
  int v7; // ebx
  int v8; // edi
  struct tm *v9; // eax
  size_t v10; // eax
  char *v11; // ebx
  int v12; // edi
  int v13; // esi
  unicode_val_T v14; // eax
  int timer_duration; // eax
  int v16; // eax
  unsigned int v17; // edx
  bool v18; // zf
  char *v19; // eax
  int v20; // esi
  char *v21; // ebx
  int v22; // edi
  unicode_val_T v23; // eax
  int v24; // [esp+4h] [ebp-C4h]
  int v25; // [esp+4h] [ebp-C4h]
  int v26; // [esp+4h] [ebp-C4h]
  session *v27; // [esp+3Ch] [ebp-8Ch]
  int v28; // [esp+40h] [ebp-88h]
  int leds_length; // [esp+40h] [ebp-88h]
  size_t v30; // [esp+44h] [ebp-84h]
  char *v31; // [esp+44h] [ebp-84h]
  int v32; // [esp+44h] [ebp-84h]
  int xpos; // [esp+48h] [ebp-80h]
  int width; // [esp+50h] [ebp-78h]
  color_pair *color; // [esp+54h] [ebp-74h]
  color_pair *colora; // [esp+54h] [ebp-74h]
  color_pair *colorb; // [esp+54h] [ebp-74h]
  int y; // [esp+58h] [ebp-70h]
  int ya; // [esp+58h] [ebp-70h]
  int yb; // [esp+58h] [ebp-70h]
  terminal *v41; // [esp+5Ch] [ebp-6Ch]
  terminal *v42; // [esp+5Ch] [ebp-6Ch]
  terminal *v43; // [esp+5Ch] [ebp-6Ch]
  time_t timer; // [esp+68h] [ebp-60h] BYREF
  char s[64]; // [esp+6Ch] [ebp-5Ch] BYREF
  unsigned int v46; // [esp+ACh] [ebp-1Ch]

  bfu_color = 0;
  v46 = __readgsdword(0x14u);
  term = ses->tab->term;
  width = term->width;
  xpos = width - 9;
  height = term->height;
  term->leds_length = 0;
  v4 = height - 1;
  if ( get_opt_(config_options, "ui.timer.enable")->number == 2 )
  {
    bfu_color = get_bfu_color(term, "status.status-text");
    if ( !bfu_color )
      goto end;
    leds_length = term->leds_length;
    timer_duration = get_timer_duration();
    __snprintf_chk(s, 64, 1, 64, "[%d]", timer_duration);
    v31 = s;
    do
    {
      v16 = *(_DWORD *)v31;
      v31 += 4;
      v17 = ~v16 & (v16 - 16843009) & 0x80808080;
    }
    while ( !v17 );
    v18 = (~v16 & (v16 - 16843009) & 0x8080) == 0;
    if ( (~v16 & (v16 - 16843009) & 0x8080) == 0 )
      v17 >>= 16;
    v19 = v31;
    if ( v18 )
      v19 = v31 + 2;
    v32 = &v19[-__CFADD__((_BYTE)v17, (_BYTE)v17) - 3] - s;
    if ( v32 - 1 >= 0 )
    {
      colorb = bfu_color;
      v20 = v32 - 1;
      v43 = term;
      v21 = &s[v32 - 1];
      yb = v4;
      v22 = width - 10;
      do
      {
        v23 = (unsigned __int8)*v21--;
        v26 = v22--;
        draw_char(v43, v26, yb, v23, (screen_char_attr)0, colorb);
        --v20;
      }
      while ( v20 >= 0 );
      v4 = yb;
      bfu_color = colorb;
      term = v43;
    }
    term->leds_length = leds_length + v32;
  }
  if ( !led_options[5].option_elinks.value.number )
    return;
  if ( bfu_color || (bfu_color = get_bfu_color(term, "status.status-text")) != 0 )
  {
    if ( led_options[1].option_elinks.value.number )
    {
      v28 = term->leds_length;
      timer = time(0);
      v9 = localtime(&timer);
      v10 = strftime(s, 0x40u, (const char *)led_options[2].option_elinks.value.tree, v9);
      s[v10] = 0;
      v30 = v10;
      if ( (int)(v10 - 1) >= 0 )
      {
        v42 = term;
        v11 = &s[v10 - 1];
        ya = v4;
        colora = bfu_color;
        v12 = xpos - v28 - 1;
        v13 = v10 - 1;
        do
        {
          v14 = (unsigned __int8)*v11--;
          v25 = v12--;
          draw_char(v42, v25, ya, v14, (screen_char_attr)0, colora);
          --v13;
        }
        while ( v13 >= 0 );
        v4 = ya;
        bfu_color = colora;
        term = v42;
      }
      term->leds_length = v28 + v30;
    }
    draw_char(term, xpos, v4, 0x5Bu, (screen_char_attr)0, bfu_color);
    color = bfu_color;
    v5 = 0;
    v6 = ses;
    v41 = term;
    y = v4;
    v7 = width - 8;
    do
    {
      v8 = v5 + 40;
      ++v5;
      v24 = v7++;
      v27 = v6;
      draw_char(
        v41,
        v24,
        y,
        (unsigned __int8)(*((_WORD *)&v6->history.current + 2 * v8) >> 2),
        (screen_char_attr)0,
        color);
      v6 = v27;
      *((_BYTE *)&v27->history.current + 4 * v8) &= ~2u;
    }
    while ( v5 != 6 );
    draw_char(v41, xpos + 7, y, 0x5Du, (screen_char_attr)0, color);
    v41->leds_length += 8;
  }
end:
  if ( !drawing && !redraw_timer )
    install_timer(&redraw_timer, 100, redraw_leds, 0);
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 8060C80: using guessed type char s[64];

//----- (08061090) --------------------------------------------------------
void __cdecl redraw_leds(void *xxx)
{
  session *next; // ebx
  int v2; // eax
  int timer_duration; // eax

  if ( led_options[5].option_elinks.value.number || get_opt_(config_options, "ui.timer.enable")->number == 2 )
  {
    install_timer(&redraw_timer, 100, redraw_leds, 0);
    if ( !drawing )
    {
      next = (session *)sessions.next;
      for ( drawing = 1; next != (session *)&sessions; next = next->next )
      {
        if ( !led_options[1].option_elinks.value.number )
        {
          v2 = 0;
          while ( (*(_BYTE *)&next->status.leds.leds[v2] & 2) == 0 )
          {
            if ( ++v2 == 6 )
            {
              timer_duration = get_timer_duration();
              if ( timer_duration == timer_duration_backup )
                goto LABEL_14;
              timer_duration_backup = timer_duration;
              break;
            }
          }
        }
        redraw_terminal(next->tab->term);
        draw_leds(next);
LABEL_14:
        ;
      }
      drawing = 0;
    }
  }
  else
  {
    redraw_timer = 0;
  }
}

//----- (08061180) --------------------------------------------------------
void __cdecl done_leds(module *module)
{
  kill_timer(&redraw_timer);
}

//----- (080611A0) --------------------------------------------------------
void __cdecl add_dlg_listbox(dialog *dlg, void *box_data)
{
  int number_of_widgets; // edx
  char *v3; // eax

  number_of_widgets = dlg->number_of_widgets;
  dlg->number_of_widgets = number_of_widgets + 1;
  v3 = (char *)dlg + 48 * number_of_widgets;
  *((_DWORD *)v3 + 20) = 4;
  *((_DWORD *)v3 + 12) = box_data;
}

//----- (080611D0) --------------------------------------------------------
listbox_item *__cdecl traverse_listbox_items_list(
        listbox_item *item,
        listbox_data *box,
        int offset,
        int follow_visible,
        int (*fn)(listbox_item *, void *, int *),
        void *d)
{
  listbox_item *v6; // esi
  int v7; // eax
  int v8; // edx
  listbox_item *v9; // eax
  listbox_item *prev; // edi
  listbox_item *next; // edx
  listbox_item *v12; // ebx
  listbox_item *v13; // ecx
  char v14; // al
  int v16; // eax
  bool v17; // zf
  listbox_item *v18; // edi
  listbox_item *v19; // eax
  int v20; // eax
  char v21; // al
  int v22; // ebx
  listbox_item *v23; // eax
  listbox_item *v24; // [esp+14h] [ebp-24h]
  listbox_item *v25; // [esp+14h] [ebp-24h]
  listbox_item *visible_item; // [esp+18h] [ebp-20h]
  int infinite; // [esp+1Ch] [ebp-1Ch]

  v6 = item;
  v7 = offset;
  visible_item = 0;
  if ( item )
  {
    infinite = 0;
    if ( !offset )
    {
      offset = 1;
      v7 = 1;
      infinite = 1;
    }
    visible_item = item;
    v8 = 0;
LABEL_5:
    while ( !v8 )
    {
      if ( !v7 )
        return visible_item;
      v9 = box->ops->get_root(v6);
      prev = v6->prev;
      next = v6->next;
      v12 = v9;
      if ( fn && (!follow_visible || (*((_BYTE *)v6 + 24) & 2) != 0) )
      {
        v24 = v6->next;
        v16 = fn(v6, d, &offset);
        next = v24;
        v17 = v16 == 0;
        v7 = offset;
        if ( !v17 )
          v6 = 0;
        if ( !offset )
        {
          infinite = 0;
          v8 = 0;
          goto LABEL_5;
        }
      }
      else
      {
        v7 = offset;
      }
      if ( v7 <= 0 )
      {
        if ( !infinite )
          offset = v7 + 1;
        v20 = 0;
        if ( v12 )
        {
          if ( &v12->child != (list_head_elinks *)prev )
            goto LABEL_46;
          v23 = box->ops->get_root(v12);
          prev = v12->prev;
          if ( v23 )
          {
            v6 = v12;
            v8 = 0;
LABEL_61:
            if ( !follow_visible || (*((_BYTE *)v6 + 24) & 2) != 0 )
            {
LABEL_29:
              visible_item = v6;
              v7 = offset;
              goto LABEL_5;
            }
            goto LABEL_63;
          }
          v6 = v12;
          v20 = 1;
        }
        v8 = 1;
        if ( (listbox_item *)box->items != prev )
        {
          if ( !v20 )
          {
LABEL_46:
            box->ops->get_root(prev);
            if ( !prev )
            {
LABEL_55:
              v8 = 0;
              v6 = 0;
              goto LABEL_63;
            }
            if ( prev->child.next == &prev->child || (v21 = *((_BYTE *)prev + 24), v6 = prev, (v21 & 1) == 0) )
            {
              v6 = prev;
LABEL_65:
              v8 = 0;
              goto LABEL_61;
            }
            v22 = follow_visible;
            while ( !v22 || (v21 & 2) != 0 )
            {
              v6 = (listbox_item *)v6->child.prev;
              box->ops->get_root(v6);
              if ( !v6 )
                goto LABEL_55;
              if ( v6->child.next != &v6->child )
              {
                v21 = *((_BYTE *)v6 + 24);
                if ( (v21 & 1) != 0 )
                  continue;
              }
              goto LABEL_65;
            }
          }
          v8 = 0;
        }
        if ( v6 )
          goto LABEL_61;
LABEL_63:
        v7 = --offset;
        goto LABEL_5;
      }
      if ( !infinite )
        offset = v7 - 1;
      if ( v6
        && (v13 = (listbox_item *)v6->child.next, v13 != (listbox_item *)&v6->child)
        && (v14 = *((_BYTE *)v6 + 24), (v14 & 1) != 0)
        && (!follow_visible || (v14 & 2) != 0) )
      {
        v6 = (listbox_item *)v6->child.next;
        box->ops->get_root(v13);
        v8 = 0;
      }
      else
      {
        v18 = 0;
        if ( v12 )
        {
          v18 = v6;
          if ( next != (listbox_item *)&v12->child )
            goto LABEL_41;
          while ( 1 )
          {
            v19 = box->ops->get_root(v12);
            next = v12->next;
            if ( !v19 )
              break;
            if ( &v19->child != (list_head_elinks *)next )
              goto LABEL_41;
            if ( !v18 )
              v18 = v12;
            v12 = v19;
          }
          v6 = v12;
        }
        if ( next && (listbox_item *)box->items != next )
        {
LABEL_41:
          v25 = next;
          box->ops->get_root(next);
          v6 = v25;
          v8 = 0;
          goto done_down;
        }
        if ( v18 )
        {
          v6 = v18;
          box->ops->get_root(v18);
        }
        v8 = 1;
      }
done_down:
      if ( v6 && (!follow_visible || (*((_BYTE *)v6 + 24) & 2) != 0) )
        goto LABEL_29;
      v7 = ++offset;
    }
  }
  return visible_item;
}

//----- (080614C0) --------------------------------------------------------
int __cdecl calc_dist(listbox_item *item, void *data_, int *offset)
{
  if ( *offset < 0 )
  {
    --*(_DWORD *)data_;
    return 0;
  }
  else
  {
    if ( *offset )
      ++*(_DWORD *)data_;
    return 0;
  }
}

//----- (080614F0) --------------------------------------------------------
int __cdecl test_search(listbox_item *item, void *data_, int *offset)
{
  if ( *((listbox_item **)data_ + 1) == item )
    *offset = 0;
  else
    ++*((_DWORD *)data_ + 6);
  return 0;
}

//----- (08061520) --------------------------------------------------------
int __cdecl check_old_state(listbox_item *item, void *info_, int *offset)
{
  listbox_item *v3; // edx

  v3 = (listbox_item *)*((_DWORD *)info_ + 3);
  if ( v3 == item )
  {
    *((_DWORD *)info_ + 3) = 0;
LABEL_7:
    if ( !*((_DWORD *)info_ + 4) )
      *offset = 0;
    return 0;
  }
  if ( *((listbox_item **)info_ + 4) == item )
    *((_DWORD *)info_ + 4) = 0;
  if ( !v3 )
    goto LABEL_7;
  return 0;
}

//----- (08061580) --------------------------------------------------------
listbox_data *__cdecl get_listbox_widget_data(widget_data *widget_data)
{
  bool v1; // zf

  if ( assert_failed )
    return (listbox_data *)widget_data->widget->data;
  v1 = widget_data->widget->type == WIDGET_LISTBOX;
  assert_failed = widget_data->widget->type != WIDGET_LISTBOX;
  if ( v1 )
    return (listbox_data *)widget_data->widget->data;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
  errline = 38;
  elinks_internal("assertion widget_data->widget->type == WIDGET_LISTBOX failed!");
  return (listbox_data *)widget_data->widget->data;
}

//----- (080615F0) --------------------------------------------------------
widget_handler_status_T __cdecl init_listbox(dialog_data *dlg_data, widget_data *widget_data)
{
  char *udata2; // esi
  listbox_data *listbox_widget_data; // eax
  listbox_data *v4; // ebx
  listbox_item *v5; // edx
  listbox_item *top; // ecx
  listbox_item *v7; // eax
  const listbox_ops *v8; // eax
  listbox_data *v9; // edx
  listbox_item *v11; // ecx

  udata2 = (char *)dlg_data->dlg->udata2;
  listbox_widget_data = get_listbox_widget_data(widget_data);
  v4 = listbox_widget_data;
  if ( *((char **)udata2 + 10) == udata2 + 40 || !*((_DWORD *)udata2 + 23) )
    goto LABEL_8;
  listbox_widget_data->next = (listbox_data *)*((_DWORD *)udata2 + 17);
  listbox_widget_data->prev = (listbox_data *)*((_DWORD *)udata2 + 18);
  listbox_widget_data->ops = (const listbox_ops *)*((_DWORD *)udata2 + 19);
  listbox_widget_data->sel = (listbox_item *)*((_DWORD *)udata2 + 20);
  listbox_widget_data->top = (listbox_item *)*((_DWORD *)udata2 + 21);
  listbox_widget_data->sel_offset = *((_DWORD *)udata2 + 22);
  listbox_widget_data->items = (list_head_elinks *)*((_DWORD *)udata2 + 23);
  traverse_listbox_items_list(
    *((listbox_item **)udata2 + 10),
    listbox_widget_data,
    0,
    0,
    check_old_state,
    listbox_widget_data);
  v5 = 0;
  if ( v4->sel )
  {
    top = v4->top;
    v7 = 0;
    v4->sel = 0;
    if ( top )
      goto LABEL_5;
LABEL_10:
    v7 = (listbox_item *)*((_DWORD *)udata2 + 21);
    v4->top = v7;
    if ( v5 )
      goto LABEL_6;
    goto LABEL_11;
  }
  v11 = v4->top;
  v7 = 0;
  v5 = (listbox_item *)*((_DWORD *)udata2 + 20);
  v4->sel = v5;
  if ( !v11 )
    goto LABEL_10;
LABEL_5:
  v4->top = 0;
  if ( v5 )
    goto LABEL_6;
LABEL_11:
  v4->sel = v7;
LABEL_6:
  if ( !v7 )
    v4->top = v4->sel;
LABEL_8:
  v8 = (const listbox_ops *)*((_DWORD *)udata2 + 16);
  v4->items = (list_head_elinks *)(udata2 + 40);
  v4->ops = v8;
  v9 = (listbox_data *)*((_DWORD *)udata2 + 4);
  v4->prev = (listbox_data *)(udata2 + 16);
  v4->next = v9;
  *((_DWORD *)udata2 + 4) = v4;
  v4->next->prev = v4;
  return 0;
}

//----- (080616F0) --------------------------------------------------------
void __cdecl listbox_sel_move(widget_data *widget_data, int dist)
{
  int v2; // edi
  listbox_data *listbox_widget_data; // ebx
  list_head_elinks *items; // eax
  listbox_item *next; // edx
  listbox_item *top; // eax
  listbox_item *sel; // eax
  int sel_offset; // eax
  int height; // edx
  listbox_item *v10; // eax
  listbox_item *v11; // ecx

  v2 = dist;
  listbox_widget_data = get_listbox_widget_data(widget_data);
  items = listbox_widget_data->items;
  next = (listbox_item *)items->next;
  if ( items != items->next )
  {
    top = listbox_widget_data->top;
    if ( top )
    {
      if ( listbox_widget_data->sel )
      {
LABEL_4:
        if ( top && (*((_BYTE *)top + 24) & 2) == 0 )
        {
          sel = traverse_listbox_items_list(top, listbox_widget_data, 1, 1, 0, 0);
          listbox_widget_data->top = sel;
          listbox_widget_data->sel = sel;
        }
        else
        {
          sel = listbox_widget_data->sel;
        }
        if ( !dist )
        {
          if ( (*((_BYTE *)sel + 24) & 2) != 0 )
          {
LABEL_9:
            sel_offset = listbox_widget_data->sel_offset;
            if ( sel_offset < 0 )
            {
              v10 = listbox_widget_data->sel;
              listbox_widget_data->sel_offset = 0;
              listbox_widget_data->top = v10;
            }
            else
            {
              height = widget_data->box.height;
              if ( sel_offset >= height )
              {
                listbox_widget_data->sel_offset = height - 1;
                listbox_widget_data->top = traverse_listbox_items_list(
                                             listbox_widget_data->sel,
                                             listbox_widget_data,
                                             1 - widget_data->box.height,
                                             1,
                                             0,
                                             0);
              }
            }
            return;
          }
          LOWORD(v2) = 1;
        }
        listbox_widget_data->sel = traverse_listbox_items_list(
                                     sel,
                                     listbox_widget_data,
                                     v2,
                                     1,
                                     calc_dist,
                                     &listbox_widget_data->sel_offset);
        goto LABEL_9;
      }
    }
    else
    {
      v11 = listbox_widget_data->sel;
      top = next;
      listbox_widget_data->top = next;
      if ( v11 )
        goto LABEL_4;
    }
    listbox_widget_data->sel = top;
    top = listbox_widget_data->top;
    goto LABEL_4;
  }
}

//----- (08061850) --------------------------------------------------------
widget_handler_status_T __cdecl kbd_listbox(dialog_data *dlg_data, widget_data *widget_data)
{
  widget_handler_status_T result; // eax
  term_event *term_event; // edx
  int v4; // eax
  int v5; // edx
  listbox_item *sel; // edx
  const listbox_ops *ops; // eax

  result = EVENT_NOT_PROCESSED;
  term_event = dlg_data->term_event;
  if ( term_event->ev == EVENT_KBD )
  {
    v4 = kbd_action(KEYMAP_MENU, term_event, 0) - 3;
    switch ( v4 )
    {
      case 0:
        ops = get_listbox_widget_data(dlg_data->widgets_data)->ops;
        if ( !ops || !ops->delete || !ops->can_delete )
          return 0;
        push_hierbox_delete_button(dlg_data, widget_data);
        return 0;
      case 1:
        listbox_sel_move(dlg_data->widgets_data, 1);
        goto LABEL_7;
      case 2:
        listbox_sel_move(dlg_data->widgets_data, 0x7FFFFFFF);
        goto LABEL_7;
      case 5:
        listbox_sel_move(dlg_data->widgets_data, -2147483647);
        goto LABEL_7;
      case 7:
        sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
        if ( sel )
        {
          *((_BYTE *)sel + 24) = (4 * (((*((_BYTE *)sel + 24) >> 2) ^ 1) & 1)) | *((_BYTE *)sel + 24) & 0xFB;
          listbox_sel_move(dlg_data->widgets_data, 1);
        }
        goto LABEL_7;
      case 9:
        v5 = 2 * dlg_data->widgets_data[0].box.height - get_listbox_widget_data(dlg_data->widgets_data)->sel_offset - 1;
        goto LABEL_9;
      case 10:
        v5 = -dlg_data->widgets_data[0].box.height - get_listbox_widget_data(dlg_data->widgets_data)->sel_offset;
LABEL_9:
        listbox_sel_move(dlg_data->widgets_data, v5);
        goto LABEL_7;
      case 17:
        listbox_sel_move(dlg_data->widgets_data, -1);
LABEL_7:
        display_widget(dlg_data, dlg_data->widgets_data);
        result = EVENT_PROCESSED;
        break;
      default:
        result = EVENT_NOT_PROCESSED;
        break;
    }
  }
  return result;
}

//----- (080619C0) --------------------------------------------------------
widget_handler_status_T __cdecl mouse_listbox(dialog_data *dlg_data, widget_data *widget_data)
{
  listbox_data *listbox_widget_data; // eax
  term_event *term_event; // edx
  listbox_data *v4; // ebx
  list_head_elinks *items; // eax
  unsigned int v6; // eax
  int v7; // ecx
  int v8; // eax
  listbox_item *top; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // [esp+4h] [ebp-54h]
  int x; // [esp+2Ch] [ebp-2Ch]
  widget_data *v15; // [esp+34h] [ebp-24h]
  int y; // [esp+3Ch] [ebp-1Ch]

  listbox_widget_data = get_listbox_widget_data(widget_data);
  term_event = dlg_data->term_event;
  v4 = listbox_widget_data;
  items = listbox_widget_data->items;
  if ( items != items->next )
  {
    if ( v4->top )
    {
      if ( v4->sel )
        goto LABEL_4;
    }
    else
    {
      v4->top = (listbox_item *)items->next;
      if ( v4->sel )
        goto LABEL_4;
    }
    v4->sel = v4->top;
  }
LABEL_4:
  if ( (term_event->info.mouse.button & 0x20) != 0 )
  {
    v6 = term_event->info.mouse.button & 7;
  }
  else
  {
    v6 = term_event->info.mouse.button & 7;
    if ( v6 == 3 )
    {
      v13 = -1;
      goto LABEL_21;
    }
    if ( v6 == 4 )
    {
      v13 = 1;
LABEL_21:
      listbox_sel_move(dlg_data->widgets_data, v13);
      display_widget(dlg_data, dlg_data->widgets_data);
      return 0;
    }
  }
  if ( v6 > 2 )
    return 1;
  y = term_event->info.mouse.y;
  x = term_event->info.mouse.x;
  v7 = widget_data->box.x;
  if ( x < v7 )
    return 1;
  v8 = widget_data->box.y;
  if ( y < v8 || x >= widget_data->box.width + v7 || y >= widget_data->box.height + v8 )
    return 1;
  v4->sel_offset = y - v8;
  if ( y == v8 )
  {
    top = v4->top;
  }
  else
  {
    v15 = (widget_data *)term_event;
    top = traverse_listbox_items_list(v4->top, v4, y - v8, 1, 0, 0);
    term_event = (term_event *)v15;
  }
  v4->sel = top;
  if ( top )
  {
    if ( top->type == BI_FOLDER )
    {
      v11 = term_event->info.mouse.x;
      v12 = widget_data->box.x + 5 * top->depth;
      if ( v12 <= v11 && v11 <= v12 + 2 )
        *((_BYTE *)top + 24) = (*((_BYTE *)top + 24) ^ 1) & 1 | *((_BYTE *)top + 24) & 0xFE;
    }
  }
  display_widget(dlg_data, widget_data);
  return 0;
}

//----- (08061B70) --------------------------------------------------------
int __cdecl display_listbox_item(listbox_item *item, void *data_, int *offset)
{
  terminal **v3; // edi
  int v4; // ebx
  listbox_item *v5; // esi
  listbox_item *v6; // edx
  listbox_item *v7; // eax
  int v8; // ebx
  bool v9; // al
  listbox_item_type type; // eax
  char v11; // dl
  int v12; // ebx
  terminal **v13; // edx
  int v14; // edi
  int v15; // eax
  terminal *v16; // eax
  int v17; // ebx
  _DWORD *next; // esi
  void (__cdecl *v19)(listbox_item *, terminal **, int, int, char *); // edx
  const char *v21; // eax
  unsigned __int8 *v22; // esi
  terminal *v23; // ecx
  int v24; // eax
  bool v25; // sf
  int v26; // edx
  int v27; // ecx
  terminal *v28; // eax
  int v29; // edx
  terminal **v30; // edx
  int v31; // esi
  int v32; // eax
  int v33; // eax
  listbox_item *v34; // edx
  int v35; // ebx
  listbox_item **v36; // eax
  border_char v37; // [esp+Ch] [ebp-7Ch]
  listbox_item *v38; // [esp+28h] [ebp-60h]
  listbox_item *v39; // [esp+2Ch] [ebp-5Ch]
  terminal **v40; // [esp+2Ch] [ebp-5Ch]
  terminal **v41; // [esp+2Ch] [ebp-5Ch]
  color_pair *text_color; // [esp+30h] [ebp-58h]
  int depth; // [esp+34h] [ebp-54h]
  int v44; // [esp+38h] [ebp-50h]
  color_pair *tree_color; // [esp+3Ch] [ebp-4Ch]
  int v46; // [esp+40h] [ebp-48h]
  int d; // [esp+44h] [ebp-44h]
  int v48; // [esp+48h] [ebp-40h]
  int width; // [esp+4Ch] [ebp-3Ch]
  int widtha; // [esp+4Ch] [ebp-3Ch]
  int widthb; // [esp+4Ch] [ebp-3Ch]
  border_char str[5]; // [esp+5Ch] [ebp-2Ch]

  v3 = (terminal **)data_;
  v44 = item->depth;
  depth = v44 + 1;
  tree_color = get_bfu_color(*(terminal **)data_, "menu.normal");
  if ( *(listbox_item **)(*((_DWORD *)data_ + 2) + 12) == item )
  {
    text_color = get_bfu_color(*(terminal **)data_, "menu.selected");
  }
  else
  {
    text_color = tree_color;
    if ( (*((_BYTE *)item + 24) & 4) != 0 )
      text_color = get_bfu_color(*(terminal **)data_, "menu.marked");
  }
  v46 = *(_DWORD *)(*((_DWORD *)data_ + 4) + 12) + *((_DWORD *)data_ + 6);
  if ( v44 > 0 )
  {
    v48 = 0;
    d = 0;
    width = v44 + 1;
    do
    {
      v4 = width;
      v5 = item;
      v6 = item;
      v7 = item;
      if ( width )
      {
        while ( 1 )
        {
          v7 = 0;
          if ( v5 )
            v7 = (listbox_item *)(*(int (__cdecl **)(listbox_item *))(*(_DWORD *)(*((_DWORD *)data_ + 2) + 8) + 24))(v5);
          if ( !--v4 )
            break;
          v5 = v7;
        }
        v6 = v5;
      }
      v8 = *(_DWORD *)(*((_DWORD *)data_ + 4) + 8) + v48;
      v38 = v7;
      v39 = v6;
      draw_text(*(terminal **)data_, v8, v46, (unsigned __int8 *)&byte_8134F98, 5, (screen_char_attr)0, tree_color);
      if ( v38 )
        v9 = v38->child.prev == v39;
      else
        v9 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)data_ + 2) + 24) + 4) == (_DWORD)v39;
      if ( !v9 )
        draw_border_char(*(terminal **)data_, v8 + 1, v46, BORDER_SVLINE, tree_color);
      ++d;
      --width;
      v48 += 5;
    }
    while ( v44 > d );
  }
  if ( v44 != -1 )
  {
    str[0] = 32;
    str[1] = BORDER_SRTEE;
    str[2] = BORDER_SHLINE;
    str[3] = BORDER_SHLINE;
    str[4] = 32;
    type = item->type;
    if ( type == BI_FOLDER )
    {
      v11 = *((_BYTE *)item + 24);
      str[0] = 91;
      str[2] = 93;
      str[1] = (v11 & 1) == 0 ? 43 : 45;
      goto LABEL_23;
    }
    if ( type && type != BI_SEPARATOR )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
      errline = 426;
      elinks_internal("Unknown item type");
      v11 = *((_BYTE *)item + 24);
LABEL_23:
      if ( (v11 & 4) != 0 )
        str[4] = 42;
      v12 = 0;
      v13 = (terminal **)data_;
      v14 = *(_DWORD *)(*((_DWORD *)data_ + 4) + 8) + 5 * v44;
      do
      {
        v37 = str[v12];
        v15 = v12 + v14;
        ++v12;
        v40 = v13;
        draw_border_char(*v13, v15, v46, v37, tree_color);
        v13 = v40;
      }
      while ( v12 != 5 );
      v3 = v40;
      goto LABEL_28;
    }
    v33 = (*(int (__cdecl **)(listbox_item *))(*(_DWORD *)(*((_DWORD *)data_ + 2) + 8) + 24))(item);
    if ( v33 )
    {
      v34 = item;
      if ( *(listbox_item **)(v33 + 12) != item )
        goto LABEL_55;
    }
    else
    {
      v34 = item;
      v36 = *(listbox_item ***)(*((_DWORD *)data_ + 2) + 24);
      if ( *v36 == item )
      {
        str[1] = BORDER_SULCORNER;
        goto LABEL_55;
      }
      v34 = item;
      if ( v36[1] != item )
      {
LABEL_55:
        v11 = *((_BYTE *)v34 + 24);
        goto LABEL_23;
      }
    }
    str[1] = BORDER_SDLCORNER;
    v11 = *((_BYTE *)item + 24);
    goto LABEL_23;
  }
LABEL_28:
  v16 = v3[4];
  v17 = (int)v16->windows.next + 5 * depth;
  if ( item->type == BI_SEPARATOR )
  {
    widthb = (int)v16->spec - 5 * depth;
    if ( widthb > 0 )
    {
      v30 = v3;
      v31 = 0;
      do
      {
        v32 = v31 + v17;
        ++v31;
        v41 = v30;
        draw_border_char(*v30, v32, v46, BORDER_SHLINE, text_color);
        v30 = v41;
      }
      while ( widthb > v31 );
      v3 = v41;
    }
    goto LABEL_32;
  }
  next = v3[2]->windows.next;
  if ( next )
  {
    v19 = (void (__cdecl *)(listbox_item *, terminal **, int, int, char *))next[10];
    if ( v19 )
    {
      v19(item, v3, v17, v46, (char *)v16->spec - 5 * depth);
LABEL_32:
      if ( v3[2]->windows.prev == item )
      {
        v35 = (int)v3[4]->windows.next + 5 * item->depth + 5;
        set_cursor(*v3, v35, v46, 1);
        v3[3]->next->fdin = v35;
        v3[3]->next->fdout = v46;
      }
      v3[6] = (terminal *)((char *)v3[6] + 1);
      return 0;
    }
  }
  if ( !assert_failed )
  {
    if ( next && next[4] )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listbox.c";
      errline = 458;
      elinks_internal("assertion ops && ops->get_info failed!");
    }
  }
  v21 = (const char *)((int (__cdecl *)(listbox_item *, terminal *))next[3])(item, *v3);
  v22 = (unsigned __int8 *)v21;
  if ( v21 )
  {
    widtha = strlen(v21);
    v23 = v3[4];
    v24 = 0;
    v25 = (int)v23->spec - 5 * depth < 0;
    v26 = (int)v23->spec - 5 * depth;
    v27 = widtha;
    if ( !v25 )
      v24 = v26;
    if ( widtha > v24 )
      v27 = v24;
    v28 = *v3;
    v29 = v27;
    if ( (*((_BYTE *)*v3 + 56) & 2) != 0 )
    {
      v29 = utf8_cells2bytes(v22, v27, 0);
      v28 = *v3;
    }
    draw_text(v28, v17, v46, v22, v29, (screen_char_attr)0, text_color);
    mem_free(v22);
    goto LABEL_32;
  }
  return 0;
}

//----- (08062070) --------------------------------------------------------
void __cdecl dlg_format_listbox(
        terminal *term,
        widget_data *widget_data,
        int x,
        int *y,
        int w,
        int max_height,
        int *rw,
        format_align align,
        int format_only)
{
  option_value *opt; // eax
  int number; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // edi
  int v14; // ecx

  opt = get_opt_(config_options, "ui.dialogs.listbox_min_height");
  number = max_height - 3;
  if ( opt->number <= max_height - 3 )
  {
    number = 7 * max_height / 10 - 3;
    if ( number < opt->number )
      number = opt->number;
  }
  v11 = 0;
  v12 = *y;
  v13 = x;
  if ( x < 0 )
    v13 = 0;
  if ( v12 < 0 )
    v12 = 0;
  widget_data->box.x = v13;
  widget_data->box.y = v12;
  v14 = w;
  if ( w < 0 )
    v14 = 0;
  if ( number >= 0 )
    v11 = number;
  widget_data->box.width = v14;
  widget_data->box.height = v11;
  *y += number;
  if ( rw )
    *rw = w;
}

//----- (08062120) --------------------------------------------------------
int __usercall listbox_item_offset@<eax>(listbox_data *box@<eax>, listbox_item *item@<edx>)
{
  unsigned int i; // ecx
  listbox_context ctx; // [esp+24h] [ebp-24h] BYREF

  for ( i = 0; i < 0x1C; i += 4 )
    *(terminal **)((char *)&ctx.term + i) = 0;
  ctx.item = item;
  ctx.offset = 0;
  traverse_listbox_items_list((listbox_item *)box->items->next, box, 0, 1, test_search, &ctx);
  return ctx.offset;
}

//----- (08062180) --------------------------------------------------------
void __cdecl listbox_sel(widget_data *widget_data, listbox_item *item)
{
  listbox_data *listbox_widget_data; // ebx
  int v3; // edi
  listbox_item *itema; // [esp+34h] [ebp+Ch]

  listbox_widget_data = get_listbox_widget_data(widget_data);
  v3 = listbox_item_offset(listbox_widget_data, item);
  itema = (listbox_item *)(v3 - listbox_item_offset(listbox_widget_data, listbox_widget_data->sel));
  listbox_sel_move(widget_data, (int)itema);
}

//----- (080621D0) --------------------------------------------------------
widget_handler_status_T __cdecl display_listbox(dialog_data *dlg_data, widget_data *widget_data)
{
  terminal *term; // esi
  color_pair *bfu_color; // eax
  unsigned int i; // eax
  listbox_data *box; // [esp+2Ch] [ebp-3Ch]
  listbox_context data; // [esp+34h] [ebp-34h] BYREF

  term = dlg_data->win->term;
  box = get_listbox_widget_data(widget_data);
  listbox_sel_move(widget_data, 0);
  bfu_color = get_bfu_color(term, "menu.normal");
  draw_box(term, &widget_data->box, 0x20u, (screen_char_attr)0, bfu_color);
  for ( i = 0; i < 0x1C; i += 4 )
    *(terminal **)((char *)&data.term + i) = 0;
  data.term = term;
  data.widget_data = widget_data;
  data.dlg_data = dlg_data;
  data.box = box;
  traverse_listbox_items_list(box->top, box, widget_data->box.height, 1, display_listbox_item, &data);
  return 0;
}

//----- (080622A0) --------------------------------------------------------
_BOOL4 __usercall menu_contains@<eax>(menu_item *m@<eax>, int f@<edx>)
{
  menu_item *data; // ebx

  if ( m->func != do_select_submenu )
    return m->data == (void *)f;
  data = (menu_item *)m->data;
  if ( !data->text )
    return 0;
  while ( !menu_contains(data, f) )
  {
    ++data;
    if ( !data->text )
      return 0;
  }
  return 1;
}

//----- (08062300) --------------------------------------------------------
void __cdecl menu_labels(menu_item *items, unsigned __int8 *base, unsigned __int8 **lbls)
{
  menu_item *i; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // eax
  void (__cdecl *func)(terminal *, void *, void *); // edx
  unsigned __int8 *bs; // [esp+1Ch] [ebp-1Ch] BYREF

  for ( i = items; i->text; ++i )
  {
    v4 = (unsigned __int8 *)&delete;
    if ( (i->flags & 0x10) == 0 )
      v4 = base;
    bs = v4;
    v5 = straconcat(v4, i->text, 0);
    bs = v5;
    if ( v5 )
    {
      func = i->func;
      if ( func == do_select_submenu )
      {
        add_to_strn(&bs, &start);
        menu_labels((menu_item *)i->data, bs, lbls);
        mem_free(bs);
      }
      else
      {
        if ( !assert_failed )
        {
          assert_failed = func != selected_item;
          if ( func != selected_item )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
            errline = 188;
            elinks_internal("assertion item->func == selected_item failed!");
            v5 = bs;
          }
        }
        lbls[(int)i->data] = v5;
      }
    }
  }
}

//----- (08062400) --------------------------------------------------------
menu_item *__cdecl detach_menu(list_menu *menu)
{
  menu_item *v1; // ebx

  v1 = 0;
  if ( menu->stack )
  {
    if ( menu->stack_size )
      v1 = *menu->stack;
    mem_free(menu->stack);
  }
  return v1;
}

//----- (08062440) --------------------------------------------------------
void __cdecl free_menu(menu_item *m)
{
  unsigned __int8 *text; // eax
  menu_item *v2; // ebx

  if ( m )
  {
    text = m->text;
    if ( m->text )
    {
      v2 = m;
      do
      {
        mem_free(text);
        if ( v2->func == do_select_submenu )
          free_menu((menu_item *)v2->data);
        ++v2;
        text = v2->text;
      }
      while ( v2->text );
    }
    mem_free(m);
  }
}

//----- (080624A0) --------------------------------------------------------
void __cdecl destroy_menu(list_menu *menu)
{
  if ( menu->stack )
    free_menu(*menu->stack);
  detach_menu(menu);
}

//----- (080624D0) --------------------------------------------------------
void __cdecl new_menu_item(list_menu *menu, unsigned __int8 *name, int data, int fullname)
{
  unsigned __int8 *v4; // ebx
  unsigned int stack_size; // esi
  int v6; // edx
  menu_item **v7; // ecx
  menu_item *i; // eax
  menu_item **v9; // eax
  menu_item *v10; // eax
  int v11; // edx
  unsigned __int8 *v12; // eax
  void (*v13)(terminal *, void *, void *); // [esp+10h] [ebp-38h]
  menu_item *v14; // [esp+14h] [ebp-34h]
  int v15; // [esp+18h] [ebp-30h]
  void **v16; // [esp+28h] [ebp-20h]

  v4 = name;
  stack_size = menu->stack_size;
  if ( !name )
  {
    menu->stack_size = stack_size - 1;
    return;
  }
  if ( data != -1 && !stack_size )
    goto LABEL_15;
  clr_spaces(name);
  v6 = data;
  if ( !*name )
  {
    mem_free(name);
    v12 = stracpy(&start);
    v6 = data;
    v4 = v12;
    if ( !v12 )
      return;
  }
  if ( v6 != -1 )
  {
    v7 = &menu->stack[stack_size - 1];
    v14 = (menu_item *)v6;
    v13 = selected_item;
    v15 = fullname != 0 ? 0x10 : 0;
    goto LABEL_7;
  }
  v9 = (menu_item **)mem_realloc(menu->stack, 4 * menu->stack_size + 4);
  if ( !v9
    || (menu->stack = v9, (v10 = new_menu(NO_INTL)) == 0)
    || (v11 = menu->stack_size, menu->stack[v11] = v10, ++v11, menu->stack_size = v11, v11 == 1) )
  {
LABEL_15:
    mem_free(v4);
    return;
  }
  v7 = &menu->stack[stack_size - 1];
  v15 = 32;
  v14 = v10;
  v13 = do_select_submenu;
LABEL_7:
  v16 = (void **)v7;
  add_to_menu(v7, v4, 0, ACT_MAIN_NONE, v13, v14, (menu_item_flags)v15);
  if ( stack_size > 1 )
  {
    for ( i = menu->stack[stack_size - 2]; i->text; ++i )
      ;
    i[-1].data = *v16;
  }
}

//----- (08062640) --------------------------------------------------------
void __cdecl add_select_item(
        list_menu *menu,
        string *string,
        string *orig_string,
        unsigned __int8 **value,
        int order,
        int dont_add)
{
  unsigned __int8 **v6; // eax
  unsigned int v7; // esi
  unsigned __int8 **v8; // edx
  unsigned __int8 **v9; // [esp+14h] [ebp-24h]

  v6 = value;
  if ( !assert_failed && (assert_failed = string == 0 || menu == 0) != 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
    errline = 201;
    elinks_internal("assertion menu && string failed!");
    v6 = value;
    if ( !string->source )
      return;
  }
  else if ( !string->source )
  {
    return;
  }
  v7 = order - 1;
  if ( !assert_failed )
  {
    assert_failed = (v6 == 0) | (v7 >> 31);
    if ( assert_failed )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/listmenu.c";
      errline = 205;
      v9 = v6;
      elinks_internal("assertion value && pos >= 0 failed!");
      v6 = v9;
    }
  }
  v8 = &v6[v7];
  if ( !*v8 )
    *v8 = memacpy(orig_string->source, orig_string->length);
  if ( dont_add )
  {
    done_string(string);
  }
  else
  {
    new_menu_item(menu, string->source, v7, 1);
    string->source = 0;
    string->length = 0;
  }
  done_string(orig_string);
}

//----- (080627C0) --------------------------------------------------------
void __cdecl init_menu(list_menu *menu)
{
  unsigned __int8 *v1; // eax

  menu->stack_size = 0;
  menu->stack = 0;
  v1 = stracpy((const unsigned __int8 *)&delete);
  new_menu_item(menu, v1, -1, 0);
}

//----- (08062810) --------------------------------------------------------
void __cdecl do_select_submenu(terminal *term, void *menu_, void *ses_)
{
  int v3; // esi
  int current_state; // eax
  menu_item *v5; // ebx
  int v6; // ebx

  v3 = 0;
  current_state = get_current_state((session *)ses_);
  if ( current_state >= 0 )
    v3 = current_state;
  if ( *(_DWORD *)menu_ )
  {
    v5 = (menu_item *)menu_;
    while ( !menu_contains(v5, v3) )
    {
      ++v5;
      if ( !v5->text )
        goto LABEL_8;
    }
    v6 = ((char *)v5 - (_BYTE *)menu_) >> 5;
  }
  else
  {
LABEL_8:
    v6 = 0;
  }
  do_menu_selected(term, (menu_item *)menu_, ses_, v6, 0);
}

//----- (08062890) --------------------------------------------------------
void __cdecl deselect_mainmenu(terminal *term, menu *menu)
{
  window *win; // ecx

  win = menu->win;
  menu->selected = -1;
  win->next->prev = win->prev;
  menu->win->prev->next = menu->win->next;
  menu->win->next = *(window **)term->windows.prev;
  menu->win->prev = (window *)term->windows.prev;
  *(_DWORD *)term->windows.prev = menu->win;
  menu->win->next->prev = menu->win;
}

//----- (080628E0) --------------------------------------------------------
void __usercall set_menu_selection(menu *menu@<eax>, int pos@<edx>)
{
  int height; // ecx
  int v3; // esi
  int first; // edi
  int v5; // ecx
  int v6; // ebx
  int size; // edx
  int v8; // edx
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+18h] [ebp-20h]
  menu *v11; // [esp+1Ch] [ebp-1Ch]
  menu *v12; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_16;
  if ( pos < 0 || pos >= menu->size )
  {
    v12 = menu;
    v10 = pos;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
    errline = 351;
    elinks_internal("assertion pos >= 0 && pos < menu->size failed!");
    menu = v12;
    pos = v10;
    if ( assert_failed )
    {
LABEL_16:
      assert_failed = 0;
      return;
    }
  }
  else
  {
    assert_failed = 0;
  }
  assert_failed = ((unsigned int)menu->items[pos].flags >> 7) & 1;
  if ( assert_failed )
  {
    v11 = menu;
    v9 = pos;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
    errline = 352;
    elinks_internal("assertion mi_is_selectable(&menu->items[pos]) failed!");
    pos = v9;
    menu = v11;
    if ( assert_failed )
      goto LABEL_16;
  }
  height = menu->box.height;
  menu->selected = pos;
  v3 = height - 2;
  if ( height - 2 > 0 && height != 3 )
  {
    first = menu->first;
    v5 = (height - 3) >> 1;
    if ( v5 >= 2 )
      v5 = 2;
    v6 = v5 + pos - v3 + 1;
    if ( v6 > first || (v6 = pos - v5, pos - v5 < first) )
    {
      size = menu->size;
      menu->first = v6;
      if ( v6 >= 0 )
      {
LABEL_13:
        v8 = size - v3;
        if ( v8 < v6 )
          menu->first = v8;
        return;
      }
    }
    else
    {
      v6 = menu->first;
      size = menu->size;
      if ( first >= 0 )
        goto LABEL_13;
    }
    menu->first = 0;
  }
}

//----- (08062A60) --------------------------------------------------------
void __usercall scroll_menu(menu *menu@<eax>, int steps@<edx>, int wrap@<ecx>)
{
  int v3; // esi
  int v4; // ebx
  bool v5; // zf
  int size; // ecx
  int selected; // eax
  int v8; // edx
  int v9; // eax
  menu_item *items; // [esp+3Ch] [ebp-2Ch]
  int v12; // [esp+44h] [ebp-24h]

  v3 = steps;
  v4 = 1;
  if ( steps )
    v4 = steps / (int)abs32(steps);
  if ( assert_failed
    || (v5 = menu->selected >= -1, assert_failed = menu->selected < -1, !v5)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c",
        errline = 286,
        elinks_internal("assertion menu->selected >= -1 failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    size = menu->size;
    if ( size <= 0 )
      goto no_item;
    selected = menu->selected;
    v8 = selected;
    if ( !v3 )
    {
      LOWORD(v3) = 1;
      if ( selected >= 0 )
        v8 = selected - 1;
    }
    v12 = v3 - v4;
    items = menu->items;
LABEL_8:
    v8 += v4;
    while ( v8 != selected )
    {
      if ( v8 >= size && v4 == 1 )
      {
        if ( !wrap )
        {
          v8 = size - 1;
          v9 = size - 1;
          goto select_item;
        }
        v8 = 0;
      }
      else if ( v8 < 0 && v4 == -1 )
      {
        if ( !wrap )
        {
          v9 = 0;
          v8 = 0;
          goto select_item;
        }
        v8 = size - 1;
      }
      else
      {
        if ( SLOBYTE(items[v8].flags) >= 0 )
        {
          v12 -= v4;
          if ( v4 + v12 )
            goto LABEL_8;
          goto LABEL_25;
        }
        v8 += v4;
      }
      if ( selected == -1 )
        selected = 0;
    }
    v9 = v8;
select_item:
    if ( SLOBYTE(items[v9].flags) >= 0 )
    {
LABEL_25:
      set_menu_selection(menu, v8);
    }
    else
    {
no_item:
      menu->selected = -1;
      menu->first = 0;
    }
  }
}

//----- (08062C30) --------------------------------------------------------
unsigned __int8 *__usercall _@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (08062CA0) --------------------------------------------------------
void __usercall select_menu_item(terminal *term@<eax>, menu_item *it@<edx>, void *data@<ecx>)
{
  menu_func_T func; // edi
  menu_item_flags flags; // eax
  list_head_elinks *p_windows; // esi
  window *next; // eax
  void (__cdecl *handler)(window *, term_event *); // edx
  _DWORD **v9; // eax
  _DWORD *v10; // edx
  main_action action_id; // [esp+14h] [ebp-24h]
  void *it_data; // [esp+18h] [ebp-20h]

  func = it->func;
  it_data = it->data;
  action_id = it->action_id;
  flags = it->flags;
  if ( (flags & 0x80u) == 0 )
  {
    if ( (flags & 0x20) == 0 )
    {
      it->flags = flags & 0xFFFFFFF7;
      p_windows = &term->windows;
      while ( 1 )
      {
        next = (window *)term->windows.next;
        if ( next == (window *)p_windows )
          break;
        while ( 1 )
        {
          handler = next->handler;
          if ( handler == menu_handler )
            break;
          if ( handler == mainmenu_handler )
          {
            v9 = (_DWORD **)next->data;
            v10 = *v9;
            v9[3] = (_DWORD *)-1;
            *(_DWORD *)(*v10 + 4) = v10[1];
            *(_DWORD *)(*v9)[1] = **v9;
            **v9 = *(_DWORD *)term->windows.prev;
            (*v9)[1] = term->windows.prev;
            *(_DWORD *)term->windows.prev = *v9;
            *(_DWORD *)(**v9 + 4) = *v9;
            redraw_terminal(term);
            next = (window *)term->windows.next;
            if ( next != (window *)p_windows )
              continue;
          }
          goto LABEL_8;
        }
        delete_window(next);
      }
    }
LABEL_8:
    if ( func || action_id == ACT_MAIN_NONE )
    {
      if ( assert_failed
        || (assert_failed = func == 0, !func)
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c",
            errline = 174,
            elinks_internal("assertion func != NULL failed: No menu function"),
            assert_failed) )
      {
        assert_failed = 0;
      }
      else
      {
        func(term, it_data, data);
      }
    }
    else
    {
      do_action((session *)data, action_id, 1);
    }
  }
}

//----- (08062E10) --------------------------------------------------------
void __usercall free_menu_items(menu_item *items@<eax>)
{
  menu_item_flags flags; // edx
  unsigned __int8 *text; // ecx
  menu_item *i; // ebx

  if ( items )
  {
    flags = items->flags;
    if ( (flags & 0xF) != 0 )
    {
      text = items->text;
      if ( items->text )
      {
        for ( i = items; ; flags = i->flags )
        {
          if ( (flags & 2) != 0 )
          {
            mem_free(text);
            flags = i->flags;
          }
          if ( (flags & 4) != 0 && i->rtext )
          {
            mem_free(i->rtext);
            flags = i->flags;
          }
          if ( (flags & 8) != 0 )
          {
            if ( i->data )
              mem_free(i->data);
          }
          ++i;
          text = i->text;
          if ( !i->text )
            break;
        }
      }
      mem_free(items);
    }
  }
}

//----- (08062E90) --------------------------------------------------------
void __cdecl do_menu_selected(terminal *term, menu_item *items, void *data, int selected, int hotkeys)
{
  menu_item *v5; // ebx
  menu *v6; // eax
  int v7; // edx
  menu *v8; // [esp+14h] [ebp-24h]

  v5 = items;
  v6 = (menu *)mem_calloc(1u, 0x3Cu);
  if ( v6 )
  {
    v6->items = items;
    v6->data = data;
    v6->selected = selected;
    if ( items && items->text )
    {
      v7 = 0;
      do
      {
        ++v5;
        ++v7;
      }
      while ( v5->text );
    }
    else
    {
      v7 = 0;
    }
    v6->size = v7;
    v6->lang = -1;
    v6->hotkeys = hotkeys;
    v8 = v6;
    refresh_hotkeys(term, v6);
    add_window(term, menu_handler, v8);
  }
  else
  {
    free_menu_items(items);
  }
}

//----- (08062F40) --------------------------------------------------------
void __cdecl do_menu(terminal *term, menu_item *items, void *data, int hotkeys)
{
  do_menu_selected(term, items, data, 0, hotkeys);
}

//----- (08062F70) --------------------------------------------------------
void __cdecl add_to_menu(
        menu_item **mi,
        unsigned __int8 *text,
        unsigned __int8 *rtext,
        main_action action_id,
        menu_func_T func,
        void *data,
        menu_item_flags flags)
{
  menu_item *v7; // ecx
  menu_item *v8; // eax
  int v9; // ebx
  unsigned int v10; // edx
  unsigned int v11; // esi
  menu_item *v12; // ebx
  menu_item *v13; // eax
  int v14; // [esp+1Ch] [ebp-1Ch]

  v7 = *mi;
  v8 = *mi;
  if ( *mi )
  {
    if ( v7->text )
    {
      v9 = 0;
      do
      {
        ++v8;
        ++v9;
      }
      while ( v8->text );
      v10 = (v9 + 18) & 0xFFFFFFF0;
      v11 = (v9 + 16) & 0xFFFFFFF0;
      if ( v10 > v11 )
      {
        v14 = 32 * v10;
        v13 = (menu_item *)mem_realloc(v7, 32 * v10);
        if ( !v13 )
          return;
        *mi = v13;
        memset(&v13[v11], 0, v14 - 32 * v11);
        v7 = *mi;
      }
    }
    else
    {
      v9 = 0;
    }
    if ( v7 )
    {
      v12 = &v7[v9];
      v12[1].text = v12->text;
      v12[1].rtext = v12->rtext;
      v12[1].action_id = v12->action_id;
      v12[1].func = v12->func;
      v12[1].data = v12->data;
      v12[1].flags = v12->flags;
      v12[1].hotkey_state = v12->hotkey_state;
      v12[1].hotkey_pos = v12->hotkey_pos;
      v12->text = text;
      v12->rtext = rtext;
      v12->action_id = action_id;
      v12->func = func;
      v12->data = data;
      v12->flags |= flags;
      v12->hotkey_state = HKS_SHOW;
      v12->hotkey_pos = 0;
    }
  }
}

//----- (08063070) --------------------------------------------------------
menu_item *__cdecl new_menu(menu_item_flags flags)
{
  _WORD *v1; // eax
  _WORD *v2; // edi
  unsigned int v3; // edx
  _WORD *v4; // edi
  menu_item *mi; // [esp+1Ch] [ebp-Ch]

  mi = 0;
  v1 = mem_realloc(0, 0x200u);
  if ( v1 )
  {
    v2 = v1;
    mi = (menu_item *)v1;
    v3 = 512;
    if ( ((unsigned __int8)v1 & 1) != 0 )
    {
      *(_BYTE *)v1 = 0;
      v2 = (_WORD *)((char *)v1 + 1);
      LOWORD(v3) = 511;
    }
    if ( ((unsigned __int8)v2 & 2) != 0 )
    {
      *v2 = 0;
      v3 -= 2;
      ++v2;
    }
    memset(v2, 0, 4 * (v3 >> 2));
    v4 = &v2[2 * (v3 >> 2)];
    if ( (v3 & 2) != 0 )
      *v4++ = 0;
    if ( (v3 & 1) != 0 )
      *(_BYTE *)v4 = 0;
    *((_DWORD *)v1 + 5) = flags;
  }
  return mi;
}
// 80630CF: conditional instruction was optimized away because %mi.4!=0

//----- (08063100) --------------------------------------------------------
void __usercall display_menu(terminal *term@<eax>, menu *menu@<edx>)
{
  int v3; // eax
  int height; // edi
  int width; // esi
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  int v9; // edi
  int first; // esi
  menu_item *v11; // edi
  menu_item_flags flags; // ecx
  const unsigned __int8 *text; // edx
  bool v14; // cc
  color_pair *v15; // eax
  unsigned __int8 v16; // cl
  int v17; // edi
  int v18; // esi
  _BOOL4 v19; // eax
  int v20; // ebx
  unsigned __int8 *rtext; // edi
  int v22; // edx
  int v23; // eax
  size_t v24; // eax
  unsigned __int8 *v25; // edx
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  unsigned __int8 *source; // edx
  int v30; // edi
  int v31; // eax
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  int v34; // eax
  int v35; // edi
  _BOOL4 v36; // esi
  int v37; // ebx
  unicode_val_T v38; // eax
  int v39; // eax
  int v40; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  color_pair *bfu_color; // eax
  int v44; // eax
  unicode_val_T v45; // [esp+Ch] [ebp-BCh]
  screen_char_attr v46; // [esp+10h] [ebp-B8h]
  color_pair *v47; // [esp+14h] [ebp-B4h]
  int v48; // [esp+2Ch] [ebp-9Ch]
  int v49; // [esp+38h] [ebp-90h]
  __int16 v50; // [esp+38h] [ebp-90h]
  int v51; // [esp+38h] [ebp-90h]
  int v52; // [esp+38h] [ebp-90h]
  unsigned __int8 *data; // [esp+3Ch] [ebp-8Ch]
  unicode_val_T dataa; // [esp+3Ch] [ebp-8Ch]
  unsigned __int8 *datab; // [esp+3Ch] [ebp-8Ch]
  unicode_val_T datac; // [esp+3Ch] [ebp-8Ch]
  unicode_val_T datad; // [esp+3Ch] [ebp-8Ch]
  unicode_val_T datae; // [esp+3Ch] [ebp-8Ch]
  unicode_val_T datag; // [esp+3Ch] [ebp-8Ch]
  unsigned __int8 *dataf; // [esp+3Ch] [ebp-8Ch]
  int v61; // [esp+40h] [ebp-88h]
  menu_item *v62; // [esp+44h] [ebp-84h]
  menu *v63; // [esp+48h] [ebp-80h]
  menu_item *v64; // [esp+4Ch] [ebp-7Ch]
  unsigned __int8 *v65; // [esp+4Ch] [ebp-7Ch]
  color_pair *frame_color; // [esp+50h] [ebp-78h]
  int v67; // [esp+54h] [ebp-74h]
  int v68; // [esp+54h] [ebp-74h]
  color_pair *selected_color; // [esp+58h] [ebp-70h]
  color_pair *v70; // [esp+5Ch] [ebp-6Ch]
  color_pair *v71; // [esp+5Ch] [ebp-6Ch]
  int x; // [esp+60h] [ebp-68h]
  menu *xa; // [esp+60h] [ebp-68h]
  unsigned __int8 *end; // [esp+64h] [ebp-64h]
  unsigned __int8 *enda; // [esp+64h] [ebp-64h]
  int menu_height; // [esp+68h] [ebp-60h]
  color_pair *normal_color; // [esp+6Ch] [ebp-5Ch]
  unsigned __int8 *l; // [esp+70h] [ebp-58h]
  int la; // [esp+70h] [ebp-58h]
  screen_char_attr attr; // [esp+74h] [ebp-54h]
  screen_char_attr attra; // [esp+74h] [ebp-54h]
  int y; // [esp+78h] [ebp-50h]
  int ya; // [esp+78h] [ebp-50h]
  color_pair *color; // [esp+7Ch] [ebp-4Ch]
  int length; // [esp+80h] [ebp-48h]
  int lengthc; // [esp+80h] [ebp-48h]
  int lengtha; // [esp+80h] [ebp-48h]
  int lengthb; // [esp+80h] [ebp-48h]
  int v89; // [esp+84h] [ebp-44h]
  int selected; // [esp+8Ch] [ebp-3Ch]
  int selecteda; // [esp+8Ch] [ebp-3Ch]
  int selectedb; // [esp+8Ch] [ebp-3Ch]
  int selectedc; // [esp+8Ch] [ebp-3Ch]
  int selectedd; // [esp+8Ch] [ebp-3Ch]
  box box; // [esp+94h] [ebp-34h] BYREF
  string keystroke; // [esp+A4h] [ebp-24h] BYREF
  unsigned __int8 *string; // [esp+ACh] [ebp-1Ch] BYREF

  normal_color = get_bfu_color(term, "menu.normal");
  selected_color = get_bfu_color(term, "menu.selected");
  frame_color = get_bfu_color(term, "menu.frame");
  v3 = 0;
  height = menu->box.height;
  width = menu->box.width;
  v6 = menu->box.x + 1;
  if ( v6 < 0 )
    v6 = 0;
  v7 = menu->box.y + 1;
  if ( v7 < 0 )
    v7 = 0;
  box.y = v7;
  v8 = width - 2;
  if ( v8 < 0 )
    v8 = 0;
  if ( height - 2 >= 0 )
    v3 = height - 2;
  box.x = v6;
  box.height = v3;
  box.width = v8;
  draw_box(term, &box, 0x20u, (screen_char_attr)0, normal_color);
  draw_border(term, &box, frame_color, 1);
  if ( get_opt_(config_options, "ui.dialogs.shadows")->number )
  {
    bfu_color = get_bfu_color(term, "dialog.shadow");
    draw_shadow(term, &menu->box, bfu_color, 2, 1);
    if ( (*((_BYTE *)term + 56) & 2) != 0 )
      fix_dwchar_around_box(term, &box, 1, 2, 1);
  }
  else if ( (*((_BYTE *)term + 56) & 2) != 0 )
  {
    fix_dwchar_around_box(term, &box, 1, 0, 0);
  }
  v9 = box.height;
  box.height = 1;
  menu_height = v9;
  first = menu->first;
  if ( first < menu->size && first < first + v9 )
  {
    v89 = first;
    while ( 1 )
    {
      v11 = &menu->items[v89];
      selected = menu->selected == first;
      color = normal_color;
      if ( menu->selected == first )
      {
        set_cursor(term, box.x, box.y, 1);
        menu->win->x = menu->box.x + menu->box.width;
        menu->win->y = box.y;
        draw_box(term, &box, 0x20u, (screen_char_attr)0, selected_color);
        color = selected_color;
      }
      flags = v11->flags;
      length = flags & 0x80;
      if ( (flags & 0x80) != 0 )
        break;
      text = v11->text;
      if ( !v11->text )
        goto LABEL_37;
      if ( *text )
        goto LABEL_20;
      if ( (flags & 0x20) != 0 )
        goto LABEL_54;
LABEL_38:
      if ( v11->action_id )
      {
        if ( init_string(&keystroke) )
        {
          add_keystroke_action_to_string(&keystroke, v11->action_id, KEYMAP_MAIN);
          v27 = box.y;
          v28 = keystroke.length;
          source = keystroke.source;
          selectedc = menu->box.x;
          v30 = box.width - 2;
          if ( box.width - 2 > 0 )
          {
            if ( keystroke.length < 0 )
            {
              dataf = keystroke.source;
              v52 = box.y;
              v28 = strlen((const char *)keystroke.source);
              v27 = v52;
              source = dataf;
            }
            if ( v28 )
            {
              if ( v28 > v30 )
                v28 = v30;
              draw_text(term, selectedc + v30 + 2 - v28, v27, source, v28, (screen_char_attr)0, color);
            }
          }
          done_string(&keystroke);
          v22 = box.y;
          goto LABEL_48;
        }
LABEL_47:
        v22 = box.y;
        goto LABEL_48;
      }
      rtext = v11->rtext;
      if ( !rtext || !*rtext )
        goto LABEL_47;
      if ( (BYTE1(flags) & 1) == 0 )
        goto LABEL_42;
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        if ( terminal_codepage != current_charset )
        {
          datag = terminal_codepage;
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = datag;
        }
      }
      rtext = gettext(rtext);
      if ( *rtext )
      {
LABEL_42:
        v22 = box.y;
        selecteda = menu->box.x;
        if ( box.width - 2 <= 0 )
          goto LABEL_48;
        dataa = box.y;
        v49 = box.width - 2;
        v23 = strlen((const char *)rtext);
        v22 = dataa;
        if ( !v23 )
          goto LABEL_48;
        if ( v23 > v49 )
          v23 = v49;
        draw_text(term, v49 + selecteda + 2 - v23, dataa, rtext, v23, (screen_char_attr)0, color);
        goto LABEL_47;
      }
      v22 = box.y;
LABEL_48:
      ++first;
      box.y = v22 + 1;
      if ( menu->size > first )
      {
        ++v89;
        if ( menu->first + menu_height > first )
          continue;
      }
      goto LABEL_50;
    }
    text = v11->text;
    if ( !v11->text )
      goto LABEL_37;
    if ( !*text )
    {
      draw_border_char(term, menu->box.x, box.y, BORDER_SRTEE, frame_color);
      draw_box(term, &box, 0xC4u, SCREEN_ATTR_FRAME, frame_color);
      draw_border_char(term, box.x + box.width, box.y, BORDER_SLTEE, frame_color);
      v22 = box.y;
      goto LABEL_48;
    }
LABEL_20:
    l = (unsigned __int8 *)v11->hotkey_pos;
    if ( (flags & 0x40) == 0 )
    {
      if ( term )
      {
        datac = (unicode_val_T)text;
        v31 = get_terminal_codepage(term);
        text = (const unsigned __int8 *)datac;
        if ( v31 != current_charset )
        {
          v51 = v31;
          v32 = get_cp_mime_name(v31);
          bind_textdomain_codeset("elinks", v32);
          text = (const unsigned __int8 *)datac;
          current_charset = v51;
        }
      }
      v33 = gettext(text);
      flags = v11->flags;
      text = v33;
      length = flags & 0x80;
    }
    if ( !length && l )
    {
      data = (unsigned __int8 *)text;
      lengthc = box.width;
      y = box.y;
      x = box.x;
      v70 = get_bfu_color(term, "menu.hotkey.normal");
      end = (unsigned __int8 *)get_bfu_color(term, "menu.hotkey.selected");
      v14 = lengthc - 2 <= 0;
      attr = get_opt_(config_options, "ui.dialogs.underline_hotkeys")->number != 0 ? SCREEN_ATTR_UNDERLINE : 0;
      lengtha = lengthc - 2;
      if ( v14 )
        goto LABEL_62;
      v15 = (color_pair *)end;
      if ( !selected )
        v15 = v70;
      v71 = v15;
      v67 = x + 1;
      if ( (*((_BYTE *)term + 56) & 2) == 0 )
      {
        v16 = *data;
        if ( *data )
        {
          v64 = v11;
          v17 = 0;
          v68 = first;
          v18 = x;
          la = (int)(l - 1);
          v19 = 0;
          xa = menu;
          v20 = 0;
          while ( v17 )
          {
            if ( v17 != 1 )
              goto LABEL_30;
            ++v20;
            v17 = 2;
            draw_char(term, v18, y, v16, attr, v71);
            v19 = 1;
            if ( lengtha <= v20 - 1 )
            {
LABEL_36:
              v11 = v64;
              first = v68;
              menu = xa;
              flags = v64->flags;
              goto LABEL_37;
            }
LABEL_32:
            ++v18;
            v16 = data[v20];
            if ( !v16 )
              goto LABEL_36;
          }
          if ( la == v20 )
          {
            v19 = 1;
            LOWORD(v17) = 1;
          }
          else
          {
LABEL_30:
            draw_char(term, v18 + 1 - v19, y, v16, (screen_char_attr)0, color);
            v19 = v17 != 0;
          }
          if ( lengtha <= ++v20 - v19 )
            goto LABEL_36;
          goto LABEL_32;
        }
LABEL_62:
        flags = v11->flags;
        goto LABEL_37;
      }
      v34 = __rawmemchr(data, 0);
      string = data;
      enda = (unsigned __int8 *)v34;
      if ( !*data )
        goto LABEL_62;
      v62 = v11;
      v35 = 0;
      v61 = first;
      v36 = 0;
      v63 = menu;
      v37 = 0;
      selectedd = 0;
      v65 = data;
      while ( 2 )
      {
        v38 = utf8_to_unicode(&string, enda);
        if ( v35 )
        {
          if ( v35 == 1 )
          {
            datae = v38;
            if ( unicode_to_cell(v38) != 2 )
            {
              v45 = datae;
              v47 = v71;
              v46 = attr;
              goto LABEL_94;
            }
            if ( v37 >= lengtha || (v39 = v37 + v67, v37 + v67 >= term->width) )
            {
              v46 = 0;
              v45 = 32;
              v47 = v71;
LABEL_94:
              v36 = 1;
              v35 = 2;
              v40 = v37 + x;
              ++v37;
              draw_char(term, v40, y, v45, v46, v47);
              selectedd = v37 - 1;
              if ( lengtha <= v37 - 1 )
              {
LABEL_95:
                v11 = v62;
                first = v61;
                menu = v63;
                flags = v62->flags;
                goto LABEL_37;
              }
LABEL_87:
              if ( !*string )
                goto LABEL_95;
              continue;
            }
            ++v37;
            v36 = 1;
            draw_char(term, v39 - 1, y, datae, attr, v71);
            v35 = 2;
            draw_char(term, v37 + x, y, 0xFFFFFFFD, (screen_char_attr)0, v71);
LABEL_86:
            selectedd = ++v37 - v36;
            if ( lengtha <= v37 - v36 )
              goto LABEL_95;
            goto LABEL_87;
          }
        }
        else if ( l == (unsigned __int8 *)(string - v65) )
        {
          v36 = 1;
          LOWORD(v35) = 1;
          goto LABEL_86;
        }
        break;
      }
      datad = v38;
      if ( unicode_to_cell(v38) == 2 )
      {
        if ( lengtha <= selectedd + 1 )
        {
          v48 = v37 + v67 - v36;
        }
        else
        {
          v48 = v37 + v67 - v36;
          if ( v48 + 1 < term->width )
          {
            ++v37;
            draw_char(term, v48, y, datad, (screen_char_attr)0, color);
            draw_char(term, v37 - v36 + v67, y, 0xFFFFFFFD, (screen_char_attr)0, color);
            v36 = v35 != 0;
            goto LABEL_86;
          }
        }
        draw_char(term, v48, y, 0x20u, (screen_char_attr)0, color);
      }
      else
      {
        draw_char(term, v37 + v67 - v36, y, datad, (screen_char_attr)0, color);
      }
      v36 = v35 != 0;
      goto LABEL_86;
    }
    attra = box.y;
    ya = box.x;
    selectedb = box.width - 2;
    if ( box.width - 2 > 0 )
    {
      datab = (unsigned __int8 *)text;
      v50 = flags;
      v24 = strlen((const char *)text);
      v25 = datab;
      LOWORD(flags) = v50;
      lengthb = v24;
      if ( v24 )
      {
        if ( (*((_BYTE *)term + 56) & 2) == 0
          || (v44 = utf8_cells2bytes(datab, selectedb, 0), v25 = datab, selectedb = v44, v44 > 0) )
        {
          v26 = lengthb;
          if ( selectedb <= lengthb )
            v26 = selectedb;
          draw_text(term, ya + 1, attra, v25, v26, (screen_char_attr)0, color);
        }
        goto LABEL_62;
      }
    }
LABEL_37:
    if ( (flags & 0x20) != 0 )
    {
LABEL_54:
      v22 = box.y;
      if ( box.width - 2 > 0 )
      {
        draw_text(
          term,
          menu->box.x + box.width - ((box.width != 3) + 1),
          box.y,
          m_submenu,
          (box.width != 3) + 1,
          (screen_char_attr)0,
          color);
        v22 = box.y;
      }
      goto LABEL_48;
    }
    goto LABEL_38;
  }
LABEL_50:
  redraw_from_window(menu->win);
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (08063CC0) --------------------------------------------------------
void __usercall display_mainmenu(terminal *term@<eax>, menu *menu@<edx>)
{
  terminal *v2; // ebx
  int v3; // ecx
  int first; // edx
  int v5; // ecx
  int last; // eax
  int size; // ecx
  int v8; // ecx
  int width; // edx
  int v10; // eax
  menu_item *v11; // eax
  const char *v12; // edx
  _BOOL4 v13; // edi
  int v14; // esi
  color_pair *v15; // edi
  unsigned __int8 v16; // al
  int v17; // edi
  unsigned __int8 *v18; // edx
  int v19; // esi
  int v20; // ebx
  _BOOL4 v21; // edx
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // edx
  int v26; // eax
  int v27; // edx
  int terminal_codepage; // eax
  int v29; // esi
  unsigned __int8 *cp_mime_name; // eax
  int v31; // eax
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  _BOOL4 v35; // ebx
  int v36; // eax
  unicode_val_T v37; // eax
  int v38; // eax
  int v39; // eax
  unicode_val_T v40; // [esp+Ch] [ebp-ACh]
  color_pair *v41; // [esp+14h] [ebp-A4h]
  int v42; // [esp+2Ch] [ebp-8Ch]
  unicode_val_T data; // [esp+34h] [ebp-84h]
  unicode_val_T dataa; // [esp+34h] [ebp-84h]
  int v45; // [esp+38h] [ebp-80h]
  unsigned __int8 *end; // [esp+3Ch] [ebp-7Ch]
  color_pair *selected_color; // [esp+40h] [ebp-78h]
  int v48; // [esp+44h] [ebp-74h]
  color_pair *normal_color; // [esp+48h] [ebp-70h]
  terminal *v50; // [esp+4Ch] [ebp-6Ch]
  color_pair *bfu_color; // [esp+50h] [ebp-68h]
  color_pair *v52; // [esp+50h] [ebp-68h]
  int v53; // [esp+54h] [ebp-64h]
  int v54; // [esp+58h] [ebp-60h]
  int screencnt; // [esp+5Ch] [ebp-5Ch]
  screen_char_attr attr; // [esp+60h] [ebp-58h]
  color_pair *color; // [esp+64h] [ebp-54h]
  int i; // [esp+68h] [ebp-50h]
  unsigned __int8 *l; // [esp+70h] [ebp-48h]
  terminal *la; // [esp+70h] [ebp-48h]
  int selected; // [esp+74h] [ebp-44h]
  int selecteda; // [esp+74h] [ebp-44h]
  int selectedb; // [esp+74h] [ebp-44h]
  unsigned __int8 *text; // [esp+78h] [ebp-40h]
  int x; // [esp+7Ch] [ebp-3Ch]
  int xa; // [esp+7Ch] [ebp-3Ch]
  int xb; // [esp+7Ch] [ebp-3Ch]
  box box; // [esp+8Ch] [ebp-2Ch] BYREF
  unsigned __int8 *string; // [esp+9Ch] [ebp-1Ch] BYREF

  v2 = term;
  normal_color = get_bfu_color(term, "menu.normal");
  selected_color = get_bfu_color(v2, "menu.selected");
  v3 = menu->selected;
  first = menu->first;
  if ( v3 >= first )
  {
    last = menu->last;
    if ( v3 > last )
    {
      first -= last - v3;
      last = menu->selected;
      menu->first = first;
      menu->last = v3;
      if ( v3 > 0 )
        goto LABEL_4;
      goto LABEL_43;
    }
  }
  else
  {
    v5 = v3 - first;
    first += v5;
    menu->first = first;
    last = v5 + menu->last;
    menu->last = last;
  }
  if ( last > 0 )
  {
LABEL_4:
    size = menu->size;
    goto LABEL_5;
  }
LABEL_43:
  size = menu->size;
  last = size - 1;
  menu->last = size - 1;
  if ( size - 1 < 0 )
  {
    v8 = 0;
    menu->last = 0;
    if ( first >= 0 )
      goto LABEL_8;
    goto LABEL_45;
  }
LABEL_5:
  v8 = size - 1;
  if ( v8 < last )
    menu->last = v8;
  else
    v8 = last;
  if ( first >= 0 )
  {
LABEL_8:
    if ( first > v8 )
      menu->first = v8;
    goto LABEL_10;
  }
LABEL_45:
  menu->first = 0;
LABEL_10:
  width = v2->width;
  v10 = 0;
  box.x = 0;
  box.y = 0;
  box.height = 1;
  if ( width >= 0 )
    v10 = width;
  box.width = v10;
  draw_box(v2, &box, 0x20u, (screen_char_attr)0, normal_color);
  i = 0;
  if ( menu->first )
  {
    box.width = 2;
    draw_box(v2, &box, 0x3Cu, (screen_char_attr)0, normal_color);
    i = menu->first;
  }
  if ( i >= menu->size )
    goto LABEL_51;
  v54 = i;
  x = 2;
  while ( 2 )
  {
    v11 = &menu->items[v54];
    text = v11->text;
    l = (unsigned __int8 *)v11->hotkey_pos;
    selected = menu->selected == i;
    v12 = (const char *)v11->text;
    if ( (v11->flags & 0x40) == 0 )
    {
      v12 = 0;
      if ( text )
      {
        v12 = (const char *)v11->text;
        if ( *text )
        {
          terminal_codepage = get_terminal_codepage(v2);
          v29 = terminal_codepage;
          if ( terminal_codepage != current_charset )
          {
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            current_charset = v29;
          }
          text = gettext(text);
          v12 = (const char *)text;
        }
      }
    }
    v13 = l != 0;
    v14 = strlen(v12) - v13;
    screencnt = v14;
    if ( (*((_BYTE *)v2 + 56) & 2) != 0 )
      screencnt = utf8_ptr2cells(text, 0) - v13;
    color = normal_color;
    if ( selected )
    {
      box.x = x;
      if ( (*((_BYTE *)v2 + 56) & 2) != 0 )
        box.width = screencnt + 4;
      else
        box.width = v14 + 4;
      draw_box(v2, &box, 0x20u, (screen_char_attr)0, selected_color);
      set_cursor(v2, x, 0, 1);
      menu->win->x = x;
      menu->win->y = 1;
      color = selected_color;
    }
    v53 = x + 1;
    if ( !l )
    {
      if ( v14 <= 0 )
        goto LABEL_38;
      if ( (*((_BYTE *)v2 + 56) & 2) == 0 )
        goto LABEL_49;
      v23 = utf8_cells2bytes(text, v14, 0);
      if ( v23 <= 0 )
        goto LABEL_38;
      if ( v14 <= v23 )
LABEL_49:
        v23 = v14;
      draw_text(v2, x + 2, 0, text, v23, (screen_char_attr)0, color);
      v22 = v53 + screencnt;
      if ( v53 + screencnt < v2->width - 2 )
        goto LABEL_39;
      break;
    }
    bfu_color = get_bfu_color(v2, "menu.hotkey.normal");
    v15 = get_bfu_color(v2, "menu.hotkey.selected");
    attr = get_opt_(config_options, "ui.dialogs.underline_hotkeys")->number != 0 ? SCREEN_ATTR_UNDERLINE : 0;
    if ( v14 <= 0 )
      goto LABEL_38;
    if ( !selected )
      v15 = bfu_color;
    v52 = v15;
    v48 = x + 2;
    if ( (*((_BYTE *)v2 + 56) & 2) == 0 )
    {
      v16 = *text;
      if ( !*text )
        goto LABEL_38;
      v17 = 0;
      v18 = l;
      xa = v14;
      la = v2;
      v19 = v53;
      v20 = 0;
      selecteda = (int)(v18 - 1);
      v21 = 0;
      while ( v20 )
      {
        if ( v20 != 1 )
          goto LABEL_31;
        ++v17;
        LOBYTE(v20) = 2;
        draw_char(la, v19, 0, v16, attr, v52);
        v21 = 1;
        if ( xa <= v17 - 1 )
        {
LABEL_37:
          v2 = la;
          goto LABEL_38;
        }
LABEL_33:
        ++v19;
        v16 = text[v17];
        if ( !v16 )
          goto LABEL_37;
      }
      if ( selecteda == v17 )
      {
        v21 = 1;
        LOBYTE(v20) = 1;
      }
      else
      {
LABEL_31:
        draw_char(la, v19 + 1 - v21, 0, v16, (screen_char_attr)0, color);
        v21 = v20 != 0;
      }
      if ( xa <= ++v17 - v21 )
        goto LABEL_37;
      goto LABEL_33;
    }
    v31 = __rawmemchr(text, 0);
    string = text;
    end = (unsigned __int8 *)v31;
    if ( !*text )
      goto LABEL_38;
    v32 = x;
    xb = v14;
    v33 = 0;
    v34 = 0;
    v50 = v2;
    v35 = 0;
    selectedb = 0;
    v45 = v32 + 1;
    do
    {
      v37 = utf8_to_unicode(&string, end);
      if ( !v34 )
      {
        if ( l == (unsigned __int8 *)(string - text) )
        {
          v35 = 1;
          LOWORD(v34) = 1;
          goto LABEL_77;
        }
LABEL_72:
        data = v37;
        if ( unicode_to_cell(v37) == 2 )
        {
          if ( xb > selectedb + 1 )
          {
            v42 = v33 + v48 - v35;
            if ( v42 + 1 < v50->width )
            {
              ++v33;
              draw_char(v50, v42, 0, data, (screen_char_attr)0, color);
              draw_char(v50, v33 - v35 + v48, 0, 0xFFFFFFFD, (screen_char_attr)0, color);
              v35 = v34 != 0;
              goto LABEL_77;
            }
          }
          v36 = v33 + v48;
          v40 = 32;
          v41 = color;
        }
        else
        {
          v40 = data;
          v41 = color;
          v36 = v33 + v48;
        }
        draw_char(v50, v36 - v35, 0, v40, (screen_char_attr)0, v41);
        v35 = v34 != 0;
        goto LABEL_77;
      }
      if ( v34 != 1 )
        goto LABEL_72;
      dataa = v37;
      if ( unicode_to_cell(v37) != 2 )
      {
        v35 = 1;
        v34 = 2;
        draw_char(v50, v33 + v45, 0, dataa, attr, v52);
        goto LABEL_77;
      }
      if ( xb > v33 && v33 + v48 < v50->width )
      {
        v39 = v33 + v48 - 1;
        ++v33;
        v35 = 1;
        draw_char(v50, v39, 0, dataa, attr, v52);
        v34 = 2;
        draw_char(v50, v33 + v45, 0, 0xFFFFFFFD, (screen_char_attr)0, v52);
LABEL_77:
        selectedb = ++v33 - v35;
        if ( xb <= v33 - v35 )
          break;
        continue;
      }
      v35 = 1;
      v34 = 2;
      v38 = v33 + v45;
      ++v33;
      draw_char(v50, v38, 0, 0x20u, (screen_char_attr)0, v52);
      selectedb = v33 - 1;
      if ( xb <= v33 - 1 )
        break;
    }
    while ( *string );
    v2 = v50;
LABEL_38:
    v22 = v53 + screencnt;
    if ( v53 + screencnt < v2->width - 2 )
    {
LABEL_39:
      ++i;
      ++v54;
      if ( menu->size > i )
      {
        x = v22 + 3;
        continue;
      }
    }
    break;
  }
LABEL_51:
  v24 = menu->first;
  menu->last = i - 1;
  if ( i - 1 < v24 )
    menu->last = v24;
  else
    v24 = i - 1;
  if ( menu->size - 1 > v24 )
  {
    if ( (*((_BYTE *)v2 + 56) & 2) != 0 && get_char(v2, v2->width - 2, 0)->data == -3 )
      draw_char_data(v2, v2->width - 3, 0, 0x20u);
    v25 = v2->width;
    v26 = 0;
    box.y = 0;
    box.width = 2;
    v27 = v25 - 2;
    if ( v27 >= 0 )
      v26 = v27;
    box.x = v26;
    box.height = 1;
    draw_box(v2, &box, 0x3Eu, (screen_char_attr)0, normal_color);
  }
  redraw_from_window(menu->win);
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (08064640) --------------------------------------------------------
void __cdecl do_mainmenu(terminal *term, menu_item *items, void *data, int sel)
{
  int v4; // ecx
  menu_item *v5; // edx
  menu *main_menu; // esi
  int v7; // eax
  int v8; // eax
  terminal *next; // eax
  int selected; // edx
  window *win; // eax
  int v12; // [esp+18h] [ebp-20h]
  list_head_elinks *p_windows; // [esp+1Ch] [ebp-1Ch]

  v4 = 0;
  v5 = items;
  main_menu = term->main_menu;
  if ( !main_menu )
  {
    main_menu = (menu *)mem_calloc(1u, 0x3Cu);
    term->main_menu = main_menu;
    v5 = items;
    if ( !main_menu )
      return;
    v4 = 1;
  }
  v7 = 0;
  if ( sel != -1 )
    v7 = sel;
  main_menu->selected = v7;
  main_menu->items = v5;
  main_menu->data = data;
  if ( v5 && v5->text )
  {
    v8 = 0;
    do
    {
      ++v5;
      ++v8;
    }
    while ( v5->text );
  }
  else
  {
    v8 = 0;
  }
  main_menu->size = v8;
  main_menu->hotkeys = 1;
  v12 = v4;
  clear_hotkeys_cache(main_menu);
  init_hotkeys(term, main_menu);
  if ( v12 )
  {
    add_window(term, mainmenu_handler, main_menu);
    win = main_menu->win;
    if ( !assert_failed )
    {
      assert_failed = win == 0;
      if ( !win )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/menu.c";
        errline = 1044;
        elinks_internal("assertion win failed!");
      }
      win = main_menu->win;
    }
    main_menu->selected = -1;
    win->next->prev = win->prev;
    main_menu->win->prev->next = main_menu->win->next;
    main_menu->win->next = *(window **)term->windows.prev;
    main_menu->win->prev = (window *)term->windows.prev;
    *(_DWORD *)term->windows.prev = main_menu->win;
    main_menu->win->next->prev = main_menu->win;
  }
  else
  {
    next = (terminal *)term->windows.next;
    p_windows = &term->windows;
    if ( next != (terminal *)&term->windows )
    {
      if ( main_menu == (menu *)next->spec )
      {
LABEL_18:
        next->next->prev = next->prev;
        next->prev->next = next->next;
        next->next = (terminal *)term->windows.next;
        next->prev = (terminal *)p_windows;
        term->windows.next = next;
        next->next->prev = next;
        display_mainmenu(term, main_menu);
      }
      else
      {
        while ( 1 )
        {
          next = next->next;
          if ( next == (terminal *)p_windows )
            break;
          if ( (menu *)next->spec == main_menu )
            goto LABEL_18;
        }
      }
    }
  }
  if ( sel != -1 )
  {
    selected = main_menu->selected;
    if ( selected >= 0 && selected < main_menu->size )
      select_menu_item(term, &main_menu->items[selected], main_menu->data);
  }
}

//----- (08064830) --------------------------------------------------------
void __cdecl mainmenu_handler(window *win, term_event *ev)
{
  window *v2; // esi
  menu *data; // ebx
  unsigned int button; // eax
  int v5; // edx
  action_id_T v6; // eax
  int y; // edx
  int selected; // edx
  terminal *v9; // eax
  void *v10; // ecx
  window *v11; // edx
  terminal *term; // eax
  int x; // ecx
  int v14; // edx
  menu_item *items; // ecx
  menu_item *v16; // ebx
  unsigned __int8 *text; // esi
  int v18; // edi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  menu_item *v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // [esp+10h] [ebp-28h]
  menu *v25; // [esp+14h] [ebp-24h]

  v2 = win;
  data = (menu *)win->data;
  data->win = win;
  switch ( ev->ev )
  {
    case EVENT_INIT:
    case EVENT_REDRAW:
    case EVENT_RESIZE:
      goto LABEL_9;
    case EVENT_KBD:
      v6 = kbd_action(KEYMAP_MENU, ev, 0);
      switch ( v6 )
      {
        case 2:
          goto LABEL_21;
        case 4:
        case 6:
        case 12:
        case 13:
        case 18:
        case 20:
          goto LABEL_16;
        case 5:
          scroll_menu(data, data->size - 1 - data->selected, 0);
          goto LABEL_9;
        case 8:
          scroll_menu(data, -data->selected, 0);
          goto LABEL_9;
        case 9:
        case 16:
          if ( v6 != 9 )
            goto LABEL_7;
          goto LABEL_43;
        case 11:
        case 14:
          if ( v6 == 11 )
LABEL_7:
            v5 = 1;
          else
LABEL_43:
            v5 = -1;
          scroll_menu(data, v5, 1);
          goto LABEL_9;
        case 15:
          goto LABEL_9;
        default:
          if ( ev->info.mouse.x <= 32
            || (y = ev->info.mouse.y, y != 4) && y
            || !check_hotkeys(data, ev->info.mouse.x, win->term) )
          {
LABEL_21:
            v11 = data->win;
            term = win->term;
            data->selected = -1;
            v11->next->prev = v11->prev;
            goto LABEL_22;
          }
          display_mainmenu(win->term, data);
LABEL_16:
          selected = data->selected;
          v9 = win->term;
          if ( selected >= 0 && selected < data->size )
          {
            v10 = data->data;
            goto LABEL_19;
          }
          break;
      }
      return;
    case EVENT_MOUSE:
      button = ev->info.mouse.button;
      if ( (button & 7) > 2 )
        return;
      if ( !ev->info.mouse.y )
      {
        x = ev->info.mouse.x;
        v14 = -1;
        if ( x <= 1 )
          goto LABEL_36;
        v9 = win->term;
        v14 = 1;
        if ( x >= v9->width - 2 )
          goto LABEL_36;
        items = data->items;
        if ( !items->text )
          goto LABEL_47;
        v25 = data;
        v16 = data->items;
        text = items->text;
        v18 = 2;
        while ( 1 )
        {
          if ( *text )
          {
            if ( (v16->flags & 0x40) == 0 )
            {
              if ( win->term )
              {
                terminal_codepage = get_terminal_codepage(win->term);
                if ( terminal_codepage != current_charset )
                {
                  v24 = terminal_codepage;
                  cp_mime_name = get_cp_mime_name(terminal_codepage);
                  bind_textdomain_codeset("elinks", cp_mime_name);
                  current_charset = v24;
                }
              }
              text = gettext(text);
            }
            v18 += strlen((const char *)text) + 4 - (v16->hotkey_pos != 0);
            if ( v18 > ev->info.mouse.x )
              break;
          }
          ++v16;
          text = v16->text;
          if ( !v16->text )
          {
            data = v25;
            v9 = win->term;
LABEL_47:
            v22 = data->selected;
LABEL_38:
            if ( v22 >= 0 && data->size > v22 )
            {
              v10 = data->data;
              selected = v22;
LABEL_19:
              select_menu_item(v9, &data->items[selected], v10);
            }
            return;
          }
        }
        v21 = v16;
        data = v25;
        v2 = win;
        v22 = v25->selected;
        v23 = v21 - v25->items;
        v14 = v23 - v22;
        if ( v23 != v22 )
        {
LABEL_36:
          scroll_menu(data, v14, 1);
          display_mainmenu(v2->term, data);
          v22 = data->selected;
        }
        v9 = v2->term;
        goto LABEL_38;
      }
      if ( (button & 0x20) == 0 )
      {
        term = win->term;
        data->selected = -1;
        win->next->prev = win->prev;
LABEL_22:
        data->win->prev->next = data->win->next;
        data->win->next = *(window **)term->windows.prev;
        data->win->prev = (window *)term->windows.prev;
        *(_DWORD *)term->windows.prev = data->win;
        data->win->next->prev = data->win;
LABEL_9:
        display_mainmenu(win->term, data);
      }
      return;
    default:
      return;
  }
}

//----- (08064B50) --------------------------------------------------------
input_line_code __cdecl menu_search_handler(input_line *line, int action_id)
{
  menu *data; // esi
  int selected; // eax
  int v4; // ebx
  int v5; // eax
  unsigned __int8 *v6; // edi
  int v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // edi
  char *v10; // eax
  size_t v11; // eax
  int size; // eax
  _DWORD *next; // ebx
  int v15; // edx
  void *v16; // edx
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  char *dest; // [esp+1Ch] [ebp-2Ch]
  void *desta; // [esp+1Ch] [ebp-2Ch]
  void *destb; // [esp+1Ch] [ebp-2Ch]
  terminal *term; // [esp+24h] [ebp-24h]
  int direction; // [esp+28h] [ebp-20h]
  int v24; // [esp+2Ch] [ebp-1Ch]

  data = (menu *)line->data;
  term = data->win->term;
  selected = data->selected;
  if ( action_id == 22 )
  {
    ++selected;
LABEL_4:
    direction = 1;
    goto LABEL_5;
  }
  if ( action_id <= 22 )
  {
    if ( action_id == 14 )
    {
      next = term->windows.next;
      *(_DWORD *)(*next + 4) = next[1];
      *(_DWORD *)next[1] = *next;
      v15 = data->selected;
      if ( v15 >= 0 && v15 < data->size )
        select_menu_item(term, &data->items[v15], data->data);
      v16 = term->windows.next;
      next[1] = &term->windows;
      *next = v16;
      term->windows.next = next;
      *(_DWORD *)(*next + 4) = next;
      return 0;
    }
    goto LABEL_4;
  }
  if ( action_id != 25 )
  {
    if ( action_id == 26 )
      return 1;
    goto LABEL_4;
  }
  --selected;
  direction = -1;
LABEL_5:
  if ( !line->buffer[0] )
    return 1;
  v24 = selected % data->size;
  v4 = v24;
  while ( 1 )
  {
    v5 = (int)&data->items[v4];
    v6 = *(unsigned __int8 **)v5;
    if ( *(_DWORD *)v5 )
    {
      if ( *v6 )
      {
        v7 = *(_DWORD *)(v5 + 20);
        if ( (v7 & 0x80u) == 0 )
        {
          if ( (v7 & 0x40) == 0 )
          {
            if ( term )
            {
              terminal_codepage = get_terminal_codepage(term);
              if ( terminal_codepage != current_charset )
              {
                destb = (void *)terminal_codepage;
                cp_mime_name = get_cp_mime_name(terminal_codepage);
                bind_textdomain_codeset("elinks", cp_mime_name);
                current_charset = (int)destb;
              }
            }
            v6 = gettext(v6);
          }
          v8 = stracpy(v6);
          v9 = v8;
          if ( v8 )
          {
            v10 = strchr((const char *)v8, 126);
            if ( v10 )
            {
              dest = v10;
              v11 = strlen(v10);
              memmove(dest, dest + 1, v11);
            }
            desta = (void *)strcasestr(v9, line->buffer);
            mem_free(v9);
            if ( desta )
              break;
          }
        }
      }
    }
    size = data->size;
    v4 += direction;
    if ( size == v4 )
    {
      v4 = 0;
      if ( !v24 )
        return 0;
    }
    else
    {
      if ( v4 < 0 )
        v4 = size - 1;
      if ( v4 == v24 )
        return 0;
    }
  }
  set_menu_selection(data, v4);
  display_menu(term, data);
  return 1;
}
// 80596D8: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08064D80) --------------------------------------------------------
void __cdecl menu_handler(window *win, term_event *ev)
{
  term_event *v2; // ebx
  unsigned int button; // eax
  int v4; // ecx
  int v5; // edx
  window *p_windows; // edi
  void (__cdecl *handler)(window *, term_event *); // edx
  window *v8; // eax
  _DWORD *v9; // edx
  int v10; // ebx
  int v11; // esi
  int v12; // ecx
  int v13; // eax
  menu_item *items; // ebx
  int v15; // esi
  int v16; // eax
  int v17; // edi
  unsigned __int8 *text; // esi
  size_t v19; // eax
  int v20; // esi
  menu_item_flags flags; // edx
  int v22; // eax
  unsigned __int8 *rtext; // eax
  size_t v24; // eax
  int v25; // esi
  string *inited; // eax
  int v27; // edx
  int parent_y; // ecx
  int parent_x; // ebx
  int v30; // edi
  action_id_T v31; // eax
  int x; // esi
  int y; // eax
  int terminal_codepage; // eax
  int v35; // ecx
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v37; // eax
  int v38; // edx
  int v39; // esi
  int v40; // edx
  int v41; // edx
  bool v42; // di
  session *v43; // ebx
  terminal *v44; // esi
  window *tab_by_number; // eax
  unsigned __int8 *v46; // eax
  int v47; // eax
  int v48; // ebx
  int v49; // ecx
  char *v50; // eax
  _BYTE *v51; // edx
  int v52; // edx
  int v53; // eax
  int v54; // eax
  int v55; // edx
  int size; // ebx
  int selected; // eax
  int v58; // esi
  int v59; // edx
  char *p_flags; // eax
  _BYTE *v61; // ecx
  int v62; // edi
  int v63; // eax
  int v64; // eax
  window *next; // edi
  terminal *v66; // esi
  int v67; // edx
  void (__cdecl *v68)(window *, term_event *); // edx
  void *data; // ebx
  int v70; // edx
  int v71; // [esp+2Ch] [ebp-4Ch]
  int v72; // [esp+38h] [ebp-40h]
  int v73; // [esp+38h] [ebp-40h]
  int v74; // [esp+3Ch] [ebp-3Ch]
  int v75; // [esp+3Ch] [ebp-3Ch]
  int v76; // [esp+3Ch] [ebp-3Ch]
  int v77; // [esp+3Ch] [ebp-3Ch]
  int v78; // [esp+3Ch] [ebp-3Ch]
  int v79; // [esp+3Ch] [ebp-3Ch]
  int v80; // [esp+40h] [ebp-38h]
  int v81; // [esp+44h] [ebp-34h]
  terminal *term; // [esp+48h] [ebp-30h]
  terminal *terma; // [esp+48h] [ebp-30h]
  menu *menu; // [esp+4Ch] [ebp-2Ch]
  string string; // [esp+58h] [ebp-20h] BYREF

  v2 = ev;
  menu = (menu *)win->data;
  menu->win = win;
  switch ( ev->ev )
  {
    case EVENT_INIT:
    case EVENT_RESIZE:
      get_parent_ptr(win, &menu->parent_x, &menu->parent_y);
      goto LABEL_16;
    case EVENT_KBD:
      v31 = kbd_action(KEYMAP_MENU, ev, 0);
      switch ( v31 )
      {
        case 2:
          if ( win->next != (window *)&win->term->windows && win->next->handler == mainmenu_handler )
            goto LABEL_144;
          delete_window_ev(win, 0);
          return;
        case 4:
          scroll_menu(menu, 1, 1);
          goto LABEL_63;
        case 5:
          scroll_menu(menu, menu->size - 1 - menu->selected, 0);
          goto LABEL_63;
        case 6:
        case 18:
          v66 = win->term;
          goto LABEL_127;
        case 8:
          scroll_menu(menu, -menu->selected, 0);
          goto LABEL_63;
        case 9:
        case 16:
          next = win->next;
          v66 = win->term;
          if ( (list_head_elinks *)win->next != &v66->windows && next->handler == mainmenu_handler )
          {
            delete_window_ev(win, ev);
            data = next->data;
            v70 = *((_DWORD *)data + 3);
            if ( v70 >= 0 && v70 < *((_DWORD *)data + 2) )
              select_menu_item(next->term, (menu_item *)(*((_DWORD *)data + 1) + 32 * v70), *((void **)data + 14));
          }
          else
          {
            if ( v31 == 16 )
              goto LABEL_127;
            delete_window(win);
          }
          return;
        case 12:
          size = menu->size;
          selected = menu->selected;
          if ( size - 1 <= selected )
            selected = size - 1;
          v58 = 0;
          if ( selected >= 0 )
            v58 = selected;
          v59 = v58 + 1;
          if ( size <= v58 + 1 )
            goto LABEL_117;
          p_flags = (char *)&menu->items[v59].flags;
          while ( 1 )
          {
            if ( *p_flags < 0 )
            {
              v61 = (_BYTE *)*((_DWORD *)p_flags - 5);
              if ( v61 )
              {
                if ( !*v61 )
                  break;
              }
            }
            ++v59;
            p_flags += 32;
            if ( size <= v59 )
            {
LABEL_117:
              v59 = size - 1;
              break;
            }
          }
          v62 = size - 1 - v58;
          v63 = v59 - v58;
          v52 = 5;
          if ( v62 >= 5 )
            v62 = 5;
          LOBYTE(v52) = 0;
          v64 = v63 + 1;
          if ( v64 >= 0 )
          {
            v52 = v64;
            if ( v62 <= v64 )
              v52 = v62;
          }
          goto LABEL_106;
        case 13:
          v47 = menu->selected;
          if ( menu->size - 1 <= v47 )
            v47 = menu->size - 1;
          v48 = 0;
          if ( v47 >= 0 )
            v48 = v47;
          v49 = v48 - 1;
          if ( v48 - 1 <= 0 )
            goto LABEL_99;
          v50 = (char *)&menu->items[v49].flags;
          break;
        case 17:
          v42 = 1;
          v43 = 0;
          v44 = menu->win->term;
          tab_by_number = get_tab_by_number(v44, v44->current_tab);
          if ( tab_by_number )
          {
            v43 = (session *)tab_by_number->data;
            v42 = v43 == 0;
          }
          v46 = _("Search menu/", v44);
          if ( !v42 && menu->size > 0 )
            input_field_line(v43, v46, menu, 0, menu_search_handler);
          goto LABEL_63;
        case 20:
          scroll_menu(menu, -1, 1);
          goto LABEL_63;
        default:
          x = ev->info.mouse.x;
          if ( (unsigned int)(x + 299) <= 0xB )
            goto LABEL_144;
          y = ev->info.mouse.y;
          if ( y == 4 )
            goto LABEL_144;
          if ( x <= 32 || y )
            goto LABEL_63;
          if ( check_hotkeys(menu, ev->info.mouse.x, win->term) )
          {
            scroll_menu(menu, 0, 1);
            display_menu(win->term, menu);
            v66 = win->term;
LABEL_127:
            v67 = menu->selected;
            if ( v67 >= 0 && v67 < menu->size )
              select_menu_item(v66, &menu->items[v67], menu->data);
          }
          else
          {
            if ( !check_not_so_hot_keys(menu, x, win->term) )
              goto LABEL_63;
            scroll_menu(menu, 0, 1);
            display_menu(win->term, menu);
          }
          return;
      }
      while ( 1 )
      {
        if ( *v50 < 0 )
        {
          v51 = (_BYTE *)*((_DWORD *)v50 - 5);
          if ( v51 )
          {
            if ( !*v51 )
              break;
          }
        }
        --v49;
        v50 -= 32;
        if ( v49 <= 0 )
        {
LABEL_99:
          v49 = 0;
          break;
        }
      }
      v52 = 5;
      v53 = v48 + 1;
      if ( v48 >= 5 )
        v48 = 5;
      LOBYTE(v52) = 0;
      v54 = v53 - v49;
      if ( v54 >= 0 )
      {
        v55 = v54;
        if ( v48 <= v54 )
          v55 = v48;
        v52 = -v55;
      }
LABEL_106:
      scroll_menu(menu, v52, 0);
LABEL_63:
      display_menu(win->term, menu);
      return;
    case EVENT_MOUSE:
      button = ev->info.mouse.button;
      if ( (button & 7) == 3 )
      {
        v38 = -1;
LABEL_70:
        if ( (button & 0x20) == 0 )
        {
          scroll_menu(menu, v38, 1);
          display_menu(win->term, menu);
        }
        return;
      }
      if ( (button & 7) == 4 )
      {
        v38 = 1;
        goto LABEL_70;
      }
      term = (terminal *)ev->info.mouse.y;
      v4 = ev->info.mouse.x;
      v5 = menu->box.x;
      if ( v4 < v5
        || (v39 = menu->box.y, (int)term < v39)
        || v4 >= menu->box.width + v5
        || (int)term >= v39 + menu->box.height )
      {
        if ( (button & 0x20) != 0 )
        {
          p_windows = (window *)&win->term->windows;
          if ( win == p_windows )
            return;
          handler = win->handler;
          if ( handler != mainmenu_handler )
          {
            v8 = win;
            if ( handler != menu_handler )
              return;
            while ( 1 )
            {
              v9 = v8->data;
              v10 = v9[6];
              if ( v4 >= v10 )
              {
                v11 = v9[7];
                if ( (int)term >= v11 && v4 < v9[8] + v10 && (int)term < v9[9] + v11 )
                {
                  delete_window_ev(win, ev);
                  return;
                }
              }
              v8 = v8->next;
              if ( p_windows == v8 )
                return;
              v68 = v8->handler;
              if ( v68 == mainmenu_handler )
                break;
              if ( v68 != menu_handler )
                return;
            }
            v2 = ev;
          }
          if ( term )
            return;
        }
LABEL_144:
        delete_window_ev(win, v2);
        return;
      }
      v40 = (int)term + menu->first - v39 - 1;
      if ( v40 >= 0 && v40 < menu->size && SLOBYTE(menu->items[v40].flags) >= 0 )
      {
        set_menu_selection(menu, v40);
        display_menu(win->term, menu);
        v41 = menu->selected;
        if ( v41 >= 0 && v41 < menu->size )
          select_menu_item(win->term, &menu->items[v41], menu->data);
      }
      return;
    case EVENT_REDRAW:
LABEL_16:
      terma = win->term;
      v12 = terma->width - 2;
      v71 = v12;
      v80 = terma->height - 2;
      v13 = menu->size;
      if ( v80 <= v13 )
        v13 = terma->height - 2;
      v81 = v13;
      items = menu->items;
      v15 = 0;
      v16 = 2;
      if ( !items->text )
        goto LABEL_45;
      v17 = 0;
      text = items->text;
      break;
    case EVENT_ABORT:
      free_menu_items(menu->items);
      return;
    default:
      return;
  }
  while ( 1 )
  {
    if ( *text )
    {
      if ( (items->flags & 0x40) != 0 )
        goto LABEL_21;
      v78 = v12;
      terminal_codepage = get_terminal_codepage(terma);
      v35 = v78;
      if ( terminal_codepage != current_charset )
      {
        v73 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v73;
        v35 = v78;
      }
      v79 = v35;
      v37 = gettext(text);
      v12 = v79;
      text = v37;
      if ( *v37 )
      {
LABEL_21:
        v74 = v12;
        if ( (*((_BYTE *)terma + 56) & 2) != 0 )
          v19 = utf8_ptr2cells(text, 0);
        else
          v19 = strlen((const char *)text);
        v12 = v74;
        v20 = v19 + 2 - (items->hotkey_pos != 0);
      }
      else
      {
        v20 = 0;
      }
    }
    else
    {
      v20 = 0;
    }
    flags = items->flags;
    v22 = 4;
    if ( (flags & 0x20) != 0 )
      goto LABEL_30;
    if ( items->action_id )
      break;
    rtext = items->rtext;
    if ( !rtext )
      goto LABEL_40;
    if ( !*rtext )
      goto LABEL_40;
    if ( (BYTE1(flags) & 1) != 0 )
    {
      v76 = v12;
      rtext = _(rtext, terma);
      v12 = v76;
      if ( !*rtext )
        goto LABEL_40;
    }
    v75 = v12;
    v24 = strlen((const char *)rtext);
    v12 = v75;
    v22 = v24 + 2;
LABEL_30:
    if ( v20 > v12 )
      v20 = v12;
    if ( v22 > v12 - v20 )
      v22 = v12 - v20;
    v25 = v22 + v20;
    if ( v17 < v25 )
      v17 = v25;
    ++items;
    text = items->text;
    if ( !items->text )
    {
      v15 = v17;
      v16 = v17 + 2;
      v71 = v12;
      if ( v17 + 2 < 0 )
        v16 = 0;
LABEL_45:
      v27 = 0;
      parent_y = menu->parent_y;
      parent_x = menu->parent_x;
      if ( parent_x < 0 )
        parent_x = 0;
      menu->box.x = parent_x;
      v30 = 0;
      if ( parent_y >= 0 )
        v30 = parent_y;
      menu->box.y = v30;
      menu->box.width = v16;
      if ( v81 + 2 >= 0 )
        v27 = v81 + 2;
      menu->box.height = v27;
      if ( v71 - v15 < parent_x )
        menu->box.x = v71 - v15;
      if ( v80 - v81 < v30 )
        menu->box.y = v80 - v81;
      scroll_menu(menu, 0, 1);
      display_menu(win->term, menu);
      return;
    }
  }
  v77 = v12;
  inited = init_string(&string);
  v12 = v77;
  if ( inited )
  {
    add_keystroke_action_to_string(&string, items->action_id, KEYMAP_MAIN);
    v72 = string.length + 2;
    done_string(&string);
    v22 = v72;
    v12 = v77;
    goto LABEL_30;
  }
LABEL_40:
  v22 = 0;
  goto LABEL_30;
}

//----- (080655E0) --------------------------------------------------------
void __cdecl abort_refreshed_msg_box_handler(dialog_data *dlg_data)
{
  dialog *dlg; // eax

  dlg = dlg_data->dlg;
  if ( dlg->udata != dlg->widgets[0].text )
    mem_free(dlg->widgets[0].text);
}

//----- (08065610) --------------------------------------------------------
dlg_refresh_code __cdecl refresh_msg_box(dialog_data *dlg_data, void *data)
{
  unsigned __int8 *v2; // esi
  dlg_refresh_code result; // eax

  v2 = (unsigned __int8 *)((int (__cdecl *)(terminal *, void *))data)(dlg_data->win->term, dlg_data->dlg->udata2);
  result = REFRESH_CANCEL;
  if ( v2 )
  {
    abort_refreshed_msg_box_handler(dlg_data);
    dlg_data->dlg->widgets[0].text = v2;
    return 0;
  }
  return result;
}

//----- (08065660) --------------------------------------------------------
unsigned __int8 *msg_text(terminal *term, unsigned __int8 *format, ...)
{
  unsigned __int8 *v2; // esi
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax
  int v6; // edi
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v10; // [esp+0h] [ebp-48h]
  va_list va; // [esp+58h] [ebp+10h] BYREF

  va_start(va, format);
  v2 = 0;
  if ( format )
  {
    v2 = format;
    if ( *format )
    {
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        v4 = terminal_codepage;
        if ( terminal_codepage != current_charset )
        {
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v4;
        }
      }
      v2 = gettext(format);
    }
  }
  v6 = __vsnprintf_chk(0, 0, 1, -1, v2, va);
  v7 = (unsigned __int8 *)mem_alloc(v6 + 1);
  v8 = v7;
  if ( v7 )
  {
    if ( v6 == __vsnprintf_chk(v7, v6 + 1, 1, -1, v2, va) )
    {
      v8[v6] = 0;
    }
    else
    {
      v10 = v8;
      v8 = 0;
      mem_free(v10);
    }
  }
  return v8;
}
// 80590A8: using guessed type int __cdecl __vsnprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08065760) --------------------------------------------------------
dialog_data *msg_box(
        terminal *term,
        memory_list *ml,
        msgbox_flags flags,
        unsigned __int8 *title,
        format_align align,
        unsigned __int8 *text,
        void *udata,
        int buttons,
        ...)
{
  char v8; // bl
  unsigned __int8 *v9; // esi
  void *v10; // eax
  void *v11; // edi
  unsigned __int8 *v12; // eax
  va_list v13; // ebx
  int v14; // eax
  unsigned __int8 *v15; // esi
  done_handler_T *v16; // edx
  int v17; // ecx
  int v19; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  int terminal_codepage; // eax
  int v23; // edi
  unsigned __int8 *cp_mime_name; // eax
  int v25; // eax
  int v26; // edi
  unsigned __int8 *v27; // eax
  done_handler_T *v28; // [esp+2Ch] [ebp-2Ch]
  done_handler_T *v29; // [esp+2Ch] [ebp-2Ch]
  int v30; // [esp+30h] [ebp-28h]
  int v31; // [esp+30h] [ebp-28h]
  int v32; // [esp+34h] [ebp-24h]
  int v33; // [esp+38h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-1Ch]
  va_list va; // [esp+80h] [ebp+28h] BYREF

  va_start(va, buttons);
  v8 = flags;
  v9 = text;
  if ( buttons < 0 || !text )
    return 0;
  if ( (flags & 1) != 0 )
  {
    add_one_to_ml(&ml, text);
    v33 = v8 & 2;
    if ( (v8 & 2) != 0 )
      goto LABEL_5;
  }
  else
  {
    v33 = flags & 2;
    if ( (flags & 2) != 0 )
      goto LABEL_5;
  }
  if ( title && *title )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v23 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v23;
      }
    }
    title = gettext(title);
  }
  if ( (v8 & 9) == 0 && *v9 )
  {
    if ( term )
    {
      v25 = get_terminal_codepage(term);
      v26 = v25;
      if ( v25 != current_charset )
      {
        v27 = get_cp_mime_name(v25);
        bind_textdomain_codeset("elinks", v27);
        current_charset = v26;
      }
    }
    v9 = gettext(v9);
  }
LABEL_5:
  v10 = mem_calloc(1u, 48 * buttons + 84);
  v11 = v10;
  if ( !v10 )
  {
    freeml(ml);
    return 0;
  }
  add_one_to_ml(&ml, v10);
  v12 = title;
  *((_BYTE *)v11 + 28) |= 2u;
  *((_DWORD *)v11 + 4) = generic_dialog_layouter;
  *(_DWORD *)v11 = v12;
  *((_DWORD *)v11 + 2) = udata;
  if ( (v8 & 4) != 0 )
    *((_BYTE *)v11 + 60) |= 2u;
  va_copy(v13, va);
  add_dlg_text((dialog *)v11, v9, align, 0);
  v14 = *((_DWORD *)v11 + 8);
  for ( i = buttons + 1; i > v14; i = buttons + 1 )
  {
    while ( 1 )
    {
      v15 = *(unsigned __int8 **)v13;
      v16 = (done_handler_T *)*((_DWORD *)v13 + 1);
      v13 += 12;
      v17 = *((_DWORD *)v13 - 1);
      if ( !v15 )
        break;
      if ( !v33 && *v15 )
      {
        if ( term )
        {
          v28 = v16;
          v30 = *((_DWORD *)v13 - 1);
          v19 = get_terminal_codepage(term);
          v16 = v28;
          v17 = v30;
          v32 = v19;
          if ( v19 != current_charset )
          {
            v20 = get_cp_mime_name(v19);
            bind_textdomain_codeset("elinks", v20);
            current_charset = v32;
            v17 = v30;
            v16 = v28;
          }
        }
        v29 = v16;
        v31 = v17;
        v21 = gettext(v15);
        v17 = v31;
        v16 = v29;
        v15 = v21;
      }
      add_dlg_button_do((dialog *)v11, v15, v17, ok_dialog, 0, v16, udata);
      v14 = *((_DWORD *)v11 + 8);
      if ( i <= v14 )
        goto LABEL_13;
    }
    --buttons;
  }
LABEL_13:
  if ( !assert_failed )
  {
    assert_failed = i != v14;
    if ( i != v14 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/msgbox.c";
      errline = 91;
      elinks_internal("assertion buttons + 1 == (dlg)->number_of_widgets failed!");
    }
  }
  return do_dialog(term, (dialog *)v11, ml);
}

//----- (08065A70) --------------------------------------------------------
dialog_data *__cdecl info_box(
        terminal *term,
        msgbox_flags flags,
        unsigned __int8 *title,
        format_align align,
        unsigned __int8 *text)
{
  return msg_box(term, 0, flags, title, align, text, 0, 1, &okbutton, 0, 3);
}

//----- (08065AD0) --------------------------------------------------------
void __cdecl refreshed_msg_box(
        terminal *term,
        msgbox_flags flags,
        unsigned __int8 *title,
        format_align align,
        unsigned __int8 *(*get_info)(terminal *, void *),
        void *data)
{
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // ebx
  dialog_data *v8; // eax

  v6 = get_info(term, data);
  v7 = v6;
  if ( v6 )
  {
    v8 = msg_box(term, 0, (msgbox_flags)(flags | 1), title, align, v6, data, 1, &okbutton, 0, 3);
    if ( v8 )
    {
      v8->dlg->udata = v7;
      v8->dlg->abort = abort_refreshed_msg_box_handler;
      refresh_dialog(v8, refresh_msg_box, get_info);
    }
  }
}

//----- (08065BB0) --------------------------------------------------------
void done_bfu_colors()
{
  hash *v0; // eax
  hash *v1; // edx
  int v2; // ebx
  hash *i; // ecx
  list_head_elinks *next; // edi

  v0 = bfu_colors;
  if ( bfu_colors )
  {
    if ( 1 << bfu_colors->width > 0 )
    {
      v1 = bfu_colors;
      v2 = 0;
      for ( i = bfu_colors; ; i = v1 )
      {
        next = (list_head_elinks *)v1->hash[v2].next;
        v1 = i;
        if ( next != &i->hash[v2] )
        {
          do
          {
            if ( next[2].next )
            {
              mem_free(next[2].next);
              v0 = bfu_colors;
            }
            next = (list_head_elinks *)next->next;
            v1 = v0;
          }
          while ( &v0->hash[v2] != next );
        }
        if ( 1 << v1->width <= ++v2 )
          break;
      }
    }
    free_hash(&bfu_colors);
  }
}

//----- (08065C40) --------------------------------------------------------
color_pair *__cdecl get_bfu_color(terminal *term, unsigned __int8 *stylename)
{
  option_value *opt; // eax
  hash *inited; // ebx
  hash *v4; // eax
  hash *v5; // edx
  int v6; // esi
  hash *i; // ecx
  hash_item *next; // edi
  hash_item **p_next; // edi
  unsigned int v10; // esi
  hash_item *hash_item; // eax
  char *value; // ebx
  option_value *v13; // eax
  const unsigned __int8 *v15; // eax
  option_elinks *opt_rec_real; // eax
  option_elinks *v17; // edi
  char *v18; // eax
  color_mode color_mode; // [esp+18h] [ebp-20h]

  if ( !term )
    return 0;
  opt = get_opt_(term->spec, "colors");
  inited = bfu_colors;
  color_mode = opt->number;
  v4 = bfu_colors;
  if ( !bfu_colors )
  {
    inited = init_hash8();
    bfu_colors = inited;
    if ( inited )
    {
      last_color_mode_4585 = color_mode;
      goto LABEL_14;
    }
    return 0;
  }
  if ( color_mode != last_color_mode_4585 )
  {
    if ( 1 << bfu_colors->width > 0 )
    {
      v5 = bfu_colors;
      v6 = 0;
      for ( i = bfu_colors; ; i = v5 )
      {
        next = (hash_item *)v5->hash[v6].next;
        v5 = i;
        if ( next != (hash_item *)&i->hash[v6] )
        {
          do
          {
            if ( next->value )
            {
              mem_free(next->value);
              v4 = bfu_colors;
            }
            p_next = &next->prev->next;
            del_hash_item(v4, *p_next);
            v4 = bfu_colors;
            next = *p_next;
            v5 = bfu_colors;
          }
          while ( &bfu_colors->hash[v6] != (list_head_elinks *)next );
        }
        if ( 1 << v5->width <= ++v6 )
          break;
      }
    }
    inited = v4;
    last_color_mode_4585 = color_mode;
  }
LABEL_14:
  v10 = strlen((const char *)stylename);
  hash_item = get_hash_item(inited, stylename, v10);
  if ( hash_item )
  {
    value = (char *)hash_item->value;
    if ( value )
    {
      v13 = *(option_value **)value;
LABEL_17:
      *((option_value *)value + 2) = (option_value)v13->tree;
      *((_DWORD *)value + 3) = **((_DWORD **)value + 1);
      return (color_pair *)(value + 8);
    }
  }
  v15 = "ui.colors.color";
  if ( color_mode == COLOR_MODE_MONO )
    v15 = &byte_8127850;
  opt_rec_real = get_opt_rec_real(config_options, v15);
  if ( !opt_rec_real )
    return 0;
  v17 = get_opt_rec_real(opt_rec_real, stylename);
  if ( !v17 )
    return 0;
  v18 = (char *)mem_calloc(1u, 0x10u);
  value = v18;
  if ( !v18 )
    return 0;
  if ( add_hash_item(bfu_colors, stylename, v10, v18) )
  {
    *((_DWORD *)value + 1) = get_opt_(v17, "text");
    v13 = get_opt_(v17, "background");
    *(_DWORD *)value = v13;
    goto LABEL_17;
  }
  mem_free(value);
  return 0;
}

//----- (08065E40) --------------------------------------------------------
void __cdecl add_dlg_text(dialog *dlg, unsigned __int8 *text, format_align align, int bottom_pad)
{
  int number_of_widgets; // ecx
  int v5; // edx
  char *v6; // ecx
  int v7; // ecx

  number_of_widgets = dlg->number_of_widgets;
  v5 = number_of_widgets + 1;
  v6 = (char *)dlg + 48 * number_of_widgets;
  dlg->number_of_widgets = v5;
  *((_DWORD *)v6 + 20) = 5;
  *((_DWORD *)v6 + 10) = text;
  v7 = 12 * v5;
  *(void **)((char *)&dlg->udata2 + v7 * 4) = (void *)align;
  LOBYTE((&dlg->refresh)[v7]) = (bottom_pad != 0) | (int)(&dlg->refresh)[12 * v5] & 0xFE;
}

//----- (08065EA0) --------------------------------------------------------
widget_handler_status_T __cdecl display_text(dialog_data *dlg_data, widget_data *widget_data)
{
  window *win; // esi
  int y; // edi
  int v4; // eax
  int v5; // ecx
  int height; // edx
  int v7; // eax
  color_pair *bfu_color; // eax
  int v9; // edi
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // eax
  int v15; // edi
  color_pair *v16; // eax
  int current; // [esp+24h] [ebp-34h]
  int lines; // [esp+2Ch] [ebp-2Ch]
  box box; // [esp+30h] [ebp-28h] BYREF

  win = dlg_data->win;
  lines = widget_data->info.field.cpos;
  y = widget_data->box.y;
  v4 = dlg_data->box.width + dlg_data->box.x;
  v5 = 0;
  height = widget_data->box.height;
  box.width = 1;
  v7 = v4 - 4;
  if ( v7 < 0 )
    v7 = 0;
  if ( y < 0 )
    y = 0;
  if ( height >= 0 )
    v5 = height;
  box.x = v7;
  box.y = y;
  box.height = v5;
  if ( (*((_BYTE *)&widget_data->widget->info.text + 4) & 2) != 0 && height > 0 && lines > 0 && height < lines && v5 )
  {
    bfu_color = get_bfu_color(win->term, "dialog.scrollbar");
    draw_box(win->term, &box, 0x20u, (screen_char_attr)0, bfu_color);
    current = widget_data->info.field.vpos;
    v9 = widget_data->box.height;
    v10 = 0;
    v11 = 100 * (box.height + 1) / lines * (current + 1) / 100;
    if ( v11 >= 0 )
    {
      v10 = v9 - 1;
      if ( v11 <= v9 - 1 )
        v10 = 100 * (box.height + 1) / lines * (current + 1) / 100;
    }
    v12 = (box.height + 1) * (100 * (box.height + 1) / lines) / 100;
    box.height = v12;
    if ( v12 <= 0 )
    {
      box.height = 1;
    }
    else
    {
      v13 = 1;
      if ( v9 - v10 > 0 )
        v13 = v9 - v10;
      if ( v12 > v13 )
        box.height = v13;
    }
    v14 = lines - v9;
    v15 = v9 - box.height;
    if ( v14 == current )
      v10 = v15;
    box.y += v10;
    widget_data->info.text.scroller_height = box.height;
    widget_data->info.text.scroller_y = box.y;
    v16 = get_bfu_color(win->term, "dialog.scrollbar-selected");
    draw_box(win->term, &box, 0x20u, (screen_char_attr)0, v16);
    set_cursor(win->term, widget_data->box.x, widget_data->box.y, 1);
    win->x = widget_data->box.x;
    win->y = widget_data->box.y;
  }
  return 0;
}

//----- (08066090) --------------------------------------------------------
void __cdecl dlg_format_text_do(
        terminal *term,
        unsigned __int8 *text,
        int x,
        int *y,
        int width,
        int *real_width,
        color_pair *color,
        format_align align,
        int format_only)
{
  unsigned __int8 v9; // bl
  unsigned __int8 v10; // bl
  unsigned __int8 *v11; // esi
  const unsigned __int16 *v12; // eax
  int v13; // esi
  unsigned __int8 *v14; // ebx
  int v15; // edi
  unsigned __int8 *v16; // edi
  int v17; // eax
  unsigned __int8 v18; // bl
  unsigned __int8 *v19; // edi
  int v20; // esi
  unsigned __int8 *v21; // edx
  unsigned __int8 *i; // edi
  const unsigned __int16 **v23; // eax
  int v24; // eax
  unsigned __int8 *v25; // [esp+28h] [ebp-30h]
  _BOOL4 v26; // [esp+2Ch] [ebp-2Ch]
  int v27; // [esp+30h] [ebp-28h]
  unsigned __int8 *end; // [esp+34h] [ebp-24h]
  unsigned __int8 *p; // [esp+38h] [ebp-20h]
  int cells; // [esp+3Ch] [ebp-1Ch]

  if ( *text )
  {
    v9 = *text;
LABEL_3:
    if ( v9 )
    {
      do
      {
        v26 = (*((_BYTE *)term + 56) & 2) != 0;
        end = &text[strlen((const char *)text)];
        if ( width <= 0 )
          goto LABEL_55;
        cells = 0;
        v27 = 0;
        p = text;
        if ( v9 != 10 )
        {
          while ( 1 )
          {
            if ( !v9 )
              goto LABEL_17;
            if ( v26 )
            {
              v16 = &p[utf8charlen(p)];
              v17 = utf8_char2cells(p, end);
              v18 = *p;
              if ( p != v16 && (v11 = p, v18) )
              {
                do
                  v18 = *++v11;
                while ( v16 != v11 && v18 );
                v19 = v11;
              }
              else
              {
                v19 = p;
                v11 = p;
              }
              cells += v17;
              while ( v18 != 10 && v18 && ((*__ctype_b_loc())[v18] & 0x2000) == 0 )
              {
                if ( v11 < v19 )
                {
                  ++v11;
                }
                else
                {
                  cells += utf8_char2cells(v11, end);
                  v19 += utf8charlen(v11);
                }
                v18 = *v11;
              }
            }
            else
            {
              v10 = p[1];
              v11 = p + 1;
              if ( v10 && v10 != 10 )
              {
                v12 = *__ctype_b_loc();
                do
                {
                  if ( (v12[v10] & 0x2000) != 0 )
                    break;
                  v10 = *++v11;
                  if ( *v11 == 10 )
                    break;
                }
                while ( v10 );
              }
              cells = v11 - text;
            }
            if ( width < cells )
              break;
            v9 = *v11;
            p = v11;
            v27 = cells;
            if ( *v11 == 10 )
              goto LABEL_17;
          }
          if ( text != p )
            goto LABEL_17;
          if ( !v26 )
          {
            v20 = width;
            v21 = &text[width];
            for ( i = &text[width]; text != i - 1; --i )
            {
              v25 = v21;
              v23 = __ctype_b_loc();
              v21 = v25;
              if ( ((*v23)[*(i - 1)] & 4) != 0 )
              {
                p = i;
                goto LABEL_59;
              }
              --v20;
            }
            v14 = v21;
            goto LABEL_61;
          }
          v24 = utf8_cells2bytes(text, width, 0);
          p = &text[v24];
          v20 = utf8_ptr2cells(text, &text[v24]);
LABEL_59:
          v27 = v20;
          if ( text == p )
          {
            v14 = &text[width];
LABEL_61:
            v27 = width;
            v13 = width;
            goto LABEL_19;
          }
        }
LABEL_17:
        v13 = p - text;
        if ( p - text <= 0 )
        {
LABEL_55:
          ++text;
        }
        else
        {
          v14 = p;
LABEL_19:
          if ( real_width && *real_width < v27 )
            *real_width = v27;
          if ( !format_only )
          {
            if ( align == ALIGN_CENTER )
            {
              v15 = (width - v27) / 2;
            }
            else
            {
              v15 = width - v27;
              if ( align != ALIGN_RIGHT )
                v15 = 0;
            }
            if ( !assert_failed )
            {
              assert_failed = v15 >= width || width < v27;
              if ( v15 >= width || width < v27 )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
                errline = 256;
                elinks_internal("assertion cells <= width && shift < width failed!");
              }
            }
            draw_text(term, x + v15, *y, text, v13, (screen_char_attr)0, color);
          }
          text = v14;
        }
        ++*y;
        v9 = *text;
        if ( !*text )
          return;
        if ( ((*__ctype_b_loc())[v9] & 0x2000) == 0 )
          goto LABEL_3;
        v9 = *++text;
      }
      while ( *text );
    }
  }
}

//----- (08066400) --------------------------------------------------------
void __cdecl dlg_format_text(
        terminal *term,
        widget_data *widget_data,
        int x,
        int *y,
        int width,
        int *real_width,
        int max_height,
        int format_only)
{
  widget *widget; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // ebx
  bool v13; // si
  char v14; // di
  char *v15; // ebx
  unsigned __int8 *v16; // edx
  unsigned __int8 *cdata; // eax
  const unsigned __int16 **v18; // eax
  unsigned __int8 v19; // cl
  _DWORD *v20; // edx
  int v21; // edi
  size_t v22; // eax
  unsigned __int8 v23; // cl
  char *v24; // edi
  unsigned __int8 v25; // al
  unsigned __int8 *v26; // ebx
  unsigned __int8 *v27; // eax
  int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // ebx
  int v31; // esi
  unsigned __int8 *v32; // edx
  int vpos; // eax
  unsigned __int8 *v34; // esi
  int cpos; // edx
  int v36; // ecx
  int v37; // ebx
  int v38; // eax
  int v39; // eax
  bool v40; // si
  unsigned __int8 *v41; // ebx
  int v42; // ecx
  unsigned __int8 v43; // al
  unsigned __int8 *v44; // esi
  unsigned __int8 v45; // dl
  int v46; // eax
  unsigned __int8 *v47; // eax
  color_pair *bfu_color; // [esp+18h] [ebp-70h]
  unsigned __int8 v49; // [esp+38h] [ebp-50h]
  unsigned __int8 v50; // [esp+38h] [ebp-50h]
  int v51; // [esp+38h] [ebp-50h]
  format_align alignb; // [esp+3Ch] [ebp-4Ch]
  format_align alignc; // [esp+3Ch] [ebp-4Ch]
  _DWORD *align; // [esp+3Ch] [ebp-4Ch]
  format_align alignd; // [esp+3Ch] [ebp-4Ch]
  format_align aligna; // [esp+3Ch] [ebp-4Ch]
  int v57; // [esp+40h] [ebp-48h]
  int v58; // [esp+44h] [ebp-44h]
  _BOOL4 v59; // [esp+4Ch] [ebp-3Ch]
  unsigned __int8 *end; // [esp+50h] [ebp-38h]
  int v61; // [esp+54h] [ebp-34h]
  int v62; // [esp+54h] [ebp-34h]
  char *s; // [esp+58h] [ebp-30h]
  unsigned __int8 *text; // [esp+5Ch] [ebp-2Ch]
  unsigned __int8 *texta; // [esp+5Ch] [ebp-2Ch]
  unsigned __int8 *p; // [esp+6Ch] [ebp-1Ch]

  widget = widget_data->widget;
  v9 = 0;
  v10 = max_height - 3;
  if ( max_height - 3 < 0 )
    v10 = 0;
  v57 = v10;
  text = widget->text;
  v11 = *y;
  v12 = x;
  if ( x < 0 )
    v12 = 0;
  if ( v11 < 0 )
    v11 = 0;
  if ( widget_data->box.width >= 0 )
    v9 = widget_data->box.width;
  widget_data->box.x = v12;
  widget_data->box.y = v11;
  widget_data->box.width = v9;
  widget_data->box.height = v57;
  if ( !v57 )
    return;
  if ( (*((_BYTE *)&widget->info.text + 4) & 2) == 0
    || widget_data->info.text.max_width == width && widget_data->info.field.cpos <= v57 )
  {
    v13 = 0;
    v14 = 0;
    widget_data->info.field.vpos = 0;
    v15 = 0;
    goto LABEL_12;
  }
  if ( width == v9 )
    goto LABEL_51;
  v59 = (*((_BYTE *)term + 56) & 2) != 0;
  v16 = widget->text;
  s = (char *)v16;
  cdata = widget_data->cdata;
  p = cdata;
  if ( width == widget_data->info.text.max_width )
    goto LABEL_50;
  widget_data->box.width = 0;
  if ( !*v16 )
  {
    v32 = cdata;
    v31 = 0;
    goto LABEL_49;
  }
  v49 = *v16;
  v18 = __ctype_b_loc();
  v19 = v49;
  v58 = 0;
  v20 = v18;
  while ( 2 )
  {
    if ( (*(_BYTE *)(*v20 + 2 * v19 + 1) & 0x20) != 0 )
      v19 = *++s;
    if ( !v19 )
      goto LABEL_48;
    v21 = 1;
    alignc = (format_align)v20;
    v50 = v19;
    v22 = strlen(s);
    v61 = 1;
    v20 = (_DWORD *)alignc;
    v23 = v50;
    end = (unsigned __int8 *)&s[v22];
    if ( width <= 0 )
      goto LABEL_42;
    v24 = s;
    texta = 0;
    v62 = 0;
    if ( v50 == 10 )
      goto LABEL_37;
    while ( 1 )
    {
      if ( !v23 )
        goto LABEL_37;
      if ( !v59 )
        break;
      align = v20;
      v41 = (unsigned __int8 *)&v24[utf8charlen((const unsigned __int8 *)v24)];
      v42 = utf8_char2cells((unsigned __int8 *)v24, end);
      v43 = *v24;
      if ( v24 != (char *)v41 && (v44 = (unsigned __int8 *)v24, v43) )
      {
        do
          v43 = *++v44;
        while ( v41 != v44 && v43 );
        v26 = v44;
      }
      else
      {
        v44 = (unsigned __int8 *)v24;
        v26 = (unsigned __int8 *)v24;
      }
      v45 = v43;
      texta += v42;
      while ( v45 != 10 && v45 && (*(_BYTE *)(*align + 2 * v45 + 1) & 0x20) == 0 )
      {
        if ( v26 < v44 )
        {
          ++v26;
        }
        else
        {
          texta += utf8_char2cells(v26, end);
          v44 += utf8charlen(v26);
        }
        v45 = *v26;
      }
      v27 = texta;
      v20 = align;
      if ( width < (int)texta )
        goto LABEL_81;
LABEL_36:
      v23 = *v26;
      v24 = (char *)v26;
      v62 = (int)v27;
      if ( *v26 == 10 )
        goto LABEL_37;
    }
    v25 = v24[1];
    v26 = (unsigned __int8 *)(v24 + 1);
    if ( v25 && v25 != 10 )
    {
      do
      {
        if ( (*(_BYTE *)(*v20 + 2 * v25 + 1) & 0x20) != 0 )
          break;
        v25 = *++v26;
        if ( *v26 == 10 )
          break;
      }
      while ( v25 );
    }
    texta = (unsigned __int8 *)(v26 - (unsigned __int8 *)s);
    v27 = (unsigned __int8 *)(v26 - (unsigned __int8 *)s);
    if ( width >= v26 - (unsigned __int8 *)s )
      goto LABEL_36;
LABEL_81:
    if ( s != v24 )
      goto LABEL_37;
    if ( !v59 )
    {
      v24 = &s[width];
      v62 = width;
      while ( s != v24 - 1 )
      {
        if ( (*(_BYTE *)(*v20 + 2 * (unsigned __int8)*(v24 - 1)) & 4) != 0 )
          goto LABEL_88;
        --v62;
        --v24;
      }
LABEL_89:
      v62 = width;
      v21 = width;
      goto LABEL_39;
    }
    alignd = (format_align)v20;
    v24 = &s[utf8_cells2bytes((unsigned __int8 *)s, width, 0)];
    v46 = utf8_ptr2cells((unsigned __int8 *)s, (unsigned __int8 *)v24);
    v20 = (_DWORD *)alignd;
    v62 = v46;
LABEL_88:
    if ( s == v24 )
      goto LABEL_89;
LABEL_37:
    v21 = v24 - s;
    if ( v21 <= 0 )
      v21 = 1;
LABEL_39:
    v28 = 1;
    if ( v62 > 0 )
      v28 = v62;
    v61 = v28;
LABEL_42:
    if ( widget_data->box.width < v61 )
      widget_data->box.width = v61;
    v29 = (v58 + 8) & 0xFFFFFFF8;
    v30 = (v58 + 7) & 0xFFFFFFF8;
    v31 = v58 + 1;
    if ( v29 > v30 )
    {
      aligna = (format_align)v20;
      v51 = 4 * v29;
      v47 = (unsigned __int8 *)mem_realloc(p, 4 * v29);
      if ( v47 )
      {
        p = v47;
        memset(&v47[4 * v30], 0, v51 - 4 * v30);
        v20 = (_DWORD *)aligna;
        goto LABEL_45;
      }
LABEL_48:
      cdata = p;
      v31 = v58;
      v32 = p;
      break;
    }
LABEL_45:
    cdata = p;
    if ( p )
    {
      *(_DWORD *)&p[4 * v31 - 4] = s;
      s += v21;
      v19 = *s;
      if ( *s )
      {
        ++v58;
        continue;
      }
      cdata = p;
      v32 = p;
    }
    else
    {
      v31 = v58;
      v32 = 0;
    }
    break;
  }
LABEL_49:
  widget_data->cdata = v32;
  widget_data->info.field.cpos = v31;
  widget_data->info.text.max_width = width;
LABEL_50:
  if ( cdata )
  {
LABEL_51:
    vpos = widget_data->info.field.vpos;
    v34 = widget_data->cdata;
    cpos = widget_data->info.field.cpos;
    if ( vpos < 0 )
    {
      widget_data->info.field.vpos = 0;
      v37 = 0;
      vpos = 0;
    }
    else
    {
      v36 = cpos - v57;
      if ( cpos - v57 < v57 )
        v36 = v57;
      if ( vpos > v36 )
      {
        vpos = v36;
        widget_data->info.field.vpos = v36;
        v37 = 4 * v36;
      }
      else
      {
        v37 = 4 * vpos;
      }
    }
    v14 = 0;
    text = *(unsigned __int8 **)&v34[v37];
    v15 = 0;
    if ( cpos - vpos > v57 )
    {
      v38 = v57 + vpos;
      v15 = *(char **)&v34[4 * v38];
      if ( v38 > 0 && *(v15 - 1) == 10 )
      {
        --v15;
        v14 = 10;
      }
      else
      {
        v14 = *v15;
      }
      *v15 = 0;
    }
    if ( real_width && (v39 = widget_data->box.width, v39 > *real_width) )
    {
      *real_width = v39;
      v40 = v14 != 0;
    }
    else
    {
      v40 = v14 != 0;
    }
    v13 = v15 != 0 && v40;
    widget = widget_data->widget;
LABEL_12:
    alignb = widget->info.text.align;
    bfu_color = get_bfu_color(term, "dialog.text");
    dlg_format_text_do(term, text, x, y, width, real_width, bfu_color, alignb, format_only);
    if ( (*((_BYTE *)&widget_data->widget->info.text + 4) & 1) != 0 )
      --*y;
    if ( v13 )
      *v15 = v14;
  }
}

//----- (08066950) --------------------------------------------------------
void __usercall format_and_display_text(widget_data *widget_data@<eax>, dialog_data *dlg_data@<edx>, int current@<ecx>)
{
  terminal *term; // edi
  int height; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int cpos; // ecx
  int v11; // eax
  int v12; // ecx
  color_pair *bfu_color; // eax
  int v14; // [esp+20h] [ebp-38h]
  int v15; // [esp+20h] [ebp-38h]
  int max_height; // [esp+24h] [ebp-34h]
  int max_heighta; // [esp+24h] [ebp-34h]
  int max_heightb; // [esp+24h] [ebp-34h]
  int y[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  term = dlg_data->win->term;
  y[0] = widget_data->box.y;
  height = term->height;
  v7 = 9 * height / 10 - 4;
  v8 = 1;
  if ( v7 > 0 )
  {
    v9 = height - 4;
    if ( v9 > 0 )
      v8 = v9;
    if ( v7 <= v8 )
      v8 = v7;
  }
  cpos = widget_data->info.field.cpos;
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)cpos >> 31;
    if ( cpos >= 0 )
    {
      assert_failed = (unsigned int)widget_data->box.height >> 31;
      if ( !assert_failed )
        goto LABEL_9;
LABEL_15:
      max_heighta = v8;
      v14 = cpos;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
      errline = 415;
      elinks_internal("assertion widget_data->box.height >= 0 failed!");
      cpos = v14;
      v8 = max_heighta;
      goto LABEL_9;
    }
    max_heightb = v8;
    v15 = cpos;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bfu/text.c";
    errline = 414;
    elinks_internal("assertion lines >= 0 failed!");
    v8 = max_heightb;
    cpos = v15;
    if ( !assert_failed )
    {
      assert_failed = (unsigned int)widget_data->box.height >> 31;
      if ( assert_failed )
        goto LABEL_15;
    }
  }
LABEL_9:
  v11 = 0;
  if ( current >= 0 )
  {
    v11 = current;
    v12 = cpos - widget_data->box.height;
    if ( current > v12 )
      v11 = v12;
  }
  if ( widget_data->info.field.vpos != v11 )
  {
    widget_data->info.field.vpos = v11;
    max_height = v8;
    bfu_color = get_bfu_color(term, "dialog.generic");
    draw_box(term, &widget_data->box, 0x20u, (screen_char_attr)0, bfu_color);
    dlg_format_text(term, widget_data, widget_data->box.x, y, widget_data->box.width, 0, max_height, 0);
    display_text(dlg_data, widget_data);
    redraw_from_window(dlg_data->win);
  }
}
// 8066950: using guessed type int y[7];

//----- (08066B20) --------------------------------------------------------
widget_handler_status_T __cdecl kbd_text(dialog_data *dlg_data, widget_data *widget_data)
{
  int vpos; // edi
  int v3; // eax
  widget_handler_status_T result; // eax
  int cpos; // ecx

  vpos = widget_data->info.field.vpos;
  v3 = kbd_action(KEYMAP_MENU, dlg_data->term_event, 0) - 4;
  switch ( v3 )
  {
    case 0:
      cpos = vpos + 1;
      goto LABEL_5;
    case 1:
      cpos = widget_data->info.field.cpos;
      goto LABEL_5;
    case 4:
      cpos = 0;
      goto LABEL_5;
    case 8:
      cpos = vpos + widget_data->box.height;
      goto LABEL_5;
    case 9:
      cpos = vpos - widget_data->box.height;
      goto LABEL_5;
    case 16:
      cpos = vpos - 1;
LABEL_5:
      format_and_display_text(widget_data, dlg_data, cpos);
      result = EVENT_PROCESSED;
      break;
    default:
      result = EVENT_NOT_PROCESSED;
      break;
  }
  return result;
}

//----- (08066BC0) --------------------------------------------------------
widget_handler_status_T __cdecl mouse_text(dialog_data *dlg_data, widget_data *widget_data)
{
  int vpos; // edi
  term_event *term_event; // ecx
  int height; // ebx
  int v5; // esi
  int v6; // esi
  unsigned int v8; // ecx
  int v9; // esi
  int v10; // ecx
  int v11; // [esp+Ch] [ebp-3Ch]
  int y; // [esp+24h] [ebp-24h]
  int x; // [esp+28h] [ebp-20h]

  vpos = widget_data->info.field.vpos;
  term_event = dlg_data->term_event;
  height = 0;
  v5 = dlg_data->box.width + dlg_data->box.x - 6;
  if ( v5 < 0 )
    v5 = 0;
  v11 = v5;
  y = term_event->info.mouse.y;
  x = term_event->info.mouse.x;
  if ( x < v5 )
    return 1;
  v6 = widget_data->box.y;
  if ( v6 < 0 )
    v6 = 0;
  if ( y < v6 || x >= v11 + 5 )
    return 1;
  if ( widget_data->box.height >= 0 )
    height = widget_data->box.height;
  if ( y >= v6 + height )
    return 1;
  v8 = term_event->info.mouse.button & 7;
  v9 = widget_data->info.text.scroller_height / 2
     - widget_data->info.text.scroller_last_dir
     + widget_data->info.text.scroller_y;
  if ( v8 == 2 )
  {
    v10 = vpos - 5;
    if ( v9 < y )
      v10 = vpos + 5;
    goto LABEL_20;
  }
  if ( v8 <= 2 )
  {
    if ( !v8 )
    {
      v10 = vpos - 1;
      if ( v9 < y )
        v10 = vpos + 1;
      goto LABEL_20;
    }
    return 1;
  }
  if ( v8 == 3 )
  {
    v10 = vpos - 1;
  }
  else
  {
    if ( v8 != 4 )
      return 1;
    v10 = vpos + 1;
  }
LABEL_20:
  widget_data->info.text.scroller_last_dir = 2 * (v10 > vpos) - 1;
  format_and_display_text(widget_data, dlg_data, v10);
  return 0;
}

//----- (08066CE0) --------------------------------------------------------
void __cdecl display_widget(dialog_data *dlg_data, widget_data *widget_data)
{
  void (*display)(void); // eax

  display = (void (*)(void))widget_data->widget->ops->display;
  if ( display )
    display();
}

//----- (08066D00) --------------------------------------------------------
evhook_status __cdecl bookmark_change_hook(va_list ap, void *data)
{
  evhook_status result; // eax

  result = EVENT_HOOK_STATUS_NEXT;
  if ( *(bookmark **)ap == bm_snapshot_last_folder )
    bm_snapshot_last_folder = 0;
  return result;
}

//----- (08066D30) --------------------------------------------------------
int __cdecl change_hook_folder_state(session *ses, option_elinks *current, option_elinks *changed)
{
  if ( !changed->value.number )
    bookmarks_dirty = 1;
  return 0;
}

//----- (08066D50) --------------------------------------------------------
void bookmarks_set_dirty()
{
  bookmarks_dirty = 1;
}

//----- (08066D60) --------------------------------------------------------
void bookmarks_unset_dirty()
{
  bookmarks_dirty = 0;
}

//----- (08066D70) --------------------------------------------------------
_BOOL4 bookmarks_are_dirty()
{
  return bookmarks_dirty == 1;
}

//----- (08066D90) --------------------------------------------------------
void __usercall free_bookmarks(list_head_elinks *bookmarks_list@<eax>, list_head_elinks *box_items@<edx>)
{
  list_head_elinks *v3; // esi
  list_head_elinks *i; // ebx
  list_head_elinks *next; // eax
  list_head_elinks *v6; // ebx
  list_head_elinks *j; // edx
  list_head_elinks *v8; // edi
  list_head_elinks *v9; // esi
  list_head_elinks *v10; // eax
  list_head_elinks *v11; // ebx
  list_head_elinks *k; // edx
  list_head_elinks *v13; // esi
  list_head_elinks *v14; // edx
  list_head_elinks *v15; // [esp+1Ch] [ebp-1Ch]

  v3 = bookmarks_list;
  for ( i = (list_head_elinks *)bookmarks_list->next; i != v3; i = (list_head_elinks *)i->next )
  {
    if ( i[3].prev != &i[3].prev )
      free_bookmarks((list_head_elinks *)((char *)i + 28), (list_head_elinks *)i[2].next + 1);
    mem_free(i[2].prev);
    mem_free(i[3].next);
  }
  next = (list_head_elinks *)box_items->next;
  v6 = (list_head_elinks *)box_items->next;
  if ( box_items->next == box_items )
  {
    v6 = box_items;
  }
  else
  {
    do
      v6 = (list_head_elinks *)v6->next;
    while ( v6 != box_items );
  }
  for ( j = (list_head_elinks *)box_items->prev; j != v6; j = (list_head_elinks *)j->prev )
    ;
  v8 = (list_head_elinks *)next->next;
  if ( next != v6 )
  {
    v15 = v3;
    do
    {
      v9 = v8;
      v8->prev = next->prev;
      *(_DWORD *)next->prev = next->next;
      mem_free(next);
      v8 = (list_head_elinks *)v8->next;
      next = v9;
    }
    while ( v9 != v6 );
    v3 = v15;
  }
  v10 = (list_head_elinks *)v3->next;
  v11 = (list_head_elinks *)v3->next;
  if ( v3->next == v3 )
  {
    v11 = v3;
  }
  else
  {
    do
      v11 = (list_head_elinks *)v11->next;
    while ( v11 != v3 );
  }
  for ( k = (list_head_elinks *)v3->prev; k != v11; k = (list_head_elinks *)k->prev )
    ;
  v13 = (list_head_elinks *)v10->next;
  if ( v10 != v11 )
  {
    v14 = (list_head_elinks *)v10->next;
    while ( 1 )
    {
      v14->prev = v10->prev;
      *(_DWORD *)v10->prev = v10->next;
      mem_free(v10);
      v14 = (list_head_elinks *)v13->next;
      v10 = v13;
      if ( v13 == v11 )
        break;
      v13 = (list_head_elinks *)v13->next;
    }
  }
  if ( bookmark_cache )
    free_hash(&bookmark_cache);
}

//----- (08066EB0) --------------------------------------------------------
bookmark *__cdecl get_bookmark_by_name(bookmark *folder, unsigned __int8 *title)
{
  list_head_elinks *p_child; // esi
  bookmark *next; // ebx

  p_child = &bookmarks;
  if ( folder )
    p_child = &folder->child;
  next = (bookmark *)p_child->next;
  if ( p_child->next == p_child )
    return 0;
  while ( strcmp((const char *)next->title, (const char *)title) )
  {
    next = next->next;
    if ( next == (bookmark *)p_child )
      return 0;
  }
  return next;
}

//----- (08066F10) --------------------------------------------------------
void __cdecl open_bookmark_folder(session *ses, unsigned __int8 *foldername)
{
  list_head_elinks *next; // esi
  bookmark *prev; // ebx
  bookmark *p_prev; // esi
  unsigned __int8 *url; // eax
  uri *translated_uri; // eax
  uri *v7; // eax
  uri *v8; // [esp+18h] [ebp-20h]
  bookmark *current; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = ses == 0 || foldername == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/bookmarks.c",
        errline = 734,
        elinks_internal("assertion foldername && ses failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    next = (list_head_elinks *)bookmarks.next;
    if ( bookmarks.next != &bookmarks )
    {
      while ( *((_DWORD *)next[2].next + 4) != 1 || strcmp((const char *)next[2].prev, (const char *)foldername) )
      {
        next = (list_head_elinks *)next->next;
        if ( next == &bookmarks )
          return;
      }
      prev = (bookmark *)next[3].prev;
      p_prev = (bookmark *)&next[3].prev;
      if ( prev != p_prev )
      {
        current = 0;
        do
        {
          while ( 1 )
          {
            if ( (unsigned int)(prev->box_item->type - 1) > 1 )
            {
              url = prev->url;
              if ( *url )
              {
                translated_uri = get_translated_uri(url, 0);
                if ( translated_uri )
                  break;
              }
            }
            prev = prev->next;
            if ( prev == p_prev )
              return;
          }
          v8 = translated_uri;
          if ( current )
          {
            open_uri_in_new_tab(ses, translated_uri, 1, 0);
            v7 = v8;
          }
          else
          {
            goto_uri(ses, translated_uri);
            v7 = v8;
            current = prev;
          }
          done_uri(v7);
          prev = prev->next;
        }
        while ( prev != p_prev );
      }
    }
  }
}

//----- (08067080) --------------------------------------------------------
unsigned __int8 *get_auto_save_bookmark_foldername_utf8()
{
  option_value *opt; // eax
  char *number; // ebx
  int cp_index; // esi
  int v4; // edi
  conv_table *translation_table; // esi
  int v6; // eax

  opt = get_opt_(config_options, "ui.sessions.auto_save_foldername");
  number = (char *)opt->number;
  if ( !*opt->string )
    return 0;
  cp_index = get_cp_index("System");
  v4 = get_cp_index("UTF-8");
  translation_table = get_translation_table(cp_index, v4);
  if ( !translation_table )
    return 0;
  v6 = strlen(number);
  return convert_string_elinks(translation_table, (unsigned __int8 *)number, v6, v4, CSM_NONE, 0, 0, 0);
}

//----- (08067130) --------------------------------------------------------
bookmark *__cdecl get_bookmark(unsigned __int8 *url)
{
  hash *v1; // esi
  unsigned int v3; // eax
  hash_item *hash_item; // eax

  v1 = bookmark_cache;
  if ( url && bookmark_cache && *url && (v3 = strlen((const char *)url), (hash_item = get_hash_item(v1, url, v3)) != 0) )
    return (bookmark *)hash_item->value;
  else
    return 0;
}

//----- (08067190) --------------------------------------------------------
int __cdecl update_bookmark(bookmark *bm, int codepage, unsigned __int8 *title, unsigned __int8 *url)
{
  conv_table *translation_table; // edi
  char *v5; // ebx
  int v6; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // esi
  unsigned __int8 *v9; // eax
  int event_id; // eax
  hash *v11; // edi
  unsigned __int8 *v12; // esi
  unsigned __int8 *v13; // eax
  unsigned int v15; // eax
  unsigned int v16; // eax
  hash_item *hash_item; // eax
  int v18; // [esp+8h] [ebp-40h]
  int utf8_cp; // [esp+2Ch] [ebp-1Ch]

  utf8_cp = get_cp_index("UTF-8");
  translation_table = get_translation_table(codepage, utf8_cp);
  if ( !translation_table )
    return 0;
  v5 = 0;
  if ( !url )
    goto LABEL_5;
  v6 = strlen((const char *)url);
  v7 = convert_string_elinks(translation_table, url, v6, utf8_cp, CSM_NONE, 0, 0, 0);
  v5 = (char *)v7;
  if ( !v7 )
    return 0;
  sanitize_url(v7);
LABEL_5:
  v8 = 0;
  if ( !title )
    goto LABEL_8;
  v18 = strlen((const char *)title);
  v9 = convert_string_elinks(translation_table, title, v18, utf8_cp, CSM_NONE, 0, 0, 0);
  v8 = v9;
  if ( v9 )
  {
    sanitize_title(v9);
LABEL_8:
    event_id = update_bookmark_event_id_7606;
    if ( update_bookmark_event_id_7606 == -1 )
    {
      event_id = get_event_id("bookmark-update");
      update_bookmark_event_id_7606 = event_id;
    }
    trigger_event(event_id, bm, v8, v5);
    if ( v8 )
    {
      if ( bm->title )
        mem_free(bm->title);
      bm->title = v8;
    }
    if ( !v5 )
      goto LABEL_23;
    v11 = bookmark_cache;
    if ( bookmark_cache )
    {
      v12 = bm->url;
      if ( v12 && *v12 )
      {
        v16 = strlen((const char *)bm->url);
        hash_item = get_hash_item(v11, v12, v16);
        if ( hash_item )
          del_hash_item(bookmark_cache, hash_item);
        v11 = bookmark_cache;
        if ( !bookmark_cache )
        {
          v13 = bm->url;
          if ( !v13 )
            goto LABEL_22;
          goto LABEL_21;
        }
      }
      if ( *v5 )
      {
        v15 = strlen(v5);
        add_hash_item(v11, (unsigned __int8 *)v5, v15, bm);
      }
    }
    v13 = bm->url;
    if ( !v13 )
    {
LABEL_22:
      bm->url = (unsigned __int8 *)v5;
LABEL_23:
      bookmarks_dirty = 1;
      return 1;
    }
LABEL_21:
    mem_free(v13);
    goto LABEL_22;
  }
  if ( !v5 )
    return 0;
  mem_free(v5);
  return 0;
}

//----- (080673D0) --------------------------------------------------------
bookmark *__cdecl add_bookmark(bookmark *root, int place, unsigned __int8 *title, unsigned __int8 *url)
{
  bookmark *v4; // ebx
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // eax
  listbox_item_type v8; // eax
  listbox_item *box_item; // ecx
  listbox_item *v10; // eax
  bookmark *next; // edx
  hash *inited; // edi
  unsigned __int8 *v13; // esi
  unsigned int v14; // eax
  bookmark *v16; // eax
  bookmark *v17; // [esp+0h] [ebp-38h]
  bookmark *v18; // [esp+0h] [ebp-38h]

  v4 = (bookmark *)mem_calloc(1u, 0x24u);
  if ( !v4 )
    return v4;
  v5 = stracpy(title);
  v4->title = v5;
  if ( !v5 )
  {
LABEL_33:
    v17 = v4;
    v4 = 0;
    mem_free(v17);
    return v4;
  }
  sanitize_title(v5);
  v6 = (unsigned __int8 *)&delete;
  if ( url )
    v6 = url;
  v7 = stracpy(v6);
  v4->url = v7;
  if ( !v7 )
  {
    mem_free(v4->title);
    goto LABEL_33;
  }
  sanitize_url(v7);
  v4->root = root;
  v4->child.prev = &v4->child;
  v4->child.next = &v4->child;
  if ( !url || (v8 = BI_LEAF, !*url) )
  {
    if ( !title || *title != 45 || (v8 = BI_SEPARATOR, title[1]) )
      v8 = BI_FOLDER;
  }
  box_item = 0;
  if ( root )
    box_item = root->box_item;
  v10 = add_listbox_item(&bookmark_browser, box_item, v8, v4, place == 0 ? 1 : -1);
  v4->box_item = v10;
  if ( v10 )
  {
    if ( place )
    {
      if ( root )
      {
        v4->next = *(bookmark **)root->child.prev;
        v4->prev = (bookmark *)root->child.prev;
        *(_DWORD *)root->child.prev = v4;
      }
      else
      {
        v4->next = *(bookmark **)bookmarks.prev;
        v4->prev = (bookmark *)bookmarks.prev;
        *(_DWORD *)bookmarks.prev = v4;
      }
      v4->next->prev = v4;
    }
    else
    {
      if ( root )
      {
        next = (bookmark *)root->child.next;
        v4->prev = (bookmark *)&root->child;
        v4->next = next;
        root->child.next = v4;
      }
      else
      {
        v16 = (bookmark *)bookmarks.next;
        v4->prev = (bookmark *)&bookmarks;
        v4->next = v16;
        bookmarks.next = v4;
      }
      v4->next->prev = v4;
    }
    inited = bookmark_cache;
    bookmarks_dirty = 1;
    if ( bookmark_cache || (inited = init_hash8(), (bookmark_cache = inited) != 0) )
    {
      v13 = v4->url;
      if ( v13 && *v13 )
      {
        v14 = strlen((const char *)v4->url);
        add_hash_item(inited, v13, v14, v4);
      }
    }
  }
  else
  {
    mem_free(v4->url);
    mem_free(v4->title);
    v18 = v4;
    v4 = 0;
    mem_free(v18);
  }
  return v4;
}

//----- (08067610) --------------------------------------------------------
bookmark *__cdecl add_bookmark_cp(
        bookmark *root,
        int place,
        int codepage,
        unsigned __int8 *title,
        unsigned __int8 *url)
{
  char *v5; // ebx
  int cp_index; // edi
  conv_table *translation_table; // esi
  bookmark *result; // eax
  int v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // edx
  unsigned __int8 *v13; // ebx
  bool v14; // si
  bookmark *v15; // eax
  unsigned __int8 *p; // [esp+2Ch] [ebp-1Ch]
  bookmark *pa; // [esp+2Ch] [ebp-1Ch]
  bookmark *pb; // [esp+2Ch] [ebp-1Ch]

  v5 = (char *)url;
  cp_index = get_cp_index("UTF-8");
  if ( !url )
    v5 = (char *)&delete;
  translation_table = get_translation_table(codepage, cp_index);
  result = 0;
  if ( translation_table )
  {
    v9 = strlen((const char *)title);
    p = convert_string_elinks(translation_table, title, v9, cp_index, CSM_NONE, 0, 0, 0);
    v10 = strlen(v5);
    v11 = convert_string_elinks(translation_table, (unsigned __int8 *)v5, v10, cp_index, CSM_NONE, 0, 0, 0);
    v12 = p;
    v13 = v11;
    v14 = v11 != 0;
    if ( v11 )
    {
      if ( p )
      {
        v15 = add_bookmark(root, place, p, v11);
        v12 = p;
        goto LABEL_6;
      }
    }
    else
    {
      v15 = 0;
      if ( p )
      {
LABEL_6:
        pa = v15;
        mem_free(v12);
        result = pa;
        goto LABEL_7;
      }
    }
    result = 0;
LABEL_7:
    if ( v14 )
    {
      pb = result;
      mem_free(v13);
      return pb;
    }
  }
  return result;
}

//----- (08067740) --------------------------------------------------------
void __usercall bookmark_terminal(terminal *term@<eax>, bookmark *folder@<edx>)
{
  list_head_elinks *prev; // ebx
  list_head_elinks *i; // esi
  session *next; // edi
  int term_cp; // [esp+2Ch] [ebp-82Ch]
  unsigned __int8 url[1024]; // [esp+3Ch] [ebp-81Ch] BYREF
  unsigned __int8 title[1024]; // [esp+43Ch] [ebp-41Ch] BYREF
  unsigned int v10; // [esp+83Ch] [ebp-1Ch]

  v10 = __readgsdword(0x14u);
  term_cp = get_terminal_codepage(term);
  prev = (list_head_elinks *)term->windows.prev;
  for ( i = &term->windows; prev != i; prev = (list_head_elinks *)prev->prev )
  {
    while ( 1 )
    {
      if ( prev[1].next == (void *)1 )
      {
        next = (session *)prev[2].next;
        if ( get_current_url(next, url, 0x400u) )
        {
          if ( get_current_title(next, title, 0x400u) )
            break;
        }
      }
      prev = (list_head_elinks *)prev->prev;
      if ( prev == i )
        return;
    }
    add_bookmark_cp(folder, 1, term_cp, title, url);
  }
}

//----- (08067830) --------------------------------------------------------
void __cdecl bookmark_terminal_tabs(terminal *term, unsigned __int8 *foldername)
{
  bookmark *v2; // eax

  v2 = add_bookmark(0, 1, foldername, 0);
  if ( v2 )
    bookmark_terminal(term, v2);
}

//----- (08067880) --------------------------------------------------------
void __cdecl delete_bookmark(bookmark *bm)
{
  bookmark *i; // eax
  hash *v2; // edi
  unsigned __int8 *url; // esi
  int event_id; // eax
  unsigned int v5; // eax
  hash_item *hash_item; // eax

  for ( i = (bookmark *)bm->child.next; i != (bookmark *)&bm->child; i = (bookmark *)bm->child.next )
    delete_bookmark(i);
  v2 = bookmark_cache;
  if ( bookmark_cache
    && (url = bm->url) != 0
    && *url
    && (v5 = strlen((const char *)bm->url), (hash_item = get_hash_item(v2, url, v5)) != 0) )
  {
    del_hash_item(bookmark_cache, hash_item);
    event_id = delete_bookmark_event_id_7397;
    if ( delete_bookmark_event_id_7397 == -1 )
      goto LABEL_10;
  }
  else
  {
    event_id = delete_bookmark_event_id_7397;
    if ( delete_bookmark_event_id_7397 == -1 )
    {
LABEL_10:
      event_id = get_event_id("bookmark-delete");
      delete_bookmark_event_id_7397 = event_id;
    }
  }
  trigger_event(event_id, bm);
  bm->next->prev = bm->prev;
  bm->prev->next = bm->next;
  bookmarks_dirty = 1;
  done_listbox_item(&bookmark_browser, bm->box_item);
  mem_free(bm->title);
  mem_free(bm->url);
  mem_free(bm);
}

//----- (08067980) --------------------------------------------------------
void __cdecl bookmark_auto_save_tabs(terminal *term)
{
  bookmark *next; // esi
  list_head_elinks *v2; // ebx
  list_head_elinks *v3; // eax
  unsigned __int8 *url; // eax
  unsigned __int8 *foldername; // [esp+1Ch] [ebp-1Ch]

  if ( !get_opt_(cmdline_options, "anonymous")->number )
  {
    if ( get_opt_(config_options, "ui.sessions.auto_save")->number )
    {
      foldername = get_auto_save_bookmark_foldername_utf8();
      if ( foldername )
      {
        next = (bookmark *)bookmarks.next;
        v2 = *(list_head_elinks **)bookmarks.next;
        if ( bookmarks.next != &bookmarks )
        {
          while ( 1 )
          {
            url = next->url;
            if ( url && *url || strcmp((const char *)next->title, (const char *)foldername) )
            {
              v3 = (list_head_elinks *)v2->next;
              if ( &bookmarks == v2 )
                break;
            }
            else
            {
              delete_bookmark(next);
              v3 = (list_head_elinks *)v2->next;
              if ( &bookmarks == v2 )
                break;
            }
            next = (bookmark *)v2;
            v2 = v3;
          }
        }
        bookmark_terminal_tabs(term, foldername);
        mem_free(foldername);
      }
    }
  }
}

//----- (08067A70) --------------------------------------------------------
void write_bookmarks()
{
  if ( get_opt_(cmdline_options, "anonymous")->number )
    bookmarks_dirty = 0;
  else
    bookmarks_write(&bookmarks);
}

//----- (08067AB0) --------------------------------------------------------
void __cdecl done_bookmarks(module *module)
{
  if ( bm_snapshot_last_folder )
    delete_bookmark(bm_snapshot_last_folder);
  bm_snapshot_last_folder = 0;
  write_bookmarks();
  free_bookmarks(&bookmarks, &bookmark_browser.root.child);
  free_last_searched_bookmark();
}

//----- (08067AF0) --------------------------------------------------------
evhook_status __cdecl bookmark_write_hook(va_list ap, void *data)
{
  option_value *opt; // eax
  unsigned __int8 *source; // esi
  int cp_index; // eax
  terminal *next; // ebx
  unsigned int i; // esi
  bookmark *v8; // eax
  bookmark *root; // [esp+2Ch] [ebp-2Ch]
  string string; // [esp+34h] [ebp-24h] BYREF
  unsigned __int8 title[16]; // [esp+3Ch] [ebp-1Ch] BYREF

  if ( get_opt_(config_options, "ui.sessions.snapshot")->number )
  {
    if ( !get_opt_(cmdline_options, "anonymous")->number )
    {
      if ( init_string(&string) )
      {
        add_to_string(&string, "Session snapshot");
        add_to_string(&string, " - ");
        opt = get_opt_(config_options, "ui.date_format");
        add_date_to_string(&string, opt->string, 0);
        source = string.source;
        cp_index = get_cp_index("System");
        root = add_bookmark_cp(0, 1, cp_index, source, 0);
        done_string(&string);
        if ( root )
        {
          if ( !get_opt_(cmdline_options, "anonymous")->number )
          {
            next = (terminal *)terminals.next;
            if ( terminals.next == terminals.prev )
            {
              bookmark_terminal((terminal *)terminals.next, root);
            }
            else if ( terminals.next != &terminals )
            {
              for ( i = 0; (unsigned int)elinks_ulongcat(title, 0, i, 4u, 0, 0xAu, 0) <= 3; ++i )
              {
                v8 = add_bookmark(root, 1, title, 0);
                if ( !v8 )
                  break;
                bookmark_terminal(next, v8);
                next = next->next;
                if ( next == (terminal *)&terminals )
                  break;
              }
            }
          }
          if ( bm_snapshot_last_folder )
            delete_bookmark(bm_snapshot_last_folder);
          bm_snapshot_last_folder = root;
        }
      }
    }
  }
  write_bookmarks();
  return 0;
}

//----- (08067CE0) --------------------------------------------------------
void read_bookmarks()
{
  bookmarks_read();
}

//----- (08067CF0) --------------------------------------------------------
void __cdecl init_bookmarks(module *module)
{
  register_change_hooks(bookmarks_change_hooks_7301);
  bookmarks_read();
}

//----- (08067D10) --------------------------------------------------------
void __cdecl lock_bookmark(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (08067D20) --------------------------------------------------------
void __cdecl unlock_bookmark(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (08067D30) --------------------------------------------------------
int __cdecl is_bookmark_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (08067D50) --------------------------------------------------------
listbox_item *__cdecl get_bookmark_root(listbox_item *item)
{
  int v1; // edx
  listbox_item *result; // eax

  v1 = *((_DWORD *)item->udata + 3);
  result = 0;
  if ( v1 )
    return *(listbox_item **)(v1 + 16);
  return result;
}

//----- (08067D70) --------------------------------------------------------
int __cdecl can_delete_bookmark(listbox_item *item)
{
  return 1;
}

//----- (08067D80) --------------------------------------------------------
void __cdecl bookmark_edit_cancel(dialog *dlg)
{
  --*((_DWORD *)dlg->udata2 + 2);
}

//----- (08067D90) --------------------------------------------------------
void __usercall update_depths(listbox_item *parent@<eax>)
{
  listbox_item *next; // ebx
  list_head_elinks *i; // edi
  bool v4; // zf

  next = (listbox_item *)parent->child.next;
  for ( i = &parent->child; next != (listbox_item *)i; next = next->next )
  {
    while ( 1 )
    {
      v4 = next->type == BI_FOLDER;
      next->depth = parent->depth + 1;
      if ( v4 )
        break;
      next = next->next;
      if ( next == (listbox_item *)i )
        return;
    }
    update_depths(next);
  }
}

//----- (08067DE0) --------------------------------------------------------
void __cdecl delete_bookmark_item(listbox_item *item, int last)
{
  bookmark *udata; // ebx
  int refcount; // ecx

  udata = (bookmark *)item->udata;
  if ( !assert_failed )
  {
    refcount = udata->object.refcount;
    assert_failed = refcount != 0;
    if ( refcount )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
      errline = 138;
      elinks_internal("assertion !is_object_used(bookmark) failed!");
    }
  }
  delete_bookmark(udata);
  if ( last )
    write_bookmarks();
}

//----- (08067E60) --------------------------------------------------------
uri *__cdecl get_bookmark_uri(listbox_item *item)
{
  unsigned __int8 *v1; // eax

  v1 = (unsigned __int8 *)*((_DWORD *)item->udata + 6);
  if ( v1 && *v1 )
    return get_translated_uri(v1, 0);
  else
    return 0;
}

//----- (08067E90) --------------------------------------------------------
unsigned __int8 *__cdecl get_bookmark_text(listbox_item *item, terminal *term)
{
  void *udata; // edi
  int cp_index; // ebx
  int terminal_codepage; // esi
  conv_table *translation_table; // ebx
  unsigned __int8 *result; // eax
  char *v7; // edi
  int v8; // eax

  udata = item->udata;
  cp_index = get_cp_index("UTF-8");
  terminal_codepage = get_terminal_codepage(term);
  translation_table = get_translation_table(cp_index, terminal_codepage);
  result = 0;
  if ( translation_table )
  {
    v7 = (char *)*((_DWORD *)udata + 5);
    v8 = strlen(v7);
    return convert_string_elinks(translation_table, (unsigned __int8 *)v7, v8, terminal_codepage, CSM_NONE, 0, 0, 0);
  }
  return result;
}

//----- (08067F20) --------------------------------------------------------
unsigned __int8 *__usercall _0@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (08067F90) --------------------------------------------------------
unsigned __int8 *__cdecl get_bookmark_info(listbox_item *item, terminal *term)
{
  void *udata; // esi
  int terminal_codepage; // eax
  int v4; // ebx
  conv_table *translation_table; // edi
  const char *v7; // eax
  int v8; // eax
  unsigned __int8 *v9; // eax
  char *v10; // esi
  int v11; // eax
  unsigned __int8 *chars; // [esp+28h] [ebp-30h]
  int utf8_cp; // [esp+2Ch] [ebp-2Ch]
  string info; // [esp+38h] [ebp-20h] BYREF

  udata = item->udata;
  utf8_cp = get_cp_index("UTF-8");
  terminal_codepage = get_terminal_codepage(term);
  v4 = terminal_codepage;
  if ( item->type == BI_FOLDER )
    return 0;
  translation_table = get_translation_table(utf8_cp, terminal_codepage);
  if ( !translation_table || !init_string(&info) )
    return 0;
  v7 = (const char *)_0((unsigned __int8 *)&byte_81279A0, term);
  add_format_to_string(&info, "%s: ", v7);
  chars = (unsigned __int8 *)*((_DWORD *)udata + 5);
  v8 = strlen((const char *)chars);
  convert_string_elinks(translation_table, chars, v8, v4, CSM_NONE, 0, add_converted_bytes_to_string, &info);
  v9 = _0((unsigned __int8 *)&byte_812B6C9, term);
  add_format_to_string(&info, &byte_81279A6, v9);
  v10 = (char *)*((_DWORD *)udata + 6);
  v11 = strlen(v10);
  convert_string_elinks(
    translation_table,
    (unsigned __int8 *)v10,
    v11,
    v4,
    CSM_NONE,
    0,
    add_converted_bytes_to_string,
    &info);
  return info.source;
}

//----- (080680D0) --------------------------------------------------------
void __cdecl add_converted_bytes_to_string(void *data, unsigned __int8 *buf, int buflen)
{
  int v3; // ecx
  int v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // edi
  char *v7; // eax
  unsigned int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_8;
  if ( !buf || !data || buflen < 0 )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( !assert_failed )
      goto LABEL_4;
LABEL_8:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_4:
  if ( !buflen )
    return;
  v3 = *((_DWORD *)data + 1);
  v4 = buflen + v3;
  v5 = v3 + 255;
  LOBYTE(v5) = 0;
  v6 = (v4 + 256) & 0xFFFFFF00;
  if ( v6 > v5 )
  {
    v10 = v4;
    v8 = v5;
    v7 = (char *)mem_realloc(*(void **)data, (v4 + 256) & 0xFFFFFF00);
    if ( !v7 )
      return;
    *(_DWORD *)data = v7;
    memset(&v7[v8], 0, v6 - v8);
    v4 = v10;
  }
  if ( *(_DWORD *)data )
  {
    v9 = v4;
    memcpy((void *)(*((_DWORD *)data + 1) + *(_DWORD *)data), buf, buflen);
    *(_BYTE *)(*(_DWORD *)data + v9) = 0;
    *((_DWORD *)data + 1) = v9;
  }
}

//----- (08068210) --------------------------------------------------------
void free_last_searched_bookmark()
{
  if ( bm_last_searched_title )
    mem_free(bm_last_searched_title);
  bm_last_searched_title = 0;
  if ( bm_last_searched_url )
    mem_free(bm_last_searched_url);
  bm_last_searched_url = 0;
}

//----- (08068250) --------------------------------------------------------
widget_handler_status_T __cdecl push_search_button(dialog_data *dlg_data, widget_data *widget_data)
{
  terminal *term; // esi
  int cp_index; // edi
  conv_table *translation_table; // edi
  int v5; // eax
  int v6; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edi
  unsigned __int8 *charsa; // [esp+34h] [ebp-24h]
  unsigned __int8 *chars; // [esp+34h] [ebp-24h]
  session *ses; // [esp+38h] [ebp-20h]
  int cp; // [esp+3Ch] [ebp-1Ch]

  ses = (session *)dlg_data->dlg->udata;
  term = dlg_data->win->term;
  if ( bm_last_searched_title )
  {
    if ( bm_last_searched_url )
    {
      cp_index = get_cp_index("UTF-8");
      cp = get_terminal_codepage(term);
      translation_table = get_translation_table(cp_index, cp);
      if ( translation_table )
      {
        charsa = (unsigned __int8 *)bm_last_searched_title;
        v5 = strlen(bm_last_searched_title);
        chars = convert_string_elinks(translation_table, charsa, v5, cp, CSM_NONE, 0, 0, 0);
        v6 = strlen(bm_last_searched_url);
        v7 = convert_string_elinks(
               translation_table,
               (unsigned __int8 *)bm_last_searched_url,
               v6,
               cp,
               CSM_NONE,
               0,
               0,
               0);
        v8 = v7;
        if ( v7 )
        {
          if ( chars )
          {
            do_edit_dialog(
              term,
              1,
              "Search bookmarks",
              chars,
              v7,
              ses,
              dlg_data,
              bookmark_search_do,
              0,
              0,
              EDIT_DLG_SEARCH);
            mem_free(chars);
            mem_free(v8);
            return 0;
          }
          mem_free(v7);
        }
        else if ( chars )
        {
          mem_free(chars);
        }
      }
    }
  }
  do_edit_dialog(term, 1, "Search bookmarks", 0, 0, ses, dlg_data, bookmark_search_do, 0, 0, EDIT_DLG_SEARCH);
  return 0;
}

//----- (08068450) --------------------------------------------------------
void __cdecl launch_bm_add_dialog(
        terminal *term,
        dialog_data *parent,
        session *ses,
        unsigned __int8 *title,
        unsigned __int8 *url)
{
  do_edit_dialog(term, 1, "Add bookmark", title, url, ses, parent, bookmark_add_add, 0, term, EDIT_DLG_ADD);
}

//----- (080684B0) --------------------------------------------------------
void __cdecl launch_bm_add_doc_dialog(terminal *term, dialog_data *parent, session *ses)
{
  launch_bm_add_dialog(term, parent, ses, 0, 0);
}

//----- (080684F0) --------------------------------------------------------
widget_handler_status_T __cdecl push_add_button(dialog_data *dlg_data, widget_data *widget_data)
{
  launch_bm_add_doc_dialog(dlg_data->win->term, dlg_data, (session *)dlg_data->dlg->udata);
  return 0;
}

//----- (08068520) --------------------------------------------------------
widget_handler_status_T __cdecl push_edit_button(dialog_data *dlg_data, widget_data *edit_btn)
{
  listbox_item *sel; // eax
  int cp_index; // esi
  int terminal_codepage; // edi
  conv_table *translation_table; // esi
  int v6; // eax
  int v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // esi
  bool v11; // di
  unsigned __int8 *chars; // [esp+34h] [ebp-24h]
  unsigned __int8 *charsa; // [esp+34h] [ebp-24h]
  unsigned __int8 *p; // [esp+38h] [ebp-20h]
  _DWORD *done_data; // [esp+3Ch] [ebp-1Ch]

  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( !sel )
    return 0;
  done_data = sel->udata;
  cp_index = get_cp_index("UTF-8");
  terminal_codepage = get_terminal_codepage(dlg_data->win->term);
  translation_table = get_translation_table(cp_index, terminal_codepage);
  if ( !translation_table )
    return 0;
  chars = (unsigned __int8 *)done_data[5];
  v6 = strlen((const char *)chars);
  p = convert_string_elinks(translation_table, chars, v6, terminal_codepage, CSM_NONE, 0, 0, 0);
  charsa = (unsigned __int8 *)done_data[6];
  v7 = strlen((const char *)charsa);
  v8 = convert_string_elinks(translation_table, charsa, v7, terminal_codepage, CSM_NONE, 0, 0, 0);
  v9 = p;
  v10 = v8;
  v11 = v8 != 0;
  if ( !v8 )
  {
    if ( !p )
      return 0;
    goto LABEL_5;
  }
  if ( p )
  {
    ++done_data[2];
    do_edit_dialog(
      dlg_data->win->term,
      1,
      "Edit bookmark",
      p,
      v8,
      (session *)dlg_data->dlg->udata,
      dlg_data,
      bookmark_edit_done,
      bookmark_edit_cancel,
      done_data,
      EDIT_DLG_ADD);
    v9 = p;
LABEL_5:
    mem_free(v9);
  }
  if ( v11 )
    mem_free(v10);
  return 0;
}

//----- (080686B0) --------------------------------------------------------
void __cdecl bookmark_search_do(void *data)
{
  int v1; // esi
  int terminal_codepage; // edi
  char *v3; // esi
  conv_table *translation_table; // ebx
  int v5; // eax
  unsigned __int8 *v6; // ebx
  conv_table *v7; // ebx
  int v8; // eax
  int v9; // eax
  listbox_data *listbox_widget_data; // eax
  conv_table *v11; // [esp+0h] [ebp-68h]
  char *s; // [esp+28h] [ebp-40h]
  dialog_data *dlg_data; // [esp+2Ch] [ebp-3Ch]
  bookmark_search_ctx ctx; // [esp+38h] [ebp-30h] BYREF

  if ( assert_failed )
    goto LABEL_25;
  memset(&ctx, 0, 16);
  ctx.utf8_cp = -1;
  ctx.system_cp = -1;
  v1 = *((_DWORD *)data + 1);
  assert_failed = v1 == 0;
  if ( !v1 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
    errline = 750;
    elinks_internal("assertion dlg->udata != NULL failed: Bookmark search with NULL udata in dialog");
    if ( assert_failed )
    {
LABEL_25:
      assert_failed = 0;
      return;
    }
  }
  dlg_data = (dialog_data *)*((_DWORD *)data + 1);
  terminal_codepage = get_terminal_codepage(dlg_data->win->term);
  ctx.system_cp = get_cp_index("System");
  ctx.utf8_cp = get_cp_index("UTF-8");
  v3 = (char *)*((_DWORD *)data + 12);
  s = (char *)*((_DWORD *)data + 24);
  translation_table = get_translation_table(terminal_codepage, ctx.system_cp);
  if ( !translation_table )
    goto free_all;
  v5 = strlen(v3);
  v11 = translation_table;
  v6 = 0;
  ctx.title = convert_string_elinks(v11, (unsigned __int8 *)v3, v5, ctx.system_cp, CSM_NONE, 0, 0, 0);
  if ( ctx.title )
  {
    v7 = get_translation_table(terminal_codepage, ctx.utf8_cp);
    if ( v7 )
    {
      v8 = strlen(s);
      ctx.url = convert_string_elinks(v7, (unsigned __int8 *)s, v8, ctx.utf8_cp, CSM_NONE, 0, 0, 0);
      if ( ctx.url )
      {
        v9 = strlen(v3);
        v6 = convert_string_elinks(v7, (unsigned __int8 *)v3, v9, ctx.utf8_cp, CSM_NONE, 0, 0, 0);
        if ( v6 )
        {
          if ( bm_last_searched_title )
            mem_free(bm_last_searched_title);
          bm_last_searched_title = (char *)stracpy(v6);
          if ( bm_last_searched_title )
          {
            if ( bm_last_searched_url )
              mem_free(bm_last_searched_url);
            bm_last_searched_url = (char *)stracpy(ctx.url);
            if ( bm_last_searched_url )
            {
              listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
              traverse_listbox_items_list(listbox_widget_data->sel, listbox_widget_data, 0, 0, test_search_0, &ctx);
              if ( ctx.found )
                listbox_sel_move(dlg_data->widgets_data, ctx.offset - 1);
            }
            else
            {
              if ( bm_last_searched_title )
                mem_free(bm_last_searched_title);
              bm_last_searched_title = 0;
            }
          }
        }
        goto LABEL_17;
      }
    }
free_all:
    v6 = 0;
LABEL_17:
    if ( ctx.title )
      mem_free(ctx.title);
  }
  if ( ctx.url )
    mem_free(ctx.url);
  if ( v6 )
    mem_free(v6);
}

//----- (080689A0) --------------------------------------------------------
int __cdecl test_search_0(listbox_item *item, void *data_, int *offset)
{
  void *udata; // esi
  _BYTE *v4; // eax
  conv_table *translation_table; // edi
  char *v7; // esi
  int v8; // eax
  unsigned __int8 *v9; // esi

  if ( *((_DWORD *)data_ + 3) )
  {
    udata = item->udata;
    if ( !assert_failed )
    {
      if ( *((_DWORD *)data_ + 1) && *(_DWORD *)data_ )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/dialogs.c";
        errline = 664;
        elinks_internal("assertion ctx->title && ctx->url failed!");
      }
    }
    if ( **(_BYTE **)data_ && c_strcasestr(*((const char **)udata + 6), *(const char **)data_) )
    {
      *((_DWORD *)data_ + 2) = 1;
LABEL_12:
      *offset = 0;
      goto LABEL_8;
    }
    v4 = (_BYTE *)*((_DWORD *)data_ + 1);
    *((_DWORD *)data_ + 2) = 0;
    if ( *v4 )
    {
      translation_table = get_translation_table(*((_DWORD *)data_ + 4), *((_DWORD *)data_ + 5));
      if ( translation_table )
      {
        v7 = (char *)*((_DWORD *)udata + 5);
        v8 = strlen(v7);
        v9 = convert_string_elinks(
               translation_table,
               (unsigned __int8 *)v7,
               v8,
               *((_DWORD *)data_ + 5),
               CSM_NONE,
               0,
               0,
               0);
        if ( v9 )
        {
          *((_DWORD *)data_ + 2) = strcasestr(v9, *((_DWORD *)data_ + 1)) != 0;
          mem_free(v9);
        }
      }
      if ( *((_DWORD *)data_ + 2) )
        goto LABEL_12;
    }
  }
  else
  {
    *((_DWORD *)data_ + 2) = 0;
  }
LABEL_8:
  ++*((_DWORD *)data_ + 3);
  return 0;
}
// 80596D8: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08068B20) --------------------------------------------------------
move_bookmark_flags __usercall do_move_bookmark@<eax>(
        bookmark *dest@<eax>,
        int insert_as_child@<edx>,
        list_head_elinks *src@<ecx>,
        listbox_data *box)
{
  bookmark *next; // esi
  listbox_item *box_item; // eax
  char v7; // dl
  void **v8; // edi
  widget_data *v9; // ebx
  bookmark *v10; // edx
  int v11; // eax
  listbox_item *v12; // eax
  list_head_elinks *v13; // eax
  bookmark *v15; // eax
  bookmark *v16; // [esp+1Ch] [ebp-2Ch]
  move_bookmark_flags result; // [esp+28h] [ebp-20h]
  list_head_elinks *v20; // [esp+2Ch] [ebp-1Ch]

  if ( move_bookmark_event_id_7252 == -1 )
    move_bookmark_event_id_7252 = get_event_id("bookmark-move");
  next = (bookmark *)src->next;
  result = MOVE_BOOKMARK_NONE;
  v20 = *(list_head_elinks **)src->next;
  if ( src->next != src )
  {
    box_item = next->box_item;
    v7 = *((_BYTE *)box_item + 24);
    if ( (v7 & 4) != 0 )
      goto LABEL_5;
LABEL_21:
    if ( box_item->type == BI_FOLDER )
    {
LABEL_22:
      result |= do_move_bookmark(dest, insert_as_child, &next->child, box);
      next = (bookmark *)v20;
      v13 = (list_head_elinks *)v20->next;
      if ( src != v20 )
        goto LABEL_20;
    }
    else
    {
      while ( 1 )
      {
        v13 = (list_head_elinks *)v20->next;
        next = (bookmark *)v20;
        if ( src == v20 )
          break;
LABEL_20:
        v20 = v13;
        box_item = next->box_item;
        v7 = *((_BYTE *)box_item + 24);
        if ( (v7 & 4) == 0 )
          goto LABEL_21;
LABEL_5:
        if ( next == dest || next == move_cache_root_avoid )
        {
          result |= 2u;
          if ( box_item->type == BI_FOLDER )
            goto LABEL_22;
        }
        else
        {
          result |= 1u;
          *((_BYTE *)box_item + 24) = v7 & 0xFB;
          trigger_event(move_bookmark_event_id_7252, next, dest);
          v8 = (void **)bookmark_browser.dialogs.next;
          if ( bookmark_browser.dialogs.next != &bookmark_browser.dialogs )
          {
            v16 = dest;
            do
            {
              v9 = (widget_data *)((char *)v8[2] + 40);
              if ( get_listbox_widget_data(v9)->top == next->box_item )
                listbox_sel_move(v9, 1);
              v8 = (void **)*v8;
            }
            while ( v8 != &bookmark_browser.dialogs.next );
            dest = v16;
          }
          next->box_item->next->prev = next->box_item->prev;
          next->box_item->prev->next = next->box_item->next;
          next->next->prev = next->prev;
          next->prev->next = next->next;
          if ( insert_as_child )
          {
            v10 = (bookmark *)dest->child.next;
            next->prev = (bookmark *)&dest->child;
            next->next = v10;
            dest->child.next = next;
            next->next->prev = next;
            next->box_item->next = (listbox_item *)dest->box_item->child.next;
            next->box_item->prev = (listbox_item *)&dest->box_item->child;
            dest->box_item->child.next = next->box_item;
            next->box_item->next->prev = next->box_item;
          }
          else
          {
            v15 = dest->next;
            next->prev = dest;
            next->next = v15;
            dest->next = next;
            next->next->prev = next;
            next->box_item->next = dest->box_item->next;
            next->box_item->prev = dest->box_item;
            dest->box_item->next = next->box_item;
            next->box_item->next->prev = next->box_item;
            dest = dest->root;
          }
          next->root = dest;
          v11 = 0;
          if ( dest )
            v11 = dest->box_item->depth + 1;
          next->box_item->depth = v11;
          v12 = next->box_item;
          dest = next;
          insert_as_child = 0;
          if ( v12->type == BI_FOLDER )
          {
            update_depths(v12);
            insert_as_child = 0;
          }
        }
      }
    }
  }
  return result;
}

//----- (08068D60) --------------------------------------------------------
widget_handler_status_T __cdecl push_move_button(dialog_data *dlg_data, widget_data *blah)
{
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // ecx
  listbox_data *v4; // edi
  int v5; // edx
  bookmark *udata; // eax
  bookmark *root; // ecx
  bookmark *v8; // ebx
  char v9; // al
  unsigned __int8 *v11; // [esp+8h] [ebp-30h]
  unsigned __int8 *v12; // [esp+10h] [ebp-28h]

  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  sel = listbox_widget_data->sel;
  v4 = listbox_widget_data;
  if ( !sel )
    return 0;
  v5 = 0;
  udata = (bookmark *)sel->udata;
  if ( sel->type == BI_FOLDER )
    v5 = *((_BYTE *)sel + 24) & 1;
  move_cache_root_avoid = 0;
  root = udata->root;
  if ( root )
  {
    v8 = 0;
    do
    {
      if ( (*((_BYTE *)root->box_item + 24) & 4) != 0 )
        v8 = root;
      root = root->root;
    }
    while ( root );
    move_cache_root_avoid = v8;
  }
  v9 = do_move_bookmark(udata, v5, &bookmarks, v4);
  if ( (v9 & 1) == 0 )
  {
    if ( (v9 & 2) != 0 )
    {
      v12 = "You are trying to move the marked folder inside itself. To move the folder to a different location select th"
            "e new location before pressing the Move button.";
      v11 = "Cannot move folder inside itself";
    }
    else
    {
      v12 = "To move bookmarks, first mark all the bookmarks (or folders) you want to move.  This can be done with the In"
            "sert key if you're using the default key-bindings.  An asterisk will appear near all marked bookmarks.  Now "
            "move to where you want to have the stuff moved to, and press the \"Move\" button.";
      v11 = "Nothing to move";
    }
    info_box(dlg_data->win->term, (msgbox_flags)0, v11, ALIGN_LEFT, v12);
    return 0;
  }
  bookmarks_set_dirty();
  write_bookmarks();
  update_hierbox_browser(&bookmark_browser);
  return 0;
}

//----- (08068E60) --------------------------------------------------------
widget_handler_status_T __cdecl push_add_folder_button(dialog_data *dlg_data, widget_data *widget_data)
{
  input_dialog(
    dlg_data->win->term,
    0,
    "Add folder",
    "Folder name",
    dlg_data,
    0,
    1024,
    0,
    0,
    0,
    0,
    (void (*)(void *, unsigned __int8 *))do_add_folder,
    0);
  return 0;
}

//----- (08068EE0) --------------------------------------------------------
void __usercall do_add_bookmark(
        terminal *term@<eax>,
        dialog_data *dlg_data@<edx>,
        unsigned __int8 *title@<ecx>,
        unsigned __int8 *url)
{
  int terminal_codepage; // edx
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // eax
  bookmark *udata; // esi
  bookmark *root; // ecx
  bookmark *v11; // eax
  bookmark *v12; // edi
  listbox_item *box_item; // eax
  bookmark *next; // eax
  int codepage; // [esp+2Ch] [ebp-1Ch]

  terminal_codepage = get_terminal_codepage(term);
  if ( dlg_data
    && (codepage = terminal_codepage,
        listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data),
        terminal_codepage = codepage,
        (sel = listbox_widget_data->sel) != 0) )
  {
    udata = (bookmark *)sel->udata;
    if ( sel->type != BI_FOLDER || (root = (bookmark *)sel->udata, (*((_BYTE *)sel + 24) & 1) == 0) )
      root = udata->root;
  }
  else
  {
    udata = 0;
    root = 0;
  }
  v11 = add_bookmark_cp(root, 1, terminal_codepage, title, url);
  v12 = v11;
  if ( v11 )
  {
    if ( udata )
    {
      if ( udata != v11->root )
      {
        if ( udata->box_item )
        {
          box_item = v11->box_item;
          if ( box_item )
          {
            box_item->next->prev = box_item->prev;
            v12->box_item->prev->next = v12->box_item->next;
            v12->next->prev = v12->prev;
            v12->prev->next = v12->next;
            next = udata->next;
            v12->prev = udata;
            v12->next = next;
            udata->next = v12;
            v12->next->prev = v12;
            v12->box_item->next = udata->box_item->next;
            v12->box_item->prev = udata->box_item;
            udata->box_item->next = v12->box_item;
            v12->box_item->next->prev = v12->box_item;
          }
        }
      }
    }
    write_bookmarks();
    if ( dlg_data )
      listbox_sel(dlg_data->widgets_data, v12->box_item);
  }
}

//----- (08069010) --------------------------------------------------------
void __cdecl do_add_folder(dialog_data *dlg_data, unsigned __int8 *foldername)
{
  do_add_bookmark(dlg_data->win->term, dlg_data, foldername, 0);
}

//----- (08069030) --------------------------------------------------------
void __cdecl bookmark_add_add(void *data)
{
  do_add_bookmark(
    *((terminal **)data + 2),
    *((dialog_data **)data + 1),
    *((unsigned __int8 **)data + 12),
    *((unsigned __int8 **)data + 24));
}

//----- (08069060) --------------------------------------------------------
widget_handler_status_T __cdecl push_add_separator_button(dialog_data *dlg_data, widget_data *widget_data)
{
  do_add_bookmark(dlg_data->win->term, dlg_data, (unsigned __int8 *)"-", (unsigned __int8 *)&delete);
  redraw_dialog(dlg_data, 1);
  return 0;
}

//----- (080690A0) --------------------------------------------------------
void __cdecl bookmark_edit_done(void *data)
{
  bookmark *v1; // esi
  int terminal_codepage; // eax

  v1 = (bookmark *)*((_DWORD *)data + 2);
  terminal_codepage = get_terminal_codepage(*(const terminal **)(**((_DWORD **)data + 1) + 20));
  update_bookmark(v1, terminal_codepage, *((unsigned __int8 **)data + 12), *((unsigned __int8 **)data + 24));
  --v1->object.refcount;
  write_bookmarks();
}

//----- (080690F0) --------------------------------------------------------
void __cdecl bookmark_terminal_tabs_ok(void *term_void, unsigned __int8 *foldername)
{
  int terminal_codepage; // ebx
  int cp_index; // esi
  conv_table *translation_table; // ebx
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // ebx
  int v7; // [esp+8h] [ebp-40h]

  terminal_codepage = get_terminal_codepage((const terminal *)term_void);
  cp_index = get_cp_index("UTF-8");
  translation_table = get_translation_table(terminal_codepage, cp_index);
  if ( translation_table )
  {
    v7 = strlen((const char *)foldername);
    v5 = convert_string_elinks(translation_table, foldername, v7, cp_index, CSM_NONE, 0, 0, 0);
    v6 = v5;
    if ( v5 )
    {
      bookmark_terminal_tabs((terminal *)term_void, v5);
      mem_free(v6);
    }
  }
}

//----- (080691B0) --------------------------------------------------------
void __cdecl launch_bm_add_link_dialog(terminal *term, dialog_data *parent, session *ses)
{
  unsigned __int8 *current_link_name; // eax
  unsigned __int8 *current_link_url; // [esp+2Ch] [ebp-82Ch]
  unsigned __int8 url[1024]; // [esp+3Ch] [ebp-81Ch] BYREF
  unsigned __int8 title[1024]; // [esp+43Ch] [ebp-41Ch] BYREF
  unsigned int v7; // [esp+83Ch] [ebp-1Ch]

  v7 = __readgsdword(0x14u);
  current_link_url = get_current_link_url(ses, url, 0x400u);
  current_link_name = get_current_link_name(ses, title, 0x400u);
  launch_bm_add_dialog(term, parent, ses, current_link_name, current_link_url);
}

//----- (08069250) --------------------------------------------------------
void __cdecl bookmark_manager(session *ses)
{
  free_last_searched_bookmark();
  bookmark_browser.expansion_callback = bookmarks_set_dirty;
  hierbox_browser_0(&bookmark_browser, ses);
}

//----- (08069280) --------------------------------------------------------
void __cdecl bookmark_terminal_tabs_dialog(terminal *term)
{
  int terminal_codepage; // eax
  int v2; // edi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v4; // eax
  option_value *opt; // eax
  string string; // [esp+48h] [ebp-20h] BYREF

  if ( init_string(&string) )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v2 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v2;
      }
    }
    v4 = gettext(&byte_81279FF);
    add_to_string(&string, v4);
    add_to_string(&string, " - ");
    opt = get_opt_(config_options, "ui.date_format");
    add_date_to_string(&string, opt->string, 0);
    input_dialog(
      term,
      0,
      "Bookmark tabs",
      "Enter folder name",
      term,
      0,
      1024,
      string.source,
      0,
      0,
      0,
      bookmark_terminal_tabs_ok,
      0);
    done_string(&string);
  }
}

//----- (080693C0) --------------------------------------------------------
void __cdecl bookmarks_write(list_head_elinks *bookmarks_list)
{
  option_value *opt; // eax
  int number; // esi
  bookmarks_backend *v3; // ebx
  int v4; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // esi
  secure_save_info *v7; // [esp+1Ch] [ebp-1Ch]

  opt = get_opt_(config_options, "bookmarks.file_format");
  number = opt->number;
  v3 = bookmarks_backends[opt->number];
  if ( bookmarks_are_dirty() || number != loaded_backend_num )
  {
    if ( v3 )
    {
      if ( v3->write )
      {
        if ( elinks_home )
        {
          if ( v3->filename )
          {
            v4 = (int)v3->filename(1);
            if ( v4 )
            {
              v5 = straconcat((const unsigned __int8 *)elinks_home, v4, 0);
              v6 = v5;
              if ( v5 )
              {
                v7 = secure_open(v5);
                mem_free(v6);
                if ( v7 )
                {
                  v3->write(v7, bookmarks_list);
                  if ( !secure_close(v7) )
                    bookmarks_unset_dirty();
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (080694B0) --------------------------------------------------------
void bookmarks_read()
{
  option_value *opt; // eax
  int number; // edi
  bookmarks_backend *v2; // ebx
  unsigned __int8 *v3; // esi
  int v4; // eax
  FILE *stream; // [esp+1Ch] [ebp-1Ch]
  FILE *streama; // [esp+1Ch] [ebp-1Ch]

  opt = get_opt_(config_options, "bookmarks.file_format");
  number = opt->number;
  v2 = bookmarks_backends[opt->number];
  if ( v2 )
  {
    if ( v2->read )
    {
      if ( v2->filename )
      {
        v3 = (unsigned __int8 *)v2->filename(0);
        if ( v3 )
        {
          if ( !elinks_home || (v3 = straconcat((const unsigned __int8 *)elinks_home, v3, 0)) != 0 )
          {
            v4 = fopen64(v3, "rb");
            if ( elinks_home )
            {
              stream = (FILE *)v4;
              mem_free(v3);
              v4 = (int)stream;
            }
            if ( v4 )
            {
              streama = (FILE *)v4;
              v2->read((FILE *)v4);
              fclose(streama);
              bookmarks_unset_dirty();
              loaded_backend_num = number;
            }
          }
        }
      }
    }
  }
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08069580) --------------------------------------------------------
unsigned __int8 *__cdecl filename_bookmarks_default(int writing)
{
  return "bookmarks";
}

//----- (08069590) --------------------------------------------------------
void __usercall write_bookmarks_default_inner(
        const write_bookmarks_default *out@<eax>,
        list_head_elinks *bookmarks_list@<edx>)
{
  list_head_elinks *i; // ebx
  char *prev; // edi
  int v5; // eax
  char *next; // edi
  int v7; // eax
  unsigned __int8 *v8; // eax
  const char *v9; // edx
  unsigned __int8 *v10; // edi
  const char *v11; // eax
  unsigned __int8 *p; // [esp+2Ch] [ebp-1Ch]

  for ( i = (list_head_elinks *)bookmarks_list->next; i != bookmarks_list; i = (list_head_elinks *)i->next )
  {
    prev = (char *)i[2].prev;
    v5 = strlen(prev);
    p = convert_string_elinks(out->conv_table, (unsigned __int8 *)prev, v5, out->codepage, CSM_NONE, 0, 0, 0);
    next = (char *)i[3].next;
    v7 = strlen(next);
    v8 = convert_string_elinks(out->conv_table, (unsigned __int8 *)next, v7, out->codepage, CSM_NONE, 0, 0, 0);
    v9 = &delete;
    v10 = v8;
    if ( v8 )
      v9 = (const char *)v8;
    v11 = &delete;
    if ( p )
      v11 = (const char *)p;
    secure_fprintf(out->ssi, "%s\t%s\t%d\t", v11, v9, *((_DWORD *)i[2].next + 5));
    if ( *((_DWORD *)i[2].next + 4) == 1 )
    {
      secure_fputc(out->ssi, 70);
      if ( out->save_folder_state )
      {
        if ( (*((_BYTE *)i[2].next + 24) & 1) != 0 )
          secure_fputc(out->ssi, 69);
      }
    }
    secure_fputc(out->ssi, 10);
    if ( v10 && p || (secsave_errno_0 = SS_ERR_OTHER, out->ssi->err = 12, p) )
      mem_free(p);
    if ( v10 )
      mem_free(v10);
    if ( out->ssi->err )
      break;
    if ( i[3].prev != &i[3].prev )
      write_bookmarks_default_inner(out, (list_head_elinks *)((char *)i + 28));
  }
}

//----- (08069750) --------------------------------------------------------
void __cdecl write_bookmarks_default_0(secure_save_info *ssi, list_head_elinks *bookmarks_list)
{
  int cp_index; // eax
  write_bookmarks_default out; // [esp+10h] [ebp-18h] BYREF

  out.ssi = ssi;
  out.save_folder_state = get_opt_(config_options, "bookmarks.folder_state")->number;
  out.codepage = get_cp_index("System");
  cp_index = get_cp_index("UTF-8");
  out.conv_table = get_translation_table(cp_index, out.codepage);
  write_bookmarks_default_inner(&out, bookmarks_list);
}

//----- (080697C0) --------------------------------------------------------
void __cdecl read_bookmarks_default(FILE *f)
{
  char *v1; // eax
  char *v2; // esi
  char *v3; // eax
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  char *v7; // eax
  int v8; // edx
  char *v9; // ecx
  char *v10; // ebx
  char *v11; // eax
  bookmark *root; // eax
  bookmark *v13; // eax
  char v14; // al
  int v15; // eax
  bookmark *v16; // ecx
  int v17; // [esp+24h] [ebp-C44h]
  int v18; // [esp+24h] [ebp-C44h]
  int file_cp; // [esp+28h] [ebp-C40h]
  int v20; // [esp+2Ch] [ebp-C3Ch]
  bookmark *v21; // [esp+30h] [ebp-C38h]
  char *s; // [esp+38h] [ebp-C30h]
  unsigned __int8 *url; // [esp+3Ch] [ebp-C2Ch]
  unsigned __int8 in_buffer[3079]; // [esp+45h] [ebp-C23h] BYREF
  unsigned int v25; // [esp+C4Ch] [ebp-1Ch]

  v25 = __readgsdword(0x14u);
  v20 = 0;
  v21 = 0;
  file_cp = get_cp_index("System");
  while ( fgets((char *)in_buffer, 3079, f) )
  {
    v1 = strchr((const char *)in_buffer, 9);
    v2 = v1;
    if ( v1 && in_buffer != (unsigned __int8 *)v1 && v1 - (char *)in_buffer <= 1023 )
    {
      *v1 = 0;
      url = (unsigned __int8 *)(v1 + 1);
      s = v1 + 1;
      v3 = strchr(v1 + 1, 9);
      if ( !v3 )
      {
        v8 = 0;
        goto LABEL_36;
      }
      if ( v3 - (char *)url <= 1023 )
      {
        *v3 = 0;
        s = v3 + 1;
        v4 = strtol(v3 + 1, 0, 10);
        v5 = 0;
        if ( v21 )
          v5 = v20 + 1;
        v6 = 0;
        if ( v4 >= 0 )
        {
          v6 = v4;
          if ( v5 <= v4 )
            v6 = v5;
        }
        v17 = v6;
        v7 = strchr(s, 9);
        v8 = v17;
        if ( v7 )
        {
          *v7 = 0;
          v9 = s;
          v10 = v7 + 1;
          if ( v7 != (char *)-1 )
            v9 = v7 + 1;
          s = v9;
          goto LABEL_17;
        }
LABEL_36:
        v10 = 0;
LABEL_17:
        v18 = v8;
        v11 = strchr(s, 10);
        if ( v11 )
        {
          *v11 = 0;
          root = 0;
          if ( v18 )
          {
            if ( v20 == v18 )
            {
              root = v21->root;
            }
            else
            {
              root = v21;
              if ( v18 <= v20 )
              {
                v15 = v20;
                v16 = v21;
                do
                {
                  --v15;
                  v16 = v16->root;
                }
                while ( v15 != v18 );
                root = v16->root;
              }
            }
          }
          v13 = add_bookmark_cp(root, 1, file_cp, in_buffer, url);
          v21 = v13;
          if ( v2[1] || in_buffer[0] != 45 || in_buffer[1] )
          {
            if ( v10 )
            {
              v14 = *v10;
              if ( v21 )
              {
                if ( v14 )
                {
                  do
                  {
                    if ( v14 == 69 )
                    {
                      *((_BYTE *)v21->box_item + 24) |= 1u;
                      if ( !++v10 )
                        break;
                    }
                    else
                    {
                      if ( v14 == 70 )
                        v21->box_item->type = BI_FOLDER;
                      if ( !++v10 )
                        break;
                    }
                    v14 = *v10;
                  }
                  while ( *v10 );
                }
              }
            }
            v20 = v18;
          }
          else
          {
            v13->box_item->type = BI_SEPARATOR;
            v20 = v18;
          }
        }
      }
    }
  }
}

//----- (08069AB0) --------------------------------------------------------
unsigned __int8 *__cdecl filename_bookmarks_xbel(int writing)
{
  unsigned __int8 *result; // eax

  if ( !writing )
    return "bookmarks.xbel";
  result = 0;
  if ( readok )
    return "bookmarks.xbel";
  return result;
}

//----- (08069AE0) --------------------------------------------------------
void __cdecl on_element_close(void *data, const char *name)
{
  current_node = current_node->parent;
}

//----- (08069B00) --------------------------------------------------------
void __usercall print_xml_entities(secure_save_info *ssi@<eax>, const unsigned __int8 *str@<edx>)
{
  int v4; // eax
  string entitized; // [esp+18h] [ebp-20h] BYREF

  entitized.source = 0;
  entitized.length = 0;
  if ( init_string(&entitized) && (v4 = strlen((const char *)str), add_html_to_string(&entitized, str, v4)) )
  {
    secure_fputs(ssi, (const char *)entitized.source);
  }
  else
  {
    secsave_errno_0 = SS_ERR_OUT_OF_MEM;
    ssi->err = 12;
  }
  done_string(&entitized);
}

//----- (08069B90) --------------------------------------------------------
void __usercall write_bookmarks_list(
        secure_save_info *ssi@<eax>,
        list_head_elinks *bookmarks_list@<edx>,
        int n@<ecx>,
        int folder_state)
{
  list_head_elinks *next; // edi
  int v6; // esi
  secure_save_info *v7; // edi
  int i; // ebx
  _DWORD *v9; // edx
  int v10; // eax
  const char *v11; // eax
  int j; // esi
  secure_save_info *v13; // edi
  int k; // ebx
  int m; // esi
  secure_save_info *v16; // edi
  int ii; // ebx
  int v18; // [esp+14h] [ebp-24h]
  list_head_elinks *v20; // [esp+1Ch] [ebp-1Ch]
  int v21; // [esp+1Ch] [ebp-1Ch]
  list_head_elinks *v22; // [esp+1Ch] [ebp-1Ch]
  int v23; // [esp+1Ch] [ebp-1Ch]
  list_head_elinks *v24; // [esp+1Ch] [ebp-1Ch]

  next = (list_head_elinks *)bookmarks_list->next;
  if ( bookmarks_list->next != bookmarks_list )
  {
    v6 = n + 1;
    v18 = n + 2;
    do
    {
      if ( v6 > 0 )
      {
        v20 = next;
        v7 = ssi;
        for ( i = 0; i < v6; ++i )
          secure_fputs(v7, s);
        ssi = v7;
        next = v20;
      }
      v9 = next[2].next;
      v10 = v9[4];
      if ( v10 == 1 )
      {
        if ( folder_state && (v9[6] & 1) != 0 )
        {
          secure_fputs(ssi, "<folder folded=\"");
          v11 = &byte_812785C;
        }
        else
        {
          secure_fputs(ssi, "<folder folded=\"");
          v11 = "yes";
        }
        secure_fputs(ssi, v11);
        secure_fputs(ssi, "\">\n");
        if ( v18 > 0 )
        {
          v21 = v6;
          for ( j = 0; j < v18; ++j )
            secure_fputs(ssi, s);
          v6 = v21;
        }
        secure_fputs(ssi, "<title>");
        print_xml_entities(ssi, (const unsigned __int8 *)next[2].prev);
        secure_fputs(ssi, "</title>\n");
        if ( next[3].prev != &next[3].prev )
          write_bookmarks_list(ssi, (list_head_elinks *)((char *)next + 28), v18, folder_state);
        if ( v6 > 0 )
        {
          v22 = next;
          v13 = ssi;
          for ( k = 0; k < v6; ++k )
            secure_fputs(v13, s);
          ssi = v13;
          next = v22;
        }
        secure_fputs(ssi, "</folder>\n\n");
      }
      else if ( v10 )
      {
        if ( v10 == 2 )
          secure_fputs(ssi, "<separator/>\n\n");
      }
      else
      {
        secure_fputs(ssi, "<bookmark href=\"");
        print_xml_entities(ssi, (const unsigned __int8 *)next[3].next);
        secure_fputs(ssi, "\">\n");
        if ( v18 > 0 )
        {
          v23 = v6;
          for ( m = 0; m < v18; ++m )
            secure_fputs(ssi, s);
          v6 = v23;
        }
        secure_fputs(ssi, "<title>");
        print_xml_entities(ssi, (const unsigned __int8 *)next[2].prev);
        secure_fputs(ssi, "</title>\n");
        if ( v6 > 0 )
        {
          v24 = next;
          v16 = ssi;
          for ( ii = 0; ii < v6; ++ii )
            secure_fputs(v16, s);
          ssi = v16;
          next = v24;
        }
        secure_fputs(ssi, "</bookmark>\n\n");
      }
      next = (list_head_elinks *)next->next;
    }
    while ( next != bookmarks_list );
  }
}

//----- (08069E20) --------------------------------------------------------
void __cdecl write_bookmarks_xbel(secure_save_info *ssi, list_head_elinks *bookmarks_list)
{
  int number; // edi

  number = get_opt_(config_options, "bookmarks.folder_state")->number;
  secure_fputs(
    ssi,
    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
    "<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\"\n"
    "\t\t       \"http://www.python.org/topics/xml/dtds/xbel-1.0.dtd\">\n"
    "\n"
    "<xbel>\n"
    "\n"
    "\n");
  write_bookmarks_list(ssi, bookmarks_list, 0, number);
  secure_fputs(ssi, "\n</xbel>\n");
}

//----- (08069E90) --------------------------------------------------------
void __usercall free_node(tree_node *node@<eax>)
{
  tree_node *next; // esi
  list_head_elinks *v3; // ebx
  tree_node *v4; // edx
  tree_node *i; // ebx
  tree_node *j; // ecx
  unsigned __int8 *name; // eax
  unsigned __int8 *v8; // ecx
  tree_node *v9; // [esp+18h] [ebp-20h]
  list_head_elinks *p_attrs; // [esp+1Ch] [ebp-1Ch]

  next = (tree_node *)node->attrs.next;
  p_attrs = &node->attrs;
  v3 = (list_head_elinks *)next;
  if ( next != (tree_node *)&node->attrs )
  {
    do
    {
      mem_free(v3[1].next);
      mem_free(v3[1].prev);
      v3 = (list_head_elinks *)v3->next;
    }
    while ( v3 != p_attrs );
    next = (tree_node *)node->attrs.next;
  }
  v4 = next;
  for ( i = next; i != (tree_node *)p_attrs; i = (tree_node *)i->name )
    ;
  for ( j = (tree_node *)node->attrs.prev; i != j; j = (tree_node *)j->text )
    ;
  name = next->name;
  if ( next != i )
  {
    v8 = next->name;
    while ( 1 )
    {
      *((_DWORD *)v8 + 1) = v4->text;
      *(_DWORD *)v4->text = v4->name;
      v9 = (tree_node *)name;
      mem_free(v4);
      v8 = v9->name;
      v4 = v9;
      if ( i == v9 )
        break;
      name = v9->name;
    }
  }
  if ( node->name )
    mem_free(node->name);
  if ( node->text )
    mem_free(node->text);
  mem_free(node);
}

//----- (08069F60) --------------------------------------------------------
void __usercall free_xbeltree(tree_node *node@<eax>)
{
  tree_node *v1; // ebx
  tree_node *children; // eax
  tree_node *next; // esi

  v1 = node;
  if ( node )
  {
    do
    {
      children = v1->children;
      if ( children )
        free_xbeltree(children);
      next = v1->next;
      free_node(v1);
      v1 = next;
    }
    while ( next );
  }
}

//----- (08069F90) --------------------------------------------------------
void __cdecl on_text(void *data, const XML_Char *text, int len)
{
  size_t v3; // esi
  unsigned __int8 *v4; // edi
  char *v5; // eax
  char *v6; // edi
  int v7; // ebx
  int v8; // esi
  char *i; // eax
  char v10; // dl
  tree_node *v11; // [esp+34h] [ebp-24h]
  unsigned __int8 *v12; // [esp+38h] [ebp-20h]
  char *src; // [esp+3Ch] [ebp-1Ch]

  if ( len )
  {
    v3 = 0;
    v4 = current_node->text;
    if ( v4 )
      v3 = strlen((const char *)current_node->text);
    v5 = (char *)mem_realloc(v4, v3 + len + 1);
    v6 = v5;
    if ( v5 )
    {
      strncpy(&v5[v3], text, len);
      v6[v3 + len] = 0;
      v11 = current_node;
      src = (char *)strlen(v6);
      v12 = (unsigned __int8 *)mem_alloc((size_t)(src + 1));
      if ( v12 )
      {
        v7 = 0;
        if ( (int)src > 0 )
        {
          v8 = 0;
          for ( i = 0; i != src; ++i )
          {
            while ( 1 )
            {
              v10 = i[(_DWORD)v6];
              if ( (unsigned __int8)(v10 - 9) <= 0x17u && ((1 << (v10 - 9)) & 0x800013) != 0 )
                break;
              v8 = 0;
              ++i;
              v12[v7++] = v10;
              if ( src == i )
                goto LABEL_14;
            }
            if ( !v8 )
              v12[v7++] = 32;
            v8 = 1;
          }
        }
LABEL_14:
        v12[v7] = 0;
      }
      v11->text = v12;
      mem_free(v6);
    }
  }
}

//----- (0806A0B0) --------------------------------------------------------
void __cdecl on_element_open(void *data, const char *name, const char **attr)
{
  tree_node *v4; // edi
  tree_node *v5; // eax
  tree_node *v6; // ebx
  list_head_elinks *p_attrs; // eax
  tree_node *v8; // eax
  tree_node *children; // edx
  _DWORD *v10; // ebx
  unsigned __int8 *v11; // edi
  unsigned __int8 *v12; // eax
  tree_node *v13; // eax
  unsigned __int8 *v14; // [esp+18h] [ebp-20h]
  unsigned __int8 *v15; // [esp+18h] [ebp-20h]

  v4 = current_node;
  v5 = (tree_node *)mem_calloc(1u, 0x20u);
  v6 = v5;
  if ( v5 )
  {
    if ( !v4 )
      v4 = v5;
    v5->parent = v4;
    p_attrs = &v5->attrs;
    v6->attrs.prev = p_attrs;
    v6->attrs.next = p_attrs;
    if ( root_node )
    {
      v8 = current_node;
      children = current_node->children;
      current_node->children = v6;
      if ( children )
      {
        v6->next = children;
        v8->children->prev = 0;
      }
    }
    else
    {
      root_node = v6;
    }
    current_node = v6;
    v6->name = stracpy((const unsigned __int8 *)name);
    if ( current_node->name )
    {
      while ( *attr )
      {
        v10 = mem_calloc(1u, 0x10u);
        v11 = stracpy((const unsigned __int8 *)*attr);
        v12 = stracpy((const unsigned __int8 *)attr[1]);
        if ( !v10 )
          goto LABEL_16;
        if ( !v11 || !v12 )
        {
          v14 = v12;
          mem_free(v10);
          v12 = v14;
LABEL_16:
          if ( v11 )
          {
            v15 = v12;
            mem_free(v11);
            v12 = v15;
          }
          if ( v12 )
            mem_free(v12);
          free_node(current_node);
          return;
        }
        v10[2] = v11;
        attr += 2;
        v10[3] = v12;
        v13 = current_node;
        *v10 = *(_DWORD *)current_node->attrs.prev;
        v10[1] = v13->attrs.prev;
        *(_DWORD *)v13->attrs.prev = v10;
        *(_DWORD *)(*v10 + 4) = v10;
      }
    }
    else
    {
      mem_free(current_node);
    }
  }
}
// 806A1BA: conditional instruction was optimized away because ebx.4!=0

//----- (0806A230) --------------------------------------------------------
int __usercall xbeltree_to_bookmarks_list@<eax>(
        const read_bookmarks_xbel *preload@<eax>,
        tree_node *node@<edx>,
        bookmark *current_parent@<ecx>)
{
  tree_node *j; // ebx
  const char *v4; // eax
  unsigned __int8 *v5; // edi
  int v6; // esi
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  bookmark *v9; // eax
  tree_node *children; // edx
  bool v11; // zf
  bookmark *v12; // ecx
  tree_node *v13; // ebx
  tree_node *i; // ebx
  int utf8_cp; // esi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *text; // eax
  const char *next; // eax
  _BYTE *v20; // eax
  bookmark *v21; // eax
  bookmark *v23; // [esp+24h] [ebp-24h]
  tree_node *v25; // [esp+2Ch] [ebp-1Ch]

  v25 = node;
  if ( !node )
    return 1;
  while ( memcmp(v25->name, "bookmark", 9u) )
  {
    if ( !memcmp(v25->name, "folder", 7u) )
    {
      for ( i = v25->children; i; i = i->next )
      {
        if ( !strcmp("title", (const char *)i->name) )
          break;
      }
      utf8_cp = preload->utf8_cp;
      if ( preload->utf8_cp != current_charset )
      {
        cp_mime_name = get_cp_mime_name(preload->utf8_cp);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = utf8_cp;
      }
      if ( !i || (text = i->text) == 0 )
        text = gettext("No title");
      v23 = add_bookmark(current_parent, 0, text, 0);
      if ( !v23 )
        return 0;
      next = (const char *)v25->attrs.next;
      if ( next != (const char *)&v25->attrs )
      {
        while ( strcmp(*((const char **)next + 2), "folded") )
        {
          next = *(const char **)next;
          if ( next == (const char *)&v25->attrs )
            goto LABEL_45;
        }
        v20 = (_BYTE *)*((_DWORD *)next + 3);
        if ( v20 && *v20 == 110 && v20[1] == 111 && !v20[2] )
          *((_BYTE *)v23->box_item + 24) |= 1u;
      }
LABEL_45:
      lastbm_8068 = v23;
    }
    else if ( !strcmp((const char *)v25->name, "separator") )
    {
      v21 = add_bookmark(current_parent, 0, (unsigned __int8 *)"-", (unsigned __int8 *)&delete);
      if ( !v21 )
        return 0;
      v21->root = current_parent;
      lastbm_8068 = v21;
    }
LABEL_20:
    children = v25->children;
    if ( children )
    {
      v11 = memcmp(v25->name, "folder", 7u) == 0;
      v12 = current_parent;
      if ( v11 )
        v12 = lastbm_8068;
      if ( !xbeltree_to_bookmarks_list(preload, children, v12) )
        return 0;
    }
    v13 = v25->next;
    v25 = v13;
    if ( !v13 )
      return 1;
  }
  for ( j = v25->children; j; j = j->next )
  {
    if ( !strcmp("title", (const char *)j->name) )
      break;
  }
  v4 = (const char *)v25->attrs.next;
  if ( v4 == (const char *)&v25->attrs )
  {
LABEL_46:
    v5 = 0;
  }
  else
  {
    while ( strcmp(*((const char **)v4 + 2), "href") )
    {
      v4 = *(const char **)v4;
      if ( v4 == (const char *)&v25->attrs )
        goto LABEL_46;
    }
    v5 = (unsigned __int8 *)*((_DWORD *)v4 + 3);
  }
  v6 = preload->utf8_cp;
  if ( preload->utf8_cp != current_charset )
  {
    v7 = get_cp_mime_name(preload->utf8_cp);
    bind_textdomain_codeset("elinks", v7);
    current_charset = v6;
  }
  if ( !v5 )
    v5 = gettext("No URL");
  if ( !j || (v8 = j->text) == 0 )
    v8 = gettext("No title");
  v9 = add_bookmark(current_parent, 0, v8, v5);
  if ( v9 )
  {
    v9->root = current_parent;
    lastbm_8068 = v9;
    goto LABEL_20;
  }
  return 0;
}

//----- (0806A570) --------------------------------------------------------
void __cdecl read_bookmarks_xbel_0(FILE *f)
{
  int v1; // edi
  unsigned __int8 *v2; // eax
  enum XML_Error ErrorCode; // eax
  const XML_LChar *v4; // edi
  XML_Size CurrentColumnNumber; // esi
  XML_Size CurrentLineNumber; // ebx
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  int v9; // [esp+28h] [ebp-2030h]
  XML_ParserStruct *p; // [esp+2Ch] [ebp-202Ch]
  read_bookmarks_xbel preload; // [esp+38h] [ebp-2020h] BYREF
  unsigned __int8 in_buffer[8192]; // [esp+3Ch] [ebp-201Ch] BYREF
  unsigned int v13; // [esp+203Ch] [ebp-1Ch]

  v13 = __readgsdword(0x14u);
  readok = 0;
  p = XML_ParserCreate(0);
  if ( p )
  {
    XML_SetElementHandler(p, on_element_open, on_element_close);
    XML_SetCharacterDataHandler(p, on_text);
    while ( 1 )
    {
      v1 = fread(in_buffer, 1u, 0x2000u, f);
      if ( ferror(f) )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/backend/xbel.c";
        errline = 116;
        v2 = gettext("read_bookmarks_xbel(): Error reading %s");
        elinks_error(v2, "bookmarks.xbel");
        goto LABEL_5;
      }
      v9 = feof(f);
      if ( XML_Parse(p, (const char *)in_buffer, v1, v9) == XML_STATUS_ERROR )
        break;
      if ( v9 )
      {
        preload.utf8_cp = get_cp_index("UTF-8");
        readok = xbeltree_to_bookmarks_list(&preload, root_node->children, 0);
        goto LABEL_5;
      }
    }
    ErrorCode = XML_GetErrorCode(p);
    v4 = XML_ErrorString(ErrorCode);
    CurrentColumnNumber = XML_GetCurrentColumnNumber(p);
    CurrentLineNumber = XML_GetCurrentLineNumber(p);
    v7 = gettext("Parse error while processing XBEL bookmarks in %s at line %d column %d:\n%s");
    usrerror(v7, "bookmarks.xbel", CurrentLineNumber, CurrentColumnNumber, v4);
LABEL_5:
    XML_ParserFree(p);
    free_xbeltree(root_node);
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/bookmarks/backend/xbel.c";
    errline = 105;
    v8 = gettext("read_bookmarks_xbel(): Error in XML_ParserCreate()");
    elinks_error(v8);
  }
}

//----- (0806A790) --------------------------------------------------------
unsigned __int64 get_cache_size()
{
  return cache_size;
}

//----- (0806A7A0) --------------------------------------------------------
int get_cache_entry_count()
{
  list_head_elinks *next; // edx
  int result; // eax

  next = (list_head_elinks *)cache_entries.next;
  for ( result = 0; next != &cache_entries; ++result )
    next = (list_head_elinks *)next->next;
  return result;
}

//----- (0806A7D0) --------------------------------------------------------
int get_cache_entry_used_count()
{
  list_head_elinks *next; // edx
  int result; // eax
  bool v2; // zf

  next = (list_head_elinks *)cache_entries.next;
  for ( result = 0; next != &cache_entries; result += !v2 )
  {
    v2 = next[1].next == 0;
    next = (list_head_elinks *)next->next;
  }
  return result;
}

//----- (0806A800) --------------------------------------------------------
int __cdecl cache_entry_is_valid(cache_entry *cached)
{
  list_head_elinks *next; // eax

  next = (list_head_elinks *)cache_entries.next;
  if ( cache_entries.next == &cache_entries )
    return 0;
  if ( cache_entries.next != cached )
  {
    while ( 1 )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &cache_entries )
        break;
      if ( cached == (cache_entry *)next )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (0806A840) --------------------------------------------------------
int get_cache_entry_loading_count()
{
  int v0; // esi
  cache_entry *i; // ebx
  int v2; // eax

  v0 = 0;
  for ( i = (cache_entry *)cache_entries.next; i != (cache_entry *)&cache_entries; v0 += v2 )
  {
    v2 = is_entry_used(i);
    i = i->next;
  }
  return v0;
}

//----- (0806A880) --------------------------------------------------------
uri *__cdecl redirect_cache(cache_entry *cached, unsigned __int8 *location, int get, int incomplete)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *post; // edx
  char v6; // al
  char *v8; // eax
  unsigned __int8 *uri_string; // eax
  unsigned __int8 *uristring[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( incomplete || *location != 47 || location[1] )
  {
    v4 = join_urls(cached->uri, location);
    uristring[0] = v4;
  }
  else
  {
    uri_string = get_uri_string(cached->uri, URI_ORIGINAL);
    if ( !uri_string )
      return 0;
    uristring[0] = uri_string;
    add_to_strn(uristring, location);
    v4 = uristring[0];
  }
  if ( !v4 )
    return 0;
  post = cached->uri->post;
  if ( post && !get && (*((_BYTE *)cached + 92) & 4) == 0 )
  {
    if ( !assert_failed )
    {
      v8 = strchr((const char *)v4, 1);
      assert_failed = v8 != 0;
      if ( v8 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 738;
        elinks_internal("assertion !strchr(uristring, POST_CHAR) failed!");
      }
      post = cached->uri->post;
    }
    add_to_strn(uristring, post - 1);
  }
  if ( cached->redirect )
    done_uri(cached->redirect);
  cached->redirect = get_uri(uristring[0], (uri_component)0);
  v6 = (4 * (get & 1)) | *((_BYTE *)cached + 92) & 0xFB;
  *((_BYTE *)cached + 92) = v6;
  if ( incomplete >= 0 )
    *((_BYTE *)cached + 92) = (8 * (incomplete & 1)) | v6 & 0xF7;
  mem_free(uristring[0]);
  return cached->redirect;
}

//----- (0806AA00) --------------------------------------------------------
fragment *__usercall frag_alloc@<eax>(size_t size@<eax>)
{
  size_t v1; // esi
  void *v2; // eax
  void *v3; // ebx

  v1 = size + 35;
  v2 = mem_mmap_alloc(size + 35);
  v3 = v2;
  if ( v2 )
    memset(v2, 0, v1);
  return (fragment *)v3;
}

//----- (0806AA40) --------------------------------------------------------
fragment *__cdecl get_cache_fragment(cache_entry *cached)
{
  list_head_elinks *next; // edi
  list_head_elinks *p_frag; // esi
  fragment *v3; // ecx
  int v5; // eax
  list_head_elinks *v6; // ebx
  int v7; // eax
  size_t v8; // eax
  size_t v9; // edx
  list_head_elinks *v10; // eax
  _DWORD *p_next; // ecx
  fragment *v12; // eax
  int v13; // esi
  void **prev; // eax
  fragment *v15; // [esp+1Ch] [ebp-2Ch]
  signed int v16; // [esp+20h] [ebp-28h]
  void **v17; // [esp+20h] [ebp-28h]
  fragment *new_frag; // [esp+2Ch] [ebp-1Ch]
  fragment *new_fraga; // [esp+2Ch] [ebp-1Ch]

  next = (list_head_elinks *)cached->frag.next;
  p_frag = &cached->frag;
  if ( next == &cached->frag )
    return 0;
  v3 = (fragment *)cached->frag.next;
  if ( next[1] )
    return 0;
  if ( next == cached->frag.prev )
    return v3;
  new_frag = (fragment *)next->next;
  if ( p_frag == next->next )
    return v3;
  v5 = LODWORD(new_frag->offset) + -LODWORD(new_frag->prev->length) - LODWORD(new_frag->prev->offset);
  if ( v5 > 0 )
    return v3;
  if ( v5 )
  {
LABEL_13:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
    errline = 506;
    elinks_internal("fragments overlap");
    return 0;
  }
  v6 = (list_head_elinks *)next->next;
  while ( 1 )
  {
    v6 = (list_head_elinks *)v6->next;
    if ( p_frag == v6 )
      break;
    v7 = (int)v6[1].next - *((_DWORD *)v6->prev + 4) - *((_DWORD *)v6->prev + 2);
    if ( v7 > 0 )
    {
      if ( v6 == (list_head_elinks *)new_frag )
        return v3;
      break;
    }
    if ( v7 )
      goto LABEL_13;
  }
  v8 = 0;
  v9 = 0;
  if ( v6 != next )
  {
    v10 = (list_head_elinks *)next->next;
    p_next = cached->frag.next;
    while ( 1 )
    {
      v9 += p_next[4];
      if ( v6 == v10 )
        break;
      p_next = &v10->next;
      v10 = (list_head_elinks *)v10->next;
    }
    v3 = (fragment *)cached->frag.next;
    v8 = v9;
  }
  v16 = v9;
  v15 = v3;
  v12 = frag_alloc(v8);
  v3 = v15;
  new_fraga = v12;
  if ( !v12 )
  {
    if ( next[2] )
      return v3;
    return 0;
  }
  v12->length = v16;
  v12->real_length = v16;
  if ( v6 != next )
  {
    v13 = 0;
    do
    {
      memcpy(&new_fraga->data[v13], &next[4], (size_t)next[2].next);
      prev = (void **)next->prev;
      v13 += (int)next[2].next;
      *((_DWORD *)next->next + 1) = prev;
      *(_DWORD *)next->prev = next->next;
      v17 = prev;
      mem_mmap_free(next, (size_t)next[3].next + 35);
      next = (list_head_elinks *)*v17;
    }
    while ( v6 != *v17 );
    p_frag = &cached->frag;
  }
  new_fraga->next = (fragment *)cached->frag.next;
  v3 = new_fraga;
  new_fraga->prev = (fragment *)p_frag;
  cached->frag.next = new_fraga;
  new_fraga->next->prev = new_fraga;
  return v3;
}

//----- (0806ABE0) --------------------------------------------------------
cache_entry *__cdecl find_in_cache(uri *uri)
{
  cache_entry *next; // ebx
  int protocol; // edi
  const uri *v3; // eax
  cache_entry *v4; // eax

  next = (cache_entry *)cache_entries.next;
  protocol = uri->protocol;
  if ( cache_entries.next == &cache_entries )
    return 0;
  while ( 1 )
  {
    if ( (*((_BYTE *)next + 92) & 0x10) != 0 )
    {
      v3 = protocol == 15 ? next->proxy_uri : next->uri;
      if ( compare_uri(v3, uri, URI_BASE) )
        break;
    }
    next = next->next;
    if ( next == (cache_entry *)&cache_entries )
      return 0;
  }
  if ( cache_entries.next != next )
  {
    next->next->prev = next->prev;
    next->prev->next = next->next;
    v4 = (cache_entry *)cache_entries.next;
    next->prev = (cache_entry *)&cache_entries;
    next->next = v4;
    cache_entries.next = next;
    next->next->prev = next;
  }
  return next;
}

//----- (0806AC90) --------------------------------------------------------
cache_entry *__cdecl follow_cached_redirects(cache_entry *cached)
{
  cache_entry *result; // eax
  uri *redirect; // edx
  int v3; // ebx

  result = cached;
  if ( cached )
  {
    redirect = cached->redirect;
    v3 = 1;
    if ( redirect )
    {
      while ( 1 )
      {
        result = find_in_cache(redirect);
        if ( !result )
          break;
        redirect = result->redirect;
        if ( !redirect )
          break;
        if ( ++v3 == 11 )
          return 0;
      }
    }
  }
  return result;
}

//----- (0806ACE0) --------------------------------------------------------
cache_entry *__cdecl get_redirected_cache_entry(uri *uri)
{
  cache_entry *result; // eax

  result = find_in_cache(uri);
  if ( result )
    return follow_cached_redirects(result);
  return result;
}

//----- (0806AD10) --------------------------------------------------------
cache_entry *__cdecl get_cache_entry(uri *uri)
{
  cache_entry *v1; // ebx
  unsigned __int8 *fragment; // edx
  cache_entry *v4; // edi
  uri *proxied_uri; // eax
  uri *proxy_uri; // eax
  int v7; // eax
  cache_entry *next; // eax

  v1 = find_in_cache(uri);
  if ( !assert_failed )
  {
    fragment = uri->fragment;
    assert_failed = fragment != 0;
    if ( fragment )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 131;
      elinks_internal("assertion !uri->fragment failed: Fragment in URI (%s)", (const char *)uri->string);
    }
  }
  if ( !v1 )
  {
    shrink_memory(0);
    v4 = (cache_entry *)mem_calloc(1u, 0x64u);
    if ( v4 )
    {
      proxied_uri = get_proxied_uri(uri);
      v4->uri = proxied_uri;
      if ( proxied_uri )
      {
        proxy_uri = get_proxy_uri(uri, 0);
        v4->proxy_uri = proxy_uri;
        if ( proxy_uri )
        {
          *((_BYTE *)v4 + 92) |= 0x18u;
          v1 = v4;
          v4->frag.prev = &v4->frag;
          v4->frag.next = &v4->frag;
          v7 = id_counter;
          v4->cache_id = id_counter;
          id_counter = v7 + 1;
          v4->box_item = add_listbox_item(&cache_browser, 0, BI_LEAF, v4, 1);
          next = (cache_entry *)cache_entries.next;
          v4->prev = (cache_entry *)&cache_entries;
          v4->next = next;
          cache_entries.next = v4;
          v4->next->prev = v4;
          return v1;
        }
        done_uri(v4->uri);
      }
      mem_free(v4);
    }
  }
  return v1;
}

//----- (0806AE60) --------------------------------------------------------
void __cdecl free_entry_to(cache_entry *cached, off_t offset)
{
  cache_entry *next; // ebx
  __int64 v3; // rax
  off_t v4; // kr00_8
  cache_entry **p_next; // esi
  int refcount; // esi
  void *v7; // edi
  unsigned __int64 v8; // kr08_8
  unsigned __int64 v9; // rax
  __int64 v10; // [esp+18h] [ebp-50h]
  off_t v11; // [esp+48h] [ebp-20h]

  next = (cache_entry *)cached->frag.next;
  if ( next != (cache_entry *)&cached->frag )
  {
    do
    {
      refcount = next->object.refcount;
      v7 = next->frag.next;
      v10 = *(_QWORD *)&next->frag.prev;
      if ( (__int64)(__PAIR64__((unsigned int)v7, refcount) + *(_QWORD *)&next->frag.prev) > offset )
      {
        if ( __SPAIR64__((unsigned int)v7, refcount) >= offset )
          return;
        v8 = offset - __PAIR64__((unsigned int)v7, refcount);
        v11 = cached->data_size - (offset - __PAIR64__((unsigned int)v7, refcount));
        cached->data_size = v11;
        if ( assert_failed
          || (assert_failed = HIDWORD(v11) >> 31, v11 < 0)
          && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
              errline = 261,
              elinks_internal(
                "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
                LODWORD(cached->data_size)),
              assert_failed) )
        {
          assert_failed = 0;
          cached->data_size = 0LL;
          cache_size -= v8;
          if ( assert_failed )
          {
            assert_failed = 0;
            cache_size = 0LL;
            goto LABEL_18;
          }
        }
        else
        {
          cache_size -= v8;
        }
        assert_failed = 0;
LABEL_18:
        v9 = *(_QWORD *)&next->frag.prev - v8;
        *(_QWORD *)&next->frag.prev = v9;
        p_next = &next->next;
        memmove(&next->head, (char *)&next->head + v8, v9);
        *(_QWORD *)&next->object.refcount = offset;
        goto LABEL_9;
      }
      v3 = -v10;
      v4 = cached->data_size - v10;
      cached->data_size = v4;
      if ( assert_failed
        || (assert_failed = HIDWORD(v4) >> 31, v4 < 0)
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
            errline = 261,
            elinks_internal(
              "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
              LODWORD(cached->data_size)),
            v3 = -v10,
            assert_failed) )
      {
        assert_failed = 0;
        cached->data_size = 0LL;
        cache_size += v3;
        if ( assert_failed )
        {
          assert_failed = 0;
          cache_size = 0LL;
          goto LABEL_8;
        }
      }
      else
      {
        cache_size += v3;
      }
      assert_failed = 0;
LABEL_8:
      p_next = &next->prev->next;
      next->next->prev = (cache_entry *)p_next;
      next->prev->next = next->next;
      mem_mmap_free(next, (size_t)&next->proxy_uri->fragment + 3);
LABEL_9:
      next = *p_next;
    }
    while ( &cached->frag != (list_head_elinks *)*p_next );
  }
}

//----- (0806B160) --------------------------------------------------------
void __usercall remove_overlaps(cache_entry *cached@<eax>, fragment *f@<edx>, int *trunc@<ecx>)
{
  fragment *next; // ebx
  int offset_high; // edi
  unsigned int v5; // esi
  fragment *v6; // eax
  fragment *v7; // ebx
  _DWORD *v8; // ecx
  fragment *v9; // edx
  int v10; // eax
  off_t v11; // kr08_8
  off_t v12; // rax
  off_t v13; // rax
  int v14; // esi
  unsigned int v15; // edi
  fragment *p; // [esp+2Ch] [ebp-4Ch]
  char *pa; // [esp+2Ch] [ebp-4Ch]
  list_head_elinks *p_frag; // [esp+34h] [ebp-44h]
  off_t offset; // [esp+38h] [ebp-40h]
  int data; // [esp+38h] [ebp-40h]
  off_t f_end_offset; // [esp+40h] [ebp-38h]
  _DWORD *v24; // [esp+50h] [ebp-28h]
  off_t length; // [esp+50h] [ebp-28h]
  fragment *end_offset; // [esp+58h] [ebp-20h]
  off_t end_offseta; // [esp+58h] [ebp-20h]
  off_t end_offsetb; // [esp+58h] [ebp-20h]

  offset = f->offset;
  p_frag = &cached->frag;
  end_offset = f->next;
  if ( (list_head_elinks *)f->next == &cached->frag )
    return;
  next = f->next;
  f_end_offset = f->length + offset;
  offset_high = HIDWORD(end_offset->offset);
  v5 = end_offset->offset;
  if ( SHIDWORD(f_end_offset) < offset_high )
    return;
  if ( SHIDWORD(f_end_offset) > offset_high )
  {
    p = f;
    next = f->next;
LABEL_23:
    while ( 1 )
    {
      length = next->length;
      end_offsetb = __PAIR64__(offset_high, v5) + length;
      if ( f_end_offset < (__int64)(__PAIR64__(offset_high, v5) + length) )
        break;
      if ( memcmp(&p->data[v5 - offset], next->data, length) )
      {
        *trunc = 1;
LABEL_26:
        next = p->next;
      }
LABEL_16:
      v14 = -LODWORD(next->length);
      v15 = (unsigned __int64)-next->length >> 32;
      end_offseta = cached->data_size - next->length;
      cached->data_size = end_offseta;
      if ( assert_failed
        || (assert_failed = HIDWORD(end_offseta) >> 31, end_offseta < 0)
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
            errline = 261,
            elinks_internal(
              "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
              LODWORD(cached->data_size)),
            assert_failed) )
      {
        assert_failed = 0;
        LODWORD(cached->data_size) = 0;
        HIDWORD(cached->data_size) = 0;
        cache_size += __PAIR64__(v15, v14);
        if ( assert_failed )
        {
          assert_failed = 0;
          cache_size = 0LL;
          goto LABEL_20;
        }
      }
      else
      {
        cache_size += __PAIR64__(v15, v14);
      }
      assert_failed = 0;
LABEL_20:
      next->next->prev = next->prev;
      next->prev->next = next->next;
      mem_mmap_free(next, LODWORD(next->real_length) + 35);
      next = p->next;
      if ( (list_head_elinks *)p->next == p_frag )
        return;
      offset_high = HIDWORD(next->offset);
      v5 = next->offset;
      if ( f_end_offset <= __SPAIR64__(offset_high, v5) )
        return;
      LODWORD(offset) = p->offset;
    }
    v6 = (fragment *)mem_mmap_realloc(p, LODWORD(p->real_length) + 35, end_offsetb - offset + 35);
    v7 = v6;
    if ( !v6 )
      goto LABEL_26;
    v6->prev->next = v6;
    v6->next->prev = v6;
    v8 = (_DWORD *)v6->offset;
    v24 = (_DWORD *)v6->length;
    v9 = v6->next;
    pa = (char *)v6->data;
    v10 = v6->next->offset;
    data = (int)v9->data;
    if ( memcmp(&v7->data[v10 - (_DWORD)v8], v9->data, (unsigned int)v8 + (_DWORD)v24 - v10) )
    {
      *trunc = 1;
      v10 = v7->next->offset;
      v24 = (_DWORD *)v7->length;
      data = (int)v7->next->data;
    }
    memcpy(&pa[(_DWORD)v24], (const void *)(f_end_offset - v10 + data), end_offsetb - f_end_offset);
    v11 = end_offsetb - f_end_offset;
    v12 = cached->data_size + end_offsetb - f_end_offset;
    cached->data_size = v12;
    if ( assert_failed
      || (assert_failed = HIDWORD(v12) >> 31, v12 < 0)
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
          errline = 261,
          elinks_internal(
            "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
            LODWORD(cached->data_size)),
          assert_failed) )
    {
      assert_failed = 0;
      LODWORD(cached->data_size) = 0;
      HIDWORD(cached->data_size) = 0;
      cache_size += v11;
      if ( assert_failed )
      {
        assert_failed = 0;
        cache_size = 0LL;
        goto LABEL_15;
      }
    }
    else
    {
      cache_size += v11;
    }
    assert_failed = 0;
LABEL_15:
    v13 = end_offsetb - v7->offset;
    v7->real_length = v13;
    v7->length = v13;
    p = v7;
    next = v7->next;
    goto LABEL_16;
  }
  if ( LODWORD(f->length) + (int)offset > v5 )
  {
    p = f;
    goto LABEL_23;
  }
}

//----- (0806B540) --------------------------------------------------------
void __cdecl delete_entry_content(cache_entry *cached)
{
  off_t data_size; // rax
  off_t v2; // rax
  cache_entry *i; // eax
  int v4; // eax
  unsigned __int8 *last_modified; // eax
  unsigned __int8 *etag; // eax

  data_size = cached->data_size;
  cached->data_size = 0LL;
  v2 = -data_size;
  if ( !assert_failed )
  {
    cache_size += v2;
LABEL_3:
    assert_failed = 0;
    goto LABEL_4;
  }
  assert_failed = 0;
  cached->data_size = 0LL;
  cache_size += v2;
  if ( !assert_failed )
    goto LABEL_3;
  assert_failed = 0;
  cache_size = 0LL;
LABEL_4:
  for ( i = (cache_entry *)cached->frag.next; i != (cache_entry *)&cached->frag; i = (cache_entry *)cached->frag.next )
  {
    i->next->prev = i->prev;
    i->prev->next = i->next;
    mem_mmap_free(i, (size_t)&i->proxy_uri->fragment + 3);
  }
  v4 = id_counter;
  cached->cache_id = id_counter;
  id_counter = v4 + 1;
  last_modified = cached->last_modified;
  *((_BYTE *)cached + 92) |= 8u;
  cached->length = 0LL;
  if ( last_modified )
    mem_free(last_modified);
  etag = cached->etag;
  cached->last_modified = 0;
  if ( etag )
    mem_free(etag);
  cached->etag = 0;
}

//----- (0806B670) --------------------------------------------------------
void __cdecl delete_cache_entry(cache_entry *cached)
{
  int refcount; // ecx
  int v2; // eax

  cached->next->prev = cached->prev;
  cached->prev->next = cached->next;
  if ( !assert_failed )
  {
    refcount = cached->object.refcount;
    assert_failed = refcount != 0;
    if ( !refcount
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
          errline = 656,
          elinks_internal("assertion !is_object_used(cached) failed: deleting locked cache entry"),
          !assert_failed) )
    {
      v2 = is_entry_used(cached);
      assert_failed = v2 != 0;
      if ( v2 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 657;
        elinks_internal("assertion !is_entry_used(cached) failed: deleting loading cache entry");
      }
    }
  }
  delete_entry_content(cached);
  if ( cached->box_item )
    done_listbox_item(&cache_browser, cached->box_item);
  if ( cached->uri )
    done_uri(cached->uri);
  if ( cached->proxy_uri )
    done_uri(cached->proxy_uri);
  if ( cached->redirect )
    done_uri(cached->redirect);
  if ( cached->head )
    mem_free(cached->head);
  if ( cached->content_type )
    mem_free(cached->content_type);
  if ( cached->last_modified )
    mem_free(cached->last_modified);
  if ( cached->ssl_info )
    mem_free(cached->ssl_info);
  if ( cached->encoding_info )
    mem_free(cached->encoding_info);
  if ( cached->etag )
    mem_free(cached->etag);
  mem_free(cached);
}

//----- (0806B7E0) --------------------------------------------------------
void __cdecl garbage_collection(int whole)
{
  option_value *opt; // eax
  unsigned int v2; // ebx
  unsigned int v3; // esi
  cache_entry *next; // edi
  unsigned int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  unsigned int v8; // esi
  unsigned __int64 v9; // kr08_8
  off_t data_size; // rax
  unsigned __int64 v11; // rax
  list_head_elinks *prev; // edi
  unsigned int v13; // ecx
  list_head_elinks *v14; // edi
  list_head_elinks *v15; // eax
  unsigned __int64 v16; // kr18_8
  cache_entry *v17; // eax
  int v18; // eax
  list_head_elinks v19; // rax
  unsigned __int64 v20; // kr20_8
  unsigned __int64 v21; // [esp+28h] [ebp-50h]
  unsigned int v22; // [esp+38h] [ebp-40h]
  unsigned int v23; // [esp+3Ch] [ebp-3Ch]
  unsigned int v24; // [esp+3Ch] [ebp-3Ch]
  unsigned int v25; // [esp+3Ch] [ebp-3Ch]
  unsigned __int64 opt_cache_size; // [esp+48h] [ebp-30h]
  unsigned int opt_cache_sizea; // [esp+48h] [ebp-30h]
  list_head_elinks *v28; // [esp+58h] [ebp-20h]

  opt = get_opt_(config_options, "document.cache.memory.size");
  v3 = HIDWORD(cache_size);
  v2 = cache_size;
  opt_cache_size = opt->number;
  if ( whole || opt_cache_size < cache_size )
  {
    next = (cache_entry *)cache_entries.next;
    v5 = 0;
    v6 = 0;
    if ( cache_entries.next != &cache_entries )
    {
      v21 = cache_size;
      v7 = 0;
      v8 = 0;
      while ( 1 )
      {
        v9 = next->data_size + __PAIR64__(v8, v7);
        v8 = HIDWORD(v9);
        v7 = v9;
        if ( !next->object.refcount && !is_entry_used(next) )
          goto LABEL_12;
        if ( assert_failed )
          break;
        if ( next->data_size <= v21 )
        {
          assert_failed = 0;
          data_size = next->data_size;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
          errline = 801;
          elinks_internal(
            "assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld",
            (_DWORD)cache_size,
            HIDWORD(cache_size),
            LODWORD(next->data_size));
          data_size = next->data_size;
          if ( assert_failed )
            break;
        }
        v21 -= data_size;
LABEL_12:
        next = next->next;
        if ( next == (cache_entry *)&cache_entries )
        {
          v6 = HIDWORD(v9);
          v5 = v9;
          v3 = HIDWORD(v21);
          v2 = v21;
          goto LABEL_14;
        }
      }
      assert_failed = 0;
      v21 = 0LL;
      goto LABEL_12;
    }
LABEL_14:
    if ( assert_failed )
      goto LABEL_15;
    assert_failed = cache_size != __PAIR64__(v6, v5);
    if ( cache_size != __PAIR64__(v6, v5) )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
      errline = 810;
      v22 = v5;
      v23 = v6;
      elinks_internal(
        "assertion old_cache_size == cache_size failed: cache_size out of sync: %ld != (actual) %ld",
        (_DWORD)cache_size,
        HIDWORD(cache_size));
      v5 = v22;
      v6 = v23;
      if ( assert_failed )
      {
LABEL_15:
        assert_failed = 0;
        cache_size = __PAIR64__(v6, v5);
      }
    }
    if ( __PAIR64__(v3, v2) > opt_cache_size || whole )
    {
      v11 = 90 * opt_cache_size / 0x64;
      prev = (list_head_elinks *)cache_entries.prev;
      v13 = HIDWORD(v11);
      opt_cache_sizea = v11;
      if ( cache_entries.prev == &cache_entries )
      {
LABEL_52:
        if ( assert_failed
          || (assert_failed = (v3 | v2) != 0, v3 | v2)
          && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
              errline = 852,
              v25 = v13,
              elinks_internal(
                "assertion new_cache_size == 0 failed: cache_size (%ld) overflow: %ld",
                (_DWORD)cache_size,
                HIDWORD(cache_size)),
              v13 = v25,
              assert_failed) )
        {
          assert_failed = 0;
          prev = &cache_entries;
          v2 = 0;
          v3 = 0;
        }
        else
        {
          prev = &cache_entries;
        }
LABEL_26:
        v14 = (list_head_elinks *)prev->next;
        if ( v14 != &cache_entries )
        {
          if ( whole )
            goto LABEL_34;
          v15 = v14;
          v28 = v14;
          do
          {
            v16 = *(_QWORD *)&v15[9] + __PAIR64__(v3, v2);
            if ( __PAIR64__(v13, opt_cache_sizea) >= v16 )
            {
              LOBYTE(v15[11].prev) &= ~0x20u;
              v3 = HIDWORD(v16);
              v2 = v16;
            }
            v15 = (list_head_elinks *)v15->next;
          }
          while ( v15 != &cache_entries );
          v14 = (list_head_elinks *)v14->next;
          v17 = (cache_entry *)*((_DWORD *)v28->next + 1);
          if ( (*((_BYTE *)v17 + 92) & 0x20) != 0 )
            goto LABEL_35;
          while ( v14 != &cache_entries )
          {
LABEL_34:
            v14 = (list_head_elinks *)v14->next;
            v17 = (cache_entry *)v14->prev;
            if ( (*((_BYTE *)v17 + 92) & 0x20) != 0 )
LABEL_35:
              delete_cache_entry(v17);
          }
        }
        return;
      }
      if ( v11 >= __PAIR64__(v3, v2) )
        goto LABEL_25;
      while ( !prev[1].next )
      {
        v24 = v13;
        v18 = is_entry_used((cache_entry *)prev);
        v13 = v24;
        if ( v18 )
          break;
        if ( !assert_failed )
        {
          if ( *(_QWORD *)&prev[9] > __PAIR64__(v3, v2) )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
            errline = 840;
            elinks_internal(
              "assertion new_cache_size >= cached->data_size failed: cache_size (%ld) underflow: subtracting %ld from %ld",
              (_DWORD)cache_size,
              HIDWORD(cache_size),
              prev[9].next);
            v13 = v24;
          }
          else
          {
            assert_failed = 0;
          }
        }
        LOBYTE(prev[11].prev) |= 0x20u;
        v19 = prev[9];
        if ( assert_failed )
        {
          assert_failed = 0;
          v2 = 0;
          v3 = 0;
LABEL_21:
          prev = (list_head_elinks *)prev->prev;
          if ( prev == &cache_entries )
            goto LABEL_52;
          goto LABEL_22;
        }
        prev = (list_head_elinks *)prev->prev;
        v20 = __PAIR64__(v3, v2) - *(_QWORD *)&v19;
        v3 = (__PAIR64__(v3, v2) - *(_QWORD *)&v19) >> 32;
        v2 = v20;
        if ( prev == &cache_entries )
          goto LABEL_52;
LABEL_22:
        if ( v3 <= v13 && (v3 < v13 || v2 <= opt_cache_sizea) )
        {
LABEL_25:
          if ( !whole )
            goto LABEL_26;
        }
      }
      LOBYTE(prev[11].prev) &= ~0x20u;
      goto LABEL_21;
    }
  }
}

//----- (0806BCF0) --------------------------------------------------------
cache_entry *__cdecl get_validated_cache_entry(uri *uri, cache_mode cache_mode)
{
  cache_entry *v2; // ebx
  cache_entry *v4; // eax
  char v5; // al
  time_t seconds; // esi
  time_t v7; // esi
  cache_entry *v8; // [esp+0h] [ebp-28h]
  timeval_T t; // [esp+18h] [ebp-10h] BYREF

  if ( cache_mode > CACHE_MODE_NORMAL )
    return 0;
  v4 = find_in_cache(uri);
  v2 = v4;
  if ( !v4 )
    return v2;
  v5 = *((_BYTE *)v4 + 92);
  if ( (v5 & 8) != 0 )
    return 0;
  if ( cache_mode && v2->cache_mode == CACHE_MODE_NEVER )
    goto LABEL_17;
  if ( v2->redirect )
  {
    if ( !get_opt_(config_options, "document.cache.cache_redirects")->number )
      goto LABEL_17;
    v5 = *((_BYTE *)v2 + 92);
  }
  if ( (v5 & 1) != 0 )
  {
    timeval_now(&t);
    if ( timeval_cmp(&v2->max_age, &t) <= 0 )
    {
LABEL_17:
      if ( !v2->object.refcount )
      {
        v8 = v2;
        v2 = 0;
        delete_cache_entry(v8);
        return v2;
      }
      return 0;
    }
  }
  if ( v2->cache_mode <= CACHE_MODE_CHECK_IF_MODIFIED
    && (v2->last_modified || v2->etag)
    && get_opt_(config_options, "document.cache.revalidation_interval")->number >= 0 )
  {
    seconds = v2->seconds;
    v7 = get_opt_(config_options, "document.cache.revalidation_interval")->number + seconds;
    if ( v7 < time(0) )
      return 0;
  }
  return v2;
}

//----- (0806BE30) --------------------------------------------------------
void __usercall truncate_entry(cache_entry *cached@<eax>, off_t offset@<0:edx, 4:ecx>, int final)
{
  list_head_elinks *next; // esi
  off_t v5; // rcx
  off_t v6; // rax
  __int64 v7; // rax
  __int64 v8; // kr00_8
  list_head_elinks **v9; // eax
  list_head_elinks *v10; // ecx
  off_t v11; // [esp+18h] [ebp-40h]
  list_head_elinks *v12; // [esp+18h] [ebp-40h]
  int v13; // [esp+24h] [ebp-34h]
  off_t v14; // [esp+28h] [ebp-30h]
  list_head_elinks *p_frag; // [esp+34h] [ebp-24h]
  off_t v17; // [esp+38h] [ebp-20h]
  off_t v18; // [esp+38h] [ebp-20h]

  if ( cached->length > offset )
  {
    *((_BYTE *)cached + 92) |= 8u;
    cached->length = offset;
  }
  next = (list_head_elinks *)cached->frag.next;
  p_frag = &cached->frag;
  if ( next == &cached->frag )
    return;
  while ( 1 )
  {
    v5 = offset - *(_QWORD *)&next[1];
    if ( !assert_failed )
    {
      assert_failed = (unsigned int)next[2].prev >> 31;
      if ( assert_failed )
      {
        v13 = v5;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 580;
        elinks_internal("assertion f->length >= 0 failed!");
        LODWORD(v5) = v13;
      }
    }
    v6 = (off_t)next[2];
    if ( v5 < v6 )
      break;
    next = (list_head_elinks *)next->next;
    if ( next == p_frag )
      return;
  }
  v11 = v5;
  if ( v5 > 0 )
  {
    v17 = v5 - v6;
    v14 = cached->data_size + v5 - v6;
    cached->data_size = v14;
    if ( assert_failed
      || (assert_failed = HIDWORD(v14) >> 31, v14 < 0)
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
          errline = 261,
          elinks_internal(
            "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
            LODWORD(cached->data_size)),
          assert_failed) )
    {
      assert_failed = 0;
      LODWORD(cached->data_size) = 0;
      HIDWORD(cached->data_size) = 0;
      cache_size += v17;
      if ( assert_failed )
      {
        assert_failed = 0;
        cache_size = 0LL;
LABEL_14:
        next[2] = (list_head_elinks)v11;
        if ( final && (v9 = (list_head_elinks **)mem_mmap_realloc(next, (size_t)next[3].next + 35, v11 + 35)) != 0 )
        {
          (*v9)->prev = v9;
          v9[1]->next = v9;
          v10 = v9[5];
          v9[6] = v9[4];
          v9[7] = v10;
          next = *v9;
        }
        else
        {
          next = (list_head_elinks *)next->next;
        }
        goto LABEL_16;
      }
    }
    else
    {
      cache_size += v17;
    }
    assert_failed = 0;
    goto LABEL_14;
  }
LABEL_16:
  if ( next != p_frag )
  {
    while ( 1 )
    {
      v12 = (list_head_elinks *)next->next;
      v7 = -*(_QWORD *)&next[2];
      v18 = cached->data_size - *(_QWORD *)&next[2];
      cached->data_size = v18;
      if ( !assert_failed )
      {
        assert_failed = HIDWORD(v18) >> 31;
        if ( v18 >= 0 )
          break;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c";
        errline = 261;
        v8 = v7;
        elinks_internal(
          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
          LODWORD(cached->data_size));
        v7 = v8;
        if ( !assert_failed )
          break;
      }
      assert_failed = 0;
      LODWORD(cached->data_size) = 0;
      HIDWORD(cached->data_size) = 0;
      cache_size += v7;
      if ( !assert_failed )
        goto LABEL_20;
      assert_failed = 0;
      cache_size = 0LL;
LABEL_21:
      *((_DWORD *)next->next + 1) = next->prev;
      *(_DWORD *)next->prev = next->next;
      mem_mmap_free(next, (size_t)next[3].next + 35);
      if ( v12 == p_frag )
        return;
      next = v12;
    }
    cache_size += v7;
LABEL_20:
    assert_failed = 0;
    goto LABEL_21;
  }
}

//----- (0806C1F0) --------------------------------------------------------
void __cdecl normalize_cache_entry(cache_entry *cached, off_t truncate_length)
{
  if ( truncate_length >= 0 )
  {
    truncate_entry(cached, truncate_length, 1);
    *((_BYTE *)cached + 92) &= 0xF5u;
    cached->seconds = time(0);
  }
}

//----- (0806C230) --------------------------------------------------------
int __cdecl add_fragment(cache_entry *cached, off_t offset, const unsigned __int8 *data, ssize_t length)
{
  unsigned int v4; // ebx
  int v5; // esi
  int v6; // eax
  fragment *next; // edi
  bool v8; // cc
  off_t v10; // rax
  off_t v11; // kr08_8
  bool v12; // cc
  fragment *v13; // eax
  off_t v14; // [esp+18h] [ebp-70h]
  fragment *nf; // [esp+40h] [ebp-48h]
  unsigned __int64 v16; // [esp+48h] [ebp-40h]
  int f_end_offset; // [esp+58h] [ebp-30h]
  off_t f_end_offseta; // [esp+58h] [ebp-30h]
  off_t f_end_offsetb; // [esp+58h] [ebp-30h]
  off_t f_end_offsetc; // [esp+58h] [ebp-30h]
  off_t f_end_offsetd; // [esp+58h] [ebp-30h]
  signed __int64 f_end_offsete; // [esp+58h] [ebp-30h]
  int trunc[7]; // [esp+6Ch] [ebp-1Ch] BYREF
  off_t v24; // 0:edx.8
  off_t v25; // 0:edx.8

  f_end_offset = 0;
  if ( !length )
    return f_end_offset;
  trunc[0] = 0;
  v5 = (unsigned __int64)(offset + length) >> 32;
  v4 = offset + length;
  if ( __SPAIR64__(v5, v4) > cached->length )
    cached->length = __PAIR64__(v5, v4);
  v6 = id_counter;
  cached->cache_id = id_counter;
  id_counter = v6 + 1;
  next = (fragment *)cached->frag.next;
  if ( next != (fragment *)&cached->frag )
  {
    v14 = next->offset;
    f_end_offseta = next->length;
    if ( offset >= next->offset )
    {
      v8 = SHIDWORD(offset) <= (int)((unsigned __int64)(v14 + f_end_offseta) >> 32);
      f_end_offsetb = v14 + f_end_offseta;
      if ( v8 )
      {
        v8 = v5 <= SHIDWORD(f_end_offsetb);
        if ( v5 < SHIDWORD(f_end_offsetb) )
        {
LABEL_7:
          f_end_offset = 0;
LABEL_8:
          memcpy(&next->data[offset - LODWORD(next->offset)], data, length);
          remove_overlaps(cached, next, trunc);
          LODWORD(v24) = offset + length;
          HIDWORD(v24) = (unsigned __int64)(offset + length) >> 32;
          truncate_entry(cached, v24, 0);
          return f_end_offset;
        }
LABEL_16:
        if ( v8 && v4 <= (unsigned int)f_end_offsetb )
          goto LABEL_7;
        if ( (signed __int64)(__PAIR64__(v5, v4) - v14) <= next->real_length )
        {
          v16 = __PAIR64__(v5, v4) - f_end_offsetb;
          f_end_offsete = cached->data_size + __PAIR64__(v5, v4) - f_end_offsetb;
          cached->data_size = f_end_offsete;
          if ( assert_failed
            || (assert_failed = HIDWORD(f_end_offsete) >> 31, f_end_offsete < 0)
            && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
                errline = 261,
                elinks_internal(
                  "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
                  LODWORD(cached->data_size)),
                assert_failed) )
          {
            assert_failed = 0;
            cached->data_size = 0LL;
            cache_size += v16;
            if ( assert_failed )
            {
              assert_failed = 0;
              cache_size = 0LL;
              goto LABEL_33;
            }
          }
          else
          {
            cache_size += v16;
          }
          assert_failed = 0;
LABEL_33:
          next->length = __PAIR64__(v5, v4) - next->offset;
          f_end_offset = 1;
          goto LABEL_8;
        }
        next->length = offset - v14;
        next = next->next;
      }
      else
      {
        while ( 1 )
        {
          next = next->next;
          if ( next == (fragment *)&cached->frag )
            break;
          v10 = next->offset;
          f_end_offsetc = next->length;
          if ( offset < v10 )
            break;
          v11 = v10 + f_end_offsetc;
          v12 = SHIDWORD(offset) < (int)((unsigned __int64)(v10 + f_end_offsetc) >> 32);
          f_end_offsetb = v10 + f_end_offsetc;
          if ( v12 || v12 && (unsigned int)offset <= (unsigned int)v11 )
          {
            v8 = v5 <= SHIDWORD(f_end_offsetb);
            v14 = next->offset;
            if ( v5 < SHIDWORD(f_end_offsetb) )
              goto LABEL_7;
            goto LABEL_16;
          }
        }
      }
    }
  }
  v13 = frag_alloc((length | 0x3FFF) + 1);
  f_end_offset = -1;
  nf = v13;
  if ( !v13 )
    return f_end_offset;
  v13->offset = offset;
  v13->length = length;
  v13->real_length = (length | 0x3FFF) + 1;
  memcpy(v13->data, data, length);
  nf->next = next->prev->next;
  nf->prev = next->prev;
  next->prev->next = nf;
  nf->next->prev = nf;
  f_end_offsetd = cached->data_size + length;
  cached->data_size = f_end_offsetd;
  if ( assert_failed
    || (assert_failed = HIDWORD(f_end_offsetd) >> 31, f_end_offsetd < 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/cache.c",
        errline = 261,
        elinks_internal(
          "assertion cached->data_size >= 0 failed: cache entry data_size underflow: %ld",
          LODWORD(cached->data_size)),
        assert_failed) )
  {
    assert_failed = 0;
    cached->data_size = 0LL;
    cache_size += length;
    if ( assert_failed )
    {
      assert_failed = 0;
      cache_size = 0LL;
      goto LABEL_24;
    }
  }
  else
  {
    cache_size += length;
  }
  assert_failed = 0;
LABEL_24:
  remove_overlaps(cached, nf, trunc);
  f_end_offset = 1;
  if ( trunc[0] )
  {
    LODWORD(v25) = offset + length;
    HIDWORD(v25) = (unsigned __int64)(offset + length) >> 32;
    truncate_entry(cached, v25, 0);
    return 1;
  }
  return f_end_offset;
}

//----- (0806C740) --------------------------------------------------------
void __cdecl lock_cache_entry(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (0806C750) --------------------------------------------------------
void __cdecl unlock_cache_entry(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (0806C760) --------------------------------------------------------
int __cdecl is_cache_entry_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (0806C780) --------------------------------------------------------
uri *__cdecl get_cache_entry_uri(listbox_item *item)
{
  uri *result; // eax

  result = (uri *)*((_DWORD *)item->udata + 5);
  ++result->object.refcount;
  return result;
}

//----- (0806C7A0) --------------------------------------------------------
listbox_item *__cdecl get_cache_entry_root(listbox_item *item)
{
  return 0;
}

//----- (0806C7B0) --------------------------------------------------------
int __cdecl can_delete_cache_entry(listbox_item *item)
{
  return 1;
}

//----- (0806C7C0) --------------------------------------------------------
void __cdecl delete_cache_entry_item(listbox_item *item, int last)
{
  cache_entry *udata; // ebx
  int refcount; // ecx

  udata = (cache_entry *)item->udata;
  if ( !assert_failed && (refcount = udata->object.refcount, assert_failed = refcount != 0, refcount) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cache/dialogs.c";
    errline = 167;
    elinks_internal("assertion !is_object_used(cached) failed!");
    delete_cache_entry(udata);
  }
  else
  {
    delete_cache_entry(udata);
  }
}

//----- (0806C830) --------------------------------------------------------
listbox_match __cdecl match_cache_entry(listbox_item *item, terminal *term, unsigned __int8 *text)
{
  void *udata; // ebx
  char *v4; // edx
  listbox_match result; // eax
  const char *v6; // edx

  udata = item->udata;
  v4 = c_strcasestr(**((const char ***)udata + 5), (const char *)text);
  result = LISTBOX_MATCH_OK;
  if ( !v4 )
  {
    v6 = (const char *)*((_DWORD *)udata + 8);
    LOBYTE(result) = 1;
    if ( v6 )
      return c_strcasestr(v6, (const char *)text) == 0;
  }
  return result;
}

//----- (0806C890) --------------------------------------------------------
unsigned __int8 *__usercall _1@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (0806C900) --------------------------------------------------------
unsigned __int8 *__cdecl get_cache_entry_info(listbox_item *item, terminal *term)
{
  char *udata; // ebx
  const unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  char v13; // al
  const unsigned __int8 *v14; // eax
  const unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  option_value *opt; // eax
  const unsigned __int8 *v18; // eax
  const char *v19; // [esp+24h] [ebp-34h]
  const char *v20; // [esp+24h] [ebp-34h]
  const char *v21; // [esp+24h] [ebp-34h]
  const char *v22; // [esp+24h] [ebp-34h]
  __int64 v23; // [esp+28h] [ebp-30h]
  __int64 v24; // [esp+28h] [ebp-30h]
  string msg; // [esp+34h] [ebp-24h] BYREF
  int expires[4]; // [esp+3Ch] [ebp-1Ch] BYREF

  udata = (char *)item->udata;
  if ( item->type == BI_FOLDER || !init_string(&msg) )
    return 0;
  v4 = _1((unsigned __int8 *)&byte_812B6C9, term);
  add_to_string(&msg, v4);
  add_to_string(&msg, ": ");
  add_uri_to_string(&msg, *((const uri **)udata + 5), URI_PUBLIC);
  if ( *((_DWORD *)udata + 6) != *((_DWORD *)udata + 5) )
  {
    v5 = _1("Proxy URL", term);
    add_format_to_string(&msg, &byte_81279A6, v5);
    add_uri_to_string(&msg, *((const uri **)udata + 6), URI_PUBLIC);
  }
  if ( *((_DWORD *)udata + 7) )
  {
    v6 = _1("Redirect", term);
    add_format_to_string(&msg, &byte_81279A6, v6);
    add_uri_to_string(&msg, *((const uri **)udata + 7), URI_PUBLIC);
    if ( (udata[92] & 4) != 0 )
      add_to_string(&msg, " (GET)");
  }
  v23 = *((_QWORD *)udata + 8);
  v7 = (const char *)_1((unsigned __int8 *)&byte_8127BDB, term);
  add_format_to_string(&msg, "\n%s: %lld", v7, v23);
  v24 = *((_QWORD *)udata + 9);
  v8 = (const char *)_1("Loaded size", term);
  add_format_to_string(&msg, "\n%s: %lld", v8, v24);
  if ( *((_DWORD *)udata + 9) )
  {
    v19 = (const char *)*((_DWORD *)udata + 9);
    v9 = (const char *)_1("Content type", term);
    add_format_to_string(&msg, "\n%s: %s", v9, v19);
  }
  if ( *((_DWORD *)udata + 10) )
  {
    v20 = (const char *)*((_DWORD *)udata + 10);
    v10 = (const char *)_1((unsigned __int8 *)&byte_8127C0B, term);
    add_format_to_string(&msg, "\n%s: %s", v10, v20);
  }
  if ( *((_DWORD *)udata + 11) )
    add_format_to_string(&msg, "\n%s: %s", "ETag", *((const char **)udata + 11));
  if ( *((_DWORD *)udata + 12) )
  {
    v21 = (const char *)*((_DWORD *)udata + 12);
    v11 = (const char *)_1((unsigned __int8 *)&byte_8127C1E, term);
    add_format_to_string(&msg, "\n%s: %s", v11, v21);
  }
  if ( *((_DWORD *)udata + 13) )
  {
    v22 = (const char *)*((_DWORD *)udata + 13);
    v12 = (const char *)_1((unsigned __int8 *)&byte_8132CF2, term);
    add_format_to_string(&msg, "\n%s: %s", v12, v22);
  }
  v13 = udata[92];
  if ( (v13 & 0x18) != 16 )
  {
    add_char_to_string(&msg, 0xAu);
    v14 = _1("Flags", term);
    add_to_string(&msg, v14);
    add_to_string(&msg, ": ");
    v13 = udata[92];
    if ( (v13 & 8) != 0 )
    {
      v18 = _1((unsigned __int8 *)&byte_8127C2F, term);
      add_to_string(&msg, v18);
      add_char_to_string(&msg, 0x20u);
      v13 = udata[92];
    }
    if ( (v13 & 0x10) == 0 )
    {
      v15 = _1("invalid", term);
      add_to_string(&msg, v15);
      v13 = udata[92];
    }
  }
  if ( (v13 & 1) != 0 )
  {
    expires[0] = timeval_to_seconds((timeval_T *)(udata + 84));
    v16 = _1((unsigned __int8 *)&byte_8127C42, term);
    add_format_to_string(&msg, &byte_81279A6, v16);
    opt = get_opt_(config_options, "ui.date_format");
    add_date_to_string(&msg, opt->string, expires);
  }
  return msg.source;
}
// 806C900: using guessed type time_t expires[4];

//----- (0806CCA0) --------------------------------------------------------
unsigned __int8 *__cdecl get_cache_entry_text(listbox_item *item, terminal *term)
{
  return get_uri_string(*((const uri **)item->udata + 5), URI_PUBLIC);
}

//----- (0806CCC0) --------------------------------------------------------
void __cdecl cache_manager(session *ses)
{
  hierbox_browser_0(&cache_browser, ses);
}

//----- (0806CCE0) --------------------------------------------------------
unsigned __int8 *__cdecl version_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  __printf_chk(1, "%s\n", (const char *)full_static_version);
  fflush(stdout);
  return (unsigned __int8 *)&delete;
}
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806CD20) --------------------------------------------------------
unsigned __int8 *__cdecl remote_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  unsigned __int8 v3; // dl
  size_t v4; // esi
  unsigned __int8 *v5; // ebx
  const unsigned __int16 **v6; // eax
  unsigned __int8 v7; // dl
  const unsigned __int16 *v8; // edi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // edx
  unsigned __int8 v12; // al
  const char *v13; // ebx
  const unsigned __int16 *v14; // esi
  char *v15; // eax
  char *v16; // edx
  unsigned __int8 *v17; // ebx
  const char *i; // eax
  unsigned __int8 v19; // cl
  char *v20; // eax
  unsigned __int8 *v22; // ecx
  unsigned __int8 *v23; // eax
  char *v24; // edi
  unsigned __int8 v25; // dl
  int v26; // ebx
  unsigned __int8 *name; // eax
  unsigned __int8 *v28; // eax
  const char *v29; // ebx
  unsigned __int8 v30; // [esp+3Ch] [ebp-9Ch]
  unsigned __int8 v31; // [esp+3Ch] [ebp-9Ch]
  unsigned __int8 *argstring; // [esp+44h] [ebp-94h]
  unsigned __int8 *s1; // [esp+50h] [ebp-88h]
  size_t n1; // [esp+54h] [ebp-84h]
  const unsigned __int16 **v35; // [esp+58h] [ebp-80h]
  unsigned int remote_argc; // [esp+5Ch] [ebp-7Ch]
  remote_cmd::$67FC5AA8F34302F8200D76697F634B2B remote_methods[6]; // [esp+68h] [ebp-70h]
  unsigned __int8 *remote_argv[10]; // [esp+98h] [ebp-40h]
  char *oa; // [esp+E0h] [ebp+8h]

  remote_methods[0].name = "openURL";
  remote_methods[0].type = REMOTE_METHOD_OPENURL;
  remote_methods[1].name = "ping";
  remote_methods[1].type = REMOTE_METHOD_PING;
  remote_methods[2].name = "addBookmark";
  remote_methods[2].type = REMOTE_METHOD_ADDBOOKMARK;
  remote_methods[3].name = "infoBox";
  remote_methods[3].type = REMOTE_METHOD_INFOBOX;
  remote_methods[4].name = "xfeDoCommand";
  remote_methods[4].type = REMOTE_METHOD_XFEDOCOMMAND;
  remote_methods[5].name = 0;
  remote_methods[5].type = REMOTE_METHOD_NOT_SUPPORTED;
  if ( *argc <= 0 )
  {
    oa = "Parameter expected";
    return gettext((const unsigned __int8 *)oa);
  }
  s1 = **argv;
  v3 = *s1;
  if ( (unsigned __int8)(*s1 - 97) <= 0x19u || (unsigned __int8)(v3 - 65) <= 0x19u )
  {
    v4 = 0;
    do
    {
      do
      {
        v3 = s1[++v4];
        v5 = &s1[v4];
      }
      while ( (unsigned __int8)(v3 - 97) <= 0x19u );
    }
    while ( (unsigned __int8)(v3 - 65) <= 0x19u );
    n1 = v4;
  }
  else
  {
    v5 = **argv;
    v4 = 0;
    n1 = 0;
  }
  v30 = v3;
  v6 = __ctype_b_loc();
  v7 = v30;
  v35 = v6;
  v8 = *v6;
  while ( (v8[v7] & 0x2000) != 0 )
    v7 = *++v5;
  v31 = v7;
  v9 = &v5[strlen((const char *)v5)];
  if ( v9 > v5 && (v8[*(v9 - 1)] & 0x2000) != 0 )
  {
    --v9;
    while ( v5 < v9 )
    {
      if ( (v8[*(v9 - 1)] & 0x2000) == 0 )
        goto LABEL_56;
      --v9;
    }
  }
  else
  {
LABEL_56:
    v9 = (unsigned __int8 *)((__PAIR64__((unsigned int)v9, (unsigned int)v5) - (unsigned int)v9) >> 32);
  }
  if ( !v4 || v31 != 40 || *v9 != 41 )
  {
    remote_session_flags_0 |= 1u;
    return 0;
  }
  v10 = memacpy(v5 + 1, v9 - (v5 + 1));
  argstring = v10;
  if ( !v10 )
  {
    oa = byte_8127CFF;
    return gettext((const unsigned __int8 *)oa);
  }
  v11 = v10;
  v12 = *v10;
  v13 = (const char *)v11;
  remote_argc = 0;
  while ( 1 )
  {
    v14 = *v35;
    if ( ((*v35)[v12] & 0x2000) != 0 )
    {
      do
        v12 = *++v13;
      while ( (v14[*(unsigned __int8 *)v13] & 0x2000) != 0 );
    }
    if ( v12 == 34 )
      break;
    v15 = strchr(v13, 44);
    v16 = v15 + 1;
    if ( !v15 )
    {
      v15 = (char *)&v13[strlen(v13)];
      v16 = v15;
    }
    while ( v13 < v15 )
    {
      if ( (v14[(unsigned __int8)*(v15 - 1)] & 0x2000) == 0 )
        goto LABEL_30;
      --v15;
    }
    if ( v13 == v15 )
      goto LABEL_31;
LABEL_30:
    remote_argv[remote_argc++] = (unsigned __int8 *)v13;
LABEL_31:
    *v15 = 0;
    v12 = *v16;
    if ( *v16 == 44 )
      goto LABEL_49;
LABEL_32:
    if ( !v12 )
      goto LABEL_50;
LABEL_33:
    if ( remote_argc > 0xA )
    {
      mem_free(argstring);
      oa = "Too many arguments";
      return gettext((const unsigned __int8 *)oa);
    }
    v13 = v16;
  }
  v17 = (unsigned __int8 *)(v13 + 1);
  for ( i = (const char *)v17; ; i = v20 + 2 )
  {
    v20 = strchr(i, 34);
    if ( !v20 )
    {
      oa = "Mismatched ending argument quoting";
      return gettext((const unsigned __int8 *)oa);
    }
    v19 = v20[1];
    v16 = v20 + 1;
    if ( v19 != 34 )
      break;
  }
  while ( (v14[v19] & 0x2000) != 0 )
    v19 = *++v16;
  if ( v19 != 44 && v19 )
  {
    oa = "Garbage after quoted argument";
    return gettext((const unsigned __int8 *)oa);
  }
  *v20 = 0;
  v22 = v17;
  if ( *v17 )
  {
    v23 = v17;
    v24 = v16;
    v25 = *v17;
    do
    {
      *v22++ = v25;
      v23 += (*v23 == 34) + 1;
      v25 = *v23;
    }
    while ( *v23 );
    v16 = v24;
  }
  remote_argv[remote_argc++] = v17;
  *v22 = 0;
  v12 = *v16;
  if ( *v16 != 44 )
    goto LABEL_32;
LABEL_49:
  v12 = *++v16;
  if ( *v16 )
    goto LABEL_33;
LABEL_50:
  v26 = 0;
  name = "openURL";
  do
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
    errline = 322;
    if ( !elinks_strlcasecmp(s1, n1, name, 0xFFFFFFFF, 1) )
      break;
    name = remote_methods[++v26].name;
  }
  while ( name );
  switch ( remote_methods[v26].type )
  {
    case REMOTE_METHOD_OPENURL:
      if ( remote_argc )
      {
        if ( remote_argc != 2 )
        {
          remote_session_flags_0 |= 4u;
          goto LABEL_72;
        }
        v29 = (const char *)remote_argv[1];
        if ( strstr((const char *)remote_argv[1], "new-window") )
        {
          remote_session_flags_0 |= 2u;
          goto LABEL_72;
        }
        if ( strstr(v29, "new-tab") )
        {
          remote_session_flags_0 |= 1u;
LABEL_72:
          remote_url = stracpy(remote_argv[0]);
        }
      }
      else
      {
        remote_session_flags_0 |= 8u;
      }
      break;
    case REMOTE_METHOD_PING:
      remote_session_flags_0 = SES_REMOTE_PING;
      break;
    case REMOTE_METHOD_XFEDOCOMMAND:
      if ( remote_argc )
      {
        if ( !c_strcasecmp((const char *)remote_argv[0], "openBrowser") )
          remote_session_flags_0 = SES_REMOTE_NEW_WINDOW;
      }
      break;
    case REMOTE_METHOD_ADDBOOKMARK:
      if ( remote_argc )
      {
        v28 = stracpy(remote_argv[0]);
        remote_session_flags_0 = SES_REMOTE_ADD_BOOKMARK;
        remote_url = v28;
      }
      break;
    case REMOTE_METHOD_INFOBOX:
      if ( remote_argc )
      {
        remote_url = stracpy(remote_argv[0]);
        if ( remote_url )
          insert_in_string(&remote_url, 0, "about:", 6);
        remote_session_flags_0 = SES_REMOTE_INFO_BOX;
      }
      break;
    default:
      break;
  }
  mem_free(argstring);
  if ( !remote_session_flags_0 )
  {
    oa = "Remote method not supported";
    return gettext((const unsigned __int8 *)oa);
  }
  ++*argv;
  --*argc;
  return 0;
}

//----- (0806D2C0) --------------------------------------------------------
unsigned __int8 *__cdecl lookup_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  int v4; // ebx
  in6_addr *p_sin6_addr; // edx
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // eax
  int addrno; // [esp+28h] [ebp-70h] BYREF
  sockaddr_storage *addrs; // [esp+2Ch] [ebp-6Ch] BYREF
  unsigned __int8 p[46]; // [esp+32h] [ebp-66h] BYREF
  sockaddr_in6 addr; // [esp+60h] [ebp-38h] BYREF
  unsigned int v12; // [esp+7Ch] [ebp-1Ch]

  v12 = __readgsdword(0x14u);
  addrs = 0;
  if ( !*argc )
    return gettext("Parameter expected");
  if ( *argc > 1 )
    return gettext("Too many parameters");
  ++*argv;
  --*argc;
  if ( do_real_lookup(*(*argv - 1), &addrs, &addrno, 0) == DNS_ERROR )
  {
    v7 = gettext("error");
    herror((const char *)v7);
    return (unsigned __int8 *)&delete;
  }
  else
  {
    if ( addrno > 0 )
    {
      v4 = 0;
      do
      {
        while ( 1 )
        {
          addr = *(sockaddr_in6 *)&addrs[v4].ss_family;
          p_sin6_addr = &addr.sin6_addr;
          if ( addr.sin6_family != 10 )
            p_sin6_addr = (in6_addr *)&addr.sin6_flowinfo;
          if ( !inet_ntop(addr.sin6_family, p_sin6_addr, (char *)p, 0x2Eu) )
            break;
          ++v4;
          __printf_chk(1, "%s\n", (const char *)p);
          if ( addrno <= v4 )
            goto LABEL_12;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
        ++v4;
        errline = 179;
        v6 = gettext("Resolver error");
        elinks_error(v6);
      }
      while ( addrno > v4 );
    }
LABEL_12:
    if ( addrs )
      mem_free(addrs);
    fflush(stdout);
    return (unsigned __int8 *)&delete;
  }
}
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806D490) --------------------------------------------------------
unsigned __int8 *__cdecl forcehtml_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  option_value *opt; // eax

  opt = get_opt_(config_options, "mime.default_type");
  safe_strncpy(opt->string, "text/html", 0x400u);
  return 0;
}

//----- (0806D4D0) --------------------------------------------------------
unsigned __int8 *__cdecl eval_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  if ( *argc <= 0 )
    return gettext("Parameter expected");
  ++*argv;
  --*argc;
  parse_config_file(config_options, "-eval", *(*argv - 1), 0, 0);
  fflush(stdout);
  return 0;
}

//----- (0806D540) --------------------------------------------------------
void __usercall print_full_help_inner(option_elinks *tree@<eax>, unsigned __int8 *path@<edx>, int trees@<ecx>)
{
  list_head_elinks *v3; // eax
  option_elinks *next; // ebx
  unsigned __int8 *desc; // eax
  option_type type; // esi
  const unsigned __int8 *capt; // edi
  unsigned __int8 *v8; // edx
  unsigned __int8 *help_str; // eax
  unsigned __int8 *v10; // eax
  signed int v11; // esi
  size_t v12; // eax
  unsigned __int8 *v13; // edx
  size_t v14; // ecx
  unsigned __int8 *v15; // edx
  size_t v16; // ecx
  void *cp_name; // esi
  unsigned __int8 *v18; // eax
  int v19; // eax
  const char *name; // edi
  size_t v21; // esi
  unsigned __int8 *v22; // eax
  const unsigned __int8 *v23; // [esp+0h] [ebp-488h]
  size_t v24; // [esp+34h] [ebp-454h]
  size_t v25; // [esp+34h] [ebp-454h]
  unsigned __int8 *src; // [esp+38h] [ebp-450h]
  unsigned __int8 *srca; // [esp+38h] [ebp-450h]
  unsigned __int8 *srcd; // [esp+38h] [ebp-450h]
  unsigned __int8 *srcb; // [esp+38h] [ebp-450h]
  unsigned __int8 *srcc; // [esp+38h] [ebp-450h]
  unsigned __int8 *srce; // [esp+38h] [ebp-450h]
  unsigned __int8 *srcf; // [esp+38h] [ebp-450h]
  const char *v33; // [esp+3Ch] [ebp-44Ch]
  unsigned __int8 *savedpos; // [esp+44h] [ebp-444h]
  unsigned __int8 *savedposa; // [esp+44h] [ebp-444h]
  string string; // [esp+5Ch] [ebp-42Ch] BYREF
  unsigned __int8 saved[1024]; // [esp+64h] [ebp-424h] BYREF
  unsigned __int8 hexcolor[8]; // [esp+464h] [ebp-24h] BYREF
  unsigned int v42; // [esp+46Ch] [ebp-1Ch]

  v42 = __readgsdword(0x14u);
  saved[0] = 0;
  v3 = tree->value.tree;
  next = (option_elinks *)v3->next;
  if ( v3->next != v3 )
  {
    savedpos = saved;
    while ( 1 )
    {
      desc = next->desc;
      type = next->type;
      capt = next->capt;
      if ( desc && *desc )
        v8 = gettext(next->desc);
      else
        v8 = "N/A";
      if ( (type == OPT_TREE) != trees || type == OPT_ALIAS && tree != cmdline_options || (next->flags & 1) != 0 )
        goto LABEL_3;
      if ( !capt )
      {
        capt = "Template option folder";
        srcf = v8;
        v19 = c_strncasecmp((const char *)next->name, "_template_", 0xAu);
        v8 = srcf;
        if ( v19 )
        {
          name = (const char *)next->name;
          v21 = strlen(name);
          safe_strncpy(savedpos, (const unsigned __int8 *)name, hexcolor - savedpos);
          safe_strncpy(&savedpos[v21], ", -", hexcolor - savedpos - v21);
          savedpos += v21 + 3;
          goto LABEL_3;
        }
      }
      help_str = option_types[next->type].help_str;
      if ( *help_str )
      {
        srcd = v8;
        help_str = gettext(help_str);
        v8 = srcd;
        if ( type != OPT_TREE )
        {
LABEL_13:
          src = v8;
          __printf_chk(
            1,
            "    %s%s%s %s ",
            (const char *)path,
            (const char *)saved,
            (const char *)next->name,
            (const char *)help_str);
          v8 = src;
          switch ( type )
          {
            case OPT_BOOL:
            case OPT_INT:
            case OPT_LONG:
              cp_name = next->value.tree;
              v23 = "(default: %ld)";
              goto LABEL_34;
            case OPT_STRING:
              cp_name = next->value.tree;
              v23 = "(default: \"%s\")";
              goto LABEL_34;
            case OPT_CODEPAGE:
              cp_name = get_cp_name(next->value.number);
              v18 = gettext("(default: %s)");
              goto LABEL_35;
            case OPT_LANGUAGE:
              cp_name = language_to_name(next->value.number);
              v18 = gettext("(default: \"%s\")");
              goto LABEL_35;
            case OPT_COLOR:
              cp_name = (void *)get_color_string(next->value.color, hexcolor);
              v18 = gettext("(default: %s)");
              goto LABEL_35;
            case OPT_ALIAS:
              cp_name = next->value.tree;
              v23 = "(alias for %s)";
LABEL_34:
              v18 = gettext(v23);
LABEL_35:
              __printf_chk(1, (const char *)v18, cp_name);
              v8 = src;
              break;
            case OPT_TREE:
              goto LABEL_27;
            default:
              goto LABEL_14;
          }
          goto LABEL_14;
        }
      }
      else if ( type != OPT_TREE )
      {
        goto LABEL_13;
      }
LABEL_27:
      srcb = v8;
      v11 = strlen((const char *)path);
      v33 = (const char *)next->name;
      v12 = strlen(v33);
      v13 = srcb;
      v14 = v12;
      if ( (int)(v11 + v12 + 2) > 1024 )
      {
LABEL_3:
        next = next->next;
        if ( (option_elinks *)tree->value.tree == next )
          return;
      }
      else
      {
        savedposa = saved;
        if ( v11 > 0 )
        {
          v24 = v12;
          __memcpy_chk(saved, path, v11, 1024);
          v14 = v24;
          v13 = srcb;
          savedposa = &saved[v11];
          v33 = (const char *)next->name;
        }
        srcc = v13;
        v25 = v14;
        memcpy(savedposa, v33, v14 + 1);
        v15 = srcc;
        v16 = v25;
        if ( *capt )
        {
          v22 = gettext(capt);
          v16 = v25;
          v15 = srcc;
          capt = v22;
        }
        srce = v15;
        savedpos = &savedposa[v16];
        __printf_chk(1, "  %s: (%s)", (const char *)capt, (const char *)saved);
        v8 = srce;
LABEL_14:
        srca = v8;
        _IO_putc(10, stdout);
        if ( init_string(&string) && wrap_option_desc(&string, srca, &indent_7640, 67) )
        {
          fwrite(string.source, 1u, string.length, stdout);
        }
        else
        {
          v10 = gettext("Out of memory formatting option documentation");
          __fprintf_chk(stderr, 1, "%12s%s\n", &delete, (const char *)v10);
        }
        done_string(&string);
        _IO_putc(10, stdout);
        if ( next->type == OPT_TREE )
        {
          *(_WORD *)savedpos = 46;
          print_full_help_outer(next, saved);
        }
        saved[0] = 0;
        savedpos = saved;
        next = next->next;
        if ( (option_elinks *)tree->value.tree == next )
          return;
      }
    }
  }
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8059038: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806DA90) --------------------------------------------------------
void __usercall print_full_help_outer(option_elinks *tree@<eax>, unsigned __int8 *path@<edx>)
{
  print_full_help_inner(tree, path, 0);
  print_full_help_inner(tree, path, 1);
}

//----- (0806DAC0) --------------------------------------------------------
unsigned __int8 *__cdecl printconfigdump_cmd(option_elinks *option_elinks, unsigned __int8 ***argv, int *argc)
{
  unsigned __int8 *config_string; // eax
  unsigned __int8 *v4; // ebx

  get_opt_(config_options, "config.saving_style")->number = 2;
  config_string = create_config_string((unsigned __int8 *)&delete, (unsigned __int8 *)&delete, config_options);
  v4 = config_string;
  if ( config_string )
  {
    __printf_chk(1, (const char *)"%s", (const char *)config_string);
    mem_free(v4);
  }
  fflush(stdout);
  return (unsigned __int8 *)&delete;
}
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806DB40) --------------------------------------------------------
unsigned __int8 *__cdecl redir_cmd(option_elinks *option_elinks, unsigned __int8 ***argv, int *argc)
{
  const unsigned __int8 *v3; // ecx
  option_elinks *opt_rec; // eax
  unsigned __int8 *v6; // eax

  v3 = "config-dir";
  if ( !strcmp((const char *)option_elinks->name, "confdir")
    || (v3 = "config-file", !strcmp((const char *)option_elinks->name, "conffile")) )
  {
    opt_rec = get_opt_rec(cmdline_options, v3);
    if ( !assert_failed )
    {
      assert_failed = opt_rec == 0;
      if ( !opt_rec )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/cmdline.c";
        errline = 705;
        elinks_internal("assertion option failed!");
        opt_rec = 0;
      }
    }
    option_types[opt_rec->type].cmdline(opt_rec, argv, argc);
  }
  else
  {
    if ( strcmp((const char *)option_elinks->name, "stdin") )
      return gettext("Internal consistency error");
    if ( !complained_8041 )
    {
      complained_8041 = 1;
      v6 = **argv;
      if ( v6 && (unsigned __int8)(*v6 - 48) <= 1u && !v6[1] )
      {
        ++*argv;
        --*argc;
      }
      __fprintf_chk(stderr, 1, "Warning: Deprecated option -stdin used!\n");
      __fprintf_chk(stderr, 1, "ELinks now determines the -stdin option value automatically.\n");
      __fprintf_chk(stderr, 1, "In the future versions ELinks will report error when you will\n");
      __fprintf_chk(stderr, 1, "continue to use this option.\a\n");
    }
  }
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0806DD30) --------------------------------------------------------
retval __cdecl parse_options(int argc, unsigned __int8 **argv, list_head_elinks *url_list)
{
  retval result; // eax
  const unsigned __int8 **v4; // edx
  const unsigned __int8 *v5; // ebx
  const unsigned __int8 *v6; // edi
  option_elinks *opt_rec; // ebx
  unsigned __int8 *(*cmdline)(option_elinks *, unsigned __int8 ***, int *); // eax
  int v9; // eax
  unsigned __int8 *v10; // eax
  char *i; // eax
  int v12; // ebx
  unsigned __int8 *v13; // eax
  _BYTE *v14; // ebx
  int v15; // esi
  unsigned __int8 *v16; // eax
  option_elinks *tree; // [esp+18h] [ebp-30h]
  char *p; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 **v19; // [esp+28h] [ebp-20h] BYREF
  retval v20[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  result = argc;
  tree = cmdline_options;
  v19 = argv;
  while ( result )
  {
    v4 = (const unsigned __int8 **)v19;
    v20[0] = result - 1;
    ++v19;
    v5 = *v4;
    if ( **v4 == 45 && (v6 = v5 + 1, v5[1]) )
    {
      p = (char *)stracpy(v5 + 1);
      if ( p )
      {
        if ( v5[1] == 45 )
          v6 = v5 + 2;
        opt_rec = get_opt_rec(tree, v6);
        if ( opt_rec || (opt_rec = get_opt_rec(tree, (const unsigned __int8 *)p)) != 0 )
        {
          mem_free(p);
        }
        else
        {
          for ( i = strchr(p + 1, 95); i; i = strchr(i, 95) )
            *i = 45;
          opt_rec = get_opt_rec(tree, (const unsigned __int8 *)p + 1);
          mem_free(p);
          if ( !opt_rec )
          {
LABEL_23:
            v12 = (int)*(v19 - 1);
            v13 = gettext("Unknown option %s");
            usrerror(v13, v12);
            return 3;
          }
        }
        cmdline = option_types[opt_rec->type].cmdline;
        if ( !cmdline )
          goto LABEL_23;
        v9 = (int)cmdline(opt_rec, &v19, (int *)v20);
        if ( v9 )
        {
          v14 = (_BYTE *)v9;
          result = RET_COMMAND;
          if ( *v14 )
          {
            v15 = (int)*(v19 - 1);
            v16 = gettext("Cannot parse option %s: %s");
            usrerror(v16, v15, v14);
            return 3;
          }
          return result;
        }
        v10 = remote_url;
        if ( remote_url )
        {
          if ( url_list )
          {
            add_to_string_list(url_list, remote_url, -1);
            v10 = remote_url;
          }
          mem_free(v10);
          remote_url = 0;
        }
      }
    }
    else if ( url_list )
    {
      add_to_string_list(url_list, v5, -1);
    }
    result = v20[0];
  }
  return result;
}
// 806DD30: using guessed type retval var_1C[7];

//----- (0806DF20) --------------------------------------------------------
unsigned __int8 *__cdecl printhelp_cmd(option_elinks *option_elinks, unsigned __int8 ***argv, int *argc)
{
  char *v3; // eax
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // eax
  option_elinks *v6; // edi
  string *p_string; // esi
  list_head_elinks *tree; // eax
  _DWORD *next; // ebx
  const char *help_str; // edx
  int length; // eax
  int v12; // ecx
  size_t v13; // eax
  const unsigned __int8 *v14; // edx
  const char *v15; // edi
  unsigned __int8 *v16; // eax
  unsigned __int8 *v18; // eax
  size_t v19; // ecx
  unsigned __int8 *v20; // eax
  string *v21; // [esp+0h] [ebp-68h]
  size_t v22; // [esp+20h] [ebp-48h]
  int v23; // [esp+20h] [ebp-48h]
  size_t v24; // [esp+20h] [ebp-48h]
  size_t v25; // [esp+20h] [ebp-48h]
  const char *source; // [esp+24h] [ebp-44h]
  unsigned __int8 *sourcea; // [esp+24h] [ebp-44h]
  size_t v28; // [esp+28h] [ebp-40h]
  const char *v29; // [esp+2Ch] [ebp-3Ch]
  string string; // [esp+30h] [ebp-38h] BYREF
  char v31[20]; // [esp+38h] [ebp-30h] BYREF
  unsigned int v32; // [esp+4Ch] [ebp-1Ch]

  v32 = __readgsdword(0x14u);
  v3 = strchr((const char *)full_static_version, 10);
  if ( v3 )
    *v3 = 0;
  __printf_chk(1, "%s\n\n", (const char *)full_static_version);
  if ( !strcmp((const char *)option_elinks->name, "config-help") )
  {
    v20 = gettext("Configuration options");
    __printf_chk(1, "%s:\n", (const char *)v20);
    print_full_help_outer(config_options, (unsigned __int8 *)&delete);
  }
  else
  {
    v4 = gettext("Options");
    v5 = gettext("Usage: elinks [OPTION]... [URL]...");
    __printf_chk(1, "%s\n\n%s:\n", (const char *)v5, (const char *)v4);
    if ( strcmp((const char *)option_elinks->name, "long-help") )
    {
      v6 = cmdline_options;
      p_string = 0;
      string.source = 0;
      string.length = 0;
      strcpy(v31, "                   ");
      tree = cmdline_options->value.tree;
      next = tree->next;
      v29 = &delete;
      if ( tree->next == tree )
        goto LABEL_24;
      while ( 1 )
      {
        sourcea = (unsigned __int8 *)next[3];
        v13 = strlen((const char *)sourcea);
        v14 = sourcea;
        v19 = v13;
        if ( (next[4] & 1) == 0 )
        {
          v15 = (const char *)next[10];
          if ( v15 )
          {
            if ( *v15 )
            {
              v24 = v13;
              v16 = gettext((const unsigned __int8 *)next[10]);
              v19 = v24;
              v15 = (const char *)v16;
            }
            help_str = (const char *)option_types[next[5]].help_str;
            if ( *help_str )
            {
              v25 = v19;
              v18 = gettext(option_types[next[5]].help_str);
              v19 = v25;
              help_str = (const char *)v18;
            }
            source = help_str;
            v22 = v19;
            v28 = strlen(help_str);
            length = 0;
            if ( p_string )
              length = p_string->length;
            v12 = 20 - v22 - v28 - length;
            if ( v12 < 0 )
              v12 = *source != 0;
            v31[v12] = 0;
            v23 = v12;
            __printf_chk(1, "  -%s%s %s%s%s\n", v29, (const char *)next[3], source, v31, v15);
            v31[v23] = 32;
            if ( p_string )
            {
              v21 = p_string;
              p_string = 0;
              done_string(v21);
            }
LABEL_15:
            v6 = cmdline_options;
            goto LABEL_16;
          }
          if ( !p_string )
          {
            if ( !init_string(&string) )
              goto LABEL_15;
            v14 = (const unsigned __int8 *)next[3];
            p_string = &string;
          }
          add_to_string(p_string, v14);
          add_to_string(p_string, ", -");
          v6 = cmdline_options;
        }
LABEL_16:
        next = (_DWORD *)*next;
        if ( next == (_DWORD *)v6->value.tree )
          goto LABEL_24;
        v29 = &delete;
        if ( p_string )
          v29 = (const char *)p_string->source;
      }
    }
    print_full_help_outer(cmdline_options, (unsigned __int8 *)"-");
  }
LABEL_24:
  fflush(stdout);
  return (unsigned __int8 *)&delete;
}
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806E220) --------------------------------------------------------
void __usercall skip_quoted(conf_parsing_pos *pos@<eax>)
{
  unsigned __int8 v1; // dl
  unsigned __int8 *v2; // ecx
  unsigned __int8 v3; // dl
  unsigned __int8 *look; // edx
  conf_parsing_pos *v5; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (v1 = *pos->look, (assert_failed = v1 != 39 && v1 != 34) != 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c",
        errline = 136,
        v5 = pos,
        elinks_internal("assertion isquote(*pos->look) failed!"),
        pos = v5,
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  v2 = pos->look + 1;
  pos->look = v2;
  v3 = *v2;
  if ( *v2 )
  {
    if ( v3 != 34 && v3 != 39 )
    {
      do
      {
        if ( v3 == 92 && (look = v2 + 1, v2[1]) )
        {
          pos->look = look;
          if ( *look == 10 )
          {
LABEL_15:
            ++pos->line;
            look = pos->look;
          }
        }
        else
        {
          look = pos->look;
          if ( *pos->look == 10 )
            goto LABEL_15;
        }
        v2 = look + 1;
        pos->look = look + 1;
        v3 = look[1];
        if ( !v3 )
          return;
      }
      while ( v3 != 39 && v3 != 34 );
    }
    pos->look = v2 + 1;
  }
}

//----- (0806E300) --------------------------------------------------------
void __usercall skip_option_value(conf_parsing_pos *pos@<eax>)
{
  unsigned __int8 *look; // edx
  unsigned __int8 v2; // cl

  look = pos->look;
  v2 = *pos->look;
  if ( v2 == 39 || v2 == 34 )
  {
    skip_quoted(pos);
  }
  else
  {
    while ( (unsigned __int8)(v2 - 97) <= 0x19u
         || (unsigned __int8)(v2 - 65) <= 0x19u
         || (unsigned __int8)(v2 - 48) <= 9u
         || v2 == 46
         || v2 == 43
         || v2 == 45 )
    {
      pos->look = ++look;
      v2 = *look;
    }
  }
}

//----- (0806E360) --------------------------------------------------------
string *__usercall add_bytes_to_string__@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (0806E4B0) --------------------------------------------------------
void __usercall add_cfg_header_to_string(string *string@<eax>, unsigned __int8 *text@<edx>)
{
  int v3; // esi
  signed int v5; // eax

  v3 = 10;
  v5 = strlen((const char *)text) + 2;
  if ( v5 > 9 )
  {
    LOWORD(v3) = 80;
    if ( v5 <= 80 )
      v3 = v5;
  }
  add_to_string(string, &byte_81281C9);
  add_xchar_to_string(string, 0x23u, v3);
  add_to_string(string, &byte_81281CD);
  add_to_string(string, text);
  add_to_string(string, &byte_81281D1);
}

//----- (0806E540) --------------------------------------------------------
void __usercall skip_white(conf_parsing_pos *pos@<eax>)
{
  unsigned __int8 *look; // ebx
  const unsigned __int16 **v3; // eax
  unsigned __int8 v4; // dl
  const unsigned __int16 *v5; // ecx
  int v6; // edx
  unsigned __int8 v7; // al
  const unsigned __int16 **v8; // [esp+Ch] [ebp-2Ch]
  unsigned __int8 v9; // [esp+1Ch] [ebp-1Ch]

  look = pos->look;
  if ( *pos->look )
  {
    v9 = *pos->look;
    v3 = __ctype_b_loc();
    v4 = v9;
    v8 = v3;
    v5 = *v3;
    do
    {
      while ( (v5[v4] & 0x2000) != 0 )
      {
        if ( v4 == 10 )
        {
          ++pos->line;
          v5 = *v8;
        }
        v4 = *++look;
      }
      if ( v4 != 35 )
        break;
      v6 = 0;
      do
        v7 = look[++v6];
      while ( v7 && v7 != 10 );
      look += v6;
      v4 = *look;
    }
    while ( *look );
  }
  pos->look = look;
}

//----- (0806E5C0) --------------------------------------------------------
parse_error __usercall show_parse_error@<eax>(const conf_parsing_state *state@<eax>, parse_error err@<edx>)
{
  const unsigned __int8 *filename; // edx

  filename = state->filename;
  if ( filename )
    __fprintf_chk(stderr, 1, "%s:%d: %s\n", (const char *)filename, state->pos.line, (const char *)error_msg_8620[err]);
  return err;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0806E610) --------------------------------------------------------
parse_error __cdecl parse_bind(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf)
{
  unsigned __int8 *look; // esi
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // edi
  parse_error v9; // ebx
  unsigned __int8 *v10; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v11; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *act_str; // [esp+24h] [ebp-24h]
  int line; // [esp+28h] [ebp-20h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+28h] [ebp-20h]
  unsigned __int8 *keymap; // [esp+2Ch] [ebp-1Ch]

  skip_white(&state->pos);
  look = state->pos.look;
  if ( !*state->pos.look )
    return show_parse_error(state, ERROR_PARSE);
  line = state->pos.line;
  keymap = option_types[3].read(0, &state->pos.look, &state->pos.line);
  skip_white(&state->pos);
  if ( !keymap || !*state->pos.look )
  {
    state->pos.look = look;
    state->pos.line = line;
    return show_parse_error(state, ERROR_PARSE);
  }
  v14 = state->pos.line;
  v10 = state->pos.look;
  v6 = option_types[3].read(0, &state->pos.look, &state->pos.line);
  skip_white(&state->pos);
  if ( !v6 )
  {
    mem_free(keymap);
    v7 = v10;
    goto LABEL_9;
  }
  if ( !*state->pos.look )
  {
    mem_free(keymap);
    mem_free(v6);
    v7 = v10;
LABEL_9:
    state->pos.look = v7;
    state->pos.line = v14;
    return show_parse_error(state, ERROR_PARSE);
  }
  skip_white(&state->pos);
  if ( *state->pos.look != 61 || (++state->pos.look, skip_white(&state->pos), !*state->pos.look) )
  {
    mem_free(keymap);
    mem_free(v6);
    return show_parse_error(state, ERROR_PARSE);
  }
  v15 = state->pos.line;
  v11 = state->pos.look;
  v8 = option_types[3].read(0, &state->pos.look, &state->pos.line);
  if ( !v8 )
  {
    mem_free(keymap);
    mem_free(v6);
    state->pos.line = v15;
    state->pos.look = v11;
    return show_parse_error(state, ERROR_PARSE);
  }
  if ( !mirror )
  {
    if ( get_opt_(cmdline_options, "default-keys")->number || !bind_do(keymap, v6, v8, is_system_conf) )
      goto LABEL_16;
LABEL_23:
    v9 = show_parse_error(state, ERROR_VALUE);
    goto LABEL_17;
  }
  if ( !is_system_conf )
  {
    act_str = bind_act(keymap, v6);
    if ( act_str )
    {
      add_bytes_to_string__(mirror, state->mirrored, v11 - state->mirrored);
      add_to_string(mirror, act_str);
      mem_free(act_str);
      state->mirrored = state->pos.look;
      v9 = ERROR_NONE;
      goto LABEL_17;
    }
    goto LABEL_23;
  }
LABEL_16:
  v9 = ERROR_NONE;
LABEL_17:
  mem_free(keymap);
  mem_free(v6);
  mem_free(v8);
  return v9;
}

//----- (0806E890) --------------------------------------------------------
parse_error __cdecl parse_unset(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf)
{
  unsigned __int8 *look; // esi
  unsigned __int8 v5; // dl
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // eax
  option_elinks *opt_rec_real; // edi
  option_flags flags; // eax
  option_flags v10; // edx
  parse_error v12; // edx
  option_elinks *v13; // eax
  option_flags v14; // edx
  unsigned __int8 *p; // [esp+10h] [ebp-28h]
  option_elinks *v16; // [esp+14h] [ebp-24h]
  int length; // [esp+18h] [ebp-20h]

  skip_white(&state->pos);
  look = state->pos.look;
  v5 = *state->pos.look;
  v6 = state->pos.look;
  if ( !v5 )
  {
    v12 = ERROR_PARSE;
    return show_parse_error(state, v12);
  }
  while ( (unsigned __int8)(v5 - 97) <= 0x19u
       || (unsigned __int8)(v5 - 65) <= 0x19u
       || (unsigned __int8)(v5 - 48) <= 9u
       || v5 == 95
       || v5 == 45
       || v5 == 42
       || v5 == 46
       || v5 == 43 )
  {
    state->pos.look = ++v6;
    v5 = *v6;
  }
  length = v6 - look;
  v7 = memacpy(look, v6 - look);
  if ( !v7 )
  {
    v12 = ERROR_NOMEM;
    return show_parse_error(state, v12);
  }
  p = v7;
  opt_rec_real = get_opt_rec_real(opt_tree, v7);
  mem_free(p);
  if ( opt_rec_real )
  {
    flags = opt_rec_real->flags;
    if ( (flags & 1) == 0 )
    {
      if ( mirror )
      {
        if ( is_system_conf )
        {
          v13 = indirect_option(opt_rec_real);
          v14 = v13->flags;
          if ( (v14 & 0x80u) == 0 )
            v13->flags = v14 | 4;
          else
            v13->flags = v14 & 0xFFFFFFFB;
        }
        else
        {
          v16 = indirect_option(opt_rec_real);
          v10 = v16->flags;
          if ( (v10 & 0x80u) == 0 )
          {
            if ( option_types[opt_rec_real->type].write )
            {
              add_to_string(mirror, "set ");
              add_bytes_to_string__(mirror, look, length);
              add_to_string(mirror, " = ");
              option_types[opt_rec_real->type].write(opt_rec_real, mirror);
              state->mirrored = state->pos.look;
              v10 = v16->flags;
            }
          }
          v16->flags = v10 & 0xFFFFFFFB;
        }
      }
      else if ( (flags & 0x20) != 0 )
      {
        delete_option(opt_rec_real);
      }
      else
      {
        mark_option_as_deleted(opt_rec_real);
      }
    }
  }
  return 0;
}

//----- (0806EA50) --------------------------------------------------------
parse_error __cdecl parse_set(option_elinks *opt_tree, conf_parsing_state *state, string *mirror, int is_system_conf)
{
  unsigned __int8 *look; // esi
  unsigned __int8 v5; // al
  unsigned __int8 *v6; // edi
  parse_error v7; // edx
  unsigned __int8 *v9; // edx
  option_elinks *opt_rec_real; // eax
  option_elinks *v11; // edi
  unsigned __int8 *(*read)(option_elinks *, unsigned __int8 **, int *); // eax
  int (*set)(option_elinks *, unsigned __int8 *); // eax
  option_elinks *v14; // ebx
  option_flags v15; // eax
  int (*equals)(option_elinks *, const unsigned __int8 *); // edx
  option_flags flags; // eax
  unsigned __int8 *p; // [esp+14h] [ebp-34h]
  int line; // [esp+18h] [ebp-30h]
  int length; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v21; // [esp+20h] [ebp-28h]
  option_elinks *flagsite; // [esp+24h] [ebp-24h]
  unsigned __int8 *val; // [esp+2Ch] [ebp-1Ch]

  skip_white(&state->pos);
  look = state->pos.look;
  v5 = *state->pos.look;
  v6 = state->pos.look;
  if ( !v5 )
    goto LABEL_13;
  while ( (unsigned __int8)(v5 - 97) <= 0x19u
       || (unsigned __int8)(v5 - 65) <= 0x19u
       || (unsigned __int8)(v5 - 48) <= 9u
       || v5 == 95
       || v5 == 45
       || v5 == 42
       || v5 == 46
       || v5 == 43 )
  {
    state->pos.look = ++v6;
    v5 = *v6;
  }
  skip_white(&state->pos);
  if ( *state->pos.look != 61 )
  {
LABEL_13:
    v7 = ERROR_PARSE;
    return show_parse_error(state, v7);
  }
  ++state->pos.look;
  skip_white(&state->pos);
  if ( !*state->pos.look )
  {
LABEL_28:
    v7 = ERROR_VALUE;
    return show_parse_error(state, v7);
  }
  length = v6 - look;
  v9 = memacpy(look, v6 - look);
  if ( !v9 )
  {
    v7 = ERROR_NOMEM;
    return show_parse_error(state, v7);
  }
  line = state->pos.line;
  v21 = state->pos.look;
  p = v9;
  if ( mirror )
    opt_rec_real = get_opt_rec_real(opt_tree, v9);
  else
    opt_rec_real = get_opt_rec(opt_tree, v9);
  v11 = opt_rec_real;
  mem_free(p);
  if ( !v11 || (v11->flags & 1) != 0 )
  {
    show_parse_error(state, ERROR_OPTION);
    skip_option_value(&state->pos);
    return 3;
  }
  read = option_types[v11->type].read;
  if ( read )
  {
    val = read(v11, &state->pos.look, &state->pos.line);
    if ( val )
    {
      if ( !mirror )
      {
        set = option_types[v11->type].set;
        if ( !set || !set(v11, val) )
        {
          mem_free(val);
          goto LABEL_28;
        }
        goto LABEL_35;
      }
      if ( !is_system_conf )
      {
        flagsite = indirect_option(v11);
        flags = flagsite->flags;
        if ( (flags & 0x80u) != 0 )
        {
          add_to_string(mirror, &byte_81281E4);
          add_bytes_to_string__(mirror, look, length);
          state->mirrored = state->pos.look;
          flags = flagsite->flags;
        }
        else if ( option_types[v11->type].write )
        {
          add_bytes_to_string__(mirror, state->mirrored, v21 - state->mirrored);
          option_types[v11->type].write(v11, mirror);
          state->mirrored = state->pos.look;
          flags = flagsite->flags;
        }
        flagsite->flags = flags & 0xFFFFFFFB;
        goto LABEL_35;
      }
      v14 = indirect_option(v11);
      v15 = v14->flags;
      if ( (v15 & 0x80u) == 0 )
      {
        equals = option_types[v11->type].equals;
        if ( equals )
        {
          if ( equals(v11, val) )
          {
            v14->flags &= ~4u;
            goto LABEL_35;
          }
          v15 = v14->flags;
        }
      }
      v14->flags = v15 | 4;
LABEL_35:
      mem_free(val);
      return 0;
    }
    state->pos.line = line;
    state->pos.look = v21;
  }
  show_parse_error(state, ERROR_VALUE);
  skip_option_value(&state->pos);
  return 4;
}

//----- (0806ED20) --------------------------------------------------------
string *__cdecl wrap_option_desc(string *out, const unsigned __int8 *src, const string *indent, int maxwidth)
{
  const unsigned __int8 *v4; // ebx
  string *v5; // edi
  unsigned __int8 v6; // al
  int v7; // ecx
  const unsigned __int8 *v8; // esi
  const unsigned __int8 *v9; // edi
  signed int v11; // edx
  const unsigned __int8 *v12; // ecx
  unsigned __int8 *v13; // edx
  unsigned int length; // ecx
  int v15; // eax
  size_t v16; // eax
  unsigned __int8 *v17; // eax
  unsigned __int8 *source; // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 *sourcea; // [esp+3Ch] [ebp-2Ch]
  int v20; // [esp+40h] [ebp-28h]
  unsigned int v21; // [esp+44h] [ebp-24h]
  size_t v22; // [esp+48h] [ebp-20h]

  v4 = src;
  v5 = out;
  v6 = *src;
  if ( !*src )
    return v5;
  v7 = 0;
  v8 = 0;
  v9 = src;
  while ( 1 )
  {
    if ( v6 == 10 )
    {
      v8 = v4;
    }
    else
    {
      if ( v6 == 32 )
        v8 = v4;
      if ( !v8 || v7 < maxwidth )
      {
        v6 = *++v4;
        if ( !*v4 )
          break;
        goto LABEL_4;
      }
    }
    if ( !add_string_to_string(out, indent) )
      return 0;
    if ( assert_failed )
    {
LABEL_12:
      assert_failed = 0;
      return 0;
    }
    v11 = v8 - v9;
    if ( v9 && out && v11 >= 0 )
    {
      assert_failed = 0;
      if ( !v11 )
        goto LABEL_18;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      v11 = v8 - v9;
      if ( assert_failed )
        goto LABEL_12;
      if ( v8 == v9 )
        goto LABEL_18;
    }
    length = out->length;
    v15 = length + v11;
    length += 255;
    v20 = v15;
    v16 = v15 + 256;
    LOBYTE(length) = 0;
    LOBYTE(v16) = 0;
    v22 = v16;
    v21 = length;
    if ( v16 > length )
    {
      sourcea = (unsigned __int8 *)v11;
      v17 = (unsigned __int8 *)mem_realloc(out->source, v16);
      if ( !v17 )
        return 0;
      out->source = v17;
      memset(&v17[v21], 0, v22 - v21);
      v11 = (signed int)sourcea;
    }
    if ( !out->source )
      return 0;
    memcpy(&out->source[out->length], v9, v11);
    out->source[v20] = 0;
    out->length = v20;
LABEL_18:
    if ( !out || !add_char_to_string(out, 0xAu) )
      return 0;
    v12 = v4++;
    v6 = *v4;
    v9 = v8 + 1;
    v8 = 0;
    v7 = v12 - v9;
    if ( !*v4 )
      break;
LABEL_4:
    ++v7;
  }
  v13 = (unsigned __int8 *)v9;
  v5 = out;
  if ( *v13 )
  {
    source = v13;
    if ( !add_string_to_string(out, indent) || !add_to_string(out, source) || !add_char_to_string(out, 0xAu) )
      return 0;
  }
  return v5;
}

//----- (0806EF90) --------------------------------------------------------
void __cdecl smart_config_output_fn(
        string *string,
        option_elinks *option_elinks,
        unsigned __int8 *path,
        int depth,
        int do_print_comment,
        int action,
        int i18n)
{
  int v7; // edx
  unsigned __int8 *desc; // ebx
  void (*write)(option_elinks *, string *); // ecx
  unsigned __int8 *v10; // eax
  int v11; // [esp+1Ch] [ebp-2Ch]
  string indent; // [esp+28h] [ebp-20h] BYREF

  v7 = depth;
  if ( option_elinks->type != OPT_ALIAS )
  {
    if ( action == 1 )
    {
      if ( (comments & 2) != 0 )
      {
        desc = option_elinks->desc;
        if ( do_print_comment )
        {
          if ( desc )
          {
            if ( i18n )
            {
              v10 = gettext(desc);
              v7 = depth;
              desc = v10;
            }
            v11 = v7;
            if ( init_string(&indent) )
            {
              if ( v11 )
                add_xchar_to_string(&indent, 0x20u, indentation * v11);
              if ( add_to_string(&indent, "#  ") )
                wrap_option_desc(string, desc, &indent, 80 - indent.length);
              done_string(&indent);
            }
          }
        }
      }
    }
    else if ( action <= 1 )
    {
      if ( !action && (comments & 1) != 0 )
      {
        if ( depth )
          add_xchar_to_string(string, 0x20u, indentation * depth);
        add_to_string(string, "## ");
        if ( path )
        {
          add_to_string(string, path);
          add_char_to_string(string, 0x2Eu);
        }
        add_to_string(string, option_elinks->name);
        add_char_to_string(string, 0x20u);
        add_to_string(string, option_types[option_elinks->type].help_str);
        add_char_to_string(string, 0xAu);
      }
    }
    else if ( action == 2 )
    {
      if ( depth )
        add_xchar_to_string(string, 0x20u, indentation * depth);
      if ( SLOBYTE(option_elinks->flags) < 0 )
        add_to_string(string, "un");
      add_to_string(string, "set ");
      if ( path )
      {
        add_to_string(string, path);
        add_char_to_string(string, 0x2Eu);
      }
      add_to_string(string, option_elinks->name);
      if ( SLOBYTE(option_elinks->flags) >= 0 )
      {
        add_to_string(string, " = ");
        if ( !assert_failed )
        {
          write = option_types[option_elinks->type].write;
          assert_failed = write == 0;
          if ( !write )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
            errline = 906;
            elinks_internal("assertion option_types[option->type].write failed!");
          }
        }
        option_types[option_elinks->type].write(option_elinks, string);
      }
      add_char_to_string(string, 0xAu);
      if ( do_print_comment )
        goto LABEL_15;
    }
    else if ( action == 3 && do_print_comment <= 1 )
    {
LABEL_15:
      add_char_to_string(string, 0xAu);
    }
  }
}

//----- (0806F2D0) --------------------------------------------------------
unsigned __int8 *__usercall read_config_file@<eax>(unsigned __int8 *name@<eax>)
{
  int v1; // eax
  int v2; // esi
  ssize_t v4; // eax
  size_t v5; // ebx
  unsigned __int8 *v6; // eax
  unsigned int v7; // ecx
  size_t v8; // edx
  unsigned __int8 *v9; // eax
  unsigned int v10; // [esp+14h] [ebp-434h]
  size_t v11; // [esp+18h] [ebp-430h]
  int v12; // [esp+1Ch] [ebp-42Ch]
  string string; // [esp+24h] [ebp-424h] BYREF
  unsigned __int8 cfg_buffer[1024]; // [esp+2Ch] [ebp-41Ch] BYREF
  unsigned int v15; // [esp+42Ch] [ebp-1Ch]

  v15 = __readgsdword(0x14u);
  v1 = open64(name, 256);
  v2 = v1;
  if ( v1 < 0 )
    return 0;
  set_bin(v1);
  if ( !init_string(&string) )
    return 0;
  while ( 1 )
  {
    v4 = read(v2, cfg_buffer, 0x400u);
    v5 = v4;
    if ( v4 <= 0 )
      break;
    v6 = cfg_buffer;
    do
    {
      if ( !*v6 )
        *v6 = 32;
      ++v6;
    }
    while ( v6 != &cfg_buffer[v5] );
    if ( assert_failed )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 0;
      v7 = string.length + 255;
      v12 = v5 + string.length;
      v8 = v5 + string.length + 256;
      LOBYTE(v7) = 0;
      LOBYTE(v8) = 0;
      if ( v8 > v7 )
      {
        v11 = v8;
        v10 = v7;
        v9 = (unsigned __int8 *)mem_realloc(string.source, v8);
        if ( v9 )
        {
          string.source = v9;
          memset(&v9[v10], 0, v11 - v10);
          goto LABEL_11;
        }
      }
      else
      {
LABEL_11:
        if ( string.source )
        {
          memcpy(&string.source[string.length], cfg_buffer, v5);
          string.source[v12] = 0;
          string.length = v12;
        }
      }
    }
  }
  if ( v4 )
    done_string(&string);
  close(v2);
  return string.source;
}
// 80598F8: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (0806F470) --------------------------------------------------------
void __cdecl parse_config_file(
        option_elinks *options,
        unsigned __int8 *name,
        unsigned __int8 *file,
        string *mirror,
        int is_system_conf)
{
  unsigned __int8 *look; // eax
  unsigned __int8 *v6; // esi
  unsigned __int8 *mirrored; // ebx
  const unsigned __int8 *command; // ebx
  const parse_handler *v9; // esi
  size_t v10; // edi
  unsigned __int8 *v11; // edi
  unsigned int v12; // ebx
  unsigned __int8 *v13; // esi
  unsigned __int8 v14; // dl
  unsigned __int8 *v15; // ebx
  parse_error v16; // eax
  signed int v17; // esi
  unsigned __int8 *v18; // edi
  signed int v19; // esi
  signed int v20; // esi
  unsigned int length; // ecx
  int v22; // edx
  unsigned int v23; // edi
  int v24; // edx
  int v25; // ecx
  unsigned int v26; // edx
  unsigned int v27; // edi
  unsigned __int8 *v28; // eax
  unsigned int v29; // ecx
  int v30; // edx
  size_t v31; // edx
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  unsigned int v34; // [esp+1Ch] [ebp-3Ch]
  unsigned int v35; // [esp+1Ch] [ebp-3Ch]
  int v36; // [esp+24h] [ebp-34h]
  int v37; // [esp+24h] [ebp-34h]
  unsigned int v38; // [esp+24h] [ebp-34h]
  size_t v39; // [esp+24h] [ebp-34h]
  int error_occurred; // [esp+28h] [ebp-30h]
  char *s1; // [esp+2Ch] [ebp-2Ch]
  int s1a; // [esp+2Ch] [ebp-2Ch]
  int s1b; // [esp+2Ch] [ebp-2Ch]
  conf_parsing_state state; // [esp+30h] [ebp-28h] BYREF

  look = file;
  state.filename = 0;
  state.pos.line = 1;
  state.pos.look = file;
  state.mirrored = file;
  if ( !mirror )
  {
    if ( get_opt_(cmdline_options, "verbose")->number > 0 )
      state.filename = name;
    look = state.pos.look;
  }
  error_occurred = 0;
LABEL_3:
  if ( look )
  {
    do
    {
      if ( !*look )
        break;
      skip_white(&state.pos);
      if ( !mirror )
      {
        v6 = state.pos.look;
        goto LABEL_9;
      }
      v6 = state.pos.look;
      mirrored = state.mirrored;
      if ( !assert_failed )
      {
        v17 = state.pos.look - state.mirrored;
        if ( state.mirrored && v17 >= 0 )
        {
          assert_failed = 0;
LABEL_44:
          if ( !v17 )
          {
LABEL_45:
            v6 = state.pos.look;
            goto LABEL_8;
          }
          length = mirror->length;
          v22 = v17 + length;
          length += 255;
          LOBYTE(length) = 0;
          v23 = (v22 + 256) & 0xFFFFFF00;
          v34 = length;
          if ( v23 > length )
          {
            v37 = v22;
            v28 = (unsigned __int8 *)mem_realloc(mirror->source, (v22 + 256) & 0xFFFFFF00);
            if ( !v28 )
              goto LABEL_45;
            mirror->source = v28;
            memset(&v28[v34], 0, v23 - v34);
            v22 = v37;
          }
          if ( mirror->source )
          {
            v36 = v22;
            memcpy(&mirror->source[mirror->length], mirrored, v17);
            mirror->source[v36] = 0;
            mirror->length = v36;
          }
          goto LABEL_45;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( !assert_failed )
          goto LABEL_44;
        v6 = state.pos.look;
      }
      assert_failed = 0;
LABEL_8:
      state.mirrored = v6;
LABEL_9:
      if ( !*v6 )
        break;
      if ( assert_failed )
      {
LABEL_40:
        assert_failed = 0;
        v16 = show_parse_error(&state, ERROR_PARSE);
        v13 = state.pos.look;
        v12 = v16;
        goto LABEL_21;
      }
      if ( !mirror || v6 == state.mirrored )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
        errline = 574;
        elinks_internal("assertion mirror == NULL || state->mirrored == state->pos.look failed!");
        if ( assert_failed )
          goto LABEL_40;
      }
      command = parse_handlers[0].command;
      if ( !parse_handlers[0].command )
      {
LABEL_19:
        v12 = show_parse_error(&state, ERROR_COMMAND);
LABEL_20:
        v13 = state.pos.look;
        goto LABEL_21;
      }
      v9 = parse_handlers;
      s1 = (char *)state.pos.look;
      while ( 1 )
      {
        v10 = strlen((const char *)command);
        if ( !strncmp(s1, (const char *)command, v10) )
        {
          v11 = (unsigned __int8 *)&s1[v10];
          if ( ((*__ctype_b_loc())[*v11] & 0x2000) != 0 )
            break;
        }
        ++v9;
        command = v9->command;
        if ( !v9->command )
          goto LABEL_19;
      }
      state.pos.look = v11;
      v12 = v9->handler(options, &state, mirror, is_system_conf);
      if ( !mirror )
        goto LABEL_20;
      v13 = state.pos.look;
      v18 = state.mirrored;
      if ( assert_failed )
        goto LABEL_49;
      v20 = state.pos.look - state.mirrored;
      if ( state.mirrored && v20 >= 0 )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( assert_failed )
        {
          v13 = state.pos.look;
LABEL_49:
          assert_failed = 0;
          state.mirrored = v13;
          goto LABEL_21;
        }
      }
      if ( v20 )
      {
        v29 = mirror->length;
        v30 = v20 + v29;
        v29 += 255;
        s1b = v30;
        v31 = v30 + 256;
        LOBYTE(v29) = 0;
        LOBYTE(v31) = 0;
        v35 = v29;
        if ( v31 <= v29 )
          goto LABEL_77;
        v39 = v31;
        v33 = (unsigned __int8 *)mem_realloc(mirror->source, v31);
        if ( v33 )
        {
          mirror->source = v33;
          memset(&v33[v35], 0, v39 - v35);
LABEL_77:
          if ( mirror->source )
          {
            memcpy(&mirror->source[mirror->length], v18, v20);
            mirror->source[s1b] = 0;
            mirror->length = s1b;
          }
        }
      }
      v13 = state.pos.look;
      state.mirrored = state.pos.look;
LABEL_21:
      look = v13;
      if ( !v12 )
        goto LABEL_3;
      if ( v12 > 2 )
        goto LABEL_23;
LABEL_30:
      v14 = *look;
      if ( *look != 35 )
      {
        while ( v14 && v14 != 10 )
        {
          if ( v14 == 39 || v14 == 34 )
          {
            skip_quoted(&state.pos);
            look = state.pos.look;
            goto LABEL_30;
          }
          state.pos.look = ++look;
          v14 = *look;
          if ( *look == 35 )
            break;
        }
      }
      if ( !mirror )
      {
        v13 = state.pos.look;
        goto LABEL_23;
      }
      v15 = state.mirrored;
      if ( assert_failed )
      {
        v13 = state.pos.look;
      }
      else
      {
        v19 = look - state.mirrored;
        if ( state.mirrored && v19 >= 0 )
        {
          assert_failed = 0;
LABEL_56:
          if ( !v19 )
          {
LABEL_57:
            v13 = state.pos.look;
            state.mirrored = state.pos.look;
            goto LABEL_23;
          }
          v24 = mirror->length;
          v25 = v19 + v24;
          v26 = v24 + 255;
          LOBYTE(v26) = 0;
          v27 = (v25 + 256) & 0xFFFFFF00;
          s1a = v25;
          if ( v27 > v26 )
          {
            v38 = v26;
            v32 = (unsigned __int8 *)mem_realloc(mirror->source, (v25 + 256) & 0xFFFFFF00);
            if ( !v32 )
              goto LABEL_57;
            mirror->source = v32;
            memset(&v32[v38], 0, v27 - v38);
          }
          if ( mirror->source )
          {
            memcpy(&mirror->source[mirror->length], v15, v19);
            mirror->source[s1a] = 0;
            mirror->length = s1a;
          }
          goto LABEL_57;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( !assert_failed )
          goto LABEL_56;
        v13 = state.pos.look;
        look = state.pos.look;
      }
      assert_failed = 0;
      state.mirrored = look;
LABEL_23:
      look = v13;
      error_occurred = 1;
    }
    while ( v13 );
  }
  if ( error_occurred )
  {
    if ( state.filename )
    {
      fputc(7, stderr);
      if ( !get_opt_(cmdline_options, "dump")->number && !get_opt_(cmdline_options, "source")->number )
        sleep(1u);
    }
  }
}

//----- (0806FAD0) --------------------------------------------------------
int __usercall load_config_file@<eax>(
        unsigned __int8 *prefix@<eax>,
        unsigned __int8 *name@<edx>,
        option_elinks *options@<ecx>,
        string *mirror,
        int is_system_conf)
{
  unsigned __int8 *v7; // edi
  int result; // eax
  unsigned __int8 *config_file; // eax
  unsigned __int8 *p; // [esp+28h] [ebp-20h]

  v7 = straconcat(prefix, "/", name, 0);
  result = 1;
  if ( v7 )
  {
    config_file = read_config_file(v7);
    if ( config_file )
    {
LABEL_3:
      p = config_file;
      parse_config_file(options, v7, config_file, mirror, is_system_conf);
      mem_free(p);
      mem_free(v7);
      return 0;
    }
    mem_free(v7);
    v7 = straconcat(prefix, "/", ".", name, 0);
    result = 2;
    if ( v7 )
    {
      config_file = read_config_file(v7);
      if ( !config_file )
      {
        mem_free(v7);
        return 3;
      }
      goto LABEL_3;
    }
  }
  return result;
}

//----- (0806FBC0) --------------------------------------------------------
unsigned __int8 *__cdecl create_config_string(unsigned __int8 *prefix, unsigned __int8 *name, option_elinks *options)
{
  int number; // esi
  int v4; // edi
  string *inited; // edx
  unsigned __int8 *result; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edx
  unsigned __int8 *v9; // edx
  int v10; // edi
  unsigned __int8 *v11; // eax
  int length; // [esp+2Ch] [ebp-2Ch]
  string tmpstring; // [esp+30h] [ebp-28h] BYREF
  string config; // [esp+38h] [ebp-20h] BYREF

  number = get_opt_(config_options, "config.saving_style")->number;
  v4 = get_opt_(config_options, "config.i18n")->number;
  inited = init_string(&config);
  result = 0;
  if ( !inited )
    return result;
  prepare_mustsave_flags(options->value.tree, (unsigned int)(number - 1) <= 1);
  if ( number == 2 || load_config_file(prefix, name, options, &config, 0) || !config.length )
  {
    add_to_string(&config, "## ELinks 0.12pre5 configuration file\n\n");
    if ( !assert_failed )
    {
      assert_failed = (unsigned int)number > 3;
      if ( (unsigned int)number > 3 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
        errline = 959;
        elinks_internal("assertion savestyle >= 0 && savestyle <= 3 failed!");
      }
    }
    if ( number != 1 )
    {
      if ( number <= 1 )
      {
        if ( number )
          goto LABEL_11;
        v11 = "## This is ELinks configuration file. You can edit it manually,\n"
              "## if you wish so; this file is edited by ELinks when you save\n"
              "## options through UI, however only option values will be altered\n"
              "## and all your formatting, own comments etc will be kept as-is.\n";
        if ( !v4 )
          goto LABEL_31;
        goto LABEL_33;
      }
      if ( number == 2 )
      {
        v11 = "## This is ELinks configuration file. You can edit it manually,\n"
              "## if you wish so, but keep in mind that this file is overwritten\n"
              "## by ELinks when you save options through UI and you are out of\n"
              "## luck with your formatting and own comments then, so beware.\n";
        if ( !v4 )
          goto LABEL_31;
        goto LABEL_33;
      }
      if ( number != 3 )
      {
LABEL_11:
        add_to_string(&config, "##\n");
        v7 = "## Obviously, if you don't like what ELinks is going to do with\n"
             "## this file, you can change it by altering the config.saving_style\n"
             "## option. Come on, aren't we friendly guys after all?\n";
        if ( v4 )
          v7 = gettext(
                 "## Obviously, if you don't like what ELinks is going to do with\n"
                 "## this file, you can change it by altering the config.saving_style\n"
                 "## option. Come on, aren't we friendly guys after all?\n");
        add_to_string(&config, v7);
        goto LABEL_14;
      }
    }
    v11 = "## This is ELinks configuration file. You can edit it manually,\n"
          "## if you wish so; this file is edited by ELinks when you save\n"
          "## options through UI, however only option values will be altered\n"
          "## and missing options will be added at the end of file; if option\n"
          "## is not written in this file, but in some file included from it,\n"
          "## it is NOT counted as missing. Note that all your formatting,\n"
          "## own comments and so on will be kept as-is.\n";
    if ( !v4 )
    {
LABEL_31:
      add_to_string(&config, v11);
      goto LABEL_11;
    }
LABEL_33:
    v11 = gettext(v11);
    goto LABEL_31;
  }
LABEL_14:
  if ( number )
  {
    indentation = get_opt_(config_options, "config.indentation")->number;
    comments = get_opt_(config_options, "config.comments")->number;
    if ( init_string(&tmpstring) )
    {
      v8 = "Automatically saved options\n";
      if ( v4 )
        v8 = gettext("Automatically saved options\n");
      add_cfg_header_to_string(&tmpstring, v8);
      length = tmpstring.length;
      smart_config_string(&tmpstring, 2, v4, options->value.tree, 0, 0, smart_config_output_fn);
      if ( length < tmpstring.length )
        add_string_to_string(&config, &tmpstring);
      done_string(&tmpstring);
      if ( init_string(&tmpstring) )
      {
        v9 = "Automatically saved keybindings\n";
        if ( v4 )
          v9 = gettext("Automatically saved keybindings\n");
        add_cfg_header_to_string(&tmpstring, v9);
        v10 = tmpstring.length;
        bind_config_string(&tmpstring);
        if ( v10 < tmpstring.length )
          add_string_to_string(&config, &tmpstring);
        done_string(&tmpstring);
      }
    }
  }
  return config.source;
}

//----- (0806FEC0) --------------------------------------------------------
int __cdecl write_config(terminal *term)
{
  option_value *opt; // eax
  const char *v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *config_string; // edi
  size_t v5; // eax
  _BOOL4 v6; // edx
  _BOOL4 v7; // eax
  const unsigned __int8 *v8; // ecx
  int result; // eax
  unsigned __int8 *v10; // ebx
  int v11; // eax
  secure_save_info *v12; // esi
  int v13; // eax
  unsigned __int8 *number; // [esp+4h] [ebp-34h]
  int v15; // [esp+14h] [ebp-24h]
  int v16; // [esp+14h] [ebp-24h]
  bool v17; // [esp+18h] [ebp-20h]
  option_elinks *options; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    assert_failed = term == 0;
    if ( !term )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/conf.c";
      errline = 1069;
      elinks_internal("assertion term failed!");
    }
  }
  if ( !elinks_home )
  {
    number = (unsigned __int8 *)get_opt_(cmdline_options, "config-file")->number;
    write_config_dialog(term, number, 1, 0);
    return -1;
  }
  options = config_options;
  opt = get_opt_(cmdline_options, "config-file");
  v2 = elinks_home;
  v3 = (unsigned __int8 *)opt->number;
  config_string = create_config_string((unsigned __int8 *)elinks_home, opt->string, options);
  v5 = strlen(v2);
  v6 = 0;
  if ( !v5 )
  {
    v7 = *v3 == 47;
    v17 = *v3 == 47;
    goto LABEL_7;
  }
  v6 = v2[v5 - 1] == 47;
  v7 = *v3 == 47;
  v17 = *v3 == 47;
  if ( !v6 )
  {
LABEL_7:
    v8 = "/";
    if ( !v7 )
      goto LABEL_9;
  }
  v8 = (const unsigned __int8 *)&delete;
LABEL_9:
  result = -1;
  if ( config_string )
  {
    if ( v6 )
      v3 += -!v17 + 1;
    v10 = straconcat((const unsigned __int8 *)v2, v8, v3, 0);
    v11 = -1;
    if ( v10 )
    {
      v12 = secure_open(v10);
      v13 = -1;
      if ( v12 )
      {
        secure_fputs(v12, (const char *)config_string);
        v13 = secure_close(v12);
        if ( !v13 )
        {
          untouch_options(options->value.tree);
          v13 = 0;
        }
      }
      v15 = v13;
      write_config_dialog(term, v10, secsave_errno_0, v13);
      mem_free(v10);
      v11 = v15;
    }
    v16 = v11;
    mem_free(config_string);
    return v16;
  }
  return result;
}

//----- (080700C0) --------------------------------------------------------
void load_config()
{
  option_elinks *v0; // ebx
  unsigned __int8 *number; // esi
  char *v2; // eax

  v0 = config_options;
  number = (unsigned __int8 *)get_opt_(cmdline_options, "config-file")->number;
  load_config_file("/etc/elinks", number, v0, 0, 1);
  v2 = elinks_home;
  if ( !elinks_home )
    v2 = (char *)&delete;
  load_config_file((unsigned __int8 *)v2, number, v0, 0, 0);
}

//----- (08070130) --------------------------------------------------------
parse_error __cdecl parse_include(
        option_elinks *opt_tree,
        conf_parsing_state *state,
        string *mirror,
        int is_system_conf)
{
  unsigned __int8 *v4; // edi
  string *p_dumbstring; // edx
  char *v6; // eax
  unsigned __int8 *look; // [esp+18h] [ebp-30h]
  int line; // [esp+1Ch] [ebp-2Ch]
  string dumbstring; // [esp+28h] [ebp-20h] BYREF

  if ( !init_string(&dumbstring) )
    return show_parse_error(state, ERROR_NOMEM);
  skip_white(&state->pos);
  if ( *state->pos.look )
  {
    look = state->pos.look;
    line = state->pos.line;
    v4 = option_types[3].read(0, &state->pos.look, &state->pos.line);
    if ( v4 )
    {
      p_dumbstring = 0;
      v6 = (char *)&delete;
      if ( mirror )
        p_dumbstring = &dumbstring;
      if ( *v4 != 47 )
        v6 = elinks_home;
      if ( load_config_file((unsigned __int8 *)v6, v4, opt_tree, p_dumbstring, 1) )
      {
        done_string(&dumbstring);
        mem_free(v4);
        return show_parse_error(state, ERROR_VALUE);
      }
      else
      {
        done_string(&dumbstring);
        mem_free(v4);
        return 0;
      }
    }
    else
    {
      done_string(&dumbstring);
      state->pos.line = line;
      state->pos.look = look;
      return show_parse_error(state, ERROR_PARSE);
    }
  }
  else
  {
    done_string(&dumbstring);
    return show_parse_error(state, ERROR_PARSE);
  }
}

//----- (08070260) --------------------------------------------------------
void __cdecl lock_option(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (08070270) --------------------------------------------------------
void __cdecl unlock_option(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (08070280) --------------------------------------------------------
int __cdecl is_option_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (080702A0) --------------------------------------------------------
listbox_item *__cdecl get_option_root(listbox_item *item)
{
  option_elinks *v1; // eax

  v1 = (option_elinks *)*((_DWORD *)item->udata + 11);
  if ( v1 == config_options || !v1 )
    return 0;
  else
    return v1->box_item;
}

//----- (080702D0) --------------------------------------------------------
int __cdecl can_delete_option(listbox_item *item)
{
  int v1; // edx
  int result; // eax

  v1 = *((_DWORD *)item->udata + 11);
  result = 0;
  if ( v1 )
    return *(_DWORD *)(v1 + 16) & 2;
  return result;
}

//----- (080702F0) --------------------------------------------------------
void __cdecl lock_keybinding(listbox_item *item)
{
  if ( item->depth == 2 )
    ++*((_DWORD *)item->udata + 2);
}

//----- (08070310) --------------------------------------------------------
void __cdecl unlock_keybinding(listbox_item *item)
{
  if ( item->depth == 2 )
    --*((_DWORD *)item->udata + 2);
}

//----- (08070330) --------------------------------------------------------
int __cdecl is_keybinding_used(listbox_item *item)
{
  int result; // eax

  result = 0;
  if ( item->depth == 2 )
    return *((_DWORD *)item->udata + 2) != 0;
  return result;
}

//----- (08070350) --------------------------------------------------------
int __cdecl can_delete_keybinding(listbox_item *item)
{
  return item->depth == 2;
}

//----- (08070370) --------------------------------------------------------
listbox_item *__cdecl get_keybinding_action_box_item(keymap_id keymap_id, action_id_T action_id)
{
  if ( assert_failed )
    goto LABEL_2;
  assert_failed = action_id > 127;
  if ( action_id <= 127 )
    return action_box_items[keymap_id][action_id];
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
  errline = 543;
  elinks_internal("assertion action_id < ACTION_BOX_SIZE failed!");
  if ( assert_failed )
  {
LABEL_2:
    assert_failed = 0;
    return 0;
  }
  return action_box_items[keymap_id][action_id];
}

//----- (08070400) --------------------------------------------------------
listbox_item *__cdecl get_keybinding_root(listbox_item *item)
{
  listbox_item *result; // eax
  int depth; // edx

  result = 0;
  depth = item->depth;
  if ( depth )
  {
    if ( depth == 1 )
      return keymap_box_item[*((_DWORD *)item->udata + 2)];
    else
      return get_keybinding_action_box_item(*((keymap_id *)item->udata + 3), *((_DWORD *)item->udata + 4));
  }
  return result;
}

//----- (08070440) --------------------------------------------------------
void __cdecl delete_keybinding_item(listbox_item *item, int last)
{
  keybinding *udata; // ebx

  udata = (keybinding *)item->udata;
  if ( !assert_failed )
  {
    if ( item->depth != 2 || udata->object.refcount )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
      errline = 730;
      elinks_internal("assertion item->depth == 2 && !is_object_used(keybinding) failed!");
    }
    else
    {
      assert_failed = 0;
    }
  }
  free_keybinding(udata);
}

//----- (080704B0) --------------------------------------------------------
unsigned __int8 *__usercall _2@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (08070520) --------------------------------------------------------
unsigned __int8 *__cdecl get_keybinding_info(listbox_item *item, terminal *term)
{
  char *udata; // ebx
  const char *v4; // eax
  const char *v5; // eax
  const char *v6; // eax
  unsigned __int8 *action_name; // [esp+18h] [ebp-30h]
  unsigned __int8 *keymap; // [esp+1Ch] [ebp-2Ch]
  string info; // [esp+28h] [ebp-20h] BYREF

  udata = (char *)item->udata;
  if ( item->depth <= 1 || item->type == BI_FOLDER || !init_string(&info) )
    return 0;
  action_name = get_action_name(*((keymap_id *)udata + 3), *((_DWORD *)udata + 4));
  keymap = get_keymap_name(*((keymap_id *)udata + 3));
  v4 = (const char *)_2("Keystroke", term);
  add_format_to_string(&info, "%s: ", v4);
  add_keystroke_to_string(&info, (term_event_keyboard *)(udata + 20), 0);
  v5 = (const char *)_2("Action", term);
  add_format_to_string(&info, "\n%s: %s", v5, (const char *)action_name);
  v6 = (const char *)_2("Keymap", term);
  add_format_to_string(&info, "\n%s: %s", v6, (const char *)keymap);
  return info.source;
}

//----- (08070620) --------------------------------------------------------
widget_handler_status_T __cdecl push_kbdbind_save_button(dialog_data *dlg_data, widget_data *some_useless_info_button)
{
  write_config(dlg_data->win->term);
  return 0;
}

//----- (08070640) --------------------------------------------------------
widget_handler_status_T __cdecl push_kbdbind_toggle_display_button(
        dialog_data *dlg_data,
        widget_data *some_useless_info_button)
{
  keybinding_text_toggle = keybinding_text_toggle == 0;
  redraw_dialog(dlg_data, 0);
  return 0;
}

//----- (08070670) --------------------------------------------------------
widget_handler_status_T __cdecl check_option_name(dialog_data *dlg_data, widget_data *widget_data)
{
  unsigned __int8 *cdata; // edx
  unsigned __int8 v3; // al

  cdata = widget_data->cdata;
  v3 = *cdata;
  if ( !*cdata )
    return 0;
  while ( (unsigned __int8)(v3 - 97) <= 0x19u
       || (unsigned __int8)(v3 - 65) <= 0x19u
       || (unsigned __int8)(v3 - 48) <= 9u
       || v3 == 95
       || v3 == 45 )
  {
    v3 = *++cdata;
    if ( !*cdata )
      return 0;
  }
  info_box(
    dlg_data->win->term,
    (msgbox_flags)0,
    "Bad string",
    ALIGN_CENTER,
    "Option names may only contain alpha-numeric characters\nin addition to '_' and '-'.");
  return 1;
}

//----- (080706F0) --------------------------------------------------------
widget_handler_status_T __cdecl push_kbdbind_add_button(dialog_data *dlg_data, widget_data *some_useless_info_button)
{
  terminal *term; // edi
  listbox_item *sel; // ebx
  _DWORD *v5; // eax
  _DWORD *v6; // esi
  _DWORD *udata; // eax
  keymap_id v8; // eax
  unsigned __int8 *keymap_name; // ebx
  unsigned __int8 *action_name; // eax
  unsigned __int8 *v11; // ebx
  memory_list *v12; // eax

  term = dlg_data->win->term;
  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( sel && sel->depth )
  {
    v5 = mem_calloc(1u, 0x18u);
    v6 = v5;
    if ( v5 )
    {
      *v5 = term;
      v5[5] = dlg_data->widgets_data;
      udata = sel->udata;
      if ( sel->depth == 2 )
      {
        v6[1] = udata[4];
        v8 = udata[3];
      }
      else
      {
        v6[1] = udata[1];
        v8 = udata[2];
      }
      v6[2] = v8;
      keymap_name = get_keymap_name(v8);
      action_name = get_action_name((keymap_id)v6[2], v6[1]);
      v11 = msg_text(
              term,
              "Action: %s\n"
              "Keymap: %s\n"
              "\n"
              "Keystroke should be written in the format: [Shift-][Ctrl-][Alt-]Key\n"
              "Key: a,b,c,...,1,2,3,...,Space,Up,PageDown,Tab,Enter,Insert,F5,...\n"
              "\n"
              "Keystroke",
              (const char *)action_name,
              (const char *)keymap_name);
      v12 = getml(v6, v11, 0);
      input_dialog(
        term,
        v12,
        "Add keybinding",
        v11,
        v6,
        0,
        1024,
        (unsigned __int8 *)&delete,
        0,
        0,
        check_keystroke,
        really_add_keybinding,
        0);
    }
  }
  else
  {
    info_box(term, (msgbox_flags)0, "Add keybinding", ALIGN_CENTER, "Need to select an action.");
  }
  return 0;
}

//----- (08070860) --------------------------------------------------------
widget_handler_status_T __cdecl push_add_button_0(dialog_data *dlg_data, widget_data *some_useless_info_button)
{
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // edx
  _BYTE *udata; // ebx
  _DWORD *v5; // eax
  void *v6; // esi
  int v8; // eax
  memory_list *v9; // [esp+4h] [ebp-64h]
  terminal *term; // [esp+4Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  sel = listbox_widget_data->sel;
  if ( sel
    && (udata = sel->udata) != 0
    && (sel->type != BI_FOLDER
     || (*((_BYTE *)sel + 24) & 1) != 0
     || (v8 = (int)listbox_widget_data->ops->get_root(sel)) != 0 && (udata = *(_BYTE **)(v8 + 28)) != 0)
    && ((udata[16] & 2) != 0 || (udata = (_BYTE *)*((_DWORD *)udata + 11)) != 0 && (udata[16] & 2) != 0) )
  {
    v5 = mem_alloc(8u);
    v6 = v5;
    if ( v5 )
    {
      *v5 = udata;
      v5[1] = dlg_data->widgets_data;
      v9 = getml(v5, 0);
      input_dialog(
        term,
        v9,
        "Add option",
        (unsigned __int8 *)&str,
        v6,
        0,
        1024,
        (unsigned __int8 *)&delete,
        0,
        0,
        check_option_name,
        add_option_to_tree,
        0);
    }
  }
  else
  {
    info_box(term, (msgbox_flags)0, "Add option", ALIGN_CENTER, "Cannot add an option here.");
  }
  return 0;
}

//----- (080709C0) --------------------------------------------------------
void __cdecl really_really_add_keybinding(void *data)
{
  keybinding *v1; // eax
  listbox_item *box_item; // eax

  if ( !assert_failed )
  {
    assert_failed = data == 0;
    if ( !data )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
      errline = 776;
      elinks_internal("assertion hop failed!");
    }
  }
  v1 = add_keybinding(*((keymap_id *)data + 2), *((_DWORD *)data + 1), (term_event_keyboard *)((char *)data + 12), -1);
  if ( v1 )
  {
    box_item = v1->box_item;
    if ( box_item )
      listbox_sel(*((widget_data **)data + 5), box_item);
  }
}

//----- (08070A50) --------------------------------------------------------
void __cdecl really_add_keybinding(void *data, unsigned __int8 *keystroke)
{
  terminal **v2; // eax
  terminal **v3; // esi
  unsigned __int8 *action_name; // eax
  unsigned __int8 *v6; // ebx
  memory_list *v7; // eax
  string canonical; // [esp+44h] [ebp-24h] BYREF
  int action_id[4]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( keybinding_exists(*((keymap_id *)data + 2), (term_event_keyboard *)((char *)data + 12), action_id)
    && action_id[0] )
  {
    if ( action_id[0] != *((_DWORD *)data + 1) )
    {
      v2 = (terminal **)mem_alloc(0x18u);
      v3 = v2;
      if ( v2 )
      {
        *v2 = *(terminal **)data;
        v2[1] = (terminal *)*((_DWORD *)data + 1);
        v2[2] = (terminal *)*((_DWORD *)data + 2);
        v2[3] = (terminal *)*((_DWORD *)data + 3);
        v2[4] = (terminal *)*((_DWORD *)data + 4);
        v2[5] = (terminal *)*((_DWORD *)data + 5);
        if ( init_string(&canonical) )
          add_keystroke_to_string(&canonical, (term_event_keyboard *)((char *)data + 12), 0);
        action_name = get_action_name(*((keymap_id *)data + 2), action_id[0]);
        if ( canonical.length )
          keystroke = canonical.source;
        v6 = msg_text(
               *v3,
               "The keystroke \"%s\" is currently used for \"%s\".\nAre you sure you want to replace it?",
               keystroke,
               action_name);
        v7 = getml(v3, 0);
        msg_box(
          *v3,
          v7,
          MSGBOX_FREE_TEXT,
          "Keystroke already used",
          ALIGN_CENTER,
          v6,
          v3,
          2,
          "~Yes",
          really_really_add_keybinding,
          1,
          "~No",
          0,
          2);
        done_string(&canonical);
      }
    }
  }
  else
  {
    really_really_add_keybinding(data);
  }
}
// 8070A50: using guessed type action_id_T action_id[4];

//----- (08070BD0) --------------------------------------------------------
widget_handler_status_T __cdecl check_keystroke(dialog_data *dlg_data, widget_data *widget_data)
{
  char *udata2; // ebx
  int v3; // edx
  widget_handler_status_T result; // eax

  udata2 = (char *)dlg_data->dlg->udata2;
  v3 = parse_keystroke(widget_data->cdata, (term_event_keyboard *)(udata2 + 12));
  result = EVENT_PROCESSED;
  if ( v3 < 0 )
  {
    info_box(*(terminal **)udata2, (msgbox_flags)0, "Add keybinding", ALIGN_CENTER, "Invalid keystroke.");
    return 1;
  }
  return result;
}

//----- (08070C40) --------------------------------------------------------
void __cdecl delete_option_item(listbox_item *item, int last)
{
  option_elinks *udata; // ebx
  int refcount; // edx

  udata = (option_elinks *)item->udata;
  if ( !assert_failed )
  {
    refcount = udata->object.refcount;
    assert_failed = refcount != 0;
    if ( refcount )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
      errline = 238;
      elinks_internal("assertion !is_object_used(option) failed!");
    }
  }
  if ( (udata->flags & 0x20) != 0 )
    delete_option(udata);
  else
    mark_option_as_deleted(udata);
}

//----- (08070CC0) --------------------------------------------------------
void done_keybinding_listboxes()
{
  void **next; // ecx
  list_head_elinks *v1; // edx
  list_head_elinks *v2; // eax
  list_head_elinks *i; // ebx
  list_head_elinks *j; // edx
  list_head_elinks *v5; // esi
  list_head_elinks *v6; // edi
  list_head_elinks *v7; // eax
  list_head_elinks *k; // ebx
  list_head_elinks *m; // ecx
  list_head_elinks *v10; // esi
  list_head_elinks *v11; // edi
  void **v12; // eax
  void **n; // ebx
  void **ii; // edx
  void **v15; // esi
  _DWORD *v16; // edx
  listbox_item *action; // [esp+14h] [ebp-24h]
  list_head_elinks *p_child; // [esp+18h] [ebp-20h]
  listbox_item *keymap; // [esp+1Ch] [ebp-1Ch]

  next = (void **)keybinding_browser.root.child.next;
  action = (listbox_item *)keybinding_browser.root.child.next;
  if ( keybinding_browser.root.child.next != &keybinding_browser.root.child )
  {
    do
    {
      v1 = (list_head_elinks *)action->child.next;
      p_child = &action->child;
      keymap = (listbox_item *)v1;
      if ( v1 != &action->child )
      {
        do
        {
          v2 = (list_head_elinks *)keymap->child.next;
          for ( i = v2; i != &keymap->child; i = (list_head_elinks *)i->next )
            ;
          for ( j = (list_head_elinks *)keymap->child.prev; j != i; j = (list_head_elinks *)j->prev )
            ;
          v5 = (list_head_elinks *)v2->next;
          if ( v2 != i )
          {
            do
            {
              v6 = v5;
              v5->prev = v2->prev;
              *(_DWORD *)v2->prev = v2->next;
              mem_free(v2);
              v5 = (list_head_elinks *)v5->next;
              v2 = v6;
            }
            while ( v6 != i );
          }
          keymap = keymap->next;
        }
        while ( keymap != (listbox_item *)p_child );
        v1 = (list_head_elinks *)action->child.next;
      }
      v7 = v1;
      for ( k = v1; k != p_child; k = (list_head_elinks *)k->next )
        ;
      for ( m = (list_head_elinks *)action->child.prev; m != k; m = (list_head_elinks *)m->prev )
        ;
      v10 = (list_head_elinks *)v1->next;
      if ( v1 != k )
      {
        do
        {
          v11 = v10;
          v10->prev = v7->prev;
          *(_DWORD *)v7->prev = v7->next;
          mem_free(v7);
          v10 = (list_head_elinks *)v10->next;
          v7 = v11;
        }
        while ( v11 != k );
      }
      action = action->next;
    }
    while ( action != (listbox_item *)&keybinding_browser.root.child );
    next = (void **)keybinding_browser.root.child.next;
  }
  v12 = next;
  for ( n = next; n != &keybinding_browser.root.child.next; n = (void **)*n )
    ;
  for ( ii = (void **)keybinding_browser.root.child.prev; ii != n; ii = (void **)ii[1] )
    ;
  v15 = (void **)*next;
  if ( next != n )
  {
    v16 = *next;
    while ( 1 )
    {
      v16[1] = v12[1];
      *(_DWORD *)v12[1] = *v12;
      mem_free(v12);
      v16 = *v15;
      v12 = v15;
      if ( v15 == n )
        break;
      v15 = (void **)*v15;
    }
  }
}

//----- (08070E20) --------------------------------------------------------
unsigned __int8 *__usercall get_range_string@<eax>(option_elinks *option_elinks@<eax>)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  option_type type; // eax
  string info; // [esp+18h] [ebp-10h] BYREF

  inited = init_string(&info);
  result = 0;
  if ( inited )
  {
    type = option_elinks->type;
    if ( type )
    {
      if ( (unsigned int)(type - 1) <= 1 )
        add_format_to_string(&info, "[%li..%li]", option_elinks->min, option_elinks->max);
    }
    else
    {
      add_to_string(&info, "[0|1]");
    }
    return info.source;
  }
  return result;
}

//----- (08070EA0) --------------------------------------------------------
widget_handler_status_T __cdecl push_save_button(dialog_data *dlg_data, widget_data *some_useless_info_button)
{
  write_config(dlg_data->win->term);
  update_hierbox_browser(&option_browser);
  return 0;
}

//----- (08070ED0) --------------------------------------------------------
void __cdecl add_option_to_tree(void *data, unsigned __int8 *name)
{
  option_elinks *opt_rec_real; // eax
  option_elinks *opt_rec; // eax

  opt_rec_real = get_opt_rec_real(*(option_elinks **)data, name);
  if ( opt_rec_real && SLOBYTE(opt_rec_real->flags) < 0 )
    delete_option(opt_rec_real);
  opt_rec = get_opt_rec(*(option_elinks **)data, name);
  if ( opt_rec )
    listbox_sel(*((widget_data **)data + 1), opt_rec->box_item);
}

//----- (08070F40) --------------------------------------------------------
widget_handler_status_T __cdecl check_valid_option(dialog_data *dlg_data, widget_data *widget_data)
{
  dialog *dlg; // eax
  terminal *term; // edi
  option_elinks *udata; // ebx
  unsigned __int8 *cdata; // eax
  unsigned __int8 *v6; // esi
  int (*set)(option_elinks *, unsigned __int8 *); // eax
  session *ses; // [esp+2Ch] [ebp-2Ch]
  int dummy_line; // [esp+38h] [ebp-20h] BYREF
  unsigned __int8 *value; // [esp+3Ch] [ebp-1Ch] BYREF

  dlg = dlg_data->dlg;
  term = dlg_data->win->term;
  udata = (option_elinks *)dlg->udata;
  ses = (session *)dlg->udata2;
  cdata = widget_data->cdata;
  dummy_line = 0;
  commandline = 1;
  value = cdata;
  v6 = option_types[udata->type].read(udata, &value, &dummy_line);
  if ( !v6 )
    goto LABEL_5;
  set = option_types[udata->type].set;
  if ( !set || !set(udata, v6) )
  {
    mem_free(v6);
LABEL_5:
    commandline = 0;
    info_box(term, (msgbox_flags)0, "Error", ALIGN_LEFT, "Bad option value.");
    return 1;
  }
  option_changed(ses, udata);
  commandline = 0;
  mem_free(v6);
  return 0;
}

//----- (08071030) --------------------------------------------------------
void __cdecl keybinding_manager(session *ses)
{
  hierbox_browser_0(&keybinding_browser, ses);
}

//----- (08071050) --------------------------------------------------------
void __cdecl options_manager(session *ses)
{
  hierbox_browser_0(&option_browser, ses);
}

//----- (08071070) --------------------------------------------------------
void __cdecl init_keybinding_listboxes(keymap *keymap_table, action_list *actions)
{
  listbox_item *v2; // esi
  action *i; // ebx
  bool v4; // zf
  unsigned __int8 *desc; // edx
  listbox_item *v6; // eax
  keymap_id keymap_id; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]

  v9 = 0;
  keymap_id = KEYMAP_MAIN;
  do
  {
    v2 = add_listbox_item(0, &keybinding_browser.root, BI_FOLDER, keymap_table, -1);
    if ( v2 )
    {
      for ( i = actions[v9].actions; i->str; ++i )
      {
        while ( 1 )
        {
          if ( !assert_failed )
          {
            v4 = i->num <= 127;
            assert_failed = i->num > 127;
            if ( v4 )
              break;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
            errline = 569;
            elinks_internal("assertion act->num < ACTION_BOX_SIZE failed!");
            if ( !assert_failed )
              break;
          }
          ++i;
          assert_failed = 0;
          if ( !i->str )
            goto LABEL_14;
        }
        if ( i->num > 1u )
        {
          desc = i->desc;
          assert_failed = desc == 0;
          if ( !desc )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
            errline = 577;
            elinks_internal("assertion act->desc failed!");
          }
          v6 = add_listbox_item(0, v2, BI_FOLDER, i, -1);
          if ( v6 )
          {
            *((_BYTE *)v6 + 24) |= 1u;
            action_box_items[keymap_id][i->num] = v6;
          }
        }
      }
LABEL_14:
      keymap_box_item[keymap_id] = v2;
    }
    ++v9;
    ++keymap_id;
    ++keymap_table;
  }
  while ( v9 != 3 );
}

//----- (08071200) --------------------------------------------------------
void __cdecl disable_success_msgbox(void *dummy)
{
  option_elinks *opt_rec; // eax

  get_opt_(config_options, "ui.success_msgbox")->number = 0;
  opt_rec = get_opt_rec(config_options, "ui.success_msgbox");
  option_changed(0, opt_rec);
}

//----- (08071250) --------------------------------------------------------
void __cdecl write_config_dialog(terminal *term, unsigned __int8 *config_file, int secsave_error, int stdio_error)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  char *v9; // [esp+8h] [ebp-60h]
  unsigned __int8 *strerr; // [esp+4Ch] [ebp-1Ch]

  if ( stdio_error || secsave_error )
  {
    strerr = secsave_strerror((secsave_errno)secsave_error, term);
    if ( stdio_error > 0
      && (v9 = strerror(stdio_error), v4 = straconcat(strerr, " (", v9, &byte_812757C, 0), (v5 = v4) != 0) )
    {
      v6 = msg_text(term, "Unable to write to config file %s.\n%s", (const char *)config_file, (const char *)v4);
      info_box(term, MSGBOX_FREE_TEXT, "Write config error", ALIGN_CENTER, v6);
      mem_free(v5);
    }
    else
    {
      v7 = msg_text(term, "Unable to write to config file %s.\n%s", (const char *)config_file, (const char *)strerr);
      info_box(term, MSGBOX_FREE_TEXT, "Write config error", ALIGN_CENTER, v7);
    }
  }
  else if ( get_opt_(config_options, "ui.success_msgbox")->number )
  {
    v8 = msg_text(term, "Options were saved successfully to config file %s.", (const char *)config_file);
    msg_box(
      term,
      0,
      MSGBOX_FREE_TEXT,
      "Write config success",
      ALIGN_CENTER,
      v8,
      0,
      2,
      &okbutton,
      0,
      3,
      "~Do not show anymore",
      disable_success_msgbox,
      0);
  }
}

//----- (08071410) --------------------------------------------------------
unsigned __int8 *__cdecl get_option_text(listbox_item *item, terminal *term)
{
  void *udata; // eax
  unsigned __int8 *v3; // ebx
  int v4; // eax
  int v5; // esi
  unsigned __int8 *v6; // eax
  int terminal_codepage; // eax
  int v9; // edi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v11; // edi
  int v12; // eax
  int v13; // esi
  unsigned __int8 *v14; // eax

  udata = item->udata;
  v3 = (unsigned __int8 *)*((_DWORD *)udata + 10);
  if ( !v3 )
    v3 = (unsigned __int8 *)*((_DWORD *)udata + 3);
  if ( (*((_BYTE *)udata + 16) & 8) != 0 )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v9 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v9;
      }
    }
    v11 = gettext(&byte_8131C02);
    if ( v3 && *v3 )
    {
      if ( term )
      {
        v12 = get_terminal_codepage(term);
        v13 = v12;
        if ( v12 != current_charset )
        {
          v14 = get_cp_mime_name(v12);
          bind_textdomain_codeset("elinks", v14);
          current_charset = v13;
        }
      }
      v3 = gettext(v3);
    }
    return straconcat(v3, " (", v11, &byte_812757C, 0);
  }
  else
  {
    if ( v3 && *v3 )
    {
      if ( term )
      {
        v4 = get_terminal_codepage(term);
        v5 = v4;
        if ( v4 != current_charset )
        {
          v6 = get_cp_mime_name(v4);
          bind_textdomain_codeset("elinks", v6);
          current_charset = v5;
        }
      }
      v3 = gettext(v3);
    }
    return stracpy(v3);
  }
}

//----- (08071570) --------------------------------------------------------
widget_handler_status_T __cdecl push_edit_button_0(dialog_data *dlg_data, widget_data *some_useless_info_button)
{
  terminal *term; // edi
  listbox_item *sel; // eax
  option_elinks *udata; // ebx
  dialog *v5; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *name; // eax
  int v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // eax
  unsigned __int8 *v12; // eax
  unsigned __int8 *v13; // edx
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *desc; // edx
  int v18; // eax
  unsigned __int8 *v19; // eax
  int v20; // eax
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *range_string; // eax
  unsigned __int8 *v24; // ebx
  int v26; // eax
  int v27; // ebx
  unsigned __int8 *v28; // eax
  unsigned __int8 *v29; // eax
  int v30; // eax
  int v31; // ebx
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  int v34; // eax
  int v35; // ebx
  unsigned __int8 *v36; // eax
  unsigned __int8 *v37; // eax
  bool v38; // zf
  memory_list *v39; // eax
  int v40; // [esp+38h] [ebp-40h]
  int v41; // [esp+38h] [ebp-40h]
  int v42; // [esp+38h] [ebp-40h]
  int v43; // [esp+3Ch] [ebp-3Ch]
  int v44; // [esp+3Ch] [ebp-3Ch]
  int v45; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v46; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v47; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v48; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v49; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v50; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v51; // [esp+40h] [ebp-38h]
  unsigned __int8 *p; // [esp+48h] [ebp-30h]
  unsigned __int8 *pa; // [esp+48h] [ebp-30h]
  unsigned __int8 *msgid; // [esp+4Ch] [ebp-2Ch]
  const unsigned __int8 *msgida; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *msgidb; // [esp+4Ch] [ebp-2Ch]
  string string; // [esp+58h] [ebp-20h] BYREF

  term = dlg_data->win->term;
  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( !sel )
    return 0;
  udata = (option_elinks *)sel->udata;
  if ( !udata )
    return 0;
  if ( option_types[udata->type].write && option_types[udata->type].read && option_types[udata->type].set )
  {
    msgid = (unsigned __int8 *)dlg_data->dlg->udata;
    if ( !init_string(&string) )
      return 0;
    commandline = 1;
    option_types[udata->type].write(udata, &string);
    commandline = 0;
    v5 = (dialog *)mem_calloc(1u, 0x514u);
    if ( !v5 )
    {
      done_string(&string);
      return 0;
    }
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        v43 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v43;
      }
    }
    v5->title = gettext(&byte_8127A45);
    v5->layouter = generic_dialog_layouter;
    v5->udata = udata;
    v5->udata2 = msgid;
    safe_strncpy((unsigned __int8 *)&v5[3].abort, string.source, 0x400u);
    done_string(&string);
    name = option_types[udata->type].name;
    msgida = name;
    if ( name && *name )
    {
      if ( term )
      {
        v9 = get_terminal_codepage(term);
        if ( v9 != current_charset )
        {
          v44 = v9;
          v10 = get_cp_mime_name(v9);
          bind_textdomain_codeset("elinks", v10);
          current_charset = v44;
        }
      }
      msgida = gettext(msgida);
    }
    if ( term )
    {
      v11 = get_terminal_codepage(term);
      if ( v11 != current_charset )
      {
        v45 = v11;
        v12 = get_cp_mime_name(v11);
        bind_textdomain_codeset("elinks", v12);
        current_charset = v45;
      }
    }
    v13 = gettext(&byte_8132B67);
    p = udata->name;
    if ( term )
    {
      v46 = v13;
      v14 = get_terminal_codepage(term);
      v13 = v46;
      if ( v14 != current_charset )
      {
        v40 = v14;
        v15 = get_cp_mime_name(v14);
        bind_textdomain_codeset("elinks", v15);
        current_charset = v40;
        v13 = v46;
      }
    }
    v47 = v13;
    v16 = gettext(&str);
    msgidb = straconcat(v16, ": ", p, "\n", v47, ": ", msgida, 0);
    desc = udata->desc;
    if ( !desc )
      desc = "N/A";
    if ( *desc )
    {
      if ( term )
      {
        v48 = desc;
        v18 = get_terminal_codepage(term);
        desc = v48;
        if ( v18 != current_charset )
        {
          v41 = v18;
          v19 = get_cp_mime_name(v18);
          bind_textdomain_codeset("elinks", v19);
          current_charset = v41;
          desc = v48;
        }
      }
      desc = gettext(desc);
    }
    if ( term )
    {
      v49 = desc;
      v20 = get_terminal_codepage(term);
      desc = v49;
      if ( v20 != current_charset )
      {
        v42 = v20;
        v21 = get_cp_mime_name(v20);
        bind_textdomain_codeset("elinks", v21);
        current_charset = v42;
        desc = v49;
      }
    }
    v50 = desc;
    v22 = gettext(&byte_81283B4);
    pa = straconcat(v22, ": \n", v50, 0);
    range_string = get_range_string(udata);
    v24 = range_string;
    if ( range_string )
    {
      if ( *range_string && (v51 = straconcat(msgidb, &start, range_string, 0)) != 0 )
        mem_free(msgidb);
      else
        v51 = msgidb;
      mem_free(v24);
      msgidb = v51;
    }
    if ( !msgidb )
    {
      if ( pa )
        mem_free(pa);
      goto LABEL_40;
    }
    if ( !pa )
    {
      mem_free(msgidb);
LABEL_40:
      mem_free(v5);
      return 0;
    }
    add_dlg_text(v5, msgidb, ALIGN_LEFT, 0);
    if ( term )
    {
      v26 = get_terminal_codepage(term);
      v27 = v26;
      if ( v26 != current_charset )
      {
        v28 = get_cp_mime_name(v26);
        bind_textdomain_codeset("elinks", v28);
        current_charset = v27;
      }
    }
    v29 = gettext(&label);
    add_dlg_field_do(v5, WIDGET_FIELD, v29, 0, 0, check_valid_option, 1024, &v5[3].abort, 0, INPFIELD_FLOAT);
    add_dlg_text(v5, pa, ALIGN_LEFT, 0);
    if ( term )
    {
      v30 = get_terminal_codepage(term);
      v31 = v30;
      if ( v30 != current_charset )
      {
        v32 = get_cp_mime_name(v30);
        bind_textdomain_codeset("elinks", v32);
        current_charset = v31;
      }
    }
    v33 = gettext(&okbutton);
    add_dlg_button_do(v5, v33, 1, ok_dialog, 0, 0, 0);
    if ( term )
    {
      v34 = get_terminal_codepage(term);
      v35 = v34;
      if ( v34 != current_charset )
      {
        v36 = get_cp_mime_name(v34);
        bind_textdomain_codeset("elinks", v36);
        current_charset = v35;
      }
    }
    v37 = gettext(&cancelbutton);
    add_dlg_button_do(v5, v37, 2, cancel_dialog, 0, 0, 0);
    if ( !assert_failed )
    {
      v38 = v5->number_of_widgets == 5;
      assert_failed = v5->number_of_widgets != 5;
      if ( !v38 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/dialogs.c";
        errline = 368;
        elinks_internal("assertion 5 == (dlg)->number_of_widgets failed!");
      }
    }
    v39 = getml(v5, msgidb, pa, 0);
    do_dialog(term, v5, v39);
    return 0;
  }
  else
  {
    info_box(
      term,
      (msgbox_flags)0,
      (unsigned __int8 *)&byte_8127A45,
      ALIGN_LEFT,
      "This option cannot be edited. This means that this is some special option like a folder - try to press a space in "
      "order to see its contents.");
    return 0;
  }
}

//----- (08071C50) --------------------------------------------------------
unsigned __int8 *__cdecl get_keybinding_text(listbox_item *item, terminal *term)
{
  char *udata; // ebx
  int depth; // eax
  unsigned __int8 *v4; // ebx
  unsigned __int8 *result; // eax
  int terminal_codepage; // eax
  int v7; // esi
  unsigned __int8 *cp_mime_name; // eax
  string *inited; // edx
  string info; // [esp+18h] [ebp-10h] BYREF

  udata = (char *)item->udata;
  depth = item->depth;
  if ( !depth )
  {
    if ( keybinding_text_toggle )
    {
LABEL_3:
      v4 = *(unsigned __int8 **)udata;
      return stracpy(v4);
    }
    v4 = (unsigned __int8 *)*((_DWORD *)udata + 2);
    if ( !v4 )
      return stracpy(v4);
LABEL_11:
    if ( *v4 )
    {
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        v7 = terminal_codepage;
        if ( terminal_codepage != current_charset )
        {
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v7;
        }
      }
      v4 = gettext(v4);
    }
    return stracpy(v4);
  }
  if ( depth <= 1 )
  {
    if ( keybinding_text_toggle )
      goto LABEL_3;
    v4 = (unsigned __int8 *)*((_DWORD *)udata + 3);
    if ( !v4 )
      return stracpy(v4);
    goto LABEL_11;
  }
  inited = init_string(&info);
  result = 0;
  if ( inited )
  {
    add_keystroke_to_string(&info, (term_event_keyboard *)(udata + 20), 0);
    return info.source;
  }
  return result;
}

//----- (08071D40) --------------------------------------------------------
listbox_match __cdecl match_option(listbox_item *item, terminal *term, unsigned __int8 *text)
{
  _DWORD *udata; // ebx
  listbox_match result; // eax
  int v5; // edx
  unsigned __int8 *v6; // ebx
  int terminal_codepage; // eax
  int v8; // edi
  unsigned __int8 *cp_mime_name; // eax

  udata = item->udata;
  result = LISTBOX_MATCH_IMPOSSIBLE;
  if ( udata[5] != 9 )
  {
    v5 = strcasestr(udata[3], text);
    result = LISTBOX_MATCH_OK;
    if ( !v5 )
    {
      v6 = (unsigned __int8 *)udata[10];
      LOBYTE(result) = 1;
      if ( v6 )
      {
        if ( *v6 )
        {
          if ( term )
          {
            terminal_codepage = get_terminal_codepage(term);
            v8 = terminal_codepage;
            if ( terminal_codepage != current_charset )
            {
              cp_mime_name = get_cp_mime_name(terminal_codepage);
              bind_textdomain_codeset("elinks", cp_mime_name);
              current_charset = v8;
            }
          }
          v6 = gettext(v6);
        }
        return strcasestr(v6, text) == 0;
      }
    }
  }
  return result;
}
// 80596D8: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08071E00) --------------------------------------------------------
listbox_match __cdecl match_keybinding(listbox_item *item, terminal *term, unsigned __int8 *text)
{
  listbox_match result; // eax
  unsigned __int8 **udata; // ecx
  unsigned __int8 *v5; // ebx
  int terminal_codepage; // eax
  int v7; // esi
  unsigned __int8 *cp_mime_name; // eax

  result = LISTBOX_MATCH_IMPOSSIBLE;
  udata = (unsigned __int8 **)item->udata;
  if ( item->depth == 1 )
  {
    if ( keybinding_text_toggle )
    {
      v5 = *udata;
    }
    else
    {
      v5 = udata[3];
      if ( !v5 )
        return 1;
      if ( *v5 )
      {
        if ( term )
        {
          terminal_codepage = get_terminal_codepage(term);
          v7 = terminal_codepage;
          if ( terminal_codepage != current_charset )
          {
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            current_charset = v7;
          }
        }
        v5 = gettext(v5);
      }
    }
    if ( v5 )
      return strcasestr(v5, text) == 0;
    return 1;
  }
  return result;
}
// 80596D8: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (08071ED0) --------------------------------------------------------
unsigned __int8 *__cdecl get_option_info(listbox_item *item, terminal *term)
{
  option_elinks *udata; // ebx
  string *inited; // edx
  unsigned __int8 *result; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v7; // eax
  option_type v8; // eax
  unsigned __int8 *name; // edx
  int v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  option_type v15; // eax
  unsigned __int8 *range_string; // eax
  unsigned __int8 *v17; // edx
  int v18; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  const unsigned __int8 *desc; // ebx
  int v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // ebx
  int v25; // eax
  int v26; // esi
  unsigned __int8 *v27; // eax
  unsigned __int8 *v28; // eax
  int v29; // eax
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // eax
  int v32; // eax
  unsigned __int8 *v33; // eax
  unsigned __int8 *v34; // eax
  unsigned __int8 *source; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourcea; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourceb; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourced; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourcee; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourcef; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourcec; // [esp+18h] [ebp-30h]
  unsigned __int8 *sourceg; // [esp+18h] [ebp-30h]
  unsigned __int8 *type; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *typea; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *typeb; // [esp+1Ch] [ebp-2Ch]
  string value; // [esp+20h] [ebp-28h] BYREF
  string info; // [esp+28h] [ebp-20h] BYREF

  udata = (option_elinks *)item->udata;
  inited = init_string(&info);
  result = 0;
  if ( inited )
  {
    type = udata->name;
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        source = (unsigned __int8 *)terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = (int)source;
      }
    }
    v7 = gettext(&str);
    add_format_to_string(&info, "%s: %s", (const char *)v7, (const char *)type);
    v8 = udata->type;
    name = option_types[v8].name;
    typea = name;
    if ( name && *name )
    {
      if ( term )
      {
        v10 = get_terminal_codepage(term);
        if ( v10 != current_charset )
        {
          sourcea = (unsigned __int8 *)v10;
          v11 = get_cp_mime_name(v10);
          bind_textdomain_codeset("elinks", v11);
          current_charset = (int)sourcea;
        }
      }
      typea = gettext(typea);
      v8 = udata->type;
    }
    if ( v8 == OPT_TREE )
    {
      if ( term )
      {
        v32 = get_terminal_codepage(term);
        if ( v32 != current_charset )
        {
          sourceg = (unsigned __int8 *)v32;
          v33 = get_cp_mime_name(v32);
          bind_textdomain_codeset("elinks", v33);
          current_charset = (int)sourceg;
        }
      }
      v34 = gettext(&byte_81283CA);
      typea = straconcat(typea, &start, v34, 0);
    }
    if ( term )
    {
      v12 = get_terminal_codepage(term);
      if ( v12 != current_charset )
      {
        sourceb = (unsigned __int8 *)v12;
        v13 = get_cp_mime_name(v12);
        bind_textdomain_codeset("elinks", v13);
        current_charset = (int)sourceb;
      }
    }
    v14 = gettext(&byte_8132B67);
    add_format_to_string(&info, "\n%s: %s", (const char *)v14, (const char *)typea);
    v15 = udata->type;
    if ( v15 == OPT_TREE )
    {
      mem_free(typea);
      v15 = udata->type;
    }
    if ( option_types[v15].write )
    {
      if ( !init_string(&value) )
      {
        done_string(&info);
        return 0;
      }
      option_types[udata->type].write(udata, &value);
      range_string = get_range_string(udata);
      v17 = range_string;
      if ( range_string )
      {
        if ( *range_string )
        {
          sourcec = range_string;
          add_to_string(&info, &start);
          add_to_string(&info, sourcec);
          v17 = sourcec;
        }
        mem_free(v17);
      }
      typeb = value.source;
      if ( term )
      {
        v18 = get_terminal_codepage(term);
        if ( v18 != current_charset )
        {
          sourced = (unsigned __int8 *)v18;
          v19 = get_cp_mime_name(v18);
          bind_textdomain_codeset("elinks", v19);
          current_charset = (int)sourced;
        }
      }
      v20 = gettext(&label);
      add_format_to_string(&info, "\n%s: %s", (const char *)v20, (const char *)typeb);
      done_string(&value);
      if ( (udata->flags & 8) != 0 )
      {
        if ( term )
        {
          v29 = get_terminal_codepage(term);
          if ( v29 != current_charset )
          {
            sourcef = (unsigned __int8 *)v29;
            v30 = get_cp_mime_name(v29);
            bind_textdomain_codeset("elinks", v30);
            current_charset = (int)sourcef;
          }
        }
        v31 = gettext(&byte_8113370);
        add_to_string(&info, v31);
      }
    }
    desc = udata->desc;
    if ( !desc )
      desc = "N/A";
    if ( *desc )
    {
      if ( term )
      {
        v22 = get_terminal_codepage(term);
        if ( v22 != current_charset )
        {
          sourcee = (unsigned __int8 *)v22;
          v23 = get_cp_mime_name(v22);
          bind_textdomain_codeset("elinks", v23);
          current_charset = (int)sourcee;
        }
      }
      v24 = gettext(desc);
      if ( *v24 )
      {
        if ( term )
        {
          v25 = get_terminal_codepage(term);
          v26 = v25;
          if ( v25 != current_charset )
          {
            v27 = get_cp_mime_name(v25);
            bind_textdomain_codeset("elinks", v27);
            current_charset = v26;
          }
        }
        v28 = gettext(&byte_81283B4);
        add_format_to_string(&info, "\n\n%s:\n%s", (const char *)v28, (const char *)v24);
      }
    }
    return info.source;
  }
  return result;
}

//----- (08072350) --------------------------------------------------------
void done_home()
{
  if ( elinks_home )
    mem_free(elinks_home);
}

//----- (08072370) --------------------------------------------------------
const char *__usercall test_confdir@<eax>(
        unsigned __int8 *home@<eax>,
        unsigned __int8 *path@<edx>,
        unsigned __int8 *error_message@<ecx>)
{
  const char *v3; // ebx
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // edx
  unsigned __int8 *v7; // ecx
  size_t v8; // eax
  size_t v9; // esi
  size_t v10; // edi
  const char *v11; // eax
  char v12; // bl
  int v13; // eax
  unsigned __int8 *v14; // edx
  const unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // eax
  int v17; // eax
  unsigned __int8 *v18; // eax
  char *v19; // [esp+0h] [ebp-98h]
  unsigned __int8 *msgid; // [esp+14h] [ebp-84h]
  unsigned __int8 *v24; // [esp+18h] [ebp-80h]
  unsigned __int8 *v26; // [esp+18h] [ebp-80h]
  const char *v27; // [esp+1Ch] [ebp-7Ch]
  stat st; // [esp+20h] [ebp-78h] BYREF

  if ( !path || !*path )
    return 0;
  if ( home && *home && *path != 47 )
  {
    v5 = straconcat(home, "/", path, 0);
    v6 = path;
    v7 = error_message;
    v3 = (const char *)v5;
  }
  else
  {
    v16 = stracpy(path);
    v7 = error_message;
    v6 = path;
    v3 = (const char *)v16;
  }
  if ( v3 )
  {
    v24 = v6;
    msgid = v7;
    v8 = strlen(v3);
    v9 = v8 - 1;
    v10 = v8 - 1;
    if ( (int)(v8 - 1) > 0 && v3[v8 - 1] == 47 )
    {
      v11 = &v3[v8];
      v27 = v3;
      do
      {
        if ( !--v9 )
        {
          v3 = v27;
          v10 = 0;
          goto LABEL_16;
        }
        v12 = *(v11 - 2);
        --v11;
        v10 = v9;
      }
      while ( v12 == 47 );
      v3 = v27;
    }
LABEL_16:
    v3[v10 + 1] = 0;
    v13 = __xstat64(3, v3, &st);
    v14 = v24;
    v15 = msgid;
    if ( v13 )
    {
      v17 = mkdir(v3, 0x1C0u);
      v14 = v24;
      v15 = msgid;
      if ( !v17 )
        return v3;
    }
    else if ( (st.st_mode & 0xF000) == 0x4000 )
    {
      first_use = 0;
      return v3;
    }
    if ( v15 )
    {
      v26 = v14;
      v18 = gettext(v15);
      usrerror(v18, v26, v3);
      sleep(3u);
    }
    v19 = (char *)v3;
    v3 = 0;
    mem_free(v19);
  }
  return v3;
}
// 8058E68: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (08072520) --------------------------------------------------------
void init_home()
{
  char *v0; // eax
  unsigned __int8 *v1; // ebx
  size_t v2; // eax
  size_t v3; // edx
  size_t v4; // esi
  unsigned __int8 *v5; // eax
  char v6; // cl
  option_value *opt; // eax
  unsigned __int8 *v8; // eax
  size_t v9; // eax
  int v10; // edx
  int v11; // esi
  unsigned __int8 *v12; // eax
  char v13; // cl
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *dst; // [esp+1Ch] [ebp-Ch] BYREF

  first_use = 1;
  v0 = getenv("HOME");
  if ( !v0 || (v1 = stracpy((const unsigned __int8 *)v0)) == 0 )
  {
    if ( !program_0.path || (v8 = stracpy(program_0.path), (v1 = v8) == 0) )
    {
      v1 = 0;
      goto LABEL_10;
    }
    v9 = strlen((const char *)v8);
    v10 = v9 - 1;
    v11 = v9 - 1;
    if ( (int)(v9 - 1) >= 0 && v1[v9 - 1] != 47 )
    {
      v12 = &v1[v9];
      while ( --v10 != -1 )
      {
        v13 = *(v12 - 2);
        --v12;
        v11 = v10;
        if ( v13 == 47 )
          goto LABEL_24;
      }
      v11 = -1;
    }
LABEL_24:
    v1[v11 + 1] = 0;
  }
  v2 = strlen((const char *)v1);
  v3 = v2 - 1;
  v4 = v2 - 1;
  if ( (int)(v2 - 1) > 0 && v1[v2 - 1] == 47 )
  {
    v5 = &v1[v2];
    while ( --v3 )
    {
      v6 = *(v5 - 2);
      --v5;
      v4 = v3;
      if ( v6 != 47 )
        goto LABEL_9;
    }
    v4 = 0;
  }
LABEL_9:
  v1[v4 + 1] = 0;
LABEL_10:
  opt = get_opt_(cmdline_options, "config-dir");
  dst = (unsigned __int8 *)test_confdir(
                             v1,
                             opt->string,
                             "Commandline options -config-dir set to %s, but could not create directory %s.");
  if ( dst
    || (v15 = (unsigned __int8 *)getenv("ELINKS_CONFDIR"),
        (dst = (unsigned __int8 *)test_confdir(v1, v15, "ELINKS_CONFDIR set to %s, but could not create directory %s.")) != 0)
    || (dst = (unsigned __int8 *)test_confdir(v1, (unsigned __int8 *)&path, 0)) != 0
    || (dst = (unsigned __int8 *)test_confdir(v1, "elinks", 0)) != 0 )
  {
    add_to_strn(&dst, "/");
  }
  if ( v1 )
    mem_free(v1);
  elinks_home = (char *)dst;
  if ( !dst )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/home.c";
    errline = 156;
    v14 = gettext(
            "Unable to find or create ELinks config directory. Please check if you have $HOME variable set correctly and "
            "if you have write permission to your home directory.");
    elinks_error(v14);
    sleep(3u);
  }
}

//----- (08072700) --------------------------------------------------------
int __cdecl keybinding_exists(keymap_id keymap_id, term_event_keyboard *kbd, action_id_T *action_id)
{
  list_head_elinks *next; // edx
  list_head_elinks *v4; // eax
  int result; // eax

  next = (list_head_elinks *)keymaps[keymap_id].next;
  v4 = &keymaps[keymap_id];
  if ( next == v4 )
    return 0;
  while ( (void *)kbd->key != next[2].prev || next[3].next != (void *)kbd->modifier )
  {
    next = (list_head_elinks *)next->next;
    if ( next == v4 )
      return 0;
  }
  result = 1;
  if ( action_id )
  {
    *action_id = (action_id_T)next[2].next;
    return 1;
  }
  return result;
}

//----- (08072760) --------------------------------------------------------
action_id_T __cdecl kbd_action(keymap_id keymap_id, term_event *ev, int *event)
{
  list_head_elinks *next; // eax
  list_head_elinks *v5; // edx

  if ( ev->ev != EVENT_KBD )
    return -1;
  next = (list_head_elinks *)keymaps[keymap_id].next;
  v5 = &keymaps[keymap_id];
  if ( next == v5 )
    return -1;
  while ( next[2].prev != (void *)ev->info.mouse.x || next[3].next != (void *)ev->info.mouse.y )
  {
    next = (list_head_elinks *)next->next;
    if ( next == v5 )
      return -1;
  }
  if ( event )
  {
    if ( next[2].next == (void *)1 )
      *event = (int)next[3].prev;
  }
  return (action_id_T)next[2].next;
}

//----- (080727E0) --------------------------------------------------------
keybinding *__cdecl kbd_ev_lookup(keymap_id keymap_id, term_event_keyboard *kbd, int *event)
{
  keybinding *result; // eax
  keybinding *v4; // ecx

  result = (keybinding *)keymaps[keymap_id].next;
  v4 = (keybinding *)&keymaps[keymap_id];
  if ( result == v4 )
    return 0;
  while ( kbd->key != result->kbd.key || result->kbd.modifier != kbd->modifier )
  {
    result = result->next;
    if ( result == v4 )
      return 0;
  }
  if ( event )
  {
    if ( result->action_id == 1 )
      *event = result->event;
  }
  return result;
}

//----- (08072850) --------------------------------------------------------
void __cdecl free_keymaps(module *xxx)
{
  int *v1; // esi
  int *next; // eax
  int *v3; // edx
  int *i; // edx
  int *v5; // ebx
  int *v6; // edi
  keymap_id keymap_id; // [esp+1Ch] [ebp-1Ch]

  v1 = (int *)keymaps;
  done_keybinding_listboxes();
  keymap_id = KEYMAP_MAIN;
  do
  {
    next = (int *)keymaps[keymap_id].next;
    if ( next != v1 )
    {
      v3 = (int *)keymaps[keymap_id].next;
      do
        v3 = (int *)*v3;
      while ( v3 != v1 );
    }
    for ( i = (int *)keymaps[keymap_id].prev; i != v1; i = (int *)i[1] )
      ;
    v5 = (int *)*next;
    if ( next != v1 )
    {
      do
      {
        v6 = v5;
        v5[1] = next[1];
        *(_DWORD *)next[1] = *next;
        mem_free(next);
        v5 = (int *)*v5;
        next = v6;
      }
      while ( v6 != v1 );
    }
    v1 += 2;
    ++keymap_id;
  }
  while ( v1 != &no_autocreate );
}

//----- (080728E0) --------------------------------------------------------
unsigned __int8 *__cdecl get_keymap_name(keymap_id keymap_id)
{
  if ( assert_failed )
    return keymap_table[keymap_id].str;
  assert_failed = (unsigned int)keymap_id > KEYMAP_MENU;
  if ( (unsigned int)keymap_id <= KEYMAP_MENU )
    return keymap_table[keymap_id].str;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
  errline = 298;
  elinks_internal("assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
  return keymap_table[keymap_id].str;
}

//----- (08072950) --------------------------------------------------------
action *__cdecl get_action(keymap_id keymap_id, action_id_T action_id)
{
  if ( assert_failed || (assert_failed = (unsigned int)keymap_id > KEYMAP_MENU, (unsigned int)keymap_id <= KEYMAP_MENU) )
  {
    if ( action_id < 0 )
      return 0;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
    errline = 269;
    elinks_internal("assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
    if ( action_id < 0 )
      return 0;
  }
  if ( action_id >= action_table[keymap_id].num_actions )
    return 0;
  return &action_table[keymap_id].actions[action_id];
}

//----- (080729E0) --------------------------------------------------------
unsigned __int8 *__cdecl get_action_name(keymap_id keymap_id, action_id_T action_id)
{
  action *action; // edx
  unsigned __int8 *result; // eax

  action = get_action(keymap_id, action_id);
  result = 0;
  if ( action )
    return action->str;
  return result;
}

//----- (08072A10) --------------------------------------------------------
action_id_T __cdecl get_action_from_string(keymap_id keymap_id, unsigned __int8 *str)
{
  action *actions; // ebx
  const char *v3; // eax

  if ( !assert_failed )
  {
    assert_failed = (unsigned int)keymap_id > KEYMAP_MENU;
    if ( (unsigned int)keymap_id > KEYMAP_MENU )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
      errline = 257;
      elinks_internal("assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
    }
  }
  actions = action_table[keymap_id].actions;
  v3 = (const char *)actions->str;
  if ( !actions->str )
    return -1;
  while ( strcmp(v3, (const char *)str) )
  {
    ++actions;
    v3 = (const char *)actions->str;
    if ( !actions->str )
      return -1;
  }
  return actions->num;
}

//----- (08072AB0) --------------------------------------------------------
keybinding *__cdecl kbd_nm_lookup(keymap_id keymap_id, unsigned __int8 *name)
{
  action_id_T action_from_string; // edx
  keybinding *result; // eax
  keybinding *v4; // ecx

  action_from_string = get_action_from_string(keymap_id, name);
  if ( action_from_string < 0 )
    return 0;
  result = (keybinding *)keymaps[keymap_id].next;
  v4 = (keybinding *)&keymaps[keymap_id];
  if ( result == v4 )
    return 0;
  while ( action_from_string != result->action_id )
  {
    result = result->next;
    if ( result == v4 )
      return 0;
  }
  return result;
}

//----- (08072B00) --------------------------------------------------------
void __cdecl add_keystroke_to_string(string *str, term_event_keyboard *kbd, int escape)
{
  term_event_modifier_T modifier; // eax
  const unsigned __int8 *v4; // edx
  int key; // ecx
  const named_key *v6; // eax
  char *v7; // eax
  unsigned __int8 key_buffer[3]; // [esp+1Dh] [ebp-Bh] BYREF

  strcpy((char *)key_buffer, "\\x");
  if ( kbd->key != -1 )
  {
    modifier = kbd->modifier;
    if ( (modifier & 1) != 0 )
    {
      add_to_string(str, "Shift-");
      modifier = kbd->modifier;
    }
    if ( (modifier & 2) != 0 )
    {
      add_to_string(str, "Ctrl-");
      modifier = kbd->modifier;
    }
    if ( (modifier & 4) != 0 )
      add_to_string(str, "Alt-");
    v4 = key_table[0].str;
    if ( key_table[0].str )
    {
      key = kbd->key;
      v6 = key_table;
      if ( kbd->key == -256 )
      {
LABEL_16:
        add_to_string(str, v4);
        return;
      }
      while ( 1 )
      {
        ++v6;
        v4 = v6->str;
        if ( !v6->str )
          break;
        if ( v6->num == key )
          goto LABEL_16;
      }
    }
    else
    {
      key = kbd->key;
    }
    v4 = &key_buffer[1];
    key_buffer[1] = key;
    if ( escape )
    {
      v7 = strchr("'\"\\", key);
      v4 = key_buffer;
      if ( !v7 )
        v4 = &key_buffer[1];
    }
    goto LABEL_16;
  }
}

//----- (08072C00) --------------------------------------------------------
void __cdecl bind_config_string(string *file)
{
  keymap_id v1; // edi
  int *v2; // esi
  int *next; // ebx
  unsigned __int8 *action_name; // edi
  int v5; // eax
  const unsigned __int8 *source; // [esp+18h] [ebp-20h]
  keymap_id v7; // [esp+1Ch] [ebp-1Ch]

  v1 = KEYMAP_MAIN;
  v2 = (int *)keymaps;
  do
  {
    next = (int *)keymaps[v1].next;
    if ( next == v2 )
      goto LABEL_12;
    v7 = v1;
    do
    {
      while ( 1 )
      {
        if ( (next[8] & 8) != 0 )
          goto LABEL_4;
        source = get_keymap_name(v7);
        action_name = get_action_name(v7, next[4]);
        if ( !action_name || !source || *action_name == 32 )
          goto LABEL_4;
        v5 = next[8];
        if ( (v5 & 1) != 0 )
          break;
        add_to_string(file, "bind \"");
        add_to_string(file, source);
        add_to_string(file, "\" \"");
        add_keystroke_to_string(file, (term_event_keyboard *)(next + 5), 1);
        add_to_string(file, "\" = \"");
        add_to_string(file, action_name);
        add_char_to_string(file, 0x22u);
        add_char_to_string(file, 0xAu);
LABEL_4:
        next = (int *)*next;
        if ( next == v2 )
          goto LABEL_11;
      }
      next[8] = v5 & 0xFFFFFFFE;
      next = (int *)*next;
    }
    while ( next != v2 );
LABEL_11:
    v1 = v7;
LABEL_12:
    v2 += 2;
    ++v1;
  }
  while ( v2 != &no_autocreate );
}

//----- (08072D40) --------------------------------------------------------
void __cdecl add_keystroke_action_to_string(string *string, action_id_T action_id, keymap_id keymap_id)
{
  list_head_elinks *next; // eax
  list_head_elinks *v4; // edx

  next = (list_head_elinks *)keymaps[keymap_id].next;
  v4 = &keymaps[keymap_id];
  if ( next != v4 )
  {
    while ( (void *)action_id != next[2].next )
    {
      next = (list_head_elinks *)next->next;
      if ( next == v4 )
        return;
    }
    add_keystroke_to_string(string, (term_event_keyboard *)&next[2].prev, 0);
  }
}

//----- (08072DA0) --------------------------------------------------------
unsigned __int8 *__cdecl get_keystroke(action_id_T action_id, keymap_id keymap_id)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  string keystroke; // [esp+18h] [ebp-10h] BYREF

  inited = init_string(&keystroke);
  result = 0;
  if ( inited )
  {
    add_keystroke_action_to_string(&keystroke, action_id, keymap_id);
    if ( !keystroke.length )
      done_string(&keystroke);
    return keystroke.source;
  }
  return result;
}

//----- (08072DF0) --------------------------------------------------------
term_event_key_T __cdecl read_key(const unsigned __int8 *key_str)
{
  term_event_key_T result; // eax
  const unsigned __int8 *str; // eax
  const named_key *v3; // esi

  LOBYTE(result) = *key_str;
  if ( !*key_str || (result = (unsigned __int8)result, key_str[1]) )
  {
    str = key_table[0].str;
    v3 = key_table;
    if ( key_table[0].str )
    {
      while ( c_strcasecmp((const char *)str, (const char *)key_str) )
      {
        ++v3;
        str = v3->str;
        if ( !v3->str )
          return -1;
      }
      return v3->num;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

//----- (08072E60) --------------------------------------------------------
int __cdecl parse_keystroke(const unsigned __int8 *s, term_event_keyboard *kbd)
{
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int key; // eax
  bool v7; // zf

  kbd->modifier = KBD_MOD_NONE;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( !c_strncasecmp((const char *)s, "Shift", 5u) )
      {
        v3 = s[5];
        if ( v3 != 43 && v3 != 45 )
          break;
        kbd->modifier |= 1u;
        s += 6;
      }
      if ( c_strncasecmp((const char *)s, "Ctrl", 4u) )
        break;
      v4 = s[4];
      if ( v4 != 43 && v4 != 45 )
        break;
      kbd->modifier |= 2u;
      s += 5;
    }
    if ( c_strncasecmp((const char *)s, "Alt", 3u) )
      break;
    v5 = s[3];
    if ( v5 != 43 && v5 != 45 )
      break;
    kbd->modifier |= 4u;
    s += 4;
  }
  key = read_key(s);
  v7 = (kbd->modifier & 2) == 0;
  kbd->key = key;
  if ( !v7 && key >= 0 )
  {
    if ( key > 127 )
      return 0;
    key = c_toupper(key);
    kbd->key = key;
  }
  if ( key != -1 )
    return 0;
  return -1;
}

//----- (08072F70) --------------------------------------------------------
unsigned __int8 *__cdecl bind_act(unsigned __int8 *keymap_str, const unsigned __int8 *keystroke_str)
{
  int v2; // esi
  keymap_id i; // ebx
  list_head_elinks *next; // esi
  list_head_elinks *v6; // eax
  unsigned __int8 *action_name; // eax
  term_event_keyboard kbd; // [esp+18h] [ebp-20h] BYREF

  v2 = 0;
  for ( i = KEYMAP_MAIN; strcmp((const char *)keymap_table[i].str, (const char *)keymap_str); ++i )
  {
    if ( ++v2 == 3 )
      return 0;
  }
  if ( parse_keystroke(keystroke_str, &kbd) < 0 )
    return 0;
  next = (list_head_elinks *)keymaps[i].next;
  v6 = &keymaps[i];
  if ( next == v6 )
    return 0;
  while ( (void *)kbd.key != next[2].prev || next[3].next != (void *)kbd.modifier )
  {
    next = (list_head_elinks *)next->next;
    if ( next == v6 )
      return 0;
  }
  action_name = get_action_name(i, (action_id_T)next[2].next);
  if ( !action_name )
    return 0;
  next[4].next = (void *)((int)next[4].next | 1);
  return straconcat("\"", action_name, 135431241, 0);
}

//----- (08073030) --------------------------------------------------------
unsigned __int8 *__cdecl get_action_name_from_keystroke(keymap_id keymap_id, const unsigned __int8 *keystroke_str)
{
  list_head_elinks *next; // eax
  list_head_elinks *v3; // edx
  action *action; // eax
  term_event_keyboard kbd; // [esp+18h] [ebp-10h] BYREF

  if ( parse_keystroke(keystroke_str, &kbd) < 0 )
    return 0;
  next = (list_head_elinks *)keymaps[keymap_id].next;
  v3 = &keymaps[keymap_id];
  if ( next == v3 )
    return 0;
  while ( next[2].prev != (void *)kbd.key || next[3].next != (void *)kbd.modifier )
  {
    next = (list_head_elinks *)next->next;
    if ( next == v3 )
      return 0;
  }
  action = get_action(keymap_id, (action_id_T)next[2].next);
  if ( !action )
    return 0;
  else
    return action->str;
}

//----- (080730B0) --------------------------------------------------------
void __cdecl free_keybinding(keybinding *keybinding)
{
  kbdbind_flags flags; // eax

  if ( keybinding->box_item )
  {
    done_listbox_item(&keybinding_browser, keybinding->box_item);
    keybinding->box_item = 0;
  }
  flags = keybinding->flags;
  if ( (flags & 4) != 0 )
  {
    keybinding->flags = flags & 0xFFFFFFF7;
    keybinding->action_id = 0;
  }
  else
  {
    keybinding->next->prev = keybinding->prev;
    keybinding->prev->next = keybinding->next;
    mem_free(keybinding);
  }
}

//----- (08073120) --------------------------------------------------------
keybinding *__cdecl add_keybinding(keymap_id keymap_id, action_id_T action_id, term_event_keyboard *kbd, int event)
{
  keybinding *next; // eax
  kbdbind_flags flags; // ecx
  int v6; // ebx
  _BOOL4 v7; // edi
  keybinding *v8; // eax
  keybinding *v9; // ebx
  term_event_modifier_T modifier; // edx
  int key; // ecx
  int v13; // eax
  default_kb *v14; // eax
  listbox_item *keybinding_action_box_item; // eax
  list_head_elinks *v16; // [esp+28h] [ebp-40h]
  int v17[9]; // [esp+44h] [ebp-24h] BYREF

  next = (keybinding *)keymaps[keymap_id].next;
  v16 = &keymaps[keymap_id];
  if ( next == (keybinding *)v16 )
  {
LABEL_18:
    v7 = 0;
  }
  else
  {
    while ( next->kbd.key != kbd->key || next->kbd.modifier != kbd->modifier )
    {
      next = next->next;
      if ( next == (keybinding *)v16 )
        goto LABEL_18;
    }
    flags = next->flags;
    v6 = 1;
    if ( (flags & 4) != 0 )
    {
      LOBYTE(v6) = 2;
      next->flags = flags & 0xFFFFFFFB;
    }
    free_keybinding(next);
    v7 = v6 == 2;
  }
  v8 = (keybinding *)mem_calloc(1u, 0x28u);
  v9 = v8;
  if ( !v8 )
    return v9;
  v8->keymap_id = keymap_id;
  v8->action_id = action_id;
  modifier = kbd->modifier;
  v8->kbd.key = kbd->key;
  key = v8->kbd.key;
  v8->kbd.modifier = modifier;
  v8->flags = 4 * v7;
  v8->event = event;
  v13 = v8->kbd.modifier;
  v17[0] = key;
  v17[1] = v13;
  v17[2] = action_id;
  v14 = default_keybindings[v9->keymap_id];
  if ( v14->kbd.key )
  {
    while ( memcmp(v17, v14, 0xCu) )
    {
      ++v14;
      if ( !v14->kbd.key )
        goto LABEL_16;
    }
    v9->flags |= 8u;
  }
LABEL_16:
  v9->next = (keybinding *)keymaps[keymap_id].next;
  v9->prev = (keybinding *)v16;
  keymaps[keymap_id].next = v9;
  v9->next->prev = v9;
  if ( action_id )
  {
    keybinding_action_box_item = get_keybinding_action_box_item(keymap_id, action_id);
    if ( keybinding_action_box_item )
    {
      v9->box_item = add_listbox_item(&keybinding_browser, keybinding_action_box_item, BI_LEAF, v9, 1);
      return v9;
    }
  }
  return 0;
}

//----- (080732B0) --------------------------------------------------------
void __cdecl init_keymaps(module *xxx)
{
  int v1; // edi
  keymap_id v2; // esi
  default_kb *i; // ebx
  action_id_T action_id; // eax
  keybinding *v5; // eax
  term_event_keyboard *p_kbd; // [esp+8h] [ebp-20h]

  v1 = 0;
  v2 = KEYMAP_MAIN;
  keymaps[0].prev = keymaps;
  keymaps[0].next = keymaps;
  keymaps[1].prev = keymaps + 8;
  keymaps[1].next = keymaps + 8;
  keymaps[2].prev = keymaps + 16;
  keymaps[2].next = keymaps + 16;
  init_keybinding_listboxes(keymap_table, action_table);
  do
  {
    for ( i = default_keybindings[v2]; i->kbd.key; v5->flags |= 0xCu )
    {
      p_kbd = &i->kbd;
      action_id = i->action_id;
      ++i;
      v5 = add_keybinding(v2, action_id, p_kbd, -1);
    }
    ++v1;
    ++v2;
  }
  while ( v1 != 3 );
}

//----- (08073360) --------------------------------------------------------
int __cdecl bind_do(
        unsigned __int8 *keymap_str,
        const unsigned __int8 *keystroke_str,
        unsigned __int8 *action_str,
        int is_system_conf)
{
  keymap_id v4; // esi
  int v5; // ebx
  int result; // eax
  int v7; // edx
  action_alias *v8; // ebx
  int action_id; // edx
  keybinding *v10; // eax
  term_event_keyboard kbd; // [esp+18h] [ebp-20h] BYREF

  v4 = KEYMAP_MAIN;
  v5 = 0;
  while ( strcmp((const char *)keymap_table[v4].str, (const char *)keymap_str) )
  {
    ++v5;
    ++v4;
    if ( v5 == 3 )
      return 1;
  }
  v7 = parse_keystroke(keystroke_str, &kbd);
  result = 2;
  if ( v7 >= 0 )
  {
    if ( !assert_failed )
    {
      assert_failed = (unsigned int)v4 > KEYMAP_MENU;
      if ( (unsigned int)v4 > KEYMAP_MENU )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
        errline = 887;
        elinks_internal("assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
      }
    }
    v8 = action_aliases[v4];
    if ( v8 )
    {
      while ( v8->str )
      {
        if ( !strcmp((const char *)v8->str, (const char *)action_str) )
        {
          action_id = v8->action_id;
          goto LABEL_16;
        }
        ++v8;
      }
    }
    action_id = get_action_from_string(v4, action_str);
LABEL_16:
    result = 3;
    if ( action_id >= 0 )
    {
      v10 = add_keybinding(v4, action_id, &kbd, -1);
      if ( v10 )
      {
        if ( is_system_conf )
          v10->flags |= 0xCu;
      }
      return 0;
    }
  }
  return result;
}

//----- (08073490) --------------------------------------------------------
int __cdecl bind_key_to_event_name(
        unsigned __int8 *ckmap,
        const unsigned __int8 *ckey,
        unsigned __int8 *event_name,
        unsigned __int8 **err)
{
  int v4; // esi
  keymap_id v5; // ebx
  unsigned __int8 *v6; // eax
  int action_from_string; // eax
  int event_id; // [esp+1Ch] [ebp-2Ch]
  term_event_keyboard kbd; // [esp+28h] [ebp-20h] BYREF

  event_id = register_event(event_name);
  if ( event_id == -1 )
  {
    *err = gettext("Error registering event");
  }
  else
  {
    v4 = 0;
    v5 = KEYMAP_MAIN;
    while ( strcmp((const char *)keymap_table[v5].str, (const char *)ckmap) )
    {
      ++v4;
      ++v5;
      if ( v4 == 3 )
      {
        v6 = gettext("Unrecognised keymap");
        goto LABEL_6;
      }
    }
    if ( parse_keystroke(ckey, &kbd) < 0 )
    {
      v6 = gettext("Error parsing keystroke");
    }
    else
    {
      action_from_string = get_action_from_string(v5, " *scripting-function*");
      if ( action_from_string >= 0 )
      {
        add_keybinding(v5, action_from_string, &kbd, event_id);
        v6 = 0;
      }
      else
      {
        v6 = gettext("Unrecognised action (internal error)");
      }
    }
LABEL_6:
    *err = v6;
  }
  return event_id;
}

//----- (08073580) --------------------------------------------------------
void __cdecl add_actions_to_string(string *string, action_id_T *action_ids, keymap_id keymap_id, terminal *term)
{
  unsigned __int8 *desc; // ebx
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  action_id_T v7; // eax
  list_head_elinks *next; // ebx
  unsigned __int8 *str; // esi
  action *action; // eax
  int v11; // eax
  int v12; // eax
  int v13; // ebx
  unsigned __int8 *v14; // eax
  int v15; // [esp+10h] [ebp-28h]
  int keystrokelen; // [esp+14h] [ebp-24h]
  list_head_elinks *v17; // [esp+18h] [ebp-20h]
  action_id_T *v18; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    assert_failed = (unsigned int)keymap_id > KEYMAP_MENU;
    if ( (unsigned int)keymap_id > KEYMAP_MENU )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/kbdbind.c";
      errline = 502;
      elinks_internal("assertion keymap_id >= 0 && keymap_id < KEYMAP_MAX failed!");
    }
  }
  desc = keymap_table[keymap_id].desc;
  if ( desc && *desc )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        v15 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v15;
      }
    }
    desc = gettext(desc);
  }
  add_format_to_string(string, (const unsigned __int8 *)"%s:\n", (const char *)desc);
  v7 = *action_ids;
  if ( *action_ids )
  {
    v18 = action_ids;
    v17 = &keymaps[keymap_id];
    do
    {
      next = (list_head_elinks *)keymaps[keymap_id].next;
      if ( next != v17 )
      {
        if ( (void *)v7 == next[2].next )
          goto LABEL_16;
        while ( 1 )
        {
          next = (list_head_elinks *)next->next;
          if ( next == v17 )
            break;
          if ( (void *)v7 == next[2].next )
            goto LABEL_16;
        }
      }
      next = 0;
LABEL_16:
      str = 0;
      keystrokelen = string->length;
      action = get_action(keymap_id, v7);
      if ( action )
      {
        str = action->desc;
        if ( !str )
          str = action->str;
      }
      if ( next )
      {
        add_char_to_string(string, 0xAu);
        add_keystroke_to_string(string, (term_event_keyboard *)&next[2].prev, 0);
        v11 = 1;
        if ( keystrokelen - string->length + 15 > 0 )
          v11 = keystrokelen - string->length + 15;
        add_xchar_to_string(string, 0x20u, v11);
        if ( str && *str )
        {
          if ( term )
          {
            v12 = get_terminal_codepage(term);
            v13 = v12;
            if ( v12 != current_charset )
            {
              v14 = get_cp_mime_name(v12);
              bind_textdomain_codeset("elinks", v14);
              current_charset = v13;
            }
          }
          str = gettext(str);
        }
        add_to_string(string, str);
      }
      v7 = v18[1];
      ++v18;
    }
    while ( v7 );
  }
}

//----- (080737A0) --------------------------------------------------------
void __cdecl prepare_mustsave_flags(list_head_elinks *tree, int set_all)
{
  list_head_elinks *next; // ebx
  unsigned int v3; // eax
  bool v4; // zf

  next = (list_head_elinks *)tree->next;
  if ( tree->next != tree )
  {
    while ( !set_all )
    {
      v3 = (unsigned int)next[2].next;
      if ( (v3 & 0x88) != 0 || next[2].prev == (void *)5 )
      {
LABEL_4:
        v4 = next[2].prev == (void *)9;
        next[2].next = (void *)(v3 | 4);
        if ( !v4 )
          goto LABEL_5;
LABEL_10:
        prepare_mustsave_flags((list_head_elinks *)next[4].next, set_all);
        next = (list_head_elinks *)next->next;
        if ( next == tree )
          return;
      }
      else
      {
        v4 = next[2].prev == (void *)9;
        next[2].next = (void *)(v3 & 0xFFFFFFFB);
        if ( v4 )
          goto LABEL_10;
LABEL_5:
        next = (list_head_elinks *)next->next;
        if ( next == tree )
          return;
      }
    }
    v3 = (unsigned int)next[2].next;
    goto LABEL_4;
  }
}

//----- (08073810) --------------------------------------------------------
void __cdecl untouch_options(list_head_elinks *tree)
{
  list_head_elinks *i; // ebx

  for ( i = (list_head_elinks *)tree->next; i != tree; i = (list_head_elinks *)i->next )
  {
    while ( 1 )
    {
      i[2].next = (void *)((int)i[2].next & ~8u);
      if ( i[2].prev == (void *)9 )
        break;
      i = (list_head_elinks *)i->next;
      if ( i == tree )
        return;
    }
    untouch_options((list_head_elinks *)i[4].next);
  }
}

//----- (08073860) --------------------------------------------------------
int __usercall check_nonempty_tree@<eax>(list_head_elinks *options@<eax>)
{
  list_head_elinks **i; // ebx

  for ( i = (list_head_elinks **)options->next; i != (list_head_elinks **)options; i = (list_head_elinks **)*i )
  {
    if ( i[5] == (list_head_elinks *)9 )
    {
      if ( check_nonempty_tree(i[8]) )
        return 1;
    }
    else if ( ((_BYTE)i[4] & 4) != 0 )
    {
      return 1;
    }
  }
  return 0;
}

//----- (080738B0) --------------------------------------------------------
int __cdecl change_hook_html(session *ses, option_elinks *current, option_elinks *changed)
{
  list_head_elinks *i; // eax

  for ( i = (list_head_elinks *)sessions.next; i != &sessions; i = (list_head_elinks *)i->next )
    *((_BYTE *)i[1].next + 40) |= 1u;
  return 0;
}

//----- (080738E0) --------------------------------------------------------
void __cdecl call_change_hooks(session *ses, option_elinks *current, option_elinks *option_elinks)
{
  option_elinks *i; // ebx
  int (__cdecl *change_hook)(session *, option_elinks *, option_elinks *); // eax

  for ( i = current; i; i = i->root )
  {
    change_hook = i->change_hook;
    if ( change_hook && change_hook(ses, i, option_elinks) )
      break;
  }
}

//----- (08073920) --------------------------------------------------------
void __cdecl option_changed(session *ses, option_elinks *option_elinks)
{
  option_elinks->flags |= 8u;
  call_change_hooks(ses, option_elinks, option_elinks);
}

//----- (08073950) --------------------------------------------------------
void __usercall delete_option_do(option_elinks *option_elinks@<eax>, int recursive@<edx>)
{
  int v2; // edi
  option_elinks *next; // eax
  option_type type; // eax
  list_head_elinks *tree; // esi
  option_elinks *v7; // eax

  v2 = recursive;
  next = option_elinks->next;
  if ( next )
  {
    next->prev = option_elinks->prev;
    option_elinks->prev->next = option_elinks->next;
    option_elinks->next = 0;
    option_elinks->prev = 0;
  }
  if ( recursive == -1 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 596;
    elinks_error("Orphaned option %s", (const char *)option_elinks->name);
  }
  type = option_elinks->type;
  if ( type == OPT_TREE )
  {
    tree = option_elinks->value.tree;
    if ( !tree || (v7 = (option_elinks *)tree->next, tree == tree->next) )
    {
LABEL_26:
      if ( tree )
        mem_free(tree);
      goto LABEL_8;
    }
    if ( v2
      || (LOWORD(v2) = 1, (option_elinks->flags & 2) != 0)
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c",
          v2 = -1,
          errline = 605,
          elinks_error("Orphaned unregistered option in subtree %s!", (const char *)option_elinks->name),
          tree = option_elinks->value.tree,
          v7 = (option_elinks *)tree->next,
          tree != tree->next) )
    {
      do
      {
        delete_option_do(v7, v2);
        v7 = (option_elinks *)tree->next;
      }
      while ( tree->next != tree );
    }
    type = option_elinks->type;
    if ( type != OPT_STRING )
    {
LABEL_7:
      if ( type != OPT_TREE )
        goto LABEL_8;
      tree = option_elinks->value.tree;
      goto LABEL_26;
    }
  }
  else if ( type != OPT_STRING )
  {
    goto LABEL_7;
  }
  if ( option_elinks->value.number )
    mem_free(option_elinks->value.tree);
LABEL_8:
  if ( option_elinks->box_item )
    done_listbox_item(&option_browser, option_elinks->box_item);
  if ( (option_elinks->flags & 0x20) != 0 )
  {
    if ( option_elinks->name )
      mem_free(option_elinks->name);
    mem_free(option_elinks);
  }
  else if ( !option_elinks->capt )
  {
    memset(option_elinks, 0, sizeof(option_elinks));
  }
}

//----- (08073AE0) --------------------------------------------------------
void __cdecl unregister_options(option_info *info, option_elinks *tree)
{
  option_info *v2; // eax
  int i; // ebx
  unsigned __int8 *path; // edx
  option_info *v5; // esi
  option_elinks *p_option_elinks; // eax

  if ( info->path )
  {
    v2 = info;
    for ( i = 0; ; ++i )
    {
      path = v2[1].path;
      ++v2;
      if ( !path )
        break;
    }
    if ( i != -1 )
    {
      v5 = &info[i];
      do
      {
        p_option_elinks = &v5->option_elinks;
        --i;
        --v5;
        delete_option_do(p_option_elinks, 0);
      }
      while ( i != -1 );
    }
  }
}

//----- (08073B30) --------------------------------------------------------
void done_options()
{
  option_elinks *i; // eax

  unregister_options(config_options_info, config_options);
  unregister_options(cmdline_options_info, cmdline_options);
  config_options->box_item = 0;
  for ( i = (option_elinks *)options_root_tree.next;
        options_root_tree.next != &options_root_tree;
        i = (option_elinks *)options_root_tree.next )
  {
    delete_option_do(i, 0);
  }
}

//----- (08073B90) --------------------------------------------------------
void __cdecl delete_option(option_elinks *option_elinks)
{
  delete_option_do(option_elinks, 1);
}

//----- (08073BB0) --------------------------------------------------------
list_head_elinks *init_options_tree()
{
  list_head_elinks *result; // eax

  result = (list_head_elinks *)mem_alloc(8u);
  if ( result )
  {
    result->prev = result;
    result->next = result;
  }
  return result;
}

//----- (08073BD0) --------------------------------------------------------
void __cdecl toggle_option(session *ses, option_elinks *option_elinks)
{
  int min; // esi
  bool v3; // zf
  int max; // ecx

  min = option_elinks->value.number + 1;
  if ( !assert_failed )
  {
    v3 = option_elinks->type <= (unsigned int)OPT_INT;
    assert_failed = option_elinks->type > (unsigned int)OPT_INT;
    if ( v3
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c",
          errline = 988,
          elinks_internal("assertion option->type == OPT_BOOL || option->type == OPT_INT failed!"),
          !assert_failed) )
    {
      max = option_elinks->max;
      assert_failed = max == 0;
      if ( !max )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 989;
        elinks_internal("assertion option->max failed!");
      }
    }
  }
  if ( min > option_elinks->max )
    min = option_elinks->min;
  option_elinks->value.number = min;
  option_changed(ses, option_elinks);
}

//----- (08073CA0) --------------------------------------------------------
void __cdecl mark_option_as_deleted(option_elinks *option_elinks)
{
  option_value v1; // edx
  option_elinks **tree; // eax
  option_elinks *v3; // ebx

  if ( option_elinks->type == OPT_TREE )
  {
    if ( !assert_failed )
    {
      v1.tree = (list_head_elinks *)option_elinks->value;
      assert_failed = v1.number == 0;
      if ( !v1.number )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 623;
        elinks_internal("assertion option->value.tree failed!");
      }
    }
    tree = (option_elinks **)option_elinks->value.tree;
    v3 = *tree;
    if ( *tree != (option_elinks *)tree )
    {
      do
      {
        mark_option_as_deleted(v3);
        v3 = v3->next;
      }
      while ( (option_elinks *)option_elinks->value.tree != v3 );
    }
  }
  *((_BYTE *)option_elinks->box_item + 24) &= ~2u;
  option_elinks->flags |= 0x88u;
}

//----- (08073D30) --------------------------------------------------------
void __usercall update_visibility(list_head_elinks *tree@<eax>, int show@<edx>)
{
  list_head_elinks *next; // ebx
  _BYTE *prev; // edx
  _BYTE *v4; // eax
  int v5; // [esp+Ch] [ebp-2Ch]
  int v6; // [esp+10h] [ebp-28h]
  char v8; // [esp+1Bh] [ebp-1Dh]

  next = (list_head_elinks *)tree->next;
  if ( tree->next != tree )
  {
    v6 = show & 2;
    v8 = 2 * (show & 1);
    v5 = show | 2;
    while ( 1 )
    {
      if ( SLOBYTE(next[2].next) < 0 )
        goto LABEL_7;
      if ( !strcmp((const char *)next[1].prev, "_template_") )
      {
        prev = next[6].prev;
        if ( prev )
          prev[24] = v8 | prev[24] & 0xFD;
        if ( next[2].prev == (void *)9 )
          update_visibility((list_head_elinks *)next[4].next, v5);
        goto LABEL_7;
      }
      v4 = next[6].prev;
      if ( v4 )
      {
        if ( v6 )
          v4[24] = v8 | v4[24] & 0xFD;
      }
      if ( next[2].prev == (void *)9 )
      {
        update_visibility((list_head_elinks *)next[4].next, show);
        next = (list_head_elinks *)next->next;
        if ( next == tree )
          return;
      }
      else
      {
LABEL_7:
        next = (list_head_elinks *)next->next;
        if ( next == tree )
          return;
      }
    }
  }
}

//----- (08073DF0) --------------------------------------------------------
int __cdecl change_hook_stemplate(session *ses, option_elinks *current, option_elinks *changed)
{
  update_visibility(config_options->value.tree, changed->value.number);
  return 0;
}

//----- (08073E10) --------------------------------------------------------
void __cdecl smart_config_string(
        string *str,
        int print_comment,
        int i18n,
        list_head_elinks *options,
        unsigned __int8 *path,
        int depth,
        void (*fn)(string *, option_elinks *, unsigned __int8 *, int, int, int, int))
{
  option_elinks *next; // ebx
  option_flags flags; // eax
  option_type type; // edx
  int v11; // esi
  int v12; // eax
  int v13; // esi
  string newpath; // [esp+48h] [ebp-20h] BYREF

  next = (option_elinks *)options->next;
  if ( options->next != options )
  {
    while ( 1 )
    {
      flags = next->flags;
      if ( (flags & 1) == 0
        && next->type != OPT_ALIAS
        && strcmp((const char *)next->name, "_template_")
        && !(next->type == OPT_TREE ? check_nonempty_tree(next->value.tree) == 0 : ((unsigned __int8)((unsigned int)flags >> 2) ^ 1) & 1) )
      {
        break;
      }
LABEL_14:
      next = next->next;
      if ( next == (option_elinks *)options )
        return;
    }
    if ( print_comment )
    {
      if ( print_comment == 1 && strcmp((const char *)next->name, "_template_") && (next->flags & 2) != 0 )
      {
        v11 = 1;
        if ( next->type == OPT_TREE )
        {
          v12 = 1;
          LOWORD(v11) = 0;
LABEL_12:
          fn(str, next, path, depth, v12, 0, i18n);
          fn(str, next, path, depth, v11, 1, i18n);
          if ( option_types[next->type].write )
          {
            fn(str, next, path, depth, v11, 2, i18n);
          }
          else if ( next->type == OPT_TREE && init_string(&newpath) )
          {
            if ( print_comment == 2 )
            {
              v13 = 2 - ((next->flags & 2) != 0);
            }
            else
            {
              v13 = print_comment;
              if ( print_comment == 1 )
                v13 = strcmp((const char *)next->name, "_template_") == 0;
            }
            fn(str, next, path, depth, 1, 3, i18n);
            if ( path )
            {
              add_to_string(&newpath, path);
              add_char_to_string(&newpath, 0x2Eu);
            }
            add_to_string(&newpath, next->name);
            smart_config_string(str, v13, i18n, next->value.tree, newpath.source, depth + 1, fn);
            done_string(&newpath);
            fn(str, next, path, depth, 1, 3, i18n);
          }
          goto LABEL_14;
        }
LABEL_11:
        v12 = v11;
        goto LABEL_12;
      }
      type = next->type;
      v11 = 1;
    }
    else
    {
      type = next->type;
      v11 = 0;
    }
    v12 = print_comment;
    if ( type == OPT_TREE )
      goto LABEL_12;
    goto LABEL_11;
  }
}

//----- (080740E0) --------------------------------------------------------
int __cdecl change_hook_ui(session *ses, option_elinks *current, option_elinks *changed)
{
  update_status();
  return 0;
}

//----- (080740F0) --------------------------------------------------------
int __cdecl change_hook_insert_mode(session *ses, option_elinks *current, option_elinks *changed)
{
  update_status();
  return 0;
}

//----- (08074100) --------------------------------------------------------
int __cdecl change_hook_language(session *ses, option_elinks *current, option_elinks *changed)
{
  set_language(changed->value.number);
  return 0;
}

//----- (08074120) --------------------------------------------------------
int __cdecl change_hook_terminal(session *ses, option_elinks *current, option_elinks *changed)
{
  cls_redraw_all_terminals();
  return 0;
}

//----- (08074130) --------------------------------------------------------
int __cdecl change_hook_cache(session *ses, option_elinks *current, option_elinks *changed)
{
  shrink_memory(0);
  return 0;
}

//----- (08074150) --------------------------------------------------------
int __cdecl change_hook_active_link(session *ses, option_elinks *current, option_elinks *changed)
{
  update_cached_document_options();
  return 0;
}

//----- (08074160) --------------------------------------------------------
int __cdecl change_hook_connection(session *ses, option_elinks *current, option_elinks *changed)
{
  register_check_queue();
  return 0;
}

//----- (08074170) --------------------------------------------------------
option_elinks *__cdecl copy_option(option_elinks *templatea)
{
  option_elinks *v1; // ebx
  unsigned __int8 *v2; // eax
  listbox_item *v3; // eax
  listbox_item *box_item; // edx
  void (*dup)(option_elinks *, option_elinks *); // eax

  v1 = (option_elinks *)mem_calloc(1u, 0x38u);
  if ( !v1 )
    return v1;
  v2 = 0;
  if ( templatea->name )
    v2 = stracpy(templatea->name);
  v1->name = v2;
  v1->flags = templatea->flags | 0x20;
  v1->type = templatea->type;
  v1->min = templatea->min;
  v1->max = templatea->max;
  v1->capt = templatea->capt;
  v1->desc = templatea->desc;
  v1->change_hook = templatea->change_hook;
  v3 = (listbox_item *)mem_calloc(1u, 0x20u);
  if ( v3 )
  {
    *((_BYTE *)v3 + 24) |= 2u;
    v3->child.prev = &v3->child;
    v3->child.next = &v3->child;
    v3->udata = v1;
    v3->type = v1->type == OPT_TREE;
    v1->box_item = v3;
    box_item = templatea->box_item;
    if ( box_item )
    {
      v3->type = box_item->type;
      v1->box_item->depth = templatea->box_item->depth;
    }
  }
  else
  {
    v1->box_item = 0;
  }
  dup = option_types[templatea->type].dup;
  if ( dup )
  {
    dup(v1, templatea);
    return v1;
  }
  v1->value.number = templatea->value.number;
  return v1;
}

//----- (08074270) --------------------------------------------------------
option_elinks *__cdecl get_opt_rec(option_elinks *tree, const unsigned __int8 *name_)
{
  option_elinks *v2; // ebx
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // esi
  char *v5; // eax
  option_elinks *opt_rec; // eax
  option_elinks **v7; // edi
  option_elinks *v8; // ebx
  const char *v9; // eax
  option_elinks *v10; // eax
  option_elinks *v11; // eax
  unsigned __int8 *name; // eax
  unsigned __int8 *src; // [esp+18h] [ebp-20h]
  char *v15; // [esp+1Ch] [ebp-1Ch]

  v2 = 0;
  v3 = stracpy(name_);
  v4 = v3;
  if ( !v3 )
    return v2;
  v5 = strrchr((const char *)v3, 46);
  src = v4;
  v15 = v5;
  if ( v5 )
  {
    *v5 = 0;
    opt_rec = get_opt_rec(tree, v4);
    tree = opt_rec;
    if ( !opt_rec || opt_rec->type != OPT_TREE || (opt_rec->flags & 1) != 0 )
      goto LABEL_21;
    *v15 = 46;
    src = (unsigned __int8 *)(v15 + 1);
  }
  v7 = (option_elinks **)tree->value.tree;
  v8 = *v7;
  if ( *v7 == (option_elinks *)v7 )
  {
LABEL_11:
    if ( (tree->flags & 2) != 0 && !no_autocreate )
    {
      v10 = get_opt_rec(tree, "_template_");
      if ( assert_failed
        || (assert_failed = v10 == 0, !v10)
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c",
            errline = 209,
            elinks_internal(
              "assertion template != NULL failed: Requested %s should be autocreated but %.*s._template_ is missing!",
              (const char *)name_,
              v15 - (char *)name_,
              (const char *)name_),
            v10 = 0,
            assert_failed) )
      {
        assert_failed = 0;
        mem_free(v4);
        return 0;
      }
      v11 = copy_option(v10);
      v2 = v11;
      if ( v11 )
      {
        name = v11->name;
        if ( name )
          mem_free(name);
        v2->name = stracpy(src);
        add_opt_rec(tree, (unsigned __int8 *)&delete, v2);
      }
      mem_free(v4);
      return v2;
    }
LABEL_21:
    mem_free(v4);
    return 0;
  }
  while ( 1 )
  {
    v9 = (const char *)v8->name;
    if ( v9 )
    {
      if ( !strcmp(v9, (const char *)src) )
        break;
    }
    v8 = v8->next;
    if ( v8 == (option_elinks *)v7 )
      goto LABEL_11;
  }
  mem_free(v4);
  return v8;
}

//----- (08074460) --------------------------------------------------------
void __cdecl checkout_option_values(option_resolver *resolvers, option_elinks *root, option_value *values, int size)
{
  int i; // ebx
  option_elinks *opt_rec; // eax
  int id; // edx

  if ( size > 0 )
  {
    for ( i = 0; i < size; ++i )
    {
      opt_rec = get_opt_rec(root, resolvers[i].name);
      id = resolvers[i].id;
      values[id] = opt_rec->value;
    }
  }
}

//----- (080744B0) --------------------------------------------------------
int __cdecl commit_option_values(option_resolver *resolvers, option_elinks *root, option_value *values, int size)
{
  option_resolver *v4; // edx
  int v5; // ebx
  option_elinks *opt_rec; // eax
  option_value v7; // ecx
  void (__cdecl *change_hook)(_DWORD, _DWORD, _DWORD); // ecx
  option_resolver *v10; // [esp+1Ch] [ebp-2Ch]
  int touched; // [esp+28h] [ebp-20h]

  v4 = resolvers;
  if ( !assert_failed )
  {
    if ( root && resolvers && size && values )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 1061;
      elinks_internal("assertion resolvers && root && values && size failed!");
      v4 = resolvers;
    }
  }
  v5 = 0;
  touched = 0;
  if ( size > 0 )
  {
    v10 = v4;
    do
    {
      opt_rec = get_opt_rec(root, v10[v5].name);
      if ( memcmp(&opt_rec->value, &values[v10[v5].id], 4u) )
      {
        v7.tree = (list_head_elinks *)values[v10[v5].id];
        opt_rec->flags |= 8u;
        opt_rec->value = v7;
        change_hook = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))opt_rec->change_hook;
        if ( change_hook )
          change_hook(0, opt_rec, 0);
        ++touched;
      }
      ++v5;
    }
    while ( size > v5 );
  }
  call_change_hooks(0, root, 0);
  return touched;
}

//----- (080745E0) --------------------------------------------------------
void __cdecl register_change_hooks(const change_hook_info *change_hooks)
{
  const change_hook_info *v1; // esi
  unsigned __int8 *name; // eax
  const change_hook_info *v3; // ebx
  int (*change_hook)(session *, option_elinks *, option_elinks *); // edx
  option_elinks *opt_rec; // eax

  v1 = change_hooks;
  name = change_hooks->name;
  if ( change_hooks->name )
  {
    v3 = change_hooks + 1;
    do
    {
      opt_rec = get_opt_rec(config_options, name);
      if ( !assert_failed )
      {
        assert_failed = opt_rec == 0;
        if ( !opt_rec )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
          errline = 755;
          elinks_internal("assertion option failed!");
          opt_rec = 0;
        }
      }
      change_hook = v1->change_hook;
      v1 = v3;
      opt_rec->change_hook = change_hook;
      name = v3->name;
      ++v3;
    }
    while ( name );
  }
}

//----- (08074670) --------------------------------------------------------
option_value *__cdecl get_opt_(option_elinks *tree, unsigned __int8 *name)
{
  return &get_opt_rec(tree, name)->value;
}

//----- (08074690) --------------------------------------------------------
void __usercall add_opt_rec(option_elinks *tree@<eax>, unsigned __int8 *path@<edx>, option_elinks *option_elinks@<ecx>)
{
  unsigned __int8 *name; // esi
  option_elinks *v5; // ecx
  listbox_item *v6; // eax
  listbox_item *v7; // ecx
  int v8; // edx
  option_elinks *v9; // eax
  _DWORD *prev; // eax
  option_elinks *v11; // eax
  option_elinks *opt_rec; // eax
  option_elinks *v13; // ecx
  listbox_item *v14; // esi
  option_type type; // ecx
  option_elinks *v16; // edi
  int v17; // eax
  option_type v18; // edi
  option_elinks *v19; // ecx
  listbox_item *v20; // eax
  unsigned __int8 *v21; // esi
  int v22; // eax
  option_type v23; // eax
  int v24; // ecx
  option_elinks *v25; // eax
  option_type v26; // [esp+14h] [ebp-34h]
  option_elinks *v27; // [esp+14h] [ebp-34h]
  option_elinks *v28; // [esp+14h] [ebp-34h]
  unsigned __int8 *v29; // [esp+18h] [ebp-30h]
  unsigned __int8 *v30; // [esp+18h] [ebp-30h]
  int v31; // [esp+18h] [ebp-30h]
  int v32; // [esp+18h] [ebp-30h]
  listbox_item *box_item; // [esp+18h] [ebp-30h]
  int v34; // [esp+18h] [ebp-30h]
  const char *v35; // [esp+1Ch] [ebp-2Ch]
  listbox_item *p_child; // [esp+20h] [ebp-28h]
  listbox_item *v37; // [esp+24h] [ebp-24h]
  option_elinks *v38; // [esp+28h] [ebp-20h]
  option_elinks *v39; // [esp+2Ch] [ebp-1Ch]
  option_elinks *next; // [esp+2Ch] [ebp-1Ch]

  v39 = tree;
  if ( !assert_failed )
  {
    if ( option_elinks && path && tree )
    {
      assert_failed = 0;
      if ( *path )
        goto LABEL_31;
      goto LABEL_5;
    }
    v29 = path;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
    errline = 419;
    elinks_internal("assertion path && option && tree failed!");
    path = v29;
  }
  if ( *path )
  {
LABEL_31:
    v30 = path;
    opt_rec = get_opt_rec(v39, path);
    path = v30;
    v39 = opt_rec;
  }
LABEL_5:
  if ( !assert_failed )
  {
    assert_failed = v39 == 0;
    if ( !v39 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
      errline = 422;
      elinks_internal("assertion tree != NULL failed: Missing option tree for '%s'", (const char *)path);
    }
  }
  if ( !v39->value.number )
    return;
  if ( option_elinks->box_item && (name = option_elinks->name) != 0 && !strcmp((const char *)name, "_template_") )
  {
    box_item = option_elinks->box_item;
    *((_BYTE *)box_item + 24) = (2 * ((int)get_opt_rec(config_options, "config.show_template")->value.tree & 1)) | *((_BYTE *)box_item + 24) & 0xFD;
    v5 = v39;
    if ( (v39->flags & 2) == 0 )
      goto LABEL_13;
  }
  else
  {
    v5 = v39;
    if ( (v39->flags & 2) == 0 )
      goto LABEL_13;
  }
  if ( !option_elinks->desc )
  {
    v11 = get_opt_rec(v5, "_template_");
    if ( !assert_failed )
    {
      assert_failed = v11 == 0;
      if ( !v11 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 433;
        elinks_internal("assertion template failed!");
        v11 = 0;
      }
    }
    option_elinks->desc = v11->desc;
  }
LABEL_13:
  option_elinks->root = v39;
  v6 = v39->box_item;
  if ( v6 && (v7 = option_elinks->box_item) != 0 )
  {
    v8 = 1;
    if ( v6->next )
      v7->depth = v6->depth + 1;
    v9 = v39;
    if ( (v39->flags & 0x40) == 0 )
      goto LABEL_18;
  }
  else
  {
    v9 = v39;
    v8 = 0;
    if ( (v39->flags & 0x40) == 0 )
    {
LABEL_18:
      option_elinks->next = **(option_elinks ***)(v39->value.number + 4);
      option_elinks->prev = *(option_elinks **)(v39->value.number + 4);
      **(_DWORD **)(v39->value.number + 4) = option_elinks;
      option_elinks->next->prev = option_elinks;
      if ( !v8 )
        goto LABEL_21;
      option_elinks->box_item->next = *(listbox_item **)v39->box_item->child.prev;
      option_elinks->box_item->prev = (listbox_item *)v39->box_item->child.prev;
      prev = v39->box_item->child.prev;
      goto LABEL_20;
    }
  }
  v13 = (option_elinks *)v9->value.tree;
  v38 = v13;
  v14 = v9->box_item;
  p_child = (listbox_item *)&v14->child;
  next = v13->next;
  if ( v13 == v13->next )
  {
    option_elinks->next = v13;
    option_elinks->prev = v13;
    v13->next = option_elinks;
    option_elinks->next->prev = option_elinks;
    if ( v8 )
    {
      option_elinks->box_item->next = (listbox_item *)v14->child.next;
      option_elinks->box_item->prev = (listbox_item *)&v14->child;
      v14->child.next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    goto LABEL_21;
  }
  type = option_elinks->type;
  if ( type != OPT_TREE )
  {
    v16 = v38->prev;
LABEL_36:
    v31 = v8;
    v26 = option_elinks->type;
    v17 = strcmp((const char *)v16->name, (const char *)option_elinks->name);
    v8 = v31;
    type = v26;
    if ( v17 <= 0 || v26 != OPT_TREE && v16->type == OPT_TREE )
    {
      option_elinks->next = v16->next;
      option_elinks->prev = v38->prev;
      v38->prev->next = option_elinks;
      option_elinks->next->prev = option_elinks;
      if ( !v31 )
        goto LABEL_21;
      option_elinks->box_item->next = *(listbox_item **)v14->child.prev;
      option_elinks->box_item->prev = (listbox_item *)v14->child.prev;
      prev = v14->child.prev;
LABEL_20:
      *prev = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
      goto LABEL_21;
    }
    goto LABEL_39;
  }
  v16 = v38->prev;
  if ( v16->type == OPT_TREE )
    goto LABEL_36;
LABEL_39:
  v37 = (listbox_item *)&v14->child;
  if ( next == v38 )
    goto LABEL_53;
  v18 = type;
  v19 = next;
  while ( 1 )
  {
    if ( SLOBYTE(v19->flags) >= 0 )
    {
      if ( v19->box_item )
      {
        v20 = v37->next;
        v37 = v37->next;
        if ( !assert_failed )
        {
          assert_failed = p_child == v20;
          if ( p_child == v20 )
          {
            v34 = v8;
            v28 = v19;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
            errline = 373;
            elinks_internal("assertion bpos != (struct listbox_item *) bcat failed!");
            v18 = option_elinks->type;
            v19 = v28;
            v8 = v34;
          }
          else
          {
            v18 = option_elinks->type;
          }
        }
      }
    }
    if ( v18 == OPT_TREE && v19->type != OPT_TREE )
    {
      next = v19;
      goto LABEL_50;
    }
    v21 = option_elinks->name;
    v32 = v8;
    v27 = v19;
    v35 = (const char *)v19->name;
    v22 = strcmp(v35, (const char *)v21);
    v8 = v32;
    if ( v22 > 0 )
    {
      if ( v18 == OPT_TREE )
      {
        next = v27;
        v24 = 9;
        v23 = v27->type;
        goto LABEL_49;
      }
      v23 = v27->type;
      if ( v23 != OPT_TREE )
        break;
    }
    v19 = v27->next;
    if ( v27->next == v38 )
    {
      next = v27->next;
      goto LABEL_53;
    }
  }
  next = v27;
  v24 = v18;
LABEL_49:
  if ( v24 != v23 || *v21 > 0x5Fu || strcmp(v35, "_template_") )
  {
LABEL_50:
    if ( v8 )
    {
      option_elinks->box_item->next = v37->prev->next;
      option_elinks->box_item->prev = v37->prev;
      v37->prev->next = option_elinks->box_item;
      option_elinks->box_item->next->prev = option_elinks->box_item;
    }
    option_elinks->next = next->prev->next;
    option_elinks->prev = next->prev;
    next->prev->next = option_elinks;
    option_elinks->next->prev = option_elinks;
    goto LABEL_53;
  }
  if ( v32 )
  {
    option_elinks->box_item->next = v37->next;
    option_elinks->box_item->prev = v37;
    v37->next = option_elinks->box_item;
    option_elinks->box_item->next->prev = option_elinks->box_item;
  }
  v25 = next->next;
  option_elinks->prev = next;
  option_elinks->next = v25;
  next->next = option_elinks;
  option_elinks->next->prev = option_elinks;
LABEL_53:
  if ( !assert_failed )
  {
    assert_failed = next == v38;
    if ( next != v38
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c",
          errline = 408,
          elinks_internal("assertion pos != (struct option *) cat failed!"),
          !assert_failed) )
    {
      assert_failed = p_child == v37;
      if ( p_child == v37 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
        errline = 409;
        elinks_internal("assertion bpos != (struct listbox_item *) bcat failed!");
      }
    }
  }
LABEL_21:
  update_hierbox_browser(&option_browser);
}

//----- (08074C80) --------------------------------------------------------
void __cdecl register_options(option_info *info, option_elinks *tree)
{
  option_info *v2; // edi
  option_info *v3; // ebx
  unsigned __int8 *path; // eax
  unsigned int type; // eax
  listbox_item *v6; // eax
  list_head_elinks *inited; // eax
  unsigned __int8 *v8; // eax
  const char *v9; // edx
  int v10; // eax
  const unsigned __int8 *string; // eax
  unsigned __int8 *v12; // edx
  option_elinks *p_option_elinks; // [esp+0h] [ebp-38h]
  unsigned __int8 *str; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *stra; // [esp+1Ch] [ebp-1Ch]

  v2 = info;
  if ( info->path )
  {
    v3 = info + 1;
    do
    {
      while ( 1 )
      {
        type = v2->option_elinks.type;
        if ( type != 8 )
        {
          if ( (tree->flags & 0x10) != 0 || (v2->option_elinks.flags & 0x10) != 0 )
          {
            v6 = (listbox_item *)mem_calloc(1u, 0x20u);
            if ( !v6 )
            {
              v2->option_elinks.box_item = 0;
              delete_option(&v2->option_elinks);
              goto LABEL_5;
            }
            *((_BYTE *)v6 + 24) |= 2u;
            v6->child.prev = &v6->child;
            v6->child.next = &v6->child;
            v6->udata = v2;
            v6->type = v2->option_elinks.type == OPT_TREE;
            v2->option_elinks.box_item = v6;
            type = v2->option_elinks.type;
          }
          if ( type == 4 )
          {
            string = v2->option_elinks.value.string;
            if ( !assert_failed )
            {
              assert_failed = string == 0;
              if ( !string )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
                errline = 1158;
                elinks_internal("assertion string failed!");
                string = 0;
              }
            }
            v2->option_elinks.value.number = get_cp_index(string);
            goto LABEL_4;
          }
          if ( type > 4 )
          {
            if ( type == 6 )
            {
              v9 = (const char *)v2->option_elinks.value.tree;
              if ( !assert_failed )
              {
                assert_failed = v9 == 0;
                if ( !v9 )
                {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c";
                  errline = 1152;
                  elinks_internal("assertion string failed!");
                  v9 = 0;
                }
              }
              str = (unsigned __int8 *)v9;
              v10 = strlen(v9);
              decode_color(str, v10, (color_T *)&v2->option_elinks.value);
            }
            else if ( type == 9 )
            {
              inited = init_options_tree();
              v2->option_elinks.value.number = (int)inited;
              if ( !inited )
                goto LABEL_16;
            }
            goto LABEL_4;
          }
          if ( type == 3 )
            break;
        }
LABEL_4:
        add_opt_rec(tree, v2->path, &v2->option_elinks);
LABEL_5:
        path = v3->path;
        v2 = v3++;
        if ( !path )
          return;
      }
      v12 = (unsigned __int8 *)mem_alloc(0x400u);
      if ( v12 )
      {
        stra = v12;
        safe_strncpy(v12, v2->option_elinks.value.string, 0x400u);
        v2->option_elinks.value.number = (int)stra;
        goto LABEL_4;
      }
LABEL_16:
      p_option_elinks = &v2->option_elinks;
      v2 = v3;
      delete_option(p_option_elinks);
      v8 = v3->path;
      ++v3;
    }
    while ( v8 );
  }
}

//----- (08074EA0) --------------------------------------------------------
option_elinks *__cdecl add_opt(
        option_elinks *tree,
        unsigned __int8 *path,
        unsigned __int8 *capt,
        unsigned __int8 *name,
        option_flags flags,
        option_type type,
        int min,
        int max,
        longptr_T value,
        unsigned __int8 *desc)
{
  option_type v10; // edi
  option_elinks *v11; // ebx
  unsigned __int8 *v12; // eax
  listbox_item *v13; // eax
  option_elinks *v15; // [esp+0h] [ebp-28h]
  int v16; // [esp+4h] [ebp-24h]

  v10 = type;
  v11 = (option_elinks *)mem_calloc(1u, 0x38u);
  if ( v11 )
  {
    v12 = stracpy(name);
    v11->name = v12;
    if ( v12 )
    {
      v11->type = type;
      v11->flags = flags | 0x20;
      v11->min = min;
      v11->max = max;
      v11->capt = capt;
      v11->desc = desc;
      switch ( type )
      {
        case OPT_BOOL:
        case OPT_INT:
        case OPT_LONG:
        case OPT_CODEPAGE:
        case OPT_COMMAND:
          goto LABEL_7;
        case OPT_STRING:
        case OPT_TREE:
          if ( !value )
            goto LABEL_18;
LABEL_7:
          v11->value.number = value;
          goto LABEL_8;
        case OPT_COLOR:
          v16 = strlen((const char *)value);
          decode_color((const unsigned __int8 *)value, v16, (color_T *)&v11->value);
          v10 = v11->type;
          goto LABEL_4;
        case OPT_ALIAS:
          v11->value.number = value;
          goto LABEL_12;
        default:
LABEL_4:
          if ( v10 == OPT_ALIAS )
            goto LABEL_12;
LABEL_8:
          if ( (tree->flags & 0x10) == 0 && (v11->flags & 0x10) == 0 )
            goto LABEL_12;
          v13 = (listbox_item *)mem_calloc(1u, 0x20u);
          if ( !v13 )
          {
            v11->box_item = 0;
            goto LABEL_18;
          }
          *((_BYTE *)v13 + 24) |= 2u;
          v13->child.prev = &v13->child;
          v13->child.next = &v13->child;
          v13->udata = v11;
          v13->type = v11->type == OPT_TREE;
          v11->box_item = v13;
LABEL_12:
          add_opt_rec(tree, path, v11);
          break;
      }
    }
    else
    {
LABEL_18:
      v15 = v11;
      v11 = 0;
      mem_free(v15);
    }
  }
  return v11;
}

//----- (08074FE0) --------------------------------------------------------
void update_options_visibility()
{
  option_elinks *opt_rec; // eax

  opt_rec = get_opt_rec(config_options, "config.show_template");
  update_visibility(config_options->value.tree, opt_rec->value.number);
}

//----- (08075010) --------------------------------------------------------
void init_options()
{
  list_head_elinks *inited; // eax
  list_head_elinks *v1; // eax

  inited = init_options_tree();
  cmdline_options = add_opt(
                      &options_root,
                      (unsigned __int8 *)&delete,
                      (unsigned __int8 *)&delete,
                      "cmdline",
                      (option_flags)0,
                      OPT_TREE,
                      0,
                      0,
                      (longptr_T)inited,
                      (unsigned __int8 *)&delete);
  register_options(cmdline_options_info, cmdline_options);
  v1 = init_options_tree();
  config_options = add_opt(
                     &options_root,
                     (unsigned __int8 *)&delete,
                     (unsigned __int8 *)&delete,
                     "config",
                     OPT_SORT,
                     OPT_TREE,
                     0,
                     0,
                     (longptr_T)v1,
                     (unsigned __int8 *)&delete);
  config_options->flags |= 0x10u;
  config_options->box_item = (listbox_item *)(&option_browser + 32);
  register_options(config_options_info, config_options);
  get_opt_rec(config_options, "terminal.linux.type")->value.number = 2;
  get_opt_rec(config_options, "terminal.linux.colors")->value.number = 1;
  get_opt_rec(config_options, "terminal.linux.m11_hack")->value.number = 1;
  get_opt_rec(config_options, "terminal.vt100.type")->value.number = 1;
  get_opt_rec(config_options, "terminal.vt110.type")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm.type")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm.underline")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-color.type")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-color.colors")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-color.underline")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-88color.type")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-88color.colors")->value.number = 2;
  get_opt_rec(config_options, "terminal.xterm-88color.underline")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-256color.type")->value.number = 1;
  get_opt_rec(config_options, "terminal.xterm-256color.colors")->value.number = 3;
  get_opt_rec(config_options, "terminal.xterm-256color.underline")->value.number = 1;
  register_change_hooks(change_hooks);
}

//----- (080752D0) --------------------------------------------------------
option_elinks *__cdecl indirect_option(option_elinks *alias)
{
  option_elinks *v1; // ebx
  option_elinks *opt_rec; // eax

  v1 = alias;
  if ( alias->type == OPT_ALIAS )
  {
    opt_rec = get_opt_rec(config_options, alias->value.string);
    if ( assert_failed
      || (assert_failed = opt_rec == 0, !opt_rec)
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/options.c",
          errline = 266,
          elinks_internal(
            "assertion real != NULL failed: %s aliased to unknown option %s!",
            (const char *)alias->name,
            (const char *)alias->value.tree),
          opt_rec = 0,
          assert_failed) )
    {
      assert_failed = 0;
    }
    else
    {
      return opt_rec;
    }
  }
  return v1;
}

//----- (08075370) --------------------------------------------------------
option_elinks *__cdecl get_opt_rec_real(option_elinks *tree, const unsigned __int8 *name)
{
  option_elinks *result; // eax

  no_autocreate = 1;
  result = get_opt_rec(tree, name);
  no_autocreate = 0;
  return result;
}

//----- (080753A0) --------------------------------------------------------
unsigned __int8 *__cdecl bool_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  unsigned __int8 **v3; // edi
  unsigned __int8 *v4; // esi
  unsigned __int8 v5; // bl

  o->value.number = 1;
  if ( *argc )
  {
    v3 = *argv;
    v4 = **argv;
    v5 = *v4;
    if ( *v4 )
    {
      if ( !v4[1] )
      {
        if ( v5 == 48 )
        {
          o->value.number = 0;
          v3 = *argv;
        }
        else
        {
          if ( v5 != 49 )
            return 0;
          o->value.number = 1;
        }
        *argv = v3 + 1;
        --*argc;
      }
    }
  }
  return 0;
}

//----- (08075430) --------------------------------------------------------
unsigned __int8 *__cdecl exec_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  return (unsigned __int8 *)((int (*)(void))o->value.tree)();
}

//----- (08075440) --------------------------------------------------------
int __cdecl num_set(option_elinks *opt, unsigned __int8 *str)
{
  opt->value.number = *(_DWORD *)str;
  return 1;
}

//----- (08075460) --------------------------------------------------------
int __cdecl num_eq(option_elinks *opt, const unsigned __int8 *str)
{
  int result; // eax

  result = 0;
  if ( str )
    return opt->value.number == *(_DWORD *)str;
  return result;
}

//----- (08075480) --------------------------------------------------------
int __cdecl long_set(option_elinks *opt, unsigned __int8 *str)
{
  opt->value.number = *(_DWORD *)str;
  return 1;
}

//----- (080754A0) --------------------------------------------------------
int __cdecl long_eq(option_elinks *opt, const unsigned __int8 *str)
{
  int result; // eax

  result = 0;
  if ( str )
    return opt->value.number == *(_DWORD *)str;
  return result;
}

//----- (080754C0) --------------------------------------------------------
int __cdecl str_eq(option_elinks *opt, const unsigned __int8 *str)
{
  int result; // eax

  result = 0;
  if ( str )
    return strcmp((const char *)opt->value.tree, (const char *)str) == 0;
  return result;
}

//----- (080754F0) --------------------------------------------------------
void __cdecl tree_dup(option_elinks *opt, option_elinks *templatea)
{
  list_head_elinks *inited; // edx
  listbox_item *v3; // eax
  option_elinks *v4; // eax
  option_elinks *v5; // ebx
  listbox_item *box_item; // esi
  const char *name; // esi
  list_head_elinks *v8; // [esp+10h] [ebp-28h]
  list_head_elinks *tree; // [esp+14h] [ebp-24h]
  listbox_item *v10; // [esp+18h] [ebp-20h]
  option_elinks *option_elinks; // [esp+1Ch] [ebp-1Ch]

  inited = init_options_tree();
  tree = templatea->value.tree;
  if ( inited )
  {
    opt->value.number = (int)inited;
    for ( option_elinks = (option_elinks *)tree->prev;
          option_elinks != (option_elinks *)tree;
          option_elinks = option_elinks->prev )
    {
      v8 = inited;
      v4 = copy_option(option_elinks);
      inited = v8;
      v5 = v4;
      if ( v4 )
      {
        v4->next = *(option_elinks **)v8->prev;
        v4->prev = (option_elinks *)v8->prev;
        *(_DWORD *)v8->prev = v4;
        v4->next->prev = v4;
        box_item = v4->box_item;
        v4->root = opt;
        v10 = box_item;
        if ( box_item )
        {
          name = (const char *)v4->name;
          if ( name && !strcmp(name, "_template_") )
          {
            *((_BYTE *)v10 + 24) = (2 * ((int)get_opt_(config_options, "config.show_template")->tree & 1)) | *((_BYTE *)v10 + 24) & 0xFD;
            inited = v8;
          }
          v3 = opt->box_item;
          if ( v3 )
          {
            v5->box_item->next = (listbox_item *)v3->child.next;
            v5->box_item->prev = (listbox_item *)&opt->box_item->child;
            opt->box_item->child.next = v5->box_item;
            v5->box_item->next->prev = v5->box_item;
          }
        }
      }
    }
  }
}

//----- (08075610) --------------------------------------------------------
int __cdecl redir_eq(option_elinks *opt, const unsigned __int8 *str)
{
  option_elinks *opt_rec; // eax
  option_elinks *v3; // edi
  int (*equals)(option_elinks *, const unsigned __int8 *); // edx
  int result; // eax
  int negated[4]; // [esp+1Ch] [ebp-1Ch] BYREF

  opt_rec = get_opt_rec(config_options, opt->value.string);
  v3 = opt_rec;
  if ( assert_failed
    || (assert_failed = opt_rec == 0, !opt_rec)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c",
        errline = 171,
        elinks_internal(
          "assertion real != NULL failed: %s aliased to unknown option %s!",
          (const char *)opt->name,
          (const char *)opt->value.tree),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    equals = option_types[v3->type].equals;
    result = 0;
    if ( equals )
    {
      if ( (BYTE1(opt->flags) & 1) == 0 || v3->type )
      {
        return equals(v3, str);
      }
      else
      {
        negated[0] = *(_DWORD *)str == 0;
        return option_types[v3->type].equals(v3, (const unsigned __int8 *)negated);
      }
    }
  }
  return result;
}
// 8075610: using guessed type int negated[4];

//----- (08075700) --------------------------------------------------------
int __cdecl redir_set(option_elinks *opt, unsigned __int8 *str)
{
  option_elinks *opt_rec; // eax
  option_elinks *v3; // edi
  int (*set)(option_elinks *, unsigned __int8 *); // edx
  int result; // eax
  int negated[4]; // [esp+1Ch] [ebp-1Ch] BYREF

  opt_rec = get_opt_rec(config_options, opt->value.string);
  v3 = opt_rec;
  if ( assert_failed
    || (assert_failed = opt_rec == 0, !opt_rec)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c",
        errline = 149,
        elinks_internal(
          "assertion real != NULL failed: %s aliased to unknown option %s!",
          (const char *)opt->name,
          (const char *)opt->value.tree),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    set = option_types[v3->type].set;
    result = 0;
    if ( set )
    {
      if ( (BYTE1(opt->flags) & 1) == 0 || v3->type )
      {
        return set(v3, str);
      }
      else
      {
        negated[0] = *(_DWORD *)str == 0;
        return option_types[v3->type].set(v3, (unsigned __int8 *)negated);
      }
    }
  }
  return result;
}
// 8075700: using guessed type int negated[4];

//----- (080757F0) --------------------------------------------------------
void __cdecl redir_wr(option_elinks *opt, string *string)
{
  option_elinks *opt_rec; // eax
  void (*write)(option_elinks *, string *); // edx

  opt_rec = get_opt_rec(config_options, opt->value.string);
  if ( assert_failed
    || (assert_failed = opt_rec == 0, !opt_rec)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c",
        errline = 136,
        elinks_internal(
          "assertion real != NULL failed: %s aliased to unknown option %s!",
          (const char *)opt->name,
          (const char *)opt->value.tree),
        opt_rec = 0,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    write = option_types[opt_rec->type].write;
    if ( write )
      write(opt_rec, string);
  }
}

//----- (080758B0) --------------------------------------------------------
unsigned __int8 *__cdecl redir_rd(option_elinks *opt, unsigned __int8 **file, int *line)
{
  option_elinks *opt_rec; // eax
  option_elinks *v4; // ebx
  unsigned __int8 *result; // eax
  unsigned __int8 *(*read)(option_elinks *, unsigned __int8 **, int *); // edx

  opt_rec = get_opt_rec(config_options, opt->value.string);
  v4 = opt_rec;
  if ( assert_failed
    || (assert_failed = opt_rec == 0, !opt_rec)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c",
        errline = 118,
        elinks_internal(
          "assertion real != NULL failed: %s aliased to unknown option %s!",
          (const char *)opt->name,
          (const char *)opt->value.tree),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    read = option_types[v4->type].read;
    result = 0;
    if ( read )
    {
      result = read(v4, file, line);
      if ( result )
      {
        if ( (BYTE1(opt->flags) & 1) != 0 && v4->type == OPT_BOOL )
          *(_DWORD *)result = *(_DWORD *)result == 0;
      }
    }
  }
  return result;
}

//----- (08075990) --------------------------------------------------------
unsigned __int8 *__cdecl redir_cmd_0(option_elinks *opt, unsigned __int8 ***argv, int *argc)
{
  option_elinks *opt_rec; // eax
  option_elinks *v4; // ebx
  unsigned __int8 *result; // eax
  unsigned __int8 *(*cmdline)(option_elinks *, unsigned __int8 ***, int *); // edx

  opt_rec = get_opt_rec(config_options, opt->value.string);
  v4 = opt_rec;
  if ( assert_failed
    || (assert_failed = opt_rec == 0, !opt_rec)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c",
        errline = 99,
        elinks_internal(
          "assertion real != NULL failed: %s aliased to unknown option %s!",
          (const char *)opt->name,
          (const char *)opt->value.tree),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    cmdline = option_types[v4->type].cmdline;
    result = 0;
    if ( cmdline )
    {
      result = cmdline(v4, argv, argc);
      if ( (BYTE1(opt->flags) & 1) != 0 && v4->type == OPT_BOOL )
        v4->value.number = v4->value.number == 0;
    }
  }
  return result;
}

//----- (08075A70) --------------------------------------------------------
unsigned __int8 *__cdecl get_option_type_name(option_type type)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)type > OPT_TREE;
    if ( (unsigned int)type <= OPT_TREE )
      return option_types[type].name;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
    errline = 500;
    elinks_internal("assertion type >= 0 && type < sizeof(option_types)/sizeof(struct option_type_info) failed!");
    if ( !assert_failed )
      return option_types[type].name;
  }
  assert_failed = 0;
  return (unsigned __int8 *)&delete;
}

//----- (08075AF0) --------------------------------------------------------
int __cdecl color_eq(option_elinks *opt, const unsigned __int8 *str)
{
  int v2; // eax
  int color[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( str && (v2 = strlen((const char *)str), !decode_color(str, v2, (color_T *)color)) )
    return opt->value.number == color[0];
  else
    return 0;
}
// 8075AF0: using guessed type color_T color[3];

//----- (08075B40) --------------------------------------------------------
int __cdecl color_set(option_elinks *opt, unsigned __int8 *str)
{
  int v2; // eax

  v2 = strlen((const char *)str);
  return decode_color(str, v2, (color_T *)&opt->value) == 0;
}

//----- (08075B80) --------------------------------------------------------
void __usercall add_optstring_to_string(string *s@<eax>, const unsigned __int8 *q@<edx>, int qlen@<ecx>)
{
  int v4; // [esp+18h] [ebp-10h]
  const unsigned __int8 *v5; // [esp+1Ch] [ebp-Ch]

  if ( !commandline )
  {
    v5 = q;
    v4 = qlen;
    add_char_to_string(s, 0x22u);
    qlen = v4;
    q = v5;
  }
  add_quoted_to_string(s, q, qlen);
  if ( !commandline )
    add_char_to_string(s, 0x22u);
}

//----- (08075BF0) --------------------------------------------------------
void __cdecl color_wr(option_elinks *opt, string *str)
{
  const unsigned __int8 *color_string; // esi
  int v3; // eax
  unsigned __int8 hexcolor[8]; // [esp+14h] [ebp-14h] BYREF
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  color_string = get_color_string(opt->value.color, hexcolor);
  v3 = strlen((const char *)color_string);
  add_optstring_to_string(str, color_string, v3);
}

//----- (08075C50) --------------------------------------------------------
void __cdecl str_wr(option_elinks *o, string *s)
{
  const char *tree; // ebx
  signed int v3; // eax
  int v4; // ecx

  tree = (const char *)o->value.tree;
  v3 = strlen(tree);
  v4 = o->max - 1;
  if ( v3 <= v4 )
    v4 = v3;
  add_optstring_to_string(s, (const unsigned __int8 *)tree, v4);
}

//----- (08075C90) --------------------------------------------------------
int __cdecl lang_eq(option_elinks *opt, const unsigned __int8 *str)
{
  int result; // eax

  result = 0;
  if ( str )
    return name_to_language(str) == opt->value.number;
  return result;
}

//----- (08075CC0) --------------------------------------------------------
int __cdecl lang_set(option_elinks *opt, unsigned __int8 *str)
{
  int v2; // eax

  v2 = name_to_language(str);
  opt->value.number = v2;
  set_language(v2);
  return 1;
}

//----- (08075CF0) --------------------------------------------------------
void __cdecl lang_wr(option_elinks *o, string *s)
{
  unsigned __int8 *v2; // esi
  int v3; // eax

  v2 = language_to_name(current_language);
  v3 = strlen((const char *)v2);
  add_optstring_to_string(s, v2, v3);
}

//----- (08075D30) --------------------------------------------------------
int __cdecl cp_eq(option_elinks *opt, const unsigned __int8 *str)
{
  int result; // eax

  result = 0;
  if ( str )
    return get_cp_index(str) == opt->value.number;
  return result;
}

//----- (08075D60) --------------------------------------------------------
int __cdecl cp_set(option_elinks *opt, unsigned __int8 *str)
{
  int cp_index; // edx
  int result; // eax

  cp_index = get_cp_index(str);
  result = 0;
  if ( cp_index >= 0 )
  {
    opt->value.number = cp_index;
    return 1;
  }
  return result;
}

//----- (08075D90) --------------------------------------------------------
void __cdecl cp_wr(option_elinks *o, string *s)
{
  unsigned __int8 *cp_config_name; // esi
  int v3; // eax

  cp_config_name = get_cp_config_name(o->value.number);
  v3 = strlen((const char *)cp_config_name);
  add_optstring_to_string(s, cp_config_name, v3);
}

//----- (08075DD0) --------------------------------------------------------
int __cdecl str_set(option_elinks *opt, unsigned __int8 *str)
{
  option_value v2; // ecx

  if ( !assert_failed )
  {
    v2.tree = (list_head_elinks *)opt->value;
    assert_failed = v2.number == 0;
    if ( !v2.number )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/opttypes.c";
      errline = 321;
      elinks_internal("assertion opt->value.string failed!");
    }
  }
  safe_strncpy(opt->value.string, str, 0x400u);
  return 1;
}

//----- (08075E50) --------------------------------------------------------
void __cdecl str_dup(option_elinks *opt, option_elinks *templatea)
{
  unsigned __int8 *v2; // ebx

  v2 = (unsigned __int8 *)mem_alloc(0x400u);
  if ( v2 )
    safe_strncpy(v2, templatea->value.string, 0x400u);
  opt->value.number = (int)v2;
}

//----- (08075E90) --------------------------------------------------------
unsigned __int8 *__cdecl str_rd(option_elinks *opt, unsigned __int8 **file, int *line)
{
  unsigned __int8 *v3; // ebx
  string *inited; // edx
  unsigned __int8 *result; // eax
  int v6; // edx
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // edx
  unsigned __int8 *v10; // ecx
  int max; // eax
  string str2; // [esp+18h] [ebp-20h] BYREF

  v3 = *file;
  inited = init_string(&str2);
  result = 0;
  if ( inited )
  {
    v6 = commandline;
    if ( !commandline )
    {
      if ( *v3 != 39 && *v3 != 34 )
        goto LABEL_32;
      ++v3;
    }
    v7 = *v3;
    if ( !*v3 )
    {
LABEL_27:
      if ( !v6 )
      {
        done_string(&str2);
        result = 0;
        *file = v3;
        return result;
      }
LABEL_20:
      if ( !opt )
        return str2.source;
      max = opt->max;
      if ( !max || max > str2.length )
        return str2.source;
LABEL_32:
      done_string(&str2);
      return 0;
    }
    while ( 1 )
    {
      if ( !v6 && (v7 == 39 || v7 == 34) )
      {
        *file = v3 + 1;
        goto LABEL_20;
      }
      v9 = v3;
      v10 = v3 + 1;
      if ( v7 == 92 )
      {
        v8 = v3[1];
        v9 = v3 + 1;
        if ( v8 == 10 )
        {
          v3[1] = 32;
          v10 = v3 + 2;
          ++*line;
        }
        else
        {
          if ( v8 == 39 || v8 == 34 )
          {
            v3 += 2;
            goto LABEL_7;
          }
          v10 = v3 + 1;
          v9 = v3;
          if ( v8 == 92 )
          {
            v3 += 2;
            goto LABEL_7;
          }
        }
      }
      v8 = *v9;
      v3 = v10;
      if ( *v9 == 10 )
      {
        ++*line;
        v8 = *v9;
      }
LABEL_7:
      add_char_to_string(&str2, v8);
      v7 = *v3;
      if ( !*v3 )
      {
        v6 = commandline;
        goto LABEL_27;
      }
      v6 = commandline;
    }
  }
  return result;
}
// 8075F5A: conditional instruction was optimized away because al.1 is in (==22|==27)

//----- (08075FE0) --------------------------------------------------------
void __cdecl long_wr(option_elinks *option_elinks, string *string)
{
  add_knum_to_string(string, option_elinks->value.number);
}

//----- (08076000) --------------------------------------------------------
void __cdecl num_wr(option_elinks *option_elinks, string *string)
{
  add_knum_to_string(string, option_elinks->value.number);
}

//----- (08076020) --------------------------------------------------------
unsigned __int8 *__cdecl gen_cmd(option_elinks *o, unsigned __int8 ***argv, int *argc)
{
  unsigned __int8 *v3; // eax
  unsigned __int8 *p; // [esp+1Ch] [ebp-2Ch]
  int dummy_line[4]; // [esp+2Ch] [ebp-1Ch] BYREF

  dummy_line[0] = 0;
  if ( !*argc )
    return gettext("Parameter expected");
  commandline = 1;
  v3 = option_types[o->type].read(o, *argv, dummy_line);
  commandline = 0;
  if ( !v3 )
    return gettext("Read error");
  ++*argv;
  --*argc;
  p = v3;
  if ( !option_types[o->type].set(o, v3) )
  {
    mem_free(p);
    return gettext("Read error");
  }
  mem_free(p);
  return 0;
}
// 8076020: using guessed type int dummy_line[4];

//----- (080760E0) --------------------------------------------------------
unsigned __int8 *__cdecl num_rd(option_elinks *opt, unsigned __int8 **file, int *line)
{
  int *v3; // ebx
  unsigned __int8 *result; // eax
  unsigned __int8 *v5; // eax
  unsigned __int8 v6; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *end; // [esp+2Ch] [ebp-1Ch] BYREF

  end = *file;
  v3 = (int *)mem_alloc(4u);
  result = 0;
  if ( v3 )
  {
    *v3 = strtolx(*file, &end);
    v5 = end;
    if ( !commandline )
      *file = end;
    if ( *v5 && (commandline || (v6 = *v5, ((*__ctype_b_loc())[v6] & 0x2000) == 0) && v6 != 35)
      || *v3 < opt->min
      || (result = (unsigned __int8 *)v3, *v3 > opt->max) )
    {
      mem_free(v3);
      return 0;
    }
  }
  return result;
}

//----- (080761A0) --------------------------------------------------------
void __cdecl done_timer(module *module)
{
  kill_timer(&periodic_save_timer);
}

//----- (080761C0) --------------------------------------------------------
void __cdecl periodic_save_handler(void *xxx)
{
  option_value *opt; // eax
  milliseconds_T v2; // eax

  if ( !get_opt_(cmdline_options, "anonymous")->number )
  {
    if ( periodic_save_event_id_4824 == -1 )
      periodic_save_event_id_4824 = get_event_id("periodic-saving");
    else
      trigger_event(periodic_save_event_id_4824);
    opt = get_opt_(config_options, "infofiles.save_interval");
    v2 = sec_to_ms(opt->number);
    if ( v2 )
    {
      install_timer(&periodic_save_timer, v2, periodic_save_handler, 0);
    }
    else if ( !assert_failed )
    {
      assert_failed = periodic_save_timer != 0;
      if ( periodic_save_timer )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/config/timer.c";
        errline = 42;
        elinks_internal("assertion periodic_save_timer == TIMER_ID_UNDEF failed!");
      }
    }
  }
}

//----- (080762B0) --------------------------------------------------------
void __cdecl init_timer(module *module)
{
  register_change_hooks(timer_change_hooks_4871);
  periodic_save_handler(0);
}

//----- (080762D0) --------------------------------------------------------
int __cdecl periodic_save_change_hook(session *ses, option_elinks *current, option_elinks *changed)
{
  if ( !get_opt_(cmdline_options, "anonymous")->number )
  {
    kill_timer(&periodic_save_timer);
    periodic_save_handler(0);
  }
  return 0;
}

//----- (08076310) --------------------------------------------------------
evhook_status __cdecl goto_url_history_write_hook(va_list ap, void *data)
{
  save_input_history(&goto_url_history, "gotohist");
  return 0;
}

//----- (08076330) --------------------------------------------------------
void __cdecl done_url_history(module *module)
{
  _DWORD *next; // eax
  input_history *i; // ebx
  input_history *j; // edx
  input_history *v4; // esi
  input_history *v5; // edi

  save_input_history(&goto_url_history, "gotohist");
  next = goto_url_history.entries.next;
  for ( i = (input_history *)goto_url_history.entries.next; i != &goto_url_history; i = (input_history *)i->entries.next )
    ;
  for ( j = (input_history *)goto_url_history.entries.prev; j != i; j = (input_history *)j->entries.prev )
    ;
  v4 = *(input_history **)goto_url_history.entries.next;
  if ( goto_url_history.entries.next != i )
  {
    do
    {
      v5 = v4;
      v4->entries.prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v4 = (input_history *)v4->entries.next;
      next = &v5->entries.next;
    }
    while ( v5 != i );
  }
}

//----- (080763B0) --------------------------------------------------------
void __cdecl init_url_history(module *module)
{
  load_input_history(&goto_url_history, "gotohist");
}

//----- (080763D0) --------------------------------------------------------
void __cdecl save_cookies(terminal *term)
{
  unsigned __int8 *v1; // eax
  unsigned __int8 *v2; // ebx
  time_t v3; // eax
  list_head_elinks *next; // ebx
  time_t v5; // eax
  const char *v6; // ecx
  const char *prev; // edx
  unsigned __int8 *v8; // eax
  secure_save_info *ssi; // [esp+38h] [ebp-20h]
  time_t now; // [esp+3Ch] [ebp-1Ch]

  if ( cookies_nosave )
  {
    if ( assert_failed
      || (assert_failed = term != 0, term)
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/cookies.c",
          errline = 825,
          elinks_internal("assertion term == NULL failed!"),
          assert_failed) )
    {
      assert_failed = 0;
    }
  }
  else if ( elinks_home )
  {
    if ( term || cookies_dirty )
    {
      if ( get_opt_(cmdline_options, "anonymous")->number )
      {
        if ( term )
          info_box(
            term,
            (msgbox_flags)0,
            "Cannot save cookies",
            ALIGN_LEFT,
            "ELinks was started with the -anonymous option.");
      }
      else
      {
        v1 = straconcat((const unsigned __int8 *)elinks_home, "cookies", 0);
        v2 = v1;
        if ( v1 )
        {
          ssi = secure_open(v1);
          mem_free(v2);
          if ( !ssi )
            goto LABEL_28;
          v3 = time(0);
          next = (list_head_elinks *)cookies.next;
          now = v3;
          if ( cookies.next != &cookies )
          {
            do
            {
              v5 = (time_t)next[4].next;
              if ( v5 && now < v5 )
              {
                v6 = (const char *)next[3].next;
                if ( !v6 )
                  v6 = &delete;
                prev = (const char *)next[2].prev;
                if ( !prev )
                  prev = &delete;
                if ( secure_fprintf(
                       ssi,
                       "%s\t%s\t%s\t%s\t%s\t%ld\t%d\n",
                       (const char *)next[1].prev,
                       (const char *)next[2].next,
                       (const char *)next[3].prev + 16,
                       prev,
                       v6,
                       next[4].next,
                       next[4].prev) < 0 )
                  break;
              }
              next = (list_head_elinks *)next->next;
            }
            while ( &cookies != next );
          }
          secsave_errno_0 = SS_ERR_OTHER;
          if ( !secure_close(ssi) )
          {
            cookies_dirty = 0;
          }
          else
          {
LABEL_28:
            if ( term )
            {
              v8 = secsave_strerror(secsave_errno_0, term);
              info_box(term, MSGBOX_NO_TEXT_INTL, "Cannot save cookies", ALIGN_LEFT, v8);
            }
          }
        }
        else if ( term )
        {
          info_box(term, (msgbox_flags)0, "Cannot save cookies", ALIGN_LEFT, (unsigned __int8 *)byte_8127CFF);
        }
      }
    }
  }
  else if ( term )
  {
    info_box(term, (msgbox_flags)0, "Cannot save cookies", ALIGN_LEFT, "ELinks was started without a home directory.");
  }
}

//----- (08076640) --------------------------------------------------------
void __cdecl resave_cookies_bottom_half(void *always_null)
{
  if ( cookies_options[4].option_elinks.value.number )
  {
    if ( cookies_options[5].option_elinks.value.number )
      save_cookies(0);
  }
}

//----- (08076670) --------------------------------------------------------
void set_cookies_dirty()
{
  cookies_dirty = 1;
  register_bottom_half_do(resave_cookies_bottom_half, 0);
}

//----- (080766A0) --------------------------------------------------------
cookie_server *__cdecl get_cookie_server(unsigned __int8 *host, int hostlen)
{
  cookie_server *next; // ebx
  int v3; // edi
  int v4; // eax
  cookie_server *v5; // edi
  cookie_server *v7; // eax
  listbox_item *v8; // eax
  cookie_server *v9; // eax
  cookie_server *i; // [esp+28h] [ebp-20h]
  cookie_server *sort_spot; // [esp+2Ch] [ebp-1Ch]

  next = (cookie_server *)cookie_servers.next;
  if ( cookie_servers.next == &cookie_servers )
  {
    sort_spot = 0;
LABEL_13:
    v7 = (cookie_server *)mem_calloc(1u, hostlen + 20);
    v5 = v7;
    if ( v7 )
    {
      memcpy(v7->host, host, hostlen);
      v8 = add_listbox_item(&cookie_browser, 0, BI_FOLDER, v5, 1);
      ++v5->object.refcount;
      v5->box_item = v8;
      if ( sort_spot )
      {
        v9 = sort_spot->next;
        v5->prev = sort_spot;
        v5->next = v9;
        sort_spot->next = v5;
        v5->next->prev = v5;
        if ( next != sort_spot )
        {
          v5->box_item->next->prev = v5->box_item->prev;
          v5->box_item->prev->next = v5->box_item->next;
          v5->box_item->next = sort_spot->box_item->next;
          v5->box_item->prev = sort_spot->box_item;
          sort_spot->box_item->next = v5->box_item;
          v5->box_item->next->prev = v5->box_item;
        }
      }
      else
      {
        v5->next = *(cookie_server **)cookie_servers.prev;
        v5->prev = (cookie_server *)cookie_servers.prev;
        *(_DWORD *)cookie_servers.prev = v5;
        v5->next->prev = v5;
        v5->box_item->next->prev = v5->box_item->prev;
        v5->box_item->prev->next = v5->box_item->next;
        v5->box_item->next = *(listbox_item **)cookie_browser.root.child.prev;
        v5->box_item->prev = (listbox_item *)cookie_browser.root.child.prev;
        *(_DWORD *)cookie_browser.root.child.prev = v5->box_item;
        v5->box_item->next->prev = v5->box_item;
      }
    }
  }
  else
  {
    sort_spot = 0;
    for ( i = (cookie_server *)cookie_servers.next; ; i = next )
    {
      v3 = strlen((const char *)next->host);
      v4 = c_strncasecmp((const char *)next->host, (const char *)host, hostlen);
      if ( !sort_spot && (v4 > 0 || v3 > hostlen && !v4) )
        sort_spot = next->prev;
      if ( v3 == hostlen && !v4 )
        break;
      next = next->next;
      if ( next == (cookie_server *)&cookie_servers )
        goto LABEL_13;
    }
    v5 = i;
    ++next->object.refcount;
  }
  return v5;
}

//----- (08076880) --------------------------------------------------------
void __usercall done_cookie_server(cookie_server *cs_0@<eax>)
{
  int v2; // eax

  v2 = cs_0->object.refcount - 1;
  cs_0->object.refcount = v2;
  if ( !v2 )
  {
    if ( cs_0->box_item )
      done_listbox_item(&cookie_browser, cs_0->box_item);
    cs_0->next->prev = cs_0->prev;
    cs_0->prev->next = cs_0->next;
    mem_free(cs_0);
  }
}

//----- (080768D0) --------------------------------------------------------
cookie *__cdecl init_cookie(
        unsigned __int8 *name,
        unsigned __int8 *value,
        unsigned __int8 *path,
        unsigned __int8 *domain,
        cookie_server *server)
{
  cookie *result; // eax

  result = (cookie *)mem_calloc(1u, 0x2Cu);
  if ( result )
  {
    if ( name && path && value && server && domain )
    {
      result->name = name;
      result->value = value;
      result->path = path;
      result->domain = domain;
      result->server = server;
      return result;
    }
    mem_free(result);
  }
  if ( name )
    mem_free(name);
  if ( value )
    mem_free(value);
  if ( path )
    mem_free(path);
  if ( domain )
    mem_free(domain);
  done_cookie_server(server);
  return 0;
}
// 8076942: conditional instruction was optimized away because eax.4!=0

//----- (08076990) --------------------------------------------------------
void __cdecl done_cookie(cookie *c)
{
  cookie_server *server; // eax

  if ( c->box_item )
    done_listbox_item(&cookie_browser, c->box_item);
  server = c->server;
  if ( server )
    done_cookie_server(server);
  if ( c->name )
    mem_free(c->name);
  if ( c->value )
    mem_free(c->value);
  if ( c->path )
    mem_free(c->path);
  if ( c->domain )
    mem_free(c->domain);
  mem_free(c);
}

//----- (08076A10) --------------------------------------------------------
void __cdecl delete_cookie(cookie *c)
{
  c->next->prev = c->prev;
  c->prev->next = c->next;
  done_cookie(c);
}

//----- (08076A40) --------------------------------------------------------
void __cdecl done_cookies(module *module)
{
  _DWORD *next; // eax
  list_head_elinks *i; // ebx
  list_head_elinks *j; // edx
  list_head_elinks *v4; // esi
  list_head_elinks *v5; // edi
  cookie *v6; // eax
  cookie *k; // eax

  next = c_domains.next;
  for ( i = (list_head_elinks *)c_domains.next; i != &c_domains; i = (list_head_elinks *)i->next )
    ;
  for ( j = (list_head_elinks *)c_domains.prev; j != i; j = (list_head_elinks *)j->prev )
    ;
  v4 = *(list_head_elinks **)c_domains.next;
  if ( c_domains.next != i )
  {
    do
    {
      v5 = v4;
      v4->prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v4 = (list_head_elinks *)v4->next;
      next = &v5->next;
    }
    while ( v5 != i );
  }
  if ( cookies_nosave || !cookies_options[4].option_elinks.value.number )
    goto LABEL_11;
  save_cookies(0);
  v6 = (cookie *)cookies.next;
  if ( cookies.next == &cookies )
    goto LABEL_14;
  do
  {
    delete_cookie(v6);
LABEL_11:
    v6 = (cookie *)cookies.next;
  }
  while ( cookies.next != &cookies );
  for ( k = (cookie *)cookie_queries.next; cookie_queries.next != &cookie_queries; k = (cookie *)cookie_queries.next )
  {
    delete_cookie(k);
LABEL_14:
    ;
  }
  cookies_dirty = 0;
}

//----- (08076B20) --------------------------------------------------------
string *__cdecl send_cookies(uri *uri)
{
  unsigned __int8 *host; // eax
  string *result; // eax
  unsigned __int8 *next; // esi
  cookie *v4; // ebx
  list_head_elinks *v5; // eax
  const char *path; // esi
  time_t expires; // eax
  unsigned int v8; // [esp+1Ch] [ebp-2Ch]
  time_t now; // [esp+20h] [ebp-28h]
  char *s; // [esp+24h] [ebp-24h]
  list_head_elinks *v11; // [esp+2Ch] [ebp-1Ch]

  host = uri->host;
  if ( !host )
    return 0;
  if ( !uri->data )
    return 0;
  next = (unsigned __int8 *)c_domains.next;
  if ( c_domains.next == &c_domains )
    return 0;
  while ( !is_in_domain(next + 8, host, *((unsigned __int16 *)uri + 23)) )
  {
    next = *(unsigned __int8 **)next;
    if ( next == (unsigned __int8 *)&c_domains )
      return 0;
    host = uri->host;
  }
  s = (char *)get_uri_string(uri, URI_PATH);
  if ( !s )
    return 0;
  init_string(&header_8344);
  now = time(0);
  v11 = *(list_head_elinks **)cookies.next;
  if ( cookies.next != &cookies )
  {
    v4 = (cookie *)cookies.next;
    while ( 1 )
    {
      if ( !is_in_domain(v4->domain, uri->host, *((unsigned __int16 *)uri + 23)) )
        goto LABEL_14;
      path = (const char *)v4->path;
      v8 = strlen(path);
      if ( v8 > strlen(s) || memcmp(path, s, v8) )
        goto LABEL_14;
      expires = v4->expires;
      if ( expires )
      {
        if ( now >= expires )
          break;
      }
      if ( v4->secure && uri->protocol != 10 )
        goto LABEL_14;
      if ( header_8344.length )
        add_to_string(&header_8344, "; ");
      add_to_string(&header_8344, v4->name);
      add_char_to_string(&header_8344, 0x3Du);
      add_to_string(&header_8344, v4->value);
      v5 = (list_head_elinks *)v11->next;
      v4 = (cookie *)v11;
      if ( v11 == &cookies )
        goto LABEL_25;
LABEL_15:
      v11 = v5;
    }
    delete_cookie(v4);
    set_cookies_dirty();
LABEL_14:
    v5 = (list_head_elinks *)v11->next;
    v4 = (cookie *)v11;
    if ( v11 == &cookies )
      goto LABEL_25;
    goto LABEL_15;
  }
LABEL_25:
  mem_free(s);
  result = &header_8344;
  if ( !header_8344.length )
  {
    done_string(&header_8344);
    return 0;
  }
  return result;
}

//----- (08076D20) --------------------------------------------------------
void __cdecl accept_cookie(cookie *cookie)
{
  listbox_item *box_item; // eax
  cookie *next; // ebx
  list_head_elinks *v3; // edi
  cookie *v4; // eax
  char *v5; // ebx
  char **v6; // eax
  char **v7; // edi
  char *v8; // eax
  size_t v9; // [esp+2Ch] [ebp-1Ch]

  box_item = cookie->server->box_item;
  if ( box_item )
    cookie->box_item = add_listbox_item(&cookie_browser, box_item, BI_LEAF, cookie, 1);
  if ( !cookies_nosave )
  {
    next = (cookie *)cookies.next;
    v3 = *(list_head_elinks **)cookies.next;
    if ( cookies.next != &cookies )
    {
      while ( 1 )
      {
        if ( !c_strcasecmp((const char *)next->name, (const char *)cookie->name)
          && !c_strcasecmp((const char *)next->domain, (const char *)cookie->domain) )
        {
          delete_cookie(next);
        }
        next = (cookie *)v3;
        if ( &cookies == v3 )
          break;
        v3 = (list_head_elinks *)v3->next;
      }
    }
  }
  v4 = (cookie *)cookies.next;
  cookie->prev = (cookie *)&cookies;
  cookie->next = v4;
  cookies.next = cookie;
  cookie->next->prev = cookie;
  set_cookies_dirty();
  v5 = (char *)c_domains.next;
  if ( c_domains.next == &c_domains )
  {
LABEL_16:
    v9 = strlen((const char *)cookie->domain);
    v6 = (char **)mem_alloc(v9 + 12);
    v7 = v6;
    if ( v6 )
    {
      memcpy(v6 + 2, cookie->domain, v9 + 1);
      v8 = *(char **)v5;
      v7[1] = v5;
      *v7 = v8;
      *(_DWORD *)v5 = v7;
      *((_DWORD *)*v7 + 1) = v7;
    }
  }
  else
  {
    while ( c_strcasecmp(v5 + 8, (const char *)cookie->domain) )
    {
      v5 = *(char **)v5;
      if ( v5 == (char *)&c_domains )
        goto LABEL_16;
    }
  }
}

//----- (08076E80) --------------------------------------------------------
void load_cookies()
{
  unsigned __int8 *v0; // ebx
  int v1; // edi
  int v2; // esi
  unsigned __int8 *i; // ebx
  char *v4; // eax
  char *v5; // eax
  int v6; // eax
  int v7; // esi
  cookie *v8; // ebx
  unsigned __int8 *v9; // eax
  cookie_server *server; // edi
  time_t now; // [esp+18h] [ebp-1860h]
  FILE *fp; // [esp+1Ch] [ebp-185Ch]
  load_cookies::$ECB0A3A4EC44DDCAB1264784E86766DB members[7]; // [esp+24h] [ebp-1854h]
  unsigned __int8 in_buffer[6144]; // [esp+5Ch] [ebp-181Ch] BYREF
  unsigned int v15; // [esp+185Ch] [ebp-1Ch]

  v0 = "cookies";
  v15 = __readgsdword(0x14u);
  if ( !elinks_home || (v0 = straconcat((const unsigned __int8 *)elinks_home, "cookies", 0)) != 0 )
  {
    cookies_nosave = 1;
    done_cookies(&cookies_module);
    cookies_nosave = 0;
    fp = (FILE *)fopen64(v0, "rb");
    if ( elinks_home )
      mem_free(v0);
    if ( fp )
    {
      cookies_nosave = 1;
      now = time(0);
LABEL_7:
      while ( fgets((char *)in_buffer, 6144, fp) )
      {
        v1 = 0;
        v2 = 0;
        for ( i = in_buffer; ; i = (unsigned __int8 *)(v4 + 1) )
        {
          v4 = strchr((const char *)i, 9);
          if ( !v4 )
            break;
          ++v1;
          members[v2].pos = i;
          members[v2++].len = v4 - (char *)i;
          if ( v1 == 7 )
          {
            if ( v2 != 7 )
              goto LABEL_7;
            goto LABEL_15;
          }
        }
        if ( v2 != 6 )
          goto LABEL_7;
        v5 = strchr((const char *)i, 10);
        if ( !v5 )
          goto LABEL_7;
        members[6].pos = i;
        members[6].len = v5 - (char *)i;
LABEL_15:
        v6 = strtol((const char *)members[5].pos, 0, 10);
        v7 = v6;
        if ( now < v6 && v6 )
        {
          v8 = (cookie *)mem_calloc(1u, 0x2Cu);
          if ( v8 )
          {
            v8->server = get_cookie_server(members[2].pos, members[2].len);
            v8->name = memacpy(members[0].pos, members[0].len);
            v8->value = memacpy(members[1].pos, members[1].len);
            v8->path = memacpy(members[3].pos, members[3].len);
            v9 = memacpy(members[4].pos, members[4].len);
            server = v8->server;
            v8->domain = v9;
            if ( server && v8->name && v8->value && v8->path && v9 )
            {
              v8->expires = v7;
              v8->secure = strtol((const char *)members[6].pos, 0, 10) != 0;
              accept_cookie(v8);
            }
            else
            {
              done_cookie(v8);
            }
          }
        }
        else
        {
          set_cookies_dirty();
        }
      }
      cookies_nosave = 0;
      fclose(fp);
    }
  }
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08077170) --------------------------------------------------------
void __cdecl init_cookies(module *module)
{
  if ( cookies_options[4].option_elinks.value.number )
    load_cookies();
}

//----- (08077190) --------------------------------------------------------
void __cdecl set_cookie(uri *uri, unsigned __int8 *str)
{
  parse_header_param v2; // eax
  size_t v3; // eax
  char v4; // dl
  unsigned __int8 *v5; // edi
  size_t v6; // eax
  unsigned __int8 *v7; // edi
  cookie_server *cookie_server; // eax
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // eax
  cookie *inited; // edi
  parse_header_param v12; // eax
  unsigned __int8 *v13; // ecx
  time_t v14; // eax
  int v15; // eax
  char *v16; // ebx
  const char *v17; // eax
  signed int v18; // eax
  unsigned __int8 *uri_string; // eax
  char *v20; // eax
  int v21; // eax
  int v22; // ecx
  char *v23; // edx
  unsigned __int8 v24; // al
  cookie *next; // eax
  size_t v26; // eax
  unsigned __int8 *valuea; // [esp+2Ch] [ebp-4Ch]
  unsigned __int8 *valueb; // [esp+2Ch] [ebp-4Ch]
  unsigned __int8 *value; // [esp+2Ch] [ebp-4Ch]
  char serverb; // [esp+30h] [ebp-48h]
  cookie_server *serverc; // [esp+30h] [ebp-48h]
  option_value server; // [esp+30h] [ebp-48h]
  cookie_server *servera; // [esp+30h] [ebp-48h]
  const unsigned __int8 *address; // [esp+34h] [ebp-44h]
  char *s1; // [esp+38h] [ebp-40h]
  unsigned __int8 *v36; // [esp+3Ch] [ebp-3Ch]
  int v37; // [esp+3Ch] [ebp-3Ch]
  cookie_str cstr; // [esp+44h] [ebp-34h] BYREF
  unsigned __int8 *date; // [esp+54h] [ebp-24h] BYREF
  unsigned __int8 *domain; // [esp+58h] [ebp-20h] BYREF
  unsigned __int8 *path[4]; // [esp+5Ch] [ebp-1Ch] BYREF

  if ( cookies_options[1].option_elinks.value.number && parse_cookie_str(&cstr, str) )
  {
    v2 = parse_header_param_0(str, "path", path);
    if ( v2 )
    {
      if ( v2 != HEADER_PARAM_NOT_FOUND )
        return;
      uri_string = get_uri_string(uri, URI_PATH);
      if ( !uri_string )
        return;
      path[0] = uri_string;
      v20 = strrchr((const char *)uri_string, 47);
      if ( v20 )
        v20[1] = 0;
    }
    else
    {
      if ( !*path[0]
        || (serverb = *path[0], valuea = path[0], v3 = strlen((const char *)path[0]), v4 = serverb, valuea[v3 - 1] != 47) )
      {
        add_to_strn(path, "/");
        v4 = *path[0];
      }
      if ( v4 != 47 )
      {
        add_to_strn(path, (const unsigned __int8 *)"x");
        v5 = path[0];
        v6 = strlen((const char *)path[0]);
        memmove(v5 + 1, v5, v6 - 1);
        *path[0] = 47;
      }
    }
    if ( parse_header_param_0(str, "domain", &domain) == HEADER_PARAM_NOT_FOUND )
    {
      v7 = memacpy(uri->host, *((unsigned __int16 *)uri + 23));
      domain = v7;
    }
    else
    {
      v7 = domain;
    }
    if ( v7 && *v7 == 46 )
    {
      v26 = strlen((const char *)v7);
      memmove(v7, v7 + 1, v26);
    }
    cookie_server = get_cookie_server(uri->host, *((unsigned __int16 *)uri + 23));
    v9 = domain;
    serverc = cookie_server;
    v36 = path[0];
    valueb = memacpy(cstr.val_start, cstr.val_end - cstr.val_start);
    v10 = memacpy(str, cstr.nam_end - str);
    inited = init_cookie(v10, valueb, v36, v9, serverc);
    if ( inited )
    {
      if ( cookies_options[2].option_elinks.value.number )
      {
        server.tree = (list_head_elinks *)cookies_options[2].option_elinks.value;
        v12 = parse_header_param_0(str, "expires", &date);
        if ( v12 )
        {
          if ( v12 != HEADER_PARAM_NOT_FOUND )
          {
            done_cookie(inited);
            return;
          }
        }
        else
        {
          value = (unsigned __int8 *)parse_date(&date, 0, 0, 1);
          mem_free(date);
          v13 = value;
          if ( value )
          {
            if ( server.number > 0 )
            {
              v14 = time(0);
              v13 = value;
              v15 = 86400 * server.number + v14;
              if ( (int)value > v15 )
                v13 = (unsigned __int8 *)v15;
            }
            inited->expires = (time_t)v13;
          }
        }
      }
      inited->secure = parse_header_param_0(str, "secure", 0) == HEADER_PARAM_FOUND;
      v37 = *((unsigned __int16 *)uri + 23);
      address = uri->host;
      v16 = (char *)inited->domain;
      v17 = v16 + 1;
      if ( *v16 != 46 )
        v17 = (const char *)inited->domain;
      s1 = (char *)v17;
      v18 = strlen(v17);
      if ( v37 >= v18 )
      {
        servera = (cookie_server *)v18;
        if ( !c_strncasecmp(s1, (const char *)&address[v37 - v18], v18) )
        {
          if ( (cookie_server *)v37 == servera )
          {
LABEL_27:
            if ( cookies_options[1].option_elinks.value.number == 1 )
            {
              next = (cookie *)cookie_queries.next;
              inited->prev = (cookie *)&cookie_queries;
              inited->next = next;
              cookie_queries.next = inited;
              inited->next->prev = inited;
              add_questions_entry(accept_cookie_dialog, inited);
            }
            else
            {
              accept_cookie(inited);
            }
            return;
          }
          if ( !is_ip_address(address, v37) )
          {
            if ( !cookies_options[3].option_elinks.value.number
              || (int)servera > 0
              && (v21 = end_with_known_tld((const unsigned __int8 *)s1, (int)servera), v21 > 0)
              && s1[v21 - 1] == 46 )
            {
              v22 = 1;
            }
            else
            {
              v22 = 2;
            }
            v23 = s1;
            v24 = *s1;
            if ( *s1 )
            {
              do
              {
                if ( v24 == 46 )
                {
                  if ( v22 == 1 )
                    goto LABEL_27;
                  v22 = 1;
                }
                v24 = *++v23;
              }
              while ( v24 );
            }
          }
        }
        v16 = (char *)inited->domain;
      }
      mem_free(v16);
      inited->domain = memacpy(uri->host, *((unsigned __int16 *)uri + 23));
      goto LABEL_27;
    }
  }
}

//----- (080775F0) --------------------------------------------------------
void __cdecl lock_cookie(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (08077600) --------------------------------------------------------
void __cdecl unlock_cookie(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (08077610) --------------------------------------------------------
int __cdecl is_cookie_used(listbox_item *item)
{
  listbox_item *next; // eax

  if ( item->type != BI_FOLDER )
    return *((_DWORD *)item->udata + 2) != 0;
  next = (listbox_item *)item->child.next;
  if ( next == (listbox_item *)&item->child )
    return 0;
  while ( !*((_DWORD *)next->udata + 2) )
  {
    next = next->next;
    if ( next == (listbox_item *)&item->child )
      return 0;
  }
  return 1;
}

//----- (08077660) --------------------------------------------------------
listbox_item *__cdecl get_cookie_root(listbox_item *item)
{
  listbox_item *result; // eax

  result = 0;
  if ( item->type != BI_FOLDER )
    return *(listbox_item **)(*((_DWORD *)item->udata + 7) + 12);
  return result;
}

//----- (08077680) --------------------------------------------------------
int __cdecl can_delete_cookie(listbox_item *item)
{
  return 1;
}

//----- (08077690) --------------------------------------------------------
void __cdecl delete_cookie_item(listbox_item *item, int last)
{
  cookie *udata; // ebx
  int refcount; // esi
  listbox_item *next; // eax
  listbox_item *v5; // ebx

  udata = (cookie *)item->udata;
  if ( item->type == BI_FOLDER )
  {
    next = (listbox_item *)item->child.next;
    v5 = next->next;
    if ( next != (listbox_item *)&item->child )
    {
      while ( 1 )
      {
        delete_cookie_item(next, 0);
        next = v5;
        if ( &item->child == (list_head_elinks *)v5 )
          break;
        v5 = v5->next;
      }
    }
  }
  else
  {
    if ( !assert_failed )
    {
      refcount = udata->object.refcount;
      assert_failed = refcount != 0;
      if ( refcount )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
        errline = 200;
        elinks_internal("assertion !is_object_used(cookie) failed!");
      }
    }
    delete_cookie(udata);
    set_cookies_dirty();
  }
}

//----- (08077740) --------------------------------------------------------
unsigned __int8 *__cdecl get_cookie_text(listbox_item *item, terminal *term)
{
  if ( item->type == BI_FOLDER )
    return stracpy((const unsigned __int8 *)item->udata + 16);
  else
    return stracpy(*((const unsigned __int8 **)item->udata + 3));
}

//----- (08077770) --------------------------------------------------------
widget_handler_status_T __cdecl push_save_button_0(dialog_data *dlg_data, widget_data *button)
{
  save_cookies(dlg_data->win->term);
  return 0;
}

//----- (08077790) --------------------------------------------------------
widget_handler_status_T __cdecl set_cookie_domain(dialog_data *dlg_data, widget_data *widget_data)
{
  void **udata; // ebx
  unsigned __int8 *cdata; // esi

  udata = (void **)dlg_data->dlg->udata;
  cdata = widget_data->cdata;
  if ( !udata || !cdata )
    return 1;
  if ( udata[6] )
    mem_free(udata[6]);
  udata[6] = stracpy(cdata);
  set_cookies_dirty();
  return 0;
}

//----- (080777F0) --------------------------------------------------------
widget_handler_status_T __cdecl set_cookie_value(dialog_data *dlg_data, widget_data *widget_data)
{
  void **udata; // ebx
  unsigned __int8 *cdata; // esi

  udata = (void **)dlg_data->dlg->udata;
  cdata = widget_data->cdata;
  if ( !udata || !cdata )
    return 1;
  if ( udata[4] )
    mem_free(udata[4]);
  udata[4] = stracpy(cdata);
  set_cookies_dirty();
  return 0;
}

//----- (08077850) --------------------------------------------------------
widget_handler_status_T __cdecl set_cookie_name(dialog_data *dlg_data, widget_data *widget_data)
{
  void **udata; // ebx
  unsigned __int8 *cdata; // esi

  udata = (void **)dlg_data->dlg->udata;
  cdata = widget_data->cdata;
  if ( !udata || !cdata )
    return 1;
  if ( udata[3] )
    mem_free(udata[3]);
  udata[3] = stracpy(cdata);
  set_cookies_dirty();
  return 0;
}

//----- (080778B0) --------------------------------------------------------
widget_handler_status_T __cdecl set_cookie_secure(dialog_data *dlg_data, widget_data *widget_data)
{
  _DWORD *udata; // ebx
  unsigned __int8 *cdata; // esi
  int *v5; // eax
  int *v6; // edi
  int v7; // eax
  unsigned __int8 *end; // [esp+1Ch] [ebp-1Ch] BYREF

  udata = dlg_data->dlg->udata;
  cdata = widget_data->cdata;
  if ( !udata )
    return 1;
  if ( !cdata )
    return 1;
  v5 = __errno_location();
  *v5 = 0;
  v6 = v5;
  v7 = strtol((const char *)cdata, (char **)&end, 10);
  if ( *v6 || *end )
    return 1;
  udata[9] = v7 != 0;
  set_cookies_dirty();
  return 0;
}

//----- (08077940) --------------------------------------------------------
widget_handler_status_T __cdecl set_cookie_expires(dialog_data *dlg_data, widget_data *widget_data)
{
  _DWORD *udata; // ebx
  unsigned __int8 *cdata; // esi
  int *v5; // eax
  int *v6; // edi
  int v7; // eax
  unsigned __int8 *end; // [esp+1Ch] [ebp-1Ch] BYREF

  udata = dlg_data->dlg->udata;
  cdata = widget_data->cdata;
  if ( !udata )
    return 1;
  if ( !cdata )
    return 1;
  v5 = __errno_location();
  *v5 = 0;
  v6 = v5;
  v7 = strtol((const char *)cdata, (char **)&end, 10);
  if ( *v6 || v7 < 0 || *end )
    return 1;
  udata[8] = v7;
  set_cookies_dirty();
  return 0;
}

//----- (080779C0) --------------------------------------------------------
void __cdecl add_server_do(void *data)
{
  int v1; // eax
  cookie_server *cookie_server; // edi
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // eax
  cookie *inited; // eax
  unsigned __int8 *domain; // [esp+2Ch] [ebp-1Ch]

  if ( data )
  {
    v1 = strlen((const char *)data);
    cookie_server = get_cookie_server((unsigned __int8 *)data, v1);
    domain = stracpy((const unsigned __int8 *)data);
    v3 = stracpy("/");
    v4 = stracpy((const unsigned __int8 *)"1");
    v5 = stracpy("empty");
    inited = init_cookie(v5, v4, v3, domain, cookie_server);
    if ( inited )
      accept_cookie(inited);
  }
}

//----- (08077A70) --------------------------------------------------------
void __cdecl accept_cookie_in_msg_box(void *cookie_)
{
  accept_cookie((cookie *)cookie_);
}

//----- (08077A80) --------------------------------------------------------
void __cdecl cookie_manager(session *ses)
{
  hierbox_browser_0(&cookie_browser, ses);
}

//----- (08077AA0) --------------------------------------------------------
void __cdecl reject_cookie_in_msg_box(void *cookie_)
{
  done_cookie((cookie *)cookie_);
}

//----- (08077AB0) --------------------------------------------------------
widget_handler_status_T __cdecl push_add_server_button(dialog_data *dlg_data, widget_data *button)
{
  terminal *term; // esi
  dialog *v3; // ebx
  widget_handler_status_T result; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  int v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // eax
  int v13; // eax
  int v14; // edi
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  memory_list *v17; // eax
  bool v18; // zf
  int v19; // [esp+3Ch] [ebp-1Ch]
  int v20; // [esp+3Ch] [ebp-1Ch]
  int v21; // [esp+3Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  v3 = (dialog *)mem_calloc(1u, 0x4B4u);
  result = EVENT_NOT_PROCESSED;
  if ( v3 )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        v19 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v19;
      }
    }
    v3->title = gettext(&byte_812B299);
    v3->layouter = generic_dialog_layouter;
    v3->udata = 0;
    v3->udata2 = 0;
    if ( term )
    {
      v7 = get_terminal_codepage(term);
      if ( v7 != current_charset )
      {
        v20 = v7;
        v8 = get_cp_mime_name(v7);
        bind_textdomain_codeset("elinks", v8);
        current_charset = v20;
      }
    }
    v9 = gettext(&byte_812B2A4);
    add_dlg_field_do(v3, WIDGET_FIELD, v9, 0, 0, check_nonempty, 1024, &v3[2].refresh, 0, INPFIELD_FLOAT);
    if ( term )
    {
      v10 = get_terminal_codepage(term);
      if ( v10 != current_charset )
      {
        v21 = v10;
        v11 = get_cp_mime_name(v10);
        bind_textdomain_codeset("elinks", v11);
        current_charset = v21;
      }
    }
    v12 = gettext(&okbutton);
    add_dlg_button_do(v3, v12, 1, ok_dialog, 0, add_server_do, &v3[2].refresh);
    if ( term )
    {
      v13 = get_terminal_codepage(term);
      v14 = v13;
      if ( v13 != current_charset )
      {
        v15 = get_cp_mime_name(v13);
        bind_textdomain_codeset("elinks", v15);
        current_charset = v14;
      }
    }
    v16 = gettext(&cancelbutton);
    add_dlg_button_do(v3, v16, 2, cancel_dialog, 0, 0, 0);
    if ( !assert_failed )
    {
      v18 = v3->number_of_widgets == 3;
      assert_failed = v3->number_of_widgets != 3;
      if ( !v18 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
        errline = 472;
        elinks_internal("assertion 3 == (dlg)->number_of_widgets failed!");
      }
    }
    v17 = getml(v3, 0);
    do_dialog(term, v3, v17);
    return 0;
  }
  return result;
}

//----- (08077D60) --------------------------------------------------------
void __usercall build_edit_dialog(terminal *term@<eax>, cookie *cookie@<edx>)
{
  char *v4; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  cookie_server *server; // edi
  int v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // edi
  int v13; // eax
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // eax
  int v16; // eax
  unsigned __int8 *v17; // eax
  unsigned __int8 *v18; // eax
  int v19; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  int v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // eax
  int v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // eax
  int v28; // eax
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // eax
  int v31; // eax
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  memory_list *v34; // eax
  bool v35; // zf
  unsigned int *slen; // [esp+38h] [ebp-40h]
  unsigned int *slena; // [esp+38h] [ebp-40h]
  unsigned int *slenb; // [esp+38h] [ebp-40h]
  unsigned int *slenc; // [esp+38h] [ebp-40h]
  unsigned int *slend; // [esp+38h] [ebp-40h]
  unsigned int *slene; // [esp+38h] [ebp-40h]
  unsigned int *slenf; // [esp+38h] [ebp-40h]
  unsigned int *sleng; // [esp+38h] [ebp-40h]
  unsigned int *slenh; // [esp+38h] [ebp-40h]
  int length[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  length[0] = 0;
  v4 = (char *)mem_calloc(1u, 0x15A4u);
  if ( v4 )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        slen = (unsigned int *)terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = (int)slen;
      }
    }
    *(_DWORD *)v4 = gettext(&byte_8127A45);
    *((_DWORD *)v4 + 1) = cookie;
    *((_DWORD *)v4 + 4) = generic_dialog_layouter;
    *((_DWORD *)v4 + 2) = 0;
    safe_strncpy((unsigned __int8 *)v4 + 420, cookie->name, 0x400u);
    safe_strncpy((unsigned __int8 *)v4 + 1444, cookie->value, 0x400u);
    safe_strncpy((unsigned __int8 *)v4 + 2468, cookie->domain, 0x400u);
    elinks_ulongcat((unsigned __int8 *)v4 + 3492, (unsigned int *)length, cookie->expires, 0x400u, 0, 0xAu, 0);
    length[0] = 0;
    elinks_ulongcat((unsigned __int8 *)v4 + 4516, (unsigned int *)length, cookie->secure, 0x400u, 0, 0xAu, 0);
    server = cookie->server;
    if ( term )
    {
      v8 = get_terminal_codepage(term);
      if ( v8 != current_charset )
      {
        slena = (unsigned int *)v8;
        v9 = get_cp_mime_name(v8);
        bind_textdomain_codeset("elinks", v9);
        current_charset = (int)slena;
      }
    }
    v10 = gettext(&item);
    v11 = straconcat(v10, ": ", server->host, "\n", 0);
    v12 = v11;
    if ( v11 )
    {
      add_dlg_text((dialog *)v4, v11, ALIGN_LEFT, 0);
      if ( term )
      {
        v13 = get_terminal_codepage(term);
        if ( v13 != current_charset )
        {
          slenb = (unsigned int *)v13;
          v14 = get_cp_mime_name(v13);
          bind_textdomain_codeset("elinks", v14);
          current_charset = (int)slenb;
        }
      }
      v15 = gettext(&str);
      add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v15, 0, 0, set_cookie_name, 1024, v4 + 420, 0, INPFIELD_FLOAT);
      if ( term )
      {
        v16 = get_terminal_codepage(term);
        if ( v16 != current_charset )
        {
          slenc = (unsigned int *)v16;
          v17 = get_cp_mime_name(v16);
          bind_textdomain_codeset("elinks", v17);
          current_charset = (int)slenc;
        }
      }
      v18 = gettext(&label);
      add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v18, 0, 0, set_cookie_value, 1024, v4 + 1444, 0, INPFIELD_FLOAT);
      if ( term )
      {
        v19 = get_terminal_codepage(term);
        if ( v19 != current_charset )
        {
          slend = (unsigned int *)v19;
          v20 = get_cp_mime_name(v19);
          bind_textdomain_codeset("elinks", v20);
          current_charset = (int)slend;
        }
      }
      v21 = gettext(&byte_812B2B7);
      add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v21, 0, 0, set_cookie_domain, 1024, v4 + 2468, 0, INPFIELD_FLOAT);
      if ( term )
      {
        v22 = get_terminal_codepage(term);
        if ( v22 != current_charset )
        {
          slene = (unsigned int *)v22;
          v23 = get_cp_mime_name(v22);
          bind_textdomain_codeset("elinks", v23);
          current_charset = (int)slene;
        }
      }
      v24 = gettext(&byte_8127C42);
      add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v24, 0, 0, set_cookie_expires, 1024, v4 + 3492, 0, INPFIELD_FLOAT);
      if ( term )
      {
        v25 = get_terminal_codepage(term);
        if ( v25 != current_charset )
        {
          slenf = (unsigned int *)v25;
          v26 = get_cp_mime_name(v25);
          bind_textdomain_codeset("elinks", v26);
          current_charset = (int)slenf;
        }
      }
      v27 = gettext(&byte_812B2BE);
      add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v27, 0, 0, set_cookie_secure, 1024, v4 + 4516, 0, INPFIELD_FLOAT);
      if ( term )
      {
        v28 = get_terminal_codepage(term);
        if ( v28 != current_charset )
        {
          sleng = (unsigned int *)v28;
          v29 = get_cp_mime_name(v28);
          bind_textdomain_codeset("elinks", v29);
          current_charset = (int)sleng;
        }
      }
      v30 = gettext(&okbutton);
      add_dlg_button_do((dialog *)v4, v30, 1, ok_dialog, 0, 0, 0);
      if ( term )
      {
        v31 = get_terminal_codepage(term);
        if ( v31 != current_charset )
        {
          slenh = (unsigned int *)v31;
          v32 = get_cp_mime_name(v31);
          bind_textdomain_codeset("elinks", v32);
          current_charset = (int)slenh;
        }
      }
      v33 = gettext(&cancelbutton);
      add_dlg_button_do((dialog *)v4, v33, 2, cancel_dialog, 0, 0, 0);
      if ( !assert_failed )
      {
        v35 = *((_DWORD *)v4 + 8) == 8;
        assert_failed = *((_DWORD *)v4 + 8) != 8;
        if ( !v35 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
          errline = 375;
          elinks_internal("assertion 8 == (dlg)->number_of_widgets failed!");
        }
      }
      v34 = getml(v4, v12, 0);
      do_dialog(term, (dialog *)v4, v34);
    }
    else
    {
      mem_free(v4);
    }
  }
}

//----- (08078430) --------------------------------------------------------
widget_handler_status_T __cdecl push_edit_button_1(dialog_data *dlg_data, widget_data *button)
{
  listbox_item *sel; // eax
  cookie *udata; // edx

  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( sel )
  {
    if ( sel->type != BI_FOLDER )
    {
      udata = (cookie *)sel->udata;
      if ( udata )
        build_edit_dialog(dlg_data->win->term, udata);
    }
  }
  return 0;
}

//----- (08078470) --------------------------------------------------------
widget_handler_status_T __cdecl push_add_button_1(dialog_data *dlg_data, widget_data *button)
{
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // edx
  cookie_server *udata; // ebx
  unsigned __int8 *v5; // edi
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // eax
  cookie *inited; // eax
  cookie *v9; // ebx
  unsigned __int8 *domain; // [esp+28h] [ebp-20h]
  unsigned __int8 *domaina; // [esp+28h] [ebp-20h]
  terminal *term; // [esp+2Ch] [ebp-1Ch]

  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  sel = listbox_widget_data->sel;
  if ( sel )
  {
    udata = (cookie_server *)sel->udata;
    if ( udata )
    {
      if ( sel->type == BI_FOLDER )
      {
        if ( !assert_failed )
        {
          assert_failed = sel->depth != 0;
          if ( assert_failed )
          {
            domaina = (unsigned __int8 *)listbox_widget_data;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
            errline = 407;
            elinks_internal("assertion box->sel->depth == 0 failed!");
            listbox_widget_data = (listbox_data *)domaina;
          }
          udata = (cookie_server *)listbox_widget_data->sel->udata;
        }
      }
      else
      {
        udata = (cookie_server *)udata[1].object.refcount;
      }
      ++udata->object.refcount;
      domain = stracpy(udata->host);
      v5 = stracpy("/");
      v6 = stracpy((const unsigned __int8 *)&delete);
      v7 = stracpy((const unsigned __int8 *)&delete);
      inited = init_cookie(v7, v6, v5, domain, udata);
      v9 = inited;
      if ( inited )
      {
        accept_cookie(inited);
        build_edit_dialog(term, v9);
      }
    }
  }
  return 0;
}

//----- (08078580) --------------------------------------------------------
void __usercall add_cookie_info_to_string(string *string@<eax>, cookie *cookie@<edx>, terminal *term@<ecx>)
{
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v8; // eax
  int v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  int v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  int v18; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // edx
  int v25; // eax
  int v26; // esi
  unsigned __int8 *v27; // eax
  int v28; // eax
  int v29; // esi
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // eax
  int v32; // eax
  unsigned __int8 *v33; // eax
  unsigned __int8 *v34; // eax
  option_value *opt; // eax
  int v36; // [esp+18h] [ebp-20h]
  int v37; // [esp+18h] [ebp-20h]
  int v38; // [esp+18h] [ebp-20h]
  int v39; // [esp+18h] [ebp-20h]
  int v40; // [esp+18h] [ebp-20h]
  int v41; // [esp+18h] [ebp-20h]
  unsigned __int8 *v42; // [esp+18h] [ebp-20h]
  unsigned __int8 *v43; // [esp+18h] [ebp-20h]
  const char *v44; // [esp+18h] [ebp-20h]
  int v45; // [esp+18h] [ebp-20h]
  unsigned __int8 *name; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *value; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *domain; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *path; // [esp+1Ch] [ebp-1Ch]

  name = cookie->name;
  if ( term )
  {
    terminal_codepage = get_terminal_codepage(term);
    if ( terminal_codepage != current_charset )
    {
      v36 = terminal_codepage;
      cp_mime_name = get_cp_mime_name(terminal_codepage);
      bind_textdomain_codeset("elinks", cp_mime_name);
      current_charset = v36;
    }
  }
  v8 = gettext(&str);
  add_format_to_string(string, "\n%s: %s", (const char *)v8, (const char *)name);
  value = cookie->value;
  if ( term )
  {
    v9 = get_terminal_codepage(term);
    if ( v9 != current_charset )
    {
      v37 = v9;
      v10 = get_cp_mime_name(v9);
      bind_textdomain_codeset("elinks", v10);
      current_charset = v37;
    }
  }
  v11 = gettext(&label);
  add_format_to_string(string, "\n%s: %s", (const char *)v11, (const char *)value);
  domain = cookie->domain;
  if ( term )
  {
    v12 = get_terminal_codepage(term);
    if ( v12 != current_charset )
    {
      v38 = v12;
      v13 = get_cp_mime_name(v12);
      bind_textdomain_codeset("elinks", v13);
      current_charset = v38;
    }
  }
  v14 = gettext(&byte_812B2B7);
  add_format_to_string(string, "\n%s: %s", (const char *)v14, (const char *)domain);
  path = cookie->path;
  if ( term )
  {
    v15 = get_terminal_codepage(term);
    if ( v15 != current_charset )
    {
      v39 = v15;
      v16 = get_cp_mime_name(v15);
      bind_textdomain_codeset("elinks", v16);
      current_charset = v39;
    }
  }
  v17 = gettext(&byte_812B2C5);
  add_format_to_string(string, "\n%s: %s", (const char *)v17, (const char *)path);
  if ( cookie->expires )
  {
    if ( term )
    {
      v32 = get_terminal_codepage(term);
      if ( v32 != current_charset )
      {
        v45 = v32;
        v33 = get_cp_mime_name(v32);
        bind_textdomain_codeset("elinks", v33);
        current_charset = v45;
      }
    }
    v34 = gettext(&byte_8127C42);
    add_format_to_string(string, &byte_81279A6, v34);
    opt = get_opt_(config_options, "ui.date_format");
    add_date_to_string(string, opt->string, &cookie->expires);
  }
  else
  {
    if ( term )
    {
      v18 = get_terminal_codepage(term);
      if ( v18 != current_charset )
      {
        v40 = v18;
        v19 = get_cp_mime_name(v18);
        bind_textdomain_codeset("elinks", v19);
        current_charset = v40;
      }
    }
    v20 = gettext(&byte_8127C42);
    add_format_to_string(string, &byte_81279A6, v20);
    if ( term )
    {
      v21 = get_terminal_codepage(term);
      if ( v21 != current_charset )
      {
        v41 = v21;
        v22 = get_cp_mime_name(v21);
        bind_textdomain_codeset("elinks", v22);
        current_charset = v41;
      }
    }
    v23 = gettext(&byte_812B2CA);
    add_to_string(string, v23);
  }
  v24 = "yes";
  if ( !cookie->secure )
    v24 = (unsigned __int8 *)&byte_812785C;
  if ( *v24 )
  {
    if ( term )
    {
      v42 = v24;
      v25 = get_terminal_codepage(term);
      v24 = v42;
      v26 = v25;
      if ( v25 != current_charset )
      {
        v27 = get_cp_mime_name(v25);
        bind_textdomain_codeset("elinks", v27);
        v24 = v42;
        current_charset = v26;
      }
    }
    v24 = gettext(v24);
  }
  if ( term )
  {
    v43 = v24;
    v28 = get_terminal_codepage(term);
    v24 = v43;
    v29 = v28;
    if ( v28 != current_charset )
    {
      v30 = get_cp_mime_name(v28);
      bind_textdomain_codeset("elinks", v30);
      v24 = v43;
      current_charset = v29;
    }
  }
  v44 = (const char *)v24;
  v31 = gettext(&byte_812B2BE);
  add_format_to_string(string, "\n%s: %s", (const char *)v31, v44);
}

//----- (080789A0) --------------------------------------------------------
unsigned __int8 *__cdecl get_cookie_info(listbox_item *item, terminal *term)
{
  cookie *udata; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v6; // eax
  int v7; // [esp+18h] [ebp-30h]
  cookie_server *server; // [esp+1Ch] [ebp-2Ch]
  string string; // [esp+28h] [ebp-20h] BYREF

  udata = (cookie *)item->udata;
  if ( item->type == BI_FOLDER || !init_string(&string) )
    return 0;
  server = udata->server;
  if ( term )
  {
    terminal_codepage = get_terminal_codepage(term);
    if ( terminal_codepage != current_charset )
    {
      v7 = terminal_codepage;
      cp_mime_name = get_cp_mime_name(terminal_codepage);
      bind_textdomain_codeset("elinks", cp_mime_name);
      current_charset = v7;
    }
  }
  v6 = gettext(&::item);
  add_format_to_string(&string, "%s: %s", (const char *)v6, (const char *)server->host);
  add_cookie_info_to_string(&string, udata, term);
  return string.source;
}

//----- (08078A70) --------------------------------------------------------
void __cdecl accept_cookie_dialog(session *ses, void *data)
{
  cookie *next; // ebx
  list_head_elinks *v3; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v6; // eax
  int v7; // [esp+48h] [ebp-30h]
  cookie_server *server; // [esp+4Ch] [ebp-2Ch]
  string string; // [esp+58h] [ebp-20h] BYREF

  next = (cookie *)cookie_queries.next;
  if ( assert_failed || (assert_failed = ses == 0, ses) )
  {
    v3 = (list_head_elinks *)cookie_queries.next;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/cookies/dialogs.c";
    errline = 73;
    elinks_internal("assertion ses failed!");
    v3 = (list_head_elinks *)cookie_queries.next;
  }
  if ( v3 != &cookie_queries && init_string(&string) )
  {
    next->next->prev = next->prev;
    next->prev->next = next->next;
    server = next->server;
    if ( ses->tab->term )
    {
      terminal_codepage = get_terminal_codepage(ses->tab->term);
      if ( terminal_codepage != current_charset )
      {
        v7 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v7;
      }
    }
    v6 = gettext(&byte_811A318);
    add_format_to_string(&string, v6, server->host);
    add_to_string(&string, &ptr);
    add_cookie_info_to_string(&string, next, ses->tab->term);
    msg_box(
      ses->tab->term,
      0,
      MSGBOX_FREE_TEXT,
      "Accept cookie?",
      ALIGN_LEFT,
      string.source,
      next,
      2,
      "~Accept",
      accept_cookie_in_msg_box,
      1,
      "~Reject",
      reject_cookie_in_msg_box,
      2);
  }
}

//----- (08078C10) --------------------------------------------------------
cookie_str *__cdecl parse_cookie_str(cookie_str *cstr, unsigned __int8 *str)
{
  cookie_str *v2; // esi
  unsigned __int8 v3; // bl
  const unsigned __int16 **v4; // eax
  unsigned __int8 *v5; // edx
  cookie_str *result; // eax
  const unsigned __int16 *v7; // edi
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl
  unsigned __int8 *v10; // edx

  v2 = cstr;
  cstr->nam_end = 0;
  cstr->val_start = 0;
  cstr->val_end = 0;
  cstr->str = str;
  v3 = *str;
  if ( *str == 61 || v3 == 59 )
    return 0;
  v4 = __ctype_b_loc();
  v5 = str;
  do
  {
    if ( ((*v4)[v3] & 0x2000) != 0 )
      break;
    if ( !v3 )
      break;
    v3 = *++v5;
    if ( *v5 == 61 )
      break;
  }
  while ( v3 != 59 );
  if ( v5 == str )
    return 0;
  cstr->nam_end = v5;
  v7 = *v4;
  while ( 1 )
  {
    v8 = *v5;
    if ( (v7[*v5] & 0x2000) == 0 )
      break;
    ++v5;
  }
  if ( v8 == 59 )
    goto LABEL_17;
  if ( v8 != 61 )
  {
    if ( v8 )
      return 0;
LABEL_17:
    cstr->val_start = v5;
    result = cstr;
    cstr->val_end = v5;
    return result;
  }
  do
    ++v5;
  while ( *v5 == 61 );
  for ( ; (v7[*v5] & 0x2000) != 0; ++v5 )
    ;
  cstr->val_start = v5;
  cstr->val_end = v5;
  v9 = *v5;
  if ( *v5 == 59 || !v9 )
    return v2;
  v10 = v5 + 1;
  while ( 1 )
  {
    if ( ((*v4)[v9] & 0x2000) == 0 )
      cstr->val_end = v10;
    v9 = *v10++;
    if ( !v9 )
      break;
    if ( v9 == 59 )
      return v2;
  }
  return cstr;
}

//----- (08078D30) --------------------------------------------------------
void __cdecl cached_header_dialog(session *ses, cache_entry *cached)
{
  unsigned __int8 *head; // eax
  msgbox_flags v3; // edx
  size_t v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int8 v6; // dl
  int v7; // esi
  int v8; // ecx
  unsigned __int8 *v9; // eax
  int v10; // ecx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // edx
  unsigned __int8 v13; // si
  int v14; // ecx
  unsigned __int8 *headers; // [esp+2Ch] [ebp-1Ch]

  if ( !cached )
    goto display_headers;
  head = cached->head;
  if ( !head || !*head )
    goto display_headers;
  v4 = strlen((const char *)cached->head);
  headers = (unsigned __int8 *)mem_alloc(v4 + 1);
  if ( headers )
  {
    v5 = cached->head;
    v6 = *v5;
    if ( *v5 )
    {
      v7 = 0;
      v8 = 0;
      do
      {
        while ( v6 == 10 || v6 > 0x1Fu )
        {
          ++v8;
          headers[v7] = v6;
          v5 = cached->head;
          ++v7;
          v6 = v5[v8];
          if ( !v6 )
            goto LABEL_16;
        }
        if ( v6 != 13 )
        {
          headers[v7] = 42;
          v5 = cached->head;
          ++v7;
        }
        v6 = v5[++v8];
      }
      while ( v6 );
LABEL_16:
      v9 = headers;
      headers[v7] = 0;
      if ( v7 )
      {
        v10 = v7 - 1;
        v9 = headers;
        v11 = &headers[v7 - 1];
        v12 = &headers[v7 - 2];
        if ( *v11 == 10 )
        {
          do
          {
            *v11 = 0;
            if ( !v10 )
            {
              v14 = *headers;
              goto LABEL_22;
            }
            v13 = *v12;
            --v10;
            v11 = v12--;
          }
          while ( v13 == 10 );
          v9 = headers;
        }
      }
      LOBYTE(v14) = *v9;
LABEL_22:
      v3 = MSGBOX_SCROLLABLE|MSGBOX_FREE_TEXT;
      if ( (_BYTE)v14 )
        goto LABEL_5;
    }
    else
    {
      *headers = 0;
    }
    mem_free(headers);
display_headers:
    headers = "No header info.";
    v3 = 0;
LABEL_5:
    info_box(ses->tab->term, v3, "Header info", ALIGN_LEFT, headers);
  }
}

//----- (08078E80) --------------------------------------------------------
void __cdecl nowhere_box(terminal *term, unsigned __int8 *title)
{
  unsigned __int8 *v2; // ebx

  v2 = title;
  if ( assert_failed
    || (assert_failed = term == 0, !term)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/document.c",
        errline = 39,
        elinks_internal("assertion term failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    if ( !title || !*title )
      v2 = "Info";
    info_box(term, (msgbox_flags)0, v2, ALIGN_CENTER, "You are nowhere!");
  }
}

//----- (08078F40) --------------------------------------------------------
void __cdecl protocol_header_dialog(session *ses)
{
  document_view *doc_view; // edx
  document *document; // edx

  if ( ses->history.current )
  {
    doc_view = ses->doc_view;
    if ( doc_view )
    {
      document = doc_view->document;
      if ( document )
        cached_header_dialog(ses, document->cached);
    }
  }
  else
  {
    nowhere_box(ses->tab->term, "Header info");
  }
}

//----- (08078F90) --------------------------------------------------------
unsigned __int8 *__usercall _3@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (08079000) --------------------------------------------------------
void __cdecl document_info_dialog(session *ses)
{
  terminal *term; // edi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v4; // eax
  unsigned __int8 *title; // edx
  int v6; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  cache_entry *v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // eax
  unsigned __int8 *cp_name; // edx
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  cp_status cp_status; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // edx
  int v20; // eax
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *ssl_info; // edx
  int v24; // eax
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *encoding_info; // edx
  int v28; // eax
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // eax
  unsigned __int8 *v32; // edx
  int v33; // eax
  unsigned __int8 *v34; // eax
  unsigned __int8 *v35; // eax
  unsigned __int8 *last_modified; // edx
  int v37; // eax
  unsigned __int8 *v38; // eax
  unsigned __int8 *v39; // eax
  int v40; // eax
  unsigned __int8 *v41; // eax
  unsigned __int8 *v42; // eax
  global_history_item *global_history_item; // eax
  char *v44; // edx
  unsigned int v45; // ecx
  size_t v46; // eax
  unsigned __int8 *v47; // eax
  unsigned __int8 *current_link_info; // esi
  int v49; // eax
  unsigned __int8 *v50; // eax
  unsigned __int8 *v51; // eax
  unsigned __int8 *current_link_title; // esi
  int v53; // eax
  unsigned __int8 *v54; // eax
  unsigned __int8 *v55; // eax
  link *current_link_in_view; // eax
  link *v57; // esi
  int v58; // eax
  unsigned __int8 *v59; // eax
  unsigned __int8 *v60; // eax
  global_history_item *v61; // eax
  global_history_item *v62; // esi
  char *v63; // edx
  int v64; // eax
  unsigned __int8 *v65; // eax
  unsigned __int8 *v66; // eax
  const char *v67; // esi
  int v68; // eax
  unsigned __int8 *v69; // eax
  unsigned __int8 *v70; // eax
  unsigned __int8 *v71; // eax
  int v72; // eax
  unsigned __int8 *v73; // eax
  unsigned __int8 *v74; // eax
  const unsigned __int8 *v75; // eax
  terminal *v76; // edx
  unsigned __int8 *v77; // eax
  const char *v78; // eax
  int v79; // [esp+20h] [ebp-48h]
  int v80; // [esp+20h] [ebp-48h]
  int v81; // [esp+20h] [ebp-48h]
  int v82; // [esp+20h] [ebp-48h]
  int v83; // [esp+20h] [ebp-48h]
  int v84; // [esp+20h] [ebp-48h]
  int v85; // [esp+20h] [ebp-48h]
  int v86; // [esp+20h] [ebp-48h]
  void *pi; // [esp+24h] [ebp-44h]
  unsigned __int8 *p; // [esp+24h] [ebp-44h]
  const char *pj; // [esp+24h] [ebp-44h]
  void *pk; // [esp+24h] [ebp-44h]
  unsigned __int8 *pa; // [esp+24h] [ebp-44h]
  const char *pl; // [esp+24h] [ebp-44h]
  unsigned __int8 *pb; // [esp+24h] [ebp-44h]
  char *pm; // [esp+24h] [ebp-44h]
  unsigned __int8 *pc; // [esp+24h] [ebp-44h]
  const char *pn; // [esp+24h] [ebp-44h]
  unsigned __int8 *pd; // [esp+24h] [ebp-44h]
  const char *po; // [esp+24h] [ebp-44h]
  unsigned __int8 *pe; // [esp+24h] [ebp-44h]
  char *pp; // [esp+24h] [ebp-44h]
  unsigned __int8 *pf; // [esp+24h] [ebp-44h]
  const char *pq; // [esp+24h] [ebp-44h]
  void *pr; // [esp+24h] [ebp-44h]
  void *ps; // [esp+24h] [ebp-44h]
  void *pt; // [esp+24h] [ebp-44h]
  void *pu; // [esp+24h] [ebp-44h]
  char *pg; // [esp+24h] [ebp-44h]
  const char *pv; // [esp+24h] [ebp-44h]
  void *pw; // [esp+24h] [ebp-44h]
  char *ph; // [esp+24h] [ebp-44h]
  void *px; // [esp+24h] [ebp-44h]
  off_t v112; // [esp+28h] [ebp-40h]
  int length; // [esp+28h] [ebp-40h]
  location *location; // [esp+34h] [ebp-34h]
  location *locationa; // [esp+34h] [ebp-34h]
  document_view *doc_view; // [esp+38h] [ebp-30h]
  document_view *doc_viewa; // [esp+38h] [ebp-30h]
  terminal *doc_viewb; // [esp+38h] [ebp-30h]
  cache_entry *cached; // [esp+3Ch] [ebp-2Ch]
  cache_entry *cacheda; // [esp+3Ch] [ebp-2Ch]
  document_view *cachedb; // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 *cachedc; // [esp+3Ch] [ebp-2Ch]
  string string; // [esp+40h] [ebp-28h] BYREF
  string msg; // [esp+48h] [ebp-20h] BYREF

  term = ses->tab->term;
  location = ses->history.current;
  if ( !location )
  {
    nowhere_box(term, 0);
    return;
  }
  doc_view = current_frame(ses);
  if ( init_string(&msg) )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        pi = (void *)terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = (int)pi;
      }
    }
    v4 = gettext(&byte_812B6C9);
    add_to_string(&msg, v4);
    add_to_string(&msg, ": ");
    add_uri_to_string(&msg, location->vs.uri, URI_PUBLIC);
    add_char_to_string(&msg, 0xAu);
    if ( doc_view )
    {
      title = doc_view->document->title;
      if ( title )
      {
        if ( term )
        {
          p = doc_view->document->title;
          v6 = get_terminal_codepage(term);
          title = p;
          if ( v6 != current_charset )
          {
            v79 = v6;
            v7 = get_cp_mime_name(v6);
            bind_textdomain_codeset("elinks", v7);
            current_charset = v79;
            title = p;
          }
        }
        pj = (const char *)title;
        v8 = gettext(&byte_81279A0);
        add_format_to_string(&msg, "%s: %s", (const char *)v8, pj);
      }
    }
    add_char_to_string(&msg, 0xAu);
    v9 = doc_view->document->cached;
    cached = v9;
    if ( !v9 )
    {
LABEL_47:
      if ( term )
      {
        v40 = get_terminal_codepage(term);
        if ( v40 != current_charset )
        {
          pr = (void *)v40;
          v41 = get_cp_mime_name(v40);
          bind_textdomain_codeset("elinks", v41);
          current_charset = (int)pr;
        }
      }
      v42 = gettext(&byte_812B3DB);
      add_format_to_string(&msg, &byte_81279A6, v42);
      global_history_item = get_global_history_item(location->vs.uri->string);
      if ( global_history_item && (v44 = ctime(&global_history_item->last_visit)) != 0 )
      {
        if ( assert_failed )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 0;
          length = msg.length;
          locationa = (location *)(msg.length + 24);
          v46 = msg.length + 280;
          v45 = msg.length + 255;
          LOBYTE(v46) = 0;
          LOBYTE(v45) = 0;
          cacheda = (cache_entry *)v46;
          doc_viewa = (document_view *)v45;
          if ( v46 <= v45 )
            goto LABEL_54;
          ph = v44;
          v71 = (unsigned __int8 *)mem_realloc(msg.source, v46);
          if ( v71 )
          {
            msg.source = v71;
            memset(&v71[(_DWORD)doc_viewa], 0, (char *)cacheda - (char *)doc_viewa);
            v44 = ph;
LABEL_54:
            if ( msg.source )
            {
              v47 = &msg.source[msg.length];
              *(_DWORD *)v47 = *(_DWORD *)v44;
              *((_DWORD *)v47 + 1) = *((_DWORD *)v44 + 1);
              *((_DWORD *)v47 + 2) = *((_DWORD *)v44 + 2);
              *((_DWORD *)v47 + 3) = *((_DWORD *)v44 + 3);
              *((_DWORD *)v47 + 4) = *((_DWORD *)v44 + 4);
              *((_DWORD *)v47 + 5) = *((_DWORD *)v44 + 5);
              msg.source[length + 24] = 0;
              msg.length = (int)locationa;
            }
          }
        }
      }
      else
      {
        v75 = _3("Unknown", term);
        add_to_string(&msg, v75);
      }
      cachedb = current_frame(ses);
      doc_viewb = ses->tab->term;
      if ( cachedb )
      {
        add_char_to_string(&msg, 0xAu);
        current_link_info = get_current_link_info(ses, cachedb);
        if ( current_link_info )
        {
          if ( doc_viewb )
          {
            v49 = get_terminal_codepage(doc_viewb);
            if ( v49 != current_charset )
            {
              ps = (void *)v49;
              v50 = get_cp_mime_name(v49);
              bind_textdomain_codeset("elinks", v50);
              current_charset = (int)ps;
            }
          }
          v51 = gettext(&byte_812B807);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v51, (const char *)current_link_info);
          mem_free(current_link_info);
        }
        current_link_title = get_current_link_title(cachedb);
        if ( current_link_title )
        {
          if ( doc_viewb )
          {
            v53 = get_terminal_codepage(doc_viewb);
            if ( v53 != current_charset )
            {
              pt = (void *)v53;
              v54 = get_cp_mime_name(v53);
              bind_textdomain_codeset("elinks", v54);
              current_charset = (int)pt;
            }
          }
          v55 = gettext(&byte_812B3F3);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v55, (const char *)current_link_title);
          mem_free(current_link_title);
        }
        current_link_in_view = get_current_link_in_view(cachedb);
        v57 = current_link_in_view;
        if ( current_link_in_view )
        {
          if ( current_link_in_view->where_img && init_string(&string) )
          {
            add_string_uri_to_string(&string, v57->where_img, URI_PUBLIC);
            decode_uri_string_for_display(&string);
            cachedc = string.source;
            if ( doc_viewb )
            {
              v58 = get_terminal_codepage(doc_viewb);
              if ( v58 != current_charset )
              {
                pu = (void *)v58;
                v59 = get_cp_mime_name(v58);
                bind_textdomain_codeset("elinks", v59);
                current_charset = (int)pu;
              }
            }
            v60 = gettext(&byte_812B3FE);
            add_format_to_string(&msg, "\n%s: %s", (const char *)v60, (const char *)cachedc);
            done_string(&string);
          }
          v61 = get_global_history_item(v57->where);
          v62 = v61;
          if ( v61 )
          {
            v63 = ctime(&v61->last_visit);
            if ( v63 )
            {
              if ( doc_viewb )
              {
                pg = v63;
                v64 = get_terminal_codepage(doc_viewb);
                v63 = pg;
                if ( v64 != current_charset )
                {
                  v86 = v64;
                  v65 = get_cp_mime_name(v64);
                  bind_textdomain_codeset("elinks", v65);
                  current_charset = v86;
                  v63 = pg;
                }
              }
              pv = v63;
              v66 = gettext(&byte_812B409);
              add_format_to_string(&msg, "\n%s: %.24s", (const char *)v66, pv);
            }
            v67 = (const char *)v62->title;
            if ( *v67 )
            {
              if ( doc_viewb )
              {
                v68 = get_terminal_codepage(doc_viewb);
                if ( v68 != current_charset )
                {
                  pw = (void *)v68;
                  v69 = get_cp_mime_name(v68);
                  bind_textdomain_codeset("elinks", v69);
                  current_charset = (int)pw;
                }
              }
              v70 = gettext(&byte_812B429);
              add_format_to_string(&msg, "\n%s: %s", (const char *)v70, v67);
            }
          }
        }
      }
      info_box(term, MSGBOX_SCROLLABLE|MSGBOX_FREE_TEXT, "Info", ALIGN_LEFT, msg.source);
      return;
    }
    v112 = v9->length;
    if ( term )
    {
      v10 = get_terminal_codepage(term);
      if ( v10 != current_charset )
      {
        pk = (void *)v10;
        v11 = get_cp_mime_name(v10);
        bind_textdomain_codeset("elinks", v11);
        current_charset = (int)pk;
      }
    }
    v12 = gettext(&byte_8127BDB);
    add_format_to_string(&msg, "\n%s: %lld", (const char *)v12, v112);
    if ( (*((_BYTE *)cached + 92) & 8) != 0 )
    {
      if ( term )
      {
        v72 = get_terminal_codepage(term);
        if ( v72 != current_charset )
        {
          px = (void *)v72;
          v73 = get_cp_mime_name(v72);
          bind_textdomain_codeset("elinks", v73);
          current_charset = (int)px;
        }
      }
      v74 = gettext(&byte_8127C2F);
      add_format_to_string(&msg, (const unsigned __int8 *)" (%s)", (const char *)v74);
    }
    cp_name = get_cp_name(doc_view->document->cp);
    if ( term )
    {
      pa = cp_name;
      v14 = get_terminal_codepage(term);
      cp_name = pa;
      if ( v14 != current_charset )
      {
        v80 = v14;
        v15 = get_cp_mime_name(v14);
        bind_textdomain_codeset("elinks", v15);
        current_charset = v80;
        cp_name = pa;
      }
    }
    pl = (const char *)cp_name;
    v16 = gettext(&byte_812A18A);
    add_format_to_string(&msg, "\n%s: %s", (const char *)v16, pl);
    cp_status = doc_view->document->cp_status;
    if ( cp_status == CP_STATUS_ASSUMED )
    {
      v76 = term;
      v77 = "assumed";
    }
    else
    {
      if ( cp_status != CP_STATUS_IGNORED )
      {
LABEL_22:
        v18 = parse_header(cached->head, (unsigned __int8 *)&item, 0);
        v19 = v18;
        if ( v18 )
        {
          if ( term )
          {
            pb = v18;
            v20 = get_terminal_codepage(term);
            v19 = pb;
            if ( v20 != current_charset )
            {
              v81 = v20;
              v21 = get_cp_mime_name(v20);
              bind_textdomain_codeset("elinks", v21);
              current_charset = v81;
              v19 = pb;
            }
          }
          pm = (char *)v19;
          v22 = gettext(&item);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v22, pm);
          mem_free(pm);
        }
        ssl_info = cached->ssl_info;
        if ( ssl_info )
        {
          if ( term )
          {
            pc = cached->ssl_info;
            v24 = get_terminal_codepage(term);
            ssl_info = pc;
            if ( v24 != current_charset )
            {
              v82 = v24;
              v25 = get_cp_mime_name(v24);
              bind_textdomain_codeset("elinks", v25);
              current_charset = v82;
              ssl_info = pc;
            }
          }
          pn = (const char *)ssl_info;
          v26 = gettext(&byte_8127C1E);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v26, pn);
        }
        encoding_info = cached->encoding_info;
        if ( encoding_info )
        {
          if ( term )
          {
            pd = cached->encoding_info;
            v28 = get_terminal_codepage(term);
            encoding_info = pd;
            if ( v28 != current_charset )
            {
              v83 = v28;
              v29 = get_cp_mime_name(v28);
              bind_textdomain_codeset("elinks", v29);
              current_charset = v83;
              encoding_info = pd;
            }
          }
          po = (const char *)encoding_info;
          v30 = gettext(&byte_8132CF2);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v30, po);
        }
        v31 = parse_header(cached->head, (unsigned __int8 *)&byte_812B3D6, 0);
        v32 = v31;
        if ( v31 )
        {
          if ( term )
          {
            pe = v31;
            v33 = get_terminal_codepage(term);
            v32 = pe;
            if ( v33 != current_charset )
            {
              v84 = v33;
              v34 = get_cp_mime_name(v33);
              bind_textdomain_codeset("elinks", v34);
              current_charset = v84;
              v32 = pe;
            }
          }
          pp = (char *)v32;
          v35 = gettext(&byte_812B3D6);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v35, pp);
          mem_free(pp);
        }
        last_modified = cached->last_modified;
        if ( last_modified )
        {
          if ( term )
          {
            pf = cached->last_modified;
            v37 = get_terminal_codepage(term);
            last_modified = pf;
            if ( v37 != current_charset )
            {
              v85 = v37;
              v38 = get_cp_mime_name(v37);
              bind_textdomain_codeset("elinks", v38);
              current_charset = v85;
              last_modified = pf;
            }
          }
          pq = (const char *)last_modified;
          v39 = gettext(&byte_8127C0B);
          add_format_to_string(&msg, "\n%s: %s", (const char *)v39, pq);
        }
        goto LABEL_47;
      }
      v76 = term;
      v77 = "ignoring server setting";
    }
    v78 = (const char *)_3(v77, v76);
    add_format_to_string(&msg, (const unsigned __int8 *)" (%s)", v78);
    goto LABEL_22;
  }
}

//----- (08079B80) --------------------------------------------------------
void __cdecl download_abort_function(dialog_data *dlg_data)
{
  *((_DWORD *)dlg_data->dlg->udata + 27) = 0;
}

//----- (08079BA0) --------------------------------------------------------
void __cdecl lock_file_download(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (08079BB0) --------------------------------------------------------
void __cdecl unlock_file_download(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (08079BC0) --------------------------------------------------------
int __cdecl is_file_download_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (08079BE0) --------------------------------------------------------
unsigned __int8 *__cdecl get_file_download_info(listbox_item *item, terminal *term)
{
  return 0;
}

//----- (08079BF0) --------------------------------------------------------
uri *__cdecl get_file_download_uri(listbox_item *item)
{
  uri *result; // eax

  result = (uri *)*((_DWORD *)item->udata + 3);
  ++result->object.refcount;
  return result;
}

//----- (08079C10) --------------------------------------------------------
listbox_item *__cdecl get_file_download_root(listbox_item *item)
{
  return 0;
}

//----- (08079C20) --------------------------------------------------------
int __cdecl can_delete_file_download(listbox_item *item)
{
  return 1;
}

//----- (08079C30) --------------------------------------------------------
void __cdecl done_download_display(file_download *file_download)
{
  if ( file_download->box_item )
  {
    done_listbox_item(&download_browser, file_download->box_item);
    file_download->box_item = 0;
  }
}

//----- (08079C60) --------------------------------------------------------
dlg_refresh_code __cdecl refresh_file_download(dialog_data *dlg_data, void *data)
{
  return are_there_downloads() == 0 ? 3 : 0;
}

//----- (08079C80) --------------------------------------------------------
void __cdecl delete_file_download(listbox_item *item, int last)
{
  _DWORD *udata; // ebx
  int v3; // ecx

  udata = item->udata;
  if ( !assert_failed )
  {
    v3 = udata[2];
    assert_failed = v3 != 0;
    if ( v3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
      errline = 347;
      elinks_internal("assertion !is_object_used(file_download) failed!");
    }
  }
  register_bottom_half_do((select_handler_T)do_abort_download, udata);
}

//----- (08079CF0) --------------------------------------------------------
widget_handler_status_T __cdecl push_delete_button(dialog_data *dlg_data, widget_data *widget_data)
{
  _BYTE *udata; // eax

  udata = dlg_data->dlg->udata;
  udata[104] |= 1u;
  --*((_DWORD *)udata + 2);
  register_bottom_half_do((select_handler_T)do_abort_download, udata);
  return 0;
}

//----- (08079D20) --------------------------------------------------------
widget_handler_status_T __cdecl dlg_abort_download(dialog_data *dlg_data, widget_data *widget_data)
{
  _DWORD *udata; // eax

  udata = dlg_data->dlg->udata;
  --udata[2];
  register_bottom_half_do((select_handler_T)do_abort_download, udata);
  return 0;
}

//----- (08079D50) --------------------------------------------------------
widget_handler_status_T __cdecl dlg_undisplay_download(dialog_data *dlg_data, widget_data *widget_data)
{
  _DWORD *udata; // eax

  udata = dlg_data->dlg->udata;
  --udata[2];
  register_bottom_half_do((select_handler_T)undisplay_download, udata);
  return 0;
}

//----- (08079D80) --------------------------------------------------------
void __cdecl do_abort_download(file_download *file_download)
{
  list_head_elinks *next; // eax

  next = (list_head_elinks *)downloads.next;
  if ( downloads.next != &downloads )
  {
    while ( file_download != (file_download *)next )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &downloads )
        return;
    }
    *((_BYTE *)file_download + 104) |= 2u;
    abort_download(file_download);
  }
}

//----- (08079DC0) --------------------------------------------------------
unsigned __int8 *__cdecl get_file_download_text(listbox_item *item, terminal *term)
{
  unsigned __int8 *uri_string; // ebx

  uri_string = get_uri_string(*((const uri **)item->udata + 3), URI_PUBLIC);
  if ( !uri_string )
    return uri_string;
  if ( (*((_BYTE *)term + 56) & 2) == 0 )
  {
    decode_uri_for_display(uri_string);
    return uri_string;
  }
  decode_uri(uri_string);
  return uri_string;
}

//----- (08079E10) --------------------------------------------------------
void __cdecl draw_file_download(listbox_item *item, listbox_context *context, int x, int y, int width)
{
  unsigned __int8 *v5; // eax
  unsigned __int8 *file_download_text; // eax
  unsigned __int8 *v7; // esi
  int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  dialog_data *dlg_data; // edx
  dialog_refresh *refresh; // eax
  int v14; // [esp+2Ch] [ebp-2Ch]
  int v15; // [esp+2Ch] [ebp-2Ch]
  color_pair *color; // [esp+34h] [ebp-24h]
  void *udata; // [esp+3Ch] [ebp-1Ch]

  udata = item->udata;
  if ( width > 3 )
  {
    v5 = "menu.selected";
    if ( context->box->sel != item )
    {
      v5 = "menu.normal";
      if ( (*((_BYTE *)item + 24) & 4) != 0 )
        v5 = "menu.marked";
    }
    color = get_bfu_color(context->term, v5);
    file_download_text = get_file_download_text(item, context->term);
    v7 = file_download_text;
    if ( file_download_text )
    {
      v8 = width - 19;
      v9 = strlen((const char *)file_download_text);
      if ( 50 * v9 / 100 >= width - 19 )
      {
        v8 = width - 3;
        if ( v9 < width - 3 )
          goto LABEL_8;
      }
      else if ( v9 < v8 )
      {
LABEL_8:
        v14 = v9;
        draw_text(context->term, x, y, v7, v9, (screen_char_attr)0, color);
        v8 = v14;
LABEL_9:
        mem_free(v7);
        v10 = *((_DWORD *)udata + 20);
        if ( v10 && *(int *)(v10 + 48) >= 0 && *((_DWORD *)udata + 21) == 8 && has_progress(*((progress **)udata + 20)) )
        {
          dlg_data = context->dlg_data;
          refresh = dlg_data->dlg->refresh;
          if ( !refresh || !refresh->timer )
            refresh_dialog(dlg_data, refresh_file_download, 0);
          if ( width > v8 + 15 )
            draw_progress_bar(*((progress **)udata + 20), context->term, x + width - 15, y, 15, 0, 0);
        }
        return;
      }
      v15 = v9;
      draw_text(context->term, x, y, v7, v8, (screen_char_attr)0, color);
      if ( v8 < v15 )
      {
        v11 = v8 + x;
        v8 += 3;
        draw_text(context->term, v11, y, (unsigned __int8 *)&bytes, 3, (screen_char_attr)0, color);
      }
      goto LABEL_9;
    }
  }
}

//----- (0807A030) --------------------------------------------------------
void __cdecl init_download_display(file_download *file_download)
{
  file_download->box_item = add_listbox_item(&download_browser, 0, BI_LEAF, file_download, 1);
}

//----- (0807A070) --------------------------------------------------------
void __cdecl download_manager(session *ses)
{
  hierbox_browser_0(&download_browser, ses);
  *((_BYTE *)&download_browser + 96) |= 1u;
}

//----- (0807A0A0) --------------------------------------------------------
void __cdecl undisplay_download(file_download *file_download)
{
  list_head_elinks *next; // eax
  dialog_data *dlg_data; // eax

  next = (list_head_elinks *)downloads.next;
  if ( downloads.next != &downloads )
  {
    while ( file_download != (file_download *)next )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &downloads )
        return;
    }
    dlg_data = file_download->dlg_data;
    if ( dlg_data )
      cancel_dialog(dlg_data, 0);
  }
}

//----- (0807A0E0) --------------------------------------------------------
widget_handler_status_T __cdecl dlg_set_notify(dialog_data *dlg_data, widget_data *widget_data)
{
  file_download *udata; // eax

  udata = (file_download *)dlg_data->dlg->udata;
  udata->notify = 1;
  undisplay_download(udata);
  return 0;
}

//----- (0807A110) --------------------------------------------------------
void __cdecl download_dialog_layouter(dialog_data *dlg_data)
{
  terminal *term; // esi
  int width; // ecx
  int v3; // edi
  int v4; // edx
  int v5; // ecx
  int v6; // edi
  int v7; // eax
  color_pair *dialog_text_color; // [esp+44h] [ebp-44h]
  unsigned __int8 *msg; // [esp+48h] [ebp-40h]
  file_download *file_download; // [esp+4Ch] [ebp-3Ch]
  int x; // [esp+50h] [ebp-38h]
  int xa; // [esp+50h] [ebp-38h]
  int show_meter; // [esp+54h] [ebp-34h]
  unsigned __int8 *download; // [esp+5Ch] [ebp-2Ch]
  int y; // [esp+68h] [ebp-20h] BYREF
  int rw[7]; // [esp+6Ch] [ebp-1Ch] BYREF

  file_download = (file_download *)dlg_data->dlg->udata;
  term = dlg_data->win->term;
  width = term->width;
  v3 = 1;
  v4 = 9 * width / 10 - 12;
  if ( v4 > 0 )
  {
    v5 = width - 12;
    if ( v5 > 0 )
      v3 = v5;
    if ( v4 <= v3 )
      v3 = v4;
  }
  rw[0] = v3;
  y = 0;
  dialog_text_color = get_bfu_color(term, "dialog.text");
  msg = get_download_msg(&file_download->download, term, 1, 1, (unsigned __int8 *)"\n");
  show_meter = 0;
  if ( download_is_progressing(&file_download->download) )
    show_meter = file_download->download.progress->size >= 0;
  redraw_below_window(dlg_data->win);
  file_download->dlg_data = dlg_data;
  if ( msg )
  {
    download = get_uri_string(file_download->uri, URI_PUBLIC);
    if ( download )
    {
      if ( (*((_BYTE *)term + 56) & 2) != 0 )
        decode_uri(download);
      else
        decode_uri_for_display(download);
      x = strlen((const char *)download);
      if ( show_meter )
      {
        if ( v3 <= 19 )
          v3 = 20;
        dlg_format_text_do(term, download, 0, &y, v3, rw, dialog_text_color, ALIGN_LEFT, 1);
        y += 3;
      }
      else
      {
        dlg_format_text_do(term, download, 0, &y, v3, rw, dialog_text_color, ALIGN_LEFT, 1);
        ++y;
      }
      dlg_format_text_do(term, msg, 0, &y, v3, rw, dialog_text_color, ALIGN_LEFT, 1);
      ++y;
      dlg_format_buttons(term, dlg_data->widgets_data, dlg_data->number_of_widgets, 0, &y, v3, rw, ALIGN_CENTER, 1);
      draw_dialog(dlg_data, v3, y);
      v6 = rw[0];
      if ( x > rw[0] )
      {
        download[rw[0]] = 0;
        if ( v6 > 4 )
        {
          download[v6 - 1] = 46;
          download[v6 - 2] = 46;
          download[v6 - 3] = 46;
        }
      }
      y = dlg_data->box.y + 3;
      xa = dlg_data->box.x + 6;
      dlg_format_text_do(term, download, xa, &y, v6, 0, dialog_text_color, ALIGN_LEFT, 0);
      if ( show_meter )
      {
        draw_progress_bar(file_download->download.progress, term, xa, ++y, v6, 0, 0);
        v7 = y + 1;
      }
      else
      {
        v7 = y;
      }
      y = v7 + 1;
      dlg_format_text_do(term, msg, xa, &y, v6, 0, dialog_text_color, ALIGN_LEFT, 0);
      ++y;
      dlg_format_buttons(term, dlg_data->widgets_data, dlg_data->number_of_widgets, xa, &y, v6, 0, ALIGN_CENTER, 0);
      mem_free(download);
    }
    mem_free(msg);
  }
}

//----- (0807A520) --------------------------------------------------------
void __cdecl display_download(terminal *term, file_download *file_download, session *ses)
{
  list_head_elinks *next; // eax
  dialog *v4; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  int v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // eax
  int v13; // eax
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // eax
  bool v16; // zf
  memory_list *v17; // eax
  int v18; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // [esp+28h] [ebp-20h]
  int v22; // [esp+28h] [ebp-20h]
  int v23; // [esp+28h] [ebp-20h]
  int v24; // [esp+28h] [ebp-20h]
  int v25; // [esp+28h] [ebp-20h]

  next = (list_head_elinks *)downloads.next;
  if ( downloads.next != &downloads )
  {
    while ( file_download != (file_download *)next )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &downloads )
        return;
    }
    v4 = (dialog *)mem_calloc(1u, 0xE4u);
    if ( v4 )
    {
      undisplay_download(file_download);
      file_download->ses = ses;
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        if ( terminal_codepage != current_charset )
        {
          v21 = terminal_codepage;
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v21;
        }
      }
      v4->title = gettext(&byte_812B447);
      v4->layouter = download_dialog_layouter;
      v4->abort = download_abort_function;
      v4->udata = file_download;
      ++file_download->object.refcount;
      if ( term )
      {
        v7 = get_terminal_codepage(term);
        if ( v7 != current_charset )
        {
          v22 = v7;
          v8 = get_cp_mime_name(v7);
          bind_textdomain_codeset("elinks", v8);
          current_charset = v22;
        }
      }
      v9 = gettext(&byte_812B450);
      add_dlg_button_do(v4, v9, 3, dlg_undisplay_download, 0, 0, 0);
      if ( term )
      {
        v10 = get_terminal_codepage(term);
        if ( v10 != current_charset )
        {
          v23 = v10;
          v11 = get_cp_mime_name(v10);
          bind_textdomain_codeset("elinks", v11);
          current_charset = v23;
        }
      }
      v12 = gettext(&byte_812B45C);
      add_dlg_button_do(v4, v12, 3, dlg_set_notify, 0, 0, 0);
      if ( term )
      {
        v13 = get_terminal_codepage(term);
        if ( v13 != current_charset )
        {
          v24 = v13;
          v14 = get_cp_mime_name(v13);
          bind_textdomain_codeset("elinks", v14);
          current_charset = v24;
        }
      }
      v15 = gettext(&byte_812B474);
      add_dlg_button_do(v4, v15, 0, dlg_abort_download, 0, 0, 0);
      if ( !file_download->external_handler )
      {
        if ( term )
        {
          v18 = get_terminal_codepage(term);
          if ( v18 != current_charset )
          {
            v25 = v18;
            v19 = get_cp_mime_name(v18);
            bind_textdomain_codeset("elinks", v19);
            current_charset = v25;
          }
        }
        v20 = gettext(&byte_812B47B);
        add_dlg_button_do(v4, v20, 0, push_delete_button, 0, 0, 0);
      }
      if ( !assert_failed )
      {
        v16 = 4 - (file_download->external_handler != 0) == v4->number_of_widgets;
        assert_failed = 4 - (file_download->external_handler != 0) != v4->number_of_widgets;
        if ( !v16 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
          errline = 270;
          elinks_internal("assertion 4 - !!file_download->external_handler == (dlg)->number_of_widgets failed!");
        }
      }
      v17 = getml(v4, 0);
      do_dialog(term, v4, v17);
    }
  }
}

//----- (0807A890) --------------------------------------------------------
widget_handler_status_T __cdecl push_info_button(dialog_data *dlg_data, widget_data *button)
{
  file_download *v2; // esi
  listbox_data *listbox_widget_data; // eax
  listbox_item *sel; // eax
  session *udata; // edi
  terminal *term; // [esp+1Ch] [ebp-1Ch]

  v2 = 0;
  listbox_widget_data = get_listbox_widget_data(dlg_data->widgets_data);
  term = dlg_data->win->term;
  sel = listbox_widget_data->sel;
  udata = (session *)dlg_data->dlg->udata;
  if ( sel )
    v2 = (file_download *)sel->udata;
  if ( !assert_failed )
  {
    assert_failed = udata == 0;
    if ( !udata )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/download.c";
      errline = 472;
      elinks_internal("assertion ses failed!");
    }
  }
  if ( v2 )
  {
    delete_window(dlg_data->win);
    display_download(term, v2, udata);
  }
  return 0;
}

//----- (0807A940) --------------------------------------------------------
widget_handler_status_T __cdecl my_cancel_dialog(dialog_data *dlg_data, widget_data *widget_data)
{
  ((void (__cdecl *)(dialog *))widget_data->widget->data)(dlg_data->dlg);
  return cancel_dialog(dlg_data, widget_data);
}

//----- (0807A980) --------------------------------------------------------
void __cdecl do_edit_dialog(
        terminal *term,
        int intl,
        unsigned __int8 *title,
        const unsigned __int8 *src_name,
        const unsigned __int8 *src_url,
        session *ses,
        dialog_data *parent,
        done_handler_T *when_done,
        void (*when_cancel)(dialog *),
        void *done_data,
        edit_dialog_type dialog_type)
{
  unsigned __int8 *v11; // edi
  const unsigned __int8 *v12; // edx
  char *v13; // eax
  dialog *v14; // ebx
  int v15; // eax
  int v16; // edi
  unsigned __int8 *v17; // eax
  unsigned __int8 *v18; // eax
  int v19; // eax
  int v20; // edi
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // eax
  int v23; // eax
  int v24; // edi
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  int v27; // eax
  int v28; // edi
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // eax
  int v31; // eax
  int v32; // edi
  unsigned __int8 *v33; // eax
  unsigned __int8 *v34; // eax
  bool v35; // zf
  memory_list *v36; // eax
  int terminal_codepage; // eax
  int v38; // ebx
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v40; // eax
  int v41; // eax
  int v42; // edi
  unsigned __int8 *v43; // eax
  unsigned __int8 *v44; // eax
  int v45; // eax
  int v46; // edi
  unsigned __int8 *v47; // eax
  unsigned __int8 *v48; // eax
  unsigned __int8 *src; // [esp+38h] [ebp-40h]
  unsigned __int8 *srca; // [esp+38h] [ebp-40h]
  unsigned __int8 *name; // [esp+58h] [ebp-20h]
  unsigned __int8 *url; // [esp+5Ch] [ebp-1Ch]

  v11 = title;
  v12 = src_name;
  if ( intl && title && *title )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v12 = src_name;
      v38 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v38;
        v12 = src_name;
      }
    }
    srca = (unsigned __int8 *)v12;
    v40 = gettext(title);
    v12 = srca;
    v11 = v40;
  }
  src = (unsigned __int8 *)v12;
  v13 = (char *)mem_calloc(1u, 0x914u);
  v14 = (dialog *)v13;
  if ( v13 )
  {
    name = (unsigned __int8 *)(v13 + 276);
    url = (unsigned __int8 *)(v13 + 1300);
    if ( src )
    {
      safe_strncpy(name, src, 0x400u);
      if ( src_url )
      {
LABEL_5:
        safe_strncpy(url, src_url, 0x400u);
LABEL_6:
        *(_BYTE *)&v14->layout |= 1u;
        v14->title = v11;
        v14->layouter = generic_dialog_layouter;
        v14->udata = parent;
        v14->udata2 = done_data;
        if ( dialog_type == EDIT_DLG_ADD )
        {
          if ( term )
          {
            v41 = get_terminal_codepage(term);
            v42 = v41;
            if ( v41 != current_charset )
            {
              v43 = get_cp_mime_name(v41);
              bind_textdomain_codeset("elinks", v43);
              current_charset = v42;
            }
          }
          v44 = gettext(&str);
          add_dlg_field_do(v14, WIDGET_FIELD, v44, 0, 0, check_nonempty, 1024, name, 0, INPFIELD_NONE);
        }
        else
        {
          if ( term )
          {
            v15 = get_terminal_codepage(term);
            v16 = v15;
            if ( v15 != current_charset )
            {
              v17 = get_cp_mime_name(v15);
              bind_textdomain_codeset("elinks", v17);
              current_charset = v16;
            }
          }
          v18 = gettext(&str);
          add_dlg_field_do(v14, WIDGET_FIELD, v18, 0, 0, 0, 1024, name, 0, INPFIELD_NONE);
        }
        if ( term )
        {
          v19 = get_terminal_codepage(term);
          v20 = v19;
          if ( v19 != current_charset )
          {
            v21 = get_cp_mime_name(v19);
            bind_textdomain_codeset("elinks", v21);
            current_charset = v20;
          }
        }
        v22 = gettext(&byte_812B6C9);
        add_dlg_field_do(v14, WIDGET_FIELD, v22, 0, 0, 0, 1024, url, 0, INPFIELD_NONE);
        if ( term )
        {
          v23 = get_terminal_codepage(term);
          v24 = v23;
          if ( v23 != current_charset )
          {
            v25 = get_cp_mime_name(v23);
            bind_textdomain_codeset("elinks", v25);
            current_charset = v24;
          }
        }
        v26 = gettext(&okbutton);
        add_dlg_button_do(v14, v26, 1, ok_dialog, 0, when_done, v14);
        if ( term )
        {
          v27 = get_terminal_codepage(term);
          v28 = v27;
          if ( v27 != current_charset )
          {
            v29 = get_cp_mime_name(v27);
            bind_textdomain_codeset("elinks", v29);
            current_charset = v28;
          }
        }
        v30 = gettext(&byte_812B311);
        add_dlg_button_do(v14, v30, 0, clear_dialog, 0, 0, 0);
        if ( when_cancel )
        {
          if ( term )
          {
            v31 = get_terminal_codepage(term);
            v32 = v31;
            if ( v31 != current_charset )
            {
              v33 = get_cp_mime_name(v31);
              bind_textdomain_codeset("elinks", v33);
              current_charset = v32;
            }
          }
          v34 = gettext(&cancelbutton);
          add_dlg_button_do(v14, v34, 2, my_cancel_dialog, when_cancel, 0, 0);
        }
        else
        {
          if ( term )
          {
            v45 = get_terminal_codepage(term);
            v46 = v45;
            if ( v45 != current_charset )
            {
              v47 = get_cp_mime_name(v45);
              bind_textdomain_codeset("elinks", v47);
              current_charset = v46;
            }
          }
          v48 = gettext(&cancelbutton);
          add_dlg_button_do(v14, v48, 2, cancel_dialog, 0, 0, 0);
        }
        if ( !assert_failed )
        {
          v35 = v14->number_of_widgets == 5;
          assert_failed = v14->number_of_widgets != 5;
          if ( !v35 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/edit.c";
            errline = 108;
            elinks_internal("assertion 5 == (dlg)->number_of_widgets failed!");
          }
        }
        v36 = getml(v14, 0);
        do_dialog(term, v14, v36);
        return;
      }
    }
    else
    {
      get_current_title(ses, name, 0x400u);
      if ( src_url )
        goto LABEL_5;
    }
    get_current_url(ses, url, 0x400u);
    goto LABEL_6;
  }
}

//----- (0807AF50) --------------------------------------------------------
void __cdecl resource_info(terminal *term)
{
  refreshed_msg_box(term, (msgbox_flags)0, (unsigned __int8 *)&byte_812B51E, ALIGN_LEFT, get_resource_info, 0);
}

//----- (0807AF90) --------------------------------------------------------
void __cdecl menu_copying(terminal *term, void *xxx, void *xxxx)
{
  unsigned __int8 *v3; // eax

  v3 = msg_text(
         term,
         "ELinks %s\n"
         "\n"
         "%set al.\n"
         "\n"
         "This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Publ"
         "ic License as published by the Free Software Foundation, specifically version 2 of the License.",
         "0.12pre5",
         "(C) 1999 - 2002 Mikulas Patocka\n(C) 2001 - 2004 Petr Baudis\n(C) 2002 - 2007 Jonas Fonseca\n");
  info_box(term, MSGBOX_FREE_TEXT, "Copying", ALIGN_CENTER, v3);
}

//----- (0807AFF0) --------------------------------------------------------
void __cdecl menu_keys(terminal *term, void *d_, void *xxx)
{
  action_id_T i; // eax
  int v4; // edi
  keymap_id j; // esi
  keymap_id v6; // edx
  unsigned __int8 *source; // ebx
  memory_list *v8; // [esp+4h] [ebp-254h]
  keys_toggle_info *info; // [esp+4Ch] [ebp-20Ch]
  action_id_T action_ids[119]; // [esp+5Ch] [ebp-1FCh] BYREF
  string keys; // [esp+238h] [ebp-20h] BYREF

  memset(action_ids, 0, sizeof(action_ids));
  action_ids[0] = 48;
  action_ids[1] = 76;
  action_ids[2] = 60;
  action_ids[3] = 61;
  action_ids[4] = 87;
  action_ids[5] = 90;
  action_ids[6] = 88;
  action_ids[7] = 89;
  action_ids[8] = 32;
  action_ids[9] = 26;
  action_ids[10] = 27;
  action_ids[11] = 14;
  action_ids[12] = 30;
  action_ids[13] = 91;
  action_ids[14] = 92;
  action_ids[15] = 18;
  action_ids[16] = 19;
  action_ids[17] = 41;
  action_ids[18] = 37;
  action_ids[19] = 113;
  info = (keys_toggle_info *)mem_calloc(1u, 8u);
  if ( info )
  {
    if ( init_string(&keys) )
    {
      info->term = term;
      info->toggle = (int)d_;
      if ( d_ )
      {
        for ( i = 0; i != 118; action_ids[i - 1] = i )
          ++i;
        v4 = 0;
        for ( j = KEYMAP_MAIN; ; j = v6 )
        {
          add_actions_to_string(&keys, action_ids, j, term);
          v6 = j + 1;
          if ( j != KEYMAP_MENU )
          {
            add_to_string(&keys, &ptr);
            v6 = j + 1;
          }
          if ( !assert_failed )
            assert_failed = 0;
          if ( j == KEYMAP_MAIN )
            break;
          if ( j != KEYMAP_EDIT )
            goto LABEL_8;
          ++v4;
          action_ids[21] = 0;
          if ( v4 == 3 )
            goto LABEL_17;
LABEL_9:
          ;
        }
        action_ids[30] = 0;
LABEL_8:
        if ( ++v4 == 3 )
          goto LABEL_17;
        goto LABEL_9;
      }
      add_actions_to_string(&keys, action_ids, KEYMAP_MAIN, term);
LABEL_17:
      source = keys.source;
      v8 = getml(info, 0);
      msg_box(
        term,
        v8,
        MSGBOX_SCROLLABLE|MSGBOX_FREE_TEXT,
        "Keys",
        ALIGN_LEFT,
        source,
        info,
        2,
        &okbutton,
        0,
        3,
        "~Toggle display",
        push_toggle_keys_display_button,
        1);
    }
    else
    {
      mem_free(info);
    }
  }
}

//----- (0807B2A0) --------------------------------------------------------
void __cdecl push_toggle_keys_display_button(void *data)
{
  menu_keys(*(terminal **)data, (void *)(*((_DWORD *)data + 1) == 0), 0);
}

//----- (0807B2D0) --------------------------------------------------------
void __cdecl menu_about(terminal *term, void *xxx, void *xxxx)
{
  unsigned __int8 *dyn_full_version; // eax

  dyn_full_version = get_dyn_full_version(term, 1);
  info_box(term, MSGBOX_FREE_TEXT, "About", ALIGN_CENTER, dyn_full_version);
}

//----- (0807B320) --------------------------------------------------------
unsigned __int8 *__cdecl get_resource_info(terminal *term, void *data)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  int terminal_codepage; // eax
  int v5; // edi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v7; // eax
  unsigned int file_handles_count; // edi
  int v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  unsigned int timers_count; // edi
  int v13; // eax
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // eax
  int v16; // eax
  int v17; // edi
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // eax
  unsigned int connections_count; // edi
  int v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // eax
  unsigned int connections_connecting_count; // edi
  int v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // eax
  unsigned int connections_transfering_count; // edi
  int v29; // eax
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // eax
  unsigned int keepalive_connections_count; // edi
  int v33; // eax
  unsigned __int8 *v34; // eax
  unsigned __int8 *v35; // eax
  int v36; // eax
  int v37; // edi
  unsigned __int8 *v38; // eax
  unsigned __int8 *v39; // eax
  unsigned __int64 cache_size; // rax
  unsigned int v41; // edi
  unsigned __int8 *v42; // eax
  unsigned __int8 *v43; // eax
  unsigned int cache_entry_count; // edi
  int v45; // eax
  unsigned __int8 *v46; // eax
  unsigned __int8 *v47; // eax
  unsigned int cache_entry_used_count; // edx
  int v49; // eax
  unsigned __int8 *v50; // eax
  unsigned __int8 *v51; // eax
  unsigned int cache_entry_loading_count; // edx
  int v53; // eax
  unsigned __int8 *v54; // eax
  unsigned __int8 *v55; // eax
  int v56; // eax
  unsigned __int8 *v57; // eax
  unsigned __int8 *v58; // eax
  unsigned int format_cache_size; // edx
  int v60; // eax
  unsigned __int8 *v61; // eax
  unsigned __int8 *v62; // eax
  int format_cache_used_count; // eax
  unsigned int v64; // edx
  int v65; // eax
  int v66; // edi
  unsigned __int8 *v67; // eax
  unsigned __int8 *v68; // eax
  unsigned int format_cache_refresh_count; // edi
  int v70; // eax
  unsigned __int8 *v71; // eax
  unsigned __int8 *v72; // eax
  int v73; // eax
  int v74; // edi
  unsigned __int8 *v75; // eax
  unsigned __int8 *v76; // eax
  int v77; // eax
  int v78; // edi
  unsigned __int8 *v79; // eax
  unsigned __int8 *v80; // eax
  unsigned int v81; // edi
  list_head_elinks *next; // eax
  unsigned int v83; // edx
  int v84; // eax
  unsigned int v85; // edx
  unsigned __int8 *v86; // eax
  unsigned __int8 *v87; // eax
  unsigned int v88; // edi
  list_head_elinks *v89; // eax
  unsigned int v90; // edx
  int v91; // eax
  unsigned int v92; // edx
  int v93; // esi
  unsigned __int8 *v94; // eax
  unsigned __int8 *v95; // eax
  int v96; // eax
  int v97; // edi
  unsigned __int8 *v98; // eax
  unsigned int v99; // [esp+8h] [ebp-40h]
  int v100; // [esp+18h] [ebp-30h]
  int v101; // [esp+18h] [ebp-30h]
  int v102; // [esp+18h] [ebp-30h]
  int v103; // [esp+18h] [ebp-30h]
  int v104; // [esp+18h] [ebp-30h]
  unsigned int ng; // [esp+1Ch] [ebp-2Ch]
  unsigned int nh; // [esp+1Ch] [ebp-2Ch]
  unsigned int ni; // [esp+1Ch] [ebp-2Ch]
  unsigned int nj; // [esp+1Ch] [ebp-2Ch]
  unsigned int nk; // [esp+1Ch] [ebp-2Ch]
  unsigned int nl; // [esp+1Ch] [ebp-2Ch]
  unsigned int n; // [esp+1Ch] [ebp-2Ch]
  unsigned int nm; // [esp+1Ch] [ebp-2Ch]
  unsigned int nn; // [esp+1Ch] [ebp-2Ch]
  unsigned int na; // [esp+1Ch] [ebp-2Ch]
  unsigned int no; // [esp+1Ch] [ebp-2Ch]
  unsigned int nb; // [esp+1Ch] [ebp-2Ch]
  unsigned int np; // [esp+1Ch] [ebp-2Ch]
  unsigned int nq; // [esp+1Ch] [ebp-2Ch]
  unsigned int nc; // [esp+1Ch] [ebp-2Ch]
  unsigned int nr; // [esp+1Ch] [ebp-2Ch]
  unsigned int nd; // [esp+1Ch] [ebp-2Ch]
  unsigned int ns; // [esp+1Ch] [ebp-2Ch]
  unsigned int nt; // [esp+1Ch] [ebp-2Ch]
  unsigned int ne; // [esp+1Ch] [ebp-2Ch]
  unsigned int nf; // [esp+1Ch] [ebp-2Ch]
  string info; // [esp+28h] [ebp-20h] BYREF

  inited = init_string(&info);
  result = 0;
  if ( inited )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v5 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v5;
      }
    }
    v7 = gettext(&byte_812B51E);
    add_to_string(&info, v7);
    add_to_string(&info, ": ");
    file_handles_count = get_file_handles_count();
    if ( term )
    {
      v9 = get_terminal_codepage(term);
      if ( v9 != current_charset )
      {
        ng = v9;
        v10 = get_cp_mime_name(v9);
        bind_textdomain_codeset("elinks", v10);
        current_charset = ng;
      }
    }
    v11 = ngettext(&msgid1, "%ld handles", file_handles_count);
    add_format_to_string(&info, v11, file_handles_count);
    add_to_string(&info, ", ");
    timers_count = get_timers_count();
    if ( term )
    {
      v13 = get_terminal_codepage(term);
      if ( v13 != current_charset )
      {
        nh = v13;
        v14 = get_cp_mime_name(v13);
        bind_textdomain_codeset("elinks", v14);
        current_charset = nh;
      }
    }
    v15 = ngettext(&byte_812B53F, "%ld timers", timers_count);
    add_format_to_string(&info, v15, timers_count);
    add_to_string(&info, ".\n");
    if ( term )
    {
      v16 = get_terminal_codepage(term);
      v17 = v16;
      if ( v16 != current_charset )
      {
        v18 = get_cp_mime_name(v16);
        bind_textdomain_codeset("elinks", v18);
        current_charset = v17;
      }
    }
    v19 = gettext(&byte_81296C1);
    add_to_string(&info, v19);
    add_to_string(&info, ": ");
    connections_count = get_connections_count();
    if ( term )
    {
      v21 = get_terminal_codepage(term);
      if ( v21 != current_charset )
      {
        ni = v21;
        v22 = get_cp_mime_name(v21);
        bind_textdomain_codeset("elinks", v22);
        current_charset = ni;
      }
    }
    v23 = ngettext(&byte_812B557, "%ld connections", connections_count);
    add_format_to_string(&info, v23, connections_count);
    add_to_string(&info, ", ");
    connections_connecting_count = get_connections_connecting_count();
    if ( term )
    {
      v25 = get_terminal_codepage(term);
      if ( v25 != current_charset )
      {
        nj = v25;
        v26 = get_cp_mime_name(v25);
        bind_textdomain_codeset("elinks", v26);
        current_charset = nj;
      }
    }
    v27 = ngettext(&byte_812B576, &byte_812B576, connections_connecting_count);
    add_format_to_string(&info, v27, connections_connecting_count);
    add_to_string(&info, ", ");
    connections_transfering_count = get_connections_transfering_count();
    if ( term )
    {
      v29 = get_terminal_codepage(term);
      if ( v29 != current_charset )
      {
        nk = v29;
        v30 = get_cp_mime_name(v29);
        bind_textdomain_codeset("elinks", v30);
        current_charset = nk;
      }
    }
    v31 = ngettext(&byte_812B585, &byte_812B585, connections_transfering_count);
    add_format_to_string(&info, v31, connections_transfering_count);
    add_to_string(&info, ", ");
    keepalive_connections_count = get_keepalive_connections_count();
    if ( term )
    {
      v33 = get_terminal_codepage(term);
      if ( v33 != current_charset )
      {
        nl = v33;
        v34 = get_cp_mime_name(v33);
        bind_textdomain_codeset("elinks", v34);
        current_charset = nl;
      }
    }
    v35 = ngettext(&byte_812B596, &byte_812B596, keepalive_connections_count);
    add_format_to_string(&info, v35, keepalive_connections_count);
    add_to_string(&info, ".\n");
    if ( term )
    {
      v36 = get_terminal_codepage(term);
      v37 = v36;
      if ( v36 != current_charset )
      {
        v38 = get_cp_mime_name(v36);
        bind_textdomain_codeset("elinks", v38);
        current_charset = v37;
      }
    }
    v39 = gettext(&byte_8129ED7);
    add_to_string(&info, v39);
    add_to_string(&info, ": ");
    cache_size = get_cache_size();
    v41 = cache_size;
    if ( term )
    {
      n = HIDWORD(cache_size);
      cache_size = __PAIR64__(n, get_terminal_codepage(term));
      if ( (_DWORD)cache_size != current_charset )
      {
        v100 = cache_size;
        v42 = get_cp_mime_name(cache_size);
        bind_textdomain_codeset("elinks", v42);
        HIDWORD(cache_size) = n;
        current_charset = v100;
      }
    }
    nm = HIDWORD(cache_size);
    v43 = ngettext(&byte_812B5A4, "%ld bytes", v41);
    add_format_to_string(&info, v43, v41, nm);
    add_to_string(&info, ", ");
    cache_entry_count = get_cache_entry_count();
    if ( term )
    {
      v45 = get_terminal_codepage(term);
      if ( v45 != current_charset )
      {
        nn = v45;
        v46 = get_cp_mime_name(v45);
        bind_textdomain_codeset("elinks", v46);
        current_charset = nn;
      }
    }
    v47 = ngettext(&byte_812B5B7, "%ld files", cache_entry_count);
    add_format_to_string(&info, v47, cache_entry_count);
    add_to_string(&info, ", ");
    cache_entry_used_count = get_cache_entry_used_count();
    if ( term )
    {
      na = cache_entry_used_count;
      v49 = get_terminal_codepage(term);
      cache_entry_used_count = na;
      if ( v49 != current_charset )
      {
        v101 = v49;
        v50 = get_cp_mime_name(v49);
        bind_textdomain_codeset("elinks", v50);
        cache_entry_used_count = na;
        current_charset = v101;
      }
    }
    no = cache_entry_used_count;
    v51 = ngettext(&byte_812B5CA, &byte_812B5CA, cache_entry_used_count);
    add_format_to_string(&info, v51, no);
    add_to_string(&info, ", ");
    cache_entry_loading_count = get_cache_entry_loading_count();
    if ( term )
    {
      nb = cache_entry_loading_count;
      v53 = get_terminal_codepage(term);
      cache_entry_loading_count = nb;
      if ( v53 != current_charset )
      {
        v102 = v53;
        v54 = get_cp_mime_name(v53);
        bind_textdomain_codeset("elinks", v54);
        cache_entry_loading_count = nb;
        current_charset = v102;
      }
    }
    np = cache_entry_loading_count;
    v55 = ngettext(&byte_812B5D5, &byte_812B5D5, cache_entry_loading_count);
    add_format_to_string(&info, v55, np);
    add_to_string(&info, ".\n");
    if ( term )
    {
      v56 = get_terminal_codepage(term);
      if ( v56 != current_charset )
      {
        nq = v56;
        v57 = get_cp_mime_name(v56);
        bind_textdomain_codeset("elinks", v57);
        current_charset = nq;
      }
    }
    v58 = gettext(&byte_812B5E1);
    add_to_string(&info, v58);
    add_to_string(&info, ": ");
    format_cache_size = get_format_cache_size();
    if ( term )
    {
      nc = format_cache_size;
      v60 = get_terminal_codepage(term);
      format_cache_size = nc;
      if ( v60 != current_charset )
      {
        v103 = v60;
        v61 = get_cp_mime_name(v60);
        bind_textdomain_codeset("elinks", v61);
        format_cache_size = nc;
        current_charset = v103;
      }
    }
    nr = format_cache_size;
    v62 = ngettext(&byte_812B5F0, &byte_812B5F0, format_cache_size);
    add_format_to_string(&info, v62, nr);
    add_to_string(&info, ", ");
    format_cache_used_count = get_format_cache_used_count();
    v64 = format_cache_used_count;
    if ( term )
    {
      nd = format_cache_used_count;
      v65 = get_terminal_codepage(term);
      v64 = nd;
      v66 = v65;
      if ( v65 != current_charset )
      {
        v67 = get_cp_mime_name(v65);
        bind_textdomain_codeset("elinks", v67);
        v64 = nd;
        current_charset = v66;
      }
    }
    ns = v64;
    v68 = ngettext(&byte_812B5CA, &byte_812B5CA, v64);
    add_format_to_string(&info, v68, ns);
    add_to_string(&info, ", ");
    format_cache_refresh_count = get_format_cache_refresh_count();
    if ( term )
    {
      v70 = get_terminal_codepage(term);
      if ( v70 != current_charset )
      {
        nt = v70;
        v71 = get_cp_mime_name(v70);
        bind_textdomain_codeset("elinks", v71);
        current_charset = nt;
      }
    }
    v72 = ngettext(&byte_812B5FE, &byte_812B5FE, format_cache_refresh_count);
    add_format_to_string(&info, v72, format_cache_refresh_count);
    add_to_string(&info, ".\n");
    if ( term )
    {
      v73 = get_terminal_codepage(term);
      v74 = v73;
      if ( v73 != current_charset )
      {
        v75 = get_cp_mime_name(v73);
        bind_textdomain_codeset("elinks", v75);
        current_charset = v74;
      }
    }
    v76 = gettext(&byte_812B60D);
    add_to_string(&info, v76);
    add_to_string(&info, ": ");
    if ( (*((_BYTE *)term + 56) & 1) != 0 )
    {
      v77 = get_terminal_codepage(term);
      v78 = v77;
      if ( v77 != current_charset )
      {
        v79 = get_cp_mime_name(v77);
        bind_textdomain_codeset("elinks", v79);
        current_charset = v78;
      }
      v80 = gettext(&byte_812B61A);
    }
    else
    {
      v96 = get_terminal_codepage(term);
      v97 = v96;
      if ( v96 != current_charset )
      {
        v98 = get_cp_mime_name(v96);
        bind_textdomain_codeset("elinks", v98);
        current_charset = v97;
      }
      v80 = gettext(&byte_812B62A);
    }
    v81 = 0;
    add_to_string(&info, v80);
    add_to_string(&info, ", ");
    next = (list_head_elinks *)terminals.next;
    v83 = 0;
    if ( terminals.next != &terminals )
    {
      do
      {
        next = (list_head_elinks *)next->next;
        ++v81;
      }
      while ( next != &terminals );
      v83 = v81;
    }
    ne = v83;
    v84 = get_terminal_codepage(term);
    v85 = ne;
    if ( v84 != current_charset )
    {
      v104 = v84;
      v86 = get_cp_mime_name(v84);
      bind_textdomain_codeset("elinks", v86);
      v85 = ne;
      current_charset = v104;
    }
    v87 = ngettext(&byte_812B639, "%ld terminals", v85);
    v99 = v81;
    v88 = 0;
    add_format_to_string(&info, v87, v99);
    add_to_string(&info, ", ");
    v89 = (list_head_elinks *)sessions.next;
    v90 = 0;
    if ( sessions.next != &sessions )
    {
      do
      {
        v89 = (list_head_elinks *)v89->next;
        ++v88;
      }
      while ( v89 != &sessions );
      v90 = v88;
    }
    nf = v90;
    v91 = get_terminal_codepage(term);
    v92 = nf;
    v93 = v91;
    if ( v91 != current_charset )
    {
      v94 = get_cp_mime_name(v91);
      bind_textdomain_codeset("elinks", v94);
      v92 = nf;
      current_charset = v93;
    }
    v95 = ngettext(&byte_812B654, "%ld sessions", v92);
    add_format_to_string(&info, v95, v88);
    add_char_to_string(&info, 0x2Eu);
    return info.source;
  }
  return result;
}

//----- (0807BE80) --------------------------------------------------------
void __cdecl dont_exit_prog(void *ses_)
{
  *((_DWORD *)ses_ + 34) = 0;
}

//----- (0807BEA0) --------------------------------------------------------
void __cdecl add_uri_command_to_menu(menu_item **mi, pass_uri_type type, unsigned __int8 *text)
{
  const char *next; // eax
  menu_item_flags v4; // eax
  action_id_T action_id; // [esp+24h] [ebp-24h]
  int commands; // [esp+28h] [ebp-20h]
  list_head_elinks *tree; // [esp+2Ch] [ebp-1Ch]

  action_id = 102;
  tree = (list_head_elinks *)get_opt_(config_options, "document.uri_passing")->number;
  if ( (unsigned int)type <= PASS_URI_LINK )
    action_id = CSWTCH_174[type];
  next = (const char *)tree->next;
  if ( tree->next != tree )
  {
    commands = 0;
    do
    {
      if ( strcmp(*((const char **)next + 3), "_template_") )
      {
        if ( commands == 1 )
        {
          v4 = SUBMENU;
          goto LABEL_12;
        }
        commands = 1;
      }
      next = *(const char **)next;
    }
    while ( next != (const char *)tree );
    if ( !commands )
      return;
    v4 = NO_FLAG;
LABEL_12:
    add_to_menu(mi, text, 0, (main_action)action_id, 0, 0, v4);
  }
}
// 8101930: using guessed type int CSWTCH_174[4];

//----- (0807BF90) --------------------------------------------------------
void __cdecl do_setup_menu(terminal *term, void *xxx, void *ses_)
{
  if ( get_opt_(cmdline_options, "anonymous")->number )
    do_menu(term, setup_menu_anon, ses_, 1);
  else
    do_menu(term, setup_menu, ses_, 1);
}

//----- (0807C010) --------------------------------------------------------
void __cdecl do_submenu(terminal *term, void *menu_, void *ses_)
{
  do_menu(term, (menu_item *)menu_, ses_, 1);
}

//----- (0807C040) --------------------------------------------------------
void __usercall history_menu_common(terminal *term@<eax>, session *ses@<edx>, int unhist@<ecx>)
{
  location *current; // eax
  ses_history *next; // ebx
  menu_item *v6; // eax
  ses_history *p_history; // edi
  unsigned __int8 *uri_string; // eax
  menu_item *mi; // [esp+3Ch] [ebp-1Ch] BYREF

  mi = 0;
  current = ses->history.current;
  if ( !current )
    goto LABEL_18;
  next = (ses_history *)(unhist ? current->next : current->prev);
  v6 = 0;
  p_history = &ses->history;
  while ( p_history != next )
  {
    if ( !v6 )
    {
      mi = new_menu(NO_INTL|FREE_TEXT|FREE_LIST);
      if ( !mi )
        return;
    }
    uri_string = get_uri_string((const uri *)next[5].current, URI_PUBLIC);
    if ( uri_string )
      add_to_menu(&mi, uri_string, 0, ACT_MAIN_NONE, go_historywards, next, NO_FLAG);
    if ( unhist )
      next = (ses_history *)next->history.next;
    else
      next = (ses_history *)next->history.prev;
    v6 = mi;
  }
  if ( v6 )
    do_menu(term, v6, ses, 0);
  else
LABEL_18:
    do_menu(term, no_hist_menu, ses, 0);
}

//----- (0807C150) --------------------------------------------------------
void __cdecl unhistory_menu(terminal *term, void *xxx, void *ses_)
{
  history_menu_common(term, (session *)ses_, 1);
}

//----- (0807C170) --------------------------------------------------------
void __cdecl history_menu(terminal *term, void *xxx, void *ses_)
{
  history_menu_common(term, (session *)ses_, 0);
}

//----- (0807C190) --------------------------------------------------------
void __cdecl do_pass_uri_to_command(terminal *term, void *command_, void *xxx)
{
  exec_on_terminal(term, (unsigned __int8 *)command_, (unsigned __int8 *)&delete, TERM_EXEC_BG);
  mem_free(command_);
}

//----- (0807C1D0) --------------------------------------------------------
void __cdecl add_new_win_to_menu(menu_item **mi, unsigned __int8 *text, terminal *term)
{
  int v3; // ebx
  menu_item_flags v4; // eax

  v3 = can_open_in_new(term);
  if ( v3
    && !get_opt_(cmdline_options, "no-connect")->number
    && !get_opt_(cmdline_options, "no-home")->number
    && !get_opt_(cmdline_options, "anonymous")->number )
  {
    v4 = NO_FLAG;
    if ( v3 != 1 )
      v4 = SUBMENU;
    add_to_menu(mi, text, 0, ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW, open_in_new_window, send_open_in_new_window, v4);
  }
}

//----- (0807C290) --------------------------------------------------------
void __cdecl open_in_new_window(terminal *term, void *func_, void *ses_)
{
  menu_item *v3; // eax
  term_env_type env; // edx
  open_in_new *v5; // edi
  menu_item *mi; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_4;
  if ( !ses_ || !term || !func_ )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
    errline = 708;
    elinks_internal("assertion term && ses && func failed!");
    if ( !assert_failed )
      goto LABEL_9;
LABEL_4:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_9:
  v3 = (menu_item *)can_open_in_new(term);
  if ( v3 )
  {
    if ( v3 == (menu_item *)1 )
    {
      mi = 0;
      LOBYTE(v3) = 0;
LABEL_12:
      env = open_in_new_0[0].env;
      v5 = (open_in_new *)open_in_new_0;
      if ( !open_in_new_0[0].env )
      {
LABEL_20:
        do_menu(term, v3, ses_, 1);
        return;
      }
      while ( 1 )
      {
        if ( (env & term->environment) != 0 )
        {
          if ( !v3 )
          {
            ((void (__cdecl *)(terminal *, open_in_new *, void *))func_)(term, v5, ses_);
            return;
          }
          add_to_menu(&mi, v5->text, 0, ACT_MAIN_NONE, (menu_func_T)func_, v5, NO_FLAG);
        }
        env = v5[1].env;
        ++v5;
        if ( !env )
        {
          v3 = mi;
          goto LABEL_20;
        }
        v3 = mi;
      }
    }
    v3 = new_menu(FREE_LIST);
    mi = v3;
    if ( v3 )
      goto LABEL_12;
  }
}

//----- (0807C3F0) --------------------------------------------------------
void __usercall add_cmdline_bool_option(string *string@<eax>, unsigned __int8 *name@<edx>)
{
  if ( get_opt_(cmdline_options, name)->number )
  {
    add_to_string(string, " -");
    add_to_string(string, name);
  }
}

//----- (0807C440) --------------------------------------------------------
void __cdecl open_uri_in_new_window(
        session *ses,
        uri *uri,
        uri *referrer,
        term_env_type env,
        cache_mode cache_mode,
        task_type task)
{
  int v6; // edi
  int ring; // [esp+2Ch] [ebp-2Ch]
  string parameters; // [esp+38h] [ebp-20h] BYREF

  ring = get_opt_(cmdline_options, "session-ring")->number;
  if ( assert_failed
    || (assert_failed = ses == 0 || env == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c",
        errline = 640,
        elinks_internal("assertion env && ses failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    v6 = add_session_info(ses, uri, referrer, cache_mode, task);
    if ( v6 > 0 && init_string(&parameters) )
    {
      add_format_to_string(&parameters, "-base-session %d", v6);
      if ( ring )
        add_format_to_string(&parameters, " -session-ring %d", ring);
      if ( !uri )
      {
        add_cmdline_bool_option(&parameters, "localhost");
        add_cmdline_bool_option(&parameters, "no-home");
        add_cmdline_bool_option(&parameters, "no-connect");
      }
      open_new_window(ses->tab->term, program_0.path, env, parameters.source);
      done_string(&parameters);
    }
  }
}

//----- (0807C5D0) --------------------------------------------------------
void __cdecl send_open_new_window(terminal *term, const open_in_new *open, session *ses)
{
  open_uri_in_new_window(ses, 0, 0, open->env, CACHE_MODE_NORMAL, TASK_NONE);
}

//----- (0807C610) --------------------------------------------------------
void __cdecl send_open_in_new_window(terminal *term, const open_in_new *open, session *ses)
{
  document_view *v3; // eax
  int current_link; // edx
  document *document; // ecx
  link *v6; // edx
  uri *link_uri; // edi
  document_view *v8; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( open && term && ses )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
    errline = 674;
    elinks_internal("assertion term && open && ses failed!");
    if ( assert_failed )
      goto LABEL_4;
  }
  v3 = current_frame(ses);
  if ( assert_failed )
    goto LABEL_4;
  if ( !v3 || !v3->vs || !v3->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
    errline = 677;
    v8 = v3;
    elinks_internal("assertion doc_view && doc_view->vs && doc_view->document failed!");
    v3 = v8;
    if ( !assert_failed )
    {
      if ( !v8 )
        return;
      goto LABEL_14;
    }
LABEL_4:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_14:
  current_link = v3->vs->current_link;
  if ( current_link >= 0 )
  {
    document = v3->document;
    if ( current_link < document->nlinks )
    {
      v6 = &document->links[current_link];
      if ( v6 )
      {
        link_uri = get_link_uri(ses, v3, v6);
        if ( link_uri )
        {
          open_uri_in_new_window(ses, link_uri, 0, open->env, CACHE_MODE_NORMAL, TASK_NONE);
          done_uri(link_uri);
        }
      }
    }
  }
}

//----- (0807C7A0) --------------------------------------------------------
void free_history_lists()
{
  _DWORD *next; // eax
  input_history *i; // ebx
  input_history *j; // edx
  input_history *v3; // esi
  input_history *v4; // edi

  next = file_history.entries.next;
  for ( i = (input_history *)file_history.entries.next; i != &file_history; i = (input_history *)i->entries.next )
    ;
  for ( j = (input_history *)file_history.entries.prev; j != i; j = (input_history *)j->entries.prev )
    ;
  v3 = *(input_history **)file_history.entries.next;
  if ( file_history.entries.next != i )
  {
    do
    {
      v4 = v3;
      v3->entries.prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v3 = (input_history *)v3->entries.next;
      next = &v4->entries.next;
    }
    while ( v4 != i );
  }
  trigger_event_name("free-history");
}

//----- (0807C820) --------------------------------------------------------
void __cdecl dialog_goto_url(session *ses, unsigned __int8 *url)
{
  input_dialog(
    ses->tab->term,
    0,
    "Go to URL",
    "Enter URL",
    ses,
    &goto_url_history,
    1024,
    url,
    0,
    0,
    0,
    (void (*)(void *, unsigned __int8 *))goto_url_with_hook,
    0);
}

//----- (0807C8A0) --------------------------------------------------------
void __cdecl save_url_as(session *ses)
{
  input_dialog(
    ses->tab->term,
    0,
    (unsigned __int8 *)&byte_812B6C4,
    "Enter URL",
    ses,
    &goto_url_history,
    1024,
    (unsigned __int8 *)&delete,
    0,
    0,
    0,
    (void (*)(void *, unsigned __int8 *))save_url,
    0);
}

//----- (0807C920) --------------------------------------------------------
void __cdecl activate_bfu_technology(session *ses, int item)
{
  do_mainmenu(ses->tab->term, main_menu, ses, item);
}

//----- (0807C950) --------------------------------------------------------
void __cdecl menu_url_shortcut(terminal *term, void *url_, void *ses_)
{
  uri *uri; // eax
  uri *v4; // esi

  uri = get_uri((unsigned __int8 *)url_, (uri_component)0);
  v4 = uri;
  if ( uri )
  {
    goto_uri((session *)ses_, uri);
    done_uri(v4);
  }
}

//----- (0807C9B0) --------------------------------------------------------
void __cdecl do_file_menu(terminal *term, void *xxx, void *ses_)
{
  int number; // esi
  menu_item *v4; // eax
  menu_item *v5; // ebx
  menu_item *v6; // esi
  int v7; // edi
  size_t v8; // eax
  menu_item *v9; // edi
  menu_item *v10; // esi
  menu_item *v11; // eax
  menu_item *v12; // edx
  int v13; // eax
  menu_item *v14; // eax
  menu_item *v15; // [esp+0h] [ebp-38h]
  menu_item *v16; // [esp+1Ch] [ebp-1Ch]

  number = get_opt_(cmdline_options, "anonymous")->number;
  v4 = (menu_item *)mem_alloc(0x2E0u);
  v5 = v4;
  if ( v4 )
  {
    if ( number )
    {
      qmemcpy(v4, file_menu11, 0xE0u);
      qmemcpy(&v4[7], file_menu22, 0xA0u);
      v6 = v4 + 12;
      v7 = 1;
    }
    else
    {
      if ( get_opt_(cmdline_options, "no-connect")->number || get_opt_(cmdline_options, "no-home")->number )
      {
        qmemcpy(v5, file_menu11, 0xE0u);
        v12 = v5 + 7;
      }
      else
      {
        v13 = can_open_in_new(term);
        if ( v13 )
        {
          if ( v13 != 1 )
            number = 32;
          v5->text = "Open ~new window";
          v14 = v5 + 1;
          v5->rtext = 0;
          v5->action_id = ACT_MAIN_OPEN_NEW_WINDOW;
          v5->func = open_in_new_window;
          v5->data = send_open_new_window;
          v5->flags = number;
          v5->hotkey_state = HKS_SHOW;
          v5->hotkey_pos = 0;
        }
        else
        {
          v14 = v5;
        }
        v12 = v14 + 7;
        qmemcpy(v14, file_menu11, 0xE0u);
      }
      qmemcpy(v12, file_menu21, 0xA0u);
      qmemcpy(&v12[5], file_menu22, 0xA0u);
      v6 = v12 + 10;
      v7 = 1;
      v16 = v12;
      if ( can_open_os_shell(term->environment) )
      {
        v16[10].text = "~OS shell";
        LOWORD(v7) = 0;
        v6->rtext = 0;
        v6->action_id = ACT_MAIN_OPEN_OS_SHELL;
        v6->func = 0;
        v6->data = 0;
        v6->flags = NO_FLAG;
        v6->hotkey_state = HKS_SHOW;
        v6->hotkey_pos = 0;
        v6 = v16 + 11;
      }
    }
    if ( can_resize_window(term->environment) )
    {
      v6->text = "Resize t~erminal";
      v9 = file_menu3;
      v8 = 96;
      v6->rtext = 0;
      v6->action_id = ACT_MAIN_TERMINAL_RESIZE;
      v6->func = 0;
      v6->data = 0;
      v6->flags = NO_FLAG;
      v6->hotkey_state = HKS_SHOW;
      v6->hotkey_pos = 0;
      ++v6;
    }
    else
    {
      v8 = 32 * (3 - v7);
      v9 = (menu_item *)(32 * v7 + 135529280);
    }
    v15 = v6;
    v10 = v6 + 3;
    memcpy(v15, v9, v8);
    if ( v5 < v10 )
    {
      v11 = v5;
      do
      {
        v11->flags |= 1u;
        ++v11;
      }
      while ( v10 > v11 );
    }
    do_menu(term, v5, ses_, 1);
  }
}

//----- (0807CC40) --------------------------------------------------------
void __cdecl go_historywards(terminal *term, void *target_, void *ses_)
{
  go_history((session *)ses_, (location *)target_);
}

//----- (0807CC60) --------------------------------------------------------
void __cdecl tab_menu(session *ses, int x, int y, int place_above_cursor)
{
  int v4; // esi
  int number; // edi
  menu_item *v6; // eax
  document_view *doc_view; // eax
  document *document; // eax
  int v9; // eax
  int tabs_count; // [esp+2Ch] [ebp-2Ch]
  menu_item *menu[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v4 = y;
  number = get_opt_(cmdline_options, "anonymous")->number;
  if ( assert_failed )
    goto LABEL_25;
  if ( ses && ses->tab )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
  errline = 231;
  elinks_internal("assertion ses && ses->tab failed!");
  if ( assert_failed )
  {
LABEL_25:
    assert_failed = 0;
    return;
  }
LABEL_5:
  tabs_count = number_of_tabs(ses->tab->term);
  v6 = new_menu(FREE_LIST);
  if ( v6 )
  {
    menu[0] = v6;
    add_to_menu(menu, "Go ~back", 0, ACT_MAIN_HISTORY_MOVE_BACK, 0, 0, NO_FLAG);
    add_to_menu(menu, "Go for~ward", 0, ACT_MAIN_HISTORY_MOVE_FORWARD, 0, 0, NO_FLAG);
    if ( ses->history.current )
    {
      add_to_menu(menu, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
      if ( !number )
        add_to_menu(menu, "Bookm~ark document", 0, ACT_MAIN_ADD_BOOKMARK, 0, 0, NO_FLAG);
      add_to_menu(menu, "Toggle ~HTML/plain", 0, ACT_MAIN_TOGGLE_HTML_PLAIN, 0, 0, NO_FLAG);
      add_to_menu(menu, "~Reload", 0, ACT_MAIN_RELOAD, 0, 0, NO_FLAG);
      doc_view = ses->doc_view;
      if ( doc_view )
      {
        document = doc_view->document;
        if ( document )
        {
          if ( document->frame_desc )
          {
            add_to_menu(menu, "Frame at ~full-screen", 0, ACT_MAIN_FRAME_MAXIMIZE, 0, 0, NO_FLAG);
            add_uri_command_to_menu(menu, PASS_URI_FRAME, "~Pass frame URI to external command");
          }
        }
      }
    }
    add_to_menu(menu, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
    if ( tabs_count <= 1 )
    {
      add_to_menu(menu, "~Close tab", 0, ACT_MAIN_TAB_CLOSE, 0, 0, NO_FLAG);
    }
    else
    {
      add_to_menu(menu, "Nex~t tab", 0, ACT_MAIN_TAB_NEXT, 0, 0, NO_FLAG);
      add_to_menu(menu, "Pre~v tab", 0, ACT_MAIN_TAB_PREV, 0, 0, NO_FLAG);
      add_to_menu(menu, "~Close tab", 0, ACT_MAIN_TAB_CLOSE, 0, 0, NO_FLAG);
      add_to_menu(menu, "C~lose all tabs but the current", 0, ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT, 0, 0, NO_FLAG);
      if ( !number )
        add_to_menu(menu, "B~ookmark all tabs", 0, ACT_MAIN_ADD_BOOKMARK_TABS, 0, 0, NO_FLAG);
    }
    if ( ses->history.current )
      add_uri_command_to_menu(menu, PASS_URI_TAB, "Pass tab URI to e~xternal command");
    if ( place_above_cursor )
    {
      v9 = 0;
      if ( menu[0]->text )
      {
        do
          ++v9;
        while ( menu[0][v9].text );
      }
      v4 = 0;
      if ( y - 1 - v9 >= 0 )
        v4 = y - 1 - v9;
    }
    ses->tab->x = x;
    ses->tab->y = v4;
    do_menu(ses->tab->term, menu[0], ses, 1);
  }
}

//----- (0807D160) --------------------------------------------------------
void __cdecl really_exit_prog(void *ses_)
{
  register_bottom_half_do((select_handler_T)destroy_terminal, *(void **)(*((_DWORD *)ses_ + 2) + 20));
}

//----- (0807D190) --------------------------------------------------------
void __cdecl query_exit(session *ses)
{
  window *tab; // eax
  terminal *term; // eax
  unsigned __int8 *v3; // edx

  tab = ses->tab;
  ses->exit_query = 1;
  term = tab->term;
  if ( term->next == term->prev )
  {
    if ( are_there_downloads() )
    {
      v3 = "Do you really want to exit ELinks (and terminate all downloads)?";
      term = ses->tab->term;
      goto LABEL_3;
    }
    term = ses->tab->term;
  }
  v3 = "Do you really want to exit ELinks?";
LABEL_3:
  msg_box(
    term,
    0,
    (msgbox_flags)0,
    "Exit ELinks",
    ALIGN_CENTER,
    v3,
    ses,
    2,
    "~Yes",
    really_exit_prog,
    1,
    "~No",
    dont_exit_prog,
    2);
}

//----- (0807D250) --------------------------------------------------------
void __cdecl exit_prog(session *ses, int query)
{
  if ( !assert_failed )
  {
    assert_failed = ses == 0;
    if ( !ses )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 139;
      elinks_internal("assertion ses failed!");
    }
  }
  if ( !ses->exit_query )
  {
    if ( query || terminals.next == terminals.prev && are_there_downloads() )
      query_exit(ses);
    else
      really_exit_prog(ses);
  }
}

//----- (0807D310) --------------------------------------------------------
frame_event_status __cdecl pass_uri_to_command(session *ses, document_view *doc_view, int which_type)
{
  list_head_elinks *next; // ebx
  _BYTE *v4; // esi
  char v5; // al
  int v6; // ecx
  size_t v7; // ebx
  _BYTE *v8; // edi
  char v9; // al
  char v11; // al
  int length; // ebx
  size_t v13; // edx
  unsigned int v14; // ecx
  int v15; // ecx
  unsigned int v16; // eax
  size_t v17; // edx
  unsigned __int8 *post; // eax
  unsigned __int8 *v19; // ebx
  int v20; // eax
  int current_link; // edx
  document *document; // eax
  link *v23; // edx
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // eax
  size_t v26; // [esp+20h] [ebp-48h]
  size_t v27; // [esp+20h] [ebp-48h]
  int v28; // [esp+24h] [ebp-44h]
  int v29; // [esp+24h] [ebp-44h]
  int v30; // [esp+24h] [ebp-44h]
  unsigned int v31; // [esp+24h] [ebp-44h]
  list_head_elinks **v32; // [esp+28h] [ebp-40h]
  int commands; // [esp+2Ch] [ebp-3Ch]
  uri *uri; // [esp+30h] [ebp-38h]
  unsigned __int8 *text; // [esp+34h] [ebp-34h]
  int v36; // [esp+38h] [ebp-30h]
  unsigned int v37; // [esp+38h] [ebp-30h]
  list_head_elinks *tree; // [esp+3Ch] [ebp-2Ch]
  string string; // [esp+44h] [ebp-24h] BYREF
  menu_item *items; // [esp+4Ch] [ebp-1Ch] BYREF

  tree = (list_head_elinks *)get_opt_(config_options, "document.uri_passing")->number;
  if ( which_type )
  {
    if ( which_type == 1 )
    {
      if ( !doc_view )
        return 2;
      current_link = doc_view->vs->current_link;
      if ( current_link < 0 )
        return 2;
      document = doc_view->document;
      if ( current_link >= document->nlinks )
        return 2;
      v23 = &document->links[current_link];
      if ( !v23 )
        return 2;
      uri = get_link_uri(ses, doc_view, v23);
      if ( !uri )
        return 2;
    }
    else
    {
      uri = ses->doc_view->document->uri;
      ++uri->object.refcount;
    }
  }
  else
  {
    uri = doc_view->document->uri;
    ++uri->object.refcount;
  }
  items = new_menu(NO_INTL|FREE_DATA|FREE_TEXT|FREE_LIST);
  if ( !items )
  {
    done_uri(uri);
    return 2;
  }
  next = (list_head_elinks *)tree->next;
  if ( tree->next == tree )
  {
    done_uri(uri);
LABEL_24:
    mem_free(items->data);
LABEL_25:
    mem_free(items->text);
    mem_free(items);
    return 2;
  }
  commands = 0;
  do
  {
    while ( 1 )
    {
      if ( !strcmp((const char *)next[1].prev, "_template_") )
        goto LABEL_6;
      text = stracpy((const unsigned __int8 *)next[1].prev);
      if ( !text )
        goto LABEL_6;
      v4 = next[4].next;
      if ( init_string(&string) )
      {
        v32 = (list_head_elinks **)next;
        while ( 1 )
        {
          v5 = *v4;
          if ( !*v4 )
            break;
          while ( 1 )
          {
            v6 = 0;
            v7 = 0;
            v8 = v4;
            if ( v5 != 37 )
            {
              do
              {
                v9 = v4[++v6];
                v7 = v6;
                v8 = &v4[v6];
              }
              while ( v9 != 37 && v9 );
            }
            if ( assert_failed )
            {
LABEL_17:
              assert_failed = 0;
              goto LABEL_18;
            }
            if ( v6 < 0 )
            {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 255;
              v29 = v6;
              elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
              v6 = v29;
              if ( assert_failed )
                goto LABEL_17;
            }
            else
            {
              assert_failed = 0;
            }
            if ( v6 )
            {
              v15 = string.length + v6;
              v16 = string.length + 255;
              v17 = v15 + 256;
              LOBYTE(v16) = 0;
              LOBYTE(v17) = 0;
              v37 = v16;
              if ( v17 > v16 )
              {
                v26 = v17;
                v30 = v15;
                v24 = (unsigned __int8 *)mem_realloc(string.source, v17);
                if ( !v24 )
                  goto LABEL_18;
                string.source = v24;
                memset(&v24[v37], 0, v26 - v37);
                v15 = v30;
              }
              if ( string.source )
              {
                v28 = v15;
                memcpy(&string.source[string.length], v4, v7);
                string.source[v28] = 0;
                string.length = v28;
              }
            }
LABEL_18:
            v5 = *v8;
            if ( *v8 == 37 )
              break;
            v4 = v8;
            if ( !v5 )
              goto LABEL_20;
          }
          v11 = v8[1];
          if ( v11 == 37 )
          {
            add_char_to_string(&string, 0x25u);
          }
          else if ( v11 == 99 )
          {
            post = uri->post;
            v19 = uri->string;
            if ( post )
              v20 = post - 1 - v19;
            else
              v20 = strlen((const char *)uri->string);
            add_shell_quoted_to_string(&string, v19, v20);
          }
          else if ( assert_failed )
          {
            assert_failed = 0;
          }
          else
          {
            length = string.length;
            assert_failed = 0;
            v13 = string.length + 258;
            v14 = string.length + 255;
            LOBYTE(v13) = 0;
            LOBYTE(v14) = 0;
            v36 = string.length + 2;
            if ( v13 > v14 )
            {
              v27 = v13;
              v31 = v14;
              v25 = (unsigned __int8 *)mem_realloc(string.source, v13);
              if ( v25 )
              {
                string.source = v25;
                memset(&v25[v31], 0, v27 - v31);
                goto LABEL_31;
              }
            }
            else
            {
LABEL_31:
              if ( string.source )
              {
                *(_WORD *)&string.source[string.length] = *(_WORD *)v8;
                string.source[length + 2] = 0;
                string.length = v36;
              }
            }
          }
          v4 = &v8[-(v8[1] == 0) + 2];
        }
LABEL_20:
        next = (list_head_elinks *)v32;
        if ( string.source )
          break;
      }
      mem_free(text);
LABEL_6:
      next = (list_head_elinks *)next->next;
      if ( next == tree )
        goto LABEL_22;
    }
    add_to_menu(&items, text, 0, ACT_MAIN_NONE, do_pass_uri_to_command, string.source, NO_FLAG);
    ++commands;
    next = *v32;
  }
  while ( *v32 != tree );
LABEL_22:
  done_uri(uri);
  if ( commands <= 1 )
  {
    if ( commands != 1 )
      goto LABEL_24;
    do_pass_uri_to_command(ses->tab->term, items->data, ses);
    goto LABEL_25;
  }
  do_menu(ses->tab->term, items, ses, 1);
  return 2;
}

//----- (0807D7F0) --------------------------------------------------------
void __cdecl query_file(
        session *ses,
        uri *uri,
        void *data,
        void (*std)(void *, unsigned __int8 *),
        void (*cancel)(void *),
        int interactive)
{
  int v6; // eax
  option_value *opt; // eax
  string def; // [esp+48h] [ebp-20h] BYREF

  if ( assert_failed
    || (assert_failed = ses == 0 || uri == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c",
        errline = 560,
        elinks_internal("assertion ses && uri failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( uri->protocol == 18 )
  {
    assert_failed = 0;
    print_error_dialog(ses, (connection_state)4294867281LL, uri, PRI_CANCEL);
  }
  else if ( get_protocol_external_handler(ses->tab->term, uri) )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v6 = -100003;
    }
    else
    {
      assert_failed = 0;
      v6 = -100016;
    }
    print_error_dialog(ses, (connection_state)(unsigned int)v6, uri, PRI_CANCEL);
  }
  else if ( init_string(&def) )
  {
    opt = get_opt_(config_options, "document.download.directory");
    add_to_string(&def, opt->string);
    if ( def.length && def.source[def.length - 1] != 47 )
      add_char_to_string(&def, 0x2Fu);
    add_mime_filename_to_string(&def, uri);
    if ( (*((_BYTE *)ses->tab->term + 56) & 2) != 0 )
      decode_uri_string(&def);
    else
      decode_uri_string_for_display(&def);
    if ( interactive )
      input_dialog(
        ses->tab->term,
        0,
        (unsigned __int8 *)&byte_812B447,
        "Save to file",
        data,
        &file_history,
        1024,
        def.source,
        0,
        0,
        check_nonempty,
        std,
        cancel);
    else
      std(data, def.source);
    done_string(&def);
  }
}

//----- (0807DA60) --------------------------------------------------------
void __cdecl save_url(session *ses, unsigned __int8 *url)
{
  window *tab; // eax
  uri *translated_uri; // esi
  document_view *v4; // eax
  document *document; // edx
  int v6; // eax
  document_view *v7; // [esp+2Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_18;
  if ( !ses || (tab = ses->tab) == 0 || !url || !tab->term )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
    errline = 70;
    elinks_internal("assertion ses && ses->tab && ses->tab->term && url failed!");
    if ( !assert_failed )
      goto LABEL_7;
LABEL_18:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_7:
  if ( !*url )
    return;
  translated_uri = get_translated_uri(url, ses->tab->term->cwd);
  if ( translated_uri )
  {
    if ( ses->download_uri )
      done_uri(ses->download_uri);
    ses->download_uri = translated_uri;
    v4 = current_frame(ses);
    if ( !assert_failed )
    {
      if ( v4 )
      {
        document = v4->document;
        if ( document )
        {
          if ( document->uri )
          {
            assert_failed = 0;
LABEL_16:
            set_session_referrer(ses, v4->document->uri);
            query_file(ses, ses->download_uri, ses, start_download, 0, 1);
            return;
          }
        }
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 86;
      v7 = v4;
      elinks_internal("assertion doc_view && doc_view->document && doc_view->document->uri failed!");
      v4 = v7;
      if ( !assert_failed )
        goto LABEL_16;
    }
    goto LABEL_18;
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v6 = -100003;
  }
  else
  {
    assert_failed = 0;
    v6 = -100009;
  }
  print_error_dialog(ses, (connection_state)(unsigned int)v6, 0, PRI_CANCEL);
}

//----- (0807DC40) --------------------------------------------------------
void __cdecl auto_complete_file(
        terminal *term,
        int no_elevator,
        unsigned __int8 *path,
        menu_func_T file_func,
        menu_func_T dir_func,
        void *data)
{
  unsigned __int8 *v6; // ebx
  uri *translated_uri; // eax
  uri *v8; // ebx
  unsigned __int8 *uri_string; // esi
  unsigned __int8 *filename_position; // ebx
  unsigned __int8 *v11; // eax
  bool v12; // zf
  char *v13; // edi
  menu_item *v14; // ebx
  directory_entry *directory_entries; // eax
  directory_entry *v16; // ebx
  unsigned __int8 v17; // di
  _BOOL4 v18; // esi
  unsigned __int8 *v19; // edi
  unsigned __int8 *name; // eax
  int terminal_codepage; // eax
  int v22; // esi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v24; // eax
  char *v25; // ebx
  char *v26; // eax
  int v27; // eax
  int v28; // esi
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // eax
  unsigned __int8 *s; // [esp+28h] [ebp-40h]
  size_t n; // [esp+2Ch] [ebp-3Ch]
  int v33; // [esp+30h] [ebp-38h]
  char *s1; // [esp+34h] [ebp-34h]
  int v35; // [esp+38h] [ebp-30h]
  directory_entry *p; // [esp+3Ch] [ebp-2Ch]
  menu_item *separator; // [esp+48h] [ebp-20h] BYREF
  unsigned __int8 *dirname; // [esp+4Ch] [ebp-1Ch] BYREF

  v6 = path;
  if ( !assert_failed )
  {
    if ( data && term && dir_func && file_func )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/menu.c";
      errline = 1050;
      elinks_internal("assertion term && data && file_func && dir_func && data failed!");
    }
  }
  if ( !get_opt_(cmdline_options, "anonymous")->number )
  {
    if ( !*path )
      v6 = "./";
    translated_uri = get_translated_uri(v6, term->cwd);
    v8 = translated_uri;
    if ( translated_uri )
    {
      if ( translated_uri->protocol != 4 )
      {
        done_uri(translated_uri);
        return;
      }
      uri_string = get_uri_string(translated_uri, URI_PATH);
      done_uri(v8);
      if ( uri_string )
      {
        filename_position = get_filename_position(uri_string);
        if ( *filename_position )
        {
          if ( file_is_dir(uri_string) )
          {
            filename_position = &uri_string[strlen((const char *)uri_string)];
          }
          else if ( *filename_position && file_exists(uri_string) )
          {
            file_func(term, uri_string, data);
            return;
          }
        }
        dirname = uri_string;
        v11 = stracpy(filename_position);
        v12 = *(filename_position - 1) == 47;
        *filename_position = 0;
        v13 = (char *)v11;
        if ( !v12 )
        {
          LOBYTE(separator) = *dirname;
          insert_in_string(&dirname, filename_position - dirname, (const unsigned __int8 *)&separator, 1);
        }
        s = dirname;
        separator = new_menu(NO_INTL|FREE_LIST);
        v14 = separator;
        n = strlen(v13);
        if ( !v14 )
          goto LABEL_38;
        directory_entries = get_directory_entries(s, 1);
        p = directory_entries;
        if ( !directory_entries )
          goto LABEL_50;
        if ( !directory_entries->name )
        {
          mem_free(directory_entries);
          goto LABEL_50;
        }
        v16 = directory_entries;
        v33 = 0;
        v35 = 0;
        s1 = v13;
        while ( 1 )
        {
          while ( 1 )
          {
            v17 = *v16->attrib;
            v18 = v17 == 100;
            mem_free(v16->attrib);
            if ( v17 == 45 || v17 == 100 )
            {
              if ( file_can_read(v16->name) )
              {
                v19 = get_filename_position(v16->name);
                if ( !strncmp(s1, (const char *)v19, n) && (!no_elevator || *v19 != 46 || v19[1] != 46 || v19[2]) )
                  break;
              }
            }
            mem_free(v16->name);
LABEL_24:
            ++v16;
            if ( !v16->name )
              goto LABEL_35;
          }
          if ( !v18 )
          {
            if ( !v33 )
            {
              if ( v35 )
                add_to_menu(&separator, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
              if ( term )
              {
                terminal_codepage = get_terminal_codepage(term);
                v22 = terminal_codepage;
                if ( terminal_codepage != current_charset )
                {
                  cp_mime_name = get_cp_mime_name(terminal_codepage);
                  bind_textdomain_codeset("elinks", cp_mime_name);
                  current_charset = v22;
                }
              }
              v24 = gettext(&byte_812B7E3);
              add_to_menu(&separator, v24, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
              add_to_menu(&separator, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
            }
            add_to_menu(&separator, v19, 0, ACT_MAIN_NONE, file_func, v16->name, FREE_DATA);
            ++v33;
            goto LABEL_24;
          }
          if ( !v35 )
          {
            if ( term )
            {
              v27 = get_terminal_codepage(term);
              v28 = v27;
              if ( v27 != current_charset )
              {
                v29 = get_cp_mime_name(v27);
                bind_textdomain_codeset("elinks", v29);
                current_charset = v28;
              }
            }
            v30 = gettext(&byte_812B7D6);
            add_to_menu(&separator, v30, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
            add_to_menu(&separator, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
          }
          name = v16->name;
          ++v16;
          add_to_menu(&separator, v19, 0, ACT_MAIN_NONE, dir_func, name, SUBMENU|FREE_DATA);
          ++v35;
          if ( !v16->name )
          {
LABEL_35:
            v13 = s1;
            mem_free(p);
            if ( v35 || v33 )
            {
              if ( v33 + v35 == 1 )
              {
                v25 = (char *)separator[2].data;
                mem_free(separator);
                if ( v33 )
                {
                  file_func(term, v25, data);
                }
                else
                {
                  v26 = &v25[strlen((const char *)s)];
                  if ( *v26 == 46 && v26[1] == 46 && !v26[2] )
                    do_menu(term, empty_directory_menu, 0, 0);
                  else
                    dir_func(term, v25, data);
                  mem_free(v25);
                }
              }
              else
              {
                do_menu(term, separator, data, 0);
              }
            }
            else
            {
LABEL_50:
              mem_free(separator);
            }
LABEL_38:
            mem_free(dirname);
            mem_free(v13);
            return;
          }
        }
      }
    }
  }
}

//----- (0807E2E0) --------------------------------------------------------
void __cdecl push_resize_button(void *data)
{
  unsigned __int8 str[1024]; // [esp+3Ch] [ebp-40Ch] BYREF
  unsigned int v2; // [esp+43Ch] [ebp-Ch]

  v2 = __readgsdword(0x14u);
  __snprintf_chk(
    str,
    1024,
    1,
    1024,
    "%s,%s,%d,%d",
    (const char *)width_str,
    (const char *)height_str,
    *((_DWORD *)data + 11),
    *((_DWORD *)data + 12));
  do_terminal_function((terminal *)data, 2u, str);
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0807E380) --------------------------------------------------------
void __cdecl menu_language_list(terminal *term, void *xxx, void *ses)
{
  menu_item *v3; // eax
  int v4; // ebx
  unsigned __int8 *name; // eax
  unsigned __int8 *v6; // [esp+8h] [ebp-30h]
  void *v7; // [esp+14h] [ebp-24h]
  menu_item *mi; // [esp+2Ch] [ebp-Ch] BYREF

  v3 = new_menu(FREE_LIST);
  if ( v3 )
  {
    mi = v3;
    if ( languages[0].name )
    {
      v4 = 0;
      do
      {
        v7 = (void *)v4;
        v6 = language_to_iso639(v4);
        name = languages[v4++].name;
        add_to_menu(&mi, name, v6, ACT_MAIN_NONE, menu_set_language, v7, NO_FLAG);
      }
      while ( languages[v4].name );
      v3 = mi;
    }
    do_menu_selected(term, v3, ses, current_language, 0);
  }
}

//----- (0807E430) --------------------------------------------------------
void __cdecl menu_set_language(terminal *term, void *pcp_, void *xxx)
{
  set_language((int)pcp_);
  cls_redraw_all_terminals();
}

//----- (0807E450) --------------------------------------------------------
widget_handler_status_T __cdecl push_ok_button(dialog_data *dlg_data, widget_data *button)
{
  terminal *term; // edi
  option_value *udata; // [esp+1Ch] [ebp-1Ch]

  term = dlg_data->win->term;
  udata = (option_value *)dlg_data->dlg->udata;
  update_dialog_data(dlg_data);
  commit_option_values(resolvers, term->spec, udata, 8);
  if ( button->widget->handler == push_ok_button )
    return cancel_dialog(dlg_data, button);
  else
    return 0;
}

//----- (0807E4D0) --------------------------------------------------------
widget_handler_status_T __cdecl push_save_button_1(dialog_data *dlg_data, widget_data *button)
{
  push_ok_button(dlg_data, button);
  write_config(dlg_data->win->term);
  return 0;
}

//----- (0807E500) --------------------------------------------------------
void __cdecl charset_list(terminal *term, void *xxx, void *ses_)
{
  int terminal_codepage; // eax
  int v4; // edi
  int i; // ebx
  int v6; // eax
  unsigned __int8 *cp_config_name; // eax
  unsigned __int8 *cp_name; // esi
  int v9; // [esp+0h] [ebp-58h]
  unsigned __int8 *cp_mime_name; // [esp+4h] [ebp-54h]
  unsigned __int8 *sel_mime; // [esp+2Ch] [ebp-2Ch]
  menu_item *mi; // [esp+3Ch] [ebp-1Ch] BYREF

  terminal_codepage = get_terminal_codepage(term);
  sel_mime = get_cp_mime_name(terminal_codepage);
  mi = new_menu(FREE_LIST);
  if ( mi )
  {
    v4 = 0;
    for ( i = 0; ; ++i )
    {
      cp_name = get_cp_name(i);
      if ( !cp_name )
        break;
      cp_mime_name = get_cp_mime_name(i);
      v6 = strcmp((const char *)sel_mime, (const char *)cp_mime_name);
      v9 = i;
      if ( !v6 )
        v4 = i;
      cp_config_name = get_cp_config_name(v9);
      add_to_menu(&mi, cp_name, 0, ACT_MAIN_NONE, display_codepage, cp_config_name, NO_FLAG);
    }
    do_menu_selected(term, mi, ses_, v4, 0);
  }
}

//----- (0807E5E0) --------------------------------------------------------
void __cdecl display_codepage(terminal *term, void *name_, void *xxx)
{
  option_elinks *opt_rec; // ebx
  int cp_index; // eax

  opt_rec = get_opt_rec(term->spec, "charset");
  cp_index = get_cp_index((const unsigned __int8 *)name_);
  if ( !assert_failed )
  {
    assert_failed = cp_index == -1;
    if ( cp_index == -1 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
      errline = 36;
      elinks_internal("assertion index != -1 failed: %s", (const char *)name_);
      cp_index = -1;
    }
  }
  if ( cp_index != opt_rec->value.number )
  {
    opt_rec->value.number = cp_index;
    option_changed(0, opt_rec);
  }
  cls_redraw_all_terminals();
}

//----- (0807E680) --------------------------------------------------------
void __cdecl resize_terminal_dialog(terminal *term)
{
  int width; // edi
  int height; // esi
  dialog *v3; // esi
  int terminal_codepage; // eax
  int v5; // edi
  unsigned __int8 *cp_mime_name; // eax
  int v7; // eax
  int v8; // edi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // eax
  int v12; // edi
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  int v15; // eax
  int v16; // edi
  unsigned __int8 *v17; // eax
  unsigned __int8 *v18; // eax
  int v19; // eax
  int v20; // edi
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // eax
  bool v23; // zf
  memory_list *v24; // eax

  width = term->width;
  height = term->height;
  if ( width >= 999 )
    width = 999;
  if ( height >= 999 )
    height = 999;
  if ( can_resize_window(term->environment) )
  {
    elinks_ulongcat(width_str, 0, width, 3u, 0x20u, 0xAu, 0);
    elinks_ulongcat(height_str, 0, height, 3u, 0x20u, 0xAu, 0);
    v3 = (dialog *)mem_calloc(1u, 0xE4u);
    if ( v3 )
    {
      terminal_codepage = get_terminal_codepage(term);
      v5 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v5;
      }
      v3->title = gettext(&byte_812BB28);
      v3->layouter = group_layouter;
      v7 = get_terminal_codepage(term);
      v8 = v7;
      if ( v7 != current_charset )
      {
        v9 = get_cp_mime_name(v7);
        bind_textdomain_codeset("elinks", v9);
        current_charset = v8;
      }
      v10 = gettext(&byte_812BB38);
      add_dlg_field_do(v3, WIDGET_FIELD, v10, 1, 999, check_number, 4, width_str, 0, INPFIELD_NONE);
      v11 = get_terminal_codepage(term);
      v12 = v11;
      if ( v11 != current_charset )
      {
        v13 = get_cp_mime_name(v11);
        bind_textdomain_codeset("elinks", v13);
        current_charset = v12;
      }
      v14 = gettext(&byte_812BB3F);
      add_dlg_field_do(v3, WIDGET_FIELD, v14, 1, 999, check_number, 4, height_str, 0, INPFIELD_NONE);
      v15 = get_terminal_codepage(term);
      v16 = v15;
      if ( v15 != current_charset )
      {
        v17 = get_cp_mime_name(v15);
        bind_textdomain_codeset("elinks", v17);
        current_charset = v16;
      }
      v18 = gettext(&okbutton);
      add_dlg_button_do(v3, v18, 1, ok_dialog, 0, push_resize_button, term);
      v19 = get_terminal_codepage(term);
      v20 = v19;
      if ( v19 != current_charset )
      {
        v21 = get_cp_mime_name(v19);
        bind_textdomain_codeset("elinks", v21);
        current_charset = v20;
      }
      v22 = gettext(&cancelbutton);
      add_dlg_button_do(v3, v22, 2, cancel_dialog, 0, 0, 0);
      if ( !assert_failed )
      {
        v23 = v3->number_of_widgets == 4;
        assert_failed = v3->number_of_widgets != 4;
        if ( !v23 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
          errline = 318;
          elinks_internal("assertion 4 == (dlg)->number_of_widgets failed!");
        }
      }
      v24 = getml(v3, 0);
      do_dialog(term, v3, v24);
    }
  }
}

//----- (0807EA40) --------------------------------------------------------
void __cdecl terminal_options(terminal *term, void *xxx, session *ses)
{
  size_t v3; // edx
  int v4; // eax
  option_value *v5; // eax
  option_value *v6; // ebx
  int *v7; // esi
  int v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // eax
  unsigned __int8 *v12; // eax
  unsigned __int8 *v13; // eax
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  int v17; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // eax
  int v20; // eax
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // eax
  int v23; // eax
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // eax
  int v26; // eax
  unsigned __int8 *v27; // eax
  unsigned __int8 *v28; // eax
  int v29; // eax
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // eax
  int v32; // eax
  unsigned __int8 *v33; // eax
  unsigned __int8 *v34; // eax
  int v35; // eax
  unsigned __int8 *v36; // eax
  unsigned __int8 *v37; // eax
  int v38; // eax
  unsigned __int8 *v39; // eax
  unsigned __int8 *v40; // eax
  int v41; // eax
  unsigned __int8 *v42; // eax
  unsigned __int8 *v43; // eax
  int v44; // eax
  unsigned __int8 *v45; // eax
  unsigned __int8 *v46; // eax
  int v47; // eax
  unsigned __int8 *v48; // eax
  unsigned __int8 *v49; // eax
  int v50; // eax
  unsigned __int8 *v51; // eax
  unsigned __int8 *v52; // eax
  int v53; // eax
  unsigned __int8 *v54; // eax
  unsigned __int8 *v55; // eax
  int v56; // eax
  unsigned __int8 *v57; // eax
  unsigned __int8 *v58; // eax
  int v59; // eax
  unsigned __int8 *v60; // eax
  unsigned __int8 *v61; // eax
  int v62; // eax
  int v63; // esi
  unsigned __int8 *v64; // eax
  unsigned __int8 *v65; // eax
  int v66; // eax
  int v67; // esi
  unsigned __int8 *v68; // eax
  unsigned __int8 *v69; // eax
  memory_list *v70; // eax
  bool v71; // zf
  unsigned __int8 *name; // ebx
  int terminal_codepage; // eax
  int v74; // esi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v76; // eax
  unsigned __int8 *v77; // kr00_4
  int v78; // edx
  int v79; // eax
  int v80; // esi
  unsigned __int8 *v81; // eax
  unsigned __int8 *v82; // eax
  unsigned __int8 *v83; // [esp+24h] [ebp-434h]
  unsigned __int8 *v84; // [esp+24h] [ebp-434h]
  unsigned __int8 *v85; // [esp+24h] [ebp-434h]
  unsigned __int8 *v86; // [esp+24h] [ebp-434h]
  unsigned __int8 *v87; // [esp+24h] [ebp-434h]
  unsigned __int8 *v88; // [esp+24h] [ebp-434h]
  unsigned __int8 *v89; // [esp+24h] [ebp-434h]
  unsigned __int8 *v90; // [esp+24h] [ebp-434h]
  unsigned __int8 *v91; // [esp+24h] [ebp-434h]
  unsigned __int8 *v92; // [esp+24h] [ebp-434h]
  unsigned __int8 *v93; // [esp+24h] [ebp-434h]
  unsigned __int8 *v94; // [esp+24h] [ebp-434h]
  unsigned __int8 *v95; // [esp+24h] [ebp-434h]
  unsigned __int8 *v96; // [esp+24h] [ebp-434h]
  unsigned __int8 *v97; // [esp+24h] [ebp-434h]
  unsigned __int8 *v98; // [esp+24h] [ebp-434h]
  unsigned __int8 *v99; // [esp+24h] [ebp-434h]
  unsigned __int8 *v100; // [esp+24h] [ebp-434h]
  int number; // [esp+28h] [ebp-430h]
  int n; // [esp+2Ch] [ebp-42Ch]
  int *na; // [esp+2Ch] [ebp-42Ch]
  unsigned __int8 help_text[1024]; // [esp+3Ch] [ebp-41Ch] BYREF
  unsigned int v105; // [esp+43Ch] [ebp-1Ch]

  v105 = __readgsdword(0x14u);
  number = get_opt_(cmdline_options, "anonymous")->number;
  if ( term->height > 30 )
  {
    name = term->spec->name;
    terminal_codepage = get_terminal_codepage(term);
    v74 = terminal_codepage;
    if ( terminal_codepage != current_charset )
    {
      cp_mime_name = get_cp_mime_name(terminal_codepage);
      bind_textdomain_codeset("elinks", cp_mime_name);
      current_charset = v74;
    }
    v76 = gettext(&byte_811AAEC);
    __snprintf_chk(help_text, 1021, 1, 1024, (const char *)v76, name);
    v77 = &help_text[strlen((const char *)help_text)];
    v78 = v77 - help_text;
    help_text[v78] = 10;
    v4 = v77 - help_text + 2;
    help_text[v78 + 1] = 10;
    v3 = v77 - help_text + 1079;
    n = v77 - help_text + 3;
  }
  else
  {
    v3 = 1077;
    v4 = 0;
    n = 1;
  }
  help_text[v4] = 0;
  v5 = (option_value *)mem_calloc(1u, v3);
  v6 = v5;
  if ( v5 )
  {
    v7 = (int *)&v5[261];
    checkout_option_values(resolvers, term->spec, v5 + 261, 8);
    v8 = get_terminal_codepage(term);
    if ( v8 != current_charset )
    {
      v83 = (unsigned __int8 *)v8;
      v9 = get_cp_mime_name(v8);
      bind_textdomain_codeset("elinks", v9);
      current_charset = (int)v83;
    }
    v10 = gettext(&byte_812B83A);
    LOBYTE(v6[7].tree) |= 2u;
    v6->number = (int)v10;
    v6[4].number = (int)generic_dialog_layouter;
    v6[1].number = (int)v7;
    memcpy(v7 + 8, help_text, n);
    add_dlg_text((dialog *)v6, (unsigned __int8 *)v7 + 32, ALIGN_LEFT, 1);
    v11 = get_terminal_codepage(term);
    if ( v11 != current_charset )
    {
      v84 = (unsigned __int8 *)v11;
      v12 = get_cp_mime_name(v11);
      bind_textdomain_codeset("elinks", v12);
      current_charset = (int)v84;
    }
    v13 = gettext(&byte_812BB47);
    add_dlg_text((dialog *)v6, v13, ALIGN_LEFT, 1);
    v14 = get_terminal_codepage(term);
    if ( v14 != current_charset )
    {
      v85 = (unsigned __int8 *)v14;
      v15 = get_cp_mime_name(v14);
      bind_textdomain_codeset("elinks", v15);
      current_charset = (int)v85;
    }
    v16 = gettext(&byte_812BB57);
    add_dlg_radio_do((dialog *)v6, v16, 1, 0, v7);
    v17 = get_terminal_codepage(term);
    if ( v17 != current_charset )
    {
      v86 = (unsigned __int8 *)v17;
      v18 = get_cp_mime_name(v17);
      bind_textdomain_codeset("elinks", v18);
      current_charset = (int)v86;
    }
    v19 = gettext(&byte_812BB61);
    add_dlg_radio_do((dialog *)v6, v19, 1, 1, v7);
    v20 = get_terminal_codepage(term);
    if ( v20 != current_charset )
    {
      v87 = (unsigned __int8 *)v20;
      v21 = get_cp_mime_name(v20);
      bind_textdomain_codeset("elinks", v21);
      current_charset = (int)v87;
    }
    v22 = gettext(&byte_812BB6F);
    add_dlg_radio_do((dialog *)v6, v22, 1, 2, v7);
    v23 = get_terminal_codepage(term);
    if ( v23 != current_charset )
    {
      v88 = (unsigned __int8 *)v23;
      v24 = get_cp_mime_name(v23);
      bind_textdomain_codeset("elinks", v24);
      current_charset = (int)v88;
    }
    v25 = gettext(&byte_812BB84);
    add_dlg_radio_do((dialog *)v6, v25, 1, 4, v7);
    v26 = get_terminal_codepage(term);
    if ( v26 != current_charset )
    {
      v89 = (unsigned __int8 *)v26;
      v27 = get_cp_mime_name(v26);
      bind_textdomain_codeset("elinks", v27);
      current_charset = (int)v89;
    }
    v28 = gettext(&byte_812BB93);
    add_dlg_radio_do((dialog *)v6, v28, 1, 3, v7);
    v29 = get_terminal_codepage(term);
    if ( v29 != current_charset )
    {
      v90 = (unsigned __int8 *)v29;
      v30 = get_cp_mime_name(v29);
      bind_textdomain_codeset("elinks", v30);
      current_charset = (int)v90;
    }
    v31 = gettext(&byte_812BBA1);
    add_dlg_text((dialog *)v6, v31, ALIGN_LEFT, 1);
    na = v7 + 4;
    v32 = get_terminal_codepage(term);
    if ( v32 != current_charset )
    {
      v91 = (unsigned __int8 *)v32;
      v33 = get_cp_mime_name(v32);
      bind_textdomain_codeset("elinks", v33);
      current_charset = (int)v91;
    }
    v34 = gettext(&byte_812BBAD);
    add_dlg_radio_do((dialog *)v6, v34, 2, 0, na);
    v35 = get_terminal_codepage(term);
    if ( v35 != current_charset )
    {
      v92 = (unsigned __int8 *)v35;
      v36 = get_cp_mime_name(v35);
      bind_textdomain_codeset("elinks", v36);
      current_charset = (int)v92;
    }
    v37 = gettext(&byte_812BBBE);
    add_dlg_radio_do((dialog *)v6, v37, 2, 1, na);
    v38 = get_terminal_codepage(term);
    if ( v38 != current_charset )
    {
      v93 = (unsigned __int8 *)v38;
      v39 = get_cp_mime_name(v38);
      bind_textdomain_codeset("elinks", v39);
      current_charset = (int)v93;
    }
    v40 = gettext(&byte_812BBC8);
    add_dlg_radio_do((dialog *)v6, v40, 2, 2, na);
    v41 = get_terminal_codepage(term);
    if ( v41 != current_charset )
    {
      v94 = (unsigned __int8 *)v41;
      v42 = get_cp_mime_name(v41);
      bind_textdomain_codeset("elinks", v42);
      current_charset = (int)v94;
    }
    v43 = gettext(&byte_812BBD2);
    add_dlg_radio_do((dialog *)v6, v43, 2, 3, na);
    v44 = get_terminal_codepage(term);
    if ( v44 != current_charset )
    {
      v95 = (unsigned __int8 *)v44;
      v45 = get_cp_mime_name(v44);
      bind_textdomain_codeset("elinks", v45);
      current_charset = (int)v95;
    }
    v46 = gettext(&byte_812A3D0);
    add_dlg_radio_do((dialog *)v6, v46, 0, 0, v7 + 1);
    v47 = get_terminal_codepage(term);
    if ( v47 != current_charset )
    {
      v96 = (unsigned __int8 *)v47;
      v48 = get_cp_mime_name(v47);
      bind_textdomain_codeset("elinks", v48);
      current_charset = (int)v96;
    }
    v49 = gettext(&byte_812A40E);
    add_dlg_radio_do((dialog *)v6, v49, 0, 0, v7 + 2);
    v50 = get_terminal_codepage(term);
    if ( v50 != current_charset )
    {
      v97 = (unsigned __int8 *)v50;
      v51 = get_cp_mime_name(v50);
      bind_textdomain_codeset("elinks", v51);
      current_charset = (int)v97;
    }
    v52 = gettext(&byte_812A438);
    add_dlg_radio_do((dialog *)v6, v52, 0, 0, v7 + 3);
    v53 = get_terminal_codepage(term);
    if ( v53 != current_charset )
    {
      v98 = (unsigned __int8 *)v53;
      v54 = get_cp_mime_name(v53);
      bind_textdomain_codeset("elinks", v54);
      current_charset = (int)v98;
    }
    v55 = gettext(&byte_812A452);
    add_dlg_radio_do((dialog *)v6, v55, 0, 0, v7 + 6);
    v56 = get_terminal_codepage(term);
    if ( v56 != current_charset )
    {
      v99 = (unsigned __int8 *)v56;
      v57 = get_cp_mime_name(v56);
      bind_textdomain_codeset("elinks", v57);
      current_charset = (int)v99;
    }
    v58 = gettext(&byte_8129B1D);
    add_dlg_radio_do((dialog *)v6, v58, 0, 0, v7 + 7);
    v59 = get_terminal_codepage(term);
    if ( v59 != current_charset )
    {
      v100 = (unsigned __int8 *)v59;
      v60 = get_cp_mime_name(v59);
      bind_textdomain_codeset("elinks", v60);
      current_charset = (int)v100;
    }
    v61 = gettext(&byte_812A3F7);
    add_dlg_radio_do((dialog *)v6, v61, 0, 0, v7 + 5);
    v62 = get_terminal_codepage(term);
    v63 = v62;
    if ( v62 != current_charset )
    {
      v64 = get_cp_mime_name(v62);
      bind_textdomain_codeset("elinks", v64);
      current_charset = v63;
    }
    v65 = gettext(&okbutton);
    add_dlg_button_do((dialog *)v6, v65, 1, push_ok_button, 0, 0, 0);
    if ( !number )
    {
      v79 = get_terminal_codepage(term);
      v80 = v79;
      if ( v79 != current_charset )
      {
        v81 = get_cp_mime_name(v79);
        bind_textdomain_codeset("elinks", v81);
        current_charset = v80;
      }
      v82 = gettext(&byte_81283FD);
      add_dlg_button_do((dialog *)v6, v82, 1, push_save_button_1, 0, 0, 0);
    }
    v66 = get_terminal_codepage(term);
    v67 = v66;
    if ( v66 != current_charset )
    {
      v68 = get_cp_mime_name(v66);
      bind_textdomain_codeset("elinks", v68);
      current_charset = v67;
    }
    v69 = gettext(&cancelbutton);
    add_dlg_button_do((dialog *)v6, v69, 2, cancel_dialog, 0, 0, 0);
    if ( !assert_failed )
    {
      v71 = 21 - number == v6[8].number;
      assert_failed = 21 - number != v6[8].number;
      if ( !v71 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/options.c";
        errline = 239;
        elinks_internal("assertion (19 + 1 + 1 + 0) - anonymous == (dlg)->number_of_widgets failed!");
      }
    }
    v70 = getml(v6, 0);
    do_dialog(term, (dialog *)v6, v70);
  }
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0807F660) --------------------------------------------------------
void __cdecl draw_progress_bar(
        progress *progress,
        terminal *term,
        int x,
        int y,
        int width,
        unsigned __int8 *text,
        color_pair *meter_color)
{
  int v7; // ebx
  unsigned __int8 *v8; // edi
  int v9; // esi
  int v10; // edx
  int v11; // ecx
  int v12; // ecx
  signed int v13; // eax
  int v14; // eax
  int v15; // edx
  unsigned int v16; // eax
  int v17; // edi
  unsigned int v18; // ebx
  int percent; // [esp+38h] [ebp-40h]
  box barprogress; // [esp+4Ch] [ebp-2Ch] BYREF
  int slen[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v7 = width;
  v8 = text;
  if ( progress->size > 0 )
    percent = 100 * progress->pos / progress->size;
  else
    percent = 0;
  if ( text || width <= 2 )
  {
    v9 = x;
  }
  else
  {
    v7 = width - 2;
    v9 = x + 1;
    draw_text(term, x, y, (unsigned __int8 *)"[", 1, (screen_char_attr)0, 0);
    draw_text(term, width - 2 + x + 1, y, (unsigned __int8 *)"]", 1, (screen_char_attr)0, 0);
  }
  if ( !meter_color )
    meter_color = get_bfu_color(term, "dialog.meter");
  barprogress.height = 1;
  v10 = v7 * percent / 100;
  if ( v10 > v7 )
    v10 = v7;
  v11 = 0;
  if ( v9 >= 0 )
    v11 = v9;
  barprogress.x = v11;
  v12 = y;
  if ( y < 0 )
    v12 = 0;
  if ( v10 < 0 )
    v10 = 0;
  barprogress.width = v10;
  barprogress.y = v12;
  draw_box(term, &barprogress, 0x20u, (screen_char_attr)0, meter_color);
  if ( text )
  {
    v13 = strlen((const char *)text);
    if ( v7 >= v13 )
      v7 = v13;
  }
  else if ( v7 > 1 )
  {
    v14 = 5;
    if ( v7 <= 5 )
      v14 = v7;
    slen[0] = 0;
    if ( elinks_ulongcat(s_6003, (unsigned int *)slen, percent, v14 - 1, 0, 0xAu, 0) )
    {
      s_6003[0] = 63;
      v17 = -1;
      v16 = 2;
      v15 = 1;
    }
    else
    {
      v15 = slen[0];
      v16 = slen[0] + 1;
      v17 = -slen[0];
    }
    s_6003[v15] = 37;
    slen[0] = v16;
    if ( !assert_failed )
    {
      assert_failed = v7 < v16;
      if ( v7 < v16 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/progress.c";
        errline = 136;
        elinks_internal("assertion slen <= width failed!");
        v16 = slen[0];
      }
    }
    v18 = v17 + v7;
    v8 = s_6003;
    v9 += v18 >> 1;
    v7 = v16;
  }
  draw_text(term, v9, y, v8, v7, (screen_char_attr)0, 0);
}
// 81409C0: using guessed type unsigned __int8 s_6003[32];
// 807F660: using guessed type unsigned int slen[7];

//----- (0807F950) --------------------------------------------------------
unsigned __int8 *__cdecl get_progress_msg(
        progress *progress,
        terminal *term,
        int wide,
        int full,
        unsigned __int8 *separator)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // eax
  const unsigned __int8 *v13; // edi
  unsigned __int8 *v14; // eax
  int v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // edx
  int v18; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // edx
  int v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // edi
  int v24; // eax
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // edi
  int v27; // eax
  unsigned __int8 *v28; // eax
  int v29; // [esp+14h] [ebp-34h]
  int v30; // [esp+14h] [ebp-34h]
  int v31; // [esp+18h] [ebp-30h]
  int v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+18h] [ebp-30h]
  unsigned __int8 *v34; // [esp+18h] [ebp-30h]
  unsigned __int8 *v35; // [esp+18h] [ebp-30h]
  int v36; // [esp+18h] [ebp-30h]
  int v37; // [esp+18h] [ebp-30h]
  unsigned __int8 newlines; // [esp+1Ch] [ebp-2Ch]
  int newlinesa; // [esp+1Ch] [ebp-2Ch]
  string msg; // [esp+28h] [ebp-20h] BYREF

  newlines = separator[strlen((const char *)separator) - 1];
  inited = init_string(&msg);
  result = 0;
  if ( inited )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        v31 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v31;
      }
    }
    v9 = gettext(&byte_812BBDD);
    add_to_string(&msg, v9);
    add_char_to_string(&msg, 0x20u);
    add_xnum_to_string(&msg, progress->pos);
    if ( progress->size >= 0 )
    {
      add_char_to_string(&msg, 0x20u);
      if ( term )
      {
        v10 = get_terminal_codepage(term);
        if ( v10 != current_charset )
        {
          v32 = v10;
          v11 = get_cp_mime_name(v10);
          bind_textdomain_codeset("elinks", v11);
          current_charset = v32;
        }
      }
      v12 = gettext(&byte_812F636);
      add_to_string(&msg, v12);
      add_char_to_string(&msg, 0x20u);
      add_xnum_to_string(&msg, progress->size);
    }
    newlinesa = newlines == 10;
    add_to_string(&msg, separator);
    if ( wide )
    {
      v17 = "avg";
      if ( full )
      {
        v17 = "average speed";
        if ( newlinesa )
          v17 = (unsigned __int8 *)&unk_812BBF4;
      }
      if ( *v17 )
      {
        if ( term )
        {
          v34 = v17;
          v18 = get_terminal_codepage(term);
          v17 = v34;
          if ( v18 != current_charset )
          {
            v29 = v18;
            v19 = get_cp_mime_name(v18);
            bind_textdomain_codeset("elinks", v19);
            v17 = v34;
            current_charset = v29;
          }
        }
        v17 = gettext(v17);
      }
      add_to_string(&msg, v17);
      add_char_to_string(&msg, 0x20u);
      add_xnum_to_string(&msg, progress->average_speed);
      add_to_string(&msg, (const unsigned __int8 *)"/s");
      add_to_string(&msg, ", ");
      v20 = "current speed";
      if ( !full )
        v20 = (unsigned __int8 *)"cur";
      if ( *v20 )
      {
        if ( term )
        {
          v35 = v20;
          v21 = get_terminal_codepage(term);
          v20 = v35;
          if ( v21 != current_charset )
          {
            v30 = v21;
            v22 = get_cp_mime_name(v21);
            bind_textdomain_codeset("elinks", v22);
            v20 = v35;
            current_charset = v30;
          }
        }
        v20 = gettext(v20);
      }
      add_to_string(&msg, v20);
      add_char_to_string(&msg, 0x20u);
      add_xnum_to_string(&msg, progress->current_speed);
      add_to_string(&msg, (const unsigned __int8 *)"/s");
      v23 = (unsigned __int8 *)&byte_812BC2E;
      add_to_string(&msg, separator);
      if ( full )
      {
        v23 = "elapsed time";
        if ( newlinesa )
          v23 = "Elapsed time";
      }
      if ( *v23 )
      {
        if ( term )
        {
          v24 = get_terminal_codepage(term);
          if ( v24 != current_charset )
          {
            v36 = v24;
            v25 = get_cp_mime_name(v24);
            bind_textdomain_codeset("elinks", v25);
            current_charset = v36;
          }
        }
        v23 = gettext(v23);
      }
      add_to_string(&msg, v23);
      add_char_to_string(&msg, 0x20u);
      add_timeval_to_string(&msg, &progress->elapsed);
    }
    else
    {
      v13 = "speed";
      if ( newlinesa )
        v13 = "Speed";
      v14 = (unsigned __int8 *)v13;
      if ( *v13 )
      {
        if ( term )
        {
          v15 = get_terminal_codepage(term);
          if ( v15 != current_charset )
          {
            v33 = v15;
            v16 = get_cp_mime_name(v15);
            bind_textdomain_codeset("elinks", v16);
            current_charset = v33;
          }
        }
        v14 = gettext(v13);
      }
      add_to_string(&msg, v14);
      add_char_to_string(&msg, 0x20u);
      add_xnum_to_string(&msg, progress->average_speed);
      add_to_string(&msg, (const unsigned __int8 *)"/s");
    }
    if ( progress->size >= 0 && progress->loaded > 0 )
    {
      v26 = "estimated time";
      add_to_string(&msg, ", ");
      if ( !full )
        v26 = (unsigned __int8 *)"ETA";
      if ( *v26 )
      {
        if ( term )
        {
          v27 = get_terminal_codepage(term);
          if ( v27 != current_charset )
          {
            v37 = v27;
            v28 = get_cp_mime_name(v27);
            bind_textdomain_codeset("elinks", v28);
            current_charset = v37;
          }
        }
        v26 = gettext(v26);
      }
      add_to_string(&msg, v26);
      add_char_to_string(&msg, 0x20u);
      add_timeval_to_string(&msg, &progress->estimated_time);
    }
    return msg.source;
  }
  return result;
}

//----- (0807FE70) --------------------------------------------------------
string *__usercall add_bytes_to_string___0@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (0807FFC0) --------------------------------------------------------
void update_status()
{
  int number; // esi
  option_value *opt; // eax
  session *next; // ebx
  terminal *v3; // eax
  window *tab; // edx
  terminal *term; // esi
  char status; // al
  char v7; // dl
  int v8; // ecx
  int v9; // edx
  char v10; // cl
  int v11; // edi
  _BOOL4 v12; // ecx
  bool v13; // dl
  char v14; // cl
  terminal_screen *screen; // eax
  int height; // edx
  char v17; // [esp+1Fh] [ebp-49h]
  int show_tabs_bar_at_top; // [esp+30h] [ebp-38h]
  char v19; // [esp+37h] [ebp-31h]
  int insert_mode; // [esp+38h] [ebp-30h]
  int show_leds; // [esp+3Ch] [ebp-2Ch]
  int tabs_count; // [esp+40h] [ebp-28h]
  int show_tabs_bar; // [esp+44h] [ebp-24h]
  int show_title_bar; // [esp+48h] [ebp-20h]
  int show_status_bar; // [esp+4Ch] [ebp-1Ch]

  show_title_bar = get_opt_(config_options, "ui.show_title_bar")->number;
  show_status_bar = get_opt_(config_options, "ui.show_status_bar")->number;
  show_tabs_bar = get_opt_(config_options, "ui.tabs.show_bar")->number;
  show_tabs_bar_at_top = get_opt_(config_options, "ui.tabs.top")->number;
  show_leds = get_opt_(config_options, "ui.leds.enable")->number;
  number = get_opt_(config_options, "ui.window_title")->number;
  opt = get_opt_(config_options, "document.browse.forms.insert_mode");
  next = (session *)sessions.next;
  insert_mode = opt->number;
  if ( sessions.next != &sessions )
  {
    v3 = 0;
    tabs_count = 1;
    v19 = (_BYTE)number << 7;
    while ( 1 )
    {
      tab = next->tab;
      term = tab->term;
      if ( term != v3 )
        tabs_count = number_of_tabs(tab->term);
      status = (char)next->status;
      v7 = (char)(2 * status) >> 6;
      v8 = v7;
      if ( v7 < 0 )
        v8 = show_title_bar;
      v9 = 0;
      show_title_bar = v8;
      if ( ((status & 4) != 0) != v8 )
      {
        status = (4 * (v8 & 1)) | status & 0xFB;
        v9 = 1;
        *(_BYTE *)&next->status = status;
      }
      v10 = (char)(8 * status) >> 6;
      v11 = v10;
      if ( v10 < 0 )
        v11 = show_status_bar;
      show_status_bar = v11;
      if ( ((status & 2) != 0) != v11 )
      {
        status = (2 * (v11 & 1)) | status & 0xFD;
        v9 = 1;
        *(_BYTE *)&next->status = status;
      }
      v12 = 0;
      if ( show_tabs_bar > 0 )
        v12 = show_tabs_bar != 1 || tabs_count > 1;
      if ( v12 != (status & 1) )
      {
        v13 = 0;
        if ( show_tabs_bar > 0 )
          v13 = show_tabs_bar != 1 || tabs_count > 1;
        status = v13 | status & 0xFE;
        v9 = 1;
        *(_BYTE *)&next->status = status;
      }
      if ( (status & 1) != 0 )
      {
        v17 = *((_BYTE *)&next->status + 52);
        if ( ((v17 & 4) != 0) != show_tabs_bar_at_top )
        {
          v9 = 1;
          *((_BYTE *)&next->status + 52) = (4 * (show_tabs_bar_at_top & 1)) | v17 & 0xFB;
        }
      }
      v14 = *((_BYTE *)&next->status + 8);
      if ( (v14 & 1) != show_leds )
      {
        v9 = 1;
        *((_BYTE *)&next->status + 8) = show_leds & 1 | v14 & 0xFE;
      }
      *(_BYTE *)&next->status = v19 | status & 0x7F;
      if ( !insert_mode )
        break;
      if ( next->insert_mode )
        goto LABEL_4;
      next->insert_mode = INSERT_MODE_OFF;
      if ( !v9 )
        goto LABEL_5;
LABEL_31:
      render_document_frames(next, 1);
      screen = term->screen;
      height = term->height;
      if ( screen->dirty_from > 0 )
        screen->dirty_from = 0;
      if ( height <= screen->dirty_to )
      {
LABEL_5:
        next = next->next;
        if ( next == (session *)&sessions )
          return;
        goto LABEL_6;
      }
      screen->dirty_to = height;
      next = next->next;
      if ( next == (session *)&sessions )
        return;
LABEL_6:
      v3 = term;
    }
    next->insert_mode = INSERT_MODE_LESS;
LABEL_4:
    if ( !v9 )
      goto LABEL_5;
    goto LABEL_31;
  }
}

//----- (080802A0) --------------------------------------------------------
unsigned __int8 *__cdecl get_download_msg(
        download *download,
        terminal *term,
        int wide,
        int full,
        unsigned __int8 *separator)
{
  unsigned __int8 *state_message; // eax

  if ( download_is_progressing(download) )
    return get_progress_msg(download->progress, term, wide, full, separator);
  state_message = get_state_message(download->state, term);
  return stracpy(state_message);
}

//----- (08080330) --------------------------------------------------------
void __cdecl print_screen_status(session *ses)
{
  window *tab; // ebx
  int v2; // ebx
  int v3; // edi
  int v4; // ecx
  int v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // edx
  char v9; // al
  int v10; // edx
  int v11; // ebx
  terminal *v12; // edi
  download *v13; // edx
  session *v14; // eax
  int v15; // esi
  document_view *v16; // eax
  unsigned __int8 *v17; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v20; // eax
  char v21; // al
  int v22; // eax
  int v23; // eax
  unsigned __int8 *v24; // eax
  int status; // eax
  document_view *doc_view; // eax
  document *document; // eax
  const unsigned __int8 *title; // eax
  unsigned __int8 *v29; // ebx
  size_t v30; // eax
  char v31; // al
  document_view *v32; // eax
  document *v33; // eax
  cache_entry *cached; // eax
  insert_mode insert_mode; // eax
  char v36; // al
  download *current_download; // edi
  $A432824C7AF5BC859123DC670ECB2CAE mark; // eax
  unsigned __int8 *download_msg; // ebx
  int v40; // eax
  int v41; // edx
  int v42; // edx
  color_pair *v43; // eax
  color_pair *v44; // esi
  progress *progress; // ebx
  int v46; // esi
  signed int v47; // ecx
  int v48; // eax
  unsigned int v49; // eax
  unsigned int v50; // eax
  int v51; // eax
  int v52; // edx
  color_pair *bfu_color; // eax
  document_view *v54; // eax
  document_view *v55; // ebx
  int height; // ecx
  int v57; // esi
  view_state *vs; // eax
  int v59; // ebx
  int v60; // edi
  int v61; // eax
  int v62; // edi
  const unsigned __int8 *v63; // ebx
  int v64; // esi
  int v65; // eax
  int v66; // ebx
  color_pair *v67; // eax
  document_view *v68; // eax
  document_view *v69; // ebx
  view_state *v70; // eax
  int current_link; // edx
  unsigned __int8 *last_title; // esi
  int v73; // eax
  int v74; // ebx
  int v75; // eax
  int v76; // eax
  document *v77; // edx
  unsigned __int8 *current_link_title; // esi
  bool v79; // zf
  unsigned __int8 *text; // [esp+28h] [ebp-B0h]
  unsigned __int8 *textc; // [esp+28h] [ebp-B0h]
  unsigned __int8 *textd; // [esp+28h] [ebp-B0h]
  unsigned __int8 *texta; // [esp+28h] [ebp-B0h]
  unsigned __int8 *textb; // [esp+28h] [ebp-B0h]
  color_pair *v85; // [esp+2Ch] [ebp-ACh]
  color_pair *v86; // [esp+30h] [ebp-A8h]
  color_pair *v87; // [esp+34h] [ebp-A4h]
  color_pair *v88; // [esp+38h] [ebp-A0h]
  color_pair *v89; // [esp+3Ch] [ebp-9Ch]
  int v90; // [esp+44h] [ebp-94h]
  int width; // [esp+50h] [ebp-88h]
  int tabs_count; // [esp+58h] [ebp-80h]
  int v93; // [esp+5Ch] [ebp-7Ch]
  color_pair *color; // [esp+60h] [ebp-78h]
  unsigned __int8 *str; // [esp+64h] [ebp-74h]
  unsigned __int8 *stra; // [esp+64h] [ebp-74h]
  unsigned __int8 *strb; // [esp+64h] [ebp-74h]
  terminal *term; // [esp+68h] [ebp-70h]
  unsigned __int8 *v99; // [esp+68h] [ebp-70h]
  session *v100; // [esp+6Ch] [ebp-6Ch]
  session *v101; // [esp+6Ch] [ebp-6Ch]
  session *v102; // [esp+6Ch] [ebp-6Ch]
  box x; // [esp+78h] [ebp-60h] BYREF
  string string; // [esp+88h] [ebp-50h] BYREF
  unsigned int slen; // [esp+90h] [ebp-48h] BYREF
  unsigned __int8 s[40]; // [esp+94h] [ebp-44h] BYREF
  unsigned int v107; // [esp+BCh] [ebp-1Ch]

  v107 = __readgsdword(0x14u);
  term = ses->tab->term;
  tabs_count = number_of_tabs(term);
  tab = ses->tab;
  if ( tab != get_tab_by_number(term, term->current_tab) )
    goto LABEL_2;
  LOBYTE(status) = ses->status;
  if ( (status & 0x80u) != 0 )
  {
    doc_view = ses->doc_view;
    if ( doc_view && (document = doc_view->document) != 0 && (title = document->title) != 0 && *title )
      v29 = straconcat(title, &unk_812BDA0, 0);
    else
      v29 = stracpy("ELinks");
    if ( v29 )
    {
      v30 = strlen((const char *)v29);
      if ( ses == (session *)last_ses_9168
        && (last_title = ses->status.last_title) != 0
        && (textb = (unsigned __int8 *)v30, v30 == strlen((const char *)last_title))
        && !memcmp(last_title, v29, (unsigned int)textb)
        || set_terminal_title(term, v29) < 0 )
      {
        mem_free(v29);
        LOBYTE(status) = ses->status;
      }
      else
      {
        if ( ses->status.last_title )
          mem_free(ses->status.last_title);
        ses->status.last_title = v29;
        last_ses_9168 = (int)ses;
        LOBYTE(status) = ses->status;
      }
    }
    else
    {
      LOBYTE(status) = ses->status;
    }
  }
  if ( (status & 4) != 0 )
  {
    if ( !get_opt_(config_options, "ui.show_menu_bar_always")->number )
    {
      v51 = 0;
      v52 = term->width;
      x.x = 0;
      x.y = 0;
      x.height = 1;
      if ( v52 >= 0 )
        v51 = v52;
      x.width = v51;
      bfu_color = get_bfu_color(term, "title.title-bar");
      draw_box(term, &x, 0x20u, (screen_char_attr)0, bfu_color);
    }
    v54 = current_frame(ses);
    v55 = v54;
    if ( !v54 )
    {
      status = (int)ses->status;
      goto LABEL_65;
    }
    if ( !v54->document )
    {
      LOBYTE(status) = ses->status;
      goto LABEL_65;
    }
    if ( !init_string(&string) )
    {
LABEL_137:
      LOBYTE(status) = ses->status;
      goto LABEL_65;
    }
    stra = (unsigned __int8 *)v55->document;
    height = v55->box.height;
    v57 = *((_DWORD *)stra + 64);
    if ( height >= v57 )
      goto LABEL_151;
    vs = v55->vs;
    if ( !vs )
      goto LABEL_151;
    v59 = 1;
    v60 = height + vs->y;
    if ( height )
      v59 = (v57 + height - 1) / height;
    v61 = v59;
    if ( v57 > v60 )
    {
      v61 = 1;
      if ( height )
      {
        v61 = (v60 - height / 2) / height + 1;
        if ( v59 <= v61 )
          v61 = v59;
      }
    }
    v62 = __snprintf_chk(s, 40, 1, 40, " (%d/%d)", v61, v59);
    if ( v62 < 0 )
LABEL_151:
      v62 = 0;
    v63 = (const unsigned __int8 *)*((_DWORD *)stra + 47);
    if ( !v63 )
    {
LABEL_130:
      if ( v62 )
        add_bytes_to_string___0(&string, s, v62);
      if ( !string.length )
        goto LABEL_136;
      if ( (*((_BYTE *)term + 56) & 2) != 0 )
      {
        v74 = term->width - 1;
        v66 = v74 - utf8_ptr2cells(string.source, &string.source[string.length]);
        if ( v66 > 0 )
          goto LABEL_135;
      }
      else
      {
        v66 = term->width + ~string.length;
        if ( v66 > 0 )
        {
LABEL_135:
          v67 = get_bfu_color(term, "title.title-text");
          draw_text(term, v66, 0, string.source, string.length, (screen_char_attr)0, v67);
LABEL_136:
          done_string(&string);
          goto LABEL_137;
        }
      }
      v66 = 0;
      goto LABEL_135;
    }
    v64 = 0;
    if ( term->width - 4 - v62 >= 0 )
      v64 = term->width - 4 - v62;
    if ( (*((_BYTE *)term + 56) & 2) != 0 )
    {
      v73 = utf8_ptr2cells(*((unsigned __int8 **)stra + 47), 0);
      if ( v73 > v64 )
        v73 = v64;
      v102 = (session *)v73;
      v65 = utf8_cells2bytes(*((unsigned __int8 **)stra + 47), v73, 0);
      v63 = (const unsigned __int8 *)*((_DWORD *)stra + 47);
    }
    else
    {
      v65 = strlen(*((const char **)stra + 47));
      if ( v65 >= v64 )
      {
        add_bytes_to_string___0(&string, v63, v64);
LABEL_158:
        add_bytes_to_string___0(&string, &bytes, 3);
        goto LABEL_130;
      }
      v102 = (session *)v65;
    }
    add_bytes_to_string___0(&string, v63, v65);
    if ( v102 != (session *)v64 )
      goto LABEL_130;
    goto LABEL_158;
  }
LABEL_65:
  if ( (status & 2) == 0 )
  {
LABEL_66:
    v31 = *((_BYTE *)&ses->status + 8);
    goto LABEL_67;
  }
  slen = 0;
  current_download = get_current_download(ses);
  mark = ses->kbdprefix.mark;
  if ( mark == KP_MARK_NOTHING )
  {
    if ( ses->kbdprefix.repeat_count )
    {
      download_msg = msg_text(term, "Keyboard prefix: %d", ses->kbdprefix.repeat_count);
      goto LABEL_85;
    }
    if ( !current_download )
      goto LABEL_84;
    v68 = current_frame(ses);
    v69 = v68;
    if ( v68 )
    {
      v70 = v68->vs;
      if ( v70 )
      {
        current_link = v70->current_link;
        if ( current_download->state.basic == S_INTERRUPTED && current_link != last_current_link_8807 )
        {
          if ( assert_failed )
          {
            assert_failed = 0;
            v75 = -100003;
          }
          else
          {
            assert_failed = 0;
            v75 = -100000;
          }
          current_download->state.basic = v75;
          current_download->state.syserr = 0;
        }
        last_current_link_8807 = current_link;
        if ( current_download->state.basic == S_OK )
        {
          v76 = v69->vs->current_link;
          if ( v76 >= 0 && (v77 = v69->document, v76 < v77->nlinks) && &v77->links[v76] )
          {
            strb = get_current_link_info(ses, v69);
            if ( strb )
            {
              current_link_title = get_current_link_title(v69);
              if ( current_link_title )
              {
                if ( !assert_failed )
                {
                  v79 = *current_link_title != 0;
                  assert_failed = *current_link_title == 0;
                  if ( !v79 )
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dialogs/status.c";
                    errline = 153;
                    elinks_internal("assertion *link_title failed!");
                  }
                }
                download_msg = straconcat(strb, " - ", current_link_title, 0);
                mem_free(strb);
                mem_free(current_link_title);
                if ( download_msg )
                  goto LABEL_85;
              }
            }
            download_msg = strb;
          }
          else
          {
            if ( ses->navigate_mode != NAVIGATE_CURSOR_ROUTING )
              goto LABEL_146;
            download_msg = msg_text(term, "Cursor position: %dx%d", ses->tab->x + 1, ses->tab->y + 1);
          }
          if ( download_msg )
            goto LABEL_85;
        }
      }
    }
LABEL_146:
    download_msg = get_download_msg(
                     current_download,
                     term,
                     term->width > 80,
                     term->width > 130,
                     (unsigned __int8 *)", ");
    goto LABEL_85;
  }
  if ( mark != KP_MARK_SET )
  {
    if ( mark == KP_MARK_GOTO )
    {
      download_msg = msg_text(term, "Enter a mark to which to jump");
      goto LABEL_85;
    }
LABEL_84:
    download_msg = 0;
    goto LABEL_85;
  }
  download_msg = msg_text(term, "Enter a mark to set");
LABEL_85:
  v40 = term->width;
  v41 = term->height;
  x.x = 0;
  x.height = 1;
  v42 = v41 - 1;
  if ( v42 < 0 )
    v42 = 0;
  if ( v40 < 0 )
    v40 = 0;
  x.y = v42;
  x.width = v40;
  v43 = get_bfu_color(term, "status.status-bar");
  draw_box(term, &x, 0x20u, (screen_char_attr)0, v43);
  if ( tabs_count <= 1 || (*(_BYTE *)&ses->status & 1) != 0 )
  {
    v44 = 0;
  }
  else
  {
    v49 = slen;
    s[slen] = 91;
    slen = v49 + 1;
    elinks_ulongcat(s, &slen, term->current_tab + 1, 4u, 0, 0xAu, 0);
    v50 = slen;
    s[slen] = 93;
    s[v50 + 1] = 32;
    slen = v50 + 2;
    s[slen] = 0;
    v44 = get_bfu_color(term, "status.status-text");
    draw_text(term, 0, term->height - 1, s, slen, (screen_char_attr)0, v44);
  }
  if ( !download_msg )
    goto LABEL_66;
  if ( !v44 )
    v44 = get_bfu_color(term, "status.status-text");
  texta = (unsigned __int8 *)strlen((const char *)download_msg);
  draw_text(term, slen, term->height - 1, download_msg, (int)texta, (screen_char_attr)0, v44);
  mem_free(download_msg);
  if ( download_is_progressing(current_download) )
  {
    progress = current_download->progress;
    if ( progress->size < 0 )
    {
      v31 = *((_BYTE *)&ses->status + 8);
      goto LABEL_67;
    }
    if ( SHIDWORD(progress->size) <= 0 && !LODWORD(progress->size) )
    {
      v31 = *((_BYTE *)&ses->status + 8);
      goto LABEL_67;
    }
    v31 = *((_BYTE *)&ses->status + 8);
    v46 = term->width - 1;
    if ( (v31 & 1) != 0 )
      v46 -= term->leds_length;
    v47 = v46 - (_DWORD)texta + -1 - slen;
    if ( v47 < 0 || v47 <= 5 )
      goto LABEL_67;
    v48 = 20;
    if ( v47 <= 20 )
      v48 = v46 - (_DWORD)texta + -1 - slen;
    draw_progress_bar(progress, term, v46 - v48, term->height - 1, v48, 0, 0);
  }
  v31 = *((_BYTE *)&ses->status + 8);
LABEL_67:
  if ( (v31 & 1) != 0 )
  {
    v32 = ses->doc_view;
    if ( v32 )
    {
      v33 = v32->document;
      if ( v33 )
      {
        cached = v33->cached;
        if ( cached )
        {
          if ( cached->ssl_info )
            set_led_value(ses->status.ssl_led, 0x53u);
          else
            unset_led_value(ses->status.ssl_led);
        }
        else
        {
          set_led_value(ses->status.ssl_led, 0x3Fu);
        }
      }
    }
    insert_mode = ses->insert_mode;
    if ( insert_mode )
    {
      if ( insert_mode == INSERT_MODE_ON )
        set_led_value(ses->status.insert_mode_led, 0x49u);
      else
        unset_led_value(ses->status.insert_mode_led);
    }
    else
    {
      set_led_value(ses->status.insert_mode_led, 0x69u);
    }
    draw_leds(ses);
  }
  v36 = *((_BYTE *)&ses->status + 52);
  if ( (v36 & 1) == 0 )
    *((_BYTE *)&ses->status + 52) = v36 | 1;
LABEL_2:
  if ( (*(_BYTE *)&ses->status & 1) != 0 )
  {
    v2 = 1;
    v3 = 1;
    v86 = get_bfu_color(term, "tabs.normal");
    v89 = get_bfu_color(term, "tabs.selected");
    v88 = get_bfu_color(term, "tabs.loading");
    v85 = get_bfu_color(term, "tabs.unvisited");
    v87 = get_bfu_color(term, "tabs.separator");
    v4 = term->width;
    if ( v4 / tabs_count > 0 )
      v3 = term->width / tabs_count;
    v5 = 0;
    v6 = v4 - v3 * tabs_count;
    if ( v6 < 0 )
      v6 = 0;
    v93 = v6;
    v7 = v6 / tabs_count;
    if ( v7 > 0 )
      v2 = v7;
    v90 = v2;
    if ( (*((_BYTE *)&ses->status + 52) & 4) != 0 )
    {
      v21 = (char)ses->status;
      x.x = 0;
      x.height = 1;
      v22 = (v21 & 4) != 0;
      if ( v4 < 0 )
        v4 = 0;
      x.y = v22;
      x.width = v4;
    }
    else
    {
      v8 = term->height;
      v9 = (char)ses->status;
      x.x = 0;
      x.width = 0;
      x.height = 1;
      v10 = v8 - (2 - ((v9 & 2) == 0));
      if ( v10 >= 0 )
        v5 = v10;
      x.y = v5;
    }
    if ( tabs_count > 0 )
    {
      v11 = 0;
      width = v3 - 1;
      v12 = term;
      while ( 1 )
      {
        v15 = width;
        str = (unsigned __int8 *)get_tab_by_number(v12, v11);
        v100 = (session *)*((_DWORD *)str + 4);
        if ( v93 )
        {
          v15 = width + v90;
          v93 -= v90;
        }
        if ( v100 && (v16 = current_frame(v100)) != 0 )
        {
          v17 = v16->document->title;
          v99 = v17;
          if ( !v17 || !*v17 )
          {
            terminal_codepage = get_terminal_codepage(v12);
            if ( terminal_codepage != current_charset )
            {
              textc = (unsigned __int8 *)terminal_codepage;
              cp_mime_name = get_cp_mime_name(terminal_codepage);
              bind_textdomain_codeset("elinks", cp_mime_name);
              current_charset = (int)textc;
            }
            v99 = gettext(&byte_812BD8B);
          }
        }
        else
        {
          v23 = get_terminal_codepage(v12);
          if ( v23 != current_charset )
          {
            textd = (unsigned __int8 *)v23;
            v24 = get_cp_mime_name(v23);
            bind_textdomain_codeset("elinks", v24);
            current_charset = (int)textd;
          }
          v99 = gettext(&byte_812BD94);
        }
        if ( v11 )
          draw_char(v12, x.x++, x.y, 0xB3u, SCREEN_ATTR_FRAME, v87);
        if ( v11 == v12->current_tab )
          break;
        v13 = get_current_download(v100);
        if ( !v13 || (color = v88, v13->state.basic == S_OK) )
        {
          if ( !v100 || (color = v86, (*((_BYTE *)&v100->status + 52) & 1) == 0) )
            color = v85;
        }
        text = (unsigned __int8 *)v13;
        if ( !download_is_progressing(v13) || *(__int64 *)(*((_DWORD *)text + 6) + 44) <= 0 )
          goto LABEL_36;
        v101 = (session *)(v15 + 1);
        x.width = v15 + 1;
        draw_box(v12, &x, 0x20u, (screen_char_attr)0, color);
        draw_progress_bar(*((progress **)text + 6), v12, x.x, x.y, v15, v99, 0);
LABEL_20:
        *((_DWORD *)str + 6) = x.x;
        v14 = v101;
        if ( v11 != tabs_count - 1 )
          v14 = (session *)v15;
        ++v11;
        *((_DWORD *)str + 7) = v14;
        x.x += v15;
        if ( tabs_count <= v11 )
          goto LABEL_3;
      }
      color = v89;
LABEL_36:
      v101 = (session *)(v15 + 1);
      x.width = v15 + 1;
      draw_box(v12, &x, 0x20u, (screen_char_attr)0, color);
      if ( (*((_BYTE *)v12 + 56) & 2) != 0 )
      {
        v20 = (unsigned __int8 *)(utf8_step_forward(v99, 0, v15, UTF8_STEP_CELLS_FEWER, 0) - v99);
      }
      else
      {
        v20 = (unsigned __int8 *)strlen((const char *)v99);
        if ( v15 <= (int)v20 )
          v20 = (unsigned __int8 *)v15;
      }
      draw_text(v12, x.x, x.y, v99, (int)v20, (screen_char_attr)0, color);
      goto LABEL_20;
    }
  }
LABEL_3:
  redraw_from_window(ses->tab);
}
// 8080A86: conditional instruction was optimized away because eax.4>=2u
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 81493A4: using guessed type int last_ses_9168;
// 81493A8: using guessed type int last_current_link_8807;

//----- (08081380) --------------------------------------------------------
line *__cdecl realloc_lines(document *document, int y)
{
  int height; // edi
  unsigned int v4; // edi
  unsigned int v5; // ecx
  int v6; // edx
  line *v7; // eax
  int v8; // [esp+18h] [ebp-20h]

  if ( assert_failed
    || (assert_failed = document == 0, !document)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/docdata.c",
        errline = 20,
        elinks_internal("assertion document failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  height = document->height;
  if ( height > y )
    return &document->data[y];
  v4 = (height + 127) & 0xFFFFFF80;
  v5 = (y + 128) & 0xFFFFFF80;
  v6 = y + 1;
  if ( v5 > v4 )
  {
    v8 = 8 * v5;
    v7 = (line *)mem_realloc(document->data, 8 * v5);
    if ( !v7 )
      return 0;
    document->data = v7;
    memset(&v7[v4], 0, v8 - 8 * v4);
    v6 = y + 1;
  }
  if ( document->data )
  {
    document->height = v6;
    return &document->data[y];
  }
  return 0;
}

//----- (080814A0) --------------------------------------------------------
int get_format_cache_size()
{
  list_head_elinks *next; // edx
  int result; // eax

  next = (list_head_elinks *)format_cache.next;
  for ( result = 0; next != &format_cache; ++result )
    next = (list_head_elinks *)next->next;
  return result;
}

//----- (080814D0) --------------------------------------------------------
int get_format_cache_used_count()
{
  list_head_elinks *next; // edx
  int result; // eax
  bool v2; // zf

  next = (list_head_elinks *)format_cache.next;
  for ( result = 0; next != &format_cache; result += !v2 )
  {
    v2 = next[1].next == 0;
    next = (list_head_elinks *)next->next;
  }
  return result;
}

//----- (08081500) --------------------------------------------------------
int get_format_cache_refresh_count()
{
  list_head_elinks *next; // edx
  int result; // eax
  _DWORD *prev; // ecx

  next = (list_head_elinks *)format_cache.next;
  for ( result = 0; next != &format_cache; next = (list_head_elinks *)next->next )
  {
    prev = next[25].prev;
    if ( prev )
      result -= (*prev == 0) - 1;
  }
  return result;
}

//----- (08081540) --------------------------------------------------------
void __cdecl done_documents(module *module)
{
  free_tags_lookup();
  free_table_cache();
}

//----- (08081560) --------------------------------------------------------
void __cdecl init_documents(module *module)
{
  init_tags_lookup();
}

//----- (08081570) --------------------------------------------------------
unsigned int __cdecl get_document_css_magic(document *document)
{
  unsigned int v1; // esi
  int i; // ebx
  cache_entry *v3; // eax

  v1 = 0;
  for ( i = 0; document->css_imports.size > i; ++i )
  {
    if ( document->css_imports.uris[i] )
    {
      v3 = find_in_cache(document->css_imports.uris[i]);
      if ( v3 )
        v1 += v3->cache_id + LODWORD(v3->data_size);
    }
  }
  return v1;
}

//----- (080815D0) --------------------------------------------------------
int __cdecl find_tag(document *document, unsigned __int8 *name, int namelen)
{
  list_head_elinks *next; // ebx

  next = (list_head_elinks *)document->tags.next;
  if ( next == &document->tags )
    return -1;
  while ( 1 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 190;
    if ( !elinks_strlcasecmp((const unsigned __int8 *)&next[2], 0xFFFFFFFF, name, namelen, 1) )
      break;
    next = (list_head_elinks *)next->next;
    if ( next == &document->tags )
      return -1;
  }
  return (int)next[1].prev;
}

//----- (08081660) --------------------------------------------------------
void __cdecl release_document(document *document)
{
  document *next; // eax

  if ( assert_failed
    || (assert_failed = document == 0, !document)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c",
        errline = 173,
        elinks_internal("assertion document failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    if ( document->refresh )
      kill_document_refresh(document->refresh);
    --document->object.refcount;
    if ( format_cache.next != document )
    {
      document->next->prev = document->prev;
      document->prev->next = document->next;
      next = (document *)format_cache.next;
      document->prev = (document *)&format_cache;
      document->next = next;
      format_cache.next = document;
      document->next->prev = document;
    }
  }
}

//----- (08081720) --------------------------------------------------------
void __usercall free_frameset_desc(frameset_desc *frameset_desc@<eax>)
{
  frameset_desc *v2; // ebx
  int v3; // esi
  frameset_desc *subframe; // eax

  if ( frameset_desc->n > 0 )
  {
    v2 = frameset_desc;
    v3 = 0;
    do
    {
      subframe = v2->frame_desc[0].subframe;
      if ( subframe )
        free_frameset_desc(subframe);
      if ( v2->frame_desc[0].name )
        mem_free(v2->frame_desc[0].name);
      if ( v2->frame_desc[0].uri )
        done_uri(v2->frame_desc[0].uri);
      ++v3;
      v2 = (frameset_desc *)((char *)v2 + 20);
    }
    while ( frameset_desc->n > v3 );
  }
  mem_free(frameset_desc);
}

//----- (08081780) --------------------------------------------------------
void __cdecl done_link_members(link *link)
{
  list_head_elinks *event_hooks; // eax
  _DWORD **next; // ebx
  list_head_elinks *v3; // esi
  void *v4; // [esp+0h] [ebp-28h]

  event_hooks = link->event_hooks;
  if ( event_hooks )
  {
    next = (_DWORD **)event_hooks->next;
    v3 = *(list_head_elinks **)event_hooks->next;
    if ( event_hooks->next != event_hooks )
    {
      while ( 1 )
      {
        if ( next[3] )
          mem_free(next[3]);
        v4 = next;
        next = (_DWORD **)v3;
        mem_free(v4);
        event_hooks = link->event_hooks;
        if ( event_hooks == v3 )
          break;
        v3 = (list_head_elinks *)v3->next;
      }
    }
    mem_free(event_hooks);
  }
  if ( link->type <= (unsigned int)LINK_MAP && link->data.name )
    mem_free(link->data.name);
  if ( link->where )
    mem_free(link->where);
  if ( link->target )
    mem_free(link->target);
  if ( link->title )
    mem_free(link->title);
  if ( link->where_img )
    mem_free(link->where_img);
  if ( link->points )
    mem_free(link->points);
}

//----- (08081850) --------------------------------------------------------
void __cdecl done_document(document *document)
{
  document *v1; // ebx
  int refcount; // edi
  cache_entry *cached; // esi
  frameset_desc *frame_desc; // eax
  link *links; // eax
  int v6; // edi
  int v7; // esi
  line *data; // edx
  int v9; // esi
  form *i; // eax
  document *next; // eax
  document *j; // esi
  document *k; // edx
  document *v14; // edi
  document *v15; // ebx
  list_head_elinks *v16; // eax
  list_head_elinks *p_nodes; // edi
  list_head_elinks *v18; // edx
  list_head_elinks *m; // edx
  list_head_elinks *v20; // esi
  list_head_elinks *v21; // ebx
  link *v22; // [esp+0h] [ebp-38h]
  document *v23; // [esp+1Ch] [ebp-1Ch]

  v1 = document;
  if ( assert_failed )
    goto LABEL_58;
  assert_failed = document == 0;
  if ( !document )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
    errline = 110;
    elinks_internal("assertion document failed!");
    if ( assert_failed )
      goto LABEL_58;
  }
  refcount = document->object.refcount;
  assert_failed = refcount != 0;
  if ( refcount
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c",
        errline = 113,
        elinks_internal("assertion !is_object_used(document) failed: Attempt to free locked formatted data."),
        assert_failed) )
  {
LABEL_58:
    assert_failed = 0;
  }
  else
  {
    cached = document->cached;
    assert_failed = cached == 0;
    if ( !cached )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c";
      errline = 116;
      elinks_internal("assertion document->cached failed!");
    }
    --document->cached->object.refcount;
    if ( document->uri )
      done_uri(document->uri);
    if ( document->title )
      mem_free(document->title);
    frame_desc = document->frame_desc;
    if ( frame_desc )
      free_frameset_desc(frame_desc);
    if ( document->refresh )
      done_document_refresh(document->refresh);
    links = document->links;
    if ( links )
    {
      if ( document->nlinks > 0 )
      {
        v6 = 0;
        v7 = 0;
        while ( 1 )
        {
          ++v7;
          v22 = &links[v6++];
          done_link_members(v22);
          if ( document->nlinks <= v7 )
            break;
          links = document->links;
        }
        links = document->links;
      }
      mem_free(links);
    }
    data = document->data;
    if ( data )
    {
      if ( document->height > 0 )
      {
        v9 = 0;
        do
        {
          if ( data[v9].chars )
          {
            mem_free(data[v9].chars);
            data = document->data;
          }
          ++v9;
        }
        while ( document->height > v9 );
      }
      mem_free(data);
    }
    if ( document->lines1 )
      mem_free(document->lines1);
    if ( document->lines2 )
      mem_free(document->lines2);
    done_document_options(&document->options);
    for ( i = (form *)document->forms.next; i != (form *)&document->forms; i = (form *)document->forms.next )
      done_form(i);
    free_uri_list(&document->css_imports);
    next = (document *)document->tags.next;
    for ( j = next; j != (document *)&document->tags; j = j->next )
      ;
    for ( k = (document *)document->tags.prev; k != j; k = k->prev )
      ;
    v14 = next->next;
    if ( next != j )
    {
      do
      {
        v15 = v14;
        v14->prev = next->prev;
        next->prev->next = next->next;
        mem_free(next);
        v14 = v14->next;
        next = v15;
      }
      while ( v15 != j );
      v1 = document;
    }
    v16 = (list_head_elinks *)v1->nodes.next;
    p_nodes = &v1->nodes;
    if ( &v1->nodes != v16 )
    {
      v18 = (list_head_elinks *)v1->nodes.next;
      do
        v18 = (list_head_elinks *)v18->next;
      while ( p_nodes != v18 );
    }
    for ( m = (list_head_elinks *)v1->nodes.prev; m != p_nodes; m = (list_head_elinks *)m->prev )
      ;
    v20 = (list_head_elinks *)v16->next;
    if ( v16 != p_nodes )
    {
      v23 = v1;
      do
      {
        v21 = v20;
        v20->prev = v16->prev;
        *(_DWORD *)v16->prev = v16->next;
        mem_free(v16);
        v20 = (list_head_elinks *)v20->next;
        v16 = v21;
      }
      while ( p_nodes != v21 );
      v1 = v23;
    }
    if ( v1->search )
      mem_free(v1->search);
    if ( v1->slines1 )
      mem_free(v1->slines1);
    if ( v1->slines2 )
      mem_free(v1->slines2);
    v1->next->prev = v1->prev;
    v1->prev->next = v1->next;
    mem_free(v1);
  }
}

//----- (08081B90) --------------------------------------------------------
void __cdecl shrink_format_cache(int whole)
{
  int v1; // esi
  document *next; // eax
  list_head_elinks *v3; // ebx
  list_head_elinks *v4; // edx
  document *prev; // eax
  list_head_elinks *v6; // ebx
  int number; // [esp+1Ch] [ebp-1Ch]

  v1 = 0;
  number = get_opt_(config_options, "document.cache.format.size")->number;
  next = (document *)format_cache.next;
  v3 = *(list_head_elinks **)format_cache.next;
  if ( format_cache.next != &format_cache )
  {
    while ( 1 )
    {
      if ( next->object.refcount )
        goto LABEL_4;
      if ( next->cached->cache_id == next->cache_id )
        break;
      done_document(next);
      v4 = (list_head_elinks *)v3->next;
      next = (document *)v3;
      if ( &format_cache == v3 )
        goto LABEL_9;
LABEL_5:
      v3 = v4;
    }
    ++v1;
LABEL_4:
    v4 = (list_head_elinks *)v3->next;
    next = (document *)v3;
    if ( &format_cache == v3 )
      goto LABEL_9;
    goto LABEL_5;
  }
LABEL_9:
  if ( assert_failed
    || (assert_failed = (unsigned int)v1 >> 31, v1 < 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c",
        errline = 294,
        elinks_internal("assertion format_cache_entries >= 0 failed: format_cache_entries underflow on entry"),
        assert_failed) )
  {
    assert_failed = 0;
    v1 = 0;
  }
  prev = (document *)format_cache.prev;
  v6 = (list_head_elinks *)*((_DWORD *)format_cache.prev + 1);
  if ( format_cache.prev != &format_cache )
  {
    while ( 1 )
    {
      if ( !prev->object.refcount )
      {
        if ( v1 <= number && !whole )
          break;
        --v1;
        done_document(prev);
      }
      prev = (document *)v6;
      if ( v6 == &format_cache )
        break;
      v6 = (list_head_elinks *)v6->prev;
    }
  }
  if ( assert_failed
    || (assert_failed = (unsigned int)v1 >> 31, v1 < 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/document.c",
        errline = 309,
        elinks_internal("assertion format_cache_entries >= 0 failed: format_cache_entries underflow"),
        assert_failed) )
  {
    assert_failed = 0;
  }
}

//----- (08081D20) --------------------------------------------------------
document *__cdecl get_cached_document(cache_entry *cached, document_options *options)
{
  document *next; // ebx
  list_head_elinks *v3; // esi
  document *v4; // eax
  unsigned int css_magic; // [esp+1Ch] [ebp-1Ch]

  next = (document *)format_cache.next;
  v3 = *(list_head_elinks **)format_cache.next;
  if ( format_cache.next == &format_cache )
    return 0;
  while ( 1 )
  {
    if ( !compare_uri(next->uri, cached->uri, (uri_component)0) || compare_opt(&next->options, options) )
      goto LABEL_12;
    if ( (*((_BYTE *)options + 92) & 4) == 0 && cached->cache_id == next->cache_id )
    {
      css_magic = next->css_magic;
      if ( css_magic == get_document_css_magic(next) )
        break;
    }
    if ( !next->object.refcount )
      done_document(next);
LABEL_12:
    next = (document *)v3;
    if ( v3 == &format_cache )
      return 0;
    v3 = (list_head_elinks *)v3->next;
  }
  if ( format_cache.next != next )
  {
    next->next->prev = next->prev;
    next->prev->next = next->next;
    v4 = (document *)format_cache.next;
    next->prev = (document *)&format_cache;
    next->next = v4;
    format_cache.next = next;
    next->next->prev = next;
  }
  ++next->object.refcount;
  return next;
}

//----- (08081E20) --------------------------------------------------------
document *__cdecl init_document(cache_entry *cached, document_options *options)
{
  document *v2; // esi
  uri *uri; // eax
  unsigned int cache_id; // eax
  document *next; // eax

  v2 = (document *)mem_calloc(1u, 0x118u);
  if ( v2 )
  {
    uri = cached->uri;
    ++uri->object.refcount;
    v2->uri = uri;
    cache_id = cached->cache_id;
    ++cached->object.refcount;
    ++v2->object.refcount;
    v2->cache_id = cache_id;
    v2->forms.prev = &v2->forms;
    v2->forms.next = &v2->forms;
    v2->tags.prev = &v2->tags;
    v2->tags.next = &v2->tags;
    v2->cached = cached;
    v2->nodes.prev = &v2->nodes;
    v2->nodes.next = &v2->nodes;
    copy_opt(&v2->options, options);
    next = (document *)format_cache.next;
    v2->prev = (document *)&format_cache;
    v2->next = next;
    format_cache.next = v2;
    v2->next->prev = v2;
  }
  return v2;
}

//----- (08081EE0) --------------------------------------------------------
void update_cached_document_options()
{
  list_head_elinks *i; // eax
  int active_link; // [esp+14h] [ebp-14h]
  int active_link_4; // [esp+18h] [ebp-10h]
  int active_link_8; // [esp+1Ch] [ebp-Ch]

  active_link_4 = get_opt_(config_options, "document.browse.links.active_link.colors.text")->number;
  active_link_8 = get_opt_(config_options, "document.browse.links.active_link.colors.background")->number;
  active_link = get_opt_(config_options, "document.browse.links.active_link.enable_color")->number & 1;
  LOBYTE(active_link) = (8 * (get_opt_(config_options, "document.browse.links.active_link.invert")->number & 1)) | active_link & 0xF7;
  LOBYTE(active_link) = (2 * (get_opt_(config_options, "document.browse.links.active_link.underline")->number & 1)) | active_link & 0xFD;
  LOBYTE(active_link) = (4 * ((int)get_opt_(config_options, "document.browse.links.active_link.bold")->tree & 1)) | active_link & 0xFB;
  for ( i = (list_head_elinks *)format_cache.next; i != &format_cache; i = (list_head_elinks *)i->next )
  {
    i[13].prev = (void *)active_link;
    i[14].next = (void *)active_link_4;
    i[14].prev = (void *)active_link_8;
  }
}

//----- (08082000) --------------------------------------------------------
void __cdecl get_screen_char_template(screen_char *templatea, document_options *options, text_style style)
{
  color_pair colors; // [esp+18h] [ebp-10h] BYREF

  templatea->attr = 0;
  templatea->data = 32;
  if ( style.attr )
  {
    if ( (style.attr & 4) != 0 )
      templatea->attr = 32;
    if ( (style.attr & 1) != 0 )
      templatea->attr |= 8u;
    if ( (style.attr & 2) != 0 )
      templatea->attr |= 0x10u;
    if ( (style.attr & 0x10) != 0 )
      templatea->attr |= 0x80u;
  }
  colors.background = style.bg;
  colors.foreground = style.fg;
  set_term_color(templatea, &colors, options->color_flags, options->color_mode);
}

//----- (08082080) --------------------------------------------------------
unsigned __int8 *__cdecl form_type2str(form_type num)
{
  unsigned __int8 *result; // eax

  result = (unsigned __int8 *)1;
  if ( num )
  {
    while ( form_type2name[(_DWORD)result].num != num )
    {
      if ( ++result == (unsigned __int8 *)10 )
      {
        LOBYTE(result) = 0;
        return result;
      }
    }
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return form_type2name[(_DWORD)result].name;
}

//----- (080820C0) --------------------------------------------------------
int __cdecl has_form_submit(form *form)
{
  list_head_elinks *p_items; // ebx
  bool v2; // zf
  list_head_elinks *next; // eax

  if ( assert_failed
    || (assert_failed = form == 0, !form)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c",
        errline = 112,
        elinks_internal("assertion form failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    p_items = &form->items;
    v2 = form->items.next != &form->items;
    assert_failed = form->items.next == &form->items;
    if ( !v2 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 115;
      elinks_internal("assertion !list_empty(form->items) failed: form has no items");
    }
    next = (list_head_elinks *)form->items.next;
    if ( p_items == next )
    {
      return 0;
    }
    else
    {
      while ( (unsigned int)next[2].prev - 7 > 1 )
      {
        next = (list_head_elinks *)next->next;
        if ( p_items == next )
          return 0;
      }
      return 1;
    }
  }
}

//----- (080821A0) --------------------------------------------------------
void __cdecl done_form_control(form_control *fc)
{
  int v1; // ebx

  if ( assert_failed
    || (assert_failed = fc == 0, !fc)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c",
        errline = 152,
        elinks_internal("assertion fc failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    if ( fc->id )
      mem_free(fc->id);
    if ( fc->name )
      mem_free(fc->name);
    if ( fc->alt )
      mem_free(fc->alt);
    if ( fc->default_value )
      mem_free(fc->default_value);
    if ( fc->nvalues > 0 )
    {
      v1 = 0;
      do
      {
        if ( fc->values[v1] )
          mem_free(fc->values[v1]);
        if ( fc->labels[v1] )
          mem_free(fc->labels[v1]);
        ++v1;
      }
      while ( fc->nvalues > v1 );
    }
    if ( fc->values )
      mem_free(fc->values);
    if ( fc->labels )
      mem_free(fc->labels);
    if ( fc->menu )
      free_menu(fc->menu);
  }
}

//----- (080822D0) --------------------------------------------------------
void __cdecl done_form(form *form)
{
  form *next; // edx
  list_head_elinks *p_items; // ebx
  form_control *v3; // esi
  form *v4; // eax
  form *i; // ecx
  list_head_elinks *j; // ecx
  form *v7; // esi
  list_head_elinks *v8; // edi

  if ( form->next )
  {
    form->next->prev = form->prev;
    form->prev->next = form->next;
  }
  if ( form->action )
    mem_free(form->action);
  if ( form->name )
    mem_free(form->name);
  if ( form->onsubmit )
    mem_free(form->onsubmit);
  if ( form->target )
    mem_free(form->target);
  next = (form *)form->items.next;
  p_items = &form->items;
  v3 = (form_control *)next;
  if ( next != (form *)&form->items )
  {
    do
    {
      done_form_control(v3);
      v3 = v3->next;
    }
    while ( v3 != (form_control *)p_items );
    next = (form *)form->items.next;
  }
  v4 = next;
  for ( i = next; p_items != (list_head_elinks *)i; i = i->next )
    ;
  for ( j = (list_head_elinks *)form->items.prev; p_items != j; j = (list_head_elinks *)j->prev )
    ;
  v7 = next->next;
  if ( next != (form *)p_items )
  {
    do
    {
      v8 = (list_head_elinks *)v7;
      v7->prev = v4->prev;
      v4->prev->next = v4->next;
      mem_free(v4);
      v7 = v7->next;
      v4 = (form *)v8;
    }
    while ( p_items != v8 );
  }
  mem_free(form);
}

//----- (080823D0) --------------------------------------------------------
int __cdecl get_form_control_link(document *document, form_control *fc)
{
  int nlinks; // esi
  link *links; // edx
  int result; // eax
  form_control *form_control; // ecx

  if ( fc->type == FC_HIDDEN )
    return -1;
  if ( (*((_BYTE *)document + 276) & 1) == 0 )
    sort_links(document);
  nlinks = document->nlinks;
  if ( nlinks <= 0 )
  {
LABEL_11:
    if ( !assert_failed )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/forms.c";
      errline = 142;
      elinks_internal("assertion 0 failed: Form control has no link.");
      return -1;
    }
    return -1;
  }
  links = document->links;
  result = 0;
  while ( 1 )
  {
    form_control = 0;
    if ( links->type > (unsigned int)LINK_MAP )
      form_control = links->data.form_control;
    if ( form_control == fc )
      return result;
    ++result;
    ++links;
    if ( nlinks <= result )
      goto LABEL_11;
  }
}

//----- (08082490) --------------------------------------------------------
form *init_form()
{
  form *result; // eax

  result = (form *)mem_calloc(1u, 0x2Cu);
  if ( result )
  {
    result->form_end = 0x7FFFFFFF;
    result->items.prev = &result->items;
    result->items.next = &result->items;
  }
  return result;
}

//----- (080824C0) --------------------------------------------------------
int __cdecl str2form_type(unsigned __int8 *s)
{
  int v1; // ebx

  v1 = 0;
  while ( strcmp((const char *)form_type2name[v1].name, (const char *)s) )
  {
    if ( ++v1 == 10 )
      return -1;
  }
  return form_type2name[v1].num;
}

//----- (08082510) --------------------------------------------------------
void __cdecl toggle_document_option(session *ses, unsigned __int8 *option_name)
{
  window *tab; // eax
  option_elinks *opt_rec; // eax

  if ( assert_failed )
    goto LABEL_10;
  if ( ses )
  {
    if ( ses->doc_view )
    {
      tab = ses->tab;
      if ( tab )
      {
        if ( tab->term )
        {
          assert_failed = 0;
          goto LABEL_7;
        }
      }
    }
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/options.c";
  errline = 129;
  elinks_internal("assertion ses && ses->doc_view && ses->tab && ses->tab->term failed!");
  if ( assert_failed )
  {
LABEL_10:
    assert_failed = 0;
    return;
  }
LABEL_7:
  if ( ses->doc_view->vs )
  {
    opt_rec = get_opt_rec(config_options, option_name);
    toggle_option(ses, opt_rec);
    draw_formatted(ses, 1);
  }
  else
  {
    nowhere_box(ses->tab->term, 0);
  }
}

//----- (08082610) --------------------------------------------------------
void __cdecl done_document_options(document_options *options)
{
  if ( options->framename )
    mem_free(options->framename);
  mem_free(options->image_link.prefix);
  mem_free(options->image_link.suffix);
}

//----- (08082650) --------------------------------------------------------
void __cdecl copy_opt(document_options *o1, document_options *o2)
{
  option_value *opt; // eax
  option_value *v3; // eax

  qmemcpy(o1, o2, sizeof(document_options));
  o1->framename = stracpy(o2->framename);
  opt = get_opt_(config_options, "document.browse.images.image_link_prefix");
  o1->image_link.prefix = stracpy(opt->string);
  v3 = get_opt_(config_options, "document.browse.images.image_link_suffix");
  o1->image_link.suffix = stracpy(v3->string);
}

//----- (080826D0) --------------------------------------------------------
int __cdecl compare_opt(document_options *o1, document_options *o2)
{
  int result; // eax
  char v3; // al

  if ( memcmp(o1, o2, 0x48u)
    || c_strcasecmp((const char *)o1->framename, (const char *)o2->framename)
    || o1->box.x != o2->box.x
    || o1->box.y != o2->box.y )
  {
    return 1;
  }
  v3 = *((_BYTE *)o1 + 92);
  if ( ((v3 & 1) != 0 || (*((_BYTE *)o2 + 92) & 1) != 0) && o1->box.height != o2->box.height )
    return 1;
  if ( (v3 & 2) != 0 )
    return o1->box.width != o2->box.width;
  result = 0;
  if ( (*((_BYTE *)o2 + 92) & 2) != 0 )
    return o1->box.width != o2->box.width;
  return result;
}

//----- (08082770) --------------------------------------------------------
void __cdecl init_document_options(document_options *doo)
{
  int number; // edx
  char v2; // al

  memset(doo, 0, sizeof(document_options));
  doo->assume_cp = get_opt_(config_options, "document.codepage.assume")->number;
  doo->hard_assume = get_opt_(config_options, "document.codepage.force_assumed")->number;
  doo->use_document_colors = get_opt_(config_options, "document.colors.use_document_colors")->number;
  doo->margin = get_opt_(config_options, "document.browse.margin_width")->number;
  doo->num_links_key = get_opt_(config_options, "document.browse.links.number_keys_select_link")->number;
  doo->meta_link_display = get_opt_(config_options, "document.html.link_display")->number;
  doo->default_form_input_size = get_opt_(config_options, "document.browse.forms.input_size")->number;
  doo->default_style.fg = get_opt_(config_options, "document.colors.text")->color;
  doo->default_style.bg = get_opt_(config_options, "document.colors.background")->color;
  doo->default_link = get_opt_(config_options, "document.colors.link")->color;
  doo->default_vlink = get_opt_(config_options, "document.colors.vlink")->color;
  doo->default_bookmark_link = get_opt_(config_options, "document.colors.bookmark")->color;
  doo->default_image_link = get_opt_(config_options, "document.colors.image")->color;
  doo->active_link.fg = get_opt_(config_options, "document.browse.links.active_link.colors.text")->color;
  doo->active_link.bg = get_opt_(config_options, "document.browse.links.active_link.colors.background")->color;
  if ( get_opt_(config_options, "document.colors.increase_contrast")->number )
    doo->color_flags |= 4u;
  if ( get_opt_(config_options, "document.colors.ensure_contrast")->number )
    doo->color_flags |= 8u;
  *((_BYTE *)doo + 68) = (int)get_opt_(config_options, "document.css.enable")->tree & 1 | *((_BYTE *)doo + 68) & 0xFE;
  *((_BYTE *)doo + 68) = (2 * ((int)get_opt_(config_options, "document.css.import")->tree & 1)) | *((_BYTE *)doo + 68) & 0xFD;
  *((_BYTE *)doo + 69) = (4 * ((int)get_opt_(config_options, "document.plain.display_links")->tree & 1)) | *((_BYTE *)doo + 69) & 0xFB;
  *((_BYTE *)doo + 69) = (8 * ((int)get_opt_(config_options, "document.plain.compress_empty_lines")->tree & 1)) | *((_BYTE *)doo + 69) & 0xF7;
  *((_BYTE *)doo + 69) = (int)get_opt_(config_options, "document.html.underline_links")->tree & 1 | *((_BYTE *)doo + 69) & 0xFE;
  *((_BYTE *)doo + 69) = (2 * ((int)get_opt_(config_options, "document.html.wrap_nbsp")->tree & 1)) | *((_BYTE *)doo + 69) & 0xFD;
  *((_BYTE *)doo + 69) = (32 * ((int)get_opt_(config_options, "document.browse.links.use_tabindex")->tree & 1)) | *((_BYTE *)doo + 69) & 0xDF;
  *((_BYTE *)doo + 69) = (16 * ((int)get_opt_(config_options, "document.browse.links.numbering")->tree & 1)) | *((_BYTE *)doo + 69) & 0xEF;
  *(_BYTE *)&doo->active_link = (int)get_opt_(config_options, "document.browse.links.active_link.enable_color")->tree & 1 | *(_BYTE *)&doo->active_link & 0xFE;
  *(_BYTE *)&doo->active_link = (8
                               * ((int)get_opt_(config_options, "document.browse.links.active_link.invert")->tree & 1)) | *(_BYTE *)&doo->active_link & 0xF7;
  *(_BYTE *)&doo->active_link = (2
                               * ((int)get_opt_(config_options, "document.browse.links.active_link.underline")->tree & 1)) | *(_BYTE *)&doo->active_link & 0xFD;
  *(_BYTE *)&doo->active_link = (4 * ((int)get_opt_(config_options, "document.browse.links.active_link.bold")->tree & 1)) | *(_BYTE *)&doo->active_link & 0xFB;
  *((_BYTE *)doo + 68) = (8 * ((int)get_opt_(config_options, "document.browse.table_move_order")->tree & 1)) | *((_BYTE *)doo + 68) & 0xF7;
  *((_BYTE *)doo + 68) = (4 * ((int)get_opt_(config_options, "document.html.display_tables")->tree & 1)) | *((_BYTE *)doo + 68) & 0xFB;
  *((_BYTE *)doo + 68) = (16 * ((int)get_opt_(config_options, "document.html.display_frames")->tree & 1)) | *((_BYTE *)doo + 68) & 0xEF;
  *((_BYTE *)doo + 68) = (32 * ((int)get_opt_(config_options, "document.browse.images.show_as_links")->tree & 1)) | *((_BYTE *)doo + 68) & 0xDF;
  *((_BYTE *)doo + 68) = (((int)get_opt_(config_options, "document.html.display_subs")->tree & 1) << 6) | *((_BYTE *)doo + 68) & 0xBF;
  number = get_opt_(config_options, "document.html.display_sups")->number;
  v2 = *((_BYTE *)doo + 68);
  doo->framename = (unsigned __int8 *)&delete;
  doo->image_link.prefix = (unsigned __int8 *)&delete;
  *((_BYTE *)doo + 68) = ((_BYTE)number << 7) | v2 & 0x7F;
  doo->image_link.suffix = (unsigned __int8 *)&delete;
  doo->image_link.filename_maxlen = get_opt_(config_options, "document.browse.images.filename_maxlen")->number;
  doo->image_link.label_maxlen = get_opt_(config_options, "document.browse.images.label_maxlen")->number;
  doo->image_link.display_style = get_opt_(config_options, "document.browse.images.display_style")->number;
  doo->image_link.tagging = get_opt_(config_options, "document.browse.images.image_link_tagging")->number;
  *((_BYTE *)&doo->image_link + 24) = (int)get_opt_(config_options, "document.browse.images.show_any_as_links")->tree & 1 | *((_BYTE *)&doo->image_link + 24) & 0xFE;
}

//----- (08082CD0) --------------------------------------------------------
void __cdecl start_document_refreshes(session *ses)
{
  session *v1; // ebx
  document_view *doc_view; // eax
  document *document; // eax
  document_refresh *refresh; // edi
  const uri *next; // esi
  milliseconds_T v6; // eax
  milliseconds_T delay; // [esp+18h] [ebp-20h]
  int number; // [esp+1Ch] [ebp-1Ch]

  v1 = ses;
  if ( !assert_failed )
  {
    assert_failed = ses == 0;
    if ( !ses )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/refresh.c";
      errline = 127;
      elinks_internal("assertion ses failed!");
    }
  }
  doc_view = ses->doc_view;
  if ( doc_view )
  {
    document = doc_view->document;
    if ( document )
    {
      if ( document->refresh )
      {
        if ( get_opt_(config_options, "document.browse.refresh")->number )
        {
          refresh = ses->doc_view->document->refresh;
          number = get_opt_(config_options, "document.browse.minimum_refresh_time")->number;
          delay = sec_to_ms(refresh->seconds);
          if ( (*((_BYTE *)refresh + 12) & 1) != 0 && !refresh->timer )
          {
            next = (const uri *)ses->type_queries.next;
            if ( next == (const uri *)&ses->type_queries )
            {
LABEL_17:
              v6 = number;
              if ( delay >= number )
                v6 = delay;
              install_timer(&refresh->timer, v6, do_document_refresh, v1);
            }
            else
            {
              while ( !compare_uri(refresh->uri, (const uri *)next[1].protocol, URI_BASE) )
              {
                next = (const uri *)next->string;
                if ( next == (const uri *)&ses->type_queries )
                {
                  v1 = ses;
                  goto LABEL_17;
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (08082E20) --------------------------------------------------------
void __cdecl do_document_refresh(void *data)
{
  int v1; // esi
  const uri **v2; // ebx

  v1 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)data + 23) + 20) + 204);
  if ( !assert_failed )
  {
    assert_failed = v1 == 0;
    if ( !v1 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/refresh.c";
      errline = 73;
      elinks_internal("assertion refresh failed!");
    }
  }
  *(_DWORD *)v1 = 0;
  v2 = (const uri **)*((_DWORD *)data + 40);
  if ( v2 == (const uri **)((char *)data + 160) )
  {
LABEL_9:
    if ( compare_uri(
           *(const uri **)(v1 + 8),
           *(const uri **)(*(_DWORD *)(*((_DWORD *)data + 23) + 20) + 184),
           (uri_component)0) )
    {
      reload((session *)data, CACHE_MODE_FORCE_RELOAD);
    }
    else
    {
      goto_uri_frame((session *)data, *(uri **)(v1 + 8), 0, CACHE_MODE_NORMAL);
      *(_BYTE *)(v1 + 12) &= ~1u;
    }
  }
  else
  {
    while ( !compare_uri(*(const uri **)(v1 + 8), v2[16], URI_BASE) )
    {
      v2 = (const uri **)*v2;
      if ( v2 == (const uri **)((char *)data + 160) )
        goto LABEL_9;
    }
  }
}

//----- (08082F50) --------------------------------------------------------
void __cdecl kill_document_refresh(document_refresh *refresh)
{
  kill_timer(&refresh->timer);
}

//----- (08082F60) --------------------------------------------------------
void __cdecl done_document_refresh(document_refresh *refresh)
{
  kill_timer(&refresh->timer);
  done_uri(refresh->uri);
  mem_free(refresh);
}

//----- (08082F90) --------------------------------------------------------
document_refresh *__cdecl init_document_refresh(unsigned __int8 *url, unsigned int seconds)
{
  document_refresh *v2; // ebx
  uri *uri; // eax
  document_refresh *v5; // [esp+0h] [ebp-18h]

  v2 = (document_refresh *)mem_alloc(0x10u);
  if ( v2 )
  {
    uri = get_uri(url, (uri_component)0);
    v2->uri = uri;
    if ( uri )
    {
      *((_BYTE *)v2 + 12) |= 1u;
      v2->timer = 0;
      v2->seconds = seconds;
    }
    else
    {
      v5 = v2;
      v2 = 0;
      mem_free(v5);
    }
  }
  return v2;
}

//----- (08082FF0) --------------------------------------------------------
int __cdecl comp_links(const void *v1, const void *v2)
{
  if ( !assert_failed )
  {
    assert_failed = v1 == 0 || v2 == 0;
    if ( v1 != 0 && v2 != 0 )
      return *((_DWORD *)v1 + 8) - *((_DWORD *)v2 + 8);
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 516;
    elinks_internal("assertion l1 && l2 failed!");
    if ( !assert_failed )
      return *((_DWORD *)v1 + 8) - *((_DWORD *)v2 + 8);
  }
  assert_failed = 0;
  return 0;
}

//----- (08083080) --------------------------------------------------------
conv_table *__cdecl get_convert_table(
        unsigned __int8 *head,
        int to_cp,
        int default_cp,
        int *from_cp,
        cp_status *cp_status,
        int ignore_server_cp)
{
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // eax
  int v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // eax
  unsigned __int8 *v13; // ebx
  int from; // [esp+1Ch] [ebp-2Ch]
  int froma; // [esp+1Ch] [ebp-2Ch]
  int fromb; // [esp+1Ch] [ebp-2Ch]
  int fromc; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *ct_charset; // [esp+28h] [ebp-20h] BYREF
  unsigned __int8 *part[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_2;
  part[0] = head;
  assert_failed = head == 0;
  if ( head )
  {
    if ( !ignore_server_cp )
      goto LABEL_11;
LABEL_5:
    if ( cp_status )
      *cp_status = CP_STATUS_IGNORED;
    if ( from_cp )
      *from_cp = default_cp;
    return get_translation_table(default_cp, to_cp);
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
  errline = 583;
  elinks_internal("assertion head failed!");
  if ( assert_failed )
  {
LABEL_2:
    assert_failed = 0;
    return 0;
  }
  if ( ignore_server_cp )
    goto LABEL_5;
LABEL_11:
  while ( 1 )
  {
    v7 = parse_header(part[0], (unsigned __int8 *)&byte_812C04C, part);
    if ( !v7 )
      break;
    while ( 1 )
    {
      v8 = parse_header(part[0], (unsigned __int8 *)&byte_812C04C, part);
      if ( !v8 )
        break;
      from = (int)v8;
      mem_free(v7);
      v7 = (unsigned __int8 *)from;
    }
    parse_header_param_0(v7, "charset", &ct_charset);
    if ( ct_charset )
    {
      froma = get_cp_index(ct_charset);
      mem_free(ct_charset);
      mem_free(v7);
      v9 = froma;
      if ( froma != -1 )
        goto LABEL_16;
    }
    else
    {
      mem_free(v7);
    }
  }
  v10 = parse_header(head, "Content-Charset", 0);
  v11 = v10;
  if ( v10 )
  {
    fromb = get_cp_index(v10);
    mem_free(v11);
    v9 = fromb;
    if ( fromb != -1 )
      goto LABEL_16;
  }
  v12 = parse_header(head, (unsigned __int8 *)"Charset", 0);
  v13 = v12;
  if ( v12 )
  {
    fromc = get_cp_index(v12);
    mem_free(v13);
    v9 = fromc;
    if ( fromc != -1 )
    {
LABEL_16:
      if ( cp_status )
        *cp_status = CP_STATUS_SERVER;
      goto LABEL_18;
    }
  }
  v9 = default_cp;
  if ( cp_status )
  {
    *cp_status = CP_STATUS_ASSUMED;
    v9 = default_cp;
  }
LABEL_18:
  if ( from_cp )
    *from_cp = v9;
  return get_translation_table(v9, to_cp);
}

//----- (080832C0) --------------------------------------------------------
void __cdecl sort_links(document *document)
{
  link *links; // edx
  int height; // eax
  link **lines1; // eax
  link **lines2; // edx
  link **v5; // eax
  int v6; // ecx
  link *v7; // esi
  int npoints; // eax
  point *points; // edx
  int y; // esi
  int v11; // edx
  int v12; // eax
  int v13; // edi
  bool v14; // zf
  link **v15; // eax
  int nlinks; // eax
  int v17; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_29;
  assert_failed = document == 0;
  if ( document )
  {
    if ( !document->nlinks )
      return;
    goto LABEL_4;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
  errline = 526;
  elinks_internal("assertion document failed!");
  if ( assert_failed )
  {
LABEL_29:
    assert_failed = 0;
    return;
  }
  if ( MEMORY[0x104] )
  {
LABEL_4:
    if ( (*((_BYTE *)document + 276) & 1) == 0 )
    {
      links = document->links;
      assert_failed = links == 0;
      if ( !links )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
        errline = 531;
        elinks_internal("assertion document->links failed!");
        if ( assert_failed )
          goto LABEL_29;
      }
      qsort(document->links, document->nlinks, 0x34u, comp_links);
      height = document->height;
      if ( height )
      {
        if ( document->lines1 )
        {
          mem_free(document->lines1);
          height = document->height;
        }
        lines1 = (link **)mem_calloc(height, 4u);
        lines2 = document->lines2;
        document->lines1 = lines1;
        if ( lines2 )
        {
          mem_free(lines2);
          lines1 = document->lines1;
        }
        if ( lines1 )
        {
          v5 = (link **)mem_calloc(document->height, 4u);
          document->lines2 = v5;
          if ( v5 )
          {
            i = 0;
            if ( document->nlinks > 0 )
            {
              do
              {
                v6 = 52 * i;
                v7 = &document->links[i];
                npoints = v7->npoints;
                if ( npoints )
                {
                  points = v7->points;
                  y = points->y;
                  v11 = points[npoints - 1].y;
                  if ( y > v11 )
                  {
                    v12 = y;
                    y = v11;
                    v11 = v12;
                  }
                  v13 = y;
                  v17 = v11;
                  do
                  {
                    while ( 1 )
                    {
                      if ( !assert_failed )
                      {
                        v14 = document->height > y;
                        assert_failed = document->height <= y;
                        if ( v14 )
                          break;
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
                        errline = 565;
                        v18 = v6;
                        elinks_internal("assertion j < document->height failed: link out of screen");
                        v6 = v18;
                        if ( !assert_failed )
                          break;
                      }
                      ++y;
                      ++v13;
                      assert_failed = 0;
                      if ( v17 < y )
                        goto LABEL_24;
                    }
                    document->lines2[v13] = (link *)((char *)document->links + v6);
                    v15 = &document->lines1[v13];
                    if ( !*v15 )
                      *v15 = (link *)((char *)document->links + v6);
                    ++y;
                    ++v13;
                  }
                  while ( v17 >= y );
LABEL_24:
                  nlinks = document->nlinks;
                }
                else
                {
                  done_link_members(&document->links[i]);
                  memmove(v7, &v7[1], 52 * (document->nlinks + ~i));
                  nlinks = document->nlinks - 1;
                  document->nlinks = nlinks;
                  --i;
                }
                ++i;
              }
              while ( nlinks > i );
            }
            *((_BYTE *)document + 276) |= 1u;
          }
          else
          {
            mem_free(document->lines1);
          }
        }
      }
    }
  }
}

//----- (080835D0) --------------------------------------------------------
void __cdecl render_document(view_state *vs, document_view *doc_view, document_options *options)
{
  document_view *v3; // ebx
  unsigned __int8 *name; // edi
  document_view *v5; // eax
  uri *uri; // eax
  cache_entry *v7; // edx
  document *cached_document; // eax
  document *v9; // edi
  char v10; // al
  document *inited; // eax
  cache_entry *v12; // edx
  session *session; // eax
  int form_info_len; // eax
  bool v15; // zf
  uri *v16; // esi
  fragment *cache_fragment; // eax
  cache_entry *v18; // edx
  stream_encoding v19; // esi
  unsigned __int8 *extension_from_uri; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  uri_component v24; // eax
  unsigned __int8 *uri_string; // eax
  unsigned __int8 *v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  uri *v32; // [esp+0h] [ebp-58h]
  unsigned __int8 *p; // [esp+24h] [ebp-34h]
  cache_entry *v34; // [esp+28h] [ebp-30h]
  cache_entry *v35; // [esp+28h] [ebp-30h]
  cache_entry *v36; // [esp+28h] [ebp-30h]
  cache_entry *v37; // [esp+28h] [ebp-30h]
  string buffer; // [esp+34h] [ebp-24h] BYREF
  int new_len[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v3 = doc_view;
  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !vs || !options )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 281;
    elinks_internal("assertion vs && doc_view && options failed!");
    if ( !assert_failed )
      goto LABEL_9;
LABEL_4:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_9:
  name = doc_view->name;
  doc_view->name = 0;
  detach_formatted(doc_view);
  doc_view->name = name;
  doc_view->vs = vs;
  doc_view->last_y = -1;
  doc_view->last_x = -1;
  v5 = vs->doc_view;
  if ( vs->doc_view )
  {
    if ( !assert_failed )
    {
      assert_failed = v5->vs != vs;
      if ( assert_failed )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
        errline = 313;
        elinks_internal("assertion vs->doc_view->vs == vs failed!");
      }
      v5 = vs->doc_view;
    }
    v5->used = 0;
    vs->doc_view->vs = 0;
    vs->doc_view = 0;
  }
  uri = vs->uri;
  vs->doc_view = doc_view;
  v7 = find_in_cache(uri);
  if ( !v7 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c";
    errline = 326;
    elinks_internal("document %s to format not found", vs->uri->string);
    return;
  }
  v34 = v7;
  cached_document = get_cached_document(v7, options);
  v9 = cached_document;
  if ( !cached_document )
  {
    inited = init_document(v34, options);
    v12 = v34;
    v9 = inited;
    if ( !inited )
      return;
    doc_view->document = inited;
    session = doc_view->session;
    if ( session )
    {
      if ( session->reloadlevel > CACHE_MODE_NORMAL )
      {
        form_info_len = vs->form_info_len;
        if ( form_info_len > 0 )
        {
          do
          {
            done_form_state(&vs->form_info[form_info_len - 1]);
            form_info_len = vs->form_info_len - 1;
            v15 = vs->form_info_len == 1;
            vs->form_info_len = form_info_len;
          }
          while ( form_info_len >= 0 && !v15 );
          v12 = v34;
          v3 = doc_view;
        }
      }
    }
    v35 = v12;
    shrink_memory(0);
    v16 = v35->uri;
    cache_fragment = get_cache_fragment(v35);
    v18 = v35;
    buffer.source = (unsigned __int8 *)&delete;
    buffer.length = 0;
    if ( cache_fragment )
    {
      buffer.source = cache_fragment->data;
      buffer.length = cache_fragment->length;
    }
    if ( v16->protocol != 4 )
    {
      v32 = v16;
      v19 = ENCODING_NONE;
      extension_from_uri = get_extension_from_uri(v32);
      v18 = v35;
      if ( !extension_from_uri
        || (p = extension_from_uri,
            v19 = guess_encoding(extension_from_uri),
            mem_free(p),
            v18 = v35,
            v19 == ENCODING_NONE) )
      {
LABEL_34:
        if ( (*((_BYTE *)&v9->options + 69) & 0x40) != 0 )
        {
          if ( !v18->content_type )
            goto LABEL_59;
          v36 = v18;
          v21 = c_strcasecmp("text/html", (const char *)v18->content_type);
          v18 = v36;
          if ( v21 )
          {
            v22 = c_strcasecmp("application/xhtml+xml", (const char *)v36->content_type);
            v18 = v36;
            if ( v22 )
            {
              v27 = c_strcasecmp("application/docbook+xml", (const char *)v36->content_type);
              v18 = v36;
              if ( v27 )
              {
                v28 = c_strcasecmp("application/rss+xml", (const char *)v36->content_type);
                v18 = v36;
                if ( v28 )
                {
                  v29 = c_strcasecmp("application/xbel+xml", (const char *)v36->content_type);
                  v18 = v36;
                  if ( v29 )
                  {
                    v30 = c_strcasecmp("application/x-xbel", (const char *)v36->content_type);
                    v18 = v36;
                    if ( v30 )
                    {
                      v31 = c_strcasecmp("application/xbel", (const char *)v36->content_type);
                      v18 = v36;
                      if ( v31 )
                      {
LABEL_59:
                        render_plain_document(v18, v9, &buffer);
                        goto LABEL_39;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else if ( !v18->content_type
               || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/renderer.c",
                   errline = 261,
                   v37 = v18,
                   v23 = elinks_strlcasecmp("application/rss+xml", 0x13u, v18->content_type, 0xFFFFFFFF, 1),
                   v18 = v37,
                   v23) )
        {
          render_html_document(v18, v9, &buffer);
          goto LABEL_39;
        }
        render_dom_document(v18, v9, &buffer);
LABEL_39:
        if ( v19 )
          done_string(&buffer);
        sort_links(v9);
        if ( !v9->title )
        {
          v24 = URI_PUBLIC;
          if ( v9->uri->protocol == 4 )
            v24 = URI_PATH;
          uri_string = get_uri_string(v9->uri, v24);
          v9->title = uri_string;
          if ( uri_string )
          {
            if ( (*((_BYTE *)&v3->document->options + 92) & 0x10) != 0 )
              decode_uri(uri_string);
            else
              decode_uri_for_display(uri_string);
          }
        }
        v9->css_magic = get_document_css_magic(v9);
        goto LABEL_18;
      }
      new_len[0] = 0;
      v26 = decode_encoded_buffer(v19, buffer.source, buffer.length, new_len);
      v18 = v35;
      if ( v26 )
      {
        buffer.source = v26;
        buffer.length = new_len[0];
        goto LABEL_34;
      }
    }
    v19 = ENCODING_NONE;
    goto LABEL_34;
  }
  doc_view->document = cached_document;
LABEL_18:
  v3->box.x = v9->options.box.x;
  v3->box.y = v9->options.box.y;
  v3->box.width = v9->options.box.width;
  v3->box.height = v9->options.box.height;
  v10 = *((_BYTE *)&v9->options + 92);
  if ( (v10 & 2) == 0 )
  {
    v3->box.width = options->box.width;
    v10 = *((_BYTE *)&v9->options + 92);
  }
  if ( (v10 & 1) == 0 )
    v3->box.height = options->box.height;
}
// 80835D0: using guessed type int new_len[7];

//----- (08083AD0) --------------------------------------------------------
void __cdecl render_document_frames(session *ses, int no_cache)
{
  session *v2; // esi
  location *current; // eax
  view_state *p_vs; // edi
  window *tab; // eax
  terminal *term; // ecx
  int height; // edx
  int width; // ecx
  char status; // cl
  int plain; // edx
  char v11; // dl
  list_head_elinks *next; // eax
  list_head_elinks *i; // ebx
  document *document; // eax
  document_view *v15; // edi
  list_head_elinks *p_scrn_frames; // esi
  document_view **p_next; // ebx
  list_head_elinks *v18; // eax
  int j; // ecx
  _DWORD *prev; // edx
  document_view *v21; // eax
  document_view *v22; // [esp+1Ch] [ebp-ACh]
  document_options doc_opts; // [esp+28h] [ebp-A0h] BYREF

  v2 = ses;
  if ( !ses->doc_view )
  {
    v21 = (document_view *)mem_calloc(1u, 0x3Cu);
    ses->doc_view = v21;
    if ( !v21 )
      return;
    v21->session = ses;
    ses->doc_view->search_word = &ses->search_word;
  }
  current = ses->history.current;
  p_vs = &current->vs;
  if ( !current )
    p_vs = 0;
  init_document_options(&doc_opts);
  tab = ses->tab;
  term = tab->term;
  height = term->height;
  width = term->width;
  doc_opts.box.x = 0;
  doc_opts.box.y = 0;
  if ( width < 0 )
    width = 0;
  if ( height < 0 )
    height = 0;
  doc_opts.box.width = width;
  doc_opts.box.height = height;
  status = (char)ses->status;
  if ( (status & 4) != 0 )
  {
    doc_opts.box.y = 1;
    doc_opts.box.height = height - 1;
  }
  if ( (status & 2) != 0 )
    --doc_opts.box.height;
  if ( (status & 1) != 0 )
  {
    --doc_opts.box.height;
    if ( (*((_BYTE *)&ses->status + 52) & 4) != 0 )
      ++doc_opts.box.y;
  }
  doc_opts.color_mode = (color_mode)get_opt_(tab->term->spec, "colors")->tree;
  if ( !get_opt_(ses->tab->term->spec, (unsigned __int8 *)"underline")->number )
    doc_opts.color_flags |= 2u;
  doc_opts.cp = get_terminal_codepage(ses->tab->term);
  *((_BYTE *)&doc_opts + 92) = (8 * ((no_cache & 2) != 0)) | (4 * (no_cache & 1)) | *((_BYTE *)&doc_opts + 92) & 0xF3;
  if ( p_vs )
  {
    plain = p_vs->plain;
    if ( plain < 0 )
    {
      p_vs->plain = 0;
      v11 = 0;
    }
    else
    {
      v11 = plain & 1;
    }
    *((_BYTE *)&doc_opts + 69) = ((v11 & 1) << 6) | *((_BYTE *)&doc_opts + 69) & 0xBF;
    *((_BYTE *)&doc_opts + 69) = (*((_BYTE *)p_vs + 44) << 7) | *((_BYTE *)&doc_opts + 69) & 0x7F;
  }
  else
  {
    *((_BYTE *)&doc_opts + 69) |= 0x40u;
  }
  next = (list_head_elinks *)ses->scrn_frames.next;
  for ( i = &ses->scrn_frames; i != next; next = (list_head_elinks *)next->next )
    next[7].next = 0;
  if ( p_vs )
    render_document(p_vs, ses->doc_view, &doc_opts);
  document = ses->doc_view->document;
  if ( document && document->frame_desc )
  {
    v22 = current_frame(ses);
    format_frames(ses, ses->doc_view->document->frame_desc, &doc_opts, 0);
  }
  else
  {
    v22 = 0;
  }
  v15 = (document_view *)ses->scrn_frames.next;
  if ( i != (list_head_elinks *)v15 )
  {
    p_scrn_frames = &ses->scrn_frames;
    do
    {
      while ( 1 )
      {
        p_next = &v15->prev->next;
        if ( !v15->used )
          break;
        v15 = v15->next;
        if ( p_scrn_frames == (list_head_elinks *)v15 )
          goto LABEL_33;
      }
      detach_formatted(v15);
      v15->next->prev = v15->prev;
      v15->prev->next = v15->next;
      mem_free(v15);
      v15 = *p_next;
    }
    while ( p_scrn_frames != (list_head_elinks *)*p_next );
LABEL_33:
    i = &ses->scrn_frames;
    v2 = ses;
  }
  if ( v22 )
  {
    v18 = (list_head_elinks *)v2->scrn_frames.next;
    if ( i != v18 )
    {
      for ( j = 0; ; ++j )
      {
        while ( 1 )
        {
          prev = v18[2].prev;
          if ( !prev || !prev[50] )
            break;
          v18 = (list_head_elinks *)v18->next;
          if ( i == v18 )
            return;
        }
        if ( v18 == (list_head_elinks *)v22 )
          break;
        v18 = (list_head_elinks *)v18->next;
        if ( i == v18 )
          return;
      }
      v2->history.current->vs.current_link = j;
    }
  }
}

//----- (08083DC0) --------------------------------------------------------
void __cdecl apply_css_selector_style(html_context *html_context, html_element *element, css_selector *selector)
{
  css_property *i; // ebx
  bool v4; // zf

  for ( i = (css_property *)selector->properties.next; i != (css_property *)&selector->properties; i = i->next )
  {
    if ( !assert_failed )
    {
      v4 = i->type <= (unsigned int)CSS_PT_WHITE_SPACE;
      assert_failed = i->type > (unsigned int)CSS_PT_WHITE_SPACE;
      if ( v4
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c",
            errline = 276,
            elinks_internal("assertion property->type < CSS_PT_LAST failed!"),
            !assert_failed) )
      {
        v4 = css_appliers[i->type] != 0;
        assert_failed = css_appliers[i->type] == 0;
        if ( !v4 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
          errline = 280;
          elinks_internal("assertion css_appliers[property->type] failed!");
        }
      }
    }
    css_appliers[i->type](html_context, element, i);
  }
}

//----- (08083EA0) --------------------------------------------------------
void __cdecl css_apply_text_align(html_context *html_context, html_element *element, css_property *prop)
{
  bool v3; // zf

  if ( assert_failed
    || (v3 = prop->value_type == CSS_VT_TEXT_ALIGN, assert_failed = prop->value_type != CSS_VT_TEXT_ALIGN, v3) )
  {
    element->parattr.align = prop->value.text_align;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
    errline = 101;
    elinks_internal("assertion prop->value_type == CSS_VT_TEXT_ALIGN failed!");
    element->parattr.align = prop->value.text_align;
  }
}

//----- (08083F10) --------------------------------------------------------
void __cdecl css_apply_font_attribute(html_context *html_context, html_element *element, css_property *prop)
{
  bool v3; // zf
  unsigned __int32 v4; // edx

  if ( !assert_failed )
  {
    v3 = prop->value_type == CSS_VT_FONT_ATTRIBUTE;
    assert_failed = prop->value_type != CSS_VT_FONT_ATTRIBUTE;
    if ( !v3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 89;
      elinks_internal("assertion prop->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    }
  }
  v4 = element->attr.style.attr | prop->value.color;
  element->attr.style.attr = v4;
  element->attr.style.attr = v4 & ~prop->value.font_attribute.rem;
}

//----- (08083F90) --------------------------------------------------------
void __cdecl css_apply_display(html_context *html_context, html_element *element, css_property *prop)
{
  bool v3; // zf
  void *none; // eax

  if ( !assert_failed )
  {
    v3 = prop->value_type == CSS_VT_DISPLAY;
    assert_failed = prop->value_type != CSS_VT_DISPLAY;
    if ( !v3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 67;
      elinks_internal("assertion prop->value_type == CSS_VT_DISPLAY failed!");
    }
  }
  none = prop->value.none;
  if ( none )
  {
    if ( none == (void *)1 )
    {
      element->linebreak = 2;
    }
    else
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 80;
      elinks_internal("Bad prop->value.display %d", prop->value.color);
    }
  }
  else
  {
    element->linebreak = 0;
  }
}

//----- (08084060) --------------------------------------------------------
void __cdecl css_apply_color(html_context *html_context, html_element *element, css_property *prop)
{
  bool v3; // zf
  document_options *options; // eax

  if ( !assert_failed )
  {
    v3 = prop->value_type == CSS_VT_COLOR;
    assert_failed = prop->value_type != CSS_VT_COLOR;
    if ( !v3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 46;
      elinks_internal("assertion prop->value_type == CSS_VT_COLOR failed!");
    }
  }
  options = html_context->options;
  if ( options->color_mode )
  {
    if ( options->use_document_colors > 0 )
      element->attr.style.fg = prop->value.color;
  }
}

//----- (080840D0) --------------------------------------------------------
void __cdecl css_apply_background_color(html_context *html_context, html_element *element, css_property *prop)
{
  bool v3; // zf
  document_options *options; // eax

  if ( !assert_failed )
  {
    v3 = prop->value_type == CSS_VT_COLOR;
    assert_failed = prop->value_type != CSS_VT_COLOR;
    if ( !v3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 57;
      elinks_internal("assertion prop->value_type == CSS_VT_COLOR failed!");
    }
  }
  options = html_context->options;
  if ( options->color_mode )
  {
    if ( options->use_document_colors == 2 )
      element->attr.style.bg = prop->value.color;
  }
}

//----- (08084150) --------------------------------------------------------
void __usercall examine_element(
        html_context *html_context@<eax>,
        css_selector *base@<edx>,
        css_selector_type seltype@<ecx>,
        css_selector_relation rel,
        list_head_elinks *selectors,
        html_element *element)
{
  html_element *i; // edx
  html_element_pseudo_class pseudo_class; // eax
  unsigned __int8 *v8; // edx
  css_selector *v9; // eax
  list_head_elinks *v10; // esi
  html_element *v11; // ebx
  css_selector *v12; // eax
  list_head_elinks *v13; // edi
  html_element *v14; // esi
  unsigned __int8 *v15; // ebx
  css_selector *v16; // eax
  list_head_elinks *v17; // esi
  html_element *v18; // ebx
  css_selector *v19; // eax
  list_head_elinks *v20; // esi
  html_element *v21; // ebx
  css_selector *css_selector; // eax
  list_head_elinks *p_leaves; // esi
  html_element *next; // ebx
  css_selector *v25; // eax
  list_head_elinks *v26; // esi
  html_element *v27; // ebx
  css_selector_type v28; // [esp+2Ch] [ebp-2Ch]
  list_head_elinks *p_stack; // [esp+34h] [ebp-24h]

  v28 = seltype;
  if ( seltype )
  {
    p_stack = &html_context->stack;
  }
  else
  {
    p_stack = &html_context->stack;
    if ( element->namelen )
    {
      css_selector = find_css_selector(selectors, CST_ELEMENT, rel, (const unsigned __int8 *)"*", 1);
      if ( css_selector )
      {
        p_leaves = &css_selector->leaves;
        merge_css_selectors(base, css_selector);
        next = element->next;
        if ( (list_head_elinks *)element->next != p_stack )
        {
          do
          {
            examine_element(html_context, base, CST_ELEMENT, CSR_ANCESTOR, p_leaves, next);
            next = next->next;
          }
          while ( p_stack != (list_head_elinks *)next );
          examine_element(html_context, base, CST_ELEMENT, CSR_PARENT, p_leaves, element->next);
        }
        examine_element(html_context, base, CST_ID, CSR_SPECIFITY, p_leaves, element);
      }
      v25 = find_css_selector(selectors, CST_ELEMENT, rel, element->name, element->namelen);
      if ( v25 )
      {
        v26 = &v25->leaves;
        merge_css_selectors(base, v25);
        v27 = element->next;
        if ( (list_head_elinks *)element->next != p_stack )
        {
          do
          {
            examine_element(html_context, base, CST_ELEMENT, CSR_ANCESTOR, v26, v27);
            v27 = v27->next;
          }
          while ( p_stack != (list_head_elinks *)v27 );
          examine_element(html_context, base, CST_ELEMENT, CSR_PARENT, v26, element->next);
        }
        examine_element(html_context, base, CST_ID, CSR_SPECIFITY, v26, element);
      }
    }
  }
  for ( i = element; element->options; rel = CSR_SPECIFITY )
  {
    pseudo_class = i->pseudo_class;
    if ( (pseudo_class & 1) != 0 )
    {
      v19 = find_css_selector(selectors, CST_PSEUDO, rel, "link", -1);
      if ( v19 )
      {
        v20 = &v19->leaves;
        merge_css_selectors(base, v19);
        v21 = element->next;
        if ( (list_head_elinks *)element->next != p_stack )
        {
          do
          {
            examine_element(html_context, base, CST_ELEMENT, CSR_ANCESTOR, v20, v21);
            v21 = v21->next;
          }
          while ( p_stack != (list_head_elinks *)v21 );
          examine_element(html_context, base, CST_ELEMENT, CSR_PARENT, v20, element->next);
        }
        examine_element(html_context, base, CST_INVALID, CSR_SPECIFITY, v20, element);
      }
      pseudo_class = element->pseudo_class;
    }
    if ( (pseudo_class & 2) != 0 )
    {
      v16 = find_css_selector(selectors, CST_PSEUDO, rel, "visited", -1);
      if ( v16 )
      {
        v17 = &v16->leaves;
        merge_css_selectors(base, v16);
        v18 = element->next;
        if ( p_stack != (list_head_elinks *)element->next )
        {
          do
          {
            examine_element(html_context, base, CST_ELEMENT, CSR_ANCESTOR, v17, v18);
            v18 = v18->next;
          }
          while ( p_stack != (list_head_elinks *)v18 );
          examine_element(html_context, base, CST_ELEMENT, CSR_PARENT, v17, element->next);
        }
        examine_element(html_context, base, CST_INVALID, CSR_SPECIFITY, v17, element);
      }
    }
    v8 = element->attr.class;
    if ( (unsigned int)v28 <= CST_CLASS && v8 )
    {
      while ( 1 )
      {
        while ( *v8 == 32 )
          ++v8;
        if ( !*v8 )
          break;
        v15 = v8;
        do
          ++v15;
        while ( *v15 && *v15 != 32 );
        v12 = find_css_selector(selectors, CST_CLASS, rel, v8, v15 - v8);
        if ( v12 )
        {
          v13 = &v12->leaves;
          merge_css_selectors(base, v12);
          v14 = element->next;
          if ( p_stack != (list_head_elinks *)element->next )
          {
            do
            {
              examine_element(html_context, base, CST_ELEMENT, CSR_ANCESTOR, v13, v14);
              v14 = v14->next;
            }
            while ( p_stack != (list_head_elinks *)v14 );
            examine_element(html_context, base, CST_ELEMENT, CSR_PARENT, v13, element->next);
          }
          examine_element(html_context, base, CST_PSEUDO, CSR_SPECIFITY, v13, element);
        }
        v8 = v15;
      }
    }
    if ( (unsigned int)v28 > CST_ID )
      break;
    if ( !element->attr.id )
      break;
    v9 = find_css_selector(selectors, CST_ID, rel, element->attr.id, -1);
    if ( !v9 )
      break;
    v10 = &v9->leaves;
    merge_css_selectors(base, v9);
    v11 = element->next;
    if ( p_stack != (list_head_elinks *)element->next )
    {
      do
      {
        examine_element(html_context, base, CST_ELEMENT, CSR_ANCESTOR, v10, v11);
        v11 = v11->next;
      }
      while ( p_stack != (list_head_elinks *)v11 );
      examine_element(html_context, base, CST_ELEMENT, CSR_PARENT, v10, element->next);
    }
    i = element;
    selectors = v10;
    v28 = CST_CLASS;
  }
}

//----- (080846B0) --------------------------------------------------------
css_selector *__cdecl get_css_selector_for_element(
        html_context *html_context,
        html_element *element,
        css_stylesheet *css,
        list_head_elinks *html_stack)
{
  css_selector *inited; // eax
  css_selector *v5; // ebx
  unsigned __int8 *attr_value; // esi
  css_selector *v7; // edi
  scanner scanner; // [esp+24h] [ebp-D4h] BYREF

  if ( !assert_failed )
  {
    if ( element && css && element->options )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/apply.c";
      errline = 232;
      elinks_internal("assertion element && element->options && css failed!");
    }
  }
  inited = init_css_selector(0, CST_ELEMENT, 0, 0);
  v5 = inited;
  if ( inited )
  {
    examine_element(html_context, inited, CST_ELEMENT, CSR_ROOT, &css->selectors, element);
    attr_value = get_attr_value(element->options, "style", html_context->doc_cp, HTML_ATTR_NONE);
    if ( attr_value )
    {
      v7 = init_css_selector(0, CST_ELEMENT, 0, 0);
      if ( v7 )
      {
        init_scanner(&scanner, &css_scanner_info, attr_value, 0);
        css_parse_properties(&v7->properties, &scanner);
        merge_css_selectors(v5, v7);
        done_css_selector(v7);
      }
      mem_free(attr_value);
    }
  }
  return v5;
}

//----- (08084840) --------------------------------------------------------
void __cdecl css_apply(
        html_context *html_context,
        html_element *element,
        css_stylesheet *css,
        list_head_elinks *html_stack)
{
  css_selector *css_selector_for_element; // eax
  css_selector *v5; // edi

  css_selector_for_element = get_css_selector_for_element(html_context, element, css, html_stack);
  v5 = css_selector_for_element;
  if ( css_selector_for_element )
  {
    apply_css_selector_style(html_context, element, css_selector_for_element);
    done_css_selector(v5);
  }
}

//----- (080848B0) --------------------------------------------------------
void __cdecl done_css(module *module)
{
  done_css_stylesheet(&default_stylesheet);
}

//----- (080848D0) --------------------------------------------------------
void __cdecl import_css_file(css_stylesheet *css, uri *base_uri, const unsigned __int8 *url, int urllen)
{
  int v4; // ecx
  unsigned int v5; // eax
  size_t v6; // edx
  unsigned __int8 *source; // eax
  int length; // edx
  unsigned __int8 *v9; // eax
  size_t v10; // [esp+1Ch] [ebp-3Ch]
  int v11; // [esp+20h] [ebp-38h]
  int v12; // [esp+20h] [ebp-38h]
  unsigned int v13; // [esp+24h] [ebp-34h]
  connection_state v14; // [esp+28h] [ebp-30h] BYREF
  string filename; // [esp+30h] [ebp-28h] BYREF
  string string; // [esp+38h] [ebp-20h] BYREF

  if ( !*url || css->import_level > 9 || !init_string(&filename) )
    return;
  if ( *url != 47 && elinks_home )
    add_to_string(&filename, (const unsigned __int8 *)elinks_home);
  if ( assert_failed )
    goto LABEL_9;
  if ( urllen >= 0 )
  {
    assert_failed = 0;
    if ( !urllen )
      goto LABEL_10;
LABEL_15:
    v4 = filename.length + urllen;
    v5 = filename.length + 255;
    v6 = filename.length + urllen + 256;
    LOBYTE(v5) = 0;
    LOBYTE(v6) = 0;
    v13 = v5;
    if ( v6 > v5 )
    {
      v10 = v6;
      v12 = filename.length + urllen;
      v9 = (unsigned __int8 *)mem_realloc(filename.source, v6);
      if ( !v9 )
        goto LABEL_10;
      filename.source = v9;
      memset(&v9[v13], 0, v10 - v13);
      v4 = v12;
    }
    if ( filename.source )
    {
      v11 = v4;
      memcpy(&filename.source[filename.length], url, urllen);
      filename.source[v11] = 0;
      filename.length = v11;
    }
    goto LABEL_10;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  if ( !assert_failed )
    goto LABEL_15;
LABEL_9:
  assert_failed = 0;
LABEL_10:
  read_encoded_file(&v14, &filename, &string);
  if ( v14.basic == S_OK )
  {
    source = string.source;
    length = string.length;
    ++css->import_level;
    css_parse_stylesheet(css, base_uri, source, &source[length]);
    done_string(&string);
    --css->import_level;
  }
  done_string(&filename);
}

//----- (08084AA0) --------------------------------------------------------
void import_default_css()
{
  const char *number; // ebx
  int v1; // eax

  number = (const char *)get_opt_(config_options, "document.css.stylesheet")->number;
  if ( default_stylesheet.selectors.next != &default_stylesheet.selectors )
    done_css_stylesheet(&default_stylesheet);
  if ( *number )
  {
    v1 = strlen(number);
    import_css_file(&default_stylesheet, 0, (const unsigned __int8 *)number, v1);
  }
}

//----- (08084B10) --------------------------------------------------------
void __cdecl init_css(module *module)
{
  register_change_hooks(css_change_hooks_7084);
  import_default_css();
}

//----- (08084B30) --------------------------------------------------------
int __cdecl change_hook_css(session *ses, option_elinks *current, option_elinks *changed)
{
  session *i; // esi

  if ( !strcmp((const char *)changed->name, "stylesheet") )
    import_default_css();
  for ( i = (session *)sessions.next; i != (session *)&sessions; i = i->next )
    draw_formatted(i, 1);
  return 0;
}

//----- (08084B90) --------------------------------------------------------
void __cdecl import_css(css_stylesheet *css, uri *uri)
{
  cache_entry *redirected_cache_entry; // eax
  fragment *cache_fragment; // eax
  int length; // edx

  if ( uri )
  {
    if ( css->import_level <= 9 )
    {
      redirected_cache_entry = get_redirected_cache_entry(uri);
      if ( redirected_cache_entry )
      {
        cache_fragment = get_cache_fragment(redirected_cache_entry);
        if ( cache_fragment )
        {
          length = cache_fragment->length;
          ++css->import_level;
          css_parse_stylesheet(css, uri, cache_fragment->data, &cache_fragment->data[length]);
          --css->import_level;
        }
      }
    }
  }
}

//----- (08084C10) --------------------------------------------------------
css_selector *__usercall reparent_selector@<eax>(
        list_head_elinks *sels@<eax>,
        css_selector *selector@<edx>,
        css_selector **watch@<ecx>)
{
  css_selector *css_selector; // eax
  css_selector *i; // edx
  css_selector *next; // eax
  css_selector *twin; // [esp+28h] [ebp-20h]

  css_selector = find_css_selector(sels, selector->type, selector->relation, selector->name, -1);
  twin = css_selector;
  if ( css_selector )
  {
    merge_css_selectors(css_selector, selector);
    for ( i = (css_selector *)selector->leaves.next;
          i != (css_selector *)&selector->leaves;
          i = (css_selector *)selector->leaves.next )
    {
      reparent_selector(&twin->leaves, i, watch);
    }
    if ( *watch == selector )
      *watch = twin;
    done_css_selector(selector);
    return twin;
  }
  else
  {
    if ( selector->next )
    {
      selector->next->prev = selector->prev;
      selector->prev->next = selector->next;
    }
    next = (css_selector *)sels->next;
    selector->prev = (css_selector *)sels;
    selector->next = next;
    sels->next = selector;
    selector->next->prev = selector;
    return selector;
  }
}

//----- (08084CD0) --------------------------------------------------------
void __cdecl css_parse_properties(list_head_elinks *props, scanner *scanner)
{
  int tokens; // edx
  scanner_token *current; // ebx
  scanner_token *v4; // ecx
  int type; // eax
  css_property_info *v6; // edi
  unsigned __int8 *name; // eax
  css_property_value *v8; // eax
  color_T *v9; // ebx
  void *next; // eax
  int v11; // eax

  if ( !assert_failed )
  {
    assert_failed = props == 0 || scanner == 0;
    if ( props == 0 || scanner == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
      errline = 30;
      elinks_internal("assertion props && scanner failed!");
    }
  }
LABEL_4:
  tokens = scanner->tokens;
LABEL_5:
  while ( tokens > 0 )
  {
    current = scanner->current;
    v4 = &scanner->table[tokens];
    if ( current >= v4 )
      break;
    if ( !current )
      break;
    type = current->type;
    if ( current->type == 125 )
      break;
    if ( type == 256 )
    {
      if ( v4 > &current[1] && current[1].type == 58 )
      {
        v6 = css_property_info_0;
        if ( css_property_info_0[0].name )
        {
          while ( 1 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
            errline = 57;
            if ( !elinks_strlcasecmp(current->string, current->length, v6->name, 0xFFFFFFFF, 1) )
              break;
            name = v6[1].name;
            ++v6;
            if ( !name )
              goto LABEL_27;
          }
        }
        else
        {
LABEL_27:
          v6 = 0;
        }
        if ( skip_scanner_tokens(scanner, 58, 0) )
        {
          if ( v6 )
          {
            v8 = (css_property_value *)mem_calloc(1u, 0x18u);
            v9 = (color_T *)v8;
            if ( v8 )
            {
              v8[1].color = v6->type;
              v8[1].font_attribute.rem = v6->value_type;
              if ( css_parse_value(v6, v8 + 2, scanner) )
              {
                next = props->next;
                v9[1] = (color_T)props;
                *v9 = (color_T)next;
                props->next = v9;
                *(_DWORD *)(*v9 + 4) = v9;
              }
              else
              {
                mem_free(v9);
              }
            }
          }
          skip_scanner_tokens(scanner, 59, 256);
          goto LABEL_4;
        }
        if ( !assert_failed )
        {
          v11 = scanner->tokens;
          if ( v11 <= 0 || scanner->current >= &scanner->table[v11] )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
            errline = 65;
            elinks_internal("assertion !scanner_has_tokens(scanner) failed!");
          }
        }
        return;
      }
    }
    else if ( type == 123 )
    {
      scanner->current = current + 1;
      if ( &current[2] >= v4 )
      {
        scanner->info->scan(scanner);
        tokens = scanner->tokens;
      }
      goto LABEL_5;
    }
    skip_scanner_tokens(scanner, 59, 256);
    tokens = scanner->tokens;
  }
}

//----- (08084F40) --------------------------------------------------------
void __usercall skip_css_block(scanner *scanner@<eax>)
{
  int tokens; // edx
  scanner_token *current; // eax
  int v4; // esi
  int type; // eax
  scanner_token *v6; // ecx
  scanner_token *v7; // edx

  if ( skip_scanner_tokens(scanner, 123, 512) )
  {
    tokens = scanner->tokens;
    if ( tokens > 0 )
    {
      current = scanner->current;
      if ( current < &scanner->table[tokens] && current && current->precedence <= 1024 )
      {
        v4 = 1;
        while ( 1 )
        {
          type = current->type;
          if ( type == 123 )
            ++v4;
          else
            v4 -= type == 125;
          if ( tokens <= 0 )
            break;
          v6 = scanner->current;
          v7 = &scanner->table[tokens];
          if ( v6 >= v7 )
            break;
          current = v6 + 1;
          scanner->current = v6 + 1;
          if ( &v6[2] >= v7 )
          {
            current = scanner->info->scan(scanner);
          }
          else if ( current >= v7 )
          {
            return;
          }
          if ( !current || v4 <= 0 || current->precedence > 1024 )
            break;
          tokens = scanner->tokens;
        }
      }
    }
  }
}

//----- (08085010) --------------------------------------------------------
void __cdecl css_parse_stylesheet(css_stylesheet *css, uri *base_uri, unsigned __int8 *string, unsigned __int8 *end)
{
  int tokens; // edx
  scanner_token *current; // ebx
  unsigned int v6; // eax
  css_selector *v7; // esi
  _BOOL4 v8; // edi
  css_selector *css_selector; // ebx
  scanner_token *v10; // eax
  int v11; // edx
  int length; // edx
  int v13; // ecx
  const unsigned __int8 *v14; // ebx
  int v15; // eax
  void **v16; // edx
  css_selector *v17; // ebx
  void **v18; // eax
  void **j; // ebx
  void **k; // ecx
  void **v21; // esi
  _DWORD *v22; // edx
  _DWORD *p_next; // eax
  list_head_elinks *p_props; // ebx
  list_head_elinks *m; // edx
  list_head_elinks *v26; // esi
  list_head_elinks *v27; // edi
  unsigned int v28; // edx
  bool v29; // cf
  scanner_token *v30; // edx
  scanner_token *v31; // eax
  scanner_token *v32; // ebx
  scanner_token *v33; // eax
  list_head_elinks *v34; // eax
  css_selector *v35; // eax
  css_selector_relation v36; // ecx
  css_selector *next; // edx
  css_selector *v38; // ecx
  list_head_elinks *p_selectors; // eax
  _DWORD *v40; // eax
  scanner_token *v41; // ecx
  scanner_token *v42; // eax
  _DWORD *v43; // eax
  void **v44; // ecx
  void **i; // ecx
  void **v46; // ebx
  _DWORD *v47; // edx
  scanner_token *v48; // ebx
  scanner_token *v49; // eax
  scanner_token *v50; // ecx
  int v51; // eax
  scanner_token *v52; // ecx
  scanner_token *v53; // ebx
  scanner_token *v54; // eax
  bool v55; // zf
  scanner_token *v56; // eax
  scanner_token *v57; // eax
  scanner_token *v58; // ecx
  scanner_token *v59; // ecx
  scanner_token *v60; // eax
  scanner_token *v61; // [esp+34h] [ebp-124h]
  int v62; // [esp+4Ch] [ebp-10Ch]
  int v63; // [esp+4Ch] [ebp-10Ch]
  int v64; // [esp+50h] [ebp-108h]
  scanner_token *v65; // [esp+50h] [ebp-108h]
  css_selector *v66; // [esp+50h] [ebp-108h]
  int v67; // [esp+50h] [ebp-108h]
  int v68; // [esp+50h] [ebp-108h]
  int v69; // [esp+50h] [ebp-108h]
  _BOOL4 v70; // [esp+58h] [ebp-100h]
  css_selector_type type; // [esp+5Ch] [ebp-FCh]
  css_selector *v72; // [esp+60h] [ebp-F8h]
  css_selector *v73; // [esp+64h] [ebp-F4h]
  scanner_token *v74; // [esp+68h] [ebp-F0h]
  void *p; // [esp+6Ch] [ebp-ECh]
  scanner scanner; // [esp+74h] [ebp-E4h] BYREF
  list_head_elinks props; // [esp+130h] [ebp-28h] BYREF
  void *v78; // [esp+138h] [ebp-20h] BYREF
  void **v79; // [esp+13Ch] [ebp-1Ch]

  init_scanner(&scanner, &css_scanner_info, string, end);
  tokens = scanner.tokens;
LABEL_2:
  while ( tokens > 0 )
  {
    current = scanner.current;
    if ( scanner.current >= &scanner.table[tokens] )
      break;
    if ( !assert_failed )
    {
      assert_failed = scanner.current == 0;
      if ( !scanner.current )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
        errline = 553;
        elinks_internal("assertion token failed!");
        tokens = scanner.tokens;
      }
    }
    if ( (unsigned int)(current->type - 272) > 5 )
    {
      v7 = 0;
      v78 = &v78;
      v79 = &v78;
      v8 = 0;
      props.next = &props;
      props.prev = &props;
      v70 = 1;
      v72 = 0;
      v73 = 0;
      p = 0;
      while ( tokens > 0 )
      {
        v10 = scanner.current;
        if ( scanner.current >= &scanner.table[tokens] )
          break;
        if ( !assert_failed )
        {
          assert_failed = scanner.current == 0;
          if ( scanner.current
            || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c",
                errline = 278,
                elinks_internal("assertion token failed!"),
                v10 = 0,
                !assert_failed) )
          {
            assert_failed = v8;
            if ( v8 )
            {
              v65 = v10;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
              errline = 279;
              elinks_internal("assertion !last_fragment failed!");
              v10 = v65;
            }
          }
        }
        v11 = v10->type;
        if ( v10->type == 125 || v11 == 123 || v11 == 59 )
          break;
        if ( v11 == 256 )
        {
          length = v10->length;
          if ( p )
            v13 = 2;
          else
            v13 = 0;
          v14 = v10->string;
          type = CST_ELEMENT;
          goto LABEL_36;
        }
        if ( v11 == 62 )
        {
          type = CST_ELEMENT;
          v13 = 3;
          v28 = -205;
          goto LABEL_70;
        }
        if ( v11 > 62 )
        {
          v29 = v11 == 267;
          v28 = v11 - 267;
          if ( !v29 && v28 != 1 )
          {
LABEL_19:
            if ( skip_scanner_tokens(&scanner, 44, 0) )
            {
LABEL_20:
              tokens = scanner.tokens;
            }
            else
            {
              tokens = scanner.tokens;
              if ( scanner.tokens > 0 )
              {
                v57 = &scanner.table[scanner.tokens];
                if ( scanner.current < v57 )
                {
                  v58 = scanner.current + 2;
                  ++scanner.current;
                  if ( v58 >= v57 )
                  {
                    scanner.info->scan(&scanner);
                    tokens = scanner.tokens;
                  }
                }
              }
            }
            css_selector = v73;
            goto LABEL_22;
          }
          type = CST_ID;
          v13 = 2 - !v70;
LABEL_70:
          if ( v28 <= 1 )
          {
            v14 = v10->string + 1;
            length = v10->length - 1;
            v10->string = (unsigned __int8 *)v14;
            v10->length = length;
            goto LABEL_36;
          }
          goto LABEL_74;
        }
        if ( v11 == 46 )
        {
          type = CST_CLASS;
          if ( !v70 )
            goto LABEL_106;
        }
        else
        {
          if ( v11 != 58 )
            goto LABEL_19;
          type = CST_PSEUDO;
          if ( !v70 )
          {
LABEL_106:
            v13 = 1;
            goto LABEL_74;
          }
        }
        v13 = 2;
LABEL_74:
        if ( scanner.tokens <= 0 )
          break;
        v30 = &scanner.table[scanner.tokens];
        if ( scanner.current >= v30 )
          break;
        v31 = scanner.current + 1;
        v32 = scanner.current + 2;
        ++scanner.current;
        if ( v32 >= v30 )
        {
          v69 = v13;
          v31 = scanner.info->scan(&scanner);
          v13 = v69;
        }
        else if ( v31 >= v30 )
        {
          break;
        }
        if ( !v31 )
          break;
        if ( v31->type != 256 )
          goto LABEL_20;
        length = v31->length;
        v14 = v31->string;
LABEL_36:
        if ( &v14[length] < scanner.end )
        {
          v15 = v14[length];
          v70 = v15 != 46 && v15 != 35 && v15 != 58;
        }
        if ( scanner.tokens <= 0 )
          break;
        v61 = &scanner.table[scanner.tokens];
        if ( scanner.current >= v61 )
          break;
        v33 = scanner.current + 2;
        v74 = ++scanner.current;
        if ( v33 >= v61 )
        {
          v62 = length;
          v68 = v13;
          v56 = scanner.info->scan(&scanner);
          length = v62;
          v13 = v68;
          v74 = v56;
        }
        else if ( v74 >= v61 )
        {
          break;
        }
        if ( !v74 )
          break;
        v8 = v74->type == 44 || v74->type == 123;
        if ( !p )
        {
          if ( !css || (p_selectors = &css->selectors, v74->type != 44 && v74->type != 123) )
            p_selectors = 0;
          v67 = v13;
          css_selector = get_css_selector(p_selectors, type, CSR_ROOT, v14, length);
          if ( !css_selector )
            goto LABEL_20;
          v40 = mem_calloc(1u, 0xCu);
          p = v40;
          if ( !v40 )
            goto LABEL_20;
          *v40 = v78;
          v40[1] = &v78;
          v78 = v40;
          *(_DWORD *)(*v40 + 4) = v40;
          v40[2] = css_selector;
          if ( v67 == 1 )
            goto LABEL_94;
          goto LABEL_93;
        }
        if ( v13 != 1 )
        {
          if ( !css || (v34 = &css->selectors, v74->type != 44 && v74->type != 123) )
            v34 = 0;
          v64 = v13;
          v35 = get_css_selector(v34, type, CSR_ROOT, v14, length);
          v36 = v64;
          css_selector = v35;
          if ( !v35 )
            goto LABEL_20;
          if ( !assert_failed )
          {
            assert_failed = v7 == 0;
            if ( !v7 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
              errline = 429;
              elinks_internal("assertion prev_element_selector failed!");
              v36 = v64;
            }
          }
          next = (css_selector *)css_selector->leaves.next;
          v7->prev = (css_selector *)&css_selector->leaves;
          v7->next = next;
          css_selector->leaves.next = v7;
          v7->next->prev = v7;
          v7->relation = v36;
          v72 = v7;
LABEL_93:
          v7 = css_selector;
          css_selector = 0;
LABEL_94:
          if ( v8 )
          {
            v70 = 1;
            css_selector = 0;
            v7 = 0;
            v72 = 0;
            p = 0;
          }
          goto LABEL_96;
        }
        v38 = v73;
        if ( !v73 )
          v38 = v7;
        if ( !assert_failed )
        {
          assert_failed = v38 == 0;
          if ( !v38 )
          {
            v63 = length;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
            errline = 383;
            elinks_internal("assertion base_sel failed!");
            v38 = 0;
            length = v63;
          }
        }
        v66 = v38;
        css_selector = get_css_selector(&v38->leaves, type, CSR_SPECIFITY, v14, length);
        if ( !css_selector )
          goto LABEL_20;
        if ( v72 )
        {
          v72->next->prev = v72->prev;
          v72->prev->next = v72->next;
          v72->next = (css_selector *)css_selector->leaves.next;
          v72->prev = (css_selector *)&css_selector->leaves;
          css_selector->leaves.next = v72;
          v72->next->prev = v72;
        }
        if ( v66 == *((css_selector **)p + 2) )
          *((_DWORD *)p + 2) = css_selector;
        if ( v8 )
        {
          if ( !assert_failed )
          {
            assert_failed = v7 == 0;
            if ( !v7 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
              errline = 411;
              elinks_internal("assertion prev_element_selector failed!");
            }
          }
          v7->relation = CSR_ROOT;
          v7 = reparent_selector(&css->selectors, v7, (css_selector **)p + 2);
          goto LABEL_94;
        }
LABEL_96:
        if ( v74->type != 44 )
        {
          if ( v74->type == 123 )
            break;
          tokens = scanner.tokens;
LABEL_99:
          v8 = 0;
          goto LABEL_22;
        }
        tokens = scanner.tokens;
        if ( scanner.tokens <= 0 )
          goto LABEL_99;
        v41 = &scanner.table[scanner.tokens];
        if ( scanner.current >= v41 )
          goto LABEL_99;
        v42 = scanner.current + 2;
        ++scanner.current;
        if ( v42 < v41 )
          goto LABEL_99;
        v8 = 0;
        scanner.info->scan(&scanner);
        tokens = scanner.tokens;
LABEL_22:
        v73 = css_selector;
      }
      if ( p )
      {
        if ( v7 )
          done_css_selector(v7);
        *(_DWORD *)(*(_DWORD *)p + 4) = *((_DWORD *)p + 1);
        **((_DWORD **)p + 1) = *(_DWORD *)p;
        mem_free(p);
      }
      if ( &v78 == v78 )
        goto LABEL_142;
      if ( !skip_scanner_tokens(&scanner, 123, 512) )
      {
        if ( &v78 != v78 )
        {
          v43 = v78;
          v44 = (void **)v78;
          do
            v44 = (void **)*v44;
          while ( &v78 != v44 );
          for ( i = v79; &v78 != i; i = (void **)i[1] )
            ;
          v46 = *(void ***)v78;
          if ( &v78 != v78 )
          {
            v47 = *(_DWORD **)v78;
            while ( 1 )
            {
              v47[1] = v43[1];
              *(_DWORD *)v43[1] = *v43;
              mem_free(v43);
              v47 = *v46;
              if ( &v78 == v46 )
                break;
              v43 = v46;
              v46 = (void **)*v46;
            }
          }
        }
LABEL_142:
        skip_scanner_tokens(&scanner, 125, 1024);
        tokens = scanner.tokens;
        goto LABEL_2;
      }
      css_parse_properties(&props, &scanner);
      skip_scanner_tokens(&scanner, 125, 1024);
      v16 = (void **)v78;
      v17 = (css_selector *)v78;
      if ( v78 != &v78 )
      {
        do
        {
          add_selector_properties((css_selector *)v17->relation, &props);
          v17 = v17->next;
        }
        while ( v17 != (css_selector *)&v78 );
        v16 = (void **)v78;
      }
      v18 = v16;
      for ( j = v16; j != &v78; j = (void **)*j )
        ;
      for ( k = v79; k != j; k = (void **)k[1] )
        ;
      v21 = (void **)*v16;
      if ( v16 != j )
      {
        v22 = *v16;
        while ( 1 )
        {
          v22[1] = v18[1];
          *(_DWORD *)v18[1] = *v18;
          mem_free(v18);
          v22 = *v21;
          if ( v21 == j )
            break;
          v18 = v21;
          v21 = (void **)*v21;
        }
      }
      p_next = props.next;
      p_props = (list_head_elinks *)props.next;
      if ( props.next == &props )
      {
        p_props = &props;
      }
      else
      {
        do
          p_props = (list_head_elinks *)p_props->next;
        while ( p_props != &props );
      }
      for ( m = (list_head_elinks *)props.prev; m != p_props; m = (list_head_elinks *)m->prev )
        ;
      v26 = *(list_head_elinks **)props.next;
      v27 = *(list_head_elinks **)props.next;
      if ( props.next != p_props )
      {
        while ( 1 )
        {
          v26->prev = (void *)p_next[1];
          *(_DWORD *)p_next[1] = *p_next;
          mem_free(p_next);
          v26 = (list_head_elinks *)v26->next;
          if ( v27 == p_props )
            break;
          p_next = &v27->next;
          v27 = v26;
        }
      }
LABEL_67:
      tokens = scanner.tokens;
    }
    else
    {
      if ( tokens <= 0 || scanner.current >= &scanner.table[tokens] )
      {
        v6 = MEMORY[0] - 272;
      }
      else
      {
        v6 = scanner.current->type - 272;
        if ( v6 > 5 )
        {
LABEL_11:
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
          errline = 180;
          elinks_internal("@-rule parser called without atrule.");
          tokens = scanner.tokens;
          goto LABEL_2;
        }
      }
      switch ( v6 )
      {
        case 0u:
          if ( tokens <= 0 )
            return;
          break;
        case 1u:
          goto LABEL_163;
        case 2u:
        case 4u:
        case 5u:
          goto LABEL_152;
        case 3u:
          if ( tokens <= 0 )
            goto LABEL_2;
          v52 = &scanner.table[tokens];
          if ( scanner.current >= v52 )
            goto LABEL_2;
          v53 = scanner.current + 1;
          v54 = scanner.current + 2;
          ++scanner.current;
          if ( v54 >= v52 )
          {
            v53 = scanner.info->scan(&scanner);
          }
          else if ( v53 >= v52 )
          {
            goto LABEL_2;
          }
          if ( !v53 )
            goto LABEL_67;
          if ( v53->type == 271 || v53->type == 259 )
          {
            if ( !assert_failed )
            {
              v55 = css->import != 0;
              assert_failed = css->import == 0;
              if ( !v55 )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/parser.c";
                errline = 146;
                elinks_internal("assertion css->import failed!");
              }
            }
            css->import(css, base_uri, v53->string, v53->length);
          }
LABEL_163:
          skip_scanner_tokens(&scanner, 59, 256);
          tokens = scanner.tokens;
          goto LABEL_2;
        default:
          goto LABEL_11;
      }
      while ( 1 )
      {
        v48 = &scanner.table[tokens];
        if ( scanner.current >= v48 )
          break;
        v49 = scanner.current + 1;
        v50 = scanner.current + 2;
        ++scanner.current;
        if ( v50 >= v48 )
        {
          v49 = scanner.info->scan(&scanner);
        }
        else if ( v49 >= v48 )
        {
          goto LABEL_2;
        }
        if ( !v49 )
          goto LABEL_67;
        v51 = v49->type;
        if ( v51 == 59 )
        {
          tokens = scanner.tokens;
          if ( scanner.tokens <= 0 )
            return;
          v59 = &scanner.table[scanner.tokens];
          if ( scanner.current < v59 )
          {
            v60 = scanner.current + 2;
            ++scanner.current;
            if ( v60 >= v59 )
            {
              scanner.info->scan(&scanner);
              tokens = scanner.tokens;
            }
          }
          goto LABEL_2;
        }
        if ( v51 == 123 )
        {
LABEL_152:
          skip_css_block(&scanner);
          tokens = scanner.tokens;
          goto LABEL_2;
        }
        tokens = scanner.tokens;
        if ( scanner.tokens <= 0 )
          return;
      }
    }
  }
}

//----- (08085E40) --------------------------------------------------------
scanner_token *__cdecl scan_css_tokens(scanner *scanner)
{
  scanner *v1; // edi
  scanner_token *v2; // edx
  scanner_token *table; // eax
  int tokens; // ebx
  size_t v5; // edx
  unsigned __int8 *position; // ebx
  unsigned __int8 v7; // dl
  int v8; // eax
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // edx
  int v11; // eax
  bool v12; // cf
  int v13; // edx
  scanner_token *result; // eax
  unsigned __int8 *v15; // esi
  int v16; // ecx
  int v17; // ebx
  unsigned __int8 *v18; // ecx
  int v19; // eax
  unsigned __int8 *v20; // edx
  int v21; // ecx
  int v22; // eax
  scanner_token *v23; // ecx
  unsigned __int8 v24; // al
  int v25; // eax
  const unsigned __int8 *v26; // edx
  unsigned int v27; // ecx
  char *v28; // eax
  int v29; // eax
  int v30; // eax
  unsigned __int8 *v31; // ebx
  unsigned __int8 v32; // cl
  unsigned __int8 *v33; // edi
  unsigned __int8 *v34; // edx
  int v35; // eax
  unsigned int v36; // eax
  unsigned __int8 *v37; // edx
  unsigned __int8 *v38; // esi
  char *v39; // eax
  int v40; // eax
  unsigned __int8 *v41; // ecx
  int v42; // eax
  unsigned __int8 *v43; // edx
  unsigned int v44; // eax
  unsigned __int8 v45; // al
  unsigned int v46; // eax
  const char *v47; // edx
  int v48; // eax
  unsigned __int8 *v49; // eax
  _BYTE *j; // ebx
  unsigned __int8 *v51; // esi
  unsigned __int8 *i; // ecx
  unsigned __int8 *v53; // eax
  int v54; // [esp+Ch] [ebp-4Ch]
  int v55; // [esp+1Ch] [ebp-3Ch]
  scanner_token *v56; // [esp+1Ch] [ebp-3Ch]
  const unsigned __int8 *v57; // [esp+20h] [ebp-38h]
  unsigned __int8 *v58; // [esp+20h] [ebp-38h]
  int v59; // [esp+20h] [ebp-38h]
  const char *v60; // [esp+20h] [ebp-38h]
  int v61; // [esp+20h] [ebp-38h]
  int v62; // [esp+20h] [ebp-38h]
  int v63; // [esp+20h] [ebp-38h]
  unsigned __int8 *ident; // [esp+24h] [ebp-34h]
  unsigned __int8 *identa; // [esp+24h] [ebp-34h]
  unsigned __int8 *end; // [esp+28h] [ebp-30h]
  unsigned __int8 enda; // [esp+28h] [ebp-30h]
  unsigned __int8 *v68; // [esp+2Ch] [ebp-2Ch]
  bool v69; // [esp+2Ch] [ebp-2Ch]
  scanner_token *dest; // [esp+30h] [ebp-28h]
  scanner_token *table_end; // [esp+34h] [ebp-24h]
  scanner *v72; // [esp+38h] [ebp-20h]
  scanner *v73; // [esp+38h] [ebp-20h]
  bool v74; // [esp+38h] [ebp-20h]
  unsigned __int8 v75; // [esp+38h] [ebp-20h]
  scanner_token *current; // [esp+3Ch] [ebp-1Ch]

  v1 = scanner;
  dest = scanner->table;
  v2 = scanner->current;
  table = v2;
  tokens = &scanner->table[scanner->tokens] - v2;
  if ( tokens <= 0 )
  {
    table = scanner->table;
    tokens = 0;
  }
  if ( !assert_failed )
  {
    assert_failed = v2 == 0;
    if ( !v2 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
      errline = 216;
      v56 = table;
      elinks_internal("assertion scanner->current failed!");
      table = v56;
    }
  }
  v5 = 160;
  if ( tokens )
  {
    memmove(dest, table, 16 * tokens);
    table = &scanner->table[tokens];
    v5 = 160 - 16 * tokens;
  }
  memset(table, 0, v5);
  if ( !scanner->position )
  {
    if ( !tokens )
      tokens = -1;
    scanner->tokens = tokens;
    scanner->current = dest;
    if ( !assert_failed )
    {
      if ( tokens > 9 && &scanner->table[1] >= &scanner->table[tokens] )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
        errline = 231;
        elinks_internal("assertion check_scanner(scanner) failed!");
      }
      else
      {
        assert_failed = 0;
      }
    }
    tokens = scanner->tokens;
LABEL_35:
    if ( tokens > 0 )
    {
      result = scanner->current;
      if ( result < &scanner->table[tokens] )
        return result;
    }
    return 0;
  }
  scanner->tokens = tokens;
  if ( scanner == (scanner *)-28 )
    goto LABEL_35;
  current = &scanner->table[tokens];
  table_end = (scanner_token *)&scanner[1];
  if ( &scanner[1] <= (scanner *)current || (position = scanner->position, scanner->end <= position) )
  {
LABEL_16:
    if ( !assert_failed )
      goto LABEL_17;
    goto LABEL_19;
  }
  while ( 1 )
  {
    v7 = *position;
    v8 = *position;
    if ( (css_scanner_info.scan_table[v8] & 0x400) != 0 )
    {
      v9 = v1->end;
      do
      {
        v1->position = ++position;
        if ( v9 <= position )
          goto LABEL_16;
        v7 = *position;
        v8 = *position;
      }
      while ( (css_scanner_info.scan_table[v8] & 0x400) != 0 );
    }
    if ( !assert_failed )
    {
      assert_failed = v7 == 0;
      if ( !v7 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
        errline = 132;
        v55 = v8;
        elinks_internal("assertion first_char failed!");
        v7 = 0;
        v8 = v55;
      }
    }
    v15 = position + 1;
    current->string = position;
    v16 = css_scanner_info.scan_table[v8];
    if ( (v16 & 0x100) != 0 )
    {
      v17 = v7;
      v18 = v15;
      v19 = v7;
      v20 = v15;
      goto LABEL_43;
    }
    if ( (v16 & 2) != 0 || v7 == 46 )
    {
      v72 = (scanner *)v1->end;
      if ( v15 < (unsigned __int8 *)v72 )
      {
        v24 = *v15;
        if ( (css_scanner_info.scan_table[*v15] & 2) == 0 )
          goto LABEL_64;
        while ( ++v15 < (unsigned __int8 *)v72 )
        {
          v24 = *v15;
          if ( (css_scanner_info.scan_table[*v15] & 2) == 0 )
            goto LABEL_64;
        }
      }
      v24 = *v15;
LABEL_64:
      if ( v24 == 46 && (++v15, v24 = *v15, (css_scanner_info.scan_table[*v15] & 2) != 0) )
      {
        if ( v15 >= (unsigned __int8 *)v72 )
        {
LABEL_152:
          v17 = 257;
        }
        else
        {
          while ( ++v15 < (unsigned __int8 *)v72 )
          {
            v24 = *v15;
            if ( (css_scanner_info.scan_table[*v15] & 2) == 0 )
              goto LABEL_152;
          }
          v24 = *v15;
          v17 = 257;
        }
      }
      else
      {
        v17 = 284;
      }
      if ( v24 == 37 )
      {
        if ( v7 != 46 )
          v17 = 258;
        v20 = v15 + 1;
        v19 = v17;
        v18 = v15 + 1;
        goto LABEL_43;
      }
      v25 = css_scanner_info.scan_table[v24];
      if ( (v25 & 0x10) == 0 )
      {
        v18 = v15;
        v20 = v15;
        v19 = 257;
        v17 = 257;
        goto LABEL_43;
      }
      if ( v15 < (unsigned __int8 *)v72 && (v25 & 8) != 0 )
      {
        v26 = v15;
        do
          ++v26;
        while ( v26 < (const unsigned __int8 *)v72 && (css_scanner_info.scan_table[*v26] & 8) != 0 );
      }
      else
      {
        v26 = v15;
      }
      v54 = 261;
      goto LABEL_74;
    }
    if ( (v16 & 0x10) != 0 )
    {
      v27 = (unsigned int)v1->end;
      if ( (unsigned int)v15 < v27 )
      {
        while ( (css_scanner_info.scan_table[*v15] & 8) != 0 )
        {
          if ( (unsigned int)++v15 >= v27 )
            goto LABEL_106;
        }
        if ( *v15 != 40 )
          goto LABEL_81;
      }
      else
      {
LABEL_106:
        if ( *v15 != 40 )
          goto LABEL_81;
      }
      v20 = v15 + 1;
      if ( (unsigned int)(v15 + 1) >= v27 )
      {
        v68 = v15 + 1;
LABEL_150:
        if ( *v68 == 41 )
          goto LABEL_161;
      }
      else
      {
        LOBYTE(v30) = v15[1];
        if ( (_BYTE)v30 == 41 )
        {
          v68 = v15 + 1;
          goto LABEL_161;
        }
        v30 = (unsigned __int8)v30;
        if ( (unsigned __int8)v30 != 125 && v30 != 123 && v30 != 59 )
        {
          ident = position;
          v31 = v1->end;
          v32 = v15[1];
          end = v15;
          v73 = v1;
          v33 = v15 + 1;
          v34 = v15 + 1;
          while ( 1 )
          {
            if ( v32 == 39 || v32 == 34 )
            {
              v38 = v34 + 1;
              v39 = (char *)memchr(v34 + 1, v30, v31 - v34);
              v34 = (unsigned __int8 *)(v39 + 1);
              if ( !v39 )
                v34 = v38;
              if ( v31 <= v34 )
              {
LABEL_149:
                v68 = v34;
                v15 = end;
                v20 = v33;
                position = ident;
                v1 = v73;
                goto LABEL_150;
              }
            }
            else if ( v31 <= ++v34 )
            {
              goto LABEL_149;
            }
            v32 = *v34;
            if ( *v34 == 41 )
              break;
            v30 = v32;
            if ( v32 == 125 || v32 == 123 || v32 == 59 )
            {
              v20 = v33;
              v1 = v73;
              goto LABEL_121;
            }
          }
          v68 = v34;
          v15 = end;
          v20 = v33;
          position = ident;
          v1 = v73;
LABEL_161:
          v58 = v20;
          v42 = map_scanner_string(v1, position, v15, 269);
          v43 = v58;
          v17 = v42;
          if ( v42 == 269 )
          {
            v15 = v68;
            v21 = -1;
          }
          else
          {
            v21 = -1;
            if ( v42 == 271 )
            {
              while ( 1 )
              {
                if ( v43 >= v1->end )
                {
                  v51 = v43;
                  enda = *v43;
                  goto LABEL_232;
                }
                enda = *v43;
                if ( (css_scanner_info.scan_table[*v43] & 0x400) == 0 )
                  break;
                ++v43;
              }
              v51 = v43;
LABEL_232:
              for ( i = v68 - 1; ; --i )
              {
                if ( i < v1->string )
                {
                  v75 = *i;
                  v53 = i;
                  goto LABEL_238;
                }
                v75 = *i;
                if ( (css_scanner_info.scan_table[*i] & 0x400) == 0 )
                  break;
              }
              v53 = i;
LABEL_238:
              if ( enda == 39 || enda == 34 )
                v51 = v43 + 1;
              if ( v75 == 39 || v75 == 34 )
                v53 = i - 1;
              v21 = v53 - v51 + 1;
              current->string = v51;
              v15 = v68;
              if ( assert_failed )
                goto LABEL_217;
              assert_failed = (unsigned int)v21 >> 31;
              if ( v21 >= 0 )
                goto LABEL_166;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
              errline = 207;
              v63 = v21;
              elinks_internal("assertion real_length >= 0 failed!");
              v21 = v63;
            }
          }
          if ( assert_failed )
          {
LABEL_217:
            v20 = v15 + 1;
            goto LABEL_122;
          }
          if ( v17 == 270 && *v15 != 40 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
            errline = 211;
            v61 = v21;
            elinks_internal("assertion type != CSS_TOKEN_RGB || *string == '(' failed!");
            v21 = v61;
            if ( assert_failed )
              goto LABEL_217;
            goto LABEL_227;
          }
          v68 = v15;
LABEL_166:
          assert_failed = 0;
          if ( v17 == 271 && *v68 != 41 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
            errline = 212;
            v59 = v21;
            elinks_internal("assertion type != CSS_TOKEN_URL || *string == ')' failed!");
            v21 = v59;
            if ( assert_failed )
            {
              v20 = v68 + 1;
              goto LABEL_122;
            }
LABEL_169:
            assert_failed = 0;
            v20 = v68 + 1;
            goto LABEL_122;
          }
          v15 = v68;
LABEL_227:
          assert_failed = 0;
          if ( v17 == 269 && *v15 != 41 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
            errline = 213;
            v62 = v21;
            elinks_internal("assertion type != CSS_TOKEN_FUNCTION || *string == ')' failed!");
            v20 = v15 + 1;
            v21 = v62;
            goto LABEL_122;
          }
          v68 = v15;
          goto LABEL_169;
        }
      }
LABEL_121:
      v21 = -1;
      v17 = 284;
LABEL_122:
      v29 = v17;
      goto LABEL_123;
    }
    if ( (v16 & 0x200) == 0 )
      goto LABEL_96;
    switch ( v7 )
    {
      case '#':
        v35 = css_scanner_info.scan_table[*v15];
        if ( (v35 & 4) != 0 )
        {
          v36 = (unsigned int)v1->end;
          if ( (unsigned int)v15 < v36 )
          {
            do
              ++v15;
            while ( (unsigned int)v15 < v36 && (css_scanner_info.scan_table[*v15] & 4) != 0 );
          }
          v18 = v15;
          v37 = &v15[~(unsigned int)position];
          if ( (v37 == (unsigned __int8 *)6 || v37 == (unsigned __int8 *)3)
            && (css_scanner_info.scan_table[*v15] & 8) == 0 )
          {
            v20 = v15;
            v19 = 268;
            v17 = 268;
            goto LABEL_43;
          }
          if ( (unsigned int)v15 >= v36 || (css_scanner_info.scan_table[*v15] & 8) == 0 )
          {
            v20 = v15;
            v19 = 267;
            v17 = 267;
            goto LABEL_43;
          }
          while ( 1 )
          {
            v20 = v15 + 1;
            if ( (unsigned int)(v15 + 1) >= v36 || (css_scanner_info.scan_table[v15[1]] & 8) == 0 )
              break;
            ++v15;
          }
        }
        else
        {
          if ( (v35 & 8) == 0 )
            goto LABEL_96;
          v44 = (unsigned int)v1->end;
          if ( (unsigned int)v15 >= v44 )
          {
            v18 = position + 1;
            v20 = position + 1;
            v19 = 267;
            v17 = 267;
            goto LABEL_43;
          }
          while ( 1 )
          {
            v20 = v15 + 1;
            if ( (unsigned int)(v15 + 1) >= v44 || (css_scanner_info.scan_table[v15[1]] & 8) == 0 )
              break;
            ++v15;
          }
        }
        v18 = v20;
        v19 = 267;
        v17 = 267;
        goto LABEL_43;
      case '@':
        v40 = css_scanner_info.scan_table[*v15];
        if ( (v40 & 0x10) != 0 )
        {
          v41 = v1->end;
          if ( v15 < v41 && (v40 & 8) != 0 )
          {
            v26 = position + 1;
            do
              ++v26;
            while ( v26 < v41 && (css_scanner_info.scan_table[*v26] & 8) != 0 );
          }
          else
          {
            v26 = position + 1;
          }
          v54 = 272;
LABEL_74:
          v57 = v26;
          v19 = map_scanner_string(v1, v15, v26, v54);
          v20 = (unsigned __int8 *)v57;
          v18 = (unsigned __int8 *)v57;
          v17 = v19;
          goto LABEL_43;
        }
LABEL_96:
        v18 = position + 1;
        v20 = position + 1;
        v19 = 284;
        v17 = 284;
        goto LABEL_43;
      case '*':
        if ( *v15 == 61 )
        {
          v20 = position + 2;
          v19 = 283;
          v18 = position + 2;
          v17 = 283;
        }
        else
        {
LABEL_81:
          v18 = v15;
          v20 = v15;
          v19 = 256;
          v17 = 256;
        }
        goto LABEL_43;
      case '^':
        if ( *v15 == 61 )
        {
          v20 = position + 2;
          v19 = 281;
          v18 = position + 2;
          v17 = 281;
          goto LABEL_43;
        }
        goto LABEL_96;
      case '$':
        if ( *v15 == 61 )
        {
          v20 = position + 2;
          v19 = 282;
          v18 = position + 2;
          v17 = 282;
          goto LABEL_43;
        }
        goto LABEL_96;
      case '|':
        if ( *v15 == 61 )
        {
          v20 = position + 2;
          v19 = 280;
          v18 = position + 2;
          v17 = 280;
          goto LABEL_43;
        }
        goto LABEL_96;
      case '!':
        v46 = (unsigned int)v1->end;
        if ( v46 > (unsigned int)v15 && (css_scanner_info.scan_table[*v15] & 0x400) != 0 )
        {
          while ( 1 )
          {
            v47 = (const char *)(v15 + 1);
            if ( v46 <= (unsigned int)(v15 + 1) || (css_scanner_info.scan_table[v15[1]] & 0x400) == 0 )
              break;
            ++v15;
          }
        }
        else
        {
          v47 = (const char *)(position + 1);
        }
        v60 = v47;
        v48 = c_strncasecmp(v47, "important", 9u);
        v20 = (unsigned __int8 *)v60;
        if ( v48 )
        {
          v18 = (unsigned __int8 *)v60;
          v19 = 284;
          v17 = 284;
        }
        else
        {
          v20 = (unsigned __int8 *)(v60 + 9);
          v19 = 278;
          v18 = (unsigned __int8 *)(v60 + 9);
          v17 = 278;
        }
        goto LABEL_43;
    }
    if ( v7 != 39 && v7 != 34 )
    {
      v74 = v7 == 60;
      v69 = v7 == 45;
      if ( v7 == 45 || v7 == 60 )
      {
        v45 = *v15;
        if ( *v15 == 47 )
        {
          v18 = position + 1;
          v20 = position + 1;
          v19 = 0;
          v17 = 0;
        }
        else
        {
          identa = v1->end;
          v18 = position + 1;
          if ( v15 < identa )
          {
            v20 = position + 1;
            if ( SLOBYTE(css_scanner_info.scan_table[v45]) < 0 )
            {
              do
                ++v20;
              while ( v20 < identa && SLOBYTE(css_scanner_info.scan_table[*v20]) < 0 );
              v18 = position + 1;
              if ( v20 - v15 > 1 )
              {
                if ( v74 )
                {
                  if ( v45 == 33 )
                    goto LABEL_250;
                }
                else if ( v69 && *(v20 - 1) == 62 )
                {
                  goto LABEL_250;
                }
              }
            }
          }
LABEL_197:
          v20 = position + 1;
          v19 = 284;
          v17 = 284;
        }
LABEL_43:
        current->type = v19;
        goto LABEL_44;
      }
      if ( v7 == 47 )
      {
        if ( *v15 == 42 )
        {
          v49 = position + 2;
          for ( j = position + 3; ; ++j )
          {
            v20 = v49;
            if ( v49 >= v1->end )
              break;
            if ( *v49 == 42 && *j == 47 )
            {
              v20 = v49 + 2;
              v19 = 285;
              v18 = v20;
              v17 = 285;
              goto LABEL_43;
            }
            ++v49;
          }
LABEL_250:
          v18 = v20;
          v19 = 285;
          v17 = 285;
          goto LABEL_43;
        }
      }
      else
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/scanner.c";
        errline = 343;
        elinks_internal("Someone forgot to put code for recognizing tokens which start with '%c'.", v8);
      }
      goto LABEL_96;
    }
    v28 = (char *)memchr(position + 1, v8, v1->end - v15);
    v18 = position + 1;
    if ( !v28 )
      goto LABEL_197;
    v17 = 259;
    v21 = v28 - (char *)v15;
    current->string = v15;
    v20 = (unsigned __int8 *)(v28 + 1);
    v29 = 259;
LABEL_123:
    current->type = v29;
    if ( v21 > 0 )
      goto LABEL_45;
    v18 = v20;
LABEL_44:
    v21 = v18 - current->string;
LABEL_45:
    v22 = 1024;
    current->length = v21;
    if ( v17 != 125 )
    {
      LOWORD(v22) = 512;
      if ( v17 != 123 )
      {
        LOWORD(v22) = 256;
        if ( v17 != 59 )
        {
          LOWORD(v22) = 0;
          if ( v17 == 41 )
            v22 = 128;
        }
      }
    }
    current->precedence = v22;
    v1->position = v20;
    if ( !current->type )
      break;
    v23 = current - 1;
    if ( current->type != 285 )
      v23 = current;
    current = v23 + 1;
    if ( table_end <= &v23[1] || v1->end <= v20 )
      goto LABEL_16;
    position = v20;
  }
  v1->position = 0;
  --current;
  if ( assert_failed )
    goto LABEL_19;
LABEL_17:
  assert_failed = current > table_end;
  if ( current > table_end )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
    errline = 249;
    elinks_internal("assertion end <= scanner->table + SCANNER_TOKENS failed!");
  }
LABEL_19:
  v10 = v1->position;
  v11 = current - dest;
  v1->tokens = v11;
  v12 = v10 < v1->end;
  v1->current = dest;
  if ( !v12 )
    v1->position = 0;
  if ( !assert_failed )
  {
    if ( v11 <= 9 || &v1->current[1] < &v1->table[v11] )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.h";
      errline = 256;
      elinks_internal("assertion check_scanner(scanner) failed!");
    }
  }
  v13 = v1->tokens;
  if ( v13 <= 0 )
    return 0;
  result = v1->current;
  if ( result >= &v1->table[v13] )
    return 0;
  return result;
}

//----- (08086BA0) --------------------------------------------------------
css_stylesheet *__cdecl init_css_stylesheet(css_stylesheet_importer_T importer, void *import_data)
{
  css_stylesheet *result; // eax

  result = (css_stylesheet *)mem_calloc(1u, 0x14u);
  if ( result )
  {
    result->import = importer;
    result->import_data = import_data;
    result->selectors.prev = &result->selectors;
    result->selectors.next = &result->selectors;
  }
  return result;
}

//----- (08086BE0) --------------------------------------------------------
void __cdecl done_css_selector(css_selector *selector)
{
  css_selector *i; // eax
  css_selector *next; // eax
  css_selector *j; // ebx
  css_selector *k; // edx
  css_selector *v5; // esi
  css_selector *v6; // edx

  for ( i = (css_selector *)selector->leaves.next;
        i != (css_selector *)&selector->leaves;
        i = (css_selector *)selector->leaves.next )
  {
    done_css_selector(i);
  }
  if ( selector->next )
  {
    selector->next->prev = selector->prev;
    selector->prev->next = selector->next;
  }
  next = (css_selector *)selector->properties.next;
  for ( j = next; j != (css_selector *)&selector->properties; j = j->next )
    ;
  for ( k = (css_selector *)selector->properties.prev; k != j; k = k->prev )
    ;
  v5 = next->next;
  if ( next != j )
  {
    v6 = next->next;
    while ( 1 )
    {
      v6->prev = next->prev;
      next->prev->next = next->next;
      mem_free(next);
      v6 = v5->next;
      next = v5;
      if ( v5 == j )
        break;
      v5 = v5->next;
    }
  }
  if ( selector->name )
    mem_free(selector->name);
  mem_free(selector);
}

//----- (08086C90) --------------------------------------------------------
void __cdecl done_css_stylesheet(css_stylesheet *css)
{
  css_selector *i; // eax

  for ( i = (css_selector *)css->selectors.next;
        i != (css_selector *)&css->selectors;
        i = (css_selector *)css->selectors.next )
  {
    done_css_selector(i);
  }
}

//----- (08086CC0) --------------------------------------------------------
void __cdecl merge_css_selectors(css_selector *sel1, css_selector *sel2)
{
  list_head_elinks *next; // esi
  list_head_elinks *p_properties; // ebx
  list_head_elinks *v4; // eax
  void *v5; // edx
  _DWORD *v6; // eax
  void *v7; // edx

  next = (list_head_elinks *)sel2->properties.next;
  if ( next != &sel2->properties )
  {
    p_properties = &sel1->properties;
    do
    {
      v4 = (list_head_elinks *)sel1->properties.next;
      if ( v4 != p_properties )
      {
        v5 = next[1].next;
        if ( v4[1].next == v5 )
        {
LABEL_12:
          *((_DWORD *)v4->next + 1) = v4->prev;
          *(_DWORD *)v4->prev = v4->next;
          mem_free(v4);
        }
        else
        {
          while ( 1 )
          {
            v4 = (list_head_elinks *)v4->next;
            if ( v4 == p_properties )
              break;
            if ( v4[1].next == v5 )
              goto LABEL_12;
          }
        }
      }
      v6 = mem_alloc(0x18u);
      if ( v6 )
      {
        *v6 = next->next;
        v6[1] = next->prev;
        v6[2] = next[1].next;
        v6[3] = next[1].prev;
        v6[4] = next[2].next;
        v6[5] = next[2].prev;
        v7 = p_properties->next;
        v6[1] = p_properties;
        *v6 = v7;
        p_properties->next = v6;
        *(_DWORD *)(*v6 + 4) = v6;
      }
      next = (list_head_elinks *)next->next;
    }
    while ( next != &sel2->properties );
  }
}

//----- (08086D80) --------------------------------------------------------
void __cdecl add_selector_properties(css_selector *selector, list_head_elinks *properties)
{
  list_head_elinks *next; // ebx
  list_head_elinks *p_properties; // esi
  _DWORD *v4; // eax
  void *v5; // edx

  next = (list_head_elinks *)properties->next;
  if ( properties->next != properties )
  {
    p_properties = &selector->properties;
    do
    {
      v4 = mem_alloc(0x18u);
      if ( v4 )
      {
        *v4 = next->next;
        v4[1] = next->prev;
        v4[2] = next[1].next;
        v4[3] = next[1].prev;
        v4[4] = next[2].next;
        v4[5] = next[2].prev;
        v5 = p_properties->next;
        v4[1] = p_properties;
        *v4 = v5;
        p_properties->next = v4;
        *(_DWORD *)(*v4 + 4) = v4;
      }
      next = (list_head_elinks *)next->next;
    }
    while ( next != properties );
  }
}

//----- (08086DF0) --------------------------------------------------------
css_selector *__cdecl init_css_selector(
        list_head_elinks *sels,
        css_selector_type type,
        const unsigned __int8 *name,
        int namelen)
{
  css_selector *v4; // eax
  css_selector *v5; // ebx
  list_head_elinks *p_leaves; // eax
  unsigned __int8 *v7; // eax
  css_selector *next; // eax
  css_selector *v10; // [esp+0h] [ebp-28h]

  v4 = (css_selector *)mem_calloc(1u, 0x24u);
  v5 = v4;
  if ( v4 )
  {
    v4->relation = CSR_ROOT;
    p_leaves = &v4->leaves;
    v5->leaves.prev = p_leaves;
    v5->leaves.next = p_leaves;
    v5->type = type;
    v5->properties.prev = &v5->properties;
    v5->properties.next = &v5->properties;
    if ( !name )
      goto LABEL_6;
    if ( namelen < 0 )
      namelen = strlen((const char *)name);
    v7 = memacpy(name, namelen);
    v5->name = v7;
    if ( !v7 )
    {
      v10 = v5;
      v5 = 0;
      mem_free(v10);
    }
    else
    {
LABEL_6:
      if ( sels )
      {
        next = (css_selector *)sels->next;
        v5->prev = (css_selector *)sels;
        v5->next = next;
        sels->next = v5;
        v5->next->prev = v5;
      }
    }
  }
  return v5;
}

//----- (08086EA0) --------------------------------------------------------
void __cdecl mirror_css_stylesheet(css_stylesheet *css1, css_stylesheet *css2)
{
  list_head_elinks *i; // ebx
  const char *next; // esi
  css_selector *inited; // eax
  int v5; // [esp+Ch] [ebp-2Ch]

  for ( i = (list_head_elinks *)css1->selectors.next; i != &css1->selectors; i = (list_head_elinks *)i->next )
  {
    if ( !assert_failed )
    {
      assert_failed = i == 0 || css2 == 0;
      if ( i == 0 || css2 == 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
        errline = 148;
        elinks_internal("assertion css && orig failed!");
        if ( !assert_failed )
        {
          assert_failed = i == 0 || css2 == 0;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
          errline = 111;
          elinks_internal("assertion css && orig failed!");
        }
      }
      else
      {
        assert_failed = 0;
      }
    }
    next = (const char *)i[3].next;
    v5 = strlen(next);
    inited = init_css_selector(&css2->selectors, (css_selector_type)i[2].prev, (const unsigned __int8 *)next, v5);
    if ( inited )
      add_selector_properties(inited, (list_head_elinks *)((char *)i + 28));
  }
}

//----- (08086FA0) --------------------------------------------------------
css_selector *__cdecl find_css_selector(
        list_head_elinks *sels,
        css_selector_type type,
        css_selector_relation rel,
        const unsigned __int8 *name,
        int namelen)
{
  css_selector_relation v5; // ecx
  css_selector *next; // ebx
  css_selector_relation v7; // esi

  v5 = rel;
  if ( !assert_failed )
  {
    assert_failed = sels == 0 || name == 0;
    if ( sels == 0 || name == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
      errline = 36;
      elinks_internal("assertion sels && name failed!");
      v5 = rel;
    }
  }
  next = (css_selector *)sels->next;
  if ( sels->next == sels )
    return 0;
  v7 = v5;
  while ( 1 )
  {
    if ( next->type == type && next->relation == v7 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/stylesheet.c";
      errline = 41;
      if ( !elinks_strlcasecmp(name, namelen, next->name, 0xFFFFFFFF, 1) )
        break;
    }
    next = next->next;
    if ( next == (css_selector *)sels )
      return 0;
  }
  return next;
}

//----- (08087080) --------------------------------------------------------
css_selector *__cdecl get_css_selector(
        list_head_elinks *sels,
        css_selector_type type,
        css_selector_relation rel,
        const unsigned __int8 *name,
        int namelen)
{
  css_selector *result; // eax

  if ( !name || !sels || !namelen || (result = find_css_selector(sels, type, rel, name, namelen)) == 0 )
  {
    result = init_css_selector(sels, type, name, namelen);
    if ( result )
      result->relation = rel;
  }
  return result;
}

//----- (08087100) --------------------------------------------------------
int __cdecl css_parse_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // edx
  css_property_value_parser_T parser; // ecx

  if ( !assert_failed )
  {
    if ( scanner && value && propinfo )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 320;
      elinks_internal("assertion scanner && value && propinfo failed!");
      if ( assert_failed )
        goto LABEL_4;
    }
    parser = propinfo->parser;
    assert_failed = parser == 0;
    if ( !parser )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 321;
      elinks_internal("assertion propinfo->parser failed!");
    }
  }
LABEL_4:
  tokens = scanner->tokens;
  if ( tokens > 0 && (current = scanner->current, current < &scanner->table[tokens]) && current )
    return propinfo->parser(propinfo, value, scanner);
  else
    return 0;
}

//----- (08087200) --------------------------------------------------------
int __cdecl css_parse_display_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // ebx
  bool v5; // zf

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( assert_failed
    || (v5 = propinfo->value_type == CSS_VT_DISPLAY, assert_failed = propinfo->value_type != CSS_VT_DISPLAY, v5) )
  {
    if ( current->type != 256 )
      return 0;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 293;
    elinks_internal("assertion propinfo->value_type == CSS_VT_DISPLAY failed!");
    if ( current->type != 256 )
      return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 298;
  if ( elinks_strlcasecmp(current->string, current->length, "inline", 6u, 1)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c",
        errline = 300,
        elinks_strlcasecmp(current->string, current->length, "inline-block", 0xCu, 1)) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 302;
    if ( elinks_strlcasecmp(current->string, current->length, "block", 5u, 1) )
      return 0;
    value->color = 1;
  }
  else
  {
    value->color = 0;
  }
  skip_scanner_tokens(scanner, 256, 0);
  return 1;
}

//----- (080873B0) --------------------------------------------------------
int __cdecl css_parse_white_space_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // ebx
  bool v5; // zf

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( assert_failed
    || (v5 = propinfo->value_type == CSS_VT_FONT_ATTRIBUTE,
        assert_failed = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE,
        v5) )
  {
    if ( current->type != 256 )
      return 0;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 267;
    elinks_internal("assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    if ( current->type != 256 )
      return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 272;
  if ( elinks_strlcasecmp(current->string, current->length, (const unsigned __int8 *)"pre", 3u, 1) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 275;
    if ( elinks_strlcasecmp(current->string, current->length, "normal", 6u, 1) )
      return 0;
    value->font_attribute.rem |= 0x20u;
  }
  else
  {
    value->color |= 0x20u;
  }
  skip_scanner_tokens(scanner, 256, 0);
  return 1;
}

//----- (08087510) --------------------------------------------------------
int __cdecl css_parse_text_decoration_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // ebx
  bool v5; // zf

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( assert_failed
    || (v5 = propinfo->value_type == CSS_VT_FONT_ATTRIBUTE,
        assert_failed = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE,
        v5) )
  {
    if ( current->type != 256 )
      return 0;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 240;
    elinks_internal("assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    if ( current->type != 256 )
      return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 246;
  if ( elinks_strlcasecmp(current->string, current->length, "underline", 9u, 1) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 249;
    if ( elinks_strlcasecmp(current->string, current->length, "none", 4u, 1) )
      return 0;
    value->font_attribute.rem |= 4u;
  }
  else
  {
    value->color |= 4u;
  }
  skip_scanner_tokens(scanner, 256, 0);
  return 1;
}

//----- (08087670) --------------------------------------------------------
int __cdecl css_parse_text_align_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // ebx
  bool v5; // zf

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( assert_failed
    || (v5 = propinfo->value_type == CSS_VT_TEXT_ALIGN, assert_failed = propinfo->value_type != CSS_VT_TEXT_ALIGN, v5) )
  {
    if ( current->type != 256 )
      return 0;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 208;
    elinks_internal("assertion propinfo->value_type == CSS_VT_TEXT_ALIGN failed!");
    if ( current->type != 256 )
      return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 212;
  if ( elinks_strlcasecmp(current->string, current->length, "left", 4u, 1) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 215;
    if ( elinks_strlcasecmp(current->string, current->length, "right", 5u, 1) )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 218;
      if ( elinks_strlcasecmp(current->string, current->length, "center", 6u, 1) )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 221;
        if ( elinks_strlcasecmp(current->string, current->length, "justify", 7u, 1) )
          return 0;
        value->color = 3;
      }
      else
      {
        value->color = 1;
      }
    }
    else
    {
      value->color = 2;
    }
  }
  else
  {
    value->color = 0;
  }
  skip_scanner_tokens(scanner, 256, 0);
  return 1;
}

//----- (08087880) --------------------------------------------------------
int __cdecl css_parse_font_style_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // ebx
  bool v5; // zf

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( assert_failed
    || (v5 = propinfo->value_type == CSS_VT_FONT_ATTRIBUTE,
        assert_failed = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE,
        v5) )
  {
    if ( current->type != 256 )
      return 0;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 127;
    elinks_internal("assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
    if ( current->type != 256 )
      return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
  errline = 131;
  if ( elinks_strlcasecmp(current->string, current->length, "italic", 6u, 1)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c",
        errline = 132,
        elinks_strlcasecmp(current->string, current->length, "oblique", 7u, 1)) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
    errline = 135;
    if ( elinks_strlcasecmp(current->string, current->length, "underline", 9u, 1) )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 138;
      if ( elinks_strlcasecmp(current->string, current->length, "normal", 6u, 1) )
        return 0;
      value->font_attribute.rem |= 2u;
    }
    else
    {
      value->color |= 4u;
    }
  }
  else
  {
    value->color |= 2u;
  }
  skip_scanner_tokens(scanner, 256, 0);
  return 1;
}

//----- (08087A70) --------------------------------------------------------
int __cdecl css_parse_font_weight_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // ebx
  bool v5; // zf
  int type; // eax
  int v8; // edx
  int v9; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *nstring; // [esp+3Ch] [ebp-1Ch] BYREF

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( !assert_failed )
  {
    v5 = propinfo->value_type == CSS_VT_FONT_ATTRIBUTE;
    assert_failed = propinfo->value_type != CSS_VT_FONT_ATTRIBUTE;
    if ( !v5 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 159;
      elinks_internal("assertion propinfo->value_type == CSS_VT_FONT_ATTRIBUTE failed!");
      type = current->type;
      if ( current->type != 256 )
        goto LABEL_6;
LABEL_10:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 162;
      if ( !elinks_strlcasecmp(current->string, current->length, "bolder", 6u, 1) )
      {
LABEL_11:
        value->color |= 1u;
LABEL_12:
        skip_scanner_tokens(scanner, 256, 0);
        return 1;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 165;
      if ( elinks_strlcasecmp(current->string, current->length, "lighter", 7u, 1) )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 168;
        if ( !elinks_strlcasecmp(current->string, current->length, "bold", 4u, 1) )
          goto LABEL_11;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
        errline = 171;
        if ( elinks_strlcasecmp(current->string, current->length, "normal", 6u, 1) )
          return 0;
      }
      value->font_attribute.rem |= 1u;
      goto LABEL_12;
    }
  }
  type = current->type;
  if ( current->type == 256 )
    goto LABEL_10;
LABEL_6:
  if ( type != 257 )
    return 0;
  v8 = strtol((const char *)current->string, (char **)&nstring, 10);
  if ( current->string == nstring )
    return 0;
  v9 = v8;
  skip_scanner_tokens(scanner, 257, 0);
  if ( v9 <= 99 || v9 <= 900 && v9 <= 699 )
    return 1;
  value->color |= 1u;
  return 1;
}

//----- (08087D00) --------------------------------------------------------
int __cdecl css_parse_color_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  int tokens; // eax
  scanner_token *current; // esi
  bool v5; // zf
  int type; // eax
  int v8; // eax
  int v9; // edx
  int v10; // eax
  scanner_token *v11; // edx
  scanner_token *v12; // eax
  scanner_token *v13; // edi
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  scanner_token *v18; // eax
  int v19; // ebx
  int v20; // edx
  scanner_token *v21; // eax
  int v22; // edx
  int v23; // eax
  int v24; // edx
  scanner_token *v25; // [esp+1Ch] [ebp-3Ch]
  int v26; // [esp+28h] [ebp-30h]
  int skipto; // [esp+2Ch] [ebp-2Ch]
  const unsigned __int8 *nstring; // [esp+3Ch] [ebp-1Ch] BYREF

  tokens = scanner->tokens;
  if ( tokens <= 0 || (current = scanner->current, current >= &scanner->table[tokens]) )
    current = 0;
  if ( !assert_failed )
  {
    v5 = propinfo->value_type == CSS_VT_COLOR;
    assert_failed = propinfo->value_type != CSS_VT_COLOR;
    if ( !v5 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 30;
      elinks_internal("assertion propinfo->value_type == CSS_VT_COLOR failed!");
    }
  }
  type = current->type;
  if ( current->type == 270 )
  {
    v10 = scanner->tokens;
    if ( v10 <= 0 )
      return 1;
    v11 = scanner->current;
    v12 = &scanner->table[v10];
    if ( v11 >= v12 )
      return 1;
    v13 = v11 + 1;
    scanner->current = v11 + 1;
    if ( &v11[2] >= v12 )
    {
      v13 = scanner->info->scan(scanner);
    }
    else if ( v13 >= v12 )
    {
      return 1;
    }
    if ( v13 )
    {
      v14 = 16;
      while ( 1 )
      {
        v19 = v14 == 0 ? 41 : 44;
        nstring = v13->string;
        if ( (unsigned int)(v13->type - 257) > 1 )
          return 0;
        v20 = scanner->tokens;
        if ( v20 <= 0 )
          return 0;
        v21 = scanner->current;
        v25 = &scanner->table[v20];
        if ( v21 >= v25 )
          return 0;
        if ( v25 <= &v21[1] )
          return 0;
        skipto = v21[1].type;
        if ( skipto != (unsigned __int8)v19 )
          return 0;
        v26 = v14;
        v22 = strtol((const char *)v13->string, (char **)&nstring, 10);
        if ( v13->string == nstring )
          return 0;
        if ( v13->type == 258 )
          break;
        v15 = 0;
        if ( v22 >= 0 )
          goto LABEL_25;
LABEL_28:
        value->color |= v15;
        v17 = 0;
        if ( (_BYTE)v19 == 41 )
          v17 = 128;
        v18 = skip_scanner_tokens(scanner, skipto, v17);
        v14 = v26 - 8;
        v13 = v18;
        if ( !v18 || v14 < 0 )
          return 1;
      }
      v23 = 100;
      if ( v22 <= 100 )
        v23 = v22;
      v24 = 0;
      if ( v23 >= 0 )
        v24 = v23;
      v22 = 255 * v24 / 100;
LABEL_25:
      v16 = 255;
      if ( v22 <= 255 )
        v16 = v22;
      v15 = v16 << v26;
      goto LABEL_28;
    }
    return 1;
  }
  if ( type != 268 && type != 256 || decode_color(current->string, current->length, (color_T *)value) < 0 )
    return 0;
  v8 = current->type;
  v9 = 1024;
  if ( current->type != 125 )
  {
    LOWORD(v9) = 512;
    if ( v8 != 123 )
    {
      LOWORD(v9) = 256;
      if ( v8 != 59 )
      {
        LOWORD(v9) = 0;
        if ( v8 == 41 )
          v9 = 128;
      }
    }
  }
  skip_scanner_tokens(scanner, v8, v9);
  return 1;
}

//----- (08087FA0) --------------------------------------------------------
int __cdecl css_parse_background_value(css_property_info *propinfo, css_property_value *value, scanner *scanner)
{
  bool v3; // zf
  int tokens; // edx
  int v5; // esi
  scanner_token *current; // eax
  int type; // ecx

  if ( !assert_failed )
  {
    v3 = propinfo->value_type == CSS_VT_COLOR;
    assert_failed = propinfo->value_type != CSS_VT_COLOR;
    if ( !v3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/css/value.c";
      errline = 96;
      elinks_internal("assertion propinfo->value_type == CSS_VT_COLOR failed!");
    }
  }
  tokens = scanner->tokens;
  v5 = 0;
  while ( tokens > 0 )
  {
    current = scanner->current;
    if ( current >= &scanner->table[tokens] )
      break;
    type = current->type;
    if ( current->type == 125 || type == 123 || type == 59 )
      break;
    if ( type == 44 )
      goto LABEL_11;
    if ( css_parse_color_value(propinfo, value, scanner) )
    {
      ++v5;
      tokens = scanner->tokens;
    }
    else
    {
      tokens = scanner->tokens;
      if ( tokens <= 0 )
        return v5;
      current = scanner->current;
      if ( &scanner->table[tokens] > current )
      {
LABEL_11:
        scanner->current = current + 1;
        if ( &current[2] >= &scanner->table[tokens] )
        {
          scanner->info->scan(scanner);
          tokens = scanner->tokens;
        }
      }
    }
  }
  return v5;
}

//----- (080880B0) --------------------------------------------------------
screen_char *__usercall realloc_line@<eax>(document *document@<eax>, int x@<edx>, int y@<ecx>)
{
  line *v5; // eax
  line *v6; // edi
  int length; // edx
  unsigned int v9; // edx
  unsigned int v10; // ecx
  screen_char *chars; // edx
  int v12; // eax
  screen_char *v13; // eax
  unsigned int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch]

  v5 = realloc_lines(document, y);
  v6 = v5;
  if ( !v5 )
    return 0;
  length = v5->length;
  if ( length < x )
  {
    v9 = (length + 15) & 0xFFFFFFF0;
    v10 = (x + 15) & 0xFFFFFFF0;
    if ( v10 > v9 )
    {
      v14 = v9;
      v15 = 8 * v10;
      v13 = (screen_char *)mem_realloc(v5->chars, 8 * v10);
      if ( !v13 )
        return 0;
      v6->chars = v13;
      memset(&v13[v14], 0, v15 - 8 * v14);
    }
    chars = v6->chars;
    if ( v6->chars )
    {
      v12 = v6->length;
      if ( x > v12 )
      {
        while ( 1 )
        {
          chars[v12].data = 32;
          v12 = v6->length + 1;
          v6->length = v12;
          if ( x <= v12 )
            break;
          chars = v6->chars;
        }
      }
      if ( x > document->width )
        document->width = x;
      return v6->chars;
    }
    return 0;
  }
  return v6->chars;
}

//----- (08088180) --------------------------------------------------------
void __usercall render_dom_text(
        dom_renderer *renderer@<eax>,
        screen_char *a2@<edx>,
        unsigned __int8 *string@<ecx>,
        int length)
{
  unsigned __int8 *v6; // ecx
  unsigned __int8 *v7; // eax
  _BOOL4 v8; // edx
  int v9; // edi
  document *v10; // ecx
  conv_table *v11; // eax
  convert_string_mode convert_mode; // edx
  int v13; // eax
  _DWORD *v14; // eax
  int canvas_x; // edx
  int v16; // edx
  conv_table *v17; // edx
  int v18; // ecx
  unicode_val_T v19; // edx
  int v20; // eax
  screen_char *v21; // eax
  int v22; // edx
  int v23; // edi
  int v24; // edx
  screen_char *v25; // eax
  unicode_val_T v26; // eax
  screen_char *v27; // eax
  convert_string_mode v28; // [esp+28h] [ebp-50h]
  int v29; // [esp+2Ch] [ebp-4Ch]
  unsigned __int8 *end; // [esp+30h] [ebp-48h]
  document *document; // [esp+34h] [ebp-44h]
  bool v32; // [esp+3Bh] [ebp-3Dh]
  unsigned __int8 *p; // [esp+3Ch] [ebp-3Ch]
  int canvas_y; // [esp+40h] [ebp-38h]
  int v35; // [esp+40h] [ebp-38h]
  int charslen; // [esp+44h] [ebp-34h]
  conv_table *convert_table; // [esp+48h] [ebp-30h]
  conv_table *convert_tablea; // [esp+48h] [ebp-30h]
  conv_table *convert_tableb; // [esp+48h] [ebp-30h]
  unsigned __int8 *chars; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v41; // [esp+58h] [ebp-20h] BYREF
  int v42[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  chars = string;
  if ( length > 0 )
  {
    v6 = &string[length];
    if ( &chars[length] <= chars )
      goto LABEL_16;
    while ( 1 )
    {
      v7 = chars;
      v8 = *chars == 13;
      v9 = (int)&chars[v8];
      if ( chars[v8] == 10 )
      {
LABEL_10:
        v9 = (int)&v7[v8 + 1];
        charslen = v7 - chars;
      }
      else
      {
        if ( *chars == 13 )
        {
          charslen = 0;
          goto LABEL_12;
        }
        v7 = chars;
        do
        {
          if ( v6 <= ++v7 )
            goto LABEL_16;
          v8 = *v7 == 13;
          v9 = (int)&v7[v8];
          if ( v7[v8] == 10 )
            goto LABEL_10;
        }
        while ( *v7 != 13 );
        charslen = v7 - chars;
      }
      if ( charslen )
        goto LABEL_17;
      while ( 1 )
      {
LABEL_12:
        if ( v9 )
        {
          ++renderer->canvas_y;
          renderer->canvas_x = 0;
          charslen = v9 - (_DWORD)chars;
        }
        length -= charslen;
        if ( length <= 0 )
          return;
        chars += charslen;
        v6 = &chars[length];
        if ( &chars[length] > chars )
          break;
LABEL_16:
        v9 = 0;
        charslen = length;
LABEL_17:
        v10 = renderer->document;
        v11 = renderer->convert_table;
        v42[0] = charslen;
        convert_mode = renderer->convert_mode;
        document = v10;
        convert_table = v11;
        v13 = charslen;
        v32 = (*((_BYTE *)&v10->options + 92) & 0x10) != 0;
        if ( !assert_failed )
        {
          if ( a2 && chars )
          {
            assert_failed = 0;
            v13 = charslen;
          }
          else
          {
            v28 = renderer->convert_mode;
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 259;
            elinks_internal("assertion renderer && template && string && length failed!");
            v13 = v42[0];
            convert_mode = v28;
          }
        }
        p = convert_string_elinks(convert_table, chars, v13, document->options.cp, convert_mode, v42, 0, 0);
        if ( p )
        {
          if ( realloc_line(document, renderer->canvas_x + v42[0], renderer->canvas_y) )
          {
            convert_tablea = (conv_table *)v42[0];
            v14 = mem_alloc(0x18u);
            if ( v14 )
            {
              canvas_y = renderer->canvas_y;
              canvas_x = renderer->canvas_x;
              if ( canvas_x < 0 )
                canvas_x = 0;
              v14[2] = canvas_x;
              v16 = canvas_y;
              if ( canvas_y < 0 )
                v16 = 0;
              v14[3] = v16;
              v17 = convert_tablea;
              v14[5] = 1;
              if ( (int)convert_tablea < 0 )
                v17 = 0;
              v14[4] = v17;
              *v14 = renderer->document->nodes.next;
              v14[1] = &renderer->document->nodes;
              renderer->document->nodes.next = v14;
              *(_DWORD *)(*v14 + 4) = v14;
            }
            v18 = v42[0];
            end = &p[v42[0]];
            if ( v42[0] > 0 )
            {
              v35 = 1;
              convert_tableb = 0;
              v29 = v9;
              while ( 1 )
              {
                v41 = &p[(_DWORD)convert_tableb];
                LOBYTE(v19) = p[(_DWORD)convert_tableb];
                if ( (_BYTE)v19 == 9 )
                {
                  v22 = renderer->canvas_x;
                  a2->data = 32;
                  v23 = ~(_BYTE)v22 & 7;
                  if ( realloc_line(document, v18 + v23 + v22 - (_DWORD)convert_tableb, renderer->canvas_y) )
                  {
                    if ( v23 )
                    {
                      v20 = renderer->canvas_x;
                      v24 = v23;
                      do
                      {
                        --v24;
                        v25 = &renderer->document->data[renderer->canvas_y].chars[v20];
                        v25->data = a2->data;
                        *(_DWORD *)&v25->attr = *(_DWORD *)&a2->attr;
                        v20 = renderer->canvas_x + 1;
                        renderer->canvas_x = v20;
                      }
                      while ( v24 > 0 );
                      v35 = 1;
                    }
                    else
                    {
                      v20 = renderer->canvas_x;
                      v35 = 1;
                    }
                    goto LABEL_40;
                  }
                }
                else if ( v32 )
                {
                  v35 = utf8charlen(&p[(_DWORD)convert_tableb]);
                  v26 = utf8_to_unicode(&v41, end);
                  a2->data = v26;
                  if ( unicode_to_cell(v26) == 2 )
                  {
                    v27 = &renderer->document->data[renderer->canvas_y].chars[renderer->canvas_x];
                    v27->data = a2->data;
                    *(_DWORD *)&v27->attr = *(_DWORD *)&a2->attr;
                    ++renderer->canvas_x;
                    a2->data = -3;
                    v20 = renderer->canvas_x;
                    goto LABEL_40;
                  }
                }
                else
                {
                  if ( (_BYTE)v19 == 127 || (unsigned __int8)v19 <= 0x1Fu )
                    v19 = 46;
                  else
                    v19 = (unsigned __int8)v19;
                  a2->data = v19;
                }
                v20 = renderer->canvas_x;
LABEL_40:
                v21 = &renderer->document->data[renderer->canvas_y].chars[v20];
                v21->data = a2->data;
                *(_DWORD *)&v21->attr = *(_DWORD *)&a2->attr;
                convert_tableb = (conv_table *)((char *)convert_tableb + v35);
                v18 = v42[0];
                ++renderer->canvas_x;
                if ( (int)convert_tableb >= v18 )
                {
                  v9 = v29;
                  break;
                }
              }
            }
          }
          mem_free(p);
        }
      }
    }
  }
}
// 8088180: using guessed type int var_1C[7];

//----- (08088560) --------------------------------------------------------
void __usercall render_dom_flush(dom_renderer *renderer@<eax>, unsigned __int8 *string@<edx>)
{
  unsigned __int8 *position; // eax
  unsigned __int8 *v5; // edi

  position = renderer->position;
  v5 = (unsigned __int8 *)(string - position);
  if ( !assert_failed )
  {
    if ( position >= renderer->source && position <= renderer->end )
    {
      assert_failed = 0;
      if ( string >= renderer->source )
      {
LABEL_14:
        if ( string <= renderer->end )
        {
          assert_failed = 0;
          goto LABEL_6;
        }
      }
LABEL_5:
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 458;
      elinks_internal(
        "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
        renderer->source,
        renderer->end,
        string,
        string);
      goto LABEL_6;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
    errline = 457;
    elinks_internal(
      "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
      renderer->source,
      renderer->end,
      renderer->position,
      renderer->position);
    if ( !assert_failed )
    {
      if ( string >= renderer->source )
        goto LABEL_14;
      goto LABEL_5;
    }
  }
LABEL_6:
  if ( (int)v5 > 0 )
  {
    render_dom_text(renderer, &renderer->styles[3], renderer->position, (int)v5);
    renderer->position = string;
    if ( !assert_failed )
    {
      if ( string >= renderer->source && string <= renderer->end )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 464;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          renderer->source,
          renderer->end,
          renderer->position,
          renderer->position);
      }
    }
  }
}

//----- (08088700) --------------------------------------------------------
dom_code __cdecl render_dom_element_end_source(dom_stack *stack, dom_node *node, void *data)
{
  dom_renderer *v3; // ebx
  int v4; // edx
  size_t depth; // ecx
  dom_stack_context *v6; // esi
  size_t object_size; // edi
  int v8; // eax
  unsigned __int8 *v9; // ecx
  int v10; // esi
  unsigned __int8 *v12; // edi
  bool v13; // zf
  unsigned __int8 *v14; // [esp+28h] [ebp-20h]
  unsigned __int8 *v15; // [esp+28h] [ebp-20h]
  unsigned __int8 *v16; // [esp+28h] [ebp-20h]
  dom_stack_state *states; // [esp+2Ch] [ebp-1Ch]

  v3 = (dom_renderer *)stack->current->data;
  v4 = assert_failed;
  if ( !assert_failed )
    assert_failed = 0;
  states = stack->states;
  depth = stack->depth;
  v6 = *stack->contexts;
  object_size = v6->info->object_size;
  v8 = 0;
  if ( object_size )
  {
    if ( !v4 )
    {
      v13 = v6->state_objects != 0;
      assert_failed = v6->state_objects == 0;
      if ( !v13 )
      {
        v16 = (unsigned __int8 *)depth;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 198;
        elinks_internal("assertion context->state_objects failed!");
        v4 = assert_failed;
        depth = (size_t)v16;
      }
    }
    v8 = (int)&v6->state_objects[states[depth - 1].depth * object_size];
  }
  v9 = *(unsigned __int8 **)(v8 + 20);
  v10 = *(_DWORD *)(v8 + 16);
  if ( !v4 )
  {
    if ( node && v3 && v3->document )
    {
      assert_failed = 0;
    }
    else
    {
      v14 = *(unsigned __int8 **)(v8 + 20);
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 578;
      elinks_internal("assertion node && renderer && renderer->document failed!");
      v9 = v14;
    }
  }
  if ( v10 && v9 )
  {
    if ( v9 >= v3->source )
    {
      v12 = &v9[v10];
      if ( &v9[v10] <= v3->end )
      {
        v15 = v9;
        render_dom_flush(v3, v9);
        v3->position = v12;
        v9 = v15;
        if ( !assert_failed )
        {
          if ( v12 < v3->source || v12 > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 586;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
            v9 = v15;
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
    }
    render_dom_text(v3, &v3->styles[node->type], v9, v10);
  }
  return 0;
}

//----- (080888E0) --------------------------------------------------------
dom_string *__usercall get_rss_text@<eax>(dom_node *node@<eax>, rss_element_type type@<edx>)
{
  dom_node *dom_node_child; // eax
  dom_node *v3; // eax

  dom_node_child = get_dom_node_child(node, DOM_NODE_ELEMENT, type);
  if ( dom_node_child && (v3 = get_dom_node_child(dom_node_child, DOM_NODE_TEXT, 0)) != 0 )
    return &v3->string;
  else
    return 0;
}

//----- (08088930) --------------------------------------------------------
dom_code __cdecl dom_rss_pop_element(dom_stack *stack, dom_node *node, void *data)
{
  dom_string *v3; // ebx
  int v4; // eax
  dom_node *parent; // eax
  dom_node *string; // edi
  uint16_t type; // dx
  uint16_t v9; // cx
  dom_node_list **p_map; // edx
  dom_node_list **p_children; // eax

  v3 = (dom_string *)stack->current->data;
  if ( !assert_failed )
  {
    if ( node && v3 && v3->string )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 824;
      elinks_internal("assertion node && renderer && renderer->document failed!");
    }
  }
  if ( node->data.element.type <= 8u )
  {
    v4 = 1 << node->data.element.type;
    if ( (v4 & 0x1CA) != 0 )
    {
      if ( !v3[20].string )
        return 0;
      if ( !v3[20].length )
        return 0;
      parent = node->parent;
      if ( !parent )
        return 0;
      if ( parent != (dom_node *)v3[19].length )
        return 0;
      string = (dom_node *)v3[19].string;
      if ( string != node )
        return 0;
      type = parent->type;
      v9 = node->type;
      if ( parent->type == 7 )
      {
        p_map = &parent->data.proc_instruction.map;
        if ( v9 == 2 )
        {
LABEL_24:
          done_dom_node_list(*p_map);
          if ( v3[20].string && v3[20].length && !init_dom_node_at(string, DOM_NODE_TEXT, v3 + 20, -1) )
          {
            if ( v3[20].string )
              mem_free(v3[20].string);
            v3[20].string = 0;
            v3[20].length = 0;
          }
          v3[19].string = 0;
          return 0;
        }
      }
      else
      {
        if ( type <= 7u )
        {
          if ( type == 1 )
          {
            p_map = (dom_node_list **)&parent->data;
            p_children = &parent->data.document.children;
            if ( v9 == 2 )
              p_map = p_children;
            goto LABEL_24;
          }
          goto LABEL_23;
        }
        if ( type == 9 )
          goto LABEL_34;
        if ( type == 10 )
        {
          p_map = (dom_node_list **)&parent->data;
          if ( v9 == 6 )
            goto LABEL_24;
          if ( v9 == 12 )
          {
LABEL_34:
            p_map = &parent->data.document.children;
            goto LABEL_24;
          }
        }
      }
LABEL_23:
      p_map = 0;
      goto LABEL_24;
    }
    if ( (v4 & 0x20) != 0 )
    {
      if ( v3[20].string && v3[20].length )
      {
        mem_free(v3[20].string);
        v3[20].string = 0;
        v3[20].length = 0;
      }
      v3[19].length = 0;
    }
  }
  return 0;
}

//----- (08088B20) --------------------------------------------------------
dom_code __cdecl dom_rss_push_element(dom_stack *stack, dom_node *node, void *data)
{
  void *v3; // esi
  int v4; // eax
  dom_node *parent; // eax

  v3 = stack->current->data;
  if ( !assert_failed )
  {
    if ( node && v3 && *((_DWORD *)v3 + 1) )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 777;
      elinks_internal("assertion node && renderer && renderer->document failed!");
    }
  }
  if ( node->data.element.type <= 8u )
  {
    v4 = 1 << node->data.element.type;
    if ( (v4 & 0x1CA) != 0 )
    {
      parent = node->parent;
      if ( parent && parent == *((dom_node **)v3 + 39) )
        *((_DWORD *)v3 + 39) = node;
    }
    else if ( (v4 & 0x20) != 0 )
    {
      if ( !*((_DWORD *)v3 + 38) )
      {
        add_to_dom_node_list((dom_node_list **)v3 + 37, node, -1);
        *((_DWORD *)v3 + 38) = node;
      }
    }
    else if ( (v4 & 4) != 0 && stack->depth == 3 && !*((_DWORD *)v3 + 36) )
    {
      *((_DWORD *)v3 + 36) = node;
    }
  }
  return 0;
}

//----- (08088C40) --------------------------------------------------------
void __cdecl render_dom_document(cache_entry *cached, document *document, string *buffer)
{
  unsigned __int8 *head; // esi
  unsigned __int8 *string; // edi
  unsigned int v5; // eax
  conv_table *convert_table; // edx
  dom_node_type v7; // esi
  int length; // edx
  uri *v9; // eax
  dom_string *dom_node_type_name; // eax
  const unsigned __int8 *v11; // edx
  int v12; // eax
  int v13; // eax
  __int32 v14; // edx
  char v15; // al
  unsigned __int8 v16; // si
  int v17; // eax
  sgml_parser *inited; // eax
  sgml_parser *v19; // esi
  css_selector *css_selector; // eax
  list_head_elinks *next; // edx
  list_head_elinks *p_properties; // ecx
  bool v23; // zf
  dom_stack *p_stack; // ebx
  dom_string *v25; // [esp+30h] [ebp-E8h]
  color_T bg; // [esp+34h] [ebp-E4h]
  int i; // [esp+38h] [ebp-E0h]
  color_T fg; // [esp+3Ch] [ebp-DCh]
  dom_renderer renderer; // [esp+40h] [ebp-D8h] BYREF
  color_pair pair; // [esp+E8h] [ebp-30h] BYREF
  dom_string uri; // [esp+F0h] [ebp-28h] BYREF
  dom_config config; // [esp+F8h] [ebp-20h] BYREF

  head = cached->head;
  if ( !head )
    head = (unsigned __int8 *)&delete;
  string = cached->uri->string;
  v5 = strlen((const char *)string);
  uri.string = string;
  uri.length = v5;
  convert_table = get_convert_table(
                    head,
                    document->options.cp,
                    document->options.assume_cp,
                    &document->cp,
                    &document->cp_status,
                    document->options.hard_assume);
  memset(&renderer, 0, sizeof(renderer));
  renderer.document = document;
  renderer.convert_table = convert_table;
  v7 = DOM_NODE_UNKNOWN;
  renderer.convert_mode = (*((_BYTE *)&document->options + 69) & 0x40) != 0 ? CSM_NONE : CSM_DEFAULT;
  renderer.source = buffer->source;
  length = buffer->length;
  renderer.position = renderer.source;
  renderer.end = &renderer.source[length];
  v9 = document->uri;
  ++v9->object.refcount;
  renderer.base_uri = v9;
  for ( i = 0; i != 13; ++i )
  {
    bg = document->options.default_style.bg;
    fg = document->options.default_style.fg;
    dom_node_type_name = get_dom_node_type_name(v7);
    if ( !i_want_struct_module_for_dom_7054 )
    {
      v25 = dom_node_type_name;
      i_want_struct_module_for_dom_7054 = 1;
      css_parse_stylesheet(
        &default_stylesheet,
        0,
        "document\t{ color: yellow } element\t{ color: lightgreen } entity-reference { color: red } proc-instruction { co"
        "lor: red } attribute\t{ color: magenta } comment\t{ color: aqua } cdata-section\t{ color: orange2 } ",
        (unsigned __int8 *)&end);
      dom_node_type_name = v25;
    }
    if ( dom_node_type_name )
    {
      v11 = dom_node_type_name->string;
      if ( v11 )
      {
        v12 = dom_node_type_name->length;
        if ( v12 )
        {
          css_selector = find_css_selector(&default_stylesheet.selectors, CST_ELEMENT, CSR_ROOT, v11, v12);
          if ( css_selector )
          {
            next = (list_head_elinks *)css_selector->properties.next;
            p_properties = &css_selector->properties;
            if ( next != &css_selector->properties )
            {
              v13 = 0;
              while ( 2 )
              {
                switch ( (unsigned int)next[1].next )
                {
                  case 1u:
                  case 2u:
                    if ( next[1].prev != (void *)1 )
                      goto LABEL_28;
                    bg = (color_T)next[2].next;
                    next = (list_head_elinks *)next->next;
                    if ( next != p_properties )
                      continue;
                    goto LABEL_10;
                  case 3u:
                    fg = (color_T)next[2].next;
                    next = (list_head_elinks *)next->next;
                    if ( next != p_properties )
                      continue;
                    goto LABEL_10;
                  case 5u:
                    if ( ((int)next[2].next & 4) != 0 )
                      v13 |= 0x20u;
                    v23 = ((int)next[2].next & 2) == 0;
                    next = (list_head_elinks *)next->next;
                    if ( !v23 )
                      v13 |= 0x10u;
                    if ( next != p_properties )
                      continue;
                    goto LABEL_10;
                  case 6u:
                    if ( ((int)next[2].next & 1) != 0 )
                      v13 |= 8u;
                    goto LABEL_28;
                  case 8u:
                    v23 = ((int)next[2].next & 4) == 0;
                    next = (list_head_elinks *)next->next;
                    if ( !v23 )
                      v13 |= 0x20u;
                    if ( next != p_properties )
                      continue;
                    goto LABEL_10;
                  default:
LABEL_28:
                    next = (list_head_elinks *)next->next;
                    if ( next == p_properties )
                      goto LABEL_10;
                    continue;
                }
              }
            }
          }
        }
      }
    }
    LOBYTE(v13) = 0;
LABEL_10:
    pair.background = bg;
    v14 = v7 + 4;
    ++v7;
    pair.foreground = fg;
    *((_BYTE *)&renderer.convert_mode + 8 * v14) = v13;
    (&renderer.convert_table)[2 * v14] = (conv_table *)32;
    set_term_color(
      (screen_char *)&(&renderer.convert_table)[2 * v14],
      &pair,
      document->options.color_flags,
      document->options.color_mode);
  }
  document->bgcolor = document->options.default_style.bg;
  v15 = is_cp_utf8(document->options.cp);
  v16 = *((_BYTE *)&document->options + 69);
  *((_BYTE *)&document->options + 92) = (16 * (v15 & 1)) | *((_BYTE *)&document->options + 92) & 0xEF;
  if ( c_strcasecmp("application/rss+xml", (const char *)cached->content_type) )
  {
    v17 = c_strcasecmp("application/docbook+xml", (const char *)cached->content_type);
    if ( v17 )
    {
      if ( c_strcasecmp("application/xbel+xml", (const char *)cached->content_type)
        && c_strcasecmp("application/x-xbel", (const char *)cached->content_type)
        && c_strcasecmp("application/xbel", (const char *)cached->content_type) )
      {
        if ( !assert_failed )
        {
          if ( c_strcasecmp("text/html", (const char *)cached->content_type)
            && c_strcasecmp("application/xhtml+xml", (const char *)cached->content_type) )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 1018;
            elinks_internal(
              "assertion !c_strcasecmp(\"text/html\", cached->content_type) || !c_strcasecmp(\"application/xhtml+xml\", c"
              "ached->content_type) failed: Couldn't resolve doctype '%s'",
              (const char *)cached->content_type);
          }
          else
          {
            assert_failed = 0;
          }
        }
        renderer.doctype = SGML_DOCTYPE_HTML;
        v17 = 1;
      }
      else
      {
        renderer.doctype = SGML_DOCTYPE_XBEL;
        v17 = 3;
      }
    }
    else
    {
      renderer.doctype = SGML_DOCTYPE_DOCBOOK;
    }
  }
  else
  {
    renderer.doctype = SGML_DOCTYPE_RSS;
    v17 = 2;
  }
  inited = init_sgml_parser(
             (sgml_parser_type)(((v16 >> 6) ^ 1) & 1),
             (sgml_document_type)v17,
             &uri,
             (sgml_parser_flag)0);
  v19 = inited;
  if ( inited )
  {
    if ( (*((_BYTE *)&document->options + 69) & 0x40) != 0 )
    {
      add_dom_stack_context(&inited->stack, &renderer, &dom_source_renderer_context_info);
    }
    else if ( renderer.doctype == SGML_DOCTYPE_RSS )
    {
      p_stack = &inited->stack;
      add_dom_stack_context(&inited->stack, &renderer, &dom_rss_renderer_context_info);
      add_dom_config_normalizer(p_stack, &config, DOM_CONFIG_NORMALIZE_WHITESPACE|DOM_CONFIG_NORMALIZE_CHARACTERS);
    }
    parse_sgml(v19, buffer->source, buffer->length, 1);
    if ( v19->root )
    {
      if ( !assert_failed )
      {
        v23 = v19->stack.depth == 1;
        assert_failed = v19->stack.depth != 1;
        if ( v23
          || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c",
              errline = 1079,
              elinks_internal("assertion parser->stack.depth == 1 failed!"),
              !assert_failed) )
        {
          assert_failed = 0;
        }
      }
      *((_BYTE *)&v19->stack.states[v19->stack.depth - 1] + 8) &= ~1u;
      pop_dom_node(&v19->stack);
    }
    done_uri(renderer.base_uri);
    done_sgml_parser(v19);
  }
}
// 81493C0: using guessed type int i_want_struct_module_for_dom_7054;

//----- (080891D0) --------------------------------------------------------
void __usercall render_rss_item(dom_renderer *renderer@<eax>, dom_node *item@<edx>)
{
  dom_string *v3; // esi
  dom_string *v4; // edi
  unsigned __int8 *string; // edx
  unsigned __int8 *v6; // ecx
  unsigned __int8 *v7; // ecx
  int v8; // eax
  unsigned __int8 *v9; // ecx
  int nlinks; // edx
  unsigned int v11; // eax
  unsigned int v12; // edx
  link *links; // eax
  link *v14; // eax
  unsigned __int8 *v15; // eax
  color_T default_vlink; // eax
  point *points; // eax
  int v18; // ecx
  unsigned __int8 *v19; // eax
  link *v20; // eax
  point *v21; // eax
  unsigned __int8 *pb; // [esp+3Ch] [ebp-4Ch]
  unsigned int p; // [esp+3Ch] [ebp-4Ch]
  int pa; // [esp+3Ch] [ebp-4Ch]
  dom_string *rss_text; // [esp+40h] [ebp-48h]
  unsigned __int8 *v26; // [esp+40h] [ebp-48h]
  unsigned __int8 *v27; // [esp+40h] [ebp-48h]
  link *v28; // [esp+48h] [ebp-40h]
  int v29; // [esp+48h] [ebp-40h]
  int charslen; // [esp+4Ch] [ebp-3Ch]
  unsigned __int8 *charslena; // [esp+4Ch] [ebp-3Ch]
  int charslenb; // [esp+4Ch] [ebp-3Ch]
  int canvas_x; // [esp+50h] [ebp-38h]
  int length; // [esp+54h] [ebp-34h]
  dom_string *link; // [esp+58h] [ebp-30h]
  dom_string *linka; // [esp+58h] [ebp-30h]
  document *nodea; // [esp+5Ch] [ebp-2Ch]
  color_pair pair; // [esp+60h] [ebp-28h] BYREF
  screen_char schar; // [esp+68h] [ebp-20h] BYREF

  rss_text = get_rss_text(item, RSS_ELEMENT_TITLE);
  link = get_rss_text(item, RSS_ELEMENT_LINK);
  v3 = get_rss_text(item, RSS_ELEMENT_AUTHOR);
  v4 = get_rss_text(item, RSS_ELEMENT_PUBDATE);
  if ( rss_text )
  {
    string = rss_text->string;
    if ( string )
    {
      length = rss_text->length;
      if ( rss_text->length )
      {
        if ( renderer->channel == item )
        {
          v19 = convert_string_elinks(
                  renderer->convert_table,
                  string,
                  length,
                  renderer->document->options.cp,
                  CSM_DEFAULT,
                  0,
                  0,
                  0);
          if ( v19 )
            renderer->document->title = v19;
          render_dom_text(renderer, &renderer->styles[1], rss_text->string, rss_text->length);
        }
        else
        {
          render_dom_text(renderer, &renderer->styles[1], string, length);
        }
      }
    }
  }
  if ( link && link->string && link->length )
  {
    canvas_x = renderer->canvas_x;
    renderer->canvas_x = canvas_x + 1;
    charslen = link->length;
    v9 = link->string;
    linka = (dom_string *)renderer->canvas_y;
    nodea = renderer->document;
    nlinks = nodea->nlinks;
    v11 = (nlinks + 128) & 0xFFFFFF80;
    v12 = (nlinks + 127) & 0xFFFFFF80;
    if ( v11 > v12 )
    {
      v29 = 52 * v11;
      p = v12;
      v26 = v9;
      v20 = (link *)mem_realloc(nodea->links, 52 * v11);
      if ( !v20 )
        goto LABEL_7;
      nodea->links = v20;
      memset(&v20[p], 0, v29 - 52 * p);
      v9 = v26;
    }
    links = nodea->links;
    if ( links )
    {
      v14 = &links[nodea->nlinks];
      v28 = v14;
      if ( v14->npoints <= 5u )
      {
        pa = v14->npoints;
        v27 = v9;
        v21 = (point *)mem_realloc(v14->points, 0x30u);
        if ( !v21 )
          goto LABEL_7;
        v28->points = v21;
        memset(&v21[pa], 0, 48 - 8 * pa);
        v9 = v27;
      }
      if ( v28->points )
      {
        v15 = convert_string_elinks(renderer->convert_table, v9, charslen, nodea->options.cp, CSM_DEFAULT, 0, 0, 0);
        if ( v15 )
        {
          pb = v15;
          charslena = join_urls(renderer->base_uri, v15);
          mem_free(pb);
          if ( charslena )
          {
            if ( get_global_history_item(charslena) )
            {
              default_vlink = nodea->options.default_vlink;
            }
            else if ( get_bookmark(charslena) )
            {
              default_vlink = nodea->options.default_bookmark_link;
            }
            else
            {
              default_vlink = nodea->options.default_link;
            }
            v28->npoints = 6;
            v28->type = LINK_HYPERTEXT;
            v28->where = charslena;
            charslenb = nodea->options.default_style.bg;
            v28->color.background = charslenb;
            v28->color.foreground = default_vlink;
            v28->number = nodea->nlinks;
            pair.foreground = default_vlink;
            schar.attr = 0;
            schar.data = 32;
            pair.background = charslenb;
            set_term_color(&schar, &pair, nodea->options.color_flags, nodea->options.color_mode);
            render_dom_text(renderer, &schar, "[link]", 6);
            points = v28->points;
            v18 = canvas_x + 1;
            do
            {
              points->x = v18++;
              points->y = (int)linka;
              ++points;
            }
            while ( v18 != canvas_x + 7 );
            ++nodea->nlinks;
            *((_BYTE *)nodea + 276) &= ~1u;
          }
        }
      }
    }
  }
LABEL_7:
  ++renderer->canvas_y;
  renderer->canvas_x = 0;
  if ( v3 )
  {
    v6 = v3->string;
    if ( v6 )
    {
      if ( v3->length )
        render_dom_text(renderer, &renderer->styles[8], v6, v3->length);
    }
  }
  if ( v4 )
  {
    v7 = v4->string;
    if ( v7 )
    {
      v8 = v4->length;
      if ( v4->length )
      {
        if ( v3 && v3->string && v3->length )
        {
          render_dom_text(renderer, &renderer->styles[8], (unsigned __int8 *)" - ", 3);
          v8 = v4->length;
          v7 = v4->string;
        }
        render_dom_text(renderer, &renderer->styles[8], v7, v8);
      }
    }
  }
  if ( v3 && v3->string && v3->length || v4 && v4->string && v4->length )
  {
    ++renderer->canvas_y;
    renderer->canvas_x = 0;
  }
}

//----- (08089660) --------------------------------------------------------
dom_code __cdecl dom_rss_pop_document(dom_stack *stack, dom_node *root, void *data)
{
  dom_renderer *v3; // ebx
  dom_code result; // eax
  dom_node *channel; // edx
  dom_node_list *items; // ecx
  size_t v7; // esi
  dom_node *v8; // edx

  v3 = (dom_renderer *)stack->current->data;
  result = DOM_CODE_OK;
  channel = v3->channel;
  if ( channel )
  {
    render_rss_item((dom_renderer *)stack->current->data, channel);
    items = v3->items;
    if ( items && items->size )
    {
      v7 = 0;
      do
      {
        v8 = items->entries[v7];
        if ( v8 )
        {
          ++v3->canvas_y;
          v3->canvas_x = 0;
          render_rss_item(v3, v8);
          items = v3->items;
        }
        ++v7;
      }
      while ( v7 < items->size );
    }
    if ( v3->text.string && v3->text.length )
    {
      mem_free(v3->text.string);
      items = v3->items;
      v3->text.string = 0;
      v3->text.length = 0;
    }
    result = DOM_CODE_FREE_NODE;
    if ( items )
    {
      mem_free(items);
      return -998;
    }
  }
  return result;
}

//----- (08089730) --------------------------------------------------------
dom_code __cdecl render_dom_document_end(dom_stack *stack, dom_node *node, void *data)
{
  dom_renderer *v3; // ebx
  unsigned __int8 *position; // eax
  unsigned __int8 *end; // esi
  int v7; // edi

  v3 = (dom_renderer *)stack->current->data;
  position = v3->position;
  if ( v3->source <= position )
  {
    end = v3->end;
    if ( position <= end )
    {
      v7 = end - position;
      if ( !assert_failed )
      {
        assert_failed = 0;
        if ( end < v3->source || end > v3->end )
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 458;
          elinks_internal(
            "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            end,
            end);
        }
        else
        {
          assert_failed = 0;
        }
      }
      if ( v7 > 0 )
      {
        render_dom_text(v3, &v3->styles[3], v3->position, v7);
        v3->position = end;
        if ( !assert_failed )
        {
          if ( end < v3->source || end > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 464;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
    }
  }
  return 0;
}

//----- (08089870) --------------------------------------------------------
dom_code __cdecl render_dom_node_source(dom_stack *stack, dom_node *node, void *data)
{
  dom_renderer *v3; // ebx
  unsigned __int8 *string; // esi
  int length; // edi
  unsigned __int8 *source; // eax
  unsigned int end; // edx
  int v9; // ecx
  int v10; // [esp+20h] [ebp-28h]
  unsigned int position; // [esp+24h] [ebp-24h]
  unsigned __int8 *v12; // [esp+28h] [ebp-20h]
  uint16_t type; // [esp+2Eh] [ebp-1Ah]

  v3 = (dom_renderer *)stack->current->data;
  if ( !assert_failed )
  {
    if ( node && v3 && v3->document )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 540;
      elinks_internal("assertion node && renderer && renderer->document failed!");
    }
  }
  type = node->type;
  string = node->string.string;
  length = node->string.length;
  if ( node->type == 5 )
  {
    --string;
    length += 2;
  }
  source = v3->source;
  if ( source <= string )
  {
    v12 = &string[length];
    end = (unsigned int)v3->end;
    if ( (unsigned int)&string[length] <= end )
    {
      position = (unsigned int)v3->position;
      v9 = (int)&string[-position];
      if ( !assert_failed )
      {
        if ( (unsigned int)source <= position && end >= position )
        {
          assert_failed = 0;
          goto LABEL_16;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 457;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          v3->source,
          v3->end,
          v3->position,
          v3->position);
        v9 = (int)&string[-position];
        if ( !assert_failed )
        {
LABEL_16:
          if ( string >= v3->source && string <= v3->end )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 458;
            v10 = v9;
            elinks_internal(
              "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              string,
              string);
            v9 = v10;
          }
        }
      }
      if ( v9 > 0 )
      {
        render_dom_text(v3, &v3->styles[3], v3->position, v9);
        v3->position = string;
        if ( !assert_failed )
        {
          if ( string < v3->source || string > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 464;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
      v3->position = v12;
      if ( !assert_failed )
      {
        if ( v12 >= v3->source && v12 <= v3->end )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 482;
          elinks_internal(
            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            v3->position,
            v3->position);
        }
      }
    }
  }
  render_dom_text(v3, &v3->styles[type], string, length);
  return 0;
}

//----- (08089B40) --------------------------------------------------------
dom_code __cdecl render_dom_element_source(dom_stack *stack, dom_node *node, void *data)
{
  dom_renderer *v3; // ebx
  unsigned __int8 *string; // esi
  int length; // edi
  unsigned __int8 *source; // eax
  unsigned int end; // edx
  int v9; // ecx
  int v10; // [esp+20h] [ebp-28h]
  unsigned int position; // [esp+24h] [ebp-24h]
  unsigned __int8 *v12; // [esp+28h] [ebp-20h]
  uint16_t type; // [esp+2Eh] [ebp-1Ah]

  v3 = (dom_renderer *)stack->current->data;
  if ( !assert_failed )
  {
    if ( node && v3 && v3->document )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 561;
      elinks_internal("assertion node && renderer && renderer->document failed!");
    }
  }
  type = node->type;
  string = node->string.string;
  length = node->string.length;
  if ( node->type == 5 )
  {
    --string;
    length += 2;
  }
  source = v3->source;
  if ( source <= string )
  {
    v12 = &string[length];
    end = (unsigned int)v3->end;
    if ( (unsigned int)&string[length] <= end )
    {
      position = (unsigned int)v3->position;
      v9 = (int)&string[-position];
      if ( !assert_failed )
      {
        if ( (unsigned int)source <= position && end >= position )
        {
          assert_failed = 0;
          goto LABEL_16;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 457;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          v3->source,
          v3->end,
          v3->position,
          v3->position);
        v9 = (int)&string[-position];
        if ( !assert_failed )
        {
LABEL_16:
          if ( string >= v3->source && string <= v3->end )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 458;
            v10 = v9;
            elinks_internal(
              "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              string,
              string);
            v9 = v10;
          }
        }
      }
      if ( v9 > 0 )
      {
        render_dom_text(v3, &v3->styles[3], v3->position, v9);
        v3->position = string;
        if ( !assert_failed )
        {
          if ( string < v3->source || string > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 464;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
      v3->position = v12;
      if ( !assert_failed )
      {
        if ( v12 >= v3->source && v12 <= v3->end )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 482;
          elinks_internal(
            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            v3->position,
            v3->position);
        }
      }
    }
  }
  render_dom_text(v3, &v3->styles[type], string, length);
  return 0;
}

//----- (08089E10) --------------------------------------------------------
dom_code __cdecl render_dom_cdata_source(dom_stack *stack, dom_node *node, void *data)
{
  dom_renderer *v3; // ebx
  unsigned int source; // eax
  unsigned __int8 *v5; // esi
  unsigned __int8 *end; // edx
  unsigned __int8 *v7; // esi
  int length; // edi
  unsigned int v9; // edx
  int v11; // ecx
  int v12; // ecx
  unsigned __int8 *v13; // eax
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+20h] [ebp-28h]
  unsigned int v16; // [esp+24h] [ebp-24h]
  unsigned __int8 *v17; // [esp+28h] [ebp-20h]
  unsigned __int8 *position; // [esp+28h] [ebp-20h]
  unsigned __int8 *string; // [esp+2Ch] [ebp-1Ch]
  uint16_t stringa; // [esp+2Ch] [ebp-1Ch]

  v3 = (dom_renderer *)stack->current->data;
  string = node->string.string;
  if ( !assert_failed )
  {
    if ( v3 && v3->document )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 696;
      elinks_internal("assertion node && renderer && renderer->document failed!");
    }
  }
  source = (unsigned int)v3->source;
  v5 = string - 6;
  if ( source <= (unsigned int)(string - 6) )
  {
    end = v3->end;
    if ( string <= end )
    {
      position = v3->position;
      v12 = v5 - position;
      if ( !assert_failed )
      {
        if ( source <= (unsigned int)position && end >= position )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 457;
          elinks_internal(
            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            v3->position,
            v3->position);
          v12 = v5 - position;
          if ( assert_failed )
            goto LABEL_35;
        }
        if ( v5 >= v3->source && v5 <= v3->end )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 458;
          v15 = v12;
          elinks_internal(
            "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            v5,
            v5);
          v12 = v15;
        }
      }
LABEL_35:
      if ( v12 > 0 )
      {
        render_dom_text(v3, &v3->styles[3], v3->position, v12);
        v3->position = v5;
        if ( !assert_failed )
        {
          if ( v5 < v3->source || v5 > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 464;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
      render_dom_text(v3, &v3->styles[2], v5, 5);
      v13 = string - 1;
      v3->position = string - 1;
      if ( !assert_failed )
      {
        if ( v13 >= v3->source && v13 <= v3->end )
        {
          assert_failed = 0;
          source = (unsigned int)v3->source;
          goto LABEL_7;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 703;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          v3->source,
          v3->end,
          v3->position,
          v3->position);
      }
      source = (unsigned int)v3->source;
    }
  }
LABEL_7:
  stringa = node->type;
  v7 = node->string.string;
  length = node->string.length;
  if ( node->type == 5 )
  {
    --v7;
    length += 2;
  }
  if ( (unsigned int)v7 >= source )
  {
    v17 = &v7[length];
    v9 = (unsigned int)v3->end;
    if ( (unsigned int)&v7[length] <= v9 )
    {
      v16 = (unsigned int)v3->position;
      v11 = (int)&v7[-v16];
      if ( !assert_failed )
      {
        if ( v16 >= source && v9 >= v16 )
        {
          assert_failed = 0;
          goto LABEL_16;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 457;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          v3->source,
          v3->end,
          v3->position,
          v3->position);
        v11 = (int)&v7[-v16];
        if ( !assert_failed )
        {
LABEL_16:
          if ( v7 >= v3->source && v7 <= v3->end )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 458;
            v14 = v11;
            elinks_internal(
              "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v7,
              v7);
            v11 = v14;
          }
        }
      }
      if ( v11 > 0 )
      {
        render_dom_text(v3, &v3->styles[3], v3->position, v11);
        v3->position = v7;
        if ( !assert_failed )
        {
          if ( v7 < v3->source || v7 > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 464;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
      v3->position = v17;
      if ( !assert_failed )
      {
        if ( v17 >= v3->source && v17 <= v3->end )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 482;
          elinks_internal(
            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            v3->position,
            v3->position);
        }
      }
    }
  }
  render_dom_text(v3, &v3->styles[stringa], v7, length);
  return 0;
}

//----- (0808A2F0) --------------------------------------------------------
dom_code __cdecl render_dom_attribute_source(dom_stack *stack, dom_node *node, void *data)
{
  dom_renderer *v3; // ebx
  uint16_t type; // ax
  unsigned __int8 *v5; // esi
  unsigned __int8 *source; // eax
  unsigned int end; // edx
  dom_node_list *children; // edx
  dom_document *document; // eax
  _BOOL4 v10; // esi
  unsigned __int8 *v11; // edx
  bool v12; // al
  int v13; // esi
  const unsigned __int16 **v14; // eax
  unsigned __int8 v15; // dl
  int v16; // esi
  unsigned __int8 *v17; // ebx
  const unsigned __int16 **v18; // eax
  unsigned __int8 v19; // dl
  document *v20; // edi
  int nlinks; // edx
  unsigned int v22; // eax
  unsigned int v23; // edx
  link *links; // edx
  int v26; // ecx
  unsigned __int8 *v27; // eax
  unsigned __int8 *v28; // eax
  unsigned __int8 *v29; // edi
  uri *uri; // edi
  dom_renderer *v31; // eax
  unsigned __int8 *v32; // eax
  color_T default_vlink; // eax
  unsigned __int8 *v34; // eax
  int v35; // edx
  int v36; // ecx
  link *v37; // eax
  unsigned __int8 *v38; // eax
  unsigned __int8 *string; // [esp+3Ch] [ebp-4Ch]
  unsigned __int8 *stringc; // [esp+3Ch] [ebp-4Ch]
  unsigned int stringa; // [esp+3Ch] [ebp-4Ch]
  unsigned __int8 *stringb; // [esp+3Ch] [ebp-4Ch]
  int v43; // [esp+40h] [ebp-48h]
  int v44; // [esp+40h] [ebp-48h]
  unsigned __int8 *url; // [esp+44h] [ebp-44h]
  unsigned __int8 *urla; // [esp+44h] [ebp-44h]
  dom_renderer *v47; // [esp+48h] [ebp-40h]
  dom_renderer *v48; // [esp+48h] [ebp-40h]
  bool v49; // [esp+4Ch] [ebp-3Ch]
  int canvas_y; // [esp+4Ch] [ebp-3Ch]
  screen_char *templatea; // [esp+50h] [ebp-38h]
  unsigned __int8 *value; // [esp+54h] [ebp-34h]
  unsigned __int8 *valuea; // [esp+54h] [ebp-34h]
  unsigned int v54; // [esp+58h] [ebp-30h]
  int v55; // [esp+58h] [ebp-30h]
  int canvas_x; // [esp+58h] [ebp-30h]
  unsigned int length; // [esp+5Ch] [ebp-2Ch]
  int lengtha; // [esp+5Ch] [ebp-2Ch]
  color_pair pair; // [esp+60h] [ebp-28h] BYREF
  screen_char schar; // [esp+68h] [ebp-20h] BYREF

  v3 = (dom_renderer *)stack->current->data;
  type = node->type;
  templatea = &v3->styles[node->type];
  if ( !assert_failed )
  {
    if ( v3->document )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
      errline = 621;
      elinks_internal("assertion node && renderer->document failed!");
    }
    type = node->type;
  }
  v5 = node->string.string;
  length = node->string.length;
  if ( type == 5 )
  {
    --v5;
    length = node->string.length + 2;
  }
  source = v3->source;
  if ( source <= v5 )
  {
    v54 = (unsigned int)&v5[length];
    end = (unsigned int)v3->end;
    if ( (unsigned int)&v5[length] <= end )
    {
      valuea = v3->position;
      v26 = v5 - valuea;
      if ( !assert_failed )
      {
        if ( source <= valuea && end >= (unsigned int)valuea )
        {
          assert_failed = 0;
          goto LABEL_39;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 457;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          v3->source,
          v3->end,
          v3->position,
          v3->position);
        v26 = v5 - valuea;
        if ( !assert_failed )
        {
LABEL_39:
          if ( v5 >= v3->source && v5 <= v3->end )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 458;
            v43 = v26;
            elinks_internal(
              "assertion check_dom_node_source(renderer, string, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v5,
              v5);
            v26 = v43;
          }
        }
      }
      if ( v26 > 0 )
      {
        render_dom_text(v3, &v3->styles[3], v3->position, v26);
        v3->position = v5;
        if ( !assert_failed )
        {
          if ( v5 < v3->source || v5 > v3->end )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
            errline = 464;
            elinks_internal(
              "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
              v3->source,
              v3->end,
              v3->position,
              v3->position);
          }
          else
          {
            assert_failed = 0;
          }
        }
      }
      v3->position = (unsigned __int8 *)v54;
      if ( !assert_failed )
      {
        if ( (unsigned __int8 *)v54 >= v3->source && (unsigned __int8 *)v54 <= v3->end )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
          errline = 482;
          elinks_internal(
            "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
            v3->source,
            v3->end,
            v3->position,
            v3->position);
        }
      }
    }
  }
  render_dom_text(v3, templatea, v5, length);
  children = node->data.document.children;
  if ( !children )
    return 0;
  document = node->data.document.document;
  if ( !document )
    return 0;
  v10 = node->data.attribute.quoted == 1;
  v11 = (unsigned __int8 *)children - v10;
  value = v11;
  v55 = (int)document + 2 * v10;
  lengtha = v55;
  if ( v11 >= v3->source && v11 <= v3->end )
  {
    render_dom_flush(v3, v11);
    v27 = &value[v55];
    v3->position = &value[v55];
    if ( !assert_failed )
    {
      if ( v27 < v3->source || v27 > v3->end )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/dom/renderer.c";
        errline = 633;
        elinks_internal(
          "assertion check_dom_node_source(renderer, renderer->position, 0) failed: renderer[%p : %p] str[%p : %p]",
          v3->source,
          v3->end,
          v3->position,
          v3->position);
      }
      else
      {
        assert_failed = 0;
      }
    }
  }
  if ( (BYTE1(node->data.proc_instruction.map) & 8) != 0 && v55 - 2 * v10 > 0 )
  {
    if ( v55 <= 0 )
      goto LABEL_82;
    v12 = v10;
    v13 = 0;
    v49 = v12;
    do
    {
      if ( v13 || !v49 )
      {
        v14 = __ctype_b_loc();
        v15 = value[v13];
        if ( ((*v14)[v15] & 0x2000) == 0 && v15 > 0x1Fu )
          break;
      }
      ++v13;
    }
    while ( v55 > v13 );
    if ( v13 > 0 && (render_dom_text(v3, templatea, value, v13), value += v13, lengtha = v55 - v13, v55 - v13 <= 0) )
    {
LABEL_82:
      v16 = 0;
    }
    else
    {
      v16 = 0;
      v47 = v3;
      v17 = &value[lengtha];
      do
      {
        if ( v16 || !v49 )
        {
          v18 = __ctype_b_loc();
          v19 = *(v17 - 1);
          if ( ((*v18)[v19] & 0x2000) == 0 && v19 > 0x1Fu )
          {
            v3 = v47;
            lengtha -= v16;
            goto LABEL_29;
          }
        }
        ++v16;
        --v17;
      }
      while ( v16 < lengtha );
      v3 = v47;
      lengtha -= v16;
    }
LABEL_29:
    if ( v3->doctype == SGML_DOCTYPE_HTML && node->data.element.type == 47 && node->parent->data.element.type == 8 )
    {
      v28 = memacpy(value, lengtha);
      v29 = v28;
      if ( v28 )
      {
        string = join_urls(v3->base_uri, v28);
        mem_free(v29);
        if ( string )
        {
          uri = get_uri(string, (uri_component)0);
          mem_free(string);
          if ( uri )
          {
            done_uri(v3->base_uri);
            v3->base_uri = uri;
          }
        }
      }
    }
    v20 = v3->document;
    canvas_x = v3->canvas_x;
    canvas_y = v3->canvas_y;
    nlinks = v20->nlinks;
    v22 = (nlinks + 128) & 0xFFFFFF80;
    v23 = (nlinks + 127) & 0xFFFFFF80;
    if ( v22 > v23 )
    {
      stringa = v23;
      v44 = 52 * v22;
      v37 = (link *)mem_realloc(v20->links, 52 * v22);
      if ( !v37 )
        goto LABEL_32;
      v20->links = v37;
      memset(&v37[stringa], 0, v44 - 52 * stringa);
    }
    links = v20->links;
    if ( !links )
      goto LABEL_32;
    v31 = (dom_renderer *)&links[v20->nlinks];
    v48 = v31;
    if ( (unsigned __int8 *)lengtha <= v31->position )
    {
LABEL_67:
      if ( v48->end )
      {
        v32 = convert_string_elinks(v3->convert_table, value, lengtha, v20->options.cp, CSM_DEFAULT, 0, 0, 0);
        if ( v32 )
        {
          stringc = v32;
          url = join_urls(v3->base_uri, v32);
          mem_free(stringc);
          if ( url )
          {
            if ( get_global_history_item(url) )
            {
              default_vlink = v20->options.default_vlink;
            }
            else if ( get_bookmark(url) )
            {
              default_vlink = v20->options.default_bookmark_link;
            }
            else
            {
              default_vlink = v20->options.default_link;
            }
            v48->position = (unsigned __int8 *)lengtha;
            v48->document = 0;
            v48->convert_table = (conv_table *)url;
            urla = (unsigned __int8 *)v20->options.default_style.bg;
            v48->canvas_y = (int)urla;
            v48->styles[0].data = default_vlink;
            v48->canvas_x = v20->nlinks;
            pair.foreground = default_vlink;
            schar.attr = 0;
            schar.data = 32;
            pair.background = (color_T)urla;
            set_term_color(&schar, &pair, v20->options.color_flags, v20->options.color_mode);
            render_dom_text(v3, &schar, value, lengtha);
            v34 = v48->end;
            if ( lengtha > 0 )
            {
              v35 = lengtha;
              v36 = canvas_x;
              do
              {
                *(_DWORD *)v34 = v36++;
                *((_DWORD *)v34 + 1) = canvas_y;
                v34 += 8;
                --v35;
              }
              while ( v35 );
            }
            ++v20->nlinks;
            *((_BYTE *)v20 + 276) &= ~1u;
          }
        }
      }
      goto LABEL_32;
    }
    stringb = v31->position;
    v38 = (unsigned __int8 *)mem_realloc(v31->end, 8 * lengtha);
    if ( v38 )
    {
      v48->end = v38;
      memset(&v38[8 * (_DWORD)stringb], 0, 8 * lengtha - 8 * (_DWORD)stringb);
      goto LABEL_67;
    }
LABEL_32:
    if ( v16 > 0 )
      render_dom_text(v3, templatea, &value[lengtha], v16);
    return 0;
  }
  render_dom_text(v3, templatea, value, v55);
  return 0;
}

//----- (0808AAF0) --------------------------------------------------------
int __usercall distribute_rows_or_cols@<eax>(int *val_@<eax>, int max_value@<edx>, int *values@<ecx>, int values_count)
{
  int v4; // esi
  int v5; // ebx
  int v6; // eax
  int v7; // ebx
  int v8; // edi
  int v9; // edx
  int v10; // edi
  int v11; // esi
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int *v16; // [esp+1Ch] [ebp-2Ch]
  int v18; // [esp+24h] [ebp-24h]
  int v19; // [esp+2Ch] [ebp-1Ch]

  v4 = values_count;
  v5 = *val_;
  v6 = 0;
  v19 = 0;
  v7 = v5 - max_value;
  if ( values_count > 0 )
  {
    v8 = 0;
    do
    {
      while ( 1 )
      {
        v9 = values[v6];
        if ( v9 <= 0 )
          break;
        ++v6;
        v8 += v9;
        if ( v6 == values_count )
          goto LABEL_6;
      }
      values[v6++] = 1;
      ++v8;
    }
    while ( v6 != values_count );
LABEL_6:
    v19 = v8;
  }
  if ( !assert_failed )
  {
    assert_failed = v19 == 0;
    if ( !v19 )
    {
      v16 = values;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
      errline = 314;
      elinks_internal("assertion divisor failed!");
      values = v16;
    }
  }
  if ( values_count > 0 )
  {
    v10 = 0;
    v18 = v19 - v7;
    do
    {
      v11 = values[v10];
      values[v10] = v11 * v18 / v19;
      v7 += v11 * v18 / v19 - v11;
      ++v10;
    }
    while ( v10 != values_count );
    v4 = values_count;
  }
  if ( !v7 || v4 <= 0 )
    goto LABEL_26;
  do
  {
    v12 = 0;
    v13 = 0;
    while ( v7 >= 0 )
    {
      v14 = values[v13];
      if ( v14 > 1 )
      {
        --v7;
        values[v13] = v14 - 1;
        if ( !v7 )
          goto LABEL_23;
        goto LABEL_19;
      }
LABEL_20:
      if ( v4 <= ++v13 )
        goto LABEL_24;
    }
    ++v7;
    ++values[v13];
    if ( v7 )
    {
LABEL_19:
      v12 = 1;
      goto LABEL_20;
    }
LABEL_23:
    v12 = 1;
    v7 = 0;
LABEL_24:
    ;
  }
  while ( v12 && v7 );
LABEL_26:
  *val_ = v7;
  return 1;
}
// 808ABB0: conditional instruction was optimized away because ebx.4>=1

//----- (0808AC30) --------------------------------------------------------
void __cdecl parse_frame_widths(
        unsigned __int8 *str,
        int max_value,
        int pixels_per_char,
        int **new_values,
        int *new_values_count)
{
  int v5; // esi
  void *v6; // ebx
  const unsigned __int16 **v7; // eax
  signed int v9; // eax
  char *v10; // edi
  int v11; // ecx
  void *v12; // eax
  char *v13; // eax
  int v14; // edx
  int m; // edi
  int v16; // edx
  int v17; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  _DWORD *v21; // eax
  _DWORD *v22; // edi
  int i; // eax
  int v24; // ecx
  int j; // eax
  int v26; // edx
  int v27; // ecx
  int v28; // eax
  int v29; // eax
  int v30; // edx
  int k; // eax
  int v32; // ecx
  int v33; // eax
  int v34; // edx
  size_t n; // [esp+14h] [ebp-44h]
  char *nptra; // [esp+18h] [ebp-40h]
  char *nptr; // [esp+18h] [ebp-40h]
  int v38; // [esp+28h] [ebp-30h]
  const unsigned __int16 **maxpos; // [esp+2Ch] [ebp-2Ch]
  int maxposa; // [esp+2Ch] [ebp-2Ch]
  int maxposb; // [esp+2Ch] [ebp-2Ch]
  int maxposc; // [esp+2Ch] [ebp-2Ch]
  char *endptr; // [esp+38h] [ebp-20h] BYREF
  int val[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v5 = 0;
  v6 = 0;
  *new_values_count = 0;
  v7 = __ctype_b_loc();
  maxpos = v7;
  while ( 1 )
  {
    endptr = (char *)str;
    while ( ((*maxpos)[*str] & 0x2000) != 0 )
      ++str;
    nptra = (char *)str;
    v9 = strtoul((const char *)str, &endptr, 10);
    v10 = endptr;
    if ( nptra == endptr )
    {
      v9 = 0;
    }
    else if ( (unsigned int)v9 > 0xFFFF )
    {
      goto LABEL_7;
    }
    if ( *endptr == 37 )
    {
      v14 = 100;
      if ( v9 < 100 )
        v14 = v9;
      v11 = max_value * v14 / 100;
    }
    else if ( *endptr == 42 )
    {
      if ( !v9 )
      {
LABEL_7:
        v11 = -1;
        goto LABEL_8;
      }
      v11 = -v9;
    }
    else
    {
      v11 = ((pixels_per_char - 1) / 2 + v9) / (unsigned int)pixels_per_char;
    }
LABEL_8:
    ++v5;
    n = v11;
    v12 = mem_realloc(v6, 4 * v5);
    v6 = v12;
    if ( !v12 )
      return;
    *((_DWORD *)v12 + v5 - 1) = n;
    v13 = strchr(v10, 44);
    if ( !v13 )
      break;
    str = (unsigned __int8 *)(v13 + 1);
  }
  v16 = 2 * v5 - 1;
  val[0] = v16;
  if ( v5 > 0 )
  {
    v17 = 0;
    while ( 1 )
    {
      v18 = *((_DWORD *)v6 + v17);
      if ( v18 > 0 )
        val[0] = v16 + v18 - 1;
      if ( ++v17 == v5 )
        break;
      v16 = val[0];
    }
    v16 = val[0];
  }
  if ( max_value <= v16 )
    goto LABEL_80;
  v19 = 0;
  v20 = 0;
  if ( v5 <= 0 )
    goto LABEL_80;
  do
  {
    if ( *((int *)v6 + v20) < 0 )
      v19 = 1;
    ++v20;
  }
  while ( v20 != v5 );
  if ( v19 )
  {
    nptr = (char *)v16;
    v21 = mem_alloc(4 * v5);
    v22 = v21;
    if ( v21 )
    {
      memcpy(v21, v6, 4 * v5);
      for ( i = 0; i != v5; ++i )
      {
        while ( *((int *)v6 + i) > 0 )
        {
          if ( ++i == v5 )
            goto LABEL_43;
        }
        *((_DWORD *)v6 + i) = 1;
      }
LABEL_43:
      v24 = 0;
      for ( j = 0; j != v5; ++j )
      {
        while ( 1 )
        {
          v26 = v22[j];
          if ( v26 < 0 )
            break;
          if ( ++j == v5 )
            goto LABEL_47;
        }
        v24 -= v26;
      }
LABEL_47:
      v38 = v24;
      if ( !assert_failed )
      {
        assert_failed = v24 == 0;
        if ( !v24 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
          errline = 364;
          elinks_internal("assertion divisor failed!");
        }
      }
      v27 = 0;
      maxposa = max_value - (_DWORD)nptr;
      do
      {
        while ( 1 )
        {
          v28 = v22[v27];
          if ( v28 < 0 )
            break;
          if ( ++v27 == v5 )
            goto LABEL_54;
        }
        v29 = -v28 * (max_value - (int)nptr) / v38;
        *((_DWORD *)v6 + v27++) += v29;
        maxposa -= v29;
      }
      while ( v27 != v5 );
LABEL_54:
      if ( assert_failed
        || (assert_failed = (unsigned int)maxposa >> 31, maxposa < 0)
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c",
            errline = 374,
            elinks_internal("assertion val >= 0 failed: distribute_rows_or_cols_that_left: val < 0"),
            assert_failed) )
      {
        assert_failed = 0;
        maxposa = 0;
      }
      v30 = maxposa;
      for ( k = 0; k != v5; ++k )
      {
        if ( v30 && (int)v22[k] < 0 )
        {
          ++*((_DWORD *)v6 + k);
          --v30;
        }
      }
      maxposb = v30;
      if ( assert_failed
        || (assert_failed = v30 > 0) != 0
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c",
            errline = 381,
            elinks_internal("assertion val <= 0 failed: distribute_rows_or_cols_that_left: val > 0"),
            assert_failed) )
      {
        assert_failed = 0;
        maxposb = 0;
      }
      mem_free(v22);
      val[0] = maxposb;
LABEL_65:
      if ( v5 > 0 )
      {
        for ( m = 0; m != v5; ++m )
        {
          if ( !*((_DWORD *)v6 + m) )
          {
            maxposc = 0;
            v32 = 0;
            v33 = 0;
            while ( 1 )
            {
              v34 = *((_DWORD *)v6 + v33);
              if ( v34 <= v32 )
                v34 = v32;
              else
                maxposc = v33;
              if ( ++v33 == v5 )
                break;
              v32 = v34;
            }
            if ( v34 )
            {
              *((_DWORD *)v6 + m) = 1;
              --*((_DWORD *)v6 + maxposc);
            }
          }
        }
      }
      *new_values = (int *)v6;
      *new_values_count = v5;
    }
  }
  else
  {
LABEL_80:
    if ( distribute_rows_or_cols(val, max_value, (int *)v6, v5) )
      goto LABEL_65;
  }
}
// 808AC30: using guessed type int val[7];

//----- (0808B050) --------------------------------------------------------
void __cdecl format_frames(session *ses, frameset_desc *fsd, document_options *op, int depth)
{
  int *p_width; // esi
  int width; // eax
  int x; // ebx
  frameset_desc *v7; // edx
  frame_desc *v8; // esi
  cache_entry *v9; // edi
  int plain; // ecx
  bool v11; // al
  int redirect_cnt; // edx
  uri *redirect; // edx
  frame *frame; // eax
  frame *v15; // ebx
  bool v16; // di
  char *v17; // ecx
  document_view *prev; // ebx
  document_view *v19; // edx
  document_view *v20; // edx
  document *document; // ebx
  document *v22; // ebx
  document_view *v23; // eax
  unsigned __int8 *v24; // eax
  int v25; // eax
  list_head_elinks *next; // ecx
  void *v27; // eax
  int v28; // ebx
  void *v29; // eax
  bool pb; // [esp+2Ch] [ebp-DCh]
  document_view *p; // [esp+2Ch] [ebp-DCh]
  document_view *pa; // [esp+2Ch] [ebp-DCh]
  int v33; // [esp+34h] [ebp-D4h]
  int y; // [esp+3Ch] [ebp-CCh]
  int v35; // [esp+3Ch] [ebp-CCh]
  int j; // [esp+40h] [ebp-C8h]
  list_head_elinks *p_scrn_frames; // [esp+44h] [ebp-C4h]
  char *s2; // [esp+48h] [ebp-C0h]
  char *s2a; // [esp+48h] [ebp-C0h]
  int v40; // [esp+4Ch] [ebp-BCh]
  view_state *vs; // [esp+54h] [ebp-B4h]
  int i; // [esp+58h] [ebp-B0h]
  int n; // [esp+5Ch] [ebp-ACh]
  document_options o; // [esp+68h] [ebp-A0h] BYREF

  if ( assert_failed )
    goto LABEL_4;
  if ( fsd && ses && op )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
  errline = 220;
  elinks_internal("assertion ses && fsd && op failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return;
  }
LABEL_9:
  if ( depth <= 5 )
  {
    qmemcpy(&o, op, sizeof(o));
    o.margin = o.margin != 0;
    if ( fsd->box.height > 0 )
    {
      n = 0;
      p_scrn_frames = &ses->scrn_frames;
      j = 0;
      v40 = depth + 1;
      while ( 1 )
      {
        o.box.x = op->box.x;
        if ( fsd->box.width > 0 )
          break;
LABEL_33:
        ++j;
        o.box.y += o.box.height + 1;
        if ( fsd->box.height <= j )
          return;
      }
      i = 0;
      p_width = &fsd->frame_desc[n].width;
      while ( 1 )
      {
        width = *p_width;
        o.box.width = *p_width;
        o.box.height = p_width[1];
        o.framename = (unsigned __int8 *)*(p_width - 2);
        v7 = (frameset_desc *)*(p_width - 3);
        if ( !v7 )
          break;
        format_frames(ses, v7, &o, v40);
        width = o.box.width;
        x = o.box.x;
LABEL_15:
        p_width += 5;
        ++i;
        ++n;
        o.box.x = width + x + 1;
        if ( fsd->box.width <= i )
          goto LABEL_33;
      }
      if ( !*(p_width - 2) )
      {
LABEL_31:
        x = o.box.x;
        goto LABEL_15;
      }
      if ( assert_failed )
        goto LABEL_32;
      if ( ses )
      {
        s2 = (char *)p_width;
        v8 = &fsd->frame_desc[n];
        assert_failed = 0;
        goto LABEL_28;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
      errline = 174;
      elinks_internal("assertion ses && frame_desc && o failed!");
      if ( assert_failed )
      {
LABEL_32:
        assert_failed = 0;
LABEL_30:
        width = o.box.width;
        goto LABEL_31;
      }
      s2 = (char *)p_width;
      v8 = &fsd->frame_desc[n];
      while ( 1 )
      {
LABEL_28:
        frame = ses_find_frame(ses, v8->name);
        v15 = frame;
        if ( !frame || (vs = &frame->vs, (v9 = find_in_cache(frame->vs.uri)) == 0) )
        {
          p_width = (int *)s2;
          goto LABEL_30;
        }
        plain = v15->vs.plain;
        v11 = (*((_BYTE *)&o + 69) & 0x40) != 0;
        if ( plain != -1 )
          *((_BYTE *)&o + 69) = ((plain & 1) << 6) | *((_BYTE *)&o + 69) & 0xBF;
        if ( !v9->redirect )
          break;
        redirect_cnt = v15->redirect_cnt;
        if ( redirect_cnt > 9 )
          break;
        v15->redirect_cnt = redirect_cnt + 1;
        pb = v11;
        done_uri(v15->vs.uri);
        redirect = v9->redirect;
        ++redirect->object.refcount;
        v15->vs.uri = redirect;
        *((_BYTE *)&o + 69) = (pb << 6) | *((_BYTE *)&o + 69) & 0xBF;
      }
      v16 = v11;
      p_width = (int *)s2;
      x = o.box.x;
      y = o.box.y;
      v17 = (char *)*((_DWORD *)s2 - 2);
      s2a = v17;
      if ( assert_failed )
        goto LABEL_36;
      assert_failed = ses == 0 || v17 == 0;
      if ( ses == 0 || v17 == 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
        errline = 135;
        elinks_internal("assertion ses && name failed!");
        if ( assert_failed )
        {
          x = o.box.x;
LABEL_36:
          assert_failed = 0;
LABEL_37:
          *((_BYTE *)&o + 69) = (v16 << 6) | *((_BYTE *)&o + 69) & 0xBF;
LABEL_38:
          width = o.box.width;
          goto LABEL_15;
        }
      }
      if ( p_scrn_frames != ses->scrn_frames.prev )
      {
        v33 = x;
        prev = (document_view *)ses->scrn_frames.prev;
        do
        {
          if ( !prev->used && !c_strcasecmp((const char *)prev->name, s2a) )
          {
            prev->used = 1;
            v19 = prev;
            prev->depth = depth;
            goto LABEL_47;
          }
          prev = prev->prev;
        }
        while ( p_scrn_frames != (list_head_elinks *)prev );
        x = v33;
      }
      v23 = (document_view *)mem_calloc(1u, 0x3Cu);
      if ( !v23 )
        goto LABEL_77;
      v23->used = 1;
      pa = v23;
      v24 = stracpy((const unsigned __int8 *)s2a);
      v19 = pa;
      pa->name = v24;
      if ( !v24 )
      {
        mem_free(pa);
LABEL_77:
        x = o.box.x;
        goto LABEL_37;
      }
      pa->depth = depth;
      pa->session = ses;
      v25 = 0;
      if ( x < 0 )
        x = 0;
      pa->box.x = x;
      pa->search_word = &ses->search_word;
      if ( y >= 0 )
        v25 = y;
      pa->box.width = 0;
      pa->box.height = 0;
      pa->box.y = v25;
      if ( !assert_failed )
      {
        assert_failed = 0;
        next = (list_head_elinks *)ses->scrn_frames.next;
        if ( p_scrn_frames != next )
        {
          v27 = next[4].next;
          v35 = pa->box.x;
          v28 = pa->box.y;
          if ( v28 < (int)v27 || v27 == (void *)v28 && (int)next[3].prev > v35 )
          {
LABEL_74:
            pa->next = *(document_view **)next->prev;
            pa->prev = (document_view *)next->prev;
            *(_DWORD *)next->prev = pa;
            pa->next->prev = pa;
            goto LABEL_47;
          }
          while ( 1 )
          {
            next = (list_head_elinks *)next->next;
            if ( p_scrn_frames == next )
              break;
            v29 = next[4].next;
            if ( v28 < (int)v29 || (int)next[3].prev > v35 && (void *)v28 == v29 )
              goto LABEL_74;
          }
        }
        pa->next = *(document_view **)ses->scrn_frames.prev;
        pa->prev = (document_view *)ses->scrn_frames.prev;
        *(_DWORD *)ses->scrn_frames.prev = pa;
        pa->next->prev = pa;
        goto LABEL_47;
      }
      assert_failed = 0;
LABEL_47:
      p = v19;
      render_document(vs, v19, &o);
      v20 = p;
      if ( !assert_failed )
      {
        document = p->document;
        assert_failed = document == 0;
        if ( !document )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
          errline = 205;
          elinks_internal("assertion doc_view->document failed!");
          v20 = p;
        }
      }
      v20->document->frame = &fsd->frame_desc[n];
      *((_BYTE *)&o + 69) = (v16 << 6) | *((_BYTE *)&o + 69) & 0xBF;
      if ( !v20 )
      {
        x = o.box.x;
        goto LABEL_38;
      }
      v22 = v20->document;
      if ( !v22 )
      {
        width = o.box.width;
        x = o.box.x;
        goto LABEL_15;
      }
      if ( v22->frame_desc )
      {
        ++v22->object.refcount;
        format_frames(ses, v22->frame_desc, &o, v40);
        --v22->object.refcount;
      }
      goto LABEL_30;
    }
  }
}

//----- (0808B740) --------------------------------------------------------
void __cdecl add_frameset_entry(
        frameset_desc *frameset_desc,
        frameset_desc *subframe,
        unsigned __int8 *name,
        unsigned __int8 *url)
{
  unsigned __int8 *v4; // edx
  int y; // esi
  int v6; // esi
  unsigned __int8 *v7; // eax
  int v8; // eax
  bool v9; // cc
  uri *uri; // eax

  v4 = name;
  if ( assert_failed
    || (assert_failed = frameset_desc == 0, !frameset_desc)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c",
        errline = 36,
        elinks_internal("assertion frameset_desc failed!"),
        v4 = name,
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  y = frameset_desc->box.y;
  if ( y < frameset_desc->box.height )
  {
    v6 = frameset_desc->box.x + frameset_desc->box.width * y;
    frameset_desc->frame_desc[v6].subframe = subframe;
    v7 = 0;
    if ( v4 )
      v7 = stracpy(v4);
    frameset_desc->frame_desc[v6].name = v7;
    if ( url && *url )
    {
      uri = get_uri(url, (uri_component)0);
      frameset_desc->frame_desc[v6].uri = uri;
      if ( uri )
      {
LABEL_10:
        v8 = frameset_desc->box.x + 1;
        v9 = v8 < frameset_desc->box.width;
        frameset_desc->box.x = v8;
        if ( !v9 )
        {
          ++frameset_desc->box.y;
          frameset_desc->box.x = 0;
        }
        return;
      }
    }
    else
    {
      frameset_desc->frame_desc[v6].uri = 0;
    }
    frameset_desc->frame_desc[v6].uri = get_uri("about:blank", (uri_component)0);
    goto LABEL_10;
  }
}

//----- (0808B880) --------------------------------------------------------
frameset_desc *__cdecl create_frameset(frameset_param *fp)
{
  int y; // eax
  frameset_desc *v3; // eax
  int x; // edi
  frameset_desc *v5; // esi
  signed int v6; // ecx
  __int64 v7; // rax
  frameset_desc *fd; // [esp+18h] [ebp-20h]
  unsigned int v9; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = fp == 0, !fp)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c",
        errline = 70,
        elinks_internal("assertion fp failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  if ( fp->x > 0 && fp->y > 0 )
  {
    assert_failed = 0;
LABEL_6:
    y = fp->y;
    goto LABEL_15;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/frames.c";
  errline = 74;
  elinks_internal("assertion fp->x > 0 && fp->y > 0 failed: Bad size of frameset: x=%d y=%d", fp->x, fp->y);
  if ( !assert_failed )
    goto LABEL_6;
  assert_failed = 0;
  if ( fp->x <= 0 )
    fp->x = 1;
  y = fp->y;
  if ( y <= 0 )
  {
    fp->y = 1;
    y = 1;
  }
LABEL_15:
  v9 = fp->x * y;
  v3 = (frameset_desc *)mem_calloc(1u, 4 * (5 * v9 + 5));
  fd = v3;
  if ( !v3 )
    return fd;
  if ( v9 )
  {
    x = fp->x;
    v5 = v3;
    v6 = 0;
    while ( 1 )
    {
      v7 = v6;
      v5->frame_desc[0].width = fp->width[v6 % x];
      ++v6;
      v5->frame_desc[0].height = fp->height[v7 / fp->x];
      v5 = (frameset_desc *)((char *)v5 + 20);
      if ( v9 <= v6 )
        break;
      x = fp->x;
    }
  }
  fd->n = v9;
  fd->box.width = fp->x;
  fd->box.height = fp->y;
  if ( !fp->parent )
    return fd;
  add_frameset_entry(fp->parent, fd, 0, 0);
  return fd;
}

//----- (0808BA60) --------------------------------------------------------
void __cdecl ln_break(html_context *html_context, int n)
{
  int line_breax; // eax

  if ( n && !*((_DWORD *)html_context->stack.next + 38) )
  {
    while ( 1 )
    {
      line_breax = html_context->line_breax;
      if ( n <= line_breax )
        break;
      html_context->line_breax = line_breax + 1;
      html_context->line_break_f(html_context);
    }
    html_context->position = 0;
    html_context->putsp = HTML_SPACE_SUPPRESS;
  }
}

//----- (0808BAB0) --------------------------------------------------------
void __cdecl add_fragment_identifier(html_context *html_context, part *part, unsigned __int8 *attr)
{
  part *v3; // esi

  v3 = html_context->part;
  html_context->part = part;
  html_context->special_f(html_context, 0, attr);
  html_context->part = v3;
}

//----- (0808BAF0) --------------------------------------------------------
void __cdecl html_skip(html_context *html_context, unsigned __int8 *a)
{
  *((_DWORD *)html_context->stack.next + 38) = 1;
  *((_DWORD *)html_context->stack.next + 2) = 1;
}

//----- (0808BB10) --------------------------------------------------------
void __cdecl done_html_parser_state(html_context *html_context, void *state)
{
  html_element *next; // eax

  next = (html_element *)html_context->stack.next;
  for ( html_context->line_breax = 1; next != state; next = (html_element *)html_context->stack.next )
    kill_html_stack_item(html_context, next);
  *((_DWORD *)state + 2) = 2;
  kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
}

//----- (0808BB60) --------------------------------------------------------
void __cdecl done_html_parser(html_context *html_context)
{
  list_head_elinks *p_stack; // esi
  bool v2; // zf

  if ( (*((_BYTE *)html_context->options + 68) & 1) != 0 )
    done_css_stylesheet(&html_context->css_styles);
  p_stack = &html_context->stack;
  mem_free(html_context->base_target);
  done_uri(html_context->base_href);
  kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
  if ( assert_failed
    || (v2 = html_context->stack.next == p_stack, assert_failed = html_context->stack.next != p_stack, !v2)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c",
        errline = 965,
        elinks_internal("assertion list_empty(html_context->stack) failed: html stack not empty after operation"),
        assert_failed) )
  {
    assert_failed = 0;
    html_context->stack.prev = p_stack;
    html_context->stack.next = p_stack;
    mem_free(html_context);
  }
  else
  {
    mem_free(html_context);
  }
}

//----- (0808BC30) --------------------------------------------------------
html_context *__cdecl init_html_parser(
        uri *uri,
        document_options *options,
        unsigned __int8 *start,
        unsigned __int8 *end,
        string *head,
        string *title,
        void (*put_chars)(html_context *, unsigned __int8 *, int),
        void (*line_break)(html_context *),
        void *(*special)(html_context *, html_special_type, ...))
{
  _DWORD *v9; // eax
  _DWORD *v10; // ebx
  int *v11; // edx
  _DWORD *v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *framename; // ecx
  _DWORD *v15; // eax
  int v16; // ecx
  _DWORD *v17; // eax
  _DWORD *v18; // eax
  int *v20; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = uri == 0 || options == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c",
        errline = 873,
        elinks_internal("assertion uri && options failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v9 = mem_calloc(1u, 0x64u);
    v10 = v9;
    if ( v9 )
    {
      *v9 = import_css_stylesheet;
      v11 = v9 + 9;
      v12 = v9 + 2;
      v10[3] = v12;
      v10[2] = v12;
      v10[10] = v10 + 9;
      v10[9] = v10 + 9;
      v10[19] = start;
      v10[22] = put_chars;
      v10[23] = line_break;
      v10[24] = special;
      v13 = 0;
      ++uri->object.refcount;
      v10[5] = uri;
      framename = options->framename;
      if ( framename )
      {
        v13 = stracpy(framename);
        v11 = v10 + 9;
      }
      v10[6] = v13;
      v10[7] = options;
      v20 = v11;
      scan_http_equiv(start, end, head, title, options);
      v15 = mem_calloc(1u, 0xB4u);
      if ( v15 )
      {
        v16 = *v20;
        v15[1] = v20;
        *v15 = v16;
        *v20 = (int)v15;
        *(_DWORD *)(*v15 + 4) = v15;
        *(_DWORD *)(v10[9] + 12) = 0;
        *(_DWORD *)(v10[9] + 24) = 3;
        v17 = (_DWORD *)v10[9];
        v17[9] = 0;
        v17[8] = 0;
        v17[7] = 0;
        v18 = (_DWORD *)v10[9];
        v18[28] = 0;
        v18[27] = 0;
        v18[26] = 0;
        v18[25] = 0;
        v18[24] = 0;
        v18[23] = 0;
        v18[22] = 0;
        *(_DWORD *)(v10[9] + 72) = 0;
        *(_DWORD *)(v10[9] + 44) = 0;
        *(_DWORD *)(v10[9] + 40) = 0;
        *(text_style *)(v10[9] + 12) = options->default_style;
        *(_DWORD *)(v10[9] + 48) = options->default_link;
        *(_DWORD *)(v10[9] + 52) = options->default_vlink;
        *(_DWORD *)(v10[9] + 56) = options->default_bookmark_link;
        *(_DWORD *)(v10[9] + 60) = options->default_image_link;
        *(_DWORD *)(v10[9] + 116) = 0;
        *(_DWORD *)(v10[9] + 120) = options->margin;
        *(_DWORD *)(v10[9] + 124) = options->margin;
        *(_DWORD *)(v10[9] + 128) = options->box.width;
        *(_DWORD *)(v10[9] + 136) = 0;
        *(_DWORD *)(v10[9] + 132) = 0;
        *(_DWORD *)(v10[9] + 140) = options->margin;
        *(_DWORD *)(v10[9] + 144) = 0;
        *(_DWORD *)(v10[9] + 148) = options->default_style.bg;
        *(_DWORD *)(v10[9] + 152) = 0;
        *(_DWORD *)(v10[9] + 156) = 0;
        *(_DWORD *)(v10[9] + 160) = 0;
        *(_DWORD *)(v10[9] + 164) = 0;
        *(_DWORD *)(v10[9] + 168) = 1;
        *(_DWORD *)(v10[9] + 8) = 1;
        *((_BYTE *)v10 + 68) &= ~8u;
        v10[20] = 0;
        v10[1] = v10;
        if ( (*((_BYTE *)options + 68) & 1) != 0 )
          mirror_css_stylesheet(&default_stylesheet, (css_stylesheet *)v10);
      }
      else
      {
        return 0;
      }
    }
  }
  return (html_context *)v10;
}

//----- (0808BF20) --------------------------------------------------------
void *__cdecl init_html_parser_state(
        html_context *html_context,
        html_element_mortality_type type,
        int align,
        int margin,
        int width)
{
  html_stack_dup(html_context, type);
  *((_DWORD *)html_context->stack.next + 29) = align;
  if ( type == ELEMENT_IMMORTAL )
  {
    *((_DWORD *)html_context->stack.next + 30) = margin;
    *((_DWORD *)html_context->stack.next + 31) = margin;
    *((_DWORD *)html_context->stack.next + 32) = width;
    *((_DWORD *)html_context->stack.next + 33) = 0;
    *((_DWORD *)html_context->stack.next + 34) = 0;
    *((_DWORD *)html_context->stack.next + 35) = 0;
    *((_DWORD *)html_context->stack.next + 40) = 0;
  }
  return html_context->stack.next;
}

//----- (0808BFB0) --------------------------------------------------------
void __cdecl set_fragment_identifier(html_context *html_context, unsigned __int8 *attr_name, unsigned __int8 *attr)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v4; // ebx

  attr_value = get_attr_value(attr_name, attr, html_context->doc_cp, HTML_ATTR_NONE);
  v4 = attr_value;
  if ( attr_value )
  {
    html_context->special_f(html_context, 0, attr_value);
    mem_free(v4);
  }
}

//----- (0808C020) --------------------------------------------------------
void __cdecl put_chrs(html_context *html_context, unsigned __int8 *start, int len)
{
  int v3; // esi
  unsigned __int8 *v4; // edi
  _BYTE *next; // eax
  html_whitespace_state putsp; // eax
  const unsigned __int16 *v7; // eax
  int was_li; // eax

  v3 = len;
  v4 = start;
  next = html_context->stack.next;
  if ( (next[12] & 0x20) != 0 )
    html_context->putsp = HTML_SPACE_NORMAL;
  if ( len && !*((_DWORD *)next + 38) )
  {
    putsp = html_context->putsp;
    if ( putsp )
    {
      if ( putsp != HTML_SPACE_ADD )
      {
        v7 = *__ctype_b_loc();
LABEL_8:
        if ( (v7[v4[v3 - 1]] & 0x2000) != 0 && (*((_BYTE *)html_context->stack.next + 12) & 0x20) == 0 )
          html_context->putsp = HTML_SPACE_SUPPRESS;
        *((_BYTE *)html_context + 68) &= ~1u;
        html_context->put_chars_f(html_context, v4, v3);
        was_li = html_context->was_li;
        html_context->position += v3;
        html_context->line_breax = 0;
        if ( was_li > 0 )
          html_context->was_li = was_li - 1;
        return;
      }
      html_context->put_chars_f(html_context, (unsigned __int8 *)&::start, 1);
      ++html_context->position;
      html_context->putsp = HTML_SPACE_SUPPRESS;
    }
    html_context->putsp = HTML_SPACE_NORMAL;
    v7 = *__ctype_b_loc();
    if ( (v7[*start] & 0x2000) != 0 )
    {
      v3 = len - 1;
      if ( len == 1 )
      {
        html_context->putsp = HTML_SPACE_SUPPRESS;
        return;
      }
      v4 = start + 1;
    }
    goto LABEL_8;
  }
}

//----- (0808C120) --------------------------------------------------------
void __cdecl html_focusable(html_context *html_context, unsigned __int8 *a)
{
  int doc_cp; // edi
  unsigned __int8 *attr_value; // edx
  int v4; // ecx
  int num; // eax
  void **v6; // edx
  void **v7; // edx
  void **v8; // edx
  void **v9; // edx
  void **v10; // edx
  void **v11; // edx
  void **v12; // edx
  const unsigned __int16 **v13; // eax
  unsigned __int8 v14; // [esp+14h] [ebp-24h]
  unsigned __int8 *v15; // [esp+18h] [ebp-20h]
  _DWORD *next; // [esp+1Ch] [ebp-1Ch]

  *((_DWORD *)html_context->stack.next + 21) = 0;
  *((_DWORD *)html_context->stack.next + 20) = 0x80000000;
  if ( a )
  {
    doc_cp = html_context->doc_cp;
    attr_value = get_attr_value(a, "accesskey", doc_cp, HTML_ATTR_NONE);
    if ( attr_value )
    {
      next = html_context->stack.next;
      if ( !*attr_value
        || attr_value[1]
        || (v15 = attr_value,
            v14 = *attr_value,
            v13 = __ctype_b_loc(),
            attr_value = v15,
            v4 = v14,
            ((*v13)[v14] & 0x4000) == 0) )
      {
        v4 = 0;
      }
      next[21] = v4;
      mem_free(attr_value);
    }
    num = get_num(a, "tabindex", html_context->doc_cp);
    if ( (unsigned int)(num - 1) <= 0x7FFD )
      *((_DWORD *)html_context->stack.next + 20) = (num & 0x7FFF) << 16;
    v6 = (void **)html_context->stack.next;
    if ( v6[22] )
    {
      mem_free(v6[22]);
      v6 = (void **)html_context->stack.next;
    }
    v6[22] = get_attr_value(a, "onclick", doc_cp, HTML_ATTR_NONE);
    v7 = (void **)html_context->stack.next;
    if ( v7[23] )
    {
      mem_free(v7[23]);
      v7 = (void **)html_context->stack.next;
    }
    v7[23] = get_attr_value(a, "ondblclick", doc_cp, HTML_ATTR_NONE);
    v8 = (void **)html_context->stack.next;
    if ( v8[24] )
    {
      mem_free(v8[24]);
      v8 = (void **)html_context->stack.next;
    }
    v8[24] = get_attr_value(a, "onmouseover", doc_cp, HTML_ATTR_NONE);
    v9 = (void **)html_context->stack.next;
    if ( v9[25] )
    {
      mem_free(v9[25]);
      v9 = (void **)html_context->stack.next;
    }
    v9[25] = get_attr_value(a, "onhover", doc_cp, HTML_ATTR_NONE);
    v10 = (void **)html_context->stack.next;
    if ( v10[26] )
    {
      mem_free(v10[26]);
      v10 = (void **)html_context->stack.next;
    }
    v10[26] = get_attr_value(a, "onfocus", doc_cp, HTML_ATTR_NONE);
    v11 = (void **)html_context->stack.next;
    if ( v11[27] )
    {
      mem_free(v11[27]);
      v11 = (void **)html_context->stack.next;
    }
    v11[27] = get_attr_value(a, "onmouseout", doc_cp, HTML_ATTR_NONE);
    v12 = (void **)html_context->stack.next;
    if ( v12[28] )
    {
      mem_free(v12[28]);
      v12 = (void **)html_context->stack.next;
    }
    v12[28] = get_attr_value(a, "onblur", doc_cp, HTML_ATTR_NONE);
  }
}

//----- (0808C3B0) --------------------------------------------------------
void __cdecl process_head(html_context *html_context, unsigned __int8 *head)
{
  const char *v2; // eax
  char *v3; // ebx
  char v4; // dl
  char *v5; // eax
  unsigned __int8 *uri_string; // edi
  unsigned int v7; // edx
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // ebx
  char *v10; // edi
  char *v11; // eax
  const unsigned __int8 *v12; // edx
  char v13; // al
  int i; // eax
  unsigned __int8 v15; // cl
  int v16; // ecx
  unsigned __int8 v17; // cl
  const unsigned __int8 *v18; // ecx
  const unsigned __int8 *v19; // edi
  char v20; // dl
  int *v21; // eax
  unsigned __int8 *v22; // eax
  void *v23; // ebx
  char v24; // dl
  const unsigned __int8 *v25; // edi
  char v26; // al
  int v27; // edi
  unsigned __int8 *v28; // eax
  char *v29; // eax
  int v30; // eax
  int v31; // eax
  const char *v32; // edi
  char v33; // al
  char v34; // al
  int v35; // eax
  const char *v36; // edx
  char v37; // cl
  char v38; // cl
  int *v39; // [esp+28h] [ebp-40h]
  unsigned int v40; // [esp+28h] [ebp-40h]
  unsigned __int8 *link; // [esp+2Ch] [ebp-3Ch]
  timeval_T t; // [esp+3Ch] [ebp-2Ch] BYREF
  timeval_T v43; // [esp+44h] [ebp-24h] BYREF
  void *p; // [esp+4Ch] [ebp-1Ch] BYREF

  v2 = (const char *)parse_header(head, "Refresh", 0);
  v3 = (char *)v2;
  if ( !v2 )
    goto LABEL_16;
  if ( assert_failed )
    goto LABEL_4;
  assert_failed = 0;
  if ( !*v2 )
    goto LABEL_4;
  v11 = c_strcasestr(v2, (const char *)"url");
  if ( !v11 )
    goto LABEL_40;
  v12 = (const unsigned __int8 *)(v11 + 3);
  v13 = v11[3];
  if ( !v13 )
  {
LABEL_11:
    uri_string = stracpy((const unsigned __int8 *)&delete);
    if ( !uri_string )
      goto LABEL_40;
    goto LABEL_12;
  }
  while ( v13 == 61 || (unsigned __int8)v13 <= 0x20u )
  {
    v13 = *++v12;
    if ( !*v12 )
      goto LABEL_11;
  }
  for ( i = 0; ; ++i )
  {
    v15 = v12[i];
    if ( v15 <= 0x20u )
      break;
    if ( v15 == 59 )
      goto LABEL_32;
LABEL_29:
    ;
  }
  if ( v15 == 9 || v15 == 32 )
    goto LABEL_29;
LABEL_32:
  v16 = i;
  if ( i )
  {
    v17 = v12[i - 1];
    if ( v17 == 9 || v17 == 32 )
    {
      v18 = &v12[i];
      v19 = v12;
      do
      {
        if ( !--i )
        {
          v12 = v19;
          goto LABEL_38;
        }
        v20 = *(v18 - 2);
        --v18;
      }
      while ( v20 == 9 || v20 == 32 );
      v12 = v19;
    }
    if ( i > 1 && *v12 == 39 && v12[i - 1] == 39 )
    {
      v25 = &v12[i];
      v16 = i;
      do
      {
        v16 -= 2;
        ++v12;
        if ( v16 <= 1 )
          break;
        if ( *v12 != 39 )
          break;
        v26 = *(v25 - 2);
        --v25;
      }
      while ( v26 == 39 );
    }
    else
    {
LABEL_38:
      v16 = i;
    }
  }
  uri_string = memacpy(v12, v16);
  if ( uri_string )
    goto LABEL_12;
LABEL_40:
  if ( assert_failed )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
LABEL_4:
  assert_failed = 0;
  v4 = *v3;
  if ( !*v3 )
    goto LABEL_9;
  if ( v4 == 32 || v4 == 9 )
  {
    v5 = v3;
    while ( 1 )
    {
      v4 = *++v5;
      if ( !*v5 )
        break;
      if ( v4 != 9 && v4 != 32 )
        goto LABEL_54;
    }
LABEL_9:
    uri_string = get_uri_string(html_context->base_href, URI_ORIGINAL);
    if ( uri_string )
      goto LABEL_12;
    goto LABEL_15;
  }
  v5 = v3;
LABEL_54:
  while ( (unsigned __int8)(v4 - 48) <= 9u )
    v4 = *++v5;
  if ( !v4 )
    goto LABEL_9;
  v24 = *v5;
  if ( !*v5 )
    goto LABEL_9;
  if ( v24 == 32 || v24 == 9 )
  {
    do
    {
      v24 = *++v5;
      if ( !*v5 )
        goto LABEL_9;
    }
    while ( v24 == 9 || v24 == 32 );
  }
  if ( v24 != 44 && v24 != 59 )
    goto LABEL_9;
  v32 = v5 + 1;
  v33 = v5[1];
  if ( !v33 )
    goto LABEL_9;
  if ( v33 == 32 || v33 == 9 )
  {
    do
    {
      v34 = *++v32;
      if ( !*v32 )
        goto LABEL_9;
    }
    while ( v34 == 9 || v34 == 32 );
  }
  v35 = strlen(v32);
  if ( !v35 )
    goto LABEL_9;
  v36 = &v32[v35];
  v37 = v32[v35];
  if ( v37 == 32 || v37 == 9 )
  {
    while ( --v35 )
    {
      v38 = *--v36;
      if ( v38 != 9 && v38 != 32 )
        goto LABEL_110;
    }
    goto LABEL_9;
  }
LABEL_110:
  uri_string = memacpy((const unsigned __int8 *)v32, v35);
  if ( !uri_string )
    goto LABEL_9;
LABEL_12:
  v7 = 0;
  if ( *v3 == 59 )
    goto LABEL_45;
  if ( (unsigned __int8)(*v3 - 48) > 9u )
    goto LABEL_14;
  v21 = __errno_location();
  *v21 = 0;
  v39 = v21;
  v7 = strtoul(v3, 0, 10);
  if ( *v39 == 34 || v7 > 0x2A300 )
  {
    v7 = 172800;
    goto LABEL_45;
  }
  if ( !*v39 )
  {
LABEL_45:
    v40 = v7;
    link = join_urls(html_context->base_href, uri_string);
    html_focusable(html_context, 0);
    put_link_line("Refresh: ", uri_string, link, html_context->options->framename, html_context);
    html_context->special_f(html_context, 10, v40, link);
    mem_free(link);
  }
LABEL_14:
  mem_free(uri_string);
LABEL_15:
  mem_free(v3);
LABEL_16:
  if ( !get_opt_(config_options, "document.cache.ignore_cache_control")->number )
  {
    v8 = parse_header(head, "Pragma", 0);
    v9 = v8;
    p = v8;
    if ( v8 )
    {
      v10 = strstr((const char *)v8, "no-cache");
      mem_free(v9);
      if ( v10 )
        goto LABEL_20;
    }
    v22 = parse_header(head, "Cache-Control", 0);
    v23 = v22;
    p = v22;
    if ( v22 )
    {
      if ( strstr((const char *)v22, "no-cache") || strstr((const char *)v23, "must-revalidate") )
      {
        mem_free(v23);
LABEL_20:
        html_context->special_f(html_context, 8);
        return;
      }
      v29 = strstr((const char *)v23, "max-age=");
      if ( !assert_failed )
        assert_failed = 0;
      v27 = 0;
      if ( v29 )
      {
        v30 = strtol(v29 + 8, 0, 10);
        timeval_from_seconds(&t, v30);
        timeval_now(&v43);
        timeval_add_interval(&v43, &t);
        v31 = timeval_to_seconds(&v43);
        v23 = p;
        v27 = v31;
      }
      mem_free(v23);
    }
    else
    {
      v27 = 0;
    }
    v28 = parse_header(head, (unsigned __int8 *)&byte_8127C42, 0);
    p = v28;
    if ( v28 )
    {
      if ( strstr((const char *)v28, "now") )
      {
        timeval_now(&t);
        v27 = timeval_to_seconds(&t);
      }
      else
      {
        v27 = parse_date((unsigned __int8 **)&p, 0, 0, 1);
      }
      mem_free(p);
    }
    if ( v27 )
      html_context->special_f(html_context, 9, v27);
  }
}

//----- (0808CA40) --------------------------------------------------------
void __cdecl import_css_stylesheet(
        css_stylesheet *css,
        uri *base_uri,
        const unsigned __int8 *unterminated_url,
        int len)
{
  const unsigned __int8 *v4; // edx
  int v5; // ecx
  _DWORD *import_data; // ebx
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edi
  int v9; // [esp+14h] [ebp-24h]
  const unsigned __int8 *p; // [esp+18h] [ebp-20h]
  unsigned __int8 *pa; // [esp+18h] [ebp-20h]
  uri *uri; // [esp+1Ch] [ebp-1Ch]

  v4 = unterminated_url;
  v5 = len;
  import_data = css->import_data;
  if ( !assert_failed )
  {
    assert_failed = import_data == 0;
    if ( import_data )
    {
      assert_failed = base_uri == 0;
      if ( base_uri )
        goto LABEL_4;
LABEL_6:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 193;
      p = v4;
      v9 = v5;
      elinks_internal("assertion base_uri failed!");
      v5 = v9;
      v4 = p;
      if ( (*(_BYTE *)(import_data[7] + 68) & 3) != 3 )
        return;
      goto LABEL_7;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
    errline = 192;
    elinks_internal("assertion html_context failed!");
    v5 = len;
    v4 = unterminated_url;
    if ( !assert_failed )
    {
      assert_failed = base_uri == 0;
      if ( !base_uri )
        goto LABEL_6;
    }
  }
LABEL_4:
  if ( (*(_BYTE *)(import_data[7] + 68) & 3) != 3 )
    return;
LABEL_7:
  v7 = memacpy(v4, v5);
  if ( v7 )
  {
    pa = v7;
    v8 = join_urls(base_uri, v7);
    mem_free(pa);
    if ( v8 )
    {
      uri = get_uri(v8, URI_BASE);
      mem_free(v8);
      if ( uri )
      {
        ((void (__cdecl *)(_DWORD *, int, uri *))import_data[24])(import_data, 11, uri);
        import_css(css, uri);
        done_uri(uri);
      }
    }
  }
}

//----- (0808CBE0) --------------------------------------------------------
unsigned __int8 *__cdecl get_target(document_options *options, unsigned __int8 *a)
{
  const char *attr_value; // eax
  unsigned __int8 *v3; // ebx

  attr_value = (const char *)get_attr_value(a, "target", options->cp, HTML_ATTR_NONE);
  v3 = (unsigned __int8 *)attr_value;
  if ( !attr_value || *attr_value && c_strcasecmp(attr_value, "_self") )
    return v3;
  mem_free(v3);
  return stracpy(options->framename);
}

//----- (0808CC60) --------------------------------------------------------
int __cdecl get_image_map(
        unsigned __int8 *head,
        unsigned __int8 *pos,
        unsigned __int8 *eof,
        menu_item **menu,
        memory_list **ml,
        uri *uri,
        document_options *options,
        unsigned __int8 *target_base,
        int to,
        int def,
        int hdef)
{
  unsigned __int8 *v11; // ebx
  menu_item *v13; // eax
  unsigned __int8 *i; // eax
  unsigned __int8 v15; // dl
  unsigned __int8 *attr_value; // esi
  unsigned __int8 *v17; // eax
  unsigned __int8 v18; // dl
  unsigned __int8 *v19; // edi
  unsigned __int8 *v20; // esi
  unsigned __int8 *v21; // edx
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // esi
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // esi
  int v26; // edi
  menu_item *v27; // eax
  int v28; // ecx
  menu_item *v29; // esi
  const char **data; // ebx
  unsigned __int8 *text; // edx
  int v32; // ecx
  menu_item *v33; // eax
  unsigned int v34; // esi
  char *v35; // edx
  _WORD *v36; // edi
  _WORD *v37; // edi
  signed int v38; // edx
  unsigned __int8 v39; // dl
  unsigned int v40; // eax
  size_t v41; // ecx
  unsigned __int8 *v42; // eax
  unsigned __int8 *v43; // eax
  unsigned __int8 *v44; // eax
  int v45; // [esp+8h] [ebp-70h]
  signed int v46; // [esp+20h] [ebp-58h]
  signed int v47; // [esp+20h] [ebp-58h]
  int v48; // [esp+24h] [ebp-54h]
  int v49; // [esp+24h] [ebp-54h]
  size_t v50; // [esp+24h] [ebp-54h]
  int v51; // [esp+24h] [ebp-54h]
  unsigned __int8 *v52; // [esp+28h] [ebp-50h]
  conv_table *ct; // [esp+2Ch] [ebp-4Ch]
  char **p; // [esp+30h] [ebp-48h]
  char *s2; // [esp+34h] [ebp-44h]
  int s2a; // [esp+34h] [ebp-44h]
  unsigned __int8 *str; // [esp+38h] [ebp-40h]
  unsigned __int8 *stra; // [esp+38h] [ebp-40h]
  unsigned __int8 *n1; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *n1a; // [esp+3Ch] [ebp-3Ch]
  string string; // [esp+40h] [ebp-38h] BYREF
  string hd; // [esp+48h] [ebp-30h] BYREF
  unsigned __int8 *e; // [esp+50h] [ebp-28h] BYREF
  unsigned __int8 *attr; // [esp+54h] [ebp-24h] BYREF
  unsigned __int8 *name; // [esp+58h] [ebp-20h] BYREF
  int namelen[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v11 = eof;
  if ( !init_string(&hd) )
    return -1;
  if ( head )
    add_to_string(&hd, head);
  scan_http_equiv(pos, v11, &hd, 0, options);
  ct = get_convert_table(hd.source, to, def, 0, 0, hdef);
  done_string(&hd);
  v13 = (menu_item *)mem_calloc(1u, 0x20u);
  *menu = v13;
  if ( !v13 )
    return -1;
  while ( 1 )
  {
    do
    {
      for ( i = pos; ; i = ++pos )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            if ( v11 <= i )
              goto LABEL_10;
            if ( *i == 60 )
              break;
            pos = ++i;
          }
          if ( v11 < i + 2 )
            break;
          v15 = i[1];
          if ( v15 != 63 && v15 != 33 )
            break;
          i = skip_comment(i, v11);
          pos = i;
        }
        if ( !parse_element(i, v11, &name, namelen, &attr, &pos) )
          break;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 550;
    }
    while ( elinks_strlcasecmp(name, namelen[0], "MAP", 3u, 1) );
    if ( !uri || !uri->fragment )
      break;
    attr_value = get_attr_value(attr, (unsigned __int8 *)"name", options->cp, HTML_ATTR_NONE);
    if ( attr_value )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 558;
      if ( !elinks_strlcasecmp(attr_value, 0xFFFFFFFF, uri->fragment, *((unsigned __int16 *)uri + 26), 1) )
      {
        mem_free(attr_value);
        break;
      }
      mem_free(attr_value);
    }
  }
  if ( v11 <= pos )
  {
LABEL_10:
    mem_free(*menu);
    return -1;
  }
  *ml = 0;
  do
  {
LABEL_24:
    v17 = pos;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( v11 <= v17 )
            goto LABEL_48;
          while ( *v17 != 60 )
          {
            pos = ++v17;
            if ( v11 <= v17 )
              goto LABEL_48;
          }
          if ( v11 < v17 + 2 )
            break;
          v18 = v17[1];
          if ( v18 != 63 && v18 != 33 )
            break;
          v17 = skip_comment(v17, v11);
          pos = v17;
        }
        if ( !parse_element(v17, v11, &name, (int *)&attr, (unsigned __int8 **)namelen, &pos) )
          break;
        v17 = ++pos;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
      errline = 650;
      if ( elinks_strlcasecmp(name, (size_t)attr, "A", 1u, 1) )
        break;
      while ( 1 )
      {
        do
        {
          while ( 1 )
          {
            v19 = name;
            n1 = attr;
            if ( !init_string(&string) )
              goto LABEL_47;
            v20 = pos;
            e = pos;
            if ( v11 <= pos )
            {
LABEL_46:
              done_string(&string);
LABEL_47:
              pos = v11;
              goto LABEL_48;
            }
            if ( *pos == 60 )
            {
LABEL_111:
              str = string.source;
              goto LABEL_88;
            }
            v21 = pos;
            do
            {
              e = ++v21;
              if ( v11 <= v21 )
                goto LABEL_46;
            }
            while ( *v21 != 60 );
            if ( v21 == pos )
              goto LABEL_111;
            if ( assert_failed )
            {
LABEL_87:
              assert_failed = 0;
              str = string.source;
              goto LABEL_88;
            }
            v38 = v21 - pos;
            if ( v38 < 0 )
            {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 255;
              v46 = v38;
              elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
              v38 = v46;
              if ( assert_failed )
                goto LABEL_87;
            }
            else
            {
              assert_failed = 0;
            }
            if ( !v38 )
            {
              str = string.source;
              goto LABEL_88;
            }
            v40 = string.length + 255;
            s2a = v38 + string.length;
            v41 = v38 + string.length + 256;
            LOBYTE(v40) = 0;
            LOBYTE(v41) = 0;
            stra = (unsigned __int8 *)v40;
            if ( v41 > v40 )
            {
              v47 = v38;
              v50 = v41;
              v43 = (unsigned __int8 *)mem_realloc(string.source, v41);
              if ( !v43 )
                goto LABEL_111;
              string.source = v43;
              memset(&v43[(_DWORD)stra], 0, v50 - (_DWORD)stra);
              v38 = v47;
            }
            str = string.source;
            if ( string.source )
            {
              memcpy(&string.source[string.length], v20, v38);
              string.source[s2a] = 0;
              string.length = s2a;
              str = string.source;
            }
LABEL_88:
            pos = e;
            if ( v11 < e + 2 )
              break;
            v39 = e[1];
            if ( v39 != 63 && v39 != 33 )
              break;
            pos = skip_comment(e, v11);
          }
        }
        while ( parse_element(e, v11, 0, 0, 0, &e) );
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 605;
        if ( !elinks_strlcasecmp(v19, (size_t)n1, "A", 1u, 1) )
          break;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 606;
        if ( !elinks_strlcasecmp(v19, (size_t)n1, "/A", 2u, 1) )
          break;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 607;
        if ( !elinks_strlcasecmp(v19, (size_t)n1, "MAP", 3u, 1) )
          break;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 608;
        if ( !elinks_strlcasecmp(v19, (size_t)n1, "/MAP", 4u, 1) )
          break;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 609;
        if ( !elinks_strlcasecmp(v19, (size_t)n1, "AREA", 4u, 1) )
          break;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
        errline = 610;
        if ( !elinks_strlcasecmp(v19, (size_t)n1, &byte_812C403, 5u, 1) )
          break;
        pos = e;
      }
      if ( v11 <= pos )
      {
LABEL_48:
        freeml(*ml);
        mem_free(*menu);
        return -1;
      }
LABEL_53:
      n1a = get_target(options, (unsigned __int8 *)namelen[0]);
      if ( !n1a )
      {
        v42 = (unsigned __int8 *)&delete;
        if ( target_base )
          v42 = target_base;
        n1a = stracpy(v42);
        if ( !n1a )
        {
          if ( str )
            goto LABEL_109;
          goto LABEL_24;
        }
      }
      p = (char **)mem_alloc(8u);
      if ( p )
      {
        v24 = get_attr_value((unsigned __int8 *)namelen[0], "href", options->cp, HTML_ATTR_EAT_NL);
        v25 = v24;
        if ( v24 )
        {
          *p = (char *)join_urls(uri, v24);
          mem_free(v25);
          if ( *p )
          {
            v26 = 0;
            p[1] = (char *)n1a;
            v27 = *menu;
            v28 = 0;
            if ( (*menu)->text )
            {
              v29 = v27 + 1;
              v52 = v11;
              s2 = *p;
              while ( 1 )
              {
                data = (const char **)v27->data;
                if ( !strcmp(*data, s2) && !strcmp(data[1], (const char *)n1a) )
                  break;
                text = v29->text;
                ++v26;
                v27 = v29++;
                v28 = 32 * v26;
                if ( !text )
                {
                  v11 = v52;
                  goto LABEL_63;
                }
              }
              v11 = v52;
              mem_free(s2);
              mem_free(p[1]);
              mem_free(p);
              if ( !str )
                goto LABEL_24;
LABEL_109:
              mem_free(str);
              v17 = pos;
            }
            else
            {
LABEL_63:
              if ( str )
              {
                v48 = v28;
                clr_spaces(str);
                v32 = v48;
                if ( *str )
                  goto LABEL_65;
                mem_free(str);
                v28 = v48;
              }
              v51 = v28;
              v44 = stracpy((const unsigned __int8 *)*p);
              v32 = v51;
              str = v44;
              if ( !v44 )
              {
                mem_free(n1a);
                mem_free(*p);
                goto LABEL_119;
              }
LABEL_65:
              v49 = v32;
              v33 = (menu_item *)mem_realloc(*menu, 32 * (v26 + 2));
              if ( v33 )
              {
                v34 = 64;
                *menu = v33;
                v35 = (char *)v33 + v49;
                v36 = (_WORD *)((char *)v33 + v49);
                if ( (((_BYTE)v33 + (_BYTE)v49) & 1) != 0 )
                {
                  *v35 = 0;
                  v36 = v35 + 1;
                  LOWORD(v34) = 63;
                }
                if ( ((unsigned __int8)v36 & 2) != 0 )
                {
                  *v36 = 0;
                  v34 -= 2;
                  ++v36;
                }
                memset(v36, 0, 4 * (v34 >> 2));
                v37 = &v36[2 * (v34 >> 2)];
                if ( (v34 & 2) != 0 )
                  *v37++ = 0;
                if ( (v34 & 1) != 0 )
                  *(_BYTE *)v37 = 0;
                *((_DWORD *)v35 + 3) = map_selected;
                *(_DWORD *)v35 = str;
                *((_DWORD *)v35 + 5) = 64;
                *((_DWORD *)v35 + 4) = p;
              }
              add_to_ml(ml, p, *p, p[1], str, 0);
              v17 = pos;
            }
          }
          else
          {
            if ( str )
              mem_free(str);
            mem_free(n1a);
LABEL_119:
            mem_free(p);
            v17 = pos;
          }
        }
        else
        {
          if ( str )
            mem_free(str);
          mem_free(n1a);
          mem_free(p);
          v17 = pos;
        }
      }
      else
      {
        if ( str )
          mem_free(str);
        mem_free(n1a);
        v17 = pos;
      }
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
    errline = 655;
    if ( !elinks_strlcasecmp(name, (size_t)attr, "AREA", 4u, 1) )
    {
      v22 = get_attr_value((unsigned __int8 *)namelen[0], (unsigned __int8 *)"alt", options->cp, HTML_ATTR_NONE);
      str = 0;
      v23 = v22;
      if ( v22 )
      {
        v45 = strlen((const char *)v22);
        str = convert_string_elinks(ct, v23, v45, options->cp, CSM_DEFAULT, 0, 0, 0);
        mem_free(v23);
      }
      goto LABEL_53;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser.c";
    errline = 669;
  }
  while ( elinks_strlcasecmp(name, (size_t)attr, "/MAP", 4u, 1) );
  add_to_ml(ml, *menu, 0);
  return 0;
}

//----- (0808D7C0) --------------------------------------------------------
int __cdecl get_color(html_context *html_context, unsigned __int8 *a, unsigned __int8 *c, color_T *rgb)
{
  document_options *options; // eax
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v7; // ebx
  int v8; // eax
  int v9; // [esp+1Ch] [ebp-Ch]

  options = html_context->options;
  if ( options->color_mode == COLOR_MODE_MONO )
    return -1;
  if ( options->use_document_colors <= 0 )
    return -1;
  attr_value = get_attr_value(a, c, html_context->doc_cp, HTML_ATTR_NONE);
  v7 = attr_value;
  if ( !attr_value )
    return -1;
  v8 = strlen((const char *)attr_value);
  v9 = decode_color(v7, v8, rgb);
  mem_free(v7);
  return v9;
}

//----- (0808D840) --------------------------------------------------------
int __cdecl get_bgcolor(html_context *html_context, unsigned __int8 *a, color_T *rgb)
{
  document_options *options; // eax

  options = html_context->options;
  if ( options->color_mode && options->use_document_colors == 2 )
    return get_color(html_context, a, "bgcolor", rgb);
  else
    return -1;
}

//----- (0808D890) --------------------------------------------------------
void __cdecl check_html_form_hierarchy(part *part)
{
  document *v1; // eax
  list_head_elinks *next; // ebx
  bool v3; // zf
  void **prev; // eax
  void **v5; // edx
  int v6; // ecx
  void *v7; // ecx
  _DWORD *p_next; // edx
  list_head_elinks *v9; // ecx
  void *v10; // ebx
  list_head_elinks *v11; // eax
  list_head_elinks *v12; // eax
  int v13; // edi
  document *document; // [esp+28h] [ebp-30h]
  list_head_elinks *p_forms; // [esp+2Ch] [ebp-2Ch]
  list_head_elinks form_controls; // [esp+38h] [ebp-20h] BYREF

  v1 = part->document;
  form_controls.next = &form_controls;
  form_controls.prev = &form_controls;
  document = v1;
  next = (list_head_elinks *)v1->forms.next;
  p_forms = &v1->forms;
  if ( next != &v1->forms )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      next = (list_head_elinks *)v1->forms.next;
    }
    if ( next != p_forms )
    {
      do
      {
        if ( !assert_failed )
        {
          v3 = (int)next[1].next <= (int)next[1].prev;
          assert_failed = (int)next[1].next > (int)next[1].prev;
          if ( !v3 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 1912;
            elinks_internal(
              "assertion form->form_num <= form->form_end failed: %p [%d : %d]",
              next,
              next[1].next,
              next[1].prev);
          }
        }
        prev = (void **)next[4].prev;
        v5 = (void **)*prev;
        if ( prev != &next[4].prev )
        {
          while ( 1 )
          {
            v6 = (int)prev[4];
            if ( ((int)next[1].next > v6 || v6 > (int)next[1].prev) && form_controls.next != prev )
            {
              *((_DWORD *)*prev + 1) = prev[1];
              *(_DWORD *)prev[1] = *prev;
              v7 = form_controls.next;
              prev[1] = &form_controls;
              *prev = v7;
              form_controls.next = prev;
              *((_DWORD *)*prev + 1) = prev;
            }
            prev = v5;
            if ( &next[4].prev == v5 )
              break;
            v5 = (void **)*v5;
          }
        }
        next = (list_head_elinks *)next->next;
      }
      while ( next != p_forms );
      p_next = form_controls.next;
      v9 = *(list_head_elinks **)form_controls.next;
      if ( form_controls.next != &form_controls )
      {
        while ( 1 )
        {
          v12 = (list_head_elinks *)document->forms.next;
          if ( v12 != p_forms )
            break;
LABEL_22:
          v11 = (list_head_elinks *)v9->next;
          p_next = &v9->next;
          if ( v9 == &form_controls )
            goto LABEL_29;
LABEL_23:
          v9 = v11;
        }
        v13 = p_next[4];
        do
        {
          if ( (int)v12[1].next <= v13 && (int)v12[1].prev >= v13 )
          {
            p_next[2] = v12;
            if ( v12[4].prev != p_next )
            {
              *(_DWORD *)(*p_next + 4) = p_next[1];
              *(_DWORD *)p_next[1] = *p_next;
              v10 = v12[4].prev;
              p_next[1] = (char *)v12 + 36;
              *p_next = v10;
              v12[4].prev = p_next;
              *(_DWORD *)(*p_next + 4) = p_next;
            }
            goto LABEL_22;
          }
          v12 = (list_head_elinks *)v12->next;
        }
        while ( v12 != p_forms );
        p_next = &v9->next;
        v11 = (list_head_elinks *)v9->next;
        if ( v9 != &form_controls )
          goto LABEL_23;
      }
    }
LABEL_29:
    if ( !assert_failed )
    {
      assert_failed = &form_controls != form_controls.next;
      if ( &form_controls != form_controls.next )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1938;
        elinks_internal("assertion list_empty(form_controls) failed!");
      }
    }
  }
}

//----- (0808DA70) --------------------------------------------------------
void *html_special(html_context *html_context, html_special_type c, ...)
{
  html_special_type v2; // edx
  void *result; // eax
  part *part; // ebx
  document *document; // esi
  cache_entry *v6; // ebx
  cache_entry *cached; // eax
  int g_ctrl_num; // eax
  document *v9; // eax
  int use_document_colors; // ecx
  int v11; // edi
  bool v12; // zf
  document *v13; // edi
  _DWORD *v14; // eax
  int p_forms; // edi
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  int cx; // ecx
  tag *v20; // eax
  tag *v21; // ebx
  tag *next; // edx
  document *v23; // edx
  color_T v24; // eax
  document *v25; // edi
  int v26; // esi
  line *v27; // eax
  screen_char *v28; // ebx
  form *inited; // eax
  form *v30; // eax
  int v31; // [esp+24h] [ebp-44h]
  size_t v32; // [esp+28h] [ebp-40h]
  html_special_type v33; // [esp+28h] [ebp-40h]
  int v34; // [esp+30h] [ebp-38h]
  color_flags flags; // [esp+34h] [ebp-34h]
  color_flags flagsa; // [esp+34h] [ebp-34h]
  color_mode color_mode; // [esp+38h] [ebp-30h]
  color_mode color_modea; // [esp+38h] [ebp-30h]
  int x; // [esp+3Ch] [ebp-2Ch]
  color_pair pair; // [esp+48h] [ebp-20h] BYREF
  char *v41; // [esp+78h] [ebp+10h]
  unsigned __int8 *v42; // [esp+7Ch] [ebp+14h]
  unsigned __int8 *v43; // [esp+80h] [ebp+18h]
  va_list va; // [esp+84h] [ebp+1Ch] BYREF

  va_start(va, c);
  v41 = va_arg(va, char *);
  v42 = va_arg(va, unsigned __int8 *);
  v43 = va_arg(va, unsigned __int8 *);
  v2 = c;
  if ( assert_failed )
    goto LABEL_2;
  assert_failed = html_context == 0;
  if ( !html_context )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1976;
    elinks_internal("assertion html_context failed!");
    v2 = c;
    if ( assert_failed )
      goto LABEL_2;
  }
  part = html_context->part;
  assert_failed = part == 0;
  if ( !part )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1981;
    v33 = v2;
    elinks_internal("assertion part failed!");
    v2 = v33;
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  document = part->document;
  switch ( v2 )
  {
    case SP_TAG:
      if ( !document )
        return 0;
      flags = part->box.y;
      color_mode = part->cy;
      x = part->box.x;
      cx = part->cx;
      if ( assert_failed )
        goto LABEL_2;
      assert_failed = 0;
      v31 = cx;
      v32 = strlen(v41);
      v20 = (tag *)mem_alloc(v32 + 20);
      v21 = v20;
      if ( !v20 )
        return 0;
      v20->x = x + v31;
      v20->y = flags + color_mode;
      memcpy(v20->name, v41, v32 + 1);
      next = (tag *)document->tags.next;
      v21->prev = (tag *)&document->tags;
      v21->next = next;
      document->tags.next = v21;
      v21->next->prev = v21;
      if ( &document->tags != (list_head_elinks *)renderer_context_0.last_tag_for_newline )
        return 0;
      renderer_context_0.last_tag_for_newline = v21;
      return 0;
    case SP_FORM:
      if ( assert_failed )
        goto LABEL_2;
      assert_failed = v41 == 0;
      if ( !v41 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1751;
        elinks_internal("assertion part && form failed!");
        if ( assert_failed )
          goto LABEL_2;
      }
      v11 = *((_DWORD *)v41 + 2);
      assert_failed = v11 <= 0;
      if ( v11 <= 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1752;
        elinks_internal("assertion form->form_num > 0 failed!");
        if ( assert_failed )
          goto LABEL_2;
      }
      v12 = *((_DWORD *)v41 + 3) == 0x7FFFFFFF;
      assert_failed = *((_DWORD *)v41 + 3) != 0x7FFFFFFF;
      if ( !v12 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1753;
        elinks_internal("assertion form->form_end == INT_MAX failed!");
        if ( assert_failed )
          goto LABEL_2;
      }
      v13 = part->document;
      if ( !part->document )
        goto LABEL_72;
      v14 = v13->forms.next;
      p_forms = (int)&v13->forms;
      if ( v14 != (_DWORD *)p_forms )
        goto LABEL_41;
      inited = init_form();
      if ( !inited )
        goto LABEL_72;
      inited->form_num = 0;
      inited->next = (form *)part->document->forms.next;
      inited->prev = (form *)&part->document->forms;
      part->document->forms.next = inited;
      inited->next->prev = inited;
      v14 = part->document->forms.next;
      p_forms = (int)&part->document->forms;
LABEL_41:
      if ( (_DWORD *)p_forms == v14 )
      {
LABEL_71:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1812;
        elinks_error("hole between forms");
LABEL_72:
        done_form((form *)v41);
        return 0;
      }
      v16 = *((_DWORD *)v41 + 2);
      while ( 1 )
      {
        v17 = v14[2];
        if ( v17 <= v16 && v14[3] >= v16 )
          break;
        v14 = (_DWORD *)*v14;
        if ( (_DWORD *)p_forms == v14 )
          goto LABEL_71;
      }
      if ( v17 == v16 )
        goto LABEL_72;
      v18 = v16 - 1;
      *((_DWORD *)v41 + 3) = v14[3];
      v14[3] = v18;
      if ( !assert_failed )
      {
        assert_failed = v18 < v14[2];
        if ( assert_failed )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 1807;
          elinks_internal(
            "assertion nform->form_num <= nform->form_end failed: [%d:%d] [%d:%d]",
            v14[2],
            v14[3],
            *((_DWORD *)v41 + 2),
            *((_DWORD *)v41 + 3));
        }
      }
      *(_DWORD *)v41 = part->document->forms.next;
      *((_DWORD *)v41 + 1) = &part->document->forms;
      part->document->forms.next = v41;
      *(_DWORD *)(*(_DWORD *)v41 + 4) = v41;
      return 0;
    case SP_CONTROL:
      if ( assert_failed )
        goto LABEL_2;
      assert_failed = v41 == 0;
      if ( !v41 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1822;
        elinks_internal("assertion part && fc failed!");
        if ( assert_failed )
          goto LABEL_2;
      }
      if ( part->document )
      {
        g_ctrl_num = renderer_context_0.g_ctrl_num;
        *((_DWORD *)v41 + 3) = renderer_context_0.g_ctrl_num;
        renderer_context_0.g_ctrl_num = g_ctrl_num + 1;
        v9 = (document *)part->document->forms.next;
        if ( v9 == (document *)&part->document->forms )
        {
          v30 = init_form();
          v30->form_num = 0;
          v30->next = (form *)part->document->forms.next;
          v30->prev = (form *)&part->document->forms;
          part->document->forms.next = v30;
          v30->next->prev = v30;
          v9 = (document *)part->document->forms.next;
        }
        *((_DWORD *)v41 + 2) = v9;
        use_document_colors = v9->options.use_document_colors;
        *((_DWORD *)v41 + 1) = &v9->options.use_document_colors;
        *(_DWORD *)v41 = use_document_colors;
        v9->options.use_document_colors = (int)v41;
        *(_DWORD *)(*(_DWORD *)v41 + 4) = v41;
        return 0;
      }
      else
      {
        done_form_control((form_control *)v41);
        mem_free(v41);
        return 0;
      }
    case SP_TABLE:
      return renderer_context_0.convert_table;
    case SP_USED:
      return (void *)(document != 0);
    case SP_FRAMESET:
      if ( !*(_DWORD *)v41 && document->frame_desc )
        return 0;
      result = create_frameset((frameset_param *)v41);
      if ( !*(_DWORD *)v41 && !document->frame_desc )
        document->frame_desc = (frameset_desc *)result;
      return result;
    case SP_FRAME:
      add_frameset_entry((frameset_desc *)v41, 0, v42, v43);
      return 0;
    case SP_NOWRAP:
      *((_BYTE *)&renderer_context_0 + 48) = (8 * (v41 != 0)) | *((_BYTE *)&renderer_context_0 + 48) & 0xF7;
      return 0;
    case SP_CACHE_CONTROL:
      cached = renderer_context_0.cached;
      renderer_context_0.cached->cache_mode = CACHE_MODE_NEVER;
      *((_BYTE *)cached + 92) &= ~1u;
      return 0;
    case SP_CACHE_EXPIRES:
      v6 = renderer_context_0.cached;
      if ( !v41 || renderer_context_0.cached->cache_mode == CACHE_MODE_NEVER )
        return 0;
      timeval_from_seconds(&renderer_context_0.cached->max_age, (int)v41);
      result = 0;
      *((_BYTE *)v6 + 92) |= 1u;
      return result;
    case SP_REFRESH:
      if ( !document )
        return 0;
      if ( document->refresh )
        done_document_refresh(document->refresh);
      document->refresh = init_document_refresh(v42, (unsigned int)v41);
      return 0;
    case SP_STYLESHEET:
      if ( !document )
        return 0;
      add_to_uri_list(&document->css_imports, (uri *)v41);
      return 0;
    case SP_COLOR_LINK_LINES:
      if ( !document )
        return 0;
      if ( document->options.color_mode == COLOR_MODE_MONO )
        return 0;
      if ( document->options.use_document_colors != 2 )
        return 0;
      v23 = html_context->part->document;
      v24 = *((_DWORD *)html_context->stack.next + 37);
      pair.foreground = 0;
      pair.background = v24;
      color_modea = v23->options.color_mode;
      v34 = 0;
      flagsa = v23->options.color_flags;
      if ( v23->height <= 0 )
        return 0;
      v25 = v23;
      do
      {
        v26 = 0;
        v27 = &v25->data[v34];
        if ( v27->length > 0 )
        {
          do
          {
            v28 = &v27->chars[v26];
            set_term_color(v28, &pair, flagsa, color_modea);
            if ( v28->data == 58 && !pair.foreground )
              pair.foreground = *((_DWORD *)html_context->stack.next + 12);
            ++v26;
            v27 = &v25->data[v34];
          }
          while ( v26 < v27->length );
        }
        ++v34;
        pair.foreground = 0;
      }
      while ( v34 < v25->height );
      return 0;
    default:
      return 0;
  }
}

//----- (0808E200) --------------------------------------------------------
void __usercall move_links(html_context *html_context@<eax>, int xf@<edx>, int yf@<ecx>, int xt, int yt)
{
  part *v5; // eax
  document *document; // edx
  int v7; // ebx
  int v8; // esi
  point *v9; // eax
  int y; // ecx
  int v11; // edi
  int v12; // edx
  tag *last_tag_to_move; // eax
  int v14; // edi
  int p_tags; // esi
  int v16; // ecx
  int v17; // ebx
  int v18; // edi
  point *points; // edx
  point *v20; // eax
  int v21; // [esp+1Ch] [ebp-3Ch]
  int nlink; // [esp+24h] [ebp-34h]
  link *link; // [esp+2Ch] [ebp-2Ch]
  int npoints; // [esp+30h] [ebp-28h]
  part *part; // [esp+34h] [ebp-24h]
  int v28; // [esp+38h] [ebp-20h]
  int v29; // [esp+3Ch] [ebp-1Ch]

  nlink = renderer_context_0.last_link_to_move;
  if ( assert_failed )
    goto LABEL_30;
  assert_failed = html_context == 0;
  if ( !html_context )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 624;
    elinks_internal("assertion html_context failed!");
    html_context = 0;
    if ( assert_failed )
      goto LABEL_30;
  }
  v5 = html_context->part;
  part = v5;
  if ( v5 && v5->document )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 629;
    elinks_internal("assertion part && part->document failed!");
    if ( assert_failed )
    {
LABEL_30:
      assert_failed = 0;
      return;
    }
  }
  if ( !realloc_lines(part->document, part->box.y + yt) )
    return;
  document = part->document;
  if ( nlink < part->document->nlinks )
  {
    v28 = 0;
    v21 = nlink;
    while ( 1 )
    {
      link = &document->links[v21];
      npoints = link->npoints;
      v29 = npoints;
      if ( npoints > 0 )
        break;
LABEL_18:
      if ( !v28 )
        renderer_context_0.last_link_to_move = nlink;
      ++nlink;
      document = part->document;
      ++v21;
      if ( part->document->nlinks <= nlink )
        goto LABEL_21;
    }
    v7 = 0;
    while ( 1 )
    {
      while ( v28 )
      {
        v8 = v7;
        v9 = &link->points[v7];
        y = v9->y;
        v11 = part->box.y;
        v12 = v11 + yf;
LABEL_12:
        if ( y == v12 )
        {
          if ( v9->x >= part->box.x + xf )
          {
            if ( yt < 0 )
            {
              v18 = ~v7 + v29;
              if ( !assert_failed )
              {
                assert_failed = (unsigned int)v18 >> 31;
                if ( v18 < 0 )
                {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
                  errline = 687;
                  elinks_internal("assertion to_move >= 0 failed!");
                }
              }
              if ( v18 > 0 )
              {
                points = link->points;
                v20 = &points[v7-- + 1];
                memmove(&points[v8], v20, 8 * v18);
              }
              v29 = link->npoints - 1;
              npoints = v29;
              link->npoints = v29;
              v28 = 1;
            }
            else
            {
              v9->y = yt + v11;
              link->points[v8].x += xt - xf;
              v28 = 1;
              npoints = link->npoints;
              v29 = npoints;
            }
          }
          else
          {
            v28 = 1;
            v29 = npoints;
          }
        }
        else
        {
          v29 = npoints;
        }
        if ( v29 <= ++v7 )
          goto LABEL_18;
      }
      v8 = v7;
      v9 = &link->points[v7];
      v11 = part->box.y;
      y = v9->y;
      v12 = v11 + yf;
      if ( y <= v11 + yf )
        goto LABEL_12;
      ++v7;
      v28 = 1;
      v29 = npoints;
      if ( npoints <= v7 )
        goto LABEL_18;
    }
  }
LABEL_21:
  if ( yt >= 0 )
  {
    last_tag_to_move = renderer_context_0.last_tag_to_move;
    v14 = 0;
    p_tags = (int)&document->tags;
    while ( 1 )
    {
      last_tag_to_move = last_tag_to_move->next;
      if ( last_tag_to_move == (tag *)p_tags )
        break;
      while ( 1 )
      {
        v16 = last_tag_to_move->y;
        v17 = part->box.y;
        if ( v16 == v17 + yf )
          break;
        if ( v14 || v16 > v17 + yf )
          goto LABEL_38;
        renderer_context_0.last_tag_to_move = last_tag_to_move;
        last_tag_to_move = last_tag_to_move->next;
        p_tags = (int)&part->document->tags;
        if ( last_tag_to_move == (tag *)p_tags )
          return;
      }
      if ( last_tag_to_move->x >= part->box.x + xf )
      {
        last_tag_to_move->y = yt + v17;
        last_tag_to_move->x += xt - xf;
        p_tags = (int)&part->document->tags;
      }
LABEL_38:
      v14 = 1;
    }
  }
}

//----- (0808E560) --------------------------------------------------------
void __usercall del_chars(html_context *html_context@<eax>, int x@<edx>, int y@<ecx>)
{
  part *part; // ebx
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+18h] [ebp-20h]
  html_context *v8; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_9;
  assert_failed = html_context == 0;
  if ( !html_context )
  {
    v7 = x;
    v5 = y;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 804;
    elinks_internal("assertion html_context failed!");
    html_context = 0;
    x = v7;
    y = v5;
    if ( assert_failed )
      goto LABEL_9;
  }
  part = html_context->part;
  if ( part && part->document && part->document->data )
  {
    assert_failed = 0;
LABEL_7:
    part->document->data[y + part->box.y].length = x + part->box.x;
    move_links(html_context, x, y, -1, -1);
    return;
  }
  v8 = html_context;
  v6 = x;
  v4 = y;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
  errline = 809;
  elinks_internal("assertion part && part->document && part->document->data failed!");
  x = v6;
  y = v4;
  html_context = v8;
  if ( !assert_failed )
    goto LABEL_7;
LABEL_9:
  assert_failed = 0;
}

//----- (0808E690) --------------------------------------------------------
void *__usercall mem_align_alloc__@<eax>(
        void **ptr@<eax>,
        size_t old@<edx>,
        size_t a3@<ecx>,
        size_t objsize,
        size_t mask)
{
  size_t v6; // ecx
  size_t v7; // esi
  void *result; // eax
  char *v9; // edx
  size_t v10; // [esp+1Ch] [ebp-1Ch]

  v6 = ~mask & (mask + a3);
  v7 = ~mask & (old + mask);
  if ( v6 <= v7 )
    return *ptr;
  v10 = objsize * v6;
  v9 = (char *)mem_realloc(*ptr, objsize * v6);
  result = 0;
  if ( v9 )
  {
    *ptr = v9;
    memset(&v9[objsize * v7], 0, v10 - objsize * v7);
    return *ptr;
  }
  return result;
}

//----- (0808E710) --------------------------------------------------------
int __usercall realloc_line_0@<eax>(
        html_context *html_context@<eax>,
        document *document@<edx>,
        int y@<ecx>,
        int length)
{
  line *v6; // ebx
  int v7; // esi
  screen_char *v9; // eax
  color_mode color_mode; // edx
  screen_char *i; // edx
  screen_char *v12; // [esp+14h] [ebp-34h]
  color_pair pair; // [esp+28h] [ebp-20h] BYREF

  if ( !realloc_lines(document, y) )
    return -1;
  v6 = &document->data[y];
  v7 = v6->length;
  if ( v7 > length )
    return v7;
  if ( !mem_align_alloc__((void **)&v6->chars, v6->length, length + 1, 8u, 0xFu) )
    return -1;
  v9 = &v6->chars[length];
  v9->data = 32;
  v9->attr = 0;
  color_mode = document->options.color_mode;
  v12 = v9;
  pair.background = *((_DWORD *)html_context->stack.next + 37);
  pair.foreground = 0;
  set_term_color(v9, &pair, COLOR_ENSURE_CONTRAST, color_mode);
  for ( i = &v6->chars[v6->length]; v12 > i; ++i )
  {
    i->data = v12->data;
    *(_DWORD *)&i->attr = *(_DWORD *)&v12->attr;
  }
  v6->length = length + 1;
  return v7;
}

//----- (0808E800) --------------------------------------------------------
void __cdecl draw_frame_hchars(
        part *part,
        int x,
        int y,
        int width,
        unsigned __int8 data,
        color_T bgcolor,
        color_T fgcolor,
        html_context *html_context)
{
  int v8; // esi
  html_context *v9; // eax
  int v10; // edi
  line *v11; // edx
  screen_char *v12; // edi
  color_mode color_mode; // edx
  color_flags color_flags; // ecx
  int v15; // eax
  screen_char *v16; // eax
  html_context *v17; // [esp+14h] [ebp-34h]
  int v18; // [esp+1Ch] [ebp-2Ch]
  color_pair pair; // [esp+28h] [ebp-20h] BYREF

  v8 = x;
  v9 = html_context;
  if ( assert_failed )
    goto LABEL_8;
  assert_failed = width <= 0;
  if ( width <= 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 296;
    elinks_internal("assertion width > 0 failed!");
    v9 = html_context;
    if ( assert_failed )
      goto LABEL_8;
  }
  assert_failed = v9 == 0;
  if ( !v9 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 267;
    elinks_internal("assertion html_context failed!");
    v9 = 0;
    if ( assert_failed )
      goto LABEL_8;
  }
  v10 = x + width - 1;
  if ( part && v10 >= 0 && part->document && y >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 270;
    v17 = v9;
    elinks_internal("assertion part && part->document && x >= 0 && y >= 0 failed!");
    v9 = v17;
    if ( assert_failed )
    {
LABEL_8:
      assert_failed = 0;
      return;
    }
  }
  if ( realloc_line_0(v9, part->document, part->box.y + y, v10 + part->box.x) >= 0 )
  {
    if ( assert_failed )
      goto LABEL_8;
    v11 = part->document->data;
    assert_failed = v11 == 0;
    if ( !v11 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 276;
      elinks_internal("assertion part->document->data failed!");
      if ( assert_failed )
        goto LABEL_8;
    }
    v12 = &part->document->data[part->box.y + y].chars[part->box.x + v10];
    v12->attr = 0x80;
    v12->data = data;
    color_mode = part->document->options.color_mode;
    color_flags = part->document->options.color_flags;
    pair.background = bgcolor;
    pair.foreground = fgcolor;
    set_term_color(v12, &pair, color_flags, color_mode);
    v18 = width - 1;
    if ( width != 1 )
    {
      do
      {
        v15 = v8 + part->box.x;
        ++v8;
        v16 = &part->document->data[part->box.y + y].chars[v15];
        v16->data = v12->data;
        *(_DWORD *)&v16->attr = *(_DWORD *)&v12->attr;
        --v18;
      }
      while ( v18 );
    }
  }
}

//----- (0808EA60) --------------------------------------------------------
void __cdecl expand_lines(html_context *html_context, part *part, int x, int y, int lines, color_T bgcolor)
{
  int i; // esi
  int v7; // ecx

  if ( assert_failed )
    goto LABEL_12;
  if ( !part || !part->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 185;
    elinks_internal("assertion part && part->document failed!");
    if ( !assert_failed )
      goto LABEL_5;
LABEL_12:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_5:
  if ( part->document->options.color_mode )
  {
    if ( part->document->options.use_document_colors == 2 )
    {
      *((_DWORD *)html_context->stack.next + 37) = bgcolor;
      if ( lines > 0 )
      {
        for ( i = 0; i < lines; ++i )
        {
          v7 = i + y + part->box.y;
          realloc_line_0(html_context, part->document, v7, part->box.x + x);
        }
      }
    }
  }
}

//----- (0808EB40) --------------------------------------------------------
void __usercall align_line(html_context *html_context@<eax>, int y@<edx>, int last@<ecx>)
{
  part *part; // edx
  int v7; // eax
  _DWORD *next; // edx
  int v9; // ecx
  int v10; // edi
  int v11; // edi
  part *v12; // edx
  line *v13; // ecx
  int v14; // eax
  void *v15; // eax
  part *v16; // ecx
  document *document; // edx
  part *v18; // edi
  line *data; // edx
  int length; // eax
  int v21; // edx
  int v22; // eax
  color_mode v23; // eax
  int v24; // ebx
  _DWORD *v25; // ecx
  color_mode v26; // eax
  int v27; // eax
  bool v28; // zf
  int v29; // eax
  screen_char *v30; // edx
  screen_char *v31; // eax
  int v32; // ecx
  int v33; // ebx
  int v34; // esi
  int v35; // eax
  unicode_val_T *v36; // ecx
  char *v37; // edx
  char *v38; // eax
  screen_char *v39; // eax
  int nlinks; // eax
  int v41; // ecx
  link *v42; // esi
  int npoints; // ebx
  char **v44; // edx
  char *v45; // eax
  char *v46; // ecx
  int v47; // eax
  int v48; // edx
  screen_char *v49; // [esp+48h] [ebp-70h]
  part *v50; // [esp+4Ch] [ebp-6Ch]
  part *v51; // [esp+4Ch] [ebp-6Ch]
  int v52; // [esp+4Ch] [ebp-6Ch]
  part *v53; // [esp+4Ch] [ebp-6Ch]
  screen_char *v54; // [esp+4Ch] [ebp-6Ch]
  int v55; // [esp+4Ch] [ebp-6Ch]
  html_context *v56; // [esp+50h] [ebp-68h]
  __int32 v57; // [esp+54h] [ebp-64h]
  char *v58; // [esp+5Ch] [ebp-5Ch]
  char *v59; // [esp+60h] [ebp-58h]
  int v60; // [esp+64h] [ebp-54h]
  int v61; // [esp+68h] [ebp-50h]
  int v62; // [esp+6Ch] [ebp-4Ch]
  char *v63; // [esp+70h] [ebp-48h]
  _DWORD *p; // [esp+74h] [ebp-44h]
  int v65; // [esp+78h] [ebp-40h]
  document *src; // [esp+7Ch] [ebp-3Ch]
  int srca; // [esp+7Ch] [ebp-3Ch]
  int n; // [esp+80h] [ebp-38h]
  _DWORD *na; // [esp+80h] [ebp-38h]
  void *dest; // [esp+84h] [ebp-34h]
  html_context *desta; // [esp+84h] [ebp-34h]
  int destb; // [esp+84h] [ebp-34h]
  char *destc; // [esp+84h] [ebp-34h]
  part *color_mode; // [esp+88h] [ebp-30h]
  part *color_modea; // [esp+88h] [ebp-30h]
  color_mode color_modeb; // [esp+88h] [ebp-30h]
  color_mode color_moded; // [esp+88h] [ebp-30h]
  color_mode color_modec; // [esp+88h] [ebp-30h]
  signed int v79; // [esp+8Ch] [ebp-2Ch]
  int v80; // [esp+8Ch] [ebp-2Ch]
  size_t v81; // [esp+8Ch] [ebp-2Ch]
  signed int v82; // [esp+8Ch] [ebp-2Ch]
  color_pair pair; // [esp+98h] [ebp-20h] BYREF

  if ( assert_failed )
    goto LABEL_31;
  assert_failed = html_context == 0;
  if ( !html_context )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1160;
    elinks_internal("assertion html_context failed!");
    if ( assert_failed )
      goto LABEL_31;
  }
  part = html_context->part;
  if ( part && part->document && part->document->data )
  {
    assert_failed = 0;
  }
  else
  {
    v51 = html_context->part;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1165;
    elinks_internal("assertion part && part->document && part->document->data failed!");
    part = v51;
    if ( assert_failed )
      goto LABEL_31;
  }
  v7 = part->document->data[y + part->box.y].length - part->box.x;
  if ( v7 <= 0 )
    return;
  next = html_context->stack.next;
  v9 = next[29];
  if ( !v9 )
    return;
  if ( v9 == 3 )
  {
    if ( last )
      return;
    assert_failed = 0;
    v18 = html_context->part;
    if ( v18 && v18->document && (data = v18->document->data) != 0 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 1026;
      elinks_internal("assertion part && part->document && part->document->data failed!");
      if ( assert_failed )
        goto LABEL_31;
      data = v18->document->data;
    }
    length = data[y + v18->box.y].length;
    v21 = 0;
    v22 = length - v18->box.x;
    if ( v22 >= 0 )
      v21 = v22;
    assert_failed = v21 <= 0;
    if ( v21 <= 0 )
    {
      v55 = v21;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 1030;
      elinks_internal("assertion len > 0 failed!");
      v21 = v55;
      if ( assert_failed )
        goto LABEL_31;
    }
    v52 = v21;
    v80 = 8 * v21;
    p = mem_alloc(8 * v21);
    if ( p )
    {
      na = mem_alloc(4 * v52 + 4);
      if ( na )
      {
        memcpy(p, &v18->document->data[y + v18->box.y].chars[v18->box.x], v80);
        color_modeb = COLOR_MODE_MONO;
        v81 = -1;
        if ( *p == 32 )
        {
          v23 = COLOR_MODE_MONO;
          do
            ++v23;
          while ( p[2 * v23] == 32 );
          color_modeb = v23;
          v81 = v23 - 1;
        }
        *na = v81;
        if ( v52 <= color_modeb )
        {
          na[1] = v52;
        }
        else
        {
          desta = html_context;
          v24 = 1;
          v25 = &p[2 * color_modeb];
          v26 = color_modeb;
          do
          {
            if ( *v25 == 32 )
              na[v24++] = v26;
            ++v26;
            v25 += 2;
          }
          while ( v26 < v52 );
          v62 = v24;
          na[v24] = v52;
          v32 = 0;
          if ( *((_DWORD *)desta->stack.next + 32) - *((_DWORD *)desta->stack.next + 31) >= 0 )
            v32 = *((_DWORD *)desta->stack.next + 32) - *((_DWORD *)desta->stack.next + 31);
          v61 = v32 - v52;
          if ( v32 - v52 > 0
            && v24 > 1
            && realloc_line_0(desta, desta->part->document, y + v18->box.y, v18->box.x + v32) )
          {
            v65 = 0;
            srca = 0;
            v82 = 0;
            v60 = v24 - 1;
            v56 = desta;
            color_modec = y;
            while ( 1 )
            {
              if ( assert_failed
                || (v33 = na[v82] + 1, v34 = na[v82 + 1] - v33, assert_failed = (unsigned int)v34 >> 31, v34 < 0)
                && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
                    errline = 1098,
                    elinks_internal("assertion word_len >= 0 failed!"),
                    assert_failed) )
              {
                assert_failed = 0;
                v63 = (char *)srca;
              }
              else
              {
                destb = v33 + v65 / v60;
                v63 = (char *)(v34 + destb);
                v35 = 0;
                if ( v18->document->data[v18->box.y + color_modec].length - v18->box.x >= 0 )
                  v35 = v18->document->data[v18->box.y + color_modec].length - v18->box.x;
                assert_failed = v35 < (int)v63;
                if ( v35 < (int)v63
                  && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
                      errline = 1107,
                      elinks_internal("assertion LEN(y) >= new_start + word_len failed!"),
                      assert_failed) )
                {
                  assert_failed = 0;
                  v63 = (char *)srca;
                }
                else
                {
                  memcpy(&v18->document->data[v18->box.y + color_modec].chars[v18->box.x + destb], &p[2 * v33], 8 * v34);
                  if ( v82 )
                  {
                    if ( destb > srca )
                    {
                      v36 = &p[2 * v33 - 2];
                      v37 = (char *)srca;
                      do
                      {
                        v38 = &v37[v18->box.x];
                        ++v37;
                        v39 = &v18->document->data[v18->box.y + color_modec].chars[(_DWORD)v38];
                        v39->data = *v36;
                        *(_DWORD *)&v39->attr = v36[1];
                      }
                      while ( destb > (int)v37 );
                    }
                    v58 = (char *)(destb + ~srca);
                    if ( v58 )
                    {
                      move_links(v56, srca + 1, color_modec, destb, color_modec);
                      nlinks = v18->document->nlinks;
                      v59 = (char *)(v18->box.x + destb);
                      v57 = v18->box.y + color_modec;
                      v41 = nlinks - 1;
LABEL_90:
                      if ( nlinks )
                      {
                        --nlinks;
                        v42 = &v18->document->links[v41];
                        npoints = v42->npoints;
                        for ( destc = (char *)(8 * npoints - 8); ; destc -= 8 )
                        {
                          if ( npoints <= 1 )
                          {
                            --v41;
                            goto LABEL_90;
                          }
                          --npoints;
                          v44 = (char **)((char *)v42->points + (unsigned int)destc);
                          if ( v59 == *v44 && (char *)v57 == v44[1] )
                            break;
                        }
                        if ( mem_align_alloc__((void **)&v42->points, v42->npoints, (size_t)&v58[v42->npoints], 8u, 0) )
                        {
                          v45 = &v58[v42->npoints];
                          v42->npoints = (int)v45;
                          v46 = v59;
                          v47 = (int)&v42->points[(int)v45 - 1];
                          v48 = 0;
                          do
                          {
                            *(_DWORD *)(v47 + 8 * v48) = --v46;
                            *(_DWORD *)(v47 + 8 * v48-- + 4) = v57;
                          }
                          while ( &v58[v48] );
                        }
                      }
                    }
                  }
                }
              }
              ++v82;
              v65 += v61;
              if ( v82 >= v62 )
                break;
              srca = (int)v63;
            }
          }
        }
        mem_free(na);
        mem_free(p);
      }
      else
      {
        mem_free(p);
      }
    }
    return;
  }
  v10 = 0;
  if ( next[32] - next[31] >= 0 )
    v10 = next[32] - next[31];
  v11 = v10 - v7;
  if ( next[29] == 1 )
    v11 /= 2;
  if ( v11 <= 0 )
    return;
  assert_failed = 0;
  v12 = html_context->part;
  if ( v12 )
  {
    if ( v12->document )
    {
      v13 = v12->document->data;
      if ( v13 )
      {
        assert_failed = 0;
        goto LABEL_19;
      }
    }
  }
  v53 = html_context->part;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
  errline = 782;
  elinks_internal("assertion part && part->document && part->document->data failed!");
  v12 = v53;
  if ( assert_failed )
  {
LABEL_31:
    assert_failed = 0;
    return;
  }
  v13 = v53->document->data;
LABEL_19:
  v14 = v13[y + v12->box.y].length - v12->box.x;
  if ( v14 < 0 )
    v14 = 0;
  v50 = v12;
  v79 = v14;
  n = 8 * v14;
  v15 = mem_alloc(8 * v14);
  dest = v15;
  if ( v15 )
  {
    memcpy(v15, &v50->document->data[y + v50->box.y].chars[v50->box.x], n);
    if ( assert_failed )
      goto LABEL_26;
    assert_failed = 0;
    v16 = html_context->part;
    color_mode = v16;
    if ( v16 && (document = v16->document) != 0 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 236;
      elinks_internal("assertion part && part->document && width > 0 failed!");
      if ( assert_failed )
      {
LABEL_26:
        assert_failed = 0;
        color_modea = html_context->part;
        if ( v79 > 0 )
        {
          if ( html_context->part )
          {
            src = color_modea->document;
            if ( color_modea->document )
            {
              if ( color_modea->document->data )
              {
                assert_failed = 0;
                v27 = realloc_line_0(html_context, src, color_modea->box.y + y, v11 + v79 + color_modea->box.x - 1);
                goto LABEL_60;
              }
            }
          }
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 741;
        elinks_internal("assertion width > 0 && part && part->document && part->document->data failed!");
        if ( !assert_failed )
        {
          v27 = realloc_line_0(
                  html_context,
                  color_modea->document,
                  color_modea->box.y + y,
                  v11 + v79 + color_modea->box.x - 1);
LABEL_60:
          if ( v27 >= 0 )
            memcpy(&color_modea->document->data[y + color_modea->box.y].chars[v11 + color_modea->box.x], dest, n);
          goto LABEL_29;
        }
LABEL_28:
        assert_failed = 0;
LABEL_29:
        mem_free(dest);
        move_links(html_context, 0, y, v11, y);
        return;
      }
      document = color_mode->document;
    }
    if ( realloc_line_0(html_context, document, y + color_mode->box.y, v11 + color_mode->box.x - 1) >= 0 )
    {
      if ( assert_failed )
        goto LABEL_26;
      v28 = color_mode->document->data != 0;
      assert_failed = color_mode->document->data == 0;
      if ( !v28 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 242;
        elinks_internal("assertion part->document->data failed!");
        if ( assert_failed )
          goto LABEL_26;
      }
      v29 = (int)&color_mode->document->data[y + color_mode->box.y].chars[color_mode->box.x];
      v30 = (screen_char *)(v29 + 8 * v11 - 8);
      v30->data = 32;
      v30->attr = 0;
      color_moded = color_mode->document->options.color_mode;
      v49 = (screen_char *)v29;
      v54 = v30;
      pair.background = *((_DWORD *)html_context->stack.next + 37);
      pair.foreground = 0;
      set_term_color(v30, &pair, COLOR_ENSURE_CONTRAST, color_moded);
      v31 = v49;
      if ( v49 < v54 )
      {
        while ( 1 )
        {
          v31->data = v54->data;
          *(_DWORD *)&v31->attr = *(_DWORD *)&v54->attr;
          if ( v54 <= &v31[1] )
            break;
          ++v31;
        }
      }
    }
    if ( assert_failed )
      goto LABEL_28;
    goto LABEL_26;
  }
}

//----- (0808F5C0) --------------------------------------------------------
void __cdecl line_break(html_context *html_context)
{
  part *part; // ebx
  int v2; // eax
  int cx; // eax
  line *v4; // edx
  int v5; // ecx
  tag *i; // eax
  size_t spaces_len; // edx
  unsigned __int8 *spaces; // eax
  int v9; // [esp+1Ch] [ebp-2Ch]
  int y; // [esp+24h] [ebp-24h]
  int x; // [esp+28h] [ebp-20h]

  if ( !assert_failed )
  {
    assert_failed = html_context == 0;
    if ( html_context
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
          errline = 1699,
          elinks_internal("assertion html_context failed!"),
          !assert_failed) )
    {
      part = html_context->part;
      assert_failed = part == 0;
      if ( part
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
            errline = 1704,
            elinks_internal("assertion part failed!"),
            !assert_failed) )
      {
        v2 = part->cx + *((_DWORD *)html_context->stack.next + 31);
        if ( v2 > part->box.width )
          part->box.width = v2;
        if ( (*((_BYTE *)&renderer_context_0 + 48) & 2) != 0 )
        {
          *((_BYTE *)&renderer_context_0 + 48) &= ~2u;
          part->cx = -1;
          part->xa = 0;
          return;
        }
        if ( part->document && part->document->data )
        {
          if ( !realloc_lines(part->document, part->cy + part->box.height + 1) )
            return;
          cx = part->cx;
          if ( cx > *((_DWORD *)html_context->stack.next + 30) )
          {
            y = part->cy;
            v4 = &part->document->data[part->box.y + y];
            x = cx - 1;
            v9 = part->box.x;
            v5 = 0;
            if ( v4->length - v9 >= 0 )
              v5 = v4->length - v9;
            if ( x < v5 && v4->chars[x + v9].data == 32 )
            {
              del_chars(html_context, x, y);
              cx = part->cx - 1;
              part->cx = cx;
            }
          }
          if ( cx > 0 )
            align_line(html_context, part->cy, 1);
          for ( i = renderer_context_0.last_tag_for_newline; i; i = i->prev )
          {
            if ( (tag *)&part->document->tags == i )
              break;
            i->x = part->box.x;
            i->y = part->cy + part->box.y + 1;
          }
        }
        spaces_len = part->spaces_len;
        ++part->cy;
        spaces = part->spaces;
        part->cx = -1;
        part->xa = 0;
        memset(spaces, 0, spaces_len);
        memset(part->char_width, 0, part->spaces_len);
        return;
      }
    }
  }
  assert_failed = 0;
}

//----- (0808F800) --------------------------------------------------------
void free_table_cache()
{
  hash *v0; // eax
  int v1; // ebx
  list_head_elinks *i; // edi

  v0 = table_cache;
  if ( table_cache )
  {
    if ( 1 << table_cache->width > 0 )
    {
      v1 = 0;
      do
      {
        for ( i = (list_head_elinks *)v0->hash[v1].next; &v0->hash[v1] != i; i = (list_head_elinks *)i->next )
        {
          if ( i[2].next )
          {
            mem_free(i[2].next);
            v0 = table_cache;
          }
        }
        ++v1;
      }
      while ( 1 << v0->width > v1 );
    }
    free_hash(&table_cache);
    table_cache_entries = 0;
  }
}

//----- (0808F890) --------------------------------------------------------
part *__cdecl format_html_part(
        html_context *html_context,
        unsigned __int8 *start,
        unsigned __int8 *end,
        int align,
        int margin,
        int width,
        document *document,
        int x,
        int y,
        unsigned __int8 *head,
        int link_num)
{
  _DWORD *v11; // eax
  int v12; // edx
  int v13; // ebx
  int v14; // ecx
  void *next; // ecx
  part *v16; // eax
  part *v17; // ebx
  int v18; // eax
  part *result; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // esi
  unsigned int i; // eax
  _DWORD *value; // eax
  void *state; // [esp+28h] [ebp-50h]
  tag *saved_last_tag_to_move; // [esp+2Ch] [ebp-4Ch]
  int saved_margin; // [esp+30h] [ebp-48h]
  int saved_last_link_to_move; // [esp+34h] [ebp-44h]
  hash_item *item; // [esp+38h] [ebp-40h]
  char v29; // [esp+3Fh] [ebp-39h]
  table_cache_entry_key key; // [esp+44h] [ebp-34h] BYREF

  saved_last_tag_to_move = renderer_context_0.last_tag_to_move;
  v29 = *((_BYTE *)&renderer_context_0 + 48) & 1;
  saved_last_link_to_move = renderer_context_0.last_link_to_move;
  saved_margin = html_context->margin;
  if ( table_cache )
  {
    if ( !document )
    {
      for ( i = 0; i < 0x1C; i += 4 )
        *(unsigned __int8 **)((char *)&key.start + i) = 0;
      key.start = start;
      key.end = end;
      key.align = align;
      key.margin = margin;
      key.width = width;
      key.x = x;
      key.link_num = link_num;
      item = get_hash_item(table_cache, (unsigned __int8 *)&key, 0x1Cu);
      if ( item )
      {
        v17 = (part *)mem_alloc(0x34u);
        if ( v17 )
        {
          value = item->value;
          v17->document = (document *)value[9];
          v17->spaces = (unsigned __int8 *)value[10];
          v17->spaces_len = value[11];
          v17->char_width = (unsigned __int8 *)value[12];
          v17->box.x = value[13];
          v17->box.y = value[14];
          v17->box.width = value[15];
          v17->box.height = value[16];
          v17->max_width = value[17];
          v17->xa = value[18];
          v17->cx = value[19];
          v17->cy = value[20];
          v17->link_num = value[21];
          return v17;
        }
      }
    }
  }
  else
  {
    table_cache = init_hash8();
  }
  if ( assert_failed
    || (assert_failed = (unsigned int)y >> 31, y < 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
        errline = 2167,
        elinks_internal("assertion y >= 0 failed: format_html_part: y == %d", y),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  if ( document )
  {
    v11 = mem_alloc(0x18u);
    if ( v11 )
    {
      v12 = 0x7FFFFFFF;
      if ( html_context->table_level )
      {
        v12 = 0;
        if ( width >= 0 )
          v12 = width;
      }
      v13 = 0;
      v14 = x;
      if ( x < 0 )
        v14 = 0;
      v11[2] = v14;
      if ( y >= 0 )
        v13 = y;
      v11[4] = v12;
      v11[5] = 1;
      v11[3] = v13;
      next = document->nodes.next;
      v11[1] = &document->nodes;
      *v11 = next;
      document->nodes.next = v11;
      *(_DWORD *)(*v11 + 4) = v11;
    }
    renderer_context_0.last_link_to_move = document->nlinks;
    renderer_context_0.last_tag_to_move = (tag *)&document->tags;
    renderer_context_0.last_tag_for_newline = (tag *)&document->tags;
  }
  else
  {
    renderer_context_0.last_link_to_move = 0;
    renderer_context_0.last_tag_to_move = 0;
    renderer_context_0.last_tag_for_newline = 0;
  }
  html_context->margin = margin;
  *((_BYTE *)&renderer_context_0 + 48) = (document == 0) | *((_BYTE *)&renderer_context_0 + 48) & 0xFE;
  if ( renderer_context_0.link_state_info.link )
    mem_free(renderer_context_0.link_state_info.link);
  if ( renderer_context_0.link_state_info.target )
    mem_free(renderer_context_0.link_state_info.target);
  if ( renderer_context_0.link_state_info.image )
    mem_free(renderer_context_0.link_state_info.image);
  *((_BYTE *)&renderer_context_0 + 48) |= 2u;
  renderer_context_0.link_state_info.link = 0;
  renderer_context_0.link_state_info.target = 0;
  renderer_context_0.link_state_info.image = 0;
  renderer_context_0.link_state_info.form = 0;
  v16 = (part *)mem_calloc(1u, 0x34u);
  v17 = v16;
  if ( v16 )
  {
    v16->document = document;
    v16->box.x = x;
    v16->cx = -1;
    v16->cy = 0;
    v16->box.y = y;
    v16->link_num = link_num;
    state = init_html_parser_state(html_context, ELEMENT_IMMORTAL, align, margin, width);
    parse_html(start, end, v17, head, html_context);
    done_html_parser_state(html_context, state);
    v18 = v17->box.width;
    if ( v18 > v17->max_width )
      v17->max_width = v18;
    *((_BYTE *)&renderer_context_0 + 48) &= ~2u;
    if ( renderer_context_0.link_state_info.link )
      mem_free(renderer_context_0.link_state_info.link);
    if ( renderer_context_0.link_state_info.target )
      mem_free(renderer_context_0.link_state_info.target);
    if ( renderer_context_0.link_state_info.image )
      mem_free(renderer_context_0.link_state_info.image);
    renderer_context_0.link_state_info.link = 0;
    renderer_context_0.link_state_info.target = 0;
    renderer_context_0.link_state_info.image = 0;
    renderer_context_0.link_state_info.form = 0;
    if ( v17->spaces )
      mem_free(v17->spaces);
    if ( v17->char_width )
      mem_free(v17->char_width);
    if ( document )
      *((_DWORD *)document->nodes.next + 5) = v17->box.height + y - *((_DWORD *)document->nodes.next + 3);
  }
  renderer_context_0.last_link_to_move = saved_last_link_to_move;
  renderer_context_0.last_tag_to_move = saved_last_tag_to_move;
  *((_BYTE *)&renderer_context_0 + 48) = v29 | *((_BYTE *)&renderer_context_0 + 48) & 0xFE;
  html_context->margin = saved_margin;
  if ( document )
    return v17;
  if ( html_context->table_level <= 1 )
    return v17;
  if ( !table_cache )
    return v17;
  if ( table_cache_entries > 0x3FFF )
    return v17;
  v20 = (unsigned __int8 *)mem_calloc(1u, 0x58u);
  v21 = v20;
  if ( !v20 )
    return v17;
  *((_DWORD *)v20 + 2) = start;
  *((_DWORD *)v20 + 3) = end;
  *((_DWORD *)v20 + 4) = align;
  *((_DWORD *)v20 + 5) = margin;
  *((_DWORD *)v20 + 6) = width;
  *((_DWORD *)v20 + 7) = x;
  *((_DWORD *)v20 + 8) = link_num;
  *((_DWORD *)v20 + 9) = v17->document;
  *((_DWORD *)v20 + 10) = v17->spaces;
  *((_DWORD *)v20 + 11) = v17->spaces_len;
  *((_DWORD *)v20 + 12) = v17->char_width;
  *((_DWORD *)v20 + 13) = v17->box.x;
  *((_DWORD *)v20 + 14) = v17->box.y;
  *((_DWORD *)v20 + 15) = v17->box.width;
  *((_DWORD *)v20 + 16) = v17->box.height;
  *((_DWORD *)v20 + 17) = v17->max_width;
  *((_DWORD *)v20 + 18) = v17->xa;
  *((_DWORD *)v20 + 19) = v17->cx;
  *((_DWORD *)v20 + 20) = v17->cy;
  *((_DWORD *)v20 + 21) = v17->link_num;
  if ( !add_hash_item(table_cache, v20 + 8, 0x1Cu, v20) )
  {
    mem_free(v21);
    return v17;
  }
  result = v17;
  ++table_cache_entries;
  return result;
}

//----- (0808FDD0) --------------------------------------------------------
void __cdecl render_html_document(cache_entry *cached, document *document, string *buffer)
{
  unsigned __int8 *source; // edi
  document_options *options; // esi
  int height; // eax
  int v6; // edx
  int v7; // ecx
  line *data; // esi
  void *v9; // esi
  document *next; // eax
  int v11; // esi
  line *v12; // edi
  int width; // ecx
  int v14; // eax
  int length; // edx
  unsigned __int8 *end; // [esp+38h] [ebp-30h]
  unsigned __int8 *enda; // [esp+38h] [ebp-30h]
  html_context *html_context; // [esp+3Ch] [ebp-2Ch]
  string head; // [esp+40h] [ebp-28h] BYREF
  string title; // [esp+48h] [ebp-20h] BYREF

  if ( assert_failed
    || (assert_failed = cached == 0 || document == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
        errline = 2276,
        elinks_internal("assertion cached && document failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( init_string(&head) )
  {
    if ( cached->head )
      add_to_string(&head, cached->head);
    source = buffer->source;
    end = &buffer->source[buffer->length];
    html_context = init_html_parser(
                     cached->uri,
                     &document->options,
                     buffer->source,
                     end,
                     &head,
                     &title,
                     put_chars_conv,
                     line_break,
                     html_special);
    if ( html_context )
    {
      renderer_context_0.cached = cached;
      renderer_context_0.g_ctrl_num = 0;
      renderer_context_0.convert_table = get_convert_table(
                                           head.source,
                                           document->options.cp,
                                           document->options.assume_cp,
                                           &document->cp,
                                           &document->cp_status,
                                           document->options.hard_assume);
      options = html_context->options;
      *((_BYTE *)options + 92) = (16 * (is_cp_utf8(document->options.cp) & 1)) | *((_BYTE *)options + 92) & 0xEF;
      html_context->doc_cp = document->cp;
      if ( title.length )
        document->title = convert_string_elinks(
                            renderer_context_0.convert_table,
                            title.source,
                            title.length,
                            document->options.cp,
                            CSM_DEFAULT,
                            0,
                            0,
                            0);
      done_string(&title);
      enda = (unsigned __int8 *)format_html_part(
                                  html_context,
                                  source,
                                  end,
                                  *((_DWORD *)html_context->stack.next + 29),
                                  *((_DWORD *)html_context->stack.next + 30),
                                  document->options.box.width,
                                  document,
                                  0,
                                  0,
                                  head.source,
                                  1);
LABEL_10:
      height = document->height;
      v6 = 8 * height - 8;
      v7 = v6;
      while ( height )
      {
        data = document->data;
        if ( *(int *)((char *)&data->length + v7) )
          break;
        --height;
        v7 -= 8;
        document->height = height;
        v9 = *(screen_char **)((char *)&data->chars + v6);
        v6 -= 8;
        if ( v9 )
        {
          mem_free(v9);
          goto LABEL_10;
        }
      }
      v11 = document->height;
      document->width = 0;
      if ( v11 > 0 )
      {
        v12 = document->data;
        width = 0;
        v14 = 0;
        while ( 1 )
        {
          length = v12[v14].length;
          if ( width < length )
            document->width = length;
          if ( v11 <= ++v14 )
            break;
          width = document->width;
        }
      }
      *((_BYTE *)&document->options + 92) |= 2u;
      document->bgcolor = *((_DWORD *)html_context->stack.next + 37);
      done_html_parser(html_context);
      next = (document *)document->forms.next;
      if ( &document->forms != (list_head_elinks *)next )
      {
        if ( next->object.refcount )
        {
          while ( 1 )
          {
            next = next->next;
            if ( &document->forms == (list_head_elinks *)next )
              break;
            if ( !next->object.refcount )
              goto LABEL_17;
          }
        }
        else
        {
LABEL_17:
          if ( (int *)next->options.use_document_colors == &next->options.use_document_colors )
            done_form((form *)next);
        }
      }
      done_string(&head);
      if ( enda )
        mem_free(enda);
    }
  }
}

//----- (08090120) --------------------------------------------------------
void __cdecl draw_frame_vchars(
        part *part,
        int x,
        int y,
        int height,
        unsigned __int8 data,
        color_T bgcolor,
        color_T fgcolor,
        html_context *html_context)
{
  int v8; // edi
  line *v9; // esi
  screen_char *v10; // esi
  color_mode color_mode; // edx
  color_flags color_flags; // ecx
  screen_char *v13; // eax
  int v14; // [esp+1Ch] [ebp-2Ch]
  color_pair pair; // [esp+28h] [ebp-20h] BYREF

  v8 = y;
  if ( assert_failed )
    goto LABEL_6;
  assert_failed = html_context == 0;
  if ( !html_context )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 267;
    elinks_internal("assertion html_context failed!");
    if ( assert_failed )
      goto LABEL_6;
  }
  if ( part && x >= 0 && part->document && y >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 270;
    elinks_internal("assertion part && part->document && x >= 0 && y >= 0 failed!");
    if ( assert_failed )
    {
LABEL_6:
      assert_failed = 0;
      return;
    }
  }
  if ( realloc_line_0(html_context, part->document, y + part->box.y, part->box.x + x) >= 0 )
  {
    if ( assert_failed )
      goto LABEL_6;
    v9 = part->document->data;
    assert_failed = v9 == 0;
    if ( !v9 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 276;
      elinks_internal("assertion part->document->data failed!");
      if ( assert_failed )
        goto LABEL_6;
    }
    v10 = &part->document->data[y + part->box.y].chars[part->box.x + x];
    v10->attr = 0x80;
    v10->data = data;
    color_mode = part->document->options.color_mode;
    color_flags = part->document->options.color_flags;
    pair.background = bgcolor;
    pair.foreground = fgcolor;
    set_term_color(v10, &pair, color_flags, color_mode);
    v14 = height - 1;
    if ( height != 1 )
    {
      do
      {
        if ( realloc_line_0(html_context, part->document, ++v8 + part->box.y, part->box.x + x) < 0 )
          break;
        v13 = &part->document->data[v8 + part->box.y].chars[part->box.x + x];
        v13->data = v10->data;
        *(_DWORD *)&v13->attr = *(_DWORD *)&v10->attr;
        --v14;
      }
      while ( v14 );
    }
  }
}

//----- (08090330) --------------------------------------------------------
int __usercall split_line_at@<eax>(html_context *html_context@<eax>, int width@<edx>)
{
  size_t v4; // eax
  part *part; // ebx
  int v6; // eax
  int result; // eax
  _BOOL4 v8; // eax
  int v9; // eax
  part *v10; // edx
  line *data; // edx
  int *v12; // eax
  int v13; // edx
  int v14; // eax
  part *v15; // eax
  int v16; // eax
  int spaces_len; // edx
  signed int v18; // edx
  size_t v19; // ecx
  int v20; // eax
  signed int v21; // edx
  int cy; // eax
  int cx; // ecx
  int v24; // edx
  int v25; // edx
  bool v26; // cc
  line *v27; // ecx
  int v28; // edx
  bool v29; // zf
  line *v30; // edx
  line *v31; // eax
  int v32; // edx
  screen_char *chars; // eax
  part *v34; // eax
  part *v35; // eax
  document *v36; // [esp+1Ch] [ebp-5Ch]
  document *document; // [esp+2Ch] [ebp-4Ch]
  size_t nb; // [esp+38h] [ebp-40h]
  size_t nc; // [esp+38h] [ebp-40h]
  size_t nd; // [esp+38h] [ebp-40h]
  size_t nf; // [esp+38h] [ebp-40h]
  size_t n; // [esp+38h] [ebp-40h]
  size_t ne; // [esp+38h] [ebp-40h]
  size_t na; // [esp+38h] [ebp-40h]
  screen_char *v45; // [esp+3Ch] [ebp-3Ch]
  int v46; // [esp+40h] [ebp-38h]
  int v47; // [esp+40h] [ebp-38h]
  int yt; // [esp+44h] [ebp-34h]
  int yta; // [esp+44h] [ebp-34h]
  int x; // [esp+48h] [ebp-30h]
  int v51; // [esp+48h] [ebp-30h]
  int xt; // [esp+4Ch] [ebp-2Ch]
  int xta; // [esp+4Ch] [ebp-2Ch]
  part *v54; // [esp+50h] [ebp-28h]
  part *v55; // [esp+50h] [ebp-28h]
  int yf; // [esp+54h] [ebp-24h]
  int yfa; // [esp+54h] [ebp-24h]
  int yfb; // [esp+54h] [ebp-24h]
  int v59; // [esp+58h] [ebp-20h]
  part *v60; // [esp+58h] [ebp-20h]
  part *v61; // [esp+5Ch] [ebp-1Ch]
  int v62; // [esp+5Ch] [ebp-1Ch]
  line *v63; // [esp+5Ch] [ebp-1Ch]

  v4 = *((_DWORD *)html_context->stack.next + 31);
  if ( assert_failed )
    goto LABEL_7;
  assert_failed = 0;
  part = html_context->part;
  assert_failed = part == 0;
  if ( !part )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 836;
    nf = v4;
    elinks_internal("assertion part failed!");
    v4 = nf;
    if ( assert_failed )
      goto LABEL_7;
  }
  v6 = width + v4;
  if ( v6 > part->box.width )
    part->box.width = v6;
  if ( part->document )
  {
    if ( !assert_failed )
    {
      v8 = part->document->data == 0;
      assert_failed = v8;
      if ( !v8
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
            errline = 844,
            elinks_internal("assertion part->document->data failed!"),
            !assert_failed) )
      {
        if ( (*((_BYTE *)html_context->options + 92) & 0x10) != 0
          && width < part->spaces_len
          && part->char_width[width] == 2 )
        {
          yf = part->cy;
          v9 = *((_DWORD *)html_context->stack.next + 30);
          assert_failed = 0;
          xt = v9;
          v10 = html_context->part;
          v61 = v10;
          if ( v10 && v10->document && (data = v10->document->data) != 0 )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 760;
            elinks_internal("assertion part && part->document && part->document->data failed!");
            if ( assert_failed )
            {
              assert_failed = 0;
              goto LABEL_28;
            }
            data = v61->document->data;
          }
          v12 = (int *)&data[v61->box.y + yf];
          x = v61->box.x;
          v13 = v12[1] - x;
          if ( v13 < 0 )
            v13 = 0;
          v59 = v13 - width;
          if ( v13 - width <= 0 )
            goto LABEL_28;
          yt = yf + 1;
          v14 = *v12;
          assert_failed = 0;
          v46 = v14;
          v15 = html_context->part;
          v54 = v15;
          if ( v15 && (document = v15->document) != 0 && v15->document->data )
          {
            assert_failed = 0;
            v16 = realloc_line_0(html_context, document, v15->box.y + yt, v59 + v15->box.x + xt - 1);
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 741;
            elinks_internal("assertion width > 0 && part && part->document && part->document->data failed!");
            if ( assert_failed )
            {
              assert_failed = 0;
LABEL_27:
              v61->document->data[v61->box.y + yf].length = width + v61->box.x;
              move_links(html_context, width, yf, xt, yt);
LABEL_28:
              del_chars(html_context, width, part->cy);
              goto LABEL_29;
            }
            v16 = realloc_line_0(html_context, v54->document, v54->box.y + yt, v59 + v54->box.x + xt - 1);
          }
          if ( v16 >= 0 )
            memcpy(
              &v54->document->data[v54->box.y + yt].chars[v54->box.x + xt],
              (const void *)(v46 + 8 * (width + x)),
              8 * v59);
          goto LABEL_27;
        }
        v27 = part->document->data;
        v28 = width + part->box.x;
        v29 = v27[part->box.y + part->cy].chars[v28].data == 32;
        assert_failed = v27[part->box.y + part->cy].chars[v28].data != 32;
        if ( v29 )
        {
          yfa = part->cy;
          v47 = yfa + 1;
          xta = width + 1;
          yta = *((_DWORD *)html_context->stack.next + 30);
        }
        else
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 855;
          elinks_internal(
            "assertion POS(width, part->cy).data == ' ' failed: bad split: %c",
            part->document->data[part->box.y + part->cy].chars[width + part->box.x].data);
          yfa = part->cy;
          yta = *((_DWORD *)html_context->stack.next + 30);
          if ( assert_failed )
            goto LABEL_74;
          xta = width + 1;
          v47 = yfa + 1;
        }
        assert_failed = 0;
        v60 = html_context->part;
        if ( v60 )
        {
          if ( v60->document )
          {
            v30 = v60->document->data;
            if ( v30 )
            {
              assert_failed = 0;
              goto LABEL_51;
            }
          }
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 760;
        elinks_internal("assertion part && part->document && part->document->data failed!");
        if ( !assert_failed )
        {
          v30 = v60->document->data;
LABEL_51:
          v31 = &v30[v60->box.y + yfa];
          v51 = v60->box.x;
          v32 = v31->length - v51;
          if ( v32 < 0 )
            v32 = 0;
          v62 = v32 - xta;
          if ( v32 - xta > 0 )
          {
            chars = v31->chars;
            assert_failed = 0;
            v45 = chars;
            v34 = html_context->part;
            v55 = v34;
            if ( v34 && (v36 = v34->document) != 0 && v34->document->data )
            {
              assert_failed = 0;
            }
            else
            {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 741;
              elinks_internal("assertion width > 0 && part && part->document && part->document->data failed!");
              if ( assert_failed )
              {
                assert_failed = 0;
                goto LABEL_60;
              }
              v36 = v55->document;
            }
            if ( realloc_line_0(html_context, v36, v55->box.y + v47, v62 + yta + v55->box.x - 1) >= 0 )
              memcpy(&v55->document->data[v55->box.y + v47].chars[v55->box.x + yta], &v45[v51 + xta], 8 * v62);
LABEL_60:
            v60->document->data[v60->box.y + yfa].length = v60->box.x + xta;
            move_links(html_context, xta, yfa, yta, v47);
            yfb = part->cy;
            if ( assert_failed )
              goto LABEL_61;
LABEL_76:
            assert_failed = 0;
            v35 = html_context->part;
            if ( v35 && v35->document && (v63 = v35->document->data) != 0 )
            {
              assert_failed = 0;
            }
            else
            {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 809;
              na = (size_t)v35;
              elinks_internal("assertion part && part->document && part->document->data failed!");
              v35 = (part *)na;
              if ( assert_failed )
              {
LABEL_61:
                assert_failed = 0;
                if ( (*((_BYTE *)html_context->options + 92) & 0x10) == 0 )
                  goto LABEL_30;
                goto LABEL_42;
              }
              v63 = *(line **)(*(_DWORD *)na + 208);
            }
            v63[v35->box.y + yfb].length = width + v35->box.x;
            move_links(html_context, width, yfb, -1, -1);
            if ( (*((_BYTE *)html_context->options + 92) & 0x10) == 0 )
              goto LABEL_30;
            goto LABEL_42;
          }
LABEL_75:
          yfb = part->cy;
          goto LABEL_76;
        }
LABEL_74:
        assert_failed = 0;
        goto LABEL_75;
      }
    }
LABEL_7:
    assert_failed = 0;
    return 0;
  }
LABEL_29:
  if ( (*((_BYTE *)html_context->options + 92) & 0x10) == 0 )
  {
LABEL_30:
    spaces_len = part->spaces_len;
LABEL_31:
    ++width;
    goto LABEL_32;
  }
LABEL_42:
  spaces_len = part->spaces_len;
  if ( width >= spaces_len || part->char_width[width] != 2 )
    goto LABEL_31;
LABEL_32:
  v18 = spaces_len - width;
  if ( v18 > 0 )
  {
    nb = v18;
    memmove(part->spaces, &part->spaces[width], v18);
    memmove(part->char_width, &part->char_width[width], nb);
    v18 = nb;
  }
  if ( assert_failed )
  {
LABEL_63:
    assert_failed = 0;
    v19 = 0;
    goto LABEL_36;
  }
  v19 = v18;
  assert_failed = (unsigned int)v18 >> 31;
  if ( v18 < 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 878;
    n = v18;
    elinks_internal("assertion tmp >= 0 failed!");
    if ( !assert_failed )
    {
      v19 = n;
      goto LABEL_36;
    }
    goto LABEL_63;
  }
LABEL_36:
  nc = v19;
  memset(&part->spaces[v19], 0, width);
  memset(&part->char_width[nc], 0, width);
  v20 = *((_DWORD *)html_context->stack.next + 30);
  if ( v20 > 0 )
  {
    v21 = part->spaces_len - v20;
    if ( !assert_failed )
    {
      assert_failed = v21 <= 0;
      if ( v21 <= 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 887;
        ne = v21;
        elinks_internal("assertion tmp > 0 failed: part->spaces_len - par_format.leftmargin == %d", v21);
        v21 = ne;
      }
      v20 = *((_DWORD *)html_context->stack.next + 30);
    }
    nd = v21;
    memmove(&part->spaces[v20], part->spaces, v21);
    memmove(&part->char_width[*((_DWORD *)html_context->stack.next + 30)], part->char_width, nd);
  }
  cy = part->cy;
  cx = part->cx;
  v24 = cy + 1;
  part->cy = cy + 1;
  if ( cx == width )
  {
    v26 = v24 <= part->box.height;
    result = 2;
    part->cx = -1;
    if ( !v26 )
      part->box.height = v24;
  }
  else
  {
    v25 = cy + 2;
    result = 1;
    v26 = v25 <= part->box.height;
    part->cx = *((_DWORD *)html_context->stack.next + 30) + cx - width;
    if ( !v26 )
      part->box.height = v25;
  }
  return result;
}

//----- (08090C70) --------------------------------------------------------
void __cdecl put_chars(html_context *html_context, unsigned __int8 *chars, int charslen)
{
  html_context *v3; // ebx
  part *v4; // ecx
  int v5; // eax
  _DWORD *v6; // edx
  const unsigned __int8 *v7; // eax
  _DWORD *v8; // eax
  void *v9; // edx
  text_style_format v10; // eax
  document_options *options; // edx
  bool v12; // dl
  int v13; // eax
  _BOOL4 v14; // esi
  int v15; // edi
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // ecx
  const unsigned __int16 *v18; // ecx
  int v19; // eax
  part *v20; // edi
  _DWORD *v21; // eax
  const char *v22; // edi
  const char *v23; // esi
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  int v27; // esi
  int v28; // ecx
  part *v29; // edi
  bool v30; // zf
  int v31; // edi
  unsigned int v32; // eax
  unsigned int v33; // edi
  int v34; // edx
  int v35; // edi
  const unsigned __int8 *v36; // edx
  unsigned __int8 *v37; // eax
  const unsigned __int8 *v38; // edx
  unsigned __int8 *v39; // eax
  void *v40; // eax
  int v41; // edx
  int v42; // eax
  _DWORD *v43; // eax
  int v44; // edx
  int cx; // ecx
  part *v46; // edi
  _DWORD *v47; // eax
  int v48; // ecx
  int v49; // edx
  int v50; // eax
  int v51; // ecx
  int v52; // esi
  int v53; // edx
  int v54; // esi
  _DWORD *v55; // eax
  int v56; // eax
  int v57; // eax
  int v58; // esi
  _DWORD *v59; // edx
  int v60; // esi
  int v61; // edx
  void *next; // eax
  int v63; // edx
  unsigned __int8 *v64; // ecx
  int nlinks; // edi
  int v66; // edx
  int v67; // ecx
  unsigned int v68; // edi
  int v69; // edx
  _DWORD *v70; // eax
  unsigned __int8 *v71; // esi
  _DWORD *v72; // eax
  int v73; // ecx
  int v74; // eax
  int v75; // ecx
  unsigned __int8 *v76; // ecx
  int v77; // eax
  _DWORD *v78; // eax
  part *v79; // esi
  int v80; // edx
  unsigned int v81; // eax
  int v82; // eax
  int v83; // edx
  unsigned int v84; // esi
  unsigned int v85; // edi
  unsigned int v86; // edi
  unsigned int v87; // eax
  unsigned __int8 *v88; // esi
  unicode_val_T v89; // ebx
  bool v90; // dl
  unicode_val_T v91; // eax
  char v92; // cl
  unsigned int v93; // eax
  unicode_val_T v94; // eax
  char v95; // si
  char v96; // dl
  unsigned __int8 *v97; // eax
  unsigned __int8 v98; // dl
  char v99; // bl
  unsigned __int8 *v100; // edx
  unsigned __int8 *v101; // ecx
  unsigned __int8 *v102; // eax
  int v103; // ecx
  unsigned __int8 *i; // eax
  int v105; // eax
  const unsigned __int8 *v106; // eax
  unsigned __int8 *v107; // eax
  int v108; // eax
  _DWORD *v109; // eax
  _DWORD *v110; // eax
  _DWORD *v111; // eax
  _DWORD *v112; // edi
  _DWORD *v113; // eax
  _DWORD *v114; // edi
  _DWORD *v115; // eax
  _DWORD *v116; // edi
  _DWORD *v117; // eax
  _DWORD *v118; // edi
  _DWORD *v119; // eax
  _DWORD *v120; // edi
  _DWORD *v121; // eax
  _DWORD *v122; // edi
  _DWORD *v123; // eax
  _DWORD *v124; // edi
  int v125; // edi
  document *v126; // esi
  unsigned __int8 *v127; // eax
  unsigned __int8 v128; // cl
  int v129; // edx
  unsigned __int8 v130; // bl
  unicode_val_T v131; // esi
  bool v132; // dl
  unsigned __int8 *v133; // edi
  screen_char *v134; // eax
  void *v135; // edi
  unsigned __int8 *v136; // esi
  unicode_val_T v137; // edx
  unicode_val_T *v138; // eax
  unsigned __int8 *v139; // ecx
  char *v140; // eax
  char *v141; // eax
  char *v142; // eax
  screen_char *v143; // eax
  char v144; // al
  const unsigned __int8 *v145; // edx
  unsigned __int8 *v146; // eax
  _BYTE *v147; // eax
  const unsigned __int8 *v148; // edx
  unsigned __int8 *v149; // eax
  char *v150; // eax
  text_style v151; // [esp+8h] [ebp-F0h]
  int v152; // [esp+4Ch] [ebp-ACh]
  int v153; // [esp+4Ch] [ebp-ACh]
  int v154; // [esp+4Ch] [ebp-ACh]
  int v155; // [esp+4Ch] [ebp-ACh]
  int v156; // [esp+4Ch] [ebp-ACh]
  int v157; // [esp+4Ch] [ebp-ACh]
  int v158; // [esp+4Ch] [ebp-ACh]
  int v159; // [esp+4Ch] [ebp-ACh]
  int v160; // [esp+4Ch] [ebp-ACh]
  int v161; // [esp+4Ch] [ebp-ACh]
  int v162; // [esp+4Ch] [ebp-ACh]
  int v163; // [esp+4Ch] [ebp-ACh]
  int v164; // [esp+4Ch] [ebp-ACh]
  int v165; // [esp+4Ch] [ebp-ACh]
  int v166; // [esp+4Ch] [ebp-ACh]
  int v167; // [esp+4Ch] [ebp-ACh]
  bool v168; // [esp+50h] [ebp-A8h]
  int v169; // [esp+50h] [ebp-A8h]
  unsigned __int8 *v170; // [esp+50h] [ebp-A8h]
  size_t v171; // [esp+50h] [ebp-A8h]
  bool v172; // [esp+50h] [ebp-A8h]
  bool v173; // [esp+50h] [ebp-A8h]
  int v174; // [esp+50h] [ebp-A8h]
  html_context *v175; // [esp+58h] [ebp-A0h]
  unsigned __int8 attr; // [esp+58h] [ebp-A0h]
  int v177; // [esp+5Ch] [ebp-9Ch]
  int link_num; // [esp+5Ch] [ebp-9Ch]
  int v179; // [esp+5Ch] [ebp-9Ch]
  unsigned __int8 *v180; // [esp+60h] [ebp-98h]
  unsigned __int8 *v181; // [esp+60h] [ebp-98h]
  unsigned __int8 *v182; // [esp+60h] [ebp-98h]
  unsigned __int8 *v183; // [esp+64h] [ebp-94h]
  unsigned __int8 *v184; // [esp+64h] [ebp-94h]
  unsigned __int8 *v185; // [esp+64h] [ebp-94h]
  unsigned __int8 *v186; // [esp+64h] [ebp-94h]
  unsigned __int8 *v187; // [esp+68h] [ebp-90h]
  int v188; // [esp+68h] [ebp-90h]
  unsigned __int8 *v189; // [esp+6Ch] [ebp-8Ch]
  link_state link_state; // [esp+70h] [ebp-88h]
  form_control *link_statea; // [esp+70h] [ebp-88h]
  link_state link_stateb; // [esp+70h] [ebp-88h]
  link_state link_statec; // [esp+70h] [ebp-88h]
  unsigned __int8 *end; // [esp+74h] [ebp-84h]
  unsigned __int8 *enda; // [esp+74h] [ebp-84h]
  unsigned __int8 *endb; // [esp+74h] [ebp-84h]
  unsigned __int8 *endc; // [esp+74h] [ebp-84h]
  unsigned __int8 *src; // [esp+78h] [ebp-80h]
  unsigned __int8 *srca; // [esp+78h] [ebp-80h]
  unsigned __int8 *srcb; // [esp+78h] [ebp-80h]
  unsigned __int8 *srcc; // [esp+78h] [ebp-80h]
  unsigned __int8 *srcd; // [esp+78h] [ebp-80h]
  part *part; // [esp+7Ch] [ebp-7Ch]
  __int64 v204; // [esp+8Ch] [ebp-6Ch]
  unsigned __int8 *string; // [esp+94h] [ebp-64h] BYREF
  unsigned int slen; // [esp+98h] [ebp-60h] BYREF
  char s[64]; // [esp+9Ch] [ebp-5Ch] BYREF
  unsigned int v208; // [esp+DCh] [ebp-1Ch]

  v208 = __readgsdword(0x14u);
  v3 = html_context;
  v189 = chars;
  if ( assert_failed )
    goto LABEL_43;
  assert_failed = html_context == 0;
  if ( !html_context )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1578;
    elinks_internal("assertion html_context failed!");
    if ( assert_failed )
      goto LABEL_43;
  }
  v4 = html_context->part;
  part = v4;
  assert_failed = v4 == 0;
  if ( !v4 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1583;
    elinks_internal("assertion part failed!");
    if ( assert_failed )
      goto LABEL_43;
  }
  assert_failed = chars == 0 || charslen == 0;
  if ( chars == 0 || charslen == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1586;
    elinks_internal("assertion chars && charslen failed!");
    if ( assert_failed )
    {
LABEL_43:
      assert_failed = 0;
      return;
    }
  }
  if ( part->cx == -1 )
  {
    next = html_context->stack.next;
    if ( (*((_BYTE *)next + 12) & 0x20) == 0 )
    {
      if ( !charslen )
        return;
      if ( *chars == 32 )
      {
        v63 = charslen;
        v64 = chars;
        while ( --v63 )
        {
          if ( *++v64 != 32 )
          {
            v189 = v64;
            charslen = v63;
            goto LABEL_129;
          }
        }
        return;
      }
LABEL_129:
      if ( charslen <= 0 )
        return;
    }
    part->cx = *((_DWORD *)next + 30);
    if ( (*((_BYTE *)html_context->stack.next + 12) & 0x20) != 0 )
      goto LABEL_7;
  }
  else if ( (*((_BYTE *)html_context->stack.next + 12) & 0x20) != 0 )
  {
LABEL_7:
    renderer_context_0.last_tag_for_newline = (tag *)&part->document->tags;
    goto LABEL_8;
  }
  if ( charslen > 0 )
  {
    v18 = *__ctype_b_loc();
    v19 = 0;
    while ( (v18[v189[v19]] & 0x2000) != 0 )
    {
      if ( charslen <= ++v19 )
        goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_8:
  v5 = part->cy + 1;
  if ( v5 > part->box.height )
    part->box.height = v5;
  v6 = html_context->stack.next;
  v7 = (const unsigned __int8 *)v6[7];
  if ( v7 || v6[9] || (link_state = LINK_STATE_NONE, v6[11]) )
  {
    if ( !renderer_context_0.link_state_info.link && !renderer_context_0.link_state_info.image )
    {
      link_state = LINK_STATE_NEW;
      if ( !renderer_context_0.link_state_info.form )
        goto LABEL_16;
    }
    if ( !xstrcmp(v7, renderer_context_0.link_state_info.link)
      && !xstrcmp(*((const unsigned __int8 **)html_context->stack.next + 8), renderer_context_0.link_state_info.target)
      && !xstrcmp(*((const unsigned __int8 **)html_context->stack.next + 9), renderer_context_0.link_state_info.image) )
    {
      v8 = html_context->stack.next;
      link_state = LINK_STATE_SAME;
      if ( (form_control *)v8[11] == renderer_context_0.link_state_info.form )
        goto LABEL_23;
    }
    link_state = LINK_STATE_NEW;
  }
  if ( renderer_context_0.link_state_info.link )
    mem_free(renderer_context_0.link_state_info.link);
LABEL_16:
  if ( renderer_context_0.link_state_info.target )
    mem_free(renderer_context_0.link_state_info.target);
  if ( renderer_context_0.link_state_info.image )
    mem_free(renderer_context_0.link_state_info.image);
  renderer_context_0.link_state_info.link = 0;
  renderer_context_0.link_state_info.target = 0;
  renderer_context_0.link_state_info.image = 0;
  renderer_context_0.link_state_info.form = 0;
  if ( link_state != LINK_STATE_NEW )
    goto LABEL_21;
  v77 = 0;
  if ( charslen <= 0 )
    goto LABEL_180;
  if ( *v189 <= 0x20u )
  {
    do
      ++v77;
    while ( charslen > v77 && v189[v77] <= 0x20u );
LABEL_180:
    if ( v77 == charslen )
    {
LABEL_21:
      link_state = LINK_STATE_NONE;
LABEL_22:
      v8 = html_context->stack.next;
      goto LABEL_23;
    }
  }
  if ( (*((_BYTE *)html_context->options + 69) & 0x10) == 0 )
    goto LABEL_22;
  v78 = html_context->stack.next;
  v79 = html_context->part;
  srcd = (unsigned __int8 *)v78[7];
  endb = (unsigned __int8 *)v78[8];
  v186 = (unsigned __int8 *)v78[9];
  v80 = v78[11];
  slen = 0;
  v78[9] = 0;
  v78[8] = 0;
  v78[7] = 0;
  *((_DWORD *)html_context->stack.next + 11) = 0;
  v81 = slen;
  s[slen] = 91;
  slen = v81 + 1;
  v169 = v80;
  elinks_ulongcat((unsigned __int8 *)s, &slen, v79->link_num, 0x3Du, 0, 0xAu, 0);
  v82 = slen;
  *((_BYTE *)&renderer_context_0 + 48) |= 4u;
  s[slen] = 93;
  slen = ++v82;
  s[v82] = 0;
  put_chars(html_context, (unsigned __int8 *)s, v82);
  v83 = v169;
  *((_BYTE *)&renderer_context_0 + 48) &= ~4u;
  if ( v169 && *(_DWORD *)(v169 + 20) == 3 )
  {
    line_break(html_context);
    v83 = v169;
  }
  if ( v79->cx == -1 )
    v79->cx = *((_DWORD *)html_context->stack.next + 30);
  *((_DWORD *)html_context->stack.next + 7) = srcd;
  *((_DWORD *)html_context->stack.next + 8) = endb;
  *((_DWORD *)html_context->stack.next + 9) = v186;
  *((_DWORD *)html_context->stack.next + 11) = v83;
  v8 = html_context->stack.next;
LABEL_23:
  slen = (unsigned int)v189;
  src = (unsigned __int8 *)html_context->part;
  if ( memcmp(&ta_cache_8356, v8 + 3, 0xCu) )
  {
    ta_cache_8356 = v8[3];
    dword_8141184 = v8[4];
    dword_8141188 = v8[5];
    v9 = html_context->stack.next;
    v10 = *((_DWORD *)v9 + 3);
    v204 = *((_QWORD *)v9 + 2);
    if ( link_state )
    {
      options = html_context->options;
      if ( (*((_BYTE *)options + 69) & 1) != 0 )
        v10 |= 4u;
    }
    else
    {
      options = html_context->options;
    }
    v151.attr = v10;
    *(_QWORD *)&v151.fg = v204;
    get_screen_char_template(&schar_cache_8357, options, v151);
  }
  if ( ((*((_BYTE *)&renderer_context_0 + 48) & 4) != 0) != (schar_cache_8357.attr & 1) )
    schar_cache_8357.attr ^= 1u;
  v187 = (unsigned __int8 *)*((_DWORD *)src + 10);
  end = (unsigned __int8 *)*((_DWORD *)src + 11);
  v12 = (*((_BYTE *)html_context->options + 92) & 0x10) != 0;
  if ( assert_failed )
  {
    assert_failed = 0;
    v188 = charslen;
    goto LABEL_51;
  }
  assert_failed = (unsigned int)charslen >> 31;
  if ( charslen < 0 )
  {
    v168 = v12;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 375;
    elinks_internal("assertion charslen >= 0 failed!");
    v12 = v168;
  }
  v183 = &v187[charslen];
  v13 = *((_DWORD *)src + 2);
  if ( (int)&v187[charslen] >= v13 )
  {
    v84 = (unsigned int)&v187[charslen + 127] & 0xFFFFFF80;
    v85 = (v13 + 127) & 0xFFFFFF80;
    if ( v84 > v85 )
    {
      v172 = v12;
      v141 = (char *)mem_realloc(*((void **)src + 1), v84);
      if ( !v141 )
        goto LABEL_243;
      *((_DWORD *)src + 1) = v141;
      memset(&v141[v85], 0, v84 - v85);
      v12 = v172;
    }
    if ( !*((_DWORD *)src + 1) )
      goto LABEL_243;
    v86 = (*((_DWORD *)src + 2) + 127) & 0xFFFFFF80;
    if ( v84 > v86 )
    {
      v173 = v12;
      v142 = (char *)mem_realloc(*((void **)src + 3), v84);
      if ( !v142 )
        goto LABEL_243;
      *((_DWORD *)src + 3) = v142;
      memset(&v142[v86], 0, v84 - v86);
      v12 = v173;
    }
    if ( !*((_DWORD *)src + 3) )
    {
LABEL_243:
      v188 = 0;
      goto LABEL_51;
    }
    *((_DWORD *)src + 2) = v183;
  }
  v14 = v12;
  if ( *(_DWORD *)src )
  {
    v177 = realloc_line_0(
             html_context,
             *(document **)src,
             (int)&end[*((_DWORD *)src + 5)],
             (int)&v187[*((_DWORD *)src + 4) + charslen]);
    if ( v177 >= 0 )
    {
      if ( v14 )
      {
        v93 = slen;
        v182 = (unsigned __int8 *)(slen + charslen);
        v183 = v187;
        if ( *(_BYTE *)(*(_DWORD *)src + 243) )
        {
          v125 = utf8charlen((const unsigned __int8 *)(*(_DWORD *)src + 236));
          string = (unsigned __int8 *)(*(_DWORD *)src + 236);
          v126 = *(document **)src;
          v127 = (unsigned __int8 *)slen;
          v128 = *(_BYTE *)(*(_DWORD *)src + 243);
          v129 = v128;
          if ( v125 > v128 && (unsigned int)v182 > slen )
          {
            while ( 1 )
            {
              v130 = *v127;
              ++v128;
              ++v127;
              v126->buf[v129] = v130;
              v129 = v128;
              slen = (unsigned int)v127;
              if ( v125 <= v128 || v182 <= v127 )
                break;
              v126 = *(document **)src;
            }
            v3 = html_context;
            v126 = *(document **)src;
          }
          v126->buf_length = v128;
          *(_BYTE *)(v129 + *(_DWORD *)src + 236) = 0;
          v131 = utf8_to_unicode(&string, &string[v128]);
          if ( v131 == -3 )
          {
            *(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208) + 8 * (_DWORD)&end[*((_DWORD *)src + 5)] + 4) = v177;
            v188 = 0;
            goto LABEL_51;
          }
          *(_BYTE *)(*(_DWORD *)src + 243) = 0;
          v183 = v187;
LABEL_290:
          if ( v131 != 173 )
          {
            if ( v131 == 160 )
            {
              v144 = *((_BYTE *)v3->options + 69) & 2;
              v132 = v144 != 0;
              if ( v144 )
                v131 = 32;
            }
            else
            {
              v132 = v131 == 32;
            }
            v183[*((_DWORD *)src + 1)] = v132;
            if ( unicode_to_cell(v131) == 2 )
            {
              schar_cache_8357.data = v131;
              v183[*((_DWORD *)src + 3)] = 2;
              v143 = (screen_char *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208)
                                               + 8 * (_DWORD)&end[*((_DWORD *)src + 5)])
                                   + 8 * (_DWORD)&v183[*((_DWORD *)src + 4)]);
              ++v183;
              *v143 = schar_cache_8357;
              schar_cache_8357.data = -3;
              v183[*((_DWORD *)src + 1)] = 0;
              v183[*((_DWORD *)src + 3)] = 0;
            }
            else
            {
              v133 = &v183[*((_DWORD *)src + 3)];
              *v133 = unicode_to_cell(v131);
              schar_cache_8357.data = v131;
            }
            v134 = (screen_char *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208) + 8
                                                                                 * (_DWORD)&end[*((_DWORD *)src + 5)])
                                 + 8 * (_DWORD)&(v183++)[*((_DWORD *)src + 4)]);
            *v134 = schar_cache_8357;
          }
          v93 = slen;
        }
        if ( (unsigned int)v182 > v93 )
        {
          while ( 1 )
          {
            v94 = utf8_to_unicode((unsigned __int8 **)&slen, v182);
            if ( v94 != -3 )
            {
              v131 = v94;
              goto LABEL_290;
            }
            v183[*((_DWORD *)src + 1)] = 0;
            if ( charslen != 1 )
              break;
            attr = schar_cache_8357.attr;
            v137 = *(unsigned __int8 *)slen;
            schar_cache_8357.attr = 0x80;
            ++slen;
            schar_cache_8357.data = v137;
            v138 = (unicode_val_T *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208)
                                               + 8 * (_DWORD)&end[*((_DWORD *)src + 5)])
                                   + 8 * (_DWORD)&v183[*((_DWORD *)src + 4)]);
            *v138 = v137;
            v138[1] = *(_DWORD *)&schar_cache_8357.attr;
            schar_cache_8357.attr = attr;
            v183[*((_DWORD *)src + 3)] = 0;
            v139 = ++v183;
            if ( (unsigned int)v182 <= slen )
            {
              v188 = v139 - v187;
              goto LABEL_225;
            }
          }
          v95 = slen;
          v96 = 0;
          v97 = (unsigned __int8 *)slen;
          if ( (unsigned int)v182 > slen )
          {
            v175 = v3;
            do
            {
              v98 = (_BYTE)v97 - v95;
              v99 = *v97++;
              *(_BYTE *)(*(_DWORD *)src + v98 + 236) = v99;
              slen = (unsigned int)v97;
            }
            while ( v182 > v97 );
            v3 = v175;
            v96 = (_BYTE)v182 - v95;
          }
          *(_BYTE *)(*(_DWORD *)src + 243) = v96;
          v188 = v183 - v187;
          goto LABEL_225;
        }
      }
      else
      {
        v15 = charslen;
        v16 = v187;
        if ( charslen <= 0 )
        {
          v183 = v187;
          v188 = 0;
LABEL_225:
          if ( !assert_failed )
          {
            v100 = &v183[*((_DWORD *)src + 4)];
            v101 = &end[*((_DWORD *)src + 5)];
            v30 = (int)v100 <= *(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208) + 8 * (_DWORD)v101 + 4);
            assert_failed = (int)v100 > *(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208) + 8 * (_DWORD)v101 + 4);
            if ( !v30 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
              errline = 518;
              elinks_internal("assertion X(x) <= LINE(y).length failed!");
            }
          }
          v102 = &v183[*((_DWORD *)src + 4)];
          if ( (int)v102 < v177 )
            v102 = (unsigned __int8 *)v177;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208) + 8 * (_DWORD)&end[*((_DWORD *)src + 5)] + 4) = v102;
          goto LABEL_51;
        }
        do
        {
          v16[*((_DWORD *)src + 3)] = 1;
          if ( *(_BYTE *)slen == 1 )
          {
            schar_cache_8357.data = 32;
            v16[*((_DWORD *)src + 1)] = (*((_BYTE *)html_context->options + 69) & 2) != 0;
          }
          else
          {
            v16[*((_DWORD *)src + 1)] = *(_BYTE *)slen == 32;
            schar_cache_8357.data = *(unsigned __int8 *)slen;
          }
          --v15;
          v17 = &v16[*((_DWORD *)src + 4)];
          ++v16;
          *(screen_char *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)src + 208) + 8 * (_DWORD)&end[*((_DWORD *)src + 5)])
                         + 8 * (_DWORD)v17) = schar_cache_8357;
          ++slen;
        }
        while ( v15 > 0 );
      }
      v188 = v183 - v187;
      goto LABEL_225;
    }
    goto LABEL_243;
  }
  if ( v12 )
  {
    v87 = slen;
    v88 = v187;
    endc = (unsigned __int8 *)(slen + charslen);
    while ( (unsigned int)endc > v87 )
    {
      v91 = utf8_to_unicode((unsigned __int8 **)&slen, endc);
      if ( v91 != 173 )
      {
        if ( v91 == 160 )
        {
          v89 = 32;
          v92 = *((_BYTE *)html_context->options + 69) & 2;
          v90 = v92 != 0;
          if ( !v92 )
            v89 = 160;
        }
        else
        {
          v89 = v91;
          v90 = v91 == 32;
        }
        v88[*((_DWORD *)src + 1)] = v90;
        v170 = &v88[*((_DWORD *)src + 3)];
        *v170 = unicode_to_cell(v89);
        if ( v88[*((_DWORD *)src + 3)] == 2 )
        {
          ++v88;
          v88[*((_DWORD *)src + 1)] = 0;
          v88[*((_DWORD *)src + 3)] = 0;
        }
        if ( v89 == -3 )
          break;
        ++v88;
      }
      v87 = slen;
    }
    v3 = html_context;
    v188 = v88 - v187;
  }
  else
  {
    v103 = charslen;
    if ( charslen > 0 )
    {
      for ( i = v187; ; ++i )
      {
        i[*((_DWORD *)src + 3)] = 1;
        i[*((_DWORD *)src + 1)] = *(_BYTE *)slen == 1 ? (*((_BYTE *)html_context->options + 69) & 2) != 0 : *(_BYTE *)slen == 32;
        ++slen;
        if ( !--v103 )
          break;
      }
    }
    v188 = charslen;
  }
LABEL_51:
  if ( link_state )
  {
    v20 = v3->part;
    enda = (unsigned __int8 *)v20;
    if ( link_state == LINK_STATE_SAME )
    {
      if ( !v20->document )
        goto LABEL_83;
      if ( assert_failed )
        goto LABEL_82;
      nlinks = v20->document->nlinks;
      assert_failed = nlinks <= 0;
      if ( nlinks <= 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
        errline = 1446;
        elinks_internal("assertion part->document->nlinks > 0 failed: no link");
        if ( assert_failed )
          goto LABEL_82;
      }
      v66 = *(_DWORD *)(*(_DWORD *)enda + 212) + 52 * (*(_DWORD *)(*(_DWORD *)enda + 260) - 1);
      srcb = (unsigned __int8 *)v66;
      if ( *(_DWORD *)(v66 + 4) <= 1u
        && (v135 = *(void **)(v66 + 48)) != 0
        && (v136 = straconcat((const unsigned __int8 *)v135, v189, 0)) != 0 )
      {
        mem_free(v135);
        *((_DWORD *)srcb + 12) = v136;
        v27 = 0;
        v67 = v188;
      }
      else
      {
        v67 = v188;
        v27 = 0;
      }
LABEL_142:
      v68 = *((_DWORD *)srcb + 7);
      if ( v67 + v68 > v68 )
      {
        v171 = 8 * (v67 + v68);
        v164 = v67;
        v140 = (char *)mem_realloc(*((void **)srcb + 6), v171);
        if ( !v140 )
          goto LABEL_83;
        *((_DWORD *)srcb + 6) = v140;
        memset(&v140[8 * v68], 0, v171 - 8 * v68);
        v67 = v164;
      }
      v179 = *((_DWORD *)srcb + 6);
      if ( v179 )
      {
        link_statec = *((_DWORD *)srcb + 7);
        v185 = (unsigned __int8 *)*((_DWORD *)enda + 4);
        v181 = (unsigned __int8 *)*((_DWORD *)enda + 10);
        v69 = *((_DWORD *)enda + 5) + *((_DWORD *)enda + 11);
        *((_DWORD *)srcb + 7) = v67 + link_statec;
        if ( v67 > 0 )
        {
          v70 = (_DWORD *)(v179 + 8 * link_statec);
          v71 = &v181[(_DWORD)v185 + v27];
          do
          {
            *v70 = v71++;
            v70[1] = v69;
            v70 += 2;
            --v67;
          }
          while ( v67 );
        }
      }
      goto LABEL_83;
    }
    ++v20->link_num;
    v21 = v3->stack.next;
    link_statea = (form_control *)v21[11];
    srca = (unsigned __int8 *)v21[9];
    v22 = (const char *)v21[8];
    v23 = (const char *)v21[7];
    if ( !assert_failed )
    {
      assert_failed = renderer_context_0.link_state_info.image != 0;
      if ( !renderer_context_0.link_state_info.image
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
            errline = 1406,
            elinks_internal(
              "assertion !(renderer_context.link_state_info.image) failed: Old link value [%s]. New value [%s]",
              (const char *)renderer_context_0.link_state_info.image,
              (const char *)srca),
            !assert_failed) )
      {
        assert_failed = renderer_context_0.link_state_info.target != 0;
        if ( !renderer_context_0.link_state_info.target
          || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c",
              errline = 1407,
              elinks_internal(
                "assertion !(renderer_context.link_state_info.target) failed: Old link value [%s]. New value [%s]",
                (const char *)renderer_context_0.link_state_info.target,
                v22),
              !assert_failed) )
        {
          assert_failed = renderer_context_0.link_state_info.link != 0;
          if ( renderer_context_0.link_state_info.link )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
            errline = 1408;
            elinks_internal(
              "assertion !(renderer_context.link_state_info.link) failed: Old link value [%s]. New value [%s]",
              (const char *)renderer_context_0.link_state_info.link,
              v23);
          }
        }
      }
    }
    v24 = 0;
    if ( v23 )
      v24 = stracpy((const unsigned __int8 *)v23);
    renderer_context_0.link_state_info.link = v24;
    v25 = 0;
    if ( v22 )
      v25 = stracpy((const unsigned __int8 *)v22);
    renderer_context_0.link_state_info.target = v25;
    v26 = 0;
    if ( srca )
      v26 = stracpy(srca);
    renderer_context_0.link_state_info.image = v26;
    renderer_context_0.link_state_info.form = link_statea;
    if ( !*(_DWORD *)enda )
      goto LABEL_83;
    if ( charslen <= 0 || *v189 > 0x20u )
    {
      v27 = 0;
      v28 = v188;
      v180 = (unsigned __int8 *)charslen;
      v184 = v189;
    }
    else
    {
      v27 = 0;
      do
        ++v27;
      while ( charslen > v27 && v189[v27] <= 0x20u );
      if ( v27 )
      {
        v180 = (unsigned __int8 *)(charslen - v27);
        v184 = &v189[v27];
        v28 = v188 - v27;
      }
      else
      {
        v28 = v188;
        v180 = (unsigned __int8 *)charslen;
        v184 = v189;
      }
    }
    if ( assert_failed )
      goto LABEL_82;
    assert_failed = 0;
    v29 = v3->part;
    assert_failed = v29 == 0;
    if ( !v29 )
    {
      v163 = v28;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 1231;
      elinks_internal("assertion part failed!");
      v28 = v163;
      if ( assert_failed )
        goto LABEL_82;
    }
    link_stateb = (link_state)v29->document;
    v30 = v29->document != 0;
    assert_failed = v29->document == 0;
    if ( !v30 )
    {
      v154 = v28;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 1236;
      elinks_internal("assertion document failed!");
      v28 = v154;
      if ( assert_failed )
      {
LABEL_82:
        assert_failed = 0;
        goto LABEL_83;
      }
    }
    link_num = v29->link_num;
    v31 = *(_DWORD *)(link_stateb + 260);
    v32 = (v31 + 128) & 0xFFFFFF80;
    v33 = (v31 + 127) & 0xFFFFFF80;
    if ( v32 > v33 )
    {
      v174 = 52 * v32;
      v167 = v28;
      v150 = (char *)mem_realloc(*(void **)(link_stateb + 212), 52 * v32);
      if ( !v150 )
        goto LABEL_83;
      *(_DWORD *)(link_stateb + 212) = v150;
      memset(&v150[52 * v33], 0, v174 - 52 * v33);
      v28 = v167;
    }
    v34 = *(_DWORD *)(link_stateb + 212);
    if ( v34 )
    {
      v35 = *(_DWORD *)(link_stateb + 260);
      srcb = (unsigned __int8 *)(v34 + 52 * v35);
      *(_DWORD *)(link_stateb + 260) = v35 + 1;
      *((_DWORD *)srcb + 8) = link_num - 1;
      if ( (*(_BYTE *)(link_stateb + 81) & 0x20) != 0 )
        *((_DWORD *)srcb + 8) = *((_DWORD *)v3->stack.next + 20) + link_num - 1;
      *(_DWORD *)srcb = *((_DWORD *)v3->stack.next + 21);
      v36 = (const unsigned __int8 *)*((_DWORD *)v3->stack.next + 10);
      v37 = 0;
      if ( v36 )
      {
        v152 = v28;
        v37 = stracpy(v36);
        v28 = v152;
      }
      *((_DWORD *)srcb + 5) = v37;
      v38 = (const unsigned __int8 *)*((_DWORD *)v3->stack.next + 9);
      v39 = 0;
      if ( v38 )
      {
        v153 = v28;
        v39 = stracpy(v38);
        v28 = v153;
      }
      *((_DWORD *)srcb + 4) = v39;
      v40 = v3->stack.next;
      v41 = *((_DWORD *)v40 + 11);
      if ( v41 )
      {
        switch ( *(_DWORD *)(v41 + 20) )
        {
          case 0:
          case 1:
          case 2:
            *((_DWORD *)srcb + 1) = 5;
            break;
          case 3:
            *((_DWORD *)srcb + 1) = 6;
            break;
          case 4:
          case 5:
            *((_DWORD *)srcb + 1) = 3;
            break;
          case 6:
            *((_DWORD *)srcb + 1) = 4;
            break;
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0xB:
            *((_DWORD *)srcb + 1) = 2;
            break;
          default:
            break;
        }
        *((_DWORD *)srcb + 12) = v41;
        v105 = *(_DWORD *)(v41 + 8);
        if ( (v105 || (v105 = *(_DWORD *)(link_stateb + 148), v105 != link_stateb + 148) && v105)
          && (v106 = *(const unsigned __int8 **)(v105 + 28)) != 0 )
        {
          v155 = v28;
          v107 = stracpy(v106);
          v28 = v155;
        }
        else
        {
          v107 = 0;
        }
        *((_DWORD *)srcb + 3) = v107;
      }
      else
      {
        v145 = (const unsigned __int8 *)*((_DWORD *)v40 + 8);
        v146 = 0;
        if ( v145 )
        {
          v165 = v28;
          v146 = stracpy(v145);
          v28 = v165;
        }
        *((_DWORD *)srcb + 3) = v146;
        v166 = v28;
        *((_DWORD *)srcb + 12) = memacpy(v184, (int)v180);
        v28 = v166;
        v147 = (_BYTE *)*((_DWORD *)v3->stack.next + 7);
        if ( v147
          && (*v147 | 0x20) == 109
          && (v147[1] | 0x20) == 97
          && (v147[2] | 0x20) == 112
          && v147[3] == 64
          && v147[4] )
        {
          *((_DWORD *)srcb + 1) = 1;
          *((_DWORD *)srcb + 2) = stracpy((const unsigned __int8 *)(*((_DWORD *)v3->stack.next + 7) + 4));
          v28 = v166;
        }
        else
        {
          *((_DWORD *)srcb + 1) = 0;
          v148 = (const unsigned __int8 *)*((_DWORD *)v3->stack.next + 7);
          v149 = 0;
          if ( v148 )
          {
            v149 = stracpy(v148);
            v28 = v166;
          }
          *((_DWORD *)srcb + 2) = v149;
        }
      }
      *((_DWORD *)srcb + 9) = *((_DWORD *)v3->stack.next + 5);
      if ( (unsigned int)(*((_DWORD *)srcb + 1) - 5) <= 1 )
        v108 = *((_DWORD *)v3->stack.next + 4);
      else
        v108 = *((_DWORD *)v3->stack.next + 12);
      *((_DWORD *)srcb + 10) = v108;
      v156 = v28;
      v109 = mem_calloc(1u, 8u);
      *((_DWORD *)srcb + 11) = v109;
      v67 = v156;
      if ( v109 )
      {
        v109[1] = v109;
        *v109 = v109;
        v110 = v3->stack.next;
        if ( v110[22] )
        {
          v111 = mem_calloc(1u, 0x10u);
          v67 = v156;
          v112 = v111;
          if ( v111 )
          {
            v111[2] = 0;
            v111[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 22));
            *v112 = **((_DWORD **)srcb + 11);
            v112[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v112;
            *(_DWORD *)(*v112 + 4) = v112;
            v110 = v3->stack.next;
            v67 = v156;
          }
          else
          {
            v110 = v3->stack.next;
          }
        }
        if ( v110[23] )
        {
          v157 = v67;
          v113 = mem_calloc(1u, 0x10u);
          v67 = v157;
          v114 = v113;
          if ( v113 )
          {
            v113[2] = 1;
            v113[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 23));
            *v114 = **((_DWORD **)srcb + 11);
            v114[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v114;
            *(_DWORD *)(*v114 + 4) = v114;
            v110 = v3->stack.next;
            v67 = v157;
          }
          else
          {
            v110 = v3->stack.next;
          }
        }
        if ( v110[24] )
        {
          v158 = v67;
          v115 = mem_calloc(1u, 0x10u);
          v67 = v158;
          v116 = v115;
          if ( v115 )
          {
            v115[2] = 2;
            v115[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 24));
            *v116 = **((_DWORD **)srcb + 11);
            v116[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v116;
            *(_DWORD *)(*v116 + 4) = v116;
            v110 = v3->stack.next;
            v67 = v158;
          }
          else
          {
            v110 = v3->stack.next;
          }
        }
        if ( v110[25] )
        {
          v159 = v67;
          v117 = mem_calloc(1u, 0x10u);
          v67 = v159;
          v118 = v117;
          if ( v117 )
          {
            v117[2] = 3;
            v117[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 25));
            *v118 = **((_DWORD **)srcb + 11);
            v118[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v118;
            *(_DWORD *)(*v118 + 4) = v118;
            v110 = v3->stack.next;
            v67 = v159;
          }
          else
          {
            v110 = v3->stack.next;
          }
        }
        if ( v110[26] )
        {
          v160 = v67;
          v119 = mem_calloc(1u, 0x10u);
          v67 = v160;
          v120 = v119;
          if ( v119 )
          {
            v119[2] = 4;
            v119[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 26));
            *v120 = **((_DWORD **)srcb + 11);
            v120[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v120;
            *(_DWORD *)(*v120 + 4) = v120;
            v110 = v3->stack.next;
            v67 = v160;
          }
          else
          {
            v110 = v3->stack.next;
          }
        }
        if ( v110[27] )
        {
          v161 = v67;
          v121 = mem_calloc(1u, 0x10u);
          v67 = v161;
          v122 = v121;
          if ( v121 )
          {
            v121[2] = 5;
            v121[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 27));
            *v122 = **((_DWORD **)srcb + 11);
            v122[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v122;
            *(_DWORD *)(*v122 + 4) = v122;
            v110 = v3->stack.next;
            v67 = v161;
          }
          else
          {
            v110 = v3->stack.next;
          }
        }
        if ( v110[28] )
        {
          v162 = v67;
          v123 = mem_calloc(1u, 0x10u);
          v67 = v162;
          v124 = v123;
          if ( v123 )
          {
            v123[2] = 6;
            v123[3] = stracpy(*((const unsigned __int8 **)v3->stack.next + 28));
            *v124 = **((_DWORD **)srcb + 11);
            v124[1] = *((_DWORD *)srcb + 11);
            **((_DWORD **)srcb + 11) = v124;
            *(_DWORD *)(*v124 + 4) = v124;
            v67 = v162;
          }
        }
      }
      *(_BYTE *)(link_stateb + 276) &= ~1u;
      goto LABEL_142;
    }
  }
LABEL_83:
  if ( (*((_BYTE *)&renderer_context_0 + 48) & 8) == 0 )
  {
    v42 = part->cx + v188;
    goto LABEL_85;
  }
  v61 = 0;
  v42 = part->cx + v188;
  if ( *((_DWORD *)v3->stack.next + 32) - *((_DWORD *)v3->stack.next + 31) >= 0 )
    v61 = *((_DWORD *)v3->stack.next + 32) - *((_DWORD *)v3->stack.next + 31);
  if ( v42 <= v61 )
  {
LABEL_85:
    part->cx = v42;
    *((_BYTE *)&renderer_context_0 + 48) &= ~2u;
    if ( *((char *)v3->options + 69) < 0 )
      goto LABEL_110;
    v43 = v3->stack.next;
    v44 = v43[3] & 0x20;
    if ( v44 )
      goto LABEL_110;
    cx = part->cx;
    if ( v43[32] - v43[31] >= 0 )
      v44 = v43[32] - v43[31];
    if ( v44 >= cx || cx <= v43[30] )
    {
LABEL_110:
      v56 = assert_failed;
LABEL_111:
      if ( v56 )
        goto LABEL_114;
    }
    else
    {
      while ( !assert_failed )
      {
        assert_failed = 0;
        v46 = v3->part;
        assert_failed = v46 == 0;
        if ( !v46 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
          errline = 927;
          elinks_internal("assertion part failed!");
          if ( assert_failed )
            break;
        }
        if ( (*((_BYTE *)v3->options + 92) & 0x10) != 0 )
        {
          v47 = v3->stack.next;
          srcc = (unsigned __int8 *)v47[31];
          v48 = v47[32];
          v49 = 0;
          v50 = v47[30];
          v51 = v48 - (_DWORD)srcc;
          if ( v51 >= 0 )
            v49 = v51;
          if ( v50 > v49 )
          {
LABEL_160:
            v75 = v46->cx;
            if ( v50 >= v75 )
            {
LABEL_158:
              v76 = &srcc[v75];
              if ( (int)v76 <= v46->box.width )
                goto LABEL_110;
              v46->box.width = (int)v76;
              v56 = assert_failed;
              goto LABEL_111;
            }
            v49 = v50;
            while ( v49 >= v46->spaces_len || !v46->spaces[v49] && (v46->char_width[v49] != 2 || v49 <= v50) )
            {
              if ( v75 <= ++v49 )
                goto LABEL_158;
            }
          }
          else
          {
            while ( v49 >= v46->spaces_len || !v46->spaces[v49] && (v46->char_width[v49] != 2 || v49 == v50) )
            {
              if ( v50 > --v49 )
                goto LABEL_160;
            }
          }
        }
        else
        {
          v72 = v3->stack.next;
          v49 = 0;
          srcc = (unsigned __int8 *)v72[31];
          v73 = v72[32] - (_DWORD)srcc;
          v74 = v72[30];
          if ( v73 >= 0 )
            v49 = v73;
          if ( v49 < v74 )
          {
LABEL_154:
            v75 = v46->cx;
            if ( v74 >= v75 )
              goto LABEL_158;
            while ( v46->spaces_len <= v74 || !v46->spaces[v74] )
            {
              if ( v75 <= ++v74 )
                goto LABEL_158;
            }
            v49 = v74;
          }
          else
          {
            while ( v49 >= v46->spaces_len || !v46->spaces[v49] )
            {
              if ( v74 > --v49 )
                goto LABEL_154;
            }
          }
        }
        v52 = split_line_at(v3, v49);
        if ( v52 )
        {
          if ( part->document )
            align_line(v3, part->cy - 1, 0);
          v53 = 0;
          *((_BYTE *)&renderer_context_0 + 48) = (2 * (v52 != 1)) | *((_BYTE *)&renderer_context_0 + 48) & 0xFD;
          v54 = part->cx;
          v55 = v3->stack.next;
          if ( v55[32] - v55[31] >= 0 )
            v53 = v55[32] - v55[31];
          if ( v54 > v53 && v54 > v55[30] )
            continue;
        }
        goto LABEL_110;
      }
    }
    assert_failed = charslen <= 0;
    if ( charslen <= 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 1677;
      elinks_internal("assertion charslen > 0 failed!");
    }
LABEL_114:
    v57 = 0;
    v58 = part->xa + v188;
    part->xa = v58;
    v59 = v3->stack.next;
    if ( v189[charslen - 1] == 32 )
      v57 = ((unsigned __int8)(v59[3] >> 5) ^ 1) & 1;
    v60 = v59[30] + v59[31] + v58 - v57;
    if ( v60 > part->max_width )
      part->max_width = v60;
  }
}
// 8141180: using guessed type int ta_cache_8356;
// 8141184: using guessed type int dword_8141184;
// 8141188: using guessed type int dword_8141188;
// 8090C70: using guessed type unsigned __int8 s[64];

//----- (08092A20) --------------------------------------------------------
void __cdecl put_chars_conv(html_context *html_context, unsigned __int8 *chars, int charslen)
{
  if ( assert_failed )
    goto LABEL_6;
  assert_failed = html_context == 0;
  if ( html_context )
  {
    if ( !chars )
      goto LABEL_5;
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
    errline = 1346;
    elinks_internal("assertion html_context failed!");
    if ( assert_failed )
      goto LABEL_6;
    if ( !chars )
    {
LABEL_5:
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/renderer.c";
      errline = 1351;
      elinks_internal("assertion part && chars && charslen failed!");
      if ( !assert_failed )
        goto LABEL_9;
LABEL_6:
      assert_failed = 0;
      return;
    }
  }
  if ( !html_context->part || !charslen )
    goto LABEL_5;
  assert_failed = 0;
LABEL_9:
  if ( (*((_BYTE *)html_context->stack.next + 12) & 0x10) != 0 )
    put_chars(html_context, chars, charslen);
  else
    convert_string_elinks(
      renderer_context_0.convert_table,
      chars,
      charslen,
      html_context->options->cp,
      CSM_DEFAULT,
      0,
      (void (*)(void *, unsigned __int8 *, int))put_chars,
      html_context);
}

//----- (08092B70) --------------------------------------------------------
int __usercall get_hline_width@<eax>(table_elinks *table_elinks@<eax>, int row@<edx>)
{
  int rules; // ecx
  int cellspacing; // edx
  int cols; // esi
  int v6; // edx
  table_cell *cells; // ecx
  int v8; // ecx
  int v9; // edx
  char v10; // bl

  if ( !row )
    return -1;
  rules = table_elinks->rules;
  if ( rules == 3 || rules == 1 )
    goto LABEL_3;
  if ( rules == 4 )
  {
    cols = table_elinks->cols;
    if ( cols > 0 )
    {
      v6 = table_elinks->real_cols * row;
      cells = table_elinks->cells;
      if ( (*((_BYTE *)&cells[v6] + 60) & 8) == 0 )
      {
        v8 = (int)&cells[v6 + 1];
        v9 = 0;
        while ( ++v9 < cols )
        {
          v10 = *(_BYTE *)(v8 + 60);
          v8 += 64;
          if ( (v10 & 8) != 0 )
            goto LABEL_3;
        }
        goto LABEL_7;
      }
LABEL_3:
      cellspacing = table_elinks->cellspacing;
      if ( cellspacing )
        return cellspacing;
      goto LABEL_8;
    }
  }
LABEL_7:
  cellspacing = 0;
LABEL_8:
  if ( !table_elinks->vcellpadding )
    return -1;
  return cellspacing;
}

//----- (08092C10) --------------------------------------------------------
void __usercall get_table_frames(table_elinks *table_elinks@<eax>, table_frames *result@<edx>)
{
  int v2; // ecx
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  table_frames *v5; // [esp+18h] [ebp-10h]
  table_elinks *v6; // [esp+1Ch] [ebp-Ch]

  if ( !assert_failed )
  {
    assert_failed = table_elinks == 0 || result == 0;
    if ( table_elinks == 0 || result == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
      errline = 39;
      v6 = table_elinks;
      v5 = result;
      elinks_internal("assertion table && result failed!");
      result = v5;
      table_elinks = v6;
    }
  }
  if ( table_elinks->border )
  {
    v2 = table_elinks->frame & 1 | *(_BYTE *)result & 0xFE;
    *(_BYTE *)result = v2;
    v3 = (2 * (((unsigned int)table_elinks->frame >> 1) & 1)) | v2 & 0xFFFFFFFD;
    *(_BYTE *)result = v3;
    v4 = (4 * (((unsigned int)table_elinks->frame >> 2) & 1)) | v3 & 0xFFFFFFFB;
    *(_BYTE *)result = v4;
    *(_BYTE *)result = (8 * ((table_elinks->frame & 8) != 0)) | v4 & 0xF7;
  }
  else
  {
    *result = 0;
  }
}

//----- (08092CE0) --------------------------------------------------------
void __usercall draw_table_frames(
        table_elinks *table_elinks@<eax>,
        int indent@<edx>,
        int y@<ecx>,
        html_context *html_context)
{
  int rows; // edi
  int cols; // eax
  int v7; // esi
  size_t v8; // edi
  char *v9; // eax
  int v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // esi
  int v14; // ecx
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // esi
  int v19; // ecx
  int v20; // edx
  int v21; // eax
  int v22; // esi
  int v23; // edi
  int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // ecx
  int v28; // edx
  int v29; // eax
  int v30; // esi
  int v31; // edi
  int v32; // eax
  int v33; // eax
  int v34; // esi
  int v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int v41; // eax
  int v42; // eax
  int v43; // ecx
  int v44; // eax
  int v45; // eax
  int v46; // eax
  char v47; // al
  int v48; // ecx
  int v49; // ecx
  int v50; // eax
  int v51; // edx
  int v52; // ecx
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  int v56; // eax
  int v57; // eax
  int v58; // eax
  int v59; // eax
  int v60; // eax
  int v61; // edx
  int v62; // eax
  int v63; // eax
  int v64; // eax
  char v65; // cl
  int v66; // eax
  int v67; // eax
  int v68; // eax
  char v69; // al
  int v70; // ecx
  int v71; // eax
  int v72; // edi
  int v73; // edx
  int v74; // eax
  int v75; // esi
  int v76; // edx
  int v77; // edi
  int v78; // esi
  int v79; // edx
  table_cell *v80; // eax
  int colspan; // edx
  size_t rowspan; // ecx
  int v83; // eax
  int v84; // edx
  int v85; // eax
  int v86; // edx
  size_t v87; // ecx
  int v88; // eax
  int v89; // esi
  int v90; // eax
  int v91; // edx
  int cellspacing; // edx
  int v93; // eax
  int v94; // eax
  int v95; // edx
  size_t v96; // ecx
  int v97; // eax
  int v98; // eax
  int v99; // eax
  int v100; // edx
  int v101; // edi
  int v102; // esi
  table_cell *cells; // eax
  int v104; // edx
  int v105; // eax
  char v106; // cl
  int v107; // eax
  int i; // [esp+2Ch] [ebp-9Ch]
  int v109; // [esp+48h] [ebp-80h]
  char v110; // [esp+4Fh] [ebp-79h]
  int v111; // [esp+5Ch] [ebp-6Ch]
  int v112; // [esp+5Ch] [ebp-6Ch]
  int v113; // [esp+5Ch] [ebp-6Ch]
  int v114; // [esp+5Ch] [ebp-6Ch]
  int v115; // [esp+5Ch] [ebp-6Ch]
  int v116; // [esp+5Ch] [ebp-6Ch]
  int v117; // [esp+5Ch] [ebp-6Ch]
  int v118; // [esp+5Ch] [ebp-6Ch]
  int v119; // [esp+5Ch] [ebp-6Ch]
  int v120; // [esp+5Ch] [ebp-6Ch]
  int v121; // [esp+60h] [ebp-68h]
  int v122; // [esp+60h] [ebp-68h]
  int v123; // [esp+60h] [ebp-68h]
  int v124; // [esp+60h] [ebp-68h]
  char v125; // [esp+60h] [ebp-68h]
  char v126; // [esp+60h] [ebp-68h]
  int v127; // [esp+60h] [ebp-68h]
  size_t nb; // [esp+64h] [ebp-64h]
  size_t n; // [esp+64h] [ebp-64h]
  size_t nc; // [esp+64h] [ebp-64h]
  size_t na; // [esp+64h] [ebp-64h]
  size_t nd; // [esp+64h] [ebp-64h]
  size_t ne; // [esp+64h] [ebp-64h]
  char nf; // [esp+64h] [ebp-64h]
  int v136; // [esp+6Ch] [ebp-5Ch]
  int v137; // [esp+70h] [ebp-58h]
  int v138; // [esp+74h] [ebp-54h]
  int v139; // [esp+74h] [ebp-54h]
  char *v140; // [esp+78h] [ebp-50h]
  char *p; // [esp+80h] [ebp-48h]
  int c; // [esp+84h] [ebp-44h]
  int ca; // [esp+84h] [ebp-44h]
  int cb; // [esp+84h] [ebp-44h]
  int w; // [esp+88h] [ebp-40h]
  char wa; // [esp+88h] [ebp-40h]
  int wb; // [esp+88h] [ebp-40h]
  int wc; // [esp+88h] [ebp-40h]
  int v150; // [esp+8Ch] [ebp-3Ch]
  int v151; // [esp+8Ch] [ebp-3Ch]
  int v152; // [esp+8Ch] [ebp-3Ch]
  int v153; // [esp+8Ch] [ebp-3Ch]
  int rules; // [esp+90h] [ebp-38h]
  int v155; // [esp+90h] [ebp-38h]
  int v156; // [esp+90h] [ebp-38h]
  char v157; // [esp+90h] [ebp-38h]
  int v158; // [esp+90h] [ebp-38h]
  int v159; // [esp+90h] [ebp-38h]
  int v160; // [esp+90h] [ebp-38h]
  int v161; // [esp+90h] [ebp-38h]
  int v162; // [esp+94h] [ebp-34h]
  int v163; // [esp+94h] [ebp-34h]
  int height; // [esp+98h] [ebp-30h]
  char heighta; // [esp+98h] [ebp-30h]
  int heightb; // [esp+98h] [ebp-30h]
  int heightc; // [esp+98h] [ebp-30h]
  int heightd; // [esp+98h] [ebp-30h]
  int heighte; // [esp+98h] [ebp-30h]
  char v170; // [esp+9Ch] [ebp-2Ch]
  int v171; // [esp+9Ch] [ebp-2Ch]
  int v172; // [esp+9Ch] [ebp-2Ch]
  int v173; // [esp+9Ch] [ebp-2Ch]
  int v174; // [esp+9Ch] [ebp-2Ch]
  int v175; // [esp+9Ch] [ebp-2Ch]
  table_frames table_frames; // [esp+ACh] [ebp-1Ch] BYREF

  rows = table_elinks->rows;
  cols = table_elinks->cols;
  v7 = (cols + 2) * (rows + 1);
  v8 = v7 + (cols + 1) * (rows + 2);
  v9 = (char *)mem_alloc(v8);
  p = v9;
  if ( v9 )
  {
    memset(v9, -1, v8);
    v140 = &p[v7];
    rules = table_elinks->rules;
    if ( !rules )
    {
LABEL_3:
      get_table_frames(table_elinks, &table_frames);
      v10 = table_elinks->cols;
      if ( assert_failed )
      {
        assert_failed = 0;
        v11 = 0;
      }
      else
      {
        assert_failed = 0;
        v11 = 1;
      }
      memset(&p[v11], *(_BYTE *)&table_frames & 1, v10);
      v12 = table_elinks->cols;
      v13 = table_elinks->rows;
      if ( assert_failed )
      {
        assert_failed = 0;
        v14 = 0;
      }
      else
      {
        assert_failed = 0;
        v14 = v13 * (v12 + 2) + 1;
      }
      memset(&p[v14], (*(_BYTE *)&table_frames & 2) != 0, v12);
      v15 = table_elinks->rows;
      if ( assert_failed )
      {
        assert_failed = 0;
        v16 = 0;
      }
      else
      {
        assert_failed = 0;
        v16 = 1;
      }
      memset(&v140[v16], (*(_BYTE *)&table_frames & 4) != 0, v15);
      v17 = table_elinks->rows;
      v18 = table_elinks->cols;
      if ( assert_failed )
      {
        assert_failed = 0;
        v19 = 0;
      }
      else
      {
        assert_failed = 0;
        v19 = v18 * (v17 + 2) + 1;
      }
      memset(&v140[v19], (*(_BYTE *)&table_frames & 8) != 0, v17);
      v20 = table_elinks->rows;
      if ( v20 < 0 )
        goto LABEL_39;
      v137 = -1;
      v138 = 0;
      c = 1;
      v162 = 0;
      while ( 1 )
      {
        if ( v162 <= 0 )
        {
          if ( !v162 )
          {
            v27 = v20;
            v170 = (char)table_frames;
            if ( (*(_BYTE *)&table_frames & 1) != 0 )
              goto LABEL_52;
          }
        }
        else if ( v20 > v162 )
        {
          if ( get_hline_width(table_elinks, v162) >= 0 )
          {
            v20 = table_elinks->rows;
            v170 = (char)table_frames;
            v27 = v20;
            goto LABEL_52;
          }
          v20 = table_elinks->rows;
        }
        if ( v20 == v162 )
          break;
        if ( v20 <= v162 )
          goto LABEL_49;
        v21 = table_elinks->cols;
        if ( v21 < 0 )
          goto LABEL_37;
        v22 = 0;
        v23 = indent;
        v150 = v20;
        height = c;
        do
        {
          if ( !v22 )
          {
            if ( (*(_BYTE *)&table_frames & 4) == 0 )
              goto LABEL_20;
            goto LABEL_26;
          }
          if ( v21 <= v22 )
            goto LABEL_20;
          v28 = table_elinks->rules;
          if ( (unsigned int)(v28 - 2) > 1 )
          {
            if ( v28 == 4 && v22 < table_elinks->columns_count && table_elinks->columns[v22].group )
              goto LABEL_26;
LABEL_47:
            if ( table_elinks->cellpadding )
              goto LABEL_20;
            goto LABEL_26;
          }
          if ( !table_elinks->cellspacing )
            goto LABEL_47;
          if ( table_elinks->cellspacing < 0 )
          {
LABEL_20:
            if ( v22 != v21 || (*(_BYTE *)&table_frames & 8) == 0 )
              goto LABEL_21;
          }
LABEL_26:
          if ( assert_failed )
          {
            assert_failed = 0;
            v24 = 0;
          }
          else
          {
            assert_failed = 0;
            v24 = c + v22 * (v150 + 2);
          }
          v25 = v140[v24];
          assert_failed = v25 > 2;
          if ( v25 > 2
            && (v116 = v25,
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
                errline = 1062,
                elinks_internal("assertion pos < 3 failed: Vertical table position out of bound [%d]", v25),
                v25 = v116,
                assert_failed) )
          {
            assert_failed = 0;
          }
          else if ( v25 >= 0 )
          {
            v26 = table_elinks->rows_heights[v138];
            if ( v26 > 0 )
              draw_frame_vchars(
                table_elinks->part,
                v23,
                y,
                v26,
                vltable_7304[v25],
                *((_DWORD *)html_context->stack.next + 37),
                table_elinks->bordercolor,
                html_context);
          }
          ++v23;
          v21 = table_elinks->cols;
          v150 = table_elinks->rows;
LABEL_21:
          if ( v21 > v22 )
            v23 += table_elinks->cols_widths[v22];
          ++v22;
        }
        while ( v21 >= v22 );
        v20 = v150;
LABEL_36:
        if ( v162 < v20 )
        {
LABEL_37:
          y += table_elinks->rows_heights[v138];
          height = c;
        }
LABEL_38:
        ++v162;
        ++c;
        ++v138;
        ++v137;
        if ( v20 < height )
        {
LABEL_39:
          mem_free(p);
          return;
        }
      }
      v170 = (char)table_frames;
      if ( (*(_BYTE *)&table_frames & 2) == 0 )
      {
LABEL_49:
        height = c;
        goto LABEL_38;
      }
      v27 = v20;
LABEL_52:
      w = -1;
      if ( (v170 & 4) != 0 )
        w = table_elinks->border;
      v29 = table_elinks->cols;
      if ( v29 > 0 )
      {
        v30 = 0;
        v151 = v27;
        v136 = y + 1;
        v31 = indent;
        for ( i = 0; ; ++i )
        {
          if ( w < 0 )
          {
            v171 = v30 + 1;
            if ( assert_failed )
              goto LABEL_105;
            goto LABEL_57;
          }
          if ( !assert_failed )
          {
            if ( v30 - 1 >= -1 )
            {
              v37 = v29 + 2;
LABEL_76:
              assert_failed = 0;
LABEL_77:
              v38 = v30 + v162 * v37;
              goto LABEL_78;
            }
            v37 = v29 + 2;
            if ( v30 - 1 < v37 || v162 >= 0 || v151 >= v162 )
              goto LABEL_76;
            v111 = v37;
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
            errline = 971;
            elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
            v37 = v111;
            if ( !assert_failed )
              goto LABEL_77;
          }
          assert_failed = 0;
          v38 = 0;
LABEL_78:
          heighta = p[v38];
          v39 = table_elinks->cols;
          if ( v30 >= -1 )
          {
            v40 = v39 + 2;
LABEL_80:
            assert_failed = 0;
LABEL_81:
            v171 = v30 + 1;
            v156 = v30 + 1 + v162 * v40;
            goto LABEL_82;
          }
          v40 = v39 + 2;
          if ( v30 < v40 || v162 >= 0 || table_elinks->rows >= v162 )
            goto LABEL_80;
          v114 = v40;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v40 = v114;
          if ( !assert_failed )
            goto LABEL_81;
          assert_failed = 0;
          v156 = 0;
          v171 = v30 + 1;
LABEL_82:
          v41 = table_elinks->rows;
          v110 = p[v156];
          if ( v137 >= -1 )
          {
            v42 = v41 + 2;
LABEL_84:
            assert_failed = 0;
LABEL_85:
            v43 = v30 * v42 + v162;
            goto LABEL_86;
          }
          v42 = v41 + 2;
          if ( v30 >= 0 || v137 < v42 || v30 <= table_elinks->cols )
            goto LABEL_84;
          v113 = v42;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v42 = v113;
          if ( !assert_failed )
            goto LABEL_85;
          assert_failed = 0;
          v43 = 0;
LABEL_86:
          v44 = table_elinks->rows;
          v157 = v140[v43];
          if ( v162 >= -1 )
          {
            v45 = v44 + 2;
LABEL_88:
            assert_failed = 0;
            goto LABEL_89;
          }
          v45 = v44 + 2;
          if ( v30 >= 0 || v45 > v162 || v30 <= table_elinks->cols )
            goto LABEL_88;
          v115 = v45;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v45 = v115;
          if ( assert_failed )
          {
            assert_failed = 0;
            v46 = 0;
            goto LABEL_90;
          }
LABEL_89:
          v46 = c + v30 * v45;
LABEL_90:
          v47 = v140[v46];
          if ( v110 >= 0 || heighta >= 0 || v47 >= 0 || v157 >= 0 )
          {
            v48 = heighta;
            heightb = v47;
            v152 = v48;
            v49 = v110;
            v50 = 0;
            if ( v110 < 0 )
              v49 = 0;
            v51 = v157;
            v109 = v49;
            v52 = v152;
            if ( v152 < 0 )
              v52 = 0;
            if ( v157 < 0 )
              v51 = 0;
            if ( heightb >= 0 )
              v50 = heightb;
            draw_frame_hchars(
              table_elinks->part,
              v31,
              y,
              1,
              border_chars_7192[108 * v50 + 36 * v52 + 12 * v109 + 4 * v51],
              *((_DWORD *)html_context->stack.next + 37),
              table_elinks->bordercolor,
              html_context);
          }
          v151 = table_elinks->rows;
          if ( v151 <= v162 )
          {
            heightc = assert_failed;
            goto LABEL_104;
          }
          if ( assert_failed )
          {
LABEL_136:
            assert_failed = 0;
            v54 = 0;
            goto LABEL_116;
          }
          if ( v162 >= -1 )
          {
            v53 = v151 + 2;
LABEL_114:
            assert_failed = 0;
            goto LABEL_115;
          }
          v53 = v151 + 2;
          if ( v30 >= 0 || v53 > v162 || v30 <= table_elinks->cols )
            goto LABEL_114;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v53 = v151 + 2;
          if ( assert_failed )
            goto LABEL_136;
LABEL_115:
          v54 = c + v30 * v53;
LABEL_116:
          v55 = v140[v54];
          assert_failed = v55 > 2;
          if ( v55 > 2
            && (nb = v55,
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
                errline = 1062,
                elinks_internal("assertion pos < 3 failed: Vertical table position out of bound [%d]", v55),
                v55 = nb,
                assert_failed) )
          {
            assert_failed = 0;
            heightc = 0;
            v151 = table_elinks->rows;
          }
          else if ( v55 < 0 )
          {
            v151 = table_elinks->rows;
            heightc = assert_failed;
          }
          else
          {
            if ( table_elinks->rows_heights[v138] > 0 )
              draw_frame_vchars(
                table_elinks->part,
                v31,
                v136,
                table_elinks->rows_heights[v138],
                vltable_7304[v55],
                *((_DWORD *)html_context->stack.next + 37),
                table_elinks->bordercolor,
                html_context);
            v151 = table_elinks->rows;
            heightc = assert_failed;
          }
LABEL_104:
          ++v31;
          v29 = table_elinks->cols;
          if ( heightc )
            goto LABEL_105;
LABEL_57:
          if ( v30 >= -1 )
          {
            v32 = v29 + 2;
LABEL_59:
            assert_failed = 0;
            goto LABEL_60;
          }
          v32 = v29 + 2;
          if ( v30 < v32 || v162 >= 0 || v162 <= v151 )
            goto LABEL_59;
          v112 = v32;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v32 = v112;
          if ( assert_failed )
          {
LABEL_105:
            assert_failed = 0;
            v33 = 0;
            goto LABEL_61;
          }
LABEL_60:
          v33 = v171 + v162 * v32;
LABEL_61:
          v34 = p[v33];
          assert_failed = v34 > 2;
          if ( v34 > 2
            && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
                errline = 1046,
                elinks_internal("assertion pos < 3 failed: Horizontal table position out of bound [%d]", v34),
                assert_failed) )
          {
            assert_failed = 0;
            v35 = table_elinks->cols_widths[i];
          }
          else
          {
            if ( v34 >= 0 )
            {
              v35 = table_elinks->cols_widths[i];
              if ( v35 <= 0 )
                goto LABEL_66;
              draw_frame_hchars(
                table_elinks->part,
                v31,
                y,
                v35,
                hltable_7258[v34],
                *((_DWORD *)html_context->stack.next + 37),
                table_elinks->bordercolor,
                html_context);
            }
            v35 = table_elinks->cols_widths[i];
          }
LABEL_66:
          v31 += v35;
          v30 = v171;
          v29 = table_elinks->cols;
          if ( v29 <= v171 )
          {
            v155 = v31;
            v170 = (char)table_frames;
            v20 = table_elinks->rows;
            v27 = v20;
            goto LABEL_34;
          }
          if ( v171 > 0 )
          {
            v36 = table_elinks->rules;
            if ( (unsigned int)(v36 - 2) <= 1 )
            {
              w = table_elinks->cellspacing;
              if ( !w )
                goto LABEL_70;
            }
            else if ( v36 != 4 || v171 >= table_elinks->columns_count || (w = 1, !table_elinks->columns[v171].group) )
            {
LABEL_70:
              w = -(table_elinks->cellpadding != 0);
            }
          }
          v151 = table_elinks->rows;
        }
      }
      v155 = indent;
      v30 = 0;
      v136 = y + 1;
LABEL_34:
      height = c;
      if ( (v170 & 8) == 0 )
      {
LABEL_35:
        y = v136;
        goto LABEL_36;
      }
      if ( !assert_failed )
      {
        if ( v30 - 1 >= -1 )
        {
          v56 = v29 + 2;
LABEL_165:
          assert_failed = 0;
LABEL_166:
          v57 = v30 + v162 * v56;
          goto LABEL_167;
        }
        v56 = v29 + 2;
        if ( v30 - 1 < v56 || v162 >= 0 || v162 <= v27 )
          goto LABEL_165;
        v117 = v56;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 971;
        elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
        v56 = v117;
        if ( !assert_failed )
          goto LABEL_166;
      }
      assert_failed = 0;
      v57 = 0;
LABEL_167:
      wa = p[v57];
      v58 = table_elinks->cols;
      if ( v30 < -1 )
      {
        v59 = v58 + 2;
        if ( v30 >= v59 && v162 < 0 && table_elinks->rows < v162 )
        {
          v118 = v59;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v59 = v118;
          if ( assert_failed )
          {
            assert_failed = 0;
            v60 = 0;
LABEL_171:
            LOBYTE(v61) = p[v60];
            v62 = table_elinks->rows;
            if ( v137 < -1 )
            {
              v63 = v62 + 2;
              if ( v30 < 0 && v137 >= v63 && table_elinks->cols < v30 )
              {
                v120 = v63;
                v126 = v61;
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                errline = 971;
                elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
                v63 = v120;
                LOBYTE(v61) = v126;
                if ( assert_failed )
                {
                  assert_failed = 0;
                  v64 = 0;
LABEL_175:
                  v65 = v140[v64];
                  v66 = table_elinks->rows;
                  if ( v162 < -1 )
                  {
                    v67 = v66 + 2;
                    if ( v30 < 0 && v162 >= v67 && table_elinks->cols < v30 )
                    {
                      v119 = v67;
                      v125 = v61;
                      nf = v65;
                      assert_failed = 1;
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                      errline = 971;
                      elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
                      v67 = v119;
                      LOBYTE(v61) = v125;
                      v65 = nf;
                      if ( assert_failed )
                      {
                        assert_failed = 0;
                        height = c;
                        v68 = 0;
                        goto LABEL_179;
                      }
LABEL_178:
                      v68 = c + v30 * v67;
                      height = c;
LABEL_179:
                      v69 = v140[v68];
                      if ( (v61 & 0x80u) == 0 || wa >= 0 || v69 >= 0 || v65 >= 0 )
                      {
                        v172 = v65;
                        v70 = wa;
                        v61 = (char)v61;
                        wb = v69;
                        v71 = 0;
                        if ( (v61 & 0x80u) != 0 )
                          v61 = 0;
                        if ( v70 < 0 )
                          v70 = 0;
                        v72 = v172;
                        v73 = 3 * v61;
                        if ( v172 < 0 )
                          v72 = 0;
                        if ( wb >= 0 )
                          v71 = wb;
                        draw_frame_hchars(
                          table_elinks->part,
                          v155,
                          y,
                          1,
                          border_chars_7192[108 * v71 + 36 * v70 + 4 * v72 + 4 * v73],
                          *((_DWORD *)html_context->stack.next + 37),
                          table_elinks->bordercolor,
                          html_context);
                      }
                      v20 = table_elinks->rows;
                      if ( v20 <= v162 )
                        goto LABEL_35;
                      if ( assert_failed )
                        goto LABEL_193;
                      if ( v162 < -1 )
                      {
                        v100 = v20 + 2;
                        if ( v30 < 0 && v162 >= v100 && table_elinks->cols < v30 )
                        {
                          v127 = v100;
                          assert_failed = 1;
                          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                          errline = 971;
                          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
                          v100 = v127;
                          if ( assert_failed )
                          {
LABEL_193:
                            assert_failed = 0;
                            v74 = 0;
LABEL_194:
                            v75 = v140[v74];
                            assert_failed = v75 > 2;
                            if ( v75 > 2
                              && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
                                  errline = 1062,
                                  elinks_internal(
                                    "assertion pos < 3 failed: Vertical table position out of bound [%d]",
                                    v75),
                                  assert_failed) )
                            {
                              assert_failed = 0;
                              v20 = table_elinks->rows;
                            }
                            else
                            {
                              if ( v75 >= 0 )
                              {
                                v76 = table_elinks->rows_heights[v138];
                                if ( v76 > 0 )
                                  draw_frame_vchars(
                                    table_elinks->part,
                                    v155,
                                    v136,
                                    v76,
                                    vltable_7304[v75],
                                    *((_DWORD *)html_context->stack.next + 37),
                                    table_elinks->bordercolor,
                                    html_context);
                              }
                              v20 = table_elinks->rows;
                            }
                            goto LABEL_35;
                          }
LABEL_289:
                          v74 = c + v30 * v100;
                          goto LABEL_194;
                        }
                      }
                      else
                      {
                        v100 = v20 + 2;
                      }
                      assert_failed = 0;
                      goto LABEL_289;
                    }
                  }
                  else
                  {
                    v67 = v66 + 2;
                  }
                  assert_failed = 0;
                  goto LABEL_178;
                }
LABEL_174:
                v64 = v162 + v30 * v63;
                goto LABEL_175;
              }
            }
            else
            {
              v63 = v62 + 2;
            }
            assert_failed = 0;
            goto LABEL_174;
          }
LABEL_170:
          v60 = v30 + v162 * v59 + 1;
          goto LABEL_171;
        }
      }
      else
      {
        v59 = v58 + 2;
      }
      assert_failed = 0;
      goto LABEL_170;
    }
    ca = table_elinks->rows;
    if ( ca <= 0 )
      goto LABEL_244;
    v153 = 1;
    v163 = 0;
    heightd = table_elinks->rows;
    v173 = table_elinks->cols;
    while ( 1 )
    {
      v139 = v153;
      if ( v173 <= 0 )
        goto LABEL_243;
      v77 = 1;
      v78 = 0;
      while ( 1 )
      {
        v79 = v77;
        v80 = &table_elinks->cells[v78 + table_elinks->real_cols * v163];
        if ( (*((_BYTE *)v80 + 60) & 3) != 1 )
          goto LABEL_222;
        colspan = v173 - v78;
        if ( v80->colspan )
          colspan = v80->colspan;
        wc = colspan;
        rowspan = v80->rowspan;
        if ( !rowspan )
          rowspan = heightd - v163;
        if ( rules != 2 )
          break;
LABEL_253:
        cellspacing = table_elinks->cellspacing;
        if ( !assert_failed )
        {
          if ( v163 >= -1 )
          {
            v93 = ca + 2;
LABEL_256:
            assert_failed = 0;
LABEL_257:
            v94 = v153 + v78 * v93;
            goto LABEL_258;
          }
          v93 = ca + 2;
          if ( v163 < ca + 2 || v78 >= 0 || v173 >= v78 )
            goto LABEL_256;
          v124 = table_elinks->cellspacing;
          ne = rowspan;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
          errline = 971;
          elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
          v93 = ca + 2;
          rowspan = ne;
          cellspacing = v124;
          if ( !assert_failed )
            goto LABEL_257;
        }
        assert_failed = 0;
        v94 = 0;
LABEL_258:
        na = rowspan;
        memset(&v140[v94], cellspacing, rowspan);
        v95 = table_elinks->cellspacing;
        v96 = na;
        v160 = table_elinks->rows;
        if ( assert_failed )
          goto LABEL_278;
        v175 = v78 + wc;
        if ( v163 >= -1 )
        {
          v161 = v160 + 2;
LABEL_261:
          assert_failed = 0;
          goto LABEL_262;
        }
        v99 = v160 + 2;
        v161 = v160 + 2;
        if ( v175 >= 0 || v163 < v99 || table_elinks->cols >= v175 )
          goto LABEL_261;
        v123 = table_elinks->cellspacing;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 971;
        elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
        v95 = v123;
        v96 = na;
        if ( assert_failed )
        {
LABEL_278:
          assert_failed = 0;
          v97 = 0;
          goto LABEL_263;
        }
LABEL_262:
        v97 = v153 + v175 * v161;
LABEL_263:
        memset(&v140[v97], v95, v96);
        v79 = v77;
        v173 = table_elinks->cols;
        heightd = table_elinks->rows;
        rules = table_elinks->rules;
LABEL_222:
        ++v78;
        ++v77;
        if ( v173 <= v79 )
          goto LABEL_242;
LABEL_223:
        ca = heightd;
      }
      cb = table_elinks->cellspacing;
      if ( !assert_failed )
      {
        if ( v78 >= -1 )
        {
          v83 = v173 + 2;
LABEL_233:
          assert_failed = 0;
LABEL_234:
          v84 = v77;
          v85 = v77 + v163 * v83;
          goto LABEL_235;
        }
        v83 = v173 + 2;
        if ( v173 + 2 > v78 || v163 >= 0 || v163 <= heightd )
          goto LABEL_233;
        nd = rowspan;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 971;
        elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
        v83 = v173 + 2;
        rowspan = nd;
        if ( !assert_failed )
          goto LABEL_234;
      }
      assert_failed = 0;
      v84 = v77;
      v85 = 0;
LABEL_235:
      v121 = v84;
      n = rowspan;
      memset(&p[v85], cb, wc);
      v86 = v121;
      v87 = n;
      v174 = table_elinks->cellspacing;
      v158 = table_elinks->cols;
      if ( !assert_failed )
      {
        heighte = n + v163;
        if ( v78 >= -1 )
        {
          v159 = v158 + 2;
LABEL_238:
          assert_failed = 0;
LABEL_239:
          v88 = v77 + heighte * v159;
          goto LABEL_240;
        }
        v98 = v158 + 2;
        v159 = v158 + 2;
        if ( heighte >= 0 || v98 > v78 || table_elinks->rows >= heighte )
          goto LABEL_238;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 971;
        elinks_internal("assertion a >= -1 || a < a_size + 2 || b >= 0 || b <= b_size failed!");
        v87 = n;
        v86 = v121;
        if ( !assert_failed )
          goto LABEL_239;
      }
      assert_failed = 0;
      v88 = 0;
LABEL_240:
      v122 = v86;
      nc = v87;
      memset(&p[v88], v174, wc);
      rowspan = nc;
      if ( table_elinks->rules != 1 )
      {
        ca = table_elinks->rows;
        v173 = table_elinks->cols;
        goto LABEL_253;
      }
      ++v78;
      ++v77;
      rules = 1;
      v173 = table_elinks->cols;
      heightd = table_elinks->rows;
      if ( v173 > v122 )
        goto LABEL_223;
LABEL_242:
      ca = heightd;
LABEL_243:
      ++v163;
      ++v153;
      if ( heightd <= v139 )
      {
LABEL_244:
        if ( rules != 4 )
          goto LABEL_3;
        if ( table_elinks->cols > 1 )
        {
          v89 = 1;
          do
          {
            if ( !table_elinks->cols_x[v89] )
            {
              v90 = table_elinks->rows;
              if ( assert_failed )
              {
                assert_failed = 0;
                v91 = 0;
              }
              else
              {
                assert_failed = 0;
                v91 = v89 * (v90 + 2) + 1;
              }
              memset(&v140[v91], 0, v90);
            }
            ++v89;
          }
          while ( v89 < table_elinks->cols );
        }
        v101 = 1;
        if ( table_elinks->rows <= 1 )
          goto LABEL_3;
        while ( 2 )
        {
          v102 = table_elinks->cols;
          if ( v102 <= 0 )
          {
LABEL_312:
            if ( assert_failed )
            {
              assert_failed = 0;
              v107 = 0;
            }
            else
            {
              assert_failed = 0;
              v107 = v101 * (v102 + 2) + 1;
            }
            memset(&p[v107], 0, v102);
          }
          else
          {
            cells = table_elinks->cells;
            if ( (*((_BYTE *)&cells[v101 * table_elinks->real_cols] + 60) & 8) == 0 )
            {
              v104 = (int)&cells[v101 * table_elinks->real_cols + 1];
              v105 = 0;
              while ( v102 > ++v105 )
              {
                v106 = *(_BYTE *)(v104 + 60);
                v104 += 64;
                if ( (v106 & 8) != 0 )
                  goto LABEL_315;
              }
              goto LABEL_312;
            }
          }
LABEL_315:
          if ( ++v101 >= table_elinks->rows )
            goto LABEL_3;
          continue;
        }
      }
    }
  }
}

//----- (08094400) --------------------------------------------------------
void __cdecl format_table(
        unsigned __int8 *attr,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end,
        html_context *html_context)
{
  int v5; // eax
  table_elinks *v6; // eax
  int v7; // ebx
  unsigned __int8 *v8; // edx
  int v9; // eax
  unsigned __int8 *v10; // esi
  unsigned __int8 *v11; // edi
  const unsigned __int16 **v12; // eax
  const unsigned __int16 *v13; // eax
  document ***v14; // ebx
  document **v15; // eax
  document **v16; // edi
  document ***v17; // edi
  document **v18; // eax
  int v19; // ebx
  int v20; // esi
  unsigned __int8 *v21; // edx
  int v22; // ecx
  part *v23; // eax
  int max_width; // edx
  signed int cols; // eax
  int real_cols; // eax
  table_elinks *v27; // esi
  int v28; // eax
  bool v29; // zf
  unsigned __int8 *colspan; // esi
  int v31; // edx
  int v32; // edx
  int v33; // ecx
  int v34; // eax
  int v35; // esi
  int rules; // esi
  int cellspacing; // esi
  char *v38; // ebx
  int *max_cols_widths; // edi
  int v40; // eax
  int v41; // edx
  int *v42; // ecx
  int v43; // esi
  int v44; // eax
  int v45; // edx
  int v46; // esi
  int v47; // edi
  int v48; // eax
  int v49; // edx
  int v50; // esi
  int v51; // edx
  int v52; // eax
  int v53; // esi
  int v54; // edx
  int v55; // eax
  int v56; // edi
  int v57; // esi
  int v58; // eax
  int *v59; // ecx
  int v60; // eax
  int v61; // edx
  _DWORD *v62; // ecx
  int v63; // ebx
  int i; // ebx
  int v65; // esi
  unsigned __int8 *v66; // edx
  unsigned __int8 *v67; // eax
  int v68; // ecx
  part *v69; // eax
  int v70; // edx
  int v71; // edx
  int v72; // ecx
  signed int v73; // esi
  _BOOL4 v74; // ecx
  int v75; // ecx
  signed int v76; // edi
  document **v77; // esi
  document **v78; // eax
  document **v79; // edx
  int v80; // eax
  int v81; // ecx
  int v82; // edx
  table_elinks *v83; // ecx
  size_t v84; // edi
  void *v85; // edi
  int v86; // esi
  int *v87; // ecx
  document **v88; // eax
  int v89; // esi
  int v90; // edi
  int v91; // ecx
  int v92; // eax
  int v93; // edx
  int v94; // eax
  int v95; // eax
  document **v96; // eax
  int v97; // edi
  int v98; // esi
  int v99; // eax
  document **v100; // edx
  document *v101; // ecx
  int v102; // edi
  int v103; // edx
  unsigned __int8 *v104; // eax
  part *v105; // eax
  document **v106; // eax
  document **v107; // edx
  part *v108; // edx
  int v109; // edi
  document **v110; // edx
  unsigned __int8 *v111; // esi
  int v112; // ecx
  unsigned __int8 *v113; // eax
  unsigned __int8 *v114; // edi
  unsigned __int8 *v115; // esi
  document **height; // esi
  document **v117; // eax
  document **v118; // edx
  int v119; // edi
  int v120; // esi
  int *v121; // eax
  int v122; // edx
  int v123; // ecx
  document **v124; // ecx
  part *v125; // eax
  document **v126; // edx
  document **v127; // edx
  int v128; // eax
  int v129; // edx
  int v130; // eax
  int v131; // eax
  int v132; // edx
  int v133; // ecx
  int v134; // edx
  int v135; // edx
  _DWORD *next; // esi
  document **v137; // edi
  int v138; // ecx
  int v139; // eax
  unsigned __int8 *v140; // edx
  unsigned __int8 *v141; // edi
  const unsigned __int16 **v142; // eax
  int v143; // esi
  unsigned __int8 *v144; // edi
  unsigned __int8 *v145; // ecx
  int v146; // eax
  int v147; // edi
  int hline_width; // eax
  int v149; // eax
  int v150; // edx
  int ii; // edi
  int v152; // edi
  int jj; // eax
  document **v154; // eax
  document **v155; // eax
  document **v156; // eax
  document **v157; // eax
  int v158; // ecx
  document **v159; // eax
  char *v160; // edi
  int kk; // esi
  int v162; // edx
  _DWORD *v163; // eax
  int v164; // esi
  int v165; // edx
  int v166; // edi
  int v167; // ecx
  document **v168; // eax
  int v169; // eax
  int v170; // edx
  document *v171; // edi
  document *v172; // edx
  document *v173; // eax
  int v174; // eax
  int v175; // edx
  int v176; // edx
  document **v177; // eax
  document **v178; // edx
  int v179; // edx
  char *v180; // eax
  int v181; // edx
  int v182; // ecx
  int k; // eax
  int v184; // esi
  int m; // eax
  document *v186; // edi
  int *v187; // eax
  int v188; // edx
  part *v189; // eax
  color_T v190; // esi
  document **v191; // eax
  document **v192; // eax
  int v193; // esi
  int v194; // esi
  int v195; // eax
  document **v196; // edx
  int v197; // esi
  _BOOL4 v198; // ecx
  int v199; // eax
  table_elinks *v200; // esi
  int v201; // edi
  int v202; // ebx
  int v203; // edx
  int v204; // edx
  int v205; // eax
  int v206; // edx
  part *v207; // edi
  document **v208; // ebx
  document **v209; // ecx
  _BOOL4 v210; // edx
  document **v211; // edx
  int v212; // eax
  document **v213; // edx
  part *v214; // eax
  int v215; // edi
  document **v216; // eax
  int v217; // esi
  document ***v218; // [esp+38h] [ebp-90h]
  document *v219; // [esp+3Ch] [ebp-8Ch]
  unsigned __int8 *v220; // [esp+40h] [ebp-88h]
  unsigned __int8 *v221; // [esp+40h] [ebp-88h]
  unsigned __int8 *v222; // [esp+40h] [ebp-88h]
  unsigned __int8 *v223; // [esp+40h] [ebp-88h]
  unsigned __int8 *v224; // [esp+40h] [ebp-88h]
  unsigned __int8 *v225; // [esp+40h] [ebp-88h]
  unsigned __int8 *v226; // [esp+40h] [ebp-88h]
  unsigned __int8 *v227; // [esp+40h] [ebp-88h]
  unsigned __int8 *v228; // [esp+40h] [ebp-88h]
  int v229; // [esp+48h] [ebp-80h]
  int v230; // [esp+48h] [ebp-80h]
  void *state; // [esp+4Ch] [ebp-7Ch]
  document **v232; // [esp+50h] [ebp-78h]
  document **v233; // [esp+54h] [ebp-74h]
  int v234; // [esp+58h] [ebp-70h]
  document *v235; // [esp+58h] [ebp-70h]
  int margins; // [esp+5Ch] [ebp-6Ch]
  int marginsa; // [esp+5Ch] [ebp-6Ch]
  document *document; // [esp+60h] [ebp-68h]
  document *documenta; // [esp+60h] [ebp-68h]
  int v240; // [esp+64h] [ebp-64h]
  part *part; // [esp+68h] [ebp-60h]
  int v242; // [esp+6Ch] [ebp-5Ch]
  int v243; // [esp+6Ch] [ebp-5Ch]
  node *node; // [esp+70h] [ebp-58h]
  node *nodea; // [esp+70h] [ebp-58h]
  int v246; // [esp+74h] [ebp-54h]
  int v247; // [esp+74h] [ebp-54h]
  int x; // [esp+78h] [ebp-50h]
  int xa; // [esp+78h] [ebp-50h]
  int xb; // [esp+78h] [ebp-50h]
  int xc; // [esp+78h] [ebp-50h]
  int width; // [esp+7Ch] [ebp-4Ch]
  int widtha; // [esp+7Ch] [ebp-4Ch]
  int widthb; // [esp+7Ch] [ebp-4Ch]
  int widthc; // [esp+7Ch] [ebp-4Ch]
  int widthd; // [esp+7Ch] [ebp-4Ch]
  int j; // [esp+80h] [ebp-48h]
  int v258; // [esp+80h] [ebp-48h]
  int v259; // [esp+80h] [ebp-48h]
  int v260; // [esp+80h] [ebp-48h]
  int v261; // [esp+80h] [ebp-48h]
  int v262; // [esp+84h] [ebp-44h]
  unsigned __int8 *v263; // [esp+84h] [ebp-44h]
  int v264; // [esp+84h] [ebp-44h]
  unsigned __int8 *v265; // [esp+84h] [ebp-44h]
  unsigned __int8 *v266; // [esp+84h] [ebp-44h]
  unsigned __int8 *v267; // [esp+84h] [ebp-44h]
  unsigned __int8 *y; // [esp+84h] [ebp-44h]
  int v269; // [esp+84h] [ebp-44h]
  signed int n; // [esp+88h] [ebp-40h]
  size_t na; // [esp+88h] [ebp-40h]
  int nb; // [esp+88h] [ebp-40h]
  signed int nc; // [esp+88h] [ebp-40h]
  size_t nd; // [esp+88h] [ebp-40h]
  signed int ne; // [esp+88h] [ebp-40h]
  int nf; // [esp+88h] [ebp-40h]
  size_t ng; // [esp+88h] [ebp-40h]
  size_t nh; // [esp+88h] [ebp-40h]
  table_elinks *v279; // [esp+8Ch] [ebp-3Ch]
  table_elinks *min_cols_widths; // [esp+8Ch] [ebp-3Ch]
  table_elinks *v281; // [esp+8Ch] [ebp-3Ch]
  table_elinks *v282; // [esp+8Ch] [ebp-3Ch]
  table_elinks *cy; // [esp+8Ch] [ebp-3Ch]
  table_elinks *v284; // [esp+8Ch] [ebp-3Ch]
  int v285; // [esp+90h] [ebp-38h]
  document **v286; // [esp+90h] [ebp-38h]
  int v287; // [esp+90h] [ebp-38h]
  int v288; // [esp+90h] [ebp-38h]
  unsigned __int8 *v289; // [esp+90h] [ebp-38h]
  int v290; // [esp+90h] [ebp-38h]
  int v291; // [esp+90h] [ebp-38h]
  int v292; // [esp+90h] [ebp-38h]
  int v293; // [esp+90h] [ebp-38h]
  document **v294; // [esp+90h] [ebp-38h]
  int v295; // [esp+90h] [ebp-38h]
  unsigned __int8 *v296; // [esp+90h] [ebp-38h]
  unsigned __int8 *startn; // [esp+94h] [ebp-34h]
  unsigned __int8 *start; // [esp+94h] [ebp-34h]
  unsigned __int8 *starta; // [esp+94h] [ebp-34h]
  unsigned __int8 *startb; // [esp+94h] [ebp-34h]
  unsigned __int8 *startc; // [esp+94h] [ebp-34h]
  int startd; // [esp+94h] [ebp-34h]
  unsigned __int8 *starte; // [esp+94h] [ebp-34h]
  unsigned __int8 *startf; // [esp+94h] [ebp-34h]
  unsigned __int8 *startg; // [esp+94h] [ebp-34h]
  unsigned __int8 *starth; // [esp+94h] [ebp-34h]
  unsigned __int8 *starti; // [esp+94h] [ebp-34h]
  unsigned __int8 *startj; // [esp+94h] [ebp-34h]
  unsigned __int8 *startk; // [esp+94h] [ebp-34h]
  int startl; // [esp+94h] [ebp-34h]
  unsigned __int8 *startm; // [esp+94h] [ebp-34h]
  void *s; // [esp+98h] [ebp-30h]
  char *sa; // [esp+98h] [ebp-30h]
  table_cell *sb; // [esp+98h] [ebp-30h]
  int sc; // [esp+98h] [ebp-30h]
  void *sd; // [esp+98h] [ebp-30h]
  document **se; // [esp+98h] [ebp-30h]
  int sf; // [esp+98h] [ebp-30h]
  char *sg; // [esp+98h] [ebp-30h]
  char *sh; // [esp+98h] [ebp-30h]
  int sq; // [esp+98h] [ebp-30h]
  int si; // [esp+98h] [ebp-30h]
  int sj; // [esp+98h] [ebp-30h]
  document **sk; // [esp+98h] [ebp-30h]
  int sl; // [esp+98h] [ebp-30h]
  document *sm; // [esp+98h] [ebp-30h]
  void *sn; // [esp+98h] [ebp-30h]
  char *so; // [esp+98h] [ebp-30h]
  void *sp; // [esp+98h] [ebp-30h]
  int link_num; // [esp+9Ch] [ebp-2Ch]
  int link_numa; // [esp+9Ch] [ebp-2Ch]
  int link_numb; // [esp+9Ch] [ebp-2Ch]
  int link_numc; // [esp+9Ch] [ebp-2Ch]
  int link_numd; // [esp+9Ch] [ebp-2Ch]
  int link_nume; // [esp+9Ch] [ebp-2Ch]
  int link_numf; // [esp+9Ch] [ebp-2Ch]
  int link_numg; // [esp+9Ch] [ebp-2Ch]
  int link_numh; // [esp+9Ch] [ebp-2Ch]
  int link_numi; // [esp+9Ch] [ebp-2Ch]
  int link_numj; // [esp+9Ch] [ebp-2Ch]
  int link_numk; // [esp+9Ch] [ebp-2Ch]
  table_frames result; // [esp+ACh] [ebp-1Ch] BYREF

  part = html_context->part;
  v5 = 1;
  ++html_context->table_level;
  if ( !part->document )
    v5 = part->box.x != 0;
  v6 = parse_table(html, eof, end, attr, v5, html_context);
  if ( !v6 )
    goto ret0;
  v6->part = part;
  s = (void *)v6->bad_html_size;
  v7 = 0;
  v8 = (unsigned __int8 *)v6;
  while ( v7 < (int)s )
  {
    v9 = *((_DWORD *)v8 + 35) + 8 * v7;
    v10 = *(unsigned __int8 **)v9;
    v11 = *(unsigned __int8 **)(v9 + 4);
    if ( *(_DWORD *)v9 < (unsigned int)v11 )
    {
      v220 = v8;
      v12 = __ctype_b_loc();
      v8 = v220;
      v13 = *v12;
      while ( (v13[*v10] & 0x2000) != 0 )
      {
        if ( v11 <= ++v10 )
          goto LABEL_17;
      }
      if ( v11 > v10 )
      {
        while ( (v13[*(v11 - 1)] & 0x2000) != 0 )
        {
          if ( v11 - 1 <= v10 )
            goto LABEL_17;
          --v11;
        }
        if ( v11 > v10 )
        {
          parse_html(v10, v11, *(part **)v220, 0, html_context);
          v8 = v220;
          s = (void *)*((_DWORD *)v220 + 36);
        }
      }
    }
LABEL_17:
    ++v7;
  }
  v14 = (document ***)v8;
  state = init_html_parser_state(html_context, ELEMENT_DONT_KILL, 0, 0, 0);
  margins = *((_DWORD *)html_context->stack.next + 30) + *((_DWORD *)html_context->stack.next + 31);
  document = (document *)*v14;
  v15 = *v14;
  v233 = 0;
  v234 = 0;
  v232 = v14[20];
  while ( 1 )
  {
    v16 = (document **)v15[12];
    if ( (*((_BYTE *)html_context->options + 68) & 8) != 0 )
    {
      sa = 0;
      if ( (int)v14[15] <= 0 )
        goto LABEL_34;
      link_num = (int)v15[12];
      v17 = v14;
      do
      {
        if ( (int)v17[16] > 0 )
        {
          v18 = v17[17];
          v19 = 0;
          while ( 1 )
          {
            v20 = (int)&v17[1][16 * (_DWORD)&sa[v19 * (_DWORD)v18]];
            if ( *(_DWORD *)v20 )
            {
              v21 = *(unsigned __int8 **)(v20 + 4);
              *(_DWORD *)(v20 + 56) = link_num;
              v22 = (int)v17[20];
              startn = *(unsigned __int8 **)v20;
              *(_DWORD *)(v20 + 40) = -1;
              *(_DWORD *)(v20 + 44) = -1;
              v23 = format_html_part(html_context, startn, v21, 0, v22, 0, 0, 0, 0, 0, link_num);
              if ( v23 )
              {
                start = (unsigned __int8 *)v23->box.width;
                *(_DWORD *)(v20 + 40) = start;
                max_width = v23->max_width;
                *(_DWORD *)(v20 + 44) = max_width;
                link_num = v23->link_num;
                if ( !assert_failed )
                {
                  assert_failed = (int)start > max_width;
                  if ( (int)start > max_width )
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 119;
                    v221 = (unsigned __int8 *)v23;
                    elinks_internal(
                      "assertion *min <= *max failed: get_cell_width: %d > %d",
                      *(_DWORD *)(v20 + 40),
                      *(_DWORD *)(v20 + 44));
                    v23 = (part *)v221;
                  }
                }
                mem_free(v23);
              }
            }
            if ( ++v19 >= (int)v17[16] )
              break;
            v18 = v17[17];
          }
        }
        ++sa;
      }
      while ( (int)sa < (int)v17[15] );
      goto LABEL_33;
    }
    sc = 0;
    if ( (int)v14[16] > 0 )
    {
      link_num = (int)v15[12];
      v17 = v14;
      do
      {
        for ( i = 0; i < (int)v17[15]; ++i )
        {
          v65 = (int)&v17[1][16 * (i + (_DWORD)v17[17] * sc)];
          if ( *(_DWORD *)v65 )
          {
            v66 = *(unsigned __int8 **)(v65 + 4);
            v67 = *(unsigned __int8 **)v65;
            *(_DWORD *)(v65 + 56) = link_num;
            v68 = (int)v17[20];
            *(_DWORD *)(v65 + 40) = -1;
            *(_DWORD *)(v65 + 44) = -1;
            v69 = format_html_part(html_context, v67, v66, 0, v68, 0, 0, 0, 0, 0, link_num);
            if ( v69 )
            {
              startc = (unsigned __int8 *)v69->box.width;
              *(_DWORD *)(v65 + 40) = startc;
              v70 = v69->max_width;
              *(_DWORD *)(v65 + 44) = v70;
              link_num = v69->link_num;
              if ( !assert_failed )
              {
                assert_failed = (int)startc > v70;
                if ( (int)startc > v70 )
                {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                  errline = 119;
                  v222 = (unsigned __int8 *)v69;
                  elinks_internal(
                    "assertion *min <= *max failed: get_cell_width: %d > %d",
                    *(_DWORD *)(v65 + 40),
                    *(_DWORD *)(v65 + 44));
                  v69 = (part *)v222;
                }
              }
              mem_free(v69);
            }
          }
        }
        ++sc;
      }
      while ( sc < (int)v17[16] );
LABEL_33:
      v14 = v17;
      v16 = (document **)link_num;
    }
LABEL_34:
    cols = (signed int)v14[15];
    v14[30] = v16;
    if ( !cols )
      goto ret2;
    if ( !v14[9] )
    {
      v155 = (document **)mem_calloc(cols, 4u);
      v14[9] = v155;
      if ( !v155 )
        goto LABEL_393;
      cols = (signed int)v14[15];
    }
    if ( !v14[10] )
      break;
LABEL_37:
    if ( !v14[11] )
    {
      v154 = (document **)mem_calloc(cols, 4u);
      v14[11] = v154;
      if ( !v154 )
      {
        if ( v14[9] )
          mem_free(v14[9]);
        v157 = v14[10];
        v14[9] = 0;
        if ( v157 )
          mem_free(v157);
        v14[10] = 0;
        v16 = v14[30];
        goto ret2;
      }
      cols = (signed int)v14[15];
    }
    link_numa = 1;
    v279 = (table_elinks *)v14;
    while ( 1 )
    {
      if ( cols <= 0 )
      {
        v14 = (document ***)v279;
LABEL_180:
        v73 = 0;
        v76 = 0;
        goto LABEL_141;
      }
      v246 = 0;
      v242 = 1;
      for ( j = 0x7FFFFFFF; ; j = v262 )
      {
        width = v242 - 1;
        v262 = j;
        if ( v279->rows <= 0 )
          goto LABEL_60;
        real_cols = v279->real_cols;
        n = 0;
LABEL_45:
        sb = &v279->cells[width + n * real_cols];
        if ( (*((_BYTE *)sb + 60) & 3) != 1 )
          goto LABEL_43;
        if ( assert_failed
          || (v29 = sb->colspan + width <= v279->cols, assert_failed = sb->colspan + width > v279->cols, !v29)
          && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
              errline = 292,
              elinks_internal("assertion cell->colspan + col <= table->cols failed: colspan out of table"),
              assert_failed) )
        {
          v14 = (document ***)v279;
          assert_failed = 0;
          v16 = (document **)v279->link_num;
          goto ret2;
        }
        colspan = (unsigned __int8 *)sb->colspan;
        v262 = (int)colspan;
        if ( colspan == (unsigned __int8 *)link_numa )
        {
          x = 0;
          if ( link_numa <= 1 )
            goto LABEL_75;
          v32 = 1;
          v33 = 0;
          v34 = v242;
          starta = (unsigned __int8 *)(16 * v242);
          while ( 1 )
          {
            v35 = 0;
            if ( v34 )
            {
              rules = v279->rules;
              if ( (unsigned int)(rules - 2) > 1 )
              {
                if ( rules == 4 && v279->columns_count > v34 )
                {
                  v35 = 1;
                  if ( *(int *)((char *)&v279->columns->group + (unsigned int)starta) )
                    goto LABEL_66;
                }
              }
              else
              {
                cellspacing = v279->cellspacing;
                if ( cellspacing )
                {
                  v35 = cellspacing >= 0;
                  goto LABEL_66;
                }
              }
              v35 = v279->cellpadding == 0;
            }
LABEL_66:
            v33 += v35;
            ++v32;
            ++v34;
            starta += 16;
            if ( link_numa <= v32 )
            {
              x = v33;
LABEL_75:
              node = (node *)v279->max_cols_widths;
              v38 = (char *)node + v246 * 4;
              max_cols_widths = (int *)node;
              v40 = 0;
              v41 = sb->min_width - x;
              v42 = &v279->min_cols_widths[v246];
              v43 = 0;
              if ( v262 > 0 )
              {
                do
                  v43 += v42[v40++];
                while ( v40 != link_numa );
                max_cols_widths = v279->max_cols_widths;
              }
              if ( v41 <= v43 )
                goto LABEL_91;
              v44 = (v41 - v43) / v262;
              v45 = (v41 - v43) % v262;
              v285 = v45;
              v46 = v44;
              startb = (unsigned __int8 *)v44;
              if ( !v38 )
              {
                if ( v262 > 0 )
                  goto LABEL_87;
                goto LABEL_90;
              }
              if ( v262 <= 0 )
              {
                v53 = sb->max_width - x;
LABEL_106:
                v54 = 0;
                if ( v53 > 0 )
                  goto LABEL_95;
                goto LABEL_107;
              }
              v47 = 0;
              v48 = 0;
              do
              {
                v49 = (int)&startb[v42[v48] + (v285 > v48)];
                v42[v48] = v49;
                v50 = *(_DWORD *)&v38[4 * v48];
                v51 = v49 - v50;
                if ( v51 > 0 )
                {
                  v47 += v51;
                  v42[v48] = v50;
                }
                ++v48;
              }
              while ( v48 != link_numa );
              if ( !v47 )
              {
                max_cols_widths = v279->max_cols_widths;
                v53 = sb->max_width - x;
                v38 = (char *)&max_cols_widths[v246];
                goto LABEL_92;
              }
              v45 = v47 % link_numa;
              v46 = v47 / link_numa;
LABEL_87:
              v52 = 0;
              do
              {
                v42[v52] += v46 + (v45 > v52);
                ++v52;
              }
              while ( v52 != link_numa );
              node = (node *)v279->max_cols_widths;
LABEL_90:
              max_cols_widths = (int *)node;
              v38 = (char *)node + v246 * 4;
LABEL_91:
              v53 = sb->max_width - x;
              if ( v262 <= 0 )
                goto LABEL_106;
LABEL_92:
              v54 = 0;
              v55 = 0;
              do
                v54 += *(_DWORD *)&v38[4 * v55++];
              while ( v55 != link_numa );
              if ( v53 > v54 )
              {
LABEL_95:
                v56 = (v53 - v54) % v262;
                v57 = (v53 - v54) / v262;
                if ( v262 > 0 )
                {
                  v58 = 0;
                  do
                  {
                    *(_DWORD *)&v38[4 * v58] += v57 + (v56 > v58);
                    ++v58;
                  }
                  while ( v58 != link_numa );
                  max_cols_widths = v279->max_cols_widths;
                  goto LABEL_99;
                }
                goto LABEL_43;
              }
LABEL_107:
              if ( v262 > 0 )
              {
LABEL_99:
                v59 = max_cols_widths;
                v60 = v246 * 4;
                v61 = 0;
                while ( 1 )
                {
                  v62 = (int *)((char *)v59 + v60);
                  v63 = *(int *)((char *)v279->min_cols_widths + v60);
                  if ( v63 > *v62 )
                    *v62 = v63;
                  ++v61;
                  v60 += 4;
                  if ( v262 <= v61 )
                    break;
                  v59 = v279->max_cols_widths;
                }
              }
LABEL_43:
              v27 = v279;
              ++n;
              v262 = j;
              if ( n >= v279->rows )
                goto LABEL_59;
LABEL_44:
              real_cols = v279->real_cols;
              j = v262;
              goto LABEL_45;
            }
          }
        }
        if ( (int)colspan <= link_numa || j <= (int)colspan )
          goto LABEL_43;
        v27 = v279;
        if ( ++n < v279->rows )
          goto LABEL_44;
LABEL_59:
        cols = v27->cols;
LABEL_60:
        v31 = v242;
        ++v246;
        ++v242;
        if ( cols <= v31 )
          break;
      }
      if ( v262 == 0x7FFFFFFF )
        break;
      link_numa = v262;
    }
    v14 = (document ***)v279;
    if ( cols <= 0 )
      goto LABEL_180;
    v71 = 0;
    min_cols_widths = (table_elinks *)v279->min_cols_widths;
    v72 = -1;
    v286 = v14[10];
    v73 = 0;
    na = 0;
    while ( 1 )
    {
      v74 = v72 >= 0;
      na += v74 + *((_DWORD *)&min_cols_widths->part + v71);
      v73 += (signed int)v286[v71] + v74;
      v75 = (int)v14[12][v71];
      if ( (int)v286[v71] < v75 )
        v73 += v75;
      if ( ++v71 == cols )
        break;
      if ( !v71 )
        goto LABEL_134;
      v72 = (int)v14[24];
      if ( (unsigned int)(v72 - 2) <= 1 )
      {
        v72 = (int)v14[22];
        if ( !v72 )
        {
LABEL_133:
          v72 = 0;
          if ( v14[20] )
LABEL_134:
            v72 = -1;
        }
      }
      else
      {
        if ( v72 != 4 )
          goto LABEL_133;
        if ( v71 >= (int)v14[7] )
          goto LABEL_133;
        LOBYTE(v72) = 1;
        if ( !v14[6][4 * v71] )
          goto LABEL_133;
      }
    }
    v76 = na;
LABEL_141:
    get_table_frames((table_elinks *)v14, &result);
    v14[28] = (document **)(v76 + ((*(_BYTE *)&result & 8) != 0) + ((*(_BYTE *)&result & 4) != 0));
    v14[29] = (document **)(v73 + ((*(_BYTE *)&result & 8) != 0) + ((*(_BYTE *)&result & 4) != 0));
    if ( !assert_failed )
    {
      assert_failed = v76 > v73;
      if ( v76 > v73 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
        errline = 351;
        elinks_internal("assertion min <= max failed: min(%d) > max(%d)", v76, v73);
      }
    }
    if ( !document->next && !document->options.cp )
    {
      if ( ((_BYTE)v14[31] & 1) != 0 )
      {
        v177 = v14[29];
      }
      else
      {
        v177 = v14[25];
        if ( (int)v177 < (int)v14[29] )
          v14[29] = v177;
        else
          v177 = v14[29];
      }
      v178 = v14[28];
      if ( (int)v178 > (int)v177 )
        v14[29] = v178;
      else
        v178 = v177;
      v179 = (int)v178 + margins;
      if ( v179 > document->options.num_links_key )
        document->options.num_links_key = v179;
      v180 = (char *)v14[28] + margins;
      if ( (int)v180 > document->options.hard_assume )
      {
        document->options.hard_assume = (int)v180;
        v16 = v14[30];
        goto ret2;
      }
LABEL_393:
      v16 = v14[30];
      goto ret2;
    }
    if ( v234 )
    {
      if ( v234 == 1 )
      {
        v79 = v14[28];
        if ( (int)v79 > (int)v233 )
        {
          v14[20] = v232;
          v234 = 2;
          v15 = *v14;
          continue;
        }
        v78 = v14[25];
      }
      else
      {
        v78 = v14[25];
        v79 = v14[28];
      }
LABEL_172:
      v77 = v79;
      if ( (int)v79 < (int)v78 )
      {
        v77 = v14[29];
        if ( (int)v77 >= (int)v78 || ((_BYTE)v14[31] & 1) == 0 )
          v77 = v78;
      }
LABEL_149:
      v80 = (int)v14[15];
      if ( v80 )
      {
        v81 = (char *)v77 - (char *)v79;
        link_numb = (char *)v77 - (char *)v79;
        if ( !assert_failed )
        {
          assert_failed = (unsigned int)v81 >> 31;
          if ( v81 < 0 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
            errline = 493;
            elinks_internal("assertion spare_width >= 0 failed: too small width %d, required %d", v77, v14[28]);
          }
          v80 = (int)v14[15];
        }
        v82 = 0;
        v83 = 0;
        while ( v82 < v80 )
        {
          if ( (int)v83 < (int)v14[10][v82] )
            v83 = (table_elinks *)v14[10][v82];
          ++v82;
        }
        v281 = v83;
        nb = 4 * v80;
        v84 = 4 * v80;
        memcpy(v14[11], v14[9], 4 * v80);
        v14[26] = v77;
        sd = mem_alloc(v84);
        if ( sd )
        {
          v85 = mem_alloc(v84);
          if ( !v85 )
            goto LABEL_208;
          v287 = 0;
          while ( 2 )
          {
            if ( link_numb )
            {
              v86 = 0;
              memset(sd, 0, nb);
              memset(v85, 0, nb);
              v87 = (int *)sd;
              v88 = v14[15];
              startd = 0;
              v263 = 0;
              widtha = (int)v85;
              while ( 2 )
              {
                if ( (int)v263 < (int)v88 )
                {
                  switch ( v287 )
                  {
                    case 0:
                      if ( (int)v14[11][v86] >= (int)v14[12][v86] )
                        goto LABEL_413;
                      *v87 = 1;
                      v173 = v14[10][v86];
                      if ( (int)v14[12][v86] <= (int)v173 )
                        v173 = v14[12][v86];
                      v174 = (char *)v173 - (char *)v14[11][v86];
                      *(_DWORD *)(widtha + v86 * 4) = v174;
                      if ( v174 > 0 )
                        goto LABEL_400;
                      goto LABEL_411;
                    case 1:
                      v176 = (int)v14[12][v86];
                      if ( v176 >= -1 )
                        goto LABEL_413;
                      *v87 = -2 - v176;
                      v168 = v14[10];
                      goto LABEL_399;
                    case 2:
                      if ( v14[12][v86] == (document *)-1 )
                        goto LABEL_403;
                      goto LABEL_413;
                    case 3:
LABEL_403:
                      v171 = v14[11][v86];
                      v172 = v14[10][v86];
                      if ( (int)v171 >= (int)v172 )
                        goto LABEL_413;
                      *(_DWORD *)(widtha + v86 * 4) = (char *)v172 - (char *)v171;
                      if ( v281 )
                      {
                        v170 = 10 * (int)v14[10][v86] / (int)v281 + 5;
                        *v87 = v170;
                      }
                      else
                      {
                        *v87 = 1;
                        v170 = 1;
                      }
                      v88 = v14[15];
                      goto LABEL_401;
                    case 4:
                      if ( (int)v14[12][v86] < 0 )
                        goto LABEL_413;
                      *v87 = 1;
                      v168 = v14[12];
LABEL_399:
                      v169 = (char *)v168[v86] - (char *)v14[11][v86];
                      *(_DWORD *)(widtha + v86 * 4) = v169;
                      if ( v169 > 0 )
                        goto LABEL_400;
LABEL_411:
                      *v87 = 0;
                      v170 = 0;
                      v88 = v14[15];
                      goto LABEL_401;
                    case 5:
                      v175 = (int)v14[12][v86];
                      if ( v175 < 0 )
                      {
                        if ( v175 == -1 )
                          *v87 = 1;
                        else
                          *v87 = -2 - v175;
                        *(_DWORD *)(widtha + v86 * 4) = 0x7FFFFFFF;
                        v170 = *v87;
                        v88 = v14[15];
                      }
                      else
                      {
LABEL_413:
                        v170 = *v87;
                      }
                      goto LABEL_401;
                    case 6:
                      *v87 = 1;
                      *(_DWORD *)(widtha + v86 * 4) = 0x7FFFFFFF;
LABEL_400:
                      v170 = *v87;
                      v88 = v14[15];
LABEL_401:
                      startd += v170;
                      ++v87;
                      ++v263;
                      ++v86;
                      continue;
                    default:
                      v85 = (void *)widtha;
                      startd = -1;
                      goto LABEL_167;
                  }
                }
                break;
              }
              v85 = (void *)widtha;
LABEL_167:
              if ( assert_failed
                || (assert_failed = startd == -1) != 0
                && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
                    errline = 515,
                    elinks_internal("assertion total_width != -1 failed: Could not expand table"),
                    assert_failed) )
              {
                assert_failed = 0;
                break;
              }
              v89 = link_numb;
              if ( !startd )
                goto LABEL_170;
              widthb = (int)v85;
LABEL_184:
              v258 = (int)v14[15];
              if ( v258 <= 0 )
              {
LABEL_202:
                v85 = (void *)widthb;
                if ( link_numb != v89 )
                {
LABEL_203:
                  link_numb = v89;
                  continue;
                }
LABEL_170:
                ++v287;
                continue;
              }
              v264 = -1;
              v90 = 0;
              v91 = 0;
              while ( 1 )
              {
                v94 = *((_DWORD *)sd + v91);
                if ( !v94 )
                  goto LABEL_193;
                v92 = link_numb * v94 / startd;
                v93 = 1;
                if ( v92 > 0 )
                {
                  v93 = *(_DWORD *)(widthb + 4 * v91);
                  if ( v92 <= v93 )
                    v93 = v92;
                }
                if ( v93 > v90 )
                {
                  v264 = v91++;
                  if ( v91 == v258 )
                    goto LABEL_194;
                }
                else
                {
LABEL_193:
                  ++v91;
                  v93 = v90;
                  if ( v91 == v258 )
                  {
LABEL_194:
                    v95 = v93;
                    if ( v264 == -1 )
                      goto LABEL_202;
                    if ( v93 > v89 )
                      v95 = v89;
                    *((_DWORD *)sd + v264) = 0;
                    if ( !assert_failed )
                    {
                      assert_failed = (unsigned int)v95 >> 31;
                      if ( v95 < 0 )
                      {
                        v223 = (unsigned __int8 *)v95;
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                        errline = 468;
                        elinks_internal("assertion stretch_width >= 0 failed: shrinking cell");
                        v95 = (int)v223;
                      }
                    }
                    v14[11][v264] = (document *)((char *)v14[11][v264] + v95);
                    v89 -= v95;
                    if ( !v89 )
                    {
                      v85 = (void *)widthb;
                      goto LABEL_203;
                    }
                    goto LABEL_184;
                  }
                }
                v90 = v93;
              }
            }
            break;
          }
          mem_free(v85);
LABEL_208:
          mem_free(sd);
        }
      }
      if ( !part->document && part->box.x == 1 )
      {
        v106 = v14[26];
        v107 = (document **)((char *)v106 + margins);
        if ( (int)v106 <= (int)v106 + margins )
        {
          v106 = (document **)*((_DWORD *)html_context->stack.next + 32);
          if ( (int)v107 <= (int)v106 )
            v106 = v107;
        }
        v108 = part;
        if ( part->box.width < (int)v106 )
LABEL_245:
          v108->box.width = (int)v106;
LABEL_246:
        part->cy += (int)v14[27];
        v16 = v14[30];
        goto ret2;
      }
      v282 = (table_elinks *)mem_calloc((size_t)v14[15], 4u);
      if ( !v282 )
        goto LABEL_262;
      v96 = v14[15];
      nc = 0;
      se = v96;
LABEL_212:
      if ( nc < (int)v14[16] )
      {
        for ( link_numc = 0; ; ++link_numc )
        {
          if ( (int)v96 <= link_numc )
          {
            ++nc;
            goto LABEL_212;
          }
          v97 = (int)&v14[1][16 * (link_numc + (_DWORD)v14[17] * nc)];
          v265 = *(unsigned __int8 **)v97;
          if ( *(_DWORD *)v97 )
          {
            v288 = *(_DWORD *)(v97 + 32);
            if ( v288 > 0 )
            {
              v98 = 0;
              v99 = 0;
              v100 = &v14[11][link_numc];
              while ( 1 )
              {
                v101 = *v100;
                v102 = v99 + link_numc;
                if ( !v99 || !v102 )
                  goto LABEL_218;
                startf = (unsigned __int8 *)v14[24];
                if ( (unsigned int)(startf - 2) <= 1 )
                {
                  if ( !v14[22] )
                    goto LABEL_223;
                  if ( (int)v14[22] >= 0 )
                    goto LABEL_224;
LABEL_218:
                  ++v99;
                  ++v100;
                  starte = (unsigned __int8 *)v14[20];
                  v98 += (int)v101;
                  if ( v99 == v288 )
                    goto LABEL_225;
                }
                else
                {
                  if ( startf == (unsigned __int8 *)4 && v102 < (int)v14[7] && v14[6][4 * v102] )
                    goto LABEL_224;
LABEL_223:
                  if ( v14[20] )
                    goto LABEL_218;
LABEL_224:
                  ++v99;
                  ++v100;
                  v98 += (int)&v101->next + 1;
                  starte = (unsigned __int8 *)v14[20];
                  if ( v99 == v288 )
                  {
LABEL_225:
                    v97 = (int)&v14[1][16 * (link_numc + (_DWORD)v14[17] * nc)];
                    goto LABEL_226;
                  }
                }
              }
            }
            v98 = 0;
            starte = (unsigned __int8 *)v14[20];
LABEL_226:
            v103 = *(_DWORD *)(v97 + 56);
            v104 = *(unsigned __int8 **)(v97 + 4);
            *(_DWORD *)(v97 + 48) = -1;
            v105 = format_html_part(html_context, v265, v104, 0, (int)starte, v98, 0, 1, 1, 0, v103);
            if ( v105 )
            {
              *(_DWORD *)(v97 + 48) = v105->box.width;
              mem_free(v105);
            }
            if ( v98 < *(_DWORD *)(v97 + 48) )
              *(_DWORD *)(v97 + 48) = v98;
            v96 = v14[15];
          }
          se = v96;
        }
      }
      v109 = 1;
      while ( 2 )
      {
        v266 = 0;
        v259 = 1;
        link_numd = 0x7FFFFFFF;
LABEL_249:
        xa = v259 - 1;
        if ( (int)se > v259 - 1 )
        {
          v110 = v14[16];
          v111 = &v266[(_DWORD)v282];
          for ( widthc = 0; ; ++widthc )
          {
            if ( widthc >= (int)v110 )
            {
              ++v259;
              v266 += 4;
              se = v14[15];
              goto LABEL_249;
            }
            v112 = link_numd;
            v113 = (unsigned __int8 *)&v14[1][16 * (xa + (_DWORD)v14[17] * widthc)];
            if ( *(_DWORD *)v113 )
              break;
LABEL_256:
            link_numd = v112;
          }
          if ( assert_failed
            || (v29 = *((_DWORD *)v113 + 8) + xa <= (int)v14[15],
                assert_failed = *((_DWORD *)v113 + 8) + xa > (int)v14[15],
                !v29)
            && (v226 = v113,
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c",
                errline = 621,
                elinks_internal("assertion cell->colspan + col <= table->cols failed: colspan out of table"),
                v113 = v226,
                assert_failed) )
          {
            assert_failed = 0;
            goto LABEL_261;
          }
          v112 = *((_DWORD *)v113 + 8);
          if ( v112 != v109 )
          {
            if ( v112 > v109 && v112 < link_numd )
            {
              v110 = v14[16];
              goto LABEL_256;
            }
            goto LABEL_282;
          }
          v290 = 0;
          if ( v109 > 1 )
          {
            ne = 1;
            starth = (unsigned __int8 *)(16 * v259);
            sg = (char *)v259;
            do
            {
              v126 = 0;
              if ( sg )
              {
                v126 = v14[24];
                if ( (unsigned int)v126 - 2 > 1 )
                {
                  if ( v126 == (document **)4 && (int)sg < (int)v14[7] )
                  {
                    LOBYTE(v126) = 1;
                    if ( *(_DWORD *)&starth[(_DWORD)v14[6]] )
                      goto LABEL_289;
                  }
                }
                else
                {
                  v127 = v14[22];
                  if ( v127 )
                  {
                    v126 = (document **)((int)v127 >= 0);
                    goto LABEL_289;
                  }
                }
                v126 = (document **)(v14[20] == 0);
              }
LABEL_289:
              ++ne;
              v290 += (int)v126;
              ++sg;
              starth += 16;
            }
            while ( v109 > ne );
          }
          starti = (unsigned __int8 *)v14[10];
          sh = (char *)(*((_DWORD *)v113 + 12) - v290);
          v128 = 0;
          if ( v112 > 0 )
          {
            v129 = 0;
            do
              v128 += *(_DWORD *)&v111[4 * v129++];
            while ( v129 != v109 );
          }
          if ( (int)sh > v128 )
          {
            sq = (int)&sh[-v128];
            v130 = sq / v112;
            nf = sq % v112;
            si = sq % v112;
            v29 = &starti[(_DWORD)v266] == 0;
            v291 = v130;
            startj = &starti[(_DWORD)v266];
            if ( v29 )
            {
              if ( v112 > 0 )
              {
LABEL_306:
                v135 = 0;
                do
                {
                  *(_DWORD *)&v111[4 * v135] += v130 + (si > v135);
                  ++v135;
                }
                while ( v135 != v109 );
              }
            }
            else if ( v112 > 0 )
            {
              sj = 0;
              v131 = 0;
              do
              {
                v132 = *(_DWORD *)&v111[4 * v131] + v291 + (nf > v131);
                *(_DWORD *)&v111[4 * v131] = v132;
                v133 = *(_DWORD *)&startj[4 * v131];
                v134 = v132 - v133;
                if ( v134 > 0 )
                {
                  sj += v134;
                  *(_DWORD *)&v111[4 * v131] = v133;
                }
                ++v131;
              }
              while ( v131 != v109 );
              if ( sj )
              {
                v130 = sj / v109;
                si = sj % v109;
                goto LABEL_306;
              }
            }
          }
LABEL_282:
          v110 = v14[16];
          v112 = link_numd;
          goto LABEL_256;
        }
        if ( link_numd != 0x7FFFFFFF )
        {
          v109 = link_numd;
          continue;
        }
        break;
      }
      v181 = 0;
      v182 = 0;
      for ( k = 0; (int)se > k; ++k )
      {
        v182 += (int)v14[11][k];
        v181 += *((_DWORD *)&v282->part + k);
      }
      if ( v182 < v181 )
        goto LABEL_261;
      link_numi = 0;
      v184 = -1;
      for ( m = 0; (int)se > m; ++m )
      {
        v186 = v14[10][m];
        if ( (int)v186 > v184 )
          link_numi = m;
        else
          v186 = (document *)v184;
        v184 = (int)v186;
      }
      if ( v184 == -1
        || (v187 = (int *)(&v282->part + link_numi),
            v188 = v182 - v181 + *v187,
            *v187 = v188,
            v188 > (int)v14[10][link_numi]) )
      {
LABEL_261:
        mem_free(v282);
      }
      else
      {
        mem_free(v14[11]);
        v14[11] = (document **)v282;
      }
LABEL_262:
      v114 = (unsigned __int8 *)v14[33];
      v115 = (unsigned __int8 *)v14[32];
      if ( v114 && v115 )
      {
        while ( v114 > v115 )
        {
          if ( ((*__ctype_b_loc())[*v115] & 0x2000) == 0 )
          {
            while ( v114 > v115 )
            {
              if ( ((*__ctype_b_loc())[*(v114 - 1)] & 0x2000) == 0 )
              {
                v214 = format_html_part(
                         html_context,
                         v115,
                         v114,
                         (int)v14[5],
                         0,
                         (int)v14[26],
                         0,
                         0,
                         0,
                         0,
                         (int)v14[30]);
                if ( !v214 )
                  goto LABEL_264;
                height = (document **)v214->box.height;
                mem_free(v214);
                goto LABEL_265;
              }
              --v114;
            }
            break;
          }
          ++v115;
        }
      }
LABEL_264:
      height = 0;
LABEL_265:
      v14[34] = height;
      sf = 0;
LABEL_266:
      v117 = v14[16];
      if ( sf < (int)v117 )
      {
        v118 = v14[15];
        v119 = 0;
        for ( link_nume = 1; ; ++link_nume )
        {
          if ( v119 >= (int)v118 )
          {
            ++sf;
            goto LABEL_266;
          }
          v120 = (int)&v14[1][16 * (v119 + (_DWORD)v14[17] * sf)];
          if ( (*(_BYTE *)(v120 + 60) & 3) == 1 )
          {
            v267 = *(unsigned __int8 **)(v120 + 32);
            if ( (int)v267 > 0 )
            {
              v121 = (int *)&v14[11][v119];
              nd = 4 * link_nume;
              v122 = link_nume;
              startg = 0;
              v289 = 0;
              while ( 1 )
              {
                xb = *v121;
                if ( (int)(v267 - 1) <= (int)v289 || !v122 )
                  goto LABEL_273;
                v124 = v14[24];
                if ( (unsigned int)v124 - 2 > 1 )
                  break;
                if ( !v14[22] )
                  goto LABEL_279;
                if ( (int)v14[22] >= 0 )
                  goto LABEL_280;
LABEL_273:
                v123 = (int)v14[20];
                v260 = 0;
LABEL_274:
                ++v121;
                ++v122;
                ++v289;
                startg += xb + v260;
                nd += 4;
                if ( v289 == v267 )
                  goto LABEL_283;
              }
              if ( v124 == (document **)4 && v122 < (int)v14[7] && v14[6][nd] )
              {
LABEL_280:
                v123 = (int)v14[20];
                v260 = 1;
                goto LABEL_274;
              }
LABEL_279:
              if ( !v14[20] )
                goto LABEL_280;
              goto LABEL_273;
            }
            v123 = (int)v14[20];
            startg = 0;
LABEL_283:
            v125 = format_html_part(
                     html_context,
                     *(unsigned __int8 **)v120,
                     *(unsigned __int8 **)(v120 + 4),
                     *(_DWORD *)(v120 + 24),
                     v123,
                     (int)startg,
                     0,
                     2,
                     2,
                     0,
                     *(_DWORD *)(v120 + 56));
            if ( !v125 )
              goto LABEL_320;
            *(_DWORD *)(v120 + 52) = v125->box.height;
            mem_free(v125);
            v118 = v14[15];
          }
          ++v119;
        }
      }
      v143 = 1;
      while ( 2 )
      {
        link_numg = 0x7FFFFFFF;
        v144 = 0;
LABEL_335:
        if ( (int)v117 > (int)v144 )
        {
          if ( (int)v14[15] <= 0 )
            goto LABEL_347;
          v145 = v144;
          v284 = (table_elinks *)(4 * (_DWORD)v144);
          sl = 0;
          while ( 1 )
          {
            v147 = (int)&v14[1][16 * (sl + (_DWORD)v145 * (_DWORD)v14[17])];
            if ( (*(_BYTE *)(v147 + 60) & 3) != 1 )
              goto LABEL_338;
            v146 = *(_DWORD *)(v147 + 36);
            if ( v146 == v143 )
              break;
            if ( v146 <= v143 || v146 >= link_numg )
              goto LABEL_338;
LABEL_339:
            if ( ++sl >= (int)v14[15] )
            {
              link_numg = v146;
              v117 = v14[16];
              v144 = v145;
LABEL_347:
              ++v144;
              goto LABEL_335;
            }
            link_numg = v146;
          }
          v292 = 0;
          if ( v143 > 1 )
          {
            for ( startl = 1; startl < v143; ++startl )
            {
              v225 = v145;
              hline_width = get_hline_width((table_elinks *)v14, (int)&v145[startl]);
              v145 = v225;
              v292 += hline_width >= 0;
            }
          }
          v149 = 0;
          v150 = *(_DWORD *)(v147 + 52) - v292;
          startm = (unsigned __int8 *)v284 + (_DWORD)v14[14];
          if ( v143 > 0 )
          {
            for ( ii = 0; ii != v143; ++ii )
              v149 += *(_DWORD *)&startm[4 * ii];
          }
          if ( v149 < v150 )
          {
            v293 = (v150 - v149) % v143;
            v152 = (v150 - v149) / v143;
            if ( v143 > 0 )
            {
              for ( jj = 0; jj != v143; ++jj )
                *(_DWORD *)&startm[4 * jj] += v152 + (v293 > jj);
            }
          }
LABEL_338:
          v146 = link_numg;
          goto LABEL_339;
        }
        if ( link_numg != 0x7FFFFFFF )
        {
          v143 = link_numg;
          continue;
        }
        break;
      }
      v215 = 0;
      get_table_frames((table_elinks *)v14, &result);
      v216 = v14[16];
      v217 = (int)v14[34] + ((*(_BYTE *)&result & 2) != 0) + (*(_BYTE *)&result & 1);
      while ( v215 < (int)v216 )
      {
        v217 += (int)v14[14][v215];
        if ( v215 )
        {
          if ( get_hline_width((table_elinks *)v14, v215) >= 0 )
            ++v217;
          v216 = v14[16];
        }
        ++v215;
      }
      v14[27] = (document **)v217;
LABEL_320:
      v108 = part;
      if ( !part->document )
      {
        v106 = (document **)((char *)v14[26] + margins);
        if ( (int)v106 > part->box.width )
          goto LABEL_245;
        goto LABEL_246;
      }
      nodea = (node *)part->document->nodes.next;
      nodea->box.height = part->box.y + part->cy - nodea->box.y;
      next = html_context->stack.next;
      sk = v14[26];
      v137 = v14[5];
      link_numf = (int)v137;
      v138 = next[32] - (_DWORD)sk;
      if ( v137 == (document **)1 )
      {
        v139 = (next[30] + v138 - next[31]) / 2;
      }
      else if ( v137 == (document **)2 )
      {
        v139 = v138 - next[31];
      }
      else
      {
        v139 = next[30];
      }
      if ( v139 <= v138 )
        v138 = v139;
      if ( v138 < 0 )
        v138 = 0;
      startk = (unsigned __int8 *)v138;
      y = (unsigned __int8 *)part->box.y;
      cy = (table_elinks *)part->cy;
      ng = part->box.x;
      v140 = (unsigned __int8 *)v14[33];
      v141 = (unsigned __int8 *)v14[32];
      if ( v140 && v141 )
      {
        while ( v140 > v141 )
        {
          v224 = v140;
          v142 = __ctype_b_loc();
          v140 = v224;
          if ( ((*v142)[*v141] & 0x2000) == 0 )
            break;
          ++v141;
        }
        while ( v141 < v140 )
        {
          v228 = v140;
          v296 = v140 - 1;
          if ( ((*__ctype_b_loc())[*(v140 - 1)] & 0x2000) == 0 )
          {
            v189 = format_html_part(
                     html_context,
                     v141,
                     v228,
                     link_numf,
                     0,
                     (int)sk,
                     **v14,
                     (int)&startk[ng],
                     (int)cy + (_DWORD)y,
                     0,
                     (int)v14[30]);
            if ( v189 )
            {
              (*v14)[11] = (document *)((char *)(*v14)[11] + v189->box.height);
              (*v14)[10] = (document *)-1;
              (*v14)[12] = (document *)v189->link_num;
              mem_free(v189);
            }
            cy = (table_elinks *)part->cy;
            next = html_context->stack.next;
            break;
          }
          v140 = v296;
        }
      }
      v190 = next[37];
      get_table_frames((table_elinks *)v14, &result);
      if ( v14[2] )
        add_fragment_identifier(html_context, (part *)*v14, (unsigned __int8 *)v14[2]);
      expand_lines(html_context, (part *)*v14, (int)(startk - 1), (int)cy, (int)v14[27], v190);
      xc = (int)&startk[(*(_BYTE *)&result & 4) != 0];
      v191 = v14[15];
      v261 = 1;
      v295 = 0;
      while ( 2 )
      {
        if ( v295 >= (int)v191 )
        {
          expand_lines(
            html_context,
            (part *)*v14,
            (int)v14[26] + (_DWORD)startk - 1,
            (int)cy,
            (int)v14[27],
            (color_T)v14[3]);
          check_html_form_hierarchy((part *)*v14);
          v158 = 1;
          v294 = v14[27];
          sm = (*v14)[11];
          v159 = v14[16];
          v160 = (char *)v14[34] + ((*(_BYTE *)&result & 2) != 0) + (*(_BYTE *)&result & 1) + (_DWORD)cy;
          for ( kk = 0; kk < (int)v159; ++kk )
          {
            link_numh = (int)v14[14][kk];
            v162 = 0;
            if ( kk < (int)v159 - 1 )
            {
              v227 = (unsigned __int8 *)v158;
              v212 = get_hline_width((table_elinks *)v14, v158);
              v158 = (int)v227;
              if ( v212 < 0 )
              {
                v159 = v14[16];
                v162 = 0;
              }
              else
              {
                v159 = v14[16];
                v162 = 1;
              }
            }
            ++v158;
            v160 += link_numh + v162;
          }
          if ( !assert_failed )
          {
            assert_failed = (char *)sm + (_DWORD)v294 != v160;
            if ( (char *)sm + (_DWORD)v294 != v160 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
              errline = 704;
              elinks_internal(
                "assertion old_height == our_height failed: size not matching! %d vs %d",
                (char *)sm + (_DWORD)v294,
                v160);
            }
          }
          draw_table_frames((table_elinks *)v14, (int)startk, part->cy, html_context);
          part->cy += (int)v14[27];
          part->cx = -1;
          v163 = mem_alloc(0x18u);
          if ( v163 )
          {
            v164 = nodea->box.width;
            v165 = part->box.y + part->cy;
            v166 = nodea->box.x;
            v167 = 0;
            v163[5] = 0;
            if ( v166 < 0 )
              v166 = 0;
            if ( v165 < 0 )
              v165 = 0;
            if ( v164 >= 0 )
              v167 = v164;
            v163[2] = v166;
            v163[3] = v165;
            v163[4] = v167;
            *v163 = part->document->nodes.next;
            v163[1] = &part->document->nodes;
            part->document->nodes.next = v163;
            *(_DWORD *)(*v163 + 4) = v163;
          }
          goto LABEL_393;
        }
        v247 = 0;
        v269 = 1;
        nh = (size_t)cy + (*(_BYTE *)&result & 1);
        v243 = v295 + 1;
        while ( 2 )
        {
          v192 = v14[16];
          v193 = v269 - 1;
          if ( v269 - 1 < (int)v192 )
          {
            v235 = v14[14][v247];
            if ( v193 >= (int)v192 - 1 || (marginsa = 1, get_hline_width((table_elinks *)v14, v269) < 0) )
              marginsa = 0;
            v194 = (int)&v14[1][16 * (v295 + (_DWORD)v14[17] * v193)];
            documenta = **v14;
            if ( !*(_DWORD *)v194 )
              goto LABEL_491;
            widthd = 0;
            link_numj = *(_DWORD *)(v194 + 32);
            if ( link_numj > 0 )
            {
              v195 = 0;
              sn = (void *)(*(_DWORD *)(v194 + 32) - 1);
              v196 = &v14[11][v295];
              v229 = v194;
              v197 = 0;
              v218 = v14;
              while ( 1 )
              {
                v219 = *v196;
                if ( (int)sn > v195 && v195 + v243 )
                {
                  v208 = v218[24];
                  if ( (unsigned int)v208 - 2 <= 1 )
                  {
                    v209 = v218[22];
                    if ( v209 )
                    {
                      v198 = (int)v209 >= 0;
                      goto LABEL_469;
                    }
                  }
                  else if ( v208 == (document **)4 && v195 + v243 < (int)v218[7] )
                  {
                    v198 = 1;
                    if ( *(&v218[6][4 * v195] + 4 * v243) )
                      goto LABEL_469;
                  }
                  v198 = v218[20] == 0;
                }
                else
                {
                  v198 = 0;
                }
LABEL_469:
                ++v195;
                ++v196;
                v197 += (int)v219 + v198;
                if ( v195 == link_numj )
                {
                  widthd = v197;
                  v14 = v218;
                  v194 = v229;
                  break;
                }
              }
            }
            v199 = *(_DWORD *)(v194 + 36);
            link_numk = 0;
            if ( v199 <= 0 )
              goto LABEL_477;
            v240 = v194;
            v200 = (table_elinks *)v14;
            so = (char *)v269;
            v201 = 0;
            v202 = v247 * 4;
LABEL_473:
            v230 = *(int *)((char *)v200->rows_heights + v202);
            if ( v201 < v199 - 1 )
            {
              if ( get_hline_width(v200, (int)so) < 0 )
              {
                v199 = *(_DWORD *)(v240 + 36);
                goto LABEL_474;
              }
              v203 = 1;
              v199 = *(_DWORD *)(v240 + 36);
            }
            else
            {
LABEL_474:
              v203 = 0;
            }
            ++v201;
            v202 += 4;
            ++so;
            link_numk += v230 + v203;
            if ( v201 >= v199 )
            {
              v14 = (document ***)v200;
              v194 = v240;
LABEL_477:
              sp = init_html_parser_state(html_context, ELEMENT_DONT_KILL, *(_DWORD *)(v194 + 24), 0, 0);
              if ( (*(_BYTE *)(v194 + 60) & 4) != 0 )
                *((_DWORD *)html_context->stack.next + 3) |= 1u;
              *((_DWORD *)html_context->stack.next + 5) = *(_DWORD *)(v194 + 12);
              *((_DWORD *)html_context->stack.next + 37) = *(_DWORD *)(v194 + 12);
              v204 = *(_DWORD *)(v194 + 28);
              if ( v204 == 1 )
              {
                v205 = (link_numk - *(_DWORD *)(v194 + 52)) / 2 + nh;
              }
              else
              {
                v205 = nh;
                if ( v204 == 2 )
                  v205 = link_numk + nh - *(_DWORD *)(v194 + 52);
              }
              v206 = xc;
              if ( documenta )
              {
                v206 = (int)(*v14)[4] + xc;
                v205 += (int)(*v14)[5];
              }
              v207 = format_html_part(
                       html_context,
                       *(unsigned __int8 **)v194,
                       *(unsigned __int8 **)(v194 + 4),
                       *(_DWORD *)(v194 + 24),
                       (int)v14[20],
                       widthd,
                       documenta,
                       v206,
                       v205,
                       0,
                       *(_DWORD *)(v194 + 56));
              if ( v207 )
              {
                if ( !assert_failed )
                {
                  v29 = link_numk >= *(_DWORD *)(v194 + 52);
                  assert_failed = link_numk < *(_DWORD *)(v194 + 52);
                  if ( !v29 )
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/tables.c";
                    errline = 888;
                    elinks_internal("assertion height >= cell->height failed!");
                  }
                }
                expand_lines(html_context, (part *)*v14, widthd + xc - 1, nh, link_numk, *(_DWORD *)(v194 + 12));
                if ( *(_DWORD *)(v194 + 8) )
                  add_fragment_identifier(html_context, v207, *(unsigned __int8 **)(v194 + 8));
                done_html_parser_state(html_context, sp);
                mem_free(v207);
              }
              else
              {
                done_html_parser_state(html_context, sp);
              }
LABEL_491:
              ++v269;
              nh += (size_t)v235 + marginsa;
              ++v247;
              continue;
            }
            goto LABEL_473;
          }
          break;
        }
        v191 = v14[15];
        if ( v295 >= (int)v191 - 1 )
        {
LABEL_509:
          ++v261;
          ++v295;
          continue;
        }
        break;
      }
      v210 = 0;
      if ( v261 )
      {
        v211 = v14[24];
        if ( (unsigned int)v211 - 2 <= 1 )
        {
          v213 = v14[22];
          if ( !v213 )
            goto LABEL_513;
          v210 = (int)v213 >= 0;
        }
        else if ( v211 != (document **)4 || v261 >= (int)v14[7] || (v210 = 1, !v14[6][4 * v261]) )
        {
LABEL_513:
          v210 = v14[20] == 0;
        }
      }
      xc += (int)v14[11][v295] + v210;
      goto LABEL_509;
    }
    v77 = v14[28];
    v78 = v14[25];
    if ( (int)v77 <= (int)v78 )
    {
      v79 = v14[28];
      goto LABEL_172;
    }
    if ( !v14[20] )
    {
      v79 = v14[28];
      goto LABEL_149;
    }
    v14[20] = 0;
    v233 = v77;
    v234 = 1;
    v15 = *v14;
  }
  v156 = (document **)mem_calloc(cols, 4u);
  v14[10] = v156;
  if ( v156 )
  {
    cols = (signed int)v14[15];
    goto LABEL_37;
  }
  if ( v14[9] )
    mem_free(v14[9]);
  v14[9] = 0;
  v16 = v14[30];
ret2:
  part->link_num = (int)v16;
  v28 = part->cy;
  if ( v28 > part->box.height )
    part->box.height = v28;
  html_context->part = part;
  done_html_parser_state(html_context, state);
  free_table((table_elinks *)v14);
ret0:
  v29 = html_context->table_level-- == 1;
  if ( v29 )
    free_table_cache();
}

//----- (080965B0) --------------------------------------------------------
form_control *__usercall init_form_control@<eax>(
        form_type type@<eax>,
        unsigned __int8 *attr@<edx>,
        html_context *html_context@<ecx>)
{
  _DWORD *v5; // eax
  _DWORD *v6; // edi
  unsigned __int8 *attr_value; // eax
  int v8; // edx

  v5 = mem_calloc(1u, 0x54u);
  v6 = v5;
  if ( v5 )
  {
    v5[5] = type;
    v5[4] = attr - html_context->startf;
    attr_value = get_attr_value(attr, "disabled", html_context->doc_cp, HTML_ATTR_TEST);
    v8 = 2;
    if ( !attr_value )
      v8 = get_attr_value(attr, "readonly", html_context->doc_cp, HTML_ATTR_TEST) != 0;
    v6[6] = v8;
  }
  return (form_control *)v6;
}

//----- (08096660) --------------------------------------------------------
void __cdecl html_textarea(
        html_context *html_context,
        unsigned __int8 *attr,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_context *v5; // edi
  unsigned __int8 *v6; // esi
  unsigned __int8 *j; // ebx
  char *v8; // esi
  char v9; // al
  html_context *v10; // edx
  char *v11; // ebx
  char *v12; // edi
  int num; // eax
  document_options *options; // edx
  int v15; // eax
  int width; // ebx
  int v17; // eax
  int height; // esi
  unsigned __int8 *attr_value; // eax
  int v20; // eax
  char *v21; // edx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // esi
  int k; // ebx
  size_t v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  char *s1; // [esp+2Ch] [ebp-3Ch]
  char *s1a; // [esp+2Ch] [ebp-3Ch]
  int v35; // [esp+30h] [ebp-38h]
  form_control *fc; // [esp+34h] [ebp-34h]
  int v37; // [esp+38h] [ebp-30h]
  int i; // [esp+3Ch] [ebp-2Ch]
  int t_namelen; // [esp+48h] [ebp-20h] BYREF
  unsigned __int8 *t_name; // [esp+4Ch] [ebp-1Ch] BYREF

  v5 = html_context;
  v6 = html;
  html_focusable(html_context, attr);
  if ( html < eof )
  {
    do
    {
      if ( *v6 != 13 && *v6 != 10 )
        break;
      ++v6;
    }
    while ( eof > v6 );
  }
  for ( j = v6; ; ++j )
  {
    if ( j >= eof )
    {
      *end = eof;
      return;
    }
    if ( *j == 60 && !parse_element(j, eof, &t_name, &t_namelen, 0, end) )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 646;
      if ( !elinks_strlcasecmp(t_name, t_namelen, "/TEXTAREA", 9u, 1) )
        break;
    }
  }
  fc = init_form_control(FC_TEXTAREA, attr, html_context);
  if ( fc )
  {
    fc->id = get_attr_value(attr, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
    fc->name = get_attr_value(attr, (unsigned __int8 *)"name", html_context->doc_cp, HTML_ATTR_NONE);
    v8 = (char *)convert_string_elinks(0, v6, j - v6, html_context->doc_cp, CSM_DEFAULT, 0, 0, 0);
    fc->default_value = (unsigned __int8 *)v8;
    if ( v8 )
    {
      v9 = *v8;
      if ( *v8 )
      {
        v10 = html_context;
        while ( 1 )
        {
          v11 = v8 + 1;
          if ( v9 == 13 )
          {
            v11 = v8 + 1;
            v12 = v8 - 1;
            if ( v8[1] == 10 || fc->default_value < (unsigned __int8 *)v8 && (v12 = v8 - 1, *(v8 - 1) == 10) )
            {
              s1a = (char *)v10;
              v27 = strlen(v8);
              v11 = v12 + 1;
              memmove(v8, v8 + 1, v27);
              v10 = (html_context *)s1a;
            }
            else
            {
              *v8 = 10;
            }
          }
          if ( !v11 )
            break;
          v9 = *v11;
          if ( !*v11 )
            break;
          v8 = v11;
        }
        v5 = v10;
      }
    }
    num = get_num(attr, "cols", v5->doc_cp);
    options = v5->options;
    if ( num <= 0 )
      num = options->default_form_input_size;
    v15 = num + 1;
    width = options->box.width;
    if ( v15 <= width )
      width = v15;
    fc->cols = width;
    v17 = get_num(attr, "rows", v5->doc_cp);
    if ( v17 <= 0 )
      v17 = 1;
    height = v5->options->box.height;
    if ( v17 <= height )
      height = v17;
    fc->rows = height;
    *((_BYTE *)v5->options + 92) |= 1u;
    attr_value = get_attr_value(attr, "wrap", v5->doc_cp, HTML_ATTR_NONE);
    if ( attr_value )
    {
      s1 = (char *)attr_value;
      v20 = c_strcasecmp((const char *)attr_value, "hard");
      v21 = s1;
      if ( v20 && (v28 = c_strcasecmp(s1, "physical"), v21 = s1, v28) )
      {
        v29 = c_strcasecmp(s1, "soft");
        v21 = s1;
        if ( v29 && (v30 = c_strcasecmp(s1, "virtual"), v21 = s1, v30) )
        {
          v31 = c_strcasecmp(s1, "none");
          v21 = s1;
          if ( !v31 || (v32 = c_strcasecmp(s1, "off"), v21 = s1, !v32) )
            fc->wrap = FORM_WRAP_NONE;
        }
        else
        {
          fc->wrap = FORM_WRAP_SOFT;
        }
      }
      else
      {
        fc->wrap = FORM_WRAP_HARD;
      }
      mem_free(v21);
    }
    else
    {
      fc->wrap = get_attr_value(attr, (unsigned __int8 *)&byte_812C4E0, v5->doc_cp, HTML_ATTR_TEST) == 0;
    }
    v22 = get_num(attr, "maxlength", v5->doc_cp);
    v23 = 0x7FFFFFFF;
    if ( v22 != -1 )
      v23 = v22;
    fc->maxlength = v23;
    if ( height <= 1 )
    {
      put_chrs(v5, (unsigned __int8 *)&start, 1);
      html_stack_dup(v5, ELEMENT_KILLABLE);
      *((_DWORD *)v5->stack.next + 11) = fc;
      *((_DWORD *)v5->stack.next + 3) |= 1u;
      if ( height <= 0 )
      {
        kill_html_stack_item(v5, (html_element *)v5->stack.next);
        goto LABEL_55;
      }
    }
    else
    {
      ln_break(v5, 1);
      html_stack_dup(v5, ELEMENT_KILLABLE);
      *((_DWORD *)v5->stack.next + 11) = fc;
      *((_DWORD *)v5->stack.next + 3) |= 1u;
    }
    v24 = height - 1;
    v37 = height;
    v25 = width;
    v35 = v24;
    for ( i = 0; i < v37; ++i )
    {
      for ( k = 0; v25 > k; ++k )
        put_chrs(v5, (unsigned __int8 *)"_", 1);
      if ( i < v35 )
        ln_break(v5, 1);
    }
    kill_html_stack_item(v5, (html_element *)v5->stack.next);
    if ( v37 > 1 )
    {
      ln_break(v5, 1);
LABEL_51:
      v5->special_f(v5, 2, fc);
      return;
    }
LABEL_55:
    put_chrs(v5, (unsigned __int8 *)&start, 1);
    goto LABEL_51;
  }
}

//----- (08096BA0) --------------------------------------------------------
void __cdecl html_option(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // esi
  form_control *inited; // edi
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  int v9; // edx
  unsigned __int8 *v10; // eax
  char v11; // dl
  unsigned __int8 *v12; // edi
  unsigned __int8 *eoff; // edx
  unsigned __int8 *i; // esi
  const unsigned __int16 **v15; // eax
  unsigned __int8 v16; // cl
  const unsigned __int16 *v17; // edx
  unsigned __int16 v18; // ax
  unsigned __int8 v19; // al
  unsigned __int8 v20; // al
  int v21; // eax
  unsigned __int8 *v22; // edx
  unsigned __int8 *source; // [esp+2Ch] [ebp-3Ch]
  string str; // [esp+3Ch] [ebp-2Ch] BYREF
  int namelen; // [esp+44h] [ebp-24h] BYREF
  unsigned __int8 *name; // [esp+48h] [ebp-20h] BYREF
  unsigned __int8 *p[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( *((_DWORD *)html_context->stack.next + 18) )
  {
    attr_value = get_attr_value(a, "value", html_context->doc_cp, HTML_ATTR_NONE);
    if ( !attr_value )
    {
      p[0] = a - 1;
      if ( *(a - 1) != 60 )
      {
        v10 = a - 2;
        do
        {
          p[0] = v10;
          v11 = *v10--;
        }
        while ( v11 != 60 );
      }
      if ( init_string(&str) )
      {
        if ( parse_element(p[0], html_context->eoff, 0, 0, 0, p) )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
          errline = 565;
          elinks_internal("parse element failed");
          attr_value = str.source;
        }
        else
        {
          v12 = p[0];
          eoff = html_context->eoff;
LABEL_18:
          for ( i = eoff; i > v12; p[0] = ++v12 )
          {
            if ( ((*__ctype_b_loc())[*v12] & 0x2000) == 0 )
              break;
          }
          while ( v12 < i )
          {
            v15 = __ctype_b_loc();
            v16 = *v12;
            v17 = *v15;
            v18 = (*v15)[*v12];
            if ( (v18 & 0x2000) != 0 || v16 == 60 )
            {
              source = str.source;
              while ( (v18 & 0x2000) != 0 )
              {
                if ( ++v12 >= i )
                  goto LABEL_45;
                v18 = v17[*v12];
              }
              if ( v12 >= i )
              {
LABEL_45:
                attr_value = source;
                goto end_parse;
              }
              if ( v12 - 2 <= i && ((v20 = v12[1], v20 == 63) || v20 == 33) )
              {
                p[0] = skip_comment(v12, i);
                v12 = p[0];
                eoff = html_context->eoff;
              }
              else
              {
                if ( parse_element(v12, i, &name, &namelen, 0, p) )
                {
                  v16 = *p[0];
                  goto LABEL_24;
                }
                v21 = namelen;
                if ( namelen > 5 )
                {
                  v22 = name;
                  if ( *name == 47 )
                  {
                    v22 = name + 1;
                    v21 = namelen - 1;
                    ++name;
                    --namelen;
                  }
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
                  errline = 592;
                  if ( !elinks_strlcasecmp(v22, v21, "OPTION", 6u, 1) )
                    goto LABEL_45;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
                  errline = 593;
                  if ( !elinks_strlcasecmp(name, namelen, "SELECT", 6u, 1) )
                    goto LABEL_45;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
                  errline = 594;
                  if ( !elinks_strlcasecmp(name, namelen, "OPTGROUP", 8u, 1) )
                    goto LABEL_45;
                }
                v12 = p[0];
                eoff = html_context->eoff;
              }
              goto LABEL_18;
            }
LABEL_24:
            v19 = v16;
            if ( !v16 )
              v19 = 32;
            add_char_to_string(&str, v19);
            v12 = ++p[0];
            i = html_context->eoff;
          }
          attr_value = str.source;
        }
      }
    }
end_parse:
    inited = init_form_control(FC_CHECKBOX, a, html_context);
    if ( inited )
    {
      inited->id = get_attr_value(a, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
      v7 = 0;
      if ( *((_DWORD *)html_context->stack.next + 18) )
        v7 = stracpy(*((const unsigned __int8 **)html_context->stack.next + 18));
      inited->name = v7;
      inited->default_value = attr_value;
      inited->default_state = get_attr_value(a, "selected", html_context->doc_cp, HTML_ATTR_TEST) != 0;
      v8 = get_attr_value(a, "disabled", html_context->doc_cp, HTML_ATTR_TEST);
      v9 = 2;
      if ( !v8 )
        v9 = *((_DWORD *)html_context->stack.next + 19);
      inited->mode = v9;
      put_chrs(html_context, (unsigned __int8 *)&start, 1);
      html_stack_dup(html_context, ELEMENT_KILLABLE);
      *((_DWORD *)html_context->stack.next + 11) = inited;
      *((_DWORD *)html_context->stack.next + 3) |= 1u;
      put_chrs(html_context, "[ ]", 3);
      kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
      put_chrs(html_context, (unsigned __int8 *)&start, 1);
      html_context->special_f(html_context, 2, inited);
    }
    else if ( attr_value )
    {
      mem_free(attr_value);
    }
  }
}

//----- (08097010) --------------------------------------------------------
void __cdecl html_button(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  int doc_cp; // edi
  unsigned __int8 *attr_value; // edx
  form_type v7; // eax
  int v8; // eax
  char *v9; // edx
  int v10; // ecx
  int v11; // eax
  unsigned __int8 *v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  form_type type; // eax
  unsigned __int8 *v18; // eax
  char *p; // [esp+18h] [ebp-20h]
  void *pa; // [esp+18h] [ebp-20h]
  form_control *fc; // [esp+1Ch] [ebp-1Ch]

  doc_cp = html_context->doc_cp;
  html_focusable(html_context, a);
  attr_value = get_attr_value(a, "type", doc_cp, HTML_ATTR_NONE);
  v7 = FC_SUBMIT;
  if ( attr_value )
  {
    p = (char *)attr_value;
    v8 = c_strcasecmp((const char *)attr_value, "button");
    v9 = p;
    v10 = v8;
    v11 = 10;
    if ( v10 )
    {
      v13 = c_strcasecmp(p, "reset");
      v9 = p;
      v14 = v13;
      v11 = 9;
      if ( v14 )
      {
        v15 = c_strcasecmp(p, "submit");
        v9 = p;
        v16 = v15;
        v11 = 7;
        if ( v16 )
        {
          mem_free(p);
          return;
        }
      }
    }
    pa = (void *)v11;
    mem_free(v9);
    v7 = (form_type)pa;
  }
  fc = init_form_control(v7, a, html_context);
  if ( fc )
  {
    fc->id = get_attr_value(a, (unsigned __int8 *)"id", doc_cp, HTML_ATTR_NONE);
    fc->name = get_attr_value(a, (unsigned __int8 *)"name", doc_cp, HTML_ATTR_NONE);
    v12 = get_attr_value(a, "value", doc_cp, HTML_ATTR_NONE);
    fc->default_value = v12;
    if ( v12 )
    {
LABEL_6:
      html_context->special_f(html_context, 2, fc);
      *((_DWORD *)html_context->stack.next + 11) = fc;
      *((_DWORD *)html_context->stack.next + 3) |= 1u;
      return;
    }
    type = fc->type;
    switch ( type )
    {
      case FC_SUBMIT:
        v18 = stracpy("Submit");
        fc->default_value = v18;
        break;
      case FC_RESET:
        v18 = stracpy("Reset");
        fc->default_value = v18;
        break;
      case FC_BUTTON:
        v18 = stracpy("Button");
        fc->default_value = v18;
        break;
      default:
LABEL_14:
        fc->default_value = stracpy((const unsigned __int8 *)&delete);
        goto LABEL_6;
    }
    if ( v18 )
      goto LABEL_6;
    goto LABEL_14;
  }
}

//----- (08097210) --------------------------------------------------------
void __cdecl html_input(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  int doc_cp; // edi
  unsigned __int8 *attr_value; // eax
  int v7; // eax
  char *v8; // edx
  form_type type; // eax
  unsigned __int8 *v10; // eax
  int num; // eax
  int v12; // eax
  int width; // edx
  int v14; // eax
  int v15; // edx
  form_type v16; // eax
  void **next; // edi
  form_type v18; // eax
  char *default_value; // esi
  int v20; // eax
  int v21; // eax
  int v22; // esi
  void **v23; // eax
  unsigned __int8 *v24; // edi
  _DWORD *v25; // esi
  int v26; // eax
  unsigned __int8 *v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int v31; // eax
  int v32; // eax
  int v33; // eax
  int v34; // eax
  const char *p; // [esp+18h] [ebp-20h]
  form_control *fc; // [esp+1Ch] [ebp-1Ch]

  doc_cp = html_context->doc_cp;
  fc = init_form_control(FC_TEXT, a, html_context);
  if ( !fc )
    return;
  attr_value = get_attr_value(a, "type", doc_cp, HTML_ATTR_NONE);
  if ( attr_value )
  {
    p = (const char *)attr_value;
    v7 = c_strcasecmp((const char *)attr_value, "text");
    v8 = (char *)p;
    if ( v7 )
    {
      v21 = c_strcasecmp(p, "hidden");
      v8 = (char *)p;
      if ( v21 )
      {
        v26 = c_strcasecmp(p, "button");
        v8 = (char *)p;
        if ( v26 )
        {
          v28 = c_strcasecmp(p, "checkbox");
          v8 = (char *)p;
          if ( v28 )
          {
            v29 = c_strcasecmp(p, "radio");
            v8 = (char *)p;
            if ( v29 )
            {
              v30 = c_strcasecmp(p, "password");
              v8 = (char *)p;
              if ( v30 )
              {
                v31 = c_strcasecmp(p, "submit");
                v8 = (char *)p;
                if ( v31 )
                {
                  v32 = c_strcasecmp(p, "reset");
                  v8 = (char *)p;
                  if ( v32 )
                  {
                    v33 = c_strcasecmp(p, "file");
                    v8 = (char *)p;
                    if ( v33 )
                    {
                      v34 = c_strcasecmp(p, "image");
                      v8 = (char *)p;
                      if ( !v34 )
                        fc->type = FC_IMAGE;
                    }
                    else
                    {
                      fc->type = FC_FILE;
                    }
                  }
                  else
                  {
                    fc->type = FC_RESET;
                  }
                }
                else
                {
                  fc->type = FC_SUBMIT;
                }
              }
              else
              {
                fc->type = FC_PASSWORD;
              }
            }
            else
            {
              fc->type = FC_RADIO;
            }
          }
          else
          {
            fc->type = FC_CHECKBOX;
          }
        }
        else
        {
          fc->type = FC_BUTTON;
        }
      }
      else
      {
        fc->type = FC_HIDDEN;
      }
    }
    else
    {
      fc->type = FC_TEXT;
    }
    mem_free(v8);
  }
  type = fc->type;
  if ( type == FC_HIDDEN )
  {
    v10 = get_attr_value(a, "value", doc_cp, HTML_ATTR_LITERAL_NL);
  }
  else
  {
    if ( type == FC_FILE )
    {
      if ( fc->default_value )
        goto LABEL_10;
LABEL_25:
      v18 = fc->type;
      switch ( v18 )
      {
        case FC_CHECKBOX:
          v27 = stracpy((const unsigned __int8 *)"on");
          fc->default_value = v27;
          break;
        case FC_SUBMIT:
          v27 = stracpy("Submit");
          fc->default_value = v27;
          break;
        case FC_RESET:
          v27 = stracpy("Reset");
          fc->default_value = v27;
          break;
        case FC_BUTTON:
          v27 = stracpy("Button");
          fc->default_value = v27;
          break;
        default:
LABEL_29:
          fc->default_value = stracpy((const unsigned __int8 *)&delete);
          goto LABEL_10;
      }
      if ( v27 )
        goto LABEL_10;
      goto LABEL_29;
    }
    v10 = get_attr_value(a, "value", doc_cp, HTML_ATTR_NONE);
  }
  fc->default_value = v10;
  if ( !v10 )
    goto LABEL_25;
LABEL_10:
  fc->id = get_attr_value(a, (unsigned __int8 *)"id", doc_cp, HTML_ATTR_NONE);
  fc->name = get_attr_value(a, (unsigned __int8 *)"name", doc_cp, HTML_ATTR_NONE);
  num = get_num(a, (unsigned __int8 *)"size", doc_cp);
  fc->size = num;
  if ( num == -1 )
  {
    num = html_context->options->default_form_input_size;
    fc->size = num;
  }
  v12 = num + 1;
  fc->size = v12;
  width = html_context->options->box.width;
  if ( v12 > width )
    fc->size = width;
  v14 = get_num(a, "maxlength", doc_cp);
  v15 = 0x7FFFFFFF;
  if ( v14 != -1 )
    v15 = v14;
  fc->maxlength = v15;
  v16 = fc->type;
  if ( (unsigned int)(v16 - 4) <= 1 )
  {
    fc->default_state = get_attr_value(a, "checked", doc_cp, HTML_ATTR_TEST) != 0;
    v16 = fc->type;
  }
  if ( v16 == FC_IMAGE )
  {
    fc->alt = get_attr_value(a, (unsigned __int8 *)"alt", doc_cp, HTML_ATTR_NONE);
    v16 = fc->type;
  }
  if ( v16 != FC_HIDDEN )
  {
    put_chrs(html_context, (unsigned __int8 *)&start, 1);
    html_stack_dup(html_context, ELEMENT_KILLABLE);
    html_focusable(html_context, a);
    *((_DWORD *)html_context->stack.next + 11) = fc;
    next = (void **)html_context->stack.next;
    if ( next[10] )
    {
      mem_free(next[10]);
      next = (void **)html_context->stack.next;
    }
    next[10] = get_attr_value(a, "title", html_context->doc_cp, HTML_ATTR_NONE);
    switch ( fc->type )
    {
      case FC_TEXT:
      case FC_PASSWORD:
      case FC_FILE:
        *((_DWORD *)html_context->stack.next + 3) |= 1u;
        if ( fc->size > 0 )
        {
          v22 = 0;
          do
          {
            ++v22;
            put_chrs(html_context, (unsigned __int8 *)"_", 1);
          }
          while ( v22 < fc->size );
        }
        break;
      case FC_TEXTAREA:
      case FC_SELECT:
      case FC_HIDDEN:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 257;
        elinks_internal("bad control type");
        break;
      case FC_CHECKBOX:
        *((_DWORD *)html_context->stack.next + 3) |= 1u;
        put_chrs(html_context, (unsigned __int8 *)&byte_812C537, 8);
        break;
      case FC_RADIO:
        *((_DWORD *)html_context->stack.next + 3) |= 1u;
        put_chrs(html_context, "(&nbsp;)", 8);
        break;
      case FC_SUBMIT:
      case FC_RESET:
      case FC_BUTTON:
        *((_DWORD *)html_context->stack.next + 3) |= 1u;
        put_chrs(html_context, "[&nbsp;", 7);
        default_value = (char *)fc->default_value;
        if ( !default_value )
          goto LABEL_32;
        goto LABEL_31;
      case FC_IMAGE:
        v23 = (void **)html_context->stack.next;
        if ( v23[9] )
        {
          mem_free(v23[9]);
          v23 = (void **)html_context->stack.next;
        }
        v23[9] = 0;
        v24 = get_attr_value(a, (unsigned __int8 *)"src", html_context->doc_cp, HTML_ATTR_EAT_NL);
        if ( v24 || (v24 = get_attr_value(a, "dynsrc", html_context->doc_cp, HTML_ATTR_EAT_NL)) != 0 )
        {
          v25 = html_context->stack.next;
          v25[9] = join_urls(html_context->base_href, v24);
          mem_free(v24);
        }
        *((_DWORD *)html_context->stack.next + 3) |= 1u;
        put_chrs(html_context, "[&nbsp;", 7);
        default_value = (char *)fc->alt;
        if ( default_value || (default_value = (char *)fc->name) != 0 )
        {
LABEL_31:
          v20 = strlen(default_value);
          put_chrs(html_context, (unsigned __int8 *)default_value, v20);
        }
        else
        {
          put_chrs(html_context, "Submit", 6);
        }
LABEL_32:
        put_chrs(html_context, "&nbsp;]", 7);
        break;
      default:
        break;
    }
    kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
    put_chrs(html_context, (unsigned __int8 *)&start, 1);
  }
  html_context->special_f(html_context, 2, fc);
}

//----- (08097940) --------------------------------------------------------
void __cdecl html_form(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  form *inited; // eax
  form *v6; // esi
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v8; // edi
  unsigned __int8 *v9; // eax
  char *v10; // eax
  unsigned __int8 *uri_string; // eax
  const char *action; // eax
  unsigned __int8 *target; // eax
  size_t v14; // eax
  char *v15; // ecx
  char *v16; // edi
  char *v17; // edx
  char v18; // cl
  size_t v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // eax
  char *v22; // edx
  int v23; // eax
  char s1a; // [esp+14h] [ebp-24h]
  char *s1; // [esp+14h] [ebp-24h]
  char *p; // [esp+18h] [ebp-20h]

  *((_BYTE *)html_context + 68) |= 1u;
  inited = init_form();
  v6 = inited;
  if ( !inited )
    return;
  inited->method = FORM_METHOD_GET;
  inited->form_num = a - html_context->startf;
  attr_value = get_attr_value(a, "method", html_context->doc_cp, HTML_ATTR_NONE);
  v8 = attr_value;
  if ( attr_value )
  {
    if ( !c_strcasecmp((const char *)attr_value, "post") )
    {
      v20 = get_attr_value(a, "enctype", html_context->doc_cp, HTML_ATTR_NONE);
      v6->method = FORM_METHOD_POST;
      if ( v20 )
      {
        s1 = (char *)v20;
        v21 = c_strcasecmp((const char *)v20, "multipart/form-data");
        v22 = s1;
        if ( v21 )
        {
          v23 = c_strcasecmp(s1, "text/plain");
          v22 = s1;
          if ( !v23 )
            v6->method = FORM_METHOD_POST_TEXT_PLAIN;
        }
        else
        {
          v6->method = FORM_METHOD_POST_MP;
        }
        mem_free(v22);
      }
    }
    mem_free(v8);
  }
  v6->onsubmit = get_attr_value(a, "onsubmit", html_context->doc_cp, HTML_ATTR_NONE);
  v9 = get_attr_value(a, (unsigned __int8 *)"name", html_context->doc_cp, HTML_ATTR_NONE);
  if ( v9 )
    v6->name = v9;
  v10 = (char *)get_attr_value(a, "action", html_context->doc_cp, HTML_ATTR_NONE);
  p = v10;
  if ( v10 )
  {
    if ( *v10 )
    {
      s1a = *v10;
      v14 = strlen(v10);
      v15 = p;
      if ( s1a == 32 )
      {
        do
        {
          ++v15;
          --v14;
        }
        while ( *v15 == 32 );
      }
      if ( v14 )
      {
        v16 = v15;
        v17 = &v15[v14];
        if ( v15[v14 - 1] == 32 )
        {
          do
          {
            --v14;
            *(v17 - 1) = 0;
            if ( !v14 )
            {
              v15 = v16;
              goto LABEL_29;
            }
            v18 = *(v17 - 2);
            --v17;
          }
          while ( v18 == 32 );
          v15 = v16;
        }
        v19 = v14 + 1;
      }
      else
      {
LABEL_29:
        v19 = 1;
      }
      memmove(p, v15, v19);
      v6->action = join_urls(html_context->base_href, (unsigned __int8 *)p);
      mem_free(p);
      goto LABEL_18;
    }
    mem_free(v10);
  }
  uri_string = get_uri_string(
                 html_context->base_href,
                 (uri_component)(v6->method == FORM_METHOD_GET ? URI_FORM_GET : URI_ORIGINAL));
  v6->action = uri_string;
  if ( !assert_failed )
  {
    if ( !uri_string || !strchr((const char *)uri_string, 1) )
    {
      assert_failed = 0;
      goto LABEL_14;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
    errline = 99;
    elinks_internal("assertion !form->action || !strchr(form->action, POST_CHAR) failed!");
    if ( !assert_failed )
    {
LABEL_14:
      action = (const char *)v6->action;
      if ( action && v6->method == FORM_METHOD_GET && strchr(action, 63) )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 104;
        elinks_internal("assertion !form->action || form->method != FORM_METHOD_GET || !strchr(form->action, '?') failed!");
      }
      else
      {
        assert_failed = 0;
      }
    }
  }
LABEL_18:
  target = get_target(html_context->options, a);
  if ( !target )
    target = stracpy(html_context->base_target);
  v6->target = target;
  html_context->special_f(html_context, 1, v6);
}

//----- (08097CC0) --------------------------------------------------------
void __cdecl html_select(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  unsigned __int8 *attr_value; // ebx
  void **next; // edx
  _DWORD *v8; // ebx
  conv_table *v9; // eax
  unsigned __int8 *v10; // ebx
  void **v11; // edx
  int v12; // ebx
  int v13; // esi
  const unsigned __int16 **v14; // eax
  unsigned __int8 v15; // dl
  const unsigned __int16 *v16; // eax
  int v17; // edx
  unsigned __int8 *v18; // ecx
  unsigned __int8 *v19; // eax
  signed int v20; // edx
  unsigned __int8 *v21; // esi
  unsigned __int8 v22; // al
  int v23; // eax
  int v24; // esi
  unsigned int v25; // eax
  size_t v26; // ecx
  unsigned __int8 *v27; // edx
  int v28; // esi
  int v29; // esi
  int v30; // eax
  int v31; // edi
  unsigned __int8 *v32; // eax
  size_t v33; // edx
  unsigned int v34; // eax
  unsigned __int8 *v35; // ebx
  unsigned __int8 *v36; // eax
  unsigned __int8 *v37; // eax
  char *v38; // eax
  bool v39; // zf
  int v40; // eax
  form_control *inited; // esi
  int v42; // ebx
  menu_item *v43; // eax
  int v44; // esi
  unsigned __int8 *v45; // edi
  int v46; // eax
  int i; // edi
  size_t v48; // [esp+2Ch] [ebp-6Ch]
  int v49; // [esp+2Ch] [ebp-6Ch]
  unsigned __int8 nc; // [esp+30h] [ebp-68h]
  size_t n; // [esp+30h] [ebp-68h]
  size_t nd; // [esp+30h] [ebp-68h]
  size_t na; // [esp+30h] [ebp-68h]
  size_t nb; // [esp+30h] [ebp-68h]
  int v55; // [esp+34h] [ebp-64h]
  int v56; // [esp+38h] [ebp-60h]
  _BOOL4 dont_add; // [esp+3Ch] [ebp-5Ch]
  int order; // [esp+40h] [ebp-58h]
  unsigned int v59; // [esp+44h] [ebp-54h]
  unsigned __int8 *v60; // [esp+44h] [ebp-54h]
  conv_table *convert_table; // [esp+48h] [ebp-50h]
  conv_table *convert_tablea; // [esp+48h] [ebp-50h]
  unsigned __int8 **lbls; // [esp+4Ch] [ebp-4Ch]
  string orig_string; // [esp+5Ch] [ebp-3Ch] BYREF
  string string; // [esp+64h] [ebp-34h] BYREF
  int namelen; // [esp+6Ch] [ebp-2Ch] BYREF
  unsigned __int8 *v67; // [esp+70h] [ebp-28h] BYREF
  unsigned __int8 *attr; // [esp+74h] [ebp-24h] BYREF
  unsigned __int8 *name; // [esp+78h] [ebp-20h] BYREF
  void *p; // [esp+7Ch] [ebp-1Ch]

  if ( get_attr_value(a, "multiple", html_context->doc_cp, HTML_ATTR_TEST) )
  {
    attr_value = get_attr_value(a, (unsigned __int8 *)"name", html_context->doc_cp, HTML_ATTR_NONE);
    if ( attr_value )
    {
      html_focusable(html_context, a);
      *((_DWORD *)html_context->stack.next + 2) = 1;
      next = (void **)html_context->stack.next;
      if ( next[18] )
      {
        mem_free(next[18]);
        next = (void **)html_context->stack.next;
      }
      next[18] = attr_value;
      v8 = html_context->stack.next;
      v8[19] = get_attr_value(a, "disabled", html_context->doc_cp, HTML_ATTR_TEST) != 0 ? 2 : 0;
    }
    return;
  }
  v9 = (conv_table *)html_context->special_f(html_context, 3, 0);
  string.source = 0;
  string.length = 0;
  orig_string.source = 0;
  orig_string.length = 0;
  p = 0;
  convert_table = v9;
  html_focusable(html_context, a);
  init_menu(&lnk_menu);
  v55 = 0;
  v56 = -1;
  order = 0;
  dont_add = 0;
LABEL_8:
  v67 = html;
  while ( 1 )
  {
    if ( eof <= html )
      goto LABEL_15;
    if ( *html != 60 )
      break;
    v10 = html;
LABEL_29:
    if ( !string.source )
      goto LABEL_47;
    v13 = v10 - html;
    if ( v10 == html )
    {
LABEL_53:
      v17 = 0;
    }
    else
    {
      nc = *html;
      v14 = __ctype_b_loc();
      v15 = nc;
      v16 = *v14;
      while ( (v16[v15] & 0x2000) != 0 )
      {
        ++html;
        if ( !--v13 )
          goto LABEL_53;
        v15 = *html;
      }
      v17 = v13;
      if ( v13 )
      {
        v18 = &html[v13];
        do
        {
          if ( (v16[*(v18 - 1)] & 0x2000) == 0 )
            break;
          --v18;
          --v13;
        }
        while ( v13 );
        v17 = v13;
      }
    }
    n = v17;
    v19 = convert_string_elinks(convert_table, html, v17, html_context->options->cp, CSM_DEFAULT, 0, 0, 0);
    v20 = n;
    v21 = v19;
    if ( v19 )
    {
      add_to_string(&string, v19);
      mem_free(v21);
      v20 = n;
    }
    if ( assert_failed )
    {
LABEL_55:
      assert_failed = 0;
      goto LABEL_47;
    }
    if ( html && v20 >= 0 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      nd = v20;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      v20 = nd;
      if ( assert_failed )
        goto LABEL_55;
    }
    if ( v20 )
    {
      v24 = v20 + orig_string.length;
      v25 = orig_string.length + 255;
      v26 = v20 + orig_string.length + 256;
      LOBYTE(v25) = 0;
      LOBYTE(v26) = 0;
      v59 = v25;
      if ( v26 <= v25 )
        goto LABEL_57;
      v48 = v26;
      na = v20;
      v36 = (unsigned __int8 *)mem_realloc(orig_string.source, v26);
      if ( v36 )
      {
        orig_string.source = v36;
        memset(&v36[v59], 0, v48 - v59);
        v20 = na;
LABEL_57:
        if ( orig_string.source )
        {
          memcpy(&orig_string.source[orig_string.length], html, v20);
          orig_string.source[v24] = 0;
          orig_string.length = v24;
        }
      }
    }
LABEL_47:
    if ( eof >= v10 + 2 )
    {
      v22 = v10[1];
      if ( v22 == 63 || v22 == 33 )
      {
        html = skip_comment(v10, eof);
        goto LABEL_8;
      }
    }
    if ( parse_element(v10, eof, &name, &namelen, &attr, &v67) )
    {
      html = v10 + 1;
      goto LABEL_8;
    }
    v23 = namelen;
    if ( namelen )
    {
      v27 = name;
      v28 = 0;
      if ( *name == 47 )
      {
        v30 = namelen - 1;
        namelen = v30;
        if ( !v30 )
          goto LABEL_62;
        ++name;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 413;
        v31 = elinks_strlcasecmp(name, v30, "SELECT", 6u, 1);
        if ( !v31 )
        {
          add_select_item(&lnk_menu, &string, &orig_string, (unsigned __int8 **)p, order, dont_add);
          *end = v67;
          if ( !order )
            goto LABEL_16;
          lbls = (unsigned __int8 **)mem_calloc(order, 4u);
          if ( !lbls )
            goto LABEL_16;
          inited = init_form_control(FC_SELECT, a, html_context);
          if ( !inited )
          {
            mem_free(lbls);
            goto LABEL_16;
          }
          inited->id = get_attr_value(a, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
          inited->name = get_attr_value(a, (unsigned __int8 *)"name", html_context->doc_cp, HTML_ATTR_NONE);
          if ( v56 >= 0 )
            v31 = v56;
          v42 = 0;
          inited->default_state = v31;
          inited->default_value = stracpy(*((const unsigned __int8 **)p + v31));
          inited->nvalues = order;
          inited->values = (unsigned __int8 **)p;
          v43 = detach_menu(&lnk_menu);
          inited->menu = v43;
          inited->labels = lbls;
          menu_labels(v43, (unsigned __int8 *)&delete, lbls);
          put_chrs(html_context, (unsigned __int8 *)"[", 1);
          html_stack_dup(html_context, ELEMENT_KILLABLE);
          *((_DWORD *)html_context->stack.next + 11) = inited;
          *((_DWORD *)html_context->stack.next + 3) |= 1u;
          convert_tablea = (conv_table *)inited;
          v44 = 0;
          while ( 2 )
          {
            if ( order <= v44 )
            {
              for ( i = 0; v42 > i; ++i )
                put_chrs(html_context, (unsigned __int8 *)"_", 1);
              kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
              put_chrs(html_context, (unsigned __int8 *)"]", 1);
              html_context->special_f(html_context, 2, convert_tablea);
              return;
            }
            v45 = lbls[v44];
            if ( v45 )
            {
              if ( (*((_BYTE *)html_context->options + 92) & 0x10) != 0 )
              {
                v46 = utf8_ptr2cells(v45, 0);
                if ( v46 > v42 )
                  goto LABEL_102;
              }
              else
              {
                v46 = strlen((const char *)v45);
                if ( v42 < v46 )
                {
LABEL_102:
                  ++v44;
                  v42 = v46;
                  continue;
                }
              }
            }
            break;
          }
          v46 = v42;
          goto LABEL_102;
        }
        LOWORD(v28) = 1;
        v23 = namelen;
        v27 = name;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
      errline = 418;
      if ( elinks_strlcasecmp(v27, v23, "OPTION", 6u, 1) )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/forms.c";
        errline = 447;
        if ( elinks_strlcasecmp(name, namelen, "OPTGROUP", 8u, 1) )
          goto LABEL_62;
        add_select_item(&lnk_menu, &string, &orig_string, (unsigned __int8 **)p, order, dont_add);
        if ( v55 )
          new_menu_item(&lnk_menu, 0, -1, 0);
        if ( !v28
          && ((v37 = get_attr_value(attr, "label", html_context->doc_cp, HTML_ATTR_NONE)) != 0
           || (v37 = stracpy((const unsigned __int8 *)&delete)) != 0) )
        {
          new_menu_item(&lnk_menu, v37, -1, 0);
          v29 = order;
          v55 = 1;
        }
        else
        {
          v29 = order;
          v55 = 0;
        }
      }
      else
      {
        add_select_item(&lnk_menu, &string, &orig_string, (unsigned __int8 **)p, order, dont_add);
        if ( v28 || get_attr_value(attr, "disabled", html_context->doc_cp, HTML_ATTR_TEST) )
        {
LABEL_62:
          v29 = order;
          goto LABEL_63;
        }
        if ( v56 == -1 )
        {
          v39 = get_attr_value(attr, "selected", html_context->doc_cp, HTML_ATTR_TEST) == 0;
          v40 = order;
          if ( v39 )
            v40 = -1;
          v56 = v40;
        }
        v32 = get_attr_value(attr, "value", html_context->doc_cp, HTML_ATTR_NONE);
        v33 = order + 255;
        LOBYTE(v33) = 0;
        v29 = order + 1;
        v60 = v32;
        v34 = order + 256;
        LOBYTE(v34) = 0;
        if ( v34 > v33 )
        {
          nb = v33;
          v49 = 4 * v34;
          v38 = (char *)mem_realloc(p, 4 * v34);
          if ( !v38 )
            goto LABEL_16;
          p = v38;
          memset(&v38[4 * nb], 0, v49 - 4 * nb);
        }
        if ( !p )
          goto LABEL_16;
        *((_DWORD *)p + order) = v60;
        v35 = get_attr_value(attr, "label", html_context->doc_cp, HTML_ATTR_NONE);
        if ( !v35 || (new_menu_item(&lnk_menu, v35, order, 0), !v60) )
        {
          init_string(&string);
          init_string(&orig_string);
          dont_add = v35 != 0;
        }
      }
LABEL_63:
      html = v67;
      order = v29;
    }
    else
    {
      html = v67;
    }
  }
  v10 = html;
  while ( eof > ++v10 )
  {
    if ( *v10 == 60 )
      goto LABEL_29;
  }
  html = v10;
LABEL_15:
  v10 = html;
LABEL_16:
  *end = v10;
  if ( string.source )
    done_string(&string);
  if ( orig_string.source )
    done_string(&orig_string);
  v11 = (void **)p;
  if ( p )
  {
    if ( order )
    {
      v12 = 0;
      do
      {
        if ( v11[v12] )
        {
          mem_free(v11[v12]);
          v11 = (void **)p;
        }
        ++v12;
      }
      while ( v12 < order );
    }
    mem_free(v11);
  }
  destroy_menu(&lnk_menu);
  *end = v67;
}

//----- (08098720) --------------------------------------------------------
void __cdecl html_span(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  ;
}

//----- (08098730) --------------------------------------------------------
void __cdecl html_bold(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 3) |= 1u;
}

//----- (08098740) --------------------------------------------------------
void __cdecl html_italic(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 3) |= 2u;
}

//----- (08098750) --------------------------------------------------------
void __cdecl html_underline(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 3) |= 4u;
}

//----- (08098760) --------------------------------------------------------
void __cdecl html_fixed(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 3) |= 8u;
}

//----- (08098770) --------------------------------------------------------
void __cdecl html_style_close(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_BYTE *)html_context + 68) &= ~4u;
}

//----- (08098780) --------------------------------------------------------
void __cdecl html_html(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  _DWORD *next; // edx
  _DWORD *prev; // ecx
  int v7; // eax

  next = html_context->stack.next;
  prev = html_context->stack.prev;
  v7 = next[5];
  if ( next[37] != v7 )
  {
    next[37] = v7;
    prev[5] = v7;
    prev[37] = v7;
  }
}

//----- (080987B0) --------------------------------------------------------
void __cdecl html_head(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  ;
}

//----- (080987C0) --------------------------------------------------------
void __cdecl html_meta(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  ;
}

//----- (080987D0) --------------------------------------------------------
void __cdecl html_title(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 38) = 1;
  *((_DWORD *)html_context->stack.next + 2) = 3;
}

//----- (080987F0) --------------------------------------------------------
void __cdecl html_center(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  _DWORD *next; // eax

  *((_DWORD *)html_context->stack.next + 29) = 1;
  if ( !html_context->table_level )
  {
    next = html_context->stack.next;
    next[31] = 0;
    next[30] = 0;
  }
}

//----- (08098820) --------------------------------------------------------
void __cdecl html_address(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  ++*((_DWORD *)html_context->stack.next + 30);
  *((_DWORD *)html_context->stack.next + 29) = 0;
}

//----- (08098840) --------------------------------------------------------
void __cdecl html_blockquote(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 30) += 2;
  *((_DWORD *)html_context->stack.next + 29) = 0;
}

//----- (08098860) --------------------------------------------------------
void __cdecl html_pre(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_DWORD *)html_context->stack.next + 3) |= 0x20u;
  *((_DWORD *)html_context->stack.next + 30) = *((_DWORD *)html_context->stack.next + 30) > 1;
  *((_DWORD *)html_context->stack.next + 31) = 0;
}

//----- (08098890) --------------------------------------------------------
void __cdecl html_xmp(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  _DWORD *next; // edx

  next = html_context->stack.next;
  *((_BYTE *)html_context + 68) |= 2u;
  next[3] |= 0x20u;
  *((_DWORD *)html_context->stack.next + 30) = *((_DWORD *)html_context->stack.next + 30) > 1;
  *((_DWORD *)html_context->stack.next + 31) = 0;
}

//----- (080988C0) --------------------------------------------------------
void __cdecl html_xmp_close(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  *((_BYTE *)html_context + 68) &= ~2u;
}

//----- (080988D0) --------------------------------------------------------
void __cdecl html_tt(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  ;
}

//----- (080988E0) --------------------------------------------------------
void __cdecl html_noscript(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  ;
}

//----- (080988F0) --------------------------------------------------------
void __cdecl html_frameset(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // esi
  unsigned __int8 *v6; // edi
  _DWORD *v7; // eax
  int v8; // edx
  _DWORD *v9; // eax
  int width; // edx
  void *next; // edx
  document_options *options; // eax
  int height; // [esp+2Ch] [ebp-3Ch]
  frameset_param fp; // [esp+3Ch] [ebp-2Ch] BYREF

  if ( !search_html_stack(html_context, "BODY") && (*((_BYTE *)html_context->options + 68) & 0x10) != 0 )
  {
    if ( (int)html_context->special_f(html_context, 4, 0) )
    {
      attr_value = get_attr_value(a, "cols", html_context->doc_cp, HTML_ATTR_NONE);
      if ( attr_value || (attr_value = stracpy("100%")) != 0 )
      {
        v6 = get_attr_value(a, "rows", html_context->doc_cp, HTML_ATTR_NONE);
        if ( !v6 )
        {
          v6 = stracpy("100%");
          if ( !v6 )
          {
            mem_free(attr_value);
            return;
          }
        }
        v7 = (_DWORD *)*((_DWORD *)html_context->stack.next + 43);
        if ( v7 )
        {
          v8 = v7[2];
          if ( v8 >= v7[4] )
          {
free_and_return:
            mem_free(attr_value);
            mem_free(v6);
            return;
          }
          v9 = &v7[5 * v7[1] + 5 * v7[3] * v8];
          width = v9[8];
          height = v9[9];
        }
        else
        {
          options = html_context->options;
          width = options->box.width;
          height = options->box.height;
          *((_BYTE *)options + 92) |= 1u;
        }
        fp.height = 0;
        fp.width = 0;
        parse_frame_widths(attr_value, width, 10, &fp.width, &fp.x);
        parse_frame_widths(v6, height, 16, &fp.height, &fp.y);
        next = html_context->stack.next;
        fp.parent = (frameset_desc *)*((_DWORD *)next + 43);
        if ( fp.x && fp.y )
          *((_DWORD *)next + 43) = html_context->special_f(html_context, 5, &fp);
        if ( fp.width )
          mem_free(fp.width);
        if ( fp.height )
          mem_free(fp.height);
        goto free_and_return;
      }
    }
  }
}

//----- (08098AF0) --------------------------------------------------------
void __cdecl html_frame(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // esi

  attr_value = get_attr_value(a, (unsigned __int8 *)"src", html_context->doc_cp, HTML_ATTR_EAT_NL);
  v6 = attr_value;
  if ( attr_value )
  {
    v7 = join_urls(html_context->base_href, attr_value);
    mem_free(v6);
  }
  else
  {
    v7 = stracpy("about:blank");
  }
  if ( !v7 )
    return;
  v8 = get_attr_value(a, (unsigned __int8 *)"name", html_context->doc_cp, HTML_ATTR_NONE);
  v9 = v8;
  if ( !v8 )
    goto LABEL_13;
  if ( !*v8 )
  {
    mem_free(v8);
LABEL_13:
    v9 = stracpy(v7);
    if ( !v9 )
      return;
  }
  if ( (*((_BYTE *)html_context->options + 68) & 0x10) != 0 && *((_DWORD *)html_context->stack.next + 43) )
  {
    if ( (int)html_context->special_f(html_context, 4, 0) )
      html_context->special_f(html_context, 6, *((_DWORD *)html_context->stack.next + 43), v9, v7);
  }
  else
  {
    html_focusable(html_context, a);
    put_link_line("Frame: ", v9, v7, (unsigned __int8 *)&delete, html_context);
  }
  mem_free(v9);
  mem_free(v7);
}

//----- (08098C70) --------------------------------------------------------
void __cdecl html_noframes(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  html_element *v5; // eax

  if ( (*((_BYTE *)html_context->options + 68) & 0x10) != 0 )
  {
    v5 = search_html_stack(html_context, "frameset");
    if ( !v5 || v5->frameset )
      html_skip(html_context, a);
  }
}

//----- (08098CD0) --------------------------------------------------------
void __cdecl html_style(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  *((_BYTE *)html_context + 68) |= 4u;
  html_skip(html_context, a);
}

//----- (08098CF0) --------------------------------------------------------
void __cdecl html_script(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_skip(html_context, a);
}

//----- (08098D00) --------------------------------------------------------
void __cdecl html_dd(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  _DWORD *next; // eax
  int v6; // edx

  kill_html_stack_until(html_context, 0, &delete, "DL", 0);
  *((_DWORD *)html_context->stack.next + 30) = *((_DWORD *)html_context->stack.next + 35) + 3;
  if ( html_context->table_level )
    goto LABEL_4;
  *((_DWORD *)html_context->stack.next + 30) += 5;
  next = html_context->stack.next;
  v6 = next[32] / 2;
  if ( v6 < next[30] )
  {
    next[30] = v6;
LABEL_4:
    next = html_context->stack.next;
  }
  next[29] = 0;
}

//----- (08098D80) --------------------------------------------------------
void __cdecl html_dt(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  kill_html_stack_until(html_context, 0, &delete, "DL", 0);
  *((_DWORD *)html_context->stack.next + 29) = 0;
  *((_DWORD *)html_context->stack.next + 30) = *((_DWORD *)html_context->stack.next + 35);
  if ( (*((_BYTE *)html_context->stack.next + 144) & 8) == 0
    && !get_attr_value(a, "compact", html_context->doc_cp, HTML_ATTR_TEST) )
  {
    ln_break(html_context, 2);
  }
}

//----- (08098E30) --------------------------------------------------------
void __cdecl html_dl(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  _DWORD *next; // eax
  int v6; // edx

  *((_DWORD *)html_context->stack.next + 36) &= ~8u;
  if ( get_attr_value(a, "compact", html_context->doc_cp, HTML_ATTR_TEST) )
    *((_DWORD *)html_context->stack.next + 36) |= 8u;
  next = html_context->stack.next;
  v6 = 0;
  if ( next[33] )
  {
    next[30] += 5;
    next = html_context->stack.next;
    v6 = next[33];
  }
  next[33] = v6 + 1;
  *((_DWORD *)html_context->stack.next + 34) = 0;
  *((_DWORD *)html_context->stack.next + 29) = 0;
  *((_DWORD *)html_context->stack.next + 35) = *((_DWORD *)html_context->stack.next + 30);
  *((_DWORD *)html_context->stack.next + 2) = 1;
  if ( (*((_BYTE *)html_context->stack.next + 144) & 8) == 0 )
  {
    ln_break(html_context, 2);
    *((_DWORD *)html_context->stack.next + 42) = 2;
  }
}

//----- (08098F00) --------------------------------------------------------
void __cdecl html_td(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  kill_html_stack_until(html_context, 1, "TD", "TH", &delete, "TR", "TABLE", 0);
  *((_DWORD *)html_context->stack.next + 3) &= ~1u;
  put_chrs(html_context, (unsigned __int8 *)&start, 1);
}

//----- (08098F70) --------------------------------------------------------
void __cdecl html_th(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  kill_html_stack_until(html_context, 1, "TD", "TH", &delete, "TR", "TABLE", 0);
  *((_DWORD *)html_context->stack.next + 3) |= 1u;
  put_chrs(html_context, (unsigned __int8 *)&start, 1);
}

//----- (08098FE0) --------------------------------------------------------
void __cdecl html_quote_close(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  char v5; // dl
  unsigned int quote_level; // ecx

  v5 = 0;
  quote_level = html_context->quote_level;
  if ( quote_level )
  {
    v5 = quote_level - 1;
    html_context->quote_level = quote_level - 1;
  }
  put_chrs(html_context, quote_char[v5 & 1], 1);
}

//----- (08099020) --------------------------------------------------------
void __cdecl html_quote(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *v5; // ecx

  v5 = quote_char[html_context->quote_level++ & 1];
  put_chrs(html_context, v5, 1);
}

//----- (08099060) --------------------------------------------------------
void __cdecl html_superscript(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  put_chrs(html_context, (unsigned __int8 *)"^", 1);
}

//----- (08099080) --------------------------------------------------------
void __cdecl html_subscript_close(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  put_chrs(html_context, (unsigned __int8 *)"]", 1);
}

//----- (080990A0) --------------------------------------------------------
void __cdecl html_subscript(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  put_chrs(html_context, (unsigned __int8 *)"[", 1);
}

//----- (080990C0) --------------------------------------------------------
void __cdecl html_ol(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  int num; // eax
  int v6; // edx
  unsigned __int8 *attr_value; // eax
  unsigned __int8 v8; // dl
  _DWORD *next; // eax
  int v10; // edx

  ++*((_DWORD *)html_context->stack.next + 33);
  num = get_num(a, "start", html_context->doc_cp);
  v6 = 1;
  if ( num != -1 )
    v6 = num;
  *((_DWORD *)html_context->stack.next + 34) = v6;
  *((_DWORD *)html_context->stack.next + 36) = 1;
  attr_value = get_attr_value(a, "type", html_context->doc_cp, HTML_ATTR_NONE);
  if ( attr_value )
  {
    v8 = *attr_value;
    if ( !*attr_value || attr_value[1] )
      goto LABEL_5;
    switch ( v8 )
    {
      case '1':
        *((_DWORD *)html_context->stack.next + 36) = 1;
        goto LABEL_5;
      case 'a':
        *((_DWORD *)html_context->stack.next + 36) = 2;
        goto LABEL_5;
      case 'A':
        *((_DWORD *)html_context->stack.next + 36) = 3;
        goto LABEL_5;
    }
    if ( v8 != 114 )
    {
      if ( v8 == 82 )
        goto LABEL_19;
      if ( v8 != 105 )
      {
        if ( v8 != 73 )
        {
LABEL_5:
          mem_free(attr_value);
          goto LABEL_6;
        }
LABEL_19:
        *((_DWORD *)html_context->stack.next + 36) = 5;
        goto LABEL_5;
      }
    }
    *((_DWORD *)html_context->stack.next + 36) = 4;
    goto LABEL_5;
  }
LABEL_6:
  *((_DWORD *)html_context->stack.next + 30) += *((_DWORD *)html_context->stack.next + 33) > 1;
  if ( html_context->table_level )
  {
LABEL_9:
    next = html_context->stack.next;
    goto LABEL_10;
  }
  next = html_context->stack.next;
  v10 = next[32] / 2;
  if ( v10 < next[30] )
  {
    next[30] = v10;
    goto LABEL_9;
  }
LABEL_10:
  next[29] = 0;
  *((_DWORD *)html_context->stack.next + 2) = 1;
}

//----- (08099240) --------------------------------------------------------
void __cdecl html_li(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  html_context *v5; // ebx
  _DWORD *next; // eax
  int v7; // eax
  int num; // eax
  unsigned __int8 v9; // si
  unsigned int v10; // eax
  int v11; // ecx
  unsigned __int8 *v12; // kr00_4
  html_element *v13; // eax
  unsigned __int8 v14; // cl
  int v15; // esi
  char v16; // cl
  unsigned int v17; // esi
  unsigned int v18; // edx
  int v19; // ebx
  unsigned __int8 *s; // edi
  unsigned __int8 v21; // al
  unsigned __int8 *v22; // esi
  int v23; // [esp+28h] [ebp-60h]
  int v24; // [esp+30h] [ebp-58h]
  int v25; // [esp+34h] [ebp-54h]
  unsigned int v26; // [esp+3Ch] [ebp-4Ch]
  unsigned __int8 x[7]; // [esp+45h] [ebp-43h] BYREF
  unsigned __int8 n[32]; // [esp+4Ch] [ebp-3Ch] BYREF
  unsigned int v29; // [esp+6Ch] [ebp-1Ch]

  v5 = html_context;
  v29 = __readgsdword(0x14u);
  if ( html_context->was_li )
  {
    html_context->line_breax = 0;
    ln_break(html_context, 1);
  }
  next = html_context->stack.next;
  if ( next[34] )
  {
    v25 = next[36] & 7;
    num = get_num(a, "value", html_context->doc_cp);
    if ( num != -1 )
      *((_DWORD *)html_context->stack.next + 34) = num;
    if ( (unsigned int)(v25 - 2) <= 1 )
    {
      put_chrs(html_context, (unsigned __int8 *)"&nbsp;", 6);
      v14 = 0;
      v15 = *((_DWORD *)html_context->stack.next + 34);
      if ( v15 )
      {
        v16 = 97;
        if ( v25 == 3 )
          v16 = 65;
        v14 = (v15 - 1) % 0x1Au + v16;
      }
      n[0] = v14;
      v11 = 1;
      n[1] = 0;
    }
    else if ( (unsigned int)(v25 - 4) <= 1 )
    {
      v17 = *((_DWORD *)html_context->stack.next + 34);
      if ( v17 > 0xF9F )
      {
        strcpy((char *)n, "---");
      }
      else if ( v17 )
      {
        n[0] = 0;
        v24 = 0;
        do
        {
          while ( 1 )
          {
            v18 = roman_tbl[v24].n;
            v26 = v18;
            if ( v17 >= v18 )
            {
              v17 -= v18;
              v19 = -v18;
              s = roman_tbl[v24].s;
              while ( 1 )
              {
                __strcat_chk(n, s, 32);
                if ( __CFADD__(v17 + v19, v26) )
                  break;
                v17 += v19;
              }
            }
            if ( assert_failed )
            {
LABEL_36:
              v5 = html_context;
              assert_failed = 0;
              goto LABEL_37;
            }
            ++v24;
            if ( !v17 || roman_tbl[v24].n )
              break;
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/general.c";
            errline = 844;
            elinks_internal("assertion !(n && !roman_tbl[i].n) failed: BUG in roman number converter");
            if ( assert_failed )
              goto LABEL_36;
          }
          assert_failed = 0;
        }
        while ( v17 );
        v5 = html_context;
      }
      else
      {
        strcpy((char *)n, "o");
      }
LABEL_37:
      if ( v25 == 5 && (v21 = n[0]) != 0 )
      {
        v22 = n;
        do
        {
          *v22++ = c_toupper(v21);
          v21 = *v22;
        }
        while ( *v22 );
        v11 = 0;
      }
      else
      {
        v11 = 0;
      }
    }
    else
    {
      v9 = 0;
      v10 = *((_DWORD *)html_context->stack.next + 34);
      if ( v10 <= 9 )
      {
        v9 = 1;
        put_chrs(html_context, (unsigned __int8 *)"&nbsp;", 6);
        v10 = *((_DWORD *)html_context->stack.next + 34);
      }
      elinks_ulongcat(n, 0, v10, 0x1Fu, 0, 0xAu, 0);
      v11 = v9;
    }
    v12 = &n[strlen((const char *)n)];
    v23 = v11;
    put_chrs(v5, n, v12 - n);
    put_chrs(v5, ".&nbsp;", 7);
    *((_DWORD *)v5->stack.next + 30) += v23 + 2 + v12 - n;
    *((_DWORD *)v5->stack.next + 29) = 0;
    v13 = search_html_stack(v5, (unsigned __int8 *)"ol");
    if ( v13 )
      v13->parattr.list_number = *((_DWORD *)v5->stack.next + 34) + 1;
    *((_DWORD *)v5->stack.next + 34) = 0;
  }
  else
  {
    qmemcpy(x, "*&nbsp;", sizeof(x));
    v7 = next[36] & 7;
    if ( v7 == 2 )
    {
      x[0] = 111;
    }
    else if ( v7 == 3 )
    {
      x[0] = 43;
    }
    put_chrs(html_context, x, 7);
    *((_DWORD *)html_context->stack.next + 30) += 2;
    *((_DWORD *)html_context->stack.next + 29) = 0;
  }
  v5->putsp = HTML_SPACE_SUPPRESS;
  v5->line_breax = 2;
  v5->was_li = 1;
}
// 8059118: using guessed type int __cdecl __strcat_chk(_DWORD, _DWORD, _DWORD);

//----- (08099680) --------------------------------------------------------
void __cdecl html_ul(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  char *v6; // esi
  _DWORD *next; // eax
  int v8; // edx

  ++*((_DWORD *)html_context->stack.next + 33);
  *((_DWORD *)html_context->stack.next + 34) = 0;
  *((_DWORD *)html_context->stack.next + 36) = 1;
  attr_value = get_attr_value(a, "type", html_context->doc_cp, HTML_ATTR_NONE);
  v6 = (char *)attr_value;
  if ( attr_value )
  {
    if ( c_strcasecmp((const char *)attr_value, "disc") && c_strcasecmp(v6, "circle") )
    {
      if ( !c_strcasecmp(v6, "square") )
        *((_DWORD *)html_context->stack.next + 36) = 3;
    }
    else
    {
      *((_DWORD *)html_context->stack.next + 36) = 2;
    }
    mem_free(v6);
  }
  *((_DWORD *)html_context->stack.next + 30) += (*((_DWORD *)html_context->stack.next + 33) > 1) + 2;
  if ( html_context->table_level )
    goto LABEL_8;
  next = html_context->stack.next;
  v8 = next[32] / 2;
  if ( v8 < next[30] )
  {
    next[30] = v8;
LABEL_8:
    next = html_context->stack.next;
  }
  next[29] = 0;
  *((_DWORD *)html_context->stack.next + 2) = 1;
}

//----- (080997A0) --------------------------------------------------------
void __cdecl html_linebrk(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v6; // ebx
  _DWORD *next; // eax

  attr_value = get_attr_value(a, "align", html_context->doc_cp, HTML_ATTR_NONE);
  v6 = attr_value;
  if ( attr_value )
  {
    if ( !c_strcasecmp((const char *)attr_value, "left") )
    {
      *((_DWORD *)html_context->stack.next + 29) = 0;
LABEL_4:
      mem_free(v6);
      return;
    }
    if ( c_strcasecmp((const char *)v6, "right") )
    {
      if ( c_strcasecmp((const char *)v6, "center") )
      {
        if ( !c_strcasecmp((const char *)v6, "justify") )
          *((_DWORD *)html_context->stack.next + 29) = 3;
      }
      else
      {
        *((_DWORD *)html_context->stack.next + 29) = 1;
        if ( !html_context->table_level )
        {
          next = html_context->stack.next;
          next[31] = 0;
          next[30] = 0;
        }
      }
      goto LABEL_4;
    }
    *((_DWORD *)html_context->stack.next + 29) = 2;
    mem_free(v6);
  }
}

//----- (080998A0) --------------------------------------------------------
void __cdecl html_tr(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_linebrk(html_context, a, html, eof, end);
}

//----- (080998B0) --------------------------------------------------------
void __cdecl html_h(
        int h,
        unsigned __int8 *a,
        format_align default_align,
        html_context *html_context,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  _DWORD *next; // eax
  _DWORD *v8; // edx
  int v9; // eax
  int v10; // ecx
  int v11; // eax

  next = html_context->stack.next;
  if ( !next[29] )
    next[29] = default_align;
  html_linebrk(html_context, a, html, eof, end);
  v8 = html_context->stack.next;
  v9 = 0;
  if ( h - 2 >= 0 )
    v9 = h - 2;
  v10 = v8[29];
  if ( v10 == 1 )
  {
    v8[31] = 0;
    v8[30] = 0;
  }
  else if ( v10 )
  {
    if ( v10 == 2 )
    {
      v8[30] = 0;
      *((_DWORD *)html_context->stack.next + 31) = 2 * v9;
    }
    else if ( v10 == 3 )
    {
      v11 = 2 * v9;
      v8[31] = v11;
      v8[30] = v11;
    }
  }
  else
  {
    v8[30] = 2 * v9;
    *((_DWORD *)html_context->stack.next + 31) = 0;
  }
}

//----- (08099970) --------------------------------------------------------
void __cdecl html_h6(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_h(6, a, ALIGN_LEFT, html_context, html, eof, end);
}

//----- (080999B0) --------------------------------------------------------
void __cdecl html_h5(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_h(5, a, ALIGN_LEFT, html_context, html, eof, end);
}

//----- (080999F0) --------------------------------------------------------
void __cdecl html_h4(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_h(4, a, ALIGN_LEFT, html_context, html, eof, end);
}

//----- (08099A30) --------------------------------------------------------
void __cdecl html_h3(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_h(3, a, ALIGN_LEFT, html_context, html, eof, end);
}

//----- (08099A70) --------------------------------------------------------
void __cdecl html_h2(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  html_h(2, a, ALIGN_LEFT, html_context, html, eof, end);
}

//----- (08099AB0) --------------------------------------------------------
void __cdecl html_h1(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  *((_DWORD *)html_context->stack.next + 3) |= 1u;
  html_h(1, a, ALIGN_CENTER, html_context, html, eof, end);
}

//----- (08099B00) --------------------------------------------------------
void __cdecl html_p(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  _DWORD *next; // edx
  int margin; // ecx

  next = html_context->stack.next;
  margin = html_context->margin;
  if ( margin > next[30] )
  {
    next[30] = margin;
    margin = html_context->margin;
    next = html_context->stack.next;
  }
  if ( next[31] < margin )
    next[31] = margin;
  html_linebrk(html_context, a, html, eof, end);
}

//----- (08099B60) --------------------------------------------------------
void __cdecl html_br(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  char v5; // al

  html_linebrk(html_context, a, html, eof, end);
  v5 = *((_BYTE *)html_context + 68);
  if ( (v5 & 1) != 0 )
    ln_break(html_context, 2);
  else
    *((_BYTE *)html_context + 68) = v5 | 1;
}

//----- (08099BC0) --------------------------------------------------------
void __cdecl html_base(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // eax
  unsigned __int8 *target; // esi
  unsigned __int8 *p; // [esp+18h] [ebp-20h]
  uri *uri; // [esp+1Ch] [ebp-1Ch]

  attr_value = get_attr_value(a, "href", html_context->doc_cp, HTML_ATTR_EAT_NL);
  v6 = attr_value;
  if ( attr_value )
  {
    v7 = join_urls(html_context->base_href, attr_value);
    if ( v7 )
    {
      p = v7;
      uri = get_uri(v7, (uri_component)0);
      mem_free(v6);
      mem_free(p);
      if ( uri )
      {
        done_uri(html_context->base_href);
        html_context->base_href = uri;
      }
    }
    else
    {
      mem_free(v6);
    }
  }
  target = get_target(html_context->options, a);
  if ( target )
  {
    if ( html_context->base_target )
      mem_free(html_context->base_target);
    html_context->base_target = target;
  }
}

//----- (08099CA0) --------------------------------------------------------
void __cdecl html_table(
        html_context *html_context,
        unsigned __int8 *attr,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  _DWORD *next; // eax
  int margin; // edx

  if ( (*((_BYTE *)html_context->options + 68) & 4) != 0 && html_context->table_level <= 9 )
  {
    format_table(attr, html, eof, end, html_context);
    ln_break(html_context, 2);
  }
  else
  {
    next = html_context->stack.next;
    margin = html_context->margin;
    next[30] = margin;
    next[31] = margin;
    *((_DWORD *)html_context->stack.next + 29) = 0;
    html_linebrk(html_context, attr, html, eof, end);
    *((_DWORD *)html_context->stack.next + 3) = 0;
  }
}

//----- (08099D50) --------------------------------------------------------
void __cdecl html_hr(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end)
{
  void **next; // eax
  _DWORD *v6; // eax
  int margin; // edx
  int width; // esi
  _DWORD *v9; // eax
  char r[25]; // [esp+2Fh] [ebp-19h] BYREF

  r[0] = -51;
  if ( (unsigned int)get_num(a, (unsigned __int8 *)"size", html_context->doc_cp) <= 1 )
    r[0] = -60;
  html_stack_dup(html_context, ELEMENT_KILLABLE);
  *((_DWORD *)html_context->stack.next + 29) = 1;
  next = (void **)html_context->stack.next;
  if ( next[7] )
  {
    mem_free(next[7]);
    next = (void **)html_context->stack.next;
  }
  next[7] = 0;
  *((_DWORD *)html_context->stack.next + 11) = 0;
  html_linebrk(html_context, a, html, eof, end);
  v6 = html_context->stack.next;
  if ( v6[29] == 3 )
  {
    v6[29] = 1;
    v6 = html_context->stack.next;
  }
  margin = html_context->margin;
  v6[31] = margin;
  v6[30] = margin;
  width = get_width(a, "width", 1, html_context);
  if ( width == -1 )
  {
    v9 = html_context->stack.next;
    width = 0;
    if ( v9[32] + -v9[31] - v9[30] >= 0 )
      width = v9[32] + -v9[31] - v9[30];
  }
  else
  {
    v9 = html_context->stack.next;
  }
  v9[3] = 16;
  html_context->special_f(html_context, 7, 1);
  while ( width > 0 )
  {
    --width;
    put_chrs(html_context, (unsigned __int8 *)r, 1);
  }
  html_context->special_f(html_context, 7, 0);
  ln_break(html_context, 2);
  kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
}
// 8099D50: using guessed type unsigned __int8 r[25];

//----- (08099EE0) --------------------------------------------------------
void __cdecl html_handle_body_meta(html_context *html_context, unsigned __int8 *meta, unsigned __int8 *eof)
{
  string head; // [esp+28h] [ebp-10h] BYREF

  if ( init_string(&head) )
  {
    scan_http_equiv(meta, eof, &head, 0, html_context->options);
    process_head(html_context, head.source);
    done_string(&head);
  }
}

//----- (08099F50) --------------------------------------------------------
void __cdecl html_apply_canvas_bgcolor(html_context *html_context)
{
  _DWORD *next; // eax
  _DWORD *prev; // ecx
  int v3; // edx

  if ( (*((_BYTE *)html_context->options + 68) & 1) != 0 )
    css_apply(html_context, (html_element *)html_context->stack.next, &html_context->css_styles, &html_context->stack);
  next = html_context->stack.next;
  if ( next[37] != next[5] )
  {
    *((_BYTE *)html_context + 68) |= 0x20u;
    prev = html_context->stack.prev;
    v3 = next[5];
    next[37] = v3;
    prev[5] = v3;
    prev[37] = v3;
  }
  if ( (*((_BYTE *)html_context + 68) & 8) != 0
    && *((_DWORD *)html_context->stack.next + 37) != html_context->options->default_style.bg
    && !search_html_stack(html_context, "BODY") )
  {
    html_context->special_f(html_context, 12);
  }
}

//----- (0809A000) --------------------------------------------------------
void __cdecl html_html_close(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  if ( *((_DWORD *)html_context->stack.next + 2) > 1u && (*((_BYTE *)html_context + 68) & 0x20) == 0 )
    html_apply_canvas_bgcolor(html_context);
}

//----- (0809A030) --------------------------------------------------------
void __cdecl html_body(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  char v6; // al

  get_color(html_context, a, "text", (color_T *)html_context->stack.next + 4);
  get_color(html_context, a, "link", (color_T *)html_context->stack.next + 12);
  get_color(html_context, a, (unsigned __int8 *)"vlink", (color_T *)html_context->stack.next + 13);
  if ( get_bgcolor(html_context, a, (color_T *)html_context->stack.next + 5) == -1 )
  {
    v6 = *((_BYTE *)html_context + 68);
  }
  else
  {
    v6 = *((_BYTE *)html_context + 68) | 0x20;
    *((_BYTE *)html_context + 68) = v6;
  }
  *((_BYTE *)html_context + 68) = v6 | 0x10;
  html_apply_canvas_bgcolor(html_context);
}

//----- (0809A0E0) --------------------------------------------------------
void __cdecl html_font(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v6; // ebx
  unsigned __int8 v7; // al
  int *v8; // eax
  int *v9; // edi
  unsigned int v10; // eax
  int v11; // edx
  _DWORD *next; // edx
  int v13; // eax
  int p; // [esp+18h] [ebp-30h]
  unsigned __int8 *nn; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *end; // [esp+2Ch] [ebp-1Ch] BYREF

  attr_value = get_attr_value(a, (unsigned __int8 *)"size", html_context->doc_cp, HTML_ATTR_NONE);
  v6 = attr_value;
  if ( attr_value )
  {
    v7 = *attr_value;
    if ( v7 == 43 )
    {
      nn = v6 + 1;
      p = 1;
    }
    else
    {
      nn = v6;
      p = 0;
      if ( v7 == 45 )
      {
        nn = v6 + 1;
        p = -1;
      }
    }
    v8 = __errno_location();
    *v8 = 0;
    v9 = v8;
    v10 = strtoul((const char *)nn, (char **)&end, 10);
    if ( !*v9 && *nn && !*end )
    {
      v11 = 7;
      if ( v10 <= 7 )
        v11 = v10;
      if ( p )
        *((_DWORD *)html_context->stack.next + 6) += p * v11;
      else
        *((_DWORD *)html_context->stack.next + 6) = v11;
      next = html_context->stack.next;
      v13 = next[6];
      if ( v13 <= 0 )
      {
        next[6] = 1;
      }
      else if ( v13 > 7 )
      {
        next[6] = 7;
      }
    }
    mem_free(v6);
  }
  get_color(html_context, a, "color", (color_T *)html_context->stack.next + 4);
}

//----- (0809A240) --------------------------------------------------------
unsigned __int8 *__usercall truncate_label@<eax>(unsigned __int8 *label@<eax>, int max_len@<edx>)
{
  _BYTE *v4; // edi
  int v5; // eax
  int v6; // ecx
  int v8; // eax
  _BYTE *v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // [esp+14h] [ebp-24h]
  int right_part_len; // [esp+18h] [ebp-20h]
  int n; // [esp+1Ch] [ebp-1Ch]

  v4 = 0;
  v5 = strlen((const char *)label);
  v6 = v5;
  if ( max_len >= 0 )
  {
    if ( v5 > max_len && max_len )
    {
      n = max_len / 2;
      v8 = max_len / 2 - 1;
      if ( max_len >= 2 * (max_len / 2) + 1 )
        v8 = max_len / 2;
      v12 = v6;
      right_part_len = v8;
      v9 = mem_alloc(max_len + 1);
      v10 = v12;
      v4 = v9;
      if ( v9 )
      {
        v11 = 0;
        if ( n )
        {
          memcpy(v9, label, n);
          v10 = v12;
          v11 = max_len / 2;
        }
        v4[v11] = 42;
        if ( right_part_len )
          memcpy(&v4[v11 + 1], &label[v10 - right_part_len], right_part_len);
        v4[max_len] = 0;
      }
    }
    else
    {
      return stracpy(label);
    }
  }
  return v4;
}

//----- (0809A320) --------------------------------------------------------
unsigned __int8 *__usercall get_image_filename_from_src@<eax>(int max_len@<eax>, unsigned __int8 *src@<edx>)
{
  int v3; // eax
  unsigned __int8 v4; // cl
  int v5; // ebx
  unsigned __int8 *v6; // eax
  unsigned int v7; // ecx
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // ebx
  unsigned __int8 *v10; // esi

  if ( !src )
    return 0;
  if ( !*src || *src == 63 )
  {
    v6 = src;
    v5 = 0;
  }
  else
  {
    v3 = 0;
    do
      v4 = src[++v3];
    while ( v4 && v4 != 63 );
    v5 = v3;
    v6 = &src[v3];
    if ( src < v6 )
    {
      do
      {
        v7 = (unsigned int)(v6 - 1);
        if ( *(v6 - 1) == 47 )
          break;
        --v6;
      }
      while ( (unsigned int)src < v7 );
    }
  }
  v8 = memacpy(v6, &src[v5] - v6);
  v9 = v8;
  if ( !v8 )
    return 0;
  v10 = truncate_label(v8, max_len);
  mem_free(v9);
  return v10;
}

//----- (0809A3C0) --------------------------------------------------------
void __usercall put_image_label(
        unsigned __int8 *a@<eax>,
        unsigned __int8 *label@<edx>,
        html_context *html_context@<ecx>)
{
  _DWORD *next; // eax
  int v6; // edi
  int v7; // eax

  html_focusable(html_context, a);
  next = html_context->stack.next;
  v6 = next[4];
  next[4] = next[15];
  v7 = strlen((const char *)label);
  put_chrs(html_context, label, v7);
  *((_DWORD *)html_context->stack.next + 4) = v6;
}

//----- (0809A420) --------------------------------------------------------
void __usercall html_img_do(
        unsigned __int8 *a@<eax>,
        unsigned __int8 *object_src@<edx>,
        html_context *html_context@<ecx>)
{
  document_options *options; // esi
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // edi
  void **next; // edx
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // eax
  unsigned __int8 *image_filename_from_src; // edi
  void **v12; // eax
  void **v13; // eax
  int tagging; // eax
  _DWORD *v15; // esi
  _DWORD *v16; // esi
  void **v17; // eax
  void **v18; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // esi
  void **v21; // eax
  size_t v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // eax
  unsigned __int8 *p; // [esp+14h] [ebp-34h]
  unsigned __int8 *pc; // [esp+14h] [ebp-34h]
  unsigned __int8 *pd; // [esp+14h] [ebp-34h]
  unsigned __int8 *pe; // [esp+14h] [ebp-34h]
  unsigned __int8 *pa; // [esp+14h] [ebp-34h]
  unsigned __int8 *pb; // [esp+14h] [ebp-34h]
  int add_brackets; // [esp+18h] [ebp-30h]
  int ismap; // [esp+1Ch] [ebp-2Ch]
  int display_style; // [esp+20h] [ebp-28h]
  int usemap; // [esp+24h] [ebp-24h]
  unsigned __int8 *srca; // [esp+2Ch] [ebp-1Ch]

  options = html_context->options;
  display_style = options->image_link.display_style;
  attr_value = get_attr_value(a, "usemap", html_context->doc_cp, HTML_ATTR_NONE);
  usemap = 0;
  v6 = attr_value;
  if ( attr_value )
  {
    p = join_urls(html_context->base_href, attr_value);
    mem_free(v6);
    if ( !p )
      return;
    v7 = straconcat("MAP@", p, 0);
    mem_free(p);
    if ( !v7 )
      return;
    html_stack_dup(html_context, ELEMENT_KILLABLE);
    next = (void **)html_context->stack.next;
    if ( next[7] )
    {
      mem_free(next[7]);
      next = (void **)html_context->stack.next;
    }
    next[7] = v7;
    *((_DWORD *)html_context->stack.next + 11) = 0;
    *((_DWORD *)html_context->stack.next + 3) |= 1u;
    usemap = 1;
  }
  if ( !*((_DWORD *)html_context->stack.next + 7)
    || !get_attr_value(a, "ismap", html_context->doc_cp, HTML_ATTR_TEST)
    || (ismap = 1, usemap) )
  {
    ismap = 0;
  }
  v9 = 0;
  if ( (unsigned int)(display_style - 2) <= 1 )
  {
    v9 = get_attr_value(a, (unsigned __int8 *)"alt", html_context->doc_cp, HTML_ATTR_NONE);
    if ( v9 || (v9 = get_attr_value(a, "title", html_context->doc_cp, HTML_ATTR_NONE)) != 0 )
    {
      pa = v9;
      v22 = strlen((const char *)v9);
      v9 = pa;
      if ( v22 > 5 )
      {
        clr_spaces(pa);
        v9 = pa;
      }
    }
  }
  if ( !object_src || (pc = v9, v10 = stracpy(object_src), v9 = pc, (srca = v10) == 0) )
  {
    pb = v9;
    v24 = get_attr_value(a, (unsigned __int8 *)"src", html_context->doc_cp, HTML_ATTR_EAT_NL);
    v9 = pb;
    srca = v24;
    if ( !v24 )
    {
      v25 = get_attr_value(a, "dynsrc", html_context->doc_cp, HTML_ATTR_EAT_NL);
      v9 = pb;
      srca = v25;
    }
  }
  if ( v9 )
  {
    if ( *v9 )
    {
      pd = v9;
      image_filename_from_src = truncate_label(v9, options->image_link.label_maxlen);
      mem_free(pd);
      add_brackets = 0;
      goto LABEL_17;
    }
    mem_free(v9);
  }
  if ( (*((_BYTE *)options + 68) & 0x20) != 0 || *((_DWORD *)html_context->stack.next + 7) )
  {
    if ( usemap )
    {
      add_brackets = 1;
      image_filename_from_src = stracpy("USEMAP");
    }
    else if ( ismap )
    {
      add_brackets = 1;
      image_filename_from_src = stracpy("ISMAP");
    }
    else
    {
      if ( display_style != 3 )
        goto LABEL_20;
      add_brackets = 1;
      image_filename_from_src = get_image_filename_from_src(options->image_link.filename_maxlen, srca);
    }
LABEL_17:
    if ( image_filename_from_src )
    {
      if ( *image_filename_from_src )
        goto LABEL_22;
      mem_free(image_filename_from_src);
    }
LABEL_20:
    if ( display_style == 1 )
    {
      v23 = get_image_filename_from_src(options->image_link.filename_maxlen, srca);
      image_filename_from_src = v23;
      if ( v23 )
      {
        add_brackets = 1;
        if ( *v23 )
          goto LABEL_22;
        mem_free(v23);
      }
    }
    add_brackets = 1;
    image_filename_from_src = stracpy("IMG");
LABEL_22:
    v12 = (void **)html_context->stack.next;
    if ( v12[9] )
    {
      mem_free(v12[9]);
      v12 = (void **)html_context->stack.next;
    }
    v12[9] = 0;
    v13 = (void **)html_context->stack.next;
    if ( v13[10] )
    {
      mem_free(v13[10]);
      v13 = (void **)html_context->stack.next;
    }
    v13[10] = 0;
    if ( image_filename_from_src )
    {
      tagging = options->image_link.tagging;
      if ( tagging && (add_brackets || tagging == 2) )
      {
        v19 = straconcat(options->image_link.prefix, image_filename_from_src, options->image_link.suffix, 0);
        if ( v19 )
        {
          pe = v19;
          mem_free(image_filename_from_src);
          image_filename_from_src = pe;
        }
      }
      if ( (*((_BYTE *)&options->image_link + 24) & 1) != 0 )
      {
        if ( srca )
        {
          v15 = html_context->stack.next;
          v15[9] = join_urls(html_context->base_href, srca);
        }
        v16 = html_context->stack.next;
        v16[10] = get_attr_value(a, "title", html_context->doc_cp, HTML_ATTR_NONE);
        if ( ismap )
        {
          html_stack_dup(html_context, ELEMENT_KILLABLE);
          v20 = straconcat(*((const unsigned __int8 **)html_context->stack.next + 7), "?0,0", 0);
          if ( v20 )
          {
            v21 = (void **)html_context->stack.next;
            if ( v21[7] )
            {
              mem_free(v21[7]);
              v21 = (void **)html_context->stack.next;
            }
            v21[7] = v20;
          }
          put_image_label(a, image_filename_from_src, html_context);
          kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
        }
        else
        {
          put_image_label(a, image_filename_from_src, html_context);
        }
        v17 = (void **)html_context->stack.next;
        if ( v17[9] )
        {
          mem_free(v17[9]);
          v17 = (void **)html_context->stack.next;
        }
        v17[9] = 0;
        v18 = (void **)html_context->stack.next;
        if ( v18[10] )
        {
          mem_free(v18[10]);
          v18 = (void **)html_context->stack.next;
        }
        v18[10] = 0;
      }
      else
      {
        put_image_label(a, image_filename_from_src, html_context);
      }
      mem_free(image_filename_from_src);
    }
  }
  if ( srca )
    mem_free(srca);
  if ( usemap )
    kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
}

//----- (0809A9A0) --------------------------------------------------------
void __cdecl html_img(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  html_img_do(a, 0, html_context);
}

//----- (0809A9C0) --------------------------------------------------------
void __cdecl put_link_line(
        unsigned __int8 *prefix,
        unsigned __int8 *linkname,
        unsigned __int8 *link,
        unsigned __int8 *target,
        html_context *html_context)
{
  void **next; // eax
  void **v6; // eax
  void **v7; // eax
  int v8; // eax
  _DWORD *v9; // edi
  _DWORD *v10; // edi
  int v11; // eax

  *((_BYTE *)html_context + 68) |= 8u;
  html_stack_dup(html_context, ELEMENT_KILLABLE);
  ln_break(html_context, 1);
  next = (void **)html_context->stack.next;
  if ( next[7] )
  {
    mem_free(next[7]);
    next = (void **)html_context->stack.next;
  }
  next[7] = 0;
  v6 = (void **)html_context->stack.next;
  if ( v6[8] )
  {
    mem_free(v6[8]);
    v6 = (void **)html_context->stack.next;
  }
  v6[8] = 0;
  v7 = (void **)html_context->stack.next;
  if ( v7[10] )
  {
    mem_free(v7[10]);
    v7 = (void **)html_context->stack.next;
  }
  v7[10] = 0;
  *((_DWORD *)html_context->stack.next + 11) = 0;
  v8 = strlen((const char *)prefix);
  put_chrs(html_context, prefix, v8);
  v9 = html_context->stack.next;
  v9[7] = join_urls(html_context->base_href, link);
  v10 = html_context->stack.next;
  v10[8] = stracpy(target);
  *((_DWORD *)html_context->stack.next + 4) = *((_DWORD *)html_context->stack.next + 12);
  v11 = strlen((const char *)linkname);
  put_chrs(html_context, linkname, v11);
  ln_break(html_context, 1);
  kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
}

//----- (0809AAF0) --------------------------------------------------------
void __cdecl html_link(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *name; // eax
  unsigned __int8 *str; // edx
  int v8; // edi
  unsigned __int8 *href; // edi
  char *source; // edi
  lt_default_name *v11; // eax
  int v12; // eax
  int v13; // esi
  const unsigned __int8 *v14; // eax
  const unsigned __int8 *v15; // eax
  const unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  int v18; // eax
  const unsigned __int8 *v19; // eax
  char *v20; // eax
  hlink_type v21; // edx
  hlink_type type; // eax
  int link_display; // [esp+2Ch] [ebp-4Ch]
  hlink link; // [esp+34h] [ebp-44h] BYREF
  string text; // [esp+58h] [ebp-20h] BYREF

  link_display = html_context->options->meta_link_display;
  if ( !assert_failed )
  {
    assert_failed = a == 0;
    if ( !a )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/link.c";
      errline = 736;
      elinks_internal("assertion a && link failed!");
    }
  }
  memset(&link, 0, sizeof(link));
  attr_value = get_attr_value(a, "href", html_context->doc_cp, HTML_ATTR_EAT_NL);
  if ( attr_value )
  {
    link.href = attr_value;
    link.lang = get_attr_value(a, "lang", html_context->doc_cp, HTML_ATTR_NONE);
    link.hreflang = get_attr_value(a, (unsigned __int8 *)&byte_812C62E, html_context->doc_cp, HTML_ATTR_NONE);
    link.title = get_attr_value(a, "title", html_context->doc_cp, HTML_ATTR_NONE);
    link.content_type = get_attr_value(a, "type", html_context->doc_cp, HTML_ATTR_NONE);
    link.media = get_attr_value(a, "media", html_context->doc_cp, HTML_ATTR_NONE);
    name = get_attr_value(a, "rel", html_context->doc_cp, HTML_ATTR_NONE);
    link.name = name;
    if ( name )
    {
      link.direction = LD_REL;
    }
    else
    {
      name = get_attr_value(a, (unsigned __int8 *)"rev", html_context->doc_cp, HTML_ATTR_NONE);
      link.name = name;
      if ( !name )
        goto LABEL_13;
      link.direction = LD_REV;
    }
    str = lt_names[0].str;
    if ( lt_names[0].str )
    {
      v8 = 0;
      while ( 1 )
      {
        if ( !c_strcasecmp((const char *)name, (const char *)str) )
        {
          link.type = lt_names[v8].type;
          goto LABEL_13;
        }
        str = lt_names[++v8].str;
        if ( !str )
          break;
        name = link.name;
      }
      name = link.name;
    }
    if ( c_strcasestr((const char *)name, "icon")
      || link.content_type && c_strcasestr((const char *)link.content_type, "icon") )
    {
      link.type = LT_ICON;
    }
    else if ( c_strcasestr((const char *)link.name, "alternate") )
    {
      link.type = LT_ALTERNATE;
      if ( link.lang )
      {
        link.type = LT_ALTERNATE_LANG;
      }
      else if ( c_strcasestr((const char *)link.name, "stylesheet")
             || link.content_type && c_strcasestr((const char *)link.content_type, "css") )
      {
        link.type = LT_ALTERNATE_STYLESHEET;
      }
      else
      {
        type = LT_ALTERNATE_MEDIA;
        if ( !link.media )
          type = link.type;
        link.type = type;
      }
    }
    else if ( link.content_type )
    {
      v20 = c_strcasestr((const char *)link.content_type, "css");
      v21 = LT_STYLESHEET;
      if ( !v20 )
        v21 = link.type;
      link.type = v21;
    }
LABEL_13:
    href = link.href;
    if ( !link.href )
      goto LABEL_58;
    if ( link.type == LT_STYLESHEET )
    {
      v18 = strlen((const char *)link.href);
      import_css_stylesheet(&html_context->css_styles, html_context->base_href, href, v18);
    }
    if ( !link_display
      || link_display <= 4
      && ((unsigned int)(link.type - 16) <= 1 || link.type == LT_STYLESHEET || link.type == LT_ALTERNATE_STYLESHEET) )
    {
      goto LABEL_58;
    }
    source = (char *)link.name;
    if ( !link.name || link.type )
    {
      if ( !assert_failed )
        assert_failed = 0;
      source = (char *)lt_names[0].str;
      if ( lt_names[0].str )
      {
        v11 = lt_names;
        if ( lt_names[0].type == link.type )
          goto LABEL_29;
        while ( ++v11 )
        {
          source = (char *)v11->str;
          if ( !source )
            break;
          if ( link.type == v11->type )
            goto LABEL_29;
        }
      }
      source = "unknown";
    }
LABEL_29:
    if ( !init_string(&text) )
    {
LABEL_58:
      if ( !assert_failed )
        assert_failed = 0;
      if ( link.content_type )
        mem_free(link.content_type);
      if ( link.media )
        mem_free(link.media);
      if ( link.href )
        mem_free(link.href);
      if ( link.hreflang )
        mem_free(link.hreflang);
      if ( link.title )
        mem_free(link.title);
      if ( link.lang )
        mem_free(link.lang);
      if ( link.name )
        mem_free(link.name);
      return;
    }
    html_focusable(html_context, a);
    if ( link.title )
    {
      add_to_string(&text, link.title);
      v12 = strcmp((const char *)link.title, source);
    }
    else
    {
      add_to_string(&text, (const unsigned __int8 *)source);
      v12 = 0;
    }
    if ( link_display != 1 )
    {
      v13 = 1;
      if ( v12 )
      {
        LOWORD(v13) = 0;
        add_to_string(&text, " (");
        add_to_string(&text, (const unsigned __int8 *)source);
      }
      if ( link_display > 2 )
      {
        if ( link.hreflang )
        {
          v14 = ", ";
          if ( v13 )
            v14 = " (";
          v13 = 0;
          add_to_string(&text, v14);
          add_to_string(&text, link.hreflang);
        }
        if ( link_display != 3 && link.content_type )
        {
          v15 = ", ";
          if ( v13 )
            v15 = " (";
          v13 = 0;
          add_to_string(&text, v15);
          add_to_string(&text, link.content_type);
        }
      }
      if ( link.lang
        && link.type == LT_ALTERNATE_LANG
        && (link_display <= 2 || link.hreflang && c_strcasecmp((const char *)link.hreflang, (const char *)link.lang)) )
      {
        v19 = ", ";
        if ( v13 )
          v19 = " (";
        v13 = 0;
        add_to_string(&text, v19);
        add_to_string(&text, link.lang);
      }
      if ( link.media )
      {
        v16 = " (";
        if ( !v13 )
          v16 = ", ";
        add_to_string(&text, v16);
        add_to_string(&text, link.media);
      }
      else if ( v13 )
      {
        goto put_link_line;
      }
      add_char_to_string(&text, 0x29u);
    }
put_link_line:
    v17 = "Link: ";
    if ( link.direction != LD_REL )
      v17 = "Reverse link: ";
    if ( text.length )
      source = (char *)text.source;
    put_link_line(v17, (unsigned __int8 *)source, link.href, html_context->base_target, html_context);
    if ( text.source )
      done_string(&text);
    goto LABEL_58;
  }
}

//----- (0809B170) --------------------------------------------------------
void __usercall html_iframe_do(
        unsigned __int8 *a@<eax>,
        unsigned __int8 *object_src@<edx>,
        html_context *html_context@<ecx>)
{
  unsigned __int8 *v5; // edi
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *p; // [esp+2Ch] [ebp-1Ch]

  if ( object_src && (v5 = stracpy(object_src)) != 0
    || (v5 = get_attr_value(a, (unsigned __int8 *)"src", html_context->doc_cp, HTML_ATTR_EAT_NL)) != 0 )
  {
    attr_value = get_attr_value(a, (unsigned __int8 *)"name", html_context->doc_cp, HTML_ATTR_NONE);
    if ( attr_value
      || (attr_value = get_attr_value(a, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE)) != 0
      || (attr_value = stracpy((const unsigned __int8 *)&delete)) != 0 )
    {
      p = attr_value;
      html_focusable(html_context, a);
      if ( *p )
        put_link_line((unsigned __int8 *)&byte_812C668, p, v5, html_context->options->framename, html_context);
      else
        put_link_line((unsigned __int8 *)&delete, "IFrame", v5, html_context->options->framename, html_context);
      mem_free(p);
    }
    mem_free(v5);
  }
}

//----- (0809B2C0) --------------------------------------------------------
void __cdecl html_embed(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // eax
  unsigned __int8 *extension_content_type; // eax
  unsigned __int8 *v9; // edi

  attr_value = get_attr_value(a, (unsigned __int8 *)"src", html_context->doc_cp, HTML_ATTR_EAT_NL);
  v6 = attr_value;
  if ( attr_value )
  {
    if ( *attr_value )
    {
      v7 = (unsigned __int8 *)strrchr((const char *)attr_value, 46);
      if ( !v7 )
        v7 = v6;
      extension_content_type = get_extension_content_type(v7);
      v9 = extension_content_type;
      if ( extension_content_type )
      {
        if ( c_strncasecmp((const char *)extension_content_type, "image/", 6u) )
          html_iframe_do(a, v6, html_context);
        else
          html_img_do(a, v6, html_context);
        mem_free(v9);
      }
      else
      {
        html_iframe_do(a, v6, html_context);
      }
    }
    mem_free(v6);
  }
}

//----- (0809B3B0) --------------------------------------------------------
void __cdecl html_iframe(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  html_iframe_do(a, 0, html_context);
}

//----- (0809B3D0) --------------------------------------------------------
void __cdecl html_object(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // edi
  unsigned __int8 *p; // [esp+28h] [ebp-20h]
  unsigned __int8 *type; // [esp+2Ch] [ebp-1Ch]

  attr_value = get_attr_value(a, (unsigned __int8 *)"data", html_context->doc_cp, HTML_ATTR_EAT_NL);
  if ( attr_value || (attr_value = get_attr_value(a, "codebase", html_context->doc_cp, HTML_ATTR_EAT_NL)) != 0 )
  {
    type = get_attr_value(a, "type", html_context->doc_cp, HTML_ATTR_NONE);
    if ( type )
    {
      if ( c_strncasecmp((const char *)type, "text/", 5u) )
      {
        if ( c_strncasecmp((const char *)type, "image/", 6u) )
        {
          p = get_attr_value(a, "standby", html_context->doc_cp, HTML_ATTR_NONE);
          html_focusable(html_context, a);
          if ( p )
          {
            if ( *p )
              put_link_line("Object: ", p, attr_value, html_context->options->framename, html_context);
            else
              put_link_line("Object: ", type, attr_value, html_context->options->framename, html_context);
            mem_free(p);
          }
          else
          {
            put_link_line("Object: ", type, attr_value, html_context->options->framename, html_context);
          }
        }
        else
        {
          html_img_do(a, attr_value, html_context);
        }
      }
      else
      {
        html_iframe_do(a, attr_value, html_context);
        html_skip(html_context, a);
      }
      mem_free(type);
    }
    mem_free(attr_value);
  }
}

//----- (0809B5E0) --------------------------------------------------------
void __cdecl html_applet(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // edi
  unsigned __int8 *p; // [esp+2Ch] [ebp-1Ch]

  attr_value = get_attr_value(a, "code", html_context->doc_cp, HTML_ATTR_EAT_NL);
  if ( attr_value )
  {
    p = get_attr_value(a, (unsigned __int8 *)"alt", html_context->doc_cp, HTML_ATTR_NONE);
    html_focusable(html_context, a);
    if ( p )
    {
      if ( *p )
        put_link_line("Applet: ", p, attr_value, html_context->options->framename, html_context);
      else
        put_link_line((unsigned __int8 *)&delete, "Applet", attr_value, html_context->options->framename, html_context);
      mem_free(p);
    }
    else
    {
      put_link_line((unsigned __int8 *)&delete, "Applet", attr_value, html_context->options->framename, html_context);
    }
    mem_free(attr_value);
  }
}

//----- (0809B710) --------------------------------------------------------
void __cdecl html_a(
        html_context *html_context,
        unsigned __int8 *a,
        unsigned __int8 *xxx3,
        unsigned __int8 *xxx4,
        unsigned __int8 **xxx5)
{
  unsigned __int8 *attr_value; // esi
  size_t v6; // eax
  unsigned __int8 *i; // ecx
  unsigned __int8 *v8; // edi
  unsigned __int8 *v9; // edx
  char v10; // cl
  size_t v11; // eax
  unsigned __int8 *target; // esi
  void **v13; // edx
  void **v14; // esi
  void **v15; // esi
  _DWORD *v16; // eax
  int v17; // edx
  void **next; // [esp+18h] [ebp-20h]

  attr_value = get_attr_value(a, "href", html_context->doc_cp, HTML_ATTR_EAT_NL);
  if ( attr_value )
  {
    next = (void **)html_context->stack.next;
    if ( next[7] )
    {
      mem_free(next[7]);
      next = (void **)html_context->stack.next;
    }
    v6 = strlen((const char *)attr_value);
    for ( i = attr_value; *i == 32; --v6 )
      ++i;
    if ( v6 )
    {
      v8 = i;
      v9 = &i[v6];
      if ( i[v6 - 1] == 32 )
      {
        do
        {
          --v6;
          *(v9 - 1) = 0;
          if ( !v6 )
          {
            i = v8;
            goto LABEL_12;
          }
          v10 = *(v9 - 2);
          --v9;
        }
        while ( v10 == 32 );
        i = v8;
      }
      v11 = v6 + 1;
    }
    else
    {
LABEL_12:
      v11 = 1;
    }
    memmove(attr_value, i, v11);
    next[7] = join_urls(html_context->base_href, attr_value);
    mem_free(attr_value);
    target = get_target(html_context->options, a);
    if ( target )
    {
      v13 = (void **)html_context->stack.next;
      if ( v13[8] )
      {
        mem_free(v13[8]);
        v13 = (void **)html_context->stack.next;
      }
      v13[8] = target;
    }
    else
    {
      v15 = (void **)html_context->stack.next;
      if ( v15[8] )
      {
        mem_free(v15[8]);
        v15 = (void **)html_context->stack.next;
      }
      v15[8] = stracpy(html_context->base_target);
    }
    if ( get_global_history_item(*((unsigned __int8 **)html_context->stack.next + 7)) )
    {
      *((_DWORD *)html_context->stack.next + 4) = *((_DWORD *)html_context->stack.next + 13);
      *((_DWORD *)html_context->stack.next + 44) &= ~1u;
      *((_DWORD *)html_context->stack.next + 44) |= 2u;
    }
    else
    {
      if ( get_bookmark(*((unsigned __int8 **)html_context->stack.next + 7)) )
      {
        v16 = html_context->stack.next;
        v17 = v16[14];
      }
      else
      {
        v16 = html_context->stack.next;
        v17 = v16[12];
      }
      v16[4] = v17;
      *((_DWORD *)html_context->stack.next + 44) &= ~2u;
      *((_DWORD *)html_context->stack.next + 44) |= 1u;
    }
    v14 = (void **)html_context->stack.next;
    if ( v14[10] )
    {
      mem_free(v14[10]);
      v14 = (void **)html_context->stack.next;
    }
    v14[10] = get_attr_value(a, "title", html_context->doc_cp, HTML_ATTR_NONE);
    html_focusable(html_context, a);
  }
  else
  {
    kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
  }
  set_fragment_identifier(html_context, a, (unsigned __int8 *)"name");
}

//----- (0809B940) --------------------------------------------------------
void tags_list_reset()
{
  internal_pointer = elements;
}

//----- (0809B950) --------------------------------------------------------
fastfind_key_value *tags_list_next()
{
  fastfind_key_value *result; // eax
  unsigned __int8 *name; // ecx

  result = 0;
  name = internal_pointer->name;
  if ( internal_pointer->name )
  {
    kv_7440.data = internal_pointer;
    result = &kv_7440;
    kv_7440.key = name;
    ++internal_pointer;
  }
  return result;
}

//----- (0809B980) --------------------------------------------------------
unsigned __int8 *__cdecl skip_comment(unsigned __int8 *html, unsigned __int8 *eof)
{
  unsigned __int8 *v2; // ebx
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // esi
  unsigned int v6; // eax
  const unsigned __int16 **v8; // eax
  unsigned __int8 i; // dl
  unsigned __int8 v10; // [esp+Ch] [ebp-Ch]

  v2 = eof;
  v3 = html + 4;
  v4 = html + 2;
  if ( html + 4 <= eof )
  {
    v4 = html + 2;
    if ( html[2] == 45 && html[3] == 45 )
    {
      if ( v3 >= eof )
        return v2;
      while ( 1 )
      {
        v5 = v3 + 2;
        if ( eof < v3 + 2 || *v3 != 45 )
          break;
        v6 = (unsigned int)(v3 + 1);
        if ( v3[1] != 45 )
          goto LABEL_8;
        if ( eof <= v5 )
          return v2;
        while ( *v5 == 45 )
        {
          if ( eof <= ++v5 )
            return v2;
        }
        v10 = *v5;
        v8 = __ctype_b_loc();
        for ( i = v10; ((*v8)[i] & 0x2000) != 0; i = *v5 )
        {
          if ( eof <= ++v5 )
            return v2;
        }
        if ( eof <= v5 )
          return v2;
        if ( i == 62 )
          return v5 + 1;
LABEL_10:
        v3 = v5;
      }
      v6 = (unsigned int)(v3 + 1);
LABEL_8:
      if ( (unsigned int)eof <= v6 )
        return v2;
      v5 = (unsigned __int8 *)v6;
      goto LABEL_10;
    }
  }
  while ( 1 )
  {
    if ( eof <= v4 )
      return v2;
    if ( *v4 == 62 )
      break;
    ++v4;
  }
  return v4 + 1;
}

//----- (0809BA60) --------------------------------------------------------
int __cdecl parse_element(
        unsigned __int8 *e,
        unsigned __int8 *eof,
        unsigned __int8 **name,
        int *namelen,
        unsigned __int8 **attr,
        unsigned __int8 **end)
{
  int result; // eax
  unsigned __int8 *v7; // esi
  unsigned __int8 v8; // dl
  const unsigned __int16 **v9; // eax
  unsigned __int8 v10; // dl
  const unsigned __int16 *v11; // ecx
  const unsigned __int16 **v12; // edi
  unsigned __int16 v13; // ax
  unsigned __int16 i; // ax
  _BYTE *v15; // eax
  unsigned __int8 v16; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    assert_failed = e == 0 || eof == 0;
    if ( e == 0 || eof == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
      errline = 60;
      elinks_internal("assertion e && eof failed!");
    }
  }
  if ( e >= eof )
    return -1;
  if ( *e != 60 )
    return -1;
  v7 = e + 1;
  if ( e + 1 == eof )
    return -1;
  if ( name )
    *name = v7;
  v8 = e[1];
  if ( v8 == 47 )
  {
    v7 = e + 2;
    if ( e + 2 == eof )
      return -1;
    v8 = *v7;
  }
  if ( (unsigned __int8)(v8 - 97) <= 0x19u
    || (unsigned __int8)(v8 - 65) <= 0x19u
    || (unsigned __int8)(v8 - 48) <= 9u
    || v8 == 95
    || v8 == 45 )
  {
    while ( (unsigned __int8)(v8 - 97) <= 0x19u
         || (unsigned __int8)(v8 - 65) <= 0x19u
         || (unsigned __int8)(v8 - 48) <= 9u
         || v8 == 95
         || v8 == 45 )
    {
      if ( ++v7 == eof )
        return -1;
      v8 = *v7;
    }
    v16 = v8;
    v9 = __ctype_b_loc();
    v10 = v16;
    v11 = *v9;
    v12 = v9;
    v13 = (*v9)[v16];
    if ( (v13 & 0x2000) != 0 || v16 == 60 || v16 == 62 || v16 == 47 || v16 == 58 || v16 == 61 )
    {
      if ( namelen && name )
      {
        *namelen = v7 - *name;
        v10 = *v7;
        v11 = *v12;
        v13 = (*v12)[*v7];
      }
      while ( (v13 & 0x2000) != 0 || v10 == 47 || v10 == 58 )
      {
        if ( ++v7 == eof )
          return -1;
        v10 = *v7;
        v13 = v11[*v7];
      }
      while ( (v10 > 0x7Eu || v10 <= 0x3Eu && (v10 == 61 || v10 <= 0x20u)) && (v11[v10] & 0x2000) == 0 )
      {
        if ( ++v7 == eof )
          return -1;
        v10 = *v7;
      }
      if ( attr )
      {
        *attr = v7;
        v11 = *v12;
        v10 = *v7;
      }
      i = v11[v10];
      while ( 1 )
      {
LABEL_44:
        while ( (i & 0x2000) != 0 )
        {
          if ( ++v7 == eof )
            return -1;
          v10 = *v7;
          i = v11[*v7];
        }
        while ( (v10 > 0x7Eu || v10 <= 0x3Eu && (v10 == 61 || v10 <= 0x20u)) && (v11[v10] & 0x2000) == 0 )
        {
          if ( ++v7 == eof )
            return -1;
          v10 = *v7;
        }
        if ( v10 == 60 || v10 == 62 )
        {
LABEL_73:
          result = 0;
          if ( end )
          {
            result = 0;
            *end = &v7[*v7 == 62];
          }
          return result;
        }
        while ( v10 <= 0x7Eu && (v10 > 0x3Eu || v10 != 61 && v10 > 0x20u && v10 != 60 && v10 != 62) )
        {
          if ( ++v7 == eof )
            return -1;
          v10 = *v7;
        }
        while ( 1 )
        {
          i = v11[v10];
          if ( (i & 0x2000) == 0 )
            break;
          if ( ++v7 == eof )
            return -1;
          v10 = *v7;
        }
        if ( v10 == 61 )
          break;
        if ( v10 == 60 || v10 == 62 )
          goto LABEL_73;
        v10 = *v7;
      }
      while ( ++v7 != eof )
      {
        v10 = *v7;
        if ( (v11[*v7] & 0x2000) == 0 )
        {
          if ( v10 == 39 || v10 == 34 )
          {
            v15 = v7 + 1;
            if ( v7 + 1 == eof )
              return -1;
            while ( v10 != *v15 )
            {
              if ( ++v15 == eof )
                return -1;
            }
            v7 = v15 + 1;
            if ( v15 + 1 == eof )
              return -1;
            v10 = v15[1];
          }
          else
          {
            while ( v10 != 60 && v10 != 62 )
            {
              if ( ++v7 == eof )
                return -1;
              v10 = *v7;
              i = v11[*v7];
              if ( (i & 0x2000) != 0 )
                break;
            }
          }
          for ( i = v11[v10]; (i & 0x2000) != 0; i = v11[*v7] )
          {
            if ( ++v7 == eof )
              return -1;
            v10 = *v7;
          }
          if ( v10 != 60 && v10 != 62 )
            goto LABEL_44;
          goto LABEL_73;
        }
      }
    }
  }
  return -1;
}
// 809BC99: conditional instruction was optimized away because dl.1 is in (<21u|==3D|>=7Fu)
// 809BCA2: conditional instruction was optimized away because dl.1 is in (<21u|==3D|>=7Fu)
// 809BD70: conditional instruction was optimized away because dl.1 is in (<21u|==3D|>=7Fu)
// 809BD79: conditional instruction was optimized away because dl.1 is in (<21u|==3D|>=7Fu)

//----- (0809BE60) --------------------------------------------------------
void free_tags_lookup()
{
  fastfind_done(&ff_tags_index);
}

//----- (0809BE80) --------------------------------------------------------
void init_tags_lookup()
{
  fastfind_index_0(&ff_tags_index, FF_LOCALE_INDEP|FF_COMPRESS);
}

//----- (0809BEA0) --------------------------------------------------------
void *__usercall mem_align_alloc___2@<eax>(void **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // esi
  unsigned int v4; // edi
  void *result; // eax
  char *v7; // edx

  v3 = (a3 + 255) & 0xFFFFFF00;
  v4 = (a2 + 255) & 0xFFFFFF00;
  if ( v3 <= v4 )
    return *a1;
  v7 = (char *)mem_realloc(*a1, (a3 + 255) & 0xFFFFFF00);
  result = 0;
  if ( v7 )
  {
    *a1 = v7;
    memset(&v7[v4], 0, v3 - v4);
    return *a1;
  }
  return result;
}

//----- (0809BF20) --------------------------------------------------------
unsigned __int8 *__cdecl get_attr_value(unsigned __int8 *e, unsigned __int8 *name, int cp, html_attr_flags flags)
{
  unsigned __int8 *v4; // edi
  const unsigned __int16 *v5; // ecx
  unsigned __int8 v6; // al
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v9; // ebx
  unsigned __int8 *v10; // esi
  unsigned __int8 *v11; // ebx
  unsigned __int8 v12; // dl
  unsigned __int8 *v13; // ecx
  unsigned __int8 v14; // dl
  unsigned __int8 *v15; // edi
  int v16; // edx
  int v17; // edi
  int v18; // eax
  unsigned __int8 v19; // si
  int v20; // ecx
  int v21; // edi
  void *v22; // eax
  char v23; // al
  unsigned __int8 *v24; // edx
  unsigned __int8 v25; // al
  size_t v26; // ebx
  unsigned int v27; // esi
  int v28; // ecx
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // [esp+2Ch] [ebp-3Ch]
  unsigned __int8 *v31; // [esp+30h] [ebp-38h]
  unsigned __int16 v32; // [esp+38h] [ebp-30h]
  size_t v33; // [esp+38h] [ebp-30h]
  const unsigned __int16 **v34; // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 *attr[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  v4 = e;
  attr[0] = 0;
  v34 = __ctype_b_loc();
  v5 = *v34;
  v6 = *e;
  v32 = (*v34)[*e];
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_2:
      if ( (v32 & 0x2000) != 0 )
      {
        v6 = v4[1];
        v9 = v4 + 1;
        v32 = v5[v6];
        goto LABEL_10;
      }
      if ( v6 == 60 || v6 == 62 || v6 > 0x7Eu || v6 <= 0x3Eu && (v6 == 61 || v6 <= 0x20u) )
        goto parse_error;
      v10 = name;
      v11 = v4;
      v12 = *name;
      if ( *name > 0x7Eu )
      {
LABEL_36:
        v11 = v4;
        v16 = 0;
      }
      else
      {
        v13 = v4;
        while ( 1 )
        {
          if ( v12 <= 0x3Eu && (v12 == 61 || v12 <= 0x20u || v12 == 60 || v12 == 62) )
          {
LABEL_21:
            v14 = *v10;
            v15 = v13;
            v6 = *v11;
            goto LABEL_22;
          }
          if ( v6 > 0x7Eu || v6 <= 0x3Eu && (v6 == 61 || v6 <= 0x20u || v6 == 60 || v6 == 62) )
            break;
          v31 = v13;
          v17 = c_toupper(v6);
          v18 = c_toupper(*v10);
          v13 = v31;
          if ( v17 != v18 )
            goto LABEL_21;
          ++v10;
          ++v11;
          v12 = *v10;
          if ( *v10 > 0x7Eu )
          {
            v4 = v11;
            v6 = *v11;
            v5 = *v34;
            goto LABEL_36;
          }
          v6 = *v11;
        }
        v15 = v13;
        v14 = *v10;
LABEL_22:
        if ( v14 )
        {
          v16 = 0;
          v5 = *v34;
        }
        else
        {
          if ( v6 <= 0x7Eu && (v6 > 0x3Eu || v6 != 61 && v6 > 0x20u && v6 != 60 && v6 != 62) )
          {
            v16 = 0;
            v5 = *v34;
            goto LABEL_38;
          }
          if ( (flags & 1) != 0 )
            return v15;
          v16 = 1;
          v5 = *v34;
        }
      }
      if ( v6 <= 0x7Eu )
      {
LABEL_38:
        while ( v6 > 0x3Eu || v6 != 61 && v6 > 0x20u && v6 != 60 && v6 != 62 )
        {
          v6 = *++v11;
          if ( *v11 > 0x7Eu )
          {
            if ( (v5[v6] & 0x2000) == 0 )
              goto LABEL_48;
            goto LABEL_45;
          }
        }
        goto LABEL_46;
      }
      while ( (v5[v6] & 0x2000) != 0 )
      {
LABEL_45:
        ++v11;
LABEL_46:
        v6 = *v11;
      }
LABEL_48:
      if ( v6 == 61 )
        break;
      if ( v16 )
        goto found_endattr;
LABEL_50:
      v6 = *v11;
      v4 = v11;
      v32 = v5[*v11];
    }
    v9 = v11 + 1;
    v19 = *v9;
    if ( (v5[*v9] & 0x2000) != 0 )
    {
      do
        ++v9;
      while ( (v5[*v9] & 0x2000) != 0 );
      v19 = *v9;
    }
    if ( v16 )
      break;
    v6 = v19;
    if ( v19 == 39 || v19 == 34 )
    {
      while ( v19 != *++v9 )
      {
        if ( !*v9 )
          goto parse_error;
      }
      v11 = v9 + 1;
      goto LABEL_50;
    }
    v32 = v5[v19];
    if ( (v32 & 0x2000) == 0 && v19 != 60 && v19 != 62 )
    {
      while ( v6 )
      {
        v6 = *++v9;
        if ( (v5[*v9] & 0x2000) != 0 || v6 == 60 || v6 == 62 )
        {
          v32 = v5[v6];
          v4 = v9;
          goto LABEL_2;
        }
      }
      goto parse_error;
    }
LABEL_10:
    v4 = v9;
  }
  if ( v19 != 39 && v19 != 34 )
  {
    if ( (v5[v19] & 0x2000) != 0 || v19 == 62 || v19 == 60 )
    {
found_endattr:
      v33 = 0;
      v20 = 1;
      v21 = 0;
    }
    else
    {
      v21 = 0;
      if ( !v19 )
      {
parse_error:
        if ( attr[0] )
        {
          mem_free(attr[0]);
          return 0;
        }
        return 0;
      }
      v24 = v9;
      while ( 1 )
      {
        v26 = ++v21 + 255;
        LOBYTE(v26) = 0;
        v27 = (v21 + 254) & 0xFFFFFF00;
        v33 = v21;
        v28 = v21 - 1;
        if ( v26 > v27 )
        {
          v30 = v24;
          v29 = (unsigned __int8 *)mem_realloc(attr[0], v26);
          if ( !v29 )
            return 0;
          attr[0] = v29;
          memset(&v29[v27], 0, v26 - v27);
          v28 = v21 - 1;
          v24 = v30;
        }
        if ( !attr[0] )
          return 0;
        attr[0][v28] = v24[v21 - 1];
        v25 = v24[v21];
        if ( ((*v34)[v25] & 0x2000) != 0 || v25 == 60 || v25 == 62 )
          break;
        if ( !v25 )
          goto parse_error;
      }
      v20 = v21 + 1;
    }
    v22 = mem_align_alloc___2((void **)attr, v33, v20);
    goto LABEL_80;
  }
  v21 = 0;
  while ( 1 )
  {
    v23 = *++v9;
    if ( *v9 == v19 )
      break;
    if ( !v23 )
      goto parse_error;
    if ( (flags & 8) != 0 )
    {
LABEL_96:
      if ( !mem_align_alloc___2((void **)attr, v21, v21 + 1) )
        return 0;
      attr[0][v21++] = *v9;
    }
    else if ( v23 != 13 )
    {
      if ( (unsigned __int8)(v23 - 9) > 1u )
        goto LABEL_96;
      if ( (flags & 2) == 0 )
      {
        if ( !mem_align_alloc___2((void **)attr, v21, v21 + 1) )
          return 0;
        attr[0][v21++] = 32;
      }
    }
  }
  v33 = v21;
  v22 = mem_align_alloc___2((void **)attr, v21, v21 + 1);
LABEL_80:
  if ( !v22 )
    return 0;
  attr[0][v33] = 0;
  v7 = attr[0];
  if ( memchr(attr[0], 38, v33) )
  {
    attr[0] = convert_string_elinks(0, v7, v21, cp, CSM_QUERY, 0, 0, 0);
    mem_free(v7);
    return attr[0];
  }
  return v7;
}

//----- (0809C460) --------------------------------------------------------
void __cdecl scan_http_equiv(
        unsigned __int8 *s,
        unsigned __int8 *eof,
        string *head,
        string *title,
        document_options *options)
{
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // eax
  unsigned __int8 v7; // dl
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edi
  signed int v10; // edi
  unsigned __int8 v11; // al
  unsigned int length; // eax
  unsigned int v13; // edx
  size_t v14; // ecx
  string *v15; // ecx
  unsigned __int8 *v16; // eax
  unsigned __int8 *attr_value; // ebx
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ebx
  unsigned __int8 *v20; // ebx
  size_t v21; // [esp+2Ch] [ebp-4Ch]
  int v22; // [esp+48h] [ebp-30h]
  unsigned int v23; // [esp+48h] [ebp-30h]
  unsigned int v24; // [esp+4Ch] [ebp-2Ch]
  int namelen; // [esp+54h] [ebp-24h] BYREF
  unsigned __int8 *attr; // [esp+58h] [ebp-20h] BYREF
  unsigned __int8 *name[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v5 = eof;
  if ( !title || init_string(title) )
  {
    add_char_to_string(head, 0xAu);
    v6 = s;
LABEL_4:
    if ( v5 <= v6 )
      return;
    do
    {
      if ( *v6 == 60 )
      {
        if ( v5 >= v6 + 2 )
        {
          v7 = v6[1];
          if ( v7 == 63 || v7 == 33 )
          {
            v6 = skip_comment(v6, v5);
            s = v6;
            goto LABEL_4;
          }
        }
        if ( !parse_element(v6, v5, name, &namelen, &attr, &s) )
        {
          while ( 2 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
            errline = 1075;
            if ( elinks_strlcasecmp(name[0], namelen, "HEAD", 4u, 1) )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
              errline = 1076;
              if ( !elinks_strlcasecmp(name[0], namelen, &byte_812C755, 5u, 1) )
                return;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
              errline = 1077;
              if ( !elinks_strlcasecmp(name[0], namelen, "BODY", 4u, 1) )
                return;
              if ( !title
                || title->length
                || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c",
                    errline = 1078,
                    elinks_strlcasecmp(name[0], namelen, "TITLE", 5u, 1)) )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
                errline = 1101;
                if ( !elinks_strlcasecmp(name[0], namelen, "META", 4u, 1) )
                {
                  attr_value = get_attr_value(attr, "charset", options->cp, HTML_ATTR_NONE);
                  if ( attr_value )
                  {
                    add_to_string(head, "Charset: ");
                    add_to_string(head, attr_value);
                    mem_free(attr_value);
                  }
                  v18 = get_attr_value(attr, "http-equiv", options->cp, HTML_ATTR_NONE);
                  v19 = v18;
                  if ( v18 )
                  {
                    add_to_string(head, v18);
                    mem_free(v19);
                    v20 = get_attr_value(attr, "content", options->cp, HTML_ATTR_NONE);
                    if ( v20 )
                    {
                      add_to_string(head, ": ");
                      add_to_string(head, v20);
                      mem_free(v20);
                    }
                    add_crlf_to_string(head);
                  }
                }
                break;
              }
              v8 = s;
              while ( 2 )
              {
                v9 = v8;
                while ( 2 )
                {
                  if ( v5 > v9 && *v9 != 60 )
                  {
xsp:
                    s = ++v9;
                    continue;
                  }
                  break;
                }
                if ( v8 != v9 )
                {
                  if ( assert_failed )
                    goto LABEL_39;
                  v10 = v9 - v8;
                  if ( v8 && v10 >= 0 )
                  {
                    assert_failed = 0;
                    goto LABEL_30;
                  }
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 255;
                  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                  if ( assert_failed )
                  {
LABEL_39:
                    assert_failed = 0;
                    v8 = s;
                    goto LABEL_32;
                  }
LABEL_30:
                  if ( v10 )
                  {
                    length = title->length;
                    v13 = v10 + length;
                    length += 255;
                    v14 = v13 + 256;
                    LOBYTE(length) = 0;
                    LOBYTE(v14) = 0;
                    v21 = v14;
                    v24 = length;
                    if ( v14 > length )
                    {
                      v23 = v13;
                      v16 = (unsigned __int8 *)mem_realloc(title->source, v14);
                      if ( !v16 )
                        goto LABEL_31;
                      title->source = v16;
                      memset(&v16[v24], 0, v21 - v24);
                      v13 = v23;
                    }
                    if ( title->source )
                    {
                      v22 = v13;
                      memcpy(&title->source[title->length], v8, v10);
                      v15 = title;
                      title->source[v22] = 0;
                      v15->length = v22;
                    }
                  }
LABEL_31:
                  v8 = s;
                }
LABEL_32:
                if ( v5 <= v8 )
                  return;
                if ( v5 >= v8 + 2 )
                {
                  v11 = v8[1];
                  if ( v11 == 63 || v11 == 33 )
                  {
                    v8 = skip_comment(v8, v5);
                    s = v8;
                    continue;
                  }
                }
                break;
              }
              if ( !parse_element(v8, v5, name, &namelen, &attr, &s) )
              {
                clr_spaces(title->source);
                continue;
              }
              v8 = s;
              v9 = s;
              goto xsp;
            }
            break;
          }
          v6 = s;
          goto LABEL_4;
        }
        v6 = s;
      }
      s = ++v6;
    }
    while ( v5 > v6 );
  }
}

//----- (0809C970) --------------------------------------------------------
void __cdecl parse_html(
        unsigned __int8 *html,
        unsigned __int8 *eof,
        part *part,
        unsigned __int8 *head,
        html_context *html_context)
{
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // edx
  bool v7; // cf
  char v8; // al
  unsigned __int8 *v9; // edi
  const unsigned __int16 **v10; // eax
  unsigned __int8 *v11; // edx
  int v12; // eax
  unsigned __int8 *v13; // ebx
  unsigned __int8 *v14; // ebx
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // esi
  unsigned __int8 v17; // cl
  void *v18; // eax
  void *v19; // esi
  int v20; // edi
  unsigned __int8 v21; // cl
  unsigned __int8 *v22; // eax
  unsigned __int8 v23; // cl
  int v24; // esi
  unsigned __int8 *v25; // eax
  html_context *v26; // edi
  unsigned __int8 v27; // al
  int v28; // eax
  int v29; // ebx
  int v30; // eax
  unsigned __int8 *v31; // edx
  char v32; // cl
  void *v33; // eax
  void (__cdecl *v34)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **); // eax
  unsigned __int8 *i; // ecx
  unsigned __int8 v36; // al
  int v37; // eax
  unsigned __int8 *v38; // eax
  int line_breax; // eax
  _DWORD *v40; // eax
  int v41; // ebx
  unsigned __int8 *attr_value; // eax
  unsigned __int8 *v43; // ebx
  void (__cdecl *v44)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **); // eax
  html_element *next; // ebx
  int v46; // esi
  int v47; // eax
  void (__cdecl *v48)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **); // ecx
  int v49; // eax
  unsigned __int8 *v50; // esi
  html_element *p_stack; // ebx
  int v52; // eax
  html_element *prev; // eax
  css_selector *v54; // ebx
  _DWORD *v55; // esi
  void *v56; // eax
  unsigned __int8 *v57; // edx
  void **v58; // ebx
  css_selector *css_selector_for_element; // eax
  unsigned __int8 *v60; // eax
  unsigned __int8 *v61; // esi
  void (__cdecl *v62)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **); // eax
  html_element *v63; // eax
  css_selector *v64; // eax
  css_selector *v65; // ebx
  _DWORD *v66; // eax
  unsigned __int8 *v67; // eax
  int v68; // eax
  int linebreak; // ecx
  unsigned __int8 *v70; // [esp+4h] [ebp-A4h]
  int v71; // [esp+8h] [ebp-A0h]
  char v72; // [esp+24h] [ebp-84h]
  unsigned __int8 *v73; // [esp+28h] [ebp-80h]
  unsigned __int8 *v74; // [esp+28h] [ebp-80h]
  unsigned __int8 *v75; // [esp+28h] [ebp-80h]
  unsigned __int8 *v76; // [esp+28h] [ebp-80h]
  unsigned __int8 *v77; // [esp+28h] [ebp-80h]
  unsigned __int8 *v78; // [esp+28h] [ebp-80h]
  unsigned __int8 *v79; // [esp+28h] [ebp-80h]
  unsigned __int8 *v80; // [esp+28h] [ebp-80h]
  unsigned __int8 *v81; // [esp+28h] [ebp-80h]
  unsigned __int8 *v82; // [esp+28h] [ebp-80h]
  unsigned __int8 *v83; // [esp+28h] [ebp-80h]
  unsigned __int8 *v84; // [esp+28h] [ebp-80h]
  unsigned __int8 *v85; // [esp+28h] [ebp-80h]
  unsigned __int8 *v86; // [esp+28h] [ebp-80h]
  unsigned __int8 *v87; // [esp+28h] [ebp-80h]
  unsigned __int8 *v88; // [esp+28h] [ebp-80h]
  unsigned __int8 *v89; // [esp+28h] [ebp-80h]
  unsigned __int8 *v90; // [esp+28h] [ebp-80h]
  unsigned __int8 *v91; // [esp+28h] [ebp-80h]
  unsigned __int8 *v92; // [esp+28h] [ebp-80h]
  unsigned __int8 *v93; // [esp+28h] [ebp-80h]
  unsigned __int8 *v94; // [esp+28h] [ebp-80h]
  unsigned __int8 *v95; // [esp+28h] [ebp-80h]
  unsigned __int8 *v96; // [esp+28h] [ebp-80h]
  unsigned __int8 *v97; // [esp+28h] [ebp-80h]
  unsigned __int8 *v98; // [esp+28h] [ebp-80h]
  unsigned __int8 *v99; // [esp+28h] [ebp-80h]
  unsigned __int8 *v100; // [esp+28h] [ebp-80h]
  int v101; // [esp+2Ch] [ebp-7Ch]
  int v102; // [esp+30h] [ebp-78h]
  int v103; // [esp+34h] [ebp-74h]
  int v104; // [esp+38h] [ebp-70h]
  int v105; // [esp+3Ch] [ebp-6Ch]
  int v106; // [esp+40h] [ebp-68h]
  int v107; // [esp+44h] [ebp-64h]
  int v108; // [esp+48h] [ebp-60h]
  char v109; // [esp+4Ch] [ebp-5Ch]
  int v110; // [esp+4Ch] [ebp-5Ch]
  int v111; // [esp+50h] [ebp-58h]
  size_t key_len; // [esp+54h] [ebp-54h]
  int len; // [esp+58h] [ebp-50h]
  unsigned __int8 *lena; // [esp+58h] [ebp-50h]
  list_head_elinks *html_stack; // [esp+5Ch] [ebp-4Ch]
  unsigned __int8 *v116; // [esp+60h] [ebp-48h]
  const unsigned __int16 **v117; // [esp+64h] [ebp-44h]
  unsigned __int8 key; // [esp+68h] [ebp-40h]
  unsigned __int8 *keya; // [esp+68h] [ebp-40h]
  unsigned __int8 *keyb; // [esp+68h] [ebp-40h]
  unsigned __int8 *keyc; // [esp+68h] [ebp-40h]
  int dotcounter; // [esp+6Ch] [ebp-3Ch]
  int dotcountera; // [esp+6Ch] [ebp-3Ch]
  int dotcounterb; // [esp+6Ch] [ebp-3Ch]
  int dotcounterc; // [esp+6Ch] [ebp-3Ch]
  html_element *dotcounterd; // [esp+6Ch] [ebp-3Ch]
  unsigned __int8 *nm; // [esp+78h] [ebp-30h] BYREF
  unsigned __int8 *ee; // [esp+7Ch] [ebp-2Ch] BYREF
  int namelen; // [esp+80h] [ebp-28h] BYREF
  unsigned __int8 *end; // [esp+84h] [ebp-24h] BYREF
  unsigned __int8 *attr; // [esp+88h] [ebp-20h] BYREF
  unsigned __int8 *name[7]; // [esp+8Ch] [ebp-1Ch] BYREF

  v5 = html;
  v6 = eof;
  v7 = html_context->table_level == 0;
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->line_breax = 2 - v7;
  v8 = *((_BYTE *)html_context + 68);
  html_context->position = 0;
  html_context->was_li = 0;
  *((_BYTE *)html_context + 68) = v8 & 0xEE;
  html_context->eoff = eof;
  html_context->part = part;
  if ( head )
  {
    process_head(html_context, head);
    v6 = eof;
  }
  if ( html < v6 )
  {
    v73 = v6;
    v9 = html;
    v10 = __ctype_b_loc();
    v11 = v73;
    v117 = v10;
    v12 = 0;
    html_stack = &html_context->stack;
    v116 = v73 - 1;
    while ( 1 )
    {
      if ( !v12 )
      {
        v9 = v5;
        html_context->part = part;
        html_context->eoff = v11;
      }
      key = *v5;
      if ( ((*v117)[*v5] & 0x2000) == 0 )
        break;
      if ( (*((_BYTE *)html_context->stack.next + 12) & 0x20) != 0 )
        goto LABEL_41;
      v13 = v5;
      if ( v11 > v5 )
      {
        do
          ++v13;
        while ( v11 > v13 && ((*v117)[*v13] & 0x2000) != 0 );
      }
      if ( v11 > v13 + 1 && *v13 == 60 && v13[1] == 47 )
      {
        v83 = v11;
        v37 = parse_element(v13, v11, name, &namelen, &attr, &end);
        v11 = v83;
        if ( !v37 )
        {
          v71 = v5 - v9;
          v5 = v13;
          v70 = v9;
          v9 = v13;
          v29 = 0;
          put_chrs(html_context, v70, v71);
          html_context->putsp = HTML_SPACE_ADD;
          v11 = v83;
element:
          v30 = *name[0] == 47;
          namelen -= v30;
          name[0] += v30;
          if ( v30 )
          {
            v81 = v11;
            put_chrs(html_context, v9, v29);
            v31 = v81;
            v32 = 0;
          }
          else
          {
            if ( html_context->putsp == HTML_SPACE_ADD && !*((_DWORD *)html_context->stack.next + 38) )
            {
              v97 = v11;
              put_chrs(html_context, (unsigned __int8 *)&start, 1);
              v11 = v97;
            }
            v86 = v11;
            put_chrs(html_context, v9, v29);
            v31 = v86;
            if ( (*((_BYTE *)html_context->stack.next + 12) & 0x20) != 0 || html_context->putsp != HTML_SPACE_NORMAL )
              goto ng;
            v67 = end;
            for ( ee = end; !parse_element(v67, v86, &nm, 0, 0, &ee); v67 = ee )
            {
              if ( *nm == 47 )
              {
                v31 = v86;
                goto ng;
              }
            }
            v31 = v86;
            if ( v86 > ee && ((*v117)[*ee] & 0x2000) != 0 )
            {
              put_chrs(html_context, (unsigned __int8 *)&start, 1);
              v32 = 1;
              v31 = v86;
            }
            else
            {
ng:
              v32 = 1;
            }
          }
          v82 = v31;
          v72 = v32;
          key_len = namelen;
          lena = attr;
          v14 = end;
          keyc = name[0];
          v33 = fastfind_search(&ff_tags_index, name[0], namelen);
          v11 = v82;
          dotcounterc = (int)v33;
          v109 = *((_BYTE *)html_context + 68);
          if ( (v109 & 6) != 0 )
          {
            if ( !v33
              || (v34 = (void (__cdecl *)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))*((_DWORD *)v33 + 1),
                  v34 != html_xmp)
              && v34 != html_style
              || v72 )
            {
              v14 = v5 + 1;
              put_chrs(html_context, (unsigned __int8 *)"<", 1);
              v12 = 0;
              v11 = v82;
              goto LABEL_37;
            }
LABEL_136:
            nm = v14;
            *((_BYTE *)html_context + 68) = v109 & 0xFE;
            if ( (unsigned int)(*(_DWORD *)(dotcounterc + 16) - 2) > 1 )
            {
              v44 = *(void (__cdecl **)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))(dotcounterc + 8);
              if ( v44 )
              {
                v44(html_context, lena, v14, v82, &nm);
                v11 = v82;
              }
              next = (html_element *)html_context->stack.next;
              if ( html_stack != (list_head_elinks *)next )
              {
                v46 = 0;
                while ( 1 )
                {
                  if ( next->linebreak > 0 && !*(_DWORD *)(dotcounterc + 12) )
                    v46 = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
                  errline = 977;
                  v88 = v11;
                  v47 = elinks_strlcasecmp(next->name, next->namelen, keyc, key_len, 1);
                  v11 = v88;
                  if ( !v47 )
                    break;
                  if ( next->type > (unsigned int)ELEMENT_DONT_KILL )
                  {
                    next = next->next;
                    if ( html_stack != (list_head_elinks *)next )
                      continue;
                  }
                  goto LABEL_134;
                }
                v68 = 0;
                dotcounterd = next;
                if ( v46 )
                {
                  kill_html_stack_item(html_context, next);
                  v11 = v88;
                }
                else
                {
                  while ( html_stack != (list_head_elinks *)next )
                  {
                    linebreak = next->linebreak;
                    next = next->prev;
                    if ( v68 < linebreak )
                      v68 = linebreak;
                  }
                  if ( html_context->was_li )
                    html_context->line_breax = 0;
                  ln_break(html_context, v68);
                  while ( html_stack != (list_head_elinks *)dotcounterd->prev )
                    kill_html_stack_item(html_context, dotcounterd->prev);
                  kill_html_stack_item(html_context, dotcounterd);
                  v11 = v88;
                }
              }
LABEL_134:
              v14 = nm;
              v12 = 0;
LABEL_37:
              if ( v11 <= v14 )
              {
                if ( v12 )
                  put_chrs(html_context, v9, v14 - v9);
                goto LABEL_40;
              }
              goto LABEL_25;
            }
LABEL_81:
            v12 = 0;
            goto LABEL_37;
          }
          if ( !v33 )
            goto LABEL_81;
          if ( !v72 )
            goto LABEL_136;
          nm = v14;
          v40 = html_context->stack.next;
          if ( v40[2] == 3 )
          {
            kill_html_stack_item(html_context, (html_element *)html_context->stack.next);
            v40 = html_context->stack.next;
            v11 = v82;
          }
          v41 = v40[38];
          if ( v41 )
          {
            if ( *(void (__cdecl **)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))(dotcounterc + 4) != html_script
              || (v48 = html_script, v41 <= 1) )
            {
              v87 = v11;
              ln_break(html_context, *(_DWORD *)(dotcounterc + 12));
              attr_value = get_attr_value(lena, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
              v11 = v87;
              v43 = attr_value;
              if ( attr_value )
              {
                html_context->special_f(html_context, 0, attr_value);
                mem_free(v43);
                v11 = v87;
              }
              goto LABEL_134;
            }
          }
          else
          {
            v48 = *(void (__cdecl **)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))(dotcounterc + 4);
          }
          v111 = v40[3];
          v101 = v40[37];
          v102 = v40[36];
          v103 = v40[35];
          v104 = v40[34];
          v105 = v40[33];
          v106 = v40[32];
          v107 = v40[31];
          v108 = v40[30];
          v110 = v40[29];
          if ( v48 == html_meta && (*((_BYTE *)html_context + 68) & 0x10) != 0 )
          {
            v99 = v11;
            html_handle_body_meta(html_context, keyc - 1, v11);
            *((_BYTE *)html_context + 68) &= ~0x10u;
            v11 = v99;
            v48 = *(void (__cdecl **)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))(dotcounterc + 4);
          }
          if ( v48 == html_style && (*((_BYTE *)html_context->options + 68) & 1) != 0 )
          {
            v98 = v11;
            css_parse_stylesheet(&html_context->css_styles, html_context->base_href, nm, v11);
            v11 = v98;
          }
          v49 = *(_DWORD *)(dotcounterc + 16);
          if ( v49 == 3 )
          {
            v50 = v11;
            p_stack = (html_element *)html_context->stack.next;
            if ( html_stack != (list_head_elinks *)p_stack )
            {
              do
              {
                if ( p_stack->linebreak > 0 && !*(_DWORD *)(dotcounterc + 12)
                  || p_stack->type <= (unsigned int)ELEMENT_DONT_KILL
                  || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c",
                      errline = 868,
                      !elinks_strlcasecmp(p_stack->name, p_stack->namelen, keyc, key_len, 1)) )
                {
                  v11 = v50;
                  goto LABEL_160;
                }
                p_stack = p_stack->next;
              }
              while ( html_stack != (list_head_elinks *)p_stack );
              v11 = v50;
            }
            p_stack = (html_element *)&html_context->stack;
LABEL_160:
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/parse.c";
            errline = 872;
            v89 = v11;
            v52 = elinks_strlcasecmp(p_stack->name, p_stack->namelen, keyc, key_len, 1);
            v11 = v89;
            if ( v52 )
              goto LABEL_165;
            prev = p_stack->prev;
            if ( html_stack != (list_head_elinks *)prev )
            {
              do
              {
                kill_html_stack_item(html_context, prev);
                prev = p_stack->prev;
              }
              while ( html_stack != (list_head_elinks *)prev );
              v11 = v89;
            }
            if ( p_stack->type )
            {
              v100 = v11;
              kill_html_stack_item(html_context, p_stack);
              v11 = v100;
              v49 = *(_DWORD *)(dotcounterc + 16);
            }
            else
            {
LABEL_165:
              v49 = *(_DWORD *)(dotcounterc + 16);
            }
          }
          else if ( v49 == 1 )
          {
            for ( p_stack = (html_element *)html_context->stack.next;
                  p_stack != (html_element *)html_stack
               && p_stack->type > (unsigned int)ELEMENT_DONT_KILL
               && p_stack->linebreak <= 0
               && *(_DWORD *)(dotcounterc + 12);
                  p_stack = p_stack->next )
            {
              ;
            }
            goto LABEL_160;
          }
          if ( v49 != 2 )
          {
            v90 = v11;
            html_stack_dup(html_context, ELEMENT_KILLABLE);
            *((_DWORD *)html_context->stack.next + 39) = keyc;
            *((_DWORD *)html_context->stack.next + 40) = key_len;
            *((_DWORD *)html_context->stack.next + 41) = lena;
            *((_DWORD *)html_context->stack.next + 42) = *(_DWORD *)(dotcounterc + 12);
            v11 = v90;
          }
          v54 = 0;
          v55 = html_context->stack.next;
          if ( v55[41] && (*((_BYTE *)html_context->options + 68) & 1) != 0 )
          {
            v56 = (void *)v55[16];
            if ( v56 )
            {
              v91 = v11;
              mem_free(v56);
              v11 = v91;
              v55 = html_context->stack.next;
            }
            v92 = v11;
            v55[16] = get_attr_value(lena, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
            v57 = v92;
            v58 = (void **)html_context->stack.next;
            if ( v58[17] )
            {
              mem_free(v58[17]);
              v57 = v92;
              v58 = (void **)html_context->stack.next;
            }
            v93 = v57;
            v58[17] = get_attr_value(lena, "class", html_context->doc_cp, HTML_ATTR_NONE);
            css_selector_for_element = get_css_selector_for_element(
                                         html_context,
                                         (html_element *)html_context->stack.next,
                                         &html_context->css_styles,
                                         html_stack);
            v11 = v93;
            v54 = css_selector_for_element;
            if ( css_selector_for_element )
            {
              apply_css_selector_style(html_context, (html_element *)html_context->stack.next, css_selector_for_element);
              done_css_selector(v54);
              v11 = v93;
            }
          }
          v94 = v11;
          ln_break(html_context, *(_DWORD *)(dotcounterc + 12));
          v60 = get_attr_value(lena, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
          v11 = v94;
          v61 = v60;
          if ( v60 )
          {
            html_context->special_f(html_context, (signed __int32)v94, html_context, 0, v60);
            mem_free(v61);
            v11 = v94;
          }
          v62 = *(void (__cdecl **)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))(dotcounterc + 4);
          if ( v62 )
          {
            v95 = v11;
            v62(html_context, lena, nm, v11, &nm);
            v11 = v95;
          }
          if ( v54 )
          {
            v63 = (html_element *)html_context->stack.next;
            if ( v63->options )
            {
              v96 = v11;
              v64 = get_css_selector_for_element(html_context, v63, &html_context->css_styles, html_stack);
              v11 = v96;
              v65 = v64;
              if ( v64 )
              {
                apply_css_selector_style(html_context, (html_element *)html_context->stack.next, v64);
                done_css_selector(v65);
                v11 = v96;
              }
            }
          }
          if ( *(void (__cdecl **)(html_context *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 **))(dotcounterc + 4) != html_br )
            *((_BYTE *)html_context + 68) &= ~1u;
          if ( (v111 & 0x20) != 0 )
          {
            v66 = html_context->stack.next;
            v66[37] = v101;
            v66[36] = v102;
            v66[35] = v103;
            v66[34] = v104;
            v66[33] = v105;
            v66[32] = v106;
            v66[31] = v107;
            v66[30] = v108;
            v66[29] = v110;
          }
          goto LABEL_134;
        }
      }
      v14 = v5 + 1;
      if ( html_context->position + v5 - v9 )
      {
        if ( *v5 == 32 )
        {
          if ( v11 > v14 )
          {
            v12 = 1;
            if ( ((*v117)[*v14] & 0x2000) == 0 )
              goto LABEL_25;
          }
          v74 = v11;
          put_chrs(html_context, v9, v5 + 1 - v9);
          v11 = v74;
        }
        else
        {
          v78 = v11;
          put_chrs(html_context, v9, v5 - v9);
          put_chrs(html_context, (unsigned __int8 *)&start, 1);
          v11 = v78;
        }
      }
      if ( v11 <= v14 )
        goto LABEL_40;
      while ( ((*v117)[*v14] & 0x2000) != 0 )
      {
        if ( v11 <= ++v14 )
          goto LABEL_40;
      }
      v12 = 0;
LABEL_25:
      v5 = v14;
    }
    if ( (*((_BYTE *)html_context->stack.next + 12) & 0x20) != 0 )
    {
LABEL_41:
      html_context->putsp = HTML_SPACE_NORMAL;
      key = *v5;
      if ( *v5 == 9 )
      {
        v79 = v11;
        put_chrs(html_context, v9, v5 - v9);
        v14 = v5 + 1;
        put_chrs(
          html_context,
          (unsigned __int8 *)&byte_8134F95,
          ((unsigned int)(html_context->position >> 31) >> 29)
        - ((((unsigned int)(html_context->position >> 31) >> 29) + (unsigned __int8)html_context->position) & 7)
        + 8);
        v12 = 0;
        v11 = v79;
        goto LABEL_37;
      }
      if ( key == 10 || key == 13 )
      {
        v77 = v11;
        put_chrs(html_context, v9, v5 - v9);
        if ( v5 == v9 && (line_breax = html_context->line_breax, line_breax > 0) )
        {
          html_context->line_breax = line_breax - 1;
          dotcounterb = (int)v9;
          v26 = html_context;
          keyb = v77;
        }
        else
        {
          dotcounterb = (int)v9;
          v26 = html_context;
          keyb = v77;
        }
        while ( 1 )
        {
          if ( *v5 == 13 && v5 < v116 )
          {
            v14 = v5 + 1;
            if ( v5[1] == 10 )
              v14 = v5 + 2;
          }
          else
          {
            v14 = v5 + 1;
          }
          ln_break(v26, 1);
          if ( *v14 != 10 && *v14 != 13 )
            break;
          v26->line_breax = 0;
          v5 = v14;
        }
        v9 = (unsigned __int8 *)dotcounterb;
        v11 = keyb;
        goto LABEL_81;
      }
      if ( v11 > v5 + 5 && key == 38 )
      {
        v14 = v5;
        keya = v9;
        v20 = 0;
        dotcountera = 0;
        len = (int)v5;
        while ( v14[1] == 35 )
        {
          v21 = v14[2];
          v22 = v14 + 2;
          if ( v21 == 88 || v21 == 120 )
          {
            for ( i = v14 + 3; v11 > i && *i == 48; ++i )
              ;
            if ( v11 == i )
              break;
            v36 = *i;
            if ( *i == 65 || v36 == 97 )
            {
              v24 = 0;
            }
            else
            {
              if ( v36 != 68 && v36 != 100 )
                break;
              v24 = 1;
            }
            v25 = i + 1;
          }
          else
          {
            if ( v11 > v22 && v21 == 48 )
            {
              do
                ++v22;
              while ( v11 > v22 && *v22 == 48 );
            }
            if ( v11 - v22 <= 1 || *v22 != 49 )
              break;
            v23 = v22[1];
            v24 = 0;
            if ( v23 != 48 )
            {
              if ( v23 != 51 )
                break;
              LOWORD(v24) = 1;
            }
            v25 = v22 + 2;
          }
          if ( v11 == v25 || *v25 != 59 )
            break;
          v14 = v25 + 1;
          if ( v24 || !v20 )
            ++dotcountera;
          if ( v11 <= v25 + 6 || *v14 != 38 )
            break;
          v20 = v24;
        }
        v9 = keya;
        if ( dotcountera )
        {
          v85 = v11;
          put_chrs(html_context, keya, len - (_DWORD)keya);
          ln_break(html_context, dotcountera);
          v12 = 0;
          v11 = v85;
          goto LABEL_37;
        }
        v5 = v14;
        key = *v14;
      }
    }
    dotcounter = 0;
    if ( key <= 0x1Fu )
    {
      v15 = v5;
      v16 = v11;
      while ( 1 )
      {
        if ( v15 != v9 )
        {
          v75 = v15;
          put_chrs(html_context, v9, v15 - v9);
          v15 = v75;
        }
        ++dotcounter;
        v17 = v15[1];
        v14 = v15 + 1;
        if ( v17 > 0x1Fu )
          break;
        v9 = v15 + 1;
        if ( v14 >= v16 || ((*v117)[v17] & 0x2000) != 0 )
          break;
        ++v15;
      }
      v9 = v15 + 1;
      v76 = v16;
      v18 = mem_alloc(dotcounter);
      v11 = v16;
      v19 = v18;
      v12 = 0;
      if ( v19 )
      {
        memset(v19, 46, dotcounter);
        put_chrs(html_context, (unsigned __int8 *)v19, dotcounter);
        mem_free(v19);
        v11 = v76;
        v12 = 0;
      }
      goto LABEL_37;
    }
    if ( v11 >= v5 + 2 )
    {
      if ( key != 60 )
        goto LABEL_84;
      v27 = v5[1];
      if ( (v27 == 63 || v27 == 33) && (*((_BYTE *)html_context + 68) & 6) == 0 )
      {
        v84 = v11;
        put_chrs(html_context, v9, v5 - v9);
        v38 = skip_comment(v5, v84);
        v11 = v84;
        v14 = v38;
        v12 = 0;
        goto LABEL_37;
      }
    }
    else if ( key != 60 )
    {
LABEL_84:
      v14 = v5 + 1;
      v12 = 1;
      goto LABEL_37;
    }
    v80 = v11;
    v28 = parse_element(v5, v11, name, &namelen, &attr, &end);
    v11 = v80;
    if ( !v28 )
    {
      v29 = v5 - v9;
      goto element;
    }
    goto LABEL_84;
  }
LABEL_40:
  ln_break(html_context, 1);
  *((_BYTE *)html_context + 68) &= ~1u;
  html_context->part = part;
  html_context->putsp = HTML_SPACE_SUPPRESS;
  html_context->position = 0;
}

//----- (0809D9B0) --------------------------------------------------------
int __cdecl get_width(unsigned __int8 *a, unsigned __int8 *name, int limited, html_context *html_context)
{
  const char *v4; // ebx
  const unsigned __int16 *v5; // edx
  char v6; // al
  int v7; // eax
  char v8; // cl
  unsigned __int8 v9; // si
  const char *v10; // ecx
  const unsigned __int16 *v11; // edi
  unsigned __int8 v12; // dl
  int v13; // edi
  const char *v14; // ecx
  int v15; // esi
  int *v17; // eax
  int *v18; // esi
  unsigned int v19; // ebx
  int v20; // ecx
  int v21; // ebx
  __int64 v22; // rax
  int v23; // ebx
  int v24; // edx
  int v25; // edx
  int v27; // ebx
  unsigned __int8 *value; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *end; // [esp+2Ch] [ebp-1Ch] BYREF

  value = get_attr_value(a, name, html_context->doc_cp, HTML_ATTR_NONE);
  if ( !value )
    return -1;
  v4 = (const char *)value;
  v5 = *__ctype_b_loc();
  while ( 1 )
  {
    v6 = *v4;
    if ( (v5[*(unsigned __int8 *)v4] & 0x2000) == 0 )
      break;
    ++v4;
  }
  if ( v6 == 44 || !v6 )
    goto LABEL_22;
  v7 = 0;
  do
    v8 = v4[++v7];
  while ( v8 != 44 && v8 );
  if ( !v7 )
    goto LABEL_22;
  v9 = v4[v7 - 1];
  if ( (v5[v9] & 0x2000) != 0 )
  {
    v10 = &v4[v7];
    v11 = v5;
    while ( --v7 )
    {
      v12 = *(v10 - 2);
      --v10;
      if ( (v11[v12] & 0x2000) == 0 )
      {
        v9 = v12;
        v5 = v11;
        goto LABEL_17;
      }
    }
    goto LABEL_22;
  }
LABEL_17:
  v13 = 0;
  if ( v9 == 37 )
  {
    if ( --v7 )
    {
      v9 = v4[v7 - 1];
      v13 = 1;
      goto LABEL_18;
    }
LABEL_22:
    mem_free(value);
    return -1;
  }
LABEL_18:
  if ( (v5[v9] & 0x2000) != 0 )
  {
    v14 = &v4[v7];
    while ( --v7 )
    {
      v15 = *((unsigned __int8 *)v14-- - 2);
      if ( (v5[v15] & 0x2000) == 0 )
        goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_23:
  v4[v7] = 0;
  v17 = __errno_location();
  *v17 = 0;
  v18 = v17;
  v19 = strtoul(v4, (char **)&end, 10);
  if ( *v18 || *end != 46 && *end || v19 == 0x7FFFFFFF )
  {
    mem_free(value);
    return -1;
  }
  mem_free(value);
  if ( limited )
  {
    v20 = 0;
    if ( *((_DWORD *)html_context->stack.next + 32)
       + -*((_DWORD *)html_context->stack.next + 31)
       - *((_DWORD *)html_context->stack.next + 30) >= 0 )
      v20 = *((_DWORD *)html_context->stack.next + 32)
          + -*((_DWORD *)html_context->stack.next + 31)
          - *((_DWORD *)html_context->stack.next + 30);
    if ( v13 )
    {
      v21 = v20 * v19;
      v22 = 1374389535LL * v21;
      v23 = v21 >> 31;
      v24 = SHIDWORD(v22) >> 5;
    }
    else
    {
      v27 = v19 + 3;
      v24 = (int)((unsigned __int64)(2454267027LL * v27) >> 32) >> 2;
      v23 = v27 >> 31;
    }
    v25 = v24 - v23;
    if ( v25 > v20 )
      return v20;
    goto LABEL_36;
  }
  if ( v13 )
    return -1;
  v25 = (int)(v19 + 3) / 7;
LABEL_36:
  if ( v25 < 0 )
    return 0;
  return v25;
}

//----- (0809DC00) --------------------------------------------------------
int __cdecl get_num(unsigned __int8 *a, unsigned __int8 *name, int cp)
{
  int v3; // esi
  unsigned __int8 *attr_value; // ebx
  int *v5; // eax
  int *v6; // esi
  int v7; // eax
  unsigned __int8 *end; // [esp+1Ch] [ebp-Ch] BYREF

  v3 = -1;
  attr_value = get_attr_value(a, name, cp, HTML_ATTR_NONE);
  if ( attr_value )
  {
    v5 = __errno_location();
    *v5 = 0;
    v6 = v5;
    v7 = strtol((const char *)attr_value, (char **)&end, 10);
    if ( *v6 || !*attr_value || v7 < 0 || (v3 = v7, *end) )
      v3 = -1;
    mem_free(attr_value);
  }
  return v3;
}

//----- (0809DC90) --------------------------------------------------------
html_element *__cdecl search_html_stack(html_context *html_context, unsigned __int8 *name)
{
  html_element *next; // ebx
  size_t n2; // [esp+28h] [ebp-20h]

  if ( !assert_failed )
  {
    if ( name && *name )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
      errline = 55;
      elinks_internal("assertion name && *name failed!");
    }
  }
  n2 = strlen((const char *)name);
  next = (html_element *)html_context->stack.next;
  if ( next != (html_element *)&html_context->stack )
  {
    while ( 1 )
    {
      next = next->next;
      if ( next == (html_element *)&html_context->stack )
        break;
      if ( html_context->stack.next != next )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
        errline = 65;
        if ( !elinks_strlcasecmp(next->name, next->namelen, name, n2, 1) )
          return next;
      }
    }
  }
  return 0;
}

//----- (0809DD80) --------------------------------------------------------
void __cdecl html_stack_dup(html_context *html_context, html_element_mortality_type type)
{
  html_context *next; // edx
  _DWORD *v3; // eax
  const unsigned __int8 **v4; // edx
  _DWORD *v5; // ebx
  void *v6; // edx
  const unsigned __int8 **v7; // [esp+1Ch] [ebp-1Ch]
  const unsigned __int8 **v8; // [esp+1Ch] [ebp-1Ch]
  const unsigned __int8 **v9; // [esp+1Ch] [ebp-1Ch]
  const unsigned __int8 **v10; // [esp+1Ch] [ebp-1Ch]
  html_context *v11; // [esp+1Ch] [ebp-1Ch]

  next = (html_context *)html_context->stack.next;
  if ( assert_failed )
    goto LABEL_18;
  if ( next && &html_context->stack != (list_head_elinks *)next )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
  errline = 140;
  v11 = next;
  elinks_internal("assertion ep && (void *) ep != &html_context->stack failed: html stack empty");
  next = v11;
  if ( assert_failed )
  {
LABEL_18:
    assert_failed = 0;
    return;
  }
LABEL_5:
  v7 = (const unsigned __int8 **)next;
  v3 = mem_alloc(0xB4u);
  v4 = v7;
  v5 = v3;
  if ( v3 )
  {
    qmemcpy(v3, v7, 0xB4u);
    if ( v7[7] )
    {
      v3[7] = stracpy(v7[7]);
      v4 = v7;
    }
    if ( v4[8] )
    {
      v8 = v4;
      v5[8] = stracpy(v4[8]);
      v4 = v8;
    }
    if ( v4[9] )
    {
      v9 = v4;
      v5[9] = stracpy(v4[9]);
      v4 = v9;
    }
    if ( v4[10] )
    {
      v10 = v4;
      v5[10] = stracpy(v4[10]);
      v4 = v10;
    }
    if ( v4[18] )
      v5[18] = stracpy(v4[18]);
    v5[17] = 0;
    v5[16] = 0;
    v5[28] = 0;
    v5[27] = 0;
    v5[26] = 0;
    v5[25] = 0;
    v5[24] = 0;
    v5[23] = 0;
    v5[22] = 0;
    v5[41] = 0;
    v5[39] = 0;
    v5[40] = 0;
    v5[2] = type;
    v6 = html_context->stack.next;
    v5[1] = &html_context->stack;
    *v5 = v6;
    html_context->stack.next = v5;
    *(_DWORD *)(*v5 + 4) = v5;
  }
}

//----- (0809DF30) --------------------------------------------------------
void __cdecl kill_html_stack_item(html_context *html_context, html_element *e)
{
  html_element_mortality_type type; // esi

  if ( assert_failed )
    goto LABEL_35;
  assert_failed = e == 0;
  if ( !e )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 81;
    elinks_internal("assertion e failed!");
    if ( assert_failed )
      goto LABEL_35;
  }
  assert_failed = &html_context->stack == (list_head_elinks *)e;
  if ( &html_context->stack == (list_head_elinks *)e )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
    errline = 83;
    elinks_internal("assertion (void *) e != &html_context->stack failed: trying to free bad html element");
    if ( assert_failed )
      goto LABEL_35;
  }
  type = e->type;
  assert_failed = type == ELEMENT_IMMORTAL;
  if ( type == ELEMENT_IMMORTAL
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c",
        errline = 85,
        elinks_internal("assertion e->type != ELEMENT_IMMORTAL failed: trying to kill unkillable element"),
        assert_failed) )
  {
LABEL_35:
    assert_failed = 0;
  }
  else
  {
    if ( e->attr.link )
      mem_free(e->attr.link);
    if ( e->attr.target )
      mem_free(e->attr.target);
    if ( e->attr.image )
      mem_free(e->attr.image);
    if ( e->attr.title )
      mem_free(e->attr.title);
    if ( e->attr.select )
      mem_free(e->attr.select);
    if ( e->attr.id )
      mem_free(e->attr.id);
    if ( e->attr.class )
      mem_free(e->attr.class);
    if ( e->attr.onclick )
      mem_free(e->attr.onclick);
    if ( e->attr.ondblclick )
      mem_free(e->attr.ondblclick);
    if ( e->attr.onmouseover )
      mem_free(e->attr.onmouseover);
    if ( e->attr.onhover )
      mem_free(e->attr.onhover);
    if ( e->attr.onfocus )
      mem_free(e->attr.onfocus);
    if ( e->attr.onmouseout )
      mem_free(e->attr.onmouseout);
    if ( e->attr.onblur )
      mem_free(e->attr.onblur);
    e->next->prev = e->prev;
    e->prev->next = e->next;
    mem_free(e);
  }
}

//----- (0809E130) --------------------------------------------------------
void __usercall kill_element(html_context *html_context@<eax>, int ls@<edx>, html_element *e@<ecx>)
{
  html_element *v3; // edi
  int v6; // eax
  int linebreak; // edx
  int v8; // [esp+18h] [ebp-20h]
  list_head_elinks *p_stack; // [esp+1Ch] [ebp-1Ch]

  v3 = e;
  p_stack = &html_context->stack;
  v6 = 0;
  if ( e != (html_element *)p_stack )
  {
    do
    {
      if ( ls && html_context->stack.next == v3 )
        break;
      linebreak = v3->linebreak;
      v3 = v3->prev;
      if ( v6 < linebreak )
        v6 = linebreak;
      v8 = v6;
      kill_html_stack_item(html_context, v3->next);
      v6 = v8;
    }
    while ( v3 != (html_element *)p_stack );
  }
  ln_break(html_context, v6);
}

//----- (0809E1A0) --------------------------------------------------------
void kill_html_stack_until(html_context *html_context, int ls, ...)
{
  html_context *next; // edi
  va_list v3; // esi
  int v4; // edi
  const char *v5; // ebx
  size_t v6; // eax
  char v7; // al
  html_element *v8; // [esp+2Ch] [ebp-1Ch]
  va_list va; // [esp+58h] [ebp+10h] BYREF

  va_start(va, ls);
  next = (html_context *)html_context->stack.next;
  if ( ls )
    next = (html_context *)next->css_styles.import;
  if ( next != (html_context *)&html_context->stack )
  {
    v8 = (html_element *)next;
    while ( 2 )
    {
      va_copy(v3, va);
      v4 = 0;
      while ( 1 )
      {
        v3 += 4;
        v5 = (const char *)*((_DWORD *)v3 - 1);
        if ( !v5 )
          break;
        while ( 1 )
        {
          v6 = strlen(v5);
          if ( v6 )
            break;
          v3 += 4;
          ++v4;
          v5 = (const char *)*((_DWORD *)v3 - 1);
          if ( !v5 )
            goto LABEL_9;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
        errline = 221;
        if ( !elinks_strlcasecmp(v8->name, v8->namelen, (const unsigned __int8 *)v5, v6, 1) )
        {
          if ( !v4 )
          {
            if ( v8->type > (unsigned int)ELEMENT_DONT_KILL )
              kill_element(html_context, ls, v8);
            return;
          }
          if ( v4 == 1 )
          {
            kill_element(html_context, ls, v8->prev);
            return;
          }
          break;
        }
      }
LABEL_9:
      if ( v8->type > (unsigned int)ELEMENT_DONT_KILL )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/stack.c";
        errline = 243;
        if ( elinks_strlcasecmp(v8->name, v8->namelen, "TABLE", 5u, 1) )
        {
          if ( v8->namelen != 2
            || c_toupper(*v8->name) != 84
            || (v7 = c_toupper(v8->name[1]), v7 != 72) && v7 != 68 && v7 != 82 )
          {
            v8 = v8->next;
            if ( v8 != (html_element *)&html_context->stack )
              continue;
          }
        }
      }
      break;
    }
  }
}

//----- (0809E370) --------------------------------------------------------
void __usercall add_table_bad_html_end(table_elinks *table_elinks@<eax>, unsigned __int8 *end@<edx>)
{
  int bad_html_size; // ecx
  html_start_end *v3; // ecx

  if ( table_elinks->caption.start && !table_elinks->caption.end )
  {
    table_elinks->caption.end = end;
  }
  else
  {
    bad_html_size = table_elinks->bad_html_size;
    if ( bad_html_size )
    {
      v3 = &table_elinks->bad_html[bad_html_size - 1];
      if ( !v3->end )
        v3->end = end;
    }
  }
}

//----- (0809E3C0) --------------------------------------------------------
void __cdecl free_table(table_elinks *table_elinks)
{
  table_cell *v1; // edx
  int v2; // edi
  table_cell *cells; // ecx
  int real_cols; // eax
  int v5; // ebx
  unsigned __int8 *fragment_id; // eax

  if ( table_elinks->min_cols_widths )
    mem_free(table_elinks->min_cols_widths);
  if ( table_elinks->max_cols_widths )
    mem_free(table_elinks->max_cols_widths);
  if ( table_elinks->cols_widths )
    mem_free(table_elinks->cols_widths);
  if ( table_elinks->rows_heights )
    mem_free(table_elinks->rows_heights);
  if ( table_elinks->fragment_id )
    mem_free(table_elinks->fragment_id);
  if ( table_elinks->cols_x )
    mem_free(table_elinks->cols_x);
  if ( table_elinks->bad_html )
    mem_free(table_elinks->bad_html);
  if ( table_elinks->cols <= 0 )
  {
    cells = table_elinks->cells;
  }
  else
  {
    v1 = table_elinks->cells;
    v2 = 0;
    cells = v1;
    do
    {
      while ( table_elinks->rows <= 0 )
      {
        ++v2;
        cells = v1;
        if ( table_elinks->cols <= v2 )
          goto LABEL_24;
      }
      real_cols = table_elinks->real_cols;
      v5 = 0;
      while ( 1 )
      {
        fragment_id = v1[v2 + v5 * real_cols].fragment_id;
        if ( fragment_id )
        {
          mem_free(fragment_id);
          v1 = table_elinks->cells;
          cells = v1;
        }
        if ( table_elinks->rows <= ++v5 )
          break;
        real_cols = table_elinks->real_cols;
      }
      ++v2;
    }
    while ( table_elinks->cols > v2 );
  }
LABEL_24:
  mem_free(cells);
  mem_free(table_elinks->columns);
  mem_free(table_elinks);
}

//----- (0809E4C0) --------------------------------------------------------
void __usercall get_align(html_context *html_context@<eax>, unsigned __int8 *attr@<edx>, int *a@<ecx>)
{
  unsigned __int8 *attr_value; // eax
  char *v5; // ebx

  attr_value = get_attr_value(attr, "align", html_context->doc_cp, HTML_ATTR_NONE);
  v5 = (char *)attr_value;
  if ( attr_value )
  {
    if ( c_strcasecmp((const char *)attr_value, "left") )
    {
      if ( c_strcasecmp(v5, "right") )
      {
        if ( !c_strcasecmp(v5, "center") )
        {
          *a = 1;
          goto LABEL_4;
        }
        if ( !c_strcasecmp(v5, "justify") )
        {
          *a = 3;
          goto LABEL_4;
        }
        if ( c_strcasecmp(v5, "char") )
          goto LABEL_4;
      }
      *a = 2;
    }
    else
    {
      *a = 0;
    }
LABEL_4:
    mem_free(v5);
  }
}

//----- (0809E590) --------------------------------------------------------
void __usercall get_valign(html_context *html_context@<eax>, unsigned __int8 *attr@<edx>, int *a@<ecx>)
{
  unsigned __int8 *attr_value; // eax
  char *v5; // ebx

  attr_value = get_attr_value(attr, "valign", html_context->doc_cp, HTML_ATTR_NONE);
  v5 = (char *)attr_value;
  if ( attr_value )
  {
    if ( c_strcasecmp((const char *)attr_value, "top") )
    {
      if ( !c_strcasecmp(v5, "middle") )
      {
        *a = 1;
        goto LABEL_4;
      }
      if ( !c_strcasecmp(v5, "bottom") )
      {
        *a = 2;
        goto LABEL_4;
      }
      if ( c_strcasecmp(v5, "baseline") )
        goto LABEL_4;
    }
    *a = 0;
LABEL_4:
    mem_free(v5);
  }
}

//----- (0809E640) --------------------------------------------------------
void __usercall set_td_width(table_elinks *table_elinks@<eax>, int col@<edx>, int width@<ecx>, int force)
{
  int cols_x_count; // edi
  int *cols_x; // eax
  int *v7; // edx
  int v8; // eax
  int i; // eax
  int v10; // esi
  int v11; // ecx
  int *v12; // edi
  int v13; // [esp+14h] [ebp-24h]

  cols_x_count = table_elinks->cols_x_count;
  if ( cols_x_count > col )
  {
    cols_x = table_elinks->cols_x;
    goto LABEL_3;
  }
  if ( cols_x_count < col + 1 )
  {
    for ( i = table_elinks->cols_x_count; ; i = v10 )
    {
      v10 = 2 * i;
      if ( i > 0xFFFF )
        v10 = i + 0x10000;
      if ( i >= v10 )
        break;
      if ( col + 1 <= v10 )
        goto LABEL_29;
    }
LABEL_19:
    if ( cols_x_count )
      return;
    v10 = col + 1;
    goto LABEL_21;
  }
  v10 = table_elinks->cols_x_count;
LABEL_29:
  if ( !v10 )
    goto LABEL_19;
LABEL_21:
  v13 = col;
  cols_x = (int *)mem_realloc(table_elinks->cols_x, 4 * v10);
  col = v13;
  if ( !cols_x )
    return;
  v11 = table_elinks->cols_x_count;
  if ( v10 > v11 )
  {
    v12 = &cols_x[v11];
    do
    {
      ++v11;
      *v12++ = -1;
    }
    while ( v10 > v11 );
  }
  table_elinks->cols_x_count = v10;
  table_elinks->cols_x = cols_x;
LABEL_3:
  if ( force )
  {
    v7 = &table_elinks->cols_x[col];
    goto LABEL_10;
  }
  v7 = &cols_x[col];
  v8 = *v7;
  if ( *v7 == -1 )
  {
LABEL_10:
    *v7 = width;
    return;
  }
  if ( width == -1 )
    return;
  if ( width < 0 )
  {
    if ( v8 < 0 )
      goto LABEL_8;
    goto LABEL_10;
  }
  if ( v8 >= 0 )
LABEL_8:
    *v7 = (width + v8) >> 1;
}

//----- (0809E750) --------------------------------------------------------
void __usercall get_column_width(
        unsigned __int8 *attr@<eax>,
        int *width@<edx>,
        int sh@<ecx>,
        html_context *html_context)
{
  unsigned __int8 *attr_value; // eax
  char *v6; // esi
  size_t v7; // eax
  char *v8; // eax
  int v9; // eax
  int *v10; // eax
  int *v11; // ebx
  signed int v12; // eax
  unsigned __int8 *en; // [esp+2Ch] [ebp-1Ch] BYREF

  attr_value = get_attr_value(attr, "width", html_context->doc_cp, HTML_ATTR_NONE);
  v6 = (char *)attr_value;
  if ( attr_value )
  {
    v7 = strlen((const char *)attr_value);
    if ( v7 && (v8 = &v6[v7 - 1], *v8 == 42) )
    {
      *v8 = 0;
      v10 = __errno_location();
      *v10 = 0;
      v11 = v10;
      v12 = strtoul(v6, (char **)&en, 10);
      if ( v12 >= 0 && !*v11 && (*en == 46 || !*en) )
        *width = -2 - v12;
    }
    else
    {
      v9 = get_width(attr, "width", sh, html_context);
      if ( v9 >= 0 )
        *width = v9;
    }
    mem_free(v6);
  }
}

//----- (0809E830) --------------------------------------------------------
table_cell *__usercall new_cell@<eax>(table_elinks *table_elinks@<eax>, int dest_col@<edx>, int dest_row@<ecx>)
{
  int real_cols; // edi
  int v5; // eax
  bool v6; // cc
  int real_rows; // esi
  int v9; // eax
  int v10; // eax
  int i; // edi
  int v12; // ecx
  int v13; // eax
  table_cell *v14; // edi
  int v15; // esi
  int v16; // eax
  int cols; // eax
  int v18; // esi
  int j; // eax
  table_cell *cells; // edi
  table_cell *v21; // ecx
  int v22; // edx
  int v23; // eax
  table_cell *v24; // eax
  int rowspan; // edi
  int rows; // eax
  int v27; // edi
  int v28; // eax
  table_cell *v29; // esi
  table_cell *v30; // ecx
  int v31; // edx
  int v32; // eax
  table_cell *v33; // eax
  int v34; // [esp+1Ch] [ebp-3Ch]
  int v35; // [esp+20h] [ebp-38h]
  int v38; // [esp+2Ch] [ebp-2Ch]
  table_cell *dest; // [esp+30h] [ebp-28h]
  int v40; // [esp+34h] [ebp-24h]
  int v41; // [esp+38h] [ebp-20h]
  size_t n; // [esp+3Ch] [ebp-1Ch]
  int na; // [esp+3Ch] [ebp-1Ch]
  size_t nb; // [esp+3Ch] [ebp-1Ch]
  size_t nc; // [esp+3Ch] [ebp-1Ch]

  if ( table_elinks->cols > dest_col && table_elinks->rows > dest_row )
    return &table_elinks->cells[dest_col + dest_row * table_elinks->real_cols];
  real_cols = table_elinks->real_cols;
  v38 = dest_col + 1;
  v41 = dest_row + 1;
  while ( dest_col >= real_cols || dest_row >= table_elinks->real_rows )
  {
    while ( v38 > real_cols )
    {
      v5 = real_cols;
      v6 = real_cols <= 2047;
      real_cols *= 2;
      if ( !v6 )
        real_cols = v5 + 2048;
      if ( real_cols <= v5 )
        return 0;
    }
    if ( !real_cols )
      return 0;
    real_rows = table_elinks->real_rows;
    if ( real_rows < v41 )
    {
      v9 = 0x20000;
      if ( (4096 - real_cols) << 6 >= 0x20000 )
        v9 = (4096 - real_cols) << 6;
      n = real_cols;
      v10 = v9 >> 6;
      for ( i = table_elinks->real_rows; ; i = real_rows )
      {
        v6 = real_rows < v10;
        v12 = real_rows + v10;
        real_rows *= 2;
        if ( !v6 )
          real_rows = v12;
        if ( i >= real_rows )
          break;
        if ( v41 <= real_rows )
        {
          real_cols = n;
          goto LABEL_25;
        }
      }
      return 0;
    }
LABEL_25:
    if ( !real_rows )
      return 0;
    dest = (table_cell *)mem_calloc(real_cols * real_rows, 0x40u);
    if ( !dest )
      return 0;
    na = table_elinks->cols << 6;
    if ( na && table_elinks->rows > 0 )
    {
      v13 = table_elinks->real_cols;
      v40 = real_cols << 6;
      v35 = real_cols;
      v34 = real_rows;
      v14 = dest;
      v15 = 0;
      while ( 1 )
      {
        v16 = v15 * v13;
        ++v15;
        memcpy(v14, &table_elinks->cells[v16], na);
        v14 = (table_cell *)((char *)v14 + v40);
        if ( v15 >= table_elinks->rows )
          break;
        v13 = table_elinks->real_cols;
      }
      real_cols = v35;
      real_rows = v34;
    }
    mem_free(table_elinks->cells);
    table_elinks->real_cols = real_cols;
    table_elinks->real_rows = real_rows;
    table_elinks->cells = dest;
  }
  cols = table_elinks->cols;
  if ( dest_col >= cols )
  {
    if ( cols )
    {
      nb = cols - 1;
      if ( table_elinks->rows > 0 )
      {
        v18 = 0;
        for ( j = real_cols; ; j = table_elinks->real_cols )
        {
          cells = table_elinks->cells;
          v21 = &cells[nb + v18 * j];
          if ( v21->colspan == -1 )
          {
            v22 = table_elinks->cols;
            if ( dest_col >= v22 )
            {
              while ( 1 )
              {
                v23 = v22 + v18 * j;
                ++v22;
                v24 = &cells[v23];
                *((_BYTE *)v24 + 60) |= 3u;
                rowspan = v21->rowspan;
                v24->colspan = -1;
                v24->rowspan = rowspan;
                v24->col = v21->col;
                v24->row = v21->row;
                if ( dest_col < v22 )
                  break;
                cells = table_elinks->cells;
                j = table_elinks->real_cols;
              }
            }
          }
          if ( ++v18 >= table_elinks->rows )
            break;
        }
      }
    }
    table_elinks->cols = dest_col + 1;
  }
  rows = table_elinks->rows;
  if ( dest_row >= rows )
  {
    if ( rows )
    {
      nc = rows - 1;
      if ( table_elinks->cols > 0 )
      {
        v27 = 0;
        do
        {
          v28 = table_elinks->real_cols;
          v29 = table_elinks->cells;
          v30 = &v29[v27 + v28 * nc];
          if ( v30->rowspan == -1 )
          {
            v31 = table_elinks->rows;
            if ( dest_row >= v31 )
            {
              while ( 1 )
              {
                v32 = v31 * v28;
                ++v31;
                v33 = &v29[v27 + v32];
                *((_BYTE *)v33 + 60) |= 3u;
                v33->rowspan = -1;
                v33->colspan = v30->colspan;
                v33->col = v30->col;
                v33->row = v30->row;
                if ( dest_row < v31 )
                  break;
                v29 = table_elinks->cells;
                v28 = table_elinks->real_cols;
              }
            }
          }
          ++v27;
        }
        while ( v27 < table_elinks->cols );
      }
    }
    table_elinks->rows = dest_row + 1;
  }
  return &table_elinks->cells[dest_col + table_elinks->real_cols * dest_row];
}

//----- (0809EB00) --------------------------------------------------------
void __usercall new_columns(
        table_elinks *table_elinks@<eax>,
        int span@<edx>,
        int width@<ecx>,
        int align,
        int valign,
        int group)
{
  int real_columns_count; // eax
  int columns_count; // eax
  table_column *v10; // eax
  int v11; // edi
  table_column *v12; // eax
  int v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  int v15; // [esp+1Ch] [ebp-1Ch]

  v15 = span + table_elinks->columns_count;
  real_columns_count = table_elinks->real_columns_count;
  if ( v15 > real_columns_count )
  {
    while ( 1 )
    {
      v11 = 2 * real_columns_count;
      if ( real_columns_count > 0x3FFF )
        v11 = real_columns_count + 0x4000;
      if ( v11 <= real_columns_count )
        break;
      if ( v15 <= v11 )
      {
        if ( v11 )
        {
          v14 = span;
          v13 = width;
          v12 = (table_column *)mem_realloc(table_elinks->columns, 16 * v11);
          span = v14;
          width = v13;
          if ( v12 )
          {
            table_elinks->real_columns_count = v11;
            table_elinks->columns = v12;
            goto LABEL_2;
          }
        }
        return;
      }
      real_columns_count = v11;
    }
  }
  else
  {
LABEL_2:
    while ( span )
    {
      columns_count = table_elinks->columns_count;
      table_elinks->columns_count = columns_count + 1;
      v10 = &table_elinks->columns[columns_count];
      v10->align = align;
      v10->group = group;
      group = 0;
      --span;
      v10->width = width;
      v10->valign = valign;
    }
  }
}

//----- (0809EBD0) --------------------------------------------------------
table_elinks *__cdecl parse_table(
        unsigned __int8 *html,
        unsigned __int8 *eof,
        unsigned __int8 **end,
        unsigned __int8 *attr,
        int sh,
        html_context *html_context)
{
  unsigned __int8 *v6; // ebx
  table_cell *v7; // eax
  table_column *v8; // eax
  document_options *options; // eax
  unsigned __int8 *attr_value; // edx
  int width; // eax
  int num; // eax
  int v13; // eax
  unsigned __int8 *v14; // eax
  char *v15; // edi
  int v17; // eax
  unsigned __int8 *v18; // eax
  char *v19; // edi
  int bad_html_size; // edi
  html_start_end *bad_html; // eax
  unsigned int v22; // edx
  unsigned int v23; // edi
  int v24; // edx
  unsigned __int8 v25; // al
  int v26; // eax
  int v27; // ecx
  int v28; // ebx
  size_t v29; // eax
  int real_cols; // eax
  int v31; // edx
  int v32; // eax
  bool v33; // zf
  int v34; // ecx
  int v35; // ebx
  int v36; // ecx
  html_start_end *v37; // eax
  unsigned __int8 *v38; // edx
  int v39; // edi
  unsigned __int8 *v40; // eax
  unsigned int v41; // ecx
  const unsigned __int8 *v42; // eax
  int v43; // edx
  unsigned __int8 *v44; // eax
  int v45; // eax
  bool v46; // cc
  int v47; // eax
  int *v48; // eax
  unsigned __int8 *v49; // eax
  char v50; // al
  int v51; // edx
  unsigned __int8 *v52; // edx
  int v53; // eax
  table_cell *v54; // eax
  table_cell *v55; // ebx
  char v56; // al
  unsigned __int8 *v57; // eax
  char v58; // di
  char v59; // al
  int v60; // eax
  int v61; // ecx
  int v62; // eax
  int v63; // edi
  int v64; // eax
  int v65; // eax
  int v66; // ebx
  table_cell *v68; // eax
  char v69; // dl
  int i; // eax
  int v71; // edx
  int rows; // edx
  table_cell *v73; // eax
  char v74; // dl
  unsigned int v75; // edx
  int v76; // edi
  _WORD *v77; // edi
  int j; // eax
  int k; // edx
  int v80; // ecx
  unsigned __int8 *v81; // edx
  int v82; // ebx
  int v83; // eax
  unsigned __int8 *v84; // edx
  unsigned __int8 *pb; // [esp+3Ch] [ebp-8Ch]
  void *p; // [esp+3Ch] [ebp-8Ch]
  void *pa; // [esp+3Ch] [ebp-8Ch]
  int v88; // [esp+40h] [ebp-88h]
  int maxj; // [esp+44h] [ebp-84h]
  int group; // [esp+4Ch] [ebp-7Ch]
  int v91; // [esp+50h] [ebp-78h]
  unsigned __int8 *l_fragment_id; // [esp+54h] [ebp-74h]
  int dest_row; // [esp+58h] [ebp-70h]
  int c_span; // [esp+5Ch] [ebp-6Ch]
  int c_spana; // [esp+5Ch] [ebp-6Ch]
  int dest_col; // [esp+60h] [ebp-68h]
  int c; // [esp+64h] [ebp-64h]
  char ca; // [esp+64h] [ebp-64h]
  int cb; // [esp+64h] [ebp-64h]
  int cc; // [esp+64h] [ebp-64h]
  int in_cell; // [esp+68h] [ebp-60h]
  int in_cella; // [esp+68h] [ebp-60h]
  int in_cellb; // [esp+68h] [ebp-60h]
  table_elinks *v104; // [esp+6Ch] [ebp-5Ch]
  int width_0; // [esp+7Ch] [ebp-4Ch] BYREF
  int al_0; // [esp+80h] [ebp-48h] BYREF
  int val; // [esp+84h] [ebp-44h] BYREF
  int c_width; // [esp+88h] [ebp-40h] BYREF
  int c_val; // [esp+8Ch] [ebp-3Ch] BYREF
  int c_al; // [esp+90h] [ebp-38h] BYREF
  int l_val; // [esp+94h] [ebp-34h] BYREF
  int l_al; // [esp+98h] [ebp-30h] BYREF
  int namelen; // [esp+9Ch] [ebp-2Ch] BYREF
  color_T last_bgcolor; // [esp+A0h] [ebp-28h] BYREF
  unsigned __int8 *name; // [esp+A4h] [ebp-24h] BYREF
  unsigned __int8 *en; // [esp+A8h] [ebp-20h] BYREF
  unsigned __int8 *t_attr; // [esp+ACh] [ebp-1Ch] BYREF

  v6 = html;
  l_al = 0;
  l_val = 1;
  c_al = -1;
  c_val = -1;
  c_width = -1;
  *end = html;
  v104 = (table_elinks *)mem_calloc(1u, 0x94u);
  if ( !v104 )
    return v104;
  v7 = (table_cell *)mem_calloc(4u, 0x40u);
  v104->cells = v7;
  if ( !v7 )
  {
    mem_free(v104);
    return 0;
  }
  v104->real_cols = 2;
  v104->real_rows = 2;
  v8 = (table_column *)mem_calloc(2u, 0x10u);
  v104->columns = v8;
  if ( !v8 )
  {
    mem_free(v104->cells);
    mem_free(v104);
    return 0;
  }
  v104->real_columns_count = 2;
  v104->fragment_id = get_attr_value(attr, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
  options = html_context->options;
  if ( options->color_mode )
  {
    if ( options->use_document_colors > 0 )
    {
      attr_value = get_attr_value(attr, "bordercolor", html_context->doc_cp, HTML_ATTR_NONE);
      if ( attr_value
        || (attr_value = get_attr_value(attr, "bordercolorlight", html_context->doc_cp, HTML_ATTR_NONE)) != 0
        || (attr_value = get_attr_value(attr, "bordercolordark", html_context->doc_cp, HTML_ATTR_NONE)) != 0 )
      {
        pb = attr_value;
        decode_color(attr_value, strlen((const char *)attr_value), &v104->bordercolor);
        mem_free(pb);
      }
    }
  }
  width = get_width(attr, "width", sh, html_context);
  v104->width = width;
  if ( width == -1 )
  {
    v51 = 0;
    if ( *((_DWORD *)html_context->stack.next + 32)
       + -*((_DWORD *)html_context->stack.next + 31)
       - *((_DWORD *)html_context->stack.next + 30) >= 0 )
      v51 = *((_DWORD *)html_context->stack.next + 32)
          + -*((_DWORD *)html_context->stack.next + 31)
          - *((_DWORD *)html_context->stack.next + 30);
    v104->width = v51;
    *((_BYTE *)v104 + 124) |= 1u;
  }
  num = get_num(attr, "border", html_context->doc_cp);
  v104->border = num;
  if ( num == -1 )
  {
    v52 = get_attr_value(attr, "border", html_context->doc_cp, HTML_ATTR_TEST);
    num = 1;
    if ( !v52 )
    {
      if ( get_attr_value(attr, "rules", html_context->doc_cp, HTML_ATTR_TEST)
        || (v84 = get_attr_value(attr, "frame", html_context->doc_cp, HTML_ATTR_TEST), num = 0, v84) )
      {
        num = 1;
      }
    }
    v104->border = num;
  }
  if ( !num )
    goto LABEL_23;
  if ( num > 2 )
    v104->border = 2;
  v13 = get_num(attr, "cellspacing", html_context->doc_cp);
  v104->cellspacing = v13;
  if ( v13 <= 0 )
  {
    v104->cellspacing = 1;
  }
  else if ( v13 > 2 )
  {
    v104->cellspacing = 2;
  }
  if ( v104->border )
  {
    v104->frame = 15;
    v14 = get_attr_value(attr, "frame", html_context->doc_cp, HTML_ATTR_NONE);
    v15 = (char *)v14;
    if ( v14 )
    {
      if ( c_strcasecmp((const char *)v14, "void") )
      {
        if ( c_strcasecmp(v15, "above") )
        {
          if ( c_strcasecmp(v15, "below") )
          {
            if ( c_strcasecmp(v15, "hsides") )
            {
              if ( c_strcasecmp(v15, "vsides") )
              {
                if ( c_strcasecmp(v15, "lhs") )
                {
                  if ( !c_strcasecmp(v15, "rhs") )
                    v104->frame = 8;
                }
                else
                {
                  v104->frame = 4;
                }
              }
              else
              {
                v104->frame = 12;
              }
            }
            else
            {
              v104->frame = 3;
            }
          }
          else
          {
            v104->frame = 2;
          }
        }
        else
        {
          v104->frame = 1;
        }
      }
      else
      {
        v104->frame = 0;
      }
      mem_free(v15);
    }
  }
  else
  {
LABEL_23:
    v104->frame = 0;
  }
  v17 = get_num(attr, "cellpadding", html_context->doc_cp);
  v104->cellpadding = v17;
  if ( v17 == -1 )
  {
    v33 = v104->border == 0;
    v104->vcellpadding = 0;
    v104->cellpadding = !v33;
  }
  else
  {
    v104->vcellpadding = v17 > 6;
    v104->cellpadding = v17 > 3;
  }
  v104->rules = v104->border != 0 ? 3 : 0;
  v18 = get_attr_value(attr, "rules", html_context->doc_cp, HTML_ATTR_NONE);
  v19 = (char *)v18;
  if ( v18 )
  {
    if ( c_strcasecmp((const char *)v18, "none") )
    {
      if ( c_strcasecmp(v19, "groups") )
      {
        if ( c_strcasecmp(v19, "rows") )
        {
          if ( c_strcasecmp(v19, "cols") )
          {
            if ( !c_strcasecmp(v19, "all") )
              v104->rules = 3;
          }
          else
          {
            v104->rules = 2;
          }
        }
        else
        {
          v104->rules = 1;
        }
      }
      else
      {
        v104->rules = 4;
      }
    }
    else
    {
      v104->rules = 0;
    }
    mem_free(v19);
  }
  v104->align = *((_DWORD *)html_context->stack.next + 29);
  get_align(html_context, attr, &v104->align);
  v104->bgcolor = *((_DWORD *)html_context->stack.next + 37);
  get_bgcolor(html_context, attr, &v104->bgcolor);
  l_fragment_id = 0;
  in_cell = 0;
  last_bgcolor = v104->bgcolor;
  dest_row = -1;
  dest_col = 0;
  c_span = 0;
  group = 0;
  while ( 2 )
  {
    while ( 2 )
    {
      en = v6;
LABEL_32:
      if ( !in_cell && (!v104->caption.start || v104->caption.end) )
      {
        bad_html_size = v104->bad_html_size;
        if ( bad_html_size )
        {
          bad_html = v104->bad_html;
          if ( !bad_html[bad_html_size - 1].end )
            goto LABEL_40;
          v22 = bad_html_size + 256;
          LOBYTE(v22) = 0;
          v23 = (bad_html_size + 255) & 0xFFFFFF00;
          if ( v22 <= v23 )
          {
LABEL_38:
            if ( bad_html )
            {
              v24 = v104->bad_html_size;
              bad_html[v24].start = v6;
              v104->bad_html_size = v24 + 1;
            }
            goto LABEL_40;
          }
        }
        else
        {
          v23 = 0;
          bad_html = v104->bad_html;
          v22 = 256;
        }
        p = (void *)(8 * v22);
        v37 = (html_start_end *)mem_realloc(bad_html, 8 * v22);
        if ( !v37 )
          goto LABEL_40;
        v104->bad_html = v37;
        memset(&v37[v23], 0, (size_t)p - 8 * v23);
        bad_html = v104->bad_html;
        goto LABEL_38;
      }
LABEL_40:
      if ( eof <= v6 )
      {
LABEL_50:
        if ( in_cell )
          v104->cells[dest_col + v104->real_cols * dest_row].end = v6;
        goto scan_done;
      }
      while ( *v6 != 60 )
      {
        if ( eof <= ++v6 )
          goto LABEL_50;
      }
      if ( eof >= v6 + 2 )
      {
        v25 = v6[1];
        if ( v25 == 63 || v25 == 33 )
        {
          v6 = skip_comment(v6, eof);
          continue;
        }
      }
      break;
    }
    if ( parse_element(v6, eof, &name, &namelen, &t_attr, &en) )
    {
      ++v6;
      continue;
    }
    break;
  }
  v26 = namelen;
  if ( !namelen )
    goto LABEL_49;
  v38 = name;
  v39 = 0;
  if ( *name == 47 )
  {
    v26 = namelen - 1;
    namelen = v26;
    if ( !v26 )
      goto LABEL_49;
    ++name;
    LOWORD(v39) = 1;
    v38 = name;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
  errline = 611;
  if ( elinks_strlcasecmp(v38, v26, "TABLE", 5u, 1) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
    errline = 626;
    if ( !elinks_strlcasecmp(name, namelen, "CAPTION", 7u, 1) )
    {
      if ( v39 )
      {
        if ( v104->caption.start && !v104->caption.end )
          v104->caption.end = v6;
      }
      else
      {
        add_table_bad_html_end(v104, v6);
        if ( !v104->caption.start )
          v104->caption.start = v6;
      }
      goto LABEL_49;
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
    errline = 640;
    if ( !elinks_strlcasecmp(name, namelen, "COLGROUP", 8u, 1) )
    {
      if ( c_span )
        new_columns(v104, c_span, c_width, c_al, c_val, 1);
      add_table_bad_html_end(v104, v6);
      c_al = -1;
      c_val = -1;
      c_width = -1;
      c_span = 0;
      if ( !v39 )
      {
        get_align(html_context, t_attr, &c_al);
        get_valign(html_context, t_attr, &c_val);
        get_column_width(t_attr, &c_width, sh, html_context);
        v45 = get_num(t_attr, "span", html_context->doc_cp);
        c_spana = v45;
        if ( v45 == -1 )
        {
          c_span = 1;
        }
        else
        {
          v46 = v45 < 32769;
          v47 = 0x8000;
          if ( v46 )
            v47 = c_spana;
          c_span = v47;
        }
      }
      goto LABEL_49;
    }
    if ( !v39 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
      errline = 666;
      if ( !elinks_strlcasecmp(name, namelen, "COL", 3u, 1) )
      {
        v81 = v6;
        v82 = 1;
        add_table_bad_html_end(v104, v81);
        v83 = get_num(t_attr, "span", html_context->doc_cp);
        if ( v83 != -1 )
        {
          LOWORD(v82) = 0x8000;
          if ( v83 <= 0x8000 )
            v82 = v83;
        }
        width_0 = c_width;
        al_0 = c_al;
        val = c_val;
        get_align(html_context, t_attr, &al_0);
        get_valign(html_context, t_attr, &val);
        get_column_width(t_attr, &width_0, sh, html_context);
        new_columns(v104, v82, width_0, al_0, val, c_span != 0);
        c_span = 0;
        goto LABEL_49;
      }
    }
    if ( c_toupper(*name) != 84 )
      goto LABEL_49;
    v49 = name++;
    if ( !--namelen )
      goto LABEL_49;
    v50 = c_toupper(v49[1]);
    ca = v50;
    if ( v39 )
    {
      if ( namelen == 1 && (v50 == 68 || v50 == 82 || v50 == 72) )
      {
        if ( c_span )
          new_columns(v104, c_span, c_width, c_al, c_val, 1);
        if ( in_cell )
          v104->cells[dest_col + v104->real_cols * dest_row].end = v6;
        add_table_bad_html_end(v104, v6);
        in_cell = 0;
      }
      goto LABEL_49;
    }
    v53 = namelen;
    if ( namelen == 4 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
      errline = 715;
      if ( !elinks_strlcasecmp(name, 4u, "HEAD", 4u, 1)
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c",
            errline = 716,
            !elinks_strlcasecmp(name, namelen, "BODY", 4u, 1))
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c",
            errline = 717,
            !elinks_strlcasecmp(name, namelen, "FOOT", 4u, 1)) )
      {
        if ( c_span )
          new_columns(v104, c_span, c_width, c_al, c_val, 1);
        add_table_bad_html_end(v104, v6);
        group = 2;
        goto LABEL_49;
      }
      v53 = namelen;
    }
    if ( v53 != 1 )
      goto LABEL_49;
    if ( ca == 82 )
    {
      if ( c_span )
        new_columns(v104, c_span, c_width, c_al, c_val, 1);
      if ( in_cell )
        v104->cells[dest_col + v104->real_cols * dest_row].end = v6;
      add_table_bad_html_end(v104, v6);
      group = (group == 0) + group - 1;
      l_al = 0;
      l_val = 1;
      last_bgcolor = v104->bgcolor;
      get_align(html_context, t_attr, &l_al);
      get_valign(html_context, t_attr, &l_val);
      get_bgcolor(html_context, t_attr, &last_bgcolor);
      if ( l_fragment_id )
        mem_free(l_fragment_id);
      ++dest_row;
      in_cell = 0;
      dest_col = 0;
      l_fragment_id = get_attr_value(t_attr, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
      goto LABEL_49;
    }
    if ( ca != 72 && ca != 68 )
      goto LABEL_49;
    if ( c_span )
      new_columns(v104, c_span, c_width, c_al, c_val, 1);
    add_table_bad_html_end(v104, v6);
    if ( in_cell )
      v104->cells[dest_col + v104->real_cols * dest_row].end = v6;
    if ( dest_row == -1 )
    {
      dest_row = 0;
      dest_col = 0;
    }
    while ( 1 )
    {
      v54 = new_cell(v104, dest_col, dest_row);
      v55 = v54;
      if ( !v54 )
      {
LABEL_209:
        in_cell = 0;
        goto LABEL_49;
      }
      v56 = *((_BYTE *)v54 + 60);
      if ( (v56 & 1) == 0 )
        break;
      if ( v55->colspan == -1 )
        goto LABEL_209;
      ++dest_col;
    }
    v55->col = dest_col;
    *((_BYTE *)v55 + 60) = v56 | 1;
    v55->row = dest_row;
    v55->start = en;
    v55->align = l_al;
    v55->valign = l_val;
    v57 = get_attr_value(t_attr, (unsigned __int8 *)"id", html_context->doc_cp, HTML_ATTR_NONE);
    v55->fragment_id = v57;
    if ( !v57 && l_fragment_id )
    {
      v55->fragment_id = l_fragment_id;
      l_fragment_id = 0;
    }
    v58 = 4 * (ca == 72);
    v59 = v58 | *((_BYTE *)v55 + 60) & 0xFB;
    *((_BYTE *)v55 + 60) = v59;
    if ( (v58 & 4) != 0 )
      v55->align = 1;
    if ( group == 1 )
      *((_BYTE *)v55 + 60) = v59 | 8;
    if ( v104->columns_count > dest_col )
    {
      v60 = (int)&v104->columns[dest_col];
      v61 = *(_DWORD *)(v60 + 4);
      if ( v61 != -1 )
      {
        v55->align = v61;
        v60 = (int)&v104->columns[dest_col];
      }
      v62 = *(_DWORD *)(v60 + 8);
      if ( v62 != -1 )
        v55->valign = v62;
    }
    v63 = 1;
    v55->bgcolor = last_bgcolor;
    get_align(html_context, t_attr, &v55->align);
    get_valign(html_context, t_attr, &v55->valign);
    get_bgcolor(html_context, t_attr, &v55->bgcolor);
    v64 = get_num(t_attr, (unsigned __int8 *)&byte_812C8D7, html_context->doc_cp);
    if ( v64 != -1 )
    {
      v63 = -1;
      if ( v64 )
      {
        v63 = 0x8000;
        if ( v64 <= 0x8000 )
          v63 = v64;
      }
    }
    v65 = get_num(t_attr, "rowspan", html_context->doc_cp);
    in_cella = 1;
    if ( v65 != -1 )
    {
      in_cella = -1;
      if ( v65 )
      {
        if ( v65 > 0x8000 )
          v65 = 0x8000;
        in_cella = v65;
      }
    }
    v55->colspan = v63;
    v55->rowspan = in_cella;
    if ( v63 == 1 )
    {
      val = -1;
      get_column_width(t_attr, &val, sh, html_context);
      if ( val != -1 )
        set_td_width(v104, dest_col, val, 0);
    }
    v66 = 1;
    cb = v104->cols;
    while ( v63 == -1 ? v66 < cb : v66 < v63 )
    {
      v68 = new_cell(v104, v66 + dest_col, dest_row);
      if ( !v68 )
        goto abort;
      v69 = *((_BYTE *)v68 + 60);
      if ( (v69 & 1) != 0 )
      {
        for ( i = 0; i < v66; ++i )
        {
          v71 = i + dest_col + v104->real_cols * dest_row;
          v104->cells[v71].colspan = v66;
        }
        v63 = v66;
        break;
      }
      ++v66;
      *((_BYTE *)v68 + 60) = v69 | 3;
      v68->colspan = v63;
      v68->rowspan = in_cella;
      v68->col = dest_col;
      v68->row = dest_row;
    }
    rows = in_cella;
    if ( in_cella == -1 )
      rows = v104->rows;
    maxj = rows;
    if ( (unsigned int)(v66 * rows) <= 0x80000 )
    {
      for ( cc = 1; cc < maxj; ++cc )
      {
        v91 = 0;
        v88 = dest_row + cc;
        while ( v91 < v66 )
        {
          v73 = new_cell(v104, dest_col + v91, v88);
          if ( !v73 )
            goto abort;
          v74 = *((_BYTE *)v73 + 60);
          if ( (v74 & 1) != 0 )
          {
            if ( v73->col != dest_col || dest_row != v73->row )
            {
              for ( in_cellb = 0; in_cellb < v91; ++in_cellb )
              {
                v75 = 64;
                v76 = (int)&v104->cells[in_cellb + dest_col + v104->real_cols * v88];
                if ( (v76 & 1) != 0 )
                {
                  *(_BYTE *)v76++ = 0;
                  LOBYTE(v75) = 63;
                }
                if ( (v76 & 2) != 0 )
                {
                  *(_WORD *)v76 = 0;
                  v76 += 2;
                  v75 -= 2;
                }
                memset((void *)v76, 0, 4 * (v75 >> 2));
                v77 = (_WORD *)(v76 + 4 * (v75 >> 2));
                if ( (v75 & 2) != 0 )
                  *v77++ = 0;
                if ( (v75 & 1) != 0 )
                  *(_BYTE *)v77 = 0;
              }
              for ( j = 0; j < v66; ++j )
              {
                for ( k = 0; k < cc; ++k )
                {
                  v80 = k + dest_row;
                  v104->cells[j + dest_col + v104->real_cols * v80].rowspan = cc;
                }
              }
              goto LABEL_236;
            }
          }
          else
          {
            *((_BYTE *)v73 + 60) = v74 | 3;
            v73->colspan = v63;
            v73->rowspan = in_cella;
            v73->col = dest_col;
            v73->row = dest_row;
          }
          ++v91;
        }
      }
LABEL_236:
      in_cell = 1;
      goto LABEL_49;
    }
abort:
    *end = eof;
    free_table(v104);
    return 0;
  }
  if ( !v39 )
  {
    v40 = en;
    c = 1;
    val = (int)en;
LABEL_84:
    if ( eof <= v40 )
    {
LABEL_97:
      v44 = eof;
      goto LABEL_98;
    }
    while ( 1 )
    {
      do
      {
        if ( *v40 != 60 || parse_element(v40, eof, (unsigned __int8 **)&al_0, &width_0, 0, (unsigned __int8 **)&val) )
        {
          v40 = (unsigned __int8 *)++val;
          goto LABEL_84;
        }
        v40 = (unsigned __int8 *)val;
        v41 = val;
        if ( (unsigned int)eof <= val )
          goto LABEL_97;
      }
      while ( !width_0 );
      v42 = (const unsigned __int8 *)al_0;
      v43 = 0;
      if ( *(_BYTE *)al_0 == 47 )
      {
        v42 = (const unsigned __int8 *)++al_0;
        if ( !--width_0 )
          goto LABEL_96;
        v43 = 1;
      }
      pa = (void *)v43;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/html/parser/table.c";
      errline = 530;
      if ( !elinks_strlcasecmp(v42, width_0, "TABLE", 5u, 1) )
      {
        if ( pa )
        {
          if ( !--c )
          {
            v44 = (unsigned __int8 *)val;
LABEL_98:
            en = v44;
LABEL_49:
            v6 = en;
            goto LABEL_32;
          }
        }
        else
        {
          ++c;
        }
      }
      v41 = val;
LABEL_96:
      v40 = (unsigned __int8 *)v41;
      if ( (unsigned int)eof <= v41 )
        goto LABEL_97;
    }
  }
  if ( c_span )
    new_columns(v104, c_span, c_width, c_al, c_val, 1);
  if ( in_cell )
    v104->cells[dest_col + v104->real_cols * dest_row].end = v6;
scan_done:
  add_table_bad_html_end(v104, v6);
  *end = v6;
  if ( l_fragment_id )
    mem_free(l_fragment_id);
  if ( v104->cols > 0 )
  {
    v27 = v104->rows;
    v28 = 0;
    v29 = v27;
    while ( v27 <= 0 )
    {
LABEL_65:
      if ( v104->cols <= ++v28 )
        goto LABEL_66;
    }
    real_cols = v104->real_cols;
    v31 = 0;
    while ( 1 )
    {
      v32 = (int)&v104->cells[v28 + v31 * real_cols];
      if ( (*(_BYTE *)(v32 + 60) & 2) != 0 )
        break;
      if ( *(_DWORD *)(v32 + 32) == -1 )
      {
        v33 = *(_DWORD *)(v32 + 36) == -1;
        *(_DWORD *)(v32 + 32) = v104->cols - v28;
        v27 = v104->rows;
        if ( !v33 )
          break;
      }
      else if ( *(_DWORD *)(v32 + 36) != -1 )
      {
        break;
      }
      v34 = v27 - v31++;
      *(_DWORD *)(v32 + 36) = v34;
      v27 = v104->rows;
      v29 = v27;
      if ( v27 <= v31 )
        goto LABEL_65;
LABEL_60:
      real_cols = v104->real_cols;
    }
    ++v31;
    v29 = v27;
    if ( v27 <= v31 )
      goto LABEL_65;
    goto LABEL_60;
  }
  v29 = v104->rows;
LABEL_66:
  if ( v29 )
  {
    v48 = (int *)mem_calloc(v29, 4u);
    v104->rows_heights = v48;
    if ( !v48 )
      goto abort;
  }
  else
  {
    v104->rows_heights = 0;
  }
  if ( v104->columns_count > 0 )
  {
    v35 = 0;
    do
    {
      v36 = v104->columns[v35].width;
      if ( v36 != -1 )
        set_td_width(v104, v35, v36, 1);
      ++v35;
    }
    while ( v104->columns_count > v35 );
  }
  set_td_width(v104, v104->cols, -1, 0);
  return v104;
}

//----- (080A0150) --------------------------------------------------------
screen_char *__usercall realloc_line_1@<eax>(document *document@<eax>, int x@<edx>, int y@<ecx>)
{
  line *v4; // eax
  line *v5; // esi
  int length; // edi
  unsigned int v8; // edi
  unsigned int v9; // edx
  screen_char *v10; // eax
  int v11; // [esp+1Ch] [ebp-1Ch]

  v4 = realloc_lines(document, y);
  v5 = v4;
  if ( !v4 )
    return 0;
  length = v4->length;
  if ( length != x )
  {
    v8 = (length + 15) & 0xFFFFFFF0;
    v9 = (x + 15) & 0xFFFFFFF0;
    if ( v9 > v8 )
    {
      v11 = 8 * v9;
      v10 = (screen_char *)mem_realloc(v4->chars, 8 * v9);
      if ( !v10 )
        return 0;
      v5->chars = v10;
      memset(&v10[v8], 0, v11 - 8 * v8);
    }
    if ( v5->chars )
    {
      v5->length = x;
      return v5->chars;
    }
    return 0;
  }
  return v5->chars;
}

//----- (080A01F0) --------------------------------------------------------
void __cdecl render_plain_document(cache_entry *cached, document *document, string *buffer)
{
  unsigned __int8 *head; // eax
  conv_table *convert_table; // eax
  int v5; // edx
  char v6; // cl
  int width; // eax
  color_T bg; // eax
  int v9; // esi
  int v10; // ebx
  unsigned __int8 v11; // di
  _BOOL4 v12; // eax
  unicode_val_T v13; // eax
  char v14; // al
  char v15; // al
  int v16; // esi
  int v17; // edi
  int v18; // edx
  char v19; // al
  unsigned __int8 v20; // dl
  int v21; // eax
  screen_char *v22; // eax
  int v23; // esi
  int v24; // edi
  unsigned __int8 *v25; // ecx
  unsigned __int8 v26; // bl
  int v27; // edx
  screen_char *v28; // eax
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // esi
  int v33; // ebx
  int v34; // eax
  const unsigned __int16 **v35; // eax
  unsigned __int8 *v36; // ecx
  unicode_val_T v37; // eax
  unicode_val_T v38; // eax
  int v39; // eax
  screen_char *v40; // ecx
  int v41; // ebx
  unsigned __int8 v42; // al
  unicode_val_T v43; // eax
  int v44; // edi
  screen_char *v45; // ebx
  int v46; // edi
  _DWORD *v47; // eax
  int lineno; // edx
  document *v49; // ecx
  int v50; // edx
  void *next; // esi
  int v52; // esi
  unsigned __int8 v53; // al
  int v54; // ebx
  unsigned __int8 v55; // al
  unsigned __int8 v56; // al
  int v57; // ebx
  unsigned __int8 *v58; // eax
  char v59; // cl
  unsigned __int8 *v60; // eax
  unsigned __int8 *v61; // ecx
  unsigned __int8 *v62; // esi
  unsigned __int8 *v63; // ebx
  uri_errno v64; // eax
  unsigned __int8 *v65; // eax
  const unsigned __int8 *v66; // ecx
  int v67; // edx
  unsigned __int8 *v68; // ecx
  int v69; // esi
  unsigned int v70; // eax
  unsigned int v71; // esi
  int v72; // esi
  int v73; // eax
  _DWORD *v74; // eax
  int v75; // edx
  int v76; // esi
  unsigned __int8 v77; // bl
  global_history_item *global_history_item; // eax
  unsigned __int8 *v79; // ecx
  unsigned __int8 *v80; // ecx
  int v81; // edx
  unicode_val_T v82; // esi
  unsigned __int8 v83; // al
  unsigned __int8 *v84; // eax
  bookmark *bookmark; // eax
  int v86; // eax
  char *v87; // eax
  char *v88; // eax
  bool v89; // zf
  int n; // [esp+28h] [ebp-120h]
  int v91; // [esp+2Ch] [ebp-11Ch]
  int v92; // [esp+38h] [ebp-110h]
  int v93; // [esp+38h] [ebp-110h]
  int v94; // [esp+38h] [ebp-110h]
  int v95; // [esp+38h] [ebp-110h]
  int v96; // [esp+38h] [ebp-110h]
  int v97; // [esp+38h] [ebp-110h]
  unsigned __int8 *s; // [esp+3Ch] [ebp-10Ch]
  unsigned __int8 *sa; // [esp+3Ch] [ebp-10Ch]
  const unsigned __int8 *sb; // [esp+3Ch] [ebp-10Ch]
  unsigned __int8 *sc; // [esp+3Ch] [ebp-10Ch]
  unsigned __int8 *sd; // [esp+3Ch] [ebp-10Ch]
  unsigned __int8 *sf; // [esp+3Ch] [ebp-10Ch]
  unsigned __int8 *sg; // [esp+3Ch] [ebp-10Ch]
  unsigned __int8 *se; // [esp+3Ch] [ebp-10Ch]
  int v106; // [esp+44h] [ebp-104h]
  unsigned int v107; // [esp+48h] [ebp-100h]
  unsigned __int8 v108; // [esp+4Ch] [ebp-FCh]
  int v109; // [esp+4Ch] [ebp-FCh]
  unsigned __int8 *uristring; // [esp+50h] [ebp-F8h]
  int v111; // [esp+54h] [ebp-F4h]
  int v112; // [esp+58h] [ebp-F0h]
  int y; // [esp+5Ch] [ebp-ECh]
  int v114; // [esp+60h] [ebp-E8h]
  unsigned int v115; // [esp+64h] [ebp-E4h]
  unsigned __int8 *chars; // [esp+68h] [ebp-E0h]
  unsigned __int8 v117; // [esp+6Ch] [ebp-DCh]
  int v118; // [esp+6Ch] [ebp-DCh]
  unsigned __int8 v119; // [esp+71h] [ebp-D7h]
  unsigned __int8 v120; // [esp+72h] [ebp-D6h]
  unsigned __int8 attr; // [esp+73h] [ebp-D5h]
  unicode_val_T data; // [esp+74h] [ebp-D4h]
  document *v123; // [esp+78h] [ebp-D0h]
  unicode_val_T c; // [esp+7Ch] [ebp-CCh]
  int v125; // [esp+80h] [ebp-C8h]
  int v126; // [esp+84h] [ebp-C4h]
  int v127; // [esp+88h] [ebp-C0h]
  unsigned __int8 end; // [esp+8Ch] [ebp-BCh]
  unsigned __int8 *enda; // [esp+8Ch] [ebp-BCh]
  int v130; // [esp+90h] [ebp-B8h]
  int v131; // [esp+94h] [ebp-B4h]
  int v132; // [esp+98h] [ebp-B0h]
  int v133; // [esp+98h] [ebp-B0h]
  int v134; // [esp+98h] [ebp-B0h]
  int v135; // [esp+9Ch] [ebp-ACh]
  _BOOL4 v136; // [esp+9Ch] [ebp-ACh]
  int v137; // [esp+A0h] [ebp-A8h]
  char v138; // [esp+A0h] [ebp-A8h]
  screen_char *v139; // [esp+A0h] [ebp-A8h]
  const unsigned __int8 *src; // [esp+A4h] [ebp-A4h]
  int v141; // [esp+A8h] [ebp-A0h]
  int v142; // [esp+A8h] [ebp-A0h]
  int v143; // [esp+A8h] [ebp-A0h]
  unsigned __int8 *p; // [esp+ACh] [ebp-9Ch]
  uri uri; // [esp+BCh] [ebp-8Ch] BYREF
  plain_renderer renderer; // [esp+F8h] [ebp-50h] BYREF
  screen_char schar; // [esp+11Ch] [ebp-2Ch] BYREF
  unsigned __int8 *v148; // [esp+124h] [ebp-24h] BYREF
  int length; // [esp+128h] [ebp-20h] BYREF
  unsigned __int8 *string[7]; // [esp+12Ch] [ebp-1Ch] BYREF

  head = cached->head;
  if ( !head )
    head = (unsigned __int8 *)&delete;
  convert_table = get_convert_table(
                    head,
                    document->options.cp,
                    document->options.assume_cp,
                    &document->cp,
                    &document->cp_status,
                    document->options.hard_assume);
  renderer.source = buffer->source;
  v5 = buffer->length;
  renderer.document = document;
  renderer.convert_table = convert_table;
  renderer.lineno = 0;
  renderer.length = v5;
  v6 = *((_BYTE *)&document->options + 69);
  *((_BYTE *)&renderer + 32) = ((v6 & 8) != 0) | *((_BYTE *)&renderer + 32) & 0xFE;
  width = 0x7FFFFFFF;
  if ( v6 < 0 )
    width = document->options.box.width;
  renderer.max_width = width;
  bg = document->options.default_style.bg;
  document->width = 0;
  document->bgcolor = bg;
  *((_BYTE *)&document->options + 92) = (16 * (is_cp_utf8(document->options.cp) & 1)) | *((_BYTE *)&document->options
                                                                                        + 92) & 0xEF;
  get_screen_char_template(&renderer.template, &document->options, document->options.default_style);
  src = renderer.source;
  v131 = renderer.length;
  v130 = is_cp_utf8(renderer.document->cp);
  if ( renderer.length <= 0 )
    goto LABEL_60;
  v112 = 0;
  v114 = 0;
  do
  {
LABEL_7:
    v9 = 0;
    v10 = 0;
    v137 = 0;
    v135 = 0;
    v132 = 0;
    v141 = 1;
    while ( 1 )
    {
      if ( renderer.max_width <= v9 )
      {
LABEL_19:
        v14 = 1;
        v114 = 1;
        v127 = 0;
LABEL_20:
        if ( v131 > v10 && v14 )
        {
          v112 = 0;
          if ( v137 )
            v10 = v137;
          v127 = v137 != 0;
        }
        else
        {
          v112 = 0;
        }
LABEL_29:
        if ( !assert_failed )
        {
          assert_failed = (unsigned int)v10 >> 31;
          if ( v10 < 0 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
            errline = 593;
            elinks_internal("assertion width >= 0 failed!");
          }
        }
        chars = memacpy(src, v10);
        if ( !chars )
        {
LABEL_59:
          ++renderer.lineno;
          if ( v131 <= 0 )
            goto LABEL_60;
          goto LABEL_7;
        }
        v123 = renderer.document;
        v119 = renderer.template.color[1];
        v120 = renderer.template.color[0];
        attr = renderer.template.attr;
        data = renderer.template.data;
        v15 = *((_BYTE *)&renderer.document->options + 92);
        length = v10;
        v136 = (v15 & 0x10) != 0;
        y = renderer.lineno;
        p = convert_string_elinks(
              renderer.convert_table,
              chars,
              v10,
              renderer.document->options.cp,
              CSM_NONE,
              &length,
              0,
              0);
        if ( p )
        {
          v16 = length;
          v17 = 0;
          v133 = 0;
          v138 = 0;
          v18 = length;
          while ( v17 < v16 )
          {
            while ( 1 )
            {
              v19 = 1;
              v20 = p[v17];
              v142 = 1;
              LOBYTE(string[0]) = v20;
              if ( v136 )
                break;
LABEL_37:
              if ( v20 == 9 )
              {
                v17 += v142;
                v18 = v16;
                if ( v17 == v16 || p[v17] != 8 )
                  v133 += ~(v138 + (_BYTE)v133) & 7;
              }
              else
              {
                v17 += v142;
                v18 = v16;
              }
              v138 += v19;
              if ( v17 >= v16 )
                goto LABEL_40;
            }
            v148 = &p[v17];
            v142 = utf8charlen((const unsigned __int8 *)string);
            v37 = utf8_to_unicode(&v148, &p[length]);
            if ( v37 != -3 )
            {
              v19 = unicode_to_cell(v37);
              v20 = (unsigned __int8)string[0];
              v16 = length;
              goto LABEL_37;
            }
            v16 = length;
            v17 += v142;
            v18 = length;
          }
LABEL_40:
          v21 = v18;
          if ( !assert_failed )
          {
            v21 = v16;
            assert_failed = (unsigned int)v133 >> 31;
            if ( v133 < 0 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
              errline = 302;
              elinks_internal("assertion expanded >= 0 failed!");
              v21 = length;
            }
          }
          v22 = realloc_line_1(v123, v21 + v133, y);
          v115 = (unsigned int)v22;
          if ( v22 )
          {
            v23 = length;
            v24 = 0;
            v139 = v22;
            v126 = 0;
            v143 = 0;
            v111 = v10;
            while ( v24 < v23 )
            {
              v25 = &p[v24];
              v26 = p[v24];
              LOBYTE(string[0]) = v26;
              if ( v136 )
              {
                v148 = &p[v24];
                v134 = utf8charlen((const unsigned __int8 *)string);
                v38 = utf8_to_unicode(&v148, &p[length]);
                c = v38;
                if ( v38 == -3 )
                {
                  v23 = length;
                  v24 += v134;
                  continue;
                }
                v39 = unicode_to_cell(v38);
                v26 = (unsigned __int8)string[0];
                v23 = length;
                v25 = &p[v24];
                v125 = v39;
              }
              else
              {
                c = -3;
                v125 = 1;
                v134 = 1;
              }
              v117 = 0;
              if ( v24 > 0 )
                v117 = p[v24 - 1];
              end = 0;
              v27 = v24 + v134;
              if ( v24 + v134 >= v23 || (end = p[v27], end != 8) )
              {
                if ( v26 == 9 )
                {
                  v28 = v139;
                  renderer.template.data = 32;
                  v29 = ~((_BYTE)v143 + (_BYTE)v126) & 7;
                  v30 = v29;
                  do
                  {
                    --v30;
                    ++v28;
                    v31 = *(_DWORD *)&renderer.template.attr;
                    v28[-1].data = renderer.template.data;
                    *(_DWORD *)&v28[-1].attr = v31;
                  }
                  while ( v30 != -1 );
                  v126 += v29;
                  v23 = length;
                  v139 += v29 + 1;
                  renderer.template.color[1] = v119;
                  renderer.template.color[0] = v120;
                  renderer.template.attr = attr;
                  renderer.template.data = data;
                  goto LABEL_55;
                }
              }
              if ( v26 != 8 )
              {
                if ( (*((_BYTE *)&v123->options + 69) & 4) == 0 )
                  goto LABEL_73;
                s = v25;
                v35 = __ctype_b_loc();
                v27 = v24 + v134;
                v36 = s;
                if ( ((*v35)[v26] & 0x400) == 0 || ((*v35)[end] & 0x400) == 0 )
                  goto LABEL_73;
                v52 = v23 - v24;
                enda = (unsigned __int8 *)renderer.document;
                if ( v52 > 0 )
                {
                  v53 = *s;
                  if ( *s != 60 && v53 > 0x20u && v53 != 62 && v53 != 40 && v53 != 41 && v53 != 34 && v53 != 39 )
                  {
                    v54 = 0;
                    while ( v52 > ++v54 )
                    {
                      v55 = s[v54];
                      if ( v55 == 60 || v55 <= 0x20u || v55 == 62 || v55 == 40 || v55 == 41 || v55 == 39 || v55 == 34 )
                      {
                        n = v54;
                        if ( v54 > 0 )
                          goto LABEL_143;
                        schar = renderer.template;
                        if ( v54 )
                        {
                          v91 = v143 + v126;
                          v106 = v24 + v54;
                          goto LABEL_162;
                        }
LABEL_73:
                        if ( v136 )
                        {
                          if ( c == -3 )
                          {
                            v23 = length;
                            v24 = v27;
                            goto LABEL_56;
                          }
                          renderer.template.data = c;
                          v45 = v139 + 1;
                          *(_DWORD *)&v139->attr = *(_DWORD *)&renderer.template.attr;
                          v139->data = c;
                          if ( v125 == 2 )
                          {
                            renderer.template.data = -3;
                            v46 = *(_DWORD *)&renderer.template.attr;
                            v45 = v139 + 2;
                            v139[1].data = -3;
                            *(_DWORD *)&v139[1].attr = v46;
                          }
                        }
                        else
                        {
                          if ( LOBYTE(string[0]) == 127 || LOBYTE(string[0]) <= 0x1Fu )
                          {
                            LOBYTE(string[0]) = 46;
                            v43 = 46;
                          }
                          else
                          {
                            v43 = LOBYTE(string[0]);
                          }
                          renderer.template.data = v43;
                          v44 = *(_DWORD *)&renderer.template.attr;
                          v139->data = v43;
                          *(_DWORD *)&v139->attr = v44;
                          v45 = v139 + 1;
                          if ( !assert_failed )
                          {
                            assert_failed = LOBYTE(string[0]) == 0;
                            if ( !LOBYTE(string[0]) )
                            {
                              v92 = v27;
                              errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
                              errline = 462;
                              elinks_internal("assertion line_char failed!");
                              v27 = v92;
                            }
                          }
                        }
LABEL_109:
                        v23 = length;
                        v139 = v45;
                        renderer.template.color[1] = v119;
                        renderer.template.color[0] = v120;
                        renderer.template.attr = attr;
                        renderer.template.data = data;
LABEL_55:
                        v143 += v125;
                        v24 = v27;
                        goto LABEL_56;
                      }
                    }
                    n = v54;
LABEL_143:
                    v56 = s[n - 1];
                    if ( v56 != 46 && v56 != 44 )
                    {
LABEL_161:
                      v91 = v143 + v126;
                      v106 = v24 + n;
                      schar = renderer.template;
LABEL_162:
                      sa = v36;
                      v60 = (unsigned __int8 *)memchr(v36, 64, n);
                      v61 = sa;
                      v27 = v24 + v134;
                      v62 = &sa[n];
                      v63 = v60;
                      v108 = sa[n];
                      if ( assert_failed
                        || (assert_failed = enda == 0, !enda)
                        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c",
                            errline = 121,
                            elinks_internal("assertion document failed!"),
                            v27 = v24 + v134,
                            v61 = sa,
                            assert_failed) )
                      {
                        assert_failed = 0;
                        goto LABEL_73;
                      }
                      *v62 = 0;
                      if ( v61 < v63 && v63 && v63 - v61 < n - 1 )
                      {
                        v96 = v27;
                        sg = v61;
                        v84 = straconcat("mailto:", v61, 0);
                        v27 = v96;
                        v66 = sg;
                        uristring = v84;
                      }
                      else
                      {
                        v93 = v27;
                        sb = v61;
                        v64 = parse_uri(&uri, v61);
                        v27 = v93;
                        if ( v64
                          || uri.protocol == 18
                          || (*((_DWORD *)&uri + 12) & 0xFFFF00) == 0 && !*((_WORD *)&uri + 23) )
                        {
                          *v62 = v108;
                          goto LABEL_73;
                        }
                        v65 = memacpy(sb, n);
                        v66 = sb;
                        v27 = v93;
                        uristring = v65;
                      }
                      *v62 = v108;
                      if ( !uristring )
                        goto LABEL_73;
                      v94 = v27;
                      sc = (unsigned __int8 *)v66;
                      normalize_uri(0, uristring);
                      v67 = v94;
                      v68 = sc;
                      v69 = *((_DWORD *)enda + 65);
                      v70 = (v69 + 128) & 0xFFFFFF80;
                      v71 = (v69 + 127) & 0xFFFFFF80;
                      if ( v70 > v71 )
                      {
                        v109 = 52 * v70;
                        v87 = (char *)mem_realloc(*((void **)enda + 53), 52 * v70);
                        v67 = v94;
                        if ( v87 )
                        {
                          *((_DWORD *)enda + 53) = v87;
                          memset(&v87[52 * v71], 0, v109 - 52 * v71);
                          v68 = sc;
                          v67 = v94;
                          goto LABEL_174;
                        }
                      }
                      else
                      {
LABEL_174:
                        v72 = *((_DWORD *)enda + 53);
                        if ( v72 )
                        {
                          v73 = v72 + 52 * *((_DWORD *)enda + 65);
                          v118 = v73;
                          v107 = *(_DWORD *)(v73 + 28);
                          if ( n > v107 )
                          {
                            v97 = v67;
                            se = v68;
                            v88 = (char *)mem_realloc(*(void **)(v73 + 24), 8 * n);
                            v67 = v97;
                            if ( v88 )
                            {
                              *(_DWORD *)(v118 + 24) = v88;
                              memset(&v88[8 * v107], 0, 8 * n - 8 * v107);
                              v68 = se;
                              v67 = v97;
                              goto LABEL_176;
                            }
                          }
                          else
                          {
LABEL_176:
                            if ( *(_DWORD *)(v118 + 24) )
                            {
                              *(_DWORD *)(v118 + 4) = 0;
                              *(_DWORD *)(v118 + 28) = n;
                              *(_DWORD *)(v118 + 8) = uristring;
                              *(_DWORD *)(v118 + 36) = *((_DWORD *)enda + 14);
                              *(_DWORD *)(v118 + 40) = *((_DWORD *)enda + 15);
                              *(_DWORD *)(v118 + 32) = *((_DWORD *)enda + 65);
                              v74 = *(_DWORD **)(v118 + 24);
                              if ( n > 0 )
                              {
                                v75 = n;
                                v76 = v91;
                                do
                                {
                                  *v74 = v76++;
                                  v74[1] = y;
                                  v74 += 2;
                                  --v75;
                                }
                                while ( v75 );
                              }
                              ++*((_DWORD *)enda + 65);
                              enda[276] &= ~1u;
                              v77 = p[v106];
                              p[v106] = 0;
                              sd = v68;
                              global_history_item = get_global_history_item(v68);
                              v79 = sd;
                              if ( global_history_item )
                              {
                                *(_DWORD *)(v118 + 40) = *((_DWORD *)enda + 16);
                              }
                              else
                              {
                                bookmark = get_bookmark(sd);
                                v79 = sd;
                                if ( bookmark )
                                  v86 = *((_DWORD *)enda + 17);
                                else
                                  v86 = *((_DWORD *)enda + 15);
                                *(_DWORD *)(v118 + 40) = v86;
                              }
                              p[v106] = v77;
                              *(_DWORD *)(v118 + 36) = *((_DWORD *)enda + 14);
                              sf = v79;
                              set_term_color(
                                &schar,
                                (color_pair *)(v118 + 36),
                                *((color_flags *)enda + 19),
                                *((color_mode *)enda + 3));
                              v80 = sf;
                              v81 = 0;
                              do
                              {
                                v82 = *v80++;
                                schar.data = v82;
                                *(_DWORD *)&v139[v81].attr = *(_DWORD *)&schar.attr;
                                v139[v81++].data = v82;
                              }
                              while ( v81 != n );
                              v143 += v81 - 1;
                              v45 = &v139[v81];
                              v27 = v134 + v81 - 1 + v24;
                              goto LABEL_109;
                            }
                          }
                        }
                      }
                      v95 = v67;
                      mem_free(uristring);
                      v27 = v95;
                      goto LABEL_73;
                    }
                    v57 = n;
                    v58 = &s[n];
                    while ( --v57 )
                    {
                      v59 = *(v58 - 2);
                      --v58;
                      if ( v59 != 44 && v59 != 46 )
                      {
                        v36 = s;
                        n = v57;
                        goto LABEL_161;
                      }
                    }
                  }
                }
                schar = renderer.template;
                goto LABEL_73;
              }
              if ( !(v143 + v126) )
                goto LABEL_55;
              v40 = v139 - 1;
              if ( v115 >= (unsigned int)v139 )
                v40 = v139;
              v139 = v40;
              if ( end != 95 || v117 == 95 )
              {
                v41 = v126 - 2;
                if ( v24 + v126 - 2 < 0 )
                  v41 = v126;
                v126 = v41;
                if ( end == 95 )
                {
                  if ( v40->data != 95 )
                    goto LABEL_99;
                  if ( v41 + v24 >= 0 && v115 <= (unsigned int)&v40[-1] )
                  {
                    v83 = v40[-1].attr;
                    if ( v83 )
                    {
                      v42 = renderer.template.attr | v83;
                      renderer.template.attr = v42;
LABEL_101:
                      if ( v42 )
                        renderer.template.attr = v40->attr | v42;
                      goto LABEL_55;
                    }
                  }
                }
                else
                {
                  if ( v40->data == 95 )
                  {
                    v42 = renderer.template.attr | 0x20;
                    renderer.template.attr |= 0x20u;
                    goto LABEL_101;
                  }
LABEL_99:
                  if ( v40->data != end )
                  {
                    v42 = renderer.template.attr;
                    goto LABEL_101;
                  }
                }
                v42 = renderer.template.attr | 8;
                renderer.template.attr |= 8u;
                goto LABEL_101;
              }
              if ( v24 - 1 >= 0 )
              {
                p[v24 - 1] = 95;
                v23 = length;
              }
              if ( v27 < v23 )
              {
                p[v27] = v117;
                v23 = length;
                if ( v24 - 2 < 0 )
                  continue;
              }
              else if ( v24 - 2 < 0 )
              {
                continue;
              }
              --v143;
              --v24;
LABEL_56:
              ;
            }
            v10 = v111;
            mem_free(p);
            realloc_line_1(v123, (int)((int)v139 - v115) >> 3, y);
            v32 = length + v126;
            mem_free(chars);
            if ( !v32 )
              goto LABEL_58;
            v47 = mem_alloc(0x18u);
            if ( !v47 )
              goto LABEL_58;
            lineno = renderer.lineno;
            v49 = renderer.document;
            v47[2] = 0;
            v47[5] = 1;
            if ( lineno < 0 )
              lineno = 0;
            v47[3] = lineno;
            v50 = 0;
            if ( v32 >= 0 )
              v50 = v32;
            v47[4] = v50;
            if ( v49->width < v32 )
            {
              v49->width = v32;
              if ( v49->height > 0 )
                goto LABEL_123;
            }
            else if ( v49->height > 0 )
            {
LABEL_123:
              next = v49->nodes.next;
              v47[1] = &v49->nodes;
              *v47 = next;
              v49->nodes.next = v47;
              *(_DWORD *)(*v47 + 4) = v47;
LABEL_58:
              v33 = v127 + v10;
              v131 -= v33;
              src += v33;
              goto LABEL_59;
            }
            v49->height = 1;
            goto LABEL_123;
          }
          mem_free(p);
        }
        mem_free(chars);
        goto LABEL_58;
      }
      v12 = src[v10] == 13;
      if ( src[v12 + v10] == 10 )
      {
        v127 = v12 + 1;
        goto LABEL_24;
      }
      if ( src[v10] == 13 )
        break;
      v11 = src[v10];
      if ( ((*__ctype_b_loc())[v11] & 0x2000) == 0 )
      {
        v135 = 0;
        v141 = 0;
        goto LABEL_9;
      }
      if ( v141 )
      {
        ++v132;
        v137 = v10;
        v141 = 1;
        if ( v130 )
          goto LABEL_17;
LABEL_10:
        ++v9;
        if ( ++v10 >= v131 )
          goto LABEL_19;
      }
      else
      {
        ++v135;
        v137 = v10;
LABEL_9:
        if ( !v130 )
          goto LABEL_10;
LABEL_17:
        string[0] = (unsigned __int8 *)&src[v10];
        v13 = utf8_to_unicode(string, &src[v131]);
        if ( v13 == -3 )
          return;
        v9 += unicode_to_cell(v13);
        v10 += utf8charlen(&src[v10]);
        if ( v10 >= v131 )
          goto LABEL_19;
      }
    }
    v127 = 1;
LABEL_24:
    if ( !v141 )
    {
      if ( !v135 )
      {
        v112 = 0;
        v114 = 0;
        goto LABEL_29;
      }
      v10 -= v135;
      v89 = v135 + v127 == 0;
      v127 += v135;
      v114 = 0;
      v14 = v89;
      goto LABEL_20;
    }
    if ( !v114 && (!v112 || (*((_BYTE *)&renderer + 32) & 1) == 0) )
    {
      src += v132;
      v131 -= v132;
      v10 -= v132;
      v112 = 1;
      goto LABEL_29;
    }
    v131 -= v127 + v132;
    src += v127 + v132;
    v34 = --renderer.lineno;
    if ( !assert_failed )
    {
      assert_failed = (unsigned int)v34 >> 31;
      if ( v34 < 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
        errline = 567;
        elinks_internal("assertion renderer->lineno >= 0 failed!");
        v34 = renderer.lineno;
      }
    }
    renderer.lineno = v34 + 1;
  }
  while ( v131 > 0 );
LABEL_60:
  if ( !assert_failed )
  {
    assert_failed = v131 != 0;
    if ( v131 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/document/plain/renderer.c";
      errline = 613;
      elinks_internal("assertion !length failed!");
    }
  }
}

//----- (080A15D0) --------------------------------------------------------
dom_config_flag __cdecl parse_dom_config(unsigned __int8 *flaglist, unsigned __int8 separator)
{
  signed int v2; // edx
  const dom_config_info *v3; // ebx
  int v4; // edi
  unsigned int length; // esi
  size_t v6; // eax
  int v7; // eax
  dom_config_flag flag; // eax
  char *v10; // eax
  signed int v11; // [esp+1Ch] [ebp-2Ch]
  dom_config_flag flags; // [esp+28h] [ebp-20h]
  unsigned __int8 *end; // [esp+2Ch] [ebp-1Ch]

  flags = 0;
  if ( flaglist )
  {
    do
    {
      if ( separator && (v10 = strchr((const char *)flaglist, separator), (end = (unsigned __int8 *)v10) != 0) )
      {
        v2 = v10 - (char *)flaglist;
      }
      else
      {
        end = 0;
        v2 = strlen((const char *)flaglist);
      }
      v3 = dom_config_info_0;
      v4 = 0;
      while ( 1 )
      {
        length = v3->name.length;
        v11 = v2;
        v6 = v3->name.length;
        if ( v2 <= (signed int)v3->name.length )
          v6 = v2;
        v7 = c_strncasecmp((const char *)v3->name.string, (const char *)flaglist, v6);
        v2 = v11;
        if ( !v7 && v11 == length )
          break;
        ++v4;
        ++v3;
        if ( v4 == 7 )
        {
          flag = 0;
          goto LABEL_11;
        }
      }
      flag = dom_config_info_0[v4].flag;
LABEL_11:
      flags |= flag;
      if ( !end )
        break;
      flaglist = end + 1;
    }
    while ( end != (unsigned __int8 *)-1 );
  }
  return flags;
}

//----- (080A16C0) --------------------------------------------------------
dom_config *__cdecl add_dom_config_normalizer(dom_stack *stack, dom_config *config, dom_config_flag flags)
{
  dom_config *v3; // ebx

  v3 = config;
  config->error_handler = 0;
  config->flags = flags;
  if ( !add_dom_stack_context(stack, config, &dom_config_normalizer_context) )
    return 0;
  return v3;
}

//----- (080A1700) --------------------------------------------------------
dom_code __usercall normalize_text_node_whitespace@<eax>(dom_node *node@<eax>)
{
  bool v1; // zf
  unsigned int v2; // ebx
  const unsigned __int16 **v3; // eax
  size_t v4; // esi
  unsigned __int8 v5; // dl
  unsigned __int8 *v6; // edi
  char v7; // bl
  unsigned int v8; // eax
  dom_code result; // eax
  unsigned __int8 *p; // [esp+1Ch] [ebp-13Ch]
  unsigned int v11; // [esp+20h] [ebp-138h]
  unsigned __int8 *text; // [esp+24h] [ebp-134h]
  int count; // [esp+2Ch] [ebp-12Ch]
  unsigned __int8 buf[256]; // [esp+3Ch] [ebp-11Ch] BYREF
  unsigned int v16; // [esp+13Ch] [ebp-1Ch]

  v16 = __readgsdword(0x14u);
  text = node->string.string;
  if ( !assert_failed )
  {
    v1 = node->type == 3;
    assert_failed = node->type != 3;
    if ( !v1 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/configuration.c";
      errline = 23;
      elinks_internal("assertion node->type == DOM_NODE_TEXT failed!");
    }
  }
  v2 = 0;
  v11 = 0;
  p = 0;
  count = 0;
  if ( !node->string.length )
  {
LABEL_15:
    v7 = *((_BYTE *)node + 2);
    if ( (v7 & 1) != 0 )
    {
      if ( node->string.string )
      {
        mem_free(node->string.string);
        v7 = *((_BYTE *)node + 2);
      }
      node->string.string = 0;
      node->string.length = 0;
    }
    v8 = v11;
    node->string.string = p;
    if ( v11 == -1 )
      v8 = strlen((const char *)p);
    node->string.length = v8;
    result = DOM_CODE_OK;
    *((_BYTE *)node + 2) = v7 | 1;
    return result;
  }
  while ( 2 )
  {
    v3 = __ctype_b_loc();
    v4 = 0;
    do
    {
      v5 = text[v2];
      if ( ((*v3)[v5] & 0x2000) != 0 )
      {
        if ( count == 1 )
          goto LABEL_8;
        v5 = 32;
        count = 1;
      }
      else
      {
        count = 0;
      }
      buf[v4++] = v5;
LABEL_8:
      ++v2;
    }
    while ( v4 <= 0xFF && node->string.length > v2 );
    v6 = (unsigned __int8 *)mem_realloc(p, v11 + v4 + 1);
    if ( v6 )
    {
      memcpy(&v6[v11], buf, v4);
      v11 += v4;
      v6[v11] = 0;
      p = v6;
      if ( v2 >= node->string.length )
        goto LABEL_15;
      continue;
    }
    break;
  }
  result = DOM_CODE_ALLOC_ERR;
  if ( p )
  {
    mem_free(p);
    return -997;
  }
  return result;
}

//----- (080A1940) --------------------------------------------------------
dom_code __cdecl dom_normalize_text(dom_stack *stack, dom_node *node, void *data)
{
  if ( (*(_BYTE *)stack->current->data & 0x40) != 0 )
    return normalize_text_node_whitespace(node);
  else
    return 0;
}

//----- (080A1970) --------------------------------------------------------
int __usercall append_node_text@<eax>(dom_config *config@<eax>, dom_node *node@<edx>)
{
  dom_node *dom_node_prev; // esi
  unsigned int length; // ecx
  char *string; // edi
  int v6; // edx
  uint16_t type; // ax
  unsigned int v8; // edx
  uint16_t v9; // cx
  char *v11; // eax
  int v12; // edx
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  size_t v17; // eax
  size_t n; // [esp+14h] [ebp-34h]
  size_t na; // [esp+14h] [ebp-34h]
  unsigned int nb; // [esp+14h] [ebp-34h]
  int v21; // [esp+18h] [ebp-30h]
  int v22; // [esp+18h] [ebp-30h]
  int v23; // [esp+18h] [ebp-30h]
  int v24; // [esp+18h] [ebp-30h]
  _BYTE *v25; // [esp+20h] [ebp-28h]
  unsigned __int8 *v26; // [esp+20h] [ebp-28h]
  unsigned __int8 *src; // [esp+24h] [ebp-24h]
  size_t v29; // [esp+2Ch] [ebp-1Ch]

  dom_node_prev = get_dom_node_prev(node);
  src = node->string.string;
  length = node->string.length;
  if ( dom_node_prev && dom_node_prev->type == 3 )
  {
    if ( (*((_BYTE *)dom_node_prev + 2) & 1) != 0 )
    {
      v6 = dom_node_prev->string.length;
      string = (char *)dom_node_prev->string.string;
      v29 = v6;
    }
    else
    {
      v29 = dom_node_prev->string.length;
      v26 = dom_node_prev->string.string;
      nb = node->string.length;
      v16 = (char *)mem_realloc(0, v29 + 1);
      if ( !v16 )
        return -997;
      string = v16;
      memcpy(v16, v26, v29);
      v6 = v29;
      string[v29] = 0;
      dom_node_prev->string.string = (unsigned __int8 *)string;
      v17 = v29;
      length = nb;
      if ( v29 == -1 )
      {
        v17 = strlen(string);
        length = nb;
        v6 = -1;
      }
      dom_node_prev->string.length = v17;
      *((_BYTE *)dom_node_prev + 2) |= 1u;
    }
  }
  else
  {
    if ( node->type == 3 )
      return 0;
    string = 0;
    v6 = 0;
    v29 = 0;
    dom_node_prev = 0;
  }
  type = node->type;
  if ( node->type < 3u )
  {
LABEL_6:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/configuration.c";
    errline = 114;
    v21 = v6;
    elinks_internal("Cannot append from node %d", node->type);
    v8 = v21;
    goto LABEL_7;
  }
  if ( type <= 4u )
  {
    v24 = v6;
    na = length;
    v15 = (char *)mem_realloc(string, v29 + length + 1);
    if ( v15 )
    {
      string = v15;
      memcpy(&v15[v24], src, na);
      v8 = na + v24;
      string[na + v24] = 0;
LABEL_7:
      if ( !dom_node_prev )
      {
LABEL_8:
        v9 = node->type;
        node->data.attribute.value.length = 0;
        node->type = 3;
        node->data.document.children = 0;
        node->data.notation.system_id.length = 0;
        node->data.notation.system_id.string = 0;
        *((_BYTE *)node + 2) |= 1u;
        node->string.length = v8;
        node->string.string = (unsigned __int8 *)string;
        if ( (config->flags & 0x40) != 0 && v9 == 4 )
        {
          normalize_text_node_whitespace(node);
          return 0;
        }
        return 0;
      }
      goto LABEL_16;
    }
LABEL_24:
    if ( dom_node_prev )
    {
      dom_node_prev->string.length = v29;
      return -997;
    }
    if ( string )
    {
      mem_free(string);
      return -997;
    }
    return -997;
  }
  if ( type != 5 )
    goto LABEL_6;
  v22 = v6;
  n = length;
  v11 = (char *)mem_realloc(string, v29 + 2);
  if ( !v11 )
    goto LABEL_24;
  v11[v22] = 38;
  v12 = v22 + 1;
  string = v11;
  v11[v12] = 0;
  v25 = (_BYTE *)(n + v22 + 1);
  v23 = v22 + 1;
  v13 = (char *)mem_realloc(v11, n + v12 + 1);
  if ( !v13 )
    goto LABEL_24;
  string = v13;
  memcpy(&v13[v23], src, n);
  v25[(_DWORD)string] = 0;
  v14 = (char *)mem_realloc(string, (size_t)(v25 + 2));
  if ( !v14 )
    goto LABEL_24;
  string = v14;
  v25[(_DWORD)v14] = 59;
  v8 = (unsigned int)(v25 + 1);
  v25[(_DWORD)v14 + 1] = 0;
  if ( !dom_node_prev )
    goto LABEL_8;
LABEL_16:
  dom_node_prev->string.length = v8;
  dom_node_prev->string.string = (unsigned __int8 *)string;
  if ( (config->flags & 0x40) == 0 || node->type == 5 )
    return -998;
  normalize_text_node_whitespace(dom_node_prev);
  return -998;
}

//----- (080A1C80) --------------------------------------------------------
dom_code __cdecl dom_normalize_node_end(dom_stack *stack, dom_node *node, void *data)
{
  dom_config *v3; // eax
  dom_code result; // eax

  v3 = (dom_config *)stack->current->data;
  switch ( node->type )
  {
    case 1u:
    case 2u:
      if ( (v3->flags & 0x20) == 0 || node->data.element.type )
        goto LABEL_4;
      goto LABEL_7;
    case 3u:
      if ( (v3->flags & 4) != 0 || ((int)node->data.attribute.value.string & 1) == 0 )
        return append_node_text(v3, node);
      goto LABEL_7;
    case 4u:
      if ( (v3->flags & 1) == 0 )
        return append_node_text(v3, node);
      return 0;
    case 5u:
      if ( (v3->flags & 8) != 0 )
        return 0;
      else
        return append_node_text(v3, node);
    case 7u:
      if ( (v3->flags & 0x20) == 0 || node->data.element.namespace_offset )
        goto LABEL_4;
      goto LABEL_7;
    case 8u:
      if ( (v3->flags & 2) != 0 )
        result = DOM_CODE_OK;
      else
LABEL_7:
        result = DOM_CODE_FREE_NODE;
      break;
    default:
LABEL_4:
      result = DOM_CODE_OK;
      break;
  }
  return result;
}

//----- (080A1D30) --------------------------------------------------------
dom_string *__cdecl get_dom_node_type_name(dom_node_type type)
{
  if ( assert_failed )
    return &dom_node_type_names_5671[type];
  assert_failed = (unsigned int)type > DOM_NODE_NOTATION;
  if ( (unsigned int)type <= DOM_NODE_NOTATION )
    return &dom_node_type_names_5671[type];
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
  errline = 587;
  elinks_internal("assertion type < DOM_NODES failed!");
  return &dom_node_type_names_5671[type];
}

//----- (080A1DA0) --------------------------------------------------------
dom_string *__cdecl get_dom_node_value(dom_node *node)
{
  dom_string *result; // eax

  if ( !assert_failed )
  {
    assert_failed = node == 0;
    if ( !node )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 542;
      elinks_internal("assertion node failed!");
      if ( MEMORY[0] > 8u )
        return 0;
    }
  }
  switch ( node->type )
  {
    case 2u:
    case 7u:
      result = (dom_string *)&node->data;
      break;
    case 3u:
    case 4u:
    case 8u:
      result = &node->string;
      break;
    default:
      return 0;
  }
  return result;
}

//----- (080A1E30) --------------------------------------------------------
dom_string *__cdecl get_dom_node_name(dom_node *node)
{
  dom_string *result; // eax

  if ( !assert_failed )
  {
    assert_failed = node == 0;
    if ( !node )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 509;
      elinks_internal("assertion node failed!");
    }
  }
  switch ( node->type )
  {
    case 3u:
      result = &text_str_5616;
      break;
    case 4u:
      result = &cdata_section_str_5612;
      break;
    case 8u:
      result = &comment_str_5613;
      break;
    case 9u:
      result = &document_str_5614;
      break;
    case 0xBu:
      result = &document_fragment_str_5615;
      break;
    default:
      result = &node->string;
      break;
  }
  return result;
}

//----- (080A1F00) --------------------------------------------------------
int __usercall get_dom_node_list_pos@<eax>(dom_node_list *list@<eax>, dom_node *node@<edx>)
{
  int result; // eax
  dom_node *v4; // ecx
  dom_node *v5; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = list == 0, !list)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c",
        errline = 235,
        v5 = node,
        elinks_internal("assertion list failed!"),
        node = v5,
        assert_failed) )
  {
    assert_failed = 0;
    return -1;
  }
  else if ( list->size )
  {
    result = 0;
    while ( 1 )
    {
      v4 = list->entries[result];
      if ( v4 )
      {
        if ( v4 == node )
          break;
      }
      if ( list->size <= ++result )
        return -1;
    }
  }
  else
  {
    return -1;
  }
  return result;
}

//----- (080A1FA0) --------------------------------------------------------
dom_node *__cdecl get_dom_node_prev(dom_node *node)
{
  dom_node *parent; // ecx
  dom_node *v2; // edx
  uint16_t type; // cx
  uint16_t v4; // ax
  dom_node_list **p_map; // ebx
  bool v6; // zf
  int dom_node_list_pos; // eax
  dom_node_list **p_children; // edx
  int v10; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (parent = node->parent, assert_failed = parent == 0, !parent)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c",
        errline = 260,
        elinks_internal("assertion node->parent failed!"),
        assert_failed) )
  {
LABEL_17:
    assert_failed = 0;
    return 0;
  }
  v2 = node->parent;
  type = node->type;
  v4 = v2->type;
  if ( v2->type == 7 )
  {
    if ( type != 2 )
      return 0;
    p_map = &v2->data.proc_instruction.map;
    goto LABEL_10;
  }
  if ( v4 <= 7u )
  {
    if ( v4 != 1 )
      return 0;
    p_map = (dom_node_list **)&v2->data;
    p_children = &v2->data.document.children;
    if ( type == 2 )
      p_map = p_children;
    goto LABEL_10;
  }
  if ( v4 == 9 )
    goto LABEL_9;
  if ( v4 != 10 )
    return 0;
  if ( type != 6 )
  {
    if ( type != 12 )
      return 0;
LABEL_9:
    p_map = &v2->data.document.children;
    goto LABEL_10;
  }
  p_map = (dom_node_list **)&v2->data;
LABEL_10:
  if ( p_map )
  {
    v6 = *p_map != 0;
    assert_failed = *p_map == 0;
    if ( !v6 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 268;
      elinks_internal("assertion *list failed!");
      if ( assert_failed )
        goto LABEL_17;
    }
    dom_node_list_pos = get_dom_node_list_pos(*p_map, node);
    if ( assert_failed )
      goto LABEL_17;
    assert_failed = (unsigned int)dom_node_list_pos >> 31;
    if ( dom_node_list_pos < 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 272;
      v10 = dom_node_list_pos;
      elinks_internal("assertion index >= 0 failed!");
      dom_node_list_pos = v10;
      if ( assert_failed )
        goto LABEL_17;
    }
    if ( dom_node_list_pos > 0 )
      return (dom_node *)*(&(*p_map)->size + dom_node_list_pos);
  }
  return 0;
}

//----- (080A2170) --------------------------------------------------------
void __usercall del_from_dom_node_list(dom_node_list *list@<eax>, dom_node *node@<edx>)
{
  size_t size; // edi
  size_t v3; // eax
  unsigned int v4; // ebx
  dom_node **entries; // edx
  unsigned int v6; // ecx
  dom_node *v7; // ecx
  size_t v8; // eax
  dom_node **v9; // esi
  bool v10; // cf

  if ( list )
  {
    size = list->size;
    v3 = list->size;
    if ( v3 )
    {
      v4 = 1;
      entries = list->entries;
      while ( 1 )
      {
        v7 = (dom_node *)*(&list->size + v4);
        if ( v7 && v7 == node )
        {
          v8 = v3 - v4;
          v9 = entries + 1;
          if ( v8 )
          {
            memmove(entries, entries + 1, 4 * v8);
            size = list->size;
          }
          v3 = size - 1;
          v10 = v4 < size - 1;
          size = v3;
          v6 = v4 + 1;
          list->size = v3;
          entries = v9;
          if ( !v10 )
            return;
        }
        else
        {
          v3 = size;
          v6 = v4 + 1;
          ++entries;
          if ( v4 >= size )
            return;
        }
        v4 = v6;
      }
    }
  }
}

//----- (080A2200) --------------------------------------------------------
void __usercall done_dom_node_data(dom_node *node@<eax>)
{
  bool v2; // zf
  uint16_t type; // ax
  char v4; // al

  if ( !assert_failed )
  {
    assert_failed = node == 0;
    if ( node
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c",
          errline = 414,
          elinks_internal("assertion node failed!"),
          !assert_failed) )
    {
      v2 = node->type <= 0xCu;
      assert_failed = node->type > 0xCu;
      if ( !v2 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 415;
        elinks_internal("assertion node->type < DOM_NODES failed!");
      }
    }
  }
  type = node->type;
  if ( node->type == 2 )
    goto LABEL_20;
  if ( type <= 2u )
  {
    if ( type == 1 )
    {
      if ( node->data.attribute.value.length )
        done_dom_node_list(node->data.document_type.entities);
      if ( node->data.document.children )
        done_dom_node_list(node->data.document.children);
    }
    goto LABEL_8;
  }
  if ( type == 7 )
  {
    if ( node->data.notation.system_id.string )
      done_dom_node_list(node->data.proc_instruction.map);
LABEL_20:
    v4 = *((_BYTE *)node + 2);
    if ( (v4 & 1) == 0 )
      goto LABEL_13;
    if ( node->data.document.children )
    {
      mem_free(node->data.document.children);
      v4 = *((_BYTE *)node + 2);
    }
    node->data.document.children = 0;
    node->data.attribute.value.length = 0;
    goto LABEL_9;
  }
  if ( type != 9 || !node->data.document.children )
  {
LABEL_8:
    v4 = *((_BYTE *)node + 2);
    goto LABEL_9;
  }
  done_dom_node_list(node->data.document.children);
  v4 = *((_BYTE *)node + 2);
LABEL_9:
  if ( (v4 & 1) != 0 )
  {
    if ( node->string.string )
      mem_free(node->string.string);
    node->string.string = 0;
    node->string.length = 0;
  }
LABEL_13:
  node->type = -1;
  mem_free(node);
}

//----- (080A2390) --------------------------------------------------------
void __cdecl done_dom_node_list(dom_node_list *list)
{
  size_t v1; // ebx
  dom_node *v2; // eax

  if ( !assert_failed )
  {
    assert_failed = list == 0;
    if ( !list )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 113;
      elinks_internal("assertion list failed!");
    }
  }
  if ( list->size )
  {
    v1 = 0;
    do
    {
      v2 = list->entries[v1];
      if ( v2 )
        done_dom_node_data(v2);
      ++v1;
    }
    while ( list->size > v1 );
  }
  mem_free(list);
}

//----- (080A2410) --------------------------------------------------------
void __cdecl done_dom_node(dom_node *node)
{
  dom_node *parent; // esi
  uint16_t type; // ax

  if ( !assert_failed )
  {
    assert_failed = node == 0;
    if ( !node )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 469;
      elinks_internal("assertion node failed!");
    }
  }
  parent = node->parent;
  if ( !parent )
    goto LABEL_8;
  type = parent->type;
  if ( parent->type == 7 )
  {
    del_from_dom_node_list(parent->data.proc_instruction.map, node);
    done_dom_node_data(node);
  }
  else
  {
    if ( type != 9 )
    {
      if ( type != 1 )
      {
LABEL_8:
        done_dom_node_data(node);
        return;
      }
      del_from_dom_node_list(parent->data.document_type.entities, node);
    }
    del_from_dom_node_list(parent->data.document.children, node);
    done_dom_node_data(node);
  }
}

//----- (080A24D0) --------------------------------------------------------
int __cdecl dom_node_casecmp(dom_node *node1, dom_node *node2)
{
  uint16_t type; // ax
  signed int length; // eax
  int result; // eax
  uint16_t v5; // ax
  uint16_t v6; // dx

  type = node1->type;
  if ( node1->type == node2->type && (type == 1 || type == 2) )
  {
    v5 = node1->data.element.type;
    if ( v5 )
    {
      v6 = node2->data.element.type;
      if ( v6 )
        return v5 - v6;
    }
  }
  length = node2->string.length;
  if ( (signed int)node1->string.length <= length )
    length = node1->string.length;
  result = c_strncasecmp((const char *)node1->string.string, (const char *)node2->string.string, length);
  if ( !result )
    return node1->string.length - node2->string.length;
  return result;
}

//----- (080A2540) --------------------------------------------------------
dom_node *__cdecl get_dom_node_map_entry(dom_node_list *list, dom_node_type type, uint16_t subtype, dom_string *name)
{
  unsigned int length; // ebx
  unsigned __int8 *string; // ecx
  unsigned int i; // eax
  size_t size; // edi
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  dom_node *v11; // edx
  signed int v12; // esi
  dom_node *v14; // [esp+1Ch] [ebp-3Ch]
  dom_node node; // [esp+20h] [ebp-38h] BYREF

  length = name->length;
  string = name->string;
  for ( i = 0; i < 0x20; i += 4 )
    *(_DWORD *)((char *)&node.type + i) = 0;
  node.type = type;
  node.string.length = length;
  node.string.string = string;
  size = list->size;
  if ( !subtype )
    goto LABEL_7;
  if ( type == DOM_NODE_ATTRIBUTE )
  {
LABEL_25:
    node.data.element.type = subtype;
    goto LABEL_7;
  }
  if ( type != DOM_NODE_PROCESSING_INSTRUCTION )
  {
    if ( type != DOM_NODE_ELEMENT )
      goto LABEL_7;
    goto LABEL_25;
  }
  node.data.element.namespace_offset = subtype;
LABEL_7:
  v8 = assert_failed;
  if ( !assert_failed )
  {
    assert_failed = size == 0;
    if ( !size )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 171;
      elinks_internal("assertion has_bsearch_node(search->from, search->to) failed!");
      v8 = assert_failed;
    }
  }
  v9 = -1;
  while ( 1 )
  {
    v12 = v9 + (int)(size - v9) / 2;
    if ( !v8 )
    {
      if ( v12 < 0 || v12 >= list->size )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 162;
        elinks_internal("assertion 0 <= pos && pos < list->size failed: pos %d", v9 + (int)(size - v9) / 2);
      }
      else
      {
        assert_failed = 0;
      }
    }
    v14 = list->entries[v12];
    v10 = dom_node_casecmp(&node, v14);
    v11 = v14;
    if ( !v10 )
      break;
    if ( v10 >= 0 )
      v9 += (int)(size - v9) / 2;
    if ( v10 < 0 )
      size = v12;
    if ( size <= v9 + 1 )
      return 0;
    v8 = assert_failed;
  }
  return v11;
}

//----- (080A26C0) --------------------------------------------------------
dom_node_list *__cdecl add_to_dom_node_list(dom_node_list **list_ptr, dom_node *node, int position)
{
  dom_node_list **v3; // ecx
  int v4; // esi
  dom_node_list *v5; // ebx
  size_t size; // edx
  unsigned int v7; // edi
  unsigned int v8; // eax
  size_t v9; // eax
  size_t v11; // eax
  dom_node_list *v12; // eax
  int v13; // edx
  int v14; // edi
  unsigned int v15; // eax
  _WORD *v16; // edx
  size_t v17; // [esp+14h] [ebp-24h]
  dom_node_list **v18; // [esp+18h] [ebp-20h]

  v3 = list_ptr;
  v4 = position;
  if ( !assert_failed )
  {
    assert_failed = list_ptr == 0 || node == 0;
    if ( list_ptr == 0 || node == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 61;
      elinks_internal("assertion list_ptr && node failed!");
      v3 = list_ptr;
      v5 = *list_ptr;
      if ( *list_ptr )
        goto LABEL_4;
LABEL_17:
      v11 = 36;
      v7 = 0;
      size = 0;
      goto LABEL_18;
    }
  }
  v5 = *list_ptr;
  if ( !*list_ptr )
    goto LABEL_17;
LABEL_4:
  size = v5->size;
  v7 = (v5->size + 7) & 0xFFFFFFF8;
  v8 = (v5->size + 8) & 0xFFFFFFF8;
  if ( v7 >= v8 )
    goto LABEL_5;
  v11 = 4 * v8 + 4;
LABEL_18:
  v17 = size;
  v18 = v3;
  v12 = (dom_node_list *)mem_realloc(v5, v11);
  v5 = v12;
  if ( !v12 )
    return v5;
  if ( !v17 )
    v12->size = 0;
  v13 = (int)&v12->entries[v7];
  v14 = 32;
  if ( (v13 & 1) != 0 )
  {
    *(_BYTE *)v13 = 0;
    LOWORD(v14) = 31;
    ++v13;
  }
  if ( (v13 & 2) != 0 )
  {
    *(_WORD *)v13 = 0;
    v14 -= 2;
    v13 += 2;
  }
  v15 = 0;
  do
  {
    *(_DWORD *)(v13 + v15) = 0;
    v15 += 4;
  }
  while ( v15 < (v14 & 0xFFFFFFFC) );
  v16 = (_WORD *)(v15 + v13);
  if ( (v14 & 2) != 0 )
    *v16++ = 0;
  if ( (v14 & 1) != 0 )
    *(_BYTE *)v16 = 0;
  *v18 = v5;
LABEL_5:
  if ( !assert_failed )
  {
    if ( position >= 0 && position > v5->size )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 67;
      elinks_internal(
        "assertion position < 0 || position <= list->size failed: position out of bound %d > %zu",
        position,
        v5->size);
      goto LABEL_9;
    }
    assert_failed = 0;
  }
  if ( position >= 0 )
  {
LABEL_9:
    v9 = v5->size;
    if ( v5->size > position )
    {
      memmove(&v5[1].size + position, &v5->entries[position], 4 * (v9 - position));
      v9 = v5->size;
    }
    goto LABEL_11;
  }
  v4 = v5->size;
  v9 = v5->size;
LABEL_11:
  v5->size = v9 + 1;
  v5->entries[v4] = node;
  return v5;
}

//----- (080A28B0) --------------------------------------------------------
dom_node *__cdecl get_dom_node_child(dom_node *parent, dom_node_type type, int16_t subtype)
{
  uint16_t v3; // ax
  dom_node *result; // eax
  _DWORD **p_string; // eax
  _DWORD *v6; // esi
  int v7; // ecx

  v3 = parent->type;
  if ( parent->type == 7 )
  {
    if ( type != DOM_NODE_ATTRIBUTE )
      return 0;
    p_string = (_DWORD **)&parent->data.notation.system_id.string;
  }
  else if ( v3 <= 7u )
  {
    if ( v3 != 1 )
      return 0;
    p_string = (_DWORD **)&parent->data;
    if ( type == DOM_NODE_ATTRIBUTE )
      p_string = (_DWORD **)&parent->data.document.children;
  }
  else
  {
    if ( v3 != 9 )
    {
      if ( v3 != 10 )
        return 0;
      if ( type == DOM_NODE_ENTITY )
      {
        p_string = (_DWORD **)&parent->data;
        goto LABEL_10;
      }
      if ( type != DOM_NODE_NOTATION )
        return 0;
    }
    p_string = (_DWORD **)&parent->data.document.children;
  }
LABEL_10:
  if ( !p_string )
    return 0;
  v6 = *p_string;
  if ( !*p_string || !*v6 )
    return 0;
  v7 = 0;
  while ( 1 )
  {
    result = (dom_node *)v6[v7 + 1];
    if ( result
      && result->type == type
      && (!subtype
       || type != DOM_NODE_ATTRIBUTE && type != DOM_NODE_PROCESSING_INSTRUCTION && type != DOM_NODE_ELEMENT
       || result->data.element.type == subtype) )
    {
      break;
    }
    if ( (unsigned int)++v7 >= *v6 )
      return 0;
  }
  return result;
}

//----- (080A29B0) --------------------------------------------------------
int __cdecl get_dom_node_list_index(dom_node *parent, dom_node *node)
{
  uint16_t type; // ax
  uint16_t v3; // bx
  dom_node_list **p_map; // eax
  dom_node_list *v5; // eax

  type = parent->type;
  v3 = node->type;
  if ( parent->type == 7 )
  {
    if ( v3 != 2 )
      return -1;
    p_map = &parent->data.proc_instruction.map;
    goto LABEL_8;
  }
  if ( type <= 7u )
  {
    if ( type != 1 )
      return -1;
    p_map = (dom_node_list **)&parent->data;
    if ( v3 == 2 )
      p_map = &parent->data.document.children;
    goto LABEL_8;
  }
  if ( type != 9 )
  {
    if ( type != 10 )
      return -1;
    if ( v3 == 6 )
    {
      p_map = (dom_node_list **)&parent->data;
      goto LABEL_8;
    }
    if ( v3 != 12 )
      return -1;
  }
  p_map = &parent->data.document.children;
LABEL_8:
  if ( p_map )
  {
    v5 = *p_map;
    if ( v5 )
      return get_dom_node_list_pos(v5, node);
  }
  return -1;
}

//----- (080A2A50) --------------------------------------------------------
dom_node *__cdecl get_dom_node_next(dom_node *node)
{
  dom_node *parent; // ecx
  dom_node *v2; // edx
  uint16_t type; // cx
  uint16_t v4; // ax
  dom_node_list **p_map; // ebx
  bool v6; // zf
  int dom_node_list_pos; // eax
  size_t v8; // eax
  dom_node_list **p_children; // edx
  int v11; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (parent = node->parent, assert_failed = parent == 0, !parent)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c",
        errline = 287,
        elinks_internal("assertion node->parent failed!"),
        assert_failed) )
  {
LABEL_17:
    assert_failed = 0;
    return 0;
  }
  v2 = node->parent;
  type = node->type;
  v4 = v2->type;
  if ( v2->type == 7 )
  {
    if ( type != 2 )
      return 0;
    p_map = &v2->data.proc_instruction.map;
    goto LABEL_10;
  }
  if ( v4 <= 7u )
  {
    if ( v4 != 1 )
      return 0;
    p_map = (dom_node_list **)&v2->data;
    p_children = &v2->data.document.children;
    if ( type == 2 )
      p_map = p_children;
    goto LABEL_10;
  }
  if ( v4 == 9 )
    goto LABEL_9;
  if ( v4 != 10 )
    return 0;
  if ( type != 6 )
  {
    if ( type != 12 )
      return 0;
LABEL_9:
    p_map = &v2->data.document.children;
    goto LABEL_10;
  }
  p_map = (dom_node_list **)&v2->data;
LABEL_10:
  if ( p_map )
  {
    v6 = *p_map != 0;
    assert_failed = *p_map == 0;
    if ( !v6 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 295;
      elinks_internal("assertion *list failed!");
      if ( assert_failed )
        goto LABEL_17;
    }
    dom_node_list_pos = get_dom_node_list_pos(*p_map, node);
    if ( assert_failed )
      goto LABEL_17;
    assert_failed = (unsigned int)dom_node_list_pos >> 31;
    if ( dom_node_list_pos < 0 )
    {
      v11 = dom_node_list_pos;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 299;
      elinks_internal("assertion index >= 0 failed!");
      dom_node_list_pos = v11;
      if ( assert_failed )
        goto LABEL_17;
    }
    v8 = dom_node_list_pos + 1;
    if ( v8 < (*p_map)->size )
      return (*p_map)->entries[v8];
  }
  return 0;
}

//----- (080A2C20) --------------------------------------------------------
int __cdecl get_dom_node_map_index(dom_node_list *list, dom_node *node)
{
  int v2; // edx
  unsigned int size; // edi
  int v4; // ebx
  int v5; // eax
  signed int v6; // esi
  int result; // eax
  dom_node *v8; // [esp+1Ch] [ebp-1Ch]

  v2 = assert_failed;
  size = list->size;
  if ( !assert_failed )
  {
    assert_failed = size == 0;
    if ( !size )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 171;
      elinks_internal("assertion has_bsearch_node(search->from, search->to) failed!");
      v2 = assert_failed;
    }
  }
  v4 = -1;
  while ( 1 )
  {
    v6 = v4 + (int)(size - v4) / 2;
    if ( !v2 )
    {
      if ( v6 < 0 || v6 >= list->size )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
        errline = 162;
        elinks_internal("assertion 0 <= pos && pos < list->size failed: pos %d", v4 + (int)(size - v4) / 2);
      }
      else
      {
        assert_failed = 0;
      }
    }
    v8 = list->entries[v6];
    v5 = dom_node_casecmp(node, v8);
    if ( !v5 )
      break;
    if ( v5 >= 0 )
      v4 += (int)(size - v4) / 2;
    if ( v5 < 0 )
      size = v6;
    if ( size <= v4 + 1 )
      return size;
    v2 = assert_failed;
  }
  result = v4 + (int)(size - v4) / 2;
  if ( !v8 )
    return size;
  return result;
}

//----- (080A2D40) --------------------------------------------------------
dom_node *__cdecl init_dom_node_at(dom_node *parent, dom_node_type type, dom_string *string, int allocated)
{
  unsigned __int16 *v4; // ebx
  char v5; // al
  unsigned int length; // eax
  unsigned __int8 *v7; // edx
  bool v8; // zf
  uint16_t v9; // ax
  unsigned __int16 v10; // dx
  dom_node_list **p_map; // edi
  dom_node_list *v12; // eax
  int dom_node_map_index; // eax
  unsigned __int8 *v15; // edi
  char *v16; // eax
  int v17; // eax
  unsigned int v18; // edx
  dom_node *v19; // [esp+0h] [ebp-38h]
  unsigned int n; // [esp+1Ch] [ebp-1Ch]

  v4 = (unsigned __int16 *)mem_calloc(1u, 0x20u);
  if ( !v4 )
    return (dom_node *)v4;
  *((_DWORD *)v4 + 3) = parent;
  *v4 = type;
  if ( allocated < 0 )
  {
    if ( parent )
    {
      v5 = *((_BYTE *)parent + 2) & 1 | v4[1] & 0xFE;
      *((_BYTE *)v4 + 2) = v5;
    }
    else
    {
      v5 = *((_BYTE *)v4 + 2);
    }
  }
  else
  {
    v5 = (allocated != 0) | v4[1] & 0xFE;
    *((_BYTE *)v4 + 2) = v5;
  }
  if ( (v5 & 1) != 0 )
  {
    v15 = string->string;
    n = string->length;
    v16 = (char *)mem_realloc(*((void **)v4 + 2), string->length + *((_DWORD *)v4 + 1) + 1);
    if ( !v16 )
    {
LABEL_37:
      v19 = (dom_node *)v4;
      v4 = 0;
      done_dom_node(v19);
      return (dom_node *)v4;
    }
    *((_DWORD *)v4 + 2) = v16;
    memcpy(&v16[*((_DWORD *)v4 + 1)], v15, n);
    v17 = *((_DWORD *)v4 + 2);
    v18 = *((_DWORD *)v4 + 1) + n;
    *((_DWORD *)v4 + 1) = v18;
    *(_BYTE *)(v17 + v18) = 0;
  }
  else
  {
    length = string->length;
    v7 = string->string;
    v8 = string->length == -1;
    *((_DWORD *)v4 + 2) = v7;
    if ( v8 )
      length = strlen((const char *)v7);
    *((_DWORD *)v4 + 1) = length;
  }
  if ( !parent )
    return (dom_node *)v4;
  v9 = parent->type;
  v10 = *v4;
  if ( parent->type == 7 )
  {
    p_map = &parent->data.proc_instruction.map;
    if ( v10 == 2 )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( v9 > 7u )
  {
    if ( v9 == 9 )
      goto LABEL_27;
    if ( v9 == 10 )
    {
      p_map = (dom_node_list **)&parent->data;
      if ( v10 == 6 )
        goto LABEL_13;
      if ( v10 == 12 )
      {
LABEL_27:
        p_map = &parent->data.document.children;
        goto LABEL_13;
      }
    }
    goto LABEL_12;
  }
  if ( v9 != 1 )
  {
LABEL_12:
    p_map = 0;
    goto LABEL_13;
  }
  p_map = (dom_node_list **)&parent->data;
  if ( v10 == 2 )
    p_map = &parent->data.document.children;
LABEL_13:
  if ( !assert_failed )
  {
    assert_failed = p_map == 0;
    if ( !p_map )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/node.c";
      errline = 395;
      elinks_internal("assertion list != NULL failed: Adding node %d to bad parent %d", *v4, parent->type);
    }
  }
  v12 = *p_map;
  if ( *p_map && type == DOM_NODE_ATTRIBUTE && v12->size )
    dom_node_map_index = get_dom_node_map_index(v12, (dom_node *)v4);
  else
    dom_node_map_index = -1;
  if ( !add_to_dom_node_list(p_map, (dom_node *)v4, dom_node_map_index) )
    goto LABEL_37;
  return (dom_node *)v4;
}

//----- (080A2F90) --------------------------------------------------------
dom_scanner_token *__cdecl skip_dom_scanner_tokens(dom_scanner *scanner, int skipto, int precedence)
{
  int tokens; // edx
  dom_scanner_token *current; // ecx
  dom_scanner_token *v5; // eax
  dom_scanner_token *v6; // edi
  dom_scanner_token *result; // eax
  dom_scanner_token *v8; // ecx
  dom_scanner_token *v9; // edx

  tokens = scanner->tokens;
  if ( tokens <= 0 )
    return 0;
  current = scanner->current;
  if ( current >= &scanner->table[tokens] || !current )
    return 0;
  if ( current->type != skipto )
  {
    if ( precedence >= current->precedence )
    {
      while ( 1 )
      {
        v6 = &scanner->table[tokens];
        if ( current >= v6 )
          break;
        v5 = current + 1;
        scanner->current = current + 1;
        if ( &current[2] >= v6 )
        {
          v5 = scanner->info->scan(scanner);
        }
        else if ( v5 >= v6 )
        {
          return 0;
        }
        if ( !v5 )
          break;
        if ( v5->type == skipto )
          goto LABEL_19;
        if ( v5->precedence > precedence )
        {
          if ( skipto != v5->type )
            return 0;
LABEL_19:
          tokens = scanner->tokens;
          goto LABEL_20;
        }
        tokens = scanner->tokens;
        if ( tokens <= 0 )
          return 0;
        current = scanner->current;
      }
    }
    return 0;
  }
LABEL_20:
  if ( tokens <= 0 )
    return 0;
  v8 = scanner->current;
  v9 = &scanner->table[tokens];
  if ( v8 >= v9 )
    return 0;
  result = v8 + 1;
  scanner->current = v8 + 1;
  if ( &v8[2] >= v9 )
    return scanner->info->scan(scanner);
  if ( result >= v9 )
    return 0;
  return result;
}
// 80A2FDF: conditional instruction was optimized away because edx.4>=1

//----- (080A3070) --------------------------------------------------------
void __cdecl init_dom_scanner(
        dom_scanner *scanner,
        dom_scanner_info *scanner_info,
        dom_string *string,
        int state,
        int count_lines,
        int complete,
        int check_complete,
        int detect_errors)
{
  char v8; // al
  const dom_scan_table_info *scan_table_info; // esi
  $70130A969A8B755F84AA145B87409B20 type; // edx
  unsigned int v11; // edi
  bool v12; // zf
  unsigned __int8 *v13; // eax
  unsigned int length; // eax
  int v15; // edi
  unsigned __int8 *v16; // eax
  int v17; // edx
  unsigned __int8 *v18; // [esp+1Ch] [ebp-4Ch]
  unsigned int v19; // [esp+28h] [ebp-40h]
  const dom_scan_table_info *v20; // [esp+4Ch] [ebp-1Ch]

  v8 = *((_BYTE *)scanner_info + 1036);
  if ( (v8 & 1) == 0 )
  {
    scan_table_info = scanner_info->scan_table_info;
    if ( scan_table_info )
    {
      type = scan_table_info->type;
      if ( scan_table_info->type != DOM_SCAN_END )
      {
        v20 = scan_table_info + 1;
        while ( 1 )
        {
          if ( type == DOM_SCAN_RANGE )
          {
            v11 = *scan_table_info->data.string;
            if ( !assert_failed )
            {
              assert_failed = *scan_table_info->data.string == 0;
              if ( (int)v11 > 0
                || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c",
                    errline = 136,
                    elinks_internal("assertion index > 0 failed!"),
                    !assert_failed) )
              {
                v12 = scan_table_info->data.length <= 0xFF;
                assert_failed = scan_table_info->data.length > 0xFF;
                if ( v12
                  || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c",
                      errline = 137,
                      elinks_internal("assertion data->length < DOM_SCAN_TABLE_SIZE failed!"),
                      !assert_failed) )
                {
                  v12 = v11 <= scan_table_info->data.length;
                  assert_failed = v11 > scan_table_info->data.length;
                  if ( !v12 )
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
                    errline = 138;
                    elinks_internal("assertion index <= data->length failed!");
                  }
                }
              }
            }
            for ( ; v11 <= scan_table_info->data.length; ++v11 )
              scanner_info->scan_table[v11] |= scan_table_info->bits;
            goto LABEL_13;
          }
          v18 = scan_table_info->data.string;
          length = scan_table_info->data.length;
          v15 = length - 1;
          if ( !assert_failed )
          {
            assert_failed = ((unsigned int)v15 >> 31) | (type != DOM_SCAN_STRING);
            if ( !assert_failed )
              goto LABEL_19;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.c";
            errline = 147;
            v19 = length;
            elinks_internal("assertion info[i].type == DOM_SCAN_STRING && pos >= 0 failed!");
            length = v19;
          }
          if ( v15 >= 0 )
          {
LABEL_19:
            v16 = &v18[length];
            do
            {
              v17 = *--v16;
              scanner_info->scan_table[v17] |= scan_table_info->bits;
              --v15;
            }
            while ( v15 >= 0 );
            scan_table_info = v20;
            type = v20->type;
            ++v20;
            if ( type == DOM_SCAN_END )
            {
LABEL_14:
              v8 = *((_BYTE *)scanner_info + 1036);
              break;
            }
          }
          else
          {
LABEL_13:
            scan_table_info = v20;
            type = v20->type;
            ++v20;
            if ( type == DOM_SCAN_END )
              goto LABEL_14;
          }
        }
      }
    }
    *((_BYTE *)scanner_info + 1036) = v8 | 1;
  }
  memset(scanner, 0, sizeof(dom_scanner));
  scanner->string = string->string;
  scanner->position = string->string;
  v13 = &string->string[string->length];
  scanner->info = scanner_info;
  scanner->end = v13;
  scanner->current = scanner->table;
  scanner->state = state;
  *((_BYTE *)scanner + 32) = (count_lines != 0) | *((_BYTE *)scanner + 32) & 0xFE;
  *((_BYTE *)scanner + 24) = (4 * (detect_errors != 0)) | (check_complete != 0) | (2 * (complete == 0)) & 0xFB | *((_BYTE *)scanner + 24) & 0xF8;
  scanner->lineno = count_lines != 0;
  scanner_info->scan(scanner);
}

//----- (080A3330) --------------------------------------------------------
int __cdecl map_dom_scanner_string(dom_scanner *scanner, unsigned __int8 *ident, unsigned __int8 *end, int base_type)
{
  int v4; // edi
  int v5; // esi
  dom_scanner_info *info; // eax
  signed int *mappings; // ebx
  const char *i; // edx
  signed int v9; // eax

  v4 = end - ident;
  v5 = base_type;
  info = scanner->info;
  mappings = (signed int *)info->mappings;
  for ( i = (const char *)info->mappings->name.string; i; i = (const char *)mappings[1] )
  {
    v9 = *mappings;
    if ( !*mappings )
      break;
    if ( mappings[3] == base_type )
    {
      if ( v9 > v4 )
        v9 = end - ident;
      if ( !c_strncasecmp(i, (const char *)ident, v9) && v4 == *mappings )
        return mappings[2];
    }
    mappings += 4;
  }
  return v5;
}

//----- (080A33A0) --------------------------------------------------------
dom_scanner_token *__usercall get_next_dom_scanner_token@<eax>(dom_scanner *scanner@<eax>)
{
  int tokens; // edx
  dom_scanner_token *current; // ecx
  dom_scanner_token *v3; // ebx
  dom_scanner_token *v4; // edx

  tokens = scanner->tokens;
  if ( tokens <= 0 )
    return 0;
  current = scanner->current;
  v3 = &scanner->table[tokens];
  if ( current >= v3 )
    return 0;
  v4 = current + 1;
  scanner->current = current + 1;
  if ( &current[2] >= v3 )
    return scanner->info->scan(scanner);
  if ( v4 >= v3 )
    return 0;
  return v4;
}

//----- (080A33F0) --------------------------------------------------------
dom_code __cdecl dom_select_pop_element(dom_stack *stack, dom_node *node, void *data)
{
  dom_stack *v3; // esi
  int v4; // ebx
  dom_stack_context *v5; // edx
  size_t object_size; // ecx
  dom_node **v7; // eax
  unsigned __int8 *state_objects; // edi
  int v10; // [esp+1Ch] [ebp-2Ch]
  dom_stack_context *v11; // [esp+24h] [ebp-24h]
  size_t v12; // [esp+28h] [ebp-20h]
  dom_stack_state *state; // [esp+2Ch] [ebp-1Ch]

  v3 = (dom_stack *)stack->current->data;
  if ( (signed int)(v3->depth - 1) >= 0 )
  {
    v4 = 12 * v3->depth - 12;
    v10 = v3->depth - 1;
    do
    {
      state = (dom_stack_state *)((char *)v3->states + v4);
      if ( state )
      {
        v5 = *v3->contexts;
        object_size = v5->info->object_size;
        v7 = 0;
        if ( object_size )
        {
          if ( !assert_failed )
          {
            state_objects = v5->state_objects;
            assert_failed = state_objects == 0;
            if ( !state_objects )
            {
              v11 = v5;
              v12 = object_size;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
              errline = 198;
              elinks_internal("assertion context->state_objects failed!");
              object_size = v12;
              v5 = v11;
            }
          }
          v7 = (dom_node **)&v5->state_objects[object_size * state->depth];
        }
        if ( *v7 == node )
        {
          pop_dom_state(v3, state);
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 946;
          elinks_wdebug("Remove element.");
        }
      }
      v4 -= 12;
      --v10;
    }
    while ( v10 >= 0 );
  }
  return 0;
}

//----- (080A34E0) --------------------------------------------------------
void __cdecl done_dom_select(dom_select *select)
{
  if ( select->selector )
    done_dom_node(&select->selector->node);
  mem_free(select);
}

//----- (080A3510) --------------------------------------------------------
dom_code __cdecl dom_select_push_text(dom_stack *stack, dom_node *node, void *data)
{
  _DWORD *v3; // edx
  _DWORD *v4; // ecx
  int v5; // eax
  _WORD *v6; // edx

  v3 = stack->current->data;
  if ( !assert_failed )
    assert_failed = 0;
  v4 = *(_DWORD **)(*(_DWORD *)(*v3 + 4 * (3 * v3[1] - 3)) + 16);
  if ( !v4 || !*v4 )
  {
LABEL_9:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
    errline = 966;
    elinks_wdebug("Text node: %d chars", node->string.length);
    return 0;
  }
  v5 = 0;
  while ( 1 )
  {
    v6 = (_WORD *)v4[v5 + 1];
    if ( v6 )
    {
      if ( *v6 == 3 )
        break;
    }
    if ( *v4 <= (unsigned int)++v5 )
      goto LABEL_9;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
  errline = 966;
  elinks_wdebug("Text node: %d chars", node->string.length);
  if ( (unsigned __int16)(node->type - 3) <= 2u )
    return 0;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
  errline = 979;
  elinks_error((unsigned __int8 *)&byte_812CAEA);
  return 0;
}

//----- (080A3600) --------------------------------------------------------
dom_node_list *__cdecl select_dom_nodes(dom_select *select, dom_node *root)
{
  unsigned int i; // eax
  dom_select_data select_data; // [esp+18h] [ebp-50h] BYREF
  dom_stack stack; // [esp+38h] [ebp-30h] BYREF

  for ( i = 0; i < 0x20; i += 4 )
    *(dom_stack_state **)((char *)&select_data.stack.states + i) = 0;
  select_data.select = select;
  init_dom_stack(&stack, DOM_STACK_FLAG_NONE);
  add_dom_stack_context(&stack, &select_data, &dom_select_context_info);
  init_dom_stack(&select_data.stack, DOM_STACK_FLAG_NONE);
  add_dom_stack_context(&select_data.stack, &select_data, &dom_select_data_context_info);
  if ( push_dom_node(&select_data.stack, &select->selector->node) == DOM_CODE_OK )
  {
    *((_BYTE *)&select_data.stack.states[select_data.stack.depth - 1] + 8) |= 1u;
    walk_dom_nodes(&stack, root);
  }
  done_dom_stack(&select_data.stack);
  done_dom_stack(&stack);
  return select_data.list;
}

//----- (080A36D0) --------------------------------------------------------
dom_code __cdecl dom_select_push_element(dom_stack *stack, dom_node *node, void *data)
{
  dom_stack_context *current; // eax
  dom_stack *v4; // esi
  unsigned int v5; // edx
  dom_node *v6; // ecx
  unsigned int depth; // eax
  dom_node **p_node; // eax
  dom_node *v9; // edx
  dom_document *document; // eax
  dom_document *v11; // ecx
  dom_node_list *children; // edi
  unsigned int v13; // edx
  int v14; // esi
  size_t size; // ecx
  size_t v16; // eax
  dom_node *v17; // ebx
  const char *v18; // ebx
  int v19; // eax
  size_t v20; // esi
  size_t v21; // edi
  const unsigned __int16 **v22; // eax
  const unsigned __int16 *v23; // eax
  int v24; // edx
  unsigned __int16 v25; // ax
  dom_document *v26; // ecx
  int v27; // eax
  _WORD *v28; // edx
  int v30; // ecx
  signed int v31; // ebx
  int v32; // eax
  unsigned int v33; // edx
  dom_node *dom_node_map_entry; // eax
  int v35; // eax
  dom_node *v36; // eax
  int dom_node_list_index; // eax
  unsigned int v38; // edi
  int v39; // ebx
  dom_node **v40; // eax
  dom_node **v41; // ecx
  bool v42; // zf
  dom_node *v43; // ecx
  int v44; // eax
  dom_node_list *v45; // eax
  size_t v46; // eax
  size_t v47; // eax
  signed int v48; // ecx
  dom_node **v49; // [esp+28h] [ebp-40h]
  signed int v50; // [esp+28h] [ebp-40h]
  signed int v51; // [esp+28h] [ebp-40h]
  dom_node *v52; // [esp+2Ch] [ebp-3Ch]
  dom_node *v53; // [esp+2Ch] [ebp-3Ch]
  unsigned int v54; // [esp+2Ch] [ebp-3Ch]
  unsigned int v55; // [esp+2Ch] [ebp-3Ch]
  dom_node *v56; // [esp+2Ch] [ebp-3Ch]
  dom_node *v57; // [esp+2Ch] [ebp-3Ch]
  dom_node *v58; // [esp+2Ch] [ebp-3Ch]
  dom_node *v59; // [esp+2Ch] [ebp-3Ch]
  dom_node *v60; // [esp+2Ch] [ebp-3Ch]
  unsigned int v61; // [esp+2Ch] [ebp-3Ch]
  unsigned int v62; // [esp+2Ch] [ebp-3Ch]
  unsigned int v63; // [esp+2Ch] [ebp-3Ch]
  unsigned int v64; // [esp+2Ch] [ebp-3Ch]
  dom_node_list *v65; // [esp+30h] [ebp-38h]
  unsigned int v66; // [esp+34h] [ebp-34h]
  dom_node *v67; // [esp+38h] [ebp-30h]
  int v68; // [esp+3Ch] [ebp-2Ch]
  int v69; // [esp+3Ch] [ebp-2Ch]
  int v70; // [esp+3Ch] [ebp-2Ch]
  int v71; // [esp+40h] [ebp-28h]
  dom_stack *v72; // [esp+40h] [ebp-28h]
  char *s1a; // [esp+44h] [ebp-24h]
  char *s1b; // [esp+44h] [ebp-24h]
  char *s1; // [esp+44h] [ebp-24h]
  unsigned int pos; // [esp+48h] [ebp-20h]
  dom_node *parent; // [esp+4Ch] [ebp-1Ch]
  dom_node *parenta; // [esp+4Ch] [ebp-1Ch]
  dom_node *parentb; // [esp+4Ch] [ebp-1Ch]

  current = stack->current;
  v4 = (dom_stack *)current->data;
  if ( *((_DWORD *)current->data + 1) )
  {
    v5 = 0;
    pos = 0;
    while ( 1 )
    {
      p_node = &v4->states[v5].node;
      if ( !p_node )
        goto LABEL_5;
      v9 = *p_node;
      if ( !assert_failed )
      {
        if ( node && node->type == 1 )
        {
          assert_failed = 0;
        }
        else
        {
          v52 = *p_node;
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 855;
          elinks_internal("assertion node && node->type == DOM_NODE_ELEMENT failed!");
          v9 = v52;
        }
      }
      document = v9[1].data.document.document;
      if ( ((unsigned __int8)document & 8) == 0 )
        break;
      v71 = v9[1].data.attribute.value.length & 7;
      if ( ((unsigned __int8)document & 7) != 0 )
      {
LABEL_75:
        if ( !assert_failed )
          assert_failed = 0;
        v36 = node->parent;
        if ( !v36 )
          goto LABEL_5;
        if ( v71 == 1 )
        {
          v70 = -1;
        }
        else
        {
          v57 = v9;
          dom_node_list_index = get_dom_node_list_index(v36, node);
          v9 = v57;
          v70 = dom_node_list_index;
          if ( dom_node_list_index <= 0 )
            goto LABEL_5;
        }
        depth = v4->depth;
        v38 = depth - 1;
        if ( (int)(depth - 1) >= 0 )
        {
          v39 = 12 * depth - 12;
          while ( 1 )
          {
            v40 = (dom_node **)((char *)&v4->states->node + v39);
            if ( v40 && *v40 == v9->parent )
            {
              parenta = (dom_node *)*v4->contexts;
              s1b = *(char **)parenta->string.string;
              v41 = 0;
              if ( s1b )
              {
                if ( !assert_failed )
                {
                  v42 = parenta->string.length != 0;
                  assert_failed = parenta->string.length == 0;
                  if ( !v42 )
                  {
                    v49 = v40;
                    v59 = v9;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                    errline = 198;
                    elinks_internal("assertion context->state_objects failed!");
                    v9 = v59;
                    v40 = v49;
                  }
                }
                v41 = (dom_node **)(parenta->string.length + (_DWORD)v40[1] * (_DWORD)s1b);
              }
              v43 = *v41;
              if ( v71 == 1 )
              {
                if ( v43 == node->parent )
                  goto LABEL_94;
              }
              else
              {
                parentb = v43->parent;
                if ( parentb == node->parent )
                {
                  v58 = v9;
                  v44 = get_dom_node_list_index(parentb, v43);
                  v9 = v58;
                  if ( v71 == 2 )
                  {
                    if ( v44 + 1 == v70 )
                    {
LABEL_94:
                      document = v9[1].data.document.document;
                      goto LABEL_14;
                    }
                  }
                  else if ( v44 < v70 )
                  {
                    goto LABEL_94;
                  }
                }
              }
            }
            v39 -= 12;
            if ( (--v38 & 0x80000000) != 0 )
              goto LABEL_5;
          }
        }
LABEL_6:
        v5 = ++pos;
        if ( depth <= pos )
          return 0;
      }
      else
      {
LABEL_14:
        if ( ((unsigned __int8)document & 0x10) != 0 )
        {
          v6 = node->parent;
          if ( v6 )
          {
            if ( v6->type != 9 || v6->data.document.children->size > 1 )
              goto LABEL_5;
          }
        }
        if ( ((unsigned __int8)document & 0x20) != 0 )
        {
          v11 = node->data.document.document;
          if ( v11 )
          {
            if ( *(_DWORD *)v11 )
              goto LABEL_5;
          }
        }
        if ( ((unsigned __int8)document & 0xC0) != 0 )
          goto LABEL_5;
        parent = (dom_node *)v9->data.document.children;
        if ( parent )
        {
          children = node->data.document.children;
          if ( !assert_failed )
          {
            if ( v9->type == 1 && node->type == 1 )
            {
              assert_failed = 0;
            }
            else
            {
              v60 = v9;
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
              errline = 728;
              elinks_internal("assertion base->node.type == DOM_NODE_ELEMENT && node->type == DOM_NODE_ELEMENT failed!");
              v9 = v60;
            }
          }
          if ( !children )
            goto LABEL_5;
          if ( *(_DWORD *)&parent->type )
          {
            v67 = v9;
            v13 = 0;
            v72 = v4;
            while ( 1 )
            {
              while ( 1 )
              {
                v14 = *(&parent->string.length + v13);
                if ( !v14 )
                  goto LABEL_45;
                if ( *(char *)(v14 + 48) >= 0 )
                {
                  v55 = v13;
                  dom_node_map_entry = get_dom_node_map_entry(
                                         children,
                                         DOM_NODE_ATTRIBUTE,
                                         *(_WORD *)(v14 + 26),
                                         (dom_string *)(v14 + 4));
                  v13 = v55;
                  v17 = dom_node_map_entry;
                  if ( !dom_node_map_entry )
                    goto LABEL_31;
                }
                else
                {
                  size = children->size;
                  if ( !children->size )
                    goto LABEL_31;
                  v16 = 0;
                  while ( 1 )
                  {
                    v17 = children->entries[v16];
                    if ( v17 )
                    {
                      if ( (BYTE1(v17->data.proc_instruction.map) & 4) != 0 )
                        break;
                    }
                    if ( ++v16 >= size )
                      goto LABEL_31;
                  }
                  if ( v16 >= size )
                  {
LABEL_31:
                    v4 = v72;
                    goto LABEL_5;
                  }
                }
                if ( (*(_BYTE *)(v14 + 48) & 1) == 0 )
                  break;
LABEL_45:
                if ( ++v13 >= *(_DWORD *)&parent->type )
                  goto LABEL_46;
              }
              if ( !assert_failed )
              {
                v30 = *(_DWORD *)(v14 + 16);
                assert_failed = v30 == 0;
                if ( !v30 )
                {
                  v62 = v13;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                  errline = 623;
                  elinks_internal("assertion selvalue->length failed!");
                  v13 = v62;
                }
              }
              s1 = (char *)v17->data.document.document;
              v48 = *(_DWORD *)(v14 + 16);
              if ( (unsigned int)s1 < v48 )
                goto LABEL_31;
              v69 = *(_DWORD *)(v14 + 48);
              if ( (v69 & 2) == 0 )
                break;
              if ( (int)s1 <= v48 )
                v48 = (signed int)v17->data.document.document;
              v63 = v13;
              v32 = c_strncasecmp((const char *)v17->data.document.children, *(const char **)(v14 + 20), v48);
              v33 = v63;
              if ( !v32 )
              {
                if ( v17->data.attribute.value.length != *(_DWORD *)(v14 + 16) )
                  goto LABEL_31;
                goto LABEL_69;
              }
LABEL_68:
              if ( v32 )
                goto LABEL_31;
LABEL_69:
              v13 = v33 + 1;
              if ( v13 >= *(_DWORD *)&parent->type )
              {
LABEL_46:
                v9 = v67;
                v4 = v72;
                goto LABEL_47;
              }
            }
            if ( (v69 & 0x10) != 0 )
            {
              s1a = (char *)v17->data.document.children;
              v31 = *(_DWORD *)(v14 + 16);
              if ( v48 != -1 )
              {
LABEL_64:
                if ( v31 <= v48 )
                  v48 = v31;
                v54 = v13;
                v32 = c_strncasecmp(s1a, *(const char **)(v14 + 20), v48);
                v33 = v54;
                if ( !v32 )
                  v32 = v31 - *(_DWORD *)(v14 + 16);
                goto LABEL_68;
              }
            }
            else
            {
              if ( (v69 & 0x20) == 0 )
              {
                v18 = (const char *)v17->data.document.children;
                if ( s1 == (char *)-1 )
                {
                  v64 = v13;
                  v51 = *(_DWORD *)(v14 + 16);
                  v47 = strlen(v18);
                  v48 = v51;
                  v13 = v64;
                  s1 = (char *)v47;
                }
                if ( (v69 & 4) != 0 )
                {
                  v68 = v14;
                  v19 = 1;
                  v20 = v48;
                  v65 = children;
                  v21 = (size_t)s1;
                  v66 = v13;
                  while ( 1 )
                  {
                    if ( !v19 || c_strncasecmp(v18, *(const char **)(v68 + 20), v20) )
                    {
                      v22 = __ctype_b_loc();
                      v20 = *(_DWORD *)(v68 + 16);
                      v23 = *v22;
                    }
                    else
                    {
                      v20 = *(_DWORD *)(v68 + 16);
                      if ( v20 == v21 || (v23 = *__ctype_b_loc(), (v23[(unsigned __int8)v18[v21]] & 0x2000) != 0) )
                      {
                        v13 = v66;
                        children = v65;
                        goto LABEL_45;
                      }
                    }
                    v24 = *(unsigned __int8 *)v18;
                    --v21;
                    ++v18;
                    v25 = v23[v24];
                    if ( v21 < v20 )
                      goto LABEL_31;
                    v19 = v25 & 0x2000;
                  }
                }
                v4 = v72;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
                errline = 668;
                elinks_internal("No attribute selector matching method defined");
LABEL_5:
                depth = v4->depth;
                goto LABEL_6;
              }
              v45 = v17->data.document.children;
              v31 = *(_DWORD *)(v14 + 16);
              s1a = &s1[(_DWORD)v45 - v48];
              if ( v48 != -1 )
                goto LABEL_64;
            }
            v61 = v13;
            v50 = *(_DWORD *)(v14 + 16);
            v46 = strlen(s1a);
            v48 = v50;
            v13 = v61;
            v31 = v46;
            goto LABEL_64;
          }
        }
LABEL_47:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
        errline = 918;
        v53 = v9;
        elinks_wdebug("Matched element: %.*s.", node->string.length, (const char *)node->string.string);
        v26 = v53->data.document.document;
        if ( !v26 )
          goto LABEL_5;
        v27 = 0;
        if ( !*(_DWORD *)v26 )
          goto LABEL_5;
        while ( 1 )
        {
          v28 = (_WORD *)*((_DWORD *)v26 + v27 + 1);
          if ( v28 )
          {
            if ( *v28 == 1 )
              break;
          }
          if ( *(_DWORD *)v26 <= (unsigned int)++v27 )
            goto LABEL_5;
        }
        push_dom_node(v4, *((dom_node **)v26 + v27 + 1));
        v5 = ++pos;
        if ( v4->depth <= pos )
          return 0;
      }
    }
    v56 = v9;
    v35 = dom_node_casecmp(v9, node);
    v9 = v56;
    if ( v35 )
      goto LABEL_5;
    document = v56[1].data.document.document;
    v71 = (unsigned __int8)document & 7;
    if ( ((unsigned __int8)document & 7) == 0 )
      goto LABEL_14;
    goto LABEL_75;
  }
  return 0;
}

//----- (080A3DC0) --------------------------------------------------------
int __usercall parse_dom_select_nth_arg@<eax>(dom_select_nth_match *nth@<eax>, dom_scanner *scanner@<edx>)
{
  int tokens; // eax
  dom_scanner_token *current; // ecx
  dom_scanner_token *v4; // ebx
  dom_scanner_token *v5; // eax
  int v6; // eax
  dom_scanner_token *v7; // ecx
  dom_scanner_token *v8; // eax
  dom_scanner_token *v9; // ebx
  int type; // eax
  dom_scanner_token *v12; // eax
  int v13; // eax
  int v14; // esi
  int v15; // edi
  unsigned __int8 *v16; // eax
  int v17; // edi
  int v18; // ecx
  dom_scanner_token *v20; // eax
  unsigned int length; // eax
  int v22; // eax
  dom_scanner_token *next_dom_scanner_token; // eax
  dom_scanner_token *v24; // eax
  unsigned int v25; // esi
  int v26; // ecx
  unsigned int i; // ebx
  dom_scanner_token *v28; // eax
  int v29; // eax
  dom_scanner *v30; // [esp+10h] [ebp-28h]
  dom_scanner *v31; // [esp+10h] [ebp-28h]
  dom_scanner *v32; // [esp+10h] [ebp-28h]
  dom_scanner *v33; // [esp+10h] [ebp-28h]
  dom_scanner *v34; // [esp+10h] [ebp-28h]
  dom_scanner *v35; // [esp+10h] [ebp-28h]
  dom_scanner *v36; // [esp+10h] [ebp-28h]
  unsigned __int8 v37; // [esp+18h] [ebp-20h]
  unsigned __int8 *string; // [esp+18h] [ebp-20h]

  tokens = scanner->tokens;
  if ( tokens <= 0 )
    return 12;
  current = scanner->current;
  v4 = &scanner->table[tokens];
  if ( current >= v4 )
    return 12;
  v5 = current + 1;
  scanner->current = current + 1;
  if ( &current[2] >= v4 )
  {
    v31 = scanner;
    v5 = scanner->info->scan(scanner);
    scanner = v31;
  }
  else if ( v5 >= v4 )
  {
    return 12;
  }
  if ( !v5 )
    return 12;
  if ( v5->type != 40 )
    return 12;
  v6 = scanner->tokens;
  if ( v6 <= 0 )
    return 12;
  v7 = scanner->current;
  v8 = &scanner->table[v6];
  if ( v7 >= v8 )
    return 12;
  v9 = v7 + 1;
  scanner->current = v7 + 1;
  if ( &v7[2] >= v8 )
  {
    v35 = scanner;
    v28 = scanner->info->scan(scanner);
    scanner = v35;
    v9 = v28;
  }
  else if ( v9 >= v8 )
  {
    return 12;
  }
  if ( !v9 )
    return 12;
  type = v9->type;
  if ( v9->type == 256 )
  {
    length = v9->string.length;
    if ( length == 4 )
    {
      v33 = scanner;
      v22 = c_strncasecmp((const char *)v9->string.string, "even", 4u);
      scanner = v33;
      if ( !v22 )
      {
        nth->step = 2;
        nth->index = 0;
        goto LABEL_21;
      }
      length = v9->string.length;
    }
    if ( length == 3 )
    {
      v36 = scanner;
      v29 = c_strncasecmp((const char *)v9->string.string, "odd", 3u);
      scanner = v36;
      if ( !v29 )
      {
        nth->step = 2;
        nth->index = 1;
        goto LABEL_21;
      }
    }
    v13 = v9->type;
    v14 = -1;
    v15 = 1;
LABEL_19:
    if ( v13 != 256 )
    {
      nth->step = 0;
      nth->index = v15 * v14;
      goto LABEL_21;
    }
    if ( v9->string.length == 1 )
    {
      v34 = scanner;
      if ( !c_strncasecmp((const char *)v9->string.string, "n", 1u) )
      {
        nth->step = v15 * v14;
        next_dom_scanner_token = get_next_dom_scanner_token(v34);
        scanner = v34;
        if ( next_dom_scanner_token )
        {
          if ( next_dom_scanner_token->type != 43 )
            goto LABEL_21;
          v24 = get_next_dom_scanner_token(v34);
          scanner = v34;
          if ( v24 )
          {
            if ( v24->type != 257 )
              goto LABEL_21;
            v25 = v24->string.length;
            v26 = 0;
            for ( i = v25; i; v24->string.length = i )
            {
              string = v24->string.string;
              if ( (unsigned __int8)(*string - 48) > 9u )
                break;
              if ( v26 > (unsigned int)(10 * v26) )
                return -995;
              v26 = 10 * v26 + *string - 48;
              v24->string.string = string + 1;
              i = v25 - 1;
              v25 = i;
            }
            if ( v26 >= 0 )
            {
              nth->index = v15 * v26;
LABEL_21:
              if ( skip_dom_scanner_tokens(scanner, 41, 128) )
                return 0;
              return 12;
            }
            return -995;
          }
        }
      }
    }
    return 12;
  }
  if ( type != 257 )
  {
    if ( type != 45 )
      return 12;
    v30 = scanner;
    v12 = get_next_dom_scanner_token(scanner);
    scanner = v30;
    v9 = v12;
    if ( !v12 )
      return 12;
    v13 = v12->type;
    v14 = -1;
    v15 = -1;
    if ( v13 == 256 )
      return 12;
    goto LABEL_19;
  }
  if ( v9->string.length && (v16 = v9->string.string, v17 = 0, (unsigned __int8)(*v16 - 48) <= 9u) )
  {
    v37 = *v16;
    while ( 1 )
    {
      v9->string.string = ++v16;
      v18 = v17 + v37 - 48;
      if ( v9->string.length-- == 1 )
        break;
      v37 = *v16;
      if ( (unsigned __int8)(*v16 - 48) > 9u )
        break;
      v17 = 10 * v18;
      if ( 10 * v18 < (unsigned int)v18 )
        return -995;
    }
    v14 = v18;
    if ( v18 < 0 )
      return -995;
  }
  else
  {
    v14 = 0;
  }
  v32 = scanner;
  v20 = get_next_dom_scanner_token(scanner);
  scanner = v32;
  v9 = v20;
  if ( v20 )
  {
    v13 = v20->type;
    v15 = 1;
    goto LABEL_19;
  }
  return 12;
}

//----- (080A4130) --------------------------------------------------------
dom_code __usercall parse_dom_select@<eax>(dom_select *select@<eax>, dom_stack *stack@<edx>, dom_string *string@<ecx>)
{
  dom_scanner_token *current; // edi
  int type; // eax
  dom_code result; // eax
  dom_scanner_token *v6; // edi
  dom_scanner_token *v7; // eax
  dom_scanner_token *v8; // edx
  dom_scanner_token *v9; // edx
  dom_scanner_token *v10; // eax
  dom_select_node *v11; // edi
  dom_stack_state *states; // edx
  size_t depth; // ecx
  bool v14; // zf
  unsigned int v15; // eax
  unsigned __int8 *v16; // edx
  dom_scanner_token *v17; // edi
  dom_scanner_token *v18; // edx
  dom_scanner_token *v19; // ecx
  unsigned int v20; // eax
  dom_node_list *v21; // edx
  dom_scanner_token *v22; // eax
  dom_scanner_token *v23; // edx
  dom_scanner_token *v24; // ecx
  unsigned int length; // eax
  unsigned __int8 *v26; // edx
  dom_scanner_token *next_dom_scanner_token; // eax
  int v28; // eax
  dom_scanner_token *v29; // eax
  unsigned int v30; // edx
  dom_node_list *v31; // eax
  dom_scanner_token *v32; // eax
  dom_scanner_token *v33; // eax
  int v34; // ecx
  const char **v35; // edi
  dom_scanner_token *v36; // edx
  size_t v37; // eax
  int v38; // eax
  unsigned int v39; // eax
  unsigned __int16 *p_type; // edx
  unsigned __int16 v41; // cx
  dom_node_list **v42; // ecx
  dom_node_list *v43; // eax
  int dom_node_map_index; // eax
  int v45; // [esp+28h] [ebp-170h]
  int v46; // [esp+38h] [ebp-160h]
  dom_node_list **v47; // [esp+38h] [ebp-160h]
  dom_scanner_token *v48; // [esp+3Ch] [ebp-15Ch]
  dom_node *v49; // [esp+3Ch] [ebp-15Ch]
  unsigned __int16 *v50; // [esp+3Ch] [ebp-15Ch]
  unsigned __int16 *v51; // [esp+3Ch] [ebp-15Ch]
  uint16_t v52; // [esp+46h] [ebp-152h]
  dom_scanner scanner; // [esp+58h] [ebp-140h] BYREF
  dom_select_node sel; // [esp+14Ch] [ebp-4Ch] BYREF

  init_dom_scanner(&scanner, &dom_css_scanner_info, string, 0, 0, 1, 0, 0);
  memset(&sel, 0, sizeof(sel));
  while ( 1 )
  {
    if ( scanner.tokens <= 0 )
      return select->selector == 0 ? 0xFFFFFC18 : 0;
    current = scanner.current;
    if ( scanner.current >= &scanner.table[scanner.tokens] )
      return select->selector == 0 ? 0xFFFFFC18 : 0;
    if ( scanner.current >= &scanner.table[scanner.tokens] )
      current = 0;
    if ( !assert_failed )
    {
      assert_failed = current == 0;
      if ( !current )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
        errline = 403;
        elinks_internal("assertion token failed!");
      }
    }
    type = current->type;
    if ( current->type == 125 || type == 123 || type == 59 || type == 44 )
      return select->selector == 0 ? 0xFFFFFC18 : 0;
    if ( type != 91 )
      break;
    sel.node.type = 2;
    if ( scanner.tokens <= 0 || scanner.current >= &scanner.table[scanner.tokens] )
    {
      if ( MEMORY[0] != 91 )
        return 12;
    }
    else if ( scanner.current->type != 91 )
    {
      return 12;
    }
    if ( scanner.tokens <= 0 )
      return 12;
    v22 = &scanner.table[scanner.tokens];
    if ( scanner.current >= v22 )
      return 12;
    v23 = scanner.current + 1;
    v24 = scanner.current + 2;
    ++scanner.current;
    if ( v24 >= v22 )
    {
      v23 = scanner.info->scan(&scanner);
    }
    else if ( v23 >= v22 )
    {
      return 12;
    }
    if ( !v23 || v23->type != 256 )
      return 12;
    length = v23->string.length;
    v26 = v23->string.string;
    sel.node.string.string = v26;
    if ( length == -1 )
      length = strlen((const char *)v26);
    sel.node.string.length = length;
    next_dom_scanner_token = get_next_dom_scanner_token(&scanner);
    if ( !next_dom_scanner_token )
      return 12;
    v28 = next_dom_scanner_token->type;
    if ( v28 == 280 )
    {
      sel.match.element |= 8u;
      goto LABEL_86;
    }
    if ( v28 > 280 )
    {
      if ( v28 == 282 )
      {
        sel.match.element |= 0x20u;
      }
      else if ( v28 < 282 )
      {
        sel.match.element |= 0x10u;
      }
      else
      {
        if ( v28 != 283 )
          return 12;
        sel.match.element |= 0x40u;
      }
LABEL_86:
      v29 = get_next_dom_scanner_token(&scanner);
      if ( !v29 || v29->type != 256 && v29->type != 259 )
        return 12;
      v30 = v29->string.length;
      v31 = (dom_node_list *)v29->string.string;
      sel.node.data.document.children = v31;
      if ( v30 == -1 )
        v30 = strlen((const char *)v31);
      sel.node.data.attribute.value.length = v30;
      v32 = get_next_dom_scanner_token(&scanner);
      if ( !v32 || v32->type != 93 )
        return 12;
      goto LABEL_38;
    }
    if ( v28 != 93 )
    {
      if ( v28 != 279 )
        return 12;
      sel.match.element |= 4u;
      goto LABEL_86;
    }
    sel.match.element |= 1u;
LABEL_38:
    if ( scanner.tokens > 0 )
    {
      v9 = &scanner.table[scanner.tokens];
      if ( scanner.current < v9 )
      {
        v10 = scanner.current + 2;
        ++scanner.current;
        if ( v10 >= v9 )
          scanner.info->scan(&scanner);
      }
    }
    if ( sel.node.type )
    {
      v11 = (dom_select_node *)mem_calloc(1u, 0x34u);
      *v11 = sel;
      states = stack->states;
      if ( !stack->states || (depth = stack->depth) == 0 )
      {
        if ( !assert_failed )
        {
          v14 = select->selector == 0;
          assert_failed = select->selector != 0;
          if ( !v14 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
            errline = 505;
            elinks_internal("assertion !select->selector failed!");
          }
        }
        select->selector = v11;
        goto LABEL_49;
      }
      v45 = assert_failed;
      if ( !assert_failed )
      {
        assert_failed = 0;
        states = stack->states;
        depth = stack->depth;
      }
      p_type = &states[depth - 1].node->type;
      v52 = v11->node.type;
      v41 = *p_type;
      if ( *p_type == 7 )
      {
        v42 = (dom_node_list **)(p_type + 14);
        if ( v52 != 2 )
          goto LABEL_116;
      }
      else
      {
        if ( v41 <= 7u )
        {
          if ( v41 == 1 )
          {
            v42 = (dom_node_list **)(p_type + 8);
            if ( v52 == 2 )
              v42 = (dom_node_list **)(p_type + 10);
            goto LABEL_117;
          }
LABEL_116:
          v42 = 0;
          goto LABEL_117;
        }
        if ( v41 == 9 )
          goto LABEL_135;
        if ( v41 != 10 )
          goto LABEL_116;
        v42 = (dom_node_list **)(p_type + 8);
        if ( v52 != 6 )
        {
          if ( v52 != 12 )
            goto LABEL_116;
LABEL_135:
          v42 = (dom_node_list **)(p_type + 10);
        }
      }
LABEL_117:
      if ( !v45 )
      {
        assert_failed = v42 == 0;
        if ( !v42 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/select.c";
          errline = 492;
          v51 = p_type;
          elinks_internal(
            "assertion list != NULL failed: Adding node to bad parent [%d -> %d]",
            v11->node.type,
            *p_type);
          v42 = 0;
          p_type = v51;
        }
      }
      v43 = *v42;
      if ( *v42 && v52 == 2 && v43->size )
      {
        v50 = p_type;
        v47 = v42;
        dom_node_map_index = get_dom_node_map_index(v43, &v11->node);
        p_type = v50;
        v42 = v47;
      }
      else
      {
        dom_node_map_index = -1;
      }
      v49 = (dom_node *)p_type;
      if ( !add_to_dom_node_list(v42, &v11->node, dom_node_map_index) )
      {
        done_dom_node(&v11->node);
        return -997;
      }
      v11->node.parent = v49;
LABEL_49:
      result = push_dom_node(stack, &v11->node);
      if ( result )
        return result;
      if ( v11->node.type != 1 )
        pop_dom_node(stack);
      memset(&sel, 0, sizeof(sel));
    }
  }
  if ( type > 91 )
  {
    if ( type == 256 )
    {
      sel.node.type = 1;
      v15 = current->string.length;
      v16 = current->string.string;
      sel.node.string.string = v16;
      if ( v15 == -1 )
        v15 = strlen((const char *)v16);
      sel.node.string.length = v15;
      if ( current->string.length == 1 && !c_strncasecmp((const char *)current->string.string, "*", 1u) )
        sel.match.element |= 8u;
    }
    else if ( type > 256 )
    {
      if ( (unsigned int)(type - 267) > 1 )
        return 12;
      sel.match.element |= 0x80u;
      sel.node.type = 2;
      ++current->string.string;
      --current->string.length;
    }
    else
    {
      if ( type != 126 || (sel.match.element & 7) != 0 )
        return 12;
      sel.match.element |= 4u;
    }
    goto LABEL_38;
  }
  if ( type == 46 )
  {
    if ( scanner.tokens <= 0 )
      return 12;
    v17 = &scanner.table[scanner.tokens];
    if ( scanner.current >= v17 )
      return 12;
    v18 = scanner.current + 1;
    v19 = scanner.current + 2;
    ++scanner.current;
    if ( v19 >= v17 )
    {
      v18 = scanner.info->scan(&scanner);
    }
    else if ( v18 >= &scanner.table[scanner.tokens] )
    {
      return 12;
    }
    if ( !v18 || v18->type != 256 )
      return 12;
    sel.match.element |= 4u;
    sel.node.type = 2;
    sel.node.string.string = "class";
    sel.node.string.length = 5;
    v20 = v18->string.length;
    v21 = (dom_node_list *)v18->string.string;
    sel.node.data.document.children = v21;
    if ( v20 == -1 )
      v20 = strlen((const char *)v21);
    sel.node.data.attribute.value.length = v20;
    goto LABEL_38;
  }
  if ( type <= 46 )
  {
    if ( type != 43 || (sel.match.element & 7) != 0 )
      return 12;
    sel.match.element |= 2u;
    goto LABEL_38;
  }
  if ( type != 58 )
  {
    if ( type != 62 || (sel.match.element & 7) != 0 )
      return 12;
    sel.match.element |= 1u;
    goto LABEL_38;
  }
  do
  {
    if ( scanner.tokens > 0 )
    {
      v8 = &scanner.table[scanner.tokens];
      if ( scanner.current < v8 )
      {
        v6 = scanner.current + 1;
        v7 = scanner.current + 2;
        ++scanner.current;
        if ( v7 >= v8 )
        {
          v6 = scanner.info->scan(&scanner);
        }
        else if ( v6 >= v8 )
        {
          return 12;
        }
        if ( v6 )
          continue;
      }
    }
    return 12;
  }
  while ( v6->type == 58 );
  if ( v6->type != 256 )
    return 12;
  v33 = v6;
  v34 = 0;
  v35 = (const char **)&pseudo_info_4973;
  v36 = v33;
  while ( 1 )
  {
    v37 = (size_t)*v35;
    if ( (int)*v35 > (signed int)v36->string.length )
      v37 = v36->string.length;
    v48 = v36;
    v46 = v34;
    v38 = c_strncasecmp(v35[1], (const char *)v36->string.string, v37);
    v36 = v48;
    if ( !v38 && *v35 == (const char *)v48->string.length )
      break;
    v34 = v46 + 1;
    v35 += 3;
    if ( v46 == 27 )
      return -1000;
  }
  v39 = dword_8141AA8[3 * v46];
  if ( v39 == 10005 )
  {
    sel.match.element |= 0x40u;
    sel.nth_child.step = 0;
    sel.nth_child.index = 0;
    goto LABEL_38;
  }
  if ( v39 > 0x2715 )
  {
    if ( v39 == 10009 )
    {
      sel.match.element |= 0x80u;
      sel.nth_type.step = 0;
      sel.nth_type.index = -1;
    }
    else if ( v39 > 0x2719 )
    {
      if ( v39 == 10011 )
      {
        sel.match.element |= 0x10u;
      }
      else if ( v39 < 0x271B )
      {
        sel.match.element |= 0x80u;
        sel.nth_type.step = 0;
        sel.nth_type.index = 0;
      }
      else
      {
        if ( v39 != 10012 )
          goto LABEL_110;
        sel.match.element |= 0x20u;
      }
    }
    else if ( v39 > 0x2717 )
    {
      sel.match.element |= 0x80u;
      sel.nth_type.step = 0;
      sel.nth_type.index = 1;
    }
    else
    {
      result = parse_dom_select_nth_arg(&sel.nth_type, &scanner);
      if ( result )
        return result;
      sel.match.element |= 0x80u;
    }
    goto LABEL_38;
  }
  if ( v39 > 0x2712 )
  {
    sel.match.element |= 0x40u;
    sel.nth_child.step = 0;
    if ( v39 == 10003 )
      sel.nth_child.index = 1;
    else
      sel.nth_child.index = -1;
    goto LABEL_38;
  }
  if ( v39 >= 0x2711 )
  {
    result = parse_dom_select_nth_arg(&sel.nth_child, &scanner);
    if ( result )
      return result;
    sel.match.element |= 0x40u;
    goto LABEL_38;
  }
  if ( v39 )
  {
    if ( v39 == 10000 )
      goto LABEL_38;
LABEL_110:
    select->pseudo |= v39;
    goto LABEL_38;
  }
  return -1000;
}
// 80A4519: conditional instruction was optimized away because %scanner@16.4>=1
// 80A4AB7: conditional instruction was optimized away because eax.4==2714
// 8141AA8: using guessed type int dword_8141AA8[86];

//----- (080A4BA0) --------------------------------------------------------
dom_select *__cdecl init_dom_select(dom_select_syntax syntax, dom_string *string)
{
  dom_select *v2; // esi
  dom_code v3; // edi
  dom_select *v5; // [esp+0h] [ebp-48h]
  dom_stack stack; // [esp+18h] [ebp-30h] BYREF

  v2 = (dom_select *)mem_calloc(1u, 4u);
  init_dom_stack(&stack, DOM_STACK_FLAG_NONE);
  v3 = parse_dom_select(v2, &stack, string);
  done_dom_stack(&stack);
  if ( v3 )
  {
    v5 = v2;
    v2 = 0;
    done_dom_select(v5);
  }
  return v2;
}

//----- (080A4C20) --------------------------------------------------------
dom_stack_state *__cdecl search_dom_stack(dom_stack *stack, dom_node_type type, dom_string *string)
{
  size_t i; // ebx
  dom_stack_state *v5; // edi
  dom_node *node; // esi
  unsigned int length; // eax
  int v8; // eax
  dom_string *v10; // [esp+18h] [ebp-20h]
  int pos; // [esp+1Ch] [ebp-1Ch]

  pos = stack->depth - 1;
  if ( pos < 0 )
    return 0;
  for ( i = 12 * stack->depth - 12; ; i -= 12 )
  {
    v5 = (dom_stack_state *)((char *)stack->states + i);
    if ( v5 )
    {
      node = v5->node;
      if ( v5->node->type == type )
      {
        length = string->length;
        if ( (signed int)node->string.length <= (signed int)string->length )
          length = node->string.length;
        v10 = string;
        v8 = c_strncasecmp((const char *)node->string.string, (const char *)string->string, length);
        string = v10;
        if ( !v8 && node->string.length == v10->length )
          break;
      }
    }
    if ( --pos < 0 )
      return 0;
  }
  return v5;
}

//----- (080A4CB0) --------------------------------------------------------
void __cdecl init_dom_stack(dom_stack *stack, dom_stack_flag flags)
{
  unsigned int i; // eax

  if ( !assert_failed )
  {
    assert_failed = stack == 0;
    if ( !stack )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 56;
      elinks_internal("assertion stack failed!");
    }
  }
  for ( i = 0; i < 0x18; i += 4 )
    *(dom_stack_state **)((char *)&stack->states + i) = 0;
  stack->flags = flags;
}

//----- (080A4D20) --------------------------------------------------------
void __cdecl done_dom_stack(dom_stack *stack)
{
  size_t v1; // edi
  size_t v2; // ebx
  dom_stack_context *v3; // eax
  unsigned int i; // eax

  if ( !assert_failed )
  {
    assert_failed = stack == 0;
    if ( !stack )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 68;
      elinks_internal("assertion stack failed!");
    }
  }
  if ( stack->contexts_size )
  {
    v1 = 0;
    v2 = 0;
    do
    {
      v3 = stack->contexts[v1];
      if ( v3->state_objects )
      {
        mem_free(v3->state_objects);
        v3 = stack->contexts[v1];
      }
      v1 = ++v2;
      mem_free(v3);
    }
    while ( stack->contexts_size > v2 );
  }
  if ( stack->contexts )
    mem_free(stack->contexts);
  if ( stack->states )
    mem_free(stack->states);
  for ( i = 0; i < 0x18; i += 4 )
    *(dom_stack_state **)((char *)&stack->states + i) = 0;
}

//----- (080A4DF0) --------------------------------------------------------
void __cdecl done_dom_stack_context(dom_stack *stack, dom_stack_context *context)
{
  size_t contexts_size; // eax
  dom_stack_context **contexts; // edx
  size_t v4; // ecx
  int v5; // eax
  dom_stack_context **v6; // edx
  dom_stack_context *v7; // ebx
  int v8; // edi
  size_t v9; // [esp+1Ch] [ebp-1Ch]

  if ( context->state_objects )
    mem_free(context->state_objects);
  mem_free(context);
  contexts_size = stack->contexts_size;
  v9 = contexts_size - 1;
  contexts = stack->contexts;
  v4 = contexts_size - 1;
  if ( contexts[contexts_size - 1] == context )
  {
    stack->contexts_size = v9;
  }
  else
  {
    v5 = 4 * contexts_size - 8;
    v6 = (dom_stack_context **)((char *)contexts + v5);
    do
    {
      v7 = *v6;
      --v4;
      --v6;
      v8 = v5;
      v5 -= 4;
    }
    while ( v7 != context );
    stack->contexts_size = v9;
    if ( v9 > v4 )
      memmove((char *)stack->contexts + v8, (char *)stack->contexts + v8 + 4, 4 * (v9 - v4));
  }
}

//----- (080A4EA0) --------------------------------------------------------
int __usercall call_dom_stack_callbacks@<eax>(
        dom_stack *stack@<eax>,
        dom_stack_state *state@<edx>,
        dom_stack_action action@<ecx>)
{
  size_t v5; // eax
  size_t v6; // edi
  bool v7; // zf
  dom_stack_context_info *info; // ecx
  int (__cdecl *v9)(_DWORD, _DWORD, _DWORD); // edx
  unsigned int v10; // ecx
  int v11; // eax
  int v12; // eax
  dom_stack_context *v14; // eax
  int (__cdecl *v15)(_DWORD, _DWORD, _DWORD); // [esp+1Ch] [ebp-2Ch]
  dom_stack_context *v16; // [esp+20h] [ebp-28h]
  dom_stack_context *v17; // [esp+20h] [ebp-28h]
  size_t object_size; // [esp+28h] [ebp-20h]
  int free_node; // [esp+2Ch] [ebp-1Ch]

  free_node = 0;
  if ( stack->contexts_size )
  {
    v5 = 0;
    v6 = 0;
    while ( 1 )
    {
      v14 = stack->contexts[v5];
      if ( assert_failed )
        break;
      v7 = state->node->type <= 0xCu;
      assert_failed = state->node->type > 0xCu;
      if ( !v7 )
      {
        v16 = v14;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
        errline = 142;
        elinks_internal("assertion state->node->type < DOM_NODES failed!");
        v14 = v16;
        if ( assert_failed )
          break;
      }
      info = v14->info;
      if ( action )
        v9 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))info->pop[state->node->type];
      else
        v9 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))info->push[state->node->type];
      if ( v9 )
      {
        object_size = info->object_size;
        v10 = 0;
        if ( object_size )
        {
          v7 = v14->state_objects != 0;
          assert_failed = v14->state_objects == 0;
          if ( !v7 )
          {
            v17 = v14;
            v15 = v9;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
            errline = 198;
            elinks_internal("assertion context->state_objects failed!");
            v9 = v15;
            v14 = v17;
          }
          v10 = (unsigned int)&v14->state_objects[state->depth * object_size];
        }
        stack->current = v14;
        v11 = v9(stack, state->node, v10);
        stack->current = 0;
        v7 = v11 == -998;
        v12 = 1;
        if ( !v7 )
          v12 = free_node;
        free_node = v12;
      }
      v5 = ++v6;
      if ( stack->contexts_size <= v6 )
        return free_node;
    }
    assert_failed = 0;
    return 0;
  }
  return free_node;
}

//----- (080A5020) --------------------------------------------------------
void __cdecl pop_dom_node(dom_stack *stack)
{
  dom_stack_state *states; // edx
  size_t depth; // eax
  int v3; // eax
  dom_node **v4; // esi
  size_t contexts_size; // eax
  size_t v6; // eax
  size_t v7; // edi
  dom_stack_context *v8; // edx
  size_t object_size; // eax
  size_t v10; // ecx
  bool v11; // zf
  dom_stack_context *v12; // [esp+18h] [ebp-20h]
  size_t v13; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    assert_failed = stack == 0;
    if ( !stack )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 224;
      elinks_internal("assertion stack failed!");
    }
  }
  states = stack->states;
  if ( stack->states )
  {
    depth = stack->depth;
    if ( depth )
    {
      if ( !assert_failed )
      {
        assert_failed = 0;
        states = stack->states;
        depth = stack->depth;
      }
      v3 = 3 * depth - 3;
      v4 = &states->node + v3;
      if ( ((_BYTE)v4[2] & 1) == 0 )
      {
        if ( call_dom_stack_callbacks(stack, (dom_stack_state *)((char *)states + 4 * v3), DOM_STACK_POP)
          || (stack->flags & 1) != 0 )
        {
          done_dom_node(*v4);
        }
        contexts_size = stack->contexts_size;
        --stack->depth;
        if ( contexts_size )
        {
          v6 = 0;
          v7 = 0;
          do
          {
            while ( 1 )
            {
              v8 = stack->contexts[v6];
              object_size = v8->info->object_size;
              if ( object_size )
                break;
              v6 = ++v7;
              if ( stack->contexts_size <= v7 )
                goto LABEL_21;
            }
            v10 = v8->info->object_size;
            if ( !assert_failed )
            {
              v11 = v8->state_objects != 0;
              assert_failed = v8->state_objects == 0;
              if ( v11 )
              {
                v10 = v8->info->object_size;
              }
              else
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                errline = 198;
                v13 = object_size;
                v12 = v8;
                elinks_internal("assertion context->state_objects failed!");
                v8 = v12;
                object_size = v13;
                v10 = v12->info->object_size;
              }
            }
            ++v7;
            memset(&v8->state_objects[(_DWORD)v4[1] * object_size], 0, v10);
            v6 = v7;
          }
          while ( stack->contexts_size > v7 );
        }
LABEL_21:
        *v4 = 0;
        v4[1] = 0;
        v4[2] = 0;
      }
    }
  }
}

//----- (080A51B0) --------------------------------------------------------
void __cdecl pop_dom_state(dom_stack *stack, dom_stack_state *target)
{
  dom_stack_state *states; // eax
  size_t depth; // edx
  int i; // ebx
  dom_stack_state *v5; // esi

  if ( !assert_failed )
  {
    assert_failed = stack == 0;
    if ( !stack )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 274;
      elinks_internal("assertion stack failed!");
    }
  }
  if ( target )
  {
    states = stack->states;
    if ( stack->states )
    {
      depth = stack->depth;
      if ( depth )
      {
        for ( i = 12 * depth - 12; ; i -= 12 )
        {
          v5 = (dom_stack_state *)((char *)states + i);
          if ( (dom_stack_state *)((char *)states + i) )
          {
            if ( (*((_BYTE *)v5 + 8) & 1) != 0 )
              return;
            pop_dom_node(stack);
            if ( v5 == target )
              return;
            states = stack->states;
          }
        }
      }
    }
  }
}

//----- (080A5250) --------------------------------------------------------
void __cdecl pop_dom_nodes(dom_stack *stack, dom_node_type type, dom_string *string)
{
  dom_stack_state *v3; // eax

  if ( !assert_failed )
  {
    assert_failed = stack == 0;
    if ( !stack )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 259;
      elinks_internal("assertion stack failed!");
    }
  }
  if ( stack->states && stack->depth )
  {
    v3 = search_dom_stack(stack, type, string);
    if ( v3 )
      pop_dom_state(stack, v3);
  }
}

//----- (080A5300) --------------------------------------------------------
dom_code __cdecl push_dom_node(dom_stack *stack, dom_node *node)
{
  bool v2; // zf
  size_t depth; // esi
  dom_code result; // eax
  unsigned int v5; // eax
  unsigned int v6; // esi
  size_t v7; // ecx
  size_t v8; // eax
  size_t v9; // esi
  dom_stack_context *v10; // edi
  size_t object_size; // edx
  unsigned int v12; // eax
  unsigned int v13; // ecx
  dom_stack_state *v14; // edx
  unsigned __int8 *v15; // eax
  int v16; // edi
  dom_stack_state *v17; // eax
  size_t v18; // [esp+1Ch] [ebp-2Ch]
  unsigned int v19; // [esp+20h] [ebp-28h]
  int v20; // [esp+24h] [ebp-24h]
  size_t v21; // [esp+28h] [ebp-20h]
  dom_stack_state *states; // [esp+2Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    assert_failed = stack == 0 || node == 0;
    if ( stack != 0 && node != 0
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c",
          errline = 182,
          elinks_internal("assertion stack && node failed!"),
          !assert_failed) )
    {
      v2 = (unsigned __int16)(node->type - 1) <= 0xBu;
      assert_failed = (unsigned __int16)(node->type - 1) > 0xBu;
      if ( !v2 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
        errline = 183;
        elinks_internal("assertion 0 < node->type && node->type < DOM_NODES failed!");
      }
    }
  }
  depth = stack->depth;
  result = DOM_CODE_MAX_DEPTH_ERR;
  if ( depth > 0x1000 )
    return result;
  v5 = (depth + 8) & 0xFFFFFFF8;
  v6 = (depth + 7) & 0xFFFFFFF8;
  if ( v5 > v6 )
  {
    v16 = 12 * v5;
    v17 = (dom_stack_state *)mem_realloc(stack->states, 12 * v5);
    if ( !v17 )
      goto LABEL_23;
    stack->states = v17;
    memset(&v17[v6], 0, v16 - 12 * v6);
  }
  states = stack->states;
  if ( !stack->states )
  {
LABEL_23:
    done_dom_node(node);
    return -997;
  }
  v7 = stack->depth;
  v21 = v7;
  if ( stack->contexts_size )
  {
    v8 = 0;
    v9 = 0;
    do
    {
      while ( 1 )
      {
        v10 = stack->contexts[v8];
        object_size = v10->info->object_size;
        if ( object_size )
          break;
        v8 = ++v9;
        if ( stack->contexts_size <= v9 )
          goto LABEL_15;
      }
      v12 = (v7 + 8) & 0xFFFFFFF8;
      v13 = (v7 + 7) & 0xFFFFFFF8;
      if ( v12 > v13 )
      {
        v20 = object_size * v12;
        v18 = v10->info->object_size;
        v19 = v13;
        v15 = (unsigned __int8 *)mem_realloc(v10->state_objects, object_size * v12);
        if ( !v15 )
          goto LABEL_23;
        v10->state_objects = v15;
        memset(&v15[v19 * v18], 0, v20 - v19 * v18);
      }
      if ( !v10->state_objects )
        goto LABEL_23;
      ++v9;
      v7 = stack->depth;
      v8 = v9;
    }
    while ( stack->contexts_size > v9 );
  }
LABEL_15:
  v14 = &states[v21];
  v14->depth = v7;
  v14->node = node;
  ++stack->depth;
  call_dom_stack_callbacks(stack, v14, DOM_STACK_PUSH);
  return 0;
}

//----- (080A5530) --------------------------------------------------------
dom_stack_context *__cdecl add_dom_stack_context(dom_stack *stack, void *data, dom_stack_context_info *context_info)
{
  size_t contexts_size; // ebx
  unsigned int v4; // edi
  unsigned int v5; // ebx
  dom_stack_context *result; // eax
  size_t v7; // edx
  size_t v8; // edi
  dom_stack_context **v9; // eax

  contexts_size = stack->contexts_size;
  v4 = (contexts_size + 8) & 0xFFFFFFF8;
  v5 = (contexts_size + 7) & 0xFFFFFFF8;
  if ( v4 > v5 )
  {
    v8 = 4 * v4;
    v9 = (dom_stack_context **)mem_realloc(stack->contexts, v8);
    if ( !v9 )
      return 0;
    stack->contexts = v9;
    memset(&v9[v5], 0, v8 - 4 * v5);
  }
  if ( !stack->contexts )
    return 0;
  result = (dom_stack_context *)mem_calloc(1u, 0xCu);
  if ( result )
  {
    v7 = stack->contexts_size;
    stack->contexts[v7] = result;
    stack->contexts_size = v7 + 1;
    result->info = context_info;
    result->data = data;
  }
  return result;
}

//----- (080A55F0) --------------------------------------------------------
void __cdecl walk_dom_nodes(dom_stack *stack, dom_node *root)
{
  dom_stack_context *v2; // esi
  dom_stack_state *states; // edx
  size_t depth; // eax
  dom_stack_state *v5; // edi
  size_t object_size; // edx
  int v7; // eax
  unsigned __int8 *state_objects; // ecx
  dom_document *v9; // edx
  uint16_t type; // di
  dom_document *string; // ecx
  unsigned int v12; // ecx
  dom_node *v13; // edx
  dom_node *node; // [esp+1Ch] [ebp-3Ch]
  dom_node_list *v15; // [esp+2Ch] [ebp-2Ch]
  dom_document *document; // [esp+2Ch] [ebp-2Ch]
  size_t v17; // [esp+38h] [ebp-20h]
  dom_node_list *children; // [esp+3Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    assert_failed = stack == 0 || root == 0;
    if ( stack == 0 || root == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.c";
      errline = 364;
      elinks_internal("assertion root && stack failed!");
    }
  }
  v2 = add_dom_stack_context(stack, 0, &dom_stack_walk_context_info);
  if ( v2 && push_dom_node(stack, root) == DOM_CODE_OK )
  {
LABEL_6:
    states = stack->states;
    if ( stack->states )
    {
      while ( 1 )
      {
        depth = stack->depth;
        if ( !depth )
          goto LABEL_25;
        if ( !assert_failed )
        {
          assert_failed = 0;
          states = stack->states;
          depth = stack->depth;
        }
        v5 = &states[depth - 1];
        object_size = v2->info->object_size;
        v7 = 0;
        if ( object_size )
        {
          if ( !assert_failed )
          {
            state_objects = v2->state_objects;
            assert_failed = state_objects == 0;
            if ( !state_objects )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
              errline = 198;
              v17 = object_size;
              elinks_internal("assertion context->state_objects failed!");
              object_size = v17;
            }
          }
          v7 = (int)&v2->state_objects[object_size * v5->depth];
        }
        v9 = *(dom_document **)v7;
        node = v5->node;
        type = v5->node->type;
        if ( type == 7 )
        {
          if ( v9 )
            goto LABEL_23;
          string = (dom_document *)node->data.notation.system_id.string;
          goto LABEL_19;
        }
        if ( type <= 7u )
          break;
        if ( type != 9 )
        {
          if ( type == 10 )
          {
            document = *(dom_document **)v7;
            if ( !v9 )
              document = node->data.document.document;
            children = node->data.document.children;
            if ( children != (dom_node_list *)document && document && *(_DWORD *)(v7 + 4) < *(_DWORD *)document )
            {
              string = node->data.document.document;
              if ( string != document )
                string = (dom_document *)node->data.document.children;
              goto LABEL_19;
            }
LABEL_32:
            string = (dom_document *)children;
            goto LABEL_19;
          }
          goto LABEL_18;
        }
        if ( v9 )
          goto LABEL_23;
        string = (dom_document *)node->data.document.children;
LABEL_19:
        if ( string != v9 )
        {
          *(_DWORD *)v7 = string;
          *(_DWORD *)(v7 + 4) = 0;
        }
        if ( !string )
          goto LABEL_24;
        v9 = string;
LABEL_23:
        v12 = *(_DWORD *)(v7 + 4);
        if ( v12 < *(_DWORD *)v9 )
        {
          v13 = (dom_node *)*((_DWORD *)v9 + v12 + 1);
          *(_DWORD *)(v7 + 4) = v12 + 1;
          if ( push_dom_node(stack, v13) == DOM_CODE_OK )
            goto LABEL_6;
        }
LABEL_24:
        pop_dom_node(stack);
        states = stack->states;
        if ( !stack->states )
          goto LABEL_25;
      }
      if ( type == 1 )
      {
        v15 = *(dom_node_list **)v7;
        if ( !v9 )
          v15 = node->data.document.children;
        children = node->data.document_type.entities;
        if ( children != v15 )
        {
          if ( v15 )
          {
            if ( *(_DWORD *)(v7 + 4) < v15->size )
            {
              string = (dom_document *)node->data.document.children;
              if ( string == (dom_document *)v15 )
                goto LABEL_19;
            }
          }
        }
        goto LABEL_32;
      }
LABEL_18:
      string = *(dom_document **)v7;
      goto LABEL_19;
    }
LABEL_25:
    done_dom_stack_context(stack, v2);
  }
}

//----- (080A58A0) --------------------------------------------------------
dom_scanner_token *__cdecl scan_css_tokens_0(dom_scanner *scanner)
{
  dom_scanner *v1; // edi
  dom_scanner_token *v2; // eax
  dom_scanner_token *table; // edx
  int tokens; // ebx
  size_t v5; // eax
  unsigned __int8 *position; // ebx
  unsigned __int8 v7; // dl
  int v8; // eax
  unsigned __int8 *v9; // ecx
  int v10; // eax
  bool v11; // cf
  int v12; // edx
  dom_scanner_token *result; // eax
  unsigned __int8 *v14; // esi
  int v15; // ecx
  int v16; // ebx
  unsigned __int8 *v17; // ecx
  int v18; // eax
  unsigned __int8 *v19; // edx
  int v20; // ecx
  int v21; // eax
  dom_scanner_token *v22; // ecx
  unsigned __int8 v23; // al
  int v24; // eax
  unsigned __int8 *v25; // edx
  unsigned int v26; // ecx
  char *v27; // eax
  int v28; // eax
  int v29; // eax
  unsigned __int8 *v30; // ebx
  unsigned __int8 v31; // cl
  unsigned __int8 *v32; // edi
  unsigned __int8 *v33; // edx
  int v34; // eax
  unsigned int v35; // eax
  unsigned __int8 *v36; // edx
  unsigned __int8 *v37; // esi
  char *v38; // eax
  int v39; // eax
  unsigned __int8 *v40; // ecx
  int v41; // eax
  unsigned __int8 *v42; // edx
  unsigned int v43; // eax
  unsigned __int8 v44; // al
  unsigned int v45; // eax
  const char *v46; // edx
  int v47; // eax
  unsigned __int8 *v48; // eax
  _BYTE *j; // ebx
  unsigned __int8 *v50; // esi
  unsigned __int8 *i; // ecx
  unsigned __int8 *v52; // eax
  int v53; // [esp+Ch] [ebp-4Ch]
  int v54; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *v55; // [esp+20h] [ebp-38h]
  dom_scanner_token *v56; // [esp+20h] [ebp-38h]
  unsigned __int8 *v57; // [esp+20h] [ebp-38h]
  int v58; // [esp+20h] [ebp-38h]
  const char *v59; // [esp+20h] [ebp-38h]
  int v60; // [esp+20h] [ebp-38h]
  int v61; // [esp+20h] [ebp-38h]
  int v62; // [esp+20h] [ebp-38h]
  unsigned __int8 *ident; // [esp+24h] [ebp-34h]
  unsigned __int8 *identa; // [esp+24h] [ebp-34h]
  unsigned __int8 *end; // [esp+28h] [ebp-30h]
  unsigned __int8 enda; // [esp+28h] [ebp-30h]
  unsigned __int8 *v67; // [esp+2Ch] [ebp-2Ch]
  bool v68; // [esp+2Ch] [ebp-2Ch]
  dom_scanner_token *dest; // [esp+30h] [ebp-28h]
  dom_scanner_token *table_end; // [esp+34h] [ebp-24h]
  dom_scanner *v71; // [esp+38h] [ebp-20h]
  dom_scanner *v72; // [esp+38h] [ebp-20h]
  bool v73; // [esp+38h] [ebp-20h]
  unsigned __int8 v74; // [esp+38h] [ebp-20h]
  dom_scanner_token *current; // [esp+3Ch] [ebp-1Ch]

  v1 = scanner;
  dest = scanner->table;
  v2 = scanner->current;
  table = v2;
  tokens = -858993459 * (((char *)&scanner->table[scanner->tokens] - (char *)v2) >> 2);
  if ( tokens <= 0 )
  {
    table = scanner->table;
    tokens = 0;
  }
  if ( !assert_failed )
  {
    assert_failed = v2 == 0;
    if ( !v2 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
      errline = 251;
      v56 = table;
      elinks_internal("assertion scanner->current failed!");
      table = v56;
    }
  }
  v5 = 200;
  if ( tokens )
  {
    memmove(dest, table, 20 * tokens);
    table = &scanner->table[tokens];
    v5 = 200 - 20 * tokens;
  }
  memset(table, 0, v5);
  if ( !scanner->position )
  {
    if ( !tokens )
      tokens = -1;
    scanner->tokens = tokens;
    scanner->current = dest;
    if ( !assert_failed )
    {
      if ( tokens > 9 && &scanner->table[1] >= &scanner->table[tokens] )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
        errline = 266;
        elinks_internal("assertion check_dom_scanner(scanner) failed!");
      }
      else
      {
        assert_failed = 0;
      }
    }
    tokens = scanner->tokens;
LABEL_35:
    if ( tokens > 0 )
    {
      result = scanner->current;
      if ( result < &scanner->table[tokens] )
        return result;
    }
    return 0;
  }
  scanner->tokens = tokens;
  if ( scanner == (dom_scanner *)-44 )
    goto LABEL_35;
  current = &scanner->table[tokens];
  table_end = (dom_scanner_token *)&scanner[1];
  if ( &scanner[1] <= (dom_scanner *)current || (position = scanner->position, scanner->end <= position) )
  {
LABEL_16:
    if ( !assert_failed )
      goto LABEL_17;
    goto LABEL_19;
  }
  while ( 1 )
  {
    v7 = *position;
    v8 = *position;
    if ( (dom_css_scanner_info.scan_table[v8] & 0x400) != 0 )
    {
      v9 = v1->end;
      do
      {
        v1->position = ++position;
        if ( v9 <= position )
          goto LABEL_16;
        v7 = *position;
        v8 = *position;
      }
      while ( (dom_css_scanner_info.scan_table[v8] & 0x400) != 0 );
    }
    if ( !assert_failed )
    {
      assert_failed = v7 == 0;
      if ( !v7 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
        errline = 135;
        v54 = v8;
        elinks_internal("assertion first_char failed!");
        v7 = 0;
        v8 = v54;
      }
    }
    v14 = position + 1;
    current->string.string = position;
    v15 = dom_css_scanner_info.scan_table[v8];
    if ( (v15 & 0x100) != 0 )
    {
      v16 = v7;
      v17 = v14;
      v18 = v7;
      v19 = v14;
      goto LABEL_43;
    }
    if ( (v15 & 2) != 0 || v7 == 46 )
    {
      v71 = (dom_scanner *)v1->end;
      if ( v14 < (unsigned __int8 *)v71 )
      {
        v23 = *v14;
        if ( (dom_css_scanner_info.scan_table[*v14] & 2) == 0 )
          goto LABEL_64;
        while ( ++v14 < (unsigned __int8 *)v71 )
        {
          v23 = *v14;
          if ( (dom_css_scanner_info.scan_table[*v14] & 2) == 0 )
            goto LABEL_64;
        }
      }
      v23 = *v14;
LABEL_64:
      if ( v23 == 46 && (++v14, v23 = *v14, (dom_css_scanner_info.scan_table[*v14] & 2) != 0) )
      {
        if ( v14 >= (unsigned __int8 *)v71 )
        {
LABEL_152:
          v16 = 257;
        }
        else
        {
          while ( ++v14 < (unsigned __int8 *)v71 )
          {
            v23 = *v14;
            if ( (dom_css_scanner_info.scan_table[*v14] & 2) == 0 )
              goto LABEL_152;
          }
          v23 = *v14;
          v16 = 257;
        }
      }
      else
      {
        v16 = 284;
      }
      if ( v23 == 37 )
      {
        if ( v7 != 46 )
          v16 = 258;
        v19 = v14 + 1;
        v18 = v16;
        v17 = v14 + 1;
        goto LABEL_43;
      }
      v24 = dom_css_scanner_info.scan_table[v23];
      if ( (v24 & 0x10) == 0 )
      {
        v17 = v14;
        v19 = v14;
        v18 = 257;
        v16 = 257;
        goto LABEL_43;
      }
      if ( v14 < (unsigned __int8 *)v71 && (v24 & 8) != 0 )
      {
        v25 = v14;
        do
          ++v25;
        while ( v25 < (unsigned __int8 *)v71 && (dom_css_scanner_info.scan_table[*v25] & 8) != 0 );
      }
      else
      {
        v25 = v14;
      }
      v53 = 261;
      goto LABEL_74;
    }
    if ( (v15 & 0x10) != 0 )
    {
      v26 = (unsigned int)v1->end;
      if ( (unsigned int)v14 < v26 )
      {
        while ( (dom_css_scanner_info.scan_table[*v14] & 8) != 0 )
        {
          if ( (unsigned int)++v14 >= v26 )
            goto LABEL_106;
        }
        if ( *v14 != 40 )
          goto LABEL_81;
      }
      else
      {
LABEL_106:
        if ( *v14 != 40 )
          goto LABEL_81;
      }
      v19 = v14 + 1;
      if ( (unsigned int)(v14 + 1) >= v26 )
      {
        v67 = v14 + 1;
LABEL_150:
        if ( *v67 == 41 )
          goto LABEL_161;
      }
      else
      {
        LOBYTE(v29) = v14[1];
        if ( (_BYTE)v29 == 41 )
        {
          v67 = v14 + 1;
          goto LABEL_161;
        }
        v29 = (unsigned __int8)v29;
        if ( (unsigned __int8)v29 != 125 && v29 != 123 && v29 != 59 )
        {
          ident = position;
          v30 = v1->end;
          v31 = v14[1];
          end = v14;
          v72 = v1;
          v32 = v14 + 1;
          v33 = v14 + 1;
          while ( 1 )
          {
            if ( v31 == 39 || v31 == 34 )
            {
              v37 = v33 + 1;
              v38 = (char *)memchr(v33 + 1, v29, v30 - v33);
              v33 = (unsigned __int8 *)(v38 + 1);
              if ( !v38 )
                v33 = v37;
              if ( v30 <= v33 )
              {
LABEL_149:
                v67 = v33;
                v14 = end;
                v19 = v32;
                position = ident;
                v1 = v72;
                goto LABEL_150;
              }
            }
            else if ( v30 <= ++v33 )
            {
              goto LABEL_149;
            }
            v31 = *v33;
            if ( *v33 == 41 )
              break;
            v29 = v31;
            if ( v31 == 125 || v31 == 123 || v31 == 59 )
            {
              v19 = v32;
              v1 = v72;
              goto LABEL_121;
            }
          }
          v67 = v33;
          v14 = end;
          v19 = v32;
          position = ident;
          v1 = v72;
LABEL_161:
          v57 = v19;
          v41 = map_dom_scanner_string(v1, position, v14, 269);
          v42 = v57;
          v16 = v41;
          if ( v41 == 269 )
          {
            v14 = v67;
            v20 = -1;
          }
          else
          {
            v20 = -1;
            if ( v41 == 271 )
            {
              while ( 1 )
              {
                if ( v42 >= v1->end )
                {
                  v50 = v42;
                  enda = *v42;
                  goto LABEL_232;
                }
                enda = *v42;
                if ( (dom_css_scanner_info.scan_table[*v42] & 0x400) == 0 )
                  break;
                ++v42;
              }
              v50 = v42;
LABEL_232:
              for ( i = v67 - 1; ; --i )
              {
                if ( i < v1->string )
                {
                  v74 = *i;
                  v52 = i;
                  goto LABEL_238;
                }
                v74 = *i;
                if ( (dom_css_scanner_info.scan_table[*i] & 0x400) == 0 )
                  break;
              }
              v52 = i;
LABEL_238:
              if ( enda == 39 || enda == 34 )
                v50 = v42 + 1;
              if ( v74 == 39 || v74 == 34 )
                v52 = i - 1;
              v20 = v52 - v50 + 1;
              current->string.string = v50;
              v14 = v67;
              if ( assert_failed )
                goto LABEL_217;
              assert_failed = (unsigned int)v20 >> 31;
              if ( v20 >= 0 )
                goto LABEL_166;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
              errline = 210;
              v62 = v20;
              elinks_internal("assertion real_length >= 0 failed!");
              v20 = v62;
            }
          }
          if ( assert_failed )
          {
LABEL_217:
            v19 = v14 + 1;
            goto LABEL_122;
          }
          if ( v16 == 270 && *v14 != 40 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
            errline = 214;
            v60 = v20;
            elinks_internal("assertion type != CSS_TOKEN_RGB || *string == '(' failed!");
            v20 = v60;
            if ( assert_failed )
              goto LABEL_217;
            goto LABEL_227;
          }
          v67 = v14;
LABEL_166:
          assert_failed = 0;
          if ( v16 == 271 && *v67 != 41 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
            errline = 215;
            v58 = v20;
            elinks_internal("assertion type != CSS_TOKEN_URL || *string == ')' failed!");
            v20 = v58;
            if ( assert_failed )
            {
              v19 = v67 + 1;
              goto LABEL_122;
            }
LABEL_169:
            assert_failed = 0;
            v19 = v67 + 1;
            goto LABEL_122;
          }
          v14 = v67;
LABEL_227:
          assert_failed = 0;
          if ( v16 == 269 && *v14 != 41 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
            errline = 216;
            v61 = v20;
            elinks_internal("assertion type != CSS_TOKEN_FUNCTION || *string == ')' failed!");
            v19 = v14 + 1;
            v20 = v61;
            goto LABEL_122;
          }
          v67 = v14;
          goto LABEL_169;
        }
      }
LABEL_121:
      v20 = -1;
      v16 = 284;
LABEL_122:
      v28 = v16;
      goto LABEL_123;
    }
    if ( (v15 & 0x200) == 0 )
      goto LABEL_96;
    switch ( v7 )
    {
      case '#':
        v34 = dom_css_scanner_info.scan_table[*v14];
        if ( (v34 & 4) != 0 )
        {
          v35 = (unsigned int)v1->end;
          if ( (unsigned int)v14 < v35 )
          {
            do
              ++v14;
            while ( (unsigned int)v14 < v35 && (dom_css_scanner_info.scan_table[*v14] & 4) != 0 );
          }
          v17 = v14;
          v36 = &v14[~(unsigned int)position];
          if ( (v36 == (unsigned __int8 *)6 || v36 == (unsigned __int8 *)3)
            && (dom_css_scanner_info.scan_table[*v14] & 8) == 0 )
          {
            v19 = v14;
            v18 = 268;
            v16 = 268;
            goto LABEL_43;
          }
          if ( (unsigned int)v14 >= v35 || (dom_css_scanner_info.scan_table[*v14] & 8) == 0 )
          {
            v19 = v14;
            v18 = 267;
            v16 = 267;
            goto LABEL_43;
          }
          while ( 1 )
          {
            v19 = v14 + 1;
            if ( (unsigned int)(v14 + 1) >= v35 || (dom_css_scanner_info.scan_table[v14[1]] & 8) == 0 )
              break;
            ++v14;
          }
        }
        else
        {
          if ( (v34 & 8) == 0 )
            goto LABEL_96;
          v43 = (unsigned int)v1->end;
          if ( (unsigned int)v14 >= v43 )
          {
            v17 = position + 1;
            v19 = position + 1;
            v18 = 267;
            v16 = 267;
            goto LABEL_43;
          }
          while ( 1 )
          {
            v19 = v14 + 1;
            if ( (unsigned int)(v14 + 1) >= v43 || (dom_css_scanner_info.scan_table[v14[1]] & 8) == 0 )
              break;
            ++v14;
          }
        }
        v17 = v19;
        v18 = 267;
        v16 = 267;
        goto LABEL_43;
      case '@':
        v39 = dom_css_scanner_info.scan_table[*v14];
        if ( (v39 & 0x10) != 0 )
        {
          v40 = v1->end;
          if ( v14 < v40 && (v39 & 8) != 0 )
          {
            v25 = position + 1;
            do
              ++v25;
            while ( v25 < v40 && (dom_css_scanner_info.scan_table[*v25] & 8) != 0 );
          }
          else
          {
            v25 = position + 1;
          }
          v53 = 272;
LABEL_74:
          v55 = v25;
          v18 = map_dom_scanner_string(v1, v14, v25, v53);
          v19 = v55;
          v17 = v55;
          v16 = v18;
          goto LABEL_43;
        }
LABEL_96:
        v17 = position + 1;
        v19 = position + 1;
        v18 = 284;
        v16 = 284;
        goto LABEL_43;
      case '*':
        if ( *v14 == 61 )
        {
          v19 = position + 2;
          v18 = 283;
          v17 = position + 2;
          v16 = 283;
        }
        else
        {
LABEL_81:
          v17 = v14;
          v19 = v14;
          v18 = 256;
          v16 = 256;
        }
        goto LABEL_43;
      case '^':
        if ( *v14 == 61 )
        {
          v19 = position + 2;
          v18 = 281;
          v17 = position + 2;
          v16 = 281;
          goto LABEL_43;
        }
        goto LABEL_96;
      case '$':
        if ( *v14 == 61 )
        {
          v19 = position + 2;
          v18 = 282;
          v17 = position + 2;
          v16 = 282;
          goto LABEL_43;
        }
        goto LABEL_96;
      case '|':
        if ( *v14 == 61 )
        {
          v19 = position + 2;
          v18 = 280;
          v17 = position + 2;
          v16 = 280;
          goto LABEL_43;
        }
        goto LABEL_96;
      case '!':
        v45 = (unsigned int)v1->end;
        if ( (unsigned int)v14 < v45 && (dom_css_scanner_info.scan_table[*v14] & 0x400) != 0 )
        {
          while ( 1 )
          {
            v46 = (const char *)(v14 + 1);
            if ( (unsigned int)(v14 + 1) >= v45 || (dom_css_scanner_info.scan_table[v14[1]] & 0x400) == 0 )
              break;
            ++v14;
          }
        }
        else
        {
          v46 = (const char *)(position + 1);
        }
        v59 = v46;
        v47 = c_strncasecmp(v46, "important", 9u);
        v19 = (unsigned __int8 *)v59;
        if ( v47 )
        {
          v17 = (unsigned __int8 *)v59;
          v18 = 284;
          v16 = 284;
        }
        else
        {
          v19 = (unsigned __int8 *)(v59 + 9);
          v18 = 278;
          v17 = (unsigned __int8 *)(v59 + 9);
          v16 = 278;
        }
        goto LABEL_43;
    }
    if ( v7 != 39 && v7 != 34 )
    {
      v73 = v7 == 60;
      v68 = v7 == 45;
      if ( v7 == 45 || v7 == 60 )
      {
        v44 = *v14;
        if ( *v14 == 47 )
        {
          v17 = position + 1;
          v19 = position + 1;
          v18 = 0;
          v16 = 0;
        }
        else
        {
          identa = v1->end;
          v17 = position + 1;
          if ( v14 < identa )
          {
            v19 = position + 1;
            if ( SLOBYTE(dom_css_scanner_info.scan_table[v44]) < 0 )
            {
              do
                ++v19;
              while ( v19 < identa && SLOBYTE(dom_css_scanner_info.scan_table[*v19]) < 0 );
              v17 = position + 1;
              if ( v19 - v14 > 1 )
              {
                if ( v73 )
                {
                  if ( v44 == 33 )
                    goto LABEL_250;
                }
                else if ( v68 && *(v19 - 1) == 62 )
                {
                  goto LABEL_250;
                }
              }
            }
          }
LABEL_197:
          v19 = position + 1;
          v18 = 284;
          v16 = 284;
        }
LABEL_43:
        current->type = v18;
        goto LABEL_44;
      }
      if ( v7 == 47 )
      {
        if ( *v14 == 42 )
        {
          v48 = position + 2;
          for ( j = position + 3; ; ++j )
          {
            v19 = v48;
            if ( v48 >= v1->end )
              break;
            if ( *v48 == 42 && *j == 47 )
            {
              v19 = v48 + 2;
              v18 = 285;
              v17 = v19;
              v16 = 285;
              goto LABEL_43;
            }
            ++v48;
          }
LABEL_250:
          v17 = v19;
          v18 = 285;
          v16 = 285;
          goto LABEL_43;
        }
      }
      else
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/css/scanner.c";
        errline = 346;
        elinks_internal("Someone forgot to put code for recognizing tokens which start with '%c'.", v8);
      }
      goto LABEL_96;
    }
    v27 = (char *)memchr(position + 1, v8, v1->end - v14);
    v17 = position + 1;
    if ( !v27 )
      goto LABEL_197;
    v16 = 259;
    v20 = v27 - (char *)v14;
    current->string.string = v14;
    v19 = (unsigned __int8 *)(v27 + 1);
    v28 = 259;
LABEL_123:
    current->type = v28;
    if ( v20 > 0 )
      goto LABEL_45;
    v17 = v19;
LABEL_44:
    v20 = v17 - current->string.string;
LABEL_45:
    v21 = 1024;
    current->string.length = v20;
    if ( v16 != 125 )
    {
      LOWORD(v21) = 512;
      if ( v16 != 123 )
      {
        LOWORD(v21) = 256;
        if ( v16 != 59 )
        {
          LOWORD(v21) = 0;
          if ( v16 == 41 )
            v21 = 128;
        }
      }
    }
    current->precedence = v21;
    v1->position = v19;
    if ( !current->type )
      break;
    v22 = current - 1;
    if ( current->type != 285 )
      v22 = current;
    current = v22 + 1;
    if ( table_end <= &v22[1] || v1->end <= v19 )
      goto LABEL_16;
    position = v19;
  }
  v1->position = 0;
  --current;
  if ( assert_failed )
    goto LABEL_19;
LABEL_17:
  assert_failed = current > table_end;
  if ( current > table_end )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
    errline = 282;
    elinks_internal("assertion end <= scanner->table + DOM_SCANNER_TOKENS failed!");
  }
LABEL_19:
  v10 = -858993459 * (((char *)current - (char *)dest) >> 2);
  v11 = v1->position < v1->end;
  v1->tokens = v10;
  v1->current = dest;
  if ( !v11 )
    v1->position = 0;
  if ( !assert_failed )
  {
    if ( v10 <= 9
      || &v1->current[1] < (dom_scanner_token *)((char *)v1->table + 4 * (((char *)current - (char *)dest) >> 2)) )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
      errline = 289;
      elinks_internal("assertion check_dom_scanner(scanner) failed!");
    }
  }
  v12 = v1->tokens;
  if ( v12 <= 0 )
    return 0;
  result = v1->current;
  if ( result >= &v1->table[v12] )
    return 0;
  return result;
}

//----- (080A6610) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_element_pop(dom_stack *stack, dom_node *node, void *data)
{
  __fprintf_chk(stack->current->data, 1, "</%.*s>", node->string.length, (const char *)node->string.string);
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A6650) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_comment_push(dom_stack *stack, dom_node *node, void *data)
{
  __fprintf_chk(stack->current->data, 1, "<!--%.*s-->", node->string.length, (const char *)node->string.string);
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A6690) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_proc_instruction_push(dom_stack *stack, dom_node *node, void *data)
{
  __fprintf_chk(
    stack->current->data,
    1,
    "<?%.*s %.*s?>",
    node->string.length,
    (const char *)node->string.string,
    node->data.document.document,
    (const char *)node->data.document.children);
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A66E0) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_entity_ref_push(dom_stack *stack, dom_node *node, void *data)
{
  __fprintf_chk(stack->current->data, 1, "&%.*s;", node->string.length, (const char *)node->string.string);
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A6720) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_cdata_section_push(dom_stack *stack, dom_node *node, void *data)
{
  __fprintf_chk(stack->current->data, 1, "<![CDATA[%.*s]]>", node->string.length, (const char *)node->string.string);
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A6760) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_text_push(dom_stack *stack, dom_node *node, void *data)
{
  __fprintf_chk(stack->current->data, 1, "%.*s", node->string.length, (const char *)node->string.string);
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A67A0) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_element_push(dom_stack *stack, dom_node *node, void *data)
{
  void *v3; // esi
  dom_node_list *children; // eax

  v3 = stack->current->data;
  __fprintf_chk(v3, 1, "<%.*s", node->string.length, (const char *)node->string.string);
  children = node->data.document.children;
  if ( !children || !children->size )
    __fprintf_chk(v3, 1, ">");
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A6810) --------------------------------------------------------
dom_code __cdecl sgml_file_dumper_attribute_push(dom_stack *stack, dom_node *node, void *data)
{
  void *v3; // esi
  dom_node_list *children; // eax
  unsigned __int8 quoted; // dl

  v3 = stack->current->data;
  if ( node->parent->type != 7 )
  {
    __fprintf_chk(v3, 1, " %.*s", node->string.length, (const char *)node->string.string);
    children = node->data.document.children;
    if ( children )
    {
      quoted = node->data.attribute.quoted;
      if ( !quoted )
      {
        __fprintf_chk(v3, 1, "=\"%.*s\"", node->data.document.document, (const char *)node->data.document.children);
        if ( get_dom_node_next(node) )
          return 0;
        goto LABEL_8;
      }
      __fprintf_chk(v3, 1, "=%c%.*s%c", quoted, node->data.document.document, (const char *)children, quoted);
    }
    if ( get_dom_node_next(node) )
      return 0;
LABEL_8:
    __fprintf_chk(v3, 1, ">");
  }
  return 0;
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080A6900) --------------------------------------------------------
dom_stack_context *__cdecl add_sgml_file_dumper(dom_stack *stack, FILE *file)
{
  return add_dom_stack_context(stack, file, &sgml_file_dumper);
}

//----- (080A6930) --------------------------------------------------------
void __cdecl done_sgml_parser(sgml_parser *parser)
{
  dom_stack *p_parsing; // esi

  p_parsing = &parser->parsing;
  while ( parser->parsing.states )
  {
    if ( !parser->parsing.depth )
      break;
    pop_dom_node(p_parsing);
  }
  done_dom_stack(p_parsing);
  done_dom_stack(&parser->stack);
  if ( parser->uri.string )
    mem_free(parser->uri.string);
  parser->uri.string = 0;
  parser->uri.length = 0;
  mem_free(parser);
}

//----- (080A69A0) --------------------------------------------------------
dom_string *__usercall add_to_dom_string@<eax>(dom_string *string@<eax>, unsigned __int8 *str@<edx>, size_t len@<ecx>)
{
  dom_string *v3; // ebx
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // eax
  size_t v8; // edi

  v3 = string;
  v6 = (unsigned __int8 *)mem_realloc(string->string, len + string->length + 1);
  if ( !v6 )
    return 0;
  v3->string = v6;
  memcpy(&v6[v3->length], str, len);
  v7 = v3->string;
  v8 = v3->length + len;
  v3->length = v8;
  v7[v8] = 0;
  return v3;
}

//----- (080A6A10) --------------------------------------------------------
int __usercall check_sgml_incomplete@<eax>(
        dom_scanner *scanner@<eax>,
        dom_scanner_token *start@<edx>,
        dom_scanner_token *token@<ecx>)
{
  unsigned int v5; // esi
  unsigned __int8 *string; // eax
  dom_scanner_token *v7; // [esp+1Ch] [ebp-Ch]

  if ( token )
  {
    if ( token->type != 279 )
      return 0;
    token->string.length += token->string.string - start->string.string;
    token->string.string = start->string.string;
    return 1;
  }
  else
  {
    if ( (*((_BYTE *)scanner + 24) & 3) != 3 )
      return 0;
    v5 = scanner->end - start->string.string;
    if ( !assert_failed )
    {
      assert_failed = scanner->end == start->string.string;
      if ( !v5 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 189;
        v7 = start;
        elinks_internal("assertion left > 0 failed!");
        start = v7;
      }
    }
    scanner->current = scanner->table;
    scanner->tokens = 1;
    scanner->table[0].type = 279;
    string = start->string.string;
    scanner->table[0].string.string = string;
    if ( v5 == -1 )
      v5 = strlen((const char *)string);
    scanner->table[0].string.length = v5;
    return 1;
  }
}

//----- (080A6AF0) --------------------------------------------------------
dom_code __cdecl parse_sgml(sgml_parser *parser, unsigned __int8 *buf, size_t bufsize, int complete)
{
  dom_node *v4; // eax
  dom_node *inited; // eax
  dom_node *v7; // esi
  size_t depth; // edx
  dom_stack_state *states; // eax
  dom_string source; // [esp+18h] [ebp-10h] BYREF

  source.length = bufsize;
  source.string = buf;
  if ( complete )
    parser->flags |= 2u;
  if ( !parser->root )
  {
    inited = init_dom_node_at(0, DOM_NODE_DOCUMENT, &parser->uri, parser->flags & 4);
    v7 = inited;
    if ( !inited || push_dom_node(&parser->stack, inited) )
    {
      parser->root = 0;
      return -997;
    }
    depth = parser->stack.depth;
    states = parser->stack.states;
    parser->root = v7;
    *((_BYTE *)&states[depth - 1] + 8) |= 1u;
  }
  v4 = init_dom_node_at(0, DOM_NODE_TEXT, &source, 0);
  if ( !v4 || push_dom_node(&parser->parsing, v4) )
    return -997;
  else
    return parser->code;
}

//----- (080A6BD0) --------------------------------------------------------
dom_code __cdecl sgml_parsing_pop(dom_stack *stack, dom_node *node, void *data)
{
  dom_stack_context *v3; // eax
  char *v4; // ebx
  dom_code result; // eax

  v3 = *stack->contexts;
  v4 = (char *)v3->data;
  if ( (*((_BYTE *)v3->data + 4) & 2) != 0 && *((_DWORD *)data + 64) < *((_DWORD *)v4 + 9) )
  {
    do
    {
      *(_BYTE *)(*((_DWORD *)v4 + 8) + 4 * (3 * *((_DWORD *)v4 + 9) - 3) + 8) &= ~1u;
      pop_dom_node((dom_stack *)(v4 + 32));
    }
    while ( *((_DWORD *)data + 64) < *((_DWORD *)v4 + 9) );
  }
  if ( *((_DWORD *)data + 63) )
    mem_free(*((void **)data + 63));
  *((_DWORD *)data + 63) = 0;
  result = DOM_CODE_OK;
  *((_DWORD *)data + 62) = 0;
  return result;
}

//----- (080A6C60) --------------------------------------------------------
unsigned int __cdecl get_sgml_parser_line_number(sgml_parser *parser)
{
  _BOOL4 v1; // eax
  dom_stack_state *states; // edi
  size_t depth; // esi
  int v5; // eax
  int v6; // ebx
  dom_stack_context *v7; // edx
  size_t object_size; // ecx
  _DWORD *v9; // eax
  bool v10; // zf
  dom_stack_context *v11; // [esp+18h] [ebp-20h]
  size_t v12; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    v1 = !(parser->flags & 1);
    assert_failed = v1;
    if ( v1 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
      errline = 623;
      elinks_internal("assertion parser->flags & SGML_PARSER_COUNT_LINES failed!");
    }
  }
  states = parser->parsing.states;
  if ( !states )
    return 0;
  depth = parser->parsing.depth;
  if ( !depth )
    return 0;
  v5 = assert_failed;
  if ( !assert_failed )
  {
    assert_failed = 0;
    states = parser->parsing.states;
    depth = parser->parsing.depth;
  }
  v6 = 0;
  v7 = *parser->parsing.contexts;
  object_size = v7->info->object_size;
  if ( object_size )
  {
    if ( !v5 )
    {
      v10 = v7->state_objects != 0;
      assert_failed = v7->state_objects == 0;
      if ( !v10 )
      {
        v11 = v7;
        v12 = object_size;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
        errline = 198;
        elinks_internal("assertion context->state_objects failed!");
        v5 = assert_failed;
        object_size = v12;
        v7 = v11;
      }
    }
    v6 = (int)&v7->state_objects[states[depth - 1].depth * object_size];
  }
  if ( !v5 )
  {
    if ( (*(_BYTE *)(v6 + 32) & 1) != 0 && *(_DWORD *)(v6 + 36) )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
      errline = 631;
      elinks_internal("assertion pstate->scanner.count_lines && pstate->scanner.lineno failed!");
    }
  }
  v9 = *(_DWORD **)(v6 + 12);
  if ( v9 && (unsigned int)v9 < v6 + 244 && *v9 == 280 )
    return v9[2];
  else
    return *(_DWORD *)(v6 + 36);
}

//----- (080A6DF0) --------------------------------------------------------
dom_code __usercall call_sgml_error_function@<eax>(dom_stack *stack@<eax>, dom_scanner_token *token@<edx>)
{
  sgml_parser *v3; // ebx
  unsigned int sgml_parser_line_number; // eax
  sgml_error_T error_func; // ecx
  unsigned int v7; // [esp+1Ch] [ebp-Ch]

  v3 = **(sgml_parser ***)stack->contexts;
  sgml_parser_line_number = get_sgml_parser_line_number(v3);
  if ( !assert_failed )
  {
    error_func = v3->error_func;
    assert_failed = error_func == 0;
    if ( !error_func )
    {
      v7 = sgml_parser_line_number;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
      errline = 165;
      elinks_internal("assertion parser->error_func failed!");
      sgml_parser_line_number = v7;
    }
  }
  return v3->error_func(v3, &token->string, sgml_parser_line_number);
}

//----- (080A6E70) --------------------------------------------------------
sgml_parser *__cdecl init_sgml_parser(
        sgml_parser_type type,
        sgml_document_type doctype,
        dom_string *uri,
        sgml_parser_flag flags)
{
  __int32 v4; // esi
  sgml_parser *v5; // eax
  sgml_parser *v6; // ebx
  unsigned int length; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 *string; // eax
  unsigned int v10; // edi
  sgml_parser *v12; // [esp+0h] [ebp-38h]
  unsigned __int8 *src; // [esp+1Ch] [ebp-1Ch]

  v4 = flags;
  v5 = (sgml_parser *)mem_calloc(1u, 0x50u);
  v6 = v5;
  if ( v5 )
  {
    length = uri->length;
    src = uri->string;
    v8 = (unsigned __int8 *)mem_realloc(v5->uri.string, uri->length + v5->uri.length + 1);
    if ( v8 )
    {
      v6->uri.string = v8;
      memcpy(&v8[v6->uri.length], src, length);
      string = v6->uri.string;
      v10 = v6->uri.length + length;
      v6->uri.length = v10;
      string[v10] = 0;
      if ( (flags & 8) != 0 )
        v4 = flags | 1;
      v6->flags = v4;
      v6->type = type;
      v6->info = get_sgml_info(doctype);
      init_dom_stack(&v6->stack, (dom_stack_flag)(type == SGML_PARSER_STREAM));
      add_dom_stack_context(&v6->stack, v6, &sgml_parser_context_info);
      init_dom_stack(&v6->parsing, DOM_STACK_FLAG_FREE_NODES);
      add_dom_stack_context(&v6->parsing, v6, &sgml_parsing_context_info);
    }
    else
    {
      v12 = v6;
      v6 = 0;
      mem_free(v12);
    }
  }
  return v6;
}

//----- (080A6F80) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
dom_code __usercall parse_sgml_plain@<eax>(dom_stack *stack@<eax>, dom_scanner *scanner@<edx>)
{
  dom_scanner *v2; // ebx
  int tokens; // eax
  dom_scanner_token *current; // esi
  dom_node *v5; // eax
  dom_scanner_token *v6; // edx
  unsigned int v7; // ecx
  dom_code result; // eax
  dom_node *inited; // eax
  dom_scanner_token *v10; // edx
  unsigned int v11; // ecx
  int v12; // eax
  const char *v13; // edx
  dom_stack_state *v14; // eax
  dom_stack_context *v15; // edi
  size_t object_size; // ecx
  unsigned __int8 *v17; // edx
  bool v18; // zf
  int v19; // edi
  dom_node *v20; // edx
  char *v21; // edi
  char *v22; // eax
  unsigned int v23; // eax
  int type; // eax
  dom_stack_state *v25; // ecx
  dom_stack_context *v26; // edx
  unsigned __int8 *v27; // eax
  dom_scanner_token *v28; // edx
  unsigned int v29; // ecx
  dom_scanner_token *v30; // edx
  unsigned int v31; // ecx
  dom_scanner_token *v32; // esi
  dom_scanner_token *v33; // edx
  unsigned int v34; // ecx
  int v35; // eax
  dom_scanner_token *v36; // edx
  unsigned int v37; // eax
  dom_scanner_token *v38; // ecx
  dom_node *v39; // eax
  dom_node *v40; // eax
  dom_node *v41; // esi
  int v42; // ecx
  unsigned __int8 *v43; // edi
  char *v44; // edi
  char *v45; // eax
  __int16 v46; // ax
  dom_scanner_token *v47; // edx
  unsigned int v48; // ecx
  dom_node *v49; // eax
  dom_node *v50; // esi
  int length; // ecx
  unsigned __int8 *v52; // edi
  int v53; // eax
  dom_scanner_token *v54; // esi
  int v55; // eax
  dom_scanner_token *v56; // ecx
  dom_scanner_token *v57; // edx
  int v58; // eax
  dom_scanner_token *v59; // edx
  unsigned int v60; // eax
  int v61; // eax
  int v62; // eax
  dom_scanner_token *v63; // ecx
  dom_scanner_token *v64; // edx
  dom_scanner_token *v65; // edx
  dom_scanner_token *v66; // eax
  dom_scanner_token *v67; // ecx
  dom_scanner_token *v68; // ebx
  dom_node *v69; // eax
  dom_node *v70; // eax
  dom_node *v71; // esi
  int v72; // ecx
  unsigned __int8 *v73; // edi
  char *v74; // edi
  char *v75; // eax
  __int16 v76; // ax
  dom_scanner_token *v77; // ecx
  dom_scanner_token *v78; // edx
  dom_scanner_token *v79; // edx
  dom_scanner_token *v80; // eax
  dom_scanner_token *v81; // eax
  dom_scanner_token *v82; // edx
  int v83; // eax
  dom_node *v84; // [esp+0h] [ebp-188h]
  dom_node *v85; // [esp+0h] [ebp-188h]
  dom_stack_state *v86; // [esp+3Ch] [ebp-14Ch]
  size_t v87; // [esp+3Ch] [ebp-14Ch]
  dom_stack_state *v88; // [esp+3Ch] [ebp-14Ch]
  dom_node *node; // [esp+40h] [ebp-148h]
  dom_node *nodeb; // [esp+40h] [ebp-148h]
  dom_node *nodea; // [esp+40h] [ebp-148h]
  dom_string *v92; // [esp+44h] [ebp-144h]
  dom_string *v93; // [esp+44h] [ebp-144h]
  dom_scanner_token *token; // [esp+48h] [ebp-140h]
  size_t tokena; // [esp+48h] [ebp-140h]
  dom_scanner_token *tokenb; // [esp+48h] [ebp-140h]
  dom_scanner_token *tokenc; // [esp+48h] [ebp-140h]
  dom_scanner attr_scanner; // [esp+54h] [ebp-134h] BYREF
  dom_scanner_token string; // [esp+148h] [ebp-40h] OVERLAPPED BYREF
  dom_scanner_token target; // [esp+15Ch] [ebp-2Ch] BYREF

  v2 = scanner;
  tokens = scanner->tokens;
LABEL_2:
  while ( 2 )
  {
    if ( tokens <= 0 )
      return 0;
    current = v2->current;
    if ( current >= &v2->table[tokens] )
      return 0;
    switch ( current->type )
    {
      case 0x103:
      case 0x105:
      case 0x106:
      case 0x107:
      case 0x108:
        v2->current = current + 1;
        if ( &current[2] >= &v2->table[tokens] )
          goto LABEL_28;
        continue;
      case 0x104:
        if ( !assert_failed )
          assert_failed = 0;
        inited = init_dom_node_at(stack->states[stack->depth - 1].node, DOM_NODE_COMMENT, &current->string, -1);
        goto LABEL_51;
      case 0x109:
        if ( !assert_failed )
          assert_failed = 0;
        inited = init_dom_node_at(stack->states[stack->depth - 1].node, DOM_NODE_CDATA_SECTION, &current->string, -1);
LABEL_51:
        if ( !inited )
          return -997;
        if ( current->type == 277 )
          goto LABEL_53;
        goto LABEL_23;
      case 0x10A:
      case 0x10B:
      case 0x10C:
        target = *current;
        v23 = (unsigned int)&v2->table[tokens];
        if ( (unsigned int)current >= v23 )
          return -999;
        token = current + 1;
        v2->current = current + 1;
        if ( v23 <= (unsigned int)&current[2] )
        {
          token = v2->info->scan(v2);
        }
        else if ( (unsigned int)token >= v23 )
        {
          return -999;
        }
        if ( !token )
          return -999;
        type = token->type;
        if ( token->type == 279 )
          return -999;
        if ( type == 280 )
        {
LABEL_65:
          tokens = v2->tokens;
          continue;
        }
        if ( !assert_failed )
        {
          assert_failed = type != 269;
          if ( type == 269
            || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c",
                errline = 366,
                elinks_internal("assertion token->type == SGML_TOKEN_PROCESS_DATA failed!"),
                !assert_failed) )
          {
            assert_failed = 0;
          }
        }
        v49 = init_dom_node_at(
                stack->states[stack->depth - 1].node,
                DOM_NODE_PROCESSING_INSTRUCTION,
                &target.string,
                -1);
        v50 = v49;
        if ( !v49 )
          return -997;
        if ( (*((_BYTE *)v49 + 2) & 1) == 0 )
        {
          length = token->string.length;
          v52 = token->string.string;
          v49->data.document.children = (dom_node_list *)v52;
          if ( length == -1 )
          {
            do
            {
              if ( !length )
                break;
              v18 = *v52++ == 0;
              --length;
            }
            while ( !v18 );
            length = -length - 2;
          }
          v49->data.attribute.value.length = length;
          goto LABEL_132;
        }
        if ( add_to_dom_string((dom_string *)&v49->data, token->string.string, token->string.length) )
        {
LABEL_132:
          if ( target.type == 267 )
            v50->data.element.namespace_offset = 1;
          else
            v50->data.element.namespace_offset = 2 * (target.type == 268);
          if ( push_dom_node(stack, v50) )
            return -997;
          if ( (unsigned int)(target.type - 267) > 1 )
            goto LABEL_136;
          if ( !token->string.length )
            goto LABEL_136;
          init_dom_scanner(&attr_scanner, &sgml_scanner_info, &token->string, 1, *((_BYTE *)v2 + 32) & 1, 1, 0, 0);
          v53 = attr_scanner.tokens;
          if ( attr_scanner.tokens <= 0 )
            goto LABEL_136;
          v54 = attr_scanner.current;
          if ( attr_scanner.current >= &attr_scanner.table[attr_scanner.tokens] )
            goto LABEL_136;
          tokenc = (dom_scanner_token *)v2;
          while ( 1 )
          {
            if ( v54 >= &attr_scanner.table[v53] )
            {
LABEL_195:
              v2 = (dom_scanner *)tokenc;
              goto LABEL_136;
            }
            if ( !assert_failed )
            {
              assert_failed = v54 == 0;
              if ( !v54 )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
                errline = 209;
                elinks_internal("assertion token failed!");
              }
            }
            v55 = v54->type;
            if ( v54->type > 273 )
            {
              if ( v55 == 279 )
                goto LABEL_195;
              if ( v55 == 280 )
              {
                if ( call_sgml_error_function(stack, v54) )
                  goto LABEL_195;
                v53 = attr_scanner.tokens;
                if ( attr_scanner.tokens <= 0 )
                  goto LABEL_195;
                v63 = &attr_scanner.table[attr_scanner.tokens];
                if ( attr_scanner.current < v63 )
                {
                  v64 = attr_scanner.current + 2;
                  ++attr_scanner.current;
                  if ( v64 >= v63 )
                  {
LABEL_194:
                    attr_scanner.info->scan(&attr_scanner);
                    v53 = attr_scanner.tokens;
                    goto LABEL_159;
                  }
                }
                goto LABEL_159;
              }
            }
            else
            {
              if ( v55 >= 270 )
                goto LABEL_195;
              if ( v55 == 256 )
              {
                qmemcpy(&string, v54, sizeof(string));
                if ( attr_scanner.tokens <= 0 )
                  goto LABEL_247;
                v65 = &attr_scanner.table[attr_scanner.tokens];
                if ( attr_scanner.current >= v65 )
                  goto LABEL_247;
                v66 = attr_scanner.current + 1;
                v67 = attr_scanner.current + 2;
                ++attr_scanner.current;
                if ( v67 >= v65 )
                {
                  v66 = attr_scanner.info->scan(&attr_scanner);
                  goto LABEL_200;
                }
                if ( v66 >= v65 )
                {
LABEL_247:
                  v66 = 0;
LABEL_202:
                  if ( check_sgml_incomplete(&attr_scanner, &string, v66) )
                    goto LABEL_195;
                }
                else
                {
LABEL_200:
                  if ( !v66 || v66->type != 61 )
                    goto LABEL_202;
                  if ( attr_scanner.tokens <= 0
                    || (v81 = &attr_scanner.table[attr_scanner.tokens], attr_scanner.current >= v81) )
                  {
LABEL_237:
                    v68 = 0;
                  }
                  else
                  {
                    v68 = attr_scanner.current + 1;
                    v82 = attr_scanner.current + 2;
                    ++attr_scanner.current;
                    if ( v82 >= v81 )
                    {
                      v68 = attr_scanner.info->scan(&attr_scanner);
                    }
                    else if ( v68 >= v81 )
                    {
                      goto LABEL_237;
                    }
                  }
                  if ( check_sgml_incomplete(&attr_scanner, &string, v68) )
                    goto LABEL_195;
                  if ( !v68 || (v83 = v68->type, v68->type == 256) || v83 == 274 || v83 == 258 )
                  {
LABEL_204:
                    v93 = **(dom_string ***)stack->contexts;
                    if ( !assert_failed )
                      assert_failed = 0;
                    v69 = stack->states[stack->depth - 1].node;
                    if ( v68 )
                    {
                      v70 = init_dom_node_at(v69, DOM_NODE_ATTRIBUTE, &string.string, -1);
                      v71 = v70;
                      if ( v70 )
                      {
                        if ( (*((_BYTE *)v70 + 2) & 1) != 0 )
                        {
                          if ( !add_to_dom_string((dom_string *)&v70->data, v68->string.string, v68->string.length) )
                          {
                            v85 = v71;
                            v71 = 0;
                            done_dom_node(v85);
                          }
                        }
                        else
                        {
                          v72 = v68->string.length;
                          v73 = v68->string.string;
                          v70->data.document.children = (dom_node_list *)v73;
                          if ( v72 == -1 )
                          {
                            do
                            {
                              if ( !v72 )
                                break;
                              v18 = *v73++ == 0;
                              --v72;
                            }
                            while ( !v18 );
                            v72 = -v72 - 2;
                          }
                          v70->data.attribute.value.length = v72;
                        }
                      }
                    }
                    else
                    {
                      v71 = init_dom_node_at(v69, DOM_NODE_ATTRIBUTE, &string.string, -1);
                    }
                    v74 = *(char **)(v93[1].length + 4);
                    v75 = (char *)bsearch(v71, v74 + 12, *(_DWORD *)v74, 0xCu, sgml_info_strcmp);
                    if ( v75 )
                      v74 = v75;
                    v71->data.element.type = *((_WORD *)v74 + 4);
                    v76 = (4 * (*((_WORD *)v74 + 5) & 1)) | BYTE1(v71->data.proc_instruction.map) & 0xFB;
                    BYTE1(v71->data.proc_instruction.map) = v76;
                    BYTE1(v71->data.proc_instruction.map) = (8 * ((*((_WORD *)v74 + 5) & 2) != 0)) | v76 & 0xF7;
                    if ( v68 && v68->type == 258 )
                      v71->data.attribute.quoted = *(v68->string.string - 1);
                    if ( push_dom_node(stack, v71) )
                      goto LABEL_195;
                    pop_dom_node(stack);
                    if ( !v68 )
                      goto LABEL_232;
                    v53 = attr_scanner.tokens;
                    if ( attr_scanner.tokens <= 0 )
                      goto LABEL_195;
                    v77 = &attr_scanner.table[attr_scanner.tokens];
                    if ( attr_scanner.current < v77 )
                    {
                      v78 = attr_scanner.current + 2;
                      ++attr_scanner.current;
                      if ( v78 >= v77 )
                        goto LABEL_194;
                    }
                    goto LABEL_159;
                  }
                }
                v68 = 0;
                goto LABEL_204;
              }
              if ( v55 == 257 )
              {
                v2 = (dom_scanner *)tokenc;
                if ( attr_scanner.tokens > 0 )
                {
                  v79 = &attr_scanner.table[attr_scanner.tokens];
                  if ( attr_scanner.current < v79 )
                  {
                    v80 = attr_scanner.current + 2;
                    ++attr_scanner.current;
                    if ( v80 >= v79 )
                      attr_scanner.info->scan(&attr_scanner);
                  }
                }
LABEL_136:
                pop_dom_node(stack);
                tokens = v2->tokens;
                if ( tokens <= 0 )
                  return 0;
LABEL_26:
                v10 = v2->current;
                v11 = (unsigned int)&v2->table[tokens];
                if ( (unsigned int)v10 < v11 )
                {
                  v2->current = v10 + 1;
                  if ( (unsigned int)&v10[2] >= v11 )
                  {
LABEL_28:
                    v2->info->scan(v2);
                    tokens = v2->tokens;
                  }
                }
                goto LABEL_2;
              }
            }
            v53 = attr_scanner.tokens;
            if ( attr_scanner.tokens <= 0 )
              goto LABEL_195;
            v56 = &attr_scanner.table[attr_scanner.tokens];
            if ( attr_scanner.current < v56 )
            {
              v57 = attr_scanner.current + 2;
              ++attr_scanner.current;
              if ( v57 >= v56 )
              {
                attr_scanner.info->scan(&attr_scanner);
LABEL_232:
                v53 = attr_scanner.tokens;
              }
            }
LABEL_159:
            if ( v53 <= 0 )
              goto LABEL_195;
            v54 = attr_scanner.current;
          }
        }
        done_dom_node(v50);
        return -997;
      case 0x10E:
      case 0x10F:
        v19 = **(_DWORD **)stack->contexts;
        if ( !assert_failed )
          assert_failed = 0;
        v20 = init_dom_node_at(stack->states[stack->depth - 1].node, DOM_NODE_ELEMENT, &current->string, -1);
        if ( !v20 )
          return -997;
        v21 = *(char **)(*(_DWORD *)(v19 + 8) + 8);
        node = v20;
        v22 = (char *)bsearch(v20, v21 + 12, *(_DWORD *)v21, 0xCu, sgml_info_strcmp);
        if ( v22 )
          v21 = v22;
        node->data.element.type = *((_WORD *)v21 + 4);
        if ( push_dom_node(stack, node) )
          return -997;
        if ( assert_failed )
        {
          v25 = &stack->states[stack->depth - 1];
        }
        else
        {
          assert_failed = 0;
          v25 = &stack->states[stack->depth - 1];
          v18 = node == v25->node;
          assert_failed = node != v25->node;
          if ( !v18 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
            errline = 70;
            v88 = v25;
            elinks_internal("assertion node == state->node failed!");
            v25 = v88;
          }
        }
        v26 = *stack->contexts;
        tokena = v26->info->object_size;
        v27 = 0;
        if ( tokena )
        {
          if ( !assert_failed )
          {
            v18 = v26->state_objects != 0;
            assert_failed = v26->state_objects == 0;
            if ( !v18 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
              errline = 198;
              nodeb = (dom_node *)v26;
              v86 = v25;
              elinks_internal("assertion context->state_objects failed!");
              v25 = v86;
              v26 = (dom_stack_context *)nodeb;
            }
          }
          v27 = &v26->state_objects[v25->depth * tokena];
        }
        *(_DWORD *)v27 = v21;
        if ( current->type != 271 )
        {
          tokens = v2->tokens;
          if ( tokens <= 0 )
            return 0;
          v28 = v2->current;
          v29 = (unsigned int)&v2->table[tokens];
          if ( (unsigned int)v28 < v29 )
          {
            v2->current = v28 + 1;
            if ( v29 <= (unsigned int)&v28[2] )
              goto LABEL_28;
          }
          continue;
        }
        tokens = v2->tokens;
        if ( tokens <= 0 )
          continue;
        v30 = v2->current;
        v31 = (unsigned int)&v2->table[tokens];
        if ( (unsigned int)v30 < v31 )
        {
          v2->current = v30 + 1;
          if ( v31 <= (unsigned int)&v30[2] )
          {
LABEL_92:
            v2->info->scan(v2);
            goto LABEL_93;
          }
        }
        break;
      case 0x110:
        v12 = current->string.length;
        if ( !v12 )
          goto LABEL_24;
        v13 = (const char *)current->string.string;
        string.precedence = (int)v13;
        if ( v12 == -1 )
          v12 = strlen(v13);
        string.type = v12;
        v14 = search_dom_stack(stack, DOM_NODE_ELEMENT, (dom_string *)&string);
        if ( v14 )
        {
          v15 = *stack->contexts;
          object_size = v15->info->object_size;
          v17 = 0;
          if ( object_size )
          {
            if ( !assert_failed )
            {
              v18 = v15->state_objects != 0;
              assert_failed = v15->state_objects == 0;
              if ( !v18 )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/stack.h";
                errline = 198;
                nodea = (dom_node *)v14;
                v87 = object_size;
                elinks_internal("assertion context->state_objects failed!");
                object_size = v87;
                v14 = (dom_stack_state *)nodea;
              }
            }
            v17 = &v15->state_objects[object_size * v14->depth];
          }
          *((_DWORD *)v17 + 1) = current->type;
          *((_DWORD *)v17 + 2) = current->precedence;
          *((_DWORD *)v17 + 3) = current->lineno;
          *((_DWORD *)v17 + 4) = current->string.length;
          *((_DWORD *)v17 + 5) = current->string.string;
          pop_dom_state(stack, v14);
        }
        goto LABEL_25;
      case 0x111:
        pop_dom_node(stack);
        tokens = v2->tokens;
        if ( tokens <= 0 )
          return 0;
        goto LABEL_26;
      case 0x113:
        if ( !assert_failed )
          assert_failed = 0;
        inited = init_dom_node_at(stack->states[stack->depth - 1].node, DOM_NODE_ENTITY_REFERENCE, &current->string, -1);
        if ( !inited )
          goto LABEL_25;
        if ( current->type != 277 )
          goto LABEL_23;
LABEL_53:
        LOBYTE(inited->data.attribute.value.string) |= 1u;
LABEL_23:
        if ( push_dom_node(stack, inited) == DOM_CODE_OK )
LABEL_24:
          pop_dom_node(stack);
LABEL_25:
        tokens = v2->tokens;
        if ( tokens > 0 )
          goto LABEL_26;
        return 0;
      case 0x117:
        return -999;
      case 0x118:
        result = call_sgml_error_function(stack, v2->current);
        if ( result )
          return result;
        goto LABEL_12;
      default:
        if ( !assert_failed )
          assert_failed = 0;
        v5 = init_dom_node_at(stack->states[stack->depth - 1].node, DOM_NODE_TEXT, &current->string, -1);
        if ( v5 )
        {
          if ( current->type == 277 )
            LOBYTE(v5->data.attribute.value.string) |= 1u;
          if ( push_dom_node(stack, v5) == DOM_CODE_OK )
            pop_dom_node(stack);
        }
LABEL_12:
        tokens = v2->tokens;
        if ( tokens <= 0 )
          return 0;
        v6 = v2->current;
        v7 = (unsigned int)&v2->table[tokens];
        if ( (unsigned int)v6 >= v7 )
          continue;
        v2->current = v6 + 1;
        if ( (unsigned int)&v6[2] < v7 )
          continue;
        v2->info->scan(v2);
        goto LABEL_65;
    }
    break;
  }
  while ( 1 )
  {
    if ( tokens <= 0 )
      goto LABEL_2;
    v32 = v2->current;
    if ( v32 >= &v2->table[tokens] )
      goto LABEL_2;
    if ( !assert_failed )
    {
      assert_failed = v32 == 0;
      if ( !v32 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 209;
        elinks_internal("assertion token failed!");
      }
    }
    switch ( v32->type )
    {
      case 0x100:
        string = *v32;
        v35 = v2->tokens;
        if ( v35 <= 0 )
          goto LABEL_142;
        v36 = v2->current;
        v37 = (unsigned int)&v2->table[v35];
        if ( (unsigned int)v36 >= v37 )
          goto LABEL_142;
        v38 = v36 + 1;
        v2->current = v36 + 1;
        if ( v37 <= (unsigned int)&v36[2] )
        {
          v38 = v2->info->scan(v2);
        }
        else if ( v37 <= (unsigned int)v38 )
        {
LABEL_142:
          v38 = 0;
LABEL_105:
          if ( check_sgml_incomplete(v2, &string, v38) )
            return -999;
LABEL_106:
          tokenb = 0;
          goto LABEL_107;
        }
        if ( !v38 || v38->type != 61 )
          goto LABEL_105;
        v58 = v2->tokens;
        if ( v58 <= 0 )
          goto LABEL_186;
        v59 = v2->current;
        v60 = (unsigned int)&v2->table[v58];
        if ( (unsigned int)v59 >= v60 )
          goto LABEL_186;
        tokenb = v59 + 1;
        v2->current = v59 + 1;
        if ( (unsigned int)&v59[2] >= v60 )
        {
          tokenb = v2->info->scan(v2);
          v61 = check_sgml_incomplete(v2, &string, tokenb);
        }
        else if ( (unsigned int)tokenb >= v60 )
        {
LABEL_186:
          tokenb = 0;
          v61 = check_sgml_incomplete(v2, &string, 0);
        }
        else
        {
          v61 = check_sgml_incomplete(v2, &string, tokenb);
        }
        if ( v61 )
          return -999;
        if ( tokenb )
        {
          v62 = tokenb->type;
          if ( tokenb->type != 256 && v62 != 274 && v62 != 258 )
            goto LABEL_106;
        }
LABEL_107:
        v92 = **(dom_string ***)stack->contexts;
        if ( !assert_failed )
          assert_failed = 0;
        v39 = stack->states[stack->depth - 1].node;
        if ( tokenb )
        {
          v40 = init_dom_node_at(v39, DOM_NODE_ATTRIBUTE, &string.string, -1);
          v41 = v40;
          if ( v40 )
          {
            if ( (*((_BYTE *)v40 + 2) & 1) != 0 )
            {
              if ( !add_to_dom_string((dom_string *)&v40->data, tokenb->string.string, tokenb->string.length) )
              {
                v84 = v41;
                v41 = 0;
                done_dom_node(v84);
              }
            }
            else
            {
              v42 = tokenb->string.length;
              v43 = tokenb->string.string;
              v40->data.document.children = (dom_node_list *)v43;
              if ( v42 == -1 )
              {
                do
                {
                  if ( !v42 )
                    break;
                  v18 = *v43++ == 0;
                  --v42;
                }
                while ( !v18 );
                v42 = -v42 - 2;
              }
              v40->data.attribute.value.length = v42;
            }
          }
        }
        else
        {
          v41 = init_dom_node_at(v39, DOM_NODE_ATTRIBUTE, &string.string, -1);
        }
        v44 = *(char **)(v92[1].length + 4);
        v45 = (char *)bsearch(v41, v44 + 12, *(_DWORD *)v44, 0xCu, sgml_info_strcmp);
        if ( v45 )
          v44 = v45;
        v41->data.element.type = *((_WORD *)v44 + 4);
        v46 = (4 * (*((_WORD *)v44 + 5) & 1)) | BYTE1(v41->data.proc_instruction.map) & 0xFB;
        BYTE1(v41->data.proc_instruction.map) = v46;
        BYTE1(v41->data.proc_instruction.map) = (8 * ((*((_WORD *)v44 + 5) & 2) != 0)) | v46 & 0xF7;
        if ( tokenb && tokenb->type == 258 )
          v41->data.attribute.quoted = *(tokenb->string.string - 1);
        if ( push_dom_node(stack, v41) )
          return -997;
        pop_dom_node(stack);
        if ( tokenb )
        {
          tokens = v2->tokens;
          if ( tokens > 0 )
          {
            v47 = v2->current;
            v48 = (unsigned int)&v2->table[tokens];
            if ( (unsigned int)v47 < v48 )
            {
              v2->current = v47 + 1;
              if ( (unsigned int)&v47[2] >= v48 )
              {
                v2->info->scan(v2);
                tokens = v2->tokens;
              }
            }
          }
        }
        else
        {
LABEL_93:
          tokens = v2->tokens;
        }
        break;
      case 0x101:
        tokens = v2->tokens;
        if ( tokens <= 0 )
          goto LABEL_2;
        goto LABEL_26;
      case 0x10E:
      case 0x10F:
      case 0x110:
      case 0x111:
        goto LABEL_65;
      case 0x117:
        return -999;
      case 0x118:
        result = call_sgml_error_function(stack, v32);
        if ( result )
          return result;
        goto LABEL_89;
      default:
LABEL_89:
        tokens = v2->tokens;
        if ( tokens > 0 )
        {
          v33 = v2->current;
          v34 = (unsigned int)&v2->table[tokens];
          if ( (unsigned int)v33 < v34 )
          {
            v2->current = v33 + 1;
            if ( (unsigned int)&v33[2] >= v34 )
              goto LABEL_92;
          }
        }
        continue;
    }
  }
}
// 80A709F: conditional instruction was optimized away because eax.4>=1
// 80A6F80: variables would overlap: ^148.20 and stkvar "string" ^148.8(has user info)

//----- (080A8180) --------------------------------------------------------
dom_code __cdecl sgml_parsing_push(dom_stack *stack, dom_node *node, void *data)
{
  dom_stack *v3; // edx
  char *v4; // edi
  int v5; // ebx
  unsigned int v6; // ecx
  int v7; // ecx
  dom_scanner *v8; // esi
  char tokens; // al
  unsigned __int8 *end; // edi
  int state; // edi
  dom_scanner *v12; // edx
  int v13; // eax
  dom_scanner_token *current; // edi
  unsigned int v15; // edx
  unsigned int v16; // ecx
  dom_code result; // eax
  int v18; // edx
  dom_scanner *v19; // eax
  size_t v20; // esi
  dom_scanner *v21; // eax
  size_t v22; // ebx
  const char *v23; // edx
  dom_code v24; // eax
  unsigned int v25; // edx
  unsigned int v26; // ecx
  int v27; // edx
  unsigned int v28; // eax
  unsigned int v29; // edx
  int v30; // edx
  dom_scanner_token *v31; // eax
  unsigned int v32; // edx
  dom_scanner_token *v33; // ecx
  int v34; // edx
  dom_scanner_token *v35; // eax
  unsigned int v36; // edx
  int v37; // eax
  int type; // eax
  dom_node *v39; // eax
  dom_node *inited; // eax
  dom_node *v41; // edi
  size_t length; // eax
  const char *v43; // edx
  size_t *v44; // eax
  size_t *v45; // edx
  char v46; // al
  unsigned __int8 *v47; // eax
  unsigned __int8 *position; // eax
  unsigned int v49; // edi
  dom_node *v50; // [esp+0h] [ebp-88h]
  int v51; // [esp+28h] [ebp-60h]
  int v52; // [esp+28h] [ebp-60h]
  dom_scanner *scannera; // [esp+2Ch] [ebp-5Ch]
  dom_scanner *scanner; // [esp+2Ch] [ebp-5Ch]
  size_t *scannerb; // [esp+2Ch] [ebp-5Ch]
  unsigned int n; // [esp+30h] [ebp-58h]
  int count_lines; // [esp+38h] [ebp-50h]
  dom_string *string; // [esp+3Ch] [ebp-4Ch]
  _DWORD *src; // [esp+40h] [ebp-48h]
  unsigned __int8 *srca; // [esp+40h] [ebp-48h]
  int incremental; // [esp+44h] [ebp-44h]
  dom_scanner_token *incrementala; // [esp+44h] [ebp-44h]
  dom_stack *v63; // [esp+48h] [ebp-40h]
  int complete; // [esp+4Ch] [ebp-3Ch]
  const void *completea; // [esp+4Ch] [ebp-3Ch]
  dom_scanner_token start; // [esp+5Ch] [ebp-2Ch] BYREF

  v3 = stack;
  v4 = (char *)data;
  v5 = **(_DWORD **)stack->contexts;
  v6 = *(_DWORD *)(v5 + 4);
  complete = (v6 >> 1) & 1;
  count_lines = v6 & 1;
  incremental = (v6 >> 2) & 1;
  string = &node->string;
  v7 = (v6 >> 3) & 1;
  *((_DWORD *)data + 64) = *(_DWORD *)(v5 + 36);
  if ( stack->depth <= 1 || (v8 = (dom_scanner *)((char *)data - 264), tokens = *((char *)data - 4), (tokens & 1) == 0) )
  {
    init_dom_scanner((dom_scanner *)data, &sgml_scanner_info, string, 0, count_lines, complete, incremental, v7);
    v12 = (dom_scanner *)data;
LABEL_17:
    *(_DWORD *)(v5 + 24) = parse_sgml_plain((dom_stack *)(v5 + 32), v12);
    goto LABEL_18;
  }
  if ( v8[1].position )
  {
    end = v8[1].end;
    if ( end )
    {
      n = node->string.length;
      srca = node->string.string;
      v52 = v7;
      v47 = (unsigned __int8 *)mem_realloc(v8[1].position, (size_t)&end[n + 1]);
      if ( !v47 )
        goto LABEL_91;
      string = (dom_string *)((char *)data - 16);
      v8[1].position = v47;
      memcpy(&v8[1].end[(unsigned int)v47], srca, n);
      position = v8[1].position;
      v49 = (unsigned int)&v8[1].end[n];
      v8[1].end = (unsigned __int8 *)v49;
      position[v49] = 0;
      tokens = v8[1].tokens;
      v3 = stack;
      v7 = v52;
    }
  }
  state = v8->state;
  LOBYTE(v8[1].tokens) = tokens & 0xFE;
  v51 = v7;
  pop_dom_node(v3);
  init_dom_scanner(v8, &sgml_scanner_info, string, state, count_lines, complete, incremental, v51);
  v12 = (dom_scanner *)((char *)data - 264);
  if ( state != 1 )
  {
    v4 = (char *)data - 264;
    goto LABEL_17;
  }
  v63 = (dom_stack *)(v5 + 32);
  v13 = v8->tokens;
  while ( 2 )
  {
    if ( v13 <= 0 || (current = v8->current, current >= &v8->table[v13]) )
    {
LABEL_51:
      *(_DWORD *)(v5 + 24) = 0;
      v4 = (char *)data - 264;
      *(_DWORD *)(v5 + 24) = parse_sgml_plain(v63, v8);
      goto LABEL_18;
    }
    if ( !assert_failed )
    {
      assert_failed = current == 0;
      if ( !current )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
        errline = 209;
        elinks_internal("assertion token failed!");
      }
    }
    switch ( current->type )
    {
      case 0x100:
        start = *current;
        v30 = v8->tokens;
        if ( v30 <= 0 )
          goto LABEL_69;
        v31 = v8->current;
        v32 = (unsigned int)&v8->table[v30];
        if ( (unsigned int)v31 >= v32 )
          goto LABEL_69;
        v33 = v31 + 1;
        v8->current = v31 + 1;
        if ( v32 <= (unsigned int)&v31[2] )
        {
          v33 = v8->info->scan(v8);
          goto LABEL_56;
        }
        if ( v32 > (unsigned int)v33 )
        {
LABEL_56:
          if ( !v33 || v33->type != 61 )
            goto LABEL_70;
          v34 = v8->tokens;
          if ( v34 <= 0 )
            goto LABEL_99;
          v35 = v8->current;
          v36 = (unsigned int)&v8->table[v34];
          if ( (unsigned int)v35 >= v36 )
            goto LABEL_99;
          incrementala = v35 + 1;
          v8->current = v35 + 1;
          if ( (unsigned int)&v35[2] < v36 )
          {
            if ( (unsigned int)incrementala < v36 )
            {
              v37 = check_sgml_incomplete(v8, &start, incrementala);
              goto LABEL_63;
            }
LABEL_99:
            incrementala = 0;
            v37 = check_sgml_incomplete(v8, &start, 0);
            goto LABEL_63;
          }
          incrementala = v8->info->scan(v8);
          v37 = check_sgml_incomplete(v8, &start, incrementala);
LABEL_63:
          if ( v37 )
            goto LABEL_92;
          if ( incrementala )
          {
            type = incrementala->type;
            if ( incrementala->type != 256 && type != 274 && type != 258 )
              goto LABEL_71;
          }
LABEL_72:
          src = ***(_DWORD ****)(v5 + 44);
          if ( !assert_failed )
            assert_failed = 0;
          v39 = *(dom_node **)(*(_DWORD *)(v5 + 32) + 4 * (3 * *(_DWORD *)(v5 + 36) - 3));
          if ( incrementala )
          {
            inited = init_dom_node_at(v39, DOM_NODE_ATTRIBUTE, &start.string, -1);
            v41 = inited;
            if ( inited )
            {
              if ( (*((_BYTE *)inited + 2) & 1) != 0 )
              {
                if ( !add_to_dom_string(
                        (dom_string *)&inited->data,
                        incrementala->string.string,
                        incrementala->string.length) )
                {
                  v50 = v41;
                  v41 = 0;
                  done_dom_node(v50);
                }
              }
              else
              {
                length = incrementala->string.length;
                v43 = (const char *)incrementala->string.string;
                v41->data.document.children = (dom_node_list *)v43;
                if ( length == -1 )
                  length = strlen(v43);
                v41->data.attribute.value.length = length;
              }
            }
          }
          else
          {
            v41 = init_dom_node_at(v39, DOM_NODE_ATTRIBUTE, &start.string, -1);
          }
          scannerb = *(size_t **)(src[2] + 4);
          v44 = (size_t *)bsearch(v41, scannerb + 3, *scannerb, 0xCu, sgml_info_strcmp);
          v45 = scannerb;
          if ( v44 )
            v45 = v44;
          v41->data.element.type = *((_WORD *)v45 + 4);
          v46 = (4 * (*((_WORD *)v45 + 5) & 1)) | BYTE1(v41->data.proc_instruction.map) & 0xFB;
          BYTE1(v41->data.proc_instruction.map) = v46;
          BYTE1(v41->data.proc_instruction.map) = (8 * ((*((_WORD *)v45 + 5) & 2) != 0)) | v46 & 0xF7;
          if ( incrementala && incrementala->type == 258 )
            v41->data.attribute.quoted = *(incrementala->string.string - 1);
          if ( push_dom_node(v63, v41) )
          {
            v24 = DOM_CODE_ALLOC_ERR;
            goto LABEL_87;
          }
          pop_dom_node(v63);
          if ( incrementala )
          {
LABEL_43:
            v13 = v8->tokens;
            if ( v13 <= 0 )
              goto LABEL_51;
            v25 = (unsigned int)v8->current;
            v26 = (unsigned int)&v8->table[v13];
            if ( v25 < v26 )
            {
              v8->current = (dom_scanner_token *)(v25 + 20);
              if ( v25 + 40 >= v26 )
              {
                v8->info->scan(v8);
                v13 = v8->tokens;
              }
            }
          }
          else
          {
LABEL_15:
            v13 = v8->tokens;
          }
          continue;
        }
LABEL_69:
        v33 = 0;
LABEL_70:
        if ( !check_sgml_incomplete(v8, &start, v33) )
        {
LABEL_71:
          incrementala = 0;
          goto LABEL_72;
        }
LABEL_92:
        v24 = DOM_CODE_INCOMPLETE;
LABEL_87:
        *(_DWORD *)(v5 + 24) = v24;
        v4 = (char *)data - 264;
LABEL_18:
        if ( complete )
        {
LABEL_27:
          pop_dom_node((dom_stack *)(v5 + 56));
          return 0;
        }
        if ( *(_DWORD *)(v5 + 24) == -999 )
        {
          v18 = *((_DWORD *)v4 + 4);
          if ( v18 <= 0 || (v19 = (dom_scanner *)*((_DWORD *)v4 + 3), v19 >= (dom_scanner *)&v4[20 * v18 + 44]) )
            v19 = 0;
          if ( !assert_failed )
          {
            if ( v19 && v19->string == (unsigned __int8 *)279 )
            {
              assert_failed = 0;
            }
            else
            {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/parser.c";
              errline = 539;
              scannera = v19;
              elinks_internal("assertion token && token->type == SGML_TOKEN_INCOMPLETE failed!");
              v19 = scannera;
            }
          }
          v20 = (size_t)v19->current;
          completea = (const void *)v19->tokens;
          v21 = (dom_scanner *)mem_realloc(0, v20 + 1);
          if ( v21 )
          {
            v22 = v20;
            scanner = v21;
            memcpy(v21, completea, v20);
            v23 = (const char *)scanner;
            *((_BYTE *)&scanner->string + v20) = 0;
            if ( *((_DWORD *)v4 + 63) )
            {
              mem_free(*((void **)v4 + 63));
              v23 = (const char *)scanner;
            }
            *((_DWORD *)v4 + 62) = 0;
            *((_DWORD *)v4 + 63) = v23;
            if ( v20 == -1 )
              v22 = strlen(v23);
            v4[260] |= 1u;
            result = DOM_CODE_OK;
            *((_DWORD *)v4 + 62) = v22;
            return result;
          }
LABEL_91:
          *(_DWORD *)(v5 + 24) = -997;
          return 0;
        }
        if ( !*((_DWORD *)v4 + 10) )
          goto LABEL_27;
        if ( *((_DWORD *)v4 + 63) )
          mem_free(*((void **)v4 + 63));
        v4[260] |= 1u;
        *((_DWORD *)v4 + 63) = 0;
        *((_DWORD *)v4 + 62) = 0;
        return 0;
      case 0x101:
        v27 = v8->tokens;
        if ( v27 > 0 )
        {
          v28 = (unsigned int)v8->current;
          v29 = (unsigned int)&v8->table[v27];
          if ( v28 < v29 )
          {
            v8->current = (dom_scanner_token *)(v28 + 20);
            if ( v28 + 40 >= v29 )
              v8->info->scan(v8);
          }
        }
        goto LABEL_51;
      case 0x10E:
      case 0x10F:
      case 0x110:
      case 0x111:
        goto LABEL_51;
      case 0x117:
        goto LABEL_92;
      case 0x118:
        v24 = call_sgml_error_function(v63, current);
        if ( v24 == DOM_CODE_OK )
          goto LABEL_43;
        goto LABEL_87;
      default:
        v13 = v8->tokens;
        if ( v13 <= 0 )
          goto LABEL_51;
        v15 = (unsigned int)v8->current;
        v16 = (unsigned int)&v8->table[v13];
        if ( v15 >= v16 )
          continue;
        v8->current = (dom_scanner_token *)(v15 + 20);
        if ( v15 + 40 < v16 )
          continue;
        v8->info->scan(v8);
        goto LABEL_15;
    }
  }
}

//----- (080A8950) --------------------------------------------------------
void __usercall skip_sgml_space(dom_scanner *scanner@<eax>, unsigned __int8 **string@<edx>)
{
  unsigned __int8 *v2; // ecx
  unsigned __int8 *v3; // esi
  int v4; // ebx
  unsigned __int8 *end; // ebx

  v2 = *string;
  if ( (*((_BYTE *)scanner + 32) & 1) == 0 )
  {
    end = scanner->end;
    if ( v2 < end && (sgml_scanner_info.scan_table[*v2] & 0x10) != 0 )
    {
      while ( ++v2 < end )
      {
        if ( (sgml_scanner_info.scan_table[*v2] & 0x10) == 0 )
        {
          *string = v2;
          return;
        }
      }
    }
    goto LABEL_3;
  }
  v3 = scanner->end;
  if ( v2 >= v3 )
  {
LABEL_3:
    *string = v2;
    return;
  }
  while ( 1 )
  {
    v4 = sgml_scanner_info.scan_table[*v2];
    if ( (v4 & 0x10) == 0 )
      break;
    if ( (v4 & 8) != 0 )
      ++scanner->lineno;
    if ( ++v2 >= v3 )
      goto LABEL_3;
  }
  *string = v2;
}

//----- (080A89D0) --------------------------------------------------------
unsigned __int8 *__usercall skip_sgml_chars@<eax>(
        dom_scanner *scanner@<eax>,
        unsigned __int8 *string@<edx>,
        unsigned __int8 skipto@<cl>)
{
  unsigned __int8 *result; // eax
  unsigned __int8 *end; // edx
  int v7; // edi

  result = string;
  if ( assert_failed )
  {
LABEL_4:
    if ( (*((_BYTE *)scanner + 32) & 1) != 0 )
      goto LABEL_8;
    return (unsigned __int8 *)memchr(result, skipto, scanner->end - result);
  }
  if ( scanner->position > string || string > scanner->end )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
    errline = 305;
    elinks_internal("assertion string >= scanner->position && string <= scanner->end failed!");
    result = string;
    goto LABEL_4;
  }
  assert_failed = 0;
  if ( (*((_BYTE *)scanner + 32) & 1) == 0 )
    return (unsigned __int8 *)memchr(result, skipto, scanner->end - result);
LABEL_8:
  end = scanner->end;
  v7 = 0;
  if ( result >= end )
    return 0;
  while ( 1 )
  {
    v7 -= ((sgml_scanner_info.scan_table[*result] & 8) == 0) - 1;
    if ( skipto == *result )
      break;
    if ( ++result >= end )
      return 0;
  }
  scanner->lineno += v7;
  return result;
}

//----- (080A8AC0) --------------------------------------------------------
void __usercall set_sgml_incomplete(dom_scanner *scanner@<eax>, dom_scanner_token *token@<edx>)
{
  unsigned int v4; // edi
  unsigned __int8 *position; // eax

  v4 = scanner->end - scanner->position;
  if ( !assert_failed )
  {
    assert_failed = scanner->end == scanner->position;
    if ( !v4 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
      errline = 111;
      elinks_internal("assertion left > 0 failed!");
    }
  }
  token->type = 279;
  position = scanner->position;
  token->string.string = position;
  if ( v4 == -1 )
    v4 = strlen((const char *)position);
  token->string.length = v4;
  scanner->position = scanner->end;
}

//----- (080A8B50) --------------------------------------------------------
dom_scanner_token *__usercall set_sgml_error@<eax>(dom_scanner *scanner@<eax>, unsigned __int8 *end@<edx>)
{
  dom_scanner_token *current; // ebx
  dom_scanner_token *v4; // ecx
  unsigned int found_error; // ecx
  dom_scanner_token *v6; // edi
  unsigned __int8 *position; // ecx
  unsigned __int8 *v8; // eax
  unsigned __int8 *v10; // [esp+1Ch] [ebp-1Ch]

  current = scanner->current;
  v4 = current;
  if ( !assert_failed )
  {
    found_error = scanner->found_error;
    assert_failed = found_error != 0;
    if ( found_error )
    {
      v10 = end;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
      errline = 180;
      elinks_internal("assertion !scanner->found_error failed!");
      v4 = scanner->current;
      end = v10;
      if ( &scanner[1] > (dom_scanner *)v4 )
        goto LABEL_5;
      goto LABEL_10;
    }
    v4 = scanner->current;
  }
  if ( &scanner[1] > (dom_scanner *)v4 )
  {
LABEL_5:
    v6 = v4 + 1;
    scanner->current = v4 + 1;
    v4[1].type = current->type;
    v4[1].precedence = current->precedence;
    v4[1].lineno = current->lineno;
    v4[1].string.length = current->string.length;
    v4[1].string.string = current->string.string;
    goto LABEL_6;
  }
LABEL_10:
  scanner->found_error = 1;
  v6 = 0;
LABEL_6:
  current->type = 280;
  current->lineno = scanner->lineno;
  position = scanner->position;
  v8 = (unsigned __int8 *)(end - position);
  current->string.string = position;
  if ( end - position == -1 )
    v8 = (unsigned __int8 *)strlen((const char *)position);
  current->string.length = (unsigned int)v8;
  return v6;
}

//----- (080A8C40) --------------------------------------------------------
unsigned __int8 *__usercall skip_sgml@<eax>(int a1@<eax>, unsigned __int8 **a2@<edx>, int a3@<ecx>)
{
  unsigned __int8 *v4; // esi
  unsigned int v5; // edi
  unsigned __int8 v6; // dl
  int v7; // eax
  _BYTE *v8; // eax
  int v10; // esi
  int v11; // ecx
  int v12; // [esp+18h] [ebp-30h]
  unsigned __int8 v13; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v14; // [esp+24h] [ebp-24h]

  v4 = *a2;
  v5 = *(_DWORD *)(a1 + 4);
LABEL_2:
  while ( (unsigned int)v4 < v5 )
  {
    while ( 1 )
    {
      v6 = *v4;
      if ( *v4 == 62 )
      {
        *a2 = v4 + 1;
        return v4;
      }
      v7 = v6;
      if ( v6 == 60 )
        goto LABEL_15;
      if ( !a3 || v6 != 39 && v6 != 34 )
      {
        if ( (*(_BYTE *)(a1 + 32) & 1) != 0 && (sgml_scanner_info.scan_table[v6] & 8) != 0 )
          ++*(_DWORD *)(a1 + 36);
        ++v4;
        goto LABEL_2;
      }
      ++v4;
      if ( !assert_failed )
        break;
LABEL_10:
      if ( (*(_BYTE *)(a1 + 32) & 1) != 0 )
        goto LABEL_23;
LABEL_11:
      v8 = memchr(v4, v7, v5 - (_DWORD)v4);
LABEL_12:
      if ( v8 )
        v4 = v8 + 1;
      if ( (unsigned int)v4 >= v5 )
        goto LABEL_15;
    }
    if ( (unsigned int)v4 < *(_DWORD *)(a1 + 8) || (unsigned int)v4 > v5 )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
      errline = 305;
      v12 = v6;
      v13 = v6;
      elinks_internal("assertion string >= scanner->position && string <= scanner->end failed!");
      v5 = *(_DWORD *)(a1 + 4);
      v6 = v13;
      v7 = v12;
      goto LABEL_10;
    }
    assert_failed = 0;
    v5 = *(_DWORD *)(a1 + 4);
    if ( (*(_BYTE *)(a1 + 32) & 1) == 0 )
      goto LABEL_11;
LABEL_23:
    if ( (unsigned int)v4 >= v5 )
      break;
    v8 = v4;
    v14 = v4;
    v10 = 0;
    do
    {
      v10 -= ((sgml_scanner_info.scan_table[(unsigned __int8)*v8] & 8) == 0) - 1;
      if ( v6 == *v8 )
      {
        v11 = v10;
        v4 = v14;
        *(_DWORD *)(a1 + 36) += v11;
        goto LABEL_12;
      }
      ++v8;
    }
    while ( (unsigned int)v8 < v5 );
    v4 = v14;
  }
LABEL_15:
  *a2 = v4;
  return 0;
}

//----- (080A8DE0) --------------------------------------------------------
dom_scanner_token *__cdecl scan_sgml_tokens(dom_scanner *scanner)
{
  dom_scanner_token *current; // eax
  dom_scanner_token *table; // edx
  int tokens; // esi
  size_t v4; // eax
  unsigned __int8 *position; // eax
  unsigned __int8 *v6; // esi
  int state; // edi
  unsigned __int8 v8; // cl
  unsigned __int8 *v9; // edx
  int v10; // eax
  unsigned __int8 *v11; // esi
  int v12; // edi
  char v13; // cl
  unsigned __int8 *v14; // esi
  int v15; // edi
  dom_scanner_token *v16; // eax
  int v17; // eax
  int v18; // edx
  dom_scanner_token *result; // eax
  unsigned __int8 *jj; // eax
  unsigned __int8 *v21; // esi
  int v22; // edi
  bool v23; // cc
  dom_scanner_token *v24; // esi
  unsigned __int8 *v25; // edx
  unsigned __int8 v26; // cl
  int v27; // ecx
  unsigned __int8 v28; // al
  char v29; // dl
  unsigned int found_error; // edx
  unsigned __int8 v31; // cl
  int v32; // eax
  unsigned __int8 *v33; // edx
  unsigned __int8 *v34; // edx
  int v35; // eax
  int v36; // edx
  int v37; // edi
  unsigned int v38; // edx
  int v39; // ecx
  unsigned __int8 v40; // al
  int v41; // eax
  int v42; // ecx
  unsigned __int8 v43; // al
  unsigned __int8 v44; // al
  unsigned __int8 v45; // al
  unsigned int v46; // edx
  int v47; // eax
  _BOOL4 v48; // edi
  bool v49; // zf
  unsigned __int8 *v50; // ecx
  int v51; // ecx
  unsigned __int8 *v52; // eax
  int v53; // ecx
  unsigned __int8 *v54; // edx
  unsigned __int8 *v55; // ecx
  int v56; // eax
  unsigned __int8 *v57; // edx
  unsigned __int8 v58; // cl
  unsigned __int8 *v59; // eax
  int v60; // ecx
  unsigned __int8 *v61; // edx
  unsigned __int8 *v62; // eax
  int v63; // edx
  unsigned __int8 *v64; // ecx
  unsigned __int8 *v65; // ecx
  dom_scanner_token *v66; // eax
  unsigned __int8 *v67; // eax
  unsigned __int8 *i; // edx
  unsigned __int8 *v69; // eax
  unsigned __int8 *j; // eax
  unsigned __int8 *v71; // eax
  unsigned __int8 *v72; // edx
  unsigned __int8 *v73; // ecx
  unsigned __int8 *v74; // edx
  int v75; // eax
  unsigned __int8 *m; // edx
  unsigned __int8 *v77; // eax
  unsigned __int8 *v78; // edx
  unsigned __int8 *v79; // ecx
  unsigned __int8 *v80; // ecx
  unsigned __int8 *n; // eax
  unsigned __int8 *ii; // edx
  unsigned __int8 *v83; // eax
  unsigned __int8 *k; // edx
  unsigned __int8 *v85; // eax
  unsigned __int8 *v86; // ecx
  char v87; // dl
  unsigned __int8 *v88; // edx
  unsigned __int8 *v89; // eax
  dom_scanner_token *v90; // [esp+14h] [ebp-44h]
  unsigned __int8 *v91; // [esp+14h] [ebp-44h]
  unsigned __int8 *v92; // [esp+18h] [ebp-40h]
  int v93; // [esp+18h] [ebp-40h]
  unsigned __int8 *v94; // [esp+18h] [ebp-40h]
  dom_scanner_token *dest; // [esp+1Ch] [ebp-3Ch]
  int v96; // [esp+20h] [ebp-38h]
  unsigned __int8 *v97; // [esp+20h] [ebp-38h]
  dom_scanner_token *table_end; // [esp+24h] [ebp-34h]
  unsigned __int8 *string; // [esp+28h] [ebp-30h]
  unsigned __int8 *stringa; // [esp+28h] [ebp-30h]
  signed int stringb; // [esp+28h] [ebp-30h]
  unsigned __int8 *stringc; // [esp+28h] [ebp-30h]
  dom_scanner_token *token; // [esp+2Ch] [ebp-2Ch]
  int tokena; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *tokenb; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *end[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  dest = scanner->table;
  current = scanner->current;
  table = current;
  tokens = -858993459 * (((char *)&scanner->table[scanner->tokens] - (char *)current) >> 2);
  if ( tokens <= 0 )
  {
    table = scanner->table;
    tokens = 0;
  }
  if ( !assert_failed )
  {
    assert_failed = current == 0;
    if ( !current )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
      errline = 251;
      v90 = table;
      elinks_internal("assertion scanner->current failed!");
      table = v90;
    }
  }
  v4 = 200;
  if ( tokens )
  {
    memmove(dest, table, 20 * tokens);
    table = &scanner->table[tokens];
    v4 = 200 - 20 * tokens;
  }
  memset(table, 0, v4);
  if ( !scanner->position )
  {
    if ( !tokens )
      tokens = -1;
    scanner->tokens = tokens;
    scanner->current = dest;
    if ( !assert_failed )
    {
      if ( tokens <= 9 || &scanner->table[1] < &scanner->table[tokens] )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
        errline = 266;
        elinks_internal("assertion check_dom_scanner(scanner) failed!");
      }
    }
    tokens = scanner->tokens;
LABEL_47:
    if ( tokens > 0 )
    {
      result = scanner->current;
      if ( result < &scanner->table[tokens] )
        return result;
    }
    return 0;
  }
  scanner->tokens = tokens;
  if ( scanner == (dom_scanner *)-44 )
    goto LABEL_47;
  table_end = (dom_scanner_token *)&scanner[1];
  token = &scanner->table[tokens];
  scanner->current = token;
  if ( &scanner[1] <= (dom_scanner *)token )
    goto LABEL_29;
  do
  {
    position = scanner->position;
    v6 = scanner->end;
    if ( position >= v6 )
      break;
    state = scanner->state;
    if ( state == 1 )
    {
LABEL_67:
      if ( (*((_BYTE *)scanner + 32) & 1) != 0 )
      {
        while ( position < v6 )
        {
          v36 = sgml_scanner_info.scan_table[*position];
          if ( (v36 & 0x10) == 0 )
            goto LABEL_72;
          if ( (v36 & 8) != 0 )
            ++scanner->lineno;
          ++position;
        }
        v23 = scanner->end <= position;
        scanner->position = position;
        if ( !v23 )
        {
LABEL_73:
          v24 = scanner->current;
          v25 = position + 1;
          end[0] = position;
          v26 = *position;
          v96 = state;
          v24->string.string = position;
          stringa = position + 1;
          end[0] = position + 1;
          if ( v26 != 60 )
          {
            if ( v26 == 61 )
            {
              v32 = 61;
              stringb = -1;
              tokena = 61;
              goto LABEL_84;
            }
            if ( (unsigned __int8)(v26 - 62) > 1u )
            {
              if ( v26 == 47 )
              {
                if ( stringa == scanner->end )
                  goto LABEL_80;
                if ( *stringa != 62 )
                {
                  if ( (sgml_scanner_info.scan_table[*stringa] & 0x50) != 0 )
                    goto LABEL_80;
                  if ( stringa < scanner->end )
                  {
                    v59 = position + 2;
                    do
                    {
                      end[0] = v59;
                      v61 = v59;
                      if ( v59 >= scanner->end )
                        break;
                      v60 = *v59++;
                    }
                    while ( (sgml_scanner_info.scan_table[v60] & 0x50) == 0 );
                    stringa = v61;
                  }
                  if ( *(stringa - 1) == 47 && *stringa == 62 )
                  {
                    end[0] = stringa - 1;
                    v32 = 274;
                    stringb = -1;
                    tokena = 274;
                    goto LABEL_84;
                  }
                  goto LABEL_204;
                }
                end[0] = position + 2;
                if ( assert_failed || (v49 = scanner->state == 1, assert_failed = scanner->state != 1, v49) )
                {
                  v32 = 273;
                  state = 0;
                  stringb = 0;
                  tokena = 273;
                }
                else
                {
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                  state = 0;
                  errline = 648;
                  elinks_internal("assertion scanner->state == SGML_STATE_ELEMENT failed!");
                  v32 = 273;
                  stringb = 0;
                  tokena = 273;
                }
              }
              else
              {
                if ( v26 != 39 && v26 != 34 )
                {
                  v27 = sgml_scanner_info.scan_table[v26];
                  if ( (v27 & 0x50) != 0 )
                    goto LABEL_80;
                  if ( (v27 & 4) != 0 )
                  {
                    if ( stringa >= scanner->end )
                    {
LABEL_174:
                      v28 = *((_BYTE *)scanner + 24);
                      stringb = -1;
                      tokena = 256;
                      v29 = v28 & 3;
                      goto LABEL_81;
                    }
                    v51 = sgml_scanner_info.scan_table[*stringa];
                    if ( (v51 & 4) != 0 )
                    {
                      v52 = position + 2;
                      do
                      {
                        end[0] = v52;
                        v54 = v52;
                        if ( v52 >= scanner->end )
                          goto LABEL_174;
                        v53 = *v52++;
                        v51 = sgml_scanner_info.scan_table[v53];
                      }
                      while ( (v51 & 4) != 0 );
                      stringa = v54;
                    }
                    tokena = 256;
                    if ( (v51 & 0x50) == 0 )
                      goto LABEL_235;
                  }
                  else
                  {
                    if ( stringa >= scanner->end )
                      goto LABEL_80;
                    tokena = 278;
                    if ( (sgml_scanner_info.scan_table[*stringa] & 0x50) == 0 )
                    {
LABEL_235:
                      for ( i = stringa; ; ++i )
                      {
                        end[0] = i + 1;
                        if ( i + 1 >= scanner->end || (sgml_scanner_info.scan_table[i[1]] & 0x50) != 0 )
                          break;
                      }
                      if ( *i == 47 && i[1] == 62 )
                      {
                        v32 = 274;
                        stringb = -1;
                        tokena = 274;
                        end[0] = i;
                        goto LABEL_84;
                      }
                      goto LABEL_204;
                    }
                  }
                  goto LABEL_217;
                }
                v62 = skip_sgml_chars(scanner, stringa, v26);
                if ( v62 )
                {
                  v63 = (int)(v24->string.string + 1);
                  v64 = &v62[-v63];
                  v24->string.string = (unsigned __int8 *)v63;
                  end[0] = v62 + 1;
                  v32 = 258;
                  stringb = (signed int)v64;
                  tokena = 258;
                  goto LABEL_84;
                }
                v28 = *((_BYTE *)scanner + 24);
                v29 = v28 & 3;
                if ( (v28 & 3) != 3 )
                {
                  if ( scanner->end > end[0] && (sgml_scanner_info.scan_table[*end[0]] & 0x50) == 0 )
                  {
                    ++v24->string.string;
                    for ( j = end[0]; j < scanner->end; end[0] = ++j )
                    {
                      if ( (sgml_scanner_info.scan_table[*j] & 0x50) != 0 )
                        break;
                    }
LABEL_204:
                    v28 = *((_BYTE *)scanner + 24);
                    stringb = -1;
                    tokena = 274;
                    v29 = v28 & 3;
                    goto LABEL_81;
                  }
                  stringb = -1;
                  tokena = 278;
                  goto LABEL_81;
                }
                stringb = -1;
                tokena = 278;
                end[0] = scanner->end;
LABEL_160:
                if ( scanner->end == end[0] )
                {
                  set_sgml_incomplete(scanner, v24);
                  goto LABEL_90;
                }
LABEL_82:
                found_error = scanner->found_error;
                v31 = v28 >> 2;
                scanner->found_error = 0;
                state = v96;
                v32 = tokena;
                if ( (v31 & (found_error == 0)) != 0 )
                {
                  v33 = scanner->end;
                  if ( v33 == end[0] )
                  {
                    switch ( tokena )
                    {
                      case 260:
                        v69 = scanner->position + 4;
                        if ( end[0] <= v69 )
                          goto LABEL_247;
                        break;
                      case 261:
                      case 262:
                      case 264:
                      case 265:
                        v69 = scanner->position + 9;
                        if ( v33 <= v69 )
                          v69 = scanner->end;
                        break;
                      case 263:
                        v69 = scanner->position + 6;
                        if ( end[0] <= v69 )
                          goto LABEL_247;
                        break;
                      case 267:
                        v69 = scanner->position + 5;
                        if ( end[0] <= v69 )
                          goto LABEL_247;
                        break;
                      case 268:
                        v69 = scanner->position + 16;
                        if ( end[0] <= v69 )
                          goto LABEL_247;
                        break;
                      default:
LABEL_247:
                        v69 = scanner->end;
                        break;
                    }
                    v24 = set_sgml_error(scanner, v69);
                    if ( v24 )
                      goto LABEL_176;
LABEL_90:
                    v16 = scanner->current;
                    if ( v16->type == 281 )
                      scanner->current = --v16;
                    goto LABEL_28;
                  }
                }
              }
LABEL_84:
              scanner->state = state;
              v24->type = v32;
              v34 = (unsigned __int8 *)stringb;
              if ( stringb < 0 )
                v34 = (unsigned __int8 *)(end[0] - v24->string.string);
              v24->string.length = (unsigned int)v34;
              v35 = 2048;
              if ( tokena != 60 )
              {
                LOWORD(v35) = 0;
                if ( tokena == 62 )
                  v35 = 1024;
              }
              v24->precedence = v35;
              scanner->position = end[0];
              goto LABEL_90;
            }
            if ( v26 == 63 )
            {
              v48 = skip_sgml((int)scanner, end, 0) == 0;
              if ( assert_failed )
                goto LABEL_157;
            }
            else
            {
              if ( assert_failed )
              {
                stringb = -1;
                v96 = 0;
                tokena = 257;
                goto LABEL_176;
              }
              assert_failed = 0;
              v48 = 0;
            }
            v49 = scanner->state == 1;
            assert_failed = scanner->state != 1;
            if ( !v49 )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
              errline = 628;
              elinks_internal("assertion scanner->state == SGML_STATE_ELEMENT failed!");
              v96 = 0;
              stringb = -1;
              tokena = 257;
              goto LABEL_158;
            }
LABEL_157:
            v96 = 0;
            stringb = -1;
            tokena = 257;
            goto LABEL_158;
          }
          if ( (*((_BYTE *)scanner + 32) & 1) != 0 )
          {
            v55 = scanner->end;
            if ( v25 < v55 )
            {
              v56 = sgml_scanner_info.scan_table[*v25];
              if ( (v56 & 0x10) != 0 )
              {
                v57 = stringa;
                do
                {
                  if ( (v56 & 8) != 0 )
                    ++scanner->lineno;
                  if ( ++v57 >= v55 )
                    break;
                  v56 = sgml_scanner_info.scan_table[*v57];
                }
                while ( (v56 & 0x10) != 0 );
                goto LABEL_186;
              }
            }
          }
          else
          {
            v65 = scanner->end;
            if ( stringa < v65 )
            {
              v57 = position + 1;
              if ( (sgml_scanner_info.scan_table[*stringa] & 0x10) != 0 )
              {
                do
                  ++v57;
                while ( v57 < v65 && (sgml_scanner_info.scan_table[*v57] & 0x10) != 0 );
LABEL_186:
                stringa = v57;
              }
            }
          }
          end[0] = stringa;
          if ( scanner->state == 1 )
          {
            state = 0;
            stringb = 0;
            tokena = 257;
            end[0] = v24->string.string;
            v32 = 257;
            goto LABEL_84;
          }
          if ( scanner->end == stringa )
            goto LABEL_80;
          v58 = *stringa;
          if ( (sgml_scanner_info.scan_table[*stringa] & 4) != 0 )
          {
            v24->string.string = stringa;
            v67 = end[0];
            if ( scanner->end > end[0] && (sgml_scanner_info.scan_table[*end[0]] & 4) != 0 )
            {
              while ( 1 )
              {
                end[0] = ++v67;
                if ( v67 >= scanner->end )
                  break;
                if ( (sgml_scanner_info.scan_table[*v67] & 4) == 0 )
                {
                  stringa = v24->string.string;
                  goto LABEL_229;
                }
              }
              stringa = v24->string.string;
            }
LABEL_229:
            stringb = v67 - stringa;
            skip_sgml_space(scanner, end);
            if ( scanner->end > end[0] && *end[0] == 62 )
            {
              ++end[0];
              v32 = 270;
              tokena = 270;
              goto LABEL_84;
            }
            if ( (sgml_scanner_info.scan_table[*(end[0] - 1)] & 0x10) != 0 )
            {
              v32 = 271;
              state = 1;
              tokena = 271;
              goto LABEL_84;
            }
            v28 = *((_BYTE *)scanner + 24);
            v96 = 1;
            tokena = 271;
            v29 = v28 & 3;
          }
          else
          {
            if ( v58 == 33 )
            {
              end[0] = stringa + 1;
              skip_sgml_space(scanner, end);
              stringc = end[0];
              v24->string.string = end[0];
              v73 = end[0];
              v74 = end[0] + 1;
              tokenb = scanner->end;
              if ( end[0] + 1 < tokenb && *end[0] == 45 && *v74 == 45 )
              {
                end[0] += 2;
                v24->string.string = end[0];
                for ( k = end[0]; ; k = v85 + 1 )
                {
                  v85 = skip_sgml_chars(scanner, k, 0x3Eu);
                  if ( !v85 )
                    goto LABEL_352;
                  v86 = v85 - 2;
                  if ( *(v85 - 2) == 45 )
                  {
                    v87 = *(v85 - 1);
                    if ( v87 == 45 )
                    {
                      if ( v86 >= end[0] )
                      {
                        v89 = v85 + 1;
                        stringb = v86 - end[0];
LABEL_344:
                        v48 = 0;
                        if ( !v89 )
                        {
LABEL_352:
                          v89 = scanner->end;
                          v48 = 1;
                          stringb = v89 - end[0];
                        }
                        end[0] = v89;
                        if ( assert_failed || (assert_failed = (unsigned int)stringb >> 31, stringb >= 0) )
                        {
                          tokena = 260;
                        }
                        else
                        {
                          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                          errline = 503;
                          elinks_internal("assertion real_length >= 0 failed!");
                          tokena = 260;
                        }
LABEL_158:
                        if ( v48 )
                        {
                          v28 = *((_BYTE *)scanner + 24);
                          if ( (v28 & 3) == 3 )
                            goto LABEL_160;
                          goto LABEL_82;
                        }
LABEL_176:
                        state = v96;
                        v32 = tokena;
                        goto LABEL_84;
                      }
                    }
                    else if ( v87 == 33 )
                    {
                      v88 = v85 - 3;
                      if ( *(v85 - 3) == 45 && v88 >= end[0] )
                      {
                        v89 = v85 + 1;
                        stringb = v88 - end[0];
                        goto LABEL_344;
                      }
                    }
                  }
                }
              }
              if ( tokenb > end[0] + 6 )
              {
                v91 = end[0] + 1;
                v94 = end[0];
                v75 = memcmp(end[0], "[CDATA[", 7u);
                v74 = v91;
                v73 = v94;
                if ( !v75 )
                {
                  end[0] = v94 + 7;
                  v24->string.string = v94 + 7;
                  for ( m = end[0]; ; m = v77 + 1 )
                  {
                    v77 = skip_sgml_chars(scanner, m, 0x3Eu);
                    if ( !v77 )
                      break;
                    if ( *(v77 - 2) == 93 && *(v77 - 1) == 93 )
                    {
                      v78 = end[0];
                      v79 = v77 + 1;
                      if ( v77 != (unsigned __int8 *)-1 )
                      {
                        v48 = 0;
                        stringb = v77 - end[0] - 2;
LABEL_304:
                        end[0] = v79;
                        if ( assert_failed || (assert_failed = (unsigned int)stringb >> 31, stringb >= 0) )
                        {
                          tokena = 265;
                        }
                        else
                        {
                          errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
                          errline = 513;
                          elinks_internal("assertion real_length >= 0 failed!");
                          tokena = 265;
                        }
                        goto LABEL_158;
                      }
LABEL_336:
                      v79 = scanner->end;
                      v48 = 1;
                      stringb = v79 - v78;
                      goto LABEL_304;
                    }
                  }
                  v78 = end[0];
                  goto LABEL_336;
                }
              }
              if ( v73 < tokenb && (sgml_scanner_info.scan_table[*v73] & 4) != 0 )
              {
                while ( 1 )
                {
                  end[0] = v74;
                  v73 = v74;
                  if ( v74 >= scanner->end || (sgml_scanner_info.scan_table[*v74] & 4) == 0 )
                    break;
                  ++v74;
                }
              }
              tokena = map_dom_scanner_string(scanner, stringc, v73, 259);
              if ( skip_sgml((int)scanner, end, 0) )
              {
                v32 = tokena;
                stringb = -1;
                goto LABEL_84;
              }
LABEL_217:
              v28 = *((_BYTE *)scanner + 24);
              stringb = -1;
              v29 = v28 & 3;
              goto LABEL_81;
            }
            if ( v58 != 63 )
            {
              if ( v58 != 47 )
              {
                if ( skip_sgml((int)scanner, end, 0) )
                {
                  v32 = 278;
                  stringb = -1;
                  tokena = 278;
                  goto LABEL_84;
                }
                goto LABEL_80;
              }
              end[0] = stringa + 1;
              skip_sgml_space(scanner, end);
              v71 = end[0];
              if ( scanner->end != end[0] )
              {
                if ( (sgml_scanner_info.scan_table[*end[0]] & 4) != 0 )
                {
                  v24->string.string = end[0];
                  v72 = end[0];
                  if ( end[0] < scanner->end && (sgml_scanner_info.scan_table[*end[0]] & 4) != 0 )
                  {
                    do
                      end[0] = ++v72;
                    while ( v72 < scanner->end && (sgml_scanner_info.scan_table[*v72] & 4) != 0 );
                    v71 = v24->string.string;
                  }
                  stringb = v72 - v71;
                  v48 = skip_sgml((int)scanner, end, 1) == 0;
                }
                else
                {
                  if ( *end[0] != 62 )
                    goto LABEL_80;
                  v48 = 0;
                  ++end[0];
                  stringb = 0;
                }
                v96 = 0;
                tokena = 272;
                goto LABEL_158;
              }
LABEL_80:
              v28 = *((_BYTE *)scanner + 24);
              stringb = -1;
              tokena = 278;
              v29 = v28 & 3;
              goto LABEL_81;
            }
            end[0] = stringa + 1;
            skip_sgml_space(scanner, end);
            v80 = end[0];
            v24->string.string = end[0];
            for ( n = end[0]; n < scanner->end; end[0] = ++n )
            {
              if ( (sgml_scanner_info.scan_table[*n] & 4) == 0 )
                break;
            }
            v48 = 1;
            tokena = map_dom_scanner_string(scanner, v80, n, 266);
            stringb = end[0] - v24->string.string;
            skip_sgml_space(scanner, end);
            if ( (sgml_scanner_info.scan_table[*(end[0] - 1)] & 0x10) != 0 )
              v48 = end[0] >= scanner->end;
            v28 = *((_BYTE *)scanner + 24);
            v96 = 2;
            if ( (v28 & 3) != 3 )
              goto LABEL_158;
            if ( table_end > &v24[1] && !v48 )
            {
              for ( ii = end[0] + 1; ; ii = v83 + 1 )
              {
                v83 = skip_sgml_chars(scanner, ii, 0x3Eu);
                if ( !v83 )
                  break;
                if ( *(v83 - 1) == 63 )
                {
                  v32 = tokena;
                  state = 2;
                  goto LABEL_84;
                }
              }
              v28 = *((_BYTE *)scanner + 24);
            }
            v96 = 2;
            end[0] = scanner->end;
            v29 = v28 & 3;
          }
LABEL_81:
          if ( v29 == 3 )
            goto LABEL_160;
          goto LABEL_82;
        }
      }
      else
      {
        for ( ; v6 > position; ++position )
        {
          if ( (sgml_scanner_info.scan_table[*position] & 0x10) == 0 )
            break;
        }
LABEL_72:
        v23 = scanner->end <= position;
        scanner->position = position;
        if ( !v23 )
          goto LABEL_73;
      }
      token = scanner->current;
      if ( !assert_failed )
        goto LABEL_30;
      goto LABEL_32;
    }
    v8 = *position;
    if ( *position == 60 )
    {
      if ( state != 2 )
        goto LABEL_67;
    }
    else if ( !state )
    {
      token->string.string = position;
      v9 = position + 1;
      if ( v8 == 38 )
      {
        if ( (sgml_scanner_info.scan_table[position[1]] & 2) != 0 )
        {
          v50 = scanner->end;
          v14 = position + 1;
          if ( v9 < v50 )
          {
            do
              ++v14;
            while ( v14 < v50 && (sgml_scanner_info.scan_table[*v14] & 2) != 0 );
            v15 = v14 - v9;
          }
          else
          {
            v15 = 0;
          }
          token->string.string = v9;
          v42 = 275;
        }
        else
        {
          v14 = position + 1;
          v15 = -1;
          v42 = 278;
        }
        v97 = scanner->end;
        if ( v14 < v97 )
        {
          v43 = *v14;
          if ( *v14 != 60 && v43 != 38 )
          {
            if ( v43 == 59 )
            {
LABEL_207:
              ++v14;
              token->type = v42;
              if ( v15 >= 0 )
                goto LABEL_27;
              goto LABEL_26;
            }
            while ( ++v14 < v97 )
            {
              v44 = *v14;
              if ( *v14 == 60 || v44 == 38 )
                break;
              if ( v44 == 59 )
                goto LABEL_207;
            }
          }
        }
        v45 = *((_BYTE *)scanner + 24);
        if ( (v45 & 3) != 3 || v14 != v97 )
        {
          v46 = scanner->found_error;
          scanner->found_error = 0;
          if ( ((v45 >> 2) & (v46 == 0)) != 0 )
          {
            v93 = v42;
            v66 = set_sgml_error(scanner, v14);
            token = v66;
            if ( !v66 )
              goto LABEL_107;
            v66->type = v93;
            if ( v15 >= 0 )
              goto LABEL_27;
          }
          else
          {
            token->type = v42;
            if ( v15 >= 0 )
              goto LABEL_27;
          }
LABEL_26:
          v15 = v14 - token->string.string;
LABEL_27:
          token->string.length = v15;
          token->precedence = 0;
          v16 = scanner->current;
          scanner->position = v14;
          goto LABEL_28;
        }
        goto LABEL_119;
      }
      v10 = sgml_scanner_info.scan_table[v8];
      if ( (v10 & 0x10) == 0 )
      {
        v11 = scanner->end;
        v12 = 276;
        v13 = *((_BYTE *)scanner + 32);
        goto LABEL_18;
      }
      v13 = *((_BYTE *)scanner + 32);
      if ( (v13 & 1) != 0 )
      {
        if ( (v10 & 8) != 0 )
          ++scanner->lineno;
        v11 = scanner->end;
        if ( v9 >= v11 )
          goto LABEL_130;
        while ( 1 )
        {
          v41 = sgml_scanner_info.scan_table[*v9];
          if ( (v41 & 0x10) == 0 )
            break;
          if ( (v41 & 8) != 0 )
            ++scanner->lineno;
          if ( ++v9 >= v11 )
            goto LABEL_130;
        }
        v12 = 276;
        if ( (v41 & 0x20) != 0 )
LABEL_130:
          v12 = 277;
      }
      else
      {
        v11 = scanner->end;
        if ( v9 >= v11 )
          goto LABEL_130;
        while ( 1 )
        {
          v47 = sgml_scanner_info.scan_table[*v9];
          if ( (v47 & 0x10) == 0 )
            break;
          if ( ++v9 >= v11 )
            goto LABEL_130;
        }
        v12 = 276;
        if ( (v47 & 0x20) != 0 )
          goto LABEL_130;
      }
LABEL_18:
      if ( (v13 & 1) != 0 )
      {
        if ( v11 > v9 )
        {
          while ( 1 )
          {
            v40 = *v9;
            if ( *v9 == 60 )
              break;
            if ( v40 != 38 )
            {
              if ( (sgml_scanner_info.scan_table[v40] & 8) != 0 )
                ++scanner->lineno;
              if ( ++v9 < v11 )
                continue;
            }
            goto LABEL_24;
          }
          if ( (*((_BYTE *)scanner + 24) & 3) != 3 )
            goto LABEL_25;
LABEL_118:
          if ( scanner->end != v9 )
            goto LABEL_25;
LABEL_119:
          set_sgml_incomplete(scanner, token);
          v16 = scanner->current;
          goto LABEL_28;
        }
      }
      else
      {
        for ( ; v9 < v11; ++v9 )
        {
          if ( *v9 == 60 )
            break;
          if ( *v9 == 38 )
            break;
        }
      }
LABEL_24:
      if ( (*((_BYTE *)scanner + 24) & 3) != 3 )
      {
LABEL_25:
        v14 = v9;
        token->type = v12;
        goto LABEL_26;
      }
      goto LABEL_118;
    }
    token->string.string = position;
    for ( jj = position + 1; ; ++jj )
    {
      if ( assert_failed )
        goto LABEL_54;
      if ( jj >= scanner->position && jj <= scanner->end )
      {
        assert_failed = 0;
LABEL_54:
        if ( (*((_BYTE *)scanner + 32) & 1) == 0 )
          goto LABEL_55;
        goto LABEL_62;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/sgml/scanner.c";
      errline = 305;
      v92 = jj;
      elinks_internal("assertion string >= scanner->position && string <= scanner->end failed!");
      jj = v92;
      if ( (*((_BYTE *)scanner + 32) & 1) == 0 )
      {
LABEL_55:
        v21 = scanner->end;
        jj = (unsigned __int8 *)memchr(jj, 62, v21 - jj);
        goto LABEL_56;
      }
LABEL_62:
      v21 = scanner->end;
      string = v21;
      if ( jj >= v21 )
        goto LABEL_101;
      v22 = 0;
      while ( 1 )
      {
        v22 -= ((sgml_scanner_info.scan_table[*jj] & 8) == 0) - 1;
        if ( *jj == 62 )
          break;
        if ( ++jj >= v21 )
          goto LABEL_101;
      }
      scanner->lineno += v22;
LABEL_56:
      if ( !jj )
        break;
      if ( *(jj - 1) == 63 )
      {
        string = jj + 1;
        v37 = jj + 1 - token->string.string - 2;
        if ( jj == (unsigned __int8 *)-1 )
        {
          string = v21;
          goto LABEL_102;
        }
        goto LABEL_104;
      }
    }
    string = v21;
LABEL_101:
    v37 = -1;
LABEL_102:
    if ( (*((_BYTE *)scanner + 24) & 3) == 3 )
      goto LABEL_119;
    v38 = scanner->found_error;
    v39 = *((_BYTE *)scanner + 24) >> 2;
    scanner->found_error = 0;
    if ( ((unsigned __int8)v39 & (v38 == 0)) == 0 || (token = set_sgml_error(scanner, v21)) != 0 )
    {
LABEL_104:
      token->type = 269;
      if ( v37 < 0 )
        v37 = string - token->string.string;
      token->string.length = v37;
      token->precedence = 0;
      scanner->state = 0;
      scanner->position = string;
    }
LABEL_107:
    v16 = scanner->current;
LABEL_28:
    token = v16 + 1;
    scanner->current = v16 + 1;
  }
  while ( table_end > &v16[1] );
LABEL_29:
  if ( !assert_failed )
  {
LABEL_30:
    assert_failed = table_end < token;
    if ( table_end < token )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
      errline = 282;
      elinks_internal("assertion end <= scanner->table + DOM_SCANNER_TOKENS failed!");
    }
  }
LABEL_32:
  v17 = -858993459 * (((char *)token - (char *)dest) >> 2);
  scanner->tokens = v17;
  scanner->current = dest;
  if ( scanner->position >= scanner->end )
    scanner->position = 0;
  if ( !assert_failed )
  {
    if ( v17 <= 9
      || &scanner->current[1] < (dom_scanner_token *)((char *)scanner->table + 4 * (((char *)token - (char *)dest) >> 2)) )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/dom/scanner.h";
      errline = 289;
      elinks_internal("assertion check_dom_scanner(scanner) failed!");
    }
  }
  v18 = scanner->tokens;
  if ( v18 <= 0 )
    return 0;
  result = scanner->current;
  if ( result >= &scanner->table[v18] )
    return 0;
  return result;
}

//----- (080AA1E0) --------------------------------------------------------
sgml_info *__cdecl get_sgml_info(sgml_document_type doctype)
{
  sgml_info *result; // eax

  result = 0;
  if ( (unsigned int)doctype <= SGML_DOCTYPE_XBEL )
    return sgml_info_0[doctype];
  return result;
}

//----- (080AA200) --------------------------------------------------------
int __cdecl sgml_info_strcmp(const void *key_, const void *node_)
{
  size_t v2; // eax
  int result; // eax

  v2 = *(_DWORD *)node_;
  if ( *((_DWORD *)key_ + 1) <= *(_DWORD *)node_ )
    v2 = *((_DWORD *)key_ + 1);
  result = c_strncasecmp(*((const char **)key_ + 2), *((const char **)node_ + 1), v2);
  if ( !result )
    return *((_DWORD *)key_ + 1) - *(_DWORD *)node_;
  return result;
}

//----- (080AA250) --------------------------------------------------------
void __cdecl bzip2_close(stream_encoded *stream)
{
  int *data; // ebx

  data = (int *)stream->data;
  if ( data )
  {
    BZ2_bzDecompressEnd((bz_stream *)stream->data);
    close(data[12]);
    mem_free(data);
    stream->data = 0;
  }
}

//----- (080AA2A0) --------------------------------------------------------
int __cdecl bzip2_read(stream_encoded *stream, unsigned __int8 *buf, int len)
{
  bz_stream *data; // ebx
  int result; // eax
  int next_in; // edi
  ssize_t v6; // eax
  int v7; // eax
  int avail_out; // eax

  data = (bz_stream *)stream->data;
  if ( !data )
    return -1;
  if ( !assert_failed )
  {
    assert_failed = len <= 0;
    if ( len <= 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
      errline = 89;
      elinks_internal("assertion len > 0 failed!");
    }
  }
  result = 0;
  if ( !data[1].avail_in )
  {
    data->avail_out = len;
    data->next_out = (char *)buf;
    while ( 1 )
    {
      if ( !data->avail_in )
      {
        next_in = (int)data[1].next_in;
        while ( 1 )
        {
          v6 = read(next_in, &data[1].total_in_lo32, 0x1388u);
          if ( v6 != -1 )
            break;
          v7 = *__errno_location();
          if ( v7 != 4 )
          {
            if ( v7 != 11 )
              return -1;
            avail_out = data->avail_out;
            goto LABEL_23;
          }
        }
        if ( !v6 )
          return -1;
        data->next_in = (char *)&data[1].total_in_lo32;
        data->avail_in = v6;
      }
      avail_out = BZ2_bzDecompress(data);
      if ( avail_out == 4 )
        break;
      if ( avail_out )
        return -1;
      if ( !data->avail_out )
      {
        if ( assert_failed )
          return len - avail_out;
        goto LABEL_18;
      }
    }
    data[1].avail_in = 1;
    avail_out = data->avail_out;
LABEL_23:
    if ( !assert_failed )
    {
LABEL_18:
      assert_failed = len - avail_out != data->next_out - (char *)buf;
      if ( assert_failed )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
        errline = 124;
        elinks_internal("assertion len - data->fbz_stream.avail_out == data->fbz_stream.next_out - (char *) buf failed!");
      }
      avail_out = data->avail_out;
    }
    return len - avail_out;
  }
  return result;
}

//----- (080AA410) --------------------------------------------------------
int __cdecl bzip2_open(stream_encoded *stream, int fd)
{
  bz_stream *v2; // eax
  bz_stream *v3; // ebx
  int result; // eax

  v2 = (bz_stream *)mem_alloc(0x13C0u);
  stream->data = 0;
  v3 = v2;
  result = -1;
  if ( v3 )
  {
    memset(v3, 0, sizeof(bz_stream));
    v3[1].avail_in = 0;
    v3[1].next_in = (char *)fd;
    if ( BZ2_bzDecompressInit(v3, 0, 0) )
    {
      mem_free(v3);
      return -1;
    }
    else
    {
      stream->data = v3;
      return 0;
    }
  }
  return result;
}

//----- (080AA4A0) --------------------------------------------------------
unsigned __int8 *__cdecl bzip2_decode_buffer(unsigned __int8 *data, int len, int *new_len)
{
  unsigned __int8 *v3; // edi
  unsigned __int8 *v4; // edi
  int v5; // eax
  unsigned int total_out_lo32; // edi
  unsigned __int8 *p; // [esp+1Ch] [ebp-4Ch]
  bz_stream stream; // [esp+20h] [ebp-48h] BYREF

  *new_len = 0;
  memset(&stream, 0, sizeof(stream));
  v3 = 0;
  stream.next_in = (char *)data;
  stream.avail_in = len;
  p = 0;
  if ( !BZ2_bzDecompressInit(&stream, 0, 0) )
  {
    while ( 1 )
    {
      total_out_lo32 = stream.total_out_lo32;
      if ( !assert_failed )
      {
        assert_failed = stream.total_out_hi32 != 0;
        if ( stream.total_out_hi32 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/bzip2.c";
          errline = 159;
          elinks_internal("assertion !stream.total_out_hi32 failed: 64 bzip2 decoding not supported");
        }
      }
      v4 = (unsigned __int8 *)mem_realloc(p, total_out_lo32 + 1024);
      if ( !v4 )
        break;
      stream.avail_out = 1024;
      stream.next_out = (char *)&v4[stream.total_out_lo32];
      v5 = BZ2_bzDecompress(&stream);
      if ( v5 == 4 )
        goto LABEL_13;
      if ( v5 )
      {
        BZ2_bzDecompressEnd(&stream);
        p = v4;
LABEL_11:
        v3 = 0;
        mem_free(p);
        return v3;
      }
      p = v4;
      if ( !stream.avail_in )
      {
LABEL_13:
        BZ2_bzDecompressEnd(&stream);
        *new_len = stream.total_out_lo32;
        return v4;
      }
    }
    v3 = p;
    BZ2_bzDecompressEnd(&stream);
    if ( p )
      goto LABEL_11;
  }
  return v3;
}

//----- (080AA5E0) --------------------------------------------------------
void __cdecl deflate_close(stream_encoded *stream)
{
  int *data; // ebx

  data = (int *)stream->data;
  if ( data )
  {
    inflateEnd((z_streamp)stream->data);
    close(data[14]);
    mem_free(data);
    stream->data = 0;
  }
}

//----- (080AA630) --------------------------------------------------------
int __cdecl deflate_read(stream_encoded *stream, unsigned __int8 *buf, int len)
{
  char *data; // ebx
  int result; // eax
  ssize_t v5; // edi
  int v6; // edi
  ssize_t v7; // eax
  int v8; // eax
  int v9; // eax
  char v10; // dl
  char v11; // cl
  char v12; // dl
  int v13; // eax
  void *v14; // [esp+1Ch] [ebp-1Ch]

  data = (char *)stream->data;
  if ( !data )
    return -1;
  if ( !assert_failed )
  {
    assert_failed = len <= 0;
    if ( len <= 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/deflate.c";
      errline = 100;
      elinks_internal("assertion len > 0 failed!");
    }
  }
  result = 0;
  if ( (data[60] & 1) == 0 )
  {
    v5 = 0;
    *((_DWORD *)data + 3) = buf;
    *((_DWORD *)data + 4) = len;
    v14 = data + 61;
LABEL_5:
    if ( *((_DWORD *)data + 1) )
      goto LABEL_14;
    v6 = *((_DWORD *)data + 14);
    do
    {
      v7 = read(v6, v14, 0x1388u);
      if ( v7 != -1 )
      {
        v5 = v7;
        if ( !v7 )
          return -1;
        *((_DWORD *)data + 1) = v7;
        *(_DWORD *)data = v14;
LABEL_14:
        do
        {
          v9 = inflate((z_streamp)data, 2);
          if ( v9 != -3 )
            break;
          v10 = data[60];
          if ( (v10 & 2) != 0 || *((unsigned __int8 **)data + 3) != buf )
          {
            v12 = v10 | 2;
            data[60] = v12;
            goto LABEL_28;
          }
          data[60] = v10 | 2;
          inflateEnd((z_streamp)data);
          *((_DWORD *)data + 3) = buf;
          *((_DWORD *)data + 4) = len;
          *((_DWORD *)data + 1) = v5;
          *(_DWORD *)data = v14;
          v9 = inflateInit2_((z_streamp)data, -15, "1.2.3.4", 56);
        }
        while ( !v9 );
        v11 = data[60];
        v12 = v11 | 2;
        data[60] = v11 | 2;
        if ( v9 == 1 )
        {
          v13 = *((_DWORD *)data + 4);
          data[60] = v11 | 3;
        }
        else
        {
          if ( v9 )
          {
LABEL_28:
            v13 = *((_DWORD *)data + 4);
            data[60] = v12 | 1;
            goto LABEL_22;
          }
          if ( *((_DWORD *)data + 4) )
            goto LABEL_5;
          v13 = 0;
        }
LABEL_22:
        if ( !assert_failed )
          goto LABEL_23;
        return len - v13;
      }
      v8 = *__errno_location();
    }
    while ( v8 == 4 );
    if ( v8 != 11 )
      return -1;
    v13 = *((_DWORD *)data + 4);
    if ( !assert_failed )
    {
LABEL_23:
      assert_failed = len - v13 != *((_DWORD *)data + 3) - (_DWORD)buf;
      if ( assert_failed )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/deflate.c";
        errline = 168;
        elinks_internal("assertion len - data->deflate_stream.avail_out == data->deflate_stream.next_out - buf failed!");
      }
      v13 = *((_DWORD *)data + 4);
    }
    return len - v13;
  }
  return result;
}

//----- (080AA840) --------------------------------------------------------
int __cdecl deflate_gzip_open(stream_encoded *stream, int fd)
{
  z_stream *v2; // eax
  z_stream *v3; // ebx
  int result; // eax

  v2 = (z_stream *)mem_alloc(0x13C8u);
  stream->data = 0;
  v3 = v2;
  result = -1;
  if ( v3 )
  {
    memset(v3, 0, sizeof(z_stream));
    LOBYTE(v3[1].avail_in) &= 0xFCu;
    v3[1].next_in = (Bytef *)fd;
    if ( inflateInit2_(v3, 47, "1.2.3.4", 56) )
    {
      mem_free(v3);
      return -1;
    }
    else
    {
      stream->data = v3;
      return 0;
    }
  }
  return result;
}

//----- (080AA8D0) --------------------------------------------------------
unsigned __int8 *__usercall deflate_decode_buffer@<eax>(
        int window_size@<eax>,
        unsigned __int8 *data@<edx>,
        int len@<ecx>,
        int *new_len)
{
  void *v4; // ebx
  void *v6; // esi
  char *v7; // eax
  int v8; // eax
  z_stream stream; // [esp+28h] [ebp-50h] BYREF

  *new_len = 0;
  if ( !len )
    return 0;
  memset(&stream, 0, sizeof(stream));
  stream.avail_in = len;
  stream.next_in = data;
  if ( inflateInit2_(&stream, window_size, "1.2.3.4", 56) )
    return 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = (char *)mem_realloc(v6, stream.total_out + 1024);
    v4 = v7;
    if ( !v7 )
      break;
    stream.avail_out = 1024;
    stream.next_out = (Bytef *)&v7[stream.total_out];
    v8 = inflate(&stream, 2);
    if ( v8 == 1 )
      goto LABEL_10;
    if ( v8 )
    {
      v6 = v4;
      inflateEnd(&stream);
      goto LABEL_12;
    }
    v6 = v4;
    if ( !stream.avail_in )
    {
LABEL_10:
      inflateEnd(&stream);
      *new_len = stream.total_out;
      return (unsigned __int8 *)v4;
    }
  }
  v4 = v6;
  inflateEnd(&stream);
  if ( !v6 )
    return (unsigned __int8 *)v4;
LABEL_12:
  v4 = 0;
  mem_free(v6);
  return (unsigned __int8 *)v4;
}

//----- (080AA9F0) --------------------------------------------------------
unsigned __int8 *__cdecl deflate_gzip_decode_buffer(unsigned __int8 *data, int len, int *new_len)
{
  return deflate_decode_buffer(47, data, len, new_len);
}

//----- (080AAA10) --------------------------------------------------------
unsigned __int8 *__cdecl deflate_raw_decode_buffer(unsigned __int8 *data, int len, int *new_len)
{
  return deflate_decode_buffer(-15, data, len, new_len);
}

//----- (080AAA30) --------------------------------------------------------
int __cdecl read_encoded(stream_encoded *stream, unsigned __int8 *data, int len)
{
  return ((int (*)(void))decoding_backends[stream->encoding]->read)();
}

//----- (080AAA50) --------------------------------------------------------
unsigned __int8 *__cdecl decode_encoded_buffer(stream_encoding encoding, unsigned __int8 *data, int len, int *new_len)
{
  return decoding_backends[encoding]->decode_buffer(data, len, new_len);
}

//----- (080AAA80) --------------------------------------------------------
const unsigned __int8 *const *__cdecl listext_encoded(stream_encoding encoding)
{
  return decoding_backends[encoding]->extensions;
}

//----- (080AAAA0) --------------------------------------------------------
const unsigned __int8 *__cdecl get_encoding_name(stream_encoding encoding)
{
  return decoding_backends[encoding]->name;
}

//----- (080AAAC0) --------------------------------------------------------
connection_basic_state *__usercall connection_state_8@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080AAB50) --------------------------------------------------------
void __cdecl dummy_close(stream_encoded *stream)
{
  close(*(_DWORD *)stream->data);
  mem_free(stream->data);
}

//----- (080AAB80) --------------------------------------------------------
void __cdecl close_encoded(stream_encoded *stream)
{
  decoding_backends[stream->encoding]->close(stream);
  mem_free(stream);
}

//----- (080AABB0) --------------------------------------------------------
unsigned __int8 *__cdecl dummy_decode_buffer(unsigned __int8 *data, int len, int *new_len)
{
  unsigned __int8 *result; // eax

  result = memacpy(data, len);
  if ( result )
    *new_len = len;
  return result;
}

//----- (080AABE0) --------------------------------------------------------
int __cdecl dummy_read(stream_encoded *stream, unsigned __int8 *data, int len)
{
  int v3; // esi
  int v4; // ebx

  v3 = *(_DWORD *)stream->data;
  do
    v4 = read(v3, data, len);
  while ( v4 == -1 && *__errno_location() == 4 );
  return v4;
}

//----- (080AAC30) --------------------------------------------------------
int __cdecl dummy_open(stream_encoded *stream, int fd)
{
  _DWORD *v2; // eax
  int v3; // edx

  v2 = mem_alloc(4u);
  stream->data = v2;
  v3 = -1;
  if ( v2 )
  {
    *v2 = fd;
    return 0;
  }
  return v3;
}

//----- (080AAC60) --------------------------------------------------------
stream_encoded *__cdecl open_encoded(int fd, stream_encoding encoding)
{
  stream_encoded *v2; // eax
  stream_encoded *v3; // ebx
  stream_encoded *v5; // [esp+0h] [ebp-18h]

  v2 = (stream_encoded *)mem_alloc(8u);
  v3 = v2;
  if ( v2 )
  {
    v2->encoding = encoding;
    if ( decoding_backends[encoding]->open(v2, fd) < 0 )
    {
      v5 = v3;
      v3 = 0;
      mem_free(v5);
    }
  }
  return v3;
}

//----- (080AACC0) --------------------------------------------------------
stream_encoding __cdecl guess_encoding(unsigned __int8 *filename)
{
  signed int v1; // edi
  const char **i; // ebx
  signed int v3; // eax
  const char *v4; // esi
  int enc; // [esp+18h] [ebp-20h]

  enc = 1;
  v1 = strlen((const char *)filename);
  do
  {
    for ( i = (const char **)decoding_backends[enc]->extensions; i; ++i )
    {
      v4 = *i;
      if ( !*i )
        break;
      v3 = strlen(*i);
      if ( v1 >= v3 && !strcmp((const char *)&filename[v1 - v3], v4) )
        return enc;
    }
    ++enc;
  }
  while ( enc != 5 );
  return 0;
}

//----- (080AAD50) --------------------------------------------------------
connection_state *__userpurge read_file@<eax>(
        connection_state *retstr,
        stream_encoded *stream,
        int readsize,
        string *page)
{
  int v4; // eax
  int length; // edi
  int v6; // eax
  unsigned int v7; // esi
  unsigned int v8; // edi
  unsigned __int8 *v9; // eax
  connection_basic_state v10; // eax
  int v12; // eax
  connection_basic_state v13; // eax
  int v14; // [esp+1Ch] [ebp-1Ch]
  int readsizea; // [esp+48h] [ebp+10h]

  if ( init_string(page) )
  {
    v4 = 4096;
    if ( readsize )
      v4 = readsize;
    readsizea = v4;
    length = page->length;
    v14 = v4 + 1;
    while ( 1 )
    {
      v7 = (length + v14 + 255) & 0xFFFFFF00;
      v8 = (length + 255) & 0xFFFFFF00;
      if ( v7 > v8 )
      {
        v9 = (unsigned __int8 *)mem_realloc(page->source, v7);
        if ( !v9 )
        {
LABEL_12:
          done_string(page);
          if ( assert_failed )
          {
            assert_failed = 0;
            v10 = S_INTERNAL;
          }
          else
          {
            assert_failed = 0;
            v10 = S_OUT_OF_MEM;
          }
          retstr->syserr = 0;
          retstr->basic = v10;
          return retstr;
        }
        page->source = v9;
        memset(&v9[v8], 0, v7 - v8);
      }
      if ( !page->source )
        goto LABEL_12;
      v6 = decoding_backends[stream->encoding]->read(stream, &page->source[page->length], readsizea);
      if ( v6 < 0 )
      {
        done_string(page);
        v12 = *__errno_location();
        if ( v12 )
        {
          retstr->syserr = v12;
          retstr->basic = S_ERRNO;
        }
        else
        {
          connection_state_8(S_ENCODE_ERROR, &retstr->basic);
        }
        return retstr;
      }
      if ( !v6 )
      {
        page->source[page->length] = 0;
        if ( assert_failed )
        {
          assert_failed = 0;
          v13 = S_INTERNAL;
        }
        else
        {
          assert_failed = 0;
          v13 = S_OK;
        }
        retstr->syserr = 0;
        retstr->basic = v13;
        return retstr;
      }
      length = v6 + page->length;
      page->length = length;
    }
  }
  connection_state_8(S_OUT_OF_MEM, &retstr->basic);
  return retstr;
}

//----- (080AAF20) --------------------------------------------------------
connection_state *__userpurge read_encoded_file@<eax>(connection_state *retstr, string *filename, string *page)
{
  int v3; // ebx
  connection_basic_state basic; // esi
  stream_encoded *v6; // eax
  int v7; // eax
  int v8; // eax
  int length; // ebx
  const unsigned __int8 **extensions; // edi
  bool v11; // zf
  stream_encoded *v12; // [esp+14h] [ebp-94h]
  int v13; // [esp+18h] [ebp-90h]
  stream_encoding encoding; // [esp+1Ch] [ebp-8Ch]
  int *v15; // [esp+20h] [ebp-88h]
  int syserr; // [esp+24h] [ebp-84h]
  connection_state v17; // [esp+28h] [ebp-80h] BYREF
  stat stt; // [esp+30h] [ebp-78h] BYREF

  v3 = open64(filename->source, 256);
  v15 = __errno_location();
  syserr = *v15;
  if ( v3 != -1 )
  {
    encoding = guess_encoding(filename->source);
    goto LABEL_3;
  }
  if ( get_opt_(config_options, "protocol.file.try_encoding_extensions")->number )
  {
    v8 = -1;
    v13 = 1;
    length = filename->length;
    do
    {
      encoding = v13;
      extensions = (const unsigned __int8 **)decoding_backends[v13]->extensions;
      if ( extensions )
      {
        while ( *extensions )
        {
          add_to_string(filename, *extensions);
          v8 = open64(filename->source, 256);
          if ( v8 >= 0 )
          {
            v3 = v8;
            goto LABEL_3;
          }
          v11 = ++extensions == 0;
          filename->source[length] = 0;
          filename->length = length;
          if ( v11 )
            break;
        }
      }
      ++v13;
    }
    while ( v13 != 5 );
    v3 = v8;
    if ( v8 != -1 )
    {
      encoding = ENCODING_NONE;
LABEL_3:
      set_bin(v3);
      if ( __fxstat64(3, v3, &stt) )
      {
        basic = S_ERRNO;
        syserr = *v15;
LABEL_5:
        close(v3);
        retstr->basic = basic;
        retstr->syserr = syserr;
        return retstr;
      }
      if ( encoding )
      {
        basic = S_ERRNO;
        if ( (stt.st_mode & 0xF000) != 0x8000 )
          goto LABEL_5;
      }
      else if ( (stt.st_mode & 0xF000) != 0x8000 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/encoding/encoding.c";
        errline = 286;
        if ( elinks_strlcmp(filename->source, filename->length, &byte_813154A, 0xAu)
          || (v7 = stt.st_mode & 0xF000, v7 != 4096) && v7 != 49152 )
        {
          if ( !get_opt_(config_options, "protocol.file.allow_special_files")->number )
          {
            connection_state_8(S_FILE_TYPE, &v17.basic);
            basic = v17.basic;
            syserr = v17.syserr;
            goto LABEL_5;
          }
        }
      }
      v6 = open_encoded(v3, encoding);
      if ( v6 )
      {
        if ( HIDWORD(stt.st_size) == SLODWORD(stt.st_size) >> 31 && SLODWORD(stt.st_size) >= 0 )
        {
          v12 = v6;
          read_file(&v17, v6, stt.st_size, page);
          basic = v17.basic;
          v6 = v12;
          syserr = v17.syserr;
        }
        else
        {
          syserr = 27;
          basic = S_ERRNO;
        }
        close_encoded(v6);
      }
      else
      {
        connection_state_8(S_OUT_OF_MEM, &v17.basic);
        basic = v17.basic;
        syserr = v17.syserr;
      }
      goto LABEL_5;
    }
  }
  retstr->basic = S_ERRNO;
  retstr->syserr = syserr;
  return retstr;
}
// 8059818: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);
// 80598F8: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (080AB220) --------------------------------------------------------
void __cdecl lock_formhist_data(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (080AB230) --------------------------------------------------------
void __cdecl unlock_formhist_data(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (080AB240) --------------------------------------------------------
int __cdecl is_formhist_data_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (080AB260) --------------------------------------------------------
listbox_item *__cdecl get_formhist_data_root(listbox_item *item)
{
  return 0;
}

//----- (080AB270) --------------------------------------------------------
int __cdecl can_delete_formhist_data(listbox_item *item)
{
  return 1;
}

//----- (080AB280) --------------------------------------------------------
void __cdecl delete_formhist_data(listbox_item *item, int last)
{
  formhist_data *udata; // ebx
  int refcount; // ecx

  udata = (formhist_data *)item->udata;
  if ( !assert_failed && (refcount = udata->object.refcount, assert_failed = refcount != 0, refcount) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/formhist/dialogs.c";
    errline = 113;
    elinks_internal("assertion !is_object_used(formhist_data) failed!");
    delete_formhist_item(udata);
  }
  else
  {
    delete_formhist_item(udata);
  }
}

//----- (080AB2F0) --------------------------------------------------------
uri *__cdecl get_formhist_data_uri(listbox_item *item)
{
  return get_uri((unsigned __int8 *)item->udata + 21, (uri_component)0);
}

//----- (080AB320) --------------------------------------------------------
unsigned __int8 *__usercall _4@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (080AB390) --------------------------------------------------------
unsigned __int8 *__cdecl get_formhist_data_info(listbox_item *item, terminal *term)
{
  const char *udata; // esi
  const char *v4; // eax
  const unsigned __int8 *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  unsigned __int8 *v8; // eax
  _BYTE *v9; // eax
  string info; // [esp+18h] [ebp-20h] BYREF

  udata = (const char *)item->udata;
  if ( item->type == BI_FOLDER || !init_string(&info) )
    return 0;
  v4 = (const char *)_4((unsigned __int8 *)&byte_812B6C9, term);
  add_format_to_string(&info, "%s: %s", v4, udata + 21);
  add_char_to_string(&info, 0xAu);
  if ( (udata[20] & 1) != 0 )
    v5 = _4("Forms are never saved for this URL.", term);
  else
    v5 = _4("Forms are saved for this URL.", term);
  add_to_string(&info, v5);
  add_char_to_string(&info, 0xAu);
  v6 = (_DWORD *)*((_DWORD *)udata + 3);
  v7 = (_DWORD *)*v6;
  if ( (_DWORD *)*v6 != v6 )
  {
    do
    {
      v8 = form_type2str((form_type)v7[5]);
      add_format_to_string(&info, "\n[%8s] ", (const char *)v8);
      add_to_string(&info, (const unsigned __int8 *)v7[2]);
      add_to_string(&info, " = ");
      v9 = (_BYTE *)v7[3];
      if ( v9 && *v9 )
      {
        if ( v7[5] == 1 )
          add_to_string(&info, "********");
        else
          add_to_string(&info, (const unsigned __int8 *)v7[3]);
      }
      v7 = (_DWORD *)*v7;
    }
    while ( *((_DWORD **)udata + 3) != v7 );
  }
  return info.source;
}

//----- (080AB4F0) --------------------------------------------------------
unsigned __int8 *__cdecl get_formhist_data_text(listbox_item *item, terminal *term)
{
  return stracpy((const unsigned __int8 *)item->udata + 21);
}

//----- (080AB510) --------------------------------------------------------
widget_handler_status_T __cdecl push_save_button_2(dialog_data *dlg_data, widget_data *button)
{
  save_formhist_to_file();
  return 0;
}

//----- (080AB520) --------------------------------------------------------
widget_handler_status_T __cdecl push_toggle_dontsave_button(dialog_data *dlg_data, widget_data *button)
{
  listbox_item *sel; // eax
  _BYTE *udata; // eax

  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( sel )
  {
    udata = sel->udata;
    if ( udata )
      udata[20] = (udata[20] ^ 1) & 1 | udata[20] & 0xFE;
  }
  return 0;
}

//----- (080AB560) --------------------------------------------------------
widget_handler_status_T __cdecl push_login_button(dialog_data *dlg_data, widget_data *button)
{
  listbox_item *sel; // eax
  _BYTE *udata; // eax

  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( !sel )
    return 0;
  udata = sel->udata;
  if ( !udata )
    return 0;
  if ( (udata[20] & 1) == 0 )
  {
    push_hierbox_goto_button(dlg_data, button);
    return 0;
  }
  info_box(
    dlg_data->win->term,
    (msgbox_flags)0,
    "Form not saved",
    ALIGN_CENTER,
    "No saved information for this URL.\n"
    "If you want to save passwords for this URL, enable it by pressing the \"Toggle saving\" button.");
  return 0;
}

//----- (080AB5E0) --------------------------------------------------------
void __cdecl formhist_manager(session *ses)
{
  load_formhist_from_file();
  hierbox_browser_0(&formhist_browser, ses);
}

//----- (080AB600) --------------------------------------------------------
formhist_data *__usercall new_formhist_item@<eax>(unsigned __int8 *url@<eax>)
{
  size_t v2; // edi
  char *v3; // eax
  void *v4; // ebx
  _DWORD *v5; // eax
  listbox_item *v6; // eax
  void *v8; // [esp+0h] [ebp-38h]

  v2 = strlen((const char *)url);
  v3 = (char *)mem_calloc(1u, v2 + 24);
  v4 = v3;
  if ( v3 )
  {
    memcpy(v3 + 21, url, v2);
    v5 = mem_alloc(8u);
    *((_DWORD *)v4 + 3) = v5;
    if ( v5 )
    {
      v5[1] = v5;
      *v5 = v5;
      v6 = add_listbox_item(&formhist_browser, 0, BI_LEAF, v4, 1);
      *((_DWORD *)v4 + 4) = v6;
      if ( v6 )
        return (formhist_data *)v4;
      mem_free(*((void **)v4 + 3));
    }
    v8 = v4;
    v4 = 0;
    mem_free(v8);
  }
  return (formhist_data *)v4;
}

//----- (080AB6C0) --------------------------------------------------------
void __usercall done_formhist_item(formhist_data *form@<eax>)
{
  done_listbox_item(&formhist_browser, form->box_item);
  done_submitted_value_list(form->submit);
  mem_free(form->submit);
  mem_free(form);
}

//----- (080AB700) --------------------------------------------------------
void __cdecl dont_remember_form(void *form_)
{
  done_formhist_item((formhist_data *)form_);
}

//----- (080AB710) --------------------------------------------------------
void __cdecl delete_formhist_item(formhist_data *form)
{
  form->next->prev = form->prev;
  form->prev->next = form->next;
  done_formhist_item(form);
}

//----- (080AB730) --------------------------------------------------------
void __cdecl done_form_history(module *module)
{
  formhist_data *next; // eax
  list_head_elinks *v2; // ebx

  next = (formhist_data *)saved_forms.next;
  v2 = *(list_head_elinks **)saved_forms.next;
  if ( saved_forms.next != &saved_forms )
  {
    while ( 1 )
    {
      delete_formhist_item(next);
      next = (formhist_data *)v2;
      if ( &saved_forms == v2 )
        break;
      v2 = (list_head_elinks *)v2->next;
    }
  }
}

//----- (080AB770) --------------------------------------------------------
int save_formhist_to_file()
{
  int result; // eax
  unsigned __int8 *v1; // eax
  unsigned __int8 *v2; // ebx
  bool v3; // zf
  _DWORD *prev; // eax
  _DWORD *v5; // ebx
  unsigned __int8 *v6; // esi
  const char *v7; // edi
  unsigned __int8 *v8; // eax
  _BYTE *v9; // eax
  secure_save_info *ssi; // [esp+28h] [ebp-20h]
  list_head_elinks *next; // [esp+2Ch] [ebp-1Ch]

  if ( !elinks_home )
    return 0;
  if ( get_opt_(cmdline_options, "anonymous")->number )
    return 0;
  v1 = straconcat((const unsigned __int8 *)elinks_home, "formhist", 0);
  v2 = v1;
  if ( !v1 )
    return 0;
  ssi = secure_open(v1);
  mem_free(v2);
  if ( !ssi )
    return 0;
  if ( saved_forms.next == &saved_forms )
  {
LABEL_12:
    result = secure_close(ssi);
    if ( !result )
      loaded = 1;
    return result;
  }
  next = (list_head_elinks *)saved_forms.next;
  while ( ((int)next[2].prev & 1) != 0 )
  {
    secure_fprintf(ssi, "dontsave\t%s\n\n", (const char *)&next[2].prev + 1);
LABEL_11:
    v3 = &saved_forms == next->next;
    next = (list_head_elinks *)next->next;
    if ( v3 )
      goto LABEL_12;
  }
  secure_fprintf(ssi, "%s\n", (const char *)&next[2].prev + 1);
  prev = next[1].prev;
  v5 = (_DWORD *)*prev;
  if ( (_DWORD *)*prev == prev )
  {
LABEL_22:
    secure_fputc(ssi, 10);
    goto LABEL_11;
  }
  while ( 1 )
  {
    v9 = (_BYTE *)v5[3];
    if ( v9 && *v9 )
      v6 = base64_encode((unsigned __int8 *)v5[3]);
    else
      v6 = stracpy((const unsigned __int8 *)&delete);
    if ( !v6 )
      return 0;
    v7 = (const char *)v5[2];
    v8 = form_type2str((form_type)v5[5]);
    secure_fprintf(ssi, "%s\t%s\t%s\n", (const char *)v8, v7, (const char *)v6);
    mem_free(v6);
    v5 = (_DWORD *)*v5;
    if ( next[1].prev == v5 )
      goto LABEL_22;
  }
}

//----- (080AB910) --------------------------------------------------------
void __cdecl remember_form(void *form_)
{
  formhist_data *next; // esi
  list_head_elinks *v2; // ebx
  list_head_elinks *v3; // eax
  void *v4; // eax

  next = (formhist_data *)saved_forms.next;
  v2 = *(list_head_elinks **)saved_forms.next;
  if ( saved_forms.next != &saved_forms )
  {
    while ( 1 )
    {
      if ( !strcmp((const char *)next->url, (const char *)form_ + 21) )
      {
        delete_formhist_item(next);
        v3 = (list_head_elinks *)v2->next;
        if ( &saved_forms == v2 )
          break;
      }
      else
      {
        v3 = (list_head_elinks *)v2->next;
        if ( &saved_forms == v2 )
          break;
      }
      next = (formhist_data *)v2;
      v2 = v3;
    }
  }
  v4 = saved_forms.next;
  *((_DWORD *)form_ + 1) = &saved_forms;
  *(_DWORD *)form_ = v4;
  saved_forms.next = form_;
  *(_DWORD *)(*(_DWORD *)form_ + 4) = form_;
  save_formhist_to_file();
}

//----- (080AB990) --------------------------------------------------------
void __cdecl never_for_this_site(void *form_)
{
  *((_BYTE *)form_ + 20) |= 1u;
  remember_form(form_);
}

//----- (080AB9B0) --------------------------------------------------------
int load_formhist_from_file()
{
  int result; // eax
  unsigned __int8 *v1; // eax
  unsigned __int8 *v2; // ebx
  char *v3; // eax
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // edx
  _BOOL4 v6; // esi
  formhist_data *v7; // eax
  formhist_data *v8; // ebx
  char *v9; // eax
  unsigned __int8 *v10; // edi
  const char *v11; // esi
  char *v12; // eax
  char *v13; // edi
  char *v14; // eax
  int v15; // esi
  unsigned __int8 *v16; // edi
  submitted_value *inited; // esi
  formhist_data *next; // eax
  FILE *f; // [esp+34h] [ebp-434h]
  unsigned __int8 *name; // [esp+38h] [ebp-430h]
  unsigned __int8 *value; // [esp+3Ch] [ebp-42Ch]
  unsigned __int8 tmp[1024]; // [esp+4Ch] [ebp-41Ch] BYREF
  unsigned int v23; // [esp+44Ch] [ebp-1Ch]

  v23 = __readgsdword(0x14u);
  result = 1;
  if ( !loaded )
  {
    if ( elinks_home
      && (v1 = straconcat((const unsigned __int8 *)elinks_home, "formhist", 0), (v2 = v1) != 0)
      && (f = (FILE *)fopen64(v1, "rb"), mem_free(v2), f) )
    {
      while ( 1 )
      {
LABEL_5:
        if ( !fgets((char *)tmp, 1024, f) )
        {
          fclose(f);
          result = 1;
          loaded = 1;
          return result;
        }
        if ( tmp[0] != 10 || tmp[1] )
        {
          v3 = strchr((const char *)tmp, 9);
          if ( v3 )
          {
            *v3 = 0;
            v4 = (unsigned __int8 *)(v3 + 1);
            v5 = (unsigned __int8 *)(v3 + 1);
            v6 = strcmp((const char *)tmp, "dontsave") == 0;
          }
          else if ( !memcmp(tmp, "dontsave,", 9u) )
          {
            v5 = &tmp[9];
            v6 = 1;
            v4 = &tmp[9];
          }
          else
          {
            v5 = tmp;
            v6 = 0;
            v4 = tmp;
          }
          v4[strlen((const char *)v5) - 1] = 0;
          v7 = new_formhist_item(v4);
          v8 = v7;
          if ( v7 )
            break;
        }
      }
      if ( v6 )
        *((_BYTE *)v7 + 20) |= 1u;
      while ( 1 )
      {
        if ( !fgets((char *)tmp, 1024, f) || tmp[0] == 10 && !tmp[1] )
        {
          next = (formhist_data *)saved_forms.next;
          v8->prev = (formhist_data *)&saved_forms;
          v8->next = next;
          saved_forms.next = v8;
          v8->next->prev = v8;
          goto LABEL_5;
        }
        v9 = strchr((const char *)tmp, 9);
        if ( !v9 )
          break;
        v10 = (unsigned __int8 *)(v9 + 1);
        *v9 = 0;
        v11 = v9 + 1;
        v12 = strchr(v9 + 1, 9);
        if ( v12 )
        {
          v11 = v12 + 1;
          *v12 = 0;
          name = v10;
          v13 = (char *)tmp;
          value = (unsigned __int8 *)(v12 + 1);
        }
        else if ( tmp[0] == 42 )
        {
          v13 = "password";
          value = (unsigned __int8 *)v11;
          name = &tmp[1];
        }
        else
        {
          v13 = "text";
          value = (unsigned __int8 *)v11;
          name = tmp;
        }
        v14 = strchr(v11, 10);
        if ( !v14 )
          break;
        *v14 = 0;
        v15 = str2form_type((unsigned __int8 *)v13);
        if ( v15 == -1 )
          break;
        if ( (*((_BYTE *)v8 + 20) & 1) == 0 )
        {
          if ( *value )
            v16 = base64_decode(value);
          else
            v16 = stracpy(value);
          if ( !v16 )
            break;
          inited = init_submitted_value(name, v16, (form_type)v15, 0, 0);
          mem_free(v16);
          if ( !inited )
            break;
          inited->next = (submitted_value *)v8->submit->next;
          inited->prev = (submitted_value *)v8->submit;
          v8->submit->next = inited;
          inited->next->prev = inited;
        }
      }
      done_formhist_item(v8);
      return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080ABD60) --------------------------------------------------------
void __cdecl memorize_form(session *ses, list_head_elinks *submit, form *forminfo)
{
  list_head_elinks *next; // eax
  _BYTE *prev; // edx
  formhist_data *v5; // eax
  list_head_elinks *v6; // ebx
  formhist_data *v7; // edi
  form_type v8; // eax
  submitted_value *inited; // eax
  _DWORD *v10; // edi
  _DWORD *v11; // ebx
  void *v12; // esi
  formhist_data *udata; // [esp+64h] [ebp-34h]
  int v14; // [esp+68h] [ebp-30h]
  list_head_elinks *v15; // [esp+6Ch] [ebp-2Ch]
  list_head_elinks *v16; // [esp+70h] [ebp-28h]
  int v17; // [esp+74h] [ebp-24h]
  _DWORD *v18; // [esp+78h] [ebp-20h]
  list_head_elinks *v19; // [esp+7Ch] [ebp-1Ch]

  next = (list_head_elinks *)submit->next;
  if ( submit->next != submit )
  {
    while ( 1 )
    {
      if ( next[2].prev == (void *)1 )
      {
        prev = next[1].prev;
        if ( prev )
        {
          if ( *prev )
            break;
        }
      }
      next = (list_head_elinks *)next->next;
      if ( next == submit )
        return;
    }
    v5 = new_formhist_item(forminfo->action);
    udata = v5;
    if ( v5 )
    {
      v6 = (list_head_elinks *)submit->next;
      if ( submit->next == submit )
      {
LABEL_14:
        if ( load_formhist_from_file() )
        {
          v15 = (list_head_elinks *)saved_forms.next;
          if ( saved_forms.next != &saved_forms )
          {
            while ( 1 )
            {
              if ( !strcmp((const char *)&v15[2].prev + 1, (const char *)udata->url) )
              {
                if ( ((int)v15[2].prev & 1) != 0 )
                  goto fail;
                v16 = udata->submit;
                v19 = (list_head_elinks *)v16->next;
                if ( v16->next != v16 )
                  break;
              }
LABEL_31:
              v15 = (list_head_elinks *)v15->next;
              if ( v15 == &saved_forms )
                goto LABEL_32;
            }
            v10 = v15[1].prev;
            v14 = 0;
            v17 = 0;
            v18 = (_DWORD *)*v10;
            while ( 1 )
            {
              if ( v18 != v10 )
              {
                v11 = v18;
                v12 = v19[2].prev;
                while ( v12 != (void *)v11[5] || strcmp((const char *)v19[1].next, (const char *)v11[2]) )
                {
                  v11 = (_DWORD *)*v11;
                  if ( v11 == v10 )
                    goto LABEL_27;
                }
                ++v14;
                if ( v11[3] )
                {
                  if ( strcmp((const char *)v19[1].prev, (const char *)v11[3]) )
                    break;
                }
              }
LABEL_27:
              ++v17;
              v19 = (list_head_elinks *)v19->next;
              if ( v19 == v16 )
              {
                if ( v14 && v17 && v17 == v14 )
                  goto fail;
                goto LABEL_31;
              }
            }
          }
        }
LABEL_32:
        msg_box(
          ses->tab->term,
          0,
          (msgbox_flags)0,
          "Form history",
          ALIGN_CENTER,
          "Should this login be remembered?\n"
          "\n"
          "Please note that the password will be stored obscured (but unencrypted) in a file on your disk.\n"
          "\n"
          "If you are using a valuable password, answer NO.",
          udata,
          3,
          "~Yes",
          remember_form,
          1,
          "~No",
          dont_remember_form,
          2,
          "Ne~ver for this site",
          never_for_this_site,
          0);
      }
      else
      {
        v7 = v5;
        while ( 1 )
        {
          while ( 1 )
          {
            v8 = (form_type)v6[2].prev;
            if ( (unsigned int)v8 <= FC_PASSWORD )
              break;
            v6 = (list_head_elinks *)v6->next;
            if ( v6 == submit )
              goto LABEL_14;
          }
          inited = init_submitted_value((unsigned __int8 *)v6[1].next, (unsigned __int8 *)v6[1].prev, v8, 0, 0);
          if ( !inited )
            break;
          inited->next = (submitted_value *)v7->submit->next;
          inited->prev = (submitted_value *)v7->submit;
          v7->submit->next = inited;
          inited->next->prev = inited;
          v6 = (list_head_elinks *)v6->next;
          if ( v6 == submit )
            goto LABEL_14;
        }
fail:
        done_formhist_item(udata);
      }
    }
  }
}

//----- (080ABFF0) --------------------------------------------------------
unsigned __int8 *__cdecl get_form_history_value(unsigned __int8 *url, unsigned __int8 *name)
{
  list_head_elinks *next; // edi
  list_head_elinks *submit; // [esp+18h] [ebp-20h]
  formhist_data *form; // [esp+1Ch] [ebp-1Ch]

  if ( url && name && *url && *name && load_formhist_from_file() )
  {
    for ( form = (formhist_data *)saved_forms.next; form != (formhist_data *)&saved_forms; form = form->next )
    {
      if ( (*((_BYTE *)form + 20) & 1) == 0 && !strcmp((const char *)form->url, (const char *)url) )
      {
        submit = form->submit;
        next = (list_head_elinks *)submit->next;
        if ( submit->next != submit )
        {
          while ( strcmp((const char *)next[1].next, (const char *)name) )
          {
            next = (list_head_elinks *)next->next;
            if ( next == submit )
              goto LABEL_16;
          }
          return (unsigned __int8 *)next[1].prev;
        }
      }
LABEL_16:
      ;
    }
  }
  return 0;
}

//----- (080AC0A0) --------------------------------------------------------
void __cdecl lock_globhist_item(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (080AC0B0) --------------------------------------------------------
void __cdecl unlock_globhist_item(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (080AC0C0) --------------------------------------------------------
int __cdecl is_globhist_item_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (080AC0E0) --------------------------------------------------------
listbox_item *__cdecl get_globhist_item_root(listbox_item *box_item)
{
  return 0;
}

//----- (080AC0F0) --------------------------------------------------------
int __cdecl can_delete_globhist_item(listbox_item *item)
{
  return 1;
}

//----- (080AC100) --------------------------------------------------------
void __cdecl delete_globhist_item(listbox_item *item, int last)
{
  global_history_item *udata; // ebx
  int refcount; // ecx

  udata = (global_history_item *)item->udata;
  if ( !assert_failed && (refcount = udata->object.refcount, assert_failed = refcount != 0, refcount) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/globhist/dialogs.c";
    errline = 98;
    elinks_internal("assertion !is_object_used(historyitem) failed!");
    delete_global_history_item(udata);
  }
  else
  {
    delete_global_history_item(udata);
  }
}

//----- (080AC170) --------------------------------------------------------
uri *__cdecl get_globhist_item_uri(listbox_item *item)
{
  return get_uri(*((unsigned __int8 **)item->udata + 5), (uri_component)0);
}

//----- (080AC1A0) --------------------------------------------------------
unsigned __int8 *__usercall _5@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (080AC210) --------------------------------------------------------
unsigned __int8 *__cdecl get_globhist_item_info(listbox_item *box_item, terminal *term)
{
  void *udata; // ebx
  const char *v4; // edi
  const char *v5; // eax
  const char *v6; // edi
  const char *v7; // eax
  char *v8; // ebx
  const char *v9; // eax
  string info; // [esp+18h] [ebp-20h] BYREF

  udata = box_item->udata;
  if ( box_item->type == BI_FOLDER || !init_string(&info) )
    return 0;
  v4 = (const char *)*((_DWORD *)udata + 4);
  v5 = (const char *)_5((unsigned __int8 *)&byte_81279A0, term);
  add_format_to_string(&info, "%s: %s", v5, v4);
  v6 = (const char *)*((_DWORD *)udata + 5);
  v7 = (const char *)_5((unsigned __int8 *)&byte_812B6C9, term);
  add_format_to_string(&info, "\n%s: %s", v7, v6);
  v8 = ctime((const time_t *)udata + 6);
  v9 = (const char *)_5((unsigned __int8 *)&byte_812B3DB, term);
  add_format_to_string(&info, "\n%s: %s", v9, v8);
  return info.source;
}

//----- (080AC2E0) --------------------------------------------------------
unsigned __int8 *__cdecl get_globhist_item_text(listbox_item *box_item, terminal *term)
{
  void *udata; // ebx
  unsigned __int8 *result; // eax
  string *inited; // edx
  string info; // [esp+18h] [ebp-10h] BYREF

  udata = box_item->udata;
  if ( get_opt_(config_options, "document.history.global.display_type")->number && **((_BYTE **)udata + 4) )
    return stracpy(*((const unsigned __int8 **)udata + 4));
  inited = init_string(&info);
  result = 0;
  if ( inited )
  {
    add_string_uri_to_string(&info, *((unsigned __int8 **)udata + 5), URI_PUBLIC);
    return info.source;
  }
  return result;
}

//----- (080AC360) --------------------------------------------------------
widget_handler_status_T __cdecl push_toggle_display_button(dialog_data *dlg_data, widget_data *widget_data)
{
  option_value *opt; // eax

  opt = get_opt_(config_options, "document.history.global.display_type");
  opt->number = opt->number == 0;
  update_hierbox_browser(&globhist_browser);
  return 0;
}

//----- (080AC3A0) --------------------------------------------------------
widget_handler_status_T __cdecl push_search_button_0(dialog_data *dlg_data, widget_data *widget_data)
{
  do_edit_dialog(
    dlg_data->win->term,
    1,
    "Search history",
    gh_last_searched_title,
    gh_last_searched_url,
    (session *)dlg_data->dlg->udata,
    dlg_data,
    history_search_do,
    0,
    0,
    EDIT_DLG_SEARCH);
  return 0;
}

//----- (080AC410) --------------------------------------------------------
void __cdecl history_search_do(void *data)
{
  void *next; // ebx
  void **v2; // eax

  next = globhist_browser.root.child.next;
  if ( globhist_simple_search(*((unsigned __int8 **)data + 24), *((unsigned __int8 **)data + 12)) )
  {
    if ( globhist_browser.root.child.next != &globhist_browser.root.child )
    {
      v2 = (void **)globhist_browser.boxes.next;
      if ( globhist_browser.boxes.next != &globhist_browser.boxes )
      {
        do
        {
          v2[4] = next;
          v2[3] = next;
          v2 = (void **)*v2;
        }
        while ( v2 != &globhist_browser.boxes.next );
      }
    }
  }
}

//----- (080AC470) --------------------------------------------------------
widget_handler_status_T __cdecl push_bookmark_button(dialog_data *dlg_data, widget_data *some_useless_info_button)
{
  listbox_item *sel; // eax
  unsigned __int8 **udata; // eax

  sel = get_listbox_widget_data(dlg_data->widgets_data)->sel;
  if ( sel )
  {
    udata = (unsigned __int8 **)sel->udata;
    if ( udata )
      launch_bm_add_dialog(dlg_data->win->term, 0, 0, udata[4], udata[5]);
  }
  return 0;
}

//----- (080AC4D0) --------------------------------------------------------
void __cdecl history_manager(session *ses)
{
  if ( gh_last_searched_title )
    mem_free(gh_last_searched_title);
  gh_last_searched_title = 0;
  if ( gh_last_searched_url )
    mem_free(gh_last_searched_url);
  gh_last_searched_url = 0;
  hierbox_browser_0(&globhist_browser, ses);
}

//----- (080AC530) --------------------------------------------------------
void reap_deleted_globhist_items()
{
  void *next; // ebx
  list_head_elinks *v1; // esi
  list_head_elinks *v2; // eax
  void *v3; // [esp+0h] [ebp-28h]

  next = global_history_reap_list.next;
  v1 = *(list_head_elinks **)global_history_reap_list.next;
  if ( global_history_reap_list.next != &global_history_reap_list )
  {
    while ( 1 )
    {
      if ( *((_DWORD *)next + 2) )
      {
        v2 = (list_head_elinks *)v1->next;
        next = v1;
        if ( &global_history_reap_list == v1 )
          return;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)next + 4) = *((_DWORD *)next + 1);
        **((_DWORD **)next + 1) = *(_DWORD *)next;
        mem_free(*((void **)next + 4));
        mem_free(*((void **)next + 5));
        v3 = next;
        next = v1;
        mem_free(v3);
        v2 = (list_head_elinks *)v1->next;
        if ( &global_history_reap_list == v1 )
          return;
      }
      v1 = v2;
    }
  }
}

//----- (080AC5A0) --------------------------------------------------------
void write_global_history()
{
  unsigned __int8 *v0; // eax
  unsigned __int8 *v1; // ebx
  secure_save_info *v2; // esi
  input_history *i; // ebx

  if ( (*((_BYTE *)&global_history + 12) & 1) != 0 )
  {
    if ( elinks_home )
    {
      if ( global_history_options_0[1].option_elinks.value.number )
      {
        if ( !get_opt_(cmdline_options, "anonymous")->number )
        {
          v0 = straconcat((const unsigned __int8 *)elinks_home, "globhist", 0);
          v1 = v0;
          if ( v0 )
          {
            v2 = secure_open(v0);
            mem_free(v1);
            if ( v2 )
            {
              for ( i = (input_history *)global_history.entries.prev;
                    i != &global_history;
                    i = (input_history *)i->entries.prev )
              {
                if ( secure_fprintf(
                       v2,
                       "%s\t%s\t%ld\n",
                       (const char *)i[1].entries.next,
                       (const char *)i[1].entries.prev,
                       i[1].size) < 0 )
                  break;
              }
              if ( !secure_close(v2) )
                *((_BYTE *)&global_history + 12) &= ~1u;
            }
          }
        }
      }
    }
  }
}

//----- (080AC6A0) --------------------------------------------------------
evhook_status __cdecl global_history_write_hook(va_list ap, void *data)
{
  write_global_history();
  return 0;
}

//----- (080AC6B0) --------------------------------------------------------
int __cdecl globhist_simple_search(unsigned __int8 *search_url, unsigned __int8 *search_title)
{
  unsigned __int8 v2; // al
  input_history *next; // ebx
  input_history *v5; // eax

  if ( !search_title || !search_url )
    return 0;
  if ( gh_last_searched_title )
    mem_free(gh_last_searched_title);
  gh_last_searched_title = stracpy(search_title);
  if ( !gh_last_searched_title )
    return 0;
  if ( gh_last_searched_url )
    mem_free(gh_last_searched_url);
  gh_last_searched_url = stracpy(search_url);
  if ( !gh_last_searched_url )
    return 0;
  v2 = *search_title;
  if ( *search_title || *search_url )
  {
    next = (input_history *)global_history.entries.next;
    if ( global_history.entries.next != &global_history )
    {
      while ( 1 )
      {
        if ( v2 && strcasestr(next[1].entries.next, search_title)
          || *search_url && c_strcasestr((const char *)next[1].entries.prev, (const char *)search_url) )
        {
          *(_BYTE *)(*((_DWORD *)next + 3) + 24) |= 2u;
          next = (input_history *)next->entries.next;
          if ( next == &global_history )
            return 1;
        }
        else
        {
          *(_BYTE *)(*((_DWORD *)next + 3) + 24) &= ~2u;
          next = (input_history *)next->entries.next;
          if ( next == &global_history )
            return 1;
        }
        v2 = *search_title;
      }
    }
    return 1;
  }
  v5 = (input_history *)global_history.entries.next;
  if ( global_history.entries.next == &global_history )
    return 1;
  do
  {
    *(_BYTE *)(*((_DWORD *)v5 + 3) + 24) |= 2u;
    v5 = (input_history *)v5->entries.next;
  }
  while ( v5 != &global_history );
  return 1;
}
// 80596D8: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (080AC7E0) --------------------------------------------------------
global_history_item *__cdecl get_global_history_item(unsigned __int8 *url)
{
  hash *v2; // esi
  unsigned int v3; // eax
  hash_item *hash_item; // eax

  if ( url
    && (v2 = globhist_cache) != 0
    && (v3 = strlen((const char *)url), (hash_item = get_hash_item(v2, url, v3)) != 0) )
  {
    return (global_history_item *)hash_item->value;
  }
  else
  {
    return 0;
  }
}

//----- (080AC840) --------------------------------------------------------
void __cdecl delete_global_history_item(global_history_item *history_item)
{
  hash *v1; // esi
  unsigned __int8 *url; // edi
  unsigned int v3; // eax
  hash_item *hash_item; // eax
  global_history_item *next; // eax

  history_item->next->prev = history_item->prev;
  history_item->prev->next = history_item->next;
  --global_history.size;
  if ( (*((_BYTE *)&global_history + 12) & 2) == 0 )
    *((_BYTE *)&global_history + 12) |= 1u;
  v1 = globhist_cache;
  if ( globhist_cache )
  {
    url = history_item->url;
    v3 = strlen((const char *)url);
    hash_item = get_hash_item(v1, url, v3);
    if ( hash_item )
    {
      del_hash_item(globhist_cache, hash_item);
      --globhist_cache_entries;
    }
  }
  done_listbox_item(&globhist_browser, history_item->box_item);
  history_item->box_item = 0;
  next = (global_history_item *)global_history_reap_list.next;
  history_item->prev = (global_history_item *)&global_history_reap_list;
  history_item->next = next;
  global_history_reap_list.next = history_item;
  history_item->next->prev = history_item;
}

//----- (080AC900) --------------------------------------------------------
void __cdecl done_global_history(module *module)
{
  write_global_history();
  if ( globhist_cache )
  {
    free_hash(&globhist_cache);
    globhist_cache_entries = 0;
  }
  while ( global_history.entries.next != &global_history )
    delete_global_history_item((global_history_item *)global_history.entries.next);
  reap_deleted_globhist_items();
  if ( gh_last_searched_title )
    mem_free(gh_last_searched_title);
  if ( gh_last_searched_url )
    mem_free(gh_last_searched_url);
}

//----- (080AC980) --------------------------------------------------------
void __cdecl add_global_history_item(unsigned __int8 *url, unsigned __int8 *title, time_t vtime)
{
  int number; // ebx
  global_history_item *global_history_item; // eax
  _DWORD *v5; // eax
  void *v6; // edi
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  listbox_item *v10; // eax
  void *next; // eax
  hash *inited; // esi
  char *v13; // ebx
  unsigned int v14; // eax
  void *v15; // eax

  if ( !url || !global_history_options_0[1].option_elinks.value.number )
    return;
  number = global_history_options_0[2].option_elinks.value.number;
  global_history_item = get_global_history_item(url);
  if ( global_history_item )
    delete_global_history_item(global_history_item);
  if ( number > global_history.size )
  {
LABEL_11:
    reap_deleted_globhist_items();
    v5 = mem_calloc(1u, 0x1Cu);
    v6 = v5;
    if ( !v5 )
      return;
    v5[6] = vtime;
    v7 = (unsigned __int8 *)&delete;
    if ( title )
      v7 = title;
    v8 = stracpy(v7);
    *((_DWORD *)v6 + 4) = v8;
    if ( !v8 )
    {
LABEL_27:
      mem_free(v6);
      return;
    }
    sanitize_title(v8);
    v9 = stracpy(url);
    *((_DWORD *)v6 + 5) = v9;
    if ( v9 )
    {
      if ( sanitize_url(v9) )
      {
        v10 = add_listbox_item(&globhist_browser, 0, BI_LEAF, v6, 1);
        *((_DWORD *)v6 + 3) = v10;
        if ( v10 )
        {
          next = global_history.entries.next;
          *((_DWORD *)v6 + 1) = &global_history;
          *(_DWORD *)v6 = next;
          global_history.entries.next = v6;
          *(_DWORD *)(*(_DWORD *)v6 + 4) = v6;
          ++global_history.size;
          if ( (*((_BYTE *)&global_history + 12) & 2) == 0 )
            *((_BYTE *)&global_history + 12) |= 1u;
          inited = globhist_cache;
          if ( globhist_cache || (inited = init_hash8(), (globhist_cache = inited) != 0) )
          {
            if ( number > globhist_cache_entries )
            {
              v13 = (char *)*((_DWORD *)v6 + 5);
              v14 = strlen(v13);
              if ( add_hash_item(inited, (unsigned __int8 *)v13, v14, v6) )
                ++globhist_cache_entries;
            }
          }
          return;
        }
        v15 = (void *)*((_DWORD *)v6 + 5);
        goto LABEL_25;
      }
      v15 = (void *)*((_DWORD *)v6 + 5);
      if ( v15 )
LABEL_25:
        mem_free(v15);
    }
    mem_free(*((void **)v6 + 4));
    goto LABEL_27;
  }
  while ( global_history.entries.prev != &global_history )
  {
    delete_global_history_item((global_history_item *)global_history.entries.prev);
    if ( number > global_history.size )
      goto LABEL_11;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/globhist/globhist.c";
  errline = 233;
  elinks_internal((unsigned __int8 *)&byte_812E2FC);
  global_history.size = 0;
}

//----- (080ACBA0) --------------------------------------------------------
void read_global_history()
{
  unsigned __int8 *v0; // ebx
  char *v1; // eax
  unsigned __int8 *v2; // esi
  char *v3; // eax
  const char *v4; // edi
  char *v5; // eax
  int v6; // eax
  FILE *f; // [esp+1Ch] [ebp-C2Ch]
  unsigned __int8 in_buffer[3072]; // [esp+2Ch] [ebp-C1Ch] BYREF
  unsigned int v9; // [esp+C2Ch] [ebp-1Ch]

  v9 = __readgsdword(0x14u);
  if ( global_history_options_0[1].option_elinks.value.number )
  {
    if ( !get_opt_(cmdline_options, "anonymous")->number )
    {
      v0 = "globhist";
      if ( !elinks_home || (v0 = straconcat((const unsigned __int8 *)elinks_home, "globhist", 0)) != 0 )
      {
        f = (FILE *)fopen64(v0, "rb");
        if ( elinks_home )
          mem_free(v0);
        if ( f )
        {
          *((_BYTE *)&global_history + 12) |= 2u;
          while ( fgets((char *)in_buffer, 3072, f) )
          {
            v1 = strchr((const char *)in_buffer, 9);
            if ( v1 )
            {
              v2 = (unsigned __int8 *)(v1 + 1);
              *v1 = 0;
              v3 = strchr(v1 + 1, 9);
              if ( v3 )
              {
                v4 = v3 + 1;
                *v3 = 0;
                v5 = strchr(v3 + 1, 10);
                if ( v5 )
                {
                  *v5 = 0;
                  v6 = strtol(v4, 0, 10);
                  add_global_history_item(v2, in_buffer, v6);
                }
              }
            }
          }
          *((_BYTE *)&global_history + 12) &= ~2u;
          fclose(f);
        }
      }
    }
  }
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080ACD20) --------------------------------------------------------
void __cdecl init_global_history(module *module)
{
  read_global_history();
}

//----- (080ACD30) --------------------------------------------------------
int __cdecl utf8charlen(const unsigned __int8 *p)
{
  int result; // eax

  result = 0;
  if ( p )
    return utf8char_len_tab[*p];
  return result;
}

//----- (080ACD50) --------------------------------------------------------
unsigned __int8 *__cdecl utf8_prevchar(unsigned __int8 *current, int pos, unsigned __int8 *start)
{
  unsigned __int8 *result; // eax
  int v4; // edx

  result = current;
  v4 = pos;
  if ( !start || !current || pos < 0 )
    return 0;
LABEL_6:
  if ( result != start )
  {
    while ( v4 > 0 )
    {
      if ( (*--result & 0x80u) != 0 && (*result & 0xC0) != 192 )
        goto LABEL_6;
      --v4;
      if ( result == start )
        return result;
    }
  }
  return result;
}

//----- (080ACDB0) --------------------------------------------------------
int __cdecl unicode_to_cell(unicode_val_T c)
{
  if ( c > 0x10FF
    && (c == 9001
     || c <= 0x115F
     || c == 9002
     || c - 11904 <= 0x764F && c != 12351
     || c - 44032 <= 0x2BA3
     || c - 63744 <= 0x1FF
     || c - 65072 <= 0x3F
     || c - 65280 <= 0x60
     || c - 65504 <= 6
     || c - 0x20000 <= 0xFFFD
     || c - 196608 <= 0xFFFD) )
  {
    return 2;
  }
  else
  {
    return 1;
  }
}

//----- (080ACE80) --------------------------------------------------------
int __cdecl hits_cmp(const void *v1, const void *v2)
{
  int result; // eax

  result = 0;
  if ( *(_DWORD *)v1 != *(_DWORD *)v2 )
    return *(_DWORD *)v2 < *(_DWORD *)v1 ? -1 : 1;
  return result;
}

//----- (080ACEB0) --------------------------------------------------------
int __cdecl compare_entities(const void *key_, const void *element_)
{
  int v2; // eax
  _BYTE *v3; // ecx
  _BYTE *v4; // edx
  int result; // eax

  v2 = *((_DWORD *)key_ + 1);
  v3 = *(_BYTE **)key_;
  v4 = *(_BYTE **)element_;
  if ( v2 )
  {
    while ( *v3 <= *v4 )
    {
      if ( *v3 < *v4 )
        return -1;
      ++v4;
      if ( !--v2 )
        goto LABEL_9;
      ++v3;
    }
    return 1;
  }
  else
  {
LABEL_9:
    result = 0;
    if ( *v4 )
      return -1;
  }
  return result;
}

//----- (080ACF00) --------------------------------------------------------
void charsets_list_reset()
{
  i_name = 0;
  i_alias = 0;
}

//----- (080ACF20) --------------------------------------------------------
fastfind_key_value *charsets_list_next()
{
  fastfind_key_value *result; // eax
  unsigned __int8 *const *aliases; // eax
  unsigned __int8 *v2; // esi

  result = 0;
  if ( codepages[i_name].name )
  {
    aliases = codepages[i_name].aliases;
    v2 = aliases[i_alias];
    kv_7347.data = (void *)(16 * i_name + 135286656);
    kv_7347.key = v2;
    if ( aliases[i_alias + 1] )
    {
      ++i_alias;
      return &kv_7347;
    }
    else
    {
      result = &kv_7347;
      ++i_name;
      i_alias = 0;
    }
  }
  return result;
}

//----- (080ACFB0) --------------------------------------------------------
unsigned __int8 *__cdecl get_cp_name(int cp_index)
{
  unsigned __int8 *result; // eax

  result = "none";
  if ( cp_index >= 0 )
  {
    result = "System";
    if ( (cp_index & 0x80u) == 0 )
      return codepages[cp_index].name;
  }
  return result;
}

//----- (080ACFE0) --------------------------------------------------------
unsigned __int8 *__cdecl get_cp_config_name(int cp_index)
{
  unsigned __int8 *result; // eax
  unsigned __int8 **aliases; // edx

  result = "none";
  if ( cp_index >= 0 )
  {
    result = "System";
    if ( (cp_index & 0x80u) == 0 )
    {
      result = 0;
      aliases = (unsigned __int8 **)codepages[cp_index].aliases;
      if ( aliases )
        return *aliases;
    }
  }
  return result;
}

//----- (080AD020) --------------------------------------------------------
unsigned __int8 *__cdecl get_cp_mime_name(int cp_index)
{
  unsigned __int8 *result; // eax
  int v2; // edx
  unsigned __int8 **aliases; // edx

  result = "none";
  v2 = cp_index;
  if ( cp_index >= 0 )
  {
    LOBYTE(v2) = cp_index & 0x7F;
    result = 0;
    aliases = (unsigned __int8 **)codepages[v2].aliases;
    if ( aliases )
      return *aliases;
  }
  return result;
}

//----- (080AD050) --------------------------------------------------------
int __cdecl is_cp_utf8(int cp_index)
{
  int v1; // eax

  v1 = cp_index;
  LOBYTE(v1) = cp_index & 0x7F;
  return codepages[v1].aliases == aliases_utf8;
}

//----- (080AD070) --------------------------------------------------------
void free_charsets_lookup()
{
  fastfind_done(&ff_charsets_index);
}

//----- (080AD090) --------------------------------------------------------
void init_charsets_lookup()
{
  fastfind_index_0(&ff_charsets_index, FF_COMPRESS);
}

//----- (080AD0B0) --------------------------------------------------------
int __cdecl get_cp_index(const unsigned __int8 *name)
{
  int v1; // esi
  const char *v2; // ebx
  int v3; // eax
  const codepage_desc *v4; // eax
  int result; // eax
  const codepage_desc *v6; // [esp+1Ch] [ebp-Ch]

  v1 = 0;
  v2 = (const char *)name;
  if ( !c_strcasecmp((const char *)name, "System") )
  {
    LOWORD(v1) = 128;
    v2 = nl_langinfo(14);
  }
  v3 = strlen(v2);
  v4 = (const codepage_desc *)fastfind_search(&ff_charsets_index, (const unsigned __int8 *)v2, v3);
  if ( v4 )
  {
    if ( !assert_failed )
    {
      if ( v4 < codepages || (unsigned int)v4 >= 0x81051B0 )
      {
        v6 = v4;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 1413;
        elinks_internal("assertion codepages <= codepage && codepage < codepages + N_CODEPAGES failed!");
        v4 = v6;
      }
      else
      {
        assert_failed = 0;
      }
    }
    return v1 | (v4 - codepages);
  }
  else
  {
    result = -1;
    if ( v1 )
      return v1 | get_cp_index("us-ascii");
  }
  return result;
}

//----- (080AD1A0) --------------------------------------------------------
unicode_val_T __cdecl cp2u(int from, unsigned __int8 c)
{
  int v2; // eax
  const codepage_desc *v3; // esi
  bool v4; // zf
  unicode_val_T result; // eax

  if ( assert_failed )
    goto LABEL_6;
  v2 = from;
  LOBYTE(v2) = from & 0x7F;
  v3 = &codepages[v2];
  v4 = v3->aliases != aliases_utf8;
  assert_failed = v3->aliases == aliases_utf8;
  if ( v4 )
    goto LABEL_3;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
  errline = 744;
  elinks_internal("assertion !is_cp_ptr_utf8(&codepages[from]) failed!");
  if ( assert_failed )
  {
LABEL_6:
    assert_failed = 0;
    return 65533;
  }
  else
  {
LABEL_3:
    result = c;
    if ( (c & 0x80u) != 0 )
    {
      result = v3->highhalf[c - 128];
      if ( result == 0xFFFF )
        return 65533;
    }
  }
  return result;
}

//----- (080AD260) --------------------------------------------------------
unicode_val_T __cdecl utf8_to_unicode(unsigned __int8 **string, const unsigned __int8 *end)
{
  unsigned __int8 *v2; // edx
  unicode_val_T result; // eax
  unsigned __int8 v4; // bl
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // ecx
  unsigned __int8 v7; // al
  unsigned __int8 v8; // dl
  unsigned __int8 v9; // al
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // al
  unsigned __int8 v12; // dl
  unsigned __int8 v13; // dl
  unsigned __int8 v14; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 v15; // [esp+24h] [ebp-24h]
  unsigned __int8 v16; // [esp+28h] [ebp-20h]
  unsigned __int8 v17; // [esp+28h] [ebp-20h]
  unsigned __int8 v18; // [esp+2Ch] [ebp-1Ch]
  unsigned __int8 v19; // [esp+2Ch] [ebp-1Ch]

  v2 = *string;
  result = -3;
  v4 = **string;
  v5 = &(*string)[utf8char_len_tab[v4]];
  if ( v5 <= end )
  {
    switch ( v4 )
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x5Eu:
      case 0x5Fu:
      case 0x60u:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
      case 0x7Bu:
      case 0x7Cu:
      case 0x7Du:
      case 0x7Eu:
      case 0x7Fu:
      case 0x80u:
      case 0x81u:
      case 0x82u:
      case 0x83u:
      case 0x84u:
      case 0x85u:
      case 0x86u:
      case 0x87u:
      case 0x88u:
      case 0x89u:
      case 0x8Au:
      case 0x8Bu:
      case 0x8Cu:
      case 0x8Du:
      case 0x8Eu:
      case 0x8Fu:
      case 0x90u:
      case 0x91u:
      case 0x92u:
      case 0x93u:
      case 0x94u:
      case 0x95u:
      case 0x96u:
      case 0x97u:
      case 0x98u:
      case 0x99u:
      case 0x9Au:
      case 0x9Bu:
      case 0x9Cu:
      case 0x9Du:
      case 0x9Eu:
      case 0x9Fu:
      case 0xA0u:
      case 0xA1u:
      case 0xA2u:
      case 0xA3u:
      case 0xA4u:
      case 0xA5u:
      case 0xA6u:
      case 0xA7u:
      case 0xA8u:
      case 0xA9u:
      case 0xAAu:
      case 0xABu:
      case 0xACu:
      case 0xADu:
      case 0xAEu:
      case 0xAFu:
      case 0xB0u:
      case 0xB1u:
      case 0xB2u:
      case 0xB3u:
      case 0xB4u:
      case 0xB5u:
      case 0xB6u:
      case 0xB7u:
      case 0xB8u:
      case 0xB9u:
      case 0xBAu:
      case 0xBBu:
      case 0xBCu:
      case 0xBDu:
      case 0xBEu:
      case 0xBFu:
      case 0xFEu:
      case 0xFFu:
        result = v4;
        if ( (v4 & 0x80u) == 0 )
          goto LABEL_13;
        v6 = v2 + 1;
        goto LABEL_4;
      case 0xC0u:
      case 0xC1u:
      case 0xC2u:
      case 0xC3u:
      case 0xC4u:
      case 0xC5u:
      case 0xC6u:
      case 0xC7u:
      case 0xC8u:
      case 0xC9u:
      case 0xCAu:
      case 0xCBu:
      case 0xCCu:
      case 0xCDu:
      case 0xCEu:
      case 0xCFu:
      case 0xD0u:
      case 0xD1u:
      case 0xD2u:
      case 0xD3u:
      case 0xD4u:
      case 0xD5u:
      case 0xD6u:
      case 0xD7u:
      case 0xD8u:
      case 0xD9u:
      case 0xDAu:
      case 0xDBu:
      case 0xDCu:
      case 0xDDu:
      case 0xDEu:
      case 0xDFu:
        v6 = v2 + 1;
        v13 = v2[1];
        if ( (v13 & 0xC0) == 128 )
        {
          result = ((v4 & 0x1F) << 6) + (v13 & 0x3F);
          if ( result > 0x7F )
            goto LABEL_13;
        }
        goto LABEL_4;
      case 0xE0u:
      case 0xE1u:
      case 0xE2u:
      case 0xE3u:
      case 0xE4u:
      case 0xE5u:
      case 0xE6u:
      case 0xE7u:
      case 0xE8u:
      case 0xE9u:
      case 0xEAu:
      case 0xEBu:
      case 0xECu:
      case 0xEDu:
      case 0xEEu:
      case 0xEFu:
        v6 = v2 + 1;
        if ( (v2[1] & 0xC0) != 128 )
          goto LABEL_4;
        if ( (v2[2] & 0xC0) != 128 )
          goto LABEL_4;
        result = ((v2[1] & 0x3F) << 6) + (unsigned __int16)(v4 << 12) + (v2[2] & 0x3F);
        if ( result <= 0x7FF || (result & 0xFFFFF800) == 55296 )
          goto LABEL_4;
        goto LABEL_13;
      case 0xF0u:
      case 0xF1u:
      case 0xF2u:
      case 0xF3u:
      case 0xF4u:
      case 0xF5u:
      case 0xF6u:
      case 0xF7u:
        v11 = v2[1];
        v6 = v2 + 1;
        if ( (v11 & 0xC0) == 128 )
        {
          v17 = v2[2];
          if ( (v17 & 0xC0) == 128 )
          {
            v12 = v2[3];
            if ( (v12 & 0xC0) == 128 )
            {
              result = ((v17 & 0x3F) << 6) + ((v4 & 0xF) << 18) + (v12 & 0x3F) + ((v11 & 0x3F) << 12);
              if ( result > 0xFFFF )
                goto LABEL_13;
            }
          }
        }
        goto LABEL_4;
      case 0xF8u:
      case 0xF9u:
      case 0xFAu:
      case 0xFBu:
        v9 = v2[1];
        v6 = v2 + 1;
        if ( (v9 & 0xC0) == 128 )
        {
          v15 = v2[2];
          if ( (v15 & 0xC0) == 128 )
          {
            v19 = v2[3];
            if ( (v19 & 0xC0) == 128 )
            {
              v10 = v2[4];
              if ( (v10 & 0xC0) == 128 )
              {
                result = ((v4 & 0xF) << 24)
                       + (v10 & 0x3F)
                       + ((v9 & 0x3F) << 18)
                       + ((v15 & 0x3F) << 12)
                       + ((v19 & 0x3F) << 6);
                if ( result > 0x1FFFFF )
                  goto LABEL_13;
              }
            }
          }
        }
        goto LABEL_4;
      case 0xFCu:
      case 0xFDu:
        v7 = v2[1];
        v6 = v2 + 1;
        if ( (v7 & 0xC0) != 128 )
          goto LABEL_4;
        v14 = v2[2];
        if ( (v14 & 0xC0) != 128 )
          goto LABEL_4;
        v18 = v2[3];
        if ( (v18 & 0xC0) != 128 )
          goto LABEL_4;
        v16 = v2[4];
        if ( (v16 & 0xC0) != 128 )
          goto LABEL_4;
        v8 = v2[5];
        if ( (v8 & 0xC0) != 128 )
          goto LABEL_4;
        result = ((v14 & 0x3F) << 18)
               + ((v4 & 1) << 30)
               + (v8 & 0x3F)
               + ((v7 & 0x3F) << 24)
               + ((v18 & 0x3F) << 12)
               + ((v16 & 0x3F) << 6);
        if ( result <= 0x3FFFFFF )
          goto LABEL_4;
LABEL_13:
        *string = v5;
        break;
      default:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 719;
        elinks_internal("utf8char_len_tab out of range");
        v6 = *string + 1;
LABEL_4:
        result = 65533;
        *string = v6;
        break;
    }
  }
  return result;
}

//----- (080AD570) --------------------------------------------------------
unicode_val_T __cdecl cp_to_unicode(int codepage, unsigned __int8 **string, const unsigned __int8 *end)
{
  int v3; // eax
  unicode_val_T result; // eax

  v3 = codepage;
  LOBYTE(v3) = codepage & 0x7F;
  if ( codepages[v3].aliases == aliases_utf8 )
    return utf8_to_unicode(string, end);
  result = -3;
  if ( end > *string )
  {
    result = cp2u(codepage, **string);
    ++*string;
  }
  return result;
}

//----- (080AD5E0) --------------------------------------------------------
void __usercall free_translation_table(conv_table *p@<eax>)
{
  int i; // ebx
  conv_table *tbl; // eax

  for ( i = 0; i != 256; ++i )
  {
    while ( !p[i].t )
    {
      if ( ++i == 256 )
        goto LABEL_5;
    }
    tbl = p[i].u.tbl;
    free_translation_table(tbl);
  }
LABEL_5:
  mem_free(p);
}

//----- (080AD630) --------------------------------------------------------
void __usercall new_translation_table(conv_table *p@<eax>)
{
  int i; // ebx
  conv_table *tbl; // eax
  int j; // eax

  for ( i = 0; i != 256; ++i )
  {
    while ( !p[i].t )
    {
      if ( ++i == 256 )
        goto LABEL_5;
    }
    tbl = p[i].u.tbl;
    free_translation_table(tbl);
  }
LABEL_5:
  for ( j = 0; j != 256; j += 2 )
  {
    *(&p->t + j) = 0;
    *((_DWORD *)&p->u.str + j) = &strings[j];
  }
  LOWORD(j) = 128;
  do
  {
    p[j].t = 0;
    p[j++].u.str = no_str;
  }
  while ( j != 256 );
}

//----- (080AD6B0) --------------------------------------------------------
unicode_val_T __cdecl unicode_fold_label_case(unicode_val_T c)
{
  return towlower(c);
}

//----- (080AD6C0) --------------------------------------------------------
int __cdecl utf8_ptr2chars(unsigned __int8 *string, unsigned __int8 *end)
{
  unsigned __int8 *v2; // ecx
  unsigned __int8 *v3; // ebx
  int result; // eax

  v2 = end;
  if ( !end )
  {
    v2 = (unsigned __int8 *)__rawmemchr(string, 0);
    if ( !v2 )
      return -1;
  }
  if ( !string )
    return -1;
  v3 = &string[utf8char_len_tab[*string]];
  for ( result = 0; v2 >= v3; v3 += utf8char_len_tab[*v3] )
    ++result;
  return result;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080AD730) --------------------------------------------------------
int __cdecl strlen_utf8(unsigned __int8 **str)
{
  unsigned __int8 *v1; // ebx
  unsigned int v2; // ecx
  int result; // eax

  v1 = *str;
  v2 = __rawmemchr(*str, 0);
  result = 0;
  while ( !v1 )
LABEL_3:
    ++result;
  if ( v2 >= (unsigned int)&v1[utf8char_len_tab[*v1]] )
  {
    v1 += utf8char_len_tab[*v1];
    goto LABEL_3;
  }
  *str = v1;
  return result;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080AD780) --------------------------------------------------------
void free_conv_table()
{
  int i; // edi
  unsigned __int8 *str; // eax

  if ( !utf_table_init )
  {
    for ( i = 128; i != 256; ++i )
    {
      str = (unsigned __int8 *)utf_table[i].u.str;
      mem_free(str);
    }
  }
  if ( first )
  {
    memset(table_elinks_0, 0, sizeof(table_elinks_0));
    first = 0;
  }
  new_translation_table(table_elinks_0);
}

//----- (080AD7F0) --------------------------------------------------------
unsigned __int8 *__cdecl encode_utf8(unicode_val_T u)
{
  unsigned __int8 *result; // eax

  *(_DWORD *)utf_buffer = 0;
  *(_WORD *)&utf_buffer[4] = 0;
  utf_buffer[6] = 0;
  if ( u <= 0x7F )
  {
    utf_buffer[0] = u;
    return utf_buffer;
  }
  else
  {
    if ( u <= 0x7FF )
    {
      utf_buffer[0] = (u >> 6) & 0x1F | 0xC0;
      utf_buffer[1] = u & 0x3F | 0x80;
      return utf_buffer;
    }
    if ( u > 0xFFFF )
    {
      if ( u <= 0x1FFFFF )
      {
        utf_buffer[0] = (u >> 18) | 0xF0;
        utf_buffer[1] = (u >> 12) & 0x3F | 0x80;
        utf_buffer[2] = (u >> 6) & 0x3F | 0x80;
        utf_buffer[3] = u & 0x3F | 0x80;
      }
      else if ( u <= 0x3FFFFFF )
      {
        utf_buffer[0] = HIBYTE(u) | 0xF8;
        utf_buffer[1] = (u >> 18) & 0x3F | 0x80;
        utf_buffer[2] = (u >> 12) & 0x3F | 0x80;
        utf_buffer[3] = (u >> 6) & 0x3F | 0x80;
        utf_buffer[4] = u & 0x3F | 0x80;
      }
      else
      {
        utf_buffer[0] = ((u & 0x40000000) != 0) | 0xFC;
        utf_buffer[1] = HIBYTE(u) & 0x3F | 0x80;
        utf_buffer[2] = (u >> 18) & 0x3F | 0x80;
        utf_buffer[3] = (u >> 12) & 0x3F | 0x80;
        utf_buffer[4] = (u >> 6) & 0x3F | 0x80;
        utf_buffer[5] = u & 0x3F | 0x80;
      }
      return utf_buffer;
    }
    utf_buffer[0] = (u >> 12) & 0xF | 0xE0;
    utf_buffer[2] = u & 0x3F | 0x80;
    result = utf_buffer;
    utf_buffer[1] = (u >> 6) & 0x3F | 0x80;
  }
  return result;
}

//----- (080AD9B0) --------------------------------------------------------
const unsigned __int8 *__cdecl u2cp_(unicode_val_T u, int to, nbsp_mode nbsp_mode)
{
  unicode_val_T v3; // eax
  const unsigned __int8 *result; // eax
  const table_entry *table_elinks; // edx
  unsigned __int8 c; // cl
  int v8; // ebx
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  unicode_val_T x; // esi
  int v13; // edx
  int v14; // ecx

  v3 = u;
  if ( u <= 0x7F )
    return (const unsigned __int8 *)&strings[2 * v3];
  while ( 1 )
  {
    LOBYTE(to) = to & 0x7F;
    if ( codepages[to].aliases == aliases_utf8 )
      return encode_utf8(v3);
    if ( v3 == 160 )
    {
      result = (const unsigned __int8 *)&unk_812E3D7;
      if ( nbsp_mode )
        return &start;
      return result;
    }
    if ( v3 == 173 )
      return (const unsigned __int8 *)&delete;
    if ( v3 > 0x9F )
      break;
    v3 = *(&unicode_7b[2424].x + v3);
    if ( !v3 )
      return 0;
    if ( v3 <= 0x7F )
      return (const unsigned __int8 *)&strings[2 * v3];
  }
  if ( v3 <= 0xFFFE )
  {
    v14 = 0;
    while ( (unsigned __int16)codepages[to].highhalf[v14] != v3 )
    {
      if ( ++v14 == 128 )
        goto LABEL_16;
    }
    return (const unsigned __int8 *)(2 * v14 + 135295520);
  }
  else
  {
LABEL_16:
    table_elinks = codepages[to].table_elinks;
    c = table_elinks->c;
    if ( table_elinks->c )
    {
      if ( table_elinks->u == v3 )
        return (const unsigned __int8 *)&strings[2 * c];
      while ( 1 )
      {
        c = table_elinks[1].c;
        if ( !c )
          break;
        v8 = table_elinks[1].u;
        ++table_elinks;
        if ( v8 == v3 )
          return (const unsigned __int8 *)&strings[2 * c];
      }
    }
    v9 = 2451;
    v10 = 0;
    while ( 1 )
    {
      v11 = (v10 + v9) >> 1;
      x = unicode_7b[v11].x;
      if ( x == v3 )
        break;
      if ( v3 < x )
        v9 = v11 - 1;
      v13 = v11 + 1;
      if ( v3 > x )
        v10 = v13;
      if ( v9 < v10 )
        return no_str;
    }
    return unicode_7b[v11].s;
  }
}

//----- (080ADB10) --------------------------------------------------------
const unsigned __int8 *__cdecl get_entity_string(const unsigned __int8 *str, const int strlen, int encoding)
{
  const unsigned __int8 *v3; // esi
  unsigned int v4; // ebx
  int v5; // eax
  size_t v6; // edx
  int v7; // eax
  unsigned __int8 v8; // dl
  const unsigned __int8 *v9; // ecx
  int v10; // esi
  _DWORD *v11; // eax
  unsigned int v12; // eax
  int v13; // edi
  entity_cache *v14; // edi
  unsigned int v16; // eax
  _DWORD *v17; // edx
  int v18; // edx
  unsigned int v19; // ecx
  const unsigned __int8 *v20; // edi
  char v21; // bl
  unsigned __int8 v22; // bl
  const unsigned __int16 **v23; // eax
  size_t v24; // [esp+34h] [ebp-44h]
  unsigned int v25; // [esp+34h] [ebp-44h]
  int v26; // [esp+3Ch] [ebp-3Ch]
  int v27; // [esp+40h] [ebp-38h]
  int v28; // [esp+44h] [ebp-34h]
  unsigned int v29; // [esp+48h] [ebp-30h]
  int to; // [esp+4Ch] [ebp-2Ch]
  string key; // [esp+58h] [ebp-20h] BYREF

  v3 = 0;
  v4 = strlen;
  if ( strlen <= 0 )
    return v3;
  v5 = encoding;
  LOBYTE(v5) = encoding & 0x7F;
  to = v5;
  v27 = 16 * v5 + 135286656;
  if ( codepages[v5].aliases == aliases_utf8 )
    goto skip;
  if ( first_time_7079 )
  {
    memset(nb_entity_cache_7078, 0, sizeof(nb_entity_cache_7078));
    first_time_7079 = 0;
    v28 = strlen;
    if ( (unsigned int)(strlen - 2) <= 6 )
      goto LABEL_27;
  }
  else
  {
    v28 = strlen;
    if ( (unsigned int)(strlen - 2) <= 6 )
      goto LABEL_27;
  }
  if ( strlen > 8 )
  {
skip:
    v28 = 0;
    goto LABEL_7;
  }
  v28 = 0;
LABEL_27:
  if ( nb_entity_cache_7078[v28] )
  {
    v16 = 0;
    v17 = (_DWORD *)(360 * v28 + 135566536);
    while ( 1 )
    {
      if ( *v17 == to )
      {
        v26 = 360 * v28 + 36 * v16;
        if ( !memcmp(str, (const void *)(v26 + 135566544), strlen) )
          break;
      }
      ++v16;
      v17 += 9;
      if ( nb_entity_cache_7078[v28] <= v16 )
      {
        v4 = strlen;
        goto LABEL_7;
      }
    }
    v18 = *(unsigned int *)((char *)&entity_cache_7077[0][0].hits + v26);
    if ( v18 != -1 )
      *(unsigned int *)((char *)&entity_cache_7077[0][0].hits + v26) = v18 + 1;
    return entity_cache_7077[v28][v16].result;
  }
LABEL_7:
  if ( *str != 35 )
  {
    v3 = 0;
    key.length = v4;
    key.source = (unsigned __int8 *)str;
    v11 = bsearch(&key, entities, 0x3E9u, 8u, compare_entities);
    if ( v11 )
      v3 = u2cp_(v11[1], to, NBSP_MODE_HACK);
    goto LABEL_19;
  }
  v3 = 0;
  v6 = 1;
  if ( v4 == 1 )
    goto LABEL_21;
  v7 = v4 - 1;
  v8 = str[1];
  if ( (v8 | 0x20) != 120 )
  {
    if ( v7 <= 10 )
    {
      v9 = str + 1;
      v10 = 0;
      while ( (unsigned __int8)(v8 - 48) <= 9u )
      {
        v10 = v8 + 10 * v10 - 48;
        if ( v10 == -1 )
          break;
        if ( !--v7 )
          goto LABEL_16;
        v8 = *++v9;
      }
    }
    goto end;
  }
  if ( v7 <= 9 && v4 != 2 )
  {
    v19 = v4 - 2;
    v10 = 0;
    v29 = v4;
    v20 = str + 2;
    do
    {
      v21 = *v20++;
      v22 = v21 | 0x20;
      if ( (unsigned __int8)(v22 - 48) <= 9u )
      {
        v10 = (v22 - 48) | (16 * v10);
      }
      else
      {
        v25 = v19;
        v23 = __ctype_b_loc();
        v19 = v25;
        if ( ((*v23)[v22] & 0x1000) == 0 )
        {
          v4 = v29;
          v3 = 0;
          goto LABEL_20;
        }
        v10 = (v22 - 87) | (16 * v10);
      }
      --v19;
    }
    while ( v19 );
    v4 = v29;
LABEL_16:
    v3 = u2cp_(v10, to, NBSP_MODE_HACK);
LABEL_19:
    if ( *(unsigned __int8 *const **)(v27 + 4) == aliases_utf8 )
      return v3;
    goto LABEL_20;
  }
end:
  v3 = 0;
LABEL_20:
  v6 = v4;
  if ( v4 <= 0x13 )
  {
LABEL_21:
    v12 = nb_entity_cache_7078[v28];
    if ( v12 > 1 )
    {
      v13 = 10 * v28;
      v24 = v6;
      qsort(entity_cache_7077[v28], nb_entity_cache_7078[v28], 0x24u, hits_cmp);
      v6 = v24;
      v12 = nb_entity_cache_7078[v28];
      if ( v12 > 9 )
        goto LABEL_24;
    }
    else
    {
      v13 = 10 * v28;
    }
    nb_entity_cache_7078[v28] = ++v12;
LABEL_24:
    v14 = &entity_cache_7077[0][v12 - 1 + v13];
    v14->hits = 1;
    v14->strlen = v4;
    v14->result = v3;
    v14->encoding = to;
    memcpy(v14->str, str, v6);
    v14->str[v4] = 0;
  }
  return v3;
}

//----- (080ADE90) --------------------------------------------------------
unsigned __int8 *__cdecl convert_string_elinks(
        conv_table *convert_table,
        unsigned __int8 *chars,
        int charslen,
        int cp,
        convert_string_mode mode,
        int *length,
        void (*callback)(void *, unsigned __int8 *, int),
        void *callback_data)
{
  int v9; // edx
  int v10; // eax
  char v11; // cl
  const char *v12; // esi
  int v13; // ecx
  char v14; // al
  unsigned __int8 *v15; // ecx
  unsigned __int8 v16; // di
  int v17; // eax
  conv_table *tbl; // esi
  conv_table *v19; // esi
  unsigned __int8 *v20; // ecx
  bool v21; // cc
  int v22; // esi
  unsigned __int8 v23; // al
  unsigned __int8 v24; // al
  unsigned __int8 v25; // al
  const unsigned __int8 *entity_string; // eax
  const unsigned __int8 *str; // edi
  int v28; // esi
  unsigned __int8 *v29; // eax
  int v30; // [esp+1Ch] [ebp-4Ch]
  int v31; // [esp+1Ch] [ebp-4Ch]
  unsigned __int8 *v32; // [esp+34h] [ebp-34h]
  unsigned __int8 *buffer; // [esp+48h] [ebp-20h]
  int start; // [esp+4Ch] [ebp-1Ch]

  if ( convert_table || memchr(chars, 38, charslen) )
  {
    buffer = (unsigned __int8 *)mem_alloc(0x101u);
    if ( !buffer )
      return buffer;
    v9 = 0;
    v10 = 0;
    start = 0;
    if ( charslen <= 0 )
    {
LABEL_22:
      buffer[v10] = 0;
      if ( length )
        *length = v9;
      if ( callback )
      {
        if ( v9 )
          callback(callback_data, buffer, v9);
LABEL_27:
        mem_free(buffer);
        return 0;
      }
      return buffer;
    }
    while ( 1 )
    {
      v32 = &chars[start];
      v11 = chars[start];
      if ( v11 == 38 )
      {
        if ( (unsigned int)(mode - 2) <= 1 )
        {
          v12 = &delete;
          buffer[v9++] = 38;
          ++start;
          goto flush;
        }
        v20 = &chars[start];
        v21 = charslen <= start + 1;
        v22 = ++start;
        if ( !v21 )
        {
          do
          {
            v23 = v20[1];
            if ( (unsigned __int8)(v23 - 97) > 0x19u
              && (unsigned __int8)(v23 - 65) > 0x19u
              && (unsigned __int8)(v23 - 48) > 9u
              && v23 != 35 )
            {
              break;
            }
            ++v22;
            ++v20;
          }
          while ( charslen > v22 );
        }
        if ( mode && ((v24 = chars[v22], v24 == 61) || v24 == 38)
          || start >= v22
          || (v25 = chars[v22], (unsigned __int8)(v25 - 97) <= 0x19u)
          || (unsigned __int8)(v25 - 65) <= 0x19u
          || (unsigned __int8)(v25 - 48) <= 9u )
        {
          v12 = &delete;
          buffer[v9++] = 38;
          goto flush;
        }
        v30 = v9;
        entity_string = get_entity_string(&chars[start], v22 - start, cp);
        v9 = v30;
        str = entity_string;
        v28 = v22 - (chars[v22] != 59);
        if ( !entity_string )
        {
          v12 = &delete;
          buffer[v30] = *v32;
          v9 = v30 + 1;
flush:
          v13 = v9;
          if ( (_BYTE)v9 )
            goto LABEL_16;
          goto LABEL_14;
        }
        start = v28 + (v28 < charslen);
      }
      else
      {
        if ( v11 >= 0 || !convert_table )
        {
LABEL_12:
          v12 = &delete;
          buffer[v9++] = chars[start++];
          goto flush;
        }
        v15 = &chars[start];
        v16 = chars[start];
        v17 = start;
        tbl = convert_table;
        while ( 1 )
        {
          v19 = &tbl[v16];
          if ( !v19->t )
            break;
          ++v17;
          ++v15;
          tbl = v19->u.tbl;
          if ( charslen <= v17 )
            goto LABEL_12;
          v16 = *v15;
        }
        str = v19->u.str;
        start = v17 + 1;
      }
      v14 = *str;
      if ( !*str )
        goto LABEL_20;
      v13 = v9;
      v12 = (const char *)(str + 1);
      if ( !str[1] )
      {
        v12 = &delete;
        buffer[v9++] = v14;
        goto flush;
      }
      while ( 2 )
      {
        ++v9;
        buffer[v13] = v14;
        v13 = v9;
        if ( (_BYTE)v9 )
        {
          v14 = *v12;
          if ( !*v12 )
            goto LABEL_20;
LABEL_17:
          ++v12;
          continue;
        }
        break;
      }
LABEL_14:
      if ( callback )
      {
        buffer[v9] = 0;
        callback(callback_data, buffer, v9);
        v13 = 0;
        v9 = 0;
      }
      else
      {
        v31 = v9;
        v29 = (unsigned __int8 *)mem_realloc(buffer, v9 + 256);
        v9 = v31;
        if ( !v29 )
          goto LABEL_27;
        v13 = v31;
        buffer = v29;
      }
LABEL_16:
      v14 = *v12;
      if ( *v12 )
        goto LABEL_17;
LABEL_20:
      if ( charslen <= start )
      {
        v10 = v9;
        goto LABEL_22;
      }
    }
  }
  if ( callback )
  {
    buffer = 0;
    if ( charslen )
    {
      callback(callback_data, chars, charslen);
      return 0;
    }
    return buffer;
  }
  return memacpy(chars, charslen);
}

//----- (080AE240) --------------------------------------------------------
void __usercall add_utf8(unsigned int a1@<eax>, const unsigned __int8 *a2@<edx>)
{
  unsigned __int8 *v2; // eax
  conv_table *i; // edi
  conv_table *tbl; // esi
  unsigned __int8 *v5; // ebx
  conv_table *v6; // eax
  conv_table *v7; // eax
  int t; // ebx
  conv_table *v9; // eax
  unsigned __int8 *v10; // [esp+18h] [ebp-20h]

  *(_DWORD *)utf_buffer = 0;
  *(_WORD *)&utf_buffer[4] = 0;
  utf_buffer[6] = 0;
  if ( a1 <= 0x7F )
  {
    utf_buffer[0] = a1;
  }
  else if ( a1 <= 0x7FF )
  {
    utf_buffer[0] = (a1 >> 6) & 0x1F | 0xC0;
    utf_buffer[1] = a1 & 0x3F | 0x80;
  }
  else if ( a1 <= 0xFFFF )
  {
    utf_buffer[0] = (a1 >> 12) & 0xF | 0xE0;
    utf_buffer[1] = (a1 >> 6) & 0x3F | 0x80;
    utf_buffer[2] = a1 & 0x3F | 0x80;
  }
  else if ( a1 <= 0x1FFFFF )
  {
    utf_buffer[0] = (a1 >> 18) | 0xF0;
    utf_buffer[1] = (a1 >> 12) & 0x3F | 0x80;
    utf_buffer[2] = (a1 >> 6) & 0x3F | 0x80;
    utf_buffer[3] = a1 & 0x3F | 0x80;
  }
  else if ( a1 <= 0x3FFFFFF )
  {
    utf_buffer[0] = HIBYTE(a1) | 0xF8;
    utf_buffer[1] = (a1 >> 18) & 0x3F | 0x80;
    utf_buffer[2] = (a1 >> 12) & 0x3F | 0x80;
    utf_buffer[3] = (a1 >> 6) & 0x3F | 0x80;
    utf_buffer[4] = a1 & 0x3F | 0x80;
  }
  else
  {
    utf_buffer[0] = ((a1 & 0x40000000) != 0) | 0xFC;
    utf_buffer[1] = HIBYTE(a1) & 0x3F | 0x80;
    utf_buffer[2] = (a1 >> 18) & 0x3F | 0x80;
    utf_buffer[3] = (a1 >> 12) & 0x3F | 0x80;
    utf_buffer[4] = (a1 >> 6) & 0x3F | 0x80;
    utf_buffer[5] = a1 & 0x3F | 0x80;
  }
  v2 = utf_buffer;
  for ( i = table_elinks_0; ; i = tbl )
  {
    v5 = v2 + 1;
    if ( !v2[1] )
      break;
    v6 = &i[*v2];
    if ( v6->t )
    {
      tbl = v6->u.tbl;
    }
    else
    {
      if ( assert_failed )
        goto LABEL_18;
      assert_failed = v6->u.str != no_str;
      if ( assert_failed )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 790;
        elinks_internal("assertion ct[*p].u.str == no_str failed: bad utf encoding #1");
        if ( assert_failed )
          goto LABEL_18;
      }
      v7 = (conv_table *)mem_calloc(0x100u, 8u);
      tbl = v7;
      if ( !v7 )
        return;
      new_translation_table(v7);
      i[*(v5 - 1)].t = 1;
      i[*(v5 - 1)].u.str = (const unsigned __int8 *)tbl;
    }
    v2 = v5;
  }
  if ( assert_failed
    || (t = i[*v2].t, assert_failed = t != 0, t)
    && (v10 = v2,
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c",
        errline = 803,
        elinks_internal("assertion !ct[*p].t failed: bad utf encoding #2"),
        v2 = v10,
        assert_failed) )
  {
LABEL_18:
    assert_failed = 0;
    return;
  }
  v9 = &i[*v2];
  if ( v9->u.str == no_str )
    v9->u.str = a2;
}

//----- (080AE530) --------------------------------------------------------
const unsigned __int8 *__cdecl cp2utf8(int from, int c)
{
  int v2; // eax
  int v3; // eax
  unsigned int v4; // eax
  const unsigned __int8 *result; // eax
  unsigned int v6; // edx
  unsigned __int8 v7; // al
  unsigned int v8; // edx
  unsigned int v9; // ecx

  v2 = from;
  LOBYTE(v2) = from & 0x7F;
  v3 = 16 * v2 + 135286656;
  if ( c <= 127 || *(unsigned __int8 *const **)(v3 + 4) == aliases_utf8 )
    return (const unsigned __int8 *)&strings[2 * c];
  v4 = *(unsigned __int16 *)(*(_DWORD *)(v3 + 8) + 2 * (unsigned __int8)c - 256);
  if ( v4 == 0xFFFF )
  {
    *(_DWORD *)utf_buffer = 0;
    v7 = -67;
    LOBYTE(v8) = -65;
    *(_WORD *)&utf_buffer[4] = 0;
    LOBYTE(v9) = -17;
    utf_buffer[6] = 0;
  }
  else
  {
    *(_DWORD *)utf_buffer = 0;
    *(_WORD *)&utf_buffer[4] = 0;
    utf_buffer[6] = 0;
    if ( v4 <= 0x7F )
    {
      utf_buffer[0] = v4;
      return utf_buffer;
    }
    if ( v4 <= 0x7FF )
    {
      v6 = (v4 >> 6) & 0x1F | 0xFFFFFFC0;
      utf_buffer[1] = v4 & 0x3F | 0x80;
      result = utf_buffer;
      utf_buffer[0] = v6;
      return result;
    }
    v9 = (v4 >> 12) | 0xFFFFFFE0;
    v8 = (v4 >> 6) & 0x3F | 0xFFFFFF80;
    v7 = v4 & 0x3F | 0x80;
  }
  utf_buffer[2] = v7;
  result = utf_buffer;
  utf_buffer[0] = v9;
  utf_buffer[1] = v8;
  return result;
}

//----- (080AE640) --------------------------------------------------------
unsigned __int8 *__cdecl utf8_step_backward(
        unsigned __int8 *string,
        unsigned __int8 *start,
        int max,
        utf8_step way,
        int *count)
{
  unsigned __int8 *result; // eax
  int v6; // edx
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // ebx
  unsigned int v9; // ecx
  int v10; // esi
  int v11; // edx
  int v12; // edx
  unsigned __int8 v13; // dl
  unsigned __int8 v14; // dl
  unsigned __int8 v15; // dl
  unsigned __int8 v16; // dl
  unsigned __int8 v17; // dl
  unsigned __int8 *v18; // [esp+1Ch] [ebp-3Ch]
  int v19; // [esp+3Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_13;
  assert_failed = string == 0;
  if ( !string )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 510;
    elinks_internal("assertion string failed!");
    if ( assert_failed )
      goto LABEL_13;
  }
  assert_failed = start == 0;
  if ( start )
  {
    assert_failed = (unsigned int)max >> 31;
    if ( max >= 0 )
      goto LABEL_5;
LABEL_12:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 512;
    elinks_internal("assertion max >= 0 failed!");
    if ( assert_failed )
    {
LABEL_13:
      assert_failed = 0;
      result = string;
      v19 = 0;
      goto LABEL_14;
    }
    goto LABEL_5;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
  errline = 511;
  elinks_internal("assertion start failed!");
  if ( assert_failed )
    goto LABEL_13;
  assert_failed = (unsigned int)max >> 31;
  if ( max < 0 )
    goto LABEL_12;
LABEL_5:
  result = string;
  v19 = 0;
  if ( way )
  {
    if ( (unsigned int)way > UTF8_STEP_CELLS_MORE )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 558;
      elinks_internal("impossible enum utf8_step");
      result = string;
      goto LABEL_14;
    }
    if ( max <= 0 || (v7 = string, string <= start) )
    {
      result = string;
      v19 = 0;
      goto LABEL_14;
    }
    v18 = string;
    while ( 1 )
    {
      v8 = v7 - 1;
      if ( start >= v7 - 1 )
        goto LABEL_46;
LABEL_23:
      LOBYTE(v9) = *(v7 - 1);
      v10 = (unsigned __int8)v9;
      if ( (v9 & 0x80u) == 0 )
        break;
      v10 = (unsigned __int8)v9;
      if ( (v9 & 0xC0) == 192 )
        break;
      v7 = v8;
    }
    while ( 1 )
    {
      if ( &v8[utf8char_len_tab[v10]] > v18 )
      {
LABEL_36:
        v11 = 1;
        if ( way != UTF8_STEP_CELLS_FEWER )
          goto LABEL_43;
        goto LABEL_37;
      }
      switch ( v10 )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 128:
        case 129:
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 135:
        case 136:
        case 137:
        case 138:
        case 139:
        case 140:
        case 141:
        case 142:
        case 143:
        case 144:
        case 145:
        case 146:
        case 147:
        case 148:
        case 149:
        case 150:
        case 151:
        case 152:
        case 153:
        case 154:
        case 155:
        case 156:
        case 157:
        case 158:
        case 159:
        case 160:
        case 161:
        case 162:
        case 163:
        case 164:
        case 165:
        case 166:
        case 167:
        case 168:
        case 169:
        case 170:
        case 171:
        case 172:
        case 173:
        case 174:
        case 175:
        case 176:
        case 177:
        case 178:
        case 179:
        case 180:
        case 181:
        case 182:
        case 183:
        case 184:
        case 185:
        case 186:
        case 187:
        case 188:
        case 189:
        case 190:
        case 191:
        case 254:
        case 255:
          if ( (v9 & 0x80u) != 0 )
            goto LABEL_49;
          v9 = (unsigned __int8)v9;
          goto LABEL_72;
        case 192:
        case 193:
        case 194:
        case 195:
        case 196:
        case 197:
        case 198:
        case 199:
        case 200:
        case 201:
        case 202:
        case 203:
        case 204:
        case 205:
        case 206:
        case 207:
        case 208:
        case 209:
        case 210:
        case 211:
        case 212:
        case 213:
        case 214:
        case 215:
        case 216:
        case 217:
        case 218:
        case 219:
        case 220:
        case 221:
        case 222:
        case 223:
          v17 = *v7;
          if ( (v17 & 0xC0) == 128 )
          {
            v9 = (v17 & 0x3F) + ((v10 & 0x1F) << 6);
            if ( v9 > 0x7F )
              goto LABEL_55;
          }
          goto LABEL_49;
        case 224:
        case 225:
        case 226:
        case 227:
        case 228:
        case 229:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
          v16 = *v7;
          if ( (v16 & 0xC0) != 128 )
            goto LABEL_49;
          if ( (v8[2] & 0xC0) != 128 )
            goto LABEL_49;
          v9 = ((v16 & 0x3F) << 6) + (unsigned __int16)((_WORD)v10 << 12) + (v8[2] & 0x3F);
          if ( v9 <= 0x7FF || (v9 & 0xFFFFF800) == 55296 )
            goto LABEL_49;
          goto LABEL_55;
        case 240:
        case 241:
        case 242:
        case 243:
        case 244:
        case 245:
        case 246:
        case 247:
          v15 = *v7;
          if ( (v15 & 0xC0) == 128 && (v8[2] & 0xC0) == 128 && (v8[3] & 0xC0) == 128 )
          {
            v9 = (v8[3] & 0x3F) + ((v10 & 0xF) << 18) + ((v15 & 0x3F) << 12) + ((v8[2] & 0x3F) << 6);
            if ( v9 > 0xFFFF )
              goto LABEL_55;
          }
          goto LABEL_49;
        case 248:
        case 249:
        case 250:
        case 251:
          v14 = *v7;
          if ( (v14 & 0xC0) == 128 && (v8[2] & 0xC0) == 128 && (v8[3] & 0xC0) == 128 && (v8[4] & 0xC0) == 128 )
          {
            v9 = ((v8[2] & 0x3F) << 12)
               + (v8[4] & 0x3F)
               + ((v10 & 0xF) << 24)
               + ((v14 & 0x3F) << 18)
               + ((v8[3] & 0x3F) << 6);
            if ( v9 > 0x1FFFFF )
              goto LABEL_55;
          }
          goto LABEL_49;
        case 252:
        case 253:
          v13 = *v7;
          if ( (v13 & 0xC0) != 128
            || (v8[2] & 0xC0) != 128
            || (v8[3] & 0xC0) != 128
            || (v8[4] & 0xC0) != 128
            || (v8[5] & 0xC0) != 128
            || (v9 = ((v8[3] & 0x3F) << 12)
                   + ((v8[2] & 0x3F) << 18)
                   + (v8[5] & 0x3F)
                   + ((v10 & 1) << 30)
                   + ((v13 & 0x3F) << 24)
                   + ((v8[4] & 0x3F) << 6),
                v9 <= 0x3FFFFFF) )
          {
LABEL_49:
            v9 = 65533;
LABEL_28:
            if ( (v9 - 11904 > 0x764F || v9 == 12351)
              && v9 - 44032 > 0x2BA3
              && v9 - 63744 > 0x1FF
              && v9 - 65072 > 0x3F
              && v9 - 65280 > 0x60
              && v9 - 65504 > 6
              && v9 - 0x20000 > 0xFFFD
              && v9 - 196608 > 0xFFFD )
            {
              goto LABEL_36;
            }
            goto LABEL_42;
          }
LABEL_55:
          if ( v9 == -3 )
            goto LABEL_36;
LABEL_72:
          if ( v9 <= 0x10FF )
            goto LABEL_36;
          if ( v9 != 9001 && v9 > 0x115F && v9 != 9002 )
            goto LABEL_28;
LABEL_42:
          v11 = 2;
          if ( way != UTF8_STEP_CELLS_FEWER )
          {
LABEL_43:
            v19 += v11;
            if ( max <= v19 )
              goto invalid_arg;
            goto LABEL_44;
          }
LABEL_37:
          v12 = v19 + v11;
          if ( max < v12 )
          {
            result = v18;
            goto LABEL_14;
          }
          v19 = v12;
          if ( max <= v12 )
            goto invalid_arg;
LABEL_44:
          if ( start >= v8 )
          {
invalid_arg:
            result = v8;
            goto LABEL_14;
          }
          v7 = v8;
          v18 = v8--;
          if ( start < v8 )
            goto LABEL_23;
LABEL_46:
          LOBYTE(v9) = *(v7 - 1);
          v10 = (unsigned __int8)v9;
          break;
        default:
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
          errline = 719;
          elinks_internal("utf8char_len_tab out of range");
          v9 = 65533;
          goto LABEL_28;
      }
    }
  }
  v6 = 0;
LABEL_7:
  if ( result > start )
  {
    while ( v6 < max )
    {
      if ( (*--result & 0x80u) != 0 && (*result & 0xC0) != 192 )
        goto LABEL_7;
      ++v6;
      if ( result <= start )
        break;
    }
  }
  v19 = v6;
LABEL_14:
  if ( count )
    *count = v19;
  return result;
}

//----- (080AEC60) --------------------------------------------------------
unsigned __int8 *__cdecl utf8_step_forward(
        unsigned __int8 *string,
        unsigned __int8 *end,
        int max,
        utf8_step way,
        int *count)
{
  unsigned __int8 *v5; // edx
  unsigned __int8 *v6; // edi
  int v7; // ebx
  unsigned __int8 *v8; // esi
  __int16 v10; // cx
  char v11; // al
  unsigned __int8 *v12; // edx
  unsigned __int8 *v13; // eax
  unsigned int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  unsigned __int8 v18; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *v19; // [esp+24h] [ebp-34h]
  unsigned __int8 *v20; // [esp+24h] [ebp-34h]
  unsigned __int8 v21; // [esp+28h] [ebp-30h]
  unsigned __int8 v22; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 v23; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 v24; // [esp+30h] [ebp-28h]
  unsigned __int8 v25; // [esp+30h] [ebp-28h]
  unsigned __int8 v26; // [esp+30h] [ebp-28h]
  unsigned __int8 v27; // [esp+34h] [ebp-24h]
  unsigned __int8 v28; // [esp+34h] [ebp-24h]
  unsigned __int8 v29; // [esp+34h] [ebp-24h]
  unsigned __int8 v30; // [esp+34h] [ebp-24h]
  unsigned __int8 *v31; // [esp+38h] [ebp-20h]
  char v32; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 v33; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 v34; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 v35; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 v36; // [esp+3Ch] [ebp-1Ch]

  v5 = string;
  v6 = end;
  if ( assert_failed )
    goto LABEL_17;
  assert_failed = string == 0;
  if ( string )
  {
    assert_failed = (unsigned int)max >> 31;
    if ( max >= 0 )
      goto LABEL_4;
LABEL_16:
    v19 = v5;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 443;
    elinks_internal("assertion max >= 0 failed!");
    v5 = v19;
    if ( assert_failed )
    {
LABEL_17:
      assert_failed = 0;
      v8 = v5;
      v7 = 0;
      goto invalid_arg;
    }
    goto LABEL_4;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
  errline = 442;
  elinks_internal("assertion string failed!");
  v5 = 0;
  if ( assert_failed )
    goto LABEL_17;
  assert_failed = (unsigned int)max >> 31;
  if ( max < 0 )
    goto LABEL_16;
LABEL_4:
  if ( !end )
  {
    v20 = v5;
    v17 = __rawmemchr(v5, 0);
    v5 = v20;
    v6 = (unsigned __int8 *)v17;
  }
  v7 = 0;
  v8 = v5;
  if ( way == UTF8_STEP_CHARACTERS )
  {
LABEL_7:
    if ( v6 > v8 )
    {
      while ( v7 < max )
      {
        if ( (*++v8 & 0x80u) != 0 && (*v8 & 0xC0) != 192 )
          goto LABEL_7;
        ++v7;
        if ( v6 <= v8 )
          goto invalid_arg;
      }
    }
    goto invalid_arg;
  }
  if ( (unsigned int)way > UTF8_STEP_CELLS_MORE )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
    errline = 485;
    elinks_internal("impossible enum utf8_step");
    goto invalid_arg;
  }
  if ( v6 <= v5 || max <= 0 )
  {
    v8 = v5;
    v7 = 0;
    goto invalid_arg;
  }
  v32 = *v5;
  v10 = *v5;
  v11 = utf8char_len_tab[*v5];
  v12 = &v5[v11];
  if ( v6 < v12 )
  {
    v7 = 1;
    v8 = v6;
    goto invalid_arg;
  }
  v31 = v8;
  if ( (unsigned __int8)v11 <= 6u )
    goto LABEL_38;
LABEL_23:
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
  errline = 719;
  elinks_internal("utf8char_len_tab out of range");
  v13 = v31 + 1;
  while ( 2 )
  {
    v12 = v13;
    v14 = 65533;
LABEL_25:
    if ( v14 - 11904 <= 0x764F && v14 != 12351 )
    {
      v15 = 2;
      goto LABEL_49;
    }
    if ( v14 - 44032 <= 0x2BA3
      || v14 - 63744 <= 0x1FF
      || v14 - 65072 <= 0x3F
      || v14 - 65280 <= 0x60
      || v14 - 65504 <= 6
      || v14 - 0x20000 <= 0xFFFD
      || v14 - 196608 <= 0xFFFD )
    {
      goto LABEL_48;
    }
LABEL_33:
    v15 = 1;
    if ( way == UTF8_STEP_CELLS_FEWER )
      goto LABEL_50;
LABEL_34:
    v7 += v15;
    if ( max <= v7 )
      goto LABEL_52;
LABEL_35:
    if ( v6 <= v12 )
      goto LABEL_52;
    v32 = *v12;
    v10 = *v12;
    v11 = utf8char_len_tab[*v12];
    if ( v6 < &v12[v11] )
    {
LABEL_58:
      ++v7;
      v8 = v6;
      goto invalid_arg;
    }
    v31 = v12;
    v12 += v11;
LABEL_38:
    switch ( v11 )
    {
      case 1:
        if ( v32 < 0 )
        {
          v13 = v31 + 1;
          continue;
        }
        v14 = (unsigned __int8)v32;
LABEL_46:
        if ( v14 <= 0x10FF )
          goto LABEL_33;
        if ( v14 > 0x115F && v14 != 9001 && v14 != 9002 )
          goto LABEL_25;
LABEL_48:
        v15 = 2;
LABEL_49:
        if ( way != UTF8_STEP_CELLS_FEWER )
          goto LABEL_34;
LABEL_50:
        v16 = v7 + v15;
        if ( max < v16 )
        {
          v8 = v31;
        }
        else
        {
          v7 = v16;
          if ( max > v16 )
            goto LABEL_35;
LABEL_52:
          v8 = v12;
        }
invalid_arg:
        if ( count )
          *count = v7;
        return v8;
      case 2:
        v13 = v31 + 1;
        v30 = v31[1];
        if ( (v30 & 0xC0) != 128 )
          continue;
        v14 = (v30 & 0x3F) + ((v10 & 0x1F) << 6);
        if ( v14 <= 0x7F )
          continue;
        goto LABEL_57;
      case 3:
        v13 = v31 + 1;
        v24 = v31[1];
        if ( (v24 & 0xC0) != 128 )
          continue;
        v33 = v31[2];
        if ( (v33 & 0xC0) != 128 )
          continue;
        v14 = (v33 & 0x3F) + (unsigned __int16)(v10 << 12) + ((v24 & 0x3F) << 6);
        if ( v14 <= 0x7FF || (v14 & 0xFFFFF800) == 55296 )
          continue;
        goto LABEL_57;
      case 4:
        v13 = v31 + 1;
        v23 = v31[1];
        if ( (v23 & 0xC0) != 128 )
          continue;
        v36 = v31[2];
        if ( (v36 & 0xC0) != 128 )
          continue;
        v29 = v31[3];
        if ( (v29 & 0xC0) != 128 )
          continue;
        v14 = (v29 & 0x3F) + ((v10 & 0xF) << 18) + ((v23 & 0x3F) << 12) + ((v36 & 0x3F) << 6);
        if ( v14 <= 0xFFFF )
          continue;
        goto LABEL_57;
      case 5:
        v13 = v31 + 1;
        v21 = v31[1];
        if ( (v21 & 0xC0) != 128 )
          continue;
        v35 = v31[2];
        if ( (v35 & 0xC0) != 128 )
          continue;
        v28 = v31[3];
        if ( (v28 & 0xC0) != 128 )
          continue;
        v26 = v31[4];
        if ( (v26 & 0xC0) != 128 )
          continue;
        v14 = ((v35 & 0x3F) << 12) + (v26 & 0x3F) + ((v10 & 0xF) << 24) + ((v21 & 0x3F) << 18) + ((v28 & 0x3F) << 6);
        if ( v14 <= 0x1FFFFF )
          continue;
        goto LABEL_57;
      case 6:
        v13 = v31 + 1;
        v18 = v31[1];
        if ( (v18 & 0xC0) != 128 )
          continue;
        v34 = v31[2];
        if ( (v34 & 0xC0) != 128 )
          continue;
        v27 = v31[3];
        if ( (v27 & 0xC0) != 128 )
          continue;
        v25 = v31[4];
        if ( (v25 & 0xC0) != 128 )
          continue;
        v22 = v31[5];
        if ( (v22 & 0xC0) != 128 )
          continue;
        v14 = ((v27 & 0x3F) << 12)
            + ((v34 & 0x3F) << 18)
            + (v22 & 0x3F)
            + ((v10 & 1) << 30)
            + ((v18 & 0x3F) << 24)
            + ((v25 & 0x3F) << 6);
        if ( v14 <= 0x3FFFFFF )
          continue;
LABEL_57:
        if ( v14 == -3 )
          goto LABEL_58;
        goto LABEL_46;
      default:
        goto LABEL_23;
    }
  }
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080AF2F0) --------------------------------------------------------
conv_table *__cdecl get_translation_table(int from, int to)
{
  unsigned int v2; // esi
  int v3; // ebx
  int v4; // esi
  int v5; // edi
  int m; // esi
  unsigned __int16 v7; // ax
  const unsigned __int8 *v8; // eax
  conv_table *result; // eax
  int v10; // esi
  const uint16_t *v11; // edi
  uint16_t v12; // ax
  const table_entry *v13; // ecx
  unsigned __int8 v14; // al
  const table_entry *v15; // ebx
  int v16; // ebx
  unsigned int x; // eax
  unsigned int v18; // esi
  int v19; // ebx
  unsigned __int8 *str; // eax
  int i; // eax
  int v22; // ebx
  const uint16_t *highhalf; // esi
  unsigned int v24; // eax
  int j; // ebx
  const table_entry *table_elinks; // edx
  unsigned __int8 c; // al
  const table_entry *v28; // ebx
  uint16_t u; // dx
  int k; // ebx

  v3 = to;
  v2 = from & 0xFFFFFF7F;
  LOBYTE(v3) = to & 0x7F;
  if ( first )
  {
    memset(table_elinks_0, 0, sizeof(table_elinks_0));
    first = 0;
  }
  if ( codepages[v3].aliases == aliases_utf8 )
  {
    v18 = from & 0xFFFFFF7F;
    if ( (from & 0xFFFFFF7F) != lfr_6850 )
    {
      v19 = 128;
      lfr_6850 = from & 0xFFFFFF7F;
      if ( utf_table_init )
      {
        memset(utf_table, 0, sizeof(utf_table));
        utf_table_init = 0;
      }
      else
      {
        do
        {
          str = (unsigned __int8 *)utf_table[v19++].u.str;
          mem_free(str);
        }
        while ( v19 != 256 );
      }
      for ( i = 0; i != 128; ++i )
        utf_table[i].u.str = (const unsigned __int8 *)&strings[i * 2];
      if ( codepages[v18].aliases == aliases_utf8 )
      {
        for ( j = 0; j != 128; ++j )
          utf_table[j + 128].u.str = stracpy((const unsigned __int8 *)(j * 2 + 135295520));
      }
      else
      {
        v22 = 128;
        highhalf = codepages[v18].highhalf;
        do
        {
          v24 = highhalf[v22 - 128];
          if ( v24 == 0xFFFF )
          {
            utf_table[v22].u.str = 0;
          }
          else
          {
            *(_DWORD *)utf_buffer = 0;
            *(_WORD *)&utf_buffer[4] = 0;
            utf_buffer[6] = 0;
            if ( v24 <= 0x7F )
            {
              utf_buffer[0] = v24;
            }
            else if ( v24 <= 0x7FF )
            {
              utf_buffer[0] = (v24 >> 6) & 0x1F | 0xC0;
              utf_buffer[1] = v24 & 0x3F | 0x80;
            }
            else
            {
              utf_buffer[0] = (v24 >> 12) | 0xE0;
              utf_buffer[1] = (v24 >> 6) & 0x3F | 0x80;
              utf_buffer[2] = v24 & 0x3F | 0x80;
            }
            utf_table[v22].u.str = stracpy(utf_buffer);
          }
          ++v22;
        }
        while ( v22 != 256 );
        table_elinks = codepages[from & 0xFFFFFF7F].table_elinks;
        c = table_elinks->c;
        if ( table_elinks->c )
        {
          v28 = table_elinks + 1;
          do
          {
            u = table_elinks->u;
            if ( !utf_table[c].u.str )
            {
              memset(utf_buffer, 0, sizeof(utf_buffer));
              if ( u <= 0x7Fu )
              {
                utf_buffer[0] = u;
              }
              else if ( u <= 0x7FFu )
              {
                utf_buffer[0] = (u >> 6) & 0x1F | 0xC0;
                utf_buffer[1] = u & 0x3F | 0x80;
              }
              else
              {
                utf_buffer[0] = (u >> 12) | 0xE0;
                utf_buffer[1] = (u >> 6) & 0x3F | 0x80;
                utf_buffer[2] = u & 0x3F | 0x80;
              }
              utf_table[c].u.str = stracpy(utf_buffer);
            }
            c = v28->c;
            table_elinks = v28++;
          }
          while ( c );
        }
        for ( k = 128; k != 256; ++k )
        {
          if ( !utf_table[k].u.str )
            utf_table[k].u.str = stracpy(no_str);
        }
      }
    }
    return utf_table;
  }
  else if ( v2 != lfr_6932 || (result = table_elinks_0, v3 != lto_6933) )
  {
    lfr_6932 = from & 0xFFFFFF7F;
    v4 = 16 * v2;
    lto_6933 = v3;
    new_translation_table(table_elinks_0);
    if ( *(unsigned __int8 *const **)(v4 + 135286660) == aliases_utf8 )
    {
      add_utf8(0xA0u, (const unsigned __int8 *)&strings[2]);
      add_utf8(0xADu, (const unsigned __int8 *)&delete);
      v10 = 0;
      v11 = codepages[v3].highhalf;
      do
      {
        v12 = v11[v10];
        if ( v12 != 0xFFFF )
          add_utf8(v12, (const unsigned __int8 *)(v10 * 2 + 135295520));
        ++v10;
      }
      while ( v10 != 128 );
      v13 = codepages[v3].table_elinks;
      v14 = v13->c;
      if ( v13->c )
      {
        v15 = v13 + 1;
        do
        {
          add_utf8(v13->u, (const unsigned __int8 *)&strings[2 * v14]);
          v14 = v15->c;
          v13 = v15++;
        }
        while ( v14 );
      }
      v16 = 0;
      while ( 1 )
      {
        x = unicode_7b[++v16].x;
        if ( x == -1 )
          break;
        if ( x > 0x7F )
          add_utf8(x, unicode_7b[v16].s);
      }
    }
    else
    {
      v5 = *(_DWORD *)(v4 + 135286664);
      for ( m = 128; m != 256; ++m )
      {
        v7 = *(_WORD *)(v5 + 2 * m - 256);
        if ( v7 != 0xFFFF )
        {
          v8 = u2cp_(v7, v3, NBSP_MODE_HACK);
          if ( v8 )
            table_elinks_0[m].u.str = v8;
        }
      }
    }
    return table_elinks_0;
  }
  return result;
}
// 8145244: using guessed type int lfr_6850;

//----- (080AF720) --------------------------------------------------------
int __cdecl utf8_char2cells(unsigned __int8 *utf8_char, unsigned __int8 *end)
{
  unsigned __int8 *v2; // eax
  int v4; // edi
  unsigned int v5; // edx
  unsigned __int8 v6; // bl
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // [esp+1Ch] [ebp-2Ch]

  v2 = end;
  if ( !end )
  {
    v2 = (unsigned __int8 *)__rawmemchr(utf8_char, 0);
    if ( !v2 )
      return -1;
  }
  if ( !utf8_char )
    return -1;
  v4 = *utf8_char;
  v5 = -3;
  if ( v2 >= &utf8_char[utf8char_len_tab[v4]] )
  {
    switch ( *utf8_char )
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
      case 0x14u:
      case 0x15u:
      case 0x16u:
      case 0x17u:
      case 0x18u:
      case 0x19u:
      case 0x1Au:
      case 0x1Bu:
      case 0x1Cu:
      case 0x1Du:
      case 0x1Eu:
      case 0x1Fu:
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x23u:
      case 0x24u:
      case 0x25u:
      case 0x26u:
      case 0x27u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Du:
      case 0x3Eu:
      case 0x3Fu:
      case 0x40u:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Bu:
      case 0x5Cu:
      case 0x5Du:
      case 0x5Eu:
      case 0x5Fu:
      case 0x60u:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
      case 0x7Bu:
      case 0x7Cu:
      case 0x7Du:
      case 0x7Eu:
      case 0x7Fu:
      case 0x80u:
      case 0x81u:
      case 0x82u:
      case 0x83u:
      case 0x84u:
      case 0x85u:
      case 0x86u:
      case 0x87u:
      case 0x88u:
      case 0x89u:
      case 0x8Au:
      case 0x8Bu:
      case 0x8Cu:
      case 0x8Du:
      case 0x8Eu:
      case 0x8Fu:
      case 0x90u:
      case 0x91u:
      case 0x92u:
      case 0x93u:
      case 0x94u:
      case 0x95u:
      case 0x96u:
      case 0x97u:
      case 0x98u:
      case 0x99u:
      case 0x9Au:
      case 0x9Bu:
      case 0x9Cu:
      case 0x9Du:
      case 0x9Eu:
      case 0x9Fu:
      case 0xA0u:
      case 0xA1u:
      case 0xA2u:
      case 0xA3u:
      case 0xA4u:
      case 0xA5u:
      case 0xA6u:
      case 0xA7u:
      case 0xA8u:
      case 0xA9u:
      case 0xAAu:
      case 0xABu:
      case 0xACu:
      case 0xADu:
      case 0xAEu:
      case 0xAFu:
      case 0xB0u:
      case 0xB1u:
      case 0xB2u:
      case 0xB3u:
      case 0xB4u:
      case 0xB5u:
      case 0xB6u:
      case 0xB7u:
      case 0xB8u:
      case 0xB9u:
      case 0xBAu:
      case 0xBBu:
      case 0xBCu:
      case 0xBDu:
      case 0xBEu:
      case 0xBFu:
      case 0xFEu:
      case 0xFFu:
        if ( (*utf8_char & 0x80u) == 0 )
          return 1;
        goto LABEL_28;
      case 0xC0u:
      case 0xC1u:
      case 0xC2u:
      case 0xC3u:
      case 0xC4u:
      case 0xC5u:
      case 0xC6u:
      case 0xC7u:
      case 0xC8u:
      case 0xC9u:
      case 0xCAu:
      case 0xCBu:
      case 0xCCu:
      case 0xCDu:
      case 0xCEu:
      case 0xCFu:
      case 0xD0u:
      case 0xD1u:
      case 0xD2u:
      case 0xD3u:
      case 0xD4u:
      case 0xD5u:
      case 0xD6u:
      case 0xD7u:
      case 0xD8u:
      case 0xD9u:
      case 0xDAu:
      case 0xDBu:
      case 0xDCu:
      case 0xDDu:
      case 0xDEu:
      case 0xDFu:
        if ( (utf8_char[1] & 0xC0) == 128 )
        {
          v5 = ((v4 & 0x1F) << 6) + (utf8_char[1] & 0x3F);
          if ( v5 > 0x7F )
            goto LABEL_21;
        }
        goto LABEL_28;
      case 0xE0u:
      case 0xE1u:
      case 0xE2u:
      case 0xE3u:
      case 0xE4u:
      case 0xE5u:
      case 0xE6u:
      case 0xE7u:
      case 0xE8u:
      case 0xE9u:
      case 0xEAu:
      case 0xEBu:
      case 0xECu:
      case 0xEDu:
      case 0xEEu:
      case 0xEFu:
        if ( (utf8_char[1] & 0xC0) != 128 )
          goto LABEL_28;
        if ( (utf8_char[2] & 0xC0) != 128 )
          goto LABEL_28;
        v5 = ((utf8_char[1] & 0x3F) << 6) + (unsigned __int16)((_WORD)v4 << 12) + (utf8_char[2] & 0x3F);
        if ( v5 <= 0x7FF || (v5 & 0xFFFFF800) == 55296 )
          goto LABEL_28;
LABEL_21:
        if ( v5 <= 0x10FF )
          return 1;
        if ( v5 <= 0x115F || v5 == 9001 )
          return 2;
LABEL_37:
        if ( v5 == 9002 )
          return 2;
        break;
      case 0xF0u:
      case 0xF1u:
      case 0xF2u:
      case 0xF3u:
      case 0xF4u:
      case 0xF5u:
      case 0xF6u:
      case 0xF7u:
        if ( (utf8_char[1] & 0xC0) == 128 && (utf8_char[2] & 0xC0) == 128 && (utf8_char[3] & 0xC0) == 128 )
        {
          v5 = (utf8_char[3] & 0x3F) + ((v4 & 0xF) << 18) + ((utf8_char[1] & 0x3F) << 12) + ((utf8_char[2] & 0x3F) << 6);
          if ( v5 > 0xFFFF )
            goto LABEL_37;
        }
        goto LABEL_28;
      case 0xF8u:
      case 0xF9u:
      case 0xFAu:
      case 0xFBu:
        if ( (utf8_char[1] & 0xC0) == 128 && (utf8_char[2] & 0xC0) == 128 && (utf8_char[3] & 0xC0) == 128 )
        {
          v7 = utf8_char[4];
          if ( (v7 & 0xC0) == 128 )
          {
            v5 = ((utf8_char[3] & 0x3F) << 6)
               + (v7 & 0x3F)
               + ((v4 & 0xF) << 24)
               + ((utf8_char[1] & 0x3F) << 18)
               + ((utf8_char[2] & 0x3F) << 12);
            if ( v5 > 0x1FFFFF )
              goto LABEL_37;
          }
        }
        goto LABEL_28;
      case 0xFCu:
      case 0xFDu:
        if ( (utf8_char[1] & 0xC0) == 128 && (utf8_char[2] & 0xC0) == 128 && (utf8_char[3] & 0xC0) == 128 )
        {
          v8 = utf8_char[4];
          if ( (v8 & 0xC0) == 128 )
          {
            v6 = utf8_char[5];
            if ( (v6 & 0xC0) == 128 )
            {
              v5 = ((v8 & 0x3F) << 6)
                 + ((utf8_char[3] & 0x3F) << 12)
                 + (v6 & 0x3F)
                 + ((v4 & 1) << 30)
                 + ((utf8_char[1] & 0x3F) << 24)
                 + ((utf8_char[2] & 0x3F) << 18);
              if ( v5 > 0x3FFFFFF )
                goto LABEL_37;
            }
          }
        }
LABEL_28:
        v5 = 65533;
        break;
      default:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
        errline = 719;
        elinks_internal("utf8char_len_tab out of range");
        v5 = 65533;
        break;
    }
  }
  if ( (v5 - 11904 > 0x764F || v5 == 12351)
    && v5 - 44032 > 0x2BA3
    && v5 - 63744 > 0x1FF
    && v5 - 65072 > 0x3F
    && v5 - 65280 > 0x60
    && v5 - 65504 > 6
    && v5 - 0x20000 > 0xFFFD
    && v5 - 196608 > 0xFFFD )
  {
    return 1;
  }
  else
  {
    return 2;
  }
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080AFB10) --------------------------------------------------------
int __cdecl utf8_cells2bytes(unsigned __int8 *string, int max_cells, unsigned __int8 *end)
{
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v5; // edi
  unsigned __int8 *v6; // eax
  int v7; // ebx
  unsigned __int8 *v8; // edx
  unsigned int v9; // esi
  int v10; // eax
  unsigned __int8 *v11; // [esp+18h] [ebp-20h]

  v3 = end;
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)max_cells >> 31;
    if ( max_cells < 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/intl/charsets.c";
      errline = 397;
      elinks_internal("assertion max_cells>=0 failed!");
    }
  }
  if ( end || (v3 = (unsigned __int8 *)__rawmemchr(string, 0)) != 0 )
  {
    if ( string )
    {
      v5 = string;
      v6 = v3;
      v7 = 0;
      v8 = v6;
      v9 = 0;
      while ( 1 )
      {
        v11 = v8;
        v10 = utf8_char2cells(v5, v8);
        v8 = v11;
        if ( v10 < 0 )
          break;
        v9 += v10;
        if ( v9 > max_cells )
          return v7;
        if ( v5 )
        {
          v7 += utf8char_len_tab[*v5];
          v5 = &string[v7];
          if ( v11 < &string[v7] )
            return v11 - string;
        }
      }
    }
  }
  return -1;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080AFC10) --------------------------------------------------------
int __cdecl utf8_ptr2cells(unsigned __int8 *string, unsigned __int8 *end)
{
  unsigned __int8 *v2; // esi
  unsigned __int8 *v3; // edi
  unsigned __int8 *v4; // ebx
  int v5; // eax
  int cells; // [esp+1Ch] [ebp-1Ch]

  v2 = end;
  v3 = string;
  if ( end || (v2 = (unsigned __int8 *)__rawmemchr(string, 0)) != 0 )
  {
    if ( string )
    {
      cells = 0;
      v4 = &string[utf8char_len_tab[*string]];
      if ( v2 < v4 )
        return cells;
      while ( 1 )
      {
        v5 = utf8_char2cells(v3, v2);
        if ( v5 < 0 )
          break;
        cells += v5;
        if ( v2 < &v4[utf8char_len_tab[*v4]] )
          return cells;
        v3 = v4;
        v4 += utf8char_len_tab[*v4];
      }
    }
  }
  return -1;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080AFCA0) --------------------------------------------------------
void __usercall set_binding_values(
        const unsigned __int8 *domainname@<eax>,
        const unsigned __int8 **dirnamep@<edx>,
        const unsigned __int8 **codesetp@<ecx>)
{
  binding *v5; // edi
  int v6; // eax
  int v7; // edx
  const unsigned __int8 *v8; // ebx
  int v9; // eax
  const unsigned __int8 *v10; // eax
  int v11; // eax
  unsigned __int8 *dirname; // ecx
  int v13; // edx
  const unsigned __int8 **v14; // ecx
  const unsigned __int8 *v15; // esi
  const unsigned __int8 *codeset; // ebx
  int v17; // eax
  int v18; // eax
  unsigned __int8 *v19; // esi
  size_t v20; // eax
  binding *v21; // eax
  binding *v22; // edi
  int v23; // ecx
  const unsigned __int8 *v24; // eax
  const unsigned __int8 *v25; // eax
  binding *v26; // edx
  int v27; // eax
  const unsigned __int8 *v28; // edi
  binding *i; // ebx
  binding *next; // esi
  const char *ptr; // [esp+14h] [ebp-24h]
  const unsigned __int8 *ptrc; // [esp+14h] [ebp-24h]
  void *ptrd; // [esp+14h] [ebp-24h]
  void *ptre; // [esp+14h] [ebp-24h]
  const unsigned __int8 *ptra; // [esp+14h] [ebp-24h]
  binding *ptrb; // [esp+14h] [ebp-24h]
  size_t lena; // [esp+18h] [ebp-20h]
  size_t len; // [esp+18h] [ebp-20h]
  binding *v40; // [esp+1Ch] [ebp-1Ch]

  if ( !domainname || !*domainname )
    goto failed;
  v5 = nl_domain_bindings__;
  if ( !nl_domain_bindings__ )
    goto LABEL_33;
  while ( 1 )
  {
    v6 = strcmp((const char *)domainname, (const char *)v5->domainname);
    if ( !v6 )
      break;
    if ( v6 >= 0 )
    {
      v5 = v5->next;
      if ( v5 )
        continue;
    }
    goto LABEL_33;
  }
  if ( !v5 )
  {
LABEL_33:
    if ( (!dirnamep || !*dirnamep) && (!codesetp || !*codesetp) )
    {
      if ( dirnamep )
        *dirnamep = nl_default_dirname__;
      if ( codesetp )
        *codesetp = 0;
      return;
    }
    v20 = strlen((const char *)domainname);
    len = v20 + 1;
    v21 = (binding *)malloc(v20 + 17);
    v22 = v21;
    if ( !v21 )
    {
failed:
      if ( dirnamep )
        *dirnamep = 0;
      if ( codesetp )
        *codesetp = 0;
      return;
    }
    memcpy(v21->domainname, domainname, len);
    if ( dirnamep )
    {
      v24 = nl_default_dirname__;
      if ( *dirnamep )
      {
        ptra = *dirnamep;
        v23 = strcmp((const char *)*dirnamep, (const char *)nl_default_dirname__);
        v24 = nl_default_dirname__;
        if ( v23 )
        {
          v24 = (const unsigned __int8 *)__strdup(v23, ptra);
          if ( !v24 )
          {
failed_dirname:
            free(v22);
            goto failed;
          }
        }
      }
      *dirnamep = v24;
      v22->dirname = (unsigned __int8 *)v24;
    }
    else
    {
      v22->dirname = (unsigned __int8 *)nl_default_dirname__;
    }
    v22->codeset_cntr = 0;
    if ( codesetp )
    {
      v25 = *codesetp;
      if ( *codesetp )
      {
        v25 = (const unsigned __int8 *)__strdup(v23, *codesetp);
        if ( !v25 )
        {
          if ( v22->dirname != nl_default_dirname__ )
            free(v22->dirname);
          goto failed_dirname;
        }
        ++v22->codeset_cntr;
      }
      *codesetp = v25;
      v22->codeset = (unsigned __int8 *)v25;
    }
    else
    {
      v22->codeset = 0;
    }
    v26 = nl_domain_bindings__;
    if ( nl_domain_bindings__
      && (ptrb = nl_domain_bindings__,
          v27 = strcmp((const char *)domainname, (const char *)nl_domain_bindings__->domainname),
          v26 = ptrb,
          v27 >= 0) )
    {
      v40 = v22;
      v28 = domainname;
      for ( i = ptrb; ; i = next )
      {
        next = i->next;
        if ( !i->next || strcmp((const char *)v28, (const char *)next->domainname) <= 0 )
          break;
      }
      v40->next = next;
      i->next = v40;
    }
    else
    {
      v22->next = v26;
      nl_domain_bindings__ = v22;
    }
LABEL_32:
    ++nl_msg_cat_cntr;
    return;
  }
  v7 = 0;
  if ( !dirnamep )
    goto LABEL_22;
  v8 = *dirnamep;
  if ( *dirnamep )
  {
    ptr = (const char *)v5->dirname;
    v9 = strcmp((const char *)*dirnamep, ptr);
    v7 = 0;
    lena = v9;
    v10 = (const unsigned __int8 *)ptr;
    if ( lena )
    {
      v11 = strcmp((const char *)v8, (const char *)nl_default_dirname__);
      dirname = (unsigned __int8 *)ptr;
      v13 = v11;
      v10 = nl_default_dirname__;
      if ( !v13 )
      {
LABEL_18:
        if ( dirname != nl_default_dirname__ )
        {
          ptrc = v10;
          free(dirname);
          v10 = ptrc;
        }
        v5->dirname = (unsigned __int8 *)v10;
        v7 = 1;
        goto LABEL_21;
      }
      v10 = (const unsigned __int8 *)__strdup(ptr, v8);
      v7 = 0;
      if ( v10 )
      {
        dirname = v5->dirname;
        goto LABEL_18;
      }
    }
LABEL_21:
    *dirnamep = v10;
    goto LABEL_22;
  }
  *dirnamep = v5->dirname;
LABEL_22:
  if ( codesetp )
  {
    v14 = codesetp;
    v15 = *codesetp;
    if ( *codesetp )
    {
      codeset = v5->codeset;
      if ( !codeset
        || (ptrd = (void *)v7, v17 = strcmp((const char *)v15, (const char *)v5->codeset), v7 = (int)ptrd, v17) )
      {
        ptre = (void *)v7;
        v18 = __strdup(v14, v15);
        v7 = (int)ptre;
        v19 = (unsigned __int8 *)v18;
        codeset = (const unsigned __int8 *)v18;
        if ( v18 )
        {
          if ( v5->codeset )
            free(v5->codeset);
          ++v5->codeset_cntr;
          v7 = 1;
          v5->codeset = v19;
        }
      }
      *codesetp = codeset;
    }
    else
    {
      *codesetp = v5->codeset;
    }
  }
  if ( v7 )
    goto LABEL_32;
}
// 80AFDCE: variable 'v14' is possibly undefined
// 80AFEBA: variable 'v23' is possibly undefined
// 8059A88: using guessed type int __thiscall __strdup(_DWORD, _DWORD);

//----- (080AFFF0) --------------------------------------------------------
unsigned __int8 *__cdecl bind_textdomain_codeset__(const unsigned __int8 *domainname, const unsigned __int8 *codeset)
{
  set_binding_values(domainname, 0, &codeset);
  return (unsigned __int8 *)codeset;
}

//----- (080B0010) --------------------------------------------------------
unsigned __int8 *__cdecl bindtextdomain__(const unsigned __int8 *domainname, const unsigned __int8 *dirname)
{
  set_binding_values(domainname, &dirname, 0);
  return (unsigned __int8 *)dirname;
}

//----- (080B0030) --------------------------------------------------------
unsigned __int8 *__cdecl dcgettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid, int category)
{
  return dcigettext__(domainname, msgid, 0, 0, 0, category);
}

//----- (080B0070) --------------------------------------------------------
unsigned int __usercall plural_eval@<eax>(expression *pexp@<eax>, unsigned int n@<edx>)
{
  expression *v2; // ebx
  int nargs; // eax
  bool v5; // cc
  unsigned int v7; // edi
  operator v8; // eax
  operator operation; // eax
  unsigned int v10; // ecx

  v2 = pexp;
  nargs = pexp->nargs;
  v5 = nargs <= 1;
  if ( nargs == 1 )
    return plural_eval(v2->val.args[0], n) == 0;
  while ( 1 )
  {
    if ( v5 )
    {
      if ( nargs )
        return 0;
      operation = v2->operation;
      if ( operation )
      {
        if ( operation != num )
          return 0;
        return v2->val.num;
      }
      return n;
    }
    if ( nargs == 2 )
      break;
    if ( nargs != 3 )
      return 0;
    v2 = v2->val.args[-(plural_eval(v2->val.args[0], n) != 0) + 2];
    nargs = v2->nargs;
    v5 = v2->nargs <= 1;
    if ( v2->nargs == 1 )
      return plural_eval(v2->val.args[0], n) == 0;
  }
  v7 = plural_eval(v2->val.args[0], n);
  v8 = v2->operation;
  if ( v8 == lor )
  {
    return v7 || plural_eval(v2->val.args[1], n) != 0;
  }
  else
  {
    if ( v8 == land )
    {
      if ( v7 )
        return plural_eval(v2->val.args[1], n) != 0;
      return 0;
    }
    v10 = plural_eval(v2->val.args[1], n);
    switch ( v2->operation )
    {
      case mult:
        n = v7 * v10;
        break;
      case divide:
        n = v7 / v10;
        break;
      case module:
        n = v7 % v10;
        break;
      case plus:
        n = v10 + v7;
        break;
      case minus:
        n = v7 - v10;
        break;
      case less_than:
        n = v7 < v10;
        break;
      case greater_than:
        n = v7 > v10;
        break;
      case less_or_equal:
        n = v7 <= v10;
        break;
      case greater_or_equal:
        n = v7 >= v10;
        break;
      case equal:
        n = v7 == v10;
        break;
      case not_equal:
        n = v7 != v10;
        break;
      default:
        return 0;
    }
  }
  return n;
}

//----- (080B0200) --------------------------------------------------------
int __cdecl transcmp(const void *p1, const void *p2)
{
  int result; // eax

  result = strcmp((const char *)p1 + 24, (const char *)p2 + 24);
  if ( !result )
  {
    result = strcmp(*(const char **)p1, *(const char **)p2);
    if ( !result )
      return *((_DWORD *)p1 + 1) - *((_DWORD *)p2 + 1);
  }
  return result;
}

//----- (080B0250) --------------------------------------------------------
unsigned __int8 *__cdecl nl_find_msg(
        loaded_l10nfile *domain_file,
        binding *domainbinding,
        const unsigned __int8 *msgid,
        size_t *lengthp)
{
  const unsigned __int8 *v4; // ebx
  loaded_domain *data; // esi
  size_t v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // ebx
  int must_swap; // edi
  int v10; // esi
  int v11; // esi
  string_desc *orig_tab; // edx
  unsigned int v13; // eax
  int v14; // eax
  bool v15; // cf
  unsigned int v16; // edx
  int v18; // edx
  loaded_domain *v19; // esi
  string_desc *v20; // eax
  unsigned __int8 *v21; // ebx
  size_t v22; // edi
  int codeset_cntr; // eax
  unsigned __int8 **conv_tab; // eax
  size_t *v25; // eax
  unsigned int nstrings; // ecx
  loaded_domain *v27; // edx
  unsigned int v28; // esi
  unsigned int v29; // edi
  nls_uint32 offset; // ecx
  int v31; // eax
  int v32; // eax
  unsigned int v33; // ebx
  unsigned __int8 *v34; // ebx
  int v35; // esi
  char *v36; // edx
  unsigned __int8 *v37; // eax
  char *v38; // edx
  unsigned __int8 *v39; // eax
  size_t v40; // eax
  int v41; // [esp+2Ch] [ebp-4Ch]
  loaded_domain *v42; // [esp+2Ch] [ebp-4Ch]
  int v43; // [esp+2Ch] [ebp-4Ch]
  nls_uint32 v44; // [esp+34h] [ebp-44h]
  unsigned int v45; // [esp+38h] [ebp-40h]
  nls_uint32 incr; // [esp+3Ch] [ebp-3Ch]
  char *hash_tab; // [esp+40h] [ebp-38h]
  unsigned int v48; // [esp+44h] [ebp-34h]
  int v49; // [esp+44h] [ebp-34h]
  int v50; // [esp+44h] [ebp-34h]
  loaded_domain *domain; // [esp+48h] [ebp-30h]
  loaded_domain *domaina; // [esp+48h] [ebp-30h]
  unsigned int hash_size; // [esp+4Ch] [ebp-2Ch]
  const unsigned __int8 *v54; // [esp+4Ch] [ebp-2Ch]
  char *v55; // [esp+4Ch] [ebp-2Ch]
  size_t outleft; // [esp+50h] [ebp-28h] BYREF
  char *outptr; // [esp+54h] [ebp-24h] BYREF
  size_t inleft; // [esp+58h] [ebp-20h] BYREF
  char *inptr; // [esp+5Ch] [ebp-1Ch] BYREF

  v4 = msgid;
  if ( !domain_file->decided )
    nl_load_domain(domain_file, domainbinding);
  data = (loaded_domain *)domain_file->data;
  if ( !data )
    return 0;
  hash_size = data->hash_size;
  if ( hash_size > 2 && (hash_tab = (char *)data->hash_tab) != 0 )
  {
    v6 = strlen((const char *)msgid);
    v7 = 0;
    v45 = v6;
    while ( *v4 )
    {
      v7 = *v4 + 16 * v7;
      if ( (v7 & 0xF0000000) != 0 )
        v7 ^= ((v7 & 0xF0000000) >> 24) ^ v7 & 0xF0000000;
      ++v4;
    }
    v8 = v7 % hash_size;
    incr = v7 % (hash_size - 2) + 1;
    must_swap = data->must_swap;
    v48 = hash_size - incr;
    v44 = incr - hash_size;
    domain = data;
    while ( 1 )
    {
      if ( must_swap )
      {
        v10 = (*(_DWORD *)&hash_tab[4 * v8] >> 8) & 0xFF00 | ((*(_DWORD *)&hash_tab[4 * v8] & 0xFF00) << 8) | (*(_DWORD *)&hash_tab[4 * v8] << 24) | HIBYTE(*(_DWORD *)&hash_tab[4 * v8]);
        if ( !v10 )
          return 0;
      }
      else
      {
        v10 = *(_DWORD *)&hash_tab[4 * v8];
        if ( !v10 )
          return 0;
      }
      v11 = v10 - 1;
      orig_tab = domain->orig_tab;
      v13 = must_swap ? (orig_tab[v11].length >> 8) & 0xFF00 | ((orig_tab[v11].length & 0xFF00) << 8) | (orig_tab[v11].length << 24) | HIBYTE(orig_tab[v11].length) : orig_tab[v11].length;
      if ( v13 >= v45 )
      {
        v54 = domain->data;
        v14 = must_swap ? (orig_tab[v11].offset >> 8) & 0xFF00 | ((orig_tab[v11].offset & 0xFF00) << 8) | (orig_tab[v11].offset << 24) | HIBYTE(orig_tab[v11].offset) : orig_tab[v11].offset;
        if ( !strcmp((const char *)msgid, (const char *)&v54[v14]) )
          break;
      }
      v15 = v8 < v48;
      v16 = v8 + incr;
      v8 += v44;
      if ( v15 )
        v8 = v16;
    }
    v18 = v11;
    v19 = domain;
  }
  else
  {
    nstrings = data->nstrings;
    v27 = (loaded_domain *)domain_file->data;
    v28 = 0;
    v29 = nstrings;
    while ( 1 )
    {
      if ( v28 >= v29 )
        return 0;
      v50 = v27->must_swap;
      v54 = v27->data;
      while ( 1 )
      {
        v33 = (v29 + v28) >> 1;
        if ( v50 )
        {
          offset = v27->orig_tab[v33].offset;
          v31 = (offset >> 8) & 0xFF00 | ((offset & 0xFF00) << 8) | (offset << 24) | HIBYTE(offset);
        }
        else
        {
          v31 = v27->orig_tab[v33].offset;
        }
        v42 = v27;
        v32 = strcmp((const char *)msgid, (const char *)&v54[v31]);
        v27 = v42;
        if ( v32 >= 0 )
          break;
        v29 = (v29 + v28) >> 1;
        if ( v33 <= v28 )
          return 0;
      }
      if ( !v32 )
        break;
      v28 = v33 + 1;
    }
    v19 = v42;
    must_swap = v50;
    v18 = v33;
  }
  v20 = &v19->trans_tab[v18];
  if ( must_swap )
  {
    v21 = (unsigned __int8 *)&v54[(v20->offset >> 8) & 0xFF00 | ((v20->offset & 0xFF00) << 8) | (v20->offset << 24) | HIBYTE(v20->offset)];
    v22 = ((v20->length >> 8) & 0xFF00 | ((v20->length & 0xFF00) << 8) | (v20->length << 24) | HIBYTE(v20->length)) + 1;
  }
  else
  {
    v21 = (unsigned __int8 *)&v54[v20->offset];
    v22 = v20->length + 1;
  }
  codeset_cntr = 0;
  if ( domainbinding )
    codeset_cntr = domainbinding->codeset_cntr;
  if ( v19->codeset_cntr != codeset_cntr )
  {
    v41 = v18;
    nl_free_domain_conv(v19);
    nl_init_domain_conv(domain_file, v19, domainbinding);
    v18 = v41;
  }
  if ( v19->conv == (iconv_t)-1 )
    goto converted;
  conv_tab = v19->conv_tab;
  if ( !conv_tab )
  {
    v43 = v18;
    conv_tab = (unsigned __int8 **)calloc(v19->nstrings, 4u);
    v19->conv_tab = conv_tab;
    v18 = v43;
    if ( !conv_tab )
    {
      v19->conv_tab = (unsigned __int8 **)-1;
      goto converted;
    }
  }
  if ( conv_tab == (unsigned __int8 **)-1 )
    goto converted;
  v49 = v18;
  v25 = (size_t *)conv_tab[v18];
  if ( v25 )
    goto LABEL_37;
  v55 = (char *)v21;
  v34 = 0;
  domaina = v19;
  v35 = 0;
  v36 = (char *)(freemem_7306 + 4);
  while ( 1 )
  {
    inleft = v22;
    outptr = v36;
    inptr = v55;
    if ( freemem_size_7307 <= 3 )
      goto resize_freemem;
    outleft = freemem_size_7307 - 4;
    if ( iconv(domaina->conv, &inptr, &inleft, &outptr, &outleft) != -1 )
      break;
    if ( *__errno_location() != 7 )
    {
      v21 = (unsigned __int8 *)v55;
      goto converted;
    }
resize_freemem:
    if ( v35 )
    {
      ++v35;
      freemem_size_7307 = 4080 * v35;
      v37 = (unsigned __int8 *)realloc(v34, 4080 * v35);
    }
    else
    {
      freemem_size_7307 = 4080;
      v35 = 1;
      v37 = (unsigned __int8 *)malloc(0xFF0u);
    }
    if ( !v37 )
    {
      v21 = (unsigned __int8 *)v55;
      freemem_7306 = 0;
      freemem_size_7307 = 0;
      goto converted;
    }
    freemem_7306 = v37;
    v36 = (char *)(v37 + 4);
    v34 = v37;
  }
  v38 = outptr;
  v39 = freemem_7306;
  *(_DWORD *)freemem_7306 = outptr - (char *)freemem_7306 - 4;
  domaina->conv_tab[v49] = v39;
  v40 = freemem_size_7307 + v39 - (unsigned __int8 *)v38;
  freemem_7306 = (unsigned __int8 *)&v38[v40 & 3];
  freemem_size_7307 = v40 & 0xFFFFFFFC;
  v25 = (size_t *)domaina->conv_tab[v49];
LABEL_37:
  v22 = *v25;
  v21 = (unsigned __int8 *)(v25 + 1);
converted:
  *lengthp = v22;
  return v21;
}

//----- (080B0760) --------------------------------------------------------
unsigned __int8 *__usercall plural_lookup@<eax>(
        loaded_l10nfile *domain@<eax>,
        unsigned int n@<edx>,
        const unsigned __int8 *translation@<ecx>,
        size_t translation_len)
{
  expression **data; // esi
  unsigned int v6; // edi
  unsigned __int8 *result; // eax

  data = (expression **)domain->data;
  v6 = plural_eval(data[12], n);
  if ( v6 >= (unsigned int)data[13] )
    v6 = 0;
  result = (unsigned __int8 *)translation;
  while ( v6 )
  {
    --v6;
    result = (unsigned __int8 *)(__rawmemchr(result, 0) + 1);
    if ( result >= &translation[translation_len] )
      return (unsigned __int8 *)translation;
  }
  return result;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080B07D0) --------------------------------------------------------
unsigned __int8 *__cdecl dcigettext__(
        const unsigned __int8 *domainname,
        const unsigned __int8 *msgid1,
        const unsigned __int8 *msgid2,
        int plural,
        unsigned int n,
        int category)
{
  unsigned __int8 *v6; // edi
  char *v7; // edx
  size_t v8; // eax
  void *v9; // esp
  int *v10; // eax
  int v11; // edx
  binding *v12; // ebx
  char *v13; // esi
  int v14; // eax
  unsigned __int8 *dirname; // eax
  size_t v16; // esi
  size_t v17; // eax
  int *v18; // edi
  binding *v19; // ecx
  void *v20; // esp
  unsigned __int8 *v21; // ebx
  const char *v22; // esi
  int v23; // eax
  char *v24; // eax
  const char *v25; // esi
  __uid_t v27; // ebx
  char *v28; // ebx
  char *v29; // eax
  size_t v30; // eax
  void *v31; // esp
  int v32; // eax
  int v33; // eax
  void *v34; // esp
  char **v35; // edx
  char v36; // al
  _BYTE *v37; // ecx
  loaded_l10nfile *domain; // eax
  loaded_l10nfile *v39; // esi
  unsigned __int8 *msg; // eax
  int v41; // ecx
  char *v42; // eax
  loaded_l10nfile *v43; // eax
  int v44; // edi
  binding *v45; // ebx
  char *v46; // esi
  unsigned __int8 *v47; // eax
  int v48; // ecx
  _DWORD *v49; // ebx
  void *v50; // eax
  int v51; // eax
  _DWORD *v52; // eax
  __gid_t v53; // ebx
  char *v54; // [esp+10h] [ebp-68h] BYREF
  char **v55; // [esp+14h] [ebp-64h]
  char **v56; // [esp+18h] [ebp-60h]
  char *v57; // [esp+1Ch] [ebp-5Ch]
  unsigned __int8 *v58; // [esp+20h] [ebp-58h]
  size_t v59; // [esp+24h] [ebp-54h]
  size_t msgid_len; // [esp+28h] [ebp-50h] BYREF
  int saved_errno; // [esp+2Ch] [ebp-4Ch]
  int *v62; // [esp+30h] [ebp-48h]
  char *s1; // [esp+34h] [ebp-44h]
  int v64; // [esp+38h] [ebp-40h]
  loaded_l10nfile *v65; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v66; // [esp+40h] [ebp-38h]
  unsigned __int8 *v67; // [esp+44h] [ebp-34h]
  char *s; // [esp+48h] [ebp-30h]
  binding *domainbinding; // [esp+4Ch] [ebp-2Ch]
  size_t retlen[8]; // [esp+58h] [ebp-20h] BYREF

  v6 = 0;
  s1 = (char *)domainname;
  retlen[1] = __readgsdword(0x14u);
  s = (char *)msgid1;
  v58 = (unsigned __int8 *)msgid2;
  if ( !msgid1 )
    return v6;
  v7 = s1;
  if ( !s1 )
    v7 = nl_current_default_domain__;
  s1 = v7;
  v8 = strlen(s);
  v9 = alloca(v8 + 40);
  msgid_len = v8 + 1;
  memcpy(&msgid_len, s, v8 + 1);
  v54 = s1;
  v55 = (char **)category;
  v10 = (int *)tfind(&v54, &root, transcmp);
  v64 = (int)v10;
  if ( v10 )
  {
    v11 = *v10;
    if ( *(_DWORD *)(*v10 + 8) == nl_msg_cat_cntr )
    {
      if ( plural )
        return plural_lookup(
                 *(loaded_l10nfile **)(v11 + 12),
                 n,
                 *(const unsigned __int8 **)(v11 + 16),
                 *(_DWORD *)(v11 + 20));
      else
        return *(unsigned __int8 **)(v11 + 16);
    }
  }
  v62 = __errno_location();
  saved_errno = *v62;
  if ( !enable_secure )
  {
    v27 = getuid();
    if ( v27 == geteuid() && (v53 = getgid(), v53 == getegid()) )
      enable_secure = -1;
    else
      enable_secure = 1;
  }
  v12 = nl_domain_bindings__;
  if ( nl_domain_bindings__ )
  {
    v13 = s1;
    while ( 1 )
    {
      v14 = strcmp(v13, (const char *)v12->domainname);
      if ( !v14 )
        break;
      if ( v14 >= 0 )
      {
        v12 = v12->next;
        if ( v12 )
          continue;
      }
      goto LABEL_59;
    }
    domainbinding = v12;
    if ( v12 )
    {
      dirname = v12->dirname;
      v66 = dirname;
      if ( *dirname != 47 )
      {
        v16 = 4098;
        v17 = strlen((const char *)dirname);
        v67 = (unsigned __int8 *)v12;
        domainbinding = (binding *)(v17 + 1);
        v18 = v62;
        while ( 1 )
        {
          v19 = domainbinding;
          *v18 = 0;
          v20 = alloca((int)&v19->codeset + v16 + 3);
          if ( getcwd((char *)&v54, v16) )
          {
            v66 = (unsigned __int8 *)&v54;
            v21 = v67;
            v22 = (const char *)*((_DWORD *)v67 + 1);
            v23 = __rawmemchr(&v54, 0);
            v24 = (char *)stpcpy(v23, "/");
            strcpy(v24, v22);
            domainbinding = (binding *)v21;
            goto LABEL_19;
          }
          if ( *v18 != 34 )
            break;
          v16 += (v16 >> 1) + 32;
        }
        *v62 = saved_errno;
        if ( !plural )
          return (unsigned __int8 *)s;
        goto LABEL_21;
      }
    }
    else
    {
      v66 = (unsigned __int8 *)nl_default_dirname__;
    }
  }
  else
  {
LABEL_59:
    domainbinding = 0;
    v66 = (unsigned __int8 *)nl_default_dirname__;
  }
LABEL_19:
  v25 = "LC_XXX";
  switch ( category )
  {
    case 0:
      v25 = "LC_CTYPE";
      break;
    case 1:
      v25 = "LC_NUMERIC";
      break;
    case 2:
      v25 = "LC_TIME";
      break;
    case 3:
      v25 = "LC_COLLATE";
      break;
    case 4:
      v25 = "LC_MONETARY";
      break;
    case 5:
      v25 = "LC_MESSAGES";
      break;
    case 6:
      v25 = "LC_ALL";
      break;
    default:
      break;
  }
  v28 = LANGUAGE;
  if ( !LANGUAGE || !*LANGUAGE )
  {
    v29 = getenv("LANGUAGE");
    v28 = v29;
    if ( !v29 || !*v29 )
      v28 = setlocale(category, 0);
  }
  v59 = strlen(s1);
  v30 = strlen(v25);
  v31 = alloca(v59 + v30 + 20);
  v67 = (unsigned __int8 *)&v54;
  v32 = stpcpy(&v54, v25);
  v33 = stpcpy(v32, "/");
  *(_DWORD *)mempcpy(v33, s1, v59) = 7302446;
  v34 = alloca(strlen(v28) + 16);
  v35 = &v54;
  while ( 1 )
  {
LABEL_32:
    while ( 1 )
    {
      v36 = *v28;
      if ( *v28 != 58 )
        break;
LABEL_49:
      ++v28;
    }
    while ( 1 )
    {
      v37 = v35;
      if ( !v36 )
        break;
      do
      {
        ++v28;
        *v37 = v36;
        v36 = *v28;
        ++v37;
      }
      while ( *v28 != 58 && v36 );
      *v37 = 0;
      if ( enable_secure != 1 )
        goto LABEL_35;
      v55 = v35;
      v42 = strchr((const char *)v35, 47);
      v35 = v55;
      if ( !v42 )
        goto LABEL_35;
      v36 = *v28;
      if ( *v28 == 58 )
        goto LABEL_49;
    }
    *(_BYTE *)v35 = 67;
    *((_BYTE *)v35 + 1) = 0;
LABEL_35:
    if ( *(_BYTE *)v35 == 67 && !*((_BYTE *)v35 + 1) || !strcmp((const char *)v35, "POSIX") )
      break;
    v55 = v35;
    domain = nl_find_domain(v66, (unsigned __int8 *)v35, v67, domainbinding);
    v35 = v55;
    v39 = domain;
    if ( domain )
    {
      msg = nl_find_msg(domain, domainbinding, (const unsigned __int8 *)s, retlen);
      v35 = v55;
      if ( msg )
      {
        v6 = msg;
        *v62 = saved_errno;
        if ( !v64 )
          goto LABEL_55;
LABEL_41:
        *(_DWORD *)(*(_DWORD *)v64 + 8) = nl_msg_cat_cntr;
        v41 = v64;
        *(_DWORD *)(*(_DWORD *)v64 + 12) = v39;
        *(_DWORD *)(*(_DWORD *)v41 + 16) = v6;
        *(_DWORD *)(*(_DWORD *)v41 + 20) = retlen[0];
        goto LABEL_42;
      }
      v43 = v39->successor[0];
      if ( v43 )
      {
        v57 = v28;
        v44 = 0;
        v45 = domainbinding;
        v65 = v39;
        v46 = s;
        v56 = v55;
        while ( 1 )
        {
          v47 = nl_find_msg(v43, v45, (const unsigned __int8 *)v46, retlen);
          if ( v47 )
            break;
          v43 = v65->successor[++v44];
          if ( !v43 )
          {
            v28 = v57;
            v35 = v56;
            goto LABEL_32;
          }
        }
        v48 = v44;
        v6 = v47;
        v39 = v65->successor[v48];
        *v62 = saved_errno;
        if ( v64 )
          goto LABEL_41;
LABEL_55:
        v49 = malloc(msgid_len + v59 + 25);
        if ( v49 )
        {
          v50 = (void *)mempcpy(v49 + 6, s, msgid_len);
          *v49 = v50;
          memcpy(v50, s1, v59 + 1);
          v49[1] = category;
          v51 = nl_msg_cat_cntr;
          v49[3] = v39;
          v49[4] = v6;
          v49[2] = v51;
          v49[5] = retlen[0];
          v52 = tsearch(v49, &root, transcmp);
          if ( !v52 || (_DWORD *)*v52 != v49 )
            free(v49);
        }
LABEL_42:
        if ( plural )
          return plural_lookup(v39, n, v6, retlen[0]);
        return v6;
      }
    }
  }
  *v62 = saved_errno;
  if ( !plural )
    return (unsigned __int8 *)s;
LABEL_21:
  if ( n == 1 )
    return (unsigned __int8 *)s;
  return v58;
}
// 8059008: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8059048: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080B0E10) --------------------------------------------------------
unsigned __int8 *__cdecl dcngettext__(
        const unsigned __int8 *domainname,
        const unsigned __int8 *msgid1,
        const unsigned __int8 *msgid2,
        unsigned int n,
        int category)
{
  return dcigettext__(domainname, msgid1, msgid2, 1, n, category);
}

//----- (080B0E50) --------------------------------------------------------
unsigned __int8 *__cdecl dgettext__(const unsigned __int8 *domainname, const unsigned __int8 *msgid)
{
  return dcgettext__(domainname, msgid, 5);
}

//----- (080B0E80) --------------------------------------------------------
unsigned __int8 *__cdecl dngettext__(
        const unsigned __int8 *domainname,
        const unsigned __int8 *msgid1,
        const unsigned __int8 *msgid2,
        unsigned int n)
{
  return dcngettext__(domainname, msgid1, msgid2, n, 5);
}

//----- (080B0EB0) --------------------------------------------------------
unsigned __int8 *__cdecl nl_find_language(const unsigned __int8 *name)
{
  unsigned __int8 *result; // eax
  unsigned __int8 v2; // dl

  result = (unsigned __int8 *)name;
  v2 = *name;
  if ( *name && v2 != 95 )
  {
    do
    {
      if ( v2 == 64 )
        break;
      if ( v2 == 43 )
        break;
      if ( v2 == 44 )
        break;
      v2 = *++result;
      if ( *result == 95 )
        break;
    }
    while ( v2 );
  }
  return result;
}

//----- (080B0F00) --------------------------------------------------------
int __cdecl nl_explode_name(
        unsigned __int8 *name,
        const unsigned __int8 **language,
        const unsigned __int8 **modifier,
        const unsigned __int8 **territory,
        const unsigned __int8 **codeset,
        const unsigned __int8 **normalized_codeset,
        const unsigned __int8 **special,
        const unsigned __int8 **sponsor,
        const unsigned __int8 **revision)
{
  unsigned __int8 v9; // dl
  unsigned __int8 *v10; // edx
  char v11; // cl
  int result; // eax
  int v13; // edi
  unsigned __int8 v14; // di
  int v15; // ecx
  unsigned __int8 v16; // cl
  unsigned __int8 *v17; // edi
  const unsigned __int8 *v18; // eax
  unsigned __int8 v19; // al
  unsigned __int8 v20; // cl
  unsigned __int8 v21; // cl
  unsigned __int8 v22; // cl
  unsigned __int8 *v23; // eax
  unsigned __int8 v24; // cl
  unsigned __int8 v25; // [esp+1Fh] [ebp-29h]
  unsigned __int8 *ptr; // [esp+28h] [ebp-20h]

  *modifier = 0;
  *territory = 0;
  *codeset = 0;
  *normalized_codeset = 0;
  *special = 0;
  *sponsor = 0;
  *revision = 0;
  *language = name;
  v9 = *name;
  if ( *name == 95 || !v9 || v9 == 64 || v9 == 43 || v9 == 44 )
    goto LABEL_83;
  v10 = name;
  do
    v11 = *++v10;
  while ( *v10 != 95 && v11 && v11 != 64 && v11 != 43 && v11 != 44 );
  v25 = *v10;
  if ( name == v10 )
  {
LABEL_83:
    v13 = 0;
    v23 = (unsigned __int8 *)__rawmemchr(name, 0);
    v24 = *v23;
    v10 = v23;
    result = 0;
    v25 = v24;
  }
  else
  {
    result = 0;
    v13 = 0;
    if ( v11 != 95 )
      goto LABEL_14;
    *v10++ = 0;
    *territory = v10;
    v16 = *v10;
    if ( *v10 == 46 )
    {
LABEL_44:
      *v10++ = 0;
      *codeset = v10;
      v25 = *v10;
      if ( *v10 )
      {
        v17 = v10;
        if ( *v10 != 64 )
        {
          do
            ++v17;
          while ( *v17 != 64 && *v17 );
          if ( v17 == v10 )
          {
            result = 48;
LABEL_24:
            if ( *territory && !**territory )
              result &= ~0x20u;
            if ( *codeset && !**codeset )
              result &= ~0x10u;
            if ( *modifier )
            {
              v15 = result;
              if ( !**modifier )
              {
                LOBYTE(v15) = result & 0x7F;
                return v15;
              }
            }
            return result;
          }
          v18 = nl_normalize_codeset(v10, v17 - v10);
          *normalized_codeset = v18;
          ptr = (unsigned __int8 *)v18;
          if ( strcmp((const char *)*codeset, (const char *)v18) )
          {
            v19 = *v17;
            v10 = v17;
            v13 = 1;
            v25 = v19;
            result = 56;
            goto LABEL_14;
          }
          free(ptr);
          v25 = *v17;
          v10 = v17;
        }
      }
      result = 48;
      v13 = 1;
    }
    else
    {
      while ( v16 && v16 != 64 && v16 != 43 && v16 != 44 && v16 != 95 )
      {
        v16 = *++v10;
        if ( *v10 == 46 )
          goto LABEL_44;
      }
      v25 = v16;
      result = 32;
      v13 = 0;
    }
  }
LABEL_14:
  if ( v25 == 64 )
  {
    *v10 = 0;
    LOBYTE(result) = result | 0xC0;
    *modifier = v10 + 1;
    goto LABEL_24;
  }
  if ( v13 == 1 )
    goto LABEL_24;
  v14 = v25;
  if ( v25 == 43 )
  {
    *v10++ = 0;
    *modifier = v10;
    v14 = *v10;
    if ( *v10 && v14 != 43 && v14 != 44 && v14 != 95 )
    {
      ++v10;
      while ( 1 )
      {
        v20 = *v10;
        if ( !*v10 )
        {
          v25 = 0;
          goto LABEL_64;
        }
        if ( v20 == 43 )
          goto LABEL_64;
        if ( v20 == 44 )
        {
          v25 = 44;
          goto LABEL_64;
        }
        if ( v20 == 95 )
          break;
        ++v10;
      }
      v25 = 95;
LABEL_64:
      v14 = v25;
      LOBYTE(result) = result | 0xC0;
      if ( (unsigned __int8)(v25 - 43) <= 1u )
        goto LABEL_18;
LABEL_22:
      if ( v14 != 95 )
        return result;
      goto LABEL_18;
    }
    LOBYTE(result) = result | 0xC0;
  }
  if ( (unsigned __int8)(v14 - 43) > 1u )
    goto LABEL_22;
LABEL_18:
  if ( v14 == 43 )
  {
    *v10++ = 0;
    *special = v10;
    v21 = *v10;
    if ( *v10 && v21 != 44 )
    {
      do
      {
        if ( v21 == 95 )
          break;
        v21 = *++v10;
        if ( *v10 == 44 )
          break;
      }
      while ( v21 );
    }
    v14 = v21;
    result |= 4u;
    if ( v21 != 44 )
    {
LABEL_20:
      if ( v14 != 95 )
        return result;
LABEL_79:
      *v10 = 0;
      result |= 1u;
      *revision = v10 + 1;
      return result;
    }
  }
  else if ( v14 != 44 )
  {
    goto LABEL_20;
  }
  *v10++ = 0;
  *sponsor = v10;
  v22 = *v10;
  if ( *v10 && v22 != 95 )
  {
    do
      v22 = *++v10;
    while ( *v10 != 95 && v22 );
  }
  result |= 2u;
  if ( v22 == 95 )
    goto LABEL_79;
  return result;
}
// 80B1023: conditional instruction was optimized away because %var_1C.4 is in (==0|==2)
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080B1300) --------------------------------------------------------
loaded_l10nfile *__cdecl nl_find_domain(
        const unsigned __int8 *dirname,
        unsigned __int8 *locale,
        const unsigned __int8 *domainname,
        binding *domainbinding)
{
  unsigned __int8 *v4; // edi
  size_t v5; // eax
  loaded_l10nfile *l10nflist; // eax
  loaded_l10nfile *v7; // ebx
  loaded_l10nfile *v9; // eax
  int v10; // esi
  const unsigned __int8 *v11; // eax
  int v12; // ecx
  const unsigned __int8 *v13; // edx
  int v14; // eax
  size_t v15; // eax
  loaded_l10nfile *v16; // eax
  const unsigned __int8 *v17; // edx
  loaded_l10nfile *filename; // eax
  loaded_l10nfile *v19; // esi
  const unsigned __int8 *v20; // edi
  const unsigned __int8 *v21; // [esp+40h] [ebp-48h]
  const unsigned __int8 *v22; // [esp+40h] [ebp-48h]
  unsigned __int8 *v23; // [esp+44h] [ebp-44h]
  int mask; // [esp+48h] [ebp-40h]
  const unsigned __int8 *revision; // [esp+50h] [ebp-38h] BYREF
  const unsigned __int8 *sponsor; // [esp+54h] [ebp-34h] BYREF
  const unsigned __int8 *special; // [esp+58h] [ebp-30h] BYREF
  const unsigned __int8 *normalized_codeset; // [esp+5Ch] [ebp-2Ch] BYREF
  const unsigned __int8 *codeset; // [esp+60h] [ebp-28h] BYREF
  const unsigned __int8 *territory; // [esp+64h] [ebp-24h] BYREF
  const unsigned __int8 *modifier; // [esp+68h] [ebp-20h] BYREF
  const unsigned __int8 *language; // [esp+6Ch] [ebp-1Ch] BYREF

  v4 = locale;
  v5 = strlen((const char *)dirname);
  l10nflist = nl_make_l10nflist(&nl_loaded_domains, dirname, v5 + 1, 0, locale, 0, 0, 0, 0, 0, 0, 0, domainname, 0);
  v7 = l10nflist;
  if ( !l10nflist )
  {
    v11 = nl_expand_alias(locale);
    v13 = v11;
    if ( !v11 || (v21 = v11, v14 = __strdup(v12, v11), v13 = v21, (v4 = (unsigned __int8 *)v14) != 0) )
    {
      v22 = v13;
      mask = nl_explode_name(
               v4,
               &language,
               &modifier,
               &territory,
               &codeset,
               &normalized_codeset,
               &special,
               &sponsor,
               &revision);
      v15 = strlen((const char *)dirname);
      v16 = nl_make_l10nflist(
              &nl_loaded_domains,
              dirname,
              v15 + 1,
              mask,
              language,
              territory,
              codeset,
              normalized_codeset,
              modifier,
              special,
              sponsor,
              revision,
              domainname,
              1);
      v17 = v22;
      v7 = v16;
      if ( v16 )
      {
        if ( !v16->decided )
        {
          nl_load_domain(v16, domainbinding);
          v17 = v22;
        }
        if ( !v7->data )
        {
          filename = v7->successor[0];
          if ( filename )
          {
            v19 = v7;
            v23 = v4;
            v20 = v17;
            do
            {
              if ( !filename->decided )
                nl_load_domain(filename, domainbinding);
              if ( v19->successor[0]->data )
                break;
              filename = (loaded_l10nfile *)v19[1].filename;
              v19 = (loaded_l10nfile *)((char *)v19 + 4);
            }
            while ( filename );
            v17 = v20;
            v4 = v23;
          }
        }
        if ( v17 )
          free(v4);
        if ( (mask & 8) != 0 )
          free((void *)normalized_codeset);
      }
    }
    return v7;
  }
  if ( l10nflist->decided )
  {
    if ( l10nflist->data )
      return v7;
  }
  else
  {
    nl_load_domain(l10nflist, domainbinding);
    if ( v7->data )
      return v7;
  }
  v9 = v7->successor[0];
  if ( !v9 )
    return v7;
  v10 = 0;
  do
  {
    if ( !v9->decided )
      nl_load_domain(v9, domainbinding);
    if ( v7->successor[v10]->data )
      break;
    v9 = v7->successor[++v10];
  }
  while ( v9 );
  if ( v10 < 0 )
    return 0;
  return v7;
}
// 80B142C: variable 'v12' is possibly undefined
// 8059A88: using guessed type int __thiscall __strdup(_DWORD, _DWORD);

//----- (080B15A0) --------------------------------------------------------
unsigned __int8 *__cdecl gettext__(const unsigned __int8 *msgid)
{
  return dcgettext__(0, msgid, 5);
}

//----- (080B15D0) --------------------------------------------------------
unsigned __int8 *__cdecl bind_textdomain_codeset(const unsigned __int8 *domainname, const unsigned __int8 *codeset)
{
  return bind_textdomain_codeset__(domainname, codeset);
}

//----- (080B15E0) --------------------------------------------------------
unsigned __int8 *__cdecl bindtextdomain(const unsigned __int8 *domainname, const unsigned __int8 *dirname)
{
  return bindtextdomain__(domainname, dirname);
}

//----- (080B15F0) --------------------------------------------------------
unsigned __int8 *__cdecl textdomain(const unsigned __int8 *domainname)
{
  return textdomain__(domainname);
}

//----- (080B1600) --------------------------------------------------------
unsigned __int8 *__cdecl dcngettext(
        const unsigned __int8 *domainname,
        const unsigned __int8 *msgid1,
        const unsigned __int8 *msgid2,
        unsigned int n,
        int category)
{
  return dcngettext__(domainname, msgid1, msgid2, n, category);
}

//----- (080B1610) --------------------------------------------------------
unsigned __int8 *__cdecl dngettext(
        const unsigned __int8 *domainname,
        const unsigned __int8 *msgid1,
        const unsigned __int8 *msgid2,
        unsigned int n)
{
  return dngettext__(domainname, msgid1, msgid2, n);
}

//----- (080B1620) --------------------------------------------------------
unsigned __int8 *__cdecl ngettext(const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n)
{
  return ngettext__(msgid1, msgid2, n);
}

//----- (080B1630) --------------------------------------------------------
unsigned __int8 *__cdecl dcgettext(const unsigned __int8 *domainname, const unsigned __int8 *msgid, int category)
{
  return dcgettext__(domainname, msgid, category);
}

//----- (080B1640) --------------------------------------------------------
unsigned __int8 *__cdecl dgettext(const unsigned __int8 *domainname, const unsigned __int8 *msgid)
{
  return dgettext__(domainname, msgid);
}

//----- (080B1650) --------------------------------------------------------
unsigned __int8 *__cdecl gettext(const unsigned __int8 *msgid)
{
  return gettext__(msgid);
}

//----- (080B1660) --------------------------------------------------------
const unsigned __int8 *__cdecl nl_normalize_codeset(const unsigned __int8 *codeset, size_t name_len)
{
  size_t v2; // ecx
  const unsigned __int16 **v3; // eax
  int v4; // ebx
  int v5; // ecx
  const unsigned __int16 *v6; // edi
  size_t i; // eax
  unsigned __int16 v8; // dx
  _DWORD *v9; // eax
  unsigned __int8 *v10; // edx
  size_t v11; // ebx
  unsigned __int8 *v12; // esi
  const unsigned __int16 **v13; // edi
  unsigned __int8 v14; // al
  const unsigned __int8 *v16; // [esp+18h] [ebp-20h]

  v2 = 4;
  if ( name_len )
  {
    v3 = __ctype_b_loc();
    v4 = 1;
    v5 = 0;
    v6 = *v3;
    for ( i = 0; i < name_len; ++i )
    {
      v8 = v6[codeset[i]];
      if ( (v8 & 8) != 0 )
      {
        ++v5;
        if ( (v8 & 0x400) != 0 )
          v4 = 0;
      }
    }
    if ( !v4 )
    {
      v2 = v5 + 1;
      goto LABEL_9;
    }
    v2 = v5 + 4;
  }
  v4 = 1;
LABEL_9:
  v9 = malloc(v2);
  v16 = (const unsigned __int8 *)v9;
  if ( v9 )
  {
    v10 = (unsigned __int8 *)v9;
    if ( v4 )
    {
      *v9 = 7304041;
      v10 = (unsigned __int8 *)v9 + 3;
    }
    if ( name_len )
    {
      v11 = 0;
      v12 = v10;
      v13 = __ctype_b_loc();
      do
      {
        while ( 1 )
        {
          v14 = codeset[v11];
          if ( ((*v13)[v14] & 0x400) == 0 )
            break;
          ++v11;
          *v12++ = c_tolower(v14);
          if ( name_len <= v11 )
            goto LABEL_19;
        }
        if ( (unsigned __int8)(v14 - 48) <= 9u )
          *v12++ = v14;
        ++v11;
      }
      while ( name_len > v11 );
LABEL_19:
      v10 = v12;
    }
    *v10 = 0;
  }
  return v16;
}

//----- (080B1770) --------------------------------------------------------
loaded_l10nfile *__cdecl nl_make_l10nflist(
        loaded_l10nfile **l10nfile_list,
        const unsigned __int8 *dirlist,
        size_t dirlist_len,
        int mask,
        const unsigned __int8 *language,
        const unsigned __int8 *territory,
        const unsigned __int8 *codeset,
        const unsigned __int8 *normalized_codeset,
        const unsigned __int8 *modifier,
        const unsigned __int8 *special,
        const unsigned __int8 *sponsor,
        const unsigned __int8 *revision,
        const unsigned __int8 *filename,
        int do_allocate)
{
  int v14; // edi
  size_t v15; // esi
  size_t v16; // ebx
  size_t v17; // edx
  size_t v18; // ebx
  size_t v19; // eax
  char *v20; // eax
  loaded_l10nfile *v21; // edx
  char *v22; // ebx
  _BYTE *v23; // eax
  loaded_l10nfile *v24; // edi
  loaded_l10nfile *v25; // esi
  int v26; // eax
  loaded_l10nfile *v27; // esi
  _BYTE *v29; // ecx
  size_t v30; // eax
  size_t v31; // eax
  int v32; // edx
  loaded_l10nfile *v33; // eax
  size_t v34; // ecx
  _BOOL4 v35; // eax
  int v36; // esi
  size_t v37; // eax
  int v38; // ecx
  loaded_l10nfile **v39; // edi
  int v40; // esi
  const unsigned __int8 *v41; // ebx
  size_t v42; // eax
  size_t v43; // [esp+48h] [ebp-40h]
  loaded_l10nfile *v44; // [esp+48h] [ebp-40h]
  size_t v45; // [esp+5Ch] [ebp-2Ch]
  size_t v46; // [esp+60h] [ebp-28h]
  loaded_l10nfile *v47; // [esp+60h] [ebp-28h]
  size_t v48; // [esp+64h] [ebp-24h]
  int v49; // [esp+64h] [ebp-24h]
  size_t v50; // [esp+68h] [ebp-20h]
  char *v51; // [esp+68h] [ebp-20h]
  const unsigned __int8 *v52; // [esp+68h] [ebp-20h]
  int v53; // [esp+6Ch] [ebp-1Ch]
  _BYTE *v54; // [esp+6Ch] [ebp-1Ch]
  int v55; // [esp+6Ch] [ebp-1Ch]

  v14 = mask;
  v45 = strlen((const char *)language);
  if ( (mask & 0x20) != 0 )
    v46 = strlen((const char *)territory) + 1;
  else
    v46 = 0;
  if ( (mask & 0x10) != 0 )
    v48 = strlen((const char *)codeset) + 1;
  else
    v48 = 0;
  if ( (mask & 8) != 0 )
    v50 = strlen((const char *)normalized_codeset) + 1;
  else
    v50 = 0;
  v15 = 0;
  if ( (mask & 0xC0) != 0 )
    v15 = strlen((const char *)modifier) + 1;
  if ( (mask & 4) != 0 )
    v53 = strlen((const char *)special) + 1;
  else
    v53 = 0;
  v16 = 0;
  if ( (mask & 3) != 0 )
  {
    v17 = 1;
    if ( (mask & 2) != 0 )
    {
      v18 = 0;
      v17 = strlen((const char *)sponsor) + 2;
      if ( (mask & 1) == 0 )
        goto LABEL_14;
    }
    else
    {
      v18 = 0;
      if ( (mask & 1) == 0 )
      {
LABEL_14:
        v16 = v17 + v18;
        goto LABEL_15;
      }
    }
    v43 = v17;
    v30 = strlen((const char *)revision);
    v17 = v43;
    v18 = v30 + 1;
    goto LABEL_14;
  }
LABEL_15:
  v19 = strlen((const char *)filename);
  v20 = (char *)malloc(v19 + v16 + v53 + v15 + v50 + v48 + v46 + dirlist_len + v45 + 2);
  v21 = 0;
  v22 = v20;
  if ( !v20 )
    return v21;
  memcpy(v20, dirlist, dirlist_len);
  __argz_stringify(v22, dirlist_len, 58);
  v22[dirlist_len - 1] = 47;
  v51 = &v22[dirlist_len];
  v23 = (_BYTE *)stpcpy(&v22[dirlist_len], language);
  v54 = v23;
  if ( (mask & 0x20) != 0 )
  {
    *v23 = 95;
    v54 = (_BYTE *)stpcpy(v23 + 1, territory);
  }
  if ( (mask & 0x10) != 0 )
  {
    *v54 = 46;
    v54 = (_BYTE *)stpcpy(v54 + 1, codeset);
    if ( (mask & 8) == 0 )
      goto LABEL_20;
  }
  else if ( (mask & 8) == 0 )
  {
    goto LABEL_20;
  }
  *v54 = 46;
  v54 = (_BYTE *)stpcpy(v54 + 1, normalized_codeset);
LABEL_20:
  if ( (mask & 0xC0) != 0 )
  {
    *v54 = (mask & 0x40) == 0 ? 64 : 43;
    v54 = (_BYTE *)stpcpy(v54 + 1, modifier);
    if ( (mask & 4) == 0 )
      goto LABEL_22;
LABEL_43:
    *v54 = 43;
    v54 = (_BYTE *)stpcpy(v54 + 1, special);
    goto LABEL_22;
  }
  if ( (mask & 4) != 0 )
    goto LABEL_43;
LABEL_22:
  if ( (mask & 3) != 0 )
  {
    *v54 = 44;
    v29 = ++v54;
    if ( (mask & 2) != 0 )
      v54 = (_BYTE *)stpcpy(v29, sponsor);
    if ( (mask & 1) != 0 )
    {
      *v54 = 95;
      v54 = (_BYTE *)stpcpy(v54 + 1, revision);
    }
  }
  *v54 = 47;
  strcpy(v54 + 1, (const char *)filename);
  if ( !*l10nfile_list )
  {
    v27 = 0;
    goto LABEL_31;
  }
  v24 = 0;
  v25 = *l10nfile_list;
  while ( !v25->filename )
  {
LABEL_29:
    v25 = v25->next;
    if ( !v25 )
    {
      v27 = v24;
      v14 = mask;
      goto LABEL_31;
    }
  }
  v26 = strcmp((const char *)v25->filename, v22);
  if ( !v26 )
  {
    free(v22);
    return v25;
  }
  if ( v26 >= 0 )
  {
    v24 = v25;
    goto LABEL_29;
  }
  v27 = v24;
  v14 = mask;
LABEL_31:
  if ( do_allocate )
  {
    v31 = __argz_count((const char *)dirlist, dirlist_len);
    v32 = ((int)(v14 & 0xFFFFAAAA) >> 1) + (v14 & 0x5555);
    v33 = (loaded_l10nfile *)malloc(
                               4
                             * (v31 << (((unsigned __int16)(((v32 & 0x3333)
                                                           + ((int)(v32 & 0xFFFFCCCC) >> 2)
                                                           + (((v32 & 0x3333) + ((int)(v32 & 0xFFFFCCCC) >> 2)) >> 4)) & 0xF0F) >> 8)
                                      + (((v32 & 0x33)
                                        + ((int)(v32 & 0xFFFFCCCC) >> 2)
                                        + (((v32 & 0x3333) + ((int)(v32 & 0xFFFFCCCC) >> 2)) >> 4)) & 0xF)))
                             + 28);
    v21 = v33;
    v47 = v33;
    if ( v33 )
    {
      v33->filename = (const unsigned __int8 *)v22;
      v33->langdirname = (const unsigned __int8 *)v51;
      v33->langdirnamelen = v54 - v51;
      v44 = v33;
      v34 = __argz_count((const char *)dirlist, dirlist_len);
      v35 = 1;
      if ( v34 == 1 )
        v35 = (v14 & 0x18) == 24;
      v47->decided = v35;
      v47->data = 0;
      if ( v27 )
      {
        v47->next = v27->next;
        v27->next = v47;
      }
      else
      {
        v47->next = *l10nfile_list;
        *l10nfile_list = v47;
      }
      v36 = v14 - 1;
      v37 = __argz_count((const char *)dirlist, dirlist_len);
      v21 = v44;
      if ( v37 != 1 )
        v36 = v14;
      v38 = 0;
      v49 = ~v14;
      if ( v36 >= 0 )
      {
        v52 = &dirlist[dirlist_len];
        do
        {
          if ( (v36 & v49) == 0 && ((v36 & 0x47) == 0 || (v36 & 0x98) == 0) )
          {
            v39 = &v47->successor[v38];
            if ( (v36 & 0x18) != 24 )
            {
              v55 = v36;
              v40 = v38;
              if ( dirlist_len )
              {
                v41 = dirlist;
                do
                {
                  if ( !v41 )
                    break;
                  ++v40;
                  v42 = strlen((const char *)v41);
                  *v39++ = nl_make_l10nflist(
                             l10nfile_list,
                             v41,
                             v42 + 1,
                             v55,
                             language,
                             territory,
                             codeset,
                             normalized_codeset,
                             modifier,
                             special,
                             sponsor,
                             revision,
                             filename,
                             1);
                  if ( v41 >= v52 )
                    break;
                  v41 = (const unsigned __int8 *)(__rawmemchr(v41, 0) + 1);
                }
                while ( v52 > v41 );
              }
              v38 = v40;
              v36 = v55;
            }
          }
          --v36;
        }
        while ( v36 >= 0 );
        v21 = v44;
      }
      v47->successor[v38] = 0;
    }
  }
  else
  {
    free(v22);
    return 0;
  }
  return v21;
}
// 80B1D47: conditional instruction was optimized away because ebx.4!=0
// 8059048: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080B1DC0) --------------------------------------------------------
unsigned __int8 *__cdecl language_to_name(int language)
{
  return languages[language].name;
}

//----- (080B1DD0) --------------------------------------------------------
int __cdecl name_to_language(const unsigned __int8 *name)
{
  unsigned __int8 *v1; // eax
  int v2; // ebx

  v1 = languages[0].name;
  if ( !languages[0].name )
    return 1;
  v2 = 0;
  while ( c_strcasecmp((const char *)v1, (const char *)name) )
  {
    v1 = languages[++v2].name;
    if ( !v1 )
      return 1;
  }
  return v2;
}

//----- (080B1E20) --------------------------------------------------------
int __cdecl iso639_to_language(unsigned __int8 *iso639)
{
  unsigned __int8 *v1; // eax
  char *v2; // esi
  char *v3; // eax
  char *v4; // eax
  char *v5; // edi
  int v6; // ebx
  size_t v7; // eax
  signed int v8; // edi
  const char *v9; // ecx
  signed int v10; // eax
  char v11; // dl
  unsigned __int8 *name; // [esp+1Ch] [ebp-1Ch]

  v1 = stracpy(iso639);
  v2 = (char *)v1;
  if ( !v1 )
    return 1;
  v3 = strchr((const char *)v1, 46);
  if ( v3 )
    *v3 = 0;
  v4 = strchr(v2, 95);
  v5 = v4;
  if ( v4 )
    *v4 = 45;
  else
    v5 = strchr(v2, 45);
  name = languages[0].name;
  if ( languages[0].name )
  {
    v6 = 0;
    while ( strcmp((const char *)languages[v6].iso639, v2) )
    {
      if ( !languages[++v6].name )
        goto LABEL_10;
    }
    goto LABEL_28;
  }
LABEL_10:
  if ( v5 )
  {
    *v5 = 0;
    if ( languages[0].name )
    {
      v6 = 0;
      while ( strcmp((const char *)languages[v6].iso639, v2) )
      {
        if ( !languages[++v6].name )
        {
          v7 = strlen(v2);
          goto LABEL_16;
        }
      }
      goto LABEL_28;
    }
    goto LABEL_26;
  }
  v7 = strlen(v2);
  if ( !name )
  {
LABEL_26:
    mem_free(v2);
    return 1;
  }
LABEL_16:
  v8 = v7;
  v6 = 0;
  while ( 1 )
  {
    v9 = (const char *)languages[v6].iso639;
    if ( !*v9 || *v9 == 45 )
    {
      v10 = 0;
    }
    else
    {
      v10 = 0;
      do
        v11 = v9[++v10];
      while ( v11 && v11 != 45 );
    }
    if ( v10 > v8 )
      v10 = v8;
    if ( !strncmp(v9, v2, v10) )
      break;
    if ( !languages[++v6].name )
      goto LABEL_26;
  }
LABEL_28:
  mem_free(v2);
  return v6;
}

//----- (080B1FD0) --------------------------------------------------------
int get_system_language_index()
{
  unsigned __int8 *v0; // eax

  v0 = (unsigned __int8 *)getenv("LANGUAGE");
  if ( v0 )
    return iso639_to_language(v0);
  v0 = (unsigned __int8 *)getenv("LC_ALL");
  if ( v0 )
    return iso639_to_language(v0);
  v0 = (unsigned __int8 *)getenv("LC_MESSAGES");
  if ( v0 )
    return iso639_to_language(v0);
  v0 = (unsigned __int8 *)getenv("LANG");
  if ( v0 )
    return iso639_to_language(v0);
  else
    return 1;
}

//----- (080B2030) --------------------------------------------------------
unsigned __int8 *__cdecl language_to_iso639(int language)
{
  int v1; // eax

  v1 = language;
  if ( language )
    return languages[v1].iso639;
  v1 = system_language;
  if ( system_language )
    return languages[v1].iso639;
  else
    return languages[get_system_language_index()].iso639;
}

//----- (080B2060) --------------------------------------------------------
void __cdecl set_language(int language)
{
  int v1; // ebx
  unsigned __int8 *v2; // eax
  char *v3; // eax

  v1 = language;
  if ( !system_language )
    system_language = get_system_language_index();
  if ( language != current_language )
  {
    current_language = language;
    if ( !language )
      v1 = system_language;
    if ( !LANGUAGE )
      LANGUAGE = (char *)malloc(0x100u);
    v2 = language_to_iso639(v1);
    strcpy(LANGUAGE, (const char *)v2);
    v3 = strchr(LANGUAGE, 45);
    if ( v3 )
      *v3 = 95;
    ++nl_msg_cat_cntr;
  }
}

//----- (080B2100) --------------------------------------------------------
string *__usercall add_bytes_to_string___1@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (080B2250) --------------------------------------------------------
void __cdecl nl_free_domain_conv(loaded_domain *domain)
{
  unsigned __int8 **conv_tab; // eax
  iconv_t conv; // eax

  conv_tab = domain->conv_tab;
  if ( (unsigned int)conv_tab - 1 > 0xFFFFFFFD )
  {
    conv = domain->conv;
    if ( conv == (iconv_t)-1 )
      return;
    goto LABEL_3;
  }
  free(conv_tab);
  conv = domain->conv;
  if ( conv != (iconv_t)-1 )
LABEL_3:
    iconv_close(conv);
}

//----- (080B22A0) --------------------------------------------------------
const unsigned __int8 *__cdecl nl_init_domain_conv(
        loaded_l10nfile *domain_file,
        loaded_domain *domain,
        binding *domainbinding)
{
  int codeset_cntr; // eax
  unsigned __int8 *msg; // eax
  char *v5; // eax
  char v6; // dl
  char *v7; // ecx
  int v8; // ebx
  char v9; // dl
  size_t v10; // eax
  const char *codeset; // eax
  char *v13; // [esp+14h] [ebp-34h]
  unsigned __int8 *charset; // [esp+18h] [ebp-30h]
  unsigned __int8 *nullentry; // [esp+1Ch] [ebp-2Ch]
  int nullentrylen[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  codeset_cntr = 0;
  if ( domainbinding )
    codeset_cntr = domainbinding->codeset_cntr;
  domain->codeset_cntr = codeset_cntr;
  domain->conv = (iconv_t)-1;
  domain->conv_tab = 0;
  msg = nl_find_msg(domain_file, domainbinding, (const unsigned __int8 *)&delete, (size_t *)nullentrylen);
  nullentry = msg;
  if ( msg )
  {
    v5 = strstr((const char *)msg, "charset=");
    if ( v5 )
    {
      v6 = v5[8];
      v7 = v5 + 8;
      if ( !v6 || v6 == 32 || v6 == 9 || v6 == 10 )
      {
        v10 = 1;
        v8 = 0;
      }
      else
      {
        v8 = 0;
        do
          v9 = v5[++v8 + 8];
        while ( v9 && v9 != 32 && v9 != 9 && v9 != 10 );
        v10 = v8 + 1;
      }
      v13 = v7;
      charset = (unsigned __int8 *)mem_alloc(v10);
      *(_BYTE *)mempcpy(charset, v13, v8) = 0;
      if ( !domainbinding || (codeset = (const char *)domainbinding->codeset) == 0 )
      {
        codeset = getenv("OUTPUT_CHARSET");
        if ( !codeset || !*codeset )
          codeset = elinks_locale_charset();
      }
      domain->conv = iconv_open(codeset, (const char *)charset);
      mem_free(charset);
    }
  }
  return nullentry;
}
// 8059008: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 80B22A0: using guessed type size_t nullentrylen[7];

//----- (080B23F0) --------------------------------------------------------
void __cdecl nl_load_domain(loaded_l10nfile *domain_file, binding *domainbinding)
{
  char *v2; // eax
  unsigned int v3; // eax
  int v4; // esi
  size_t st_size; // edi
  int v6; // eax
  unsigned __int8 *v7; // edx
  int v8; // ecx
  loaded_domain *v9; // eax
  loaded_domain *v10; // esi
  bool v11; // zf
  int v12; // eax
  const unsigned __int8 *inited; // eax
  const char *v14; // edi
  char *v15; // eax
  unsigned __int8 *v16; // edi
  const unsigned __int16 *v17; // ecx
  unsigned __int8 v18; // al
  int v19; // ecx
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // edi
  ssize_t v22; // eax
  unsigned __int8 *v23; // edx
  int v24; // [esp+28h] [ebp-A0h]
  unsigned __int8 *addr; // [esp+2Ch] [ebp-9Ch]
  unsigned __int8 *addrb; // [esp+2Ch] [ebp-9Ch]
  unsigned __int8 *addra; // [esp+2Ch] [ebp-9Ch]
  unsigned __int8 *addrc; // [esp+2Ch] [ebp-9Ch]
  size_t v29; // [esp+30h] [ebp-98h]
  _BOOL4 read_ptr; // [esp+34h] [ebp-94h]
  unsigned __int8 *read_ptra; // [esp+34h] [ebp-94h]
  unsigned __int8 *read_ptrb; // [esp+34h] [ebp-94h]
  size_t to_read; // [esp+38h] [ebp-90h]
  int length; // [esp+3Ch] [ebp-8Ch]
  char *lengtha; // [esp+3Ch] [ebp-8Ch]
  stat st; // [esp+48h] [ebp-80h] BYREF
  parse_args args; // [esp+A8h] [ebp-20h] BYREF

  domain_file->decided = 1;
  domain_file->data = 0;
  if ( !init_string((string *)&args)
    || (addr = program_0.path, (v2 = strrchr((const char *)program_0.path, 47)) == 0)
    || (v3 = v2 - (char *)addr + 1, v3 <= 3)
    || memcmp(&addr[v3 - 4], "src", 3u)
    || !add_bytes_to_string___1((string *)&args, addr, v3)
    || !add_to_string((string *)&args, "../po/")
    || !add_bytes_to_string___1((string *)&args, domain_file->langdirname, domain_file->langdirnamelen)
    || !add_to_string((string *)&args, ".gmo") )
  {
    done_string((string *)&args);
LABEL_5:
    if ( !domain_file->filename )
      return;
    v4 = open64(domain_file->filename, 0);
    if ( v4 == -1 )
      return;
    goto source_success;
  }
  v4 = open64(args.cp, 0);
  done_string((string *)&args);
  if ( v4 == -1 )
    goto LABEL_5;
source_success:
  if ( __fxstat64(3, v4, &st) || (st_size = st.st_size, HIDWORD(st.st_size)) || LODWORD(st.st_size) <= 0x1B )
  {
LABEL_9:
    close(v4);
    return;
  }
  v6 = mmap64(0, st.st_size, 1, 2, v4, 0, 0);
  if ( v6 == -1 )
  {
    v20 = (unsigned __int8 *)malloc(st_size);
    if ( !v20 )
      return;
    to_read = st_size;
    v29 = st_size;
    v21 = v20;
    for ( read_ptrb = v20; ; read_ptrb += v22 )
    {
      while ( 1 )
      {
        v22 = read(v4, read_ptrb, to_read);
        if ( v22 != -1 )
          break;
        if ( *__errno_location() != 4 )
          goto LABEL_9;
      }
      if ( v22 <= 0 )
        goto LABEL_9;
      to_read -= v22;
      if ( !to_read )
        break;
    }
    v23 = v21;
    st_size = v29;
    addrc = v23;
    close(v4);
    v8 = 0;
    v7 = addrc;
  }
  else
  {
    addrb = (unsigned __int8 *)v6;
    close(v4);
    v7 = addrb;
    v8 = 1;
  }
  if ( *(_DWORD *)v7 == -569244523 || *(_DWORD *)v7 == -1794895138 )
  {
    addra = v7;
    v24 = v8;
    v9 = (loaded_domain *)malloc(0x38u);
    v10 = v9;
    if ( v9 )
    {
      domain_file->data = v9;
      v9->data = addra;
      v9->use_mmap = v24;
      v9->mmap_size = st_size;
      v11 = *(_DWORD *)addra == -1794895138;
      read_ptr = *(_DWORD *)addra != -1794895138;
      v9->must_swap = read_ptr;
      if ( v11 )
        length = *((_DWORD *)addra + 1);
      else
        length = (*((_DWORD *)addra + 1) >> 8) & 0xFF00 | ((*((_DWORD *)addra + 1) & 0xFF00) << 8) | (*((_DWORD *)addra + 1) << 24) | HIBYTE(*((_DWORD *)addra + 1));
      if ( length )
      {
        if ( v24 )
          munmap(addra, st_size);
        else
          free(addra);
        free(v10);
        domain_file->data = 0;
      }
      else
      {
        if ( read_ptr )
        {
          v9->nstrings = (*((_DWORD *)addra + 2) >> 8) & 0xFF00 | ((*((_DWORD *)addra + 2) & 0xFF00) << 8) | (*((_DWORD *)addra + 2) << 24) | HIBYTE(*((_DWORD *)addra + 2));
          v9->orig_tab = (string_desc *)&addra[(*((_DWORD *)addra + 3) >> 8) & 0xFF00 | ((*((_DWORD *)addra + 3) & 0xFF00) << 8) | (*((_DWORD *)addra + 3) << 24) | HIBYTE(*((_DWORD *)addra + 3))];
          v9->trans_tab = (string_desc *)&addra[(*((_DWORD *)addra + 4) >> 8) & 0xFF00 | ((*((_DWORD *)addra + 4) & 0xFF00) << 8) | (*((_DWORD *)addra + 4) << 24) | HIBYTE(*((_DWORD *)addra + 4))];
          v9->hash_size = (*((_DWORD *)addra + 5) >> 8) & 0xFF00 | ((*((_DWORD *)addra + 5) & 0xFF00) << 8) | (*((_DWORD *)addra + 5) << 24) | HIBYTE(*((_DWORD *)addra + 5));
          v12 = (*((_DWORD *)addra + 6) >> 8) & 0xFF00 | ((*((_DWORD *)addra + 6) & 0xFF00) << 8) | (*((_DWORD *)addra + 6) << 24) | HIBYTE(*((_DWORD *)addra + 6));
        }
        else
        {
          v9->nstrings = *((_DWORD *)addra + 2);
          v9->orig_tab = (string_desc *)&addra[*((_DWORD *)addra + 3)];
          v9->trans_tab = (string_desc *)&addra[*((_DWORD *)addra + 4)];
          v9->hash_size = *((_DWORD *)addra + 5);
          v12 = *((_DWORD *)addra + 6);
        }
        v10->hash_tab = (nls_uint32 *)&addra[v12];
        inited = nl_init_domain_conv(domain_file, v10, domainbinding);
        v14 = (const char *)inited;
        if ( inited )
        {
          lengtha = strstr((const char *)inited, "plural=");
          v15 = strstr(v14, "nplurals=");
          if ( v15 )
          {
            if ( lengtha )
            {
              v16 = (unsigned __int8 *)(v15 + 9);
              v17 = *__ctype_b_loc();
              while ( 1 )
              {
                v18 = *v16;
                if ( (v17[*v16] & 0x2000) == 0 )
                  break;
                ++v16;
              }
              if ( (unsigned __int8)(v18 - 48) > 9u )
              {
                v10->nplurals = 0;
              }
              else
              {
                v19 = 0;
                read_ptra = v16;
                do
                {
                  ++read_ptra;
                  v19 = v18 + 10 * v19 - 48;
                  v18 = *read_ptra;
                }
                while ( (unsigned __int8)(*read_ptra - 48) <= 9u );
                v10->nplurals = v19;
                if ( v16 != read_ptra )
                {
                  args.cp = (const unsigned __int8 *)(lengtha + 7);
                  if ( !gettext__parse(&args) )
                  {
                    v10->plural = args.res;
                    return;
                  }
                }
              }
            }
          }
        }
        if ( !plone.val.num )
        {
          plvar.nargs = 0;
          plvar.operation = var;
          plone.nargs = 0;
          plone.operation = num;
          plone.val.num = 1;
          germanic_plural.nargs = 2;
          germanic_plural.operation = not_equal;
          germanic_plural.val.num = (unsigned int)&plvar;
          germanic_plural.val.args[1] = &plone;
        }
        v10->plural = &germanic_plural;
        v10->nplurals = 2;
      }
    }
  }
  else if ( v8 )
  {
    munmap(v7, st_size);
  }
  else
  {
    free(v7);
  }
}
// 8059818: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);
// 80598F8: using guessed type int __cdecl open64(_DWORD, _DWORD);
// 80599B8: using guessed type int __cdecl mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080B2A10) --------------------------------------------------------
char *elinks_locale_charset()
{
  char *v0; // eax
  char *v1; // ebx
  const char *v2; // esi
  char v3; // di
  const char *v4; // ebx
  FILE *v6; // edi
  int v7; // eax
  size_t v8; // eax
  char *v9; // eax
  int v10; // eax
  size_t v11; // [esp+10h] [ebp-98h]
  size_t v12; // [esp+14h] [ebp-94h]
  char *ptr; // [esp+18h] [ebp-90h]
  int v14; // [esp+1Ch] [ebp-8Ch]
  char src[51]; // [esp+26h] [ebp-82h] BYREF
  char s[51]; // [esp+59h] [ebp-4Fh] BYREF
  unsigned int v17; // [esp+8Ch] [ebp-1Ch]

  v17 = __readgsdword(0x14u);
  v0 = nl_langinfo(14);
  v1 = charset_aliases;
  v2 = v0;
  if ( !v0 )
    v2 = &delete;
  if ( !charset_aliases )
  {
    ptr = (char *)malloc(0x17u);
    if ( ptr )
    {
      strcpy(ptr, "/usr/lib/charset.alias");
      v6 = (FILE *)fopen64(ptr, "rb");
      if ( !v6 )
        goto LABEL_35;
      v14 = 0;
LABEL_15:
      while ( 1 )
      {
        v7 = _IO_getc(v6);
        if ( v7 == -1 )
          break;
        while ( v7 != 32 && v7 != 10 && v7 != 9 )
        {
          if ( v7 == 35 )
          {
            while ( 1 )
            {
              v10 = _IO_getc(v6);
              if ( v10 == 10 )
                goto LABEL_15;
              if ( v10 == -1 )
                goto LABEL_25;
            }
          }
          ungetc(v7, v6);
          if ( __isoc99_fscanf(v6, "%50s %50s", s, src) <= 1 )
            goto LABEL_25;
          v12 = strlen(s);
          v8 = strlen(src);
          v11 = v8;
          if ( v14 )
          {
            v14 += v8 + v12 + 2;
            v9 = (char *)realloc(v1, v14 + 1);
          }
          else
          {
            v14 = v8 + v12 + 2;
            v9 = (char *)malloc(v8 + v12 + 3);
          }
          v1 = v9;
          if ( !v9 )
          {
            fclose(v6);
            goto LABEL_35;
          }
          strcpy(&v9[v14 - v11 - v12 - 2], s);
          strcpy(&v1[v14 - v11 - 1], src);
          v7 = _IO_getc(v6);
          if ( v7 == -1 )
            goto LABEL_25;
        }
      }
LABEL_25:
      fclose(v6);
      if ( v14 )
        v1[v14] = 0;
      else
LABEL_35:
        v1 = (char *)&delete;
      free(ptr);
    }
    else
    {
      v1 = (char *)&delete;
    }
    charset_aliases = v1;
  }
  v3 = *v1;
  if ( *v1 )
  {
    while ( strcmp(v2, v1) && (v3 != 42 || v1[1]) )
    {
      v4 = &v1[strlen(v1) + 1];
      v1 = (char *)&v4[strlen(v4) + 1];
      v3 = *v1;
      if ( !*v1 )
        return (char *)v2;
    }
    return &v1[strlen(v1) + 1];
  }
  return (char *)v2;
}
// 8058DB8: using guessed type int __isoc99_fscanf(_DWORD, const char *, ...);
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080B2D30) --------------------------------------------------------
__int64 __usercall read_alias_file@<edx:eax>(const unsigned __int8 *fname@<eax>, int fname_len@<edx>)
{
  void *v4; // esi
  FILE *v5; // edi
  const unsigned __int16 **v6; // eax
  unsigned __int8 *v7; // ebx
  const unsigned __int16 *v8; // edx
  char v9; // cl
  unsigned __int8 v10; // cl
  unsigned __int8 *v11; // esi
  unsigned __int8 v12; // al
  unsigned __int8 v13; // al
  _BYTE *v14; // ecx
  size_t v15; // eax
  size_t v16; // edx
  alias_map *v17; // eax
  size_t v18; // eax
  int v19; // eax
  unsigned __int8 *v20; // eax
  alias_map *v21; // edx
  int v22; // ecx
  size_t v23; // eax
  __int64 result; // rax
  alias_map *v25; // ebx
  size_t v26; // [esp+14h] [ebp-4044h]
  size_t new_size; // [esp+18h] [ebp-4040h]
  size_t alias_len; // [esp+1Ch] [ebp-403Ch]
  size_t value_len; // [esp+20h] [ebp-4038h]
  unsigned __int8 *new_pool; // [esp+24h] [ebp-4034h]
  size_t added; // [esp+28h] [ebp-4030h]
  _BYTE *v32; // [esp+2Ch] [ebp-402Ch]
  size_t v33; // [esp+2Ch] [ebp-402Ch]
  unsigned __int8 altbuf[8192]; // [esp+3Ch] [ebp-401Ch] BYREF
  unsigned __int8 buf[8192]; // [esp+203Ch] [ebp-201Ch] BYREF
  unsigned int v36; // [esp+403Ch] [ebp-1Ch]

  v36 = __readgsdword(0x14u);
  v4 = mem_alloc(fname_len + 14);
  strcpy((char *)mempcpy(v4, fname, fname_len), "/locale.alias");
  v5 = (FILE *)fopen64(v4, "rb");
  mem_free(v4);
  added = 0;
  if ( v5 )
  {
    while ( (v5->_flags & 0x10) == 0 && fgets_unlocked(buf, 0x2000, v5) )
    {
      if ( !strchr((const char *)buf, 10) )
      {
        while ( fgets_unlocked(altbuf, 0x2000, v5) && !strchr((const char *)altbuf, 10) )
          ;
      }
      v6 = __ctype_b_loc();
      v7 = buf;
      v8 = *v6;
      while ( 1 )
      {
        v9 = *v7;
        if ( (v8[*v7] & 0x2000) == 0 )
          break;
        ++v7;
      }
      if ( v9 != 35 && v9 )
      {
        v10 = v7[1];
        v11 = v7 + 1;
        if ( v10 )
        {
          while ( (v8[v10] & 0x2000) == 0 )
          {
            v10 = *++v11;
            if ( !*v11 )
              goto LABEL_40;
          }
          *v11++ = 0;
          v8 = *v6;
          v12 = *v11;
        }
        else
        {
LABEL_40:
          v12 = 0;
        }
        while ( (v8[v12] & 0x2000) != 0 )
          v12 = *++v11;
        if ( v12 )
        {
          v32 = v11 + 1;
          v13 = v11[1];
          if ( v13 )
          {
            if ( (v8[v13] & 0x2000) != 0 )
            {
LABEL_47:
              *v32 = 0;
              if ( v13 == 10 )
                v32[1] = 10;
            }
            else
            {
              v14 = v11 + 1;
              while ( 1 )
              {
                v13 = *++v14;
                if ( !*v14 )
                  break;
                if ( (v8[v13] & 0x2000) != 0 )
                {
                  v32 = v14;
                  goto LABEL_47;
                }
              }
            }
          }
          HIWORD(v15) = HIWORD(maxmap);
          if ( nmap >= maxmap )
          {
            if ( maxmap )
            {
              v16 = 2 * maxmap;
              v15 = 16 * maxmap;
            }
            else
            {
              LOWORD(v15) = 800;
              v16 = 100;
            }
            v26 = v16;
            v17 = (alias_map *)realloc(map, v15);
            if ( !v17 )
              goto LABEL_43;
            map = v17;
            maxmap = v26;
          }
          alias_len = strlen((const char *)v7) + 1;
          value_len = strlen((const char *)v11) + 1;
          v18 = string_space_act;
          if ( alias_len + value_len + string_space_act <= string_space_max )
          {
            new_pool = string_space;
            v21 = map;
            v33 = nmap;
          }
          else
          {
            v19 = 1024;
            if ( alias_len + value_len >= 0x400 )
              v19 = alias_len + value_len;
            new_size = string_space_max + v19;
            v20 = (unsigned __int8 *)realloc(string_space, string_space_max + v19);
            new_pool = v20;
            if ( !v20 )
              goto LABEL_43;
            if ( string_space == v20 )
            {
              v21 = map;
              v33 = nmap;
            }
            else
            {
              v33 = nmap;
              if ( nmap )
              {
                v21 = map;
                v22 = v20 - string_space;
                v23 = 0;
                do
                {
                  v21[v23].alias += v22;
                  v21[v23++].value += v22;
                }
                while ( v33 > v23 );
              }
              else
              {
                v21 = map;
              }
            }
            string_space_max = new_size;
            v18 = string_space_act;
            string_space = new_pool;
          }
          v21[v33].alias = (const unsigned __int8 *)memcpy(&new_pool[v18], v7, alias_len);
          string_space_act += alias_len;
          v25 = &map[nmap];
          v25->value = (const unsigned __int8 *)memcpy(&string_space[string_space_act], v11, value_len);
          string_space_act += value_len;
          ++nmap;
          ++added;
        }
      }
    }
    fclose(v5);
    if ( added )
      qsort(map, nmap, 8u, (__compar_fn_t)alias_compare);
  }
LABEL_43:
  HIDWORD(result) = __readgsdword(0x14u) ^ v36;
  LODWORD(result) = added;
  return result;
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8059008: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 8059218: using guessed type int __cdecl fgets_unlocked(_DWORD, _DWORD, _DWORD);

//----- (080B31D0) --------------------------------------------------------
const unsigned __int8 *__cdecl nl_expand_alias(const unsigned __int8 *name)
{
  const unsigned __int8 *v1; // edx
  unsigned __int8 i; // cl
  const unsigned __int8 *j; // edi
  const unsigned __int8 *v4; // eax
  void *v6; // eax
  alias_map item; // [esp+28h] [ebp-20h] BYREF

LABEL_1:
  item.alias = name;
  if ( nmap )
  {
    v6 = bsearch(&item, map, nmap, 8u, (__compar_fn_t)alias_compare);
    if ( v6 )
      return (const unsigned __int8 *)*((_DWORD *)v6 + 1);
  }
  v1 = locale_alias_path_4921;
  for ( i = *locale_alias_path_4921; *locale_alias_path_4921; i = *locale_alias_path_4921 )
  {
    for ( j = v1; ; v1 = j )
    {
      v4 = v1;
      if ( i == 58 )
      {
        do
          i = *++v1;
        while ( *v1 == 58 );
        j = v1;
        v4 = v1;
      }
      if ( i )
      {
        do
          ++v1;
        while ( *v1 != 58 && *v1 );
        j = v1;
      }
      if ( v4 < v1 )
        break;
      i = *j;
      if ( !*j )
      {
        locale_alias_path_4921 = j;
        return 0;
      }
    }
    locale_alias_path_4921 = j;
    if ( (unsigned int)read_alias_file(v4, v1 - v4) )
      goto LABEL_1;
    v1 = locale_alias_path_4921;
  }
  return 0;
}

//----- (080B32B0) --------------------------------------------------------
int __cdecl alias_compare(const alias_map *map1, const alias_map *map2)
{
  return c_strcasecmp((const char *)map1->alias, (const char *)map2->alias);
}

//----- (080B32D0) --------------------------------------------------------
unsigned __int8 *__cdecl ngettext__(const unsigned __int8 *msgid1, const unsigned __int8 *msgid2, unsigned int n)
{
  return dcngettext__(0, msgid1, msgid2, n, 5);
}

//----- (080B3310) --------------------------------------------------------
void __cdecl gettext_free_exp__(expression *exp)
{
  int nargs; // eax

  if ( exp )
  {
    nargs = exp->nargs;
    if ( exp->nargs != 2 )
    {
      if ( nargs != 3 )
      {
        if ( nargs != 1 )
        {
          free(exp);
          return;
        }
        goto LABEL_8;
      }
      gettext_free_exp__(exp->val.args[2]);
    }
    gettext_free_exp__(exp->val.args[1]);
LABEL_8:
    gettext_free_exp__(exp->val.args[0]);
    free(exp);
  }
}

//----- (080B3380) --------------------------------------------------------
expression *__usercall new_exp@<eax>(int nargs@<eax>, operator op@<edx>, expression *const *args@<ecx>)
{
  int v4; // esi
  expression *v5; // edi
  int v6; // eax
  expression *const *v7; // edx
  int v8; // eax
  expression *result; // eax
  int v11; // esi
  int v12; // edx
  expression **v13; // ecx
  expression *const *v14; // edi
  expression *v15; // esi
  expression **i; // ebx
  int v18; // [esp+18h] [ebp-20h]

  v4 = nargs - 1;
  if ( nargs - 1 >= 0 )
  {
    v5 = args[v4];
    v6 = nargs - 2;
    v18 = v6;
    if ( !v5 )
    {
LABEL_13:
      for ( i = (expression **)&args[v18]; ; --i )
      {
        gettext_free_exp__(v5);
        if ( --v4 < 0 )
          break;
        v5 = *i;
      }
      return 0;
    }
    v7 = &args[v6];
    v8 = v4;
    while ( --v8 >= 0 )
    {
      if ( !*v7-- )
        goto LABEL_13;
    }
  }
  result = (expression *)malloc(0x14u);
  if ( !result )
  {
    if ( v4 < 0 )
      return result;
    v5 = args[v4];
    v18 = nargs - 2;
    goto LABEL_13;
  }
  result->nargs = nargs;
  result->operation = op;
  if ( v4 >= 0 )
  {
    v11 = v4;
    v12 = 0;
    v13 = (expression **)((char *)&result->val + v11 * 4);
    v14 = &args[v11];
    do
    {
      v15 = *v14;
      ++v12;
      --v14;
      *v13-- = v15;
    }
    while ( v12 != nargs );
  }
  return result;
}

//----- (080B3450) --------------------------------------------------------
int __cdecl gettext__parse(void *arg)
{
  __int16 *v1; // ebx
  YYSTYPE_0 *v2; // esi
  YYSTYPE_0 *v3; // ecx
  __int16 *v4; // eax
  __int16 *v5; // edi
  int v6; // edi
  int v7; // esi
  unsigned int v8; // ebx
  void *v9; // esp
  int v10; // eax
  int v11; // edx
  unsigned __int8 v12; // dl
  expression *exp; // eax
  YYSTYPE_0 *v14; // esi
  int v15; // eax
  int v16; // eax
  unsigned int v17; // edx
  int v18; // edx
  unsigned int v19; // eax
  int v20; // eax
  expression *v22; // ecx
  operator op; // edx
  char *v24; // edx
  char v25; // cl
  int v26; // eax
  int v27; // eax
  expression *v28; // ecx
  expression *v29; // edx
  expression *v30; // edx
  YYSTYPE_0 v31; // edx
  unsigned __int8 num; // cl
  unsigned __int8 *v33; // esi
  _BYTE *v34; // [esp+0h] [ebp-528h]
  _BYTE v35[15]; // [esp+10h] [ebp-518h] BYREF
  unsigned __int8 v36; // [esp+1Fh] [ebp-509h]
  void *src; // [esp+28h] [ebp-500h]
  YYSTYPE_0 gettext__lval; // [esp+2Ch] [ebp-4FCh]
  char **v39; // [esp+30h] [ebp-4F8h]
  int yyerrstatus; // [esp+34h] [ebp-4F4h]
  unsigned int v41; // [esp+38h] [ebp-4F0h]
  int gettext__char; // [esp+3Ch] [ebp-4ECh]
  unsigned int yysize; // [esp+40h] [ebp-4E8h]
  unsigned int v44; // [esp+44h] [ebp-4E4h]
  YYSTYPE_0 *v45; // [esp+48h] [ebp-4E0h]
  int v46; // [esp+4Ch] [ebp-4DCh]
  YYSTYPE_0 yyvsa[200]; // [esp+50h] [ebp-4D8h] BYREF
  __int16 yyssa[200]; // [esp+370h] [ebp-1B8h] BYREF
  expression *args; // [esp+500h] [ebp-28h] BYREF
  unsigned int v50; // [esp+504h] [ebp-24h]
  unsigned int v51; // [esp+508h] [ebp-20h]
  unsigned int v52; // [esp+50Ch] [ebp-1Ch]

  v52 = __readgsdword(0x14u);
  v1 = yyssa;
  v2 = yyvsa;
  yyerrstatus = 0;
  v3 = yyvsa;
  v39 = (char **)arg;
  v4 = yyssa;
  v46 = 0;
  gettext__char = -2;
  v44 = 200;
  v41 = 199;
  while ( 1 )
  {
    *v1 = v46;
    v45 = v3;
    v5 = v4;
    if ( v1 >= &v4[v41] )
    {
      if ( v44 > 0x270F )
        return 2;
      v6 = 10000;
      v7 = v1 - v4;
      if ( 2 * v44 <= 0x2710 )
        v6 = 2 * v44;
      v44 = v6;
      v8 = (2 * v6 + 3) & 0xFFFFFFFC;
      v9 = alloca(6 * v6 + 18);
      v5 = (__int16 *)v35;
      yysize = v7 + 1;
      src = v3;
      memcpy(v35, v4, 2 * (v7 + 1));
      v45 = (YYSTYPE_0 *)&v35[v8];
      v34 = &v35[v8];
      v1 = (__int16 *)&v35[2 * v7];
      memcpy(v34, src, 4 * yysize);
      v41 = v44 - 1;
      if ( v1 >= (__int16 *)&v35[2 * v44 - 2] )
        return 1;
      v2 = &v45[v7];
    }
    v10 = yypact[v46];
    if ( v10 == -10 )
      goto yydefault;
    if ( gettext__char == -2 )
    {
      v24 = *v39;
      v36 = **v39;
      if ( !v36 )
        goto LABEL_41;
      if ( v36 == 9 || v36 == 32 )
      {
        while ( 1 )
        {
          v25 = *++v24;
          if ( !*v24 )
            break;
          if ( v25 != 9 && v25 != 32 )
          {
            v36 = *v24;
            goto LABEL_60;
          }
        }
LABEL_41:
        *v39 = v24;
        v11 = 0;
        gettext__char = 0;
        goto LABEL_13;
      }
LABEL_60:
      gettext__char = v36;
      yysize = (unsigned int)(v24 + 1);
      switch ( gettext__char )
      {
        case 0:
        case 10:
        case 59:
          gettext__char = 0;
          break;
        case 33:
          if ( *(_BYTE *)yysize != 61 )
            goto LABEL_64;
          v24 = (char *)(yysize + 1);
          gettext__lval.num = 13;
          gettext__char = 258;
          break;
        case 37:
          gettext__lval.num = 5;
          v24 = (char *)yysize;
          gettext__char = 261;
          break;
        case 38:
        case 124:
          if ( gettext__char != *(unsigned __int8 *)yysize )
            goto LABEL_61;
          v24 = (char *)(yysize + 1);
          break;
        case 40:
        case 41:
        case 58:
        case 63:
        case 110:
LABEL_64:
          v24 = (char *)yysize;
          break;
        case 42:
          gettext__lval.num = 3;
          v24 = (char *)yysize;
          gettext__char = 261;
          break;
        case 43:
          gettext__lval.num = 6;
          v24 = (char *)yysize;
          gettext__char = 260;
          break;
        case 45:
          gettext__lval.num = 7;
          v24 = (char *)yysize;
          gettext__char = 260;
          break;
        case 47:
          gettext__lval.num = 4;
          v24 = (char *)yysize;
          gettext__char = 261;
          break;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          v31.num = gettext__char - 48;
          LOBYTE(gettext__lval.num) = *(_BYTE *)yysize;
          if ( (unsigned __int8)(LOBYTE(gettext__lval.num) - 48) <= 9u )
          {
            num = gettext__lval.num;
            gettext__lval.num = (unsigned int)v2;
            v33 = (unsigned __int8 *)yysize;
            gettext__char = (int)v5;
            do
            {
              ++v33;
              v31.num = num + 10 * v31.num - 48;
              num = *v33;
            }
            while ( (unsigned __int8)(*v33 - 48) <= 9u );
            yysize = (unsigned int)v33;
            v2 = (YYSTYPE_0 *)gettext__lval.num;
            v5 = (__int16 *)gettext__char;
          }
          gettext__lval.num = v31.num;
          v24 = (char *)yysize;
          gettext__char = 262;
          break;
        case 60:
          if ( *(_BYTE *)yysize == 61 )
          {
            v24 = (char *)(yysize + 1);
            gettext__lval.num = 10;
          }
          else
          {
            gettext__lval.num = 8;
            v24 = (char *)yysize;
          }
          gettext__char = 259;
          break;
        case 61:
          if ( *(_BYTE *)yysize != 61 )
            goto LABEL_61;
          v24 = (char *)(yysize + 1);
          gettext__lval.num = 12;
          gettext__char = 258;
          break;
        case 62:
          if ( *(_BYTE *)yysize == 61 )
          {
            v24 = (char *)(yysize + 1);
            gettext__lval.num = 11;
          }
          else
          {
            gettext__lval.num = 9;
            v24 = (char *)yysize;
          }
          gettext__char = 259;
          break;
        default:
LABEL_61:
          v24 = (char *)yysize;
          gettext__char = 256;
          break;
      }
      *v39 = v24;
    }
    if ( gettext__char <= 0 )
    {
      v11 = 0;
      gettext__char = 0;
    }
    else
    {
      v11 = 2;
      if ( (unsigned int)gettext__char <= 0x106 )
        v11 = yytranslate[gettext__char];
    }
LABEL_13:
    yysize = v11 + v10;
    if ( (unsigned int)(v11 + v10) <= 0x36 && yycheck[v11 + v10] == v11 )
      break;
yydefault:
    v12 = yydefact[v46];
    v46 = v12;
    if ( !v12 )
      goto yyerrlab;
    yysize = yyr2[v12];
    exp = v2[1 - yysize].exp;
    switch ( v12 )
    {
      case 2u:
        if ( !v2->num )
          return 1;
        v39[1] = (char *)v2->num;
        break;
      case 3u:
        v27 = v2[-2].num;
        v28 = v2[-4].exp;
        v51 = v2->num;
        v50 = v27;
        args = v28;
        exp = new_exp(3, qmop, &args);
        break;
      case 4u:
        v29 = v2[-2].exp;
        v50 = v2->num;
        args = v29;
        exp = new_exp(2, lor, &args);
        break;
      case 5u:
        v30 = v2[-2].exp;
        v50 = v2->num;
        args = v30;
        exp = new_exp(2, land, &args);
        break;
      case 6u:
      case 7u:
      case 8u:
      case 9u:
        v22 = v2[-2].exp;
        op = v2[-1].op;
        v50 = v2->num;
        args = v22;
        exp = new_exp(2, op, &args);
        break;
      case 0xAu:
        args = (expression *)v2->num;
        exp = new_exp(1, lnot, &args);
        break;
      case 0xBu:
        exp = new_exp(0, var, 0);
        break;
      case 0xCu:
        exp = new_exp(0, num, 0);
        if ( exp )
          exp->val.num = v2->num;
        break;
      case 0xDu:
        exp = v2[-1].exp;
        break;
      default:
        break;
    }
    v14 = &v2[-yysize];
    v1 -= yysize;
    v14[1].num = (unsigned int)exp;
    v2 = v14 + 1;
    v15 = yyr1[v46];
    LOWORD(v46) = *v1;
    v16 = v15 - 16;
    v17 = (__int16)v46 + yypgoto[v16];
    if ( v17 <= 0x36 && (_WORD)v46 == yycheck[v17] )
      v46 = yytable[v17];
    else
      v46 = yydefgoto[v16];
yynewstate:
    ++v1;
    v4 = v5;
    v3 = v45;
  }
  v18 = yytable[yysize];
  if ( yytable[yysize] )
  {
    if ( v18 == 9 )
      return 0;
    v26 = -2;
    if ( !gettext__char )
      v26 = 0;
    ++v2;
    gettext__char = v26;
    v2->num = gettext__lval.num;
    v46 = v18;
    yyerrstatus = (yyerrstatus == 0) + yyerrstatus - 1;
    goto yynewstate;
  }
yyerrlab:
  if ( yyerrstatus == 3 )
  {
    if ( gettext__char )
    {
      gettext__char = -2;
      goto LABEL_28;
    }
    return 1;
  }
LABEL_28:
  while ( 1 )
  {
    if ( v10 != -10 )
    {
      v19 = v10 + 1;
      if ( v19 <= 0x36 && yycheck[v19] == 1 )
      {
        v20 = yytable[v19];
        if ( v20 )
          break;
      }
    }
    if ( v1 == v5 )
      return 1;
    --v1;
    --v2;
    v10 = yypact[*v1];
  }
  if ( v20 != 9 )
  {
    ++v2;
    v2->num = gettext__lval.num;
    v46 = v20;
    yyerrstatus = 3;
    goto yynewstate;
  }
  return 0;
}

//----- (080B3BF0) --------------------------------------------------------
unsigned __int8 *__cdecl textdomain__(const unsigned __int8 *domainname)
{
  unsigned __int8 *v1; // esi
  unsigned __int8 *v2; // ebx
  int v4; // ecx
  char *v5; // eax

  if ( domainname )
  {
    v1 = (unsigned __int8 *)nl_current_default_domain__;
    if ( !*domainname || !strcmp((const char *)domainname, (const char *)nl_default_default_domain__) )
    {
      nl_current_default_domain__ = (char *)nl_default_default_domain__;
      v2 = (unsigned __int8 *)nl_default_default_domain__;
    }
    else
    {
      if ( !strcmp((const char *)domainname, (const char *)v1) )
      {
        if ( v1 )
        {
          ++nl_msg_cat_cntr;
          return v1;
        }
        return v1;
      }
      v5 = (char *)__strdup(v4, domainname);
      v2 = (unsigned __int8 *)v5;
      if ( !v5 )
        return v2;
      nl_current_default_domain__ = v5;
    }
    ++nl_msg_cat_cntr;
    if ( v1 != v2 )
    {
      if ( v1 != nl_default_default_domain__ )
        free(v1);
      return v2;
    }
    return v1;
  }
  return (unsigned __int8 *)nl_current_default_domain__;
}
// 80B3C83: variable 'v4' is possibly undefined
// 8059A88: using guessed type int __thiscall __strdup(_DWORD, _DWORD);

//----- (080B3CB0) --------------------------------------------------------
unsigned __int8 *__cdecl get_event_name(int id)
{
  if ( id >= 0 && id < eventssize )
    return events[id].name;
  else
    return 0;
}

//----- (080B3CE0) --------------------------------------------------------
void done_event()
{
  unsigned int v0; // esi
  unsigned int v1; // ebx
  unsigned int v2; // esi
  event *v3; // eax

  if ( eventssize )
  {
    v0 = 0;
    v1 = 0;
    do
    {
      v2 = v0;
      v3 = &events[v2];
      if ( events[v2].handlers )
      {
        mem_free(events[v2].handlers);
        v3 = &events[v2];
      }
      v0 = ++v1;
      mem_free(v3->name);
    }
    while ( eventssize > v1 );
  }
  if ( events )
    mem_free(events);
  events = 0;
  if ( event_hash )
    free_hash(&event_hash);
  eventssize = 0;
}

//----- (080B3D70) --------------------------------------------------------
void init_event()
{
  event_hash = init_hash8();
}

//----- (080B3D90) --------------------------------------------------------
void __cdecl unregister_event_hook(int id, event_hook_T callback)
{
  event *v2; // ebx
  unsigned int count; // edi
  int v4; // eax
  evhook_status (**v5)(va_list, void *); // ecx
  evhook_status (*v6)(va_list, void *); // ebx
  event_handler *handlers; // edx
  int v8; // ecx
  int v9; // ecx
  int v10; // eax
  bool v11; // zf
  event_handler *v12; // eax
  event_hook_T *p_callback; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = callback == 0, !callback)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c",
        errline = 250,
        elinks_internal("assertion callback failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( id >= 0 && id < eventssize )
  {
    v2 = &events[id];
    p_callback = &v2->handlers->callback;
    if ( p_callback )
    {
      count = v2->count;
      if ( count )
      {
        if ( *p_callback == callback )
        {
          handlers = v2->handlers;
          v9 = 3;
          v4 = 1;
LABEL_14:
          memmove(handlers, &p_callback[v9], 12 * (count - v4));
          v10 = v2->count - 1;
          v11 = v2->count == 1;
          v2->count = v10;
          if ( v11 )
          {
            mem_free(v2->handlers);
            v2->handlers = 0;
          }
          else
          {
            v12 = (event_handler *)mem_realloc(v2->handlers, 12 * v10);
            if ( v12 )
              v2->handlers = v12;
          }
        }
        else
        {
          v4 = 0;
          v5 = p_callback + 3;
          while ( ++v4 < count )
          {
            v6 = *v5;
            handlers = (event_handler *)v5;
            v5 += 3;
            if ( v6 == callback )
            {
              v8 = v4 + 1;
              v2 = &events[id];
              if ( v4 + 1 > v4 )
                ++v4;
              v9 = 3 * v8;
              goto LABEL_14;
            }
          }
        }
      }
    }
  }
}

//----- (080B3F00) --------------------------------------------------------
void __usercall trigger_event_va(int id@<eax>, va_list ap_init@<edx>)
{
  int v3; // esi
  event *v4; // eax
  event_handler *handlers; // ebx
  int v6; // [esp+1Ch] [ebp-1Ch]

  if ( id >= 0 && id < eventssize )
  {
    v3 = 0;
    v6 = id;
    v4 = &events[id];
    handlers = v4->handlers;
    if ( v4->count )
    {
      while ( handlers->callback(ap_init, handlers->data) != EVENT_HOOK_STATUS_LAST )
      {
        if ( events[v6].count <= ++v3 )
          break;
        ++handlers;
      }
    }
  }
}

//----- (080B3F70) --------------------------------------------------------
void trigger_event(int id, ...)
{
  va_list ap_init; // [esp+14h] [ebp+Ch] BYREF

  va_start(ap_init, id);
  trigger_event_va(id, ap_init);
}

//----- (080B3F90) --------------------------------------------------------
int __cdecl get_event_id(unsigned __int8 *name)
{
  hash *v1; // esi
  unsigned int v3; // eax
  hash_item *hash_item; // eax
  _DWORD *value; // ebx

  if ( assert_failed )
    goto LABEL_8;
  if ( name && *name )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
  errline = 125;
  elinks_internal("assertion name && name[0] failed: Empty or missing event name");
  if ( assert_failed )
  {
LABEL_8:
    assert_failed = 0;
    return -1;
  }
LABEL_5:
  v1 = event_hash;
  if ( !event_hash )
    return -1;
  v3 = strlen((const char *)name);
  hash_item = get_hash_item(v1, name, v3);
  if ( !hash_item )
    return -1;
  value = hash_item->value;
  if ( assert_failed )
    goto LABEL_8;
  assert_failed = value == 0;
  if ( !value )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c";
    errline = 135;
    elinks_internal("assertion event != NULL failed: Hash item with no value");
    if ( assert_failed )
      goto LABEL_8;
  }
  return value[3];
}

//----- (080B40B0) --------------------------------------------------------
void __cdecl unregister_event_hooks(event_hook_info *hooks)
{
  event_hook_info *v1; // esi
  unsigned __int8 *name; // eax
  event_hook_info *v3; // ebx
  int event_id; // eax

  v1 = hooks;
  name = hooks->name;
  if ( hooks->name )
  {
    v3 = hooks + 1;
    do
    {
      event_id = get_event_id(name);
      if ( event_id != -1 )
        unregister_event_hook(event_id, v1->callback);
      name = v3->name;
      v1 = v3++;
    }
    while ( name );
  }
}

//----- (080B4100) --------------------------------------------------------
void trigger_event_name(unsigned __int8 *name, ...)
{
  int event_id; // eax
  va_list ap_init; // [esp+24h] [ebp+Ch] BYREF

  va_start(ap_init, name);
  event_id = get_event_id(name);
  trigger_event_va(event_id, ap_init);
}

//----- (080B4120) --------------------------------------------------------
int __cdecl register_event(unsigned __int8 *name)
{
  unsigned __int8 *v1; // esi
  unsigned int event_id; // ebx
  event *v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // edi
  unsigned int v7; // ecx
  unsigned int v8; // edi
  unsigned int v9; // edx
  unsigned int v10; // esi
  char *v11; // ebx
  unsigned int v12; // eax
  hash_item *hash_item; // eax
  event *v14; // edi
  unsigned __int8 *v15; // eax
  unsigned int v16; // eax
  event *v17; // eax
  unsigned int v18; // ecx
  event *v19; // edi
  size_t keylen; // [esp+14h] [ebp-24h]
  unsigned int keylena; // [esp+14h] [ebp-24h]
  event *v22; // [esp+1Ch] [ebp-1Ch]

  v1 = name;
  event_id = get_event_id(name);
  if ( event_id == -1 )
  {
    v4 = events;
    v5 = (eventssize + 8) & 0xFFFFFFF8;
    v6 = (eventssize + 7) & 0xFFFFFFF8;
    v22 = events;
    if ( v5 > v6 )
    {
      keylena = 16 * v5;
      v17 = (event *)mem_realloc(events, 16 * v5);
      if ( !v17 )
        return event_id;
      v18 = v6;
      v19 = v17;
      events = v17;
      memset(&v17[v18], 0, keylena - 16 * v18);
      v4 = v19;
    }
    if ( v4 )
    {
      if ( v22 == v4 )
      {
        v9 = eventssize;
      }
      else
      {
        v7 = 0;
        v8 = 0;
        v9 = 0;
        v22 = v4;
        if ( eventssize )
        {
          while ( 1 )
          {
            v10 = v7;
            v11 = (char *)v4[v7].name;
            v12 = strlen(v11);
            hash_item = get_hash_item(event_hash, (unsigned __int8 *)v11, v12);
            if ( hash_item )
              hash_item->value = &events[v10];
            v9 = eventssize;
            v7 = ++v8;
            if ( eventssize <= v8 )
              break;
            v4 = events;
          }
          v1 = name;
          event_id = -1;
          v22 = events;
        }
      }
      v14 = &v22[v9];
      keylen = strlen((const char *)v1);
      v15 = memacpy(v1, keylen);
      v14->name = v15;
      if ( v15 )
      {
        if ( add_hash_item(event_hash, v15, keylen, v14) )
        {
          v14->handlers = 0;
          v14->count = 0;
          event_id = eventssize;
          v16 = eventssize + 1;
          v14->id = eventssize;
          eventssize = v16;
        }
        else
        {
          mem_free(v14->name);
          v14->name = 0;
        }
      }
    }
  }
  return event_id;
}

//----- (080B42D0) --------------------------------------------------------
int __cdecl register_event_hook(int id, event_hook_T callback, int priority, void *data)
{
  unsigned int count; // ebx
  int v5; // eax
  event_handler *handlers; // edi
  event_handler *v7; // edx
  evhook_status (*v8)(va_list, void *); // ecx
  int v9; // edx
  int v10; // ecx
  bool v11; // of
  int v12; // eax
  int v13; // edx
  event_handler *v14; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // ebx
  int result; // eax
  int v19; // ecx
  event_handler *v20; // edi
  int v21; // ecx
  size_t v22; // eax
  int v23; // [esp+14h] [ebp-24h]
  event *event; // [esp+18h] [ebp-20h]
  int v25; // [esp+1Ch] [ebp-1Ch]
  int v26; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = callback == 0, !callback)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/event.c",
        errline = 209,
        elinks_internal("assertion callback failed!"),
        assert_failed) )
  {
    result = -1;
    assert_failed = 0;
    return result;
  }
  if ( id < 0 || id >= eventssize )
    return -1;
  event = &events[id];
  count = event->count;
  if ( !count )
  {
    handlers = events[id].handlers;
    v22 = 12;
LABEL_33:
    v14 = (event_handler *)mem_realloc(handlers, v22);
    if ( v14 )
    {
      event->handlers = v14;
      v23 = event->count + 1;
      event->count = v23;
      goto LABEL_15;
    }
    return -1;
  }
  v5 = 0;
  handlers = event->handlers;
  v7 = handlers;
  if ( handlers->callback != callback )
  {
    do
    {
      if ( ++v5 >= count )
        break;
      v8 = v7[1].callback;
      ++v7;
    }
    while ( v8 != callback );
    handlers = event->handlers;
    if ( v5 != count )
    {
      v9 = v5 + 1;
      v10 = v5;
      v11 = v5 + 1 <= v5;
      v12 = 3 * v5;
      if ( !v11 )
        v10 = v9;
      v13 = v9;
      v25 = 4 * v12;
      goto LABEL_14;
    }
    v22 = 12 * (v5 + 1);
    goto LABEL_33;
  }
  v25 = 0;
  v13 = 1;
  v10 = 1;
LABEL_14:
  memmove((char *)handlers + v25, &handlers[v13], 12 * (count - v10));
  v14 = event->handlers;
  v23 = event->count;
LABEL_15:
  if ( v23 == 1 )
  {
    v21 = 1;
    v16 = 0;
    v20 = event->handlers;
    v26 = 1;
  }
  else
  {
    v15 = 0;
    v16 = 12;
    if ( priority <= v14->priority )
    {
      while ( 1 )
      {
        if ( v23 - 1 <= (unsigned int)++v15 )
        {
          v17 = v15;
          if ( v15 + 1 > v15 )
            v17 = v15 + 1;
          v26 = v17;
          v16 = 12 * v15;
          v20 = &v14[v15];
          v21 = v15 + 1;
          goto LABEL_24;
        }
        v20 = (event_handler *)((char *)v14 + v16);
        if ( *(int *)((char *)&v14->priority + v16) < priority )
          break;
        v16 += 12;
      }
      v19 = v15 + 1;
      if ( v15 + 1 > v15 )
        ++v15;
      v26 = v15;
      v21 = v19;
    }
    else
    {
      v20 = v14;
      v21 = 1;
      LOBYTE(v16) = 0;
      v26 = 1;
    }
  }
LABEL_24:
  memmove(&v14[v21], v20, 12 * (v23 - v26));
  *(event_hook_T *)((char *)&event->handlers->callback + v16) = callback;
  *(int *)((char *)&event->handlers->priority + v16) = priority;
  *(void **)((char *)&event->handlers->data + v16) = data;
  return id;
}

//----- (080B4560) --------------------------------------------------------
void __cdecl register_event_hooks(event_hook_info *hooks)
{
  event_hook_info *v1; // esi
  unsigned __int8 *name; // eax
  event_hook_info *v3; // ebx
  int v4; // eax

  v1 = hooks;
  name = hooks->name;
  if ( hooks->name )
  {
    v3 = hooks + 1;
    do
    {
      v4 = register_event(name);
      if ( v4 != -1 )
        register_event_hook(v4, v1->callback, v1->priority, v1->data);
      name = v3->name;
      v1 = v3++;
    }
    while ( name );
  }
}

//----- (080B45C0) --------------------------------------------------------
int __usercall get_address@<eax>(socket_info *info@<eax>)
{
  option_value *opt; // eax
  sockaddr *v3; // eax
  sockaddr *v4; // edi
  int v6; // [esp+1Ch] [ebp-2Ch]
  string path; // [esp+28h] [ebp-20h] BYREF

  if ( assert_failed
    || (assert_failed = info == 0, !info)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c",
        errline = 139,
        elinks_internal("assertion info failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return -1;
  }
  else
  {
    assert_failed = 0;
    if ( elinks_home && init_string(&path) )
    {
      add_to_string(&path, (const unsigned __int8 *)elinks_home);
      add_to_string(&path, "socket");
      opt = get_opt_(cmdline_options, "session-ring");
      add_long_to_string(&path, opt->number);
      v6 = 107 - path.length;
      if ( 107 - path.length < 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
        errline = 174;
        elinks_internal("Socket path name '%s' is too long: %d >= %zu", (const char *)path.source, path.length, 0x6Cu);
      }
      else
      {
        v3 = (sockaddr *)mem_calloc(1u, 0x6Eu);
        v4 = v3;
        if ( v3 )
        {
          memcpy(v3->sa_data, path.source, path.length);
          done_string(&path);
          v4->sa_family = 1;
          info->addr = v4;
          info->size = 110 - v6;
          return 1;
        }
      }
      done_string(&path);
      return -1;
    }
    else
    {
      return -1;
    }
  }
}

//----- (080B4770) --------------------------------------------------------
void __usercall report_af_unix_error(unsigned __int8 *function@<eax>, int error@<edx>)
{
  char *v4; // edi
  unsigned __int8 *v5; // eax

  errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c";
  errline = 329;
  v4 = strerror(error);
  v5 = gettext("The call to %s failed: %d (%s)");
  elinks_error(v5, function, error, v4);
}

//----- (080B47D0) --------------------------------------------------------
void __usercall unlink_unix(sockaddr *addr@<eax>)
{
  if ( assert_failed
    || (assert_failed = addr == 0, !addr)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c",
        errline = 225,
        elinks_internal("assertion addr failed!"),
        addr = 0,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    unlink(addr->sa_data);
  }
}

//----- (080B4840) --------------------------------------------------------
void done_interlink()
{
  sockaddr *addr; // eax
  sockaddr *v1; // eax
  sockaddr *v2; // eax

  addr = s_info_listen.addr;
  if ( s_info_listen.addr )
  {
    if ( s_info_listen.fd != -1 )
    {
      close(s_info_listen.fd);
      addr = s_info_listen.addr;
      s_info_listen.fd = -1;
    }
    unlink_unix(addr);
    mem_free(s_info_listen.addr);
    s_info_listen.addr = 0;
  }
  v1 = s_info_connect.addr;
  if ( s_info_connect.addr )
  {
    if ( s_info_connect.fd != -1 )
    {
      close(s_info_connect.fd);
      v1 = s_info_connect.addr;
      s_info_connect.fd = -1;
    }
    mem_free(v1);
    s_info_connect.addr = 0;
  }
  v2 = s_info_accept.addr;
  if ( s_info_accept.addr )
  {
    if ( s_info_accept.fd != -1 )
    {
      close(s_info_accept.fd);
      v2 = s_info_accept.addr;
      s_info_accept.fd = -1;
    }
    mem_free(v2);
    s_info_accept.addr = 0;
  }
}

//----- (080B4910) --------------------------------------------------------
void __cdecl af_unix_connection(socket_info *info)
{
  int v1; // eax
  int *v2; // eax
  int l[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( assert_failed
    || (assert_failed = info == 0, !info)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/interlink.c",
        errline = 340,
        elinks_internal("assertion info failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    l[0] = info->size;
    memset(info->addr, 0, l[0]);
    v1 = accept(info->fd, info->addr, (socklen_t *)l);
    if ( v1 < 0 )
    {
      v2 = __errno_location();
      report_af_unix_error("accept()", *v2);
    }
    else
    {
      init_term(v1, v1);
      set_highpri();
    }
  }
}
// 80B4910: using guessed type socklen_t l[3];

//----- (080B49E0) --------------------------------------------------------
void __cdecl elinks_usleep(unsigned int useconds)
{
  fd_set dummy; // [esp+28h] [ebp-90h] BYREF
  timeval delay; // [esp+A8h] [ebp-10h] BYREF

  memset(&dummy, 0, sizeof(dummy));
  delay.tv_sec = 0;
  delay.tv_usec = useconds;
  select(0, &dummy, &dummy, &dummy, &delay);
}

//----- (080B4A40) --------------------------------------------------------
int init_interlink()
{
  int v0; // ebx
  int v1; // eax
  int *v2; // eax
  int v3; // edi
  int *v4; // esi
  int address; // edi
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  int *v10; // eax
  int result; // eax
  int *v12; // eax
  sockaddr *v13; // eax
  int *v14; // eax
  unsigned int v15; // [esp+0h] [ebp-48h]
  unsigned int v16; // [esp+0h] [ebp-48h]
  int domain; // [esp+2Ch] [ebp-1Ch]
  int domaina; // [esp+2Ch] [ebp-1Ch]

  domain = get_address(&s_info_connect);
  if ( domain == -1 )
  {
LABEL_7:
    if ( s_info_connect.addr )
      mem_free(s_info_connect.addr);
    s_info_connect.addr = 0;
LABEL_10:
    domaina = umask(0x7Fu);
    address = get_address(&s_info_listen);
    if ( address != -1 )
    {
      v6 = 100000;
      v7 = 0;
      while ( 1 )
      {
        v8 = socket(address, 1, 0);
        s_info_listen.fd = v8;
        if ( v8 == -1 )
        {
          v12 = __errno_location();
          report_af_unix_error("socket()", *v12);
          goto LABEL_25;
        }
        if ( bind(v8, s_info_listen.addr, s_info_listen.size) >= 0 )
          break;
        v9 = *__errno_location();
        if ( v9 != 98 )
          report_af_unix_error("bind()", v9);
        if ( ++v7 == 3 )
        {
          unlink_unix(s_info_listen.addr);
        }
        else if ( v7 > 3 )
        {
          goto LABEL_25;
        }
        v16 = v6;
        v6 += 100000;
        elinks_usleep(v16);
        close(s_info_listen.fd);
      }
      if ( assert_failed )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 0;
        v13 = (sockaddr *)mem_calloc(1u, 0x6Eu);
        if ( v13 )
        {
          s_info_accept.addr = v13;
          s_info_accept.size = 110;
          s_info_accept.fd = s_info_listen.fd;
          if ( !listen(s_info_listen.fd, 100) )
          {
            set_handlers(s_info_listen.fd, (select_handler_T)af_unix_connection, 0, 0, &s_info_accept);
            umask(domaina);
            return -1;
          }
          v14 = __errno_location();
          report_af_unix_error("listen()", *v14);
        }
      }
    }
LABEL_25:
    done_interlink();
    umask(domaina);
    return -1;
  }
  v0 = 50000;
  while ( 1 )
  {
    v1 = socket(domain, 1, 0);
    s_info_connect.fd = v1;
    if ( v1 == -1 )
    {
      v10 = __errno_location();
      report_af_unix_error("socket()", *v10);
      goto LABEL_7;
    }
    if ( connect(v1, s_info_connect.addr, s_info_connect.size) >= 0 )
      break;
    v2 = __errno_location();
    v3 = *v2;
    v4 = v2;
    close(s_info_connect.fd);
    if ( v3 != 2 && v3 != 111 )
    {
      report_af_unix_error("connect()", *v4);
      goto LABEL_7;
    }
    v15 = v0;
    v0 += 50000;
    elinks_usleep(v15);
    if ( v0 == 200000 )
      goto LABEL_7;
  }
  result = s_info_connect.fd;
  if ( s_info_connect.fd == -1 )
    goto LABEL_10;
  return result;
}

//----- (080B4D20) --------------------------------------------------------
void __usercall check_stdio(list_head_elinks *url_list@<eax>)
{
  option_value *opt; // ebx

  if ( !assert_failed )
  {
    assert_failed = remote_session_flags_0 != 0;
    if ( remote_session_flags_0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
      errline = 67;
      elinks_internal("assertion !remote_session_flags failed!");
    }
  }
  if ( !isatty(0) )
  {
    if ( url_list && url_list->next == url_list )
    {
      get_opt_(config_options, "protocol.file.allow_special_files")->number = 1;
      add_to_string_list(url_list, (const unsigned __int8 *)byte_8131543, 17);
    }
    get_opt_(cmdline_options, "no-connect")->number = 1;
  }
  if ( !isatty(1) )
  {
    opt = get_opt_(cmdline_options, "dump");
    if ( !opt->number && !get_opt_(cmdline_options, "source")->number )
      opt->number = 1;
  }
}

//----- (080B4E40) --------------------------------------------------------
void init()
{
  char *cwd; // eax
  char *v1; // esi
  retval v2; // eax
  char *v3; // eax
  const char *v4; // edi
  const unsigned __int8 *v5; // edi
  int inited; // esi
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  int input_handle; // eax
  terminal *v12; // eax
  unsigned __int8 *source; // esi
  int v14; // eax
  unsigned __int8 *v15; // eax
  int init_len; // [esp+2Ch] [ebp-3Ch]
  int init_lena; // [esp+2Ch] [ebp-3Ch]
  remote_session_flags remote; // [esp+30h] [ebp-38h]
  int remotea; // [esp+30h] [ebp-38h]
  unsigned __int8 *init_string; // [esp+34h] [ebp-34h]
  int ctl_in; // [esp+38h] [ebp-30h]
  int std_out; // [esp+3Ch] [ebp-2Ch]
  int std_outa; // [esp+3Ch] [ebp-2Ch]
  string info; // [esp+40h] [ebp-28h] BYREF
  list_head_elinks url_list; // [esp+48h] [ebp-20h] BYREF

  url_list.next = &url_list;
  url_list.prev = &url_list;
  init_osdep();
  cwd = get_cwd();
  v1 = cwd;
  if ( cwd && file_is_dir((const unsigned __int8 *)cwd) )
    goto LABEL_3;
  v3 = getenv("HOME");
  v4 = v3;
  if ( v3 && file_is_dir((const unsigned __int8 *)v3) )
  {
    chdir(v4);
    if ( v1 )
      goto LABEL_3;
  }
  else if ( v1 )
  {
LABEL_3:
    mem_free(v1);
  }
  bindtextdomain("elinks", "/usr/share/locale");
  textdomain("elinks");
  set_language(0);
  init_event();
  init_charsets_lookup();
  init_colors_lookup();
  init_modules(main_modules);
  init_options();
  init_static_version();
  register_modules_options(main_modules);
  register_modules_options(builtin_modules);
  set_sigcld();
  get_system_name();
  if ( check_terminal_pipes() )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
    errline = 136;
    v7 = gettext("Cannot create a pipe for internal communication.");
    elinks_error(v7);
    program_0.retval = RET_FATAL;
    program_0.terminate = 1;
    return;
  }
  v2 = parse_options(ac - 1, av + 1, &url_list);
  if ( v2 == RET_OK )
  {
    if ( remote_session_flags_0 )
      program_0.terminate = 1;
    else
      check_stdio(&url_list);
    if ( !get_opt_(cmdline_options, "no-home")->number )
      init_home();
    if ( get_opt_(cmdline_options, "no-connect")->number
      || (v5 = "dump", get_opt_(cmdline_options, "dump")->number)
      || get_opt_(cmdline_options, "source")->number
      || (inited = init_interlink(), inited == -1) )
    {
      load_config();
      update_options_visibility();
      parse_options(ac - 1, av + 1, 0);
      if ( !remote_session_flags_0 )
        check_stdio(0);
      init_b = 1;
      v5 = "dump";
      inited = -1;
      init_modules(builtin_modules);
    }
    if ( get_opt_(cmdline_options, "dump")->number || get_opt_(cmdline_options, "source")->number )
    {
      if ( &url_list == url_list.next )
      {
        if ( !get_opt_(cmdline_options, "dump")->number )
          v5 = "source";
        v8 = gettext("URL expected after -%s");
        usrerror(v8, v5);
        program_0.retval = RET_SYNTAX;
        program_0.terminate = 1;
        goto LABEL_37;
      }
      dump_next(&url_list);
LABEL_24:
      if ( !program_0.terminate )
      {
LABEL_25:
        free_string_list(&url_list);
        return;
      }
LABEL_37:
      close_terminal_pipes();
      goto LABEL_25;
    }
    if ( (remote_session_flags_0 & 0x10) != 0 )
    {
      if ( inited == -1 )
      {
        v9 = gettext("No running ELinks found.");
        usrerror(v9);
        program_0.retval = RET_PING;
      }
      goto LABEL_24;
    }
    if ( inited == -1 && remote_session_flags_0 )
    {
      v10 = gettext("No remote session to connect to.");
      usrerror(v10);
      program_0.retval = RET_REMOTE;
      goto LABEL_24;
    }
    if ( encode_session_info(&info, &url_list) )
    {
      if ( inited != -1 )
      {
        close_terminal_pipes();
        remote = remote_session_flags_0;
        init_len = info.length;
        init_string = info.source;
        ctl_in = get_ctl_handle();
        std_out = get_output_handle();
        input_handle = get_input_handle();
        handle_trm(input_handle, std_out, inited, inited, ctl_in, init_string, init_len, remote);
        v12 = 0;
        goto LABEL_48;
      }
      source = info.source;
      remotea = info.length;
      init_lena = get_ctl_handle();
      std_outa = get_output_handle();
      v14 = get_input_handle();
      v12 = attach_terminal(v14, std_outa, init_lena, source, remotea);
      if ( v12 )
      {
LABEL_48:
        if ( !program_0.terminate )
          handle_basic_signals(v12);
        goto LABEL_50;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
      errline = 241;
      v15 = gettext("Unable to attach_terminal().");
    }
    else
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/main.c";
      errline = 224;
      v15 = gettext("Unable to encode session info.");
    }
    elinks_error(v15);
    program_0.retval = RET_FATAL;
    program_0.terminate = 1;
LABEL_50:
    done_string(&info);
    goto LABEL_24;
  }
  if ( v2 != RET_COMMAND )
    program_0.retval = v2;
  program_0.terminate = 1;
  free_string_list(&url_list);
}

//----- (080B53A0) --------------------------------------------------------
void __cdecl shrink_memory(int whole)
{
  shrink_dns_cache(whole);
  shrink_format_cache(whole);
  garbage_collection(whole);
}

//----- (080B53D0) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned __int8 *v3; // edx

  program_0.terminate = 0;
  program_0.retval = RET_OK;
  v3 = (unsigned __int8 *)*argv;
  av = (unsigned __int8 **)argv;
  program_0.path = v3;
  ac = argc;
  select_loop(init);
  done_interlink();
  check_bottom_halves();
  abort_all_downloads();
  check_bottom_halves();
  destroy_all_terminals();
  check_bottom_halves();
  free_all_itrms();
  abort_all_connections();
  check_bottom_halves();
  abort_all_connections();
  if ( init_b )
  {
    trigger_event_name("quit");
    free_history_lists();
    done_modules(builtin_modules);
    done_saved_session_info();
  }
  shrink_memory(1);
  free_charsets_lookup();
  free_colors_lookup();
  done_modules(main_modules);
  free_conv_table();
  check_bottom_halves();
  done_home();
  done_state_message();
  done_bfu_colors();
  unregister_modules_options(builtin_modules);
  unregister_modules_options(main_modules);
  done_options();
  done_event();
  terminate_osdep();
  return program_0.retval;
}

//----- (080B54F0) --------------------------------------------------------
void __cdecl done_module(module *module)
{
  module **submodules; // edx
  int i; // ebx
  module *v3; // eax
  int v4; // ebx
  int v5; // esi
  void (*done)(module *); // eax

  submodules = module->submodules;
  if ( submodules )
  {
    if ( *submodules )
    {
      for ( i = 0; submodules[i + 1]; ++i )
        ;
      if ( i != -1 )
      {
        v3 = submodules[i];
        if ( v3 )
        {
          v4 = i - 1;
          v5 = v4;
          while ( 1 )
          {
            done_module(v3);
            if ( v4 == -1 )
              break;
            v3 = module->submodules[v5--];
            if ( !v3 )
              break;
            --v4;
          }
        }
      }
    }
  }
  if ( module->hooks )
    unregister_event_hooks(module->hooks);
  done = module->done;
  if ( done )
    done(module);
}

//----- (080B5580) --------------------------------------------------------
void __cdecl done_modules(module **modules)
{
  int i; // ebx
  module *v2; // eax
  int v3; // ebx
  module **v4; // esi

  if ( modules )
  {
    if ( *modules )
    {
      for ( i = 0; modules[i + 1]; ++i )
        ;
      if ( i != -1 )
      {
        v2 = modules[i];
        if ( v2 )
        {
          v3 = i - 1;
          v4 = &modules[v3];
          while ( 1 )
          {
            done_module(v2);
            if ( v3 == -1 )
              break;
            v2 = *v4--;
            if ( !v2 )
              break;
            --v3;
          }
        }
      }
    }
  }
}

//----- (080B55E0) --------------------------------------------------------
void __cdecl init_module(module *module)
{
  void (*init)(module *); // eax
  module **submodules; // eax
  module *v3; // eax
  int v4; // ebx

  init = module->init;
  if ( init )
    init(module);
  if ( module->hooks )
    register_event_hooks(module->hooks);
  submodules = module->submodules;
  if ( submodules )
  {
    v3 = *submodules;
    if ( v3 )
    {
      v4 = 1;
      do
      {
        init_module(v3);
        v3 = module->submodules[v4++];
      }
      while ( v3 );
    }
  }
}

//----- (080B5640) --------------------------------------------------------
void __cdecl init_modules(module **modules)
{
  module **v1; // ebx
  module *i; // eax

  v1 = modules;
  if ( modules )
  {
    for ( i = *modules; i; ++v1 )
    {
      init_module(i);
      i = v1[1];
    }
  }
}

//----- (080B5670) --------------------------------------------------------
void __cdecl unregister_module_options(module *module)
{
  module **submodules; // edx
  int i; // ebx
  module *v3; // eax
  int v4; // ebx
  int v5; // esi

  submodules = module->submodules;
  if ( submodules )
  {
    if ( *submodules )
    {
      for ( i = 0; submodules[i + 1]; ++i )
        ;
      if ( i != -1 )
      {
        v3 = submodules[i];
        if ( v3 )
        {
          v4 = i - 1;
          v5 = v4;
          while ( 1 )
          {
            unregister_module_options(v3);
            if ( v4 == -1 )
              break;
            v3 = module->submodules[v5--];
            if ( !v3 )
              break;
            --v4;
          }
        }
      }
    }
  }
  if ( module->options )
    unregister_options(module->options, config_options);
}

//----- (080B5700) --------------------------------------------------------
void __cdecl unregister_modules_options(module **modules)
{
  int i; // ebx
  module *v2; // eax
  int v3; // ebx
  module **v4; // esi

  if ( modules )
  {
    if ( *modules )
    {
      for ( i = 0; modules[i + 1]; ++i )
        ;
      if ( i != -1 )
      {
        v2 = modules[i];
        if ( v2 )
        {
          v3 = i - 1;
          v4 = &modules[v3];
          while ( 1 )
          {
            unregister_module_options(v2);
            if ( v3 == -1 )
              break;
            v2 = *v4--;
            if ( !v2 )
              break;
            --v3;
          }
        }
      }
    }
  }
}

//----- (080B5760) --------------------------------------------------------
void __cdecl register_module_options(module *module)
{
  module **submodules; // eax
  module *v2; // eax
  int v3; // ebx

  if ( module->options )
    register_options(module->options, config_options);
  submodules = module->submodules;
  if ( submodules )
  {
    v2 = *submodules;
    if ( v2 )
    {
      v3 = 1;
      do
      {
        register_module_options(v2);
        v2 = module->submodules[v3++];
      }
      while ( v2 );
    }
  }
}

//----- (080B57C0) --------------------------------------------------------
void __cdecl register_modules_options(module **modules)
{
  module **v1; // ebx
  module *i; // eax

  v1 = modules;
  if ( modules )
  {
    for ( i = *modules; i; ++v1 )
    {
      register_module_options(i);
      i = v1[1];
    }
  }
}

//----- (080B57F0) --------------------------------------------------------
int get_file_handles_count()
{
  int v0; // edx
  int result; // eax

  v0 = 0;
  result = 0;
  do
  {
    while ( threads[v0].read_func || *(_DWORD *)(v0 * 16 + 135572036) || *(_DWORD *)(v0 * 16 + 135572040) )
    {
      ++v0;
      ++result;
      if ( v0 == 1024 )
        return result;
    }
    ++v0;
  }
  while ( v0 != 1024 );
  return result;
}

//----- (080B5840) --------------------------------------------------------
int __usercall can_read_or_write@<eax>(int fd@<eax>, int write@<edx>)
{
  fd_set *v3; // eax
  fd_set *p_fds; // ecx
  fd_set fds; // [esp+28h] [ebp-A0h] BYREF
  timeval tv; // [esp+A8h] [ebp-20h] BYREF

  v3 = 0;
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  memset(&fds, 0, sizeof(fds));
  p_fds = 0;
  if ( write )
    p_fds = &fds;
  if ( !write )
    v3 = &fds;
  fds.__fds_bits[fd / 32] |= 1 << (fd % 32);
  return select(fd + 1, v3, p_fds, 0, &tv);
}

//----- (080B58E0) --------------------------------------------------------
int __cdecl can_write(int fd)
{
  return can_read_or_write(fd, 1);
}

//----- (080B5900) --------------------------------------------------------
int __cdecl can_read(int fd)
{
  return can_read_or_write(fd, 0);
}

//----- (080B5920) --------------------------------------------------------
void __cdecl set_handlers(
        int fd,
        select_handler_T read_func,
        select_handler_T write_func,
        select_handler_T error_func,
        void *data)
{
  unsigned int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // eax
  __fd_mask v9; // ebx
  __fd_mask v10; // ecx
  int v11; // ecx
  int v12; // edx
  __fd_mask v13; // ebx
  int v14; // edx

  if ( assert_failed
    || (assert_failed = (unsigned int)fd > 0x3FF) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c",
        errline = 149,
        elinks_internal(
          "assertion fd >= 0 && fd < FD_SETSIZE failed: set_handlers: handle %d >= FD_SETSIZE %d",
          fd,
          1024),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  v5 = 16 * fd;
  threads[v5 / 0x10].read_func = read_func;
  *(_DWORD *)(v5 + 135572036) = write_func;
  *(_DWORD *)(v5 + 135572040) = error_func;
  *(_DWORD *)(v5 + 135572044) = data;
  if ( read_func )
  {
    v6 = fd / 32;
    v7 = 1 << (fd % 32);
    w_read.__fds_bits[fd / 32] |= v7;
    if ( write_func )
      goto LABEL_5;
LABEL_24:
    w_write.__fds_bits[v6] &= ~v7;
    x_write.__fds_bits[v6] &= ~v7;
    if ( error_func )
      goto LABEL_6;
LABEL_25:
    v14 = ~v7;
    w_error.__fds_bits[v6] &= v14;
    x_error.__fds_bits[v6] &= v14;
    goto LABEL_7;
  }
  v7 = 1 << (fd % 32);
  v6 = fd / 32;
  w_read.__fds_bits[v6] &= ~v7;
  x_read.__fds_bits[v6] &= ~v7;
  if ( !write_func )
    goto LABEL_24;
LABEL_5:
  w_write.__fds_bits[v6] |= v7;
  if ( !error_func )
    goto LABEL_25;
LABEL_6:
  w_error.__fds_bits[v6] |= v7;
LABEL_7:
  if ( write_func || read_func || error_func )
  {
    if ( fd >= w_max )
      w_max = fd + 1;
  }
  else if ( w_max - 1 == fd )
  {
    v8 = w_max - 2;
    if ( w_max - 2 >= 0 )
    {
      do
      {
        v11 = v8 >> 5;
        v12 = v8 & 0x1F;
        v13 = w_read.__fds_bits[v8 >> 5];
        if ( _bittest(&v13, v12) )
          break;
        v9 = w_write.__fds_bits[v11];
        if ( _bittest(&v9, v12) )
          break;
        v10 = w_error.__fds_bits[v11];
        if ( _bittest(&v10, v12) )
          break;
        --v8;
      }
      while ( v8 != -1 );
    }
    w_max = v8 + 1;
  }
}

//----- (080B5B30) --------------------------------------------------------
select_handler_T __cdecl get_handler(int fd, select_handler_type tp)
{
  bool v3; // cf

  if ( assert_failed )
    goto LABEL_2;
  assert_failed = (unsigned int)fd > 0x3FF;
  if ( (unsigned int)fd > 0x3FF )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
    errline = 128;
    elinks_internal("assertion fd >= 0 && fd < FD_SETSIZE failed: get_handler: handle %d >= FD_SETSIZE %d", fd, 1024);
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
    v3 = tp == SELECT_HANDLER_READ;
    if ( tp != SELECT_HANDLER_WRITE )
      goto LABEL_5;
    return threads[fd].write_func;
  }
  v3 = tp == SELECT_HANDLER_READ;
  if ( tp == SELECT_HANDLER_WRITE )
    return threads[fd].write_func;
LABEL_5:
  if ( v3 )
    return threads[fd].read_func;
  if ( tp == SELECT_HANDLER_ERROR )
    return threads[fd].error_func;
  if ( tp == SELECT_HANDLER_DATA )
    return (select_handler_T)threads[fd].data;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
  errline = 138;
  elinks_internal("get_handler: bad type %d", tp);
  return 0;
}

//----- (080B5C80) --------------------------------------------------------
void check_bottom_halves()
{
  _DWORD **prev; // eax
  int v1; // esi
  void (__cdecl *v2)(int); // ebx

  while ( bottom_halves.next != &bottom_halves )
  {
    prev = (_DWORD **)bottom_halves.prev;
    v1 = *((_DWORD *)bottom_halves.prev + 3);
    v2 = (void (__cdecl *)(int))*((_DWORD *)bottom_halves.prev + 2);
    *(_DWORD *)(*(_DWORD *)bottom_halves.prev + 4) = *((_DWORD *)bottom_halves.prev + 1);
    *prev[1] = *prev;
    mem_free(prev);
    v2(v1);
  }
}

//----- (080B5CE0) --------------------------------------------------------
void __cdecl select_loop(void (*init)(void))
{
  int next_timer_time; // ebx
  timeval_T *p_t; // eax
  _DWORD *v3; // edx
  int v4; // esi
  int v5; // edi
  __fd_mask v6; // ecx
  int v7; // ebx
  int v8; // eax
  void (__cdecl *v9)(_DWORD); // ecx
  __fd_mask v10; // ecx
  void (__cdecl *v11)(_DWORD); // ecx
  __fd_mask v12; // ecx
  void (__cdecl *v13)(_DWORD); // ecx
  int v14; // ebx
  char *v15; // esi
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  _DWORD *v18; // [esp+24h] [ebp-34h]
  _DWORD *v19; // [esp+24h] [ebp-34h]
  _DWORD *v20; // [esp+24h] [ebp-34h]
  int select_errors; // [esp+28h] [ebp-30h]
  int n; // [esp+2Ch] [ebp-2Ch]
  timeval_T t; // [esp+30h] [ebp-28h] BYREF
  timeval_T last_time; // [esp+38h] [ebp-20h] BYREF

  clear_signal_mask_and_handlers();
  memset(&w_read, 0, sizeof(w_read));
  memset(&w_write, 0, sizeof(w_write));
  memset(&w_error, 0, sizeof(w_error));
  w_max = 0;
  timeval_now(&last_time);
  signal(13, (__sighandler_t)1);
  init();
  check_bottom_halves();
  select_errors = 0;
LABEL_2:
  while ( !program_0.terminate )
  {
    check_signals();
    check_timers(&last_time);
    redraw_all_terminals();
    qmemcpy(&x_read, &w_read, sizeof(x_read));
    qmemcpy(&x_write, &w_write, sizeof(x_write));
    qmemcpy(&x_error, &w_error, sizeof(x_error));
    if ( program_0.terminate )
      break;
    next_timer_time = get_next_timer_time(&t);
    if ( !next_timer_time && !w_max )
      break;
    critical_section = 1;
    if ( !check_signals() )
    {
      p_t = 0;
      if ( next_timer_time )
      {
        timeval_limit_to_zero_or_one(&t);
        p_t = &t;
      }
      n = select(w_max, &x_read, &x_write, &x_error, (struct timeval *)p_t);
      if ( n < 0 )
      {
        v14 = *__errno_location();
        critical_section = 0;
        uninstall_alarm();
        if ( v14 != 4 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
          errline = 279;
          v15 = strerror(v14);
          v16 = gettext("The call to %s failed: %d (%s)");
          elinks_error(v16, "select()", v14, v15);
          if ( ++select_errors > 10 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/select.c";
            errline = 282;
            v17 = gettext("%d select() failures.");
            elinks_internal(v17, select_errors);
          }
        }
      }
      else
      {
        critical_section = 0;
        uninstall_alarm();
        check_signals();
        check_timers(&last_time);
        if ( n && w_max > 0 )
        {
          v3 = (_DWORD *)(threads + 12);
          v4 = 0;
          do
          {
            v5 = v4 / 32;
            v6 = x_read.__fds_bits[v4 / 32];
            v7 = v4 % 32;
            v8 = 0;
            if ( _bittest(&v6, v4 % 32) )
            {
              v9 = (void (__cdecl *)(_DWORD))*(v3 - 3);
              LOBYTE(v8) = 1;
              if ( v9 )
              {
                v18 = v3;
                v9(*v3);
                check_bottom_halves();
                v3 = v18;
                v8 = 1;
              }
            }
            v10 = x_write.__fds_bits[v5];
            if ( _bittest(&v10, v7) )
            {
              v11 = (void (__cdecl *)(_DWORD))*(v3 - 2);
              v8 = 1;
              if ( v11 )
              {
                v19 = v3;
                v11(*v3);
                check_bottom_halves();
                v3 = v19;
                v8 = 1;
              }
            }
            v12 = x_error.__fds_bits[v5];
            if ( _bittest(&v12, v7) )
            {
              v13 = (void (__cdecl *)(_DWORD))*(v3 - 1);
              v8 = 1;
              if ( v13 )
              {
                v20 = v3;
                v13(*v3);
                check_bottom_halves();
                v3 = v20;
                v8 = 1;
              }
            }
            n -= v8;
            if ( !n )
              break;
            ++v4;
            v3 += 4;
          }
          while ( v4 < w_max );
        }
        select_errors = 0;
      }
      goto LABEL_2;
    }
    critical_section = 0;
  }
}

//----- (080B6020) --------------------------------------------------------
int __cdecl register_bottom_half_do(select_handler_T fn, void *data)
{
  select_handler_T *next; // ebx
  int v3; // edx
  void (*v5)(void *); // eax
  select_handler_T v6; // edx

  next = (select_handler_T *)bottom_halves.next;
  if ( bottom_halves.next == &bottom_halves )
  {
LABEL_8:
    v5 = (void (*)(void *))mem_alloc(0x10u);
    v3 = -1;
    if ( !v5 )
      return v3;
    *((_DWORD *)v5 + 2) = fn;
    *((_DWORD *)v5 + 3) = data;
    v6 = *next;
    *((_DWORD *)v5 + 1) = next;
    *(_DWORD *)v5 = v6;
    *next = v5;
    *(_DWORD *)(*(_DWORD *)v5 + 4) = v5;
  }
  else
  {
    while ( next[2] != fn || next[3] != data )
    {
      next = (select_handler_T *)*next;
      if ( next == (select_handler_T *)&bottom_halves )
        goto LABEL_8;
    }
  }
  return 0;
}

//----- (080B60A0) --------------------------------------------------------
int get_timers_count()
{
  list_head_elinks *next; // edx
  int result; // eax

  next = (list_head_elinks *)timers.next;
  for ( result = 0; next != &timers; ++result )
    next = (list_head_elinks *)next->next;
  return result;
}

//----- (080B60D0) --------------------------------------------------------
int __cdecl get_next_timer_time(timeval_T *t)
{
  int result; // eax
  int v2; // ecx

  result = 0;
  if ( timers.next != &timers )
  {
    v2 = *((_DWORD *)timers.next + 3);
    t->sec = *((_DWORD *)timers.next + 2);
    t->usec = v2;
    return 1;
  }
  return result;
}

//----- (080B6100) --------------------------------------------------------
void __cdecl kill_timer(timer_id_T *id)
{
  timer_id_T v1; // eax

  if ( !assert_failed )
  {
    assert_failed = id == 0;
    if ( !id )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
      errline = 107;
      elinks_internal("assertion id != NULL failed!");
    }
  }
  v1 = *id;
  if ( *id )
  {
    v1->next->prev = v1->prev;
    v1->prev->next = v1->next;
    mem_free(v1);
    *id = 0;
  }
}

//----- (080B6180) --------------------------------------------------------
void __cdecl install_timer(timer_id_T *id, milliseconds_T delay, void (*func)(void *), void *data)
{
  timer *v4; // eax
  timer *v5; // edi
  timeval_T *p_interval; // esi
  timeval_T *i; // ebx

  if ( !assert_failed )
  {
    assert_failed = id == 0 || delay <= 0;
    if ( id == 0 || delay <= 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/timer.c";
      errline = 84;
      elinks_internal("assertion id && delay > 0 failed!");
    }
  }
  v4 = (timer *)mem_alloc(0x18u);
  v5 = v4;
  *id = v4;
  if ( v4 )
  {
    p_interval = &v4->interval;
    timeval_from_milliseconds(&v4->interval, delay);
    v5->func = func;
    v5->data = data;
    for ( i = (timeval_T *)timers.next; i != (timeval_T *)&timers; i = (timeval_T *)i->sec )
    {
      if ( timeval_cmp(i + 1, p_interval) >= 0 )
        break;
    }
    v5->next = *(timer **)i->usec;
    v5->prev = (timer *)i->usec;
    *(_DWORD *)i->usec = v5;
    v5->next->prev = v5;
  }
}

//----- (080B6260) --------------------------------------------------------
void __cdecl check_timers(timeval_T *last_time)
{
  timeval_T *next; // ebx
  timeval_T *i; // ebx
  int usec; // edx
  timeval_T interval; // [esp+10h] [ebp-28h] BYREF
  timeval_T now; // [esp+18h] [ebp-20h] BYREF

  timeval_now(&now);
  timeval_sub(&interval, last_time, &now);
  next = (timeval_T *)timers.next;
  if ( timers.next != &timers )
  {
    do
    {
      timeval_sub_interval(next + 1, &interval);
      next = (timeval_T *)next->sec;
    }
    while ( next != (timeval_T *)&timers );
    for ( i = (timeval_T *)timers.next; timers.next != &timers; i = (timeval_T *)timers.next )
    {
      if ( timeval_is_positive(i + 1) )
        break;
      *(_DWORD *)(i->sec + 4) = i->usec;
      *(_DWORD *)i->usec = i->sec;
      ((void (__cdecl *)(int))i[2].sec)(i[2].usec);
      mem_free(i);
      check_bottom_halves();
    }
  }
  usec = now.usec;
  last_time->sec = now.sec;
  last_time->usec = usec;
}

//----- (080B6320) --------------------------------------------------------
void __usercall add_module_to_string(string *string@<eax>, module *module@<edx>, terminal *term@<ecx>)
{
  unsigned __int8 *name; // ebx
  int terminal_codepage; // eax
  int v6; // esi
  unsigned __int8 *cp_mime_name; // eax
  module **submodules; // eax
  module *v9; // esi
  int v10; // ebx

  name = module->name;
  if ( module->name )
  {
    if ( *name )
    {
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        v6 = terminal_codepage;
        if ( terminal_codepage != current_charset )
        {
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v6;
        }
      }
      name = gettext(name);
    }
    add_to_string(string, name);
  }
  if ( module->submodules )
  {
    add_to_string(string, " (");
    submodules = module->submodules;
    if ( submodules )
    {
      v9 = *submodules;
      if ( *submodules )
      {
        v10 = 0;
        while ( 1 )
        {
          ++v10;
          add_module_to_string(string, v9, term);
          v9 = module->submodules[v10];
          if ( !v9 )
            break;
          if ( v10 )
            add_to_string(string, ", ");
        }
      }
    }
    add_to_string(string, &byte_812757C);
  }
}

//----- (080B6410) --------------------------------------------------------
unsigned __int8 *__cdecl get_dyn_full_version(terminal *term, int more)
{
  unsigned __int8 *v2; // ebx
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // ebx
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v7; // eax
  int v8; // eax
  int v9; // ebx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // ebx
  int v12; // eax
  int v13; // esi
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // eax
  int v16; // ebx
  module *v17; // esi
  unsigned __int8 *result; // eax
  unsigned __int8 *source; // ebx
  int v20; // esi
  char *v21; // eax
  const char *v22; // esi
  char *v23; // ebx
  const char *v24; // edx
  char *v25; // eax
  int v26; // eax
  int v27; // ebx
  unsigned __int8 *v28; // eax
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // [esp+10h] [ebp-68h]
  int v31; // [esp+4Ch] [ebp-2Ch]
  string string; // [esp+58h] [ebp-20h] BYREF

  v2 = 0;
  if ( !init_string(&string) )
    return v2;
  add_format_to_string(&string, "ELinks %s", "0.12pre5");
  if ( *build_id )
  {
    add_char_to_string(&string, more == 0 ? 32 : 10);
    add_format_to_string(&string, "%s", (const char *)build_id);
  }
  add_char_to_string(&string, 0xAu);
  v3 = build_time;
  v4 = build_date;
  if ( term )
  {
    terminal_codepage = get_terminal_codepage(term);
    if ( terminal_codepage != current_charset )
    {
      v31 = terminal_codepage;
      cp_mime_name = get_cp_mime_name(terminal_codepage);
      bind_textdomain_codeset("elinks", cp_mime_name);
      current_charset = v31;
    }
  }
  v7 = gettext(&byte_8131601);
  add_format_to_string(&string, v7, v4, v3);
  if ( more )
  {
    add_to_string(&string, &ptr);
    if ( term )
    {
      v26 = get_terminal_codepage(term);
      v27 = v26;
      if ( v26 != current_charset )
      {
        v28 = get_cp_mime_name(v26);
        bind_textdomain_codeset("elinks", v28);
        current_charset = v27;
      }
    }
    v29 = gettext(&byte_8131610);
    add_to_string(&string, v29);
  }
  if ( term )
  {
    v8 = get_terminal_codepage(term);
    v9 = v8;
    if ( v8 != current_charset )
    {
      v10 = get_cp_mime_name(v8);
      bind_textdomain_codeset("elinks", v10);
      current_charset = v9;
    }
  }
  v11 = gettext(&byte_8131621);
  if ( term )
  {
    v12 = get_terminal_codepage(term);
    v13 = v12;
    if ( v12 != current_charset )
    {
      v14 = get_cp_mime_name(v12);
      bind_textdomain_codeset("elinks", v14);
      current_charset = v13;
    }
  }
  v15 = gettext(&byte_813162A);
  v30 = v11;
  v16 = 0;
  string_concat(
    &string,
    &ptr,
    v15,
    "\n",
    v30,
    comma_6159,
    "IPv6",
    comma_6159,
    "gzip",
    comma_6159,
    "bzip2",
    comma_6159,
    "UTF-8",
    comma_6159,
    0);
  v17 = builtin_modules[0];
  if ( builtin_modules[0] )
  {
    while ( 1 )
    {
      ++v16;
      add_module_to_string(&string, v17, term);
      v17 = builtin_modules[v16];
      if ( !v17 )
        break;
      if ( v16 )
        add_to_string(&string, ", ");
    }
  }
  if ( more )
    return string.source;
  source = string.source;
  v20 = 0;
  v21 = strrchr((const char *)string.source, 10);
  if ( v21 )
    v20 = v21 - (char *)source + 1;
  if ( !assert_failed )
  {
    if ( source && v20 < string.length )
    {
      assert_failed = 0;
      goto LABEL_27;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/main/version.c";
    errline = 67;
    elinks_internal("assertion string && string->source && start_at < string->length failed!");
    if ( !assert_failed )
    {
      source = string.source;
LABEL_27:
      v22 = (const char *)&source[v20];
      v23 = 0;
      v24 = v22;
      while ( 1 )
      {
        v25 = strchr(v24, 32);
        if ( !v25 )
          break;
        if ( v25 - v22 <= 71 )
        {
          v24 = v25 + 1;
        }
        else
        {
          if ( v23 )
            *v23 = 10;
          v24 = v23 + 1;
          v25 = v23;
          v22 = v23 + 1;
        }
        if ( !*v24 )
          break;
        v23 = v25;
      }
      return string.source;
    }
    source = string.source;
  }
  result = source;
  assert_failed = 0;
  return result;
}

//----- (080B67E0) --------------------------------------------------------
void init_static_version()
{
  unsigned __int8 *dyn_full_version; // eax
  unsigned __int8 *v1; // ebx

  dyn_full_version = get_dyn_full_version(0, 0);
  v1 = dyn_full_version;
  if ( dyn_full_version )
  {
    safe_strncpy(full_static_version, dyn_full_version, 0x400u);
    mem_free(v1);
  }
}

//----- (080B6830) --------------------------------------------------------
void __cdecl menu_list_ext(terminal *term, void *fn_, void *xxx)
{
  int number; // eax
  int v4; // ebx
  char *v5; // esi
  int v6; // eax
  unsigned __int8 *v7; // esi
  unsigned __int8 *v8; // eax
  menu_item *v9; // eax
  list_head_elinks *opt_tree; // [esp+2Ch] [ebp-2Ch]
  string translated; // [esp+34h] [ebp-24h] BYREF
  menu_item *mi; // [esp+3Ch] [ebp-1Ch] BYREF

  number = get_opt_(config_options, "mime.extension")->number;
  mi = 0;
  opt_tree = (list_head_elinks *)number;
  v4 = *(_DWORD *)(number + 4);
  if ( v4 != number )
  {
    while ( 1 )
    {
      while ( !strcmp(*(const char **)(v4 + 12), "_template_") )
      {
LABEL_3:
        v4 = *(_DWORD *)(v4 + 4);
        if ( (list_head_elinks *)v4 == opt_tree )
          goto LABEL_12;
      }
      if ( !init_string(&translated)
        || (v5 = *(char **)(v4 + 12),
            v6 = strlen(v5),
            !add_string_replace(&translated, (unsigned __int8 *)v5, v6, 0x2Au, 0x2Eu)) )
      {
        done_string(&translated);
        goto LABEL_3;
      }
      if ( !mi )
      {
        mi = new_menu(NO_INTL|FREE_DATA|FREE_RTEXT|FREE_TEXT|FREE_LIST);
        if ( !mi )
        {
          done_string(&translated);
          return;
        }
      }
      v7 = memacpy(translated.source, translated.length);
      v8 = stracpy(*(const unsigned __int8 **)(v4 + 32));
      if ( !v8 )
      {
        if ( v7 )
          mem_free(v7);
        goto LABEL_11;
      }
      if ( v7 )
      {
        add_to_menu(&mi, translated.source, v8, ACT_MAIN_NONE, (menu_func_T)fn_, v7, NO_FLAG);
        goto LABEL_3;
      }
      mem_free(v8);
LABEL_11:
      done_string(&translated);
      v4 = *(_DWORD *)(v4 + 4);
      if ( (list_head_elinks *)v4 == opt_tree )
      {
LABEL_12:
        v9 = mi;
        if ( !mi )
          break;
        goto LABEL_13;
      }
    }
  }
  mi = mi_no_ext;
  v9 = mi_no_ext;
LABEL_13:
  do_menu(term, v9, 0, 0);
}

//----- (080B6A00) --------------------------------------------------------
option_elinks *__usercall get_real_opt@<eax>(unsigned __int8 *base@<eax>, unsigned __int8 *id@<edx>)
{
  option_elinks *opt_rec_real; // esi
  int v4; // eax
  string translated; // [esp+28h] [ebp-20h] BYREF

  opt_rec_real = get_opt_rec_real(config_options, base);
  if ( !assert_failed )
  {
    assert_failed = opt_rec_real == 0;
    if ( !opt_rec_real )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/dialogs.c";
      errline = 29;
      elinks_internal("assertion opt failed!");
    }
  }
  if ( init_string(&translated) )
  {
    v4 = strlen((const char *)id);
    if ( add_string_replace(&translated, id, v4, 0x2Eu, 0x2Au) )
      opt_rec_real = get_opt_rec_real(opt_rec_real, translated.source);
  }
  done_string(&translated);
  return opt_rec_real;
}

//----- (080B6AD0) --------------------------------------------------------
void __cdecl really_del_ext(void *fcp)
{
  option_elinks *real_opt; // eax

  real_opt = get_real_opt("mime.extension", (unsigned __int8 *)fcp);
  if ( real_opt )
    delete_option(real_opt);
}

//----- (080B6B00) --------------------------------------------------------
void __cdecl add_mime_extension(void *data)
{
  int v1; // eax
  option_value *opt; // eax
  option_elinks *opt_rec; // eax
  string name; // [esp+28h] [ebp-20h] BYREF

  if ( data )
  {
    if ( init_string(&name) )
    {
      add_to_string(&name, "mime.extension.");
      v1 = strlen((const char *)data + 1024);
      add_string_replace(&name, (unsigned __int8 *)data + 1024, v1, 0x2Eu, 0x2Au);
      really_del_ext(data);
      opt = get_opt_(config_options, name.source);
      safe_strncpy(opt->string, (const unsigned __int8 *)data + 2048, 0x400u);
      opt_rec = get_opt_rec(config_options, name.source);
      option_changed(0, opt_rec);
      done_string(&name);
    }
  }
}

//----- (080B6BE0) --------------------------------------------------------
void __cdecl menu_del_ext(terminal *term, void *fcp, void *xxx2)
{
  option_elinks *real_opt; // eax
  unsigned __int8 *v4; // edi
  memory_list *v5; // eax

  if ( fcp )
  {
    real_opt = get_real_opt("mime.extension", (unsigned __int8 *)fcp);
    if ( real_opt )
    {
      v4 = msg_text(term, "Delete extension %s -> %s?", (const char *)fcp, (const char *)real_opt->value.tree);
      v5 = getml(fcp, 0);
      msg_box(
        term,
        v5,
        MSGBOX_FREE_TEXT,
        "Delete extension",
        ALIGN_CENTER,
        v4,
        fcp,
        2,
        "~Yes",
        really_del_ext,
        1,
        "~No",
        0,
        2);
    }
    else
    {
      mem_free(fcp);
    }
  }
}

//----- (080B6CD0) --------------------------------------------------------
void __cdecl menu_add_ext(terminal *term, void *fcp, void *xxx2)
{
  char *v3; // eax
  unsigned __int8 *v4; // ebx
  option_elinks *real_opt; // edx
  int terminal_codepage; // eax
  int v7; // edi
  unsigned __int8 *cp_mime_name; // eax
  int v9; // eax
  int v10; // edi
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // eax
  int v13; // eax
  int v14; // edi
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  int v17; // eax
  int v18; // edi
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // eax
  int v22; // edi
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // eax
  bool v25; // zf
  memory_list *v26; // eax
  option_elinks *v27; // [esp+38h] [ebp-20h]
  extension *newa; // [esp+3Ch] [ebp-1Ch]

  v3 = (char *)mem_calloc(1u, 0xCE4u);
  v4 = (unsigned __int8 *)v3;
  if ( v3 )
  {
    newa = (extension *)(v3 + 228);
    if ( fcp )
    {
      real_opt = get_real_opt("mime.extension", (unsigned __int8 *)fcp);
      if ( real_opt )
      {
        v27 = real_opt;
        safe_strncpy(v4 + 1252, (const unsigned __int8 *)fcp, 0x400u);
        safe_strncpy(v4 + 2276, v27->value.string, 0x400u);
        safe_strncpy(newa->ext_orig, (const unsigned __int8 *)fcp, 0x400u);
      }
      mem_free(fcp);
    }
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v7 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v7;
      }
    }
    *(_DWORD *)v4 = gettext(&byte_813169A);
    *((_DWORD *)v4 + 4) = generic_dialog_layouter;
    if ( term )
    {
      v9 = get_terminal_codepage(term);
      v10 = v9;
      if ( v9 != current_charset )
      {
        v11 = get_cp_mime_name(v9);
        bind_textdomain_codeset("elinks", v11);
        current_charset = v10;
      }
    }
    v12 = gettext(&byte_81316A4);
    add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v12, 0, 0, check_nonempty, 1024, newa->ext, 0, INPFIELD_NONE);
    if ( term )
    {
      v13 = get_terminal_codepage(term);
      v14 = v13;
      if ( v13 != current_charset )
      {
        v15 = get_cp_mime_name(v13);
        bind_textdomain_codeset("elinks", v15);
        current_charset = v14;
      }
    }
    v16 = gettext(&byte_812C04C);
    add_dlg_field_do((dialog *)v4, WIDGET_FIELD, v16, 0, 0, check_nonempty, 1024, newa->ct, 0, INPFIELD_NONE);
    if ( term )
    {
      v17 = get_terminal_codepage(term);
      v18 = v17;
      if ( v17 != current_charset )
      {
        v19 = get_cp_mime_name(v17);
        bind_textdomain_codeset("elinks", v19);
        current_charset = v18;
      }
    }
    v20 = gettext(&okbutton);
    add_dlg_button_do((dialog *)v4, v20, 1, ok_dialog, 0, add_mime_extension, newa);
    if ( term )
    {
      v21 = get_terminal_codepage(term);
      v22 = v21;
      if ( v21 != current_charset )
      {
        v23 = get_cp_mime_name(v21);
        bind_textdomain_codeset("elinks", v23);
        current_charset = v22;
      }
    }
    v24 = gettext(&cancelbutton);
    add_dlg_button_do((dialog *)v4, v24, 2, cancel_dialog, 0, 0, 0);
    if ( !assert_failed )
    {
      v25 = *((_DWORD *)v4 + 8) == 4;
      assert_failed = *((_DWORD *)v4 + 8) != 4;
      if ( !v25 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/dialogs.c";
        errline = 135;
        elinks_internal("assertion 4 == (dlg)->number_of_widgets failed!");
      }
    }
    v26 = getml(v4, 0);
    do_dialog(term, (dialog *)v4, v26);
  }
  else if ( fcp )
  {
    mem_free(fcp);
  }
}

//----- (080B70A0) --------------------------------------------------------
unsigned __int8 *__usercall get_content_filename@<eax>(uri *uri@<eax>, cache_entry *cached@<edx>)
{
  unsigned __int8 *head; // eax
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v5; // ebx
  int v6; // eax
  unsigned __int8 *v7; // edx
  unsigned __int8 *filename_position; // eax
  unsigned __int8 *v9; // esi
  size_t v10; // eax
  unsigned __int8 *v11; // [esp+0h] [ebp-28h]
  unsigned __int8 *filename; // [esp+1Ch] [ebp-Ch] BYREF

  if ( !cached )
  {
    cached = find_in_cache(uri);
    if ( !cached )
      return 0;
  }
  head = cached->head;
  if ( !head )
    return 0;
  v5 = parse_header(head, "Content-Disposition", 0);
  if ( !v5 )
    return 0;
  parse_header_param_0(v5, "filename", &filename);
  mem_free(v5);
  v3 = filename;
  if ( filename )
  {
    if ( *filename != 34 )
      goto LABEL_12;
    v6 = strlen((const char *)filename);
    if ( v6 > 1 )
    {
      v7 = &v3[v6 - 1];
      if ( *v7 == 34 )
      {
        *v7 = 0;
        memmove(filename, filename + 1, v6);
        v3 = filename;
      }
    }
    if ( !v3[1] )
    {
      v11 = v3;
      v3 = 0;
      mem_free(v11);
    }
    else
    {
LABEL_12:
      filename_position = get_filename_position(v3);
      v9 = filename_position;
      if ( *filename_position )
      {
        v3 = filename;
        if ( filename_position > filename )
        {
          v10 = strlen((const char *)filename_position);
          memmove(v3, v9, v10 + 1);
          return filename;
        }
      }
      else
      {
        v3 = 0;
        mem_free(filename);
      }
    }
  }
  return v3;
}

//----- (080B71D0) --------------------------------------------------------
string *__cdecl add_mime_filename_to_string(string *string, uri *uri)
{
  string *v2; // ebx
  char *content_filename; // edi
  unsigned __int8 *data; // edx
  int v5; // eax

  v2 = string;
  content_filename = (char *)get_content_filename(uri, 0);
  if ( !assert_failed )
  {
    data = uri->data;
    assert_failed = data == 0;
    if ( !data )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/mime.c";
      errline = 331;
      elinks_internal("assertion uri->data failed!");
    }
  }
  if ( !content_filename )
    return add_uri_to_string(string, uri, URI_FILENAME);
  v5 = strlen(content_filename);
  add_shell_safe_to_string(string, (unsigned __int8 *)content_filename, v5);
  mem_free(content_filename);
  return v2;
}

//----- (080B7280) --------------------------------------------------------
mime_handler *__cdecl get_mime_type_handler(unsigned __int8 *content_type, int xwin)
{
  return get_mime_handler_backends(content_type, xwin);
}

//----- (080B7290) --------------------------------------------------------
unsigned __int8 *__cdecl get_extension_content_type(unsigned __int8 *extension)
{
  unsigned __int8 *content_type_backends; // esi
  unsigned __int8 *v2; // edi
  stream_encoding v4; // edi
  char *v5; // eax
  unsigned __int8 *v6; // eax
  mime_handler *mime_handler_backends; // eax
  const char **v8; // edi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // [esp+0h] [ebp-38h]
  char *s2; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
  {
    if ( extension && *extension )
    {
      assert_failed = 0;
      content_type_backends = get_content_type_backends(extension);
      if ( content_type_backends )
        return content_type_backends;
      goto LABEL_9;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/mime/mime.c";
    errline = 179;
    elinks_internal("assertion extension && *extension failed!");
  }
  content_type_backends = get_content_type_backends(extension);
  if ( content_type_backends )
    return content_type_backends;
LABEL_9:
  v4 = guess_encoding(extension);
  v5 = strrchr((const char *)extension, 46);
  s2 = v5;
  if ( !v5 )
    return content_type_backends;
  if ( v4 )
  {
    v8 = (const char **)listext_encoded(v4);
    if ( v8 )
    {
      while ( *v8 )
      {
        if ( !strcmp(*v8, s2) )
        {
          *s2 = 0;
          v9 = get_content_type_backends(extension);
          *s2 = 46;
          v2 = v9;
          if ( v9 )
            return v2;
          break;
        }
        if ( !++v8 )
          break;
      }
    }
    v5 = strrchr((const char *)extension, 46);
  }
  if ( !v5 )
    return content_type_backends;
  v6 = straconcat("application/x-", v5 + 1, 0);
  v2 = v6;
  if ( v6 )
  {
    mime_handler_backends = get_mime_handler_backends(v6, 1);
    if ( mime_handler_backends )
    {
      mem_free(mime_handler_backends);
    }
    else
    {
      v10 = v2;
      v2 = 0;
      mem_free(v10);
    }
  }
  return v2;
}

//----- (080B7400) --------------------------------------------------------
unsigned __int8 *__cdecl get_cache_header_content_type(cache_entry *cached)
{
  unsigned __int8 *v1; // eax
  char *v2; // eax
  size_t v3; // eax
  size_t v4; // edx
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // eax
  unsigned __int8 v7; // di
  unsigned __int8 *content_filename; // eax
  unsigned __int8 *v10; // esi
  unsigned __int8 *ctype; // [esp+1Ch] [ebp-1Ch]

  v1 = parse_header(cached->head, (unsigned __int8 *)&byte_812C04C, 0);
  ctype = v1;
  if ( !v1 )
  {
LABEL_12:
    content_filename = get_content_filename(cached->uri, cached);
    ctype = 0;
    v10 = content_filename;
    if ( content_filename )
    {
      ctype = get_extension_content_type(content_filename);
      mem_free(v10);
    }
    return ctype;
  }
  v2 = strchr((const char *)v1, 59);
  if ( v2 )
    *v2 = 0;
  v3 = strlen((const char *)ctype);
  if ( v3 )
  {
    v4 = v3 - 1;
    v5 = &ctype[v3 - 1];
    if ( *v5 <= 0x20u )
    {
      v6 = &ctype[v3 - 2];
      do
      {
        *v5 = 0;
        if ( !v4 )
          break;
        v7 = *v6;
        --v4;
        v5 = v6--;
      }
      while ( v7 <= 0x20u );
    }
  }
  if ( !*ctype )
  {
    mem_free(ctype);
    goto LABEL_12;
  }
  return ctype;
}

//----- (080B74D0) --------------------------------------------------------
unsigned __int8 *__cdecl get_content_type(cache_entry *cached)
{
  unsigned __int8 *result; // eax
  unsigned __int8 *extension_from_uri; // eax
  size_t v3; // eax
  int v4; // esi
  unsigned __int8 *v5; // ebx
  list_head_elinks *next; // eax
  int v7; // edx
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // ebx
  unsigned __int8 *p; // [esp+18h] [ebp-20h]
  unsigned __int8 *pa; // [esp+18h] [ebp-20h]
  unsigned __int8 *extension; // [esp+1Ch] [ebp-1Ch]

  result = cached->content_type;
  if ( !result )
  {
    if ( cached->head )
    {
      result = get_cache_header_content_type(cached);
      if ( result )
      {
        if ( *result )
          goto LABEL_18;
        mem_free(result);
      }
    }
    extension_from_uri = get_extension_from_uri(cached->uri);
    extension = extension_from_uri;
    if ( extension_from_uri )
    {
      v3 = strlen((const char *)extension_from_uri);
      v4 = v3 - 1;
      if ( (int)(v3 - 1) >= 0 )
      {
        v5 = &extension[v3];
        do
        {
          while ( !c_isupper(*(v5 - 1)) )
          {
            --v5;
            if ( --v4 < 0 )
              goto LABEL_12;
          }
          *(v5 - 1) = c_tolower(*(v5 - 1));
          --v5;
          --v4;
        }
        while ( v4 >= 0 );
      }
LABEL_12:
      p = get_extension_content_type(extension);
      mem_free(extension);
      result = p;
      if ( p )
      {
        if ( *p )
          goto LABEL_18;
        mem_free(p);
      }
    }
    next = (list_head_elinks *)cached->frag.next;
    if ( next != &cached->frag && !*(_QWORD *)&next[1] )
    {
      v7 = (int)next[2].next;
      if ( *(_QWORD *)&next[2] > 1024 )
        v7 = 1024;
      v8 = memacpy((const unsigned __int8 *)&next[4], v7);
      v9 = v8;
      if ( v8 )
      {
        if ( c_strcasestr((const char *)v8, "<html>") )
        {
          pa = stracpy("text/html");
          mem_free(v9);
          result = pa;
          if ( pa && *pa )
            goto LABEL_18;
        }
        else
        {
          mem_free(v9);
        }
      }
    }
    result = stracpy(mime_options_0[1].option_elinks.value.string);
LABEL_18:
    cached->content_type = result;
  }
  return result;
}

//----- (080B7660) --------------------------------------------------------
unsigned __int8 *__cdecl get_content_type_backends(unsigned __int8 *extension)
{
  unsigned __int8 *result; // eax
  int v2; // ebx
  int (__cdecl *v3)(unsigned __int8 *); // eax

  result = (unsigned __int8 *)&default_mime_backend;
  v2 = 0;
  do
  {
    v3 = *(int (__cdecl **)(unsigned __int8 *))result;
    if ( v3 )
    {
      result = (unsigned __int8 *)v3(extension);
      if ( result )
        break;
    }
    result = (unsigned __int8 *)mime_backends[++v2];
  }
  while ( result );
  return result;
}

//----- (080B76A0) --------------------------------------------------------
mime_handler *__cdecl get_mime_handler_backends(unsigned __int8 *ctype, int have_x)
{
  mime_handler *result; // eax
  int v3; // ebx
  unsigned __int8 *backend_name; // eax

  result = (mime_handler *)&default_mime_backend;
  v3 = 0;
  do
  {
    backend_name = result->backend_name;
    if ( backend_name )
    {
      result = (mime_handler *)((int (__cdecl *)(unsigned __int8 *, int))backend_name)(ctype, have_x);
      if ( result )
        break;
    }
    result = (mime_handler *)mime_backends[++v3];
  }
  while ( result );
  return result;
}

//----- (080B76F0) --------------------------------------------------------
mime_handler *__cdecl init_mime_handler(
        unsigned __int8 *program,
        unsigned __int8 *description,
        unsigned __int8 *backend_name,
        int ask,
        int block)
{
  unsigned __int8 *v5; // esi
  mime_handler *v6; // eax
  mime_handler *v7; // ebx
  size_t n; // [esp+1Ch] [ebp-1Ch]

  v5 = description;
  n = strlen((const char *)program);
  v6 = (mime_handler *)mem_calloc(1u, n + 12);
  v7 = v6;
  if ( v6 )
  {
    memcpy(v6->program, program, n);
    if ( !description )
      v5 = (unsigned __int8 *)&delete;
    v7->description = v5;
    v7->backend_name = backend_name;
    *((_BYTE *)v7 + 8) = ask & 1 | (2 * (block & 1)) | *((_BYTE *)v7 + 8) & 0xFC;
  }
  return v7;
}

//----- (080B7780) --------------------------------------------------------
unsigned __int8 *__cdecl get_next_path_filename(unsigned __int8 **path_ptr, unsigned __int8 separator)
{
  unsigned __int8 *v2; // ebx
  unsigned __int8 v3; // di
  unsigned __int8 *v4; // eax
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // ebx
  int filenamelen; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v9; // [esp+2Ch] [ebp-1Ch]

  v2 = *path_ptr;
  v3 = **path_ptr;
  v4 = *path_ptr;
  filenamelen = 0;
  if ( v3 )
  {
    if ( v3 != separator )
    {
      do
      {
        if ( !*++v4 )
        {
          filenamelen = v4 - v2;
          goto LABEL_7;
        }
      }
      while ( *v4 != separator );
      filenamelen = v4 - v2;
    }
    *path_ptr = v4 + 1;
    if ( filenamelen <= 0 )
      return 0;
  }
  else
  {
LABEL_7:
    *path_ptr = v4;
    if ( filenamelen <= 0 )
      return 0;
  }
  v6 = memacpy(v2, filenamelen);
  v7 = v6;
  if ( !v6 )
    return 0;
  v9 = expand_tilde(v6);
  mem_free(v7);
  return v9;
}

//----- (080B7820) --------------------------------------------------------
mime_handler *__cdecl get_mime_handler_default(unsigned __int8 *type, int have_x)
{
  option_elinks *opt_rec_real; // ebx
  int v4; // eax
  char *v5; // eax
  option_elinks *v6; // esi
  option_elinks *v7; // eax
  option_elinks *v8; // ebx
  unsigned __int8 *system_str; // eax
  option_elinks *v10; // eax
  option_elinks *v11; // ebx
  option_value *opt; // eax
  unsigned __int8 *v13; // esi
  int number; // edi
  option_value *v15; // eax
  unsigned __int8 *backend_name; // [esp+28h] [ebp-30h]
  int block; // [esp+2Ch] [ebp-2Ch]
  string string; // [esp+38h] [ebp-20h] BYREF

  opt_rec_real = get_opt_rec_real(config_options, "mime.type");
  if ( !opt_rec_real || !init_string(&string) )
    return 0;
  v4 = strlen((const char *)type);
  if ( add_string_replace(&string, type, v4, 0x2Eu, 0x2Au) )
  {
    v5 = strchr((const char *)string.source, 47);
    if ( v5 )
    {
      *v5 = 46;
      v6 = get_opt_rec_real(opt_rec_real, string.source);
      done_string(&string);
      if ( v6 )
      {
        if ( !assert_failed )
          assert_failed = 0;
        v7 = get_opt_rec_real(config_options, "mime.handler");
        if ( v7 )
        {
          v8 = get_opt_rec_real(v7, v6->value.string);
          if ( v8 )
          {
            system_str = get_system_str(have_x);
            v10 = get_opt_rec_real(v8, system_str);
            v11 = v10;
            if ( v10 )
            {
              block = get_opt_(v10, (unsigned __int8 *)"block")->number;
              opt = get_opt_(v11, "ask");
              v13 = v6->value.string;
              number = opt->number;
              backend_name = default_mime_module.name;
              v15 = get_opt_(v11, "program");
              return init_mime_handler(v15->string, v13, backend_name, number, block);
            }
          }
        }
      }
      return 0;
    }
  }
  done_string(&string);
  return 0;
}

//----- (080B79C0) --------------------------------------------------------
unsigned __int8 *__cdecl get_content_type_default(unsigned __int8 *extension)
{
  option_elinks **tree; // eax
  const char *name; // esi
  const char *v4; // edx
  unsigned __int8 *v5; // eax
  int v6; // ecx
  option_elinks **v7; // [esp+14h] [ebp-24h]
  option_elinks *opt; // [esp+18h] [ebp-20h]
  unsigned __int8 *extend; // [esp+1Ch] [ebp-1Ch]

  extend = &extension[strlen((const char *)extension) - 1];
  if ( extension <= extend )
  {
    tree = (option_elinks **)get_opt_rec_real(config_options, "mime.extension")->value.tree;
    v7 = tree;
    while ( 1 )
    {
      opt = *tree;
      if ( *tree == (option_elinks *)v7 )
        return 0;
      name = (const char *)opt->name;
      v4 = &name[strlen(name) - 1];
      v5 = extend;
      if ( name <= v4 )
      {
        while ( 1 )
        {
          v6 = 46;
          if ( *v4 != 42 )
            v6 = *(unsigned __int8 *)v4;
          if ( *v5 != v6 )
            break;
          --v5;
          --v4;
          if ( extension > v5 )
            break;
          if ( name > v4 )
            goto LABEL_13;
        }
        if ( name <= v4 )
          goto LABEL_15;
      }
      else
      {
        v5 = extend;
      }
LABEL_13:
      if ( v5 < extension || *v5 == 46 )
        return stracpy(opt->value.string);
LABEL_15:
      tree = &opt->next;
    }
  }
  return 0;
}

//----- (080B7A90) --------------------------------------------------------
void __usercall done_mailcap_entry(mailcap_entry *entry@<eax>)
{
  unsigned __int8 *testcommand; // eax

  if ( entry )
  {
    testcommand = entry->testcommand;
    if ( testcommand )
      mem_free(testcommand);
    if ( entry->description )
      mem_free(entry->description);
    mem_free(entry);
  }
}

//----- (080B7AD0) --------------------------------------------------------
void __cdecl init_mailcap(module *module)
{
  register_change_hooks(mimetypes_change_hooks_7155);
  if ( get_opt_(cmdline_options, "anonymous")->number )
    mailcap_options[1].option_elinks.value.number = 0;
}

//----- (080B7B10) --------------------------------------------------------
const char *__usercall get_mailcap_field@<eax>(unsigned __int8 **next@<eax>)
{
  const char *v1; // ebx
  const unsigned __int16 **v3; // esi
  char v4; // dl
  char *i; // eax
  const char *v6; // edx
  unsigned __int8 *v7; // eax
  int v8; // ecx

  v1 = 0;
  if ( !next )
    return v1;
  v1 = (const char *)*next;
  if ( !*next )
    return v1;
  v3 = __ctype_b_loc();
  while ( 1 )
  {
    v4 = *v1;
    if ( ((*v3)[*(unsigned __int8 *)v1] & 0x2000) == 0 )
      break;
    ++v1;
  }
  for ( i = (char *)v1; ; v4 = *i )
  {
    i = strchr(&i[v4 == 59], 59);
    if ( !i )
    {
      *next = 0;
      v6 = &v1[strlen(v1) - 1];
      goto LABEL_14;
    }
    v6 = i - 1;
    if ( *(i - 1) != 92 )
      break;
  }
  *i = 0;
  *next = (unsigned __int8 *)(i + 1);
  if ( ((*v3)[(unsigned __int8)i[1]] & 0x2000) != 0 )
  {
    v7 = (unsigned __int8 *)(i + 2);
    do
    {
      *next = v7;
      v8 = *v7++;
    }
    while ( ((*v3)[v8] & 0x2000) != 0 );
  }
LABEL_14:
  if ( v6 < v1 )
    return v1;
  while ( ((*v3)[*(unsigned __int8 *)v6] & 0x2000) != 0 )
  {
    *v6-- = 0;
    if ( v1 > v6 )
      return v1;
  }
  return v1;
}

//----- (080B7C10) --------------------------------------------------------
unsigned __int8 *__usercall get_mailcap_field_text@<eax>(unsigned __int8 *field@<eax>)
{
  const unsigned __int16 *v2; // ecx
  unsigned __int8 *result; // eax
  const unsigned __int8 *i; // eax

  v2 = *__ctype_b_loc();
  while ( (v2[*field] & 0x2000) != 0 )
    ++field;
  result = 0;
  if ( *field == 61 )
  {
    for ( i = field + 1; (v2[*i] & 0x2000) != 0; ++i )
      ;
    return stracpy(i);
  }
  return result;
}

//----- (080B7C80) --------------------------------------------------------
unsigned __int8 *__usercall format_command@<eax>(
        unsigned __int8 *command@<eax>,
        unsigned __int8 *type@<edx>,
        int copiousoutput@<ecx>)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  int v6; // eax
  unsigned __int8 *v7; // esi
  int v8; // edi
  int v9; // ecx
  unsigned int v10; // eax
  size_t v11; // edx
  unsigned __int8 v12; // al
  unsigned __int8 *v13; // esi
  unsigned __int8 *v14; // ebx
  unsigned __int8 v15; // al
  unsigned __int8 *v16; // eax
  const unsigned __int8 *v17; // ebx
  size_t v18; // [esp+1Ch] [ebp-3Ch]
  int v19; // [esp+20h] [ebp-38h]
  int v20; // [esp+20h] [ebp-38h]
  unsigned int v23; // [esp+2Ch] [ebp-2Ch]
  string cmd; // [esp+38h] [ebp-20h] BYREF

  inited = init_string(&cmd);
  result = 0;
  if ( !inited )
    return result;
LABEL_2:
  LOBYTE(v6) = *command;
  while ( (_BYTE)v6 )
  {
    if ( (_BYTE)v6 == 37 )
      goto LABEL_23;
    if ( (_BYTE)v6 == 92 )
      goto LABEL_30;
    v7 = command;
    if ( (_BYTE)v6 == 39 )
    {
LABEL_36:
      if ( !memcmp(++command, "%s'", 3u) )
      {
        command += 3;
        add_char_to_string(&cmd, 0x25u);
      }
      else
      {
        add_char_to_string(&cmd, 0x27u);
      }
      LOBYTE(v6) = *command;
    }
    else
    {
      do
        LOBYTE(v6) = *++v7;
      while ( *v7 != 37 && (_BYTE)v6 && (_BYTE)v6 != 92 && (_BYTE)v6 != 39 );
      if ( command >= v7 )
        goto LABEL_22;
      if ( !assert_failed )
      {
        v8 = v7 - command;
        if ( command && v8 >= 0 )
        {
          assert_failed = 0;
LABEL_17:
          if ( !v8 )
            goto LABEL_21;
          v9 = v8 + cmd.length;
          v10 = cmd.length + 255;
          v11 = v8 + cmd.length + 256;
          LOBYTE(v10) = 0;
          LOBYTE(v11) = 0;
          v23 = v10;
          if ( v11 > v10 )
          {
            v18 = v11;
            v20 = v8 + cmd.length;
            v16 = (unsigned __int8 *)mem_realloc(cmd.source, v11);
            if ( v16 )
            {
              cmd.source = v16;
              memset(&v16[v23], 0, v18 - v23);
              v9 = v20;
              goto LABEL_19;
            }
            v6 = *v7;
            command = v7;
          }
          else
          {
LABEL_19:
            if ( cmd.source )
            {
              v19 = v9;
              memcpy(&cmd.source[cmd.length], command, v7 - command);
              cmd.source[v19] = 0;
              cmd.length = v19;
            }
LABEL_21:
            LOBYTE(v6) = *v7;
LABEL_22:
            command = v7;
          }
LABEL_23:
          if ( (_BYTE)v6 == 39 )
            goto LABEL_36;
          goto LABEL_24;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( !assert_failed )
          goto LABEL_17;
      }
      assert_failed = 0;
      LOBYTE(v6) = *v7;
      command = v7;
      if ( *v7 == 39 )
        goto LABEL_36;
LABEL_24:
      if ( (_BYTE)v6 == 92 )
      {
LABEL_30:
        v14 = command + 1;
        v15 = *v14;
        if ( *v14 )
        {
          command = v14 + 1;
          add_char_to_string(&cmd, v15);
          goto LABEL_2;
        }
        break;
      }
      if ( (_BYTE)v6 == 37 )
      {
        v12 = command[1];
        v13 = command + 1;
        switch ( v12 )
        {
          case 0u:
            goto LABEL_49;
          case 0x73u:
            add_char_to_string(&cmd, 0x25u);
            break;
          case 0x74u:
            if ( !type )
            {
LABEL_49:
              done_string(&cmd);
              return 0;
            }
            add_to_string(&cmd, type);
            break;
        }
        command += 2;
        LOBYTE(v6) = v13[1];
      }
    }
  }
  if ( copiousoutput )
  {
    v17 = (const unsigned __int8 *)getenv("PAGER");
    if ( v17
      || (v17 = "/usr/bin/pager", file_exists("/usr/bin/pager"))
      || (v17 = "/usr/bin/less", file_exists("/usr/bin/less"))
      || (v17 = "/usr/bin/more", file_exists("/usr/bin/more")) )
    {
      add_char_to_string(&cmd, 0x7Cu);
      add_to_string(&cmd, v17);
    }
  }
  return cmd.source;
}

//----- (080B7FB0) --------------------------------------------------------
mailcap_hash_item *__usercall check_entries@<eax>(mailcap_hash_item *item@<eax>)
{
  mailcap_hash_item *next; // ebx
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // edi
  unsigned __int8 *v5; // eax
  int v7; // [esp+1Ch] [ebp-1Ch]

  next = (mailcap_hash_item *)item->entries.next;
  if ( item->entries.next == item )
    return 0;
  while ( 1 )
  {
    v5 = *(unsigned __int8 **)next->type;
    if ( !v5 )
      break;
    v3 = format_command(v5, 0, 0);
    v4 = v3;
    if ( v3 )
    {
      v7 = exe(v3);
      mem_free(v4);
      if ( !v7 )
        break;
    }
    next = (mailcap_hash_item *)next->entries.next;
    if ( item == next )
      return 0;
  }
  return next;
}

//----- (080B8020) --------------------------------------------------------
void __cdecl done_mailcap(module *module)
{
  hash *v1; // eax
  hash *v2; // ebx
  hash *v3; // edx
  list_head_elinks *next; // edi
  void **v5; // esi
  void *v6; // ebx
  int i; // [esp+18h] [ebp-20h]

  v1 = mailcap_map;
  v2 = mailcap_map;
  if ( mailcap_map )
  {
    if ( 1 << mailcap_map->width > 0 )
    {
      v3 = mailcap_map;
      i = 0;
      while ( 1 )
      {
        next = (list_head_elinks *)v3->hash[i].next;
        v3 = v2;
        if ( next != &v2->hash[i] )
        {
          do
          {
            v5 = (void **)next[2].next;
            if ( v5 )
            {
              while ( 1 )
              {
                v6 = *v5;
                if ( *v5 == v5 )
                  break;
                *(_DWORD *)(*(_DWORD *)v6 + 4) = *((_DWORD *)v6 + 1);
                **((_DWORD **)v6 + 1) = *(_DWORD *)v6;
                if ( *((_DWORD *)v6 + 2) )
                  mem_free(*((void **)v6 + 2));
                if ( *((_DWORD *)v6 + 3) )
                  mem_free(*((void **)v6 + 3));
                mem_free(v6);
              }
              mem_free(v5);
              v1 = mailcap_map;
            }
            v3 = v1;
            next = (list_head_elinks *)next->next;
          }
          while ( &v1->hash[i] != next );
        }
        if ( 1 << v3->width <= ++i )
          break;
        v2 = v3;
      }
    }
    free_hash(&mailcap_map);
  }
}

//----- (080B8110) --------------------------------------------------------
int __cdecl change_hook_mailcap(session *ses, option_elinks *current, option_elinks *changed)
{
  if ( changed != &mailcap_options[2].option_elinks
    && (changed != &mailcap_options[1].option_elinks || mailcap_options[1].option_elinks.value.number) )
  {
    return 0;
  }
  done_mailcap(&mailcap_mime_module);
  return 0;
}

//----- (080B8150) --------------------------------------------------------
mime_handler *__cdecl get_mime_handler_mailcap(unsigned __int8 *type, int options)
{
  hash *v2; // ebx
  unsigned int v3; // eax
  hash_item *v4; // eax
  mailcap_hash_item *v5; // eax
  mailcap_hash_item *v6; // ebx
  unsigned __int8 *v7; // esi
  char *v9; // eax
  unsigned __int8 v10; // al
  int v11; // eax
  const char *v12; // eax
  const char *v13; // ebx
  mailcap_entry *v14; // eax
  mailcap_entry *v15; // esi
  const char *v16; // eax
  const char *v17; // ebx
  char *v18; // ebx
  unsigned int v19; // eax
  hash_item *hash_item; // eax
  char *v21; // ebx
  unsigned __int8 *v22; // eax
  unsigned __int8 v23; // dl
  unsigned __int8 *v24; // ecx
  int v25; // ebx
  unsigned __int8 *v26; // eax
  unsigned __int8 *mailcap_field_text; // eax
  hash *v28; // eax
  char *v29; // eax
  int v30; // eax
  int v31; // edi
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // esi
  hash_item *v34; // edi
  mailcap_hash_item *v35; // eax
  mailcap_hash_item *v36; // eax
  unsigned __int8 *v37; // eax
  char *v38; // eax
  _DWORD *value; // [esp+2Ch] [ebp-9Ch]
  _DWORD *valuea; // [esp+2Ch] [ebp-9Ch]
  mime_handler *nc; // [esp+30h] [ebp-98h]
  size_t n; // [esp+30h] [ebp-98h]
  unsigned int na; // [esp+30h] [ebp-98h]
  size_t nb; // [esp+30h] [ebp-98h]
  unsigned int keylen; // [esp+34h] [ebp-94h]
  unsigned __int8 *keylena; // [esp+34h] [ebp-94h]
  unsigned int v47; // [esp+38h] [ebp-90h]
  unsigned __int8 *p; // [esp+40h] [ebp-88h]
  FILE *file; // [esp+44h] [ebp-84h]
  char *mailcap_field; // [esp+48h] [ebp-80h]
  unsigned __int8 *v51; // [esp+48h] [ebp-80h]
  unsigned __int8 *line; // [esp+4Ch] [ebp-7Ch]
  unsigned __int8 *v53; // [esp+58h] [ebp-70h] BYREF
  unsigned __int8 *next; // [esp+5Ch] [ebp-6Ch] BYREF
  int lineno; // [esp+60h] [ebp-68h] BYREF
  size_t size; // [esp+64h] [ebp-64h] BYREF
  unsigned __int8 *path_ptr; // [esp+68h] [ebp-60h] BYREF
  unsigned __int8 key[64]; // [esp+6Ch] [ebp-5Ch] BYREF
  unsigned int v59; // [esp+ACh] [ebp-1Ch]

  v59 = __readgsdword(0x14u);
  if ( !mailcap_options[1].option_elinks.value.number )
    return 0;
  v2 = mailcap_map;
  if ( !mailcap_map )
  {
    mailcap_map = init_hash8();
    if ( !mailcap_map )
      return 0;
    path_ptr = mailcap_options[2].option_elinks.value.string;
    if ( !mailcap_options[2].option_elinks.value.number || (v10 = *mailcap_options[2].option_elinks.value.string) == 0 )
    {
      v37 = (unsigned __int8 *)getenv("MAILCAP");
      path_ptr = v37;
      if ( v37 )
      {
        v10 = *v37;
      }
      else
      {
        path_ptr = (unsigned __int8 *)&byte_811ED68;
        v10 = 126;
      }
    }
    v47 = 0;
    while ( v10 )
    {
      p = get_next_path_filename(&path_ptr, 0x3Au);
      if ( p )
      {
        v11 = fopen64(p, "rb");
        size = 1024;
        lineno = 1;
        file = (FILE *)v11;
        if ( v11 )
        {
          line = 0;
LABEL_21:
          while ( 1 )
          {
            line = file_read_line(line, &size, file, &lineno);
            if ( !line )
              break;
            if ( *line != 35 )
            {
              next = line;
              mailcap_field = (char *)get_mailcap_field(&next);
              if ( mailcap_field )
              {
                v12 = get_mailcap_field(&next);
                v13 = v12;
                if ( v12 )
                {
                  n = strlen(v12);
                  v14 = (mailcap_entry *)mem_calloc(1u, n + 24);
                  v15 = v14;
                  if ( v14 )
                  {
                    memcpy(v14->command, v13, n);
                    v15->priority = v47;
                    v53 = next;
LABEL_27:
                    while ( 1 )
                    {
                      v16 = get_mailcap_field(&v53);
                      v17 = v16;
                      if ( !v16 )
                        break;
                      while ( !c_strncasecmp(v16, "needsterminal", 0xDu) )
                      {
                        *((_BYTE *)v15 + 20) |= 1u;
                        v16 = get_mailcap_field(&v53);
                        v17 = v16;
                        if ( !v16 )
                          goto LABEL_30;
                      }
                      if ( c_strncasecmp(v17, "copiousoutput", 0xDu) )
                      {
                        if ( c_strncasecmp(v17, "test", 4u) )
                        {
                          if ( !c_strncasecmp(v17, "description", 0xBu) )
                          {
                            mailcap_field_text = get_mailcap_field_text((unsigned __int8 *)v17 + 11);
                            v15->description = mailcap_field_text;
                            if ( !mailcap_field_text )
                              goto LABEL_45;
                          }
                        }
                        else
                        {
                          v22 = get_mailcap_field_text((unsigned __int8 *)v17 + 4);
                          v15->testcommand = v22;
                          if ( !v22 )
                            goto LABEL_47;
                          v23 = *v22;
                          if ( *v22 )
                          {
                            v24 = v22 + 1;
                            while ( 1 )
                            {
                              if ( v23 == 37 )
                              {
                                v23 = *v24;
                                if ( *v24 == 115 )
                                {
                                  mem_free(v22);
LABEL_45:
                                  if ( v15->testcommand )
                                    mem_free(v15->testcommand);
LABEL_47:
                                  if ( v15->description )
                                    mem_free(v15->description);
                                  mem_free(v15);
                                  v25 = lineno;
                                  v26 = gettext("Badly formated mailcap entry for type %s in \"%s\" line %d");
                                  usrerror(v26, mailcap_field, p, v25);
                                  goto LABEL_21;
                                }
                              }
                              else
                              {
                                v23 = *v24;
                              }
                              ++v24;
                              if ( !v23 )
                                goto LABEL_27;
                            }
                          }
                        }
                      }
                      else
                      {
                        *((_BYTE *)v15 + 20) |= 2u;
                      }
                    }
LABEL_30:
                    v18 = strchr(mailcap_field, 47);
                    v19 = strlen(mailcap_field);
                    if ( v18 )
                    {
                      na = v19;
                      hash_item = get_hash_item(mailcap_map, (unsigned __int8 *)mailcap_field, v19);
                      if ( hash_item )
                      {
LABEL_32:
                        v21 = (char *)hash_item->value;
                        if ( v21 )
                          goto LABEL_33;
                      }
                      else
                      {
                        v38 = (char *)mem_alloc(na + 12);
                        v21 = v38;
                        if ( v38 )
                        {
                          keylena = (unsigned __int8 *)(v38 + 8);
                          valuea = v38;
                          safe_strncpy((unsigned __int8 *)v38 + 8, (const unsigned __int8 *)mailcap_field, na + 1);
                          valuea[1] = valuea;
                          *valuea = valuea;
                          if ( add_hash_item(mailcap_map, keylena, na, valuea) )
                          {
LABEL_33:
                            v15->next = (mailcap_entry *)**((_DWORD **)v21 + 1);
                            v15->prev = (mailcap_entry *)*((_DWORD *)v21 + 1);
                            **((_DWORD **)v21 + 1) = v15;
                            v15->next->prev = v15;
                            continue;
                          }
                          mem_free(valuea);
                        }
                      }
LABEL_80:
                      done_mailcap_entry(v15);
                      continue;
                    }
                    keylen = v19 + 3;
                    if ( v19 + 3 <= 0x40 )
                    {
                      nb = v19;
                      __memcpy_chk(key, mailcap_field, v19, 64);
                      v28 = mailcap_map;
                      key[nb] = 47;
                      key[nb + 1] = 42;
                      key[nb + 2] = 0;
                      hash_item = get_hash_item(v28, key, keylen);
                      if ( hash_item )
                        goto LABEL_32;
                      v29 = (char *)mem_alloc(nb + 15);
                      v21 = v29;
                      if ( !v29 )
                        goto LABEL_80;
                      value = v29;
                      v51 = (unsigned __int8 *)(v29 + 8);
                      safe_strncpy((unsigned __int8 *)v29 + 8, key, nb + 4);
                      value[1] = value;
                      *value = value;
                      if ( add_hash_item(mailcap_map, v51, keylen, value) )
                        goto LABEL_33;
                      mem_free(value);
                      done_mailcap_entry(v15);
                    }
                    else
                    {
                      if ( v15->testcommand )
                        mem_free(v15->testcommand);
                      if ( v15->description )
                        mem_free(v15->description);
                      mem_free(v15);
                    }
                  }
                }
              }
            }
          }
          fclose(file);
        }
        ++v47;
        mem_free(p);
      }
      v10 = *path_ptr;
    }
    v2 = mailcap_map;
    if ( !mailcap_map )
      return 0;
  }
  v3 = strlen((const char *)type);
  v4 = get_hash_item(v2, type, v3);
  if ( v4 && (v5 = (mailcap_hash_item *)v4->value) != 0 )
  {
    v6 = check_entries(v5);
    if ( v6 && !mailcap_options[5].option_elinks.value.number )
      goto LABEL_7;
  }
  else
  {
    v6 = 0;
  }
  v9 = strchr((const char *)type, 47);
  if ( !v9 )
    goto LABEL_11;
  v30 = v9 - (char *)type;
  v31 = v30 + 1;
  v32 = memacpy(type, v30 + 3);
  v33 = v32;
  if ( !v32 )
    return 0;
  v32[v31] = 42;
  v32[v31 + 1] = 0;
  v34 = get_hash_item(mailcap_map, v32, v31 + 1);
  mem_free(v33);
  if ( v34 && (v35 = (mailcap_hash_item *)v34->value) != 0 && (v36 = check_entries(v35)) != 0 )
  {
    if ( !v6 || v36[1].entries.prev < v6[1].entries.prev )
      v6 = v36;
  }
  else
  {
LABEL_11:
    if ( !v6 )
      return 0;
  }
LABEL_7:
  v7 = format_command(&v6[1].type[1], type, (v6[1].type[0] & 2) != 0);
  if ( v7 )
  {
    nc = init_mime_handler(
           v7,
           (unsigned __int8 *)v6[1].entries.next,
           mailcap_mime_module.name,
           mailcap_options[3].option_elinks.value.number,
           (v6[1].type[0] & 3) != 0);
    mem_free(v7);
    return nc;
  }
  return 0;
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8059038: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 811ED68: using guessed type char byte_811ED68;

//----- (080B8890) --------------------------------------------------------
void __usercall done_mimetypes_entry(mimetypes_entry *entry@<eax>)
{
  unsigned __int8 *content_type; // eax

  if ( entry )
  {
    content_type = entry->content_type;
    if ( content_type )
      mem_free(content_type);
    mem_free(entry);
  }
}

//----- (080B88C0) --------------------------------------------------------
void __cdecl done_mimetypes(module *module)
{
  hash *v1; // edx
  hash *v2; // eax
  int v3; // edi
  hash *i; // ecx
  list_head_elinks *next; // ebx
  mimetypes_entry *v6; // eax

  v1 = mimetypes_map;
  if ( mimetypes_map )
  {
    if ( 1 << mimetypes_map->width > 0 )
    {
      v2 = mimetypes_map;
      v3 = 0;
      for ( i = mimetypes_map; ; i = v2 )
      {
        next = (list_head_elinks *)v2->hash[v3].next;
        v2 = i;
        if ( next != &i->hash[v3] )
        {
          do
          {
            v6 = (mimetypes_entry *)next[2].next;
            if ( v6 )
            {
              done_mimetypes_entry(v6);
              v1 = mimetypes_map;
            }
            next = (list_head_elinks *)next->next;
            v2 = v1;
          }
          while ( &v1->hash[v3] != next );
        }
        if ( 1 << v2->width <= ++v3 )
          break;
      }
    }
    free_hash(&mimetypes_map);
  }
}

//----- (080B8960) --------------------------------------------------------
int __cdecl change_hook_mimetypes(session *ses, option_elinks *current, option_elinks *changed)
{
  if ( changed != &mimetypes_options[2].option_elinks
    && (changed != &mimetypes_options[1].option_elinks || mimetypes_options[1].option_elinks.value.number) )
  {
    return 0;
  }
  done_mimetypes(&mimetypes_mime_module);
  return 0;
}

//----- (080B89A0) --------------------------------------------------------
void __cdecl init_mimetypes(module *module)
{
  register_change_hooks(mimetypes_change_hooks_6816);
  if ( get_opt_(cmdline_options, "anonymous")->number )
    mimetypes_options[1].option_elinks.value.number = 0;
}

//----- (080B89E0) --------------------------------------------------------
void __usercall parse_mimetypes_file(unsigned __int8 *filename@<eax>)
{
  char *v1; // eax
  unsigned __int8 *v2; // edi
  const unsigned __int16 *v3; // edx
  unsigned __int8 *v4; // ebx
  char *v5; // ebx
  const unsigned __int16 *v6; // edx
  char *v7; // esi
  size_t v8; // edi
  mimetypes_entry *v9; // edx
  unsigned __int8 *v10; // eax
  mimetypes_entry *v11; // edx
  hash_item *v12; // eax
  mimetypes_entry *value; // [esp+1Ch] [ebp-43Ch]
  unsigned __int8 *src; // [esp+20h] [ebp-438h]
  size_t len; // [esp+24h] [ebp-434h]
  FILE *file; // [esp+28h] [ebp-430h]
  const unsigned __int16 **v17; // [esp+2Ch] [ebp-42Ch]
  unsigned __int8 line[1024]; // [esp+3Ch] [ebp-41Ch] BYREF
  unsigned int v19; // [esp+43Ch] [ebp-1Ch]

  v19 = __readgsdword(0x14u);
  file = (FILE *)fopen64(filename, "rb");
  if ( file )
  {
LABEL_2:
    while ( fgets((char *)line, 1023, file) )
    {
      v1 = strchr((const char *)line, 35);
      if ( v1 )
        *v1 = 0;
      v2 = line;
      v17 = __ctype_b_loc();
      v3 = *v17;
      while ( (v3[*v2] & 0x2000) != 0 )
        ++v2;
      if ( *v2 )
      {
        v4 = v2;
        while ( *++v4 )
        {
          if ( (v3[*v4] & 0x2000) != 0 )
          {
            *v4 = 0;
            if ( strchr((const char *)v2, 47) )
            {
              v5 = (char *)(v4 + 1);
              src = v2;
              len = strlen((const char *)v2);
LABEL_14:
              if ( *v5 )
              {
                v6 = *v17;
                if ( ((*v17)[(unsigned __int8)*v5] & 0x2000) == 0 )
                  goto LABEL_18;
                do
                  ++v5;
                while ( (v6[(unsigned __int8)*v5] & 0x2000) != 0 );
                if ( *v5 )
                {
LABEL_18:
                  v7 = v5;
                  while ( *++v7 )
                  {
                    if ( (v6[(unsigned __int8)*v7] & 0x2000) != 0 )
                    {
                      *v7 = 0;
                      v8 = strlen(v5);
                      if ( !get_hash_item(mimetypes_map, (unsigned __int8 *)v5, v8) )
                      {
                        v9 = (mimetypes_entry *)mem_calloc(1u, v8 + 8);
                        if ( v9 )
                        {
                          value = v9;
                          v10 = memacpy(src, len);
                          v11 = value;
                          value->content_type = v10;
                          if ( !v10
                            || (memcpy(value->extension, v5, v8),
                                v12 = add_hash_item(mimetypes_map, value->extension, v8, value),
                                v11 = value,
                                !v12) )
                          {
                            done_mimetypes_entry(v11);
                          }
                        }
                      }
                      v5 = v7 + 1;
                      goto LABEL_14;
                    }
                  }
                }
              }
            }
            goto LABEL_2;
          }
        }
      }
    }
    fclose(file);
  }
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080B8C40) --------------------------------------------------------
unsigned __int8 *__cdecl get_content_type_mimetypes(unsigned __int8 *extension)
{
  unsigned __int8 *v1; // esi
  unsigned int v2; // ebx
  char *v3; // eax
  hash_item *hash_item; // eax
  const unsigned __int8 **value; // eax
  unsigned __int8 i; // al
  unsigned __int8 *next_path_filename; // eax
  unsigned __int8 *v9; // ebx
  unsigned __int8 *path_ptr; // [esp+1Ch] [ebp-Ch] BYREF

  if ( !mimetypes_options[1].option_elinks.value.number )
    return 0;
  if ( !mimetypes_map )
  {
    mimetypes_map = init_hash8();
    if ( !mimetypes_map )
      return 0;
    path_ptr = mimetypes_options[2].option_elinks.value.string;
    if ( mimetypes_options[2].option_elinks.value.number && *mimetypes_options[2].option_elinks.value.string )
      goto LABEL_15;
    path_ptr = (unsigned __int8 *)&byte_811F00C;
    for ( i = 126; i; i = *path_ptr )
    {
LABEL_15:
      next_path_filename = get_next_path_filename(&path_ptr, 0x3Au);
      v9 = next_path_filename;
      if ( next_path_filename )
      {
        parse_mimetypes_file(next_path_filename);
        mem_free(v9);
      }
    }
    if ( !mimetypes_map )
      return 0;
  }
  v1 = extension + 1;
  v2 = strlen((const char *)extension + 1);
  if ( !v2 )
    return 0;
  while ( 1 )
  {
    hash_item = get_hash_item(mimetypes_map, v1, v2);
    if ( hash_item )
    {
      value = (const unsigned __int8 **)hash_item->value;
      if ( value )
        break;
    }
    v3 = strchr((const char *)v1, 46);
    if ( !v3 )
      return 0;
    v2 += ~(v3 - (char *)v1);
    if ( !v2 )
      return 0;
    v1 = (unsigned __int8 *)(v3 + 1);
  }
  return stracpy(*value);
}
// 811F00C: using guessed type char byte_811F00C;

//----- (080B8D60) --------------------------------------------------------
int get_connections_count()
{
  list_head_elinks *next; // edx
  int result; // eax

  next = (list_head_elinks *)connection_queue.next;
  for ( result = 0; next != &connection_queue; ++result )
    next = (list_head_elinks *)next->next;
  return result;
}

//----- (080B8D90) --------------------------------------------------------
int get_keepalive_connections_count()
{
  list_head_elinks *next; // edx
  int result; // eax

  next = (list_head_elinks *)keepalive_connections.next;
  for ( result = 0; next != &keepalive_connections; ++result )
    next = (list_head_elinks *)next->next;
  return result;
}

//----- (080B8DC0) --------------------------------------------------------
int get_connections_connecting_count()
{
  list_head_elinks *next; // edx
  int result; // eax
  char *v2; // ecx

  next = (list_head_elinks *)connection_queue.next;
  for ( result = 0; next != &connection_queue; result += (unsigned int)(v2 - 1) <= 6 )
  {
    v2 = (char *)next[10].next;
    next = (list_head_elinks *)next->next;
  }
  return result;
}

//----- (080B8E00) --------------------------------------------------------
int get_connections_transfering_count()
{
  list_head_elinks *next; // edx
  int result; // eax
  bool v2; // zf
  bool v3; // sf
  bool v4; // of

  next = (list_head_elinks *)connection_queue.next;
  for ( result = 0; next != &connection_queue; result += !(v3 ^ v4 | v2) )
  {
    v4 = __OFSUB__(next[10].next, 7);
    v2 = next[10].next == (void *)7;
    v3 = (int)next[10].next - 7 < 0;
    next = (list_head_elinks *)next->next;
  }
  return result;
}

//----- (080B8E30) --------------------------------------------------------
void __usercall notify_connection_callbacks(connection *conn@<eax>)
{
  unsigned int id; // edi
  connection *next; // eax
  connection *v4; // esi
  progress *progress; // edx
  list_head_elinks *v6; // eax
  connection_basic_state basic; // [esp+18h] [ebp-20h]

  id = conn->id;
  basic = conn->state.basic;
  next = (connection *)conn->downloads.next;
  v4 = next->next;
  if ( next != (connection *)&conn->downloads )
  {
    while ( 1 )
    {
      next->downloads.prev = conn->cached;
      progress = next->progress;
      if ( progress )
        ((void (__cdecl *)(connection *, uri *))progress)(next, next->uri);
      if ( basic >= S_WAIT )
      {
        v6 = (list_head_elinks *)connection_queue.next;
        if ( connection_queue.next == &connection_queue )
          return;
        while ( conn != (connection *)v6 || id != conn->id )
        {
          v6 = (list_head_elinks *)v6->next;
          if ( v6 == &connection_queue )
            return;
        }
      }
      next = v4;
      if ( v4 == (connection *)&conn->downloads )
        break;
      v4 = v4->next;
    }
  }
}

//----- (080B8EB0) --------------------------------------------------------
int __cdecl is_entry_used(cache_entry *cached)
{
  cache_entry *next; // eax

  next = (cache_entry *)connection_queue.next;
  if ( connection_queue.next == &connection_queue )
    return 0;
  while ( (cache_entry *)next->content_type != cached )
  {
    next = next->next;
    if ( next == (cache_entry *)&connection_queue )
      return 0;
  }
  return 1;
}

//----- (080B8EF0) --------------------------------------------------------
int __usercall get_priority@<eax>(connection *conn@<eax>)
{
  int v1; // edx
  int v2; // ebx

  v1 = 0;
  v2 = 0;
  do
  {
    if ( conn->pri[v2] )
      break;
    ++v1;
    ++v2;
  }
  while ( v1 != 7 );
  if ( assert_failed )
    return v2;
  assert_failed = v2 == 7;
  if ( v2 != 7 )
    return v2;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
  errline = 79;
  elinks_internal("assertion priority != PRIORITIES failed: Connection has no owner");
  return 7;
}

//----- (080B8F60) --------------------------------------------------------
void __usercall add_to_queue(connection *conn@<eax>)
{
  int priority; // eax
  connection *next; // ebx
  unsigned int i; // esi

  priority = get_priority(conn);
  next = (connection *)connection_queue.next;
  for ( i = priority; next != (connection *)&connection_queue; next = next->next )
  {
    if ( i < get_priority(next) )
      break;
  }
  conn->next = next->prev->next;
  conn->prev = next->prev;
  next->prev->next = conn;
  conn->next->prev = conn;
}

//----- (080B8FC0) --------------------------------------------------------
void sort_queue()
{
  connection *next; // ebx
  connection *v1; // eax
  int v2; // edi
  unsigned int priority; // esi
  connection *v4; // eax
  connection *v5; // edx

  do
  {
    next = (connection *)connection_queue.next;
    if ( connection_queue.next == &connection_queue )
      break;
    v1 = *(connection **)connection_queue.next;
    if ( *(list_head_elinks **)connection_queue.next == &connection_queue )
      break;
    v2 = 0;
    do
    {
      priority = get_priority(v1);
      if ( priority < get_priority(next) )
      {
        v4 = next->next;
        v2 = 1;
        v4->prev = next->prev;
        next->prev->next = next->next;
        v5 = v4->next;
        next->prev = v4;
        next->next = v5;
        v4->next = next;
        next->next->prev = next;
      }
      next = next->next;
      if ( next == (connection *)&connection_queue )
        break;
      v1 = next->next;
    }
    while ( (list_head_elinks *)next->next != &connection_queue );
  }
  while ( v2 );
}

//----- (080B9050) --------------------------------------------------------
connection_basic_state *__usercall connection_state_0@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080B90E0) --------------------------------------------------------
connection *__usercall init_connection@<eax>(
        uri *uri@<eax>,
        uri *proxied_uri@<edx>,
        uri *referrer@<ecx>,
        off_t start,
        cache_mode cache_mode,
        connection_priority priority)
{
  void **v8; // ebx
  socket *inited; // eax
  socket *v10; // eax
  progress *v11; // eax
  unsigned int v12; // eax
  bool v14; // zf
  void **v15; // [esp+0h] [ebp-38h]
  void **v16; // [esp+0h] [ebp-38h]

  v8 = (void **)mem_calloc(1u, 0x9Cu);
  if ( !v8 )
    return (connection *)v8;
  if ( !assert_failed )
  {
    v14 = proxied_uri->protocol != 15;
    assert_failed = proxied_uri->protocol == 15;
    if ( !v14 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 279;
      elinks_internal("assertion proxied_uri->protocol != PROTOCOL_PROXY failed!");
    }
  }
  inited = init_socket(v8, &connection_socket_operations_8784);
  v8[24] = inited;
  if ( !inited )
    goto LABEL_15;
  v10 = init_socket(v8, &connection_socket_operations_8784);
  v8[25] = v10;
  if ( !v10 )
  {
    mem_free(v8[24]);
LABEL_15:
    v15 = v8;
    v8 = 0;
    mem_free(v15);
    return (connection *)v8;
  }
  v11 = init_progress(start);
  v8[4] = v11;
  if ( !v11 )
  {
    mem_free(v8[25]);
    mem_free(v8[24]);
    v16 = v8;
    v8 = 0;
    mem_free(v16);
    return (connection *)v8;
  }
  v8[6] = proxied_uri;
  v8[5] = uri;
  v12 = connection_id;
  v8[19] = (void *)connection_id;
  connection_id = v12 + 1;
  v8[priority + 31] = (void *)1;
  v8[16] = 0;
  v8[29] = (void *)-1;
  v8[28] = (void *)-1;
  v8[8] = (void *)cache_mode;
  v8[3] = v8 + 2;
  v8[2] = v8 + 2;
  v8[14] = (void *)-1;
  v8[15] = (void *)-1;
  v8[27] = 0;
  if ( !referrer )
    return (connection *)v8;
  if ( referrer->protocol != 4 || uri->protocol == 4 )
  {
    ++referrer->object.refcount;
    v8[7] = referrer;
    return (connection *)v8;
  }
  return (connection *)v8;
}

//----- (080B9290) --------------------------------------------------------
const uri *__usercall get_host_connection@<eax>(connection *conn@<eax>)
{
  uri *uri; // eax
  const uri *next; // ebx

  uri = conn->uri;
  if ( !uri->host )
    return 0;
  next = (const uri *)host_connections.next;
  if ( host_connections.next == &host_connections )
    return 0;
  while ( !compare_uri((const uri *)next->user, uri, URI_HOST) )
  {
    next = (const uri *)next->string;
    if ( next == (const uri *)&host_connections )
      return 0;
    uri = conn->uri;
  }
  return next;
}

//----- (080B92F0) --------------------------------------------------------
int __usercall add_host_connection@<eax>(connection *conn@<eax>)
{
  _DWORD *host_connection; // eax
  int v3; // edx
  uri *uri; // edx
  void *next; // edx

  host_connection = get_host_connection(conn);
  if ( host_connection )
    goto LABEL_2;
  v3 = 1;
  if ( conn->uri->host )
  {
    host_connection = mem_calloc(1u, 0x10u);
    v3 = 0;
    if ( host_connection )
    {
      uri = conn->uri;
      ++uri->object.refcount;
      host_connection[3] = uri;
      next = host_connections.next;
      host_connection[1] = &host_connections;
      *host_connection = next;
      host_connections.next = host_connection;
      *(_DWORD *)(*host_connection + 4) = host_connection;
LABEL_2:
      ++host_connection[2];
      return 1;
    }
  }
  return v3;
}

//----- (080B9370) --------------------------------------------------------
void __cdecl set_connection_timeout(connection *conn)
{
  milliseconds_T v1; // eax

  kill_timer(&conn->timer);
  if ( (*((_BYTE *)conn + 120) & 2) != 0 )
    v1 = 500 * get_opt_(config_options, "connection.unrestartable_receive_timeout")->number;
  else
    v1 = 500 * get_opt_(config_options, "connection.receive_timeout")->number;
  install_timer(&conn->timer, v1, (void (*)(void *))connection_timeout_1, conn);
}

//----- (080B93F0) --------------------------------------------------------
void __cdecl set_connection_socket_timeout(socket *socket, connection_state state)
{
  if ( assert_failed || (assert_failed = socket == 0, socket) )
  {
    set_connection_timeout((connection *)socket->conn);
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 246;
    elinks_internal("assertion socket failed!");
    set_connection_timeout(MEMORY[8]);
  }
}

//----- (080B9460) --------------------------------------------------------
void __cdecl connection_timeout_1(connection *conn)
{
  milliseconds_T v1; // eax

  if ( (*((_BYTE *)conn + 120) & 2) != 0 )
    v1 = 500 * get_opt_(config_options, "connection.unrestartable_receive_timeout")->number;
  else
    v1 = 500 * get_opt_(config_options, "connection.receive_timeout")->number;
  install_timer(&conn->timer, v1, (void (*)(void *))connection_timeout, conn);
}

//----- (080B94D0) --------------------------------------------------------
void __cdecl connection_timeout(connection *conn)
{
  conn->timer = 0;
  timeout_socket(conn->socket);
}

//----- (080B94F0) --------------------------------------------------------
void __cdecl detach_connection(download *download, off_t pos)
{
  connection *conn; // ebx
  off_t est_length; // rdi
  int v4; // edx
  __int64 v5; // rdi
  cache_entry *cached; // eax

  conn = download->conn;
  if ( download->state.basic >= S_WAIT )
  {
    if ( (*((_BYTE *)conn + 120) & 4) != 0 )
    {
LABEL_14:
      free_entry_to(conn->cached, pos);
      return;
    }
    if ( conn->cached )
    {
      est_length = conn->est_length;
      if ( (HIDWORD(est_length) & (unsigned int)est_length) == -1 )
        est_length = conn->from;
      v4 = 25 * get_opt_(config_options, "document.cache.memory.size")->number / 100;
      if ( est_length >= v4 )
      {
        LODWORD(v5) = (unsigned __int64)(conn->pri[4]
                                       + conn->pri[3]
                                       + conn->pri[2]
                                       + conn->pri[1]
                                       + (__int64)conn->pri[0]
                                       + conn->pri[5]) >> 32;
        HIDWORD(v5) = conn->pri[4] + conn->pri[3] + conn->pri[2] + conn->pri[1] + conn->pri[0] + conn->pri[5];
        if ( !assert_failed )
        {
          assert_failed = v5 == 0;
          if ( !v5 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
            errline = 1113;
            elinks_internal("assertion total_pri failed: detaching free connection");
          }
        }
        shrink_format_cache(0);
        if ( !((unsigned int)v5 | HIDWORD(v5) ^ 1) )
        {
          cached = conn->cached;
          if ( !cached->object.refcount )
          {
            *((_BYTE *)cached + 92) &= ~0x10u;
            *((_BYTE *)conn + 120) |= 4u;
            goto LABEL_14;
          }
        }
      }
    }
  }
}

//----- (080B9690) --------------------------------------------------------
int register_check_queue()
{
  return register_bottom_half_do((select_handler_T)check_queue, 0);
}

//----- (080B96B0) --------------------------------------------------------
void __cdecl shutdown_connection_stream(connection *conn)
{
  if ( conn->stream )
  {
    close_encoded(conn->stream);
    conn->stream = 0;
  }
  else if ( conn->stream_pipes[0] >= 0 )
  {
    close(conn->stream_pipes[0]);
  }
  if ( conn->stream_pipes[1] >= 0 )
    close(conn->stream_pipes[1]);
  conn->stream_pipes[1] = -1;
  conn->stream_pipes[0] = -1;
}

//----- (080B9710) --------------------------------------------------------
void __usercall free_connection_data(connection *conn@<eax>)
{
  int v2; // eax
  int v3; // eax
  socket *socket; // eax
  cache_entry *cached; // esi
  void (*done)(connection *); // eax
  const uri *host_connection; // eax
  uri *p; // [esp+1Ch] [ebp-Ch]

  if ( !assert_failed )
  {
    v2 = (*((_BYTE *)conn + 120) ^ 1) & 1;
    assert_failed = (*((_BYTE *)conn + 120) ^ 1) & 1;
    if ( v2 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 397;
      elinks_internal("assertion conn->running failed: connection already suspended");
    }
  }
  *((_BYTE *)conn + 120) &= ~1u;
  v3 = --active_connections;
  if ( assert_failed
    || (assert_failed = (unsigned int)v3 >> 31, v3 < 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
        errline = 403,
        elinks_internal("assertion active_connections >= 0 failed: active connections underflow"),
        assert_failed) )
  {
    assert_failed = 0;
    active_connections = 0;
  }
  socket = conn->socket;
  if ( socket->ssl )
  {
    cached = conn->cached;
    if ( cached )
    {
      if ( cached->ssl_info )
      {
        mem_free(cached->ssl_info);
        cached = conn->cached;
        socket = conn->socket;
      }
      cached->ssl_info = get_ssl_connection_cipher(socket);
    }
  }
  done = conn->done;
  if ( done )
    done(conn);
  done_socket(conn->socket);
  done_socket(conn->data_socket);
  shutdown_connection_stream(conn);
  if ( conn->info )
    mem_free(conn->info);
  conn->info = 0;
  kill_timer(&conn->timer);
  if ( conn->state.basic )
  {
    host_connection = get_host_connection(conn);
    if ( host_connection )
    {
      if ( host_connection->ip_family-- == 1 )
      {
        *((_DWORD *)host_connection->string + 1) = host_connection->protocol;
        *(_DWORD *)host_connection->protocol = host_connection->string;
        p = (uri *)host_connection;
        done_uri((uri *)host_connection->user);
        mem_free(p);
      }
    }
  }
}

//----- (080B98C0) --------------------------------------------------------
void __cdecl set_connection_state(connection *conn, connection_state state)
{
  int syserr; // eax
  progress *progress; // edx
  unsigned int id; // ebx
  list_head_elinks *next; // edx
  list_head_elinks *i; // edx
  int v7; // ebx
  int v8; // ebx

  syserr = state.syserr;
  progress = conn->progress;
  if ( conn->state.basic < S_WAIT )
  {
    if ( state.basic < S_WAIT )
    {
      conn->state = state;
      goto LABEL_12;
    }
    v8 = conn->state.syserr;
    conn->prev_error.basic = conn->state.basic;
    conn->prev_error.syserr = v8;
  }
  conn->state = state;
  if ( state.basic != S_TRANS )
  {
LABEL_12:
    kill_timer(&progress->timer);
    syserr = state.syserr;
    goto LABEL_13;
  }
  if ( !progress->timer )
  {
    id = conn->id;
    start_update_progress(progress, (void (*)(void *))stat_timer, conn);
    update_progress(conn->progress, conn->received, conn->est_length, conn->from);
    next = (list_head_elinks *)connection_queue.next;
    syserr = state.syserr;
    if ( connection_queue.next == &connection_queue )
      return;
    while ( conn != (connection *)next || id != conn->id )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &connection_queue )
        return;
    }
  }
LABEL_13:
  for ( i = (list_head_elinks *)conn->downloads.next; i != &conn->downloads; i = (list_head_elinks *)i->next )
  {
    i[4].next = (void *)syserr;
    i[3].prev = (void *)state.basic;
    v7 = conn->prev_error.syserr;
    i[4].prev = (void *)conn->prev_error.basic;
    i[5].next = (void *)v7;
  }
  if ( state.basic >= S_WAIT )
    notify_connection_callbacks(conn);
}

//----- (080B9A00) --------------------------------------------------------
void __cdecl set_connection_socket_state(socket *socket, connection_state state)
{
  if ( !assert_failed )
  {
    assert_failed = socket == 0;
    if ( !socket )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 239;
      elinks_internal("assertion socket failed!");
    }
  }
  set_connection_state((connection *)socket->conn, state);
}

//----- (080B9A80) --------------------------------------------------------
void __cdecl stat_timer(connection *conn)
{
  update_progress(conn->progress, conn->received, conn->est_length, conn->from);
  notify_connection_callbacks(conn);
}

//----- (080B9AD0) --------------------------------------------------------
int __usercall try_to_suspend_connection@<eax>(connection *conn@<eax>, uri *uri@<edx>)
{
  int priority; // eax
  connection *prev; // ebx
  unsigned int v5; // edi
  int v6; // eax

  priority = get_priority(conn);
  prev = (connection *)connection_queue.prev;
  v5 = priority;
  if ( connection_queue.prev != &connection_queue )
  {
    while ( v5 < get_priority(prev) )
    {
      if ( prev->state.basic
        && (!prev->uri->post || (unsigned int)get_priority(prev) > 5)
        && (!uri || compare_uri(uri, prev->uri, URI_HOST)) )
      {
        free_connection_data(prev);
        if ( assert_failed )
        {
          assert_failed = 0;
          v6 = -100003;
        }
        else
        {
          assert_failed = 0;
          v6 = 0;
        }
        set_connection_state(prev, (connection_state)(unsigned int)v6);
        return 0;
      }
      prev = prev->prev;
      if ( prev == (connection *)&connection_queue )
        return -1;
    }
  }
  return -1;
}

//----- (080B9BB0) --------------------------------------------------------
int __cdecl load_uri(
        uri *uri,
        uri *referrer,
        download *download,
        connection_priority pri,
        cache_mode cache_mode,
        off_t start)
{
  connection_basic_state v6; // eax
  connection_basic_state v7; // eax
  connection_basic_state v8; // eax
  cache_entry *validated_cache_entry; // eax
  connection_basic_state v10; // eax
  download_callback_T *callback; // eax
  int result; // eax
  uri *v13; // eax
  int v14; // edx
  void *v15; // eax
  list_head_elinks *next; // esi
  progress *v17; // eax
  download *v18; // edx
  connection *inited; // eax
  connection *v20; // esi
  progress *progress; // eax
  int v22; // edx
  download *v23; // edx
  connection_basic_state v24; // edx
  int syserr; // edx
  void *data; // eax
  uri *proxied_uri; // [esp+18h] [ebp-40h]
  uri *proxy_uri; // [esp+1Ch] [ebp-3Ch]
  connection_state state; // [esp+28h] [ebp-30h] BYREF
  connection_state error_state; // [esp+38h] [ebp-20h] BYREF

  if ( assert_failed )
  {
    assert_failed = 0;
    v6 = S_INTERNAL;
  }
  else
  {
    assert_failed = 0;
    v6 = S_OK;
  }
  error_state.syserr = 0;
  error_state.basic = v6;
  if ( download )
  {
    download->conn = 0;
    download->cached = 0;
    download->pri = pri;
    if ( assert_failed )
    {
      assert_failed = 0;
      v7 = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v7 = S_OUT_OF_MEM;
    }
    download->state.basic = v7;
    download->state.syserr = 0;
    if ( assert_failed )
    {
      assert_failed = 0;
      v8 = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v8 = S_WAIT;
    }
    download->prev_error.basic = v8;
    download->prev_error.syserr = 0;
  }
  validated_cache_entry = get_validated_cache_entry(uri, cache_mode);
  if ( validated_cache_entry )
  {
    if ( download )
    {
      download->cached = validated_cache_entry;
      if ( assert_failed )
      {
        assert_failed = 0;
        v10 = S_INTERNAL;
      }
      else
      {
        assert_failed = 0;
        v10 = S_OK;
      }
      download->state.basic = v10;
      callback = download->callback;
      download->state.syserr = 0;
      if ( callback )
      {
        callback(download, download->data);
        return 0;
      }
    }
    return 0;
  }
  proxied_uri = get_proxied_uri(uri);
  v13 = get_proxy_uri(uri, &error_state);
  proxy_uri = v13;
  if ( proxied_uri
    && v13
    && (!get_protocol_need_slash_after_host((protocol)v13->protocol) || *((_WORD *)proxy_uri + 23)) )
  {
    next = (list_head_elinks *)connection_queue.next;
    if ( connection_queue.next != &connection_queue )
    {
      while ( ((int)next[15].next & 4) != 0 || !compare_uri((const uri *)next[2].prev, proxy_uri, (uri_component)0) )
      {
        next = (list_head_elinks *)next->next;
        if ( next == &connection_queue )
          goto LABEL_41;
      }
      done_uri(proxy_uri);
      done_uri(proxied_uri);
      if ( pri < (unsigned int)get_priority((connection *)next) )
      {
        *((_DWORD *)next->next + 1) = next->prev;
        *(_DWORD *)next->prev = next->next;
        ++*((_DWORD *)&next[15].prev + pri);
        add_to_queue((connection *)next);
        register_check_queue();
      }
      else
      {
        ++*((_DWORD *)&next[15].prev + pri);
      }
      if ( download )
      {
        v17 = (progress *)next[2].next;
        download->conn = (connection *)next;
        download->progress = v17;
        download->cached = (cache_entry *)next[4].prev;
        v18 = (download *)next[1].next;
        download->prev = (download *)&next[1];
        download->next = v18;
        next[1].next = download;
        download->next->prev = download;
        set_connection_state((connection *)next, (connection_state)next[10]);
        return 0;
      }
      return 0;
    }
LABEL_41:
    inited = init_connection(proxy_uri, proxied_uri, referrer, start, cache_mode, pri);
    v20 = inited;
    if ( !inited )
    {
      if ( download )
      {
        connection_state_0(S_OUT_OF_MEM, &state.basic);
        syserr = state.syserr;
        download->state.basic = state.basic;
        data = download->data;
        download->state.syserr = syserr;
        download->callback(download, data);
      }
      done_uri(proxy_uri);
      goto LABEL_31;
    }
    if ( download )
    {
      progress = inited->progress;
      download->conn = v20;
      download->cached = 0;
      download->progress = progress;
      connection_state_0(S_OK, &state.basic);
      v22 = state.syserr;
      download->state.basic = state.basic;
      download->state.syserr = v22;
      v23 = (download *)v20->downloads.next;
      download->prev = (download *)&v20->downloads;
      download->next = v23;
      v20->downloads.next = download;
      download->next->prev = download;
    }
    add_to_queue(v20);
    connection_state_0(S_WAIT, &state.basic);
    set_connection_state(v20, state);
    register_check_queue();
    return 0;
  }
  else
  {
    if ( download )
    {
      if ( error_state.basic == S_OK )
      {
        if ( proxied_uri && proxy_uri )
          v24 = S_BAD_URL;
        else
          v24 = S_OUT_OF_MEM;
        connection_state_0(v24, &state.basic);
        error_state = state;
      }
      v14 = error_state.syserr;
      download->state.basic = error_state.basic;
      v15 = download->data;
      download->state.syserr = v14;
      download->callback(download, v15);
    }
    if ( proxy_uri )
      done_uri(proxy_uri);
    result = -1;
    if ( proxied_uri )
    {
LABEL_31:
      done_uri(proxied_uri);
      return -1;
    }
  }
  return result;
}

//----- (080B9FE0) --------------------------------------------------------
void __usercall done_connection(connection *conn@<eax>)
{
  if ( conn->state.basic >= S_WAIT )
  {
    assert_failed = 0;
    set_connection_state(conn, (connection_state)4294867293LL);
  }
  conn->next->prev = conn->prev;
  conn->prev->next = conn->next;
  notify_connection_callbacks(conn);
  if ( conn->referrer )
    done_uri(conn->referrer);
  done_uri(conn->uri);
  done_uri(conn->proxied_uri);
  mem_free(conn->socket);
  mem_free(conn->data_socket);
  done_progress(conn->progress);
  mem_free(conn);
}

//----- (080BA080) --------------------------------------------------------
int __usercall do_keepalive_connection_callback@<eax>(keepalive_connection *keep_conn@<eax>)
{
  uri *proxied_uri; // edi
  uri *proxy_uri; // esi
  connection *inited; // eax
  void (*done)(connection *); // edi
  int priority; // eax
  connection *next; // ebx
  unsigned int i; // esi
  connection *conn; // [esp+1Ch] [ebp-1Ch]

  proxied_uri = get_proxied_uri(keep_conn->uri);
  proxy_uri = get_proxy_uri(keep_conn->uri, 0);
  if ( !proxy_uri )
  {
    if ( !proxied_uri )
      return 0;
    goto LABEL_3;
  }
  if ( !proxied_uri )
  {
LABEL_4:
    if ( proxy_uri )
      done_uri(proxy_uri);
    return 0;
  }
  inited = init_connection(proxy_uri, proxied_uri, 0, 0LL, CACHE_MODE_NEVER, PRI_CANCEL);
  conn = inited;
  if ( !inited )
  {
LABEL_3:
    done_uri(proxied_uri);
    goto LABEL_4;
  }
  done = keep_conn->done;
  priority = get_priority(inited);
  next = (connection *)connection_queue.next;
  for ( i = priority; next != (connection *)&connection_queue; next = next->next )
  {
    if ( i < get_priority(next) )
      break;
  }
  conn->next = next->prev->next;
  conn->prev = next->prev;
  next->prev->next = conn;
  conn->next->prev = conn;
  if ( has_keepalive_connection(conn) && add_host_connection(conn) )
  {
    ++active_connections;
    *((_BYTE *)conn + 120) |= 1u;
    done(conn);
    return 1;
  }
  else
  {
    free_connection_data(conn);
    done_connection(conn);
    return 0;
  }
}

//----- (080BA1C0) --------------------------------------------------------
int __cdecl has_keepalive_connection(connection *conn)
{
  uri *uri; // eax
  uri *next; // ebx
  const uri *string; // eax
  int protocol; // edx

  uri = conn->uri;
  if ( !uri->host )
    return 0;
  next = (uri *)keepalive_connections.next;
  if ( keepalive_connections.next == &keepalive_connections )
    return 0;
  while ( !compare_uri((const uri *)next->ip_family, uri, URI_KEEPALIVE) )
  {
    next = (uri *)next->string;
    if ( next == (uri *)&keepalive_connections )
      return 0;
    uri = conn->uri;
  }
  conn->socket->fd = (int)next->post;
  *((_BYTE *)conn->socket + 36) = (int)next->fragment & 1 | *((_BYTE *)conn->socket + 36) & 0xFE;
  string = (const uri *)next->string;
  protocol = next->protocol;
  next->post = (unsigned __int8 *)-1;
  next->user = 0;
  string->protocol = protocol;
  *(_DWORD *)next->protocol = next->string;
  if ( next->post != (unsigned __int8 *)-1 )
    close((int)next->post);
  done_uri((uri *)next->ip_family);
  mem_free(next);
  return 1;
}

//----- (080BA2A0) --------------------------------------------------------
void check_keepalive_connections()
{
  keepalive_connection *next; // ebx
  list_head_elinks *v1; // edi
  int v2; // esi
  void *prev; // ebx
  timeval_T age; // [esp+10h] [ebp-28h] BYREF
  timeval_T now; // [esp+18h] [ebp-20h] BYREF

  timeval_now(&now);
  kill_timer(&keepalive_timeout);
  next = (keepalive_connection *)keepalive_connections.next;
  v1 = *(list_head_elinks **)keepalive_connections.next;
  if ( keepalive_connections.next != &keepalive_connections )
  {
    v2 = 0;
    while ( 1 )
    {
      if ( can_read(next->socket)
        || (timeval_sub(&age, &next->creation_time, &now), timeval_cmp(&age, &next->timeout) > 0) )
      {
        if ( !next->done || !do_keepalive_connection_callback(next) )
        {
          next->next->prev = next->prev;
          next->prev->next = next->next;
          if ( next->socket != -1 )
            close(next->socket);
          done_uri(next->uri);
          mem_free(next);
        }
      }
      else
      {
        ++v2;
      }
      next = (keepalive_connection *)v1;
      if ( &keepalive_connections == v1 )
        break;
      v1 = (list_head_elinks *)v1->next;
    }
    while ( v2 > 30 )
    {
      if ( assert_failed
        || (assert_failed = keepalive_connections.next == &keepalive_connections) != 0
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
            errline = 656,
            elinks_internal("assertion !list_empty(keepalive_connections) failed: keepalive list empty"),
            assert_failed) )
      {
        assert_failed = 0;
        return;
      }
      prev = keepalive_connections.prev;
      if ( !*((_DWORD *)keepalive_connections.prev + 3)
        || !do_keepalive_connection_callback((keepalive_connection *)keepalive_connections.prev) )
      {
        *(_DWORD *)(*(_DWORD *)prev + 4) = *((_DWORD *)prev + 1);
        **((_DWORD **)prev + 1) = *(_DWORD *)prev;
        if ( *((_DWORD *)prev + 9) != -1 )
          close(*((_DWORD *)prev + 9));
        done_uri(*((uri **)prev + 2));
        mem_free(prev);
      }
      --v2;
    }
    if ( keepalive_connections.next != &keepalive_connections )
      install_timer(&keepalive_timeout, 20000, keepalive_timer, 0);
  }
}

//----- (080BA470) --------------------------------------------------------
void __cdecl keepalive_timer(void *x)
{
  keepalive_timeout = 0;
  check_keepalive_connections();
}

//----- (080BA490) --------------------------------------------------------
void __cdecl add_keepalive_connection(connection *conn, int timeout_in_seconds, void (*done)(connection *))
{
  void (*v3)(connection *); // edx
  bool v4; // zf
  uri *uri; // edi
  unsigned __int8 *host; // ecx
  timeval_T *v7; // eax
  timeval_T *v8; // esi
  void *next; // eax
  void (*v10)(connection *); // [esp+28h] [ebp-20h]
  void (*v11)(connection *); // [esp+28h] [ebp-20h]

  v3 = done;
  if ( assert_failed
    || (v4 = conn->socket->fd != -1, assert_failed = conn->socket->fd == -1, !v4)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
        errline = 594,
        elinks_internal("assertion conn->socket->fd != -1 failed: keepalive connection not connected"),
        v3 = done,
        assert_failed) )
  {
    assert_failed = 0;
    goto LABEL_6;
  }
  uri = conn->uri;
  host = uri->host;
  assert_failed = host == 0;
  if ( host
    || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
        errline = 539,
        v11 = v3,
        elinks_internal("assertion uri->host failed!"),
        v3 = v11,
        !assert_failed) )
  {
    v10 = v3;
    v7 = (timeval_T *)mem_calloc(1u, 0x28u);
    v3 = v10;
    v8 = v7;
    if ( v7 )
    {
      ++uri->object.refcount;
      v7[1].usec = (int)v10;
      v7[1].sec = (int)uri;
      LOBYTE(v7[4].sec) = *((_BYTE *)conn->socket + 36) & 1 | v7[4].sec & 0xFE;
      v7[4].usec = conn->socket->fd;
      timeval_from_seconds(v7 + 2, timeout_in_seconds);
      timeval_now(v8 + 3);
      set_handlers(conn->socket->fd, 0, 0, 0, 0);
      conn->socket->fd = -1;
      next = keepalive_connections.next;
      v8->usec = (int)&keepalive_connections;
      v8->sec = (int)next;
      keepalive_connections.next = v8;
      *(_DWORD *)(v8->sec + 4) = v8;
LABEL_6:
      free_connection_data(conn);
      done_connection(conn);
      register_check_queue();
      return;
    }
  }
  else
  {
    assert_failed = 0;
  }
  if ( !v3 )
    goto LABEL_6;
  v3(conn);
}

//----- (080BA670) --------------------------------------------------------
void __cdecl abort_connection(connection *conn, connection_state state)
{
  if ( !assert_failed )
  {
    assert_failed = state.basic >= S_WAIT;
    if ( state.basic >= S_WAIT )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 739;
      elinks_internal(
        "assertion is_in_result_state(state) failed: connection didn't end in result state (%d)",
        state.basic);
    }
  }
  if ( state.basic == S_OK && conn->cached )
    normalize_cache_entry(conn->cached, conn->from);
  set_connection_state(conn, state);
  if ( (*((_BYTE *)conn + 120) & 1) != 0 )
    free_connection_data(conn);
  done_connection(conn);
  register_check_queue();
}

//----- (080BA730) --------------------------------------------------------
void abort_background_connections()
{
  connection *next; // ebx
  list_head_elinks *v1; // esi
  list_head_elinks *v2; // eax
  int v3; // eax
  connection *v4; // [esp+0h] [ebp-28h]

  next = (connection *)connection_queue.next;
  v1 = *(list_head_elinks **)connection_queue.next;
  if ( connection_queue.next != &connection_queue )
  {
    while ( 1 )
    {
      if ( (unsigned int)get_priority(next) <= 5 )
      {
        v2 = (list_head_elinks *)v1->next;
        next = (connection *)v1;
        if ( &connection_queue == v1 )
          return;
      }
      else
      {
        if ( assert_failed )
        {
          assert_failed = 0;
          v3 = -100003;
        }
        else
        {
          assert_failed = 0;
          v3 = -100001;
        }
        v4 = next;
        next = (connection *)v1;
        abort_connection(v4, (connection_state)(unsigned int)v3);
        v2 = (list_head_elinks *)v1->next;
        if ( &connection_queue == v1 )
          return;
      }
      v1 = v2;
    }
  }
}

//----- (080BA7C0) --------------------------------------------------------
void abort_all_connections()
{
  connection *i; // eax
  int v1; // edx
  keepalive_connection *next; // ebx

  for ( i = (connection *)connection_queue.next;
        connection_queue.next != &connection_queue;
        i = (connection *)connection_queue.next )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v1 = -100003;
    }
    else
    {
      assert_failed = 0;
      v1 = -100001;
    }
    abort_connection(i, (connection_state)(unsigned int)v1);
  }
  while ( 1 )
  {
    next = (keepalive_connection *)keepalive_connections.next;
    if ( keepalive_connections.next == &keepalive_connections )
      break;
    while ( !next->done || !do_keepalive_connection_callback(next) )
    {
      next->next->prev = next->prev;
      next->prev->next = next->next;
      if ( next->socket != -1 )
        close(next->socket);
      done_uri(next->uri);
      mem_free(next);
      next = (keepalive_connection *)keepalive_connections.next;
      if ( keepalive_connections.next == &keepalive_connections )
        goto LABEL_13;
    }
  }
LABEL_13:
  check_keepalive_connections();
}

//----- (080BA8A0) --------------------------------------------------------
void __cdecl done_connection_socket(socket *socket, connection_state state)
{
  if ( !assert_failed )
  {
    assert_failed = socket == 0;
    if ( !socket )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 260;
      elinks_internal("assertion socket failed!");
    }
  }
  abort_connection((connection *)socket->conn, state);
}

//----- (080BA920) --------------------------------------------------------
void __cdecl cancel_download(download *download, int interrupt)
{
  connection *conn; // ebx
  connection_basic_state v3; // eax
  download *prev; // edx
  download *next; // eax
  connection *v6; // ebx
  connection_state state; // [esp+18h] [ebp-20h] BYREF

  if ( assert_failed
    || (assert_failed = download == 0, !download)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
        errline = 1006,
        elinks_internal("assertion download failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( download->state.basic >= S_WAIT )
  {
    conn = download->conn;
    assert_failed = conn == 0;
    if ( conn
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
          errline = 1013,
          elinks_internal("assertion download->conn != NULL failed: last state is %d", download->state.basic),
          !assert_failed) )
    {
      assert_failed = 0;
      v3 = S_INTERRUPTED;
    }
    else
    {
      assert_failed = 0;
      v3 = S_INTERNAL;
    }
    download->state.basic = v3;
    prev = download->prev;
    next = download->next;
    download->state.syserr = 0;
    next->prev = prev;
    download->prev->next = download->next;
    v6 = download->conn;
    --v6->pri[download->pri];
    if ( assert_failed
      || (assert_failed = (unsigned int)v6->pri[download->pri] >> 31) != 0
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c",
          errline = 1023,
          elinks_internal("assertion conn->pri[download->pri] >= 0 failed: priority counter underflow"),
          assert_failed) )
    {
      assert_failed = 0;
      v6->pri[download->pri] = 0;
    }
    if ( v6->downloads.next == &v6->downloads )
    {
      ++v6->pri[6];
      if ( interrupt || (*((_BYTE *)v6 + 120) & 4) != 0 )
      {
        connection_state_0(S_INTERRUPTED, &state.basic);
        abort_connection(v6, state);
      }
    }
    sort_queue();
    register_check_queue();
  }
}

//----- (080BAB20) --------------------------------------------------------
void __cdecl move_download(download *old, download *newa, connection_priority newpri)
{
  connection_priority pri; // eax
  connection *conn; // edi
  int syserr; // ecx
  connection_basic_state basic; // edx
  int v7; // ecx
  connection *v8; // edx
  download *next; // edx
  void *data; // eax

  pri = newpri;
  if ( !assert_failed )
  {
    assert_failed = old == 0;
    if ( !old )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 1046;
      elinks_internal("assertion old failed!");
      pri = newpri;
    }
  }
  conn = old->conn;
  newa->conn = conn;
  newa->cached = old->cached;
  syserr = old->prev_error.syserr;
  newa->prev_error.basic = old->prev_error.basic;
  newa->prev_error.syserr = syserr;
  newa->progress = old->progress;
  basic = old->state.basic;
  v7 = old->state.syserr;
  newa->pri = pri;
  newa->state.basic = basic;
  newa->state.syserr = v7;
  if ( old->state.basic < S_WAIT )
  {
    if ( newa->callback )
    {
      data = newa->data;
      newa->conn = 0;
      newa->progress = 0;
      newa->callback(newa, data);
    }
  }
  else
  {
    if ( !assert_failed )
    {
      v8 = old->conn;
      assert_failed = v8 == 0;
      if ( !v8 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
        errline = 1072;
        elinks_internal("assertion old->conn != NULL failed: last state is %d", old->state.basic);
      }
      pri = newa->pri;
    }
    ++conn->pri[pri];
    next = (download *)conn->downloads.next;
    newa->prev = (download *)&conn->downloads;
    newa->next = next;
    conn->downloads.next = newa;
    newa->next->prev = newa;
    sort_queue();
    cancel_download(old, 0);
  }
}

//----- (080BAC90) --------------------------------------------------------
void __usercall run_connection(connection *conn@<eax>)
{
  protocol_handler_T *protocol_handler; // esi
  int v3; // eax
  int v4; // eax
  int v5; // eax

  protocol_handler = get_protocol_handler((protocol)conn->uri->protocol);
  if ( assert_failed )
    goto LABEL_7;
  assert_failed = protocol_handler == 0;
  if ( protocol_handler )
  {
    v3 = *((_BYTE *)conn + 120) & 1;
    assert_failed = v3;
    if ( !v3 )
      goto LABEL_4;
LABEL_6:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
    errline = 719;
    elinks_internal("assertion !conn->running failed: connection already running");
    if ( assert_failed )
    {
LABEL_7:
      assert_failed = 0;
      return;
    }
    goto LABEL_4;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
  errline = 717;
  elinks_internal("assertion func failed!");
  if ( assert_failed )
    goto LABEL_7;
  v5 = *((_BYTE *)conn + 120) & 1;
  assert_failed = v5;
  if ( v5 )
    goto LABEL_6;
LABEL_4:
  if ( add_host_connection(conn) )
  {
    ++active_connections;
    *((_BYTE *)conn + 120) |= 1u;
    protocol_handler(conn);
  }
  else
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v4 = -100003;
    }
    else
    {
      assert_failed = 0;
      v4 = -100004;
    }
    set_connection_state(conn, (connection_state)(unsigned int)v4);
    done_connection(conn);
  }
}

//----- (080BADE0) --------------------------------------------------------
void __cdecl retry_connection(connection *conn, connection_state state)
{
  int v2; // eax
  int syserr; // edx
  int max_tries; // [esp+1Ch] [ebp-1Ch]

  max_tries = get_opt_(config_options, "connection.retries")->number;
  if ( !assert_failed )
  {
    assert_failed = state.basic >= S_WAIT;
    if ( state.basic >= S_WAIT )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 758;
      elinks_internal(
        "assertion is_in_result_state(state) failed: connection didn't end in result state (%d)",
        state.basic);
    }
  }
  set_connection_state(conn, state);
  free_connection_data(conn);
  if ( conn->uri->post || max_tries && (v2 = conn->tries + 1, conn->tries = v2, max_tries <= v2) )
  {
    done_connection(conn);
    register_check_queue();
  }
  else
  {
    syserr = conn->state.syserr;
    conn->prev_error.basic = conn->state.basic;
    conn->prev_error.syserr = syserr;
    run_connection(conn);
  }
}

//----- (080BAED0) --------------------------------------------------------
void __cdecl retry_connection_socket(socket *socket, connection_state state)
{
  if ( !assert_failed )
  {
    assert_failed = socket == 0;
    if ( !socket )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/connection.c";
      errline = 253;
      elinks_internal("assertion socket failed!");
    }
  }
  retry_connection((connection *)socket->conn, state);
}

//----- (080BAF50) --------------------------------------------------------
void check_queue()
{
  connection *v0; // ebx
  int priority; // edi
  connection *v2; // esi
  const uri *uri; // eax
  connection *v4; // edi
  connection *v5; // esi
  const uri *v6; // ebx
  connection *i; // ebx
  const uri *host_connection; // eax
  list_head_elinks *v9; // esi
  const uri *v10; // eax
  list_head_elinks *v11; // esi
  list_head_elinks *prev; // ebx
  int v13; // eax
  connection *next; // [esp+10h] [ebp-28h]
  int max_conns; // [esp+14h] [ebp-24h]
  int max_conns_to_host; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]

  max_conns_to_host = get_opt_(config_options, "connection.max_connections_to_host")->number;
  max_conns = get_opt_(config_options, "connection.max_connections")->number;
LABEL_2:
  while ( 2 )
  {
    next = (connection *)connection_queue.next;
    check_keepalive_connections();
    if ( next != (connection *)&connection_queue )
    {
LABEL_3:
      v0 = next;
      priority = get_priority(next);
      if ( priority == get_priority(next) )
      {
        while ( 1 )
        {
          v2 = v0->next;
          if ( v0->state.basic == S_WAIT )
          {
            uri = v0->uri;
            if ( uri->host )
            {
              if ( keepalive_connections.next != &keepalive_connections )
              {
                v17 = priority;
                v4 = v0->next;
                v5 = v0;
                v6 = (const uri *)keepalive_connections.next;
                while ( !compare_uri((const uri *)v6->ip_family, uri, URI_KEEPALIVE) )
                {
                  v6 = (const uri *)v6->string;
                  if ( v6 == (const uri *)&keepalive_connections )
                  {
                    v2 = v4;
                    priority = v17;
                    goto LABEL_15;
                  }
                  uri = v5->uri;
                }
                i = v5;
                v2 = v4;
                priority = v17;
                host_connection = get_host_connection(i);
                if ( host_connection && max_conns_to_host <= host_connection->ip_family )
                {
                  if ( !try_to_suspend_connection(i, (uri *)host_connection->user) )
                    goto LABEL_2;
                }
                else
                {
                  if ( max_conns > active_connections )
                  {
LABEL_34:
                    run_connection(i);
                    goto LABEL_2;
                  }
                  if ( !try_to_suspend_connection(i, 0) )
                    goto LABEL_2;
                }
              }
            }
          }
LABEL_15:
          if ( v2 != (connection *)&connection_queue )
          {
            v0 = v2;
            if ( priority == get_priority(v2) )
              continue;
          }
          break;
        }
      }
      for ( i = next; ; i = (connection *)v9 )
      {
        if ( priority != get_priority(i) )
        {
          next = i;
          if ( i == (connection *)&connection_queue )
            goto LABEL_41;
          goto LABEL_3;
        }
        v9 = (list_head_elinks *)i->next;
        if ( i->state.basic )
          goto LABEL_18;
        v10 = get_host_connection(i);
        if ( v10 )
        {
          if ( max_conns_to_host <= v10->ip_family )
            break;
        }
        if ( max_conns > active_connections )
          goto LABEL_34;
        if ( !try_to_suspend_connection(i, 0) )
          goto LABEL_2;
        if ( v9 == &connection_queue )
        {
LABEL_27:
          v11 = &connection_queue;
          goto LABEL_28;
        }
LABEL_19:
        ;
      }
      if ( !try_to_suspend_connection(i, (uri *)v10->user) )
        continue;
LABEL_18:
      if ( v9 == &connection_queue )
        goto LABEL_27;
      goto LABEL_19;
    }
    break;
  }
LABEL_41:
  v11 = (list_head_elinks *)next;
LABEL_28:
  prev = (list_head_elinks *)connection_queue.prev;
  if ( v11 != connection_queue.prev )
  {
    while ( (unsigned int)get_priority((connection *)prev) > 5 )
    {
      if ( !prev[10].next )
      {
        if ( assert_failed )
        {
          assert_failed = 0;
          v13 = -100003;
        }
        else
        {
          assert_failed = 0;
          v13 = -100001;
        }
        set_connection_state((connection *)prev, (connection_state)(unsigned int)v13);
        done_connection((connection *)prev);
        goto LABEL_28;
      }
      prev = (list_head_elinks *)prev->prev;
      if ( v11 == prev )
        return;
    }
  }
}

//----- (080BB1F0) --------------------------------------------------------
void __usercall del_dns_cache_entry(dnsentry *dnsentry@<eax>)
{
  sockaddr_storage *addr; // eax

  dnsentry->next->prev = dnsentry->prev;
  dnsentry->prev->next = dnsentry->next;
  addr = dnsentry->addr;
  if ( addr )
    mem_free(addr);
  mem_free(dnsentry);
}

//----- (080BB230) --------------------------------------------------------
void __cdecl shrink_dns_cache(int whole)
{
  dnsentry *next; // eax
  list_head_elinks *v2; // ebx
  dnsentry *v3; // ebx
  list_head_elinks *v4; // esi
  timeval_T age; // [esp+18h] [ebp-30h] BYREF
  timeval_T max_age; // [esp+20h] [ebp-28h] BYREF
  timeval_T now; // [esp+28h] [ebp-20h] BYREF

  if ( whole )
  {
    next = (dnsentry *)dns_cache.next;
    v2 = *(list_head_elinks **)dns_cache.next;
    if ( dns_cache.next != &dns_cache )
    {
      while ( 1 )
      {
        del_dns_cache_entry(next);
        next = (dnsentry *)v2;
        if ( &dns_cache == v2 )
          break;
        v2 = (list_head_elinks *)v2->next;
      }
    }
  }
  else
  {
    timeval_from_seconds(&max_age, 3600);
    timeval_now(&now);
    v3 = (dnsentry *)dns_cache.next;
    v4 = *(list_head_elinks **)dns_cache.next;
    if ( dns_cache.next != &dns_cache )
    {
      while ( 1 )
      {
        timeval_sub(&age, &v3->creation_time, &now);
        if ( timeval_cmp(&age, &max_age) > 0 )
          del_dns_cache_entry(v3);
        v3 = (dnsentry *)v4;
        if ( &dns_cache == v4 )
          break;
        v4 = (list_head_elinks *)v4->next;
      }
    }
  }
}

//----- (080BB2F0) --------------------------------------------------------
void __usercall done_dns_lookup(dnsquery *query@<eax>, dns_result result@<edx>)
{
  int h; // eax
  list_head_elinks *next; // esi
  void *v5; // eax
  char *v6; // eax
  void *v7; // eax
  char *p; // [esp+2Ch] [ebp-2Ch]
  sockaddr_storage *src; // [esp+30h] [ebp-28h]
  size_t n; // [esp+38h] [ebp-20h]
  int addrno; // [esp+3Ch] [ebp-1Ch]

  h = query->h;
  if ( h != -1 )
  {
    set_handlers(h, 0, 0, 0, 0);
    close(query->h);
    query->h = -1;
  }
  *query->queryref = 0;
  if ( query->done )
  {
    next = (list_head_elinks *)dns_cache.next;
    if ( dns_cache.next != &dns_cache )
    {
      while ( c_strcasecmp((const char *)&next[3], (const char *)query->name) )
      {
        next = (list_head_elinks *)next->next;
        if ( next == &dns_cache )
          goto LABEL_14;
      }
      if ( next != dns_cache.next )
      {
        *((_DWORD *)next->next + 1) = next->prev;
        *(_DWORD *)next->prev = next->next;
        v5 = dns_cache.next;
        next->prev = &dns_cache;
        next->next = v5;
        dns_cache.next = next;
        *((_DWORD *)next->next + 1) = next;
      }
      if ( next )
      {
        if ( result == DNS_ERROR )
        {
          query->done(query->data, next[1].next, next[1].prev);
          goto done;
        }
        del_dns_cache_entry((dnsentry *)next);
      }
      next = &dns_cache;
    }
LABEL_14:
    if ( result == DNS_SUCCESS )
    {
      addrno = query->addrno;
      src = query->addr;
      n = strlen((const char *)query->name);
      if ( !assert_failed )
      {
        assert_failed = addrno <= 0;
        if ( addrno <= 0 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
          errline = 107;
          elinks_internal("assertion addrno > 0 failed!");
        }
      }
      v6 = (char *)mem_calloc(1u, n + 28);
      if ( v6 )
      {
        p = v6;
        v7 = mem_alloc(addrno << 7);
        *((_DWORD *)p + 2) = v7;
        if ( v7 )
        {
          memcpy(p + 24, query->name, n);
          memcpy(*((void **)p + 2), src, addrno << 7);
          *((_DWORD *)p + 3) = addrno;
          timeval_now((timeval_T *)p + 2);
          *(_DWORD *)p = next->next;
          *((_DWORD *)p + 1) = next;
          next->next = p;
          *(_DWORD *)(*(_DWORD *)p + 4) = p;
        }
        else
        {
          mem_free(p);
        }
      }
    }
    query->done(query->data, query->addr, query->addrno);
  }
done:
  if ( query->addr )
    mem_free(query->addr);
  query->addr = 0;
  mem_free(query);
}

//----- (080BB540) --------------------------------------------------------
void __cdecl kill_dns_request(void **queryref)
{
  dnsquery *v1; // eax

  v1 = (dnsquery *)*queryref;
  if ( !assert_failed )
  {
    assert_failed = v1 == 0;
    if ( !v1 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
      errline = 534;
      elinks_internal("assertion query failed!");
      v1 = 0;
    }
  }
  v1->done = 0;
  done_dns_lookup(v1, DNS_ERROR);
}

//----- (080BB5A0) --------------------------------------------------------
void __cdecl async_dns_error(dnsquery *query)
{
  done_dns_lookup(query, DNS_ERROR);
}

//----- (080BB5C0) --------------------------------------------------------
int __usercall read_dns_data@<eax>(int h@<eax>, void *data@<edx>, size_t datalen@<ecx>)
{
  unsigned int v3; // edi
  ssize_t v6; // eax
  size_t v8; // [esp+1Ch] [ebp-1Ch]

  v3 = 0;
  do
  {
    v8 = datalen;
    v6 = read(h, (char *)data + v3, datalen - v3);
    datalen = v8;
    if ( v6 <= 0 )
      return -1;
    v3 += v6;
  }
  while ( v8 > v3 );
  if ( assert_failed )
    return 0;
  assert_failed = v3 != v8;
  if ( v3 == v8 )
    return 0;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
  errline = 303;
  elinks_internal("assertion done == datalen failed!");
  return 0;
}

//----- (080BB660) --------------------------------------------------------
void __cdecl async_dns_reader(dnsquery *query)
{
  sockaddr_storage *addr; // eax
  int v2; // esi

  if ( set_blocking_fd(query->h) < 0 || read_dns_data(query->h, &query->addrno, 4u) == -1 )
  {
done:
    if ( query->addr )
      mem_free(query->addr);
    goto LABEL_11;
  }
  addr = (sockaddr_storage *)mem_calloc(query->addrno, 0x80u);
  query->addr = addr;
  if ( !addr )
  {
LABEL_11:
    query->addr = 0;
    done_dns_lookup(query, DNS_ERROR);
    return;
  }
  if ( query->addrno > 0 )
  {
    v2 = 0;
    while ( read_dns_data(query->h, &addr[v2], 0x80u) != -1 )
    {
      if ( query->addrno <= ++v2 )
        goto LABEL_12;
      addr = query->addr;
    }
    goto done;
  }
LABEL_12:
  done_dns_lookup(query, DNS_SUCCESS);
}

//----- (080BB720) --------------------------------------------------------
int __usercall write_dns_data@<eax>(int h@<eax>, void *data@<edx>, size_t datalen@<ecx>)
{
  unsigned int v3; // edi
  ssize_t v6; // eax
  size_t v8; // [esp+1Ch] [ebp-1Ch]

  v3 = 0;
  do
  {
    v8 = datalen;
    v6 = write(h, (char *)data + v3, datalen - v3);
    datalen = v8;
    if ( v6 < 0 )
      return -1;
    v3 += v6;
  }
  while ( v8 > v3 );
  if ( assert_failed )
    return 0;
  assert_failed = v3 != v8;
  if ( v3 == v8 )
    return 0;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
  errline = 256;
  elinks_internal("assertion done == datalen failed!");
  return 0;
}

//----- (080BB7C0) --------------------------------------------------------
dns_result __cdecl do_real_lookup(unsigned __int8 *name, sockaddr_storage **addrs, int *addrno, int in_thread)
{
  dns_result result; // eax
  unsigned int i; // edx
  addrinfo *v6; // eax
  int v7; // edi
  size_t v8; // edx
  sockaddr_storage *v9; // eax
  addrinfo *v10; // edi
  struct addrinfo *v11; // eax
  bool v12; // zf
  sockaddr_storage *v13; // eax
  sockaddr_storage *v14; // [esp+18h] [ebp-50h]
  int v15; // [esp+1Ch] [ebp-4Ch]
  addrinfo hint; // [esp+2Ch] [ebp-3Ch] BYREF
  addrinfo *ai; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( !addrs )
    return -1;
  if ( !name )
    return -1;
  if ( !addrno )
    return -1;
  for ( i = 0; i < 0x20; i += 4 )
    *(int *)((char *)&hint.ai_flags + i) = 0;
  hint.ai_family = 0;
  hint.ai_socktype = 1;
  if ( getaddrinfo((const char *)name, 0, &hint, &ai) )
    return -1;
  v6 = ai;
  v7 = 0;
  v8 = 0;
  if ( ai )
  {
    do
    {
      v6 = v6->ai_next;
      ++v7;
    }
    while ( v6 );
    v8 = v7;
  }
  v9 = (sockaddr_storage *)(in_thread ? calloc(v8, 0x80u) : mem_calloc(v8, 0x80u));
  *addrs = v9;
  if ( !v9 )
    return -1;
  *addrno = v7;
  v10 = ai;
  v11 = 0;
  v15 = 0;
  if ( ai )
  {
    while ( 1 )
    {
      v13 = *addrs;
      if ( assert_failed )
        break;
      v12 = v10->ai_addrlen <= 0x80;
      assert_failed = v10->ai_addrlen > 0x80;
      if ( !v12 )
      {
        v14 = v13;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
        errline = 211;
        elinks_internal("assertion ai_cur->ai_addrlen <= sizeof(*addr) failed!");
        v13 = v14;
        if ( assert_failed )
          break;
      }
      memcpy(&v13[v15], v10->ai_addr, v10->ai_addrlen);
      v10 = v10->ai_next;
      ++v15;
      if ( !v10 )
      {
        v11 = ai;
        goto LABEL_25;
      }
    }
    assert_failed = 0;
    freeaddrinfo(ai);
    if ( in_thread )
      free(*addrs);
    else
      mem_free(*addrs);
    *addrs = 0;
    result = DNS_ERROR;
    *addrno = 0;
  }
  else
  {
LABEL_25:
    freeaddrinfo(v11);
    return 0;
  }
  return result;
}

//----- (080BB980) --------------------------------------------------------
void __cdecl async_dns_writer(void *data, int h)
{
  int v2; // ebx
  int addrno; // [esp+18h] [ebp-10h] BYREF
  sockaddr_storage *addrs; // [esp+1Ch] [ebp-Ch] BYREF

  if ( do_real_lookup((unsigned __int8 *)data, &addrs, &addrno, 1) != DNS_ERROR
    && set_blocking_fd(h) >= 0
    && write_dns_data(h, &addrno, 4u) != -1 )
  {
    if ( addrno <= 0 )
    {
LABEL_9:
      free(addrs);
    }
    else
    {
      v2 = 0;
      while ( write_dns_data(h, &addrs[v2], 0x80u) != -1 )
      {
        if ( addrno <= ++v2 )
          goto LABEL_9;
      }
    }
  }
}

//----- (080BBA30) --------------------------------------------------------
dns_result __usercall init_dns_lookup@<eax>(
        unsigned __int8 *name@<eax>,
        void **queryref@<edx>,
        dns_callback_T done@<ecx>,
        void *data)
{
  dnsquery *v6; // eax
  dnsquery *v7; // ebx
  size_t v8; // eax
  int started; // eax
  int v10; // esi
  dns_result v12; // esi
  size_t n; // [esp+28h] [ebp-20h]

  n = strlen((const char *)name);
  v6 = (dnsquery *)mem_calloc(1u, n + 28);
  v7 = v6;
  if ( !v6 )
  {
    v10 = -1;
    done(data, 0, 0);
    return v10;
  }
  v6->done = done;
  v6->data = data;
  memcpy(v6->name, name, n);
  v7->queryref = (dnsquery **)queryref;
  *queryref = v7;
  if ( get_opt_(config_options, "connection.async_dns")->number )
  {
    v8 = strlen((const char *)v7->name);
    started = start_thread(async_dns_writer, v7->name, v8 + 1);
    v7->h = started;
    if ( started != -1 )
    {
      v10 = 1;
      set_handlers(started, (select_handler_T)async_dns_reader, 0, (select_handler_T)async_dns_error, v7);
      return v10;
    }
  }
  else
  {
    v7->h = -1;
  }
  v12 = do_real_lookup(v7->name, &v7->addr, &v7->addrno, 0);
  done_dns_lookup(v7, v12);
  return v12;
}

//----- (080BBB70) --------------------------------------------------------
dns_result __cdecl find_host(unsigned __int8 *name, void **queryref, dns_callback_T done, void *data, int no_cache)
{
  list_head_elinks *next; // esi
  void *v6; // eax
  timeval_T max_age; // [esp+28h] [ebp-30h] BYREF
  timeval_T now; // [esp+30h] [ebp-28h] BYREF
  timeval_T age; // [esp+38h] [ebp-20h] BYREF

  if ( !assert_failed )
  {
    assert_failed = queryref == 0;
    if ( !queryref )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
      errline = 501;
      elinks_internal("assertion queryref failed!");
    }
  }
  *queryref = 0;
  if ( no_cache )
    return init_dns_lookup(name, queryref, done, data);
  next = (list_head_elinks *)dns_cache.next;
  if ( dns_cache.next == &dns_cache )
    return init_dns_lookup(name, queryref, done, data);
  while ( c_strcasecmp((const char *)&next[3], (const char *)name) )
  {
    next = (list_head_elinks *)next->next;
    if ( next == &dns_cache )
      return init_dns_lookup(name, queryref, done, data);
  }
  if ( next != dns_cache.next )
  {
    *((_DWORD *)next->next + 1) = next->prev;
    *(_DWORD *)next->prev = next->next;
    v6 = dns_cache.next;
    next->prev = &dns_cache;
    next->next = v6;
    dns_cache.next = next;
    *((_DWORD *)next->next + 1) = next;
  }
  if ( !next )
    return init_dns_lookup(name, queryref, done, data);
  if ( !assert_failed )
  {
    if ( (int)next[1].prev <= 0 )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/dns.c";
      errline = 514;
      elinks_internal("assertion dnsentry && dnsentry->addrno > 0 failed!");
    }
    else
    {
      assert_failed = 0;
    }
  }
  timeval_from_seconds(&max_age, 3600);
  timeval_now(&now);
  timeval_sub(&age, (timeval_T *)&next[2], &now);
  if ( timeval_cmp(&age, &max_age) > 0 )
    return init_dns_lookup(name, queryref, done, data);
  done(data, (sockaddr_storage *)next[1].next, (int)next[1].prev);
  return 0;
}

//----- (080BBD10) --------------------------------------------------------
int __cdecl has_progress(progress *progress)
{
  timeval_T current_speed_after; // [esp+18h] [ebp-10h] BYREF

  timeval_from_milliseconds(&current_speed_after, 100);
  return timeval_cmp(&progress->elapsed, &current_speed_after) >= 0;
}

//----- (080BBD50) --------------------------------------------------------
void __cdecl update_progress(progress *progress, off_t loaded, off_t size, off_t pos)
{
  int usec; // edi
  off_t v5; // kr00_8
  milliseconds_T v6; // eax
  off_t v7; // rax
  int v8; // eax
  timeval_T dis_b_interval; // [esp+40h] [ebp-38h] BYREF
  timeval_T dis_b_max; // [esp+48h] [ebp-30h] BYREF
  timeval_T elapsed; // [esp+50h] [ebp-28h] BYREF
  timeval_T now; // [esp+58h] [ebp-20h] BYREF

  timeval_now(&now);
  timeval_sub(&elapsed, &progress->last_time, &now);
  usec = now.usec;
  progress->last_time.sec = now.sec;
  progress->last_time.usec = usec;
  v5 = loaded - progress->last_loaded;
  progress->loaded = loaded;
  progress->last_loaded = loaded;
  timeval_add_interval(&progress->elapsed, &elapsed);
  timeval_add_interval(&progress->dis_b, &elapsed);
  v6 = mult_ms(100, 50);
  timeval_from_milliseconds(&dis_b_max, v6);
  timeval_from_milliseconds(&dis_b_interval, 100);
  while ( timeval_cmp(&progress->dis_b, &dis_b_max) >= 0 )
  {
    progress->cur_loaded -= progress->data_in_secs[0];
    memmove(progress->data_in_secs, &progress->data_in_secs[1], 0xC4u);
    progress->data_in_secs[49] = 0;
    timeval_sub_interval(&progress->dis_b, &dis_b_interval);
  }
  progress->data_in_secs[49] += v5;
  v7 = progress->cur_loaded + v5;
  progress->cur_loaded = v7;
  progress->current_speed = v7 / 5;
  progress->pos = pos;
  progress->size = size;
  if ( (HIDWORD(size) & (unsigned int)size) != -1 && pos > size )
    progress->size = pos;
  v8 = timeval_div_off_t(progress->loaded, &progress->elapsed);
  progress->average_speed = v8;
  if ( v8 )
    timeval_from_seconds(&progress->estimated_time, (progress->size - progress->pos) / v8);
  install_timer(&progress->timer, 100, progress->timer_func, progress->timer_func_data);
}

//----- (080BBF90) --------------------------------------------------------
void __cdecl done_progress(progress *progress)
{
  timer_id_T timer; // edx

  if ( !assert_failed && (timer = progress->timer, assert_failed = timer != 0, timer) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/progress.c";
    errline = 44;
    elinks_internal("assertion progress->timer == TIMER_ID_UNDEF failed!");
    mem_free(progress);
  }
  else
  {
    mem_free(progress);
  }
}

//----- (080BC000) --------------------------------------------------------
progress *__cdecl init_progress(off_t start)
{
  progress *result; // eax

  result = (progress *)mem_calloc(1u, 0x138u);
  if ( result )
  {
    result->start = start;
    result->timer = 0;
  }
  return result;
}

//----- (080BC050) --------------------------------------------------------
void __cdecl start_update_progress(progress *progress, void (*timer_func)(void *), void *timer_func_data)
{
  int start_high; // edx
  off_t seek; // rax
  int loaded_high; // edx
  progress tmp; // [esp+18h] [ebp-150h] BYREF

  if ( (*((_BYTE *)progress + 40) & 1) == 0 )
  {
    memset(&tmp, 0, sizeof(tmp));
    start_high = HIDWORD(progress->start);
    LODWORD(tmp.start) = progress->start;
    HIDWORD(tmp.start) = start_high;
    seek = progress->seek;
    *((_BYTE *)&tmp + 40) |= 1u;
    tmp.seek = seek;
    qmemcpy(progress, &tmp, sizeof(progress));
  }
  timeval_now(&progress->last_time);
  loaded_high = HIDWORD(progress->loaded);
  LODWORD(progress->last_loaded) = progress->loaded;
  HIDWORD(progress->last_loaded) = loaded_high;
  progress->timer_func = timer_func;
  progress->timer_func_data = timer_func_data;
}

//----- (080BC0E0) --------------------------------------------------------
connection_basic_state *__usercall connection_state_1@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080BC170) --------------------------------------------------------
void __cdecl kill_buffer_data(read_buffer *rb, int n)
{
  int v2; // eax

  if ( assert_failed )
    goto LABEL_8;
  if ( n >= 0 && n <= rb->length )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
  errline = 1012;
  elinks_internal("assertion n >= 0 && n <= rb->length failed: bad number of bytes: %d", n);
  if ( assert_failed )
  {
LABEL_8:
    assert_failed = 0;
    rb->length = 0;
    return;
  }
LABEL_5:
  if ( n )
  {
    v2 = rb->length - n;
    rb->length = v2;
    memmove(rb->data, &rb->data[n], v2);
    rb->freespace += n;
  }
}

//----- (080BC230) --------------------------------------------------------
read_buffer *__cdecl alloc_read_buffer(socket *socket)
{
  read_buffer *v1; // eax
  read_buffer *v2; // ebx
  socket_operation_T done; // edi
  int v5[5]; // [esp+18h] [ebp-20h] BYREF

  v1 = (read_buffer *)mem_calloc(1u, 0x5000u);
  v2 = v1;
  if ( v1 )
  {
    v1->freespace = 20464;
  }
  else
  {
    done = socket->ops->done;
    connection_state_1(S_OUT_OF_MEM, (connection_basic_state *)v5);
    ((void (__cdecl *)(socket *, int, int))done)(socket, v5[0], v5[1]);
  }
  return v2;
}

//----- (080BC2A0) --------------------------------------------------------
socket *__cdecl init_socket(void *conn, socket_operations *ops)
{
  socket *result; // eax

  result = (socket *)mem_calloc(1u, 0x28u);
  if ( result )
  {
    result->fd = -1;
    result->conn = conn;
    result->ops = ops;
  }
  return result;
}

//----- (080BC2E0) --------------------------------------------------------
connect_info *__usercall init_connection_info@<eax>(uri *uri@<eax>, socket_connect_T connect_done@<ecx>)
{
  _DWORD *v4; // eax
  _DWORD *v5; // esi
  int ip_family; // eax

  v4 = mem_calloc(1u, 0x20u);
  v5 = v4;
  if ( v4 )
  {
    v4[3] = connect_done;
    v4[5] = get_uri_port(uri);
    ip_family = uri->ip_family;
    v5[2] = -1;
    *v5 = 0;
    v5[6] = ip_family;
    ++uri->object.refcount;
    v5[7] = uri;
  }
  return (connect_info *)v5;
}

//----- (080BC350) --------------------------------------------------------
void __usercall done_connection_info(socket *socket@<eax>)
{
  connect_info *connect_info; // ebx

  connect_info = socket->connect_info;
  if ( !assert_failed )
  {
    assert_failed = connect_info == 0;
    if ( !connect_info )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 129;
      elinks_internal("assertion socket->connect_info failed!");
    }
  }
  if ( connect_info->dnsquery )
    kill_dns_request(&connect_info->dnsquery);
  if ( connect_info->addr )
    mem_free(connect_info->addr);
  done_uri(connect_info->uri);
  if ( socket->connect_info )
    mem_free(socket->connect_info);
  socket->connect_info = 0;
}

//----- (080BC3F0) --------------------------------------------------------
void __cdecl complete_connect_socket(socket *socket, uri *uri, socket_connect_T done)
{
  void (*v3)(socket *); // ecx
  connect_info *connect_info; // edi
  uri *v5; // eax
  void (__thiscall *v6)(void (*)(socket *), socket *); // eax
  connect_info *inited; // eax
  bool v8; // zf
  socket_operation_T v9; // esi
  int v10[5]; // [esp+18h] [ebp-20h] BYREF

  v3 = done;
  connect_info = socket->connect_info;
  if ( !connect_info )
  {
    if ( !assert_failed )
    {
      assert_failed = uri == 0;
      if ( !uri )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
        errline = 472;
        elinks_internal("assertion uri && socket failed!");
        v3 = done;
      }
    }
    inited = init_connection_info(uri, v3);
    connect_info = inited;
    if ( !inited )
    {
      v9 = socket->ops->done;
      connection_state_1(S_OUT_OF_MEM, (connection_basic_state *)v10);
      ((void (__cdecl *)(socket *, int, int))v9)(socket, v10[0], v10[1]);
      return;
    }
    v8 = (*((_BYTE *)socket + 36) & 2) == 0;
    socket->connect_info = inited;
    if ( v8 )
      goto LABEL_6;
    goto LABEL_9;
  }
  v5 = connect_info->uri;
  if ( !v5 )
    goto LABEL_5;
  if ( (*((_BYTE *)socket + 36) & 4) == 0 )
  {
    del_blacklist_entry(v5, SERVER_BLACKLIST_NO_TLS);
    if ( (*((_BYTE *)socket + 36) & 2) == 0 )
      goto LABEL_6;
LABEL_9:
    if ( !socket->ssl && ssl_connect(socket) < 0 )
      return;
    goto LABEL_6;
  }
  add_blacklist_entry(v5, SERVER_BLACKLIST_NO_TLS);
LABEL_5:
  if ( (*((_BYTE *)socket + 36) & 2) != 0 )
    goto LABEL_9;
LABEL_6:
  v6 = (void (__thiscall *)(void (*)(socket *), socket *))connect_info->done;
  if ( v6 )
    v6(v3, socket);
  done_connection_info(socket);
}
// 80BC440: variable 'v3' is possibly undefined

//----- (080BC530) --------------------------------------------------------
int __cdecl get_pasv_socket(socket *ctrl_socket, sockaddr_storage *addr)
{
  int v2; // ebx
  size_t v3; // esi
  int v4; // eax
  int v5; // ebx
  socket_operation_T retry; // ebx
  int v8; // [esp+8h] [ebp-70h]
  sockaddr *bind_addr; // [esp+18h] [ebp-60h]
  socklen_t len; // [esp+2Ch] [ebp-4Ch] BYREF
  sockaddr_in6 bind_addr6; // [esp+30h] [ebp-48h] BYREF
  sockaddr_in bind_addr4; // [esp+4Ch] [ebp-2Ch] BYREF
  unsigned int v13; // [esp+5Ch] [ebp-1Ch]

  v13 = __readgsdword(0x14u);
  if ( (*((_BYTE *)ctrl_socket + 36) & 1) != 0 )
  {
    v2 = 10;
    bind_addr = (sockaddr *)&bind_addr6;
    v3 = 28;
  }
  else
  {
    v2 = 2;
    bind_addr = (sockaddr *)&bind_addr4;
    v3 = 16;
  }
  memset(addr, 0, v3);
  memset(bind_addr, 0, v3);
  len = v3;
  if ( getsockname(ctrl_socket->fd, (struct sockaddr *)addr, &len) )
    goto LABEL_16;
  v4 = socket(v2, 1, 6);
  v5 = v4;
  if ( v4 < 0 )
  {
    if ( v4 == -1 )
    {
LABEL_16:
      retry = ctrl_socket->ops->retry;
      v8 = *__errno_location();
      ((void (__cdecl *)(socket *, int, int))retry)(ctrl_socket, -1, v8);
      return -1;
    }
LABEL_17:
    close(v5);
    goto LABEL_16;
  }
  if ( set_nonblocking_fd(v4) < 0 )
    goto LABEL_17;
  memcpy(bind_addr, addr, v3);
  if ( (*((_BYTE *)ctrl_socket + 36) & 1) != 0 )
    bind_addr6.sin6_port = 0;
  else
    bind_addr4.sin_port = 0;
  if ( bind(v5, bind_addr, v3) )
    goto LABEL_17;
  len = v3;
  if ( getsockname(v5, (struct sockaddr *)addr, &len) || listen(v5, 1) )
    goto LABEL_17;
  set_ip_tos_throughput(v5);
  return v5;
}

//----- (080BC700) --------------------------------------------------------
void __cdecl close_socket(socket *socket)
{
  int fd; // eax

  fd = socket->fd;
  if ( socket->fd != -1 )
  {
    if ( socket->ssl )
    {
      ssl_close(socket);
      fd = socket->fd;
    }
    close(fd);
    set_handlers(socket->fd, 0, 0, 0, 0);
    socket->fd = -1;
  }
}

//----- (080BC760) --------------------------------------------------------
void __cdecl done_socket(socket *socket)
{
  void *write_buffer; // eax
  socket **i; // eax

  close_socket(socket);
  if ( socket->connect_info )
    done_connection_info(socket);
  if ( socket->read_buffer )
    mem_free(socket->read_buffer);
  write_buffer = socket->write_buffer;
  socket->read_buffer = 0;
  if ( write_buffer )
    mem_free(write_buffer);
  socket->write_buffer = 0;
  for ( i = (socket **)socket_weak_refs.next; i != (socket **)&socket_weak_refs; i = (socket **)*i )
  {
    while ( i[2] != socket )
    {
      i = (socket **)*i;
      if ( i == (socket **)&socket_weak_refs )
        return;
    }
    i[2] = 0;
  }
}

//----- (080BC7F0) --------------------------------------------------------
void __cdecl exception(socket *socket)
{
  socket_operation_T retry; // edx
  int v2; // ecx

  retry = socket->ops->retry;
  if ( assert_failed )
  {
    assert_failed = 0;
    v2 = -100003;
  }
  else
  {
    assert_failed = 0;
    v2 = -100002;
  }
  ((void (__cdecl *)(socket *, int, _DWORD))retry)(socket, v2, 0);
}

//----- (080BC850) --------------------------------------------------------
void __cdecl read_from_socket(socket *socket, read_buffer *buffer, connection_state state, socket_read_T done)
{
  read_buffer *read_buffer; // edi
  socket_operation_T set_timeout; // eax
  int v6; // edx
  read_buffer *v7; // eax
  void (*handler)(void *); // eax
  bool v9; // zf
  socket_weak_ref ref; // [esp+24h] [ebp-24h] BYREF

  read_buffer = socket->read_buffer;
  ref.socket = socket;
  ref.prev = (socket_weak_ref *)&socket_weak_refs;
  ref.next = (socket_weak_ref *)socket_weak_refs.next;
  socket_weak_refs.next = &ref;
  ref.next->prev = &ref;
  buffer->done = done;
  set_timeout = socket->ops->set_timeout;
  if ( assert_failed )
  {
    assert_failed = 0;
    v6 = -100003;
  }
  else
  {
    assert_failed = 0;
    v6 = 0;
  }
  ((void (__cdecl *)(socket *, int, _DWORD))set_timeout)(socket, v6, 0);
  ((void (__cdecl *)(socket *, connection_basic_state, int))socket->ops->set_state)(socket, state.basic, state.syserr);
  ref.next->prev = ref.prev;
  ref.prev->next = ref.next;
  if ( ref.socket )
  {
    v7 = socket->read_buffer;
    if ( v7 && buffer != v7 )
      mem_free(socket->read_buffer);
    handler = 0;
    v9 = (*((_BYTE *)socket + 36) & 0x10) == 0;
    socket->read_buffer = buffer;
    if ( !v9 )
      handler = get_handler(socket->fd, SELECT_HANDLER_WRITE);
    set_handlers(socket->fd, (select_handler_T)read_select, handler, (select_handler_T)exception, socket);
  }
  else if ( read_buffer != buffer )
  {
    mem_free(buffer);
  }
}

//----- (080BC980) --------------------------------------------------------
void __cdecl read_response_from_socket(socket *socket)
{
  read_buffer *buffer; // eax
  void (*read_done)(socket *, read_buffer *); // edx
  int v3; // ecx

  buffer = alloc_read_buffer(socket);
  if ( buffer )
  {
    read_done = socket->read_done;
    if ( assert_failed )
    {
      assert_failed = 0;
      v3 = -100003;
    }
    else
    {
      assert_failed = 0;
      v3 = 4;
    }
    read_from_socket(socket, buffer, (connection_state)(unsigned int)v3, read_done);
  }
}

//----- (080BC9F0) --------------------------------------------------------
void __cdecl write_to_socket(
        socket *socket,
        unsigned __int8 *data,
        int len,
        connection_state state,
        socket_write_T write_done)
{
  socket_operation_T set_timeout; // eax
  _DWORD *v6; // eax
  void *v7; // esi
  void (*handler)(void *); // eax
  bool v9; // zf
  socket_operation_T done; // esi
  int v11[8]; // [esp+38h] [ebp-20h] BYREF

  if ( assert_failed
    || (assert_failed = len <= 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c",
        errline = 810,
        elinks_internal("assertion len > 0 failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    set_timeout = socket->ops->set_timeout;
    assert_failed = 0;
    ((void (__cdecl *)(socket *, _DWORD, _DWORD))set_timeout)(socket, 0, 0);
    v6 = mem_alloc(len + 16);
    v7 = v6;
    if ( v6 )
    {
      v6[1] = len;
      v6[2] = 0;
      *v6 = write_done;
      memcpy(v6 + 3, data, len);
      if ( socket->write_buffer )
        mem_free(socket->write_buffer);
      handler = 0;
      v9 = (*((_BYTE *)socket + 36) & 0x10) == 0;
      socket->write_buffer = v7;
      if ( !v9 )
        handler = get_handler(socket->fd, SELECT_HANDLER_READ);
      set_handlers(socket->fd, handler, (select_handler_T)write_select, (select_handler_T)exception, socket);
      ((void (__cdecl *)(socket *, connection_basic_state, int))socket->ops->set_state)(
        socket,
        state.basic,
        state.syserr);
    }
    else
    {
      done = socket->ops->done;
      connection_state_1(S_OUT_OF_MEM, (connection_basic_state *)v11);
      ((void (__cdecl *)(socket *, int, int))done)(socket, v11[0], v11[1]);
    }
  }
}

//----- (080BCB80) --------------------------------------------------------
void __cdecl request_from_socket(
        socket *socket,
        unsigned __int8 *data,
        int datalen,
        connection_state state,
        socket_state sock_state,
        socket_read_T read_done)
{
  socket->read_done = read_done;
  socket->state = sock_state;
  write_to_socket(socket, data, datalen, state, read_response_from_socket);
}

//----- (080BCBB0) --------------------------------------------------------
void __cdecl read_select(socket *socket)
{
  read_buffer *read_buffer; // esi
  socket_operation_T set_timeout; // eax
  size_t freespace; // edi
  ssize_t v4; // eax
  socket_operation_T retry; // esi
  int *v6; // eax
  int v7; // edx
  int v8; // edx
  unsigned int v9; // edi
  read_buffer *v10; // eax
  unsigned int v11; // edi
  void *ssl; // eax
  ssize_t v13; // eax
  ssize_t v14; // edx
  socket_operation_T v15; // esi
  int v16; // edi
  void (*v17)(socket *, read_buffer *); // edx
  int v18; // eax
  connection_basic_state v19; // edx
  socket_operation_T done; // esi
  bool v21; // sf
  int fd; // [esp+20h] [ebp-28h]
  unsigned __int8 *buf; // [esp+24h] [ebp-24h]
  int v24[8]; // [esp+28h] [ebp-20h] BYREF

  read_buffer = socket->read_buffer;
  if ( assert_failed
    || (assert_failed = read_buffer == 0, !read_buffer)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c",
        errline = 858,
        elinks_internal("assertion rb != NULL failed: read socket has no buffer"),
        assert_failed) )
  {
    assert_failed = 0;
    ((void (__cdecl *)(socket *, int, _DWORD))socket->ops->done)(socket, -100003, 0);
    return;
  }
  set_timeout = socket->ops->set_timeout;
  assert_failed = 0;
  ((void (__cdecl *)(socket *, _DWORD, _DWORD))set_timeout)(socket, 0, 0);
  if ( (*((_BYTE *)socket + 36) & 0x10) != 0 )
  {
    freespace = read_buffer->freespace;
    if ( freespace )
      goto LABEL_5;
LABEL_20:
    v9 = (read_buffer->length + 20496) & 0xFFFFF000;
    v10 = (read_buffer *)mem_realloc(read_buffer, v9);
    read_buffer = v10;
    if ( !v10 )
    {
      v19 = S_OUT_OF_MEM;
      done = socket->ops->done;
LABEL_40:
      connection_state_1(v19, (connection_basic_state *)v24);
      ((void (__cdecl *)(socket *, int, int))done)(socket, v24[0], v24[1]);
      return;
    }
    v11 = v9 - v10->length;
    v10->freespace = v11 - 16;
    if ( !assert_failed )
    {
      assert_failed = (int)(v11 - 16) <= 0;
      if ( (int)(v11 - 16) <= 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
        errline = 881;
        elinks_internal("assertion rb->freespace > 0 failed!");
      }
    }
    ssl = socket->ssl;
    socket->read_buffer = read_buffer;
    freespace = read_buffer->freespace;
    if ( ssl )
      goto LABEL_6;
    goto LABEL_25;
  }
  set_handlers(socket->fd, 0, 0, 0, 0);
  freespace = read_buffer->freespace;
  if ( !freespace )
    goto LABEL_20;
LABEL_5:
  if ( socket->ssl )
  {
LABEL_6:
    v4 = ssl_read(socket, &read_buffer->data[read_buffer->length], freespace);
    goto LABEL_7;
  }
LABEL_25:
  buf = &read_buffer->data[read_buffer->length];
  fd = socket->fd;
  while ( 1 )
  {
    v13 = read(fd, buf, freespace);
    v14 = v13;
    if ( v13 != -1 )
      break;
    if ( *__errno_location() != 4 )
      goto LABEL_11;
  }
  v21 = v13 < 0;
  if ( !v13 )
  {
LABEL_32:
    if ( socket->state )
    {
      socket->state = SOCKET_CLOSED;
      read_buffer->done(socket, read_buffer);
      return;
    }
    v19 = S_CANT_READ;
    done = socket->ops->retry;
    goto LABEL_40;
  }
  v4 = -1;
  if ( !v21 )
    v4 = v14;
LABEL_7:
  if ( v4 == -3 )
  {
    v17 = read_buffer->done;
    if ( assert_failed )
    {
      assert_failed = 0;
      v18 = -100003;
    }
    else
    {
      assert_failed = 0;
      v18 = 8;
    }
    read_from_socket(socket, read_buffer, (connection_state)(unsigned int)v18, v17);
    return;
  }
  if ( v4 <= -3 )
  {
    if ( v4 != -4 )
    {
LABEL_15:
      v7 = read_buffer->freespace;
      read_buffer->length += v4;
      v8 = v7 - v4;
      read_buffer->freespace = v8;
      if ( !assert_failed )
      {
        assert_failed = (unsigned int)v8 >> 31;
        if ( v8 < 0 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
          errline = 925;
          elinks_internal("assertion rb->freespace >= 0 failed!");
        }
      }
      read_buffer->done(socket, read_buffer);
      return;
    }
    goto LABEL_32;
  }
  if ( v4 != -2 )
  {
    if ( v4 == -1 )
    {
LABEL_11:
      retry = socket->ops->retry;
      v6 = __errno_location();
      ((void (__cdecl *)(socket *, int, int))retry)(socket, -1, *v6);
      return;
    }
    goto LABEL_15;
  }
  v15 = socket->ops->done;
  v16 = *__errno_location();
  if ( assert_failed
    || (assert_failed = v16 == -1) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    v16 = -100003;
  }
  ((void (__cdecl *)(socket *, int, _DWORD))v15)(socket, v16, 0);
}

//----- (080BCFD0) --------------------------------------------------------
void __cdecl write_select(socket *socket)
{
  unsigned __int8 *write_buffer; // esi
  socket_operation_T set_timeout; // eax
  ssize_t v3; // eax
  int v4; // eax
  bool v5; // zf
  void (__cdecl *v6)(socket *); // esi
  void (*handler)(void *); // eax
  void (*v8)(void *); // edx
  int v9; // eax
  size_t v10; // edi
  ssize_t v11; // eax
  ssize_t v12; // edx
  socket_operation_T retry; // esi
  int *v14; // eax
  socket_operation_T done; // esi
  int v16; // edi
  socket_operation_T v17; // eax
  int v18; // edx
  bool v19; // sf
  int fd; // [esp+28h] [ebp-20h]
  unsigned __int8 *buf; // [esp+2Ch] [ebp-1Ch]

  write_buffer = (unsigned __int8 *)socket->write_buffer;
  if ( assert_failed
    || (assert_failed = write_buffer == 0, !write_buffer)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c",
        errline = 728,
        elinks_internal("assertion wb != NULL failed: write socket has no buffer"),
        assert_failed) )
  {
    assert_failed = 0;
    ((void (__cdecl *)(socket *, int, _DWORD))socket->ops->done)(socket, -100003, 0);
    return;
  }
  set_timeout = socket->ops->set_timeout;
  assert_failed = 0;
  ((void (__cdecl *)(socket *, _DWORD, _DWORD))set_timeout)(socket, 0, 0);
  if ( socket->ssl )
  {
    v3 = ssl_write(
           socket,
           &write_buffer[*((_DWORD *)write_buffer + 2) + 12],
           *((_DWORD *)write_buffer + 1) - *((_DWORD *)write_buffer + 2));
  }
  else
  {
    if ( !assert_failed )
    {
      v5 = *((_DWORD *)write_buffer + 1) - *((_DWORD *)write_buffer + 2) > 0;
      assert_failed = *((_DWORD *)write_buffer + 1) - *((_DWORD *)write_buffer + 2) <= 0;
      if ( !v5 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
        errline = 751;
        elinks_internal("assertion wb->length - wb->pos > 0 failed!");
      }
    }
    v9 = *((_DWORD *)write_buffer + 2);
    buf = &write_buffer[v9 + 12];
    v10 = *((_DWORD *)write_buffer + 1) - v9;
    fd = socket->fd;
    while ( 1 )
    {
      v11 = write(fd, buf, v10);
      v12 = v11;
      if ( v11 != -1 )
        break;
      if ( *__errno_location() != 4 )
        goto LABEL_26;
    }
    v19 = v11 < 0;
    if ( !v11 )
      goto LABEL_30;
    v3 = -1;
    if ( !v19 )
      v3 = v12;
  }
  if ( v3 != -2 )
  {
    if ( v3 == -1 )
    {
LABEL_26:
      retry = socket->ops->retry;
      v14 = __errno_location();
      ((void (__cdecl *)(socket *, int, int))retry)(socket, -1, *v14);
      return;
    }
    if ( v3 != -5 )
    {
      if ( v3 >= 0 )
      {
        v4 = *((_DWORD *)write_buffer + 2) + v3;
        v5 = v4 == *((_DWORD *)write_buffer + 1);
        *((_DWORD *)write_buffer + 2) = v4;
        if ( v5 )
        {
          v6 = *(void (__cdecl **)(socket *))write_buffer;
          if ( (*((_BYTE *)socket + 36) & 0x10) != 0 )
          {
            handler = get_handler(socket->fd, SELECT_HANDLER_READ);
            v8 = 0;
            if ( handler )
              v8 = (void (*)(void *))exception;
            set_handlers(socket->fd, handler, 0, v8, socket);
          }
          else
          {
            set_handlers(socket->fd, 0, 0, 0, 0);
          }
          if ( socket->write_buffer )
            mem_free(socket->write_buffer);
          socket->write_buffer = 0;
          v6(socket);
        }
      }
      return;
    }
LABEL_30:
    v17 = socket->ops->retry;
    if ( assert_failed )
    {
      assert_failed = 0;
      v18 = -100003;
    }
    else
    {
      assert_failed = 0;
      v18 = -100006;
    }
    ((void (__cdecl *)(socket *, int, _DWORD))v17)(socket, v18, 0);
    return;
  }
  done = socket->ops->done;
  v16 = *__errno_location();
  if ( assert_failed
    || (assert_failed = v16 == -1) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    v16 = -100003;
  }
  ((void (__cdecl *)(socket *, int, _DWORD))done)(socket, v16, 0);
}

//----- (080BD320) --------------------------------------------------------
void __cdecl connect_socket(socket *csocket, connection_state state)
{
  connect_info *v2; // edx
  int v3; // ebx
  int v4; // esi
  int sin6_family; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // edi
  int *v9; // eax
  int v10; // eax
  struct ifaddrs *v11; // eax
  sockaddr *ifa_addr; // edi
  int v13; // esi
  int v14; // eax
  struct ifaddrs *v15; // eax
  sockaddr *v16; // edi
  int *v17; // eax
  connect_info *v18; // edx
  bool v19; // al
  int *v20; // eax
  connection_basic_state v21; // edx
  socket_operation_T set_state; // ebx
  socklen_t v23; // [esp+8h] [ebp-C0h]
  connect_info *v24; // [esp+24h] [ebp-A4h]
  connect_info *connect_info; // [esp+3Ch] [ebp-8Ch]
  connect_info *v26; // [esp+3Ch] [ebp-8Ch]
  connect_info *v27; // [esp+3Ch] [ebp-8Ch]
  connect_info *v28; // [esp+3Ch] [ebp-8Ch]
  connect_info *v29; // [esp+3Ch] [ebp-8Ch]
  connect_info *v30; // [esp+3Ch] [ebp-8Ch]
  int trno; // [esp+40h] [ebp-88h]
  connection_state v32; // [esp+44h] [ebp-84h]
  int try_ipv4; // [esp+4Ch] [ebp-7Ch]
  int try_ipv6; // [esp+50h] [ebp-78h]
  struct ifaddrs *ifa; // [esp+58h] [ebp-70h]
  int at_least_one_remote_ip; // [esp+5Ch] [ebp-6Ch]
  int silent_fail; // [esp+60h] [ebp-68h]
  int only_local; // [esp+64h] [ebp-64h]
  int force_family; // [esp+68h] [ebp-60h]
  int j; // [esp+6Ch] [ebp-5Ch]
  int family; // [esp+70h] [ebp-58h]
  int i; // [esp+74h] [ebp-54h]
  int v43[4]; // [esp+78h] [ebp-50h] BYREF
  struct ifaddrs *ifap; // [esp+88h] [ebp-40h] BYREF
  sockaddr_in6 *p_addr; // [esp+8Ch] [ebp-3Ch]
  sockaddr_in6 addr; // [esp+90h] [ebp-38h] BYREF
  unsigned int v47; // [esp+ACh] [ebp-1Ch]

  v47 = __readgsdword(0x14u);
  v32 = state;
  connect_info = csocket->connect_info;
  trno = connect_info->triedno;
  only_local = get_opt_(cmdline_options, "localhost")->number;
  try_ipv6 = get_opt_(config_options, "connection.try_ipv6")->number;
  try_ipv4 = get_opt_(config_options, "connection.try_ipv4")->number;
  ((void (__cdecl *)(socket *, connection_basic_state, int))csocket->ops->set_state)(csocket, state.basic, state.syserr);
  v2 = connect_info;
  if ( csocket->fd >= 0 )
  {
    close_socket(csocket);
    v2 = connect_info;
  }
  i = v2->triedno + 1;
  if ( v2->addrno > i )
  {
    v3 = i << 7;
    silent_fail = 0;
    at_least_one_remote_ip = 0;
    for ( j = 0; ; j = v4 )
    {
      addr = *(sockaddr_in6 *)((char *)&v2->addr->ss_family + v3);
      sin6_family = addr.sin6_family;
      family = addr.sin6_family;
      force_family = v2->ip_family;
      ++v2->triedno;
      if ( only_local )
      {
        if ( sin6_family == 10 )
        {
          p_addr = &addr;
          if ( addr.sin6_addr.__u6_addr32[0]
            || __PAIR64__(addr.sin6_addr.__u6_addr32[1], 0) != addr.sin6_addr.__u6_addr32[2]
            || addr.sin6_addr.__u6_addr32[3] != 0x1000000 )
          {
            v27 = v2;
            v10 = getifaddrs(&ifap);
            v2 = v27;
            if ( !v10 )
            {
              v11 = ifap;
              ifa = ifap;
              if ( !ifap )
                goto LABEL_42;
              v24 = v27;
              while ( 1 )
              {
LABEL_33:
                ifa_addr = v11->ifa_addr;
                if ( !ifa_addr )
                  goto LABEL_32;
                if ( ifa_addr->sa_family == 10 )
                  break;
                if ( ifa_addr->sa_family != 2 )
                  goto LABEL_32;
                if ( !memcmp(&addr, &ifa_addr->sa_data[2], 4u) )
                  goto LABEL_36;
                v11 = v11->ifa_next;
                if ( !v11 )
                {
LABEL_41:
                  v2 = v24;
                  goto LABEL_42;
                }
              }
              if ( !memcmp(&p_addr->sin6_addr, &ifa_addr->sa_data[6], 0x10u) )
                goto LABEL_36;
LABEL_32:
              v11 = v11->ifa_next;
              if ( !v11 )
                goto LABEL_41;
              goto LABEL_33;
            }
LABEL_38:
            v4 = j;
            at_least_one_remote_ip = 1;
            goto LABEL_6;
          }
LABEL_12:
          if ( !try_ipv6 || force_family != 6 && force_family )
            goto LABEL_20;
          v6 = 10;
          goto LABEL_16;
        }
        if ( _byteswap_ulong(addr.sin6_flowinfo) >> 24 != 127 )
        {
          v29 = v2;
          v14 = getifaddrs(&ifap);
          v2 = v29;
          if ( v14 )
            goto LABEL_38;
          ifa = ifap;
          if ( ifap )
          {
            v15 = ifap;
            v24 = v29;
            while ( 1 )
            {
              v16 = v15->ifa_addr;
              if ( v16 )
              {
                if ( v16->sa_family == 2 && !memcmp(&addr.sin6_flowinfo, &v16->sa_data[2], 4u) )
                  break;
              }
              v15 = v15->ifa_next;
              if ( !v15 )
                goto LABEL_41;
            }
LABEL_36:
            v2 = v24;
            v13 = 1;
          }
          else
          {
LABEL_42:
            v13 = 0;
          }
          v28 = v2;
          freeifaddrs(ifa);
          v2 = v28;
          if ( !v13 )
            goto LABEL_38;
        }
      }
      if ( family == 10 )
        goto LABEL_12;
      v4 = j;
      if ( family != 2 )
        goto LABEL_6;
      if ( !try_ipv4 || force_family != 4 && force_family )
      {
LABEL_20:
        v4 = j;
        silent_fail = 1;
        goto LABEL_6;
      }
      v6 = 2;
LABEL_16:
      v26 = v2;
      v7 = socket(v6, 1, 6);
      v8 = v7;
      if ( v7 != -1 )
      {
        if ( set_nonblocking_fd(v7) < 0 )
        {
          v20 = __errno_location();
          v18 = v26;
          v4 = *v20;
          if ( *v20 )
            goto LABEL_59;
        }
        else
        {
          csocket->fd = v8;
          addr.sin6_port = __ROR2__(v26->port, 8);
          if ( family == 10 )
          {
            *((_BYTE *)csocket + 36) |= 1u;
            v23 = 28;
          }
          else
          {
            *((_BYTE *)csocket + 36) &= ~1u;
            v23 = 16;
          }
          if ( !connect(v8, (const struct sockaddr *)&addr, v23) )
          {
            complete_connect_socket(csocket, 0, 0);
            return;
          }
          v17 = __errno_location();
          v18 = v26;
          v4 = *v17;
          if ( *v17 == 11 || v4 == 114 || v4 == 115 )
          {
            set_handlers(v8, 0, (select_handler_T)connected, (select_handler_T)dns_exception, csocket);
            v21 = S_CONN;
            set_state = csocket->ops->set_state;
            goto LABEL_81;
          }
          if ( v4 )
          {
LABEL_59:
            if ( j )
              goto LABEL_60;
LABEL_61:
            v30 = v18;
            close(v8);
            v2 = v30;
            silent_fail = 0;
            goto LABEL_6;
          }
        }
LABEL_60:
        v4 = j;
        goto LABEL_61;
      }
      v9 = __errno_location();
      v2 = v26;
      v4 = *v9;
      if ( !*v9 || (silent_fail = 0, j) )
      {
        v4 = j;
        silent_fail = 0;
      }
LABEL_6:
      ++i;
      v3 += 128;
      if ( v2->addrno <= i )
      {
        v19 = v4 == 0;
        goto LABEL_63;
      }
    }
  }
  v19 = 1;
  silent_fail = 0;
  at_least_one_remote_ip = 0;
LABEL_63:
  if ( !assert_failed )
    assert_failed = 0;
  if ( v19 && only_local && at_least_one_remote_ip )
  {
    v21 = S_LOCAL_ONLY;
    set_state = csocket->ops->done;
LABEL_81:
    connection_state_1(v21, (connection_basic_state *)v43);
    ((void (__cdecl *)(socket *, int, int))set_state)(csocket, v43[0], v43[1]);
    return;
  }
  if ( silent_fail || v2->triedno == trno )
  {
    if ( silent_fail && trno == -1 )
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v32.basic = S_INTERNAL;
      }
      else
      {
        assert_failed = 0;
        v32.basic = S_NO_FORCED_DNS;
      }
      v32.syserr = 0;
    }
  }
  else
  {
    v32.basic = S_ERRNO;
    v32.syserr = *__errno_location();
  }
  ((void (__cdecl *)(socket *, connection_basic_state, int))csocket->ops->retry)(csocket, v32.basic, v32.syserr);
}

//----- (080BD980) --------------------------------------------------------
void __cdecl dns_found(socket *socket, sockaddr_storage *addr, int addrlen)
{
  connect_info *connect_info; // esi
  sockaddr_storage *v4; // eax
  int v5; // eax
  connection_basic_state v6; // edx
  socket_operation_T done; // esi
  int v8[5]; // [esp+18h] [ebp-20h] BYREF

  connect_info = socket->connect_info;
  if ( !addr )
  {
    v6 = S_NO_DNS;
    done = socket->ops->done;
    goto LABEL_11;
  }
  if ( !assert_failed )
  {
    assert_failed = connect_info == 0;
    if ( !connect_info )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c";
      errline = 233;
      elinks_internal("assertion connect_info failed!");
    }
  }
  v4 = (sockaddr_storage *)mem_alloc(addrlen << 7);
  connect_info->addr = v4;
  if ( !v4 )
  {
    v6 = S_OUT_OF_MEM;
    done = socket->ops->done;
LABEL_11:
    connection_state_1(v6, (connection_basic_state *)v8);
    ((void (__cdecl *)(socket *, int, int))done)(socket, v8[0], v8[1]);
    return;
  }
  memcpy(v4, addr, addrlen << 7);
  connect_info->addrno = addrlen;
  if ( assert_failed )
  {
    assert_failed = 0;
    v5 = -100003;
  }
  else
  {
    assert_failed = 0;
    v5 = 2;
  }
  connect_socket(socket, (connection_state)(unsigned int)v5);
}

//----- (080BDAC0) --------------------------------------------------------
void __cdecl timeout_socket(socket *socket)
{
  connect_info *connect_info; // eax
  socket_operation_T done; // eax
  int v3; // edx
  int v4; // eax
  socket_operation_T retry; // esi
  int v6[2]; // [esp+18h] [ebp-10h] BYREF

  connect_info = socket->connect_info;
  if ( !connect_info )
  {
    retry = socket->ops->retry;
    connection_state_1(S_TIMEOUT, (connection_basic_state *)v6);
    ((void (__cdecl *)(socket *, int, int))retry)(socket, v6[0], v6[1]);
    return;
  }
  if ( connect_info->dnsquery )
  {
    done = socket->ops->done;
    if ( !assert_failed )
    {
      assert_failed = 0;
      v3 = -100010;
      goto LABEL_5;
    }
LABEL_4:
    assert_failed = 0;
    v3 = -100003;
LABEL_5:
    ((void (__cdecl *)(socket *, int, _DWORD))done)(socket, v3, 0);
    return;
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v4 = -100003;
  }
  else
  {
    assert_failed = 0;
    v4 = -100010;
  }
  connect_socket(socket, (connection_state)(unsigned int)v4);
  if ( socket->connect_info )
  {
    done = socket->ops->set_timeout;
    if ( !assert_failed )
    {
      assert_failed = 0;
      v3 = 0;
      goto LABEL_5;
    }
    goto LABEL_4;
  }
}

//----- (080BDBE0) --------------------------------------------------------
void __cdecl dns_exception(socket *socket)
{
  int v1; // eax

  if ( assert_failed )
  {
    assert_failed = 0;
    v1 = -100003;
  }
  else
  {
    assert_failed = 0;
    v1 = -100002;
  }
  connect_socket(socket, (connection_state)(unsigned int)v1);
}

//----- (080BDC30) --------------------------------------------------------
void __cdecl connected(socket *socket)
{
  connect_info *connect_info; // edx
  int v2; // eax
  int v3; // edx
  socklen_t len; // [esp+28h] [ebp-10h] BYREF
  int err[3]; // [esp+2Ch] [ebp-Ch] BYREF

  assert_failed = 0;
  err[0] = 0;
  len = 4;
  connect_info = socket->connect_info;
  assert_failed = connect_info == 0;
  if ( connect_info
    || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/socket.c",
        errline = 506,
        elinks_internal("assertion socket->connect_info != NULL failed: Lost connect_info!"),
        !assert_failed) )
  {
    if ( getsockopt(socket->fd, 1, 4, err, &len) )
    {
      v2 = *__errno_location();
      if ( v2 )
      {
LABEL_4:
        v3 = -1;
LABEL_5:
        connect_socket(socket, (connection_state)__PAIR64__(v2, v3));
        return;
      }
      if ( !assert_failed )
      {
        assert_failed = 0;
        v3 = -100012;
        goto LABEL_5;
      }
    }
    else
    {
      v2 = err[0];
      if ( err[0] > 9999 )
      {
        v2 = err[0] - 10000;
        err[0] -= 10000;
      }
      if ( v2 )
        goto LABEL_4;
      if ( !assert_failed )
      {
        assert_failed = 0;
        complete_connect_socket(socket, 0, 0);
        return;
      }
    }
    assert_failed = 0;
    v3 = -100003;
    goto LABEL_5;
  }
  assert_failed = 0;
}
// 80BDC30: using guessed type int err[3];

//----- (080BDD90) --------------------------------------------------------
void __cdecl make_connection(socket *socket, uri *uri, socket_connect_T connect_done, int no_cache)
{
  unsigned __int8 *uri_string; // edi
  socket_operation_T set_timeout; // eax
  int v6; // edx
  connect_info *inited; // eax
  char v8; // cl
  connect_info *v9; // edx
  dns_result host; // esi
  socket_operation_T retry; // eax
  int v12; // edx
  socket_operation_T v13; // esi
  connect_info *v14; // [esp+2Ch] [ebp-2Ch]
  int v15[8]; // [esp+38h] [ebp-20h] BYREF

  uri_string = get_uri_string(uri, URI_DNS_HOST);
  set_timeout = socket->ops->set_timeout;
  if ( assert_failed )
  {
    assert_failed = 0;
    v6 = -100003;
  }
  else
  {
    assert_failed = 0;
    v6 = 0;
  }
  ((void (__cdecl *)(socket *, int, _DWORD))set_timeout)(socket, v6, 0);
  if ( !uri_string )
  {
    retry = socket->ops->retry;
    if ( !assert_failed )
    {
      assert_failed = 0;
      v12 = -100004;
      goto LABEL_12;
    }
    goto LABEL_13;
  }
  inited = init_connection_info(uri, connect_done);
  if ( !inited )
  {
    mem_free(uri_string);
    v13 = socket->ops->retry;
    connection_state_1(S_OUT_OF_MEM, (connection_basic_state *)v15);
    ((void (__cdecl *)(socket *, int, int))v13)(socket, v15[0], v15[1]);
    return;
  }
  socket->connect_info = inited;
  v14 = inited;
  v8 = (2 * (get_protocol_need_ssl((protocol)uri->protocol) & 1)) | *((_BYTE *)socket + 36) & 0xFD;
  *((_BYTE *)socket + 36) = v8;
  v9 = v14;
  if ( (v8 & 8) == 0 )
  {
    *((_BYTE *)socket + 36) = (4 * ((get_blacklist_flags(uri) & 4) != 0)) | *((_BYTE *)socket + 36) & 0xFB | 8;
    v9 = v14;
  }
  host = find_host(uri_string, &v9->dnsquery, (dns_callback_T)dns_found, socket, no_cache);
  mem_free(uri_string);
  if ( host == DNS_ASYNC )
  {
    retry = socket->ops->set_state;
    if ( !assert_failed )
    {
      assert_failed = 0;
      v12 = 1;
LABEL_12:
      ((void (__cdecl *)(socket *, int, _DWORD))retry)(socket, v12, 0);
      return;
    }
LABEL_13:
    assert_failed = 0;
    v12 = -100003;
    goto LABEL_12;
  }
}

//----- (080BDF60) --------------------------------------------------------
void done_state_message()
{
  _DWORD *next; // eax
  list_head_elinks *i; // ebx
  list_head_elinks *j; // edx
  list_head_elinks *v3; // esi
  list_head_elinks *v4; // edi

  next = strerror_buf.next;
  for ( i = (list_head_elinks *)strerror_buf.next; i != &strerror_buf; i = (list_head_elinks *)i->next )
    ;
  for ( j = (list_head_elinks *)strerror_buf.prev; j != i; j = (list_head_elinks *)j->prev )
    ;
  v3 = *(list_head_elinks **)strerror_buf.next;
  if ( strerror_buf.next != i )
  {
    do
    {
      v4 = v3;
      v3->prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v3 = (list_head_elinks *)v3->next;
      next = &v4->next;
    }
    while ( v4 != i );
  }
}

//----- (080BDFD0) --------------------------------------------------------
unsigned __int8 *__cdecl get_state_message(connection_state state, terminal *term)
{
  terminal *v2; // edx
  int terminal_codepage; // eax
  int v4; // edi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v6; // edi
  unsigned __int8 *msg; // ebx
  int v8; // eax
  int v10; // eax
  int v11; // esi
  unsigned __int8 *v12; // eax
  char *v13; // eax
  size_t v14; // eax
  list_head_elinks *next; // esi
  char *v16; // eax
  _DWORD *v17; // ebx
  unsigned __int8 *v18; // edi
  void *v19; // eax
  const terminal *v20; // [esp+14h] [ebp-24h]
  size_t n2; // [esp+18h] [ebp-20h]
  unsigned __int8 *e; // [esp+1Ch] [ebp-1Ch]

  v2 = term;
  if ( term )
  {
    terminal_codepage = get_terminal_codepage(term);
    v2 = term;
    v4 = terminal_codepage;
    if ( terminal_codepage != current_charset )
    {
      cp_mime_name = get_cp_mime_name(terminal_codepage);
      bind_textdomain_codeset("elinks", cp_mime_name);
      current_charset = v4;
      v2 = term;
    }
  }
  v20 = v2;
  v6 = gettext(&byte_8131AED);
  if ( state.basic == S_ERRNO )
  {
    v13 = strerror(state.syserr);
    e = (unsigned __int8 *)v13;
    if ( v13 && *v13 )
    {
      v14 = strlen(v13);
      next = (list_head_elinks *)strerror_buf.next;
      for ( n2 = v14; next != &strerror_buf; next = (list_head_elinks *)next->next )
      {
        msg = (unsigned __int8 *)&next[1];
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.c";
        errline = 176;
        if ( !elinks_strlcmp((const unsigned __int8 *)&next[1], 0xFFFFFFFF, e, n2) )
          return msg;
      }
      v16 = (char *)mem_calloc(1u, n2 + 12);
      v17 = v16;
      if ( v16 )
      {
        v18 = (unsigned __int8 *)(v16 + 8);
        memcpy(v16 + 8, e, n2 + 1);
        v19 = next->next;
        v17[1] = next;
        *v17 = v19;
        next->next = v17;
        *(_DWORD *)(*v17 + 4) = v17;
        return v18;
      }
    }
    return v6;
  }
  msg = msg_dsc[0].msg;
  if ( !msg_dsc[0].msg )
    return v6;
  v8 = 0;
  if ( state.basic )
  {
    do
    {
      msg = msg_dsc[++v8].msg;
      if ( !msg )
        return v6;
    }
    while ( msg_dsc[v8].n != state.basic );
  }
  if ( !*msg )
    return msg;
  if ( v20 )
  {
    v10 = get_terminal_codepage(v20);
    v11 = v10;
    if ( v10 != current_charset )
    {
      v12 = get_cp_mime_name(v10);
      bind_textdomain_codeset("elinks", v12);
      current_charset = v11;
    }
  }
  return gettext(msg);
}

//----- (080BE1A0) --------------------------------------------------------
int __cdecl ssl_close(socket *socket)
{
  gnutls_bye(*(_DWORD *)socket->ssl, 0);
  done_ssl_connection(socket);
  return 0;
}
// 8059AB8: using guessed type int __cdecl gnutls_bye(_DWORD, _DWORD);

//----- (080BE1D0) --------------------------------------------------------
ssize_t __cdecl ssl_read(socket *socket, unsigned __int8 *data, int len)
{
  ssize_t result; // eax

  result = gnutls_record_recv(*(_DWORD *)socket->ssl, data, len);
  if ( result <= 0 )
  {
    if ( result == -37 )
      return -1;
    if ( result == -52 || result == -28 )
    {
      return -3;
    }
    else if ( result )
    {
      if ( result == -54 )
        return -1;
      *__errno_location() = -100018;
      return -2;
    }
    else
    {
      return -4;
    }
  }
  return result;
}
// 8058D68: using guessed type int __cdecl gnutls_record_recv(_DWORD, _DWORD, _DWORD);

//----- (080BE250) --------------------------------------------------------
ssize_t __cdecl ssl_write(socket *socket, unsigned __int8 *data, int len)
{
  ssize_t result; // eax

  result = gnutls_record_send(*(_DWORD *)socket->ssl, data, len);
  if ( result <= 0 )
  {
    switch ( result )
    {
      case -52:
      case -28:
        return -1;
      case 0:
        return -5;
      case -53:
        return -1;
    }
    *__errno_location() = -100018;
    return -2;
  }
  return result;
}
// 8058DC8: using guessed type int __cdecl gnutls_record_send(_DWORD, _DWORD, _DWORD);

//----- (080BE2C0) --------------------------------------------------------
connection_basic_state *__usercall connection_state_2@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080BE350) --------------------------------------------------------
void __cdecl ssl_want_read(socket *socket)
{
  int v1; // eax
  socket_operations *ops; // eax
  void (__cdecl *retry)(_DWORD, _DWORD, _DWORD); // eax
  int v4; // edx
  socket_operation_T v5; // esi
  int v6[4]; // [esp+18h] [ebp-10h] BYREF

  if ( (*((_BYTE *)socket + 36) & 4) != 0 )
    gnutls_protocol_set_priority(*(_DWORD *)socket->ssl, &protocol_priority_7093);
  v1 = gnutls_handshake(*(_DWORD *)socket->ssl);
  if ( v1 != -28 )
  {
    if ( v1 )
    {
      if ( v1 != -52 )
      {
        ops = socket->ops;
        *((_BYTE *)socket + 36) = (4 * (((*((_BYTE *)socket + 36) >> 2) ^ 1) & 1)) | *((_BYTE *)socket + 36) & 0xFB;
        retry = (void (__cdecl *)(_DWORD, _DWORD, _DWORD))ops->retry;
        if ( assert_failed )
        {
          assert_failed = 0;
          v4 = -100003;
        }
        else
        {
          assert_failed = 0;
          v4 = -100018;
        }
        retry(socket, v4, 0);
      }
    }
    else if ( get_opt_(config_options, "connection.ssl.cert_verify")->number
           && gnutls_certificate_verify_peers(*(_DWORD *)socket->ssl) )
    {
      v5 = socket->ops->retry;
      connection_state_2(S_SSL_ERROR, (connection_basic_state *)v6);
      ((void (__cdecl *)(socket *, int, int))v5)(socket, v6[0], v6[1]);
    }
    else
    {
      complete_connect_socket(socket, 0, 0);
    }
  }
}
// 8058DD8: using guessed type int __cdecl gnutls_handshake(_DWORD);
// 80593A8: using guessed type int __cdecl gnutls_protocol_set_priority(_DWORD, _DWORD);
// 8059568: using guessed type int __cdecl gnutls_certificate_verify_peers(_DWORD);

//----- (080BE490) --------------------------------------------------------
int __cdecl ssl_connect(socket *socket)
{
  int v1; // eax
  int v2; // eax
  socket_operation_T set_state; // eax
  int v5; // edx
  socket_operation_T done; // esi
  int v7[4]; // [esp+28h] [ebp-10h] BYREF

  if ( init_ssl_connection(socket) == -100018 )
  {
    done = socket->ops->done;
    connection_state_2(S_SSL_ERROR, (connection_basic_state *)v7);
    ((void (__cdecl *)(socket *, int, int))done)(socket, v7[0], v7[1]);
    return -1;
  }
  if ( (*((_BYTE *)socket + 36) & 4) != 0 )
    gnutls_protocol_set_priority(*(_DWORD *)socket->ssl, &protocol_priority_7093);
  gnutls_transport_set_ptr(*(_DWORD *)socket->ssl, socket->fd);
  v1 = gnutls_handshake(*(_DWORD *)socket->ssl);
  if ( v1 != -28 )
  {
    if ( !v1 )
    {
      if ( !get_opt_(config_options, "connection.ssl.cert_verify")->number
        || !gnutls_certificate_verify_peers(*(_DWORD *)socket->ssl) )
      {
        return 0;
      }
      goto LABEL_8;
    }
    if ( v1 != -52 )
    {
      *((_BYTE *)socket + 36) = (4 * (((*((_BYTE *)socket + 36) >> 2) ^ 1) & 1)) | *((_BYTE *)socket + 36) & 0xFB;
LABEL_8:
      if ( assert_failed )
      {
        assert_failed = 0;
        v2 = -100003;
      }
      else
      {
        assert_failed = 0;
        v2 = -100018;
      }
      connect_socket(socket, (connection_state)(unsigned int)v2);
      return -1;
    }
  }
  set_state = socket->ops->set_state;
  if ( assert_failed )
  {
    assert_failed = 0;
    v5 = -100003;
  }
  else
  {
    assert_failed = 0;
    v5 = 3;
  }
  ((void (__cdecl *)(socket *, int, _DWORD))set_state)(socket, v5, 0);
  set_handlers(socket->fd, (select_handler_T)ssl_want_read, 0, (select_handler_T)dns_exception, socket);
  return -1;
}
// 80BE4F0: conditional instruction was optimized away because eax.4 is in (1..FFFFFFCB|FFFFFFCD..FFFFFFE3|>=FFFFFFE5u)
// 8058DD8: using guessed type int __cdecl gnutls_handshake(_DWORD);
// 8058F18: using guessed type int __cdecl gnutls_transport_set_ptr(_DWORD, _DWORD);
// 80593A8: using guessed type int __cdecl gnutls_protocol_set_priority(_DWORD, _DWORD);
// 8059568: using guessed type int __cdecl gnutls_certificate_verify_peers(_DWORD);

//----- (080BE680) --------------------------------------------------------
void __cdecl done_gnutls(module *module)
{
  if ( xcred )
    gnutls_certificate_free_credentials(xcred);
  if ( anon_cred )
    gnutls_anon_free_client_credentials(anon_cred);
  gnutls_global_deinit(module);
}
// 8059128: using guessed type int __cdecl gnutls_anon_free_client_credentials(_DWORD);
// 8059608: using guessed type int __cdecl gnutls_certificate_free_credentials(_DWORD);
// 8059988: using guessed type void __cdecl gnutls_global_deinit(module *module);

//----- (080BE6B0) --------------------------------------------------------
void __cdecl init_gnutls(module *module)
{
  int v1; // esi
  _BYTE *number; // ebx
  int client_credentials; // eax
  int credentials; // eax
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax

  v1 = gnutls_global_init();
  number = (_BYTE *)get_opt_(config_options, "connection.ssl.trusted_ca_file")->number;
  if ( v1 < 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 129;
    v6 = (const char *)gnutls_strerror(v1);
    elinks_internal("GNUTLS init failed: %s", v6);
    client_credentials = gnutls_anon_allocate_client_credentials(&anon_cred);
    if ( client_credentials >= 0 )
      goto LABEL_3;
  }
  else
  {
    client_credentials = gnutls_anon_allocate_client_credentials(&anon_cred);
    if ( client_credentials >= 0 )
      goto LABEL_3;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
  errline = 133;
  v7 = (const char *)gnutls_strerror(client_credentials);
  elinks_internal("GNUTLS anon credentials alloc failed: %s", v7);
LABEL_3:
  credentials = gnutls_certificate_allocate_credentials(&xcred);
  if ( credentials < 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/ssl/ssl.c";
    errline = 138;
    v5 = (const char *)gnutls_strerror(credentials);
    elinks_internal("GNUTLS X509 credentials alloc failed: %s", v5);
  }
  if ( *number )
  {
    gnutls_certificate_set_x509_trust_file(xcred, number, 1);
    gnutls_certificate_set_verify_flags(xcred, 2);
  }
}
// 8058C68: using guessed type int gnutls_global_init(void);
// 8058E28: using guessed type int __cdecl gnutls_certificate_set_x509_trust_file(_DWORD, _DWORD, _DWORD);
// 8058EE8: using guessed type int __cdecl gnutls_certificate_allocate_credentials(_DWORD);
// 8058F48: using guessed type int __cdecl gnutls_certificate_set_verify_flags(_DWORD, _DWORD);
// 8059418: using guessed type int __cdecl gnutls_anon_allocate_client_credentials(_DWORD);
// 8059AD8: using guessed type int __cdecl gnutls_strerror(_DWORD);

//----- (080BE7F0) --------------------------------------------------------
unsigned __int8 *__cdecl get_ssl_connection_cipher(socket *socket)
{
  _DWORD *ssl; // ebx
  string *inited; // edx
  unsigned __int8 *result; // eax
  int v4; // eax
  int v5; // eax
  const char *v6; // edi
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int version; // eax
  const char *v11; // eax
  const char *v12; // [esp+20h] [ebp-38h]
  const char *name; // [esp+24h] [ebp-34h]
  const char *v14; // [esp+28h] [ebp-30h]
  const char *v15; // [esp+2Ch] [ebp-2Ch]
  string str; // [esp+38h] [ebp-20h] BYREF

  ssl = socket->ssl;
  inited = init_string(&str);
  result = 0;
  if ( inited )
  {
    v4 = gnutls_compression_get(*ssl);
    name = (const char *)gnutls_compression_get_name(v4);
    v5 = gnutls_certificate_type_get(*ssl);
    v6 = (const char *)gnutls_certificate_type_get_name(v5);
    v7 = gnutls_mac_get(*ssl);
    v12 = (const char *)gnutls_mac_get_name(v7);
    v8 = gnutls_cipher_get(*ssl);
    v14 = (const char *)gnutls_cipher_get_name(v8);
    v9 = gnutls_kx_get(*ssl);
    v15 = (const char *)gnutls_kx_get_name(v9);
    version = gnutls_protocol_get_version(*ssl);
    v11 = (const char *)gnutls_protocol_get_name(version);
    add_format_to_string(&str, "%s - %s - %s - %s - %s (compr: %s)", v11, v15, v14, v12, v6, name);
    return str.source;
  }
  return result;
}
// 8058C48: using guessed type int __cdecl gnutls_mac_get(_DWORD);
// 8058D38: using guessed type int __cdecl gnutls_certificate_type_get_name(_DWORD);
// 8058DF8: using guessed type int __cdecl gnutls_protocol_get_name(_DWORD);
// 8058E58: using guessed type int __cdecl gnutls_compression_get(_DWORD);
// 8059148: using guessed type int __cdecl gnutls_cipher_get_name(_DWORD);
// 80593D8: using guessed type int __cdecl gnutls_protocol_get_version(_DWORD);
// 8059508: using guessed type int __cdecl gnutls_mac_get_name(_DWORD);
// 8059598: using guessed type int __cdecl gnutls_compression_get_name(_DWORD);
// 8059778: using guessed type int __cdecl gnutls_certificate_type_get(_DWORD);
// 80597F8: using guessed type int __cdecl gnutls_kx_get(_DWORD);
// 8059808: using guessed type int __cdecl gnutls_kx_get_name(_DWORD);
// 8059A68: using guessed type int __cdecl gnutls_cipher_get(_DWORD);

//----- (080BE8E0) --------------------------------------------------------
void __cdecl done_ssl_connection(socket *socket)
{
  _DWORD *ssl; // ebx

  ssl = socket->ssl;
  if ( ssl )
  {
    gnutls_deinit(*ssl);
    mem_free(ssl);
    socket->ssl = 0;
  }
}
// 80593E8: using guessed type int __cdecl gnutls_deinit(_DWORD);

//----- (080BE920) --------------------------------------------------------
int __cdecl init_ssl_connection(socket *socket)
{
  _DWORD *v1; // ebx
  int result; // eax

  v1 = mem_alloc(4u);
  result = -100018;
  if ( !v1 )
    return result;
  if ( gnutls_init(v1, 2) < 0 )
  {
LABEL_10:
    mem_free(v1);
    return -100018;
  }
  if ( gnutls_credentials_set(*v1, 2, anon_cred) < 0 )
  {
    gnutls_deinit(*v1);
    goto LABEL_10;
  }
  if ( gnutls_credentials_set(*v1, 1, xcred) < 0 || gnutls_priority_set_direct(*v1, "NORMAL:-CTYPE-OPENPGP", 0) )
  {
    gnutls_deinit(*v1);
    mem_free(v1);
    return -100018;
  }
  else
  {
    gnutls_cipher_set_priority(*v1, cipher_priority);
    gnutls_kx_set_priority(*v1, kx_priority);
    socket->ssl = v1;
    return -100000;
  }
}
// 80590E8: using guessed type int __cdecl gnutls_cipher_set_priority(_DWORD, _DWORD);
// 8059138: using guessed type int __cdecl gnutls_credentials_set(_DWORD, _DWORD, _DWORD);
// 8059168: using guessed type int __cdecl gnutls_init(_DWORD, _DWORD);
// 8059388: using guessed type int __cdecl gnutls_kx_set_priority(_DWORD, _DWORD);
// 80593E8: using guessed type int __cdecl gnutls_deinit(_DWORD);
// 80597D8: using guessed type int __cdecl gnutls_priority_set_direct(_DWORD, _DWORD, _DWORD);

//----- (080BEA30) --------------------------------------------------------
int __cdecl can_open_in_new(terminal *term)
{
  int *v1; // ecx
  int v2; // edx
  int result; // eax
  bool v4; // cf

  v1 = (_DWORD *)(open_in_new_0 + 12);
  v2 = 2;
  result = 0;
  do
  {
    v4 = (term->environment & v2) == 0;
    v2 = *v1;
    result -= v4 - 1;
    v1 += 3;
  }
  while ( v2 );
  return result;
}

//----- (080BEA60) --------------------------------------------------------
void __cdecl open_new_window(
        terminal *term,
        unsigned __int8 *exe_name,
        term_env_type environment,
        unsigned __int8 *param)
{
  int v4; // ebx
  char v5; // cl
  int *v6; // eax
  int v7; // edx
  unsigned __int8 *command; // ebx
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // ebx
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax

  v4 = 0;
  v5 = environment;
  v6 = (_DWORD *)(open_in_new_0 + 12);
  if ( (environment & 2) != 0 )
  {
LABEL_14:
    command = open_in_new_0[v4].command;
  }
  else
  {
    while ( 1 )
    {
      v7 = *v6;
      ++v4;
      if ( !*v6 )
        break;
      v6 += 3;
      if ( (v7 & environment) != 0 )
        goto LABEL_14;
    }
    command = 0;
  }
  if ( !assert_failed )
  {
    assert_failed = command == 0;
    if ( !command )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/osdep/newwin.c";
      errline = 74;
      elinks_internal("assertion command failed!");
      v5 = environment;
    }
  }
  if ( (environment & 2) != 0 )
  {
    v11 = getenv("ELINKS_XTERM");
    if ( !v11 )
    {
      v13 = getenv("LINKS_XTERM");
      if ( v13 )
        command = (unsigned __int8 *)v13;
      goto LABEL_11;
    }
  }
  else
  {
    if ( (v5 & 0x20) == 0 )
    {
LABEL_11:
      v9 = straconcat(command, &start, exe_name, &start, param, 0);
      goto LABEL_12;
    }
    v11 = getenv("ELINKS_TWTERM");
    if ( !v11 )
    {
      v12 = getenv("LINKS_TWTERM");
      if ( v12 )
        command = (unsigned __int8 *)v12;
      goto LABEL_11;
    }
  }
  v9 = straconcat((const unsigned __int8 *)v11, &start, exe_name, &start, param, 0);
LABEL_12:
  v10 = v9;
  if ( v9 )
  {
    exec_on_terminal(term, v9, (unsigned __int8 *)&delete, TERM_EXEC_NEWWIN);
    mem_free(v10);
  }
}

//----- (080BEBE0) --------------------------------------------------------
void __cdecl sigwinch(void *s)
{
  ((void (*)(void))s)();
}

//----- (080BEBF0) --------------------------------------------------------
void __cdecl set_bin(int fd)
{
  ;
}

//----- (080BEC00) --------------------------------------------------------
int __cdecl resize_window(int width, int height, int old_width, int old_height)
{
  return -1;
}

//----- (080BEC10) --------------------------------------------------------
void want_draw()
{
  ;
}

//----- (080BEC20) --------------------------------------------------------
void done_draw()
{
  ;
}

//----- (080BEC30) --------------------------------------------------------
int get_output_handle()
{
  return 1;
}

//----- (080BEC40) --------------------------------------------------------
void terminate_osdep()
{
  ;
}

//----- (080BEC50) --------------------------------------------------------
void block_stdin()
{
  ;
}

//----- (080BEC60) --------------------------------------------------------
void unblock_stdin()
{
  ;
}

//----- (080BEC70) --------------------------------------------------------
void __cdecl elinks_cfmakeraw(termios *t)
{
  t->c_iflag &= 0xFFFFFE14;
  t->c_oflag &= ~1u;
  t->c_lflag &= 0xFFFF7FB4;
  t->c_cc[6] = 1;
  t->c_cc[5] = 0;
}

//----- (080BECA0) --------------------------------------------------------
int __cdecl can_resize_window(int environment)
{
  return (environment & 0xA) != 0;
}

//----- (080BECB0) --------------------------------------------------------
int __cdecl can_open_os_shell(int environment)
{
  return 1;
}

//----- (080BECC0) --------------------------------------------------------
void set_highpri()
{
  ;
}

//----- (080BECD0) --------------------------------------------------------
unsigned __int8 *__cdecl get_system_str(int xwin)
{
  unsigned __int8 *result; // eax

  result = "unix-xwin";
  if ( !xwin )
    return "unix";
  return result;
}

//----- (080BECF0) --------------------------------------------------------
void init_osdep()
{
  setlocale(6, &delete);
}

//----- (080BED10) --------------------------------------------------------
int get_ctl_handle()
{
  int v0; // edx
  int result; // eax

  v0 = isatty(0);
  result = 0;
  if ( !v0 )
  {
    result = fd_7506;
    if ( fd_7506 < 0 )
    {
      result = open64("/dev/tty", 0);
      fd_7506 = result;
    }
  }
  return result;
}
// 80598F8: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (080BED60) --------------------------------------------------------
int get_input_handle()
{
  return get_ctl_handle();
}

//----- (080BED70) --------------------------------------------------------
unsigned __int8 *get_window_title()
{
  return stracpy((const unsigned __int8 *)&delete);
}

//----- (080BED90) --------------------------------------------------------
unsigned __int8 *get_clipboard_text()
{
  const unsigned __int8 *v0; // eax

  v0 = clipboard;
  if ( !clipboard )
    v0 = (const unsigned __int8 *)&delete;
  return stracpy(v0);
}

//----- (080BEDB0) --------------------------------------------------------
int __cdecl exe(unsigned __int8 *path)
{
  return system((const char *)path);
}

//----- (080BEDC0) --------------------------------------------------------
int is_xterm()
{
  int result; // eax
  char *v1; // ebx
  char *v2; // eax

  result = xt_7330;
  if ( xt_7330 == -1 )
  {
    v1 = getenv("DISPLAY");
    v2 = getenv("WINDOWID");
    if ( !v2 || !*v2 )
      v2 = getenv("KONSOLE_DCOP_SESSION");
    result = v1 && v2 && *v1 && *v2 != 0;
    xt_7330 = result;
  }
  return result;
}

//----- (080BEE40) --------------------------------------------------------
int is_gnuscreen()
{
  int result; // eax

  result = screen_7320;
  if ( screen_7320 == -1 )
  {
    result = getenv("STY") != 0;
    screen_7320 = result;
  }
  return result;
}

//----- (080BEE80) --------------------------------------------------------
void __cdecl set_window_title(unsigned __int8 *title, int codepage)
{
  unsigned __int8 *v2; // ebx
  unicode_val_T v3; // eax
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // ecx
  unsigned int v7; // eax
  size_t v8; // edx
  unsigned __int8 *v9; // eax
  size_t v10; // [esp+10h] [ebp-38h]
  int v11; // [esp+14h] [ebp-34h]
  unsigned __int8 *v12; // [esp+14h] [ebp-34h]
  unsigned int v13; // [esp+18h] [ebp-30h]
  unsigned __int8 *end; // [esp+1Ch] [ebp-2Ch]
  string filtered; // [esp+24h] [ebp-24h] BYREF
  unsigned __int8 *scan; // [esp+2Ch] [ebp-1Ch] BYREF

  v2 = title;
  if ( (is_xterm() || is_gnuscreen()) && init_string(&filtered) )
  {
    if ( title )
    {
      scan = title;
      end = &title[strlen((const char *)title)];
      while ( 1 )
      {
        while ( 1 )
        {
          v3 = cp_to_unicode(codepage, &scan, end);
          v4 = scan;
          if ( v3 == -3 )
            goto LABEL_21;
          v5 = (unsigned __int8 *)(scan - v2);
          if ( v3 - 127 > 0x20 && v3 > 0x1F )
            break;
LABEL_19:
          v2 = v4;
        }
        if ( (int)&v5[filtered.length] > 596 )
        {
          add_to_string(&filtered, &bytes);
          break;
        }
        if ( !assert_failed )
        {
          if ( v2 && (int)v5 >= 0 )
          {
            assert_failed = 0;
LABEL_14:
            if ( v5 )
            {
              v6 = &v5[filtered.length];
              v7 = filtered.length + 255;
              v8 = (size_t)&v5[filtered.length + 256];
              LOBYTE(v7) = 0;
              LOBYTE(v8) = 0;
              v13 = v7;
              if ( v8 > v7 )
              {
                v10 = v8;
                v12 = &v5[filtered.length];
                v9 = (unsigned __int8 *)mem_realloc(filtered.source, v8);
                if ( v9 )
                {
                  filtered.source = v9;
                  memset(&v9[v13], 0, v10 - v13);
                  v6 = v12;
                  goto LABEL_16;
                }
              }
              else
              {
LABEL_16:
                if ( filtered.source )
                {
                  v11 = (int)v6;
                  memcpy(&filtered.source[filtered.length], v2, (size_t)v5);
                  filtered.source[v11] = 0;
                  filtered.length = v11;
                }
              }
            }
            v4 = scan;
            goto LABEL_19;
          }
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 255;
          elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if ( !assert_failed )
            goto LABEL_14;
          v4 = scan;
        }
        assert_failed = 0;
        v2 = v4;
      }
    }
LABEL_21:
    __printf_chk(1, "\x1B]0;%s\a", (const char *)filtered.source);
    fflush(stdout);
    done_string(&filtered);
  }
}
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (080BF0A0) --------------------------------------------------------
void __cdecl set_clipboard_text(unsigned __int8 *data)
{
  int length; // ecx
  int v2; // eax
  string str; // [esp+18h] [ebp-10h] BYREF

  if ( is_gnuscreen() )
  {
    if ( !init_string(&str) )
      return;
    add_to_string(&str, "screen -X register . ");
    v2 = strlen((const char *)data);
    add_shell_quoted_to_string(&str, data, v2);
    length = str.length;
    if ( str.length )
      system((const char *)str.source);
    if ( str.source )
      done_string(&str);
  }
  if ( clipboard )
    free(clipboard);
  clipboard = (unsigned __int8 *)__strdup(length, data);
}
// 80BF0CC: variable 'length' is possibly undefined
// 8059A88: using guessed type int __thiscall __strdup(_DWORD, _DWORD);

//----- (080BF140) --------------------------------------------------------
int is_twterm()
{
  int result; // eax

  result = tw_7310;
  if ( tw_7310 == -1 )
  {
    result = getenv("TWDISPLAY") != 0;
    tw_7310 = result;
  }
  return result;
}

//----- (080BF180) --------------------------------------------------------
int get_system_env()
{
  int v0; // ebx
  bool v1; // zf
  int v2; // eax

  v0 = is_xterm() != 0 ? 2 : 0;
  if ( is_twterm() )
    v0 |= 0x20u;
  v1 = is_gnuscreen() == 0;
  v2 = v0;
  if ( !v1 )
    v2 = v0 | 4;
  return v2 | 1;
}

//----- (080BF1C0) --------------------------------------------------------
char *get_shell()
{
  char *result; // eax

  result = getenv("SHELL");
  if ( !result || !*result )
    return "/bin/sh";
  return result;
}

//----- (080BF1F0) --------------------------------------------------------
int __cdecl c_pipe(int *fd)
{
  return pipe(fd);
}

//----- (080BF200) --------------------------------------------------------
void __cdecl unhandle_terminal_resize(int fd)
{
  install_signal_handler(28, 0, 0, 0);
}

//----- (080BF230) --------------------------------------------------------
void __cdecl handle_terminal_resize(int fd, void (*fn)(void))
{
  install_signal_handler(28, sigwinch, fn, 0);
}

//----- (080BF260) --------------------------------------------------------
void __cdecl set_cwd(unsigned __int8 *path)
{
  if ( path )
  {
    while ( chdir((const char *)path) && *__errno_location() == 4 )
      ;
  }
}

//----- (080BF290) --------------------------------------------------------
char *get_cwd()
{
  size_t v0; // esi
  char *v1; // eax
  char *v2; // ebx
  int v3; // eax

  v0 = 128;
LABEL_2:
  v1 = (char *)mem_alloc(v0);
  v2 = v1;
  if ( v1 )
  {
    while ( !getcwd(v1, v0) )
    {
      mem_free(v2);
      v3 = *__errno_location();
      if ( v3 == 4 )
        goto LABEL_2;
      if ( v3 != 34 )
        return 0;
      v0 += 128;
      v1 = (char *)mem_alloc(v0);
      v2 = v1;
      if ( !v1 )
        return v2;
    }
  }
  return v2;
}

//----- (080BF300) --------------------------------------------------------
int __cdecl get_e(unsigned __int8 *env)
{
  char *v1; // edx
  int result; // eax

  v1 = getenv((const char *)env);
  result = 0;
  if ( v1 )
    return strtol(v1, 0, 10);
  return result;
}

//----- (080BF340) --------------------------------------------------------
void __cdecl get_terminal_size(int fd, int *x, int *y)
{
  int v3; // eax
  int v4; // edx
  int e; // eax
  int v6; // edx
  winsize ws; // [esp+18h] [ebp-10h] BYREF

  if ( ioctl(1, 0x5413u, &ws) == -1 )
  {
    *x = 0;
    *y = 0;
  }
  else
  {
    *x = ws.ws_col;
    *y = ws.ws_row;
  }
  if ( !*x )
  {
    e = get_e("COLUMNS");
    v6 = 80;
    if ( e )
      v6 = e;
    *x = v6;
  }
  if ( !*y )
  {
    v3 = get_e("LINES");
    v4 = 25;
    if ( v3 )
      v4 = v3;
    *y = v4;
  }
}

//----- (080BF3E0) --------------------------------------------------------
void __cdecl set_ip_tos_throughput(int socket)
{
  int on[3]; // [esp+2Ch] [ebp-Ch] BYREF

  on[0] = 8;
  setsockopt(socket, 0, 1, on, 4u);
}
// 80BF3E0: using guessed type int on[3];

//----- (080BF420) --------------------------------------------------------
int __cdecl set_blocking_fd(int fd)
{
  int v1; // edx
  int result; // eax

  v1 = fcntl(fd, 3, 0);
  result = -1;
  if ( v1 >= 0 )
  {
    BYTE1(v1) &= ~8u;
    return fcntl(fd, 4, v1);
  }
  return result;
}

//----- (080BF470) --------------------------------------------------------
int __cdecl set_nonblocking_fd(int fd)
{
  int v1; // edx
  int result; // eax

  v1 = fcntl(fd, 3, 0);
  result = -1;
  if ( v1 >= 0 )
  {
    BYTE1(v1) |= 8u;
    return fcntl(fd, 4, v1);
  }
  return result;
}

//----- (080BF4C0) --------------------------------------------------------
int __cdecl start_thread(void (*fn)(void *, int), void *ptr, int l)
{
  __pid_t v4; // eax
  list_head_elinks *i; // ebx
  int p[2]; // [esp+18h] [ebp-10h] BYREF

  if ( pipe(p) < 0 || set_nonblocking_fd(p[0]) < 0 || set_nonblocking_fd(p[1]) < 0 )
    return -1;
  v4 = fork();
  if ( !v4 )
  {
    for ( i = (list_head_elinks *)terminals.next; i != &terminals; i = (list_head_elinks *)i->next )
    {
      if ( (int)i[4].next > 0 )
        close((int)i[4].next);
    }
    close(p[0]);
    fn(ptr, p[1]);
    write(p[1], "x", 1u);
    close(p[1]);
    _exit(0);
  }
  if ( v4 == -1 )
  {
    close(p[0]);
    close(p[1]);
    return -1;
  }
  else
  {
    close(p[1]);
    return p[0];
  }
}

//----- (080BF5C0) --------------------------------------------------------
void __cdecl sig_ign(void *x)
{
  ;
}

//----- (080BF5D0) --------------------------------------------------------
int check_signals()
{
  int result; // eax
  int i; // ebx
  void (*handler)(void *); // eax

  result = 0;
  for ( i = 0; i != 32; ++i )
  {
    if ( *(_DWORD *)(i * 16 + 135589292) )
    {
      handler = signal_info_0[i].handler;
      *(_DWORD *)(i * 16 + 135589292) = 0;
      if ( handler )
        handler(*(void **)(i * 16 + 135589284));
      check_bottom_halves();
      result = 1;
    }
  }
  return result;
}

//----- (080BF630) --------------------------------------------------------
void __cdecl sig_chld(void *p)
{
  while ( waitpid(-1, 0, 1) > 0 )
    ;
}

//----- (080BF660) --------------------------------------------------------
void uninstall_alarm()
{
  pending_alarm = 0;
  alarm(0);
}

//----- (080BF680) --------------------------------------------------------
void __cdecl __noreturn sig_segv(terminal *term)
{
  fputc(7, stderr);
  fflush(stderr);
  sleep(1u);
  fwrite("\a\n", 1u, 2u, stderr);
  fwrite(
    "ELinks crashed. That shouldn't happen. Please report this incident to\n"
    "the developers. If you would like to help to debug the problem you just\n"
    "uncovered, please keep the core you just got and send the developers\n"
    "the output of 'bt' command entered inside of gdb (which you run as:\n"
    "gdb elinks core). Thanks a lot for your cooperation!\n"
    "\n",
    1u,
    0x14Du,
    stderr);
  fputs((const char *)full_static_version, stderr);
  fwrite(&ptr, 1u, 2u, stderr);
  dump_backtrace(stderr, 1);
  abort();
}

//----- (080BF760) --------------------------------------------------------
void __cdecl sig_cont(terminal *term)
{
  if ( !unblock_itrm() )
    resize_terminal();
}

//----- (080BF790) --------------------------------------------------------
void __cdecl sig_tstp(terminal *term)
{
  __pid_t v1; // ebx

  v1 = getpid();
  block_itrm();
  if ( !fork() )
  {
    sleep(1u);
    kill(v1, 18);
    _exit(0);
  }
  raise(19);
}

//----- (080BF7F0) --------------------------------------------------------
void __cdecl sig_ctrl_c(terminal *term)
{
  if ( !is_blocked() )
    kbd_ctrl_c();
}

//----- (080BF820) --------------------------------------------------------
void clear_signal_mask_and_handlers()
{
  memset(signal_info_0, 0, sizeof(signal_info_0));
}

//----- (080BF840) --------------------------------------------------------
void __cdecl install_signal_handler(int sig, void (*fn)(void *), void *data, int critical)
{
  unsigned int v4; // eax
  unsigned int v5; // esi
  sigaction sa; // [esp+14h] [ebp-A4h] BYREF

  if ( assert_failed
    || (assert_failed = (unsigned int)sig > 0x1F) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/osdep/signals.c",
        errline = 261,
        elinks_internal("assertion sig >= 0 && sig < NUM_SIGNALS failed: bad signal number: %d", sig),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    memset(&sa, 0, sizeof(sa));
    if ( fn )
    {
      sa.sa_handler = got_signal;
      sigfillset(&sa.sa_mask);
      v4 = 16 * sig;
      signal_info_0[v4 / 0x10].handler = fn;
      *(_DWORD *)(v4 + 135589284) = data;
      *(_DWORD *)(v4 + 135589288) = critical;
      sigaction(sig, &sa, 0);
    }
    else
    {
      sa.sa_handler = (__sighandler_t)1;
      sigfillset(&sa.sa_mask);
      v5 = 16 * sig;
      sigaction(sig, &sa, 0);
      signal_info_0[v5 / 0x10].handler = 0;
      *(_DWORD *)(v5 + 135589284) = data;
      *(_DWORD *)(v5 + 135589288) = critical;
    }
  }
}

//----- (080BF980) --------------------------------------------------------
void set_sigcld()
{
  install_signal_handler(17, sig_chld, 0, 1);
}

//----- (080BF9B0) --------------------------------------------------------
void check_for_select_race()
{
  if ( critical_section )
  {
    install_signal_handler(14, alarm_handler, 0, 1);
    pending_alarm = 1;
    alarm(1u);
  }
}

//----- (080BFA10) --------------------------------------------------------
void __cdecl alarm_handler(void *x)
{
  pending_alarm = 0;
  check_for_select_race();
}

//----- (080BFA30) --------------------------------------------------------
void __cdecl got_signal(int sig)
{
  int *v1; // esi
  int v2; // edi
  void (*handler)(void *); // edx
  signal_info *v4; // eax

  v1 = __errno_location();
  v2 = *v1;
  if ( (unsigned int)sig <= 0x1F )
  {
    handler = signal_info_0[sig].handler;
    v4 = &signal_info_0[sig];
    if ( handler )
    {
      if ( v4->critical )
      {
        handler(v4->data);
      }
      else
      {
        v4->mask = 1;
        check_for_select_race();
      }
      *v1 = v2;
    }
  }
}

//----- (080BFAA0) --------------------------------------------------------
void __cdecl unhandle_terminal_signals(terminal *term)
{
  install_signal_handler(1, 0, 0, 0);
  install_signal_handler(2, 0, 0, 0);
  install_signal_handler(20, 0, 0, 0);
  install_signal_handler(21, 0, 0, 0);
  install_signal_handler(22, 0, 0, 0);
  install_signal_handler(18, 0, 0, 0);
  install_signal_handler(11, 0, 0, 0);
}

//----- (080BFBB0) --------------------------------------------------------
void __cdecl handle_basic_signals(terminal *term)
{
  install_signal_handler(1, (void (*)(void *))sig_intr, term, 0);
  install_signal_handler(2, (void (*)(void *))sig_ctrl_c, term, 0);
  install_signal_handler(15, (void (*)(void *))sig_terminate, term, 0);
  install_signal_handler(20, (void (*)(void *))sig_tstp, term, 0);
  install_signal_handler(21, (void (*)(void *))sig_tstp, term, 0);
  install_signal_handler(22, sig_ign, term, 0);
  install_signal_handler(18, (void (*)(void *))sig_cont, term, 0);
  install_signal_handler(11, (void (*)(void *))sig_segv, term, 1);
}

//----- (080BFCC0) --------------------------------------------------------
void unhandle_basic_signals()
{
  install_signal_handler(1, 0, 0, 0);
  install_signal_handler(2, 0, 0, 0);
  install_signal_handler(15, 0, 0, 0);
  install_signal_handler(20, 0, 0, 0);
  install_signal_handler(21, 0, 0, 0);
  install_signal_handler(22, 0, 0, 0);
  install_signal_handler(18, 0, 0, 0);
  install_signal_handler(11, 0, 0, 0);
}

//----- (080BFDF0) --------------------------------------------------------
void __cdecl sig_terminate(terminal *term)
{
  unhandle_basic_signals();
  program_0.terminate = 1;
  program_0.retval = RET_SIGNAL;
}

//----- (080BFE20) --------------------------------------------------------
void __cdecl sig_intr(terminal *term)
{
  unhandle_basic_signals();
  if ( term )
    register_bottom_half_do((select_handler_T)destroy_terminal, term);
  else
    program_0.terminate = 1;
}

//----- (080BFE60) --------------------------------------------------------
void get_system_name()
{
  FILE *v0; // eax
  FILE *v1; // ebx
  unsigned __int8 *v2; // eax
  utsname name; // [esp+26h] [ebp-192h] BYREF
  unsigned int v4; // [esp+1ACh] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  if ( !uname(&name) )
  {
    __snprintf_chk(system_name, 1024, 1, 1024, "%s %s %s", name.sysname, name.release, name.machine);
    return;
  }
  v0 = popen("uname -srm", (const char *)"r");
  v1 = v0;
  if ( !v0 )
    goto LABEL_5;
  if ( !fread(system_name, 1u, 0x3FFu, v0) )
  {
    pclose(v1);
LABEL_5:
    safe_strncpy(system_name, "Unix", 0x400u);
    return;
  }
  pclose(v1);
  v2 = system_name;
  for ( system_name[1023] = 0; *v2 > 0x1Fu; ++v2 )
    ;
  *v2 = 0;
  if ( !system_name[0] )
    goto LABEL_5;
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080BFFA0) --------------------------------------------------------
int __usercall init_mouse@<eax>(int cons@<eax>, int suspend@<edx>)
{
  unsigned __int16 v2; // dx
  Gpm_Connect_0 conn; // [esp+10h] [ebp-18h] BYREF

  if ( suspend )
  {
    conn.eventMask = 0;
    v2 = -1;
    conn.defaultMask = -1;
    conn.minMod = -1;
  }
  else
  {
    conn.eventMask = -1;
    v2 = 0;
    conn.defaultMask = 0;
    conn.minMod = 0;
  }
  conn.maxMod = v2;
  gpm_visiblepointer = 1;
  return Gpm_Open(&conn, cons);
}
// 8148C50: using guessed type int gpm_visiblepointer;

//----- (080C0000) --------------------------------------------------------
void __cdecl resume_mouse(void *h)
{
  int inited; // eax

  if ( h )
  {
    inited = init_mouse(*((_DWORD *)h + 1), 0);
    *(_DWORD *)h = inited;
    if ( inited >= 0 )
      set_handlers(inited, (select_handler_T)gpm_mouse_in, 0, 0, h);
  }
}

//----- (080C0050) --------------------------------------------------------
void __cdecl suspend_mouse(void *h)
{
  int inited; // eax

  if ( h )
  {
    inited = init_mouse(*((_DWORD *)h + 1), 1);
    *(_DWORD *)h = inited;
    if ( inited >= 0 )
      set_handlers(inited, 0, 0, 0, 0);
  }
}

//----- (080C00A0) --------------------------------------------------------
void __cdecl unhandle_mouse(void *h)
{
  if ( h )
  {
    set_handlers(*(_DWORD *)h, 0, 0, 0, 0);
    mem_free(h);
    Gpm_Close();
  }
}

//----- (080C0100) --------------------------------------------------------
void *__cdecl handle_mouse(int cons, void (*fn)(void *, unsigned __int8 *, int), void *data)
{
  int inited; // esi
  _DWORD *v5; // eax
  void *v6; // edi

  inited = init_mouse(cons, 0);
  if ( inited < 0 )
    return 0;
  v5 = mem_alloc(0x10u);
  v6 = v5;
  if ( !v5 )
    return 0;
  *v5 = inited;
  v5[1] = cons;
  v5[2] = fn;
  v5[3] = data;
  set_handlers(inited, (select_handler_T)gpm_mouse_in, 0, 0, v5);
  return v6;
}

//----- (080C0180) --------------------------------------------------------
void __cdecl gpm_mouse_in(gpm_mouse_spec *gms)
{
  __int16 x; // si
  _WORD *v2; // eax
  __int16 y; // di
  __int16 v4; // dx
  int v5; // eax
  __int16 v6; // dx
  unsigned int v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // edi
  Gpm_Event_0 gev; // [esp+24h] [ebp-44h] BYREF
  interlink_event ev; // [esp+40h] [ebp-28h] BYREF

  if ( Gpm_GetEvent(&gev) <= 0 )
  {
    set_handlers(gms->h, 0, 0, 0, 0);
    return;
  }
  x = gev.x;
  v2 = (_WORD *)gpm_arg;
  y = gev.y;
  byte_8148C81 = 2;
  v4 = gpm_zerobased + gev.x;
  *(_WORD *)(gpm_arg + 4) = gpm_zerobased + gev.x;
  *v2 = v4;
  v5 = gpm_arg;
  v6 = gev.y + gpm_zerobased;
  *(_WORD *)(gpm_arg + 6) = gev.y + gpm_zerobased;
  *(_WORD *)(v5 + 2) = v6;
  *(_WORD *)(gpm_arg + 8) = 3;
  ioctl(1, 0x541Cu, &byte_8148C81);
  v7 = 0;
  if ( (gev.buttons & 4) == 0 )
  {
    LOBYTE(v7) = 1;
    if ( (gev.buttons & 2) == 0 )
    {
      LOBYTE(v7) = 2;
      if ( (gev.buttons & 1) == 0 )
      {
        LOBYTE(v7) = 4;
        if ( gev.wdy >= 0 )
        {
          if ( !gev.wdy )
            return;
          LOBYTE(v7) = 3;
        }
      }
    }
  }
  if ( (gev.type & 4) == 0 )
  {
    if ( (gev.type & 8) != 0 )
    {
      v7 |= 0x20u;
    }
    else if ( (gev.type & 2) != 0 )
    {
      v7 |= 0x40u;
    }
    else if ( !gev.wdy )
    {
      return;
    }
  }
  v8 = 0;
  v9 = x - 1;
  if ( v9 < 0 )
    v9 = 0;
  v10 = y - 1;
  if ( v10 >= 0 )
    v8 = v10;
  ev.ev = EVENT_MOUSE;
  *(_QWORD *)&ev.info.mouse.x = __PAIR64__(v8, v9);
  ev.info.mouse.button = v7;
  gms->fn(gms->data, (unsigned __int8 *)&ev, 16);
}
// 8148C68: using guessed type int gpm_zerobased;
// 8148C81: using guessed type char byte_8148C81;
// 8148C8C: using guessed type int gpm_arg;

//----- (080C02D0) --------------------------------------------------------
void __cdecl about_protocol_handler(connection *conn)
{
  cache_entry *cache_entry; // eax
  cache_entry *v2; // esi
  int v3; // eax
  unsigned __int8 *name; // eax
  const about_page *v5; // edi
  signed int v6; // edi
  unsigned __int8 *data; // [esp+28h] [ebp-20h]
  char *s1; // [esp+2Ch] [ebp-1Ch]

  cache_entry = get_cache_entry(conn->uri);
  v2 = cache_entry;
  if ( cache_entry && !cache_entry->content_type )
  {
    name = about_pages[0].name;
    if ( about_pages[0].name )
    {
      v5 = about_pages;
      s1 = (char *)conn->uri->data;
      while ( strcmp(s1, (const char *)name) )
      {
        ++v5;
        name = v5->name;
        if ( !v5->name )
          goto LABEL_11;
      }
      data = v5->string;
      v6 = strlen((const char *)data);
      add_fragment(v2, 0LL, data, v6);
      conn->from = v6;
      if ( v2->content_type )
        mem_free(v2->content_type);
    }
LABEL_11:
    v2->content_type = stracpy("text/html");
  }
  conn->cached = v2;
  if ( assert_failed )
  {
    assert_failed = 0;
    v3 = -100003;
  }
  else
  {
    assert_failed = 0;
    v3 = -100000;
  }
  abort_connection(conn, (connection_state)(unsigned int)v3);
}

//----- (080C03F0) --------------------------------------------------------
void close_all_non_term_fd()
{
  int rlim_max; // esi
  int v1; // ebx
  int v2; // [esp+0h] [ebp-28h]
  rlimit lim; // [esp+10h] [ebp-18h] BYREF

  if ( getrlimit64(7, &lim) )
  {
    rlim_max = 1024;
  }
  else
  {
    rlim_max = lim.rlim_max;
    if ( SLODWORD(lim.rlim_max) <= 3 )
      return;
  }
  v1 = 3;
  do
  {
    v2 = v1++;
    close(v2);
  }
  while ( v1 < rlim_max );
}
// 8059898: using guessed type int __cdecl getrlimit64(_DWORD, _DWORD);

//----- (080C0450) --------------------------------------------------------
connection_state *__userpurge init_directory_listing@<eax>(connection_state *retstr, string *page, uri *uri)
{
  char *v3; // eax
  unsigned __int8 *source; // esi
  signed int v5; // edx
  unsigned int v6; // eax
  size_t v7; // ecx
  char *v8; // edi
  connection_basic_state v9; // eax
  connection_basic_state v11; // eax
  unsigned __int8 *v12; // eax
  size_t v13; // [esp+14h] [ebp-54h]
  signed int v14; // [esp+18h] [ebp-50h]
  int v15; // [esp+20h] [ebp-48h]
  int local; // [esp+24h] [ebp-44h]
  int locala; // [esp+24h] [ebp-44h]
  int localb; // [esp+24h] [ebp-44h]
  string location; // [esp+34h] [ebp-34h] BYREF
  string decoded; // [esp+3Ch] [ebp-2Ch] BYREF
  string dirpath; // [esp+44h] [ebp-24h] BYREF
  char sep[25]; // [esp+4Fh] [ebp-19h] BYREF

  dirpath.source = 0;
  dirpath.length = 0;
  decoded.source = 0;
  decoded.length = 0;
  location.source = 0;
  location.length = 0;
  local = uri->protocol;
  if ( !init_string(page)
    || !init_string(&dirpath)
    || !init_string(&decoded)
    || !init_string(&location)
    || !add_uri_to_string(&dirpath, uri, URI_DATA)
    || !add_uri_to_string(&location, uri, URI_DIR_LOCATION)
    || dirpath.length > 0 && dirpath.source[dirpath.length - 1] != 47 && !add_char_to_string(&dirpath, 0x2Fu) )
  {
    goto out_of_memory;
  }
  if ( !add_string_to_string(&decoded, &dirpath) )
    goto out_of_memory;
  locala = local == 4;
  decode_uri_string(&decoded);
  if ( !locala && !add_char_to_string(&location, 0x2Fu) )
    goto out_of_memory;
  if ( !add_to_string(page, &byte_8131EF1)
    || !locala && !add_html_to_string(page, location.source, location.length)
    || !add_html_to_string(page, decoded.source, decoded.length)
    || !add_to_string(page, "</title>\n<base href=\"")
    || !add_html_to_string(page, location.source, location.length)
    || !add_html_to_string(page, dirpath.source, dirpath.length)
    || !add_to_string(page, "\" />\n</head>\n<body>\n<h2>") )
  {
    goto out_of_memory;
  }
  switch ( uri->protocol )
  {
    case 4:
      v3 = "Local";
      break;
    case 6:
      v3 = "FSP";
      break;
    case 7:
      v3 = "FTP";
      break;
    case 8:
      v3 = "Gopher";
      break;
    case 0x10:
      v3 = "Samba";
      break;
    default:
      v3 = "?";
      break;
  }
  if ( !add_to_string(page, (const unsigned __int8 *)v3)
    || !add_to_string(page, " directory ")
    || !locala && !add_string_to_string(page, &location) )
  {
    goto out_of_memory;
  }
  sep[0] = 47;
  source = dirpath.source;
  while ( 1 )
  {
    v8 = strchr((const char *)source, 47);
    if ( !v8 )
      break;
    done_string(&decoded);
    if ( !init_string(&decoded) )
      goto out_of_memory;
    if ( assert_failed )
    {
LABEL_43:
      assert_failed = 0;
      goto out_of_memory;
    }
    v5 = v8 - (char *)source;
    if ( source && v5 >= 0 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      v5 = v8 - (char *)source;
      if ( assert_failed )
        goto LABEL_43;
    }
    if ( v5 )
    {
      v6 = decoded.length + 255;
      v15 = v5 + decoded.length;
      v7 = v5 + decoded.length + 256;
      LOBYTE(v6) = 0;
      LOBYTE(v7) = 0;
      localb = v6;
      if ( v7 > v6 )
      {
        v13 = v7;
        v14 = v5;
        v12 = (unsigned __int8 *)mem_realloc(decoded.source, v7);
        if ( !v12 )
          goto out_of_memory;
        decoded.source = v12;
        memset(&v12[localb], 0, v13 - localb);
        v5 = v14;
      }
      if ( !decoded.source )
        goto out_of_memory;
      memcpy(&decoded.source[decoded.length], source, v5);
      decoded.source[v15] = 0;
      decoded.length = v15;
    }
    decode_uri_string(&decoded);
    if ( add_to_string(page, "<a href=\"") )
    {
      if ( add_html_to_string(page, location.source, location.length) )
      {
        source = (unsigned __int8 *)(v8 + 1);
        if ( add_html_to_string(page, dirpath.source, v8 + 1 - (char *)dirpath.source) )
        {
          if ( add_to_string(page, "\">")
            && add_html_to_string(page, decoded.source, decoded.length)
            && add_to_string(page, "</a>")
            && add_html_to_string(page, (const unsigned __int8 *)sep, 1) )
          {
            continue;
          }
        }
      }
    }
    goto out_of_memory;
  }
  if ( !add_to_string(page, "</h2>\n<pre>") )
out_of_memory:
    done_string(page);
  done_string(&dirpath);
  done_string(&decoded);
  done_string(&location);
  if ( page->length <= 0 )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v11 = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v11 = S_OUT_OF_MEM;
    }
    retstr->syserr = 0;
    retstr->basic = v11;
    return retstr;
  }
  else
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v9 = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v9 = S_OK;
    }
    retstr->syserr = 0;
    retstr->basic = v9;
    return retstr;
  }
}
// 80C0450: using guessed type unsigned __int8 sep[25];

//----- (080C0A60) --------------------------------------------------------
connection_basic_state *__usercall connection_state_3@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080C0AF0) --------------------------------------------------------
void __cdecl data_protocol_handler(connection *conn)
{
  uri *v1; // ecx
  _BYTE *v2; // eax
  const unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int8 *v6; // esi
  const unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // eax
  char *v9; // esi
  unsigned __int8 *v10; // eax
  signed int v11; // edi
  int v12; // eax
  void *v13; // eax
  char *v14; // [esp+0h] [ebp-68h]
  unsigned __int8 *s; // [esp+2Ch] [ebp-3Ch]
  int base64; // [esp+30h] [ebp-38h]
  uri *v17; // [esp+34h] [ebp-34h]
  uri *uri; // [esp+38h] [ebp-30h]
  _BYTE *v19; // [esp+3Ch] [ebp-2Ch]
  int len; // [esp+40h] [ebp-28h]
  cache_entry *cached; // [esp+44h] [ebp-24h]
  connection_state state; // [esp+48h] [ebp-20h] BYREF

  uri = conn->uri;
  cached = get_cache_entry(uri);
  if ( !cached )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      v12 = -100004;
      goto LABEL_22;
    }
    goto LABEL_27;
  }
  v1 = conn->uri;
  conn->cached = cached;
  v17 = v1;
  s = v1->data;
  v2 = memchr(s, 44, *(unsigned __int16 *)((char *)v1 + 49));
  v19 = v2;
  if ( v2 )
  {
    len = v2 - s;
    if ( (unsigned int)(v2 - s) > 6 && !memcmp(";base64", v2 - 7, 7u) )
    {
      len -= 7;
      base64 = 1;
    }
    else
    {
      base64 = 0;
    }
    if ( len <= 2 || (v13 = memchr(s, 47, len), v3 = s, !v13) )
    {
      v3 = "text/plain;charset=US-ASCII";
      len = 27;
    }
  }
  else
  {
    v3 = "text/plain;charset=US-ASCII";
    base64 = 0;
    len = 27;
  }
  if ( !assert_failed )
    assert_failed = 0;
  v4 = memacpy(v3, len);
  v5 = v4;
  if ( v4 )
  {
    v6 = straconcat("\r\nContent-Type: ", v4, "\r\n", 0);
    mem_free(v5);
    if ( v6 )
    {
      if ( cached->head )
        mem_free(cached->head);
      cached->head = v6;
      v7 = v19 ? v19 + 1 : v17->data;
      if ( v7 )
      {
        v8 = memacpy(v7, &uri->data[*(unsigned __int16 *)((char *)uri + 49)] - (unsigned __int8 *)v7);
        v9 = (char *)v8;
        if ( v8 )
        {
          if ( !base64 )
          {
            decode_uri(v8);
LABEL_20:
            v11 = strlen(v9);
            add_fragment(cached, conn->from, (const unsigned __int8 *)v9, v11);
            conn->from += v11;
            mem_free(v9);
            if ( !assert_failed )
            {
              assert_failed = 0;
              v12 = -100000;
LABEL_22:
              abort_connection(conn, (connection_state)(unsigned int)v12);
              return;
            }
LABEL_27:
            assert_failed = 0;
            v12 = -100003;
            goto LABEL_22;
          }
          v10 = base64_encode(v8);
          if ( v10 )
          {
            v14 = v9;
            v9 = (char *)v10;
            mem_free(v14);
            goto LABEL_20;
          }
        }
      }
    }
  }
  connection_state_3(S_OUT_OF_MEM, &state.basic);
  abort_connection(conn, state);
}

//----- (080C0DD0) --------------------------------------------------------
int __cdecl parse_year(const unsigned __int8 **date_p, unsigned __int8 *end)
{
  const unsigned __int8 *v2; // ecx
  int result; // eax
  unsigned __int8 v4; // si
  unsigned __int8 v5; // [esp+3h] [ebp-Dh]

  v2 = *date_p;
  if ( end && end <= v2 + 1 || (unsigned __int8)(*v2 - 48) > 9u || (unsigned __int8)(v2[1] - 48) > 9u )
    return -1;
  result = v2[1] + 10 * *v2 - 528;
  if ( !end || end > v2 + 3 )
  {
    v5 = v2[2];
    if ( (unsigned __int8)(v5 - 48) <= 9u )
    {
      v4 = v2[3];
      if ( (unsigned __int8)(v4 - 48) <= 9u )
      {
        v2 += 4;
        result = 10 * (10 * result + v5 - 48) + v4 - 1948;
LABEL_11:
        *date_p = v2;
        return result;
      }
    }
  }
  if ( result > 69 )
    goto LABEL_11;
  result += 100;
  *date_p = v2 + 2;
  return result;
}

//----- (080C0EA0) --------------------------------------------------------
int __cdecl parse_day(const unsigned __int8 **date_p, unsigned __int8 *end)
{
  const unsigned __int8 *v2; // edx
  const unsigned __int8 *v3; // esi
  int result; // eax
  unsigned __int8 v5; // dl

  v2 = *date_p;
  if ( *date_p >= end && end || (unsigned __int8)(*v2 - 48) > 9u )
    return 32;
  v3 = v2 + 1;
  result = *v2 - 48;
  if ( v2 + 1 >= end && end || (v5 = v2[1], (unsigned __int8)(v5 - 48) > 9u) )
  {
    *date_p = v3;
  }
  else
  {
    result = v5 + 10 * result - 48;
    *date_p = v3 + 1;
  }
  return result;
}

//----- (080C0F20) --------------------------------------------------------
int __cdecl parse_time(const unsigned __int8 **time, tm *tm, unsigned __int8 *end)
{
  const unsigned __int8 *v3; // eax
  unsigned __int8 v5; // di
  unsigned __int8 v6; // bl
  _BYTE *v7; // eax
  _BYTE *v8; // eax
  unsigned __int8 v9; // bl
  int v10; // [esp+0h] [ebp-18h]
  const unsigned __int8 *v11; // [esp+4h] [ebp-14h]
  unsigned __int8 v12; // [esp+Bh] [ebp-Dh]

  v3 = *time;
  if ( end && end < v3 + 5 )
    return 0;
  if ( (unsigned __int8)(*v3 - 48) > 9u )
    return 0;
  if ( (unsigned __int8)(v3[1] - 48) > 9u )
    return 0;
  if ( v3[2] != 58 )
    return 0;
  v5 = v3[3];
  if ( (unsigned __int8)(v5 - 48) > 9u )
    return 0;
  v12 = v3[4];
  if ( (unsigned __int8)(v12 - 48) > 9u )
    return 0;
  v11 = v3 + 5;
  v10 = v3[1] + 10 * *v3 - 528;
  tm->tm_hour = v10;
  tm->tm_min = v12 + 10 * v5 - 528;
  tm->tm_sec = 0;
  if ( end && end <= v3 + 7 )
  {
    *time = v11;
    if ( tm->tm_hour <= 23 && tm->tm_min <= 59 )
      return tm->tm_sec <= 59;
    return 0;
  }
  v6 = v3[5];
  if ( v6 == 58 )
  {
    v8 = v3 + 6;
    if ( end && end <= v11 + 3 )
      return 0;
    if ( (unsigned __int8)(*v8 - 48) > 9u )
      return 0;
    v9 = v11[2];
    if ( (unsigned __int8)(v9 - 48) > 9u )
      return 0;
    v11 += 3;
    tm->tm_sec = v9 + 10 * (unsigned __int8)*v8 - 528;
  }
  else if ( v6 == 80 || v6 == 65 )
  {
    if ( v10 == 12 )
    {
      tm->tm_hour = 0;
      v6 = v3[5];
    }
    v7 = v3 + 6;
    if ( v6 == 80 )
      tm->tm_hour += 12;
    if ( *v7 != 77 )
      return 0;
    v11 += 2;
  }
  *time = v11;
  if ( tm->tm_hour > 23 || tm->tm_min > 59 )
    return 0;
  return tm->tm_sec <= 59;
}

//----- (080C10F0) --------------------------------------------------------
int __cdecl parse_month(const unsigned __int8 **buf, unsigned __int8 *end)
{
  const unsigned __int8 *v2; // edx
  int result; // eax

  v2 = *buf;
  if ( end && end < v2 + 2 || !*v2 || !v2[1] || !v2[2] )
    return -1;
  result = month2num(*buf);
  if ( result != -1 )
    *buf += 3;
  return result;
}

//----- (080C1140) --------------------------------------------------------
time_t __cdecl parse_date(unsigned __int8 **date_pos, unsigned __int8 *end, int update_pos, int skip_week_day)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 v5; // dl
  unsigned __int8 *v6; // esi
  time_t result; // eax
  const unsigned __int8 *v8; // eax
  const unsigned __int8 *v9; // ecx
  char v10; // dl
  const unsigned __int8 *v11; // eax
  const unsigned __int8 *v12; // ecx
  char v13; // dl
  const unsigned __int8 *v14; // eax
  const unsigned __int8 *v15; // ecx
  char v16; // dl
  int v17; // ebx
  unsigned __int8 v18; // dl
  const unsigned __int8 *v19; // eax
  const unsigned __int8 *v20; // ecx
  char v21; // dl
  const unsigned __int8 *v22; // eax
  const unsigned __int8 *v23; // ecx
  char v24; // dl
  const unsigned __int8 *v25; // eax
  const unsigned __int8 *v26; // ecx
  char v27; // dl
  const unsigned __int8 *start; // [esp+1Ch] [ebp-4Ch]
  const unsigned __int8 *starta; // [esp+1Ch] [ebp-4Ch]
  const unsigned __int8 *startb; // [esp+1Ch] [ebp-4Ch]
  const unsigned __int8 *startc; // [esp+1Ch] [ebp-4Ch]
  const unsigned __int8 *startd; // [esp+1Ch] [ebp-4Ch]
  const unsigned __int8 *starte; // [esp+1Ch] [ebp-4Ch]
  tm tm; // [esp+20h] [ebp-48h] BYREF
  const unsigned __int8 *date[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  v4 = *date_pos;
  if ( !*date_pos )
    return 0;
  date[0] = *date_pos;
  if ( skip_week_day )
  {
    if ( end && v4 >= end )
      return 0;
    v5 = *v4;
    v6 = v4;
    if ( *v4 != 32 )
    {
      while ( 1 )
      {
        if ( !v5 )
          return 0;
        date[0] = ++v4;
        if ( end <= v4 )
        {
          if ( end )
            break;
        }
        v5 = *v4;
        if ( *v4 == 32 )
        {
          v6 = v4;
          if ( end == 0 || end > v4 )
            goto LABEL_49;
          goto LABEL_13;
        }
      }
      v6 = v4;
LABEL_13:
      if ( v6 == v4 )
        return 0;
      v4 = (unsigned __int8 *)date[0];
      goto LABEL_15;
    }
    while ( 1 )
    {
LABEL_49:
      while ( 1 )
      {
        date[0] = ++v4;
        if ( end > v4 )
          break;
        if ( end )
          goto LABEL_13;
        v18 = *v4;
        if ( *v4 != 45 )
          goto LABEL_51;
      }
      v18 = *v4;
      if ( *v4 != 45 )
      {
LABEL_51:
        if ( v18 != 32 )
          goto LABEL_13;
      }
    }
  }
LABEL_15:
  if ( (unsigned __int8)(*v4 - 48) > 9u )
  {
    tm.tm_mon = parse_month(date, end);
    if ( tm.tm_mon < 0 )
      return 0;
    v19 = date[0];
    startc = date[0];
    while ( 1 )
    {
      v20 = v19;
      if ( end )
      {
        if ( end <= v19 )
          break;
      }
      v21 = *v19++;
      if ( v21 != 45 && v21 != 32 )
        break;
      date[0] = v19;
    }
    if ( startc == v20 )
      return 0;
    tm.tm_mday = parse_day(date, end);
    if ( tm.tm_mday > 31 )
      return 0;
    v22 = date[0];
    startd = date[0];
    while ( 1 )
    {
      v23 = v22;
      if ( end )
      {
        if ( end <= v22 )
          break;
      }
      v24 = *v22++;
      if ( v24 != 45 && v24 != 32 )
        break;
      date[0] = v22;
    }
    if ( startd == v23 || !parse_time(date, &tm, end) )
      return 0;
    v25 = date[0];
    starte = date[0];
    while ( 1 )
    {
      v26 = v25;
      if ( end )
      {
        if ( end <= v25 )
          break;
      }
      v27 = *v25++;
      if ( v27 != 45 && v27 != 32 )
        break;
      date[0] = v25;
    }
    if ( v26 == starte )
      return 0;
    tm.tm_year = parse_year(date, end);
    if ( tm.tm_year < 0 )
      return 0;
  }
  else
  {
    tm.tm_mday = parse_day(date, end);
    if ( tm.tm_mday > 31 )
      return 0;
    v8 = date[0];
    start = date[0];
    while ( 1 )
    {
      v9 = v8;
      if ( end )
      {
        if ( end <= v8 )
          break;
      }
      v10 = *v8++;
      if ( v10 != 45 && v10 != 32 )
        break;
      date[0] = v8;
    }
    if ( start == v9 )
      return 0;
    tm.tm_mon = parse_month(date, end);
    if ( tm.tm_mon < 0 )
      return 0;
    v11 = date[0];
    starta = date[0];
    while ( 1 )
    {
      v12 = v11;
      if ( end )
      {
        if ( end <= v11 )
          break;
      }
      v13 = *v11++;
      if ( v13 != 45 && v13 != 32 )
        break;
      date[0] = v11;
    }
    if ( starta == v12 )
      return 0;
    tm.tm_year = parse_year(date, end);
    if ( tm.tm_year < 0 )
      return 0;
    v14 = date[0];
    startb = date[0];
    while ( 1 )
    {
      v15 = v14;
      if ( end )
      {
        if ( end <= v14 )
          break;
      }
      v16 = *v14++;
      if ( v16 != 45 && v16 != 32 )
        break;
      date[0] = v14;
    }
    if ( startb == v15 || !parse_time(date, &tm, end) )
      return 0;
  }
  if ( update_pos )
    *date_pos = (unsigned __int8 *)date[0];
  v17 = tm.tm_mon - 2;
  if ( tm.tm_mon - 2 < 0 )
  {
    v17 = tm.tm_mon + 10;
    --tm.tm_year;
  }
  result = tm.tm_sec
         + 3600 * tm.tm_hour
         + 60 * tm.tm_min
         + 86400 * (tm.tm_mday + 1461 * (tm.tm_year - 68) / 4 + (153 * v17 + 2) / 5 - 672);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (080C14D0) --------------------------------------------------------
unsigned __int8 *__cdecl get_header_param(unsigned __int8 *e, unsigned __int8 *name)
{
  unsigned __int8 v3; // al
  unsigned __int8 *result; // eax
  int v5; // ebx
  unsigned __int8 v6; // al
  unsigned __int8 *v7; // ebx
  int v8; // edi
  const unsigned __int16 **v9; // eax
  unsigned __int8 v10; // dl
  const unsigned __int16 *v11; // ecx
  unsigned __int8 v12; // dl
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // ebx
  unsigned __int8 *v15; // esi
  unsigned __int8 *v16; // eax
  int v17; // edx
  unsigned __int8 *v18; // edi
  char *v19; // ecx
  char v20; // dl
  unsigned __int8 v21; // dl
  unsigned __int8 v22; // [esp+18h] [ebp-20h]

  do
  {
LABEL_1:
    v3 = *e;
    if ( !*e )
      return 0;
    ++e;
    v5 = c_toupper(v3);
  }
  while ( v5 != c_toupper(*name) );
  v6 = *e;
  if ( !*e )
    return 0;
  v7 = name + 1;
  if ( name[1] )
  {
    while ( 1 )
    {
      v8 = c_toupper(v6);
      if ( v8 != c_toupper(*v7) )
        break;
      ++v7;
      ++e;
      if ( !*v7 )
        goto LABEL_12;
      v6 = *e;
    }
    if ( *v7 )
      goto LABEL_1;
LABEL_12:
    v21 = *e;
  }
  else
  {
    v21 = *e;
  }
  v22 = v21;
  v9 = __ctype_b_loc();
  v10 = v22;
  v11 = *v9;
  while ( (v11[v10] & 0x2000) != 0 )
    v10 = *++e;
  if ( v10 != 61 )
    return 0;
  v12 = e[1];
  v13 = e + 1;
  if ( (v11[v12] & 0x2000) != 0 )
  {
    do
      v12 = *++v13;
    while ( (v11[*v13] & 0x2000) != 0 );
  }
  if ( v12 == 39 || v12 == 34 )
  {
    if ( *++v13 != v12 )
    {
      v14 = v13;
      if ( !*v13 )
        return 0;
      while ( *++v14 != v12 )
      {
        if ( !*v14 )
          return 0;
      }
      goto LABEL_25;
    }
LABEL_51:
    v15 = v13;
    v14 = v13;
    goto LABEL_35;
  }
  if ( !*v13 || (v11[*v13] & 0x2000) != 0 )
    goto LABEL_51;
  v14 = v13;
  do
    ++v14;
  while ( *v14 && (v11[*v14] & 0x2000) == 0 );
LABEL_25:
  v15 = v13;
  if ( v14 > v13 )
  {
    while ( *v15 == 32 )
    {
      if ( v14 <= ++v15 )
        goto LABEL_35;
    }
    v16 = v14 - 1;
    if ( *(v14 - 1) == 32 )
    {
      while ( v15 < v16 && *(v16 - 1) == 32 )
        --v16;
      v14 = v16;
    }
  }
LABEL_35:
  if ( v15 == v14 )
    return 0;
  result = (unsigned __int8 *)mem_alloc(v14 + 1 - v15);
  if ( result )
  {
    v17 = 0;
    if ( v14 > v15 )
    {
      v18 = result;
      v19 = (char *)v15;
      do
      {
        v20 = *v19;
        if ( (unsigned __int8)*v19 <= 0x1Fu )
          v20 = 46;
        ++v19;
        *v18++ = v20;
      }
      while ( v14 > (unsigned __int8 *)v19 );
      v17 = v14 - v15;
    }
    result[v17] = 0;
  }
  return result;
}

//----- (080C16E0) --------------------------------------------------------
parse_header_param __cdecl parse_header_param_0(unsigned __int8 *str, unsigned __int8 *name, unsigned __int8 **ret)
{
  const char *v3; // ebx
  size_t v4; // esi
  char v5; // al
  const unsigned __int8 *v6; // ebx
  unsigned __int8 v7; // al
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // eax
  int i; // eax
  unsigned __int8 v12; // dl
  int v13; // edx
  unsigned __int8 v14; // cl
  const unsigned __int8 *v15; // eax
  char v16; // cl
  unsigned __int8 *v17; // eax
  const unsigned __int8 *v18; // ecx
  char v19; // dl

  v3 = (const char *)str;
  if ( ret )
    *ret = 0;
  if ( assert_failed )
    goto LABEL_23;
  if ( name && str && *name )
  {
    assert_failed = 0;
    if ( !*str )
      return 1;
    goto LABEL_7;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/header.c";
  errline = 216;
  elinks_internal("assertion str && name && *name failed!");
  if ( assert_failed )
  {
LABEL_23:
    assert_failed = 0;
    return 1;
  }
  if ( !*str )
    return 1;
LABEL_7:
  v4 = strlen((const char *)name);
  do
  {
    v3 = strchr(v3, 59);
    if ( v3 )
    {
      while ( 1 )
      {
        v5 = *v3;
        if ( !*v3 || (unsigned __int8)v5 > 0x20u && v5 != 59 )
          break;
        ++v3;
      }
      if ( v4 <= strlen(v3) )
        continue;
    }
    return 1;
  }
  while ( c_strncasecmp(v3, (const char *)name, v4) );
  v6 = (const unsigned __int8 *)&v3[v4];
  v7 = *v6;
  if ( !*v6 )
    goto LABEL_20;
  if ( v7 <= 0x20u || v7 == 61 )
  {
    while ( 1 )
    {
      v8 = *++v6;
      if ( !*v6 )
        break;
      if ( v8 != 61 && v8 > 0x20u )
        goto LABEL_31;
    }
LABEL_20:
    if ( ret )
    {
      v9 = stracpy((const unsigned __int8 *)&delete);
      *ret = v9;
      if ( !v9 )
        return 2;
    }
    return 0;
  }
LABEL_31:
  for ( i = 0; ; ++i )
  {
    v12 = v6[i];
    if ( v12 <= 0x20u )
      break;
    if ( v12 == 59 )
      goto LABEL_36;
LABEL_33:
    ;
  }
  if ( v12 == 9 || v12 == 32 )
    goto LABEL_33;
LABEL_36:
  v13 = i;
  if ( i )
  {
    v14 = v6[i - 1];
    if ( v14 == 9 || v14 == 32 )
    {
      v15 = &v6[i];
      while ( --v13 )
      {
        v16 = *(v15 - 2);
        --v15;
        if ( v16 != 9 && v16 != 32 )
          goto LABEL_46;
      }
LABEL_41:
      i = v13;
    }
    else
    {
LABEL_46:
      if ( v13 <= 1 )
        goto LABEL_41;
      if ( *v6 != 39 )
        goto LABEL_41;
      v18 = &v6[v13];
      if ( v6[v13 - 1] != 39 )
        goto LABEL_41;
      while ( 1 )
      {
        i = v13 - 2;
        ++v6;
        if ( v13 - 2 <= 1 )
          break;
        if ( *v6 != 39 )
          break;
        v19 = *(v18 - 2);
        --v18;
        if ( v19 != 39 )
          break;
        v13 = i;
      }
    }
  }
  if ( !ret )
    return 0;
  v17 = memacpy(v6, i);
  *ret = v17;
  if ( v17 )
    return 0;
  return 2;
}

//----- (080C1970) --------------------------------------------------------
unsigned __int8 *__cdecl parse_header(unsigned __int8 *head, unsigned __int8 *item, unsigned __int8 **ptr)
{
  unsigned __int8 *v3; // esi
  unsigned __int8 *result; // eax
  int v5; // ebx
  unsigned __int8 v6; // dl
  unsigned __int8 *v7; // ebx
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // esi
  int v10; // edi
  unsigned __int8 v11; // al
  unsigned __int8 v12; // dl
  unsigned __int8 v13; // al
  unsigned __int8 *v14; // ecx
  char v15; // dl
  unsigned __int8 *v16; // eax
  char v17; // dl

  v3 = head;
  if ( head )
  {
LABEL_6:
    v6 = *v3;
LABEL_7:
    while ( v6 )
    {
      if ( v6 != 10 )
      {
        while ( *++v3 != 10 )
        {
          if ( !*v3 )
            return 0;
        }
      }
      v7 = v3 + 1;
      v8 = *item;
      if ( *item )
      {
        if ( !v3[1] )
          return 0;
        v9 = item;
        while ( 1 )
        {
          v10 = c_toupper(v8);
          if ( v10 != c_toupper(*v7) )
            break;
          ++v9;
          ++v7;
          v8 = *v9;
          if ( !*v9 )
            break;
          if ( !*v7 )
            return 0;
        }
      }
      else
      {
        v9 = item;
      }
      v11 = *v7;
      if ( !*v7 )
        break;
      if ( *v9 )
        goto LABEL_20;
      if ( v11 == 32 || (v12 = *v7, v3 = v7, v11 == 9) )
      {
        v3 = v7;
        do
        {
          do
            v12 = *++v3;
          while ( *v3 == 9 );
        }
        while ( v12 == 32 );
        if ( !v12 )
          return 0;
      }
      if ( v12 == 61 || v12 == 58 )
        ++v3;
      v6 = *v3;
      if ( !*v3 )
        return 0;
      if ( v6 == 9 || v6 == 32 )
      {
        do
        {
          do
            v6 = *++v3;
          while ( *v3 == 9 );
        }
        while ( v6 == 32 );
        if ( !v6 )
          return 0;
      }
      if ( v7 == v3 )
      {
LABEL_20:
        v6 = *v7;
        v3 = v7;
      }
      else
      {
        v13 = v6;
        v14 = v3;
        if ( v6 != 127 )
        {
          while ( v13 > 0x20u || v13 == 9 || v13 == 32 )
          {
            v13 = *++v14;
            if ( *v14 == 127 )
              goto LABEL_7;
          }
          if ( !v13 )
            return 0;
          if ( v13 == 10 || v13 == 13 )
          {
            if ( v14 > v3 )
            {
              v15 = *(v14 - 1);
              v16 = v14 - 1;
              if ( v15 == 32 || v15 == 9 )
              {
                while ( v16 > v3 )
                {
                  v17 = *(v16 - 1);
                  if ( v17 == 9 )
                  {
                    --v16;
                  }
                  else
                  {
                    if ( v17 != 32 )
                      break;
                    --v16;
                  }
                }
                v14 = v16;
              }
            }
            if ( assert_failed
              || (v5 = v14 - v3, assert_failed = (unsigned int)(v14 - v3) >> 31, v14 - v3 < 0)
              && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/header.c",
                  errline = 179,
                  elinks_internal("assertion len >= 0 failed!"),
                  assert_failed) )
            {
              assert_failed = 0;
              return 0;
            }
            else
            {
              if ( !v5 )
                goto LABEL_6;
              result = memacpy(v3, v5);
              if ( result )
              {
                if ( ptr )
                  *ptr = v3;
              }
            }
            return result;
          }
        }
      }
    }
  }
  return 0;
}

//----- (080C1C00) --------------------------------------------------------
protocol_handler_T *__cdecl get_protocol_handler(protocol protocol)
{
  if ( assert_failed )
    goto LABEL_2;
  assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
  if ( (unsigned int)protocol <= PROTOCOL_LUA )
    return protocol_backends[protocol].handler;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
  errline = 206;
  elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
  if ( assert_failed )
  {
LABEL_2:
    assert_failed = 0;
    return 0;
  }
  return protocol_backends[protocol].handler;
}

//----- (080C1C80) --------------------------------------------------------
int __cdecl get_protocol_need_ssl(protocol protocol)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
    if ( (unsigned int)protocol <= PROTOCOL_LUA )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 8) != 0;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 198;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if ( !assert_failed )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 8) != 0;
  }
  assert_failed = 0;
  return 0;
}

//----- (080C1D10) --------------------------------------------------------
int __cdecl get_protocol_free_syntax(protocol protocol)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
    if ( (unsigned int)protocol <= PROTOCOL_LUA )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 4) != 0;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 190;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if ( !assert_failed )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 4) != 0;
  }
  assert_failed = 0;
  return 0;
}

//----- (080C1DA0) --------------------------------------------------------
int __cdecl get_protocol_keep_double_slashes(protocol protocol)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
    if ( (unsigned int)protocol <= PROTOCOL_LUA )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 0x10) != 0;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 182;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if ( !assert_failed )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 0x10) != 0;
  }
  assert_failed = 0;
  return 0;
}

//----- (080C1E30) --------------------------------------------------------
int __cdecl get_protocol_need_slash_after_host(protocol protocol)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
    if ( (unsigned int)protocol <= PROTOCOL_LUA )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 2) != 0;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 174;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if ( !assert_failed )
      return (*((_BYTE *)&protocol_backends[protocol] + 12) & 2) != 0;
  }
  assert_failed = 0;
  return 0;
}

//----- (080C1EC0) --------------------------------------------------------
int __cdecl get_protocol_need_slashes(protocol protocol)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
    if ( (unsigned int)protocol <= PROTOCOL_LUA )
      return *((_BYTE *)&protocol_backends[protocol] + 12) & 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 166;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if ( !assert_failed )
      return *((_BYTE *)&protocol_backends[protocol] + 12) & 1;
  }
  assert_failed = 0;
  return 0;
}

//----- (080C1F40) --------------------------------------------------------
int __cdecl get_protocol_port(protocol protocol)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_6;
  assert_failed = (unsigned int)protocol > PROTOCOL_LUA;
  if ( (unsigned int)protocol > PROTOCOL_LUA )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 154;
    elinks_internal("assertion VALID_PROTOCOL(protocol) failed!");
    if ( assert_failed )
      goto LABEL_6;
  }
  result = protocol_backends[protocol].port;
  assert_failed = (unsigned int)result > 0xFFFF;
  if ( (unsigned int)result > 0xFFFF )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 157;
    v2 = result;
    elinks_internal("assertion uri_port_is_valid(protocol_backends[protocol].port) failed!");
    result = v2;
    if ( assert_failed )
    {
LABEL_6:
      assert_failed = 0;
      return 0;
    }
  }
  return result;
}

//----- (080C2000) --------------------------------------------------------
protocol_external_handler_T *__cdecl get_protocol_external_handler(terminal *term, uri *uri)
{
  protocol_external_handler_T *result; // eax
  unsigned __int8 *user_program; // edx

  if ( assert_failed )
    goto LABEL_2;
  if ( uri && uri->protocol <= 0x14u )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/protocol.c";
    errline = 258;
    elinks_internal("assertion uri && VALID_PROTOCOL(uri->protocol) failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  user_program = get_user_program(term, uri->string, *((unsigned __int16 *)uri + 20));
  if ( !user_program || (result = user_protocol_handler, !*user_program) )
  {
    result = 0;
    if ( !protocol_backends[uri->protocol].handler )
      return generic_external_protocol_handler;
  }
  return result;
}

//----- (080C20C0) --------------------------------------------------------
protocol __cdecl get_protocol(unsigned __int8 *name, int namelen)
{
  int v2; // ebx
  int v3; // edx
  unsigned __int8 *v4; // edi
  int v5; // eax
  int v6; // esi
  int v7; // eax
  int v8; // eax
  bool v9; // cc
  int v11; // [esp+18h] [ebp-20h]
  int start; // [esp+1Ch] [ebp-1Ch]

  if ( !assert_failed )
    assert_failed = 0;
  v2 = 9;
  v3 = 17;
  for ( start = 0; ; v2 = (v3 + start) / 2 )
  {
    v4 = protocol_backends[v2].name;
    v11 = v3;
    v5 = strlen((const char *)v4);
    v9 = v5 <= namelen;
    v6 = v5;
    v7 = namelen;
    if ( v9 )
      v7 = v6;
    v8 = c_strncasecmp((const char *)v4, (const char *)name, v7);
    v3 = v11;
    v9 = v8 <= 0;
    if ( !v8 )
    {
      v9 = v6 <= namelen;
      if ( v6 == namelen )
        break;
    }
    if ( v9 )
      start = v2 + 1;
    else
      v3 = v2 - 1;
    if ( start > v3 )
      return 19 - (get_user_program(0, name, namelen) == 0);
  }
  return v2;
}

//----- (080C2190) --------------------------------------------------------
void __cdecl generic_external_protocol_handler(session *ses, uri *uri)
{
  int protocol; // eax
  unsigned __int8 *v3; // eax
  int v4; // eax

  protocol = uri->protocol;
  if ( protocol == 11 )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      v4 = -100600;
      goto LABEL_6;
    }
  }
  else
  {
    if ( protocol != 18 )
    {
      v3 = msg_text(
             ses->tab->term,
             "This version of ELinks does not contain %s protocol support",
             (const char *)protocol_backends[protocol].name);
      msg_box(ses->tab->term, 0, MSGBOX_FREE_TEXT, "Error", ALIGN_CENTER, v3, ses, 1, &okbutton, 0, 3);
      return;
    }
    if ( !assert_failed )
    {
      assert_failed = 0;
      v4 = -100015;
      goto LABEL_6;
    }
  }
  assert_failed = 0;
  v4 = -100003;
LABEL_6:
  print_error_dialog(ses, (connection_state)(unsigned int)v4, uri, PRI_CANCEL);
}

//----- (080C22B0) --------------------------------------------------------
uri *__cdecl get_proxied_uri(uri *uri)
{
  if ( uri->protocol == 15 )
    return get_uri(uri->data, URI_BASE);
  else
    return get_composed_uri(uri, URI_BASE);
}

//----- (080C22F0) --------------------------------------------------------
unsigned __int8 *__usercall strip_proxy_protocol@<eax>(
        unsigned __int8 *proxy@<eax>,
        unsigned __int8 *strip1@<edx>,
        unsigned __int8 *strip2@<ecx>)
{
  unsigned __int8 *v3; // ebx
  size_t v6; // eax
  size_t v7; // eax

  v3 = proxy;
  if ( !assert_failed )
  {
    if ( proxy && *proxy )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/proxy.c";
      errline = 87;
      elinks_internal("assertion proxy && *proxy failed!");
    }
  }
  v6 = strlen((const char *)strip1);
  if ( c_strncasecmp((const char *)v3, (const char *)strip1, v6) )
  {
    if ( strip2 )
    {
      v7 = strlen((const char *)strip2);
      if ( !c_strncasecmp((const char *)v3, (const char *)strip2, v7) )
        v3 += strlen((const char *)strip2);
    }
  }
  else
  {
    v3 += strlen((const char *)strip1);
  }
  return v3;
}

//----- (080C23C0) --------------------------------------------------------
unsigned __int8 *__usercall get_protocol_proxy@<eax>(
        unsigned __int8 *opt@<eax>,
        unsigned __int8 *env1@<edx>,
        unsigned __int8 *env2@<ecx>,
        unsigned __int8 *strip1,
        unsigned __int8 *strip2)
{
  unsigned __int8 *result; // eax

  result = (unsigned __int8 *)get_opt_(config_options, opt)->number;
  if ( !*result )
    result = (unsigned __int8 *)getenv((const char *)env1);
  if ( result && *result )
    return strip_proxy_protocol(result, strip1, strip2);
  result = (unsigned __int8 *)getenv((const char *)env2);
  if ( result )
  {
    if ( *result )
      return strip_proxy_protocol(result, strip1, strip2);
  }
  return result;
}

//----- (080C2450) --------------------------------------------------------
uri *__usercall proxy_uri@<eax>(uri *uri@<eax>, unsigned __int8 *proxy@<edx>, connection_state *error_state@<ecx>)
{
  uri *v5; // ebx
  connection_basic_state v7; // eax
  connection_basic_state v8; // eax
  string string; // [esp+38h] [ebp-20h] BYREF

  if ( init_string(&string)
    && string_concat(&string, "proxy://", proxy, "/", 0)
    && add_uri_to_string(&string, uri, URI_BASE) )
  {
    v5 = get_uri(string.source, (uri_component)0);
    if ( !v5 )
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v8 = S_INTERNAL;
      }
      else
      {
        assert_failed = 0;
        v8 = S_PROXY_ERROR;
      }
      error_state->basic = v8;
      error_state->syserr = 0;
    }
  }
  else
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v7 = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v7 = S_OUT_OF_MEM;
    }
    v5 = 0;
    error_state->basic = v7;
    error_state->syserr = 0;
  }
  done_string(&string);
  return v5;
}

//----- (080C2570) --------------------------------------------------------
uri *__cdecl get_proxy_uri(uri *uri, connection_state *error_state)
{
  uri *v2; // ebx
  int event_id; // eax
  uri *result; // eax
  unsigned __int8 *v5; // eax
  int protocol; // eax
  char *v7; // eax
  option_value *opt; // eax
  char *number; // esi
  char *v10; // eax
  unsigned __int8 v11; // bl
  char *v12; // edi
  uri *v13; // [esp+18h] [ebp-40h]
  char *v14; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 *s; // [esp+20h] [ebp-38h]
  const unsigned __int16 **v16; // [esp+28h] [ebp-30h]
  char *haystack; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *tmp; // [esp+3Ch] [ebp-1Ch] BYREF

  v2 = uri;
  if ( uri->protocol == 15 )
    return get_composed_uri(uri, URI_BASE);
  event_id = get_proxy_event_id_5943;
  tmp = 0;
  if ( get_proxy_event_id_5943 == -1 )
  {
    event_id = get_event_id("get-proxy");
    get_proxy_event_id_5943 = event_id;
  }
  trigger_event(event_id, &tmp, uri->string);
  if ( !tmp )
  {
    protocol = uri->protocol;
    switch ( protocol )
    {
      case 9:
        s = get_protocol_proxy("protocol.http.proxy.host", "HTTP_PROXY", "http_proxy", "http://", 0);
        break;
      case 10:
        s = get_protocol_proxy("protocol.https.proxy.host", "HTTPS_PROXY", "https_proxy", "http://", 0);
        break;
      case 7:
        s = get_protocol_proxy("protocol.ftp.proxy.host", "FTP_PROXY", "ftp_proxy", "ftp://", "http://");
        break;
      default:
        goto LABEL_6;
    }
    if ( s && *s )
    {
      v7 = strchr((const char *)s, 47);
      if ( v7 )
        *v7 = 0;
      opt = get_opt_(config_options, "protocol.no_proxy");
      number = (char *)opt->number;
      if ( !*opt->string )
        number = getenv("NO_PROXY");
      if ( !number || !*number )
        number = getenv((const char *)"no_proxy");
      haystack = (char *)uri->host;
      v10 = strchr(haystack, 47);
      v14 = v10;
      if ( v10 )
        *v10 = 0;
      if ( !number || !*number )
      {
LABEL_37:
        if ( v14 )
          *v14 = 47;
        result = proxy_uri(v2, s, error_state);
        goto LABEL_7;
      }
      v11 = *number;
      v16 = __ctype_b_loc();
      while ( 1 )
      {
        v12 = strchr(number, 44);
        while ( ((*v16)[v11] & 0x2000) != 0 )
          v11 = *++number;
        if ( v12 )
          *v12 = 0;
        if ( c_strcasestr(haystack, number) )
          break;
        if ( v12 )
        {
          number = v12 + 1;
          *v12 = 44;
          if ( v12 != (char *)-1 )
          {
            v11 = v12[1];
            if ( v11 )
              continue;
          }
        }
        v2 = uri;
        goto LABEL_37;
      }
      v2 = uri;
      if ( v12 )
        *v12 = 44;
      if ( v14 )
        *v14 = 47;
    }
    goto LABEL_6;
  }
  if ( !*tmp )
  {
LABEL_6:
    result = get_composed_uri(v2, URI_BASE);
    goto LABEL_7;
  }
  v5 = strip_proxy_protocol(tmp, "http://", "ftp://");
  result = proxy_uri(uri, v5, error_state);
LABEL_7:
  if ( tmp )
  {
    v13 = result;
    mem_free(tmp);
    return v13;
  }
  return result;
}

//----- (080C2850) --------------------------------------------------------
void __cdecl decode_uri(unsigned __int8 *src)
{
  unsigned __int8 *v1; // eax
  unsigned __int8 *v2; // ecx
  unsigned __int8 *i; // edx
  unsigned __int8 v4; // bl
  int v5; // esi
  int v6; // esi
  unsigned __int8 v7; // bl
  int v8; // ebx
  int v9; // ebx
  unsigned __int8 v10; // [esp+4h] [ebp-10h]

  v1 = src;
  v2 = src + 1;
  for ( i = src + 1; ; ++i )
  {
    v4 = *v1;
    v1 = v2;
    if ( v4 == 37 )
      break;
    *(i - 1) = v4;
    if ( !v4 )
      return;
LABEL_3:
    v2 = v1 + 1;
  }
  v5 = *v2;
  v10 = *v2;
  if ( (unsigned __int8)(*v2 - 48) > 9u )
  {
    if ( (unsigned __int8)(v10 - 97) > 5u )
    {
      if ( (unsigned __int8)(v10 - 65) > 5u )
        goto LABEL_16;
      v6 = v5 - 55;
    }
    else
    {
      v6 = v5 - 87;
    }
  }
  else
  {
    v6 = v5 - 48;
  }
  if ( v6 < 0 )
  {
LABEL_16:
    *(i - 1) = 37;
    goto LABEL_3;
  }
  v7 = v2[1];
  if ( (unsigned __int8)(v7 - 48) > 9u )
  {
    if ( (unsigned __int8)(v7 - 97) <= 5u )
    {
      v8 = v7 - 87;
      goto LABEL_10;
    }
    if ( (unsigned __int8)(v7 - 65) <= 5u )
    {
      v8 = v7 - 55;
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  v8 = v7 - 48;
LABEL_10:
  if ( v8 < 0 )
    goto LABEL_16;
  v9 = 16 * v6 + v8;
  if ( !v9 )
    goto LABEL_16;
  v1 = v2 + 2;
  *(i - 1) = v9;
  if ( (_BYTE)v9 )
    goto LABEL_3;
}

//----- (080C2960) --------------------------------------------------------
void __cdecl decode_uri_string(string *string)
{
  decode_uri(string->source);
  string->length = strlen((const char *)string->source);
}

//----- (080C2990) --------------------------------------------------------
void __cdecl done_uri(uri *uri)
{
  unsigned __int8 *string; // esi
  unsigned int v2; // eax
  void *value; // ebx
  hash_item *hash_item; // eax
  hash_item *v6; // [esp+1Ch] [ebp-Ch]
  unsigned int v7; // [esp+1Ch] [ebp-Ch]

  string = uri->string;
  v2 = strlen((const char *)uri->string);
  if ( !assert_failed )
  {
    assert_failed = uri_cache_0.object.refcount == 0;
    if ( !uri_cache_0.object.refcount )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 1613;
      v7 = v2;
      elinks_internal("assertion is_object_used(&uri_cache) failed!");
      v2 = v7;
    }
  }
  if ( uri->object.refcount-- == 1 )
  {
    value = 0;
    hash_item = get_hash_item(uri_cache_0.map, string, v2);
    if ( hash_item )
      value = hash_item->value;
    if ( !assert_failed )
    {
      assert_failed = value == 0;
      if ( !value )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 1621;
        v6 = hash_item;
        elinks_internal("assertion entry != NULL failed: Releasing unknown URI [%s]", (const char *)string);
        hash_item = v6;
      }
    }
    del_hash_item(uri_cache_0.map, hash_item);
    mem_free(value);
    if ( !--uri_cache_0.object.refcount )
      free_hash(&uri_cache_0.map);
  }
}

//----- (080C2AC0) --------------------------------------------------------
void __cdecl free_uri_list(uri_list *list)
{
  uri **uris; // edx
  int v2; // ebx

  uris = list->uris;
  if ( uris )
  {
    if ( list->size <= 0 )
      goto LABEL_8;
    v2 = 0;
    do
    {
      if ( uris[v2] )
      {
        done_uri(uris[v2]);
        uris = list->uris;
      }
      ++v2;
    }
    while ( list->size > v2 );
    if ( uris )
LABEL_8:
      mem_free(uris);
    list->uris = 0;
    list->size = 0;
  }
}

//----- (080C2B20) --------------------------------------------------------
void *__usercall mem_align_alloc___0@<eax>(
        void **ptr@<eax>,
        size_t old@<edx>,
        size_t a3@<ecx>,
        size_t objsize,
        size_t mask)
{
  size_t v6; // ecx
  size_t v7; // esi
  void *result; // eax
  char *v9; // edx
  size_t v10; // [esp+1Ch] [ebp-1Ch]

  v6 = ~mask & (mask + a3);
  v7 = ~mask & (old + mask);
  if ( v6 <= v7 )
    return *ptr;
  v10 = objsize * v6;
  v9 = (char *)mem_realloc(*ptr, objsize * v6);
  result = 0;
  if ( v9 )
  {
    *ptr = v9;
    memset(&v9[objsize * v7], 0, v10 - objsize * v7);
    return *ptr;
  }
  return result;
}

//----- (080C2BA0) --------------------------------------------------------
string *__usercall add_bytes_to_string___2@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v4; // ebx
  size_t v7; // edx
  int newlength; // [esp+1Ch] [ebp-1Ch]

  v4 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  if ( length )
  {
    v7 = v4->length;
    newlength = length + v7;
    if ( mem_align_alloc___0((void **)&v4->source, v7, length + v7 + 1, 1u, 0xFFu) )
    {
      memcpy(&v4->source[v4->length], bytes, length);
      v4->source[newlength] = 0;
      v4->length = newlength;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

//----- (080C2CA0) --------------------------------------------------------
void __cdecl decode_uri_for_display(unsigned __int8 *src)
{
  unsigned __int8 *v1; // ebx
  const unsigned __int16 **v2; // eax
  unsigned __int8 v3; // dl
  unsigned __int8 v4; // [esp+1Ch] [ebp-Ch]

  v1 = src;
  decode_uri(src);
  if ( *src )
  {
    v4 = *src;
    v2 = __ctype_b_loc();
    v3 = v4;
    do
    {
      if ( ((*v2)[v3] & 0x4002) != 0x4000 )
        *v1 = 42;
      v3 = *++v1;
    }
    while ( *v1 );
  }
}

//----- (080C2D00) --------------------------------------------------------
void __cdecl decode_uri_string_for_display(string *string)
{
  decode_uri_for_display(string->source);
  string->length = strlen((const char *)string->source);
}

//----- (080C2D30) --------------------------------------------------------
unsigned __int8 *__cdecl get_extension_from_uri(uri *uri)
{
  unsigned __int8 *data; // ebx
  unsigned __int8 v2; // al
  _BOOL4 v3; // edx
  const unsigned __int8 *v4; // ecx
  _BOOL4 v5; // eax

  data = uri->data;
  if ( !assert_failed )
  {
    assert_failed = data == 0;
    if ( !data )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 1322;
      elinks_internal("assertion pos failed!");
    }
  }
  v2 = *data;
  if ( !*data || v2 == 1 || v2 == 35 || v2 == 63 )
    return 0;
  v3 = 1;
  v4 = 0;
  do
  {
    if ( v4 || v3 || v2 != 46 )
    {
      v5 = v2 == 47;
      v3 = v5;
      if ( v5 )
        v4 = 0;
    }
    else
    {
      v4 = data;
    }
    v2 = *++data;
  }
  while ( *data && v2 != 35 && v2 != 1 && v2 != 63 );
  if ( v4 >= data || !v4 )
    return 0;
  else
    return memacpy(v4, data - v4);
}

//----- (080C2E30) --------------------------------------------------------
int __cdecl end_with_known_tld(const unsigned __int8 *s, int slen)
{
  size_t v2; // ebx
  int v3; // esi
  const char *v5; // edi
  size_t v6; // eax
  int i; // [esp+1Ch] [ebp-1Ch]

  v2 = slen;
  if ( !slen )
    return -1;
  if ( slen < 0 )
    v2 = strlen((const char *)s);
  v5 = "com";
  i = 0;
  while ( 1 )
  {
    v6 = strlen(v5);
    v3 = v2 - v6;
    if ( (int)(v2 - v6) >= 0 && !c_strncasecmp((const char *)&s[v3], v5, v6) )
      break;
    v5 = (const char *)tld_7154[++i];
    if ( !v5 )
      return -1;
  }
  return v3;
}

//----- (080C2EC0) --------------------------------------------------------
int __cdecl is_in_domain(unsigned __int8 *domain, unsigned __int8 *server, int server_len)
{
  int v3; // eax
  int v5; // eax

  v3 = strlen((const char *)domain);
  if ( v3 > server_len )
    return 0;
  if ( v3 == server_len )
  {
    v5 = c_strncasecmp((const char *)domain, (const char *)server, v3);
  }
  else
  {
    if ( server[server_len - v3 - 1] != 46 )
      return 0;
    v5 = c_strncasecmp((const char *)domain, (const char *)&server[server_len - v3], v3);
  }
  return v5 == 0;
}

//----- (080C2F40) --------------------------------------------------------
int __usercall check_whether_file_exists@<eax>(unsigned __int8 *name@<eax>)
{
  int v2; // esi
  int v3; // edx
  int result; // eax
  int v5; // edi
  unsigned __int8 *v6; // eax
  int v7; // eax
  unsigned __int8 *v8; // [esp+18h] [ebp-20h]
  unsigned __int8 v9; // [esp+1Fh] [ebp-19h]

  v2 = strlen((const char *)name);
  v3 = file_exists(name);
  result = v2;
  if ( !v3 )
  {
    v5 = 0;
    while ( 1 )
    {
      v9 = chars_7182[v5];
      v6 = (unsigned __int8 *)memchr(name, v9, v2);
      if ( v6 )
      {
        *v6 = 0;
        v8 = v6;
        v7 = file_exists(name);
        *v8 = v9;
        if ( v7 )
          break;
      }
      if ( ++v5 == 3 )
        return -1;
    }
    return v8 - name;
  }
  return result;
}

//----- (080C2FD0) --------------------------------------------------------
protocol __usercall find_uri_protocol@<eax>(unsigned __int8 *newurl@<eax>)
{
  int v2; // edx
  protocol result; // eax
  unsigned __int8 *v4; // esi
  unsigned __int8 v5; // al
  const char *v6; // ebx
  const char *v7; // eax
  char v8; // dl
  int v9; // eax
  const char *v10; // esi
  char *v11; // ebx
  char *v12; // eax

  v2 = check_whether_file_exists(newurl);
  result = PROTOCOL_FILE;
  if ( v2 < 0 )
  {
    v4 = &newurl[strcspn((const char *)newurl, ".:/@")];
    if ( *v4 == 64
      || *v4 == 58 && *newurl != 91 && strchr((const char *)newurl, 64)
      || !c_strncasecmp((const char *)newurl, "ftp.", 4u) )
    {
      return 7;
    }
    if ( *newurl == 91 )
    {
      v5 = *v4;
      if ( *v4 == 58 )
      {
        v10 = (const char *)(v4 + 1);
        v11 = strchr(v10, 93);
        v12 = strchr(v10, 58);
        if ( v12 && v11 && v11 > v12 )
          return 9;
        return 18;
      }
    }
    else
    {
      if ( *newurl == 46 )
        return 18;
      v5 = *v4;
    }
    v6 = (const char *)(v4 + 1);
    if ( v5 == 46 )
    {
      while ( 1 )
      {
        v7 = &v6[strcspn(v6, ".:/?")];
        if ( *v7 != 46 )
          break;
        v6 = v7 + 1;
      }
      do
      {
        do
          v8 = *++v4;
        while ( (unsigned __int8)(*v4 - 48) <= 9u );
      }
      while ( v8 == 46 );
      switch ( v8 )
      {
        case 58:
          return 9;
        case 0:
          return 9;
        case 47:
          return 9;
      }
      v9 = v7 - v6;
      if ( v9 == 2 || end_with_known_tld((const unsigned __int8 *)v6, v9) >= 0 )
        return 9;
    }
    return 18;
  }
  return result;
}

//----- (080C3140) --------------------------------------------------------
_BOOL4 __usercall compare_component@<eax>(
        const unsigned __int8 *a@<eax>,
        int alen@<edx>,
        const unsigned __int8 *b@<ecx>,
        int blen)
{
  if ( alen != blen || (b != 0) != (a != 0) )
    return 0;
  if ( alen && a )
    return memcmp(a, b, alen) == 0;
  return 1;
}

//----- (080C31A0) --------------------------------------------------------
int __cdecl compare_uri(const uri *a, const uri *b, uri_component components)
{
  unsigned __int8 *post; // edi
  int v4; // ecx
  unsigned __int8 *v5; // ebx
  int v6; // edx
  size_t v7; // eax
  int v9; // [esp+1Ch] [ebp-1Ch]

  if ( a == b )
    return 1;
  if ( !components )
    return 0;
  if ( !assert_failed )
  {
    assert_failed = (components & 0x7840) != 0;
    if ( (components & 0x7840) != 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 468;
      elinks_internal("assertion can_compare_uri_components(components) failed: compare_uri() is a work in progress. Comp"
                      "onent unsupported");
    }
  }
  if ( (components & 1) != 0 && a->protocol != b->protocol
    || (components & 2) != 0 && a->ip_family != b->ip_family
    || (components & 4) != 0
    && !compare_component(a->user, *((unsigned __int16 *)a + 21), b->user, *((unsigned __int16 *)b + 21))
    || (components & 8) != 0
    && !compare_component(a->password, *((unsigned __int16 *)a + 22), b->password, *((unsigned __int16 *)b + 22))
    || (components & 0x10) != 0
    && !compare_component(a->host, *((unsigned __int16 *)a + 23), b->host, *((unsigned __int16 *)b + 23))
    || (components & 0x20) != 0
    && !compare_component(a->port, *((unsigned __int8 *)a + 48), b->port, *((unsigned __int8 *)b + 48))
    || (components & 0x80u) != 0
    && !compare_component(
          a->data,
          *(unsigned __int16 *)((char *)a + 49),
          b->data,
          *(unsigned __int16 *)((char *)b + 49))
    || (BYTE1(components) & 1) != 0
    && !compare_component(a->fragment, *((unsigned __int16 *)a + 26), b->fragment, *((unsigned __int16 *)b + 26)) )
  {
    return 0;
  }
  if ( (BYTE1(components) & 2) == 0 )
    return 1;
  post = b->post;
  v4 = 0;
  if ( post )
    v4 = strlen((const char *)post);
  v5 = a->post;
  v6 = 0;
  if ( v5 )
  {
    v9 = v4;
    v7 = strlen((const char *)a->post);
    v4 = v9;
    v6 = v7;
  }
  return compare_component(v5, v6, post, v4);
}

//----- (080C33E0) --------------------------------------------------------
int __cdecl get_uri_port(const uri *uri)
{
  unsigned __int8 *port; // eax
  int result; // eax
  int v3; // [esp+1Ch] [ebp-1Ch]
  const unsigned __int8 *end; // [esp+2Ch] [ebp-Ch] BYREF

  port = uri->port;
  if ( !port )
    return get_protocol_port((protocol)uri->protocol);
  if ( !*((_BYTE *)uri + 48) )
    return get_protocol_port((protocol)uri->protocol);
  end = uri->port;
  result = strtol((const char *)port, (char **)&end, 10);
  if ( uri->port == end )
    return get_protocol_port((protocol)uri->protocol);
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)result > 0xFFFF;
    if ( (unsigned int)result > 0xFFFF )
    {
      v3 = result;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 434;
      elinks_internal("assertion uri_port_is_valid(port) failed!");
      return v3;
    }
  }
  return result;
}

//----- (080C3470) --------------------------------------------------------
uri_errno __cdecl parse_uri(uri *uri, unsigned __int8 *uristring)
{
  uri *v2; // ebx
  uri_errno result; // eax
  const unsigned __int16 **v4; // eax
  unsigned __int8 *v5; // edx
  const unsigned __int16 *v6; // edi
  unsigned __int8 v7; // al
  unsigned __int16 v8; // dx
  unsigned __int8 *v9; // eax
  unsigned __int8 v10; // dl
  int protocol_need_slashes; // edx
  char *v12; // edi
  unsigned __int8 v13; // dl
  int v14; // eax
  unsigned __int8 v15; // cl
  int v16; // eax
  unsigned __int8 *v17; // edi
  unsigned __int8 v18; // cl
  int v19; // eax
  unsigned __int8 v20; // dl
  unsigned __int8 v21; // bl
  unsigned int v22; // edx
  unsigned __int8 v23; // al
  unsigned int v24; // ecx
  unsigned __int8 v25; // al
  int v26; // eax
  int v27; // edx
  unsigned __int8 v28; // dl
  int protocol_need_slash_after_host; // edx
  char *v30; // eax
  char v31; // al
  int v32; // edi
  char v33; // al
  unsigned int v34; // eax
  unsigned __int8 *v35; // esi
  unsigned __int8 v36; // al
  unsigned __int8 v37; // al
  int v38; // eax
  unsigned __int8 v39; // dl
  int v40; // ecx
  unsigned __int8 *v41; // edx
  unsigned __int8 v42; // cl
  unsigned __int8 v43; // al
  int v44; // esi
  unsigned __int8 v45; // al
  unsigned __int8 v46; // dl
  int v47; // eax
  unsigned __int8 v48; // dl
  unsigned int v49; // edi
  unsigned __int8 *v50; // edx
  unsigned __int8 v51; // si
  unsigned __int8 v52; // al
  int v53; // esi
  unsigned __int8 v54; // al
  unsigned __int8 *v55; // eax
  unsigned __int8 v56; // dl
  _BYTE *v57; // edi
  unsigned __int8 v58; // dl
  int v59; // edx
  unsigned __int8 v60; // cl
  int v61; // eax
  _BYTE *v62; // ecx
  unsigned __int8 v63; // al
  int v64; // eax
  unsigned __int8 *v65; // esi
  unsigned __int8 v66; // dl
  int v67; // edx
  int *v68; // eax
  int *v69; // edi
  uri *v70; // [esp+1Ch] [ebp-2Ch]
  char *lbracket; // [esp+20h] [ebp-28h]
  _BYTE v72[5]; // [esp+27h] [ebp-21h]
  unsigned __int8 *s; // [esp+2Ch] [ebp-1Ch]

  v2 = uri;
  if ( !assert_failed )
  {
    assert_failed = uristring == 0;
    if ( !uristring )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 212;
      elinks_internal("assertion uristring != NULL failed: No uri to parse.");
    }
  }
  result = URI_ERRNO_OK;
  memset(uri, 0, sizeof(uri));
  if ( assert_failed )
  {
    assert_failed = 0;
    return result;
  }
  result = URI_ERRNO_EMPTY;
  if ( !*uristring )
    return result;
  uri->string = uristring;
  v4 = __ctype_b_loc();
  v5 = uristring;
  v6 = *v4;
  while ( 1 )
  {
    v7 = *v5;
    if ( (v6[*v5] & 8) == 0 && v7 != 43 && v7 != 45 && v7 != 46 )
      break;
    ++v5;
  }
  if ( uristring == v5 || (unsigned __int8)(*(v5 - 1) - 48) > 9u )
  {
    if ( (unsigned __int8)(v7 - 48) > 0xAu )
    {
      *((_WORD *)uri + 20) = 0;
      return 2;
    }
  }
  else
  {
    LOWORD(v5) = (_WORD)v5 - 1;
  }
  v8 = (_WORD)v5 - (_WORD)uristring;
  *((_WORD *)uri + 20) = v8;
  if ( !v8 )
    return 2;
  uri->protocol = get_protocol(uristring, v8);
  v9 = &uristring[*((unsigned __int16 *)uri + 20)];
  v10 = *v9;
  if ( (unsigned __int8)(*v9 - 48) <= 9u )
  {
    ++v9;
    uri->ip_family = v10 - 48;
    v10 = *v9;
  }
  if ( v10 != 58 )
    return 2;
  s = v9 + 1;
  if ( v9[1] == 47 && v9[2] == 47 )
  {
    s = v9 + 3;
    if ( v9[3] == 47 )
    {
      protocol_need_slash_after_host = get_protocol_need_slash_after_host((protocol)uri->protocol);
      result = URI_ERRNO_TOO_MANY_SLASHES;
      if ( protocol_need_slash_after_host )
        return result;
    }
  }
  else
  {
    protocol_need_slashes = get_protocol_need_slashes((protocol)uri->protocol);
    result = URI_ERRNO_NO_SLASHES;
    if ( protocol_need_slashes )
      return result;
  }
  if ( get_protocol_free_syntax((protocol)uri->protocol) )
  {
    uri->data = s;
    *((_DWORD *)uri + 12) = ((unsigned __int16)strlen((const char *)s) << 8) | *((_DWORD *)uri + 12) & 0xFF0000FF;
    return 0;
  }
  if ( uri->protocol == 4 )
  {
    v52 = *s;
    if ( !*s || v52 == 35 || v52 == 1 )
    {
      v55 = s;
      v53 = 0;
    }
    else
    {
      v53 = 0;
      do
        v54 = s[++v53];
      while ( v54 && v54 != 35 && v54 != 1 );
      if ( v53 < 0 )
      {
        v53 = strlen((const char *)s);
LABEL_138:
        if ( v53 > 9 && !c_strncasecmp((const char *)s, "localhost/", 0xAu) )
        {
          s += 9;
          LOWORD(v53) = v53 - 9;
        }
        *((_DWORD *)uri + 12) = ((unsigned __int16)v53 << 8) | *((_DWORD *)uri + 12) & 0xFF0000FF;
        result = URI_ERRNO_OK;
        uri->data = s;
        return result;
      }
      v55 = &s[v53];
    }
    v56 = *v55;
    if ( *v55 == 35 )
    {
      v57 = v55 + 1;
      uri->fragment = v55 + 1;
      v58 = v55[1];
      if ( !v58 || v58 == 1 )
      {
        v61 = 0;
        LOWORD(v59) = 0;
      }
      else
      {
        v59 = 0;
        do
          v60 = v55[++v59 + 1];
        while ( v60 && v60 != 1 );
        v61 = (unsigned __int16)v59;
      }
      v55 = &v57[v61];
      *((_WORD *)uri + 26) = v59;
      v56 = *v55;
    }
    if ( v56 == 1 )
      uri->post = v55 + 1;
    goto LABEL_138;
  }
  lbracket = strchr((const char *)s, 91);
  if ( lbracket )
  {
    v12 = strchr(lbracket, 93);
    *(_DWORD *)&v72[1] = v12;
    if ( v12 )
    {
      v13 = *s;
      if ( !*s || v13 == 47 )
      {
        v14 = 0;
      }
      else
      {
        v14 = 0;
        do
          v15 = s[++v14];
        while ( v15 && v15 != 47 );
        v2 = uri;
      }
      if ( v12 < (char *)&s[v14] )
      {
        v72[0] = *((_BYTE *)v2 + 54) | 1;
        *((_BYTE *)v2 + 54) = v72[0];
        v13 = *s;
      }
      else
      {
        v72[4] = 0;
        lbracket = 0;
        *(_DWORD *)v72 = *((unsigned __int8 *)v2 + 54);
      }
    }
    else
    {
      v13 = *s;
      lbracket = 0;
      *(_DWORD *)v72 = *((unsigned __int8 *)uri + 54);
    }
  }
  else
  {
    v13 = *s;
    v72[4] = 0;
    *(_DWORD *)v72 = *((unsigned __int8 *)uri + 54);
  }
  if ( v13 )
  {
    v16 = 0;
    v17 = s;
    if ( v13 == 64 )
      goto LABEL_44;
    do
      v18 = s[++v16];
    while ( v18 && v18 != 64 );
    v17 = &s[v16];
    v19 = 0;
    if ( v13 != 47 )
    {
LABEL_44:
      v19 = 0;
      do
        v20 = s[++v19];
      while ( v20 && v20 != 47 );
    }
    if ( &s[v19] > v17 && *v17 )
    {
      v70 = v2;
      while ( 1 )
      {
        v21 = v17[1];
        if ( !v21 )
          break;
        v22 = 0;
        if ( v21 != 64 )
        {
          do
            v23 = v17[++v22 + 1];
          while ( v23 && v23 != 64 );
          if ( v21 == 47 || v21 == 63 )
            break;
        }
        v24 = 0;
        do
          v25 = v17[++v24 + 1];
        while ( v25 && v25 != 47 && v25 != 63 );
        if ( v24 <= v22 )
          break;
        v26 = 0;
        v27 = 1;
        if ( v21 != 64 )
        {
          do
            v28 = v17[++v26 + 1];
          while ( v28 && v28 != 64 );
          v27 = v26 + 1;
        }
        v17 += v27;
      }
      v2 = v70;
      v30 = strchr((const char *)s, 58);
      if ( v30 <= (char *)v17 && v30 )
      {
        v70->user = s;
        v70->password = (unsigned __int8 *)(v30 + 1);
        *((_WORD *)v70 + 21) = (_WORD)v30 - (_WORD)s;
        *((_WORD *)v70 + 22) = (_WORD)v17 - 1 - (_WORD)v30;
      }
      else
      {
        v70->user = s;
        *((_WORD *)v70 + 21) = (_WORD)v17 - (_WORD)s;
      }
      s = v17 + 1;
    }
  }
  if ( (v72[0] & 1) != 0 )
  {
    v31 = **(_BYTE **)&v72[1];
    if ( !**(_BYTE **)&v72[1] || v31 == 58 || v31 == 47 || v31 == 63 )
    {
      v32 = 0;
    }
    else
    {
      v32 = 0;
      do
      {
        ++v32;
        v33 = *(_BYTE *)(*(_DWORD *)&v72[1] + v32);
      }
      while ( v33 && v33 != 58 && v33 != 47 && v33 != 63 );
    }
    if ( assert_failed
      || (v34 = *(_DWORD *)&v72[1] - 1 - (_DWORD)lbracket, (assert_failed = v34 > 0x400) != 0)
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c",
          errline = 347,
          elinks_internal(
            "assertion addrlen >= 0 && addrlen < NI_MAXHOST failed: parse_uri(): addrlen value is bad (%d) for URL '%s'. "
            "Problems are likely to be encountered. Please report this, it is a security bug!",
            v34,
            (const char *)uristring),
          LOWORD(v34) = *(_WORD *)&v72[1] - 1 - (_WORD)lbracket,
          assert_failed) )
    {
      assert_failed = 0;
      return 9;
    }
    *((_WORD *)v2 + 23) = v34;
    v35 = (unsigned __int8 *)(v32 + *(_DWORD *)&v72[1]);
    v2->host = (unsigned __int8 *)(lbracket + 1);
  }
  else
  {
    v43 = *s;
    if ( !*s || v43 == 58 || v43 == 47 || v43 == 63 )
    {
      v44 = 0;
    }
    else
    {
      v44 = 0;
      do
        v45 = s[++v44];
      while ( v45 && v45 != 58 && v45 != 47 && v45 != 63 );
    }
    v35 = &s[v44];
    v2->host = s;
    *((_WORD *)v2 + 23) = (_WORD)v35 - (_WORD)s;
    if ( (_WORD)v35 != (_WORD)s )
    {
      result = URI_ERRNO_TRAILING_DOTS;
      if ( s[(unsigned __int16)((_WORD)v35 - (_WORD)s) - 1] == 46 )
        return result;
    }
  }
  v36 = *v35;
  if ( *v35 != 58 )
    goto LABEL_89;
  v46 = v35[1];
  if ( !v46 || (v47 = 0, v46 == 47) )
  {
    result = URI_ERRNO_NO_PORT_COLON;
    v2->port = v35 + 1;
    *((_BYTE *)v2 + 48) = 0;
    return result;
  }
  do
  {
    v48 = v35[++v47 + 1];
    if ( !v48 )
    {
      v49 = (unsigned int)&v35[v47 + 1];
      v50 = v35 + 1;
      v51 = v47;
      goto LABEL_120;
    }
  }
  while ( v48 != 47 );
  v49 = (unsigned int)&v35[v47 + 1];
  v50 = v35 + 1;
  v51 = v47;
LABEL_120:
  *((_BYTE *)v2 + 48) = v51;
  result = URI_ERRNO_NO_PORT_COLON;
  v2->port = v50;
  if ( v51 )
  {
    if ( v51 == v49 - (_DWORD)v50 )
    {
      v35 = v50;
      if ( v49 > (unsigned int)v50 )
      {
        if ( (unsigned __int8)(*v50 - 48) > 9u )
          return 10;
        while ( (unsigned int)++v35 < v49 )
        {
          if ( (unsigned __int8)(*v35 - 48) > 9u )
            return 10;
        }
      }
      if ( !v50
        || (v68 = __errno_location(), *v68 = 0, v69 = v68, (unsigned int)strtol((const char *)v2->port, 0, 10) <= 0xFFFF)
        && !*v69 )
      {
        v36 = *v35;
LABEL_89:
        if ( v36 == 47 )
        {
          ++v35;
        }
        else if ( get_protocol_need_slash_after_host((protocol)v2->protocol) )
        {
          return *((_WORD *)v2 + 23) == 0 ? 6 : 8;
        }
        v37 = *v35;
        if ( !*v35 || v37 == 35 || v37 == 1 )
        {
          v38 = 0;
        }
        else
        {
          v38 = 0;
          do
            v39 = v35[++v38];
          while ( v39 && v39 != 35 && v39 != 1 );
        }
        v40 = *((_DWORD *)v2 + 12);
        v41 = &v35[v38];
        v2->data = v35;
        *((_DWORD *)v2 + 12) = ((unsigned __int16)v38 << 8) | v40 & 0xFF0000FF;
        v42 = v35[v38];
        if ( v42 == 35 )
        {
          v62 = v41 + 1;
          v2->fragment = v41 + 1;
          v63 = v41[1];
          if ( !v63 || v63 == 1 )
          {
            v67 = 0;
            LOWORD(v64) = 0;
          }
          else
          {
            v64 = 0;
            v65 = v41;
            do
              v66 = v65[++v64 + 1];
            while ( v66 && v66 != 1 );
            v67 = (unsigned __int16)v64;
          }
          v41 = &v62[v67];
          *((_WORD *)v2 + 26) = v64;
          v42 = *v41;
        }
        result = URI_ERRNO_OK;
        if ( v42 == 1 )
          v2->post = v41 + 1;
        return result;
      }
    }
    return 10;
  }
  return result;
}

//----- (080C3D30) --------------------------------------------------------
int __cdecl is_ip_address(const unsigned __int8 *address, int addresslen)
{
  int result; // eax
  int v3; // edx
  in_addr addr4; // [esp+1Ch] [ebp-5Ch] BYREF
  unsigned __int8 buffer[46]; // [esp+22h] [ebp-56h] BYREF
  sockaddr_in6 addr6; // [esp+50h] [ebp-28h] BYREF
  unsigned int v7; // [esp+6Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  result = 0;
  if ( (unsigned int)addresslen <= 0x2D )
  {
    safe_strncpy(buffer, address, addresslen + 1);
    v3 = inet_pton(10, (const char *)buffer, &addr6.sin6_addr);
    result = 1;
    if ( v3 <= 0 )
      return inet_pton(2, (const char *)buffer, &addr4) > 0;
  }
  return result;
}

//----- (080C3DC0) --------------------------------------------------------
unsigned __int8 *__cdecl normalize_uri(uri *uri, unsigned __int8 *uristring)
{
  uri *p_uri_struct; // ebx
  unsigned __int8 *v3; // edx
  unsigned __int8 *data; // edi
  unsigned __int8 *v5; // esi
  int v6; // edi
  int v7; // ebx
  unsigned __int16 v8; // ax
  protocol protocol; // eax
  protocol v11; // eax
  int v12; // esi
  unsigned __int8 *v13; // esi
  char v14; // cl
  unsigned __int8 v15; // al
  size_t v16; // eax
  unsigned __int8 *v17; // edx
  unsigned __int8 v18; // dl
  int v19; // eax
  unsigned __int8 *v20; // esi
  int v21; // edi
  int v22; // ebx
  unsigned __int8 v23; // si
  unsigned __int8 *v24; // ecx
  unsigned __int8 *v25; // [esp+1Ch] [ebp-7Ch]
  int keep_dslash; // [esp+28h] [ebp-70h]
  unsigned __int8 *path; // [esp+2Ch] [ebp-6Ch]
  unsigned __int8 v28; // [esp+37h] [ebp-61h]
  uri *v29; // [esp+3Ch] [ebp-5Ch]
  unsigned __int8 *v30; // [esp+3Ch] [ebp-5Ch]
  uri *v31; // [esp+3Ch] [ebp-5Ch]
  uri uri_struct; // [esp+44h] [ebp-54h] BYREF

  p_uri_struct = &uri_struct;
  v3 = uristring;
  if ( uri )
    p_uri_struct = uri;
  if ( !uri )
    goto LABEL_15;
  while ( 1 )
  {
    if ( !assert_failed )
    {
      data = p_uri_struct->data;
      assert_failed = data == 0;
      if ( !data )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 708;
        elinks_internal("assertion uri->data failed!");
      }
    }
    if ( *((_WORD *)p_uri_struct + 20) )
    {
      v29 = p_uri_struct;
      v5 = &p_uri_struct->string[*((unsigned __int16 *)p_uri_struct + 20) - 1];
      v6 = 0;
      v7 = *((unsigned __int16 *)p_uri_struct + 20) - 1;
      do
      {
        while ( !c_isupper(*v5) )
        {
          --v6;
          --v5;
          if ( v7 + v6 == -1 )
            goto LABEL_12;
        }
        --v6;
        *v5 = c_tolower(*v5);
        --v5;
      }
      while ( v7 + v6 != -1 );
LABEL_12:
      p_uri_struct = v29;
    }
    v8 = *((_WORD *)p_uri_struct + 23);
    if ( v8 )
    {
      v19 = v8 - 1;
      if ( v19 >= 0 )
      {
        v31 = p_uri_struct;
        v20 = &p_uri_struct->host[v19];
        v21 = 0;
        v22 = v19;
        do
        {
          while ( !c_isupper(*v20) )
          {
            --v21;
            --v20;
            if ( v21 + v22 < 0 )
              goto LABEL_41;
          }
          --v21;
          *v20 = c_tolower(*v20);
          --v20;
        }
        while ( v21 + v22 >= 0 );
LABEL_41:
        p_uri_struct = v31;
      }
    }
    protocol = p_uri_struct->protocol;
    v3 = p_uri_struct->data;
    if ( protocol != PROTOCOL_PROXY )
      break;
LABEL_15:
    if ( parse_uri(p_uri_struct, v3) )
      return uristring;
  }
  if ( !get_protocol_free_syntax(protocol) )
  {
    v11 = p_uri_struct->protocol;
    v12 = 0;
    keep_dslash = 1;
    if ( v11 != PROTOCOL_UNKNOWN )
    {
      v12 = -get_protocol_need_slash_after_host(v11);
      keep_dslash = get_protocol_keep_double_slashes((protocol)p_uri_struct->protocol);
    }
    v13 = &p_uri_struct->data[v12];
    path = v13;
    v14 = *v13;
    v30 = v13;
    while ( 1 )
    {
      if ( !v14 )
        return uristring;
      v15 = *v13;
      if ( *v13 == 35 || v15 == 1 || v15 == 63 )
      {
        v16 = strlen((const char *)v13);
        memmove(v30, v13, v16 + 1);
        return uristring;
      }
      if ( v15 != 47 )
        break;
      v25 = v13 + 1;
      v18 = v13[1];
      if ( v18 == 46 )
      {
        v17 = v13 + 2;
        v28 = v13[2];
        if ( !v28 )
          goto LABEL_53;
        if ( v28 != 47 )
        {
          if ( v28 == 46 )
          {
            v17 = v13 + 3;
            v23 = v13[3];
            if ( v23 == 47 || !v23 )
            {
              if ( v30 > path )
              {
                v24 = v30;
                do
                  --v24;
                while ( *v24 != 47 && path < v24 );
                v30 = v24;
              }
              if ( !v23 )
              {
LABEL_53:
                *v30 = 47;
                v30[1] = 0;
                return uristring;
              }
LABEL_30:
              v14 = *v30;
              goto LABEL_31;
            }
          }
LABEL_28:
          *v30 = v15;
          v14 = 0;
          v17 = v25;
          if ( !v15 )
            goto LABEL_31;
          ++v30;
          goto LABEL_30;
        }
LABEL_31:
        v13 = v17;
      }
      else
      {
        if ( v18 != 47 || keep_dslash )
          goto LABEL_28;
        ++v13;
      }
    }
    v25 = v13 + 1;
    goto LABEL_28;
  }
  return uristring;
}

//----- (080C40D0) --------------------------------------------------------
uri *__cdecl add_to_uri_list(uri_list *list, uri *uri)
{
  uri *v2; // esi
  unsigned int v3; // edx
  unsigned int v4; // edi
  uri **uris; // eax
  int size; // edx
  uri **v8; // eax
  int v9; // [esp+1Ch] [ebp-1Ch]

  v2 = uri;
  v3 = (list->size + 4) & 0xFFFFFFFC;
  v4 = (list->size + 3) & 0xFFFFFFFC;
  if ( v3 > v4 )
  {
    v9 = 4 * v3;
    v8 = (uri **)mem_realloc(list->uris, 4 * v3);
    if ( !v8 )
      return 0;
    list->uris = v8;
    memset(&v8[v4], 0, v9 - 4 * v4);
  }
  uris = list->uris;
  if ( !uris )
    return 0;
  size = list->size;
  ++uri->object.refcount;
  uris[size] = uri;
  list->size = size + 1;
  return v2;
}

//----- (080C4170) --------------------------------------------------------
void __cdecl encode_win32_uri_string(string *string, unsigned __int8 *name, int namelen)
{
  size_t v3; // eax
  unsigned __int8 *v4; // ebx
  unsigned __int8 v5; // al
  unsigned __int8 v6; // al
  int v7; // ecx
  char v8; // dl
  char v9; // al
  unsigned __int8 v10; // al
  unsigned __int8 v11; // dl
  int length; // edi
  size_t v13; // edx
  size_t v14; // ecx
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  size_t v17; // [esp+10h] [ebp-38h]
  size_t v18; // [esp+14h] [ebp-34h]
  unsigned __int8 *end; // [esp+1Ch] [ebp-2Ch]
  __int16 n; // [esp+2Ch] [ebp-1Ch]
  unsigned __int8 n_2; // [esp+2Eh] [ebp-1Ah]

  v3 = namelen;
  v4 = name;
  LOBYTE(n) = 37;
  if ( namelen < 0 )
    v3 = strlen((const char *)name);
  end = &name[v3];
  if ( name < &name[v3] )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = *v4;
        if ( (unsigned __int8)(*v4 - 97) > 0x19u
          && (unsigned __int8)(v5 - 65) > 0x19u
          && (unsigned __int8)(v5 - 48) > 9u
          && v5 != 95
          && v5 != 46
          && v5 != 45
          && v5 != 126
          && v5 != 33
          && v5 != 39
          && v5 != 42
          && v5 != 41
          && v5 != 40
          && v5 != 58
          && v5 != 92 )
        {
          break;
        }
        ++v4;
        add_char_to_string(string, v5);
        if ( end <= v4 )
          return;
      }
      v6 = v5 >> 4;
      v7 = v6;
      v8 = v6 + 87;
      v9 = v6 + 48;
      if ( v7 < 10 )
        v8 = v9;
      HIBYTE(n) = v8;
      v10 = *v4 & 0xF;
      v11 = v10 + 87;
      if ( v10 < 0xAu )
        v11 = v10 + 48;
      n_2 = v11;
      if ( assert_failed )
        break;
      if ( string )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( assert_failed )
          break;
      }
      length = string->length;
      v13 = length + 259;
      v14 = length + 255;
      LOBYTE(v13) = 0;
      LOBYTE(v14) = 0;
      if ( v13 > v14 )
      {
        v17 = v13;
        v18 = v14;
        v16 = (unsigned __int8 *)mem_realloc(string->source, v13);
        if ( !v16 )
          goto LABEL_24;
        string->source = v16;
        memset(&v16[v18], 0, v17 - v18);
      }
      if ( string->source )
      {
        ++v4;
        v15 = &string->source[string->length];
        *(_WORD *)v15 = n;
        v15[2] = n_2;
        string->source[length + 3] = 0;
        string->length = length + 3;
        if ( end <= v4 )
          return;
      }
      else
      {
LABEL_24:
        if ( end <= ++v4 )
          return;
      }
    }
    assert_failed = 0;
    goto LABEL_24;
  }
}

//----- (080C4380) --------------------------------------------------------
void __cdecl encode_uri_string(string *string, const unsigned __int8 *name, int namelen, int convert_slashes)
{
  size_t v4; // eax
  const unsigned __int8 *v5; // ebx
  unsigned __int8 v6; // dl
  unsigned __int8 v7; // dl
  int v8; // ecx
  char v9; // al
  char v10; // dl
  unsigned __int8 v11; // al
  unsigned __int8 v12; // dl
  int length; // edi
  size_t v14; // edx
  size_t v15; // ecx
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  size_t v18; // [esp+10h] [ebp-38h]
  size_t v19; // [esp+14h] [ebp-34h]
  const unsigned __int8 *end; // [esp+1Ch] [ebp-2Ch]
  __int16 n; // [esp+2Ch] [ebp-1Ch]
  unsigned __int8 n_2; // [esp+2Eh] [ebp-1Ah]

  v4 = namelen;
  v5 = name;
  LOBYTE(n) = 37;
  if ( namelen < 0 )
    v4 = strlen((const char *)name);
  end = &name[v4];
  if ( name < &name[v4] )
  {
    while ( 1 )
    {
      v6 = *v5;
      if ( (unsigned __int8)(*v5 - 97) <= 0x19u
        || (unsigned __int8)(v6 - 65) <= 0x19u
        || (unsigned __int8)(v6 - 48) <= 9u
        || v6 == 95
        || v6 == 46
        || v6 == 45
        || v6 == 126
        || v6 == 33
        || v6 == 39
        || v6 == 42
        || v6 == 41
        || v6 == 40
        || !convert_slashes && v6 == 47 )
      {
        add_char_to_string(string, v6);
        goto LABEL_23;
      }
      v7 = v6 >> 4;
      v8 = v7;
      v9 = v7 + 87;
      v10 = v7 + 48;
      if ( v8 < 10 )
        v9 = v10;
      HIBYTE(n) = v9;
      v11 = *v5 & 0xF;
      v12 = v11 + 87;
      if ( v11 < 0xAu )
        v12 = v11 + 48;
      n_2 = v12;
      if ( assert_failed )
        break;
      if ( string )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( assert_failed )
          break;
      }
      length = string->length;
      v14 = length + 259;
      v15 = length + 255;
      LOBYTE(v14) = 0;
      LOBYTE(v15) = 0;
      if ( v14 <= v15 )
        goto LABEL_30;
      v18 = v14;
      v19 = v15;
      v17 = (unsigned __int8 *)mem_realloc(string->source, v14);
      if ( v17 )
      {
        string->source = v17;
        memset(&v17[v19], 0, v18 - v19);
LABEL_30:
        if ( string->source )
        {
          v16 = &string->source[string->length];
          *(_WORD *)v16 = n;
          v16[2] = n_2;
          string->source[length + 3] = 0;
          string->length = length + 3;
        }
      }
LABEL_23:
      if ( end <= ++v5 )
        return;
    }
    assert_failed = 0;
    goto LABEL_23;
  }
}

//----- (080C4590) --------------------------------------------------------
unsigned __int8 *__usercall translate_url@<eax>(unsigned __int8 *url@<eax>, unsigned __int8 *cwd@<edx>)
{
  unsigned __int8 *v3; // ebx
  unsigned __int8 v4; // al
  unsigned __int8 *v6; // eax
  int v7; // ebx
  int v8; // esi
  uri_errno v9; // eax
  unsigned __int8 *v10; // ebx
  unsigned __int8 *port; // ebx
  unsigned __int8 *v12; // edi
  size_t v13; // eax
  int v14; // ecx
  unsigned __int8 *host; // edx
  unsigned __int8 *v16; // edi
  unsigned __int8 *j; // ebx
  size_t v18; // eax
  int v19; // eax
  unsigned __int8 *v20; // ecx
  int v21; // edx
  char *v22; // edi
  const char *i; // ebx
  size_t v24; // eax
  protocol v25; // ebx
  unsigned __int8 *v26; // ebx
  int v27; // edi
  int protocol; // eax
  protocol uri_protocol; // ebx
  const unsigned __int8 *v30; // eax
  const char *v31; // ebx
  unsigned __int8 *v32; // edi
  unsigned __int8 *v33; // eax
  unsigned __int8 *string; // edx
  unsigned __int8 *v35; // ebx
  unsigned __int8 *data; // eax
  unsigned __int8 *v37; // ebx
  unsigned __int8 v38; // al
  unsigned __int8 *v39; // [esp+0h] [ebp-88h]
  int v40; // [esp+4h] [ebp-84h]
  unsigned __int8 *v41; // [esp+4h] [ebp-84h]
  const char *v42; // [esp+4h] [ebp-84h]
  unsigned __int8 *name; // [esp+18h] [ebp-70h]
  unsigned __int8 *v44; // [esp+1Ch] [ebp-6Ch]
  uri uri; // [esp+28h] [ebp-60h] BYREF
  string str; // [esp+64h] [ebp-24h] BYREF
  unsigned __int8 *newurl[7]; // [esp+6Ch] [ebp-1Ch] BYREF

  v3 = url;
  v4 = *url;
  if ( v4 == 32 )
  {
    do
      v4 = *++v3;
    while ( *v3 == 32 );
  }
  if ( !v4 )
    return 0;
  v6 = expand_tilde(v3);
  newurl[0] = v6;
  if ( !v6 )
    return 0;
  v44 = v3;
  v7 = 1;
  v8 = 0;
  name = cwd;
  while ( 2 )
  {
    v9 = parse_uri(&uri, v6);
    if ( v7 == v9 )
    {
      v31 = (const char *)v44;
      if ( v8 <= 32 )
        goto LABEL_10;
      goto LABEL_69;
    }
    if ( ++v8 == 34 )
    {
      v31 = (const char *)v44;
LABEL_69:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 1097;
      elinks_error("Maximum number of parsing attempts exceeded for %s.", v31);
      goto LABEL_10;
    }
    switch ( v9 )
    {
      case URI_ERRNO_OK:
        protocol = uri.protocol;
        if ( uri.protocol != 18 )
        {
          v32 = name;
          goto LABEL_82;
        }
        uri_protocol = find_uri_protocol(newurl[0]);
        if ( uri_protocol != PROTOCOL_UNKNOWN )
        {
          if ( !init_string(&str) )
            return 0;
          if ( uri_protocol == PROTOCOL_HTTP )
          {
            add_to_string(&str, "http://");
            add_to_string(&str, newurl[0]);
          }
          else if ( uri_protocol == PROTOCOL_FTP )
          {
            add_to_string(&str, "ftp://");
            encode_uri_string(&str, newurl[0], -1, 0);
          }
          else
          {
            add_to_string(&str, "file://");
            v30 = newurl[0];
            if ( *newurl[0] != 47 )
            {
              add_to_string(&str, "./");
              v30 = newurl[0];
            }
            add_to_string(&str, v30);
          }
          v7 = 1;
          mem_free(newurl[0]);
          newurl[0] = str.source;
LABEL_18:
          v6 = newurl[0];
          continue;
        }
        v32 = name;
        protocol = uri.protocol;
LABEL_82:
        if ( protocol != 4 )
        {
LABEL_87:
          if ( protocol != 15 )
            return normalize_uri(&uri, uri.string);
          v33 = translate_url(uri.data, v32);
          string = uri.string;
          v35 = v33;
          data = uri.data;
          if ( v35 )
          {
            *uri.data = 0;
            insert_in_string(&uri.string, data - string, v35, strlen((const char *)v35));
            mem_free(v35);
            return normalize_uri(0, uri.string);
          }
LABEL_10:
          mem_free(newurl[0]);
          return 0;
        }
        if ( !v32 || !*v32 )
          return normalize_uri(&uri, uri.string);
        v37 = uri.data;
        if ( !assert_failed )
        {
          if ( uri.data )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 814;
            elinks_internal("assertion uri->protocol == PROTOCOL_FILE && uri->data failed!");
          }
        }
        v38 = *v37;
        if ( *v37 && v38 != 46 )
        {
          do
          {
            if ( v38 == 47 )
              break;
            v38 = *++v37;
          }
          while ( *v37 );
          memmove(uri.data, v37, strlen((const char *)v37) + 1);
          return normalize_uri(0, uri.string);
        }
        if ( !init_string(&str) )
        {
          protocol = uri.protocol;
          goto LABEL_87;
        }
        encode_uri_string(&str, v32, -1, 0);
        if ( *v37 == 46 )
          *v37 = 47;
        insert_in_string(&uri.string, 7, str.source, str.length);
        done_string(&str);
        return normalize_uri(0, uri.string);
      case URI_ERRNO_INVALID_PROTOCOL:
        v25 = find_uri_protocol(newurl[0]);
        if ( !init_string(&str) )
          return 0;
        if ( v25 == PROTOCOL_FTP )
        {
          add_to_string(&str, "ftp://");
          encode_uri_string(&str, newurl[0], -1, 0);
        }
        else if ( v25 == PROTOCOL_HTTP )
        {
          add_to_string(&str, "http://");
          add_to_string(&str, newurl[0]);
        }
        else
        {
          add_to_string(&str, "file://");
          v26 = newurl[0];
          if ( *newurl[0] != 47 )
          {
            add_to_string(&str, "./");
            v26 = newurl[0];
          }
          v27 = check_whether_file_exists(v26);
          encode_uri_string(&str, v26, v27, 0);
          if ( v27 > 0 )
            add_to_string(&str, &v26[v27]);
        }
        v7 = 2;
        mem_free(newurl[0]);
        newurl[0] = str.source;
        goto LABEL_18;
      case URI_ERRNO_NO_SLASHES:
        v7 = 3;
        insert_in_string(
          newurl,
          *((unsigned __int16 *)&uri + 20) + 1,
          "//",
          (uri.string[*((unsigned __int16 *)&uri + 20) + 1] != 47) + 1);
        goto LABEL_18;
      case URI_ERRNO_TOO_MANY_SLASHES:
        v19 = assert_failed;
        if ( assert_failed )
        {
          v20 = uri.string;
          v21 = *((unsigned __int16 *)&uri + 20);
        }
        else
        {
          v20 = uri.string;
          v21 = *((unsigned __int16 *)&uri + 20);
          if ( uri.string[*((unsigned __int16 *)&uri + 20)] == 58
            && uri.string[*((unsigned __int16 *)&uri + 20) + 1] == 47
            && uri.string[*((unsigned __int16 *)&uri + 20) + 2] == 47 )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1177;
            elinks_internal("assertion uri.string[uri.protocollen] == ':' && uri.string[uri.protocollen + 1] == '/' && ur"
                            "i.string[uri.protocollen + 2] == '/' failed!");
            v20 = uri.string;
            v21 = *((unsigned __int16 *)&uri + 20);
            v19 = assert_failed;
          }
        }
        v22 = (char *)&v20[v21 + 3];
        for ( i = v22; *i == 47; ++i )
          ;
        if ( !v19 )
        {
          assert_failed = v22 >= i;
          if ( v22 >= i )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1182;
            elinks_internal("assertion to < from failed!");
          }
        }
        v24 = strlen(i);
        v42 = i;
        v7 = 4;
        memmove(v22, v42, v24 + 1);
        goto LABEL_18;
      case URI_ERRNO_TRAILING_DOTS:
        v14 = assert_failed;
        host = uri.host;
        v16 = &uri.host[*((unsigned __int16 *)&uri + 23)];
        if ( !assert_failed )
        {
          if ( uri.host >= v16 || *(v16 - 1) != 46 || *v16 == 46 )
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1204;
            elinks_internal("assertion uri.host < to && to[-1] == '.' && *from != '.' failed!");
            host = uri.host;
            v14 = assert_failed;
          }
          else
          {
            assert_failed = 0;
          }
        }
        for ( j = v16; j > host && *(j - 1) == 46; --j )
          ;
        if ( !v14 )
        {
          assert_failed = j >= v16;
          if ( j >= v16 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1208;
            elinks_internal("assertion to < from failed!");
          }
        }
        v18 = strlen((const char *)v16);
        v39 = j;
        v7 = 5;
        memmove(v39, v16, v18 + 1);
        goto LABEL_18;
      case URI_ERRNO_NO_PORT_COLON:
        if ( assert_failed )
          goto LABEL_22;
        if ( *((_BYTE *)&uri + 48)
          || (port = uri.port, uri.string >= uri.port)
          || (v12 = uri.port - 1, *(uri.port - 1) != 58) )
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
          errline = 1215;
          elinks_internal("assertion uri.portlen == 0 && uri.string < uri.port && uri.port[-1] == ':' failed!");
LABEL_22:
          port = uri.port;
          v12 = uri.port - 1;
        }
        else
        {
          assert_failed = 0;
        }
        v13 = strlen((const char *)port);
        v41 = port;
        v7 = 7;
        memmove(v12, v41, v13 + 1);
        goto LABEL_18;
      case URI_ERRNO_NO_HOST_SLASH:
        if ( uri.port )
          v10 = (unsigned __int8 *)(&uri.port[*((unsigned __int8 *)&uri + 48)] - uri.string);
        else
          v10 = &uri.host[*((unsigned __int16 *)&uri + 23) + (*((_BYTE *)&uri + 54) & 1) - (unsigned int)uri.string];
        if ( !assert_failed )
        {
          assert_failed = uri.host == 0;
          if ( !uri.host )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
            errline = 1226;
            elinks_internal("assertion uri.host != NULL failed: uri.host not set after no host slash error");
          }
        }
        v40 = (int)v10;
        v7 = 8;
        insert_in_string(newurl, v40, "/", 1);
        goto LABEL_18;
      default:
        goto LABEL_10;
    }
  }
}
// 80C4930: conditional instruction was optimized away because ebx.4 is in (<9u|A..11|>=13u)

//----- (080C4D80) --------------------------------------------------------
unsigned __int8 *__cdecl join_urls(uri *base, unsigned __int8 *rel)
{
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // cl
  const unsigned __int16 **v4; // eax
  unsigned __int8 v5; // cl
  const unsigned __int16 *v6; // esi
  unsigned __int8 *v7; // eax
  int v8; // eax
  unsigned __int8 *data; // ecx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // esi
  _BOOL4 v12; // edi
  _BOOL4 v13; // edx
  unsigned __int8 v14; // al
  unsigned __int8 *v15; // ecx
  bool v16; // zf
  size_t v17; // eax
  size_t v18; // esi
  unsigned __int8 *v19; // eax
  unsigned __int8 *result; // eax
  protocol protocol; // eax
  unsigned __int8 *fragment; // esi
  int v23; // esi
  unsigned __int8 *post; // esi
  unsigned __int8 *v25; // eax
  int v26; // edi
  unsigned __int8 *v27; // eax
  unsigned __int8 v28; // [esp+18h] [ebp-30h]
  _BOOL4 v29; // [esp+18h] [ebp-30h]
  unsigned __int8 *v30; // [esp+18h] [ebp-30h]
  unsigned __int8 *uristring; // [esp+2Ch] [ebp-1Ch] BYREF

  v2 = *rel;
  v3 = *rel;
  if ( *rel == 35 )
  {
    fragment = base->fragment;
    if ( fragment || (fragment = base->post) != 0 )
      v23 = fragment - 1 - base->string;
    else
      v23 = strlen((const char *)base->string);
    goto LABEL_50;
  }
  if ( v2 == 63 )
  {
    post = base->fragment;
    if ( post || (post = base->post) != 0 )
      v23 = post - 1 - base->string;
    else
      v23 = strlen((const char *)base->string);
    v25 = (unsigned __int8 *)memchr(base->data, 63, *(unsigned __int16 *)((char *)base + 49));
    v2 = 63;
    uristring = v25;
    if ( v25 )
    {
      v23 = v25 - base->string;
      if ( v25 != base->string )
        goto LABEL_56;
      goto LABEL_51;
    }
LABEL_50:
    if ( v23 )
    {
LABEL_56:
      v26 = 0;
      goto LABEL_57;
    }
LABEL_51:
    v3 = v2;
    goto LABEL_4;
  }
  if ( v2 == 47 && rel[1] == 47 )
  {
    if ( !get_protocol_need_slashes((protocol)base->protocol) )
      return 0;
    v26 = 1;
    v23 = *((unsigned __int16 *)base + 20) + 1;
LABEL_57:
    v27 = memacpy(base->string, v23);
    if ( v27 )
    {
      uristring = v27;
      add_to_strn(&uristring, rel);
      if ( v26 )
      {
        v30 = translate_url(uristring, 0);
        mem_free(uristring);
        return v30;
      }
      return normalize_uri(0, uristring);
    }
    return 0;
  }
LABEL_4:
  v28 = v3;
  v4 = __ctype_b_loc();
  v5 = v28;
  v6 = *v4;
  v7 = rel;
  while ( (v6[v5] & 8) != 0 || v5 == 43 || v5 == 45 || v5 == 46 )
    v5 = *++v7;
  if ( rel == v7 || (unsigned __int8)(*(v7 - 1) - 48) > 9u )
  {
    if ( (unsigned __int8)(v5 - 48) > 0xAu )
    {
      if ( !assert_failed )
        goto LABEL_15;
      goto LABEL_40;
    }
  }
  else
  {
    --v7;
  }
  v8 = v7 - rel;
  if ( !v8
    || (protocol = get_protocol(rel, v8), protocol == PROTOCOL_PROXY)
    || protocol == PROTOCOL_UNKNOWN
    || (result = translate_url(rel, 0), (uristring = result) == 0) )
  {
    if ( !assert_failed )
    {
LABEL_15:
      data = base->data;
      assert_failed = data == 0;
      if ( !data )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 948;
        elinks_internal("assertion base->data != NULL failed: bad base url");
        if ( assert_failed )
          goto LABEL_40;
      }
      v10 = base->data;
      if ( *v10 )
      {
        v11 = v10 - 1;
        if ( *v10 != 47 )
        {
LABEL_18:
          v12 = 0;
          v13 = 0;
          if ( *rel != 47 )
          {
            v14 = *v11;
            v13 = *v11 == 0;
            v12 = v13;
            if ( *v11 )
            {
              if ( v14 != 1 && v14 != 35 )
              {
                v12 = v14 == 0;
                if ( v14 == 63 )
                  goto LABEL_31;
                v15 = v11 + 1;
                do
                {
                  v16 = v14 != 47;
                  v14 = *v15;
                  if ( !v16 )
                    v11 = v15;
                  if ( !v14 )
                    break;
                  if ( v14 == 35 )
                    break;
                  if ( v14 == 1 )
                    break;
                  ++v15;
                }
                while ( v14 != 63 );
              }
              v12 = v13;
            }
          }
LABEL_31:
          v29 = v13;
          v17 = strlen((const char *)rel);
          v18 = v11 - base->string;
          v19 = (unsigned __int8 *)mem_alloc(v18 + v12 + v17 + 1);
          if ( v19 )
          {
            uristring = v19;
            memcpy(v19, base->string, v18);
            if ( v29 )
              uristring[v18] = 47;
            strcpy((char *)&uristring[v12 + v18], (const char *)rel);
            return normalize_uri(0, uristring);
          }
          return 0;
        }
      }
      else
      {
        v11 = v10 - 1;
        if ( *(v10 - 1) == 47 )
          goto LABEL_18;
      }
      v11 = base->data;
      goto LABEL_18;
    }
LABEL_40:
    assert_failed = 0;
    return 0;
  }
  return result;
}

//----- (080C5130) --------------------------------------------------------
string *__cdecl add_uri_to_string(string *string, const uri *uri, uri_component components)
{
  unsigned __int16 v3; // di
  unsigned __int16 v4; // di
  unsigned __int16 v5; // ax
  int protocol_port; // edi
  unsigned __int8 *data; // edi
  unsigned __int8 v8; // al
  signed int v9; // ebx
  char *v11; // eax
  char v12; // dl
  const void *v13; // esi
  size_t v14; // ebx
  char v15; // dl
  int v16; // edi
  unsigned __int16 v17; // di
  unsigned __int8 *v18; // edi
  int v19; // edx
  int v20; // esi
  unsigned __int8 *v21; // edx
  unsigned __int8 *v22; // ecx
  size_t v23; // edi
  unsigned __int16 v24; // di
  int v25; // edx
  int v26; // edi
  int v27; // edx
  int v28; // edx
  int v29; // edx
  int v30; // edi
  int v31; // edx
  int v32; // edi
  int length; // edx
  char *v34; // [esp+14h] [ebp-34h]
  unsigned __int8 *src; // [esp+18h] [ebp-30h]
  unsigned __int8 *srca; // [esp+18h] [ebp-30h]
  int srcb; // [esp+18h] [ebp-30h]
  int srcc; // [esp+18h] [ebp-30h]
  int srcd; // [esp+18h] [ebp-30h]
  unsigned __int8 *n; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *na; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *nb; // [esp+1Ch] [ebp-2Ch]
  size_t nc; // [esp+1Ch] [ebp-2Ch]
  size_t nd; // [esp+1Ch] [ebp-2Ch]
  char *idname; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( uri->protocol == 18 )
    return add_to_string(string, uri->string);
  if ( (components & 1) != 0 )
  {
    v17 = *((_WORD *)uri + 20);
    n = uri->string;
    if ( !assert_failed )
    {
      if ( string && uri->string )
      {
        assert_failed = 0;
        goto LABEL_74;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( !assert_failed )
      {
LABEL_74:
        if ( v17 )
        {
          length = string->length;
          srcd = v17 + length;
          if ( mem_align_alloc___0((void **)&string->source, length, srcd + 1, 1u, 0xFFu) )
          {
            memcpy(&string->source[string->length], n, v17);
            string->source[srcd] = 0;
            string->length = srcd;
          }
        }
        goto LABEL_75;
      }
    }
    assert_failed = 0;
LABEL_75:
    if ( (components & 2) != 0 && uri->ip_family )
      add_long_to_string(string, uri->ip_family);
    add_char_to_string(string, 0x3Au);
    if ( get_protocol_need_slashes((protocol)uri->protocol) )
      add_to_string(string, "//");
  }
  if ( (components & 4) == 0 || (v3 = *((_WORD *)uri + 21)) == 0 )
  {
    if ( (components & 8) == 0 )
      goto LABEL_7;
    v4 = *((_WORD *)uri + 22);
    if ( !v4 )
      goto LABEL_7;
    srca = uri->password;
    if ( assert_failed )
    {
LABEL_88:
      assert_failed = 0;
      goto LABEL_7;
    }
    if ( string && uri->password )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
        goto LABEL_88;
    }
    nd = v4;
    v29 = string->length;
    v30 = v29 + v4;
    if ( mem_align_alloc___0((void **)&string->source, v29, v30 + 1, 1u, 0xFFu) )
    {
      memcpy(&string->source[string->length], srca, nd);
      string->source[v30] = 0;
      string->length = v30;
    }
LABEL_7:
    if ( (components & 0x10) == 0 )
      goto LABEL_17;
LABEL_8:
    v5 = *((_WORD *)uri + 23);
    if ( !v5 )
      goto LABEL_17;
    if ( (*((_BYTE *)uri + 54) & 1) != 0 && (components & 0x20) != 0 )
    {
      add_char_to_string(string, 0x5Bu);
      v5 = *((_WORD *)uri + 23);
    }
    if ( (components & 0x800) != 0 )
    {
      v18 = memacpy(uri->host, v5);
      if ( v18 )
      {
        if ( !idna_to_ascii_lz(v18, &idname, 0) )
        {
          add_to_string(string, (const unsigned __int8 *)idname);
          free(idname);
          mem_free(v18);
          goto LABEL_14;
        }
        mem_free(v18);
      }
      v5 = *((_WORD *)uri + 23);
    }
    add_bytes_to_string___2(string, uri->host, v5);
LABEL_14:
    if ( (*((_BYTE *)uri + 54) & 1) != 0 && (components & 0x20) != 0 )
      add_char_to_string(string, 0x5Du);
    goto LABEL_17;
  }
  src = uri->user;
  if ( assert_failed )
    goto LABEL_81;
  if ( string && uri->user )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( assert_failed )
    {
LABEL_81:
      assert_failed = 0;
      goto LABEL_82;
    }
  }
  nc = v3;
  v25 = string->length;
  v26 = v25 + v3;
  if ( mem_align_alloc___0((void **)&string->source, v25, v26 + 1, 1u, 0xFFu) )
  {
    memcpy(&string->source[string->length], src, nc);
    string->source[v26] = 0;
    string->length = v26;
  }
LABEL_82:
  if ( (components & 8) != 0 && *((_WORD *)uri + 22) )
  {
    add_char_to_string(string, 0x3Au);
    add_bytes_to_string___2(string, uri->password, *((unsigned __int16 *)uri + 22));
  }
  add_char_to_string(string, 0x40u);
  if ( (components & 0x10) != 0 )
    goto LABEL_8;
LABEL_17:
  if ( (components & 0x60) == 0 )
    goto LABEL_22;
  if ( !*((_BYTE *)uri + 48) )
  {
    if ( (components & 0x40) != 0 && uri->protocol != 19 )
    {
      protocol_port = get_protocol_port((protocol)uri->protocol);
      add_char_to_string(string, 0x3Au);
      add_long_to_string(string, protocol_port);
    }
    goto LABEL_22;
  }
  add_char_to_string(string, 0x3Au);
  LOBYTE(v23) = *((_BYTE *)uri + 48);
  na = uri->port;
  if ( assert_failed )
  {
LABEL_114:
    assert_failed = 0;
    goto LABEL_22;
  }
  if ( string && uri->port )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( assert_failed )
      goto LABEL_114;
  }
  v23 = (unsigned __int8)v23;
  if ( (_BYTE)v23 )
  {
    v27 = string->length;
    srcb = v23 + v27;
    if ( mem_align_alloc___0((void **)&string->source, v27, v23 + v27 + 1, 1u, 0xFFu) )
    {
      memcpy(&string->source[string->length], na, v23);
      string->source[srcb] = 0;
      string->length = srcb;
    }
  }
LABEL_22:
  if ( ((components & 0x280) != 0 || components == URI_HTTP_REFERRER_HOST)
    && (components & 0xFFFFFF5F) != 0
    && get_protocol_need_slash_after_host((protocol)uri->protocol) )
  {
    add_char_to_string(string, 0x2Fu);
  }
  if ( (components & 0x80u) != 0 && (*((_DWORD *)uri + 12) & 0xFFFF00) != 0 )
  {
    v24 = *(_WORD *)((char *)uri + 49);
    nb = uri->data;
    if ( assert_failed )
    {
LABEL_116:
      assert_failed = 0;
      goto LABEL_27;
    }
    if ( string && uri->data )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
        goto LABEL_116;
    }
    if ( v24 )
    {
      v28 = string->length;
      srcc = v24 + v28;
      if ( mem_align_alloc___0((void **)&string->source, v28, srcc + 1, 1u, 0xFFu) )
      {
        memcpy(&string->source[string->length], nb, v24);
        string->source[srcc] = 0;
        string->length = srcc;
      }
    }
  }
LABEL_27:
  if ( (components & 0x3000) != 0 )
  {
    data = uri->data;
    if ( !assert_failed )
    {
      assert_failed = (components != URI_FILENAME) & ((unsigned int)components >> 13);
      if ( assert_failed )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 602;
        elinks_internal(
          "assertion !wants(URI_FILENAME) || components == URI_FILENAME failed: URI_FILENAME should be used alone %d",
          components);
      }
    }
    if ( (components & 0x1000) != 0 && *data != 47 )
      add_char_to_string(string, 0x2Fu);
    if ( (*((_DWORD *)uri + 12) & 0xFFFF00) == 0 )
      return string;
    v8 = *data;
    if ( !*data || v8 == 35 || v8 == 1 || v8 == 63 )
    {
      v9 = 0;
    }
    else
    {
      v21 = data + 1;
      do
      {
        v22 = v21;
        if ( (components & 0x2000) != 0 )
        {
          v22 = v21;
          if ( v8 == 47 )
            data = v21;
        }
        v8 = *v21;
        if ( !*v21 || v8 == 35 || v8 == 1 )
        {
          v9 = v21 - data;
          goto LABEL_39;
        }
        ++v21;
      }
      while ( v8 != 63 );
      v9 = v22 - data;
    }
LABEL_39:
    if ( assert_failed )
      goto LABEL_40;
    if ( data && string && v9 >= 0 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
      {
LABEL_40:
        assert_failed = 0;
        return 0;
      }
    }
    if ( !v9 )
      return string;
    v19 = string->length;
    v20 = v9 + v19;
    if ( mem_align_alloc___0((void **)&string->source, v19, v9 + v19 + 1, 1u, 0xFFu) )
    {
      memcpy(&string->source[string->length], data, v9);
      string->source[v20] = 0;
      string->length = v20;
      return string;
    }
    return 0;
  }
  if ( (components & 0x4000) != 0 && (*((_DWORD *)uri + 12) & 0xFFFF00) != 0 )
  {
    v11 = (char *)memchr(uri->data, 63, *(unsigned __int16 *)((char *)uri + 49));
    if ( !assert_failed )
    {
      assert_failed = components != URI_QUERY;
      if ( components != URI_QUERY )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
        errline = 625;
        v34 = v11;
        elinks_internal("assertion URI_QUERY == components failed: URI_QUERY should be used alone %d", components);
        v11 = v34;
      }
    }
    if ( !v11 )
      return string;
    v12 = v11[1];
    v13 = v11 + 1;
    if ( !v12 || v12 == 35 || v12 == 1 )
    {
      v16 = 0;
      v14 = 0;
    }
    else
    {
      v14 = 0;
      do
        v15 = v11[++v14 + 1];
      while ( v15 && v15 != 35 && v15 != 1 );
      v16 = v14;
    }
    if ( assert_failed )
      goto LABEL_57;
    if ( string && v16 >= 0 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
      {
LABEL_57:
        assert_failed = 0;
        return 0;
      }
    }
    if ( !v16 )
      return string;
    v31 = string->length;
    v32 = v31 + v16;
    if ( mem_align_alloc___0((void **)&string->source, v31, v32 + 1, 1u, 0xFFu) )
    {
      memcpy(&string->source[string->length], v13, v14);
      string->source[v32] = 0;
      string->length = v32;
      return string;
    }
    return 0;
  }
  if ( (components & 0x100) != 0 && *((_WORD *)uri + 26) )
  {
    add_char_to_string(string, 0x23u);
    add_bytes_to_string___2(string, uri->fragment, *((unsigned __int16 *)uri + 26));
  }
  if ( (components & 0x200) == 0 || !uri->post )
  {
    if ( (components & 0x400) != 0 && uri->post )
    {
      if ( !memcmp(uri->post, "text/plain", 0xAu) )
      {
        add_to_string(string, " (PLAIN TEXT DATA)");
      }
      else if ( !memcmp(uri->post, "multipart/form-data;", 0x14u) )
      {
        add_to_string(string, " (MULTIPART FORM DATA)");
      }
      else
      {
        add_to_string(string, " (POST DATA)");
      }
    }
    return string;
  }
  add_char_to_string(string, 1u);
  add_to_string(string, uri->post);
  return string;
}
// 80590C8: using guessed type int __cdecl idna_to_ascii_lz(_DWORD, _DWORD, _DWORD);

//----- (080C5DA0) --------------------------------------------------------
unsigned __int8 *__cdecl get_uri_string(const uri *uri, uri_component components)
{
  string string; // [esp+18h] [ebp-10h] BYREF

  if ( init_string(&string) && add_uri_to_string(&string, uri, components) )
    return string.source;
  done_string(&string);
  return 0;
}

//----- (080C5DF0) --------------------------------------------------------
uri *__cdecl get_composed_uri(uri *uri, uri_component components)
{
  unsigned __int8 *uri_string; // ebx
  uri *result; // eax
  uri *v4; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = uri == 0, !uri)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c",
        errline = 1288,
        elinks_internal("assertion uri failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    uri_string = get_uri_string(uri, components);
    result = 0;
    if ( uri_string )
    {
      v4 = get_uri(uri_string, (uri_component)0);
      mem_free(uri_string);
      return v4;
    }
  }
  return result;
}

//----- (080C5E90) --------------------------------------------------------
uri *__cdecl get_uri(unsigned __int8 *string, uri_component components)
{
  signed int v2; // eax
  unsigned int v3; // edi
  hash_item *hash_item; // eax
  uri *value; // ebx
  char *v7; // eax
  unsigned __int8 *uristring; // [esp+1Ch] [ebp-5Ch]
  uri uri; // [esp+24h] [ebp-54h] BYREF

  if ( !assert_failed )
  {
    assert_failed = string == 0;
    if ( !string )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c";
      errline = 1574;
      elinks_internal("assertion string failed!");
    }
  }
  if ( components )
  {
    if ( parse_uri(&uri, string) == URI_ERRNO_OK )
      return get_composed_uri(&uri, components);
    return 0;
  }
  if ( uri_cache_0.object.refcount || (uri_cache_0.map = init_hash8()) != 0 )
  {
    v2 = strlen((const char *)string);
    v3 = v2;
    if ( assert_failed
      || (assert_failed = string == 0 || v2 <= 0) != 0
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/uri.c",
          errline = 1543,
          elinks_internal("assertion string && length > 0 failed!"),
          assert_failed) )
    {
      assert_failed = 0;
      goto LABEL_13;
    }
    hash_item = get_hash_item(uri_cache_0.map, string, v3);
    if ( hash_item )
    {
      value = (uri *)hash_item->value;
      if ( !value )
        goto LABEL_13;
LABEL_10:
      ++value->object.refcount;
      return value;
    }
    v7 = (char *)mem_calloc(1u, v3 + 64);
    value = (uri *)v7;
    if ( v7 )
    {
      uristring = (unsigned __int8 *)(v7 + 60);
      memcpy(v7 + 60, string, v3);
      if ( parse_uri(value, uristring) == URI_ERRNO_OK && add_hash_item(uri_cache_0.map, uristring, v3, value) )
      {
        ++uri_cache_0.object.refcount;
        goto LABEL_10;
      }
      mem_free(value);
    }
LABEL_13:
    if ( !uri_cache_0.object.refcount )
    {
      free_hash(&uri_cache_0.map);
      return 0;
    }
    return 0;
  }
  return 0;
}

//----- (080C6090) --------------------------------------------------------
uri *__cdecl get_translated_uri(unsigned __int8 *uristring, unsigned __int8 *cwd)
{
  uri *uri; // esi
  unsigned __int8 *v3; // eax
  unsigned __int8 *v4; // ebx

  uri = 0;
  v3 = translate_url(uristring, cwd);
  v4 = v3;
  if ( v3 )
  {
    uri = get_uri(v3, (uri_component)0);
    mem_free(v4);
  }
  return uri;
}

//----- (080C60E0) --------------------------------------------------------
string *__cdecl add_string_uri_to_string(string *string, unsigned __int8 *uristring, uri_component components)
{
  uri_errno v3; // edx
  string *result; // eax
  uri uri; // [esp+14h] [ebp-44h] BYREF

  v3 = parse_uri(&uri, uristring);
  result = 0;
  if ( v3 == URI_ERRNO_OK )
    return add_uri_to_string(string, &uri, components);
  return result;
}

//----- (080C6120) --------------------------------------------------------
unsigned __int8 *__cdecl get_user_program(terminal *term, unsigned __int8 *progid, int progidlen)
{
  __int32 v3; // esi
  unsigned __int8 *source; // eax
  unsigned __int8 *v5; // edi
  int v6; // esi
  unsigned __int8 *system_str; // eax
  option_elinks *opt_rec_real; // esi
  int v10; // ecx
  size_t v11; // edx
  unsigned __int8 *v12; // eax
  size_t v13; // [esp+10h] [ebp-38h]
  int v14; // [esp+14h] [ebp-34h]
  int v15; // [esp+14h] [ebp-34h]
  unsigned int v16; // [esp+18h] [ebp-30h]
  __int32 v17; // [esp+1Ch] [ebp-2Ch]
  string name; // [esp+28h] [ebp-20h] BYREF

  v3 = 0;
  if ( term )
    v3 = term->environment & 2;
  if ( !init_string(&name) )
    return 0;
  add_to_string(&name, "protocol.user.");
  if ( assert_failed )
    goto LABEL_5;
  if ( progid && progidlen >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( assert_failed )
    {
LABEL_5:
      source = name.source;
      assert_failed = 0;
      goto LABEL_6;
    }
  }
  if ( !progidlen )
    goto LABEL_16;
  v10 = progidlen + name.length;
  v11 = progidlen + name.length + 256;
  v16 = (name.length + 255) & 0xFFFFFF00;
  LOBYTE(v11) = 0;
  if ( v11 > v16 )
  {
    v13 = v11;
    v15 = progidlen + name.length;
    v12 = (unsigned __int8 *)mem_realloc(name.source, v11);
    if ( !v12 )
      goto LABEL_24;
    name.source = v12;
    memset(&v12[v16], 0, v13 - v16);
    v10 = v15;
  }
  source = name.source;
  if ( !name.source )
    goto LABEL_6;
  v14 = v10;
  memcpy(&name.source[name.length], progid, progidlen);
  name.source[v14] = 0;
  name.length = v14;
LABEL_24:
  source = name.source;
LABEL_6:
  if ( progidlen - 1 >= 0 )
  {
    v17 = v3;
    v5 = &source[progidlen];
    v6 = progidlen - 1;
    do
    {
      while ( !c_isupper(v5[13]) )
      {
        --v5;
        if ( --v6 < 0 )
          goto LABEL_11;
      }
      v5[13] = c_tolower(v5[13]);
      --v5;
      --v6;
    }
    while ( v6 >= 0 );
LABEL_11:
    v3 = v17;
  }
LABEL_16:
  add_char_to_string(&name, 0x2Eu);
  system_str = get_system_str(v3);
  add_to_string(&name, system_str);
  opt_rec_real = get_opt_rec_real(config_options, name.source);
  done_string(&name);
  if ( opt_rec_real )
    return opt_rec_real->value.string;
  return 0;
}

//----- (080C6320) --------------------------------------------------------
void __cdecl user_protocol_handler(session *ses, uri *uri)
{
  unsigned __int8 *user_program; // eax
  unsigned __int8 *v3; // ebx
  unsigned __int8 *tempdir_filename; // eax
  unsigned __int8 *post; // esi
  char *v6; // eax
  size_t v7; // edi
  unsigned __int8 *source; // esi
  int v9; // ecx
  size_t v10; // edi
  unsigned __int8 *v11; // esi
  unsigned __int8 v12; // al
  _BYTE *v13; // ebx
  int length; // edi
  size_t v15; // edx
  unsigned int v16; // ecx
  char v17; // al
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ebx
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // esi
  int v23; // eax
  int v24; // eax
  unsigned __int8 v25; // al
  unsigned __int16 v26; // ax
  unsigned __int8 *host; // eax
  int v28; // ecx
  unsigned int v29; // eax
  size_t v30; // edx
  unsigned __int8 *v31; // eax
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  FILE *v34; // eax
  unsigned __int8 *uri_string; // eax
  char *v36; // eax
  const unsigned __int8 *v37; // ecx
  int v38; // eax
  unsigned __int8 v39; // dl
  FILE *stream; // [esp+2Ch] [ebp-3Ch]
  FILE *streama; // [esp+2Ch] [ebp-3Ch]
  FILE *streamb; // [esp+2Ch] [ebp-3Ch]
  int v43; // [esp+30h] [ebp-38h]
  int v44; // [esp+30h] [ebp-38h]
  unsigned int v45; // [esp+30h] [ebp-38h]
  int v46; // [esp+30h] [ebp-38h]
  unsigned __int8 *subj; // [esp+34h] [ebp-34h]
  int fd; // [esp+38h] [ebp-30h]
  int fda; // [esp+38h] [ebp-30h]
  int fdb; // [esp+38h] [ebp-30h]
  unsigned __int8 *query; // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 *querya; // [esp+3Ch] [ebp-2Ch]
  string string; // [esp+48h] [ebp-20h] BYREF

  user_program = get_user_program(ses->tab->term, uri->string, *((unsigned __int16 *)uri + 20));
  v3 = user_program;
  if ( !user_program || !*user_program )
  {
    v18 = memacpy(uri->string, *((unsigned __int16 *)uri + 20));
    v19 = v18;
    if ( v18 )
    {
      v20 = msg_text(ses->tab->term, "No program specified for protocol %s.", (const char *)v18);
      info_box(ses->tab->term, MSGBOX_FREE_TEXT, (unsigned __int8 *)&byte_8132214, ALIGN_CENTER, v20);
      mem_free(v19);
    }
    else
    {
      v32 = msg_text(ses->tab->term, "No program specified for protocol %s.", &delete);
      info_box(ses->tab->term, MSGBOX_FREE_TEXT, (unsigned __int8 *)&byte_8132214, ALIGN_CENTER, v32);
    }
    return;
  }
  if ( !uri->data
    || (*((_DWORD *)uri + 12) & 0xFFFF00) == 0
    || (uri_string = get_uri_string(uri, URI_QUERY), (querya = uri_string) == 0) )
  {
    subj = 0;
    goto LABEL_6;
  }
  if ( !memcmp(uri_string, "subject=", 8u) )
  {
    v37 = uri_string + 8;
  }
  else
  {
    v36 = strstr((const char *)uri_string, "&subject=");
    v37 = (const unsigned __int8 *)(v36 + 9);
    if ( !v36 )
    {
      mem_free(querya);
      subj = 0;
      goto LABEL_6;
    }
  }
  if ( !*v37 || *v37 == 38 )
  {
    v38 = 0;
  }
  else
  {
    v38 = 0;
    do
      v39 = v37[++v38];
    while ( v39 && v39 != 38 );
  }
  subj = memacpy(v37, v38);
  mem_free(querya);
  if ( subj )
    decode_uri(subj);
LABEL_6:
  tempdir_filename = get_tempdir_filename("elinks-XXXXXX");
  query = tempdir_filename;
  if ( !tempdir_filename )
    goto LABEL_12;
  fd = safe_mkstemp(tempdir_filename);
  if ( fd < 0 )
  {
    mem_free(query);
    query = 0;
  }
  else
  {
    post = uri->post;
    if ( post )
    {
      v6 = strchr((const char *)uri->post, 10);
      if ( v6 )
        post = (unsigned __int8 *)(v6 + 1);
      v7 = strlen((const char *)post);
      if ( v7 )
      {
        v34 = fdopen(fd, "w");
        if ( v34 )
        {
          streamb = v34;
          if ( fwrite(post, v7, 1u, v34) == 1 )
          {
            if ( !fclose(streamb) )
              goto LABEL_12;
          }
          else
          {
            fclose(streamb);
          }
        }
        unlink((const char *)query);
        mem_free(query);
        close(fd);
        query = 0;
      }
    }
  }
LABEL_12:
  source = 0;
  if ( !init_string(&string) )
    goto LABEL_29;
  while ( *v3 )
  {
    v9 = 0;
    v10 = 0;
    v11 = v3;
    if ( *v3 != 37 )
    {
      do
      {
        v12 = v3[++v9];
        v10 = v9;
        v11 = &v3[v9];
      }
      while ( v12 != 37 && v12 );
    }
    if ( assert_failed )
    {
LABEL_19:
      assert_failed = 0;
      goto LABEL_20;
    }
    if ( v9 < 0 )
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      v44 = v9;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      v9 = v44;
      if ( assert_failed )
        goto LABEL_19;
    }
    else
    {
      assert_failed = 0;
    }
    if ( v9 )
    {
      v28 = string.length + v9;
      v29 = string.length + 255;
      v30 = v28 + 256;
      LOBYTE(v29) = 0;
      LOBYTE(v30) = 0;
      fdb = v29;
      if ( v30 <= v29 )
        goto LABEL_59;
      streama = (FILE *)v30;
      v46 = v28;
      v33 = (unsigned __int8 *)mem_realloc(string.source, v30);
      if ( v33 )
      {
        string.source = v33;
        memset(&v33[fdb], 0, (size_t)streama - fdb);
        v28 = v46;
LABEL_59:
        if ( string.source )
        {
          v43 = v28;
          memcpy(&string.source[string.length], v3, v10);
          string.source[v43] = 0;
          string.length = v43;
        }
      }
    }
LABEL_20:
    if ( *v11 != 37 )
      break;
    v13 = v11 + 1;
    switch ( v11[1] )
    {
      case 'd':
        if ( (*((_DWORD *)uri + 12) & 0xFFFF00) == 0 )
          goto LABEL_45;
        add_shell_safe_to_string(&string, uri->data, *(unsigned __int16 *)((char *)uri + 49));
        goto LABEL_50;
      case 'f':
        if ( !query )
          goto LABEL_45;
        add_to_string(&string, query);
        v17 = *v13;
        goto LABEL_27;
      case 'h':
        if ( *((_WORD *)uri + 21) && (v26 = *((_WORD *)uri + 23)) != 0 )
        {
          add_shell_safe_to_string(&string, uri->user, &uri->host[v26] - uri->user);
          v17 = *v13;
        }
        else
        {
          host = uri->host;
          if ( !host )
            goto LABEL_45;
          add_shell_safe_to_string(&string, host, *((unsigned __int16 *)uri + 23));
LABEL_50:
          v17 = *v13;
        }
        goto LABEL_27;
      case 'p':
        v25 = *((_BYTE *)uri + 48);
        if ( !v25 )
          goto LABEL_45;
        add_shell_safe_to_string(&string, uri->port, v25);
        v17 = *v13;
        goto LABEL_27;
      case 's':
        if ( !subj )
          goto LABEL_45;
        v24 = strlen((const char *)subj);
        add_shell_safe_to_string(&string, subj, v24);
        v17 = *v13;
        goto LABEL_27;
      case 'u':
        v21 = uri->post;
        v22 = uri->string;
        if ( v21 )
          v23 = v21 - 1 - v22;
        else
          v23 = strlen((const char *)uri->string);
        add_shell_safe_to_string(&string, v22, v23);
        v17 = *v13;
        goto LABEL_27;
      default:
        if ( !assert_failed )
        {
          length = string.length;
          assert_failed = 0;
          v15 = string.length + 258;
          v16 = string.length + 255;
          LOBYTE(v15) = 0;
          LOBYTE(v16) = 0;
          fda = string.length + 2;
          if ( v15 > v16 )
          {
            stream = (FILE *)v15;
            v45 = v16;
            v31 = (unsigned __int8 *)mem_realloc(string.source, v15);
            if ( !v31 )
            {
LABEL_26:
              v17 = *v13;
              goto LABEL_27;
            }
            string.source = v31;
            memset(&v31[v45], 0, (size_t)stream - v45);
          }
          if ( string.source )
          {
            *(_WORD *)&string.source[string.length] = *(_WORD *)v11;
            string.source[length + 2] = 0;
            string.length = fda;
          }
          goto LABEL_26;
        }
        assert_failed = 0;
        v17 = *v13;
LABEL_27:
        if ( !v17 )
          goto LABEL_28;
LABEL_45:
        v3 = v13 + 1;
        break;
    }
  }
LABEL_28:
  source = string.source;
LABEL_29:
  if ( subj )
    mem_free(subj);
  if ( source )
  {
    if ( query )
    {
      exec_on_terminal(ses->tab->term, source, query, TERM_EXEC_FG);
      mem_free(source);
      goto LABEL_34;
    }
    exec_on_terminal(ses->tab->term, source, (unsigned __int8 *)&delete, TERM_EXEC_FG);
    mem_free(source);
  }
  else if ( query )
  {
    unlink((const char *)query);
LABEL_34:
    mem_free(query);
  }
}

//----- (080C6A60) --------------------------------------------------------
list_head_elinks *get_invalid_auth_entry()
{
  list_head_elinks *result; // eax

  result = (list_head_elinks *)auth_entry_list.next;
  if ( auth_entry_list.next == &auth_entry_list )
    return 0;
  while ( ((int)result[14].next & 2) != 0 )
  {
    result = (list_head_elinks *)result->next;
    if ( result == &auth_entry_list )
      return 0;
  }
  return result;
}

//----- (080C6AA0) --------------------------------------------------------
void __usercall done_auth_entry(auth_entry *entry@<eax>)
{
  listbox_item *box_item; // eax

  box_item = entry->box_item;
  if ( box_item )
    done_listbox_item(&auth_browser, box_item);
  done_uri(entry->uri);
  if ( entry->realm )
    mem_free(entry->realm);
  if ( entry->nonce )
    mem_free(entry->nonce);
  if ( entry->opaque )
    mem_free(entry->opaque);
  mem_free(entry);
}

//----- (080C6B10) --------------------------------------------------------
void __cdecl del_auth_entry(auth_entry *entry)
{
  entry->next->prev = entry->prev;
  entry->prev->next = entry->next;
  done_auth_entry(entry);
}

//----- (080C6B30) --------------------------------------------------------
void free_auth()
{
  auth_entry *i; // eax
  _DWORD *next; // eax
  list_head_elinks *j; // ebx
  list_head_elinks *k; // edx
  list_head_elinks *v4; // esi
  list_head_elinks *v5; // edi

  for ( i = (auth_entry *)auth_entry_list.next;
        auth_entry_list.next != &auth_entry_list;
        i = (auth_entry *)auth_entry_list.next )
  {
    del_auth_entry(i);
  }
  next = questions_queue.next;
  for ( j = (list_head_elinks *)questions_queue.next; j != &questions_queue; j = (list_head_elinks *)j->next )
    ;
  for ( k = (list_head_elinks *)questions_queue.prev; k != j; k = (list_head_elinks *)k->prev )
    ;
  v4 = *(list_head_elinks **)questions_queue.next;
  if ( questions_queue.next != j )
  {
    do
    {
      v5 = v4;
      v4->prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v4 = (list_head_elinks *)v4->next;
      next = &v5->next;
    }
    while ( v5 != j );
  }
}

//----- (080C6BC0) --------------------------------------------------------
void __cdecl done_auth(module *xxx)
{
  free_auth();
}

//----- (080C6BD0) --------------------------------------------------------
auth_entry *__usercall find_auth_entry@<eax>(uri *uri@<eax>, unsigned __int8 *realm@<edx>)
{
  auth_entry *next; // esi
  auth_entry *match; // [esp+18h] [ebp-20h]

  next = (auth_entry *)auth_entry_list.next;
  match = 0;
  if ( auth_entry_list.next == &auth_entry_list )
    return match;
  while ( !compare_uri(next->uri, uri, URI_HTTP_AUTH) )
  {
LABEL_7:
    next = next->next;
    if ( &auth_entry_list == (list_head_elinks *)next )
      return match;
  }
  if ( realm && (!next->realm || strcmp((const char *)next->realm, (const char *)realm)) )
  {
    match = next;
    goto LABEL_7;
  }
  return next;
}

//----- (080C6C60) --------------------------------------------------------
void __usercall set_auth_user(auth_entry *entry@<eax>, uri *uri@<edx>)
{
  unsigned int v3; // esi
  size_t v4; // eax

  v3 = *((unsigned __int16 *)uri + 21);
  if ( v3 <= 0x26 )
  {
    if ( !*((_WORD *)uri + 21) )
      goto LABEL_4;
    v4 = *((unsigned __int16 *)uri + 21);
  }
  else
  {
    v4 = 39;
    v3 = 39;
  }
  memcpy(entry->user, uri->user, v4);
LABEL_4:
  entry->user[v3] = 0;
}

//----- (080C6CB0) --------------------------------------------------------
void __usercall set_auth_password(auth_entry *entry@<eax>, uri *uri@<edx>)
{
  unsigned int v3; // esi
  size_t v4; // eax

  v3 = *((unsigned __int16 *)uri + 22);
  if ( v3 <= 0x26 )
  {
    if ( !*((_WORD *)uri + 22) )
      goto LABEL_4;
    v4 = *((unsigned __int16 *)uri + 22);
  }
  else
  {
    v4 = 39;
    v3 = 39;
  }
  memcpy(entry->password, uri->password, v4);
LABEL_4:
  entry->password[v3] = 0;
}

//----- (080C6D00) --------------------------------------------------------
auth_entry *__cdecl add_auth_entry(
        uri *uri,
        unsigned __int8 *realm,
        unsigned __int8 *nonce,
        unsigned __int8 *opaque,
        unsigned int digest)
{
  auth_entry *auth_entry; // eax
  auth_entry *v6; // ebx
  char v7; // al
  char *v8; // edx
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  auth_entry *v12; // edi
  auth_entry *v14; // eax
  auth_entry *v15; // ecx
  unsigned __int8 *v16; // eax
  listbox_item *v17; // eax
  auth_entry *v18; // ecx
  auth_entry *next; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  auth_entry *v22; // [esp+0h] [ebp-58h]
  auth_entry *v23; // [esp+3Ch] [ebp-1Ch]
  auth_entry *v24; // [esp+3Ch] [ebp-1Ch]
  auth_entry *v25; // [esp+3Ch] [ebp-1Ch]

  auth_entry = find_auth_entry(uri, realm);
  v6 = auth_entry;
  if ( auth_entry )
  {
    v7 = *((_BYTE *)auth_entry + 112);
    if ( (v7 & 1) == 0 )
    {
      v8 = (char *)v6->realm;
      if ( (realm != 0) == (v8 != 0) )
      {
        if ( !realm || !v8 || !strcmp((const char *)realm, v8) )
          goto LABEL_17;
        v7 = *((_BYTE *)v6 + 112);
        v8 = (char *)v6->realm;
      }
      *((_BYTE *)v6 + 112) = v7 & 0xFD;
      if ( v8 )
        mem_free(v8);
      v6->realm = 0;
      if ( !realm )
        goto LABEL_17;
      v9 = stracpy(realm);
      v6->realm = v9;
      if ( !v9 )
        goto LABEL_50;
      if ( nonce )
      {
        if ( v6->nonce )
          mem_free(v6->nonce);
        v10 = stracpy(nonce);
        v6->nonce = v10;
        if ( !v10 )
        {
LABEL_50:
          v22 = v6;
          v6 = 0;
          del_auth_entry(v22);
          return v6;
        }
      }
      if ( !opaque )
        goto LABEL_16;
      if ( v6->opaque )
        mem_free(v6->opaque);
      v11 = stracpy(opaque);
      v6->opaque = v11;
      if ( v11 )
      {
LABEL_16:
        *((_BYTE *)v6 + 112) = (4 * (digest & 1)) | *((_BYTE *)v6 + 112) & 0xFB;
LABEL_17:
        if ( !v6->user[0]
          || !uri->user
          || !*((_WORD *)uri + 21)
          || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c",
              errline = 185,
              elinks_strlcmp(v6->user, 0xFFFFFFFF, uri->user, *((unsigned __int16 *)uri + 21))) )
        {
          *((_BYTE *)v6 + 112) &= ~2u;
          set_auth_user(v6, uri);
        }
        if ( !v6->password[0]
          || !uri->password
          || !*((_WORD *)uri + 22)
          || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c",
              v12 = v6,
              errline = 192,
              elinks_strlcmp(v6->password, 0xFFFFFFFF, uri->password, *((unsigned __int16 *)uri + 22))) )
        {
          *((_BYTE *)v6 + 112) &= ~2u;
          v12 = v6;
          set_auth_password(v6, uri);
        }
LABEL_25:
        if ( (*((_BYTE *)v12 + 112) & 2) == 0 && v12->realm )
        {
          v6 = v12;
          add_questions_entry(do_auth_dialog, v12);
          return v6;
        }
        return v12;
      }
      del_auth_entry(v6);
    }
    return 0;
  }
  v14 = (auth_entry *)mem_calloc(1u, 0x74u);
  v15 = v14;
  v12 = v14;
  if ( v14 )
  {
    ++uri->object.refcount;
    v14->uri = uri;
    if ( realm )
    {
      v23 = v14;
      v16 = stracpy(realm);
      v15 = v23;
      v23->realm = v16;
      if ( !v16 )
      {
        mem_free(v23);
        return v6;
      }
    }
    v24 = v15;
    set_auth_user(v15, uri);
    set_auth_password(v24, uri);
    v17 = add_listbox_item(&auth_browser, 0, BI_LEAF, v24, 1);
    v18 = v24;
    v24->box_item = v17;
    if ( !v17 )
    {
      done_auth_entry(v24);
      return v6;
    }
    next = (auth_entry *)auth_entry_list.next;
    v24->prev = (auth_entry *)&auth_entry_list;
    v24->next = next;
    auth_entry_list.next = v24;
    v24->next->prev = v24;
    if ( nonce && (v20 = stracpy(nonce), v18 = v24, (v24->nonce = v20) == 0)
      || opaque && (v25 = v18, v21 = stracpy(opaque), v18 = v25, (v25->opaque = v21) == 0) )
    {
      del_auth_entry(v18);
      return v6;
    }
    *((_BYTE *)v18 + 112) = (4 * (digest & 1)) | *((_BYTE *)v18 + 112) & 0xFB;
    goto LABEL_25;
  }
  return v12;
}

//----- (080C70A0) --------------------------------------------------------
auth_entry *__cdecl find_auth(uri *uri)
{
  auth_entry *auth_entry; // esi
  __int16 v2; // ax

  auth_entry = find_auth_entry(uri, 0);
  v2 = *((_WORD *)uri + 21);
  if ( v2 || *((_WORD *)uri + 22) )
  {
    if ( auth_entry )
    {
      if ( !v2 )
      {
        if ( !uri->password )
          goto LABEL_12;
LABEL_6:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
        errline = 250;
        if ( !elinks_strlcmp(auth_entry->password, 0xFFFFFFFF, uri->password, *((unsigned __int16 *)uri + 22)) )
          goto LABEL_12;
        goto LABEL_7;
      }
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/auth.c";
      errline = 249;
      if ( !elinks_strlcmp(auth_entry->user, 0xFFFFFFFF, uri->user, *((unsigned __int16 *)uri + 21)) )
      {
        if ( !uri->password )
          goto LABEL_12;
        goto LABEL_6;
      }
    }
LABEL_7:
    auth_entry = add_auth_entry(uri, 0, 0, 0, 0);
  }
  if ( !auth_entry )
    return auth_entry;
LABEL_12:
  if ( (*((_BYTE *)auth_entry + 112) & 1) == 0 )
  {
    if ( auth_entry->user[0] || auth_entry->password[0] )
      return auth_entry;
    del_auth_entry(auth_entry);
  }
  return 0;
}

//----- (080C71D0) --------------------------------------------------------
void __cdecl lock_auth_entry(listbox_item *item)
{
  ++*((_DWORD *)item->udata + 2);
}

//----- (080C71E0) --------------------------------------------------------
void __cdecl unlock_auth_entry(listbox_item *item)
{
  --*((_DWORD *)item->udata + 2);
}

//----- (080C71F0) --------------------------------------------------------
int __cdecl is_auth_entry_used(listbox_item *item)
{
  return *((_DWORD *)item->udata + 2) != 0;
}

//----- (080C7210) --------------------------------------------------------
listbox_item *__cdecl get_auth_entry_root(listbox_item *box_item)
{
  return 0;
}

//----- (080C7220) --------------------------------------------------------
int __cdecl can_delete_auth_entry(listbox_item *item)
{
  return 1;
}

//----- (080C7230) --------------------------------------------------------
void __cdecl delete_auth_entry(listbox_item *item, int last)
{
  auth_entry *udata; // ebx
  int refcount; // ecx

  udata = (auth_entry *)item->udata;
  if ( !assert_failed && (refcount = udata->object.refcount, assert_failed = refcount != 0, refcount) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 212;
    elinks_internal("assertion !is_object_used(auth_entry) failed!");
    del_auth_entry(udata);
  }
  else
  {
    del_auth_entry(udata);
  }
}

//----- (080C72A0) --------------------------------------------------------
void __cdecl auth_cancel(void *data)
{
  *((_BYTE *)data + 112) &= ~1u;
  del_auth_entry((auth_entry *)data);
}

//----- (080C72C0) --------------------------------------------------------
uri *__cdecl get_auth_entry_uri(listbox_item *item)
{
  return get_composed_uri(*((uri **)item->udata + 3), URI_HTTP_AUTH);
}

//----- (080C72F0) --------------------------------------------------------
string *__usercall add_bytes_to_string___3@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (080C7440) --------------------------------------------------------
unsigned __int8 *__usercall _6@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (080C74B0) --------------------------------------------------------
unsigned __int8 *__cdecl get_auth_entry_info(listbox_item *item, terminal *term)
{
  void *udata; // ebx
  const char *v4; // eax
  unsigned __int8 *v5; // eax
  const unsigned __int8 *v6; // edi
  int v7; // eax
  unsigned __int8 *v8; // ebx
  const char *v9; // eax
  const unsigned __int8 *v10; // eax
  string info; // [esp+18h] [ebp-20h] BYREF

  udata = item->udata;
  if ( item->type == BI_FOLDER || !init_string(&info) )
    return 0;
  v4 = (const char *)_6((unsigned __int8 *)&byte_812B6C9, term);
  add_format_to_string(&info, "%s: ", v4);
  add_uri_to_string(&info, *((const uri **)udata + 3), URI_HTTP_AUTH);
  v5 = _6("Realm", term);
  add_format_to_string(&info, &byte_81279A6, v5);
  v6 = (const unsigned __int8 *)*((_DWORD *)udata + 4);
  if ( v6 )
  {
    v7 = strlen(*((const char **)udata + 4));
    if ( v7 <= 511 )
    {
      add_bytes_to_string___3(&info, v6, v7);
    }
    else
    {
      add_bytes_to_string___3(&info, v6, 512);
      add_to_string(&info, &bytes);
    }
  }
  else
  {
    v10 = _6("none", term);
    add_to_string(&info, v10);
  }
  if ( (*((_BYTE *)udata + 112) & 2) != 0 )
    v8 = _6((unsigned __int8 *)"valid", term);
  else
    v8 = _6("invalid", term);
  v9 = (const char *)_6("State", term);
  add_format_to_string(&info, "\n%s: %s\n", v9, (const char *)v8);
  return info.source;
}

//----- (080C7610) --------------------------------------------------------
unsigned __int8 *__cdecl get_auth_entry_text(listbox_item *item, terminal *term)
{
  return get_uri_string(*((const uri **)item->udata + 3), URI_HTTP_AUTH);
}

//----- (080C7630) --------------------------------------------------------
void __cdecl auth_manager(session *ses)
{
  hierbox_browser_0(&auth_browser, ses);
}

//----- (080C7650) --------------------------------------------------------
void __cdecl auth_ok(void *data)
{
  bool v1; // dl
  int v2; // ebx
  session *v3; // edi
  char v4; // al
  bool v5; // zf
  char v6; // al
  location *current; // eax
  uri *uri; // esi
  uri *composed_uri; // eax
  uri *v10; // ebx

  v1 = 1;
  v2 = *((_DWORD *)data + 2);
  v3 = (session *)*((_DWORD *)data + 1);
  v4 = *(_BYTE *)(v2 + 112) & 0xFE;
  v5 = *(_BYTE *)(v2 + 32) == 0;
  *(_BYTE *)(v2 + 112) = v4;
  if ( v5 )
    v1 = *(_BYTE *)(v2 + 72) != 0;
  v6 = (2 * v1) | v4 & 0xFD;
  *(_BYTE *)(v2 + 112) = v6;
  if ( (v6 & 2) == 0 )
    goto LABEL_10;
  current = v3->history.current;
  if ( !current )
    goto LABEL_10;
  uri = current->vs.uri;
  if ( !*((_WORD *)uri + 21)
    || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c",
        errline = 45,
        !elinks_strlcmp((const unsigned __int8 *)(v2 + 32), 0xFFFFFFFF, uri->user, *((unsigned __int16 *)uri + 21))) )
  {
    if ( !uri->password )
      goto LABEL_10;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
    errline = 46;
    if ( !elinks_strlcmp((const unsigned __int8 *)(v2 + 72), 0xFFFFFFFF, uri->password, *((unsigned __int16 *)uri + 22)) )
      goto LABEL_10;
  }
  composed_uri = get_composed_uri(uri, (uri_component)-32077);
  v10 = composed_uri;
  if ( composed_uri )
  {
    goto_uri_frame(v3, composed_uri, 0, CACHE_MODE_INCREMENT);
    done_uri(v10);
  }
  else
  {
LABEL_10:
    reload(v3, CACHE_MODE_INCREMENT);
  }
}

//----- (080C77B0) --------------------------------------------------------
void __cdecl do_auth_dialog(session *ses, void *data)
{
  terminal *term; // edi
  list_head_elinks *invalid_auth_entry; // eax
  list_head_elinks *v4; // ebx
  unsigned __int8 *uri_string; // edx
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  bool v12; // zf
  dialog_data *v13; // eax
  unsigned __int8 *v14; // [esp+4h] [ebp-464h]
  unsigned __int8 *v15; // [esp+8h] [ebp-460h]
  memory_list *v16; // [esp+8h] [ebp-460h]
  int v17; // [esp+30h] [ebp-438h]
  unsigned __int8 *p; // [esp+34h] [ebp-434h]
  unsigned __int8 *pa; // [esp+34h] [ebp-434h]
  unsigned int sticker_len; // [esp+38h] [ebp-430h]
  dialog *dlg; // [esp+3Ch] [ebp-42Ch]
  dialog *dlga; // [esp+3Ch] [ebp-42Ch]
  unsigned __int8 sticker[1024]; // [esp+4Ch] [ebp-41Ch] BYREF
  unsigned int v24; // [esp+44Ch] [ebp-1Ch]

  v24 = __readgsdword(0x14u);
  term = ses->tab->term;
  invalid_auth_entry = get_invalid_auth_entry();
  v4 = invalid_auth_entry;
  if ( invalid_auth_entry )
  {
    if ( ((int)invalid_auth_entry[14].next & 1) == 0 )
    {
      uri_string = get_uri_string((const uri *)invalid_auth_entry[1].prev, URI_HTTP_AUTH);
      if ( uri_string )
      {
        dlg = (dialog *)v4[2].next;
        if ( term )
        {
          p = uri_string;
          terminal_codepage = get_terminal_codepage(term);
          uri_string = p;
          if ( terminal_codepage != current_charset )
          {
            v17 = terminal_codepage;
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            uri_string = p;
            current_charset = v17;
          }
        }
        pa = uri_string;
        v8 = gettext(&byte_812122C);
        sticker_len = __snprintf_chk(sticker, 1024, 1, 1024, (const char *)v8, dlg, pa);
        mem_free(pa);
        if ( sticker_len <= 0x400 )
        {
          dlga = (dialog *)mem_calloc(1u, sticker_len + 277);
          if ( dlga )
          {
            LOBYTE(v4[14].next) |= 1u;
            v9 = _6("Authentication required", term);
            dlga->layouter = generic_dialog_layouter;
            dlga->title = v9;
            memcpy(&dlga[3].abort, sticker, sticker_len);
            dlga->udata = ses;
            dlga->udata2 = v4;
            add_dlg_text(dlga, (unsigned __int8 *)&dlga[3].abort, ALIGN_LEFT, 0);
            v15 = _6("Login", term);
            add_dlg_field_do(dlga, WIDGET_FIELD, v15, 0, 0, 0, 40, &v4[4], 0, INPFIELD_FLOAT);
            v10 = _6("Password", term);
            add_dlg_field_do(dlga, WIDGET_FIELD_PASS, v10, 0, 0, 0, 40, &v4[9], 0, INPFIELD_FLOAT);
            v11 = _6((unsigned __int8 *)&okbutton, term);
            add_dlg_button_do(dlga, v11, 1, ok_dialog, 0, auth_ok, dlga);
            v14 = _6((unsigned __int8 *)&cancelbutton, term);
            add_dlg_button_do(dlga, v14, 2, ok_dialog, 0, auth_cancel, v4);
            if ( !assert_failed )
            {
              v12 = dlga->number_of_widgets == 5;
              assert_failed = dlga->number_of_widgets != 5;
              if ( !v12 )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/auth/dialogs.c";
                errline = 118;
                elinks_internal("assertion 5 == (dlg)->number_of_widgets failed!");
              }
            }
            v16 = getml(dlga, 0);
            v13 = do_dialog(term, dlga, v16);
            if ( v13 && LOBYTE(v4[4].next) && !LOBYTE(v4[9].next) )
              select_widget_by_id(v13, 1);
          }
        }
      }
    }
  }
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080C7B90) --------------------------------------------------------
void __usercall convert_to_md5_digest_hex_T(unsigned __int8 *bin@<eax>, unsigned __int8 *hex@<edx>)
{
  int v2; // esi
  int i; // eax
  unsigned __int8 *v4; // esi
  unsigned __int8 v5; // cl
  int v6; // edi
  unsigned __int8 v7; // bl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl
  unsigned __int8 v10; // bl

  v2 = 0;
  for ( i = 0; i != 16; v2 = i )
  {
    v4 = &bin[v2];
    v5 = *v4 >> 4;
    v6 = v5;
    v7 = v5 + 87;
    v8 = v5 + 48;
    if ( v6 < 10 )
      v7 = v8;
    hex[2 * i] = v7;
    v9 = *v4 & 0xF;
    v10 = v9 + 87;
    if ( v9 < 0xAu )
      v10 = v9 + 48;
    hex[2 * i++ + 1] = v10;
  }
}

//----- (080C7BF0) --------------------------------------------------------
unsigned __int8 *__cdecl get_http_auth_digest_response(auth_entry *entry, uri *uri)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  unsigned int v4; // eax
  unsigned __int8 *user; // edx
  int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned __int8 *password; // edx
  int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned __int16 v13; // di
  unsigned __int8 *v14; // edx
  int length; // edi
  size_t v16; // edx
  unsigned int v17; // ecx
  unsigned __int8 *v18; // eax
  int v19; // edi
  unsigned int v20; // ecx
  size_t v21; // edx
  unsigned __int8 *v22; // eax
  unsigned int v23; // eax
  size_t v24; // ecx
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // eax
  unsigned __int8 *realm; // [esp+1Ch] [ebp-18Ch]
  unsigned __int8 *nonce; // [esp+1Ch] [ebp-18Ch]
  unsigned __int8 *v30; // [esp+1Ch] [ebp-18Ch]
  unsigned __int8 *v31; // [esp+1Ch] [ebp-18Ch]
  unsigned __int8 *v32; // [esp+1Ch] [ebp-18Ch]
  unsigned __int8 *v33; // [esp+20h] [ebp-188h]
  unsigned __int8 *v34; // [esp+20h] [ebp-188h]
  unsigned __int8 *v35; // [esp+20h] [ebp-188h]
  int v36; // [esp+28h] [ebp-180h]
  const unsigned __int8 *buf; // [esp+2Ch] [ebp-17Ch]
  unsigned __int8 *bufa; // [esp+2Ch] [ebp-17Ch]
  unsigned __int8 *bufb; // [esp+2Ch] [ebp-17Ch]
  unsigned __int8 *bufc; // [esp+2Ch] [ebp-17Ch]
  string string; // [esp+30h] [ebp-178h] BYREF
  unsigned __int8 data[4]; // [esp+38h] [ebp-170h] BYREF
  md5_context ctx; // [esp+3Ch] [ebp-16Ch] BYREF
  md5_context v44; // [esp+94h] [ebp-114h] BYREF
  unsigned __int8 v45[32]; // [esp+ECh] [ebp-BCh] BYREF
  unsigned __int8 hex[32]; // [esp+10Ch] [ebp-9Ch] BYREF
  md5_digest_hex_T response; // [esp+12Ch] [ebp-7Ch] BYREF
  md5_digest_hex_T cnonce; // [esp+14Ch] [ebp-5Ch] BYREF
  unsigned __int8 bin[16]; // [esp+16Ch] [ebp-3Ch] BYREF
  unsigned __int8 digest[16]; // [esp+17Ch] [ebp-2Ch] BYREF
  unsigned int v51; // [esp+18Ch] [ebp-1Ch]

  v51 = __readgsdword(0x14u);
  inited = init_string(&string);
  result = 0;
  if ( !inited )
    return result;
  v4 = time(0);
  srand(v4);
  *(_DWORD *)data = rand();
  digest_md5(data, 4u, digest);
  convert_to_md5_digest_hex_T(digest, cnonce);
  init_md5(&ctx);
  buf = entry->user;
  user = entry->user;
  do
  {
    v6 = *(_DWORD *)user;
    user += 4;
    v7 = ~v6 & (v6 - 16843009) & 0x80808080;
  }
  while ( !v7 );
  if ( (~v6 & (v6 - 16843009) & 0x8080) == 0 )
    v7 >>= 16;
  if ( (~v6 & (v6 - 16843009) & 0x8080) == 0 )
    user += 2;
  update_md5(&ctx, buf, &user[-__CFADD__((_BYTE)v7, (_BYTE)v7) - 3] - buf);
  update_md5(&ctx, &::buf, 1u);
  realm = entry->realm;
  v8 = strlen((const char *)realm);
  update_md5(&ctx, realm, v8);
  update_md5(&ctx, &::buf, 1u);
  password = entry->password;
  do
  {
    v10 = *(_DWORD *)password;
    password += 4;
    v11 = ~v10 & (v10 - 16843009) & 0x80808080;
  }
  while ( !v11 );
  if ( (~v10 & (v10 - 16843009) & 0x8080) == 0 )
    v11 >>= 16;
  if ( (~v10 & (v10 - 16843009) & 0x8080) == 0 )
    password += 2;
  update_md5(&ctx, entry->password, &password[-__CFADD__((_BYTE)v11, (_BYTE)v11) - 3] - entry->password);
  done_md5(&ctx, bin);
  convert_to_md5_digest_hex_T(bin, hex);
  init_md5(&ctx);
  update_md5(&ctx, (const unsigned __int8 *)"GET", 3u);
  update_md5(&ctx, &byte_81323EC, 2u);
  update_md5(&ctx, uri->data, *(unsigned __int16 *)((char *)uri + 49));
  done_md5(&ctx, bin);
  convert_to_md5_digest_hex_T(bin, v45);
  init_md5(&v44);
  update_md5(&v44, hex, 0x20u);
  update_md5(&v44, &::buf, 1u);
  if ( entry->nonce )
  {
    nonce = entry->nonce;
    v12 = strlen((const char *)nonce);
    update_md5(&v44, nonce, v12);
  }
  update_md5(&v44, &::buf, 1u);
  update_md5(&v44, "00000001", 8u);
  update_md5(&v44, &::buf, 1u);
  update_md5(&v44, cnonce, 0x20u);
  update_md5(&v44, &::buf, 1u);
  update_md5(&v44, "auth", 4u);
  update_md5(&v44, &::buf, 1u);
  update_md5(&v44, v45, 0x20u);
  done_md5(&v44, digest);
  convert_to_md5_digest_hex_T(digest, response);
  add_to_string(&string, "username=\"");
  add_to_string(&string, buf);
  add_to_string(&string, "\", ");
  add_to_string(&string, "realm=\"");
  if ( entry->realm )
    add_to_string(&string, entry->realm);
  add_to_string(&string, "\", ");
  add_to_string(&string, "nonce=\"");
  if ( entry->nonce )
    add_to_string(&string, entry->nonce);
  add_to_string(&string, "\", ");
  add_to_string(&string, "uri=\"/");
  v13 = *(_WORD *)((char *)uri + 49);
  v14 = uri->data;
  if ( assert_failed )
    goto LABEL_21;
  if ( v14 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    v14 = 0;
    if ( assert_failed )
    {
LABEL_21:
      assert_failed = 0;
      goto LABEL_22;
    }
  }
  if ( v13 )
  {
    v23 = string.length + 255;
    v36 = v13 + string.length;
    v24 = v36 + 256;
    LOBYTE(v23) = 0;
    LOBYTE(v24) = 0;
    bufc = (unsigned __int8 *)v23;
    if ( v24 > v23 )
    {
      v35 = (unsigned __int8 *)v24;
      v32 = v14;
      v27 = (unsigned __int8 *)mem_realloc(string.source, v24);
      if ( !v27 )
        goto LABEL_22;
      string.source = v27;
      memset(&v27[(_DWORD)bufc], 0, v35 - bufc);
      v14 = v32;
    }
    if ( string.source )
    {
      memcpy(&string.source[string.length], v14, v13);
      string.source[v36] = 0;
      string.length = v36;
    }
  }
LABEL_22:
  add_to_string(&string, "\", ");
  add_to_string(&string, "qop=auth, nc=00000001, ");
  add_to_string(&string, &byte_8132433);
  if ( assert_failed )
  {
    assert_failed = 0;
    goto LABEL_26;
  }
  length = string.length;
  assert_failed = 0;
  bufa = (unsigned __int8 *)(string.length + 32);
  v16 = string.length + 288;
  v17 = string.length + 255;
  LOBYTE(v16) = 0;
  LOBYTE(v17) = 0;
  if ( v16 > v17 )
  {
    v31 = (unsigned __int8 *)v16;
    v34 = (unsigned __int8 *)v17;
    v26 = (unsigned __int8 *)mem_realloc(string.source, v16);
    if ( !v26 )
      goto LABEL_26;
    string.source = v26;
    memset(&v34[(_DWORD)v26], 0, v31 - v34);
  }
  if ( string.source )
  {
    v18 = &string.source[string.length];
    *(_DWORD *)v18 = *(_DWORD *)cnonce;
    *((_DWORD *)v18 + 1) = *(_DWORD *)&cnonce[4];
    *((_DWORD *)v18 + 2) = *(_DWORD *)&cnonce[8];
    *((_DWORD *)v18 + 3) = *(_DWORD *)&cnonce[12];
    *((_DWORD *)v18 + 4) = *(_DWORD *)&cnonce[16];
    *((_DWORD *)v18 + 5) = *(_DWORD *)&cnonce[20];
    *((_DWORD *)v18 + 6) = *(_DWORD *)&cnonce[24];
    *((_DWORD *)v18 + 7) = *(_DWORD *)&cnonce[28];
    string.source[length + 32] = 0;
    string.length = (int)bufa;
  }
LABEL_26:
  add_to_string(&string, "\", ");
  add_to_string(&string, "response=\"");
  if ( assert_failed )
  {
    assert_failed = 0;
  }
  else
  {
    v19 = string.length;
    assert_failed = 0;
    bufb = (unsigned __int8 *)(string.length + 32);
    v20 = string.length + 255;
    v21 = string.length + 288;
    LOBYTE(v20) = 0;
    LOBYTE(v21) = 0;
    if ( v21 <= v20 )
      goto LABEL_28;
    v30 = (unsigned __int8 *)v21;
    v33 = (unsigned __int8 *)v20;
    v25 = (unsigned __int8 *)mem_realloc(string.source, v21);
    if ( v25 )
    {
      string.source = v25;
      memset(&v33[(_DWORD)v25], 0, v30 - v33);
LABEL_28:
      if ( string.source )
      {
        v22 = &string.source[string.length];
        *(_DWORD *)v22 = *(_DWORD *)response;
        *((_DWORD *)v22 + 1) = *(_DWORD *)&response[4];
        *((_DWORD *)v22 + 2) = *(_DWORD *)&response[8];
        *((_DWORD *)v22 + 3) = *(_DWORD *)&response[12];
        *((_DWORD *)v22 + 4) = *(_DWORD *)&response[16];
        *((_DWORD *)v22 + 5) = *(_DWORD *)&response[20];
        *((_DWORD *)v22 + 6) = *(_DWORD *)&response[24];
        *((_DWORD *)v22 + 7) = *(_DWORD *)&response[28];
        string.source[v19 + 32] = 0;
        string.length = (int)bufb;
      }
    }
  }
  add_to_string(&string, "\"");
  if ( entry->opaque )
  {
    add_to_string(&string, ", opaque=\"");
    add_to_string(&string, entry->opaque);
    add_to_string(&string, "\"");
  }
  return string.source;
}

//----- (080C8420) --------------------------------------------------------
connection_basic_state *__usercall connection_state_4@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080C84B0) --------------------------------------------------------
void __cdecl close_pipe_and_read(socket *data_socket)
{
  socket **conn; // esi
  read_buffer *buffer; // eax
  read_buffer *v3; // ebx
  unsigned __int8 *data; // eax
  int v5; // eax

  conn = (socket **)data_socket->conn;
  buffer = alloc_read_buffer(conn[24]);
  v3 = buffer;
  if ( buffer )
  {
    data = buffer->data;
    *(_DWORD *)v3->data = 1347703880;
    *((_DWORD *)data + 1) = 808333615;
    *((_DWORD *)data + 2) = 808464928;
    *((_DWORD *)data + 3) = 223039264;
    data[16] = 10;
    v3->freespace -= 17;
    v3->length = 17;
    *((_BYTE *)conn + 120) |= 2u;
    close(data_socket->fd);
    data_socket->fd = -1;
    conn[24]->state = SOCKET_END_ONCLOSE;
    if ( assert_failed )
    {
      assert_failed = 0;
      v5 = -100003;
    }
    else
    {
      assert_failed = 0;
      v5 = 4;
    }
    read_from_socket(conn[24], v3, (connection_state)(unsigned int)v5, http_got_header);
  }
}

//----- (080C8590) --------------------------------------------------------
void __usercall send_post_data(connection *conn@<eax>)
{
  unsigned __int8 *post; // ebx
  char *v2; // eax
  signed int v3; // esi
  unsigned __int8 v4; // al
  char v5; // dl
  int v6; // edi
  unsigned int v7; // edi
  char v8; // cl
  unsigned __int8 v9; // al
  unsigned int v10; // edi
  int length; // edx
  unsigned int v12; // esi
  unsigned int v13; // edi
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // esi
  unsigned __int8 *v16; // edi
  int v17; // eax
  unsigned __int8 *v18; // edi
  unsigned __int8 *v19; // esi
  int v20; // ebx
  int v21; // eax
  int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // edx
  unsigned __int8 *v25; // eax
  __int16 v26; // ax
  unsigned __int8 *v27; // eax
  char v28; // [esp+28h] [ebp-1040h]
  int v29; // [esp+28h] [ebp-1040h]
  unsigned int v30; // [esp+28h] [ebp-1040h]
  unsigned int v31; // [esp+2Ch] [ebp-103Ch]
  int v32; // [esp+30h] [ebp-1038h]
  connection_state state; // [esp+38h] [ebp-1030h] BYREF
  string data; // [esp+44h] [ebp-1024h] BYREF
  unsigned __int8 buffer[4096]; // [esp+4Ch] [ebp-101Ch] BYREF
  unsigned int v37; // [esp+104Ch] [ebp-1Ch]

  v37 = __readgsdword(0x14u);
  post = conn->uri->post;
  if ( !init_string(&data) )
  {
    connection_state_4(S_OUT_OF_MEM, &state.basic);
    abort_connection(conn, state);
    return;
  }
  v2 = strchr((const char *)post, 10);
  if ( v2 )
    post = (unsigned __int8 *)(v2 + 1);
  v3 = 0;
  while ( 1 )
  {
    v9 = *post;
    if ( !*post || !post[1] )
      break;
    v10 = v9 - 48;
    if ( (unsigned __int8)(v9 - 48) > 9u )
    {
      v10 = v9 - 87;
      if ( (unsigned __int8)(v9 - 97) > 5u )
      {
        v10 = -1;
        if ( (unsigned __int8)(v9 - 65) < 6u )
          v10 = v9 - 55;
      }
    }
    if ( assert_failed
      || (assert_failed = v10 > 0xF) != 0
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/file/cgi.c",
          errline = 107,
          elinks_internal("assertion h1 >= 0 && h1 < 16 failed!"),
          assert_failed) )
    {
      assert_failed = 0;
      v4 = post[1];
      v5 = 0;
      v6 = v4;
      if ( (unsigned __int8)(v4 - 48) <= 9u )
      {
LABEL_7:
        v7 = v6 - 48;
        goto LABEL_8;
      }
    }
    else
    {
      v4 = post[1];
      v5 = 16 * v10;
      v6 = v4;
      if ( (unsigned __int8)(v4 - 48) <= 9u )
        goto LABEL_7;
    }
    if ( (unsigned __int8)(v4 - 97) <= 5u )
    {
      v7 = v6 - 87;
      goto LABEL_8;
    }
    if ( (unsigned __int8)(v4 - 65) <= 5u )
    {
      v7 = v6 - 55;
LABEL_8:
      v8 = v7;
      assert_failed = v7 > 0xF;
      if ( v7 <= 0xF )
        goto LABEL_9;
      goto LABEL_26;
    }
    assert_failed = 1;
    LOBYTE(v7) = -1;
LABEL_26:
    v28 = v5;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/file/cgi.c";
    errline = 111;
    elinks_internal("assertion h2 >= 0 && h2 < 16 failed!");
    v5 = v28;
    if ( assert_failed )
    {
      assert_failed = 0;
      v8 = 0;
    }
    else
    {
      v8 = v7;
    }
LABEL_9:
    buffer[v3++] = v8 + v5;
    if ( v3 != 4096 )
      goto LABEL_10;
    if ( assert_failed )
    {
      assert_failed = 0;
      v3 = 0;
      goto LABEL_10;
    }
    length = data.length;
    assert_failed = 0;
    v12 = (data.length + 4352) & 0xFFFFFF00;
    v13 = (data.length + 255) & 0xFFFFFF00;
    v32 = data.length + 4096;
    if ( v12 > v13 )
    {
      v29 = data.length;
      v25 = (unsigned __int8 *)mem_realloc(data.source, (data.length + 4352) & 0xFFFFFF00);
      if ( !v25 )
      {
LABEL_57:
        v3 = 0;
        goto LABEL_10;
      }
      data.source = v25;
      memset(&v25[v13], 0, v12 - v13);
      length = v29;
    }
    if ( !data.source )
      goto LABEL_57;
    v14 = &data.source[data.length];
    v15 = buffer;
    v31 = 4096;
    v16 = &data.source[data.length];
    if ( ((LOBYTE(data.length) + LOBYTE(data.source)) & 1) != 0 )
    {
      v16 = v14 + 1;
      v15 = &buffer[1];
      *v14 = buffer[0];
      v31 = 4095;
    }
    if ( ((unsigned __int8)v16 & 2) != 0 )
    {
      v26 = *(_WORD *)v15;
      v15 += 2;
      *(_WORD *)v16 = v26;
      v16 += 2;
      v31 -= 2;
    }
    v17 = 0;
    qmemcpy(v16, v15, 4 * (v31 >> 2));
    v19 = &v15[4 * (v31 >> 2)];
    v18 = &v16[4 * (v31 >> 2)];
    if ( (v31 & 2) != 0 )
    {
      *(_WORD *)v18 = *(_WORD *)v19;
      v17 = 2;
    }
    if ( (v31 & 1) != 0 )
      v18[v17] = v19[v17];
    v3 = 0;
    data.source[length + 4096] = 0;
    data.length = v32;
LABEL_10:
    post += 2;
  }
  if ( !v3 )
    goto LABEL_42;
  if ( assert_failed )
    goto LABEL_61;
  if ( v3 >= 0 )
  {
    assert_failed = 0;
    goto LABEL_53;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  if ( assert_failed )
  {
LABEL_61:
    assert_failed = 0;
    v20 = data.length;
  }
  else
  {
LABEL_53:
    v22 = data.length;
    v20 = v3 + data.length;
    v24 = data.length + 255;
    v23 = (v3 + data.length + 256) & 0xFFFFFF00;
    LOBYTE(v24) = 0;
    if ( v23 > v24 )
    {
      v30 = v24;
      v27 = (unsigned __int8 *)mem_realloc(data.source, (v3 + data.length + 256) & 0xFFFFFF00);
      if ( !v27 )
      {
LABEL_42:
        v20 = data.length;
        goto LABEL_43;
      }
      data.source = v27;
      memset(&v27[v30], 0, v23 - v30);
      v22 = data.length;
    }
    if ( data.source )
    {
      memcpy(&data.source[v22], buffer, v3);
      data.source[v20] = 0;
      data.length = v20;
    }
    else
    {
      v20 = v22;
    }
  }
LABEL_43:
  if ( v20 )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v21 = -100003;
    }
    else
    {
      assert_failed = 0;
      v21 = 4;
    }
    write_to_socket(conn->data_socket, data.source, v20, (connection_state)(unsigned int)v21, close_pipe_and_read);
  }
  else
  {
    close_pipe_and_read(conn->data_socket);
  }
  done_string(&data);
}

//----- (080C8B20) --------------------------------------------------------
int __cdecl execute_cgi(connection *conn)
{
  uri *referrer; // eax
  unsigned __int8 *uri_string; // eax
  char *v4; // esi
  char *v5; // eax
  unsigned __int8 *next_path_filename; // eax
  unsigned __int8 *v7; // edi
  size_t v8; // eax
  int v9; // edi
  __pid_t v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // edi
  int v13; // eax
  char *v14; // eax
  char *v15; // edi
  socket *socket; // eax
  unsigned __int8 *v17; // eax
  option_value *opt; // eax
  unsigned __int8 v19; // al
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  unsigned __int8 *v22; // edi
  int number; // eax
  unsigned __int8 *v24; // eax
  cache_entry *cached; // eax
  unsigned __int8 *last_modified; // eax
  string *v27; // eax
  string *v28; // edi
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // edi
  unsigned __int8 **p_string; // eax
  size_t v32; // [esp+28h] [ebp-F0h]
  int v33; // [esp+28h] [ebp-F0h]
  int v34; // [esp+28h] [ebp-F0h]
  _DWORD *prev; // [esp+28h] [ebp-F0h]
  char storage; // [esp+2Ch] [ebp-ECh]
  unsigned __int8 *storagea; // [esp+2Ch] [ebp-ECh]
  unsigned __int8 *storageb; // [esp+2Ch] [ebp-ECh]
  char *v39; // [esp+30h] [ebp-E8h]
  connection_state state; // [esp+34h] [ebp-E4h] BYREF
  int v41; // [esp+3Ch] [ebp-DCh]
  stat buf; // [esp+44h] [ebp-D4h] BYREF
  int pipe_write[2]; // [esp+A4h] [ebp-74h] BYREF
  int pipe_read[2]; // [esp+ACh] [ebp-6Ch] BYREF
  unsigned __int8 *dst; // [esp+B4h] [ebp-64h] BYREF
  unsigned __int8 *path_ptr; // [esp+B8h] [ebp-60h] BYREF
  unsigned __int8 value[4]; // [esp+BCh] [ebp-5Ch] BYREF
  char v48[60]; // [esp+C0h] [ebp-58h] BYREF
  unsigned int v49; // [esp+FCh] [ebp-1Ch]

  v49 = __readgsdword(0x14u);
  if ( assert_failed )
  {
    assert_failed = 0;
    state.basic = S_INTERNAL;
  }
  else
  {
    assert_failed = 0;
    state.basic = S_OK;
  }
  if ( !get_opt_(config_options, "protocol.file.cgi.policy")->number )
    return 1;
  referrer = conn->referrer;
  if ( referrer )
  {
    if ( referrer->protocol != 4 )
      return 1;
  }
  uri_string = get_uri_string(conn->uri, URI_PATH);
  v4 = (char *)uri_string;
  if ( !uri_string )
  {
    connection_state_4(S_OUT_OF_MEM, (connection_basic_state *)&state.syserr);
    v9 = v41;
    state.basic = state.syserr;
    goto end2;
  }
  decode_uri(uri_string);
  if ( __xstat64(3, v4, &buf) )
    goto LABEL_11;
  if ( (buf.st_mode & 0xF040) != 32832 )
    goto LABEL_11;
  v5 = strrchr(v4, 47);
  v39 = v5;
  if ( !v5 )
    goto LABEL_11;
  storage = v5[1];
  v5[1] = 0;
  path_ptr = (unsigned __int8 *)get_opt_(config_options, "protocol.file.cgi.path")->number;
  do
  {
    next_path_filename = get_next_path_filename(&path_ptr, 0x3Au);
    v7 = next_path_filename;
    dst = next_path_filename;
    if ( !next_path_filename )
    {
      v39[1] = storage;
LABEL_11:
      mem_free(v4);
      return 1;
    }
    v8 = strlen((const char *)next_path_filename);
    if ( v7[v8 - 1] != 47 )
    {
      v32 = v8;
      add_to_strn(&dst, "/");
      v7 = dst;
      v8 = v32 + 1;
    }
    v33 = strncmp(v4, (const char *)v7, v8);
    mem_free(v7);
  }
  while ( v33 );
  v39[1] = storage;
  if ( c_pipe(pipe_read) || c_pipe(pipe_write) )
  {
    v9 = *__errno_location();
    state.basic = S_ERRNO;
    goto end1;
  }
  v10 = fork();
  if ( v10 < 0 )
  {
    v9 = *__errno_location();
    state.basic = S_ERRNO;
    goto end0;
  }
  if ( v10 )
  {
    mem_free(v4);
    if ( init_http_connection_info(conn, 1, 0, 1) )
    {
      close(pipe_read[1]);
      close(pipe_write[0]);
      conn->socket->fd = pipe_read[0];
      conn->data_socket->fd = pipe_write[1];
      socket = conn->socket;
      *((_BYTE *)conn + 120) |= 8u;
      set_nonblocking_fd(socket->fd);
      set_nonblocking_fd(conn->data_socket->fd);
      if ( conn->uri->post )
        send_post_data(conn);
      else
        close_pipe_and_read(conn->data_socket);
      return 0;
    }
    else
    {
      close(pipe_read[0]);
      close(pipe_read[1]);
      close(pipe_write[0]);
      close(pipe_write[1]);
      return 0;
    }
  }
  storagea = conn->uri->post;
  v11 = get_uri_string(conn->uri, URI_QUERY);
  v12 = v11;
  if ( v11 )
  {
    v34 = env_set("QUERY_STRING", v11, -1);
    mem_free(v12);
    v13 = v34;
  }
  else
  {
    v13 = env_set("QUERY_STRING", (unsigned __int8 *)&delete, -1);
  }
  if ( v13 )
    goto LABEL_33;
  if ( !storagea )
  {
LABEL_92:
    v17 = (unsigned __int8 *)"GET";
    goto LABEL_46;
  }
  v14 = strchr((const char *)storagea, 10);
  v15 = v14;
  if ( v14 )
  {
    if ( env_set("CONTENT_TYPE", storagea, v14 - (char *)storagea) )
      goto LABEL_33;
    storagea = (unsigned __int8 *)(v15 + 1);
  }
  __snprintf_chk(value, 16, 1, 16, (const char *)"%d", (int)strlen((const char *)storagea) / 2);
  if ( env_set("CONTENT_LENGTH", value, -1) )
LABEL_33:
    _exit(1);
  v17 = "POST";
  if ( !storagea )
    goto LABEL_92;
LABEL_46:
  if ( env_set("REQUEST_METHOD", v17, -1)
    || env_set("SERVER_SOFTWARE", (unsigned __int8 *)&byte_81324BF, -1)
    || env_set("SERVER_PROTOCOL", "HTTP/1.0", -1)
    || env_set("SERVER_NAME", "localhost", -1)
    || env_set("REMOTE_ADDR", "127.0.0.1", -1)
    || env_set("GATEWAY_INTERFACE", "CGI/1.1", -1)
    || env_set("SCRIPT_NAME", (unsigned __int8 *)v4, -1)
    || env_set("SCRIPT_FILENAME", (unsigned __int8 *)v4, -1)
    || env_set("PATH_TRANSLATED", (unsigned __int8 *)v4, -1)
    || env_set("REDIRECT_STATUS", (unsigned __int8 *)"1", -1) )
  {
    goto LABEL_33;
  }
  opt = get_opt_(config_options, "protocol.http.user_agent");
  storageb = (unsigned __int8 *)opt->number;
  v19 = *opt->string;
  if ( v19 && (v19 != 32 || storageb[1]) )
  {
    memset(v48, 0, sizeof(v48));
    *(_DWORD *)value = 0;
    if ( terminals.next != &terminals )
    {
      dst = 0;
      prev = terminals.prev;
      elinks_ulongcat(value, (unsigned int *)&dst, *((_DWORD *)terminals.prev + 11), 3u, 0, 0xAu, 0);
      v20 = dst;
      value[(_DWORD)dst] = 120;
      dst = v20 + 1;
      elinks_ulongcat(value, (unsigned int *)&dst, prev[12], 3u, 0, 0xAu, 0);
    }
    v21 = subst_user_agent(storageb, "0.12pre5", system_name, value);
    v22 = v21;
    if ( v21 )
    {
      env_set("HTTP_USER_AGENT", v21, -1);
      mem_free(v22);
    }
  }
  number = get_opt_(config_options, "protocol.http.referer.policy")->number;
  switch ( number )
  {
    case 2:
      p_string = (unsigned __int8 **)get_opt_(config_options, "protocol.http.referer.fake");
LABEL_90:
      env_set("HTTP_REFERER", *p_string, -1);
      break;
    case 3:
      p_string = &conn->referrer->string;
      if ( !p_string )
        break;
      goto LABEL_90;
    case 1:
      v29 = get_uri_string(conn->uri, URI_HTTP_REFERRER);
      v30 = v29;
      if ( v29 )
      {
        env_set("HTTP_REFERER", v29, -1);
        mem_free(v30);
      }
      break;
  }
  env_set("HTTP_ACCEPT", (unsigned __int8 *)"*/*", -1);
  v24 = (unsigned __int8 *)get_opt_(config_options, "protocol.http.accept_language")->number;
  if ( *v24 )
    goto LABEL_84;
  if ( get_opt_(config_options, "protocol.http.accept_ui_language")->number )
  {
    v24 = language_to_iso639(current_language);
LABEL_84:
    env_set((unsigned __int8 *)&byte_81325FF, v24, -1);
  }
  cached = conn->cached;
  if ( cached )
  {
    if ( (*((_BYTE *)cached + 92) & 8) == 0 )
    {
      if ( cached->head )
      {
        last_modified = cached->last_modified;
        if ( last_modified )
        {
          if ( conn->cache_mode > CACHE_MODE_CHECK_IF_MODIFIED )
            goto LABEL_73;
          env_set("HTTP_IF_MODIFIED_SINCE", last_modified, -1);
        }
      }
    }
  }
  if ( conn->cache_mode > CACHE_MODE_CHECK_IF_MODIFIED )
  {
LABEL_73:
    env_set("HTTP_PRAGMA", "no-cache", -1);
    env_set("HTTP_CACHE_CONTROL", "no-cache", -1);
  }
  v27 = send_cookies(conn->uri);
  v28 = v27;
  if ( v27 )
  {
    env_set("HTTP_COOKIE", v27->source, -1);
    done_string(v28);
  }
  if ( dup2(pipe_write[0], 0) < 0 || dup2(pipe_read[1], 1) < 0 )
    _exit(2);
  close_all_non_term_fd();
  *v39 = 0;
  set_cwd((unsigned __int8 *)v4);
  *v39 = 47;
  if ( execl(v4, v4, 0) )
    _exit(3);
  v9 = 0;
end0:
  close(pipe_read[0]);
  close(pipe_read[1]);
  close(pipe_write[0]);
  close(pipe_write[1]);
end1:
  mem_free(v4);
end2:
  abort_connection(conn, (connection_state)__PAIR64__(v9, state.basic));
  return 0;
}
// 8058E68: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080C9570) --------------------------------------------------------
void __usercall add_dir_entry(
        directory_entry *entry@<eax>,
        string *page@<edx>,
        int pathlen@<ecx>,
        unsigned __int8 *dircolor)
{
  size_t v6; // eax
  int v7; // eax
  unsigned __int8 v8; // al
  int v9; // eax
  ssize_t v10; // eax
  const unsigned __int8 *src; // [esp+24h] [ebp-4A4h]
  unsigned __int8 *lnka; // [esp+2Ch] [ebp-49Ch]
  stat st; // [esp+3Ch] [ebp-48Ch] BYREF
  string uri_encoded_name; // [esp+9Ch] [ebp-42Ch] BYREF
  string html_encoded_name; // [esp+A4h] [ebp-424h] BYREF
  unsigned __int8 buf[1024]; // [esp+ACh] [ebp-41Ch] BYREF
  unsigned int v18; // [esp+4ACh] [ebp-1Ch]

  v18 = __readgsdword(0x14u);
  if ( init_string(&html_encoded_name) )
  {
    if ( init_string(&uri_encoded_name) )
    {
      encode_uri_string(&uri_encoded_name, &entry->name[pathlen], -1, 1);
      v6 = strlen((const char *)entry->name);
      add_html_to_string(&html_encoded_name, &entry->name[pathlen], v6 - pathlen);
      src = entry->attrib;
      v7 = strlen((const char *)entry->attrib);
      add_html_to_string(page, src, v7);
      add_to_string(page, "<a href=\"");
      add_string_to_string(page, &uri_encoded_name);
      v8 = *entry->attrib;
      if ( v8 == 100 )
      {
        add_char_to_string(page, 0x2Fu);
        lnka = 0;
      }
      else
      {
        lnka = 0;
        if ( v8 == 108 )
        {
          v10 = readlink((const char *)entry->name, (char *)buf, 0x400u);
          if ( v10 == 1024 || v10 <= 0 )
          {
            lnka = 0;
          }
          else
          {
            buf[v10] = 0;
            lnka = straconcat(" -> ", buf, 0);
          }
          if ( !__xstat64(3, entry->name, &st) && (st.st_mode & 0xF000) == 0x4000 )
            add_char_to_string(page, 0x2Fu);
        }
      }
      add_to_string(page, "\">");
      if ( *entry->attrib == 100 && *dircolor )
        string_concat(page, "<font color=\"", dircolor, "\"><b>", 0);
      add_string_to_string(page, &html_encoded_name);
      done_string(&uri_encoded_name);
      done_string(&html_encoded_name);
      if ( *entry->attrib == 100 && *dircolor )
        add_to_string(page, "</b></font>");
      add_to_string(page, "</a>");
      if ( lnka )
      {
        v9 = strlen((const char *)lnka);
        add_html_to_string(page, lnka, v9);
        mem_free(lnka);
      }
      add_char_to_string(page, 0xAu);
    }
    else
    {
      done_string(&html_encoded_name);
    }
  }
}
// 8058E68: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (080C98A0) --------------------------------------------------------
connection_basic_state *__usercall connection_state_5@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        result = v2,
        basic = S_ERRNO,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080C9930) --------------------------------------------------------
void __cdecl file_protocol_handler(connection *connection)
{
  connection *v1; // ebx
  int v2; // eax
  unsigned __int8 *source; // edi
  connection_basic_state basic; // edi
  int *v5; // eax
  int v6; // ecx
  int syserr; // eax
  directory_entry *v8; // edi
  directory_entry *v9; // ebx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  cache_entry *cache_entry; // eax
  cache_entry *v13; // esi
  option_value *opt; // eax
  int cp_index; // eax
  unsigned __int8 *cp_mime_name; // eax
  int get_hiddena; // [esp+24h] [ebp-54h]
  int *get_hidden; // [esp+24h] [ebp-54h]
  int set_dir_content_type; // [esp+2Ch] [ebp-4Ch]
  size_t set_dir_content_typea; // [esp+2Ch] [ebp-4Ch]
  unsigned __int8 *head; // [esp+30h] [ebp-48h]
  unsigned __int8 *heada; // [esp+30h] [ebp-48h]
  directory_entry *entry; // [esp+34h] [ebp-44h]
  directory_entry *entrya; // [esp+34h] [ebp-44h]
  connection_state state; // [esp+38h] [ebp-40h] BYREF
  string name; // [esp+44h] [ebp-34h] BYREF
  string page; // [esp+4Ch] [ebp-2Ch] BYREF
  unsigned __int8 str[8]; // [esp+54h] [ebp-24h] BYREF
  unsigned int v29; // [esp+5Ch] [ebp-1Ch]

  v1 = connection;
  v29 = __readgsdword(0x14u);
  if ( !get_opt_(cmdline_options, "anonymous")->number
    || !strcmp((const char *)connection->uri->string, byte_8131543) && !isatty(0) )
  {
    if ( !execute_cgi(connection) )
      return;
    if ( !init_string(&name) || !add_uri_to_string(&name, connection->uri, URI_PATH) )
    {
      done_string(&name);
      connection_state_5(S_OUT_OF_MEM, &state.basic);
      abort_connection(connection, state);
      return;
    }
    decode_uri_string(&name);
    if ( name.length <= 0 )
    {
      source = name.source;
    }
    else
    {
      source = name.source;
      if ( name.source[name.length - 1] == 47 )
        goto LABEL_15;
    }
    if ( !file_is_dir(source) )
    {
      read_encoded_file(&state, &name, &page);
      basic = state.basic;
      set_dir_content_type = 0;
      head = 0;
      entry = (directory_entry *)state.syserr;
LABEL_18:
      done_string(&name);
      if ( basic != S_OK )
        goto LABEL_19;
      cache_entry = get_cache_entry(v1->uri);
      v13 = cache_entry;
      v1->cached = cache_entry;
      if ( cache_entry )
      {
        if ( !head )
        {
          add_fragment(cache_entry, 0LL, page.source, page.length);
          v1->from += page.length;
          if ( set_dir_content_type && !v13->head )
          {
            cp_index = get_cp_index("System");
            cp_mime_name = get_cp_mime_name(cp_index);
            heada = straconcat("\r\nContent-Type: text/html; charset=", cp_mime_name, "\r\n", 0);
            if ( !heada )
            {
              connection_state_5(S_OUT_OF_MEM, &state.basic);
              basic = state.basic;
              entry = (directory_entry *)state.syserr;
            }
            if ( v13->head )
              mem_free(v13->head);
            v13->head = heada;
          }
          done_string(&page);
          goto LABEL_19;
        }
        if ( redirect_cache(cache_entry, head, 1, 0) )
        {
LABEL_19:
          abort_connection(v1, (connection_state)__PAIR64__((unsigned int)entry, basic));
          return;
        }
      }
      else if ( !head )
      {
        done_string(&page);
      }
      connection_state_5(S_OUT_OF_MEM, &state.basic);
      basic = state.basic;
      entry = (directory_entry *)state.syserr;
      goto LABEL_19;
    }
    source = name.source;
LABEL_15:
    if ( *source && source[name.length - 1] != 47 )
    {
      head = (_BYTE *)("uri=\"/" + 5);
      connection_state_5(S_OK, &state.basic);
      basic = state.basic;
      set_dir_content_type = 0;
      entry = (directory_entry *)state.syserr;
      goto LABEL_18;
    }
    get_hiddena = get_opt_(config_options, "protocol.file.show_hidden_files")->number;
    v5 = __errno_location();
    *v5 = 0;
    v6 = get_hiddena;
    get_hidden = v5;
    entrya = get_directory_entries(source, v6);
    if ( entrya )
    {
      init_directory_listing(&state, &page, connection->uri);
      if ( state.basic == S_OK )
      {
        set_dir_content_typea = strlen((const char *)source);
        if ( get_opt_(config_options, "document.browse.links.color_dirs")->number )
        {
          opt = get_opt_(config_options, "document.colors.dirs");
          color_to_string(opt->number, str);
        }
        else
        {
          str[0] = 0;
        }
        if ( entrya->name )
        {
          v8 = entrya;
          v9 = entrya + 1;
          do
          {
            add_dir_entry(v8, &page, set_dir_content_typea, str);
            mem_free(v8->attrib);
            v10 = v8->name;
            v8 = v9;
            mem_free(v10);
            v11 = v9->name;
            ++v9;
          }
          while ( v11 );
          v1 = connection;
        }
        mem_free(entrya);
        if ( add_to_string(&page, "</pre>\n<hr/>\n</body>\n</html>\n") )
        {
          connection_state_5(S_OK, &state.basic);
          basic = state.basic;
          syserr = state.syserr;
          goto LABEL_24;
        }
        done_string(&page);
      }
    }
    else
    {
      syserr = *get_hidden;
      basic = S_ERRNO;
      if ( *get_hidden )
        goto LABEL_24;
    }
    connection_state_5(S_OUT_OF_MEM, &state.basic);
    basic = state.basic;
    syserr = state.syserr;
LABEL_24:
    entry = (directory_entry *)syserr;
    set_dir_content_type = 1;
    head = 0;
    goto LABEL_18;
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v2 = -100003;
  }
  else
  {
    assert_failed = 0;
    v2 = -100203;
  }
  abort_connection(connection, (connection_state)(unsigned int)v2);
}

//----- (080C9E40) --------------------------------------------------------
void __cdecl finger_protocol_handler(connection *conn)
{
  bool v1; // zf
  bool v2; // sf
  bool v3; // of

  v3 = __OFSUB__(conn->cache_mode, 2);
  v1 = conn->cache_mode == CACHE_MODE_CHECK_IF_MODIFIED;
  v2 = conn->cache_mode - 2 < 0;
  conn->from = 0LL;
  make_connection(conn->socket, conn->uri, finger_send_request, !(v2 ^ v3 | v1));
}

//----- (080C9E80) --------------------------------------------------------
void __cdecl finger_send_request(socket *socket)
{
  _DWORD *conn; // edi
  int v2; // eax
  unsigned __int16 v3; // di
  const void *v4; // edx
  unsigned int v5; // eax
  size_t v6; // ecx
  int v7; // eax
  unsigned __int8 *v8; // eax
  size_t v9; // [esp+20h] [ebp-38h]
  const void *v10; // [esp+24h] [ebp-34h]
  int v11; // [esp+28h] [ebp-30h]
  unsigned int v12; // [esp+2Ch] [ebp-2Ch]
  string req; // [esp+38h] [ebp-20h] BYREF

  conn = socket->conn;
  if ( !init_string(&req) )
    return;
  if ( !*(_DWORD *)(conn[5] + 12) )
    goto LABEL_10;
  add_char_to_string(&req, 0x20u);
  v2 = conn[5];
  v3 = *(_WORD *)(v2 + 42);
  v4 = *(const void **)(v2 + 12);
  if ( assert_failed )
    goto LABEL_16;
  if ( v4 )
  {
    assert_failed = 0;
    goto LABEL_6;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  v4 = 0;
  if ( assert_failed )
  {
LABEL_16:
    assert_failed = 0;
    goto LABEL_10;
  }
LABEL_6:
  if ( v3 )
  {
    v5 = req.length + 255;
    v11 = v3 + req.length;
    v6 = v11 + 256;
    LOBYTE(v5) = 0;
    LOBYTE(v6) = 0;
    v12 = v5;
    if ( v6 <= v5 )
      goto LABEL_8;
    v9 = v6;
    v10 = v4;
    v8 = (unsigned __int8 *)mem_realloc(req.source, v6);
    if ( v8 )
    {
      req.source = v8;
      memset(&v8[v12], 0, v9 - v12);
      v4 = v10;
LABEL_8:
      if ( req.source )
      {
        memcpy(&req.source[req.length], v4, v3);
        req.source[v11] = 0;
        req.length = v11;
      }
    }
  }
LABEL_10:
  add_crlf_to_string(&req);
  if ( assert_failed )
  {
    assert_failed = 0;
    v7 = -100003;
  }
  else
  {
    assert_failed = 0;
    v7 = 4;
  }
  request_from_socket(
    socket,
    req.source,
    req.length,
    (connection_state)(unsigned int)v7,
    SOCKET_END_ONCLOSE,
    finger_get_response);
  done_string(&req);
}

//----- (080CA060) --------------------------------------------------------
void __cdecl finger_get_response(socket *socket, read_buffer *rb)
{
  connection *conn; // ebx
  cache_entry *cache_entry; // eax
  bool v4; // cf
  int v5; // eax
  int v6; // eax
  ssize_t l; // [esp+2Ch] [ebp-2Ch]

  conn = (connection *)socket->conn;
  cache_entry = get_cache_entry(conn->uri);
  if ( !cache_entry )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      v6 = -100004;
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  conn->cached = cache_entry;
  if ( socket->state == SOCKET_CLOSED )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      v6 = -100000;
LABEL_11:
      abort_connection(conn, (connection_state)(unsigned int)v6);
      return;
    }
LABEL_12:
    assert_failed = 0;
    v6 = -100003;
    goto LABEL_11;
  }
  l = rb->length;
  v4 = __CFADD__(l, conn->received);
  LODWORD(conn->received) += l;
  HIDWORD(conn->received) += (l >> 31) + v4;
  if ( add_fragment(cache_entry, conn->from, rb->data, l) == 1 )
    conn->tries = 0;
  conn->from += l;
  kill_buffer_data(rb, l);
  if ( assert_failed )
  {
    assert_failed = 0;
    v5 = -100003;
  }
  else
  {
    assert_failed = 0;
    v5 = 8;
  }
  read_from_socket(conn->socket, rb, (connection_state)(unsigned int)v5, finger_get_response);
}

//----- (080CA1E0) --------------------------------------------------------
connection_basic_state *__usercall connection_state_6@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080CA270) --------------------------------------------------------
int __usercall parse_psv_resp@<eax>(unsigned __int8 *data@<eax>, int *n@<edx>, int max_value@<ecx>)
{
  unsigned int i; // eax
  unsigned __int8 *v4; // eax
  unsigned __int8 v5; // cl
  int v7; // esi
  int v8; // ecx
  int v9; // ecx
  int v10; // ebx
  unsigned __int8 *v11; // edi

  for ( i = 0; i < 6; ++i )
    n[i] = 0;
  v4 = data;
  if ( *data > 0x1Fu )
  {
    do
      ++v4;
    while ( *v4 > 0x1Fu );
    if ( data != v4 )
    {
      while ( data != --v4 )
      {
        v5 = *v4;
        if ( (unsigned __int8)(*v4 - 48) <= 9u )
        {
          v7 = 5;
LABEL_11:
          if ( (unsigned __int8)(v5 - 48) > 9u )
          {
            v11 = data;
LABEL_20:
            while ( v11 != --v4 )
            {
              v5 = *v4;
              if ( (unsigned __int8)(*v4 - 48) <= 9u )
              {
                --v7;
                data = v11;
                if ( v7 != -1 )
                  goto LABEL_11;
                return 0;
              }
            }
          }
          else
          {
            v8 = n[v7] + v5 - 48;
            n[v7] = v8;
            if ( max_value < v8 )
              return 0;
            v9 = 1;
            while ( data != --v4 )
            {
              if ( (unsigned __int8)(*v4 - 48) > 9u )
              {
                v11 = data;
                goto LABEL_20;
              }
              v9 *= 10;
              v10 = n[v7] + v9 * (*v4 - 48);
              n[v7] = v10;
              if ( v10 > max_value )
                return 0;
            }
          }
          return 6 - v7;
        }
      }
    }
  }
  return 0;
}

//----- (080CA380) --------------------------------------------------------
void __usercall send_cmd(connection *conn@<eax>, string *cmd@<edx>, void *callback@<ecx>, connection_state state)
{
  request_from_socket(conn->socket, cmd->source, cmd->length, state, SOCKET_RETRY_ONCLOSE, (socket_read_T)callback);
  done_string(cmd);
}

//----- (080CA3D0) --------------------------------------------------------
int __usercall ftp_data_connect@<eax>(
        connection *conn@<eax>,
        int pf_0@<edx>,
        sockaddr_storage *sa@<ecx>,
        int size_of_sockaddr)
{
  int v6; // eax
  int v7; // esi
  connection_state state; // [esp+18h] [ebp-20h] BYREF

  if ( conn->data_socket->fd == -1 && (v6 = socket(pf_0, 1, 0), v7 = v6, v6 >= 0) && set_nonblocking_fd(v6) >= 0 )
  {
    set_ip_tos_throughput(v7);
    conn->data_socket->fd = v7;
    connect(v7, (const struct sockaddr *)sa, size_of_sockaddr);
    return 0;
  }
  else
  {
    connection_state_6(S_FTP_ERROR, &state.basic);
    abort_connection(conn, state);
    return -1;
  }
}

//----- (080CA480) --------------------------------------------------------
int __usercall get_ftp_response@<eax>(
        connection *conn@<eax>,
        read_buffer *rb@<edx>,
        int part@<ecx>,
        sockaddr_storage *sa)
{
  _BYTE *v5; // esi
  int *v6; // eax
  int *v7; // edi
  signed int v8; // eax
  unsigned __int8 *v9; // eax
  int v10; // esi
  int v12; // eax
  unsigned __int8 *v13; // eax
  char v14; // dl
  unsigned int v15; // eax
  int length; // [esp+24h] [ebp-54h]
  int response; // [esp+28h] [ebp-50h]
  unsigned __int8 *v20; // [esp+30h] [ebp-48h]
  unsigned __int8 *data; // [esp+34h] [ebp-44h]
  unsigned __int8 *s; // [esp+38h] [ebp-40h]
  int v23; // [esp+3Ch] [ebp-3Ch]
  int n[6]; // [esp+40h] [ebp-38h] BYREF
  int sal; // [esp+58h] [ebp-20h] BYREF
  unsigned __int8 *num_end; // [esp+5Ch] [ebp-1Ch] BYREF

  s = rb->data;
  data = &rb->data[3];
  v20 = &rb->data[1];
  while ( 1 )
  {
    v5 = memchr(s, 10, rb->length);
    if ( !v5 )
      return 0;
    v6 = __errno_location();
    *v6 = 0;
    v7 = v6;
    v8 = strtoul((const char *)s, (char **)&num_end, 10);
    v23 = v8;
    if ( *v7 )
      return -1;
    response = v8;
    if ( v8 <= 99 || data != num_end )
      return -1;
    if ( v8 == 227 && sa )
    {
      if ( parse_psv_resp(data, n, 255) != 6 )
        return -1;
      sa->__ss_align = 0;
      *(_DWORD *)sa->__ss_padding = 0;
      *(_DWORD *)&sa->__ss_padding[4] = 0;
      sa->ss_family = 2;
      sa->__ss_align = _byteswap_ulong((n[2] << 8) + n[3] + (n[1] << 16) + (n[0] << 24));
      *(&sa->ss_family + 1) = __ROR2__(LOWORD(n[5]) + (LOWORD(n[4]) << 8), 8);
      v9 = num_end;
    }
    else
    {
      v9 = data;
      if ( v23 == 229 && sa )
      {
        sal = 28;
        v15 = parse_psv_resp(data, n, 0xFFFF);
        if ( v15 != 1 )
          return -1;
        LOBYTE(v15) = 0;
        do
        {
          *(_DWORD *)((char *)&sa->ss_family + v15) = 0;
          v15 += 4;
        }
        while ( v15 < 0x1C );
        if ( getpeername(conn->socket->fd, (struct sockaddr *)sa, (socklen_t *)&sal) )
          return -1;
        sa->ss_family = 10;
        *(&sa->ss_family + 1) = __ROR2__(n[5], 8);
        v9 = num_end;
      }
    }
    v10 = v5 - s;
    if ( *v9 == 45 )
    {
      length = rb->length;
      if ( length - 5 <= 0 )
        return 0;
      v12 = 0;
      while ( rb->data[v12] != 10 || memcmp(&v20[v12], s, 3u) || *((_BYTE *)&rb[1].done + v12) != 32 )
      {
        if ( rb->length - 5 <= ++v12 )
          return 0;
      }
      v10 = v12 + 1;
      if ( length <= v12 + 1 )
        return 0;
      v13 = &rb->data[v12 + 2];
      if ( rb->data[v10] != 10 )
      {
        while ( length > ++v10 )
        {
          v14 = *v13++;
          if ( v14 == 10 )
            goto LABEL_9;
        }
        return 0;
      }
    }
LABEL_9:
    if ( part != 2 )
    {
      kill_buffer_data(rb, v10 + 1);
      if ( !part && v23 <= 199 )
        continue;
    }
    return response;
  }
}

//----- (080CA700) --------------------------------------------------------
void __usercall ftp_end_request(connection *conn@<eax>, connection_state state@<0:edx, 4:ecx>)
{
  cache_entry *cached; // eax
  int syserr; // [esp+18h] [ebp-20h]

  if ( state.basic == S_OK )
  {
    cached = conn->cached;
    if ( cached )
    {
      syserr = state.syserr;
      normalize_cache_entry(cached, conn->from);
      state.syserr = syserr;
      state.basic = S_OK;
    }
  }
  set_connection_state(conn, state);
  add_keepalive_connection(conn, 600000, 0);
}

//----- (080CA780) --------------------------------------------------------
void __cdecl ftp_data_accept(connection *conn)
{
  _BYTE *info; // esi
  socket *data_socket; // eax
  int fd; // esi
  connection_state v4; // [esp+4h] [ebp-24h]

  info = conn->info;
  if ( assert_failed
    || (assert_failed = (unsigned int)conn->data_socket->fd >> 31) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c",
        errline = 1409,
        elinks_internal("assertion conn->data_socket->fd >= 0 failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  set_connection_timeout(conn);
  set_handlers(conn->data_socket->fd, 0, 0, 0, 0);
  if ( (*((_BYTE *)conn->socket + 36) & 1) != 0 )
  {
    if ( (info[16] & 8) != 0 )
      goto LABEL_5;
  }
  else if ( (info[16] & 4) != 0 )
  {
LABEL_5:
    data_socket = conn->data_socket;
    fd = data_socket->fd;
LABEL_6:
    data_socket->fd = fd;
    set_handlers(fd, (select_handler_T)got_something_from_data_connection, 0, 0, conn);
    return;
  }
  fd = accept(conn->data_socket->fd, 0, 0);
  if ( fd >= 0 )
  {
    close(conn->data_socket->fd);
    data_socket = conn->data_socket;
    goto LABEL_6;
  }
  v4.basic = S_ERRNO;
  v4.syserr = *__errno_location();
  retry_connection(conn, v4);
}

//----- (080CA8D0) --------------------------------------------------------
int __usercall display_dir_entry@<eax>(
        cache_entry *cached@<eax>,
        off_t *pos@<edx>,
        int *tries@<ecx>,
        const ftp_dir_html_format *format,
        ftp_file_info *ftp_info)
{
  string *inited; // edx
  int result; // eax
  mode_t v8; // eax
  struct tm *v9; // eax
  const char *v10; // edx
  int v11; // eax
  int current_time; // [esp+34h] [ebp-94h]
  string string; // [esp+44h] [ebp-84h] BYREF
  time_t when; // [esp+4Ch] [ebp-7Ch] BYREF
  unsigned __int8 date[80]; // [esp+52h] [ebp-76h] BYREF
  unsigned __int8 permissions[10]; // [esp+A2h] [ebp-26h] BYREF
  unsigned int v19; // [esp+ACh] [ebp-1Ch]

  v19 = __readgsdword(0x14u);
  strcpy((char *)permissions, "---------");
  inited = init_string(&string);
  result = -1;
  if ( !inited )
    return result;
  add_char_to_string(&string, ftp_info->type);
  v8 = ftp_info->permissions;
  if ( v8 )
  {
    if ( (v8 & 0x100) != 0 )
      permissions[0] = 114;
    if ( (v8 & 0x80u) != 0 )
      permissions[1] = 119;
    if ( (v8 & 0x40) != 0 )
      permissions[2] = 120;
    if ( (v8 & 0x800) != 0 )
      permissions[2] = (v8 & 0x40) == 0 ? 83 : 115;
    if ( (v8 & 0x20) != 0 )
      permissions[3] = 114;
    if ( (v8 & 0x10) != 0 )
      permissions[4] = 119;
    if ( (v8 & 8) != 0 )
      permissions[5] = 120;
    if ( (v8 & 0x400) != 0 )
      permissions[5] = (v8 & 8) == 0 ? 83 : 115;
    if ( (v8 & 4) != 0 )
      permissions[6] = 114;
    if ( (v8 & 2) != 0 )
      permissions[7] = 119;
    if ( (v8 & 1) != 0 )
      permissions[8] = 120;
    if ( (v8 & 0x200) != 0 )
      permissions[8] = (v8 & 1) == 0 ? 84 : 116;
  }
  add_to_string(&string, permissions);
  add_char_to_string(&string, 0x20u);
  add_to_string(&string, "   1 ftp      ftp ");
  if ( (HIDWORD(ftp_info->size) & ftp_info->size) == -1 )
  {
    add_to_string(&string, "           - ");
    if ( ftp_info->mtime > 0 )
      goto LABEL_5;
  }
  else
  {
    add_format_to_string(&string, "%12lld ", ftp_info->size);
    if ( ftp_info->mtime > 0 )
    {
LABEL_5:
      current_time = time(0);
      when = ftp_info->mtime;
      if ( (*((_BYTE *)ftp_info + 32) & 1) != 0 )
        v9 = localtime(&when);
      else
        v9 = gmtime(&when);
      if ( current_time > when + 15552000 || (v10 = "%b %e %H:%M", current_time < when - 3600) )
        v10 = "%b %e  %Y";
      v11 = strftime((char *)date, 0x50u, v10, v9);
      add_cp_html_to_string(&string, format->libc_codepage, date, v11);
      goto LABEL_10;
    }
  }
  add_to_string(&string, &byte_8134F91);
LABEL_10:
  add_char_to_string(&string, 0x20u);
  if ( ftp_info->type == FTP_FILE_DIRECTORY && format->colorize_dir )
  {
    add_to_string(&string, "<font color=\"");
    add_to_string(&string, format->dircolor);
    add_to_string(&string, "\"><b>");
  }
  add_to_string(&string, "<a href=\"");
  encode_uri_string(&string, ftp_info->name.source, ftp_info->name.length, 0);
  if ( ftp_info->type == FTP_FILE_DIRECTORY )
    add_char_to_string(&string, 0x2Fu);
  add_to_string(&string, "\">");
  add_html_to_string(&string, ftp_info->name.source, ftp_info->name.length);
  add_to_string(&string, "</a>");
  if ( ftp_info->type == FTP_FILE_DIRECTORY && format->colorize_dir )
    add_to_string(&string, "</b></font>");
  if ( ftp_info->symlink.length )
  {
    add_to_string(&string, " -&gt; ");
    add_html_to_string(&string, ftp_info->symlink.source, ftp_info->symlink.length);
  }
  add_char_to_string(&string, 0xAu);
  if ( add_fragment(cached, *pos, string.source, string.length) )
    *tries = 0;
  *pos += string.length;
  done_string(&string);
  return 0;
}

//----- (080CAD20) --------------------------------------------------------
int __usercall ftp_process_dirlist@<eax>(
        cache_entry *cached@<eax>,
        off_t *pos@<edx>,
        unsigned __int8 *buffer@<ecx>,
        int buflen,
        int last,
        int *tries,
        const ftp_dir_html_format *format)
{
  int v7; // ebx
  int v8; // esi
  unsigned __int8 *v10; // edi
  unsigned __int8 *v11; // eax
  int v12; // edx
  int v13; // eax
  int len; // [esp+20h] [ebp-58h]
  ftp_file_info ftp_info; // [esp+30h] [ebp-48h] BYREF
  string string; // [esp+58h] [ebp-20h] BYREF

  v7 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v8 = buflen - v7;
      if ( buflen == v7 )
        return v7;
      *((_BYTE *)&ftp_info + 32) &= ~1u;
      ftp_info.type = FTP_FILE_UNKNOWN;
      v10 = &buffer[v7];
      ftp_info.name.source = (unsigned __int8 *)&delete;
      ftp_info.name.length = 0;
      ftp_info.symlink.source = (unsigned __int8 *)&delete;
      ftp_info.symlink.length = 0;
      ftp_info.size = -1LL;
      ftp_info.mtime = 0;
      ftp_info.permissions = 420;
      v11 = (unsigned __int8 *)memchr(&buffer[v7], 10, buflen - v7);
      if ( v11 )
      {
        v12 = v11 - v10;
        if ( v11 == v10 )
        {
          v8 = 1;
        }
        else
        {
          v8 = v12 + 1;
          if ( *(v11 - 1) == 13 )
            v8 = --v12 + 2;
        }
      }
      else
      {
        if ( v8 <= 0x3FFF && !last )
          return v7;
        v12 = buflen - v7;
      }
      v7 += v8;
      len = v12;
      if ( !parse_ftp_file_info(&ftp_info, v10, v12) )
        break;
      if ( (*ftp_info.name.source != 46
         || ftp_info.name.length != 1 && (ftp_info.name.length != 2 || ftp_info.name.source[1] != 46))
        && display_dir_entry(cached, pos, tries, format, &ftp_info) < 0 )
      {
        return v7;
      }
    }
    if ( !init_string(&string) )
      break;
    if ( !add_html_to_string(&string, v10, len) )
      break;
    if ( !add_char_to_string(&string, 0xAu) )
      break;
    v13 = add_fragment(cached, *pos, string.source, string.length);
    if ( v13 == -1 )
      break;
    *pos += string.length;
    if ( v13 == 1 )
      *tries = 0;
    done_string(&string);
  }
  done_string(&string);
  return -1;
}

//----- (080CAF30) --------------------------------------------------------
void __cdecl got_something_from_data_connection(connection *conn)
{
  char *info; // esi
  int v2; // eax
  char *v3; // edi
  int v4; // eax
  int v5; // eax
  option_value *opt; // eax
  cache_entry *cached; // edi
  cache_entry *cache_entry; // eax
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // eax
  size_t v13; // edi
  connection_state v14; // [esp+4h] [ebp-A4h]
  int v15; // [esp+24h] [ebp-84h]
  int v16; // [esp+28h] [ebp-80h]
  int fd; // [esp+2Ch] [ebp-7Ch]
  unsigned __int8 *data; // [esp+30h] [ebp-78h]
  size_t nbytes; // [esp+34h] [ebp-74h]
  connection_state state; // [esp+38h] [ebp-70h] BYREF
  ftp_file_info ftp_info; // [esp+4Ch] [ebp-5Ch] BYREF
  string string; // [esp+74h] [ebp-34h] BYREF
  ftp_dir_html_format format; // [esp+7Ch] [ebp-2Ch] BYREF
  unsigned int v24; // [esp+8Ch] [ebp-1Ch]

  v24 = __readgsdword(0x14u);
  info = (char *)conn->info;
  if ( assert_failed
    || (assert_failed = (unsigned int)conn->data_socket->fd >> 31) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c",
        errline = 1450,
        elinks_internal("assertion conn->data_socket->fd >= 0 failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  set_connection_timeout(conn);
  if ( !conn->cached )
  {
    cache_entry = get_cache_entry(conn->uri);
    conn->cached = cache_entry;
    if ( !cache_entry )
      goto LABEL_24;
  }
  if ( (info[16] & 1) != 0 )
  {
    format.libc_codepage = get_cp_index("System");
    format.colorize_dir = get_opt_(config_options, "document.browse.links.color_dirs")->number;
    if ( format.colorize_dir )
    {
      opt = get_opt_(config_options, "document.colors.dirs");
      color_to_string(opt->number, format.dircolor);
    }
    if ( (info[16] & 1) != 0 && !conn->from )
    {
      if ( !conn->uri->data )
      {
        connection_state_6(S_FTP_ERROR, &state.basic);
        abort_connection(conn, state);
        return;
      }
      init_directory_listing(&state, &string, conn->uri);
      if ( state.basic != S_OK )
      {
        abort_connection(conn, state);
        return;
      }
      add_fragment(conn->cached, conn->from, string.source, string.length);
      conn->from += string.length;
      done_string(&string);
      if ( (*((_DWORD *)conn->uri + 12) & 0xFFFF00) != 0 )
      {
        *((_BYTE *)&ftp_info + 32) &= ~1u;
        ftp_info.type = FTP_FILE_DIRECTORY;
        ftp_info.name.source = (unsigned __int8 *)&byte_812B444;
        ftp_info.name.length = 2;
        ftp_info.symlink.source = (unsigned __int8 *)&delete;
        ftp_info.symlink.length = 0;
        ftp_info.size = -1LL;
        ftp_info.mtime = 0;
        ftp_info.permissions = 493;
        display_dir_entry(conn->cached, &conn->from, &conn->tries, &format, &ftp_info);
      }
      cached = conn->cached;
      if ( cached->content_type )
      {
        mem_free(cached->content_type);
        cached = conn->cached;
      }
      cached->content_type = stracpy("text/html");
    }
  }
  v2 = *((_DWORD *)info + 3);
  nbytes = 0x4000 - v2;
  data = (unsigned __int8 *)(info + 17);
  v3 = &info[v2 + 17];
  fd = conn->data_socket->fd;
  while ( 1 )
  {
    v4 = read(fd, v3, nbytes);
    if ( v4 != -1 )
      break;
    v5 = *__errno_location();
    if ( v5 != 4 )
      goto LABEL_8;
  }
  v10 = v4;
  if ( v4 < 0 )
  {
    v5 = *__errno_location();
LABEL_8:
    v14.basic = S_ERRNO;
    v14.syserr = v5;
    retry_connection(conn, v14);
    return;
  }
  if ( v4 )
  {
    conn->received += v4;
    if ( (info[16] & 1) == 0 )
    {
      v16 = v4;
      v15 = v4 >> 31;
      if ( add_fragment(conn->cached, conn->from, data, v4) == 1 )
        conn->tries = 0;
      conn->from += __PAIR64__(v15, v16);
      if ( !assert_failed )
        goto LABEL_34;
      goto LABEL_38;
    }
    v12 = ftp_process_dirlist(conn->cached, &conn->from, data, v4 + *((_DWORD *)info + 3), 0, &conn->tries, &format);
    if ( v12 != -1 )
    {
      v13 = *((_DWORD *)info + 3) + v10 - v12;
      *((_DWORD *)info + 3) = v13;
      memmove(data, &data[v12], v13);
      if ( !assert_failed )
      {
LABEL_34:
        assert_failed = 0;
        v11 = 8;
LABEL_35:
        set_connection_state(conn, (connection_state)(unsigned int)v11);
        return;
      }
LABEL_38:
      assert_failed = 0;
      v11 = -100003;
      goto LABEL_35;
    }
LABEL_24:
    if ( assert_failed )
    {
      assert_failed = 0;
      v9 = -100003;
    }
    else
    {
      assert_failed = 0;
      v9 = -100004;
    }
    abort_connection(conn, (connection_state)(unsigned int)v9);
    return;
  }
  if ( ftp_process_dirlist(conn->cached, &conn->from, data, *((_DWORD *)info + 3), 1, &conn->tries, &format) == -1 )
    goto LABEL_24;
  if ( (info[16] & 1) != 0 )
  {
    add_fragment(conn->cached, conn->from, "</pre>\n<hr/>\n</body>\n</html>", 28);
    conn->from += 28LL;
  }
  close_socket(conn->data_socket);
  if ( *((_DWORD *)info + 2) == 1 )
  {
    connection_state_6(S_OK, &state.basic);
    ftp_end_request(conn, state);
  }
  else
  {
    *((_DWORD *)info + 2) = 2;
    connection_state_6(S_TRANS, &state.basic);
    set_connection_state(conn, state);
  }
}
// 812B444: using guessed type char byte_812B444;

//----- (080CB490) --------------------------------------------------------
void __usercall ftp_send_retr_req(connection *conn@<eax>, connection_state state@<0:edx, 4:ecx>)
{
  int syserr; // esi
  connection_basic_state basic; // ebx
  int v4; // edx
  unsigned __int8 *v5; // edi
  char *v6; // eax
  const char *v7; // edx
  signed int v8; // ecx
  size_t v9; // eax
  _BYTE *v10; // eax
  int v11; // edi
  int v12; // eax
  int v13; // eax
  unsigned __int8 v14; // dl
  int v15; // eax
  int v16; // edi
  int v17; // eax
  char *v18; // eax
  int v19; // eax
  int v20; // eax
  unsigned int v21; // eax
  unsigned __int8 *v22; // eax
  int v23; // eax
  int pasv_socket; // eax
  int v25; // eax
  connection_basic_state v26; // edx
  long double v27; // [esp+0h] [ebp-148h]
  long double v28; // [esp+0h] [ebp-148h]
  long double v29; // [esp+0h] [ebp-148h]
  signed int v30; // [esp+28h] [ebp-120h]
  signed int v31; // [esp+28h] [ebp-120h]
  const char *srca; // [esp+2Ch] [ebp-11Ch]
  const char *srcb; // [esp+2Ch] [ebp-11Ch]
  const char *srcc; // [esp+2Ch] [ebp-11Ch]
  const char *src; // [esp+2Ch] [ebp-11Ch]
  socket *ctrl_socket; // [esp+30h] [ebp-118h]
  _BYTE *p; // [esp+38h] [ebp-110h]
  int pa; // [esp+38h] [ebp-110h]
  string *v39; // [esp+3Ch] [ebp-10Ch]
  string *from; // [esp+40h] [ebp-108h]
  long double v41; // [esp+44h] [ebp-104h] BYREF
  string v42; // [esp+54h] [ebp-F4h] BYREF
  string v43; // [esp+5Ch] [ebp-ECh] BYREF
  string string; // [esp+64h] [ebp-E4h] BYREF
  string cmd; // [esp+6Ch] [ebp-DCh] BYREF
  int v46; // [esp+76h] [ebp-D2h]
  __int16 v47; // [esp+7Ah] [ebp-CEh]
  sockaddr_storage addr; // [esp+7Ch] [ebp-CCh] BYREF
  char buf[2]; // [esp+FCh] [ebp-4Ch] BYREF
  __int16 v50; // [esp+FEh] [ebp-4Ah]
  int v51; // [esp+100h] [ebp-48h]
  unsigned int v52; // [esp+12Ch] [ebp-1Ch]

  syserr = state.syserr;
  basic = state.basic;
  LODWORD(v41) = conn;
  v52 = __readgsdword(0x14u);
  if ( init_string(&cmd) )
  {
    v4 = *(_DWORD *)(LODWORD(v41) + 152);
    if ( v4 )
      goto LABEL_3;
    string.source = 0;
    string.length = 0;
    v43.source = 0;
    v43.length = 0;
    v42.source = 0;
    v42.length = 0;
    if ( !*(_DWORD *)(*(_DWORD *)(LODWORD(v41) + 20) + 28) )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
      errline = 680;
      elinks_internal((unsigned __int8 *)&byte_81327E1);
      assert_failed = 0;
      abort_connection((connection *)LODWORD(v41), (connection_state)4294867293LL);
      done_string(&v42);
      goto LABEL_49;
    }
    v10 = mem_calloc(1u, 0x4014u);
    p = v10;
    if ( !v10 )
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v23 = -100003;
      }
      else
      {
        assert_failed = 0;
        v23 = -100004;
      }
      abort_connection((connection *)LODWORD(v41), (connection_state)(unsigned int)v23);
      done_string(&v42);
      goto LABEL_49;
    }
    *(_DWORD *)(LODWORD(v41) + 152) = v10;
    if ( !init_string(&string) || !init_string(&v43) || !init_string(&v42) )
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v19 = -100003;
      }
      else
      {
        assert_failed = 0;
        v19 = -100004;
      }
      abort_connection((connection *)LODWORD(v41), (connection_state)(unsigned int)v19);
      goto LABEL_48;
    }
    v11 = *(_DWORD *)(LODWORD(v41) + 152);
    *(_BYTE *)(v11 + 16) = (4 * ((int)get_opt_(config_options, "protocol.ftp.use_pasv")->tree & 1)) | *(_BYTE *)(v11 + 16) & 0xFB;
    v12 = (8 * (get_opt_(config_options, "protocol.ftp.use_epsv")->number & 1)) | *(_BYTE *)(v11 + 16) & 0xF7;
    *(_BYTE *)(v11 + 16) = v12;
    ctrl_socket = *(socket **)(LODWORD(v41) + 96);
    if ( (*((_BYTE *)ctrl_socket + 36) & 1) != 0 )
    {
      if ( (v12 & 8) != 0 )
      {
        add_to_string(&v43, "EPSV");
LABEL_21:
        add_crlf_to_string(&v43);
        if ( add_uri_to_string(&v42, *(const uri **)(LODWORD(v41) + 20), URI_PATH) )
        {
          decode_uri_string(&v42);
          if ( v42.length > 0 )
          {
            if ( *v42.source == 10 || (v13 = 0, *v42.source == 13) )
            {
LABEL_69:
              v26 = S_BAD_URL;
LABEL_70:
              connection_state_6(v26, (connection_basic_state *)&v41 + 1);
              v28 = v41;
              abort_connection((connection *)LODWORD(v41), *(connection_state *)((char *)&v28 + 4));
LABEL_48:
              done_string(&v42);
LABEL_49:
              done_string(&v43);
              done_string(&string);
              done_string(&cmd);
              return;
            }
            while ( ++v13 < v42.length )
            {
              v14 = v42.source[v13];
              if ( v14 == 13 || v14 == 10 )
                goto LABEL_69;
            }
          }
          v15 = *(_DWORD *)(LODWORD(v41) + 20);
          if ( (*(_DWORD *)(v15 + 48) & 0xFFFF00) == 0
            || *(_BYTE *)(*(unsigned __int16 *)(v15 + 49) + *(_DWORD *)(v15 + 28) - 1) == 47 )
          {
            p[16] |= 1u;
            *(_DWORD *)p = 4;
            if ( !add_to_string(&string, "TYPE A")
              || !add_crlf_to_string(&string)
              || !add_string_to_string(&string, &v43)
              || !add_to_string(&string, "CWD ")
              || !add_string_to_string(&string, &v42)
              || !add_crlf_to_string(&string)
              || !add_to_string(&string, "LIST")
              || !add_crlf_to_string(&string) )
            {
LABEL_80:
              v26 = S_OUT_OF_MEM;
              goto LABEL_70;
            }
            *(_DWORD *)(LODWORD(v41) + 40) = 0;
            *(_DWORD *)(LODWORD(v41) + 44) = 0;
LABEL_43:
            *((_DWORD *)p + 1) = *(_DWORD *)p;
            v18 = (char *)mem_realloc(p, string.length + 16404);
            if ( v18 )
            {
              *(_DWORD *)(LODWORD(v41) + 152) = v18;
              memcpy(v18 + 16401, string.source, string.length + 1);
              done_string(&v42);
              done_string(&v43);
              done_string(&string);
              v4 = *(_DWORD *)(LODWORD(v41) + 152);
LABEL_3:
              v5 = (unsigned __int8 *)(v4 + 16401);
              v6 = strchr((const char *)(v4 + 16401), 10);
              if ( !v6 )
              {
                add_to_string(&cmd, v5);
                goto LABEL_11;
              }
              v7 = v6 + 1;
              if ( !assert_failed )
              {
                v8 = v7 - (const char *)v5;
                if ( v5 && v8 >= 0 )
                {
                  assert_failed = 0;
                  goto LABEL_9;
                }
                srca = v6 + 1;
                v30 = v7 - (const char *)v5;
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                errline = 255;
                elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                v7 = srca;
                v8 = v30;
                if ( !assert_failed )
                {
LABEL_9:
                  if ( v8 )
                  {
                    pa = v8 + cmd.length;
                    v20 = v8 + cmd.length + 256;
                    LOBYTE(v20) = 0;
                    from = (string *)v20;
                    v21 = cmd.length + 255;
                    LOBYTE(v21) = 0;
                    v39 = (string *)v21;
                    if ( (unsigned int)from > v21 )
                    {
                      src = v7;
                      v31 = v8;
                      v22 = (unsigned __int8 *)mem_realloc(cmd.source, (size_t)from);
                      v7 = src;
                      if ( !v22 )
                        goto LABEL_10;
                      cmd.source = v22;
                      memset(&v22[(_DWORD)v39], 0, (char *)from - (char *)v39);
                      v8 = v31;
                      v7 = src;
                    }
                    if ( cmd.source )
                    {
                      srcc = v7;
                      memcpy(&cmd.source[cmd.length], v5, v8);
                      cmd.source[pa] = 0;
                      v7 = srcc;
                      cmd.length = pa;
                    }
                  }
LABEL_10:
                  srcb = v7;
                  v9 = strlen(v7);
                  memmove(v5, srcb, v9 + 1);
LABEL_11:
                  send_cmd((connection *)LODWORD(v41), &cmd, ftp_retr_file, (connection_state)__PAIR64__(syserr, basic));
                  return;
                }
              }
              assert_failed = 0;
              goto LABEL_10;
            }
            goto LABEL_80;
          }
          p[16] &= ~1u;
          *(_DWORD *)p = 3;
          if ( add_to_string(&string, "TYPE I") )
          {
            if ( add_crlf_to_string(&string) && add_string_to_string(&string, &v43) )
            {
              v16 = *(_DWORD *)(LODWORD(v41) + 40);
              if ( *(_QWORD *)(LODWORD(v41) + 40)
                || (v17 = *(_DWORD *)(LODWORD(v41) + 16), v16 = *(_DWORD *)(v17 + 76), *(__int64 *)(v17 + 76) > 0) )
              {
                if ( !add_to_string(&string, "REST ")
                  || !add_long_to_string(&string, v16)
                  || !add_crlf_to_string(&string) )
                {
                  goto LABEL_81;
                }
                p[16] |= 2u;
                ++*(_DWORD *)p;
              }
              if ( add_to_string(&string, "RETR ") && add_string_to_string(&string, &v42) && add_crlf_to_string(&string) )
                goto LABEL_43;
            }
          }
        }
LABEL_81:
        connection_state_6(S_OUT_OF_MEM, (connection_basic_state *)&v41 + 1);
        v29 = v41;
        abort_connection((connection *)LODWORD(v41), *(connection_state *)((char *)&v29 + 4));
        goto LABEL_48;
      }
      memset(&addr, 0, sizeof(addr));
      pasv_socket = get_pasv_socket(ctrl_socket, &addr);
      if ( pasv_socket >= 0 )
      {
        **(_DWORD **)(LODWORD(v41) + 100) = pasv_socket;
        inet_ntop(10, addr.__ss_padding, buf, 0x2Eu);
        add_to_string(&v43, "EPRT |2|");
        add_to_string(&v43, (const unsigned __int8 *)buf);
        add_char_to_string(&v43, 0x7Cu);
        add_long_to_string(&v43, (unsigned __int16)__ROR2__(*(&addr.ss_family + 1), 8));
        add_char_to_string(&v43, 0x7Cu);
        goto LABEL_21;
      }
    }
    else
    {
      if ( (v12 & 4) != 0 )
      {
        add_to_string(&v43, "PASV");
        goto LABEL_21;
      }
      v46 = 0;
      v47 = 0;
      v25 = get_pasv_socket(ctrl_socket, (sockaddr_storage *)buf);
      if ( v25 >= 0 )
      {
        v46 = v51;
        v47 = v50;
        **(_DWORD **)(LODWORD(v41) + 100) = v25;
        add_to_string(&v43, "PORT ");
        add_long_to_string(&v43, (unsigned __int8)v46);
        add_char_to_string(&v43, 0x2Cu);
        add_long_to_string(&v43, BYTE1(v46));
        add_char_to_string(&v43, 0x2Cu);
        add_long_to_string(&v43, BYTE2(v46));
        add_char_to_string(&v43, 0x2Cu);
        add_long_to_string(&v43, HIBYTE(v46));
        add_char_to_string(&v43, 0x2Cu);
        add_long_to_string(&v43, (unsigned __int8)v47);
        add_char_to_string(&v43, 0x2Cu);
        add_long_to_string(&v43, HIBYTE(v47));
        goto LABEL_21;
      }
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
    errline = 706;
    elinks_internal("Ftp data socket failure");
    assert_failed = 0;
    abort_connection((connection *)LODWORD(v41), (connection_state)4294867293LL);
    goto LABEL_48;
  }
  connection_state_6(S_OUT_OF_MEM, (connection_basic_state *)&v41 + 1);
  v27 = v41;
  abort_connection((connection *)LODWORD(v41), *(connection_state *)((char *)&v27 + 4));
}

//----- (080CC150) --------------------------------------------------------
void __cdecl ftp_protocol_handler(connection *conn)
{
  connection_state v1; // 0:edx.8

  if ( has_keepalive_connection(conn) )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v1.basic = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v1.basic = S_SENT;
    }
    v1.syserr = 0;
    ftp_send_retr_req(conn, v1);
  }
  else
  {
    make_connection(conn->socket, conn->uri, ftp_login, conn->cache_mode > CACHE_MODE_CHECK_IF_MODIFIED);
  }
}

//----- (080CC1E0) --------------------------------------------------------
void __cdecl ftp_got_final_response(socket *socket, read_buffer *rb)
{
  connection *conn; // ebx
  _DWORD *info; // edi
  int ftp_response; // eax
  int v5; // ecx
  int syserr; // edx
  cache_entry *cached; // eax
  int v8; // eax
  int v9; // eax
  connection_basic_state v10; // edx
  connection_state state; // [esp+28h] [ebp-20h] BYREF

  conn = (connection *)socket->conn;
  info = conn->info;
  ftp_response = get_ftp_response(conn, rb, 0, 0);
  if ( ftp_response == -1 )
  {
    v10 = S_FTP_ERROR;
    goto LABEL_26;
  }
  if ( !ftp_response )
  {
    if ( conn->state.basic == S_TRANS )
    {
      syserr = conn->state.syserr;
      v5 = 8;
    }
    else
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v5 = -100003;
      }
      else
      {
        assert_failed = 0;
        v5 = 6;
      }
      syserr = 0;
    }
    read_from_socket(conn->socket, rb, (connection_state)__PAIR64__(syserr, v5), ftp_got_final_response);
    return;
  }
  if ( ftp_response == 450 || ftp_response > 549 )
  {
    cached = conn->cached;
    if ( cached || (cached = get_cache_entry(conn->uri), (conn->cached = cached) != 0) )
    {
      if ( redirect_cache(cached, (unsigned __int8 *)"/", 1, 0) )
      {
        if ( assert_failed )
        {
          assert_failed = 0;
          v8 = -100003;
        }
        else
        {
          assert_failed = 0;
          v8 = -100000;
        }
        abort_connection(conn, (connection_state)(unsigned int)v8);
        return;
      }
    }
    v10 = S_OUT_OF_MEM;
LABEL_26:
    connection_state_6(v10, &state.basic);
    abort_connection(conn, state);
    return;
  }
  if ( ftp_response > 399 )
  {
    v10 = S_FTP_FILE_ERROR;
    goto LABEL_26;
  }
  if ( info[2] == 2 )
  {
    connection_state_6(S_OK, &state.basic);
    ftp_end_request(conn, state);
  }
  else
  {
    info[2] = 1;
    if ( conn->state.basic != S_TRANS )
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v9 = -100003;
      }
      else
      {
        assert_failed = 0;
        v9 = 6;
      }
      set_connection_state(conn, (connection_state)(unsigned int)v9);
    }
  }
}

//----- (080CC430) --------------------------------------------------------
void __cdecl ftp_retr_file(socket *socket, read_buffer *rb)
{
  connection *conn; // ebx
  _BYTE *info; // esi
  int v4; // eax
  int v5; // edi
  int v6; // edx
  int v7; // eax
  int ftp_response; // eax
  int length; // esi
  unsigned __int8 v10; // dl
  int v11; // ecx
  int v12; // eax
  int v13; // eax
  unsigned __int8 *v14; // edx
  unsigned __int8 v15; // cl
  int fd; // eax
  int v17; // eax
  connection_basic_state v18; // edx
  progress *progress; // eax
  int start; // edx
  int start_high; // ecx
  char *v22; // eax
  char *v23; // edx
  char *v24; // esi
  long double v25; // fst7
  int v26; // ecx
  __int64 v27; // rax
  unsigned __int8 *v28; // edx
  char v29; // cl
  int *v30; // eax
  int *v31; // esi
  unsigned __int8 v32; // [esp+2Fh] [ebp-D9h]
  char *haystack; // [esp+3Ch] [ebp-CCh]
  int v34; // [esp+40h] [ebp-C8h]
  int v35; // [esp+40h] [ebp-C8h]
  connection_state state; // [esp+58h] [ebp-B0h] BYREF
  char *endptr; // [esp+68h] [ebp-A0h] BYREF
  sockaddr_storage sa; // [esp+6Ch] [ebp-9Ch] BYREF
  unsigned int v39; // [esp+ECh] [ebp-1Ch]
  connection_state v40; // 0:edx.8

  v39 = __readgsdword(0x14u);
  conn = (connection *)socket->conn;
  info = conn->info;
  if ( *(int *)info <= 1 )
  {
    ftp_response = get_ftp_response((connection *)socket->conn, rb, 2, 0);
    if ( ftp_response == -1 )
      goto LABEL_41;
    if ( !ftp_response )
    {
      connection_state_6(S_GETH, &state.basic);
      read_from_socket(conn->socket, rb, state, ftp_retr_file);
      return;
    }
    if ( (unsigned int)(ftp_response - 100) > 0x63
      || (info[16] & 1) != 0
      || (HIDWORD(conn->est_length) & conn->est_length) != -1 )
    {
LABEL_32:
      fd = conn->data_socket->fd;
      if ( fd != -1 )
      {
        set_handlers(fd, (select_handler_T)ftp_data_accept, 0, 0, conn);
        ftp_got_final_response(socket, rb);
        return;
      }
      goto LABEL_41;
    }
    length = rb->length;
    haystack = (char *)rb->data;
    v34 = length - 1;
    if ( length > 0 )
    {
      v10 = rb->data[0];
      if ( v10 != 10 )
      {
        v11 = 0;
        v12 = 0;
        do
        {
          if ( v10 == 40 )
            v11 = v12;
          if ( length <= ++v12 )
            break;
          v10 = haystack[v12];
        }
        while ( v10 != 10 );
        if ( v11 )
        {
          v34 = length - 1;
          if ( v11 != length - 1 )
          {
            v13 = v11 + 1;
            v35 = v11 + 1;
            if ( (unsigned __int8)(rb->data[v11 + 1] - 48) <= 9u )
            {
              v14 = &rb->data[v11];
              if ( length > v13 )
              {
                while ( length > ++v13 )
                {
                  v15 = v14[2];
                  ++v14;
                  if ( (unsigned __int8)(v15 - 48) > 9u )
                  {
                    v28 = &rb->data[v13];
                    if ( *v28 == 32 )
                    {
                      do
                      {
                        if ( length <= ++v13 )
                          break;
                        v29 = *++v28;
                      }
                      while ( v29 == 32 );
                    }
                    if ( length >= v13 + 4 && !c_strncasecmp(&haystack[v13], "byte", 4u) )
                    {
                      v30 = __errno_location();
                      *v30 = 0;
                      v31 = v30;
                      LODWORD(v27) = strtol(&haystack[v35], 0, 10);
                      if ( !*v31 )
                      {
                        v26 = 0;
                        v27 = (int)v27;
                        goto LABEL_79;
                      }
                    }
                    goto LABEL_32;
                  }
                }
              }
            }
            goto LABEL_32;
          }
        }
        else
        {
          v34 = length - 1;
        }
      }
    }
    v32 = rb->data[v34];
    rb->data[v34] = 0;
    v22 = strstr(haystack, "kbytes");
    rb->data[v34] = v32;
    if ( !v22 )
      goto LABEL_32;
    v23 = v22 - 2;
    if ( haystack <= v22 - 2 )
    {
      if ( *(v22 - 2) == 32 )
      {
LABEL_66:
        v24 = v23 + 1;
        v25 = strtod(v23 + 1, &endptr);
        if ( v24 != endptr )
        {
          v26 = 1;
          v27 = (__int64)(v25 * 1024.0);
LABEL_79:
          if ( v27 > 0 )
          {
            if ( v26 )
              v27 += conn->progress->start;
            conn->est_length = v27;
          }
        }
        goto LABEL_32;
      }
      while ( haystack <= --v23 )
      {
        if ( *v23 == 32 )
          goto LABEL_66;
      }
    }
    if ( *v23 != 32 )
      goto LABEL_32;
    goto LABEL_66;
  }
  v4 = get_ftp_response(conn, rb, 0, &sa);
  v5 = v4;
  if ( v4 == -1 )
  {
LABEL_41:
    v18 = S_FTP_ERROR;
    goto LABEL_42;
  }
  if ( v4 )
  {
    if ( v4 == 227 )
    {
      if ( ftp_data_connect(conn, 2, &sa, 16) )
        return;
    }
    else if ( v4 == 229 && ftp_data_connect(conn, 10, &sa, 28) )
    {
      return;
    }
    v6 = *(_DWORD *)info - 1;
    v7 = *((_DWORD *)info + 1) - v6;
    *(_DWORD *)info = v6;
    if ( v7 == 2 )
    {
      if ( v5 <= 399 )
        goto LABEL_10;
      v18 = S_FTP_PORT;
    }
    else
    {
      if ( v7 != 3 )
      {
        if ( v7 != 1 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c";
          errline = 1018;
          elinks_internal("WHAT???");
        }
        goto LABEL_10;
      }
      if ( v5 <= 399 )
      {
        if ( (info[16] & 2) != 0 )
        {
          progress = conn->progress;
          if ( v5 == 350 )
          {
            start = progress->start;
            start_high = HIDWORD(progress->start);
            LODWORD(conn->from) = start;
            HIDWORD(conn->from) = start_high;
          }
          else
          {
            start = conn->from;
            start_high = HIDWORD(conn->from);
          }
          if ( progress->start >= 0 )
          {
            LODWORD(progress->seek) = start;
            HIDWORD(progress->seek) = start_high;
            progress = conn->progress;
            start = conn->from;
            start_high = HIDWORD(conn->from);
          }
          LODWORD(progress->start) = start;
          HIDWORD(progress->start) = start_high;
        }
        goto LABEL_10;
      }
      v18 = S_FTP_NO_FILE;
      if ( (info[16] & 1) == 0 )
      {
        LODWORD(conn->from) = 0;
        HIDWORD(conn->from) = 0;
LABEL_10:
        if ( assert_failed )
        {
          assert_failed = 0;
          v40.basic = S_INTERNAL;
        }
        else
        {
          assert_failed = 0;
          v40.basic = S_GETH;
        }
        v40.syserr = 0;
        ftp_send_retr_req(conn, v40);
        return;
      }
    }
LABEL_42:
    connection_state_6(v18, &state.basic);
    abort_connection(conn, state);
    return;
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v17 = -100003;
  }
  else
  {
    assert_failed = 0;
    v17 = 6;
  }
  read_from_socket(conn->socket, rb, (connection_state)(unsigned int)v17, ftp_retr_file);
}

//----- (080CCA60) --------------------------------------------------------
void __usercall prompt_username_pw(connection *conn@<eax>)
{
  cache_entry *cached; // esi
  int v3; // eax
  connection_state state; // [esp+28h] [ebp-10h] BYREF

  cached = conn->cached;
  if ( cached || (cached = get_cache_entry(conn->uri), (conn->cached = cached) != 0) )
  {
    if ( cached->content_type )
    {
      mem_free(cached->content_type);
      cached = conn->cached;
    }
    cached->content_type = stracpy("text/html");
    if ( conn->cached->content_type )
    {
      add_auth_entry(conn->uri, (unsigned __int8 *)&realm, 0, 0, 0);
      if ( !assert_failed )
      {
        assert_failed = 0;
        v3 = -100000;
        goto LABEL_7;
      }
    }
    else if ( !assert_failed )
    {
      assert_failed = 0;
      v3 = -100004;
      goto LABEL_7;
    }
    assert_failed = 0;
    v3 = -100003;
LABEL_7:
    abort_connection(conn, (connection_state)(unsigned int)v3);
    return;
  }
  connection_state_6(S_OUT_OF_MEM, &state.basic);
  abort_connection(conn, state);
}

//----- (080CCB80) --------------------------------------------------------
void __cdecl ftp_pass_info(socket *socket, read_buffer *rb)
{
  connection *conn; // ebx
  int ftp_response; // eax
  int v4; // eax
  connection_state state; // [esp+28h] [ebp-10h] BYREF
  connection_state v6; // 0:edx.8

  conn = (connection *)socket->conn;
  ftp_response = get_ftp_response(conn, rb, 0, 0);
  if ( ftp_response == -1 )
  {
    connection_state_6(S_FTP_ERROR, &state.basic);
    abort_connection(conn, state);
  }
  else if ( ftp_response )
  {
    if ( ftp_response > 499 || ftp_response == 332 )
    {
      prompt_username_pw(conn);
    }
    else if ( ftp_response > 399 )
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v4 = -100003;
      }
      else
      {
        assert_failed = 0;
        v4 = -100301;
      }
      abort_connection(conn, (connection_state)(unsigned int)v4);
    }
    else
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v6.basic = S_INTERNAL;
      }
      else
      {
        assert_failed = 0;
        v6.basic = S_GETH;
      }
      v6.syserr = 0;
      ftp_send_retr_req(conn, v6);
    }
  }
  else
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      ftp_response = -100003;
    }
    else
    {
      assert_failed = 0;
      LOBYTE(ftp_response) = 5;
    }
    read_from_socket(conn->socket, rb, (connection_state)(unsigned int)ftp_response, ftp_pass_info);
  }
}

//----- (080CCD00) --------------------------------------------------------
void __cdecl ftp_login(socket *socket)
{
  connection *conn; // ebx
  auth_entry *auth; // edi
  uri *uri; // eax
  unsigned __int16 v4; // dx
  int v5; // eax
  unsigned __int8 *user; // eax
  int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // edi
  int v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+10h] [ebp-38h]
  unsigned __int16 v14; // [esp+14h] [ebp-34h]
  unsigned int v15; // [esp+14h] [ebp-34h]
  unsigned __int8 *src; // [esp+18h] [ebp-30h]
  size_t n; // [esp+1Ch] [ebp-2Ch]
  string cmd; // [esp+28h] [ebp-20h] BYREF

  conn = (connection *)socket->conn;
  auth = find_auth(conn->uri);
  if ( init_string(&cmd) )
  {
    add_to_string(&cmd, "USER ");
    uri = conn->uri;
    v4 = *((_WORD *)uri + 21);
    if ( !v4 )
    {
      if ( auth && (*((_BYTE *)auth + 112) & 2) != 0 )
        add_to_string(&cmd, auth->user);
      else
        add_to_string(&cmd, "anonymous");
      goto LABEL_6;
    }
    user = uri->user;
    src = user;
    if ( !assert_failed )
    {
      if ( user )
      {
        assert_failed = 0;
LABEL_13:
        n = v4;
        v7 = cmd.length + v4;
        v8 = cmd.length + 255;
        LOBYTE(v8) = 0;
        v9 = (cmd.length + n + 256) & 0xFFFFFF00;
        if ( v9 <= v8 )
          goto LABEL_14;
        v15 = v8;
        v13 = v7;
        v11 = (unsigned __int8 *)mem_realloc(cmd.source, (cmd.length + n + 256) & 0xFFFFFF00);
        if ( v11 )
        {
          cmd.source = v11;
          memset(&v11[v15], 0, v9 - v15);
          v7 = v13;
LABEL_14:
          if ( cmd.source )
          {
            v12 = v7;
            memcpy(&cmd.source[cmd.length], src, n);
            cmd.source[v12] = 0;
            cmd.length = v12;
          }
        }
LABEL_6:
        add_crlf_to_string(&cmd);
        if ( assert_failed )
        {
          assert_failed = 0;
          v5 = -100003;
        }
        else
        {
          assert_failed = 0;
          v5 = 4;
        }
        send_cmd(conn, &cmd, ftp_got_info, (connection_state)(unsigned int)v5);
        return;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      v14 = v4;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      v4 = v14;
      if ( !assert_failed )
        goto LABEL_13;
    }
    assert_failed = 0;
    goto LABEL_6;
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v10 = -100003;
  }
  else
  {
    assert_failed = 0;
    v10 = -100004;
  }
  abort_connection(conn, (connection_state)(unsigned int)v10);
}

//----- (080CCF60) --------------------------------------------------------
void __cdecl ftp_got_user_info(socket *socket, read_buffer *rb)
{
  connection *conn; // ebx
  int ftp_response; // eax
  auth_entry *auth; // edi
  uri *uri; // eax
  unsigned __int16 v6; // dx
  option_value *opt; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 *password; // eax
  int v11; // ecx
  unsigned int v12; // edx
  unsigned int v13; // edi
  unsigned __int8 *v14; // eax
  int v15; // [esp+28h] [ebp-40h]
  int v16; // [esp+28h] [ebp-40h]
  unsigned __int16 v17; // [esp+2Ch] [ebp-3Ch]
  unsigned int v18; // [esp+2Ch] [ebp-3Ch]
  unsigned __int8 *src; // [esp+30h] [ebp-38h]
  size_t n; // [esp+34h] [ebp-34h]
  connection_state state; // [esp+38h] [ebp-30h] BYREF
  string string; // [esp+48h] [ebp-20h] BYREF

  conn = (connection *)socket->conn;
  ftp_response = get_ftp_response(conn, rb, 0, 0);
  if ( ftp_response == -1 )
  {
    connection_state_6(S_FTP_ERROR, &state.basic);
    abort_connection(conn, state);
    return;
  }
  if ( !ftp_response )
  {
    read_from_socket(conn->socket, rb, conn->state, ftp_got_user_info);
    return;
  }
  if ( ftp_response > 499 || ftp_response == 332 )
    goto LABEL_16;
  if ( ftp_response > 399 )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      v9 = -100301;
LABEL_19:
      abort_connection(conn, (connection_state)(unsigned int)v9);
      return;
    }
LABEL_32:
    assert_failed = 0;
    v9 = -100003;
    goto LABEL_19;
  }
  if ( ftp_response == 230 )
  {
    connection_state_6(S_GETH, &state.basic);
    ftp_send_retr_req(conn, state);
    return;
  }
  auth = find_auth(conn->uri);
  if ( !init_string(&string) )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      v9 = -100004;
      goto LABEL_19;
    }
    goto LABEL_32;
  }
  add_to_string(&string, "PASS ");
  uri = conn->uri;
  v6 = *((_WORD *)uri + 22);
  if ( v6 )
  {
    password = uri->password;
    src = password;
    if ( !assert_failed )
    {
      if ( password )
      {
        assert_failed = 0;
        goto LABEL_27;
      }
      v17 = v6;
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      v6 = v17;
      if ( !assert_failed )
      {
LABEL_27:
        n = v6;
        v11 = string.length + v6;
        v12 = string.length + 255;
        LOBYTE(v12) = 0;
        v13 = (string.length + n + 256) & 0xFFFFFF00;
        if ( v13 > v12 )
        {
          v18 = v12;
          v16 = v11;
          v14 = (unsigned __int8 *)mem_realloc(string.source, (string.length + n + 256) & 0xFFFFFF00);
          if ( !v14 )
            goto LABEL_12;
          string.source = v14;
          memset(&v14[v18], 0, v13 - v18);
          v11 = v16;
        }
        if ( string.source )
        {
          v15 = v11;
          memcpy(&string.source[string.length], src, n);
          string.source[v15] = 0;
          string.length = v15;
        }
        goto LABEL_12;
      }
    }
    assert_failed = 0;
    goto LABEL_12;
  }
  if ( auth && (*((_BYTE *)auth + 112) & 2) != 0 )
  {
    if ( !*((_WORD *)uri + 21)
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/ftp.c",
          errline = 303,
          !elinks_strlcasecmp(auth->user, 0xFFFFFFFF, uri->user, *((unsigned __int16 *)uri + 21), 1)) )
    {
      add_to_string(&string, auth->password);
      goto LABEL_12;
    }
LABEL_16:
    prompt_username_pw(conn);
    return;
  }
  opt = get_opt_(config_options, "protocol.ftp.anon_passwd");
  add_to_string(&string, opt->string);
LABEL_12:
  add_crlf_to_string(&string);
  if ( assert_failed )
  {
    assert_failed = 0;
    v8 = -100003;
  }
  else
  {
    assert_failed = 0;
    v8 = 5;
  }
  send_cmd(conn, &string, ftp_pass_info, (connection_state)(unsigned int)v8);
}

//----- (080CD330) --------------------------------------------------------
void __cdecl ftp_got_info(socket *socket, read_buffer *rb)
{
  connection *conn; // ebx
  int ftp_response; // eax
  int v4; // eax
  connection_state state; // [esp+28h] [ebp-20h] BYREF

  conn = (connection *)socket->conn;
  ftp_response = get_ftp_response(conn, rb, 0, 0);
  if ( ftp_response == -1 )
  {
    connection_state_6(S_FTP_ERROR, &state.basic);
    abort_connection(conn, state);
  }
  else if ( ftp_response )
  {
    if ( ftp_response == 220 )
    {
      ftp_got_user_info(socket, rb);
    }
    else
    {
      if ( assert_failed )
      {
        assert_failed = 0;
        v4 = -100003;
      }
      else
      {
        assert_failed = 0;
        v4 = -100301;
      }
      retry_connection(conn, (connection_state)(unsigned int)v4);
    }
  }
  else
  {
    read_from_socket(conn->socket, rb, conn->state, ftp_got_info);
  }
}

//----- (080CD430) --------------------------------------------------------
ftp_file_info *__cdecl parse_ftp_winnt_response(ftp_file_info *info, unsigned __int8 *src, int len)
{
  ftp_file_info *v3; // ebx
  unsigned __int8 *v5; // ecx
  unsigned __int8 v6; // bl
  int v7; // esi
  int v8; // eax
  int v9; // eax
  unsigned __int8 *v10; // edx
  unsigned __int8 *i; // eax
  unsigned __int8 *v12; // edx
  char v13; // cl
  unsigned __int8 *j; // eax
  char v15; // dl
  unsigned __int8 *v16; // ecx
  __int64 v17; // rax
  __int64 v18; // [esp+10h] [ebp-68h]
  __int64 v19; // [esp+10h] [ebp-68h]
  unsigned __int8 *v20; // [esp+24h] [ebp-54h]
  tm mtime; // [esp+34h] [ebp-44h] BYREF

  v3 = info;
  if ( len > 39 )
  {
    v20 = &src[len];
    info->name.source = src + 39;
    info->name.length = v20 - src - 39;
    memset(&mtime, 0, sizeof(mtime));
    mtime.tm_isdst = -1;
    v5 = src;
    if ( v20 <= src || (unsigned __int8)(*src - 48) > 9u )
    {
      v7 = -1;
    }
    else
    {
      v6 = *src;
      v18 = 0LL;
      do
      {
        v18 = 10 * v18 + v6 - 48;
        if ( v20 <= ++v5 )
          break;
        v6 = *v5;
      }
      while ( (unsigned __int8)(*v5 - 48) <= 9u );
      v3 = info;
      src = v5;
      v7 = v18;
      if ( v18 > 12 || v18 <= 0 )
        v7 = -1;
    }
    if ( v20 > v5 + 2 )
    {
      mtime.tm_mon = v7;
      if ( *v5 == 45 )
      {
        src = v5 + 1;
        v8 = parse_day((const unsigned __int8 **)&src, v20);
        if ( v20 > src + 2 )
        {
          mtime.tm_mday = v8;
          if ( *src == 45 )
          {
            ++src;
            v9 = parse_year((const unsigned __int8 **)&src, v20);
            v10 = src;
            mtime.tm_year = v9;
            if ( v20 > src && v9 != -1 )
            {
              while ( *v10 == 32 )
              {
                src = ++v10;
                if ( v20 <= v10 )
                  return 0;
              }
              if ( parse_time((const unsigned __int8 **)&src, &mtime, v20) )
              {
                v3->mtime = mktime(&mtime);
                for ( i = src; ; src = i )
                {
                  v12 = i;
                  if ( v20 <= i )
                    break;
                  v13 = *i++;
                  if ( v13 == 32 )
                    break;
                }
                for ( j = v12; v20 > j; src = j )
                {
                  v15 = *j++;
                  if ( v15 != 32 )
                  {
                    if ( v15 == 60 )
                    {
                      v3->type = FTP_FILE_DIRECTORY;
                      v3->permissions = 493;
                    }
                    else if ( (unsigned __int8)(v15 - 48) > 9u )
                    {
                      v3->type = FTP_FILE_UNKNOWN;
                    }
                    else
                    {
                      v3->type = FTP_FILE_PLAINFILE;
                      v16 = src;
                      v19 = 0LL;
                      while ( v20 > v16 && (unsigned __int8)(*v16 - 48) <= 9u )
                        v19 = 10 * v19 + *v16++ - 48;
                      v17 = v19;
                      src = v16;
                      if ( v19 < 0 )
                        v17 = -1LL;
                      v3->size = v17;
                      v3->permissions = 420;
                    }
                    return v3;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 80CD5C8: conditional instruction was optimized away because %var_68@4.4<1

//----- (080CD710) --------------------------------------------------------
ftp_file_info *__cdecl parse_ftp_file_info(ftp_file_info *info, unsigned __int8 *src, int len)
{
  unsigned __int8 v4; // cl
  void *v5; // eax
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // esi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // ebx
  mode_t v11; // edx
  ftp_file_type type; // ecx
  int v13; // esi
  time_t v14; // eax
  unsigned __int8 *v15; // ecx
  off_t v16; // rax
  unsigned __int8 *v17; // edi
  unsigned __int8 v18; // bl
  unsigned __int8 *v19; // ebx
  unsigned __int8 *v20; // eax
  unsigned __int8 v21; // cl
  unsigned __int8 *v22; // edx
  unsigned __int8 v23; // bl
  unsigned __int8 *v24; // ecx
  unsigned __int8 *v25; // ecx
  unsigned __int8 v26; // bl
  time_t v27; // ecx
  struct tm *v28; // eax
  int tm_year; // edx
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // ebx
  char *v32; // ebx
  unsigned __int8 *v33; // edx
  unsigned __int8 *source; // eax
  int length; // eax
  int v36; // eax
  bool v37; // cc
  time_t v38; // eax
  unsigned __int8 *i; // eax
  char v40; // bl
  unsigned __int8 *v41; // ecx
  unsigned __int8 v42; // cl
  unsigned __int8 v43; // cl
  unsigned __int8 v44; // cl
  unsigned __int8 v45; // cl
  unsigned __int8 v46; // cl
  unsigned __int8 v47; // cl
  unsigned __int8 v48; // cl
  unsigned __int8 v49; // al
  char v50; // bl
  unsigned __int8 *v51; // eax
  char v52; // bl
  unsigned __int8 *v53; // ecx
  int v54; // eax
  unsigned __int8 *v55; // eax
  unsigned __int8 *v56; // ebx
  char *v57; // esi
  char *v58; // eax
  int v59; // ecx
  char *v60; // esi
  mode_t v61; // eax
  unsigned __int8 v62; // dl
  __int64 v63; // [esp+10h] [ebp-88h]
  off_t v64; // [esp+10h] [ebp-88h]
  __int64 v65; // [esp+10h] [ebp-88h]
  unsigned __int8 end; // [esp+2Ch] [ebp-6Ch]
  unsigned __int8 *enda; // [esp+2Ch] [ebp-6Ch]
  int v68; // [esp+34h] [ebp-64h]
  unsigned __int8 *v69; // [esp+34h] [ebp-64h]
  int v70; // [esp+34h] [ebp-64h]
  __int64 v71; // [esp+38h] [ebp-60h]
  tm tm; // [esp+4Ch] [ebp-4Ch] BYREF
  time_t timer; // [esp+78h] [ebp-20h] BYREF
  void *s[7]; // [esp+7Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_2;
  if ( src && info && len > 0 )
  {
    assert_failed = 0;
    v4 = *src;
    if ( *src > 0x64u )
      goto LABEL_16;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/ftp/parse.c";
    errline = 605;
    elinks_internal("assertion info && src && len > 0 failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
    v4 = *src;
    if ( *src > 0x64u )
    {
LABEL_16:
      if ( v4 == 112 || v4 == 115 || v4 == 108 )
        goto LABEL_19;
      goto LABEL_10;
    }
  }
  if ( v4 >= 0x62u )
    goto LABEL_19;
  if ( v4 == 43 )
  {
    v19 = src + 1;
    v69 = &src[len];
    if ( &src[len] > src + 1 )
    {
      do
      {
        v20 = (unsigned __int8 *)memchr(v19, 44, v69 - v19);
        v21 = *v19;
        v22 = v19 + 1;
        if ( !v20 )
          v20 = &src[len];
        if ( v21 == 114 )
        {
          info->type = FTP_FILE_PLAINFILE;
        }
        else if ( v21 <= 0x72u )
        {
          if ( v21 == 109 )
          {
            if ( v22 < v20 )
            {
              LODWORD(v71) = 0;
              if ( (unsigned __int8)(*v22 - 48) > 9u )
                goto LABEL_95;
              v25 = v19 + 1;
              v26 = *v22;
              v65 = 0LL;
              do
              {
                v65 = 10 * v65 + v26 - 48;
                if ( v20 <= ++v25 )
                  break;
                v26 = *v25;
              }
              while ( (unsigned __int8)(*v25 - 48) <= 9u );
              v71 = v65;
              if ( SHIDWORD(v65) > 0 || v65 < 0 || (unsigned int)v65 > 0x7FFFFFFF )
                v27 = -1;
              else
LABEL_95:
                v27 = v71;
              info->mtime = v27;
            }
          }
          else if ( v21 <= 0x6Du )
          {
            if ( v21 == 9 )
            {
              if ( v69 > v22 )
              {
                info->name.source = v22;
                info->name.length = v69 - v22;
                return info;
              }
            }
            else if ( v21 == 47 )
            {
              info->type = FTP_FILE_DIRECTORY;
            }
          }
        }
        else if ( v21 == 115 && v22 < v20 )
        {
          v64 = 0LL;
          if ( (unsigned __int8)(*v22 - 48) <= 9u )
          {
            v23 = *v22;
            v24 = v22;
            do
            {
              v64 = 10 * v64 + v23 - 48;
              if ( v20 <= ++v24 )
                break;
              v23 = *v24;
            }
            while ( (unsigned __int8)(*v24 - 48) <= 9u );
            if ( v64 < 0 )
              v64 = -1LL;
          }
          info->size = v64;
        }
        v19 = v20 + 1;
      }
      while ( v69 > v20 + 1 && v20 );
    }
    return 0;
  }
  if ( v4 == 45 )
    goto LABEL_19;
LABEL_10:
  end = v4;
  v5 = memchr(src, 59, len);
  v4 = end;
  if ( !v5 )
  {
    if ( (unsigned __int8)(end - 48) <= 9u )
      return parse_ftp_winnt_response(info, src, len);
LABEL_19:
    s[0] = src + 1;
    if ( v4 == 100 || v4 == 108 || v4 == 45 )
      info->type = v4;
    else
      info->type = FTP_FILE_UNKNOWN;
    v68 = 0;
    v8 = &src[len];
    memset(&tm, 0, sizeof(tm));
    v9 = (unsigned __int8 *)s[0];
    tm.tm_isdst = -1;
    v10 = (unsigned __int8 *)s[0];
    if ( &src[len] > s[0] )
    {
      while ( 2 )
      {
        while ( v8 > v10 )
        {
          if ( *v10 == 32 )
            break;
          ++v10;
        }
        switch ( v68 )
        {
          case 0:
            v11 = v10 - v9;
            v68 = 1;
            if ( v10 - v9 != 9 )
              goto LABEL_30;
            if ( *v9 == 45 )
            {
              v11 = 0;
            }
            else
            {
              LOWORD(v11) = 256;
              if ( *v9 != 114 )
              {
LABEL_41:
                v11 = 0;
LABEL_42:
                info->permissions = v11;
                v68 = 1;
                goto LABEL_30;
              }
            }
            v42 = v9[1];
            if ( v42 != 45 )
            {
              if ( v42 != 119 )
                goto LABEL_41;
              LOBYTE(v11) = v11 | 0x80;
            }
            v43 = v9[2];
            if ( v43 == 115 )
            {
              BYTE1(v11) |= 8u;
            }
            else
            {
              if ( v43 <= 0x73u )
              {
                if ( v43 != 45 )
                {
                  if ( v43 != 83 )
                    goto LABEL_41;
                  BYTE1(v11) |= 8u;
                }
LABEL_154:
                v44 = v9[3];
                if ( v44 != 45 )
                {
                  if ( v44 != 114 )
                    goto LABEL_41;
                  v11 |= 0x20u;
                }
                v45 = v9[4];
                if ( v45 != 45 )
                {
                  if ( v45 != 119 )
                    goto LABEL_41;
                  v11 |= 0x10u;
                }
                v46 = v9[5];
                if ( v46 == 115 )
                {
                  BYTE1(v11) |= 4u;
                }
                else
                {
                  if ( v46 <= 0x73u )
                  {
                    if ( v46 != 45 )
                    {
                      if ( v46 != 83 )
                        goto LABEL_41;
                      BYTE1(v11) |= 4u;
                    }
LABEL_165:
                    v47 = v9[6];
                    if ( v47 != 45 )
                    {
                      if ( v47 != 114 )
                        goto LABEL_41;
                      v11 |= 4u;
                    }
                    v48 = v9[7];
                    if ( v48 != 45 )
                    {
                      if ( v48 != 119 )
                        goto LABEL_41;
                      v11 |= 2u;
                    }
                    v49 = v9[8];
                    if ( v49 != 108 )
                    {
                      if ( v49 > 0x6Cu )
                      {
                        if ( v49 == 116 )
                        {
                          BYTE1(v11) |= 2u;
                        }
                        else if ( v49 != 120 )
                        {
                          goto LABEL_41;
                        }
                        v11 |= 1u;
                        goto LABEL_42;
                      }
                      if ( v49 != 76 )
                      {
                        if ( v49 == 84 )
                        {
                          BYTE1(v11) |= 2u;
                          goto LABEL_42;
                        }
                        if ( v49 == 45 )
                          goto LABEL_42;
                        goto LABEL_41;
                      }
                    }
                    BYTE1(v11) |= 4u;
                    v11 &= ~8u;
                    goto LABEL_42;
                  }
                  if ( v46 != 120 )
                    goto LABEL_41;
                }
                v11 |= 8u;
                goto LABEL_165;
              }
              if ( v43 != 120 )
                goto LABEL_41;
            }
            v11 |= 0x40u;
            goto LABEL_154;
          case 1:
            if ( (HIDWORD(info->size) & info->size) == -1
              || v10 - v9 != 3
              || (v54 = parse_month((const unsigned __int8 **)s, v10), v54 == -1) )
            {
              v15 = (unsigned __int8 *)s[0];
              if ( (unsigned __int8)(*(_BYTE *)s[0] - 48) > 9u )
              {
                info->size = -1LL;
              }
              else
              {
                v16 = 0LL;
                if ( s[0] < v10 )
                {
                  v17 = v10;
                  v63 = 0LL;
                  v18 = *(_BYTE *)s[0];
                  do
                  {
                    v63 = 10 * v63 + v18 - 48;
                    if ( ++v15 >= v17 )
                      break;
                    v18 = *v15;
                  }
                  while ( (unsigned __int8)(*v15 - 48) <= 9u );
                  v10 = v17;
                  v16 = v63;
                  s[0] = v15;
                  if ( v63 < 0 )
                    v16 = -1LL;
                }
                info->size = v16;
              }
            }
            else
            {
              tm.tm_mon = v54;
              v68 = 2;
            }
            goto LABEL_30;
          case 2:
            v68 = 3;
            tm.tm_mday = parse_day((const unsigned __int8 **)s, v10);
            goto LABEL_30;
          case 3:
            if ( (unsigned __int8)(*v9 - 48) > 9u )
              goto LABEL_92;
            if ( memchr(v9, 58, v10 - v9) )
            {
              if ( !parse_time((const unsigned __int8 **)s, &tm, v10) )
              {
                memset(&tm, 0, 12);
                v68 = 4;
                goto LABEL_30;
              }
            }
            else
            {
              tm.tm_year = parse_year((const unsigned __int8 **)s, v10);
            }
LABEL_92:
            v68 = 4;
LABEL_30:
            while ( 2 )
            {
              if ( v8 <= v10 )
                return 0;
              if ( *v10 == 32 )
              {
                ++v10;
                continue;
              }
              break;
            }
            s[0] = v10;
            v9 = v10;
            continue;
          case 4:
            type = info->type;
            info->name.source = v9;
            v13 = v8 - (unsigned __int8 *)s[0];
            info->name.length = v13;
            if ( type == FTP_FILE_DIRECTORY )
            {
              if ( v13 > 0 && v9[v13 - 1] == 47 )
                info->name.length = v13 - 1;
              goto LABEL_46;
            }
            if ( type != FTP_FILE_SYMLINK )
            {
              if ( type == FTP_FILE_PLAINFILE && (info->permissions & 0x49) != 0 && v13 > 0 && v9[v13 - 1] == 42 )
                info->name.length = v13 - 1;
              goto LABEL_46;
            }
            if ( !v10 )
              goto LABEL_188;
            if ( &src[len] <= v10 + 3 )
              goto LABEL_187;
            v30 = v10;
            v31 = &src[len];
            while ( 1 )
            {
              if ( !memcmp(v30, " -> ", 4u) )
              {
                v32 = (char *)v30;
                v33 = (unsigned __int8 *)(&src[len - 4] - v30);
                source = v30 + 4;
                info->symlink.source = source;
                info->symlink.length = (int)v33;
                info->name.length = v32 - (char *)s[0];
                goto LABEL_113;
              }
              v30 = (unsigned __int8 *)memchr(v30 + 1, 32, v31 - v30);
              if ( !v30 )
                break;
              if ( v31 <= v30 + 3 )
              {
LABEL_187:
                source = info->symlink.source;
                goto LABEL_113;
              }
            }
LABEL_188:
            source = info->symlink.source;
LABEL_113:
            if ( !source )
              return 0;
            length = info->name.length;
            if ( length > 0 && info->name.source[length - 1] == 64 )
              info->name.length = length - 1;
            v36 = info->symlink.length;
            if ( v36 > 0 && info->symlink.source[v36 - 1] == 47 )
              info->symlink.length = v36 - 1;
LABEL_46:
            if ( !tm.tm_year )
            {
              timer = time(0);
              v28 = localtime(&timer);
              tm_year = v28->tm_year;
              tm.tm_year = tm_year;
              if ( tm.tm_mon > v28->tm_mon )
                tm.tm_year = tm_year - 1;
            }
            v14 = mktime(&tm);
            *((_BYTE *)info + 32) |= 1u;
            info->mtime = v14;
            return info;
          default:
            goto LABEL_30;
        }
      }
    }
    return 0;
  }
  s[0] = src;
  v6 = (unsigned __int8 *)memchr(src, 59, len);
  v7 = &src[len];
  if ( v6 )
  {
    info->name.source = src;
    v37 = v6 - (unsigned __int8 *)s[0] <= 4;
    v70 = v6 - (unsigned __int8 *)s[0];
    info->name.length = v6 - (unsigned __int8 *)s[0];
    if ( v37 || memcmp(v6 - 4, ".DIR", 4u) )
    {
      info->type = FTP_FILE_PLAINFILE;
    }
    else
    {
      info->type = FTP_FILE_DIRECTORY;
      info->name.length = v70 - 4;
    }
    if ( v7 > v6 )
    {
      if ( *v6 == 32 )
        goto LABEL_129;
      do
      {
        if ( v7 <= ++v6 )
          return 0;
      }
      while ( *v6 != 32 );
      do
      {
LABEL_129:
        if ( v7 <= ++v6 )
          return 0;
      }
      while ( *v6 == 32 );
      s[0] = v6;
      while ( *v6 != 32 )
      {
        s[0] = ++v6;
        if ( v7 <= v6 )
          return 0;
      }
      do
      {
        s[0] = ++v6;
        if ( v7 <= v6 )
          return 0;
      }
      while ( *v6 == 32 );
      enda = &src[len];
      v38 = parse_date((unsigned __int8 **)s, v7, 1, 0);
      info->mtime = v38;
      if ( v38 )
      {
        for ( i = (unsigned __int8 *)s[0]; ; s[0] = i )
        {
          v41 = i;
          if ( i >= enda )
            break;
          v40 = *i++;
          if ( v40 != 32 )
            break;
        }
        while ( 1 )
        {
          v51 = v41;
          if ( enda <= v41 )
            break;
          v50 = *v41++;
          if ( v50 == 32 )
            break;
          s[0] = v41;
        }
        while ( 1 )
        {
          v53 = v51;
          if ( enda <= v51 )
            return info;
          v52 = *v51++;
          if ( v52 != 32 )
            break;
          s[0] = v51;
        }
        v55 = (unsigned __int8 *)memchr(v53, 40, enda - v53);
        v56 = v55;
        if ( !v55 )
          return info;
        if ( enda <= v55 )
          return info;
        v57 = (char *)(v55 + 1);
        s[0] = v55 + 1;
        v58 = (char *)memchr(v55 + 1, 41, enda - (v55 + 1));
        if ( !v58 )
          return info;
        v59 = 0;
        v60 = (char *)(v58 - v57);
        v61 = 0;
        while ( 1 )
        {
          if ( (int)v60 <= v59 )
          {
LABEL_212:
            info->permissions = v61;
            return info;
          }
          v62 = v56[v59 + 1];
          if ( v62 == 69 )
          {
            v61 |= 1u;
          }
          else if ( v62 > 0x45u )
          {
            if ( v62 != 82 )
            {
              if ( v62 != 87 )
              {
LABEL_211:
                v61 = 0;
                goto LABEL_212;
              }
              goto LABEL_216;
            }
            v61 |= 4u;
          }
          else
          {
            if ( v62 != 44 )
            {
              if ( v62 != 68 )
                goto LABEL_211;
LABEL_216:
              v61 |= 2u;
              goto LABEL_217;
            }
            v61 *= 8;
          }
LABEL_217:
          ++v59;
        }
      }
    }
  }
  return 0;
}
// 80CDD77: conditional instruction was optimized away because %var_88@4.4==0

//----- (080CE2C0) --------------------------------------------------------
void free_blacklist()
{
  _DWORD *next; // eax
  list_head_elinks *i; // ebx
  list_head_elinks *j; // edx
  list_head_elinks *v3; // esi
  list_head_elinks *v4; // edi

  next = blacklist.next;
  for ( i = (list_head_elinks *)blacklist.next; i != &blacklist; i = (list_head_elinks *)i->next )
    ;
  for ( j = (list_head_elinks *)blacklist.prev; j != i; j = (list_head_elinks *)j->prev )
    ;
  v3 = *(list_head_elinks **)blacklist.next;
  if ( blacklist.next != i )
  {
    do
    {
      v4 = v3;
      v3->prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v3 = (list_head_elinks *)v3->next;
      next = &v4->next;
    }
    while ( v4 != i );
  }
}

//----- (080CE330) --------------------------------------------------------
blacklist_entry *__usercall get_blacklist_entry@<eax>(uri *uri@<eax>)
{
  const unsigned __int8 *next; // ebx

  if ( assert_failed )
    goto LABEL_9;
  if ( uri && *((_WORD *)uri + 23) )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/blacklist.c";
  errline = 33;
  elinks_internal("assertion uri && uri->hostlen > 0 failed!");
  if ( assert_failed )
  {
LABEL_9:
    assert_failed = 0;
    return 0;
  }
LABEL_5:
  next = (const unsigned __int8 *)blacklist.next;
  if ( blacklist.next == &blacklist )
    return 0;
  while ( 1 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/blacklist.c";
    errline = 37;
    if ( !elinks_strlcasecmp(next + 12, 0xFFFFFFFF, uri->host, *((unsigned __int16 *)uri + 23), 1) )
      break;
    next = *(const unsigned __int8 **)next;
    if ( next == (const unsigned __int8 *)&blacklist )
      return 0;
  }
  return (blacklist_entry *)next;
}

//----- (080CE420) --------------------------------------------------------
blacklist_flags __cdecl get_blacklist_flags(uri *uri)
{
  blacklist_entry *blacklist_entry; // edx
  blacklist_flags result; // eax

  blacklist_entry = get_blacklist_entry(uri);
  result = SERVER_BLACKLIST_NONE;
  if ( blacklist_entry )
    return blacklist_entry->flags;
  return result;
}

//----- (080CE440) --------------------------------------------------------
void __cdecl del_blacklist_entry(uri *uri, blacklist_flags flags)
{
  blacklist_entry *blacklist_entry; // eax
  __int32 v3; // ebx

  blacklist_entry = get_blacklist_entry(uri);
  if ( blacklist_entry )
  {
    v3 = blacklist_entry->flags & ~flags;
    blacklist_entry->flags = v3;
    if ( !v3 )
    {
      blacklist_entry->next->prev = blacklist_entry->prev;
      blacklist_entry->prev->next = blacklist_entry->next;
      mem_free(blacklist_entry);
    }
  }
}

//----- (080CE490) --------------------------------------------------------
void __cdecl add_blacklist_entry(uri *uri, blacklist_flags flags)
{
  blacklist_entry *blacklist_entry; // eax
  void *v3; // eax
  _DWORD *v4; // edi
  void *next; // eax

  blacklist_entry = get_blacklist_entry(uri);
  if ( blacklist_entry )
  {
    blacklist_entry->flags |= flags;
  }
  else
  {
    v3 = mem_alloc(*((unsigned __int16 *)uri + 23) + 16);
    v4 = v3;
    if ( v3 )
    {
      *((_DWORD *)v3 + 2) = flags;
      safe_strncpy((unsigned __int8 *)v3 + 12, uri->host, *((unsigned __int16 *)uri + 23) + 1);
      next = blacklist.next;
      v4[1] = &blacklist;
      *v4 = next;
      blacklist.next = v4;
      *(_DWORD *)(*v4 + 4) = v4;
    }
  }
}

//----- (080CE510) --------------------------------------------------------
int __cdecl compare_http_codes(const void *key, const void *element)
{
  return (int)key - *(_DWORD *)element;
}

//----- (080CE520) --------------------------------------------------------
void __cdecl http_error_document(connection *conn, int code)
{
  _DWORD *v2; // eax
  uri *uri; // edx

  if ( !assert_failed )
  {
    if ( conn && conn->uri )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/codes.c";
      errline = 202;
      elinks_internal("assertion conn && conn->uri failed!");
    }
  }
  v2 = mem_calloc(1u, 8u);
  if ( v2 )
  {
    *v2 = code;
    uri = conn->uri;
    ++uri->object.refcount;
    v2[1] = uri;
    add_questions_entry(show_http_error_document, v2);
  }
}

//----- (080CE5D0) --------------------------------------------------------
void __cdecl show_http_error_document(session *ses, void *data)
{
  cache_entry *cache_entry; // ebx
  const void *v3; // edi
  _DWORD *v4; // eax
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v7; // eax
  const unsigned __int8 *v8; // eax
  int v9; // eax
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // eax
  unsigned __int8 *source; // edi
  unsigned __int8 *v13; // eax
  size_t v14; // eax
  int v15; // [esp+28h] [ebp-40h]
  int v16; // [esp+28h] [ebp-40h]
  const char **v17; // [esp+2Ch] [ebp-3Ch]
  const terminal *term; // [esp+30h] [ebp-38h]
  unsigned __int8 *p; // [esp+34h] [ebp-34h]
  cache_entry *cached; // [esp+38h] [ebp-30h]
  int gettext_codepage; // [esp+3Ch] [ebp-2Ch]
  const char *gettext_codepagea; // [esp+3Ch] [ebp-2Ch]
  int gettext_codepageb; // [esp+3Ch] [ebp-2Ch]
  string string; // [esp+48h] [ebp-20h] BYREF

  term = ses->tab->term;
  cache_entry = find_in_cache(*((uri **)data + 1));
  cached = cache_entry;
  if ( cache_entry || (cache_entry = get_cache_entry(*((uri **)data + 1))) != 0 )
  {
    v3 = *(const void **)data;
    v17 = (const char **)*((_DWORD *)data + 1);
    v4 = bsearch(*(const void **)data, http_code_0, 0x29u, 8u, compare_http_codes);
    gettext_codepage = 0;
    if ( v4 )
      gettext_codepage = v4[1];
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        v15 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v15;
      }
    }
    v7 = gettext((const unsigned __int8 *)&byte_8132982);
    p = asprintfa((const char *)v7, v3);
    v8 = &byte_8131AED;
    if ( gettext_codepage )
      v8 = (const unsigned __int8 *)gettext_codepage;
    gettext_codepagea = (const char *)v8;
    if ( init_string(&string) )
    {
      add_format_to_string(
        &string,
        "<html>\n <head><title>%s</title></head>\n <body>\n  <h1 align=\"left\">%s: %s</h1>\n  <hr />\n  <p>\n",
        (const char *)p,
        (const char *)p,
        gettext_codepagea);
      if ( term )
      {
        v9 = get_terminal_codepage(term);
        if ( v9 != current_charset )
        {
          v16 = v9;
          v10 = get_cp_mime_name(v9);
          bind_textdomain_codeset("elinks", v10);
          current_charset = v16;
        }
      }
      v11 = gettext(&byte_8121994);
      add_format_to_string(&string, v11);
      add_format_to_string(&string, "  </p>\n  <p>\n  URI: <a href=\"%s\">%s</a>\n", *v17, *v17);
      add_format_to_string(&string, " </p>\n <hr />\n </body>\n</html>\n");
      if ( p )
        mem_free(p);
      source = string.source;
      if ( string.source )
      {
        gettext_codepageb = get_terminal_codepage(term);
        if ( cached )
          delete_entry_content(cache_entry);
        if ( cache_entry->content_type )
          mem_free(cache_entry->content_type);
        cache_entry->content_type = stracpy("text/html");
        if ( cache_entry->head )
          mem_free(cache_entry->head);
        v13 = get_cp_mime_name(gettext_codepageb);
        cache_entry->head = straconcat("\r\nContent-Type: text/html; charset=", v13, "\r\n", 0);
        v14 = strlen((const char *)source);
        add_fragment(cache_entry, 0LL, source, v14);
        mem_free(source);
        draw_formatted(ses, 1);
      }
    }
    else if ( p )
    {
      mem_free(p);
    }
  }
  done_uri(*((uri **)data + 1));
  mem_free(data);
}

//----- (080CE8B0) --------------------------------------------------------
void done_http()
{
  if ( proxy_auth.realm )
    mem_free(proxy_auth.realm);
  if ( proxy_auth.nonce )
    mem_free(proxy_auth.nonce);
  if ( proxy_auth.opaque )
    mem_free(proxy_auth.opaque);
  free_blacklist();
  if ( accept_charset )
    mem_free(accept_charset);
}

//----- (080CE910) --------------------------------------------------------
connection_basic_state *__usercall connection_state_7@<eax>(
        connection_basic_state basic@<edx>,
        connection_basic_state *result@<eax>)
{
  connection_basic_state *v2; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = basic == S_ERRNO) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/network/state.h",
        errline = 132,
        v2 = result,
        elinks_internal("assertion basic != S_ERRNO failed!"),
        basic = S_ERRNO,
        result = v2,
        assert_failed) )
  {
    assert_failed = 0;
    *((_DWORD *)result + 1) = 0;
    *result = S_INTERNAL;
  }
  else
  {
    *((_DWORD *)result + 1) = 0;
    *result = basic;
  }
  return result;
}

//----- (080CE9A0) --------------------------------------------------------
void __usercall http_end_request(connection *conn@<eax>, connection_state state@<0:edx, 4:ecx>, int notrunc)
{
  connection_basic_state basic; // esi
  int syserr; // edi
  _DWORD *info; // eax
  cache_entry *cached; // eax
  int from; // edx
  int from_high; // ecx

  basic = state.basic;
  syserr = state.syserr;
  shutdown_connection_stream(conn);
  info = conn->info;
  if ( !info
    || info[5]
    || conn->socket->ssl
    || get_opt_(config_options, "protocol.http.bugs.post_no_keepalive")->number && conn->uri->post )
  {
    abort_connection(conn, (connection_state)__PAIR64__(syserr, basic));
  }
  else
  {
    if ( basic == S_OK )
    {
      cached = conn->cached;
      if ( cached )
      {
        from = -1;
        from_high = -1;
        if ( !notrunc )
        {
          from = conn->from;
          from_high = HIDWORD(conn->from);
        }
        normalize_cache_entry(cached, __SPAIR64__(from_high, from));
      }
    }
    set_connection_state(conn, (connection_state)__PAIR64__(syserr, basic));
    add_keepalive_connection(conn, 60000, 0);
  }
}

//----- (080CEA90) --------------------------------------------------------
unsigned __int8 *__usercall decompress_data@<eax>(
        connection *conn@<eax>,
        unsigned __int8 *data@<edx>,
        int len@<ecx>,
        int *new_len)
{
  int length; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edi
  int encoded; // eax
  int v10; // edi
  ssize_t v11; // eax
  stream_encoded *v12; // eax
  int *length_of_block; // [esp+18h] [ebp-30h]
  http_connection_info *http; // [esp+1Ch] [ebp-2Ch]
  _BOOL4 state; // [esp+20h] [ebp-28h]
  unsigned __int8 *output; // [esp+28h] [ebp-20h]
  int n; // [esp+2Ch] [ebp-1Ch]

  n = len;
  http = (http_connection_info *)conn->info;
  length = http->length;
  if ( length == -2 )
  {
    state = http->chunk_remaining == -2;
    length_of_block = &http->chunk_remaining;
  }
  else
  {
    length_of_block = &http->length;
    state = length == 0;
  }
  if ( conn->content_encoding == ENCODING_NONE )
  {
    *new_len = len;
    if ( *length_of_block > 0 )
      *length_of_block -= len;
    return data;
  }
  *new_len = 0;
  if ( conn->stream_pipes[0] == -1
    && (c_pipe(conn->stream_pipes) < 0
     || set_nonblocking_fd(conn->stream_pipes[0]) < 0
     || set_nonblocking_fd(conn->stream_pipes[1]) < 0) )
  {
    return 0;
  }
  output = 0;
  do
  {
    if ( !state )
    {
      v10 = conn->stream_pipes[1];
      while ( 1 )
      {
        v11 = write(v10, data, n);
        if ( v11 != -1 )
          break;
        if ( *__errno_location() != 4 )
          goto LABEL_10;
      }
      if ( v11 < 0 )
        goto LABEL_10;
      data += v11;
      n -= v11;
      if ( *length_of_block > 0 )
        *length_of_block -= v11;
      if ( http->length )
      {
        if ( !n )
          return output;
        goto LABEL_10;
      }
    }
    state = 1;
LABEL_10:
    if ( !conn->stream )
    {
      v12 = open_encoded(conn->stream_pipes[0], conn->content_encoding);
      conn->stream = v12;
      if ( !v12 )
        return 0;
    }
    v7 = (unsigned __int8 *)mem_realloc(output, *new_len + 655360);
    v8 = v7;
    if ( !v7 )
      break;
    encoded = read_encoded(conn->stream, &v7[*new_len], 655360);
    if ( encoded < 0 )
    {
      output = v8;
      goto LABEL_24;
    }
    *new_len += encoded;
    output = v8;
  }
  while ( encoded == 655360 || n );
  if ( !state )
    return output;
LABEL_24:
  shutdown_connection_stream(conn);
  return output;
}

//----- (080CECA0) --------------------------------------------------------
string *__usercall add_bytes_to_string___4@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (080CEDF0) --------------------------------------------------------
http_connection_info *__cdecl init_http_connection_info(connection *conn, int major, int minor, int close)
{
  http_connection_info *v4; // eax
  http_connection_info *v5; // ebx
  blacklist_flags blacklist_flags; // eax
  connection_state state; // [esp+18h] [ebp-10h] BYREF

  v4 = (http_connection_info *)mem_calloc(1u, 0x24u);
  v5 = v4;
  if ( !v4 )
  {
    connection_state_7(S_OUT_OF_MEM, &state.basic);
    http_end_request(conn, state, 0);
    return v5;
  }
  v4->sent_version.major = major;
  v4->sent_version.minor = minor;
  v4->close = close;
  if ( conn->proxied_uri->protocol == 4 )
  {
    if ( (v4->bl_flags & 1) != 0 )
      goto LABEL_4;
LABEL_10:
    if ( !get_opt_(config_options, "protocol.http.bugs.http10")->number )
      goto LABEL_5;
    goto LABEL_4;
  }
  blacklist_flags = get_blacklist_flags(conn->proxied_uri);
  v5->bl_flags = blacklist_flags;
  if ( (blacklist_flags & 1) == 0 )
    goto LABEL_10;
LABEL_4:
  v5->sent_version.major = 1;
  v5->sent_version.minor = 0;
LABEL_5:
  if ( conn->info )
    mem_free(conn->info);
  conn->info = v5;
  return v5;
}

//----- (080CEEC0) --------------------------------------------------------
void __usercall read_http_data_done(connection *conn@<eax>)
{
  int v1; // edx
  connection *v2; // [esp+1Ch] [ebp-Ch]
  connection_state v3; // 0:edx.8

  if ( !conn->from )
  {
    v1 = *((_DWORD *)conn->info + 8);
    if ( v1 > 399 )
    {
      v2 = conn;
      http_error_document(conn, v1);
      conn = v2;
    }
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v3.basic = S_INTERNAL;
  }
  else
  {
    assert_failed = 0;
    v3.basic = S_OK;
  }
  v3.syserr = 0;
  http_end_request(conn, v3, 0);
}

//----- (080CEF40) --------------------------------------------------------
void __usercall read_more_http_data(connection *conn@<eax>, read_buffer *rb@<edx>, int already_got_anything@<ecx>)
{
  connection_basic_state basic; // ebx
  int syserr; // ecx

  if ( already_got_anything )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      basic = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      basic = S_TRANS;
    }
    syserr = 0;
  }
  else
  {
    basic = conn->state.basic;
    syserr = conn->state.syserr;
  }
  read_from_socket(conn->socket, rb, (connection_state)__PAIR64__(syserr, basic), read_http_data);
}

//----- (080CEFB0) --------------------------------------------------------
void __cdecl read_http_data(socket *socket, read_buffer *rb)
{
  void *conn; // ebx
  int length; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int chunk_remaining; // eax
  int v10; // edi
  int v11; // edx
  unsigned __int8 v12; // di
  int v13; // eax
  unsigned __int8 v14; // cl
  int v15; // eax
  unsigned __int8 v16; // dl
  unsigned __int8 v17; // di
  unsigned __int8 v18; // cl
  int v19; // edx
  int *v20; // eax
  int *v21; // edi
  int v22; // eax
  int v23; // edi
  int v24; // [esp+4h] [ebp-64h]
  unsigned __int8 *p; // [esp+2Ch] [ebp-3Ch]
  unsigned __int8 *pa; // [esp+2Ch] [ebp-3Ch]
  void *pb; // [esp+2Ch] [ebp-3Ch]
  void *pc; // [esp+2Ch] [ebp-3Ch]
  int v29; // [esp+30h] [ebp-38h]
  unsigned __int8 *nptr; // [esp+34h] [ebp-34h]
  int data; // [esp+38h] [ebp-30h]
  _BOOL4 dataa; // [esp+38h] [ebp-30h]
  int datab; // [esp+38h] [ebp-30h]
  http_connection_info *http; // [esp+3Ch] [ebp-2Ch]
  int new_len[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  conn = socket->conn;
  http = (http_connection_info *)*((_DWORD *)conn + 38);
  if ( socket->state == SOCKET_CLOSED )
  {
    if ( !*((_DWORD *)conn + 16) )
    {
LABEL_18:
      read_http_data_done((connection *)conn);
      return;
    }
    *(_DWORD *)(*((_DWORD *)conn + 38) + 24) = 0;
    http = (http_connection_info *)*((_DWORD *)conn + 38);
    length = http->length;
LABEL_3:
    v4 = rb->length;
    if ( length >= 0 && v4 > length )
      v4 = length;
    *((_QWORD *)conn + 6) += v4;
    p = decompress_data((connection *)conn, rb->data, v4, new_len);
    if ( add_fragment(*((cache_entry **)conn + 9), *((_QWORD *)conn + 5), p, new_len[0]) == 1 )
      *((_DWORD *)conn + 26) = 0;
    if ( p && rb->data != p )
      mem_free(p);
    *((_QWORD *)conn + 5) += new_len[0];
    kill_buffer_data(rb, v4);
    if ( http->length || (v6 = *(_DWORD *)(*((_DWORD *)conn + 24) + 4), v6 != 2) && v6 )
    {
      v5 = new_len[0] != 0;
      goto LABEL_13;
    }
    goto LABEL_18;
  }
  length = http->length;
  if ( length != -2 )
    goto LABEL_3;
  chunk_remaining = http->chunk_remaining;
  nptr = rb->data;
  v29 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( chunk_remaining == -3 )
        goto LABEL_45;
      if ( chunk_remaining == -1 )
        break;
LABEL_34:
      dataa = chunk_remaining == -2;
      v10 = rb->length;
      if ( chunk_remaining == -2 )
        chunk_remaining = 0;
      if ( chunk_remaining <= v10 )
        v10 = chunk_remaining;
      *((_QWORD *)conn + 6) += v10;
      pa = decompress_data((connection *)conn, nptr, v10, new_len);
      if ( add_fragment(*((cache_entry **)conn + 9), *((_QWORD *)conn + 5), pa, new_len[0]) == 1 )
        *((_DWORD *)conn + 26) = 0;
      if ( pa && nptr != pa )
        mem_free(pa);
      *((_QWORD *)conn + 5) += new_len[0];
      v29 += new_len[0];
      kill_buffer_data(rb, v10);
      if ( !dataa )
      {
        if ( http->chunk_remaining )
          goto LABEL_88;
        v15 = rb->length;
        if ( v15 <= 0 )
          goto LABEL_88;
        v16 = rb->data[0];
        if ( v16 == 10 )
        {
          kill_buffer_data(rb, 1);
        }
        else
        {
          if ( v16 != 13 )
            goto LABEL_23;
          if ( v15 == 1 )
            goto LABEL_88;
          if ( rb->data[1] != 10 )
            goto LABEL_23;
          kill_buffer_data(rb, 2);
        }
        http->chunk_remaining = -1;
        break;
      }
      http->chunk_remaining = -3;
LABEL_45:
      v11 = rb->length;
      if ( v11 <= 0 )
        goto LABEL_88;
      v12 = rb->data[0];
      if ( v12 == 10 )
      {
        v23 = 1;
      }
      else
      {
        v13 = 0;
        data = 1;
        if ( v12 != 13 )
        {
          if ( v12 <= 0x1Fu )
            goto LABEL_23;
          v13 = 0;
          while ( ++v13 < v11 )
          {
            v14 = rb->data[v13];
            if ( v14 == 10 )
            {
              v23 = v13 + 1;
              if ( v13 != -1 )
                goto LABEL_82;
              goto LABEL_88;
            }
            if ( v14 == 13 )
            {
              data = v13 + 1;
              goto LABEL_20;
            }
            if ( v14 <= 0x1Fu )
              goto LABEL_23;
          }
          goto LABEL_88;
        }
LABEL_20:
        if ( rb->data[data] != 10 )
          goto LABEL_21;
        v7 = v11 - 1;
        if ( v7 <= v13 )
          goto LABEL_22;
        v23 = v13 + 2;
LABEL_82:
        if ( v23 == -1 )
          goto LABEL_23;
      }
      kill_buffer_data(rb, v23);
      if ( v23 <= 2 )
        goto LABEL_18;
      chunk_remaining = http->chunk_remaining;
    }
    v11 = rb->length;
    if ( v11 <= 0 )
      goto LABEL_88;
    v17 = rb->data[0];
    if ( v17 == 10 )
    {
      v19 = 1;
      goto LABEL_75;
    }
    v13 = 0;
    datab = 1;
    if ( v17 != 13 )
    {
      if ( v17 <= 0x1Fu )
        goto LABEL_23;
      v13 = 0;
      while ( ++v13 < v11 )
      {
        v18 = rb->data[v13];
        if ( v18 == 10 )
        {
          v19 = v13 + 1;
          if ( v13 != -1 )
            goto LABEL_74;
          goto LABEL_88;
        }
        if ( v18 == 13 )
        {
          datab = v13 + 1;
          goto LABEL_71;
        }
        if ( v18 <= 0x1Fu )
          goto LABEL_23;
      }
      goto LABEL_88;
    }
LABEL_71:
    if ( rb->data[datab] != 10 )
      break;
    v7 = v11 - 1;
    if ( v7 <= v13 )
      goto LABEL_22;
    v19 = v13 + 2;
LABEL_74:
    if ( v19 == -1 )
      goto LABEL_23;
LABEL_75:
    pb = (void *)v19;
    v20 = __errno_location();
    *v20 = 0;
    v21 = v20;
    v22 = strtol((const char *)nptr, (char **)new_len, 16);
    if ( *v21 || !*(_BYTE *)new_len[0] || (unsigned __int8 *)new_len[0] == nptr )
      goto LABEL_23;
    v24 = (int)pb;
    pc = (void *)v22;
    kill_buffer_data(rb, v24);
    chunk_remaining = (int)pc;
    http->chunk_remaining = (int)pc;
    if ( !pc )
    {
      http->chunk_remaining = -2;
      chunk_remaining = -2;
      goto LABEL_34;
    }
  }
LABEL_21:
  v7 = v11 - 1;
LABEL_22:
  if ( v13 != v7 )
  {
LABEL_23:
    v5 = -1;
    goto LABEL_24;
  }
LABEL_88:
  v5 = v29 != 0;
LABEL_13:
  if ( v5 == 1 )
  {
    read_more_http_data((connection *)conn, rb, 1);
  }
  else if ( v5 )
  {
LABEL_24:
    if ( assert_failed
      || (assert_failed = v5 != -1) != 0
      && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c",
          errline = 1388,
          elinks_internal("assertion ret == -1 failed: Unexpected return value: %d", v5),
          assert_failed) )
    {
      assert_failed = 0;
      v8 = -100003;
    }
    else
    {
      assert_failed = 0;
      v8 = -100100;
    }
    abort_connection((connection *)conn, (connection_state)(unsigned int)v8);
  }
  else
  {
    read_more_http_data((connection *)conn, rb, 0);
  }
}

//----- (080CF530) --------------------------------------------------------
void __usercall add_url_to_http_string(string *header@<eax>, uri *uri@<edx>, int components@<ecx>)
{
  unsigned __int8 *uri_string; // eax
  const char *v5; // esi
  char v6; // al
  signed int v7; // eax
  size_t v8; // edi
  unsigned int length; // eax
  int v10; // ecx
  size_t v11; // edx
  unsigned __int8 *v12; // eax
  size_t v13; // [esp+10h] [ebp-28h]
  int v14; // [esp+14h] [ebp-24h]
  int v15; // [esp+14h] [ebp-24h]
  unsigned int v16; // [esp+18h] [ebp-20h]
  unsigned __int8 *string; // [esp+1Ch] [ebp-1Ch]

  uri_string = get_uri_string(uri, (uri_component)components);
  string = uri_string;
  if ( uri_string )
  {
    if ( *uri_string )
    {
      v5 = (const char *)uri_string;
      do
      {
        v7 = strcspn(v5, " \t\r\n\\");
        v8 = v7;
        if ( assert_failed )
        {
LABEL_4:
          assert_failed = 0;
          goto LABEL_5;
        }
        if ( header && v7 >= 0 )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 255;
          elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if ( assert_failed )
            goto LABEL_4;
        }
        if ( v8 )
        {
          length = header->length;
          v10 = v8 + length;
          length += 255;
          v11 = v10 + 256;
          LOBYTE(length) = 0;
          LOBYTE(v11) = 0;
          v16 = length;
          if ( v11 > length )
          {
            v13 = v11;
            v15 = v10;
            v12 = (unsigned __int8 *)mem_realloc(header->source, v11);
            if ( !v12 )
              goto LABEL_5;
            header->source = v12;
            memset(&v12[v16], 0, v13 - v16);
            v10 = v15;
          }
          if ( header->source )
          {
            v14 = v10;
            memcpy(&header->source[header->length], v5, v8);
            header->source[v14] = 0;
            header->length = v14;
            v6 = v5[v8];
            if ( !v6 )
              break;
            goto LABEL_6;
          }
        }
LABEL_5:
        v6 = v5[v8];
        if ( !v6 )
          break;
LABEL_6:
        if ( v6 == 92 )
          add_char_to_string(header, 0x2Fu);
        else
          add_to_string(header, &byte_8132C10);
        v5 += v8 + 1;
      }
      while ( *v5 );
    }
    mem_free(string);
  }
}

//----- (080CF700) --------------------------------------------------------
void __cdecl http_got_header(socket *socket, read_buffer *rb)
{
  read_buffer *v2; // ebx
  int length; // esi
  int v4; // eax
  int v5; // edx
  unsigned __int8 v6; // di
  unsigned __int8 v7; // al
  unsigned __int8 *data; // esi
  int v9; // eax
  unsigned __int8 *v10; // eax
  const char *v11; // esi
  const char **v12; // edi
  const char *v13; // ebx
  unsigned __int8 *j; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // edi
  unsigned __int8 *v17; // eax
  int v18; // esi
  int v19; // eax
  uri *uri; // edx
  cache_entry *cache_entry; // eax
  cache_entry *cached; // eax
  unsigned __int8 *v23; // eax
  int v24; // esi
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // edx
  off_t from; // rdi
  progress *progress; // ecx
  int *v29; // eax
  int *v30; // esi
  int v31; // eax
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  cache_entry *v34; // edx
  const char *last_modified; // ecx
  cache_entry *v36; // eax
  unsigned __int8 *v37; // esi
  cache_entry *v38; // edi
  unsigned __int8 *etag; // eax
  const char *v40; // edx
  stream_encoding v41; // edi
  unsigned __int8 *extension_from_uri; // eax
  unsigned __int8 *v43; // esi
  stream_encoding content_encoding; // eax
  cache_entry *v45; // esi
  const unsigned __int8 *encoding_name; // eax
  int v47; // eax
  char v48; // al
  unsigned __int8 *v49; // eax
  unsigned __int8 *v50; // esi
  unsigned __int8 *v51; // esi
  unsigned __int8 *v52; // edi
  unsigned __int8 *k; // esi
  unsigned __int8 *v54; // eax
  int v55; // eax
  _BOOL4 v56; // edi
  connection_basic_state v57; // edx
  unsigned __int8 *v58; // eax
  cache_entry *v59; // esi
  int v60; // edi
  unsigned __int8 *v61; // eax
  unsigned __int8 *v62; // edi
  unsigned __int8 *v63; // eax
  const char *v64; // edi
  connection_basic_state v65; // edx
  unsigned __int8 *v66; // edi
  unsigned __int8 *i; // eax
  unsigned __int8 v68; // cl
  unsigned __int8 *v69; // esi
  char *v70; // edi
  bool v71; // zf
  int v72; // eax
  unsigned __int8 *v73; // eax
  unsigned __int8 *header_param; // edi
  int *v75; // eax
  int *v76; // esi
  int v77; // eax
  unsigned __int8 *v78; // esi
  int v79; // edi
  unsigned __int8 v80; // di
  unsigned __int8 v81; // al
  timeval_T *t; // [esp+38h] [ebp-70h]
  __int64 v83; // [esp+3Ch] [ebp-6Ch]
  read_buffer *v84; // [esp+44h] [ebp-64h]
  unsigned __int8 *v85; // [esp+48h] [ebp-60h]
  char *s1; // [esp+4Ch] [ebp-5Ch]
  http_connection_info *http; // [esp+50h] [ebp-58h]
  uri *proxied_uri; // [esp+54h] [ebp-54h]
  connection *conn; // [esp+58h] [ebp-50h]
  int h; // [esp+5Ch] [ebp-4Ch]
  int ha; // [esp+5Ch] [ebp-4Ch]
  unsigned __int8 *hb; // [esp+5Ch] [ebp-4Ch]
  unsigned __int8 a; // [esp+60h] [ebp-48h]
  int aa; // [esp+60h] [ebp-48h]
  int opaque; // [esp+64h] [ebp-44h]
  unsigned __int8 *opaquea; // [esp+64h] [ebp-44h]
  unsigned __int8 *opaqueb; // [esp+64h] [ebp-44h]
  unsigned __int8 *opaquec; // [esp+64h] [ebp-44h]
  unsigned __int8 *opaqued; // [esp+64h] [ebp-44h]
  unsigned __int8 *opaquee; // [esp+64h] [ebp-44h]
  connection_state state; // [esp+68h] [ebp-40h] BYREF
  timeval_T max_age; // [esp+7Ch] [ebp-2Ch] BYREF
  unsigned __int8 *str; // [esp+84h] [ebp-24h] BYREF
  unsigned __int8 *d; // [esp+88h] [ebp-20h] BYREF
  unsigned __int8 *ch_0; // [esp+8Ch] [ebp-1Ch] BYREF

  v2 = rb;
  conn = (connection *)socket->conn;
  http = (http_connection_info *)conn->info;
  proxied_uri = conn->proxied_uri;
  if ( conn->state.basic == S_PROC )
  {
    if ( !assert_failed )
    {
      assert_failed = 0;
      opaque = 7;
LABEL_4:
      if ( socket->state != SOCKET_CLOSED )
        goto LABEL_5;
LABEL_65:
      if ( !conn->tries && proxied_uri->host )
      {
        if ( (http->bl_flags & 2) != 0 )
        {
          del_blacklist_entry(proxied_uri, SERVER_BLACKLIST_NO_CHARSET);
        }
        else
        {
          add_blacklist_entry(proxied_uri, SERVER_BLACKLIST_NO_CHARSET);
          conn->tries = -1;
        }
      }
      if ( assert_failed )
      {
        assert_failed = 0;
        v19 = -100003;
      }
      else
      {
        assert_failed = 0;
        v19 = -100007;
      }
      retry_connection(conn, (connection_state)(unsigned int)v19);
      return;
    }
LABEL_3:
    assert_failed = 0;
    opaque = -100003;
    goto LABEL_4;
  }
  if ( assert_failed )
    goto LABEL_3;
  assert_failed = 0;
  opaque = 6;
  if ( socket->state == SOCKET_CLOSED )
    goto LABEL_65;
LABEL_5:
  socket->state = SOCKET_RETRY_ONCLOSE;
  s1 = (char *)rb->data;
  v83 = 9LL;
  h = 200;
  while ( 2 )
  {
    length = v2->length;
    if ( length > 4 )
    {
      if ( c_strncasecmp(s1, "HTTP/", 5u) )
        goto LABEL_35;
      length = v2->length;
    }
    v4 = 0;
    if ( length <= 0 )
    {
LABEL_11:
      read_from_socket(conn->socket, v2, (connection_state)(unsigned int)opaque, http_got_header);
      return;
    }
    while ( 1 )
    {
      a = v2->data[v4];
      v5 = v4 + 1;
      v6 = v2->data[v4 + 1];
      if ( !a )
      {
        *((_BYTE *)&v2->freespace + v5 + 3) = 32;
        length = v2->length;
        goto LABEL_10;
      }
      if ( v6 != 10 || a != 10 )
        break;
      if ( v4 < length - 1 )
      {
        aa = v4 + 2;
        goto LABEL_18;
      }
LABEL_10:
      ++v4;
      if ( length <= v5 )
        goto LABEL_11;
    }
    if ( a != 13 || v4 >= length - 3 || v6 == 13 )
      goto LABEL_10;
    if ( v6 != 10 )
      goto LABEL_32;
    if ( v2->data[v5 + 1] != 13 )
      goto LABEL_10;
    if ( v2->data[v4 + 3] != 10 )
    {
LABEL_32:
      if ( assert_failed )
      {
        assert_failed = 0;
        v9 = -100003;
      }
      else
      {
        assert_failed = 0;
        v9 = -100100;
      }
      goto LABEL_34;
    }
    aa = v4 + 4;
LABEL_18:
    if ( aa == -1 )
      goto LABEL_32;
    if ( !aa )
      goto LABEL_11;
    if ( aa != -2 )
    {
      v7 = v2->data[0];
      data = rb->data;
      if ( v7 == 32 )
      {
        do
          v7 = *++data;
        while ( *data == 32 );
      }
      if ( c_toupper(v7) == 72
        && c_toupper(data[1]) == 84
        && c_toupper(data[2]) == 84
        && c_toupper(data[3]) == 80
        && data[4] == 47 )
      {
        v66 = data + 5;
        for ( i = data + 5; ; ++i )
        {
          v68 = *i;
          if ( *i == 46 || !v68 )
            break;
        }
        if ( v66 != i )
        {
          if ( v68 )
          {
            if ( i - v66 <= 4 )
            {
              opaqued = i + 1;
              if ( (unsigned __int8)(i[1] - 48) <= 9u )
              {
                v69 = i;
                HIDWORD(v83) = 0;
                for ( ha = 1; (unsigned __int8)(*--v69 - 48) <= 9u; ha *= 10 )
                {
                  HIDWORD(v83) += ha * (*v69 - 48);
                  if ( v66 >= v69 )
                  {
                    while ( v68 != 32 && v68 )
                      v68 = *++i;
                    if ( opaqued != i && v68 && i - opaqued <= 4 )
                    {
                      v78 = i;
                      v79 = 1;
                      LODWORD(v83) = 0;
                      while ( (unsigned __int8)(*--v78 - 48) <= 9u )
                      {
                        LODWORD(v83) = v79 * (*v78 - 48) + v83;
                        if ( opaqued >= v78 )
                        {
                          while ( v68 == 32 )
                            v68 = *++i;
                          if ( (unsigned __int8)(v68 - 49) <= 8u )
                          {
                            v80 = i[1];
                            if ( (unsigned __int8)(v80 - 48) <= 9u )
                            {
                              v81 = i[2];
                              if ( (unsigned __int8)(v81 - 48) <= 9u )
                              {
                                h = 100 * v68 + v81 - 5328 + 10 * v80;
                                goto LABEL_36;
                              }
                            }
                          }
                          goto LABEL_24;
                        }
                        v79 *= 10;
                      }
                    }
                    break;
                  }
                }
              }
            }
          }
        }
      }
LABEL_24:
      if ( assert_failed )
      {
LABEL_25:
        assert_failed = 0;
        v9 = -100003;
      }
      else
      {
        assert_failed = 0;
        v9 = -100100;
      }
      goto LABEL_34;
    }
LABEL_35:
    aa = 0;
LABEL_36:
    if ( h == 101 )
      goto LABEL_24;
    if ( !aa )
    {
      opaquea = stracpy("\r\nContent-Type: text/html\r\n");
      if ( !opaquea )
        goto LABEL_56;
LABEL_39:
      if ( get_opt_(config_options, "protocol.http.bugs.allow_blacklist")->number
        && (http->sent_version.major != 1 || http->sent_version.minor)
        && (v10 = parse_header(opaquea, (unsigned __int8 *)&item, 0), (v85 = v10) != 0) )
      {
        v84 = v2;
        v11 = "mod_czech/3.1.0";
        v12 = (const char **)buggy_servers_9226;
        v13 = (const char *)v10;
        do
        {
          if ( strstr(v13, v11) )
          {
            v2 = v84;
            add_blacklist_entry(proxied_uri, SERVER_BLACKLIST_HTTP10);
            mem_free(v85);
            if ( !v11 )
              goto LABEL_47;
            mem_free(opaquea);
            if ( assert_failed )
            {
              assert_failed = 0;
              v47 = -100003;
            }
            else
            {
              assert_failed = 0;
              v47 = -100011;
            }
            retry_connection(conn, (connection_state)(unsigned int)v47);
            return;
          }
          v11 = *++v12;
        }
        while ( *v12 );
        v2 = v84;
        mem_free(v85);
        if ( proxied_uri->protocol != 4 )
          goto LABEL_48;
      }
      else
      {
LABEL_47:
        if ( proxied_uri->protocol != 4 )
          goto LABEL_48;
      }
      v17 = parse_header(opaquea, "Status", 0);
      d = v17;
      if ( v17 )
      {
        v18 = strtol((const char *)v17, 0, 10);
        mem_free(d);
        if ( (unsigned int)(v18 - 100) <= 0x1F3 )
        {
          if ( v18 == 101 )
          {
            mem_free(opaquea);
            v65 = S_HTTP_ERROR;
            goto LABEL_240;
          }
          h = v18;
        }
      }
LABEL_48:
      ch_0 = opaquea;
      for ( j = opaquea; ; j = ch_0 )
      {
        v15 = parse_header(j, "Set-Cookie", &ch_0);
        v16 = v15;
        if ( !v15 )
          break;
        set_cookie(proxied_uri, v15);
        mem_free(v16);
      }
      http->code = h;
      if ( h == 100 )
      {
        mem_free(opaquea);
        if ( assert_failed )
        {
          assert_failed = 0;
          opaque = -100003;
        }
        else
        {
          assert_failed = 0;
          opaque = 7;
        }
        kill_buffer_data(v2, aa);
        continue;
      }
      if ( h <= 199 )
      {
        mem_free(opaquea);
        connection_state_7(S_HTTP_ERROR, &state.basic);
        abort_connection(conn, state);
        return;
      }
      switch ( h )
      {
        case 304:
          mem_free(opaquea);
          connection_state_7(S_OK, &state.basic);
          http_end_request(conn, state, 1);
          return;
        case 204:
          mem_free(opaquea);
          connection_state_7(S_HTTP_204, &state.basic);
          http_end_request(conn, state, 0);
          return;
        case 200:
          uri = conn->uri;
          if ( uri->protocol == 15 && conn->proxied_uri->protocol == 10 && !conn->socket->ssl )
          {
            mem_free(opaquea);
            *((_BYTE *)socket + 36) |= 2u;
            complete_connect_socket(socket, proxied_uri, http_send_header);
            return;
          }
          break;
        default:
          uri = conn->uri;
          break;
      }
      cache_entry = get_cache_entry(uri);
      conn->cached = cache_entry;
      if ( cache_entry )
      {
        *((_BYTE *)cache_entry + 92) = (8 * *((_BYTE *)conn + 120)) & 0x40 | *((_BYTE *)cache_entry + 92) & 0xBF;
        cached = conn->cached;
        if ( cached->head )
        {
          mem_free(cached->head);
          cached = conn->cached;
        }
        cached->head = opaquea;
        if ( !get_opt_(config_options, "document.cache.ignore_cache_control")->number )
        {
          v59 = conn->cached;
          d = parse_header(v59->head, (unsigned __int8 *)&byte_8127C42, 0);
          if ( d )
          {
            v60 = parse_date(&d, 0, 0, 1);
            mem_free(d);
            if ( v60 )
            {
              if ( v59->cache_mode != CACHE_MODE_NEVER )
              {
                timeval_from_seconds(&v59->max_age, v60);
                *((_BYTE *)v59 + 92) |= 1u;
              }
            }
          }
          v61 = parse_header(v59->head, "Pragma", 0);
          v62 = v61;
          d = v61;
          if ( v61 )
          {
            if ( strstr((const char *)v61, "no-cache") )
            {
              *((_BYTE *)v59 + 92) &= ~1u;
              v59->cache_mode = CACHE_MODE_NEVER;
              v62 = d;
            }
            mem_free(v62);
          }
          if ( v59->cache_mode != CACHE_MODE_NEVER )
          {
            v63 = parse_header(v59->head, "Cache-Control", 0);
            v64 = (const char *)v63;
            d = v63;
            if ( v63 )
            {
              if ( strstr((const char *)v63, "no-cache") || strstr(v64, "must-revalidate") )
              {
                *((_BYTE *)v59 + 92) &= ~1u;
                v59->cache_mode = CACHE_MODE_NEVER;
              }
              else
              {
                v70 = strstr(v64, "max-age=");
                if ( !assert_failed )
                {
                  v71 = v59->cache_mode != CACHE_MODE_NEVER;
                  assert_failed = v59->cache_mode == CACHE_MODE_NEVER;
                  if ( !v71 )
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
                    errline = 1667;
                    elinks_internal("assertion cached->cache_mode != CACHE_MODE_NEVER failed!");
                  }
                }
                if ( v70 )
                {
                  v72 = strtol(v70 + 8, 0, 10);
                  timeval_from_seconds(&max_age, v72);
                  timeval_now(&v59->max_age);
                  timeval_add_interval(&v59->max_age, &max_age);
                  *((_BYTE *)v59 + 92) |= 1u;
                }
              }
              mem_free(d);
            }
          }
        }
        if ( h == 301 || h == 201 || h == 302 || h == 303 || h == 307 )
        {
          v23 = parse_header(conn->cached->head, "Location", 0);
          d = v23;
          if ( v23 )
          {
            v24 = h == 303;
            if ( h == 302 )
            {
              if ( get_opt_(config_options, "protocol.http.bugs.broken_302_redirect")->number )
              {
                v23 = d;
                v24 = 1;
              }
              else
              {
                v23 = d;
              }
            }
            redirect_cache(conn->cached, v23, v24, -1);
            mem_free(d);
          }
        }
        if ( h == 401 )
        {
          for ( k = parse_header(conn->cached->head, "WWW-Authenticate", &str);
                ;
                k = parse_header(str, "WWW-Authenticate", &str) )
          {
            if ( !k )
              goto LABEL_96;
            if ( c_strncasecmp((const char *)k, "Basic", 5u) )
            {
              if ( !c_strncasecmp((const char *)k, "Digest", 6u) )
              {
                header_param = get_header_param(k, "realm");
                opaquee = get_header_param(k, "nonce");
                hb = get_header_param(k, "opaque");
                add_auth_entry(proxied_uri, header_param, opaquee, hb, 1u);
                if ( header_param )
                  mem_free(header_param);
                if ( opaquee )
                  mem_free(opaquee);
                if ( hb )
                  mem_free(hb);
                mem_free(k);
                goto LABEL_96;
              }
              if ( !c_strncasecmp((const char *)k, "GSS-Negotiate", 0xEu) )
              {
                v55 = http_negotiate_input(conn, proxied_uri, 1, str);
                goto LABEL_216;
              }
              if ( !c_strncasecmp((const char *)k, "Negotiate", 0xAu) )
              {
                v55 = http_negotiate_input(conn, proxied_uri, 2, str);
LABEL_216:
                v56 = v55 == 0;
                mem_free(k);
                if ( !v56 )
                  goto LABEL_96;
                v57 = S_RESTART;
                goto LABEL_218;
              }
            }
            else
            {
              v54 = get_header_param(k, "realm");
              if ( v54 )
              {
                t = (timeval_T *)v54;
                add_auth_entry(proxied_uri, v54, 0, 0, 0);
                mem_free(t);
                mem_free(k);
                goto LABEL_96;
              }
            }
            mem_free(k);
          }
        }
        if ( h == 407 )
        {
          v49 = parse_header(conn->cached->head, "Proxy-Authenticate", &str);
          d = v49;
          while ( v49 )
          {
            if ( c_strncasecmp((const char *)v49, "Basic", 5u) )
            {
              if ( !c_strncasecmp((const char *)d, "Digest", 6u) )
              {
                v51 = get_header_param(d, "realm");
                v52 = get_header_param(d, "nonce");
                opaquec = get_header_param(d, "opaque");
                if ( proxy_auth.realm )
                  mem_free(proxy_auth.realm);
                proxy_auth.realm = v51;
                if ( proxy_auth.nonce )
                  mem_free(proxy_auth.nonce);
                proxy_auth.nonce = v52;
                if ( proxy_auth.opaque )
                  mem_free(proxy_auth.opaque);
                *((_BYTE *)&proxy_auth + 112) |= 4u;
                proxy_auth.opaque = opaquec;
                mem_free(d);
                break;
              }
            }
            else
            {
              v50 = get_header_param(d, "realm");
              if ( v50 )
              {
                if ( proxy_auth.realm )
                  mem_free(proxy_auth.realm);
                *((_BYTE *)&proxy_auth + 112) &= ~4u;
                proxy_auth.realm = v50;
                mem_free(d);
                break;
              }
            }
            mem_free(d);
            v49 = parse_header(str, "Proxy-Authenticate", &str);
            d = v49;
          }
        }
LABEL_96:
        kill_buffer_data(v2, aa);
        http->close = 0;
        http->length = -1;
        http->recv_version.minor = v83;
        http->recv_version.major = HIDWORD(v83);
        v25 = parse_header(conn->cached->head, "Connection", 0);
        d = v25;
        if ( v25 || (v25 = parse_header(conn->cached->head, (unsigned __int8 *)&byte_8132CAD, 0), (d = v25) != 0) )
        {
          if ( !c_strcasecmp((const char *)v25, "close") )
            http->close = 1;
          mem_free(d);
        }
        else if ( SHIDWORD(v83) <= 0 || v83 <= 0x100000000LL )
        {
          http->close = 1;
        }
        opaqueb = (unsigned __int8 *)conn->from;
        LODWORD(conn->from) = 0;
        HIDWORD(conn->from) = 0;
        v26 = parse_header(conn->cached->head, "Content-Range", 0);
        d = v26;
        if ( v26 )
        {
          if ( strlen((const char *)v26) > 6 )
          {
            v26[5] = 0;
            v26 = d;
            if ( (unsigned __int8)(d[6] - 48) <= 9u )
            {
              if ( !c_strcasecmp((const char *)d, (const char *)"bytes") )
              {
                v75 = __errno_location();
                *v75 = 0;
                v76 = v75;
                v77 = strtol((const char *)d + 6, 0, 10);
                if ( !*v76 && v77 >= 0 )
                  conn->from = v77;
              }
              v26 = d;
            }
          }
          mem_free(v26);
        }
        if ( opaqueb )
        {
          from = conn->from;
          if ( !from )
          {
            v48 = *((_BYTE *)conn + 120);
            if ( (v48 & 2) == 0 )
              *((_BYTE *)conn + 120) = v48 | 2;
          }
        }
        else
        {
          from = conn->from;
        }
        progress = conn->progress;
        if ( progress->start <= 0 && from > (int)opaqueb || from < 0 )
        {
          connection_state_7(S_HTTP_ERROR, &state.basic);
          abort_connection(conn, state);
          return;
        }
        if ( progress->start >= 0 )
        {
          progress->seek = from;
          progress = conn->progress;
          from = conn->from;
        }
        progress->start = from;
        d = parse_header(conn->cached->head, "Content-Length", 0);
        if ( d )
        {
          v29 = __errno_location();
          *v29 = 0;
          v30 = v29;
          v31 = strtol((const char *)d, (char **)&str, 10);
          if ( !*v30 && v31 >= 0 && !*str )
          {
            if ( !http->close || SHIDWORD(v83) > 1 || HIDWORD(v83) == 1 && (int)v83 > 0 )
              http->length = v31;
            conn->est_length = conn->from + v31;
          }
          mem_free(d);
        }
        if ( (*((_BYTE *)conn + 120) & 2) == 0 )
        {
          v58 = parse_header(conn->cached->head, "Accept-Ranges", 0);
          d = v58;
          if ( v58 )
          {
            if ( !c_strcasecmp((const char *)v58, "none") )
              *((_BYTE *)conn + 120) |= 2u;
            mem_free(d);
          }
          else if ( !conn->from )
          {
            *((_BYTE *)conn + 120) |= 2u;
          }
        }
        v32 = parse_header(conn->cached->head, (unsigned __int8 *)&byte_8132CE9, 0);
        d = v32;
        if ( v32 )
        {
          if ( !c_strcasecmp((const char *)v32, "chunked") )
          {
            http->length = -2;
            http->chunk_remaining = -1;
          }
          mem_free(d);
        }
        if ( !http->close && http->length == -1 )
          http->close = 1;
        v33 = parse_header(conn->cached->head, "Last-Modified", 0);
        d = v33;
        if ( v33 )
        {
          v34 = conn->cached;
          last_modified = (const char *)v34->last_modified;
          if ( last_modified )
          {
            if ( c_strcasecmp(last_modified, (const char *)v33) )
            {
              delete_entry_content(conn->cached);
              if ( conn->from )
              {
                LODWORD(conn->from) = 0;
                HIDWORD(conn->from) = 0;
                mem_free(d);
                connection_state_7(S_MODIFIED, &state.basic);
                retry_connection(conn, state);
                return;
              }
            }
            v34 = conn->cached;
            if ( v34->last_modified )
            {
              mem_free(d);
              goto LABEL_132;
            }
            v33 = d;
          }
          v34->last_modified = v33;
        }
LABEL_132:
        v36 = conn->cached;
        if ( !v36->last_modified )
        {
          v73 = parse_header(v36->head, (unsigned __int8 *)&byte_812B3D6, 0);
          d = v73;
          if ( v73 )
            conn->cached->last_modified = v73;
          v36 = conn->cached;
        }
        v37 = parse_header(v36->head, "ETag", 0);
        d = v37;
        if ( !v37 )
          goto LABEL_140;
        v38 = conn->cached;
        etag = v38->etag;
        if ( etag )
        {
          if ( *v37 != 87 || (v40 = (const char *)(v37 + 2), v37[1] != 47) )
            v40 = (const char *)v37;
          if ( *etag == 87 && etag[1] == 47 )
            etag += 2;
          if ( !strcmp(v40, (const char *)etag) )
            goto LABEL_139;
          delete_entry_content(v38);
          if ( conn->from )
          {
            LODWORD(conn->from) = 0;
            HIDWORD(conn->from) = 0;
            mem_free(d);
            v57 = S_MODIFIED;
LABEL_218:
            connection_state_7(v57, &state.basic);
            retry_connection(conn, state);
            return;
          }
          v38 = conn->cached;
          if ( v38->etag )
          {
            v37 = d;
LABEL_139:
            mem_free(v37);
LABEL_140:
            d = parse_header(conn->cached->head, "Content-Encoding", 0);
            if ( d )
            {
              v41 = ENCODING_NONE;
              extension_from_uri = get_extension_from_uri(proxied_uri);
              v43 = extension_from_uri;
              if ( !extension_from_uri
                || (v41 = guess_encoding(extension_from_uri), mem_free(v43), v41 != ENCODING_GZIP) )
              {
                if ( !c_strcasecmp((const char *)d, "gzip") || !c_strcasecmp((const char *)d, "x-gzip") )
                  conn->content_encoding = ENCODING_GZIP;
              }
              if ( !c_strcasecmp((const char *)d, "deflate") || !c_strcasecmp((const char *)d, "x-deflate") )
                conn->content_encoding = ENCODING_DEFLATE;
              if ( v41 != ENCODING_BZIP2
                && (!c_strcasecmp((const char *)d, "bzip2") || !c_strcasecmp((const char *)d, "x-bzip2")) )
              {
                conn->content_encoding = ENCODING_BZIP2;
              }
              mem_free(d);
            }
            content_encoding = conn->content_encoding;
            if ( content_encoding )
            {
              v45 = conn->cached;
              if ( v45->encoding_info )
              {
                mem_free(v45->encoding_info);
                v45 = conn->cached;
                content_encoding = conn->content_encoding;
              }
              encoding_name = get_encoding_name(content_encoding);
              v45->encoding_info = stracpy(encoding_name);
            }
            if ( http->length == -1 || http->close )
              socket->state = SOCKET_END_ONCLOSE;
            read_http_data(socket, v2);
            return;
          }
          v37 = d;
        }
        v38->etag = v37;
        goto LABEL_140;
      }
      mem_free(opaquea);
      v65 = S_OUT_OF_MEM;
LABEL_240:
      connection_state_7(v65, &state.basic);
      abort_connection(conn, state);
      return;
    }
    break;
  }
  opaquea = memacpy((const unsigned __int8 *)s1, aa);
  if ( opaquea )
    goto LABEL_39;
LABEL_56:
  if ( assert_failed )
    goto LABEL_25;
  assert_failed = 0;
  v9 = -100004;
LABEL_34:
  abort_connection(conn, (connection_state)(unsigned int)v9);
}
// 810CD4C: using guessed type char *buggy_servers_9226[3];

//----- (080D0F30) --------------------------------------------------------
unsigned __int8 *__cdecl subst_user_agent(
        unsigned __int8 *fmt,
        unsigned __int8 *version,
        unsigned __int8 *sysname,
        unsigned __int8 *termsize)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  unsigned __int8 v7; // al
  int v8; // ecx
  size_t v9; // edi
  unsigned __int8 *v10; // esi
  unsigned __int8 v11; // al
  unsigned __int8 v12; // al
  int length; // edi
  size_t v14; // edx
  unsigned int v15; // ecx
  int v16; // ecx
  unsigned int v17; // eax
  size_t v18; // edx
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  size_t v22; // [esp+24h] [ebp-34h]
  size_t v23; // [esp+24h] [ebp-34h]
  int v24; // [esp+28h] [ebp-30h]
  int v25; // [esp+28h] [ebp-30h]
  int v26; // [esp+28h] [ebp-30h]
  unsigned int v27; // [esp+28h] [ebp-30h]
  int v28; // [esp+2Ch] [ebp-2Ch]
  unsigned int v29; // [esp+2Ch] [ebp-2Ch]
  string agent; // [esp+30h] [ebp-28h] BYREF
  int blen; // [esp+38h] [ebp-20h] BYREF
  unsigned __int8 bs[4]; // [esp+3Ch] [ebp-1Ch] BYREF

  inited = init_string(&agent);
  result = 0;
  if ( inited )
  {
LABEL_2:
    v7 = *fmt;
    while ( 1 )
    {
      if ( !v7 )
        return agent.source;
      v8 = 0;
      v9 = 0;
      v10 = fmt;
      if ( v7 != 37 )
      {
        do
        {
          v11 = fmt[++v8];
          v9 = v8;
          v10 = &fmt[v8];
        }
        while ( v11 != 37 && v11 );
      }
      if ( assert_failed )
        break;
      if ( v8 < 0 )
      {
        v25 = v8;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        v8 = v25;
        if ( assert_failed )
          break;
      }
      else
      {
        assert_failed = 0;
      }
      if ( v8 )
      {
        v16 = agent.length + v8;
        v17 = agent.length + 255;
        v18 = v16 + 256;
        LOBYTE(v17) = 0;
        LOBYTE(v18) = 0;
        v29 = v17;
        if ( v18 <= v17 )
          goto LABEL_23;
        v22 = v18;
        v26 = v16;
        v20 = (unsigned __int8 *)mem_realloc(agent.source, v18);
        if ( v20 )
        {
          agent.source = v20;
          memset(&v20[v29], 0, v22 - v29);
          v16 = v26;
LABEL_23:
          if ( agent.source )
          {
            v24 = v16;
            memcpy(&agent.source[agent.length], fmt, v9);
            agent.source[v24] = 0;
            agent.length = v24;
          }
        }
      }
LABEL_10:
      v7 = *v10;
      fmt = v10;
      if ( *v10 == 37 )
      {
        v12 = v10[1];
        fmt = v10 + 1;
        if ( v12 == 115 )
        {
          add_to_string(&agent, sysname);
          v7 = v10[1];
          goto LABEL_33;
        }
        if ( v12 > 0x73u )
        {
          if ( v12 == 116 )
          {
            if ( !termsize )
            {
LABEL_34:
              fmt = v10 + 2;
              goto LABEL_2;
            }
            v19 = termsize;
            goto LABEL_32;
          }
          if ( v12 == 118 )
          {
            v19 = version;
LABEL_32:
            add_to_string(&agent, v19);
            v7 = *fmt;
            goto LABEL_33;
          }
        }
        else if ( v12 == 98 )
        {
          if ( sessions.next == &sessions )
            goto LABEL_34;
          blen = 0;
          *(_DWORD *)bs = 0;
          elinks_ulongcat(
            bs,
            (unsigned int *)&blen,
            (*((_BYTE *)sessions.prev + 168) & 1)
          + ((*((_BYTE *)sessions.prev + 168) & 2) != 0)
          + ((*((_BYTE *)sessions.prev + 168) & 4) != 0),
            2u,
            0,
            0xAu,
            0);
          v19 = bs;
          goto LABEL_32;
        }
        if ( assert_failed )
        {
          assert_failed = 0;
          v7 = *fmt;
          goto LABEL_33;
        }
        length = agent.length;
        assert_failed = 0;
        v14 = agent.length + 258;
        v15 = agent.length + 255;
        LOBYTE(v14) = 0;
        LOBYTE(v15) = 0;
        v28 = agent.length + 2;
        if ( v14 <= v15 )
          goto LABEL_16;
        v23 = v14;
        v27 = v15;
        v21 = (unsigned __int8 *)mem_realloc(agent.source, v14);
        if ( v21 )
        {
          agent.source = v21;
          memset(&v21[v27], 0, v23 - v27);
LABEL_16:
          if ( agent.source )
          {
            *(_WORD *)&agent.source[agent.length] = *(_WORD *)v10;
            agent.source[length + 2] = 0;
            agent.length = v28;
          }
        }
        v7 = *fmt;
LABEL_33:
        if ( v7 )
          goto LABEL_34;
      }
    }
    assert_failed = 0;
    goto LABEL_10;
  }
  return result;
}

//----- (080D1260) --------------------------------------------------------
void __cdecl http_send_header(socket *socket)
{
  connection *conn; // ebx
  option_value *opt; // eax
  uri *proxied_uri; // esi
  int number; // edi
  unsigned __int8 *host; // eax
  uri *uri; // edx
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // edi
  unsigned __int8 *v9; // edx
  option_value *v10; // eax
  unsigned __int8 *v11; // edx
  unsigned __int8 v12; // al
  unsigned __int8 *v13; // edx
  _DWORD *prev; // edi
  unsigned int v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // edi
  option_value *v18; // eax
  unsigned __int8 *v19; // edi
  cache_entry *cached; // eax
  unsigned __int8 *post; // ebx
  char *v22; // eax
  char *v23; // edi
  size_t v24; // eax
  string *v25; // esi
  int v26; // esi
  unsigned int v27; // edi
  unsigned __int8 v28; // al
  char v29; // dl
  int v30; // edi
  unsigned int v31; // edi
  char v32; // cl
  unsigned __int8 v33; // al
  int v34; // edx
  unsigned int v35; // esi
  unsigned int v36; // edi
  unsigned __int8 *v37; // eax
  unsigned __int8 *v38; // esi
  unsigned __int8 *v39; // edi
  int v40; // eax
  unsigned __int8 *v41; // edi
  unsigned __int8 *v42; // esi
  int v43; // eax
  int from; // eax
  signed int v45; // edx
  signed int v46; // eax
  unsigned __int8 *v47; // edx
  int v48; // edi
  unsigned __int8 *http_auth_digest_response; // edi
  int v50; // eax
  uri *referrer; // edx
  auth_entry *auth; // eax
  unsigned __int8 *v53; // ebx
  unsigned __int8 *v54; // eax
  unsigned __int8 *v55; // ebx
  unsigned __int8 *v56; // edi
  option_value *v57; // eax
  const unsigned __int8 *v58; // edi
  int i; // ebx
  unsigned __int8 *cp_mime_name; // edi
  int length; // eax
  unsigned __int8 *v62; // eax
  __int16 v63; // ax
  unsigned __int8 *sourcec; // [esp+30h] [ebp-1058h]
  unsigned __int8 *source; // [esp+30h] [ebp-1058h]
  char sourced; // [esp+30h] [ebp-1058h]
  unsigned __int8 *sourcea; // [esp+30h] [ebp-1058h]
  unsigned __int8 *sourceb; // [esp+30h] [ebp-1058h]
  unsigned __int8 *passwd; // [esp+34h] [ebp-1054h]
  _BOOL4 user; // [esp+38h] [ebp-1050h]
  unsigned __int8 *usera; // [esp+38h] [ebp-1050h]
  unsigned __int8 *userb; // [esp+38h] [ebp-1050h]
  int use_connect; // [esp+3Ch] [ebp-104Ch]
  unsigned int use_connecta; // [esp+3Ch] [ebp-104Ch]
  http_connection_info *http; // [esp+40h] [ebp-1048h]
  http_connection_info *httpa; // [esp+40h] [ebp-1048h]
  connection_state state; // [esp+48h] [ebp-1040h] BYREF
  string string; // [esp+58h] [ebp-1030h] BYREF
  string header; // [esp+60h] [ebp-1028h] BYREF
  unsigned int tslen; // [esp+68h] [ebp-1020h] BYREF
  unsigned __int8 buffer[4096]; // [esp+6Ch] [ebp-101Ch] BYREF
  unsigned int v82; // [esp+106Ch] [ebp-1Ch]
  connection_state v83; // 0:edx.8

  v82 = __readgsdword(0x14u);
  conn = (connection *)socket->conn;
  opt = get_opt_(config_options, "protocol.http.trace");
  proxied_uri = conn->proxied_uri;
  number = opt->number;
  if ( !proxied_uri || (host = proxied_uri->host) == 0 || !*host || !*((_WORD *)proxied_uri + 23) )
  {
    if ( assert_failed )
    {
      assert_failed = 0;
      v83.basic = S_INTERNAL;
    }
    else
    {
      assert_failed = 0;
      v83.basic = S_BAD_URL;
    }
    v83.syserr = 0;
    http_end_request(conn, v83, 0);
    return;
  }
  http = init_http_connection_info(conn, 1, 1, 0);
  if ( !http )
    return;
  if ( !init_string(&header) )
  {
    connection_state_7(S_OUT_OF_MEM, &state.basic);
    http_end_request(conn, state, 0);
    return;
  }
  if ( !conn->cached )
    conn->cached = find_in_cache(proxied_uri);
  user = 0;
  if ( conn->uri->protocol != 15
    || (user = conn->socket->ssl == 0, conn->proxied_uri->protocol != 10)
    || (use_connect = 1, conn->socket->ssl) )
  {
    use_connect = 0;
  }
  if ( number )
  {
    add_to_string(&header, "TRACE ");
  }
  else if ( use_connect )
  {
    add_to_string(&header, "CONNECT ");
  }
  else if ( proxied_uri->post )
  {
    add_to_string(&header, "POST ");
    *((_BYTE *)conn + 120) |= 2u;
  }
  else
  {
    add_to_string(&header, "GET ");
  }
  if ( !user )
    add_char_to_string(&header, 0x2Fu);
  if ( use_connect )
  {
    add_uri_to_string(&header, proxied_uri, URI_HTTP_CONNECT);
    goto LABEL_138;
  }
  uri = conn->uri;
  if ( uri->protocol == 15 && conn->proxied_uri->protocol == 10 && conn->socket->ssl )
  {
    add_url_to_http_string(&header, proxied_uri, 128);
LABEL_138:
    add_to_string(&header, &byte_8132D6A);
    add_long_to_string(&header, http->sent_version.major);
    add_char_to_string(&header, 0x2Eu);
    add_long_to_string(&header, http->sent_version.minor);
    add_crlf_to_string(&header);
    add_to_string(&header, "Host: ");
    add_uri_to_string(&header, proxied_uri, URI_HTTP_HOST);
    add_crlf_to_string(&header);
    if ( !user )
      goto LABEL_33;
    goto LABEL_26;
  }
  if ( !user )
  {
    add_url_to_http_string(&header, uri, 128);
    add_to_string(&header, &byte_8132D6A);
    add_long_to_string(&header, http->sent_version.major);
    add_char_to_string(&header, 0x2Eu);
    add_long_to_string(&header, http->sent_version.minor);
    add_crlf_to_string(&header);
    add_to_string(&header, "Host: ");
    add_uri_to_string(&header, proxied_uri, URI_HTTP_HOST);
    add_crlf_to_string(&header);
    goto LABEL_33;
  }
  add_url_to_http_string(&header, proxied_uri, -30529);
  add_to_string(&header, &byte_8132D6A);
  add_long_to_string(&header, http->sent_version.major);
  add_char_to_string(&header, 0x2Eu);
  add_long_to_string(&header, http->sent_version.minor);
  add_crlf_to_string(&header);
  add_to_string(&header, "Host: ");
  add_uri_to_string(&header, proxied_uri, URI_HTTP_HOST);
  add_crlf_to_string(&header);
LABEL_26:
  usera = (unsigned __int8 *)get_opt_(config_options, "protocol.http.proxy.user")->number;
  passwd = (unsigned __int8 *)get_opt_(config_options, "protocol.http.proxy.passwd")->number;
  if ( (*((_BYTE *)&proxy_auth + 112) & 4) != 0 )
  {
    v45 = strlen((const char *)usera);
    if ( v45 >= 39 )
      v45 = 39;
    sourcea = (unsigned __int8 *)v45;
    v46 = strlen((const char *)passwd);
    v47 = sourcea;
    v48 = v46;
    if ( v46 >= 39 )
      v48 = 39;
    if ( sourcea )
    {
      __memcpy_chk(135589888, usera, sourcea, 84);
      v47 = sourcea;
    }
    v47[135589888] = 0;
    if ( v48 )
      __memcpy_chk(135589928, passwd, v48, 44);
    *(_BYTE *)(v48 + 135589928) = 0;
    http_auth_digest_response = get_http_auth_digest_response(&proxy_auth, proxied_uri);
    if ( http_auth_digest_response )
    {
      add_to_string(&header, "Proxy-Authorization: Digest ");
      add_to_string(&header, http_auth_digest_response);
      add_crlf_to_string(&header);
      mem_free(http_auth_digest_response);
    }
  }
  else if ( *usera )
  {
    v7 = straconcat(usera, &buf, passwd, 0);
    v8 = v7;
    if ( v7 )
    {
      v9 = base64_encode(v7);
      if ( v9 )
      {
        sourcec = v9;
        add_to_string(&header, "Proxy-Authorization: Basic ");
        add_to_string(&header, sourcec);
        add_crlf_to_string(&header);
        mem_free(sourcec);
      }
      mem_free(v8);
    }
  }
LABEL_33:
  v10 = get_opt_(config_options, "protocol.http.user_agent");
  v11 = (unsigned __int8 *)v10->number;
  v12 = *v10->string;
  if ( v12 && (v12 != 32 || v11[1]) )
  {
    source = v11;
    memset(buffer, 0, 64);
    add_to_string(&header, "User-Agent: ");
    v13 = source;
    if ( terminals.next != &terminals )
    {
      prev = terminals.prev;
      tslen = 0;
      elinks_ulongcat(buffer, &tslen, *((_DWORD *)terminals.prev + 11), 3u, 0, 0xAu, 0);
      v15 = tslen;
      buffer[tslen] = 120;
      tslen = v15 + 1;
      elinks_ulongcat(buffer, &tslen, prev[12], 3u, 0, 0xAu, 0);
      v13 = source;
    }
    v16 = subst_user_agent(v13, "0.12pre5", system_name, buffer);
    v17 = v16;
    if ( v16 )
    {
      add_to_string(&header, v16);
      mem_free(v17);
    }
    add_crlf_to_string(&header);
  }
  if ( !use_connect )
  {
    v50 = get_opt_(config_options, "protocol.http.referer.policy")->number;
    if ( v50 != 2 )
    {
      if ( v50 == 3 )
      {
        if ( !conn->referrer )
          goto LABEL_42;
        add_to_string(&header, "Referer: ");
        referrer = conn->referrer;
      }
      else
      {
        if ( v50 != 1 )
          goto LABEL_42;
        add_to_string(&header, "Referer: ");
        referrer = proxied_uri;
      }
      add_url_to_http_string(&header, referrer, 177);
      add_crlf_to_string(&header);
      goto LABEL_42;
    }
    v57 = get_opt_(config_options, "protocol.http.referer.fake");
    v58 = (const unsigned __int8 *)v57->number;
    if ( *v57->string )
    {
      add_to_string(&header, "Referer: ");
      add_to_string(&header, v58);
      add_crlf_to_string(&header);
    }
  }
LABEL_42:
  add_to_string(&header, "Accept: */*");
  add_crlf_to_string(&header);
  if ( get_opt_(config_options, "protocol.http.compression")->number )
  {
    add_to_string(&header, "Accept-Encoding: ");
    add_to_string(&header, "bzip2");
    add_to_string(&header, ", ");
    add_to_string(&header, &byte_8132E34);
    add_crlf_to_string(&header);
  }
  if ( !accept_charset && init_string(&string) )
  {
    userb = (unsigned __int8 *)conn;
    for ( i = 0; ; ++i )
    {
      cp_mime_name = get_cp_mime_name(i);
      if ( !cp_mime_name )
        break;
      if ( string.length )
        add_to_string(&string, ", ");
      else
        add_to_string(&string, &byte_8132E42);
      add_to_string(&string, cp_mime_name);
    }
    length = 0;
    conn = (connection *)userb;
    if ( string.length )
    {
      add_crlf_to_string(&string);
      length = string.length;
    }
    accept_charset = memacpy(string.source, length);
    done_string(&string);
  }
  if ( (http->bl_flags & 2) == 0
    && !get_opt_(config_options, "protocol.http.bugs.accept_charset")->number
    && accept_charset )
  {
    add_to_string(&header, accept_charset);
  }
  v18 = get_opt_(config_options, "protocol.http.accept_language");
  v19 = (unsigned __int8 *)v18->number;
  if ( *v18->string
    || get_opt_(config_options, "protocol.http.accept_ui_language")->number
    && (v19 = language_to_iso639(current_language)) != 0 )
  {
    add_to_string(&header, "Accept-Language: ");
    add_to_string(&header, v19);
    add_crlf_to_string(&header);
  }
  if ( http->sent_version.major == 1 && http->sent_version.minor == 1 )
  {
    if ( conn->uri->protocol == 15 )
      add_to_string(&header, &byte_8132E65);
    else
      add_to_string(&header, "Connection: ");
    if ( proxied_uri->post && get_opt_(config_options, "protocol.http.bugs.post_no_keepalive")->number )
      add_to_string(&header, "close");
    else
      add_to_string(&header, "Keep-Alive");
    add_crlf_to_string(&header);
  }
  if ( use_connect || (cached = conn->cached) == 0 || (*((_BYTE *)cached + 92) & 8) != 0 || !cached->head )
  {
LABEL_58:
    if ( conn->cache_mode <= CACHE_MODE_CHECK_IF_MODIFIED )
      goto LABEL_59;
    goto LABEL_144;
  }
  if ( conn->cache_mode <= CACHE_MODE_CHECK_IF_MODIFIED )
  {
    if ( cached->last_modified )
    {
      add_to_string(&header, "If-Modified-Since: ");
      add_to_string(&header, conn->cached->last_modified);
      add_crlf_to_string(&header);
      cached = conn->cached;
    }
    if ( cached->etag )
    {
      add_to_string(&header, "If-None-Match: ");
      add_to_string(&header, conn->cached->etag);
      add_crlf_to_string(&header);
    }
    goto LABEL_58;
  }
LABEL_144:
  add_to_string(&header, &byte_8132EA7);
  add_crlf_to_string(&header);
  add_to_string(&header, "Cache-Control: no-cache");
  add_crlf_to_string(&header);
LABEL_59:
  if ( use_connect )
  {
    add_crlf_to_string(&header);
    goto LABEL_115;
  }
  if ( conn->from || conn->progress->start > 0 )
  {
    add_to_string(&header, "Range: bytes=");
    from = conn->from;
    if ( !conn->from )
      from = conn->progress->start;
    add_long_to_string(&header, from);
    add_char_to_string(&header, 0x2Du);
    add_crlf_to_string(&header);
  }
  if ( http_negotiate_output(proxied_uri, &header) )
  {
    auth = find_auth(proxied_uri);
    if ( auth )
    {
      if ( (*((_BYTE *)auth + 112) & 4) != 0 )
      {
        v53 = get_http_auth_digest_response(auth, proxied_uri);
        if ( v53 )
        {
          add_to_string(&header, "Authorization: Digest ");
          add_to_string(&header, v53);
          add_crlf_to_string(&header);
          mem_free(v53);
        }
      }
      else
      {
        v54 = straconcat(auth->user, &buf, auth->password, 0);
        v55 = v54;
        if ( v54 )
        {
          v56 = base64_encode(v54);
          mem_free(v55);
          if ( v56 )
          {
            add_to_string(&header, "Authorization: Basic ");
            add_to_string(&header, v56);
            add_crlf_to_string(&header);
            mem_free(v56);
          }
        }
      }
    }
  }
  post = proxied_uri->post;
  if ( post )
  {
    v22 = strchr((const char *)post, 10);
    v23 = v22;
    if ( v22 )
    {
      post = (unsigned __int8 *)(v22 + 1);
      add_to_string(&header, "Content-Type: ");
      add_bytes_to_string___4(&header, proxied_uri->post, v23 - (char *)proxied_uri->post);
      add_crlf_to_string(&header);
    }
    add_to_string(&header, "Content-Length: ");
    v24 = strlen((const char *)post);
    add_long_to_string(&header, v24 >> 1);
    add_crlf_to_string(&header);
  }
  v25 = send_cookies(proxied_uri);
  if ( v25 )
  {
    add_to_string(&header, "Cookie: ");
    add_string_to_string(&header, v25);
    add_crlf_to_string(&header);
    done_string(v25);
  }
  add_crlf_to_string(&header);
  if ( post )
  {
    if ( !assert_failed )
      assert_failed = 0;
    v26 = 0;
    while ( 1 )
    {
      v33 = *post;
      if ( !*post || !post[1] )
      {
        if ( v26 )
          add_bytes_to_string___4(&header, buffer, v26);
        break;
      }
      if ( (unsigned __int8)(v33 - 48) <= 9u )
      {
        v27 = v33 - 48;
      }
      else
      {
        if ( (unsigned __int8)(v33 - 97) <= 5u )
        {
          v27 = v33 - 87;
          if ( assert_failed )
            goto LABEL_86;
          goto LABEL_75;
        }
        v27 = v33 - 55;
        if ( (unsigned __int8)(v33 - 65) >= 6u )
          v27 = -1;
      }
      if ( assert_failed )
        goto LABEL_86;
LABEL_75:
      assert_failed = v27 > 0xF;
      if ( v27 <= 0xF
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c",
            errline = 998,
            elinks_internal(
              "assertion h1 >= 0 && h1 < 16 failed: h1 in the POST buffer is %d (%d/%c)",
              v27,
              *post,
              *post),
            !assert_failed) )
      {
        v28 = post[1];
        v29 = 16 * v27;
        v30 = v28;
        if ( (unsigned __int8)(v28 - 48) <= 9u )
          goto LABEL_77;
        goto LABEL_87;
      }
LABEL_86:
      assert_failed = 0;
      v28 = post[1];
      v29 = 0;
      v30 = v28;
      if ( (unsigned __int8)(v28 - 48) <= 9u )
      {
LABEL_77:
        v31 = v30 - 48;
        goto LABEL_78;
      }
LABEL_87:
      if ( (unsigned __int8)(v28 - 97) <= 5u )
      {
        v31 = v30 - 87;
        goto LABEL_78;
      }
      if ( (unsigned __int8)(v28 - 65) <= 5u )
      {
        v31 = v30 - 55;
LABEL_78:
        v32 = v31;
        assert_failed = v31 > 0xF;
        if ( v31 <= 0xF )
          goto LABEL_79;
        goto LABEL_97;
      }
      assert_failed = 1;
      v31 = -1;
LABEL_97:
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/http/http.c";
      errline = 1002;
      sourced = v29;
      elinks_internal("assertion h2 >= 0 && h2 < 16 failed: h2 in the POST buffer is %d (%d/%c)", v31, post[1], post[1]);
      v29 = sourced;
      if ( assert_failed )
      {
        assert_failed = 0;
        v32 = 0;
      }
      else
      {
        v32 = v31;
      }
LABEL_79:
      buffer[v26++] = v32 + v29;
      if ( v26 != 4096 )
        goto LABEL_80;
      if ( assert_failed )
      {
        assert_failed = 0;
        v26 = 0;
      }
      else
      {
        v34 = header.length;
        assert_failed = 0;
        v35 = (header.length + 4352) & 0xFFFFFF00;
        v36 = (header.length + 255) & 0xFFFFFF00;
        httpa = (http_connection_info *)(header.length + 4096);
        if ( v35 > v36 )
        {
          sourceb = (unsigned __int8 *)header.length;
          v62 = (unsigned __int8 *)mem_realloc(header.source, (header.length + 4352) & 0xFFFFFF00);
          if ( !v62 )
          {
LABEL_112:
            v26 = 0;
            goto LABEL_80;
          }
          header.source = v62;
          memset(&v62[v36], 0, v35 - v36);
          v34 = (int)sourceb;
        }
        if ( !header.source )
          goto LABEL_112;
        v37 = &header.source[header.length];
        v38 = buffer;
        use_connecta = 4096;
        v39 = &header.source[header.length];
        if ( ((LOBYTE(header.length) + LOBYTE(header.source)) & 1) != 0 )
        {
          v39 = v37 + 1;
          v38 = &buffer[1];
          *v37 = buffer[0];
          use_connecta = 4095;
        }
        if ( ((unsigned __int8)v39 & 2) != 0 )
        {
          v63 = *(_WORD *)v38;
          v38 += 2;
          *(_WORD *)v39 = v63;
          v39 += 2;
          use_connecta -= 2;
        }
        v40 = 0;
        qmemcpy(v39, v38, 4 * (use_connecta >> 2));
        v42 = &v38[4 * (use_connecta >> 2)];
        v41 = &v39[4 * (use_connecta >> 2)];
        if ( (use_connecta & 2) != 0 )
        {
          *(_WORD *)v41 = *(_WORD *)v42;
          v40 = 2;
        }
        if ( (use_connecta & 1) != 0 )
          v41[v40] = v42[v40];
        v26 = 0;
        header.source[v34 + 4096] = 0;
        header.length = (int)httpa;
      }
LABEL_80:
      post += 2;
    }
  }
LABEL_115:
  if ( assert_failed )
  {
    assert_failed = 0;
    v43 = -100003;
  }
  else
  {
    assert_failed = 0;
    v43 = 4;
  }
  request_from_socket(
    socket,
    header.source,
    header.length,
    (connection_state)(unsigned int)v43,
    SOCKET_END_ONCLOSE,
    http_got_header);
  done_string(&header);
}
// 8059038: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080D2780) --------------------------------------------------------
void __cdecl http_protocol_handler(connection *conn)
{
  if ( has_keepalive_connection(conn) )
    http_send_header(conn->socket);
  else
    make_connection(conn->socket, conn->uri, http_send_header, conn->cache_mode > CACHE_MODE_CHECK_IF_MODIFIED);
}

//----- (080D27E0) --------------------------------------------------------
void __cdecl proxy_protocol_handler(connection *conn)
{
  http_protocol_handler(conn);
}

//----- (080D27F0) --------------------------------------------------------
const uri *__usercall http_negotiate_get@<eax>(uri *uri@<eax>, int *isnew@<edx>, int alloc@<ecx>)
{
  const uri *next; // edi
  const uri *v7; // eax

  next = (const uri *)negotiate_list.next;
  if ( negotiate_list.next == &negotiate_list )
  {
LABEL_6:
    next = 0;
    if ( alloc )
    {
      v7 = (const uri *)mem_calloc(1u, 0x30u);
      next = v7;
      if ( v7 )
      {
        ++uri->object.refcount;
        v7->user = (unsigned __int8 *)uri;
        if ( isnew )
          *isnew = 1;
      }
    }
  }
  else
  {
    while ( !compare_uri((const uri *)next->user, uri, URI_HTTP_REFERRER_HOST) )
    {
      next = (const uri *)next->string;
      if ( next == (const uri *)&negotiate_list )
        goto LABEL_6;
    }
  }
  return next;
}

//----- (080D2880) --------------------------------------------------------
int __usercall http_negotiate_create_context@<eax>(negotiate *neg@<eax>)
{
  OM_uint32 inited; // eax
  int result; // eax
  int minor_status[3]; // [esp+4Ch] [ebp-Ch] BYREF

  inited = gss_init_sec_context(
             minor_status,
             0,
             &neg->context,
             neg->server_name,
             0,
             1,
             0,
             0,
             &neg->input_token,
             0,
             &neg->output_token,
             0,
             0);
  neg->status = inited;
  if ( (inited & 0xFFFF0000) != 0 )
    return -1;
  result = 0;
  if ( !neg->output_token.length )
    return -1;
  return result;
}
// 8059A38: using guessed type int __cdecl gss_init_sec_context(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80D2880: using guessed type OM_uint32 minor_status[3];

//----- (080D2920) --------------------------------------------------------
void __usercall http_negotiate_cleanup(negotiate *neg@<eax>, int full@<edx>)
{
  OM_uint32 minor_status[4]; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( neg->context )
    gss_delete_sec_context(minor_status, &neg->context, 0);
  if ( neg->output_token.length )
    gss_release_buffer(minor_status, &neg->output_token);
  if ( full )
  {
    if ( neg->server_name )
      gss_release_name(minor_status, &neg->server_name);
    if ( neg->input_token.length )
    {
      mem_free(neg->input_token.value);
      neg->input_token.length = 0;
    }
    memset(neg, 0, sizeof(negotiate));
  }
}
// 8058CD8: using guessed type int __cdecl gss_release_name(_DWORD, _DWORD);
// 8058DA8: using guessed type int __cdecl gss_release_buffer(_DWORD, _DWORD);
// 80596C8: using guessed type int __cdecl gss_delete_sec_context(_DWORD, _DWORD, _DWORD);

//----- (080D29D0) --------------------------------------------------------
int __cdecl http_negotiate_output(uri *uri, string *header)
{
  const uri *v2; // eax
  uri *v3; // ebx
  int fragment; // eax
  unsigned __int8 *v5; // esi
  const char *v7; // eax
  int len[4]; // [esp+1Ch] [ebp-1Ch] BYREF

  len[0] = 0;
  v2 = http_negotiate_get(uri, 0, 0);
  v3 = (uri *)v2;
  if ( !v2 )
    return -1;
  fragment = (int)v2->fragment;
  if ( !fragment )
  {
    if ( http_negotiate_create_context((negotiate *)v3) < 0 )
    {
      http_negotiate_cleanup((negotiate *)v3, 1);
      return -1;
    }
    fragment = (int)v3->fragment;
  }
  v5 = base64_encode_bin(v3->post, fragment, len);
  if ( !v5 || !len[0] )
    return -1;
  add_to_string(header, "Authorization: ");
  v7 = "GSS-Negotiate";
  if ( v3->password != (unsigned __int8 *)1 )
    v7 = "Negotiate";
  add_to_string(header, (const unsigned __int8 *)v7);
  add_char_to_string(header, 0x20u);
  add_to_string(header, v5);
  add_crlf_to_string(header);
  http_negotiate_cleanup((negotiate *)v3, 0);
  mem_free(v5);
  return 0;
}
// 80D29D0: using guessed type int len[4];

//----- (080D2AD0) --------------------------------------------------------
int __usercall http_negotiate_get_name@<eax>(connection *conn@<eax>, negotiate *neg@<edx>)
{
  uri *proxied_uri; // ecx
  _BOOL4 v4; // esi
  const char *v5; // eax
  int v6; // edx
  int result; // eax
  int v8; // edx
  gss_buffer_desc token; // [esp+20h] [ebp-818h] BYREF
  OM_uint32 minor_status; // [esp+28h] [ebp-810h] BYREF
  char name[2048]; // [esp+2Ch] [ebp-80Ch] BYREF
  unsigned int v12; // [esp+82Ch] [ebp-Ch]

  v12 = __readgsdword(0x14u);
  token.length = 0;
  token.value = 0;
  proxied_uri = conn->proxied_uri;
  v4 = neg->type == 1;
  v5 = "KHTTP" + 1;
  if ( neg->type == 1 )
    v5 = "KHTTP";
  v6 = v4 + *((unsigned __int16 *)proxied_uri + 23) + 6;
  if ( v4 + (unsigned int)*((unsigned __int16 *)proxied_uri + 23) + 7 > 0x800 )
    return -1;
  token.length = v4 + *((unsigned __int16 *)proxied_uri + 23) + 6;
  __snprintf_chk(
    name,
    v6,
    1,
    2048,
    "%s@%*s",
    v5,
    *((unsigned __int16 *)proxied_uri + 23),
    (const char *)proxied_uri->host);
  token.value = name;
  v8 = gss_import_name(&minor_status, &token, GSS_C_NT_HOSTBASED_SERVICE__GSS_1_0_0, &neg->server_name);
  result = 0;
  if ( (v8 & 0xFFFF0000) != 0 )
    return -1;
  return result;
}
// 8059828: using guessed type int __cdecl gss_import_name(_DWORD, _DWORD, _DWORD, _DWORD);
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 8148CA8: using guessed type int GSS_C_NT_HOSTBASED_SERVICE__GSS_1_0_0;

//----- (080D2BE0) --------------------------------------------------------
int __cdecl http_negotiate_input(connection *conn, uri *uri, int type, unsigned __int8 *data)
{
  negotiate *v4; // eax
  negotiate *v5; // esi
  gss_ctx_id_t context; // ecx
  int result; // eax
  negotiate *next; // edx
  unsigned __int8 *v9; // edx
  unsigned __int8 v10; // bl
  const unsigned __int16 **v11; // eax
  unsigned __int8 *v12; // edx
  const unsigned __int16 *v13; // ecx
  unsigned __int8 *v14; // edi
  int v15; // edx
  unsigned __int8 *v16; // eax
  unsigned __int8 *in; // [esp+1Ch] [ebp-2Ch]
  int isnew[4]; // [esp+2Ch] [ebp-1Ch] BYREF

  isnew[0] = 0;
  v4 = (negotiate *)http_negotiate_get(uri, isnew, 1);
  v5 = v4;
  if ( type != 1 && v4->context )
    return -1;
  context = v4->context;
  v4->type = type;
  if ( context && !v4->status )
  {
    http_negotiate_cleanup(v4, 1);
    return -1;
  }
  else
  {
    if ( !v4->server_name && http_negotiate_get_name(conn, v4) < 0 )
      return -1;
    if ( data && *data )
    {
      v9 = data + 14;
      if ( type != 1 )
        v9 = data + 10;
      v10 = *v9;
      if ( *v9 )
      {
        in = v9;
        v11 = __ctype_b_loc();
        v12 = in;
        v13 = *v11;
        while ( (v13[v10] & 0x2000) != 0 )
        {
          v10 = *++v12;
          if ( !*v12 )
            goto LABEL_6;
        }
        v14 = v12;
        if ( v10 != 13 && v10 && v10 != 10 )
        {
          while ( (v13[v10] & 8) != 0 || v10 == 61 )
            v10 = *++v12;
          if ( v10 == 10 || v10 == 13 )
          {
            v15 = v12 - v14;
            if ( v15 )
            {
              v16 = base64_decode_bin(v14, v15, (int *)&v5->input_token);
              v5->input_token.value = v16;
              if ( !v16 )
                return -1;
            }
          }
        }
      }
    }
LABEL_6:
    result = http_negotiate_create_context(v5);
    if ( !result )
    {
      if ( isnew[0] )
      {
        next = (negotiate *)negotiate_list.next;
        v5->prev = (negotiate *)&negotiate_list;
        v5->next = next;
        negotiate_list.next = v5;
        v5->next->prev = v5;
      }
    }
  }
  return result;
}
// 80D2BE0: using guessed type int isnew[4];

//----- (080D2D80) --------------------------------------------------------
unsigned __int8 *__usercall get_uri_rewrite_prefix@<eax>(uri_rewrite_type type@<eax>, unsigned __int8 *url@<edx>)
{
  int v2; // ebx
  option_elinks *opt_rec_real; // eax
  unsigned __int8 *result; // eax
  unsigned __int8 *v5; // [esp+1Ch] [ebp-Ch]

  v2 = type == URI_REWRITE_DUMB ? 3 : 5;
  if ( !assert_failed )
  {
    assert_failed = v2 != 5 && v2 != 3;
    if ( v2 != 5 && v2 != 3 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/protocol/rewrite/rewrite.c";
      errline = 230;
      v5 = url;
      elinks_internal("assertion tree == URI_REWRITE_DUMB_TREE || tree == URI_REWRITE_SMART_TREE failed!");
      url = v5;
    }
  }
  opt_rec_real = get_opt_rec_real((option_elinks *)(60 * v2 + 135557152), url);
  if ( !opt_rec_real )
    return 0;
  result = opt_rec_real->value.string;
  if ( result )
  {
    if ( !*result )
      return 0;
  }
  return result;
}

//----- (080D2E20) --------------------------------------------------------
evhook_status __cdecl goto_url_hook(va_list ap, void *data)
{
  int v2; // esi
  char *v3; // edi
  char v4; // al
  int v5; // edx
  char v6; // al
  char *v7; // edi
  char v8; // cl
  unsigned __int8 *number; // ebx
  int v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // ecx
  int v13; // esi
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // ebx
  unsigned __int8 v17; // cl
  int v18; // edx
  size_t v19; // edi
  unsigned __int8 *v20; // esi
  unsigned __int8 v21; // al
  unsigned __int8 v22; // al
  int v23; // eax
  unsigned __int8 *source; // ebx
  int v25; // ecx
  unsigned int v26; // eax
  size_t v27; // edx
  int length; // edi
  unsigned int v29; // ecx
  size_t v30; // edx
  unsigned __int8 *v31; // eax
  unsigned __int8 *uri_rewrite_prefix; // eax
  unsigned __int8 *v33; // eax
  int v34; // [esp+14h] [ebp-94h]
  int v35; // [esp+14h] [ebp-94h]
  char v36; // [esp+14h] [ebp-94h]
  unsigned int v37; // [esp+14h] [ebp-94h]
  int v38; // [esp+18h] [ebp-90h]
  size_t v39; // [esp+18h] [ebp-90h]
  size_t v40; // [esp+18h] [ebp-90h]
  int v41; // [esp+1Ch] [ebp-8Ch]
  uri *uri; // [esp+20h] [ebp-88h]
  unsigned __int8 *name; // [esp+24h] [ebp-84h]
  unsigned int v44; // [esp+28h] [ebp-80h]
  int v45; // [esp+28h] [ebp-80h]
  unsigned __int8 **url; // [esp+2Ch] [ebp-7Ch]
  int namelen[10]; // [esp+38h] [ebp-70h]
  unsigned __int8 *v48[10]; // [esp+60h] [ebp-48h]
  string string; // [esp+88h] [ebp-20h] BYREF

  url = *(unsigned __int8 ***)ap;
  v2 = *((_DWORD *)ap + 1);
  name = (unsigned __int8 *)&delete;
  v3 = **(char ***)ap;
  v4 = *v3;
  if ( !*v3 || v4 == 32 || v4 == 58 )
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    do
      v6 = v3[++v5];
    while ( v6 && v6 != 32 && v6 != 58 );
  }
  v7 = &v3[v5];
  if ( uri_rewrite_options[2].option_elinks.value.number && (v8 = *v7) != 0 )
  {
    *v7 = 0;
    v36 = v8;
    uri_rewrite_prefix = get_uri_rewrite_prefix(URI_REWRITE_SMART, *url);
    *v7 = v36;
    name = (unsigned __int8 *)(v7 + 1);
    number = uri_rewrite_prefix;
    if ( uri_rewrite_prefix )
    {
LABEL_12:
      if ( number )
        goto LABEL_13;
      goto LABEL_26;
    }
  }
  else
  {
    number = 0;
  }
  if ( !uri_rewrite_options[1].option_elinks.value.number )
    goto LABEL_12;
  if ( !*v7 )
  {
    number = get_uri_rewrite_prefix(URI_REWRITE_DUMB, *url);
    goto LABEL_12;
  }
LABEL_26:
  v15 = *url;
  if ( strchr((const char *)*url, 58) )
    return 0;
  if ( strchr((const char *)v15, 46) )
    return 0;
  if ( strchr((const char *)v15, 47) )
    return 0;
  number = (unsigned __int8 *)get_opt_(config_options, "protocol.rewrite.default_template")->number;
  if ( !number || !*number )
    return 0;
  name = *url;
LABEL_13:
  if ( v2 && (v10 = *(_DWORD *)(v2 + 20)) != 0 )
    uri = *(uri **)(v10 + 68);
  else
    uri = 0;
  string.source = 0;
  string.length = 0;
  if ( !init_string(&string) )
    return 0;
  v11 = name;
  v12 = 0;
  v13 = 0;
  v48[0] = name;
  while ( 1 )
  {
    v14 = &v11[v12];
    if ( *v14 == 32 )
      break;
    if ( !*v14 )
    {
      namelen[v13] = v12;
      v17 = *number;
      v41 = v13 + 1;
      goto LABEL_29;
    }
    ++v12;
LABEL_20:
    v11 = v48[v13];
  }
  namelen[v13++] = v12;
  if ( v13 != 10 )
  {
    do
      ++v14;
    while ( *v14 == 32 );
    v48[v13] = v14;
    v12 = 1;
    goto LABEL_20;
  }
  v17 = *number;
  v41 = 10;
LABEL_29:
  while ( 2 )
  {
    if ( v17 )
    {
LABEL_30:
      v18 = 0;
      v19 = 0;
      v20 = number;
      if ( v17 != 37 )
      {
        do
        {
          v21 = number[++v18];
          v19 = v18;
          v20 = &number[v18];
        }
        while ( v21 != 37 && v21 );
      }
      if ( assert_failed )
      {
LABEL_35:
        assert_failed = 0;
        goto LABEL_36;
      }
      if ( v18 < 0 )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        v38 = v18;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        v18 = v38;
        if ( assert_failed )
          goto LABEL_35;
      }
      else
      {
        assert_failed = 0;
      }
      if ( v18 )
      {
        v25 = v18 + string.length;
        v26 = string.length + 255;
        v27 = v18 + string.length + 256;
        LOBYTE(v26) = 0;
        LOBYTE(v27) = 0;
        v44 = v26;
        if ( v27 > v26 )
        {
          v39 = v27;
          v35 = v25;
          v31 = (unsigned __int8 *)mem_realloc(string.source, v27);
          if ( v31 )
          {
            string.source = v31;
            memset(&v31[v44], 0, v39 - v44);
            v25 = v35;
            goto LABEL_48;
          }
        }
        else
        {
LABEL_48:
          if ( string.source )
          {
            v34 = v25;
            memcpy(&string.source[string.length], number, v19);
            string.source[v34] = 0;
            string.length = v34;
          }
        }
      }
LABEL_36:
      v17 = *v20;
      number = v20;
      if ( *v20 != 37 )
        continue;
      v22 = v20[1];
      number = v20 + 1;
      if ( v22 > 0x39u )
      {
        if ( v22 == 99 )
        {
          if ( uri )
          {
            add_uri_to_string(&string, uri, URI_ORIGINAL);
            v17 = *number;
            goto LABEL_56;
          }
        }
        else
        {
          if ( v22 != 115 )
            goto LABEL_54;
          if ( name )
          {
            encode_uri_string(&string, name, -1, 1);
            v17 = *number;
            goto LABEL_56;
          }
        }
LABEL_40:
        number = v20 + 2;
        v17 = v20[2];
        goto LABEL_41;
      }
      if ( v22 >= 0x30u )
      {
        v23 = v22 - 48;
        if ( v23 >= v41 )
          goto LABEL_40;
        encode_uri_string(&string, v48[v23], namelen[v23], 1);
        v17 = *number;
LABEL_56:
        if ( !v17 )
          continue;
        number = v20 + 2;
        v17 = v20[2];
LABEL_41:
        if ( !v17 )
          break;
        goto LABEL_30;
      }
      if ( v22 == 37 )
      {
        add_char_to_string(&string, 0x25u);
        v17 = *number;
        goto LABEL_56;
      }
LABEL_54:
      if ( assert_failed )
      {
        assert_failed = 0;
        v17 = *number;
        goto LABEL_56;
      }
      length = string.length;
      assert_failed = 0;
      v45 = string.length + 2;
      v29 = string.length + 255;
      v30 = string.length + 258;
      LOBYTE(v29) = 0;
      LOBYTE(v30) = 0;
      if ( v30 > v29 )
      {
        v40 = v30;
        v37 = v29;
        v33 = (unsigned __int8 *)mem_realloc(string.source, v30);
        if ( v33 )
        {
          string.source = v33;
          memset(&v33[v37], 0, v40 - v37);
          goto LABEL_61;
        }
      }
      else
      {
LABEL_61:
        if ( string.source )
        {
          *(_WORD *)&string.source[string.length] = *(_WORD *)v20;
          string.source[length + 2] = 0;
          string.length = v45;
        }
      }
      v17 = *number;
      goto LABEL_56;
    }
    break;
  }
  source = string.source;
  if ( !string.source )
    return 0;
  mem_free(*url);
  *url = source;
  return 0;
}
// 80D2E20: using guessed type int namelen[10];

//----- (080D33A0) --------------------------------------------------------
void __cdecl report_scripting_error(module *module, session *ses, unsigned __int8 *msg)
{
  terminal *term; // edi
  unsigned __int8 *name; // ebx
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  int v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // eax
  int v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+2Ch] [ebp-2Ch]
  string string; // [esp+38h] [ebp-20h] BYREF

  if ( ses )
  {
    term = ses->tab->term;
  }
  else
  {
    term = (terminal *)terminals.next;
    if ( terminals.next == &terminals )
    {
      v10 = gettext(module->name);
      v11 = gettext("[%s error] %s");
      usrerror(v11, v10, msg);
      sleep(3u);
      return;
    }
  }
  if ( init_string(&string) )
  {
    name = module->name;
    if ( module->name && *name )
    {
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        if ( terminal_codepage != current_charset )
        {
          v12 = terminal_codepage;
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v12;
        }
      }
      name = gettext(name);
    }
    if ( term )
    {
      v7 = get_terminal_codepage(term);
      if ( v7 != current_charset )
      {
        v13 = v7;
        v8 = get_cp_mime_name(v7);
        bind_textdomain_codeset("elinks", v8);
        current_charset = v13;
      }
    }
    v9 = gettext(&byte_8123E44);
    add_format_to_string(&string, v9, name);
    add_format_to_string(&string, &byte_8133692, msg);
    info_box(term, MSGBOX_NO_TEXT_INTL|MSGBOX_FREE_TEXT, "Browser scripting error", ALIGN_LEFT, string.source);
  }
}

//----- (080D3520) --------------------------------------------------------
VALUE __cdecl erb_module_method_missing(VALUE self, VALUE arg)
{
  return 4;
}

//----- (080D3530) --------------------------------------------------------
VALUE __cdecl erb_stdout_p(int argc, VALUE *argv, VALUE self)
{
  int v3; // edi
  int v4; // eax
  _BYTE *v5; // esi
  int v6; // ebx
  signed int v7; // ebx
  int v8; // ecx
  unsigned int v9; // eax
  size_t v10; // edx
  unsigned __int8 *v12; // eax
  size_t v13; // [esp+24h] [ebp-34h]
  int v14; // [esp+28h] [ebp-30h]
  int v15; // [esp+28h] [ebp-30h]
  unsigned int v16; // [esp+2Ch] [ebp-2Ch]
  string string; // [esp+38h] [ebp-20h] BYREF

  if ( init_string(&string) )
  {
    v3 = 0;
    if ( argc > 0 )
    {
      while ( 1 )
      {
        v4 = rb_inspect(argv[v3]);
        v5 = *(_BYTE **)(v4 + 12);
        v6 = *(_DWORD *)(v4 + 8);
        if ( *v5 == 34 )
        {
          ++v5;
          --v6;
        }
        v7 = v6 - (v5[v6 - 1] == 34);
        if ( !assert_failed )
        {
          if ( v5 && v7 >= 0 )
          {
            assert_failed = 0;
LABEL_9:
            if ( v7 )
            {
              v8 = v7 + string.length;
              v9 = string.length + 255;
              v10 = v7 + string.length + 256;
              LOBYTE(v9) = 0;
              LOBYTE(v10) = 0;
              v16 = v9;
              if ( v10 > v9 )
              {
                v13 = v10;
                v15 = v7 + string.length;
                v12 = (unsigned __int8 *)mem_realloc(string.source, v10);
                if ( v12 )
                {
                  string.source = v12;
                  memset(&v12[v16], 0, v13 - v16);
                  v8 = v15;
                  goto LABEL_11;
                }
              }
              else
              {
LABEL_11:
                if ( string.source )
                {
                  v14 = v8;
                  memcpy(&string.source[string.length], v5, v7);
                  string.source[v14] = 0;
                  string.length = v14;
                }
              }
            }
            if ( argc <= ++v3 )
              break;
            goto LABEL_14;
          }
          assert_failed = 1;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
          errline = 255;
          elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
          if ( !assert_failed )
            goto LABEL_9;
        }
        ++v3;
        assert_failed = 0;
        if ( argc <= v3 )
          break;
LABEL_14:
        add_to_string(&string, ", ");
      }
    }
    if ( terminals.next == &terminals )
    {
      usrerror("[Ruby] %s", (const char *)string.source);
      done_string(&string);
    }
    else
    {
      info_box(
        (terminal *)terminals.next,
        MSGBOX_NO_TEXT_INTL|MSGBOX_FREE_TEXT,
        "Ruby Message",
        ALIGN_LEFT,
        string.source);
    }
  }
  return 4;
}
// 80594E8: using guessed type int __cdecl rb_inspect(_DWORD);

//----- (080D3720) --------------------------------------------------------
VALUE __cdecl erb_module_message(VALUE self, VALUE str)
{
  int v2; // eax
  unsigned __int8 *v3; // eax
  char *v4; // ebx
  char *v5; // eax

  v2 = rb_obj_as_string(str);
  v3 = memacpy(*(const unsigned __int8 **)(v2 + 12), *(_DWORD *)(v2 + 8));
  v4 = (char *)v3;
  if ( v3 )
  {
    v5 = strchr((const char *)v3, 10);
    if ( v5 )
      *v5 = 0;
    if ( terminals.next == &terminals )
    {
      usrerror("[Ruby] %s", v4);
      mem_free(v4);
    }
    else
    {
      info_box(
        (terminal *)terminals.next,
        MSGBOX_NO_TEXT_INTL|MSGBOX_FREE_TEXT,
        "Ruby Message",
        ALIGN_LEFT,
        (unsigned __int8 *)v4);
    }
  }
  return 4;
}
// 8059658: using guessed type int __cdecl rb_obj_as_string(_DWORD);

//----- (080D37C0) --------------------------------------------------------
void __cdecl alert_ruby_error(session *ses, unsigned __int8 *msg)
{
  report_scripting_error(&ruby_scripting_module, ses, msg);
}

//----- (080D37F0) --------------------------------------------------------
void __cdecl erb_report_error(session *ses, int error)
{
  char *v2; // edx
  int v3; // edi
  int v4; // eax
  int v5; // esi
  int v6; // eax
  char *v7; // eax
  unsigned __int8 buff[1024]; // [esp+2Ch] [ebp-41Ch] BYREF
  unsigned int v9; // [esp+42Ch] [ebp-1Ch]

  v9 = __readgsdword(0x14u);
  switch ( error )
  {
    case 1:
      v2 = "unexpected return";
      break;
    case 2:
      v2 = "unexpected break";
      break;
    case 3:
      v2 = "unexpected next";
      break;
    case 4:
      v2 = "retry outside of rescue clause";
      break;
    case 5:
      v2 = "unexpected redo";
      break;
    case 6:
    case 8:
      if ( (ruby_errinfo & 1) != 0 )
      {
        v3 = rb_cFixnum;
      }
      else if ( ruby_errinfo == 4 )
      {
        v3 = rb_cNilClass;
      }
      else if ( ruby_errinfo )
      {
        if ( ruby_errinfo == 2 )
        {
          v3 = rb_cTrueClass;
        }
        else if ( (_BYTE)ruby_errinfo == 14 )
        {
          v3 = rb_cSymbol;
        }
        else
        {
          v3 = *(_DWORD *)(ruby_errinfo + 4);
        }
      }
      else
      {
        v3 = rb_cFalseClass;
      }
      v4 = rb_obj_as_string(ruby_errinfo);
      v5 = v4;
      if ( rb_eRuntimeError != v3 || (v2 = "unhandled exception", *(_DWORD *)(v4 + 8)) )
      {
        v6 = rb_class_path(v3);
        __snprintf_chk(
          buff,
          1024,
          1,
          1024,
          (const char *)"%s: %s",
          *(const char **)(v6 + 12),
          *(const char **)(v5 + 12));
        v7 = strchr((const char *)buff, 10);
        v2 = (char *)buff;
        if ( v7 )
          *v7 = 0;
      }
      break;
    default:
      __snprintf_chk(buff, 1024, 1, 1024, "unknown longjmp status %d", error);
      v2 = (char *)buff;
      break;
  }
  alert_ruby_error(ses, (unsigned __int8 *)v2);
}
// 8059428: using guessed type int __cdecl rb_class_path(_DWORD);
// 8059658: using guessed type int __cdecl rb_obj_as_string(_DWORD);
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 8148C40: using guessed type int ruby_errinfo;
// 8148C44: using guessed type int rb_cFixnum;
// 8148C48: using guessed type int rb_cTrueClass;
// 8148C4C: using guessed type int rb_eRuntimeError;
// 8148C60: using guessed type int rb_cSymbol;
// 8148C90: using guessed type int rb_cNilClass;
// 8148CAC: using guessed type int rb_cFalseClass;

//----- (080D39D0) --------------------------------------------------------
void __cdecl init_ruby(module *module)
{
  int v1; // eax
  const unsigned __int8 *v2; // eax
  int v3; // eax
  unsigned __int8 *v4; // ebx
  int v5; // eax
  int error[3]; // [esp+1Ch] [ebp-Ch] BYREF

  ruby_init();
  ruby_script("ELinks-ruby");
  ruby_init_loadpath();
  rb_define_singleton_method(rb_stdout, "write", erb_module_message, 1);
  rb_define_global_function("p", erb_stdout_p, -1);
  erb_module = rb_define_module("ELinks");
  v1 = rb_str_new2("0.12pre5");
  rb_define_const(erb_module, "VERSION", v1);
  v2 = (const unsigned __int8 *)elinks_home;
  if ( !elinks_home )
    v2 = "/etc/elinks";
  v3 = rb_str_new2(v2);
  rb_define_const(erb_module, "HOME", v3);
  rb_define_module_function(erb_module, "message", erb_module_message, 1);
  rb_define_module_function(erb_module, "method_missing", erb_module_method_missing, -1);
  rb_define_module_function(erb_module, "p", erb_stdout_p, -1);
  if ( elinks_home )
    v4 = straconcat((const unsigned __int8 *)elinks_home, "hooks.rb", 0);
  else
    v4 = stracpy(&byte_81335AB);
  if ( v4 )
  {
    if ( file_can_read(v4) )
    {
      v5 = rb_str_new2(v4);
      rb_load_protect(v5, 0, error);
      if ( error[0] )
        erb_report_error(0, error[0]);
    }
    mem_free(v4);
  }
}
// 8058CB8: using guessed type int __cdecl rb_define_global_function(_DWORD, _DWORD, _DWORD);
// 8058F28: using guessed type int ruby_init(void);
// 8058FE8: using guessed type int ruby_init_loadpath(void);
// 80591D8: using guessed type int __cdecl rb_define_singleton_method(_DWORD, _DWORD, _DWORD, _DWORD);
// 8059288: using guessed type int __cdecl rb_define_module(_DWORD);
// 80593F8: using guessed type int __cdecl rb_load_protect(_DWORD, _DWORD, _DWORD);
// 8059518: using guessed type int __cdecl ruby_script(_DWORD);
// 80596B8: using guessed type int __cdecl rb_define_module_function(_DWORD, _DWORD, _DWORD, _DWORD);
// 8059838: using guessed type int __cdecl rb_str_new2(_DWORD);
// 8059AC8: using guessed type int __cdecl rb_define_const(_DWORD, _DWORD, _DWORD);
// 8148C54: using guessed type int rb_stdout;
// 80D39D0: using guessed type int error[3];

//----- (080D3B90) --------------------------------------------------------
evhook_status __cdecl script_hook_quit(va_list ap, void *data)
{
  int v3[3]; // [esp+1Ch] [ebp-1Ch] BYREF
  int error; // [esp+28h] [ebp-10h] BYREF
  VALUE args[1]; // [esp+2Ch] [ebp-Ch] BYREF

  v3[2] = (int)args;
  v3[0] = (int)"quit_hook";
  v3[1] = 0;
  rb_protect(do_erb_protected_method_call, v3, &error);
  if ( error )
    erb_report_error(0, error);
  return 0;
}
// 8058FB8: using guessed type int __cdecl rb_protect(_DWORD, _DWORD, _DWORD);

//----- (080D3BE0) --------------------------------------------------------
VALUE __cdecl do_erb_protected_method_call(VALUE data)
{
  int v1; // eax

  if ( !assert_failed )
  {
    assert_failed = data == 0;
    if ( !data )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/scripting/ruby/hooks.c";
      errline = 38;
      elinks_internal("assertion info failed!");
    }
  }
  v1 = rb_intern(*(_DWORD *)data);
  return rb_funcall3(erb_module, v1, *(_DWORD *)(data + 4), *(_DWORD *)(data + 8));
}
// 8059878: using guessed type int __cdecl rb_intern(_DWORD);
// 8059908: using guessed type int __cdecl rb_funcall3(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080D3C60) --------------------------------------------------------
evhook_status __cdecl script_hook_get_proxy(va_list ap, void *data)
{
  int v2; // ebx
  void **v3; // esi
  size_t v5; // eax
  int v6; // eax
  int v7; // edx
  unsigned __int8 *v8; // ebx
  int v9[3]; // [esp+1Ch] [ebp-1Ch] BYREF
  VALUE args[1]; // [esp+28h] [ebp-10h] BYREF
  int error; // [esp+2Ch] [ebp-Ch] BYREF

  v2 = *((_DWORD *)ap + 1);
  v3 = *(void ***)ap;
  if ( !v2 || !v3 )
    return 0;
  v5 = strlen(*((const char **)ap + 1));
  v9[0] = (int)"proxy_hook";
  v9[1] = 1;
  args[0] = rb_str_new(v2, v5);
  v9[2] = (int)args;
  v6 = rb_protect(do_erb_protected_method_call, v9, &error);
  if ( error )
  {
    erb_report_error(0, error);
    return 0;
  }
  if ( (v6 & 1) != 0 )
    goto LABEL_17;
  if ( v6 == 4 )
    return 0;
  if ( !v6 || v6 == 2 || v6 == 6 || (_BYTE)v6 == 14 )
    goto LABEL_17;
  v7 = *(_DWORD *)v6 & 0x3F;
  if ( v7 == 1 )
    return 0;
  if ( v7 == 7 )
  {
    v8 = memacpy(*(const unsigned __int8 **)(v6 + 12), *(_DWORD *)(v6 + 8));
    if ( v8 )
    {
      if ( *v3 )
        mem_free(*v3);
      *v3 = v8;
    }
    return 0;
  }
LABEL_17:
  alert_ruby_error(0, "proxy_hook must return a string or nil");
  return 0;
}
// 8058FB8: using guessed type int __cdecl rb_protect(_DWORD, _DWORD, _DWORD);
// 80590B8: using guessed type int __cdecl rb_str_new(_DWORD, _DWORD);

//----- (080D3D80) --------------------------------------------------------
evhook_status __cdecl script_hook_follow_url(va_list ap, void *data)
{
  void **v2; // esi
  session *v3; // edi
  int v4; // ebx
  size_t v5; // eax
  int v6; // eax
  int v7; // edx
  unsigned __int8 *v8; // ebx
  int v10[3]; // [esp+1Ch] [ebp-2Ch] BYREF
  VALUE args[1]; // [esp+28h] [ebp-20h] BYREF
  int error[4]; // [esp+2Ch] [ebp-1Ch] BYREF

  v2 = *(void ***)ap;
  v3 = (session *)*((_DWORD *)ap + 1);
  v4 = **(_DWORD **)ap;
  if ( v4 )
  {
    v5 = strlen(**(const char ***)ap);
    v10[0] = (int)"follow_url_hook";
    v10[1] = 1;
    args[0] = rb_str_new(v4, v5);
    v10[2] = (int)args;
    v6 = rb_protect(do_erb_protected_method_call, v10, error);
    if ( error[0] )
    {
      erb_report_error(v3, error[0]);
      return 0;
    }
    if ( (v6 & 1) != 0 )
      goto LABEL_16;
    if ( v6 == 4 )
      return 0;
    if ( !v6 || v6 == 2 || v6 == 6 || (_BYTE)v6 == 14 )
      goto LABEL_16;
    v7 = *(_DWORD *)v6 & 0x3F;
    if ( v7 == 1 )
      return 0;
    if ( v7 != 7 )
    {
LABEL_16:
      alert_ruby_error(v3, "follow_url_hook must return a string or nil");
      return 0;
    }
    v8 = memacpy(*(const unsigned __int8 **)(v6 + 12), *(_DWORD *)(v6 + 8));
    if ( v8 )
    {
      if ( *v2 )
        mem_free(*v2);
      *v2 = v8;
    }
  }
  return 0;
}
// 8058FB8: using guessed type int __cdecl rb_protect(_DWORD, _DWORD, _DWORD);
// 80590B8: using guessed type int __cdecl rb_str_new(_DWORD, _DWORD);
// 80D3D80: using guessed type int error[4];

//----- (080D3E80) --------------------------------------------------------
evhook_status __cdecl script_hook_goto_url(va_list ap, void *data)
{
  void **v2; // edi
  session *v3; // esi
  int v4; // ebx
  size_t v5; // eax
  location *current; // eax
  const char *string; // ebx
  size_t v8; // eax
  int v9; // eax
  int v11; // edx
  unsigned __int8 *v12; // ebx
  int v13[3]; // [esp+18h] [ebp-30h] BYREF
  VALUE args[2]; // [esp+24h] [ebp-24h] BYREF
  int error[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  v2 = *(void ***)ap;
  v3 = (session *)*((_DWORD *)ap + 1);
  v4 = **(_DWORD **)ap;
  if ( !v4 )
    return 0;
  v5 = strlen(**(const char ***)ap);
  args[0] = rb_str_new(v4, v5);
  if ( v3 && (current = v3->history.current) != 0 )
  {
    string = (const char *)current->vs.uri->string;
    v8 = strlen(string);
    args[1] = rb_str_new(string, v8);
  }
  else
  {
    args[1] = 4;
  }
  v13[2] = (int)args;
  v13[0] = (int)"goto_url_hook";
  v13[1] = 2;
  v9 = rb_protect(do_erb_protected_method_call, v13, error);
  if ( error[0] )
  {
    erb_report_error(v3, error[0]);
    return 0;
  }
  else
  {
    if ( (v9 & 1) != 0 )
      goto LABEL_7;
    if ( v9 == 4 )
      return 0;
    if ( !v9 || v9 == 2 || v9 == 6 || (_BYTE)v9 == 14 )
      goto LABEL_7;
    v11 = *(_DWORD *)v9 & 0x3F;
    if ( v11 == 1 )
      return 0;
    if ( v11 != 7 )
    {
LABEL_7:
      alert_ruby_error(v3, "goto_url_hook must return a string or nil");
      return 0;
    }
    v12 = memacpy(*(const unsigned __int8 **)(v9 + 12), *(_DWORD *)(v9 + 8));
    if ( !v12 )
      return 0;
    if ( *v2 )
      mem_free(*v2);
    *v2 = v12;
    return 0;
  }
}
// 8058FB8: using guessed type int __cdecl rb_protect(_DWORD, _DWORD, _DWORD);
// 80590B8: using guessed type int __cdecl rb_str_new(_DWORD, _DWORD);
// 80D3E80: using guessed type int error[7];

//----- (080D3FC0) --------------------------------------------------------
evhook_status __cdecl script_hook_pre_format_html(va_list ap, void *data)
{
  cache_entry *v2; // ebx
  session *v3; // edi
  fragment *cache_fragment; // esi
  int v6; // eax
  int v7; // eax
  int v8; // edx
  ssize_t v9; // esi
  int v10[3]; // [esp+28h] [ebp-30h] BYREF
  VALUE args[2]; // [esp+34h] [ebp-24h] BYREF
  int error[4]; // [esp+3Ch] [ebp-1Ch] BYREF

  v2 = (cache_entry *)*((_DWORD *)ap + 1);
  v3 = *(session **)ap;
  cache_fragment = get_cache_fragment(v2);
  if ( v2->length && cache_fragment->data[0] )
  {
    args[0] = rb_str_new2(v2->uri->string);
    v6 = rb_str_new(cache_fragment->data, cache_fragment->length);
    v10[0] = (int)"pre_format_html_hook";
    v10[1] = 2;
    args[1] = v6;
    v10[2] = (int)args;
    v7 = rb_protect(do_erb_protected_method_call, v10, error);
    if ( error[0] )
    {
      erb_report_error(v3, error[0]);
      return 0;
    }
    if ( (v7 & 1) == 0 )
    {
      if ( v7 == 4 )
        return 0;
      if ( v7 && v7 != 2 && v7 != 6 && (_BYTE)v7 != 14 )
      {
        v8 = *(_DWORD *)v7 & 0x3F;
        if ( v8 == 1 )
          return 0;
        if ( v8 == 7 )
        {
          v9 = *(_DWORD *)(v7 + 8);
          add_fragment(v2, 0LL, *(const unsigned __int8 **)(v7 + 12), v9);
          normalize_cache_entry(v2, v9);
          return 0;
        }
      }
    }
    alert_ruby_error(v3, "pre_format_html_hook must return a string or nil");
  }
  return 0;
}
// 8058FB8: using guessed type int __cdecl rb_protect(_DWORD, _DWORD, _DWORD);
// 80590B8: using guessed type int __cdecl rb_str_new(_DWORD, _DWORD);
// 8059838: using guessed type int __cdecl rb_str_new2(_DWORD);
// 80D3FC0: using guessed type int error[4];

//----- (080D4110) --------------------------------------------------------
int are_there_downloads()
{
  list_head_elinks *next; // eax

  next = (list_head_elinks *)downloads.next;
  if ( downloads.next == &downloads )
    return 0;
  while ( next[2].prev )
  {
    next = (list_head_elinks *)next->next;
    if ( next == &downloads )
      return 0;
  }
  return 1;
}

//----- (080D4150) --------------------------------------------------------
void __cdecl lun_cancel(void *lun_hop_)
{
  (*((void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))lun_hop_ + 3))(
    *(_DWORD *)lun_hop_,
    0,
    *((_DWORD *)lun_hop_ + 4),
    0);
  if ( *((_DWORD *)lun_hop_ + 1) )
    mem_free(*((void **)lun_hop_ + 1));
  if ( *((_DWORD *)lun_hop_ + 2) )
    mem_free(*((void **)lun_hop_ + 2));
  mem_free(lun_hop_);
}

//----- (080D41B0) --------------------------------------------------------
void __cdecl lun_overwrite(void *lun_hop_)
{
  (*((void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))lun_hop_ + 3))(
    *(_DWORD *)lun_hop_,
    *((_DWORD *)lun_hop_ + 1),
    *((_DWORD *)lun_hop_ + 4),
    0);
  if ( *((_DWORD *)lun_hop_ + 2) )
    mem_free(*((void **)lun_hop_ + 2));
  mem_free(lun_hop_);
}

//----- (080D4200) --------------------------------------------------------
void __cdecl lun_alternate(void *lun_hop_)
{
  (*((void (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))lun_hop_ + 3))(
    *(_DWORD *)lun_hop_,
    *((_DWORD *)lun_hop_ + 2),
    *((_DWORD *)lun_hop_ + 4),
    0);
  if ( *((_DWORD *)lun_hop_ + 1) )
    mem_free(*((void **)lun_hop_ + 1));
  mem_free(lun_hop_);
}

//----- (080D4250) --------------------------------------------------------
widget_handler_status_T __cdecl tp_show_header(dialog_data *dlg_data, widget_data *widget_data)
{
  cached_header_dialog(*((session **)widget_data->widget->data + 15), *((cache_entry **)widget_data->widget->data + 14));
  return 0;
}

//----- (080D4280) --------------------------------------------------------
unsigned __int8 *__usercall subst_file@<eax>(unsigned __int8 *prog@<eax>, unsigned __int8 *file@<edx>)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  unsigned __int8 v5; // dl
  int v6; // eax
  size_t v7; // ebx
  unsigned __int8 *v8; // edi
  unsigned __int8 v9; // dl
  int v10; // eax
  unsigned int v11; // ecx
  size_t v12; // edx
  unsigned __int8 v13; // bl
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // edi
  int v17; // ecx
  bool v18; // zf
  size_t v19; // [esp+1Ch] [ebp-3Ch]
  int v20; // [esp+20h] [ebp-38h]
  unsigned int v21; // [esp+20h] [ebp-38h]
  int input; // [esp+24h] [ebp-34h]
  int v24; // [esp+2Ch] [ebp-2Ch]
  string s; // [esp+30h] [ebp-28h] BYREF
  string name; // [esp+38h] [ebp-20h] BYREF

  input = 1;
  inited = init_string(&name);
  result = 0;
  if ( inited )
  {
LABEL_2:
    v5 = *prog;
    while ( v5 )
    {
      v6 = 0;
      v7 = 0;
      v8 = prog;
      if ( v5 != 37 )
      {
        do
        {
          v9 = prog[++v6];
          v7 = v6;
          v8 = &prog[v6];
        }
        while ( v9 != 37 && v9 );
      }
      if ( !assert_failed )
      {
        if ( v6 >= 0 )
        {
          assert_failed = 0;
LABEL_10:
          if ( v6 )
          {
            v10 = name.length + v6;
            v11 = name.length + 255;
            LOBYTE(v11) = 0;
            v12 = v10 + 256;
            LOBYTE(v12) = 0;
            v24 = v10;
            if ( v12 > v11 )
            {
              v19 = v12;
              v21 = v11;
              v15 = (unsigned __int8 *)mem_realloc(name.source, v12);
              if ( v15 )
              {
                name.source = v15;
                memset(&v15[v21], 0, v19 - v21);
                goto LABEL_12;
              }
            }
            else
            {
LABEL_12:
              if ( name.source )
              {
                memcpy(&name.source[name.length], prog, v7);
                name.source[v24] = 0;
                name.length = v24;
              }
            }
          }
          v5 = *v8;
          if ( *v8 == 37 )
            goto LABEL_21;
          goto LABEL_15;
        }
        v20 = v6;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        v6 = v20;
        if ( !assert_failed )
          goto LABEL_10;
      }
      assert_failed = 0;
      v5 = *v8;
      if ( *v8 == 37 )
      {
LABEL_21:
        prog = v8 + 1;
        v14 = strlen((const char *)file);
        add_shell_quoted_to_string(&name, file, v14);
        input = 0;
        goto LABEL_2;
      }
LABEL_15:
      prog = v8;
    }
    v13 = v5;
    if ( input && init_string(&s) )
    {
      add_to_string(&s, "/bin/cat ");
      v16 = file;
      v17 = -1;
      do
      {
        if ( !v17 )
          break;
        v18 = *v16++ == v13;
        --v17;
      }
      while ( !v18 );
      add_shell_quoted_to_string(&s, file, -v17 - 2);
      add_to_string(&s, " | ");
      add_string_to_string(&s, &name);
      done_string(&name);
      return s.source;
    }
    else
    {
      return name.source;
    }
  }
  return result;
}

//----- (080D44C0) --------------------------------------------------------
void __cdecl tp_save(type_query *type_query)
{
  if ( type_query->external_handler )
    mem_free(type_query->external_handler);
  type_query->external_handler = 0;
  query_file(type_query->ses, type_query->uri, type_query, continue_download, tp_cancel, 1);
}

//----- (080D4520) --------------------------------------------------------
void __cdecl done_type_query(type_query *type_query)
{
  cancel_download(&type_query->download, 0);
  --type_query->cached->object.refcount;
  done_uri(type_query->uri);
  if ( type_query->external_handler )
    mem_free(type_query->external_handler);
  if ( type_query->target_frame )
    mem_free(type_query->target_frame);
  type_query->next->prev = type_query->prev;
  type_query->prev->next = type_query->next;
  mem_free(type_query);
}

//----- (080D4590) --------------------------------------------------------
void __cdecl tp_display(type_query *type_query)
{
  session *ses; // ebx
  uri *loading_uri; // edx
  unsigned __int8 *frame; // edi
  view_state *v4; // eax
  location *current; // eax
  uri *v6; // [esp+1Ch] [ebp-1Ch]

  ses = type_query->ses;
  loading_uri = ses->loading_uri;
  ses->loading_uri = type_query->uri;
  frame = ses->task.target.frame;
  ses->task.target.frame = type_query->target_frame;
  v6 = loading_uri;
  v4 = ses_forward(ses, 0);
  if ( v4 )
    v4->plain = 1;
  current = ses->history.current;
  ses->loading_uri = v6;
  ses->task.target.frame = frame;
  current->download.data = ses;
  current->download.callback = (download_callback_T *)doc_loading_callback;
  move_download(&type_query->download, &current->download, PRI_MAIN);
  display_timer(ses);
  done_type_query(type_query);
}

//----- (080D4630) --------------------------------------------------------
void __cdecl tp_cancel(void *data)
{
  cancel_download((download *)((char *)data + 8), 1);
  done_type_query((type_query *)data);
}

//----- (080D4660) --------------------------------------------------------
void __cdecl lun_resume(void *lun_hop_)
{
  _DWORD *v1; // esi
  _DWORD *v2; // eax
  _DWORD *v3; // edi
  type_query *type_query; // eax
  session *ses; // ecx
  uri *uri; // edx
  codw_hop *codw_hop; // [esp+1Ch] [ebp-2Ch]
  type_query *v8; // [esp+28h] [ebp-20h]

  v1 = (_DWORD *)*((_DWORD *)lun_hop_ + 4);
  v2 = v1;
  if ( *(_DWORD *)v1[3] == 1 )
  {
    v3 = mem_calloc(1u, 0xCu);
    if ( !v3 )
    {
      lun_cancel(lun_hop_);
      return;
    }
    codw_hop = (codw_hop *)v1[3];
    type_query = codw_hop->type_query;
    *v3 = 0;
    ses = type_query->ses;
    v3[1] = ses;
    uri = type_query->uri;
    ++uri->object.refcount;
    ses->download_uri = uri;
    if ( type_query->external_handler && codw_hop->file )
    {
      v8 = type_query;
      mem_free(codw_hop->file);
      type_query = v8;
    }
    tp_cancel(type_query);
    mem_free(codw_hop);
    *v1 = v3 + 2;
    v1[3] = v3;
    v1[2] = common_download_do;
    v2 = (_DWORD *)*((_DWORD *)lun_hop_ + 4);
  }
  (*((void (__cdecl **)(_DWORD, _DWORD, _DWORD *, int))lun_hop_ + 3))(
    *(_DWORD *)lun_hop_,
    *((_DWORD *)lun_hop_ + 1),
    v2,
    1);
  if ( *((_DWORD *)lun_hop_ + 2) )
    mem_free(*((void **)lun_hop_ + 2));
  mem_free(lun_hop_);
}

//----- (080D4760) --------------------------------------------------------
void __usercall download_error_dialog(file_download *file_download@<eax>, int saved_errno@<edx>)
{
  char *v3; // eax
  terminal *term; // esi
  unsigned __int8 *v5; // eax

  v3 = strerror(saved_errno);
  term = file_download->term;
  if ( file_download->ses )
  {
    v5 = msg_text(term, "Could not create file '%s':\n%s", (const char *)file_download->file, v3);
    info_box(term, MSGBOX_FREE_TEXT, "Download error", ALIGN_CENTER, v5);
  }
}

//----- (080D47D0) --------------------------------------------------------
void __cdecl create_download_file_do(terminal *term, unsigned __int8 *file, void *data, int resume)
{
  int v4; // edi
  int v5; // edx
  signed int v6; // eax
  unsigned __int8 *v7; // edx
  char v8; // cl
  char *v9; // eax
  unsigned __int8 *v10; // [esp+10h] [ebp-48h]
  int v11; // [esp+28h] [ebp-30h]
  int saved_errno; // [esp+30h] [ebp-28h]
  int saved_errnoa; // [esp+30h] [ebp-28h]
  unsigned __int8 *download_dir; // [esp+3Ch] [ebp-1Ch]
  unsigned __int8 *download_dira; // [esp+3Ch] [ebp-1Ch]

  v4 = -1;
  if ( file )
  {
    v11 = *((_DWORD *)data + 1);
    download_dir = (unsigned __int8 *)get_cwd();
    set_cwd(term->cwd);
    mkalldirs(file);
    v5 = 65;
    if ( !resume )
      v5 = v11 == 0 ? 577 : 705;
    v4 = open64(file, v5);
    saved_errno = *__errno_location();
    if ( download_dir )
    {
      set_cwd(download_dir);
      mem_free(download_dir);
    }
    if ( v4 == -1 )
    {
      v9 = strerror(saved_errno);
      v10 = msg_text(term, "Could not create file '%s':\n%s", (const char *)file, v9);
      info_box(term, MSGBOX_FREE_TEXT, "Download error", ALIGN_CENTER, v10);
      mem_free(file);
    }
    else
    {
      set_bin(v4);
      if ( !*((_DWORD *)data + 1) )
      {
        download_dira = (unsigned __int8 *)get_opt_(config_options, "document.download.directory")->number;
        safe_strncpy(download_dira, file, 0x400u);
        v6 = strlen((const char *)download_dira);
        saved_errnoa = v6;
        if ( v6 >= 0 )
        {
          v7 = &download_dira[v6];
          if ( download_dira[v6] != 47 )
          {
            do
            {
              if ( --v6 == -1 )
              {
                saved_errnoa = -1;
                goto LABEL_17;
              }
              v8 = *--v7;
            }
            while ( v8 != 47 );
            saved_errnoa = v6;
          }
        }
LABEL_17:
        download_dira[saved_errnoa + 1] = 0;
      }
      if ( *(_DWORD *)data )
        **(_DWORD **)data = file;
      else
        mem_free(file);
    }
  }
  (*((void (__cdecl **)(terminal *, int, _DWORD, int))data + 2))(term, v4, *((_DWORD *)data + 3), resume);
  mem_free(data);
}
// 80598F8: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (080D49F0) --------------------------------------------------------
void __cdecl abort_download(file_download *file_download)
{
  dialog_data *dlg_data; // eax
  unsigned __int8 *file; // eax

  done_download_display(file_download);
  if ( file_download->ses )
    check_questions_queue(file_download->ses);
  dlg_data = file_download->dlg_data;
  if ( dlg_data )
    cancel_dialog(dlg_data, 0);
  cancel_download(&file_download->download, (*((_BYTE *)file_download + 104) & 2) != 0);
  if ( file_download->uri )
    done_uri(file_download->uri);
  if ( file_download->handle != -1 )
    close(file_download->handle);
  if ( file_download->external_handler )
    mem_free(file_download->external_handler);
  file = file_download->file;
  if ( file )
  {
    if ( (*((_BYTE *)file_download + 104) & 1) != 0 )
    {
      unlink((const char *)file_download->file);
      file = file_download->file;
    }
    mem_free(file);
  }
  file_download->next->prev = file_download->prev;
  file_download->prev->next = file_download->next;
  mem_free(file_download);
}

//----- (080D4AB0) --------------------------------------------------------
void __usercall kill_downloads_to_file(unsigned __int8 *file@<eax>)
{
  file_download *i; // ebx
  file_download **p_next; // ebx

  for ( i = (file_download *)downloads.next; i != (file_download *)&downloads; i = *p_next )
  {
    while ( strcmp((const char *)i->file, (const char *)file) )
    {
      i = i->next;
      if ( i == (file_download *)&downloads )
        return;
    }
    p_next = &i->prev->next;
    abort_download(*p_next);
  }
}

//----- (080D4B10) --------------------------------------------------------
void __cdecl detach_downloads_from_terminal(terminal *term)
{
  file_download *next; // eax
  list_head_elinks *v2; // ebx
  list_head_elinks *v3; // edx
  session *ses; // edx

  if ( assert_failed
    || (assert_failed = term == 0, !term)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c",
        errline = 227,
        elinks_internal("assertion term != NULL failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  next = (file_download *)downloads.next;
  v2 = *(list_head_elinks **)downloads.next;
  if ( &downloads != downloads.next )
  {
    while ( 1 )
    {
      if ( next->term != term )
        goto LABEL_5;
      if ( !next->external_handler )
        break;
      abort_download(next);
      v3 = (list_head_elinks *)v2->next;
      next = (file_download *)v2;
      if ( &downloads == v2 )
        return;
LABEL_6:
      v2 = v3;
    }
    ses = next->ses;
    next->term = 0;
    if ( ses )
    {
      if ( term == ses->tab->term )
        next->ses = 0;
    }
LABEL_5:
    v3 = (list_head_elinks *)v2->next;
    next = (file_download *)v2;
    if ( &downloads == v2 )
      return;
    goto LABEL_6;
  }
}

//----- (080D4C00) --------------------------------------------------------
void __cdecl destroy_downloads(session *ses)
{
  list_head_elinks *next; // edx
  session *i; // eax
  file_download *v3; // eax
  list_head_elinks *v4; // esi

  next = (list_head_elinks *)sessions.next;
  if ( sessions.next == &sessions )
  {
LABEL_12:
    v3 = (file_download *)downloads.next;
    v4 = *(list_head_elinks **)downloads.next;
    if ( downloads.next != &downloads )
    {
      while ( 1 )
      {
        if ( v3->ses == ses )
        {
          if ( v3->external_handler )
            abort_download(v3);
          else
            v3->ses = 0;
        }
        v3 = (file_download *)v4;
        if ( &downloads == v4 )
          break;
        v4 = (list_head_elinks *)v4->next;
      }
    }
  }
  else
  {
    while ( next == (list_head_elinks *)ses || (terminal *)*((_DWORD *)next[1].next + 5) != ses->tab->term )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &sessions )
        goto LABEL_12;
    }
    for ( i = (session *)downloads.next; i != (session *)&downloads; i = i->next )
    {
      while ( i->more_files.next != ses )
      {
        i = i->next;
        if ( i == (session *)&downloads )
          return;
      }
      i->more_files.next = next;
    }
  }
}

//----- (080D4CD0) --------------------------------------------------------
void abort_all_downloads()
{
  file_download *i; // eax

  for ( i = (file_download *)downloads.next; downloads.next != &downloads; i = (file_download *)downloads.next )
    abort_download(i);
}

//----- (080D4D00) --------------------------------------------------------
file_download *__cdecl init_file_download(uri *uri, session *ses, unsigned __int8 *file, int fd)
{
  file_download *v4; // ebx
  uri *composed_uri; // eax
  file_download *next; // eax
  file_download *v8; // [esp+0h] [ebp-18h]

  v4 = (file_download *)mem_calloc(1u, 0x74u);
  if ( v4 )
  {
    composed_uri = get_composed_uri(uri, URI_BASE);
    v4->uri = composed_uri;
    if ( composed_uri )
    {
      init_download_display(v4);
      v4->file = file;
      v4->download.callback = (download_callback_T *)download_data;
      v4->download.data = v4;
      v4->ses = ses;
      v4->handle = fd;
      v4->term = ses->tab->term;
      next = (file_download *)downloads.next;
      v4->prev = (file_download *)&downloads;
      v4->next = next;
      downloads.next = v4;
      v4->next->prev = v4;
    }
    else
    {
      v8 = v4;
      v4 = 0;
      mem_free(v8);
    }
  }
  return v4;
}

//----- (080D4DA0) --------------------------------------------------------
void __cdecl continue_download_do(terminal *term, int fd, void *data, int resume)
{
  int v4; // esi
  int v5; // esi
  int v6; // edx
  unsigned __int8 *v7; // eax
  type_query *v8; // esi
  file_download *inited; // edi
  unsigned __int8 *external_handler; // eax
  unsigned __int8 *v11; // eax

  if ( !assert_failed )
  {
    assert_failed = data == 0;
    if ( data
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c",
          errline = 889,
          elinks_internal("assertion codw_hop failed!"),
          !assert_failed) )
    {
      v4 = *((_DWORD *)data + 1);
      assert_failed = v4 == 0;
      if ( v4
        || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c",
            errline = 890,
            elinks_internal("assertion codw_hop->type_query failed!"),
            !assert_failed) )
      {
        v5 = *(_DWORD *)(*((_DWORD *)data + 1) + 64);
        assert_failed = v5 == 0;
        if ( v5
          || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c",
              errline = 891,
              elinks_internal("assertion codw_hop->type_query->uri failed!"),
              !assert_failed) )
        {
          v6 = *(_DWORD *)(*((_DWORD *)data + 1) + 60);
          assert_failed = v6 == 0;
          if ( !v6 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
            errline = 892;
            elinks_internal("assertion codw_hop->type_query->ses failed!");
          }
        }
      }
    }
  }
  v7 = (unsigned __int8 *)*((_DWORD *)data + 2);
  v8 = (type_query *)*((_DWORD *)data + 1);
  if ( v7 && (inited = init_file_download(v8->uri, v8->ses, v7, fd)) != 0 )
  {
    external_handler = v8->external_handler;
    if ( external_handler )
    {
      v11 = subst_file(external_handler, *((unsigned __int8 **)data + 3));
      *((_BYTE *)inited + 104) |= 1u;
      inited->external_handler = v11;
      mem_free(*((void **)data + 3));
      if ( v8->external_handler )
        mem_free(v8->external_handler);
      v8->external_handler = 0;
    }
    *((_BYTE *)inited + 104) = (4 * (v8->block != 0)) | *((_BYTE *)inited + 104) & 0xFB;
    display_download(term, inited, v8->ses);
    move_download(&v8->download, &inited->download, PRI_MAIN);
    done_type_query(v8);
    mem_free(data);
  }
  else
  {
    if ( v8->external_handler && *((_DWORD *)data + 3) )
      mem_free(*((void **)data + 3));
    tp_cancel(v8);
    mem_free(data);
  }
}

//----- (080D4FF0) --------------------------------------------------------
void __cdecl common_download_do(terminal *term, int fd, void *data, int resume)
{
  unsigned __int8 *v4; // esi
  session *v5; // ebx
  file_download *inited; // esi
  stat buf; // [esp+20h] [ebp-78h] BYREF

  v4 = (unsigned __int8 *)*((_DWORD *)data + 2);
  v5 = (session *)*((_DWORD *)data + 1);
  mem_free(data);
  if ( v4 )
  {
    if ( !__fxstat64(3, fd, &buf) )
    {
      inited = init_file_download(v5->download_uri, v5, v4, fd);
      if ( inited )
      {
        if ( resume )
          inited->seek = buf.st_size;
        display_download(v5->tab->term, inited, v5);
        load_uri(inited->uri, v5->referrer, &inited->download, PRI_MAIN, CACHE_MODE_NORMAL, inited->seek);
      }
    }
  }
}
// 8059818: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);

//----- (080D50D0) --------------------------------------------------------
void __usercall abort_download_and_beep(file_download *file_download@<eax>, terminal *term@<edx>)
{
  if ( term && get_opt_(config_options, "document.download.notify_bell")->number + file_download->notify > 1 )
    beep_terminal(term);
  abort_download(file_download);
}

//----- (080D5120) --------------------------------------------------------
void __usercall download_data_store(download *download@<eax>, file_download *file_download@<edx>)
{
  terminal *term; // esi
  connection_basic_state basic; // eax
  dialog_data *dlg_data; // eax
  unsigned __int8 *state_message; // eax
  unsigned __int8 *v8; // eax
  char v9; // al
  unsigned __int8 *uri_string; // edi
  unsigned __int8 *v11; // eax
  connection_state state; // [esp+20h] [ebp-38h]
  unsigned __int8 *url; // [esp+2Ch] [ebp-2Ch]
  utimbuf foo; // [esp+38h] [ebp-20h] BYREF

  term = file_download->term;
  assert_terminal_ptr_not_dangling(term);
  if ( assert_failed )
  {
    assert_failed = 0;
    file_download->term = 0;
LABEL_3:
    abort_download(file_download);
    return;
  }
  if ( !term )
    goto LABEL_3;
  basic = download->state.basic;
  if ( basic < S_WAIT )
  {
    if ( basic == S_OK )
    {
      if ( file_download->external_handler )
      {
        close(file_download->handle);
        v9 = *((_BYTE *)file_download + 104);
        file_download->handle = -1;
        exec_on_terminal(term, file_download->external_handler, file_download->file, (term_exec)((v9 & 4) != 0));
        *((_BYTE *)file_download + 104) &= ~1u;
        abort_download_and_beep(file_download, term);
      }
      else
      {
        if ( file_download->notify )
        {
          uri_string = get_uri_string(file_download->uri, URI_PUBLIC);
          done_download_display(file_download);
          if ( uri_string )
          {
            v11 = msg_text(term, "Download complete:\n%s", (const char *)uri_string);
            info_box(term, MSGBOX_FREE_TEXT, (unsigned __int8 *)&byte_812B447, ALIGN_CENTER, v11);
            mem_free(uri_string);
          }
        }
        if ( file_download->remotetime && get_opt_(config_options, "document.download.set_original_time")->number )
        {
          foo.modtime = file_download->remotetime;
          foo.actime = foo.modtime;
          utime((const char *)file_download->file, &foo);
        }
        abort_download_and_beep(file_download, term);
      }
    }
    else
    {
      url = get_uri_string(file_download->uri, URI_PUBLIC);
      state = download->state;
      abort_download_and_beep(file_download, term);
      if ( url )
      {
        state_message = get_state_message(state, term);
        v8 = msg_text(term, (unsigned __int8 *)&byte_813367E, url, state_message);
        info_box(term, MSGBOX_FREE_TEXT, "Download error", ALIGN_CENTER, v8);
        mem_free(url);
      }
    }
  }
  else
  {
    dlg_data = file_download->dlg_data;
    if ( dlg_data )
      redraw_dialog(dlg_data, 1);
  }
}

//----- (080D5360) --------------------------------------------------------
void __cdecl download_data(download *download, file_download *file_download)
{
  cache_entry *cached; // edi
  int redirect_cnt; // eax
  progress *v4; // eax
  int seek_high; // edx
  list_head_elinks *next; // esi
  off_t v7; // rax
  int handle; // edi
  ssize_t v9; // eax
  int v10; // edx
  uri *redirect; // eax
  connection_basic_state v12; // eax
  dialog_data *dlg_data; // eax
  off_t start; // rax
  progress *progress; // ecx
  int v16; // edx
  int *v17; // eax
  int v18; // eax
  char *buf; // [esp+30h] [ebp-28h]
  list_head_elinks *p_frag; // [esp+34h] [ebp-24h]
  off_t n; // [esp+38h] [ebp-20h]
  size_t na; // [esp+38h] [ebp-20h]

  cached = download->cached;
  if ( !cached || download->state.basic <= (unsigned int)S_PROC )
  {
LABEL_20:
    download_data_store(download, file_download);
    return;
  }
  if ( cached->last_modified )
    file_download->remotetime = parse_date(&cached->last_modified, 0, 0, 1);
  if ( cached->redirect )
  {
    redirect_cnt = file_download->redirect_cnt;
    file_download->redirect_cnt = redirect_cnt + 1;
    if ( redirect_cnt <= 9 )
    {
      cancel_download(&file_download->download, 0);
      if ( !assert_failed )
      {
        v18 = compare_uri(cached->uri, file_download->uri, (uri_component)0);
        assert_failed = v18 == 0;
        if ( !v18 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
          errline = 421;
          elinks_internal("assertion compare_uri(cached->uri, file_download->uri, 0) failed: Redirecting using bad base URI");
        }
      }
      done_uri(file_download->uri);
      redirect = cached->redirect;
      ++redirect->object.refcount;
      file_download->uri = redirect;
      if ( assert_failed )
      {
        assert_failed = 0;
        v12 = S_INTERNAL;
      }
      else
      {
        assert_failed = 0;
        v12 = S_WAIT_REDIR;
      }
      file_download->download.state.basic = v12;
      dlg_data = file_download->dlg_data;
      file_download->download.state.syserr = 0;
      if ( dlg_data )
        redraw_dialog(dlg_data, 1);
      start = 0LL;
      progress = download->progress;
      if ( progress )
        start = progress->start;
      load_uri(file_download->uri, cached->uri, &file_download->download, PRI_MAIN, CACHE_MODE_NORMAL, start);
      return;
    }
  }
  v4 = file_download->download.progress;
  if ( !v4
    || (seek_high = HIDWORD(v4->seek), !v4->seek)
    || (LODWORD(file_download->seek) = v4->seek,
        HIDWORD(file_download->seek) = seek_high,
        LODWORD(v4->seek) = 0,
        HIDWORD(v4->seek) = 0,
        lseek64(file_download->handle, file_download->seek, HIDWORD(file_download->seek), 0),
        v16 >= 0) )
  {
    next = (list_head_elinks *)cached->frag.next;
    p_frag = &cached->frag;
    if ( &cached->frag == next )
    {
      n = file_download->seek;
    }
    else
    {
      n = file_download->seek;
      do
      {
        v7 = n - *(_QWORD *)&next[1];
        if ( v7 >= 0 && v7 < *(_QWORD *)&next[2] )
        {
          na = (size_t)next[2].next - v7;
          buf = (char *)&next[4] + v7;
          handle = file_download->handle;
          while ( 1 )
          {
            v9 = write(handle, buf, na);
            if ( v9 != -1 )
              break;
            v10 = *__errno_location();
            if ( v10 != 4 )
            {
              download_error_dialog(file_download, v10);
              goto LABEL_17;
            }
          }
          n = file_download->seek + v9;
          file_download->seek = n;
        }
        next = (list_head_elinks *)next->next;
      }
      while ( p_frag != next );
    }
    detach_connection(download, n);
    goto LABEL_20;
  }
  v17 = __errno_location();
  download_error_dialog(file_download, *v17);
LABEL_17:
  detach_connection(download, file_download->seek);
  abort_download(file_download);
}
// 80D5607: variable 'v16' is possibly undefined
// 8058F78: using guessed type int __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080D5690) --------------------------------------------------------
int __cdecl download_is_progressing(download *download)
{
  return download && download->state.basic == S_TRANS && has_progress(download->progress) != 0;
}

//----- (080D56C0) --------------------------------------------------------
void __cdecl create_download_file(
        terminal *term,
        unsigned __int8 *fi,
        unsigned __int8 **real_file,
        int safe,
        int resume,
        void (*callback)(terminal *, int, void *, int),
        void *data)
{
  _DWORD *v7; // eax
  void *v8; // ebx
  unsigned __int8 *cwd; // edi
  unsigned __int8 *v10; // edx
  int number; // ecx
  unsigned __int8 *unique_name; // eax
  _DWORD *v13; // eax
  const char *v14; // edx
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  void *udata; // [esp+54h] [ebp-34h]
  void *udataa; // [esp+54h] [ebp-34h]
  unsigned __int8 *fileprefix; // [esp+58h] [ebp-30h]
  unsigned __int8 *file; // [esp+6Ch] [ebp-1Ch]

  v7 = mem_calloc(1u, 0x10u);
  v8 = v7;
  if ( !v7 )
  {
    callback(term, -1, data, 0);
    return;
  }
  *v7 = real_file;
  v7[1] = safe;
  v7[3] = data;
  v7[2] = callback;
  cwd = (unsigned __int8 *)get_cwd();
  set_cwd(term->cwd);
  v10 = expand_tilde(fi);
  if ( resume )
  {
    create_download_file_do(term, v10, v8, resume);
    if ( cwd )
      goto LABEL_14;
    return;
  }
  fileprefix = v10;
  number = get_opt_(config_options, "document.download.overwrite")->number;
  if ( !number )
  {
    create_download_file_do(term, fileprefix, v8, 0);
    goto LABEL_13;
  }
  udata = (void *)number;
  if ( file_is_dir(fileprefix) )
  {
    v16 = msg_text(term, "'%s' is a directory.", (const char *)fileprefix);
    info_box(term, MSGBOX_FREE_TEXT, "Download error", ALIGN_CENTER, v16);
LABEL_21:
    mem_free(fileprefix);
    create_download_file_do(term, 0, v8, 0);
    goto LABEL_13;
  }
  unique_name = get_unique_name(fileprefix);
  file = unique_name;
  if ( !unique_name || udata == (void *)1 )
  {
    if ( fileprefix != unique_name )
      mem_free(fileprefix);
    goto LABEL_19;
  }
  if ( fileprefix == unique_name )
  {
LABEL_19:
    create_download_file_do(term, file, v8, 0);
    goto LABEL_13;
  }
  v13 = mem_calloc(1u, 0x14u);
  v14 = (const char *)fileprefix;
  if ( !v13 )
  {
    mem_free(file);
    goto LABEL_21;
  }
  *v13 = term;
  v13[1] = fileprefix;
  v13[4] = v8;
  v13[3] = create_download_file_do;
  v13[2] = file;
  if ( !fileprefix )
    v14 = &delete;
  udataa = v13;
  v15 = msg_text(term, "This file already exists:\n%s\n\nThe alternative filename is:\n%s", v14, (const char *)file);
  msg_box(
    term,
    0,
    MSGBOX_FREE_TEXT,
    "File exists",
    ALIGN_CENTER,
    v15,
    udataa,
    4,
    "Sa~ve under the alternative name",
    lun_alternate,
    1,
    "~Overwrite the original file",
    lun_overwrite,
    0,
    "~Resume download of the original file",
    lun_resume,
    0,
    &cancelbutton,
    lun_cancel,
    2);
LABEL_13:
  if ( cwd )
  {
LABEL_14:
    set_cwd(cwd);
    mem_free(cwd);
  }
}

//----- (080D59E0) --------------------------------------------------------
void __cdecl continue_download(void *data, unsigned __int8 *file)
{
  void *v3; // ebx
  char *v4; // edi
  unsigned __int8 *extension_from_uri; // eax
  unsigned __int8 *v6; // edi
  int v7; // eax
  uri *uri; // [esp+2Ch] [ebp-2Ch]
  string string; // [esp+38h] [ebp-20h] BYREF

  v3 = mem_calloc(1u, 0x10u);
  if ( v3 )
  {
    if ( !*((_DWORD *)data + 18) )
    {
LABEL_8:
      *((_DWORD *)v3 + 1) = data;
      *((_DWORD *)v3 + 3) = file;
      *(_DWORD *)v3 = 1;
      kill_downloads_to_file(file);
      create_download_file(
        *(terminal **)(*(_DWORD *)(*((_DWORD *)data + 15) + 8) + 20),
        file,
        (unsigned __int8 **)v3 + 2,
        *((_DWORD *)data + 18) != 0,
        0,
        continue_download_do,
        v3);
      return;
    }
    uri = (uri *)*((_DWORD *)data + 16);
    v4 = tempnam(0, "elinks");
    if ( v4 )
    {
      if ( init_string(&string) )
      {
        add_to_string(&string, (const unsigned __int8 *)v4);
        free(v4);
        extension_from_uri = get_extension_from_uri(uri);
        v6 = extension_from_uri;
        if ( extension_from_uri )
        {
          v7 = strlen((const char *)extension_from_uri);
          add_shell_safe_to_string(&string, v6, v7);
          mem_free(v6);
        }
        file = string.source;
        if ( string.source )
          goto LABEL_8;
      }
      else
      {
        free(v4);
      }
    }
    mem_free(v3);
  }
  tp_cancel(data);
}

//----- (080D5B20) --------------------------------------------------------
void __cdecl tp_open(type_query *type_query)
{
  unsigned __int8 *external_handler; // eax
  uri *uri; // eax
  unsigned __int8 *uri_string; // eax
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // edi

  external_handler = type_query->external_handler;
  if ( external_handler && *external_handler )
  {
    uri = type_query->uri;
    if ( uri->protocol != 4 || (*((_BYTE *)type_query + 80) & 1) != 0 )
    {
      continue_download(type_query, (unsigned __int8 *)&delete);
    }
    else
    {
      uri_string = get_uri_string(uri, URI_PATH);
      v4 = uri_string;
      if ( uri_string )
      {
        decode_uri(uri_string);
        v5 = subst_file(type_query->external_handler, v4);
        mem_free(v4);
        if ( v5 )
        {
          exec_on_terminal(
            type_query->ses->tab->term,
            v5,
            (unsigned __int8 *)&delete,
            (term_exec)(type_query->block != 0));
          mem_free(v5);
        }
      }
      done_type_query(type_query);
    }
  }
  else
  {
    tp_display(type_query);
  }
}

//----- (080D5C10) --------------------------------------------------------
void __usercall common_download(session *ses@<eax>, unsigned __int8 *file@<edx>, int resume@<ecx>)
{
  unsigned __int8 **v5; // eax
  unsigned __int8 **v6; // edi

  if ( ses->download_uri )
  {
    v5 = (unsigned __int8 **)mem_calloc(1u, 0xCu);
    v6 = v5;
    if ( v5 )
    {
      v5[1] = (unsigned __int8 *)ses;
      *v5 = 0;
      kill_downloads_to_file(file);
      create_download_file(ses->tab->term, file, v6 + 2, 0, resume, common_download_do, v6);
    }
  }
}

//----- (080D5CA0) --------------------------------------------------------
void __cdecl resume_download(void *ses, unsigned __int8 *file)
{
  common_download((session *)ses, file, 1);
}

//----- (080D5CC0) --------------------------------------------------------
void __cdecl start_download(void *ses, unsigned __int8 *file)
{
  common_download((session *)ses, file, 0);
}

//----- (080D5CE0) --------------------------------------------------------
int __cdecl setup_download_handler(session *ses, download *loading, cache_entry *cached, int frame)
{
  cache_entry *v4; // edi
  unsigned __int8 *content_type; // eax
  unsigned __int8 *v6; // ebx
  int v7; // ebx
  view_state *v8; // edx
  int result; // eax
  unsigned __int8 *type; // eax
  const char *v11; // edi
  int v12; // ebx
  session *next; // edx
  list_head_elinks *v14; // ebx
  type_query *v15; // eax
  session *v16; // edx
  uri *loading_uri; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ecx
  char v20; // al
  connection_basic_state v21; // eax
  type_query *v22; // eax
  terminal *term; // edi
  const char *v24; // eax
  char *v25; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  int v28; // eax
  int v29; // ebx
  unsigned __int8 *v30; // eax
  int v31; // eax
  int v32; // ebx
  unsigned __int8 *v33; // eax
  int v34; // ebx
  unsigned __int8 *v35; // eax
  int v36; // eax
  unsigned __int8 *v37; // eax
  unsigned __int8 *v38; // eax
  int v39; // eax
  unsigned __int8 *v40; // eax
  unsigned __int8 *v41; // eax
  cache_entry *v42; // eax
  int v43; // eax
  unsigned __int8 *v44; // eax
  unsigned __int8 *v45; // eax
  int v46; // eax
  unsigned __int8 *v47; // eax
  unsigned __int8 *v48; // eax
  bool v49; // zf
  memory_list *v50; // eax
  dialog_data *v51; // eax
  int v52; // eax
  unsigned __int8 *v53; // eax
  unsigned __int8 *v54; // eax
  unsigned __int8 *v55; // ebx
  int v56; // eax
  unsigned __int8 *v57; // eax
  unsigned __int8 *v58; // eax
  int v59; // eax
  int v60; // ebx
  unsigned __int8 *v61; // eax
  unsigned __int8 *v62; // eax
  int v63; // eax
  unsigned __int8 *v64; // eax
  unsigned __int8 *v65; // eax
  unsigned __int8 *v66; // [esp+10h] [ebp-68h]
  unsigned __int8 *v67; // [esp+10h] [ebp-68h]
  unsigned __int8 *v68; // [esp+10h] [ebp-68h]
  int v69; // [esp+34h] [ebp-44h]
  session *v70; // [esp+34h] [ebp-44h]
  type_query *v71; // [esp+34h] [ebp-44h]
  int v72; // [esp+34h] [ebp-44h]
  int v73; // [esp+34h] [ebp-44h]
  int v74; // [esp+34h] [ebp-44h]
  int v75; // [esp+34h] [ebp-44h]
  int v76; // [esp+34h] [ebp-44h]
  int v77; // [esp+34h] [ebp-44h]
  int v78; // [esp+34h] [ebp-44h]
  int v79; // [esp+34h] [ebp-44h]
  const char *description; // [esp+38h] [ebp-40h]
  unsigned __int8 *text; // [esp+3Ch] [ebp-3Ch]
  const unsigned __int8 *msgid; // [esp+40h] [ebp-38h]
  mime_handler *handler; // [esp+44h] [ebp-34h]
  type_query *type_query; // [esp+48h] [ebp-30h]
  type_query *type_querya; // [esp+48h] [ebp-30h]
  unsigned __int8 *v86; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v87; // [esp+4Ch] [ebp-2Ch]
  int v88; // [esp+4Ch] [ebp-2Ch]
  string string; // [esp+58h] [ebp-20h] BYREF

  v4 = cached;
  content_type = get_content_type(cached);
  v6 = content_type;
  if ( content_type && *content_type )
  {
    type = known_types[0].type;
    if ( known_types[0].type )
    {
      v11 = (const char *)v6;
      v12 = 0;
      while ( c_strcasecmp(v11, (const char *)type) )
      {
        type = known_types[++v12].type;
        if ( !type )
        {
          v6 = (unsigned __int8 *)v11;
          v4 = cached;
          goto LABEL_12;
        }
      }
      v7 = *((_BYTE *)&known_types[v12] + 4) & 1;
      goto LABEL_4;
    }
LABEL_12:
    handler = get_mime_type_handler(v6, ses->tab->term->environment & 2);
    if ( handler || strlen((const char *)v6) <= 3 || c_strncasecmp((const char *)v6, "text", 4u) )
    {
      next = (session *)ses->type_queries.next;
      if ( next != (session *)&ses->type_queries )
      {
        type_query = (type_query *)v6;
        v14 = (list_head_elinks *)ses->type_queries.next;
        while ( !compare_uri((const uri *)v14[8].next, ses->loading_uri, (uri_component)0) )
        {
          v14 = (list_head_elinks *)v14->next;
          if ( v14 == &ses->type_queries )
          {
            next = (session *)v14;
            v6 = (unsigned __int8 *)type_query;
            goto LABEL_22;
          }
        }
        goto LABEL_17;
      }
LABEL_22:
      v70 = next;
      v15 = (type_query *)mem_calloc(1u, 0x54u);
      v16 = v70;
      type_querya = v15;
      if ( !v15 )
      {
LABEL_17:
        result = 0;
        goto LABEL_18;
      }
      loading_uri = ses->loading_uri;
      ++loading_uri->object.refcount;
      type_querya->uri = loading_uri;
      v18 = 0;
      type_querya->ses = ses;
      v19 = ses->task.target.frame;
      if ( v19 )
      {
        v18 = stracpy(v19);
        v16 = v70;
      }
      type_querya->target_frame = v18;
      v20 = *((_BYTE *)type_querya + 80);
      type_querya->cached = v4;
      *((_BYTE *)type_querya + 80) = ((*((_BYTE *)v4 + 92) & 0x40) != 0) | v20 & 0xFE;
      ++v4->object.refcount;
      v71 = (type_query *)v16;
      move_download(loading, &type_querya->download, PRI_MAIN);
      if ( assert_failed )
      {
        assert_failed = 0;
        v21 = S_INTERNAL;
      }
      else
      {
        assert_failed = 0;
        v21 = S_OK;
      }
      loading->state.basic = v21;
      loading->state.syserr = 0;
      v22 = v71->next;
      type_querya->prev = v71;
      type_querya->next = v22;
      v71->next = type_querya;
      type_querya->next->prev = type_querya;
      term = type_querya->ses->tab->term;
      if ( type_querya->external_handler )
        mem_free(type_querya->external_handler);
      type_querya->external_handler = 0;
      if ( handler )
      {
        type_querya->block = (*((_BYTE *)handler + 8) & 2) != 0;
        if ( (*((_BYTE *)handler + 8) & 1) == 0 )
        {
          type_querya->external_handler = stracpy(handler->program);
          tp_open(type_querya);
          goto LABEL_106;
        }
        description = (const char *)handler->description;
        v24 = &delete;
        if ( *handler->description )
          v24 = (_BYTE *)(" -&gt; " + 5);
        msgid = "What to do?";
        v86 = (unsigned __int8 *)v24;
      }
      else
      {
        msgid = "Unknown type";
        v86 = (unsigned __int8 *)&delete;
        description = &delete;
      }
      v25 = (char *)mem_calloc(1u, 0x9A4u);
      if ( !v25 )
      {
LABEL_80:
        result = 1;
        goto LABEL_18;
      }
      if ( init_string(&string) )
      {
        add_mime_filename_to_string(&string, type_querya->uri);
        if ( (*((_BYTE *)term + 56) & 2) != 0 )
          decode_uri_string(&string);
        else
          decode_uri_string_for_display(&string);
      }
      text = (unsigned __int8 *)(v25 + 420);
      if ( string.length )
      {
        if ( term )
        {
          terminal_codepage = get_terminal_codepage(term);
          if ( terminal_codepage != current_charset )
          {
            v72 = terminal_codepage;
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            current_charset = v72;
          }
        }
        v66 = gettext(&byte_812419C);
        __snprintf_chk(text, 1024, 1, -1, (const char *)v66, string.source, v6, v86, description);
      }
      else
      {
        if ( term )
        {
          v52 = get_terminal_codepage(term);
          if ( v52 != current_charset )
          {
            v77 = v52;
            v53 = get_cp_mime_name(v52);
            bind_textdomain_codeset("elinks", v53);
            current_charset = v77;
          }
        }
        v68 = gettext(&byte_81241DC);
        __snprintf_chk(text, 1024, 1, -1, (const char *)v68, v6, v86, description);
      }
      done_string(&string);
      if ( *msgid )
      {
        if ( term )
        {
          v28 = get_terminal_codepage(term);
          v29 = v28;
          if ( v28 != current_charset )
          {
            v30 = get_cp_mime_name(v28);
            bind_textdomain_codeset("elinks", v30);
            current_charset = v29;
          }
        }
        msgid = gettext(msgid);
      }
      v25[28] |= 6u;
      *((_DWORD *)v25 + 4) = generic_dialog_layouter;
      *(_DWORD *)v25 = msgid;
      *((_DWORD *)v25 + 2) = type_querya;
      add_dlg_text((dialog *)v25, text, ALIGN_LEFT, 0);
      if ( !get_opt_(cmdline_options, "anonymous")->number )
      {
        v54 = (unsigned __int8 *)mem_calloc(1u, 0x400u);
        v55 = v54;
        if ( !v54 )
          goto LABEL_109;
        if ( handler )
          safe_strncpy(v54, handler->program, 0x400u);
        if ( term )
        {
          v56 = get_terminal_codepage(term);
          if ( v56 != current_charset )
          {
            v78 = v56;
            v57 = get_cp_mime_name(v56);
            bind_textdomain_codeset("elinks", v57);
            current_charset = v78;
          }
        }
        v58 = gettext(&byte_8124214);
        add_dlg_field_do((dialog *)v25, WIDGET_FIELD, v58, 0, 0, 0, 1024, v55, 0, INPFIELD_NONE);
        type_querya->external_handler = v55;
        if ( term )
        {
          v59 = get_terminal_codepage(term);
          v60 = v59;
          if ( v59 != current_charset )
          {
            v61 = get_cp_mime_name(v59);
            bind_textdomain_codeset("elinks", v61);
            current_charset = v60;
          }
        }
        v62 = gettext(&byte_8133721);
        v34 = 8;
        add_dlg_radio_do((dialog *)v25, v62, 0, 0, &type_querya->block);
        v88 = 3;
        goto LABEL_54;
      }
      if ( !handler )
      {
        v88 = 1;
        v34 = 6;
        goto LABEL_54;
      }
      v87 = (unsigned __int8 *)(v25 + 1444);
      if ( term )
      {
        v31 = get_terminal_codepage(term);
        v32 = v31;
        if ( v31 != current_charset )
        {
          v33 = get_cp_mime_name(v31);
          bind_textdomain_codeset("elinks", v33);
          current_charset = v32;
        }
      }
      v67 = gettext(&byte_8124244);
      __snprintf_chk(v87, 1024, 1, -1, (const char *)v67, handler->program);
      add_dlg_text((dialog *)v25, v87, ALIGN_LEFT, 0);
      v34 = 7;
      v35 = stracpy(handler->program);
      type_querya->external_handler = v35;
      v88 = 2;
      if ( v35 )
      {
LABEL_54:
        if ( get_opt_(cmdline_options, "anonymous")->number && !handler )
        {
          --v34;
        }
        else
        {
          if ( term )
          {
            v36 = get_terminal_codepage(term);
            if ( v36 != current_charset )
            {
              v73 = v36;
              v37 = get_cp_mime_name(v36);
              bind_textdomain_codeset("elinks", v37);
              current_charset = v73;
            }
          }
          v38 = gettext(&byte_8133734);
          add_dlg_button_do((dialog *)v25, v38, 1, ok_dialog, 0, (done_handler_T *)tp_open, type_querya);
        }
        if ( get_opt_(cmdline_options, "anonymous")->number )
        {
          --v34;
        }
        else
        {
          if ( term )
          {
            v63 = get_terminal_codepage(term);
            if ( v63 != current_charset )
            {
              v79 = v63;
              v64 = get_cp_mime_name(v63);
              bind_textdomain_codeset("elinks", v64);
              current_charset = v79;
            }
          }
          v65 = gettext(&byte_81283FD);
          add_dlg_button_do((dialog *)v25, v65, 1, ok_dialog, 0, (done_handler_T *)tp_save, type_querya);
        }
        if ( term )
        {
          v39 = get_terminal_codepage(term);
          if ( v39 != current_charset )
          {
            v74 = v39;
            v40 = get_cp_mime_name(v39);
            bind_textdomain_codeset("elinks", v40);
            current_charset = v74;
          }
        }
        v41 = gettext(&byte_813373A);
        add_dlg_button_do((dialog *)v25, v41, 1, ok_dialog, 0, (done_handler_T *)tp_display, type_querya);
        v42 = type_querya->cached;
        if ( v42 && v42->head )
        {
          if ( term )
          {
            v43 = get_terminal_codepage(term);
            if ( v43 != current_charset )
            {
              v75 = v43;
              v44 = get_cp_mime_name(v43);
              bind_textdomain_codeset("elinks", v44);
              current_charset = v75;
            }
          }
          v45 = gettext(&byte_8133743);
          add_dlg_button_do((dialog *)v25, v45, 1, tp_show_header, type_querya, 0, 0);
        }
        else
        {
          --v34;
        }
        if ( term )
        {
          v46 = get_terminal_codepage(term);
          if ( v46 != current_charset )
          {
            v76 = v46;
            v47 = get_cp_mime_name(v46);
            bind_textdomain_codeset("elinks", v47);
            current_charset = v76;
          }
        }
        v48 = gettext(&cancelbutton);
        add_dlg_button_do((dialog *)v25, v48, 2, ok_dialog, 0, tp_cancel, type_querya);
        if ( !assert_failed )
        {
          v49 = *((_DWORD *)v25 + 8) == v34;
          assert_failed = *((_DWORD *)v25 + 8) != v34;
          if ( !v49 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/download.c";
            errline = 1248;
            elinks_internal("assertion widgets == (dlg)->number_of_widgets failed!");
          }
        }
        v50 = getml(v25, 0);
        if ( v50 )
        {
          v51 = do_dialog(term, (dialog *)v25, v50);
          if ( v51 )
          {
            select_widget_by_id(v51, v88);
            result = 1;
            goto LABEL_18;
          }
          goto LABEL_80;
        }
LABEL_109:
        mem_free(v25);
        result = 1;
LABEL_18:
        if ( !handler )
          return result;
LABEL_19:
        v69 = result;
        mem_free(handler);
        return v69;
      }
      mem_free(v25);
LABEL_106:
      result = 1;
      goto LABEL_19;
    }
  }
  v7 = 1;
LABEL_4:
  v8 = ses_forward(ses, frame);
  result = 0;
  if ( v8 )
    v8->plain = v7;
  return result;
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080D6820) --------------------------------------------------------
void __cdecl create_history(ses_history *history)
{
  history->history.prev = history;
  history->history.next = history;
  history->current = 0;
}

//----- (080D6840) --------------------------------------------------------
void __cdecl add_to_history(ses_history *history, location *loc)
{
  location *current; // ecx
  location *next; // ecx

  current = history->current;
  if ( current )
  {
    loc->next = current->next;
    loc->prev = history->current;
    history->current->next = loc;
  }
  else
  {
    next = (location *)history->history.next;
    loc->prev = (location *)history;
    loc->next = next;
    history->history.next = loc;
  }
  loc->next->prev = loc;
  history->current = loc;
}

//----- (080D6890) --------------------------------------------------------
void __cdecl del_from_history(ses_history *history, location *loc)
{
  ses_history *current; // ecx
  location *prev; // ecx
  location *next; // ecx

  current = (ses_history *)history->current;
  if ( current == (ses_history *)loc )
  {
    prev = (location *)current->history.prev;
    history->current = prev;
    if ( history != (ses_history *)prev )
      goto LABEL_3;
  }
  else if ( history != current )
  {
    goto LABEL_3;
  }
  next = 0;
  if ( history != (ses_history *)loc->next )
    next = loc->next;
  history->current = next;
LABEL_3:
  loc->next->prev = loc->prev;
  loc->prev->next = loc->next;
}

//----- (080D68E0) --------------------------------------------------------
void __cdecl go_history(session *ses, location *loc)
{
  task_type type; // edx

  type = ses->task.type;
  ses->reloadlevel = CACHE_MODE_NORMAL;
  if ( type )
  {
    abort_loading(ses, 0);
    print_screen_status(ses);
    reload(ses, CACHE_MODE_NORMAL);
  }
  else if ( ses->history.current )
  {
    if ( &ses->history != (ses_history *)loc )
    {
      abort_loading(ses, 0);
      set_session_referrer(ses, 0);
      ses_goto(ses, loc->vs.uri, 0, loc, CACHE_MODE_ALWAYS, TASK_HISTORY, 0);
    }
  }
}

//----- (080D69A0) --------------------------------------------------------
void __cdecl go_history_by_n(session *ses, int n)
{
  int v2; // ecx
  location *current; // eax
  int v4; // ecx

  v2 = n;
  current = ses->history.current;
  if ( current )
  {
    if ( n <= 0 )
    {
      while ( v2 )
      {
        ++v2;
        if ( (ses_history *)current->prev == &ses->history )
          break;
        current = current->prev;
      }
    }
    else
    {
      v4 = n - 1;
      while ( (ses_history *)current->next != &ses->history )
      {
        if ( !v4 )
        {
          current = current->next;
          break;
        }
        --v4;
        current = current->next;
      }
    }
    go_history(ses, current);
  }
}

//----- (080D6A10) --------------------------------------------------------
void __cdecl go_unback(session *ses)
{
  go_history_by_n(ses, 1);
}

//----- (080D6A30) --------------------------------------------------------
void __cdecl go_back(session *ses)
{
  go_history_by_n(ses, -1);
}

//----- (080D6A50) --------------------------------------------------------
void __cdecl clean_unhistory(ses_history *history)
{
  location *current; // eax
  ses_history *next; // eax

  current = history->current;
  if ( current )
  {
    while ( 1 )
    {
      next = (ses_history *)current->next;
      if ( next == history )
        break;
      *((_DWORD *)next->history.next + 1) = next->history.prev;
      *(_DWORD *)next->history.prev = next->history.next;
      destroy_location((location *)next);
      current = history->current;
    }
  }
}

//----- (080D6A90) --------------------------------------------------------
void __cdecl destroy_history(ses_history *history)
{
  location *i; // eax

  for ( i = (location *)history->history.next; history != history->history.next; i = (location *)history->history.next )
  {
    i->next->prev = i->prev;
    i->prev->next = i->next;
    destroy_location(i);
  }
  history->current = 0;
}

//----- (080D6AD0) --------------------------------------------------------
void __cdecl ses_history_move(session *ses)
{
  location *current; // esi
  location *location; // esi
  ses_history *p_history; // edi
  location *prev; // eax
  location *next; // eax

  free_files(ses);
  if ( ses->search_word )
    mem_free(ses->search_word);
  current = ses->history.current;
  ses->search_word = 0;
  if ( current )
  {
    location = ses->task.target.location;
    if ( location )
    {
      p_history = &ses->history;
      if ( location != (location *)&ses->history )
      {
        ses->history.current = location;
        if ( !compare_uri(location->vs.uri, ses->loading_uri, (uri_component)0) )
        {
          prev = ses->history.current;
          if ( location == prev )
          {
            prev = location->prev;
            ses->history.current = prev;
          }
          if ( p_history == (ses_history *)prev )
          {
            next = 0;
            if ( p_history != (ses_history *)location->next )
              next = location->next;
            ses->history.current = next;
          }
          location->next->prev = location->prev;
          location->prev->next = location->next;
          destroy_location(location);
          ses_forward(ses, 0);
          if ( get_opt_(config_options, "document.history.keep_unhistory")->number )
            clean_unhistory(&ses->history);
        }
      }
    }
  }
}

//----- (080D6BD0) --------------------------------------------------------
void __cdecl destroy_location(location *loc)
{
  location *next; // ecx
  list_head_elinks *p_frames; // esi
  location *v3; // ebx
  location *v4; // eax
  location *i; // edx
  list_head_elinks *j; // edx
  location *v7; // ebx
  location *v8; // edx

  next = (location *)loc->frames.next;
  p_frames = &loc->frames;
  v3 = next;
  if ( next != (location *)&loc->frames )
  {
    do
    {
      destroy_vs((view_state *)&v3->download, 1);
      mem_free(v3->frames.next);
      v3 = v3->next;
    }
    while ( v3 != (location *)p_frames );
    next = (location *)loc->frames.next;
  }
  v4 = next;
  for ( i = next; p_frames != (list_head_elinks *)i; i = i->next )
    ;
  for ( j = (list_head_elinks *)loc->frames.prev; p_frames != j; j = (list_head_elinks *)j->prev )
    ;
  v7 = next->next;
  if ( next != (location *)p_frames )
  {
    v8 = next->next;
    while ( 1 )
    {
      v8->prev = v4->prev;
      v4->prev->next = v4->next;
      mem_free(v4);
      v8 = v7->next;
      v4 = v7;
      if ( p_frames == (list_head_elinks *)v7 )
        break;
      v7 = v7->next;
    }
  }
  destroy_vs(&loc->vs, 1);
  mem_free(loc);
}

//----- (080D6C90) --------------------------------------------------------
void __cdecl copy_location(location *dst, location *src)
{
  list_head_elinks *p_frames; // edi
  list_head_elinks *prev; // esi
  char *v4; // ebx
  unsigned __int8 *v5; // eax
  void *next; // eax

  p_frames = &dst->frames;
  dst->frames.prev = &dst->frames;
  dst->frames.next = &dst->frames;
  prev = (list_head_elinks *)src->frames.prev;
  if ( prev == &src->frames )
  {
LABEL_6:
    copy_vs(&dst->vs, &src->vs);
    return;
  }
  while ( 1 )
  {
    v4 = (char *)mem_calloc(1u, 0x40u);
    if ( v4 )
      break;
LABEL_5:
    prev = (list_head_elinks *)prev->prev;
    if ( &src->frames == prev )
      goto LABEL_6;
  }
  v5 = stracpy((const unsigned __int8 *)prev[1].next);
  *((_DWORD *)v4 + 2) = v5;
  if ( v5 )
  {
    *((_DWORD *)v4 + 3) = 0;
    copy_vs((view_state *)(v4 + 16), (view_state *)&prev[2]);
    next = p_frames->next;
    *((_DWORD *)v4 + 1) = p_frames;
    *(_DWORD *)v4 = next;
    p_frames->next = v4;
    *(_DWORD *)(*(_DWORD *)v4 + 4) = v4;
    goto LABEL_5;
  }
  mem_free(v4);
}

//----- (080D6D60) --------------------------------------------------------
download *__cdecl get_current_download(session *ses)
{
  location *current; // eax
  download *result; // eax
  list_head_elinks *next; // edx

  if ( !ses )
    return 0;
  if ( ses->task.type )
  {
    result = &ses->loading;
    if ( ses->loading.state.basic != S_OK )
      return result;
    goto LABEL_7;
  }
  current = ses->history.current;
  if ( !current )
    return 0;
  result = &current->download;
  if ( result->state.basic != S_OK )
    return result;
LABEL_7:
  next = (list_head_elinks *)ses->more_files.next;
  if ( next != &ses->more_files )
  {
    while ( ((int)next[1].prev & 1) == 0 || (int)next[7].prev < 0 )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &ses->more_files )
        return result;
    }
    return (download *)&next[4];
  }
  return result;
}

//----- (080D6DD0) --------------------------------------------------------
link *__cdecl get_current_link_in_view(document_view *doc_view)
{
  int current_link; // eax
  document *document; // edx
  link *result; // eax

  if ( !doc_view )
    return 0;
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 )
    return 0;
  document = doc_view->document;
  if ( current_link >= document->nlinks )
    return 0;
  result = &document->links[current_link];
  if ( result )
  {
    if ( result->type > (unsigned int)LINK_MAP )
      return 0;
  }
  return result;
}

//----- (080D6E10) --------------------------------------------------------
int __cdecl eat_kbd_repeat_count(session *ses)
{
  int repeat_count; // ebx

  repeat_count = ses->kbdprefix.repeat_count;
  ses->kbdprefix.repeat_count = 0;
  print_screen_status(ses);
  return repeat_count;
}

//----- (080D6E40) --------------------------------------------------------
link *__cdecl get_current_session_link(session *ses)
{
  document_view *v1; // eax
  int current_link; // edx
  document *document; // ecx
  link *result; // eax

  v1 = current_frame(ses);
  if ( !v1 )
    return 0;
  current_link = v1->vs->current_link;
  if ( current_link < 0 )
    return 0;
  document = v1->document;
  if ( current_link >= document->nlinks )
    return 0;
  result = &document->links[current_link];
  if ( result )
  {
    if ( result->type > (unsigned int)LINK_MAP )
      return 0;
  }
  return result;
}

//----- (080D6E80) --------------------------------------------------------
unsigned __int8 *__cdecl get_current_link_name(session *ses, unsigned __int8 *str, size_t str_size)
{
  link *current_session_link; // ebx
  unsigned __int8 *where; // esi
  global_history_item *global_history_item; // eax
  const unsigned __int8 *title; // eax

  current_session_link = get_current_session_link(ses);
  if ( !assert_failed && (assert_failed = str == 0 || str_size == 0) != 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 1387;
    elinks_internal("assertion str && str_size > 0 failed!");
    if ( current_session_link )
    {
LABEL_4:
      where = current_session_link->where;
      if ( where )
      {
        global_history_item = get_global_history_item(current_session_link->where);
        if ( !global_history_item )
          goto LABEL_11;
      }
      else
      {
        where = current_session_link->where_img;
        global_history_item = get_global_history_item(where);
        if ( !global_history_item )
          goto LABEL_11;
      }
      title = global_history_item->title;
      if ( title )
        return safe_strncpy(str, title, str_size);
LABEL_11:
      if ( current_session_link->type <= (unsigned int)LINK_MAP )
      {
        title = current_session_link->data.name;
        if ( !title )
          title = where;
      }
      else
      {
        title = where;
      }
      return safe_strncpy(str, title, str_size);
    }
  }
  else if ( current_session_link )
  {
    goto LABEL_4;
  }
  return 0;
}

//----- (080D6F70) --------------------------------------------------------
unsigned __int8 *__cdecl get_current_link_url(session *ses, unsigned __int8 *str, size_t str_size)
{
  unsigned __int8 *result; // eax
  const unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // [esp+1Ch] [ebp-Ch]

  result = (unsigned __int8 *)get_current_session_link(ses);
  if ( !assert_failed && (assert_failed = str == 0 || str_size == 0) != 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
    errline = 1370;
    v5 = result;
    elinks_internal("assertion str && str_size > 0 failed!");
    result = v5;
    if ( !v5 )
      return result;
  }
  else if ( !result )
  {
    return result;
  }
  v4 = (const unsigned __int8 *)*((_DWORD *)result + 2);
  if ( !v4 )
    v4 = (const unsigned __int8 *)*((_DWORD *)result + 4);
  return safe_strncpy(str, v4, str_size);
}

//----- (080D7010) --------------------------------------------------------
unsigned __int8 *__cdecl get_current_title(session *ses, unsigned __int8 *str, size_t str_size)
{
  document_view *v3; // eax
  const unsigned __int8 *title; // eax
  document_view *v6; // [esp+1Ch] [ebp-Ch]

  v3 = current_frame(ses);
  if ( !assert_failed )
  {
    assert_failed = str == 0 || str_size == 0;
    if ( str == 0 || str_size == 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
      errline = 1350;
      v6 = v3;
      elinks_internal("assertion str && str_size > 0 failed!");
      v3 = v6;
    }
  }
  if ( v3 && (title = v3->document->title) != 0 )
    return safe_strncpy(str, title, str_size);
  else
    return 0;
}

//----- (080D70B0) --------------------------------------------------------
unsigned __int8 *__cdecl get_current_url(session *ses, unsigned __int8 *str, size_t str_size)
{
  location *current; // eax
  uri *loading_uri; // edx
  unsigned __int8 *post; // eax
  const char *string; // ebx
  signed int v7; // eax
  size_t v8; // edi

  if ( assert_failed || (assert_failed = str == 0 || str_size == 0) == 0 )
  {
    current = ses->history.current;
    if ( current )
      goto LABEL_4;
LABEL_11:
    loading_uri = ses->loading_uri;
    if ( loading_uri )
      goto LABEL_5;
    return 0;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
  errline = 1325;
  elinks_internal("assertion str && str_size > 0 failed!");
  current = ses->history.current;
  if ( !current )
    goto LABEL_11;
LABEL_4:
  loading_uri = current->vs.uri;
  if ( !loading_uri )
    return 0;
LABEL_5:
  post = loading_uri->post;
  string = (const char *)loading_uri->string;
  if ( post )
    v7 = post - 1 - loading_uri->string;
  else
    v7 = strlen((const char *)loading_uri->string);
  v8 = str_size - 1;
  if ( v7 <= (int)(str_size - 1) )
    v8 = v7;
  return safe_strncpy(str, (const unsigned __int8 *)string, v8 + 1);
}

//----- (080D7180) --------------------------------------------------------
void __cdecl set_session_referrer(session *ses, uri *referrer)
{
  if ( ses->referrer )
    done_uri(ses->referrer);
  if ( referrer )
    ++referrer->object.refcount;
  ses->referrer = referrer;
}

//----- (080D71C0) --------------------------------------------------------
frame *__cdecl ses_find_frame(session *ses, unsigned __int8 *name)
{
  location *current; // edi
  frame *prev; // ebx
  list_head_elinks *p_frames; // edi
  frame *result; // eax

  current = ses->history.current;
  if ( assert_failed
    || (assert_failed = current == 0, !current)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c",
        errline = 1261,
        elinks_internal("assertion have_location(ses) failed: ses_request_frame: no location yet"),
        assert_failed) )
  {
    result = 0;
    assert_failed = 0;
  }
  else
  {
    prev = (frame *)current->frames.prev;
    p_frames = &current->frames;
    if ( prev == (frame *)p_frames )
    {
      return 0;
    }
    else
    {
      while ( c_strcasecmp((const char *)prev->name, (const char *)name) )
      {
        prev = prev->prev;
        if ( prev == (frame *)p_frames )
          return 0;
      }
      return prev;
    }
  }
  return result;
}

//----- (080D7280) --------------------------------------------------------
void __usercall load_additional_file(file_to_load *ftl@<eax>, cache_mode cache_mode@<edx>)
{
  document_view *v4; // eax
  document *document; // eax
  uri *uri; // edx

  v4 = current_frame(ftl->ses);
  if ( v4 && (document = v4->document) != 0 )
    uri = document->uri;
  else
    uri = 0;
  load_uri(ftl->uri, uri, &ftl->download, (connection_priority)ftl->pri, cache_mode, -1LL);
}

//----- (080D72F0) --------------------------------------------------------
void __cdecl process_file_requests(session *ses)
{
  char v1; // al
  list_head_elinks *p_more_files; // esi
  list_head_elinks *next; // ebx
  int v4; // edx
  char prev; // al

  v1 = *((_BYTE *)&ses->status + 52);
  if ( (v1 & 2) == 0 )
  {
    *((_BYTE *)&ses->status + 52) = v1 | 2;
    p_more_files = &ses->more_files;
    do
    {
      next = (list_head_elinks *)ses->more_files.next;
      if ( next == p_more_files )
        break;
      v4 = 0;
      do
      {
        while ( 1 )
        {
          prev = (char)next[1].prev;
          if ( (prev & 1) == 0 )
            break;
          next = (list_head_elinks *)next->next;
          if ( next == p_more_files )
            goto LABEL_8;
        }
        LOBYTE(next[1].prev) = prev | 1;
        load_additional_file((file_to_load *)next, CACHE_MODE_NORMAL);
        next = (list_head_elinks *)next->next;
        v4 = 1;
      }
      while ( next != p_more_files );
LABEL_8:
      ;
    }
    while ( v4 );
    *((_BYTE *)&ses->status + 52) &= ~2u;
  }
}

//----- (080D7370) --------------------------------------------------------
void __cdecl abort_loading(session *ses, int interrupt)
{
  location *current; // eax
  list_head_elinks *p_more_files; // esi
  list_head_elinks *next; // ebx
  int v5; // eax

  current = ses->history.current;
  if ( current )
  {
    cancel_download(&current->download, interrupt);
    p_more_files = &ses->more_files;
    do
    {
      next = (list_head_elinks *)ses->more_files.next;
      if ( next == p_more_files )
        break;
      v5 = 0;
      do
      {
        if ( ((int)next[1].prev & 1) != 0 && (int)next[7].prev >= 0 )
        {
          cancel_download((download *)&next[4], interrupt);
          v5 = 1;
        }
        next = (list_head_elinks *)next->next;
      }
      while ( next != p_more_files );
    }
    while ( v5 );
  }
  abort_preloading(ses, interrupt);
}

//----- (080D73F0) --------------------------------------------------------
void __cdecl reload(session *ses, cache_mode cache_mode)
{
  cache_mode v2; // edi
  location *current; // eax
  list_head_elinks *next; // ebx
  list_head_elinks *i; // esi
  cache_mode reloadlevel; // eax

  v2 = cache_mode;
  abort_loading(ses, 0);
  if ( cache_mode == CACHE_MODE_INCREMENT )
  {
    reloadlevel = ses->reloadlevel;
    v2 = CACHE_MODE_NEVER;
    if ( reloadlevel <= CACHE_MODE_FORCE_RELOAD )
    {
      v2 = reloadlevel + 1;
      ses->reloadlevel = reloadlevel + 1;
    }
  }
  else
  {
    ses->reloadlevel = cache_mode;
  }
  current = ses->history.current;
  if ( current )
  {
    current->download.data = ses;
    current->download.callback = (download_callback_T *)doc_loading_callback;
    load_uri(current->vs.uri, ses->referrer, &current->download, PRI_MAIN, v2, -1LL);
    next = (list_head_elinks *)ses->more_files.next;
    for ( i = &ses->more_files; i != next; next = (list_head_elinks *)next->next )
    {
      while ( ((int)next[1].prev & 1) != 0 && (int)next[7].prev >= 0 )
      {
        next = (list_head_elinks *)next->next;
        if ( i == next )
          return;
      }
      next[6].prev = next;
      next[6].next = file_loading_callback;
      load_additional_file((file_to_load *)next, v2);
    }
  }
}

//----- (080D74D0) --------------------------------------------------------
void __cdecl check_questions_queue(session *ses)
{
  void (__cdecl **i)(session *, _DWORD); // ebx

  for ( i = (void (__cdecl **)(session *, _DWORD))questions_queue.next;
        questions_queue.next != &questions_queue;
        i = (void (__cdecl **)(session *, _DWORD))questions_queue.next )
  {
    i[2](ses, i[3]);
    *((_DWORD *)*i + 1) = i[1];
    *(_DWORD *)i[1] = *i;
    mem_free(i);
  }
}

//----- (080D7530) --------------------------------------------------------
void __cdecl free_files(session *ses)
{
  list_head_elinks *p_more_files; // esi
  list_head_elinks *next; // ebx
  list_head_elinks *v3; // edx
  int v4; // eax
  list_head_elinks *v5; // ebx
  _DWORD *prev; // eax
  list_head_elinks *v7; // eax
  list_head_elinks *v8; // ecx
  list_head_elinks *i; // ecx
  list_head_elinks *v10; // ebx
  list_head_elinks *v11; // edi

  p_more_files = &ses->more_files;
  while ( 1 )
  {
    next = (list_head_elinks *)ses->more_files.next;
    v3 = next;
    if ( next == p_more_files )
      break;
    v4 = 0;
    do
    {
      if ( ((int)next[1].prev & 1) != 0 && (int)next[7].prev >= 0 )
      {
        cancel_download((download *)&next[4], 0);
        v4 = 1;
      }
      next = (list_head_elinks *)next->next;
    }
    while ( next != p_more_files );
    if ( !v4 )
    {
      v3 = (list_head_elinks *)ses->more_files.next;
      v5 = v3;
      if ( v3 != p_more_files )
      {
        do
        {
          prev = v5[2].prev;
          if ( prev )
            --prev[2];
          if ( v5[3].prev )
            done_uri((uri *)v5[3].prev);
          if ( v5[3].next )
            mem_free(v5[3].next);
          v5 = (list_head_elinks *)v5->next;
        }
        while ( v5 != p_more_files );
        v3 = (list_head_elinks *)ses->more_files.next;
      }
      break;
    }
  }
  v7 = v3;
  if ( v3 != p_more_files )
  {
    v8 = v3;
    do
      v8 = (list_head_elinks *)v8->next;
    while ( v8 != p_more_files );
  }
  for ( i = (list_head_elinks *)ses->more_files.prev; i != p_more_files; i = (list_head_elinks *)i->prev )
    ;
  v10 = (list_head_elinks *)v3->next;
  if ( v3 != p_more_files )
  {
    do
    {
      v11 = v10;
      v10->prev = v7->prev;
      *(_DWORD *)v7->prev = v7->next;
      mem_free(v7);
      v10 = (list_head_elinks *)v10->next;
      v7 = v11;
    }
    while ( v11 != p_more_files );
  }
}

//----- (080D7610) --------------------------------------------------------
void __usercall done_session_info(session_info *info@<eax>)
{
  info->next->prev = info->prev;
  info->prev->next = info->next;
  kill_timer(&info->timer);
  if ( info->uri )
    done_uri(info->uri);
  if ( info->referrer )
    done_uri(info->referrer);
  mem_free(info);
}

//----- (080D7660) --------------------------------------------------------
void __cdecl session_info_timeout(int id)
{
  list_head_elinks *next; // eax
  list_head_elinks *v2; // edx
  void *v3; // ecx

  next = (list_head_elinks *)session_info_0.next;
  if ( session_info_0.next != &session_info_0 )
  {
    while ( (void *)id != next[1].next )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &session_info_0 )
        return;
    }
    v2 = (list_head_elinks *)sessions.next;
    if ( sessions.next != &sessions )
    {
      v3 = next[2].next;
      if ( sessions.next == v3 )
        goto LABEL_11;
      while ( 1 )
      {
        v2 = (list_head_elinks *)v2->next;
        if ( v2 == &sessions )
          break;
        if ( v2 == v3 )
          goto LABEL_11;
      }
    }
    next[2].next = 0;
LABEL_11:
    next[1].prev = 0;
    done_session_info((session_info *)next);
  }
}

//----- (080D76D0) --------------------------------------------------------
void done_saved_session_info()
{
  session_info *i; // eax

  for ( i = (session_info *)session_info_0.next;
        session_info_0.next != &session_info_0;
        i = (session_info *)session_info_0.next )
  {
    done_session_info(i);
  }
}

//----- (080D7700) --------------------------------------------------------
void __cdecl dialog_goto_url_open(void *data)
{
  dialog_goto_url((session *)data, 0);
}

//----- (080D7720) --------------------------------------------------------
void __usercall init_remote_session(session *ses@<eax>, remote_session_flags *remote_ptr@<edx>, uri *uri@<ecx>)
{
  remote_session_flags v4; // esi
  unsigned __int8 *v5; // eax
  remote_session_flags v6; // eax
  unsigned int v7; // esi
  int cp_index; // eax

  v4 = *remote_ptr;
  if ( (*remote_ptr & 4) != 0 )
  {
    goto_uri(ses, uri);
    v6 = SES_REMOTE_NEW_TAB;
    v7 = v4 & 0xFFFFFFFB;
    if ( v7 )
      v6 = v7;
    *remote_ptr = v6;
  }
  else
  {
    if ( (v4 & 1) != 0 )
    {
      open_uri_in_new_tab(ses, uri, 0, 1);
      if ( (v4 & 8) == 0 )
        return;
      goto LABEL_14;
    }
    if ( (v4 & 2) != 0 )
    {
      if ( can_open_in_new(ses->tab->term) )
        open_uri_in_new_window(ses, uri, 0, ses->tab->term->environment, CACHE_MODE_NORMAL, TASK_NONE);
    }
    else
    {
      if ( (v4 & 0x20) == 0 )
      {
        if ( (v4 & 0x40) != 0 )
        {
          if ( uri )
          {
            v5 = memacpy(uri->data, *(unsigned __int16 *)((char *)uri + 49));
            if ( v5 )
              info_box(ses->tab->term, MSGBOX_FREE_TEXT, "Error", ALIGN_CENTER, v5);
          }
          return;
        }
        if ( (v4 & 8) == 0 )
          return;
LABEL_14:
        dialog_goto_url_open(ses);
        return;
      }
      if ( uri )
      {
        cp_index = get_cp_index("System");
        add_bookmark_cp(0, 1, cp_index, uri->string, uri->string);
      }
    }
  }
}

//----- (080D78D0) --------------------------------------------------------
string *__cdecl encode_session_info(string *info, list_head_elinks *url_list)
{
  list_head_elinks *next; // ebx
  signed int v3; // edi
  unsigned int length; // eax
  int v5; // ecx
  size_t v6; // ecx
  void *v7; // edx
  unsigned __int8 *v9; // eax
  size_t v10; // [esp+10h] [ebp-28h]
  void *v11; // [esp+14h] [ebp-24h]
  void *v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  unsigned int v14; // [esp+1Ch] [ebp-1Ch]

  if ( init_string(info) )
  {
    next = (list_head_elinks *)url_list->next;
    if ( url_list->next == url_list )
      return info;
    while ( 1 )
    {
      while ( 1 )
      {
        v7 = next[1].next;
        if ( !assert_failed )
          break;
LABEL_14:
        assert_failed = 0;
        next = (list_head_elinks *)next->next;
        if ( next == url_list )
          return info;
      }
      v3 = (signed int)next[1].prev + 1;
      if ( info && v7 && v3 >= 0 )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        v11 = v7;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        v7 = v11;
        if ( assert_failed )
          goto LABEL_14;
      }
      if ( v3 )
      {
        length = info->length;
        v5 = v3 + length;
        length += 255;
        v13 = v5;
        v6 = v5 + 256;
        LOBYTE(length) = 0;
        LOBYTE(v6) = 0;
        v14 = length;
        if ( v6 <= length )
          goto LABEL_10;
        v12 = v7;
        v10 = v6;
        v9 = (unsigned __int8 *)mem_realloc(info->source, v6);
        if ( v9 )
          break;
      }
LABEL_12:
      next = (list_head_elinks *)next->next;
      if ( next == url_list )
        return info;
    }
    info->source = v9;
    memset(&v9[v14], 0, v10 - v14);
    v7 = v12;
LABEL_10:
    if ( info->source )
    {
      memcpy(&info->source[info->length], v7, v3);
      info->source[v13] = 0;
      info->length = v13;
    }
    goto LABEL_12;
  }
  return 0;
}

//----- (080D7A50) --------------------------------------------------------
session *__cdecl init_session(session *base_session, terminal *term, uri *uri, int in_background)
{
  session *v4; // eax
  session *v5; // ebx
  window *inited; // eax
  led *v7; // eax
  session *next; // eax
  location *current; // eax
  uri *v10; // eax
  document_view *doc_view; // eax
  view_state *vs; // eax
  document_view *v13; // edx
  int tab_number; // eax
  unsigned __int8 *auto_save_bookmark_foldername_utf8; // eax
  unsigned __int8 *v17; // esi
  option_elinks *opt_rec; // eax
  session *v19; // [esp+0h] [ebp-58h]
  view_state *dst; // [esp+38h] [ebp-20h]
  terminal *v21; // [esp+3Ch] [ebp-1Ch]

  v4 = (session *)mem_calloc(1u, 0xE0u);
  v5 = v4;
  if ( !v4 )
    return v5;
  inited = init_tab(term, v4, tabwin_func);
  v5->tab = inited;
  if ( !inited )
  {
    v19 = v5;
    v5 = 0;
    mem_free(v19);
    return v5;
  }
  create_history(&v5->history);
  v5->scrn_frames.prev = &v5->scrn_frames;
  v5->scrn_frames.next = &v5->scrn_frames;
  v5->more_files.prev = &v5->more_files;
  v5->more_files.next = &v5->more_files;
  v5->type_queries.prev = &v5->type_queries;
  v5->type_queries.next = &v5->type_queries;
  v5->task.type = TASK_NONE;
  v5->display_timer = 0;
  init_led_panel(&v5->status.leds);
  v5->status.ssl_led = register_led(v5, 0);
  v5->status.insert_mode_led = register_led(v5, 1);
  v5->status.ecmascript_led = register_led(v5, 2);
  v7 = register_led(v5, 3);
  *(_BYTE *)&v5->status |= 0x78u;
  v5->status.popup_led = v7;
  next = (session *)sessions.next;
  v5->prev = (session *)&sessions;
  v5->next = next;
  sessions.next = v5;
  v5->next->prev = v5;
  update_status();
  if ( sessions.next != sessions.prev )
    goto LABEL_4;
  v21 = v5->tab->term;
  if ( !*get_opt_(config_options, "protocol.http.user_agent")->string )
    info_box(
      v21,
      (msgbox_flags)0,
      "Warning",
      ALIGN_CENTER,
      "You have an empty string in protocol.http.user_agent - this was a default value in the past, substituted by defaul"
      "t ELinks User-Agent string. However, currently this means that NO User-Agent HEADER WILL BE SENT AT ALL - if this "
      "is really what you want, set its value to \" \", otherwise please delete the line with this setting from your conf"
      "iguration file (if you have no idea what I'm talking about, just do this), so that the correct default setting wil"
      "l be used. Apologies for any inconvience caused.");
  if ( !get_opt_(config_options, "config.saving_style_w")->number )
  {
    opt_rec = get_opt_rec(config_options, "config.saving_style_w");
    opt_rec->value.number = 1;
    option_changed(v5, opt_rec);
    if ( get_opt_(config_options, "config.saving_style")->number != 3 )
      info_box(
        v21,
        (msgbox_flags)0,
        "Warning",
        ALIGN_CENTER,
        "You have option config.saving_style set to a de facto obsolete value. The configuration saving algorithms of ELi"
        "nks were changed from the last time you upgraded ELinks. Now, only those options which you actually changed are "
        "saved to the configuration file, instead of all the options. This simplifies our situation greatly when we see t"
        "hat some option has an inappropriate default value or we need to change the semantics of some option in a subtle"
        " way. Thus, we recommend you change the value of config.saving_style option to 3 in order to get the \"right\" b"
        "ehaviour. Apologies for any inconvience caused.");
  }
  if ( !first_use )
  {
    if ( !uri && get_opt_(config_options, "ui.sessions.auto_restore")->number )
    {
      auto_save_bookmark_foldername_utf8 = get_auto_save_bookmark_foldername_utf8();
      v17 = auto_save_bookmark_foldername_utf8;
      if ( auto_save_bookmark_foldername_utf8 )
      {
        open_bookmark_folder(v5, auto_save_bookmark_foldername_utf8);
        mem_free(v17);
      }
      goto LABEL_13;
    }
    goto LABEL_4;
  }
  if ( uri )
  {
    first_use = 0;
    msg_box(
      v21,
      0,
      (msgbox_flags)0,
      "Welcome",
      ALIGN_CENTER,
      "Welcome to ELinks!\n\nPress ESC for menu. Documentation is available in Help menu.",
      v5,
      1,
      &okbutton,
      0,
      3);
LABEL_4:
    if ( base_session )
    {
      current = base_session->history.current;
      if ( current )
      {
        v10 = current->vs.uri;
        ++v10->object.refcount;
        ses_load(v5, v10, 0, 0, CACHE_MODE_ALWAYS, TASK_FORWARD);
        doc_view = v5->doc_view;
        if ( doc_view )
        {
          vs = doc_view->vs;
          if ( vs )
          {
            v13 = base_session->doc_view;
            if ( v13 )
            {
              if ( v13->vs )
              {
                dst = vs;
                destroy_vs(vs, 1);
                copy_vs(dst, base_session->doc_view->vs);
                v5->doc_view->vs = dst;
              }
            }
          }
        }
      }
    }
    if ( uri )
    {
      goto_uri(v5, uri);
    }
    else if ( !goto_url_home(v5) && get_opt_(config_options, "ui.startup_goto_dialog")->number )
    {
      dialog_goto_url_open(v5);
    }
    goto LABEL_13;
  }
  first_use = 0;
  msg_box(
    v21,
    0,
    (msgbox_flags)0,
    "Welcome",
    ALIGN_CENTER,
    "Welcome to ELinks!\n\nPress ESC for menu. Documentation is available in Help menu.",
    v5,
    1,
    &okbutton,
    dialog_goto_url_open,
    3);
LABEL_13:
  if ( !in_background )
  {
    tab_number = get_tab_number(v5->tab);
    switch_to_tab(term, tab_number, -1);
  }
  if ( !term->main_menu )
    activate_bfu_technology(v5, -1);
  return v5;
}

//----- (080D7F00) --------------------------------------------------------
const uri **__usercall request_additional_file@<eax>(
        session *ses@<eax>,
        unsigned __int8 *name@<edx>,
        uri *uri@<ecx>,
        int pri)
{
  session *v4; // ebx
  const uri **v5; // esi
  protocol_external_handler_T *protocol_external_handler; // eax
  unsigned __int8 *v8; // edx
  uri *v9; // ecx
  list_head_elinks *next; // edi
  list_head_elinks *p_more_files; // ebx
  const uri **v12; // eax
  unsigned __int8 *v13; // eax
  const uri *v14; // eax
  uri *ba; // [esp+10h] [ebp-28h]
  unsigned __int8 *srca; // [esp+14h] [ebp-24h]
  session *v19; // [esp+1Ch] [ebp-1Ch]

  v4 = ses;
  if ( uri->protocol == 18 )
    return 0;
  protocol_external_handler = get_protocol_external_handler(ses->tab->term, uri);
  v8 = name;
  v9 = uri;
  if ( protocol_external_handler )
    return 0;
  next = (list_head_elinks *)v4->more_files.next;
  if ( next == &v4->more_files )
  {
LABEL_12:
    srca = v8;
    ba = v9;
    v12 = (const uri **)mem_calloc(1u, 0x50u);
    v5 = v12;
    if ( v12 )
    {
      ++ba->object.refcount;
      v12[7] = ba;
      v13 = stracpy(srca);
      v5[12] = (const uri *)file_loading_callback;
      v5[13] = (const uri *)v5;
      v5[6] = (const uri *)v13;
      v5[2] = (const uri *)v4;
      v5[4] = (const uri *)pri;
      v14 = (const uri *)next->next;
      v5[1] = (const uri *)next;
      *v5 = v14;
      next->next = v5;
      (*v5)->protocol = (int)v5;
    }
  }
  else
  {
    v19 = v4;
    p_more_files = &v4->more_files;
    while ( !compare_uri((const uri *)next[3].prev, uri, URI_BASE) )
    {
      next = (list_head_elinks *)next->next;
      if ( next == p_more_files )
      {
        v4 = v19;
        v9 = uri;
        v8 = name;
        goto LABEL_12;
      }
    }
    if ( (int)next[2].next <= pri )
      return 0;
    next[2].next = (void *)pri;
    v5 = 0;
    move_download((download *)&next[4], (download *)&next[4], (connection_priority)pri);
  }
  return v5;
}

//----- (080D8020) --------------------------------------------------------
int __cdecl session_is_loading(session *ses)
{
  download *current_download; // eax
  download *v2; // ebx
  int basic; // edx
  int result; // eax
  cache_entry *cached; // ebx
  cache_entry *v6; // eax

  current_download = get_current_download(ses);
  v2 = current_download;
  if ( !current_download )
    return 0;
  basic = current_download->state.basic;
  result = 1;
  if ( basic >= 0 )
    return result;
  if ( !v2->cached || !cache_entry_is_valid(v2->cached) )
    return 0;
  cached = v2->cached;
  if ( !assert_failed )
  {
    assert_failed = cached == 0;
    if ( !cached )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
      errline = 555;
      elinks_internal("assertion cached failed!");
    }
  }
  v6 = follow_cached_redirects(cached);
  return v6 && !v6->redirect && (*((_BYTE *)v6 + 92) & 8) != 0;
}

//----- (080D80D0) --------------------------------------------------------
void __cdecl add_questions_entry(void (*callback)(session *, void *), void *data)
{
  _DWORD *v2; // eax
  void *next; // edx

  v2 = mem_alloc(0x10u);
  if ( v2 )
  {
    v2[2] = callback;
    v2[3] = data;
    next = questions_queue.next;
    v2[1] = &questions_queue;
    *v2 = next;
    questions_queue.next = v2;
    *(_DWORD *)(*v2 + 4) = v2;
  }
}

//----- (080D8110) --------------------------------------------------------
int __cdecl add_session_info(session *ses, uri *uri, uri *referrer, cache_mode cache_mode, task_type task)
{
  int *v5; // edi
  int result; // eax
  char *v7; // eax
  void *next; // eax

  v5 = (int *)mem_calloc(1u, 0x24u);
  result = -1;
  if ( v5 )
  {
    v7 = (char *)session_info_id;
    v5[2] = (int)session_info_id;
    session_info_id = v7 + 1;
    install_timer((timer_id_T *)v5 + 3, 10000, (void (*)(void *))session_info_timeout, v7);
    v5[4] = (int)ses;
    v5[7] = task;
    v5[8] = cache_mode;
    if ( uri )
    {
      ++uri->object.refcount;
      v5[5] = (int)uri;
    }
    if ( referrer )
    {
      ++referrer->object.refcount;
      v5[6] = (int)referrer;
    }
    next = session_info_0.next;
    v5[1] = (int)&session_info_0;
    *v5 = (int)next;
    session_info_0.next = v5;
    *(_DWORD *)(*v5 + 4) = v5;
    return v5[2];
  }
  return result;
}

//----- (080D81D0) --------------------------------------------------------
void __usercall request_frameset(session *ses@<eax>, frameset_desc *frameset_desc@<edx>, int depth@<ecx>)
{
  frameset_desc *v3; // ebx
  list_head_elinks *p_scrn_frames; // edi
  int i; // esi
  frameset_desc *subframe; // edx
  location *current; // eax
  frameset_desc *v8; // esi
  list_head_elinks *v9; // ebx
  char *v10; // eax
  unsigned __int8 *v11; // eax
  void *v12; // eax
  list_head_elinks *v13; // eax
  char *p; // [esp+1Ch] [ebp-3Ch]
  int v15; // [esp+20h] [ebp-38h]
  list_head_elinks *p_frames; // [esp+24h] [ebp-34h]
  uri *uri; // [esp+28h] [ebp-30h]
  int v18; // [esp+2Ch] [ebp-2Ch]
  list_head_elinks *next; // [esp+30h] [ebp-28h]
  list_head_elinks *v20; // [esp+30h] [ebp-28h]
  char *s2; // [esp+34h] [ebp-24h]

  if ( depth <= 5 )
  {
    v18 = depth + 1;
    if ( frameset_desc->n > 0 )
    {
      v3 = frameset_desc;
      p_scrn_frames = &ses->scrn_frames;
      for ( i = 0; frameset_desc->n > i; ++i )
      {
        subframe = v3->frame_desc[0].subframe;
        if ( !subframe )
        {
          s2 = (char *)v3->frame_desc[0].name;
          if ( !s2 )
            goto LABEL_5;
          uri = v3->frame_desc[0].uri;
          if ( !uri )
            goto LABEL_5;
          current = ses->history.current;
          if ( assert_failed
            || (assert_failed = current == 0, !current)
            && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c",
                errline = 339,
                elinks_internal("assertion have_location(ses) failed: request_frame: no location"),
                current = 0,
                assert_failed) )
          {
            assert_failed = 0;
            goto LABEL_5;
          }
          p_frames = &current->frames;
          next = (list_head_elinks *)current->frames.next;
          if ( next == &current->frames )
          {
LABEL_16:
            v10 = (char *)mem_calloc(1u, 0x40u);
            if ( v10 )
            {
              p = v10;
              v11 = stracpy((const unsigned __int8 *)s2);
              *((_DWORD *)p + 2) = v11;
              if ( v11 )
              {
                init_vs((view_state *)(p + 16), uri, -1);
                v12 = next->next;
                *((_DWORD *)p + 1) = next;
                *(_DWORD *)p = v12;
                next->next = p;
                *(_DWORD *)(*(_DWORD *)p + 4) = p;
                request_additional_file(ses, (unsigned __int8 *)s2, *((uri **)p + 5), 1);
              }
              else
              {
                mem_free(p);
              }
            }
            goto LABEL_5;
          }
          v15 = i;
          v8 = v3;
          v9 = (list_head_elinks *)current->frames.next;
          while ( c_strcasecmp((const char *)v9[1].next, s2) )
          {
            v9 = (list_head_elinks *)v9->next;
            if ( v9 == p_frames )
            {
              next = v9;
              v3 = v8;
              i = v15;
              goto LABEL_16;
            }
          }
          v20 = v9;
          v3 = v8;
          i = v15;
          v13 = (list_head_elinks *)ses->scrn_frames.next;
          if ( v13 == p_scrn_frames )
          {
LABEL_26:
            request_additional_file(ses, (unsigned __int8 *)s2, (uri *)v20[2].prev, 1);
            goto LABEL_5;
          }
          while ( v13[3].next != &v20[2] || !*((_DWORD *)v13[2].prev + 50) )
          {
            v13 = (list_head_elinks *)v13->next;
            if ( v13 == p_scrn_frames )
              goto LABEL_26;
          }
          subframe = (frameset_desc *)*((_DWORD *)v13[2].prev + 50);
        }
        request_frameset(ses, subframe, v18);
LABEL_5:
        v3 = (frameset_desc *)((char *)v3 + 20);
      }
    }
  }
}

//----- (080D83F0) --------------------------------------------------------
void __cdecl print_error_dialog(session *ses, connection_state state, uri *uri, connection_priority priority)
{
  unsigned __int8 *uri_string; // edi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *state_message; // eax
  int v9; // [esp+2Ch] [ebp-2Ch]
  string msg; // [esp+38h] [ebp-20h] BYREF

  if ( priority != PRI_CSS && init_string(&msg) )
  {
    if ( uri )
    {
      uri_string = get_uri_string(uri, URI_PUBLIC);
      if ( uri_string )
      {
        if ( (*((_BYTE *)ses->tab->term + 56) & 2) != 0 )
          decode_uri(uri_string);
        else
          decode_uri_for_display(uri_string);
        if ( ses->tab->term )
        {
          terminal_codepage = get_terminal_codepage(ses->tab->term);
          if ( terminal_codepage != current_charset )
          {
            v9 = terminal_codepage;
            cp_mime_name = get_cp_mime_name(terminal_codepage);
            bind_textdomain_codeset("elinks", cp_mime_name);
            current_charset = v9;
          }
        }
        v7 = gettext(&byte_81337BF);
        add_format_to_string(&msg, v7, uri_string);
        mem_free(uri_string);
        add_to_string(&msg, &byte_81337D5);
      }
    }
    state_message = get_state_message(state, ses->tab->term);
    add_to_string(&msg, state_message);
    info_box(ses->tab->term, MSGBOX_FREE_TEXT, "Error", ALIGN_CENTER, msg.source);
  }
}

//----- (080D8550) --------------------------------------------------------
int __cdecl decode_session_info(terminal *term, terminal_info *info)
{
  int length; // edi
  int magic; // ebx
  int v4; // edi
  _BYTE *v5; // eax
  uri *hooked_uri; // esi
  unsigned __int8 *v7; // edx
  uri *v8; // edi
  list_head_elinks *v9; // edx
  session *v10; // eax
  session_info *v12; // ebx
  list_head_elinks *next; // eax
  int i; // edx
  int v15; // edx
  list_head_elinks *v16; // eax
  session *ses; // ecx
  session *inited; // eax
  uri *uri; // eax
  window *tab_by_number; // eax
  unsigned __int8 *p; // [esp+28h] [ebp-40h]
  session *pb; // [esp+28h] [ebp-40h]
  list_head_elinks *pa; // [esp+28h] [ebp-40h]
  list_head_elinks *p_windows; // [esp+2Ch] [ebp-3Ch]
  session *base_session; // [esp+34h] [ebp-34h]
  int v26; // [esp+38h] [ebp-30h]
  unsigned __int8 *str; // [esp+3Ch] [ebp-2Ch]
  remote_session_flags remote[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  length = info->length;
  remote[0] = 0;
  magic = info->magic;
  if ( magic == -257 )
  {
    if ( !info->session_info )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
      errline = 1071;
      elinks_internal("Remote magic with no remote flags");
      return 0;
    }
    next = (list_head_elinks *)sessions.next;
    if ( sessions.next == &sessions )
      return 0;
    remote[0] = (remote_session_flags)info->session_info;
    for ( i = *(_DWORD *)(*((_DWORD *)sessions.next + 2) + 20);
          (*(_BYTE *)(i + 56) & 1) == 0;
          i = *((_DWORD *)next[1].next + 5) )
    {
      next = (list_head_elinks *)next->next;
      if ( next == &sessions )
        return 0;
    }
    tab_by_number = get_tab_by_number((terminal *)i, *(_DWORD *)(i + 60));
    if ( !tab_by_number )
      return 0;
    base_session = (session *)tab_by_number->data;
    if ( !base_session )
      return 0;
    goto LABEL_55;
  }
  if ( magic != -256 )
  {
    if ( magic > 0 )
    {
      base_session = 0;
      if ( magic <= length - 8 )
        goto LABEL_5;
    }
    base_session = 0;
    return init_session(base_session, term, 0, 0) != 0;
  }
  v12 = (session_info *)session_info_0.next;
  if ( session_info_0.next != &session_info_0 )
  {
    while ( info->session_info != v12->id )
    {
      v12 = v12->next;
      if ( v12 == (session_info *)&session_info_0 )
        goto LABEL_28;
    }
    v16 = (list_head_elinks *)sessions.next;
    if ( &sessions != sessions.next )
    {
      ses = v12->ses;
      if ( ses == sessions.next )
        goto LABEL_45;
      while ( 1 )
      {
        v16 = (list_head_elinks *)v16->next;
        if ( &sessions == v16 )
          break;
        if ( ses == (session *)v16 )
          goto LABEL_45;
      }
    }
    v12->ses = 0;
LABEL_45:
    inited = init_session(v12->ses, term, v12->uri, 0);
    if ( inited )
    {
      if ( v12->uri && v12->task )
      {
        pb = inited;
        abort_loading(inited, 1);
        pb->reloadlevel = v12->cache_mode;
        set_session_referrer(pb, v12->referrer);
        ses_goto(pb, v12->uri, 0, 0, v12->cache_mode, v12->task, 0);
      }
      done_session_info(v12);
      return 1;
    }
    done_session_info(v12);
  }
LABEL_28:
  base_session = 0;
LABEL_55:
  if ( length > 0 )
  {
    magic = length;
LABEL_5:
    str = info->data;
    p_windows = &term->windows;
    while ( 1 )
    {
      v26 = magic;
      v4 = magic;
      v5 = memchr(str, 0, magic);
      if ( v5 )
      {
        v4 = v5 - str;
        v26 = v5 - str;
      }
      hooked_uri = 0;
      v7 = memacpy(str, v4);
      if ( v7 )
      {
        p = v7;
        hooked_uri = get_hooked_uri(v7, base_session, term->cwd);
        mem_free(p);
      }
      magic += ~v4;
      if ( remote[0] )
        break;
      v8 = hooked_uri;
      v9 = (list_head_elinks *)term->windows.next;
      if ( !hooked_uri )
      {
        pa = (list_head_elinks *)term->windows.next;
        uri = get_uri("about:blank", (uri_component)0);
        v9 = pa;
        v8 = uri;
      }
      v10 = init_session(base_session, term, v8, v9 != p_windows);
      if ( v10 )
      {
        if ( !hooked_uri )
        {
          if ( assert_failed )
          {
            assert_failed = 0;
            v15 = -100003;
          }
          else
          {
            assert_failed = 0;
            v15 = -100009;
          }
          print_error_dialog(v10, (connection_state)(unsigned int)v15, 0, PRI_MAIN);
        }
      }
      else
      {
        magic = 0;
      }
      if ( v8 )
      {
        hooked_uri = v8;
LABEL_8:
        done_uri(hooked_uri);
      }
LABEL_9:
      if ( magic <= 0 )
      {
        if ( !remote[0] )
          return p_windows != term->windows.next;
        return 0;
      }
      str += v26 + 1;
    }
    if ( !hooked_uri )
      goto LABEL_9;
    init_remote_session(base_session, remote, hooked_uri);
    goto LABEL_8;
  }
  if ( !remote[0] )
    return init_session(base_session, term, 0, 0) != 0;
  init_remote_session(base_session, remote, 0);
  return 0;
}

//----- (080D89A0) --------------------------------------------------------
void __cdecl load_frames(session *ses, document_view *doc_view)
{
  document *document; // eax
  frameset_desc *frame_desc; // edx
  location *current; // esi
  connection_priority v5; // ebx
  uri *v6; // ecx
  session *i; // [esp+1Ch] [ebp-1Ch]

  document = doc_view->document;
  if ( document )
  {
    frame_desc = document->frame_desc;
    if ( frame_desc )
    {
      request_frameset(ses, frame_desc, 0);
      for ( i = (session *)ses->scrn_frames.next; i != (session *)&ses->scrn_frames; i = i->next )
      {
        current = i->history.current;
        if ( current && current[1].download.pri > PRI_MAIN )
        {
          v5 = PRI_MAIN;
          do
          {
            v6 = (uri *)*((_DWORD *)&current[1].vs.doc_view->next + v5);
            if ( v6 )
              request_additional_file(ses, (unsigned __int8 *)&delete, v6, 2);
            ++v5;
          }
          while ( v5 < current[1].download.pri );
        }
      }
    }
  }
}

//----- (080D8A40) --------------------------------------------------------
void __cdecl tabwin_func(window *tab, term_event *ev)
{
  session *data; // ebx
  window *v3; // esi
  list_head_elinks *next; // edx
  list_head_elinks *p_scrn_frames; // esi
  document_view *v6; // edi
  list_head_elinks *v7; // eax
  list_head_elinks *v8; // ecx
  list_head_elinks *i; // ecx
  list_head_elinks *v10; // edi
  list_head_elinks *j; // ebx
  type_query *k; // eax
  window *v13; // edi
  window *tab_by_number; // eax
  session *v15; // [esp+1Ch] [ebp-1Ch]

  data = (session *)tab->data;
  switch ( ev->ev )
  {
    case EVENT_INIT:
    case EVENT_RESIZE:
      *((_BYTE *)tab + 40) |= 1u;
      goto LABEL_3;
    case EVENT_KBD:
    case EVENT_MOUSE:
      if ( data )
      {
        if ( !assert_failed )
        {
          v13 = data->tab;
          tab_by_number = get_tab_by_number(v13->term, v13->term->current_tab);
          assert_failed = v13 != tab_by_number;
          if ( v13 != tab_by_number )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/session.c";
            errline = 1308;
            elinks_internal("assertion ses->tab == get_current_tab(ses->tab->term) failed!");
          }
        }
        send_event(data, ev);
      }
      break;
    case EVENT_REDRAW:
LABEL_3:
      if ( data )
      {
        v3 = data->tab;
        if ( v3 == get_tab_by_number(v3->term, v3->term->current_tab) )
        {
          draw_formatted(data, *((_BYTE *)tab + 40) & 1);
          if ( (*((_BYTE *)tab + 40) & 1) != 0 )
          {
            load_frames(data, data->doc_view);
            process_file_requests(data);
            *((_BYTE *)tab + 40) &= ~1u;
          }
          print_screen_status(data);
        }
      }
      break;
    case EVENT_ABORT:
      if ( data )
      {
        if ( assert_failed )
        {
          assert_failed = 0;
        }
        else
        {
          assert_failed = 0;
          destroy_downloads(data);
          abort_loading(data, 0);
          free_files(data);
          if ( data->doc_view )
          {
            detach_formatted(data->doc_view);
            mem_free(data->doc_view);
          }
          next = (list_head_elinks *)data->scrn_frames.next;
          p_scrn_frames = &data->scrn_frames;
          v6 = (document_view *)next;
          if ( next != &data->scrn_frames )
          {
            do
            {
              detach_formatted(v6);
              v6 = v6->next;
            }
            while ( v6 != (document_view *)p_scrn_frames );
            next = (list_head_elinks *)data->scrn_frames.next;
          }
          v7 = next;
          if ( p_scrn_frames != next )
          {
            v8 = next;
            do
              v8 = (list_head_elinks *)v8->next;
            while ( p_scrn_frames != v8 );
          }
          for ( i = (list_head_elinks *)data->scrn_frames.prev; i != p_scrn_frames; i = (list_head_elinks *)i->prev )
            ;
          v10 = (list_head_elinks *)next->next;
          if ( next != p_scrn_frames )
          {
            v15 = data;
            for ( j = (list_head_elinks *)next->next; ; j = v10 )
            {
              v10->prev = v7->prev;
              *(_DWORD *)v7->prev = v7->next;
              mem_free(v7);
              v10 = (list_head_elinks *)v10->next;
              if ( j == p_scrn_frames )
                break;
              v7 = j;
            }
            data = v15;
          }
          destroy_history(&data->history);
          set_session_referrer(data, 0);
          if ( data->loading_uri )
            done_uri(data->loading_uri);
          kill_timer(&data->display_timer);
          for ( k = (type_query *)data->type_queries.next;
                k != (type_query *)&data->type_queries;
                k = (type_query *)data->type_queries.next )
          {
            done_type_query(k);
          }
          if ( data->download_uri )
            done_uri(data->download_uri);
          if ( data->search_word )
            mem_free(data->search_word);
          if ( data->last_search_word )
            mem_free(data->last_search_word);
          if ( data->status.last_title )
            mem_free(data->status.last_title);
          data->next->prev = data->prev;
          data->prev->next = data->next;
        }
      }
      if ( sessions.next != &sessions )
        update_status();
      break;
    default:
      return;
  }
}

//----- (080D8D10) --------------------------------------------------------
void __cdecl display_timer(session *ses)
{
  milliseconds_T v1; // eax
  int v2; // eax
  document *document; // esi
  frameset_desc *frame_desc; // edx
  location *current; // esi
  connection_priority v6; // ebx
  uri *v7; // ecx
  int v8; // ebx
  uri *v9; // ecx
  session *i; // [esp+1Ch] [ebp-3Ch]
  timeval_T duration; // [esp+28h] [ebp-30h] BYREF
  timeval_T stop; // [esp+30h] [ebp-28h] BYREF
  timeval_T start; // [esp+38h] [ebp-20h] BYREF

  timeval_now(&start);
  draw_formatted(ses, 3);
  timeval_now(&stop);
  timeval_sub(&duration, &start, &stop);
  v1 = timeval_to_milliseconds(&duration);
  v2 = mult_ms(v1, 20);
  if ( v2 <= 199 )
    v2 = 200;
  install_timer(&ses->display_timer, v2, (void (*)(void *))display_timer, ses);
  document = ses->doc_view->document;
  if ( document )
  {
    frame_desc = document->frame_desc;
    if ( !frame_desc )
      goto LABEL_14;
    request_frameset(ses, frame_desc, 0);
    for ( i = (session *)ses->scrn_frames.next; i != (session *)&ses->scrn_frames; i = i->next )
    {
      current = i->history.current;
      if ( current && current[1].download.pri > PRI_MAIN )
      {
        v6 = PRI_MAIN;
        do
        {
          v7 = (uri *)*((_DWORD *)&current[1].vs.doc_view->next + v6);
          if ( v7 )
            request_additional_file(ses, (unsigned __int8 *)&delete, v7, 2);
          ++v6;
        }
        while ( v6 < current[1].download.pri );
      }
    }
    document = ses->doc_view->document;
    if ( document )
    {
LABEL_14:
      if ( document->css_imports.size > 0 )
      {
        v8 = 0;
        do
        {
          v9 = document->css_imports.uris[v8];
          if ( v9 )
            request_additional_file(ses, (unsigned __int8 *)&delete, v9, 2);
          ++v8;
        }
        while ( v8 < document->css_imports.size );
      }
    }
  }
  process_file_requests(ses);
}

//----- (080D8E80) --------------------------------------------------------
void __cdecl doc_loading_callback(download *download, session *ses)
{
  connection_basic_state basic; // eax
  unsigned __int8 *title; // ebx
  connection *conn; // eax
  unsigned __int8 **p_string; // esi
  time_t v6; // eax
  cache_entry *cached; // ebx
  document *document; // ebx
  frameset_desc *frame_desc; // edx
  location *current; // esi
  connection_priority v11; // ebx
  uri *v12; // ecx
  int v13; // esi
  uri *v14; // ecx
  cache_entry *v15; // eax
  int event_id; // eax
  int submit; // [esp+20h] [ebp-28h]
  session *i; // [esp+2Ch] [ebp-1Ch]

  basic = download->state.basic;
  if ( basic < S_WAIT )
  {
    cached = download->cached;
    if ( cached && (*((_BYTE *)cached + 92) & 2) == 0 )
    {
      ++cached->object.refcount;
      if ( get_cache_fragment(cached) && cached->frag.next == cached->frag.prev )
      {
        event_id = pre_format_html_event_9516;
        if ( pre_format_html_event_9516 == -1 )
        {
          event_id = get_event_id("pre-format-html");
          pre_format_html_event_9516 = event_id;
        }
        trigger_event(event_id, ses, cached);
        *((_BYTE *)cached + 92) |= 2u;
      }
      --cached->object.refcount;
    }
    kill_timer(&ses->display_timer);
    draw_formatted(ses, 1);
    if ( get_opt_(cmdline_options, (unsigned __int8 *)&byte_8127F34)->number )
    {
      document = ses->doc_view->document;
      submit = 0;
      if ( document->forms.next != &document->forms )
      {
        get_opt_(cmdline_options, (unsigned __int8 *)&byte_8127F34)->number = 0;
        document = ses->doc_view->document;
        submit = 1;
      }
    }
    else
    {
      document = ses->doc_view->document;
      submit = 0;
    }
    if ( document )
    {
      frame_desc = document->frame_desc;
      if ( !frame_desc )
        goto LABEL_29;
      request_frameset(ses, frame_desc, 0);
      for ( i = (session *)ses->scrn_frames.next; i != (session *)&ses->scrn_frames; i = i->next )
      {
        current = i->history.current;
        if ( current && current[1].download.pri > PRI_MAIN )
        {
          v11 = PRI_MAIN;
          do
          {
            v12 = (uri *)*((_DWORD *)&current[1].vs.doc_view->next + v11);
            if ( v12 )
              request_additional_file(ses, (unsigned __int8 *)&delete, v12, 2);
            ++v11;
          }
          while ( v11 < current[1].download.pri );
        }
      }
      document = ses->doc_view->document;
      if ( document )
      {
LABEL_29:
        if ( document->css_imports.size > 0 )
        {
          v13 = 0;
          do
          {
            v14 = document->css_imports.uris[v13];
            if ( v14 )
              request_additional_file(ses, (unsigned __int8 *)&delete, v14, 2);
            ++v13;
          }
          while ( v13 < document->css_imports.size );
        }
      }
    }
    process_file_requests(ses);
    start_document_refreshes(ses);
    if ( download->state.basic != S_OK )
      print_error_dialog(ses, download->state, ses->doc_view->document->uri, download->pri);
  }
  else if ( basic <= S_PROC || ses->display_timer )
  {
    submit = 0;
  }
  else
  {
    display_timer(ses);
    submit = 0;
  }
  check_questions_queue(ses);
  print_screen_status(ses);
  if ( download->pri != PRI_CSS )
  {
    title = ses->doc_view->document->title;
    conn = download->conn;
    if ( conn )
    {
      p_string = &conn->proxied_uri->string;
    }
    else
    {
      v15 = download->cached;
      if ( !v15 )
        goto LABEL_9;
      p_string = &v15->uri->string;
    }
    if ( p_string )
    {
      v6 = time(0);
      add_global_history_item(*p_string, title, v6);
    }
  }
LABEL_9:
  if ( submit )
    auto_submit_form(ses);
}

//----- (080D9170) --------------------------------------------------------
void __cdecl file_loading_callback(download *download, file_to_load *ftl)
{
  cache_entry *cached; // eax
  cache_entry *v3; // edx
  session *ses; // esi
  uri *loading_uri; // edx
  unsigned __int8 *frame; // ecx
  uri *v7; // [esp+18h] [ebp-20h]
  unsigned __int8 *v8; // [esp+1Ch] [ebp-1Ch]

  cached = ftl->download.cached;
  if ( !cached )
  {
LABEL_6:
    cached = ftl->cached;
    goto LABEL_7;
  }
  v3 = ftl->cached;
  if ( cached != v3 )
  {
    if ( v3 )
    {
      --v3->object.refcount;
      cached = ftl->download.cached;
    }
    ftl->cached = cached;
    ++cached->object.refcount;
    goto LABEL_6;
  }
LABEL_7:
  if ( cached && (*((_BYTE *)cached + 92) & 4) == 0 && download->pri != PRI_CSS )
  {
    ses = ftl->ses;
    loading_uri = ses->loading_uri;
    ses->loading_uri = ftl->uri;
    frame = ses->task.target.frame;
    ses->task.target.frame = ftl->target_frame;
    v7 = loading_uri;
    v8 = frame;
    setup_download_handler(ses, &ftl->download, ftl->cached, 1);
    ses->loading_uri = v7;
    ses->task.target.frame = v8;
  }
  doc_loading_callback(download, ftl->ses);
}

//----- (080D9220) --------------------------------------------------------
void __usercall free_task(session *ses@<eax>)
{
  task_type type; // ecx

  if ( assert_failed
    || (type = ses->task.type, assert_failed = type == TASK_NONE, type == TASK_NONE)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c",
        errline = 44,
        elinks_internal("assertion ses->task.type failed: Session has no task"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    if ( ses->loading_uri )
    {
      done_uri(ses->loading_uri);
      ses->loading_uri = 0;
    }
    ses->task.type = TASK_NONE;
  }
}

//----- (080D92B0) --------------------------------------------------------
uri *__cdecl get_hooked_uri(unsigned __int8 *uristring, session *ses, unsigned __int8 *cwd)
{
  unsigned __int8 *v3; // eax
  int event_id; // eax
  unsigned __int8 *v6; // edx
  uri *translated_uri; // eax
  uri *v8; // [esp+1Ch] [ebp-Ch]

  v3 = stracpy(uristring);
  if ( !v3 )
    return 0;
  uristring = v3;
  event_id = goto_url_event_id_9115;
  if ( goto_url_event_id_9115 == -1 )
  {
    event_id = get_event_id("goto-url");
    goto_url_event_id_9115 = event_id;
  }
  trigger_event(event_id, &uristring, ses);
  v6 = uristring;
  if ( !uristring )
    return 0;
  translated_uri = 0;
  if ( *uristring )
  {
    translated_uri = get_translated_uri(uristring, cwd);
    v6 = uristring;
  }
  v8 = translated_uri;
  mem_free(v6);
  return v8;
}

//----- (080D9350) --------------------------------------------------------
view_state *__cdecl ses_forward(session *ses, int loaded_in_frame)
{
  location *v2; // edi
  unsigned __int8 *frame; // eax
  view_state *v4; // edx
  location *current; // edx
  frame *v7; // eax
  location *v8; // eax
  uri *loading_uri; // ecx
  document_view *doc_view; // ecx
  frame *v11; // [esp+14h] [ebp-24h]
  frame *v12; // [esp+14h] [ebp-24h]
  view_state *v13; // [esp+18h] [ebp-20h]
  view_state *p_vs; // [esp+18h] [ebp-20h]
  view_state *v15; // [esp+18h] [ebp-20h]
  ses_history *history; // [esp+1Ch] [ebp-1Ch]

  if ( !loaded_in_frame )
  {
    free_files(ses);
    if ( ses->search_word )
      mem_free(ses->search_word);
    ses->search_word = 0;
  }
  v2 = 0;
  history = &ses->history;
  if ( !loaded_in_frame )
    goto LABEL_16;
LABEL_3:
  frame = ses->task.target.frame;
  if ( frame )
  {
    while ( *frame )
    {
      if ( assert_failed
        || (current = ses->history.current, assert_failed = current == 0, !current)
        && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c",
            errline = 311,
            elinks_internal("assertion have_location(ses) failed: no location yet"),
            assert_failed) )
      {
        assert_failed = 0;
        return 0;
      }
      if ( !loaded_in_frame )
      {
        copy_location(v2, ses->history.current);
        add_to_history(history, v2);
      }
      v7 = ses_find_frame(ses, ses->task.target.frame);
      if ( v7 )
      {
        if ( loaded_in_frame )
        {
          v11 = v7;
          p_vs = &v7->vs;
          done_uri(v7->vs.uri);
          loading_uri = ses->loading_uri;
          ++loading_uri->object.refcount;
          v11->vs.uri = loading_uri;
          doc_view = v11->vs.doc_view;
          v4 = p_vs;
          if ( doc_view )
          {
            doc_view->vs = 0;
            v11->vs.doc_view = 0;
          }
        }
        else
        {
          v12 = v7;
          v15 = &v7->vs;
          destroy_vs(&v7->vs, 1);
          init_vs(v15, ses->loading_uri, v12->vs.plain);
          v4 = v15;
        }
        goto LABEL_21;
      }
      if ( !loaded_in_frame )
      {
        del_from_history(history, v2);
        destroy_location(v2);
      }
      ses->task.target.frame = 0;
      if ( loaded_in_frame )
        goto LABEL_3;
LABEL_16:
      v8 = (location *)mem_calloc(1u, 0x70u);
      v2 = v8;
      if ( !v8 )
        return 0;
      v8->download = ses->loading;
      frame = ses->task.target.frame;
      if ( !frame )
        break;
    }
  }
  if ( assert_failed
    || (assert_failed = v2 == 0, !v2)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c",
        errline = 349,
        elinks_internal("assertion loc failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v2->frames.prev = &v2->frames;
    v2->frames.next = &v2->frames;
    init_vs(&v2->vs, ses->loading_uri, v2->vs.plain);
    add_to_history(history, v2);
    v4 = &v2->vs;
LABEL_21:
    *((_BYTE *)&ses->status + 52) &= ~1u;
    if ( ses->task.type == TASK_FORWARD )
    {
      v13 = v4;
      clean_unhistory(history);
      return v13;
    }
    else
    {
      return v4;
    }
  }
}

//----- (080D9670) --------------------------------------------------------
void __cdecl post_no(void *task_)
{
  reload(*(session **)task_, CACHE_MODE_NORMAL);
  done_uri(*((uri **)task_ + 1));
}

//----- (080D96A0) --------------------------------------------------------
void __cdecl ses_load(
        session *ses,
        uri *uri,
        unsigned __int8 *target_frame,
        location *target_location,
        cache_mode cache_mode,
        task_type task_type)
{
  ses->loading.callback = (download_callback_T *)loading_callback;
  ses->loading.data = ses;
  ses->loading_uri = uri;
  ses->task.type = task_type;
  ses->task.target.frame = target_frame;
  ses->task.target.location = target_location;
  load_uri(uri, ses->referrer, &ses->loading, PRI_MAIN, cache_mode, -1LL);
}

//----- (080D9710) --------------------------------------------------------
void __cdecl ses_goto(
        session *ses,
        uri *uri,
        unsigned __int8 *target_frame,
        location *target_location,
        cache_mode cache_mode,
        task_type task_type,
        int redir)
{
  document_view *doc_view; // eax
  document *document; // eax
  document_refresh *refresh; // eax
  uri *loading_uri; // ebx
  cache_entry *v11; // eax
  int v12; // esi
  int v13; // edi
  _DWORD *v14; // eax
  void *v15; // ebx
  char *v16; // esi
  unsigned __int8 *uri_string; // edi
  unsigned __int8 *v18; // esi
  memory_list *v19; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 v21; // dl
  const unsigned __int8 *i; // esi
  const unsigned __int8 *v23; // ebx
  const unsigned __int16 **v24; // eax
  unsigned __int8 v25; // dl
  const unsigned __int16 *v26; // edi
  int v27; // eax
  const unsigned __int8 *v28; // ecx
  int v29; // edx
  const unsigned __int8 *v30; // edi
  char v31; // bl
  unsigned __int8 v32; // [esp+40h] [ebp-48h]
  unsigned __int8 *p; // [esp+44h] [ebp-44h]
  int confirm_submit; // [esp+4Ch] [ebp-3Ch]
  const unsigned __int16 **v35; // [esp+50h] [ebp-38h]
  unsigned __int8 *host; // [esp+60h] [ebp-28h]
  unsigned __int8 *user; // [esp+64h] [ebp-24h]

  if ( (*((_BYTE *)uri + 54) & 2) == 0
    || (confirm_submit = 1, !get_opt_(config_options, "document.browse.forms.confirm_submit")->number) )
  {
    confirm_submit = 0;
  }
  doc_view = ses->doc_view;
  if ( doc_view )
  {
    document = doc_view->document;
    if ( document )
    {
      refresh = document->refresh;
      if ( refresh )
        kill_document_refresh(refresh);
    }
  }
  if ( !assert_failed )
  {
    loading_uri = ses->loading_uri;
    assert_failed = loading_uri != 0;
    if ( loading_uri )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 182;
      elinks_internal("assertion !ses->loading_uri failed: Buggy URI reference counting");
    }
  }
  if ( !redir )
    ses->redirect_cnt = 0;
  if ( uri->user && *((_WORD *)uri + 21) && get_opt_(config_options, "document.browse.links.warn_malicious")->number )
  {
    if ( !assert_failed )
    {
      if ( uri->user && *((_WORD *)uri + 21) )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
        errline = 126;
        elinks_internal("assertion uri->user && uri->userlen failed!");
      }
    }
    v20 = memacpy(uri->user, *((unsigned __int16 *)uri + 21));
    p = v20;
    if ( v20 )
    {
      decode_uri_for_display(v20);
      v21 = *p;
      for ( i = p; ; i = v23 )
      {
        if ( !v21 )
        {
          mem_free(p);
          goto LABEL_14;
        }
        v32 = v21;
        v23 = i;
        v24 = __ctype_b_loc();
        v25 = v32;
        v35 = v24;
        v26 = *v24;
        v27 = 0;
        do
        {
          if ( (v26[v25] & 8) == 0 && v25 != 46 )
            break;
          v25 = i[++v27];
          v23 = &i[v27];
        }
        while ( v25 );
        if ( v27 && i[v27 - 1] == 46 )
        {
          v28 = &i[v27];
          v29 = 0;
          v30 = v23;
          do
          {
            if ( v27 <= ++v29 )
            {
              v23 = v30;
              v27 -= v29;
              goto LABEL_47;
            }
            v31 = *(v28 - 2);
            --v28;
          }
          while ( v31 == 46 );
          v27 -= v29;
          v23 = v30;
        }
LABEL_47:
        if ( end_with_known_tld(i, v27) != -1 )
          break;
        v21 = *v23;
        if ( *v23 )
        {
          while ( ((*v35)[v21] & 8) == 0 || v21 == 46 )
          {
            v21 = *++v23;
            if ( !*v23 )
              goto LABEL_52;
          }
        }
        else
        {
LABEL_52:
          v21 = 0;
        }
      }
      v12 = 1;
      v13 = 0;
      mem_free(p);
      goto LABEL_22;
    }
  }
LABEL_14:
  if ( (*((_BYTE *)uri + 54) & 2) != 0 )
  {
    if ( ses->referrer )
    {
      v11 = find_in_cache(ses->referrer);
      if ( v11 )
      {
        v12 = 0;
        v13 = 1;
        if ( (*((_BYTE *)v11 + 92) & 8) != 0 )
          goto LABEL_22;
      }
    }
    if ( get_validated_cache_entry(uri, cache_mode) )
    {
LABEL_19:
      ++uri->object.refcount;
      ses_load(ses, uri, target_frame, target_location, cache_mode, task_type);
      return;
    }
  }
  if ( !confirm_submit )
    goto LABEL_19;
  v12 = 0;
  v13 = 0;
LABEL_22:
  v14 = mem_alloc(0x18u);
  v15 = v14;
  if ( v14 )
  {
    *v14 = ses;
    ++uri->object.refcount;
    v14[1] = uri;
    v14[2] = cache_mode;
    v14[3] = task_type;
    v14[4] = target_frame;
    v14[5] = target_location;
    if ( v12 )
    {
      host = memacpy(uri->host, *((unsigned __int16 *)uri + 23));
      user = memacpy(uri->user, *((unsigned __int16 *)uri + 21));
      uri_string = get_uri_string(uri, URI_PUBLIC);
      v18 = msg_text(
              ses->tab->term,
              "The URL you are about to follow might be maliciously crafted in order to confuse you. By following the URL"
              " you will be connecting to host \"%s\" as user \"%s\".\n"
              "\n"
              "Do you want to go to URL %s?",
              (const char *)host,
              (const char *)user,
              (const char *)uri_string);
      if ( host )
        mem_free(host);
      if ( user )
        mem_free(user);
    }
    else
    {
      v16 = "Do you want to follow the redirect and post form data to URL %s?";
      if ( !redir )
      {
        v16 = "The form data you are about to post might be incomplete.\nDo you want to post to URL %s?";
        if ( !v13 )
        {
          v16 = "Do you want to post form data to URL %s?";
          if ( task_type != TASK_FORWARD )
            v16 = "Do you want to repost form data to URL %s?";
        }
      }
      uri_string = get_uri_string(uri, URI_PUBLIC);
      v18 = msg_text(ses->tab->term, (unsigned __int8 *)v16, uri_string);
    }
    if ( uri_string )
      mem_free(uri_string);
    v19 = getml(v15, 0);
    msg_box(
      ses->tab->term,
      v19,
      MSGBOX_FREE_TEXT,
      "Warning",
      ALIGN_CENTER,
      v18,
      v15,
      2,
      "~Yes",
      post_yes,
      1,
      "~No",
      post_no,
      2);
  }
}

//----- (080D9C40) --------------------------------------------------------
void __usercall do_follow_url(
        session *ses@<eax>,
        uri *uri@<edx>,
        unsigned __int8 *target@<ecx>,
        task_type task,
        cache_mode cache_mode,
        int do_referrer)
{
  session *v6; // ebx
  protocol_external_handler_T *protocol_external_handler; // eax
  uri *v8; // edx
  int v9; // eax
  document_view *v10; // eax
  document *document; // eax
  option_value *opt; // eax
  int number; // esi
  session *inited; // eax
  int v15; // eax
  option_value *v16; // eax
  int v17; // eax
  option_value *v18; // eax
  option_value *v19; // eax
  uri *bb; // [esp+2Ch] [ebp-2Ch]
  uri *ba; // [esp+2Ch] [ebp-2Ch]
  uri *bc; // [esp+2Ch] [ebp-2Ch]
  uri *bd; // [esp+2Ch] [ebp-2Ch]
  uri *referrer; // [esp+30h] [ebp-28h]

  v6 = ses;
  if ( uri )
  {
    protocol_external_handler = get_protocol_external_handler(ses->tab->term, uri);
    v8 = uri;
    if ( protocol_external_handler )
    {
      protocol_external_handler(v6, uri);
      return;
    }
    if ( do_referrer && (v10 = current_frame(v6), v8 = uri, v10) && (document = v10->document) != 0 )
      referrer = document->uri;
    else
      referrer = 0;
    if ( !target || strcmp((const char *)target, "_blank") )
      goto LABEL_8;
    ba = v8;
    opt = get_opt_(config_options, "document.browse.links.target_blank");
    v8 = ba;
    number = opt->number;
    if ( opt->number == 3 )
    {
      v16 = get_opt_(cmdline_options, "anonymous");
      v8 = ba;
      if ( !v16->number )
      {
        v17 = can_open_in_new(v6->tab->term);
        v8 = ba;
        if ( v17 )
        {
          v18 = get_opt_(cmdline_options, "no-connect");
          v8 = ba;
          if ( !v18->number )
          {
            v19 = get_opt_(cmdline_options, "no-home");
            v8 = ba;
            if ( !v19->number )
            {
              open_uri_in_new_window(v6, ba, referrer, v6->tab->term->environment, cache_mode, task);
              return;
            }
          }
        }
      }
    }
    else if ( number <= 0 )
    {
LABEL_8:
      v6->reloadlevel = cache_mode;
      if ( v6->task.type != task || (bd = v8, v15 = compare_uri(v6->loading_uri, v8, (uri_component)0), v8 = bd, !v15) )
      {
        bb = v8;
        abort_loading(v6, 0);
        set_session_referrer(v6, referrer);
        ses_goto(v6, bb, target, 0, cache_mode, task, 0);
      }
      return;
    }
    bc = v8;
    inited = init_session(v6, v6->tab->term, v8, number == 2);
    v8 = bc;
    if ( inited )
      v6 = inited;
    goto LABEL_8;
  }
  if ( assert_failed )
  {
    assert_failed = 0;
    v9 = -100003;
  }
  else
  {
    assert_failed = 0;
    v9 = -100009;
  }
  print_error_dialog(v6, (connection_state)(unsigned int)v9, 0, PRI_CANCEL);
}

//----- (080D9F00) --------------------------------------------------------
void __usercall follow_url(
        session *ses@<eax>,
        uri *uri@<edx>,
        unsigned __int8 *target@<ecx>,
        task_type task,
        cache_mode cache_mode,
        int referrer)
{
  int event_id; // eax
  uri *translated_uri; // esi
  unsigned __int8 *uristring; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( !uri )
  {
    uristring = 0;
    goto LABEL_10;
  }
  uristring = get_uri_string(uri, (uri_component)-31809);
  if ( !uristring )
  {
LABEL_10:
    do_follow_url(ses, uri, target, task, cache_mode, referrer);
    return;
  }
  event_id = follow_url_event_id_9029;
  if ( follow_url_event_id_9029 == -1 )
  {
    event_id = get_event_id("follow-url");
    follow_url_event_id_9029 = event_id;
  }
  trigger_event(event_id, &uristring, ses);
  if ( uristring )
  {
    if ( *uristring )
    {
      translated_uri = get_translated_uri(uristring, ses->tab->term->cwd);
      mem_free(uristring);
      do_follow_url(ses, translated_uri, target, task, cache_mode, referrer);
      if ( translated_uri )
        done_uri(translated_uri);
    }
    else
    {
      mem_free(uristring);
    }
  }
}

//----- (080DA010) --------------------------------------------------------
void __cdecl goto_imgmap(session *ses, uri *uri, unsigned __int8 *target)
{
  follow_url(ses, uri, target, TASK_IMGMAP, CACHE_MODE_NORMAL, 1);
}

//----- (080DA040) --------------------------------------------------------
void __cdecl goto_uri_frame(session *ses, uri *uri, unsigned __int8 *target, cache_mode cache_mode)
{
  follow_url(ses, uri, target, TASK_FORWARD, cache_mode, 1);
}

//----- (080DA070) --------------------------------------------------------
void __cdecl map_selected(terminal *term, void *ld_, void *ses_)
{
  uri *uri; // edi

  uri = get_uri(*(unsigned __int8 **)ld_, (uri_component)0);
  goto_uri_frame((session *)ses_, uri, *((unsigned __int8 **)ld_ + 1), CACHE_MODE_NORMAL);
  if ( uri )
    done_uri(uri);
}

//----- (080DA0E0) --------------------------------------------------------
void __cdecl delayed_goto_uri_frame(void *data)
{
  frame *frame; // eax

  if ( !assert_failed )
  {
    assert_failed = data == 0;
    if ( !data )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 680;
      elinks_internal("assertion deo failed!");
    }
  }
  frame = ses_find_frame(*(session **)data, *((unsigned __int8 **)data + 2));
  if ( frame )
    goto_uri_frame(*(session **)data, *((uri **)data + 1), frame->name, CACHE_MODE_NORMAL);
  else
    goto_uri_frame(*(session **)data, *((uri **)data + 1), 0, CACHE_MODE_NORMAL);
  done_uri(*((uri **)data + 1));
  mem_free(*((void **)data + 2));
  mem_free(data);
}

//----- (080DA1A0) --------------------------------------------------------
void __cdecl goto_uri(session *ses, uri *uri)
{
  follow_url(ses, uri, 0, TASK_FORWARD, CACHE_MODE_NORMAL, 0);
}

//----- (080DA1D0) --------------------------------------------------------
void __cdecl goto_url_with_hook(session *ses, unsigned __int8 *url)
{
  uri *hooked_uri; // eax
  uri *v3; // esi

  if ( *url )
  {
    hooked_uri = get_hooked_uri(url, ses, ses->tab->term->cwd);
    v3 = hooked_uri;
    if ( hooked_uri )
    {
      goto_uri(ses, hooked_uri);
      done_uri(v3);
    }
  }
}

//----- (080DA230) --------------------------------------------------------
int __cdecl goto_url_home(session *ses)
{
  unsigned __int8 *number; // eax

  number = (unsigned __int8 *)get_opt_(config_options, "ui.sessions.homepage")->number;
  if ( !*number )
    number = (unsigned __int8 *)getenv("WWW_HOME");
  if ( !number || !*number )
    return 0;
  goto_url_with_hook(ses, number);
  return 1;
}

//----- (080DA290) --------------------------------------------------------
void __cdecl goto_url(session *ses, unsigned __int8 *url)
{
  uri *uri; // esi

  uri = get_uri(url, (uri_component)0);
  goto_uri(ses, uri);
  if ( uri )
    done_uri(uri);
}

//----- (080DA2F0) --------------------------------------------------------
void __cdecl loading_callback(download *download, session *ses)
{
  task_type type; // edx
  uri *loading_uri; // edi
  uri *v4; // edx
  download *v5; // eax
  cache_entry *cached; // esi
  int redirect_cnt; // eax
  task_type v8; // eax
  download *p_download; // eax
  location *v10; // edx
  int v11; // esi
  int basic; // edx
  connection *conn; // ecx
  uri *uri; // edx
  task_type v15; // edi
  location *current; // eax
  protocol_external_handler_T *protocol_external_handler; // eax
  location *v18; // eax
  int syserr; // ecx
  cache_entry *v20; // edi
  document_view *v21; // eax
  fragment *cache_fragment; // esi
  int terminal_codepage; // eax
  int v24; // eax
  uri *v25; // eax
  unsigned __int8 *frame; // [esp+8h] [ebp-60h]
  location *location; // [esp+Ch] [ebp-5Ch]
  cache_mode reloadlevel; // [esp+10h] [ebp-58h]
  task_type v29; // [esp+14h] [ebp-54h]
  int hdef; // [esp+34h] [ebp-34h]
  uri *redirect; // [esp+38h] [ebp-30h]
  document_view *v32; // [esp+38h] [ebp-30h]
  int def; // [esp+3Ch] [ebp-2Ch]
  menu_item *menu; // [esp+48h] [ebp-20h] BYREF
  memory_list *ml; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( assert_failed
    || (type = ses->task.type, assert_failed = type == TASK_NONE, type == TASK_NONE)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c",
        errline = 529,
        elinks_internal("assertion ses->task.type failed: loading_callback: no ses->task"),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  if ( download )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 466;
    elinks_internal("assertion download_p && *download_p failed!");
    if ( assert_failed )
    {
LABEL_46:
      assert_failed = 0;
      v5 = download;
      v11 = 0;
      goto LABEL_20;
    }
  }
  loading_uri = ses->loading_uri;
  assert_failed = loading_uri == 0;
  if ( !loading_uri )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
    errline = 467;
    elinks_internal("assertion ses->loading_uri != NULL failed: no ses->loading_uri");
    if ( assert_failed )
      goto LABEL_46;
  }
  v4 = ses->loading_uri;
  if ( v4->protocol == 18 )
  {
    v5 = download;
    v11 = 0;
    goto LABEL_20;
  }
  if ( ses->task.type == TASK_IMGMAP )
  {
    v5 = download;
    if ( download->state.basic >= S_WAIT )
      goto LABEL_33;
  }
  else
  {
    v5 = download;
  }
  cached = v5->cached;
  if ( !cached )
  {
LABEL_33:
    v11 = 0;
    goto LABEL_20;
  }
  if ( cached->redirect )
  {
    redirect_cnt = ses->redirect_cnt;
    ses->redirect_cnt = redirect_cnt + 1;
    if ( redirect_cnt <= 9 )
    {
      v15 = ses->task.type;
      if ( v15 != TASK_HISTORY || ses->history.current )
      {
        if ( !assert_failed )
        {
          v24 = compare_uri(cached->uri, v4, URI_BASE);
          assert_failed = v24 == 0;
          if ( !v24 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
            errline = 415;
            elinks_internal("assertion compare_uri(cached->uri, ses->loading_uri, URI_BASE) failed: Redirecting using bad base URI");
          }
        }
        if ( cached->redirect->protocol == 18 )
        {
          v11 = 0;
          goto LABEL_57;
        }
        abort_loading(ses, 0);
        current = ses->history.current;
        if ( current )
          download = &current->download;
        else
          download = 0;
        set_session_referrer(ses, cached->uri);
        if ( v15 != TASK_IMGMAP )
        {
          if ( (unsigned int)v15 > TASK_IMGMAP )
          {
            if ( v15 == TASK_RELOAD )
            {
              v29 = TASK_RELOAD;
              location = 0;
              reloadlevel = ses->reloadlevel;
            }
            else
            {
              if ( v15 != TASK_HISTORY )
                goto LABEL_12;
              v29 = TASK_RELOAD;
              reloadlevel = CACHE_MODE_NORMAL;
              location = ses->task.target.location;
            }
            frame = 0;
            goto LABEL_81;
          }
          if ( v15 != TASK_FORWARD )
            goto LABEL_12;
          redirect = cached->redirect;
          protocol_external_handler = get_protocol_external_handler(ses->tab->term, redirect);
          if ( protocol_external_handler )
          {
            v11 = 0;
            protocol_external_handler(ses, redirect);
            download = 0;
LABEL_57:
            v5 = download;
            goto LABEL_20;
          }
        }
        v29 = v15;
        reloadlevel = CACHE_MODE_NORMAL;
        location = 0;
        frame = ses->task.target.frame;
LABEL_81:
        v25 = cached->redirect;
        v11 = 2;
        ses_goto(ses, v25, frame, location, reloadlevel, v29, 1);
        goto LABEL_57;
      }
    }
  }
LABEL_12:
  kill_timer(&ses->display_timer);
  v8 = ses->task.type;
  if ( v8 == TASK_IMGMAP )
  {
    v20 = find_in_cache(ses->loading_uri);
    v21 = current_frame(ses);
    if ( v20 )
    {
      v32 = v21;
      cache_fragment = get_cache_fragment(v20);
      if ( cache_fragment )
      {
        if ( v32 )
        {
          if ( v32->document )
          {
            hdef = get_opt_(config_options, "document.codepage.force_assumed")->number;
            def = get_opt_(config_options, "document.codepage.assume")->number;
            terminal_codepage = get_terminal_codepage(ses->tab->term);
            if ( !get_image_map(
                    v20->head,
                    cache_fragment->data,
                    &cache_fragment->data[LODWORD(cache_fragment->length)],
                    &menu,
                    &ml,
                    ses->loading_uri,
                    &v32->document->options,
                    ses->task.target.frame,
                    terminal_codepage,
                    def,
                    hdef) )
            {
              add_empty_window(ses->tab->term, (void (*)(void *))freeml, ml);
              do_menu(ses->tab->term, menu, ses, 0);
            }
          }
        }
      }
    }
    else
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/session/task.c";
      errline = 377;
      elinks_internal("can't find cache entry");
    }
    goto LABEL_15;
  }
  if ( (unsigned int)v8 > TASK_IMGMAP )
  {
    if ( v8 == TASK_RELOAD )
    {
      ses->task.target.location = ses->history.current->prev;
      ses_history_move(ses);
      ses_forward(ses, 0);
    }
    else if ( v8 == TASK_HISTORY )
    {
      ses_history_move(ses);
    }
    goto LABEL_15;
  }
  if ( v8 != TASK_FORWARD || !setup_download_handler(ses, &ses->loading, cached, 0) )
  {
LABEL_15:
    p_download = download;
    if ( download->state.basic < S_WAIT )
    {
      v18 = ses->history.current;
      if ( v18 )
      {
        syserr = ses->loading.state.syserr;
        v18->download.state.basic = ses->loading.state.basic;
        v18->download.state.syserr = syserr;
      }
    }
    else
    {
      v10 = ses->history.current;
      if ( v10 )
      {
        p_download = &v10->download;
        download = &v10->download;
      }
      move_download(&ses->loading, p_download, PRI_MAIN);
    }
    v11 = 1;
    free_task(ses);
    v5 = download;
    goto LABEL_20;
  }
  v11 = 2;
  free_task(ses);
  reload(ses, CACHE_MODE_NORMAL);
  v5 = download;
LABEL_20:
  if ( v5 )
  {
    if ( v11 != 2 )
    {
      if ( v11 == 1 )
      {
        v5->callback = (download_callback_T *)doc_loading_callback;
        download->data = ses;
        display_timer(ses);
        v5 = download;
      }
      if ( v5->state.basic < S_WAIT )
      {
        if ( ses->task.type )
        {
          free_task(ses);
          v5 = download;
        }
        if ( v11 == 1 )
        {
          doc_loading_callback(v5, ses);
          v5 = download;
        }
        basic = v5->state.basic;
        if ( basic != -100000 && basic < 0 )
        {
          conn = v5->conn;
          uri = 0;
          if ( conn )
            uri = conn->uri;
          print_error_dialog(ses, v5->state, uri, v5->pri);
          if ( !v11 )
            reload(ses, CACHE_MODE_NORMAL);
        }
      }
    }
    check_questions_queue(ses);
    print_screen_status(ses);
  }
}

//----- (080DA9D0) --------------------------------------------------------
void __cdecl abort_preloading(session *ses, int interrupt)
{
  if ( ses->task.type )
  {
    cancel_download(&ses->loading, interrupt);
    free_task(ses);
  }
}

//----- (080DAA10) --------------------------------------------------------
void __cdecl post_yes(void *task_)
{
  abort_preloading(*(session **)task_, 0);
  ses_load(
    *(session **)task_,
    *((uri **)task_ + 1),
    *((unsigned __int8 **)task_ + 4),
    *((location **)task_ + 5),
    *((cache_mode *)task_ + 2),
    *((task_type *)task_ + 3));
}

//----- (080DAA60) --------------------------------------------------------
void __cdecl set_term_color16(screen_char *schar, color_flags flags, unsigned __int8 fg, unsigned __int8 bg)
{
  unsigned __int8 v4; // al
  unsigned __int8 v5; // bl
  unsigned __int8 v6; // dl
  unsigned __int8 attr; // cl
  unsigned __int8 v8; // di
  unsigned __int8 v9; // cl

  v4 = fg;
  v5 = bg;
  v6 = bg;
  if ( (flags & 4) != 0 )
    v4 = fg_color[fg][bg];
  attr = schar->attr;
  if ( attr )
  {
    if ( (attr & 0x10) != 0 )
      v4 ^= 1u;
    if ( (attr & 8) != 0 )
      v4 |= 8u;
    if ( (attr & 0x20) != 0 && (flags & 2) != 0 )
      v4 = (v4 | 8) ^ 4;
  }
  if ( (flags & 4) != 0 )
    goto LABEL_17;
  if ( bg != v4 )
  {
    v6 = v4;
    v8 = bg;
    goto LABEL_12;
  }
  if ( (flags & 8) != 0 )
  {
LABEL_17:
    if ( (flags & 0x10) != 0 )
    {
      v9 = fg_color[v4][bg];
      v4 = bg;
      v8 = v9;
      v5 = v9;
    }
    else
    {
      v8 = bg;
      v4 = fg_color[v4][bg];
      v6 = v4;
    }
  }
  else
  {
    v6 = bg;
    v4 = bg;
    v8 = bg;
  }
LABEL_12:
  if ( (v6 & 8) != 0 )
    schar->attr |= 8u;
  if ( (((2 * (v6 & 7)) | ((v6 & 7) >> 2)) & 7) < (((2 * v8) | (v5 >> 2)) & 7) )
    schar->attr |= 0x40u;
  schar->color[0] = (16 * v8) | v4;
}

//----- (080DABA0) --------------------------------------------------------
void __cdecl set_term_color(screen_char *schar, color_pair *pair, color_flags flags, color_mode color_mode)
{
  unsigned __int32 v4; // ebx
  const rgb *palette; // eax
  unsigned int v6; // edx
  int v7; // ebx
  int v8; // ebx
  int v9; // edx
  int v10; // ecx
  int v11; // ecx
  int v12; // esi
  int v13; // edi
  int bg; // edi
  color_T v15; // edx
  unsigned __int8 v16; // bl
  int v17; // ecx
  int v18; // esi
  int v19; // ecx
  int v20; // esi
  int v21; // edx
  int v22; // ecx
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  unsigned __int8 attr; // dl
  unsigned __int8 v27; // bl
  unsigned __int8 v28; // di
  char v29; // al
  char v30; // bl
  int i; // [esp+1Ch] [ebp-7Ch]
  unsigned int v32; // [esp+2Ch] [ebp-6Ch]
  palette_range palette_range; // [esp+34h] [ebp-64h]
  int v34; // [esp+3Ch] [ebp-5Ch]
  unsigned __int8 v35; // [esp+40h] [ebp-58h]
  unsigned int v36; // [esp+60h] [ebp-38h]
  const color_mode_info *mode; // [esp+64h] [ebp-34h]
  color_T foreground; // [esp+68h] [ebp-30h]
  color_T background; // [esp+68h] [ebp-30h]
  unsigned __int8 v40; // [esp+6Fh] [ebp-29h]
  unsigned __int8 v41; // [esp+6Fh] [ebp-29h]
  int v42; // [esp+70h] [ebp-28h]
  int v43; // [esp+70h] [ebp-28h]
  int fg; // [esp+7Ch] [ebp-1Ch]
  int v45; // [esp+7Ch] [ebp-1Ch]

  v4 = color_mode + 1;
  if ( !assert_failed )
  {
    assert_failed = v4 > 5;
    if ( v4 > 5 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
      errline = 299;
      elinks_internal("assertion color_mode >= COLOR_MODE_DUMP && color_mode < COLOR_MODES failed!");
    }
  }
  switch ( color_mode )
  {
    case COLOR_MODE_DUMP:
    case COLOR_MODES:
      return;
    case COLOR_MODE_MONO:
      if ( (flags & 1) == 0 )
        goto LABEL_5;
      schar->attr |= 0x40u;
      palette_range = PALETTE_HALF;
      if ( assert_failed )
        goto LABEL_9;
      goto LABEL_7;
    case COLOR_MODE_88:
    case COLOR_MODE_256:
      goto LABEL_5;
    default:
      palette_range = PALETTE_HALF;
      if ( (flags & 1) == 0 )
LABEL_5:
        palette_range = PALETTE_FULL;
      if ( !assert_failed )
      {
LABEL_7:
        assert_failed = schar == 0;
        if ( !schar )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
          errline = 366;
          elinks_internal("assertion schar failed!");
        }
      }
LABEL_9:
      mode = color_modes[color_mode];
      fg = mode->palette_range[palette_range].fg;
      palette = mode->palette;
      foreground = pair->foreground;
      v6 = (foreground & 0xFF0000) >> 16;
      v32 = 12 * (((_WORD)fg + (unsigned __int8)foreground + 8 * (_WORD)v6 + 4 * BYTE1(foreground)) & 0xFFF);
      v7 = *(_DWORD *)((char *)&unk_814F064 + v32);
      if ( !v7
        || fg != v7
        || foreground != dword_814F068[3
                                     * (((_WORD)fg
                                       + (unsigned __int8)pair->foreground
                                       + 8 * (_WORD)v6
                                       + 4 * (unsigned __int8)BYTE1(pair->foreground)) & 0xFFF)] )
      {
        v8 = 0;
        v35 = 0;
        if ( fg > 1 )
        {
          v42 = (unsigned __int8)v6;
          v40 = 0;
          v9 = 1;
          for ( i = 3 * (v42 - palette->r) * (v42 - palette->r)
                  + 4 * (BYTE1(foreground) - palette->g) * (BYTE1(foreground) - palette->g)
                  + 2 * ((unsigned __int8)foreground - palette->b) * ((unsigned __int8)foreground - palette->b); ; i = v10 )
          {
            v11 = v42 - palette[v9].r;
            v12 = BYTE1(foreground) - palette[v9].g;
            v13 = (unsigned __int8)foreground - palette[v9].b;
            v10 = 3 * v11 * v11 + 4 * v12 * v12 + 2 * v13 * v13;
            if ( v10 >= i )
            {
              ++v9;
              v10 = i;
              if ( v9 == fg )
                goto LABEL_16;
            }
            else
            {
              v40 = v9++;
              if ( v9 == fg )
              {
LABEL_16:
                v8 = v40;
                v35 = v40;
                break;
              }
            }
          }
        }
        cache_3940[v32 / 4] = v8;
        *(_DWORD *)(v32 + 135589988) = fg;
        *(_DWORD *)(v32 + 135589992) = foreground;
        palette = mode->palette;
        goto LABEL_18;
      }
      v35 = cache_3940[3
                     * (((_WORD)fg
                       + (unsigned __int8)pair->foreground
                       + 8 * (_WORD)v6
                       + 4 * (unsigned __int8)BYTE1(pair->foreground)) & 0xFFF)];
LABEL_18:
      bg = mode->palette_range[palette_range].bg;
      v45 = bg;
      background = pair->background;
      v15 = (pair->background & 0xFF0000) >> 16;
      v16 = BYTE1(pair->background);
      v36 = 12 * (((_WORD)bg + (unsigned __int8)pair->background + 8 * (_WORD)v15 + 4 * v16) & 0xFFF);
      v17 = *(_DWORD *)((char *)&unk_814F064 + v36);
      if ( v17
        && bg == v17
        && background == dword_814F068[3
                                     * (((_WORD)bg
                                       + (unsigned __int8)pair->background
                                       + 8 * (_WORD)v15
                                       + 4 * (unsigned __int8)BYTE1(pair->background)) & 0xFFF)] )
      {
        LOBYTE(v18) = cache_3940[3
                               * (((_WORD)bg
                                 + (unsigned __int8)pair->background
                                 + 8 * (_WORD)v15
                                 + 4 * (unsigned __int8)BYTE1(pair->background)) & 0xFFF)];
        goto LABEL_27;
      }
      LOBYTE(v18) = 0;
      v19 = 0;
      if ( bg <= 1 )
        goto LABEL_26;
      v43 = (unsigned __int8)v15;
      v20 = v16 - palette->g;
      v41 = 0;
      v21 = 1;
      v34 = 3 * (v43 - palette->r) * (v43 - palette->r)
          + 4 * v20 * v20
          + 2 * ((unsigned __int8)background - palette->b) * ((unsigned __int8)background - palette->b);
      break;
  }
  while ( 1 )
  {
    v23 = v43 - palette[v21].r;
    v24 = v16 - palette[v21].g;
    v25 = (unsigned __int8)background - palette[v21].b;
    v22 = 3 * v23 * v23 + 4 * v24 * v24 + 2 * v25 * v25;
    if ( v22 < v34 )
      break;
    ++v21;
    v22 = v34;
    if ( v21 == v45 )
      goto LABEL_25;
LABEL_22:
    v34 = v22;
  }
  v41 = v21++;
  if ( v21 != v45 )
    goto LABEL_22;
LABEL_25:
  v19 = v41;
  LOBYTE(v18) = v41;
LABEL_26:
  cache_3940[v36 / 4] = v19;
  *(_DWORD *)(v36 + 135589988) = v45;
  *(_DWORD *)(v36 + 135589992) = background;
LABEL_27:
  if ( color_mode <= COLOR_MODE_256 )
  {
    if ( color_mode >= COLOR_MODE_88 )
    {
      if ( v35 == (_BYTE)v18 )
      {
        LOBYTE(v18) = v35;
        if ( (flags & 8) != 0 )
        {
          if ( (flags & 0x10) != 0 )
          {
            v18 = v35 == 0 ? 0xF : 0;
          }
          else if ( v35 )
          {
            LOBYTE(v18) = v35;
            v35 = 0;
          }
          else
          {
            LOBYTE(v18) = 0;
            v35 = 15;
          }
        }
      }
      schar->color[0] = v35;
      schar->color[1] = v18;
      return;
    }
    if ( color_mode == COLOR_MODE_DUMP )
      goto LABEL_61;
LABEL_29:
    if ( (flags & 4) != 0 )
      v35 = fg_color[v35][(unsigned __int8)v18];
    attr = schar->attr;
    if ( attr )
    {
      v27 = v35;
      if ( (attr & 0x10) != 0 )
        v27 = v35 ^ 1;
      if ( (attr & 8) != 0 )
        v27 |= 8u;
      v35 = v27;
      if ( (attr & 0x20) != 0 && (flags & 2) != 0 )
        v35 = (v27 | 8) ^ 4;
    }
    if ( (flags & 4) != 0 )
      goto LABEL_40;
    if ( v35 == (_BYTE)v18 )
    {
      if ( (flags & 8) != 0 )
      {
LABEL_40:
        if ( (flags & 0x10) != 0 )
        {
          v28 = fg_color[v35][(unsigned __int8)v18];
          v29 = v28;
          v30 = v18;
          v35 = v18;
        }
        else
        {
          v28 = v18;
          v35 = fg_color[v35][(unsigned __int8)v18];
          v30 = v35;
          v29 = v18;
        }
        goto LABEL_42;
      }
      v29 = v18;
      v30 = v18;
      v28 = v35;
    }
    else
    {
      v30 = v35;
      v29 = v18;
      v28 = v18;
    }
LABEL_42:
    if ( (v30 & 8) != 0 )
      schar->attr = attr | 8;
    if ( (((2 * (v30 & 7)) | ((v30 & 7) >> 2)) & 7) < (((2 * v29) | (v28 >> 2)) & 7) )
      schar->attr |= 0x40u;
    schar->color[0] = v35 | (16 * v29);
    return;
  }
  if ( color_mode != COLOR_MODES )
    goto LABEL_29;
LABEL_61:
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/color.c";
  errline = 375;
  elinks_internal("Bad color mode, it should _never_ occur here.");
}
// 814F060: using guessed type int cache_3940[];
// 814F068: using guessed type _DWORD dword_814F068[12286];

//----- (080DB190) --------------------------------------------------------
screen_char *__cdecl get_char(terminal *term, int x, int y)
{
  terminal_screen *screen; // eax
  int v5; // edx
  int width; // ecx
  int v7; // eax
  int height; // esi
  int v9; // eax

  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  v5 = 0;
  width = term->width;
  if ( x >= 0 )
  {
    v5 = width - 1;
    if ( x <= width - 1 )
      v5 = x;
  }
  v7 = 0;
  height = term->height;
  if ( y >= 0 )
  {
    v9 = height - 1;
    if ( y <= height - 1 )
      v9 = y;
    v7 = width * v9;
  }
  return &term->screen->image[v5 + v7];
}

//----- (080DB260) --------------------------------------------------------
void __cdecl set_cursor(terminal *term, int x, int y, int blockable)
{
  int v4; // esi
  terminal_screen *screen; // eax
  int cy; // edx
  int v8; // ecx
  int v9; // esi
  int v10; // edi
  int width; // [esp+1Ch] [ebp-1Ch]
  int height; // [esp+1Ch] [ebp-1Ch]

  v4 = x;
  if ( assert_failed )
    goto LABEL_24;
  if ( !term || !term->screen )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 564;
    elinks_internal("assertion term && term->screen failed!");
    if ( !assert_failed )
      goto LABEL_5;
LABEL_24:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_5:
  if ( blockable && get_opt_(term->spec, "block_cursor")->number )
  {
    screen = term->screen;
    v4 = term->width - 1;
    y = term->height - 1;
    if ( screen->cx == v4 )
    {
LABEL_27:
      cy = screen->cy;
      if ( cy == y )
        return;
      goto LABEL_8;
    }
  }
  else
  {
    screen = term->screen;
    if ( screen->cx == x )
      goto LABEL_27;
  }
  cy = screen->cy;
LABEL_8:
  width = term->width;
  v8 = 0;
  if ( v4 >= 0 )
  {
    v8 = width - 1;
    if ( v4 <= width - 1 )
      v8 = v4;
  }
  height = term->height;
  v9 = 0;
  if ( y >= 0 )
  {
    v9 = height - 1;
    if ( y <= height - 1 )
      v9 = y;
  }
  v10 = cy;
  if ( v9 >= cy )
    v10 = v9;
  if ( v9 <= cy )
    cy = v9;
  if ( cy < screen->dirty_from )
    screen->dirty_from = cy;
  if ( v10 > screen->dirty_to )
    screen->dirty_to = v10;
  term->screen->cx = v8;
  term->screen->cy = v9;
}

//----- (080DB3B0) --------------------------------------------------------
void __cdecl draw_box(terminal *term, box *box, unsigned __int8 data, screen_char_attr attr, color_pair *color)
{
  terminal *v5; // edi
  int y; // ebx
  int x; // esi
  terminal_screen *screen; // eax
  int v9; // edx
  int width; // eax
  int v11; // ecx
  int height; // esi
  int v13; // esi
  int v14; // ecx
  int v15; // eax
  int v16; // esi
  unsigned int v17; // ebx
  option_value *opt; // eax
  screen_char *v19; // eax
  int v20; // ebx
  terminal *v21; // edx
  screen_char *v22; // esi
  terminal_screen *v23; // eax
  int v24; // edx
  int v25; // ecx
  int v26; // [esp+10h] [ebp-28h]
  terminal *v27; // [esp+10h] [ebp-28h]
  screen_char *src; // [esp+18h] [ebp-20h]
  int n; // [esp+1Ch] [ebp-1Ch]

  v5 = term;
  y = box->y;
  x = box->x;
  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return;
    }
  }
  v9 = 0;
  width = term->width;
  if ( x >= 0 )
  {
    v9 = width - 1;
    if ( width - 1 > x )
      v9 = x;
  }
  v11 = 0;
  height = term->height;
  if ( y >= 0 )
  {
    v11 = height - 1;
    if ( height - 1 > y )
      v11 = y;
  }
  src = &term->screen->image[v9 + width * v11];
  if ( src )
  {
    v13 = height - box->y;
    v14 = box->height;
    if ( v13 <= v14 )
      v14 = v13;
    v15 = width - box->x;
    v16 = box->width;
    if ( v15 <= v16 )
      v16 = v15;
    if ( v16 > 0 && v14 > 0 )
    {
      v17 = (unsigned int)&src[v16 - 1];
      *(_BYTE *)(v17 + 4) = attr;
      *(_DWORD *)v17 = data;
      if ( color )
      {
        v26 = v14;
        opt = get_opt_(term->spec, "colors");
        set_term_color((screen_char *)v17, color, (color_flags)0, (color_mode)opt->tree);
        v14 = v26;
      }
      else
      {
        *(_WORD *)(v17 + 5) = 0;
      }
      if ( v17 > (unsigned int)src )
      {
        v19 = src;
        do
        {
          v19->data = *(_DWORD *)v17;
          *(_DWORD *)&v19->attr = *(_DWORD *)(v17 + 4);
          ++v19;
        }
        while ( v17 > (unsigned int)v19 );
      }
      v20 = v14 - 1;
      if ( v14 != 1 )
      {
        v21 = term;
        n = 8 * v16;
        v22 = src;
        do
        {
          v22 += v21->width;
          v27 = v21;
          memcpy(v22, src, n);
          --v20;
          v21 = v27;
        }
        while ( v20 );
        v5 = v27;
      }
      v23 = v5->screen;
      v24 = box->y;
      v25 = v24 + box->height;
      if ( v24 < v23->dirty_from )
        v23->dirty_from = v24;
      if ( v25 > v23->dirty_to )
        v23->dirty_to = v25;
    }
  }
}

//----- (080DB5A0) --------------------------------------------------------
void __cdecl clear_terminal(terminal *term)
{
  int v1; // eax
  int width; // ecx
  int height; // edx
  box box; // [esp+20h] [ebp-18h] BYREF

  v1 = 0;
  width = term->width;
  height = term->height;
  box.x = 0;
  if ( width < 0 )
    width = 0;
  if ( height >= 0 )
    v1 = height;
  box.height = v1;
  box.width = width;
  box.y = 0;
  draw_box(term, &box, 0x20u, (screen_char_attr)0, 0);
  set_cursor(term, 0, 0, 1);
}

//----- (080DB620) --------------------------------------------------------
void __cdecl draw_shadow(terminal *term, box *box, color_pair *color, int width, int height)
{
  int v5; // esi
  int v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // [esp+2Ch] [ebp-3Ch]
  box dbox; // [esp+40h] [ebp-28h] BYREF

  v5 = 0;
  v6 = width;
  v7 = box->y + box->height;
  v8 = box->x + width;
  if ( v8 < 0 )
    v8 = 0;
  if ( v7 < 0 )
    v7 = 0;
  dbox.x = v8;
  dbox.y = v7;
  v9 = box->width - width;
  if ( v9 < 0 )
    v9 = 0;
  dbox.width = v9;
  v10 = 0;
  if ( height >= 0 )
    v10 = height;
  dbox.height = v10;
  draw_box(term, &dbox, 0x20u, (screen_char_attr)0, color);
  v13 = box->height;
  v11 = box->y + height;
  v12 = box->x + box->width;
  if ( v12 < 0 )
    v12 = 0;
  if ( v11 < 0 )
    v11 = 0;
  dbox.y = v11;
  if ( width < 0 )
    v6 = 0;
  dbox.x = v12;
  dbox.width = v6;
  if ( v13 >= 0 )
    v5 = v13;
  dbox.height = v5;
  draw_box(term, &dbox, 0x20u, (screen_char_attr)0, color);
}

//----- (080DB700) --------------------------------------------------------
void __cdecl draw_char_data(terminal *term, int x, int y, unicode_val_T data)
{
  int v4; // eax
  terminal_screen *screen; // edx
  int v6; // edx
  int width; // ecx
  int v8; // eax
  int v9; // eax
  screen_char *v10; // eax
  terminal_screen *v11; // eax
  int height; // [esp+1Ch] [ebp-1Ch]

  v4 = x;
  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    v4 = x;
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return;
    }
  }
  v6 = 0;
  width = term->width;
  if ( v4 >= 0 )
  {
    v6 = width - 1;
    if ( v4 <= width - 1 )
      v6 = v4;
  }
  height = term->height;
  v8 = 0;
  if ( y >= 0 )
  {
    v9 = height - 1;
    if ( y <= height - 1 )
      v9 = y;
    v8 = width * v9;
  }
  v10 = &term->screen->image[v6 + v8];
  if ( v10 )
  {
    v10->data = data;
    if ( data == -3 )
      v10->attr = 0;
    v11 = term->screen;
    if ( y < v11->dirty_from )
      v11->dirty_from = y;
    if ( y > v11->dirty_to )
      v11->dirty_to = y;
  }
}

//----- (080DB800) --------------------------------------------------------
void __cdecl draw_char(terminal *term, int x, int y, unicode_val_T data, screen_char_attr attr, color_pair *color)
{
  terminal_screen *screen; // eax
  int v7; // ecx
  int width; // edx
  int v9; // eax
  int height; // edi
  int v11; // eax
  screen_char *v12; // edi
  terminal_screen *v13; // eax
  int number; // [esp+Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return;
    }
  }
  v7 = 0;
  width = term->width;
  if ( x >= 0 )
  {
    v7 = width - 1;
    if ( x <= width - 1 )
      v7 = x;
  }
  v9 = 0;
  height = term->height;
  if ( y >= 0 )
  {
    v11 = height - 1;
    if ( y <= height - 1 )
      v11 = y;
    v9 = width * v11;
  }
  v12 = &term->screen->image[v9 + v7];
  if ( v12 )
  {
    v12->data = data;
    v12->attr = attr;
    number = get_opt_(term->spec, "colors")->number;
    set_term_color(v12, color, (color_flags)0, (color_mode)number);
    v13 = term->screen;
    if ( y < v13->dirty_from )
      v13->dirty_from = y;
    if ( y > v13->dirty_to )
      v13->dirty_to = y;
  }
}

//----- (080DB930) --------------------------------------------------------
void __cdecl draw_line(terminal *term, int x, int y, int l, screen_char *line)
{
  int v5; // eax
  terminal_screen *screen; // edx
  int v7; // edi
  int width; // ecx
  int v9; // edx
  int v10; // edx
  screen_char *v11; // edi
  int v12; // edx
  int v13; // eax
  terminal_screen *v14; // eax
  unicode_val_T data; // ecx
  size_t v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+14h] [ebp-24h]
  int v18; // [esp+14h] [ebp-24h]
  unicode_val_T v19; // [esp+14h] [ebp-24h]
  int height; // [esp+18h] [ebp-20h]
  screen_char *v21; // [esp+18h] [ebp-20h]

  v5 = x;
  if ( assert_failed )
    goto LABEL_30;
  if ( term )
  {
    screen = term->screen;
    if ( screen )
    {
      if ( screen->image )
      {
        assert_failed = 0;
        goto LABEL_6;
      }
    }
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
  errline = 39;
  elinks_internal("assertion term && term->screen && term->screen->image failed!");
  v5 = x;
  if ( assert_failed )
  {
LABEL_30:
    v11 = 0;
    goto LABEL_14;
  }
LABEL_6:
  v7 = 0;
  width = term->width;
  if ( v5 >= 0 )
  {
    v7 = width - 1;
    if ( v5 <= width - 1 )
      v7 = v5;
  }
  height = term->height;
  v9 = 0;
  if ( y >= 0 )
  {
    v10 = height - 1;
    if ( y <= height - 1 )
      v10 = y;
    v9 = width * v10;
  }
  v11 = &term->screen->image[v9 + v7];
LABEL_14:
  assert_failed = line == 0;
  if ( line
    || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c",
        errline = 151,
        v18 = v5,
        elinks_internal("assertion line failed!"),
        v5 = v18,
        !assert_failed) )
  {
    if ( v11 )
    {
      v12 = term->width - v5;
      if ( l <= v12 )
        v12 = l;
      if ( v12 )
      {
        if ( (*((_BYTE *)term + 56) & 2) == 0 )
          goto LABEL_23;
        if ( !v5 && line->data == -3 )
        {
          v11->data = 32;
          --v12;
          *(_DWORD *)&v11->attr = *(_DWORD *)&line->attr;
          ++v11;
          line->data = -3;
          ++line;
        }
        if ( v12 - 1 > 0 && (v21 = &line[v12 - 1], v17 = v12, v13 = unicode_to_cell(v21->data), v12 = v17, v13 == 2) )
        {
          data = v21->data;
          v21->data = 32;
          v16 = 8 * v17;
          v19 = data;
          memcpy(v11, line, v16);
          v21->data = v19;
        }
        else
        {
LABEL_23:
          memcpy(v11, line, 8 * v12);
        }
        v14 = term->screen;
        if ( y < v14->dirty_from )
          v14->dirty_from = y;
        if ( y > v14->dirty_to )
          v14->dirty_to = y;
      }
    }
  }
  else
  {
    assert_failed = 0;
  }
}

//----- (080DBB60) --------------------------------------------------------
void __cdecl draw_char_color(terminal *term, int x, int y, color_pair *color)
{
  terminal_screen *screen; // eax
  int v5; // ecx
  int width; // edx
  int v7; // eax
  int height; // edi
  int v9; // eax
  screen_char *v10; // edi
  terminal_screen *v11; // eax
  int number; // [esp+Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return;
    }
  }
  v5 = 0;
  width = term->width;
  if ( x >= 0 )
  {
    v5 = width - 1;
    if ( x <= width - 1 )
      v5 = x;
  }
  v7 = 0;
  height = term->height;
  if ( y >= 0 )
  {
    v9 = height - 1;
    if ( y <= height - 1 )
      v9 = y;
    v7 = width * v9;
  }
  v10 = &term->screen->image[v7 + v5];
  if ( v10 )
  {
    number = get_opt_(term->spec, "colors")->number;
    set_term_color(v10, color, (color_flags)0, (color_mode)number);
    v11 = term->screen;
    if ( y < v11->dirty_from )
      v11->dirty_from = y;
    if ( y > v11->dirty_to )
      v11->dirty_to = y;
  }
}

//----- (080DBC80) --------------------------------------------------------
void __cdecl draw_border_char(terminal *term, int x, int y, border_char border, color_pair *color)
{
  terminal_screen *screen; // eax
  int v6; // ecx
  int width; // edx
  int v8; // eax
  int height; // edi
  int v10; // eax
  screen_char *v11; // edi
  terminal_screen *v12; // eax
  int number; // [esp+Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return;
    }
  }
  v6 = 0;
  width = term->width;
  if ( x >= 0 )
  {
    v6 = width - 1;
    if ( x <= width - 1 )
      v6 = x;
  }
  v8 = 0;
  height = term->height;
  if ( y >= 0 )
  {
    v10 = height - 1;
    if ( y <= height - 1 )
      v10 = y;
    v8 = width * v10;
  }
  v11 = &term->screen->image[v8 + v6];
  if ( v11 )
  {
    v11->attr = 0x80;
    v11->data = (unsigned __int8)border;
    number = get_opt_(term->spec, "colors")->number;
    set_term_color(v11, color, (color_flags)0, (color_mode)number);
    v12 = term->screen;
    if ( y < v12->dirty_from )
      v12->dirty_from = y;
    if ( y > v12->dirty_to )
      v12->dirty_to = y;
  }
}

//----- (080DBDB0) --------------------------------------------------------
void __cdecl draw_border(terminal *term, box *box, color_pair *color, int width)
{
  const border_char *v4; // edi
  int v5; // eax
  int v6; // edx
  int v7; // edx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // ebx
  terminal_screen *screen; // eax
  int v15; // [esp+2Ch] [ebp-4Ch]
  int y; // [esp+3Ch] [ebp-3Ch]
  int ya; // [esp+3Ch] [ebp-3Ch]
  int yb; // [esp+3Ch] [ebp-3Ch]
  int x; // [esp+40h] [ebp-38h]
  int right; // [esp+44h] [ebp-34h]
  unsigned __int8 rightb; // [esp+44h] [ebp-34h]
  int righta; // [esp+44h] [ebp-34h]
  unsigned __int8 rightc; // [esp+44h] [ebp-34h]
  int rightd; // [esp+44h] [ebp-34h]
  int v25; // [esp+48h] [ebp-30h]
  int bottom; // [esp+4Ch] [ebp-2Ch]
  int bottoma; // [esp+4Ch] [ebp-2Ch]
  box bbox; // [esp+50h] [ebp-28h] BYREF

  v4 = p1_4830;
  if ( width > 1 )
    v4 = p2_4831;
  right = box->width;
  v15 = box->x;
  v5 = 0;
  v6 = box->x - 1;
  if ( v6 < 0 )
    v6 = 0;
  x = v6;
  v7 = box->y - 1;
  if ( v7 < 0 )
    v7 = 0;
  v8 = right + 2;
  if ( right + 2 < 0 )
    v8 = 0;
  v25 = v8;
  v9 = box->height + 2;
  if ( v9 < 0 )
    v9 = 0;
  bottom = v9;
  if ( v25 > 2 )
  {
    bbox.y = v7;
    bbox.height = 1;
    v10 = v15;
    if ( v15 < 0 )
      v10 = 0;
    bbox.x = v10;
    if ( right >= 0 )
      v5 = right;
    bbox.width = v5;
    y = v7;
    rightb = *((_BYTE *)v4 + 20);
    draw_box(term, &bbox, rightb, SCREEN_ATTR_FRAME, color);
    bbox.y = bottom + bbox.y - 1;
    draw_box(term, &bbox, rightb, SCREEN_ATTR_FRAME, color);
    v7 = y;
  }
  if ( bottom > 2 )
  {
    v11 = 0;
    righta = box->height;
    v12 = box->y;
    bbox.width = 1;
    bbox.x = x;
    if ( v12 < 0 )
      v12 = 0;
    bbox.y = v12;
    if ( righta >= 0 )
      v11 = righta;
    bbox.height = v11;
    ya = v7;
    rightc = *((_BYTE *)v4 + 16);
    draw_box(term, &bbox, rightc, SCREEN_ATTR_FRAME, color);
    bbox.x = v25 + bbox.x - 1;
    draw_box(term, &bbox, rightc, SCREEN_ATTR_FRAME, color);
    v7 = ya;
  }
  if ( v25 <= 1 || bottom <= 1 )
  {
    v13 = v7 + bottom;
  }
  else
  {
    rightd = v25 + x - 1;
    v13 = v7 + bottom;
    bottoma = v7 + bottom - 1;
    yb = v7;
    draw_border_char(term, x, v7, *v4, color);
    draw_border_char(term, rightd, yb, v4[1], color);
    draw_border_char(term, x, bottoma, v4[2], color);
    draw_border_char(term, rightd, bottoma, v4[3], color);
    v7 = yb;
  }
  screen = term->screen;
  if ( screen->dirty_from > v7 )
    screen->dirty_from = v7;
  if ( v13 > screen->dirty_to )
    screen->dirty_to = v13;
}

//----- (080DC020) --------------------------------------------------------
void __cdecl draw_border_cross(terminal *term, int x, int y, border_cross_direction dir, color_pair *color)
{
  int v5; // eax
  terminal_screen *screen; // edx
  int v7; // edx
  int width; // ecx
  int v9; // eax
  int v10; // eax
  screen_char *v11; // esi
  unsigned int v12; // eax
  option_value *opt; // eax
  int height; // [esp+1Ch] [ebp-1Ch]

  v5 = x;
  if ( assert_failed )
    goto LABEL_2;
  if ( term && (screen = term->screen) != 0 && screen->image )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    v5 = x;
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return;
    }
  }
  v7 = 0;
  width = term->width;
  if ( v5 >= 0 )
  {
    v7 = width - 1;
    if ( v5 <= width - 1 )
      v7 = v5;
  }
  height = term->height;
  v9 = 0;
  if ( y >= 0 )
  {
    v10 = height - 1;
    if ( y <= height - 1 )
      v10 = y;
    v9 = width * v10;
  }
  v11 = &term->screen->image[v9 + v7];
  if ( v11 && (v11->attr & 0x80u) != 0 )
  {
    v12 = (unsigned int)dir >> 1;
    if ( v11->data == (unsigned __int8)border_trans_4691[(unsigned int)dir >> 1][0] )
    {
      v11->data = (unsigned __int8)byte_810D4B1[4 * v12 + (dir & 1)];
    }
    else if ( v11->data == (unsigned __int8)byte_810D4B2[4 * v12 - (dir & 1)] )
    {
      v11->data = 197;
    }
    opt = get_opt_(term->spec, "colors");
    set_term_color(v11, color, (color_flags)0, (color_mode)opt->tree);
  }
}

//----- (080DC1B0) --------------------------------------------------------
void __cdecl draw_text(
        terminal *term,
        int x,
        int y,
        unsigned __int8 *text,
        int length,
        screen_char_attr attr,
        color_pair *color)
{
  terminal *v7; // edx
  int v8; // ecx
  unsigned __int8 *v9; // esi
  unsigned int v10; // ebx
  terminal_screen *v11; // eax
  int v12; // ebx
  int v13; // eax
  screen_char *v14; // ebx
  int v15; // edi
  int v16; // eax
  int v17; // edi
  screen_char *v18; // edi
  unsigned __int8 v19; // al
  unsigned __int8 v20; // al
  unicode_val_T v21; // eax
  terminal *v22; // edx
  int v23; // ecx
  unicode_val_T v24; // esi
  int v25; // eax
  terminal *v26; // edx
  int v27; // ecx
  int v28; // eax
  unicode_val_T *v29; // ebx
  int v30; // edi
  unicode_val_T v31; // esi
  unsigned __int8 v32; // al
  terminal_screen *v33; // eax
  terminal_screen *screen; // eax
  int v35; // ebx
  int v36; // eax
  int height; // ebx
  int v38; // eax
  int v39; // [esp+Ch] [ebp-4Ch]
  int number; // [esp+Ch] [ebp-4Ch]
  int v41; // [esp+18h] [ebp-40h]
  int v42; // [esp+18h] [ebp-40h]
  int v43; // [esp+18h] [ebp-40h]
  int v44; // [esp+18h] [ebp-40h]
  int v45; // [esp+18h] [ebp-40h]
  int v46; // [esp+18h] [ebp-40h]
  int v47; // [esp+18h] [ebp-40h]
  terminal *v48; // [esp+1Ch] [ebp-3Ch]
  terminal *v49; // [esp+1Ch] [ebp-3Ch]
  terminal *v50; // [esp+1Ch] [ebp-3Ch]
  terminal *v51; // [esp+1Ch] [ebp-3Ch]
  terminal *v52; // [esp+1Ch] [ebp-3Ch]
  terminal *v53; // [esp+1Ch] [ebp-3Ch]
  terminal *v54; // [esp+1Ch] [ebp-3Ch]
  int v55; // [esp+20h] [ebp-38h]
  int width; // [esp+24h] [ebp-34h]
  int v57; // [esp+24h] [ebp-34h]
  int v58; // [esp+24h] [ebp-34h]
  unsigned __int8 *v59; // [esp+28h] [ebp-30h]
  unsigned __int8 *v60; // [esp+28h] [ebp-30h]
  screen_char *schar; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *string[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v7 = term;
  v8 = y;
  v9 = text;
  if ( assert_failed )
    goto LABEL_37;
  v10 = (text == 0) | ((unsigned int)length >> 31);
  assert_failed = v10;
  if ( v10 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 503;
    elinks_internal("assertion text && length >= 0 failed!");
    v7 = term;
    v8 = y;
    if ( assert_failed )
      goto LABEL_37;
    if ( term->width <= x )
      return;
  }
  else if ( term->width <= x )
  {
    return;
  }
  if ( v7->height <= v8 )
    return;
  if ( (*((_BYTE *)v7 + 56) & 2) != 0 )
  {
    string[0] = text;
    assert_failed = (text == 0) | ((unsigned int)length >> 31);
    if ( v10 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 431;
      v49 = v7;
      v42 = v8;
      elinks_internal("assertion text && length >= 0 failed!");
      v8 = v42;
      v7 = v49;
      if ( assert_failed )
        goto LABEL_37;
    }
    if ( length <= 0 )
      return;
    if ( x >= v7->width )
      return;
    v50 = v7;
    v43 = v8;
    v21 = utf8_to_unicode(string, &text[length]);
    v22 = v50;
    v23 = v43;
    v24 = v21;
    if ( v21 == -3 )
      return;
    if ( assert_failed )
      goto LABEL_45;
    screen = v50->screen;
    if ( screen && screen->image )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 39;
      elinks_internal("assertion term && term->screen && term->screen->image failed!");
      v22 = v50;
      v23 = v43;
      if ( assert_failed )
      {
LABEL_45:
        assert_failed = 0;
        v57 = 8;
        schar = 0;
LABEL_46:
        if ( color )
        {
          schar->attr = attr;
          v51 = v22;
          v44 = v23;
          number = get_opt_(v22->spec, "colors")->number;
          set_term_color(schar, color, (color_flags)0, (color_mode)number);
          v23 = v44;
          v22 = v51;
        }
        if ( schar->data == -3 && x - 1 > 0 )
        {
          v54 = v22;
          v47 = v23;
          draw_char_data(v22, x - 1, v23, 0x20u);
          v23 = v47;
          v22 = v54;
        }
        v52 = v22;
        v45 = v23;
        v25 = unicode_to_cell(v24);
        v26 = v52;
        v27 = v45;
        if ( v25 == 2 )
        {
          v28 = x + 1;
          if ( x + 1 >= v52->width )
          {
            schar->data = 32;
          }
          else
          {
            schar->data = v24;
            v28 = x + 2;
            *(_DWORD *)v57 = -3;
            *(_BYTE *)(v57 + 4) = 0;
            v57 += 8;
          }
        }
        else
        {
          schar->data = v24;
          v28 = x + 1;
        }
        if ( v28 < v52->width )
        {
          v29 = (unicode_val_T *)v57;
          v30 = v28;
          while ( 1 )
          {
            v31 = utf8_to_unicode(string, &text[length]);
            if ( v31 == -3 )
              break;
            if ( color )
            {
              *v29 = schar->data;
              v29[1] = *(_DWORD *)&schar->attr;
            }
            if ( unicode_to_cell(v31) == 2 )
            {
              if ( ++v30 >= v52->width )
              {
                *v29 = 32;
              }
              else
              {
                *v29 = v31;
                v29 += 2;
                ++v30;
                *v29 = -3;
                *((_BYTE *)v29 + 4) = 0;
              }
            }
            else
            {
              *v29 = v31;
              ++v30;
            }
            if ( v52->width <= v30 )
              break;
            v29 += 2;
          }
          v26 = v52;
          v27 = v45;
        }
        v33 = v26->screen;
        if ( v27 < v33->dirty_from )
          v33->dirty_from = v27;
        if ( v27 > v33->dirty_to )
          v33->dirty_to = v27;
        return;
      }
    }
    v58 = 0;
    if ( x >= 0 )
    {
      v35 = v22->width - 1;
      if ( x <= v35 )
        v35 = x;
      v58 = v35;
    }
    v36 = 0;
    height = v22->height;
    if ( v23 >= 0 )
    {
      v38 = height - 1;
      if ( v23 <= height - 1 )
        v38 = v23;
      v36 = v22->width * v38;
    }
    schar = &v22->screen->image[v58 + v36];
    v57 = (int)&schar[1];
    goto LABEL_46;
  }
  if ( length <= 0 )
    return;
  v11 = v7->screen;
  if ( v11 && v11->image )
  {
    assert_failed = 0;
    goto LABEL_10;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
  errline = 39;
  v53 = v7;
  v46 = v8;
  elinks_internal("assertion term && term->screen && term->screen->image failed!");
  v8 = v46;
  v7 = v53;
  if ( assert_failed )
  {
LABEL_37:
    assert_failed = 0;
    return;
  }
LABEL_10:
  v55 = 0;
  width = v7->width;
  if ( x >= 0 )
  {
    v12 = v7->width - 1;
    if ( x <= v12 )
      v12 = x;
    v55 = v12;
  }
  v59 = (unsigned __int8 *)v7->height;
  v13 = 0;
  if ( v8 >= 0 )
  {
    v13 = (int)(v59 - 1);
    if ( v8 <= (int)(v59 - 1) )
      v13 = v8;
  }
  v60 = (unsigned __int8 *)v7->screen;
  v14 = (screen_char *)(*(_DWORD *)v60 + 8 * (v55 + v13 * width));
  if ( v14 )
  {
    v15 = length;
    if ( length > width - x )
      v15 = width - x;
    v16 = 0;
    v17 = v15 - 1;
    if ( v17 >= 0 )
      v16 = v17;
    v18 = &v14[v16];
    if ( !color )
    {
      if ( v18 >= v14 )
      {
        v32 = *text;
        if ( *text )
        {
          do
          {
            v14->data = v32;
            if ( v18 < ++v14 )
              break;
            v32 = *++v9;
          }
          while ( *v9 );
          v60 = (unsigned __int8 *)v7->screen;
        }
      }
      goto LABEL_30;
    }
    v18->attr = attr;
    v48 = v7;
    v41 = v8;
    v39 = get_opt_(v7->spec, "colors")->number;
    set_term_color(v18, color, (color_flags)0, (color_mode)v39);
    v8 = v41;
    if ( v18 > v14 )
    {
      v19 = *text;
      if ( !*text )
      {
LABEL_64:
        v20 = 0;
        goto LABEL_29;
      }
      while ( 1 )
      {
        ++v9;
        v18->data = v19;
        v14->data = v19;
        *(_DWORD *)&v14->attr = *(_DWORD *)&v18->attr;
        if ( v18 <= ++v14 )
          break;
        v19 = *v9;
        if ( !*v9 )
          goto LABEL_64;
      }
    }
    v20 = *v9;
LABEL_29:
    v18->data = v20;
    v60 = (unsigned __int8 *)v48->screen;
LABEL_30:
    if ( v8 < *((_DWORD *)v60 + 6) )
      *((_DWORD *)v60 + 6) = v8;
    if ( v8 > *((_DWORD *)v60 + 7) )
      *((_DWORD *)v60 + 7) = v8;
  }
}

//----- (080DC770) --------------------------------------------------------
void __cdecl fix_dwchar_around_box(terminal *term, box *box, int border, int shadow_width, int shadow_height)
{
  int x; // ecx
  int v6; // edi
  int v7; // esi
  int y; // ecx
  int v9; // edi
  terminal_screen *screen; // eax
  int v11; // edx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // edx
  screen_char *v16; // esi
  int v17; // edi
  int width; // edx
  int v19; // eax
  int v20; // edi
  box *v21; // esi
  int v22; // ecx
  int v23; // esi
  screen_char *v24; // ecx
  int v25; // edx
  int v26; // eax
  int v27; // ecx
  int v28; // edi
  int v29; // esi
  terminal_screen *v30; // eax
  int v31; // edx
  int v32; // eax
  int v33; // edi
  int v34; // edx
  bool v35; // sf
  int v36; // edi
  int v37; // ecx
  int v38; // edx
  screen_char *v39; // eax
  int j; // esi
  int v41; // esi
  int v42; // edx
  screen_char *v43; // esi
  int i; // edi
  terminal_screen *v45; // eax
  int v46; // eax
  int v47; // edx
  int v48; // ecx
  int v49; // edi
  int v50; // esi
  int v51; // ecx
  terminal_screen *v52; // eax
  int v53; // esi
  int v54; // eax
  int v55; // edx
  int v56; // esi
  int v57; // ecx
  int v58; // eax
  int v59; // edx
  int v60; // [esp+14h] [ebp-24h]
  int v61; // [esp+14h] [ebp-24h]
  int v62; // [esp+14h] [ebp-24h]
  int v63; // [esp+14h] [ebp-24h]
  int height; // [esp+18h] [ebp-20h]

  if ( (*((_BYTE *)term + 56) & 2) == 0 )
    return;
  x = box->x;
  v6 = box->x - 1;
  v7 = v6 - border;
  if ( v6 - border <= 0 )
  {
LABEL_33:
    width = term->width;
    v20 = shadow_width - border + v6;
    v19 = width;
    if ( v20 > 0 )
      goto LABEL_34;
LABEL_21:
    v21 = box;
    v19 = width;
    v22 = box->width + border + x;
    if ( v22 >= width )
      goto LABEL_36;
    goto LABEL_22;
  }
  y = box->y;
  v9 = box->height + 2 * border;
  if ( assert_failed )
    goto LABEL_86;
  screen = term->screen;
  if ( !screen || !screen->image )
  {
    v60 = box->y;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    y = v60;
    if ( !assert_failed )
      goto LABEL_7;
LABEL_86:
    assert_failed = 0;
    v16 = 0;
    goto LABEL_14;
  }
  assert_failed = 0;
LABEL_7:
  v11 = term->width;
  height = term->height;
  v12 = 0;
  v13 = y - border;
  if ( v13 >= 0 )
  {
    v14 = height - 1;
    if ( v13 <= height - 1 )
      v14 = v13;
    v12 = v11 * v14;
  }
  v15 = v11 - 1;
  if ( v7 > v15 )
    v7 = v15;
  v16 = &term->screen->image[v12 + v7];
LABEL_14:
  if ( !v9 )
  {
    x = box->x;
    v6 = box->x - 1;
    goto LABEL_33;
  }
  v17 = v9 - 1;
  while ( unicode_to_cell(v16->data) != 2 )
  {
    width = term->width;
    v19 = width;
    if ( !v17 )
      goto LABEL_20;
LABEL_17:
    v16 += width;
    --v17;
  }
  v16->data = 32;
  width = term->width;
  v19 = width;
  if ( v17 )
    goto LABEL_17;
LABEL_20:
  x = box->x;
  v20 = shadow_width - border + box->x - 1;
  if ( v20 <= 0 )
    goto LABEL_21;
LABEL_34:
  if ( v20 >= width )
    goto LABEL_35;
  v41 = box->y;
  v42 = box->height;
  if ( assert_failed )
  {
LABEL_56:
    assert_failed = 0;
    v43 = 0;
  }
  else
  {
    v52 = term->screen;
    if ( v52 && v52->image )
    {
      assert_failed = 0;
    }
    else
    {
      v62 = box->height;
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 39;
      elinks_internal("assertion term && term->screen && term->screen->image failed!");
      v42 = v62;
      if ( assert_failed )
        goto LABEL_56;
    }
    v53 = v42 + v41;
    v54 = 0;
    v55 = term->width;
    v35 = border + v53 < 0;
    v56 = border + v53;
    v57 = term->height;
    if ( !v35 )
    {
      v58 = v57 - 1;
      if ( v56 <= v57 - 1 )
        v58 = v56;
      v54 = v55 * v58;
    }
    v59 = v55 - 1;
    if ( v20 <= v59 )
      v59 = v20;
    v43 = &term->screen->image[v54 + v59];
  }
  if ( shadow_height )
  {
    for ( i = shadow_height - 1; ; --i )
    {
      if ( unicode_to_cell(v43->data) == 2 )
      {
        v43->data = 32;
        v19 = term->width;
        if ( !i )
        {
LABEL_63:
          x = box->x;
          goto LABEL_35;
        }
      }
      else
      {
        v19 = term->width;
        if ( !i )
          goto LABEL_63;
      }
      v43 += v19;
    }
  }
  v19 = term->width;
  x = box->x;
LABEL_35:
  v21 = box;
  v22 = box->width + border + x;
  if ( v22 >= v19 )
  {
LABEL_36:
    v27 = shadow_width + v22;
    if ( v27 < v19 )
      goto LABEL_37;
    return;
  }
LABEL_22:
  v23 = v21->y;
  if ( assert_failed )
  {
LABEL_23:
    assert_failed = 0;
    v24 = 0;
  }
  else
  {
    v45 = term->screen;
    if ( v45 && v45->image )
    {
      assert_failed = 0;
    }
    else
    {
      v63 = v22;
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
      errline = 39;
      elinks_internal("assertion term && term->screen && term->screen->image failed!");
      v22 = v63;
      if ( assert_failed )
        goto LABEL_23;
    }
    v46 = 0;
    v47 = term->width;
    if ( v22 >= 0 )
    {
      v46 = v47 - 1;
      if ( v22 <= v47 - 1 )
        v46 = v22;
    }
    v48 = 0;
    v49 = term->height;
    v50 = v23 - border;
    if ( v50 >= 0 )
    {
      v51 = v49 - 1;
      if ( v50 <= v49 - 1 )
        v51 = v50;
      v48 = v47 * v51;
    }
    v24 = &term->screen->image[v46 + v48];
  }
  if ( !shadow_height )
  {
    v19 = term->width;
    v22 = border + box->x + box->width;
    goto LABEL_36;
  }
  v25 = shadow_height - 1;
  while ( 2 )
  {
    if ( v24->data != -3 )
    {
      v26 = term->width;
      if ( !v25 )
        break;
      goto LABEL_27;
    }
    v24->data = 32;
    v26 = term->width;
    if ( v25 )
    {
LABEL_27:
      v24 += v26;
      --v25;
      continue;
    }
    break;
  }
  v27 = shadow_width + border + box->x + box->width;
  if ( v27 >= v26 )
    return;
LABEL_37:
  v28 = box->y;
  v29 = box->height + 2 * border;
  if ( assert_failed )
  {
LABEL_88:
    assert_failed = 0;
    v39 = 0;
    goto LABEL_49;
  }
  v30 = term->screen;
  if ( !v30 || !v30->image )
  {
    v61 = v27;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/draw.c";
    errline = 39;
    elinks_internal("assertion term && term->screen && term->screen->image failed!");
    v27 = v61;
    if ( !assert_failed )
      goto LABEL_41;
    goto LABEL_88;
  }
  assert_failed = 0;
LABEL_41:
  v31 = term->width;
  v32 = 0;
  if ( v27 >= 0 )
  {
    v32 = v31 - 1;
    if ( v27 <= v31 - 1 )
      v32 = v27;
  }
  v33 = v28 - border;
  v34 = 0;
  v35 = shadow_height + v33 < 0;
  v36 = shadow_height + v33;
  v37 = term->height;
  if ( !v35 )
  {
    v38 = v37 - 1;
    if ( v36 <= v37 - 1 )
      v38 = v36;
    v34 = term->width * v38;
  }
  v39 = &term->screen->image[v34 + v32];
LABEL_49:
  if ( v29 )
  {
    for ( j = v29 - 1; ; --j )
    {
      if ( v39->data == -3 )
        v39->data = 32;
      if ( !j )
        break;
      v39 += term->width;
    }
  }
}

//----- (080DCC50) --------------------------------------------------------
void __cdecl term_send_event(terminal *term, term_event *ev)
{
  int v2; // eax
  int y; // edi
  int x; // edx
  window *prev; // edi
  bool v6; // zf
  void (__cdecl **next)(void *, term_event *); // eax
  unsigned __int8 *v8; // eax
  list_head_elinks *i; // edi
  int v10; // [esp+18h] [ebp-20h]
  list_head_elinks *j; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_21;
  assert_failed = term == 0 || ev == 0;
  if ( term == 0 || ev == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
    errline = 68;
    elinks_internal("assertion ev && term failed!");
    if ( assert_failed )
      goto LABEL_21;
    if ( ev->ev > (unsigned int)EVENT_ABORT )
      return;
  }
  else if ( ev->ev > (unsigned int)EVENT_ABORT )
  {
    return;
  }
  v2 = 1 << ev->ev;
  if ( (v2 & 0x26) != 0 )
  {
    v6 = term->windows.next != &term->windows;
    assert_failed = term->windows.next == &term->windows;
    if ( v6
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c",
          errline = 121,
          elinks_internal("assertion !list_empty(term->windows) failed!"),
          !assert_failed) )
    {
      next = (void (__cdecl **)(void *, term_event *))term->windows.next;
      if ( next[2] != (void (__cdecl *)(void *, term_event *))1
        || (next = (void (__cdecl **)(void *, term_event *))get_tab_by_number(term, term->current_tab), !assert_failed)
        && ((assert_failed = next == 0, next)
         || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c",
             errline = 129,
             elinks_internal("assertion win != NULL failed: No tab to send the event to!"),
             next = 0,
             !assert_failed)) )
      {
        next[3](next, ev);
        return;
      }
    }
LABEL_21:
    assert_failed = 0;
    return;
  }
  if ( (v2 & 0x11) != 0 )
  {
    y = ev->info.mouse.y;
    x = ev->info.mouse.x;
    if ( y < 0 || x < 0 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
      errline = 79;
      v10 = x;
      v8 = gettext("Bad terminal size: %d, %d");
      elinks_error(v8, v10, y);
      return;
    }
    resize_screen(term, x, ev->info.mouse.y);
    erase_screen(term);
  }
  else if ( (v2 & 8) == 0 )
  {
    return;
  }
  if ( term->screen->image )
  {
    clear_terminal(term);
    term->redrawing = TREDRAW_DELAYED;
    if ( ev->ev == EVENT_RESIZE )
    {
      for ( i = (list_head_elinks *)term->windows.prev; &term->windows != i; i = (list_head_elinks *)i->prev )
        ((void (__cdecl *)(list_head_elinks *, term_event *))i[1].prev)(i, ev);
    }
    else
    {
      prev = (window *)term->windows.prev;
      for ( j = &term->windows; prev != (window *)j; prev = prev->prev )
      {
        while ( prev->type && get_tab_by_number(prev->term, prev->term->current_tab) != prev )
        {
          prev = prev->prev;
          if ( prev == (window *)j )
            goto LABEL_17;
        }
        prev->handler(prev, ev);
      }
    }
LABEL_17:
    term->redrawing = TREDRAW_READY;
  }
}

//----- (080DCF00) --------------------------------------------------------
void __usercall term_send_ucs(terminal *term@<eax>, unicode_val_T u@<edx>, term_event_modifier_T modifier@<ecx>)
{
  term_event ev; // [esp+10h] [ebp-18h] BYREF

  ev.ev = EVENT_KBD;
  ev.info.mouse.x = u;
  *(_QWORD *)&ev.info.size.height = (unsigned int)modifier;
  term_send_event(term, &ev);
}

//----- (080DCF30) --------------------------------------------------------
void __cdecl in_term(terminal *term)
{
  unsigned int v1; // esi
  char *interlink; // ebx
  size_t v3; // eax
  size_t v4; // esi
  int v5; // eax
  int fdin; // edi
  ssize_t v7; // eax
  int *v8; // eax
  int *v9; // edi
  char *v10; // eax
  int v11; // ebx
  char *v12; // esi
  unsigned __int8 *v13; // eax
  int v14; // edx
  unsigned int v15; // edx
  term_event_type v16; // esi
  unsigned __int8 *v17; // eax
  int v18; // edx
  int v19; // eax
  size_t v20; // eax
  terminal_interlink *v21; // esi
  term_event_type v22; // eax
  char *v23; // esi
  unsigned int v24; // edx
  int v25; // ecx
  int v26; // edx
  int v27; // edi
  unsigned int v28; // edx
  int len; // eax
  char v30; // al
  char *v31; // edx
  int v32; // eax
  int v33; // esi
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v35; // eax
  unsigned int v36; // edx
  unsigned __int8 *cwd; // edi
  __int16 *v38; // esi
  int v39; // eax
  unsigned __int8 *v40; // edi
  __int16 *v41; // esi
  int v42; // edx
  int v43; // eax
  unicode_val_T v44; // eax
  int v45; // ecx
  unsigned int v46; // edx
  option_elinks *opt_rec; // eax
  int terminal_codepage; // eax
  char v49; // dl
  char v50; // al
  char v51; // dl
  int v52; // eax
  int v53; // ebx
  unsigned __int8 *v54; // eax
  unsigned __int8 *v55; // eax
  unsigned int i; // eax
  __int16 v57; // ax
  int v58; // [esp+2Ch] [ebp-8Ch]
  unsigned int v59; // [esp+30h] [ebp-88h]
  term_event_modifier_T modifier; // [esp+50h] [ebp-68h]
  char *buf; // [esp+54h] [ebp-64h]
  bool bufa; // [esp+54h] [ebp-64h]
  void *bufb; // [esp+54h] [ebp-64h]
  terminal_info *iq; // [esp+5Ch] [ebp-5Ch]
  term_event ev; // [esp+60h] [ebp-58h] BYREF
  unsigned __int8 name_[42]; // [esp+72h] [ebp-46h] BYREF
  unsigned int v67; // [esp+9Ch] [ebp-1Ch]

  v1 = 256;
  v67 = __readgsdword(0x14u);
  interlink = (char *)term->interlink;
  v3 = 284;
  if ( interlink )
  {
    v4 = *((_DWORD *)interlink + 1);
    if ( v4 )
    {
      v5 = *(_DWORD *)interlink;
      if ( (int)(v4 - *(_DWORD *)interlink) <= 256 )
        goto LABEL_8;
    }
    else
    {
      v5 = *(_DWORD *)interlink;
    }
    v1 = (v5 + 256) & 0xFFFFFF00;
    v3 = v1 + 28;
  }
  interlink = (char *)mem_realloc(term->interlink, v3);
  if ( !interlink )
  {
LABEL_92:
    destroy_terminal(term);
    return;
  }
  if ( !term->interlink )
  {
    for ( i = 0; i < 0x1C; i += 4 )
      *(_DWORD *)&interlink[i] = 0;
  }
  term->interlink = (terminal_interlink *)interlink;
  v5 = *(_DWORD *)interlink;
  v4 = v1 - *(_DWORD *)interlink;
  *((_DWORD *)interlink + 1) = v4;
LABEL_8:
  iq = (terminal_info *)(interlink + 24);
  buf = &interlink[v5 + 24];
  fdin = term->fdin;
  while ( 1 )
  {
    v7 = read(fdin, buf, v4);
    if ( v7 != -1 )
      break;
    v8 = __errno_location();
    if ( *v8 != 4 )
    {
      v9 = v8;
      if ( *v8 != 104 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
        errline = 483;
        v10 = strerror(*v8);
        v11 = *v9;
        v12 = v10;
        v13 = gettext("Could not read event: %d (%s)");
        elinks_error(v13, v11, v12);
      }
      goto LABEL_13;
    }
  }
  if ( v7 <= 0 )
  {
LABEL_13:
    destroy_terminal(term);
    return;
  }
  v14 = *(_DWORD *)interlink;
  *((_DWORD *)interlink + 1) -= v7;
  v15 = v7 + v14;
  *(_DWORD *)interlink = v15;
  if ( v15 <= 0xF )
    return;
  while ( 2 )
  {
    v21 = term->interlink;
    v22 = iq->event.ev;
    switch ( iq->event.ev )
    {
      case EVENT_INIT:
        if ( v21->qlen <= 0x13Fu || v21->qlen < (unsigned int)(*((_DWORD *)interlink + 83) + 320) )
          return;
        v30 = interlink[40];
        interlink[71] = 0;
        if ( !v30 )
          goto LABEL_88;
        v31 = interlink + 24;
        while ( (unsigned __int8)(v30 - 97) <= 0x19u
             || (unsigned __int8)(v30 - 65) <= 0x19u
             || (unsigned __int8)(v30 - 48) <= 9u
             || v30 == 95
             || v30 == 45 )
        {
          v30 = v31[17];
          ++v31;
          if ( !v30 )
          {
LABEL_88:
            __snprintf_chk(name_, 42, 1, 42, "terminal.%s", interlink + 40);
            --term->spec->object.refcount;
            opt_rec = get_opt_rec(config_options, name_);
            term->spec = opt_rec;
            ++opt_rec->object.refcount;
            terminal_codepage = get_terminal_codepage(term);
            v49 = 2 * (is_cp_utf8(terminal_codepage) & 1);
            v50 = v49 | *((_BYTE *)term + 56) & 0xFD;
            *((_BYTE *)term + 56) = v50;
            if ( (v49 & 2) != 0 )
              goto LABEL_89;
            if ( get_opt_(term->spec, "utf_8_io")->number )
            {
              v50 = *((_BYTE *)term + 56);
LABEL_89:
              v51 = 1;
            }
            else
            {
              v51 = 0;
              v50 = *((_BYTE *)term + 56);
            }
            *((_BYTE *)term + 56) = (4 * v51) | v50 & 0xFB;
            goto LABEL_56;
          }
        }
        v32 = get_terminal_codepage(term);
        v33 = v32;
        if ( v32 != current_charset )
        {
          cp_mime_name = get_cp_mime_name(v32);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v33;
        }
        v35 = gettext(&byte_8124F48);
        usrerror(v35);
LABEL_56:
        v36 = 256;
        cwd = term->cwd;
        v38 = (__int16 *)(interlink + 72);
        if ( ((unsigned int)term->cwd & 1) != 0 )
        {
          LOWORD(v36) = 255;
          term->cwd[0] = interlink[72];
          cwd = &term->cwd[1];
          v38 = (__int16 *)(interlink + 73);
        }
        if ( ((unsigned __int8)cwd & 2) != 0 )
        {
          v57 = *v38;
          v36 -= 2;
          ++v38;
          *(_WORD *)cwd = v57;
          cwd += 2;
        }
        v39 = 0;
        qmemcpy(cwd, v38, 4 * (v36 >> 2));
        v41 = &v38[2 * (v36 >> 2)];
        v40 = &cwd[4 * (v36 >> 2)];
        if ( (v36 & 2) != 0 )
        {
          *(_WORD *)v40 = *v41;
          v39 = 1;
        }
        if ( (v36 & 1) != 0 )
          v40[v39 * 2] = v41[v39];
        term->cwd[255] = 0;
        term->environment = *((_DWORD *)interlink + 82);
        v42 = *((_DWORD *)interlink + 7);
        *(_QWORD *)&ev.info.size.height = *((unsigned int *)interlink + 8);
        ev.info.mouse.x = v42;
        ev.ev = EVENT_INIT;
        term_send_event(term, &ev);
        if ( decode_session_info(term, iq) )
        {
          iq->event.ev = EVENT_REDRAW;
          v23 = interlink + 24;
          v22 = EVENT_REDRAW;
LABEL_26:
          v24 = *((_DWORD *)interlink + 8);
          v25 = *((_DWORD *)interlink + 7);
          ev.ev = v22;
          *(_QWORD *)&ev.info.size.height = v24;
          ev.info.mouse.x = v25;
          term_send_event(term, &ev);
          if ( v23 )
          {
            v18 = *((_DWORD *)v23 + 77) + 320;
            if ( *((_DWORD *)v23 + 77) == -320 )
              return;
          }
          else
          {
LABEL_21:
            v18 = 16;
          }
          v19 = *(_DWORD *)interlink;
          *((_DWORD *)interlink + 1) += v18;
          v20 = v19 - v18;
          *(_DWORD *)interlink = v20;
          if ( !v20 )
            return;
          memmove(iq, &interlink[v18 + 24], v20);
          if ( *(_DWORD *)interlink <= 0xFu )
            return;
          continue;
        }
        destroy_terminal(term);
        if ( program_0.terminate )
        {
          v52 = get_terminal_codepage(term);
          v53 = v52;
          if ( v52 != current_charset )
          {
            v54 = get_cp_mime_name(v52);
            bind_textdomain_codeset("elinks", v54);
            current_charset = v53;
          }
          v55 = gettext(&byte_81338CA);
          usrerror(v55);
          program_0.retval = RET_FATAL;
        }
        return;
      case EVENT_KBD:
        v27 = *((_DWORD *)interlink + 7);
        if ( v27 >= 256 )
          v27 = -*((_DWORD *)interlink + 7);
        modifier = *((_DWORD *)interlink + 8);
        reset_timer();
        if ( modifier == KBD_MOD_CTRL && (v27 == 76 || v27 == 108) )
        {
          redraw_terminal_cls(term);
          goto LABEL_21;
        }
        if ( v27 == -512 )
          goto LABEL_92;
        bufa = (*((_BYTE *)term + 56) & 4) != 0;
        if ( !v21->utf8.len )
          goto LABEL_67;
        if ( (unsigned int)(v27 - 128) <= 0x3F && (*((_BYTE *)term + 56) & 4) != 0 )
        {
          v28 = (v21->utf8.ucs << 6) | v27 & 0x3F;
          len = v21->utf8.len;
          v21->utf8.ucs = v28;
          v21->utf8.len = --len;
          if ( !len )
          {
            if ( v28 < v21->utf8.min || (v28 & 0xFFFFF800) == 55296 )
              v28 = 65533;
            term_send_ucs(term, v28, term->interlink->utf8.modifier);
          }
        }
        else
        {
          v21->utf8.len = 0;
          term_send_ucs(term, 0xFFFDu, term->interlink->utf8.modifier);
LABEL_67:
          if ( v27 > 127 && (bufa & 0x3F) != 0 )
          {
            if ( (v27 & 0xC0) == 192 && (v27 & 0xFE) != 254 )
            {
              v45 = 0;
              v46 = 128;
              if ( (v27 & 0x80u) != 0 )
              {
                do
                {
                  v46 >>= 1;
                  ++v45;
                }
                while ( (v27 & v46) != 0 );
              }
              if ( !assert_failed )
              {
                bufb = (void *)(v45 - 2);
                assert_failed = (unsigned int)(v45 - 2) > 4;
                if ( (unsigned int)(v45 - 2) <= 4
                  || (v59 = v46,
                      v58 = v45,
                      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c",
                      errline = 423,
                      elinks_internal("assertion len >= 2 && len <= 6 failed!"),
                      v46 = v59,
                      v45 = v58,
                      !assert_failed) )
                {
                  v21->utf8.len = v45 - 1;
                  v21->utf8.ucs = v27 & (v46 - 1);
                  v21->utf8.min = min_8206[(_DWORD)bufb];
                  v21->utf8.modifier = modifier;
                  goto LABEL_21;
                }
              }
              assert_failed = 0;
            }
            term_send_ucs(term, 0xFFFDu, modifier);
          }
          else if ( v27 < 0 || (bufa & 0x3F) != 0 )
          {
            ev.info.mouse.x = v27;
            ev.ev = EVENT_KBD;
            *(_QWORD *)&ev.info.size.height = (unsigned int)modifier;
            term_send_event(term, &ev);
          }
          else
          {
            v43 = get_terminal_codepage(term);
            v44 = cp2u(v43, v27);
            term_send_ucs(term, v44, modifier);
          }
        }
        goto LABEL_21;
      case EVENT_MOUSE:
        reset_timer();
        ev.ev = iq->event.ev;
        ev.info.mouse.x = *((_DWORD *)interlink + 7);
        v26 = *((_DWORD *)interlink + 8);
        *(_QWORD *)&ev.info.size.height = *((_QWORD *)interlink + 4);
        if ( (*(_BYTE *)(&ev.info.size + 1) & 0x20) != 0
          && v26 == term->prev_mouse_event.y
          && ((term->prev_mouse_event.button ^ ev.info.mouse.button) & 0xFFFFFFDF) == 0 )
        {
          term->prev_mouse_event.x = 0;
          term->prev_mouse_event.y = 0;
          term->prev_mouse_event.button = 0;
        }
        else
        {
          term->prev_mouse_event = (term_event_mouse)ev.info;
          term_send_event(term, &ev);
        }
        goto LABEL_21;
      case EVENT_REDRAW:
      case EVENT_RESIZE:
        v23 = 0;
        goto LABEL_26;
      case EVENT_ABORT:
        goto LABEL_92;
      default:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/event.c";
        errline = 443;
        v16 = iq->event.ev;
        v17 = gettext("Bad event %d");
        elinks_error(v17, v16);
        goto LABEL_21;
    }
  }
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 810D4D0: using guessed type int min_8206[12];

//----- (080DD800) --------------------------------------------------------
ssize_t __cdecl hard_read(int fd, unsigned __int8 *data, size_t datalen)
{
  unsigned __int8 *v3; // esi
  size_t v5; // ebx
  ssize_t v6; // eax

  v3 = data;
  if ( assert_failed
    || (assert_failed = data == 0, !data)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c",
        errline = 132,
        elinks_internal("assertion data && datalen >= 0 failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return -1;
  }
  else
  {
    v5 = datalen;
    if ( datalen )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v6 = read(fd, v3, v5);
          if ( v6 != -1 )
            break;
          if ( *__errno_location() != 4 )
            return -1;
        }
        if ( v6 <= 0 )
          break;
        v5 -= v6;
        if ( !v5 )
          return datalen - v5;
        v3 += v6;
      }
      if ( v6 )
        return -1;
    }
    else
    {
      v5 = 0;
    }
    return datalen - v5;
  }
}

//----- (080DD8E0) --------------------------------------------------------
ssize_t __cdecl hard_write(int fd, unsigned __int8 *data, size_t datalen)
{
  unsigned __int8 *v3; // esi
  size_t v5; // ebx
  ssize_t v6; // eax

  v3 = data;
  if ( assert_failed
    || (assert_failed = data == 0, !data)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/hardio.c",
        errline = 102,
        elinks_internal("assertion data && datalen >= 0 failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return -1;
  }
  else
  {
    v5 = datalen;
    if ( datalen )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v6 = write(fd, v3, v5);
          if ( v6 != -1 )
            break;
          if ( *__errno_location() != 4 )
            return -1;
        }
        if ( v6 <= 0 )
          break;
        v5 -= v6;
        if ( !v5 )
          return datalen - v5;
        v3 += v6;
      }
      if ( v6 )
        return -1;
    }
    else
    {
      v5 = 0;
    }
    return datalen - v5;
  }
}

//----- (080DD9C0) --------------------------------------------------------
int is_blocked()
{
  int result; // eax

  result = 0;
  if ( ditrm )
    return *((_BYTE *)ditrm + 116) & 1;
  return result;
}

//----- (080DD9E0) --------------------------------------------------------
void __usercall send_done_sequence(int h@<eax>, int altscreen@<edx>)
{
  hard_write(h, "\x1B[2J", 4u);
  send_mouse_done_sequence(h);
  if ( altscreen )
    hard_write(h, "\x1B[?47l", 6u);
  hard_write(h, "\x1B8\r \b", 5u);
}

//----- (080DDA50) --------------------------------------------------------
void __usercall unhandle_itrm_stdin(itrm *itrm@<eax>)
{
  itrm *v1; // [esp+2Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = (unsigned int)itrm->in.std >> 31) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c",
        errline = 1237,
        v1 = itrm,
        elinks_internal("assertion itrm->in.std >= 0 failed!"),
        itrm = v1,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    set_handlers(itrm->in.std, 0, 0, (select_handler_T)free_itrm, itrm);
  }
}

//----- (080DDAE0) --------------------------------------------------------
void block_itrm()
{
  if ( ditrm )
  {
    *((_BYTE *)ditrm + 116) |= 1u;
    block_stdin();
    kill_timer(&ditrm->timer);
    ditrm->in.queue.len = 0;
    unhandle_terminal_resize(ditrm->in.ctl);
    send_done_sequence(ditrm->out.std, (*((_BYTE *)ditrm + 116) & 2) != 0);
    tcsetattr(ditrm->in.ctl, 0, &ditrm->t);
    unhandle_itrm_stdin(ditrm);
    suspend_mouse(ditrm->mouse_h);
  }
}

//----- (080DDB80) --------------------------------------------------------
void __usercall handle_itrm_stdin(itrm *itrm@<eax>)
{
  itrm *v1; // [esp+2Ch] [ebp-Ch]

  if ( assert_failed
    || (assert_failed = (unsigned int)itrm->in.std >> 31) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c",
        errline = 1224,
        v1 = itrm,
        elinks_internal("assertion itrm->in.std >= 0 failed!"),
        itrm = v1,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    set_handlers(itrm->in.std, (select_handler_T)in_kbd, 0, (select_handler_T)free_itrm, itrm);
  }
}

//----- (080DDC10) --------------------------------------------------------
void __usercall set_kbd_interlink_event(interlink_event *ev@<eax>, int key@<edx>, term_event_modifier_T modifier@<ecx>)
{
  if ( key <= -256 )
    key = -key;
  ev->info.mouse.button = 0;
  ev->ev = EVENT_KBD;
  *(_QWORD *)&ev->info.mouse.x = __PAIR64__(modifier, key);
}

//----- (080DDC40) --------------------------------------------------------
void __usercall send_init_sequence(int h@<eax>, int altscreen@<edx>)
{
  hard_write(h, "\x1B)0\x1B7", 5u);
  if ( altscreen )
    hard_write(h, "\x1B[?47h", 6u);
  send_mouse_init_sequence(h);
}

//----- (080DDCA0) --------------------------------------------------------
void __cdecl get_terminal_name(unsigned __int8 *name)
{
  char *v1; // eax
  int v2; // ecx
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // edi
  unsigned int v5; // eax
  unsigned __int8 *v6; // edx
  unsigned __int8 v7; // dl
  int v8; // esi
  int v9; // ecx

  v1 = getenv("TERM");
  v2 = 32;
  v3 = name;
  v4 = (unsigned __int8 *)v1;
  if ( ((unsigned __int8)name & 1) != 0 )
  {
    v3 = name + 1;
    LOBYTE(v2) = 31;
    *name = 0;
    if ( (((_BYTE)name + 1) & 2) == 0 )
      goto LABEL_3;
LABEL_21:
    *(_WORD *)v3 = 0;
    v2 -= 2;
    v3 += 2;
    goto LABEL_3;
  }
  if ( ((unsigned __int8)name & 2) != 0 )
    goto LABEL_21;
LABEL_3:
  v5 = 0;
  do
  {
    *(_DWORD *)&v3[v5] = 0;
    v5 += 4;
  }
  while ( v5 < (v2 & 0xFFFFFFFC) );
  v6 = &v3[v5];
  if ( (v2 & 2) != 0 )
  {
    *(_WORD *)v6 = 0;
    v6 += 2;
  }
  if ( (v2 & 1) != 0 )
    *v6 = 0;
  if ( v4 )
  {
    v7 = *v4;
    if ( *v4 )
    {
      v8 = 0;
      v9 = 0;
      do
      {
        if ( (unsigned __int8)(v7 - 97) > 0x19u
          && (unsigned __int8)(v7 - 65) > 0x19u
          && (unsigned __int8)(v7 - 48) > 9u
          && v7 != 95 )
        {
          v7 = 45;
        }
        ++v9;
        name[v8] = v7;
        v8 = v9;
        v7 = v4[v9];
      }
      while ( v9 <= 30 && v7 );
    }
  }
}

//----- (080DDD80) --------------------------------------------------------
void __cdecl free_itrm(itrm *itrm)
{
  char v1; // al
  unsigned __int8 *orig_title; // edx
  bool v3; // zf
  int std; // eax
  int cp_index; // eax
  unsigned __int8 title[32]; // [esp+2Ch] [ebp-2Ch] BYREF
  unsigned int v7; // [esp+4Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  if ( !itrm )
    return;
  v1 = *((_BYTE *)itrm + 116);
  if ( (v1 & 8) == 0 )
  {
    orig_title = itrm->orig_title;
    if ( orig_title && *orig_title )
    {
      set_window_title(itrm->orig_title, itrm->title_codepage);
    }
    else if ( (v1 & 4) != 0 )
    {
      get_terminal_name(title);
      if ( title[0] )
      {
        cp_index = get_cp_index("US-ASCII");
        set_window_title(title, cp_index);
      }
    }
    unhandle_terminal_resize(itrm->in.ctl);
    disable_mouse();
    send_done_sequence(itrm->out.std, (*((_BYTE *)itrm + 116) & 2) != 0);
    tcsetattr(itrm->in.ctl, 0, &itrm->t);
  }
  if ( itrm->orig_title )
    mem_free(itrm->orig_title);
  v3 = (*((_BYTE *)itrm + 116) & 8) == 0;
  itrm->orig_title = 0;
  if ( v3 )
  {
    std = itrm->in.std;
    goto LABEL_11;
  }
  std = itrm->in.std;
  if ( itrm->in.std >= 0 )
LABEL_11:
    set_handlers(std, 0, 0, 0, 0);
  set_handlers(itrm->in.sock, 0, 0, 0, 0);
  set_handlers(itrm->out.std, 0, 0, 0, 0);
  set_handlers(itrm->out.sock, 0, 0, 0, 0);
  kill_timer(&itrm->timer);
  if ( itrm == ditrm )
    ditrm = 0;
  if ( itrm->out.queue.data )
    mem_free(itrm->out.queue.data);
  if ( itrm->in.queue.data )
    mem_free(itrm->in.queue.data);
  mem_free(itrm);
}

//----- (080DDF80) --------------------------------------------------------
void free_all_itrms()
{
  if ( ditrm )
    free_itrm(ditrm);
}

//----- (080DDFA0) --------------------------------------------------------
void __cdecl itrm_queue_event(itrm *itrm, unsigned __int8 *data, int len)
{
  unsigned __int8 *v3; // edx
  int v4; // edi
  size_t v5; // esi
  unsigned __int8 *v6; // eax
  void (*handler)(void *); // eax
  int v8; // eax
  ssize_t v9; // eax
  unsigned __int8 *buf; // [esp+2Ch] [ebp-1Ch]

  v3 = data;
  if ( len )
  {
    if ( itrm->out.queue.len || (v8 = can_write(itrm->out.sock), v3 = data, !v8) )
    {
      v4 = 0;
    }
    else
    {
      v9 = write(itrm->out.sock, data, len);
      v3 = data;
      v4 = v9;
      if ( v9 <= 0 )
      {
        register_bottom_half_do((select_handler_T)free_itrm, itrm);
        return;
      }
    }
    if ( v4 < len )
    {
      v5 = len - v4;
      buf = v3;
      v6 = (unsigned __int8 *)mem_realloc(itrm->out.queue.data, len - v4 + itrm->out.queue.len);
      if ( v6 )
      {
        itrm->out.queue.data = v6;
        memcpy(&v6[itrm->out.queue.len], &buf[v4], v5);
        itrm->out.queue.len += v5;
        handler = get_handler(itrm->out.sock, SELECT_HANDLER_READ);
        set_handlers(itrm->out.sock, handler, (select_handler_T)itrm_queue_write, (select_handler_T)free_itrm, itrm);
      }
      else
      {
        free_itrm(itrm);
      }
    }
  }
}

//----- (080DE0D0) --------------------------------------------------------
void __cdecl itrm_queue_write(itrm *itrm)
{
  int len; // esi
  ssize_t v2; // eax
  int v3; // edx
  bool v4; // zf
  select_handler_T handler; // edi
  void (*v6)(void *); // esi
  void (*v7)(void *); // eax
  ssize_t v8; // [esp+2Ch] [ebp-1Ch]

  len = itrm->out.queue.len;
  if ( len >= 128 )
    len = 128;
  if ( assert_failed
    || (assert_failed = len == 0, !len)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c",
        errline = 85,
        elinks_internal("assertion qlen failed: event queue empty"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    v2 = write(itrm->out.sock, itrm->out.queue.data, len);
    if ( v2 <= 0 )
    {
      if ( v2 )
        free_itrm(itrm);
    }
    else
    {
      v3 = itrm->out.queue.len - v2;
      v4 = itrm->out.queue.len == v2;
      itrm->out.queue.len = v3;
      if ( v4 )
      {
        handler = get_handler(itrm->out.sock, SELECT_HANDLER_DATA);
        v6 = get_handler(itrm->out.sock, SELECT_HANDLER_ERROR);
        v7 = get_handler(itrm->out.sock, SELECT_HANDLER_READ);
        set_handlers(itrm->out.sock, v7, 0, v6, handler);
      }
      else
      {
        if ( !assert_failed )
        {
          assert_failed = v3 <= 0;
          if ( v3 <= 0 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
            errline = 103;
            v8 = v2;
            elinks_internal("assertion itrm->out.queue.len > 0 failed!");
            v3 = itrm->out.queue.len;
            v2 = v8;
          }
          else
          {
            v3 = itrm->out.queue.len;
          }
        }
        memmove(itrm->out.queue.data, &itrm->out.queue.data[v2], v3);
      }
    }
  }
}

//----- (080DE280) --------------------------------------------------------
int __usercall setraw@<eax>(itrm *itrm@<eax>, int save_orig@<edx>)
{
  int result; // eax
  int ctl; // eax
  int v5; // edx
  termios t; // [esp+20h] [ebp-58h] BYREF
  unsigned int v8; // [esp+5Ch] [ebp-1Ch]

  v8 = __readgsdword(0x14u);
  memset(&t, 0, sizeof(t));
  if ( tcgetattr(itrm->in.ctl, &t) )
    return -1;
  if ( save_orig )
    itrm->t = t;
  itrm->verase = t.c_cc[2] ? t.c_cc[2] : -1;
  elinks_cfmakeraw(&t);
  ctl = itrm->in.ctl;
  t.c_lflag |= 0x101u;
  t.c_oflag |= 1u;
  v5 = tcsetattr(ctl, 0, &t);
  result = 0;
  if ( v5 )
    return -1;
  return result;
}

//----- (080DE3A0) --------------------------------------------------------
int unblock_itrm()
{
  itrm *v0; // eax

  v0 = ditrm;
  if ( ditrm )
  {
    if ( ditrm->in.ctl < 0 )
    {
LABEL_3:
      *((_BYTE *)v0 + 116) &= ~1u;
      send_init_sequence(ditrm->out.std, (*((_BYTE *)ditrm + 116) & 2) != 0);
      handle_itrm_stdin(ditrm);
      resume_mouse(ditrm->mouse_h);
      handle_terminal_resize(ditrm->in.ctl, resize_terminal);
      unblock_stdin();
      return 0;
    }
    if ( !setraw(ditrm, 0) )
    {
      v0 = ditrm;
      goto LABEL_3;
    }
  }
  return -1;
}

//----- (080DE430) --------------------------------------------------------
void __cdecl handle_trm(
        int std_in,
        int std_out,
        int sock_in,
        int sock_out,
        int ctl_in,
        void *init_string,
        int init_len,
        int remote)
{
  itrm *v8; // esi
  unsigned __int8 *v9; // eax
  char *cwd; // eax
  char *v11; // ebx
  signed int v12; // eax
  int v13; // edx
  int number; // eax
  terminal_info info; // [esp+48h] [ebp-160h] BYREF
  unsigned int v16; // [esp+18Ch] [ebp-1Ch]

  v16 = __readgsdword(0x14u);
  memset(&info, 0, sizeof(info));
  get_terminal_size(ctl_in, &info.event.info.mouse.x, &info.event.info.mouse.y);
  info.event.ev = EVENT_INIT;
  info.system_env = get_system_env();
  info.length = init_len;
  if ( remote )
  {
    info.session_info = remote;
    info.magic = -257;
  }
  else
  {
    number = get_opt_(cmdline_options, "base-session")->number;
    info.magic = -256;
    info.session_info = number;
  }
  v8 = (itrm *)mem_calloc(1u, 0x78u);
  if ( v8 )
  {
    v9 = (unsigned __int8 *)mem_calloc(1u, 0x40u);
    v8->in.queue.data = v9;
    if ( v9 )
    {
      ditrm = v8;
      v8->in.std = std_in;
      v8->out.std = std_out;
      v8->in.sock = sock_in;
      v8->out.sock = sock_out;
      v8->timer = 0;
      v8->in.ctl = ctl_in;
      *((_BYTE *)v8 + 116) = (8 * (remote != 0)) | *((_BYTE *)v8 + 116) & 0xF7;
      v8->title_codepage = get_cp_index("ISO-8859-1");
      if ( (info.system_env & 6) != 0 )
        *((_BYTE *)v8 + 116) |= 2u;
      if ( remote )
      {
        if ( std_in >= 0 )
          handle_itrm_stdin(v8);
      }
      else
      {
        if ( ctl_in >= 0 )
          setraw(v8, 1);
        send_init_sequence(std_out, (*((_BYTE *)v8 + 116) & 2) != 0);
        handle_terminal_resize(ctl_in, resize_terminal);
        enable_mouse();
        handle_itrm_stdin(v8);
      }
      if ( sock_in != std_out )
        set_handlers(sock_in, (select_handler_T)in_sock, 0, (select_handler_T)free_itrm, v8);
      get_terminal_name(info.name);
      cwd = get_cwd();
      v11 = cwd;
      if ( cwd )
      {
        v12 = strlen(cwd);
        v13 = 256;
        if ( v12 < 256 )
          v13 = v12;
        __memcpy_chk(info.cwd, v11, v13, 276);
        mem_free(v11);
      }
      itrm_queue_event(v8, (unsigned __int8 *)&info, 320);
      itrm_queue_event(v8, (unsigned __int8 *)init_string, init_len);
    }
    else
    {
      mem_free(v8);
    }
  }
}
// 8059038: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080DE6C0) --------------------------------------------------------
void resize_terminal()
{
  interlink_event ev; // [esp+18h] [ebp-20h] BYREF
  int height; // [esp+28h] [ebp-10h] BYREF
  int width[3]; // [esp+2Ch] [ebp-Ch] BYREF

  get_terminal_size(ditrm->out.std, width, &height);
  ev.ev = EVENT_RESIZE;
  ev.info.mouse.x = width[0];
  *(_QWORD *)&ev.info.size.height = (unsigned int)height;
  itrm_queue_event(ditrm, (unsigned __int8 *)&ev, 16);
}
// 80DE6C0: using guessed type int width[3];

//----- (080DE720) --------------------------------------------------------
void __cdecl dispatch_special(unsigned __int8 *text)
{
  unsigned __int8 v1; // al
  itrm *v2; // ebx
  char v3; // al
  int title_codepage; // eax
  int cp_index; // eax
  const char *v6; // ebx
  int v7; // edi
  int v8; // esi
  const char *v9; // edx
  char *v10; // eax
  char *v11; // [esp+1Ch] [ebp-2Ch]
  int width[3]; // [esp+20h] [ebp-28h]
  int old_height; // [esp+2Ch] [ebp-1Ch]

  v1 = *text;
  if ( *text == 2 )
  {
    if ( ditrm && (*((_BYTE *)ditrm + 116) & 8) != 0 )
      return;
    if ( !assert_failed )
    {
      v6 = (const char *)(text + 1);
      if ( text != (unsigned __int8 *)-1 && text[1] )
      {
        assert_failed = 0;
LABEL_22:
        v7 = 0;
        v8 = 0;
        while ( 1 )
        {
          v10 = strchr(v6, 44);
          if ( v10 )
          {
            *v10 = 0;
            v11 = v10 + 1;
            width[v8] = strtol(v6, 0, 10);
            v9 = v11;
            if ( v11 )
            {
              ++v7;
              ++v8;
              if ( v7 == 4 )
                goto LABEL_30;
              goto LABEL_25;
            }
          }
          else
          {
            if ( v8 != 3 )
              return;
            old_height = strtol(v6, 0, 10);
          }
          ++v7;
          ++v8;
          v9 = v6;
          if ( v7 == 4 )
          {
LABEL_30:
            resize_window(width[0], width[1], width[2], old_height);
            resize_terminal();
            return;
          }
LABEL_25:
          v6 = v9;
        }
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
      errline = 471;
      elinks_internal("assertion text && *text failed!");
      if ( !assert_failed )
        goto LABEL_22;
    }
    assert_failed = 0;
    return;
  }
  if ( v1 == 3 )
  {
    if ( ditrm )
    {
      cp_index = get_cp_index(text + 1);
      if ( cp_index == -1 )
        cp_index = get_cp_index("US-ASCII");
      ditrm->title_codepage = cp_index;
    }
  }
  else
  {
    if ( v1 != 1 )
      return;
    v2 = ditrm;
    if ( !ditrm )
      goto LABEL_33;
    v3 = *((_BYTE *)ditrm + 116);
    if ( (v3 & 8) == 0 )
    {
      if ( !ditrm->orig_title )
      {
        v2->orig_title = get_window_title();
        v2 = ditrm;
        v3 = *((_BYTE *)ditrm + 116);
      }
      *((_BYTE *)v2 + 116) = v3 | 4;
      if ( ditrm )
      {
        title_codepage = ditrm->title_codepage;
LABEL_11:
        set_window_title(text + 1, title_codepage);
        return;
      }
LABEL_33:
      title_codepage = get_cp_index("US-ASCII");
      goto LABEL_11;
    }
  }
}

//----- (080DE950) --------------------------------------------------------
void __cdecl unblock_itrm_x(void *h)
{
  close_handle(h);
  if ( ditrm )
  {
    unblock_itrm();
    resize_terminal();
  }
}

//----- (080DE980) --------------------------------------------------------
void __usercall set_kbd_event(
        const itrm *itrm@<eax>,
        interlink_event *ev@<edx>,
        int key@<ecx>,
        term_event_modifier_T modifier)
{
  int v4; // ecx

  if ( itrm->verase == key )
  {
    key = 257;
    goto LABEL_13;
  }
  if ( key == 13 )
    goto LABEL_12;
  if ( key <= 13 )
  {
    if ( key == 9 )
    {
      key = 258;
      goto LABEL_13;
    }
    if ( key != 10 )
      goto LABEL_6;
LABEL_12:
    key = 256;
    goto LABEL_13;
  }
  if ( key == 27 )
  {
    key = 259;
    goto LABEL_13;
  }
  if ( key == 127 )
  {
    key = 265;
    goto LABEL_13;
  }
LABEL_6:
  if ( key > 31 )
  {
LABEL_13:
    *(_QWORD *)&ev->info.mouse.x = 0LL;
    *(_QWORD *)&ev->info.size.height = (unsigned int)modifier;
    ev->ev = EVENT_KBD;
    ev->info.mouse.x = key;
    return;
  }
  v4 = key + 64;
  *(_QWORD *)&ev->info.mouse.x = 0LL;
  ev->info.mouse.button = 0;
  ev->ev = EVENT_KBD;
  if ( v4 < -255 )
    v4 = -v4;
  ev->info.mouse.y = modifier | 2;
  ev->info.mouse.x = v4;
}

//----- (080DEA60) --------------------------------------------------------
void __cdecl in_sock(itrm *itrm)
{
  signed int v1; // ebx
  size_t v2; // esi
  int std; // esi
  int v4; // ebx
  int v5; // esi
  unsigned __int8 v6; // al
  unsigned __int8 v7; // al
  char *v8; // eax
  void *v9; // edx
  int started; // eax
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // edx
  void *v15; // [esp+0h] [ebp-4078h]
  int length; // [esp+24h] [ebp-4054h]
  int v17; // [esp+24h] [ebp-4054h]
  char *ptr; // [esp+28h] [ebp-4050h]
  void *ptrc; // [esp+28h] [ebp-4050h]
  void *ptra; // [esp+28h] [ebp-4050h]
  void *ptrd; // [esp+28h] [ebp-4050h]
  void *ptrb; // [esp+28h] [ebp-4050h]
  int del_len; // [esp+2Ch] [ebp-404Ch]
  int param_len; // [esp+30h] [ebp-4048h]
  unsigned __int8 v25; // [esp+3Bh] [ebp-403Dh]
  string delete; // [esp+48h] [ebp-4030h] BYREF
  string path; // [esp+50h] [ebp-4028h] BYREF
  unsigned __int8 cc; // [esp+5Bh] [ebp-401Dh] BYREF
  unsigned __int8 buf[16384]; // [esp+5Ch] [ebp-401Ch] BYREF
  unsigned int v30; // [esp+405Ch] [ebp-1Ch]

  v30 = __readgsdword(0x14u);
  v1 = read(itrm->in.sock, buf, 0x4000u);
  if ( v1 <= 0 )
    goto free_and_return;
  do
  {
    v2 = 0;
    if ( buf[0] )
    {
      do
      {
        if ( (int)++v2 >= v1 )
          goto LABEL_6;
      }
      while ( buf[v2] );
      if ( v2 )
      {
        if ( !ditrm || (*((_BYTE *)ditrm + 116) & 1) == 0 )
        {
          ptrd = (void *)itrm->out.std;
          want_draw();
          hard_write((int)ptrd, buf, v2);
          done_draw();
        }
        ++v2;
        v14 = 0x4000 - v2;
        v12 = v2;
        v13 = 0x4000 - v2;
      }
      else
      {
        LOWORD(v2) = 1;
        v14 = 0x3FFF;
        v13 = 0x3FFF;
        v12 = 1;
      }
    }
    else
    {
      v12 = 1;
      v13 = 0x3FFF;
      v14 = 0x3FFF;
      LOWORD(v2) = 1;
    }
    if ( !assert_failed )
    {
      assert_failed = v14 <= 0;
      if ( v14 <= 0 )
      {
        ptrb = (void *)v13;
        v17 = v12;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 573;
        elinks_internal("assertion ITRM_OUT_QUEUE_SIZE - i > 0 failed!");
        v12 = v17;
        v13 = (int)ptrb;
      }
    }
    v4 = v1 - v2;
    __memmove_chk(buf, &buf[v12], v13, 0x4000);
    if ( v4 <= 0 )
    {
      if ( hard_read(itrm->in.sock, &cc, 1u) <= 0 )
        goto free_and_return;
      v5 = 0;
      v25 = cc;
    }
    else
    {
      v5 = 1;
      v25 = buf[0];
      cc = buf[0];
    }
    if ( !init_string(&path) )
      goto free_and_return;
    while ( 1 )
    {
      if ( v5 < v4 )
      {
        v6 = buf[v5++];
        cc = v6;
        if ( !v6 )
          break;
        goto LABEL_19;
      }
      if ( hard_read(itrm->in.sock, &cc, 1u) <= 0 )
        goto free_and_return;
      v6 = cc;
      if ( !cc )
        break;
LABEL_19:
      add_char_to_string(&path, v6);
    }
    if ( !init_string(&delete) )
    {
      done_string(&path);
free_and_return:
      free_itrm(itrm);
      return;
    }
    while ( 2 )
    {
      if ( v5 < v4 )
      {
        v7 = buf[v5++];
        cc = v7;
        if ( !v7 )
          goto LABEL_30;
LABEL_26:
        add_char_to_string(&delete, v7);
        continue;
      }
      break;
    }
    if ( hard_read(itrm->in.sock, &cc, 1u) <= 0 )
      goto free_and_return;
    v7 = cc;
    if ( cc )
      goto LABEL_26;
LABEL_30:
    if ( *path.source )
    {
      if ( ditrm && (*((_BYTE *)ditrm + 116) & 1) != 0 && v25 )
      {
        if ( *delete.source )
          unlink((const char *)delete.source);
      }
      else
      {
        length = path.length;
        param_len = delete.length + path.length + 3;
        del_len = delete.length;
        v8 = (char *)mem_alloc(param_len);
        if ( v8 )
        {
          *v8 = v25;
          ptr = v8;
          memcpy(v8 + 1, path.source, length + 1);
          memcpy(&ptr[length + 2], delete.source, del_len + 1);
          v9 = ptr;
          if ( v25 == 1 )
          {
            block_itrm();
            v9 = ptr;
          }
          ptrc = v9;
          started = start_thread((void (*)(void *, int))exec_thread, v9, param_len);
          v15 = ptrc;
          ptra = (void *)started;
          mem_free(v15);
          if ( ptra == (void *)-1 )
          {
            if ( v25 == 1 )
              unblock_itrm();
          }
          else if ( v25 == 1 )
          {
            set_handlers((int)ptra, unblock_itrm_x, 0, unblock_itrm_x, ptra);
          }
          else
          {
            set_handlers((int)ptra, close_handle, 0, close_handle, ptra);
          }
        }
      }
    }
    else
    {
      dispatch_special(delete.source);
    }
    done_string(&path);
    done_string(&delete);
    if ( assert_failed )
    {
      v11 = 0x4000 - v5;
    }
    else
    {
      v11 = 0x4000 - v5;
      assert_failed = 0x4000 - v5 <= 0;
      if ( 0x4000 - v5 <= 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 665;
        elinks_internal("assertion ITRM_OUT_QUEUE_SIZE - p > 0 failed!");
        v11 = 0x4000 - v5;
      }
    }
    v1 = v4 - v5;
    __memmove_chk(buf, &buf[v5], v11, 0x4000);
  }
  while ( v1 > 0 );
LABEL_6:
  std = itrm->out.std;
  if ( !ditrm || (*((_BYTE *)ditrm + 116) & 1) == 0 )
  {
    want_draw();
    hard_write(std, buf, v1);
    done_draw();
  }
}
// 80599C8: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080DF040) --------------------------------------------------------
void kbd_ctrl_c()
{
  interlink_event ev; // [esp+10h] [ebp-18h] BYREF

  if ( ditrm )
  {
    ev.ev = EVENT_KBD;
    ev.info.mouse.x = 512;
    *(_QWORD *)&ev.info.size.height = 0LL;
    itrm_queue_event(ditrm, (unsigned __int8 *)&ev, 16);
  }
}

//----- (080DF090) --------------------------------------------------------
int __usercall process_queue@<eax>(itrm *itrm@<eax>)
{
  int v2; // esi
  unsigned __int8 *data; // eax
  unsigned __int8 v4; // cl
  term_event_type v5; // eax
  bool v6; // zf
  size_t v7; // eax
  int len; // ecx
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // al
  unsigned __int8 v12; // dl
  int v13; // esi
  unsigned __int8 v14; // dl
  int v15; // eax
  unsigned __int8 *v16; // edi
  int v17; // eax
  unsigned __int8 *v18; // ecx
  int v19; // esi
  unsigned __int8 v20; // al
  int v21; // edx
  int v22; // eax
  unsigned __int8 v23; // al
  int v24; // edx
  int v25; // [esp+24h] [ebp-34h]
  int v26; // [esp+24h] [ebp-34h]
  int v27; // [esp+28h] [ebp-30h]
  unsigned __int8 v28; // [esp+2Fh] [ebp-29h]
  interlink_event ev; // [esp+30h] [ebp-28h] BYREF

  v2 = 0;
  if ( !itrm->in.queue.len )
    goto LABEL_12;
  if ( assert_failed
    || (assert_failed = *((_BYTE *)itrm + 116) & 1) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c",
        errline = 1060,
        elinks_internal("assertion !itrm->blocked failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  ev.ev = EVENT_KBD;
  ev.info.mouse.x = -1;
  *(_QWORD *)&ev.info.size.height = 0LL;
  data = itrm->in.queue.data;
  v4 = *data;
  if ( *data == 27 )
  {
    len = itrm->in.queue.len;
    if ( len <= 1 )
      goto LABEL_35;
    v10 = data[1];
    if ( v10 != 91 )
    {
      if ( v10 != 79 )
      {
        if ( v10 != 27 )
        {
LABEL_29:
          v2 = 2;
          set_kbd_event(itrm, &ev, v10, KBD_MOD_ALT);
          v5 = ev.ev;
          goto LABEL_7;
        }
        if ( len != 2 )
        {
          v11 = data[2];
          if ( v11 == 79 || v11 == 91 )
          {
            v2 = 1;
            set_kbd_event(itrm, &ev, 27, KBD_MOD_NONE);
          }
          else
          {
            v2 = 2;
            set_kbd_event(itrm, &ev, 27, KBD_MOD_ALT);
          }
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if ( assert_failed )
        goto LABEL_59;
      assert_failed = 0;
      v6 = *itrm->in.queue.data == 27;
      assert_failed = *itrm->in.queue.data != 27;
      if ( !v6 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 933;
        elinks_internal("assertion itrm->in.queue.data[0] == ASCII_ESC failed!");
        if ( assert_failed )
          goto LABEL_59;
      }
      v6 = itrm->in.queue.data[1] == 79;
      assert_failed = itrm->in.queue.data[1] != 79;
      if ( !v6 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
        errline = 934;
        elinks_internal("assertion itrm->in.queue.data[1] == 0x4F failed!");
        if ( assert_failed )
        {
LABEL_59:
          assert_failed = 0;
          goto LABEL_44;
        }
      }
      if ( itrm->in.queue.len > 2 )
      {
        v14 = itrm->in.queue.data[2];
        if ( (unsigned __int8)(v14 - 33) <= 0x5Du )
        {
          if ( v14 == 77 )
          {
            v15 = -256;
          }
          else if ( v14 > 0x4Du )
          {
            if ( v14 == 83 )
            {
              v15 = -291;
            }
            else if ( v14 > 0x53u )
            {
              if ( v14 == 88 )
              {
                v15 = 61;
              }
              else
              {
                if ( v14 < 0x58u || (unsigned __int8)(v14 - 106) > 0xFu )
                  goto LABEL_57;
                v15 = v14 - 64;
              }
            }
            else if ( v14 == 81 )
            {
              v15 = -289;
            }
            else
            {
              v15 = -290;
              if ( v14 <= 0x51u )
              {
                if ( v14 != 80 )
                  goto LABEL_57;
                v15 = -288;
              }
            }
          }
          else if ( v14 == 68 )
          {
            v15 = -260;
          }
          else if ( v14 > 0x44u )
          {
            switch ( v14 )
            {
              case 'H':
                v15 = -266;
                break;
              case 'I':
                v15 = -258;
                break;
              case 'F':
                v15 = -267;
                break;
              default:
                goto LABEL_57;
            }
          }
          else if ( v14 == 66 )
          {
            v15 = -263;
          }
          else
          {
            v15 = -261;
            if ( v14 <= 0x42u )
            {
              if ( v14 != 65 )
                goto LABEL_57;
              v15 = -262;
            }
          }
          *(_QWORD *)&ev.info.mouse.x = (unsigned int)v15;
LABEL_57:
          v2 = 3;
          goto LABEL_34;
        }
LABEL_44:
        v10 = itrm->in.queue.data[1];
        goto LABEL_29;
      }
LABEL_35:
      v2 = -1;
LABEL_34:
      v5 = ev.ev;
      goto LABEL_7;
    }
    if ( len == 2 )
      goto LABEL_35;
    v12 = data[2];
    v28 = v12;
    if ( v12 == 91 )
    {
      if ( len != 3 )
      {
        v23 = data[3];
        if ( v23 > 0x40u && v23 <= 0x4Cu )
        {
          v2 = 4;
          set_kbd_interlink_event(&ev, -223 - v23, KBD_MOD_NONE);
          goto LABEL_34;
        }
      }
      goto LABEL_35;
    }
    v13 = 2;
    while ( v12 > 0x2Fu && v12 <= 0x3Fu )
    {
      if ( len <= ++v13 )
        goto LABEL_43;
      v12 = data[v13];
    }
    v27 = v13;
    if ( len <= v13 )
    {
LABEL_43:
      if ( len == 64 )
        goto LABEL_44;
      goto LABEL_35;
    }
    if ( v12 > 0x1Fu && v12 <= 0x2Fu )
    {
      v16 = &data[v13];
      v25 = v13;
      do
      {
        if ( len <= ++v13 )
          goto LABEL_43;
        v12 = v16[1];
        if ( v12 <= 0x1Fu )
          break;
        ++v16;
      }
      while ( v12 <= 0x2Fu );
      v27 = v13;
      v13 = v25;
    }
    if ( (unsigned __int8)(v12 - 64) > 0x3Eu )
      goto LABEL_44;
    v17 = 0;
    if ( (unsigned __int8)(v28 - 48) <= 9u )
    {
      v18 = itrm->in.queue.data;
      v26 = v13;
      v19 = 0;
      v20 = v28;
      do
      {
        v19 = v20 + 10 * v19 - 48;
        v20 = v18[3];
        ++v18;
      }
      while ( (unsigned __int8)(v20 - 48) <= 9u );
      v28 = v20;
      v17 = v19;
      v13 = v26;
    }
    if ( v28 == 58 )
      v17 = 0;
    if ( v13 != v27 )
    {
      v2 = v27 + 1;
      goto LABEL_79;
    }
    v2 = v13 + 1;
    switch ( v12 )
    {
      case 'A':
        v24 = -262;
        goto LABEL_138;
      case 'B':
        v21 = 263;
        v22 = 0;
        goto LABEL_85;
      case 'C':
        v21 = 261;
        v22 = 0;
        goto LABEL_85;
      case 'D':
        v21 = 260;
        v22 = 0;
        goto LABEL_85;
      case 'F':
      case 'e':
        goto LABEL_84;
      case 'G':
        goto LABEL_112;
      case 'H':
        goto LABEL_108;
      case 'I':
        goto LABEL_93;
      case 'L':
LABEL_105:
        v21 = 264;
        v22 = 0;
        goto LABEL_85;
      case 'M':
        v2 = decode_terminal_mouse_escape_sequence(itrm, &ev, v2, v17);
        goto LABEL_79;
      case 'N':
LABEL_106:
        v21 = 289;
        v22 = 0;
        goto LABEL_85;
      case 'O':
LABEL_104:
        v21 = 290;
        v22 = 0;
        goto LABEL_85;
      case 'P':
LABEL_103:
        v21 = 291;
        v22 = 0;
        goto LABEL_85;
      case 'Q':
LABEL_102:
        v21 = 292;
        v22 = 0;
        goto LABEL_85;
      case 'R':
        resize_terminal();
        goto LABEL_79;
      case 'S':
LABEL_100:
        v21 = 294;
        v22 = 0;
        goto LABEL_85;
      case 'T':
LABEL_99:
        v21 = 295;
        v22 = 0;
        goto LABEL_85;
      case 'U':
LABEL_98:
        v21 = 296;
        v22 = 0;
        goto LABEL_85;
      case 'V':
LABEL_97:
        v21 = 297;
        v22 = 0;
        goto LABEL_85;
      case 'W':
LABEL_96:
        v21 = 298;
        v22 = 0;
        goto LABEL_85;
      case 'X':
LABEL_95:
        v21 = 299;
        v22 = 0;
        goto LABEL_85;
      case 'Z':
        v21 = 258;
        v22 = 1;
        goto LABEL_85;
      case 'z':
        if ( v17 != 220 )
        {
          if ( v17 > 220 )
          {
            switch ( v17 )
            {
              case 247:
                v24 = -264;
LABEL_138:
                v22 = 0;
                v21 = -v24;
                memset(&ev, 0, sizeof(ev));
                ev.ev = EVENT_KBD;
                goto LABEL_86;
              case 249:
LABEL_148:
                v21 = 265;
                v22 = 0;
                goto LABEL_85;
              case 222:
LABEL_112:
                v21 = 269;
                v22 = 0;
                goto LABEL_85;
            }
          }
          else
          {
            if ( v17 == 214 )
            {
LABEL_108:
              v21 = 266;
              v22 = 0;
              goto LABEL_85;
            }
            if ( v17 == 216 )
            {
LABEL_93:
              v21 = 268;
              v22 = 0;
              goto LABEL_85;
            }
          }
LABEL_79:
          if ( v2 )
            goto LABEL_34;
          goto LABEL_44;
        }
LABEL_84:
        v21 = 267;
        v22 = 0;
LABEL_85:
        ev.info.mouse.button = 0;
        ev.ev = EVENT_KBD;
LABEL_86:
        *(_QWORD *)&ev.info.mouse.x = __PAIR64__(v22, v21);
        goto LABEL_79;
      case '~':
        switch ( v17 )
        {
          case 1:
          case 7:
            v24 = -266;
            goto LABEL_138;
          case 2:
            goto LABEL_105;
          case 3:
            goto LABEL_148;
          case 4:
          case 8:
            goto LABEL_84;
          case 5:
            goto LABEL_93;
          case 6:
            goto LABEL_112;
          case 11:
            v21 = 288;
            v22 = 0;
            goto LABEL_85;
          case 12:
            goto LABEL_106;
          case 13:
            goto LABEL_104;
          case 14:
            goto LABEL_103;
          case 15:
            goto LABEL_102;
          case 17:
            v21 = 293;
            v22 = 0;
            goto LABEL_85;
          case 18:
            goto LABEL_100;
          case 19:
            goto LABEL_99;
          case 20:
            goto LABEL_98;
          case 21:
            goto LABEL_97;
          case 23:
            goto LABEL_96;
          case 24:
            goto LABEL_95;
          case 25:
            v21 = 290;
            v22 = 1;
            goto LABEL_85;
          case 26:
            v21 = 291;
            v22 = 1;
            goto LABEL_85;
          case 28:
            v21 = 292;
            v22 = 1;
            goto LABEL_85;
          case 29:
            v21 = 293;
            v22 = 1;
            goto LABEL_85;
          case 31:
            v21 = 294;
            v22 = 1;
            goto LABEL_85;
          case 32:
            v21 = 295;
            v22 = 1;
            goto LABEL_85;
          case 33:
            v21 = 296;
            v22 = 1;
            goto LABEL_85;
          case 34:
            v21 = 297;
            v22 = 1;
            goto LABEL_85;
          default:
            goto LABEL_79;
        }
        goto LABEL_79;
      default:
        goto LABEL_79;
    }
  }
  if ( v4 )
  {
    v2 = 1;
    set_kbd_event(itrm, &ev, v4, KBD_MOD_NONE);
    v5 = ev.ev;
  }
  else
  {
    v2 = -1;
    if ( itrm->in.queue.len <= 1 )
    {
LABEL_8:
      if ( ev.info.mouse.x == -1 )
        goto return_without_event;
      goto LABEL_9;
    }
    v2 = 2;
    set_kbd_interlink_event(&ev, os2xtd_7283[data[1]].key, modifier[2 * data[1]]);
    v5 = ev.ev;
  }
LABEL_7:
  if ( v5 != EVENT_MOUSE )
    goto LABEL_8;
LABEL_9:
  itrm_queue_event(itrm, (unsigned __int8 *)&ev, 16);
return_without_event:
  if ( v2 == -1 )
  {
    v2 = 0;
    install_timer(&itrm->timer, 200, (void (*)(void *))kbd_timeout, itrm);
    return v2;
  }
LABEL_12:
  if ( assert_failed
    || (v6 = itrm->in.queue.len >= v2, assert_failed = itrm->in.queue.len < v2, !v6)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c",
        errline = 1169,
        elinks_internal("assertion itrm->in.queue.len >= el failed: event queue underflow"),
        assert_failed) )
  {
    assert_failed = 0;
    itrm->in.queue.len = 0;
LABEL_19:
    handle_itrm_stdin(itrm);
    return v2;
  }
  v7 = itrm->in.queue.len - v2;
  v6 = itrm->in.queue.len == v2;
  itrm->in.queue.len = v7;
  if ( v6 )
    goto LABEL_19;
  memmove(itrm->in.queue.data, &itrm->in.queue.data[v2], v7);
  if ( itrm->in.queue.len <= 63 )
    goto LABEL_19;
  return v2;
}
// 810D684: using guessed type term_event_modifier_T modifier[467];

//----- (080DF920) --------------------------------------------------------
void __cdecl in_kbd(itrm *itrm)
{
  int len; // eax
  ssize_t v2; // eax
  int v3; // eax
  unsigned __int8 *v4; // eax

  if ( can_read(itrm->in.std) )
  {
    kill_timer(&itrm->timer);
    len = itrm->in.queue.len;
    if ( len > 63 )
    {
      unhandle_itrm_stdin(itrm);
      while ( process_queue(itrm) )
        ;
    }
    else
    {
      v2 = read(itrm->in.std, &itrm->in.queue.data[len], 64 - len);
      if ( v2 <= 0 )
      {
        free_itrm(itrm);
      }
      else
      {
        v3 = itrm->in.queue.len + v2;
        itrm->in.queue.len = v3;
        if ( v3 > 64 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
          errline = 1210;
          v4 = gettext("Too many bytes read from the itrm!");
          elinks_error(v4);
          itrm->in.queue.len = 64;
        }
        while ( process_queue(itrm) && process_queue(itrm) )
          ;
      }
    }
  }
}

//----- (080DFA00) --------------------------------------------------------
void __cdecl kbd_timeout(itrm *itrm)
{
  int len; // esi
  int v2; // eax
  unsigned __int8 *data; // eax
  unsigned __int8 v4; // cl
  int v5; // edi
  size_t v6; // eax
  bool v7; // zf
  int v8; // eax
  interlink_event ev; // [esp+10h] [ebp-28h] BYREF

  itrm->timer = 0;
  if ( assert_failed )
    goto LABEL_13;
  len = itrm->in.queue.len;
  assert_failed = len == 0;
  if ( len )
  {
    v2 = *((_BYTE *)itrm + 116) & 1;
    assert_failed = v2;
    if ( !v2 )
      goto LABEL_4;
LABEL_12:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
    errline = 1022;
    elinks_internal("assertion !itrm->blocked failed!");
    if ( assert_failed )
    {
LABEL_13:
      assert_failed = 0;
      return;
    }
    goto LABEL_4;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/kbd.c";
  errline = 1021;
  elinks_internal("assertion itrm->in.queue.len failed: timeout on empty queue");
  if ( assert_failed )
    goto LABEL_13;
  v8 = *((_BYTE *)itrm + 116) & 1;
  assert_failed = v8;
  if ( v8 )
    goto LABEL_12;
LABEL_4:
  if ( can_read(itrm->in.std) )
  {
    in_kbd(itrm);
    return;
  }
  if ( itrm->in.queue.len <= 1 )
  {
    v4 = *itrm->in.queue.data;
  }
  else
  {
    data = itrm->in.queue.data;
    v4 = *data;
    if ( *data == 27 )
    {
      v5 = 2;
      set_kbd_event(itrm, &ev, data[1], KBD_MOD_ALT);
      goto LABEL_8;
    }
  }
  v5 = 1;
  set_kbd_event(itrm, &ev, v4, KBD_MOD_NONE);
LABEL_8:
  itrm_queue_event(itrm, (unsigned __int8 *)&ev, 16);
  v6 = itrm->in.queue.len - v5;
  v7 = itrm->in.queue.len == v5;
  itrm->in.queue.len = v6;
  if ( !v7 )
    memmove(itrm->in.queue.data, &itrm->in.queue.data[v5], v6);
  while ( process_queue(itrm) )
    ;
}

//----- (080DFBC0) --------------------------------------------------------
int __cdecl decode_terminal_mouse_escape_sequence(itrm *itrm, interlink_event *ev, int el, int v)
{
  int v4; // ecx
  unsigned __int8 *data; // ecx
  unsigned __int8 v6; // di
  unsigned __int8 v7; // bl
  int v8; // ecx
  int result; // eax
  __int64 v10; // rdi
  int v11; // ebx
  unsigned __int8 *v12; // ecx
  int v13; // ebx
  unsigned __int8 v14; // [esp+3h] [ebp-15h]
  int v15; // [esp+8h] [ebp-10h]

  v4 = itrm->in.queue.len - el;
  if ( v4 > 2 )
  {
    if ( v != 5 )
    {
      data = itrm->in.queue.data;
      v6 = data[el + 1];
      v14 = data[el + 2];
      v7 = data[el];
      v8 = v7 & 7;
      if ( v8 == 3 )
      {
        if ( xterm_button_6476 != -1 )
          v8 = xterm_button_6476 | 0x20;
        if ( (v7 & 0x60) != 96 )
          goto LABEL_5;
      }
      else if ( (v7 & 0x60) != 96 )
      {
LABEL_5:
        xterm_button_6476 = -1;
        if ( (v8 & 0x20) != 0 )
        {
LABEL_6:
          result = el + 3;
          LODWORD(v10) = v6 - 33;
          HIDWORD(v10) = v14 - 33;
LABEL_7:
          ev->ev = EVENT_MOUSE;
          *(_QWORD *)&ev->info.mouse.x = v10;
          ev->info.mouse.button = v8;
          return result;
        }
        v11 = v8 & 7;
LABEL_10:
        xterm_button_6476 = v11;
        goto LABEL_6;
      }
      v11 = 4 - ((v7 & 1) == 0);
      v8 = v11;
      goto LABEL_10;
    }
    if ( xterm_button_6476 == -1 )
      xterm_button_6476 = 0;
    if ( v4 > 4 )
    {
      v12 = itrm->in.queue.data;
      LODWORD(v10) = (v12[el + 2] << 7) + v12[el + 1] - 4257;
      if ( (v10 & 0x2000) != 0 )
        LODWORD(v10) = 0;
      HIDWORD(v10) = (v12[el + 4] << 7) + v12[el + 3] - 4257;
      if ( (v10 & 0x200000000000LL) != 0 )
        HIDWORD(v10) = 0;
      v13 = v12[el] - 32;
      v15 = v13 ^ xterm_button_6476;
      if ( (v13 ^ xterm_button_6476) == 1 )
      {
        v8 = 32;
        if ( (xterm_button_6476 & 1) != 0 )
          goto LABEL_28;
      }
      else if ( (v13 ^ xterm_button_6476) <= 1 )
      {
        v8 = 64;
        if ( !v15 )
          goto LABEL_28;
      }
      else
      {
        if ( v15 == 2 )
        {
          v8 = (xterm_button_6476 & 2) == 0 ? 1 : 33;
          goto LABEL_28;
        }
        if ( v15 == 4 )
        {
          v8 = (xterm_button_6476 & 4) == 0 ? 2 : 34;
          goto LABEL_28;
        }
      }
      v8 = 0;
LABEL_28:
      xterm_button_6476 = v13;
      result = el + 5;
      goto LABEL_7;
    }
  }
  return -1;
}

//----- (080DFD90) --------------------------------------------------------
void __cdecl send_mouse_done_sequence(int h)
{
  hard_write(h, "\x1B[?9l", 5u);
  hard_write(h, "\x1B[?1000l", 8u);
}

//----- (080DFDD0) --------------------------------------------------------
void disable_mouse()
{
  int output_handle; // ebx

  output_handle = get_output_handle();
  if ( mouse_enabled )
  {
    unhandle_mouse(ditrm->mouse_h);
    if ( is_xterm() )
      send_mouse_done_sequence(output_handle);
    mouse_enabled = 0;
  }
}

//----- (080DFE30) --------------------------------------------------------
void __cdecl send_mouse_init_sequence(int h)
{
  hard_write(h, "\x1B[?9h", 5u);
  hard_write(h, "\x1B[?1000h", 8u);
}

//----- (080DFE70) --------------------------------------------------------
void enable_mouse()
{
  int output_handle; // ebx
  itrm *v1; // ebx

  output_handle = get_output_handle();
  if ( !mouse_enabled )
  {
    if ( is_xterm() )
      send_mouse_init_sequence(output_handle);
    v1 = ditrm;
    v1->mouse_h = handle_mouse(0, (void (*)(void *, unsigned __int8 *, int))itrm_queue_event, ditrm);
    mouse_enabled = 1;
  }
}

//----- (080DFEE0) --------------------------------------------------------
void toggle_mouse()
{
  if ( mouse_enabled )
    disable_mouse();
  else
    enable_mouse();
}

//----- (080DFF00) --------------------------------------------------------
void __cdecl done_screen(terminal_screen *screen)
{
  if ( screen->image )
    mem_free(screen->image);
  mem_free(screen);
}

//----- (080DFF30) --------------------------------------------------------
void __cdecl done_screen_drivers(module *xxx)
{
  _DWORD *next; // eax
  list_head_elinks *i; // ebx
  list_head_elinks *j; // edx
  list_head_elinks *v4; // esi
  list_head_elinks *v5; // edi

  next = active_screen_drivers.next;
  for ( i = (list_head_elinks *)active_screen_drivers.next; i != &active_screen_drivers; i = (list_head_elinks *)i->next )
    ;
  for ( j = (list_head_elinks *)active_screen_drivers.prev; j != i; j = (list_head_elinks *)j->prev )
    ;
  v4 = *(list_head_elinks **)active_screen_drivers.next;
  if ( active_screen_drivers.next != i )
  {
    do
    {
      v5 = v4;
      v4->prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v4 = (list_head_elinks *)v4->next;
      next = &v5->next;
    }
    while ( v5 != i );
  }
}

//----- (080DFFA0) --------------------------------------------------------
void __cdecl resize_screen(terminal *term, int width, int height)
{
  terminal_screen *screen; // edi
  int v4; // eax
  screen_char *v5; // eax
  int bsize; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
  {
    screen = term->screen;
    goto LABEL_14;
  }
  if ( term && term->screen )
  {
    assert_failed = 0;
    screen = term->screen;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
    errline = 1178;
    elinks_internal("assertion term && term->screen failed!");
    screen = term->screen;
    if ( assert_failed )
      goto LABEL_14;
  }
  assert_failed = (unsigned int)width >> 31;
  if ( width < 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c",
        errline = 1182,
        elinks_internal("assertion width >= 0 failed!"),
        assert_failed)
    || (assert_failed = (unsigned int)height >> 31, height >= 0) )
  {
LABEL_14:
    v4 = height * width;
    if ( !(height * width) )
      return;
    goto LABEL_8;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
  errline = 1183;
  elinks_internal("assertion height >= 0 failed!");
  v4 = height * width;
  if ( !(height * width) )
    return;
LABEL_8:
  bsize = 8 * v4;
  v5 = (screen_char *)mem_realloc(screen->image, 16 * v4);
  if ( v5 )
  {
    screen->image = v5;
    screen->last_image = &v5[bsize / 8u];
    memset(v5, 0, bsize);
    memset(screen->last_image, 255, bsize);
    term->height = height;
    term->width = width;
    if ( screen->dirty_from > 0 )
      screen->dirty_from = 0;
    if ( height > screen->dirty_to )
      screen->dirty_to = height;
  }
}

//----- (080E0150) --------------------------------------------------------
terminal_screen *init_screen()
{
  terminal_screen *result; // eax

  result = (terminal_screen *)mem_calloc(1u, 0x20u);
  if ( result )
  {
    result->lcx = -1;
    result->lcy = -1;
  }
  return result;
}

//----- (080E0180) --------------------------------------------------------
void __cdecl beep_terminal(terminal *term)
{
  hard_write(term->fdout, (unsigned __int8 *)"\a", 1u);
}

//----- (080E01B0) --------------------------------------------------------
void __cdecl erase_screen(terminal *term)
{
  if ( (*((_BYTE *)term + 56) & 1) != 0 )
  {
    if ( is_blocked() )
      return;
    want_draw();
  }
  hard_write(term->fdout, "\x1B[2J\x1B[1;1H", 0xAu);
  if ( (*((_BYTE *)term + 56) & 1) != 0 )
    done_draw();
}

//----- (080E0210) --------------------------------------------------------
void __usercall set_screen_driver_opt(screen_driver *driver@<eax>, option_elinks *term_spec@<edx>)
{
  int number; // edi
  option_value *opt; // eax
  const string *v6; // edx
  term_mode_type type; // eax
  term_mode_type v8; // eax
  int utf8_io; // [esp+1Ch] [ebp-1Ch]

  number = get_opt_(term_spec, "charset")->number;
  utf8_io = get_opt_(term_spec, "utf_8_io")->number;
  driver->opt = *screen_driver_opts[driver->type];
  if ( is_cp_utf8(number) )
  {
    *((_BYTE *)&driver->opt + 24) |= 2u;
    utf8_io = 1;
  }
  else
  {
    *((_BYTE *)&driver->opt + 24) &= ~2u;
  }
  driver->opt.color_mode = (color_mode)get_opt_(term_spec, "colors")->tree;
  *((_BYTE *)&driver->opt + 24) = (int)get_opt_(term_spec, "transparency")->tree & 1 | *((_BYTE *)&driver->opt + 24) & 0xFE;
  opt = get_opt_(term_spec, (unsigned __int8 *)"underline");
  v6 = 0;
  if ( opt->number )
    v6 = underline_seqs;
  driver->opt.underline = v6;
  if ( utf8_io )
  {
    type = driver->type;
    driver->opt.charsets[0] = number;
    driver->opt.frame_seqs = 0;
    if ( type == TERM_LINUX )
    {
      if ( get_opt_(term_spec, "restrict_852")->number )
        driver->opt.frame = frame_restrict;
    }
    else
    {
      if ( type != TERM_FREEBSD )
      {
        if ( type == TERM_VT100 )
        {
          driver->opt.frame = frame_vt100_u;
          driver->opt.charsets[1] = get_cp_index("cp437");
        }
        else if ( type == TERM_KOI8 )
        {
          driver->opt.charsets[1] = get_cp_index("koi8-r");
        }
        else if ( (*((_BYTE *)&driver->opt + 24) & 2) != 0 )
        {
          driver->opt.charsets[1] = get_cp_index("US-ASCII");
        }
        else
        {
          driver->opt.charsets[1] = number;
        }
        return;
      }
      driver->opt.frame = frame_freebsd_u;
    }
    driver->opt.charsets[1] = get_cp_index("cp437");
    return;
  }
  v8 = driver->type;
  driver->opt.charsets[0] = -1;
  if ( v8 == TERM_LINUX )
  {
    if ( get_opt_(term_spec, "restrict_852")->number )
      driver->opt.frame = frame_restrict;
  }
  else if ( v8 != TERM_FREEBSD )
  {
    if ( v8 == TERM_VT100 )
      driver->opt.frame = frame_vt100;
    return;
  }
  if ( get_opt_(term_spec, (unsigned __int8 *)"m11_hack")->number )
    driver->opt.frame_seqs = m11_hack_frame_seqs;
}

//----- (080E0460) --------------------------------------------------------
int __cdecl screen_driver_change_hook(session *ses, option_elinks *term_spec, option_elinks *changed)
{
  option_value *opt; // eax
  screen_driver *next; // ebx
  int number; // esi
  unsigned __int8 *name; // edi

  opt = get_opt_(term_spec, "type");
  next = (screen_driver *)active_screen_drivers.next;
  number = opt->number;
  name = term_spec->name;
  if ( active_screen_drivers.next != &active_screen_drivers )
  {
    while ( next->type != number || strcmp((const char *)next->name, (const char *)name) )
    {
      next = next->next;
      if ( next == (screen_driver *)&active_screen_drivers )
        return 0;
    }
    set_screen_driver_opt(next, term_spec);
  }
  return 0;
}

//----- (080E04D0) --------------------------------------------------------
string *__usercall add_bytes_to_string___5@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (080E0620) --------------------------------------------------------
void __cdecl redraw_screen(terminal *term)
{
  terminal_screen *v1; // ecx
  int v2; // edi
  list_head_elinks *next; // esi
  screen_driver *v4; // ebx
  void *v5; // eax
  char v6; // al
  int color_mode; // eax
  int width; // edx
  int dirty_from; // eax
  screen_char *v10; // esi
  int v11; // edx
  screen_char *v12; // ecx
  screen_char *v13; // edx
  screen_char *v14; // esi
  unsigned int v15; // eax
  unsigned int data; // eax
  unsigned __int8 *v17; // eax
  unsigned __int8 attr; // al
  char v19; // di
  char v20; // dl
  char v21; // cl
  char v22; // al
  const string *frame_seqs; // eax
  signed int v24; // edx
  unsigned __int8 *source; // ecx
  const string *underline; // eax
  signed int v27; // edx
  unsigned __int8 *v28; // ecx
  const unsigned __int8 *frame; // ecx
  const unsigned __int8 *v30; // eax
  const string *v31; // eax
  int cx; // esi
  int cy; // eax
  unsigned int v34; // eax
  unsigned int v35; // ecx
  int v36; // eax
  int height; // eax
  int v38; // edx
  unsigned int v39; // eax
  size_t v40; // ecx
  unsigned __int8 *v41; // eax
  unsigned __int8 v42; // dl
  char v43; // al
  int v44; // ecx
  unsigned int v45; // eax
  size_t v46; // edx
  int v47; // edx
  unsigned int v48; // eax
  size_t v49; // ecx
  unsigned __int8 *v50; // eax
  unicode_val_T v51; // eax
  int v52; // eax
  unsigned int v53; // eax
  int v54; // eax
  unsigned int v55; // eax
  unsigned __int8 *v56; // eax
  unsigned int v57; // eax
  unsigned int v58; // ecx
  unsigned __int8 *v59; // eax
  unsigned __int8 *v60; // eax
  unsigned __int8 *v61; // eax
  unsigned __int8 *v62; // eax
  screen_driver *v63; // eax
  char v64; // al
  int v65; // edx
  int v66; // ecx
  screen_char *v67; // edi
  int dirty_to; // eax
  int v69; // eax
  int v70; // edx
  screen_char *v71; // esi
  unsigned int v72; // ecx
  char v73; // dl
  unsigned int v74; // eax
  const string *v75; // edx
  int v76; // ecx
  int v77; // ecx
  int v78; // ecx
  int v79; // ecx
  const string *v80; // eax
  unicode_val_T v81; // eax
  const unsigned __int8 *v82; // ecx
  unsigned __int8 *v83; // eax
  const unsigned __int8 *v84; // eax
  const string *v85; // edx
  unsigned int v86; // eax
  unsigned int v87; // ecx
  int v88; // eax
  int v89; // edx
  screen_char *v90; // esi
  int v91; // edx
  int v92; // eax
  screen_char *v93; // ecx
  screen_char *v94; // edx
  screen_char *v95; // esi
  unsigned int v96; // ecx
  char v97; // dl
  unsigned int v98; // eax
  const string *v99; // edx
  int v100; // ecx
  int v101; // ecx
  int v102; // ecx
  int v103; // ecx
  const string *v104; // eax
  unicode_val_T v105; // eax
  const unsigned __int8 *v106; // ecx
  unsigned __int8 *v107; // eax
  const unsigned __int8 *v108; // eax
  const string *v109; // edx
  unsigned int v110; // eax
  unsigned int v111; // ecx
  char v112; // [esp+2Fh] [ebp-B9h]
  char v113; // [esp+2Fh] [ebp-B9h]
  char v114; // [esp+2Fh] [ebp-B9h]
  char v115; // [esp+2Fh] [ebp-B9h]
  unsigned __int8 *v116; // [esp+34h] [ebp-B4h]
  unsigned __int8 *v117; // [esp+34h] [ebp-B4h]
  size_t v118; // [esp+34h] [ebp-B4h]
  size_t v119; // [esp+34h] [ebp-B4h]
  int v120; // [esp+34h] [ebp-B4h]
  unsigned __int8 *v121; // [esp+34h] [ebp-B4h]
  unsigned __int8 *v122; // [esp+34h] [ebp-B4h]
  signed int v123; // [esp+38h] [ebp-B0h]
  signed int v124; // [esp+38h] [ebp-B0h]
  int v125; // [esp+38h] [ebp-B0h]
  int v126; // [esp+38h] [ebp-B0h]
  size_t v127; // [esp+38h] [ebp-B0h]
  signed int v128; // [esp+38h] [ebp-B0h]
  signed int v129; // [esp+38h] [ebp-B0h]
  bool v130; // [esp+3Fh] [ebp-A9h]
  bool v131; // [esp+3Fh] [ebp-A9h]
  bool v132; // [esp+3Fh] [ebp-A9h]
  int ymax; // [esp+40h] [ebp-A8h]
  int ymaxa; // [esp+40h] [ebp-A8h]
  int ymaxb; // [esp+40h] [ebp-A8h]
  int v136; // [esp+44h] [ebp-A4h]
  int v137; // [esp+44h] [ebp-A4h]
  int v138; // [esp+44h] [ebp-A4h]
  terminal_screen *screen; // [esp+48h] [ebp-A0h]
  terminal_screen *screen_0; // [esp+4Ch] [ebp-9Ch]
  terminal_screen *screen_0a; // [esp+4Ch] [ebp-9Ch]
  terminal_screen *screen_0b; // [esp+4Ch] [ebp-9Ch]
  unsigned int number; // [esp+54h] [ebp-94h]
  unsigned int numbera; // [esp+54h] [ebp-94h]
  unsigned int numberb; // [esp+54h] [ebp-94h]
  signed int v146; // [esp+58h] [ebp-90h]
  int xmax; // [esp+5Ch] [ebp-8Ch]
  int xmaxa; // [esp+5Ch] [ebp-8Ch]
  int xmaxb; // [esp+5Ch] [ebp-8Ch]
  int xmax_0; // [esp+60h] [ebp-88h]
  int xmax_0a; // [esp+60h] [ebp-88h]
  screen_char *current; // [esp+64h] [ebp-84h]
  screen_char *currenta; // [esp+64h] [ebp-84h]
  screen_char *currentb; // [esp+64h] [ebp-84h]
  signed int v155; // [esp+68h] [ebp-80h]
  signed int v156; // [esp+68h] [ebp-80h]
  signed int v157; // [esp+68h] [ebp-80h]
  char v158; // [esp+6Ch] [ebp-7Ch]
  unsigned int v159; // [esp+6Ch] [ebp-7Ch]
  unsigned __int8 *v160; // [esp+70h] [ebp-78h]
  int v161; // [esp+70h] [ebp-78h]
  int v162; // [esp+70h] [ebp-78h]
  char v163; // [esp+70h] [ebp-78h]
  const unsigned __int8 *v164; // [esp+70h] [ebp-78h]
  char v165; // [esp+70h] [ebp-78h]
  const unsigned __int8 *v166; // [esp+70h] [ebp-78h]
  screen_char *pos; // [esp+74h] [ebp-74h]
  unsigned __int8 *posa; // [esp+74h] [ebp-74h]
  int posb; // [esp+74h] [ebp-74h]
  char posc; // [esp+74h] [ebp-74h]
  unsigned __int8 *posd; // [esp+74h] [ebp-74h]
  int pose; // [esp+74h] [ebp-74h]
  char posf; // [esp+74h] [ebp-74h]
  char pos_0; // [esp+78h] [ebp-70h]
  screen_char *pos_0a; // [esp+78h] [ebp-70h]
  screen_char *pos_0b; // [esp+78h] [ebp-70h]
  screen_char *pos_0c; // [esp+78h] [ebp-70h]
  screen_char *pos_0d; // [esp+78h] [ebp-70h]
  size_t size; // [esp+7Ch] [ebp-6Ch]
  char sizea; // [esp+7Ch] [ebp-6Ch]
  size_t sizeb; // [esp+7Ch] [ebp-6Ch]
  size_t sizec; // [esp+7Ch] [ebp-6Ch]
  size_t sized; // [esp+7Ch] [ebp-6Ch]
  unsigned __int8 sizee; // [esp+7Ch] [ebp-6Ch]
  unsigned __int8 sizef; // [esp+7Ch] [ebp-6Ch]
  list_head_elinks *v186; // [esp+80h] [ebp-68h]
  char v187; // [esp+80h] [ebp-68h]
  char v188; // [esp+80h] [ebp-68h]
  char v189; // [esp+80h] [ebp-68h]
  char v190; // [esp+80h] [ebp-68h]
  char v191; // [esp+80h] [ebp-68h]
  char length; // [esp+84h] [ebp-64h]
  int lengtha; // [esp+84h] [ebp-64h]
  char lengthb; // [esp+84h] [ebp-64h]
  int lengthc; // [esp+84h] [ebp-64h]
  int lengthd; // [esp+84h] [ebp-64h]
  char lengthe; // [esp+84h] [ebp-64h]
  int lengthf; // [esp+84h] [ebp-64h]
  int lengthg; // [esp+84h] [ebp-64h]
  char v200; // [esp+88h] [ebp-60h]
  unsigned int v201; // [esp+88h] [ebp-60h]
  char v202; // [esp+88h] [ebp-60h]
  int v203; // [esp+88h] [ebp-60h]
  unsigned __int8 v204; // [esp+88h] [ebp-60h]
  char v205; // [esp+88h] [ebp-60h]
  int v206; // [esp+88h] [ebp-60h]
  unsigned __int8 v207; // [esp+88h] [ebp-60h]
  unsigned __int8 *prev_y; // [esp+8Ch] [ebp-5Ch]
  int prev_ya; // [esp+8Ch] [ebp-5Ch]
  int prev_yb; // [esp+8Ch] [ebp-5Ch]
  char prev_yc; // [esp+8Ch] [ebp-5Ch]
  int prev_yd; // [esp+8Ch] [ebp-5Ch]
  int prev_ye; // [esp+8Ch] [ebp-5Ch]
  char prev_yf; // [esp+8Ch] [ebp-5Ch]
  char prev_yg; // [esp+8Ch] [ebp-5Ch]
  char prev_yh; // [esp+8Ch] [ebp-5Ch]
  unsigned int prev_yi; // [esp+8Ch] [ebp-5Ch]
  int prev_yj; // [esp+8Ch] [ebp-5Ch]
  char prev_yk; // [esp+8Ch] [ebp-5Ch]
  char prev_yl; // [esp+8Ch] [ebp-5Ch]
  char prev_ym; // [esp+8Ch] [ebp-5Ch]
  unsigned int prev_yn; // [esp+8Ch] [ebp-5Ch]
  string image; // [esp+9Ch] [ebp-4Ch] BYREF
  unsigned __int8 bytes[6]; // [esp+A6h] [ebp-42h] BYREF
  unsigned int slen; // [esp+ACh] [ebp-3Ch] BYREF
  unsigned __int8 s; // [esp+B3h] [ebp-35h] BYREF
  char v227; // [esp+B4h] [ebp-34h]
  unsigned int v228; // [esp+CCh] [ebp-1Ch]

  v228 = __readgsdword(0x14u);
  v1 = term->screen;
  screen = v1;
  if ( v1 && v1->dirty_from <= v1->dirty_to && ((*((_BYTE *)term + 56) & 1) == 0 || !is_blocked()) )
  {
    v2 = get_opt_(term->spec, "type")->number;
    prev_y = term->spec->name;
    size = strlen((const char *)prev_y);
    next = (list_head_elinks *)active_screen_drivers.next;
    v186 = (list_head_elinks *)active_screen_drivers.next;
    if ( active_screen_drivers.next == &active_screen_drivers )
    {
LABEL_181:
      v4 = (screen_driver *)mem_alloc(size + 44);
      if ( !v4 )
        return;
      v63 = (screen_driver *)next->next;
      v4->prev = (screen_driver *)next;
      v4->next = v63;
      next->next = v4;
      v4->next->prev = v4;
      v4->type = v2;
      set_screen_driver_opt(v4, term->spec);
      memcpy(v4->name, term->spec->name, size + 1);
      term->spec->change_hook = screen_driver_change_hook;
      v64 = *((_BYTE *)&v4->opt + 24) & 2 | *((_BYTE *)term + 56) & 0xFD;
      *((_BYTE *)term + 56) = v64;
      *((_BYTE *)term + 56) = (4 * (v4->opt.charsets[0] != -1)) | v64 & 0xFB;
    }
    else
    {
      while ( 1 )
      {
        v4 = (screen_driver *)next;
        if ( (void *)v2 == next[1].next && !strcmp((const char *)&next[5], (const char *)prev_y) )
          break;
        next = (list_head_elinks *)next->next;
        if ( next == &active_screen_drivers )
          goto LABEL_181;
      }
      if ( v186 != next )
      {
        *((_DWORD *)next->next + 1) = next->prev;
        *(_DWORD *)next->prev = next->next;
        v5 = active_screen_drivers.next;
        next->prev = &active_screen_drivers;
        next->next = v5;
        active_screen_drivers.next = next;
        *((_DWORD *)next->next + 1) = next;
      }
      v6 = (int)next[4].prev & 2 | *((_BYTE *)term + 56) & 0xFD;
      *((_BYTE *)term + 56) = v6;
      *((_BYTE *)term + 56) = (4 * (next[1].prev != (void *)-1)) | v6 & 0xFB;
    }
    if ( !init_string(&image) )
      return;
    color_mode = v4->opt.color_mode;
    if ( color_mode != 2 )
    {
      if ( color_mode <= 2 )
      {
        if ( color_mode != -1 )
          goto LABEL_16;
        goto LABEL_101;
      }
      if ( color_mode != 3 )
      {
        if ( color_mode != 5 )
        {
LABEL_16:
          screen_0 = term->screen;
          width = term->width;
          dirty_from = screen_0->dirty_from;
          xmax = width - 1;
          ymax = term->height - 1;
          prev_ya = (int)screen_0->last_image;
          v10 = screen_0->image;
          if ( ymax < screen_0->dirty_to )
            screen_0->dirty_to = ymax;
          if ( dirty_from <= screen_0->dirty_to )
          {
            number = dirty_from + 1;
            v158 = -1;
            v200 = -1;
            v11 = dirty_from * width;
            v12 = (screen_char *)(v11 * 8 + prev_ya);
            v13 = &v10[v11];
            v14 = 0;
            current = v12;
            pos = v13;
            length = -1;
            pos_0 = -1;
            prev_yb = -1;
            while ( 1 )
            {
              v15 = number - 1;
              v136 = number;
              if ( xmax >= 0 )
              {
                v130 = v15 == ymax;
                if ( v15 != ymax || xmax )
                  break;
              }
LABEL_78:
              ++number;
              if ( screen_0->dirty_to < v136 )
                goto LABEL_79;
            }
            v155 = 1;
            v136 = number;
            while ( (((current->color[0] >> 4) ^ (pos->color[0] >> 4)) & 7) == 0 )
            {
              if ( ((pos->color[0] ^ current->color[0]) & 7) != 0 )
              {
                data = pos->data;
              }
              else
              {
                data = pos->data;
                if ( pos->data == current->data )
                {
                  xmax_0 = v155;
                  if ( pos->attr == current->attr )
                    goto LABEL_75;
                }
              }
              if ( data > 0x20 )
                break;
              if ( current->data > 0x20 )
                break;
              xmax_0 = v155;
              if ( pos->attr != current->attr )
                break;
LABEL_75:
              ++current;
              ++pos;
              if ( xmax >= v155 )
              {
                ++v155;
                if ( xmax != xmax_0 || !v130 )
                  continue;
              }
              goto LABEL_78;
            }
            if ( number - 1 == prev_yb && &v14[10] > pos )
            {
              xmax_0 = v155;
              if ( v14 <= pos )
                goto LABEL_41;
LABEL_74:
              prev_yb = number - 1;
              goto LABEL_75;
            }
            slen = 2;
            s = 27;
            xmax_0 = v155;
            v227 = 91;
            if ( elinks_ulongcat(&s, &slen, number, 0xAu, 0, 0xAu, 0) >= 0 )
            {
              v57 = slen;
              *(&s + slen) = 59;
              slen = v57 + 1;
              if ( elinks_ulongcat(&s, &slen, v155, 0xAu, 0, 0xAu, 0) >= 0 )
              {
                v58 = slen;
                *(&s + slen) = 72;
                slen = v58 + 1;
                add_bytes_to_string___5(&image, &s, v58 + 1);
              }
            }
            v14 = pos;
            while ( 1 )
            {
LABEL_41:
              attr = v14->attr;
              v19 = attr & 0x80;
              prev_yc = attr & 0x20;
              v187 = attr & 8;
              v20 = *((_BYTE *)&v4->opt + 24);
              v21 = v20 & 2;
              if ( (v20 & 2) != 0 && v14->data == -3 )
              {
LABEL_108:
                v51 = -3;
                goto LABEL_63;
              }
              v22 = attr & 0x80;
              if ( v19 == v158 )
                goto LABEL_106;
              frame_seqs = v4->opt.frame_seqs;
              if ( frame_seqs )
              {
                if ( v19 )
                  ++frame_seqs;
                v24 = frame_seqs->length;
                source = frame_seqs->source;
                if ( !assert_failed )
                {
                  if ( source && v24 >= 0 )
                  {
                    assert_failed = 0;
                    if ( !v24 )
                    {
LABEL_105:
                      v20 = *((_BYTE *)&v4->opt + 24);
                      v22 = v19;
                      v21 = v20 & 2;
LABEL_106:
                      v158 = v22;
                      if ( !v21 )
                        goto LABEL_50;
                      goto LABEL_107;
                    }
LABEL_148:
                    v161 = v24 + image.length;
                    v52 = v24 + image.length + 256;
                    LOBYTE(v52) = 0;
                    sizec = v52;
                    v53 = image.length + 255;
                    LOBYTE(v53) = 0;
                    v159 = v53;
                    if ( sizec > v53 )
                    {
                      v128 = v24;
                      v121 = source;
                      v61 = (unsigned __int8 *)mem_realloc(image.source, sizec);
                      if ( !v61 )
                        goto LABEL_105;
                      image.source = v61;
                      memset(&v61[v159], 0, sizec - v159);
                      source = v121;
                      v24 = v128;
                    }
                    if ( image.source )
                    {
                      memcpy(&image.source[image.length], source, v24);
                      image.source[v161] = 0;
                      image.length = v161;
                    }
                    goto LABEL_105;
                  }
                  v123 = frame_seqs->length;
                  v116 = frame_seqs->source;
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 255;
                  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                  source = v116;
                  v24 = v123;
                  if ( !assert_failed )
                  {
                    if ( !v123 )
                      goto LABEL_105;
                    goto LABEL_148;
                  }
                }
                assert_failed = 0;
                v20 = *((_BYTE *)&v4->opt + 24);
                v158 = v19;
                v21 = v20 & 2;
              }
              if ( !v21 )
                goto LABEL_50;
LABEL_107:
              if ( v14->data == -3 )
                goto LABEL_108;
LABEL_50:
              if ( prev_yc == v200 )
                goto LABEL_113;
              underline = v4->opt.underline;
              if ( underline )
              {
                if ( prev_yc )
                  ++underline;
                v27 = underline->length;
                v28 = underline->source;
                if ( assert_failed )
                {
LABEL_55:
                  assert_failed = 0;
                  v200 = prev_yc;
                  v20 = *((_BYTE *)&v4->opt + 24);
                  goto LABEL_56;
                }
                if ( v28 && v27 >= 0 )
                {
                  assert_failed = 0;
                  if ( !v27 )
                    goto LABEL_112;
                }
                else
                {
                  v124 = underline->length;
                  v117 = underline->source;
                  assert_failed = 1;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
                  errline = 255;
                  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
                  v27 = v124;
                  v28 = v117;
                  if ( assert_failed )
                    goto LABEL_55;
                  if ( !v124 )
                    goto LABEL_112;
                }
                v162 = v27 + image.length;
                v54 = v27 + image.length + 256;
                LOBYTE(v54) = 0;
                sized = v54;
                v55 = image.length + 255;
                LOBYTE(v55) = 0;
                v201 = v55;
                if ( sized > v55 )
                {
                  v129 = v27;
                  v122 = v28;
                  v62 = (unsigned __int8 *)mem_realloc(image.source, sized);
                  if ( !v62 )
                  {
LABEL_112:
                    v20 = *((_BYTE *)&v4->opt + 24);
LABEL_113:
                    v200 = prev_yc;
                    if ( (v20 & 2) == 0 )
                      goto LABEL_57;
                    goto LABEL_114;
                  }
                  image.source = v62;
                  memset(&v62[v201], 0, sized - v201);
                  v28 = v122;
                  v27 = v129;
                }
                if ( !image.source )
                  goto LABEL_112;
                memcpy(&image.source[image.length], v28, v27);
                image.source[v162] = 0;
                image.length = v162;
                v200 = prev_yc;
                v20 = *((_BYTE *)&v4->opt + 24);
              }
LABEL_56:
              if ( (v20 & 2) == 0 )
                goto LABEL_57;
LABEL_114:
              if ( v14->data == -3 )
                goto LABEL_108;
LABEL_57:
              if ( length != v187 )
              {
                if ( v187 )
                {
                  if ( assert_failed )
                  {
                    assert_failed = 0;
                    length = v187;
                    v20 = *((_BYTE *)&v4->opt + 24);
                  }
                  else
                  {
                    v47 = image.length;
                    assert_failed = 0;
                    lengtha = image.length + 4;
                    v49 = image.length + 260;
                    v48 = image.length + 255;
                    LOBYTE(v49) = 0;
                    LOBYTE(v48) = 0;
                    sizeb = v48;
                    if ( v49 > v48 )
                    {
                      v119 = v49;
                      v126 = image.length;
                      v59 = (unsigned __int8 *)mem_realloc(image.source, v49);
                      if ( !v59
                        || (image.source = v59,
                            memset(&v59[sizeb], 0, v119 - sizeb),
                            v50 = image.source,
                            v47 = v126,
                            !image.source) )
                      {
LABEL_168:
                        length = v187;
                        v20 = *((_BYTE *)&v4->opt + 24);
                        goto LABEL_60;
                      }
                    }
                    else
                    {
                      v50 = image.source;
                      if ( !image.source )
                        goto LABEL_168;
                    }
                    *(_DWORD *)&v50[image.length] = 1831951131;
                    image.source[v47 + 4] = 0;
                    image.length = lengtha;
                    length = v187;
                    v20 = *((_BYTE *)&v4->opt + 24);
                  }
                }
                else
                {
                  length = 0;
                  pos_0 = v14->color[0] + 1;
                }
              }
LABEL_60:
              if ( (v20 & 2) != 0 && v14->data == -3 )
                goto LABEL_108;
              sizea = v14->color[0];
              if ( pos_0 == sizea )
              {
                v51 = v14->data;
                goto LABEL_63;
              }
              if ( !assert_failed )
              {
                v38 = image.length;
                assert_failed = 0;
                v160 = (unsigned __int8 *)(image.length + 3);
                v40 = image.length + 259;
                v39 = image.length + 255;
                LOBYTE(v40) = 0;
                LOBYTE(v39) = 0;
                pos_0a = (screen_char *)v39;
                if ( v40 > v39 )
                {
                  v118 = v40;
                  v125 = image.length;
                  v56 = (unsigned __int8 *)mem_realloc(image.source, v40);
                  if ( v56 )
                  {
                    image.source = v56;
                    memset(&v56[(_DWORD)pos_0a], 0, v118 - (_DWORD)pos_0a);
                    v38 = v125;
                    goto LABEL_118;
                  }
                }
                else
                {
LABEL_118:
                  if ( image.source )
                  {
                    v41 = &image.source[image.length];
                    *(_WORD *)v41 = 23323;
                    v41[2] = 48;
                    image.source[v38 + 3] = 0;
                    image.length = (int)v160;
                  }
                }
                if ( v4->opt.color_mode )
                  goto LABEL_121;
                goto LABEL_136;
              }
              assert_failed = 0;
              if ( v4->opt.color_mode )
              {
LABEL_121:
                qmemcpy(bytes, ";30;40", sizeof(bytes));
                v42 = v14->color[0];
                bytes[2] = (v42 & 7) + 48;
                v43 = (v42 >> 4) & 7;
                if ( !v43 && (*((_BYTE *)&v4->opt + 24) & 1) != 0 )
                {
                  add_bytes_to_string___5(&image, bytes, 3);
                }
                else
                {
                  bytes[5] += v43;
                  add_bytes_to_string___5(&image, bytes, 6);
                }
                goto LABEL_124;
              }
LABEL_136:
              if ( (v14->attr & 0x40) != 0 )
                add_bytes_to_string___5(&image, ";7", 2);
LABEL_124:
              if ( prev_yc && v4->opt.underline )
              {
                if ( assert_failed )
                {
                  assert_failed = 0;
                }
                else
                {
                  v44 = image.length;
                  assert_failed = 0;
                  pos_0b = (screen_char *)(image.length + 2);
                  v46 = image.length + 258;
                  v45 = image.length + 255;
                  LOBYTE(v46) = 0;
                  LOBYTE(v45) = 0;
                  prev_yd = v45;
                  if ( v46 <= v45 )
                    goto LABEL_128;
                  v127 = v46;
                  v120 = image.length;
                  v60 = (unsigned __int8 *)mem_realloc(image.source, v46);
                  if ( v60 )
                  {
                    image.source = v60;
                    memset(&v60[prev_yd], 0, v127 - prev_yd);
                    v44 = v120;
LABEL_128:
                    if ( image.source )
                    {
                      *(_WORD *)&image.source[image.length] = 13371;
                      image.source[v44 + 2] = 0;
                      image.length = (int)pos_0b;
                    }
                  }
                }
              }
              if ( v187 )
                add_bytes_to_string___5(&image, ";1", 2);
              add_bytes_to_string___5(&image, (const unsigned __int8 *)"m", 1);
              v51 = v14->data;
              pos_0 = sizea;
              v20 = *((_BYTE *)&v4->opt + 24);
LABEL_63:
              if ( v19 )
              {
                frame = v4->opt.frame;
                if ( v51 > 0xAF && frame && v51 <= 0xDF )
                  v51 = frame[v51 - 176];
              }
              if ( (v20 & 2) != 0 )
              {
                if ( v19 )
                  v51 = cp2u(v4->opt.charsets[1], v51);
                if ( v51 != -3 )
                {
                  if ( v51 - 32 > 0x5E && v51 <= 0x9F )
                    v51 = 32;
                  v17 = encode_utf8(v51);
                  add_to_string(&image, v17);
                }
                goto LABEL_40;
              }
              if ( v4->opt.charsets[0] == -1 )
              {
                if ( !v19 && (v51 == 127 || v51 <= 0x1F) )
LABEL_160:
                  add_char_to_string(&image, 0x20u);
                else
                  add_char_to_string(&image, v51);
LABEL_40:
                if ( ++v14 > pos )
                  goto LABEL_74;
                continue;
              }
              if ( !v19 && (v51 == 127 || v51 <= 0x1F) )
                goto LABEL_160;
              ++v14;
              v30 = cp2utf8(*(int *)((char *)v4->opt.charsets + (v19 != 0 ? 4 : 0)), v51);
              add_to_string(&image, v30);
              if ( v14 > pos )
                goto LABEL_74;
            }
          }
LABEL_410:
          v158 = -1;
          if ( !image.length )
            goto LABEL_179;
LABEL_79:
          if ( v4->opt.color_mode )
            add_bytes_to_string___5(&image, "\x1B[37;40m", 8);
          add_bytes_to_string___5(&image, "\x1B[0m", 4);
          if ( v158 )
          {
            v31 = v4->opt.frame_seqs;
            if ( v31 )
              add_bytes_to_string___5(&image, v31->source, v31->length);
          }
          if ( image.length )
          {
            cx = screen->cx;
            cy = screen->cy;
          }
          else
          {
LABEL_179:
            cx = screen->cx;
            if ( cx == screen->lcx )
            {
              cy = screen->cy;
              if ( cy == screen->lcy )
              {
LABEL_95:
                done_string(&image);
                memcpy(screen->last_image, screen->image, 8 * term->width * term->height);
                height = term->height;
                screen->dirty_to = 0;
                screen->dirty_from = height;
                return;
              }
            }
            else
            {
              cy = screen->cy;
            }
          }
          screen->lcy = cy;
          screen->lcx = cx;
          slen = 2;
          s = 27;
          v227 = 91;
          if ( elinks_ulongcat(&s, &slen, cy + 1, 0xAu, 0, 0xAu, 0) >= 0 )
          {
            v34 = slen;
            *(&s + slen) = 59;
            slen = v34 + 1;
            if ( elinks_ulongcat(&s, &slen, cx + 1, 0xAu, 0, 0xAu, 0) >= 0 )
            {
              v35 = slen;
              *(&s + slen) = 72;
              slen = v35 + 1;
              add_bytes_to_string___5(&image, &s, v35 + 1);
            }
          }
          v36 = image.length;
          if ( image.length )
          {
            if ( (*((_BYTE *)term + 56) & 1) != 0 )
            {
              want_draw();
              v36 = image.length;
            }
            hard_write(term->fdout, image.source, v36);
            if ( (*((_BYTE *)term + 56) & 1) != 0 )
              done_draw();
          }
          goto LABEL_95;
        }
LABEL_101:
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/screen.c";
        errline = 1091;
        elinks_internal("Invalid color mode (%d).", v4->opt.color_mode);
        return;
      }
      screen_0a = term->screen;
      v65 = term->width;
      v66 = screen_0a->dirty_from;
      xmax_0a = v65 - 1;
      ymaxa = term->height - 1;
      prev_ye = (int)screen_0a->last_image;
      v67 = screen_0a->image;
      dirty_to = screen_0a->dirty_to;
      if ( ymaxa < dirty_to )
      {
        screen_0a->dirty_to = ymaxa;
        dirty_to = ymaxa;
      }
      if ( v66 > dirty_to )
        goto LABEL_410;
      numbera = v66 + 1;
      v69 = -1;
      v158 = -1;
      sizee = 0;
      v70 = v66 * v65;
      currenta = (screen_char *)(v70 * 8 + prev_ye);
      v71 = 0;
      pos_0c = &v67[v70];
      v202 = -1;
      lengthb = -1;
      while ( 1 )
      {
        v137 = numbera;
        v72 = numbera - 1;
        if ( xmax_0a >= 0 )
        {
          v131 = ymaxa == v72;
          if ( ymaxa != v72 || xmax_0a )
            break;
        }
LABEL_258:
        ++numbera;
        if ( screen_0a->dirty_to < v137 )
          goto LABEL_79;
      }
      v156 = 1;
      v137 = numbera;
      while ( 1 )
      {
        if ( pos_0c->color[1] != currenta->color[1] )
          goto LABEL_192;
        if ( pos_0c->color[0] == currenta->color[0] )
        {
          prev_yi = pos_0c->data;
          if ( pos_0c->data == currenta->data )
          {
            xmaxa = v156;
            if ( pos_0c->attr == currenta->attr )
              goto LABEL_255;
          }
        }
        else
        {
          prev_yi = pos_0c->data;
        }
        if ( prev_yi > 0x20 || currenta->data > 0x20 || (xmaxa = v156, pos_0c->attr != currenta->attr) )
        {
LABEL_192:
          if ( v69 != numbera - 1 || &v71[10] <= pos_0c )
          {
            slen = 2;
            s = 27;
            xmaxa = v156;
            v227 = 91;
            if ( elinks_ulongcat(&s, &slen, numbera, 0xAu, 0, 0xAu, 0) >= 0 )
            {
              v86 = slen;
              *(&s + slen) = 59;
              slen = v86 + 1;
              if ( elinks_ulongcat(&s, &slen, v156, 0xAu, 0, 0xAu, 0) >= 0 )
              {
                v87 = slen + 1;
                *(&s + slen) = 72;
                slen = v87;
                add_bytes_to_string___5(&image, &s, v87);
              }
            }
            v71 = pos_0c;
LABEL_194:
            while ( 2 )
            {
              v73 = *((_BYTE *)&v4->opt + 24);
              v74 = v71->attr;
              v188 = v73 & 2;
              if ( (v73 & 2) != 0 && v71->data == -3 )
                goto LABEL_261;
              prev_yf = v74 ^ sizee;
              if ( (unsigned __int8)v74 != sizee )
              {
                if ( ((v74 ^ sizee) & 0x80u) != 0 && (v85 = v4->opt.frame_seqs) != 0 )
                {
                  v158 = (unsigned __int8)v74 >> 7;
                  add_bytes_to_string___5(
                    &image,
                    v85[(unsigned __int8)v74 >> 7].source,
                    v85[(unsigned __int8)v74 >> 7].length);
                  v74 = v71->attr;
                  sizee = v71->attr;
                }
                else
                {
                  sizee = v71->attr;
                }
                if ( (prev_yf & 0x20) != 0 )
                {
                  v75 = v4->opt.underline;
                  if ( v75 )
                  {
                    add_bytes_to_string___5(
                      &image,
                      *(const unsigned __int8 **)((char *)&v75->source + ((v74 >> 2) & 8)),
                      *(int *)((char *)&v75->length + ((v74 >> 2) & 8)));
                    sizee = v71->attr;
                    LOBYTE(v74) = sizee;
                  }
                }
                if ( (prev_yf & 8) != 0 )
                {
                  if ( (sizee & 8) == 0 )
                  {
                    v202 = v71->color[0] + 1;
                    goto LABEL_205;
                  }
                  add_bytes_to_string___5(&image, "\x1B[1m", 4);
                  LOBYTE(v74) = v71->attr;
                }
                sizee = v74;
LABEL_205:
                v73 = *((_BYTE *)&v4->opt + 24);
                v188 = v73 & 2;
              }
              if ( v188 && v71->data == -3 )
              {
LABEL_261:
                posc = v71->attr;
                v81 = -3;
                v189 = lengthb;
                goto LABEL_234;
              }
              prev_yg = v71->color[0];
              if ( v202 == prev_yg )
              {
                v189 = v71->color[1];
                if ( v189 == lengthb )
                {
                  posc = v71->attr;
                  v81 = v71->data;
                  goto LABEL_234;
                }
              }
              else
              {
                v189 = v71->color[1];
              }
              v76 = 0;
              v203 = 2;
              lengthc = 10;
              if ( *color256_seqs[0].source != 37 )
              {
                do
                  ++v76;
                while ( color256_seqs[0].source[v76] != 37 );
                lengthc = 12 - (v76 + 2);
                v203 = v76 + 2;
              }
              add_bytes_to_string___5(&image, color256_seqs[0].source, v76);
              if ( (unsigned __int8)prev_yg <= 9u )
              {
                posa = &bytes[2];
                v112 = prev_yg;
                v77 = 1;
              }
              else
              {
                if ( (unsigned __int8)prev_yg > 0x63u )
                {
                  v77 = 3;
                  if ( (unsigned __int8)prev_yg > 0xC7u )
                  {
                    bytes[0] = 50;
                    posa = bytes;
                    v163 = prev_yg + 56;
                  }
                  else
                  {
                    bytes[0] = 49;
                    posa = bytes;
                    v163 = prev_yg - 100;
                  }
                }
                else
                {
                  v77 = 2;
                  posa = &bytes[1];
                  v163 = prev_yg;
                }
                bytes[1] = (unsigned __int8)v163 / 0xAu + 48;
                v112 = (unsigned __int8)v163 % 0xAu;
              }
              bytes[2] = v112 + 48;
              add_bytes_to_string___5(&image, posa, v77);
              add_bytes_to_string___5(&image, &color256_seqs[0].source[v203], lengthc);
              if ( (*((_BYTE *)&v4->opt + 24) & 1) != 0 )
              {
                v204 = v71->color[1];
                if ( v204 )
                  goto LABEL_218;
              }
              else
              {
                v204 = v71->color[1];
LABEL_218:
                v78 = 0;
                posb = 2;
                lengthd = 8;
                if ( *color256_seqs[1].source != 37 )
                {
                  do
                    ++v78;
                  while ( color256_seqs[1].source[v78] != 37 );
                  lengthd = 10 - (v78 + 2);
                  posb = v78 + 2;
                }
                add_bytes_to_string___5(&image, color256_seqs[1].source, v78);
                if ( v204 <= 9u )
                {
                  v79 = 1;
                  v164 = &bytes[2];
                  v113 = v204;
                }
                else
                {
                  v79 = 2;
                  v164 = &bytes[1];
                  if ( v204 > 0x63u )
                  {
                    if ( v204 > 0xC7u )
                    {
                      v79 = 3;
                      bytes[0] = 50;
                      v204 += 56;
                    }
                    else
                    {
                      v204 -= 100;
                      LOBYTE(v79) = 3;
                      bytes[0] = 49;
                    }
                    v164 = bytes;
                  }
                  bytes[1] = v204 / 0xAu + 48;
                  v113 = v204 % 0xAu;
                }
                bytes[2] = v113 + 48;
                add_bytes_to_string___5(&image, v164, v79);
                add_bytes_to_string___5(&image, &color256_seqs[1].source[posb], lengthd);
              }
              posc = v71->attr;
              if ( (posc & 8) != 0 )
              {
                add_bytes_to_string___5(&image, "\x1B[1m", 4);
                posc = v71->attr;
              }
              if ( (posc & 0x20) != 0 )
              {
                v80 = v4->opt.underline;
                if ( !v80 )
                {
                  v81 = v71->data;
                  v202 = prev_yg;
                  v73 = *((_BYTE *)&v4->opt + 24);
                  goto LABEL_234;
                }
                add_bytes_to_string___5(&image, v80[1].source, v80[1].length);
                posc = v71->attr;
              }
              v81 = v71->data;
              v202 = prev_yg;
              v73 = *((_BYTE *)&v4->opt + 24);
LABEL_234:
              prev_yh = posc & 0x80;
              if ( (posc & 0x80) != 0 )
              {
                v82 = v4->opt.frame;
                if ( v81 > 0xAF && v82 && v81 <= 0xDF )
                  v81 = v82[v81 - 176];
              }
              if ( (v73 & 2) != 0 )
              {
                if ( prev_yh )
                  v81 = cp2u(v4->opt.charsets[1], v81);
                if ( v81 != -3 )
                {
                  if ( v81 - 32 > 0x5E && v81 <= 0x9F )
                    v81 = 32;
                  v83 = encode_utf8(v81);
                  add_to_string(&image, v83);
                }
                goto LABEL_247;
              }
              if ( v4->opt.charsets[0] == -1 )
              {
                if ( !prev_yh && (v81 == 127 || v81 <= 0x1F) )
                  goto LABEL_277;
                add_char_to_string(&image, v81);
              }
              else
              {
                if ( prev_yh || v81 != 127 && v81 > 0x1F )
                {
                  ++v71;
                  v84 = cp2utf8(*(int *)((char *)v4->opt.charsets + (posc < 0 ? 4 : 0)), v81);
                  add_to_string(&image, v84);
                  if ( v71 > pos_0c )
                  {
LABEL_254:
                    v69 = numbera - 1;
                    lengthb = v189;
                    goto LABEL_255;
                  }
                  goto LABEL_248;
                }
LABEL_277:
                add_char_to_string(&image, 0x20u);
              }
LABEL_247:
              if ( ++v71 > pos_0c )
                goto LABEL_254;
LABEL_248:
              lengthb = v189;
              continue;
            }
          }
          xmaxa = v156;
          if ( pos_0c >= v71 )
            goto LABEL_194;
        }
LABEL_255:
        ++currenta;
        ++pos_0c;
        if ( xmax_0a >= v156 )
        {
          ++v156;
          if ( xmax_0a != xmaxa || !v131 )
            continue;
        }
        goto LABEL_258;
      }
    }
    screen_0b = term->screen;
    v88 = screen_0b->dirty_from;
    v89 = term->width;
    xmaxb = v89 - 1;
    ymaxb = term->height - 1;
    prev_yj = (int)screen_0b->last_image;
    v90 = screen_0b->image;
    if ( ymaxb < screen_0b->dirty_to )
      screen_0b->dirty_to = ymaxb;
    if ( v88 > screen_0b->dirty_to )
      goto LABEL_410;
    v91 = v88 * v89;
    numberb = v88 + 1;
    v92 = -1;
    v158 = -1;
    v91 *= 8;
    v93 = (screen_char *)(v91 + prev_yj);
    v94 = (screen_char *)((char *)v90 + v91);
    v95 = 0;
    currentb = v93;
    pos_0d = v94;
    sizef = 0;
    v205 = -1;
    lengthe = -1;
    while ( 1 )
    {
      v138 = numberb;
      v96 = numberb - 1;
      if ( xmaxb >= 0 )
      {
        v132 = ymaxb == v96;
        if ( ymaxb != v96 || xmaxb )
          break;
      }
LABEL_371:
      ++numberb;
      if ( screen_0b->dirty_to < v138 )
        goto LABEL_79;
    }
    v157 = 1;
    v138 = numberb;
    while ( 1 )
    {
      if ( pos_0d->color[1] != currentb->color[1] )
        goto LABEL_304;
      if ( pos_0d->color[0] == currentb->color[0] )
      {
        prev_yn = pos_0d->data;
        if ( pos_0d->data == currentb->data )
        {
          v146 = v157;
          if ( pos_0d->attr == currentb->attr )
            goto LABEL_368;
        }
      }
      else
      {
        prev_yn = pos_0d->data;
      }
      if ( prev_yn > 0x20 || currentb->data > 0x20 || (v146 = v157, pos_0d->attr != currentb->attr) )
      {
LABEL_304:
        if ( numberb - 1 != v92 || &v95[10] <= pos_0d )
        {
          slen = 2;
          s = 27;
          v146 = v157;
          v227 = 91;
          if ( elinks_ulongcat(&s, &slen, numberb, 0xAu, 0, 0xAu, 0) >= 0 )
          {
            v110 = slen;
            *(&s + slen) = 59;
            slen = v110 + 1;
            if ( elinks_ulongcat(&s, &slen, v157, 0xAu, 0, 0xAu, 0) >= 0 )
            {
              v111 = slen + 1;
              *(&s + slen) = 72;
              slen = v111;
              add_bytes_to_string___5(&image, &s, v111);
            }
          }
          v95 = pos_0d;
LABEL_306:
          while ( 2 )
          {
            v97 = *((_BYTE *)&v4->opt + 24);
            v98 = v95->attr;
            v190 = v97 & 2;
            if ( (v97 & 2) != 0 && v95->data == -3 )
              goto LABEL_374;
            prev_yk = v98 ^ sizef;
            if ( (unsigned __int8)v98 != sizef )
            {
              if ( ((v98 ^ sizef) & 0x80u) != 0 && (v109 = v4->opt.frame_seqs) != 0 )
              {
                v158 = (unsigned __int8)v98 >> 7;
                add_bytes_to_string___5(
                  &image,
                  v109[(unsigned __int8)v98 >> 7].source,
                  v109[(unsigned __int8)v98 >> 7].length);
                v98 = v95->attr;
                sizef = v95->attr;
              }
              else
              {
                sizef = v95->attr;
              }
              if ( (prev_yk & 0x20) != 0 )
              {
                v99 = v4->opt.underline;
                if ( v99 )
                {
                  add_bytes_to_string___5(
                    &image,
                    *(const unsigned __int8 **)((char *)&v99->source + ((v98 >> 2) & 8)),
                    *(int *)((char *)&v99->length + ((v98 >> 2) & 8)));
                  sizef = v95->attr;
                  LOBYTE(v98) = sizef;
                }
              }
              if ( (prev_yk & 8) != 0 )
              {
                if ( (sizef & 8) == 0 )
                {
                  v205 = v95->color[0] + 1;
                  goto LABEL_317;
                }
                add_bytes_to_string___5(&image, "\x1B[1m", 4);
                LOBYTE(v98) = v95->attr;
              }
              sizef = v98;
LABEL_317:
              v97 = *((_BYTE *)&v4->opt + 24);
              v190 = v97 & 2;
            }
            if ( v190 && v95->data == -3 )
            {
LABEL_374:
              posf = v95->attr;
              v105 = -3;
              v191 = lengthe;
              goto LABEL_346;
            }
            prev_yl = v95->color[0];
            if ( v205 == prev_yl )
            {
              v191 = v95->color[1];
              if ( v191 == lengthe )
              {
                posf = v95->attr;
                v105 = v95->data;
                goto LABEL_346;
              }
            }
            else
            {
              v191 = v95->color[1];
            }
            v100 = 0;
            v206 = 2;
            lengthf = 10;
            if ( *color256_seqs[0].source != 37 )
            {
              do
                ++v100;
              while ( color256_seqs[0].source[v100] != 37 );
              lengthf = 12 - (v100 + 2);
              v206 = v100 + 2;
            }
            add_bytes_to_string___5(&image, color256_seqs[0].source, v100);
            if ( (unsigned __int8)prev_yl <= 9u )
            {
              posd = &bytes[2];
              v114 = prev_yl;
              v101 = 1;
            }
            else
            {
              if ( (unsigned __int8)prev_yl > 0x63u )
              {
                v101 = 3;
                if ( (unsigned __int8)prev_yl > 0xC7u )
                {
                  bytes[0] = 50;
                  posd = bytes;
                  v165 = prev_yl + 56;
                }
                else
                {
                  bytes[0] = 49;
                  posd = bytes;
                  v165 = prev_yl - 100;
                }
              }
              else
              {
                v101 = 2;
                posd = &bytes[1];
                v165 = prev_yl;
              }
              bytes[1] = (unsigned __int8)v165 / 0xAu + 48;
              v114 = (unsigned __int8)v165 % 0xAu;
            }
            bytes[2] = v114 + 48;
            add_bytes_to_string___5(&image, posd, v101);
            add_bytes_to_string___5(&image, &color256_seqs[0].source[v206], lengthf);
            if ( (*((_BYTE *)&v4->opt + 24) & 1) != 0 )
            {
              v207 = v95->color[1];
              if ( v207 )
                goto LABEL_330;
            }
            else
            {
              v207 = v95->color[1];
LABEL_330:
              v102 = 0;
              pose = 2;
              lengthg = 8;
              if ( *color256_seqs[1].source != 37 )
              {
                do
                  ++v102;
                while ( color256_seqs[1].source[v102] != 37 );
                lengthg = 10 - (v102 + 2);
                pose = v102 + 2;
              }
              add_bytes_to_string___5(&image, color256_seqs[1].source, v102);
              if ( v207 <= 9u )
              {
                v103 = 1;
                v166 = &bytes[2];
                v115 = v207;
              }
              else
              {
                v103 = 2;
                v166 = &bytes[1];
                if ( v207 > 0x63u )
                {
                  if ( v207 > 0xC7u )
                  {
                    v103 = 3;
                    bytes[0] = 50;
                    v207 += 56;
                  }
                  else
                  {
                    v207 -= 100;
                    LOBYTE(v103) = 3;
                    bytes[0] = 49;
                  }
                  v166 = bytes;
                }
                bytes[1] = v207 / 0xAu + 48;
                v115 = v207 % 0xAu;
              }
              bytes[2] = v115 + 48;
              add_bytes_to_string___5(&image, v166, v103);
              add_bytes_to_string___5(&image, &color256_seqs[1].source[pose], lengthg);
            }
            posf = v95->attr;
            if ( (posf & 8) != 0 )
            {
              add_bytes_to_string___5(&image, "\x1B[1m", 4);
              posf = v95->attr;
            }
            if ( (posf & 0x20) != 0 )
            {
              v104 = v4->opt.underline;
              if ( !v104 )
              {
                v105 = v95->data;
                v205 = prev_yl;
                v97 = *((_BYTE *)&v4->opt + 24);
                goto LABEL_346;
              }
              add_bytes_to_string___5(&image, v104[1].source, v104[1].length);
              posf = v95->attr;
            }
            v105 = v95->data;
            v205 = prev_yl;
            v97 = *((_BYTE *)&v4->opt + 24);
LABEL_346:
            prev_ym = posf & 0x80;
            if ( (posf & 0x80) != 0 )
            {
              v106 = v4->opt.frame;
              if ( v105 > 0xAF && v106 && v105 <= 0xDF )
                v105 = v106[v105 - 176];
            }
            if ( (v97 & 2) != 0 )
            {
              if ( prev_ym )
                v105 = cp2u(v4->opt.charsets[1], v105);
              if ( v105 != -3 )
              {
                if ( v105 - 32 > 0x5E && v105 <= 0x9F )
                  v105 = 32;
                v107 = encode_utf8(v105);
                add_to_string(&image, v107);
              }
              goto LABEL_359;
            }
            if ( v4->opt.charsets[0] == -1 )
            {
              if ( !prev_ym && (v105 == 127 || v105 <= 0x1F) )
                goto LABEL_390;
              add_char_to_string(&image, v105);
            }
            else
            {
              if ( prev_ym || v105 != 127 && v105 > 0x1F )
              {
                ++v95;
                v108 = cp2utf8(*(int *)((char *)v4->opt.charsets + (posf < 0 ? 4 : 0)), v105);
                add_to_string(&image, v108);
                if ( v95 > pos_0d )
                {
LABEL_366:
                  lengthe = v191;
                  goto LABEL_367;
                }
                goto LABEL_360;
              }
LABEL_390:
              add_char_to_string(&image, 0x20u);
            }
LABEL_359:
            if ( ++v95 > pos_0d )
              goto LABEL_366;
LABEL_360:
            lengthe = v191;
            continue;
          }
        }
        v146 = v157;
        if ( pos_0d >= v95 )
          goto LABEL_306;
LABEL_367:
        v92 = numberb - 1;
      }
LABEL_368:
      ++currentb;
      ++pos_0d;
      if ( xmaxb >= v157 )
      {
        ++v157;
        if ( xmaxb != v146 || !v132 )
          continue;
      }
      goto LABEL_371;
    }
  }
}

//----- (080E2740) --------------------------------------------------------
int __cdecl number_of_tabs(terminal *term)
{
  int result; // eax
  terminal *i; // edx
  bool v3; // zf

  result = 0;
  for ( i = (terminal *)term->windows.next; i != (terminal *)&term->windows; result += v3 )
  {
    v3 = i->windows.next == (void *)1;
    i = i->next;
  }
  return result;
}

//----- (080E2770) --------------------------------------------------------
int __cdecl get_tab_number(window *window)
{
  terminal *term; // ecx
  _DWORD *prev; // edx
  list_head_elinks *p_windows; // ecx
  int result; // eax

  term = window->term;
  prev = term->windows.prev;
  p_windows = &term->windows;
  if ( prev == (_DWORD *)p_windows )
    return 0;
  for ( result = 0; ; ++result )
  {
    while ( prev[2] != 1 )
    {
      prev = (_DWORD *)prev[1];
      if ( prev == (_DWORD *)p_windows )
        return 0;
    }
    if ( prev == (_DWORD *)window )
      break;
    prev = (_DWORD *)prev[1];
    if ( prev == (_DWORD *)p_windows )
      return 0;
  }
  return result;
}

//----- (080E27B0) --------------------------------------------------------
int __cdecl get_tab_number_by_xpos(terminal *term, int xpos)
{
  terminal *prev; // edx
  int result; // eax
  int screen; // ecx

  prev = (terminal *)term->windows.prev;
  if ( prev != (terminal *)&term->windows )
  {
    result = 0;
    do
    {
      if ( prev->windows.next == (void *)1 )
      {
        screen = (int)prev->screen;
        if ( screen <= xpos && xpos < (int)prev->main_menu + screen )
          return result;
        ++result;
      }
      prev = prev->prev;
    }
    while ( &term->windows != (list_head_elinks *)prev );
  }
  return -1;
}

//----- (080E27F0) --------------------------------------------------------
window *__cdecl get_tab_by_number(terminal *term, int num)
{
  window *result; // eax
  window *p_windows; // edx
  window *v5; // [esp+1Ch] [ebp-Ch]

  result = (window *)term->windows.prev;
  p_windows = (window *)&term->windows;
  if ( result != (window *)&term->windows )
  {
    do
    {
      while ( result->type != WINDOW_TAB )
      {
        result = result->prev;
        if ( result == p_windows )
          goto LABEL_7;
      }
      if ( !num )
        break;
      result = result->prev;
      --num;
    }
    while ( result != p_windows );
  }
LABEL_7:
  if ( assert_failed
    || (assert_failed = result == p_windows) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c",
        errline = 111,
        v5 = result,
        elinks_internal("assertion (LIST_OF(struct window) *) win != &term->windows failed: tab number out of range"),
        result = v5,
        assert_failed) )
  {
    assert_failed = 0;
    return (window *)term->windows.next;
  }
  return result;
}

//----- (080E28A0) --------------------------------------------------------
void __cdecl open_uri_in_new_tab(session *ses, uri *uri, int in_background, int based)
{
  int v4; // edx
  session *v5; // ebx

  v4 = based;
  v5 = ses;
  if ( !assert_failed )
  {
    assert_failed = ses == 0;
    if ( !ses )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 261;
      elinks_internal("assertion ses failed!");
      v4 = based;
    }
  }
  if ( !v4 )
    v5 = 0;
  init_session(v5, ses->tab->term, uri, in_background);
}

//----- (080E2930) --------------------------------------------------------
void __cdecl open_current_link_in_new_tab(session *ses, int in_background)
{
  document_view *v2; // eax
  int current_link; // edx
  document *document; // ecx
  link *v5; // edx
  uri *link_uri; // edi
  document_view *v7; // [esp+1Ch] [ebp-1Ch]

  v2 = current_frame(ses);
  if ( v2 )
  {
    if ( assert_failed )
    {
LABEL_13:
      assert_failed = 0;
      return;
    }
    if ( v2->vs && v2->document )
    {
      assert_failed = 0;
      goto LABEL_6;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
    errline = 285;
    v7 = v2;
    elinks_internal("assertion doc_view->vs && doc_view->document failed!");
    v2 = v7;
  }
  if ( assert_failed )
    goto LABEL_13;
  if ( !v2 )
  {
LABEL_16:
    open_uri_in_new_tab(ses, 0, in_background, 1);
    return;
  }
LABEL_6:
  current_link = v2->vs->current_link;
  if ( current_link < 0 )
    goto LABEL_16;
  document = v2->document;
  if ( current_link >= document->nlinks )
    goto LABEL_16;
  v5 = &document->links[current_link];
  if ( !v5 )
    goto LABEL_16;
  link_uri = get_link_uri(ses, v2, v5);
  open_uri_in_new_tab(ses, link_uri, in_background, 1);
  if ( link_uri )
    done_uri(link_uri);
}

//----- (080E2A70) --------------------------------------------------------
void __cdecl delayed_open_0(void *data)
{
  if ( !assert_failed )
  {
    assert_failed = data == 0;
    if ( !data )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 272;
      elinks_internal("assertion deo failed!");
    }
  }
  open_uri_in_new_tab(*(session **)data, *((uri **)data + 1), 0, 0);
  done_uri(*((uri **)data + 1));
  mem_free(data);
}

//----- (080E2B00) --------------------------------------------------------
void __cdecl really_close_tabs(void *ses_)
{
  terminal *v1; // ebx
  window *p_windows; // edi
  window *next; // esi
  int v4; // edx
  window **p_next; // esi
  window *current_tab; // [esp+1Ch] [ebp-1Ch]

  v1 = *(terminal **)(*((_DWORD *)ses_ + 2) + 20);
  p_windows = (window *)&v1->windows;
  current_tab = get_tab_by_number(v1, v1->current_tab);
  next = (window *)v1->windows.next;
  if ( next != (window *)&v1->windows )
  {
    do
    {
      while ( next->type != WINDOW_TAB || next == current_tab )
      {
        next = next->next;
        if ( next == p_windows )
          goto LABEL_9;
      }
      v4 = v1->current_tab;
      if ( v4 > 0 )
        v1->current_tab = v4 - 1;
      p_next = &next->prev->next;
      delete_window(*p_next);
      next = *p_next;
    }
    while ( next != p_windows );
  }
LABEL_9:
  redraw_terminal(v1);
}

//----- (080E2B80) --------------------------------------------------------
void __cdecl close_all_tabs_but_current(session *ses)
{
  if ( assert_failed
    || (assert_failed = ses == 0, !ses)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c",
        errline = 240,
        elinks_internal("assertion ses failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( get_opt_(config_options, "ui.tabs.confirm_close")->number )
  {
    msg_box(
      ses->tab->term,
      0,
      (msgbox_flags)0,
      (unsigned __int8 *)"Close tab",
      ALIGN_CENTER,
      "Do you really want to close all except the current tab?",
      ses,
      2,
      "~Yes",
      really_close_tabs,
      1,
      "~No",
      0,
      2);
  }
  else
  {
    really_close_tabs(ses);
  }
}

//----- (080E2CA0) --------------------------------------------------------
void __cdecl switch_to_tab(terminal *term, int tab, int tabs_count)
{
  int v3; // ebx
  int v4; // edi
  terminal_screen *screen; // eax
  int height; // edx
  terminal *next; // eax
  bool v8; // zf
  int v9; // ebx

  v3 = tabs_count;
  v4 = tab;
  if ( tabs_count < 0 )
  {
    next = (terminal *)term->windows.next;
    if ( next == (terminal *)&term->windows )
      goto LABEL_7;
    v3 = 0;
    do
    {
      v8 = next->windows.next == (void *)1;
      next = next->next;
      v3 += v8;
    }
    while ( next != (terminal *)&term->windows );
  }
  if ( v3 <= 1 )
    goto LABEL_7;
  if ( get_opt_(config_options, "ui.tabs.wraparound")->number )
  {
    v4 = tab % v3;
    if ( tab % v3 < 0 )
      v4 += v3;
LABEL_8:
    if ( term->current_tab == v4 )
      return;
    goto LABEL_9;
  }
  if ( tab < 0 )
  {
LABEL_7:
    v4 = 0;
    goto LABEL_8;
  }
  v9 = v3 - 1;
  if ( v9 < tab )
    v4 = v9;
  if ( term->current_tab != v4 )
  {
LABEL_9:
    screen = term->screen;
    term->current_tab = v4;
    height = term->height;
    if ( screen->dirty_from > 0 )
      screen->dirty_from = 0;
    if ( height > screen->dirty_to )
      screen->dirty_to = height;
    redraw_terminal(term);
  }
}

//----- (080E2D70) --------------------------------------------------------
void __cdecl move_current_tab(session *ses, int direction)
{
  int v2; // ebx
  terminal *term; // edi
  list_head_elinks *i; // eax
  bool v5; // zf
  window *tab_by_number; // eax
  session *v7; // edx
  window *v8; // esi
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  window *v12; // eax
  int v13; // edx
  window *prev; // eax
  window *next; // ecx
  int v16; // [esp+1Ch] [ebp-1Ch]
  session *v17; // [esp+1Ch] [ebp-1Ch]
  session *v18; // [esp+1Ch] [ebp-1Ch]

  v2 = 0;
  term = ses->tab->term;
  for ( i = (list_head_elinks *)term->windows.next; i != &term->windows; v2 += v5 )
  {
    v5 = i[1].next == (void *)1;
    i = (list_head_elinks *)i->next;
  }
  tab_by_number = get_tab_by_number(term, term->current_tab);
  v7 = ses;
  v8 = tab_by_number;
  if ( !assert_failed )
  {
    assert_failed = direction == 0;
    if ( !direction )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 305;
      elinks_internal("assertion ses && direction failed!");
      v7 = ses;
    }
  }
  v9 = eat_kbd_repeat_count(v7);
  v10 = v9 * direction;
  if ( !v9 )
    v10 = direction;
  v16 = term->current_tab + v10;
  if ( get_opt_(config_options, "ui.tabs.wraparound")->number )
  {
    v11 = v16 % v2;
    if ( v16 % v2 < 0 )
      v11 += v2;
  }
  else
  {
    v11 = 0;
    if ( v16 >= 0 )
    {
      v11 = v2 - 1;
      if ( v16 <= v2 - 1 )
        v11 = v16;
    }
  }
  if ( !assert_failed )
  {
    if ( v11 >= 0 && v2 > v11 )
    {
      assert_failed = 0;
    }
    else
    {
      v17 = (session *)v11;
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
      errline = 318;
      elinks_internal("assertion 0 <= new_pos && new_pos < tabs failed!");
      v11 = (int)v17;
    }
  }
  if ( term->current_tab != v11 )
  {
    v8->next->prev = v8->prev;
    v8->prev->next = v8->next;
    if ( v11 )
    {
      v18 = (session *)v11;
      v12 = get_tab_by_number(term, v11 - 1);
      v13 = (int)v18;
      prev = v12->prev;
    }
    else
    {
      prev = get_tab_by_number(term, 0);
      v13 = 0;
    }
    next = prev->next;
    v8->prev = prev;
    v8->next = next;
    prev->next = v8;
    v8->next->prev = v8;
    switch_to_tab(term, v13, v2);
  }
}

//----- (080E2F40) --------------------------------------------------------
void __cdecl really_close_tab(void *ses_)
{
  terminal *v1; // ebx
  window *tab_by_number; // eax
  window *v3; // edx
  list_head_elinks *next; // eax
  int v5; // edx
  int v6; // ecx
  bool v7; // zf

  v1 = *(terminal **)(*((_DWORD *)ses_ + 2) + 20);
  tab_by_number = get_tab_by_number(v1, v1->current_tab);
  v3 = (window *)*((_DWORD *)ses_ + 2);
  if ( tab_by_number == v3 )
  {
    next = (list_head_elinks *)v1->windows.next;
    v5 = 0;
    v6 = -1;
    if ( next != &v1->windows )
    {
      do
      {
        v7 = next[1].next == (void *)1;
        next = (list_head_elinks *)next->next;
        v5 += v7;
      }
      while ( next != &v1->windows );
      v6 = v5 - 1;
    }
    switch_to_tab(v1, v1->current_tab - 1, v6);
    v3 = (window *)*((_DWORD *)ses_ + 2);
  }
  delete_window(v3);
}

//----- (080E2FD0) --------------------------------------------------------
void __cdecl switch_current_tab(session *ses, int direction)
{
  terminal *term; // esi
  list_head_elinks *next; // eax
  int v4; // ebx
  bool v5; // zf
  int v6; // eax
  int v7; // edx
  int v8; // eax

  term = ses->tab->term;
  next = (list_head_elinks *)term->windows.next;
  if ( next != &term->windows )
  {
    v4 = 0;
    do
    {
      v5 = next[1].next == (void *)1;
      next = (list_head_elinks *)next->next;
      v4 += v5;
    }
    while ( next != &term->windows );
    if ( v4 > 1 )
    {
      v6 = eat_kbd_repeat_count(ses);
      v7 = v6 * direction;
      v5 = v6 == 0;
      v8 = direction;
      if ( !v5 )
        v8 = v7;
      switch_to_tab(term, term->current_tab + v8, v4);
    }
  }
}

//----- (080E3040) --------------------------------------------------------
void __cdecl close_tab(terminal *term, session *ses)
{
  terminal *next; // eax
  int v3; // edx
  bool v4; // zf

  next = (terminal *)term->windows.next;
  if ( next == (terminal *)&term->windows )
    goto LABEL_8;
  v3 = 0;
  do
  {
    v4 = next->windows.next == (void *)1;
    next = next->next;
    v3 += v4;
  }
  while ( next != (terminal *)&term->windows );
  if ( v3 <= 1 )
  {
LABEL_8:
    query_exit(ses);
  }
  else if ( get_opt_(config_options, "ui.tabs.confirm_close")->number )
  {
    msg_box(
      term,
      0,
      (msgbox_flags)0,
      (unsigned __int8 *)"Close tab",
      ALIGN_CENTER,
      "Do you really want to close the current tab?",
      ses,
      2,
      "~Yes",
      really_close_tab,
      1,
      "~No",
      0,
      2);
  }
  else
  {
    really_close_tab(ses);
  }
}

//----- (080E3130) --------------------------------------------------------
window *__cdecl init_tab(terminal *term, void *data, window_handler_T *handler)
{
  window *result; // eax
  terminal *next; // edx
  window *prev; // edx
  window *v6; // ecx
  menu *main_menu; // ecx
  window *v8; // [esp+1Ch] [ebp-Ch]

  result = (window *)mem_calloc(1u, 0x2Cu);
  if ( result )
  {
    result->term = term;
    result->handler = handler;
    *((_BYTE *)result + 40) |= 1u;
    result->type = WINDOW_TAB;
    result->data = data;
    next = (terminal *)term->windows.next;
    if ( next == (terminal *)&term->windows )
    {
LABEL_9:
      if ( !assert_failed )
      {
        main_menu = term->main_menu;
        assert_failed = main_menu != 0;
        if ( main_menu )
        {
          v8 = result;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/tab.c";
          errline = 53;
          elinks_internal("assertion term->main_menu == NULL failed!");
          result = v8;
        }
      }
      prev = (window *)term->windows.prev;
    }
    else
    {
      while ( next->windows.next != (void *)1 )
      {
        next = next->next;
        if ( next == (terminal *)&term->windows )
          goto LABEL_9;
      }
      prev = (window *)next->prev;
    }
    v6 = prev->next;
    result->prev = prev;
    result->next = v6;
    prev->next = result;
    result->next->prev = result;
  }
  return result;
}

//----- (080E31F0) --------------------------------------------------------
void close_terminal_pipes()
{
  close(terminal_pipe[0]);
  close(terminal_pipe[1]);
}

//----- (080E3220) --------------------------------------------------------
int check_terminal_pipes()
{
  return c_pipe(terminal_pipe);
}

//----- (080E3240) --------------------------------------------------------
int __cdecl get_terminal_codepage(const terminal *term)
{
  return get_opt_(term->spec, "charset")->number;
}

//----- (080E3260) --------------------------------------------------------
void __cdecl close_handle(void *h)
{
  close((int)h);
  set_handlers((int)h, 0, 0, 0, 0);
}

//----- (080E32A0) --------------------------------------------------------
void __cdecl exec_on_terminal(terminal *term, unsigned __int8 *path, unsigned __int8 *delete, term_exec fg)
{
  const char *v4; // ebx
  size_t v5; // eax
  char *v6; // eax
  void *v7; // edx
  void *started; // ebx
  size_t v9; // eax
  unsigned __int8 *v10; // eax
  size_t v11; // [esp+2Ch] [ebp-2Ch]
  size_t v12; // [esp+2Ch] [ebp-2Ch]
  char *ptr; // [esp+30h] [ebp-28h]
  void *ptra; // [esp+30h] [ebp-28h]
  unsigned __int8 *ptrb; // [esp+30h] [ebp-28h]
  size_t v16; // [esp+34h] [ebp-24h]
  size_t v17; // [esp+34h] [ebp-24h]
  int l; // [esp+38h] [ebp-20h]
  int la; // [esp+38h] [ebp-20h]

  v4 = (const char *)path;
  if ( path )
  {
    if ( !*path )
      return;
  }
  else
  {
    v4 = &::delete;
  }
  if ( (*((_BYTE *)term + 56) & 1) != 0 )
  {
    if ( *v4 )
    {
      if ( fg && is_blocked() )
      {
        unlink((const char *)delete);
      }
      else
      {
        v16 = strlen((const char *)delete);
        v5 = strlen(v4);
        l = v16 + v5 + 3;
        v11 = v5;
        v6 = (char *)mem_alloc(l);
        if ( v6 )
        {
          *v6 = fg;
          ptr = v6;
          memcpy(v6 + 1, v4, v11 + 1);
          memcpy(&ptr[v11 + 2], delete, v16 + 1);
          v7 = ptr;
          if ( fg == TERM_EXEC_FG )
          {
            block_itrm();
            v7 = ptr;
          }
          ptra = v7;
          started = (void *)start_thread((void (*)(void *, int))exec_thread, v7, l);
          mem_free(ptra);
          if ( started == (void *)-1 )
          {
            if ( fg == TERM_EXEC_FG )
              unblock_itrm();
          }
          else if ( fg == TERM_EXEC_FG )
          {
            term->blocked = (int)started;
            set_handlers((int)started, (select_handler_T)unblock_terminal, 0, (select_handler_T)unblock_terminal, term);
            set_handlers(term->fdin, 0, 0, (select_handler_T)destroy_terminal, term);
          }
          else
          {
            set_handlers((int)started, close_handle, 0, close_handle, started);
          }
        }
      }
    }
    else
    {
      dispatch_special(delete);
    }
  }
  else
  {
    v17 = strlen((const char *)delete);
    v9 = strlen(v4);
    la = v17 + v9 + 4;
    v12 = v9;
    v10 = (unsigned __int8 *)mem_alloc(la);
    if ( v10 )
    {
      *v10 = 0;
      v10[1] = fg;
      ptrb = v10;
      memcpy(v10 + 2, v4, v12 + 1);
      memcpy(&ptrb[v12 + 3], delete, v17 + 1);
      hard_write(term->fdout, ptrb, la);
      mem_free(ptrb);
    }
  }
}

//----- (080E3570) --------------------------------------------------------
void __cdecl do_terminal_function(terminal *term, unsigned __int8 code, unsigned __int8 *data)
{
  size_t v3; // edi
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ebx

  v3 = strlen((const char *)data);
  v4 = (unsigned __int8 *)mem_alloc(v3 + 2);
  v5 = v4;
  if ( v4 )
  {
    *v4 = code;
    memcpy(v4 + 1, data, v3 + 1);
    exec_on_terminal(term, 0, v5, TERM_EXEC_BG);
    mem_free(v5);
  }
}

//----- (080E3610) --------------------------------------------------------
int __cdecl set_terminal_title(terminal *term, unsigned __int8 *title)
{
  int v2; // edx
  int result; // eax
  int terminal_codepage; // edi
  unsigned __int8 *v5; // edi
  unsigned __int8 *cp_mime_name; // eax
  conv_table *translation_table; // edi
  int v8; // eax
  int to_cp; // [esp+2Ch] [ebp-1Ch]

  if ( term->title )
  {
    v2 = strcmp((const char *)title, (const char *)term->title);
    result = 0;
    if ( !v2 )
      return result;
  }
  terminal_codepage = get_terminal_codepage(term);
  if ( get_opt_(term->spec, "latin1_title")->number )
  {
    to_cp = get_cp_index("ISO-8859-1");
  }
  else
  {
    if ( !get_opt_(term->spec, "utf_8_io")->number )
      goto LABEL_5;
    to_cp = get_cp_index("UTF-8");
  }
  if ( to_cp != terminal_codepage )
  {
    translation_table = get_translation_table(terminal_codepage, to_cp);
    if ( !translation_table )
      return -1;
    v8 = strlen((const char *)title);
    v5 = convert_string_elinks(translation_table, title, v8, to_cp, CSM_NONE, 0, 0, 0);
    if ( !v5 )
      return -1;
    goto LABEL_6;
  }
LABEL_5:
  to_cp = terminal_codepage;
  v5 = 0;
LABEL_6:
  if ( term->title )
    mem_free(term->title);
  term->title = stracpy(title);
  cp_mime_name = get_cp_mime_name(to_cp);
  do_terminal_function(term, 3u, cp_mime_name);
  if ( v5 )
  {
    do_terminal_function(term, 1u, v5);
    mem_free(v5);
    return 0;
  }
  else
  {
    do_terminal_function(term, 1u, title);
    return 0;
  }
}

//----- (080E37B0) --------------------------------------------------------
void __cdecl exec_shell(terminal *term)
{
  unsigned __int8 *shell; // eax

  if ( can_open_os_shell(term->environment) )
  {
    shell = (unsigned __int8 *)get_shell();
    if ( shell )
    {
      if ( *shell )
        exec_on_terminal(term, shell, (unsigned __int8 *)&delete, TERM_EXEC_FG);
    }
  }
}

//----- (080E3810) --------------------------------------------------------
void __cdecl assert_terminal_ptr_not_dangling(const terminal *suspect)
{
  list_head_elinks *next; // eax

  if ( suspect )
  {
    next = (list_head_elinks *)terminals.next;
    if ( terminals.next == &terminals )
    {
LABEL_7:
      if ( !assert_failed )
      {
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/terminal/terminal.c";
        errline = 242;
        elinks_internal("assertion 0 failed: Dangling pointer to struct terminal");
      }
    }
    else
    {
      while ( suspect != (const terminal *)next )
      {
        next = (list_head_elinks *)next->next;
        if ( next == &terminals )
          goto LABEL_7;
      }
    }
  }
}

//----- (080E3880) --------------------------------------------------------
void __cdecl exec_thread(unsigned __int8 *path, int p)
{
  size_t v2; // esi

  v2 = strlen((const char *)path + 1);
  if ( *path == 2 )
    setpgid(0, 0);
  exe(path + 1);
  if ( path[v2 + 2] )
    unlink((const char *)&path[v2 + 2]);
}

//----- (080E3900) --------------------------------------------------------
void __cdecl destroy_terminal(terminal *term)
{
  window *next; // eax
  int fdout; // eax
  int v3; // edx
  option_value *opt; // eax

  bookmark_auto_save_tabs(term);
  detach_downloads_from_terminal(term);
  next = (window *)term->windows.next;
  for ( term->current_tab = 0; next != (window *)&term->windows; next = (window *)term->windows.next )
    delete_window(next);
  if ( term->title )
    mem_free(term->title);
  if ( term->screen )
    done_screen(term->screen);
  set_handlers(term->fdin, 0, 0, 0, 0);
  if ( term->interlink )
    mem_free(term->interlink);
  if ( term->blocked != -1 )
  {
    close(term->blocked);
    set_handlers(term->blocked, 0, 0, 0, 0);
  }
  term->next->prev = term->prev;
  term->prev->next = term->next;
  close(term->fdin);
  fdout = term->fdout;
  if ( fdout == 1 )
  {
    unhandle_terminal_signals(term);
    free_all_itrms();
    if ( terminals.next != &terminals && fork() )
      exit(0);
  }
  else if ( fdout != term->fdin )
  {
    close(term->fdout);
  }
  --term->spec->object.refcount;
  mem_free(term);
  if ( terminals.next != &terminals
    || (opt = get_opt_(config_options, "ui.sessions.keep_session_active"), v3 = 1, opt->number) )
  {
    v3 = 0;
  }
  program_0.terminate = v3;
}

//----- (080E3A80) --------------------------------------------------------
void destroy_all_terminals()
{
  terminal *i; // eax

  for ( i = (terminal *)terminals.next; terminals.next != &terminals; i = (terminal *)terminals.next )
    destroy_terminal(i);
}

//----- (080E3AB0) --------------------------------------------------------
void redraw_all_terminals()
{
  terminal *i; // ebx

  for ( i = (terminal *)terminals.next; i != (terminal *)&terminals; i = i->next )
    redraw_screen(i);
}

//----- (080E3AE0) --------------------------------------------------------
terminal *__cdecl init_term(int fdin, int fdout)
{
  int v2; // ecx
  unsigned __int8 *v3; // edx
  unsigned int v4; // eax
  unsigned __int8 *v5; // edx
  terminal *v6; // ebx
  terminal_screen *inited; // eax
  int output_handle; // eax
  option_elinks *opt_rec; // eax
  terminal *next; // eax
  int v12; // edx
  option_value *opt; // eax
  terminal *v14; // [esp+0h] [ebp-68h]
  unsigned __int8 name[41]; // [esp+23h] [ebp-45h] BYREF
  unsigned int v16; // [esp+4Ch] [ebp-1Ch]

  v2 = 28;
  v3 = &name[13];
  v16 = __readgsdword(0x14u);
  strcpy((char *)name, "terminal.");
  *(_WORD *)&name[10] = 0;
  name[12] = 0;
  if ( ((unsigned __int8)&name[13] & 2) != 0 )
  {
    *(_WORD *)&name[13] = 0;
    v2 = 26;
    v3 = &name[15];
  }
  v4 = 0;
  do
  {
    *(_DWORD *)&v3[v4] = 0;
    v4 += 4;
  }
  while ( v4 < (v2 & 0xFFFFFFFC) );
  v5 = &v3[v4];
  if ( (v2 & 2) != 0 )
    *(_WORD *)v5 = 0;
  v6 = (terminal *)mem_calloc(1u, 0x158u);
  if ( v6 )
  {
    inited = init_screen();
    v6->screen = inited;
    if ( inited )
    {
      v6->fdout = fdout;
      v6->windows.prev = &v6->windows;
      v6->windows.next = &v6->windows;
      v6->fdin = fdin;
      output_handle = get_output_handle();
      v6->blocked = -1;
      *((_BYTE *)v6 + 56) = (fdout == output_handle) | *((_BYTE *)v6 + 56) & 0xFE;
      get_terminal_name(&name[9]);
      opt_rec = get_opt_rec(config_options, name);
      v6->spec = opt_rec;
      ++opt_rec->object.refcount;
      next = (terminal *)terminals.next;
      v6->prev = (terminal *)&terminals;
      v6->next = next;
      terminals.next = v6;
      v6->next->prev = v6;
      set_handlers(fdin, (select_handler_T)in_term, 0, (select_handler_T)destroy_terminal, v6);
    }
    else
    {
      v14 = v6;
      v6 = 0;
      mem_free(v14);
    }
  }
  else
  {
    if ( terminals.next != &terminals
      || (opt = get_opt_(config_options, "ui.sessions.keep_session_active"), v12 = 1, opt->number) )
    {
      v12 = 0;
    }
    program_0.terminate = v12;
  }
  return v6;
}
// 80E3B4B: conditional instruction was optimized away because ecx.4 is in (==1A|==1C)

//----- (080E3C90) --------------------------------------------------------
terminal *__cdecl attach_terminal(int in, int out, int ctl, void *info, int len)
{
  terminal *result; // eax

  if ( set_nonblocking_fd(terminal_pipe[0]) < 0 || set_nonblocking_fd(terminal_pipe[1]) < 0 )
    return 0;
  handle_trm(in, out, out, terminal_pipe[1], ctl, info, len, 0);
  result = init_term(terminal_pipe[0], out);
  if ( !result )
  {
    close_terminal_pipes();
    return 0;
  }
  return result;
}

//----- (080E3D30) --------------------------------------------------------
void __cdecl redraw_terminal(terminal *term)
{
  int width; // ebx
  int height; // ecx
  term_event ev; // [esp+10h] [ebp-18h] BYREF

  width = term->width;
  height = term->height;
  ev.ev = EVENT_REDRAW;
  ev.info.mouse.x = width;
  *(_QWORD *)&ev.info.size.height = (unsigned int)height;
  term_send_event(term, &ev);
}

//----- (080E3D70) --------------------------------------------------------
void __cdecl redraw_terminal_cls(terminal *term)
{
  int width; // ebx
  int height; // ecx
  term_event ev; // [esp+10h] [ebp-18h] BYREF

  width = term->width;
  height = term->height;
  ev.ev = EVENT_RESIZE;
  ev.info.mouse.x = width;
  *(_QWORD *)&ev.info.size.height = (unsigned int)height;
  term_send_event(term, &ev);
}

//----- (080E3DB0) --------------------------------------------------------
void __cdecl unblock_terminal(terminal *term)
{
  close_handle((void *)term->blocked);
  term->blocked = -1;
  set_handlers(term->fdin, (select_handler_T)in_term, 0, (select_handler_T)destroy_terminal, term);
  unblock_itrm();
  redraw_terminal_cls(term);
  if ( textarea_editor )
    textarea_edit(1, 0, 0, 0, 0);
}

//----- (080E3E40) --------------------------------------------------------
void cls_redraw_all_terminals()
{
  terminal *i; // ebx

  for ( i = (terminal *)terminals.next; i != (terminal *)&terminals; i = i->next )
    redraw_terminal_cls(i);
}

//----- (080E3E70) --------------------------------------------------------
void __cdecl get_parent_ptr(window *win, int *x, int *y)
{
  window *next; // eax

  next = win->next;
  if ( win->next->type == WINDOW_TAB )
    next = get_tab_by_number(win->term, win->term->current_tab);
  if ( next )
  {
    *x = next->x;
    *y = next->y;
  }
  else
  {
    *x = 0;
    *y = 0;
  }
}

//----- (080E3EE0) --------------------------------------------------------
void __cdecl redraw_from_window(window *win)
{
  terminal *term; // edi
  int height; // edx
  window *p_windows; // esi
  int width; // ecx
  window *prev; // ebx
  term_event ev; // [esp+10h] [ebp-28h] BYREF

  term = win->term;
  if ( term->redrawing == TREDRAW_READY )
  {
    height = term->height;
    p_windows = (window *)&term->windows;
    width = term->width;
    ev.ev = EVENT_REDRAW;
    *(_QWORD *)&ev.info.size.height = (unsigned int)height;
    ev.info.mouse.x = width;
    term->redrawing = TREDRAW_BUSY;
    prev = win->prev;
    if ( &term->windows != (list_head_elinks *)prev )
    {
      do
      {
        while ( prev->type && get_tab_by_number(prev->term, prev->term->current_tab) != prev )
        {
          prev = prev->prev;
          if ( p_windows == prev )
            goto LABEL_8;
        }
        prev->handler(prev, &ev);
        prev = prev->prev;
      }
      while ( p_windows != prev );
    }
LABEL_8:
    term->redrawing = TREDRAW_READY;
  }
}

//----- (080E3F80) --------------------------------------------------------
void __cdecl delete_window(window *win)
{
  term_event ev; // [esp+10h] [ebp-18h] BYREF

  win->next->prev = win->prev;
  win->prev->next = win->next;
  memset(&ev.info, 0, sizeof(ev.info));
  ev.ev = EVENT_ABORT;
  win->handler(win, &ev);
  if ( win->data )
    mem_free(win->data);
  redraw_terminal(win->term);
  mem_free(win);
}

//----- (080E3FF0) --------------------------------------------------------
void __cdecl empty_window_handler(window *win, term_event *ev)
{
  void (**data)(void *); // eax
  char v3; // cl
  void (*v4)(void *); // edi
  term_event_type v5; // ebx
  terminal *term; // [esp+18h] [ebp-20h]
  void (*fn)(void *); // [esp+1Ch] [ebp-1Ch]

  term = win->term;
  data = (void (**)(void *))win->data;
  fn = *data;
  v3 = *((_BYTE *)data + 8);
  v4 = data[1];
  if ( (v3 & 1) == 0 )
  {
    v5 = ev->ev;
    if ( ev->ev <= (unsigned int)EVENT_RESIZE )
    {
      if ( (unsigned int)v5 < EVENT_REDRAW && v5 )
        goto LABEL_4;
      get_parent_ptr(win, &win->x, &win->y);
    }
    else
    {
      if ( v5 != EVENT_ABORT )
      {
LABEL_4:
        *((_BYTE *)data + 8) = v3 | 1;
        delete_window(win);
        fn(v4);
        term_send_event(term, ev);
        return;
      }
      fn(v4);
    }
  }
}

//----- (080E40B0) --------------------------------------------------------
void __cdecl delete_window_ev(window *win, term_event *ev)
{
  window *next; // esi
  bool v3; // di

  next = win->next;
  if ( win->next == (window *)&win->term->windows )
  {
    v3 = 1;
    next = 0;
  }
  else
  {
    v3 = next == 0;
  }
  delete_window(win);
  if ( !v3 && ev )
  {
    if ( next->type == WINDOW_TAB )
      next = get_tab_by_number(next->term, next->term->current_tab);
    if ( next )
      next->handler(next, ev);
  }
}

//----- (080E4150) --------------------------------------------------------
void __cdecl add_window(terminal *term, window_handler_T *handler, void *data)
{
  _DWORD *v3; // eax
  void *next; // ecx
  int height; // ecx
  int width; // ebx
  term_event ev; // [esp+10h] [ebp-18h] BYREF

  v3 = mem_calloc(1u, 0x2Cu);
  if ( v3 )
  {
    v3[4] = data;
    v3[5] = term;
    v3[2] = 0;
    v3[3] = handler;
    next = term->windows.next;
    v3[1] = &term->windows;
    *v3 = next;
    term->windows.next = v3;
    *(_DWORD *)(*v3 + 4) = v3;
    height = term->height;
    width = term->width;
    ev.ev = EVENT_INIT;
    *(_QWORD *)&ev.info.size.height = (unsigned int)height;
    ev.info.mouse.x = width;
    ((void (__cdecl *)(_DWORD *, term_event *))v3[3])(v3, &ev);
  }
  else if ( data )
  {
    mem_free(data);
  }
}

//----- (080E41F0) --------------------------------------------------------
void __cdecl add_empty_window(terminal *term, void (*fn)(void *), void *data)
{
  _BYTE *v3; // eax

  v3 = mem_alloc(0xCu);
  if ( v3 )
  {
    v3[8] &= ~1u;
    *(_DWORD *)v3 = fn;
    *((_DWORD *)v3 + 1) = data;
    add_window(term, empty_window_handler, v3);
  }
}

//----- (080E4250) --------------------------------------------------------
void __cdecl redraw_below_window(window *win)
{
  terminal *term; // edi
  int height; // eax
  int width; // edx
  window *prev; // ebx
  term_redrawing_state saved_redraw_state; // [esp+1Ch] [ebp-2Ch]
  term_event ev; // [esp+20h] [ebp-28h] BYREF

  term = win->term;
  saved_redraw_state = term->redrawing;
  if ( saved_redraw_state != TREDRAW_DELAYED )
  {
    height = term->height;
    width = term->width;
    ev.ev = EVENT_REDRAW;
    *(_QWORD *)&ev.info.size.height = (unsigned int)height;
    ev.info.mouse.x = width;
    prev = (window *)term->windows.prev;
    for ( term->redrawing = TREDRAW_DELAYED; win != prev; prev = prev->prev )
    {
      while ( prev->type && get_tab_by_number(prev->term, prev->term->current_tab) != prev )
      {
        prev = prev->prev;
        if ( win == prev )
          goto LABEL_8;
      }
      prev->handler(prev, &ev);
    }
LABEL_8:
    term->redrawing = saved_redraw_state;
  }
}

//----- (080E42E0) --------------------------------------------------------
unsigned __int8 *__cdecl base64_encode_bin(unsigned __int8 *in, int inlen, int *outlen)
{
  unsigned __int8 *v3; // ebx
  int v4; // esi
  unsigned __int8 *result; // eax
  unsigned __int8 *v6; // edx
  unsigned __int8 v7; // cl
  unsigned __int8 v8; // cl
  unsigned __int8 v9; // cl

  v3 = in;
  v4 = inlen;
  if ( assert_failed )
    goto LABEL_5;
  if ( in && *in )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 33;
    elinks_internal("assertion in && *in failed!");
    if ( assert_failed )
    {
LABEL_5:
      assert_failed = 0;
      return 0;
    }
  }
  result = (unsigned __int8 *)mem_alloc(4 * (inlen / 3) + 5);
  if ( result )
  {
    v6 = result;
    if ( inlen > 2 )
    {
      do
      {
        v4 -= 3;
        *v6 = base64_chars[*v3 >> 2];
        v6[1] = base64_chars[((unsigned __int8)(16 * *v3) | (v3[1] >> 4)) & 0x3F];
        v6[2] = base64_chars[((unsigned __int8)(4 * v3[1]) | (v3[2] >> 6)) & 0x3F];
        v7 = v3[2];
        v3 += 3;
        v6[3] = base64_chars[v7 & 0x3F];
        v6 += 4;
      }
      while ( v4 > 2 );
    }
    if ( v4 == 1 )
    {
      *v6 = base64_chars[*v3 >> 2];
      v9 = *v3;
      v6[2] = 61;
      v6[3] = 61;
      v6[1] = base64_chars[(16 * v9) & 0x3F];
      v6 += 4;
    }
    else if ( v4 == 2 )
    {
      *v6 = base64_chars[*v3 >> 2];
      v6[1] = base64_chars[((unsigned __int8)(16 * *v3) | (v3[1] >> 4)) & 0x3F];
      v8 = v3[1];
      v6[3] = 61;
      v6[2] = base64_chars[(4 * v8) & 0x3F];
      v6 += 4;
    }
    *v6 = 0;
    if ( outlen )
      *outlen = v6 - result;
  }
  return result;
}

//----- (080E44B0) --------------------------------------------------------
unsigned __int8 *__cdecl base64_decode_bin(unsigned __int8 *in, int inlen, int *outlen)
{
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edx
  unsigned __int8 *result; // eax
  unsigned int v6; // edx
  unsigned __int8 *v7; // edi
  unsigned int v8; // esi
  int v9; // ecx
  unsigned int v10; // esi
  int v11; // ecx

  v3 = in;
  if ( assert_failed )
    goto LABEL_5;
  if ( in && *in )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 97;
    elinks_internal("assertion in && *in failed!");
    if ( assert_failed )
    {
LABEL_5:
      assert_failed = 0;
      return 0;
    }
  }
  result = (unsigned __int8 *)mem_alloc(3 * (inlen / 4) + 1);
  v4 = 0;
  if ( !result )
    return v4;
  if ( !once_3804 )
  {
    LOBYTE(v4) = 64;
    do
    {
      v11 = base64_chars[(_DWORD)v4];
      decode_3799[v11] = (unsigned __int8)v4--;
      is_base64_char_3798[v11] = 1;
    }
    while ( v4 != (unsigned __int8 *)-1 );
    once_3804 = 1;
  }
  LOBYTE(v6) = *in;
  if ( !*in || (_BYTE)v6 == 61 )
  {
    v7 = result;
LABEL_20:
    *v7 = 0;
    v4 = result;
    if ( !outlen )
      return v4;
    *outlen = v7 - result;
  }
  else
  {
    v6 = (unsigned __int8)v6;
    if ( is_base64_char_3798[(unsigned __int8)v6] )
    {
      v7 = result;
      v8 = 0;
      v9 = 0;
      while ( 1 )
      {
        ++v9;
        v6 = v8 + decode_3799[v6];
        if ( v9 == 4 )
        {
          ++v3;
          v8 = 0;
          *v7 = BYTE2(v6);
          v7[1] = BYTE1(v6);
          v9 = 0;
          v7[2] = v6;
          LOBYTE(v6) = *v3;
          v7 += 3;
          if ( !*v3 )
          {
LABEL_19:
            if ( v9 )
              goto decode_error;
            goto LABEL_20;
          }
        }
        else
        {
          ++v3;
          v10 = v6;
          LOBYTE(v6) = *v3;
          v8 = v10 << 6;
          if ( !*v3 )
            goto LABEL_19;
        }
        if ( (_BYTE)v6 == 61 )
          break;
        v6 = (unsigned __int8)v6;
        if ( !is_base64_char_3798[(unsigned __int8)v6] )
          goto decode_error;
      }
      if ( v9 == 2 )
      {
        *v7++ = v8 >> 10;
        goto LABEL_20;
      }
      if ( v9 == 3 )
      {
        *v7 = BYTE2(v8);
        v7[1] = BYTE1(v8);
        v7 += 2;
        goto LABEL_20;
      }
      if ( v9 != 1 )
        goto LABEL_20;
    }
decode_error:
    mem_free(result);
    return 0;
  }
  return result;
}

//----- (080E46A0) --------------------------------------------------------
unsigned __int8 *__cdecl base64_decode(unsigned __int8 *in)
{
  int v2; // eax

  if ( assert_failed )
    goto LABEL_2;
  if ( in && *in )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 73;
    elinks_internal("assertion in && *in failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  v2 = strlen((const char *)in);
  return base64_decode_bin(in, v2, 0);
}

//----- (080E4740) --------------------------------------------------------
unsigned __int8 *__cdecl base64_encode(unsigned __int8 *in)
{
  int v2; // eax

  if ( assert_failed )
    goto LABEL_2;
  if ( in && *in )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/base64.c";
    errline = 21;
    elinks_internal("assertion in && *in failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  v2 = strlen((const char *)in);
  return base64_encode_bin(in, v2, 0);
}

//----- (080E47E0) --------------------------------------------------------
void colors_list_reset()
{
  internal_pointer_0 = color_specs;
}

//----- (080E47F0) --------------------------------------------------------
fastfind_key_value *colors_list_next()
{
  fastfind_key_value *result; // eax
  unsigned __int8 *name; // ecx

  result = 0;
  name = (unsigned __int8 *)internal_pointer_0->name;
  if ( internal_pointer_0->name )
  {
    kv_5773.data = (void *)internal_pointer_0;
    result = &kv_5773;
    kv_5773.key = name;
    ++internal_pointer_0;
  }
  return result;
}

//----- (080E4820) --------------------------------------------------------
void __cdecl color_to_string(color_T color, unsigned __int8 *str)
{
  *str = 35;
  elinks_ulongcat(str + 1, 0, color, 6u, 0x30u, 0x10u, 0);
}

//----- (080E4870) --------------------------------------------------------
const unsigned __int8 *__cdecl get_color_string(color_T color, unsigned __int8 *hexcolor)
{
  const unsigned __int8 *name; // ecx
  const color_spec *v3; // edx

  name = (const unsigned __int8 *)color_specs[0].name;
  if ( !color_specs[0].name )
  {
LABEL_6:
    color_to_string(color, hexcolor);
    return hexcolor;
  }
  v3 = color_specs;
  if ( color != 15792383 )
  {
    while ( 1 )
    {
      ++v3;
      name = (const unsigned __int8 *)v3->name;
      if ( !v3->name )
        break;
      if ( v3->rgb == color )
        return name;
    }
    goto LABEL_6;
  }
  return name;
}

//----- (080E48D0) --------------------------------------------------------
int __cdecl decode_color(const unsigned __int8 *str, int slen, color_T *color)
{
  const unsigned __int8 *v3; // ebx
  _DWORD *v4; // eax
  unsigned int v5; // eax
  int *v7; // eax
  int *v8; // esi
  const unsigned __int16 *v9; // ecx
  int i; // eax
  unsigned __int8 v11; // al
  unsigned __int8 buffer[7]; // [esp+15h] [ebp-23h] BYREF
  unsigned __int8 *end; // [esp+1Ch] [ebp-1Ch] BYREF

  v3 = str;
  if ( *str == 35 && (slen == 4 || slen == 7) )
  {
    v3 = str + 1;
decode_hex_color:
    if ( slen == 4 )
    {
      buffer[1] = *v3;
      buffer[0] = buffer[1];
      buffer[3] = v3[1];
      buffer[2] = buffer[3];
      v11 = v3[2];
      v3 = buffer;
      buffer[6] = 0;
      buffer[5] = v11;
      buffer[4] = v11;
    }
    v7 = __errno_location();
    *v7 = 0;
    v8 = v7;
    v5 = strtoul((const char *)v3, (char **)&end, 16);
    if ( !*v8 && v3 + 6 == end && v5 <= 0xFFFFFF )
      goto LABEL_5;
    return -1;
  }
  v4 = fastfind_search(&ff_colors_index, str, slen);
  if ( v4 && *v4 )
  {
    v5 = v4[1];
LABEL_5:
    *color = v5;
    return 0;
  }
  if ( slen == 3 || slen == 6 )
  {
    v9 = *__ctype_b_loc();
    for ( i = 0; i < slen; ++i )
    {
      if ( (v9[str[i]] & 0x1000) == 0 )
        break;
    }
    if ( i == slen )
      goto decode_hex_color;
  }
  return -1;
}
// 80E4976: conditional instruction was optimized away because esi.4 is in (==3|==6)

//----- (080E49E0) --------------------------------------------------------
void free_colors_lookup()
{
  fastfind_done(&ff_colors_index);
}

//----- (080E4A00) --------------------------------------------------------
void init_colors_lookup()
{
  fastfind_index_0(&ff_colors_index, FF_LOCALE_INDEP|FF_COMPRESS);
}

//----- (080E4A20) --------------------------------------------------------
int __cdecl elinks_ulongcat(
        unsigned __int8 *s,
        unsigned int *slen,
        unsigned int number,
        unsigned int width,
        unsigned __int8 fillchar,
        unsigned int base,
        unsigned int upper)
{
  const unsigned __int8 *v7; // ecx
  unsigned int *v8; // esi
  unsigned int v9; // edi
  int v10; // ebx
  unsigned int v12; // eax
  int v13; // ecx
  unsigned int v14; // edx
  unsigned __int8 *v15; // eax
  unsigned int v16; // eax
  unsigned int v17; // esi
  unsigned __int8 *v18; // edi
  unsigned int v19; // et2
  const unsigned __int8 *v20; // [esp+0h] [ebp-20h]
  unsigned int v21; // [esp+8h] [ebp-18h]
  unsigned int v22; // [esp+10h] [ebp-10h]

  v7 = lnum_5845;
  v8 = slen;
  if ( upper )
    v7 = unum_5844;
  v9 = 0;
  if ( slen )
    v9 = *slen;
  if ( !width || !s || base > 0x10 || base <= 1 )
    return -1;
  v12 = number;
  v21 = 1;
  if ( number > base - 1 )
  {
    v20 = v7;
    v13 = 1;
    do
    {
      ++v13;
      v12 /= base;
    }
    while ( v12 > base - 1 );
    v21 = v13;
    v8 = slen;
    v7 = v20;
  }
  v10 = 0;
  if ( width < v21 )
  {
    v10 = v21;
    v21 = width;
  }
  if ( v8 )
    *v8 += v21;
  if ( fillchar )
  {
    v22 = width - v21;
    if ( width != v21 )
    {
      if ( v8 )
        *v8 += width - v21;
      v14 = width - v21;
      v15 = &s[v22 - 1 + v9];
      do
      {
        *v15-- = fillchar;
        --v14;
      }
      while ( v14 );
      v9 += v22;
    }
  }
  s[v9 + v21] = 0;
  if ( v21 )
  {
    v16 = number;
    v17 = v21 - 1;
    v18 = &s[v21 - 1 + v9];
    while ( 1 )
    {
      v19 = v16 % base;
      v16 /= base;
      *v18-- = v7[v19];
      if ( !v17 )
        break;
      --v17;
    }
  }
  return v10;
}

//----- (080E4B60) --------------------------------------------------------
int __cdecl month2num(const unsigned __int8 *str)
{
  char v1; // al
  char v2; // cl
  int result; // eax

  v1 = str[1] | 0x20;
  v2 = str[2] | 0x20;
  switch ( *str | 0x20 )
  {
    case 'a':
      if ( v1 == 112 )
      {
        result = 3;
        if ( v2 != 114 )
          goto LABEL_2;
      }
      else
      {
        if ( v1 != 117 )
          goto LABEL_2;
        result = 7;
        if ( v2 != 103 )
          goto LABEL_2;
      }
      break;
    case 'd':
      if ( v1 != 101 )
        goto LABEL_2;
      result = 11;
      if ( v2 != 99 )
        goto LABEL_2;
      break;
    case 'f':
      if ( v1 != 101 )
        goto LABEL_2;
      result = 1;
      if ( v2 != 98 )
        goto LABEL_2;
      break;
    case 'j':
      if ( v1 == 97 )
      {
        result = 0;
        if ( v2 != 110 )
          goto LABEL_2;
      }
      else
      {
        if ( v1 != 117 )
          goto LABEL_2;
        result = 5;
        if ( v2 != 110 )
        {
          LOBYTE(result) = 6;
          if ( v2 != 108 )
            goto LABEL_2;
        }
      }
      break;
    case 'm':
      if ( v1 != 97 )
        goto LABEL_2;
      result = 2;
      if ( v2 != 114 )
      {
        LOBYTE(result) = 4;
        if ( v2 != 121 )
          goto LABEL_2;
      }
      break;
    case 'n':
      if ( v1 != 111 )
        goto LABEL_2;
      result = 10;
      if ( v2 != 118 )
        goto LABEL_2;
      break;
    case 'o':
      if ( v1 != 99 )
        goto LABEL_2;
      result = 9;
      if ( v2 != 116 )
        goto LABEL_2;
      break;
    case 's':
      if ( v1 != 101 )
        goto LABEL_2;
      result = 8;
      if ( v2 != 112 )
        goto LABEL_2;
      break;
    default:
LABEL_2:
      result = -1;
      break;
  }
  return result;
}

//----- (080E4CC0) --------------------------------------------------------
int __cdecl c_tolower(int c)
{
  int result; // eax

  result = c;
  switch ( c )
  {
    case 'A':
      result = 97;
      break;
    case 'B':
      result = 98;
      break;
    case 'C':
      result = 99;
      break;
    case 'D':
      result = 100;
      break;
    case 'E':
      result = 101;
      break;
    case 'F':
      result = 102;
      break;
    case 'G':
      result = 103;
      break;
    case 'H':
      result = 104;
      break;
    case 'I':
      result = 105;
      break;
    case 'J':
      result = 106;
      break;
    case 'K':
      result = 107;
      break;
    case 'L':
      result = 108;
      break;
    case 'M':
      result = 109;
      break;
    case 'N':
      result = 110;
      break;
    case 'O':
      result = 111;
      break;
    case 'P':
      result = 112;
      break;
    case 'Q':
      result = 113;
      break;
    case 'R':
      result = 114;
      break;
    case 'S':
      result = 115;
      break;
    case 'T':
      result = 116;
      break;
    case 'U':
      result = 117;
      break;
    case 'V':
      result = 118;
      break;
    case 'W':
      result = 119;
      break;
    case 'X':
      result = 120;
      break;
    case 'Y':
      result = 121;
      break;
    case 'Z':
      result = 122;
      break;
    default:
      return result;
  }
  return result;
}

//----- (080E4E80) --------------------------------------------------------
int __cdecl c_toupper(int c)
{
  int result; // eax

  result = c;
  switch ( c )
  {
    case 'a':
      result = 65;
      break;
    case 'b':
      result = 66;
      break;
    case 'c':
      result = 67;
      break;
    case 'd':
      result = 68;
      break;
    case 'e':
      result = 69;
      break;
    case 'f':
      result = 70;
      break;
    case 'g':
      result = 71;
      break;
    case 'h':
      result = 72;
      break;
    case 'i':
      result = 73;
      break;
    case 'j':
      result = 74;
      break;
    case 'k':
      result = 75;
      break;
    case 'l':
      result = 76;
      break;
    case 'm':
      result = 77;
      break;
    case 'n':
      result = 78;
      break;
    case 'o':
      result = 79;
      break;
    case 'p':
      result = 80;
      break;
    case 'q':
      result = 81;
      break;
    case 'r':
      result = 82;
      break;
    case 's':
      result = 83;
      break;
    case 't':
      result = 84;
      break;
    case 'u':
      result = 85;
      break;
    case 'v':
      result = 86;
      break;
    case 'w':
      result = 87;
      break;
    case 'x':
      result = 88;
      break;
    case 'y':
      result = 89;
      break;
    case 'z':
      result = 90;
      break;
    default:
      return result;
  }
  return result;
}

//----- (080E5040) --------------------------------------------------------
int __cdecl c_isupper(int c)
{
  return (unsigned int)(c - 65) <= 0x19;
}

//----- (080E5060) --------------------------------------------------------
int __cdecl c_islower(int c)
{
  return (unsigned int)(c - 97) <= 0x19;
}

//----- (080E5080) --------------------------------------------------------
void __cdecl clr_spaces(unsigned __int8 *str)
{
  unsigned __int8 v1; // dl
  unsigned __int8 *v2; // eax
  unsigned __int8 v3; // al
  unsigned __int8 *v4; // edx
  unsigned __int8 *v5; // ecx

  if ( !assert_failed )
  {
    assert_failed = str == 0;
    if ( !str )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
      errline = 479;
      elinks_internal("assertion str failed!");
    }
  }
  v1 = *str;
  if ( *str )
  {
    v2 = str;
    do
    {
      if ( v1 <= 0x1Fu )
        *v2 = 32;
      v1 = *++v2;
    }
    while ( *v2 );
    v3 = *str;
    if ( *str )
    {
      v4 = str + 1;
      v5 = str;
      while ( 1 )
      {
        if ( v3 != 32 )
          goto LABEL_11;
        if ( v5 != str )
          break;
LABEL_12:
        v3 = *v4;
        if ( !*v4 )
          goto LABEL_18;
LABEL_13:
        ++v4;
      }
      if ( *v4 == 32 )
        goto LABEL_13;
      if ( !*v4 )
        goto LABEL_18;
LABEL_11:
      *v5++ = v3;
      goto LABEL_12;
    }
  }
  v5 = str;
LABEL_18:
  *v5 = 0;
}

//----- (080E5130) --------------------------------------------------------
int __cdecl strtolx(unsigned __int8 *str, unsigned __int8 **end)
{
  int *v2; // eax
  int *v3; // ebx
  int v4; // edi
  unsigned __int8 *v5; // ebx
  char v6; // al

  v2 = __errno_location();
  *v2 = 0;
  v3 = v2;
  v4 = strtol((const char *)str, (char **)end, 10);
  if ( *v3 )
    return 0;
  v5 = *end;
  if ( *end )
  {
    v6 = c_toupper(*v5);
    if ( v6 == 75 )
    {
      *end = v5 + 1;
      if ( v4 >= -2097151 )
      {
        if ( v4 <= 0x1FFFFF )
        {
          v4 <<= 10;
          return v4;
        }
        return 0x7FFFFFFF;
      }
    }
    else
    {
      if ( v6 != 77 )
        return v4;
      *end = v5 + 1;
      if ( v4 >= -2047 )
      {
        if ( v4 <= 2047 )
        {
          v4 <<= 20;
          return v4;
        }
        return 0x7FFFFFFF;
      }
    }
    return -2147483647;
  }
  return v4;
}

//----- (080E51F0) --------------------------------------------------------
string *__cdecl add_shell_safe_to_string(string *string, unsigned __int8 *cmd, int cmdlen)
{
  int v3; // ebx
  unsigned __int8 v4; // al
  int v5; // edx
  int v6; // eax
  int v7; // ecx
  unsigned __int8 v8; // dl
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  unsigned __int8 v11; // dl

  if ( cmdlen )
  {
    v3 = 0;
    v4 = *cmd;
LABEL_3:
    if ( (unsigned __int8)(v4 - 97) <= 0x19u
      || (unsigned __int8)(v4 - 65) <= 0x19u
      || (unsigned __int8)(v4 - 48) <= 9u
      || v4 == 64
      || v4 == 46
      || v4 == 43
      || v4 == 58
      || v4 == 47
      || v4 == 95 )
    {
      while ( 1 )
      {
        ++v3;
        add_char_to_string(string, v4);
        v5 = 1;
        if ( cmdlen == v3 )
          break;
LABEL_10:
        v4 = cmd[v3];
        if ( !v5 || v4 != 45 )
          goto LABEL_3;
      }
    }
    else
    {
      add_char_to_string(string, 0x25u);
      v6 = cmd[v3] >> 4;
      v7 = (unsigned __int8)v6;
      v8 = v6 + 48;
      v9 = v6 + 87;
      if ( v7 > 9 )
        v8 = v9;
      add_char_to_string(string, v8);
      v10 = cmd[v3] & 0xF;
      v11 = v10 + 87;
      if ( v10 < 0xAu )
        v11 = v10 + 48;
      ++v3;
      add_char_to_string(string, v11);
      v5 = 0;
      if ( cmdlen != v3 )
        goto LABEL_10;
    }
  }
  return string;
}

//----- (080E5310) --------------------------------------------------------
string *__cdecl add_quoted_to_string(string *string, const unsigned __int8 *src, int len)
{
  int i; // ebx
  unsigned __int8 v4; // al

  if ( len )
  {
    for ( i = 0; i != len; ++i )
    {
      v4 = src[i];
      if ( v4 == 39 || v4 == 34 || v4 == 92 )
      {
        add_char_to_string(string, 0x5Cu);
        v4 = src[i];
      }
      add_char_to_string(string, v4);
    }
  }
  return string;
}

//----- (080E5380) --------------------------------------------------------
string *__cdecl add_shell_quoted_to_string(string *string, unsigned __int8 *src, int len)
{
  int i; // ebx
  unsigned __int8 v4; // al

  add_char_to_string(string, 0x27u);
  if ( len )
  {
    for ( i = 0; i != len; ++i )
    {
      while ( 1 )
      {
        v4 = src[i];
        if ( v4 == 39 )
          break;
        ++i;
        add_char_to_string(string, v4);
        if ( i == len )
          goto LABEL_6;
      }
      add_to_string(string, "'\\''");
    }
  }
LABEL_6:
  add_char_to_string(string, 0x27u);
  return string;
}

//----- (080E5400) --------------------------------------------------------
string *__usercall add_bytes_to_string___6@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  int v5; // eax
  int v6; // edi
  unsigned int v7; // esi
  unsigned __int8 *v8; // eax
  size_t na; // [esp+14h] [ebp-24h]
  size_t n; // [esp+14h] [ebp-24h]
  const unsigned __int8 *srca; // [esp+18h] [ebp-20h]
  const unsigned __int8 *src; // [esp+18h] [ebp-20h]
  unsigned int v13; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
LABEL_6:
    if ( !length )
      return v3;
    v5 = v3->length;
    v6 = length + v5;
    v13 = (v5 + 255) & 0xFFFFFF00;
    v7 = (length + v5 + 256) & 0xFFFFFF00;
    if ( v7 > v13 )
    {
      src = bytes;
      n = length;
      v8 = (unsigned __int8 *)mem_realloc(v3->source, (v6 + 256) & 0xFFFFFF00);
      if ( !v8 )
        return 0;
      v3->source = v8;
      memset(&v8[v13], 0, v7 - v13);
      length = n;
      bytes = src;
    }
    if ( v3->source )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[v6] = 0;
      v3->length = v6;
      return v3;
    }
    return 0;
  }
  srca = bytes;
  na = length;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  bytes = srca;
  length = na;
  if ( !assert_failed )
    goto LABEL_6;
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (080E5550) --------------------------------------------------------
string *__cdecl add_date_to_string(string *string, const unsigned __int8 *fmt, const time_t *date)
{
  time_t v3; // eax
  struct tm *v4; // eax
  size_t v5; // edx
  string *result; // eax
  time_t when_time; // [esp+18h] [ebp-410h] BYREF
  unsigned __int8 buffer[1024]; // [esp+1Ch] [ebp-40Ch] BYREF
  unsigned int v9; // [esp+41Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  if ( date )
    v3 = *date;
  else
    v3 = time(0);
  when_time = v3;
  v4 = localtime(&when_time);
  v5 = strftime((char *)buffer, 0x400u, (const char *)fmt, v4);
  result = 0;
  if ( v5 )
    return add_to_string(string, buffer);
  return result;
}

//----- (080E55F0) --------------------------------------------------------
int __cdecl sanitize_url(unsigned __int8 *url)
{
  size_t v1; // eax
  int v2; // edx
  size_t v3; // ecx
  unsigned __int8 *v4; // edx
  unsigned __int8 *v6; // ecx
  unsigned __int8 *v7; // edx
  char v8; // si
  size_t v9; // eax

  v1 = strlen((const char *)url);
  v2 = 1;
  if ( !v1 )
    return v2;
  v3 = v1 - 1;
  v4 = &url[v1];
  while ( 1 )
  {
    if ( *(v4 - 1) <= 0x1Fu )
      return 0;
    --v4;
    if ( !v3 )
      break;
    --v3;
  }
  v6 = url;
  if ( *url != 32 )
    goto LABEL_11;
  do
  {
    ++v6;
    --v1;
  }
  while ( *v6 == 32 );
  if ( v1 )
  {
LABEL_11:
    v7 = &v6[v1];
    if ( v6[v1 - 1] != 32 )
    {
LABEL_17:
      v9 = v1 + 1;
      goto LABEL_16;
    }
    while ( 1 )
    {
      --v1;
      *(v7 - 1) = 0;
      if ( !v1 )
        break;
      v8 = *(v7 - 2);
      --v7;
      if ( v8 != 32 )
        goto LABEL_17;
    }
  }
  v9 = 1;
LABEL_16:
  memmove(url, v6, v9);
  return 1;
}

//----- (080E56B0) --------------------------------------------------------
void __cdecl sanitize_title(unsigned __int8 *title)
{
  size_t v1; // eax
  size_t v2; // edx
  unsigned __int8 *v3; // eax
  size_t v4; // eax
  unsigned __int8 *i; // ecx
  unsigned __int8 *v6; // edx
  char v7; // si
  size_t v8; // eax

  v1 = strlen((const char *)title);
  if ( v1 )
  {
    v2 = v1 - 1;
    v3 = &title[v1];
    while ( 1 )
    {
      if ( *(v3 - 1) <= 0x1Fu )
        *(v3 - 1) = 32;
      --v3;
      if ( !v2 )
        break;
      --v2;
    }
    v4 = strlen((const char *)title);
    for ( i = title; *i == 32; --v4 )
      ++i;
    if ( v4 )
    {
      v6 = &i[v4];
      if ( i[v4 - 1] != 32 )
      {
LABEL_17:
        v8 = v4 + 1;
        goto LABEL_15;
      }
      while ( 1 )
      {
        --v4;
        *(v6 - 1) = 0;
        if ( !v4 )
          break;
        v7 = *(v6 - 2);
        --v6;
        if ( v7 != 32 )
          goto LABEL_17;
      }
    }
    v8 = 1;
LABEL_15:
    memmove(title, i, v8);
  }
}

//----- (080E5760) --------------------------------------------------------
int __cdecl elinks_longcat(
        unsigned __int8 *s,
        unsigned int *slen,
        int number,
        unsigned int width,
        unsigned __int8 fillchar,
        unsigned int base,
        unsigned int upper)
{
  unsigned int *v7; // ecx
  unsigned __int8 *v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // edx
  const unsigned __int8 *v11; // ebx
  int v12; // esi
  int v14; // ecx
  unsigned int v15; // edx
  unsigned __int8 *v16; // eax
  unsigned int v17; // ecx
  unsigned __int8 *v18; // edi
  unsigned int v19; // eax
  unsigned int v20; // et2
  unsigned int v21; // [esp+8h] [ebp-20h]
  unsigned int v22; // [esp+Ch] [ebp-1Ch]
  unsigned int v23; // [esp+14h] [ebp-14h]
  unsigned int v24; // [esp+18h] [ebp-10h]

  v7 = slen;
  v8 = s;
  v9 = number;
  if ( width && number < 0 )
  {
    if ( slen )
    {
      v10 = *slen;
      s[v10] = 45;
      *slen = v10 + 1;
    }
    else
    {
      *s = 45;
      v8 = s + 1;
    }
    --width;
    v9 = -number;
  }
  v11 = lnum_5845;
  v23 = 0;
  if ( upper )
    v11 = unum_5844;
  if ( slen )
    v23 = *slen;
  if ( !v8 || !width || base > 0x10 || base <= 1 )
    return -1;
  v21 = v9;
  v22 = 1;
  if ( base - 1 < v9 )
  {
    v14 = 1;
    do
    {
      ++v14;
      v9 /= base;
    }
    while ( base - 1 < v9 );
    v22 = v14;
    v7 = slen;
  }
  v12 = 0;
  if ( width < v22 )
  {
    v12 = v22;
    v22 = width;
  }
  if ( v7 )
    *v7 += v22;
  if ( fillchar )
  {
    v24 = width - v22;
    if ( width != v22 )
    {
      if ( v7 )
        *v7 += width - v22;
      v15 = width - v22;
      v16 = &v8[v24 - 1 + v23];
      do
      {
        *v16-- = fillchar;
        --v15;
      }
      while ( v15 );
      v23 += v24;
    }
  }
  v8[v23 + v22] = 0;
  if ( v22 )
  {
    v17 = v22 - 1;
    v18 = &v8[v22 - 1 + v23];
    v19 = v21;
    while ( 1 )
    {
      v20 = v19 % base;
      v19 /= base;
      *v18-- = v11[v20];
      if ( !v17 )
        break;
      --v17;
    }
  }
  return v12;
}

//----- (080E58E0) --------------------------------------------------------
string *__cdecl add_knum_to_string(string *string, int num)
{
  unsigned int v2; // ecx
  string *v3; // ebx
  int v4; // esi
  int v5; // edi
  int v6; // esi
  unsigned int v7; // ebx
  unsigned __int8 v8; // al
  unsigned int v9; // edx
  int v10; // eax
  int v12; // eax
  unsigned int v13; // [esp+24h] [ebp-54h]
  unsigned int v14; // [esp+2Ch] [ebp-4Ch]
  int tlen; // [esp+38h] [ebp-40h] BYREF
  unsigned __int8 t[32]; // [esp+3Ch] [ebp-3Ch] BYREF
  unsigned int v17; // [esp+5Ch] [ebp-1Ch]

  v2 = num;
  v17 = __readgsdword(0x14u);
  v3 = string;
  tlen = 0;
  if ( !num )
  {
    v4 = 0;
    v2 = 0;
LABEL_3:
    v5 = 0;
    tlen = v4 + 1;
    t[v4 + 1] = 0;
    v14 = 1;
    goto LABEL_4;
  }
  if ( (num / 0x100000) << 20 == num )
  {
    v5 = elinks_longcat(t, (unsigned int *)&tlen, num / 0x100000, 0x1Eu, 0, 0xAu, 0);
    v10 = tlen;
    t[tlen] = 77;
    tlen = v10 + 1;
    t[v10 + 1] = 0;
    goto LABEL_17;
  }
  if ( (num / 1024) << 10 == num )
  {
    v5 = elinks_longcat(t, (unsigned int *)&tlen, num / 1024, 0x1Eu, 0, 0xAu, 0);
    v12 = tlen;
    t[tlen] = 107;
    tlen = v12 + 1;
    t[v12 + 1] = 0;
    goto LABEL_17;
  }
  v4 = 0;
  v13 = 31;
  if ( num < 0 )
  {
    t[0] = 45;
    v2 = -num;
    LOWORD(v4) = 1;
    tlen = 1;
    v13 = 30;
  }
  if ( v2 <= 9 )
    goto LABEL_3;
  v9 = v2;
  v14 = 1;
  do
  {
    ++v14;
    v9 /= 0xAu;
  }
  while ( v9 > 9 );
  if ( v14 > v13 )
  {
    v5 = v14;
    tlen = v4 + v13;
    t[v4 + v13] = 0;
    v14 = v13;
    goto LABEL_4;
  }
  tlen = v4 + v14;
  t[v4 + v14] = 0;
  if ( v14 )
  {
    v5 = 0;
LABEL_4:
    v6 = v14 + v4 - 1;
    v7 = v14;
    do
    {
      v8 = lnum_5845[v2 % 0xA];
      v2 /= 0xAu;
      t[v6--] = v8;
      --v7;
    }
    while ( v7 );
    v3 = string;
LABEL_17:
    if ( v5 < 0 )
      return 0;
  }
  if ( tlen )
  {
    add_bytes_to_string___6(v3, t, tlen);
    return v3;
  }
  return 0;
}

//----- (080E5B10) --------------------------------------------------------
string *__cdecl add_string_replace(
        string *string,
        unsigned __int8 *src,
        int len,
        unsigned __int8 replaceable,
        unsigned __int8 replacement)
{
  string *v5; // esi
  unsigned __int8 v6; // cl
  int length; // edi
  unsigned int v9; // edx
  int v10; // eax
  size_t v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // edi
  unsigned __int8 *v14; // eax
  unsigned __int8 v15; // [esp+40h] [ebp-28h]
  unsigned __int8 v16; // [esp+40h] [ebp-28h]
  int v17; // [esp+44h] [ebp-24h]
  unsigned int v18; // [esp+48h] [ebp-20h]
  size_t v19; // [esp+4Ch] [ebp-1Ch]

  v5 = string;
  v6 = replacement;
  length = string->length;
  if ( assert_failed )
    goto LABEL_2;
  if ( src && len >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    v6 = replacement;
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  if ( !len )
    return v5;
  v9 = string->length;
  v10 = v9 + len;
  v9 += 255;
  v17 = v10;
  v11 = v10 + 256;
  LOBYTE(v9) = 0;
  LOBYTE(v11) = 0;
  v19 = v11;
  v18 = v9;
  if ( v11 > v9 )
  {
    v16 = v6;
    v14 = (unsigned __int8 *)mem_realloc(string->source, v11);
    if ( !v14 )
      return 0;
    string->source = v14;
    memset(&v14[v18], 0, v19 - v18);
    v6 = v16;
  }
  if ( !string->source )
    return 0;
  v15 = v6;
  memcpy(&string->source[string->length], src, len);
  string->source[v17] = 0;
  v12 = 0;
  string->length = v17;
  v13 = &string->source[length];
  do
  {
    if ( v13[v12] == replaceable )
      v13[v12] = v15;
    ++v12;
  }
  while ( len != v12 );
  return v5;
}

//----- (080E5C90) --------------------------------------------------------
string *__cdecl add_duration_to_string(string *string, int seconds)
{
  unsigned int v2; // ecx
  unsigned int v3; // esi
  int v4; // edi
  unsigned __int8 *v5; // ebx
  unsigned __int8 v6; // al
  int v7; // ebx
  unsigned int v8; // edx
  unsigned int v9; // edi
  unsigned __int8 *v10; // ecx
  unsigned __int8 v11; // al
  unsigned int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // esi
  int v16; // edi
  int v17; // ecx
  unsigned int v18; // ebx
  unsigned int v19; // edx
  unsigned int v20; // esi
  int v21; // edi
  int v22; // edi
  unsigned int v23; // ebx
  unsigned int v24; // edx
  unsigned int v25; // esi
  unsigned __int8 *v26; // edi
  unsigned __int8 v27; // al
  int v28; // eax
  unsigned __int8 *v29; // edx
  unsigned int v30; // edx
  unsigned __int8 *v31; // esi
  unsigned __int8 v32; // al
  int v33; // edx
  unsigned __int8 *v34; // eax
  unsigned int v35; // eax
  unsigned __int8 *v36; // esi
  unsigned __int8 v37; // al
  int v38; // [esp+1Ch] [ebp-9Ch]
  int v39; // [esp+3Ch] [ebp-7Ch]
  int v40; // [esp+3Ch] [ebp-7Ch]
  int v41; // [esp+48h] [ebp-70h]
  int v42; // [esp+48h] [ebp-70h]
  int v43; // [esp+48h] [ebp-70h]
  int qlen; // [esp+58h] [ebp-60h]
  int qlena; // [esp+58h] [ebp-60h]
  int qlenb; // [esp+58h] [ebp-60h]
  unsigned __int8 q[64]; // [esp+5Ch] [ebp-5Ch] BYREF
  unsigned int v48; // [esp+9Ch] [ebp-1Ch]

  v48 = __readgsdword(0x14u);
  if ( seconds < 0 )
  {
    v3 = 0;
    v2 = 0;
    goto LABEL_24;
  }
  if ( seconds > 86399 )
  {
    v13 = seconds / 86400;
    if ( (unsigned int)(seconds / 86400) <= 9 )
    {
      qlena = 1;
      v16 = 1;
      q[1] = 0;
    }
    else
    {
      v14 = seconds / 86400;
      v15 = 1;
      do
      {
        ++v15;
        v14 /= 0xAu;
      }
      while ( v14 > 9 );
      v16 = 5;
      if ( v15 <= 5 )
        v16 = v15;
      qlena = v16;
      q[v16] = 0;
      if ( !v16 )
        goto LABEL_22;
    }
    v36 = &q[v16];
    do
    {
      v37 = lnum_5845[v13 % 0xA];
      v13 /= 0xAu;
      *--v36 = v37;
      --v16;
    }
    while ( v16 );
LABEL_22:
    q[qlena] = 100;
    q[qlena + 1] = 32;
    v42 = qlena + 2;
    goto LABEL_26;
  }
  if ( seconds <= 3599 )
  {
    v2 = seconds / 60;
    v3 = seconds % 60;
    if ( (unsigned int)(seconds / 60) > 9 )
    {
      qlen = 2;
      v4 = 2;
      q[2] = 0;
      goto LABEL_6;
    }
LABEL_24:
    v4 = 1;
    qlen = 1;
    q[1] = 0;
LABEL_6:
    v5 = &q[v4];
    do
    {
      v6 = lnum_5845[v2 % 0xA];
      v2 /= 0xAu;
      *--v5 = v6;
      --v4;
    }
    while ( v4 );
    goto LABEL_8;
  }
  v42 = 0;
LABEL_26:
  v17 = seconds % 86400;
  v18 = seconds % 86400 / 3600;
  if ( v18 <= 9 )
  {
    v21 = 1;
    qlenb = v42 + 1;
    q[v42 + 1] = 0;
LABEL_47:
    v31 = &q[v21 - 1 + v42];
    do
    {
      v32 = lnum_5845[v18 % 0xA];
      v18 /= 0xAu;
      *v31-- = v32;
      --v21;
    }
    while ( v21 );
    goto LABEL_32;
  }
  v19 = seconds % 86400 / 3600;
  v20 = 1;
  do
  {
    ++v20;
    v19 /= 0xAu;
  }
  while ( v19 > 9 );
  v21 = 4;
  if ( v20 <= 4 )
    v21 = v20;
  qlenb = v21 + v42;
  q[v21 + v42] = 0;
  if ( v21 )
    goto LABEL_47;
LABEL_32:
  v22 = qlenb;
  v43 = qlenb + 1;
  q[qlenb] = 58;
  v39 = qlenb + 1;
  v23 = v17 / 60 % 60;
  if ( v23 <= 9 )
  {
    v25 = 1;
    qlen = qlenb + 2;
    v38 = 1;
LABEL_51:
    qlen += v38;
    v33 = v38;
    v39 = v38 + v43;
    v34 = &q[v22 + v38];
    do
    {
      *v34-- = 48;
      --v33;
    }
    while ( v33 );
    v35 = v25 + v39;
LABEL_54:
    q[v35] = 0;
    if ( !v25 )
    {
      v3 = v17 % 60;
      goto LABEL_8;
    }
    goto LABEL_37;
  }
  v24 = v17 / 60 % 60;
  v25 = 1;
  do
  {
    ++v25;
    v24 /= 0xAu;
  }
  while ( v24 > 9 );
  if ( v25 <= 2 )
  {
    v35 = v25 + v43;
    qlen = v25 + v43;
    v38 = 2 - v25;
    if ( v25 == 2 )
      goto LABEL_54;
    goto LABEL_51;
  }
  v25 = 2;
  qlen = qlenb + 3;
  q[v43 + 2] = 0;
LABEL_37:
  v26 = &q[v39 - 1 + v25];
  do
  {
    v27 = lnum_5845[v23 % 0xA];
    v23 /= 0xAu;
    *v26-- = v27;
    --v25;
  }
  while ( v25 );
  v3 = v17 % 60;
LABEL_8:
  v7 = qlen + 1;
  q[qlen] = 58;
  v41 = qlen + 1;
  if ( v3 <= 9 )
  {
    v9 = 1;
    v40 = 1;
LABEL_41:
    v28 = v40;
    v29 = &q[qlen + v40];
    v41 = v40 + v7;
    do
    {
      *v29-- = 48;
      --v28;
    }
    while ( v28 );
    v30 = v9 + v41;
LABEL_44:
    q[v30] = 0;
    if ( !v9 )
      goto LABEL_15;
    goto LABEL_13;
  }
  v8 = v3;
  v9 = 1;
  do
  {
    ++v9;
    v8 /= 0xAu;
  }
  while ( v8 > 9 );
  if ( v9 <= 2 )
  {
    v30 = v7 + v9;
    v40 = 2 - v9;
    if ( v9 == 2 )
      goto LABEL_44;
    goto LABEL_41;
  }
  v9 = 2;
  q[v7 + 2] = 0;
LABEL_13:
  v10 = &q[v9 - 1 + v41];
  do
  {
    v11 = lnum_5845[v3 % 0xA];
    v3 /= 0xAu;
    *v10-- = v11;
    --v9;
  }
  while ( v9 );
LABEL_15:
  add_to_string(string, q);
  return string;
}

//----- (080E61E0) --------------------------------------------------------
string *__cdecl add_timeval_to_string(string *string, timeval_T *timeval)
{
  int v2; // eax

  v2 = timeval_to_seconds(timeval);
  return add_duration_to_string(string, v2);
}

//----- (080E6210) --------------------------------------------------------
string *__cdecl add_long_to_string(string *string, int number)
{
  unsigned int v2; // esi
  int v3; // ecx
  unsigned int v4; // edx
  unsigned int v5; // edi
  unsigned __int8 *v6; // ecx
  unsigned __int8 v7; // al
  int width; // [esp+18h] [ebp-50h]
  unsigned int v10; // [esp+1Ch] [ebp-4Ch]
  int length; // [esp+28h] [ebp-40h]
  unsigned __int8 buffer[32]; // [esp+2Ch] [ebp-3Ch] BYREF
  unsigned int v13; // [esp+4Ch] [ebp-1Ch]

  v13 = __readgsdword(0x14u);
  v2 = number;
  if ( assert_failed )
    goto LABEL_16;
  v3 = 0;
  assert_failed = string == 0;
  if ( string )
    goto LABEL_3;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
  errline = 138;
  elinks_internal("assertion string failed!");
  if ( assert_failed )
  {
LABEL_16:
    assert_failed = 0;
    return 0;
  }
  v3 = 0;
LABEL_3:
  v10 = 31;
  if ( number < 0 )
  {
    buffer[0] = 45;
    v2 = -number;
    v3 = 1;
    v10 = 30;
  }
  if ( v2 <= 9 )
  {
    v5 = 1;
    length = v3 + 1;
    buffer[v3 + 1] = 0;
    width = 0;
    goto LABEL_10;
  }
  v4 = v2;
  v5 = 1;
  do
  {
    ++v5;
    v4 /= 0xAu;
  }
  while ( v4 > 9 );
  if ( v5 > v10 )
  {
    width = v5;
    length = v3 + v10;
    buffer[v3 + v10] = 0;
    v5 = v10;
LABEL_10:
    v6 = &buffer[v5 - 1 + v3];
    do
    {
      v7 = lnum_5845[v2 % 0xA];
      v2 /= 0xAu;
      *v6-- = v7;
      --v5;
    }
    while ( v5 );
    if ( width < 0 )
      return 0;
    goto LABEL_13;
  }
  length = v5 + v3;
  buffer[v5 + v3] = 0;
  if ( v5 )
  {
    width = 0;
    goto LABEL_10;
  }
LABEL_13:
  if ( !length )
    return 0;
  return add_bytes_to_string___6(string, buffer, length);
}

//----- (080E63A0) --------------------------------------------------------
string *__cdecl add_cp_html_to_string(string *string, int src_codepage, const unsigned __int8 *src, int len)
{
  string *v4; // ebx
  int length; // edi
  size_t v6; // ecx
  size_t v7; // edx
  unsigned __int8 *source; // eax
  unicode_val_T v9; // eax
  int v10; // esi
  unsigned __int8 *v12; // eax
  size_t v13; // [esp+10h] [ebp-28h]
  size_t v14; // [esp+14h] [ebp-24h]
  int rollback_length; // [esp+18h] [ebp-20h]

  v4 = string;
  len += (int)src;
  do
  {
    while ( 1 )
    {
      v9 = cp_to_unicode(src_codepage, (unsigned __int8 **)&src, (const unsigned __int8 *)len);
      v10 = v9;
      if ( v9 == -3 )
        return v4;
      if ( v9 - 32 <= 0x5E && v9 != 60 && v9 != 38 && v9 != 62 && v9 != 39 && v9 != 34 )
        break;
      rollback_length = string->length;
      if ( assert_failed )
      {
        assert_failed = 0;
        source = string->source;
LABEL_14:
        string->length = rollback_length;
        v4 = 0;
        source[rollback_length] = 0;
        return v4;
      }
      assert_failed = 0;
      length = string->length;
      v6 = length + 255;
      v7 = length + 258;
      LOBYTE(v6) = 0;
      LOBYTE(v7) = 0;
      if ( v7 > v6 )
      {
        v14 = v7;
        v13 = v6;
        v12 = (unsigned __int8 *)mem_realloc(string->source, v7);
        if ( !v12 )
          goto LABEL_18;
        string->source = v12;
        memset(&v12[v13], 0, v14 - v13);
      }
      source = string->source;
      if ( !string->source )
        goto LABEL_14;
      *(_WORD *)&source[string->length] = 8998;
      string->source[length + 2] = 0;
      string->length = length + 2;
      if ( !add_long_to_string(string, v10) || !add_char_to_string(string, 0x3Bu) )
      {
LABEL_18:
        source = string->source;
        goto LABEL_14;
      }
    }
  }
  while ( add_char_to_string(string, v9) );
  return 0;
}

//----- (080E6520) --------------------------------------------------------
string *__cdecl add_html_to_string(string *string, const unsigned __int8 *src, int len)
{
  string *v3; // ebx
  int i; // esi
  int length; // edi
  size_t v6; // ecx
  size_t v7; // edx
  unsigned __int8 *source; // eax
  unsigned __int8 v9; // al
  unsigned __int8 *v11; // eax
  size_t v12; // [esp+10h] [ebp-28h]
  size_t v13; // [esp+14h] [ebp-24h]
  int rollback_length; // [esp+18h] [ebp-20h]

  v3 = string;
  if ( len )
  {
    for ( i = 0; i != len; ++i )
    {
      v9 = src[i];
      if ( v9 == 60 || v9 <= 0x1Fu || v9 == 62 || v9 == 38 || v9 == 34 || v9 == 39 )
      {
        rollback_length = string->length;
        if ( assert_failed )
        {
          assert_failed = 0;
          source = string->source;
LABEL_16:
          string->length = rollback_length;
          v3 = 0;
          source[rollback_length] = 0;
          return v3;
        }
        assert_failed = 0;
        length = string->length;
        v6 = length + 255;
        v7 = length + 258;
        LOBYTE(v6) = 0;
        LOBYTE(v7) = 0;
        if ( v7 > v6 )
        {
          v13 = v7;
          v12 = v6;
          v11 = (unsigned __int8 *)mem_realloc(string->source, v7);
          if ( !v11 )
            goto LABEL_20;
          string->source = v11;
          memset(&v11[v12], 0, v13 - v12);
        }
        source = string->source;
        if ( !string->source )
          goto LABEL_16;
        *(_WORD *)&source[string->length] = 8998;
        string->source[length + 2] = 0;
        string->length = length + 2;
        if ( !add_long_to_string(string, src[i]) || !add_char_to_string(string, 0x3Bu) )
        {
LABEL_20:
          source = string->source;
          goto LABEL_16;
        }
      }
      else if ( !add_char_to_string(string, v9) )
      {
        return 0;
      }
    }
  }
  return v3;
}

//----- (080E6690) --------------------------------------------------------
string *__cdecl add_xnum_to_string(string *string, off_t xnum)
{
  int v2; // esi
  int v3; // ebx
  off_t v4; // rax
  char v5; // al
  bool v6; // dl
  char v7; // dl
  int v8; // eax
  char v10; // [esp+18h] [ebp-40h]
  char v11; // [esp+18h] [ebp-40h]
  int d; // [esp+28h] [ebp-30h]
  unsigned __int8 suff[3]; // [esp+3Dh] [ebp-1Bh] BYREF

  v2 = HIDWORD(xnum);
  v3 = xnum;
  *(_WORD *)suff = 26880;
  suff[2] = 0;
  if ( xnum > 0xFFFFF )
  {
    v3 = (unsigned __int64)xnum >> 20;
    suff[0] = 77;
    v2 = SHIDWORD(xnum) >> 20;
    v4 = 10 * xnum / 0x100000 % 10;
    d = v4;
  }
  else
  {
    if ( xnum < 0 || (unsigned int)xnum <= 0x3FF )
    {
      v7 = 0;
      d = -1;
      goto LABEL_7;
    }
    v3 = (unsigned __int64)xnum >> 10;
    v2 = SHIDWORD(xnum) >> 10;
    suff[0] = 75;
    v4 = ((10 * xnum) >> 10) % 10;
    d = v4;
  }
  LOBYTE(v4) = 1;
  v6 = (HIDWORD(v4) & d) != -1;
  if ( v2 >= 0 )
  {
    if ( v2 <= 0 )
    {
      if ( (unsigned int)v3 > 9 )
        v5 = 0;
    }
    else
    {
      v5 = 0;
    }
  }
  v7 = v5 & v6;
LABEL_7:
  if ( assert_failed )
  {
    v8 = v3;
  }
  else
  {
    v8 = v3;
    assert_failed = v2 != v3 >> 31;
    if ( v2 != v3 >> 31 )
    {
      v11 = v7;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/conv.c";
      errline = 194;
      elinks_internal("assertion xnum == (long) xnum failed!");
      v7 = v11;
      v8 = v3;
    }
  }
  v10 = v7;
  add_long_to_string(string, v8);
  if ( v10 )
  {
    add_char_to_string(string, 0x2Eu);
    add_long_to_string(string, d);
  }
  add_char_to_string(string, 0x20u);
  if ( suff[0] )
    add_to_string(string, suff);
  add_char_to_string(string, 0x42u);
  return string;
}
// 80E67CF: conditional instruction was optimized away because %xnum@4.4<1

//----- (080E68F0) --------------------------------------------------------
int __cdecl env_set(unsigned __int8 *name, unsigned __int8 *value, int length)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ebx
  int v6; // [esp+1Ch] [ebp-1Ch]

  if ( !value || !name || !*name )
    return -1;
  if ( length < (int)strlen((const char *)value) && length >= 0 )
  {
    v4 = memacpy(value, length);
    v5 = v4;
    if ( v4 )
    {
      v6 = setenv((const char *)name, (const char *)v4, 1);
      mem_free(v5);
      return v6;
    }
    return -1;
  }
  return setenv((const char *)name, (const char *)value, 1);
}

//----- (080E69A0) --------------------------------------------------------
void __cdecl do_not_optimize_here(void *p)
{
  ;
}

//----- (080E69B0) --------------------------------------------------------
void __cdecl dump_backtrace(FILE *f, int trouble)
{
  int v2; // eax
  char **v3; // edx
  unsigned int v4; // ebx
  void *v5; // eax
  int v6; // [esp+8h] [ebp-90h]
  const char *v7; // [esp+10h] [ebp-88h]
  char **ptr; // [esp+28h] [ebp-70h]
  char **ptra; // [esp+28h] [ebp-70h]
  unsigned int size; // [esp+2Ch] [ebp-6Ch]
  void *stack[20]; // [esp+30h] [ebp-68h] BYREF

  v2 = backtrace(stack, 20);
  size = v2;
  if ( trouble )
  {
    v6 = fileno(f);
    backtrace_symbols_fd(stack, size, v6);
  }
  else
  {
    ptr = backtrace_symbols(stack, v2);
    __fprintf_chk(f, 1, "Obtained %d stack frames:\n", size);
    v3 = ptr;
    if ( size )
    {
      v4 = 0;
      do
      {
        v7 = v3[v4];
        v5 = stack[v4++];
        ptra = v3;
        __fprintf_chk(f, 1, "[%p] %s\n", v5, v7);
        v3 = ptra;
      }
      while ( size > v4 );
    }
    free(v3);
    fflush(f);
  }
}
// 8058DE8: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080E6AA0) --------------------------------------------------------
void usrerror(unsigned __int8 *fmt, ...)
{
  va_list va; // [esp+24h] [ebp+Ch] BYREF

  va_start(va, fmt);
  fwrite("ELinks: ", 1u, 8u, stderr);
  __vfprintf_chk(stderr, 1, fmt, va);
  fputc(10, stderr);
  fflush(stderr);
}
// 8059268: using guessed type int __cdecl __vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080E6B20) --------------------------------------------------------
void __usercall er(int bell@<eax>, int shall_sleep@<edx>, unsigned __int8 *fmt@<ecx>, va_list params)
{
  unsigned __int8 *v5; // [esp+1Ch] [ebp-Ch]

  if ( bell )
  {
    v5 = fmt;
    fputc(7, stderr);
    fmt = v5;
  }
  __vfprintf_chk(stderr, 1, fmt, params);
  fputc(10, stderr);
  fflush(stderr);
  if ( shall_sleep )
    sleep(1u);
}
// 8059268: using guessed type int __cdecl __vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080E6BC0) --------------------------------------------------------
void elinks_internal(unsigned __int8 *fmt, ...)
{
  unsigned __int8 errbuf[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v2; // [esp+102Ch] [ebp-Ch]
  va_list params; // [esp+1044h] [ebp+Ch] BYREF

  va_start(params, fmt);
  v2 = __readgsdword(0x14u);
  __snprintf_chk(
    errbuf,
    4096,
    1,
    4096,
    "\x1B[1mINTERNAL ERROR\x1B[0m at %s:%d: %s",
    (const char *)errfile,
    errline,
    (const char *)fmt);
  er(1, 1, errbuf, params);
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080E6C50) --------------------------------------------------------
void elinks_assertm(int x, unsigned __int8 *fmt, ...)
{
  unsigned __int8 *buf; // [esp+1Ch] [ebp-Ch] BYREF
  va_list va; // [esp+38h] [ebp+10h] BYREF

  va_start(va, fmt);
  buf = 0;
  if ( !assert_failed )
  {
    assert_failed = x == 0;
    if ( !x )
    {
      __vasprintf_chk(&buf, 1, fmt, va);
      elinks_internal("assertion failed: %s", (const char *)buf);
      if ( buf )
        free(buf);
    }
  }
}
// 8059B08: using guessed type int __cdecl __vasprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080E6CD0) --------------------------------------------------------
void elinks_error(unsigned __int8 *fmt, ...)
{
  unsigned __int8 errbuf[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v2; // [esp+102Ch] [ebp-Ch]
  va_list params; // [esp+1044h] [ebp+Ch] BYREF

  va_start(params, fmt);
  v2 = __readgsdword(0x14u);
  __snprintf_chk(errbuf, 4096, 1, 4096, "ERROR at %s:%d: %s", (const char *)errfile, errline, (const char *)fmt);
  er(1, 1, errbuf, params);
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080E6D60) --------------------------------------------------------
void elinks_wdebug(unsigned __int8 *fmt, ...)
{
  unsigned __int8 errbuf[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v2; // [esp+102Ch] [ebp-Ch]
  va_list params; // [esp+1044h] [ebp+Ch] BYREF

  va_start(params, fmt);
  v2 = __readgsdword(0x14u);
  __snprintf_chk(errbuf, 4096, 1, 4096, "DEBUG MESSAGE at %s:%d: %s", (const char *)errfile, errline, (const char *)fmt);
  er(0, 1, errbuf, params);
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080E6DF0) --------------------------------------------------------
void elinks_debug(unsigned __int8 *fmt, ...)
{
  unsigned __int8 errbuf[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v2; // [esp+102Ch] [ebp-Ch]
  va_list params; // [esp+1044h] [ebp+Ch] BYREF

  va_start(params, fmt);
  v2 = __readgsdword(0x14u);
  __snprintf_chk(errbuf, 4096, 1, 4096, "DEBUG MESSAGE at %s:%d: %s", (const char *)errfile, errline, (const char *)fmt);
  er(0, 0, errbuf, params);
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080E6E80) --------------------------------------------------------
void __cdecl fastfind_done(fastfind_index *index)
{
  void **handle; // ebx
  char *v2; // eax
  char *v3; // edx
  _DWORD *v4; // ecx
  void *v5; // edx
  bool v6; // zf

  if ( assert_failed
    || (assert_failed = index == 0, !index)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c",
        errline = 643,
        elinks_internal("assertion index failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    handle = (void **)index->handle;
    if ( handle )
    {
      if ( *handle )
        mem_free(*handle);
      v2 = (char *)handle[8];
      v3 = v2;
      if ( v2 )
      {
        v4 = handle[1];
        do
        {
          v5 = (void *)v4[(_DWORD)v3];
          if ( v5 )
          {
            mem_free(v5);
            v2 = (char *)handle[8];
            v4 = handle[1];
          }
          v3 = v2 - 1;
          v6 = v2 == (char *)1;
          v2 = v3;
          handle[8] = v3;
        }
        while ( !v6 );
      }
      else
      {
        v4 = handle[1];
      }
      if ( v4 )
        mem_free(v4);
      mem_free(handle);
      index->handle = 0;
    }
  }
}

//----- (080E6F60) --------------------------------------------------------
void *__cdecl fastfind_search(fastfind_index *index, const unsigned __int8 *key, int key_len)
{
  fastfind_index *v3; // edx
  _DWORD *handle; // ebx
  char v6; // al
  char *v7; // edx
  const __int32_t **v8; // eax
  int v9; // ecx
  char *v10; // edx
  char v11; // al
  int v12; // eax
  int v13; // eax
  int v14; // esi
  char *v15; // esi
  int v16; // edi
  char v17; // al
  int v18; // eax
  int v19; // edx
  int v20; // ecx
  int v21; // esi
  char v22; // al
  char *v23; // [esp+20h] [ebp-28h]
  const __int32_t *v24; // [esp+28h] [ebp-20h]

  v3 = index;
  if ( assert_failed )
    goto LABEL_7;
  assert_failed = index == 0;
  if ( !index )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 602;
    elinks_internal("assertion index failed!");
    v3 = 0;
    if ( assert_failed )
      goto LABEL_7;
  }
  handle = v3->handle;
  assert_failed = handle == 0;
  if ( !handle )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 607;
    elinks_internal("assertion info != NULL failed: FastFind index %s not initialized", (const char *)v3->comment);
    if ( assert_failed )
    {
LABEL_7:
      assert_failed = 0;
      return 0;
    }
  }
  if ( !key || handle[4] < key_len || key_len < handle[3] )
    return 0;
  v6 = *((_BYTE *)handle + 36);
  v7 = (char *)handle[2];
  if ( (v6 & 1) == 0 )
  {
    if ( (v6 & 2) != 0 )
    {
      if ( key_len > 0 )
      {
        v15 = (char *)handle[2];
        v16 = 0;
        while ( 1 )
        {
          v18 = c_toupper(key[v16]);
          if ( v18 > 127 )
            break;
          v19 = handle[v18 + 10];
          if ( v19 < 0 )
            break;
          v17 = *v15;
          if ( (*v15 & 2) != 0 )
          {
            if ( (unsigned __int8)v15[3] >> 1 != v19 )
              return 0;
          }
          else
          {
            v15 += 4 * v19;
            v17 = *v15;
          }
          if ( (v17 & 1) != 0 )
          {
            v12 = *handle + 8 * ((*(_WORD *)v15 >> 2) & 0x3FF);
            if ( *(_DWORD *)(v12 + 4) == key_len )
              return *(void **)v12;
          }
          if ( (*(_DWORD *)v15 & 0x1FFF000) != 0 )
          {
            ++v16;
            v15 = *(char **)(handle[1] + ((*(_DWORD *)v15 >> 10) & 0x7FFC));
            if ( key_len > v16 )
              continue;
          }
          return 0;
        }
      }
    }
    else if ( key_len > 0 )
    {
      v23 = (char *)handle[2];
      v8 = __ctype_toupper_loc();
      v9 = 0;
      v10 = v23;
      v24 = *v8;
      while ( 1 )
      {
        v13 = v24[key[v9]];
        if ( v13 > 127 )
          break;
        v14 = handle[v13 + 10];
        if ( v14 < 0 )
          break;
        v11 = *v10;
        if ( (*v10 & 2) != 0 )
        {
          if ( (unsigned __int8)v10[3] >> 1 != v14 )
            return 0;
        }
        else
        {
          v10 += 4 * v14;
          v11 = *v10;
        }
        if ( (v11 & 1) != 0 )
        {
          v12 = *handle + 8 * ((*(_WORD *)v10 >> 2) & 0x3FF);
          if ( *(_DWORD *)(v12 + 4) == key_len )
            return *(void **)v12;
        }
        if ( (*(_DWORD *)v10 & 0x1FFF000) != 0 )
        {
          ++v9;
          v10 = *(char **)(handle[1] + ((*(_DWORD *)v10 >> 10) & 0x7FFC));
          if ( key_len > v9 )
            continue;
        }
        return 0;
      }
    }
    return 0;
  }
  if ( key_len <= 0 || *key > 0x7Fu || (int)handle[*key + 10] < 0 )
    return 0;
  v20 = 0;
  v21 = handle[*key + 10];
  while ( 1 )
  {
    v22 = *v7;
    if ( (*v7 & 2) != 0 )
      break;
    v7 += 4 * v21;
    v22 = *v7;
LABEL_44:
    if ( (v22 & 1) != 0 )
    {
      v12 = *handle + 8 * ((*(_WORD *)v7 >> 2) & 0x3FF);
      if ( *(_DWORD *)(v12 + 4) == key_len )
        return *(void **)v12;
    }
    if ( (*(_DWORD *)v7 & 0x1FFF000) != 0 )
    {
      ++v20;
      v7 = *(char **)(handle[1] + ((*(_DWORD *)v7 >> 10) & 0x7FFC));
      if ( key_len > v20 && key[v20] <= 0x7Fu )
      {
        v21 = handle[key[v20] + 10];
        if ( v21 >= 0 )
          continue;
      }
    }
    return 0;
  }
  if ( (unsigned __int8)v7[3] >> 1 == v21 )
    goto LABEL_44;
  return 0;
}

//----- (080E72A0) --------------------------------------------------------
int __usercall alloc_leafset@<eax>(fastfind_info *info@<eax>)
{
  bool v2; // zf
  ff_node_c **v3; // eax
  ff_node_c *v4; // eax
  ff_node_c **leafsets; // ecx
  int v6; // edx

  if ( assert_failed
    || (v2 = info->leafsets_count <= 8190, assert_failed = info->leafsets_count > 8190, !v2)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c",
        errline = 344,
        elinks_internal("assertion info->leafsets_count < FF_MAX_LEAFSETS failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v3 = (ff_node_c **)mem_realloc(info->leafsets, 4 * info->leafsets_count + 8);
    if ( v3 && (info->leafsets = v3, (v4 = (ff_node_c *)mem_calloc(info->uniq_chars_count, 4u)) != 0) )
    {
      leafsets = info->leafsets;
      v6 = info->leafsets_count + 1;
      info->leafsets_count = v6;
      leafsets[v6] = v4;
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

//----- (080E7360) --------------------------------------------------------
void __usercall compress_tree(ff_node_c *leafset@<eax>, fastfind_info *info@<edx>)
{
  ff_node_c *v3; // ebx
  int v4; // esi
  int v5; // ecx
  ff_node_c v6; // eax
  ff_node_c *v7; // esi
  int leafsets_count; // edx
  ff_node_c **leafsets; // ecx
  int v10; // ebx
  int v11; // eax
  _BYTE *v12; // eax
  char v13; // dl
  unsigned int v14; // edx
  void **v15; // edx
  int v16; // [esp+10h] [ebp-28h]
  _BYTE *v17; // [esp+10h] [ebp-28h]
  int pos; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = info == 0, !info)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c",
        errline = 412,
        elinks_internal("assertion info failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( info->uniq_chars_count > 0 )
  {
    v3 = leafset;
    v4 = 0;
    v5 = 0;
    pos = 0;
    do
    {
      if ( (*(_BYTE *)v3 & 2) == 0 )
      {
        v6 = *v3;
        if ( (*(_DWORD *)v3 & 0x1FFF000) != 0 )
        {
          v16 = v5;
          compress_tree(info->leafsets[(*(unsigned int *)&v6 >> 12) & 0x1FFF], info);
          v6 = *v3;
          v5 = v16;
        }
        if ( (*(_DWORD *)&v6 & 0x1FFF001) != 0 )
        {
          ++v5;
          pos = v4;
        }
      }
      ++v4;
      ++v3;
    }
    while ( info->uniq_chars_count > v4 );
    if ( v5 == 1 )
    {
      v7 = &leafset[pos];
      if ( (*(_BYTE *)v7 & 2) == 0 )
      {
        leafsets_count = info->leafsets_count;
        if ( leafsets_count > 1 )
        {
          leafsets = info->leafsets;
          v10 = 1;
          if ( leafsets[1] == leafset )
          {
LABEL_23:
            v12 = mem_alloc(4u);
            if ( v12 )
            {
              v13 = *v12 | 2;
              *v12 = v13;
              *v12 = *(_BYTE *)v7 & 1 | v13 & 0xFE;
              *(_WORD *)v12 = *(_WORD *)v7 & 0xFFC | *(_WORD *)v12 & 0xF003;
              v14 = *(_DWORD *)v7 & 0x1FFF000 | *(_DWORD *)v12 & 0xFE000FFF;
              *(_DWORD *)v12 = v14;
              v12[3] = (2 * pos) | HIBYTE(v14) & 1;
              v15 = (void **)&info->leafsets[v10];
              if ( *v15 )
              {
                v17 = v12;
                mem_free(*v15);
                v12 = v17;
                v15 = (void **)&info->leafsets[v10];
              }
              *v15 = v12;
            }
          }
          else
          {
            v11 = 1;
            while ( ++v11 < leafsets_count )
            {
              v10 = v11;
              if ( leafsets[v11] == leafset )
              {
                v7 = &leafset[pos];
                goto LABEL_23;
              }
            }
          }
        }
      }
    }
  }
}

//----- (080E7520) --------------------------------------------------------
fastfind_index *__cdecl fastfind_index_0(fastfind_index *index, fastfind_flags flags)
{
  fastfind_info *v2; // eax
  fastfind_info *v3; // esi
  size_t v4; // eax
  int v5; // ebx
  int v6; // edi
  _BYTE *v7; // eax
  char v8; // al
  int v10; // eax
  int v11; // ebx
  fastfind_info *v12; // edx
  _BYTE *v13; // eax
  int v14; // ecx
  fastfind_info *v15; // esi
  bool v16; // zf
  ff_data *v17; // eax
  signed int v18; // ebx
  const char *key; // edi
  size_t v20; // eax
  signed int v21; // ecx
  fastfind_info *root_leafset; // edx
  const char *v23; // edx
  ff_node_c *v24; // edi
  int v25; // eax
  unsigned int *v26; // edi
  unsigned int v27; // eax
  int v28; // eax
  char v29; // al
  char v30; // al
  int v31; // eax
  _BYTE *v32; // edx
  void *data; // ecx
  int pointers_count; // edx
  ff_data *v35; // eax
  const __int32_t **v36; // eax
  int v37; // [esp+1Ch] [ebp-2Ch]
  signed int uniq_chars_count; // [esp+20h] [ebp-28h]
  fastfind_info *v39; // [esp+20h] [ebp-28h]
  fastfind_info *v40; // [esp+20h] [ebp-28h]
  fastfind_key_value *p; // [esp+24h] [ebp-24h]
  fastfind_key_value *pa; // [esp+24h] [ebp-24h]
  int v43; // [esp+28h] [ebp-20h]
  signed int v44; // [esp+28h] [ebp-20h]
  unsigned __int8 *s; // [esp+2Ch] [ebp-1Ch]
  fastfind_key_value *sa; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_26;
  if ( index && index->reset && index->next )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
    errline = 448;
    elinks_internal("assertion index && index->reset && index->next failed!");
    if ( assert_failed )
      goto LABEL_26;
  }
  v2 = (fastfind_info *)mem_calloc(1u, 0x2A8u);
  v3 = v2;
  index->handle = v2;
  if ( !v2 )
    goto return_error;
  v2->min_key_len = 255;
  *((_BYTE *)v2 + 36) = (4 * ((flags & 2) != 0)) | (2 * ((flags & 4) != 0)) & 0xFB | flags & 1 | *((_BYTE *)v2 + 36) & 0xF8;
  index->reset();
  s = v3->uniq_chars;
  while ( 1 )
  {
    p = index->next();
    if ( !p )
      break;
    v4 = strlen((const char *)p->key);
    v43 = v4;
    if ( assert_failed )
      goto LABEL_26;
    assert_failed = v4 - 1 > 0xFE;
    if ( v4 - 1 > 0xFE )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
      errline = 461;
      elinks_internal("assertion key_len > 0 && key_len <= FF_MAX_KEYLEN failed!");
      if ( assert_failed )
        goto LABEL_26;
    }
    if ( v43 < v3->min_key_len )
      v3->min_key_len = v43;
    if ( v43 > v3->max_key_len )
      v3->max_key_len = v43;
    if ( v43 > 0 )
    {
      v5 = 0;
      while ( 1 )
      {
        v8 = *((_BYTE *)v3 + 36);
        if ( (v8 & 1) != 0 )
          break;
        if ( (v8 & 2) != 0 )
        {
          v6 = c_toupper(p->key[v5]);
LABEL_18:
          if ( assert_failed )
            goto LABEL_26;
          goto LABEL_19;
        }
        v6 = (*__ctype_toupper_loc())[p->key[v5]];
        if ( assert_failed )
          goto LABEL_26;
LABEL_19:
        assert_failed = v6 > 127;
        if ( v6 > 127 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
          errline = 477;
          elinks_internal("assertion k < FF_MAX_CHARS failed!");
          if ( assert_failed )
            goto LABEL_26;
        }
        uniq_chars_count = v3->uniq_chars_count;
        v7 = memchr(s, (unsigned __int8)v6, uniq_chars_count);
        if ( !v7 || v7 - s == -1 )
        {
          assert_failed = uniq_chars_count > 127;
          if ( uniq_chars_count > 127 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c";
            errline = 481;
            elinks_internal("assertion info->uniq_chars_count < FF_MAX_CHARS failed!");
            if ( assert_failed )
              goto LABEL_26;
          }
          v10 = v3->uniq_chars_count;
          ++v5;
          v3->uniq_chars[v10] = v6;
          v3->uniq_chars_count = v10 + 1;
          if ( v43 <= v5 )
            goto LABEL_35;
        }
        else if ( v43 <= ++v5 )
        {
          goto LABEL_35;
        }
      }
      v6 = p->key[v5];
      goto LABEL_18;
    }
LABEL_35:
    ++v3->count;
  }
  v11 = 0;
  if ( !v3->count )
    return 0;
  v12 = v3;
  do
  {
    v39 = v12;
    v13 = memchr(s, v11, v12->uniq_chars_count);
    v12 = v39;
    v14 = v13 - s;
    if ( !v13 )
      v14 = -1;
    v39->idxtab[v11++] = v14;
  }
  while ( v11 != 128 );
  v15 = v39;
  if ( !alloc_leafset(v39) )
  {
return_error:
    fastfind_done(index);
    return 0;
  }
  v39->root_leafset = v39->leafsets[v39->leafsets_count];
  if ( assert_failed
    || (v16 = v39->count <= 1023, assert_failed = v39->count > 1023, !v16)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/fastfind.c",
        errline = 312,
        elinks_internal("assertion info->count < FF_MAX_KEYS failed!"),
        assert_failed) )
  {
LABEL_26:
    assert_failed = 0;
    goto return_error;
  }
  v17 = (ff_data *)mem_calloc(v39->count, 8u);
  if ( !v17 )
    goto return_error;
  v39->data = v17;
  index->reset();
  while ( 1 )
  {
    sa = index->next();
    if ( !sa )
      break;
    v18 = 0;
    key = (const char *)sa->key;
    v20 = strlen((const char *)sa->key);
    v21 = 0;
    pa = (fastfind_key_value *)v20;
    root_leafset = (fastfind_info *)v15->root_leafset;
    v44 = v20 - 1;
    if ( (int)(v20 - 1) <= 0 )
      goto LABEL_67;
    v23 = key;
    v24 = v15->root_leafset;
    while ( 1 )
    {
      v29 = *((_BYTE *)v15 + 36);
      if ( (v29 & 1) != 0 )
      {
        v25 = (unsigned __int8)v23[v18];
        goto LABEL_56;
      }
      if ( (v29 & 2) != 0 )
      {
        v25 = c_toupper((unsigned __int8)v23[v18]);
LABEL_56:
        v26 = (unsigned int *)&v24[v15->idxtab[v25]];
        v27 = *v26;
        if ( (*v26 & 0x1FFF000) != 0 )
          goto LABEL_57;
        goto LABEL_63;
      }
      v26 = (unsigned int *)&v24[v15->idxtab[(*__ctype_toupper_loc())[(unsigned __int8)v23[v18]]]];
      v27 = *v26;
      if ( (*v26 & 0x1FFF000) != 0 )
      {
LABEL_57:
        v28 = (v27 >> 12) & 0x1FFF;
        goto LABEL_58;
      }
LABEL_63:
      if ( !alloc_leafset(v15) )
        goto return_error;
      v28 = v15->leafsets_count & 0x1FFF;
      *v26 = (v28 << 12) | *v26 & 0xFE000FFF;
LABEL_58:
      ++v18;
      v24 = v15->leafsets[v28];
      if ( v18 >= v44 )
        break;
      v23 = (const char *)sa->key;
    }
    root_leafset = (fastfind_info *)v15->leafsets[v28];
    v21 = v18;
    key = (const char *)sa->key;
LABEL_67:
    v30 = *((_BYTE *)v15 + 36);
    if ( (v30 & 1) != 0 )
    {
      v31 = (unsigned __int8)key[v21];
    }
    else
    {
      v40 = root_leafset;
      if ( (v30 & 2) != 0 )
      {
        v31 = c_toupper((unsigned __int8)key[v21]);
        root_leafset = v40;
      }
      else
      {
        v37 = v21;
        v36 = __ctype_toupper_loc();
        root_leafset = v40;
        v31 = (*v36)[(unsigned __int8)key[v37]];
      }
    }
    v32 = &root_leafset->data + v15->idxtab[v31];
    *v32 |= 1u;
    *(_WORD *)v32 = (4 * (v15->pointers_count & 0x3FF)) | *(_WORD *)v32 & 0xF003;
    data = sa->data;
    pointers_count = v15->pointers_count;
    v35 = &v15->data[pointers_count];
    v15->pointers_count = pointers_count + 1;
    v35->pointer = data;
    v35->keylen = (int)pa;
  }
  if ( (*((_BYTE *)v15 + 36) & 4) != 0 )
    compress_tree(v15->root_leafset, v15);
  return index;
}

//----- (080E7A90) --------------------------------------------------------
int __cdecl mkalldirs(const unsigned __int8 *path)
{
  int v1; // ebx
  size_t v3; // esi
  char *v4; // eax
  char *v5; // edi
  char v6; // al
  char *v7; // edx
  char *v8; // esi
  int v9; // eax
  char *v10; // [esp+1Ch] [ebp-1Ch]

  if ( !*path )
    return -1;
  v3 = strlen((const char *)path) + 1;
  v4 = (char *)mem_alloc(v3);
  v5 = v4;
  if ( !v4 )
    return -1;
  v1 = 0;
  memcpy(v4, path, v3);
  v6 = v5[1];
  v7 = v5 + 1;
  if ( v6 )
  {
    v8 = v5 + 2;
    do
    {
      if ( v6 == 47 )
      {
        *v7 = 0;
        v10 = v7;
        v9 = mkdir(v5, 0x1C0u);
        *v10 = 47;
        v1 = v9;
        if ( v9 < 0 )
        {
          if ( *__errno_location() != 17 )
            break;
          v1 = 0;
        }
      }
      v6 = *v8;
      v7 = v8++;
    }
    while ( v6 );
  }
  mem_free(v5);
  return v1;
}

//----- (080E7B60) --------------------------------------------------------
directory_entry *__cdecl get_directory_entries(unsigned __int8 *dirname, int get_hidden)
{
  directory_entry *v2; // ebx
  DIR *v3; // esi
  int v4; // eax
  int v5; // edx
  unsigned __int8 v6; // dl
  int v7; // eax
  __mode_t st_mode; // edx
  int v9; // ecx
  __mode_t v10; // eax
  struct passwd *v11; // eax
  const char *pw_name; // eax
  struct group *v13; // eax
  const char *gr_name; // eax
  time_t v15; // eax
  const unsigned __int8 *v16; // ecx
  directory_entry *v17; // eax
  directory_entry *v18; // eax
  char v20; // al
  int v21; // eax
  int v22; // eax
  int v23; // [esp+24h] [ebp-E4h]
  int is_root_directory; // [esp+28h] [ebp-E0h]
  int is_root_directorya; // [esp+28h] [ebp-E0h]
  unsigned __int8 *name; // [esp+30h] [ebp-D8h]
  directory_entry *p; // [esp+34h] [ebp-D4h]
  int size; // [esp+38h] [ebp-D0h]
  directory_entry *new_entries; // [esp+3Ch] [ebp-CCh]
  stat st; // [esp+40h] [ebp-C8h] BYREF
  string attrib; // [esp+A0h] [ebp-68h] BYREF
  time_t date; // [esp+A8h] [ebp-60h] BYREF
  unsigned __int8 source[64]; // [esp+ACh] [ebp-5Ch] BYREF
  unsigned int v34; // [esp+ECh] [ebp-1Ch]

  v34 = __readgsdword(0x14u);
  is_root_directory = 0;
  if ( *dirname == 47 )
    is_root_directory = dirname[1] == 0;
  v2 = 0;
  size = 0;
  p = 0;
  v3 = opendir((const char *)dirname);
  if ( v3 )
  {
    is_root_directorya = is_root_directory ^ 1;
LABEL_5:
    while ( 1 )
    {
      v4 = readdir64(v3);
      if ( !v4 )
        break;
      while ( 1 )
      {
        v5 = v4 + 19;
        if ( *(_BYTE *)(v4 + 19) == 46 )
        {
          v20 = *(_BYTE *)(v4 + 20);
          if ( !v20 )
            break;
          if ( v20 != 46 || (v21 = is_root_directorya, *(_BYTE *)(v5 + 2)) )
            v21 = get_hidden;
          if ( !v21 )
            break;
        }
        v23 = v5;
        new_entries = (directory_entry *)mem_realloc(p, 8 * size + 16);
        if ( !new_entries )
          break;
        p = new_entries;
        name = straconcat(dirname, v23, 0);
        if ( !name )
          break;
        if ( !init_string(&attrib) )
        {
          mem_free(name);
          p = new_entries;
          goto LABEL_5;
        }
        if ( __lxstat64(3, name, &st) )
        {
          add_char_to_string(&attrib, 0x3Fu);
          strcpy((char *)source, "---------");
          add_to_string(&attrib, source);
          add_char_to_string(&attrib, 0x20u);
          add_to_string(&attrib, s);
          add_to_string(&attrib, &byte_8134F94);
          add_to_string(&attrib, &byte_8134F94);
          add_to_string(&attrib, &byte_8134F94);
          add_to_string(&attrib, &byte_8134F90);
        }
        else
        {
          v6 = 100;
          v7 = st.st_mode & 0xF000;
          if ( v7 != 0x4000 )
          {
            v6 = 45;
            if ( v7 != 0x8000 )
            {
              v6 = 98;
              if ( v7 != 24576 )
              {
                v6 = 99;
                if ( v7 != 0x2000 )
                {
                  v6 = 112;
                  if ( v7 != 4096 )
                  {
                    v6 = 108;
                    if ( v7 != 40960 )
                    {
                      v6 = 63;
                      if ( v7 == 49152 )
                        v6 = 115;
                    }
                  }
                }
              }
            }
          }
          add_char_to_string(&attrib, v6);
          st_mode = st.st_mode;
          v9 = 0;
          strcpy((char *)source, "---------");
          do
          {
            v10 = st_mode << v9;
            if ( ((st_mode << v9) & 0x100) != 0 )
              source[v9] = 114;
            if ( (v10 & 0x80u) != 0 )
              source[v9 + 1] = 119;
            if ( (v10 & 0x40) != 0 )
              source[v9 + 2] = 120;
            v9 += 3;
          }
          while ( v9 != 9 );
          if ( (st_mode & 0x800) != 0 )
            source[2] = (st_mode & 0x40) == 0 ? 83 : 115;
          if ( (st_mode & 0x400) != 0 )
            source[5] = (st_mode & 8) == 0 ? 83 : 115;
          if ( (st_mode & 0x200) != 0 )
            source[8] = (st_mode & 1) == 0 ? 84 : 116;
          add_to_string(&attrib, source);
          add_char_to_string(&attrib, 0x20u);
          elinks_ulongcat(source, 0, st.st_nlink, 3u, 0x20u, 0xAu, 0);
          add_to_string(&attrib, source);
          add_char_to_string(&attrib, 0x20u);
          if ( st.st_uid != last_uid_6521 )
          {
            v11 = getpwuid(st.st_uid);
            if ( v11 && (pw_name = v11->pw_name) != 0 )
              __sprintf_chk(&last_user_6520, 1, 64, "%-8.8s", pw_name);
            else
              __sprintf_chk(&last_user_6520, 1, 64, "%-8d", st.st_uid);
            last_uid_6521 = st.st_uid;
          }
          add_to_string(&attrib, &last_user_6520);
          add_char_to_string(&attrib, 0x20u);
          if ( st.st_gid != last_gid_6546 )
          {
            v13 = getgrgid(st.st_gid);
            if ( v13 && (gr_name = v13->gr_name) != 0 )
              __sprintf_chk(&last_group_6545, 1, 64, "%-8.8s", gr_name);
            else
              __sprintf_chk(&last_group_6545, 1, 64, "%-8d", st.st_gid);
            last_gid_6546 = st.st_gid;
          }
          add_to_string(&attrib, &last_group_6545);
          add_char_to_string(&attrib, 0x20u);
          if ( HIDWORD(st.st_size) )
          {
            add_to_string(&attrib, &byte_8134F94);
          }
          else
          {
            v22 = elinks_ulongcat(source, 0, st.st_size, 9u, 0x20u, 0xAu, 0);
            if ( (unsigned int)(v22 - 1) <= 0x3E )
              elinks_ulongcat(source, 0, st.st_size, v22, 0x20u, 0xAu, 0);
            add_to_string(&attrib, source);
            add_char_to_string(&attrib, 0x20u);
          }
          v15 = time(0);
          if ( v15 > st.st_mtim.tv_sec + 15552000 || (v16 = "%b %e %H:%M", v15 < st.st_mtim.tv_sec - 3600) )
            v16 = "%b %e  %Y";
          date = st.st_mtim.tv_sec;
          add_date_to_string(&attrib, v16, &date);
          add_char_to_string(&attrib, 0x20u);
        }
        v17 = &new_entries[size];
        v17->name = name;
        v17->attrib = attrib.source;
        p = new_entries;
        ++size;
        v4 = readdir64(v3);
        if ( !v4 )
          goto LABEL_49;
      }
    }
LABEL_49:
    v2 = p;
    closedir(v3);
    if ( size )
    {
      qsort(p, size, 8u, compare_dir_entries);
      v18 = &p[size];
      v18->attrib = 0;
      v18->name = 0;
    }
    else if ( p )
    {
      v2 = 0;
      mem_free(p);
    }
  }
  return v2;
}
// 80591F8: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);
// 8059358: using guessed type int __cdecl readdir64(_DWORD);
// 80598C8: using guessed type int __sprintf_chk(_DWORD, _DWORD, _DWORD, const char *, ...);
// 8148B20: using guessed type int last_uid_6521;
// 8148B24: using guessed type int last_gid_6546;

//----- (080E8270) --------------------------------------------------------
int __cdecl compare_dir_entries(const void *v1, const void *v2)
{
  int edx1; // edx
  _BYTE *v3; // eax

  edx1 = *((_DWORD *)v1 + 1);
  if ( *(_BYTE *)edx1 == 46 && *(_BYTE *)(edx1 + 1) == 46 && !*(_BYTE *)(edx1 + 2) )
    return -1;
  v3 = (_BYTE *)*((_DWORD *)v2 + 1);
  if ( *v3 != 46 || v3[1] != 46 || v3[2] )
  {
    if ( **(_BYTE **)v1 == 100 )
    {
      if ( **(_BYTE **)v2 != 100 )
        return -1;
    }
    else if ( **(_BYTE **)v2 == 100 )
    {
      return 1;
    }
    return strcmp((const char *)edx1, *((const char **)v2 + 1));
  }
  return 1;
}

//----- (080E8300) --------------------------------------------------------
int __cdecl safe_mkstemp(unsigned __int8 *templatea)
{
  __mode_t v1; // esi
  int v2; // ebx

  v1 = umask(0x7Fu);
  v2 = mkstemp64(templatea);
  umask(v1);
  return v2;
}
// 8059588: using guessed type int __cdecl mkstemp64(_DWORD);

//----- (080E8340) --------------------------------------------------------
unsigned __int8 *__cdecl file_read_line(unsigned __int8 *line, size_t *size, FILE *file, int *lineno)
{
  unsigned __int8 *v4; // esi
  size_t v5; // eax
  size_t v6; // ebx
  int v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // ebx
  const unsigned __int16 *v11; // ecx
  int v13; // eax
  size_t v14; // ebx
  size_t v15; // eax
  unsigned __int8 *v16; // eax
  void *v17; // [esp+0h] [ebp-28h]

  v4 = line;
  if ( line )
  {
    v5 = *size;
  }
  else
  {
    v4 = (unsigned __int8 *)mem_alloc(0x400u);
    if ( !v4 )
      return v4;
    *size = 1024;
    v5 = 1024;
  }
  v6 = 0;
  while ( 1 )
  {
    v7 = v5 - v6;
    v8 = (char *)&v4[v6];
    if ( !fgets(v8, v7, file) )
    {
LABEL_18:
      v17 = v4;
      v4 = 0;
      mem_free(v17);
      return v4;
    }
    v9 = strchr(v8, 10);
    v10 = v9;
    if ( v9 )
    {
      ++*lineno;
      if ( v4 >= (unsigned __int8 *)v9 )
      {
LABEL_13:
        if ( *v10 != 92 )
          goto LABEL_14;
      }
      else
      {
        v11 = *__ctype_b_loc();
        while ( (v11[(unsigned __int8)*v10] & 0x2000) != 0 )
        {
          if ( v4 >= (unsigned __int8 *)--v10 )
            goto LABEL_13;
        }
        if ( *v10 != 92 )
        {
LABEL_14:
          v10[1] = 0;
          return v4;
        }
      }
      v6 = (size_t)&v10[~(unsigned int)v4];
      goto LABEL_12;
    }
    v13 = _IO_getc(file);
    if ( v13 == -1 )
      break;
    ungetc(v13, file);
    v14 = *size;
    v15 = *size + 1024;
    *size = v15;
    v16 = (unsigned __int8 *)mem_realloc(v4, v15);
    if ( !v16 )
      goto LABEL_18;
    v6 = v14 - 1;
    v4 = v16;
LABEL_12:
    v5 = *size;
  }
  ++*lineno;
  return v4;
}

//----- (080E8470) --------------------------------------------------------
unsigned __int8 *__cdecl get_tempdir_filename(unsigned __int8 *name)
{
  char *v1; // eax

  v1 = getenv("TMPDIR");
  if ( !v1 || !*v1 )
  {
    v1 = getenv("TMP");
    if ( !v1 || !*v1 )
    {
      v1 = getenv("TEMPDIR");
      if ( !v1 || !*v1 )
      {
        v1 = getenv("TEMP");
        if ( !v1 || !*v1 )
          v1 = "/tmp";
      }
    }
  }
  return straconcat((const unsigned __int8 *)v1, 135472153, name, 0);
}

//----- (080E84F0) --------------------------------------------------------
unsigned __int8 *__cdecl get_filename_position(unsigned __int8 *filename)
{
  unsigned __int8 *result; // eax
  unsigned __int8 v2; // cl
  unsigned __int8 *v3; // edx
  bool v4; // zf

  result = filename;
  if ( assert_failed
    || (assert_failed = filename == 0, !filename)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/file.c",
        errline = 98,
        elinks_internal("assertion filename failed!"),
        result = 0,
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v2 = *result;
    if ( *result )
    {
      v3 = result + 1;
      do
      {
        v4 = v2 == 47;
        v2 = *v3;
        if ( v4 )
          result = v3;
        ++v3;
      }
      while ( v2 );
    }
  }
  return result;
}

//----- (080E8590) --------------------------------------------------------
unsigned __int8 *__cdecl expand_tilde(unsigned __int8 *filename)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  unsigned __int8 *v3; // edx
  unsigned __int8 v4; // al
  int v5; // esi
  unsigned __int8 v6; // al
  unsigned __int8 *v7; // eax
  struct passwd *v8; // eax
  const unsigned __int8 *pw_dir; // eax
  char *v10; // eax
  unsigned __int8 *v11; // [esp+0h] [ebp-48h]
  unsigned __int8 *pa; // [esp+1Ch] [ebp-2Ch]
  struct passwd *p; // [esp+1Ch] [ebp-2Ch]
  string file; // [esp+28h] [ebp-20h] BYREF

  inited = init_string(&file);
  result = 0;
  if ( inited )
  {
    if ( *filename == 126 )
    {
      v4 = filename[1];
      if ( v4 && (v5 = 0, v4 != 47) )
      {
        do
          v6 = filename[++v5 + 1];
        while ( v6 && v6 != 47 );
        v7 = memacpy(filename + 1, v5);
        if ( v7 )
        {
          pa = v7;
          v8 = getpwnam((const char *)v7);
          v11 = pa;
          p = v8;
          mem_free(v11);
          if ( p )
          {
            pw_dir = (const unsigned __int8 *)p->pw_dir;
            if ( pw_dir )
            {
              add_to_string(&file, pw_dir);
              v3 = &filename[v5 + 1];
              goto LABEL_4;
            }
          }
        }
      }
      else
      {
        v10 = getenv("HOME");
        if ( v10 )
        {
          add_to_string(&file, (const unsigned __int8 *)v10);
          v3 = filename + 1;
          goto LABEL_4;
        }
      }
    }
    v3 = filename;
LABEL_4:
    add_to_string(&file, v3);
    return file.source;
  }
  return result;
}

//----- (080E8680) --------------------------------------------------------
int __cdecl file_is_dir(const unsigned __int8 *filename)
{
  int v1; // edx
  int result; // eax
  stat st; // [esp+10h] [ebp-68h] BYREF

  v1 = __xstat64(3, filename, &st);
  result = 0;
  if ( !v1 )
    return (st.st_mode & 0xF000) == 0x4000;
  return result;
}
// 8058E68: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (080E86C0) --------------------------------------------------------
int __cdecl file_can_read(const unsigned __int8 *filename)
{
  return access((const char *)filename, 4) >= 0;
}

//----- (080E86E0) --------------------------------------------------------
int __cdecl file_exists(const unsigned __int8 *filename)
{
  return access((const char *)filename, 0) >= 0;
}

//----- (080E8700) --------------------------------------------------------
unsigned __int8 *__cdecl get_unique_name(unsigned __int8 *fileprefix)
{
  int v1; // edi
  int v2; // ebx
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // eax
  int v6; // [esp+8h] [ebp-40h]
  size_t n; // [esp+24h] [ebp-24h]
  int memtrigger; // [esp+2Ch] [ebp-1Ch]

  v1 = 0;
  v2 = 1;
  v3 = fileprefix;
  memtrigger = 1;
  n = strlen((const char *)fileprefix);
  while ( file_exists(v3) )
  {
    if ( memtrigger <= v2 )
    {
      if ( v2 > 9999 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/file.c";
        errline = 162;
        elinks_internal("Too big suffix in get_unique_name().");
      }
      ++v1;
      if ( v3 != fileprefix )
        mem_free(v3);
      v4 = (unsigned __int8 *)mem_alloc(v1 + n + 2);
      v3 = v4;
      if ( !v4 )
        return v3;
      memtrigger *= 10;
      memcpy(v4, fileprefix, n);
      v3[n] = 46;
    }
    v6 = v2++;
    elinks_longcat(&v3[n + 1], 0, v6, v1 + 1, 0, 0xAu, 0);
  }
  return v3;
}

//----- (080E8830) --------------------------------------------------------
hash_value_T __cdecl strhash(unsigned __int8 *k, unsigned int length, hash_value_T initval)
{
  hash_value_T result; // eax
  int v4; // edx
  hash_value_T v5; // ecx
  int v6; // eax

  result = initval;
  if ( assert_failed
    || (assert_failed = k == 0 || length == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c",
        errline = 162,
        elinks_internal("assertion k && length > 0 failed!"),
        result = initval,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      result = 31 * result + k[v4];
      if ( v4 + 1 == length )
        break;
      result = 31 * result + k[v4 + 1];
      if ( v4 + 2 == length )
        break;
      result = 31 * result + k[v4 + 2];
      if ( v4 + 3 == length )
        break;
      result = 31 * result + k[v4 + 3];
      if ( v4 + 4 == length )
        break;
      result = 31 * result + k[v4 + 4];
      if ( v4 + 5 == length )
        break;
      result = 31 * result + k[v4 + 5];
      if ( v4 + 6 == length )
        break;
      result = 31 * result + k[v4 + 6];
      if ( v4 + 7 == length )
        break;
      v5 = 31 * result;
      v6 = k[v4 + 7];
      v4 += 8;
      result = v5 + v6;
    }
    while ( length != v4 );
  }
  return result;
}

//----- (080E8980) --------------------------------------------------------
void __cdecl del_hash_item(hash *hash, hash_item *item)
{
  if ( assert_failed
    || (assert_failed = item == 0, !item)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c",
        errline = 139,
        elinks_internal("assertion item failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    item->next->prev = item->prev;
    item->prev->next = item->next;
    mem_free(item);
  }
}

//----- (080E8A00) --------------------------------------------------------
void __cdecl free_hash(hash **hashp)
{
  hash *v1; // eax
  list_head_elinks *hash; // edx
  list_head_elinks *next; // ecx
  int v4; // esi
  list_head_elinks *v5; // edi
  list_head_elinks *v6; // ebx
  list_head_elinks *j; // ebx
  list_head_elinks *v8; // ebx
  unsigned int width; // [esp+28h] [ebp-20h]
  unsigned int i; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_17;
  if ( !hashp || !*hashp )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/hash.c";
    errline = 67;
    elinks_internal("assertion hashp && *hashp failed!");
    if ( !assert_failed )
      goto LABEL_5;
LABEL_17:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_5:
  v1 = *hashp;
  hash = (*hashp)->hash;
  i = 0;
  width = (*hashp)->width;
  if ( 1 << width )
  {
    do
    {
      next = (list_head_elinks *)v1->hash[i].next;
      v4 = i;
      v5 = &hash[i];
      if ( next != v5 )
      {
        v6 = (list_head_elinks *)v1->hash[i].next;
        do
          v6 = (list_head_elinks *)v6->next;
        while ( v6 != v5 );
      }
      for ( j = (list_head_elinks *)v1->hash[i].prev; j != v5; j = (list_head_elinks *)j->prev )
        ;
      v8 = (list_head_elinks *)next->next;
      if ( next != &hash[v4] )
      {
        do
        {
          v8->prev = next->prev;
          *(_DWORD *)next->prev = next->next;
          mem_free(next);
          next = v8;
          v8 = (list_head_elinks *)v8->next;
          v1 = *hashp;
          hash = (*hashp)->hash;
        }
        while ( &hash[v4] != next );
        width = v1->width;
      }
      ++i;
    }
    while ( 1 << width > i );
  }
  mem_free(v1);
  *hashp = 0;
}

//----- (080E8B50) --------------------------------------------------------
hash_item *__cdecl get_hash_item(hash *hash, unsigned __int8 *key, unsigned int keylen)
{
  hash_value_T v3; // edx
  hash_item *next; // ecx
  char *v5; // edx
  hash_item *result; // eax
  hash_item *v7; // [esp+28h] [ebp-20h]
  hash_item *v8; // [esp+2Ch] [ebp-1Ch]

  v3 = ((1 << hash->width) - 1) & hash->func(key, keylen, -559038737);
  next = (hash_item *)hash->hash[v3].next;
  v5 = (char *)hash + 8 * v3;
  result = next;
  v8 = next;
  v7 = (hash_item *)(v5 + 8);
  if ( next == (hash_item *)(v5 + 8) )
    return 0;
  while ( result->keylen != keylen || memcmp(key, result->key, keylen) )
  {
    result = result->next;
    if ( result == v7 )
      return 0;
  }
  if ( result != v8 )
  {
    result->next->prev = result->prev;
    result->prev->next = result->next;
    result->next = (hash_item *)*((_DWORD *)v5 + 2);
    result->prev = v7;
    *((_DWORD *)v5 + 2) = result;
    result->next->prev = result;
  }
  return result;
}

//----- (080E8C00) --------------------------------------------------------
hash_item *__cdecl add_hash_item(hash *hash, unsigned __int8 *key, unsigned int keylen, void *value)
{
  hash_item *v4; // ebx
  hash_value_T v5; // eax
  unsigned int width; // ecx
  list_head_elinks *v7; // eax
  hash_item *next; // edx

  v4 = (hash_item *)mem_alloc(0x14u);
  if ( v4 )
  {
    v5 = hash->func(key, keylen, -559038737);
    width = hash->width;
    v4->key = key;
    v7 = &hash->hash[((1 << width) - 1) & v5];
    v4->keylen = keylen;
    v4->value = value;
    next = (hash_item *)v7->next;
    v4->prev = (hash_item *)v7;
    v4->next = next;
    v7->next = v4;
    v4->next->prev = v4;
  }
  return v4;
}

//----- (080E8C80) --------------------------------------------------------
hash *init_hash8()
{
  hash *result; // eax
  list_head_elinks *hash; // ebx
  int v2; // edx

  if ( assert_failed )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    assert_failed = 0;
    result = (hash *)mem_alloc(0x808u);
    if ( result )
    {
      result->width = 8;
      hash = result->hash;
      v2 = 0;
      result->func = strhash;
      do
      {
        result->hash[v2].prev = &hash[v2];
        result->hash[v2].next = &hash[v2];
        ++v2;
      }
      while ( v2 != 256 );
    }
  }
  return result;
}

//----- (080E8D00) --------------------------------------------------------
void __cdecl init_md5(md5_context *ctx)
{
  ctx->buf[0] = 1732584193;
  ctx->buf[1] = -271733879;
  ctx->buf[2] = -1732584194;
  ctx->buf[3] = 271733878;
  ctx->bits[0] = 0;
  ctx->bits[1] = 0;
}

//----- (080E8D40) --------------------------------------------------------
void __usercall transform_md5(uint32_t *buf@<eax>, const uint32_t *in@<edx>)
{
  uint32_t v2; // esi
  uint32_t v3; // edi
  uint32_t v4; // ecx
  uint32_t v5; // eax
  uint32_t v6; // ebx
  uint32_t v7; // ecx
  uint32_t v8; // esi
  uint32_t v9; // eax
  uint32_t v10; // ebx
  uint32_t v11; // ecx
  uint32_t v12; // esi
  uint32_t v13; // eax
  int v14; // ebx
  int v15; // ecx
  int v16; // esi
  int v17; // eax
  uint32_t v18; // edi
  int v19; // ebx
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // ebx
  int v24; // ecx
  int v25; // edx
  int v26; // eax
  int v27; // ebx
  int v28; // ecx
  int v29; // edx
  int v30; // eax
  int v31; // ebx
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // ebx
  int v36; // ecx
  int v37; // edx
  int v38; // esi
  int v39; // ebx
  int v40; // ecx
  int v41; // edx
  int v42; // eax
  int v43; // ebx
  int v44; // ecx
  int v45; // edx
  int v46; // esi
  int v47; // ebx
  int v48; // eax
  int v49; // ecx
  int v50; // esi
  int v51; // edx
  int v52; // ebx
  int v53; // ecx
  int v54; // eax
  int v55; // edx
  int v56; // ebx
  int v57; // ecx
  int v58; // esi
  int v59; // edx
  int v60; // ebx
  int v61; // eax
  int v62; // ecx
  int v63; // edx
  int v64; // ebx
  int v65; // eax
  int v66; // ecx
  int v67; // edi
  int v68; // edx
  uint32_t v69; // ebx
  uint32_t v70; // [esp+4h] [ebp-54h]
  uint32_t v71; // [esp+8h] [ebp-50h]
  uint32_t v72; // [esp+Ch] [ebp-4Ch]
  uint32_t v73; // [esp+10h] [ebp-48h]
  uint32_t v74; // [esp+14h] [ebp-44h]
  uint32_t v75; // [esp+18h] [ebp-40h]
  uint32_t v76; // [esp+1Ch] [ebp-3Ch]
  uint32_t v77; // [esp+20h] [ebp-38h]
  uint32_t v78; // [esp+24h] [ebp-34h]
  uint32_t v79; // [esp+28h] [ebp-30h]
  uint32_t v80; // [esp+2Ch] [ebp-2Ch]
  uint32_t v81; // [esp+30h] [ebp-28h]
  uint32_t v82; // [esp+34h] [ebp-24h]
  uint32_t v83; // [esp+38h] [ebp-20h]
  uint32_t v84; // [esp+3Ch] [ebp-1Ch]
  uint32_t v85; // [esp+44h] [ebp-14h]

  v70 = *buf;
  v2 = buf[1];
  v3 = buf[2];
  v4 = buf[3];
  v71 = *in;
  v5 = v2 + __ROR4__(*buf + *in - 680876936 + (v4 ^ v2 & (v3 ^ v4)), 25);
  v72 = in[1];
  v6 = v5 + __ROR4__((v3 ^ v5 & (v2 ^ v3)) + v4 + v72 - 389564586, 20);
  v73 = in[2];
  v7 = v6 + __ROR4__(v3 + v73 + 606105819 + (v2 ^ v6 & (v2 ^ v5)), 15);
  v74 = in[3];
  v8 = v7 + __ROR4__(v2 + v74 - 1044525330 + (v5 ^ v7 & (v5 ^ v6)), 10);
  v75 = in[4];
  v9 = v8 + __ROR4__(v5 + v75 - 176418897 + (v6 ^ v8 & (v6 ^ v7)), 25);
  v76 = in[5];
  v77 = in[6];
  v10 = v9 + __ROR4__(v6 + v76 + 1200080426 + (v7 ^ v9 & (v7 ^ v8)), 20);
  v78 = in[7];
  v11 = v10 + __ROR4__(v7 + v77 - 1473231341 + (v8 ^ v10 & (v8 ^ v9)), 15);
  v79 = in[8];
  v12 = v11 + __ROR4__(v8 + v78 - 45705983 + (v9 ^ v11 & (v9 ^ v10)), 10);
  v80 = in[9];
  v13 = v12 + __ROR4__(v9 + v79 + 1770035416 + (v10 ^ v12 & (v10 ^ v11)), 25);
  v14 = v13 + __ROR4__(v10 + v80 - 1958414417 + (v11 ^ v13 & (v11 ^ v12)), 20);
  v81 = in[10];
  v15 = v14 + __ROR4__(v11 + v81 - 42063 + (v12 ^ v14 & (v12 ^ v13)), 15);
  v82 = in[11];
  v16 = v15 + __ROR4__(v12 + v82 - 1990404162 + (v13 ^ v15 & (v13 ^ v14)), 10);
  v83 = in[12];
  v17 = v16 + __ROR4__(v13 + v83 + 1804603682 + (v14 ^ v16 & (v14 ^ v15)), 25);
  v84 = in[13];
  v18 = in[14];
  v19 = v17 + __ROR4__(v14 + v84 - 40341101 + (v15 ^ v17 & (v15 ^ v16)), 20);
  v85 = in[15];
  v20 = v19 + __ROR4__(v15 + v18 - 1502002290 + (v16 ^ v19 & (v16 ^ v17)), 15);
  v21 = v20 + __ROR4__(v16 + v85 + 1236535329 + (v17 ^ v20 & (v17 ^ v19)), 10);
  v22 = v21 + __ROR4__(v17 + v72 - 165796510 + (v20 ^ v19 & (v20 ^ v21)), 27);
  v23 = v22 + __ROR4__(v19 + v77 - 1069501632 + (v21 ^ v20 & (v21 ^ v22)), 23);
  v24 = v23 + __ROR4__(v20 + v82 + 643717713 + (v22 ^ v21 & (v22 ^ v23)), 18);
  v25 = v24 + __ROR4__(v21 + v71 - 373897302 + (v23 ^ v22 & (v23 ^ v24)), 12);
  v26 = v25 + __ROR4__(v22 + v76 - 701558691 + (v24 ^ v23 & (v24 ^ v25)), 27);
  v27 = v26 + __ROR4__(v23 + v81 + 38016083 + (v25 ^ v24 & (v25 ^ v26)), 23);
  v28 = v27 + __ROR4__(v24 + v85 - 660478335 + (v26 ^ v25 & (v26 ^ v27)), 18);
  v29 = v28 + __ROR4__(v25 + v75 - 405537848 + (v27 ^ v26 & (v27 ^ v28)), 12);
  v30 = v29 + __ROR4__(v26 + v80 + 568446438 + (v28 ^ v27 & (v28 ^ v29)), 27);
  v31 = v30 + __ROR4__(v27 + v18 - 1019803690 + (v29 ^ v28 & (v29 ^ v30)), 23);
  v32 = v31 + __ROR4__(v28 + v74 - 187363961 + (v30 ^ v29 & (v30 ^ v31)), 18);
  v33 = v32 + __ROR4__(v29 + v79 + 1163531501 + (v31 ^ v30 & (v31 ^ v32)), 12);
  v34 = v33 + __ROR4__(v30 + v84 - 1444681467 + (v32 ^ v31 & (v32 ^ v33)), 27);
  v35 = v34 + __ROR4__(v31 + v73 - 51403784 + (v33 ^ v32 & (v33 ^ v34)), 23);
  v36 = v35 + __ROR4__(v32 + v78 + 1735328473 + (v34 ^ v33 & (v34 ^ v35)), 18);
  v37 = v36 + __ROR4__(v33 + v83 - 1926607734 + (v35 ^ v34 & (v35 ^ v36)), 12);
  v38 = v37 + __ROR4__(v34 + v76 - 378558 + (v37 ^ v35 ^ v36), 28);
  v39 = v38 + __ROR4__((v38 ^ v36 ^ v37) + v35 + v79 - 2022574463, 21);
  v40 = v39 + __ROR4__((v39 ^ v37 ^ v38) + v36 + v82 + 1839030562, 16);
  v41 = v40 + __ROR4__((v40 ^ v38 ^ v39) + v37 + v18 - 35309556, 9);
  v42 = v41 + __ROR4__(v38 + v72 - 1530992060 + (v41 ^ v39 ^ v40), 28);
  v43 = v42 + __ROR4__(v39 + v75 + 1272893353 + (v42 ^ v40 ^ v41), 21);
  v44 = v43 + __ROR4__(v40 + v78 - 155497632 + (v43 ^ v41 ^ v42), 16);
  v45 = v44 + __ROR4__(v41 + v81 - 1094730640 + (v44 ^ v42 ^ v43), 9);
  v46 = v45 + __ROR4__((v45 ^ v43 ^ v44) + v42 + v84 + 681279174, 28);
  v47 = v46 + __ROR4__((v46 ^ v44 ^ v45) + v43 + v71 - 358537222, 21);
  v48 = v47 + __ROR4__(v44 + v74 - 722521979 + (v47 ^ v45 ^ v46), 16);
  v49 = v48 + __ROR4__((v48 ^ v46 ^ v47) + v45 + v77 + 76029189, 9);
  v50 = v49 + __ROR4__((v49 ^ v47 ^ v48) + v46 + v80 - 640364487, 28);
  v51 = v50 + __ROR4__(v47 + v83 - 421815835 + (v50 ^ v48 ^ v49), 21);
  v52 = v51 + __ROR4__((v51 ^ v49 ^ v50) + v48 + v85 + 530742520, 16);
  v53 = v52 + __ROR4__((v52 ^ v50 ^ v51) + v49 + v73 - 995338651, 9);
  v54 = v53 + __ROR4__(v50 + v71 - 198630844 + (v52 ^ (v53 | ~v51)), 26);
  v55 = v54 + __ROR4__(v51 + v78 + 1126891415 + (v53 ^ (v54 | ~v52)), 22);
  v56 = v55 + __ROR4__(v52 + v18 - 1416354905 + (v54 ^ (v55 | ~v53)), 17);
  v57 = v56 + __ROR4__(v53 + v76 - 57434055 + (v55 ^ (v56 | ~v54)), 11);
  v58 = v57 + __ROR4__((v56 ^ (v57 | ~v55)) + v54 + v83 + 1700485571, 26);
  v59 = v58 + __ROR4__((v57 ^ (v58 | ~v56)) + v55 + v74 - 1894986606, 22);
  v60 = v59 + __ROR4__((v58 ^ (v59 | ~v57)) + v56 + v81 - 1051523, 17);
  v61 = v60 + __ROR4__(v57 + v72 - 2054922799 + (v59 ^ (v60 | ~v58)), 11);
  v62 = v61 + __ROR4__(v58 + v79 + 1873313359 + (v60 ^ (v61 | ~v59)), 26);
  v63 = v62 + __ROR4__(v59 + v85 - 30611744 + (v61 ^ (v62 | ~v60)), 22);
  v64 = v63 + __ROR4__(v60 + v77 - 1560198380 + (v62 ^ (v63 | ~v61)), 17);
  v65 = v64 + __ROR4__(v61 + v84 + 1309151649 + (v63 ^ (v64 | ~v62)), 11);
  v66 = v65 + __ROR4__(v62 + v75 - 145523070 + (v64 ^ (v65 | ~v63)), 26);
  v67 = v66 + __ROR4__((v65 ^ (v66 | ~v64)) + v63 + v82 - 1120210379, 22);
  v68 = v67 + __ROR4__(v64 + v73 + 718787259 + (v66 ^ (v67 | ~v65)), 17);
  *buf = v70 + v66;
  v69 = v68 + buf[1];
  buf[2] += v68;
  buf[3] += v67;
  buf[1] = v69 + __ROR4__(v65 + v80 - 343485551 + (v67 ^ (v68 | ~v66)), 11);
}
// 80E8D40: too many cbuild loops

//----- (080E9430) --------------------------------------------------------
void __cdecl update_md5(md5_context *ctx, const unsigned __int8 *buf, unsigned int len)
{
  uint32_t v3; // eax
  uint32_t v4; // edx
  uint32_t v5; // edx
  int v6; // eax
  unsigned __int8 *in; // ebx
  int v8; // edi
  unsigned __int8 *v9; // edx
  int i; // eax
  int v11; // esi
  int j; // eax
  const unsigned __int8 *src; // [esp+14h] [ebp-24h]
  size_t v14; // [esp+1Ch] [ebp-1Ch]

  v14 = len;
  src = buf;
  v3 = ctx->bits[0];
  v4 = v3 + 8 * len;
  ctx->bits[0] = v4;
  if ( v3 > v4 )
  {
    v5 = ctx->bits[1] + 1;
    ctx->bits[1] = v5;
  }
  else
  {
    v5 = ctx->bits[1];
  }
  v6 = (v3 >> 3) & 0x3F;
  ctx->bits[1] = (len >> 29) + v5;
  in = ctx->in;
  if ( v6 )
  {
    v8 = 64 - v6;
    v9 = &ctx->in[v6];
    if ( len < 64 - v6 )
    {
      memmove(v9, buf, len);
      return;
    }
    memmove(v9, buf, 64 - v6);
    for ( i = 0; i != 64; i += 4 )
      *(_DWORD *)&in[i] = *(_DWORD *)&in[i];
    transform_md5(ctx->buf, (const uint32_t *)in);
    src = &buf[v8];
    v14 = len - v8;
  }
  if ( v14 > 0x3F )
  {
    v11 = 0;
    do
    {
      memmove(in, &src[v11], 0x40u);
      for ( j = 0; j != 64; j += 4 )
        *(_DWORD *)&in[j] = *(_DWORD *)&in[j];
      v11 += 64;
      transform_md5(ctx->buf, (const uint32_t *)in);
    }
    while ( v14 - v11 > 0x3F );
    src += ((v14 - 64) & 0xFFFFFFC0) + 64;
    v14 = (v14 - 64) & 0x3F;
  }
  memmove(in, src, v14);
}

//----- (080E95C0) --------------------------------------------------------
void __cdecl done_md5(md5_context *ctx, unsigned __int8 *digest)
{
  uint32_t v2; // eax
  unsigned __int8 *in; // ebx
  int i; // eax
  unsigned __int8 *v5; // edi
  unsigned int v6; // edx
  unsigned __int8 *v7; // edi
  int j; // eax
  md5_context *v9; // eax

  v2 = (ctx->bits[0] >> 3) & 0x3F;
  ctx->in[v2] = 0x80;
  if ( 63 - v2 > 7 )
  {
    in = ctx->in;
    memset(&ctx->in[v2 + 1], 0, 63 - v2 - 8);
    goto LABEL_10;
  }
  in = ctx->in;
  memset(&ctx->in[v2 + 1], 0, 63 - v2);
  for ( i = 0; i != 64; i += 4 )
    *(_DWORD *)&in[i] = *(_DWORD *)&in[i];
  transform_md5(ctx->buf, (const uint32_t *)ctx->in);
  v5 = ctx->in;
  v6 = 56;
  if ( ((unsigned __int8)in & 1) != 0 )
  {
    ctx->in[0] = 0;
    v5 = &ctx->in[1];
    LOBYTE(v6) = 55;
  }
  if ( ((unsigned __int8)v5 & 2) != 0 )
  {
    *(_WORD *)v5 = 0;
    v6 -= 2;
    v5 += 2;
  }
  memset(v5, 0, 4 * (v6 >> 2));
  v7 = &v5[4 * (v6 >> 2)];
  if ( (v6 & 2) != 0 )
  {
    *(_WORD *)v7 = 0;
    v7 += 2;
    if ( (v6 & 1) == 0 )
      goto LABEL_10;
    goto LABEL_16;
  }
  if ( (v6 & 1) != 0 )
LABEL_16:
    *v7 = 0;
LABEL_10:
  for ( j = 0; j != 56; j += 4 )
    *(_DWORD *)&in[j] = *(_DWORD *)&in[j];
  *((_QWORD *)in + 7) = *(_QWORD *)ctx->bits;
  transform_md5(ctx->buf, (const uint32_t *)in);
  v9 = ctx;
  do
  {
    v9->buf[0] = v9->buf[0];
    v9 = (md5_context *)((char *)v9 + 4);
  }
  while ( v9 != (md5_context *)ctx->bits );
  memmove(digest, ctx, 0x10u);
  memset(ctx, 0, sizeof(md5_context));
}

//----- (080E9780) --------------------------------------------------------
unsigned __int8 *__cdecl digest_md5(const unsigned __int8 *data, unsigned int length, unsigned __int8 *digest)
{
  md5_context ctx; // [esp+14h] [ebp-64h] BYREF
  unsigned int v5; // [esp+6Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  ctx.buf[0] = 1732584193;
  ctx.buf[1] = -271733879;
  ctx.buf[2] = -1732584194;
  ctx.buf[3] = 271733878;
  ctx.bits[0] = 0;
  ctx.bits[1] = 0;
  if ( length )
    update_md5(&ctx, data, length);
  done_md5(&ctx, digest);
  return digest;
}

//----- (080E9810) --------------------------------------------------------
void __cdecl freeml(memory_list *ml)
{
  int v1; // ebx
  void *v2; // eax

  if ( ml )
  {
    if ( ml->n > 0 )
    {
      v1 = 0;
      do
      {
        v2 = ml->p[v1++];
        mem_free(v2);
      }
      while ( ml->n > v1 );
    }
    mem_free(ml);
  }
}

//----- (080E9860) --------------------------------------------------------
void __cdecl add_one_to_ml(memory_list **ml, void *p)
{
  memory_list *v2; // eax
  int n; // edx
  memory_list *v4; // eax

  if ( p )
  {
    if ( *ml )
    {
      v2 = (memory_list *)mem_realloc(*ml, 4 * (*ml)->n + 12);
      if ( !v2 )
        return;
      *ml = v2;
      goto LABEL_5;
    }
    v4 = (memory_list *)mem_alloc(0xCu);
    *ml = v4;
    if ( v4 )
    {
      v4->n = 0;
      v2 = *ml;
LABEL_5:
      n = v2->n;
      v2->p[n] = p;
      v2->n = n + 1;
    }
  }
}

//----- (080E98D0) --------------------------------------------------------
void add_to_ml(memory_list **ml, ...)
{
  int v1; // eax
  memory_list *v2; // eax
  int v3; // edx
  va_list v4; // ecx
  memory_list *v5; // eax
  int n; // esi
  memory_list *v7; // eax
  int v8; // [esp+24h] [ebp+Ch]
  va_list va1; // [esp+28h] [ebp+10h] BYREF
  va_list va; // [esp+24h] [ebp+Ch]

  va_start(va1, ml);
  va_start(va, ml);
  v8 = va_arg(va1, _DWORD);
  if ( v8 )
  {
    v1 = 0;
    do
      ++v1;
    while ( *((int *)va + v1) );
    if ( v1 )
    {
      if ( *ml )
      {
        v2 = (memory_list *)mem_realloc(*ml, 4 * ((*ml)->n + v1) + 8);
        if ( !v2 )
          return;
        *ml = v2;
      }
      else
      {
        v7 = (memory_list *)mem_alloc(4 * v1 + 8);
        *ml = v7;
        if ( !v7 )
          return;
        v7->n = 0;
      }
      v3 = v8;
      va_copy(v4, va1);
      if ( v8 )
      {
        do
        {
          v5 = *ml;
          v4 += 4;
          n = (*ml)->n;
          v5->p[n] = (void *)v3;
          v5->n = n + 1;
          v3 = *((_DWORD *)v4 - 1);
        }
        while ( v3 );
      }
    }
  }
}

//----- (080E9970) --------------------------------------------------------
memory_list *getml(void *p, ...)
{
  memory_list *result; // eax
  void *v2; // ebx
  size_t v3; // ecx
  va_list v4; // ecx
  int v5; // edx
  int v6; // esi
  memory_list *v7; // ebx
  int v8; // [esp+24h] [ebp+Ch] BYREF
  va_list va1; // [esp+28h] [ebp+10h] BYREF
  va_list va; // [esp+24h] [ebp+Ch]

  va_start(va1, p);
  va_start(va, p);
  v8 = va_arg(va1, _DWORD);
  result = 0;
  v2 = p;
  if ( p )
  {
    LOBYTE(result) = 1;
    v3 = 12;
    if ( v8 )
    {
      do
        result = (memory_list *)((char *)result + 1);
      while ( *((int *)va + (_DWORD)result - 1) );
      v3 = 4 * (_DWORD)result + 8;
    }
    result = (memory_list *)mem_alloc(v3);
    if ( result )
    {
      result->n = 1;
      va_copy(v4, va1);
      result->p[0] = v2;
      v5 = v8;
      if ( v8 )
      {
        v6 = 1;
        v7 = result + 1;
        do
        {
          ++v6;
          v4 += 4;
          v7->n = v5;
          v7 = (memory_list *)((char *)v7 + 4);
          result->n = v6;
          v5 = *((_DWORD *)v4 - 1);
        }
        while ( v5 );
      }
    }
  }
  return result;
}

//----- (080E9A00) --------------------------------------------------------
size_t __usercall round_size@<eax>(size_t size@<eax>)
{
  int v2; // ecx

  v2 = page_size;
  if ( !page_size )
  {
    v2 = sysconf(30);
    page_size = v2;
  }
  if ( v2 <= 0 )
  {
    page_size = 1;
    v2 = 1;
  }
  return v2 * (size / v2 + 1);
}

//----- (080E9A50) --------------------------------------------------------
void __cdecl mem_mmap_free(void *p, size_t size)
{
  size_t v2; // eax

  if ( p )
  {
    v2 = round_size(size);
    munmap(p, v2);
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    errline = 167;
    elinks_internal("mem_mmap_free(NULL)");
  }
}

//----- (080E9AA0) --------------------------------------------------------
void *__cdecl mem_mmap_alloc(size_t size)
{
  void *result; // eax
  size_t v2; // eax

  if ( !size )
    return 0;
  v2 = round_size(size);
  result = (void *)mmap64(0, v2, 3, 33, -1, 0, 0);
  if ( result == (void *)-1 )
    return 0;
  return result;
}
// 80599B8: using guessed type int __cdecl mmap64(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080E9B00) --------------------------------------------------------
void *__cdecl mem_mmap_realloc(void *p, size_t old_size, size_t new_size)
{
  void *v3; // ebx
  size_t v4; // esi
  size_t v5; // eax
  void *v6; // eax
  size_t v8; // [esp+1Ch] [ebp-1Ch]

  v3 = p;
  if ( !p )
    return mem_mmap_alloc(new_size);
  v8 = round_size(old_size);
  if ( v8 != round_size(new_size) )
  {
    if ( new_size )
    {
      v4 = round_size(new_size);
      v5 = round_size(old_size);
      v3 = 0;
      v6 = (void *)mremap(p, v5, v4, 1);
      if ( v6 != (void *)-1 )
        return v6;
    }
    else
    {
      v3 = 0;
      mem_mmap_free(p, old_size);
    }
  }
  return v3;
}
// 8058F38: using guessed type int __cdecl mremap(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080E9BA0) --------------------------------------------------------
int __usercall patience@<eax>(unsigned __int8 *of_0@<eax>)
{
  int v1; // edx
  bool v2; // cc
  int result; // eax

  v1 = alloc_try + 1;
  v2 = ++alloc_try <= 2;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
  if ( v2 )
  {
    errline = 34;
    elinks_error(
      "Out of memory (%s returned NULL): retry #%d/%d, I still exercise my patience and retry tirelessly.",
      (const char *)of_0,
      v1,
      3);
    sleep(3u);
    return alloc_try;
  }
  else
  {
    errline = 46;
    elinks_error(
      "Out of memory (%s returned NULL) after %d tries, I give up and try to continue. Pray for me, please.",
      (const char *)of_0,
      v1);
    result = 0;
    alloc_try = 0;
  }
  return result;
}

//----- (080E9C40) --------------------------------------------------------
void __cdecl mem_free(void *p)
{
  if ( p )
  {
    free(p);
  }
  else
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/memory.c";
    errline = 90;
    elinks_internal("mem_free(NULL)");
  }
}

//----- (080E9C80) --------------------------------------------------------
void *__cdecl mem_calloc(size_t count, size_t eltsize)
{
  void *v2; // ebx

  if ( !eltsize || !count )
    return 0;
  do
    v2 = calloc(count, eltsize);
  while ( !v2 && patience("calloc") );
  return v2;
}

//----- (080E9CE0) --------------------------------------------------------
void *__cdecl mem_alloc(size_t size)
{
  void *v1; // ebx

  v1 = 0;
  if ( size )
  {
    do
      v1 = malloc(size);
    while ( !v1 && patience("malloc") );
  }
  return v1;
}

//----- (080E9D20) --------------------------------------------------------
void *__cdecl mem_realloc(void *p, size_t size)
{
  void *v2; // ebx

  if ( !p )
    return mem_alloc(size);
  if ( size )
  {
    do
      v2 = realloc(p, size);
    while ( !v2 && patience("realloc") );
  }
  else
  {
    v2 = 0;
    mem_free(p);
  }
  return v2;
}

//----- (080E9D80) --------------------------------------------------------
scanner_token *__cdecl skip_scanner_tokens(scanner *scanner, int skipto, int precedence)
{
  int tokens; // edx
  scanner_token *current; // ecx
  int v5; // eax
  scanner_token *v6; // eax
  scanner_token *v7; // edi
  scanner_token *v8; // ecx
  scanner_token *result; // eax
  scanner_token *v10; // ecx
  scanner_token *v11; // edx

  tokens = scanner->tokens;
  if ( tokens <= 0 )
    return 0;
  current = scanner->current;
  v5 = tokens + 1;
  if ( current >= &scanner->table[tokens] || !current )
    return 0;
  if ( current->type != skipto )
  {
    if ( precedence >= current->precedence )
    {
      while ( current < (scanner_token *)&(&scanner->current)[4 * v5] )
      {
        v6 = current + 1;
        v7 = current + 2;
        v8 = &scanner->table[tokens];
        scanner->current = v6;
        if ( v7 >= v8 )
        {
          v6 = scanner->info->scan(scanner);
        }
        else if ( v6 >= v8 )
        {
          return 0;
        }
        if ( !v6 )
          break;
        if ( v6->type == skipto )
          goto LABEL_19;
        if ( v6->precedence > precedence )
        {
          if ( skipto != v6->type )
            return 0;
LABEL_19:
          tokens = scanner->tokens;
          goto LABEL_20;
        }
        tokens = scanner->tokens;
        if ( tokens <= 0 )
          return 0;
        current = scanner->current;
        v5 = tokens + 1;
      }
    }
    return 0;
  }
LABEL_20:
  if ( tokens <= 0 )
    return 0;
  v10 = scanner->current;
  v11 = &scanner->table[tokens];
  if ( v10 >= v11 )
    return 0;
  result = v10 + 1;
  scanner->current = v10 + 1;
  if ( &v10[2] >= v11 )
    return scanner->info->scan(scanner);
  if ( result >= v11 )
    return 0;
  return result;
}
// 80E9DE0: conditional instruction was optimized away because edx.4>=1

//----- (080E9E80) --------------------------------------------------------
void __cdecl init_scanner(scanner *scanner, scanner_info *scanner_info, unsigned __int8 *string, unsigned __int8 *end)
{
  char v4; // al
  const scan_table_info *scan_table_info; // esi
  $C75BC9A64E76601AC02310071A963720 type; // edx
  unsigned __int8 v7; // al
  int v8; // edi
  bool v9; // zf
  int *v10; // eax
  int length; // eax
  unsigned __int8 *source; // edi
  unsigned __int8 *v13; // eax
  int v14; // edx
  int v15; // [esp+1Ch] [ebp-3Ch]
  int v16; // [esp+28h] [ebp-30h]
  unsigned __int8 v17; // [esp+28h] [ebp-30h]
  unsigned __int8 v18; // [esp+28h] [ebp-30h]
  unsigned __int8 *v19; // [esp+30h] [ebp-28h]
  const scan_table_info *v20; // [esp+3Ch] [ebp-1Ch]

  v19 = end;
  v4 = *((_BYTE *)scanner_info + 1036);
  if ( (v4 & 1) == 0 )
  {
    scan_table_info = scanner_info->scan_table_info;
    if ( scan_table_info )
    {
      type = scan_table_info->type;
      if ( scan_table_info->type != SCAN_END )
      {
        v20 = scan_table_info + 1;
        while ( 1 )
        {
          if ( type == SCAN_RANGE )
          {
            v7 = *scan_table_info->data.string.source;
            v8 = v7;
            if ( !assert_failed )
            {
              assert_failed = v7 == 0;
              if ( v7
                || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c",
                    errline = 139,
                    elinks_internal("assertion index > 0 failed!"),
                    v7 = 0,
                    !assert_failed) )
              {
                v9 = scan_table_info->data.string.length <= 255;
                assert_failed = scan_table_info->data.string.length > 255;
                if ( v9
                  || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c",
                      errline = 140,
                      v18 = v7,
                      elinks_internal("assertion data->range.end < SCAN_TABLE_SIZE failed!"),
                      v7 = v18,
                      !assert_failed) )
                {
                  v9 = v8 <= scan_table_info->data.string.length;
                  assert_failed = v8 > scan_table_info->data.string.length;
                  if ( !v9 )
                  {
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
                    errline = 141;
                    v17 = v7;
                    elinks_internal("assertion index <= data->range.end failed!");
                    v7 = v17;
                  }
                }
              }
            }
            if ( scan_table_info->data.string.length >= v8 )
            {
              v10 = &scanner_info->scan_table[v7];
              do
              {
                ++v8;
                *v10++ |= scan_table_info->bits;
              }
              while ( v8 <= scan_table_info->data.string.length );
            }
            goto LABEL_14;
          }
          length = scan_table_info->data.string.length;
          source = scan_table_info->data.string.source;
          v15 = length - 1;
          if ( !assert_failed )
          {
            assert_failed = ((unsigned int)(length - 1) >> 31) | (type != SCAN_STRING);
            if ( !assert_failed )
              goto LABEL_22;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
            errline = 150;
            v16 = length;
            elinks_internal("assertion info[i].type == SCAN_STRING && pos >= 0 failed!");
            length = v16;
          }
          if ( v15 >= 0 )
          {
LABEL_22:
            v13 = &source[length];
            do
            {
              v14 = *--v13;
              scanner_info->scan_table[v14] |= scan_table_info->bits;
            }
            while ( v13 != source );
            scan_table_info = v20;
            type = v20->type;
            ++v20;
            if ( type == SCAN_END )
            {
LABEL_15:
              v4 = *((_BYTE *)scanner_info + 1036);
              break;
            }
          }
          else
          {
LABEL_14:
            scan_table_info = v20;
            type = v20->type;
            ++v20;
            if ( type == SCAN_END )
              goto LABEL_15;
          }
        }
      }
    }
    *((_BYTE *)scanner_info + 1036) = v4 | 1;
  }
  memset(scanner, 0, sizeof(scanner));
  scanner->string = string;
  scanner->position = string;
  if ( !end )
    v19 = &string[strlen((const char *)string)];
  scanner->info = scanner_info;
  scanner->end = v19;
  scanner->current = scanner->table;
  scanner_info->scan(scanner);
}

//----- (080EA110) --------------------------------------------------------
int __cdecl map_scanner_string(
        scanner *scanner,
        const unsigned __int8 *ident,
        const unsigned __int8 *end,
        int base_type)
{
  int v4; // esi
  scanner_info *info; // eax
  const scanner_string_mapping *mappings; // ebx

  v4 = base_type;
  info = scanner->info;
  mappings = info->mappings;
  if ( info->mappings->name )
  {
    while ( 1 )
    {
      if ( mappings->base_type == base_type )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/scanner.c";
        errline = 28;
        if ( !elinks_strlcasecmp(mappings->name, 0xFFFFFFFF, ident, end - ident, 1) )
          break;
      }
      ++mappings;
      if ( !mappings->name )
        return v4;
    }
    return mappings->type;
  }
  return v4;
}

//----- (080EA1A0) --------------------------------------------------------
int secure_fprintf(secure_save_info *ssi, const char *format, ...)
{
  int v2; // esi
  va_list va; // [esp+28h] [ebp+10h] BYREF

  va_start(va, format);
  if ( !ssi || !ssi->fp || ssi->err )
    return -1;
  v2 = __vfprintf_chk(ssi->fp, 1, format, va);
  if ( v2 < 0 )
    ssi->err = *__errno_location();
  return v2;
}
// 8059268: using guessed type int __cdecl __vfprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080EA210) --------------------------------------------------------
int __cdecl secure_fputc(secure_save_info *ssi, int c)
{
  int v2; // esi

  if ( !ssi || !ssi->fp || ssi->err )
    return -1;
  v2 = fputc(c, ssi->fp);
  if ( v2 == -1 )
  {
    ssi->err = *__errno_location();
    secsave_errno_0 = SS_ERR_OTHER;
  }
  return v2;
}

//----- (080EA280) --------------------------------------------------------
int __cdecl secure_fputs(secure_save_info *ssi, const char *s)
{
  int v2; // esi

  if ( !ssi || !ssi->fp || ssi->err )
    return -1;
  v2 = fputs(s, ssi->fp);
  if ( v2 == -1 )
  {
    secsave_errno_0 = SS_ERR_OTHER;
    ssi->err = *__errno_location();
  }
  return v2;
}

//----- (080EA2F0) --------------------------------------------------------
int __cdecl secure_close(secure_save_info *ssi)
{
  int err; // esi
  FILE *fp; // eax
  unsigned __int8 *file_name; // eax
  unsigned __int8 *tmp_file_name; // edx
  int v6; // eax

  err = -1;
  if ( ssi )
  {
    fp = ssi->fp;
    if ( !ssi->fp )
      goto free;
    err = ssi->err;
    if ( err )
      goto LABEL_15;
    if ( !ssi->secure_save )
      goto LABEL_5;
    if ( fflush(ssi->fp) == -1 )
    {
LABEL_14:
      err = *__errno_location();
      secsave_errno_0 = SS_ERR_OTHER;
      fp = ssi->fp;
LABEL_15:
      fclose(fp);
      goto free;
    }
    if ( get_opt_(config_options, "infofiles.secure_save_fsync")->number )
    {
      v6 = fileno(ssi->fp);
      if ( fsync(v6) )
        goto LABEL_14;
      fp = ssi->fp;
    }
    else
    {
      fp = ssi->fp;
    }
LABEL_5:
    if ( fclose(fp) == -1 )
    {
      err = *__errno_location();
      secsave_errno_0 = SS_ERR_OTHER;
    }
    else if ( ssi->secure_save )
    {
      file_name = ssi->file_name;
      if ( file_name )
      {
        tmp_file_name = ssi->tmp_file_name;
        if ( !tmp_file_name )
        {
LABEL_10:
          mem_free(file_name);
LABEL_11:
          mem_free(ssi);
          return err;
        }
        if ( rename((const char *)tmp_file_name, (const char *)ssi->file_name) == -1 )
        {
          err = *__errno_location();
          secsave_errno_0 = SS_ERR_RENAME;
        }
      }
    }
free:
    if ( ssi->tmp_file_name )
      mem_free(ssi->tmp_file_name);
    file_name = ssi->file_name;
    if ( !file_name )
      goto LABEL_11;
    goto LABEL_10;
  }
  return err;
}

//----- (080EA430) --------------------------------------------------------
secure_save_info *__cdecl secure_open(unsigned __int8 *file_name)
{
  __mode_t v1; // eax
  __mode_t v2; // esi
  option_value *v3; // ebx
  unsigned __int8 *v4; // eax
  int v5; // eax
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // edi
  int v8; // eax
  FILE *v9; // eax
  int v10; // eax
  option_value *v12; // [esp+0h] [ebp-88h]
  char v13[16]; // [esp+10h] [ebp-78h] BYREF
  int v14; // [esp+20h] [ebp-68h]

  v1 = umask(0x7Fu);
  secsave_errno_0 = SS_ERR_NONE;
  v2 = v1;
  if ( (get_opt_(cmdline_options, "no-connect")->number || get_opt_(cmdline_options, "session-ring")->number)
    && !get_opt_(cmdline_options, "touch-files")->number )
  {
    secsave_errno_0 = SS_ERR_DISABLED;
    v3 = 0;
    goto LABEL_17;
  }
  v3 = (option_value *)mem_calloc(1u, 0x14u);
  if ( !v3 )
  {
    secsave_errno_0 = SS_ERR_OUT_OF_MEM;
    goto LABEL_17;
  }
  v3[4].tree = get_opt_(config_options, "infofiles.secure_save")->tree;
  v4 = stracpy(file_name);
  v3[1].number = (int)v4;
  if ( !v4 )
  {
    secsave_errno_0 = SS_ERR_OUT_OF_MEM;
    goto LABEL_20;
  }
  if ( __lxstat64(3, v4, v13) )
  {
    v5 = *__errno_location();
    if ( v5 == 2 )
      goto LABEL_7;
    v3[3].number = v5;
    secsave_errno_0 = SS_ERR_STAT;
LABEL_19:
    mem_free(v3[1].tree);
    v3[1].number = 0;
LABEL_20:
    v12 = v3;
    v3 = 0;
    mem_free(v12);
    goto LABEL_17;
  }
  if ( (v14 & 0xF000) != 0x8000 )
  {
    v3[4].number = 0;
    goto LABEL_16;
  }
  if ( access((const char *)v3[1].tree, 6) < 0 )
  {
    v3[3].number = *__errno_location();
    secsave_errno_0 = SS_ERR_ACCESS;
    goto LABEL_19;
  }
LABEL_7:
  if ( !v3[4].number )
  {
LABEL_16:
    v10 = ((int (__cdecl *)(_DWORD, _DWORD))fopen64)((option_value)v3[1].number, "wb");
    v3->number = v10;
    if ( v10 )
      goto LABEL_17;
    secsave_errno_0 = SS_ERR_OPEN_WRITE;
    v3[3].number = *__errno_location();
    goto LABEL_19;
  }
  v6 = straconcat(v3[1].string, ".tmp_XXXXXX", 0);
  v7 = v6;
  if ( !v6 )
  {
    secsave_errno_0 = SS_ERR_OUT_OF_MEM;
    goto LABEL_19;
  }
  v8 = mkstemp64(v6);
  if ( v8 == -1 )
  {
    secsave_errno_0 = SS_ERR_MKSTEMP;
    mem_free(v7);
    goto LABEL_19;
  }
  v9 = fdopen(v8, "w");
  v3->number = (int)v9;
  if ( !v9 )
  {
    secsave_errno_0 = SS_ERR_OPEN_WRITE;
    v3[3].number = *__errno_location();
    mem_free(v7);
    goto LABEL_19;
  }
  v3[2].number = (int)v7;
LABEL_17:
  umask(v2);
  return (secure_save_info *)v3;
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 80591F8: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);
// 8059588: using guessed type int __cdecl mkstemp64(_DWORD);
// 80EA430: using guessed type char var_78[16];

//----- (080EA6E0) --------------------------------------------------------
unsigned __int8 *__cdecl secsave_strerror(secsave_errno secsave_error, terminal *term)
{
  int v2; // eax
  int v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *result; // eax
  int terminal_codepage; // eax
  int v7; // ebx
  unsigned __int8 *cp_mime_name; // eax
  int v9; // eax
  int v10; // ebx
  unsigned __int8 *v11; // eax
  int v12; // eax
  int v13; // ebx
  unsigned __int8 *v14; // eax
  int v15; // eax
  int v16; // ebx
  unsigned __int8 *v17; // eax
  int v18; // eax
  int v19; // ebx
  unsigned __int8 *v20; // eax
  int v21; // eax
  int v22; // ebx
  unsigned __int8 *v23; // eax
  int v24; // eax
  int v25; // ebx
  unsigned __int8 *v26; // eax
  int v27; // eax
  int v28; // ebx
  unsigned __int8 *v29; // eax

  switch ( secsave_error )
  {
    case SS_ERR_DISABLED:
      if ( term )
      {
        terminal_codepage = get_terminal_codepage(term);
        v7 = terminal_codepage;
        if ( terminal_codepage != current_charset )
        {
          cp_mime_name = get_cp_mime_name(terminal_codepage);
          bind_textdomain_codeset("elinks", cp_mime_name);
          current_charset = v7;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_8125A54);
      break;
    case SS_ERR_OUT_OF_MEM:
      if ( term )
      {
        v18 = get_terminal_codepage(term);
        v19 = v18;
        if ( v18 != current_charset )
        {
          v20 = get_cp_mime_name(v18);
          bind_textdomain_codeset("elinks", v20);
          current_charset = v19;
        }
      }
      result = gettext((const unsigned __int8 *)byte_8127CFF);
      break;
    case SS_ERR_OPEN_READ:
      if ( term )
      {
        v12 = get_terminal_codepage(term);
        v13 = v12;
        if ( v12 != current_charset )
        {
          v14 = get_cp_mime_name(v12);
          bind_textdomain_codeset("elinks", v14);
          current_charset = v13;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_8135046);
      break;
    case SS_ERR_OPEN_WRITE:
      if ( term )
      {
        v24 = get_terminal_codepage(term);
        v25 = v24;
        if ( v24 != current_charset )
        {
          v26 = get_cp_mime_name(v24);
          bind_textdomain_codeset("elinks", v26);
          current_charset = v25;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_81350B8);
      break;
    case SS_ERR_STAT:
      if ( term )
      {
        v9 = get_terminal_codepage(term);
        v10 = v9;
        if ( v9 != current_charset )
        {
          v11 = get_cp_mime_name(v9);
          bind_textdomain_codeset("elinks", v11);
          current_charset = v10;
        }
      }
      result = gettext((const unsigned __int8 *)byte_813505B);
      break;
    case SS_ERR_ACCESS:
      if ( term )
      {
        v21 = get_terminal_codepage(term);
        v22 = v21;
        if ( v21 != current_charset )
        {
          v23 = get_cp_mime_name(v21);
          bind_textdomain_codeset("elinks", v23);
          current_charset = v22;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_8135072);
      break;
    case SS_ERR_MKSTEMP:
      if ( term )
      {
        v15 = get_terminal_codepage(term);
        v16 = v15;
        if ( v15 != current_charset )
        {
          v17 = get_cp_mime_name(v15);
          bind_textdomain_codeset("elinks", v17);
          current_charset = v16;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_8135089);
      break;
    case SS_ERR_RENAME:
      if ( term )
      {
        v27 = get_terminal_codepage(term);
        v28 = v27;
        if ( v27 != current_charset )
        {
          v29 = get_cp_mime_name(v27);
          bind_textdomain_codeset("elinks", v29);
          current_charset = v28;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_81350A1);
      break;
    default:
      if ( term )
      {
        v2 = get_terminal_codepage(term);
        v3 = v2;
        if ( v2 != current_charset )
        {
          v4 = get_cp_mime_name(v2);
          bind_textdomain_codeset("elinks", v4);
          current_charset = v3;
        }
      }
      result = gettext((const unsigned __int8 *)&byte_81350CE);
      break;
  }
  return result;
}
// 8125A54: using guessed type char byte_8125A54;
// 8135046: using guessed type char byte_8135046;
// 8135072: using guessed type char byte_8135072;
// 8135089: using guessed type char byte_8135089;
// 81350A1: using guessed type char byte_81350A1;
// 81350B8: using guessed type char byte_81350B8;
// 81350CE: using guessed type char byte_81350CE;

//----- (080EAA20) --------------------------------------------------------
void dummy_snprintf()
{
  ;
}

//----- (080EAA30) --------------------------------------------------------
unsigned __int8 *asprintfa(const char *fmt, ...)
{
  void *v1; // ebx
  size_t v2; // esi
  char *s; // [esp+1Ch] [ebp-Ch] BYREF
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, fmt);
  v1 = 0;
  if ( vasprintf(&s, fmt, va) >= 0 )
  {
    v2 = strlen(s) + 1;
    v1 = mem_alloc(v2);
    if ( v1 )
      memcpy(v1, s, v2);
    free(s);
  }
  return (unsigned __int8 *)v1;
}

//----- (080EAAA0) --------------------------------------------------------
string *__cdecl init_string(string *string)
{
  unsigned __int8 *v1; // eax

  if ( assert_failed
    || (assert_failed = string == 0, !string)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 307,
        elinks_internal("assertion string != NULL failed: [init_string]"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    string->length = 0;
    v1 = (unsigned __int8 *)mem_alloc(0x100u);
    string->source = v1;
    if ( v1 )
    {
      *v1 = 0;
      return string;
    }
  }
  return 0;
}

//----- (080EAB30) --------------------------------------------------------
int __cdecl elinks_strlcmp(const unsigned __int8 *s1, size_t n1, const unsigned __int8 *s2, size_t n2)
{
  size_t v4; // ebx
  size_t v5; // ecx
  int result; // eax
  int v7; // edx
  unsigned __int8 v8; // al
  unsigned __int8 v9; // cl
  size_t v10; // eax
  size_t v11; // eax

  v4 = n1;
  v5 = n2;
  if ( !s2 || !s1 )
    return 1;
  if ( n1 != -1 )
  {
    if ( n2 != -1 )
      goto LABEL_5;
LABEL_18:
    v10 = strlen((const char *)s2);
    assert_failed = 0;
    result = v4 - v10;
    if ( result )
      return result;
    goto LABEL_6;
  }
  v11 = strlen((const char *)s1);
  v5 = n2;
  v4 = v11;
  if ( n2 == -1 )
    goto LABEL_18;
LABEL_5:
  result = v4 - v5;
  assert_failed = 0;
  if ( v4 != v5 )
    return result;
LABEL_6:
  if ( v4 && *s1 && *s2 )
  {
    if ( *s1 == *s2 )
    {
      v7 = 0;
      while ( v4 > ++v7 )
      {
        v8 = s1[v7];
        if ( !v8 )
          break;
        v9 = s2[v7];
        if ( !v9 )
          break;
        result = v8 - v9;
        if ( result )
          return result;
      }
    }
    return *s1 - *s2;
  }
  return result;
}

//----- (080EAC10) --------------------------------------------------------
void __cdecl done_string(string *string)
{
  if ( assert_failed
    || (assert_failed = string == 0, !string)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 328,
        elinks_internal("assertion string != NULL failed: [done_string]"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    if ( string->source )
      mem_free(string->source);
    string->source = 0;
    string->length = 0;
  }
}

//----- (080EACA0) --------------------------------------------------------
void __cdecl add_to_strn(unsigned __int8 **dst, const unsigned __int8 *src)
{
  _BOOL4 v2; // eax
  unsigned __int8 *v3; // esi
  size_t v4; // edi
  unsigned __int8 *v5; // esi
  size_t v6; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (v2 = *dst == 0 || src == 0, (assert_failed = v2) != 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 108,
        elinks_internal("assertion *dst && src failed: [add_to_strn]"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    v3 = *dst;
    v6 = strlen((const char *)*dst);
    v4 = strlen((const char *)src) + 1;
    v5 = (unsigned __int8 *)mem_realloc(v3, v4 + v6);
    if ( v5 )
    {
      memcpy(&v5[v6], src, v4);
      *dst = v5;
    }
  }
}

//----- (080EAD80) --------------------------------------------------------
unsigned __int8 *__cdecl memacpy(const unsigned __int8 *src, int len)
{
  int v2; // ebx
  size_t v3; // eax
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // esi

  v2 = len;
  if ( assert_failed
    || (assert_failed = (unsigned int)len >> 31, len < 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 77,
        elinks_internal("assertion len >= 0 failed: [memacpy]"),
        assert_failed) )
  {
    assert_failed = 0;
    v3 = 1;
    v2 = 0;
  }
  else
  {
    v3 = len + 1;
  }
  v4 = (unsigned __int8 *)mem_alloc(v3);
  v5 = v4;
  if ( v4 )
  {
    if ( v2 && src )
      memcpy(v4, src, v2);
    v5[v2] = 0;
  }
  return v5;
}

//----- (080EAE40) --------------------------------------------------------
unsigned __int8 *__cdecl stracpy(const unsigned __int8 *src)
{
  int v2; // eax

  if ( assert_failed
    || (assert_failed = src == 0, !src)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 92,
        elinks_internal("assertion src failed: [stracpy]"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v2 = strlen((const char *)src);
    return memacpy(src, v2);
  }
}

//----- (080EAED0) --------------------------------------------------------
unsigned __int8 *straconcat(const unsigned __int8 *str, ...)
{
  const char **v1; // esi
  const char *v2; // ebx
  size_t v3; // eax
  size_t v4; // edi
  unsigned __int8 *v5; // edx
  unsigned __int8 *v7; // [esp+10h] [ebp-28h]
  unsigned int len; // [esp+14h] [ebp-24h]
  size_t n; // [esp+18h] [ebp-20h]
  unsigned __int8 *s; // [esp+1Ch] [ebp-1Ch]
  va_list va; // [esp+44h] [ebp+Ch] BYREF

  va_start(va, str);
  if ( assert_failed
    || (assert_failed = str == 0, !str)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 144,
        elinks_internal("assertion str != NULL failed: [straconcat]"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  n = strlen((const char *)str);
  s = (unsigned __int8 *)mem_alloc(n + 1);
  if ( !s )
    return s;
  if ( n )
    memcpy(s, str, n);
  va_copy((va_list)v1, va);
  while ( 1 )
  {
    v2 = *v1;
    if ( !*v1 )
      break;
    while ( 1 )
    {
      ++v1;
      v3 = strlen(v2);
      v4 = v3;
      if ( !v3 )
        break;
      len = v3 + n;
      v5 = (unsigned __int8 *)mem_realloc(s, v3 + n + 1);
      if ( !v5 )
      {
        mem_free(s);
        return 0;
      }
      v7 = v5;
      memcpy(&v5[n], v2, v4);
      s = v7;
      n = len;
      v2 = *v1;
      if ( !*v1 )
        goto LABEL_11;
    }
  }
LABEL_11:
  s[n] = 0;
  return s;
}

//----- (080EB040) --------------------------------------------------------
int __cdecl c_strncasecmp(const char *s1, const char *s2, size_t n)
{
  int v3; // ebx
  unsigned __int8 v4; // si
  unsigned __int8 v5; // al

  if ( !n )
    return 0;
  v3 = 0;
  while ( 1 )
  {
    v4 = c_tolower((unsigned __int8)s1[v3]);
    v5 = c_tolower((unsigned __int8)s2[v3]);
    if ( v4 != v5 )
      break;
    if ( v4 )
    {
      if ( n != ++v3 )
        continue;
    }
    return 0;
  }
  return v4 < v5 ? -1 : 1;
}

//----- (080EB0B0) --------------------------------------------------------
char *__cdecl c_strcasestr(const char *haystack, const char *needle)
{
  const char *v2; // ebx
  size_t v3; // edi
  size_t v4; // eax
  size_t v5; // esi
  size_t v7; // edi

  v2 = haystack;
  v3 = strlen(haystack);
  v4 = strlen(needle);
  v5 = v4;
  if ( v3 < v4 )
    return 0;
  v7 = v3 + 1 - v4;
  if ( !v7 )
    return 0;
  while ( c_strncasecmp(v2, needle, v5) )
  {
    if ( !--v7 )
      return 0;
    ++v2;
  }
  return (char *)v2;
}

//----- (080EB130) --------------------------------------------------------
int __cdecl c_strcasecmp(const char *s1, const char *s2)
{
  int v2; // ebx
  unsigned __int8 v3; // si
  unsigned __int8 v4; // al

  v2 = 0;
  do
  {
    v3 = c_tolower((unsigned __int8)s1[v2]);
    v4 = c_tolower((unsigned __int8)s2[v2]);
    if ( v3 != v4 )
      return v3 < v4 ? -1 : 1;
    ++v2;
  }
  while ( v3 );
  return 0;
}

//----- (080EB190) --------------------------------------------------------
int __cdecl elinks_strlcasecmp(
        const unsigned __int8 *s1,
        size_t n1,
        const unsigned __int8 *s2,
        size_t n2,
        const int locale_indep)
{
  const unsigned __int8 *v5; // esi
  size_t v6; // ebx
  int result; // eax
  unsigned __int8 v8; // cl
  int v9; // ebx
  int v10; // edi
  int v11; // edi
  unsigned __int8 v12; // bl
  const __int32_t **v13; // eax
  int v14; // ecx
  unsigned __int8 v15; // dl
  const __int32_t *v16; // eax
  int v17; // ebx
  unsigned __int8 v18; // [esp+14h] [ebp-24h]

  v5 = s2;
  v6 = n2;
  if ( locale_indep )
  {
    if ( s2 && s1 )
    {
      if ( n1 == -1 )
        n1 = strlen((const char *)s1);
      if ( n2 == -1 )
        v6 = strlen((const char *)s2);
      assert_failed = 0;
      result = n1 - v6;
      if ( n1 == v6 )
      {
        if ( n1 )
        {
          v8 = *s1;
          if ( *s1 )
          {
            if ( *s2 )
            {
              v9 = 0;
              do
              {
                v10 = c_toupper(v8);
                v11 = v10 - c_toupper(*v5);
                if ( v11 )
                  break;
                if ( n1 <= ++v9 )
                  break;
                v8 = s1[v9];
                if ( !v8 )
                  break;
                v5 = &s2[v9];
              }
              while ( s2[v9] );
              return v11;
            }
          }
        }
      }
      return result;
    }
    return 1;
  }
  if ( !s2 || !s1 )
    return 1;
  if ( n1 == -1 )
    n1 = strlen((const char *)s1);
  if ( n2 == -1 )
    v6 = strlen((const char *)s2);
  assert_failed = 0;
  result = n1 - v6;
  if ( n1 == v6 )
  {
    if ( n1 && (v12 = *s1) != 0 && *s2 )
    {
      v18 = *s2;
      v13 = __ctype_toupper_loc();
      v14 = 0;
      v15 = v18;
      v16 = *v13;
      while ( 1 )
      {
        v17 = v16[v12] - v16[v15];
        if ( v17 )
          break;
        if ( n1 > ++v14 )
        {
          v12 = s1[v14];
          if ( v12 )
          {
            v15 = s2[v14];
            if ( v15 )
              continue;
          }
        }
        return 0;
      }
      return v17;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

//----- (080EB350) --------------------------------------------------------
unsigned __int8 *__cdecl safe_strncpy(unsigned __int8 *dst, const unsigned __int8 *src, size_t dst_size)
{
  unsigned __int8 *v3; // ebx

  v3 = dst;
  if ( assert_failed )
    goto LABEL_2;
  if ( src && dst && dst_size )
  {
    assert_failed = 0;
    goto LABEL_6;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
  errline = 188;
  elinks_internal("assertion dst && src && dst_size > 0 failed: [safe_strncpy]");
  if ( !assert_failed )
  {
LABEL_6:
    strncpy((char *)dst, (const char *)src, dst_size);
    dst[dst_size - 1] = 0;
    return v3;
  }
LABEL_2:
  assert_failed = 0;
  return 0;
}

//----- (080EB400) --------------------------------------------------------
int __cdecl xstrcmp(const unsigned __int8 *s1, const unsigned __int8 *s2)
{
  int result; // eax

  if ( !s1 )
    return -(s2 != 0);
  result = 1;
  if ( s2 )
    return strcmp((const char *)s1, (const char *)s2);
  return result;
}

//----- (080EB440) --------------------------------------------------------
unsigned __int8 *__cdecl insert_in_string(unsigned __int8 **dst, int pos, const unsigned __int8 *seq, int seqlen)
{
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // ebx
  size_t v8; // [esp+8h] [ebp-30h]
  void *dest; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *desta; // [esp+1Ch] [ebp-1Ch]

  v4 = *dst;
  dest = (void *)strlen((const char *)*dst);
  v5 = (unsigned __int8 *)mem_realloc(v4, (size_t)dest + seqlen + 1);
  v6 = v5;
  if ( v5 )
  {
    v8 = (size_t)dest - pos + 1;
    desta = &v5[pos];
    memmove(&v5[seqlen + pos], &v5[pos], v8);
    memcpy(desta, seq, seqlen);
    *dst = v6;
  }
  return v6;
}

//----- (080EB4D0) --------------------------------------------------------
void *__usercall mem_align_alloc___3@<eax>(void **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v3; // esi
  unsigned int v4; // edi
  void *result; // eax
  char *v7; // edx

  v3 = (a3 + 255) & 0xFFFFFF00;
  v4 = (a2 + 255) & 0xFFFFFF00;
  if ( v3 <= v4 )
    return *a1;
  v7 = (char *)mem_realloc(*a1, (a3 + 255) & 0xFFFFFF00);
  result = 0;
  if ( v7 )
  {
    *a1 = v7;
    memset(&v7[v4], 0, v3 - v4);
    return *a1;
  }
  return result;
}

//----- (080EB550) --------------------------------------------------------
string *add_format_to_string(string *string, const unsigned __int8 *format, ...)
{
  string *v2; // ebx
  int v3; // eax
  int v4; // esi
  int length; // edx
  int newlength; // [esp+2Ch] [ebp-1Ch]
  va_list va; // [esp+58h] [ebp+10h] BYREF

  va_start(va, format);
  v2 = string;
  if ( assert_failed
    || (assert_failed = string == 0 || format == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 502,
        elinks_internal("assertion string && format failed: [add_format_to_string]"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v3 = __vsnprintf_chk(0, 0, 1, -1, format, va);
    v4 = v3;
    if ( v3 > 0
      && (length = string->length,
          newlength = length + v3,
          mem_align_alloc___3((void **)&string->source, length, length + v3 + 1)) )
    {
      __vsnprintf_chk(&string->source[string->length], v4 + 1, 1, -1, format, va);
      string->length = newlength;
      string->source[newlength] = 0;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}
// 80590A8: using guessed type int __cdecl __vsnprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (080EB660) --------------------------------------------------------
string *__cdecl add_xchar_to_string(string *string, unsigned __int8 character, int times)
{
  string *v3; // ebx
  int length; // edx
  unsigned __int8 *source; // eax
  int newlength; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( character && string && times >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 476;
    elinks_internal("assertion string && character && times >= 0 failed: [add_xchar_to_string]");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  if ( times )
  {
    length = string->length;
    newlength = times + length;
    if ( mem_align_alloc___3((void **)&string->source, length, times + length + 1) )
    {
      memset(&string->source[string->length], character, times);
      source = string->source;
      string->length = newlength;
      source[newlength] = 0;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

//----- (080EB750) --------------------------------------------------------
void __cdecl free_string_list(list_head_elinks *list)
{
  void *next; // ebx

  if ( assert_failed
    || (assert_failed = list == 0, !list)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 557,
        elinks_internal("assertion list != NULL failed: [free_string_list]"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    while ( 1 )
    {
      next = list->next;
      if ( list->next == list )
        break;
      *(_DWORD *)(*(_DWORD *)next + 4) = *((_DWORD *)next + 1);
      **((_DWORD **)next + 1) = *(_DWORD *)next;
      if ( assert_failed )
      {
        assert_failed = 0;
      }
      else
      {
        assert_failed = 0;
        if ( *((_DWORD *)next + 2) )
          mem_free(*((void **)next + 2));
        *((_DWORD *)next + 2) = 0;
        *((_DWORD *)next + 3) = 0;
      }
      mem_free(next);
    }
  }
}

//----- (080EB820) --------------------------------------------------------
string *__cdecl add_to_string_list(list_head_elinks *list, const unsigned __int8 *source, int length)
{
  string *v3; // esi
  string *v4; // eax
  string *v5; // ebx
  unsigned __int8 *v6; // eax
  int v8; // edx
  int v9; // [esp+18h] [ebp-20h]
  string *v10; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = list == 0 || source == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 533,
        elinks_internal("assertion list && source failed: [add_to_string_list]"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  v3 = 0;
  v4 = (string *)mem_alloc(0x10u);
  v5 = v4;
  if ( v4 )
  {
    v10 = v4 + 1;
    v3 = v4 + 1;
    if ( length < 0 )
      length = strlen((const char *)source);
    if ( !assert_failed )
    {
      assert_failed = 0;
      v5[1].length = 0;
      v6 = (unsigned __int8 *)mem_alloc(0x100u);
      v5[1].source = v6;
      if ( !v6 )
        goto LABEL_19;
      *v6 = 0;
      if ( !assert_failed )
      {
        if ( source && length >= 0 )
        {
          assert_failed = 0;
LABEL_12:
          if ( !length )
          {
LABEL_13:
            v5->source = *(unsigned __int8 **)list->prev;
            v5->length = (int)list->prev;
            *(_DWORD *)list->prev = v5;
            *((_DWORD *)v5->source + 1) = v5;
            return v3;
          }
          v8 = v5[1].length;
          v9 = v8 + length;
          if ( mem_align_alloc___3((void **)&v10->source, v8, v8 + length + 1) )
          {
            memcpy(&v5[1].source[v5[1].length], source, length);
            v5[1].source[v9] = 0;
            v5[1].length = v9;
            goto LABEL_13;
          }
LABEL_19:
          v3 = 0;
          done_string(v10);
          mem_free(v5);
          return v3;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( !assert_failed )
          goto LABEL_12;
      }
    }
    assert_failed = 0;
    goto LABEL_19;
  }
  return v3;
}

//----- (080EBA30) --------------------------------------------------------
string *string_concat(string *string, ...)
{
  const char **v2; // esi
  const char *v3; // ebx
  signed int v4; // eax
  int length; // edx
  int v6; // [esp+18h] [ebp-20h]
  size_t n; // [esp+1Ch] [ebp-1Ch]
  va_list va; // [esp+44h] [ebp+Ch] BYREF

  va_start(va, string);
  if ( !assert_failed )
  {
    assert_failed = string == 0;
    if ( string
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
          errline = 438,
          elinks_internal("assertion string != NULL failed: [string_concat]"),
          !assert_failed) )
    {
      va_copy((va_list)v2, va);
      while ( 1 )
      {
        while ( 1 )
        {
          do
          {
            while ( 1 )
            {
              do
              {
                v3 = *v2;
                if ( !*v2 )
                  return string;
                ++v2;
              }
              while ( !*v3 );
              if ( !assert_failed )
              {
                assert_failed = string == 0;
                if ( string )
                  break;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
                errline = 347;
                elinks_internal("assertion string && source failed: [add_to_string]");
                if ( !assert_failed )
                  break;
              }
LABEL_9:
              assert_failed = 0;
            }
          }
          while ( !*v3 );
          v4 = strlen(v3);
          n = v4;
          if ( !string || v4 < 0 )
            break;
          assert_failed = 0;
          if ( v4 )
            goto LABEL_15;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        if ( assert_failed )
          goto LABEL_9;
        if ( n )
        {
LABEL_15:
          length = string->length;
          v6 = length + n;
          if ( mem_align_alloc___3((void **)&string->source, length, length + n + 1) )
          {
            memcpy(&string->source[string->length], v3, n);
            string->source[v6] = 0;
            string->length = v6;
          }
        }
      }
    }
  }
  assert_failed = 0;
  return 0;
}

//----- (080EBC00) --------------------------------------------------------
string *__cdecl add_crlf_to_string(string *string)
{
  string *v1; // ebx
  int length; // edi
  unsigned int v3; // esi
  unsigned int v4; // edi
  int v5; // eax
  unsigned __int8 *v7; // eax

  v1 = string;
  if ( assert_failed
    || (assert_failed = string == 0, !string)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 361,
        elinks_internal("assertion string != NULL failed: [add_crlf_to_string]"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  length = string->length;
  v3 = (length + 258) & 0xFFFFFF00;
  v4 = (length + 255) & 0xFFFFFF00;
  if ( v3 > v4 )
  {
    v7 = (unsigned __int8 *)mem_realloc(string->source, v3);
    if ( !v7 )
      return 0;
    string->source = v7;
    memset(&v7[v4], 0, v3 - v4);
  }
  if ( !string->source )
    return 0;
  v5 = string->length;
  string->source[v5] = 13;
  string->source[v5 + 1] = 10;
  string->length = v5 + 2;
  string->source[v5 + 2] = 0;
  return v1;
}

//----- (080EBD00) --------------------------------------------------------
string *__cdecl add_char_to_string(string *string, unsigned __int8 character)
{
  unsigned __int8 v2; // dl
  string *v3; // ebx
  int length; // edi
  unsigned int v5; // esi
  unsigned int v6; // edi
  int v7; // eax
  unsigned __int8 *v9; // eax
  unsigned __int8 v10; // [esp+1Ch] [ebp-1Ch]

  v2 = character;
  v3 = string;
  if ( assert_failed
    || (assert_failed = string == 0 || character == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 457,
        elinks_internal("assertion string && character failed: [add_char_to_string]"),
        v2 = character,
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  length = string->length;
  v5 = (length + 257) & 0xFFFFFF00;
  v6 = (length + 255) & 0xFFFFFF00;
  if ( v5 > v6 )
  {
    v10 = v2;
    v9 = (unsigned __int8 *)mem_realloc(string->source, v5);
    if ( !v9 )
      return 0;
    string->source = v9;
    memset(&v9[v6], 0, v5 - v6);
    v2 = v10;
  }
  if ( !string->source )
    return 0;
  v7 = string->length;
  string->source[v7] = v2;
  string->length = v7 + 1;
  string->source[v7 + 1] = 0;
  return v3;
}

//----- (080EBE20) --------------------------------------------------------
string *__cdecl add_to_string(string *string, const unsigned __int8 *source)
{
  string *v2; // ebx
  signed int v4; // eax
  size_t v5; // edi
  int length; // edx
  int v7; // [esp+1Ch] [ebp-1Ch]

  v2 = string;
  if ( assert_failed )
    goto LABEL_2;
  assert_failed = string == 0 || source == 0;
  if ( string == 0 || source == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 347;
    elinks_internal("assertion string && source failed: [add_to_string]");
    if ( assert_failed )
      goto LABEL_2;
    if ( !*source )
      return v2;
  }
  else if ( !*source )
  {
    return v2;
  }
  v4 = strlen((const char *)source);
  v5 = v4;
  if ( !string || v4 < 0 )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( !assert_failed )
      goto LABEL_8;
LABEL_2:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_8:
  if ( v5 )
  {
    length = string->length;
    v7 = v5 + length;
    if ( mem_align_alloc___3((void **)&string->source, length, v5 + length + 1) )
    {
      memcpy(&string->source[string->length], source, v5);
      string->source[v7] = 0;
      string->length = v7;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

//----- (080EBF80) --------------------------------------------------------
string *__cdecl add_string_to_string(string *string, const string *from)
{
  string *v2; // ebx
  int length; // esi
  int v5; // edx
  int v6; // edi
  unsigned __int8 *src; // [esp+1Ch] [ebp-1Ch]

  v2 = string;
  if ( assert_failed )
    goto LABEL_2;
  assert_failed = string == 0 || from == 0;
  if ( string == 0 || from == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c";
    errline = 380;
    elinks_internal("assertion string && from failed: [add_string_to_string]");
    if ( assert_failed )
      goto LABEL_2;
    length = from->length;
    if ( !length )
      return v2;
  }
  else
  {
    length = from->length;
    if ( !length )
      return v2;
  }
  src = from->source;
  if ( string && from->source && length >= 0 )
  {
    assert_failed = 0;
    goto LABEL_10;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
  errline = 255;
  elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
  if ( assert_failed )
  {
LABEL_2:
    assert_failed = 0;
    return 0;
  }
LABEL_10:
  v5 = string->length;
  v6 = v5 + length;
  if ( !mem_align_alloc___3((void **)&string->source, v5, v5 + length + 1) )
    return 0;
  memcpy(&string->source[string->length], src, length);
  string->source[v6] = 0;
  string->length = v6;
  return v2;
}

//----- (080EC0D0) --------------------------------------------------------
string *__cdecl add_file_to_string(string *string, const unsigned __int8 *filename)
{
  string *v2; // ebx
  int v3; // eax
  FILE *v4; // esi
  __int64 v5; // rax
  size_t v6; // edi
  int length; // ecx
  int v8; // eax
  size_t v9; // ecx
  size_t v10; // edx
  int v11; // edx
  unsigned __int8 *source; // eax
  unsigned __int8 *v14; // eax
  size_t v15; // [esp+14h] [ebp-24h]
  int v16; // [esp+18h] [ebp-20h]
  size_t v17; // [esp+18h] [ebp-20h]
  int newlength; // [esp+1Ch] [ebp-1Ch]

  v2 = string;
  if ( assert_failed
    || (assert_failed = string == 0 || filename == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.c",
        errline = 399,
        elinks_internal("assertion string && filename failed: [add_file_to_string]"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  v3 = fopen64(filename, 135476669);
  v4 = (FILE *)v3;
  if ( !v3 )
    return 0;
  if ( fseeko64(v3, 0, 0, 2) )
    goto err;
  v5 = ftello64(v4);
  v6 = v5;
  if ( ((unsigned int)v5 & HIDWORD(v5)) == -1 || fseeko64(v4, 0, 0, 0) )
    goto err;
  length = string->length;
  v8 = v6 + length;
  v9 = length + 255;
  LOBYTE(v9) = 0;
  v10 = v8 + 256;
  LOBYTE(v10) = 0;
  newlength = v8;
  if ( v10 > v9 )
  {
    v17 = v10;
    v15 = v9;
    v14 = (unsigned __int8 *)mem_realloc(string->source, v10);
    if ( v14 )
    {
      string->source = v14;
      memset(&v14[v15], 0, v17 - v15);
      goto LABEL_8;
    }
err:
    fclose(v4);
    return 0;
  }
LABEL_8:
  if ( !string->source )
    goto err;
  v16 = string->length;
  v11 = fread(&string->source[v16], 1u, v6, v4) + v16;
  source = string->source;
  string->length = v11;
  source[v11] = 0;
  fclose(v4);
  if ( string->length != newlength )
    goto err;
  return v2;
}
// 8058FD8: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8059098: using guessed type int __cdecl fseeko64(_DWORD, _DWORD, _DWORD, _DWORD);
// 8059328: using guessed type __int64 __cdecl ftello64(_DWORD);

//----- (080EC290) --------------------------------------------------------
timeval_T *__cdecl timeval_sub_interval(timeval_T *t, timeval_T *interval)
{
  timeval_T *result; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ecx
  int v6; // ebx

  result = t;
  v3 = t->sec - interval->sec;
  t->sec = v3;
  if ( v3 < 0 )
    goto LABEL_7;
  v4 = t->usec - interval->usec;
  t->usec = v4;
  if ( v4 < 0 )
  {
    v5 = v3 - 1;
    do
    {
      v6 = v5--;
      v4 += 1000000;
    }
    while ( v4 < 0 );
    t->usec = v4;
    t->sec = v6;
    if ( v6 < 0 )
    {
LABEL_7:
      t->sec = 0;
      t->usec = 0;
    }
  }
  return result;
}

//----- (080EC2F0) --------------------------------------------------------
timeval_T *__cdecl timeval_sub(timeval_T *res, timeval_T *older, timeval_T *newer)
{
  timeval_T *result; // eax
  int v4; // ecx
  int v5; // edx

  result = res;
  v4 = newer->sec - older->sec;
  res->sec = v4;
  v5 = newer->usec - older->usec;
  res->usec = v5;
  if ( v5 < 0 )
  {
    do
    {
      --v4;
      v5 += 1000000;
    }
    while ( v5 < 0 );
    res->usec = v5;
    res->sec = v4;
  }
  return result;
}

//----- (080EC330) --------------------------------------------------------
timeval_T *__cdecl timeval_add(timeval_T *res, timeval_T *base, timeval_T *t)
{
  timeval_T *result; // eax
  int v4; // ecx
  int v5; // edx

  result = res;
  v4 = base->sec + t->sec;
  res->sec = v4;
  v5 = base->usec + t->usec;
  res->usec = v5;
  if ( v5 > 999999 )
  {
    do
    {
      v5 -= 1000000;
      ++v4;
    }
    while ( v5 > 999999 );
    res->usec = v5;
    res->sec = v4;
  }
  return result;
}

//----- (080EC380) --------------------------------------------------------
timeval_T *__cdecl timeval_add_interval(timeval_T *t, timeval_T *interval)
{
  timeval_T *result; // eax
  int v3; // edx
  int sec; // ecx

  result = t;
  t->sec += interval->sec;
  v3 = interval->usec + t->usec;
  t->usec = v3;
  if ( v3 > 999999 )
  {
    sec = t->sec;
    do
    {
      v3 -= 1000000;
      ++sec;
    }
    while ( v3 > 999999 );
    t->usec = v3;
    t->sec = sec;
  }
  return result;
}

//----- (080EC3C0) --------------------------------------------------------
timeval_T *__cdecl timeval_from_double(timeval_T *t, double x)
{
  timeval_T *result; // eax
  int v3; // edx

  result = t;
  v3 = (int)x;
  t->sec = v3;
  t->usec = (int)((x - (long double)v3) * 1000000.0);
  return result;
}

//----- (080EC400) --------------------------------------------------------
timeval_T *__cdecl timeval_from_milliseconds(timeval_T *t, milliseconds_T milliseconds)
{
  timeval_T *result; // eax

  result = t;
  t->sec = milliseconds / 1000;
  t->usec = 1000 * (milliseconds % 1000);
  return result;
}

//----- (080EC440) --------------------------------------------------------
timeval_T *__cdecl timeval_from_seconds(timeval_T *t, int seconds)
{
  timeval_T *result; // eax

  result = t;
  t->usec = 0;
  t->sec = seconds;
  return result;
}

//----- (080EC460) --------------------------------------------------------
int __cdecl timeval_to_seconds(timeval_T *t)
{
  return t->sec + t->usec / 1000000;
}

//----- (080EC490) --------------------------------------------------------
int __cdecl timeval_is_positive(timeval_T *t)
{
  int result; // eax

  result = 1;
  if ( t->sec <= 0 )
  {
    if ( t->sec )
      LOBYTE(result) = 0;
    else
      return t->usec > 0;
  }
  return result;
}

//----- (080EC4C0) --------------------------------------------------------
void __cdecl timeval_limit_to_zero_or_one(timeval_T *t)
{
  if ( t->sec < 0 )
    t->sec = 0;
  if ( t->usec < 0 )
    t->usec = 0;
}

//----- (080EC500) --------------------------------------------------------
int __cdecl timeval_cmp(timeval_T *t1, timeval_T *t2)
{
  int result; // eax

  result = 1;
  if ( t1->sec <= t2->sec )
  {
    if ( t1->sec < t2->sec )
      return -1;
    else
      return t1->usec - t2->usec;
  }
  return result;
}

//----- (080EC540) --------------------------------------------------------
int __cdecl timeval_div_off_t(off_t n, timeval_T *t)
{
  int v2; // ecx
  __int64 v4; // [esp+18h] [ebp-30h]

  v2 = 0x7FFFFFFF;
  v4 = 1000LL * t->sec + t->usec / 1000;
  if ( v4 )
    return 1000 * n / v4;
  return v2;
}

//----- (080EC5E0) --------------------------------------------------------
milliseconds_T __cdecl mult_ms(milliseconds_T a, int lb)
{
  if ( !assert_failed )
  {
    if ( lb >= 0 && a >= 0 && a < 0x7FFFFFFF / lb )
    {
      assert_failed = 0;
      return a * lb;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 183;
    elinks_internal("assertion la >= 0 && lb >= 0 && la < LONG_MAX / lb failed!");
    if ( !assert_failed )
      return a * lb;
  }
  assert_failed = 0;
  return 2147483;
}

//----- (080EC690) --------------------------------------------------------
milliseconds_T __cdecl add_ms_to_ms(milliseconds_T a, milliseconds_T b)
{
  if ( !assert_failed )
  {
    if ( b >= 0 && a >= 0 && b < 0x7FFFFFFF - a )
    {
      assert_failed = 0;
      return b + a;
    }
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 172;
    elinks_internal("assertion la >= 0 && lb >= 0 && lb < LONG_MAX - la failed!");
    if ( !assert_failed )
      return b + a;
  }
  assert_failed = 0;
  return 2147483;
}

//----- (080EC740) --------------------------------------------------------
milliseconds_T __cdecl sec_to_ms(int sec)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)sec > 0x20C49A;
    if ( (unsigned int)sec <= 0x20C49A )
      return 1000 * sec;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/time.c";
    errline = 160;
    elinks_internal("assertion sec >= 0 && sec < LONG_MAX / 1000L failed!");
    if ( !assert_failed )
      return 1000 * sec;
  }
  assert_failed = 0;
  return 2147483;
}

//----- (080EC7C0) --------------------------------------------------------
milliseconds_T __cdecl timeval_to_milliseconds(timeval_T *t)
{
  milliseconds_T v1; // eax

  v1 = sec_to_ms(t->sec);
  return add_ms_to_ms(v1, t->usec / 1000);
}

//----- (080EC810) --------------------------------------------------------
timeval_T *__cdecl timeval_now(timeval_T *t)
{
  timeval tv; // [esp+18h] [ebp-10h] BYREF

  gettimeofday(&tv, 0);
  *(timeval *)t = tv;
  return t;
}

//----- (080EC840) --------------------------------------------------------
void __usercall goto_url_action(
        session *ses@<eax>,
        unsigned __int8 *(*get_url)(session *, unsigned __int8 *, size_t)@<edx>)
{
  unsigned __int8 url[1024]; // [esp+1Ch] [ebp-40Ch] BYREF
  unsigned int v4; // [esp+41Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  if ( !get_url || !(int)get_url(ses, url, 1024) )
    url[0] = 0;
  dialog_goto_url(ses, url);
}

//----- (080EC8B0) --------------------------------------------------------
frame_event_status __cdecl do_action(session *ses, main_action action_id, int verbose)
{
  document_view *v3; // eax
  document_view *v4; // esi
  action *v5; // eax
  int current_link; // edi
  document *v7; // eax
  int v8; // edi
  action *v9; // eax
  frame_event_status result; // eax
  action *v11; // eax
  action *v12; // eax
  action *v13; // eax
  action *action; // eax
  unsigned __int8 *action_name; // eax
  int v16; // eax
  char status; // al
  int v18; // eax
  int v19; // eax
  int v20; // edx
  window *tab_by_number; // eax
  bool v22; // [esp+2Fh] [ebp-29h]
  terminal *term; // [esp+38h] [ebp-20h]
  int terma; // [esp+38h] [ebp-20h]
  terminal *termb; // [esp+38h] [ebp-20h]
  document *document; // [esp+3Ch] [ebp-1Ch]
  window *tab; // [esp+3Ch] [ebp-1Ch]

  term = ses->tab->term;
  v3 = current_frame(ses);
  v4 = v3;
  if ( action_id == -1 )
  {
    v8 = 0;
unknown_action:
    result = FRAME_EVENT_IGNORED;
    v22 = 0;
    if ( verbose )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/action.c";
      errline = 635;
      action_name = get_action_name(KEYMAP_MAIN, action_id);
      elinks_internal("No action handling defined for '%s'.", (const char *)action_name);
      result = FRAME_EVENT_IGNORED;
      v22 = 0;
    }
    goto LABEL_24;
  }
  if ( !v3 || !v3->vs )
  {
    action = get_action(KEYMAP_MAIN, action_id);
    if ( !action || (action->flags & 0x20000) == 0 )
      goto LABEL_8;
LABEL_30:
    v22 = 0;
    v8 = 0;
    result = FRAME_EVENT_OK;
    if ( ses->insert_mode != INSERT_MODE_ON )
    {
LABEL_25:
      if ( v22 )
      {
        refresh_view(ses, v4, 0);
        return 1;
      }
      return result;
    }
LABEL_31:
    if ( v4 && (terma = v4->vs->current_link, terma >= 0) && (document = v4->document, terma < document->nlinks) )
      termb = (terminal *)&document->links[terma];
    else
      termb = 0;
    if ( termb != (terminal *)v8 )
      ses->insert_mode = INSERT_MODE_OFF;
    goto LABEL_25;
  }
  v5 = get_action(KEYMAP_MAIN, action_id);
  if ( v5 && (v5->flags & 0x80000) != 0 && !try_jump_to_link_number(ses, v4) )
    goto LABEL_30;
  current_link = v4->vs->current_link;
  if ( current_link >= 0 )
  {
    v7 = v4->document;
    if ( current_link < v7->nlinks )
    {
      v8 = (int)&v7->links[current_link];
      goto LABEL_9;
    }
  }
LABEL_8:
  v8 = 0;
LABEL_9:
  v9 = get_action(KEYMAP_MAIN, action_id);
  if ( !v9 || (v9->flags & 0x40000) == 0 || (result = FRAME_EVENT_OK, ses->history.current) )
  {
    v11 = get_action(KEYMAP_MAIN, action_id);
    if ( v11 && (v11->flags & 0x100000) != 0 && !v8
      || (v12 = get_action(KEYMAP_MAIN, action_id)) != 0
      && (v12->flags & 0x200000) != 0
      && (!v8 || *(_DWORD *)(v8 + 4) <= 1u)
      || ((v13 = get_action(KEYMAP_MAIN, action_id)) == 0 || (v13->flags & 0x10000) != 0)
      && get_opt_(cmdline_options, "anonymous")->number )
    {
LABEL_38:
      v22 = 0;
      result = FRAME_EVENT_OK;
    }
    else
    {
      switch ( action_id )
      {
        case ACT_MAIN_ABORT_CONNECTION:
          abort_loading(ses, 1);
          print_screen_status(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_ADD_BOOKMARK:
          launch_bm_add_doc_dialog(term, 0, ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_ADD_BOOKMARK_LINK:
          launch_bm_add_link_dialog(term, 0, ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_ADD_BOOKMARK_TABS:
          bookmark_terminal_tabs_dialog(term);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_AUTH_MANAGER:
          auth_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_BACKSPACE_PREFIX:
          if ( !ses->kbdprefix.repeat_count )
            goto LABEL_38;
          draw_formatted(ses, 0);
          v16 = ses->kbdprefix.repeat_count / 10;
          ses->kbdprefix.repeat_count = v16;
          if ( v16 )
            highlight_links_with_prefixes_that_start_with_n(term, v4, v16);
          print_screen_status(ses);
          return 3;
        case ACT_MAIN_BOOKMARK_MANAGER:
          bookmark_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_CACHE_MANAGER:
          cache_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_CACHE_MINIMIZE:
          goto LABEL_48;
        case ACT_MAIN_COOKIE_MANAGER:
          cookie_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_COOKIES_LOAD:
          if ( !get_opt_(config_options, "cookies.save")->number )
            goto LABEL_38;
          load_cookies();
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_COPY_CLIPBOARD:
          result = copy_current_link_to_clipboard(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_DOCUMENT_INFO:
          document_info_dialog(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_DOWNLOAD_MANAGER:
          download_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_EXMODE:
        case ACT_MAIN_JUMP_TO_LINK:
        case ACT_MAIN_LUA_CONSOLE:
          goto LABEL_38;
        case ACT_MAIN_FILE_MENU:
          activate_bfu_technology(ses, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_FIND_NEXT:
          result = find_next(ses, v4, 1);
          goto ignore_action;
        case ACT_MAIN_FIND_NEXT_BACK:
          result = find_next(ses, v4, -1);
          goto ignore_action;
        case ACT_MAIN_FORGET_CREDENTIALS:
          free_auth();
LABEL_48:
          shrink_memory(1);
          goto LABEL_38;
        case ACT_MAIN_FORMHIST_MANAGER:
          formhist_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_FRAME_EXTERNAL_COMMAND:
          result = pass_uri_to_command(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_FRAME_MAXIMIZE:
          result = set_frame(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_FRAME_NEXT:
          next_frame(ses, 1);
          goto LABEL_155;
        case ACT_MAIN_FRAME_PREV:
          next_frame(ses, -1);
LABEL_155:
          draw_formatted(ses, 0);
          goto LABEL_38;
        case ACT_MAIN_GOTO_URL:
          goto_url_action(ses, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_GOTO_URL_CURRENT:
          goto_url_action(ses, get_current_url);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_GOTO_URL_CURRENT_LINK:
          goto_url_action(ses, get_current_link_url);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_GOTO_URL_HOME:
          goto_url_home(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_HEADER_INFO:
          protocol_header_dialog(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_HISTORY_MANAGER:
          history_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_HISTORY_MOVE_BACK:
          v19 = eat_kbd_repeat_count(ses);
          v20 = -1;
          if ( v19 > 0 )
            v20 = -v19;
          go_history_by_n(ses, v20);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_HISTORY_MOVE_FORWARD:
          v18 = eat_kbd_repeat_count(ses);
          if ( v18 <= 0 )
            v18 = 1;
          go_history_by_n(ses, v18);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_KEYBINDING_MANAGER:
          keybinding_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_KILL_BACKGROUNDED_CONNECTIONS:
          abort_background_connections();
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_LINK_DOWNLOAD:
        case ACT_MAIN_LINK_DOWNLOAD_IMAGE:
        case ACT_MAIN_LINK_DOWNLOAD_RESUME:
          result = download_link(ses, v4, action_id);
          goto ignore_action;
        case ACT_MAIN_LINK_EXTERNAL_COMMAND:
          result = pass_uri_to_command(ses, v4, 1);
          goto ignore_action;
        case ACT_MAIN_LINK_FOLLOW:
          result = enter(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_LINK_FOLLOW_RELOAD:
          result = enter(ses, v4, 1);
          goto ignore_action;
        case ACT_MAIN_LINK_MENU:
          link_menu(term, 0, ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_LINK_FORM_MENU:
          link_form_menu(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_MARK_GOTO:
          result = FRAME_EVENT_REFRESH;
          ses->kbdprefix.mark = KP_MARK_GOTO;
          v22 = v4 != 0;
          break;
        case ACT_MAIN_MARK_SET:
          result = FRAME_EVENT_REFRESH;
          ses->kbdprefix.mark = KP_MARK_SET;
          v22 = v4 != 0;
          break;
        case ACT_MAIN_MENU:
          activate_bfu_technology(ses, -1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_MOVE_CURSOR_DOWN:
          result = move_cursor_down(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_CURSOR_LEFT:
          result = move_cursor_left(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_CURSOR_LINE_START:
          result = move_cursor_line_start(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_CURSOR_RIGHT:
          result = move_cursor_right(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_CURSOR_UP:
          result = move_cursor_up(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_DOCUMENT_END:
          result = move_document_end(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_DOCUMENT_START:
          result = move_document_start(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_DOWN:
          result = move_link_dir(ses, v4, 0, 1);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_DOWN_LINE:
          result = move_link_down_line(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_LEFT:
          result = move_link_dir(ses, v4, -1, 0);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_LEFT_LINE:
          result = move_link_prev_line(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_NEXT:
          result = move_link(ses, v4, 1, v4->document->nlinks - 1, 0);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_PREV:
          result = move_link(ses, v4, -1, 0, v4->document->nlinks - 1);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_RIGHT:
          result = move_link_dir(ses, v4, 1, 0);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_RIGHT_LINE:
          result = move_link_next_line(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_UP:
          result = move_link_dir(ses, v4, 0, -1);
          goto ignore_action;
        case ACT_MAIN_MOVE_LINK_UP_LINE:
          result = move_link_up_line(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_PAGE_DOWN:
          result = move_page_down(ses, v4);
          goto ignore_action;
        case ACT_MAIN_MOVE_PAGE_UP:
          result = move_page_up(ses, v4);
          goto ignore_action;
        case ACT_MAIN_OPEN_LINK_IN_NEW_TAB:
          open_current_link_in_new_tab(ses, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND:
          open_current_link_in_new_tab(ses, 1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_OPEN_LINK_IN_NEW_WINDOW:
          open_in_new_window(term, send_open_in_new_window, ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_OPEN_NEW_TAB:
          open_uri_in_new_tab(ses, 0, 0, 1);
          goto LABEL_38;
        case ACT_MAIN_OPEN_NEW_TAB_IN_BACKGROUND:
          open_uri_in_new_tab(ses, 0, 1, 1);
          goto LABEL_38;
        case ACT_MAIN_OPEN_NEW_WINDOW:
          open_in_new_window(term, send_open_new_window, ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_OPEN_OS_SHELL:
          exec_shell(term);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_OPTIONS_MANAGER:
          options_manager(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_QUIT:
          exit_prog(ses, 1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_REALLY_QUIT:
          exit_prog(ses, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_REDRAW:
          redraw_terminal_cls(term);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_RELOAD:
          reload(ses, CACHE_MODE_INCREMENT);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_RERENDER:
          draw_formatted(ses, 2);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_RESET_FORM:
          result = reset_form(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_RESOURCE_INFO:
          resource_info(term);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_SAVE_AS:
          result = save_as(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_SAVE_FORMATTED:
          result = save_formatted_dlg(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_SAVE_OPTIONS:
          write_config(term);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_SAVE_URL_AS:
          save_url_as(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_SCROLL_DOWN:
          result = scroll_down(ses, v4);
          goto ignore_action;
        case ACT_MAIN_SCROLL_LEFT:
          result = scroll_left(ses, v4);
          goto ignore_action;
        case ACT_MAIN_SCROLL_RIGHT:
          result = scroll_right(ses, v4);
          goto ignore_action;
        case ACT_MAIN_SCROLL_UP:
          result = scroll_up(ses, v4);
          goto ignore_action;
        case ACT_MAIN_SEARCH:
          result = search_dlg(ses, v4, 1);
          goto ignore_action;
        case ACT_MAIN_SEARCH_BACK:
          result = search_dlg(ses, v4, -1);
          goto ignore_action;
        case ACT_MAIN_SEARCH_TYPEAHEAD:
        case ACT_MAIN_SEARCH_TYPEAHEAD_LINK:
        case ACT_MAIN_SEARCH_TYPEAHEAD_TEXT:
        case ACT_MAIN_SEARCH_TYPEAHEAD_TEXT_BACK:
          result = search_typeahead(ses, v4, action_id);
          goto ignore_action;
        case ACT_MAIN_SHOW_TERM_OPTIONS:
          terminal_options(term, 0, ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_SUBMIT_FORM:
          result = submit_form(ses, v4, 0);
          goto ignore_action;
        case ACT_MAIN_SUBMIT_FORM_RELOAD:
          result = submit_form(ses, v4, 1);
          goto ignore_action;
        case ACT_MAIN_TAB_CLOSE:
          close_tab(term, ses);
          return 3;
        case ACT_MAIN_TAB_CLOSE_ALL_BUT_CURRENT:
          close_all_tabs_but_current(ses);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TAB_EXTERNAL_COMMAND:
          result = pass_uri_to_command(ses, v4, 2);
          goto ignore_action;
        case ACT_MAIN_TAB_MENU:
          if ( !assert_failed )
          {
            tab = ses->tab;
            tab_by_number = get_tab_by_number(term, term->current_tab);
            assert_failed = tab != tab_by_number;
            if ( tab != tab_by_number )
            {
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/action.c";
              errline = 561;
              elinks_internal("assertion ses->tab == get_current_tab(term) failed!");
            }
          }
          status = (char)ses->status;
          if ( (status & 1) != 0 )
            tab_menu(ses, ses->tab->xpos, term->height - 1 - ((status & 2) != 0), 1);
          else
            tab_menu(ses, 0, 0, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TAB_MOVE_LEFT:
          move_current_tab(ses, -1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TAB_MOVE_RIGHT:
          move_current_tab(ses, 1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TAB_NEXT:
          switch_current_tab(ses, 1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TAB_PREV:
          switch_current_tab(ses, -1);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TERMINAL_RESIZE:
          resize_terminal_dialog(term);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_CSS:
          toggle_document_option(ses, "document.css.enable");
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_DISPLAY_IMAGES:
          toggle_document_option(ses, "document.browse.images.show_as_links");
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_DISPLAY_TABLES:
          toggle_document_option(ses, "document.html.display_tables");
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_DOCUMENT_COLORS:
          toggle_document_option(ses, "document.colors.use_document_colors");
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_HTML_PLAIN:
          toggle_plain_html(ses, ses->doc_view, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_MOUSE:
          toggle_mouse();
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_NUMBERED_LINKS:
          toggle_document_option(ses, "document.browse.links.numbering");
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_PLAIN_COMPRESS_EMPTY_LINES:
          toggle_document_option(ses, "document.plain.compress_empty_lines");
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_TOGGLE_WRAP_TEXT:
          toggle_wrap_text(ses, ses->doc_view, 0);
          result = FRAME_EVENT_OK;
          v22 = 0;
          break;
        case ACT_MAIN_VIEW_IMAGE:
          result = view_image(ses, v4, 0);
ignore_action:
          if ( result == FRAME_EVENT_SESSION_DESTROYED )
            return result;
          v22 = v4 != 0 && result == FRAME_EVENT_REFRESH;
          break;
        default:
          goto unknown_action;
      }
    }
LABEL_24:
    if ( ses->insert_mode != INSERT_MODE_ON )
      goto LABEL_25;
    goto LABEL_31;
  }
  return result;
}

//----- (080ED7E0) --------------------------------------------------------
int get_timer_duration()
{
  return timer_duration;
}

//----- (080ED7F0) --------------------------------------------------------
void __cdecl done_timer_0(module *module)
{
  kill_timer(&countdown);
}

//----- (080ED810) --------------------------------------------------------
void reset_timer()
{
  kill_timer(&countdown);
  if ( get_opt_(config_options, "ui.timer.enable")->number )
  {
    timer_duration = get_opt_(config_options, "ui.timer.duration")->number;
    install_timer(&countdown, 1000, count_down, 0);
  }
}

//----- (080ED890) --------------------------------------------------------
void __cdecl init_timer_0(module *module)
{
  reset_timer();
}

//----- (080ED8A0) --------------------------------------------------------
void __cdecl count_down(void *xxx)
{
  option_value *opt; // eax
  keybinding *v2; // eax
  terminal *next; // ebx
  term_event_modifier_T modifier; // edx
  int key; // eax
  term_event ev; // [esp+10h] [ebp-18h] BYREF

  if ( --timer_duration )
  {
    install_timer(&countdown, 1000, count_down, 0);
  }
  else
  {
    countdown = 0;
    opt = get_opt_(config_options, (unsigned __int8 *)&byte_8135106);
    v2 = kbd_nm_lookup(KEYMAP_MAIN, opt->string);
    if ( v2 )
    {
      next = (terminal *)terminals.next;
      modifier = v2->kbd.modifier;
      key = v2->kbd.key;
      ev.ev = EVENT_KBD;
      ev.info.mouse.x = key;
      for ( *(_QWORD *)&ev.info.size.height = (unsigned int)modifier; next != (terminal *)&terminals; next = next->next )
        term_send_event(next, &ev);
    }
    reset_timer();
  }
}

//----- (080ED980) --------------------------------------------------------
dump_output *__usercall dump_output_alloc@<eax>(int fd@<eax>, string *string@<edx>)
{
  dump_output *result; // eax
  bool v5; // dl

  if ( assert_failed
    || (v5 = fd != -1, (assert_failed = v5 ^ (string == 0)) != 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c",
        errline = 94,
        elinks_internal("assertion (fd == -1) ^ (string == NULL) failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    result = (dump_output *)mem_alloc(0x1000Cu);
    if ( result )
    {
      result->fd = fd;
      result->string = string;
      result->bufpos = 0;
    }
  }
  return result;
}

//----- (080EDA20) --------------------------------------------------------
int __usercall dump_output_flush@<eax>(dump_output *out@<eax>)
{
  string *string; // esi
  int bufpos; // edi
  int length; // eax
  int v6; // ecx
  size_t v7; // edx
  unsigned __int8 *v8; // eax
  size_t v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+18h] [ebp-20h]
  unsigned int v12; // [esp+1Ch] [ebp-1Ch]

  string = out->string;
  if ( !string )
  {
    if ( hard_write(out->fd, out->buf, out->bufpos) == out->bufpos )
      goto LABEL_5;
    return -1;
  }
  bufpos = out->bufpos;
  if ( assert_failed )
    goto LABEL_11;
  if ( bufpos < 0 )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( !assert_failed )
      goto LABEL_8;
LABEL_11:
    assert_failed = 0;
    return -1;
  }
  assert_failed = 0;
  if ( bufpos )
  {
LABEL_8:
    length = string->length;
    v6 = bufpos + length;
    v7 = bufpos + length + 256;
    v12 = (length + 255) & 0xFFFFFF00;
    LOBYTE(v7) = 0;
    if ( v7 > v12 )
    {
      v9 = v7;
      v11 = bufpos + length;
      v8 = (unsigned __int8 *)mem_realloc(string->source, v7);
      if ( !v8 )
        return -1;
      string->source = v8;
      memset(&v8[v12], 0, v9 - v12);
      v6 = v11;
    }
    if ( string->source )
    {
      v10 = v6;
      memcpy(&string->source[string->length], out->buf, bufpos);
      string->source[v10] = 0;
      string->length = v10;
      goto LABEL_5;
    }
    return -1;
  }
LABEL_5:
  out->bufpos = 0;
  return 0;
}

//----- (080EDB90) --------------------------------------------------------
int __usercall write_char@<eax>(unsigned __int8 c@<al>, dump_output *out@<edx>)
{
  size_t bufpos; // eax
  int result; // eax
  int v5; // eax
  int v6; // ecx
  dump_output *v7; // [esp+Ch] [ebp-Ch]

  bufpos = out->bufpos;
  if ( out->bufpos <= 0xFFFF )
    goto LABEL_2;
  v7 = out;
  v5 = dump_output_flush(out);
  out = v7;
  v6 = v5;
  result = -1;
  if ( !v6 )
  {
    bufpos = v7->bufpos;
LABEL_2:
    out->buf[bufpos] = c;
    out->bufpos = bufpos + 1;
    return 0;
  }
  return result;
}

//----- (080EDBE0) --------------------------------------------------------
int __usercall write_color_16@<eax>(unsigned __int8 color@<al>, dump_output *out@<edx>)
{
  unsigned __int8 *i; // ebx
  unsigned __int8 bufor[11]; // [esp+1h] [ebp-17h] BYREF
  unsigned int v6; // [esp+Ch] [ebp-Ch]

  v6 = __readgsdword(0x14u);
  strcpy((char *)&bufor[4], "30;40m");
  bufor[5] = (color & 7) + 48;
  *(_DWORD *)bufor = 993024795;
  if ( ((color >> 4) & 7) != 0 )
    bufor[8] += (color >> 4) & 7;
  else
    strcpy((char *)&bufor[6], "m");
  for ( i = bufor; *i; ++i )
  {
    if ( write_char(*i, out) )
      return -1;
  }
  return 0;
}

//----- (080EDC80) --------------------------------------------------------
int __usercall dump_nocolor@<eax>(document *document@<eax>, dump_output *out@<edx>)
{
  int v3; // ebx
  line *v4; // edx
  unsigned __int8 *v5; // eax
  unsigned __int8 v6; // di
  unsigned __int8 v7; // al
  int result; // eax
  int v9; // ebx
  line *v10; // eax
  int v11; // edx
  unicode_val_T v12; // edi
  int v13; // edx
  unsigned __int8 *k; // ebx
  int v15; // [esp+10h] [ebp-28h]
  int i; // [esp+10h] [ebp-28h]
  int v18; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+1Ch] [ebp-1Ch]

  if ( is_cp_utf8(document->options.cp) )
  {
    for ( i = 0; i < document->height; ++i )
    {
      v9 = 0;
      v10 = &document->data[i];
      for ( j = 0; j < v10->length; v10 = &document->data[i] )
      {
        v11 = (int)&v10->chars[j];
        v12 = *(_DWORD *)v11;
        if ( *(_DWORD *)v11 != -3 )
        {
          if ( *(char *)(v11 + 4) < 0 && v12 > 0xAF && v12 <= 0xDF )
            v12 = (unsigned __int8)byte_810DDD0[v12];
          if ( v12 - 32 > 0x5E && v12 <= 0x9F || v12 == 32 )
          {
            ++v9;
          }
          else
          {
            for ( ; v9; --v9 )
            {
              if ( write_char(0x20u, out) )
                return -1;
            }
            for ( k = encode_utf8(v12); *k; ++k )
            {
              if ( write_char(*k, out) )
                return -1;
            }
            v9 = 0;
          }
        }
        ++j;
      }
      if ( write_char(0xAu, out) )
        return -1;
    }
    goto LABEL_43;
  }
  v15 = 0;
  if ( document->height <= 0 )
  {
LABEL_43:
    v13 = dump_output_flush(out);
    result = 0;
    if ( v13 )
      return -1;
    return result;
  }
  while ( 1 )
  {
    v3 = 0;
    v4 = &document->data[v15];
    v18 = 0;
    if ( v4->length > 0 )
      break;
LABEL_9:
    if ( write_char(0xAu, out) )
      return -1;
    if ( ++v15 >= document->height )
      goto LABEL_43;
  }
  while ( 1 )
  {
    v5 = (unsigned __int8 *)&v4->chars[v18];
    v6 = *v5;
    if ( *v5 <= 0xAFu || (v5[4] & 0x80u) == 0 || *v5 > 0xDFu )
    {
      v7 = *v5;
      if ( v6 == 127 )
        goto LABEL_7;
    }
    else
    {
      v6 = byte_810DDD0[*v5];
      v7 = v6;
      if ( v6 == 127 )
        goto LABEL_7;
    }
    if ( v7 <= 0x1Fu || v7 == 32 )
    {
LABEL_7:
      ++v3;
      goto LABEL_8;
    }
    if ( v3 )
      break;
LABEL_22:
    if ( write_char(v6, out) )
      return -1;
    v3 = 0;
LABEL_8:
    ++v18;
    v4 = &document->data[v15];
    if ( v18 >= v4->length )
      goto LABEL_9;
  }
  while ( !write_char(0x20u, out) )
  {
    if ( !--v3 )
      goto LABEL_22;
  }
  return -1;
}

//----- (080EDF20) --------------------------------------------------------
string *__cdecl add_document_to_string(string *string, document *document)
{
  string *v2; // ebx
  dump_output *v3; // eax
  dump_output *v4; // esi
  int v5; // edi

  v2 = string;
  if ( assert_failed
    || (assert_failed = string == 0 || document == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c",
        errline = 610,
        elinks_internal("assertion string && document failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    v3 = dump_output_alloc(-1, string);
    v4 = v3;
    if ( !v3 )
      return 0;
    v5 = dump_nocolor(document, v3);
    mem_free(v4);
    if ( v5 )
      return 0;
  }
  return v2;
}

//----- (080EDFD0) --------------------------------------------------------
int __usercall write_color_256@<eax>(
        const unsigned __int8 *str@<eax>,
        unsigned __int8 color@<dl>,
        dump_output *out@<ecx>)
{
  unsigned __int8 *v4; // ebx
  unsigned __int8 bufor[16]; // [esp+2Ch] [ebp-1Ch] BYREF
  unsigned int v7; // [esp+3Ch] [ebp-Ch]

  v4 = bufor;
  v7 = __readgsdword(0x14u);
  __snprintf_chk(bufor, 16, 1, 16, "\x1B[%s;5;%dm", (const char *)str, color);
  while ( *v4 )
  {
    if ( write_char(*v4, out) )
      return -1;
    ++v4;
  }
  return 0;
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080EE060) --------------------------------------------------------
int __usercall dump_256color@<eax>(document *document@<eax>, dump_output *out@<edx>)
{
  unsigned __int8 v2; // si
  unsigned __int8 v3; // di
  line *v4; // ecx
  int v5; // ebx
  unsigned __int8 k; // dl
  int v7; // eax
  unsigned __int8 v8; // al
  int result; // eax
  unsigned __int8 v10; // si
  line *v11; // ecx
  int v12; // edi
  unsigned __int8 i; // dl
  int v14; // eax
  unicode_val_T v15; // ebx
  unsigned __int8 *j; // ebx
  int v17; // edx
  int v18; // [esp+10h] [ebp-38h]
  int number; // [esp+10h] [ebp-38h]
  int v20; // [esp+14h] [ebp-34h]
  int v21; // [esp+14h] [ebp-34h]
  char v23; // [esp+23h] [ebp-25h]
  char v24; // [esp+23h] [ebp-25h]
  int v26; // [esp+28h] [ebp-20h]
  unsigned __int8 v27; // [esp+28h] [ebp-20h]
  unsigned __int8 v28; // [esp+2Fh] [ebp-19h]
  unsigned __int8 v29; // [esp+2Fh] [ebp-19h]

  if ( is_cp_utf8(document->options.cp) )
  {
    number = get_opt_(config_options, "document.dump.width")->number;
    if ( document->height > 0 )
    {
      v21 = 0;
      v10 = 0;
      v29 = 0;
      while ( 1 )
      {
        write_color_256((const unsigned __int8 *)"38", v29, out);
        write_color_256((const unsigned __int8 *)"48", v10, out);
        v11 = &document->data[v21];
        if ( v11->length > 0 )
        {
          v12 = 0;
          v27 = v10;
          for ( i = v29; ; i = v29 )
          {
            v14 = (int)&v11->chars[v12];
            v24 = *(_BYTE *)(v14 + 4);
            v29 = *(_BYTE *)(v14 + 5);
            v15 = *(_DWORD *)v14;
            v10 = *(_BYTE *)(v14 + 6);
            if ( *(_DWORD *)v14 == -3 )
            {
              v10 = v27;
              v29 = i;
            }
            else
            {
              if ( v29 != i && write_color_256((const unsigned __int8 *)"38", v29, out)
                || v10 != v27 && write_color_256((const unsigned __int8 *)"48", v10, out) )
              {
                return -1;
              }
              if ( v24 < 0 && v15 > 0xAF && v15 <= 0xDF )
                v15 = (unsigned __int8)byte_810DDD0[v15];
              if ( v15 - 32 > 0x5E && v15 <= 0x9F )
                v15 = 32;
              for ( j = encode_utf8(v15); *j; ++j )
              {
                if ( write_char(*j, out) )
                  return -1;
              }
            }
            ++v12;
            v11 = &document->data[v21];
            if ( v12 >= v11->length )
              goto LABEL_60;
            v27 = v10;
          }
        }
        v12 = 0;
LABEL_60:
        if ( number > v12 )
          break;
LABEL_65:
        if ( write_char(0xAu, out) )
          return -1;
        if ( ++v21 >= document->height )
          goto LABEL_53;
      }
      while ( !write_char(0x20u, out) )
      {
        if ( number <= ++v12 )
          goto LABEL_65;
      }
      return -1;
    }
  }
  else
  {
    v18 = get_opt_(config_options, "document.dump.width")->number;
    if ( document->height > 0 )
    {
      v20 = 0;
      v2 = 0;
      v3 = 0;
      while ( 1 )
      {
        write_color_256((const unsigned __int8 *)"38", v3, out);
        write_color_256((const unsigned __int8 *)"48", v2, out);
        v4 = &document->data[v20];
        if ( v4->length > 0 )
          break;
        v5 = 0;
LABEL_46:
        if ( v18 > v5 )
        {
          while ( !write_char(0x20u, out) )
          {
            if ( v18 <= ++v5 )
              goto LABEL_51;
          }
          return -1;
        }
LABEL_51:
        if ( write_char(0xAu, out) )
          return -1;
        if ( ++v20 >= document->height )
          goto LABEL_53;
      }
      v5 = 0;
      v28 = v2;
      for ( k = v3; ; k = v3 )
      {
        v7 = (int)&v4->chars[v5];
        v23 = *(_BYTE *)(v7 + 4);
        v3 = *(_BYTE *)(v7 + 5);
        v2 = *(_BYTE *)(v7 + 6);
        v26 = *(_DWORD *)v7;
        if ( v3 != k )
        {
          if ( write_color_256((const unsigned __int8 *)"38", v3, out) )
            break;
        }
        if ( v2 != v28 && write_color_256((const unsigned __int8 *)"48", v2, out) )
          break;
        v8 = v26;
        if ( (unsigned __int8)v26 > 0xAFu && v23 < 0 && (unsigned __int8)v26 <= 0xDFu )
          v8 = byte_810DDD0[(unsigned __int8)v26];
        if ( v8 == 127 || v8 <= 0x1Fu )
        {
          if ( write_char(0x20u, out) )
            return -1;
        }
        else if ( write_char(v8, out) )
        {
          return -1;
        }
        ++v5;
        v4 = &document->data[v20];
        if ( v5 >= v4->length )
          goto LABEL_46;
        v28 = v2;
      }
      return -1;
    }
  }
LABEL_53:
  v17 = dump_output_flush(out);
  result = 0;
  if ( v17 )
    return -1;
  return result;
}

//----- (080EE470) --------------------------------------------------------
int __usercall dump_references@<eax>(document *document@<eax>, int fd@<edx>, unsigned __int8 *buf@<ecx>)
{
  ssize_t v7; // eax
  ssize_t v8; // esi
  document *v9; // edi
  int i; // ebx
  int v11; // eax
  link *v12; // edx
  const char *where; // eax
  const char *title; // edx
  unsigned __int8 *v15; // edx
  size_t v16; // [esp+24h] [ebp-24h]
  int v17; // [esp+28h] [ebp-20h]
  char *s; // [esp+2Ch] [ebp-1Ch]

  if ( document->nlinks && get_opt_(config_options, "document.dump.references")->number )
  {
    v7 = hard_write(fd, "\nReferences\n\n   Visible links\n", 0x1Eu);
    if ( v7 != 30 )
      return -1;
    if ( document->nlinks > 0 )
    {
      LOBYTE(v7) = 1;
      v17 = fd;
      v8 = v7;
      s = (char *)buf;
      v9 = document;
      for ( i = 0; ; ++i )
      {
        v12 = &v9->links[i];
        where = (const char *)v12->where;
        if ( where )
        {
          if ( (*((_BYTE *)&v9->options + 69) & 0x10) != 0 )
          {
            title = (const char *)v12->title;
            if ( title && *title )
              __snprintf_chk(s, 0x10000, 1, -1, "%4d. %s\n\t%s\n", v8, title, where);
            else
              __snprintf_chk(s, 0x10000, 1, -1, "%4d. %s\n", v8, where);
          }
          else
          {
            v15 = v12->title;
            if ( v15 && *v15 )
              __snprintf_chk(s, 0x10000, 1, -1, "   . %s\n\t%s\n", v15, where);
            else
              __snprintf_chk(s, 0x10000, 1, -1, "   . %s\n", where);
          }
          v16 = strlen(s);
          if ( hard_write(v17, (unsigned __int8 *)s, v16) != v16 )
            break;
        }
        v11 = v8++;
        if ( v9->nlinks <= v11 )
          return 0;
      }
      return -1;
    }
  }
  return 0;
}
// 8059918: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080EE640) --------------------------------------------------------
int __cdecl dump_to_file(document *document, int fd)
{
  dump_output *v2; // ebx
  int result; // eax
  int v4; // eax
  int v5; // [esp+1Ch] [ebp-1Ch]

  v2 = dump_output_alloc(fd, 0);
  result = -1;
  if ( v2 )
  {
    v4 = dump_nocolor(document, v2);
    if ( !v4 )
      v4 = dump_references(document, fd, v2->buf);
    v5 = v4;
    mem_free(v2);
    return v5;
  }
  return result;
}

//----- (080EE6B0) --------------------------------------------------------
void __usercall dump_print(unsigned __int8 *option_elinks@<eax>, string *url@<edx>)
{
  _BYTE *number; // ebx
  char i; // dl
  int v4; // ecx
  char v5; // al
  size_t v6; // edi
  _BYTE *v7; // esi
  char v8; // dl
  unsigned __int8 *source; // ebx
  unsigned __int8 v10; // al
  int v11; // ecx
  unsigned int v12; // eax
  size_t v13; // edx
  unsigned __int8 *v14; // eax
  size_t v15; // [esp+10h] [ebp-38h]
  int v16; // [esp+14h] [ebp-34h]
  int v17; // [esp+14h] [ebp-34h]
  int v18; // [esp+14h] [ebp-34h]
  unsigned int v19; // [esp+18h] [ebp-30h]
  string string; // [esp+28h] [ebp-20h] BYREF

  number = (_BYTE *)get_opt_(config_options, option_elinks)->number;
  if ( number && init_string(&string) )
  {
LABEL_3:
    for ( i = *number; ; i = v7[2] )
    {
      if ( !i )
      {
LABEL_17:
        source = string.source;
        if ( string.source )
        {
          __printf_chk(1, (const char *)"%s", (const char *)string.source);
          fflush(stdout);
          mem_free(source);
        }
        return;
      }
      if ( i == 37 || (v4 = 0, i == 92) )
      {
        v7 = number;
        v6 = 0;
        v4 = 0;
      }
      else
      {
        do
        {
          v5 = number[++v4];
          v6 = v4;
          v7 = &number[v4];
        }
        while ( v5 != 37 && v5 && v5 != 92 );
      }
      if ( assert_failed )
      {
LABEL_12:
        assert_failed = 0;
        goto LABEL_13;
      }
      if ( v4 < 0 )
      {
        v17 = v4;
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
        errline = 255;
        elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
        v4 = v17;
        if ( assert_failed )
          goto LABEL_12;
      }
      else
      {
        assert_failed = 0;
      }
      if ( v4 )
      {
        v11 = string.length + v4;
        v12 = string.length + 255;
        v13 = v11 + 256;
        LOBYTE(v12) = 0;
        LOBYTE(v13) = 0;
        v19 = v12;
        if ( v13 > v12 )
        {
          v15 = v13;
          v18 = v11;
          v14 = (unsigned __int8 *)mem_realloc(string.source, v13);
          if ( !v14 )
            goto LABEL_13;
          string.source = v14;
          memset(&v14[v19], 0, v15 - v19);
          v11 = v18;
        }
        if ( string.source )
        {
          v16 = v11;
          memcpy(&string.source[string.length], number, v6);
          string.source[v16] = 0;
          string.length = v16;
        }
      }
LABEL_13:
      if ( *v7 != 92 )
      {
        if ( *v7 != 37 )
          goto LABEL_17;
        v8 = v7[1];
        if ( v8 != 117 )
          goto LABEL_16;
        if ( url )
        {
          add_string_to_string(&string, url);
          v8 = v7[1];
LABEL_16:
          if ( !v8 )
            goto LABEL_17;
        }
        number = v7 + 2;
        goto LABEL_3;
      }
      v10 = v7[1];
      switch ( v10 )
      {
        case 0x6Eu:
          v10 = 10;
          break;
        case 0x74u:
          v10 = 9;
          break;
        case 0x66u:
          v10 = 12;
          break;
        case 0u:
          goto LABEL_17;
      }
      number = v7 + 2;
      add_char_to_string(&string, v10);
    }
  }
}
// 8058E98: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (080EE930) --------------------------------------------------------
void __cdecl dump_next(list_head_elinks *url_list)
{
  _DWORD *next; // eax
  string *v2; // ebx
  unsigned __int8 *v3; // eax
  string *v4; // esi
  unsigned __int8 *cwd; // edi
  uri *translated_uri; // ebx
  unsigned __int8 *v7; // eax
  unsigned __int8 *uristring; // [esp+2Ch] [ebp-1Ch]

  if ( url_list )
  {
    while ( 1 )
    {
      next = url_list->next;
      if ( url_list->next == url_list )
        break;
      *(_DWORD *)(*next + 4) = next[1];
      *(_DWORD *)next[1] = *next;
      *next = *(_DWORD *)todo_list_8837.prev;
      next[1] = todo_list_8837.prev;
      *(_DWORD *)todo_list_8837.prev = next;
      *(_DWORD *)(*next + 4) = next;
    }
  }
  v2 = (string *)todo_list_8837.next;
  if ( todo_list_8837.next != &todo_list_8837 )
  {
    program_0.terminate = 0;
    *(_DWORD *)(*(_DWORD *)todo_list_8837.next + 4) = *((_DWORD *)todo_list_8837.next + 1);
    *(_DWORD *)v2->length = v2->source;
    v3 = (unsigned __int8 *)done_list_8838.next;
    v2->length = (int)&done_list_8838;
    v2->source = v3;
    done_list_8838.next = v2;
    *((_DWORD *)v2->source + 1) = v2;
    if ( first_8843 )
      first_8843 = 0;
    else
      dump_print("document.dump.separator", 0);
    v4 = v2 + 1;
    dump_print("document.dump.header", v2 + 1);
    uristring = v2[1].source;
    cwd = (unsigned __int8 *)get_cwd();
    translated_uri = get_translated_uri(uristring, cwd);
    if ( cwd )
      mem_free(cwd);
    if ( translated_uri && !get_protocol_external_handler(0, translated_uri) )
    {
      dump_download.callback = dump_loading_callback;
      LODWORD(dump_pos) = 0;
      if ( load_uri(translated_uri, 0, &dump_download, PRI_MAIN, CACHE_MODE_ALWAYS, -1LL) )
      {
        dump_next(0);
        program_0.terminate = 1;
        program_0.retval = RET_SYNTAX;
      }
    }
    else
    {
      v7 = gettext("URL protocol not supported (%s).");
      usrerror(v7, uristring);
      dump_next(0);
      program_0.terminate = 1;
      program_0.retval = RET_SYNTAX;
      if ( !translated_uri )
      {
LABEL_14:
        dump_print("document.dump.footer", v4);
        return;
      }
    }
    done_uri(translated_uri);
    goto LABEL_14;
  }
  free_string_list(&done_list_8838);
  program_0.terminate = 1;
}

//----- (080EEB30) --------------------------------------------------------
void __cdecl dump_loading_callback(download *download, void *p)
{
  cache_entry *cached; // ebx
  connection_basic_state basic; // eax
  int number; // eax
  int v6; // eax
  option_value *opt; // eax
  dump_output *v8; // esi
  int v9; // edi
  line *v10; // ecx
  int v11; // eax
  int v12; // edx
  unicode_val_T v13; // ebx
  char v14; // cl
  unsigned __int8 *i; // ebx
  unsigned __int8 *state_message; // eax
  uri *redirect; // esi
  dump_output *next; // eax
  int v19; // ecx
  size_t v20; // edi
  ssize_t v21; // eax
  int v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 v24; // di
  line *v25; // ecx
  unsigned __int8 v26; // al
  int v27; // ebx
  unsigned __int8 v28; // al
  int v29; // edx
  char v30; // cl
  int v31; // esi
  int v32; // eax
  int *v33; // eax
  char *v34; // ebx
  unsigned __int8 *v35; // eax
  int v36; // eax
  dump_output *v37; // ebx
  int v38; // [esp+34h] [ebp-134h]
  char v39; // [esp+34h] [ebp-134h]
  char v40; // [esp+34h] [ebp-134h]
  int v41; // [esp+38h] [ebp-130h]
  int v42; // [esp+38h] [ebp-130h]
  int v43; // [esp+3Ch] [ebp-12Ch]
  int v44; // [esp+3Ch] [ebp-12Ch]
  document *document; // [esp+44h] [ebp-124h]
  dump_output *out; // [esp+48h] [ebp-120h]
  dump_output *outa; // [esp+48h] [ebp-120h]
  dump_output *outb; // [esp+48h] [ebp-120h]
  int fd; // [esp+4Ch] [ebp-11Ch]
  document_options doo; // [esp+5Ch] [ebp-10Ch] BYREF
  document_view doc_view; // [esp+E4h] [ebp-84h] BYREF
  view_state vs; // [esp+120h] [ebp-48h] BYREF

  cached = download->cached;
  fd = get_output_handle();
  if ( fd != -1 )
  {
    if ( cached )
    {
      if ( cached->redirect )
      {
        if ( dump_redir_count++ <= 9 )
        {
          redirect = cached->redirect;
          cancel_download(download, 0);
          load_uri(redirect, cached->uri, download, PRI_MAIN, CACHE_MODE_ALWAYS, -1LL);
          return;
        }
      }
    }
    if ( download->state.basic > (unsigned int)S_PROC )
    {
      if ( !get_opt_(cmdline_options, "dump")->number )
      {
        if ( cached )
        {
          outa = (dump_output *)&cached->frag;
          while ( 1 )
          {
            next = (dump_output *)cached->frag.next;
            if ( next == outa )
              break;
            while ( 1 )
            {
              v19 = dump_pos - next->fd;
              if ( v19 >= 0 && *(_QWORD *)&next->buf[4] > v19 )
                break;
              next = (dump_output *)next->bufpos;
              if ( next == outa )
                goto LABEL_50;
            }
            v20 = *(_DWORD *)&next->buf[4] - v19;
            v21 = hard_write(fd, &next->buf[v19 + 20], v20);
            if ( v20 != v21 )
            {
              v38 = v21;
              detach_connection(download, (int)dump_pos);
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/dump/dump.c";
              if ( v38 < 0 )
              {
                errline = 401;
                v33 = __errno_location();
                v34 = strerror(*v33);
                v35 = gettext("Can't write to stdout: %s");
                elinks_error(v35, v34);
              }
              else
              {
                errline = 404;
                v23 = gettext("Can't write to stdout.");
                elinks_error(v23);
              }
              goto LABEL_38;
            }
            LODWORD(dump_pos) = dump_pos + v20;
            detach_connection(download, (int)dump_pos);
          }
        }
LABEL_50:
        basic = download->state.basic;
        if ( basic >= S_WAIT )
          return;
LABEL_36:
        if ( basic != S_OK )
        {
          state_message = get_state_message(download->state, 0);
          usrerror(state_message);
LABEL_38:
          program_0.retval = RET_ERROR;
        }
        program_0.terminate = 1;
        dump_next(0);
        return;
      }
      basic = download->state.basic;
      if ( basic > S_PROC )
        return;
      if ( !cached )
        goto LABEL_36;
      memset(&doc_view, 0, sizeof(doc_view));
      init_document_options(&doo);
      number = get_opt_(config_options, "document.dump.width")->number;
      doo.box.x = 0;
      doo.box.y = 1;
      doo.box.height = 25;
      if ( number < 0 )
        number = 0;
      doo.box.width = number;
      doo.cp = get_opt_(config_options, "document.dump.codepage")->number;
      v6 = get_opt_(config_options, "document.dump.color_mode")->number;
      *((_BYTE *)&doo + 69) &= ~0x40u;
      *((_BYTE *)&doo + 68) &= ~0x10u;
      doo.color_mode = v6;
      opt = get_opt_(config_options, "document.dump.numbering");
      *((_BYTE *)&doo + 69) = (16 * ((int)opt->tree & 1)) | *((_BYTE *)&doo + 69) & 0xEF;
      init_vs(&vs, cached->uri, -1);
      render_document(&vs, &doc_view, &doo);
      v8 = dump_output_alloc(fd, 0);
      if ( !v8 )
      {
LABEL_35:
        detach_formatted(&doc_view);
        destroy_vs(&vs, 1);
        basic = download->state.basic;
        goto LABEL_36;
      }
      if ( doo.color_mode != COLOR_MODE_88 )
      {
        if ( doo.color_mode <= COLOR_MODE_88 )
        {
          if ( doo.color_mode != COLOR_MODE_DUMP && doo.color_mode != COLOR_MODE_MONO )
            goto LABEL_16;
          v22 = dump_nocolor(doc_view.document, v8);
LABEL_54:
          if ( v22 )
            goto LABEL_34;
          goto LABEL_55;
        }
        if ( doo.color_mode != COLOR_MODE_256 )
        {
LABEL_16:
          document = doc_view.document;
          if ( is_cp_utf8(doc_view.document->options.cp) )
          {
            v41 = get_opt_(config_options, "document.dump.width")->number;
            if ( document->height > 0 )
            {
              v43 = 0;
              v9 = 0;
              while ( 1 )
              {
                write_color_16(v9, v8);
                v10 = &document->data[v43];
                if ( v10->length > 0 )
                {
                  v11 = v9;
                  out = 0;
                  while ( 1 )
                  {
                    v12 = (int)&v10->chars[(_DWORD)out];
                    v13 = *(_DWORD *)v12;
                    v14 = *(_BYTE *)(v12 + 4);
                    v9 = *(unsigned __int8 *)(v12 + 5);
                    if ( *(_DWORD *)v12 == -3 )
                    {
                      v9 = v11;
                    }
                    else
                    {
                      if ( (_BYTE)v9 != (_BYTE)v11 )
                      {
                        v40 = *(_BYTE *)(v12 + 4);
                        v36 = write_color_16(v9, v8);
                        v14 = v40;
                        if ( v36 )
                          goto LABEL_34;
                      }
                      if ( v14 < 0 && v13 > 0xAF && v13 <= 0xDF )
                        v13 = (unsigned __int8)byte_810DDD0[v13];
                      if ( v13 - 32 > 0x5E && v13 <= 0x9F )
                        v13 = 32;
                      for ( i = encode_utf8(v13); *i; ++i )
                      {
                        if ( write_char(*i, v8) )
                          goto LABEL_34;
                      }
                    }
                    out = (dump_output *)((char *)out + 1);
                    v10 = &document->data[v43];
                    if ( (int)out >= v10->length )
                      goto LABEL_95;
                    v11 = v9;
                  }
                }
                out = 0;
LABEL_95:
                if ( v41 > (int)out )
                  break;
LABEL_100:
                if ( write_char(0xAu, v8) )
                  goto LABEL_34;
                if ( ++v43 >= document->height )
                  goto LABEL_90;
              }
              v37 = out;
              while ( !write_char(0x20u, v8) )
              {
                v37 = (dump_output *)((char *)v37 + 1);
                if ( v41 <= (int)v37 )
                  goto LABEL_100;
              }
              goto LABEL_34;
            }
          }
          else
          {
            v42 = get_opt_(config_options, "document.dump.width")->number;
            if ( document->height > 0 )
            {
              v44 = 0;
              v24 = 0;
              outb = v8;
              while ( 1 )
              {
                write_color_16(v24, outb);
                v25 = &document->data[v44];
                if ( v25->length > 0 )
                {
                  v26 = v24;
                  v27 = 0;
                  while ( 1 )
                  {
                    v29 = (int)&v25->chars[v27];
                    v24 = *(_BYTE *)(v29 + 5);
                    v30 = *(_BYTE *)(v29 + 4);
                    v31 = *(_DWORD *)v29;
                    if ( v24 != v26 )
                    {
                      v39 = *(_BYTE *)(v29 + 4);
                      v32 = write_color_16(v24, outb);
                      v30 = v39;
                      if ( v32 )
                        break;
                    }
                    v28 = v31;
                    if ( (unsigned __int8)v31 > 0xAFu && v30 < 0 && (unsigned __int8)v31 <= 0xDFu )
                      v28 = byte_810DDD0[(unsigned __int8)v31];
                    if ( v28 == 127 || v28 <= 0x1Fu )
                      v28 = 32;
                    if ( write_char(v28, outb) )
                      break;
                    ++v27;
                    v25 = &document->data[v44];
                    if ( v27 >= v25->length )
                      goto LABEL_82;
                    v26 = v24;
                  }
LABEL_79:
                  v8 = outb;
                  goto LABEL_34;
                }
                v27 = 0;
LABEL_82:
                if ( v42 > v27 )
                  break;
LABEL_87:
                if ( write_char(0xAu, outb) )
                  goto LABEL_79;
                if ( ++v44 >= document->height )
                {
                  v8 = outb;
                  goto LABEL_90;
                }
              }
              while ( !write_char(0x20u, outb) )
              {
                if ( v42 <= ++v27 )
                  goto LABEL_87;
              }
              v8 = outb;
              goto LABEL_34;
            }
          }
LABEL_90:
          if ( dump_output_flush(v8) )
          {
LABEL_34:
            mem_free(v8);
            goto LABEL_35;
          }
LABEL_55:
          dump_references(doc_view.document, fd, v8->buf);
          goto LABEL_34;
        }
      }
      v22 = dump_256color(doc_view.document, v8);
      goto LABEL_54;
    }
  }
}

//----- (080EF350) --------------------------------------------------------
void __usercall draw_frame_lines(
        terminal *term@<eax>,
        frameset_desc *frameset_desc@<edx>,
        int xp@<ecx>,
        int yp,
        color_pair *colors)
{
  int width; // edx
  int v7; // eax
  int v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // edx
  int v12; // edx
  int v13; // eax
  int v14; // ebx
  int v15; // eax
  int v16; // edx
  int v17; // edx
  frameset_desc *v18; // edx
  int v19; // eax
  int v20; // edx
  int v21; // eax
  int v22; // esi
  int v23; // ebx
  frameset_desc **v24; // edi
  int v25; // [esp+24h] [ebp-54h]
  int v26; // [esp+24h] [ebp-54h]
  int v27; // [esp+28h] [ebp-50h]
  int v28; // [esp+30h] [ebp-48h]
  int height_0; // [esp+34h] [ebp-44h]
  int height; // [esp+38h] [ebp-40h]
  int heighta; // [esp+38h] [ebp-40h]
  int y; // [esp+40h] [ebp-38h]
  int j; // [esp+44h] [ebp-34h]
  int ja; // [esp+44h] [ebp-34h]
  frameset_desc *v36; // [esp+48h] [ebp-30h]
  int v37; // [esp+48h] [ebp-30h]
  frameset_desc *v38; // [esp+4Ch] [ebp-2Ch]
  int v39; // [esp+4Ch] [ebp-2Ch]
  box box; // [esp+50h] [ebp-28h] BYREF

  if ( assert_failed )
    goto LABEL_4;
  if ( frameset_desc && term )
  {
    assert_failed = 0;
    goto LABEL_8;
  }
  v25 = xp;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
  errline = 97;
  elinks_internal("assertion term && frameset_desc && frameset_desc->frame_desc failed!");
  xp = v25;
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return;
  }
LABEL_8:
  if ( frameset_desc->box.height <= 0 )
    return;
  v27 = xp - 1;
  v28 = yp - 1;
  width = frameset_desc->box.width;
  y = yp - 1;
  j = 0;
  v36 = frameset_desc;
  while ( 1 )
  {
    v7 = v36->frame_desc[width * j].height;
    height = v7;
    if ( width > 0 )
      break;
    ++j;
    y += v7 + 1;
    v18 = v36;
    v19 = v36->box.height;
    if ( v19 <= j )
      goto LABEL_42;
LABEL_38:
    width = v18->box.width;
  }
  v8 = 0;
  v9 = v27;
  v38 = v36;
  while ( 1 )
  {
    v14 = v38->frame_desc[0].width;
    if ( v8 )
    {
      v10 = 0;
      v11 = 0;
      if ( v9 >= 0 )
        v11 = v9;
      box.x = v11;
      box.width = 1;
      v12 = y + 1;
      if ( y + 1 < 0 )
        v12 = 0;
      if ( height >= 0 )
        v10 = height;
      box.y = v12;
      box.height = v10;
      draw_box(term, &box, 0xB3u, SCREEN_ATTR_FRAME, colors);
      if ( v36->box.height - 1 == j )
        draw_border_cross(term, v9, y + height + 1, BORDER_X_UP, colors);
      if ( !j )
      {
        draw_border_cross(term, v9, y, BORDER_X_DOWN, colors);
        v13 = v9 + v14 + 1;
        goto LABEL_22;
      }
    }
    else
    {
      v13 = v9 + v14 + 1;
      if ( !j )
        goto LABEL_22;
      if ( v9 >= 0 )
        draw_border_cross(term, v9, y, BORDER_X_RIGHT, colors);
    }
    v15 = 0;
    v16 = v9 + 1;
    if ( v9 + 1 < 0 )
      v16 = 0;
    box.x = v16;
    v17 = y;
    box.height = 1;
    if ( y < 0 )
      v17 = 0;
    box.y = v17;
    if ( v14 >= 0 )
      v15 = v14;
    box.width = v15;
    draw_box(term, &box, 0xC4u, SCREEN_ATTR_FRAME, colors);
    v13 = v9 + v14 + 1;
    if ( v36->box.width - 1 == v8 && v13 < term->width )
    {
      draw_border_cross(term, v9 + v14 + 1, y, BORDER_X_LEFT, colors);
      v13 = v9 + v14 + 1;
    }
    if ( v8 )
      break;
LABEL_22:
    ++v8;
    v38 = (frameset_desc *)((char *)v38 + 20);
    if ( v36->box.width <= v8 )
      goto LABEL_37;
LABEL_23:
    v9 = v13;
  }
  ++v8;
  v26 = v13;
  draw_border_char(term, v9, y, BORDER_SCROSS, colors);
  v38 = (frameset_desc *)((char *)v38 + 20);
  v13 = v26;
  if ( v36->box.width > v8 )
    goto LABEL_23;
LABEL_37:
  v18 = v36;
  ++j;
  y += height + 1;
  v19 = v36->box.height;
  if ( v19 > j )
    goto LABEL_38;
LABEL_42:
  if ( v19 > 0 )
  {
    v20 = v36->box.width;
    heighta = 0;
    for ( ja = (int)v36; ; v20 = *(_DWORD *)(ja + 12) )
    {
      v21 = 20 * v20 * heighta;
      height_0 = *(_DWORD *)(ja + v21 + 36);
      if ( v20 > 0 )
      {
        v22 = ja;
        v23 = v27;
        v39 = 0;
        v24 = (frameset_desc **)(ja + v21 + 20);
        while ( 1 )
        {
          v37 = *(_DWORD *)(v22 + 32);
          if ( *v24 )
            draw_frame_lines(term, *v24, v23 + 1, v28 + 1, colors);
          v22 += 20;
          v24 += 5;
          if ( *(_DWORD *)(ja + 12) <= ++v39 )
            break;
          v23 += v37 + 1;
        }
      }
      if ( *(_DWORD *)(ja + 16) <= ++heighta )
        break;
      v28 += height_0 + 1;
    }
  }
}
// 80EF59C: conditional instruction was optimized away because %j.4!=0

//----- (080EF750) --------------------------------------------------------
void __usercall draw_view_status(session *ses@<eax>, document_view *doc_view@<edx>, int active@<ecx>)
{
  terminal *term; // edi

  term = ses->tab->term;
  draw_forms(term, doc_view);
  if ( active )
  {
    draw_searched(term, doc_view);
    draw_current_link(ses, doc_view);
  }
}

//----- (080EF7B0) --------------------------------------------------------
void __usercall draw_doc(session *ses@<eax>, document_view *doc_view@<edx>, int active@<ecx>)
{
  window *tab; // eax
  int width; // eax
  window *v6; // edx
  int height; // ecx
  document *document; // eax
  int bgcolor; // eax
  view_state *vs; // esi
  document *v11; // eax
  unsigned __int8 *source; // edx
  int tag; // eax
  int v14; // edx
  int v15; // edx
  int last_x; // eax
  int y; // ecx
  int v18; // edx
  int v19; // eax
  uri *v20; // esi
  document *v21; // edx
  char *v22; // eax
  int v23; // edi
  int v24; // eax
  line *v25; // ecx
  int length; // eax
  int v27; // eax
  char *v28; // eax
  unsigned __int8 **search_word; // eax
  unsigned __int8 *v30; // eax
  link *link_at_coordinates; // edx
  int current_link; // ecx
  document *v33; // eax
  bool v34; // zf
  unsigned __int8 **v35; // eax
  unsigned __int8 *v36; // eax
  cache_entry *cached; // ecx
  int v38; // edx
  option_value *opt; // eax
  unsigned __int8 *v40; // eax
  int v41; // [esp+24h] [ebp-54h]
  int v42; // [esp+24h] [ebp-54h]
  int v43; // [esp+24h] [ebp-54h]
  color_pair *colors; // [esp+28h] [ebp-50h]
  int v45; // [esp+2Ch] [ebp-4Ch]
  int v46; // [esp+30h] [ebp-48h]
  int v48; // [esp+38h] [ebp-40h]
  int vx; // [esp+3Ch] [ebp-3Ch]
  terminal *term; // [esp+40h] [ebp-38h]
  const uri *uri; // [esp+44h] [ebp-34h]
  uri *uria; // [esp+44h] [ebp-34h]
  uri *urib; // [esp+44h] [ebp-34h]
  document *en; // [esp+4Ch] [ebp-2Ch]
  view_state *ena; // [esp+4Ch] [ebp-2Ch]
  string string; // [esp+50h] [ebp-28h] BYREF
  color_pair color; // [esp+58h] [ebp-20h] BYREF

  if ( assert_failed )
    goto LABEL_19;
  if ( ses )
  {
    tab = ses->tab;
    if ( tab )
    {
      if ( doc_view && tab->term )
      {
        assert_failed = 0;
        goto LABEL_7;
      }
    }
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
  errline = 208;
  elinks_internal("assertion ses && ses->tab && ses->tab->term && doc_view failed!");
  if ( assert_failed )
  {
LABEL_19:
    assert_failed = 0;
    return;
  }
LABEL_7:
  width = doc_view->box.width;
  v6 = ses->tab;
  term = v6->term;
  if ( width <= 1 )
    return;
  height = doc_view->box.height;
  if ( height <= 1 )
    return;
  if ( active )
  {
    if ( ses->navigate_mode == NAVIGATE_CURSOR_ROUTING )
    {
      set_cursor(term, v6->x, v6->y, 0);
    }
    else
    {
      set_cursor(term, doc_view->box.x + width - 1, doc_view->box.y + height - 1, 1);
      ses->tab->x = doc_view->box.x;
      ses->tab->y = doc_view->box.y;
    }
  }
  color.foreground = get_opt_(config_options, "document.colors.text")->color;
  document = doc_view->document;
  if ( document->height )
    bgcolor = document->bgcolor;
  else
    bgcolor = get_opt_(config_options, "document.colors.background")->number;
  vs = doc_view->vs;
  color.background = bgcolor;
  if ( !vs )
  {
    draw_box(term, &doc_view->box, 0x20u, (screen_char_attr)0, &color);
    return;
  }
  v11 = doc_view->document;
  if ( v11 && v11->frame_desc )
  {
    draw_box(term, &doc_view->box, 0x20u, (screen_char_attr)0, &color);
    draw_frame_lines(term, doc_view->document->frame_desc, doc_view->box.x, doc_view->box.y, &color);
    if ( vs->current_link == -1 )
      vs->current_link = 0;
    return;
  }
  if ( ses->navigate_mode )
  {
    link_at_coordinates = get_link_at_coordinates(
                            doc_view,
                            ses->tab->x - doc_view->box.x,
                            ses->tab->y - doc_view->box.y);
    if ( link_at_coordinates )
    {
      ena = doc_view->vs;
      current_link = ena->current_link;
      if ( current_link < 0 )
      {
        urib = (uri *)doc_view->document->links;
      }
      else
      {
        v33 = doc_view->document;
        if ( current_link < v33->nlinks )
        {
          urib = (uri *)v33->links;
          if ( link_at_coordinates == (link *)((char *)urib + 52 * current_link) )
            goto LABEL_23;
        }
        else
        {
          urib = (uri *)v33->links;
        }
      }
      ena->current_link = -991146299 * (((char *)link_at_coordinates - (char *)urib) >> 2);
    }
  }
  else
  {
    check_vs(doc_view);
  }
LABEL_23:
  if ( (*((_BYTE *)vs + 44) & 2) != 0 )
    goto LABEL_38;
  en = doc_view->document;
  uri = doc_view->vs->uri;
  if ( !assert_failed )
  {
    assert_failed = *((_WORD *)doc_view->vs->uri + 26) == 0;
    if ( assert_failed )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 53;
      elinks_internal("assertion uri->fragmentlen failed!");
    }
  }
  if ( !init_string(&string) )
    goto LABEL_38;
  if ( !add_uri_to_string(&string, uri, URI_FRAGMENT) )
    goto LABEL_92;
  decode_uri_string(&string);
  if ( !assert_failed )
  {
    assert_failed = string.length == 0;
    if ( string.length
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c",
          errline = 61,
          elinks_internal("assertion fragment.length failed!"),
          !assert_failed) )
    {
      source = string.source;
      v34 = *string.source != 0;
      assert_failed = *string.source == 0;
      if ( v34 )
        goto LABEL_31;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 62;
      elinks_internal("assertion *fragment.source failed!");
    }
  }
  source = string.source;
LABEL_31:
  tag = find_tag(en, source + 1, string.length - 1);
  v14 = tag;
  if ( tag != -1 )
  {
    if ( tag >= 0 )
    {
      if ( tag > en->height - 1 )
        v14 = en->height - 1;
      v41 = v14;
      done_string(&string);
      v15 = v41;
      if ( v41 == -2 )
        goto LABEL_38;
      goto LABEL_36;
    }
    v38 = 0;
LABEL_94:
    v42 = v38;
    done_string(&string);
    v15 = v42;
LABEL_36:
    *((_BYTE *)vs + 44) |= 2u;
    if ( v15 >= 0 )
    {
      doc_view->vs->y = v15;
      set_link(doc_view);
    }
    goto LABEL_38;
  }
  cached = en->cached;
  if ( !assert_failed )
  {
    assert_failed = cached == 0;
    if ( !cached )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
      errline = 69;
      elinks_internal("assertion cached failed!");
      cached = 0;
      v14 = -1;
    }
  }
  if ( (*((_BYTE *)cached + 92) & 8) == 0 && cached->cache_id == en->cache_id )
  {
    v43 = v14;
    opt = get_opt_(config_options, "document.browse.links.missing_fragment");
    v38 = v43;
    if ( opt->number )
    {
      v40 = msg_text(ses->tab->term, "The requested fragment \"%s\" doesn't exist.", (const char *)string.source);
      info_box(ses->tab->term, MSGBOX_FREE_TEXT, "Missing fragment", ALIGN_CENTER, v40);
      v38 = v43;
    }
    goto LABEL_94;
  }
LABEL_92:
  done_string(&string);
LABEL_38:
  last_x = doc_view->last_x;
  vx = vs->x;
  y = vs->y;
  if ( last_x == -1
    || vs->x != last_x
    || doc_view->last_y != y
    || (v35 = doc_view->search_word) != 0 && (v36 = *v35) != 0 && *v36 )
  {
    doc_view->last_y = y;
    colors = (color_pair *)y;
    doc_view->last_x = vx;
    draw_box(term, &doc_view->box, 0x20u, (screen_char_attr)0, &color);
    v18 = doc_view->document->height;
    if ( v18 )
    {
      v19 = vs->y;
      if ( v18 <= v19 )
      {
        do
        {
          v19 -= doc_view->box.height;
          vs->y = v19;
        }
        while ( doc_view->document->height <= v19 );
      }
      if ( v19 < 0 )
      {
        vs->y = 0;
        v20 = 0;
        uria = 0;
      }
      else
      {
        uria = (uri *)vs->y;
        v20 = 0;
        if ( (int)uria >= 0 )
          v20 = uria;
      }
      if ( colors != (color_pair *)uria && ses->navigate_mode == NAVIGATE_LINKWISE )
        check_vs(doc_view);
      v21 = doc_view->document;
      v22 = (char *)uria + doc_view->box.height;
      if ( (int)v22 > v21->height )
        v22 = (char *)v21->height;
      if ( (int)v22 > (int)v20 )
      {
        v23 = (int)v20;
        v24 = 0;
        if ( vx >= 0 )
          v24 = vx;
        v48 = v24;
        v46 = v24;
        v45 = v24 - vx;
        do
        {
          v25 = &v21->data[v23];
          length = v25->length;
          if ( doc_view->box.width + vx <= length )
            length = doc_view->box.width + vx;
          v27 = length - v48;
          if ( v27 > 0 )
          {
            draw_line(term, doc_view->box.x + v45, doc_view->box.y + (char *)v20 - (char *)uria, v27, &v25->chars[v46]);
            v21 = doc_view->document;
          }
          v28 = (char *)v21->height;
          v20 = (uri *)((char *)v20 + 1);
          ++v23;
          if ( (int)uria + doc_view->box.height <= (int)v28 )
            v28 = (char *)uria + doc_view->box.height;
        }
        while ( (int)v20 < (int)v28 );
      }
      draw_view_status(ses, doc_view, active);
      search_word = doc_view->search_word;
      if ( search_word )
      {
        v30 = *search_word;
        if ( v30 )
        {
          if ( *v30 )
          {
            doc_view->last_y = -1;
            doc_view->last_x = -1;
          }
        }
      }
    }
  }
  else
  {
    clear_link(term, doc_view);
    draw_view_status(ses, doc_view, active);
  }
}

//----- (080EFF80) --------------------------------------------------------
void __cdecl refresh_view(session *ses, document_view *doc_view, int frames)
{
  document_view *v3; // eax
  document *document; // eax
  int v5; // ebx
  int v6; // eax
  session *v7; // ecx
  location *current; // ecx
  int current_link; // edx
  int i; // edi
  document_view *v11; // ebx
  int v12; // esi
  bool v13; // cc
  window *tab; // [esp+10h] [ebp-28h]
  document_view *v15; // [esp+14h] [ebp-24h]
  session *next; // [esp+1Ch] [ebp-1Ch]

  tab = ses->tab;
  if ( tab != get_tab_by_number(tab->term, tab->term->current_tab) )
    goto LABEL_2;
  draw_doc(ses, doc_view, 1);
  if ( !frames )
    goto LABEL_2;
  if ( assert_failed )
    goto LABEL_30;
  v3 = ses->doc_view;
  if ( !v3 || !v3->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
    errline = 309;
    elinks_internal("assertion ses && ses->doc_view && ses->doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_9;
LABEL_30:
    assert_failed = 0;
LABEL_2:
    print_screen_status(ses);
    return;
  }
  assert_failed = 0;
LABEL_9:
  document = ses->doc_view->document;
  if ( !document || !document->frame_desc )
    goto LABEL_2;
  v5 = 1;
  next = (session *)ses->scrn_frames.next;
  v6 = 0;
  if ( next != (session *)&ses->scrn_frames )
  {
    v7 = (session *)ses->scrn_frames.next;
    do
    {
      v7->loading.callback = (download_callback_T *)-1;
      ++v6;
      v7->loading.cached = (cache_entry *)-1;
      v7 = v7->next;
    }
    while ( v7 != (session *)&ses->scrn_frames );
    v5 = 1;
    next = v7;
    if ( v6 > 0 )
      v5 = v6;
  }
  current = ses->history.current;
  current_link = 0;
  if ( current->vs.current_link >= 0 )
    current_link = current->vs.current_link;
  current->vs.current_link = current_link % v5;
  v15 = current_frame(ses);
  for ( i = 0; ; ++i )
  {
    v11 = (document_view *)ses->scrn_frames.next;
    if ( v11 == (document_view *)next )
      break;
    v12 = 0;
    do
    {
      while ( 1 )
      {
        v13 = v11->depth <= i;
        if ( v11->depth != i )
          break;
        draw_doc(ses, v11, v15 == v11);
        v11 = v11->next;
        if ( v11 == (document_view *)next )
          goto LABEL_26;
      }
      v11 = v11->next;
      if ( !v13 )
        v12 = 1;
    }
    while ( v11 != (document_view *)next );
LABEL_26:
    if ( !v12 )
      break;
  }
  print_screen_status(ses);
}

//----- (080F0120) --------------------------------------------------------
void __cdecl draw_formatted(session *ses, int rerender)
{
  int v2; // esi
  window *tab; // esi
  document_view *doc_view; // eax
  window *v5; // eax
  terminal *term; // edx
  int width; // ebx
  int height; // ecx
  int v9; // edx
  int v10; // ecx
  location *current; // edx
  box box; // [esp+20h] [ebp-18h] BYREF

  if ( assert_failed )
    goto LABEL_14;
  if ( !ses || !ses->tab )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/draw.c";
    errline = 343;
    elinks_internal("assertion ses && ses->tab failed!");
    if ( !assert_failed )
      goto LABEL_5;
LABEL_14:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_5:
  if ( rerender )
  {
    v2 = rerender - 1;
    if ( ((rerender - 1) & 2) == 0 && session_is_loading(ses) )
      v2 |= 2u;
    render_document_frames(ses, v2);
    start_document_refreshes(ses);
  }
  tab = ses->tab;
  if ( tab == get_tab_by_number(tab->term, tab->term->current_tab) )
  {
    doc_view = ses->doc_view;
    if ( doc_view && doc_view->document )
    {
      if ( !doc_view->vs )
      {
        current = ses->history.current;
        if ( current )
        {
          doc_view->vs = &current->vs;
          doc_view = ses->doc_view;
        }
      }
      doc_view->last_y = -1;
      doc_view->last_x = -1;
      refresh_view(ses, ses->doc_view, 1);
    }
    else
    {
      v5 = ses->tab;
      term = v5->term;
      width = term->width;
      height = term->height;
      v9 = 0;
      box.x = 0;
      box.y = 1;
      if ( width < 0 )
        width = 0;
      v10 = height - 2;
      if ( v10 >= 0 )
        v9 = v10;
      box.height = v9;
      box.width = width;
      draw_box(v5->term, &box, 0x20u, (screen_char_attr)0, 0);
    }
  }
}

//----- (080F02E0) --------------------------------------------------------
form_control *__cdecl find_form_control(document *document, form_state *fs_0)
{
  list_head_elinks *next; // edx
  int form_num; // ebx
  form_control *result; // eax
  form_control *p_prev; // edx

  next = (list_head_elinks *)document->forms.next;
  if ( next == &document->forms )
  {
LABEL_6:
    next = 0;
    goto LABEL_7;
  }
  form_num = fs_0->form_view->form_num;
  while ( next[1].next != (void *)form_num )
  {
    next = (list_head_elinks *)next->next;
    if ( next == &document->forms )
      goto LABEL_6;
  }
LABEL_7:
  result = (form_control *)next[4].prev;
  p_prev = (form_control *)&next[4].prev;
  if ( result == p_prev )
    return 0;
  while ( result->g_ctrl_num != fs_0->g_ctrl_num || fs_0->position != result->position || fs_0->type != result->type )
  {
    result = result->next;
    if ( result == p_prev )
      return 0;
  }
  return result;
}

//----- (080F0350) --------------------------------------------------------
form *__cdecl find_form_by_form_view(document *document, form_view *fv)
{
  form *result; // eax
  int form_num; // ecx

  result = (form *)document->forms.next;
  if ( result == (form *)&document->forms )
    return 0;
  form_num = fv->form_num;
  if ( result->form_num != form_num )
  {
    while ( 1 )
    {
      result = result->next;
      if ( result == (form *)&document->forms )
        break;
      if ( result->form_num == form_num )
        return result;
    }
    return 0;
  }
  return result;
}

//----- (080F0390) --------------------------------------------------------
const char *__usercall get_form_label@<eax>(form_control *fc@<eax>)
{
  form *form; // ecx
  const char *result; // eax
  form *v3; // edx
  form_control *v4; // [esp+1Ch] [ebp-Ch]

  if ( !assert_failed )
  {
    form = fc->form;
    assert_failed = form == 0;
    if ( !form )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 1873;
      v4 = fc;
      elinks_internal("assertion fc->form failed!");
      fc = v4;
      if ( v4->type > (unsigned int)FC_BUTTON )
        return 0;
    }
  }
  switch ( fc->type )
  {
    case FC_TEXT:
      result = "Text field";
      break;
    case FC_PASSWORD:
      result = "Password field";
      break;
    case FC_FILE:
      result = "File upload";
      break;
    case FC_TEXTAREA:
      result = "Text area";
      break;
    case FC_CHECKBOX:
      result = "Checkbox";
      break;
    case FC_RADIO:
      result = "Radio button";
      break;
    case FC_SELECT:
      result = "Select field";
      break;
    case FC_SUBMIT:
    case FC_IMAGE:
      v3 = fc->form;
      if ( !v3->action )
        return 0;
      result = "Submit form to";
      if ( v3->method )
        result = "Post form to";
      break;
    case FC_RESET:
      result = "Reset form";
      break;
    case FC_BUTTON:
      result = "Harmless button";
      break;
    default:
      return 0;
  }
  return result;
}

//----- (080F0470) --------------------------------------------------------
unsigned __int8 *__usercall _7@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (080F04E0) --------------------------------------------------------
void __cdecl done_form_view(form_view *fv)
{
  mem_free(fv);
}

//----- (080F04F0) --------------------------------------------------------
void __cdecl done_form_state(form_state *fs_0)
{
  if ( fs_0->value )
    mem_free(fs_0->value);
}

//----- (080F0520) --------------------------------------------------------
void __cdecl done_submitted_value(submitted_value *sv)
{
  if ( sv )
  {
    if ( sv->value )
      mem_free(sv->value);
    if ( sv->name )
      mem_free(sv->name);
    mem_free(sv);
  }
}

//----- (080F0570) --------------------------------------------------------
void __cdecl done_submitted_value_list(list_head_elinks *list)
{
  submitted_value *next; // eax
  submitted_value **p_next; // ebx

  if ( assert_failed
    || (assert_failed = list == 0, !list)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c",
        errline = 665,
        elinks_internal("assertion list failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    next = (submitted_value *)list->next;
    if ( list->next != list )
    {
      do
      {
        p_next = &next->prev->next;
        next->next->prev = (submitted_value *)p_next;
        next->prev->next = next->next;
        done_submitted_value(next);
        next = *p_next;
      }
      while ( *p_next != (submitted_value *)list );
    }
  }
}

//----- (080F0610) --------------------------------------------------------
void __cdecl link_form_menu_func(terminal *term, void *link_number_, void *ses_)
{
  int v3; // esi
  document_view *v4; // eax
  document_view *v5; // edi

  v3 = *(_DWORD *)link_number_;
  mem_free(link_number_);
  if ( !assert_failed )
  {
    assert_failed = term == 0 || ses_ == 0;
    if ( term != 0 && ses_ != 0
      || (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c",
          errline = 2060,
          elinks_internal("assertion term && ses failed!"),
          !assert_failed) )
    {
      v4 = current_frame((session *)ses_);
      v5 = v4;
      if ( !v4 )
        return;
      if ( !assert_failed )
      {
        if ( v4->vs && v4->document )
        {
          assert_failed = 0;
LABEL_8:
          jump_to_link_number((session *)ses_, v5, v3);
          refresh_view((session *)ses_, v5, 0);
          return;
        }
        assert_failed = 1;
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 2066;
        elinks_internal("assertion doc_view->vs && doc_view->document failed!");
        if ( !assert_failed )
          goto LABEL_8;
      }
    }
  }
  assert_failed = 0;
}

//----- (080F0750) --------------------------------------------------------
frame_event_status __cdecl submit_form(session *ses, document_view *doc_view, int do_reload)
{
  goto_current_link(ses, doc_view, do_reload);
  return 2;
}

//----- (080F0780) --------------------------------------------------------
void __cdecl file_form_menu(terminal *term, void *path_, void *fs_)
{
  auto_complete_file(term, 0, (unsigned __int8 *)path_, set_file_form_state, file_form_menu, fs_);
}

//----- (080F07C0) --------------------------------------------------------
void __cdecl set_file_form_state(terminal *term, void *filename_, void *fs_)
{
  if ( *((_DWORD *)fs_ + 4) )
    mem_free(*((void **)fs_ + 4));
  *((_DWORD *)fs_ + 4) = filename_;
  *((_DWORD *)fs_ + 5) = strlen((const char *)filename_);
  redraw_terminal(term);
}

//----- (080F0810) --------------------------------------------------------
void __usercall fixup_select_state(form_control *fc@<eax>, form_state *fs_0@<edx>)
{
  int state; // eax
  int nvalues; // esi
  unsigned __int8 *value; // edi
  int v5; // ebx
  unsigned __int8 **values; // esi
  unsigned __int8 *v7; // eax
  int v10; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = fc == 0 || fs_0 == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c",
        errline = 101,
        elinks_internal("assertion fc && fs failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  state = fs_0->state;
  if ( state < 0 )
  {
    value = fs_0->value;
    nvalues = fc->nvalues;
  }
  else
  {
    nvalues = fc->nvalues;
    if ( state < nvalues )
    {
      value = fs_0->value;
      if ( !strcmp((const char *)fc->values[state], (const char *)value) )
        return;
    }
    else
    {
      value = fs_0->value;
    }
  }
  if ( nvalues <= 0 )
  {
LABEL_15:
    fs_0->state = 0;
    if ( value )
      mem_free(value);
    v7 = (unsigned __int8 *)&delete;
    if ( fc->nvalues )
      v7 = *fc->values;
    fs_0->value = stracpy(v7);
  }
  else
  {
    v5 = 0;
    v10 = nvalues;
    values = fc->values;
    while ( strcmp((const char *)values[v5], (const char *)value) )
    {
      if ( v10 <= ++v5 )
        goto LABEL_15;
    }
    fs_0->state = v5;
  }
}

//----- (080F0980) --------------------------------------------------------
submitted_value *__cdecl init_submitted_value(
        unsigned __int8 *name,
        unsigned __int8 *value,
        form_type type,
        form_control *fc,
        int position)
{
  submitted_value *v5; // ebx
  unsigned __int8 *v6; // eax
  unsigned __int8 *v7; // eax
  submitted_value *v9; // [esp+0h] [ebp-18h]

  v5 = (submitted_value *)mem_alloc(0x1Cu);
  if ( v5 )
  {
    v6 = stracpy(value);
    v5->value = v6;
    if ( v6 )
    {
      v7 = stracpy(name);
      v5->name = v7;
      if ( v7 )
      {
        v5->type = type;
        v5->form_control = fc;
        v5->position = position;
        return v5;
      }
      mem_free(v5->value);
    }
    v9 = v5;
    v5 = 0;
    mem_free(v9);
  }
  return v5;
}

//----- (080F09F0) --------------------------------------------------------
unsigned __int8 *__cdecl encode_crlf(submitted_value *sv)
{
  string *inited; // edx
  unsigned __int8 *result; // eax
  unsigned __int8 *value; // edx
  unsigned __int8 v4; // al
  int v5; // ecx
  int v6; // ebx
  string newtext; // [esp+18h] [ebp-20h] BYREF

  if ( assert_failed )
    goto LABEL_16;
  if ( sv && sv->value )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
  errline = 804;
  elinks_internal("assertion sv && sv->value failed!");
  if ( assert_failed )
  {
LABEL_16:
    assert_failed = 0;
    return 0;
  }
LABEL_5:
  inited = init_string(&newtext);
  result = 0;
  if ( inited )
  {
    value = sv->value;
    v4 = *value;
    if ( *value )
    {
      v5 = 0;
      v6 = 0;
      do
      {
        while ( v4 == 13 )
        {
          if ( value[v5 + 1] != 10 )
            goto LABEL_13;
LABEL_10:
          v4 = value[++v6];
          v5 = v6;
          if ( !v4 )
            return newtext.source;
        }
        if ( v4 != 10 )
        {
          add_char_to_string(&newtext, v4);
          value = sv->value;
          goto LABEL_10;
        }
LABEL_13:
        ++v6;
        add_crlf_to_string(&newtext);
        value = sv->value;
        v5 = v6;
        v4 = value[v6];
      }
      while ( v4 );
    }
    return newtext.source;
  }
  return result;
}

//----- (080F0B00) --------------------------------------------------------
void *__usercall mem_align_alloc___1@<eax>(
        void **ptr@<eax>,
        size_t old@<edx>,
        size_t a3@<ecx>,
        size_t objsize,
        size_t mask)
{
  size_t v6; // ecx
  size_t v7; // esi
  void *result; // eax
  char *v9; // edx
  size_t v10; // [esp+1Ch] [ebp-1Ch]

  v6 = ~mask & (mask + a3);
  v7 = ~mask & (old + mask);
  if ( v6 <= v7 )
    return *ptr;
  v10 = objsize * v6;
  v9 = (char *)mem_realloc(*ptr, objsize * v6);
  result = 0;
  if ( v9 )
  {
    *ptr = v9;
    memset(&v9[objsize * v7], 0, v10 - objsize * v7);
    return *ptr;
  }
  return result;
}

//----- (080F0B80) --------------------------------------------------------
string *__usercall add_bytes_to_string___7@<eax>(
        string *string@<eax>,
        const unsigned __int8 *bytes@<edx>,
        int length@<ecx>)
{
  string *v3; // ebx
  size_t v7; // edx
  int newlength; // [esp+1Ch] [ebp-1Ch]

  v3 = string;
  if ( assert_failed )
    goto LABEL_2;
  if ( bytes && string && length >= 0 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
    errline = 255;
    elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  if ( length )
  {
    v7 = v3->length;
    newlength = length + v7;
    if ( mem_align_alloc___1((void **)&v3->source, v7, length + v7 + 1, 1u, 0xFFu) )
    {
      memcpy(&v3->source[v3->length], bytes, length);
      v3->source[newlength] = 0;
      v3->length = newlength;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

//----- (080F0C80) --------------------------------------------------------
void __usercall init_form_state(document_view *doc_view@<eax>, form_control *fc@<edx>, form_state *fs_0@<ecx>)
{
  int cp; // edi
  conv_table *v6; // eax
  unsigned __int8 *v7; // eax
  unsigned __int8 *form_history_value; // edx
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // eax
  conv_table *translation_table; // eax
  document_view *chars; // [esp+24h] [ebp-24h]
  unsigned __int8 *charsa; // [esp+24h] [ebp-24h]
  unsigned __int8 *charsb; // [esp+24h] [ebp-24h]
  size_t charslen; // [esp+28h] [ebp-20h]
  size_t charslena; // [esp+28h] [ebp-20h]
  int viewer_cp; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = fc == 0 || fs_0 == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c",
        errline = 163,
        chars = doc_view,
        elinks_internal("assertion fc && fs failed!"),
        doc_view = chars,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    cp = doc_view->document->cp;
    viewer_cp = get_terminal_codepage(doc_view->session->tab->term);
    if ( fs_0->value )
      mem_free(fs_0->value);
    fs_0->value = 0;
    switch ( fc->type )
    {
      case FC_TEXT:
      case FC_PASSWORD:
        form_history_value = get_form_history_value(fc->form->action, fc->name);
        v9 = 0;
        if ( form_history_value )
        {
          v10 = get_form_history_value(fc->form->action, fc->name);
          v9 = stracpy(v10);
        }
        fs_0->value = v9;
        if ( !v9 )
          goto LABEL_20;
        goto LABEL_17;
      case FC_FILE:
        v7 = stracpy((const unsigned __int8 *)&delete);
        fs_0->state = 0;
        fs_0->value = v7;
        goto LABEL_13;
      case FC_TEXTAREA:
LABEL_20:
        charsb = fc->default_value;
        charslena = strlen((const char *)charsb);
        translation_table = get_translation_table(cp, viewer_cp);
        v9 = convert_string_elinks(translation_table, charsb, charslena, viewer_cp, CSM_FORM, &fs_0->state, 0, 0);
        fs_0->value = v9;
        if ( v9 )
LABEL_17:
          v9 = (unsigned __int8 *)strlen((const char *)v9);
        fs_0->state = (int)v9;
        if ( fc->type == FC_TEXTAREA )
          fs_0->state_cell = 0;
LABEL_13:
        fs_0->vpos = 0;
        return;
      case FC_CHECKBOX:
      case FC_RADIO:
        fs_0->state = fc->default_state;
        goto LABEL_10;
      case FC_SELECT:
        charsa = fc->default_value;
        charslen = strlen((const char *)charsa);
        v6 = get_translation_table(cp, viewer_cp);
        fs_0->value = convert_string_elinks(v6, charsa, charslen, viewer_cp, CSM_FORM, &fs_0->state, 0, 0);
        fs_0->state = fc->default_state;
        fixup_select_state(fc, fs_0);
        return;
      case FC_SUBMIT:
      case FC_IMAGE:
      case FC_RESET:
      case FC_BUTTON:
      case FC_HIDDEN:
LABEL_10:
        fs_0->value = stracpy(fc->default_value);
        break;
      default:
        return;
    }
  }
}

//----- (080F0EE0) --------------------------------------------------------
form_view *__cdecl find_form_view_in_vs(view_state *vs, int form_num)
{
  form_view *result; // eax
  list_head_elinks *p_forms; // ebx
  form_view *next; // edx

  if ( !assert_failed )
  {
    assert_failed = vs == 0;
    if ( !vs )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 308;
      elinks_internal("assertion vs failed!");
    }
  }
  result = (form_view *)vs->forms.next;
  p_forms = &vs->forms;
  if ( &vs->forms == (list_head_elinks *)result )
  {
LABEL_9:
    result = (form_view *)mem_calloc(1u, 0xCu);
    result->form_num = form_num;
    next = (form_view *)vs->forms.next;
    result->prev = (form_view *)p_forms;
    result->next = next;
    vs->forms.next = result;
    result->next->prev = result;
  }
  else
  {
    while ( result->form_num != form_num )
    {
      result = result->next;
      if ( p_forms == (list_head_elinks *)result )
        goto LABEL_9;
    }
  }
  return result;
}

//----- (080F0F90) --------------------------------------------------------
form_view *__cdecl find_form_view(document_view *doc_view, form *form)
{
  return find_form_view_in_vs(doc_view->vs, form->form_num);
}

//----- (080F0FB0) --------------------------------------------------------
form_state *__cdecl find_form_state(document_view *doc_view, form_control *fc)
{
  form_state *form_info; // ebx
  int g_ctrl_num; // edi
  signed int form_info_len; // edx
  form_state *v6; // eax
  view_state *vs; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_2;
  if ( doc_view && fc && doc_view->vs )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 235;
    elinks_internal("assertion doc_view && doc_view->vs && fc failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  vs = doc_view->vs;
  g_ctrl_num = fc->g_ctrl_num;
  form_info_len = vs->form_info_len;
  if ( g_ctrl_num >= form_info_len )
  {
    v6 = (form_state *)mem_align_alloc___1((void **)&vs->form_info, form_info_len, g_ctrl_num + 1, 0x24u, 0);
    form_info = v6;
    if ( !v6 )
      return form_info;
    vs->form_info = v6;
    vs->form_info_len = g_ctrl_num + 1;
  }
  else
  {
    form_info = vs->form_info;
  }
  form_info += g_ctrl_num;
  if ( form_info->form_view
    && form_info->form_view->form_num == fc->form->form_num
    && form_info->g_ctrl_num == fc->g_ctrl_num
    && form_info->position == fc->position
    && form_info->type == fc->type )
  {
    return form_info;
  }
  if ( form_info->value )
    mem_free(form_info->value);
  memset(form_info, 0, sizeof(form_state));
  form_info->form_view = find_form_view_in_vs(doc_view->vs, fc->form->form_num);
  form_info->g_ctrl_num = fc->g_ctrl_num;
  form_info->position = fc->position;
  form_info->type = fc->type;
  init_form_state(doc_view, fc, form_info);
  return form_info;
}

//----- (080F1140) --------------------------------------------------------
frame_event_status __cdecl field_op(session *ses, document_view *doc_view, link *link, term_event *ev)
{
  term_event *v4; // ecx
  bool v5; // dl
  unsigned __int8 *name; // ebx
  frame_event_status result; // eax
  form_state *form_state; // eax
  int v9; // edx
  signed int v10; // eax
  const unsigned __int16 **v11; // eax
  int m; // ecx
  int v13; // edx
  unsigned __int8 v14; // bl
  unsigned __int8 *v15; // ecx
  unsigned __int8 v16; // bl
  unsigned __int8 *v17; // ecx
  int v18; // esi
  int v19; // ebx
  const unsigned __int16 **v20; // eax
  int j; // ebx
  const unsigned __int16 *v22; // ecx
  int v23; // edx
  int k; // edx
  signed int v25; // eax
  int v26; // ebx
  unsigned __int8 *v27; // ebx
  char *v28; // esi
  char *v29; // ebx
  char v30; // si
  char *v31; // eax
  char *v32; // edx
  int v33; // edi
  int v34; // eax
  char *v35; // esi
  const char *v36; // edi
  size_t v37; // eax
  int v38; // eax
  const char *v39; // edi
  const unsigned __int16 *v40; // esi
  char *i; // eax
  unsigned __int8 v42; // dl
  unsigned __int16 v43; // cx
  char *v44; // ebx
  size_t v45; // eax
  int state; // esi
  unsigned __int8 *v47; // edx
  int v48; // eax
  const char *clipboard_text; // eax
  char *v50; // esi
  signed int v51; // eax
  const unsigned __int8 *v52; // eax
  int terminal_codepage; // eax
  int v54; // esi
  size_t v55; // edi
  unsigned __int8 *v56; // eax
  term_event *v57; // [esp+28h] [ebp-40h]
  term_event *v58; // [esp+28h] [ebp-40h]
  bool v59; // [esp+2Ch] [ebp-3Ch]
  bool v60; // [esp+2Ch] [ebp-3Ch]
  bool v61; // [esp+2Ch] [ebp-3Ch]
  char *v62; // [esp+30h] [ebp-38h]
  char *s; // [esp+34h] [ebp-34h]
  form_state *fs_; // [esp+38h] [ebp-30h]
  unsigned __int8 *seq; // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 *seqa; // [esp+3Ch] [ebp-2Ch]
  unsigned __int8 *string[4]; // [esp+4Ch] [ebp-1Ch] BYREF

  v4 = ev;
  v5 = (*((_BYTE *)ses->tab->term + 56) & 2) != 0;
  if ( assert_failed )
    goto LABEL_11;
  if ( doc_view && ev && link )
  {
    assert_failed = 0;
  }
  else
  {
    v59 = (*((_BYTE *)ses->tab->term + 56) & 2) != 0;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 1463;
    elinks_internal("assertion ses && doc_view && link && ev failed!");
    v5 = v59;
    v4 = ev;
    if ( assert_failed )
      goto LABEL_11;
  }
  if ( link->type <= (unsigned int)LINK_MAP )
  {
    assert_failed = 1;
    name = 0;
LABEL_10:
    v60 = v5;
    v57 = v4;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 1467;
    elinks_internal("assertion fc != NULL failed: link has no form control");
    v4 = v57;
    v5 = v60;
    if ( !assert_failed )
      goto LABEL_6;
LABEL_11:
    assert_failed = 0;
    return 2;
  }
  name = link->data.name;
  assert_failed = name == 0;
  if ( !name )
    goto LABEL_10;
LABEL_6:
  if ( *((_DWORD *)name + 6) == 2 || v4->ev != EVENT_KBD || ses->insert_mode == INSERT_MODE_OFF )
    return 0;
  v61 = v5;
  v58 = v4;
  v62 = (char *)kbd_action(KEYMAP_EDIT, v4, 0);
  form_state = find_form_state(doc_view, (form_control *)name);
  fs_ = form_state;
  if ( !form_state )
    return 2;
  s = (char *)form_state->value;
  if ( !s )
    return 2;
  v9 = v61;
  switch ( (unsigned int)v62 )
  {
    case 2u:
      if ( *((_DWORD *)name + 5) != 2 || *((_DWORD *)name + 6) )
        return 0;
      file_form_menu(ses->tab->term, s, form_state);
      return 1;
    case 5u:
      if ( *((_DWORD *)name + 6) )
        return 0;
      state = form_state->state;
      if ( !state )
        return 2;
      if ( v61 )
      {
        v47 = utf8_prevchar((unsigned __int8 *)&s[state], 1, (unsigned __int8 *)s);
        v48 = v47 - fs_->value;
        fs_->state = v48;
        if ( state == v48 )
          return 1;
        if ( *((_DWORD *)name + 5) == 3 )
          fs_->state_cell = 0;
        memmove(v47, &fs_->value[state], strlen((const char *)&fs_->value[state]) + 1);
        return 1;
      }
      else
      {
        memmove(&s[state - 1], &s[state], strlen(&s[state]) + 1);
        --fs_->state;
        return 1;
      }
    case 6u:
      if ( *((_DWORD *)name + 5) == 3 )
      {
        result = textarea_op_bob(form_state, (form_control *)name, v61);
        fs_->state_cell = 0;
      }
      else
      {
        result = FRAME_EVENT_REFRESH;
        fs_->state = 0;
      }
      return result;
    case 7u:
      if ( ses->insert_mode != INSERT_MODE_ON )
        return 0;
      ses->insert_mode = INSERT_MODE_OFF;
      return 1;
    case 8u:
      set_clipboard_text((unsigned __int8 *)s);
      return 2;
    case 9u:
      set_clipboard_text((unsigned __int8 *)s);
      if ( !*((_DWORD *)name + 6) )
        *fs_->value = 0;
      fs_->state = 0;
      if ( *((_DWORD *)name + 5) != 3 )
        return 1;
      fs_->state_cell = 0;
      return 1;
    case 0xAu:
      if ( *((_DWORD *)name + 6) )
        return 0;
      v25 = strlen(s);
      v26 = fs_->state;
      if ( v25 <= v26 )
        return 2;
      if ( v61 )
      {
        v27 = (unsigned __int8 *)&s[v26];
        v28 = &s[v25];
        string[0] = v27;
        utf8_to_unicode(string, (const unsigned __int8 *)&s[v25]);
        if ( v27 == string[0] )
          return 1;
        memmove(v27, string[0], v28 - (char *)string[0] + 1);
        return 1;
      }
      else
      {
        memmove(&s[v26], &s[v26 + 1], v25 - v26);
        return 1;
      }
    case 0xBu:
      if ( *((_DWORD *)name + 5) != 3 )
        return 0;
      return textarea_op_down(form_state, (form_control *)name, v61);
    case 0xCu:
      if ( *((_DWORD *)name + 5) != 3 )
        goto LABEL_106;
      return textarea_op_end(form_state, (form_control *)name, v61);
    case 0xDu:
      if ( *((_DWORD *)name + 5) == 3 )
        return textarea_op_eob(form_state, (form_control *)name, v61);
LABEL_106:
      form_state->state = strlen(s);
      return 1;
    case 0xEu:
      if ( *((_DWORD *)name + 5) == 3 )
        return textarea_op_enter(form_state, (form_control *)name, v61);
      if ( (!has_form_submit(*((form **)name + 2))
         || get_opt_(config_options, "document.browse.forms.auto_submit")->number)
        && !goto_current_link(ses, doc_view, 0) )
      {
        return 1;
      }
      if ( ses->insert_mode != INSERT_MODE_ON )
        return 2;
      ses->insert_mode = INSERT_MODE_OFF;
      return 2;
    case 0xFu:
      if ( *((_DWORD *)name + 5) == 3 )
        return textarea_op_home(form_state, (form_control *)name, v61);
      result = FRAME_EVENT_REFRESH;
      fs_->state = 0;
      return result;
    case 0x10u:
      if ( *((_DWORD *)name + 6) )
        return 0;
      v33 = form_state->state;
      if ( v33 <= 0 )
        return 2;
      v34 = memrchr(s, 10, form_state->state);
      v35 = s;
      if ( v34 )
      {
        v35 = &s[v33 - 1];
        if ( v35 != (char *)v34 )
          v35 = (char *)(v34 + 1);
      }
      v36 = &s[v33];
      v37 = strlen(v36);
      memmove(v35, v36, v37 + 1);
      fs_->state = v35 - (char *)fs_->value;
      if ( !v61 || *((_DWORD *)name + 5) != 3 )
        return 1;
      fs_->state_cell = 0;
      return 1;
    case 0x11u:
      if ( *((_DWORD *)name + 6) )
        return 0;
      v29 = &s[form_state->state];
      v30 = *v29;
      if ( !*v29 )
        return 2;
      v31 = strchr(v29, 10);
      if ( v31 )
      {
        v32 = v31 + 1;
        if ( v30 != 10 )
          v32 = v31;
        memmove(v29, v32, strlen(v32) + 1);
        return 1;
      }
      else
      {
        *v29 = 0;
        return 1;
      }
    case 0x12u:
      if ( *((_DWORD *)name + 6) )
        return 0;
      v38 = form_state->state;
      seq = (unsigned __int8 *)fs_->state;
      if ( v38 <= 0 )
        return 2;
      v39 = &s[v38];
      if ( s >= &s[v38] )
      {
        v42 = *v39;
        i = &s[v38];
      }
      else
      {
        v40 = *__ctype_b_loc();
        for ( i = (char *)v39; ; --i )
        {
          v42 = *(i - 1);
          v43 = v40[v42];
          if ( (v43 & 0x2000) == 0 )
            break;
          if ( s >= i - 1 )
          {
            --i;
            goto LABEL_103;
          }
        }
        if ( s < i )
        {
          while ( (v43 & 0x2000) == 0 )
          {
            if ( s >= --i )
              goto LABEL_103;
            v42 = *(i - 1);
            v43 = v40[v42];
          }
        }
        v42 = *i;
      }
LABEL_103:
      v44 = i;
      if ( v42 == 10 )
      {
        v44 = &s[(_DWORD)seq - 1];
        if ( v44 != i )
          v44 = i + 1;
      }
      v45 = strlen(v39);
      memmove(v44, v39, v45 + 1);
      result = FRAME_EVENT_REFRESH;
      fs_->state = v44 - (char *)fs_->value;
      return result;
    case 0x13u:
      if ( *((_DWORD *)name + 5) == 3 )
        return textarea_op_left(form_state, (form_control *)name, v61);
      if ( v61 )
      {
        form_state->state = utf8_prevchar((unsigned __int8 *)&s[form_state->state], 1, (unsigned __int8 *)s)
                          - form_state->value;
        return 1;
      }
      else
      {
        if ( form_state->state - 1 >= 0 )
          v9 = form_state->state - 1;
        result = FRAME_EVENT_REFRESH;
        fs_->state = v9;
      }
      return result;
    case 0x14u:
      v19 = form_state->state;
      if ( v19 <= 0 )
        return 1;
      v20 = __ctype_b_loc();
      for ( j = v19 - 1; ; --j )
      {
        v22 = *v20;
        if ( ((*v20)[(unsigned __int8)s[j]] & 0x2000) == 0 )
          break;
        fs_->state = j;
        if ( j <= 0 )
          return 1;
      }
      v23 = fs_->state;
      if ( v23 > 0 )
      {
        for ( k = v23 - 1; (v22[(unsigned __int8)s[k]] & 0x2000) == 0; --k )
        {
          fs_->state = k;
          if ( k <= 0 )
            break;
          v22 = *v20;
        }
      }
      return 1;
    case 0x15u:
      v11 = __ctype_b_loc();
      for ( m = fs_->state; ; fs_->state = m )
      {
        v13 = m;
        v14 = s[m++];
        if ( ((*v11)[v14] & 0x2000) == 0 )
          break;
      }
      if ( !v14 )
        return 1;
      v15 = &fs_->value[v13];
      break;
    case 0x17u:
      if ( *((_DWORD *)name + 6) )
        return 0;
      if ( *((_DWORD *)name + 5) != 3 )
        return 1;
      textarea_edit(0, ses->tab->term, form_state, doc_view, link);
      return 1;
    case 0x18u:
      if ( *((_DWORD *)name + 6) )
        return 1;
      clipboard_text = (const char *)get_clipboard_text();
      v50 = (char *)clipboard_text;
      if ( !clipboard_text )
        return 1;
      v51 = strlen(clipboard_text);
      if ( v51 <= *((_DWORD *)name + 16) )
      {
        v55 = v51 + 1;
        v56 = (unsigned __int8 *)mem_realloc(fs_->value, v51 + 1);
        if ( v56 )
        {
          fs_->value = v56;
          memmove(v56, v50, v55);
          fs_->state = strlen((const char *)fs_->value);
          if ( v61 && *((_DWORD *)name + 5) == 3 )
            fs_->state_cell = 0;
        }
      }
      mem_free(v50);
      return 1;
    case 0x1Au:
      redraw_terminal_cls(ses->tab->term);
      return 2;
    case 0x1Bu:
      if ( *((_DWORD *)name + 5) == 3 )
        return textarea_op_right(form_state, (form_control *)name, v61);
      if ( v61 )
      {
        string[0] = (unsigned __int8 *)&s[form_state->state];
        v52 = (const unsigned __int8 *)__rawmemchr(string[0], 0);
        utf8_to_unicode(string, v52);
        fs_->state = string[0] - fs_->value;
        return 1;
      }
      else
      {
        v10 = strlen(s);
        if ( v10 > fs_->state + 1 )
          v10 = fs_->state + 1;
        fs_->state = v10;
        return 1;
      }
    case 0x1Du:
      if ( *((_DWORD *)name + 5) != 3 )
        return 0;
      return textarea_op_up(form_state, (form_control *)name, v61);
    default:
      if ( v58->info.mouse.x <= 31 || v58->info.mouse.y )
        return 0;
      if ( *((_DWORD *)name + 6) )
        return 2;
      terminal_codepage = get_terminal_codepage(ses->tab->term);
      seqa = (unsigned __int8 *)u2cp_(v58->info.mouse.x, terminal_codepage, NBSP_MODE_ASCII);
      v54 = strlen((const char *)seqa);
      if ( v54 + strlen((const char *)fs_->value) > *((_DWORD *)name + 16)
        || !insert_in_string(&fs_->value, fs_->state, seqa, v54) )
      {
        return 2;
      }
      fs_->state += v54;
      if ( *((_DWORD *)name + 5) != 3 )
        return 1;
      fs_->state_cell = 0;
      return 1;
  }
  while ( 1 )
  {
    fs_->state = ++v13;
    v16 = v15[1];
    if ( !v16 )
      break;
    ++v15;
    if ( ((*v11)[v16] & 0x2000) != 0 )
      goto LABEL_46;
  }
  if ( (*((_BYTE *)*v11 + 1) & 0x20) == 0 )
    return 1;
LABEL_46:
  v17 = &fs_->value[v13];
  do
  {
    fs_->state = ++v13;
    v18 = *++v17;
  }
  while ( ((*v11)[v18] & 0x2000) != 0 );
  return 1;
}
// 80596A8: using guessed type int __cdecl memrchr(_DWORD, _DWORD, _DWORD);
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080F1CD0) --------------------------------------------------------
void __cdecl do_reset_form(document_view *doc_view, form *form)
{
  form_control *i; // ebx
  form_state *form_state; // eax

  if ( assert_failed )
    goto LABEL_11;
  if ( doc_view && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
  errline = 1196;
  elinks_internal("assertion doc_view && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_11:
    assert_failed = 0;
    return;
  }
LABEL_5:
  for ( i = (form_control *)form->items.next; i != (form_control *)&form->items; i = i->next )
  {
    form_state = find_form_state(doc_view, i);
    if ( form_state )
      init_form_state(doc_view, i, form_state);
  }
}

//----- (080F1D90) --------------------------------------------------------
void __cdecl draw_form_entry(terminal *term, document_view *doc_view, link *link)
{
  view_state *vs; // eax
  int x; // edx
  int y; // ecx
  point *v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // eax
  point *points; // eax
  int v11; // edx
  int state; // edx
  int v13; // esi
  int vpos; // ecx
  int v15; // eax
  unsigned int v16; // ecx
  int v17; // esi
  unsigned __int8 *v18; // eax
  int i; // ebx
  unicode_val_T v20; // edx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  unsigned __int8 *v24; // eax
  int v25; // edi
  point *v26; // edx
  int v27; // eax
  int v28; // ecx
  int v29; // edx
  int v30; // ecx
  unicode_val_T v31; // edx
  unsigned __int8 *value; // eax
  unsigned __int8 *v33; // eax
  unsigned int v34; // esi
  int v35; // edi
  unsigned __int8 *v36; // eax
  const char *v37; // eax
  signed int v38; // eax
  int v39; // edx
  int v40; // ecx
  int v41; // edx
  unsigned __int8 *v42; // ecx
  int v43; // eax
  unicode_val_T v44; // esi
  int v45; // edi
  int v46; // edx
  int v47; // esi
  int v48; // eax
  int v49; // edx
  int v50; // esi
  int v51; // edi
  int v52; // eax
  int v53; // ecx
  int v54; // edi
  document_view *v55; // edx
  unicode_val_T v56; // ecx
  point *v57; // eax
  int v58; // ebx
  int v59; // ecx
  int v60; // eax
  int v61; // eax
  int v62; // [esp+8h] [ebp-70h]
  unicode_val_T v63; // [esp+Ch] [ebp-6Ch]
  unicode_val_T v64; // [esp+20h] [ebp-58h]
  unsigned __int8 *v65; // [esp+24h] [ebp-54h]
  int v66; // [esp+24h] [ebp-54h]
  document_view *v67; // [esp+24h] [ebp-54h]
  document_view *v68; // [esp+24h] [ebp-54h]
  unsigned __int8 *end; // [esp+28h] [ebp-50h]
  int v70; // [esp+2Ch] [ebp-4Ch]
  unsigned __int8 *maybe_in_view; // [esp+30h] [ebp-48h]
  int v72; // [esp+34h] [ebp-44h]
  int v73; // [esp+34h] [ebp-44h]
  form_state *fs_0; // [esp+38h] [ebp-40h]
  unsigned __int8 *v75; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v76; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *v77; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *last_in_view; // [esp+40h] [ebp-38h]
  unsigned __int8 *last_in_viewa; // [esp+40h] [ebp-38h]
  unsigned __int8 *last_in_viewb; // [esp+40h] [ebp-38h]
  unsigned __int8 *last_in_viewc; // [esp+40h] [ebp-38h]
  unsigned __int8 *name; // [esp+44h] [ebp-34h]
  int dy; // [esp+48h] [ebp-30h]
  int dya; // [esp+48h] [ebp-30h]
  int dyb; // [esp+48h] [ebp-30h]
  int dx_0; // [esp+4Ch] [ebp-2Ch]
  int dx_0a; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *ptr; // [esp+54h] [ebp-24h] BYREF
  unsigned __int8 *text; // [esp+58h] [ebp-20h] BYREF
  unsigned __int8 *s; // [esp+5Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_14;
  if ( doc_view && term && doc_view->document && link && doc_view->vs )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 394;
    elinks_internal("assertion term && doc_view && doc_view->document && doc_view->vs && link failed!");
    if ( assert_failed )
      goto LABEL_14;
  }
  if ( link->type <= (unsigned int)LINK_MAP )
  {
    assert_failed = 1;
    name = 0;
LABEL_13:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 398;
    elinks_internal(
      "assertion fc != NULL failed: link %d has no form control",
      -991146299 * (((char *)link - (char *)doc_view->document->links) >> 2));
    if ( !assert_failed )
      goto LABEL_10;
LABEL_14:
    assert_failed = 0;
    return;
  }
  name = link->data.name;
  assert_failed = name == 0;
  if ( !name )
    goto LABEL_13;
LABEL_10:
  fs_0 = find_form_state(doc_view, (form_control *)name);
  if ( !fs_0 )
    return;
  vs = doc_view->vs;
  x = doc_view->box.x;
  dx_0 = x - vs->x;
  y = doc_view->box.y;
  dy = y - vs->y;
  switch ( *((_DWORD *)name + 5) )
  {
    case 0:
    case 1:
    case 2:
      if ( !link->npoints )
        return;
      points = link->points;
      v11 = points->y + dy;
      v72 = v11;
      if ( y > v11 || v11 >= doc_view->box.height + y )
        return;
      v70 = points->x + dx_0;
      if ( (*((_BYTE *)term + 56) & 2) == 0 )
      {
        state = fs_0->state;
        v13 = *((_DWORD *)name + 12);
        vpos = fs_0->vpos;
        v15 = state + 1 - v13;
        if ( v15 <= vpos )
        {
          if ( state >= vpos )
          {
            state = fs_0->vpos;
          }
          else
          {
            fs_0->vpos = state;
            v13 = *((_DWORD *)name + 12);
          }
        }
        else
        {
          fs_0->vpos = v15;
          v13 = *((_DWORD *)name + 12);
          state = v15;
        }
        v16 = strlen((const char *)fs_0->value) + 1;
        if ( v13 > 0 )
        {
          dya = v16 - 1 - state;
          v17 = 0;
          v18 = name;
          for ( i = v70; ; ++i )
          {
            v21 = doc_view->box.x;
            if ( v21 <= i && doc_view->box.width + v21 > i )
            {
              if ( fs_0->value && (v22 = fs_0->vpos, v17 < dya) && -v22 <= v17 )
              {
                v20 = 42;
                if ( *((_DWORD *)v18 + 5) != 1 )
                  v20 = fs_0->value[v17 + v22];
              }
              else
              {
                v20 = 95;
              }
              v65 = v18;
              draw_char_data(term, i, v72, v20);
              v18 = v65;
            }
            if ( *((_DWORD *)v18 + 12) <= ++v17 )
              break;
          }
        }
        return;
      }
LABEL_65:
      text = fs_0->value;
      v37 = (const char *)text;
      if ( !text )
      {
        v37 = &delete;
        text = (unsigned __int8 *)&delete;
      }
      v38 = strlen(v37);
      v39 = fs_0->state;
      if ( v39 < 0 )
      {
        fs_0->state = 0;
        v40 = 0;
      }
      else
      {
        v40 = v38;
        if ( v38 < v39 )
          fs_0->state = v38;
        else
          v40 = fs_0->state;
      }
      v41 = fs_0->vpos;
      if ( v41 < 0 )
      {
        fs_0->vpos = 0;
        v41 = 0;
      }
      else if ( v41 > v40 )
      {
        v41 = v40;
        fs_0->vpos = v40;
      }
      v42 = text;
      text += v41;
      end = &v42[v38];
      v43 = *((_DWORD *)name + 12);
      dx_0a = 0;
      last_in_viewa = 0;
      break;
    case 3:
      draw_textarea(term, fs_0, doc_view, link);
      return;
    case 4:
    case 5:
      if ( link->npoints > 1 )
      {
        v6 = link->points;
        v7 = v6[1].x + dx_0;
        v8 = v6[1].y;
        if ( x <= v7 )
        {
          v9 = dy + v8;
          if ( y <= v9 && v7 < doc_view->box.width + x && v9 < doc_view->box.height + y )
            draw_char_data(term, v7, v9, fs_0->state == 0 ? 32 : 88);
        }
      }
      return;
    case 6:
      fixup_select_state((form_control *)name, fs_0);
      v23 = fs_0->state;
      if ( v23 >= *((_DWORD *)name + 17) )
      {
        v24 = (unsigned __int8 *)&delete;
        s = (unsigned __int8 *)&delete;
      }
      else
      {
        v24 = *(unsigned __int8 **)(*((_DWORD *)name + 19) + 4 * v23);
        s = v24;
      }
      if ( (*((_BYTE *)term + 56) & 2) != 0 )
      {
        text = v24;
        v77 = (unsigned __int8 *)__rawmemchr(v24, 0);
        last_in_viewc = (unsigned __int8 *)utf8_ptr2cells(text, v77);
        if ( link->npoints > 0 )
        {
          v54 = 0;
          v55 = doc_view;
          do
          {
            v57 = &link->points[v54];
            v58 = v57->x + dx_0;
            v59 = v57->y;
            v60 = v55->box.x;
            if ( v58 < v60
              || (v73 = dy + v59, dy + v59 < v55->box.y)
              || v58 >= v55->box.width + v60
              || v73 >= v55->box.height + v55->box.y )
            {
              ++v54;
            }
            else
            {
              if ( (int)last_in_viewc > v54 )
              {
                ++v54;
                v68 = v55;
                v64 = utf8_to_unicode(&s, v77);
                v61 = unicode_to_cell(v64);
                v55 = v68;
                v56 = v64;
                if ( v61 == 2 )
                {
                  if ( (int)last_in_viewc > v54 )
                  {
                    ++v54;
                    draw_char_data(term, v58++, v73, v64);
                    v56 = -3;
                    v55 = v68;
                  }
                  else
                  {
                    v56 = 32;
                  }
                }
              }
              else
              {
                ++v54;
                v56 = 95;
              }
              v67 = v55;
              draw_char_data(term, v58, v73, v56);
              v55 = v67;
            }
          }
          while ( v54 < link->npoints );
        }
      }
      else
      {
        v75 = 0;
        if ( v24 )
          v75 = (unsigned __int8 *)strlen((const char *)v24);
        if ( link->npoints > 0 )
        {
          v25 = 0;
          do
          {
            v26 = &link->points[v25];
            v27 = v26->x + dx_0;
            v28 = v26->y;
            v29 = doc_view->box.x;
            if ( v27 >= v29 )
            {
              last_in_view = (unsigned __int8 *)(dy + v28);
              v30 = doc_view->box.y;
              if ( (int)last_in_view >= v30
                && v27 < doc_view->box.width + v29
                && (int)last_in_view < v30 + doc_view->box.height )
              {
                v31 = 95;
                if ( (int)v75 > v25 )
                  v31 = s[v25];
                draw_char_data(term, v27, (int)last_in_view, v31);
              }
            }
            ++v25;
          }
          while ( link->npoints > v25 );
        }
      }
      return;
    default:
      return;
  }
  while ( dx_0a < v43 )
  {
    maybe_in_view = text;
    v44 = utf8_to_unicode(&text, end);
    if ( v44 == -3 )
    {
      v44 = 95;
    }
    else if ( *((_DWORD *)name + 5) == 1 )
    {
      v44 = 42;
    }
    v45 = unicode_to_cell(v44);
    v76 = (unsigned __int8 *)(v45 + dx_0a);
    v43 = *((_DWORD *)name + 12);
    dyb = v43;
    if ( v45 + dx_0a <= v43 )
    {
      last_in_viewb = (unsigned __int8 *)(v70 + dx_0a);
      v46 = doc_view->box.x;
      if ( v70 + dx_0a >= v46 && v45 + v70 + dx_0a <= doc_view->box.width + v46 )
      {
        v63 = v44;
        v47 = 1;
        draw_char_data(term, (int)last_in_viewb, v72, v63);
        if ( v45 <= 1 )
        {
          v43 = *((_DWORD *)name + 12);
          last_in_viewa = maybe_in_view;
        }
        else
        {
          do
          {
            v48 = (int)&last_in_viewb[v47++];
            draw_char_data(term, v48, v72, 0xFFFFFFFD);
          }
          while ( v45 > v47 );
          v43 = *((_DWORD *)name + 12);
          last_in_viewa = maybe_in_view;
        }
        goto drew_char;
      }
      last_in_viewa = maybe_in_view;
    }
    if ( v45 > 0 )
    {
      v49 = v45;
      v50 = 0;
      v51 = v70 + dx_0a;
      v52 = v49;
      do
      {
        v53 = doc_view->box.x;
        if ( v50 + v51 >= v53 && v50 + v51 < doc_view->box.width + v53 && dyb > v50 + dx_0a )
        {
          v66 = v52;
          draw_char_data(term, v50 + v51, v72, 0x20u);
          v52 = v66;
          dyb = *((_DWORD *)name + 12);
        }
        ++v50;
      }
      while ( v52 > v50 );
      v43 = dyb;
    }
drew_char:
    dx_0a = (int)v76;
  }
  value = fs_0->value;
  if ( last_in_viewa )
  {
    if ( value )
    {
      v33 = &value[fs_0->state];
      if ( v33 > last_in_viewa )
      {
        ptr = v33;
        v34 = *((_DWORD *)name + 12);
        v35 = *((_DWORD *)name + 5);
        v62 = (__PAIR64__(v34, utf8_to_unicode(&ptr, end) + 3) - 1) >> 32;
        ptr = utf8_step_backward(ptr, fs_0->value, v62, (utf8_step)(v35 != 1), 0);
        v36 = (unsigned __int8 *)(ptr - fs_0->value);
        if ( (unsigned __int8 *)fs_0->vpos != v36 )
        {
          fs_0->vpos = (int)v36;
          goto LABEL_65;
        }
      }
    }
  }
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080F2550) --------------------------------------------------------
void __cdecl draw_forms(terminal *term, document_view *doc_view)
{
  link *first_link; // ebx
  link *last_link; // eax
  link *v4; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = term == 0 || doc_view == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c",
        errline = 638,
        elinks_internal("assertion term && doc_view failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    first_link = get_first_link(doc_view);
    last_link = get_last_link(doc_view);
    if ( last_link && first_link )
    {
      while ( 1 )
      {
        if ( first_link->type > (unsigned int)LINK_MAP && first_link->data.name )
        {
          v4 = last_link;
          draw_form_entry(term, doc_view, first_link);
          last_link = v4;
        }
        if ( first_link >= last_link )
          break;
        ++first_link;
      }
    }
    else if ( !assert_failed )
    {
      assert_failed = first_link != 0 || last_link != 0;
      if ( first_link != 0 || last_link != 0 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 645;
        elinks_internal("assertion !l1 && !l2 failed: get_first_link == %p, get_last_link == %p", first_link, last_link);
      }
    }
  }
}

//----- (080F2680) --------------------------------------------------------
frame_event_status __cdecl reset_form(session *ses, document_view *doc_view, int a)
{
  int current_link; // eax
  document *document; // edx
  int v5; // eax
  int v6; // edx

  if ( doc_view )
  {
    current_link = doc_view->vs->current_link;
    if ( current_link >= 0 )
    {
      document = doc_view->document;
      if ( current_link < document->nlinks )
      {
        v5 = (int)&document->links[current_link];
        if ( v5 )
        {
          v6 = 0;
          if ( *(_DWORD *)(v5 + 4) > 1u )
            v6 = *(_DWORD *)(v5 + 48);
          do_reset_form(doc_view, *(form **)(v6 + 8));
          draw_forms(ses->tab->term, doc_view);
        }
      }
    }
  }
  return 2;
}

//----- (080F26F0) --------------------------------------------------------
int __cdecl get_current_state(session *ses)
{
  document_view *v1; // eax
  int current_link; // edx
  document *document; // ecx
  int v4; // edx
  form_state *form_state; // eax
  document_view *v7; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_14;
  assert_failed = ses == 0;
  if ( !ses )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 369;
    elinks_internal("assertion ses failed!");
    if ( assert_failed )
      goto LABEL_14;
  }
  v1 = current_frame(ses);
  if ( assert_failed )
    goto LABEL_14;
  if ( v1 && v1->vs && v1->document )
  {
    assert_failed = 0;
    goto LABEL_8;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
  errline = 373;
  v7 = v1;
  elinks_internal("assertion doc_view && doc_view->vs && doc_view->document failed!");
  v1 = v7;
  if ( assert_failed )
  {
LABEL_14:
    assert_failed = 0;
    return -1;
  }
  if ( !v7 )
    return -1;
LABEL_8:
  current_link = v1->vs->current_link;
  if ( current_link < 0 )
    return -1;
  document = v1->document;
  if ( current_link >= document->nlinks )
    return -1;
  v4 = (int)&document->links[current_link];
  if ( !v4 )
    return -1;
  if ( *(_DWORD *)(v4 + 4) != 4 )
    return -1;
  form_state = find_form_state(v1, *(form_control **)(v4 + 48));
  if ( !form_state )
    return -1;
  return form_state->state;
}

//----- (080F2840) --------------------------------------------------------
void __cdecl selected_item(terminal *term, void *item_, void *ses_)
{
  document_view *v3; // eax
  document_view *v4; // ebx
  int current_link; // eax
  document *document; // edx
  int v7; // eax
  form_state *form_state; // eax
  form_control *v9; // ecx
  form_state *v10; // edx
  unsigned __int8 *value; // eax
  unsigned __int8 *v12; // eax
  form_state *v13; // [esp+18h] [ebp-20h]
  form_state *v14; // [esp+18h] [ebp-20h]
  form_control *v15; // [esp+1Ch] [ebp-1Ch]
  form_control *v16; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_21;
  assert_failed = term == 0 || ses_ == 0;
  if ( term == 0 || ses_ == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 133;
    elinks_internal("assertion term && ses failed!");
    if ( assert_failed )
      goto LABEL_21;
  }
  v3 = current_frame((session *)ses_);
  v4 = v3;
  if ( assert_failed )
    goto LABEL_21;
  if ( !v3 || !v3->vs || !v3->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 137;
    elinks_internal("assertion doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
    {
      if ( !v4 )
        return;
      goto LABEL_8;
    }
LABEL_21:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_8:
  current_link = v4->vs->current_link;
  if ( current_link >= 0 )
  {
    document = v4->document;
    if ( current_link < document->nlinks )
    {
      v7 = (int)&document->links[current_link];
      if ( v7 )
      {
        if ( *(_DWORD *)(v7 + 4) == 4 )
        {
          v15 = *(form_control **)(v7 + 48);
          form_state = find_form_state(v4, v15);
          v9 = v15;
          v10 = form_state;
          if ( form_state )
          {
            if ( (int)item_ >= 0 && (int)item_ < v15->nvalues )
            {
              form_state->state = (int)item_;
              value = form_state->value;
              if ( value )
              {
                v13 = v10;
                mem_free(value);
                v9 = v15;
                v10 = v13;
              }
              v14 = v10;
              v16 = v9;
              v12 = stracpy(v9->values[(_DWORD)item_]);
              v10 = v14;
              v14->value = v12;
              v9 = v16;
            }
            fixup_select_state(v9, v10);
          }
          refresh_view((session *)ses_, v4, 0);
        }
      }
    }
  }
}

//----- (080F2A10) --------------------------------------------------------
void __usercall add_form_attr_to_string(
        string *string@<eax>,
        terminal *term@<edx>,
        unsigned __int8 *name@<ecx>,
        unsigned __int8 *value)
{
  int terminal_codepage; // eax
  int v8; // esi
  unsigned __int8 *cp_mime_name; // eax

  add_to_string(string, ", ");
  if ( name && *name )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v8 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v8;
      }
    }
    name = gettext(name);
  }
  add_to_string(string, name);
  if ( value )
  {
    add_char_to_string(string, 0x20u);
    add_to_string(string, value);
  }
}

//----- (080F2AC0) --------------------------------------------------------
void __cdecl link_form_menu(session *ses)
{
  document_view *v1; // eax
  int current_link; // eax
  document *document; // edx
  int v4; // ebx
  bool v5; // zf
  int v6; // eax
  menu_item *v7; // eax
  list_head_elinks *next; // ebx
  const char *form_label; // esi
  int form_control_link; // edi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  unsigned __int8 *v13; // esi
  _DWORD *v14; // eax
  unsigned int prev; // eax
  int v16; // [esp+20h] [ebp-38h]
  form *form; // [esp+24h] [ebp-34h]
  list_head_elinks *p_items; // [esp+28h] [ebp-30h]
  document_view *doc_view; // [esp+2Ch] [ebp-2Ch]
  string str; // [esp+34h] [ebp-24h] BYREF
  menu_item *mi; // [esp+3Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_43;
  assert_failed = ses == 0;
  if ( !ses )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 2082;
    elinks_internal("assertion ses failed!");
    if ( assert_failed )
      goto LABEL_43;
  }
  v1 = current_frame(ses);
  doc_view = v1;
  if ( !v1 )
    return;
  if ( assert_failed )
    goto LABEL_43;
  if ( v1->vs && v1->document )
  {
    assert_failed = 0;
    goto LABEL_8;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
  errline = 2088;
  elinks_internal("assertion doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_43:
    assert_failed = 0;
    return;
  }
LABEL_8:
  current_link = doc_view->vs->current_link;
  if ( current_link >= 0 )
  {
    document = doc_view->document;
    if ( current_link < document->nlinks )
    {
      v4 = (int)&document->links[current_link];
      if ( v4 )
      {
        v5 = *(_DWORD *)(v4 + 4) > 1u;
        assert_failed = *(_DWORD *)(v4 + 4) <= 1u;
        if ( !v5 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
          errline = 2094;
          elinks_internal("assertion link_is_form(link) failed!");
        }
        if ( *(_DWORD *)(v4 + 4) > 1u )
        {
          v6 = *(_DWORD *)(v4 + 48);
          if ( v6 )
          {
            form = *(form **)(v6 + 8);
            v7 = new_menu(NO_INTL|FREE_TEXT|FREE_LIST);
            if ( v7 )
            {
              mi = v7;
              next = (list_head_elinks *)form->items.next;
              p_items = &form->items;
              if ( &form->items == next )
              {
LABEL_41:
                do_menu(ses->tab->term, v7, ses, 1);
                return;
              }
              while ( 1 )
              {
                prev = (unsigned int)next[2].prev;
                if ( prev < 7 )
                  goto LABEL_18;
                if ( prev <= 8 )
                {
                  form_label = "Useless button";
                  if ( form->action )
                    form_label = "Submit button";
                  goto LABEL_19;
                }
                if ( prev == 11 )
                {
                  next = (list_head_elinks *)next->next;
                  if ( p_items == next )
                    goto LABEL_40;
                }
                else
                {
LABEL_18:
                  form_label = get_form_label((form_control *)next);
LABEL_19:
                  form_control_link = get_form_control_link(doc_view->document, (form_control *)next);
                  if ( form_control_link >= 0 && init_string(&str) )
                  {
                    if ( !assert_failed )
                    {
                      assert_failed = form_label == 0;
                      if ( !form_label )
                      {
                        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
                        errline = 2131;
                        elinks_internal("assertion text failed!");
                      }
                    }
                    if ( form_label && *form_label )
                    {
                      if ( ses->tab->term )
                      {
                        terminal_codepage = get_terminal_codepage(ses->tab->term);
                        if ( terminal_codepage != current_charset )
                        {
                          v16 = terminal_codepage;
                          cp_mime_name = get_cp_mime_name(terminal_codepage);
                          bind_textdomain_codeset("elinks", cp_mime_name);
                          current_charset = v16;
                        }
                      }
                      form_label = (const char *)gettext((const unsigned __int8 *)form_label);
                    }
                    add_to_string(&str, (const unsigned __int8 *)form_label);
                    v13 = (unsigned __int8 *)next[4].next;
                    if ( !v13 )
                      v13 = (unsigned __int8 *)next[4].prev;
                    v14 = mem_alloc(4u);
                    if ( v14 )
                      *v14 = form_control_link;
                    add_to_menu(&mi, str.source, v13, ACT_MAIN_NONE, link_form_menu_func, v14, FREE_DATA);
                  }
                  next = (list_head_elinks *)next->next;
                  if ( p_items == next )
                  {
LABEL_40:
                    v7 = mi;
                    goto LABEL_41;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (080F2E30) --------------------------------------------------------
void __usercall encode_multipart(
        session *ses@<eax>,
        list_head_elinks *l@<edx>,
        string *data@<ecx>,
        boundary_info *boundary,
        int cp_from,
        int cp_to)
{
  string *v6; // ebx
  const unsigned __int8 *next; // esi
  unsigned __int8 *string; // edi
  unsigned int v9; // eax
  int v10; // eax
  unsigned __int8 *v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx
  int *v14; // eax
  int v15; // edx
  unsigned __int8 *v16; // edx
  unsigned int v17; // eax
  size_t v18; // ecx
  unsigned __int8 *v19; // eax
  unsigned __int8 *filename_position; // eax
  unsigned __int8 *v21; // eax
  unsigned __int8 *extension_content_type; // eax
  unsigned __int8 *v23; // eax
  ssize_t v24; // eax
  size_t v25; // esi
  int v26; // edi
  int v27; // ecx
  unsigned int v28; // edi
  size_t v29; // edx
  int *v30; // eax
  int *v31; // edi
  char *v32; // eax
  unsigned __int8 *v33; // eax
  int *v34; // eax
  unsigned __int8 *v35; // eax
  unsigned int v36; // edi
  unsigned int v37; // esi
  int *offsets; // eax
  int count; // edx
  int v40; // ecx
  int *v41; // ebx
  char *v42; // edx
  int *v43; // eax
  int v44; // ecx
  unsigned __int8 *v45; // edx
  int i; // edx
  unsigned __int8 v47; // cl
  size_t length; // esi
  unsigned __int8 *v49; // eax
  unsigned __int8 *v50; // eax
  size_t v51; // edi
  int *v52; // eax
  int v53; // [esp+34h] [ebp-454h]
  int v54; // [esp+34h] [ebp-454h]
  size_t v55; // [esp+34h] [ebp-454h]
  int v56; // [esp+34h] [ebp-454h]
  unsigned __int8 *charsc; // [esp+38h] [ebp-450h]
  unsigned __int8 *charsd; // [esp+38h] [ebp-450h]
  unsigned __int8 *charse; // [esp+38h] [ebp-450h]
  unsigned __int8 *charsf; // [esp+38h] [ebp-450h]
  unsigned int chars; // [esp+38h] [ebp-450h]
  unsigned __int8 *charsa; // [esp+38h] [ebp-450h]
  unsigned __int8 *charsb; // [esp+38h] [ebp-450h]
  unsigned __int8 *v64; // [esp+40h] [ebp-448h]
  conv_table *convert_table; // [esp+4Ch] [ebp-43Ch]
  conv_table *convert_tablea; // [esp+4Ch] [ebp-43Ch]
  int v69; // [esp+50h] [ebp-438h]
  int v70; // [esp+54h] [ebp-434h]
  const unsigned __int8 *v71; // [esp+54h] [ebp-434h]
  unsigned int v72; // [esp+54h] [ebp-434h]
  int fh; // [esp+5Ch] [ebp-42Ch]
  int fha; // [esp+5Ch] [ebp-42Ch]
  int fhb; // [esp+5Ch] [ebp-42Ch]
  unsigned __int8 buffer[1024]; // [esp+6Ch] [ebp-41Ch] BYREF
  unsigned int v77; // [esp+46Ch] [ebp-1Ch]

  v6 = data;
  v77 = __readgsdword(0x14u);
  if ( assert_failed )
    goto LABEL_23;
  if ( !l || !ses || !boundary || !data )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 985;
    elinks_internal("assertion ses && l && data && boundary failed!");
    if ( !assert_failed )
      goto LABEL_4;
LABEL_23:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_4:
  memset(boundary, 0, sizeof(boundary_info));
  memset(boundary->string, 48, sizeof(boundary->string));
  next = (const unsigned __int8 *)l->next;
  if ( l->next == l )
  {
LABEL_62:
    add_to_string(v6, (const unsigned __int8 *)"--");
    v36 = (boundary->count + 256) & 0xFFFFFF00;
    v37 = (boundary->count + 255) & 0xFFFFFF00;
    if ( v36 > v37 )
    {
      v51 = 4 * v36;
      v52 = (int *)mem_realloc(boundary->offsets, v51);
      if ( !v52 )
        goto LABEL_65;
      boundary->offsets = v52;
      memset(&v52[v37], 0, v51 - 4 * v37);
    }
    offsets = boundary->offsets;
    if ( offsets )
    {
      count = boundary->count;
      offsets[count] = v6->length;
      boundary->count = count + 1;
    }
LABEL_65:
    if ( assert_failed )
    {
LABEL_66:
      assert_failed = 0;
LABEL_67:
      add_to_string(v6, "--\r\n");
      v69 = boundary->count;
      if ( boundary->count - 1 <= 0 )
      {
        v43 = boundary->offsets;
LABEL_75:
        if ( v69 > 0 )
        {
          v44 = 0;
          while ( 1 )
          {
            v45 = &v6->source[v43[v44++]];
            *(_DWORD *)v45 = *(_DWORD *)boundary->string;
            *((_DWORD *)v45 + 1) = *(_DWORD *)&boundary->string[4];
            *((_DWORD *)v45 + 2) = *(_DWORD *)&boundary->string[8];
            *((_DWORD *)v45 + 3) = *(_DWORD *)&boundary->string[12];
            *((_DWORD *)v45 + 4) = *(_DWORD *)&boundary->string[16];
            *((_DWORD *)v45 + 5) = *(_DWORD *)&boundary->string[20];
            *((_DWORD *)v45 + 6) = *(_DWORD *)&boundary->string[24];
            *((_DWORD *)v45 + 7) = *(_DWORD *)&boundary->string[28];
            if ( v44 >= boundary->count )
              break;
            v43 = boundary->offsets;
          }
          v43 = boundary->offsets;
        }
      }
      else
      {
        v40 = 0;
        convert_tablea = (conv_table *)v6;
        v41 = boundary->offsets;
        while ( 1 )
        {
          fhb = v40 + 1;
          v42 = (char *)(convert_tablea->t + v41[v40] + 72);
          v72 = convert_tablea->t + v41[++v40] - 34;
          if ( (unsigned int)v42 <= v72 )
            break;
LABEL_73:
          if ( v69 - 1 <= v40 )
          {
            v43 = v41;
            v6 = (string *)convert_tablea;
            goto LABEL_75;
          }
        }
        while ( memcmp(v42, boundary->string, 0x20u) )
        {
          if ( v72 < (unsigned int)++v42 )
          {
            v40 = fhb;
            goto LABEL_73;
          }
        }
        for ( i = 31; i != -1; --i )
        {
          v47 = boundary->string[i];
          boundary->string[i] = v47 + 1;
          if ( v47 <= 0x38u )
          {
            v40 = 1;
            v41 = boundary->offsets;
            v69 = boundary->count;
            goto LABEL_73;
          }
          boundary->string[i] = 48;
        }
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
        errline = 925;
        elinks_internal("Form data boundary counter overflow");
        v43 = boundary->offsets;
      }
      if ( v43 )
        mem_free(v43);
      return;
    }
    if ( v6 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
        goto LABEL_66;
    }
    length = v6->length;
    if ( mem_align_alloc___1((void **)&v6->source, length, length + 33, 1u, 0xFFu) )
    {
      v49 = &v6->source[v6->length];
      *(_DWORD *)v49 = *(_DWORD *)boundary->string;
      *((_DWORD *)v49 + 1) = *(_DWORD *)&boundary->string[4];
      *((_DWORD *)v49 + 2) = *(_DWORD *)&boundary->string[8];
      *((_DWORD *)v49 + 3) = *(_DWORD *)&boundary->string[12];
      *((_DWORD *)v49 + 4) = *(_DWORD *)&boundary->string[16];
      *((_DWORD *)v49 + 5) = *(_DWORD *)&boundary->string[20];
      *((_DWORD *)v49 + 6) = *(_DWORD *)&boundary->string[24];
      *((_DWORD *)v49 + 7) = *(_DWORD *)&boundary->string[28];
      v6->source[length + 32] = 0;
      v6->length = length + 32;
    }
    goto LABEL_67;
  }
  convert_table = 0;
  string = boundary->string;
  while ( 1 )
  {
    add_to_string(v6, (const unsigned __int8 *)"--");
    v12 = boundary->count + 256;
    v13 = boundary->count + 255;
    LOBYTE(v12) = 0;
    LOBYTE(v13) = 0;
    if ( v12 > v13 )
    {
      chars = v13;
      v54 = 4 * v12;
      v34 = (int *)mem_realloc(boundary->offsets, 4 * v12);
      if ( !v34 )
        goto LABEL_17;
      boundary->offsets = v34;
      memset(&v34[chars], 0, v54 - 4 * chars);
    }
    v14 = boundary->offsets;
    if ( v14 )
    {
      v15 = boundary->count;
      v14[v15] = v6->length;
      boundary->count = v15 + 1;
    }
LABEL_17:
    if ( assert_failed )
      goto LABEL_6;
    if ( v6 )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
      errline = 255;
      elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
      if ( assert_failed )
      {
LABEL_6:
        assert_failed = 0;
        goto LABEL_7;
      }
    }
    v16 = (unsigned __int8 *)v6->length;
    v70 = (int)(v16 + 32);
    v17 = (unsigned int)(v16 + 255);
    v18 = (size_t)(v16 + 288);
    LOBYTE(v17) = 0;
    LOBYTE(v18) = 0;
    fh = v17;
    if ( v18 > v17 )
    {
      charsa = (unsigned __int8 *)v6->length;
      v55 = v18;
      v35 = (unsigned __int8 *)mem_realloc(v6->source, v18);
      if ( !v35 )
        goto LABEL_7;
      v6->source = v35;
      memset(&v35[fh], 0, v55 - fh);
      v16 = charsa;
    }
    if ( v6->source )
    {
      v19 = &v6->source[v6->length];
      *(_DWORD *)v19 = *(_DWORD *)string;
      *((_DWORD *)v19 + 1) = *((_DWORD *)string + 1);
      *((_DWORD *)v19 + 2) = *((_DWORD *)string + 2);
      *((_DWORD *)v19 + 3) = *((_DWORD *)string + 3);
      *((_DWORD *)v19 + 4) = *((_DWORD *)string + 4);
      *((_DWORD *)v19 + 5) = *((_DWORD *)string + 5);
      *((_DWORD *)v19 + 6) = *((_DWORD *)string + 6);
      *((_DWORD *)v19 + 7) = *((_DWORD *)string + 7);
      v16[(unsigned int)v6->source + 32] = 0;
      v6->length = v70;
    }
LABEL_7:
    add_crlf_to_string(v6);
    add_to_string(v6, "Content-Disposition: form-data; name=\"");
    add_to_string(v6, *((const unsigned __int8 **)next + 2));
    add_char_to_string(v6, 0x22u);
    if ( *((_DWORD *)next + 5) == 2 )
      break;
    add_crlf_to_string(v6);
    add_crlf_to_string(v6);
    v9 = *((_DWORD *)next + 5);
    if ( v9 == 3 || v9 <= 1 )
    {
      if ( !convert_table )
        convert_table = get_translation_table(cp_from, cp_to);
      charsc = (unsigned __int8 *)*((_DWORD *)next + 3);
      v10 = strlen((const char *)charsc);
      v11 = convert_string_elinks(convert_table, charsc, v10, -1, CSM_FORM, 0, 0, 0);
      if ( v11 )
      {
        charsd = v11;
        add_to_string(v6, v11);
        mem_free(charsd);
      }
    }
    else
    {
      add_to_string(v6, *((const unsigned __int8 **)next + 3));
    }
LABEL_13:
    add_crlf_to_string(v6);
    next = *(const unsigned __int8 **)next;
    if ( next == (const unsigned __int8 *)l )
      goto LABEL_62;
  }
  add_to_string(v6, "; filename=\"");
  filename_position = get_filename_position(*((unsigned __int8 **)next + 3));
  add_to_string(v6, filename_position);
  add_char_to_string(v6, 0x22u);
  v21 = (unsigned __int8 *)strrchr(*((const char **)next + 3), 46);
  if ( v21 )
  {
    extension_content_type = get_extension_content_type(v21);
    if ( extension_content_type )
    {
      charse = extension_content_type;
      add_crlf_to_string(v6);
      add_to_string(v6, "Content-Type: ");
      add_to_string(v6, charse);
      mem_free(charse);
    }
  }
  add_crlf_to_string(v6);
  add_crlf_to_string(v6);
  if ( !**((_BYTE **)next + 3) )
    goto LABEL_13;
  if ( get_opt_(cmdline_options, "anonymous")->number )
  {
    v31 = __errno_location();
    *v31 = 1;
  }
  else
  {
    v23 = expand_tilde(*((unsigned __int8 **)next + 3));
    if ( v23 )
    {
      charsf = v23;
      fha = open64(v23, 0);
      mem_free(charsf);
      if ( fha != -1 )
      {
        set_bin(fha);
        v71 = next;
        v64 = string;
        while ( 1 )
        {
          while ( 1 )
          {
            while ( 1 )
            {
              while ( 1 )
              {
                v24 = read(fha, buffer, 0x400u);
                v25 = v24;
                if ( v24 != -1 )
                  break;
                v30 = __errno_location();
                if ( *v30 != 4 )
                {
                  v31 = v30;
                  next = v71;
                  close(fha);
                  goto encode_error;
                }
              }
              if ( !v24 )
              {
                next = v71;
                string = v64;
                close(fha);
                goto LABEL_13;
              }
              if ( !assert_failed )
                break;
LABEL_40:
              assert_failed = 0;
            }
            if ( v6 && v24 >= 0 )
            {
              assert_failed = 0;
            }
            else
            {
              assert_failed = 1;
              errfile = "/home/naftali/source/elinks-0.12~pre5/src/util/string.h";
              errline = 255;
              elinks_internal("assertion string && bytes && length >= 0 failed: [add_bytes_to_string]");
              if ( assert_failed )
                goto LABEL_40;
            }
            v26 = v6->length;
            v27 = v25 + v26;
            v29 = v25 + v26 + 256;
            v28 = (v26 + 255) & 0xFFFFFF00;
            LOBYTE(v29) = 0;
            if ( v29 > v28 )
              break;
LABEL_45:
            if ( v6->source )
            {
              v53 = v27;
              memcpy(&v6->source[v6->length], buffer, v25);
              v6->source[v53] = 0;
              v6->length = v53;
            }
          }
          charsb = (unsigned __int8 *)v29;
          v56 = v27;
          v50 = (unsigned __int8 *)mem_realloc(v6->source, v29);
          if ( v50 )
          {
            v6->source = v50;
            memset(&v50[v28], 0, (size_t)&charsb[-v28]);
            v27 = v56;
            goto LABEL_45;
          }
        }
      }
    }
    v31 = __errno_location();
  }
encode_error:
  if ( boundary->offsets )
    mem_free(boundary->offsets);
  done_string(v6);
  v32 = strerror(*v31);
  v33 = msg_text(ses->tab->term, "Could not load file %s: %s", *((const char **)next + 3), v32);
  info_box(ses->tab->term, MSGBOX_FREE_TEXT, "Error while posting form", ALIGN_CENTER, v33);
}
// 80598F8: using guessed type int __cdecl open64(_DWORD, _DWORD);

//----- (080F39C0) --------------------------------------------------------
uri *__cdecl get_form_uri(session *ses, document_view *doc_view, form_control *fc)
{
  uri *result; // eax
  window *tab; // eax
  form *v5; // eax
  form *v6; // edx
  form_control *i; // esi
  unsigned __int8 *name; // eax
  form_state *form_state; // ecx
  form_type type; // eax
  unsigned int method; // eax
  unsigned int v12; // eax
  const char *action; // edi
  char *v14; // eax
  const unsigned __int8 *v15; // esi
  list_head_elinks *v16; // esi
  unsigned __int8 *v17; // edi
  int v18; // eax
  const char *v19; // edi
  int v20; // eax
  unsigned int prev; // eax
  char *v22; // edi
  int v23; // eax
  list_head_elinks *v24; // eax
  int v25; // edi
  list_head_elinks *v26; // edx
  list_head_elinks *v27; // ecx
  list_head_elinks *j; // edx
  void *v29; // esi
  void **p_next; // ecx
  submitted_value *inited; // eax
  submitted_value *next; // edx
  unsigned __int8 *v33; // edx
  submitted_value *v34; // eax
  void *v35; // edx
  unsigned __int8 *v36; // eax
  submitted_value *v37; // eax
  void *v38; // edx
  form_method v39; // eax
  int v40; // esi
  unsigned int v41; // eax
  unsigned __int8 *v42; // edx
  int v43; // eax
  unsigned __int8 *v44; // edx
  unsigned __int8 *v45; // edx
  unsigned int v46; // eax
  char *v47; // esi
  unsigned __int8 *v48; // eax
  unsigned __int8 v49; // al
  unsigned __int8 *v50; // esi
  int length; // edi
  unsigned int v52; // eax
  size_t v53; // ecx
  unsigned __int8 *v54; // eax
  int v55; // eax
  int v56; // edi
  unsigned __int8 v57; // cl
  unsigned __int8 v58; // al
  unsigned __int8 v59; // al
  unsigned __int8 v60; // cl
  unsigned __int8 *v61; // eax
  unsigned __int8 *v62; // eax
  unsigned __int8 *v63; // eax
  conv_table *translation_table; // eax
  unsigned __int8 *v65; // [esp+0h] [ebp-B8h]
  unsigned __int8 *v66; // [esp+0h] [ebp-B8h]
  int v67; // [esp+8h] [ebp-B0h]
  form_state *v68; // [esp+2Ch] [ebp-8Ch]
  size_t v69; // [esp+2Ch] [ebp-8Ch]
  unsigned __int8 *chars; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsf; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsa; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsg; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsb; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsi; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsc; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsd; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsj; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsk; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsl; // [esp+30h] [ebp-88h]
  unsigned __int8 *charse; // [esp+30h] [ebp-88h]
  unsigned __int8 *charsh; // [esp+30h] [ebp-88h]
  conv_table *convert_table; // [esp+34h] [ebp-84h]
  int v84; // [esp+38h] [ebp-80h]
  unsigned __int8 *cp_from; // [esp+40h] [ebp-78h]
  int cp_froma; // [esp+40h] [ebp-78h]
  list_head_elinks *cp_fromb; // [esp+40h] [ebp-78h]
  form *form; // [esp+44h] [ebp-74h]
  int cp_to; // [esp+48h] [ebp-70h]
  int cp_toa; // [esp+48h] [ebp-70h]
  char *cp_tob; // [esp+48h] [ebp-70h]
  conv_table *v92; // [esp+4Ch] [ebp-6Ch]
  document_view *v93; // [esp+4Ch] [ebp-6Ch]
  string go; // [esp+58h] [ebp-60h] BYREF
  string data; // [esp+60h] [ebp-58h] BYREF
  list_head_elinks submit; // [esp+68h] [ebp-50h] BYREF
  unsigned __int8 p[3]; // [esp+71h] [ebp-47h] BYREF
  boundary_info boundary; // [esp+74h] [ebp-44h] BYREF
  unsigned int v99; // [esp+9Ch] [ebp-1Ch]

  v99 = __readgsdword(0x14u);
  submit.next = &submit;
  submit.prev = &submit;
  if ( assert_failed )
    goto LABEL_2;
  if ( ses && (tab = ses->tab) != 0 && tab->term )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 1233;
    elinks_internal("assertion ses && ses->tab && ses->tab->term failed!");
    if ( assert_failed )
      goto LABEL_2;
  }
  if ( doc_view && fc && doc_view->document && fc->form )
  {
    assert_failed = 0;
    v5 = fc->form;
    form = v5;
    if ( fc->type == FC_RESET )
      goto LABEL_17;
    goto LABEL_13;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
  errline = 1235;
  elinks_internal("assertion doc_view && doc_view->document && fc && fc->form failed!");
  if ( assert_failed )
  {
LABEL_2:
    assert_failed = 0;
    return 0;
  }
  v5 = fc->form;
  form = v5;
  if ( fc->type == FC_RESET )
  {
LABEL_17:
    do_reset_form(doc_view, v5);
    return 0;
  }
LABEL_13:
  if ( !form->action || !init_string(&data) )
    return 0;
  if ( assert_failed )
    goto LABEL_37;
  if ( !doc_view || !fc->form )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
    errline = 778;
    elinks_internal("assertion doc_view && fc && fc->form && list failed!");
    if ( !assert_failed )
      goto LABEL_23;
LABEL_37:
    assert_failed = 0;
    goto LABEL_38;
  }
  assert_failed = 0;
LABEL_23:
  v6 = fc->form;
  for ( i = (form_control *)v6->items.next; i != (form_control *)&v6->items; i = i->next )
  {
    if ( fc == i || (unsigned int)(i->type - 7) > 3 )
    {
      name = i->name;
      if ( name )
      {
        if ( *name )
        {
          form_state = find_form_state(doc_view, i);
          if ( form_state )
          {
            if ( !assert_failed )
              assert_failed = 0;
            cp_from = i->name;
            cp_to = i->position;
            type = i->type;
            switch ( type )
            {
              case FC_TEXT:
              case FC_PASSWORD:
              case FC_FILE:
              case FC_TEXTAREA:
              case FC_SUBMIT:
              case FC_RESET:
              case FC_BUTTON:
              case FC_HIDDEN:
                goto LABEL_83;
              case FC_CHECKBOX:
              case FC_RADIO:
                if ( !form_state->state )
                  goto LABEL_91;
LABEL_83:
                inited = init_submitted_value(cp_from, form_state->value, type, i, cp_to);
                if ( inited )
                  goto LABEL_84;
                goto LABEL_91;
              case FC_SELECT:
                if ( !i->nvalues )
                  goto LABEL_91;
                v68 = form_state;
                fixup_select_state(i, form_state);
                inited = init_submitted_value(cp_from, v68->value, FC_SELECT, i, cp_to);
                if ( !inited )
                  goto LABEL_91;
LABEL_84:
                next = (submitted_value *)submit.next;
                inited->prev = (submitted_value *)&submit;
                inited->next = next;
                submit.next = inited;
                inited->next->prev = inited;
                v6 = fc->form;
                break;
              case FC_IMAGE:
                v33 = straconcat(cp_from, ".x", 0);
                if ( v33 )
                {
                  charsf = v33;
                  v34 = init_submitted_value(v33, (unsigned __int8 *)"0", FC_IMAGE, i, cp_to);
                  v65 = charsf;
                  charsa = (unsigned __int8 *)v34;
                  mem_free(v65);
                  if ( charsa )
                  {
                    v35 = submit.next;
                    *((_DWORD *)charsa + 1) = &submit;
                    *(_DWORD *)charsa = v35;
                    submit.next = charsa;
                    *(_DWORD *)(*(_DWORD *)charsa + 4) = charsa;
                  }
                  v36 = straconcat(i->name, ".y", 0);
                  if ( v36 )
                  {
                    charsg = v36;
                    v37 = init_submitted_value(v36, (unsigned __int8 *)"0", FC_IMAGE, i, cp_to);
                    v66 = charsg;
                    charsb = (unsigned __int8 *)v37;
                    mem_free(v66);
                    if ( charsb )
                    {
                      v38 = submit.next;
                      *((_DWORD *)charsb + 1) = &submit;
                      *(_DWORD *)charsb = v38;
                      submit.next = charsb;
                      *(_DWORD *)(*(_DWORD *)charsb + 4) = charsb;
                    }
                  }
                }
                goto LABEL_91;
              default:
                goto LABEL_91;
            }
          }
          else
          {
LABEL_91:
            v6 = fc->form;
          }
        }
      }
    }
  }
  do
  {
    v24 = (list_head_elinks *)submit.next;
    v25 = 0;
    while ( v24 != &submit )
    {
      while ( 1 )
      {
        v26 = (list_head_elinks *)v24->next;
        if ( &submit == v24->next || (int)v26[3].next >= (int)v24[3].next )
          break;
        v25 = 1;
        v26->prev = v24->prev;
        *(_DWORD *)v24->prev = v24->next;
        v27 = (list_head_elinks *)v26->next;
        v24->prev = v26;
        v24->next = v27;
        v26->next = v24;
        *((_DWORD *)v24->next + 1) = v24;
        v24 = (list_head_elinks *)v26->next;
        if ( v26->next == &submit )
          goto LABEL_75;
      }
      v24 = (list_head_elinks *)v24->next;
    }
LABEL_75:
    for ( j = (list_head_elinks *)submit.prev; j != v24; j = (list_head_elinks *)p_next[1] )
    {
      p_next = (void **)j->next;
      if ( &submit == j->next || (int)p_next[6] >= (int)j[3].next )
      {
        p_next = &j->next;
      }
      else
      {
        p_next[1] = j->prev;
        *(_DWORD *)j->prev = j->next;
        v29 = *p_next;
        v25 = 1;
        j->prev = p_next;
        j->next = v29;
        *p_next = j;
        *((_DWORD *)j->next + 1) = j;
      }
    }
  }
  while ( v25 );
LABEL_38:
  cp_froma = get_terminal_codepage(ses->tab->term);
  cp_toa = doc_view->document->cp;
  method = form->method;
  if ( method == 2 )
  {
    encode_multipart(ses, &submit, &data, &boundary, cp_froma, cp_toa);
    goto LABEL_41;
  }
  if ( method < 2 )
  {
    if ( assert_failed )
      goto LABEL_109;
    v16 = (list_head_elinks *)submit.next;
    assert_failed = 0;
    v92 = 0;
    if ( &submit == submit.next )
      goto LABEL_41;
    while ( 1 )
    {
      v19 = (const char *)v16[1].next;
      v20 = strlen(v19);
      encode_uri_string(&data, (const unsigned __int8 *)v19, v20, 1);
      add_char_to_string(&data, 0x3Du);
      prev = (unsigned int)v16[2].prev;
      if ( prev == 3 )
      {
        v42 = encode_textarea((submitted_value *)v16);
        if ( !v42 )
          goto LABEL_62;
        if ( !v92 )
        {
          charsh = v42;
          translation_table = get_translation_table(cp_froma, cp_toa);
          v42 = charsh;
          v92 = translation_table;
        }
        charsi = v42;
        v43 = strlen((const char *)v42);
        v17 = convert_string_elinks(v92, charsi, v43, -1, CSM_FORM, 0, 0, 0);
        mem_free(charsi);
      }
      else if ( prev > 1 )
      {
        if ( prev == 11 )
          v17 = encode_crlf((submitted_value *)v16);
        else
          v17 = stracpy((const unsigned __int8 *)v16[1].prev);
      }
      else
      {
        if ( !v92 )
          v92 = get_translation_table(cp_froma, cp_toa);
        v22 = (char *)v16[1].prev;
        v23 = strlen(v22);
        v17 = convert_string_elinks(v92, (unsigned __int8 *)v22, v23, -1, CSM_FORM, 0, 0, 0);
      }
      if ( v17 )
      {
        v18 = strlen((const char *)v17);
        encode_uri_string(&data, v17, v18, 1);
        mem_free(v17);
      }
LABEL_62:
      v16 = (list_head_elinks *)v16->next;
      if ( &submit == v16 )
        goto LABEL_41;
      add_char_to_string(&data, 0x26u);
    }
  }
  if ( method == 3 )
  {
    convert_table = get_translation_table(cp_froma, cp_toa);
    if ( !assert_failed )
    {
      v44 = p;
      assert_failed = 0;
      cp_fromb = (list_head_elinks *)submit.next;
      if ( submit.next == &submit )
        goto LABEL_41;
      while ( 1 )
      {
        cp_tob = (char *)cp_fromb[1].prev;
        charsc = v44;
        add_to_string(&data, (const unsigned __int8 *)cp_fromb[1].next);
        add_char_to_string(&data, 0x3Du);
        v45 = charsc;
        v46 = (unsigned int)cp_fromb[2].prev;
        if ( v46 == 3 )
        {
          v62 = encode_textarea((submitted_value *)cp_fromb);
          v45 = charsc;
          cp_tob = (char *)v62;
          if ( !v62 )
            goto LABEL_134;
        }
        else
        {
          if ( v46 <= 3 )
          {
            if ( v46 > 1 )
              goto LABEL_118;
            v47 = 0;
            goto LABEL_116;
          }
          if ( v46 != 11 )
            goto LABEL_118;
          v61 = encode_crlf((submitted_value *)cp_fromb);
          v45 = charsc;
          cp_tob = (char *)v61;
          if ( !v61 )
            goto LABEL_134;
        }
        v47 = cp_tob;
LABEL_116:
        charsd = v45;
        v67 = strlen(cp_tob);
        v48 = convert_string_elinks(convert_table, (unsigned __int8 *)cp_tob, v67, -1, CSM_FORM, 0, 0, 0);
        v45 = charsd;
        cp_tob = (char *)v48;
        if ( v47 )
        {
          mem_free(v47);
          v45 = charsd;
        }
LABEL_118:
        if ( cp_tob )
        {
          v49 = *cp_tob;
          if ( *cp_tob )
          {
            v50 = (unsigned __int8 *)cp_tob;
            while ( v49 == 13 || v49 == 10 )
            {
              p[0] = 37;
              v55 = *v50 >> 4;
              v56 = (unsigned __int8)v55;
              v57 = v55 + 87;
              v58 = v55 + 48;
              if ( v56 < 10 )
                v57 = v58;
              p[1] = v57;
              v59 = *v50 & 0xF;
              v60 = v59 + 87;
              if ( v59 < 0xAu )
                v60 = v59 + 48;
              p[2] = v60;
              if ( assert_failed )
              {
                ++v50;
                assert_failed = 0;
                v49 = *v50;
                if ( !*v50 )
                  goto LABEL_132;
              }
              else
              {
                length = data.length;
                assert_failed = 0;
                v84 = data.length + 3;
                v53 = data.length + 259;
                v52 = data.length + 255;
                LOBYTE(v53) = 0;
                LOBYTE(v52) = 0;
                v93 = (document_view *)v52;
                if ( v53 <= v52 )
                  goto LABEL_122;
                charse = v45;
                v69 = v53;
                v63 = (unsigned __int8 *)mem_realloc(data.source, v53);
                v45 = charse;
                if ( v63 )
                {
                  data.source = v63;
                  memset(&v63[(_DWORD)v93], 0, v69 - (_DWORD)v93);
                  v45 = charse;
LABEL_122:
                  if ( data.source )
                  {
                    v54 = &data.source[data.length];
                    *(_WORD *)v54 = *(_WORD *)v45;
                    v54[2] = v45[2];
                    data.source[length + 3] = 0;
                    data.length = v84;
                  }
                }
LABEL_124:
                v49 = *++v50;
                if ( !*v50 )
                  goto LABEL_132;
              }
            }
            charsl = v45;
            add_char_to_string(&data, v49);
            v45 = charsl;
            goto LABEL_124;
          }
LABEL_132:
          if ( cp_tob != cp_fromb[1].prev )
          {
            charsj = v45;
            mem_free(cp_tob);
            v45 = charsj;
          }
        }
LABEL_134:
        charsk = v45;
        add_crlf_to_string(&data);
        v44 = charsk;
        cp_fromb = (list_head_elinks *)cp_fromb->next;
        if ( cp_fromb == &submit )
          goto LABEL_41;
      }
    }
LABEL_109:
    assert_failed = 0;
  }
LABEL_41:
  if ( data.source && get_opt_(config_options, "document.browse.forms.show_formhist")->number )
    memorize_form(ses, &submit, form);
  done_submitted_value_list(&submit);
  if ( !data.source || !init_string(&go) )
  {
    done_string(&data);
    return 0;
  }
  v12 = form->method;
  if ( !v12 )
  {
    action = (const char *)form->action;
    v14 = strchr(action, 35);
    v15 = (const unsigned __int8 *)v14;
    if ( v14 )
      add_bytes_to_string___7(&go, (const unsigned __int8 *)action, v14 - action);
    else
      add_to_string(&go, (const unsigned __int8 *)action);
    if ( strchr((const char *)go.source, 63) )
      add_char_to_string(&go, 0x26u);
    else
      add_char_to_string(&go, 0x3Fu);
    add_string_to_string(&go, &data);
    if ( v15 )
      add_to_string(&go, v15);
    goto LABEL_53;
  }
  if ( v12 <= 3 )
  {
    add_to_string(&go, form->action);
    add_char_to_string(&go, 1u);
    v39 = form->method;
    if ( v39 == FORM_METHOD_POST )
    {
      add_to_string(&go, "application/x-www-form-urlencoded\n");
LABEL_100:
      if ( data.length > 0 )
      {
        v40 = 0;
        do
        {
          v41 = data.source[v40++];
          elinks_ulongcat(p, 0, v41, 2u, 0x30u, 0x10u, 0);
          add_to_string(&go, p);
        }
        while ( data.length > v40 );
      }
      goto LABEL_53;
    }
    if ( v39 != FORM_METHOD_POST_TEXT_PLAIN )
    {
      add_to_string(&go, "multipart/form-data; boundary=");
      add_bytes_to_string___7(&go, boundary.string, 32);
      add_char_to_string(&go, 0xAu);
      goto LABEL_100;
    }
    add_to_string(&go, "text/plain\n");
    add_to_string(&go, data.source);
  }
LABEL_53:
  done_string(&data);
  chars = (unsigned __int8 *)get_uri(go.source, (uri_component)0);
  done_string(&go);
  result = (uri *)chars;
  if ( chars )
    chars[54] |= 2u;
  return result;
}

//----- (080F46A0) --------------------------------------------------------
void __cdecl submit_given_form(session *ses, document_view *doc_view, form *form, int do_reload)
{
  form *next; // eax
  uri *form_uri; // eax
  uri *v6; // [esp+1Ch] [ebp-1Ch]

  next = (form *)form->items.next;
  if ( next != (form *)&form->items && next )
  {
    form_uri = get_form_uri(ses, doc_view, (form_control *)form->items.next);
    if ( form_uri )
    {
      v6 = form_uri;
      goto_uri_frame(
        ses,
        form_uri,
        form->target,
        (cache_mode)(do_reload == 0 ? CACHE_MODE_NORMAL : CACHE_MODE_FORCE_RELOAD));
      done_uri(v6);
    }
  }
}

//----- (080F4730) --------------------------------------------------------
void __cdecl auto_submit_form(session *ses)
{
  document_view *doc_view; // ecx
  document *document; // eax
  form *next; // ebx

  doc_view = ses->doc_view;
  document = doc_view->document;
  next = (form *)document->forms.next;
  if ( next != (form *)&document->forms )
    submit_given_form(ses, doc_view, next, 0);
}

//----- (080F4770) --------------------------------------------------------
unsigned __int8 *__cdecl get_form_info(session *ses, document_view *doc_view)
{
  int current_link; // ebx
  document *document; // eax
  term_event_key_T *v4; // ebx
  term_event_key_T v5; // edi
  const char *form_label; // edx
  string *inited; // eax
  unsigned __int8 *v9; // edx
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  _BYTE *v12; // eax
  int v13; // eax
  int v14; // ecx
  form *v15; // eax
  uri *uri; // eax
  uri *v17; // esi
  unsigned __int8 *v18; // esi
  int v19; // eax
  unsigned __int8 *v20; // edi
  const unsigned __int8 *v21; // eax
  int v22; // edx
  term_event_key_T v23; // eax
  unsigned __int8 *value; // eax
  unsigned __int8 *keystroke; // esi
  const char *v26; // ecx
  const unsigned __int8 *v27; // eax
  unsigned __int8 *msg; // [esp+10h] [ebp-38h]
  unsigned __int8 *msga; // [esp+10h] [ebp-38h]
  unsigned __int8 *msgid; // [esp+14h] [ebp-34h]
  terminal *term; // [esp+18h] [ebp-30h]
  unsigned __int8 *uristring; // [esp+1Ch] [ebp-2Ch]
  term_event_keyboard kbd; // [esp+20h] [ebp-28h] BYREF
  string str; // [esp+28h] [ebp-20h] BYREF

  term = ses->tab->term;
  if ( doc_view
    && (current_link = doc_view->vs->current_link, current_link >= 0)
    && (document = doc_view->document, current_link < document->nlinks) )
  {
    v4 = (term_event_key_T *)&document->links[current_link];
  }
  else
  {
    v4 = 0;
  }
  if ( !assert_failed )
  {
    assert_failed = v4 == 0;
    if ( !v4 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
      errline = 1928;
      elinks_internal("assertion link failed!");
    }
  }
  v5 = 0;
  if ( (unsigned int)v4[1] > 1 )
    v5 = v4[12];
  form_label = get_form_label((form_control *)v5);
  if ( !form_label )
    return 0;
  msgid = (unsigned __int8 *)form_label;
  inited = init_string(&str);
  v9 = msgid;
  if ( !inited )
    return 0;
  if ( *msgid )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v9 = msgid;
      if ( terminal_codepage != current_charset )
      {
        msg = (unsigned __int8 *)terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        v9 = msgid;
        current_charset = (int)msg;
      }
    }
    v9 = gettext(v9);
  }
  add_to_string(&str, v9);
  if ( v4[1] != 2 )
  {
    v12 = *(_BYTE **)(v5 + 32);
    if ( v12 )
    {
      if ( *v12 )
        add_form_attr_to_string(&str, term, (unsigned __int8 *)"name", *(unsigned __int8 **)(v5 + 32));
    }
  }
  if ( *(_DWORD *)(v5 + 20) <= 8u )
  {
    v13 = 1 << *(_DWORD *)(v5 + 20);
    if ( (v13 & 0x180) != 0 )
    {
      add_char_to_string(&str, 0x20u);
      if ( !assert_failed )
      {
        v22 = *(_DWORD *)(v5 + 8);
        assert_failed = v22 == 0;
        if ( !v22 )
        {
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
          errline = 2029;
          elinks_internal("assertion fc->form failed!");
        }
      }
      add_string_uri_to_string(&str, *(unsigned __int8 **)(*(_DWORD *)(v5 + 8) + 16), URI_PUBLIC);
    }
    else if ( (v13 & 0x30) != 0 )
    {
      value = find_form_state(doc_view, (form_control *)v5)->value;
      if ( value && *value )
        add_form_attr_to_string(&str, term, "value", value);
    }
    else if ( (v13 & 0xF) != 0 )
    {
      if ( *(_DWORD *)(v5 + 24) )
        add_form_attr_to_string(&str, term, "read only", 0);
      if ( ses->insert_mode == INSERT_MODE_OFF )
      {
        keystroke = get_keystroke(14, KEYMAP_EDIT);
        if ( keystroke )
        {
          v26 = "press %s to navigate";
          if ( !*(_DWORD *)(v5 + 24) )
            v26 = "press %s to edit";
          msga = (unsigned __int8 *)v26;
          add_to_string(&str, " (");
          v27 = _7(msga, term);
          add_format_to_string(&str, v27, keystroke);
          add_char_to_string(&str, 0x29u);
          mem_free(keystroke);
        }
      }
      else if ( *(_DWORD *)(v5 + 20) != 3 )
      {
        if ( !assert_failed )
        {
          v14 = *(_DWORD *)(v5 + 8);
          assert_failed = v14 == 0;
          if ( !v14 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/form.c";
            errline = 1990;
            elinks_internal("assertion fc->form failed!");
          }
        }
        v15 = *(form **)(v5 + 8);
        if ( v15->action
          && (!has_form_submit(v15) || get_opt_(config_options, "document.browse.forms.auto_submit")->number) )
        {
          uri = get_uri(*(unsigned __int8 **)(*(_DWORD *)(v5 + 8) + 16), (uri_component)0);
          v17 = uri;
          if ( uri )
          {
            uristring = get_uri_string(uri, URI_PUBLIC);
            done_uri(v17);
            if ( uristring )
            {
              v18 = get_keystroke(14, KEYMAP_EDIT);
              if ( v18 )
              {
                v19 = *(_DWORD *)(v5 + 8);
                v20 = "press %s to submit to %s";
                if ( *(_DWORD *)(v19 + 32) )
                  v20 = "press %s to post to %s";
                add_to_string(&str, " (");
                v21 = _7(v20, term);
                add_format_to_string(&str, v21, v18, uristring);
                mem_free(uristring);
                mem_free(v18);
                add_char_to_string(&str, 0x29u);
              }
              else
              {
                mem_free(uristring);
              }
            }
          }
        }
      }
    }
  }
  if ( *v4 )
  {
    if ( get_opt_(config_options, "document.browse.accesskey.display")->number )
    {
      add_to_string(&str, " (");
      v23 = *v4;
      kbd.modifier = KBD_MOD_ALT;
      kbd.key = v23;
      add_keystroke_to_string(&str, &kbd, 0);
      add_char_to_string(&str, 0x29u);
    }
  }
  return str.source;
}

//----- (080F4C70) --------------------------------------------------------
void __cdecl get_link_x_bounds(link *link, int y, int *min_x, int *max_x)
{
  int v4; // eax
  int v5; // edx
  int x; // esi
  int v7; // esi

  if ( min_x )
    *min_x = 0x7FFFFFFF;
  if ( max_x )
    *max_x = 0;
  if ( link->npoints > 0 )
  {
    v4 = 0;
    v5 = 0;
    do
    {
      while ( 1 )
      {
        if ( y < 0 || link->points[v4].y == y )
        {
          if ( min_x )
          {
            x = link->points[v4].x;
            if ( x < *min_x )
              *min_x = x;
          }
          if ( max_x )
          {
            v7 = link->points[v4].x;
            if ( v7 > *max_x )
              break;
          }
        }
        ++v5;
        ++v4;
        if ( link->npoints <= v5 )
          return;
      }
      *max_x = v7;
      ++v5;
      ++v4;
    }
    while ( link->npoints > v5 );
  }
}

//----- (080F4D10) --------------------------------------------------------
link *__cdecl get_link_at_coordinates(document_view *doc_view, int x, int y)
{
  document *document; // eax
  int nlinks; // ecx
  link *result; // eax
  int height; // esi
  unsigned int links; // edx
  int v8; // ecx
  int v9; // edi
  int v10; // esi
  int v11; // esi
  link *v12; // edi
  link *v13; // edi
  point *points; // esi
  int v15; // ecx
  int v16; // [esp+1Ch] [ebp-2Ch]
  view_state *vs; // [esp+20h] [ebp-28h]
  int i; // [esp+24h] [ebp-24h]
  link *l1; // [esp+28h] [ebp-20h]
  int v20; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_9;
  if ( doc_view && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_6;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 1103;
  elinks_internal("assertion doc_view && doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_9:
    assert_failed = 0;
    return 0;
  }
LABEL_6:
  document = doc_view->document;
  nlinks = document->nlinks;
  if ( nlinks )
  {
    if ( x >= 0 && x < doc_view->box.width && y >= 0 )
    {
      height = doc_view->box.height;
      if ( y < height )
      {
        links = (unsigned int)document->links;
        l1 = (link *)(links + 52 * nlinks);
        vs = doc_view->vs;
        v8 = vs->y;
        v9 = document->height;
        v10 = v8 + height;
        if ( v10 <= v9 )
          v9 = v10;
        v16 = v9;
        v11 = v8;
        for ( i = vs->y; i < v16; ++i )
        {
          v12 = document->lines1[v11];
          if ( v12 )
          {
            if ( l1 <= v12 )
              v12 = l1;
            l1 = v12;
          }
          v13 = document->lines2[v11];
          if ( v13 && links < (unsigned int)v13 )
            links = (unsigned int)document->lines2[v11];
          ++v11;
        }
        result = l1;
        v20 = y + v8;
        while ( (unsigned int)result <= links )
        {
          if ( result->npoints > 0 )
          {
            points = result->points;
            v15 = 0;
            while ( points[v15].x != vs->x + x || points[v15].y != v20 )
            {
              if ( result->npoints <= ++v15 )
                goto LABEL_34;
            }
            return result;
          }
LABEL_34:
          ++result;
        }
      }
    }
  }
  return 0;
}

//----- (080F4E90) --------------------------------------------------------
void __cdecl set_pos_y(document_view *doc_view, link *link)
{
  int v2; // ecx
  int height; // ebx
  point *points; // edi
  int v5; // eax
  int y; // edx
  view_state *vs; // edx
  int v8; // eax
  int v9; // ecx

  if ( assert_failed )
    goto LABEL_17;
  if ( doc_view && doc_view->document && link && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_7;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 768;
  elinks_internal("assertion doc_view && doc_view->document && doc_view->vs && link failed!");
  if ( assert_failed )
  {
LABEL_17:
    assert_failed = 0;
    return;
  }
LABEL_7:
  v2 = 0;
  height = doc_view->document->height;
  if ( link->npoints > 0 )
  {
    points = link->points;
    v5 = 0;
    do
    {
      y = points[v5].y;
      if ( v2 < y + 1 )
        v2 = y + 1;
      if ( height > y )
        height = points[v5].y;
      ++v5;
    }
    while ( v5 != link->npoints );
  }
  doc_view->vs->y = (height + v2 - doc_view->box.height) / 2;
  vs = doc_view->vs;
  v8 = vs->y;
  if ( v8 < 0 )
  {
    vs->y = 0;
  }
  else
  {
    v9 = doc_view->document->height - doc_view->box.height;
    if ( v9 < v8 )
      vs->y = v9;
  }
}

//----- (080F4FC0) --------------------------------------------------------
void __cdecl set_pos_x(document_view *doc_view, link *link)
{
  int v2; // esi
  point *points; // ebx
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int x; // edx
  int v8; // esi
  int v9; // eax
  view_state *vs; // [esp+20h] [ebp-28h]
  int npoints; // [esp+28h] [ebp-20h]
  int y; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = doc_view == 0 || link == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c",
        errline = 745,
        elinks_internal("assertion doc_view && link failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    npoints = link->npoints;
    if ( npoints > 0 )
    {
      v2 = 0;
      points = link->points;
      vs = doc_view->vs;
      v4 = 0x7FFFFFFF;
      y = vs->y;
      v5 = 0;
      v6 = points->y - y;
      if ( v6 >= 0 )
        goto LABEL_5;
LABEL_11:
      while ( 1 )
      {
        ++v5;
        x = v4;
        if ( v5 == npoints )
          break;
        while ( 1 )
        {
          v4 = x;
          v6 = points[v5].y - y;
          if ( v6 < 0 )
            break;
LABEL_5:
          if ( v6 >= doc_view->box.height )
            goto LABEL_11;
          x = points[v5].x;
          if ( v2 < x + 1 )
            v2 = x + 1;
          if ( x >= v4 )
            goto LABEL_11;
          if ( ++v5 == npoints )
            goto LABEL_12;
        }
      }
LABEL_12:
      if ( x != 0x7FFFFFFF )
      {
        v8 = v2 - doc_view->box.width;
        v9 = vs->x;
        if ( v8 > v9 )
        {
          vs->x = v8;
        }
        else if ( x < v9 )
        {
          vs->x = x;
        }
      }
    }
  }
}

//----- (080F50E0) --------------------------------------------------------
int __cdecl next_link_in_dir(document_view *doc_view, int dir_x, int dir_y)
{
  document *v3; // ecx
  int current_link; // eax
  int result; // eax
  link *v6; // ebx
  point *points; // eax
  link *y; // ecx
  int v9; // ebx
  int v10; // ecx
  int v11; // edi
  int v12; // eax
  int height; // edx
  int v14; // eax
  bool k; // al
  link *v16; // esi
  link **lines2; // edx
  point *v18; // eax
  int v19; // eax
  int i; // ecx
  int npoints; // ebx
  point *v22; // edx
  int v23; // eax
  int v24; // edi
  int v25; // edx
  point *v26; // ebx
  int v27; // eax
  int x; // esi
  int v29; // [esp+14h] [ebp-54h]
  link *v30; // [esp+18h] [ebp-50h]
  link **v31; // [esp+1Ch] [ebp-4Ch]
  view_state *vs; // [esp+20h] [ebp-48h]
  link *j; // [esp+28h] [ebp-40h]
  document *document; // [esp+2Ch] [ebp-3Ch]
  int v35; // [esp+30h] [ebp-38h]
  int last; // [esp+34h] [ebp-34h]
  int max_y; // [esp+38h] [ebp-30h]
  int max_ya; // [esp+38h] [ebp-30h]
  link *backup; // [esp+3Ch] [ebp-2Ch]
  link *backupa; // [esp+3Ch] [ebp-2Ch]
  int l_max_x; // [esp+40h] [ebp-28h] BYREF
  int l_min_x; // [esp+44h] [ebp-24h] BYREF
  int max_x; // [esp+48h] [ebp-20h] BYREF
  int min_x[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_10;
  min_x[0] = 0x7FFFFFFF;
  max_x = 0;
  if ( !doc_view || !doc_view->document || !doc_view->vs )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 609;
    elinks_internal("assertion doc_view && doc_view->document && doc_view->vs failed!");
    if ( assert_failed )
      goto LABEL_10;
  }
  assert_failed = __PAIR64__(dir_y, dir_x) == 0;
  if ( !__PAIR64__(dir_y, dir_x) )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 611;
    elinks_internal("assertion dir_x || dir_y failed!");
    if ( assert_failed )
    {
LABEL_10:
      assert_failed = 0;
      return 0;
    }
  }
  v3 = doc_view->document;
  document = v3;
  vs = doc_view->vs;
  current_link = vs->current_link;
  if ( current_link < 0 )
    return 0;
  if ( current_link >= v3->nlinks )
    return 0;
  v6 = &v3->links[current_link];
  if ( !v6 )
    return 0;
  get_link_x_bounds(v6, -1, min_x, &max_x);
  points = v6->points;
  y = (link *)points->y;
  backup = y;
  max_y = points[v6->npoints - 1].y;
  if ( !dir_y )
  {
    if ( dir_x <= 0 )
      v19 = min_x[0];
    else
      v19 = max_x;
    last = 0;
    for ( i = v19 + 2 * dir_x; last < max_y + 1 - (int)backup && i >= 0; i += dir_x )
    {
      last = 0;
      if ( (int)backup <= max_y )
      {
        v29 = (int)backup;
        v31 = &document->lines1[(_DWORD)backup];
        v30 = backup;
        do
        {
          v16 = *v31;
          if ( *v31 )
          {
            for ( j = document->lines2[v29]; v16 <= j; ++v16 )
            {
              npoints = v16->npoints;
              if ( npoints > 0 )
              {
                v22 = v16->points;
                v23 = 0;
                while ( 1 )
                {
                  if ( v22[v23].x == i )
                  {
                    v24 = v22[v23].y;
                    if ( (int)backup <= v24 && max_y >= v24 )
                      break;
                  }
                  if ( ++v23 >= npoints )
                    goto LABEL_55;
                }
                if ( v24 != -1 )
                  goto chose_link;
              }
LABEL_55:
              ;
            }
            v25 = j->npoints;
            if ( v25 <= 0 )
              goto LABEL_67;
            v26 = j->points;
            v27 = 0;
            while ( 1 )
            {
              if ( v30 == (link *)v26[v27].y )
              {
                x = v26[v27].x;
                if ( x >= i )
                  break;
              }
              if ( v25 <= ++v27 )
                goto LABEL_67;
            }
            if ( x == -1 )
LABEL_67:
              ++last;
          }
          v30 = (link *)((char *)v30 + 1);
          ++v31;
          ++v29;
        }
        while ( max_y >= (int)v30 );
      }
    }
    return 0;
  }
  if ( dir_y > 0 )
    y = (link *)points[v6->npoints - 1].y;
  v9 = (int)y + dir_y;
  v10 = 0;
  v11 = v9;
  v12 = doc_view->vs->y;
  if ( v12 >= 0 )
    v10 = doc_view->vs->y;
  max_ya = v10;
  height = document->height;
  v14 = doc_view->box.height + v12;
  if ( v14 <= height )
    height = v14;
  v35 = height;
  if ( dir_y <= 0 )
    goto LABEL_33;
LABEL_20:
  for ( k = v9 < v35; ; k = v9 >= max_ya )
  {
    if ( !k )
    {
      if ( v9 && document->height != v9 )
      {
        result = 0;
        vs->current_link = -1;
        return result;
      }
      return 0;
    }
    v16 = document->lines1[v11];
    if ( v16 )
    {
      lines2 = document->lines2;
      if ( v16 <= lines2[v11] )
        break;
    }
LABEL_32:
    v9 += dir_y;
    v11 += dir_y;
    if ( dir_y > 0 )
      goto LABEL_20;
LABEL_33:
    ;
  }
  backupa = 0;
  while ( 2 )
  {
    while ( 2 )
    {
      v18 = v16->points;
      if ( v9 < v18->y || v9 > v18[v16->npoints - 1].y )
        goto LABEL_25;
      get_link_x_bounds(v16, v9, &l_min_x, &l_max_x);
      if ( l_min_x <= max_x )
      {
        if ( l_max_x >= min_x[0] )
          goto chose_link;
LABEL_35:
        backupa = v16;
        lines2 = document->lines2;
LABEL_25:
        if ( lines2[v11] < ++v16 )
          goto LABEL_31;
        continue;
      }
      break;
    }
    if ( !backupa )
      goto LABEL_35;
    ++v16;
    lines2 = document->lines2;
    if ( lines2[v11] >= v16 )
      continue;
    break;
  }
LABEL_31:
  if ( !backupa )
    goto LABEL_32;
  v16 = backupa;
chose_link:
  vs->current_link = -991146299 * (((char *)v16 - (char *)document->links) >> 2);
  set_pos_x(doc_view, v16);
  return 1;
}
// 80F50E0: using guessed type int min_x[7];

//----- (080F5500) --------------------------------------------------------
int __usercall next_link_in_view_@<eax>(
        document_view *doc_view@<eax>,
        int current@<edx>,
        int direction@<ecx>,
        int (*fn)(document_view *, link *),
        void (*cntr)(document_view *, link *))
{
  document *document; // edi
  int y; // edx
  int height; // ecx
  int v8; // eax
  int v9; // esi
  link **v10; // ebx
  link **v11; // ecx
  int v12; // edx
  int v13; // ebx
  int v14; // esi
  int result; // eax
  view_state *vs; // [esp+10h] [ebp-38h]
  int v18; // [esp+18h] [ebp-30h]
  int v20; // [esp+24h] [ebp-24h]
  document *v21; // [esp+24h] [ebp-24h]
  int start; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_29;
  if ( !doc_view || !doc_view->document || !fn || !doc_view->vs )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 508;
    elinks_internal("assertion doc_view && doc_view->document && doc_view->vs && fn failed!");
    if ( !assert_failed )
      goto LABEL_7;
LABEL_29:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_7:
  document = doc_view->document;
  vs = doc_view->vs;
  y = vs->y;
  height = document->height;
  if ( y + doc_view->box.height <= height )
    height = y + doc_view->box.height;
  v20 = height;
  start = document->nlinks - 1;
  v8 = 0;
  if ( y >= 0 )
    v8 = vs->y;
  v9 = 0;
  if ( v8 < height )
  {
    v10 = &document->lines1[v8];
    v11 = &document->lines2[v8];
    do
    {
      if ( *v10 )
      {
        v12 = -991146299 * (((char *)*v10 - (char *)document->links) >> 2);
        if ( start <= v12 )
          v12 = start;
        start = v12;
      }
      if ( *v11 && v9 < -991146299 * (((char *)*v11 - (char *)document->links) >> 2) )
        v9 = -991146299 * (((char *)*v11 - (char *)document->links) >> 2);
      ++v8;
      ++v10;
      ++v11;
    }
    while ( v20 > v8 );
  }
  if ( current < start || current > v9 )
  {
LABEL_31:
    result = 0;
    vs->current_link = -1;
  }
  else
  {
    v18 = v9;
    v21 = doc_view->document;
    v13 = current + direction;
    v14 = current;
    while ( !fn(doc_view, &v21->links[v14]) )
    {
      current += direction;
      if ( start <= v13 )
      {
        v13 += direction;
        v14 += direction;
        if ( v18 >= v13 - direction )
          continue;
      }
      goto LABEL_31;
    }
    result = 1;
    vs->current_link = current;
    if ( cntr )
    {
      cntr(doc_view, &v21->links[v14]);
      return 1;
    }
  }
  return result;
}

//----- (080F5700) --------------------------------------------------------
int __cdecl next_link_in_view_y(document_view *doc_view, int current, int direction)
{
  return next_link_in_view_(doc_view, current, direction, link_in_view_y, set_pos_x);
}

//----- (080F5730) --------------------------------------------------------
int __cdecl next_link_in_view(document_view *doc_view, int current, int direction)
{
  return next_link_in_view_(doc_view, current, direction, link_in_view, 0);
}

//----- (080F5760) --------------------------------------------------------
void __usercall find_link(document_view *doc_view@<eax>, int direction@<edx>, int page_mode@<ecx>)
{
  link **lines1; // ebx
  int v4; // edi
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  link **v8; // esi
  int v9; // edx
  link *v10; // ebx
  int y; // ecx
  int height; // esi
  int v13; // ebx
  int v14; // edx
  int v15; // edi
  link **v16; // esi
  document_view *v17; // [esp+14h] [ebp-34h]
  view_state *vs; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  document *document; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_23;
  if ( doc_view && doc_view->document && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_6;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 792;
  v17 = doc_view;
  elinks_internal("assertion doc_view && doc_view->document && doc_view->vs failed!");
  doc_view = v17;
  if ( assert_failed )
  {
LABEL_23:
    assert_failed = 0;
    return;
  }
LABEL_6:
  if ( direction == -1 )
  {
    document = doc_view->document;
    if ( document->lines2 )
    {
      vs = doc_view->vs;
      y = vs->y;
      height = document->height;
      v13 = y + doc_view->box.height;
      v14 = v13 - 1;
      if ( v13 - 1 > height - 1 )
        v14 = height - 1;
      if ( v14 < 0 )
        goto LABEL_27;
      v15 = 0;
      if ( y >= 0 )
        v15 = vs->y;
      if ( v13 <= height )
        height = y + doc_view->box.height;
      v10 = 0;
      v21 = height;
      v16 = &document->lines2[v14];
      do
      {
        --v14;
        if ( *v16 && (*v16 > v10 || !v10) )
          v10 = *v16;
        if ( v14 < v15 )
          break;
        --v16;
      }
      while ( v14 < v21 );
      goto LABEL_19;
    }
LABEL_26:
    vs = doc_view->vs;
    goto LABEL_27;
  }
  document = doc_view->document;
  lines1 = document->lines1;
  if ( !lines1 )
    goto LABEL_26;
  v4 = 0;
  vs = doc_view->vs;
  v5 = vs->y;
  v6 = document->height;
  if ( v5 >= 0 )
    v4 = vs->y;
  if ( v6 <= v4 )
    goto LABEL_27;
  v7 = doc_view->box.height + v5;
  v8 = &lines1[v4];
  if ( v7 <= v6 )
    v6 = v7;
  v9 = v4;
  v10 = 0;
  do
  {
    ++v9;
    if ( *v8 && (*v8 < v10 || !v10) )
      v10 = *v8;
    if ( v9 < v4 )
      break;
    ++v8;
  }
  while ( v9 < v6 );
LABEL_19:
  if ( !v10 )
  {
LABEL_27:
    vs->current_link = -1;
    return;
  }
  if ( page_mode )
  {
    next_link_in_view(doc_view, -991146299 * (((char *)v10 - (char *)document->links) >> 2), direction);
  }
  else
  {
    vs->current_link = -991146299 * (((char *)v10 - (char *)document->links) >> 2);
    set_pos_x(doc_view, v10);
  }
}

//----- (080F5980) --------------------------------------------------------
void __cdecl find_link_page_down(document_view *doc_view)
{
  find_link(doc_view, 1, 1);
}

//----- (080F59A0) --------------------------------------------------------
void __cdecl find_link_down(document_view *doc_view)
{
  find_link(doc_view, 1, 0);
}

//----- (080F59C0) --------------------------------------------------------
void __cdecl find_link_page_up(document_view *doc_view)
{
  find_link(doc_view, -1, 1);
}

//----- (080F59E0) --------------------------------------------------------
void __cdecl find_link_up(document_view *doc_view)
{
  find_link(doc_view, -1, 0);
}

//----- (080F5A00) --------------------------------------------------------
int __cdecl link_in_view_y(document_view *doc_view, link *link)
{
  int npoints; // ecx
  int height; // ebx
  int y; // esi
  point *points; // edi
  int v6; // eax
  int v7; // eax
  int v8; // edx

  if ( assert_failed
    || (assert_failed = doc_view == 0 || link == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c",
        errline = 439,
        elinks_internal("assertion doc_view && link failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  npoints = link->npoints;
  height = doc_view->box.height;
  y = doc_view->vs->y;
  if ( npoints <= 0 )
    return 0;
  points = link->points;
  v6 = points->y - y;
  if ( v6 >= height || v6 < 0 )
  {
    v7 = 0;
    while ( npoints > ++v7 )
    {
      v8 = points[v7].y - y;
      if ( v8 < height && v8 >= 0 )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (080F5AE0) --------------------------------------------------------
int __cdecl link_in_view(document_view *doc_view, link *link)
{
  int npoints; // ecx
  int width; // esi
  int x; // ebx
  point *points; // edi
  int v6; // eax
  int v7; // eax
  int v8; // edx

  if ( assert_failed )
    goto LABEL_13;
  assert_failed = link == 0 || doc_view == 0;
  if ( link == 0 || doc_view == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 458;
    elinks_internal("assertion doc_view && link failed!");
    if ( assert_failed )
      goto LABEL_13;
  }
  if ( !link_in_view_y(doc_view, link) )
    return 0;
  if ( assert_failed
    || (assert_failed = link == 0 || doc_view == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c",
        errline = 418,
        elinks_internal("assertion doc_view && link failed!"),
        assert_failed) )
  {
LABEL_13:
    assert_failed = 0;
    return 0;
  }
  npoints = link->npoints;
  width = doc_view->box.width;
  x = doc_view->vs->x;
  if ( npoints <= 0 )
    return 0;
  points = link->points;
  v6 = points->x - x;
  if ( width <= v6 || v6 < 0 )
  {
    v7 = 0;
    while ( ++v7 < npoints )
    {
      v8 = points[v7].x - x;
      if ( width > v8 && v8 >= 0 )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (080F5C30) --------------------------------------------------------
int __cdecl current_link_is_visible(document_view *doc_view)
{
  int current_link; // eax
  document *document; // edx
  link *v4; // eax

  if ( assert_failed )
    goto LABEL_8;
  if ( doc_view && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 468;
  elinks_internal("assertion doc_view && doc_view->vs failed!");
  if ( assert_failed )
  {
LABEL_8:
    assert_failed = 0;
    return 0;
  }
  if ( !doc_view )
    return 0;
LABEL_5:
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 )
    return 0;
  document = doc_view->document;
  if ( current_link >= document->nlinks )
    return 0;
  v4 = &document->links[current_link];
  if ( !v4 )
    return 0;
  return link_in_view(doc_view, v4) != 0;
}

//----- (080F5D00) --------------------------------------------------------
link *__cdecl get_last_link(document_view *doc_view)
{
  document *document; // ecx
  link **lines2; // edi
  int v3; // edx
  int y; // eax
  int height; // esi
  link **v6; // ecx
  link *result; // eax

  if ( assert_failed )
    goto LABEL_17;
  if ( !doc_view || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 395;
    elinks_internal("assertion doc_view && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_5;
LABEL_17:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_5:
  document = doc_view->document;
  lines2 = document->lines2;
  if ( !lines2 )
    return 0;
  v3 = 0;
  y = doc_view->vs->y;
  height = y + doc_view->box.height;
  if ( y >= 0 )
    v3 = doc_view->vs->y;
  if ( height > document->height )
    height = document->height;
  if ( v3 >= height )
    return 0;
  v6 = &lines2[v3];
  result = 0;
  do
  {
    if ( result < *v6 )
      result = *v6;
    ++v3;
    ++v6;
  }
  while ( v3 < height );
  return result;
}

//----- (080F5DE0) --------------------------------------------------------
link *__cdecl get_first_link(document_view *doc_view)
{
  document *document; // eax
  link **lines1; // ebx
  int y; // ecx
  int v4; // esi
  int nlinks; // edi
  int v6; // edx
  int height; // eax
  link *v8; // edi
  link **v9; // ebx
  link *result; // eax
  link *links; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_19;
  if ( !doc_view || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 366;
    elinks_internal("assertion doc_view && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_5;
LABEL_19:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_5:
  document = doc_view->document;
  lines1 = document->lines1;
  if ( !lines1 )
    return 0;
  y = doc_view->vs->y;
  v4 = y + doc_view->box.height;
  links = document->links;
  nlinks = document->nlinks;
  v6 = 0;
  height = document->height;
  if ( y >= 0 )
    v6 = doc_view->vs->y;
  if ( v4 > height )
    v4 = height;
  if ( v6 >= v4 )
    return 0;
  v8 = &links[nlinks];
  v9 = &lines1[v6];
  result = v8;
  do
  {
    if ( *v9 )
    {
      if ( result > *v9 )
        result = *v9;
    }
    ++v6;
    ++v9;
  }
  while ( v6 < v4 );
  if ( result == v8 )
    return 0;
  return result;
}

//----- (080F5ED0) --------------------------------------------------------
void __cdecl set_link(document_view *doc_view)
{
  if ( assert_failed
    || (assert_failed = doc_view == 0, !doc_view)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c",
        errline = 104,
        elinks_internal("assertion doc_view failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( !current_link_is_visible(doc_view) )
  {
    find_link_page_down(doc_view);
  }
}

//----- (080F5F60) --------------------------------------------------------
unsigned __int8 *__usercall _8@<eax>(unsigned __int8 *msg@<eax>, terminal *term@<edx>)
{
  unsigned __int8 *v2; // ebx
  int terminal_codepage; // eax
  int v4; // esi
  unsigned __int8 *cp_mime_name; // eax

  v2 = msg;
  if ( msg && *msg )
  {
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      v4 = terminal_codepage;
      if ( terminal_codepage != current_charset )
      {
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v4;
      }
    }
    return gettext(v2);
  }
  return v2;
}

//----- (080F5FD0) --------------------------------------------------------
unsigned __int8 *__cdecl get_current_link_info(session *ses, document_view *doc_view)
{
  document *document; // eax
  int current_link; // edx
  term_event_key_T *v5; // ebx
  terminal *term; // edi
  term_event_key_T v7; // eax
  const unsigned __int8 *v8; // eax
  const unsigned __int8 *v9; // eax
  unsigned __int8 *uristring; // [esp+1Ch] [ebp-2Ch]
  term_event_keyboard kbd; // [esp+20h] [ebp-28h] BYREF
  string str; // [esp+28h] [ebp-20h] BYREF

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->document && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 1440;
  elinks_internal("assertion ses && doc_view && doc_view->document && doc_view->vs failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 0;
  }
LABEL_9:
  document = doc_view->document;
  if ( document->frame_desc )
    return 0;
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 )
    return 0;
  if ( current_link >= document->nlinks )
    return 0;
  v5 = (term_event_key_T *)&document->links[current_link];
  if ( !v5 )
    return 0;
  if ( (unsigned int)v5[1] > 1 )
  {
    if ( v5[12] )
      return get_form_info(ses, doc_view);
    return 0;
  }
  term = ses->tab->term;
  uristring = (unsigned __int8 *)v5[2];
  if ( !init_string(&str) )
    return 0;
  if ( v5[2] || !v5[4] )
  {
    if ( v5[1] == 1 )
    {
      v9 = _8("Usemap", term);
      add_to_string(&str, v9);
      add_char_to_string(&str, 0x20u);
    }
  }
  else
  {
    v8 = _8("Image", term);
    add_to_string(&str, v8);
    add_char_to_string(&str, 0x20u);
    uristring = (unsigned __int8 *)v5[4];
  }
  add_string_uri_to_string(&str, uristring, URI_PUBLIC);
  if ( *v5 && get_opt_(config_options, "document.browse.accesskey.display")->number )
  {
    add_to_string(&str, " (");
    v7 = *v5;
    kbd.modifier = KBD_MOD_ALT;
    kbd.key = v7;
    add_keystroke_to_string(&str, &kbd, 0);
    add_char_to_string(&str, 0x29u);
  }
  if ( (*((_BYTE *)term + 56) & 2) != 0 )
    decode_uri_string(&str);
  else
    decode_uri_string_for_display(&str);
  return str.source;
}

//----- (080F61F0) --------------------------------------------------------
unsigned __int8 *__cdecl get_current_link_title(document_view *doc_view)
{
  document *document; // eax
  unsigned __int8 *v2; // esi
  int current_link; // edx
  int v5; // edi
  _BYTE *v6; // edx
  conv_table *translation_table; // eax
  unsigned __int8 v8; // bl
  const unsigned __int16 **v9; // eax
  unsigned __int8 *v10; // edx

  if ( assert_failed )
    goto LABEL_9;
  if ( !doc_view || !doc_view->document || !doc_view->vs )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 1402;
    elinks_internal("assertion doc_view && doc_view->document && doc_view->vs failed!");
    if ( !assert_failed )
      goto LABEL_6;
LABEL_9:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_6:
  document = doc_view->document;
  if ( document->frame_desc )
    return 0;
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 )
    return 0;
  if ( current_link >= document->nlinks )
    return 0;
  v5 = (int)&document->links[current_link];
  if ( !v5 )
    return 0;
  v6 = *(_BYTE **)(v5 + 20);
  if ( !v6 || !*v6 )
    return 0;
  translation_table = get_translation_table(document->cp, document->options.cp);
  v2 = convert_string_elinks(
         translation_table,
         *(unsigned __int8 **)(v5 + 20),
         strlen(*(const char **)(v5 + 20)),
         doc_view->document->options.cp,
         CSM_DEFAULT,
         0,
         0,
         0);
  if ( v2 )
  {
    if ( (*((_BYTE *)&doc_view->document->options + 92) & 0x10) == 0 )
    {
      v8 = *v2;
      if ( *v2 )
      {
        v9 = __ctype_b_loc();
        v10 = v2;
        do
        {
          if ( ((*v9)[v8] & 0x4002) != 0x4000 )
            *v10 = 42;
          v8 = *++v10;
        }
        while ( *v10 );
      }
    }
  }
  return v2;
}

//----- (080F6380) --------------------------------------------------------
void __cdecl link_menu(terminal *term, void *xxx, void *ses_)
{
  document_view *v3; // esi
  menu_item *v4; // eax
  int current_link; // edi
  document *document; // eax
  link *v7; // edi
  unsigned __int8 *name; // edx
  int v9; // eax
  unsigned __int8 *v10; // edx
  int v11; // ecx
  string *inited; // eax
  unsigned __int8 *v13; // edx
  unsigned __int8 *v14; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v15; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v16; // [esp+2Ch] [ebp-2Ch]
  string keystroke; // [esp+34h] [ebp-24h] BYREF
  menu_item *mi[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_33;
  assert_failed = term == 0 || ses_ == 0;
  if ( term == 0 || ses_ == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 1271;
    elinks_internal("assertion term && ses failed!");
    if ( assert_failed )
      goto LABEL_33;
  }
  v3 = current_frame((session *)ses_);
  v4 = new_menu(FREE_LIST);
  if ( !v4 )
    return;
  mi[0] = v4;
  if ( v3 )
  {
    if ( !assert_failed )
    {
      if ( v3->vs && v3->document )
      {
        assert_failed = 0;
LABEL_9:
        current_link = v3->vs->current_link;
        if ( current_link < 0
          || (document = v3->document, current_link >= document->nlinks)
          || (v7 = &document->links[current_link]) == 0 )
        {
LABEL_28:
          v4 = mi[0];
          goto end;
        }
        if ( v7->where )
        {
          if ( v7->type > (unsigned int)LINK_MAP )
            goto LABEL_14;
          if ( v7->type == LINK_MAP )
          {
            add_to_menu(mi, (unsigned __int8 *)&byte_81353DD, 0, ACT_MAIN_LINK_FOLLOW, 0, 0, SUBMENU);
          }
          else
          {
            add_to_menu(mi, "~Follow link", 0, ACT_MAIN_LINK_FOLLOW, 0, 0, NO_FLAG);
            add_to_menu(mi, "Follow link and r~eload", 0, ACT_MAIN_LINK_FOLLOW_RELOAD, 0, 0, NO_FLAG);
            add_to_menu(mi, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
            add_new_win_to_menu(mi, "Open in new ~window", term);
            add_to_menu(mi, "Open in new ~tab", 0, ACT_MAIN_OPEN_LINK_IN_NEW_TAB, 0, 0, NO_FLAG);
            add_to_menu(
              mi,
              "Open in new tab in ~background",
              0,
              ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND,
              0,
              0,
              NO_FLAG);
            if ( !get_opt_(cmdline_options, "anonymous")->number )
            {
              add_to_menu(mi, (unsigned __int8 *)&delete, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
              add_to_menu(mi, (unsigned __int8 *)&byte_8135437, 0, ACT_MAIN_LINK_DOWNLOAD, 0, 0, NO_FLAG);
              add_to_menu(mi, "~Add link to bookmarks", 0, ACT_MAIN_ADD_BOOKMARK_LINK, 0, 0, NO_FLAG);
              add_uri_command_to_menu(mi, PASS_URI_LINK, "Pass link URI to e~xternal command");
            }
          }
        }
        if ( v7->type <= (unsigned int)LINK_MAP )
          goto LABEL_25;
LABEL_14:
        name = v7->data.name;
        if ( !name )
        {
LABEL_25:
          if ( v7->where_img )
          {
            add_to_menu(mi, "V~iew image", 0, ACT_MAIN_VIEW_IMAGE, 0, 0, NO_FLAG);
            if ( !get_opt_(cmdline_options, "anonymous")->number )
              add_to_menu(mi, "Download ima~ge", 0, ACT_MAIN_LINK_DOWNLOAD_IMAGE, 0, 0, NO_FLAG);
          }
          goto LABEL_28;
        }
        v9 = *((_DWORD *)name + 5);
        if ( v9 == 3 )
        {
          if ( !*((_DWORD *)name + 6) )
          {
            v15 = v7->data.name;
            inited = init_string(&keystroke);
            v13 = v15;
            if ( inited )
            {
              add_keystroke_action_to_string(&keystroke, 23, KEYMAP_EDIT);
              v13 = v15;
            }
            v16 = v13;
            add_to_menu(
              mi,
              "Open in ~external editor",
              keystroke.source,
              ACT_MAIN_NONE,
              menu_textarea_edit,
              0,
              FREE_RTEXT);
            name = v16;
          }
        }
        else if ( v9 == 9 )
        {
LABEL_24:
          add_to_menu(mi, (unsigned __int8 *)&byte_813545D, 0, ACT_MAIN_RESET_FORM, 0, 0, NO_FLAG);
          add_to_menu(mi, "Form f~ields", 0, ACT_MAIN_LINK_FORM_MENU, 0, 0, SUBMENU);
          goto LABEL_25;
        }
        v14 = name;
        add_to_menu(mi, "~Submit form", 0, ACT_MAIN_SUBMIT_FORM, 0, 0, NO_FLAG);
        add_to_menu(mi, "Submit form and rel~oad", 0, ACT_MAIN_SUBMIT_FORM_RELOAD, 0, 0, NO_FLAG);
        v10 = v14;
        if ( !assert_failed )
        {
          v11 = *((_DWORD *)v14 + 2);
          assert_failed = v11 == 0;
          if ( !v11 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
            errline = 1352;
            elinks_internal("assertion fc->form failed!");
            v10 = v14;
          }
        }
        if ( !*(_DWORD *)(*((_DWORD *)v10 + 2) + 32) )
        {
          add_new_win_to_menu(mi, "Submit form and open in new ~window", term);
          add_to_menu(mi, "Submit form and open in new ~tab", 0, ACT_MAIN_OPEN_LINK_IN_NEW_TAB, 0, 0, NO_FLAG);
          add_to_menu(
            mi,
            "Submit form and open in new tab in ~background",
            0,
            ACT_MAIN_OPEN_LINK_IN_NEW_TAB_IN_BACKGROUND,
            0,
            0,
            NO_FLAG);
        }
        if ( !get_opt_(cmdline_options, "anonymous")->number )
          add_to_menu(mi, "Submit form and ~download", 0, ACT_MAIN_LINK_DOWNLOAD, 0, 0, NO_FLAG);
        goto LABEL_24;
      }
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
      errline = 1279;
      elinks_internal("assertion doc_view->vs && doc_view->document failed!");
      if ( !assert_failed )
        goto LABEL_9;
    }
LABEL_33:
    assert_failed = 0;
    return;
  }
end:
  if ( !v4->text )
  {
    add_to_menu(mi, (unsigned __int8 *)&byte_81354EA, 0, ACT_MAIN_NONE, 0, 0, NO_SELECT);
    v4 = mi[0];
  }
  do_menu(term, v4, ses_, 1);
}

//----- (080F6B30) --------------------------------------------------------
void __cdecl jump_to_link_number(session *ses, document_view *doc_view, int n)
{
  int current_link; // edi
  document *document; // eax
  int v5; // edi
  unsigned int v6; // ecx
  int v7; // eax
  form_state *v8; // eax
  form_state *form_state; // eax
  form_state *v10; // ecx
  unsigned __int8 *value; // eax
  unsigned __int8 *v12; // edx
  unsigned __int8 *v13; // eax
  form_control *fc; // [esp+18h] [ebp-20h]
  _BOOL4 utf8; // [esp+1Ch] [ebp-1Ch]
  int utf8a; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_10;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 1152;
  elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return;
  }
LABEL_10:
  if ( n >= 0 && n < doc_view->document->nlinks )
  {
    doc_view->vs->current_link = n;
    if ( ses->navigate_mode != NAVIGATE_CURSOR_ROUTING )
    {
LABEL_13:
      check_vs(doc_view);
      return;
    }
    current_link = doc_view->vs->current_link;
    if ( current_link >= 0 && (document = doc_view->document, current_link < document->nlinks) )
      v5 = (int)&document->links[current_link];
    else
      v5 = 0;
    v6 = *(_DWORD *)(v5 + 4);
    v7 = 1;
    if ( v6 != 3 )
    {
      if ( v6 <= 3 )
      {
        LOBYTE(v7) = 2;
        if ( v6 != 2 )
          v7 = 0;
        goto LABEL_22;
      }
      if ( v6 == 5 )
      {
        utf8a = (*((_BYTE *)doc_view->session->tab->term + 56) & 2) != 0;
        form_state = find_form_state(doc_view, *(form_control **)(v5 + 48));
        v10 = form_state;
        if ( form_state )
        {
          value = form_state->value;
          if ( value )
          {
            if ( utf8a )
            {
              v12 = &value[v10->vpos];
              v13 = &value[v10->state];
              if ( v10->type == FC_PASSWORD )
                v7 = utf8_ptr2chars(v12, v13);
              else
                v7 = utf8_ptr2cells(v12, v13);
            }
            else
            {
              v7 = v10->state - v10->vpos;
            }
            goto LABEL_22;
          }
        }
      }
      else if ( v6 == 6 )
      {
        utf8 = (*((_BYTE *)doc_view->session->tab->term + 56) & 2) != 0;
        fc = *(form_control **)(v5 + 48);
        v8 = find_form_state(doc_view, fc);
        if ( v8 )
        {
          v7 = area_cursor(fc, v8, utf8);
          goto LABEL_22;
        }
      }
      v7 = 0;
    }
LABEL_22:
    if ( *(_DWORD *)(v5 + 28) > v7 )
      move_cursor(
        ses,
        doc_view,
        *(_DWORD *)(*(_DWORD *)(v5 + 24) + 8 * v7) + doc_view->box.x - doc_view->vs->x,
        *(_DWORD *)(*(_DWORD *)(v5 + 24) + 8 * v7 + 4) + doc_view->box.y - doc_view->vs->y);
    goto LABEL_13;
  }
}

//----- (080F6D40) --------------------------------------------------------
uri *__cdecl get_link_uri(session *ses, document_view *doc_view, link *link)
{
  link_type type; // eax
  unsigned __int8 *where; // eax

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || !link )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 881;
    elinks_internal("assertion ses && doc_view && link failed!");
    if ( !assert_failed )
      goto LABEL_9;
LABEL_4:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_9:
  type = link->type;
  if ( type == LINK_BUTTON )
    return get_form_uri(ses, doc_view, link->data.form_control);
  if ( (unsigned int)type >= LINK_BUTTON )
  {
    if ( type == LINK_FIELD )
      return get_form_uri(ses, doc_view, link->data.form_control);
    return 0;
  }
  where = link->where;
  if ( !where )
    where = link->where_img;
  return get_uri(where, (uri_component)0);
}

//----- (080F6E40) --------------------------------------------------------
link *__cdecl goto_current_link(session *ses, document_view *doc_view, int do_reload)
{
  document_view *v3; // eax
  int current_link; // ebx
  document *document; // edx
  int v6; // ebx
  int v7; // edi
  int v8; // edx
  bool v9; // zf
  uri *form_uri; // eax
  uri *link_uri; // edi
  unsigned __int8 *v13; // eax
  cache_mode cache_mode; // [esp+18h] [ebp-20h]
  uri *v15; // [esp+1Ch] [ebp-1Ch]
  uri *v16; // [esp+1Ch] [ebp-1Ch]

  v3 = doc_view;
  if ( assert_failed )
    goto LABEL_13;
  assert_failed = ses == 0 || doc_view == 0;
  if ( ses == 0 || doc_view == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 962;
    elinks_internal("assertion doc_view && ses failed!");
    v3 = doc_view;
    if ( assert_failed )
    {
LABEL_13:
      assert_failed = 0;
      return 0;
    }
    if ( !doc_view )
      return 0;
  }
  else if ( !doc_view )
  {
    return 0;
  }
  current_link = v3->vs->current_link;
  if ( current_link < 0 )
    return 0;
  document = v3->document;
  if ( current_link >= document->nlinks )
    return 0;
  v6 = (int)&document->links[current_link];
  if ( v6 )
  {
    if ( *(_DWORD *)(v6 + 4) <= 1u )
    {
      link_uri = get_link_uri(ses, v3, (link *)v6);
      if ( !link_uri )
        return 0;
      if ( *(_DWORD *)(v6 + 4) == 1 )
      {
        v13 = 0;
        if ( *(_DWORD *)(v6 + 12) )
          v13 = stracpy(*(const unsigned __int8 **)(v6 + 12));
        goto_imgmap(ses, link_uri, v13);
      }
      else
      {
        goto_uri_frame(
          ses,
          link_uri,
          *(unsigned __int8 **)(v6 + 12),
          (cache_mode)(do_reload == 0 ? CACHE_MODE_NORMAL : CACHE_MODE_FORCE_RELOAD));
      }
      done_uri(link_uri);
    }
    else
    {
      v7 = *(_DWORD *)(v6 + 48);
      if ( *(_DWORD *)(v7 + 20) != 10 )
      {
        v8 = do_reload == 0 ? 1 : 3;
        v9 = *(_DWORD *)(v7 + 8) != 0;
        assert_failed = *(_DWORD *)(v7 + 8) == 0;
        if ( !v9 )
        {
          v16 = (uri *)v3;
          errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
          errline = 907;
          elinks_internal("assertion fc->form failed!");
          v8 = do_reload == 0 ? 1 : 3;
          v3 = (document_view *)v16;
          if ( assert_failed )
            goto LABEL_13;
        }
        cache_mode = v8;
        form_uri = get_form_uri(ses, v3, (form_control *)v7);
        if ( form_uri )
        {
          v15 = form_uri;
          goto_uri_frame(ses, form_uri, *(unsigned __int8 **)(*(_DWORD *)(v7 + 8) + 28), cache_mode);
          done_uri(v15);
          return (link *)v6;
        }
        return 0;
      }
    }
  }
  return (link *)v6;
}

//----- (080F7050) --------------------------------------------------------
frame_event_status __cdecl enter(session *ses, document_view *doc_view, int do_reload)
{
  int current_link; // edx
  document *document; // eax
  int v6; // edx
  int v7; // esi
  int v8; // edx
  int v9; // esi
  form_state *form_state; // eax
  form_control *v11; // edx
  document *v12; // eax
  list_head_elinks *i; // edi
  form_control *prev; // esi
  void **p_prev; // ecx
  int v16; // eax
  form_state *v17; // eax
  void **v18; // [esp+18h] [ebp-20h]
  form_control *v19; // [esp+1Ch] [ebp-1Ch]
  form_control *v20; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 1080;
  elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 1;
  }
LABEL_9:
  if ( !doc_view )
    return 1;
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 )
    return 1;
  document = doc_view->document;
  if ( current_link >= document->nlinks )
    return 1;
  v6 = (int)&document->links[current_link];
  if ( !v6 )
    return 1;
  if ( *(_DWORD *)(v6 + 4) > 6u )
  {
LABEL_15:
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 1069;
    elinks_internal("bad link type %d", *(_DWORD *)(v6 + 4));
    return 1;
  }
  v7 = 1 << *(_DWORD *)(v6 + 4);
  if ( (v7 & 0x67) != 0 )
  {
    if ( goto_current_link(ses, doc_view, do_reload) )
      return 2;
    return 1;
  }
  if ( (v7 & 0x10) != 0 )
  {
    v9 = *(_DWORD *)(v6 + 48);
    if ( !*(_DWORD *)(v9 + 24) )
    {
      ++document->object.refcount;
      add_empty_window(ses->tab->term, (void (*)(void *))release_document, doc_view->document);
      do_select_submenu(ses->tab->term, *(void **)(v9 + 80), ses);
      return 1;
    }
    return 2;
  }
  if ( (v7 & 8) == 0 )
    goto LABEL_15;
  v8 = *(_DWORD *)(v6 + 48);
  if ( *(_DWORD *)(v8 + 24) )
    return 2;
  v19 = (form_control *)v8;
  form_state = find_form_state(doc_view, (form_control *)v8);
  v11 = v19;
  if ( !form_state )
    return 2;
  if ( v19->type != FC_CHECKBOX )
  {
    form_state->state = 1;
    v12 = doc_view->document;
    for ( i = (list_head_elinks *)v12->forms.next; i != &v12->forms; i = (list_head_elinks *)i->next )
    {
      if ( (list_head_elinks *)v11->form == i )
      {
        prev = (form_control *)i[4].prev;
        p_prev = &i[4].prev;
        if ( prev != (form_control *)&i[4].prev )
        {
          do
          {
            if ( prev->type == FC_RADIO )
            {
              v20 = v11;
              v18 = p_prev;
              v16 = xstrcmp(prev->name, v11->name);
              v11 = v20;
              p_prev = v18;
              if ( !v16 && v20 != prev )
              {
                v17 = find_form_state(doc_view, prev);
                v11 = v20;
                p_prev = v18;
                if ( v17 )
                  v17->state = 0;
              }
            }
            prev = prev->next;
          }
          while ( prev != (form_control *)p_prev );
          v12 = doc_view->document;
        }
      }
    }
    return 1;
  }
  form_state->state = form_state->state == 0;
  return 1;
}

//----- (080F72E0) --------------------------------------------------------
void __usercall goto_link_number_do(session *ses@<eax>, document_view *doc_view@<edx>, int n@<ecx>)
{
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  v5 = n;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 1181;
  elinks_internal("assertion ses && doc_view && doc_view->document failed!");
  n = v5;
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return;
  }
LABEL_9:
  if ( n >= 0 && n < doc_view->document->nlinks )
  {
    v6 = n;
    jump_to_link_number(ses, doc_view, n);
    if ( (unsigned int)(doc_view->document->links[v6].type - 5) > 1 )
    {
      if ( get_opt_(config_options, "document.browse.accesskey.auto_follow")->number )
        enter(ses, doc_view, 0);
    }
  }
}

//----- (080F73E0) --------------------------------------------------------
frame_event_status __cdecl try_document_key(session *ses, document_view *doc_view, term_event *ev)
{
  int x; // ebx
  int current_link; // edi
  document *document; // eax
  int v7; // ecx
  int nlinks; // esi
  link *links; // edx
  link *v10; // eax
  unicode_val_T accesskey; // edx
  link *v12; // eax
  unicode_val_T v13; // edx
  document *v14; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_10;
  if ( doc_view && ses && doc_view->document && ev && doc_view->vs )
  {
    assert_failed = 0;
    if ( ev->info.mouse.y != 4 )
      return 0;
    goto LABEL_11;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
  errline = 1213;
  elinks_internal("assertion ses && doc_view && doc_view->document && doc_view->vs && ev failed!");
  if ( assert_failed )
  {
LABEL_10:
    assert_failed = 0;
    return 0;
  }
  if ( ev->info.mouse.y != 4 )
    return 0;
LABEL_11:
  x = ev->info.mouse.x;
  if ( x < 0 )
    return 0;
  current_link = doc_view->vs->current_link;
  document = doc_view->document;
  v7 = current_link + 1;
  v14 = document;
  nlinks = document->nlinks;
  if ( current_link + 1 < nlinks )
  {
    links = document->links;
    if ( links[v7].accesskey == x )
    {
LABEL_26:
      ses->kbdprefix.repeat_count = 0;
      goto_link_number_do(ses, doc_view, v7);
      return 1;
    }
    v10 = &links[current_link + 2];
    while ( ++v7 < nlinks )
    {
      accesskey = v10->accesskey;
      ++v10;
      if ( accesskey == x )
        goto LABEL_26;
    }
  }
  if ( current_link < 0 )
    return 0;
  v7 = 0;
  v12 = v14->links;
  if ( v12->accesskey == x )
    goto LABEL_26;
  while ( current_link >= ++v7 )
  {
    v13 = v12[1].accesskey;
    ++v12;
    if ( v13 == x )
      goto LABEL_26;
  }
  return 0;
}

//----- (080F7570) --------------------------------------------------------
void __cdecl goto_link_number(session *ses, unsigned __int8 *num)
{
  document_view *v2; // esi
  int v3; // eax

  if ( assert_failed )
    goto LABEL_7;
  assert_failed = ses == 0 || num == 0;
  if ( ses == 0 || num == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 1197;
    elinks_internal("assertion ses && num failed!");
    if ( assert_failed )
      goto LABEL_7;
  }
  v2 = current_frame(ses);
  if ( assert_failed
    || (assert_failed = v2 == 0, !v2)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c",
        errline = 1200,
        elinks_internal("assertion doc_view failed!"),
        assert_failed) )
  {
LABEL_7:
    assert_failed = 0;
  }
  else
  {
    v3 = strtol((const char *)num, 0, 10);
    goto_link_number_do(ses, v2, v3 - 1);
  }
}

//----- (080F7680) --------------------------------------------------------
void __cdecl highlight_links_with_prefixes_that_start_with_n(terminal *term, document_view *doc_view, int n)
{
  view_state *vs; // eax
  int nlinks; // eax
  int v5; // edi
  int v6; // esi
  _DWORD *v7; // edx
  int v8; // eax
  int v9; // ecx
  int x; // edx
  int v11; // ecx
  color_pair *color; // [esp+10h] [ebp-38h]
  int m; // [esp+14h] [ebp-34h]
  document *document; // [esp+18h] [ebp-30h]
  int i; // [esp+1Ch] [ebp-2Ch]
  int linkn; // [esp+20h] [ebp-28h]
  int yoffset; // [esp+24h] [ebp-24h]
  int xoffset; // [esp+28h] [ebp-20h]
  int y; // [esp+2Ch] [ebp-1Ch]

  color = get_bfu_color(term, "searched");
  vs = doc_view->vs;
  xoffset = doc_view->box.x - vs->x;
  yoffset = doc_view->box.y - vs->y;
  document = doc_view->document;
  nlinks = document->nlinks;
  if ( n <= nlinks )
  {
    m = n + 1;
    for ( linkn = n; ; linkn = n )
    {
      if ( linkn < m && linkn <= nlinks )
      {
        v5 = (int)&document->links[linkn - 1];
        for ( i = linkn; ; ++i )
        {
          if ( *(int *)(v5 + 28) > 0 )
          {
            v6 = 0;
            do
            {
              v7 = (_DWORD *)(*(_DWORD *)(v5 + 24) + 8 * v6);
              v8 = *v7 + xoffset;
              v9 = v7[1];
              x = doc_view->box.x;
              if ( v8 >= x )
              {
                y = yoffset + v9;
                v11 = doc_view->box.y;
                if ( y >= v11 && v8 < doc_view->box.width + x && y < doc_view->box.height + v11 )
                  draw_char_color(term, v8, y, color);
              }
              ++v6;
            }
            while ( *(_DWORD *)(v5 + 28) > v6 );
            nlinks = document->nlinks;
          }
          if ( ++linkn >= m || nlinks < linkn )
            break;
          v5 = (int)&document->links[i];
        }
      }
      n *= 10;
      if ( n > nlinks )
        break;
      m *= 10;
    }
  }
}

//----- (080F77E0) --------------------------------------------------------
void __cdecl clear_link(terminal *term, document_view *doc_view)
{
  document_view *v2; // esi
  view_state *vs; // edx
  int current_link; // ecx
  document *document; // eax
  int v6; // ebx
  int old_current_link; // edi
  document *v8; // eax
  int v9; // edi
  int v10; // ebx
  int x; // edx
  int v12; // esi
  int *v13; // ecx
  int v14; // edi
  screen_char *chars; // eax
  int v16; // ecx
  terminal_screen *screen; // eax
  int v18; // [esp+2Ch] [ebp-2Ch]
  int v19; // [esp+30h] [ebp-28h]
  screen_char *v20; // [esp+34h] [ebp-24h]
  int v21; // [esp+38h] [ebp-20h]
  int y; // [esp+3Ch] [ebp-1Ch]

  v2 = doc_view;
  if ( !doc_view )
  {
LABEL_22:
    vs = v2->vs;
    current_link = vs->current_link;
    goto LABEL_23;
  }
  vs = doc_view->vs;
  current_link = vs->current_link;
  if ( current_link < 0 || (document = doc_view->document, current_link >= document->nlinks) )
    v6 = 0;
  else
    v6 = (int)&document->links[current_link];
  old_current_link = vs->old_current_link;
  if ( old_current_link >= 0 )
  {
    v8 = doc_view->document;
    if ( old_current_link < v8->nlinks )
    {
      v9 = (int)&v8->links[old_current_link];
      if ( v6 != v9 )
      {
        if ( v9 )
        {
          v19 = doc_view->box.x - vs->x;
          v18 = doc_view->box.y - vs->y;
          if ( *(int *)(v9 + 28) > 0 )
          {
            v10 = 0;
            x = doc_view->box.x;
            v12 = v9;
            while ( 1 )
            {
              v13 = (int *)(*(_DWORD *)(v12 + 24) + 8 * v10);
              v14 = *v13;
              v21 = v13[1];
              if ( x <= *v13 + v19 )
              {
                y = v21 + v18;
                if ( v21 + v18 >= doc_view->box.y
                  && v14 + v19 < doc_view->box.width + x
                  && y < doc_view->box.height + doc_view->box.y )
                {
                  v20 = get_char(term, v14 + v19, y);
                  chars = doc_view->document->data[v21].chars;
                  v16 = *(_DWORD *)&chars[v14].attr;
                  v20->data = chars[v14].data;
                  *(_DWORD *)&v20->attr = v16;
                  screen = term->screen;
                  if ( y < screen->dirty_from )
                    screen->dirty_from = y;
                  if ( y > screen->dirty_to )
                    screen->dirty_to = y;
                }
              }
              if ( ++v10 >= *(_DWORD *)(v12 + 28) )
                break;
              x = doc_view->box.x;
            }
            v2 = doc_view;
            goto LABEL_22;
          }
        }
      }
    }
  }
LABEL_23:
  vs->old_current_link = current_link;
}

//----- (080F7960) --------------------------------------------------------
void __cdecl draw_current_link(session *ses, document_view *doc_view)
{
  document_view *v2; // esi
  window *tab; // ebx
  window *tab_by_number; // eax
  int current_link; // edi
  document *document; // eax
  int v7; // edi
  _BOOL4 v8; // ebx
  document *v9; // eax
  char active_link; // dl
  color_flags v11; // ecx
  view_state *vs; // eax
  unsigned int v13; // eax
  int v14; // ebx
  form_state *v15; // eax
  int v16; // ebx
  _DWORD *v17; // esi
  _DWORD *v18; // eax
  int v19; // edi
  int v20; // ecx
  int x; // eax
  int v22; // edx
  screen_char *v23; // eax
  unicode_val_T data; // eax
  terminal_screen *screen; // eax
  color_T background; // edx
  form_state *form_state; // eax
  unsigned __int8 *value; // edx
  unsigned __int8 *v29; // ecx
  unsigned __int8 *v30; // edx
  int y; // [esp+1Ch] [ebp-5Ch]
  form_control *fc; // [esp+28h] [ebp-50h]
  int cursor_offset; // [esp+2Ch] [ebp-4Ch]
  int ypos; // [esp+40h] [ebp-38h]
  terminal *term; // [esp+44h] [ebp-34h]
  int xpos; // [esp+48h] [ebp-30h]
  int xposa; // [esp+48h] [ebp-30h]
  unicode_val_T *co; // [esp+4Ch] [ebp-2Ch]
  color_pair pair; // [esp+58h] [ebp-20h] BYREF

  v2 = doc_view;
  term = ses->tab->term;
  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses->tab->term && doc_view->vs )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 238;
    elinks_internal("assertion term && doc_view && doc_view->vs failed!");
    if ( assert_failed )
    {
LABEL_4:
      assert_failed = 0;
      return;
    }
  }
  tab = ses->tab;
  tab_by_number = get_tab_by_number(term, term->current_tab);
  assert_failed = tab != tab_by_number;
  if ( tab != tab_by_number )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/link.c";
    errline = 241;
    elinks_internal("assertion ses->tab == get_current_tab(term) failed!");
    if ( assert_failed )
      goto LABEL_4;
  }
  if ( !doc_view )
    return;
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 )
    return;
  document = doc_view->document;
  if ( current_link >= document->nlinks )
    return;
  v7 = (int)&document->links[current_link];
  if ( !v7 )
    return;
  v8 = 1;
  if ( (unsigned int)(*(_DWORD *)(v7 + 4) - 5) <= 1 )
    v8 = ses->insert_mode == INSERT_MODE_OFF;
  template_8980.attr = 64;
  v9 = doc_view->document;
  xpos = v9->options.color_mode;
  active_link = (char)v9->options.active_link;
  v11 = v9->options.color_flags | 1;
  if ( (active_link & 2) != 0 )
  {
    template_8980.attr = 96;
    active_link = (char)v9->options.active_link;
  }
  if ( (active_link & 4) != 0 )
  {
    template_8980.attr |= 8u;
    active_link = (char)v9->options.active_link;
  }
  if ( (active_link & 1) != 0 )
  {
    pair.foreground = v9->options.active_link.fg;
    pair.background = v9->options.active_link.bg;
  }
  else
  {
    pair = *(color_pair *)(v7 + 36);
  }
  if ( v8 && (*(_BYTE *)&v9->options.active_link & 8) != 0 )
  {
    background = pair.background;
    pair.background = pair.foreground;
    pair.foreground = background;
    if ( (unsigned int)(*(_DWORD *)(v7 + 4) - 5) <= 1 )
      v11 = v11 & 0xFFFFFFEB | 0x10;
  }
  set_term_color(&template_8980, &pair, v11, (color_mode)xpos);
  vs = doc_view->vs;
  xposa = doc_view->box.x - vs->x;
  ypos = doc_view->box.y - vs->y;
  if ( ses->insert_mode != INSERT_MODE_OFF || (cursor_offset = -1, ses->navigate_mode != NAVIGATE_CURSOR_ROUTING) )
  {
    v13 = *(_DWORD *)(v7 + 4);
    v14 = (*((_BYTE *)doc_view->session->tab->term + 56) & 2) != 0;
    cursor_offset = 1;
    if ( v13 != 3 )
    {
      if ( v13 <= 3 )
      {
        cursor_offset = 2;
        if ( v13 == 2 )
          goto LABEL_32;
      }
      else if ( v13 == 5 )
      {
        form_state = find_form_state(doc_view, *(form_control **)(v7 + 48));
        if ( form_state )
        {
          value = form_state->value;
          if ( value )
          {
            if ( v14 )
            {
              v29 = &value[form_state->vpos];
              v30 = &value[form_state->state];
              if ( form_state->type == FC_PASSWORD )
                cursor_offset = utf8_ptr2chars(v29, v30);
              else
                cursor_offset = utf8_ptr2cells(v29, v30);
            }
            else
            {
              cursor_offset = form_state->state - form_state->vpos;
            }
            goto LABEL_32;
          }
        }
      }
      else if ( v13 == 6 )
      {
        fc = *(form_control **)(v7 + 48);
        v15 = find_form_state(doc_view, fc);
        if ( v15 )
        {
          cursor_offset = area_cursor(fc, v15, v14);
          goto LABEL_32;
        }
      }
      cursor_offset = 0;
    }
  }
LABEL_32:
  if ( *(int *)(v7 + 28) > 0 )
  {
    v16 = 0;
    v17 = (_DWORD *)v7;
    do
    {
      v18 = (_DWORD *)(v17[6] + 8 * v16);
      v19 = *v18 + xposa;
      v20 = v18[1];
      x = doc_view->box.x;
      if ( v19 >= x )
      {
        y = ypos + v20;
        v22 = doc_view->box.y;
        if ( ypos + v20 >= v22 && v19 < doc_view->box.width + x && y < v22 + doc_view->box.height )
        {
          v23 = get_char(term, v19, y);
          co = &v23->data;
          if ( v16 == cursor_offset )
          {
            set_cursor(term, v19, y, v23 != &template_8980 && (unsigned int)(v17[1] - 5) > 1);
            ses->tab->x = v19;
            ses->tab->y = y;
          }
          template_8980.data = *co;
          data = template_8980.data;
          co[1] = *(_DWORD *)&template_8980.attr;
          *co = data;
          screen = term->screen;
          if ( y < screen->dirty_from )
            screen->dirty_from = y;
          if ( y > screen->dirty_to )
            screen->dirty_to = y;
        }
      }
      ++v16;
    }
    while ( v17[7] > v16 );
    v2 = doc_view;
  }
  v2->vs->old_current_link = v2->vs->current_link;
}

//----- (080F7DC0) --------------------------------------------------------
void __usercall free_mark_by_index(int i@<eax>)
{
  if ( !assert_failed )
  {
    assert_failed = (unsigned int)i > 0x33;
    if ( (unsigned int)i > 0x33 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
      errline = 118;
      elinks_internal("assertion is_valid_mark_index(i) failed!");
    }
  }
  if ( marks[i] )
  {
    destroy_vs(marks[i], 1);
    if ( marks[i] )
      mem_free(marks[i]);
    marks[i] = 0;
  }
}

//----- (080F7E50) --------------------------------------------------------
void __cdecl done_marks(module *xxx)
{
  int i; // ebx
  int v2; // eax

  for ( i = 0; i != 52; ++i )
  {
    v2 = i;
    free_mark_by_index(v2);
  }
}

//----- (080F7E80) --------------------------------------------------------
void __cdecl goto_mark(unsigned __int8 mark, view_state *vs)
{
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // cl
  int v4; // edi
  unsigned int v5; // esi
  view_state *v6; // eax
  document_view *doc_view; // edi
  int current_link; // [esp+1Ch] [ebp-1Ch]

  v2 = mark - 97;
  v3 = mark - 65;
  if ( (unsigned __int8)(mark - 97) > 0x19u && v3 > 0x19u )
    return;
  v4 = assert_failed;
  if ( !assert_failed )
  {
    assert_failed = v2 > 0x19u && v3 > 0x19u;
    if ( v2 > 0x19u && v3 > 0x19u )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
      errline = 67;
      elinks_internal("assertion is_valid_mark_char(mark) failed!");
LABEL_7:
      v4 = assert_failed;
      v5 = mark - 71;
      goto LABEL_8;
    }
  }
  if ( v3 > 0x19u )
    goto LABEL_7;
  v5 = mark - 65;
LABEL_8:
  if ( !v4 )
  {
    assert_failed = v5 > 0x33;
    if ( v5 > 0x33 )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
      errline = 90;
      elinks_internal("assertion is_valid_mark_index(i) failed!");
    }
  }
  v6 = marks[v5];
  if ( v6 )
  {
    if ( compare_uri(v6->uri, vs->uri, (uri_component)0) )
    {
      doc_view = vs->doc_view;
      current_link = vs->current_link;
      destroy_vs(vs, 0);
      copy_vs(vs, marks[v5]);
      vs->doc_view = doc_view;
      doc_view->vs = vs;
      vs->old_current_link = current_link;
    }
  }
}

//----- (080F7FD0) --------------------------------------------------------
void __cdecl set_mark(unsigned __int8 mark, view_state *mark_vs)
{
  unsigned __int8 v2; // dl
  unsigned __int8 v3; // cl
  int v4; // esi
  view_state *v5; // eax
  view_state *v6; // edi

  v2 = mark - 97;
  v3 = mark - 65;
  if ( (unsigned __int8)(mark - 97) > 0x19u && v3 > 0x19u )
    return;
  if ( !assert_failed )
  {
    assert_failed = v2 > 0x19u && v3 > 0x19u;
    if ( v2 > 0x19u && v3 > 0x19u )
    {
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/marks.c";
      errline = 67;
      elinks_internal("assertion is_valid_mark_char(mark) failed!");
LABEL_7:
      v4 = mark - 71;
      goto LABEL_8;
    }
  }
  if ( v3 > 0x19u )
    goto LABEL_7;
  v4 = mark - 65;
LABEL_8:
  free_mark_by_index(v4);
  if ( mark_vs )
  {
    v5 = (view_state *)mem_calloc(1u, 0x30u);
    v6 = v5;
    if ( v5 )
    {
      copy_vs(v5, mark_vs);
      marks[v4] = v6;
    }
  }
}

//----- (080F80B0) --------------------------------------------------------
evhook_status __cdecl search_history_write_hook(va_list ap, void *data)
{
  save_input_history(&search_history, "searchhist");
  return 0;
}

//----- (080F80D0) --------------------------------------------------------
void __cdecl done_search_history(module *module)
{
  _DWORD *next; // eax
  input_history *i; // ebx
  input_history *j; // edx
  input_history *v4; // esi
  input_history *v5; // edi

  save_input_history(&search_history, "searchhist");
  next = search_history.entries.next;
  for ( i = (input_history *)search_history.entries.next; i != &search_history; i = (input_history *)i->entries.next )
    ;
  for ( j = (input_history *)search_history.entries.prev; j != i; j = (input_history *)j->entries.prev )
    ;
  v4 = *(input_history **)search_history.entries.next;
  if ( search_history.entries.next != i )
  {
    do
    {
      v5 = v4;
      v4->entries.prev = (void *)next[1];
      *(_DWORD *)next[1] = *next;
      mem_free(next);
      v4 = (input_history *)v4->entries.next;
      next = &v5->entries.next;
    }
    while ( v5 != i );
  }
}

//----- (080F8150) --------------------------------------------------------
void __cdecl init_search_history(module *module)
{
  load_input_history(&search_history, "searchhist");
}

//----- (080F8170) --------------------------------------------------------
int __usercall get_range@<eax>(
        document *document@<eax>,
        int y@<edx>,
        int height@<ecx>,
        int l,
        search **s1,
        search **s2)
{
  int result; // eax
  int v8; // edx
  int v9; // ecx
  search *v10; // ebx
  search *v11; // ebx
  search *search; // edx
  search *v13; // edx
  int v14; // [esp+24h] [ebp-24h]
  document *v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_2;
  if ( s1 && document && s2 )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 244;
    v15 = document;
    v14 = height;
    elinks_internal("assertion document && s1 && s2 failed!");
    document = v15;
    height = v14;
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return -1;
    }
  }
  *s2 = 0;
  v8 = 0;
  if ( y >= 0 )
    v8 = y;
  *s1 = 0;
  v16 = v8 + height;
  if ( v8 + height <= v8 || document->height <= v8 )
    return 1;
  v9 = v8;
  do
  {
    v10 = document->slines1[v9];
    if ( v10 && (!*s1 || v10 < *s1) )
      *s1 = v10;
    v11 = document->slines2[v9];
    if ( v11 && (!*s2 || v11 > *s2) )
      *s2 = v11;
    if ( v16 <= ++v8 )
      break;
    ++v9;
  }
  while ( document->height > v8 );
  if ( !*s1 || !*s2 )
    return 1;
  search = &(*s1)[-l];
  *s1 = search;
  if ( search < document->search )
    search = document->search;
  *s1 = search;
  v13 = &document->search[document->nsearch + 1 - l];
  if ( *s2 <= v13 )
    v13 = *s2;
  *s2 = v13;
  if ( v13 < *s1 )
  {
    result = 1;
    *s2 = 0;
    *s1 = 0;
    return result;
  }
  return !*s1 || v13 == 0;
}

//----- (080F8320) --------------------------------------------------------
widget_handler_status_T __cdecl search_dlg_cancel(dialog_data *dlg_data, widget_data *widget_data)
{
  void (__cdecl *data)(_DWORD); // eax

  data = (void (__cdecl *)(_DWORD))widget_data->widget->data;
  if ( data )
    data(*(_DWORD *)dlg_data->dlg->udata2);
  return cancel_dialog(dlg_data, widget_data);
}

//----- (080F8360) --------------------------------------------------------
widget_handler_status_T __cdecl search_dlg_ok(dialog_data *dlg_data, widget_data *widget_data)
{
  option_value *udata2; // esi
  option_elinks *opt_rec; // eax
  void *data; // [esp+14h] [ebp-24h]
  void (__cdecl *v6)(void *, unsigned __int8 *); // [esp+18h] [ebp-20h]
  unsigned __int8 *text; // [esp+1Ch] [ebp-1Ch]

  v6 = (void (__cdecl *)(void *, unsigned __int8 *))widget_data->widget->data;
  udata2 = (option_value *)dlg_data->dlg->udata2;
  data = (void *)udata2->number;
  text = dlg_data->widgets_data[0].cdata;
  update_dialog_data(dlg_data);
  opt_rec = get_opt_rec(config_options, "document.browse.search");
  commit_option_values(resolvers_0, opt_rec, udata2 + 1, 1);
  if ( check_dialog(dlg_data) )
    return 1;
  add_to_input_history(dlg_data->dlg->widgets[0].info.field.history, text, 1);
  if ( v6 )
    v6(data, text);
  return cancel_dialog(dlg_data, widget_data);
}

//----- (080F8440) --------------------------------------------------------
int __usercall strlen_u@<eax>(unsigned __int8 *text@<eax>, int utf8@<edx>)
{
  unsigned __int8 *texta; // [esp+1Ch] [ebp-Ch] BYREF

  texta = text;
  if ( utf8 )
    return strlen_utf8(&texta);
  else
    return strlen((const char *)texta);
}

//----- (080F8470) --------------------------------------------------------
unicode_val_T *__usercall memacpy_u@<eax>(unsigned __int8 *text@<eax>, int textlen@<edx>, int utf8@<ecx>)
{
  _DWORD *v5; // edi
  int v6; // esi
  int v8; // eax
  unsigned __int8 *texta; // [esp+1Ch] [ebp-1Ch] BYREF

  texta = text;
  v5 = mem_alloc(4 * textlen + 4);
  if ( v5 )
  {
    if ( utf8 )
    {
      if ( textlen > 0 )
      {
        v6 = 0;
        do
          v5[v6++] = utf8_to_unicode(&texta, texta + 7);
        while ( textlen > v6 );
      }
      goto LABEL_6;
    }
    v8 = 0;
    if ( textlen <= 0 )
    {
LABEL_6:
      v5[textlen] = 0;
      return v5;
    }
    do
    {
      v5[v8] = texta[v8];
      ++v8;
    }
    while ( v8 != textlen );
    v5[textlen] = 0;
  }
  return v5;
}

//----- (080F8500) --------------------------------------------------------
unicode_val_T *__usercall lowered_string@<eax>(unsigned __int8 *text@<eax>, int textlen@<edx>, int utf8@<ecx>)
{
  int v5; // ebx
  unicode_val_T *v6; // eax
  wint_t *v7; // edi
  __int32_t v8; // edx
  wint_t v10; // [esp+18h] [ebp-20h]
  unicode_val_T *ret; // [esp+1Ch] [ebp-1Ch]

  v5 = textlen;
  if ( textlen < 0 )
    v5 = strlen_u(text, utf8);
  v6 = memacpy_u(text, v5, utf8);
  ret = v6;
  if ( v5 && v6 )
  {
    v7 = &v6[v5];
    while ( 1 )
    {
      if ( utf8 )
      {
        *v7 = towlower(*v7);
        --v7;
        if ( !v5 )
          return ret;
      }
      else
      {
        v8 = *v7;
        if ( *v7 + 128 <= 0x17F )
        {
          v10 = *v7;
          v8 = (*__ctype_tolower_loc())[v10];
        }
        *v7-- = v8;
        if ( !v5 )
          return ret;
      }
      --v5;
    }
  }
  return ret;
}

//----- (080F8590) --------------------------------------------------------
void __usercall print_find_error_not_found(
        session *ses@<eax>,
        unsigned __int8 *title@<edx>,
        unsigned __int8 *message@<ecx>,
        unsigned __int8 *search_string)
{
  int number; // eax
  unsigned __int8 *v8; // eax

  number = get_opt_(config_options, "document.browse.search.show_not_found")->number;
  if ( number == 1 )
  {
    beep_terminal(ses->tab->term);
  }
  else if ( number == 2 )
  {
    v8 = msg_text(ses->tab->term, message, search_string);
    info_box(ses->tab->term, MSGBOX_FREE_TEXT, title, ALIGN_CENTER, v8);
  }
}

//----- (080F8640) --------------------------------------------------------
void __usercall print_find_error(session *ses@<eax>, find_error find_error@<edx>)
{
  unsigned __int8 *v3; // eax
  int v4; // esi

  switch ( find_error )
  {
    case FIND_ERROR_NO_PREVIOUS_SEARCH:
      v3 = "No previous search";
      goto LABEL_3;
    case FIND_ERROR_HIT_TOP:
      v4 = 1;
      goto LABEL_7;
    case FIND_ERROR_HIT_BOTTOM:
      v4 = 0;
LABEL_7:
      if ( get_opt_(config_options, "document.browse.search.show_hit_top_bottom")->number )
      {
        v3 = "Search hit bottom, continuing at top.";
        if ( v4 )
          v3 = "Search hit top, continuing at bottom.";
        if ( v3 )
LABEL_3:
          info_box(ses->tab->term, (msgbox_flags)0, "Search", ALIGN_CENTER, v3);
      }
      break;
    case FIND_ERROR_NOT_FOUND:
      print_find_error_not_found(ses, "Search", "Search string '%s' not found", ses->search_word);
      break;
    case FIND_ERROR_REGEX:
      print_find_error_not_found(ses, "Search", "Could not compile regular expression '%s'", ses->search_word);
      break;
    default:
      return;
  }
}

//----- (080F8740) --------------------------------------------------------
frame_event_status __cdecl search_typeahead(session *ses, document_view *doc_view, action_id_T action_id)
{
  unsigned __int8 *v3; // ecx
  char *v4; // edx
  input_line_code (*v5)(input_line *, int); // eax
  unsigned __int8 *v7; // eax

  v3 = "#";
  if ( action_id == 95 )
  {
    v4 = (_BYTE *)("uri=\"/" + 5);
    v5 = text_typeahead_handler;
    v3 = (_BYTE *)("uri=\"/" + 5);
    goto LABEL_6;
  }
  if ( action_id == 96 )
  {
    v4 = "?";
    v5 = text_typeahead_handler;
    v3 = (unsigned __int8 *)"?";
LABEL_6:
    input_field_line(ses, v3, v4, &search_history, v5);
    return 2;
  }
  v4 = 0;
  if ( action_id == 94 )
    v4 = "#";
  v5 = link_typeahead_handler;
  if ( doc_view->document->nlinks )
    goto LABEL_6;
  v7 = msg_text(ses->tab->term, "No links in current document");
  info_box(ses->tab->term, MSGBOX_FREE_TEXT, "Typeahead", ALIGN_CENTER, v7);
  return 2;
}

//----- (080F8820) --------------------------------------------------------
int __usercall match_link_text@<eax>(
        link *link@<eax>,
        unsigned __int8 *text@<edx>,
        int textlen@<ecx>,
        int case_sensitive)
{
  link_type type; // esi
  const char *where; // ebx
  char *v7; // eax

  type = link->type;
  if ( (unsigned int)type > LINK_MAP || (where = (const char *)link->data.name) == 0 )
  {
    where = (const char *)link->where;
    if ( !where )
    {
      where = (const char *)link->where_img;
      if ( !where )
        where = &delete;
    }
    if ( (unsigned int)type > LINK_MAP )
      return -1;
  }
  if ( textlen <= strlen(where)
    && (!case_sensitive ? (v7 = (char *)strcasestr(where, text)) : (v7 = strstr(where, (const char *)text)), v7) )
  {
    return v7 - where;
  }
  else
  {
    return -1;
  }
}
// 80596D8: using guessed type int __cdecl strcasestr(_DWORD, _DWORD);

//----- (080F88B0) --------------------------------------------------------
void __usercall draw_typeahead_match(terminal *term@<eax>, document_view *doc_view@<edx>, int chars@<ecx>, int offset)
{
  view_state *vs; // eax
  int current_link; // edx
  document *document; // eax
  link *v8; // edi
  const char *name; // esi
  int v10; // ebx
  unsigned __int8 v11; // cl
  int v12; // ebx
  line *v13; // edi
  point *v14; // eax
  int y; // eax
  document *v16; // edx
  color_pair *color; // [esp+10h] [ebp-38h]
  int xoffset; // [esp+18h] [ebp-30h]
  int yoffset; // [esp+1Ch] [ebp-2Ch]
  link *link; // [esp+20h] [ebp-28h]
  int x; // [esp+28h] [ebp-20h]
  int end; // [esp+2Ch] [ebp-1Ch]

  color = get_bfu_color(term, "searched");
  vs = doc_view->vs;
  xoffset = doc_view->box.x - vs->x;
  yoffset = doc_view->box.y - vs->y;
  current_link = vs->current_link;
  if ( current_link >= 0 )
  {
    document = doc_view->document;
    if ( current_link < document->nlinks )
    {
      link = &document->links[current_link];
      v8 = link;
      if ( link->type > (unsigned int)LINK_MAP )
        goto LABEL_4;
LABEL_18:
      name = (const char *)v8->data.name;
      if ( name )
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  link = 0;
  v8 = 0;
  if ( MEMORY[4] <= 1u )
    goto LABEL_18;
LABEL_4:
  name = (const char *)link->where;
  if ( !name )
  {
    name = (const char *)link->where_img;
    if ( !name )
      name = &delete;
  }
LABEL_5:
  v10 = offset + chars;
  end = v10;
  v11 = *name;
  if ( *name && v10 > 0 )
  {
    v12 = 0;
    do
    {
      v14 = &link->points[v12];
      x = v14->x;
      y = v14->y;
      v16 = doc_view->document;
      if ( y < v16->height && (v13 = &v16->data[y], x < v13->length) && v11 == v13->chars[x].data )
      {
        if ( v12 >= offset )
          draw_char_color(term, x + xoffset, yoffset + y, color);
        ++v12;
        v11 = *++name;
        if ( end <= v12 )
          return;
      }
      else
      {
        --end;
        --offset;
        v11 = *++name;
        if ( end <= v12 )
          return;
      }
    }
    while ( v11 );
  }
}

//----- (080F8A40) --------------------------------------------------------
input_line_code __cdecl link_typeahead_handler(input_line *line, int action_id)
{
  document_view *v2; // edi
  unsigned __int8 v3; // al
  int current_link; // eax
  int v5; // ebx
  int number; // esi
  size_t v7; // eax
  int nlinks; // eax
  int v9; // edi
  int matched; // eax
  int v12; // esi
  link *v13; // ebx
  int v14; // eax
  int v15; // ebx
  int v16; // esi
  option_value *v17; // eax
  int v18; // eax
  unsigned __int8 v19; // al
  action_id_T v20; // eax
  option_value *opt; // ebx
  int v22; // eax
  bool v23; // [esp+23h] [ebp-45h]
  document_view *v24; // [esp+28h] [ebp-40h]
  document *document; // [esp+2Ch] [ebp-3Ch]
  int v26; // [esp+30h] [ebp-38h]
  link *links; // [esp+34h] [ebp-34h]
  int case_sensitive; // [esp+38h] [ebp-30h]
  int textlen; // [esp+3Ch] [ebp-2Ch]
  session *ses; // [esp+40h] [ebp-28h]
  int v31; // [esp+44h] [ebp-24h]
  unsigned __int8 *buffer; // [esp+48h] [ebp-20h]
  int v33; // [esp+4Ch] [ebp-1Ch]

  ses = line->ses;
  v2 = current_frame(line->ses);
  if ( assert_failed
    || (assert_failed = v2 == 0, !v2)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 1470,
        elinks_internal("assertion doc_view != NULL failed: document not formatted"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  v3 = line->buffer[0];
  if ( v3 )
  {
    buffer = line->buffer;
    if ( action_id != 26 )
    {
      if ( !line->data )
      {
        v19 = v3 - 35;
        if ( v19 <= 0x1Cu )
        {
          v20 = CSWTCH_247[v19];
          if ( v20 )
          {
            search_typeahead(ses, v2, v20);
            return 0;
          }
        }
        line->data = (void *)"#";
      }
      current_link = v2->vs->current_link;
      if ( current_link < 0 )
        current_link = 0;
      v26 = current_link;
      document = v2->document;
      switch ( action_id )
      {
        case 11:
        case 22:
          v23 = 1;
          v33 = 1;
          v5 = current_link + 1;
          if ( current_link + 1 < document->nlinks )
            goto LABEL_10;
          if ( !get_opt_(config_options, "document.browse.search.wraparound")->number )
            goto LABEL_63;
          v33 = 1;
          v23 = v26 != 0;
          v5 = 0;
          goto LABEL_10;
        case 14:
          goto_current_link(ses, v2, 0);
          return 0;
        case 25:
        case 29:
          v5 = current_link - 1;
          if ( current_link )
            goto LABEL_33;
          if ( get_opt_(config_options, "document.browse.search.wraparound")->number )
          {
            v5 = v2->document->nlinks - 1;
LABEL_33:
            v33 = -1;
            v23 = v26 != v5;
LABEL_10:
            case_sensitive = get_opt_(config_options, "document.browse.search.case")->number;
            number = get_opt_(config_options, "document.browse.search.wraparound")->number;
            v7 = strlen((const char *)buffer);
            textlen = v7;
            if ( !assert_failed )
            {
              if ( v7 )
              {
                assert_failed = 0;
              }
              else
              {
                assert_failed = 1;
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
                errline = 1216;
                elinks_internal("assertion textlen && direction && offset failed!");
              }
            }
            if ( v33 == 1 )
            {
              nlinks = document->nlinks;
              v31 = v5 - 1;
            }
            else
            {
              nlinks = v5 + 1;
              v31 = -1;
            }
            if ( v5 <= v31 || v5 >= nlinks )
            {
LABEL_39:
              v12 = 0;
              v5 = -1;
            }
            else
            {
              v24 = v2;
              v9 = nlinks;
              links = document->links;
              while ( 1 )
              {
                matched = match_link_text(&links[v5], buffer, textlen, case_sensitive);
                if ( matched >= 0 )
                  break;
                if ( number )
                {
                  if ( v33 == 1 )
                  {
                    if ( v5 == v9 - 1 )
                    {
                      v9 = v26 + 1;
                      number = 0;
                      v5 = -1;
                      v31 = -1;
                    }
                  }
                  else if ( v5 == v31 + 1 )
                  {
                    number = 0;
                    v5 = document->nlinks;
                    v31 = v26 - 1;
                    v9 = v5;
                  }
                }
                v5 += v33;
                if ( v5 >= v9 || v5 <= v31 )
                {
                  v2 = v24;
                  goto LABEL_39;
                }
              }
              v12 = matched;
              v2 = v24;
            }
            if ( v26 != v5 || !v23 )
            {
              if ( v5 >= 0 )
              {
                if ( !assert_failed )
                {
                  if ( v5 < v2->document->nlinks )
                  {
                    assert_failed = 0;
                  }
                  else
                  {
                    assert_failed = 1;
                    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
                    errline = 1381;
                    elinks_internal("assertion match >= 0 && match < doc_view->document->nlinks failed!");
                  }
                }
                v2->vs->current_link = v5;
                v13 = &v2->document->links[v2->vs->current_link];
                --v2->box.height;
                set_pos_x(v2, v13);
                set_pos_y(v2, v13);
                ++v2->box.height;
                draw_formatted(ses, 0);
                v14 = strlen((const char *)buffer);
                goto LABEL_46;
              }
              if ( !v23 )
                goto LABEL_59;
            }
          }
          else
          {
LABEL_63:
            v12 = 0;
            opt = get_opt_(config_options, "document.browse.search.case");
            v22 = strlen((const char *)buffer);
            if ( match_link_text(&document->links[v26], buffer, v22, opt->number) < 0 )
            {
LABEL_59:
              print_find_error_not_found(ses, "Typeahead", "Could not find a link with the text '%s'.", buffer);
              return 2;
            }
          }
          print_find_error_not_found(ses, "Typeahead", "No further matches for '%s'.", buffer);
          v14 = strlen((const char *)buffer);
LABEL_46:
          draw_typeahead_match(ses->tab->term, v2, v14, v12);
          return 1;
        default:
          v5 = current_link;
          v23 = 0;
          v33 = 1;
          goto LABEL_10;
      }
    }
    v15 = v2->vs->current_link;
    if ( v15 >= 0 )
    {
      v16 = strlen((const char *)line->buffer);
      v17 = get_opt_(config_options, "document.browse.search.case");
      v18 = match_link_text(&v2->document->links[v15], buffer, v16, v17->number);
      if ( v18 >= 0 )
      {
        draw_typeahead_match(ses->tab->term, v2, v16, v18);
        return 1;
      }
    }
  }
  else if ( line->data )
  {
    draw_formatted(ses, 0);
    return 1;
  }
  return 1;
}
// 80F8B2E: conditional instruction was optimized away because %var_1C.4 is in (==1|==FFFFFFFF)
// 810F980: using guessed type action_id_T CSWTCH_247[29];

//----- (080F9000) --------------------------------------------------------
int __usercall get_srch@<eax>(document *document@<eax>)
{
  int height; // eax
  int v3; // ecx
  line *v4; // ecx
  int x; // eax
  int length; // edx
  screen_char *chars; // ebx
  unsigned int data; // ecx
  int v9; // edx
  screen_char *v10; // esi
  int v11; // edx
  int nsearch; // edx
  search *search; // ecx
  int v14; // edx
  int v16; // edx
  int v17; // edx
  int v18; // ecx
  unsigned int v19; // ebx
  search *v20; // ebx
  int v21; // edx
  int v22; // [esp+14h] [ebp-34h]
  node *node; // [esp+18h] [ebp-30h]
  int v24; // [esp+1Ch] [ebp-2Ch]
  int count; // [esp+20h] [ebp-28h]
  int y; // [esp+24h] [ebp-24h]
  int v27; // [esp+28h] [ebp-20h]
  search *v28; // [esp+2Ch] [ebp-1Ch]
  screen_char *v29; // [esp+2Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_28;
  if ( document && !document->nsearch )
  {
    assert_failed = 0;
    goto LABEL_5;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
  errline = 153;
  elinks_internal("assertion document && document->nsearch == 0 failed!");
  if ( assert_failed )
  {
LABEL_28:
    assert_failed = 0;
    return 0;
  }
LABEL_5:
  node = (node *)document->nodes.prev;
  if ( node != (node *)&document->nodes )
  {
    while ( 1 )
    {
      height = document->height;
      v3 = node->box.y;
      y = v3;
      if ( v3 + node->box.height <= height )
        height = v3 + node->box.height;
      v22 = height;
      if ( v3 < height )
        break;
LABEL_26:
      node = node->prev;
      if ( node == (node *)&document->nodes )
        return document->nsearch;
    }
    v27 = v3;
    while ( 1 )
    {
      v4 = &document->data[v27];
      x = node->box.x;
      length = v4->length;
      if ( x + node->box.width <= length )
        length = x + node->box.width;
      v24 = length;
      if ( x < length )
        break;
LABEL_18:
      v11 = assert_failed;
LABEL_19:
      if ( v11 )
      {
        assert_failed = 0;
        goto LABEL_25;
      }
      assert_failed = 0;
      nsearch = document->nsearch;
      if ( nsearch )
      {
        search = document->search;
        if ( !search )
          goto LABEL_24;
        if ( search[nsearch - 1].c != 32 )
        {
          v14 = nsearch;
          search[v14].c = 32;
          document->search[v14].x = x;
          document->search[v14].y = y;
          document->search[v14].n = 0;
          nsearch = document->nsearch;
LABEL_24:
          document->nsearch = nsearch + 1;
        }
      }
LABEL_25:
      ++y;
      ++v27;
      if ( y >= v22 )
        goto LABEL_26;
    }
    chars = v4->chars;
    data = v4->chars[x].data;
    if ( data <= 0x20 )
    {
      v9 = x + 1;
      v10 = &chars[x + 1];
      while ( 1 )
      {
        x = v9;
        if ( v9 >= v24 )
          goto LABEL_18;
        data = v10->data;
        ++v10;
        if ( data > 0x20 )
          break;
        ++v9;
      }
    }
    v11 = assert_failed;
    while ( 1 )
    {
      if ( (chars[x].attr & 1) != 0 || data == -3 )
        goto LABEL_38;
      if ( data <= 0x20 )
        break;
      if ( v11 )
      {
        assert_failed = 0;
        v11 = 0;
      }
      else
      {
        assert_failed = 0;
        v20 = document->search;
        if ( v20 )
        {
          v21 = document->nsearch;
          v20[v21].c = data;
          document->search[v21].x = x;
          document->search[v21].y = y;
          document->search[v21].n = 1;
        }
        ++document->nsearch;
        v11 = assert_failed;
      }
LABEL_39:
      if ( ++x >= v24 )
        goto LABEL_19;
      chars = document->data[v27].chars;
      data = chars[x].data;
    }
    v18 = x + 1;
    if ( x + 1 < v24 )
    {
      v29 = &chars[x + 2];
      if ( chars[v18].data > 0x1F )
      {
LABEL_48:
        count = v18 - x;
        goto LABEL_49;
      }
      while ( ++v18 < v24 )
      {
        v19 = v29->data;
        ++v29;
        if ( v19 > 0x1F )
          goto LABEL_48;
      }
    }
    count = 0;
LABEL_49:
    if ( v11 )
    {
      assert_failed = 0;
      goto LABEL_37;
    }
    assert_failed = 0;
    v16 = document->nsearch;
    if ( v16 )
    {
      v28 = document->search;
      if ( !v28 )
      {
LABEL_36:
        document->nsearch = v16 + 1;
        goto LABEL_37;
      }
      if ( v28[v16 - 1].c != 32 )
      {
        v17 = v16;
        v28[v17].c = 32;
        document->search[v17].x = x;
        document->search[v17].y = y;
        document->search[v17].n = count;
        v16 = document->nsearch;
        goto LABEL_36;
      }
    }
LABEL_37:
    x = v18 - 1;
LABEL_38:
    v11 = assert_failed;
    goto LABEL_39;
  }
  return document->nsearch;
}

//----- (080F9390) --------------------------------------------------------
void __usercall get_search_data(document *document@<eax>)
{
  int srch; // eax
  search *v3; // eax
  int nsearch; // eax
  int v5; // edx
  search *search; // ecx
  unicode_val_T c; // ecx
  search **v8; // eax
  search **v9; // eax
  int i; // eax
  int v11; // edx
  search *v12; // eax
  int y; // ecx
  int *v14; // ecx
  _DWORD *v15; // [esp+14h] [ebp-24h]
  _DWORD *p; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = document == 0, !document)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 211,
        elinks_internal("assertion document failed!"),
        assert_failed) )
  {
LABEL_6:
    assert_failed = 0;
    return;
  }
  if ( !document->search )
  {
    srch = get_srch(document);
    if ( srch )
    {
      document->nsearch = 0;
      v3 = (search *)mem_alloc(16 * srch);
      document->search = v3;
      if ( v3 )
      {
        get_srch(document);
        nsearch = document->nsearch;
        v5 = nsearch - 1;
        do
        {
          if ( !nsearch )
            break;
          search = document->search;
          document->nsearch = --nsearch;
          c = search[v5--].c;
        }
        while ( c == 32 );
        if ( assert_failed )
          goto LABEL_6;
        assert_failed = 0;
        v8 = (search **)mem_calloc(document->height, 4u);
        document->slines1 = v8;
        if ( v8 )
        {
          v9 = (search **)mem_calloc(document->height, 4u);
          document->slines2 = v9;
          if ( v9 )
          {
            p = mem_calloc(document->height, 4u);
            if ( p )
            {
              v15 = mem_calloc(document->height, 4u);
              if ( v15 )
              {
                for ( i = 0; i < document->height; ++i )
                {
                  p[i] = 0x7FFFFFFF;
                  v15[i] = 0;
                }
                if ( document->nsearch > 0 )
                {
                  v11 = 0;
                  do
                  {
                    v12 = &document->search[v11];
                    v17 = v12->x + v12->n;
                    y = v12->y;
                    if ( v12->x < p[y] )
                    {
                      p[y] = v12->x;
                      document->slines1[v12->y] = v12;
                      y = v12->y;
                    }
                    v14 = &v15[y];
                    if ( v17 > *v14 )
                    {
                      *v14 = v17;
                      document->slines2[v12->y] = v12;
                    }
                    ++v11;
                  }
                  while ( v11 < document->nsearch );
                }
                mem_free(p);
                mem_free(v15);
              }
              else
              {
                mem_free(document->slines1);
                mem_free(document->slines2);
                mem_free(p);
              }
            }
            else
            {
              mem_free(document->slines1);
              mem_free(document->slines2);
            }
          }
          else
          {
            mem_free(document->slines1);
          }
        }
      }
    }
  }
}

//----- (080F9630) --------------------------------------------------------
void __usercall get_searched(document_view *doc_view@<eax>, point **pt@<edx>, int *pl@<ecx>, int utf8)
{
  unsigned __int8 **search_word; // eax
  unsigned __int8 *v6; // eax
  view_state *vs; // eax
  int v8; // edi
  search *v9; // ebx
  int v10; // esi
  __int32_t c; // eax
  search *v12; // edx
  int v13; // edi
  wint_t v14; // eax
  search *v15; // edi
  int v16; // eax
  int y; // edx
  int v18; // ebx
  int v19; // eax
  unsigned int v20; // eax
  int v21; // ecx
  int v22; // edx
  int x; // ecx
  __int32_t v24; // edi
  wint_t v25; // ecx
  const __int32_t **v26; // eax
  point *v27; // [esp+1Ch] [ebp-6Ch]
  unicode_val_T v28; // [esp+24h] [ebp-64h]
  search *v29; // [esp+28h] [ebp-60h]
  search *v30; // [esp+28h] [ebp-60h]
  int v31; // [esp+28h] [ebp-60h]
  search *v32; // [esp+2Ch] [ebp-5Ch]
  int v33; // [esp+30h] [ebp-58h]
  unsigned int v34; // [esp+34h] [ebp-54h]
  size_t v35; // [esp+34h] [ebp-54h]
  int v36; // [esp+38h] [ebp-50h]
  int v37; // [esp+3Ch] [ebp-4Ch]
  int l; // [esp+40h] [ebp-48h]
  search *v39; // [esp+44h] [ebp-44h]
  search *v41; // [esp+4Ch] [ebp-3Ch]
  unsigned int v42; // [esp+4Ch] [ebp-3Ch]
  int number; // [esp+54h] [ebp-34h]
  document_view *v45; // [esp+58h] [ebp-30h]
  unicode_val_T *p; // [esp+5Ch] [ebp-2Ch]
  point *v47; // [esp+64h] [ebp-24h]
  search *s2; // [esp+68h] [ebp-20h] BYREF
  search *s1; // [esp+6Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_11;
  if ( !doc_view || !pt || !doc_view->vs || !pl )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 766;
    elinks_internal("assertion doc_view && doc_view->vs && pt && pl failed!");
    if ( !assert_failed )
      goto LABEL_6;
LABEL_11:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_6:
  search_word = doc_view->search_word;
  if ( search_word )
  {
    v6 = *search_word;
    if ( v6 )
    {
      if ( *v6 )
      {
        get_search_data(doc_view->document);
        l = strlen_u(*doc_view->search_word, utf8);
        if ( get_range(doc_view->document, doc_view->vs->y, doc_view->box.height, l, &s1, &s2) )
        {
          *pt = 0;
          *pl = 0;
          return;
        }
        v47 = 0;
        v39 = s2;
        v41 = s1;
        number = get_opt_(config_options, "document.browse.search.case")->number;
        p = number ? memacpy_u(*doc_view->search_word, l, utf8) : lowered_string(*doc_view->search_word, l, utf8);
        if ( p )
        {
          vs = doc_view->vs;
          v8 = 0;
          v37 = doc_view->box.x - vs->x;
          v33 = doc_view->box.y - vs->y;
          if ( v39 >= v41 )
          {
            v45 = doc_view;
            v9 = v41;
            v10 = 0;
            if ( !number )
              goto LABEL_25;
LABEL_20:
            c = v9->c;
LABEL_21:
            if ( *p != c )
            {
LABEL_22:
              v8 = v10;
              goto LABEL_23;
            }
LABEL_27:
            if ( l > 1 )
            {
              v12 = v9;
              v13 = 1;
              while ( 1 )
              {
                if ( number )
                {
                  v14 = v12[1].c;
                }
                else if ( utf8 )
                {
                  v29 = v12;
                  v14 = towlower(v12[1].c);
                  v12 = v29;
                }
                else
                {
                  v25 = v12[1].c;
                  if ( v25 + 128 <= 0x17F )
                  {
                    v30 = v12;
                    v28 = v12[1].c;
                    v26 = __ctype_tolower_loc();
                    v12 = v30;
                    v25 = (*v26)[v28];
                  }
                  v14 = v25;
                }
                if ( p[v13] != v14 )
                  goto LABEL_22;
                ++v13;
                ++v12;
                if ( l <= v13 )
                  goto LABEL_33;
              }
            }
            if ( l <= 0 )
              goto LABEL_22;
LABEL_33:
            v36 = 0;
            v15 = v9;
            v32 = v9;
            while ( 1 )
            {
              v16 = v15->y + v33;
              y = v45->box.y;
              if ( v16 >= y && v16 < v45->box.height + y && v15->n > 0 )
                break;
              v21 = v10;
LABEL_57:
              ++v36;
              ++v15;
              if ( l <= v36 )
              {
                v8 = v21;
                v9 = v32;
LABEL_23:
                if ( v39 < ++v9 )
                  goto LABEL_51;
                v10 = v8;
                if ( number )
                  goto LABEL_20;
LABEL_25:
                if ( !utf8 )
                {
                  v24 = v9->c;
                  if ( (unsigned int)(v24 + 128) <= 0x17F )
                    v24 = (*__ctype_tolower_loc())[v24];
                  c = v24;
                  goto LABEL_21;
                }
                if ( *p != towlower(v9->c) )
                  goto LABEL_22;
                goto LABEL_27;
              }
              v10 = v21;
            }
            v18 = 0;
            while ( 1 )
            {
              v22 = v18 + v15->x;
              x = v45->box.x;
              if ( v22 + v37 < x || v22 + v37 >= v45->box.width + x )
                goto LABEL_45;
              v19 = v10 + 256;
              LOBYTE(v19) = 0;
              v34 = v19;
              v20 = v10 + 255;
              LOBYTE(v20) = 0;
              v21 = v10 + 1;
              v42 = v20;
              if ( v34 > v20 )
              {
                v35 = 8 * v34;
                v31 = v18 + v15->x;
                v27 = (point *)mem_realloc(v47, v35);
                if ( !v27 )
                  goto LABEL_45;
                v47 = v27;
                memset(&v27[v42], 0, v35 - 8 * v42);
                v21 = v10 + 1;
                v22 = v31;
              }
              if ( v47 )
              {
                v47[v10].x = v22;
                v47[v10].y = v15->y;
                goto LABEL_42;
              }
LABEL_45:
              v21 = v10;
LABEL_42:
              if ( ++v18 >= v15->n )
                goto LABEL_57;
              v10 = v21;
            }
          }
LABEL_51:
          mem_free(p);
          *pt = v47;
          *pl = v8;
        }
      }
    }
  }
}

//----- (080F9A30) --------------------------------------------------------
int __usercall find_next_link_in_search@<eax>(document_view *doc_view@<eax>, int direction@<edx>)
{
  int current_link; // ebx
  int result; // eax
  link *v5; // ebx
  int v6; // edx
  point *v7; // ebx
  int i; // ecx
  int v9; // eax
  int v10; // edi
  int x; // ecx
  int v12; // eax
  int j; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // eax
  int v18; // [esp+14h] [ebp-44h]
  point *p; // [esp+1Ch] [ebp-3Ch]
  int npoints; // [esp+20h] [ebp-38h]
  point *points; // [esp+24h] [ebp-34h]
  bool v23; // [esp+2Fh] [ebp-29h]
  int len; // [esp+38h] [ebp-20h] BYREF
  point *pt; // [esp+3Ch] [ebp-1Ch] BYREF

  v23 = (*((_BYTE *)&doc_view->document->options + 92) & 0x10) != 0;
  if ( assert_failed )
    goto LABEL_28;
  if ( !doc_view->vs )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 958;
    elinks_internal("assertion doc_view && doc_view->vs failed!");
    if ( !assert_failed )
      goto LABEL_4;
LABEL_28:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_4:
  if ( direction != 2 && direction != -2 )
    goto LABEL_34;
  direction /= 2;
  if ( direction < 0 )
    find_link_page_up(doc_view);
  else
    find_link_page_down(doc_view);
  current_link = doc_view->vs->current_link;
  result = 1;
  if ( current_link != -1 )
  {
    while ( 1 )
    {
      v5 = &doc_view->document->links[current_link];
      get_searched(doc_view, &pt, &len, v23);
      v6 = len;
      npoints = v5->npoints;
      points = v5->points;
      v7 = pt;
      p = pt;
      if ( assert_failed )
        goto LABEL_31;
      assert_failed = points == 0;
      if ( !points )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
        errline = 916;
        v18 = len;
        elinks_internal("assertion p2 failed!");
        v6 = v18;
        if ( assert_failed )
        {
          v7 = pt;
LABEL_31:
          assert_failed = 0;
          goto LABEL_32;
        }
        p = pt;
      }
      if ( first_time_9390 )
      {
        memset(hash_9389, 0, sizeof(hash_9389));
        first_time_9390 = 0;
      }
      if ( v6 > 0 )
      {
        for ( i = 0; i != v6; ++i )
        {
          v9 = v7[i].x + (v7[i].y << 6);
          hash_9389[v9 & 0xFFF] = 1;
        }
      }
      if ( npoints > 0 )
      {
        v10 = 0;
        while ( 1 )
        {
          x = points[v10].x;
          if ( hash_9389[((_WORD)x + ((unsigned __int16)points[v10].y << 6)) & 0xFFF] )
          {
            if ( v6 > 0 )
              break;
          }
LABEL_40:
          if ( npoints <= ++v10 )
            goto LABEL_41;
        }
        v12 = 0;
        while ( x != v7[v12].x || points[v10].y != v7[v12].y )
        {
          if ( v6 <= ++v12 )
            goto LABEL_40;
        }
        for ( j = 0; j != v6; ++j )
        {
          v14 = v7[j].x + (v7[j].y << 6);
          hash_9389[v14 & 0xFFF] = 0;
        }
        mem_free(p);
        return 0;
      }
LABEL_41:
      v16 = 0;
      if ( v6 > 0 )
      {
        do
        {
          v17 = v7[v16].x + (v7[v16].y << 6);
          ++v16;
          hash_9389[v17 & 0xFFF] = 0;
        }
        while ( v16 != v6 );
      }
      v7 = p;
LABEL_32:
      if ( v7 )
        mem_free(v7);
LABEL_34:
      v15 = doc_view->vs->current_link;
      if ( v15 == -1 || !next_link_in_view(doc_view, direction + v15, direction) )
      {
        if ( direction < 0 )
          find_link_page_up(doc_view);
        else
          find_link_page_down(doc_view);
        return 1;
      }
      pt = 0;
      current_link = doc_view->vs->current_link;
    }
  }
  return result;
}
// 8148BF4: using guessed type int first_time_9390;

//----- (080F9D60) --------------------------------------------------------
void __cdecl draw_searched(terminal *term, document_view *doc_view)
{
  unsigned __int8 **search_word; // eax
  unsigned __int8 *v3; // eax
  color_pair *bfu_color; // edx
  view_state *vs; // eax
  int v6; // edi
  int v7; // ebx
  color_pair *v8; // esi
  int v9; // eax
  int yoffset; // [esp+1Ch] [ebp-2Ch]
  int len; // [esp+28h] [ebp-20h] BYREF
  point *pt; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( assert_failed
    || (pt = 0, len = 0, (assert_failed = term == 0 || doc_view == 0) != 0)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 798,
        elinks_internal("assertion term && doc_view failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    search_word = doc_view->search_word;
    if ( search_word )
    {
      v3 = *search_word;
      if ( v3 )
      {
        if ( *v3 )
        {
          get_searched(doc_view, &pt, &len, (*((_BYTE *)&doc_view->document->options + 92) & 0x10) != 0);
          if ( len )
          {
            bfu_color = get_bfu_color(term, "searched");
            vs = doc_view->vs;
            v6 = doc_view->box.x - vs->x;
            yoffset = doc_view->box.y - vs->y;
            if ( len > 0 )
            {
              v7 = 0;
              v8 = bfu_color;
              do
              {
                v9 = v7++;
                draw_char_color(term, v6 + pt[v9].x, pt[v9].y + yoffset, v8);
              }
              while ( len > v7 );
            }
          }
          if ( pt )
            mem_free(pt);
        }
      }
    }
  }
}

//----- (080F9EC0) --------------------------------------------------------
char __usercall find_next_do@<al>(session *ses@<eax>, document_view *doc_view@<edx>, int direction@<ecx>)
{
  window *tab; // eax
  int height; // esi
  document *document; // ebx
  char result; // al
  int v7; // edx
  int v8; // edi
  int v9; // eax
  search *v10; // ebx
  int number; // edi
  int v12; // esi
  unsigned __int8 *v13; // eax
  int v14; // eax
  search *v15; // edx
  int v16; // ecx
  int v17; // eax
  unicode_val_T v18; // eax
  __int32_t v19; // edx
  wint_t v20; // eax
  int v21; // eax
  int v22; // ecx
  search *v23; // edx
  int x; // edi
  int n; // eax
  const __int32_t **v26; // eax
  int v27; // ebx
  view_state *vs; // edx
  int v29; // eax
  unsigned __int8 *v30; // eax
  int v31; // [esp+20h] [ebp-78h]
  int v32; // [esp+20h] [ebp-78h]
  int v33; // [esp+20h] [ebp-78h]
  unicode_val_T v34; // [esp+24h] [ebp-74h]
  search *v35; // [esp+24h] [ebp-74h]
  search *v36; // [esp+24h] [ebp-74h]
  int v37; // [esp+28h] [ebp-70h]
  int v38; // [esp+2Ch] [ebp-6Ch]
  int hit_top; // [esp+30h] [ebp-68h]
  int v40; // [esp+34h] [ebp-64h]
  int in_range; // [esp+38h] [ebp-60h]
  int hit_bottom; // [esp+3Ch] [ebp-5Ch]
  int v43; // [esp+40h] [ebp-58h]
  int v44; // [esp+44h] [ebp-54h]
  __int32_t v45; // [esp+44h] [ebp-54h]
  int step; // [esp+48h] [ebp-50h]
  unicode_val_T *v48; // [esp+50h] [ebp-48h]
  int c; // [esp+58h] [ebp-40h]
  int l; // [esp+5Ch] [ebp-3Ch]
  search *v52; // [esp+60h] [ebp-38h]
  _BOOL4 utf8; // [esp+64h] [ebp-34h]
  int y; // [esp+68h] [ebp-30h]
  unsigned __int8 *text; // [esp+6Ch] [ebp-2Ch]
  unsigned __int8 *texta; // [esp+6Ch] [ebp-2Ch]
  search *s2; // [esp+78h] [ebp-20h] BYREF
  search *s1; // [esp+7Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_13;
  if ( ses )
  {
    tab = ses->tab;
    if ( tab )
    {
      if ( doc_view && tab->term && direction && doc_view->vs )
      {
        assert_failed = 0;
        goto LABEL_7;
      }
    }
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
  errline = 1005;
  v31 = direction;
  elinks_internal("assertion ses && ses->tab && ses->tab->term && doc_view && doc_view->vs && direction failed!");
  direction = v31;
  if ( assert_failed )
  {
LABEL_13:
    assert_failed = 0;
    return 0;
  }
LABEL_7:
  v43 = ses->search_direction * direction;
  y = doc_view->vs->y;
  height = doc_view->box.height;
  step = height * v43;
  if ( !ses->search_word )
    goto LABEL_80;
  if ( !find_next_link_in_search(doc_view, v43) )
    return 0;
  y += step;
  if ( !ses->search_word )
  {
LABEL_80:
    result = 1;
    if ( !ses->last_search_word )
      return result;
    v30 = stracpy(ses->last_search_word);
    ses->search_word = v30;
    if ( v30 )
      goto LABEL_10;
    return 0;
  }
LABEL_10:
  get_search_data(doc_view->document);
  document = doc_view->document;
  hit_top = 0;
  hit_bottom = 0;
  c = 0;
  while ( 1 )
  {
    text = ses->search_word;
    if ( assert_failed )
      goto LABEL_12;
    if ( document && ses->search_word )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
      errline = 599;
      elinks_internal("assertion document && text && min && max failed!");
      if ( assert_failed )
      {
LABEL_12:
        assert_failed = 0;
        return 5;
      }
    }
    utf8 = (*((_BYTE *)&document->options + 92) & 0x10) != 0;
    l = strlen_u(text, utf8);
    if ( get_range(document, y, height, l, &s1, &s2) )
      goto LABEL_19;
    v10 = s1;
    v38 = height + y;
    v52 = s2;
    number = get_opt_(config_options, "document.browse.search.case")->number;
    if ( number )
    {
      v48 = memacpy_u(text, l, utf8);
      if ( !v48 )
        return 5;
    }
    else
    {
      v48 = lowered_string(text, l, utf8);
      if ( !v48 )
        return 5;
    }
    if ( v52 < v10 )
    {
      mem_free(v48);
      goto LABEL_19;
    }
    v40 = height;
    v37 = 0x7FFFFFFF;
    in_range = 0;
    texta = (unsigned __int8 *)*v48;
    v12 = 0;
    if ( number )
      goto LABEL_31;
    while ( 1 )
    {
      if ( !utf8 )
      {
        v19 = v10->c;
        if ( (unsigned int)(v19 + 128) <= 0x17F )
        {
          v34 = v10->c;
          v19 = (*__ctype_tolower_loc())[v34];
        }
        v13 = (unsigned __int8 *)v19;
LABEL_32:
        if ( v13 != texta )
          goto LABEL_33;
        goto LABEL_38;
      }
      if ( (unsigned __int8 *)towlower(v10->c) != texta )
        goto LABEL_33;
LABEL_38:
      v15 = v10;
      v16 = 1;
      v17 = 1;
      if ( l > 1 )
      {
        while ( 1 )
        {
          if ( number )
          {
            v18 = v15[1].c;
          }
          else
          {
            if ( utf8 )
            {
              v35 = v15;
              v32 = v16;
              v20 = towlower(v15[1].c);
              v16 = v32;
              v15 = v35;
              if ( v48[v32] != v20 )
                goto LABEL_33;
              goto LABEL_48;
            }
            v45 = v15[1].c;
            if ( (unsigned int)(v45 + 128) <= 0x17F )
            {
              v36 = v15;
              v33 = v16;
              v26 = __ctype_tolower_loc();
              v16 = v33;
              v15 = v36;
              v45 = (*v26)[v45];
            }
            v18 = v45;
          }
          if ( v48[v16] != v18 )
            goto LABEL_33;
LABEL_48:
          ++v16;
          ++v15;
          if ( l <= v16 )
          {
            v17 = v16;
            break;
          }
        }
      }
      v21 = v10[v17].y;
      if ( y > v21 || v38 <= v21 )
      {
LABEL_33:
        v14 = v12;
        goto LABEL_34;
      }
      v22 = 0;
      v23 = v10;
      v14 = v12;
      in_range = 1;
      if ( l > 0 )
      {
        v44 = number;
        x = v37;
        n = v10->n;
        if ( !n )
          goto LABEL_59;
        while ( 1 )
        {
          v14 = v23->x + n;
          if ( x > v23->x )
            x = v23->x;
          if ( v14 <= v12 )
            goto LABEL_59;
          while ( 1 )
          {
            ++v22;
            ++v23;
            if ( v22 == l )
            {
              v37 = x;
              number = v44;
              in_range = 1;
              goto LABEL_34;
            }
            v12 = v14;
            n = v23->n;
            if ( n )
              break;
LABEL_59:
            v14 = v12;
          }
        }
      }
LABEL_34:
      if ( v52 < ++v10 )
        break;
      v12 = v14;
      if ( number )
      {
LABEL_31:
        v13 = (unsigned __int8 *)v10->c;
        goto LABEL_32;
      }
    }
    v27 = v14;
    height = v40;
    mem_free(v48);
    if ( in_range )
      break;
LABEL_19:
    y += step;
    document = doc_view->document;
    v7 = document->height;
    if ( y <= v7 )
    {
      if ( y < 0 )
      {
        v8 = 0;
        v9 = height;
        if ( v7 > 0 )
        {
          do
          {
            v8 = v9;
            v9 += height;
          }
          while ( v7 > v9 - height );
        }
        y = v8 - height;
        hit_top = 1;
      }
    }
    else
    {
      hit_bottom = 1;
      y = 0;
    }
    c += height;
    if ( height + v7 <= c )
      return 4;
  }
  doc_view->vs->y = y;
  if ( v27 >= v37 )
  {
    vs = doc_view->vs;
    v29 = v27 - doc_view->box.width;
    if ( v29 < vs->x )
      v29 = vs->x;
    if ( v29 > v37 )
      v29 = v37;
    vs->x = v29;
  }
  set_link(doc_view);
  find_next_link_in_search(doc_view, 2 * v43);
  result = 2;
  if ( !hit_top )
  {
    result = 3;
    if ( !hit_bottom )
      return 0;
  }
  return result;
}

//----- (080FA440) --------------------------------------------------------
find_error __usercall search_for_do@<eax>(
        session *ses@<eax>,
        unsigned __int8 *str@<edx>,
        int direction@<ecx>,
        int report_errors)
{
  document_view *v6; // edi
  unsigned __int8 *last_search_word; // eax
  find_error v8; // esi
  unsigned __int8 *v10; // eax
  find_error v11; // eax

  if ( assert_failed )
    goto LABEL_12;
  assert_failed = ses == 0 || str == 0;
  if ( ses == 0 || str == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
    errline = 858;
    elinks_internal("assertion ses && str failed!");
    if ( assert_failed )
      goto LABEL_12;
  }
  v6 = current_frame(ses);
  if ( assert_failed
    || (assert_failed = v6 == 0, !v6)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 863,
        elinks_internal("assertion doc_view failed!"),
        assert_failed) )
  {
LABEL_12:
    assert_failed = 0;
    return 4;
  }
  else
  {
    if ( ses->search_word )
      mem_free(ses->search_word);
    last_search_word = ses->last_search_word;
    ses->search_word = 0;
    if ( last_search_word )
      mem_free(last_search_word);
    ses->last_search_word = 0;
    if ( *str && (v10 = stracpy(str), (ses->last_search_word = v10) != 0) )
    {
      ses->search_direction = direction;
      LOBYTE(v11) = find_next_do(ses, v6, 1);
      v8 = v11;
      if ( report_errors )
        print_find_error(ses, v11);
    }
    else
    {
      return 4;
    }
  }
  return v8;
}
// 80FA56B: variable 'v11' is possibly undefined

//----- (080FA5C0) --------------------------------------------------------
void __cdecl search_for_back(session *ses, unsigned __int8 *str)
{
  session *v2; // eax
  unsigned __int8 *v3; // edx

  v2 = ses;
  v3 = str;
  if ( assert_failed
    || (assert_failed = ses == 0 || str == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 890,
        elinks_internal("assertion ses && str failed!"),
        v2 = ses,
        v3 = str,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    search_for_do(v2, v3, -1, 1);
  }
}

//----- (080FA650) --------------------------------------------------------
void __cdecl search_for(session *ses, unsigned __int8 *str)
{
  session *v2; // eax
  unsigned __int8 *v3; // edx

  v2 = ses;
  v3 = str;
  if ( assert_failed
    || (assert_failed = ses == 0 || str == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 899,
        elinks_internal("assertion ses && str failed!"),
        v2 = ses,
        v3 = str,
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    search_for_do(v2, v3, 1, 1);
  }
}

//----- (080FA6E0) --------------------------------------------------------
frame_event_status __cdecl find_next(session *ses, document_view *doc_view, int direction)
{
  find_error v3; // eax

  LOBYTE(v3) = find_next_do(ses, doc_view, direction);
  print_find_error(ses, v3);
  return 1;
}
// 80FA6FB: variable 'v3' is possibly undefined

//----- (080FA710) --------------------------------------------------------
input_line_code __cdecl text_typeahead_handler(input_line *line, int action_id)
{
  session *ses; // edi
  document_view *v3; // eax
  int v4; // esi
  find_error v5; // eax
  find_error v6; // esi
  input_line_code result; // eax
  option_elinks *opt_rec; // eax
  unsigned __int8 *buffer; // [esp+1Ch] [ebp-1Ch]

  ses = line->ses;
  v3 = current_frame(line->ses);
  v4 = 2 * (*(_BYTE *)line->data == 47) - 1;
  if ( assert_failed
    || (assert_failed = v3 == 0, !v3)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 1403,
        elinks_internal("assertion doc_view != NULL failed: document not formatted"),
        v3 = 0,
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  else
  {
    buffer = line->buffer;
    switch ( action_id )
    {
      case 14:
        result = INPUT_LINE_CANCEL;
        if ( !line->buffer[0] )
        {
          search_for_do(ses, buffer, v4, 0);
          return 0;
        }
        return result;
      case 22:
        find_next(ses, v3, 1);
        goto LABEL_10;
      case 25:
        find_next(ses, v3, -1);
        goto LABEL_10;
      case 26:
        goto LABEL_11;
      case 28:
        opt_rec = get_opt_rec(config_options, "document.browse.search.regex");
        if ( opt_rec )
        {
          opt_rec->value.number = (opt_rec->value.number + 1) % (opt_rec->max + 1);
          option_changed(ses, opt_rec);
        }
        goto LABEL_4;
      default:
LABEL_4:
        v5 = search_for_do(ses, buffer, v4, 0);
        v6 = v5;
        if ( v5 == FIND_ERROR_REGEX )
          goto LABEL_10;
        if ( action_id == -1 )
          print_find_error(ses, v5);
        if ( (unsigned int)(v6 - 2) <= 1 || v6 == FIND_ERROR_NONE || (result = INPUT_LINE_REWIND, !line->buffer[0]) )
        {
LABEL_10:
          draw_formatted(ses, 0);
LABEL_11:
          result = INPUT_LINE_PROCEED;
        }
        break;
    }
  }
  return result;
}

//----- (080FA8F0) --------------------------------------------------------
frame_event_status __cdecl search_dlg(session *ses, document_view *doc_view, int direction)
{
  unsigned __int8 *v3; // edi
  void (__cdecl *v4)(session *, unsigned __int8 *); // eax
  terminal *term; // esi
  int terminal_codepage; // eax
  unsigned __int8 *cp_mime_name; // eax
  option_elinks *opt_rec; // eax
  dialog *v9; // ebx
  int v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  int v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  int v18; // eax
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // eax
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // eax
  bool v25; // zf
  int v26; // [esp+3Ch] [ebp-3Ch]
  int v27; // [esp+3Ch] [ebp-3Ch]
  int v28; // [esp+3Ch] [ebp-3Ch]
  int v29; // [esp+3Ch] [ebp-3Ch]
  int v30; // [esp+3Ch] [ebp-3Ch]
  int v31; // [esp+3Ch] [ebp-3Ch]
  unsigned __int8 *label; // [esp+40h] [ebp-38h]
  int *data; // [esp+44h] [ebp-34h]
  void (__cdecl *search_function)(session *, unsigned __int8 *); // [esp+48h] [ebp-30h]
  option_value *p; // [esp+4Ch] [ebp-2Ch]
  memory_list *ml[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  if ( assert_failed
    || (assert_failed = direction == 0, !direction)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c",
        errline = 1725,
        elinks_internal("assertion direction failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 2;
  }
  else
  {
    v3 = "Search";
    if ( direction <= 0 )
      v3 = "Search backward";
    v4 = search_for_back;
    if ( direction > 0 )
      v4 = search_for;
    search_function = v4;
    term = ses->tab->term;
    ml[0] = 0;
    if ( term )
    {
      terminal_codepage = get_terminal_codepage(term);
      if ( terminal_codepage != current_charset )
      {
        v26 = terminal_codepage;
        cp_mime_name = get_cp_mime_name(terminal_codepage);
        bind_textdomain_codeset("elinks", cp_mime_name);
        current_charset = v26;
      }
    }
    label = gettext(&byte_8135628);
    p = (option_value *)mem_calloc(1u, 8u);
    if ( p )
    {
      opt_rec = get_opt_rec(config_options, "document.browse.search");
      data = (int *)&p[1];
      checkout_option_values(resolvers_0, opt_rec, p + 1, 1);
      p->number = (int)ses;
      v9 = (dialog *)mem_calloc(1u, 0x514u);
      if ( v9 )
      {
        if ( *v3 )
        {
          if ( term )
          {
            v10 = get_terminal_codepage(term);
            if ( v10 != current_charset )
            {
              v27 = v10;
              v11 = get_cp_mime_name(v10);
              bind_textdomain_codeset("elinks", v11);
              current_charset = v27;
            }
          }
          v3 = gettext(v3);
        }
        *(_BYTE *)&v9->layout |= 0xCu;
        v9->title = v3;
        v9->layouter = generic_dialog_layouter;
        v9->udata = label;
        v9->udata2 = p;
        add_to_ml(ml, p, 0);
        add_dlg_field_do(v9, WIDGET_FIELD, label, 0, 0, 0, 1024, &v9[3].abort, &search_history, INPFIELD_NONE);
        if ( term )
        {
          v12 = get_terminal_codepage(term);
          if ( v12 != current_charset )
          {
            v28 = v12;
            v13 = get_cp_mime_name(v12);
            bind_textdomain_codeset("elinks", v13);
            current_charset = v28;
          }
        }
        v14 = gettext(&byte_8135638);
        add_dlg_radio_do(v9, v14, 2, 1, data);
        if ( term )
        {
          v15 = get_terminal_codepage(term);
          if ( v15 != current_charset )
          {
            v29 = v15;
            v16 = get_cp_mime_name(v15);
            bind_textdomain_codeset("elinks", v16);
            current_charset = v29;
          }
        }
        v17 = gettext(&byte_8135647);
        add_dlg_radio_do(v9, v17, 2, 0, data);
        if ( term )
        {
          v18 = get_terminal_codepage(term);
          if ( v18 != current_charset )
          {
            v30 = v18;
            v19 = get_cp_mime_name(v18);
            bind_textdomain_codeset("elinks", v19);
            current_charset = v30;
          }
        }
        v20 = gettext(&okbutton);
        add_dlg_button_do(v9, v20, 1, search_dlg_ok, search_function, 0, 0);
        if ( term )
        {
          v21 = get_terminal_codepage(term);
          if ( v21 != current_charset )
          {
            v31 = v21;
            v22 = get_cp_mime_name(v21);
            bind_textdomain_codeset("elinks", v22);
            current_charset = v31;
          }
        }
        v23 = gettext(&cancelbutton);
        add_dlg_button_do(v9, v23, 2, search_dlg_cancel, 0, 0, 0);
        if ( !assert_failed )
        {
          v25 = v9->number_of_widgets == 5;
          assert_failed = v9->number_of_widgets != 5;
          if ( !v25 )
          {
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/search.c";
            errline = 1713;
            elinks_internal("assertion 5 == (dlg)->number_of_widgets failed!");
          }
        }
        add_to_ml(ml, v9, 0);
        do_dialog(term, v9, ml[0]);
      }
      else
      {
        mem_free(p);
      }
    }
    return 2;
  }
}

//----- (080FADC0) --------------------------------------------------------
int __usercall get_textarea_line_number@<eax>(line_info *line@<eax>, int cursor_position@<edx>)
{
  int start; // ecx
  line_info *v3; // edi
  int v4; // esi
  int v5; // ebx
  line_info *v7; // [esp+4h] [ebp-10h]

  start = line->start;
  if ( line->start == -1 )
    return -1;
  v3 = line;
  v7 = line + 1;
  v4 = 0;
  v5 = 0;
  while ( start > cursor_position || cursor_position >= (line[v4 + 1].start != v3->end) + v3->end )
  {
    v3 = v7;
    v4 = ++v5;
    start = v7->start;
    ++v7;
    if ( start == -1 )
      return -1;
  }
  return v5;
}

//----- (080FAE40) --------------------------------------------------------
int __cdecl do_op_home(form_state *fs_0, line_info *line, int current, int utf8)
{
  if ( current == -1 )
    return 0;
  if ( !utf8 )
  {
    fs_0->state = line[current].start;
    return 0;
  }
  fs_0->state = line[current - (fs_0->state_cell != 0)].start;
  return 0;
}

//----- (080FAE90) --------------------------------------------------------
int __cdecl do_op_bob(form_state *fs_0, line_info *line, int current, int utf8)
{
  int v4; // eax
  int end; // ecx

  if ( current != -1 )
  {
    v4 = fs_0->state - line[current].start;
    fs_0->state = v4;
    end = line->end;
    if ( v4 > end )
      fs_0->state = end;
  }
  return 0;
}

//----- (080FAEC0) --------------------------------------------------------
int __cdecl do_op_eob(form_state *fs_0, line_info *line, int current, int utf8)
{
  int v4; // eax
  int textarea_line_number; // eax
  line_info *v6; // eax
  int v7; // edx
  int end; // eax

  if ( current == -1 )
  {
    fs_0->state = strlen((const char *)fs_0->value);
  }
  else
  {
    v4 = strlen((const char *)fs_0->value);
    textarea_line_number = get_textarea_line_number(line, v4);
    if ( !assert_failed )
    {
      assert_failed = textarea_line_number == -1;
      if ( textarea_line_number == -1 )
      {
        errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
        errline = 986;
        elinks_internal("assertion last != -1 failed: line info corrupt");
        textarea_line_number = -1;
      }
    }
    v6 = &line[textarea_line_number];
    v7 = fs_0->state + v6->start - line[current].start;
    fs_0->state = v7;
    end = v6->end;
    if ( v7 > end )
      fs_0->state = end;
  }
  return 0;
}

//----- (080FAF80) --------------------------------------------------------
int __cdecl do_op_right(form_state *fs_0, line_info *line, int current, int utf8)
{
  signed int v4; // eax
  int v5; // edx
  const unsigned __int8 *v7; // eax
  int v8; // eax
  int v9; // edx
  line_info *v10; // esi
  int state; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *text; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( !utf8 )
  {
    v4 = strlen((const char *)fs_0->value);
    v5 = fs_0->state + 1;
    if ( v4 <= v5 )
      v5 = v4;
    fs_0->state = v5;
    return 0;
  }
  if ( fs_0->state_cell )
    goto LABEL_7;
  text = &fs_0->value[fs_0->state];
  v7 = (const unsigned __int8 *)__rawmemchr(text, 0);
  state = fs_0->state;
  utf8_to_unicode(&text, v7);
  v8 = text - fs_0->value;
  fs_0->state = v8;
  v9 = state;
  if ( state == v8 )
  {
    if ( (*((_BYTE *)&line[current] + 12) & 2) != 0 )
      return 0;
    goto LABEL_7;
  }
  v10 = &line[current];
  if ( (*((_BYTE *)v10 + 12) & 2) == 0 )
  {
LABEL_7:
    fs_0->state_cell = 0;
    return 0;
  }
  if ( v8 != v10->end )
    v9 = 0;
  fs_0->state_cell = v9;
  return 0;
}
// 80597B8: using guessed type int __cdecl __rawmemchr(_DWORD, _DWORD);

//----- (080FB050) --------------------------------------------------------
int __cdecl do_op_left(form_state *fs_0, line_info *line, int current, int utf8)
{
  int v4; // eax
  int result; // eax
  int state_cell; // eax
  int state; // esi
  int v8; // eax
  line_info *v9; // edx

  v4 = utf8;
  if ( !utf8 )
  {
    if ( fs_0->state - 1 >= 0 )
      v4 = fs_0->state - 1;
    fs_0->state = v4;
    return 0;
  }
  state_cell = fs_0->state_cell;
  if ( state_cell )
  {
    fs_0->state = state_cell;
    result = 0;
    fs_0->state_cell = 0;
    return result;
  }
  state = fs_0->state;
  v8 = utf8_prevchar(&fs_0->value[state], 1, fs_0->value) - fs_0->value;
  if ( state == v8 )
    return 0;
  v9 = &line[current];
  if ( v9->start == state && (*((_BYTE *)v9 + 12) & 1) != 0 )
  {
    fs_0->state_cell = v8;
    return 0;
  }
  fs_0->state = v8;
  return 0;
}

//----- (080FB0F0) --------------------------------------------------------
int __cdecl do_op_end(form_state *fs_0, line_info *line, int current, int utf8)
{
  int v4; // ecx
  line_info *v5; // eax
  int end; // edx
  int result; // eax

  v4 = utf8;
  if ( current == -1 )
  {
    fs_0->state = strlen((const char *)fs_0->value);
    return 0;
  }
  else if ( utf8 )
  {
    v5 = &line[current - (fs_0->state_cell != 0)];
    end = v5->end;
    fs_0->state = end;
    if ( (*((_BYTE *)v5 + 12) & 2) != 0 )
      fs_0->state_cell = utf8_prevchar(&fs_0->value[end], 1, fs_0->value) - fs_0->value;
    else
      fs_0->state_cell = 0;
    return 0;
  }
  else
  {
    if ( line[current].end - (line[current + 1].start == line[current].end) >= 0 )
      v4 = line[current].end - (line[current + 1].start == line[current].end);
    result = 0;
    fs_0->state = v4;
  }
  return result;
}

//----- (080FB1B0) --------------------------------------------------------
frame_event_status __cdecl textarea_op_enter(form_state *fs_0, form_control *fc, int utf8)
{
  if ( assert_failed )
    goto LABEL_9;
  if ( fs_0 && fc && fs_0->value )
  {
    assert_failed = 0;
    goto LABEL_6;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
  errline = 1091;
  elinks_internal("assertion fs && fs->value && fc failed!");
  if ( assert_failed )
  {
LABEL_9:
    assert_failed = 0;
    return 2;
  }
LABEL_6:
  if ( fc->mode
    || strlen((const char *)fs_0->value) >= fc->maxlength
    || !insert_in_string(&fs_0->value, fs_0->state, (const unsigned __int8 *)"\n", 1) )
  {
    return 2;
  }
  ++fs_0->state;
  return 1;
}

//----- (080FB290) --------------------------------------------------------
void __cdecl new_pos(form_state *fs_0, line_info *line, int current, int max_cells)
{
  line_info *v4; // eax
  unsigned __int8 *value; // edx
  unsigned __int8 *v6; // ecx
  const unsigned __int8 *v7; // edi
  int i; // ebx
  unicode_val_T v9; // eax
  unsigned __int8 *text; // [esp+1Ch] [ebp-1Ch] BYREF

  v4 = &line[current];
  value = fs_0->value;
  v6 = &value[v4->start];
  text = v6;
  v7 = &value[v4->end];
  if ( max_cells > 0 )
  {
    for ( i = 0; i < max_cells; i += unicode_to_cell(v9) )
    {
      v9 = utf8_to_unicode(&text, v7);
      if ( v9 == -3 )
        break;
    }
    v6 = text;
    value = fs_0->value;
  }
  fs_0->state = v6 - value;
}

//----- (080FB300) --------------------------------------------------------
int __cdecl do_op_down(form_state *fs_0, line_info *line, int current, int utf8)
{
  int state_cell; // ecx
  int result; // eax
  line_info *v6; // edx
  int v7; // eax
  int end; // edx
  int v9; // eax
  int v10; // eax
  int v11; // [esp+Ch] [ebp-2Ch]
  int state; // [esp+14h] [ebp-24h]
  int v13; // [esp+1Ch] [ebp-1Ch]

  if ( current == -1 )
    return 0;
  v13 = current + 1;
  state_cell = fs_0->state_cell;
  result = 1;
  if ( line[current + 1 - (state_cell != 0)].start == -1 )
    return result;
  if ( !utf8 )
  {
    v6 = &line[v13];
    v7 = fs_0->state + v6->start - line[current].start;
    fs_0->state = v7;
    end = v6->end;
    if ( v7 > end )
    {
      fs_0->state = end;
      return 0;
    }
    return 0;
  }
  state = fs_0->state;
  if ( state_cell )
  {
    v10 = utf8_ptr2cells(&fs_0->value[line[current - 1].start], &fs_0->value[state_cell]);
    new_pos(fs_0, line, current, line[current - 1].last_char_width + v10);
  }
  else
  {
    v11 = utf8_ptr2cells(&fs_0->value[line[current].start], &fs_0->value[fs_0->state]);
    new_pos(fs_0, line, v13, v11);
  }
  v9 = fs_0->state;
  if ( v9 == state )
    return 0;
  if ( fs_0->state_cell && v9 == line[v13].start )
  {
    fs_0->state_cell = utf8_prevchar(&fs_0->value[v9], 1, fs_0->value) - fs_0->value;
    return 0;
  }
  else
  {
    fs_0->state_cell = 0;
    return 0;
  }
}

//----- (080FB460) --------------------------------------------------------
int __cdecl do_op_up(form_state *fs_0, line_info *line, int current, int utf8)
{
  int state_cell; // eax
  int v5; // edx
  line_info *v6; // edx
  int v7; // eax
  int end; // edx
  int v10; // eax
  unsigned __int8 *v11; // eax
  int v12; // [esp+Ch] [ebp-3Ch]
  int v13; // [esp+Ch] [ebp-3Ch]
  int v14; // [esp+1Ch] [ebp-2Ch]
  int state; // [esp+28h] [ebp-20h]

  if ( current == -1 )
    return 0;
  state_cell = fs_0->state_cell;
  v5 = 1;
  if ( (state_cell != 0) != current )
  {
    if ( !utf8 )
    {
      v6 = &line[current - 1];
      v7 = fs_0->state + v6->start - line[current].start;
      fs_0->state = v7;
      end = v6->end;
      if ( v7 > end )
      {
        fs_0->state = end;
        return 0;
      }
      return 0;
    }
    if ( state_cell )
    {
      v14 = current - 1;
      state = fs_0->state;
      v13 = line[current - 1].last_char_width
          + utf8_ptr2cells(&fs_0->value[line[current - 1].start], &fs_0->value[state_cell]);
      new_pos(fs_0, line, current - 2, v13);
    }
    else
    {
      state = fs_0->state;
      v14 = current - 1;
      v12 = utf8_ptr2cells(&fs_0->value[line[current].start], &fs_0->value[state]);
      new_pos(fs_0, line, current - 1, v12);
    }
    v10 = fs_0->state;
    if ( v10 == state )
      return 0;
    if ( fs_0->state_cell && v10 == line[v14].start )
    {
      v11 = utf8_prevchar(&fs_0->value[v10], 1, fs_0->value);
      v5 = 0;
      fs_0->state_cell = v11 - fs_0->value;
    }
    else
    {
      fs_0->state_cell = 0;
      return 0;
    }
  }
  return v5;
}

//----- (080FB5B0) --------------------------------------------------------
void __cdecl textarea_edit(int op, terminal *term_, form_state *fs_, document_view *doc_view_, link *link_)
{
  size_t v5; // eax
  const unsigned __int8 *number; // edi
  unsigned __int8 *tempdir_filename; // eax
  size_t v8; // edx
  char *v9; // eax
  unsigned __int8 *v10; // edi
  unsigned __int8 *v11; // eax
  unsigned __int8 *v12; // eax
  FILE *v13; // eax
  size_t v14; // edx
  size_t sizea; // [esp+20h] [ebp-38h]
  FILE *size; // [esp+20h] [ebp-38h]
  int fd; // [esp+24h] [ebp-34h]
  char *s; // [esp+28h] [ebp-30h]
  char *name; // [esp+2Ch] [ebp-2Ch]
  string file; // [esp+38h] [ebp-20h] BYREF

  if ( assert_failed )
    goto LABEL_19;
  assert_failed = (unsigned int)op > 1;
  if ( (unsigned int)op > 1 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 577;
    elinks_internal("assertion op == 0 || op == 1 failed!");
    if ( assert_failed )
      goto LABEL_19;
  }
  assert_failed = term_ == 0 && op != 1;
  if ( term_ == 0 && op != 1 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 579;
    elinks_internal("assertion op == 1 || term_ failed!");
    if ( assert_failed )
    {
LABEL_19:
      assert_failed = 0;
      return;
    }
  }
  if ( op )
  {
    if ( op != 1 || !fs_10335 )
      return;
    if ( init_string(&file) && add_file_to_string(&file, (const unsigned __int8 *)fn_10339) )
    {
      v5 = fc_maxlength_10334;
      if ( file.length > fc_maxlength_10334 )
      {
        file.source[fc_maxlength_10334] = 0;
        v12 = msg_text(
                term_10336,
                "You have exceeded the textarea's size limit: your input is %d bytes, but the maximum is %u bytes.\n"
                "\n"
                "Your input has been truncated, but you can still recover the text that you entered from this file: %s",
                file.length,
                v5,
                fn_10339);
        info_box(term_10336, MSGBOX_FREE_TEXT, "Warning", ALIGN_CENTER, v12);
      }
      else
      {
        unlink(fn_10339);
      }
      mem_free(fs_10335->value);
      *(string *)&fs_10335->value = file;
      if ( doc_view_10337 )
      {
        if ( link_10338 )
          draw_form_entry(term_10336, doc_view_10337, link_10338);
      }
    }
    textarea_editor = 0;
    goto free_and_return;
  }
  if ( get_opt_(cmdline_options, "anonymous")->number )
  {
    info_box(
      term_,
      (msgbox_flags)0,
      "Error",
      ALIGN_CENTER,
      "You cannot launch an external editor in the anonymous mode.");
    return;
  }
  if ( (*((_BYTE *)term_ + 56) & 1) == 0 )
  {
    info_box(term_, (msgbox_flags)0, "Error", ALIGN_CENTER, "You can do this only on the master terminal");
    return;
  }
  if ( !textarea_editor )
  {
    number = (const unsigned __int8 *)get_opt_(config_options, "document.browse.forms.editor")->number;
    s = (char *)fs_->value;
    tempdir_filename = get_tempdir_filename("elinks-area-XXXXXX");
    name = (char *)tempdir_filename;
    if ( tempdir_filename )
    {
      fd = safe_mkstemp(tempdir_filename);
      if ( fd < 0 )
      {
        mem_free(name);
      }
      else
      {
        v8 = strlen(s);
        if ( !v8 )
          goto LABEL_27;
        sizea = v8;
        v13 = fdopen(fd, "w");
        v14 = sizea;
        if ( v13 )
        {
          size = v13;
          if ( fwrite(s, v14, 1u, v13) == 1 )
          {
            if ( !fclose(size) )
            {
LABEL_27:
              fn_10339 = name;
              if ( !number || !*number )
              {
                v9 = getenv("EDITOR");
                number = (const unsigned __int8 *)v9;
                if ( !v9 || !*v9 )
                  number = "vi";
                name = fn_10339;
              }
              v10 = straconcat(number, &start, name, 0);
              if ( !v10 )
              {
                unlink(fn_10339);
free_and_return:
                if ( fn_10339 )
                  mem_free(fn_10339);
                fn_10339 = 0;
                fs_10335 = 0;
                return;
              }
              fs_10335 = fs_;
              if ( doc_view_ )
                doc_view_10337 = doc_view_;
              if ( link_ )
              {
                link_10338 = link_;
                v11 = 0;
                if ( link_->type > (unsigned int)LINK_MAP )
                  v11 = link_->data.name;
                fc_maxlength_10334 = *((_DWORD *)v11 + 16);
              }
              term_10336 = term_;
              exec_on_terminal(term_, v10, (unsigned __int8 *)&delete, TERM_EXEC_FG);
              mem_free(v10);
              textarea_editor = 1;
              return;
            }
          }
          else
          {
            fclose(size);
          }
        }
        unlink(name);
        mem_free(name);
        close(fd);
      }
    }
    fn_10339 = 0;
  }
}

//----- (080FBA20) --------------------------------------------------------
void __cdecl menu_textarea_edit(terminal *term, void *xxx, void *ses_)
{
  document_view *v3; // eax
  document_view *v4; // ebx
  int current_link; // edi
  document *document; // eax
  int v7; // edi
  int v8; // eax
  form_state *form_state; // eax

  if ( assert_failed )
    goto LABEL_17;
  assert_failed = term == 0 || ses_ == 0;
  if ( term == 0 || ses_ == 0 )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 685;
    elinks_internal("assertion term && ses failed!");
    if ( assert_failed )
      goto LABEL_17;
  }
  v3 = current_frame((session *)ses_);
  v4 = v3;
  if ( assert_failed )
    goto LABEL_17;
  if ( !v3 || !v3->vs || !v3->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 690;
    elinks_internal("assertion doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
    {
      if ( !v4 )
        return;
      goto LABEL_8;
    }
LABEL_17:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_8:
  current_link = v4->vs->current_link;
  if ( current_link >= 0 )
  {
    document = v4->document;
    if ( current_link < document->nlinks )
    {
      v7 = (int)&document->links[current_link];
      if ( v7 )
      {
        v8 = 0;
        if ( *(_DWORD *)(v7 + 4) > 1u )
          v8 = *(_DWORD *)(v7 + 48);
        if ( !*(_DWORD *)(v8 + 24) )
        {
          form_state = find_form_state(v4, (form_control *)v8);
          if ( form_state )
            textarea_edit(0, term, form_state, v4, (link *)v7);
        }
      }
    }
  }
}

//----- (080FBB90) --------------------------------------------------------
line_info *__usercall format_textutf8@<eax>(const char *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  _BYTE *v3; // eax
  _WORD *v4; // edi
  unsigned int v5; // edx
  _WORD *v6; // edi
  int v7; // esi
  int v8; // edi
  unsigned __int8 *v9; // ebx
  int v10; // edx
  int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // ebx
  int v14; // eax
  int v15; // eax
  line_info *v16; // eax
  line_info *v18; // eax
  int v19; // [esp+1Ch] [ebp-4Ch]
  int v20; // [esp+20h] [ebp-48h]
  int v22; // [esp+28h] [ebp-40h]
  unsigned __int8 *text_end; // [esp+2Ch] [ebp-3Ch]
  unsigned __int8 *v26; // [esp+38h] [ebp-30h]
  int chars_cells; // [esp+3Ch] [ebp-2Ch]
  int chars_cellsa; // [esp+3Ch] [ebp-2Ch]
  line_info *line; // [esp+4Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = a1 == 0, !a1)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c",
        errline = 78,
        elinks_internal("assertion text failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  v3 = mem_realloc(0, 0x1000u);
  if ( !v3 )
    return 0;
  v4 = v3;
  line = (line_info *)v3;
  v5 = 4096;
  if ( ((unsigned __int8)v3 & 1) != 0 )
  {
    *v3 = 0;
    v4 = v3 + 1;
    LOWORD(v5) = 4095;
  }
  if ( ((unsigned __int8)v4 & 2) != 0 )
  {
    *v4 = 0;
    v5 -= 2;
    ++v4;
  }
  memset(v4, 0, 4 * (v5 >> 2));
  v6 = &v4[2 * (v5 >> 2)];
  if ( (v5 & 2) != 0 )
    *v6++ = 0;
  if ( (v5 & 1) != 0 )
    *(_BYTE *)v6 = 0;
  v7 = 0;
  v8 = 0;
  chars_cells = 0;
  v26 = 0;
  v22 = 0;
  text_end = (unsigned __int8 *)&a1[strlen(a1)];
LABEL_13:
  v9 = (unsigned __int8 *)&a1[v7];
  if ( !a1[v7] )
  {
LABEL_23:
    v15 = v8;
    *((_BYTE *)&line[v15] + 12) &= ~2u;
    line[v15].start = v22;
    line[v15].end = v7;
    v16 = &line[v8 + 1];
    v16->end = -1;
    v16->start = -1;
    *((_BYTE *)v16 + 12) &= 0xFCu;
    *((_BYTE *)line + 12) &= ~1u;
    return line;
  }
  while ( 1 )
  {
    v10 = utf8_char2cells(v9, text_end);
    if ( *v9 == 32 )
    {
      v26 = v9;
    }
    else
    {
      v11 = 1;
      if ( *v9 == 10 )
        goto LABEL_21;
    }
    if ( !a3 )
    {
      chars_cells += v10;
LABEL_28:
      v7 += utf8charlen(v9);
      goto LABEL_13;
    }
    chars_cells += v10;
    if ( chars_cells < a2 )
      goto LABEL_28;
    LOBYTE(v11) = v26 != 0;
    if ( v26 )
      v7 = v26 - (unsigned __int8 *)a1;
    v11 = (unsigned __int8)v11;
LABEL_21:
    v12 = v8 + 258;
    v13 = v8 + 255;
    LOBYTE(v12) = 0;
    LOBYTE(v13) = 0;
    if ( v12 > v13 )
      break;
LABEL_22:
    v14 = v8;
    line[v14].last_char_width = v10;
    ++v8;
    *((_BYTE *)&line[v14] + 12) = (2 * (v11 == 0)) | *((_BYTE *)&line[v14] + 12) & 0xFD;
    line[v14].start = v22;
    line[v14].end = v7;
    v7 += v11;
    *((_BYTE *)&line[v8] + 12) = (v11 == 0) | *((_BYTE *)&line[v8] + 12) & 0xFE;
    v22 = v7;
    chars_cells = 0;
    v26 = 0;
    v9 = (unsigned __int8 *)&a1[v7];
    if ( !a1[v7] )
      goto LABEL_23;
  }
  chars_cellsa = 16 * v12;
  v19 = v10;
  v20 = v11;
  v18 = (line_info *)mem_realloc(line, 16 * v12);
  if ( v18 )
  {
    line = v18;
    memset(&v18[v13], 0, chars_cellsa - 16 * v13);
    v11 = v20;
    v10 = v19;
    goto LABEL_22;
  }
  mem_free(line);
  return 0;
}
// 80FBC2E: conditional instruction was optimized away because %line.4!=0
// 80FBCDE: conditional instruction was optimized away because %line.4!=0
// 80FBE79: conditional instruction was optimized away because %line.4!=0

//----- (080FBEB0) --------------------------------------------------------
line_info *__usercall format_text@<eax>(unsigned __int8 *text@<eax>, int width@<edx>, form_wrap wrap@<ecx>, int format)
{
  _BYTE *v5; // eax
  _WORD *v6; // edi
  unsigned int v7; // edx
  _WORD *v8; // edi
  int v9; // esi
  int v10; // edi
  unsigned __int8 v11; // al
  int v12; // edx
  _BYTE *v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // eax
  line_info *v18; // edi
  line_info *v20; // eax
  unsigned int v21; // [esp+38h] [ebp-40h]
  int v22; // [esp+3Ch] [ebp-3Ch]
  int v23; // [esp+40h] [ebp-38h]
  int v24; // [esp+40h] [ebp-38h]
  int begin; // [esp+4Ch] [ebp-2Ch]
  line_info *line; // [esp+5Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = text == 0, !text)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c",
        errline = 162,
        elinks_internal("assertion text failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  v5 = mem_realloc(0, 0x1000u);
  if ( !v5 )
    return 0;
  v6 = v5;
  line = (line_info *)v5;
  v7 = 4096;
  if ( ((unsigned __int8)v5 & 1) != 0 )
  {
    *v5 = 0;
    v6 = v5 + 1;
    LOWORD(v7) = 4095;
  }
  if ( ((unsigned __int8)v6 & 2) != 0 )
  {
    *v6 = 0;
    v7 -= 2;
    ++v6;
  }
  memset(v6, 0, 4 * (v7 >> 2));
  v8 = &v6[2 * (v7 >> 2)];
  if ( (v7 & 2) != 0 )
    *v8++ = 0;
  if ( (v7 & 1) != 0 )
    *(_BYTE *)v8 = 0;
  v9 = 0;
  v10 = 0;
  begin = 0;
LABEL_13:
  v11 = text[v9];
  if ( !v11 )
  {
LABEL_25:
    v17 = v10;
    line[v17].start = begin;
    line[v17].end = v9;
    v18 = &line[v10 + 1];
    v18->end = -1;
    v18->start = -1;
    return line;
  }
  while ( 1 )
  {
    v12 = 1;
    if ( v11 != 10 )
    {
      if ( wrap == FORM_WRAP_NONE || v9 - begin < width )
      {
        ++v9;
        goto LABEL_13;
      }
      v13 = (_BYTE *)memrchr(&text[begin], 32, v9 - begin);
      if ( v13 )
      {
        if ( format )
        {
          if ( wrap == FORM_WRAP_HARD )
            *v13 = 10;
        }
        v9 = v13 - text;
      }
      v12 = v13 != 0;
    }
    v14 = v10 + 258;
    v15 = v10 + 255;
    LOBYTE(v14) = 0;
    LOBYTE(v15) = 0;
    if ( v14 > v15 )
      break;
LABEL_24:
    v16 = v10++;
    v23 = v16;
    line[v23].start = begin;
    line[v23].end = v9;
    v9 += v12;
    begin = v9;
    v11 = text[v9];
    if ( !v11 )
      goto LABEL_25;
  }
  v24 = 16 * v14;
  v22 = v12;
  v21 = v15;
  v20 = (line_info *)mem_realloc(line, 16 * v14);
  if ( v20 )
  {
    line = v20;
    memset(&v20[v21], 0, v24 - 16 * v21);
    v12 = v22;
    goto LABEL_24;
  }
  mem_free(line);
  return 0;
}
// 80FBF45: conditional instruction was optimized away because %line.4!=0
// 80FBFEB: conditional instruction was optimized away because %line.4!=0
// 80FC124: conditional instruction was optimized away because %line.4!=0
// 80596A8: using guessed type int __cdecl memrchr(_DWORD, _DWORD, _DWORD);

//----- (080FC150) --------------------------------------------------------
int __usercall textarea_op@<eax>(
        form_state *fs_0@<eax>,
        form_control *fc@<edx>,
        int utf8@<ecx>,
        int (*do_op)(form_state *, line_info *, int, int))
{
  line_info *v6; // esi
  int textarea_line_number; // eax
  form_control *v9; // [esp+14h] [ebp-24h]
  int state_cell; // [esp+18h] [ebp-20h]
  int state; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_11;
  if ( !fs_0 || !fc || !fs_0->value )
  {
    v9 = fc;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 715;
    elinks_internal("assertion fs && fs->value && fc failed!");
    fc = v9;
    if ( !assert_failed )
    {
      if ( utf8 )
        goto LABEL_7;
LABEL_14:
      v6 = format_text(fs_0->value, fc->cols, fc->wrap, 0);
      if ( v6 )
        goto LABEL_8;
      return 2;
    }
LABEL_11:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
  if ( !utf8 )
    goto LABEL_14;
LABEL_7:
  v6 = format_textutf8((const char *)fs_0->value, fc->cols, fc->wrap);
  if ( !v6 )
    return 2;
LABEL_8:
  textarea_line_number = get_textarea_line_number(v6, fs_0->state);
  state = fs_0->state;
  state_cell = fs_0->state_cell;
  if ( !do_op(fs_0, v6, textarea_line_number, utf8) )
  {
    mem_free(v6);
    if ( fs_0->state != state || fs_0->state_cell != state_cell )
      return 1;
    return 2;
  }
  mem_free(v6);
  return 0;
}

//----- (080FC2A0) --------------------------------------------------------
frame_event_status __cdecl textarea_op_right(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_right);
}

//----- (080FC2C0) --------------------------------------------------------
frame_event_status __cdecl textarea_op_left(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_left);
}

//----- (080FC2E0) --------------------------------------------------------
frame_event_status __cdecl textarea_op_eob(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_eob);
}

//----- (080FC300) --------------------------------------------------------
frame_event_status __cdecl textarea_op_bob(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_bob);
}

//----- (080FC320) --------------------------------------------------------
void __cdecl set_textarea(document_view *doc_view, int direction)
{
  document_view *v2; // eax
  bool v3; // bl
  int current_link; // edx
  document *document; // ecx
  int v6; // edx
  int v7; // edi
  form_state *form_state; // eax
  document_view *v9; // [esp+1Ch] [ebp-1Ch]
  document_view *v10; // [esp+1Ch] [ebp-1Ch]

  v2 = doc_view;
  v3 = (*((_BYTE *)&doc_view->document->options + 92) & 0x10) != 0;
  if ( assert_failed )
    goto LABEL_16;
  if ( !doc_view->vs )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 1193;
    elinks_internal("assertion doc_view && doc_view->vs && doc_view->document failed!");
    v2 = doc_view;
    if ( assert_failed )
      goto LABEL_16;
  }
  assert_failed = direction != -1 && direction != 1;
  if ( direction != -1 && direction != 1 )
  {
    v10 = v2;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 1194;
    elinks_internal("assertion direction == 1 || direction == -1 failed!");
    v2 = v10;
    if ( assert_failed )
      goto LABEL_16;
  }
  current_link = v2->vs->current_link;
  if ( current_link >= 0 )
  {
    document = v2->document;
    if ( current_link < document->nlinks )
    {
      v6 = (int)&document->links[current_link];
      if ( v6 )
      {
        if ( *(_DWORD *)(v6 + 4) == 6 )
        {
          v7 = *(_DWORD *)(v6 + 48);
          assert_failed = v7 == 0;
          if ( !v7 )
          {
            v9 = v2;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
            errline = 1202;
            elinks_internal("assertion fc != NULL failed: link has no form control");
            v2 = v9;
            if ( assert_failed )
            {
LABEL_16:
              assert_failed = 0;
              return;
            }
          }
          if ( *(_DWORD *)(v7 + 24) != 2 )
          {
            form_state = find_form_state(v2, (form_control *)v7);
            if ( form_state )
            {
              if ( form_state->value )
              {
                if ( direction == 1 )
                  textarea_op_eob(form_state, (form_control *)v7, v3);
                else
                  textarea_op_bob(form_state, (form_control *)v7, v3);
              }
            }
          }
        }
      }
    }
  }
}

//----- (080FC4E0) --------------------------------------------------------
frame_event_status __cdecl textarea_op_end(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_end);
}

//----- (080FC500) --------------------------------------------------------
frame_event_status __cdecl textarea_op_down(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_down);
}

//----- (080FC520) --------------------------------------------------------
frame_event_status __cdecl textarea_op_up(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_up);
}

//----- (080FC540) --------------------------------------------------------
frame_event_status __cdecl textarea_op_home(form_state *fs_0, form_control *fc, int utf8)
{
  return textarea_op(fs_0, fc, utf8, do_op_home);
}

//----- (080FC560) --------------------------------------------------------
int __cdecl area_cursor(form_control *fc, form_state *fs_0, int utf8)
{
  line_info *v3; // edi
  int result; // eax
  int state_cell; // edx
  int textarea_line_number; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int vpos; // ecx
  int vypos; // edi
  int v13; // ecx
  int v14; // edx
  line_info *v15; // [esp+18h] [ebp-20h]
  int v16; // [esp+18h] [ebp-20h]
  int v17; // [esp+1Ch] [ebp-1Ch]
  int v18; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed
    || (assert_failed = fc == 0 || fs_0 == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c",
        errline = 243,
        elinks_internal("assertion fc && fs failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return 0;
  }
  if ( utf8 )
    v3 = format_textutf8((const char *)fs_0->value, fc->cols, fc->wrap);
  else
    v3 = format_text(fs_0->value, fc->cols, fc->wrap, 0);
  result = 0;
  if ( v3 )
  {
    state_cell = fs_0->state_cell;
    if ( !state_cell )
      state_cell = fs_0->state;
    textarea_line_number = get_textarea_line_number(v3, state_cell);
    if ( textarea_line_number == -1 )
    {
      mem_free(v3);
      return 0;
    }
    if ( utf8 )
    {
      v7 = fs_0->state_cell;
      v17 = textarea_line_number;
      if ( v7 )
      {
        v15 = &v3[textarea_line_number];
        v8 = utf8_ptr2cells(&fs_0->value[v15->start], &fs_0->value[v7]);
        textarea_line_number = v17;
        v9 = v15->last_char_width + v8;
      }
      else
      {
        v9 = utf8_ptr2cells(&fs_0->value[v3[textarea_line_number].start], &fs_0->value[fs_0->state]);
        textarea_line_number = v17;
      }
    }
    else
    {
      v9 = fs_0->state - v3[textarea_line_number].start;
      if ( fc->wrap )
        v9 -= fc->cols == v9;
    }
    v16 = v9;
    v18 = textarea_line_number;
    mem_free(v3);
    v10 = v16 - fc->cols + 1;
    vpos = fs_0->vpos;
    if ( v10 <= vpos )
    {
      if ( v16 < vpos )
      {
        fs_0->vpos = v16;
        vypos = fs_0->vypos;
        v13 = v18 - fc->rows + 1;
        if ( v13 > vypos )
          goto LABEL_15;
        goto LABEL_25;
      }
    }
    else
    {
      fs_0->vpos = v10;
    }
    vypos = fs_0->vypos;
    v13 = v18 - fc->rows + 1;
    if ( v13 > vypos )
    {
LABEL_15:
      fs_0->vypos = v13;
      v14 = fc->cols * (v18 - v13);
      return v14 + v16 - fs_0->vpos;
    }
LABEL_25:
    if ( v18 >= vypos )
    {
      v14 = fc->cols * (v18 - vypos);
    }
    else
    {
      fs_0->vypos = v18;
      v14 = 0;
    }
    return v14 + v16 - fs_0->vpos;
  }
  return result;
}

//----- (080FC780) --------------------------------------------------------
unsigned __int8 *__cdecl encode_textarea(submitted_value *sv)
{
  line_info *v2; // eax

  if ( assert_failed )
    goto LABEL_2;
  if ( sv && sv->value )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 495;
    elinks_internal("assertion sv && sv->value failed!");
    if ( assert_failed )
    {
LABEL_2:
      assert_failed = 0;
      return 0;
    }
  }
  v2 = format_text(sv->value, sv->form_control->cols, sv->form_control->wrap, 1);
  if ( v2 )
    mem_free(v2);
  return encode_crlf(sv);
}

//----- (080FC830) --------------------------------------------------------
void __cdecl draw_textarea(terminal *term, form_state *fs_0, document_view *doc_view, link *link)
{
  document_view *v4; // ebx
  bool v5; // al
  unsigned __int8 *name; // ecx
  view_state *vs; // eax
  int x; // edi
  int vypos; // eax
  bool v10; // cl
  line_info *v11; // edx
  point *points; // esi
  int v13; // edx
  unsigned __int8 *v14; // edi
  int i; // eax
  int v16; // esi
  int v17; // edi
  int v18; // edx
  form_control *v19; // edi
  int y; // eax
  form_control *v21; // eax
  int v22; // esi
  int v23; // edi
  form_control *v24; // edx
  int v25; // ecx
  form_control *v26; // eax
  unsigned __int8 *v27; // ecx
  view_state *v28; // eax
  unsigned __int8 *v29; // edi
  line_info *v30; // eax
  int start; // eax
  bool v32; // cl
  int v33; // edx
  line_info *v34; // edi
  point *v35; // edx
  unsigned __int8 *v36; // ebx
  unsigned __int8 *v37; // eax
  int v38; // edx
  int v39; // esi
  int v40; // edi
  int v41; // edx
  int v42; // eax
  int v43; // eax
  int v44; // eax
  unicode_val_T v45; // ecx
  int v46; // edx
  int v47; // eax
  int v48; // esi
  int v49; // edi
  int v50; // eax
  unicode_val_T v51; // ebx
  unicode_val_T v52; // [esp+Ch] [ebp-6Ch]
  unicode_val_T v53; // [esp+28h] [ebp-50h]
  form_control *v54; // [esp+2Ch] [ebp-4Ch]
  int v55; // [esp+2Ch] [ebp-4Ch]
  int v56; // [esp+2Ch] [ebp-4Ch]
  int p; // [esp+30h] [ebp-48h]
  line_info *pa; // [esp+30h] [ebp-48h]
  line_info *linex; // [esp+34h] [ebp-44h]
  line_info *linexa; // [esp+34h] [ebp-44h]
  int ye; // [esp+38h] [ebp-40h]
  int yea; // [esp+38h] [ebp-40h]
  line_info *v63; // [esp+3Ch] [ebp-3Ch]
  unicode_val_T data; // [esp+40h] [ebp-38h]
  int vy; // [esp+44h] [ebp-34h]
  int vya; // [esp+44h] [ebp-34h]
  int vyb; // [esp+44h] [ebp-34h]
  form_control *v68; // [esp+48h] [ebp-30h]
  form_control *v69; // [esp+48h] [ebp-30h]
  unsigned __int8 *end; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *enda; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *endb; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *endc; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *string; // [esp+5Ch] [ebp-1Ch] BYREF

  v4 = doc_view;
  if ( assert_failed )
    goto LABEL_36;
  v5 = doc_view == 0;
  if ( doc_view && term && doc_view->document && link && doc_view->vs )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 417;
    elinks_internal("assertion term && doc_view && doc_view->document && doc_view->vs && link failed!");
    v5 = doc_view == 0;
    if ( assert_failed )
      goto LABEL_36;
  }
  if ( (*((_BYTE *)term + 56) & 2) == 0 )
  {
    if ( link->type <= (unsigned int)LINK_MAP )
    {
      assert_failed = 1;
      v68 = 0;
    }
    else
    {
      name = link->data.name;
      v68 = (form_control *)name;
      assert_failed = name == 0;
      if ( name )
      {
LABEL_11:
        vs = doc_view->vs;
        x = vs->x;
        vy = vs->y;
        if ( link->npoints )
        {
          area_cursor(v68, fs_0, 0);
          linex = format_text(fs_0->value, v68->cols, v68->wrap, 0);
          if ( linex )
          {
            vypos = fs_0->vypos;
            v10 = linex->start != -1;
            if ( !vypos || linex->start == -1 )
            {
              end = (unsigned __int8 *)linex;
            }
            else
            {
              v11 = linex;
              do
              {
                ++v11;
                v10 = v11->start != -1;
                --vypos;
              }
              while ( vypos && v11->start != -1 );
              end = (unsigned __int8 *)v11;
            }
            points = link->points;
            v13 = points->x + doc_view->box.x - x;
            v14 = (unsigned __int8 *)(doc_view->box.y + points->y - vy);
            ye = (int)&v14[v68->rows];
            if ( v10 && (int)v14 < (int)&v14[v68->rows] )
            {
              for ( i = doc_view->box.y; ; i = doc_view->box.y )
              {
                if ( i <= (int)v14 && doc_view->box.height + i > (int)v14 && v68->cols > 0 )
                {
                  vya = (int)v14;
                  v16 = 0;
                  v17 = v13;
                  do
                  {
                    v18 = doc_view->box.x;
                    if ( v18 <= v16 + v17 && doc_view->box.width + v18 > v16 + v17 )
                    {
                      p = fs_0->vpos;
                      if ( -p > v16 || v16 + p >= *((_DWORD *)end + 1) - *(_DWORD *)end )
                        draw_char_data(term, v16 + v17, vya, 0x5Fu);
                      else
                        draw_char_data(term, v16 + v17, vya, fs_0->value[p + v16 + *(_DWORD *)end]);
                    }
                    ++v16;
                  }
                  while ( v68->cols > v16 );
                  v13 = v17;
                  v14 = (unsigned __int8 *)vya;
                }
                end += 16;
                if ( ye <= (int)++v14 )
                  break;
                if ( *(_DWORD *)end == -1 )
                  goto LABEL_42;
              }
            }
            else
            {
LABEL_42:
              if ( ye > (int)v14 )
              {
                enda = v14;
                v19 = v68;
                do
                {
                  y = doc_view->box.y;
                  if ( y <= (int)enda && doc_view->box.height + y > (int)enda && v19->cols > 0 )
                  {
                    v21 = v19;
                    v22 = 0;
                    v23 = v13;
                    v24 = v21;
                    do
                    {
                      v25 = doc_view->box.x;
                      if ( v25 <= v22 + v23 && doc_view->box.width + v25 > v22 + v23 )
                      {
                        v54 = v24;
                        draw_char_data(term, v22 + v23, (int)enda, 0x5Fu);
                        v24 = v54;
                      }
                      ++v22;
                    }
                    while ( v24->cols > v22 );
                    v26 = v24;
                    v13 = v23;
                    v19 = v26;
                  }
                  ++enda;
                }
                while ( ye > (int)enda );
              }
            }
            mem_free(linex);
          }
        }
        return;
      }
    }
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 427;
    elinks_internal(
      "assertion fc != NULL failed: link %d has no form control",
      -991146299 * (((char *)link - (char *)doc_view->document->links) >> 2));
    if ( !assert_failed )
      goto LABEL_11;
LABEL_36:
    assert_failed = 0;
    return;
  }
  if ( !v5 && doc_view->document && link && doc_view->vs )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
    errline = 335;
    elinks_internal("assertion term && doc_view && doc_view->document && doc_view->vs && link failed!");
    if ( assert_failed )
      goto LABEL_36;
  }
  if ( link->type <= (unsigned int)LINK_MAP )
  {
    assert_failed = 1;
    data = 0;
  }
  else
  {
    v27 = link->data.name;
    data = (unicode_val_T)v27;
    assert_failed = v27 == 0;
    if ( v27 )
      goto LABEL_64;
  }
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/textarea.c";
  errline = 338;
  elinks_internal(
    "assertion fc != NULL failed: link %d has no form control",
    -991146299 * (((char *)link - (char *)doc_view->document->links) >> 2));
  if ( assert_failed )
    goto LABEL_36;
LABEL_64:
  v28 = doc_view->vs;
  v29 = (unsigned __int8 *)v28->x;
  v69 = (form_control *)v28->y;
  if ( link->npoints )
  {
    area_cursor((form_control *)data, fs_0, 1);
    v30 = format_textutf8((const char *)fs_0->value, *(_DWORD *)(data + 52), *(_DWORD *)(data + 60));
    pa = v30;
    if ( v30 )
    {
      start = v30->start;
      v32 = start != -1;
      if ( start == -1 || !fs_0->vypos )
      {
        v63 = pa;
      }
      else
      {
        endb = v29;
        v33 = fs_0->vypos;
        v34 = pa;
        do
        {
          ++v34;
          start = v34->start;
          v32 = v34->start != -1;
          --v33;
        }
        while ( v33 && v34->start != -1 );
        v63 = v34;
        v29 = endb;
      }
      v35 = link->points;
      linexa = (line_info *)(v35->x + doc_view->box.x - (_DWORD)v29);
      vyb = v35->y + doc_view->box.y - (_DWORD)v69;
      yea = *(_DWORD *)(data + 56) + vyb;
      if ( v32 && vyb < *(_DWORD *)(data + 56) + vyb )
      {
        while ( 1 )
        {
          string = &fs_0->value[start];
          v36 = &fs_0->value[v63->end];
          v37 = &string[utf8_cells2bytes(string, fs_0->vpos, v36)];
          string = v37;
          v38 = doc_view->box.y;
          if ( v38 <= vyb && doc_view->box.height + v38 > vyb && *(int *)(data + 52) > 0 )
          {
            v39 = (int)linexa;
            v40 = 0;
            endc = v36;
            while ( 1 )
            {
              if ( endc <= v37 || -fs_0->vpos > v40 )
                v51 = 95;
              else
                v51 = utf8_to_unicode(&string, endc);
              v44 = doc_view->box.x;
              if ( v44 > v39 || doc_view->box.width + v44 <= v39 )
              {
                v43 = v39;
                if ( ++v40 >= *(_DWORD *)(data + 52) )
                  break;
              }
              else
              {
                v41 = unicode_to_cell(v51);
                v42 = v39;
                if ( v41 == 2 )
                {
                  v52 = v51;
                  ++v40;
                  v51 = -3;
                  draw_char_data(term, v39, vyb, v52);
                  v42 = v39 + 1;
                }
                ++v40;
                v55 = v42;
                draw_char_data(term, v42, vyb, v51);
                v43 = v55;
                if ( v40 >= *(_DWORD *)(data + 52) )
                  break;
              }
              v39 = v43 + 1;
              v37 = string;
            }
          }
          ++v63;
          ++vyb;
          start = v63->start;
          if ( yea <= vyb )
            break;
          if ( start == -1 )
          {
            v4 = doc_view;
            goto LABEL_90;
          }
        }
      }
      else
      {
LABEL_90:
        if ( yea > vyb )
        {
          v45 = data;
          v46 = vyb;
          do
          {
            v47 = v4->box.y;
            if ( v47 <= v46 && v4->box.height + v47 > v46 && *(int *)(v45 + 52) > 0 )
            {
              v48 = (int)linexa;
              v49 = 0;
              while ( 1 )
              {
                v50 = v4->box.x;
                if ( v50 <= v48 && v4->box.width + v50 > v48 )
                {
                  v56 = v46;
                  v53 = v45;
                  draw_char_data(term, v48, v46, 0x5Fu);
                  v45 = v53;
                  v46 = v56;
                }
                if ( ++v49 >= *(_DWORD *)(v45 + 52) )
                  break;
                ++v48;
              }
            }
            ++v46;
          }
          while ( yea > v46 );
        }
      }
      mem_free(pa);
    }
  }
}

//----- (080FCF90) --------------------------------------------------------
frame_event_status __cdecl save_formatted_dlg(session *ses, document_view *doc_view, int xxxx)
{
  query_file(ses, doc_view->vs->uri, ses, save_formatted, 0, 1);
  return 2;
}

//----- (080FCFE0) --------------------------------------------------------
document_view *__cdecl current_frame(session *ses)
{
  location *current; // eax
  int current_link; // ebx
  list_head_elinks *p_scrn_frames; // ecx
  document_view *result; // eax
  document *document; // edx
  document *v6; // edx
  document_view *doc_view; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_20;
  assert_failed = ses == 0;
  if ( !ses )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 1253;
    elinks_internal("assertion ses failed!");
    if ( assert_failed )
      goto LABEL_20;
    current = (location *)MEMORY[0x14];
    if ( MEMORY[0x14] )
      goto LABEL_4;
    return 0;
  }
  current = ses->history.current;
  if ( !current )
    return 0;
LABEL_4:
  current_link = current->vs.current_link;
  p_scrn_frames = &ses->scrn_frames;
  if ( current_link == -1 )
    current_link = 0;
  for ( result = (document_view *)ses->scrn_frames.next; p_scrn_frames != (list_head_elinks *)result; --current_link )
  {
    while ( 1 )
    {
      document = result->document;
      if ( !document || !document->frame_desc )
        break;
      result = result->next;
      if ( p_scrn_frames == (list_head_elinks *)result )
        goto LABEL_13;
    }
    if ( !current_link )
      return result;
    result = result->next;
  }
LABEL_13:
  result = ses->doc_view;
  if ( !result || !result->document )
  {
    doc_view = ses->doc_view;
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 1268;
    elinks_internal("assertion doc_view && doc_view->document failed!");
    result = doc_view;
    if ( !assert_failed )
      goto LABEL_16;
LABEL_20:
    assert_failed = 0;
    return 0;
  }
  assert_failed = 0;
LABEL_16:
  v6 = result->document;
  if ( v6 && v6->frame_desc )
    return 0;
  return result;
}

//----- (080FD120) --------------------------------------------------------
void __cdecl save_formatted(void *data, unsigned __int8 *file)
{
  int v2; // eax
  document_view *v3; // eax
  document_view *v4; // [esp+2Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_7;
  if ( data && (v2 = *((_DWORD *)data + 2)) != 0 && file && *(_DWORD *)(v2 + 20) )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 1640;
    elinks_internal("assertion ses && ses->tab && ses->tab->term && file failed!");
    if ( assert_failed )
    {
LABEL_7:
      assert_failed = 0;
      return;
    }
  }
  v3 = current_frame((session *)data);
  if ( assert_failed )
    goto LABEL_7;
  if ( v3 && v3->document )
  {
    assert_failed = 0;
  }
  else
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 1643;
    v4 = v3;
    elinks_internal("assertion doc_view && doc_view->document failed!");
    v3 = v4;
    if ( assert_failed )
      goto LABEL_7;
  }
  create_download_file(*(terminal **)(*((_DWORD *)data + 2) + 20), file, 0, 0, 0, save_formatted_finish, v3->document);
}

//----- (080FD260) --------------------------------------------------------
void __cdecl save_formatted_finish(terminal *term, int h, void *data, int resume)
{
  if ( assert_failed
    || (assert_failed = term == 0 || data == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c",
        errline = 1623,
        elinks_internal("assertion term && document failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else if ( h != -1 )
  {
    if ( dump_to_file((document *)data, h) )
      info_box(term, (msgbox_flags)0, "Save error", ALIGN_CENTER, "Error writing to file");
    close(h);
  }
}

//----- (080FD340) --------------------------------------------------------
frame_event_status __cdecl save_as(session *ses, document_view *doc_view, int magic)
{
  location *current; // eax
  uri *uri; // eax
  document *document; // eax

  if ( assert_failed )
    goto LABEL_13;
  assert_failed = ses == 0;
  if ( !ses )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 1601;
    elinks_internal("assertion ses failed!");
    if ( assert_failed )
      goto LABEL_13;
  }
  current = ses->history.current;
  if ( current )
  {
    if ( ses->download_uri )
    {
      done_uri(ses->download_uri);
      current = ses->history.current;
    }
    uri = current->vs.uri;
    ++uri->object.refcount;
    ses->download_uri = uri;
    if ( assert_failed )
      goto LABEL_13;
    if ( doc_view && (document = doc_view->document) != 0 && document->uri )
    {
      assert_failed = 0;
    }
    else
    {
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 1609;
      elinks_internal("assertion doc_view && doc_view->document && doc_view->document->uri failed!");
      if ( assert_failed )
      {
LABEL_13:
        assert_failed = 0;
        return 2;
      }
    }
    set_session_referrer(ses, doc_view->document->uri);
    query_file(ses, ses->download_uri, ses, start_download, 0, 1);
    return 2;
  }
  return 2;
}

//----- (080FD490) --------------------------------------------------------
frame_event_status __cdecl view_image(session *ses, document_view *doc_view, int xxxx)
{
  int current_link; // edx
  document *document; // eax
  int v5; // edx

  if ( doc_view )
  {
    current_link = doc_view->vs->current_link;
    if ( current_link >= 0 )
    {
      document = doc_view->document;
      if ( current_link < document->nlinks )
      {
        v5 = (int)&document->links[current_link];
        if ( v5 )
        {
          if ( *(_DWORD *)(v5 + 16) )
            goto_url(ses, *(unsigned __int8 **)(v5 + 16));
        }
      }
    }
  }
  return 2;
}

//----- (080FD4E0) --------------------------------------------------------
frame_event_status __cdecl download_link(session *ses, document_view *doc_view, action_id_T action_id)
{
  int current_link; // eax
  document *document; // edx
  void (*v6)(void *, unsigned __int8 *); // edi
  uri *uri; // eax
  unsigned __int8 *where_img; // eax
  link *link; // [esp+2Ch] [ebp-1Ch]

  if ( doc_view )
  {
    current_link = doc_view->vs->current_link;
    if ( current_link >= 0 )
    {
      document = doc_view->document;
      if ( current_link < document->nlinks )
      {
        link = &document->links[current_link];
        if ( link )
        {
          if ( ses->download_uri )
          {
            done_uri(ses->download_uri);
            ses->download_uri = 0;
          }
          if ( action_id == 38 )
          {
            where_img = link->where_img;
            if ( where_img )
            {
              v6 = start_download;
              uri = get_uri(where_img, (uri_component)0);
              ses->download_uri = uri;
            }
            else
            {
              uri = ses->download_uri;
              v6 = start_download;
            }
          }
          else
          {
            if ( action_id == 39 )
            {
              v6 = resume_download;
            }
            else
            {
              if ( action_id != 37 )
              {
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
                errline = 1575;
                elinks_internal("I think you forgot to take your medication, mental boy!");
                return 2;
              }
              v6 = start_download;
            }
            uri = get_link_uri(ses, doc_view, link);
            ses->download_uri = uri;
          }
          if ( uri )
          {
            set_session_referrer(ses, doc_view->document->uri);
            query_file(ses, ses->download_uri, ses, v6, 0, 1);
          }
        }
      }
    }
  }
  return 2;
}

//----- (080FD630) --------------------------------------------------------
frame_event_status __usercall horizontal_scroll@<eax>(
        session *ses@<eax>,
        document_view *doc_view@<edx>,
        int steps@<ecx>)
{
  frame_event_status result; // eax
  int v5; // esi
  view_state *vs; // edi
  int x; // ecx
  int v8; // eax
  int v9; // edx
  int is_visible; // edx
  int v11; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_10;
  }
  v11 = steps;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 306;
  elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
  steps = v11;
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 2;
  }
LABEL_10:
  v5 = steps + doc_view->vs->x;
  if ( get_opt_(config_options, "document.browse.scrolling.horizontal_extended")->number )
  {
    vs = doc_view->vs;
    x = vs->x;
    v8 = doc_view->document->width - 1;
  }
  else
  {
    vs = doc_view->vs;
    x = vs->x;
    v8 = doc_view->document->width - doc_view->box.width;
    if ( v8 < x )
      v8 = vs->x;
  }
  v9 = 0;
  if ( v5 >= 0 )
  {
    v9 = v5;
    if ( v8 <= v5 )
      v9 = v8;
  }
  result = FRAME_EVENT_OK;
  if ( v9 != x )
  {
    vs->x = v9;
    is_visible = current_link_is_visible(doc_view);
    result = FRAME_EVENT_REFRESH;
    if ( !is_visible )
    {
      find_link_page_down(doc_view);
      return 1;
    }
  }
  return result;
}

//----- (080FD770) --------------------------------------------------------
frame_event_status __usercall vertical_scroll@<eax>(session *ses@<eax>, document_view *doc_view@<edx>, int steps@<ecx>)
{
  frame_event_status result; // eax
  view_state *vs; // edi
  int y; // ecx
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int is_visible; // edx

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || !doc_view->vs || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 271;
    elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_10;
LABEL_4:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
LABEL_10:
  vs = doc_view->vs;
  y = vs->y;
  v8 = steps + y;
  if ( steps > 0 )
  {
    v9 = doc_view->document->height - doc_view->box.height;
    if ( y >= v9 )
      return 2;
    if ( v8 > v9 )
      v8 = doc_view->document->height - doc_view->box.height;
  }
  v10 = 0;
  if ( v8 >= 0 )
    v10 = v8;
  if ( y == v10 )
    return 2;
  vs->y = v10;
  is_visible = current_link_is_visible(doc_view);
  result = FRAME_EVENT_REFRESH;
  if ( !is_visible )
  {
    if ( steps <= 0 )
      find_link_page_up(doc_view);
    else
      find_link_page_down(doc_view);
    return 1;
  }
  return result;
}

//----- (080FD880) --------------------------------------------------------
frame_event_status __usercall scroll_mouse_up@<eax>(session *ses@<eax>, document_view *doc_view@<edx>)
{
  option_value *opt; // eax

  opt = get_opt_(config_options, "document.browse.scrolling.vertical_step");
  return vertical_scroll(ses, doc_view, -opt->number);
}

//----- (080FD8C0) --------------------------------------------------------
frame_event_status __usercall scroll_mouse_down@<eax>(session *ses@<eax>, document_view *doc_view@<edx>)
{
  option_value *opt; // eax

  opt = get_opt_(config_options, "document.browse.scrolling.vertical_step");
  return vertical_scroll(ses, doc_view, opt->number);
}

//----- (080FD900) --------------------------------------------------------
frame_event_status __cdecl try_mark_key(session *ses, document_view *doc_view, term_event *ev)
{
  int x; // edx
  $A432824C7AF5BC859123DC670ECB2CAE mark; // ecx
  frame_event_status result; // eax

  LOBYTE(x) = 0;
  mark = ses->kbdprefix.mark;
  if ( ev->info.mouse.x < 0x80u )
    x = ev->info.mouse.x;
  if ( mark == KP_MARK_SET )
  {
    set_mark(x, doc_view->vs);
  }
  else
  {
    result = FRAME_EVENT_IGNORED;
    if ( mark == KP_MARK_NOTHING )
      return result;
    if ( mark == KP_MARK_GOTO )
      goto_mark(x, doc_view->vs);
  }
  ses->kbdprefix.repeat_count = 0;
  result = FRAME_EVENT_REFRESH;
  ses->kbdprefix.mark = KP_MARK_NOTHING;
  return result;
}

//----- (080FD990) --------------------------------------------------------
term_event *__usercall send_to_frame@<eax>(session *ses@<eax>, document_view *doc_view@<edx>, term_event *ev@<ecx>)
{
  window *tab; // eax
  view_state *vs; // edx
  frame_event_status v8; // eax
  unsigned int button; // edx
  int y; // edi
  unsigned int v11; // eax
  int current_link; // edi
  document *document; // eax
  int v14; // edi
  int v15; // edx
  document *v16; // ecx
  int v17; // edx
  frame_event_status v18; // edi
  option_value *v19; // eax
  term_event *v20; // ecx
  int v21; // eax
  int num_links_key; // edx
  int nlinks; // ecx
  int v24; // esi
  link *link_at_coordinates; // eax
  link_type type; // edx
  unsigned int v27; // eax
  int number; // eax
  option_value *v29; // eax
  terminal *term; // edx
  option_value *opt; // eax
  int v32; // [esp+4Ch] [ebp-4Ch]
  term_event *v33; // [esp+60h] [ebp-38h]
  term_event *v34; // [esp+60h] [ebp-38h]
  term_event *v35; // [esp+60h] [ebp-38h]
  term_event *v36; // [esp+60h] [ebp-38h]
  term_event *v37; // [esp+60h] [ebp-38h]
  term_event *v38; // [esp+60h] [ebp-38h]
  term_event *v39; // [esp+60h] [ebp-38h]
  term_event *v40; // [esp+60h] [ebp-38h]
  term_event *v41; // [esp+60h] [ebp-38h]
  term_event *v42; // [esp+60h] [ebp-38h]
  term_event *v43; // [esp+60h] [ebp-38h]
  document *v44; // [esp+68h] [ebp-30h]
  int x; // [esp+6Ch] [ebp-2Ch]
  int xa; // [esp+6Ch] [ebp-2Ch]
  unsigned __int8 def[14]; // [esp+7Eh] [ebp-1Ah] BYREF

  if ( assert_failed )
    goto LABEL_7;
  if ( ses )
  {
    tab = ses->tab;
    if ( tab )
    {
      if ( ev && tab->term )
      {
        assert_failed = 0;
        goto LABEL_10;
      }
    }
  }
  v33 = ev;
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 1281;
  elinks_internal("assertion ses && ses->tab && ses->tab->term && ev failed!");
  ev = v33;
  if ( !assert_failed )
  {
LABEL_10:
    if ( !doc_view || !doc_view->document )
    {
      v40 = ev;
      assert_failed = 1;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 1226;
      elinks_internal("assertion doc_view && doc_view->document failed: document not formatted");
      ev = v40;
      if ( assert_failed )
        goto LABEL_42;
    }
    assert_failed = ses == 0 || ev == 0;
    if ( ses == 0 || ev == 0 )
    {
      v39 = ev;
      errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
      errline = 1229;
      elinks_internal("assertion ses && ev failed!");
      ev = v39;
      if ( assert_failed )
      {
LABEL_42:
        assert_failed = 0;
        goto LABEL_16;
      }
    }
    vs = doc_view->vs;
    if ( !vs )
    {
LABEL_16:
      v8 = FRAME_EVENT_IGNORED;
LABEL_17:
      v34 = (term_event *)v8;
      print_screen_status(ses);
      return v34;
    }
    if ( ev->ev != EVENT_KBD )
    {
      if ( ev->ev != EVENT_MOUSE )
        goto LABEL_16;
      x = ev->info.mouse.x;
      button = ev->info.mouse.button;
      y = ev->info.mouse.y;
      v11 = button & 7;
      if ( v11 > 2 )
      {
        if ( (button & 0x20) != 0 )
        {
LABEL_22:
          v8 = FRAME_EVENT_OK;
          goto LABEL_17;
        }
        if ( v11 != 3 )
        {
          if ( v11 != 4 )
            goto LABEL_22;
LABEL_64:
          v8 = scroll_mouse_down(ses, doc_view);
          goto LABEL_39;
        }
LABEL_74:
        v8 = scroll_mouse_up(ses, doc_view);
        goto LABEL_39;
      }
      v41 = ev;
      link_at_coordinates = get_link_at_coordinates(doc_view, x, y);
      if ( !link_at_coordinates )
      {
        v8 = FRAME_EVENT_IGNORED;
        if ( (*(_BYTE *)(&v41->info.size + 1) & 7) != 0 )
          goto LABEL_17;
        number = get_opt_(config_options, "document.browse.scrolling.margin")->number;
        if ( y >= number )
        {
          if ( y < doc_view->box.height - number )
          {
            if ( x < 2 * number )
            {
              opt = get_opt_(config_options, "document.browse.scrolling.horizontal_step");
              v8 = horizontal_scroll(ses, doc_view, -opt->number);
            }
            else
            {
              if ( x < doc_view->box.width - 2 * number )
                goto LABEL_22;
              v29 = get_opt_(config_options, "document.browse.scrolling.horizontal_step");
              v8 = horizontal_scroll(ses, doc_view, v29->number);
            }
            goto LABEL_39;
          }
          goto LABEL_64;
        }
        goto LABEL_74;
      }
      doc_view->vs->current_link = -991146299 * (((char *)link_at_coordinates - (char *)doc_view->document->links) >> 2);
      ses->navigate_mode = NAVIGATE_LINKWISE;
      type = link_at_coordinates->type;
      v8 = FRAME_EVENT_REFRESH;
      if ( (unsigned int)(type - 5) <= 1 )
        goto LABEL_40;
      refresh_view(ses, doc_view, 0);
      v27 = v41->info.mouse.button;
      if ( (v27 & 7) > 1 )
      {
        link_menu(ses->tab->term, 0, ses);
        v8 = FRAME_EVENT_OK;
        goto LABEL_17;
      }
      if ( (v27 & 0x20) == 0 )
      {
        term = ses->tab->term;
        term->prev_mouse_event.x = 0;
        term->prev_mouse_event.y = 0;
        term->prev_mouse_event.button = 0;
        v8 = FRAME_EVENT_OK;
        goto LABEL_17;
      }
      if ( (v27 & 7) != 0 )
      {
        open_current_link_in_new_tab(ses, 1);
        v8 = FRAME_EVENT_OK;
        goto LABEL_17;
      }
      v8 = enter(ses, doc_view, 0);
LABEL_39:
      if ( v8 != FRAME_EVENT_REFRESH )
        goto LABEL_17;
LABEL_40:
      v38 = (term_event *)v8;
      refresh_view(ses, doc_view, 0);
      return v38;
    }
    current_link = vs->current_link;
    if ( current_link >= 0 )
    {
      document = doc_view->document;
      if ( current_link < document->nlinks )
      {
        v14 = (int)&document->links[current_link];
        if ( v14 )
        {
          if ( (unsigned int)(*(_DWORD *)(v14 + 4) - 5) > 1 )
            goto LABEL_27;
          v42 = ev;
          v8 = kbd_action(KEYMAP_EDIT, ev, 0);
          ev = v42;
          if ( ses->insert_mode == INSERT_MODE_OFF && v8 == 14 )
          {
            ses->insert_mode = INSERT_MODE_ON;
            LOBYTE(v8) = 1;
            goto LABEL_40;
          }
          if ( !assert_failed )
LABEL_27:
            assert_failed = 0;
          if ( (unsigned int)(*(_DWORD *)(v14 + 4) - 5) <= 1 )
          {
            v35 = ev;
            v8 = field_op(ses, doc_view, (link *)v14, ev);
            ev = v35;
            if ( v8 )
            {
              if ( ses->insert_mode == INSERT_MODE_ON && !assert_failed )
              {
                v15 = doc_view->vs->current_link;
                if ( v15 < 0 || (v16 = doc_view->document, v15 >= v16->nlinks) )
                  v17 = 0;
                else
                  v17 = (int)&v16->links[v15];
                assert_failed = v14 != v17;
                if ( v14 != v17 )
                {
                  v36 = (term_event *)v8;
                  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
                  errline = 1090;
                  elinks_internal("assertion link == get_current_link(doc_view) failed!");
                  v8 = (frame_event_status)v36;
                }
              }
              goto LABEL_39;
            }
          }
        }
      }
    }
    v37 = ev;
    v18 = try_mark_key(ses, doc_view, ev);
    if ( v18 )
    {
LABEL_38:
      v8 = v18;
      goto LABEL_39;
    }
    v19 = get_opt_(config_options, "document.browse.accesskey.priority");
    v20 = v37;
    v32 = v19->number;
    if ( v19->number > 1 )
    {
      v8 = try_document_key(ses, doc_view, v37);
      v20 = v37;
      if ( v8 )
        goto LABEL_39;
    }
    v44 = doc_view->document;
    v21 = v20->info.mouse.x - 48;
    xa = v20->info.mouse.x;
    if ( (unsigned int)v21 > 9 )
      goto LABEL_65;
    if ( v20->info.mouse.y )
    {
      if ( !ses->kbdprefix.repeat_count )
      {
LABEL_68:
        ses->kbdprefix.repeat_count = v21;
        goto LABEL_69;
      }
    }
    else if ( !ses->kbdprefix.repeat_count )
    {
      num_links_key = v44->options.num_links_key;
      if ( !num_links_key || num_links_key == 1 && (*((_BYTE *)&v44->options + 69) & 0x10) == 0 )
        goto LABEL_68;
      if ( v20->info.mouse.x != 48 )
      {
        nlinks = v44->nlinks;
        def[0] = xa;
        def[1] = 0;
        ses->kbdprefix.repeat_count = 0;
        if ( nlinks )
        {
          v24 = 1;
          do
          {
            ++v24;
            nlinks /= 10;
          }
          while ( nlinks );
          input_dialog(
            ses->tab->term,
            0,
            "Go to link",
            "Enter link number",
            ses,
            0,
            v24,
            def,
            1,
            v44->nlinks,
            check_number,
            (void (*)(void *, unsigned __int8 *))goto_link_number,
            0);
        }
        goto LABEL_22;
      }
LABEL_65:
      if ( v32 == 1 )
      {
        v8 = try_document_key(ses, doc_view, v20);
        goto LABEL_39;
      }
      goto LABEL_38;
    }
    v43 = (term_event *)(v20->info.mouse.x - 48);
    draw_formatted(ses, 0);
    v21 = (int)v43 + 10 * ses->kbdprefix.repeat_count;
    ses->kbdprefix.repeat_count = v21;
    if ( v21 > 99999 )
    {
      ses->kbdprefix.repeat_count = 0;
      goto LABEL_22;
    }
LABEL_69:
    if ( v21 )
      highlight_links_with_prefixes_that_start_with_n(ses->tab->term, doc_view, v21);
    goto LABEL_22;
  }
LABEL_7:
  assert_failed = 0;
  return 0;
}

//----- (080FE0C0) --------------------------------------------------------
frame_event_status __cdecl scroll_right(session *ses, document_view *doc_view)
{
  int number; // eax

  number = eat_kbd_repeat_count(ses);
  if ( !number )
    number = get_opt_(config_options, "document.browse.scrolling.horizontal_step")->number;
  return horizontal_scroll(ses, doc_view, number);
}

//----- (080FE110) --------------------------------------------------------
frame_event_status __cdecl scroll_left(session *ses, document_view *doc_view)
{
  int number; // eax

  number = eat_kbd_repeat_count(ses);
  if ( !number )
    number = get_opt_(config_options, "document.browse.scrolling.horizontal_step")->number;
  return horizontal_scroll(ses, doc_view, -number);
}

//----- (080FE160) --------------------------------------------------------
frame_event_status __cdecl scroll_down(session *ses, document_view *doc_view)
{
  int number; // eax

  number = eat_kbd_repeat_count(ses);
  if ( !number )
    number = get_opt_(config_options, "document.browse.scrolling.vertical_step")->number;
  return vertical_scroll(ses, doc_view, number);
}

//----- (080FE1B0) --------------------------------------------------------
frame_event_status __cdecl scroll_up(session *ses, document_view *doc_view)
{
  int number; // eax

  number = eat_kbd_repeat_count(ses);
  if ( !number )
    number = get_opt_(config_options, "document.browse.scrolling.vertical_step")->number;
  return vertical_scroll(ses, doc_view, -number);
}

//----- (080FE200) --------------------------------------------------------
int __cdecl try_jump_to_link_number(session *ses, document_view *doc_view)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax

  v2 = eat_kbd_repeat_count(ses);
  v3 = 1;
  v4 = v2 - 1;
  if ( v4 < 0 )
    return v3;
  if ( !doc_view || v4 >= doc_view->document->nlinks )
    return 0;
  jump_to_link_number(ses, doc_view, v4);
  refresh_view(ses, doc_view, 0);
  return 1;
}

//----- (080FE280) --------------------------------------------------------
frame_event_status __cdecl copy_current_link_to_clipboard(session *ses, document_view *doc_view, int xxx)
{
  int current_link; // edx
  document *document; // ecx
  link *v5; // edx
  uri *link_uri; // eax
  uri *v7; // ebx
  unsigned __int8 *uri_string; // esi

  if ( doc_view )
  {
    current_link = doc_view->vs->current_link;
    if ( current_link >= 0 )
    {
      document = doc_view->document;
      if ( current_link < document->nlinks )
      {
        v5 = &document->links[current_link];
        if ( v5 )
        {
          link_uri = get_link_uri(ses, doc_view, v5);
          v7 = link_uri;
          if ( link_uri )
          {
            uri_string = get_uri_string(link_uri, URI_ORIGINAL);
            done_uri(v7);
            if ( uri_string )
            {
              set_clipboard_text(uri_string);
              mem_free(uri_string);
            }
          }
        }
      }
    }
  }
  return 2;
}

//----- (080FE310) --------------------------------------------------------
frame_event_status __cdecl move_cursor(session *ses, document_view *doc_view, int x, int y)
{
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  frame_event_status result; // eax
  view_state *vs; // ecx
  int v9; // edx
  int v10; // eax
  int v11; // eax
  link *link_at_coordinates; // eax
  int v13; // [esp+1Ch] [ebp-3Ch]
  int v14; // [esp+1Ch] [ebp-3Ch]
  int v15; // [esp+2Ch] [ebp-2Ch]
  terminal *term; // [esp+30h] [ebp-28h]
  int max_height; // [esp+34h] [ebp-24h]
  int v18; // [esp+38h] [ebp-20h]
  int v19; // [esp+38h] [ebp-20h]
  int max_width; // [esp+3Ch] [ebp-1Ch]

  v4 = x;
  term = ses->tab->term;
  v5 = doc_view->box.x;
  if ( v5 > x )
  {
    vs = doc_view->vs;
    v18 = vs->y;
    v13 = vs->x;
    v6 = doc_view->box.y;
    if ( v6 > y )
      goto LABEL_3;
    max_height = doc_view->document->height - v18;
    max_width = doc_view->document->width - v13;
    v14 = v6 + doc_view->box.height;
    v19 = v14;
    v9 = y;
    if ( v14 <= y )
      goto LABEL_24;
    goto LABEL_8;
  }
  v6 = doc_view->box.y;
  if ( v6 > y )
  {
LABEL_3:
    result = vertical_scroll(ses, doc_view, y - v6);
    goto LABEL_4;
  }
  if ( v5 + doc_view->box.width <= x )
  {
    v14 = v6 + doc_view->box.height;
LABEL_23:
    max_height = doc_view->document->height - doc_view->vs->y;
    max_width = doc_view->document->width - doc_view->vs->x;
    v19 = v14;
    v9 = y;
    if ( v14 <= y )
    {
LABEL_24:
      if ( max_height >= v9 )
      {
        result = vertical_scroll(ses, doc_view, v9 + 1 - v14);
        goto LABEL_4;
      }
    }
LABEL_8:
    if ( v5 > x )
    {
      result = horizontal_scroll(ses, doc_view, x - v5);
    }
    else
    {
      v10 = doc_view->box.width + v5;
      if ( max_width < x || v10 > x )
      {
        v11 = v10 - 1;
        goto LABEL_11;
      }
      result = horizontal_scroll(ses, doc_view, x - v10 + 1);
    }
LABEL_4:
    if ( result != FRAME_EVENT_REFRESH )
      return result;
    v11 = doc_view->box.x;
    if ( v11 > x )
    {
      v6 = doc_view->box.y;
      v19 = v6 + doc_view->box.height;
LABEL_13:
      if ( y < v6 || (v6 = v19 - 1, v19 - 1 < y) )
      {
        v4 = v11;
      }
      else
      {
        v6 = y;
        v4 = v11;
      }
      goto LABEL_16;
    }
    v6 = doc_view->box.y;
    v11 = doc_view->box.width + v11 - 1;
    v19 = v6 + doc_view->box.height;
LABEL_11:
    if ( v11 > x )
      v11 = x;
    goto LABEL_13;
  }
  v14 = v6 + doc_view->box.height;
  if ( v14 <= y )
    goto LABEL_23;
  v6 = y;
LABEL_16:
  ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
  v15 = v6;
  link_at_coordinates = get_link_at_coordinates(doc_view, v4 - doc_view->box.x, v6 - doc_view->box.y);
  if ( link_at_coordinates )
    doc_view->vs->current_link = -991146299 * (((char *)link_at_coordinates - (char *)doc_view->document->links) >> 2);
  else
    doc_view->vs->current_link = -1;
  set_cursor(term, v4, v15, 0);
  ses->tab->x = v4;
  ses->tab->y = v15;
  return 1;
}

//----- (080FE590) --------------------------------------------------------
frame_event_status __usercall move_cursor_rel@<eax>(
        session *ses@<eax>,
        document_view *view@<edx>,
        int rx@<ecx>,
        int ry)
{
  int v7; // eax

  v7 = eat_kbd_repeat_count(ses);
  if ( v7 <= 0 )
    v7 = 1;
  return move_cursor(ses, view, ses->tab->x + v7 * rx, ses->tab->y + v7 * ry);
}

//----- (080FE5F0) --------------------------------------------------------
frame_event_status __cdecl move_cursor_line_start(session *ses, document_view *doc_view)
{
  session *v2; // eax
  document_view *v3; // edx

  v2 = ses;
  v3 = doc_view;
  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs )
  {
    assert_failed = 0;
    return move_cursor_rel(v2, v3, v3->box.x - (v3->vs->x + v2->tab->x), 0);
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 895;
  elinks_internal("assertion ses && doc_view && doc_view->vs failed!");
  v2 = ses;
  v3 = doc_view;
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 2;
  }
  return move_cursor_rel(v2, v3, v3->box.x - (v3->vs->x + v2->tab->x), 0);
}

//----- (080FE6A0) --------------------------------------------------------
frame_event_status __cdecl move_cursor_down(session *ses, document_view *view)
{
  return move_cursor_rel(ses, view, 0, 1);
}

//----- (080FE6C0) --------------------------------------------------------
frame_event_status __cdecl move_cursor_up(session *ses, document_view *view)
{
  return move_cursor_rel(ses, view, 0, -1);
}

//----- (080FE6E0) --------------------------------------------------------
frame_event_status __cdecl move_cursor_right(session *ses, document_view *view)
{
  return move_cursor_rel(ses, view, 1, 0);
}

//----- (080FE700) --------------------------------------------------------
frame_event_status __cdecl move_cursor_left(session *ses, document_view *view)
{
  return move_cursor_rel(ses, view, -1, 0);
}

//----- (080FE720) --------------------------------------------------------
frame_event_status __cdecl move_link_next_line(session *ses, document_view *doc_view)
{
  frame_event_status result; // eax
  view_state *v3; // edx
  document *v4; // ecx
  window *tab; // eax
  int current_link; // eax
  link *v7; // edx
  int v8; // edx
  int height; // esi
  int y; // ebx
  int v11; // eax
  int v12; // edi
  link *v13; // eax
  link *v14; // ecx
  link *v15; // ebx
  int *p_x; // esi
  int v17; // esi
  int v18; // ebx
  point *points; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  int v23; // edx
  document *v24; // ecx
  int v25; // eax
  int v26; // [esp+10h] [ebp-48h]
  int x1; // [esp+14h] [ebp-44h]
  view_state *vs; // [esp+18h] [ebp-40h]
  int y1; // [esp+1Ch] [ebp-3Ch]
  int v30; // [esp+20h] [ebp-38h]
  document *document; // [esp+24h] [ebp-34h]
  int v32; // [esp+2Ch] [ebp-2Ch]
  int max_x; // [esp+38h] [ebp-20h] BYREF
  int min_x[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || !doc_view->vs || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 819;
    elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_10;
LABEL_4:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
LABEL_10:
  v3 = doc_view->vs;
  vs = v3;
  v4 = doc_view->document;
  document = v4;
  if ( !v4->lines1 )
  {
    v25 = v3->y + doc_view->box.height;
    if ( v25 < v4->height )
    {
      v3->y = v25;
      return 1;
    }
    return 2;
  }
  tab = ses->tab;
  y1 = v3->y + tab->y - doc_view->box.y;
  x1 = v3->x + tab->x - doc_view->box.x;
  current_link = v3->current_link;
  if ( current_link >= 0 && current_link < v4->nlinks && (v7 = &v4->links[current_link]) != 0 )
  {
    get_link_x_bounds(v7, y1, min_x, &max_x);
  }
  else
  {
    max_x = x1;
    min_x[0] = x1;
  }
  v8 = y1;
  height = document->height;
  y = vs->y;
  v11 = height - 1;
  v12 = doc_view->box.height;
  if ( y1 > height - 1 )
    v8 = height - 1;
  if ( y + 2 * v12 - 1 <= v11 )
    v11 = y + 2 * v12 - 1;
  v26 = doc_view->box.height;
  v30 = v11;
  if ( v8 > v11 )
  {
LABEL_33:
    v18 = v26 + y;
    if ( height > v18 )
    {
      result = FRAME_EVENT_REFRESH;
      vs->y = v18;
      ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
      return result;
    }
    return 2;
  }
  v32 = v8;
  while ( 1 )
  {
    v13 = document->lines1[v32];
    if ( v13 )
    {
      v14 = document->lines2[v32];
      if ( v13 <= v14 )
      {
        v15 = 0;
        do
        {
          while ( 1 )
          {
            p_x = &v13->points->x;
            if ( p_x[1] == v8 )
            {
              v17 = *p_x;
              if ( v17 > min_x[0] && (!v15 || v17 < v15->points->x) )
                break;
            }
            if ( ++v13 > v14 )
              goto LABEL_30;
          }
          v15 = v13++;
        }
        while ( v13 <= v14 );
LABEL_30:
        if ( v15 )
          break;
      }
    }
    ++v8;
    ++v32;
    min_x[0] = -1;
    if ( v30 < v8 )
    {
      y = vs->y;
      height = document->height;
      goto LABEL_33;
    }
  }
  points = v15->points;
  v20 = vs->y;
  v21 = points->y;
  if ( v21 >= v20 + v26 )
  {
    v22 = document->height + ~v20;
    if ( v22 > v26 )
      v22 = v26;
    v21 -= v22;
    vs->y = v22 + v20;
    points = v15->points;
  }
  result = move_cursor(ses, doc_view, points->x + ses->tab->x - x1, ses->tab->y + v21 - y1);
  v23 = doc_view->vs->current_link;
  if ( v23 >= 0 )
  {
    v24 = doc_view->document;
    if ( v23 < v24->nlinks && &v24->links[v23] == v15 )
      ses->navigate_mode = NAVIGATE_LINKWISE;
  }
  return result;
}
// 80FE720: using guessed type int min_x[7];

//----- (080FEA20) --------------------------------------------------------
frame_event_status __cdecl move_link_prev_line(session *ses, document_view *doc_view)
{
  frame_event_status result; // eax
  view_state *v3; // edx
  window *tab; // eax
  int current_link; // eax
  link *v6; // edx
  int y; // eax
  int v8; // edx
  int v9; // ecx
  link *v10; // eax
  link *v11; // ecx
  link *v12; // ebx
  int *p_x; // esi
  int v14; // esi
  int v15; // edx
  int v16; // eax
  point *points; // eax
  int v18; // edx
  int v19; // ecx
  int height; // eax
  int v21; // edx
  document *v22; // ecx
  int v23; // edx
  int x1; // [esp+14h] [ebp-44h]
  view_state *vs; // [esp+18h] [ebp-40h]
  int y1; // [esp+1Ch] [ebp-3Ch]
  int v27; // [esp+20h] [ebp-38h]
  document *document; // [esp+24h] [ebp-34h]
  int v29; // [esp+2Ch] [ebp-2Ch]
  int max_x; // [esp+38h] [ebp-20h] BYREF
  int min_x[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || !doc_view->vs || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 739;
    elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_10;
LABEL_4:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
LABEL_10:
  v3 = doc_view->vs;
  vs = v3;
  document = doc_view->document;
  if ( !document->lines1 )
  {
    if ( v3->y )
    {
      result = FRAME_EVENT_REFRESH;
      v23 = v3->y - doc_view->box.height;
      vs->y = v23;
      if ( v23 < 0 )
      {
        vs->y = 0;
        return 1;
      }
      return result;
    }
    return 2;
  }
  tab = ses->tab;
  y1 = v3->y + tab->y - doc_view->box.y;
  x1 = v3->x + tab->x - doc_view->box.x;
  current_link = v3->current_link;
  if ( current_link >= 0 && current_link < document->nlinks && (v6 = &document->links[current_link]) != 0 )
  {
    get_link_x_bounds(v6, y1, min_x, &max_x);
  }
  else
  {
    max_x = x1;
    min_x[0] = x1;
  }
  y = vs->y;
  v8 = document->height - 1;
  if ( y1 <= v8 )
    v8 = y1;
  v9 = y - doc_view->box.height;
  if ( v9 < 0 )
    v9 = 0;
  v27 = v9;
  if ( v8 < v9 )
  {
LABEL_33:
    if ( y )
    {
      v15 = 0;
      v16 = y - doc_view->box.height;
      if ( v16 >= 0 )
        v15 = v16;
      vs->y = v15;
      ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
      return 1;
    }
    return 2;
  }
  v29 = v8;
  while ( 1 )
  {
    v10 = document->lines1[v29];
    if ( v10 )
    {
      v11 = document->lines2[v29];
      if ( v10 <= v11 )
      {
        v12 = 0;
        do
        {
          while ( 1 )
          {
            p_x = &v10->points->x;
            if ( p_x[1] == v8 )
            {
              v14 = *p_x;
              if ( v14 < min_x[0] && (!v12 || v14 > v12->points->x) )
                break;
            }
            if ( ++v10 > v11 )
              goto LABEL_30;
          }
          v12 = v10++;
        }
        while ( v10 <= v11 );
LABEL_30:
        if ( v12 )
          break;
      }
    }
    --v8;
    --v29;
    min_x[0] = 0x7FFFFFFF;
    if ( v27 > v8 )
    {
      y = vs->y;
      goto LABEL_33;
    }
  }
  points = v12->points;
  v18 = points->y;
  v19 = vs->y;
  if ( v18 < v19 )
  {
    height = doc_view->box.height;
    if ( height > v19 )
      height = vs->y;
    v18 += height;
    vs->y = v19 - height;
    points = v12->points;
  }
  result = move_cursor(ses, doc_view, points->x + ses->tab->x - x1, ses->tab->y + v18 - y1);
  v21 = doc_view->vs->current_link;
  if ( v21 >= 0 )
  {
    v22 = doc_view->document;
    if ( v21 < v22->nlinks && &v22->links[v21] == v12 )
      ses->navigate_mode = NAVIGATE_LINKWISE;
  }
  return result;
}
// 80FEA20: using guessed type int min_x[7];

//----- (080FED20) --------------------------------------------------------
frame_event_status __cdecl move_link_down_line(session *ses, document_view *doc_view)
{
  frame_event_status result; // eax
  document *document; // ecx
  link **lines1; // edx
  int v5; // eax
  window *tab; // edi
  int v7; // eax
  link *v8; // ebx
  int v9; // edx
  document_view *v10; // esi
  int v11; // eax
  int current_link; // edx
  document *v13; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // [esp+24h] [ebp-44h]
  int v17; // [esp+28h] [ebp-40h]
  link **v18; // [esp+2Ch] [ebp-3Ch]
  view_state *vs; // [esp+30h] [ebp-38h]
  int v20; // [esp+34h] [ebp-34h]
  int v21; // [esp+38h] [ebp-30h]
  int v22; // [esp+3Ch] [ebp-2Ch]
  int height; // [esp+40h] [ebp-28h]
  int y; // [esp+48h] [ebp-20h]
  int v25; // [esp+4Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || !doc_view->vs || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 676;
    elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_10;
LABEL_4:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
LABEL_10:
  vs = doc_view->vs;
  document = doc_view->document;
  lines1 = document->lines1;
  if ( !lines1 )
  {
    v15 = vs->y + doc_view->box.height;
    if ( v15 < document->height )
    {
      vs->y = v15;
      return 1;
    }
    return 2;
  }
  y = vs->y;
  height = doc_view->box.height;
  v5 = y + 2 * height - 1;
  v16 = document->height;
  if ( v5 > v16 - 1 )
    v5 = v16 - 1;
  v17 = v5;
  v21 = v16 - 1;
  tab = ses->tab;
  v20 = tab->y;
  v7 = y + v20 - doc_view->box.y + 1;
  v25 = y + v20 - doc_view->box.y;
  if ( v7 > v17 )
  {
LABEL_34:
    if ( v16 > y + height )
    {
      vs->y = y + height;
      result = FRAME_EVENT_REFRESH;
      ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
      return result;
    }
    return 2;
  }
  v22 = v7;
  v18 = &lines1[v7];
  while ( 1 )
  {
    v8 = *v18;
    if ( *v18 )
    {
      if ( v8 <= document->lines2[v22] )
        break;
    }
LABEL_33:
    ++v7;
    ++v18;
    ++v22;
    if ( v7 > v17 )
      goto LABEL_34;
  }
  v9 = v8->points->y;
  if ( v9 != v7 )
  {
    v10 = doc_view;
    while ( 1 )
    {
      if ( ++v8 > document->lines2[v22] )
        goto LABEL_33;
      v9 = v8->points->y;
      if ( v9 == v7 )
        goto LABEL_21;
    }
  }
  v10 = doc_view;
LABEL_21:
  if ( v9 >= y + height )
  {
    v11 = v21 - y;
    if ( v21 - y > height )
      v11 = doc_view->box.height;
    vs->y = v11 + y;
    v7 = v9 - v11;
    tab = ses->tab;
    v20 = tab->y;
  }
  result = move_cursor(ses, v10, tab->x, v20 + v7 - v25);
  current_link = v10->vs->current_link;
  if ( current_link < 0 || (v13 = v10->document, current_link >= v13->nlinks) )
    v14 = 0;
  else
    v14 = (int)&v13->links[current_link];
  if ( (link *)v14 == v8 )
    ses->navigate_mode = NAVIGATE_LINKWISE;
  return result;
}

//----- (080FEF80) --------------------------------------------------------
frame_event_status __cdecl move_link_up_line(session *ses, document_view *doc_view)
{
  frame_event_status result; // eax
  document *document; // edi
  link **lines1; // edx
  int v5; // ebx
  int height; // ecx
  int v7; // eax
  int v8; // eax
  link *v9; // ebx
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int current_link; // edx
  document *v14; // ecx
  int v15; // edx
  int v16; // edx
  int v17; // eax
  int v18; // [esp+38h] [ebp-40h]
  link **v19; // [esp+3Ch] [ebp-3Ch]
  int v20; // [esp+40h] [ebp-38h]
  view_state *vs; // [esp+44h] [ebp-34h]
  int v22; // [esp+48h] [ebp-30h]
  window *tab; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+54h] [ebp-24h]
  int y; // [esp+5Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || !doc_view->vs || !doc_view->document )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 611;
    elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
    if ( !assert_failed )
      goto LABEL_10;
LABEL_4:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
LABEL_10:
  vs = doc_view->vs;
  document = doc_view->document;
  lines1 = document->lines1;
  if ( !lines1 )
  {
    if ( doc_view->vs->y )
    {
      result = FRAME_EVENT_REFRESH;
      v16 = doc_view->vs->y - doc_view->box.height;
      vs->y = v16;
      if ( v16 < 0 )
        vs->y = 0;
      return result;
    }
    return 2;
  }
  v5 = 0;
  y = vs->y;
  height = doc_view->box.height;
  if ( y - height >= 0 )
    v5 = y - height;
  v18 = y - height;
  v24 = v5;
  tab = ses->tab;
  v20 = tab->y;
  v7 = document->height - 1;
  if ( y + v20 - doc_view->box.y <= v7 )
    v7 = y + v20 - doc_view->box.y;
  v8 = v7 - 1;
  if ( v8 < v5 )
  {
LABEL_37:
    if ( y )
    {
      v17 = 0;
      if ( v18 >= 0 )
        v17 = v18;
      vs->y = v17;
      ses->navigate_mode = NAVIGATE_CURSOR_ROUTING;
      return 1;
    }
    return 2;
  }
  v22 = v8;
  v19 = &lines1[v8];
  while ( 1 )
  {
    v9 = *v19;
    if ( *v19 )
    {
      if ( v9 <= document->lines2[v22] )
        break;
    }
LABEL_36:
    --v8;
    --v19;
    --v22;
    if ( v8 < v24 )
      goto LABEL_37;
  }
  v10 = v9->points->y;
  if ( v10 != v8 )
  {
    v11 = y + v20 - doc_view->box.y;
    while ( 1 )
    {
      if ( ++v9 > document->lines2[v22] )
        goto LABEL_36;
      v10 = v9->points->y;
      if ( v10 == v8 )
        goto LABEL_23;
    }
  }
  v11 = y + v20 - doc_view->box.y;
LABEL_23:
  if ( y > v10 )
  {
    v12 = vs->y;
    if ( doc_view->box.height <= y )
      v12 = doc_view->box.height;
    vs->y = y - v12;
    v8 = v10 + v12;
    tab = ses->tab;
    v20 = tab->y;
  }
  result = move_cursor(ses, doc_view, tab->x, v20 + v8 - v11);
  current_link = doc_view->vs->current_link;
  if ( current_link < 0 || (v14 = doc_view->document, current_link >= v14->nlinks) )
    v15 = 0;
  else
    v15 = (int)&v14->links[current_link];
  if ( (link *)v15 == v9 )
    ses->navigate_mode = NAVIGATE_LINKWISE;
  return result;
}

//----- (080FF1F0) --------------------------------------------------------
frame_event_status __cdecl move_document_end(session *ses, document_view *doc_view)
{
  int v3; // eax
  int v4; // edx
  view_state *vs; // eax

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 432;
  elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 2;
  }
LABEL_9:
  v3 = doc_view->document->height - doc_view->box.height;
  doc_view->vs->x = 0;
  v4 = 0;
  if ( v3 >= 0 )
    v4 = v3;
  vs = doc_view->vs;
  if ( vs->y < v4 )
    vs->y = v4;
  if ( ses->navigate_mode == NAVIGATE_CURSOR_ROUTING )
    move_cursor(ses, doc_view, ses->tab->x, doc_view->document->height - doc_view->vs->y);
  else
    find_link_page_up(doc_view);
  return 1;
}

//----- (080FF300) --------------------------------------------------------
frame_event_status __cdecl move_document_start(session *ses, document_view *doc_view)
{
  view_state *vs; // eax

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_8;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 412;
  elinks_internal("assertion ses && doc_view && doc_view->vs failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 2;
  }
LABEL_8:
  vs = doc_view->vs;
  vs->x = 0;
  vs->y = 0;
  if ( ses->navigate_mode == NAVIGATE_CURSOR_ROUTING )
    move_cursor(ses, doc_view, doc_view->box.x, doc_view->box.y);
  else
    find_link_page_down(doc_view);
  return 1;
}

//----- (080FF3F0) --------------------------------------------------------
void __cdecl toggle_wrap_text(session *ses, document_view *doc_view, int xxxx)
{
  window *tab; // eax
  view_state *vs; // eax

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || (tab = ses->tab) == 0 || !tab->term )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 485;
    elinks_internal("assertion ses && doc_view && ses->tab && ses->tab->term failed!");
    if ( !assert_failed )
      goto LABEL_9;
LABEL_4:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_9:
  vs = doc_view->vs;
  if ( vs )
  {
    *((_BYTE *)vs + 44) = (*((_BYTE *)vs + 44) ^ 1) & 1 | *((_BYTE *)vs + 44) & 0xFE;
    draw_formatted(ses, 1);
  }
  else
  {
    nowhere_box(ses->tab->term, 0);
  }
}

//----- (080FF4D0) --------------------------------------------------------
void __cdecl toggle_plain_html(session *ses, document_view *doc_view, int xxxx)
{
  window *tab; // eax
  view_state *vs; // eax

  if ( assert_failed )
    goto LABEL_4;
  if ( !doc_view || !ses || (tab = ses->tab) == 0 || !tab->term )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 470;
    elinks_internal("assertion ses && doc_view && ses->tab && ses->tab->term failed!");
    if ( !assert_failed )
      goto LABEL_9;
LABEL_4:
    assert_failed = 0;
    return;
  }
  assert_failed = 0;
LABEL_9:
  vs = doc_view->vs;
  if ( vs )
  {
    vs->plain = vs->plain == 0;
    draw_formatted(ses, 1);
  }
  else
  {
    nowhere_box(ses->tab->term, 0);
  }
}

//----- (080FF5B0) --------------------------------------------------------
frame_event_status __cdecl set_frame(session *ses, document_view *doc_view, int xxxx)
{
  if ( assert_failed )
    goto LABEL_8;
  if ( !ses || !doc_view || !ses->doc_view || !doc_view->vs )
  {
    assert_failed = 1;
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 456;
    elinks_internal("assertion ses && ses->doc_view && doc_view && doc_view->vs failed!");
    if ( !assert_failed )
      goto LABEL_6;
LABEL_8:
    assert_failed = 0;
    return 2;
  }
  assert_failed = 0;
LABEL_6:
  if ( ses->doc_view != doc_view )
  {
    goto_uri(ses, doc_view->vs->uri);
    ses->navigate_mode = NAVIGATE_LINKWISE;
  }
  return 2;
}

//----- (080FF670) --------------------------------------------------------
void __usercall move_down(session *ses@<eax>, document_view *doc_view@<edx>, int type@<ecx>)
{
  navigate_mode navigate_mode; // edx
  view_state *vs; // edx
  int v7; // eax
  session *v8; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 92;
  v8 = ses;
  elinks_internal("assertion ses && doc_view && doc_view->vs failed!");
  ses = v8;
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return;
  }
LABEL_9:
  navigate_mode = ses->navigate_mode;
  assert_failed = navigate_mode != NAVIGATE_LINKWISE;
  if ( navigate_mode )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 95;
    elinks_internal("assertion ses->navigate_mode == NAVIGATE_LINKWISE failed!");
  }
  vs = doc_view->vs;
  v7 = vs->y + doc_view->box.height;
  if ( v7 < doc_view->document->height )
    vs->y = v7;
  if ( !current_link_is_visible(doc_view) )
  {
    if ( type )
      find_link_down(doc_view);
    else
      find_link_page_down(doc_view);
  }
}

//----- (080FF780) --------------------------------------------------------
frame_event_status __cdecl move_page_down(session *ses, document_view *doc_view)
{
  int v2; // eax
  int v3; // ebx
  int oldy; // [esp+1Ch] [ebp-1Ch]

  oldy = doc_view->vs->y;
  v2 = eat_kbd_repeat_count(ses);
  ses->navigate_mode = NAVIGATE_LINKWISE;
  v3 = v2;
  do
  {
    --v3;
    move_down(ses, doc_view, 0);
  }
  while ( v3 > 0 );
  return (doc_view->vs->y == oldy) + 1;
}

//----- (080FF7E0) --------------------------------------------------------
void __usercall move_up(session *ses@<eax>, document_view *doc_view@<edx>, int type@<ecx>)
{
  navigate_mode navigate_mode; // ecx
  view_state *vs; // eax
  int y; // edx
  view_state *v8; // eax
  session *v9; // [esp+1Ch] [ebp-Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 130;
  v9 = ses;
  elinks_internal("assertion ses && doc_view && doc_view->vs failed!");
  ses = v9;
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return;
  }
LABEL_9:
  navigate_mode = ses->navigate_mode;
  assert_failed = navigate_mode != NAVIGATE_LINKWISE;
  if ( navigate_mode )
  {
    errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
    errline = 133;
    elinks_internal("assertion ses->navigate_mode == NAVIGATE_LINKWISE failed!");
  }
  vs = doc_view->vs;
  y = vs->y;
  if ( y )
  {
    vs->y = y - doc_view->box.height;
    v8 = doc_view->vs;
    if ( v8->y < 0 )
      v8->y = 0;
    if ( !current_link_is_visible(doc_view) )
    {
      if ( type )
        find_link_up(doc_view);
      else
        find_link_page_up(doc_view);
    }
  }
}

//----- (080FF900) --------------------------------------------------------
frame_event_status __cdecl move_link_dir(session *ses, document_view *doc_view, int dir_x, int dir_y)
{
  int v5; // esi
  int current_link; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 238;
  elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 2;
  }
LABEL_9:
  ses->navigate_mode = NAVIGATE_LINKWISE;
  v5 = eat_kbd_repeat_count(ses);
  do
  {
    current_link = doc_view->vs->current_link;
    if ( next_link_in_dir(doc_view, dir_x, dir_y) )
      goto LABEL_13;
    if ( dir_y > 0 )
    {
      move_down(ses, doc_view, 1);
    }
    else
    {
      if ( !dir_y )
        goto LABEL_13;
      move_up(ses, doc_view, 1);
    }
    if ( doc_view->vs->current_link != current_link )
      set_textarea(doc_view, -dir_y);
LABEL_13:
    --v5;
  }
  while ( v5 > 0 );
  return 1;
}

//----- (080FFA40) --------------------------------------------------------
frame_event_status __cdecl move_page_up(session *ses, document_view *doc_view)
{
  int v2; // eax
  int v3; // ebx
  int oldy; // [esp+1Ch] [ebp-1Ch]

  oldy = doc_view->vs->y;
  v2 = eat_kbd_repeat_count(ses);
  ses->navigate_mode = NAVIGATE_LINKWISE;
  v3 = v2;
  do
  {
    --v3;
    move_up(ses, doc_view, 0);
  }
  while ( v3 > 0 );
  return (doc_view->vs->y == oldy) + 1;
}

//----- (080FFAA0) --------------------------------------------------------
frame_event_status __cdecl move_link(
        session *ses,
        document_view *doc_view,
        int direction,
        int wraparound_bound,
        int wraparound_link)
{
  int v6; // edi
  view_state *vs; // eax
  int current_link; // ebx
  int wraparound; // [esp+1Ch] [ebp-1Ch]

  if ( assert_failed )
    goto LABEL_4;
  if ( doc_view && ses && doc_view->vs && doc_view->document )
  {
    assert_failed = 0;
    goto LABEL_9;
  }
  assert_failed = 1;
  errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
  errline = 172;
  elinks_internal("assertion ses && doc_view && doc_view->vs && doc_view->document failed!");
  if ( assert_failed )
  {
LABEL_4:
    assert_failed = 0;
    return 2;
  }
LABEL_9:
  ses->navigate_mode = NAVIGATE_LINKWISE;
  if ( doc_view->document->nlinks <= 1 )
  {
    wraparound = 0;
    wraparound_bound = -1;
  }
  else
  {
    wraparound = get_opt_(config_options, "document.browse.links.wraparound")->number;
  }
  v6 = eat_kbd_repeat_count(ses);
  do
  {
    while ( 1 )
    {
      vs = doc_view->vs;
      current_link = vs->current_link;
      if ( current_link == wraparound_bound )
        break;
      if ( !next_link_in_view_y(doc_view, current_link + direction, direction) )
      {
        doc_view->vs->current_link = current_link;
        if ( direction <= 0 )
          goto LABEL_22;
        goto LABEL_14;
      }
LABEL_18:
      if ( --v6 <= 0 )
        return 1;
    }
    if ( !wraparound )
    {
      vs->current_link = current_link;
      if ( direction <= 0 )
      {
LABEL_22:
        move_up(ses, doc_view, 1);
LABEL_15:
        if ( current_link != wraparound_bound && doc_view->vs->current_link != current_link )
          set_textarea(doc_view, -direction);
        goto LABEL_18;
      }
LABEL_14:
      move_down(ses, doc_view, 1);
      goto LABEL_15;
    }
    --v6;
    jump_to_link_number(ses, doc_view, wraparound_link);
  }
  while ( v6 > 0 );
  return 1;
}

//----- (080FFC50) --------------------------------------------------------
void __cdecl detach_formatted(document_view *doc_view)
{
  view_state *vs; // eax

  if ( assert_failed
    || (assert_failed = doc_view == 0, !doc_view)
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c",
        errline = 66,
        elinks_internal("assertion doc_view failed!"),
        assert_failed) )
  {
    assert_failed = 0;
  }
  else
  {
    if ( doc_view->document )
    {
      release_document(doc_view->document);
      doc_view->document = 0;
    }
    vs = doc_view->vs;
    if ( vs )
    {
      vs->doc_view = 0;
      doc_view->vs = 0;
    }
    if ( doc_view->name )
      mem_free(doc_view->name);
    doc_view->name = 0;
  }
}

//----- (080FFD00) --------------------------------------------------------
void __cdecl send_event(session *ses, term_event *ev)
{
  session *v2; // ebx
  document_view *v3; // eax
  document_view *v4; // edi
  action_id_T v5; // eax
  int v6; // edx
  term_event *v7; // edi
  main_action v8; // esi
  frame_event_status v9; // eax
  int v10; // eax
  int number; // eax
  action_id_T v12; // edx
  int y; // eax
  char status; // dl
  int v15; // ecx
  int tab_number_by_xpos; // edi
  window *tab_by_number; // eax
  unsigned int button; // edx
  session *data; // eax
  document_view *v20; // edi
  document *document; // eax
  int x; // edx
  int v23; // eax
  int v24; // edx
  unsigned int v25; // edx
  window *tab; // edx
  window *next; // eax
  int v28; // [esp+1Ch] [ebp-5Ch]
  action_id_T action_id; // [esp+2Ch] [ebp-4Ch]
  void (**action_ida)(void); // [esp+2Ch] [ebp-4Ch]
  terminal *term; // [esp+30h] [ebp-48h]
  int v32; // [esp+34h] [ebp-44h]
  int v33; // [esp+38h] [ebp-40h]
  document_view *v34; // [esp+3Ch] [ebp-3Ch]
  document_view *v35; // [esp+3Ch] [ebp-3Ch]
  term_event v36; // [esp+4Ch] [ebp-2Ch] BYREF
  int event[4]; // [esp+5Ch] [ebp-1Ch] BYREF

  v2 = ses;
  if ( assert_failed
    || (assert_failed = ses == 0 || ev == 0) != 0
    && (errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c",
        errline = 1528,
        elinks_internal("assertion ses && ev failed!"),
        assert_failed) )
  {
    assert_failed = 0;
    return;
  }
  if ( ev->ev != EVENT_KBD )
  {
    if ( ev->ev != EVENT_MOUSE )
      goto LABEL_5;
    v35 = current_frame(ses);
    term = ses->tab->term;
    y = ev->info.mouse.y;
    if ( !y && (ev->info.mouse.button & 0x20) == 0 && (ev->info.mouse.button & 7) <= 2 )
    {
      activate_bfu_technology(ses, -1);
      (*((void (__cdecl **)(void *, term_event *))term->windows.next + 3))(term->windows.next, ev);
LABEL_5:
      if ( v2 )
        v2->kbdprefix.repeat_count = 0;
      return;
    }
    status = (char)ses->status;
    if ( (status & 1) != 0 )
    {
      v15 = (*((_BYTE *)&ses->status + 52) & 4) != 0 ? (status & 4) != 0 : term->height - 1 - ((status & 2) != 0);
      if ( y == v15 )
      {
        tab_number_by_xpos = get_tab_number_by_xpos(term, ev->info.mouse.x);
        tab_by_number = get_tab_by_number(term, term->current_tab);
        button = ev->info.mouse.button;
        if ( (button & 0x20) != 0 )
        {
          if ( (button & 7) == 1
            && tab_number_by_xpos == term->current_tab
            && ev->info.mouse.y == term->prev_mouse_event.y )
          {
            data = (session *)tab_by_number->data;
            if ( ses == data )
              v2 = 0;
            close_tab(term, data);
          }
        }
        else
        {
          v24 = button & 7;
          if ( v24 == 3 )
          {
            switch_current_tab(ses, -1);
          }
          else if ( v24 == 4 )
          {
            switch_current_tab(ses, 1);
          }
          else if ( tab_number_by_xpos != -1 )
          {
            action_id = (action_id_T)tab_by_number;
            switch_to_tab(term, tab_number_by_xpos, -1);
            v25 = ev->info.mouse.button & 7;
            if ( v25 == 1 )
            {
              memset(&term->prev_mouse_event, 0, sizeof(term->prev_mouse_event));
            }
            else if ( v25 == 2 )
            {
              tab_menu(*(session **)(action_id + 16), ev->info.mouse.x, ev->info.mouse.y, 1);
            }
          }
        }
        goto LABEL_5;
      }
    }
    if ( assert_failed )
    {
LABEL_57:
      assert_failed = 0;
    }
    else
    {
      v20 = v35;
      assert_failed = 0;
      if ( v35 )
      {
        while ( 1 )
        {
          if ( v20 && v20->document )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
            errline = 1308;
            elinks_internal("assertion doc_view && doc_view->document failed!");
            if ( assert_failed )
              goto LABEL_57;
          }
          document = v20->document;
          if ( document->options.box.x == v20->box.x && document->options.box.y == v20->box.y )
          {
            assert_failed = 0;
          }
          else
          {
            assert_failed = 1;
            errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
            errline = 1313;
            elinks_internal("assertion doc_view->document->options.box.x == doc_view->box.x && doc_view->document->option"
                            "s.box.y == doc_view->box.y failed: Jonas' 1.565 -> 1.566 patch sucks");
            if ( assert_failed )
              goto LABEL_57;
          }
          v28 = ev->info.mouse.y;
          x = ev->info.mouse.x;
          v23 = v20->box.x;
          if ( x >= v23 )
          {
            v33 = v20->box.y;
            if ( v28 >= v33 && x < v23 + v20->box.width && v28 < v20->box.height + v33 )
              break;
          }
          next_frame(ses, 1);
          v20 = current_frame(ses);
          if ( v35 == v20 )
            goto LABEL_58;
          if ( assert_failed )
            goto LABEL_57;
        }
        v32 = ev->info.mouse.y;
        if ( v35 != v20 )
        {
          draw_formatted(ses, 0);
          v32 = ev->info.mouse.y;
          v33 = v20->box.y;
          x = ev->info.mouse.x;
          v23 = v20->box.x;
        }
        v36.info.mouse.x = x - v23;
        v36.ev = EVENT_MOUSE;
        v36.info.mouse.y = v32 - v33;
        v36.info.mouse.button = ev->info.mouse.button;
        if ( send_to_frame(ses, v20, &v36) )
        {
LABEL_59:
          if ( (*((_BYTE *)&ses->status + 8) & 1) != 0
            && ev->info.mouse.y == term->height - 1
            && ev->info.mouse.x >= term->width - 9 )
          {
            menu_leds_info(term, 0, 0);
          }
          return;
        }
      }
    }
LABEL_58:
    if ( (ev->info.mouse.button & 7) == 2 )
    {
      tab_menu(ses, ev->info.mouse.x, ev->info.mouse.y, 0);
      return;
    }
    goto LABEL_59;
  }
  v3 = current_frame(ses);
  v4 = v3;
  if ( !v3 || !send_to_frame(ses, v3, ev) )
  {
    v5 = kbd_action(KEYMAP_MAIN, ev, event);
    v6 = v5;
    if ( v5 == 76 )
    {
      v34 = v4;
      v7 = ev;
      if ( ev->info.mouse.x == -512 )
        v6 = 77;
      v8 = v6;
    }
    else
    {
      v34 = v4;
      v7 = ev;
      v8 = v5;
    }
    while ( 1 )
    {
      v9 = do_action(ses, v8, 0);
      if ( v9 )
      {
        if ( (unsigned int)v9 <= FRAME_EVENT_OK )
          goto LABEL_5;
        if ( v9 == FRAME_EVENT_SESSION_DESTROYED )
          break;
      }
      if ( v8 == ACT_MAIN_SCRIPTING_FUNCTION )
      {
        trigger_event(event[0], ses);
        return;
      }
      if ( v7->info.mouse.x != -512 )
      {
        v10 = v7->info.mouse.y;
        if ( v10 != 4 )
        {
          if ( (v10 & 2) == 0 && v34 )
          {
            number = get_opt_(config_options, "document.browse.search.typeahead")->number;
            switch ( number )
            {
              case 1:
                v12 = 94;
                break;
              case 2:
                v12 = 95;
                break;
              case 0:
                return;
              default:
                errfile = "/home/naftali/source/elinks-0.12~pre5/src/viewer/text/view.c";
                errline = 1439;
                elinks_internal("invalid value for document.browse.search.typeahead");
                v12 = v8;
                break;
            }
            search_typeahead(ses, v34, v12);
            term_send_event(ses->tab->term, v7);
          }
          return;
        }
        v7->info.mouse.y = 0;
        activate_bfu_technology(ses, -1);
        action_ida = (void (**)(void))ses->tab->term->windows.next;
        action_ida[3]();
        tab = ses->tab;
        next = (window *)tab->term->windows.next;
        if ( action_ida == (void (**)(void))next )
        {
          deselect_mainmenu(next->term, (menu *)next->data);
          print_screen_status(ses);
          tab = ses->tab;
          next = (window *)tab->term->windows.next;
        }
        if ( tab != next )
          return;
        v7->info.mouse.y |= 4u;
        if ( v34
          && get_opt_(config_options, "document.browse.accesskey.priority")->number <= 0
          && try_document_key(ses, v34, v7) == FRAME_EVENT_REFRESH )
        {
          refresh_view(ses, v34, 0);
          return;
        }
        goto LABEL_5;
      }
      v8 = ACT_MAIN_REALLY_QUIT;
    }
  }
}
// 80FFD00: using guessed type int event[4];

//----- (08100400) --------------------------------------------------------
void __cdecl next_frame(session *ses, int p)
{
  document_view *doc_view; // eax
  document *document; // eax
  session *next; // eax
  location *current; // ecx
  list_head_elinks *p_scrn_frames; // edi
  int v7; // ebx
  location *v8; // esi
  int v9; // edx
  int v10; // esi

  if ( ses->history.current )
  {
    doc_view = ses->doc_view;
    if ( !doc_view || (document = doc_view->document) != 0 && document->frame_desc )
    {
      next = (session *)ses->scrn_frames.next;
      ses->navigate_mode = NAVIGATE_LINKWISE;
      current = ses->history.current;
      p_scrn_frames = &ses->scrn_frames;
      if ( &ses->scrn_frames == (list_head_elinks *)next )
      {
        v9 = current->vs.current_link + p;
        v7 = 1;
        current->vs.current_link = v9;
      }
      else
      {
        v7 = 0;
        do
        {
          while ( 1 )
          {
            v8 = next->history.current;
            if ( !v8 || !v8[1].vs.x )
              break;
            next = next->next;
            if ( p_scrn_frames == (list_head_elinks *)next )
              goto LABEL_11;
          }
          next = next->next;
          ++v7;
        }
        while ( p_scrn_frames != (list_head_elinks *)next );
LABEL_11:
        v9 = current->vs.current_link + p;
        if ( !v7 )
          v7 = 1;
        current->vs.current_link = v9;
      }
      if ( v9 < 0 )
      {
        v10 = v9 + v7;
        do
        {
          v9 = v10;
          v10 += v7;
        }
        while ( v10 - v7 < 0 );
        current->vs.current_link = v9;
      }
      current->vs.current_link = v9 % v7;
    }
  }
}

//----- (081004B0) --------------------------------------------------------
void __cdecl check_vs(document_view *doc_view)
{
  view_state *vs; // esi
  int current_link; // eax
  int v3; // edx
  link *links; // edi

  vs = doc_view->vs;
  current_link = vs->current_link;
  v3 = doc_view->document->nlinks - 1;
  if ( v3 < current_link )
  {
    vs->current_link = v3;
    current_link = v3;
  }
  if ( current_link == -1 )
  {
    find_link_page_down(doc_view);
  }
  else if ( !current_link_is_visible(doc_view) )
  {
    links = doc_view->document->links;
    set_pos_x(doc_view, &links[vs->current_link]);
    set_pos_y(doc_view, &links[vs->current_link]);
  }
}

//----- (08100550) --------------------------------------------------------
void __cdecl copy_vs(view_state *dst, view_state *src)
{
  view_state *v2; // esi
  view_state *v3; // ebx
  int v4; // eax
  uri *uri; // eax
  view_state *next; // edi
  list_head_elinks *p_forms; // ebx
  _DWORD *v8; // eax
  void *v9; // edx
  int form_info_len; // eax
  form_state *v11; // eax
  int v12; // edi
  int v13; // ebx
  const unsigned __int8 **v14; // esi
  form_view *form_view_in_vs; // eax
  view_state *vs; // [esp+14h] [ebp-24h]
  view_state *v17; // [esp+18h] [ebp-20h]
  form_state *dstfs; // [esp+1Ch] [ebp-1Ch]

  v2 = src;
  v3 = dst;
  dst->doc_view = src->doc_view;
  dst->uri = src->uri;
  dst->forms = src->forms;
  dst->form_info = src->form_info;
  dst->form_info_len = src->form_info_len;
  dst->x = src->x;
  dst->y = src->y;
  dst->current_link = src->current_link;
  dst->old_current_link = src->old_current_link;
  dst->plain = src->plain;
  v4 = *((_DWORD *)src + 11);
  dst->form_info = 0;
  dst->doc_view = 0;
  *((_DWORD *)dst + 11) = v4;
  uri = src->uri;
  ++uri->object.refcount;
  dst->uri = uri;
  *((_BYTE *)dst + 44) = (2 * (*((_WORD *)src->uri + 26) == 0)) | *((_BYTE *)dst + 44) & 0xFD;
  dst->forms.prev = &dst->forms;
  dst->forms.next = &dst->forms;
  next = (view_state *)src->forms.next;
  if ( next != (view_state *)&src->forms )
  {
    p_forms = &dst->forms;
    do
    {
      v8 = mem_calloc(1u, 0xCu);
      if ( v8 )
      {
        v8[2] = next->forms.next;
        v9 = p_forms->next;
        v8[1] = p_forms;
        *v8 = v9;
        p_forms->next = v8;
        *(_DWORD *)(*v8 + 4) = v8;
      }
      next = (view_state *)next->doc_view;
    }
    while ( next != (view_state *)&src->forms );
    v3 = dst;
    v2 = src;
  }
  form_info_len = v2->form_info_len;
  if ( form_info_len )
  {
    v11 = (form_state *)mem_alloc(36 * form_info_len);
    v3->form_info = v11;
    if ( v11 )
    {
      memcpy(v11, v2->form_info, 36 * v2->form_info_len);
      if ( v2->form_info_len > 0 )
      {
        v12 = 0;
        vs = v3;
        v13 = 0;
        v17 = v2;
        do
        {
          v14 = (const unsigned __int8 **)&v17->form_info[v12];
          dstfs = &vs->form_info[v12];
          if ( v14[4] )
            dstfs->value = stracpy(v14[4]);
          form_view_in_vs = 0;
          if ( *v14 )
            form_view_in_vs = find_form_view_in_vs(vs, *((_DWORD *)*v14 + 2));
          ++v13;
          ++v12;
          dstfs->form_view = form_view_in_vs;
        }
        while ( v17->form_info_len > v13 );
      }
    }
  }
}

//----- (081006F0) --------------------------------------------------------
void __cdecl destroy_vs(view_state *vs, int blast_ecmascript)
{
  int form_info_len; // eax
  bool v3; // zf
  form_view *next; // eax
  view_state *v5; // esi
  _DWORD *p_next; // edx

  form_info_len = vs->form_info_len;
  if ( form_info_len > 0 )
  {
    do
    {
      done_form_state(&vs->form_info[form_info_len - 1]);
      form_info_len = vs->form_info_len - 1;
      v3 = vs->form_info_len == 1;
      vs->form_info_len = form_info_len;
    }
    while ( form_info_len >= 0 && !v3 );
  }
  if ( vs->form_info )
    mem_free(vs->form_info);
  next = (form_view *)vs->forms.next;
  vs->form_info = 0;
  v5 = (view_state *)next->next;
  if ( next != (form_view *)&vs->forms )
  {
    p_next = &next->next->next;
    while ( 1 )
    {
      p_next[1] = next->prev;
      next->prev->next = next->next;
      done_form_view(next);
      p_next = &v5->doc_view->next;
      next = (form_view *)v5;
      if ( &vs->forms == (list_head_elinks *)v5 )
        break;
      v5 = (view_state *)v5->doc_view;
    }
  }
  if ( vs->uri )
    done_uri(vs->uri);
  if ( vs->doc_view )
  {
    vs->doc_view->vs = 0;
    vs->doc_view = 0;
  }
}

//----- (081007A0) --------------------------------------------------------
void __cdecl init_vs(view_state *vs, uri *uri, int plain)
{
  uri *v3; // eax

  memset(vs, 0, sizeof(view_state));
  vs->current_link = -1;
  vs->old_current_link = -1;
  vs->plain = plain;
  v3 = 0;
  if ( uri )
  {
    ++uri->object.refcount;
    v3 = uri;
  }
  vs->uri = v3;
  *((_BYTE *)vs + 44) = (2 * (*((_WORD *)uri + 26) == 0)) | *((_BYTE *)vs + 44) & 0xFD;
  vs->forms.prev = &vs->forms;
  vs->forms.next = &vs->forms;
}

// nfuncs=2468 queued=1965 decompiled=1965 lumina nreq=0 worse=0 better=0
// ALL OK, 1965 function(s) have been successfully decompiled
