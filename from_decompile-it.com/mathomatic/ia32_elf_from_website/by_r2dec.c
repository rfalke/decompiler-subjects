/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80492d0 */
#include <stdint.h>
 
void entry0 (void) {
    /* [13] -r-x section size 165356 named .text */
    ebp = 0;
    ecx = esp;
    return libc_start_main (dbg.main, esi, ecx, sym.__libc_csu_init, sym.__libc_csu_fini, edx, esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048fc4 */
#include <stdint.h>
 
void libc_start_main (void) {
    libc_start_main ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80718bc */
#include <stdint.h>
 
void fini (void) {
    /* [14] -r-x section size 28 named .fini */
    void (*0x80718c8)(uint32_t) (ebx);
    ebx += 0x772c;
    _do_global_dtors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049300 */
#include <stdint.h>
 
int32_t do_global_dtors_aux (void) {
    if (*(obj.completed.7065) != 0) {
        goto label_0;
    }
    eax = dtor_idx.7067;
    ebx = obj.__DTOR_END__;
    ebx -= obj.__DTOR_LIST__;
    ebx >>= 2;
    ebx--;
    if (eax >= ebx) {
        goto label_1;
    }
    do {
        eax++;
        *(obj.dtor_idx.7067) = eax;
        uint32_t (*eax*4 + obj.__DTOR_LIST__)() ();
        eax = dtor_idx.7067;
    } while (eax < ebx);
label_1:
    *(obj.completed.7065) = 1;
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048e54 */
#include <stdint.h>
 
void init (void) {
    /* [11] -r-x section size 48 named .init */
    void (*0x8048e60)(uint32_t) (ebx);
    ebx += 0x30194;
    edx = *((ebx - 4));
    if (edx != 0) {
        gmon_start_ ();
    }
    frame_dummy ();
    _do_global_ctors_aux ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f24 */
#include <stdint.h>
 
void loc_imp_gmon_start_ (void) {
    gmon_start_ ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049360 */
#include <stdint.h>
 
int32_t frame_dummy (void) {
    eax = *(obj.__JCR_LIST__);
    if (eax != 0) {
        eax = 0;
        if (eax == 0) {
            goto label_0;
        }
        void (*eax)(uint32_t) (obj.__JCR_LIST__);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8071890 */
#include <stdint.h>
 
int32_t do_global_ctors_aux (void) {
    eax = .ctors;
    if (eax == -1) {
        goto label_0;
    }
    ebx = .ctors;
    do {
        ebx -= 4;
        void (*eax)() ();
        eax = *(ebx);
    } while (eax != -1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ad7a */
#include <stdint.h>
 
void dbg_error (void) {
    char const * str;
    int32_t var_4h;
    int32_t var_8h;
    /* void error(char const * str); */
    ebx = *((ebp + 8));
    *(obj.error_str) = ebx;
    set_color (2);
    *((esp + 8)) = ebx;
    *((esp + 4)) = 0x807277d;
    *(esp) = 1;
    printf_chk ();
    default_color ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806e52f */
#include <stdint.h>
 
int32_t dbg_set_color (uint32_t arg_8h, int32_t color) {
    char * var_4h;
    int32_t var_8h;
    int32_t var_ch;
    ebx = color;
    /* void set_color(int color); */
    ebx = *((ebp + 8));
    eax = gfp;
    if (eax == *(obj.stdout)) {
        eax = cur_color;
        if (eax == ebx) {
            goto label_0;
        }
        if (*(obj.color_flag) == 0) {
            goto label_0;
        }
        if (*(obj.html_flag) != 0) {
            if (eax >= 0) {
                *((esp + 4)) = "</font>";
                *(esp) = 1;
                printf_chk ();
            }
            if (*(obj.bold_colors) != 0) {
                edx = 0x92492493;
                eax = ebx;
                edx:eax = eax * edx;
                edx += ebx;
                edx >>= 2;
                eax = ebx;
                eax >>= 0x1f;
                edx -= eax;
                eax = edx*8;
                eax -= edx;
                edx = eax;
                eax = ebx;
                eax -= edx;
                eax = *((eax*4 + obj.bright_html_carray));
                *((esp + 8)) = eax;
                *((esp + 4)) = "<font color=\"%s\">";
                *(esp) = 1;
                printf_chk ();
            } else {
                edx = 0x92492493;
            }
            eax = ebx;
            edx:eax = eax * edx;
            edx += ebx;
            edx >>= 2;
            eax = ebx;
            eax >>= 0x1f;
            edx -= eax;
            eax = edx*8;
            eax -= edx;
            edx = eax;
            eax = ebx;
            eax -= edx;
            eax = *((eax*4 + obj.html_carray));
            *((esp + 8)) = eax;
            *((esp + 4)) = "<font color=\"%s\">";
            *(esp) = 1;
            printf_chk ();
        } else {
            edx = 0x2aaaaaab;
            eax = ebx;
            edx:eax = eax * edx;
            eax = ebx;
            eax >>= 0x1f;
            edx -= eax;
            eax = edx * 3;
            eax += eax;
            edx = ebx;
            edx -= eax;
            eax = *((edx*4 + obj.carray));
            *((esp + 0xc)) = eax;
            eax = bold_colors;
            *((esp + 8)) = eax;
            *((esp + 4)) = "\e[%d;%dm";
            *(esp) = 1;
            printf_chk ();
        }
        *(obj.cur_color) = ebx;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f34 */
#include <stdint.h>
 
void printf_chk (void) {
    printf_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fd58 */
#include <stdint.h>
 
void dbg_default_color (void) {
    /* void default_color(); */
    set_color (0);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b4f0 */
#include <stdint.h>
 
int32_t dbg_flip (token_type * side1p, token_type * ep, token_type * side2p, int * side1np, token_type * p1) {
    int * side2np;
    void * s2;
    size_t n;
    char * var_ch;
    ebx = side1p;
    ecx = ep;
    esi = side2p;
    edi = side1np;
    eax = p1;
    /* int flip(token_type * side1p,int * side1np,token_type * side2p,int * side2np); */
    ebx = eax;
    edi = edx;
    esi = ecx;
    if (*(obj.debug_level) > 0) {
        *((esp + 0xc)) = "Taking the reciprocal of both sides of the equation...";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = n_tokens;
    edx = *(edi);
    edx += 2;
    if (edx <= eax) {
        ecx = *((ebp + 8));
        edx = *(ecx);
        edx += 2;
        if (eax >= edx) {
            goto label_0;
        }
    }
    error_huge ();
label_0:
    edx = *(edi);
    edx <<= 4;
    edx = ebx + edx;
    if (ebx >= edx) {
        goto label_1;
    }
    eax = ebx;
    do {
        *((eax + 4))++;
        eax += 0x10;
    } while (edx > eax);
label_1:
    eax = *((ebp + 8));
    edx = *(eax);
    edx <<= 4;
    edx = esi + edx;
    if (esi >= edx) {
        goto label_2;
    }
    eax = esi;
    do {
        *((eax + 4))++;
        eax += 0x10;
    } while (edx > eax);
label_2:
    eax = *(edi);
    eax <<= 4;
    eax = ebx + 0x20;
    memmove (eax, ebx, eax);
    *(edi) += 2;
    edx = *((ebp + 8));
    eax = *(edx);
    eax <<= 4;
    eax = esi + 0x20;
    memmove (eax, esi, eax);
    ecx = *((ebp + 8));
    *(ecx) += 2;
    edi = one_token;
    eax = *(edi);
    *(ebx) = eax;
    ecx = 0x80796a8;
    eax = *(ecx);
    *((ebx + 4)) = eax;
    edx = 0x80796ac;
    eax = *(edx);
    *((ebx + 8)) = eax;
    eax = 0x80796b0;
    eax = *(eax);
    *((ebx + 0xc)) = eax;
    ebx += 0x10;
    *((ebx + 4)) = 1;
    *(ebx) = 2;
    *((ebx + 8)) = 4;
    ebx = *(edi);
    *(esi) = ebx;
    ecx = *(ecx);
    *((esi + 4)) = ecx;
    edx = *(edx);
    *((esi + 8)) = edx;
    edx = 0x80796b0;
    eax = *(edx);
    *((esi + 0xc)) = eax;
    esi += 0x10;
    *((esi + 4)) = 1;
    *(esi) = 2;
    *((esi + 8)) = 4;
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b637 */
#include <stdint.h>
 
int32_t dbg_g_of_f (size_t * arg_10h, token_type * p2, token_type * operandp, token_type * side1p, int * side2np, token_type * ep) {
    int32_t var_11ch;
    uint32_t var_115h;
    int32_t operandn;
    void * s1;
    size_t * var_10ch;
    uint32_t var_108h;
    int32_t var_104h;
    int32_t oldn;
    int32_t var_fch;
    int32_t var_f8h;
    int32_t var_f4h;
    int32_t var_f0h;
    int32_t var_ech;
    int32_t var_e0h;
    int32_t var_dch;
    int32_t var_d8h;
    int32_t var_d4h;
    int32_t var_d0h;
    int32_t var_cch;
    int32_t var_c8h;
    int32_t var_c4h;
    complexs c2;
    int32_t var_bch;
    int32_t var_b8h;
    int32_t var_b4h;
    complexs c1;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    double d2;
    double d1;
    double denominator;
    double numerator;
    char[100] var_name_buf;
    int32_t canary;
    int32_t var_ch;
    int * side1np;
    token_type * side2p;
    void * s2;
    size_t n;
    int32_t var_4h_2;
    void ** var_4h;
    char * var_8h;
    char * var_sp_ch;
    char * var_10h;
    char * var_14h;
    int32_t var_18h;
    ebx = p2;
    ecx = operandp;
    edx = side1p;
    esi = side2np;
    edi = ep;
    /* int g_of_f(int op,token_type * operandp,token_type * side1p,int * side1np,token_type * side2p,int * side2np); */
    *((ebp - 0xfc)) = eax;
    *((ebp - 0x108)) = edx;
    *((ebp - 0x110)) = ecx;
    eax = *((ebp + 8));
    *((ebp - 0x104)) = eax;
    edx = *((ebp + 0xc));
    *((ebp - 0x10c)) = edx;
    esi = *((ebp + 0x10));
    ecx = *(gs:0x14);
    *((ebp - 0x1c)) = ecx;
    ecx = 0;
    eax = *(eax);
    *((ebp - 0x100)) = eax;
    if (eax == *(0x80793b8)) {
        eax = *(esi);
        if (eax != *(0x80793b4)) {
            goto label_0;
        }
        eax = repeat_count;
        eax++;
        *(obj.repeat_count) = eax;
        if (eax <= 2) {
            goto label_1;
        }
        if (*(obj.debug_level) <= 0) {
            goto label_2;
        }
        *((esp + 0xc)) = "Infinite loop aborted in solve routine.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 0;
        goto label_3;
    }
label_0:
    edx = *((ebp - 0x100));
    *(0x80793b8) = edx;
    eax = *(esi);
    *(0x80793b4) = eax;
    *(obj.repeat_count) = 0;
label_1:
    eax = *((ebp - 0xfc));
    eax--;
    if (eax > 5) {
        goto label_2;
    }
    edi = *((ebp - 0x100));
    edi <<= 4;
    edi += *((ebp - 0x110));
    ebx = *((ebp - 0x108));
    ebx += 0x10;
    if (edi <= ebx) {
        goto label_4;
    }
    edx = 1;
    do {
        if (*((ebx + 4)) == 1) {
            eax = *((ebx + 8));
            if (eax != 5) {
                if (eax != 7) {
                    goto label_4;
                }
                *((ebp - 0xfc)) = edx;
            } else {
                ecx = ebx + 0x10;
                *((ebp - 0x108)) = ecx;
            }
        }
        ebx += 0x20;
    } while (edi > ebx);
label_4:
    eax = ebx;
    eax -= *((ebp - 0x108));
    *((ebp - 0x11c)) = eax;
    eax >>= 4;
    *((ebp - 0x114)) = eax;
    ebp - 0x115 = (*((ebp - 0xfc)) == 6) ? 1 : 0;
    if (*((ebp - 0xfc)) == 6) {
        edx = *((ebp - 0x110));
        if (*((ebp - 0x108)) != edx) {
            goto label_5;
        }
        eax = ebp - 0xb0;
        *((esp + 8)) = eax;
        eax = *(esi);
        ecx = *((ebp - 0x10c));
        eax = parse_complex (ecx, eax);
        if (eax == 0) {
            goto label_2;
        }
        eax = ebp - 0xc0;
        *((esp + 8)) = eax;
        eax = *((ebp - 0x114));
        edx = *((ebp - 0x108));
        eax = parse_complex (edx, eax);
        if (eax == 0) {
            goto label_2;
        }
        if (*(obj.debug_level) > 0) {
            *((esp + 0xc)) = "Taking logarithm of both equation sides:";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        errno_location ();
        *(eax) = 0;
        eax = ebp - 0xd0;
        edx = *((ebp - 0xc0));
        *((esp + 4)) = edx;
        edx = *((ebp - 0xbc));
        *((esp + 8)) = edx;
        edx = *((ebp - 0xb8));
        *((esp + 0xc)) = edx;
        edx = *((ebp - 0xb4));
        *((esp + 0x10)) = edx;
        complex_log (eax);
        eax = ebp - 0xe0;
        edx = *((ebp - 0xb0));
        *((esp + 4)) = edx;
        edx = *((ebp - 0xac));
        *((esp + 8)) = edx;
        edx = *((ebp - 0xa8));
        *((esp + 0xc)) = edx;
        edx = *((ebp - 0xa4));
        *((esp + 0x10)) = edx;
        complex_log (eax);
        eax = ebp - 0xf8;
        edx = *((ebp - 0xd0));
        *((esp + 0x14)) = edx;
        edx = *((ebp - 0xcc));
        *((esp + 0x18)) = edx;
        edx = *((ebp - 0xc8));
        edx = *((ebp - 0xc4));
        edx = *((ebp - 0xe0));
        edx = *((ebp - 0xdc));
        edx = *((ebp - 0xd8));
        edx = *((ebp - 0xd4));
        complex_div (edx, edx, edx);
        eax = *((ebp - 0xf8));
        *((ebp - 0xb0)) = eax;
        eax = *((ebp - 0xf4));
        *((ebp - 0xac)) = eax;
        eax = *((ebp - 0xf0));
        *((ebp - 0xa8)) = eax;
        eax = *((ebp - 0xec));
        *((ebp - 0xa4)) = eax;
        *(esi) = 0;
        ecx = *((ebp - 0x10c));
        *((ecx + 4)) = 1;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx)) = 0;
        eax = *(esi);
        eax <<= 4;
        *(fp_stack--) = *((ebp - 0xb0));
        *((eax + ecx + 8)) = fp_stack[0];
        fp_stack--;
        eax = *(esi);
        eax++;
        *(esi) = eax;
        eax <<= 4;
        *((eax + ecx + 4)) = 1;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx)) = 2;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx + 8)) = 1;
        eax = *(esi);
        eax++;
        *(esi) = eax;
        eax <<= 4;
        *((eax + ecx + 4)) = 2;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx)) = 0;
        eax = *(esi);
        eax <<= 4;
        *(fp_stack--) = *((ebp - 0xa8));
        *((eax + ecx + 8)) = fp_stack[0];
        fp_stack--;
        eax = *(esi);
        eax++;
        *(esi) = eax;
        eax <<= 4;
        *((eax + ecx + 4)) = 2;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx)) = 2;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx + 8)) = 3;
        eax = *(esi);
        eax++;
        *(esi) = eax;
        eax <<= 4;
        *((eax + ecx + 4)) = 2;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx)) = 1;
        eax = *(esi);
        eax <<= 4;
        *((eax + ecx + 8)) = 3;
        *(esi)++;
        esi = *((ebp - 0x114));
        esi = ~esi;
        eax = esi;
        edx = *((ebp - 0x104));
        eax += *(edx);
        eax <<= 4;
        ebx += 0x10;
        ecx = *((ebp - 0x110));
        memmove (ecx, ebx, eax);
        eax = *((ebp - 0x104));
        *(eax) += esi;
        check_err ();
        eax = 1;
        goto label_3;
    }
label_5:
    if (*((ebp - 0xfc)) == 5) {
        eax = ebp - 0x98;
        *((esp + 8)) = eax;
        eax = *(esi);
        *((esp + 4)) = eax;
        edx = *((ebp - 0x10c));
        eax = get_constant (edx);
        if (eax == 0) {
            goto label_6;
        }
        eax = ebp - 0xa0;
        *((esp + 8)) = eax;
        ecx = *((ebp - 0x114));
        *((esp + 4)) = ecx;
        eax = *((ebp - 0x108));
        eax = get_constant (eax);
        if (eax == 0) {
            goto label_6;
        }
        *(fp_stack--) = *((ebp - 0x98));
        fp_stack[0] = abs(fp_stack[0]);
        *(fp_stack--) = *((ebp - 0xa0));
        fp_stack[0] = abs(fp_stack[0]);
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] < fp_stack[1]) {
            goto label_6;
        }
        *(esp) = "There are no possible solutions.";
        error ();
        eax = 0;
        goto label_3;
    }
label_6:
    if (*(obj.debug_level) > 0) {
        if (*((ebp - 0xfc)) <= 6) {
            edx = *((ebp - 0xfc));
            /* switch table (7 cases) at 0x807273c */
            *((esp + 8)) = "Subtracting";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            goto label_7;
            *((esp + 8)) = "Adding";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            goto label_7;
            *((esp + 8)) = "Dividing both sides of the equation by";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            goto label_7;
            *((esp + 8)) = "Multiplying both sides of the equation by";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            goto label_7;
            *((esp + 8)) = "Raising both sides of the equation to the power of";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            goto label_7;
            *((esp + 8)) = "Applying inverse modulus of";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
label_7:
        if (*((ebp - 0x115)) != 0) {
            if (*((ebp - 0x114)) == 1) {
                ecx = *((ebp - 0x108));
                if (*(ecx) != 0) {
                    goto label_8;
                }
                *(fp_stack--) = 1.0;
                fp_stack[0] /= *((ecx + 8));
                *((esp + 0x10)) = fp_stack[0];
                fp_stack--;
                eax = precision;
                *((esp + 0xc)) = eax;
                *((esp + 8)) = " %.*g:\n";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
        } else {
label_8:
            *((esp + 8)) = 0x8072702;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            if (*((ebp - 0x115)) != 0) {
                *((esp + 8)) = 0x8072664;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            *((esp + 8)) = 0;
            eax = *((ebp - 0x114));
            *((esp + 4)) = eax;
            edx = *((ebp - 0x108));
            *(esp) = edx;
            list_proc ();
            if (*((ebp - 0xfc)) != 2) {
                if (*((ebp - 0xfc)) <= 2) {
                    if (*((ebp - 0xfc)) != 1) {
                        goto label_9;
                    }
                } else {
                    if (*((ebp - 0xfc)) == 5) {
                        goto label_10;
                    }
                    if (*((ebp - 0xfc)) != 6) {
                        goto label_9;
                    }
                    goto label_11;
                }
                *((esp + 8)) = "\" from both sides of the equation:\n";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            } else {
label_10:
                *((esp + 8)) = "\" to both sides of the equation:\n";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                goto label_12;
label_11:
                *((esp + 8)) = 0x80779a8;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
label_9:
                *((esp + 8)) = 0x8072668;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
        }
    }
label_12:
    edx = n_tokens;
    ecx = *((ebp - 0x104));
    eax = *(ecx);
    ecx = *((ebp - 0x114));
    eax = ecx + eax + 3;
    if (eax <= edx) {
        eax = *(esi);
        eax = ecx + eax + 5;
        if (edx >= eax) {
            goto label_13;
        }
    }
    error_huge ();
label_13:
    eax = *((ebp - 0x100));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x110));
    eax = min_level (edx);
    if (eax > 1) {
        goto label_14;
    }
    if (*((ebp - 0x110)) >= edi) {
        goto label_14;
    }
    eax = *((ebp - 0x110));
    do {
        *((eax + 4))++;
        eax += 0x10;
    } while (edi > eax);
label_14:
    ebx = *(esi);
    *((esp + 4)) = ebx;
    ecx = *((ebp - 0x10c));
    eax = min_level (ecx);
    if (eax > 1) {
        goto label_15;
    }
    edx = ebx;
    edx <<= 4;
    edx += *((ebp - 0x10c));
    if (*((ebp - 0x10c)) >= edx) {
        goto label_15;
    }
    eax = *((ebp - 0x10c));
    do {
        *((eax + 4))++;
        eax += 0x10;
    } while (edx > eax);
label_15:
    if (*((ebp - 0xfc)) <= 6) {
        eax = *((ebp - 0xfc));
        /* switch table (7 cases) at 0x8072758 */
        *((edi + 4)) = 1;
        *(edi) = 2;
        *((edi + 8)) = 1;
        ebx = edi + 0x10;
        *((ebx + 4)) = 2;
        *(ebx) = 1;
        eax = last_int_var;
        *((esp + 0x18)) = eax;
        *((esp + 0x14)) = "integer";
        *((esp + 0x10)) = "%s%.0d";
        *((esp + 0xc)) = 0x64;
        *((esp + 8)) = 1;
        *((esp + 4)) = 0x64;
        edx = ebp - 0x80;
        *(esp) = edx;
        snprintf_chk ();
        ecx = ebp - 0x80;
        *((esp + 4)) = ecx;
        eax = edi + 0x18;
        eax = parse_var (eax);
        if (eax == 0) {
            goto label_2;
        }
        edx = last_int_var;
        edx++;
        eax = 0;
        __asm ("cmovns eax, edx");
        *(obj.last_int_var) = eax;
        eax = ebx + 0x10;
        *((eax + 4)) = 2;
        *(eax) = 2;
        *((eax + 8)) = 3;
        eax = *((ebp - 0x11c));
        edx = *((ebp - 0x108));
        ebx += 0x20;
        memmove (ebx, edx, eax);
        ecx = *((ebp - 0x104));
        eax = *(ecx);
        edx = *((ebp - 0x114));
        eax = edx + eax + 3;
        *(ecx) = eax;
        goto label_16;
        *((edi + 4)) = 1;
        *(edi) = 2;
        *((edi + 8)) = 6;
        eax = edi + 0x10;
        *((eax + 4)) = 2;
        *(eax) = 0;
        *(fp_stack--) = 1.0;
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = edi + 0x20;
        *((eax + 4)) = 2;
        *(eax) = 2;
        *((eax + 8)) = 4;
        eax = *((ebp - 0x11c));
        edx = *((ebp - 0x108));
        eax = edi + 0x30;
        memmove (eax, edx, eax);
        ecx = *((ebp - 0x104));
        eax = *(ecx);
        edx = *((ebp - 0x114));
        eax = edx + eax + 3;
        *(ecx) = eax;
        goto label_16;
        *((edi + 4)) = 1;
        *(edi) = 2;
        *((edi + 8)) = 4;
        ecx = *((ebp - 0x11c));
        eax = *((ebp - 0x108));
        eax = edi + 0x10;
        memmove (eax, eax, ecx);
        edx = *((ebp - 0x104));
        eax = *(edx);
        ecx = *((ebp - 0x114));
        eax = ecx + eax + 1;
        *(edx) = eax;
        goto label_16;
        *((edi + 4)) = 1;
        *(edi) = 2;
        *((edi + 8)) = 3;
        eax = *((ebp - 0x11c));
        edx = *((ebp - 0x108));
        eax = edi + 0x10;
        memmove (eax, edx, eax);
        ecx = *((ebp - 0x104));
        eax = *(ecx);
        edx = *((ebp - 0x114));
        eax = edx + eax + 1;
        *(ecx) = eax;
        goto label_16;
        *((edi + 4)) = 1;
        *(edi) = 2;
        *((edi + 8)) = 2;
        ecx = *((ebp - 0x11c));
        eax = *((ebp - 0x108));
        eax = edi + 0x10;
        memmove (eax, eax, ecx);
        edx = *((ebp - 0x104));
        eax = *(edx);
        ecx = *((ebp - 0x114));
        eax = ecx + eax + 1;
        *(edx) = eax;
        goto label_16;
        *((edi + 4)) = 1;
        *(edi) = 2;
        *((edi + 8)) = 1;
        eax = *((ebp - 0x11c));
        edx = *((ebp - 0x108));
        eax = edi + 0x10;
        memmove (eax, edx, eax);
        ecx = *((ebp - 0x104));
        eax = *(ecx);
        edx = *((ebp - 0x114));
        eax = edx + eax + 1;
        *(ecx) = eax;
    }
label_16:
    ecx = *((ebp - 0x104));
    eax = *(ecx);
    eax -= *((ebp - 0x100));
    eax <<= 4;
    eax = *(esi);
    eax <<= 4;
    eax += *((ebp - 0x10c));
    memmove (eax, edi, eax);
    edx = *((ebp - 0x104));
    eax = *(edx);
    eax -= *((ebp - 0x100));
    *(esi) += eax;
    if (*((ebp - 0x115)) == 0) {
        goto label_17;
    }
    if (*((ebp - 0x114)) != 1) {
        goto label_17;
    }
    ecx = *((ebp - 0x108));
    if (*(ecx) != 0) {
        goto label_17;
    }
    eax = ebp - 0x90;
    eax = ebp - 0x88;
    *(fp_stack--) = *((ecx + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = f_to_fraction (eax, eax);
    *(fp_stack--) = *((ebp - 0x88));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(ecx) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_18;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_19;
label_18:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_19:
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_17;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_17;
    }
    edx = *(esi);
    edx <<= 4;
    edx += *((ebp - 0x10c));
    eax = *((ebp - 0x10c));
    ecx = *((ebp - 0x10c));
    if (eax >= edx) {
        goto label_20;
    }
    do {
        *((eax + 4))++;
        eax += 0x10;
    } while (edx > eax);
    eax = *((ebp - 0x10c));
    eax = ~eax;
    eax += edx;
    eax &= 0xfffffff0;
    edx = *((ebp - 0x10c));
    ecx = edx + eax + 0x10;
label_20:
    *((ecx + 4)) = 1;
    *(ecx) = 2;
    *((ecx + 8)) = 3;
    eax = ecx + 0x10;
    *((eax + 4)) = 1;
    *(eax) = 1;
    ecx += 0x18;
    next_sign (ecx);
    *(esi) += 2;
label_17:
    edx = *((ebp - 0xfc));
    edx -= 5;
    eax = 1;
    if (edx <= 1) {
        eax = *((ebp - 0x108));
        eax -= 0x10;
        eax -= *((ebp - 0x110));
        eax >>= 4;
        ecx = *((ebp - 0x104));
        *(ecx) = eax;
        eax = 1;
        goto label_3;
label_2:
        eax = 0;
    }
label_3:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804c1c3 */
#include <stdint.h>
 
int32_t dbg_quad_solve (int32_t len, token_type * ep, int32_t op2, token_type * x2p) {
    int32_t opx1;
    int32_t opx2;
    token_type * a2ep;
    token_type * a2p;
    token_type * a1p;
    token_type * x1p;
    int32_t alen;
    int32_t var_688h;
    int32_t var_684h;
    int32_t var_680h;
    int32_t nx1;
    uint32_t var_678h;
    int32_t op;
    double high_power;
    int32_t var_66ch;
    token_type[100] x1_storage;
    int32_t diff_sign;
    void ** s2;
    char * n;
    char * var_ch;
    int32_t var_10h;
    int32_t var_18h;
    ebx = len;
    esi = ep;
    edi = op2;
    eax = x2p;
    /* int quad_solve(long int v); */
    *((ebp - 0x680)) = eax;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    uf_simp ();
    ebx = *((ebp - 0x680));
    while (eax != 0) {
        eax = trhs;
        simp_loop (eax, obj.n_trhs);
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = ebx;
        *((esp + 4)) = 0x80798b4;
        eax = trhs;
        *(esp) = eax;
        eax = factor_plus ();
    }
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    eax = trhs;
    edx = n_trhs;
    edx <<= 4;
    edx = eax + edx;
    *((ebp - 0x678)) = edx;
    esi = eax;
    *(fp_stack--) = 0.0;
    *((ebp - 0x67c)) = 0;
    *((ebp - 0x674)) = 0;
    *((ebp - 0x69c)) = 0;
    *((ebp - 0x698)) = 0;
    *((ebp - 0x694)) = 0;
    *((ebp - 0x690)) = 0;
    *((ebp - 0x68c)) = 1;
label_0:
    if (eax < *((ebp - 0x678))) {
        edx = *((eax + 4));
        *((ebp - 0x670)) = fp_stack[0];
        edi = esi;
        if (edx != 1) {
            goto label_2;
        }
        if (*(eax) != 2) {
            goto label_3;
        }
        edx = *((eax + 8));
        edx--;
        if (edx > 1) {
            goto label_4;
        }
    }
    edx = *((ebp - 0x674));
    edx -= 3;
    if (edx > 1) {
        goto label_5;
    }
    if (eax <= esi) {
        *((ebp - 0x670)) = fp_stack[0];
        fp_stack--;
        edi = esi;
        *((ebp - 0x67c)) = 0;
        goto label_6;
    }
    edi = esi;
    edx = esi;
    *((ebp - 0x67c)) = 0;
    *((ebp - 0x684)) = 0;
    *((ebp - 0x688)) = eax;
    do {
        ecx = *((edx + 4));
        if (ecx == 2) {
            if (*(edx) == 2) {
                edi = edx + 0x10;
                ecx = *((edx + 8));
                *((ebp - 0x684)) = ecx;
                *((ebp - 0x670)) = fp_stack[0];
                fp_stack--;
                *((ebp - 0x67c)) = 0;
            } else {
                ebx = *(edx);
                if (ebx == 2) {
                    if (ecx == 3) {
                        if (*((edx + 8)) != 6) {
                            goto label_7;
                        }
                        if (*((ebp - 0x67c)) == 0) {
                            goto label_7;
                        }
                        if (*((ebp - 0x684)) != 3) {
                            if (*((ebp - 0x684)) != 0) {
                                goto label_7;
                            }
                        }
                        if (*((edx + 0x14)) != 3) {
                            goto label_7;
                        }
                        if (*((edx + 0x10)) != 0) {
                            goto label_7;
                        }
                        *(fp_stack--) = *((edx + 0x18));
                        *((ebp - 0x670)) = fp_stack[0];
                        fp_stack--;
                        if (fp_stack[0] <= fp_stack[1]) {
                            goto label_7;
                        }
                        fp_stack++;
                        ecx = edx + 0x20;
                        *((ebp - 0x698)) = ecx;
                        ecx = *((ebp - 0x688));
                        *((ebp - 0x69c)) = ecx;
                        *((ebp - 0x694)) = esi;
                        *((ebp - 0x690)) = edi;
                    } else {
                    }
                }
                if (ebx != 1) {
                    goto label_7;
                }
                ecx = *((ebp - 0x680));
                if (*((edx + 8)) != ecx) {
                    goto label_7;
                }
                *((ebp - 0x670)) = fp_stack[0];
                fp_stack--;
                ecx = *((ebp - 0x68c));
                *((ebp - 0x67c)) = ecx;
            } else {
label_7:
                *((ebp - 0x670)) = fp_stack[0];
                fp_stack--;
            }
        }
        edx += 0x10;
        if (eax <= edx) {
            goto label_6;
        }
        *(fp_stack--) = *((ebp - 0x670));
    } while (1);
label_5:
    if (*((ebp - 0x674)) == 6) {
        if (*((ebp - 0x67c)) != 0) {
            if (*((eax - 0xc)) != 2) {
                goto label_8;
            }
            if (*((eax - 0x10)) != 0) {
                goto label_8;
            }
            *(fp_stack--) = *((eax - 8));
            *((ebp - 0x670)) = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] <= fp_stack[1]) {
                goto label_8;
            }
            fp_stack++;
            edi = esi;
            *((ebp - 0x69c)) = eax;
            *((ebp - 0x698)) = eax;
            *((ebp - 0x694)) = esi;
            *((ebp - 0x690)) = esi;
        }
    } else {
label_8:
        *((ebp - 0x670)) = fp_stack[0];
        fp_stack--;
        edi = esi;
    }
label_6:
    if (eax < *((ebp - 0x678))) {
        edx = *((eax + 4));
        if (edx == 1) {
            *(fp_stack--) = *((ebp - 0x670));
            esi = edi;
label_3:
            if (*(eax) != 2) {
                goto label_9;
            }
            esi = eax + 0x10;
            *((ebp - 0x67c)) = 0;
            *((ebp - 0x674)) = 0;
            goto label_9;
label_2:
            fp_stack++;
        }
        ecx = *(eax);
        if (ecx == 2) {
            if (edx == 2) {
                edx = *((eax + 8));
                *((ebp - 0x674)) = edx;
                *(fp_stack--) = *((ebp - 0x670));
                esi = edi;
            } else {
                if (*((ebp - 0x674)) == 0) {
                    if (ecx != 1) {
                        goto label_10;
                    }
                    ecx = *((ebp - 0x680));
                    if (*((eax + 8)) != ecx) {
                        goto label_10;
                    }
                    *(fp_stack--) = *((ebp - 0x670));
                    esi = edi;
                    *((ebp - 0x67c)) = 1;
                }
            } else {
label_10:
                *(fp_stack--) = *((ebp - 0x670));
                esi = edi;
            }
        }
label_9:
        eax += 0x10;
        goto label_0;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x670));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    eax = *((ebp - 0x680));
    list_var (eax, 0);
    *((esp + 0x18)) = 0x8079800;
    *(fp_stack--) = *((ebp - 0x670));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    eax = precision;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "Equation is a degree %.*g polynomial in (%s).\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = *((ebp - 0x694));
    if (*(obj.trhs) < eax) {
        *((ebp - 0x6a4)) = 2;
        if (*((eax - 8)) == 2) {
            goto label_12;
        }
    }
    *((ebp - 0x6a4)) = 1;
label_12:
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = *((ebp - 0x670));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            eax = *((ebp - 0x698));
            eax -= *((ebp - 0x690));
            eax >>= 4;
            eax -= 2;
            *((ebp - 0x67c)) = eax;
            if (eax > 0x64) {
                goto label_11;
            }
            *((esp + 0xc)) = 0x640;
            eax <<= 4;
            *((esp + 8)) = eax;
            eax = *((ebp - 0x690));
            *((esp + 4)) = eax;
            eax = ebp - 0x65c;
            *(esp) = eax;
            memmove_chk ();
        }
    } else {
        eax = *((ebp - 0x698));
        eax -= *((ebp - 0x690));
        eax >>= 4;
        *((ebp - 0x67c)) = eax;
        if (eax > 0x64) {
            goto label_11;
        }
        *((esp + 0xc)) = 0x640;
        eax <<= 4;
        *((esp + 8)) = eax;
        edx = *((ebp - 0x690));
        *((esp + 4)) = edx;
        eax = ebp - 0x65c;
        *(esp) = eax;
        memmove_chk ();
        eax = *((ebp - 0x67c));
        eax <<= 4;
        eax = ebp + eax - 0x66c;
        *(fp_stack--) = *((eax + 8));
        fp_stack[0] *= *(0x8072054);
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    esi = trhs;
    *((ebp - 0x670)) = esi;
    *((ebp - 0x6a0)) = 0;
    *((ebp - 0x684)) = 0;
label_1:
    if (esi < *((ebp - 0x678))) {
        eax = *((esi + 4));
        ecx = *((ebp - 0x670));
        *((ebp - 0x674)) = ecx;
        if (eax != 1) {
            goto label_13;
        }
        if (*(esi) != 2) {
            goto label_14;
        }
    }
    *((ebp - 0x688)) = esi;
    eax = *((ebp - 0x670));
    *((ebp - 0x68c)) = eax;
    edx = ebp - 0x1c;
    *((esp + 0x10)) = edx;
    eax = esi;
    eax -= *((ebp - 0x670));
    eax >>= 4;
    *((esp + 0xc)) = eax;
    ecx = *((ebp - 0x670));
    *((esp + 8)) = ecx;
    eax = *((ebp - 0x67c));
    *((esp + 4)) = eax;
    edx = ebp - 0x65c;
    *(esp) = edx;
    eax = se_compare ();
    if (eax != 0) {
        goto label_15;
    }
    eax = *((ebp - 0x684));
    eax -= 3;
    ecx = *((ebp - 0x670));
    *((ebp - 0x674)) = ecx;
    if (eax > 1) {
        goto label_16;
    }
    ebx = ecx;
    edi = 0;
    do {
        if (esi > ebx) {
            if (*((ebx + 4)) != 2) {
                goto label_17;
            }
            if (*(ebx) != 2) {
                goto label_18;
            }
        }
        if (edi != 0) {
            if (edi != 3) {
                goto label_19;
            }
        }
        eax = ebp - 0x1c;
        *((esp + 0x10)) = eax;
        eax = ebx;
        eax -= *((ebp - 0x674));
        eax >>= 4;
        *((esp + 0xc)) = eax;
        edx = *((ebp - 0x674));
        *((esp + 8)) = edx;
        ecx = *((ebp - 0x67c));
        *((esp + 4)) = ecx;
        eax = ebp - 0x65c;
        *(esp) = eax;
        eax = se_compare ();
        if (eax != 0) {
            eax = *((ebp - 0x670));
            edx = *((ebp - 0x674));
            *((ebp - 0x670)) = edx;
            goto label_20;
        }
label_19:
        if (esi <= ebx) {
            goto label_16;
        }
        if (*((ebx + 4)) == 2) {
label_18:
            if (*(ebx) != 2) {
                goto label_17;
            }
            ecx = ebx + 0x10;
            *((ebp - 0x674)) = ecx;
            edi = *((ebx + 8));
        }
label_17:
        ebx += 0x10;
    } while (1);
label_16:
    if (esi >= *((ebp - 0x678))) {
        goto label_11;
    }
    eax = *((esi + 4));
    if (eax == 1) {
        eax = *((ebp - 0x674));
        *((ebp - 0x670)) = eax;
label_14:
        if (*(esi) != 2) {
            goto label_21;
        }
        edx = *((esi + 8));
        *((ebp - 0x6a0)) = edx;
        ecx = esi + 0x10;
        *((ebp - 0x670)) = ecx;
        *((ebp - 0x684)) = 0;
    } else {
label_13:
        if (*(esi) == 2) {
            if (eax == 2) {
                eax = *((esi + 8));
                *((ebp - 0x684)) = eax;
                edx = *((ebp - 0x674));
                *((ebp - 0x670)) = edx;
            }
        } else {
            ecx = *((ebp - 0x674));
            *((ebp - 0x670)) = ecx;
        }
    }
label_21:
    esi += 0x10;
    goto label_1;
label_15:
    eax = *((ebp - 0x670));
    ebx = esi;
label_20:
    if (*((ebp - 0x6a0)) < 0) {
        goto label_11;
    }
    if (*((ebp - 0x6a0)) > 1) {
        if (*((ebp - 0x6a0)) != 2) {
            goto label_11;
        }
    } else {
        *((ebp - 0x6a0)) = 2;
        if (*((ebp - 0x1c)) != 0) {
            goto label_22;
        }
        goto label_23;
    }
    if (*((ebp - 0x1c)) != 0) {
label_23:
        *((ebp - 0x6a0)) = 1;
    }
label_22:
    esi = *((ebp - 0x670));
    esi -= *((ebp - 0x68c));
    eax = scratch;
    memmove (eax, eax, esi);
    esi >>= 4;
    edx = esi;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 7;
    eax = scratch;
    *((eax + edx)) = 0;
    if (*((ebp - 0x6a0)) == 2) {
        eax = scratch;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    } else {
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    edi = esi + 1;
    esi = *((ebp - 0x688));
    esi -= ebx;
    eax = edi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, ebx, esi);
    esi >>= 4;
    esi = edi + esi;
    *((ebp - 0x674)) = esi;
    *((esp + 4)) = esi;
    eax = scratch;
    eax = min_level (eax);
    ecx = 7;
    ecx -= eax;
    if (*((ebp - 0x674)) <= 0) {
        goto label_24;
    }
    eax = 0;
    ebx = *((ebp - 0x674));
    do {
        edx = eax;
        edx <<= 4;
        edx += *(obj.scratch);
        *((edx + 4)) += ecx;
        eax++;
    } while (eax != ebx);
label_24:
    eax = *((ebp - 0x674));
    eax <<= 4;
    *((ebp - 0x688)) = eax;
    eax = scratch;
    edx = *((ebp - 0x688));
    *((eax + edx + 4)) = 6;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 6;
    edx = *((ebp - 0x674));
    edx++;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 6;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = *(0x8072058);
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x674));
    edx += 2;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 5;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 2;
    edx = *((ebp - 0x674));
    edx += 3;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 6;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = *(0x8072774);
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x674));
    edx += 4;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 6;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    edi = *((ebp - 0x674));
    edi += 5;
    ebx = *((ebp - 0x690));
    ebx -= *((ebp - 0x694));
    eax = edi;
    eax <<= 4;
    *((ebp - 0x6a0)) = eax;
    edx = *((ebp - 0x694));
    eax += *(obj.scratch);
    memmove (eax, edx, ebx);
    ecx = ebx;
    ecx >>= 4;
    ecx = edi + ecx;
    edx = ecx;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 7;
    eax = scratch;
    *((eax + edx)) = 0;
    if (*((ebp - 0x6a4)) == 2) {
        eax = scratch;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    } else {
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    esi = ecx + 1;
    ebx = *((ebp - 0x69c));
    ebx -= *((ebp - 0x698));
    eax = *((ebp - 0x698));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, ebx);
    ebx >>= 4;
    esi += ebx;
    edx = esi;
    edx -= edi;
    *((ebp - 0x68c)) = edx;
    *((esp + 4)) = edx;
    eax = *((ebp - 0x6a0));
    eax += *(obj.scratch);
    eax = min_level (eax);
    ebx = 7;
    ebx -= eax;
    if (edi >= esi) {
        goto label_25;
    }
    edx = *((ebp - 0x674));
    edx += 5;
    edx <<= 4;
    eax = edi;
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += ebx;
        eax++;
        edx += 0x10;
    } while (esi > eax);
label_25:
    edx = esi;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = 6;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    ecx = esi + 1;
    *((ebp - 0x684)) = ecx;
    eax = scratch;
    edx = ecx;
    edx <<= 4;
    ecx = zero_token;
    *((edx + eax)) = ecx;
    ecx = .comment;
    *((edx + eax + 4)) = ecx;
    ecx = .comment;
    *((edx + eax + 8)) = ecx;
    ecx = .comment;
    *((edx + eax + 0xc)) = ecx;
    esi += 2;
    ebx = trhs;
    eax = trhs;
    edi = esi;
    esi = *((ebp - 0x678));
    do {
        if (ebx < esi) {
            if (*((ebx + 4)) != 1) {
                goto label_26;
            }
            if (*(ebx) != 2) {
                goto label_26;
            }
        }
        if (eax <= *((ebp - 0x690))) {
            if (ebx > *((ebp - 0x690))) {
                goto label_27;
            }
        }
        if (eax <= *((ebp - 0x670))) {
            if (ebx > *((ebp - 0x670))) {
                goto label_27;
            }
        }
        if (eax == *(obj.trhs)) {
            ecx = edi;
            ecx <<= 4;
            edx = scratch;
            *((edx + ecx + 4)) = 1;
            edx = scratch;
            *((edx + ecx)) = 2;
            edx = scratch;
            *((edx + ecx + 8)) = 1;
            edi++;
        }
        edx = ebx;
        edx -= eax;
        *((ebp - 0x678)) = edx;
        eax = edi;
        eax <<= 4;
        eax += *(obj.scratch);
        memmove (eax, eax, edx);
        eax = *((ebp - 0x678));
        eax >>= 4;
        edi += eax;
label_27:
        if (ebx >= esi) {
            esi = edi;
            if (*((ebp - 0x684)) < edi) {
                goto label_28;
            }
            goto label_29;
        }
        eax = ebx;
label_26:
        ebx += 0x10;
    } while (1);
label_28:
    edx = *((ebp - 0x684));
    edx <<= 4;
    eax = *((ebp - 0x684));
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += 6;
        eax++;
        edx += 0x10;
    } while (eax < esi);
label_29:
    eax = esi;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 4;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 6;
    eax = esi + 1;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 4;
    edx = scratch;
    *((edx + eax)) = 0;
    edx = scratch;
    *(fp_stack--) = *(0x8072054);
    *((eax + edx + 8)) = fp_stack[0];
    fp_stack--;
    eax = esi + 2;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 3;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 3;
    eax = esi + 3;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 3;
    edx = scratch;
    *((edx + eax)) = 1;
    eax += *(obj.scratch);
    eax += 8;
    next_sign (eax);
    eax = esi + 4;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 2;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 2;
    esi += 5;
    ebx = *((ebp - 0x674));
    ebx = esi + ebx;
    edx = *((ebp - 0x68c));
    eax = edx + ebx + 3;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = scratch;
    ecx = *((ebp - 0x688));
    esi <<= 4;
    eax += esi;
    memmove (eax, eax, ecx);
    eax = ebx;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 1;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 4;
    eax = ebx + 1;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 2;
    edx = scratch;
    *((edx + eax)) = 0;
    edx = scratch;
    *(fp_stack--) = *(0x8072058);
    *((eax + edx + 8)) = fp_stack[0];
    fp_stack--;
    eax = ebx + 2;
    eax <<= 4;
    edx = scratch;
    *((edx + eax + 4)) = 2;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 3;
    ebx += 3;
    edx = scratch;
    eax = *((ebp - 0x68c));
    eax <<= 4;
    eax = *((ebp - 0x6a0));
    eax = edx + eax;
    eax = ebx;
    eax <<= 4;
    edx += eax;
    memmove (edx, eax, eax);
    ebx += *((ebp - 0x68c));
    eax = *((ebp - 0x680));
    eax = scratch;
    eax = found_var (eax, ebx, eax);
    if (eax == 0) {
        eax = *((ebp - 0x67c));
        eax <<= 4;
        eax = ebp - 0x65c;
        eax = tlhs;
        memmove (eax, eax, eax);
        edx = *((ebp - 0x67c));
        *(obj.n_tlhs) = edx;
        eax = tlhs;
        simp_loop (eax, 0x80796b8);
        eax = ebx;
        eax <<= 4;
        eax = scratch;
        eax = trhs;
        memmove (eax, eax, eax);
        *(obj.n_trhs) = ebx;
        eax = trhs;
        simp_loop (eax, 0x80798b4);
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        eax = trhs;
        uf_tsimp (eax, 0x80798b4);
        eax = trhs;
        simps_side (eax, 0x80798b4, 0);
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        eax = 1;
        if (*(obj.debug_level) < 0) {
            goto label_30;
        }
        *((esp + 0xc)) = "Equation was solved with the quadratic formula.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 1;
        goto label_30;
label_4:
        fp_stack++;
    }
label_11:
    eax = 0;
label_30:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8051690 */
#include <stdint.h>
 
int32_t vcmp (int32_t arg_8h, int32_t arg_ch) {
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax -= *((edx + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80539aa */
#include <stdint.h>
 
int32_t dbg_elim_sub (int32_t i, long int v) {
    token_type want;
    int32_t var_24h;
    int32_t var_20h;
    char * var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = i;
    edi = v;
    /* int elim_sub(int i,long int v); */
    ebx = eax;
    edi = edx;
    if (eax == *(obj.cur_equation)) {
        *(esp) = "Error: source and destination are the same.";
        error ();
        eax = 0;
        goto label_1;
    }
    eax = solved_equation (eax);
    if (eax == 0) {
        goto label_2;
    }
    eax = *((ebx*4 + obj.lhs));
    eax = *((eax + 8));
    if (eax != edi) {
        goto label_2;
    }
    list_var (eax, 0);
    *((esp + 0xc)) = 0x8079800;
    eax = ebx + 1;
    *((esp + 8)) = eax;
    *((esp + 4)) = "Substituting the RHS of equation #%d into the current equation for variable (%s)...\n";
    *(esp) = 1;
    printf_chk ();
    goto label_3;
label_0:
    *(esp) = "Solve failed.";
    error ();
    eax = 0;
    while (eax > 0) {
label_3:
        eax = cur_equation;
        *((esp + 0x10)) = edi;
        edx = *((ebx*4 + obj.n_rhs));
        *((esp + 0xc)) = edx;
        esi = rhs;
        edx = *((esi + ebx*4));
        *((esp + 8)) = edx;
        edx = eax*4 + obj_n_rhs;
        *((esp + 4)) = edx;
        eax = *((esi + eax*4));
        subst_var_with_exp (eax);
        eax = cur_equation;
        *((esp + 0x10)) = edi;
        edx = *((ebx*4 + obj.n_rhs));
        *((esp + 0xc)) = edx;
        edx = *((esi + ebx*4));
        *((esp + 8)) = edx;
        edx = eax*4 + obj_n_lhs;
        *((esp + 4)) = edx;
        eax = *((eax*4 + obj.lhs));
        subst_var_with_exp (eax);
        eax = cur_equation;
        simp_equation (eax);
        eax = 1;
label_1:
        return eax;
label_2:
        list_var (edi, 0);
        *((esp + 0xc)) = 0x8079800;
        eax = ebx + 1;
        *((esp + 8)) = eax;
        *((esp + 4)) = "Solving equation #%d for (%s) and substituting into the current equation...\n";
        *(esp) = 1;
        printf_chk ();
        *((ebp - 0x24)) = 1;
        *((ebp - 0x28)) = 1;
        *((ebp - 0x20)) = edi;
        eax = ebx*4;
        edx = eax + obj_n_rhs;
        *((esp + 0x14)) = edx;
        edx = *((ebx*4 + obj.rhs));
        *((esp + 0x10)) = edx;
        eax += obj.n_lhs;
        *((esp + 0xc)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        eax = ebp - 0x28;
        *(esp) = eax;
        eax = solve_sub ();
    }
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80543b1 */
#include <stdint.h>
 
int32_t dbg_compare_rhs (int32_t i, int * diff_signp, int32_t j, int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    int32_t var_10h;
    ebx = i;
    esi = diff_signp;
    edi = j;
    eax = rv;
    /* int compare_rhs(int i,int j,int * diff_signp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = eax;
    edi = edx;
    esi = ecx;
    edx = *((eax*4 + obj.n_rhs));
    eax = *((eax*4 + obj.rhs));
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = eax;
    *((esp + 4)) = edx;
    *(esp) = eax;
    eax = se_compare ();
    if (eax != 0) {
        if (*(esi) == 0) {
            goto label_0;
        }
    }
    *(esp) = "Error in compare function or too many terms to compare.";
    error ();
    eax = 0;
    goto label_1;
label_0:
    *(obj.sign_cmp_flag) = 1;
    *((esp + 0x10)) = esi;
    edx = n_rhs;
    eax = *((edx + edi*4));
    *((esp + 0xc)) = eax;
    eax = rhs;
    ecx = *((eax + edi*4));
    *((esp + 8)) = ecx;
    edx = *((edx + ebx*4));
    *((esp + 4)) = edx;
    eax = *((eax + ebx*4));
    *(esp) = eax;
    se_compare ();
    *(obj.sign_cmp_flag) = 0;
label_1:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8054e04 */
#include <stdint.h>
 
uint32_t dbg_find_more (int32_t j, int * np, int32_t en, int32_t level, int32_t i, token_type * equation) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t found_se;
    void * s1;
    int32_t diff_sign;
    void * s2;
    size_t n;
    int32_t var_ch;
    int32_t var_10h;
    ebx = j;
    ecx = np;
    edx = en;
    esi = level;
    edi = i;
    eax = equation;
    /* int find_more(token_type * equation,int * np,int en); */
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x34)) = edx;
    *((ebp - 0x38)) = ecx;
    if (*(edx) <= 0) {
        goto label_3;
    }
    eax = solved_equation (ecx);
    esi = 1;
    if (eax != 0) {
        goto label_4;
    }
    goto label_3;
    do {
label_1:
        ebx += 2;
        if (ebx >= ecx) {
            goto label_0;
        }
        edx = *(eax);
        eax += 0x20;
    } while (edx >= esi);
    do {
label_0:
        if (ebx != edi) {
            eax = edi - 1;
            *((ebp - 0x30)) = eax;
            eax <<= 4;
            eax += *((ebp - 0x2c));
            *((ebp - 0x3c)) = eax;
            edx = ebp - 0x1c;
            *((esp + 0x10)) = edx;
            ecx = *((ebp - 0x38));
            edx = n_rhs;
            eax = *((edx + ecx*4));
            *((esp + 0xc)) = eax;
            eax = *((ecx*4 + obj.rhs));
            *((esp + 8)) = eax;
            eax = ebx;
            eax -= *((ebp - 0x30));
            *((esp + 4)) = eax;
            ecx = *((ebp - 0x3c));
            *(esp) = ecx;
            eax = se_compare ();
            if (eax != 0) {
                *((ebp - 0x40)) = esi;
                if (*((ebp - 0x1c)) != 0) {
                    edx = *((ebp - 0x34));
                    eax = *(edx);
                    eax -= ebx;
                    eax <<= 4;
                    eax = ebx;
                    eax <<= 4;
                    eax += *((ebp - 0x2c));
                    eax = edi;
                    eax <<= 4;
                    ecx = *((ebp - 0x2c));
                    eax = eax + ecx + 0x20;
                    memmove (eax, eax, eax);
                    edx = *((ebp - 0x34));
                    eax = *(edx);
                    eax = edi + eax + 2;
                    eax -= ebx;
                    *(edx) = eax;
                    esi = *((ebp - 0x40));
                    esi++;
                    ecx = *((ebp - 0x3c));
                    *((ecx + 4)) = esi;
                    *(ecx) = 0;
                    *(fp_stack--) = 1.0;
                    fp_stack[0] = -fp_stack[0];
                    *((ecx + 8)) = fp_stack[0];
                    fp_stack--;
                    eax = edi;
                    eax <<= 4;
                    eax += *((ebp - 0x2c));
                    *((eax + 4)) = esi;
                    *(eax) = 2;
                    *((eax + 8)) = 3;
                    edi++;
                    *((ebp - 0x30)) = edi;
                } else {
                    edx = *((ebp - 0x34));
                    eax = *(edx);
                    eax -= ebx;
                    eax <<= 4;
                    eax = ebx;
                    eax <<= 4;
                    eax += *((ebp - 0x2c));
                    eax = edi;
                    eax <<= 4;
                    eax += *((ebp - 0x2c));
                    memmove (eax, eax, eax);
                    edi -= ebx;
                    ecx = *((ebp - 0x34));
                    *(ecx) += edi;
                }
                eax = *((ebp - 0x30));
                eax <<= 4;
                eax += *((ebp - 0x2c));
                *((eax + 4)) = esi;
                *(eax) = 1;
                ecx = *((ebp - 0x38));
                edx = *((ecx*4 + obj.lhs));
                edx = *((edx + 8));
                *((eax + 8)) = edx;
                eax = 1;
                goto label_5;
            }
            *((ebp - 0x30)) = 1;
        }
        edi = ebx + 2;
        eax = *((ebp - 0x34));
        ecx = *(eax);
        if (ecx <= edi) {
            goto label_6;
        }
        ebx = edi;
label_2:
    } while (ebx >= ecx);
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x2c));
    if (esi > *((eax + edx + 4))) {
        goto label_0;
    }
    eax = ebx;
    eax <<= 4;
    eax = edx + eax + 0x24;
    goto label_1;
label_6:
    if (*((ebp - 0x30)) != 0) {
        esi++;
label_4:
        eax = *((ebp - 0x34));
        ecx = *(eax);
        if (ecx <= 1) {
            goto label_3;
        }
        *((ebp - 0x30)) = 0;
        edi = 1;
        ebx = 1;
        goto label_2;
    }
label_3:
    eax = 0;
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8055415 */
#include <stdint.h>
 
uint32_t dbg_complex_func (int32_t k, int32_t imag_flag, int32_t found_imag, token_type * dest) {
    int * np;
    int32_t j;
    int32_t i;
    int32_t has_real;
    int32_t has_imag;
    void * s1;
    uint32_t var_3ch;
    int * nps;
    token_type * source;
    int32_t beg;
    long int v;
    int32_t n1;
    void ** s2;
    size_t n;
    ebx = k;
    ecx = imag_flag;
    edx = found_imag;
    esi = dest;
    /* int complex_func(char * cp,int imag_flag); */
    ebx = eax;
    *((ebp - 0x3c)) = edx;
    *((ebp - 0x20)) = 3;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_1;
    }
    eax = cur_equation;
    *((ebp - 0x4c)) = eax;
    eax = next_espace ();
    *((ebp - 0x50)) = eax;
    edx = *((ebp - 0x4c));
    if (*((edx*4 + obj.n_rhs)) != 0) {
        eax = rhs;
        ecx = *((eax + edx*4));
        *((ebp - 0x34)) = ecx;
        esi = edx*4 + obj_n_rhs;
        *((ebp - 0x38)) = esi;
        edx = *((ebp - 0x50));
        eax = *((eax + edx*4));
        *((ebp - 0x40)) = eax;
        ecx = edx*4 + obj_n_rhs;
        *((ebp - 0x54)) = ecx;
    } else {
        eax = lhs;
        esi = *((ebp - 0x4c));
        esi = *((eax + esi*4));
        *((ebp - 0x34)) = esi;
        edx = *((ebp - 0x4c));
        edx = edx*4 + obj_n_lhs;
        *((ebp - 0x38)) = edx;
        ecx = *((ebp - 0x50));
        eax = *((eax + ecx*4));
        *((ebp - 0x40)) = eax;
        esi = ecx*4 + obj_n_lhs;
        *((ebp - 0x54)) = esi;
    }
    if (*(ebx) != 0) {
        eax = ebp - 0x20;
        eax = parse_var2 (eax, ebx);
        if (eax == 0) {
            goto label_1;
        }
        eax = extra_characters (eax);
        if (eax != 0) {
            goto label_1;
        }
    }
    eax = *((ebp - 0x38));
    edx = *((ebp - 0x34));
    simp_loop (edx, eax);
    ecx = *((ebp - 0x38));
    *((esp + 4)) = ecx;
    esi = *((ebp - 0x34));
    *(esp) = esi;
    uf_simp ();
    eax = *((ebp - 0x20));
    eax = *((ebp - 0x38));
    factorv (esi, eax, eax);
    *(obj.partial_flag) = 0;
    edx = *((ebp - 0x38));
    *((esp + 4)) = edx;
    *(esp) = esi;
    uf_simp ();
    *(obj.partial_flag) = 1;
    *((ebp - 0x1c)) = 1;
    eax = zero_token;
    ecx = *((ebp - 0x40));
    *(ecx) = eax;
    eax = .comment;
    *((ecx + 4)) = eax;
    eax = .comment;
    *((ecx + 8)) = eax;
    eax = .comment;
    *((ecx + 0xc)) = eax;
    esi = *((ebp - 0x38));
    edx = *(esi);
    if (edx <= 0) {
        goto label_2;
    }
    *((ebp - 0x48)) = 0;
    *((ebp - 0x44)) = 0;
    *((ebp - 0x30)) = 0;
    ebx = 0;
    goto label_3;
    do {
label_0:
        if (*(eax) == 1) {
            if (*((eax - 4)) == 2) {
                esi = *((eax + 4));
                esi--;
                if (esi > 1) {
                    goto label_4;
                }
            }
        } else {
            if (*((eax - 4)) == 1) {
                esi = 1;
                if (*((eax + 4)) != edi) {
                    ecx = esi;
                    goto label_4;
                }
            }
label_4:
            ebx++;
            eax += 0x10;
        } while (edx > ebx);
    }
    if (ecx == 0) {
        goto label_5;
    }
    *((ebp - 0x44)) = 1;
    while (edx <= ebx) {
label_5:
        *((ebp - 0x48)) = 1;
        if (ecx == *((ebp - 0x3c))) {
            if (*((ebp - 0x30)) == 0) {
                *((ebp - 0x1c)) = 0;
            }
            edi = ebx;
            edi -= *((ebp - 0x30));
            eax = edi;
            eax <<= 4;
            eax = *((ebp - 0x30));
            eax <<= 4;
            eax += *((ebp - 0x34));
            eax = *((ebp - 0x1c));
            eax <<= 4;
            eax += *((ebp - 0x40));
            memmove (eax, eax, eax);
            *((ebp - 0x1c)) += edi;
        }
        eax = *((ebp - 0x38));
        edx = *(eax);
        if (edx <= ebx) {
            goto label_6;
        }
        *((ebp - 0x30)) = ebx;
        ebx = ebx + 1;
label_3:
        ecx = 0;
    }
    edi = *((ebp - 0x20));
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp - 0x34));
    eax = ecx + eax + 4;
    ecx = 0;
    goto label_0;
label_6:
    if (*((ebp - 0x44)) != 0) {
        if (*((ebp - 0x48)) != 0) {
            goto label_7;
        }
    }
label_2:
    warning ("Expression was not a mix.");
label_7:
    ebx = ebp - 0x1c;
    esi = *((ebp - 0x40));
    do {
        simp_loop (esi, ebx);
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x20));
        *((esp + 8)) = eax;
        *((esp + 4)) = ebx;
        *(esp) = esi;
        eax = factor_plus ();
    } while (eax != 0);
    eax = ebp - 0x1c;
    eax = *((ebp - 0x40));
    simp_divide (eax, eax);
    edx = *((ebp - 0x4c));
    if (*((edx*4 + obj.n_rhs)) != 0) {
        ebx = n_lhs;
        eax = *((ebx + edx*4));
        eax <<= 4;
        eax = lhs;
        edx = *((eax + edx*4));
        esi = *((ebp - 0x50));
        eax = *((eax + esi*4));
        memmove (eax, edx, eax);
        edx = *((ebp - 0x4c));
        eax = *((ebx + edx*4));
        *((ebx + esi*4)) = eax;
    }
    eax = *((ebp - 0x1c));
    ecx = *((ebp - 0x54));
    *(ecx) = eax;
    esi = *((ebp - 0x50));
    *(obj.cur_equation) = esi;
    return_result (esi);
    goto label_8;
label_1:
    eax = 0;
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8056176 */
#include <stdint.h>
 
int32_t dbg_opt_es (int32_t found_se, int32_t j, int32_t level1, int32_t level, int32_t k) {
    int32_t var_b4h;
    int32_t var_b0h;
    int32_t var_ach;
    int32_t i2;
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t var_9ch;
    int32_t var_98h;
    int32_t var_94h;
    int32_t found_se1;
    void * s1;
    long int v;
    int32_t diff_sign;
    char[100] var_name_buf;
    int32_t canary;
    void * s2;
    size_t * n;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = found_se;
    ecx = j;
    esi = level1;
    edi = level;
    eax = k;
    /* int opt_es(token_type * equation,int * np); */
    *((ebp - 0x8c)) = eax;
    *((ebp - 0x94)) = edx;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    if (*(edx) <= 0) {
        goto label_6;
    }
    *((ebp - 0xb0)) = 1;
    goto label_7;
    do {
label_4:
        edx += 2;
        if (edx >= ecx) {
            goto label_8;
        }
        esi = *(eax);
        eax += 0x20;
    } while (esi > edi);
    *((ebp - 0x98)) = edx;
    goto label_3;
label_8:
    *((ebp - 0x98)) = edx;
label_3:
    edx = *((ebp - 0xac));
    if (*((ebp - 0x98)) == edx) {
        goto label_9;
    }
    eax = edx;
    eax--;
    ecx = *((ebp - 0x98));
    ecx -= eax;
    *((ebp - 0xa4)) = ecx;
    if (ecx <= 6) {
        goto label_10;
    }
    eax <<= 4;
    eax += *((ebp - 0x8c));
    *((ebp - 0xa0)) = eax;
    esi = 1;
    goto label_11;
    do {
label_1:
        ebx += 2;
        if (ebx >= ecx) {
            goto label_0;
        }
        edx = *(eax);
        eax += 0x20;
    } while (edx > esi);
label_0:
    if (ebx == edi) {
        goto label_12;
    }
    if (edi <= *((ebp - 0x98))) {
        goto label_13;
    }
    eax = edi - 1;
    *((ebp - 0x90)) = eax;
    eax = ebx;
    eax -= *((ebp - 0x90));
    if (eax <= 6) {
        goto label_13;
    }
    edx = *((ebp - 0x90));
    edx <<= 4;
    edx += *((ebp - 0x8c));
    *((ebp - 0x9c)) = edx;
    edx = ebp - 0x84;
    *((esp + 0x10)) = edx;
    *((esp + 0xc)) = eax;
    ecx = *((ebp - 0x9c));
    *((esp + 8)) = ecx;
    eax = *((ebp - 0xa4));
    *((esp + 4)) = eax;
    edx = *((ebp - 0xa0));
    *(esp) = edx;
    eax = se_compare ();
    if (eax == 0) {
        goto label_13;
    }
    *((ebp - 0xb4)) = esi;
    eax = last_temp_var;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = "temp%.0d";
    *((esp + 0xc)) = 0x64;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x64;
    ecx = ebp - 0x80;
    *(esp) = ecx;
    snprintf_chk ();
    eax = ebp - 0x80;
    *((esp + 4)) = eax;
    eax = ebp - 0x88;
    eax = parse_var (eax);
    if (eax == 0) {
        goto label_6;
    }
    edx = last_temp_var;
    edx++;
    eax = 0;
    __asm ("cmovns eax, edx");
    *(obj.last_temp_var) = eax;
    eax = next_espace ();
    *((ebp - 0xa8)) = eax;
    edx = lhs;
    ecx = eax;
    eax = *((edx + eax*4));
    *((eax + 4)) = 1;
    eax = *((edx + ecx*4));
    *(eax) = 1;
    eax = *((edx + ecx*4));
    edx = *((ebp - 0x88));
    *((eax + 8)) = edx;
    *((ecx*4 + obj.n_lhs)) = 1;
    eax = *((ebp - 0xa4));
    eax <<= 4;
    eax = *((ebp - 0xa0));
    eax = *((ecx*4 + obj.rhs));
    memmove (eax, eax, eax);
    ecx = *((ebp - 0xa4));
    edx = *((ebp - 0xa8));
    *((edx*4 + obj.n_rhs)) = ecx;
    if (*((ebp - 0x84)) != 0) {
        esi = *((ebp - 0x94));
        eax = *(esi);
        eax -= ebx;
        eax <<= 4;
        eax = ebx;
        eax <<= 4;
        eax += *((ebp - 0x8c));
        eax = edi;
        eax <<= 4;
        edx = *((ebp - 0x8c));
        eax = eax + edx + 0x20;
        memmove (eax, eax, eax);
        eax = *(esi);
        eax = edi + eax + 2;
        eax -= ebx;
        *(esi) = eax;
        esi = *((ebp - 0xb4));
        esi++;
        ecx = *((ebp - 0x9c));
        *((ecx + 4)) = esi;
        *(ecx) = 0;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((ecx + 8)) = fp_stack[0];
        fp_stack--;
        eax = edi;
        eax <<= 4;
        eax += *((ebp - 0x8c));
        *((eax + 4)) = esi;
        *(eax) = 2;
        *((eax + 8)) = 3;
        edi++;
        *((ebp - 0x90)) = edi;
    } else {
        edx = *((ebp - 0x94));
        eax = *(edx);
        eax -= ebx;
        eax <<= 4;
        eax = ebx;
        eax <<= 4;
        eax += *((ebp - 0x8c));
        eax = edi;
        eax <<= 4;
        eax += *((ebp - 0x8c));
        memmove (eax, eax, eax);
        edi -= ebx;
        ecx = *((ebp - 0x94));
        *(ecx) += edi;
    }
    eax = *((ebp - 0x90));
    eax <<= 4;
    eax += *((ebp - 0x8c));
    *((eax + 4)) = esi;
    *(eax) = 1;
    edx = *((ebp - 0x88));
    *((eax + 8)) = edx;
    esi = *((ebp - 0x94));
    eax = *(esi);
    eax -= *((ebp - 0x98));
    eax <<= 4;
    eax = *((ebp - 0x98));
    eax <<= 4;
    eax += *((ebp - 0x8c));
    eax = *((ebp - 0xac));
    eax <<= 4;
    eax += *((ebp - 0x8c));
    memmove (eax, eax, eax);
    eax = *((ebp - 0xac));
    eax -= *((ebp - 0x98));
    *(esi) += eax;
    edx = *((ebp - 0xb0));
    eax = *((ebp - 0xa0));
    *((eax + 4)) = edx;
    *(eax) = 1;
    eax = *((ebp - 0x88));
    ecx = *((ebp - 0xa0));
    *((ecx + 8)) = eax;
    do {
        ecx = *((ebp - 0xa8));
        edx = *((ebp - 0x94));
        eax = *((ebp - 0x8c));
        eax = find_more ();
    } while (eax != 0);
    esi = *((ebp - 0xa8));
    eax = esi*4 + obj_n_rhs;
    eax = *((esi*4 + obj.rhs));
    simp_loop (eax, eax);
    eax = *((ebp - 0x94));
    edx = *((ebp - 0x8c));
    simp_loop (edx, eax);
    eax = 0;
    edx = opt_en;
    if (*(obj.opt_en) < 0) {
        goto label_14;
    }
    do {
        eax++;
    } while (*((edx + eax*4)) >= 0);
label_14:
    edx = opt_en;
    ecx = *((ebp - 0xa8));
    *((edx + eax*4)) = ecx;
    *((edx + eax*4 + 4)) = 0xffffffff;
    eax = 1;
    goto label_15;
label_13:
    *((ebp - 0x90)) = 1;
label_12:
    edi = ebx + 2;
    eax = *((ebp - 0x94));
    ecx = *(eax);
    if (ecx <= edi) {
        goto label_16;
    }
    ebx = edi;
label_2:
    if (ecx <= ebx) {
        goto label_0;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x8c));
    if (esi >= *((eax + edx + 4))) {
        goto label_0;
    }
    eax = ebx;
    eax <<= 4;
    eax = edx + eax + 0x24;
    goto label_1;
label_16:
    if (*((ebp - 0x90)) != 0) {
        esi++;
label_11:
        eax = *((ebp - 0x94));
        ecx = *(eax);
        if (ecx <= 1) {
            goto label_10;
        }
        *((ebp - 0x90)) = 0;
        edi = 1;
        ebx = 1;
        goto label_2;
    }
label_10:
    ebx = 1;
label_9:
    edx = *((ebp - 0x98));
    edx += 2;
    *((ebp - 0xac)) = edx;
    esi = *((ebp - 0x94));
    ecx = *(esi);
    if (ecx <= edx) {
        goto label_17;
    }
    *((ebp - 0x98)) = edx;
label_5:
    if (ecx <= *((ebp - 0x98))) {
        goto label_3;
    }
    eax = *((ebp - 0x98));
    eax <<= 4;
    esi = *((ebp - 0xb0));
    edx = *((ebp - 0x8c));
    if (esi >= *((eax + edx + 4))) {
        goto label_3;
    }
    eax = *((ebp - 0x98));
    eax <<= 4;
    eax = edx + eax + 0x24;
    edi = esi;
    edx = *((ebp - 0x98));
    goto label_4;
label_17:
    if (ebx != 0) {
        *((ebp - 0xb0))++;
label_7:
        eax = *((ebp - 0x94));
        ecx = *(eax);
        if (ecx <= 1) {
            goto label_6;
        }
        ebx = 0;
        *((ebp - 0xac)) = 1;
        *((ebp - 0x98)) = 1;
        goto label_5;
    }
label_6:
    eax = 0;
label_15:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (ecx != 1) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805699c */
#include <stdint.h>
 
int32_t dbg_sum_product (int32_t ns, int32_t i, token_type * dest, int32_t product_flag) {
    uint32_t var_1060h;
    int32_t var_105ch;
    double step;
    double end;
    int32_t result_equation;
    double start;
    token_type * source;
    char * cp1;
    char * cp;
    int32_t var_1024h;
    long int v;
    char[4096] buf;
    int32_t var_1ch;
    char * * endptr;
    size_t * n;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = ns;
    ecx = i;
    esi = dest;
    edi = product_flag;
    /* int sum_product(char * cp,int product_flag); */
    *((ebp - 0x102c)) = eax;
    edi = edx;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    *((ebp - 0x1020)) = 0;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_1;
    }
    eax = next_espace ();
    *((ebp - 0x1044)) = eax;
    eax = cur_equation;
    ebx = *((eax*4 + obj.n_rhs));
    if (ebx != 0) {
        edx = rhs;
        eax = *((edx + eax*4));
        *((ebp - 0x1034)) = eax;
        eax = *((ebp - 0x1044));
        esi = *((edx + eax*4));
    } else {
        ebx = *((eax*4 + obj.n_lhs));
        edx = lhs;
        eax = *((edx + eax*4));
        *((ebp - 0x1034)) = eax;
        eax = *((ebp - 0x1044));
        esi = *((edx + eax*4));
    }
    eax = *((ebp - 0x102c));
    if (*(eax) != 0) {
        eax = ebp - 0x1020;
        eax = parse_var2 (eax, eax);
        *((ebp - 0x102c)) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    eax = ebp - 0x1020;
    *((esp + 8)) = eax;
    edx = *((ebp - 0x1034));
    eax = no_vars (edx, ebx);
    if (eax != 0) {
        *(esp) = "Current expression contains no variables.";
        error ();
        eax = 0;
        goto label_2;
    }
    if (*((ebp - 0x1020)) == 0) {
        eax = ebp - 0x1020;
        eax = prompt_var (eax);
        if (eax == 0) {
            goto label_1;
        }
    }
    eax = *((ebp - 0x1020));
    eax = *((ebp - 0x1034));
    eax = found_var (eax, ebx, eax);
    if (eax == 0) {
        *(esp) = "Variable not found.";
        error ();
        eax = 0;
        goto label_2;
    }
    edx = *((ebp - 0x102c));
    eax = *(edx);
    if (al != 0) {
        if (al == 0x3d) {
            edx++;
            *((ebp - 0x102c)) = edx;
        }
        edx = *((ebp - 0x102c));
        *((ebp - 0x1030)) = edx;
    } else {
        eax = *((ebp - 0x1020));
        list_var (eax, 0);
        *((esp + 0x14)) = 0x8079800;
        *((esp + 0x10)) = "%s = ";
        *((esp + 0xc)) = 0x50;
        *((esp + 8)) = 1;
        *((esp + 4)) = 0x50;
        *(esp) = obj.prompt_str;
        snprintf_chk ();
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x1030)) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    eax = ebp - 0x102c;
    eax = *((ebp - 0x1030));
    strtod (eax, eax);
    *((ebp - 0x1040)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x102c));
    if (*((ebp - 0x1030)) == eax) {
        *(esp) = "Number expected.";
        error ();
        eax = 0;
        goto label_2;
    }
    *(fp_stack--) = *((ebp - 0x1040));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *(0x8076b48);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        *(esp) = "Number too large.";
        error ();
        eax = 0;
        goto label_2;
    }
    eax = skip_space (eax);
    *((ebp - 0x102c)) = eax;
    *((esp + 4)) = 0x8075bc4;
    eax = strcmp_tospace (eax);
    if (eax == 0) {
        eax = *((ebp - 0x102c));
        eax = skip_param (eax);
        *((ebp - 0x102c)) = eax;
    }
    edx = *((ebp - 0x102c));
    *((ebp - 0x1030)) = edx;
    if (*(edx) == 0) {
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "To: ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x1030)) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    eax = ebp - 0x102c;
    eax = *((ebp - 0x1030));
    strtod (eax, eax);
    *((ebp - 0x1050)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x102c));
    if (*((ebp - 0x1030)) == eax) {
        *(esp) = "Number expected.";
        error ();
        eax = 0;
        goto label_2;
    }
    *(fp_stack--) = *((ebp - 0x1050));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *(0x8076b48);
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        *(esp) = "Number too large.";
        error ();
        eax = 0;
        goto label_2;
    }
    eax = skip_space (eax);
    *((ebp - 0x1030)) = eax;
    *((ebp - 0x102c)) = eax;
    if (*(eax) != 0) {
        eax = ebp - 0x102c;
        edx = *((ebp - 0x1030));
        strtod (edx, eax);
        eax = *((ebp - 0x1030));
        if (eax != *((ebp - 0x102c))) {
            fp_stack[0] = abs(fp_stack[0]);
            *((ebp - 0x1058)) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = 0.0;
            *(fp_stack--) = *((ebp - 0x1058));
            fp_tmp_2 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_2;
            fp_stack--;
            if (fp_stack[0] < fp_stack[1]) {
                *(fp_stack--) = *(0x8076b48);
                fp_tmp_3 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_3;
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] < fp_stack[1]) {
                    goto label_3;
                }
                fp_stack++;
            } else {
            } else {
                fp_stack++;
            }
        }
        *(esp) = "Invalid step.";
        error ();
        eax = 0;
        goto label_2;
    }
    *(fp_stack--) = 1.0;
    *((ebp - 0x1058)) = fp_stack[0];
    fp_stack--;
label_3:
    eax = *((ebp - 0x102c));
    eax = extra_characters (eax);
    if (eax != 0) {
        goto label_1;
    }
    *(fp_stack--) = *((ebp - 0x1040));
    *(fp_stack--) = *((ebp - 0x1050));
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    al = (fp_stack[0] > fp_stack[1]) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x1030)) = eax;
    fp_stack[1] -= fp_stack[0];
    fp_stack++;
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] /= *((ebp - 0x1058));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_4;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_5;
label_4:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_5:
    *(fp_stack--) = 0.0;
    fp_tmp_5 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_5;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_6;
        }
    }
    warning ("End value not reached.");
label_6:
    if (edi != 0) {
        eax = one_token;
        *(esi) = eax;
        eax = .comment;
        *((esi + 4)) = eax;
        eax = .comment;
        *((esi + 8)) = eax;
        eax = .comment;
        *((esi + 0xc)) = eax;
    } else {
        eax = zero_token;
        *(esi) = eax;
        eax = .comment;
        *((esi + 4)) = eax;
        eax = .comment;
        *((esi + 8)) = eax;
        eax = .comment;
        *((esi + 0xc)) = eax;
    }
    *((ebp - 0x1024)) = 1;
    eax = ebx;
    eax <<= 4;
    *((ebp - 0x105c)) = eax;
    *((ebp - 0x1060)) = edi;
    goto label_7;
label_0:
    eax = *((ebp - 0x1024));
    eax = ebx + eax + 1;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edx = *((ebp - 0x105c));
    eax = *((ebp - 0x1034));
    eax = tlhs;
    memmove (eax, eax, edx);
    *(obj.n_tlhs) = ebx;
    if (ebx <= 0) {
        goto label_8;
    }
    eax = 0;
    do {
        ecx = 0;
        ecx <<= 4;
        edx = ecx;
        edx += *(obj.tlhs);
        if (*(edx) == 1) {
            edi = *((edx + 8));
            if (edi != *((ebp - 0x1020))) {
                goto label_9;
            }
            *(edx) = 0;
            edx = tlhs;
            *(fp_stack--) = *((ebp - 0x1040));
            *((edx + ecx + 8)) = fp_stack[0];
            fp_stack--;
        }
label_9:
        eax += 2;
        edx = n_tlhs;
    } while (edx > eax);
    if (edx <= 0) {
        goto label_8;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
    } while (*(obj.n_tlhs) > eax);
label_8:
    ecx = *((ebp - 0x1024));
    if (ecx <= 0) {
        goto label_10;
    }
    eax = esi;
    edx = 0;
    do {
        *((eax + 4))++;
        edx++;
        ecx = *((ebp - 0x1024));
        eax += 0x10;
    } while (ecx > edx);
label_10:
    ecx <<= 4;
    *((ecx + esi)) = 2;
    eax = *((ebp - 0x1024));
    eax <<= 4;
    *((eax + esi + 4)) = 1;
    if (*((ebp - 0x1060)) != 0) {
        eax = *((ebp - 0x1024));
        eax <<= 4;
        *((eax + esi + 8)) = 3;
    } else {
        eax = *((ebp - 0x1024));
        eax <<= 4;
        *((eax + esi + 8)) = 1;
    }
    eax = *((ebp - 0x1024));
    eax++;
    *((ebp - 0x1024)) = eax;
    edx = n_tlhs;
    edx <<= 4;
    edx = tlhs;
    eax <<= 4;
    eax = esi + eax;
    memmove (eax, edx, edx);
    eax = n_tlhs;
    *((ebp - 0x1024)) += eax;
    eax = ebp - 0x1024;
    *((esp + 4)) = eax;
    *(esp) = esi;
    calc_simp ();
    if (*((ebp - 0x1030)) != 0) {
        *(fp_stack--) = *((ebp - 0x1040));
        fp_stack[0] -= *((ebp - 0x1058));
        *((ebp - 0x1040)) = fp_stack[0];
        fp_stack--;
    } else {
        *(fp_stack--) = *((ebp - 0x1040));
        fp_stack[0] += *((ebp - 0x1058));
        *((ebp - 0x1040)) = fp_stack[0];
        fp_stack--;
    }
label_7:
    if (*((ebp - 0x1030)) != 0) {
        *(fp_stack--) = *((ebp - 0x1040));
        *(fp_stack--) = *((ebp - 0x1050));
        fp_tmp_6 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_6;
        fp_stack--;
        fp_stack++;
        al = (fp_stack[0] >= fp_stack[1]) ? 1 : 0;
    } else {
        *(fp_stack--) = *((ebp - 0x1050));
        *(fp_stack--) = *((ebp - 0x1040));
        fp_tmp_7 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_7;
        fp_stack--;
        fp_stack++;
        al = (fp_stack[0] >= fp_stack[1]) ? 1 : 0;
    }
    if (al != 0) {
        goto label_0;
    }
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        eax = *((ebp - 0x1024));
        edx = *((ebp - 0x1044));
        *((edx*4 + obj.n_rhs)) = eax;
        edx = cur_equation;
        ebx = n_lhs;
        eax = *((ebx + edx*4));
        eax <<= 4;
        eax = lhs;
        edx = *((eax + edx*4));
        edx = *((ebp - 0x1044));
        eax = *((eax + edx*4));
        memmove (eax, edx, eax);
        eax = cur_equation;
        eax = *((ebx + eax*4));
        edx = *((ebp - 0x1044));
        *((ebx + edx*4)) = eax;
    } else {
        eax = *((ebp - 0x1024));
        edx = *((ebp - 0x1044));
        *((edx*4 + obj.n_lhs)) = eax;
    }
    eax = *((ebp - 0x1044));
    return_result (eax);
    goto label_2;
label_1:
    eax = 0;
label_2:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057ac7 */
#include <stdint.h>
 
int32_t dbg_edit_sub (char * cp, char * cp1) {
    char[4096] cl;
    int32_t var_ch;
    char * var_4h;
    int32_t var_8h;
    int32_t var_sp_ch;
    char * var_10h;
    int32_t var_14h;
    int32_t var_18h;
    esi = cp;
    eax = cp1;
    /* int edit_sub(char * cp); */
    esi = eax;
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    ebx = ebp - 0x100c;
    do {
        eax = getenv ("EDITOR");
        if (eax == 0) {
            *(esp) = "EDITOR environment variable not set.";
            error ();
            eax = 0;
            goto label_0;
        }
        *((esp + 0x18)) = esi;
        *((esp + 0x14)) = eax;
        *((esp + 0x10)) = "%s %s";
        *((esp + 0xc)) = 0x1000;
        *((esp + 8)) = 1;
        *((esp + 4)) = 0x1000;
        *(esp) = ebx;
        snprintf_chk ();
        eax = shell_out (ebx);
        if (eax != 0) {
            *(esp) = "Error executing editor, check EDITOR environment variable.";
            error ();
            eax = ebp - 0x100c;
            *((esp + 8)) = eax;
            *((esp + 4)) = "Command line = \"%s\".\n";
            *(esp) = 1;
            printf_chk ();
            eax = 0;
            goto label_0;
        }
        clear_all ();
        *(esp) = esi;
        eax = read_cmd ();
        if (eax != 0) {
            goto label_1;
        }
        eax = pause_cmd ("Prepare to rerun the editor");
    } while (eax != 0);
label_1:
    eax = 1;
label_0:
    edx = *((ebp - 0xc));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8059530 */
#include <stdint.h>
 
int32_t dbg_org_up_level (token_type * ep, int32_t level, token_type * bp) {
    int32_t invert;
    ecx = ep;
    edx = level;
    eax = bp;
    /* void org_up_level(token_type * bp,token_type * ep,int level,int invert); */
    if (*((ebp + 8)) == 0) {
        if (eax <= edx) {
            goto label_0;
        }
        goto label_1;
    }
    if (eax > edx) {
        goto label_1;
    }
    do {
        ebx = *((eax + 4));
        ebx--;
        *((eax + 4)) = ebx;
        if (ebx == ecx) {
            if (*(eax) != 2) {
                goto label_2;
            }
            ebx = *((eax + 8));
            if (ebx != 2) {
                if (ebx <= 2) {
                    if (ebx != 1) {
                        goto label_2;
                    }
                } else {
                    if (ebx == 3) {
                        goto label_3;
                    }
                    if (ebx != 4) {
                        goto label_2;
                    }
                    goto label_4;
                }
                *((eax + 8)) = 2;
            } else {
                *((eax + 8)) = 1;
                goto label_2;
label_3:
                *((eax + 8)) = 4;
                goto label_2;
label_4:
                *((eax + 8)) = 3;
            }
        }
label_2:
        eax += 0x10;
    } while (edx >= eax);
    goto label_1;
    do {
label_0:
        *((eax + 4))--;
        eax += 0x10;
    } while (edx >= eax);
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80595e1 */
#include <stdint.h>
 
int32_t dbg_org_recurse (int32_t arg_8h, int32_t min1, int * np, int32_t loc, token_type * ep, int32_t invert) {
    uint32_t var_4ch;
    uint32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t op;
    int32_t eloc;
    token_type * bp;
    int32_t var_2ch;
    int32_t sub_eloc;
    int * elocp;
    int32_t var_4h;
    ebx = min1;
    ecx = np;
    edx = loc;
    edi = ep;
    eax = invert;
    /* int org_recurse(token_type * equation,int * np,int loc,int level,int * elocp); */
label_0:
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x40)) = edx;
    *((ebp - 0x3c)) = ecx;
    esi = *((ebp + 8));
    edx = ecx;
    edx <<= 4;
    edx += eax;
    *((ebp - 0x30)) = edx;
    eax = *((ebp - 0x40));
    edi = *(eax);
    edi <<= 4;
    edi += *((ebp - 0x2c));
    ebx = *((edx + 4));
    ecx = edx;
    ecx += 0x10;
    eax = ecx;
    if (edi <= ecx) {
        goto label_1;
    }
    do {
        edx = *((eax + 4));
        if (edx < ebx) {
            if (edx < esi) {
                goto label_1;
            }
            ebx = edx;
        }
        eax += 0x20;
    } while (edi > eax);
label_1:
    edx = eax;
    edx -= *((ebp - 0x2c));
    edx >>= 4;
    edx--;
    *((ebp - 0x34)) = edx;
    if (*((ebp + 0xc)) != 0) {
        edi = *((ebp + 0xc));
        *(edi) = edx;
    }
    edx = *((ebp - 0x3c));
    if (*((ebp - 0x34)) == edx) {
        esi--;
        eax = 1;
        if (esi <= 0) {
            esi = eax;
        }
        edi = *((ebp - 0x30));
        *((edi + 4)) = esi;
        *((ebp - 0x38)) = 0;
        goto label_2;
    }
    if (esi >= ebx) {
        goto label_3;
    }
    if (*((ebp - 0x30)) >= eax) {
        goto label_3;
    }
    edx = *((ebp - 0x30));
    do {
        edi = esi;
        edi -= ebx;
        *((edx + 4)) += edi;
        edx += 0x10;
    } while (edx < eax);
label_3:
    if (ecx >= eax) {
        goto label_4;
    }
    if (*((ecx + 4)) != esi) {
        goto label_5;
    }
    while (ecx < eax) {
        if (*((ecx + 4)) == esi) {
            ecx = *((ecx + 8));
            *((ebp - 0x38)) = ecx;
            goto label_6;
        }
label_5:
        ecx += 0x20;
    }
label_4:
    *((ebp - 0x38)) = 0;
label_6:
    eax = *((ebp - 0x34));
    if (*((ebp - 0x3c)) > eax) {
        goto label_2;
    }
    ebx = *((ebp - 0x3c));
    edx = esi + 1;
    *((ebp - 0x44)) = edx;
    edi = *((ebp - 0x38));
    edi--;
    *((ebp - 0x48)) = edi;
    eax = *((ebp - 0x38));
    eax -= 3;
    *((ebp - 0x4c)) = eax;
    edi = esi;
    do {
        *((ebp - 0x30)) = ebx;
        esi = ebx;
        esi <<= 4;
        esi += *((ebp - 0x2c));
        if (edi < *((esi + 4))) {
            edx = ebp - 0x1c;
            *((esp + 4)) = edx;
            eax = *((ebp - 0x44));
            ecx = ebx;
            edx = *((ebp - 0x40));
            eax = *((ebp - 0x2c));
            eax = org_recurse (eax);
            goto label_0;
            if (eax >= 1) {
                if (eax > 2) {
                    if (eax > 4) {
                        goto label_7;
                    }
                } else {
                    if (*((ebp - 0x48)) > 1) {
                        goto label_7;
                    }
                    ebx--;
                    eax = 0;
                    if (*((ebp - 0x3c)) <= ebx) {
                        eax = *((ebp - 0x30));
                        eax--;
                        eax <<= 4;
                        edx = *((ebp - 0x2c));
                        al = (*((eax + edx + 8)) == 2) ? 1 : 0;
                        eax = (int32_t) al;
                    }
                    edx = *((ebp - 0x1c));
                    edx <<= 4;
                    edx += *((ebp - 0x2c));
                    *(esp) = eax;
                    ecx = edi;
                    eax = esi;
                    org_up_level ();
                    goto label_7;
                }
                if (*((ebp - 0x4c)) > 1) {
                    goto label_7;
                }
                ebx--;
                eax = 0;
                if (*((ebp - 0x3c)) <= ebx) {
                    eax = *((ebp - 0x30));
                    eax--;
                    eax <<= 4;
                    edx = *((ebp - 0x2c));
                    al = (*((eax + edx + 8)) == 4) ? 1 : 0;
                    eax = (int32_t) al;
                }
                edx = *((ebp - 0x1c));
                edx <<= 4;
                edx += *((ebp - 0x2c));
                *(esp) = eax;
                ecx = edi;
                eax = esi;
                org_up_level ();
            }
label_7:
            ebx = *((ebp - 0x1c));
        }
        ebx += 2;
    } while (*((ebp - 0x34)) >= ebx);
label_2:
    eax = *((ebp - 0x38));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80597be */
#include <stdint.h>
 
int32_t dbg_simpb_vcmp (int32_t arg_8h, int32_t arg_ch) {
    uint32_t var_14h;
    uint32_t var_dh;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    /* int simpb_vcmp(sort_type * p1,sort_type * p2); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edx = *((ebp + 8));
    eax = *((ebp + 0xc));
    esi = *(edx);
    ecx = *(edx);
    ecx &= 0x3fff;
    *((ebp - 0x14)) = ecx;
    ebx = *(eax);
    ebp - 0xd = (ecx != 4) ? 1 : 0;
    edi = ebx;
    edi &= 0x3fff;
    cl = (edi == 4) ? 1 : 0;
    if (*((ebp - 0xd)) != cl) {
        eax = *((eax + 4));
        edx = *((edx + 4));
        if (eax == edx) {
            if (esi >= ebx) {
                al = (esi != ebx) ? 1 : 0;
                eax = (int32_t) al;
            } else {
                eax -= edx;
            }
        } else {
            eax = 1;
            if (*((ebp - 0x14)) != 4) {
                goto label_0;
            }
        }
        eax = 0xffffffff;
    }
label_0:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805a554 */
#include <stdint.h>
 
uint32_t dbg_order_recurse (int32_t arg_8h, int32_t e2, int * np, int32_t loc, int32_t n2, int32_t op, token_type * equation) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_2ch;
    int32_t n1;
    int32_t modified;
    int32_t k;
    void * s1;
    void * s2;
    size_t * n;
    ebx = e2;
    ecx = np;
    edx = loc;
    esi = n2;
    edi = op;
    eax = equation;
    do {
        /* int order_recurse(token_type * equation,int * np,int loc,int level); */
        *((ebp - 0x1c)) = eax;
        *((ebp - 0x20)) = edx;
        *((ebp - 0x2c)) = ecx;
        esi = *((ebp + 8));
        if ((cl & 1) != 0) {
            goto label_3;
        }
        ebx = ecx;
        *((ebp - 0x24)) = 0;
        edi = 0;
        eax = esi + 1;
        *((ebp - 0x28)) = eax;
        goto label_4;
label_0:
        edx = ebx;
        edx <<= 4;
        edx += *((ebp - 0x1c));
        eax = *((edx + 4));
        if (eax < esi) {
            if (*(edx) != 2) {
                goto label_5;
            }
            goto label_6;
        }
        if (eax <= esi) {
            goto label_7;
        }
        edx = *((ebp - 0x28));
        ecx = ebx;
        edx = *((ebp - 0x20));
        eax = *((ebp - 0x1c));
        eax = order_recurse (edx);
    } while (1);
    *((ebp - 0x24)) |= eax;
    eax = ebx + 1;
    ecx = *((ebp - 0x20));
    ecx = *(ecx);
    *((ebp - 0x4c)) = ecx;
    if (eax >= ecx) {
        goto label_8;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x1c));
    if (esi >= *((edx + ecx + 4))) {
        goto label_8;
    }
    edx = ebx;
    edx <<= 4;
    edx = ecx + edx + 0x24;
    ecx = *((ebp - 0x4c));
    do {
        eax++;
        if (eax >= ecx) {
            goto label_8;
        }
        ebx = *(edx);
        edx += 0x10;
    } while (esi < ebx);
    goto label_8;
label_7:
    al = (*(edx) == 2) ? 1 : 0;
    ecx = ebx;
    ecx &= 1;
    if (al != cl) {
        goto label_5;
    }
    if (al != 0) {
        edx = *((edx + 8));
        if (edx == 0) {
            goto label_5;
        }
        if (edi == 0) {
            goto label_9;
        }
        if (edx < 1) {
            goto label_5;
        }
        if (edx > 2) {
            if (edx > 4) {
                goto label_5;
            }
        } else {
            eax = edi - 1;
            if (eax <= 1) {
                goto label_10;
            }
            goto label_5;
        }
        eax = edi - 3;
        if (eax > 1) {
            goto label_5;
        }
    }
label_10:
    edx = edi;
label_9:
    eax = ebx + 1;
    goto label_11;
label_8:
    edx = edi;
label_11:
    ebx = eax;
label_4:
    eax = *((ebp - 0x20));
    ecx = *(eax);
    if (ebx < ecx) {
        goto label_0;
    }
label_6:
    if ((bl & 1) == 0) {
        goto label_5;
    }
    if (edi < 1) {
        goto label_12;
    }
    if (edi > 2) {
        if (edi > 4) {
            goto label_12;
        }
        goto label_13;
    }
    eax = *((ebp - 0x2c));
    edx = *((ebp - 0x2c));
    edx <<= 4;
    edx += *((ebp - 0x1c));
    *((ebp - 0x20)) = edx;
    if (*(edx) != 0) {
        goto label_12;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_12;
    }
    if (*((edx + 4)) != esi) {
        eax <<= 4;
        edx = *((ebp - 0x1c));
        eax = eax + edx + 0x10;
        edx = esi + 1;
        if (*((eax + 4)) != edx) {
            goto label_12;
        }
        eax = *((eax + 8));
        eax -= 3;
        if (eax > 1) {
            goto label_12;
        }
    }
    edi = *((ebp - 0x2c));
    edi++;
    if (edi >= ebx) {
        goto label_12;
    }
    eax = edi;
    eax <<= 4;
    edx = *((ebp - 0x1c));
    eax = edx + eax + 4;
    *((ebp - 0x28)) = eax;
    edx = edi;
label_1:
    if (*(eax) != esi) {
        goto label_14;
    }
    if (*((eax + 4)) != 1) {
        goto label_14;
    }
    ebx = edx + 1;
    *((ebp - 0x24)) = ebx;
    eax = *((ebp - 0x28));
    do {
        if (ecx <= edi) {
            goto label_15;
        }
        ebx = *(eax);
        eax += 0x20;
        if (esi >= ebx) {
            goto label_15;
        }
        edi += 2;
    } while (1);
label_15:
    ebx = *((ebp - 0x24));
    ebx++;
    eax = edx;
    eax <<= 4;
    edx = *((ebp - 0x1c));
    eax = edx + eax + 0x24;
    do {
        if (ecx <= ebx) {
            goto label_16;
        }
        edx = *(eax);
        eax += 0x20;
        if (esi >= edx) {
            goto label_16;
        }
        ebx += 2;
    } while (1);
label_16:
    ecx = edi;
    ecx -= *((ebp - 0x2c));
    *((ebp - 0x28)) = ecx;
    esi = ebx;
    esi -= *((ebp - 0x24));
    eax = ebx;
    eax -= *((ebp - 0x2c));
    eax <<= 4;
    eax = *((ebp - 0x20));
    eax = scratch;
    memmove (eax, eax, eax);
    eax = *((ebp - 0x24));
    eax -= edi;
    eax <<= 4;
    eax = edi;
    eax <<= 4;
    eax += *((ebp - 0x1c));
    eax = *((ebp - 0x2c));
    eax = esi + eax;
    eax <<= 4;
    eax += *((ebp - 0x1c));
    memmove (eax, eax, eax);
    esi <<= 4;
    eax = *((ebp - 0x24));
    eax -= *((ebp - 0x2c));
    eax <<= 4;
    eax += *(obj.scratch);
    edx = *((ebp - 0x20));
    memmove (edx, eax, esi);
    eax = *((ebp - 0x28));
    eax <<= 4;
    eax = scratch;
    eax = ebx;
    eax -= *((ebp - 0x28));
    eax <<= 4;
    eax += *((ebp - 0x1c));
    eax = memmove (eax, eax, eax);
    *((ebp - 0x24)) = 1;
    goto label_12;
label_14:
    edx += 2;
    eax += 0x20;
    if (edx < ebx) {
        goto label_1;
    }
    goto label_12;
label_13:
    edi = *((ebp - 0x2c));
    edi++;
    if (edi >= ebx) {
        goto label_12;
    }
    eax = edi;
    eax <<= 4;
    ecx = *((ebp - 0x1c));
    eax = ecx + eax + 4;
    do {
        if (*(eax) == esi) {
            if (*((eax + 4)) == 4) {
                goto label_17;
            }
        }
        edi += 2;
        eax += 0x20;
    } while (ebx > edi);
    goto label_12;
label_17:
    eax = edi + 2;
    *((ebp - 0x20)) = eax;
    if (eax >= ebx) {
        goto label_12;
    }
    *((ebp - 0x3c)) = ebx;
label_2:
    ecx = *((ebp - 0x20));
    ecx <<= 4;
    ecx += *((ebp - 0x1c));
    if (*((ecx + 4)) != esi) {
        goto label_18;
    }
    if (*((ecx + 8)) != 3) {
        goto label_18;
    }
    eax = *((ebp - 0x20));
    eax += 2;
    if (eax >= *((ebp - 0x3c))) {
        goto label_19;
    }
    edx = eax;
    edx <<= 4;
    ebx = *((ebp - 0x1c));
    if (esi >= *((edx + ebx + 4))) {
        goto label_19;
    }
    edx = *((ebp - 0x20));
    edx <<= 4;
    ebx = ebx + edx + 0x44;
    edx = ebx;
    ebx = *((ebp - 0x3c));
    *((ebp - 0x28)) = ecx;
    do {
        eax += 2;
        if (eax >= ebx) {
            goto label_20;
        }
        ecx = *(edx);
        edx += 0x20;
    } while (esi < ecx);
    *((ebp - 0x3c)) = ebx;
    ecx = *((ebp - 0x28));
    goto label_19;
label_20:
    *((ebp - 0x3c)) = ebx;
    ecx = *((ebp - 0x28));
label_19:
    eax -= *((ebp - 0x20));
    *((ebp - 0x24)) = eax;
    eax <<= 4;
    *((ebp - 0x28)) = eax;
    eax = scratch;
    memmove (eax, ecx, eax);
    eax = *((ebp - 0x20));
    eax -= edi;
    eax <<= 4;
    edx = edi;
    edx <<= 4;
    ebx = *((ebp - 0x1c));
    ebx = edx + ebx;
    edi += *((ebp - 0x24));
    eax = edi;
    eax <<= 4;
    eax += *((ebp - 0x1c));
    memmove (eax, ebx, eax);
    eax = *((ebp - 0x28));
    eax = scratch;
    memmove (ebx, eax, eax);
    edx = *((ebp - 0x24));
    *((ebp - 0x20)) += edx;
    *((ebp - 0x24)) = 1;
    goto label_21;
label_18:
    *((ebp - 0x20)) += 2;
label_21:
    ecx = *((ebp - 0x20));
    if (*((ebp - 0x3c)) > ecx) {
        goto label_2;
    }
    goto label_12;
label_3:
    *((ebp - 0x24)) = 0;
label_5:
    error_bug ("Internal representation of expression is corrupt!");
label_12:
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805b11e */
#include <stdint.h>
 
int32_t dbg_compare_recurse (int32_t i, token_type * ep2, int32_t diff_op, int32_t len, int32_t l1, token_type * pv1) {
    int32_t op2;
    int32_t first;
    double compare_epsilon;
    int32_t var_c3a8h;
    uint32_t var_c3a4h;
    uint32_t var_c3a0h;
    uint32_t var_c39ch;
    int32_t last_op1;
    int32_t var_c394h;
    int32_t op1;
    int32_t var_c38ch;
    int32_t var_c388h;
    int32_t var_c384h;
    int32_t var_c380h;
    uint32_t canary;
    token_type *[10000] opa2;
    int32_t var_c36ch;
    int32_t j;
    char[10000] used;
    int32_t var_1ch;
    token_type * p2;
    int32_t n2;
    int32_t l2;
    int * diff_signp;
    uint32_t var_4h;
    int32_t var_8h;
    char * var_ch;
    ebx = i;
    ecx = ep2;
    edx = diff_op;
    esi = len;
    edi = l1;
    eax = pv1;
    /* int compare_recurse(token_type * p1,int n1,int l1,token_type * p2,int n2,int l2,int * diff_signp); */
label_0:
    ebx = eax;
    *((ebp - 0xc37c)) = edx;
    edi = ecx;
    esi = *((ebp + 8));
    eax = *((ebp + 0x14));
    *((ebp - 0xc3a4)) = eax;
    edx = *(gs:0x14);
    *((ebp - 0x1c)) = edx;
    edx = 0;
    *(fp_stack--) = *(obj.epsilon);
    *((ebp - 0xc3b0)) = fp_stack[0];
    fp_stack--;
    *(eax) = 0;
    if (*((ebp - 0xc37c)) == 1) {
        if (*((ebp + 0xc)) != 1) {
            goto label_5;
        }
        eax = *(ebx);
        if (eax != *(esi)) {
            goto label_6;
        }
        if (eax != 0) {
            if (eax != 1) {
                goto label_6;
            }
            if (*(obj.sign_cmp_flag) != 0) {
                eax = *((ebx + 8));
                eax &= 0x3fff;
                if (eax != 4) {
                    goto label_7;
                }
                eax = *((esi + 8));
                eax &= 0x3fff;
                al = (eax == 4) ? 1 : 0;
                eax = (int32_t) al;
                goto label_8;
            }
label_7:
            eax = *((ebx + 8));
            al = (eax == *((esi + 8))) ? 1 : 0;
            eax = (int32_t) al;
            goto label_8;
        }
        *(fp_stack--) = *((ebx + 8));
        *(fp_stack--) = *((esi + 8));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_9;
            }
        }
        *(fp_stack--) = fp_stack[1];
        fp_stack[0] = -fp_stack[0];
        fp_stack--;
        if (fp_stack[0] == fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_10;
            }
            fp_stack++;
            fp_stack++;
            eax = *((ebp - 0xc3a4));
            *(eax) = 1;
            eax = 1;
            goto label_8;
        }
label_10:
        *(fp_stack--) = fp_stack[0];
        fp_stack[0] = abs(fp_stack[0]);
        fp_stack[0] *= *((ebp - 0xc3b0));
        *(fp_stack--) = fp_stack[1];
        fp_stack[0] -= fp_stack[3];
        fp_stack[0] = abs(fp_stack[0]);
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_11;
        }
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        fp_stack[0] += fp_stack[2];
        fp_stack++;
        fp_tmp_3 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_3;
        fp_stack[0] = abs(fp_stack[0]);
        fp_tmp_4 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_4;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_6;
        }
        edx = *((ebp - 0xc3a4));
        *(edx) = 1;
        eax = 1;
        goto label_8;
    }
label_5:
    eax = *((ebp - 0xc37c));
    eax <<= 4;
    eax = ebx + eax;
    *((ebp - 0xc39c)) = eax;
    edx = *((ebp + 0xc));
    edx <<= 4;
    edx = esi + edx;
    eax = ebx + 0x10;
    if (*((ebp - 0xc39c)) <= eax) {
        goto label_12;
    }
    if (*((eax + 4)) != edi) {
        goto label_13;
    }
    while (ecx > eax) {
        if (*((eax + 4)) == edi) {
            eax = *((eax + 8));
            *((ebp - 0xc390)) = eax;
            goto label_14;
label_13:
            ecx = *((ebp - 0xc39c));
        }
        eax += 0x20;
    }
label_12:
    *((ebp - 0xc390)) = 0;
label_14:
    eax = esi + 0x10;
    if (edx <= eax) {
        goto label_15;
    }
    *((ebp - 0xc380)) = eax;
    ecx = *((ebp + 0x10));
    if (*((eax + 4)) != ecx) {
        goto label_16;
    }
    while (edx > ecx) {
        if (*((ecx + 4)) == eax) {
            *((ebp - 0xc380)) = ecx;
            eax = *((ebp - 0xc388));
            ecx = *((ebp - 0xc380));
            ecx = *((ecx + 8));
            *((ebp - 0xc3b8)) = ecx;
            if (ecx != 0) {
                goto label_17;
            }
            goto label_18;
label_16:
            ecx = *((ebp - 0xc380));
            *((ebp - 0xc388)) = eax;
            eax = *((ebp + 0x10));
        }
        ecx += 0x20;
    }
    eax = *((ebp - 0xc388));
label_15:
    *((ebp - 0xc3b8)) = 0;
label_18:
    ecx = *((ebp - 0xc390));
    ecx -= 3;
    if (ecx > 1) {
        goto label_6;
    }
    goto label_19;
label_17:
    if (*((ebp - 0xc390)) <= 4) {
        ecx = *((ebp - 0xc390));
        /* switch table (5 cases) at 0x8076da0 */
        ecx = *((ebp - 0xc3b8));
        ecx--;
        cl = (ecx > 1) ? 1 : 0;
        ecx = (int32_t) cl;
        goto label_20;
        ecx = *((ebp - 0xc3b8));
        ecx -= 3;
        if (ecx > 1) {
            goto label_6;
        }
        goto label_21;
        ecx = *((ebp - 0xc3b8));
        ecx -= 3;
        cl = (ecx > 1) ? 1 : 0;
        ecx = (int32_t) cl;
    } else {
        ecx = *((ebp - 0xc3b8));
        cl = (*((ebp - 0xc390)) != ecx) ? 1 : 0;
        ecx = (int32_t) cl;
    }
label_20:
    if (ecx == 0) {
        goto label_21;
    }
    if (*(ebx) == 0) {
        if (*((ebx + 4)) != edi) {
            goto label_22;
        }
        if (*((ebp - 0xc390)) != 3) {
            goto label_22;
        }
        *(fp_stack--) = *((ebx + 8));
        fp_stack[0] = abs(fp_stack[0]);
        fp_stack[0] -= *(0x8075170);
        fp_stack[0] = abs(fp_stack[0]);
        *(fp_stack--) = *((ebp - 0xc3b0));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] < fp_stack[1]) {
            goto label_22;
        }
        eax = *((ebp - 0xc37c));
        eax -= 2;
        *((ebp - 0xc37c)) = eax;
        edi = ebx + 0x20;
        *((esp + 4)) = eax;
        eax = min_level (edi);
        edx = *((ebp - 0xc3a4));
        *((esp + 0xc)) = edx;
        ecx = *((ebp + 0x10));
        *((esp + 8)) = ecx;
        edx = *((ebp + 0xc));
        *((esp + 4)) = edx;
        *(esp) = esi;
        ecx = eax;
        edx = *((ebp - 0xc37c));
        eax = edi;
        eax = compare_recurse ();
        goto label_0;
        if (eax == 0) {
            goto label_6;
        }
        *(fp_stack--) = *((ebx + 8));
        *(fp_stack--) = 0.0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_23;
        }
        ecx = *((ebp - 0xc3a4));
        *(ecx) ^= 1;
        eax = 1;
        goto label_8;
    }
label_22:
    if (*(esi) != 0) {
        goto label_6;
    }
    eax = *((ebp + 0x10));
    if (*((esi + 4)) != eax) {
        goto label_6;
    }
    if (*((ebp - 0xc3b8)) != 3) {
        goto label_6;
    }
    *(fp_stack--) = *((esi + 8));
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] -= *(0x8075170);
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *((ebp - 0xc3b0));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] < fp_stack[1]) {
        goto label_6;
    }
    eax = *((ebp + 0xc));
    eax -= 2;
    *((ebp - 0xc384)) = eax;
    edx = esi + 0x20;
    *((ebp - 0xc380)) = edx;
    *((esp + 4)) = eax;
    eax = min_level (edx);
    ecx = *((ebp - 0xc3a4));
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = eax;
    eax = *((ebp - 0xc384));
    *((esp + 4)) = eax;
    edx = *((ebp - 0xc380));
    *(esp) = edx;
    ecx = edi;
    edx = *((ebp - 0xc37c));
    eax = ebx;
    eax = compare_recurse ();
    goto label_0;
    if (eax == 0) {
        goto label_6;
    }
    *(fp_stack--) = *((esi + 8));
    *(fp_stack--) = 0.0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_23;
    }
    ecx = *((ebp - 0xc3a4));
    *(ecx) ^= 1;
    eax = 1;
    goto label_8;
label_19:
    *((ebp - 0xc370)) = esi;
    *((ebp - 0x272c)) = 0;
    *((ebp - 0xc384)) = 1;
    if (edx <= eax) {
        goto label_24;
    }
    ecx = *((ebp - 0xc384));
    *((ebp - 0xc37c)) = ebx;
    ebx = *((ebp + 0x10));
    do {
label_4:
        if (*((eax + 4)) == ebx) {
            esi = eax + 0x10;
            *((ebp + ecx*4 - 0xc370)) = esi;
            *((ebp + ecx - 0x272c)) = 0;
            ecx++;
            if (ecx <= 0x270f) {
                goto label_25;
            }
            if (*(obj.debug_level) <= 0) {
                goto label_6;
            }
            *((esp + 0xc)) = "Expression too big to compare, because MAX_COMPARE_TERMS exceeded.";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = 0;
            goto label_8;
        }
label_25:
        eax += 0x20;
    } while (edx > eax);
    *((ebp - 0xc384)) = ecx;
    ebx = *((ebp - 0xc37c));
label_24:
    eax += 0x10;
    esi = *((ebp - 0xc384));
    *((ebp + esi*4 - 0xc370)) = eax;
    *((ebp - 0xc37c)) = ebx;
    *((ebp - 0xc398)) = 0;
    *((ebp - 0xc3b4)) = 1;
    esi = 1;
    ecx = *((ebp - 0xc390));
    esi <<= cl;
    *((ebp - 0xc3a8)) = esi;
    esi &= 0x19;
    *((ebp - 0xc3a0)) = esi;
label_3:
    eax = *((ebp - 0xc37c));
    eax += 0x10;
    *((ebp - 0xc388)) = eax;
    if (*((ebp - 0xc39c)) <= eax) {
        goto label_26;
    }
    if (edi < *((eax + 4))) {
        goto label_27;
    }
    while (eax < ecx) {
        edx = *((eax + 4));
        eax += 0x20;
        if (edi >= edx) {
            *((ebp - 0xc388)) = ebx;
            goto label_1;
label_26:
            esi = 1;
label_1:
            if (*((ebp - 0xc384)) > 0) {
                goto label_28;
            }
            goto label_2;
label_27:
            eax = *((ebp - 0xc37c));
            eax += 0x30;
            esi = 1;
            ecx = *((ebp - 0xc39c));
        }
        esi += 2;
        ebx = eax;
    }
    *((ebp - 0xc388)) = eax;
    goto label_1;
label_2:
    eax = *((ebp - 0xc390));
    eax -= 3;
    if (eax > 1) {
        goto label_6;
    }
    edx = *((ebp - 0xc37c));
    if (*((edx + 4)) != edi) {
        goto label_6;
    }
    if (*(edx) != 0) {
        goto label_6;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] -= *(0x8075170);
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *((ebp - 0xc3b0));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] < fp_stack[1]) {
        goto label_29;
    }
    *(fp_stack--) = 0.0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_30;
    }
    eax = *((ebp - 0xc3a4));
    *(eax) ^= 1;
    goto label_30;
label_28:
    ebx = 0;
    *((ebp - 0xc394)) = esi;
    do {
        edx = ebx;
        if (*((ebp + ebx - 0x272c)) == 0) {
            if (*((ebp - 0xc390)) <= 4) {
                if (*((ebp - 0xc3a0)) == 0) {
                    if ((*((ebp - 0xc3a8)) & 6) != 0) {
                        goto label_31;
                    }
                } else {
                    eax = 0;
                    if (ebx != 0) {
                        eax = *((ebp + ebx*4 - 0xc370));
                        al = (*((eax - 8)) == 4) ? 1 : 0;
                        eax = (int32_t) al;
                    }
                    cl = (*((ebp - 0xc398)) == 4) ? 1 : 0;
                    if (cl != al) {
                        goto label_32;
                    }
                }
            } else {
                cl = (*((ebp - 0xc398)) == 0) ? 1 : 0;
                al = (ebx == 0) ? 1 : 0;
                if (cl != al) {
                    goto label_6;
                }
            }
label_31:
            esi = *((ebp + edx*4 - 0xc370));
            eax = *((ebp + 0x10));
            eax++;
            ecx = *((ebp + 0x10));
            if (ecx >= *((esi + 4))) {
                eax = ecx;
            }
            edx = *((ebp + edx*4 - 0xc36c));
            *((ebp - 0xc38c)) = edx;
            ecx = edi + 1;
            edx = *((ebp - 0xc37c));
            if (edi >= *((edx + 4))) {
                ecx = edi;
            }
            edx = ebp - 0x2730;
            *((esp + 0xc)) = edx;
            *((esp + 8)) = eax;
            eax = *((ebp - 0xc38c));
            eax -= esi;
            eax >>= 4;
            eax--;
            *((esp + 4)) = eax;
            *(esp) = esi;
            edx = *((ebp - 0xc394));
            eax = *((ebp - 0xc37c));
            eax = compare_recurse ();
            goto label_0;
            if (eax == 0) {
                goto label_32;
            }
            if (*((ebp - 0xc390)) <= 4) {
                if (*((ebp - 0xc3a0)) == 0) {
                    if ((*((ebp - 0xc3a8)) & 6) == 0) {
                    } else {
                        eax = *((ebp - 0x2730));
                        ecx = *((ebp - 0xc3a4));
                        *(ecx) ^= eax;
                        goto label_33;
                    }
                    if (*((ebp - 0xc398)) == 2) {
                        al = (*((ebp - 0x2730)) == 0) ? 1 : 0;
                        eax = (int32_t) al;
                        *((ebp - 0x2730)) = eax;
                    }
                    if (ebx != 0) {
                        if (*((esi - 8)) != 2) {
                            goto label_34;
                        }
                        al = (*((ebp - 0x2730)) == 0) ? 1 : 0;
                        eax = (int32_t) al;
                        *((ebp - 0x2730)) = eax;
                    }
label_34:
                    if (*((ebp - 0xc3b4)) == 0) {
                        esi = *((ebp - 0xc3a4));
                        eax = *(esi);
                        if (eax != *((ebp - 0x2730))) {
                            goto label_32;
                        }
                        goto label_33;
                    }
                    eax = *((ebp - 0x2730));
                    edx = *((ebp - 0xc3a4));
                    *(edx) = eax;
                    *((ebp - 0xc3b4)) = 0;
                }
            } else {
                if (*((ebp - 0x2730)) != 0) {
                    goto label_32;
                }
            }
label_33:
            *((ebp + ebx - 0x272c)) = 1;
            goto label_30;
        }
label_32:
        ebx++;
    } while (ebx < *((ebp - 0xc384)));
    goto label_2;
label_30:
    ecx = *((ebp - 0xc388));
    if (*((ebp - 0xc39c)) <= ecx) {
        if (*((ebp - 0xc384)) > 0) {
            goto label_35;
        }
        goto label_23;
    }
    esi = *((ebp - 0xc388));
    esi = *((esi + 8));
    *((ebp - 0xc398)) = esi;
    eax = *((ebp - 0xc388));
    eax += 0x10;
    *((ebp - 0xc37c)) = eax;
    goto label_3;
label_35:
    eax = 0;
    ecx = ebp - 0x272c;
    esi = *((ebp - 0xc3b8));
    esi -= 3;
    ebx = ebp - 0xc370;
    edi = *((ebp - 0xc384));
    *((ebp - 0xc37c)) = esi;
    do {
        if (*((ecx + eax)) == 0) {
            if (*((ebp - 0xc37c)) > 1) {
                goto label_6;
            }
            edx = *((ebx + eax*4));
            esi = *((ebp + 0x10));
            if (*((edx + 4)) != esi) {
                goto label_6;
            }
            if (*(edx) != 0) {
                goto label_6;
            }
            *(fp_stack--) = *((edx + 8));
            *(fp_stack--) = fp_stack[0];
            fp_stack[0] = abs(fp_stack[0]);
            fp_stack[0] -= *(0x8075170);
            fp_stack[0] = abs(fp_stack[0]);
            *(fp_stack--) = *((ebp - 0xc3b0));
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] < fp_stack[1]) {
                goto label_36;
            }
            *(fp_stack--) = 0.0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] <= fp_stack[1]) {
                goto label_37;
            }
            edx = *((ebp - 0xc3a4));
            *(edx) ^= 1;
        }
label_37:
        eax++;
    } while (eax < edi);
    goto label_23;
label_29:
    fp_stack++;
    goto label_6;
label_36:
    fp_stack++;
label_6:
    eax = 0;
    goto label_8;
label_9:
    fp_stack++;
    fp_stack++;
    goto label_23;
label_11:
    fp_stack++;
    fp_stack++;
    fp_stack++;
label_23:
    eax = 1;
label_8:
    ecx = *((ebp - 0x1c));
    ecx ^= *(gs:0x14);
    if (eax != edi) {
        goto label_38;
label_21:
        *((ebp - 0xc370)) = esi;
        *((ebp - 0x272c)) = 0;
        *((ebp - 0xc384)) = 1;
        ecx = 1;
        *((ebp - 0xc37c)) = ebx;
        ebx = *((ebp + 0x10));
        goto label_4;
label_38:
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805c5e4 */
#include <stdint.h>
 
int32_t dbg_const_recurse (int32_t arg_8h, int32_t loc, int * np, int32_t level, token_type * equation) {
    int32_t var_9ch;
    int32_t var_98h;
    int32_t var_94h;
    double d2;
    void * s1;
    double d3;
    int32_t var_74h;
    int32_t const_count;
    int32_t loc1;
    int32_t modified;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    complexs p;
    complexs cv;
    double denominator;
    double numerator;
    double d1;
    int32_t var_ch;
    int32_t iflag;
    void * s2;
    size_t n;
    size_t var_8h;
    int32_t var_sp_ch;
    int32_t var_14h;
    ebx = loc;
    ecx = np;
    edi = level;
    eax = equation;
    do {
        /* int const_recurse(token_type * equation,int * np,int loc,int level,int iflag); */
        *((ebp - 0x5c)) = eax;
        *((ebp - 0x60)) = edx;
        *((ebp - 0x94)) = ecx;
        *((ebp - 0x6c)) = ecx;
        ebx = ecx;
        *((ebp - 0x68)) = 0;
        *((ebp - 0x70)) = 0;
        eax = *((ebp + 8));
        eax++;
        *((ebp - 0x98)) = eax;
        edi = *((ebp + 8));
label_0:
        edx = *((ebp - 0x60));
        if (ebx < *(edx)) {
            *((ebp - 0x64)) = ebx;
            esi = ebx;
            esi <<= 4;
            esi += *((ebp - 0x5c));
            eax = *((esi + 4));
            if (eax >= edi) {
                goto label_2;
            }
        }
        ebx -= *((ebp - 0x94));
        if (ebx != 1) {
            goto label_3;
        }
        edx = *((ebp - 0x94));
        edx <<= 4;
        eax = *((ebp + 8));
        eax--;
        ecx = 1;
        if (eax <= 0) {
            eax = ecx;
        }
        ecx = *((ebp - 0x5c));
        *((edx + ecx + 4)) = eax;
        goto label_3;
label_2:
        if (eax <= edi) {
            goto label_4;
        }
        eax = *((ebp + 0xc));
        *((esp + 4)) = eax;
        edx = *((ebp - 0x98));
        ecx = ebx;
        edx = *((ebp - 0x60));
        eax = *((ebp - 0x5c));
        eax = const_recurse (edx);
    } while (1);
    *((ebp - 0x68)) |= eax;
    ecx = *((ebp - 0x60));
    edx = *(ecx);
    if (ebx >= edx) {
        goto label_0;
    }
    if (edi >= *((esi + 4))) {
        goto label_0;
    }
    eax = ebx;
    eax <<= 4;
    esi = *((ebp - 0x5c));
    eax = esi + eax + 0x14;
label_1:
    ebx++;
    if (ebx >= edx) {
        goto label_0;
    }
    ecx = *(eax);
    eax += 0x10;
    if (edi < ecx) {
        goto label_1;
    }
    goto label_0;
label_4:
    if (*(esi) != 0) {
        goto label_5;
    }
    if (*((ebp - 0x70)) == 0) {
        *((ebp - 0x6c)) = ebx;
        *((ebp - 0x70)) = 1;
        goto label_5;
    }
    eax = *((ebp - 0x64));
    eax <<= 4;
    edx = *((ebp - 0x5c));
    eax = eax + edx - 0x10;
    *((ebp - 0x84)) = eax;
    ecx = *((eax + 8));
    *((ebp - 0x80)) = ecx;
    eax = *((ebp - 0x6c));
    *((ebp - 0x9c)) = eax;
    eax <<= 4;
    eax += edx;
    *((ebp - 0x74)) = eax;
    *(fp_stack--) = *((eax + 8));
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((esi + 8));
    *((ebp - 0x90)) = fp_stack[0];
    fp_stack--;
    eax = 0;
    edx = *((ebp - 0x94));
    if (*((ebp - 0x6c)) > edx) {
        eax = *((ebp - 0x9c));
        eax <<= 4;
        ecx = *((ebp - 0x5c));
        eax = ecx + eax - 8;
    }
    *(fp_stack--) = *((ebp - 0x90));
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x80));
    *((esp + 8)) = edx;
    ecx = ebp - 0x20;
    eax = calc (eax, ecx);
    if (eax == 0) {
        goto label_5;
    }
    if (*((ebp - 0x80)) != 6) {
        goto label_6;
    }
    if (*(obj.domain_check) != 0) {
        goto label_6;
    }
    eax = ebp - 0x30;
    edx = ebp - 0x28;
    *(fp_stack--) = *((ebp - 0x90));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = f_to_fraction (eax, edx);
    if (eax == 0) {
        *((ebp - 0x64)) = esi;
        if (*((ebp + 0xc)) == 0) {
            goto label_3;
        }
        if (*(obj.preserve_surds) != 0) {
            if (*(obj.approximate_roots) == 0) {
                goto label_3;
            }
        }
        *(fp_stack--) = *((ebp - 0x20));
        *((ebp - 0x40)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = 0.0;
        *((ebp - 0x38)) = fp_stack[0];
        *(fp_stack--) = *((ebp - 0x90));
        *((ebp - 0x50)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x48)) = fp_stack[0];
        fp_stack--;
        edx = ebp - 0x40;
        edi = esp + 0x14;
        esi = ebp - 0x50;
        ecx = 4;
        *(es:edi) = *(esi);
        ecx--;
        esi += 4;
        es:edi += 4;
        edi = esp + 4;
        cl = 4;
        esi = edx;
        *(es:edi) = *(esi);
        ecx--;
        esi += 4;
        es:edi += 4;
        complex_pow (edx);
        edx = *((ebp - 0x60));
        eax = *(edx);
        eax += 2;
        if (eax > *(obj.n_tokens)) {
            error_huge ();
        }
        ecx = *((ebp - 0x60));
        eax = *(ecx);
        eax -= *((ebp - 0x6c));
        eax <<= 4;
        esi = *((ebp - 0x74));
        eax = *((ebp - 0x9c));
        eax <<= 4;
        edx = *((ebp - 0x5c));
        eax = eax + edx + 0x20;
        memmove (eax, esi, eax);
        ecx = *((ebp - 0x60));
        *(ecx) += 2;
        eax = *((ebp + 8));
        *((esi + 4)) = eax;
        *(esi) = 0;
        *(fp_stack--) = *((ebp - 0x40));
        *((esi + 8)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x6c));
        eax <<= 4;
        edx = *((ebp - 0x5c));
        eax = eax + edx + 0x10;
        ecx = *((ebp + 8));
        *((eax + 4)) = ecx;
        *(eax) = 2;
        *((eax + 8)) = 1;
        edx = ecx;
        edx++;
        esi = *((ebp - 0x64));
        *((esi + 4)) = edx;
        *(esi) = 1;
        *((esi + 8)) = 3;
        eax = ebx;
        eax <<= 4;
        ecx = *((ebp - 0x5c));
        eax = eax + ecx + 0x10;
        *((eax + 4)) = edx;
        *(eax) = 2;
        *((eax + 8)) = 3;
        ebx <<= 4;
        eax = ebx + ecx + 0x20;
        *((eax + 4)) = edx;
        *(eax) = 0;
        *(fp_stack--) = *((ebp - 0x38));
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x68)) = 1;
        goto label_3;
    }
    errno_location ();
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x90));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x20));
    do {
        fp_stack[0] = -fp_stack[0];
    } while (ecx != 0);
    *(esp) = fp_stack[0];
    fp_stack--;
    pow ();
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
    ax = check_err ();
    *(fp_stack--) = *((ebp - 0x30));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (ebx == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_7;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = fmod ();
    goto label_8;
label_7:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_8:
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_9;
        }
    }
    *(fp_stack--) = *((ebp - 0x28));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_10;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_11;
label_10:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_11:
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_12;
        }
    }
    *(fp_stack--) = *((ebp - 0x80));
    fp_stack[0] = -fp_stack[0];
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
label_12:
    *(fp_stack--) = *((ebp - 0x80));
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    goto label_6;
label_9:
    *((ebp - 0x64)) = esi;
    if (*((ebp + 0xc)) != 0) {
        edx = *((ebp - 0x60));
        eax = *(edx);
        eax += 2;
        if (eax > *(obj.n_tokens)) {
            error_huge ();
        }
        ecx = *((ebp - 0x60));
        eax = *(ecx);
        eax -= *((ebp - 0x6c));
        eax <<= 4;
        esi = *((ebp - 0x74));
        eax = *((ebp - 0x9c));
        eax <<= 4;
        edx = *((ebp - 0x5c));
        eax = eax + edx + 0x20;
        memmove (eax, esi, eax);
        ecx = *((ebp - 0x60));
        *(ecx) += 2;
        *(fp_stack--) = *(0x8072054);
        *(fp_stack--) = *((ebp - 0x90));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            if (fp_stack[0] != fp_stack[1]) {
                eax = *((ebp + 8));
                eax++;
                edx = *((ebp - 0x74));
                *((edx + 4)) = eax;
                *(edx) = 0;
                *(fp_stack--) = *((ebp - 0x20));
                fp_stack[0] = -fp_stack[0];
                *((edx + 8)) = fp_stack[0];
                fp_stack--;
                edx = *((ebp - 0x6c));
                edx <<= 4;
                ecx = *((ebp - 0x5c));
                edx = edx + ecx + 0x10;
                *((edx + 4)) = eax;
                *(edx) = 2;
                *((edx + 8)) = 6;
                esi = *((ebp - 0x64));
                *((esi + 4)) = eax;
                *(esi) = 0;
                *(fp_stack--) = *(0x8072054);
                *((esi + 8)) = fp_stack[0];
                fp_stack--;
                eax = ebx;
                eax <<= 4;
                eax = eax + ecx + 0x10;
                edx = *((ebp + 8));
                *((eax + 4)) = edx;
                *(eax) = 2;
                *((eax + 8)) = 3;
                ebx <<= 4;
                eax = ebx + ecx + 0x20;
                *((eax + 4)) = edx;
                *(eax) = 1;
                *((eax + 8)) = 3;
                *((ebp - 0x68)) = 1;
            }
        } else {
            esi = *((ebp + 8));
            ecx = *((ebp - 0x74));
            *((ecx + 4)) = esi;
            *(ecx) = 0;
            *(fp_stack--) = *((ebp - 0x80));
            *((ecx + 8)) = fp_stack[0];
            fp_stack--;
            eax = *((ebp - 0x6c));
            eax <<= 4;
            edx = *((ebp - 0x5c));
            eax = eax + edx + 0x10;
            *((eax + 4)) = esi;
            *(eax) = 2;
            *((eax + 8)) = 3;
            edx = esi;
            edx++;
            ecx = *((ebp - 0x64));
            *((ecx + 4)) = edx;
            *(ecx) = 1;
            *((ecx + 8)) = 3;
            eax = ebx;
            eax <<= 4;
            esi = *((ebp - 0x5c));
            eax = eax + esi + 0x10;
            *((eax + 4)) = edx;
            *(eax) = 2;
            *((eax + 8)) = 6;
            ebx <<= 4;
            eax = ebx + esi + 0x20;
            *((eax + 4)) = edx;
            *(eax) = 0;
            *(fp_stack--) = *((ebp - 0x90));
            fp_stack[0] += fp_stack[0];
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            *((ebp - 0x68)) = 1;
            goto label_3;
label_6:
            *(fp_stack--) = *((ebp - 0x20));
            eax = *((ebp - 0x74));
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            *(obj.domain_check) = 0;
            eax = ebx;
            eax = ~eax;
            edx = *((ebp - 0x60));
            eax += *(edx);
            eax <<= 4;
            eax = *((ebp - 0x64));
            eax <<= 4;
            ecx = *((ebp - 0x5c));
            eax = eax + ecx + 0x10;
            esi = *((ebp - 0x84));
            memmove (esi, eax, eax);
            eax = *((ebp - 0x60));
            *(eax) -= 2;
            ebx -= 2;
            *((ebp - 0x68)) = 1;
label_5:
            ebx++;
            goto label_0;
        }
    }
label_3:
    eax = *((ebp - 0x68));
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805e290 */
#include <stdint.h>
 
int32_t dbg_fpower_recurse (int32_t i, int32_t loc, int32_t len, token_type * equation) {
    int32_t var_9ch;
    int32_t var_98h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_88h;
    int32_t modified;
    int32_t var_80h;
    uint32_t var_7ch;
    int32_t len1;
    int32_t b1;
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_68h;
    int32_t pop1;
    int32_t var_60h;
    void * var_5ch;
    int32_t op2;
    int32_t var_54h;
    int32_t var_50h;
    int32_t op1;
    int32_t var_48h;
    int32_t len2;
    int32_t var_40h;
    int32_t all_divide;
    void * var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t j;
    int32_t diff_sign;
    int32_t level;
    void * s2;
    size_t * n;
    int32_t var_ch;
    int32_t var_10h;
    ecx = i;
    edx = loc;
    edi = len;
    eax = equation;
    /* int fpower_recurse(token_type * equation,int * np,int loc,int level); */
label_5:
    *((ebp - 0x30)) = eax;
    *((ebp - 0x50)) = edx;
    *((ebp - 0x54)) = ecx;
    edx = ecx;
    edx++;
    eax = *((ebp - 0x50));
    esi = *(eax);
    if (edx >= esi) {
        goto label_7;
    }
    ebx = edx;
    ebx <<= 4;
    ebx += *((ebp - 0x30));
    eax = *((ebx + 4));
    if (*((ebp + 8)) > eax) {
        goto label_7;
    }
    if (eax != *((ebp + 8))) {
        goto label_8;
    }
    while (ecx >= edi) {
        eax += 0x20;
        if (ecx == edi) {
            eax = *((ebx + 8));
            eax -= 3;
            if (eax > 1) {
                goto label_7;
            }
            edx = *((ebp - 0x54));
            *((ebp - 0x48)) = edx;
            *((ebp - 0x84)) = 0;
            esi = *((ebp + 8));
            esi++;
            ecx = esi + 1;
            *((ebp - 0x9c)) = ecx;
            *((ebp - 0x94)) = esi;
            *((ebp - 0x88)) = ecx;
            goto label_2;
label_8:
            eax = *((ebp - 0x54));
            eax <<= 4;
            ecx = *((ebp - 0x30));
            eax = eax + ecx + 0x30;
            edi = *((ebp + 8));
        }
        edx += 2;
        if (edx >= esi) {
            goto label_7;
        }
        ebx = eax;
        ecx = *((eax + 4));
    }
label_7:
    *((ebp - 0x84)) = 0;
label_4:
    ebx = *((ebp - 0x54));
    esi = *((ebp + 8));
    esi++;
    edi = esi;
    esi = *((ebp + 8));
    goto label_9;
label_2:
    ebx = *((ebp - 0x48));
    ebx++;
    *((ebp - 0x3c)) = ebx;
    eax = *((ebp - 0x50));
    ebx = *(eax);
    if (*((ebp - 0x3c)) >= ebx) {
        goto label_10;
    }
    eax = *((ebp - 0x3c));
    eax <<= 4;
    ecx = *((ebp + 8));
    edx = *((ebp - 0x30));
    if (ecx >= *((eax + edx + 4))) {
        goto label_10;
    }
    eax = *((ebp - 0x48));
    eax <<= 4;
    edx = edx + eax + 0x34;
    eax = *((ebp - 0x3c));
    edi = ecx;
    while (eax < ebx) {
        ecx = *(edx);
        edx += 0x20;
        if (edi >= ecx) {
            goto label_11;
        }
        eax += 2;
    }
    goto label_11;
label_10:
    eax = *((ebp - 0x3c));
label_11:
    eax -= *((ebp - 0x48));
    *((ebp - 0x78)) = eax;
    eax += *((ebp - 0x48));
    *((ebp - 0x40)) = eax;
    eax++;
    *((ebp - 0x2c)) = eax;
    if (eax >= ebx) {
        goto label_12;
    }
    *((ebp - 0x60)) = eax;
    eax <<= 4;
    edx = *((ebp - 0x30));
    eax = eax + edx - 0x10;
    *((ebp - 0x38)) = eax;
    ecx = *((ebp + 8));
    if (ecx > *((eax + 4))) {
        goto label_12;
    }
    eax = *((ebp - 0x48));
    *((ebp - 0x8c)) = eax;
    eax <<= 4;
    eax = eax + edx - 0x10;
    *((ebp - 0x6c)) = eax;
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax = edx + eax + 4;
    *((ebp - 0x5c)) = eax;
    goto label_13;
label_3:
    edx = *((ebp - 0x2c));
    *((ebp - 0x60)) = edx;
    eax = edx;
    eax <<= 4;
    ecx = *((ebp - 0x30));
    eax = eax + ecx - 0x10;
    *((ebp - 0x38)) = eax;
    edx = *((ebp + 8));
    if (edx > *((eax + 4))) {
        goto label_12;
    }
label_13:
    edi = *((ebp - 0x2c));
    edi++;
    if (edi >= ebx) {
        goto label_14;
    }
    eax = edi;
    eax <<= 4;
    edx = *((ebp + 8));
    ecx = *((ebp - 0x30));
    if (edx >= *((eax + ecx + 4))) {
        goto label_14;
    }
    eax = *((ebp - 0x2c));
    eax <<= 4;
    edx = ecx + eax + 0x34;
    eax = edi;
    *((ebp - 0x34)) = edi;
    edi = *((ebp + 8));
    while (eax < ebx) {
        ecx = *(edx);
        edx += 0x20;
        if (edi >= ecx) {
            goto label_15;
        }
        eax += 2;
    }
    edi = *((ebp - 0x34));
    goto label_16;
label_14:
    eax = edi;
    goto label_16;
label_15:
    edi = *((ebp - 0x34));
label_16:
    eax -= *((ebp - 0x2c));
    *((ebp - 0x44)) = eax;
    ecx = *((ebp - 0x38));
    ecx = *((ecx + 8));
    *((ebp - 0x58)) = ecx;
    *((ebp - 0x4c)) = 3;
    ebx = *((ebp - 0x54));
    if (*((ebp - 0x48)) > ebx) {
        eax = *((ebp - 0x6c));
        eax = *((eax + 8));
        *((ebp - 0x4c)) = eax;
    }
    edx = *((ebp - 0x40));
    if (*((ebp - 0x3c)) >= edx) {
        goto label_17;
    }
    edx = *((ebp - 0x5c));
    ebx = *((ebp - 0x3c));
    ecx = *((ebp - 0x40));
    do {
        if (esi == *(edx)) {
            if (*((edx + 4)) != 6) {
                goto label_18;
            }
            *((ebp - 0x7c)) = ebx;
            eax = *((ebp - 0x44));
            eax += *((ebp - 0x2c));
            *((ebp - 0x68)) = eax;
            if (edi < eax) {
                goto label_19;
            }
            goto label_17;
        }
label_18:
        ebx += 2;
        edx += 0x20;
    } while (ecx > ebx);
    goto label_17;
label_19:
    edx = edi;
    edx <<= 4;
    eax = *((ebp - 0x30));
    eax = eax + edx + 4;
    *((ebp - 0x34)) = ebx;
    *((ebp - 0x64)) = ebx;
    ebx = *((ebp - 0x68));
    edx = eax;
    eax = *((ebp - 0x7c));
    do {
        if (esi == *(edx)) {
            if (*((edx + 4)) == 6) {
                goto label_20;
            }
        }
        edi += 2;
        edx += 0x20;
    } while (ebx > edi);
    goto label_17;
label_20:
    ebx = *((ebp - 0x64));
    *((ebp - 0x7c)) = eax;
    *((ebp - 0x74)) = edi;
    ecx = *((ebp - 0x34));
    *((ebp - 0x70)) = edi;
    ecx = ~ecx;
    ecx += *((ebp - 0x40));
    *((ebp - 0x34)) = ecx;
    eax <<= 4;
    edx = *((ebp - 0x30));
    eax = eax + edx + 0x10;
    *((ebp - 0x64)) = eax;
    ecx = ebp - 0x1c;
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = 1;
    *((esp + 8)) = 0x80796a4;
    eax = *((ebp - 0x34));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x64));
    *(esp) = edx;
    eax = se_compare ();
    if (eax != 0) {
        goto label_17;
    }
    ecx = ebp - 0x1c;
    *((esp + 0x10)) = ecx;
    eax = *((ebp - 0x70));
    eax = ~eax;
    eax += *((ebp - 0x68));
    *((esp + 0xc)) = eax;
    eax = *((ebp - 0x74));
    eax <<= 4;
    edx = *((ebp - 0x30));
    eax = eax + edx + 0x10;
    *((esp + 8)) = eax;
    ecx = *((ebp - 0x34));
    *((esp + 4)) = ecx;
    eax = *((ebp - 0x64));
    *(esp) = eax;
    eax = se_compare ();
    if (eax != 0) {
        ebx++;
        *((ebp - 0x74)) = ebx;
        edi++;
        edx = *((ebp - 0x68));
        *((ebp - 0x34)) = edx;
        ecx = *((ebp - 0x40));
        *((ebp - 0x70)) = ecx;
        *((ebp - 0x64)) = 3;
        goto label_21;
label_0:
        ebx = *((ebp - 0x70));
    } else {
        *((ebp - 0x90)) = edi;
        edi = *((ebp - 0x68));
        *((ebp - 0x98)) = esi;
        esi = *((ebp - 0x9c));
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x30));
    eax = *((eax + edx + 8));
    ecx = 3;
    if (eax != 6) {
        ecx = eax;
    }
    *((ebp - 0x64)) = ecx;
    eax = ebx + 1;
    *((ebp - 0x74)) = eax;
    if (*((ebp - 0x40)) <= eax) {
        goto label_22;
    }
    eax++;
    *((ebp - 0x70)) = eax;
    if (*((ebp - 0x40)) <= eax) {
        goto label_23;
    }
    ebx <<= 4;
    eax = edx + ebx + 0x24;
    edx = *((ebp - 0x70));
    ecx = *((ebp - 0x40));
    do {
        if (*(eax) == esi) {
            ebx = *((eax + 4));
            ebx -= 3;
            if (ebx <= 1) {
                goto label_24;
            }
        }
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
    *((ebp - 0x70)) = edx;
    goto label_23;
label_24:
    *((ebp - 0x70)) = edx;
label_23:
    edx = *((ebp - 0x70));
    edx -= *((ebp - 0x74));
    *((ebp - 0x7c)) = edx;
    eax = *((ebp - 0x74));
    eax <<= 4;
    eax += *((ebp - 0x30));
    *((ebp - 0x80)) = eax;
    ecx = ebp - 0x1c;
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = 1;
    *((esp + 8)) = 0x80796a4;
    *((esp + 4)) = edx;
    *(esp) = eax;
    eax = se_compare ();
    edx = eax;
    eax = *((ebp - 0x90));
    if (edx != 0) {
        goto label_0;
label_1:
        eax = ebx;
    }
    ebx = eax + 1;
    *((ebp - 0x34)) = ebx;
    if (edi <= ebx) {
        goto label_0;
    }
    ebx = ebx + 1;
    if (edi <= ebx) {
        goto label_25;
    }
    eax <<= 4;
    edx = *((ebp - 0x30));
    eax = edx + eax + 0x24;
    do {
        if (*(eax) == esi) {
            edx = *((eax + 4));
            edx -= 3;
            if (edx <= 1) {
                goto label_25;
            }
        }
        ebx += 2;
        eax += 0x20;
    } while (edi > ebx);
label_25:
    edx = *((ebp - 0x34));
    eax = *((ebp - 0x34));
    eax--;
    eax <<= 4;
    ecx = *((ebp - 0x30));
    eax = *((eax + ecx + 8));
    if (eax != 6) {
        goto label_26;
    }
    if (*((ebp - 0x64)) != 3) {
        goto label_1;
    }
    goto label_27;
label_26:
    if (eax != *((ebp - 0x64))) {
        goto label_1;
    }
label_27:
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    eax = ebx;
    eax -= *((ebp - 0x34));
    *((esp + 0xc)) = eax;
    eax = edx;
    eax <<= 4;
    eax += *((ebp - 0x30));
    *((esp + 8)) = eax;
    edx = *((ebp - 0x7c));
    *((esp + 4)) = edx;
    ecx = *((ebp - 0x80));
    *(esp) = ecx;
    eax = se_compare ();
    if (eax == 0) {
        goto label_1;
    }
    edi = *((ebp - 0x34));
    esi = *((ebp - 0x98));
    eax = *((ebp - 0x68));
    *((ebp - 0x34)) = eax;
    *((ebp - 0x68)) = ebx;
label_21:
    if (*((ebp - 0x58)) == 4) {
        al = (*((ebp - 0x1c)) == 0) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x1c)) = eax;
    }
    *((ebp - 0x3c)) = 0;
    if (*((ebp - 0x4c)) == 4) {
        al = (*((ebp - 0x1c)) != 0) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x3c)) = eax;
    }
    edx = *((ebp - 0x74));
    edx -= *((ebp - 0x48));
    *((ebp - 0x58)) = edx;
    ebx = edx;
    ebx <<= 4;
    eax = *((ebp - 0x8c));
    eax <<= 4;
    eax += *((ebp - 0x30));
    *((ebp - 0x5c)) = eax;
    eax = scratch;
    memmove (eax, eax, ebx);
    eax = scratch;
    ecx = *((ebp - 0x88));
    *((eax + ebx + 4)) = ecx;
    eax = scratch;
    *((eax + ebx)) = 0;
    ebp - 0x3c = (*((ebp - 0x3c)) == 0) ? 1 : 0;
    al = (*((ebp - 0x4c)) == 4) ? 1 : 0;
    al &= *((ebp - 0x3c));
    *((ebp - 0x7c)) = al;
    if (al != 0) {
        eax = scratch;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((ebx + eax + 8)) = fp_stack[0];
        fp_stack--;
    } else {
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((ebx + eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    ebx = *((ebp - 0x58));
    ebx++;
    eax = *((ebp - 0x40));
    eax -= *((ebp - 0x70));
    *((ebp - 0x4c)) = eax;
    eax <<= 4;
    eax = *((ebp - 0x70));
    eax <<= 4;
    eax += *((ebp - 0x30));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ebx += *((ebp - 0x4c));
    if (ebx <= 0) {
        goto label_28;
    }
    edx = 0;
    do {
        eax = 0;
        eax <<= 4;
        eax += *(obj.scratch);
        *((eax + 4)) += 2;
        edx++;
    } while (edx != ebx);
label_28:
    edx = ebx;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x88));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    ebx++;
    edi -= *((ebp - 0x2c));
    eax = edi;
    eax <<= 4;
    eax = *((ebp - 0x60));
    eax <<= 4;
    eax += *((ebp - 0x30));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    edi = ebx + edi;
    edx = edi;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x88));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 0;
    if (*((ebp - 0x3c)) != 0) {
        if (*((ebp - 0x1c)) != 0) {
            eax = scratch;
            *(fp_stack--) = 1.0;
            fp_stack[0] = -fp_stack[0];
            *((edx + eax + 8)) = fp_stack[0];
            fp_stack--;
        }
    } else {
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    edi++;
    eax = *((ebp - 0x34));
    eax -= *((ebp - 0x68));
    *((ebp - 0x2c)) = eax;
    eax <<= 4;
    eax = *((ebp - 0x68));
    eax <<= 4;
    eax += *((ebp - 0x30));
    eax = edi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    edi += *((ebp - 0x2c));
    if (ebx >= edi) {
        goto label_29;
    }
    edx = ebx;
    edx <<= 4;
    do {
        eax = edx;
        eax += *(obj.scratch);
        *((eax + 4)) += 2;
        ebx++;
        edx += 0x10;
    } while (edi > ebx);
label_29:
    edx = edi;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x94));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 6;
    edi++;
    if (*((ebp - 0x64)) == 4) {
        edx = edi;
        edx <<= 4;
        eax = scratch;
        ebx = *((ebp - 0x88));
        *((eax + edx + 4)) = ebx;
        eax = scratch;
        *((eax + edx)) = 0;
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
        edx = edi + 1;
        edx <<= 4;
        eax = scratch;
        *((eax + edx + 4)) = ebx;
        eax = scratch;
        *((eax + edx)) = 2;
        eax = scratch;
        *((eax + edx + 8)) = 4;
        edi += 2;
    }
    eax = *((ebp - 0x70));
    eax -= *((ebp - 0x74));
    *((ebp - 0x70)) = eax;
    ebx = edi;
    ebx <<= 4;
    eax <<= 4;
    eax = *((ebp - 0x74));
    eax <<= 4;
    eax += *((ebp - 0x30));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    edx = *((ebp - 0x70));
    edx += edi;
    *((ebp - 0x2c)) = edx;
    if (edi >= edx) {
        goto label_30;
    }
    do {
        eax = ebx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        edi++;
        ebx += 0x10;
    } while (edx > edi);
label_30:
    ebx = *((ebp - 0x44));
    ebx = ~ebx;
    eax = ebx;
    eax -= *((ebp - 0x78));
    ecx = *((ebp - 0x50));
    eax += *(ecx);
    eax += *((ebp - 0x2c));
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0x7c)) != 0) {
        eax = *((ebp - 0x6c));
        *((eax + 8)) = 3;
    }
    edx = *((ebp - 0x50));
    eax = *(edx);
    eax -= *((ebp - 0x34));
    eax <<= 4;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax += *((ebp - 0x30));
    ecx = *((ebp - 0x38));
    memmove (ecx, eax, eax);
    eax = ebx;
    edx = *((ebp - 0x50));
    eax += *(edx);
    *(edx) = eax;
    eax -= *((ebp - 0x40));
    eax <<= 4;
    eax = *((ebp - 0x40));
    eax <<= 4;
    eax += *((ebp - 0x30));
    eax = *((ebp - 0x2c));
    eax += *((ebp - 0x48));
    eax <<= 4;
    eax += *((ebp - 0x30));
    memmove (eax, eax, eax);
    eax = *((ebp - 0x2c));
    eax -= *((ebp - 0x78));
    ecx = *((ebp - 0x50));
    *(ecx) += eax;
    eax = *((ebp - 0x2c));
    eax <<= 4;
    eax = scratch;
    ebx = *((ebp - 0x5c));
    memmove (ebx, eax, eax);
    *((ebp - 0x84)) = 1;
    goto label_2;
label_22:
    esi = *((ebp - 0x98));
label_17:
    edx = *((ebp - 0x44));
    eax = *((ebp - 0x2c));
    eax = edx + eax + 1;
    *((ebp - 0x2c)) = eax;
    edx = *((ebp - 0x50));
    ebx = *(edx);
    if (ebx > eax) {
        goto label_3;
    }
label_12:
    ecx = *((ebp - 0x78));
    ecx += *((ebp - 0x3c));
    *((ebp - 0x48)) = ecx;
    if (ecx >= ebx) {
        goto label_4;
    }
    eax = ecx;
    eax--;
    eax <<= 4;
    edx = *((ebp + 8));
    ebx = *((ebp - 0x30));
    if (edx <= *((eax + ebx + 4))) {
        goto label_2;
    }
    goto label_4;
label_6:
    if (esi >= eax) {
        goto label_31;
    }
    *(esp) = edi;
    ecx = ebx;
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x30));
    eax = fpower_recurse ();
    goto label_5;
    *((ebp - 0x84)) |= eax;
    eax = ebx + 1;
    ecx = *((ebp - 0x50));
    ecx = *(ecx);
    *((ebp - 0x34)) = ecx;
    if (ecx <= eax) {
        goto label_32;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x30));
    if (esi >= *((edx + ecx + 4))) {
        goto label_32;
    }
    edx = ebx;
    edx <<= 4;
    edx = ecx + edx + 0x34;
    ecx = *((ebp - 0x34));
    do {
        eax += 2;
        if (ecx <= eax) {
            goto label_32;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    goto label_32;
label_31:
    eax = ebx + 1;
label_32:
    ebx = eax;
label_9:
    eax = *((ebp - 0x50));
    if (ebx >= *(eax)) {
        goto label_33;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x30));
    eax = *((eax + edx + 4));
    if (esi <= eax) {
        goto label_6;
    }
label_33:
    eax = *((ebp - 0x84));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805eba8 */
#include <stdint.h>
 
int32_t dbg_ftimes_recurse (int32_t k, int * np, int32_t loc, int32_t i, int32_t len) {
    uint32_t var_9ch;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_88h;
    int32_t modified;
    int32_t var_80h;
    int32_t var_7ch;
    uint32_t var_78h;
    int32_t var_64h;
    int32_t rlen1;
    int32_t op2;
    int32_t var_58h;
    int32_t len2;
    int32_t op1;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    int32_t len1;
    uint32_t var_3ch;
    int32_t j;
    int32_t var_34h;
    int32_t var_30h;
    int32_t s1;
    int32_t diff_sign;
    int32_t level;
    void * s2;
    size_t n;
    uint32_t var_ch;
    int32_t var_10h;
    ebx = k;
    ecx = np;
    edx = loc;
    esi = i;
    eax = len;
    /* int ftimes_recurse(token_type * equation,int * np,int loc,int level); */
label_2:
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x4c)) = edx;
    *((ebp - 0x7c)) = ecx;
    edx = ecx;
    edx++;
    eax = *((ebp - 0x4c));
    esi = *(eax);
    if (edx >= esi) {
        goto label_5;
    }
    ebx = edx;
    ebx <<= 4;
    ebx += *((ebp - 0x2c));
    eax = *((ebx + 4));
    if (*((ebp + 8)) > eax) {
        goto label_5;
    }
    if (eax != *((ebp + 8))) {
        goto label_6;
    }
    while (ecx >= edi) {
        eax += 0x20;
        if (ecx == edi) {
            eax = *((ebx + 8));
            eax -= 3;
            *((ebp - 0x84)) = 0;
            if (eax > 1) {
                goto label_7;
            }
            edx = *((ebp - 0x7c));
            *((ebp - 0x58)) = edx;
            edi = *((ebp + 8));
            edi++;
            *((ebp - 0x90)) = edi;
            goto label_0;
label_6:
            eax = *((ebp - 0x7c));
            eax <<= 4;
            ecx = *((ebp - 0x2c));
            eax = eax + ecx + 0x30;
            edi = *((ebp + 8));
        }
        edx += 2;
        if (edx >= esi) {
            goto label_5;
        }
        ebx = eax;
        ecx = *((eax + 4));
    }
    goto label_5;
label_0:
    ebx = *((ebp - 0x58));
    ebx++;
    *((ebp - 0x54)) = ebx;
    eax = *((ebp - 0x4c));
    esi = *(eax);
    if (ebx >= esi) {
        goto label_8;
    }
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp + 8));
    edx = *((ebp - 0x2c));
    if (ecx >= *((eax + edx + 4))) {
        goto label_8;
    }
    eax = *((ebp - 0x58));
    eax <<= 4;
    edx = edx + eax + 0x34;
    eax = ebx;
    ebx = ecx;
    while (eax < esi) {
        ecx = *(edx);
        edx += 0x20;
        if (ebx >= ecx) {
            goto label_9;
        }
        eax += 2;
    }
    goto label_9;
label_8:
    eax = *((ebp - 0x54));
label_9:
    eax -= *((ebp - 0x58));
    *((ebp - 0x40)) = eax;
    eax += *((ebp - 0x58));
    *((ebp - 0x44)) = eax;
    eax++;
    *((ebp - 0x38)) = eax;
    if (eax >= esi) {
        goto label_10;
    }
    *((ebp - 0x30)) = eax;
    eax <<= 4;
    ebx = *((ebp - 0x2c));
    eax = eax + ebx - 0x10;
    *((ebp - 0x34)) = eax;
    edx = *((ebp + 8));
    if (edx > *((eax + 4))) {
        goto label_10;
    }
    eax = *((ebp - 0x58));
    eax <<= 4;
    eax = eax + ebx - 0x10;
    *((ebp - 0x88)) = eax;
    eax = *((ebp - 0x58));
    eax <<= 4;
    eax += ebx;
    *((ebp - 0x64)) = eax;
    ecx = 2;
    ecx -= *((ebp - 0x58));
    *((ebp - 0x80)) = ecx;
    eax = *((ebp - 0x54));
    eax <<= 4;
    eax = ebx + eax + 4;
    *((ebp - 0x8c)) = eax;
    goto label_11;
label_1:
    ebx = *((ebp - 0x38));
    *((ebp - 0x30)) = ebx;
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x2c));
    eax = eax + edx - 0x10;
    *((ebp - 0x34)) = eax;
    ecx = *((ebp + 8));
    if (ecx > *((eax + 4))) {
        goto label_10;
    }
label_11:
    ebx = *((ebp - 0x38));
    ebx++;
    if (ebx >= esi) {
        goto label_12;
    }
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp + 8));
    edx = *((ebp - 0x2c));
    if (ecx >= *((eax + edx + 4))) {
        goto label_12;
    }
    eax = *((ebp - 0x38));
    eax <<= 4;
    edx = edx + eax + 0x34;
    eax = ebx;
    *((ebp - 0x3c)) = ebx;
    ebx = ecx;
    while (eax < esi) {
        ecx = *(edx);
        edx += 0x20;
        if (ebx >= ecx) {
            goto label_13;
        }
        eax += 2;
    }
    ebx = *((ebp - 0x3c));
    goto label_14;
label_12:
    eax = ebx;
    goto label_14;
label_13:
    ebx = *((ebp - 0x3c));
label_14:
    eax -= *((ebp - 0x38));
    *((ebp - 0x3c)) = eax;
    eax = *((ebp - 0x34));
    eax = *((eax + 8));
    *((ebp - 0x5c)) = eax;
    *((ebp - 0x50)) = 3;
    edx = *((ebp - 0x7c));
    if (*((ebp - 0x58)) > edx) {
        ecx = *((ebp - 0x88));
        ecx = *((ecx + 8));
        *((ebp - 0x50)) = ecx;
    }
    if (*((ebp - 0x40)) == 1) {
        eax = *((ebp - 0x64));
        if (*(eax) == 0) {
            goto label_15;
        }
    }
    if (*((ebp - 0x3c)) == 1) {
        eax = *((ebp - 0x30));
        eax <<= 4;
        edx = *((ebp - 0x2c));
        if (*((eax + edx)) == 0) {
            goto label_15;
        }
    }
    ecx = *((ebp - 0x3c));
    ecx += *((ebp - 0x38));
    *((ebp - 0x34)) = ecx;
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax += *((ebp - 0x2c));
    *((ebp - 0x48)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    edx = *((ebp - 0x3c));
    *((esp + 0xc)) = edx;
    ecx = *((ebp - 0x48));
    *((esp + 8)) = ecx;
    eax = *((ebp - 0x40));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x64));
    *(esp) = edx;
    eax = se_compare ();
    if (eax != 0) {
        goto label_16;
    }
    esi = *((ebp - 0x54));
    ecx = *((ebp - 0x44));
    if (esi >= ecx) {
        goto label_17;
    }
    eax = *((ebp - 0x8c));
    edx = ecx;
    do {
        if (edi == *(eax)) {
            if (*((eax + 4)) == 6) {
                goto label_17;
            }
        }
        esi += 2;
        eax += 0x20;
    } while (edx > esi);
label_17:
    if (ebx >= *((ebp - 0x34))) {
        goto label_18;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x2c));
    eax = edx + eax + 4;
    edx = *((ebp - 0x34));
    do {
        if (edi == *(eax)) {
            if (*((eax + 4)) == 6) {
                goto label_18;
            }
        }
        ebx += 2;
        eax += 0x20;
    } while (edx > ebx);
label_18:
    if (*((ebp - 0x44)) <= esi) {
        if (*((ebp - 0x34)) <= ebx) {
            goto label_15;
        }
    }
    ecx = ebx;
    ecx -= *((ebp - 0x38));
    *((ebp - 0x30)) = ecx;
    eax = esi;
    eax -= *((ebp - 0x58));
    *((ebp - 0x60)) = eax;
    edx = ebp - 0x1c;
    *((esp + 0x10)) = edx;
    *((esp + 0xc)) = ecx;
    ecx = *((ebp - 0x48));
    *((esp + 8)) = ecx;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x64));
    *(esp) = eax;
    eax = se_compare ();
    if (eax == 0) {
        if (*((ebp - 0x44)) <= esi) {
            goto label_15;
        }
        if (*((ebp - 0x34)) <= ebx) {
            goto label_15;
        }
        edx = ebp - 0x1c;
        *((esp + 0x10)) = edx;
        ecx = *((ebp - 0x30));
        *((esp + 0xc)) = ecx;
        eax = *((ebp - 0x48));
        *((esp + 8)) = eax;
        edx = *((ebp - 0x40));
        *((esp + 4)) = edx;
        ecx = *((ebp - 0x64));
        *(esp) = ecx;
        eax = se_compare ();
        if (eax != 0) {
            goto label_4;
        }
        ebx = ebp - 0x1c;
        *((esp + 0x10)) = ebx;
        eax = *((ebp - 0x3c));
        *((esp + 0xc)) = eax;
        edx = *((ebp - 0x48));
        *((esp + 8)) = edx;
        ecx = *((ebp - 0x60));
        *((esp + 4)) = ecx;
        ebx = *((ebp - 0x64));
        *(esp) = ebx;
        eax = se_compare ();
        if (eax == 0) {
            goto label_15;
        }
        ebx = *((ebp - 0x34));
    }
    if (*((ebp - 0x44)) != esi) {
        eax = *((ebp - 0x44));
        eax--;
        eax -= esi;
        *((ebp - 0x60)) = eax;
    } else {
label_4:
        esi = *((ebp - 0x44));
        *((ebp - 0x60)) = 1;
    }
    dl = (*((ebp - 0x50)) == 4) ? 1 : 0;
    al = (*((ebp - 0x5c)) == 4) ? 1 : 0;
    eax = (int32_t) al;
    ebp - 0x50 = ((eax & edx) == 0) ? 1 : 0;
    dl &= *((ebp - 0x50));
    *((ebp - 0x78)) = dl;
    eax = edx;
    eax <<= 0x1f;
    eax >>= 0x1f;
    eax &= 2;
    edx = 1;
    if (*((ebp - 0x34)) != ebx) {
        edx = *((ebp - 0x34));
        edx--;
        edx -= ebx;
    }
    ecx = ebx;
    ecx -= *((ebp - 0x38));
    *((ebp - 0x9c)) = ecx;
    if (ecx == 1) {
        ecx = *((ebp - 0x48));
        if (*(ecx) != 0) {
            goto label_19;
        }
        *(fp_stack--) = *((ecx + 8));
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            goto label_19;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_15;
        }
    }
label_19:
    ecx = *((ebp - 0x80));
    ecx -= *((ebp - 0x40));
    ecx += *((ebp - 0x60));
    ecx += esi;
    eax += ecx;
    eax += edx;
    *((ebp - 0x30)) = eax;
    if (*((ebp - 0x1c)) == 0) {
        *((ebp - 0x40)) = esi;
    } else {
        if (*((ebp - 0x9c)) == 1) {
            eax = *((ebp - 0x48));
            if (*(eax) == 0) {
                goto label_15;
            }
        }
        *((ebp - 0x80)) = ebx;
        edx = *((ebp - 0x5c));
        *((ebp - 0x84)) = edx;
        ecx = *((ebp - 0x34));
        *((ebp - 0x40)) = ecx;
        eax = ecx;
        eax += 2;
        eax -= ebx;
        *((ebp - 0x54)) = eax;
        eax = *((ebp - 0x30));
        edx = *((ebp - 0x4c));
        eax += *(edx);
        eax += *((ebp - 0x54));
        if (eax > *(obj.n_tokens)) {
            error_huge ();
        }
        eax = *((ebp - 0x40));
        eax <<= 4;
        eax += *((ebp - 0x2c));
        *((ebp - 0x48)) = eax;
        ecx = *((ebp - 0x4c));
        eax = *(ecx);
        eax -= *((ebp - 0x40));
        eax <<= 4;
        eax = *((ebp - 0x48));
        eax = *((ebp - 0x54));
        eax += *((ebp - 0x40));
        eax <<= 4;
        eax += *((ebp - 0x2c));
        memmove (eax, eax, eax);
        ecx = *((ebp - 0x54));
        edx = *((ebp - 0x4c));
        *(edx) += ecx;
        edx = *((ebp + 8));
        eax = *((ebp - 0x48));
        *((eax + 4)) = edx;
        *(eax) = 2;
        ecx = *((ebp - 0x84));
        *((eax + 8)) = ecx;
        eax = *((ebp - 0x40));
        eax <<= 4;
        edx = *((ebp - 0x2c));
        eax = eax + edx + 0x10;
        ecx = *((ebp - 0x90));
        *((eax + 4)) = ecx;
        *(eax) = 0;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x40));
        eax -= *((ebp - 0x80));
        eax <<= 4;
        eax = *((ebp - 0x80));
        eax <<= 4;
        eax += edx;
        eax = *((ebp - 0x40));
        eax <<= 4;
        eax = eax + edx + 0x20;
        memmove (eax, eax, eax);
        *((ebp - 0x40)) = esi;
    }
    eax = *((ebp - 0x30));
    edx = *((ebp - 0x4c));
    eax += *(edx);
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp - 0x44));
    *((ebp - 0x54)) = ecx;
    eax = ecx;
    eax <<= 4;
    eax += *((ebp - 0x2c));
    *((ebp - 0x48)) = eax;
    edx = *((ebp - 0x4c));
    eax = *(edx);
    eax -= ecx;
    eax <<= 4;
    ecx = *((ebp - 0x48));
    eax = *((ebp - 0x30));
    eax += *((ebp - 0x44));
    eax <<= 4;
    eax += *((ebp - 0x2c));
    memmove (eax, ecx, eax);
    edx = *((ebp - 0x30));
    eax = *((ebp - 0x4c));
    *(eax) += edx;
    ecx = *((ebp - 0x40));
    if (*((ebp - 0x44)) != ecx) {
        goto label_20;
    }
    eax = *((ebp - 0x44));
    if (*((ebp - 0x58)) >= eax) {
        goto label_21;
    }
    eax = *((ebp - 0x64));
    eax += 4;
    edx = *((ebp - 0x58));
    ecx = *((ebp - 0x44));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (ecx > edx);
label_21:
    edx = *((ebp - 0x48));
    *((edx + 4)) = edi;
    *(edx) = 2;
    *((edx + 8)) = 6;
    eax = *((ebp - 0x54));
    eax <<= 4;
    ecx = *((ebp - 0x2c));
    eax = eax + ecx + 0x10;
    *((eax + 4)) = edi;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
label_20:
    if (*((ebp - 0x78)) != 0) {
        eax = *((ebp - 0x88));
        *((eax + 8)) = 3;
        eax = *((ebp - 0x60));
        eax <<= 4;
        eax = *((ebp - 0x40));
        eax <<= 4;
        edx = *((ebp - 0x2c));
        esi = eax + edx + 0x10;
        eax = *((ebp - 0x40));
        eax <<= 4;
        eax = eax + edx + 0x30;
        memmove (eax, esi, eax);
        *((esi + 4)) = edi;
        *(esi) = 0;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((esi + 8)) = fp_stack[0];
        fp_stack--;
        esi = *((ebp - 0x40));
        esi += 2;
        eax = esi;
        eax <<= 4;
        eax += *((ebp - 0x2c));
        *((eax + 4)) = edi;
        *(eax) = 2;
        *((eax + 8)) = 3;
        *((esp + 8)) = esi;
        edx = *((ebp - 0x60));
        eax = esi + edx + 1;
        *((esp + 4)) = eax;
        ecx = *((ebp - 0x2c));
        binary_parenthesize (ecx);
    }
    eax = *((ebp - 0x60));
    esi = esi + eax + 1;
    edx = esi;
    eax = esi;
    eax <<= 4;
    eax += *((ebp - 0x2c));
    *((eax + 4)) = edi;
    *(eax) = 2;
    if (*((ebp - 0x50)) != 0) {
        if (*((ebp - 0x5c)) == 4) {
            *((eax + 8)) = 2;
        }
    } else {
        *((eax + 8)) = 1;
    }
    if (*((ebp - 0x34)) == ebx) {
        eax = edx;
        eax <<= 4;
        edx = *((ebp - 0x2c));
        eax = eax + edx + 0x10;
        *((eax + 4)) = edi;
        *(eax) = 0;
        *(fp_stack--) = 1.0;
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = esi;
        esi += 2;
        *((esp + 4)) = esi;
        binary_parenthesize (edx);
    } else {
        eax = *((ebp - 0x34));
        eax--;
        eax -= ebx;
        eax <<= 4;
        ecx = *((ebp - 0x30));
        eax = ecx + ebx + 1;
        eax <<= 4;
        eax += *((ebp - 0x2c));
        eax = edx;
        eax <<= 4;
        edx = *((ebp - 0x2c));
        eax = eax + edx + 0x10;
        memmove (eax, eax, eax);
        *((esp + 8)) = esi;
        ecx = *((ebp - 0x34));
        ecx -= ebx;
        esi = ecx + esi;
        *((esp + 4)) = esi;
        ebx = *((ebp - 0x2c));
        binary_parenthesize (ebx);
    }
    eax = *((ebp - 0x34));
    eax += *((ebp - 0x30));
    ecx = *((ebp - 0x4c));
    edx = *(ecx);
    edx -= eax;
    edx <<= 4;
    eax <<= 4;
    eax += *((ebp - 0x2c));
    edx = *((ebp - 0x30));
    ebx = *((ebp - 0x38));
    eax = edx + ebx - 1;
    eax <<= 4;
    eax += *((ebp - 0x2c));
    memmove (eax, eax, edx);
    eax = *((ebp - 0x3c));
    eax = ~eax;
    ecx = *((ebp - 0x4c));
    *(ecx) += eax;
    *((ebp - 0x84)) = 1;
    goto label_0;
label_15:
    eax = *((ebp - 0x3c));
    ebx = *((ebp - 0x38));
    ebx = eax + ebx + 1;
    *((ebp - 0x38)) = ebx;
    eax = *((ebp - 0x4c));
    esi = *(eax);
    if (esi > ebx) {
        goto label_1;
    }
label_10:
    edx = *((ebp - 0x40));
    edx += *((ebp - 0x54));
    *((ebp - 0x58)) = edx;
    if (edx >= esi) {
        goto label_7;
    }
    eax = edx;
    eax--;
    eax <<= 4;
    ebx = *((ebp + 8));
    ecx = *((ebp - 0x2c));
    if (ebx <= *((eax + ecx + 4))) {
        goto label_0;
    }
label_7:
    if (*((ebp - 0x84)) != 0) {
        *((ebp - 0x84)) = 1;
        goto label_22;
    }
    ebx = *((ebp - 0x7c));
    goto label_23;
label_3:
    if (esi >= eax) {
        goto label_24;
    }
    *(esp) = edi;
    ecx = ebx;
    edx = *((ebp - 0x4c));
    eax = *((ebp - 0x2c));
    eax = ftimes_recurse ();
    goto label_2;
    *((ebp - 0x84)) |= eax;
    eax = ebx + 1;
    edx = *((ebp - 0x4c));
    edx = *(edx);
    *((ebp - 0x34)) = edx;
    if (edx <= eax) {
        goto label_25;
    }
    ecx = eax;
    ecx <<= 4;
    edx = *((ebp - 0x2c));
    if (esi >= *((ecx + edx + 4))) {
        goto label_25;
    }
    edx = ebx;
    edx <<= 4;
    ecx = *((ebp - 0x2c));
    edx = ecx + edx + 0x34;
    ecx = *((ebp - 0x34));
    do {
        eax += 2;
        if (ecx <= eax) {
            goto label_25;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    goto label_25;
label_24:
    eax = ebx + 1;
label_25:
    ebx = eax;
    goto label_26;
label_5:
    ebx = *((ebp - 0x7c));
    *((ebp - 0x84)) = 0;
label_23:
    edi = *((ebp + 8));
    edi++;
    esi = *((ebp + 8));
label_26:
    eax = *((ebp - 0x4c));
    if (ebx >= *(eax)) {
        goto label_22;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x2c));
    eax = *((eax + edx + 4));
    if (esi <= eax) {
        goto label_3;
    }
label_22:
    eax = *((ebp - 0x84));
    return eax;
label_16:
    ebx = *((ebp - 0x34));
    goto label_4;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805f3fc */
#include <stdint.h>
 
int32_t dbg_big_fplus (int32_t arg_28h, uint32_t arg_30h, int32_t k, int32_t level, int32_t diff_sign, int32_t len, token_type * equation) {
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    void * s1;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t sop1;
    int32_t op1;
    int32_t op2;
    int32_t i1;
    int32_t i2;
    int32_t b1;
    int32_t b2;
    int32_t ai;
    int32_t i;
    int32_t e1;
    int32_t e2;
    void * s2;
    size_t n;
    ebx = k;
    ecx = level;
    edx = diff_sign;
    esi = len;
    eax = equation;
    /* int big_fplus(token_type * equation,int level,int diff_sign,int sop1,int op1,int op2,int i1,int i2,int b1,int b2,int ai,int aj,int i,int j,int e1,int e2); */
    *((ebp - 0x28)) = eax;
    *((ebp - 0x2c)) = edx;
    *((ebp - 0x34)) = ecx;
    edi = *((ebp + 0x14));
    *((ebp - 0x30)) = 0;
    if (*((ebp + 8)) == 4) {
        eax = scratch;
        *((eax + 4)) = edx;
        eax = scratch;
        *(eax) = 0;
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = scratch;
        *((eax + 0x14)) = edx;
        eax = scratch;
        *((eax + 0x10)) = 2;
        eax = scratch;
        *((eax + 0x18)) = 4;
        *((ebp - 0x30)) = 2;
    }
    esi = *((ebp + 0x2c));
    esi -= *((ebp + 0x1c));
    ebx = *((ebp - 0x30));
    ebx <<= 4;
    eax = esi;
    eax <<= 4;
    eax = *((ebp + 0x1c));
    eax <<= 4;
    eax += *((ebp - 0x28));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    esi += *((ebp - 0x30));
    if (*((ebp + 0x1c)) != edi) {
        goto label_0;
    }
    eax = *((ebp + 0x34));
    if (*((ebp + 0x2c)) != eax) {
        goto label_0;
    }
    if (*((ebp - 0x30)) >= esi) {
        goto label_0;
    }
    eax = *((ebp - 0x30));
    do {
        edx = ebx;
        edx += *(obj.scratch);
        *((edx + 4))++;
        eax++;
        ebx += 0x10;
    } while (esi > eax);
label_0:
    eax = esi;
    eax <<= 4;
    edx = scratch;
    ecx = *((ebp - 0x2c));
    *((edx + eax + 4)) = ecx;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 3;
    ebx = esi + 1;
    esi = *((ebp + 0x1c));
    esi -= edi;
    eax = esi;
    eax <<= 4;
    edi <<= 4;
    edi += *((ebp - 0x28));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, edi, eax);
    esi = ebx + esi;
    eax = esi;
    eax <<= 4;
    edx = scratch;
    ecx = *((ebp - 0x2c));
    *((edx + eax + 4)) = ecx;
    edx = scratch;
    *((edx + eax)) = 0;
    if (*((ebp + 0xc)) == 2) {
        edx = scratch;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((eax + edx + 8)) = fp_stack[0];
        fp_stack--;
    } else {
        edx = scratch;
        *(fp_stack--) = 1.0;
        *((eax + edx + 8)) = fp_stack[0];
        fp_stack--;
    }
    esi++;
    edi = *((ebp + 0x34));
    edi -= *((ebp + 0x2c));
    eax = edi;
    eax <<= 4;
    eax = *((ebp + 0x2c));
    eax <<= 4;
    eax += *((ebp - 0x28));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    esi += edi;
    if (ebx >= esi) {
        goto label_1;
    }
    eax = ebx;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.scratch);
        *((edx + 4)) += 2;
        ebx++;
        eax += 0x10;
    } while (esi > ebx);
label_1:
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x2c));
    edx++;
    *((ebp - 0x40)) = edx;
    edx = scratch;
    ecx = *((ebp - 0x40));
    *((edx + eax + 4)) = ecx;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    ecx = *((ebp + 0x10));
    *((edx + eax + 8)) = ecx;
    esi++;
    *((ebp - 0x24)) = esi;
    edi = *((ebp + 0x20));
    edi -= *((ebp + 0x18));
    eax = edi;
    eax <<= 4;
    eax = *((ebp + 0x18));
    eax <<= 4;
    eax += *((ebp - 0x28));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    edi += *((ebp - 0x24));
    eax = *((ebp + 0x2c));
    eax -= *((ebp + 0x24));
    *((ebp - 0x3c)) = eax;
    eax = 2;
    eax -= *((ebp + 0x20));
    edx = *((ebp - 0x3c));
    eax = eax + edx*2;
    eax += *((ebp + 0x38));
    eax += edi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp + 0x28));
    eax -= *((ebp + 0x20));
    eax += edi;
    *((ebp - 0x38)) = eax;
    esi = *((ebp + 0x30));
    esi -= *((ebp + 0x20));
    ebx = edi;
    ebx <<= 4;
    eax = esi;
    eax <<= 4;
    eax = *((ebp + 0x20));
    eax <<= 4;
    eax += *((ebp - 0x28));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    esi = edi + esi;
    eax = *((ebp - 0x38));
    eax++;
    if (esi <= eax) {
        goto label_2;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (esi > eax);
label_2:
    ebp - 0x34 = (*((ebp - 0x34)) != 0) ? 1 : 0;
    if (*((ebp - 0x34)) == 0) {
        goto label_3;
    }
    ecx = *((ebp + 0x18));
    if (*((ebp + 0x20)) != ecx) {
        goto label_3;
    }
    eax = *((ebp + 0x38));
    if (*((ebp + 0x30)) != eax) {
        goto label_3;
    }
    if (edi >= esi) {
        goto label_3;
    }
    do {
        eax = ebx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        edi++;
        ebx += 0x10;
    } while (esi > edi);
label_3:
    edx = scratch;
    eax = esi;
    eax <<= 4;
    edi = *((ebp - 0x38));
    edi <<= 4;
    ecx = *((edx + edi + 4));
    ecx++;
    *((edx + eax + 4)) = ecx;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = scratch;
    *((edx + eax + 8)) = 2;
    esi++;
    eax = *((ebp + 0x24));
    eax = ~eax;
    eax += *((ebp + 0x2c));
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 0x24));
    eax <<= 4;
    edx = *((ebp - 0x28));
    eax = eax + edx + 0x10;
    *((ebp - 0x20)) = eax;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    ecx = *((ebp - 0x20));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, ecx, eax);
    ebx = *((ebp - 0x1c));
    ebx = esi + ebx;
    eax = *((ebp - 0x1c));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x20));
    eax = min_level (edx);
    edx = scratch;
    edx = *((edx + edi + 4));
    edx += 2;
    edx -= eax;
    eax = edx;
    if (esi >= ebx) {
        goto label_4;
    }
    edx = esi;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += eax;
        esi++;
        edx += 0x10;
    } while (ebx > esi);
label_4:
    if (*((ebp - 0x34)) != 0) {
        eax = ebx;
        eax <<= 4;
        edx = scratch;
        ecx = *((ebp - 0x2c));
        *((edx + eax + 4)) = ecx;
        edx = scratch;
        *((edx + eax)) = 2;
        if (*((ebp + 8)) == 4) {
            edx = scratch;
            *((edx + eax + 8)) = 3;
        } else {
            edx = scratch;
            *((edx + eax + 8)) = 4;
        }
        eax = ebx + 1;
        eax <<= 4;
        edx = scratch;
        ecx = *((ebp - 0x40));
        *((edx + eax + 4)) = ecx;
        edx = scratch;
        *((edx + eax)) = 0;
        edx = scratch;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((eax + edx + 8)) = fp_stack[0];
        fp_stack--;
        ebx += 2;
        eax = scratch;
        edx = *((ebp - 0x3c));
        edx <<= 4;
        edx = *((ebp + 0x24));
        edx -= *((ebp + 0x1c));
        edx += *((ebp - 0x30));
        edx <<= 4;
        edx = eax + edx;
        edx = ebx;
        edx <<= 4;
        eax += edx;
        memmove (eax, edx, edx);
        ebx += *((ebp - 0x3c));
    }
    esi = *((ebp + 0x38));
    esi -= *((ebp + 0x30));
    eax = esi;
    eax <<= 4;
    eax = *((ebp + 0x30));
    eax <<= 4;
    eax += *((ebp - 0x28));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    eax = ebx + esi;
    if (*((ebp - 0x24)) >= eax) {
        goto label_5;
    }
    edx = *((ebp - 0x24));
    edx <<= 4;
    edi = *((ebp - 0x24));
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += 2;
        edi++;
        edx += 0x10;
    } while (eax > edi);
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805f8b2 */
#include <stdint.h>
 
int32_t dbg_fplus_recurse (int32_t i, int32_t m, int32_t flag2, int32_t flag1, int32_t same_flag) {
    int32_t var_dch;
    int32_t var_cch;
    int32_t var_c8h;
    int32_t var_c4h;
    int32_t var_c0h;
    int32_t var_bch;
    void * var_b8h;
    int32_t var_b4h;
    int32_t op2;
    int32_t op1;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_a0h;
    int32_t modified;
    int32_t var_98h;
    void * var_94h;
    int32_t len1;
    uint32_t var_8ch;
    int32_t var_7ch;
    uint32_t var_75h;
    int32_t len2;
    int32_t var_70h;
    int32_t sop1;
    int32_t var_68h;
    int32_t var_64h;
    void * s1;
    uint32_t var_5ch;
    double save_d1;
    double save_k1;
    int32_t var_48h;
    int32_t j;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t l;
    int32_t var_2ch;
    double power;
    int32_t diff_sign;
    int32_t level;
    long int v;
    double d;
    int32_t whole_flag;
    int32_t div_only;
    size_t s2;
    size_t n;
    uint32_t var_ch;
    uint32_t var_10h;
    uint32_t var_14h;
    int32_t var_18h;
    int32_t var_sp_1ch;
    int32_t var_20h;
    int32_t var_24h;
    int32_t var_sp_28h;
    int32_t var_sp_2ch;
    int32_t var_sp_30h;
    ecx = i;
    edx = m;
    esi = flag2;
    edi = flag1;
    eax = same_flag;
    /* int fplus_recurse(token_type * equation,int * np,int loc,int level,long int v,double d,int whole_flag,int div_only); */
label_11:
    *((ebp - 0x38)) = eax;
    *((ebp - 0x98)) = edx;
    *((ebp - 0xa4)) = ecx;
    *(fp_stack--) = *((ebp + 0x10));
    *((ebp - 0x88)) = fp_stack[0];
    fp_stack--;
    edx = ecx;
    edx++;
    eax = *((ebp - 0x98));
    esi = *(eax);
    eax = edx;
    eax <<= 4;
    eax += *((ebp - 0x38));
    while (ecx >= *((ebp + 8))) {
        eax += 0x20;
        if (ecx == *((ebp + 8))) {
            eax = *((ebx + 8));
            eax--;
            *((ebp - 0x9c)) = 0;
            if (eax > 1) {
                goto label_13;
            }
            edx = *((ebp - 0xa4));
            *((ebp - 0x48)) = edx;
            ecx = *((ebp + 8));
            ecx++;
            *((ebp - 0x64)) = ecx;
            ecx++;
            *((ebp - 0xbc)) = ecx;
            goto label_3;
        }
        edx += 2;
        if (edx >= esi) {
            goto label_14;
        }
        ebx = eax;
        ecx = *((eax + 4));
    }
    goto label_14;
label_3:
    esi = *((ebp - 0x48));
    esi++;
    *((ebp - 0xb4)) = esi;
    edi = *((ebp - 0x98));
    ebx = *(edi);
    if (esi >= ebx) {
        goto label_15;
    }
    eax = esi;
    eax <<= 4;
    ecx = *((ebp + 8));
    edx = *((ebp - 0x38));
    if (ecx >= *((eax + edx + 4))) {
        goto label_15;
    }
    eax = *((ebp - 0x48));
    eax <<= 4;
    edx = edx + eax + 0x34;
    eax = esi;
    esi = ecx;
    while (eax < ebx) {
        ecx = *(edx);
        edx += 0x20;
        if (esi >= ecx) {
            goto label_16;
        }
        eax += 2;
    }
    goto label_16;
label_15:
    eax = *((ebp - 0xb4));
label_16:
    eax -= *((ebp - 0x48));
    *((ebp - 0x90)) = eax;
    eax += *((ebp - 0x48));
    *((ebp - 0x70)) = eax;
    eax++;
    *((ebp - 0x44)) = eax;
    if (eax >= ebx) {
        goto label_17;
    }
    *((ebp - 0xa0)) = eax;
    eax <<= 4;
    esi = *((ebp - 0x38));
    eax = eax + esi - 0x10;
    *((ebp - 0x94)) = eax;
    edi = *((ebp + 8));
    if (edi > *((eax + 4))) {
        goto label_17;
    }
    eax = *((ebp - 0x48));
    eax <<= 4;
    eax = eax + esi - 0x10;
    *((ebp - 0xc0)) = eax;
    eax = *((ebp - 0x48));
    eax <<= 4;
    *((ebp - 0xb8)) = eax;
    esi += eax;
    *((ebp - 0x60)) = esi;
    goto label_18;
label_10:
    edx = *((ebp - 0x44));
    *((ebp - 0xa0)) = edx;
    eax = edx;
    eax <<= 4;
    ecx = *((ebp - 0x38));
    eax = eax + ecx - 0x10;
    *((ebp - 0x94)) = eax;
    esi = *((ebp + 8));
    if (esi > *((eax + 4))) {
        goto label_17;
    }
label_18:
    eax = *((ebp - 0x44));
    eax++;
    if (eax >= ebx) {
        goto label_19;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp + 8));
    edi = *((ebp - 0x38));
    if (ecx >= *((edx + edi + 4))) {
        goto label_19;
    }
    edx = *((ebp - 0x44));
    edx <<= 4;
    edx = edi + edx + 0x34;
    esi = ecx;
    while (eax < ebx) {
        ecx = *(edx);
        edx += 0x20;
        if (esi >= ecx) {
            goto label_19;
        }
        eax += 2;
    }
label_19:
    eax -= *((ebp - 0x44));
    *((ebp - 0x74)) = eax;
    esi = *((ebp - 0x64));
    *((ebp - 0x8c)) = esi;
    eax += *((ebp - 0x44));
    *((ebp - 0x40)) = eax;
    edi = *((ebp - 0x94));
    edi = *((edi + 8));
    *((ebp - 0xb0)) = edi;
    *((ebp - 0xac)) = 1;
    eax = *((ebp - 0xa4));
    if (*((ebp - 0x48)) > eax) {
        edx = *((ebp - 0xc0));
        edx = *((edx + 8));
        *((ebp - 0xac)) = edx;
    }
    eax = *((ebp - 0x48));
    eax--;
    edx = *((ebp - 0xa0));
    edx <<= 4;
    edx += *((ebp - 0x38));
    *((ebp - 0x5c)) = edx;
    ecx = *((ebp - 0x44));
    ecx--;
    *((ebp - 0xa8)) = ecx;
    esi = *((ebp - 0xbc));
    *((ebp - 0x7c)) = esi;
    goto label_20;
label_0:
    eax = *((ebp - 0x3c));
label_20:
    edi = eax + 1;
    *((ebp - 0x34)) = edi;
    if (*((ebp - 0x70)) <= edi) {
        goto label_21;
    }
    if (*((ebp + 0x18)) != 0) {
        if (*((ebp - 0x90)) <= 1) {
            goto label_22;
        }
        eax = edi;
        eax <<= 4;
        ecx = *((ebp - 0x38));
        if (*((eax + ecx)) != 0) {
            goto label_22;
        }
        eax = edi;
        eax <<= 4;
        eax = eax + ecx + 0x10;
        esi = *((ebp - 0x64));
        if (esi != *((eax + 4))) {
            goto label_22;
        }
        eax = *((eax + 8));
        eax -= 3;
        if (eax > 1) {
            goto label_22;
        }
        edi += 2;
        *((ebp - 0x34)) = edi;
        edi = *((ebp - 0x70));
        *((ebp - 0x3c)) = edi;
        goto label_23;
    }
    edx = *((ebp - 0x34));
    edx++;
    *((ebp - 0x3c)) = edx;
    if (*((ebp - 0x70)) <= edx) {
        goto label_23;
    }
    eax <<= 4;
    ecx = *((ebp - 0x38));
    eax = ecx + eax + 0x24;
    ebx = *((ebp - 0x70));
    ecx = *((ebp - 0x64));
    do {
        if (ecx == *(eax)) {
            esi = *((eax + 4));
            esi -= 3;
            if (esi <= 1) {
                goto label_24;
            }
        }
        edx += 2;
        eax += 0x20;
    } while (ebx > edx);
    *((ebp - 0x3c)) = edx;
    goto label_23;
label_22:
    esi = *((ebp - 0x70));
    *((ebp - 0x3c)) = esi;
    goto label_23;
label_24:
    *((ebp - 0x3c)) = edx;
label_23:
    *((ebp - 0x6c)) = 3;
    edi = *((ebp - 0x34));
    if (*((ebp - 0x48)) < edi) {
        eax = edi;
        eax--;
        eax <<= 4;
        edx = *((ebp - 0x38));
        eax = *((eax + edx + 8));
        *((ebp - 0x6c)) = eax;
    }
    ebp - 0x68 = (*((ebp + 0x1c)) != 0) ? 1 : 0;
    if (*((ebp + 0x1c)) == 0) {
        goto label_25;
    }
    if (*((ebp - 0x6c)) != 4) {
        goto label_0;
    }
label_25:
    eax = *((ebp - 0x3c));
    eax -= *((ebp - 0x34));
    if (eax != 1) {
        goto label_26;
    }
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax += *((ebp - 0x38));
    if (*(eax) != 0) {
        goto label_26;
    }
    *(fp_stack--) = *((eax + 8));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_26;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_0;
    }
label_26:
    ebp - 0x75 = (*((ebp + 0xc)) != 0) ? 1 : 0;
    if (*((ebp + 0x18)) != 0) {
        goto label_27;
    }
    if (*((ebp - 0x75)) == 0) {
        goto label_27;
    }
    if (*((ebp + 0xc)) == 5) {
        goto label_27;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x88));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_28;
        }
    }
    *(fp_stack--) = 1.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_29;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_29;
    }
    goto label_30;
label_28:
    fp_stack++;
label_30:
    eax = *((ebp - 0x3c));
    if (*((ebp - 0x34)) >= eax) {
        goto label_0;
    }
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax += *((ebp - 0x38));
    edx = *((ebp - 0x34));
    ecx = *((ebp - 0x3c));
    ebx = *((ebp + 0xc));
    do {
        if (*(eax) == 1) {
            if (ebx == *((eax + 8))) {
                goto label_27;
            }
        }
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
    goto label_0;
label_29:
    eax = *((ebp - 0x34));
    eax++;
    if (*((ebp - 0x3c)) <= eax) {
        goto label_0;
    }
    eax <<= 4;
    ecx = *((ebp - 0x38));
    edx = ecx + eax + 8;
    ecx = *((ebp - 0x34));
    eax = *((ebp - 0x34));
    eax <<= 4;
    esi = *((ebp - 0x38));
    ebx = esi + eax + 0x24;
    eax = ecx;
    eax <<= 4;
    esi = esi + eax + 4;
    edi = eax;
    eax = *((ebp - 0x38));
    edi = edi + eax - 0x10;
label_1:
    if (*(edx) != 6) {
        goto label_31;
    }
    eax = *((edx - 4));
    *((ebp - 0xdc)) = eax;
    if (eax != *(ebx)) {
        goto label_31;
    }
    if (*((ebx - 4)) != 0) {
        goto label_31;
    }
    *(fp_stack--) = *((ebx + 4));
    *(fp_stack--) = *((ebp - 0x88));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_31;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_31;
    }
    *((ebp - 0x30)) = ecx;
    if (ecx < 0) {
        goto label_31;
    }
    eax = esi - 4;
    *((ebp - 0xcc)) = eax;
    *((ebp - 0xc8)) = edi;
    eax = *((ebp - 0xdc));
    if (eax <= *(esi)) {
        goto label_32;
    }
    goto label_31;
    do {
        esi = ebx;
        edi = *((ebx + 4));
        ebx -= 0x10;
        if (eax > edi) {
            goto label_33;
label_32:
            *((ebp - 0x50)) = edi;
            *((ebp - 0x58)) = esi;
            *((ebp - 0xc4)) = ebx;
            ebx = *((ebp - 0xc8));
            eax = *((ebp - 0xdc));
            esi = *((ebp - 0xcc));
        }
        if (*(esi) == 1) {
            edi = *((ebp + 0xc));
            if (edi == *((esi + 8))) {
                goto label_27;
            }
        }
        *((ebp - 0x30))--;
    } while (*((ebp - 0x30)) >= 0);
    edi = *((ebp - 0x50));
    esi = *((ebp - 0x58));
    ebx = *((ebp - 0xc4));
    goto label_31;
label_33:
    edi = *((ebp - 0x50));
    esi = *((ebp - 0x58));
    ebx = *((ebp - 0xc4));
label_31:
    edx += 0x20;
    ecx += 2;
    ebx += 0x20;
    esi += 0x20;
    edi += 0x20;
    eax = ecx + 1;
    if (*((ebp - 0x3c)) > eax) {
        goto label_1;
    }
    goto label_0;
label_27:
    eax = *((ebp - 0xa8));
    goto label_34;
label_6:
    fp_stack++;
    goto label_2;
label_8:
    fp_stack++;
label_2:
    eax = ebx;
label_34:
    edx = eax + 1;
    *((ebp - 0x30)) = edx;
    if (*((ebp - 0x40)) <= edx) {
        goto label_0;
    }
    if (*((ebp + 0x18)) != 0) {
        if (*((ebp - 0x74)) <= 1) {
            goto label_35;
        }
        eax = edx;
        eax <<= 4;
        ecx = *((ebp - 0x38));
        if (*((eax + ecx)) != 0) {
            goto label_35;
        }
        eax = eax + ecx + 0x10;
        esi = *((ebp - 0x64));
        if (esi != *((eax + 4))) {
            goto label_35;
        }
        eax = *((eax + 8));
        eax -= 3;
        if (eax > 1) {
            goto label_35;
        }
        *((ebp - 0x30)) += 2;
        ebx = *((ebp - 0x40));
        goto label_36;
    }
    ebx = *((ebp - 0x30));
    ebx++;
    if (*((ebp - 0x40)) <= ebx) {
        goto label_37;
    }
    eax <<= 4;
    edi = *((ebp - 0x38));
    eax = edi + eax + 0x24;
    ecx = *((ebp - 0x40));
    edx = *((ebp - 0x64));
    do {
        if (edx == *(eax)) {
            esi = *((eax + 4));
            esi -= 3;
            if (esi <= 1) {
                goto label_37;
            }
        }
        ebx += 2;
        eax += 0x20;
    } while (ecx > ebx);
label_37:
    eax = *((ebp - 0x44));
    if (*((ebp - 0x30)) <= eax) {
        if (*((ebp - 0x6c)) != 4) {
            goto label_36;
        }
        goto label_2;
    }
    eax = *((ebp - 0x30));
    eax--;
    eax <<= 4;
    ecx = *((ebp - 0x6c));
    edx = *((ebp - 0x38));
    if (ecx != *((eax + edx + 8))) {
        goto label_2;
    }
    goto label_36;
label_35:
    ebx = *((ebp - 0x40));
label_36:
    eax = *((ebp - 0x40));
    eax -= *((ebp - 0x30));
    if (eax != 1) {
        goto label_38;
    }
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax += *((ebp - 0x38));
    if (*(eax) != 0) {
        goto label_38;
    }
    *(fp_stack--) = *((eax + 8));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = 1.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_38;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_2;
    }
label_38:
    al = (*((ebp + 0x18)) != 0) ? 1 : 0;
    eax = (int32_t) al;
    esi = *((ebp - 0x34));
    dl = (*((ebp - 0x48)) < esi) ? 1 : 0;
    edi = eax;
    edi &= edx;
    if (edi == 0) {
        *(fp_stack--) = 0.0;
        *((ebp - 0x50)) = fp_stack[0];
        fp_stack--;
    } else {
        edx = *((ebp - 0x60));
        *(fp_stack--) = *((edx + 8));
        *((ebp - 0x50)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = 1.0;
        *((edx + 8)) = fp_stack[0];
        fp_stack--;
        edx = *((ebp - 0x48));
        *((ebp - 0x34)) = edx;
    }
    ecx = *((ebp - 0x30));
    dl = (*((ebp - 0x44)) < ecx) ? 1 : 0;
    esi = eax;
    esi &= edx;
    if (esi == 0) {
        *(fp_stack--) = 0.0;
        *((ebp - 0x58)) = fp_stack[0];
        fp_stack--;
    } else {
        eax = *((ebp - 0x5c));
        *(fp_stack--) = *((eax + 8));
        *((ebp - 0x58)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = 1.0;
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x44));
        *((ebp - 0x30)) = eax;
    }
    edx = ebp - 0x1c;
    *((esp + 0x10)) = edx;
    eax = ebx;
    eax -= *((ebp - 0x30));
    *((esp + 0xc)) = eax;
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax += *((ebp - 0x38));
    *((esp + 8)) = eax;
    eax = *((ebp - 0x3c));
    eax -= *((ebp - 0x34));
    *((esp + 4)) = eax;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax += *((ebp - 0x38));
    *(esp) = eax;
    eax = se_compare ();
    if (edi != 0) {
        *(fp_stack--) = *((ebp - 0x50));
        ecx = *((ebp - 0x60));
        *((ecx + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x34)) += 2;
    }
    if (esi != 0) {
        *(fp_stack--) = *((ebp - 0x58));
        edx = *((ebp - 0x5c));
        *((edx + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x30)) += 2;
    }
    if (eax == 0) {
        goto label_39;
    }
    *(fp_stack--) = 1.0;
    *((ebp - 0x28)) = fp_stack[0];
    fp_stack--;
    edi = ebx;
    esi = *((ebp - 0x3c));
label_7:
    *((ebp - 0x60)) = 0;
    if (*((ebp - 0x6c)) == 4) {
        eax = scratch;
        edx = *((ebp - 0x8c));
        *((eax + 4)) = edx;
        eax = scratch;
        *(eax) = 0;
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = scratch;
        *((eax + 0x14)) = edx;
        eax = scratch;
        *((eax + 0x10)) = 2;
        eax = scratch;
        *((eax + 0x18)) = 4;
        *((ebp - 0x60)) = 2;
    }
    eax = esi;
    eax -= *((ebp - 0x34));
    *((ebp - 0x58)) = eax;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax += *((ebp - 0x38));
    *((ebp - 0x68)) = eax;
    edx = *((ebp - 0x60));
    edx <<= 4;
    *((ebp - 0x50)) = edx;
    eax = *((ebp - 0x58));
    eax <<= 4;
    ecx = *((ebp - 0x68));
    eax = edx;
    eax += *(obj.scratch);
    memmove (eax, ecx, eax);
    eax = *((ebp - 0x60));
    eax += *((ebp - 0x58));
    *((ebp - 0x5c)) = eax;
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x28));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_40;
        }
    }
    if (*((ebp - 0x60)) >= eax) {
        goto label_41;
    }
    eax = *((ebp - 0x60));
    edx = *((ebp - 0x50));
    do {
        ecx = *((ebp - 0x50));
        ecx += *(obj.scratch);
        *((ecx + 4)) += 2;
        eax++;
        edx += 0x10;
    } while (*((ebp - 0x5c)) > eax);
label_41:
    edx = *((ebp - 0x5c));
    edx <<= 4;
    ecx = *((ebp - 0x8c));
    ecx++;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 6;
    edx = *((ebp - 0x5c));
    edx++;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 0;
    *(fp_stack--) = *((ebp - 0x28));
    eax = scratch;
    *((eax + edx + 8)) = fp_stack[0];
    fp_stack--;
    *((ebp - 0x5c)) += 2;
    *(fp_stack--) = *((ebp - 0x28));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*((ebp - 0x5c)) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_42;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_43;
label_42:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_43:
    *(fp_stack--) = 0.0;
    fp_stack--;
    fp_stack++;
    eax = 0;
    if (fp_stack[0] != fp_stack[1]) {
        eax = *((ebp - 0x1c));
    }
    __asm ("cmovp eax, dword [ebp - 0x1c]");
    *((ebp - 0x1c)) = eax;
    goto label_44;
label_40:
    eax = *((ebp - 0x34));
    if (*((ebp - 0x48)) != eax) {
        goto label_44;
    }
    if (*((ebp - 0x70)) != esi) {
        goto label_44;
    }
    edx = *((ebp - 0x5c));
    if (*((ebp - 0x60)) >= edx) {
        goto label_44;
    }
    eax = *((ebp - 0x60));
    edx = *((ebp - 0x50));
    do {
        ecx = *((ebp - 0x50));
        ecx += *(obj.scratch);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (*((ebp - 0x5c)) > eax);
label_44:
    edx = *((ebp - 0x5c));
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x8c));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    eax = *((ebp - 0x5c));
    eax++;
    *((ebp - 0x60)) = eax;
    edx = *((ebp - 0x34));
    edx -= *((ebp - 0x48));
    *((ebp - 0x5c)) = edx;
    eax = edx;
    eax <<= 4;
    eax = *((ebp - 0x38));
    eax += *((ebp - 0xb8));
    eax = *((ebp - 0x60));
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x60));
    ecx += *((ebp - 0x5c));
    *((ebp - 0x5c)) = ecx;
    if (*((ebp - 0x3c)) == esi) {
        goto label_45;
    }
    ecx += *((ebp - 0x58));
    *((ebp - 0x58)) = ecx;
    esi = *((ebp - 0x3c));
    esi -= *((ebp - 0x34));
    eax = *((ebp - 0x5c));
    eax <<= 4;
    *((ebp - 0x50)) = eax;
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x68));
    eax = *((ebp - 0x50));
    eax += *(obj.scratch);
    memmove (eax, edx, eax);
    esi += *((ebp - 0x5c));
    ecx = *((ebp - 0x34));
    if (*((ebp - 0x48)) == ecx) {
        eax = *((ebp - 0x3c));
        if (*((ebp - 0x70)) != eax) {
            goto label_46;
        }
        if (*((ebp - 0x5c)) >= esi) {
            goto label_46;
        }
    }
label_46:
    ecx = *((ebp - 0x58));
    ecx++;
    if (esi <= ecx) {
        goto label_47;
    }
    edx = ecx;
    edx <<= 4;
    do {
        eax = edx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        ecx++;
        edx += 0x10;
    } while (esi > ecx);
label_47:
    edx = esi;
    edx <<= 4;
    ecx = *((ebp - 0x58));
    ecx <<= 4;
    *((ebp - 0x50)) = ecx;
    eax = scratch;
    eax = *((eax + ecx + 4));
    eax++;
    ecx = scratch;
    *((ecx + edx + 4)) = eax;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 2;
    edx = esi + 1;
    eax = scratch;
    edx <<= 4;
    ecx = *((ebp - 0x50));
    ecx = *((eax + ecx + 4));
    ecx++;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 0;
    *(fp_stack--) = *((ebp - 0x28));
    eax = scratch;
    *((eax + edx + 8)) = fp_stack[0];
    fp_stack--;
    edx = esi + 2;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x8c));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    esi += 3;
    *((ebp - 0x5c)) = esi;
label_45:
    edx = *((ebp - 0x5c));
    edx <<= 4;
    eax = scratch;
    esi = *((ebp - 0x8c));
    *((eax + edx + 4)) = esi;
    eax = scratch;
    *((eax + edx)) = 0;
    if (*((ebp - 0xac)) == 2) {
        eax = scratch;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    } else {
        eax = scratch;
        *(fp_stack--) = 1.0;
        *((edx + eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    esi = *((ebp - 0x5c));
    esi++;
    eax = *((ebp - 0x70));
    eax -= *((ebp - 0x3c));
    *((ebp - 0x34)) = eax;
    eax <<= 4;
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax += *((ebp - 0x38));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    esi += *((ebp - 0x34));
    if (*((ebp - 0x60)) >= esi) {
        goto label_48;
    }
    edx = *((ebp - 0x60));
    edx <<= 4;
    eax = *((ebp - 0x60));
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += 2;
        eax++;
        edx += 0x10;
    } while (esi > eax);
label_48:
    edx = esi;
    edx <<= 4;
    ecx = *((ebp - 0x8c));
    ecx++;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    al = (*((ebp - 0xb0)) == 2) ? 1 : 0;
    eax = (int32_t) al;
    eax ^= *((ebp - 0x1c));
    *((ebp - 0x1c)) = eax;
    if (eax == 0) {
        void (*0x8060363)() ();
    }
label_9:
    esi = *((ebp - 0x74));
    esi = ~esi;
    eax = ebx;
    eax -= *((ebp - 0x90));
    edx = *((ebp - 0x98));
    eax += *(edx);
    eax += esi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0xac)) == 2) {
        ecx = *((ebp - 0xc0));
        *((ecx + 8)) = 1;
    }
    edi = *((ebp - 0x98));
    eax = *(edi);
    eax -= *((ebp - 0x40));
    eax <<= 4;
    eax = *((ebp - 0x40));
    eax <<= 4;
    eax += *((ebp - 0x38));
    eax = *((ebp - 0x94));
    memmove (eax, eax, eax);
    eax = esi;
    eax += *(edi);
    *(edi) = eax;
    eax -= *((ebp - 0x70));
    eax <<= 4;
    eax = *((ebp - 0x70));
    eax <<= 4;
    eax += *((ebp - 0x38));
    eax = *((ebp - 0x48));
    eax = ebx + eax;
    eax <<= 4;
    eax += *((ebp - 0x38));
    memmove (eax, eax, eax);
    eax = ebx;
    eax -= *((ebp - 0x90));
    *(edi) += eax;
    ebx <<= 4;
    eax = scratch;
    eax = *((ebp - 0x38));
    eax += *((ebp - 0xb8));
    memmove (eax, eax, ebx);
    *((ebp - 0x9c)) = 1;
    goto label_3;
label_39:
    if (*((ebp + 0x18)) != 0) {
        goto label_21;
    }
    if (*((ebp - 0x68)) != 0) {
        goto label_2;
    }
    if (*((ebp - 0x75)) != 0) {
        goto label_2;
    }
    edx = *((ebp - 0x34));
    if (*((ebp - 0x48)) == edx) {
        edx = *((ebp - 0x64));
        ecx = *((ebp - 0x3c));
        if (*((ebp - 0x70)) == ecx) {
            goto label_49;
        }
    }
    edx = *((ebp - 0x7c));
label_49:
    esi = *((ebp - 0x34));
    esi++;
    if (*((ebp - 0x3c)) <= esi) {
        goto label_50;
    }
    eax = esi;
    eax <<= 4;
    edi = *((ebp - 0x38));
    eax = edi + eax + 4;
    edi = *((ebp - 0x3c));
label_4:
    ecx = esi;
    if (*(eax) != edx) {
        goto label_51;
    }
    if (*((eax + 4)) != 6) {
        goto label_51;
    }
    ecx <<= 4;
    edi = *((ebp - 0x38));
    eax = ecx + edi + 0x10;
    if (edx != *((eax + 4))) {
        goto label_52;
    }
    if (*(eax) != 0) {
        goto label_52;
    }
    *(fp_stack--) = *((eax + 8));
    *((ebp - 0x50)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x50));
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_2;
    }
    goto label_53;
label_51:
    esi += 2;
    eax += 0x20;
    if (edi > esi) {
        goto label_4;
    }
label_50:
    esi = *((ebp - 0x3c));
    *(fp_stack--) = 1.0;
    *((ebp - 0x50)) = fp_stack[0];
    fp_stack--;
    goto label_53;
label_52:
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((ebp - 0x50)) = fp_stack[0];
    fp_stack--;
label_53:
    eax = *((ebp - 0x30));
    if (*((ebp - 0x44)) == eax) {
        edx = *((ebp - 0x64));
        if (*((ebp - 0x40)) == ebx) {
            goto label_54;
        }
    }
    edx = *((ebp - 0x7c));
label_54:
    edi = *((ebp - 0x30));
    edi++;
    if (ebx <= edi) {
        goto label_55;
    }
    eax = edi;
    eax <<= 4;
    ecx = *((ebp - 0x38));
    eax = ecx + eax + 4;
label_5:
    if (*(eax) != edx) {
        goto label_56;
    }
    if (*((eax + 4)) != 6) {
        goto label_56;
    }
    eax = edi;
    eax <<= 4;
    ecx = *((ebp - 0x38));
    eax = eax + ecx + 0x10;
    if (edx != *((eax + 4))) {
        goto label_57;
    }
    if (*(eax) != 0) {
        goto label_57;
    }
    *(fp_stack--) = *((eax + 8));
    *((ebp - 0x58)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x58));
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_2;
    }
    goto label_58;
label_56:
    edi += 2;
    eax += 0x20;
    if (ebx > edi) {
        goto label_5;
    }
label_55:
    edi = ebx;
    *(fp_stack--) = 1.0;
    *((ebp - 0x58)) = fp_stack[0];
    fp_stack--;
    goto label_58;
label_57:
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((ebp - 0x58)) = fp_stack[0];
    fp_stack--;
label_58:
    if (*((ebp - 0x3c)) != esi) {
        goto label_59;
    }
    if (ebx == edi) {
        goto label_2;
    }
label_59:
    edx = esi;
    edx -= *((ebp - 0x34));
    if (edx != 1) {
        goto label_60;
    }
    eax = *((ebp - 0x34));
    eax <<= 4;
    ecx = *((ebp - 0x38));
    if (*((eax + ecx)) == 0) {
        goto label_2;
    }
label_60:
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x88));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_61;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_61;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x50));
    fp_tmp_5 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_5;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_6;
    }
    *(fp_stack--) = *((ebp - 0x58));
    fp_tmp_6 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_6;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_2;
    }
label_61:
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    eax = edi;
    eax -= *((ebp - 0x30));
    *((esp + 0xc)) = eax;
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax += *((ebp - 0x38));
    *((esp + 8)) = eax;
    *((esp + 4)) = edx;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax += *((ebp - 0x38));
    *(esp) = eax;
    eax = se_compare ();
    if (eax == 0) {
        goto label_2;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x50));
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x58));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_62;
        }
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x50));
    fp_tmp_7 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_7;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x58));
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        goto label_63;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x58));
    fp_tmp_8 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_8;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x50));
        *((ebp - 0x28)) = fp_stack[0];
        fp_stack--;
        goto label_63;
    }
    *(fp_stack--) = *((ebp - 0x58));
    *(fp_stack--) = *((ebp - 0x50));
    fp_tmp_9 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_9;
    __asm ("fcmovnbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x28)) = fp_stack[0];
    if (*((ebp - 0x1c)) != 0) {
        goto label_64;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*((ebp - 0x1c)) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_65;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = fmod ();
    goto label_66;
label_65:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_66:
    *(fp_stack--) = 0.0;
    fp_tmp_10 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_10;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_63;
        }
    }
    *(fp_stack--) = *((ebp - 0x50));
    *(fp_stack--) = *((ebp - 0x58));
    fp_tmp_11 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_11;
    __asm ("fcmovbe st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    fp_stack[0] -= *((ebp - 0x28));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_67;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_68;
label_67:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_68:
    *(fp_stack--) = 0.0;
    fp_tmp_12 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_12;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_63;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_7;
    }
    goto label_63;
label_64:
    fp_stack++;
label_63:
    *(fp_stack--) = *((ebp - 0x28));
    *(fp_stack--) = 1.0;
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_8;
    }
    eax = ebp - 0x28;
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (eax);
    fp_stack++;
    goto label_7;
label_62:
    eax = *((ebp - 0xac));
    *((ebp - 0x5c)) = eax;
    edx = *((ebp - 0x40));
    *((ebp - 0x68)) = edx;
    eax = *((ebp - 0x3c));
    eax -= esi;
    *((ebp - 0x2c)) = eax;
    *(fp_stack--) = *((ebp - 0x2c));
    eax = ebx;
    eax -= edi;
    *((ebp - 0x2c)) = eax;
    *(fp_stack--) = *((ebp - 0x2c));
    fp_tmp_13 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_13;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            fp_stack++;
            fp_stack++;
            eax = esi + 2;
            if (eax < *((ebp - 0x3c))) {
                *((ebp - 0x50)) = esi;
                edx = esi;
                edx <<= 4;
                ecx = *((ebp - 0x38));
                edx = edx + ecx + 0x10;
                eax = *((edx + 4));
                *((ebp - 0x60)) = eax;
                ecx = esi;
                ecx <<= 4;
                eax = *((ebp - 0x38));
                eax = *((ecx + eax + 4));
                *((ebp - 0x58)) = eax;
                eax++;
                if (*((ebp - 0x60)) == eax) {
                    ecx = esi;
                    ecx <<= 4;
                    eax = *((ebp - 0x38));
                    eax = ecx + eax + 0x20;
                    *((ebp - 0x50)) = eax;
                    ecx = *((ebp - 0x60));
                    if (ecx != *((eax + 4))) {
                        goto label_69;
                    }
                    if (*(edx) != 0) {
                        goto label_69;
                    }
                    eax = *((eax + 8));
                    eax -= 3;
                    if (eax > 1) {
                        goto label_69;
                    }
                    *(fp_stack--) = *((edx + 8));
                    fp_stack[0] = abs(fp_stack[0]);
                }
            } else {
label_69:
                *(fp_stack--) = 1.0;
            }
            eax = edi + 2;
            if (ebx > eax) {
                *((ebp - 0x50)) = edi;
                edx = edi;
                edx <<= 4;
                eax = *((ebp - 0x38));
                edx = edx + eax + 0x10;
                ecx = *((edx + 4));
                *((ebp - 0x60)) = ecx;
                eax = edi;
                eax <<= 4;
                ecx = *((ebp - 0x38));
                ecx = *((eax + ecx + 4));
                eax = *((eax + ecx + 4));
                eax++;
                if (*((ebp - 0x60)) == eax) {
                    eax = edi;
                    eax <<= 4;
                    ecx = *((ebp - 0x38));
                    ecx = eax + ecx + 0x20;
                    *((ebp - 0x50)) = ecx;
                    eax = *((ebp - 0x60));
                    if (eax != *((ecx + 4))) {
                        goto label_70;
                    }
                    if (*(edx) != 0) {
                        goto label_70;
                    }
                    eax = *((ecx + 8));
                    eax -= 3;
                    if (eax > 1) {
                        goto label_70;
                    }
                    *(fp_stack--) = *((edx + 8));
                    fp_stack[0] = abs(fp_stack[0]);
                }
label_70:
                *(fp_stack--) = 1.0;
                fp_tmp_14 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_14;
            } else {
            } else {
            } else {
                fp_tmp_15 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_15;
            }
        }
    }
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        edx = *((ebp - 0x68));
        *((esp + 0x30)) = edx;
        ecx = *((ebp - 0x70));
        *((esp + 0x2c)) = ecx;
        *((esp + 0x28)) = ebx;
        eax = *((ebp - 0x3c));
        *((esp + 0x24)) = eax;
        *((esp + 0x20)) = edi;
        *((esp + 0x1c)) = esi;
        edx = *((ebp - 0x30));
        *((esp + 0x18)) = edx;
        ecx = *((ebp - 0x34));
        *((esp + 0x14)) = ecx;
        esi = *((ebp - 0x44));
        *((esp + 0x10)) = esi;
        edi = *((ebp - 0x48));
        *((esp + 0xc)) = edi;
        eax = *((ebp - 0xb0));
        *((esp + 8)) = eax;
        edx = *((ebp - 0x5c));
        ecx = *((ebp - 0x6c));
        ecx = *((ebp - 0x1c));
        edx = *((ebp - 0x8c));
        eax = *((ebp - 0x38));
        eax = big_fplus (ecx, edx);
        ebx = eax;
        goto label_9;
    }
    eax = *((ebp - 0x70));
    *((esp + 0x30)) = eax;
    edx = *((ebp - 0x68));
    *((esp + 0x2c)) = edx;
    ecx = *((ebp - 0x3c));
    *((esp + 0x28)) = ecx;
    *((esp + 0x24)) = ebx;
    *((esp + 0x20)) = esi;
    *((esp + 0x1c)) = edi;
    esi = *((ebp - 0x34));
    *((esp + 0x18)) = esi;
    edi = *((ebp - 0x30));
    *((esp + 0x14)) = edi;
    eax = *((ebp - 0x48));
    *((esp + 0x10)) = eax;
    edx = *((ebp - 0x44));
    *((esp + 0xc)) = edx;
    ecx = *((ebp - 0x5c));
    *((esp + 8)) = ecx;
    esi = *((ebp - 0xb0));
    edi = *((ebp - 0x6c));
    ecx = *((ebp - 0x1c));
    edx = *((ebp - 0x8c));
    eax = *((ebp - 0x38));
    eax = big_fplus (edi, esi);
    ebx = eax;
    goto label_9;
label_21:
    edx = *((ebp - 0x74));
    eax = *((ebp - 0x44));
    eax = edx + eax + 1;
    *((ebp - 0x44)) = eax;
    edx = *((ebp - 0x98));
    ebx = *(edx);
    if (ebx > eax) {
        goto label_10;
    }
label_17:
    ecx = *((ebp - 0x90));
    ecx += *((ebp - 0xb4));
    *((ebp - 0x48)) = ecx;
    if (ecx >= ebx) {
        goto label_13;
    }
    eax = ecx;
    eax--;
    eax <<= 4;
    edi = *((ebp + 8));
    esi = *((ebp - 0x38));
    if (edi <= *((eax + esi + 4))) {
        goto label_3;
    }
label_13:
    ebx = *((ebp - 0xa4));
    if (*((ebp - 0x9c)) == 0) {
        goto label_71;
    }
    *((ebp - 0x9c)) = 1;
    goto label_72;
label_12:
    if (*((ebp + 8)) >= eax) {
        goto label_73;
    }
    eax = *((ebp + 0x1c));
    *((esp + 0x14)) = eax;
    edx = *((ebp + 0x18));
    *((esp + 0x10)) = edx;
    *(fp_stack--) = *((ebp - 0x88));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    *(esp) = esi;
    ecx = ebx;
    edx = edi;
    eax = *((ebp - 0x38));
    eax = fplus_recurse ();
    goto label_11;
    *((ebp - 0x9c)) |= eax;
    ebx++;
    edx = *(edi);
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp - 0x38));
    eax = ecx + eax + 4;
    while (*((ebp + 8)) < ecx) {
        ebx += 2;
        if (ebx >= edx) {
            goto label_74;
        }
        ecx = *(eax);
        eax += 0x20;
    }
    goto label_74;
label_73:
    ebx++;
    goto label_74;
label_14:
    ebx = *((ebp - 0xa4));
    *((ebp - 0x9c)) = 0;
label_71:
    esi = *((ebp + 8));
    esi++;
    edi = *((ebp - 0x98));
label_74:
    if (ebx >= *(edi)) {
        goto label_72;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x38));
    eax = *((eax + edx + 4));
    if (*((ebp + 8)) <= eax) {
        goto label_12;
    }
label_72:
    eax = *((ebp - 0x9c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8060cd0 */
#include <stdint.h>
 
int32_t dbg_sf_recurse (int32_t np2, int32_t e2, int32_t loc, int32_t len, int32_t op, int32_t div_flag2) {
    int32_t var_84h;
    token_type * p1;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_74h;
    void * var_70h;
    int32_t op2;
    int32_t var_68h;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t b1;
    int32_t var_50h;
    int32_t len1;
    void * var_48h;
    int32_t b2;
    uint32_t var_40h;
    int32_t div_flag1;
    int32_t var_38h;
    void * var_34h;
    int32_t var_30h;
    int32_t len2;
    int32_t modified;
    int32_t var_24h;
    void * var_20h;
    void * var_1ch;
    int32_t level;
    int32_t start_flag;
    size_t * s2;
    size_t * n;
    int32_t var_ch;
    int32_t var_10h;
    ebx = np2;
    ecx = e2;
    edx = loc;
    esi = len;
    edi = op;
    eax = div_flag2;
    /* int sf_recurse(token_type * equation,int * np,int loc,int level,int start_flag); */
label_0:
    *((ebp - 0x20)) = eax;
    *((ebp - 0x30)) = edx;
    *((ebp - 0x40)) = ecx;
    if (*((ebp + 0xc)) != 0) {
        goto label_9;
    }
    edx = ecx;
    edx++;
    eax = *((ebp - 0x30));
    esi = *(eax);
    if (edx >= esi) {
        goto label_9;
    }
    ebx = edx;
    ebx <<= 4;
    ebx += *((ebp - 0x20));
    ecx = *((ebx + 4));
    if (*((ebp + 8)) > ecx) {
        goto label_9;
    }
    eax = *((ebp - 0x40));
    eax <<= 4;
    edi = *((ebp - 0x20));
    eax = eax + edi + 0x30;
    edi = *((ebp + 8));
    do {
        if (ecx == edi) {
            if (*((ebx + 8)) == 4) {
                *((ebp + 0xc)) = 1;
            }
        } else {
            edx += 2;
            if (edx >= esi) {
                goto label_9;
            }
            ebx = eax;
            ecx = *((eax + 4));
            eax += 0x20;
        }
    } while (ecx >= edi);
label_9:
    ebx = *((ebp - 0x40));
    edi = 0;
    *((ebp - 0x28)) = 0;
    esi = *((ebp + 8));
    esi++;
    *((ebp - 0x1c)) = edi;
    edi = *((ebp - 0x30));
    *((ebp - 0x24)) = esi;
    esi = *((ebp + 8));
    goto label_10;
label_1:
    if (esi >= eax) {
        goto label_11;
    }
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x24));
    *(esp) = edx;
    ecx = ebx;
    edx = edi;
    eax = *((ebp - 0x20));
    eax = sf_recurse ();
    goto label_0;
    *((ebp - 0x28)) |= eax;
    eax = ebx + 1;
    ecx = *(edi);
    *((ebp - 0x34)) = ecx;
    if (eax >= ecx) {
        goto label_12;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x20));
    if (esi >= *((edx + ecx + 4))) {
        goto label_12;
    }
    edx = ebx;
    edx <<= 4;
    edx = ecx + edx + 0x34;
    ecx = *((ebp - 0x34));
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_12;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    goto label_12;
label_11:
    if (*(edx) == 2) {
        edx = *((edx + 8));
        *((ebp - 0x1c)) = edx;
    }
    eax = ebx + 1;
label_12:
    ebx = eax;
label_10:
    if (ebx >= *(edi)) {
        goto label_13;
    }
    edx = ebx;
    edx <<= 4;
    edx += *((ebp - 0x20));
    eax = *((edx + 4));
    if (esi <= eax) {
        goto label_1;
    }
label_13:
    edi = *((ebp - 0x1c));
    if (*((ebp - 0x28)) != 0) {
        goto label_14;
    }
    if (*((ebp + 0xc)) == 0) {
        goto label_14;
    }
    edi--;
    if (edi > 1) {
        goto label_14;
    }
    ebx = *((ebp - 0x40));
    ebx++;
    *((ebp - 0x38)) = ebx;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x20));
    *((ebp - 0x74)) = eax;
    esi = *((ebp - 0x40));
    esi <<= 4;
    *((ebp - 0x84)) = esi;
    edi = *((ebp - 0x20));
    edi += esi;
    *((ebp - 0x70)) = edi;
    edx = *((ebp - 0x20));
    eax = edx + esi + 0x34;
    *((ebp - 0x78)) = eax;
    edi = *((ebp + 8));
    edi++;
label_2:
    ebx = *((ebp - 0x30));
    ecx = *(ebx);
    if (*((ebp - 0x38)) >= ecx) {
        goto label_15;
    }
    eax = *((ebp + 8));
    esi = *((ebp - 0x74));
    if (eax >= *((esi + 4))) {
        goto label_15;
    }
    edx = *((ebp - 0x78));
    eax = *((ebp - 0x38));
    esi = *((ebp + 8));
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_16;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    goto label_16;
label_15:
    eax = *((ebp - 0x38));
label_16:
    eax -= *((ebp - 0x40));
    *((ebp - 0x4c)) = eax;
    eax += *((ebp - 0x40));
    *((ebp - 0x24)) = eax;
    eax++;
    *((ebp - 0x1c)) = eax;
    if (eax >= ecx) {
        goto label_14;
    }
    *((ebp - 0x68)) = eax;
    eax <<= 4;
    edx = *((ebp - 0x20));
    eax = eax + edx - 0x10;
    *((ebp - 0x48)) = eax;
    ebx = *((ebp + 8));
    if (ebx > *((eax + 4))) {
        goto label_14;
    }
    eax = *((ebp - 0x38));
    eax <<= 4;
    eax = edx + eax + 4;
    *((ebp - 0x34)) = eax;
label_4:
    ebx = *((ebp - 0x1c));
    ebx++;
    if (ebx >= ecx) {
        goto label_17;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp + 8));
    esi = *((ebp - 0x20));
    if (edx >= *((eax + esi + 4))) {
        goto label_17;
    }
    eax = *((ebp - 0x1c));
    eax <<= 4;
    edx = esi + eax + 0x34;
    eax = ebx;
    *((ebp - 0x2c)) = ebx;
    esi = *((ebp + 8));
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_18;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    ebx = *((ebp - 0x2c));
    goto label_19;
label_17:
    eax = ebx;
    goto label_19;
label_18:
    ebx = *((ebp - 0x2c));
label_19:
    eax -= *((ebp - 0x1c));
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x50)) = edi;
    edx = eax;
    edx += *((ebp - 0x1c));
    ecx = *((ebp - 0x48));
    ecx = *((ecx + 8));
    *((ebp - 0x6c)) = ecx;
    esi = *((ebp - 0x24));
    if (*((ebp - 0x38)) >= esi) {
        goto label_20;
    }
    eax = *((ebp - 0x34));
    ecx = *((ebp - 0x38));
    esi = *((ebp - 0x38));
    ecx = *((ebp - 0x24));
    do {
        if (edi == *(eax)) {
            if (*((eax + 4)) == 4) {
                goto label_21;
            }
        }
        esi += 2;
        eax += 0x20;
    } while (ecx > esi);
    goto label_22;
label_21:
    *((ebp - 0x44)) = esi;
    esi++;
    *((ebp - 0x54)) = esi;
    esi = *((ebp - 0x44));
    esi += 2;
    if (*((ebp - 0x24)) <= esi) {
        goto label_23;
    }
    eax = esi;
    eax <<= 4;
    ecx = *((ebp - 0x20));
    if (edi >= *((eax + ecx + 4))) {
        goto label_23;
    }
    eax = *((ebp - 0x44));
    eax <<= 4;
    eax = ecx + eax + 0x44;
    *((ebp - 0x44)) = ebx;
    ebx = *((ebp - 0x24));
    while (ebx > esi) {
        ecx = *(eax);
        eax += 0x20;
        if (edi >= ecx) {
            goto label_24;
        }
        esi += 2;
    }
    ebx = *((ebp - 0x44));
    goto label_23;
label_24:
    ebx = *((ebp - 0x44));
label_23:
    *((ebp - 0x3c)) = 1;
label_5:
    if (ebx >= edx) {
        goto label_25;
    }
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp - 0x20));
    eax = ecx + eax + 4;
    *((ebp - 0x60)) = ebx;
    do {
        if (edi == *(eax)) {
            if (*((eax + 4)) == 4) {
                goto label_26;
            }
        }
        ebx += 2;
        eax += 0x20;
    } while (edx > ebx);
    goto label_25;
label_26:
    *((ebp - 0x60)) = ebx;
    ebx++;
    *((ebp - 0x44)) = ebx;
    ebx = *((ebp - 0x60));
    ebx += 2;
    if (edx <= ebx) {
        goto label_27;
    }
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp - 0x20));
    if (edi >= *((eax + ecx + 4))) {
        goto label_27;
    }
    eax = *((ebp - 0x60));
    eax <<= 4;
    eax = ecx + eax + 0x44;
    while (edx > ebx) {
        ecx = *(eax);
        eax += 0x20;
        if (edi >= ecx) {
            goto label_27;
        }
        ebx += 2;
    }
label_27:
    eax = 1;
label_6:
    if (eax == 0) {
        if (*((ebp - 0x3c)) == 0) {
            goto label_28;
        }
    }
    *((ebp - 0x58)) = edx;
    *((ebp - 0x28)) = eax;
    eax = *((ebp - 0x1c));
    *((ebp - 0x64)) = eax;
    edx = *((ebp - 0x3c));
    *((ebp - 0x34)) = dl;
    if (*((ebp + 0xc)) == 2) {
        if (dl == 0) {
            goto label_29;
        }
        if (*((ebp - 0x28)) == 0) {
            goto label_29;
        }
        ecx = ebx;
        ecx -= *((ebp - 0x44));
        *((ebp - 0x7c)) = ecx;
        eax = *((ebp - 0x44));
        eax <<= 4;
        eax += *((ebp - 0x20));
        *((ebp - 0x80)) = eax;
        eax = esi;
        eax -= *((ebp - 0x54));
        *((ebp - 0x5c)) = eax;
        eax = *((ebp - 0x54));
        eax <<= 4;
        eax += *((ebp - 0x20));
        *((ebp - 0x60)) = eax;
        *((esp + 0x10)) = 0;
        *((esp + 0xc)) = ecx;
        edx = *((ebp - 0x80));
        *((esp + 8)) = edx;
        ecx = *((ebp - 0x5c));
        *((esp + 4)) = ecx;
        *(esp) = eax;
        eax = poly2_gcd ();
        if (eax != 0) {
            eax = tlhs;
            *((ebp - 0x80)) = eax;
            edx = n_tlhs;
            *((ebp - 0x28)) = edx;
            ecx = trhs;
            *((ebp - 0x3c)) = ecx;
            eax = n_trhs;
            *((ebp - 0x1c)) = eax;
            goto label_30;
        }
        *((esp + 0x10)) = 0;
        edx = *((ebp - 0x5c));
        *((esp + 0xc)) = edx;
        ecx = *((ebp - 0x60));
        *((esp + 8)) = ecx;
        eax = *((ebp - 0x7c));
        *((esp + 4)) = eax;
        edx = *((ebp - 0x80));
        *(esp) = edx;
        eax = poly2_gcd ();
        if (eax == 0) {
            goto label_29;
        }
        ecx = trhs;
        *((ebp - 0x80)) = ecx;
        eax = n_trhs;
        *((ebp - 0x28)) = eax;
        edx = tlhs;
        *((ebp - 0x3c)) = edx;
        ecx = n_tlhs;
        *((ebp - 0x1c)) = ecx;
        goto label_30;
    }
label_29:
    eax = esi;
    eax -= *((ebp - 0x54));
    *((ebp - 0x60)) = eax;
    edx = ebx;
    edx -= *((ebp - 0x44));
    *((ebp - 0x5c)) = edx;
    edx = *((ebp - 0x2c));
    ecx = *((ebp - 0x4c));
    eax = edx + ecx + 8;
    eax += *((ebp - 0x60));
    eax += *((ebp - 0x5c));
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0x3c)) != 0) {
        goto label_31;
    }
    ecx = *((ebp - 0x24));
    if (*((ebp - 0x40)) >= ecx) {
        goto label_31;
    }
    ecx = *((ebp - 0x84));
    edx = *((ebp - 0x20));
    eax = ecx + edx + 4;
    edx = *((ebp - 0x40));
    ecx = *((ebp - 0x24));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (ecx > edx);
label_31:
    if (*((ebp - 0x28)) != 0) {
        goto label_32;
    }
    eax = *((ebp - 0x58));
    if (*((ebp - 0x64)) >= eax) {
        goto label_32;
    }
    eax = *((ebp - 0x64));
    eax <<= 4;
    edx = *((ebp - 0x20));
    eax = edx + eax + 4;
    edx = *((ebp - 0x1c));
    ecx = *((ebp - 0x58));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (edx < ecx);
label_32:
    eax = *((ebp - 0x40));
    eax = ~eax;
    eax += *((ebp - 0x54));
    *((ebp - 0x1c)) = eax;
    eax <<= 4;
    *((ebp - 0x3c)) = eax;
    ecx = *((ebp - 0x70));
    eax = scratch;
    memmove (eax, ecx, eax);
    if (*((ebp - 0x34)) != 0) {
        eax = *((ebp - 0x24));
        eax -= esi;
        *((ebp - 0x7c)) = eax;
        eax <<= 4;
        eax = esi;
        eax <<= 4;
        eax += *((ebp - 0x20));
        eax = *((ebp - 0x3c));
        eax += *(obj.scratch);
        memmove (eax, eax, eax);
        edx = *((ebp - 0x7c));
        *((ebp - 0x1c)) += edx;
    }
    if (*((ebp - 0x28)) != 0) {
        edx = *((ebp - 0x1c));
        edx <<= 4;
        eax = scratch;
        ecx = *((ebp - 0x50));
        *((eax + edx + 4)) = ecx;
        eax = scratch;
        *((eax + edx)) = 2;
        eax = scratch;
        *((eax + edx + 8)) = 3;
        esi = *((ebp - 0x1c));
        esi++;
        eax = *((ebp - 0x5c));
        eax <<= 4;
        eax = *((ebp - 0x44));
        eax <<= 4;
        eax += *((ebp - 0x20));
        eax = esi;
        eax <<= 4;
        eax += *(obj.scratch);
        memmove (eax, eax, eax);
        esi += *((ebp - 0x5c));
        *((ebp - 0x1c)) = esi;
    }
    if (*((ebp - 0x1c)) <= 0) {
        goto label_33;
    }
    eax = 0;
    ecx = *((ebp - 0x1c));
    do {
        edx = eax;
        edx <<= 4;
        edx += *(obj.scratch);
        *((edx + 4)) += 2;
        eax++;
    } while (eax != ecx);
label_33:
    edx = *((ebp - 0x1c));
    edx <<= 4;
    ecx = *((ebp - 0x50));
    ecx++;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    esi = *((ebp - 0x6c));
    *((eax + edx + 8)) = esi;
    esi = *((ebp - 0x1c));
    esi++;
    eax = *((ebp - 0x44));
    eax--;
    eax -= *((ebp - 0x64));
    *((ebp - 0x1c)) = eax;
    eax <<= 4;
    eax = *((ebp - 0x68));
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    eax = *((ebp - 0x1c));
    eax += esi;
    *((ebp - 0x1c)) = eax;
    if (*((ebp - 0x28)) != 0) {
        edx = *((ebp - 0x58));
        edx -= ebx;
        *((ebp - 0x3c)) = edx;
        eax = edx;
        eax <<= 4;
        eax = ebx;
        eax <<= 4;
        eax += *((ebp - 0x20));
        eax = *((ebp - 0x1c));
        eax <<= 4;
        eax += *(obj.scratch);
        memmove (eax, eax, eax);
        ecx = *((ebp - 0x3c));
        *((ebp - 0x1c)) += ecx;
    }
    if (*((ebp - 0x34)) != 0) {
        edx = *((ebp - 0x1c));
        edx <<= 4;
        eax = scratch;
        ebx = *((ebp - 0x50));
        *((eax + edx + 4)) = ebx;
        eax = scratch;
        *((eax + edx)) = 2;
        eax = scratch;
        *((eax + edx + 8)) = 3;
        ebx = *((ebp - 0x1c));
        ebx++;
        eax = *((ebp - 0x60));
        eax <<= 4;
        eax = *((ebp - 0x54));
        eax <<= 4;
        eax += *((ebp - 0x20));
        eax = ebx;
        eax <<= 4;
        eax += *(obj.scratch);
        memmove (eax, eax, eax);
        ebx += *((ebp - 0x60));
        *((ebp - 0x1c)) = ebx;
    }
    if (esi >= *((ebp - 0x1c))) {
        goto label_34;
    }
    eax = esi;
    eax <<= 4;
    ecx = *((ebp - 0x1c));
    do {
        edx = eax;
        edx += *(obj.scratch);
        *((edx + 4)) += 2;
        esi++;
        eax += 0x10;
    } while (esi < ecx);
label_34:
    edx = *((ebp - 0x1c));
    edx <<= 4;
    eax = scratch;
    esi = *((ebp - 0x50));
    *((eax + edx + 4)) = esi;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 4;
    ebx = *((ebp - 0x1c));
    ebx++;
    if (*((ebp - 0x34)) == 0) {
        goto label_35;
    }
    eax = *((ebp - 0x60));
    eax <<= 4;
    eax = *((ebp - 0x54));
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    esi = *((ebp - 0x60));
    esi = ebx + esi;
    if (*((ebp - 0x28)) != 0) {
        edx = esi;
        edx <<= 4;
        eax = scratch;
        ecx = *((ebp - 0x50));
        *((eax + edx + 4)) = ecx;
        eax = scratch;
        *((eax + edx)) = 2;
        eax = scratch;
        *((eax + edx + 8)) = 3;
        esi++;
label_8:
        eax = *((ebp - 0x5c));
        eax <<= 4;
        eax = *((ebp - 0x44));
        eax <<= 4;
        eax += *((ebp - 0x20));
        eax = esi;
        eax <<= 4;
        eax += *(obj.scratch);
        memmove (eax, eax, eax);
        esi += *((ebp - 0x5c));
    }
label_7:
    if (ebx >= esi) {
        goto label_3;
    }
    eax = ebx;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.scratch);
        *((edx + 4))++;
        ebx++;
        eax += 0x10;
    } while (ebx < esi);
label_3:
    ebx = *((ebp - 0x2c));
    ebx = ~ebx;
    eax = ebx;
    eax -= *((ebp - 0x4c));
    edx = *((ebp - 0x30));
    eax += *(edx);
    eax += esi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp - 0x30));
    eax = *(ecx);
    eax -= *((ebp - 0x58));
    eax <<= 4;
    eax = *((ebp - 0x58));
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = *((ebp - 0x48));
    memmove (eax, eax, eax);
    edx = *((ebp - 0x30));
    ebx += *(edx);
    *(edx) = ebx;
    ebx -= *((ebp - 0x24));
    ebx <<= 4;
    eax = *((ebp - 0x24));
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = *((ebp - 0x40));
    eax = esi + eax;
    eax <<= 4;
    eax += *((ebp - 0x20));
    memmove (eax, eax, ebx);
    eax = esi;
    eax -= *((ebp - 0x4c));
    ecx = *((ebp - 0x30));
    *(ecx) += eax;
    esi <<= 4;
    eax = scratch;
    ebx = *((ebp - 0x70));
    memmove (ebx, eax, esi);
    *((ebp - 0x28)) = 1;
    goto label_2;
label_30:
    eax = *((ebp - 0x24));
    eax -= *((ebp - 0x40));
    edx = *((ebp - 0x44));
    eax = edx + eax + 5;
    eax += *((ebp - 0x58));
    eax -= *((ebp - 0x64));
    eax -= ebx;
    eax += *((ebp - 0x28));
    ecx = *((ebp - 0x1c));
    eax = eax + ecx*2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0x28)) <= 0) {
        goto label_36;
    }
    eax = *((ebp - 0x80));
    edx = 0;
    *((ebp - 0x34)) = ebx;
    ecx = *((ebp - 0x50));
    ebx = *((ebp - 0x28));
    do {
        *((eax + 4)) += ecx;
        edx++;
        eax += 0x10;
    } while (edx != ebx);
    ebx = *((ebp - 0x34));
label_36:
    if (*((ebp - 0x1c)) <= 0) {
        goto label_37;
    }
    eax = *((ebp - 0x3c));
    edx = 0;
    *((ebp - 0x34)) = ebx;
    ecx = *((ebp - 0x50));
    ebx = *((ebp - 0x1c));
    do {
        *((eax + 4)) += ecx;
        edx++;
        eax += 0x10;
    } while (edx != ebx);
    ebx = *((ebp - 0x34));
label_37:
    eax = *((ebp - 0x40));
    eax = ~eax;
    eax += *((ebp - 0x54));
    *((ebp - 0x7c)) = eax;
    eax <<= 4;
    *((ebp - 0x34)) = eax;
    eax = *((ebp - 0x70));
    eax = scratch;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x24));
    edx -= esi;
    *((ebp - 0x54)) = edx;
    eax = edx;
    eax <<= 4;
    eax = esi;
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = *((ebp - 0x34));
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x54));
    ecx += *((ebp - 0x7c));
    edx = ecx;
    edx <<= 4;
    eax = scratch;
    esi = *((ebp - 0x50));
    *((eax + edx + 4)) = esi;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    esi = ecx + 1;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    *((ebp - 0x34)) = eax;
    edx = *((ebp - 0x3c));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, edx, eax);
    esi += *((ebp - 0x1c));
    if (esi <= 0) {
        goto label_38;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.scratch);
        *((edx + 4)) += 2;
        eax++;
    } while (eax != esi);
label_38:
    edx = esi;
    edx <<= 4;
    ecx = *((ebp - 0x50));
    ecx++;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    ecx = *((ebp - 0x6c));
    *((eax + edx + 8)) = ecx;
    esi++;
    eax = *((ebp - 0x44));
    eax--;
    eax -= *((ebp - 0x64));
    *((ebp - 0x44)) = eax;
    eax <<= 4;
    eax = *((ebp - 0x68));
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    eax = *((ebp - 0x44));
    eax += esi;
    *((ebp - 0x54)) = eax;
    edx = *((ebp - 0x58));
    edx -= ebx;
    *((ebp - 0x44)) = edx;
    eax = edx;
    eax <<= 4;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x20));
    eax = *((ebp - 0x54));
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x54));
    ecx += *((ebp - 0x44));
    edx = ecx;
    edx <<= 4;
    eax = scratch;
    ebx = *((ebp - 0x50));
    *((eax + edx + 4)) = ebx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    ebx = ecx + 1;
    eax = *((ebp - 0x28));
    eax <<= 4;
    eax = *((ebp - 0x80));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ebx += *((ebp - 0x28));
    if (esi >= ebx) {
        goto label_39;
    }
    eax = esi;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.scratch);
        *((edx + 4)) += 2;
        esi++;
        eax += 0x10;
    } while (ebx > esi);
label_39:
    edx = ebx;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x50));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 4;
    ebx++;
    eax = *((ebp - 0x5c));
    eax <<= 4;
    esi = *((ebp - 0x60));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, esi, eax);
    ecx = *((ebp - 0x5c));
    ecx = ebx + ecx;
    edx = ecx;
    edx <<= 4;
    eax = scratch;
    esi = *((ebp - 0x50));
    *((eax + edx + 4)) = esi;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    esi = ecx + 1;
    eax = *((ebp - 0x34));
    edx = *((ebp - 0x3c));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, edx, eax);
    esi += *((ebp - 0x1c));
    if (ebx >= esi) {
        goto label_3;
    }
    eax = ebx;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.scratch);
        *((edx + 4))++;
        ebx++;
        eax += 0x10;
    } while (esi > ebx);
    goto label_3;
label_28:
    ebx = *((ebp - 0x1c));
    ecx = *((ebp - 0x2c));
    ebx = ebx + ecx + 1;
    *((ebp - 0x1c)) = ebx;
    esi = *((ebp - 0x30));
    ecx = *(esi);
    if (ecx <= ebx) {
        goto label_14;
    }
    *((ebp - 0x68)) = ebx;
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x20));
    eax = eax + edx - 0x10;
    *((ebp - 0x48)) = eax;
    ebx = *((ebp + 8));
    if (ebx <= *((eax + 4))) {
        goto label_4;
    }
label_14:
    eax = *((ebp - 0x28));
    return eax;
label_20:
    esi = *((ebp - 0x38));
label_22:
    eax = esi + 1;
    *((ebp - 0x54)) = eax;
    *((ebp - 0x3c)) = 0;
    goto label_5;
label_25:
    ecx = ebx + 1;
    *((ebp - 0x44)) = ecx;
    eax = 0;
    goto label_6;
label_35:
    if (*((ebp - 0x28)) == 0) {
        esi = ebx;
        goto label_7;
    }
    esi = ebx;
    goto label_8;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80618f5 */
#include <stdint.h>
 
uint32_t dbg_group_recurse (int32_t arg_8h, int32_t level, int32_t len, int32_t loc, int32_t edi, int * np, int32_t group_flag) {
    int32_t var_30h;
    void * var_2ch;
    int32_t var_28h;
    int32_t di;
    uint32_t var_20h;
    void * s1;
    void * s2;
    size_t * n;
    ebx = level;
    ecx = len;
    edx = loc;
    esi = edi;
    edi = np;
    eax = group_flag;
    do {
        /* void group_recurse(token_type * equation,int * np,int loc,int level); */
        *((ebp - 0x1c)) = eax;
        edi = edx;
        *((ebp - 0x24)) = ecx;
        ebx = *((ebp + 8));
        esi = ecx;
        eax = ebx + 1;
        *((ebp - 0x20)) = eax;
        goto label_2;
label_0:
        if (eax <= ebx) {
            goto label_3;
        }
        edx = *((ebp - 0x20));
        ecx = esi;
        edx = edi;
        eax = *((ebp - 0x1c));
        group_recurse (edx);
    } while (1);
    eax = esi + 1;
    ecx = edi;
    *((ebp - 0x2c)) = ecx;
    if (eax >= ecx) {
        goto label_4;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x1c));
    if (ebx >= *((edx + ecx + 4))) {
        goto label_4;
    }
    edx = esi;
    edx <<= 4;
    edx = ecx + edx + 0x34;
    ecx = *((ebp - 0x2c));
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_4;
        }
        esi = *(edx);
        edx += 0x20;
    } while (ebx < esi);
    goto label_4;
label_3:
    eax = esi + 1;
label_4:
    esi = eax;
label_2:
    if (esi >= edi) {
        goto label_5;
    }
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x1c));
    eax = *((eax + edx + 4));
    if (eax >= ebx) {
        goto label_0;
    }
label_5:
    *((ebp - 0x28)) = esi;
    edi = *((ebp - 0x24));
    edi++;
    if (edi >= esi) {
        goto label_6;
    }
    eax = 0;
    *((ebp - 0x24)) = 0xffffffff;
    *((ebp - 0x20)) = esi;
label_1:
    ecx = edi;
    ecx <<= 4;
    ecx += *((ebp - 0x1c));
    if (*((ecx + 4)) != ebx) {
        goto label_7;
    }
    if (*((ecx + 8)) != 4) {
        goto label_8;
    }
    if (*((ebp - 0x24)) < 0) {
        *((ebp - 0x24)) = edi;
        goto label_7;
    }
    eax = edi + 2;
    *((ebp - 0x2c)) = eax;
    if (eax >= esi) {
        goto label_9;
    }
    eax <<= 4;
    edx = *((ebp - 0x1c));
    edx = edx + eax + 4;
    eax = edx;
    edx = *((ebp - 0x2c));
    do {
        if (*(eax) == ebx) {
            if (*((eax + 4)) != 4) {
                goto label_10;
            }
        }
        edx += 2;
        eax += 0x20;
    } while (edx < esi);
    *((ebp - 0x2c)) = edx;
    goto label_9;
label_10:
    *((ebp - 0x2c)) = edx;
label_9:
    eax = *((ebp - 0x2c));
    eax -= edi;
    *((ebp - 0x28)) = eax;
    if (esi == *((ebp - 0x20))) {
        edi += eax;
        *((ebp - 0x20)) = edi;
        eax = 1;
    } else {
        edx = *((ebp - 0x28));
        edx <<= 4;
        *((ebp - 0x30)) = edx;
        eax = scratch;
        memmove (eax, ecx, edx);
        eax = *((ebp - 0x24));
        eax <<= 4;
        eax += *((ebp - 0x1c));
        *((ebp - 0x2c)) = eax;
        eax = edi;
        eax -= *((ebp - 0x24));
        eax <<= 4;
        ecx = *((ebp - 0x2c));
        eax = *((ebp - 0x28));
        eax += *((ebp - 0x24));
        eax <<= 4;
        eax += *((ebp - 0x1c));
        memmove (eax, ecx, eax);
        eax = *((ebp - 0x30));
        eax = scratch;
        edx = *((ebp - 0x2c));
        memmove (edx, eax, eax);
        ecx = *((ebp - 0x28));
        *((ebp - 0x20)) += ecx;
        edi = ecx + edi - 2;
        eax = 1;
        goto label_7;
label_8:
        if (*((ebp - 0x24)) < 0) {
            goto label_7;
        }
        edx = *((ebp - 0x20));
        if (esi == *((ebp - 0x20))) {
            edx = edi;
        }
        *((ebp - 0x20)) = edx;
    }
label_7:
    edi += 2;
    if (edi < esi) {
        goto label_1;
    }
    esi = *((ebp - 0x20));
    if (eax == 0) {
        goto label_6;
    }
    edx = *((ebp - 0x24));
    edx++;
    if (esi <= edx) {
        goto label_6;
    }
    eax = edx;
    eax <<= 4;
    ecx = *((ebp - 0x1c));
    eax = ecx + eax + 4;
    do {
        if (*(eax) == ebx) {
            if (*((eax - 4)) != 2) {
                goto label_11;
            }
            *((eax + 4)) = 3;
        }
label_11:
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (esi > edx);
label_6:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8063070 */
#include <stdint.h>
 
int32_t dbg_vcmp (void) {
    sort_type * p1;
    sort_type * p2;
    /* int vcmp(sort_type * p1,sort_type * p2); */
    eax = *((ebp + 0xc));
    eax = *((eax + 4));
    edx = *((ebp + 8));
    eax -= *((edx + 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806425f */
#include <stdint.h>
 
int32_t dbg_save_factors (void * arg_ch, int32_t level, int32_t i, int32_t j, token_type * equation) {
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t len;
    void * s2;
    size_t n;
    ebx = level;
    ecx = i;
    edx = j;
    edi = equation;
    /* void save_factors(token_type * equation,int * np,int loc1,int len,int level); */
    edi = eax;
    esi = edx;
    *((ebp - 0x1c)) = ecx;
    ebx = *((ebp + 0xc));
    eax = n_tlhs;
    eax += *(obj.n_trhs);
    eax++;
    *((ebp - 0x20)) = eax;
    eax -= *((ebp + 8));
    *((ebp - 0x24)) = eax;
    eax += *(edx);
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp + 8));
    eax += *((ebp - 0x1c));
    edx = *(esi);
    edx -= eax;
    edx <<= 4;
    eax <<= 4;
    eax = edi + eax;
    eax = *((ebp - 0x1c));
    eax += *((ebp - 0x20));
    eax <<= 4;
    eax = edi + eax;
    memmove (eax, eax, edx);
    eax = *((ebp - 0x24));
    *(esi) += eax;
    esi = *((ebp - 0x1c));
    esi <<= 4;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    eax = edi + esi;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x1c));
    edx += *(obj.n_tlhs);
    eax = edx;
    eax <<= 4;
    eax = edi + eax;
    *((eax + 4)) = 0;
    *(eax) = 2;
    *((eax + 8)) = 3;
    edx++;
    *((ebp - 0x20)) = edx;
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = edx;
    eax <<= 4;
    eax = edi + eax;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x20));
    edx += *(obj.n_trhs);
    if (*((ebp - 0x1c)) >= edx) {
        goto label_0;
    }
    eax = esi + edi + 4;
    ecx = *((ebp - 0x1c));
    do {
        *(eax) += ebx;
        ecx++;
        eax += 0x10;
    } while (edx > ecx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8064d0f */
#include <stdint.h>
 
int32_t dbg_find_highest_count (size_t * arg_ch, int32_t arg_10h, int32_t arg_14h, long int * vp1, long int v1, int32_t vc, int32_t i, int32_t count2) {
    int32_t var_1f98h;
    int32_t var_1f94h;
    int32_t count1;
    long int last_v;
    sort_type[1000] va;
    int32_t var_1f7ch;
    double d2;
    double d1;
    int32_t len_t2;
    int32_t t2;
    int32_t len_t1;
    int32_t t1;
    int32_t divide_flag;
    size_t nmemb;
    size_t size;
    int32_t const void *);
    ebx = vp1;
    edx = v1;
    esi = vc;
    edi = i;
    eax = count2;
    /* int find_highest_count(token_type * p1,int n1,token_type * p2,int n2,long int * vp1); */
    *((ebp - 0x1f94)) = eax;
    ebx = edx;
    *((ebp - 0x1f98)) = ecx;
    if (edx <= 0) {
        goto label_2;
    }
    goto label_3;
    do {
        edi = ecx;
label_0:
        if (*(eax) == 1) {
            ecx = *((eax + 8));
            if (ecx > *((ebp - 0x1f8c))) {
                if (edi == -1) {
                    goto label_4;
                }
                if (ecx < edi) {
                    goto label_4;
                }
                if (edi != ecx) {
                    goto label_5;
                }
                *((ebp - 0x1f90))++;
                ecx = edi;
            }
        } else {
label_5:
            ecx = edi;
            goto label_6;
label_4:
            *((ebp - 0x1f90)) = 1;
        }
label_6:
        edx += 2;
        eax += 0x20;
    } while (ebx > edx);
    if (ecx != -1) {
        *((ebp + esi*8 - 0x1f80)) = ecx;
        eax = *((ebp - 0x1f90));
        *((ebp + esi*8 - 0x1f7c)) = eax;
        esi++;
        if (esi != 0x3e8) {
            goto label_7;
        }
        goto label_8;
label_3:
        *((ebp - 0x1f8c)) = 0;
        esi = 0;
label_1:
        eax = *((ebp - 0x1f94));
        edi = 0xffffffff;
        *((ebp - 0x1f90)) = 0;
        edx = 0;
        goto label_0;
label_2:
        esi = 0;
    }
    if (esi <= 0) {
        goto label_9;
    }
label_8:
    eax = ebp - 0x1f80;
    qsort (dbg.vcmp, esi, 8);
    edi = 0;
    *((ebp - 0x1f8c)) = ebx;
    ebx = *((ebp + 0xc));
    do {
        eax = *((ebp + edi*8 - 0x1f80));
        edx = *((ebp + edi*8 - 0x1f80));
        edx &= 0x3fff;
        if (edx > 4) {
            *(ebx) = eax;
            *((ebp - 0x1c)) = 2;
            eax = ebp - 0x1c;
            *((esp + 0x18)) = eax;
            eax = ebp - 0x24;
            *((esp + 0x14)) = eax;
            eax = ebp - 0x20;
            *((esp + 0x10)) = eax;
            eax = ebp - 0x38;
            *((esp + 0xc)) = eax;
            *((esp + 8)) = ebx;
            eax = *((ebp - 0x1f8c));
            *((esp + 4)) = eax;
            eax = *((ebp - 0x1f94));
            *(esp) = eax;
            eax = find_greatest_power ();
            *((ebp - 0x1f90)) = eax;
            eax = ebp - 0x1c;
            *((esp + 0x18)) = eax;
            eax = ebp - 0x2c;
            *((esp + 0x14)) = eax;
            eax = ebp - 0x28;
            *((esp + 0x10)) = eax;
            eax = ebp - 0x40;
            *((esp + 0xc)) = eax;
            *((esp + 8)) = ebx;
            eax = *((ebp + 8));
            *((esp + 4)) = eax;
            eax = *((ebp - 0x1f98));
            *(esp) = eax;
            eax = find_greatest_power ();
            *(fp_stack--) = *((ebp - 0x40));
            *(fp_stack--) = 0.0;
            fp_stack--;
            if (fp_stack[0] < fp_stack[1]) {
                *(fp_stack--) = *((ebp - 0x38));
                fp_tmp_0 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_0;
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] > fp_stack[1]) {
                    goto label_10;
                }
                if (*((ebp - 0x1f90)) >= eax) {
                    goto label_11;
                }
            } else {
                fp_stack++;
            }
label_10:
            al = (*((ebp - 0x1c)) == 0) ? 1 : 0;
            eax = (int32_t) al;
            *((ebp - 0x1c)) = eax;
            eax = ebp - 0x1c;
            *((esp + 0x18)) = eax;
            eax = ebp - 0x24;
            *((esp + 0x14)) = eax;
            eax = ebp - 0x20;
            *((esp + 0x10)) = eax;
            eax = ebp - 0x38;
            *((esp + 0xc)) = eax;
            *((esp + 8)) = ebx;
            eax = *((ebp - 0x1f8c));
            *((esp + 4)) = eax;
            eax = *((ebp - 0x1f94));
            *(esp) = eax;
            eax = find_greatest_power ();
            *((ebp - 0x1f90)) = eax;
            eax = ebp - 0x1c;
            *((esp + 0x18)) = eax;
            eax = ebp - 0x2c;
            *((esp + 0x14)) = eax;
            eax = ebp - 0x28;
            *((esp + 0x10)) = eax;
            eax = ebp - 0x40;
            *((esp + 0xc)) = eax;
            *((esp + 8)) = ebx;
            eax = *((ebp + 8));
            *((esp + 4)) = eax;
            eax = *((ebp - 0x1f98));
            *(esp) = eax;
            eax = find_greatest_power ();
            *(fp_stack--) = *((ebp - 0x40));
            *(fp_stack--) = 0.0;
            fp_stack--;
            if (fp_stack[0] < fp_stack[1]) {
                *(fp_stack--) = *((ebp - 0x38));
                fp_tmp_1 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_1;
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] > fp_stack[1]) {
                    goto label_12;
                }
                if (*((ebp - 0x1f90)) < eax) {
                    goto label_12;
                }
label_11:
                eax = *((ebp + edi*8 - 0x1f7c));
                goto label_13;
            }
            fp_stack++;
        }
label_12:
        edi++;
    } while (edi < esi);
label_9:
    eax = 0;
label_13:
    return eax;
label_7:
    *((ebp - 0x1f8c)) = ecx;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8065a2e */
#include <stdint.h>
 
int32_t dbg_do_gcd (int32_t count, long int * vp, int32_t i) {
    void ** s2;
    size_t * n;
    int32_t var_ch;
    int32_t var_10h;
    ebx = count;
    esi = vp;
    eax = i;
    /* int do_gcd(long int * vp); */
    esi = eax;
    ebx = 1;
    do {
        *((esp + 0x10)) = esi;
        eax = len_d;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = 0x80f9280;
        eax = n_trhs;
        *((esp + 4)) = eax;
        eax = trhs;
        *(esp) = eax;
        eax = poly_div ();
        if (eax == 0) {
            goto label_0;
        }
        if (eax == 2) {
            goto label_1;
        }
        eax = len_d;
        if (eax > *(obj.n_tokens)) {
            goto label_0;
        }
        eax = n_trhs;
        if (eax > 0x7530) {
            goto label_0;
        }
        eax <<= 4;
        eax = trhs;
        eax = scratch;
        memmove (eax, eax, eax);
        eax = len_d;
        eax <<= 4;
        eax = trhs;
        memmove (eax, 0x80f9280, eax);
        *((esp + 0xc)) = 0x75300;
        eax = n_trhs;
        eax <<= 4;
        *((esp + 8)) = eax;
        eax = scratch;
        *((esp + 4)) = eax;
        *(esp) = obj.gcd_divisor;
        memmove_chk ();
        eax = n_trhs;
        edx = len_d;
        *(obj.n_trhs) = edx;
        *(obj.len_d) = eax;
        ebx++;
    } while (ebx != 0x32);
label_0:
    ebx = 0;
label_1:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8065b31 */
#include <stdint.h>
 
int32_t dbg_pdiv_recurse (int32_t k, int32_t last_op2, int32_t loc, int32_t len1, int32_t power_flag, int32_t rv) {
    int32_t var_a0h;
    int32_t var_9ch;
    uint32_t var_98h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_8ch;
    uint32_t var_88h;
    int32_t var_84h;
    int32_t var_80h;
    uint32_t var_7ch;
    int32_t var_78h;
    void * var_74h;
    int32_t var_70h;
    uint32_t var_6ch;
    int32_t s1;
    int32_t real_len1;
    uint32_t var_60h;
    int32_t j;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t var_4ch;
    int32_t len2;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t flag;
    int32_t op;
    int32_t var_2ch;
    long int v;
    int32_t level;
    int32_t code;
    void * s2;
    size_t * n;
    char * var_ch;
    int32_t var_10h;
    ebx = k;
    ecx = last_op2;
    edx = loc;
    esi = len1;
    edi = power_flag;
    eax = rv;
    /* int pdiv_recurse(token_type * equation,int * np,int loc,int level,int code); */
label_7:
    *((ebp - 0x74)) = eax;
    *((ebp - 0x4c)) = edx;
    *((ebp - 0x78)) = ecx;
    edi = *((ebp + 8));
    ebx = ecx;
    ebx++;
    eax = *(edx);
    if (ebx >= eax) {
        goto label_6;
    }
    *((ebp - 0x30)) = ebx;
    edx = ebx;
    edx <<= 4;
    edx += *((ebp - 0x74));
    *((ebp - 0x68)) = edx;
    edx = *((edx + 4));
    if (edi > edx) {
        goto label_6;
    }
    esi = *((ebp - 0x78));
    esi <<= 4;
    esi += *((ebp - 0x74));
    *((ebp - 0x90)) = esi;
    esi = *((ebp - 0x78));
    esi <<= 4;
    ecx = *((ebp - 0x74));
    ecx = esi + ecx + 0x30;
    *((ebp - 0x8c)) = ecx;
    esi = *((ebp - 0x78));
    esi <<= 4;
    ecx = *((ebp - 0x74));
    ecx = esi + ecx + 0x50;
    *((ebp - 0x58)) = ecx;
    esi = ebx;
    esi = ~esi;
    *((ebp - 0x54)) = esi;
    ecx = *((ebp - 0x8c));
    *((ebp - 0x44)) = ecx;
    *((ebp - 0x40)) = ebx;
    ebx <<= 4;
    ebx += *((ebp - 0x74));
    *((ebp - 0x94)) = ebx;
    ebx = edi + 1;
    *((ebp - 0x84)) = ebx;
    *((ebp - 0x7c)) = ebx;
    ecx = *((ebp - 0x30));
    *((ebp - 0x2c)) = edi;
label_5:
    if (edx != *((ebp - 0x2c))) {
        goto label_9;
    }
    esi = *((ebp - 0x68));
    if (*((esi + 8)) != 4) {
        goto label_9;
    }
    edx = *((ebp - 0x40));
    edx += 2;
    *((ebp - 0x88)) = edx;
    if (eax <= edx) {
        goto label_10;
    }
    esi = *((ebp - 0x2c));
    ebx = *((ebp - 0x44));
    if (esi >= *((ebx + 4))) {
        goto label_10;
    }
    ebx = *((ebp - 0x58));
    ebx += 4;
    edi = esi;
    while (edx < eax) {
        esi = *(ebx);
        ebx += 0x20;
        if (edi >= esi) {
            goto label_11;
        }
        edx += 2;
    }
    goto label_11;
label_10:
    edx = *((ebp - 0x88));
label_11:
    eax = *((ebp - 0x4c));
    ebx = *(eax);
    if (*((ebp - 0x78)) >= ebx) {
        goto label_9;
    }
    esi = *((ebp - 0x90));
    eax = *((esi + 4));
    if (*((ebp - 0x2c)) > eax) {
        goto label_9;
    }
    esi = *((ebp - 0x54));
    *((ebp - 0xa0)) = esi;
    edx += esi;
    *((ebp - 0x64)) = edx;
    edx = *((ebp - 0x44));
    *((ebp - 0x98)) = edx;
    ecx <<= 4;
    esi = *((ebp - 0x74));
    ecx = ecx + esi + 0x10;
    *((ebp - 0x38)) = ecx;
    edx = *((ebp - 0x94));
    *((ebp - 0x50)) = edx;
    ecx = *((ebp - 0x8c));
    *((ebp - 0x70)) = ecx;
    esi = *((ebp - 0x90));
    *((ebp - 0x3c)) = esi;
    esi = *((ebp - 0x64));
    edx = *((ebp - 0x78));
    *((ebp - 0x5c)) = edx;
    edx = 0;
    ecx = *((ebp - 0x2c));
    ecx += 3;
    *((ebp - 0x9c)) = ecx;
label_4:
    if (*((ebp - 0x2c)) == eax) {
        eax = *((ebp - 0x3c));
        if (*(eax) != 2) {
            goto label_12;
        }
        edx = *((eax + 8));
        goto label_13;
    }
label_12:
    if (edx == 4) {
        goto label_13;
    }
    edx = *((ebp - 0x5c));
    edx++;
    if (ebx <= edx) {
        goto label_14;
    }
    edi = *((ebp - 0x50));
    ecx = *((edi + 4));
    if (*((ebp - 0x2c)) >= ecx) {
        goto label_14;
    }
    eax = *((ebp - 0x70));
    *((ebp - 0x30)) = 0;
    *((ebp - 0x34)) = esi;
    esi = *((ebp - 0x84));
    do {
        if (ecx == esi) {
            edi = *((edi + 8));
            *((ebp - 0x30)) = edi;
        }
        edx += 2;
        if (edx >= ebx) {
            goto label_15;
        }
        edi = eax;
        ecx = *((eax + 4));
        eax += 0x20;
    } while (*((ebp - 0x2c)) < ecx);
label_15:
    esi = *((ebp - 0x34));
    eax = *((ebp - 0x30));
    eax--;
    if (eax > 1) {
        goto label_14;
    }
    edx -= *((ebp - 0x5c));
    *((ebp - 0x48)) = edx;
    if (ebx <= *((ebp - 0x88))) {
        goto label_1;
    }
    edx = *((ebp - 0x44));
    eax = *((edx + 4));
    if (*((ebp - 0x2c)) >= eax) {
        goto label_1;
    }
    ecx = *((ebp - 0x58));
    *((ebp - 0x6c)) = ecx;
    edi = *((ebp - 0x98));
    ecx = *((ebp - 0x88));
    *((ebp - 0x34)) = 0;
    *((ebp - 0x60)) = 0;
    edx = *((ebp - 0x2c));
    edx += 2;
    *((ebp - 0x30)) = edx;
    edx = *((ebp - 0x6c));
    *((ebp - 0x6c)) = esi;
    esi = *((ebp - 0x9c));
label_0:
    if (eax == esi) {
        eax = *((edi + 8));
        eax--;
        eax = 1;
        if (eax > 1) {
            eax = *((ebp - 0x34));
        }
        *((ebp - 0x34)) = eax;
        goto label_16;
    }
    if (eax == *((ebp - 0x30))) {
        edi = *((edi + 8));
        *((ebp - 0x60)) = edi;
        goto label_16;
    }
    if (eax != *((ebp - 0x7c))) {
        goto label_16;
    }
    esi = *((ebp - 0x6c));
    if (*((edi + 8)) != 6) {
        goto label_1;
    }
    eax = *((ebp - 0x60));
    eax--;
    if (eax > 1) {
        if (*((ebp - 0x60)) != 3) {
            goto label_1;
        }
        if (*((ebp - 0x34)) != 1) {
            goto label_1;
        }
    }
    esi = *((ebp - 0xa0));
    esi = ecx + esi;
    edi = 1;
    while (ecx >= ebx) {
        esi = *((ebp - 0x6c));
label_1:
        edi = 0;
        ecx = *((ebp + 0xc));
        *((ebp - 0x34)) = ecx;
        ebx = *((ebp - 0x48));
        ebx++;
        *((ebp - 0x80)) = ebx;
        goto label_3;
label_16:
        ecx += 2;
    }
    edi = edx;
    eax = *((edx + 4));
    edx += 0x20;
    if (*((ebp - 0x2c)) < eax) {
        goto label_0;
    }
    esi = *((ebp - 0x6c));
    goto label_1;
    do {
label_2:
        edi = 0;
label_3:
        if (edi == 0) {
            esi = *((ebp - 0x64));
        }
        *((ebp - 0x1c)) = 0;
        eax = *((ebp - 0x34));
        eax |= edi;
        *((ebp - 0x60)) = eax;
        if (eax != 0) {
            edx = ebp - 0x1c;
            *((esp + 0x10)) = edx;
            *((esp + 0xc)) = esi;
            ecx = *((ebp - 0x38));
            *((esp + 8)) = ecx;
            ebx = *((ebp - 0x48));
            *((esp + 4)) = ebx;
            eax = *((ebp - 0x3c));
            *(esp) = eax;
            poly_div ();
        } else {
            *((esp + 0xc)) = esi;
            edx = *((ebp - 0x38));
            *((esp + 8)) = edx;
            ecx = *((ebp - 0x48));
            *((esp + 4)) = ecx;
            ebx = *((ebp - 0x3c));
            *(esp) = ebx;
            eax = smart_div ();
        }
        if (eax > 0) {
            if (*(obj.n_trhs) != 1) {
                goto label_17;
            }
            edx = trhs;
            if (*(edx) != 0) {
                goto label_17;
            }
            *(fp_stack--) = *((edx + 8));
            edx = edi;
            *((ebp - 0x30)) = dl;
            *(fp_stack--) = 0.0;
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] == fp_stack[1]) {
                goto label_17;
            }
            if (fp_stack[0] == fp_stack[1]) {
                goto label_18;
            }
        }
label_17:
        ecx = edi;
        *((ebp - 0x30)) = cl;
    } while (cl != 0);
    if (eax <= 0) {
        goto label_19;
    }
label_18:
    eax = n_tlhs;
    eax += *(obj.n_trhs);
    eax = esi + eax + 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edx = n_tlhs;
    if (edx <= 0) {
        goto label_20;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
        edx = n_tlhs;
    } while (edx > eax);
label_20:
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 1;
    *(obj.n_tlhs)++;
    edx = n_trhs;
    if (edx <= 0) {
        goto label_21;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.trhs);
        *((edx + 4)) += 2;
        eax++;
        edx = n_trhs;
    } while (edx > eax);
label_21:
    edx <<= 4;
    eax = trhs;
    eax = n_tlhs;
    eax <<= 4;
    eax += *(obj.tlhs);
    memmove (eax, eax, edx);
    edx = n_trhs;
    edx += *(obj.n_tlhs);
    *(obj.n_tlhs) = edx;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 4;
    ebx = n_tlhs;
    ebx++;
    *(obj.n_tlhs) = ebx;
    eax = esi;
    eax <<= 4;
    eax = *((ebp - 0x38));
    eax = ebx;
    eax <<= 4;
    eax += *(obj.tlhs);
    memmove (eax, eax, eax);
    eax = esi;
    eax += *(obj.n_tlhs);
    *(obj.n_tlhs) = eax;
    if (ebx >= eax) {
        goto label_22;
    }
    eax = ebx;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.tlhs);
        *((edx + 4)) += 2;
        ebx++;
        eax += 0x10;
    } while (*(obj.n_tlhs) > ebx);
label_22:
    *((esp + 0x10)) = 0;
    edx = *((ebp - 0x48));
    ecx = *((ebp - 0x3c));
    list_debug (0, ecx, edx);
    *((esp + 0x10)) = 0;
    ebx = *((ebp - 0x38));
    list_debug (0, ebx, esi);
    *((esp + 0x10)) = 3;
    *((esp + 0xc)) = 1;
    eax = tlhs;
    simpb_side (eax, 0x80796b8, 0);
    *((esp + 0x10)) = 0;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (0, eax, eax);
    if (*((ebp - 0x30)) != 0) {
        eax = n_tlhs;
        eax = tlhs;
        eax = var_count (eax, eax);
        ebx = eax;
        eax = *((ebp - 0x48));
        edx = *((ebp - 0x3c));
        eax = var_count (edx, eax);
        al = (ebx <= eax) ? 1 : 0;
        eax = (int32_t) al;
    } else {
        eax = n_tlhs;
        eax = tlhs;
        var_count (eax, eax);
        edx = *((ebp - 0x80));
        edx += esi;
        dl = (edx <= *(obj.n_tlhs)) ? 1 : 0;
        edx = (int32_t) dl;
        edx = eax + edx;
        *((ebp - 0x6c)) = edx;
        ecx = *((ebp - 0x48));
        ebx = *((ebp - 0x3c));
        eax = var_count (ebx, ecx);
        ebx = eax;
        eax = *((ebp - 0x38));
        eax = var_count (eax, esi);
        eax += ebx;
        al = (*((ebp - 0x6c)) <= eax) ? 1 : 0;
        eax = (int32_t) al;
    }
    if (eax == 0) {
        goto label_19;
    }
    edi = *((ebp - 0x2c));
    edx = *((ebp - 0x5c));
    *((ebp - 0x2c)) = edx;
    edx = n_tlhs;
    if (edx <= 0) {
        goto label_23;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4)) += edi;
        eax++;
        edx = n_tlhs;
    } while (edx > eax);
label_23:
    if (*((ebp - 0x30)) == 0) {
        goto label_24;
    }
    ecx = *((ebp - 0x4c));
    eax = *(ecx);
    edx -= *((ebp - 0x48));
    eax = edx + eax + 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    esi += *((ebp - 0x88));
    edx = *((ebp - 0x64));
    edx += *((ebp - 0x40));
    if (esi > edx) {
        goto label_25;
    }
    eax = esi;
    eax <<= 4;
    ebx = *((ebp - 0x74));
    eax = ebx + eax + 4;
    do {
        *(eax)++;
        esi++;
        eax += 0x10;
    } while (esi <= edx);
label_25:
    ebx = esi;
    ebx <<= 4;
    ebx += *((ebp - 0x74));
    ecx = *((ebp - 0x4c));
    eax = *(ecx);
    eax -= esi;
    eax <<= 4;
    edx <<= 4;
    ecx = *((ebp - 0x74));
    eax = edx + ecx + 0x30;
    memmove (eax, ebx, eax);
    eax = *((ebp - 0x4c));
    *(eax) += 2;
    edi += 2;
    *((ebx + 4)) = edi;
    *(ebx) = 2;
    *((ebx + 8)) = 2;
    esi <<= 4;
    edx = *((ebp - 0x74));
    eax = esi + edx + 0x10;
    *((eax + 4)) = edi;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x2c));
    eax += 2;
    edx = *((ebp - 0x2c));
    if (*((ebp - 0x40)) >= edx) {
        eax = *((ebp - 0x5c));
    }
    *((ebp - 0x5c)) = eax;
    goto label_26;
label_24:
    ebx = esi;
    ebx = ~ebx;
    eax = ebx;
    eax -= *((ebp - 0x48));
    ecx = *((ebp - 0x4c));
    eax += *(ecx);
    eax += edx;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp - 0xa0));
    edx = *((ebp - 0x4c));
    eax += *(edx);
    eax -= esi;
    eax <<= 4;
    ecx = *((ebp - 0x40));
    eax = ecx + esi + 1;
    eax <<= 4;
    eax += *((ebp - 0x74));
    esi = *((ebp - 0x68));
    memmove (esi, eax, eax);
    eax = *((ebp - 0x4c));
    *(eax) += ebx;
    ebx += *((ebp - 0x2c));
    edx = *((ebp - 0x2c));
    if (*((ebp - 0x40)) >= edx) {
        ebx = *((ebp - 0x5c));
    }
    *((ebp - 0x5c)) = ebx;
label_26:
    eax = *((ebp - 0x5c));
    eax += *((ebp - 0x48));
    ecx = *((ebp - 0x4c));
    edx = *(ecx);
    edx -= eax;
    edx <<= 4;
    eax <<= 4;
    eax += *((ebp - 0x74));
    eax = *((ebp - 0x5c));
    eax += *(obj.n_tlhs);
    eax <<= 4;
    eax += *((ebp - 0x74));
    memmove (eax, eax, edx);
    ebx = *((ebp - 0x4c));
    eax = *(ebx);
    eax += *(obj.n_tlhs);
    eax -= *((ebp - 0x48));
    *(ebx) = eax;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    eax = *((ebp - 0x5c));
    eax <<= 4;
    eax += *((ebp - 0x74));
    memmove (eax, eax, eax);
    if (*((ebp - 0x60)) != 0) {
        if (*(obj.debug_level) <= 0) {
            goto label_27;
        }
        *((esp + 0xc)) = "Polynomial division successful.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    } else {
        if (*(obj.debug_level) <= 0) {
            goto label_27;
        }
        *((esp + 0xc)) = "Smart division successful.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
label_27:
    *((esp + 0x10)) = 0;
    esi = *((ebp - 0x4c));
    eax = *(esi);
    eax = *((ebp - 0x74));
    list_debug (0, eax, eax);
    esi = 1;
    goto label_28;
label_19:
    if (*((ebp - 0x30)) != 0) {
        goto label_2;
    }
    edx = *((ebp + 0xc));
    if (*((ebp - 0x34)) == edx) {
        al = (edx == 0) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x34)) = eax;
        goto label_3;
    }
label_14:
    edx = 4;
label_13:
    *((ebp - 0x5c))++;
    ecx = *((ebp - 0x4c));
    ebx = *(ecx);
    if (ebx <= *((ebp - 0x5c))) {
        goto label_9;
    }
    eax = *((ebp - 0x50));
    *((ebp - 0x3c)) = eax;
    ecx = eax;
    eax = *((eax + 4));
    ecx += 0x10;
    *((ebp - 0x50)) = ecx;
    *((ebp - 0x70)) += 0x10;
    if (*((ebp - 0x2c)) <= eax) {
        goto label_4;
    }
label_9:
    *((ebp - 0x40)) += 2;
    ebx = *((ebp - 0x4c));
    eax = *(ebx);
    if (eax <= *((ebp - 0x40))) {
        edi = *((ebp - 0x2c));
label_6:
        ebx = *((ebp - 0x78));
        esi = 0;
        eax = edi + 1;
        *((ebp - 0x30)) = eax;
        *((ebp - 0x2c)) = esi;
        esi = *((ebp - 0x74));
        goto label_29;
    }
    ecx = *((ebp - 0x40));
    edx = *((ebp - 0x44));
    *((ebp - 0x68)) = edx;
    ebx = edx;
    edx = *((edx + 4));
    ebx += 0x20;
    *((ebp - 0x44)) = ebx;
    *((ebp - 0x58)) += 0x20;
    *((ebp - 0x54)) -= 2;
    if (edx >= *((ebp - 0x2c))) {
        goto label_5;
    }
    edi = *((ebp - 0x2c));
    goto label_6;
label_8:
    if (edi >= eax) {
        goto label_30;
    }
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x30));
    *(esp) = edx;
    ecx = ebx;
    edx = *((ebp - 0x4c));
    eax = esi;
    eax = pdiv_recurse ();
    goto label_7;
    *((ebp - 0x2c)) |= eax;
    eax = ebx + 1;
    edx = *((ebp - 0x4c));
    ecx = *(edx);
    if (ecx <= eax) {
        goto label_31;
    }
    edx = eax;
    edx <<= 4;
    if (edi >= *((edx + esi + 4))) {
        goto label_31;
    }
    ebx <<= 4;
    edx = esi + ebx + 0x34;
    do {
        eax += 2;
        if (ecx <= eax) {
            goto label_31;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (edi < ebx);
    goto label_31;
label_30:
    eax = ebx + 1;
label_31:
    ebx = eax;
label_29:
    ecx = *((ebp - 0x4c));
    if (ebx >= *(ecx)) {
        goto label_32;
    }
    eax = ebx;
    eax <<= 4;
    eax = *((eax + esi + 4));
    if (edi <= eax) {
        goto label_8;
    }
    esi = *((ebp - 0x2c));
    goto label_28;
label_32:
    esi = *((ebp - 0x2c));
label_28:
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8066571 */
#include <stdint.h>
 
int32_t dbg_mod_recurse (int32_t i5, int32_t last_op2, int32_t loc, int32_t i1, int32_t len3, int32_t modified) {
    int32_t var_bch;
    int32_t var_b8h;
    int32_t var_b4h;
    int32_t len2;
    int32_t var_ach;
    int32_t var_a8h;
    int32_t var_a4h;
    int32_t var_a0h;
    void * var_9ch;
    int32_t var_98h;
    int32_t var_94h;
    int32_t var_90h;
    int32_t var_8ch;
    int32_t var_88h;
    int32_t var_84h;
    int32_t j;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_74h;
    int32_t len1;
    int32_t var_6ch;
    int32_t var_68h;
    int32_t var_64h;
    int32_t i3;
    uint32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    void * var_4ch;
    uint32_t var_48h;
    void * s1;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    void * var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    long int v;
    int32_t diff_sign;
    int32_t level;
    void * s2;
    size_t n;
    int32_t var_ch;
    int32_t var_10h;
    ebx = i5;
    ecx = last_op2;
    edx = loc;
    esi = i1;
    edi = len3;
    eax = modified;
    do {
        /* int mod_recurse(token_type * equation,int * np,int loc,int level); */
        *((ebp - 0x44)) = eax;
        *((ebp - 0x50)) = edx;
        *((ebp - 0x98)) = ecx;
        ebx = ecx;
        *((ebp - 0x84)) = 0;
        esi = *((ebp + 8));
        esi++;
        edi = eax;
        *((ebp - 0x2c)) = esi;
        esi = *((ebp + 8));
        goto label_7;
label_0:
        if (eax <= esi) {
            goto label_8;
        }
        eax = *((ebp - 0x2c));
        *(esp) = eax;
        ecx = ebx;
        edx = *((ebp - 0x50));
        eax = edi;
        eax = mod_recurse ();
    } while (1);
    *((ebp - 0x84)) |= eax;
    eax = ebx + 1;
    edx = *((ebp - 0x50));
    ecx = *(edx);
    if (eax >= ecx) {
        goto label_9;
    }
    edx = eax;
    edx <<= 4;
    if (esi >= *((edx + edi + 4))) {
        goto label_9;
    }
    ebx <<= 4;
    edx = edi + ebx + 0x34;
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_9;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    goto label_9;
label_8:
    eax = ebx + 1;
label_9:
    ebx = eax;
label_7:
    ecx = *((ebp - 0x50));
    edx = *(ecx);
    if (ebx >= edx) {
        goto label_10;
    }
    eax = ebx;
    eax <<= 4;
    eax = *((eax + edi + 4));
    if (eax >= esi) {
        goto label_0;
    }
label_10:
    eax = *((ebp - 0x84));
    if (eax != 0) {
        goto label_11;
    }
    edi = *((ebp - 0x98));
    edi++;
    if (edi >= edx) {
        goto label_12;
    }
    *((ebp - 0x30)) = edi;
    ebx = edi;
    ebx <<= 4;
    ebx += *((ebp - 0x44));
    ecx = *((ebx + 4));
    if (*((ebp + 8)) > ecx) {
        goto label_12;
    }
    eax = *((ebp - 0x98));
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((ebp - 0xb8)) = eax;
    esi = *((ebp - 0x98));
    esi += 3;
    *((ebp - 0x54)) = esi;
    eax = esi;
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((ebp - 0xb4)) = eax;
    eax = edi;
    eax = ~eax;
    *((ebp - 0x68)) = eax;
    esi = *((ebp - 0x98));
    esi <<= 4;
    eax = *((ebp - 0x44));
    eax = esi + eax + 0x50;
    *((ebp - 0x6c)) = eax;
    esi = *((ebp - 0xb4));
    *((ebp - 0x58)) = esi;
    *((ebp - 0xbc)) = ebx;
    eax = *((ebp + 8));
    eax += 2;
    *((ebp - 0x40)) = eax;
    esi = *((ebp - 0x30));
label_6:
    if (*((ebp + 8)) != ecx) {
        goto label_13;
    }
    if (*((ebx + 8)) != 5) {
        goto label_13;
    }
    eax = *((ebp - 0x54));
    if (edx <= eax) {
        goto label_14;
    }
    ebx = *((ebp + 8));
    ecx = *((ebp - 0x58));
    if (ebx >= *((ecx + 4))) {
        goto label_14;
    }
    ecx = *((ebp - 0x6c));
    ecx += 4;
    edi = ebx;
    while (eax < edx) {
        ebx = *(ecx);
        ecx += 0x20;
        if (edi >= ebx) {
            goto label_14;
        }
        eax += 2;
    }
label_14:
    eax += *((ebp - 0x68));
    *((ebp - 0x70)) = eax;
    eax = *((ebp - 0x50));
    ecx = *(eax);
    if (*((ebp - 0x98)) >= ecx) {
        goto label_13;
    }
    edx = *((ebp - 0xb8));
    eax = *((edx + 4));
    if (*((ebp + 8)) > eax) {
        goto label_13;
    }
    esi <<= 4;
    ebx = *((ebp - 0x44));
    esi = esi + ebx + 0x10;
    *((ebp - 0x74)) = esi;
    esi = *((ebp - 0xbc));
    *((ebp - 0x7c)) = esi;
    edx = *((ebp - 0xb4));
    *((ebp - 0x94)) = edx;
    ebx = *((ebp - 0xb8));
    *((ebp - 0x9c)) = ebx;
    esi = *((ebp - 0x98));
    *((ebp - 0x80)) = esi;
    edx = 0;
    ebx = *((ebp + 8));
    ebx++;
    *((ebp - 0x5c)) = ebx;
    *((ebp - 0xac)) = ebx;
label_5:
    if (*((ebp + 8)) == eax) {
        esi = *((ebp - 0x9c));
        if (*(esi) != 2) {
            goto label_15;
        }
        edx = *((esi + 8));
        goto label_16;
    }
label_15:
    if (edx == 5) {
        goto label_16;
    }
    eax = *((ebp - 0x80));
    *((ebp - 0x38)) = eax;
    edx = eax;
    edx++;
    *((ebp - 0x30)) = edx;
    if (ecx <= edx) {
        goto label_17;
    }
    ebx = *((ebp - 0x7c));
    *((ebp - 0x34)) = ebx;
    edx = *((ebx + 4));
    if (*((ebp + 8)) >= edx) {
        goto label_17;
    }
    eax = *((ebp - 0x94));
    esi = ebx;
    ebx = *((ebp - 0x30));
    *((ebp - 0x2c)) = ebx;
    edi = 0;
    do {
        if (edx == *((ebp - 0x5c))) {
            edi = *((esi + 8));
            *((ebp - 0x2c)) = ebx;
        }
        ebx += 2;
        if (ecx <= ebx) {
            goto label_18;
        }
        esi = eax;
        edx = *((eax + 4));
        eax += 0x20;
    } while (*((ebp + 8)) < edx);
label_18:
    *((ebp - 0x78)) = ebx;
    esi = ebx;
    esi -= *((ebp - 0x80));
    *((ebp - 0xb0)) = esi;
    if (edi != 3) {
        if (edi <= 3) {
            if (edi >= 1) {
                goto label_19;
            }
            goto label_20;
        }
        if (edi != 5) {
            goto label_20;
        }
        edi = *((ebp - 0x2c));
        edi = ~edi;
        edi += *((ebp - 0x78));
        esi = *((ebp - 0x2c));
        eax = ebp - 0x1c;
        *((esp + 0x10)) = eax;
        *((esp + 0xc)) = edi;
        eax = esi;
        eax <<= 4;
        edx = *((ebp - 0x44));
        eax = eax + edx + 0x10;
        *((esp + 8)) = eax;
        ecx = *((ebp - 0x70));
        *((esp + 4)) = ecx;
        eax = *((ebp - 0x74));
        *(esp) = eax;
        eax = se_compare ();
        if (eax == 0) {
            goto label_20;
        }
        edx = *((ebp - 0x50));
        eax = *(edx);
        eax -= ebx;
        eax <<= 4;
        eax = ebx;
        eax <<= 4;
        eax += *((ebp - 0x44));
        eax = esi;
        eax <<= 4;
        eax += *((ebp - 0x44));
        memmove (eax, eax, eax);
        edi = ~edi;
        ecx = *((ebp - 0x50));
        *(ecx) += edi;
        eax = 1;
        goto label_12;
    }
    ebx = *((ebp - 0xb0));
    *((esp + 4)) = ebx;
    esi = *((ebp - 0x9c));
    eax = is_integer_expr (esi);
    if (eax == 0) {
        goto label_20;
    }
    eax = *((ebp - 0x34));
    eax += 4;
    *((ebp - 0x38)) = eax;
    esi = *((ebp - 0x30));
label_1:
    edx = *((ebp - 0x78));
    while (1) {
        if (*((ebp - 0x30)) > esi) {
            goto label_21;
        }
        goto label_22;
        ebx = *((ebp - 0xac));
        ecx = *((ebp - 0x38));
        if (ebx != *(ecx)) {
            goto label_23;
        }
    }
label_21:
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x44));
    ebx = edx + eax + 4;
    edi = esi;
    edi = ~edi;
    edi += *((ebp - 0x30));
    eax = esi;
    eax <<= 4;
    eax = eax + edx + 0x10;
    *((ebp - 0x2c)) = eax;
    do {
        ecx = ebx - 4;
        *((ebp - 0x34)) = ecx;
        eax = *((ebp - 0x40));
        if (*(ebx) == eax) {
            if (*((ebx + 4)) != 5) {
                goto label_24;
            }
            *((ebp - 0x3c)) = edi;
            edx = ebp - 0x1c;
            *((esp + 0x10)) = edx;
            *((esp + 0xc)) = edi;
            ecx = *((ebp - 0x2c));
            *((esp + 8)) = ecx;
            eax = *((ebp - 0x70));
            *((esp + 4)) = eax;
            edx = *((ebp - 0x74));
            *(esp) = edx;
            eax = se_compare ();
            if (eax == 0) {
                goto label_24;
            }
            ecx = *((ebp - 0x50));
            eax = *(ecx);
            eax -= *((ebp - 0x30));
            eax <<= 4;
            eax = *((ebp - 0x30));
            eax <<= 4;
            eax += *((ebp - 0x44));
            ebx = *((ebp - 0x34));
            memmove (ebx, eax, eax);
            eax = *((ebp - 0x3c));
            eax = ~eax;
            esi = *((ebp - 0x50));
            *(esi) += eax;
            eax = 1;
            goto label_12;
        }
label_24:
        esi += 2;
        ebx += 0x20;
        edi -= 2;
        *((ebp - 0x2c)) += 0x20;
    } while (*((ebp - 0x30)) > esi);
label_22:
    eax = *((ebp - 0x78));
    if (*((ebp - 0x30)) >= eax) {
        goto label_20;
    }
label_23:
    *((ebp - 0x30)) += 2;
    *((ebp - 0x38)) += 0x20;
    goto label_1;
label_19:
    edx = *((ebp - 0x38));
    edx--;
    *((ebp - 0x60)) = edx;
    ecx = *((ebp - 0x34));
    ecx += 4;
    *((ebp - 0x88)) = ecx;
    ebx = *((ebp - 0x30));
    *((ebp - 0x2c)) = ebx;
    esi = *((ebp + 8));
    esi += 3;
    *((ebp - 0x48)) = esi;
label_4:
    eax = *((ebp - 0x78));
    while (1) {
        if (*((ebp - 0x2c)) > ebx) {
            goto label_25;
        }
        goto label_26;
        ecx = *((ebp - 0xac));
        edx = *((ebp - 0x88));
        if (ecx != *(edx)) {
            goto label_27;
        }
    }
label_25:
    esi = *((ebp - 0x60));
    *((ebp - 0xa4)) = esi;
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    *((ebp - 0x8c)) = eax;
    ecx = esi;
    ecx += 4;
    *((ebp - 0x90)) = ecx;
    eax = ecx;
    eax <<= 4;
    eax = edx + eax + 4;
    *((ebp - 0xa8)) = eax;
label_3:
    eax = ebx;
    esi = ebx;
    esi <<= 4;
    esi += *((ebp - 0x44));
    edx = *((ebp - 0x40));
    if (*((esi + 4)) != edx) {
        goto label_28;
    }
    edx = *((esi + 8));
    if (edx != 3) {
        if (edx != 5) {
            goto label_28;
        }
        edx = ebx;
        edx = ~edx;
        edi = *((ebp - 0x2c));
        edi = edx + edi;
        ecx = ebp - 0x1c;
        *((esp + 0x10)) = ecx;
        *((esp + 0xc)) = edi;
        eax <<= 4;
        edx = *((ebp - 0x44));
        eax = eax + edx + 0x10;
        *((esp + 8)) = eax;
        ecx = *((ebp - 0x70));
        *((esp + 4)) = ecx;
        eax = *((ebp - 0x74));
        *(esp) = eax;
        eax = se_compare ();
        if (eax == 0) {
            goto label_28;
        }
        edx = *((ebp - 0x50));
        eax = *(edx);
        eax -= *((ebp - 0x2c));
        eax <<= 4;
        eax = *((ebp - 0x2c));
        eax <<= 4;
        eax += *((ebp - 0x44));
        memmove (esi, eax, eax);
        edi = ~edi;
        ecx = *((ebp - 0x50));
        *(ecx) += edi;
        eax = 1;
        goto label_12;
    }
    ebx = *((ebp - 0x2c));
    ebx -= 2;
    eax = *((ebp - 0x60));
    eax = ~eax;
    eax += *((ebp - 0x2c));
    *((esp + 4)) = eax;
    esi = *((ebp - 0x8c));
    eax = is_integer_expr (esi);
    if (eax == 0) {
        goto label_28;
    }
    edx = *((ebp - 0x60));
    edx += 2;
    if (*((ebp - 0x2c)) <= edx) {
        goto label_28;
    }
    edi = *((ebp - 0x90));
    eax = edx;
    eax <<= 4;
    ecx = *((ebp - 0x44));
    esi = ecx + eax + 4;
    edx = ~edx;
    *((ebp - 0x34)) = edx;
    eax = *((ebp - 0xa4));
    eax <<= 4;
    eax = eax + ecx + 0x30;
    *((ebp - 0x30)) = eax;
    eax = *((ebp - 0xa8));
    *((ebp - 0x38)) = eax;
    eax = *((ebp - 0x60));
    eax <<= 4;
    eax = eax + ecx + 0x60;
    *((ebp - 0x3c)) = eax;
    *((ebp - 0xa0)) = ebx;
label_2:
    edx = esi - 4;
    *((ebp - 0x4c)) = edx;
    eax = *(esi);
    if (eax != *((ebp - 0x48))) {
        goto label_29;
    }
    if (*((esi + 4)) != 5) {
        goto label_29;
    }
    ebx = edi;
    if (*((ebp - 0x2c)) <= edi) {
        goto label_30;
    }
    ecx = *((ebp - 0x38));
    if (*(ecx) <= eax) {
        goto label_30;
    }
    edx = *((ebp - 0x3c));
    edx += 4;
    *((ebp - 0x64)) = esi;
    esi = *((ebp - 0x2c));
    do {
        ebx += 2;
        if (esi <= ebx) {
            goto label_31;
        }
        ecx = *(edx);
        edx += 0x20;
    } while (eax < ecx);
    esi = *((ebp - 0x64));
    goto label_30;
label_31:
    esi = *((ebp - 0x64));
label_30:
    eax = *((ebp - 0x34));
    eax += ebx;
    *((ebp - 0x64)) = eax;
    edx = ebp - 0x1c;
    *((esp + 0x10)) = edx;
    *((esp + 0xc)) = eax;
    ecx = *((ebp - 0x30));
    *((esp + 8)) = ecx;
    eax = *((ebp - 0x70));
    *((esp + 4)) = eax;
    edx = *((ebp - 0x74));
    *(esp) = edx;
    eax = se_compare ();
    if (eax != 0) {
        ecx = *((ebp - 0x50));
        eax = *(ecx);
        eax -= ebx;
        eax <<= 4;
        eax = ebx;
        eax <<= 4;
        eax += *((ebp - 0x44));
        ebx = *((ebp - 0x4c));
        memmove (ebx, eax, eax);
        eax = *((ebp - 0x64));
        eax = ~eax;
        esi = *((ebp - 0x50));
        *(esi) += eax;
        eax = 1;
        goto label_12;
    }
label_29:
    edi += 2;
    esi += 0x20;
    *((ebp - 0x34)) -= 2;
    *((ebp - 0x30)) += 0x20;
    *((ebp - 0x38)) += 0x20;
    *((ebp - 0x3c)) += 0x20;
    eax = edi - 2;
    if (*((ebp - 0x2c)) > eax) {
        goto label_2;
    }
    ebx = *((ebp - 0xa0));
label_28:
    ebx += 2;
    if (*((ebp - 0x2c)) > ebx) {
        goto label_3;
    }
label_26:
    eax = *((ebp - 0x78));
    if (*((ebp - 0x2c)) < eax) {
        edx = *((ebp - 0x2c));
        *((ebp - 0x60)) = edx;
label_27:
        *((ebp - 0x2c)) += 2;
        *((ebp - 0x88)) += 0x20;
        goto label_4;
label_17:
        *((ebp - 0xb0)) = 1;
    }
label_20:
    *((ebp - 0x20)) = 0;
    eax = ebp - 0x20;
    *((esp + 0x10)) = eax;
    ecx = *((ebp - 0x70));
    *((esp + 0xc)) = ecx;
    ebx = *((ebp - 0x74));
    *((esp + 8)) = ebx;
    esi = *((ebp - 0xb0));
    *((esp + 4)) = esi;
    eax = *((ebp - 0x9c));
    *(esp) = eax;
    eax = poly_div ();
    if (eax == 0) {
        goto label_32;
    }
    eax = tlhs;
    uf_pplus (eax, obj.n_tlhs);
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    eax = is_integer_expr (eax);
    if (eax == 0) {
        goto label_32;
    }
    edx = *((ebp - 0x50));
    eax = *(edx);
    eax += *(obj.n_trhs);
    eax -= esi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = n_trhs;
    if (eax <= 0) {
        goto label_33;
    }
    edx = 0;
    do {
        eax = 0;
        eax <<= 4;
        eax += *(obj.trhs);
        ecx = *((ebp + 8));
        *((eax + 4)) += ecx;
        edx++;
        eax = n_trhs;
    } while (eax > edx);
label_33:
    edx = *((ebp - 0xb0));
    edx += *((ebp - 0x80));
    ebx = *((ebp - 0x50));
    ecx = *(ebx);
    ecx -= edx;
    ecx <<= 4;
    edx <<= 4;
    edx += *((ebp - 0x44));
    eax += *((ebp - 0x80));
    eax <<= 4;
    eax += *((ebp - 0x44));
    memmove (eax, edx, ecx);
    eax = *(ebx);
    eax += *(obj.n_trhs);
    eax -= *((ebp - 0xb0));
    *(ebx) = eax;
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    esi = *((ebp - 0x9c));
    memmove (esi, eax, eax);
    eax = 1;
    goto label_12;
label_32:
    edx = 5;
label_16:
    *((ebp - 0x80))++;
    eax = *((ebp - 0x50));
    ecx = *(eax);
    if (ecx <= *((ebp - 0x80))) {
        goto label_13;
    }
    ebx = *((ebp - 0x7c));
    *((ebp - 0x9c)) = ebx;
    eax = *((ebx + 4));
    ebx += 0x10;
    *((ebp - 0x7c)) = ebx;
    *((ebp - 0x94)) += 0x10;
    if (*((ebp + 8)) <= eax) {
        goto label_5;
    }
label_13:
    esi = *((ebp - 0x50));
    edx = *(esi);
    if (edx > *((ebp - 0x54))) {
        ebx = *((ebp - 0x58));
        ecx = *((ebx + 4));
        eax = *((ebp - 0x54));
        eax += 2;
        *((ebp - 0x58)) += 0x20;
        *((ebp - 0x68)) -= 2;
        *((ebp - 0x6c)) += 0x20;
        if (*((ebp + 8)) <= ecx) {
            esi = *((ebp - 0x54));
            *((ebp - 0x54)) = eax;
            goto label_6;
label_11:
            eax = 1;
        }
    } else {
        eax = *((ebp - 0x84));
    }
label_12:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806749b */
#include <stdint.h>
 
int32_t dbg_polydiv_recurse (int32_t arg_8h, int32_t level, int32_t last_op2, int32_t loc, int32_t i, int32_t len2, int32_t len1) {
    int32_t var_68h;
    int32_t var_64h;
    int32_t var_60h;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t var_50h;
    int32_t modified;
    int32_t var_48h;
    void * s1;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t j;
    void * s2;
    size_t n;
    char * var_ch;
    int32_t var_10h;
    ebx = level;
    ecx = last_op2;
    edx = loc;
    esi = i;
    edi = len2;
    eax = len1;
    do {
        /* int polydiv_recurse(token_type * equation,int * np,int loc,int level); */
        *((ebp - 0x44)) = eax;
        *((ebp - 0x28)) = edx;
        *((ebp - 0x48)) = ecx;
        ebx = *((ebp + 8));
        esi = ecx;
        *((ebp - 0x4c)) = 0;
        edi = ebx + 1;
        *((ebp - 0x1c)) = edi;
        edi = eax;
        goto label_5;
label_0:
        if (eax <= ebx) {
            goto label_6;
        }
        eax = *((ebp - 0x1c));
        ecx = esi;
        edx = *((ebp - 0x28));
        eax = edi;
        eax = polydiv_recurse (eax);
    } while (1);
    *((ebp - 0x4c)) |= eax;
    eax = esi + 1;
    edx = *((ebp - 0x28));
    ecx = *(edx);
    if (eax >= ecx) {
        goto label_7;
    }
    edx = eax;
    edx <<= 4;
    if (ebx >= *((edx + edi + 4))) {
        goto label_7;
    }
    esi <<= 4;
    edx = edi + esi + 0x34;
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_7;
        }
        esi = *(edx);
        edx += 0x20;
    } while (ebx < esi);
    goto label_7;
label_6:
    eax = esi + 1;
label_7:
    esi = eax;
label_5:
    ecx = *((ebp - 0x28));
    if (esi >= *(ecx)) {
        goto label_8;
    }
    eax = esi;
    eax <<= 4;
    eax = *((eax + edi + 4));
    if (eax >= ebx) {
        goto label_0;
    }
label_8:
    esi = *((ebp - 0x48));
    esi++;
    *((ebp - 0x50)) = esi;
    *((ebp - 0x64)) = esi;
    eax = esi;
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((ebp - 0x54)) = eax;
    eax = *((ebp - 0x48));
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((ebp - 0x58)) = eax;
    eax = *((ebp - 0x48));
    eax <<= 4;
    edx = esi;
    edx = ~edx;
    *((ebp - 0x68)) = edx;
    ecx = *((ebp - 0x44));
    eax = eax + ecx + 0x30;
    *((ebp - 0x5c)) = eax;
label_1:
    esi = *((ebp - 0x28));
    eax = *(esi);
    if (*((ebp - 0x50)) >= eax) {
        goto label_9;
    }
    ecx = *((ebp - 0x54));
    edx = *((ecx + 4));
    if (ebx > edx) {
        goto label_9;
    }
    esi = *((ebp - 0x68));
    *((ebp - 0x34)) = esi;
    ecx = *((ebp - 0x48));
    ecx <<= 4;
    esi = *((ebp - 0x44));
    ecx = ecx + esi + 0x50;
    *((ebp - 0x38)) = ecx;
    ecx = *((ebp - 0x5c));
    *((ebp - 0x24)) = ecx;
    ecx = *((ebp - 0x54));
    esi = *((ebp - 0x64));
    *((ebp - 0x1c)) = esi;
    esi = *((ebp - 0x50));
    *((ebp - 0x20)) = esi;
    esi <<= 4;
    esi += *((ebp - 0x44));
    *((ebp - 0x60)) = esi;
label_4:
    if (ebx != edx) {
        goto label_10;
    }
    if (*((ecx + 8)) != 4) {
        goto label_10;
    }
    edx = *((ebp - 0x20));
    edx += 2;
    if (eax <= edx) {
        goto label_11;
    }
    ecx = *((ebp - 0x24));
    if (ebx >= *((ecx + 4))) {
        goto label_11;
    }
    ecx = *((ebp - 0x38));
    ecx += 4;
    while (edx < eax) {
        esi = *(ecx);
        ecx += 0x20;
        if (ebx >= esi) {
            goto label_11;
        }
        edx += 2;
    }
label_11:
    edx += *((ebp - 0x34));
    *((ebp - 0x3c)) = edx;
    esi = *((ebp - 0x28));
    edi = *(esi);
    if (*((ebp - 0x48)) >= edi) {
        goto label_10;
    }
    edx = *((ebp - 0x58));
    eax = *((edx + 4));
    if (ebx > eax) {
        goto label_10;
    }
    edx = *((ebp - 0x1c));
    edx <<= 4;
    ecx = *((ebp - 0x44));
    edx = edx + ecx + 0x10;
    *((ebp - 0x40)) = edx;
    esi = *((ebp - 0x60));
    edx = *((ebp - 0x5c));
    *((ebp - 0x30)) = edx;
    ecx = *((ebp - 0x58));
    *((ebp - 0x2c)) = ecx;
    edx = *((ebp - 0x48));
    *((ebp - 0x1c)) = edx;
    edx = 0;
label_3:
    if (ebx == eax) {
        ecx = *((ebp - 0x2c));
        if (*(ecx) != 2) {
            goto label_12;
        }
        edx = *((ecx + 8));
        goto label_13;
    }
label_12:
    if (edx == 4) {
        goto label_13;
    }
    eax = *((ebp - 0x1c));
    eax++;
    if (edi <= eax) {
        goto label_14;
    }
    if (ebx >= *((esi + 4))) {
        goto label_14;
    }
    edx = *((ebp - 0x30));
    edx += 4;
    while (edi > eax) {
        ecx = *(edx);
        edx += 0x20;
        if (ebx >= ecx) {
            goto label_14;
        }
        eax += 2;
    }
label_14:
    edi = eax;
    edi -= *((ebp - 0x1c));
    *((esp + 0x10)) = 0;
    *((esp + 0xc)) = edi;
    eax = *((ebp - 0x2c));
    *((esp + 8)) = eax;
    edx = *((ebp - 0x3c));
    *((esp + 4)) = edx;
    ecx = *((ebp - 0x40));
    *(esp) = ecx;
    eax = poly2_gcd ();
    if (eax == 0) {
        goto label_15;
    }
label_2:
    if (*(obj.n_tlhs) <= 0) {
        goto label_16;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4)) += ebx;
        eax++;
    } while (*(obj.n_tlhs) > eax);
label_16:
    edx = n_trhs;
    if (edx <= 0) {
        goto label_17;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.trhs);
        *((edx + 4)) += ebx;
        eax++;
        edx = n_trhs;
    } while (edx > eax);
label_17:
    edx -= edi;
    eax = edx;
    esi = *((ebp - 0x28));
    eax += *(esi);
    edx = n_tokens;
    if (eax <= edx) {
        eax -= *((ebp - 0x3c));
        eax += *(obj.n_tlhs);
        if (edx >= eax) {
            goto label_18;
        }
    }
    error_huge ();
label_18:
    eax = *((ebp - 0x1c));
    eax = edi + eax;
    ecx = *((ebp - 0x28));
    edx = *(ecx);
    edx -= eax;
    edx <<= 4;
    eax <<= 4;
    eax += *((ebp - 0x44));
    eax = *((ebp - 0x1c));
    eax += *(obj.n_trhs);
    eax <<= 4;
    eax += *((ebp - 0x44));
    memmove (eax, eax, edx);
    esi = *((ebp - 0x28));
    eax = *(esi);
    eax += *(obj.n_trhs);
    eax -= edi;
    *(esi) = eax;
    eax = *((ebp - 0x1c));
    if (*((ebp - 0x20)) > eax) {
        eax = *((ebp - 0x20));
        eax += *(obj.n_trhs);
        eax -= edi;
        *((ebp - 0x20)) = eax;
    }
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    eax += *((ebp - 0x44));
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x28));
    edx = *(ecx);
    edx -= *((ebp - 0x3c));
    eax = *((ebp - 0x20));
    eax = ~eax;
    eax = edx + eax;
    eax <<= 4;
    edx = *((ebp - 0x20));
    esi = *((ebp - 0x3c));
    eax = edx + esi + 1;
    eax <<= 4;
    eax += *((ebp - 0x44));
    eax = edx;
    eax += *(obj.n_tlhs);
    eax <<= 4;
    ecx = *((ebp - 0x44));
    eax = eax + ecx + 0x10;
    memmove (eax, eax, eax);
    esi = *((ebp - 0x28));
    eax = *(esi);
    eax += *(obj.n_tlhs);
    eax -= *((ebp - 0x3c));
    *(esi) = eax;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    eax = *((ebp - 0x20));
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    memmove (eax, eax, eax);
    *((ebp - 0x4c)) = 1;
    if (*(obj.debug_level) <= 0) {
        goto label_1;
    }
    *((esp + 0xc)) = "Division simplified with polynomial GCD.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((ebp - 0x4c)) = 1;
    goto label_1;
label_15:
    *((esp + 0x10)) = 0;
    ecx = *((ebp - 0x3c));
    *((esp + 0xc)) = ecx;
    eax = *((ebp - 0x40));
    *((esp + 8)) = eax;
    *((esp + 4)) = edi;
    edx = *((ebp - 0x2c));
    *(esp) = edx;
    eax = poly2_gcd ();
    if (eax != 0) {
        edx = *((ebp - 0x1c));
        edx--;
        ecx = *((ebp - 0x20));
        ecx++;
        *((ebp - 0x1c)) = ecx;
        eax = *((ebp - 0x3c));
        *((ebp - 0x3c)) = edi;
        edi = eax;
        *((ebp - 0x20)) = edx;
        goto label_2;
    }
    edx = 4;
label_13:
    *((ebp - 0x1c))++;
    eax = *((ebp - 0x28));
    edi = *(eax);
    if (edi <= *((ebp - 0x1c))) {
        goto label_10;
    }
    *((ebp - 0x2c)) = esi;
    eax = *((esi + 4));
    esi += 0x10;
    *((ebp - 0x30)) += 0x10;
    if (ebx <= eax) {
        goto label_3;
    }
label_10:
    *((ebp - 0x20)) += 2;
    edx = *((ebp - 0x28));
    eax = *(edx);
    if (eax <= *((ebp - 0x20))) {
        goto label_9;
    }
    ecx = *((ebp - 0x20));
    *((ebp - 0x1c)) = ecx;
    ecx = *((ebp - 0x24));
    edx = *((ecx + 4));
    *((ebp - 0x24)) += 0x20;
    *((ebp - 0x34)) -= 2;
    *((ebp - 0x38)) += 0x20;
    if (ebx <= edx) {
        goto label_4;
    }
label_9:
    eax = *((ebp - 0x4c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8067931 */
#include <stdint.h>
 
int32_t dbg_pf_sub (uint32_t arg_10h, int32_t arg_14h, int32_t arg_18h, long int v1, int32_t loct, int32_t loc, long int last_v, int32_t lent) {
    int32_t var_2078h;
    int32_t var_2074h;
    int32_t loc2;
    int32_t len_first;
    int32_t old_partial;
    int32_t var_2064h;
    int32_t var_2060h;
    int32_t var_205ch;
    int32_t modified;
    int32_t var_2054h;
    uint32_t var_2050h;
    int32_t count;
    int32_t var_2048h;
    int32_t var_2044h;
    int32_t var_2040h;
    int32_t loc1;
    int32_t var_2038h;
    int32_t var_2034h;
    uint32_t var_2030h;
    int32_t cnt;
    int32_t var_2028h;
    int32_t var_2024h;
    int32_t var_2020h;
    int32_t vc;
    sort_type[1000] va;
    jmp_buf save_save;
    double d;
    int32_t div_flag;
    long int v;
    int32_t k;
    int32_t j;
    int32_t len;
    int32_t do_repeat;
    void * s2;
    size_t n;
    char * var_ch;
    ebx = v1;
    ecx = loct;
    edx = loc;
    esi = last_v;
    eax = lent;
    /* int pf_sub(token_type * equation,int * np,int loc,int len,int level,int do_repeat); */
    *((ebp - 0x2044)) = eax;
    *((ebp - 0x2060)) = edx;
    *((ebp - 0x2064)) = ecx;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 3;
    if (*(obj.debug_level) > 2) {
        *((esp + 0xc)) = "Entering pf_sub().";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = partial_flag;
    *((ebp - 0x2068)) = eax;
    eax = *((ebp - 0x2064));
    eax <<= 4;
    eax += *((ebp - 0x2044));
    *((ebp - 0x205c)) = eax;
    eax = ebp - 0x28;
    *((esp + 0x18)) = eax;
    eax = ebp - 0x20;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x30;
    *((esp + 0xc)) = eax;
    eax = ebp - 0x24;
    *((esp + 8)) = eax;
    edx = *((ebp + 8));
    *((esp + 4)) = edx;
    ebx = *((ebp - 0x205c));
    *(esp) = ebx;
    find_greatest_power ();
    if (*((ebp - 0x24)) == 0) {
        goto label_6;
    }
    eax = ebp - 0xcc;
    memmove (eax, 0x8079600, 0x9c);
    eax = setjmp (obj.jmp_save);
    *((ebp - 0x2030)) = eax;
    if (eax == 0) {
        eax = *((ebp - 0x2064));
        *((ebp - 0x203c)) = eax;
        if (*((ebp + 0x10)) == 0) {
            goto label_7;
        }
        *((ebp - 0x2070)) = eax;
        *((ebp - 0x2048)) = 2;
        *((ebp - 0x2050)) = 0;
        *((ebp - 0x206c)) = 0;
        *((ebp - 0x2058)) = 0;
        esi = ebp - 0x200c;
        *((ebp - 0x2038)) = 1;
    } else {
        ebx = *((ebp - 0x2068));
        *(obj.partial_flag) = ebx;
        eax = ebp - 0xcc;
        memmove (obj.jmp_save, eax, 0x9c);
        if (*((ebp - 0x2030)) != 0xd) {
            goto label_6;
        }
        *((esp + 4)) = 0xd;
        *(esp) = obj.jmp_save;
        longjmp_chk ();
label_1:
        *((ebp - 0x2048))++;
        *((ebp - 0x2058)) = 1;
    }
    eax = *((ebp - 0x2048));
    eax--;
    *((ebp - 0x204c)) = eax;
    eax = *((ebp - 0x203c));
    eax <<= 4;
    eax += *((ebp - 0x2044));
    *((ebp - 0x2040)) = eax;
    eax = *((ebp + 8));
    eax <<= 4;
    edx = *((ebp - 0x2040));
    eax = trhs;
    memmove (eax, edx, eax);
    ebx = *((ebp + 8));
    *(obj.n_trhs) = ebx;
    *(obj.partial_flag) = 0;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    uf_simp ();
    eax = *((ebp - 0x2068));
    *(obj.partial_flag) = eax;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    eax = level1_plus_count ();
    if (eax <= 1) {
        goto label_8;
    }
    edi = n_trhs;
    edx = trhs;
    *((ebp - 0x2034)) = edx;
    if (edi <= 0) {
        goto label_9;
    }
    goto label_10;
    do {
        ebx = ecx;
label_0:
        if (*(eax) == 1) {
            ecx = *((eax + 8));
            if (ecx > *((ebp - 0x2028))) {
                if (ebx == -1) {
                    goto label_11;
                }
                if (ecx < ebx) {
                    goto label_11;
                }
                if (ebx != ecx) {
                    goto label_12;
                }
                *((ebp - 0x202c))++;
                ecx = ebx;
            }
        } else {
label_12:
            ecx = ebx;
            goto label_13;
label_11:
            ebx = *((ebp - 0x2038));
            *((ebp - 0x202c)) = ebx;
        }
label_13:
        edx += 2;
        eax += 0x20;
    } while (edx < edi);
    if (ecx != -1) {
        edx = *((ebp - 0x201c));
        *((esi + edx*8)) = ecx;
        ebx = *((ebp - 0x202c));
        *((esi + edx*8 + 4)) = ebx;
        edx++;
        *((ebp - 0x201c)) = edx;
        if (edx != 0x3e8) {
            goto label_14;
        }
        goto label_15;
label_10:
        *((ebp - 0x2028)) = 0;
        *((ebp - 0x201c)) = 0;
label_5:
        eax = *((ebp - 0x2034));
        edx = *((ebp - 0x2030));
        *((ebp - 0x202c)) = 0;
        ebx = 0xffffffff;
        goto label_0;
label_9:
        *((ebp - 0x201c)) = 0;
    }
label_15:
    eax = *((ebp - 0x2040));
    *((ebp - 0x2054)) = eax;
    *((esp + 0x10)) = 0;
    edx = *((ebp + 8));
    list_debug (0, eax, edx);
    *((esp + 0x10)) = 0;
    eax = n_trhs;
    eax = trhs;
    list_debug (0, eax, eax);
    eax = *((ebp - 0x24));
    if (eax != 0) {
        *((esp + 0xc)) = 1;
        *((esp + 8)) = eax;
        eax = n_trhs;
        *((esp + 4)) = eax;
        eax = trhs;
        eax = poly_in_v (eax);
        if (eax != 0) {
            goto label_16;
        }
        *((ebp - 0x24)) = 0;
    }
label_16:
    if (*((ebp - 0x201c)) <= 0) {
        goto label_8;
    }
    ebx = *((ebp - 0x2030));
    *((ebp - 0x2024)) = 0xffffffff;
    do {
        *((ebp - 0x2020)) = ebx;
        edi = *((esi + ebx*8));
        eax = *((esi + ebx*8));
        eax &= 0x3fff;
        if (eax > 4) {
            if (*((ebp - 0x24)) == 0) {
                *((esp + 0xc)) = 1;
                *((esp + 8)) = edi;
                eax = n_trhs;
                *((esp + 4)) = eax;
                eax = trhs;
                eax = poly_in_v (eax);
                if (eax == 0) {
                    goto label_17;
                }
                *((ebp - 0x24)) = edi;
            }
label_17:
            if (*((ebp - 0x2024)) >= 0) {
                edx = *((ebp - 0x2024));
                eax = *((ebp - 0x2020));
                if (edx <= *((esi + eax*8 + 4))) {
                    goto label_18;
                }
            }
            eax = *((ebp - 0x2020));
            eax = *((esi + eax*8 + 4));
            *((ebp - 0x2024)) = eax;
        }
label_18:
        ebx++;
    } while (ebx < *((ebp - 0x201c)));
    if (*((ebp - 0x2024)) <= 1) {
        goto label_8;
    }
    if (*((ebp - 0x24)) == 0) {
        goto label_8;
    }
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = tlhs;
    memmove (eax, eax, eax);
    eax = n_trhs;
    *(obj.n_tlhs) = eax;
    eax = *((ebp - 0x24));
    *((esp + 8)) = eax;
    eax = tlhs;
    eax = differentiate (eax, 0x80796b8);
    if (eax == 0) {
        goto label_8;
    }
    if (*(obj.debug_level) > 2) {
        eax = *((ebp - 0x24));
        list_var (eax, 0);
        *((esp + 0xc)) = 0x8079800;
        *((esp + 8)) = "Differentiation successful using variable (%s).\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = tlhs;
    simp_loop (eax, obj.n_tlhs);
    eax = n_tlhs;
    ecx = eax + 2;
    edx = 0x7530;
    if (*(obj.n_tokens) <= 0x7530) {
        edx = *(obj.n_tokens);
    }
    if (ecx > edx) {
        goto label_19;
    }
    if (eax <= 0) {
        goto label_20;
    }
    edx = *((ebp - 0x2030));
    do {
        eax = *((ebp - 0x2030));
        eax <<= 4;
        eax += *(obj.tlhs);
        *((eax + 4))++;
        edx++;
        eax = n_tlhs;
    } while (eax > edx);
label_20:
    eax <<= 4;
    edx = tlhs;
    *((eax + edx)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 3;
    edx = n_tlhs;
    edx++;
    *(obj.n_tlhs) = edx;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    ecx = *((ebp - 0x24));
    eax = tlhs;
    *((edx + eax + 8)) = ecx;
    *(obj.n_tlhs)++;
    *((esp + 4)) = 0x80796b8;
    eax = tlhs;
    *(esp) = eax;
    uf_simp ();
    eax = *((ebp - 0x24));
    *((esp + 0x10)) = eax;
    eax = n_tlhs;
    *((esp + 0xc)) = eax;
    eax = tlhs;
    *((esp + 8)) = eax;
    edx = *((ebp + 8));
    ebx = *((ebp - 0x2054));
    eax = poly_gcd (ebx, edx);
    if (eax != 0) {
        eax = n_tlhs;
        *((esp + 4)) = eax;
        eax = tlhs;
        *(esp) = eax;
        eax = level1_plus_count ();
        if (eax == 0) {
            goto label_19;
        }
        eax = *((ebp + 0xc));
        *((esp + 4)) = eax;
        edx = *((ebp + 8));
        ecx = *((ebp - 0x203c));
        edx = *((ebp - 0x2060));
        eax = *((ebp - 0x2044));
        save_factors (edx);
        eax = n_tlhs;
        ebx = *((ebp - 0x203c));
        ebx = eax + ebx + 1;
        *((ebp - 0x203c)) = ebx;
        edx = n_trhs;
        *((ebp + 8)) = edx;
        if (*((ebp - 0x204c)) != 1) {
            if (*((ebp - 0x204c)) != 2) {
                eax = *((ebp - 0x2050));
            }
            *((ebp - 0x2050)) = eax;
            goto label_1;
        }
        if (*(obj.debug_level) > 0) {
            *((esp + 0xc)) = "Polynomial with repeated factor factored.";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        ebx = n_tlhs;
        *((ebp - 0x206c)) = ebx;
        eax = *((ebp - 0x203c));
        *((ebp - 0x2070)) = eax;
        goto label_1;
    }
label_19:
    if (*((ebp - 0x2058)) != 0) {
        goto label_21;
    }
label_7:
    edx = *((ebp + 8));
    edx <<= 4;
    *((ebp - 0x2078)) = edx;
    eax = *((ebp - 0x203c));
    eax <<= 4;
    eax += *((ebp - 0x2044));
    *((ebp - 0x2074)) = eax;
    esi = 0;
    ebx = *((ebp + 8));
label_3:
    eax = *((ebp - 0x2078));
    edx = *((ebp - 0x205c));
    eax = trhs;
    memmove (eax, edx, eax);
    *(obj.n_trhs) = ebx;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    uf_simp ();
    *((ebp - 0x24)) = 0xffffffff;
    if (ebx <= 0) {
        goto label_22;
    }
    goto label_23;
label_2:
    *((ebp - 0x24)) = 0xffffffff;
label_23:
    eax = *((ebp - 0x205c));
    edx = *((ebp - 0x2030));
    do {
        if (*(eax) == 1) {
            ecx = *((eax + 8));
            if (esi >= ecx) {
                goto label_24;
            }
            edi = *((ebp - 0x24));
            if (edi != -1) {
                if (ecx >= edi) {
                    goto label_24;
                }
            }
            *((ebp - 0x24)) = ecx;
        }
label_24:
        edx += 2;
        eax += 0x20;
    } while (edx < ebx);
    esi = *((ebp - 0x24));
    if (esi == -1) {
        goto label_22;
    }
    eax = ebp - 0x28;
    *((esp + 0x18)) = eax;
    edx = ebp - 0x20;
    *((esp + 0x14)) = edx;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    edx = ebp - 0x30;
    *((esp + 0xc)) = edx;
    eax = ebp - 0x24;
    *((esp + 8)) = eax;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    eax = find_greatest_power ();
    if (eax <= 1) {
        goto label_2;
    }
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = tlhs;
    memmove (eax, eax, eax);
    eax = n_trhs;
    *(obj.n_tlhs) = eax;
    while (eax != 0) {
        eax = tlhs;
        simp_loop (eax, obj.n_tlhs);
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x24));
        *((esp + 8)) = eax;
        *((esp + 4)) = 0x80796b8;
        eax = tlhs;
        *(esp) = eax;
        eax = factor_plus ();
    }
    eax = ebp - 0x28;
    *((esp + 0x18)) = eax;
    edx = ebp - 0x20;
    *((esp + 0x14)) = edx;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    edx = ebp - 0x30;
    *((esp + 0xc)) = edx;
    eax = ebp - 0x24;
    *((esp + 8)) = eax;
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    *(esp) = eax;
    eax = find_greatest_power ();
    if (eax != 1) {
        goto label_2;
    }
    eax = tlhs;
    edx = *((ebp - 0x20));
    edx <<= 4;
    edx = *((ebp - 0x1c));
    edx <<= 4;
    edx = eax + edx;
    memmove (eax, edx, edx);
    eax = *((ebp - 0x20));
    *(obj.n_tlhs) = eax;
    if (*(obj.debug_level) > 2) {
        *((esp + 8)) = "Trying factor: ";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 8)) = 0;
        eax = n_tlhs;
        *((esp + 4)) = eax;
        eax = tlhs;
        *(esp) = eax;
        list_proc ();
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 0x10)) = 0;
    eax = n_tlhs;
    *((esp + 0xc)) = eax;
    eax = tlhs;
    *((esp + 8)) = eax;
    edx = *((ebp - 0x2074));
    eax = poly_gcd (edx, ebx);
    if (eax == 0) {
        goto label_3;
    }
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    *(esp) = eax;
    eax = level1_plus_count ();
    if (eax == 0) {
        goto label_3;
    }
    if (*(obj.debug_level) > 0) {
        *((esp + 0xc)) = "Symbolic polynomial factored.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    eax = *((ebp + 8));
    ecx = *((ebp - 0x203c));
    edx = *((ebp - 0x2060));
    eax = *((ebp - 0x2044));
    save_factors (eax);
    ebx = 1;
    goto label_25;
label_8:
    eax = ebp - 0xcc;
    memmove (obj.jmp_save, eax, 0x9c);
    while (1) {
        if (*((ebp - 0x2050)) == 0) {
            eax = *((ebp - 0x206c));
            edx = *((ebp - 0x2064));
        } else {
            eax = *((ebp - 0x2050));
            edx = *((ebp - 0x2070));
        }
        ecx = *((ebp - 0x24));
        *((esp + 0x10)) = ecx;
        *((esp + 0xc)) = eax;
        eax = edx;
        eax <<= 4;
        eax += *((ebp - 0x2044));
        *((esp + 8)) = eax;
        edx = *((ebp + 8));
        ebx = *((ebp - 0x2040));
        eax = poly_gcd (ebx, edx);
        if (eax != 0) {
            eax = *((ebp + 0xc));
            *((esp + 4)) = eax;
            edx = *((ebp + 8));
            ecx = *((ebp - 0x203c));
            edx = *((ebp - 0x2060));
            eax = *((ebp - 0x2044));
            save_factors (edx);
            eax = n_tlhs;
            ebx = *((ebp - 0x203c));
            ebx = ebx + eax + 1;
            *((ebp - 0x203c)) = ebx;
            eax = n_trhs;
            *((ebp + 8)) = eax;
        }
        edx = *((ebp - 0x2070));
        if (*((ebp - 0x2050)) == 0) {
            edx = *((ebp - 0x203c));
        }
        ebx = *((ebp - 0x2050));
        if (*((ebp - 0x2050)) == 0) {
            ebx = *((ebp + 8));
        }
        *((esp + 0x10)) = 0;
        *((esp + 0xc)) = ebx;
        eax = edx;
        eax <<= 4;
        eax += *((ebp - 0x2044));
        *((esp + 8)) = eax;
        eax = *((ebp - 0x206c));
        edx = *((ebp - 0x205c));
        eax = poly_gcd (edx, eax);
        if (eax != 0) {
            ebx = *((ebp + 0xc));
            *((esp + 4)) = ebx;
            eax = *((ebp - 0x206c));
            ecx = *((ebp - 0x2064));
            edx = *((ebp - 0x2060));
            eax = *((ebp - 0x2044));
            save_factors (eax);
            ebx = 0;
        } else {
            ebx = 0;
        }
label_4:
        eax = *((ebp - 0x2058));
        eax |= ebx;
        goto label_26;
label_6:
        eax = 0;
label_26:
        return eax;
label_21:
        eax = ebp - 0xcc;
        memmove (obj.jmp_save, eax, 0x9c);
    }
label_22:
    ebx = 0;
label_25:
    eax = ebp - 0xcc;
    memmove (obj.jmp_save, eax, 0x9c);
    *((ebp - 0x2058)) = 0;
    goto label_4;
label_14:
    *((ebp - 0x2028)) = ecx;
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80684bf */
#include <stdint.h>
 
int32_t dbg_pf_recurse (int32_t arg_8h, size_t * arg_ch, int32_t level, int32_t i, int32_t loc, token_type * equation) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t op;
    int32_t var_1ch;
    size_t * var_4h;
    size_t * var_8h;
    ebx = level;
    ecx = i;
    edx = loc;
    edi = equation;
    /* int pf_recurse(token_type * equation,int * np,int loc,int level,int do_repeat); */
label_0:
    edi = eax;
    *((ebp - 0x1c)) = edx;
    *((ebp - 0x24)) = ecx;
    ebx = *((ebp + 8));
    edx = ecx;
    edx++;
    eax = *((ebp - 0x1c));
    eax = *(eax);
    *((ebp - 0x28)) = eax;
    if (edx >= eax) {
        goto label_2;
    }
    esi = edx;
    esi <<= 4;
    esi = edi + esi;
    ecx = *((esi + 4));
    if (ebx > ecx) {
        goto label_2;
    }
    eax = *((ebp - 0x24));
    eax <<= 4;
    eax = eax + edi + 0x30;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x2c)) = edi;
    edi = *((ebp - 0x28));
    do {
        if (ecx == ebx) {
            esi = *((esi + 8));
            *((ebp - 0x20)) = esi;
        }
        edx += 2;
        if (edi <= edx) {
            goto label_3;
        }
        esi = eax;
        ecx = *((eax + 4));
        eax += 0x20;
    } while (ecx >= ebx);
label_3:
    edi = *((ebp - 0x2c));
    eax = *((ebp - 0x20));
    eax--;
    if (eax <= 1) {
        eax = *((ebp + 0xc));
        edx -= *((ebp - 0x24));
        ecx = *((ebp - 0x24));
        edx = *((ebp - 0x1c));
        eax = edi;
        eax = pf_sub (edx, ebx, eax);
        *((ebp - 0x20)) = eax;
    } else {
label_2:
        *((ebp - 0x20)) = 0;
    }
    esi = *((ebp - 0x24));
    edx = ebx + 1;
    *((ebp - 0x24)) = edx;
    goto label_4;
label_1:
    if (ebx >= eax) {
        goto label_5;
    }
    eax = *((ebp + 0xc));
    edx = *((ebp - 0x24));
    ecx = esi;
    edx = *((ebp - 0x1c));
    eax = edi;
    eax = pf_recurse (edx, eax);
    goto label_0;
    *((ebp - 0x20)) |= eax;
    eax = esi + 1;
    edx = *((ebp - 0x1c));
    ecx = *(edx);
    if (ecx <= eax) {
        goto label_6;
    }
    edx = eax;
    edx <<= 4;
    if (ebx >= *((edx + edi + 4))) {
        goto label_6;
    }
    esi <<= 4;
    edx = edi + esi + 0x34;
    do {
        eax += 2;
        if (ecx <= eax) {
            goto label_6;
        }
        esi = *(edx);
        edx += 0x20;
    } while (ebx < esi);
    goto label_6;
label_5:
    eax = esi + 1;
label_6:
    esi = eax;
label_4:
    eax = *((ebp - 0x1c));
    if (esi >= *(eax)) {
        goto label_7;
    }
    eax = esi;
    eax <<= 4;
    eax = *((eax + edi + 4));
    if (ebx <= eax) {
        goto label_1;
    }
label_7:
    eax = *((ebp - 0x20));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8068bb6 */
#include <stdint.h>
 
int32_t dbg_d_recurse (size_t * arg_8h, size_t * arg_ch, int32_t endloc, int32_t i, int32_t loc, int32_t level, int32_t j, token_type * equation) {
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    size_t * var_50h;
    int32_t oploc;
    size_t * var_48h;
    size_t * s1;
    size_t * var_40h;
    int32_t op;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    complexs c;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_ch;
    size_t * var_4h_2;
    size_t * s2;
    size_t n;
    int32_t var_sp_ch;
    int32_t var_10h;
    ebx = endloc;
    ecx = i;
    edx = loc;
    esi = level;
    edi = j;
    eax = equation;
    /* int d_recurse(token_type * equation,int * np,int loc,int level,long int v); */
label_0:
    *((ebp - 0x44)) = eax;
    *((ebp - 0x50)) = edx;
    *((ebp - 0x40)) = ecx;
    esi = *((ebp + 8));
    *((ebp - 0x58)) = ecx;
    eax = ecx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((ebp - 0x48)) = eax;
    if (*((eax + 4)) < esi) {
        if (*(eax) == 1) {
            if (*((ebp + 0xc)) == 5) {
                eax = *((eax + 8));
                eax &= 0x3fff;
                if (eax > 4) {
                    goto label_3;
                }
            }
            ebx = *((ebp + 0xc));
            ecx = *((ebp - 0x48));
            if (*((ecx + 8)) != ebx) {
                goto label_4;
            }
label_3:
            esi = *((ebp - 0x48));
            *(esi) = 0;
            *(fp_stack--) = 1.0;
            *((esi + 8)) = fp_stack[0];
            fp_stack--;
            eax = 1;
            goto label_5;
        }
label_4:
        eax = *((ebp - 0x48));
        *(eax) = 0;
        *(fp_stack--) = 0.0;
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = 1;
        goto label_5;
    }
    ebx = *((ebp - 0x40));
    ebx++;
    eax = *((ebp - 0x50));
    edi = *(eax);
    if (ebx >= edi) {
        goto label_6;
    }
    ecx = ebx;
    ecx <<= 4;
    ecx += *((ebp - 0x44));
    *((ebp - 0x5c)) = ecx;
    edx = *((ecx + 4));
    if (esi > edx) {
        goto label_6;
    }
    ecx = *((ebp - 0x40));
    ecx <<= 4;
    eax = *((ebp - 0x44));
    eax = ecx + eax + 0x30;
    *((ebp - 0x54)) = eax;
    *((ebp - 0x4c)) = ebx;
    *((ebp - 0x3c)) = 0;
    ecx = *((ebp - 0x5c));
    do {
        if (esi == edx) {
            if (*((ebp - 0x3c)) > 2) {
                error_bug ("Internal error in d_recurse(): differentiating with unparenthesized operators is not allowed.");
                eax = 0;
                goto label_5;
            }
            ecx = *((ecx + 8));
            *((ebp - 0x3c)) = ecx;
            *((ebp - 0x4c)) = ebx;
        }
        ebx += 2;
        if (ebx >= edi) {
            goto label_7;
        }
        ecx = eax;
        edx = *((eax + 4));
        eax += 0x20;
    } while (esi <= edx);
label_7:
    edx = *((ebp - 0x4c));
    *((ebp - 0x54)) = edx;
    if (*((ebp - 0x3c)) <= 6) {
        ecx = *((ebp - 0x3c));
        /* switch table (7 cases) at 0x8077494 */
        if (*((ebp - 0x54)) < ebx) {
            goto label_8;
        }
        goto label_9;
    }
    if (*((ebp - 0x40)) >= ebx) {
        goto label_10;
    }
    eax = *((ebp - 0x48));
    edx = *((ebp - 0x40));
    *((ebp - 0x4c)) = esi;
    ecx = *((ebp + 0xc));
    do {
        if (*(eax) == 1) {
            if (ecx == 5) {
                esi = *((eax + 8));
                esi &= 0x3fff;
                if (esi > 4) {
                    goto label_11;
                }
            }
            if (*((eax + 8)) == ecx) {
                goto label_11;
            }
        }
        edx += 2;
        eax += 0x20;
    } while (edx < ebx);
    esi = *((ebp - 0x4c));
label_10:
    edi -= ebx;
    eax = edi;
    eax <<= 4;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    eax = *((ebp - 0x58));
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x50));
    eax = *(ecx);
    edx = *((ebp - 0x40));
    edx -= ebx;
    eax = edx + eax + 1;
    *(ecx) = eax;
    ecx = *((ebp - 0x48));
    *((ecx + 4)) = esi;
    *(ecx) = 0;
    *(fp_stack--) = 0.0;
    *((ecx + 8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    goto label_5;
label_1:
    if (*(eax) == 2) {
        goto label_12;
    }
    eax = *((ebp + 0xc));
    edx = *((ebp - 0x40));
    ecx = ebx;
    edx = edi;
    eax = *((ebp - 0x44));
    eax = d_recurse (edx, eax);
    goto label_0;
    if (eax == 0) {
        goto label_11;
    }
    eax = ebx + 1;
    ecx = *(edi);
    *((ebp - 0x48)) = ecx;
    if (eax >= ecx) {
        goto label_13;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x44));
    if (esi >= *((edx + ecx + 4))) {
        goto label_13;
    }
    edx = ebx;
    edx <<= 4;
    edx = ecx + edx + 0x34;
    ecx = *((ebp - 0x48));
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_13;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (esi < ebx);
    goto label_13;
label_12:
    eax = ebx + 1;
label_13:
    ebx = eax;
    goto label_14;
label_6:
    ebx = *((ebp - 0x40));
    edi = esi + 1;
    *((ebp - 0x40)) = edi;
    edi = *((ebp - 0x50));
label_14:
    if (ebx >= *(edi)) {
        goto label_15;
    }
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    if (esi <= *((eax + 4))) {
        goto label_1;
    }
    goto label_15;
    eax = ebx;
    eax -= *((ebp - 0x40));
    *((ebp - 0x3c)) = eax;
    eax = edi + eax + 1;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0x40)) >= ebx) {
        goto label_16;
    }
    eax = *((ebp - 0x48));
    eax += 4;
    edx = *((ebp - 0x40));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (edx < ebx);
label_16:
    edx = *((ebp - 0x50));
    eax = *(edx);
    eax -= *((ebp - 0x40));
    eax <<= 4;
    ecx = *((ebp - 0x48));
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    memmove (eax, ecx, eax);
    ecx = *((ebp - 0x50));
    eax = *(ecx);
    edx = *((ebp - 0x3c));
    eax = edx + eax + 1;
    *(ecx) = eax;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((eax + 4)) = esi;
    *(eax) = 2;
    *((eax + 8)) = 1;
    esi += 2;
    edi = *((ebp - 0x54));
    edi -= *((ebp - 0x40));
    ecx = ebx + edi + 2;
    ebx = *((ebp + 0xc));
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x44));
    eax = d_recurse (esi, ebx);
    goto label_0;
    if (eax == 0) {
        goto label_11;
    }
    ecx = *((ebp - 0x40));
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x44));
    d_recurse (esi, ebx);
    goto label_0;
    goto label_5;
    eax = ebx;
    eax -= *((ebp - 0x40));
    *((ebp - 0x3c)) = eax;
    edx = ebx;
    edx -= *((ebp - 0x54));
    *((ebp - 0x4c)) = edx;
    eax = edi + eax + 3;
    eax += edx;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0x40)) >= ebx) {
        goto label_17;
    }
    eax = *((ebp - 0x48));
    eax += 4;
    edx = *((ebp - 0x40));
    do {
        *(eax) += 2;
        edx++;
        eax += 0x10;
    } while (edx < ebx);
label_17:
    eax = *((ebp - 0x54));
    eax <<= 4;
    ecx = *((ebp - 0x44));
    *((eax + ecx + 8)) = 3;
    edi = *((ebp - 0x3c));
    edi++;
    edx = *((ebp - 0x50));
    eax = *(edx);
    eax -= *((ebp - 0x40));
    eax <<= 4;
    ecx = *((ebp - 0x48));
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    memmove (eax, ecx, eax);
    ecx = *((ebp - 0x50));
    *(ecx) += edi;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    edx = esi + 1;
    *((ebp - 0x48)) = edx;
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 2;
    edi += ebx;
    *((ebp - 0x3c)) = edi;
    edi <<= 4;
    edi += *((ebp - 0x44));
    eax = *(ecx);
    eax -= *((ebp - 0x3c));
    eax <<= 4;
    edx = *((ebp - 0x3c));
    ecx = *((ebp - 0x4c));
    eax = edx + ecx + 2;
    eax <<= 4;
    eax += *((ebp - 0x44));
    memmove (eax, edi, eax);
    ecx = *((ebp - 0x50));
    eax = *(ecx);
    edx = *((ebp - 0x4c));
    eax = edx + eax + 2;
    *(ecx) = eax;
    *((edi + 4)) = esi;
    *(edi) = 2;
    *((edi + 8)) = 4;
    eax = *((ebp - 0x54));
    eax = ~eax;
    eax += ebx;
    eax <<= 4;
    eax = *((ebp - 0x54));
    eax <<= 4;
    ecx = *((ebp - 0x44));
    eax = eax + ecx + 0x10;
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax = eax + ecx + 0x10;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x3c));
    edx += *((ebp - 0x4c));
    eax = edx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    ecx = *((ebp - 0x48));
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 6;
    eax = edx;
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    *((eax + 4)) = ecx;
    *(eax) = 0;
    *(fp_stack--) = *(0x8072058);
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    esi += 3;
    edi = *((ebp - 0x54));
    edi -= *((ebp - 0x40));
    ecx = ebx + edi + 2;
    eax = *((ebp + 0xc));
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x44));
    eax = d_recurse (esi, eax);
    goto label_0;
    if (eax == 0) {
        goto label_11;
    }
    edx = *((ebp + 0xc));
    ecx = *((ebp - 0x40));
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x44));
    d_recurse (esi, edx);
    goto label_0;
    goto label_5;
label_8:
    edi = *((ebp - 0x54));
    eax = *((ebp - 0x54));
    eax <<= 4;
    eax += *((ebp - 0x44));
    edx = *((ebp - 0x4c));
    *((ebp - 0x3c)) = edi;
    ecx = *((ebp + 0xc));
label_2:
    if (*(eax) != 1) {
        goto label_18;
    }
    if (ecx == 5) {
        edi = *((eax + 8));
        edi &= 0x3fff;
        if (edi > 4) {
            goto label_19;
        }
    }
    if (*((eax + 8)) != ecx) {
        goto label_18;
    }
label_19:
    edi = *((ebp - 0x3c));
    eax = ebp - 0x28;
    *((esp + 8)) = eax;
    eax = *((ebp - 0x54));
    eax -= *((ebp - 0x40));
    ecx = *((ebp - 0x48));
    eax = parse_complex (ecx, eax);
    if (eax == 0) {
        goto label_11;
    }
    eax = ebp - 0x38;
    edx = *((ebp - 0x28));
    *((esp + 4)) = edx;
    edx = *((ebp - 0x24));
    *((esp + 8)) = edx;
    edx = *((ebp - 0x20));
    *((esp + 0xc)) = edx;
    edx = *((ebp - 0x1c));
    *((esp + 0x10)) = edx;
    complex_log (eax);
    eax = *((ebp - 0x38));
    *((ebp - 0x28)) = eax;
    eax = *((ebp - 0x34));
    *((ebp - 0x24)) = eax;
    eax = *((ebp - 0x30));
    *((ebp - 0x20)) = eax;
    eax = *((ebp - 0x2c));
    *((ebp - 0x1c)) = eax;
    eax = ebx + 6;
    eax -= *((ebp - 0x54));
    *((ebp - 0x4c)) = eax;
    edx = *((ebp - 0x50));
    eax += *(edx);
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    *((ebp - 0x3c)) = eax;
    ecx = *((ebp - 0x50));
    eax = *(ecx);
    eax -= ebx;
    eax <<= 4;
    eax = *((ebp - 0x3c));
    eax = *((ebp - 0x4c));
    eax += ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x4c));
    edx = *((ebp - 0x50));
    *(edx) += ecx;
    eax = *((ebp - 0x3c));
    *((eax + 4)) = esi;
    *(eax) = 2;
    *((eax + 8)) = 3;
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    ecx = esi + 1;
    *((ebp - 0x3c)) = ecx;
    *((eax + 4)) = ecx;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x28));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = ebx;
    eax <<= 4;
    eax = eax + edx + 0x20;
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 1;
    eax = ebx;
    eax <<= 4;
    eax = eax + edx + 0x30;
    edx = esi + 2;
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x20));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp - 0x44));
    eax = eax + ecx + 0x40;
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 3;
    eax = ebx;
    eax <<= 4;
    eax = eax + ecx + 0x50;
    *((eax + 4)) = edx;
    *(eax) = 1;
    *((eax + 8)) = 3;
    eax = ebx;
    eax <<= 4;
    eax = eax + ecx + 0x60;
    *((eax + 4)) = esi;
    *(eax) = 2;
    *((eax + 8)) = 3;
    esi = ebx + 7;
    eax = *((ebp - 0x54));
    eax = ~eax;
    eax += ebx;
    eax <<= 4;
    eax = edi;
    eax <<= 4;
    eax = eax + ecx + 0x10;
    eax = esi;
    eax <<= 4;
    eax += ecx;
    memmove (eax, eax, eax);
    if (*((ebp - 0x40)) >= ebx) {
        goto label_20;
    }
    eax = *((ebp - 0x48));
    eax += 4;
    edx = *((ebp - 0x40));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (ebx > edx);
label_20:
    ebx = *((ebp + 0xc));
    eax = *((ebp - 0x3c));
    ecx = esi;
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x44));
    eax = d_recurse (eax, ebx);
    goto label_0;
    goto label_5;
label_18:
    edx++;
    eax += 0x10;
    if (ebx > edx) {
        goto label_2;
    }
label_9:
    eax = *((ebp - 0x54));
    eax = ~eax;
    eax += ebx;
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x58)) = eax;
    edi = eax;
    edi <<= 4;
    eax = *((ebp - 0x54));
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = eax + edx + 0x10;
    eax = scratch;
    memmove (eax, eax, edi);
    eax = scratch;
    *((eax + edi + 4)) = esi;
    eax = scratch;
    *((eax + edi)) = 2;
    eax = scratch;
    *((eax + edi + 8)) = 3;
    ecx = *((ebp - 0x4c));
    ecx++;
    *((ebp - 0x3c)) = ecx;
    edi = ebx;
    edi -= *((ebp - 0x40));
    eax = edi + ecx + 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edi <<= 4;
    eax = *((ebp - 0x48));
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, edi);
    eax = *((ebp - 0x54));
    eax -= *((ebp - 0x40));
    edx = *((ebp - 0x3c));
    edi = edx + eax + 1;
    eax = edx;
    if (edx >= edi) {
        goto label_21;
    }
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (edi > eax);
    eax = edi;
    eax -= *((ebp - 0x58));
    ecx = *((ebp - 0x3c));
    eax = ecx + eax - 1;
label_21:
    edi += *((ebp - 0x4c));
    if (eax >= edi) {
        goto label_22;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += 2;
        eax++;
        edx += 0x10;
    } while (edi > eax);
label_22:
    edx = edi;
    edx <<= 4;
    ecx = esi + 2;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 2;
    edx = edi + 1;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = 1.0;
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    edi += 2;
    eax = *((ebp - 0x54));
    eax -= *((ebp - 0x40));
    *((ebp - 0x54)) = eax;
    eax = eax + edi + 1;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edx = edi;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = esi;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    edi++;
    *((ebp - 0x3c)) = edi;
    eax = *((ebp - 0x54));
    eax <<= 4;
    edx = *((ebp - 0x48));
    eax = edi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, edx, eax);
    edi = *((ebp - 0x3c));
    edi += *((ebp - 0x54));
    eax = *((ebp - 0x40));
    ecx = *((ebp - 0x50));
    eax += *(ecx);
    eax -= ebx;
    eax += edi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp - 0x40));
    eax += edi;
    *((ebp - 0x4c)) = eax;
    edx = *((ebp - 0x50));
    eax = *(edx);
    eax -= ebx;
    eax <<= 4;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x44));
    eax = *((ebp - 0x4c));
    eax <<= 4;
    eax += *((ebp - 0x44));
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x4c));
    ecx -= ebx;
    eax = *((ebp - 0x50));
    *(eax) += ecx;
    edi <<= 4;
    eax = scratch;
    edx = *((ebp - 0x48));
    memmove (edx, eax, edi);
    ecx = *((ebp - 0x3c));
    ecx += *((ebp - 0x40));
    ebx = *((ebp + 0xc));
    esi++;
    edx = *((ebp - 0x50));
    eax = *((ebp - 0x44));
    d_recurse (esi, ebx);
    goto label_0;
    goto label_5;
label_11:
    eax = 0;
    goto label_5;
label_15:
    eax = 1;
label_5:
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806b9bb */
#include <stdint.h>
 
int32_t dbg_inv_laplace_sub (int32_t arg_14h, int32_t k, int32_t i, int32_t j, int32_t level) {
    int32_t mlevel;
    int32_t var_28h;
    int32_t len;
    int32_t var_20h;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    int32_t loc;
    long int v;
    void * s2;
    size_t n;
    ebx = k;
    ecx = i;
    esi = j;
    edi = level;
    /* int inv_laplace_sub(token_type * equation,int * np,int loc,int eloc,long int v); */
    edi = *((ebp + 0x10));
    ebx = *((ebp + 0x14));
    esi = *((ebp + 0x18));
    eax = edi;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x1c)) = eax;
    eax = ebx;
    eax -= edi;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x1c));
    eax = min_level (eax);
    *((ebp - 0x20)) = eax;
    if (ebx <= edi) {
        goto label_1;
    }
    eax = *((ebp - 0x1c));
    eax += 4;
    edx = edi;
    do {
        *(eax) += 2;
        edx++;
        eax += 0x10;
    } while (ebx > edx);
    eax = *((ebp - 0x1c));
    edx = edi;
label_0:
    if (*(eax) != 1) {
        goto label_2;
    }
    if (*((eax + 8)) != esi) {
        goto label_2;
    }
    eax = edx + 1;
    if (ebx <= eax) {
        goto label_1;
    }
    *((ebp - 0x24)) = eax;
    esi = eax;
    esi <<= 4;
    esi += *((ebp + 8));
    if (*((esi + 8)) != 6) {
        goto label_1;
    }
    ecx = eax - 2;
    if (edi >= ecx) {
        goto label_1;
    }
    ecx <<= 4;
    edi = *((ebp + 8));
    if (*((ecx + edi + 8)) != 4) {
        goto label_1;
    }
    edi = *((esi + 4));
    eax++;
    *((ebp - 0x1c)) = eax;
    if (ebx <= eax) {
        goto label_3;
    }
    ecx = eax;
    ecx <<= 4;
    ecx += *((ebp + 8));
    eax = *((ecx + 4));
    if (edi > eax) {
        goto label_3;
    }
    edx <<= 4;
    esi = *((ebp + 8));
    edx = edx + esi + 0x30;
    esi = *((ebp - 0x1c));
    do {
        eax++;
        *((ecx + 4)) = eax;
        esi++;
        if (ebx <= esi) {
            goto label_4;
        }
        ecx = edx;
        eax = *((edx + 4));
        edx += 0x10;
    } while (edi <= eax);
    goto label_4;
label_3:
    esi = *((ebp - 0x1c));
label_4:
    eax = *((ebp - 0x1c));
    eax -= *((ebp - 0x1c));
    *((ebp - 0x24)) = eax;
    edx = *((ebp + 0xc));
    eax = *(edx);
    ecx = *((ebp - 0x24));
    eax = ecx + eax + 7;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp - 0x20));
    eax++;
    *((ebp - 0x2c)) = eax;
    eax = *((ebp - 0x1c));
    eax -= 3;
    eax <<= 4;
    edx = *((ebp + 8));
    *((eax + edx + 8)) = 3;
    eax = esi;
    eax <<= 4;
    eax += edx;
    *((ebp - 0x28)) = eax;
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    eax -= esi;
    eax <<= 4;
    eax = *((ebp - 0x28));
    eax = esi;
    eax <<= 4;
    eax = eax + edx + 0x20;
    memmove (eax, eax, eax);
    edx = *((ebp + 0xc));
    *(edx) += 2;
    eax = ebx + 2;
    ecx = *((ebp - 0x24));
    ecx += 2;
    *((ebp - 0x24)) = ecx;
    edi++;
    edx = *((ebp - 0x28));
    *((edx + 4)) = edi;
    *(edx) = 2;
    *((edx + 8)) = 2;
    esi <<= 4;
    ecx = *((ebp + 8));
    edx = esi + ecx + 0x10;
    *((edx + 4)) = edi;
    *(edx) = 0;
    *(fp_stack--) = 1.0;
    *((edx + 8)) = fp_stack[0];
    fp_stack--;
    esi = eax;
    esi <<= 4;
    esi += ecx;
    ecx = *((ebp + 0xc));
    edx = *(ecx);
    edx -= eax;
    edx <<= 4;
    edi = *((ebp - 0x24));
    eax = edi + eax + 3;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, esi, edx);
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax = edi + eax + 3;
    *(edx) = eax;
    ecx = *((ebp - 0x2c));
    *((esi + 4)) = ecx;
    *(esi) = 2;
    *((esi + 8)) = 4;
    ebx += 3;
    eax = edi;
    eax <<= 4;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, eax);
    ebx += edi;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    edx = *((ebp - 0x20));
    edx += 2;
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 7;
    ebx <<= 4;
    esi = *((ebp + 8));
    eax = ebx + esi + 0x10;
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    goto label_5;
label_2:
    edx += 2;
    eax += 0x20;
    if (ebx > edx) {
        goto label_0;
    }
label_1:
    eax = 0;
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806b6a8 */
#include <stdint.h>
 
int32_t dbg_laplace_sub (int32_t arg_14h, int32_t k, int32_t level, int32_t eloc, int32_t j) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t len;
    int32_t mlevel;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    int32_t loc;
    long int v;
    void * s2;
    size_t n;
    ebx = k;
    edx = level;
    esi = eloc;
    edi = j;
    /* int laplace_sub(token_type * equation,int * np,int loc,int eloc,long int v); */
    ebx = *((ebp + 0x10));
    esi = *((ebp + 0x14));
    edi = *((ebp + 0x18));
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x1c)) = eax;
    eax = esi;
    eax -= ebx;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x1c));
    eax = min_level (eax);
    eax++;
    *((ebp - 0x20)) = eax;
    if (esi <= ebx) {
        goto label_1;
    }
    eax = *((ebp - 0x1c));
    eax += 4;
    edx = ebx;
    do {
        *(eax) += 2;
        edx++;
        eax += 0x10;
    } while (esi > edx);
    eax = *((ebp - 0x1c));
label_0:
    if (*(eax) != 1) {
        goto label_2;
    }
    if (*((eax + 8)) != edi) {
        goto label_2;
    }
    edx = ebx + 1;
    if (esi <= edx) {
        goto label_3;
    }
    eax = edx;
    eax <<= 4;
    eax += *((ebp + 8));
    if (*((eax + 8)) != 6) {
        goto label_3;
    }
    eax = *((eax + 4));
    *((ebp - 0x2c)) = eax;
    edx++;
    *((ebp - 0x1c)) = edx;
    if (esi <= edx) {
        goto label_4;
    }
    ecx = edx;
    ecx <<= 4;
    ecx += *((ebp + 8));
    edx = *((ecx + 4));
    if (eax > edx) {
        goto label_4;
    }
    eax = ebx;
    eax <<= 4;
    edi = *((ebp + 8));
    eax = eax + edi + 0x30;
    edi = *((ebp - 0x1c));
    *((ebp - 0x24)) = ebx;
    ebx = *((ebp - 0x2c));
    do {
        edx++;
        *((ecx + 4)) = edx;
        edi++;
        if (esi <= edi) {
            goto label_5;
        }
        ecx = eax;
        edx = *((eax + 4));
        eax += 0x10;
    } while (ebx <= edx);
    ebx = *((ebp - 0x24));
    goto label_6;
label_4:
    edi = *((ebp - 0x1c));
    goto label_6;
label_5:
    ebx = *((ebp - 0x24));
label_6:
    eax = edi;
    eax -= *((ebp - 0x1c));
    *((ebp - 0x24)) = eax;
    edx = *((ebp + 0xc));
    eax = *(edx);
    ecx = *((ebp - 0x24));
    eax = ecx + eax + 7;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = edi;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x28)) = eax;
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= edi;
    eax <<= 4;
    ecx = *((ebp - 0x28));
    eax = edi;
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x40;
    memmove (eax, ecx, eax);
    ecx = *((ebp + 0xc));
    *(ecx) += 4;
    esi += 4;
    ecx = *((ebp - 0x2c));
    ecx++;
    eax = *((ebp - 0x28));
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 1;
    eax = edi;
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    *((eax + 4)) = ecx;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    edi += 2;
    if (*((ebp - 0x1c)) >= edi) {
        goto label_7;
    }
    ebx <<= 4;
    eax = edx + ebx + 0x24;
    edx = *((ebp - 0x1c));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (edi > edx);
label_7:
    eax = edi;
    eax <<= 4;
    eax += *((ebp + 8));
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 3;
    edi <<= 4;
    edx = *((ebp + 8));
    eax = edi + edx + 0x10;
    *((eax + 4)) = ecx;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    ebx = esi;
    ebx <<= 4;
    ebx += edx;
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= esi;
    eax <<= 4;
    ecx = *((ebp - 0x24));
    eax = esi + ecx + 3;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, ebx, eax);
    edi = *((ebp + 0xc));
    eax = *(edi);
    edx = *((ebp - 0x24));
    eax = edx + eax + 3;
    *(edi) = eax;
    ecx = *((ebp - 0x20));
    *((ebx + 4)) = ecx;
    *(ebx) = 2;
    *((ebx + 8)) = 3;
    ebx = esi + 1;
    eax = edx;
    eax <<= 4;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, eax);
    ebx += *((ebp - 0x24));
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    edx = *((ebp - 0x20));
    edx++;
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 7;
    ebx <<= 4;
    edi = *((ebp + 8));
    eax = ebx + edi + 0x10;
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = 1;
    goto label_8;
label_2:
    ebx += 2;
    eax += 0x20;
    if (esi > ebx) {
        goto label_0;
    }
label_1:
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ebx = esi;
    ebx <<= 4;
    ebx += *((ebp + 8));
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    eax -= esi;
    eax <<= 4;
    eax = esi;
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x20;
    memmove (eax, ebx, eax);
    ecx = *((ebp + 0xc));
    *(ecx) += 2;
    eax = *((ebp - 0x20));
    *((ebx + 4)) = eax;
    *(ebx) = 2;
    *((ebx + 8)) = 4;
    esi <<= 4;
    edx = *((ebp + 8));
    eax = esi + edx + 0x10;
    ecx = *((ebp - 0x20));
    *((eax + 4)) = ecx;
    *(eax) = 1;
    *((eax + 8)) = edi;
    eax = 1;
    goto label_8;
label_3:
    eax = 0;
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806bc22 */
#include <stdint.h>
 
int32_t dbg_integrate_sub (int32_t arg_ch, int32_t arg_14h, int32_t eloc, int32_t div_flag, int32_t j, int32_t k, int32_t level) {
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    uint32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t vlevel;
    int32_t count;
    uint32_t var_2ch;
    int32_t len;
    int32_t var_24h;
    int32_t mlevel;
    int32_t var_1ch;
    token_type * equation;
    int32_t loc;
    long int v;
    void * s2;
    size_t n;
    ebx = eloc;
    edx = div_flag;
    esi = j;
    edi = k;
    eax = level;
    /* int integrate_sub(token_type * equation,int * np,int loc,int eloc,long int v); */
    ebx = *((ebp + 0x14));
    esi = *((ebp + 0x10));
    eax = *((ebp + 0x10));
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x28)) = eax;
    eax = ebx;
    eax -= esi;
    *((esp + 4)) = eax;
    eax = *((ebp - 0x28));
    eax = min_level (eax);
    *((ebp - 0x2c)) = eax;
    if (ebx <= *((ebp + 0x10))) {
        goto label_2;
    }
    edi = *((ebp - 0x28));
    esi <<= 4;
    edx = *((ebp + 8));
    esi = edx + esi + 0x18;
    *((ebp - 0x24)) = esi;
    ecx = *((ebp + 0x10));
    ecx++;
    *((ebp - 0x20)) = ecx;
    edx = ecx;
    eax = edi;
    *((ebp - 0x30)) = 0;
    esi = *((ebp - 0x2c));
    esi++;
    *((ebp - 0x40)) = esi;
    ecx <<= 4;
    esi = *((ebp + 8));
    esi = esi + ecx + 4;
    *((ebp - 0x38)) = esi;
    *((ebp - 0x3c)) = edx;
    *((ebp - 0x44)) = edi;
    ecx = *((ebp - 0x24));
label_0:
    if (*(eax) != 1) {
        goto label_3;
    }
    esi = *((ebp + 0x18));
    if (*((eax + 8)) != esi) {
        goto label_3;
    }
    *((ebp - 0x30))++;
    if (*((ebp - 0x30)) > 1) {
        goto label_4;
    }
    edi = *((eax + 4));
    *((ebp - 0x34)) = edi;
    if (*((ebp - 0x2c)) != edi) {
        if (*((ebp - 0x40)) != edi) {
            goto label_4;
        }
    }
    if (ebx <= *((ebp - 0x20))) {
        goto label_5;
    }
    esi = *((ebp - 0x38));
    edi = *((ebp - 0x3c));
    *((ebp - 0x48)) = ecx;
    *((ebp - 0x4c)) = eax;
    eax = *((ebp - 0x2c));
    do {
        if (eax == *(esi)) {
            ecx = *((esi + 4));
            if (ecx < 3) {
                goto label_4;
            }
            if (ecx <= 4) {
                goto label_6;
            }
            if (ecx != 6) {
                goto label_4;
            }
            if (edi != edx) {
                goto label_4;
            }
        }
label_6:
        edi += 2;
        esi += 0x20;
    } while (ebx > edi);
    ecx = *((ebp - 0x48));
    eax = *((ebp - 0x4c));
label_5:
    esi = *((ebp - 0x34));
    if (*((ebp - 0x40)) == esi) {
        if (ebx <= edx) {
            goto label_4;
        }
        edi = *((ebp - 0x40));
        if (edi != *((ecx - 4))) {
            goto label_4;
        }
        if (*(ecx) != 6) {
            goto label_4;
        }
    }
label_3:
    eax += 0x20;
    ecx += 0x20;
    edx += 2;
    esi = edx - 1;
    if (ebx > esi) {
        goto label_0;
    }
    edi = *((ebp - 0x44));
    eax = *((ebp - 0x2c));
    eax++;
    *((ebp - 0x20)) = eax;
    eax = *((ebp - 0x28));
    eax += 4;
    edx = *((ebp + 0x10));
    do {
        *(eax) += 2;
        edx++;
        eax += 0x10;
    } while (ebx > edx);
    esi = *((ebp + 0x10));
    edx = *((ebp + 0x18));
label_1:
    eax = esi;
    if (*(edi) != 1) {
        goto label_7;
    }
    if (*((edi + 8)) != edx) {
        goto label_7;
    }
    ecx = 0;
    if (*((ebp + 0x10)) < esi) {
        eax--;
        eax <<= 4;
        edx = *((ebp + 8));
        cl = (*((eax + edx + 8)) == 4) ? 1 : 0;
        ecx = (int32_t) cl;
    }
    edx = esi + 1;
    if (ebx <= edx) {
        goto label_4;
    }
    eax = edx;
    eax <<= 4;
    eax += *((ebp + 8));
    if (*((eax + 8)) != 6) {
        goto label_4;
    }
    eax = *((eax + 4));
    *((ebp - 0x24)) = eax;
    edx++;
    *((ebp - 0x1c)) = edx;
    if (ecx == 0) {
        goto label_8;
    }
    *((ebp - 0x2c)) = edx;
    eax = edx;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x28)) = eax;
    ecx = *((ebp - 0x24));
    if (*((eax + 4)) == ecx) {
        if (*(eax) != 0) {
            goto label_9;
        }
        *(fp_stack--) = *((eax + 8));
        *(fp_stack--) = 1.0;
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            goto label_9;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_4;
        }
    }
label_9:
    edi = *((ebp + 0xc));
    eax = *(edi);
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (ebx <= *((ebp - 0x1c))) {
        goto label_10;
    }
    eax = *((ebp - 0x28));
    edx = *((eax + 4));
    if (*((ebp - 0x24)) > edx) {
        goto label_10;
    }
    eax = esi;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x30;
    edi = *((ebp - 0x28));
    ecx = *((ebp - 0x1c));
    do {
        edx++;
        *((edi + 4)) = edx;
        ecx++;
        if (ebx <= ecx) {
            goto label_10;
        }
        edi = eax;
        edx = *((eax + 4));
        eax += 0x10;
    } while (*((ebp - 0x24)) <= edx);
label_10:
    eax = *((ebp - 0x2c));
    eax -= 3;
    eax <<= 4;
    edi = *((ebp + 8));
    *((eax + edi + 8)) = 3;
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= *((ebp - 0x1c));
    eax <<= 4;
    ecx = *((ebp - 0x28));
    eax = *((ebp - 0x2c));
    eax <<= 4;
    eax = eax + edi + 0x20;
    memmove (eax, ecx, eax);
    edi = *((ebp + 0xc));
    *(edi) += 2;
    ebx += 2;
    edx = *((ebp - 0x24));
    edx++;
    eax = *((ebp - 0x28));
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x2c));
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x10;
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 3;
label_8:
    if (ebx <= *((ebp - 0x1c))) {
        goto label_11;
    }
    ecx = *((ebp - 0x1c));
    ecx <<= 4;
    ecx += *((ebp + 8));
    eax = *((ecx + 4));
    if (*((ebp - 0x24)) > eax) {
        goto label_11;
    }
    esi <<= 4;
    edi = *((ebp + 8));
    edx = esi + edi + 0x30;
    esi = *((ebp - 0x1c));
    edi = *((ebp - 0x24));
    do {
        eax++;
        *((ecx + 4)) = eax;
        esi++;
        if (ebx <= esi) {
            goto label_12;
        }
        ecx = edx;
        eax = *((edx + 4));
        edx += 0x10;
    } while (edi <= eax);
    goto label_12;
label_11:
    esi = *((ebp - 0x1c));
label_12:
    eax = *((ebp - 0x1c));
    eax -= *((ebp - 0x1c));
    *((ebp - 0x28)) = eax;
    edx = *((ebp + 0xc));
    eax = *(edx);
    ecx = *((ebp - 0x28));
    eax = ecx + eax + 5;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edi = esi;
    edi <<= 4;
    edi += *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= esi;
    eax <<= 4;
    eax = esi;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x20;
    memmove (eax, edi, eax);
    eax = *((ebp + 0xc));
    *(eax) += 2;
    eax = ebx + 2;
    edx = *((ebp - 0x28));
    edx += 2;
    *((ebp - 0x28)) = edx;
    ecx = *((ebp - 0x24));
    ecx++;
    *((edi + 4)) = ecx;
    *(edi) = 2;
    *((edi + 8)) = 1;
    esi <<= 4;
    edi = *((ebp + 8));
    edx = esi + edi + 0x10;
    *((edx + 4)) = ecx;
    *(edx) = 0;
    *(fp_stack--) = 1.0;
    *((edx + 8)) = fp_stack[0];
    fp_stack--;
    esi = eax;
    esi <<= 4;
    esi += edi;
    ecx = *((ebp + 0xc));
    edx = *(ecx);
    edx -= eax;
    edx <<= 4;
    edi = *((ebp - 0x28));
    eax = edi + eax + 1;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, esi, edx);
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax = edi + eax + 1;
    *(edx) = eax;
    ecx = *((ebp - 0x20));
    *((esi + 4)) = ecx;
    *(esi) = 2;
    *((esi + 8)) = 4;
    eax = edi;
    eax <<= 4;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    eax += *((ebp + 8));
    ebx <<= 4;
    esi = *((ebp + 8));
    eax = ebx + esi + 0x30;
    memmove (eax, eax, eax);
    eax = 1;
    goto label_13;
label_7:
    esi += 2;
    edi += 0x20;
    if (ebx > esi) {
        goto label_1;
    }
    do {
        edi = *((ebp + 0xc));
        eax = *(edi);
        eax += 2;
        if (eax > *(obj.n_tokens)) {
            error_huge ();
        }
        esi = ebx;
        esi <<= 4;
        esi += *((ebp + 8));
        edx = *((ebp + 0xc));
        eax = *(edx);
        eax -= ebx;
        eax <<= 4;
        eax = ebx;
        eax <<= 4;
        ecx = *((ebp + 8));
        eax = eax + ecx + 0x20;
        memmove (eax, esi, eax);
        edi = *((ebp + 0xc));
        *(edi) += 2;
        eax = *((ebp - 0x20));
        *((esi + 4)) = eax;
        *(esi) = 2;
        *((esi + 8)) = 3;
        ebx <<= 4;
        edx = *((ebp + 8));
        eax = ebx + edx + 0x10;
        ecx = *((ebp - 0x20));
        *((eax + 4)) = ecx;
        *(eax) = 1;
        esi = *((ebp + 0x18));
        *((eax + 8)) = esi;
        eax = 1;
        goto label_13;
label_4:
        eax = 0;
label_13:
        return eax;
label_2:
        edi = *((ebp - 0x2c));
        edi++;
        *((ebp - 0x20)) = edi;
    } while (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806db35 */
#include <stdint.h>
 
int32_t dbg_trim_zeros (char * buf, int32_t j) {
    ecx = buf;
    edx = j;
    /* void trim_zeros(char * buf); */
    edx = eax;
    edi = eax;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = ecx - 1;
    ecx -= 2;
    if (ecx < 0) {
        goto label_0;
    }
    edx += eax;
    do {
        eax = *((edx - 1));
        if (al != 0x30) {
            if (al != 0x2e) {
                goto label_0;
            }
            *((edx + 1)) = 0;
        }
        edx--;
        ecx--;
    } while (ecx >= 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806e66c */
#include <stdint.h>
 
int32_t dbg_flist_recurse (int32_t arg_ch, char * arg_10h, int32_t i1, int32_t out_flag, int32_t len, int32_t len_div, char * cp) {
    uint32_t var_274h;
    int32_t var_270h;
    int32_t var_26ch;
    int32_t var_268h;
    uint32_t var_264h;
    int32_t var_260h;
    int32_t var_25ch;
    uint32_t var_258h;
    uint32_t var_254h;
    int32_t var_250h;
    int32_t var_24ch;
    int32_t var_248h;
    uint32_t var_244h;
    int32_t div_loc;
    int32_t var_23ch;
    int32_t stop_at;
    int32_t var_234h;
    int32_t len1;
    int32_t len2;
    int32_t oflag;
    int32_t var_224h;
    int32_t var_220h;
    int32_t k;
    int32_t low;
    int32_t high;
    char[500] buf;
    int32_t canary;
    int32_t line;
    int * highp;
    int * lowp;
    int32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = i1;
    edx = out_flag;
    esi = len;
    edi = len_div;
    eax = cp;
    /* int flist_recurse(token_type * p1,int n,int out_flag,int line,int pos,int cur_level,int * highp,int * lowp); */
label_2:
    *((ebp - 0x234)) = eax;
    *((ebp - 0x23c)) = edx;
    *((ebp - 0x254)) = ecx;
    ebx = *((ebp + 8));
    eax = *((ebp + 0x14));
    *((ebp - 0x248)) = eax;
    edx = *((ebp + 0x18));
    *((ebp - 0x24c)) = edx;
    ecx = *(gs:0x14);
    *((ebp - 0x1c)) = ecx;
    ecx = 0;
    *(eax) = ebx;
    *(edx) = ebx;
    *((ebp - 0x224)) = 0;
    if (*((ebp - 0x23c)) <= 0) {
        goto label_6;
    }
    *((ebp - 0x228)) = 0;
    if (*((ebp - 0x254)) != 0) {
        al = (ebx == *(obj.cur_line)) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x228)) = eax;
    }
    *((ebp - 0x264)) = 0;
    if (*(obj.html_flag) != 0) {
        eax = gfp;
        al = (eax == *(obj.stdout)) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x264)) = eax;
    }
    while (ecx <= *(obj.cur_pos)) {
label_0:
        eax = ebx + 1;
        *((ebp - 0x260)) = eax;
        ebx--;
        *((ebp - 0x25c)) = ebx;
        eax += eax;
        *((ebp - 0x270)) = eax;
        ebx += ebx;
        *((ebp - 0x268)) = ebx;
        edi = *((ebp + 0x10));
        edx = *((ebp - 0x23c));
        *((ebp - 0x238)) = edx;
        *((ebp - 0x224)) = 0;
        *((ebp - 0x22c)) = 0;
        *((ebp - 0x240)) = 0xffffffff;
        eax = 0;
        goto label_1;
        eax = *((ebp + 0x10));
        eax--;
        set_color (eax);
        ecx = *((ebp + 0xc));
    }
    esi = ebx;
    ebx = ecx;
    do {
        *((esp + 8)) = 0x8077a28;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = cur_pos;
        eax++;
        *(obj.cur_pos) = eax;
    } while (ebx > eax);
    ebx = esi;
    goto label_0;
label_3:
    *((ebp - 0x22c)) = ebx;
    ebx = *((ebp - 0x23c));
    *((ebp - 0x238)) = ebx;
    eax = *((ebp - 0x22c));
    *((ebp - 0x240)) = 0xffffffff;
label_1:
    edx = eax;
    edx <<= 4;
    edx += *((ebp - 0x234));
    if (*(edx) != 2) {
        goto label_7;
    }
    if (*((edx + 8)) != 4) {
        goto label_7;
    }
    esi = *((edx + 4));
    edx = eax - 2;
    if (edx <= 0) {
        goto label_8;
    }
    ecx = edx;
    ecx <<= 4;
    ebx = *((ebp - 0x234));
    if (esi > *((ecx + ebx + 4))) {
        goto label_8;
    }
    ecx = eax;
    ecx <<= 4;
    ecx = ebx + ecx - 0x3c;
    while (edx > 0) {
        ebx = *(ecx);
        ecx -= 0x20;
        if (esi > ebx) {
            goto label_8;
        }
        edx -= 2;
    }
label_8:
    edx++;
    if (*((ebp - 0x240)) >= 0) {
        if (edx < *((ebp - 0x238))) {
            goto label_9;
        }
        if (edx != *((ebp - 0x238))) {
            goto label_7;
        }
        ecx = *((ebp - 0x240));
        ecx <<= 4;
        *((ebp - 0x238)) = edx;
        ebx = *((ebp - 0x234));
        if (esi >= *((ecx + ebx + 4))) {
            goto label_7;
        }
    }
label_9:
    *((ebp - 0x240)) = eax;
    *((ebp - 0x238)) = edx;
label_7:
    eax++;
    if (*((ebp - 0x23c)) > eax) {
        goto label_1;
    }
    eax = *((ebp - 0x240));
    *((ebp - 0x250)) = eax;
    eax <<= 4;
    eax += *((ebp - 0x234));
    *((ebp - 0x244)) = eax;
label_4:
    ecx = *((ebp - 0x22c));
    if (*((ebp - 0x238)) == ecx) {
        eax = edi;
        ebx = *((ebp - 0x244));
        eax -= *((ebx + 4));
        *((ebp - 0x220)) = eax;
        eax >>= 0x1f;
        edx = *((ebp - 0x220));
        edx ^= eax;
        edx -= eax;
        edx--;
        *((ebp - 0x21c)) = edx;
    } else {
        eax = *((ebp - 0x22c));
        eax <<= 4;
        ecx = edi;
        edx = *((ebp - 0x234));
        ecx -= *((eax + edx + 4));
        *((ebp - 0x220)) = ecx;
        eax = ecx;
        eax >>= 0x1f;
        ecx ^= eax;
        ecx -= eax;
        *((ebp - 0x21c)) = ecx;
    }
    if (*((ebp - 0x21c)) <= 0) {
        goto label_10;
    }
    esi = *((ebp - 0x224));
    esi++;
    ebx = 1;
    do {
        if (*((ebp - 0x220)) > 0) {
            edi--;
            *((ebp - 0x224)) = esi;
            if (*((ebp - 0x228)) == 0) {
                goto label_11;
            }
            *((esp + 8)) = 0x80779a8;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = edi - 1;
            set_color (eax);
        } else {
            eax = edi + 1;
            *((ebp - 0x230)) = eax;
            *((ebp - 0x224)) = esi;
            if (*((ebp - 0x228)) == 0) {
                edi = eax;
            } else {
                set_color (edi);
                *((esp + 8)) = 0x8075ad6;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                edi = *((ebp - 0x230));
            }
        }
label_11:
        ebx++;
        esi++;
    } while (*((ebp - 0x21c)) >= ebx);
label_10:
    edx = *((ebp - 0x22c));
    if (*((ebp - 0x238)) != edx) {
        goto label_12;
    }
    *((ebp - 0x274)) = edi;
    ecx = *((ebp - 0x244));
    esi = *((ecx + 4));
    ebx = *((ebp - 0x224));
    ebx += *((ebp + 0xc));
    *((ebp - 0x220)) = ebx;
    eax = *((ebp - 0x240));
    eax -= *((ebp - 0x238));
    *((ebp - 0x258)) = eax;
    eax = *((ebp - 0x238));
    eax <<= 4;
    eax += *((ebp - 0x234));
    *((ebp - 0x244)) = eax;
    edx = ebp - 0x218;
    *((esp + 0x10)) = edx;
    ecx = ebp - 0x214;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = esi;
    ebx = *((ebp - 0x260));
    ecx = 0;
    edx = *((ebp - 0x258));
    eax = flist_recurse (ebx, ebx);
    goto label_2;
    *((ebp - 0x230)) = eax;
    eax = *((ebp - 0x218));
    *((ebp - 0x26c)) = eax;
    ebx = *((ebp - 0x240));
    ebx += 2;
    if (*((ebp - 0x23c)) <= ebx) {
        goto label_13;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x234));
    if (esi >= *((eax + edx + 4))) {
        goto label_13;
    }
    eax = *((ebp - 0x240));
    eax <<= 4;
    eax = edx + eax + 0x44;
    ecx = *((ebp - 0x23c));
    while (ecx > ebx) {
        edx = *(eax);
        eax += 0x20;
        if (esi >= edx) {
            goto label_13;
        }
        ebx += 2;
    }
label_13:
    eax = *((ebp - 0x240));
    eax = ~eax;
    eax = ebx + eax;
    *((ebp - 0x240)) = eax;
    eax = *((ebp - 0x250));
    eax <<= 4;
    ecx = *((ebp - 0x234));
    eax = eax + ecx + 0x10;
    *((ebp - 0x238)) = eax;
    eax = ebp - 0x218;
    *((esp + 0x10)) = eax;
    edx = ebp - 0x214;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    ecx = *((ebp - 0x220));
    eax = *((ebp - 0x25c));
    ecx = 0;
    edx = *((ebp - 0x240));
    eax = *((ebp - 0x238));
    eax = flist_recurse (eax, ecx);
    goto label_2;
    *((ebp - 0x22c)) = eax;
    edx = *((ebp - 0x214));
    *((ebp - 0x250)) = edx;
    ecx = *((ebp - 0x230));
    if (eax >= ecx) {
        ecx = eax;
    }
    *((ebp - 0x21c)) = ecx;
    eax = 0;
    if (*((ebp - 0x230)) < ecx) {
        eax = ecx;
        eax -= *((ebp - 0x230));
        edx = eax;
        edx >>= 0x1f;
        eax = edx + eax;
        eax >>= 1;
    }
    edx = ebp - 0x218;
    *((esp + 0x10)) = edx;
    ecx = ebp - 0x214;
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = esi;
    eax += *((ebp - 0x220));
    eax = *((ebp - 0x270));
    eax -= *((ebp - 0x26c));
    ecx = *((ebp - 0x254));
    edx = *((ebp - 0x258));
    eax = *((ebp - 0x244));
    flist_recurse (eax, eax);
    goto label_2;
    eax = *((ebp - 0x214));
    edx = *((ebp - 0x248));
    if (*(edx) >= eax) {
        eax = *(edx);
    }
    *(edx) = eax;
    eax = *((ebp - 0x218));
    ecx = *((ebp - 0x24c));
    if (*(ecx) <= eax) {
        eax = *(ecx);
    }
    *(ecx) = eax;
    if (*((ebp - 0x228)) == 0) {
        goto label_14;
    }
    eax = esi - 1;
    set_color (eax);
    if (*((ebp - 0x21c)) <= 0) {
        goto label_15;
    }
    *((ebp - 0x244)) = ebx;
    ebx = 0;
    *((ebp - 0x230)) = esi;
    *((ebp - 0x258)) = edi;
    esi = *((ebp - 0x264));
    edi = *((ebp - 0x21c));
    do {
        if (esi != 0) {
            *((esp + 8)) = "&minus;";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        } else {
            *((esp + 8)) = 0x807295b;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        ebx++;
    } while (edi > ebx);
    ebx = *((ebp - 0x244));
    esi = *((ebp - 0x230));
    edi = *((ebp - 0x258));
label_15:
    eax = *((ebp - 0x274));
    eax--;
    set_color (eax);
label_14:
    eax = 0;
    edx = *((ebp - 0x21c));
    if (*((ebp - 0x22c)) < edx) {
        eax = edx;
        eax -= *((ebp - 0x22c));
        edx = eax;
        edx >>= 0x1f;
        eax = edx + eax;
        eax >>= 1;
    }
    ecx = ebp - 0x218;
    *((esp + 0x10)) = ecx;
    edx = ebp - 0x214;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = esi;
    eax += *((ebp - 0x220));
    eax = *((ebp - 0x268));
    eax -= *((ebp - 0x250));
    ecx = *((ebp - 0x254));
    edx = *((ebp - 0x240));
    eax = *((ebp - 0x238));
    flist_recurse (eax, eax);
    goto label_2;
    eax = *((ebp - 0x214));
    ecx = *((ebp - 0x248));
    if (*(ecx) >= eax) {
        eax = *(ecx);
    }
    *(ecx) = eax;
    eax = *((ebp - 0x218));
    edx = *((ebp - 0x24c));
    if (*(edx) <= eax) {
        eax = *(edx);
    }
    *(edx) = eax;
    ecx = *((ebp - 0x21c));
    *((ebp - 0x224)) += ecx;
    if (*((ebp - 0x23c)) > ebx) {
        goto label_3;
    }
    goto label_16;
label_12:
    ecx = *((ebp - 0x22c));
    eax = *((ebp - 0x22c));
    eax <<= 4;
    eax += *((ebp - 0x234));
    edx = *(eax);
    if (edx != 1) {
        if (edx >= 1) {
            if (edx != 2) {
                goto label_17;
            }
            *(fp_stack--) = *((eax + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            fp_stack[1] = fp_stack[0];
            fp_stack--;
        } else {
        } else {
            if (fp_stack[0] == fp_stack[1]) {
                if (fp_stack[0] != fp_stack[1]) {
                    fp_stack++;
                    *(fp_stack--) = 0.0;
                    *((eax + 8)) = fp_stack[0];
                }
            } else {
                *(fp_stack--) = 1.0;
                fp_stack[0] = -fp_stack[0];
                fp_tmp_1 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_1;
                fp_stack[1] = fp_stack[0];
                fp_stack--;
                if (fp_stack[0] != fp_stack[1]) {
                    goto label_18;
                }
                if (fp_stack[0] == fp_stack[1]) {
                    goto label_18;
                }
                if (*((ebp - 0x22c)) != 0) {
                    edx = ecx - 1;
                    edx <<= 4;
                    ebx = *((ebp - 0x234));
                    edx = *((edx + ebx + 4));
                    if (edx >= *((eax + 4))) {
                        goto label_18;
                    }
                }
                ebx = *((ebp - 0x22c));
                ebx++;
                if (*((ebp - 0x23c)) <= ebx) {
                    goto label_18;
                }
                edx = ecx;
                edx <<= 4;
                ecx = *((ebp - 0x234));
                edx = edx + ecx + 0x10;
                eax = *((eax + 4));
                if (eax != *((edx + 4))) {
                    goto label_18;
                }
                if (*((edx + 8)) != 3) {
                    goto label_18;
                }
                fp_stack++;
                *((esp + 0x10)) = 0x807295b;
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                eax = ebp - 0x210;
                *(esp) = eax;
                eax = snprintf_chk ();
                *((ebp - 0x224)) += eax;
                goto label_19;
            }
label_18:
            eax = finance_option;
            if (eax != 0) {
                *(fp_stack--) = 0.0;
                fp_stack--;
                if (fp_stack[0] > fp_stack[1]) {
                    *((esp + 0x18)) = fp_stack[0];
                    fp_stack--;
                    *((esp + 0x14)) = eax;
                    *((esp + 0x10)) = "(%.*f)";
                    *((esp + 0xc)) = 0x1f4;
                    *((esp + 8)) = 1;
                    *((esp + 4)) = 0x1f4;
                    edx = ebp - 0x210;
                    *(esp) = edx;
                    eax = snprintf_chk ();
                    *((ebp - 0x224)) += eax;
                    ebx = *((ebp - 0x22c));
                } else {
                    *((esp + 0x18)) = fp_stack[0];
                    fp_stack--;
                }
                *((esp + 0x14)) = eax;
                *((esp + 0x10)) = "%.*f";
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                ecx = ebp - 0x210;
                *(esp) = ecx;
                eax = snprintf_chk ();
                *((ebp - 0x224)) += eax;
                ebx = *((ebp - 0x22c));
            } else {
                *(fp_stack--) = 0.0;
                fp_stack--;
                if (fp_stack[0] > fp_stack[1]) {
                    if (*(obj.negate_highest_precedence) == 0) {
                        *((esp + 0x18)) = fp_stack[0];
                        fp_stack--;
                        eax = precision;
                        *((esp + 0x14)) = eax;
                        *((esp + 0x10)) = "(%.*g)";
                        *((esp + 0xc)) = 0x1f4;
                        *((esp + 8)) = 1;
                        *((esp + 4)) = 0x1f4;
                        ebx = ebp - 0x210;
                        *(esp) = ebx;
                        eax = snprintf_chk ();
                        *((ebp - 0x224)) += eax;
                        ebx = *((ebp - 0x22c));
                    }
                } else {
                    *((esp + 0x18)) = fp_stack[0];
                    fp_stack--;
                    eax = precision;
                    *((esp + 0x14)) = eax;
                    *((esp + 0x10)) = 0x80759b8;
                    *((esp + 0xc)) = 0x1f4;
                    *((esp + 8)) = 1;
                    *((esp + 4)) = 0x1f4;
                    eax = ebp - 0x210;
                    *(esp) = eax;
                    eax = snprintf_chk ();
                    *((ebp - 0x224)) += eax;
                    ebx = *((ebp - 0x22c));
                }
            }
label_19:
            if (*((ebp - 0x228)) == 0) {
                goto label_20;
            }
            edx = ebp - 0x210;
            *((esp + 0xc)) = edx;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = *((eax + 8));
            eax = list_var (eax, 0);
            *((ebp - 0x224)) += eax;
            if (*((ebp - 0x228)) == 0) {
                goto label_17;
            }
            *((esp + 0xc)) = obj.var_str;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            ebx = *((ebp - 0x22c));
            goto label_20;
        }
        if (*((eax + 8)) <= 9) {
            eax = *((eax + 8));
            /* switch table (10 cases) at 0x8077ba0 */
            *((ebp - 0x224)) += 3;
            eax = 0x8077a0b;
            goto label_21;
            edx = 0x8077a22;
            eax = " &minus; ";
            if (*((ebp - 0x264)) == 0) {
                eax = edx;
            }
            *((ebp - 0x224)) += 3;
            goto label_21;
            edx = 0x8077a2b;
            eax = "&middot;";
            if (*((ebp - 0x264)) == 0) {
                eax = edx;
            }
            *((ebp - 0x224))++;
            goto label_21;
            *((ebp - 0x224))++;
            eax = 0x8077a7f;
            goto label_21;
            *((ebp - 0x224)) += 2;
            eax = 0x8077a7e;
            goto label_21;
            *((ebp - 0x224)) += 3;
            eax = 0x8077a26;
            goto label_21;
            if (*(obj.power_starstar) != 0) {
                *((ebp - 0x224)) += 2;
                eax = 0x8077a2a;
            } else {
                *((ebp - 0x224))++;
            }
            eax = 0x8077a81;
            goto label_21;
            *((ebp - 0x224))++;
            *((ebp - 0x22c))++;
            eax = 0x8077a83;
        } else {
            *((ebp - 0x224)) += 0x12;
            eax = "(unknown operator)";
        }
label_21:
        if (*((ebp - 0x228)) != 0) {
            *((esp + 0xc)) = eax;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            ebx = *((ebp - 0x22c));
        } else {
label_17:
            ebx = *((ebp - 0x22c));
        }
    }
label_20:
    ebx++;
    *((ebp - 0x22c)) = ebx;
    if (*((ebp - 0x23c)) > ebx) {
        goto label_4;
    }
label_16:
    ebx = edi;
    ebx -= *((ebp + 0x10));
    if (ebx <= 0) {
        goto label_22;
    }
    edi -= 2;
    esi = *((ebp - 0x224));
    while (1) {
label_5:
        edi--;
        esi++;
        ebx--;
        if (*((ebp - 0x228)) == 0) {
            goto label_23;
        }
        *((esp + 8)) = 0x80779a8;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        if (ebx <= 0) {
            goto label_24;
        }
        set_color (edi);
    }
label_23:
    if (ebx > 0) {
        goto label_5;
    }
    *((ebp - 0x224)) = esi;
    goto label_6;
label_22:
    if (*((ebp - 0x228)) != 0) {
        goto label_25;
label_24:
        *((ebp - 0x224)) = esi;
label_25:
        ecx = *((ebp - 0x224));
        *(obj.cur_pos) += ecx;
    }
label_6:
    eax = *((ebp - 0x224));
    ebx = *((ebp - 0x1c));
    ebx ^= *(gs:0x14);
    if (*(obj.cur_pos) != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fd6c */
#include <stdint.h>
 
uint32_t dbg_flist_sub (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t out_flag, int32_t n, int32_t i, token_type * p1) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ebx = out_flag;
    ecx = n;
    esi = i;
    eax = p1;
    /* int flist_sub(token_type * p1,int n,int out_flag,int pos,int * highp,int * lowp); */
    ebx = ecx;
    ecx = *((ebp + 0x10));
    *((esp + 0x10)) = ecx;
    ecx = *((ebp + 0xc));
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = 1;
    ecx = *((ebp + 8));
    ecx = ebx;
    eax = flist_recurse (0, ecx);
    esi = eax;
    if (ebx != 0) {
        default_color ();
    }
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070a90 */
#include <stdint.h>
 
int32_t dbg_fc_recurse (int32_t arg_8h, int32_t j, int * np, int32_t loc, int32_t op, int32_t k) {
    int32_t improve_readability;
    int32_t modified;
    int32_t op_count;
    int32_t const_count;
    int32_t var_64h;
    int32_t gcd_flag;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t neg_flag;
    int32_t var_50h;
    int32_t first;
    double minimum;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    uint32_t var_24h;
    int32_t var_20h;
    int32_t level_code;
    void * s2;
    size_t n;
    ebx = j;
    ecx = np;
    edx = loc;
    esi = op;
    edi = k;
    do {
        /* int fc_recurse(token_type * equation,int * np,int loc,int level,int level_code); */
        *((ebp - 0x3c)) = eax;
        *((ebp - 0x34)) = edx;
        *((ebp - 0x50)) = ecx;
        edi = *((ebp + 8));
        ebx = ecx;
        *((ebp - 0x58)) = 0;
        esi = edi + 1;
        *((ebp - 0x24)) = esi;
        esi = eax;
        goto label_7;
label_0:
        if (eax <= edi) {
            goto label_8;
        }
        eax = *((ebp + 0xc));
        *((esp + 4)) = eax;
        edx = *((ebp - 0x24));
        ecx = ebx;
        edx = *((ebp - 0x34));
        eax = esi;
        eax = fc_recurse (edx);
    } while (1);
    *((ebp - 0x58)) |= eax;
    eax = ebx + 1;
    edx = *((ebp - 0x34));
    ecx = *(edx);
    if (eax >= ecx) {
        goto label_9;
    }
    edx = eax;
    edx <<= 4;
    if (edi >= *((edx + esi + 4))) {
        goto label_9;
    }
    ebx <<= 4;
    edx = esi + ebx + 0x34;
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_9;
        }
        ebx = *(edx);
        edx += 0x20;
    } while (edi < ebx);
    goto label_9;
label_8:
    eax = ebx + 1;
label_9:
    ebx = eax;
label_7:
    ecx = *((ebp - 0x34));
    if (ebx >= *(ecx)) {
        goto label_10;
    }
    eax = ebx;
    eax <<= 4;
    eax = *((eax + esi + 4));
    if (eax >= edi) {
        goto label_0;
    }
label_10:
    ebx = *((ebp - 0x58));
    *((ebp - 0x70)) = ebx;
    if (ebx != 0) {
        *((ebp - 0x58)) = 1;
        goto label_11;
    }
    eax = *((ebp + 0xc));
    eax &= 3;
    *((ebp - 0x74)) = 1;
    if (eax <= 1) {
        al = (eax != 0) ? 1 : 0;
        dl = (edi == 1) ? 1 : 0;
        eax &= edx;
        eax = (int32_t) al;
        *((ebp - 0x74)) = eax;
        if (eax == 0) {
            goto label_12;
        }
    }
    *((ebp - 0x60)) = 1;
    if (*(obj.integer_coefficients) == 0) {
label_12:
        eax = *((ebp + 0xc));
        eax >>= 2;
        eax &= 1;
        *((ebp - 0x60)) = eax;
    }
    esi = *((ebp - 0x50));
    *((ebp - 0x28)) = esi;
    *((ebp - 0x68)) = 0;
    *((ebp - 0x6c)) = 0;
    *((ebp - 0x54)) = 1;
    *((ebp - 0x4c)) = 1;
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[0];
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
    eax = edi + 1;
    *((ebp - 0x24)) = eax;
    *((ebp - 0x30)) = eax;
    *((ebp - 0x20)) = edi;
    goto label_13;
label_1:
    if (*((ebp - 0x20)) == eax) {
        edx = *((ebp - 0x38));
        eax = *(edx);
        if (eax != 0) {
            if (eax != 2) {
                goto label_14;
            }
        } else {
            *((ebp - 0x68))++;
            ecx = *((ebp - 0x38));
            *(fp_stack--) = *((ecx + 8));
            goto label_15;
        }
        ebx = *((ebp - 0x38));
        eax = *((ebx + 8));
        if (eax != 1) {
            if (eax != 2) {
                goto label_16;
            }
        } else {
            *((ebp - 0x54)) = 0;
        }
        *((ebp - 0x6c))++;
        *((ebp - 0x28))++;
        goto label_13;
label_14:
        *(fp_stack--) = 1.0;
label_15:
        esi = *((ebp - 0x50));
        if (*((ebp - 0x28)) == esi) {
            *(fp_stack--) = 0.0;
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            eax = 0;
            if (fp_stack[0] <= fp_stack[1]) {
                eax = *((ebp - 0x54));
            }
            *((ebp - 0x54)) = eax;
        }
        fp_stack[0] = abs(fp_stack[0]);
        if (*((ebp - 0x4c)) != 0) {
            goto label_17;
        }
        *(fp_stack--) = *((ebp - 0x48));
        __asm ("fcmovnbe st(0), st(1)");
        *((ebp - 0x48)) = fp_stack[0];
        fp_stack--;
        if (*((ebp - 0x60)) == 0) {
            goto label_18;
        }
        *(fp_stack--) = 0.0;
        fp_tmp_1 = fp_stack[2];
        fp_stack[2] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        fp_stack[2] = fp_stack[0];
        fp_stack--;
        if (fp_stack[0] != fp_stack[2]) {
            if (fp_stack[0] == fp_stack[2]) {
                goto label_19;
            }
            fp_tmp_2 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_2;
        } else {
            fp_tmp_3 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_3;
        }
        *((esp + 8)) = fp_stack[0];
        fp_stack--;
        *(esp) = fp_stack[0];
        fp_stack--;
        gcd_verified ();
        goto label_20;
    }
    ebx = *((ebp - 0x28));
    ebx++;
    if (edi <= ebx) {
        goto label_21;
    }
    ecx = ebx;
    ecx <<= 4;
    ecx += *((ebp - 0x3c));
    edx = *((ecx + 4));
    if (*((ebp - 0x20)) >= edx) {
        goto label_21;
    }
    eax = *((ebp - 0x28));
    eax <<= 4;
    esi = *((ebp - 0x3c));
    eax = eax + esi + 0x30;
    esi = 0;
    do {
        if (edx == *((ebp - 0x24))) {
            esi = *((ecx + 8));
        }
        ebx += 2;
        if (edi <= ebx) {
            goto label_22;
        }
        ecx = eax;
        edx = *((eax + 4));
        eax += 0x20;
    } while (*((ebp - 0x20)) < edx);
label_22:
    *((ebp - 0x2c)) = ebx;
    esi -= 3;
    if (esi > 1) {
        goto label_21;
    }
    if (*((ebp - 0x28)) >= ebx) {
        goto label_23;
    }
    esi = *((ebp - 0x38));
    esi += 4;
    eax = *((ebp - 0x5c));
    eax <<= 4;
    edx = *((ebp - 0x3c));
    eax = edx + eax - 8;
    *((ebp - 0x5c)) = eax;
    edi = *((ebp - 0x28));
    *((ebp - 0x38)) = ebx;
    eax = edi;
    *((ebp - 0x64)) = ebx;
    ebx = *((ebp - 0x5c));
    do {
        ecx = *((ebp - 0x30));
        if (*(esi) == ecx) {
            if (*((esi - 4)) != 0) {
                goto label_24;
            }
            if (eax == *((ebp - 0x2c))) {
                goto label_25;
            }
            if (edi > eax) {
                if (*(ebx) != 3) {
                    goto label_26;
                }
            }
            *(fp_stack--) = *((esi + 4));
            if (eax == *((ebp - 0x50))) {
                *(fp_stack--) = 0.0;
                fp_tmp_4 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_4;
                fp_stack[1] = fp_stack[0];
                fp_stack--;
                eax = 0;
                if (fp_stack[0] <= fp_stack[1]) {
                    eax = *((ebp - 0x54));
                }
                *((ebp - 0x54)) = eax;
            }
            fp_stack[0] = abs(fp_stack[0]);
            if (*((ebp - 0x4c)) != 0) {
                fp_stack[1] = fp_stack[0];
                fp_stack--;
                *(fp_stack--) = fp_stack[0];
                *((ebp - 0x48)) = fp_stack[0];
                fp_stack--;
                eax = *((ebp - 0x38));
                *((ebp - 0x4c)) = 0;
            } else {
                *(fp_stack--) = *((ebp - 0x48));
                __asm ("fcmovnbe st(0), st(1)");
                *((ebp - 0x48)) = fp_stack[0];
                fp_stack--;
                if (*((ebp - 0x60)) != 0) {
                    *(fp_stack--) = 0.0;
                    fp_tmp_5 = fp_stack[2];
                    fp_stack[2] = fp_stack[0];
                    fp_stack[0] = fp_tmp_5;
                    fp_stack[2] = fp_stack[0];
                    fp_stack--;
                    if (fp_stack[0] != fp_stack[2]) {
                        if (fp_stack[0] == fp_stack[2]) {
                            goto label_27;
                        }
                        fp_tmp_6 = fp_stack[1];
                        fp_stack[1] = fp_stack[0];
                        fp_stack[0] = fp_tmp_6;
                    } else {
                        fp_tmp_7 = fp_stack[1];
                        fp_stack[1] = fp_stack[0];
                        fp_stack[0] = fp_tmp_7;
                    }
                    *((esp + 8)) = fp_stack[0];
                    fp_stack--;
                    *(esp) = fp_stack[0];
                    fp_stack--;
                    gcd_verified ();
                    eax = *((ebp - 0x38));
                } else {
                    fp_stack++;
                    goto label_28;
label_27:
                    fp_stack++;
label_28:
                    eax = *((ebp - 0x38));
                }
            }
        }
label_24:
        edi++;
        esi += 0x10;
        ebx += 0x10;
    } while (*((ebp - 0x2c)) > edi);
    *((ebp - 0x28)) = eax;
    ebx = *((ebp - 0x64));
label_23:
    eax = *((ebp - 0x2c));
    if (*((ebp - 0x28)) != eax) {
label_21:
        edx = *((ebp - 0x50));
        eax = 0;
        if (*((ebp - 0x28)) != edx) {
            eax = *((ebp - 0x54));
        }
        *((ebp - 0x54)) = eax;
        if (*((ebp - 0x4c)) != 0) {
            fp_stack++;
            *((ebp - 0x28)) = ebx;
            *((ebp - 0x4c)) = 0;
            *(fp_stack--) = 1.0;
            *(fp_stack--) = fp_stack[0];
            *((ebp - 0x48)) = fp_stack[0];
            fp_stack--;
        } else {
            *(fp_stack--) = 1.0;
            *(fp_stack--) = *((ebp - 0x48));
            fp_stack--;
            if (fp_stack[0] > fp_stack[1]) {
                *((ebp - 0x48)) = fp_stack[0];
                fp_stack--;
            } else {
                fp_stack++;
            }
            if (*((ebp - 0x60)) != 0) {
                *(fp_stack--) = 0.0;
                fp_tmp_8 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_8;
                fp_stack[1] = fp_stack[0];
                fp_stack--;
                if (fp_stack[0] != fp_stack[1]) {
                    if (fp_stack[0] == fp_stack[1]) {
                        goto label_29;
                    }
                }
                *((esp + 8)) = fp_stack[0];
                fp_stack--;
                *(fp_stack--) = 1.0;
                *(esp) = fp_stack[0];
                fp_stack--;
                gcd_verified ();
                *((ebp - 0x28)) = ebx;
                goto label_13;
label_17:
                fp_stack[1] = fp_stack[0];
                fp_stack--;
                *(fp_stack--) = fp_stack[0];
                *((ebp - 0x48)) = fp_stack[0];
                fp_stack--;
                *((ebp - 0x4c)) = 0;
                goto label_20;
label_18:
                fp_stack++;
                goto label_20;
label_19:
                fp_stack++;
label_20:
                *((ebp - 0x28))++;
            } else {
label_29:
                *((ebp - 0x28)) = ebx;
            }
        }
    }
label_13:
    eax = *((ebp - 0x34));
    edi = *(eax);
    if (*((ebp - 0x28)) >= edi) {
        goto label_30;
    }
    edx = *((ebp - 0x28));
    *((ebp - 0x5c)) = edx;
    esi = edx;
    esi <<= 4;
    esi += *((ebp - 0x3c));
    *((ebp - 0x38)) = esi;
    eax = *((esi + 4));
    if (*((ebp - 0x20)) <= eax) {
        goto label_1;
    }
label_30:
    edi = *((ebp - 0x20));
    if (*((ebp - 0x60)) != 0) {
        *(fp_stack--) = 0.0;
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x48));
        __asm ("fcmovne st(0), st(1)");
        __asm ("fcmovu st(0), st(1)");
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        *((ebp - 0x48)) = fp_stack[0];
        fp_stack--;
    } else {
        fp_stack++;
    }
    if (*((ebp - 0x4c)) != 0) {
        goto label_11;
    }
    if (*((ebp - 0x6c)) == 0) {
        goto label_11;
    }
    if (*((ebp - 0x68)) > 1) {
        goto label_11;
    }
    if (*((ebp - 0x54)) == 0) {
        *(fp_stack--) = 1.0;
        *(fp_stack--) = *((ebp - 0x48));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            goto label_31;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
label_31:
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_32;
        }
    }
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = finite ();
    if (eax == 0) {
        goto label_11;
    }
    if (*((ebp - 0x74)) == 0) {
        goto label_6;
    }
    esi = *((ebp - 0x50));
    eax = edi + 1;
    *((ebp - 0x24)) = eax;
    ebx = *((ebp - 0x3c));
label_2:
    *((ebp - 0x2c)) = esi;
    eax = esi;
    eax <<= 4;
    eax = ebx + eax;
    if (*(eax) == 0) {
        edx = *((eax + 4));
        *((ebp - 0x28)) = edx;
        if (edx != edi) {
            ecx = esi + 1;
            edx = *((ebp - 0x34));
            if (ecx >= *(edx)) {
                goto label_33;
            }
            ecx = *((ebp - 0x24));
            if (*((ebp - 0x28)) != ecx) {
                goto label_33;
            }
            ecx = esi;
            ecx <<= 4;
            ecx = ecx + ebx + 0x10;
            edx = *((ebp - 0x28));
            if (edx != *((ecx + 4))) {
                goto label_33;
            }
            edx = *((ecx + 8));
            edx -= 3;
            if (edx > 1) {
                goto label_33;
            }
        }
        *(fp_stack--) = *((eax + 8));
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    } else {
label_33:
        *(fp_stack--) = 1.0;
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    }
    if (*((ebp - 0x60)) == 0) {
        *(fp_stack--) = 1.0;
        *(fp_stack--) = *((ebp - 0x48));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] >= fp_stack[1]) {
            goto label_34;
        }
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x48));
    fp_tmp_9 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_9;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_35;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x20));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_36;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x20));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = fmod ();
label_36:
    *(fp_stack--) = 0.0;
    fp_tmp_10 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_10;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_37;
        }
    }
label_35:
    *(fp_stack--) = *((ebp - 0x48));
    *(fp_stack--) = *((ebp - 0x20));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_38;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x48));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x20));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_38:
    *(fp_stack--) = 0.0;
    fp_tmp_11 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_11;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_37;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_37;
    }
    eax = esi + 1;
    edx = *((ebp - 0x34));
    ecx = *(edx);
    if (eax >= ecx) {
        goto label_6;
    }
    edx = eax;
    edx <<= 4;
    if (edi >= *((edx + ebx + 4))) {
        goto label_39;
    }
    esi <<= 4;
    edx = ebx + esi + 0x34;
    do {
        eax += 2;
        if (eax >= ecx) {
            goto label_6;
        }
        esi = *(edx);
        edx += 0x20;
    } while (edi < esi);
    goto label_39;
label_5:
    esi = eax + 1;
    goto label_2;
label_34:
    *(fp_stack--) = 1.0;
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
    goto label_6;
label_37:
    *(fp_stack--) = 1.0;
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
label_6:
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack[0] = -fp_stack[0];
    *(fp_stack--) = *((ebp - 0x48));
    __asm ("fcmovne st(0), st(1)");
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x48)) = fp_stack[0];
    *(fp_stack--) = 1.0;
    fp_tmp_12 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_12;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    edx = *((ebp - 0x6c));
    eax = edx + edx + 4;
    ecx = *((ebp - 0x34));
    eax += *(ecx);
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ebx = *((ebp - 0x34));
    eax = *(ebx);
    if (*((ebp - 0x50)) >= eax) {
        goto label_40;
    }
    edx = *((ebp - 0x50));
    edx <<= 4;
    edx += *((ebp - 0x3c));
    *((ebp - 0x20)) = edx;
    if (edi > *((edx + 4))) {
        goto label_40;
    }
    ebx = *((ebp - 0x50));
    esi = edi + 1;
    *((ebp - 0x24)) = esi;
label_3:
    if (*(edx) == 2) {
        goto label_41;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x3c));
    eax = edx + eax + 4;
    edx = ebx;
    edx <<= 4;
    ecx = *((ebp - 0x3c));
    edx = ecx + edx + 0x14;
    do {
        *(eax)++;
        ebx++;
        esi = *((ebp - 0x34));
        ecx = *(esi);
        if (ebx >= ecx) {
            goto label_42;
        }
        esi = *(edx);
        eax += 0x10;
        edx += 0x10;
    } while (edi < esi);
label_42:
    esi = ebx;
    esi <<= 4;
    esi += *((ebp - 0x3c));
    eax = ecx;
    eax -= ebx;
    eax <<= 4;
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x3c));
    eax = eax + edx + 0x20;
    memmove (eax, esi, eax);
    ecx = *((ebp - 0x34));
    *(ecx) += 2;
    eax = *((ebp - 0x24));
    *((esi + 4)) = eax;
    *(esi) = 2;
    *((esi + 8)) = 4;
    ebx++;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x3c));
    edx = *((ebp - 0x24));
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x48));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
label_41:
    ebx++;
    edx = *((ebp - 0x34));
    eax = *(edx);
    if (eax <= ebx) {
label_4:
        if (eax <= *((ebp - 0x50))) {
            goto label_40;
        }
        ebx = *((ebp - 0x20));
        ecx = *((ebx + 4));
        if (edi <= ecx) {
            goto label_43;
        }
        goto label_40;
    }
    edx = ebx;
    edx <<= 4;
    edx += *((ebp - 0x3c));
    if (edi <= *((edx + 4))) {
        goto label_3;
    }
    goto label_4;
label_43:
    eax = *((ebp - 0x50));
    eax <<= 4;
    esi = *((ebp - 0x3c));
    edx = eax + esi + 0x10;
    ebx = *((ebp - 0x50));
    esi = *((ebp - 0x20));
    do {
        ecx++;
        *((esi + 4)) = ecx;
        ebx++;
        ecx = *((ebp - 0x34));
        eax = *(ecx);
        if (eax <= ebx) {
            goto label_44;
        }
        esi = edx;
        ecx = *((edx + 4));
        edx += 0x10;
    } while (edi <= ecx);
    goto label_44;
label_40:
    ebx = *((ebp - 0x50));
label_44:
    esi = *((ebp - 0x50));
    esi <<= 4;
    esi += *((ebp - 0x3c));
    eax -= ebx;
    eax <<= 4;
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x3c));
    eax = eax + edx + 0x20;
    memmove (eax, esi, eax);
    ecx = *((ebp - 0x34));
    *(ecx) += 2;
    *((esi + 4)) = edi;
    *(esi) = 2;
    *((esi + 8)) = 3;
    ebx <<= 4;
    esi = *((ebp - 0x3c));
    eax = ebx + esi + 0x10;
    *((eax + 4)) = edi;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x48));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *((ebp - 0x58)) = 1;
    goto label_11;
label_16:
    fp_stack++;
    goto label_45;
label_25:
    fp_stack++;
    goto label_45;
label_26:
    fp_stack++;
label_45:
    eax = *((ebp - 0x70));
    *((ebp - 0x58)) = eax;
    goto label_11;
label_32:
    fp_stack++;
label_11:
    eax = *((ebp - 0x58));
    return eax;
label_39:
    edx = eax;
    edx <<= 4;
    if (edi <= *((edx + ebx + 4))) {
        goto label_5;
    }
    goto label_6;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8071341 */
#include <stdint.h>
 
int32_t dbg_try_factor (void) {
    double arg;
    /* void try_factor(double arg); */
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x10)) = fp_stack[0];
    ? = fp_stack[0];
    fp_stack--;
    ebx = unique;
    goto label_1;
label_0:
    eax = uno;
    if (eax > 0) {
        edx = eax - 1;
        *(fp_stack--) = *((ebx + edx*8));
        *(fp_stack--) = *((ebp - 0x10));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_2;
            }
            *((edx*4 + obj.ucnt))++;
        }
    } else {
label_2:
        *(fp_stack--) = *((ebp - 0x10));
        *((ebx + eax*8)) = fp_stack[0];
        fp_stack--;
        *((eax*4 + obj.ucnt)) = 1;
        eax++;
        *(obj.uno) = eax;
    }
    *(fp_stack--) = *((ebp - 0x10));
    *(obj.nn) /= fp_stack[0];
    *(obj.nn) = fp_stack[0];
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] = sqrt(fp_stack[0]);
    *(fp_stack--) = 1.0;
    fp_stack[1] += fp_stack[0];
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    *(obj.vv) = fp_stack[0];
    fp_stack--;
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] >= fp_stack[1]) {
            goto label_3;
        }
    } else {
        fp_stack++;
    }
label_1:
    *(fp_stack--) = *(obj.nn);
    *(fp_stack--) = fp_stack[?];
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_4;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x10));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_5;
label_4:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_5:
    *(fp_stack--) = 0.0;
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_3;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_0;
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805ae41 */
#include <stdint.h>
 
int32_t dbg_simp_pp (int32_t jlevel, int32_t j) {
    int32_t modified;
    int32_t var_40h;
    uint32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t ilevel;
    int32_t i;
    double denominator;
    double numerator;
    token_type * equation;
    int * np;
    int32_t var_8h;
    int32_t var_ch;
    ecx = jlevel;
    esi = j;
    /* int simp_pp(token_type * equation,int * np); */
    eax = *((ebp + 0xc));
    esi = *(eax);
    *((ebp - 0x44)) = 0;
    *((ebp - 0x2c)) = 1;
    if (esi <= 1) {
        goto label_2;
    }
label_1:
    edx = *((ebp - 0x2c));
    *((ebp - 0x40)) = edx;
    eax = edx;
    eax <<= 4;
    eax += *((ebp + 8));
    if (*((eax + 8)) != 6) {
        goto label_3;
    }
    eax = *((eax + 4));
    *((ebp - 0x30)) = eax;
    ecx = edx;
    ecx += 2;
    *((ebp - 0x3c)) = ecx;
    if (ecx >= esi) {
        goto label_3;
    }
    eax = ecx;
    eax <<= 4;
    edx = *((ebp + 8));
    eax = edx + eax + 4;
    ebx = ecx;
    ecx = *((ebp - 0x30));
    ecx--;
    *((ebp - 0x34)) = esi;
label_0:
    edi = ebx;
    edx = eax - 4;
    *((ebp - 0x38)) = edx;
    edx = *(eax);
    if (ecx != edx) {
        goto label_4;
    }
    if (*((eax + 4)) != 6) {
        goto label_4;
    }
    *((ebp - 0x30)) = ecx;
    esi = ebx;
    ecx = *((ebp - 0x38));
    *((ebp - 0x34)) = ecx;
    if (*(obj.symb_flag) != 0) {
        goto label_5;
    }
    edi <<= 4;
    edx = *((ebp + 8));
    eax = edi + edx + 0x10;
    ecx = *((ebp - 0x30));
    if (ecx != *((eax + 4))) {
        goto label_6;
    }
    if (*(eax) != 0) {
        goto label_6;
    }
    edx = ebp - 0x28;
    ecx = ebp - 0x20;
    *(fp_stack--) = *((eax + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = f_to_fraction (edx, ecx);
    *(fp_stack--) = *((ebp - 0x28));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(eax) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_7;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_8;
label_7:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_8:
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_5;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_5;
    }
    if (esi != *((ebp - 0x3c))) {
        goto label_3;
    }
    eax = *((ebp - 0x40));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    if (*(eax) != 0) {
        goto label_3;
    }
    ecx = ebp - 0x28;
    edx = ebp - 0x20;
    *(fp_stack--) = *((eax + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = f_to_fraction (ecx, edx);
    *(fp_stack--) = *((ebp - 0x20));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(eax) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_9;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_10;
label_9:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_10:
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_5;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_3;
    }
    goto label_5;
label_6:
    if (esi != *((ebp - 0x3c))) {
        goto label_3;
    }
    eax = *((ebp - 0x40));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    if (*(eax) != 0) {
        goto label_3;
    }
    ecx = ebp - 0x28;
    edx = ebp - 0x20;
    *(fp_stack--) = *((eax + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = f_to_fraction (ecx, edx);
    *(fp_stack--) = *((ebp - 0x20));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(eax) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_11;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_12;
label_11:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_12:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_3;
        }
    }
label_5:
    eax = *((ebp - 0x34));
    *((eax + 8)) = 3;
    edx = *((ebp + 0xc));
    if (esi >= *(edx)) {
        goto label_13;
    }
    edx = *((eax + 4));
    if (*((ebp - 0x30)) > edx) {
        goto label_13;
    }
    eax = esi;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x10;
    *((ebp - 0x34)) = esi;
    ecx = *((ebp - 0x38));
    edi = *((ebp - 0x30));
    esi = *((ebp + 0xc));
    do {
        edx += 2;
        *((ecx + 4)) = edx;
        ebx++;
        if (*(esi) <= ebx) {
            goto label_14;
        }
        ecx = eax;
        edx = *((eax + 4));
        eax += 0x10;
    } while (edi <= edx);
    esi = *((ebp - 0x34));
    goto label_13;
label_14:
    esi = *((ebp - 0x34));
label_13:
    edx = *((ebp - 0x2c));
    edx++;
    if (esi <= edx) {
        goto label_15;
    }
    eax = edx;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = ecx + eax + 4;
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (esi > edx);
label_15:
    *((ebp - 0x2c)) -= 2;
    *((ebp - 0x44)) = 1;
    goto label_3;
label_4:
    if (*((ebp - 0x30)) >= edx) {
        goto label_3;
    }
    ebx += 2;
    eax += 0x20;
    if (*((ebp - 0x34)) > ebx) {
        goto label_0;
    }
label_3:
    *((ebp - 0x2c)) += 2;
    eax = *((ebp + 0xc));
    esi = *(eax);
    if (esi > *((ebp - 0x2c))) {
        goto label_1;
    }
label_2:
    eax = *((ebp - 0x44));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d82f */
#include <stdint.h>
 
uint32_t dbg_simps_side (int32_t arg_8h, size_t * arg_ch, size_t * arg_10h, int * np, token_type * equation, int32_t zsolve) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = np;
    esi = equation;
    edi = zsolve;
    /* void simps_side(token_type * equation,int * np,int zsolve); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    elim_loop (esi, ebx);
    *((esp + 4)) = ebx;
    simp_constant_power (esi);
    do {
        al = (edi == 0) ? 1 : 0;
        eax = (int32_t) al;
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        simp_ssub (6, ebx, 0);
        *((esp + 8)) = 0;
        *((esp + 4)) = ebx;
        *(esp) = esi;
        eax = super_factor ();
    } while (eax != 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805cf2c */
#include <stdint.h>
 
int32_t dbg_elim_loop (void * arg_8h, char * arg_ch, int * np, token_type * equation) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ebx = np;
    esi = equation;
    /* void elim_loop(token_type * equation,int * np); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = abort_flag;
    if (eax != 0) {
        *(obj.abort_flag) = 0;
        *((esp + 4)) = 0xd;
        *(esp) = obj.jmp_save;
        longjmp_chk ();
    }
    *((esp + 0x10)) = 0;
    eax = *(ebx);
    list_debug (0, esi, eax);
    do {
label_0:
        *((esp + 4)) = ebx;
        organize (esi);
        *((esp + 8)) = 1;
        *((esp + 4)) = ebx;
        *(esp) = esi;
        eax = combine_constants ();
    } while (eax != 0);
    *((esp + 4)) = ebx;
    eax = elim_k (esi);
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = simp_pp ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = reorder ();
    if (eax == 0) {
        goto label_1;
    }
    do {
        *((esp + 4)) = ebx;
        organize (esi);
        *((esp + 4)) = ebx;
        eax = elim_k (esi);
    } while (eax != 0);
label_1:
    *((esp + 0x10)) = 0;
    eax = *(ebx);
    list_debug (0, esi, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8059ed8 */
#include <stdint.h>
 
int32_t dbg_simp_constant_power (char * arg_ch, int32_t i, int * np) {
    int32_t var_2ch;
    int32_t j;
    uint32_t var_24h;
    int32_t level;
    int32_t modified;
    token_type * equation;
    void * s2;
    size_t n;
    ecx = i;
    edi = np;
    /* int simp_constant_power(token_type * equation,int * np); */
    edi = *((ebp + 0xc));
    if (*(obj.symb_flag) == 0) {
        goto label_0;
    }
    eax = *(edi);
    if (eax <= 1) {
        goto label_0;
    }
    ebx = *((ebp + 8));
    ebx += 0x30;
    esi = 3;
    *((ebp - 0x1c)) = 0;
    do {
        if (*((ebx - 0x18)) == 6) {
            edx = *((ebx - 0x1c));
            *((ebp - 0x20)) = edx;
            if (edx == *((ebx - 0x2c))) {
                if (*((ebx - 0x30)) == 0) {
                    edx = *((ebx - 0xc));
                    *((ebp - 0x24)) = edx;
                    edx = *((ebp - 0x20));
                    edx++;
                    if (*((ebp - 0x24)) != edx) {
                        goto label_1;
                    }
                    if (*((ebx - 0x10)) != 0) {
                        goto label_1;
                    }
                    *(fp_stack--) = *((ebx - 8));
                    *(fp_stack--) = 1.0;
                    fp_tmp_0 = fp_stack[1];
                    fp_stack[1] = fp_stack[0];
                    fp_stack[0] = fp_tmp_0;
                    fp_stack--;
                    fp_stack++;
                    if (fp_stack[0] != fp_stack[1]) {
                        if (fp_stack[0] == fp_stack[1]) {
                            goto label_1;
                        }
                    }
                    *((ebp - 0x28)) = esi;
                    if (esi >= eax) {
                        goto label_1;
                    }
                    *((ebp - 0x2c)) = ebx;
                    edx = *((ebp - 0x24));
                    if (edx != *((ebx + 4))) {
                        goto label_1;
                    }
                    edx = *((ebx + 8));
                    if (edx != 3) {
                        if (edx != 4) {
                            goto label_1;
                        }
                        eax += 2;
                        if (eax > *(obj.n_tokens)) {
                            error_huge ();
                        }
                        eax = *(edi);
                        eax -= *((ebp - 0x28));
                        eax <<= 4;
                        eax = *((ebp - 0x2c));
                        eax = ebx + 0x20;
                        memmove (eax, eax, eax);
                        *(edi) += 2;
                        edx = *((ebp - 0x24));
                        *((ebx + 0x14)) = edx;
                        *((ebx + 0x10)) = 0;
                        *(fp_stack--) = 1.0;
                        *((ebx + 0x18)) = fp_stack[0];
                        fp_stack--;
                    }
                    eax = *((ebp - 0x20));
                    *((ebx + 4)) = eax;
                    *((ebx + 8)) = 6;
                    *((ebx - 0x2c))++;
                    *((ebx - 0x1c))++;
                    eax = 1;
                }
            } else {
label_1:
                eax = 0;
            }
            *((ebp - 0x1c)) |= eax;
        }
        edx = esi;
        eax = *(edi);
        esi += 2;
        ebx += 0x20;
    } while (eax > edx);
    goto label_2;
label_0:
    *((ebp - 0x1c)) = 0;
label_2:
    eax = *((ebp - 0x1c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d23f */
#include <stdint.h>
 
uint32_t dbg_simp_ssub (void * arg_8h, size_t * arg_ch, size_t * arg_10h, char * arg_1ch, int32_t arg_20h, int32_t arg_24h, token_type * equation, int * np, int32_t times_flag) {
    double d;
    int32_t var_4h;
    size_t * var_8h;
    ebx = equation;
    esi = np;
    edi = times_flag;
    /* void simp_ssub(token_type * equation,int * np,long int v,double d,int power_flag,int times_flag,int fc_level); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    *(fp_stack--) = *((ebp + 0x14));
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    edi = *((ebp + 0x20));
    do {
label_0:
        elim_loop (ebx, esi);
        *((esp + 4)) = esi;
        *(esp) = ebx;
        eax = simp2_power ();
    } while (eax != 0);
    if (edi == 0) {
        goto label_1;
    }
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_times ();
    if (eax != 0) {
        goto label_0;
    }
label_1:
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = elim_sign ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = subtract_itself ();
    if (eax != 0) {
        goto label_0;
    }
    eax = *((ebp + 0x24));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    eax = factor_constants (ebx);
    if (eax != 0) {
        goto label_0;
    }
    *(fp_stack--) = *((ebp - 0x20));
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_divide ();
    if (eax != 0) {
        goto label_0;
    }
    *(fp_stack--) = *((ebp - 0x20));
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_plus ();
    if (eax != 0) {
        goto label_0;
    }
    if (*((ebp + 0x1c)) == 0) {
        goto label_2;
    }
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_power ();
    if (eax != 0) {
        goto label_0;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061b12 */
#include <stdint.h>
 
int32_t dbg_super_factor (int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    token_type * equation;
    int * np;
    int32_t start_flag;
    size_t * var_sp_4h;
    edi = rv;
    /* int super_factor(token_type * equation,int * np,int start_flag); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    *(esp) = esi;
    group_proc ();
    eax = *((ebp + 0x10));
    *((esp + 4)) = eax;
    *(esp) = 1;
    ecx = 0;
    edx = ebx;
    eax = esi;
    eax = sf_recurse ();
    edi = eax;
    *((esp + 4)) = ebx;
    organize (esi);
    eax = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061af3 */
#include <stdint.h>
 
int32_t dbg_group_proc (void) {
    token_type * equation;
    int * np;
    /* void group_proc(token_type * equation,int * np); */
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    group_recurse (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805ceba */
#include <stdint.h>
 
int32_t dbg_organize (char * arg_ch, int * np) {
    token_type * equation;
    char * var_4h;
    int32_t var_8h;
    ebx = np;
    /* void organize(token_type * equation,int * np); */
    ebx = *((ebp + 0xc));
    eax = *(ebx);
    if (eax > 0) {
        if ((al & 1) != 0) {
            goto label_0;
        }
    }
    *((esp + 8)) = eax;
    *((esp + 4)) = "Bad expression size = %d.\n";
    *(esp) = 1;
    printf_chk ();
    error_bug ("Internal error: organize() called with bad expression size.");
label_0:
    eax = *(ebx);
    if (eax > *(obj.n_tokens)) {
        error_bug ("Internal error: expression array overflow detected in organize().");
    }
    *((esp + 4)) = 0;
    ecx = 0;
    edx = ebx;
    eax = *((ebp + 8));
    org_recurse (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8071415 */
#include <stdint.h>
 
int32_t dbg_factor_one (int32_t i) {
    double d;
    double value;
    ebx = i;
    /* int factor_one(double value); */
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x18)) = fp_stack[0];
    *(obj.uno) = 0;
    *(obj.nn) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_1;
        }
    }
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *(0x8076b48);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_2;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x18));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_3;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x18));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_3:
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_2;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_2;
    }
    *(fp_stack--) = *(obj.nn);
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] = sqrt(fp_stack[0]);
    *(fp_stack--) = 1.0;
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(obj.vv) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(0x8072058);
    *(esp) = fp_stack[0];
    fp_stack--;
    try_factor ();
    *(fp_stack--) = *(0x807205c);
    *(esp) = fp_stack[0];
    fp_stack--;
    try_factor ();
    *(fp_stack--) = *(0x8077e40);
    *(esp) = fp_stack[0];
    fp_stack--;
    try_factor ();
    *(fp_stack--) = *(0x8077e44);
    *(esp) = fp_stack[0];
    fp_stack--;
    try_factor ();
    *(fp_stack--) = 1.0;
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    esi = skip_multiples;
    goto label_4;
label_0:
    ebx = 0;
    do {
        *(fp_stack--) = *((ebp - 0x10));
        fp_stack[0] += *((esi + ebx*8));
        *((ebp - 0x10)) = fp_stack[0];
        *(esp) = fp_stack[0];
        fp_stack--;
        try_factor ();
        ebx++;
    } while (ebx != 0x30);
label_4:
    *(fp_stack--) = *(obj.vv);
    *(fp_stack--) = *((ebp - 0x10));
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_0;
    }
    *(fp_stack--) = *(obj.nn);
    *(fp_stack--) = 1.0;
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_5;
        }
    }
    *(esp) = fp_stack[0];
    fp_stack--;
    try_factor ();
    goto label_6;
label_5:
    fp_stack++;
label_6:
    multiply_out_unique ();
    eax = 1;
    *(fp_stack--) = *((ebp - 0x18));
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_7;
        }
    }
    error_bug ("Internal error factoring integers.");
    eax = 1;
    goto label_7;
label_1:
    fp_stack++;
label_2:
    eax = 0;
label_7:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80685de */
#include <stdint.h>
 
int32_t dbg_poly_factor (void) {
    token_type * equation;
    int * np;
    int32_t do_repeat;
    size_t * var_4h;
    /* int poly_factor(token_type * equation,int * np,int do_repeat); */
    eax = *((ebp + 0x10));
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    pf_recurse (1, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d1b8 */
#include <stdint.h>
 
uint32_t dbg_simp2_divide (int32_t arg_8h, char * arg_ch, size_t arg_10h, char * arg_14h, token_type * equation, int * np, int32_t fc_level) {
    int32_t var_4h;
    size_t var_8h;
    ebx = equation;
    esi = np;
    edi = fc_level;
    /* void simp2_divide(token_type * equation,int * np,long int v,int fc_level); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = *((ebp + 0x14));
    do {
label_0:
        elim_loop (ebx, esi);
        *((esp + 4)) = esi;
        *(esp) = ebx;
        eax = simp2_power ();
    } while (eax != 0);
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = elim_sign ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = subtract_itself ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 8)) = edi;
    *((esp + 4)) = esi;
    eax = factor_constants (ebx);
    if (eax != 0) {
        goto label_0;
    }
    *(fp_stack--) = 0.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_divide ();
    if (eax != 0) {
        goto label_0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8059cbe */
#include <stdint.h>
 
int32_t dbg_simp2_power (int32_t k, int32_t level) {
    int32_t var_4ch;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t op;
    int32_t modified;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    ebx = k;
    edi = level;
    /* int simp2_power(token_type * equation,int * np); */
    edx = *((ebp + 0xc));
    eax = *(edx);
    *((ebp - 0x2c)) = 0;
    if (eax <= 1) {
        goto label_1;
    }
    esi = *((ebp + 8));
    esi += 0x20;
    *((ebp - 0x1c)) = 1;
label_0:
    if (*((esi - 8)) != 6) {
        goto label_2;
    }
    ecx = *((esi - 0xc));
    *((ebp - 0x20)) = ecx;
    edx = *((ebp - 0x1c));
    *((ebp - 0x34)) = edx;
    ecx = edx;
    ecx++;
    *((ebp - 0x28)) = ecx;
    if (eax <= ecx) {
        goto label_3;
    }
    edi = esi;
    ecx = *((esi + 4));
    if (*((ebp - 0x20)) > ecx) {
        goto label_3;
    }
    edx = esi + 0x10;
    *((ebp - 0x4c)) = edx;
    ebx = *((ebp - 0x28));
    *((ebp - 0x30)) = 0;
    *((ebp - 0x24)) = 0xffffffff;
    edx = *((ebp - 0x20));
    edx++;
    *((ebp - 0x38)) = edx;
    *((ebp - 0x3c)) = esi;
    edx = *((ebp - 0x4c));
    esi = *((ebp - 0x38));
    do {
        if (esi == ecx) {
            ecx = *(edi);
            if (ecx == 2) {
                edi = *((edi + 8));
                *((ebp - 0x30)) = edi;
            } else {
                if (ecx != 0) {
                    goto label_4;
                }
                *(fp_stack--) = *((edi + 8));
                *(fp_stack--) = 0.0;
                fp_stack--;
                fp_stack++;
                ecx = *((ebp - 0x24));
                if (fp_stack[0] > fp_stack[1]) {
                    ecx = ebx;
                }
                *((ebp - 0x24)) = ecx;
            }
        }
label_4:
        ebx++;
        if (ebx >= eax) {
            goto label_5;
        }
        edi = edx;
        ecx = *((edx + 4));
        edx += 0x10;
    } while (*((ebp - 0x20)) <= ecx);
    esi = *((ebp - 0x3c));
    goto label_6;
label_3:
    ebx = *((ebp - 0x28));
    *((ebp - 0x30)) = 0;
    *((ebp - 0x24)) = 0xffffffff;
    goto label_6;
label_5:
    esi = *((ebp - 0x3c));
label_6:
    edx = ebx;
    edx -= *((ebp - 0x1c));
    if (edx <= 2) {
        if (*(esi) != 0) {
            goto label_7;
        }
        *(fp_stack--) = *((esi + 8));
        *(fp_stack--) = 0.0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] > fp_stack[1]) {
            goto label_8;
        }
    }
label_7:
    if (*((ebp - 0x24)) < 0) {
        goto label_9;
    }
    edx = *((ebp - 0x24));
    *((ebp - 0x28)) = edx;
label_8:
    if (*((ebp - 0x30)) > 4) {
        goto label_9;
    }
    edx = 1;
    ecx = *((ebp - 0x30));
    edx <<= cl;
    if ((dl & 0x19) == 0) {
        goto label_9;
    }
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp - 0x28));
    eax <<= 4;
    eax += *((ebp + 8));
    *(fp_stack--) = *((eax + 8));
    fp_stack[0] = -fp_stack[0];
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x34));
    eax -= 2;
    if (eax < 0) {
        goto label_10;
    }
    edx = *((ebp - 0x20));
    if (edx > *((esi - 0x2c))) {
        goto label_10;
    }
    edx = esi - 0x3c;
    edi = *((ebp - 0x20));
    while (eax >= 0) {
        ecx = *(edx);
        edx -= 0x10;
        if (edi > ecx) {
            goto label_10;
        }
        eax--;
    }
label_10:
    edi = eax + 1;
    if (ebx <= edi) {
        goto label_11;
    }
    eax = edi;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = ecx + eax + 4;
    edx = edi;
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (ebx > edx);
label_11:
    ebx = edi;
    ebx <<= 4;
    ebx += *((ebp + 8));
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= edi;
    eax <<= 4;
    eax = edi;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x20;
    memmove (eax, ebx, eax);
    eax = *((ebp + 0xc));
    *(eax) += 2;
    edx = *((ebp - 0x20));
    *((ebx + 4)) = edx;
    *(ebx) = 0;
    *(fp_stack--) = 1.0;
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    edi <<= 4;
    edx = *((ebp + 8));
    eax = edi + edx + 0x10;
    ecx = *((ebp - 0x20));
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 4;
    eax = 1;
    goto label_12;
label_9:
    eax = 0;
label_12:
    *((ebp - 0x2c)) |= eax;
label_2:
    *((ebp - 0x1c)) += 2;
    edx = *((ebp + 0xc));
    eax = *(edx);
    esi += 0x20;
    if (eax > *((ebp - 0x1c))) {
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805a9a6 */
#include <stdint.h>
 
int32_t dbg_elim_sign (int32_t j) {
    int32_t var_3ch;
    int32_t modified;
    int32_t var_34h;
    int32_t var_30h;
    int32_t level;
    double denominator;
    double numerator;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    int32_t var_ch;
    ebx = j;
    /* int elim_sign(token_type * equation,int * np); */
    eax = *((ebp + 0xc));
    edx = *(eax);
    *((ebp - 0x38)) = 0;
    ebx = 1;
    if (edx <= 1) {
        goto label_1;
    }
label_0:
    *((ebp - 0x3c)) = ebx;
    esi = ebx;
    esi <<= 4;
    esi += *((ebp + 8));
    ecx = *((esi + 4));
    *((ebp - 0x2c)) = ecx;
    eax = *((esi + 8));
    if (eax == 4) {
        edi = ebx;
        edi <<= 4;
        ecx = *((ebp + 8));
        ecx = edi + ecx + 0x10;
        *((ebp - 0x34)) = ecx;
        edi = *((ecx + 4));
        *((ebp - 0x30)) = edi;
        ecx = *((ebp - 0x2c));
        if (edi != ecx) {
            goto label_2;
        }
        edi = *((ebp - 0x34));
        if (*(edi) != 1) {
            goto label_3;
        }
        if (*((edi + 8)) != 3) {
            goto label_3;
        }
        edx += 2;
        if (edx > *(obj.n_tokens)) {
            error_huge ();
        }
        edx = *((ebp + 0xc));
        eax = *(edx);
        eax -= ebx;
        eax <<= 4;
        edi = *((ebp - 0x3c));
        edi <<= 4;
        ecx = *((ebp + 8));
        eax = edi + ecx + 0x20;
        memmove (eax, esi, eax);
        edi = *((ebp + 0xc));
        *(edi) += 2;
        eax = *((ebp - 0x30));
        *((esi + 4)) = eax;
        *(esi) = 2;
        *((esi + 8)) = 3;
        eax = ebx;
        eax <<= 4;
        edx = *((ebp + 8));
        eax = eax + edx + 0x10;
        ecx = *((ebp - 0x30));
        *((eax + 4)) = ecx;
        *(eax) = 0;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        ebx += 2;
        eax = ebx;
        eax <<= 4;
        eax += edx;
        *((eax + 4)) = ecx;
        *(eax) = 2;
        *((eax + 8)) = 3;
        *((ebp - 0x38)) = 1;
        goto label_3;
    }
label_2:
    if (eax != 6) {
        goto label_3;
    }
    eax = *((ebp - 0x3c));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    *((ebp - 0x30)) = eax;
    ecx = *((eax + 4));
    *((ebp - 0x34)) = ecx;
    edi = *((ebp - 0x2c));
    if (ecx != edi) {
        goto label_3;
    }
    if (*(eax) != 0) {
        goto label_3;
    }
    eax = ebp - 0x28;
    edx = ebp - 0x20;
    ecx = *((ebp - 0x30));
    *(fp_stack--) = *((ecx + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = f_to_fraction (eax, edx);
    *(fp_stack--) = *((ebp - 0x20));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    edi = *((ebp - 0x3c));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(eax) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    *((ebp - 0x3c)) = edi;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_4;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_5;
label_4:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_5:
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_6;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_6;
    }
    edi = *((ebp - 0x3c));
    edi <<= 4;
    edx = *((ebp + 8));
    eax = edi + edx - 0x10;
    ecx = *((ebp - 0x34));
    if (ecx == *((eax + 4))) {
        if (*(eax) != 1) {
            goto label_7;
        }
        if (*((eax + 8)) != 3) {
            goto label_7;
        }
        *(eax) = 0;
        *(fp_stack--) = 1.0;
        fp_stack[0] = -fp_stack[0];
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x30));
        *(fp_stack--) = *((eax + 8));
        fp_stack[0] *= *(0x8072054);
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x38)) = 1;
        goto label_3;
    }
label_7:
    edx = ebx;
    edx--;
    *((ebp - 0x2c)) = edx;
    if (edx < 0) {
        goto label_3;
    }
    esi = edx;
    esi <<= 4;
    esi += *((ebp + 8));
    edx = *((esi + 4));
    if (*((ebp - 0x34)) > edx) {
        goto label_8;
    }
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx - 0x20;
    ecx = *((ebp - 0x2c));
    edi = *((ebp - 0x34));
    edi++;
    *((ebp - 0x30)) = ebx;
    ebx = *((ebp - 0x34));
    do {
        if (edi >= edx) {
            if (*(esi) != 2) {
                goto label_9;
            }
            ebx = *((ebp - 0x30));
            if (*((esi + 8)) > 4) {
                goto label_3;
            }
            ecx = *((esi + 8));
            eax = 1;
            eax <<= cl;
            if ((al & 0x19) != 0) {
                goto label_10;
            }
            goto label_3;
        }
label_9:
        ecx--;
        if (ecx < 0) {
            goto label_11;
        }
        esi = eax;
        edx = *((eax + 4));
        eax -= 0x10;
    } while (ebx <= edx);
    ebx = *((ebp - 0x30));
    goto label_8;
label_10:
    if (*((ebp - 0x2c)) < 0) {
        goto label_3;
label_11:
        ebx = *((ebp - 0x30));
    }
label_8:
    ecx = *((ebp - 0x2c));
    ecx <<= 4;
    ecx += *((ebp + 8));
    edx = *((ecx + 4));
    if (*((ebp - 0x34)) > edx) {
        goto label_3;
    }
    eax = ebx;
    eax <<= 4;
    esi = *((ebp + 8));
    eax = eax + esi - 0x20;
    esi = *((ebp - 0x34));
    esi++;
    *((ebp - 0x30)) = ebx;
    ebx = *((ebp - 0x2c));
    do {
        if (esi >= edx) {
            edx = *(ecx);
            if (edx == 1) {
                edi = *((ecx + 8));
                edi &= 0x3fff;
                if (edi == 4) {
                    *(ecx) = 0;
                    *(fp_stack--) = 1.0;
                    *((ecx + 8)) = fp_stack[0];
                    fp_stack--;
                    *((ebp - 0x38)) = 1;
                }
            } else {
                if (edx != 0) {
                    goto label_12;
                }
                *(fp_stack--) = *((ecx + 8));
                *(fp_stack--) = 0.0;
                fp_stack--;
                if (fp_stack[0] > fp_stack[1]) {
                    fp_stack[0] = -fp_stack[0];
                    *((ecx + 8)) = fp_stack[0];
                    fp_stack--;
                    *((ebp - 0x38)) = 1;
                } else {
                    fp_stack++;
                }
            }
        }
label_12:
        ebx--;
        if (ebx < 0) {
            goto label_13;
        }
        ecx = eax;
        edx = *((eax + 4));
        eax -= 0x10;
    } while (*((ebp - 0x34)) <= edx);
    ebx = *((ebp - 0x30));
    goto label_3;
label_6:
    edi = *((ebp - 0x3c));
    edi <<= 4;
    edx = *((ebp + 8));
    eax = edi + edx - 0x10;
    ecx = *((ebp - 0x2c));
    if (*((eax + 4)) != ecx) {
        goto label_3;
    }
    if (*(eax) != 1) {
        goto label_3;
    }
    eax = *((eax + 8));
    if (eax != 3) {
        goto label_14;
    }
    edi = *((ebp - 0x30));
    *(fp_stack--) = *((edi + 8));
    *(fp_stack--) = *(0x8072774);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (eax == 3);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_15;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072774);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_16;
label_15:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_16:
    *(fp_stack--) = 1.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_17;
        }
        fp_stack++;
        *((esi + 8)) = 3;
        *(fp_stack--) = 1.0;
        eax = *((ebp - 0x30));
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x38)) = 1;
        goto label_3;
    }
label_17:
    *(fp_stack--) = *(0x807205c);
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_3;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_3;
    }
    *((esi + 8)) = 3;
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    eax = *((ebp - 0x30));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *((ebp - 0x38)) = 1;
    goto label_3;
label_14:
    eax &= 0x3fff;
    if (eax != 4) {
        goto label_3;
    }
    *(fp_stack--) = *((ebp - 0x28));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (eax == 4);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_18;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = fmod ();
    goto label_19;
label_18:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_19:
    *(fp_stack--) = 1.0;
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_3;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_3;
    }
    *(fp_stack--) = *((ebp - 0x20));
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_20;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *(0x8072058);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_21;
label_20:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_21:
    *((ebp - 0x20)) = fp_stack[0];
    eax = *((ebp - 0x30));
    *(fp_stack--) = *((eax + 8));
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_22;
        }
    }
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *((ebp - 0x38)) = 1;
    goto label_3;
label_13:
    ebx = *((ebp - 0x30));
    goto label_3;
label_22:
    fp_stack++;
label_3:
    ebx += 2;
    ecx = *((ebp + 0xc));
    edx = *(ecx);
    if (edx > ebx) {
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x38));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8060c4d */
#include <stdint.h>
 
int32_t dbg_subtract_itself (void) {
    token_type * equation;
    int * np;
    int32_t var_4h;
    int32_t var_10h;
    int32_t var_14h;
    /* int subtract_itself(token_type * equation,int * np); */
    *((esp + 0x14)) = 0;
    *((esp + 0x10)) = 1;
    *(fp_stack--) = 0.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = 0;
    *(esp) = 1;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    fplus_recurse ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x807122f */
#include <stdint.h>
 
int32_t dbg_factor_constants (int32_t arg_10h) {
    token_type * equation;
    int * np;
    int32_t var_4h;
    /* int factor_constants(token_type * equation,int * np,int level_code); */
    edx = *((ebp + 0x10));
    eax = 0;
    if (edx != 3) {
        *((esp + 4)) = edx;
        ecx = 0;
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        fc_recurse (1);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8060c8a */
#include <stdint.h>
 
int32_t dbg_factor_divide (void) {
    token_type * equation;
    int * np;
    long int v;
    double d;
    size_t var_4h;
    int32_t var_10h;
    int32_t var_14h;
    /* int factor_divide(token_type * equation,int * np,long int v,double d); */
    *((esp + 0x14)) = 1;
    *((esp + 0x10)) = 0;
    *(fp_stack--) = *((ebp + 0x14));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x10));
    *((esp + 4)) = eax;
    *(esp) = 1;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    fplus_recurse ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d89d */
#include <stdint.h>
 
int32_t dbg_complex_negate (int32_t arg_8h) {
    complexs a;
    /* complexs complex_negate(complexs a); */
    eax = *((ebp + 8));
    *(fp_stack--) = *((ebp + 0xc));
    fp_stack[0] = -fp_stack[0];
    *(fp_stack--) = *((ebp + 0x14));
    fp_stack[0] = -fp_stack[0];
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049450 */
#include <stdint.h>
 
void dbg_alarmhandler (void) {
    int32_t sig;
    char * var_4h;
    /* void alarmhandler(int sig); */
    *((esp + 4)) = "\nTimeout, quitting...\n";
    *(esp) = 1;
    printf_chk ();
    exit_program (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049395 */
#include <stdint.h>
 
int32_t dbg_exit_program (int32_t arg_8h, int32_t exit_value) {
    char * var_4h;
    char * var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ebx = exit_value;
    /* void exit_program(int exit_value); */
    ebx = *((ebp + 8));
    reset_attr ();
    if (*(obj.html_flag) != 0) {
        *((esp + 4)) = "</pre>\n";
        *(esp) = 1;
        printf_chk ();
    }
    if (*(obj.readline_enabled) != 0) {
        eax = history_filename;
        *(esp) = eax;
        eax = write_history ();
        if (eax == 0) {
            goto label_0;
        }
        eax = history_filename;
        *((esp + 0x10)) = eax;
        eax = prog_name;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "%s: Unable to save readline history into file \"%s\".\n";
        *((esp + 4)) = 1;
        eax = stderr;
        *(esp) = eax;
        fprintf_chk ();
    }
label_0:
    if (ebx == 0) {
        if (*(obj.quiet_mode) != 0) {
            goto label_1;
        }
        if (*(obj.html_flag) != 0) {
            goto label_1;
        }
        *((esp + 4)) = "Thank you for using Mathomatic!\n";
        *(esp) = 1;
        printf_chk ();
    }
label_1:
    return exit (ebx);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805069f */
#include <stdint.h>
 
int32_t dbg_handle_negate (char * arg_ch, int32_t i, int * np) {
    token_type * equation;
    int32_t var_4h;
    int32_t var_8h;
    esi = i;
    edi = np;
    /* void handle_negate(token_type * equation,int * np); */
    edi = *((ebp + 0xc));
    if (*(edi) <= 1) {
        goto label_0;
    }
    ebx = *((ebp + 8));
    esi = 1;
    do {
        if (*((ebx + 0x18)) == 8) {
            *((ebx + 0x18)) = 3;
            if (*(obj.negate_highest_precedence) == 0) {
                goto label_1;
            }
            *((esp + 8)) = esi;
            eax = *(edi);
            *((esp + 4)) = eax;
            eax = *((ebp + 8));
            binary_parenthesize (eax);
        }
label_1:
        esi += 2;
        ebx += 0x20;
    } while (*(edi) > esi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804aded */
#include <stdint.h>
 
int32_t dbg_prompt_var (uint32_t arg_8h, long int * vp, char * cp) {
    char[4096] buf;
    int32_t canary;
    char * var_4h;
    int32_t var_8h;
    esi = vp;
    eax = cp;
    /* int prompt_var(long int * vp); */
    esi = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    ebx = ebp - 0x100c;
    do {
label_0:
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter variable: ");
        eax = get_string (ebx, 0x1000);
        if (eax == 0) {
            goto label_1;
        }
        if (*(eax) == 0) {
            goto label_1;
        }
        eax = parse_var2 (esi, eax);
    } while (eax == 0);
    eax = extra_characters (eax);
    if (eax != 0) {
        goto label_0;
    }
    al = 1;
    goto label_2;
label_1:
    eax = 0;
label_2:
    edx = *((ebp - 0xc));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806447a */
#include <stdint.h>
 
int32_t dbg_remove_factors (int32_t i, int32_t plus_flag, int32_t op, int32_t j) {
    int32_t divide_flag;
    void * s1;
    int32_t var_bp_1ch;
    void * s2;
    size_t n;
    char * var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = i;
    edx = plus_flag;
    esi = op;
    eax = j;
    /* int remove_factors(); */
    if (*(obj.debug_level) > 2) {
        *((esp + 0xc)) = "Entering remove_factors() with:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 0x10)) = 0;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (0, eax, eax);
    do {
        *(fp_stack--) = 1.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = tlhs;
        simp_ssub (4, 0x80796b8, 0);
        eax = tlhs;
        eax = uf_power (eax, 0x80796b8);
    } while (eax != 0);
    if (*(obj.n_tlhs) <= 1) {
        goto label_1;
label_0:
        esi = *((ebp - 0x20));
        eax = *((ebp - 0x1c));
        if (ecx != 0) {
            if (*((ebp - 0x24)) != 0) {
                goto label_2;
            }
            if (esi > 0) {
                eax--;
                *((ebp - 0x1c)) = eax;
            }
            ebx -= *((ebp - 0x1c));
            eax = ebx;
            eax <<= 4;
            eax = *((ebp - 0x1c));
            eax <<= 4;
            eax += *(obj.tlhs);
            eax = esi;
            eax <<= 4;
            eax += *(obj.scratch);
            memmove (eax, eax, eax);
            ebx += esi;
            *((ebp - 0x20)) = ebx;
        }
label_2:
        if (*((ebp - 0x20)) <= 0) {
            goto label_1;
        }
        eax = *((ebp - 0x20));
        eax <<= 4;
        eax = scratch;
        eax = tlhs;
        memmove (eax, eax, eax);
        eax = *((ebp - 0x20));
        *(obj.n_tlhs) = eax;
        *((esp + 0x10)) = 0;
        eax = tlhs;
        list_debug (0, eax, eax);
        eax = 1;
        goto label_3;
    }
    *((ebp - 0x24)) = 0;
    ecx = 0;
    *((ebp - 0x20)) = 0;
    *((ebp - 0x1c)) = 0;
    ebx = 1;
    do {
        edx = tlhs;
        edi = ebx;
        eax = ebx;
        eax <<= 4;
        eax = edx + eax;
        esi = *((eax + 8));
        eax = *((eax + 4));
        if (eax != 1) {
            if (eax != 2) {
                goto label_4;
            }
        } else {
            if (esi < 1) {
                goto label_1;
            }
            if (esi <= 2) {
                goto label_5;
            }
            if (esi > 4) {
                goto label_1;
            }
            if (ecx != 0) {
                if (*((ebp - 0x24)) != 0) {
                    goto label_6;
                }
                al = (*((ebp - 0x20)) > 0) ? 1 : 0;
                eax = (int32_t) al;
                *((ebp - 0x1c)) -= eax;
                eax = ebx;
                eax -= *((ebp - 0x1c));
                *((ebp - 0x24)) = eax;
                eax <<= 4;
                eax = *((ebp - 0x1c));
                eax <<= 4;
                eax = edx + eax;
                eax = *((ebp - 0x20));
                eax <<= 4;
                eax += *(obj.scratch);
                memmove (eax, eax, eax);
                eax = *((ebp - 0x24));
                *((ebp - 0x20)) += eax;
            }
label_6:
            al = (esi == 4) ? 1 : 0;
            eax = (int32_t) al;
            *((ebp - 0x24)) = eax;
            edi++;
            *((ebp - 0x1c)) = edi;
            ecx = 0;
            goto label_4;
        }
        esi--;
        if (esi <= 1) {
label_5:
            ecx = 1;
        }
label_4:
        ebx += 2;
    } while (*(obj.n_tlhs) > ebx);
    goto label_0;
label_1:
    eax = 0;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ac49 */
#include <stdint.h>
 
int32_t dbg_check_divide_by_zero (void) {
    /* int check_divide_by_zero(double denominator); */
    eax = 0;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp + 8));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_0;
        }
        warning ("Division by zero.");
        eax = 1;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ac01 */
#include <stdint.h>
 
void dbg_warning (int32_t arg_8h, char const * str) {
    char * var_4h;
    int32_t var_8h;
    ebx = str;
    /* void warning(char const * str); */
    ebx = *((ebp + 8));
    *(obj.warning_str) = ebx;
    if (*(obj.debug_level) >= 0) {
        set_color (1);
        *((esp + 8)) = ebx;
        *((esp + 4)) = "Warning: %s\n";
        *(esp) = 1;
        printf_chk ();
        default_color ();
    }
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805178a */
#include <stdint.h>
 
uint32_t dbg_unfactor_cmd (int32_t quick_flag, int32_t fraction_flag) {
    int32_t power_flag;
    uint32_t var_2ch;
    int32_t j;
    int32_t i;
    char * cp;
    char * s2;
    size_t n;
    esi = quick_flag;
    edi = fraction_flag;
    /* int unfactor_cmd(char * cp); */
    *((ebp - 0x30)) = 0;
    *((ebp - 0x2c)) = 0;
    esi = 0;
    edi = 1;
    do {
        ebx = *((ebp + 8));
        eax = strncasecmp (ebx, "quick", 4);
        if (eax == 0) {
            esi = edi;
        } else {
            eax = strncasecmp (ebx, "fraction", 4);
            if (eax != 0) {
                eax = strncasecmp (ebx, "fully", 4);
                if (eax != 0) {
                    eax = strncasecmp (ebx, 0x8075c80, 4);
                    if (eax != 0) {
                        goto label_0;
                    }
                    *((ebp - 0x30)) = edi;
                }
            } else {
                *((ebp - 0x2c)) = edi;
            }
        }
        eax = skip_param (ebx);
        *((ebp + 8)) = eax;
    } while (1);
label_0:
    eax = ebp - 0x20;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range_eol (eax, eax, eax);
    edx = eax;
    eax = 0;
    if (edx == 0) {
        goto label_1;
    }
    al = (*((ebp - 0x2c)) == 0) ? 1 : 0;
    eax = (int32_t) al;
    *(obj.partial_flag) = eax;
    if (*((ebp - 0x30)) == 0) {
        eax = *((ebp - 0x1c));
        ebx = n_lhs;
        edi = lhs;
        if (*((ebp - 0x20)) >= eax) {
            goto label_2;
        }
        goto label_3;
    }
    eax = *((ebp - 0x1c));
    if (eax > *((ebp - 0x20))) {
        goto label_3;
    }
    edi = n_lhs;
    ebx = lhs;
    do {
        if (*((edi + eax*4)) != 0) {
            if (esi != 0) {
                edx = eax*4 + obj_n_lhs;
                eax = *((ebx + eax*4));
                uf_power (eax, edx);
            } else {
                edx = eax*4 + obj_n_lhs;
                eax = *((ebx + eax*4));
                uf_allpower (eax, edx);
            }
            eax = *((ebp - 0x1c));
            edx = eax*4 + obj_n_lhs;
            eax = *((ebx + eax*4));
            elim_loop (eax, edx);
            eax = *((ebp - 0x1c));
            if (*((eax*4 + obj.n_rhs)) != 0) {
                if (esi != 0) {
                    edx = eax*4 + obj_n_rhs;
                    eax = *((eax*4 + obj.rhs));
                    uf_power (eax, edx);
                } else {
                    edx = eax*4 + obj_n_rhs;
                    eax = *((eax*4 + obj.rhs));
                    uf_allpower (eax, edx);
                }
                eax = *((ebp - 0x1c));
                edx = eax*4 + obj_n_rhs;
                eax = *((eax*4 + obj.rhs));
                elim_loop (eax, edx);
            }
            eax = *((ebp - 0x1c));
            eax = return_result (eax);
            if (eax != 0) {
                goto label_4;
            }
            *(obj.partial_flag) = 1;
            goto label_1;
        }
label_4:
        eax = *((ebp - 0x1c));
        eax++;
        *((ebp - 0x1c)) = eax;
    } while (*((ebp - 0x20)) >= eax);
    goto label_3;
    do {
label_2:
        if (*((ebx + eax*4)) != 0) {
            if (esi != 0) {
                edx = eax*4 + obj_n_lhs;
                eax = *((edi + eax*4));
                uf_tsimp (eax, edx);
                eax = *((ebp - 0x1c));
                if (*((eax*4 + obj.n_rhs)) == 0) {
                    goto label_5;
                }
                edx = eax*4 + obj_n_rhs;
                eax = *((eax*4 + obj.rhs));
                uf_tsimp (eax, edx);
            } else {
                edx = eax*4 + obj_n_lhs;
                *((esp + 4)) = edx;
                eax = *((edi + eax*4));
                *(esp) = eax;
                uf_simp ();
                eax = *((ebp - 0x1c));
                if (*((eax*4 + obj.n_rhs)) == 0) {
                    goto label_5;
                }
                edx = eax*4 + obj_n_rhs;
                *((esp + 4)) = edx;
                eax = *((eax*4 + obj.rhs));
                *(esp) = eax;
                uf_simp ();
            }
label_5:
            eax = *((ebp - 0x1c));
            eax = return_result (eax);
            if (eax != 0) {
                goto label_6;
            }
            *(obj.partial_flag) = 1;
            goto label_1;
        }
label_6:
        eax = *((ebp - 0x1c));
        eax++;
        *((ebp - 0x1c)) = eax;
    } while (*((ebp - 0x20)) >= eax);
label_3:
    *(obj.partial_flag) = 1;
    eax = 1;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806956a */
#include <stdint.h>
 
int32_t dbg_taylor_cmd (int32_t arg_8h, int * nps, token_type * ep, int32_t i1, token_type * source, long int l1) {
    int * np;
    long int order;
    int32_t simplify_flag;
    int32_t var_1058h;
    int32_t i;
    int32_t var_1050h;
    int32_t our;
    char * cp_start;
    token_type * dest;
    int32_t var_1040h;
    char * cp;
    int32_t n1;
    int32_t our_nrhs;
    int32_t our_nlhs;
    char * cp1;
    long int v;
    char[4096] buf;
    int32_t var_1ch;
    char * s2;
    size_t * n;
    int32_t var_ch;
    int32_t var_10h;
    ebx = nps;
    ecx = ep;
    esi = i1;
    edi = source;
    eax = l1;
    /* int taylor_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x103c)) = eax;
    edx = *(gs:0x14);
    *((ebp - 0x1c)) = edx;
    edx = 0;
    *((ebp - 0x1020)) = 0;
    *((ebp - 0x1048)) = eax;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_2;
    }
    *((esp + 4)) = "nosimplify";
    eax = *((ebp - 0x103c));
    eax = strcmp_tospace (eax);
    *((ebp - 0x105c)) = 1;
    if (eax == 0) {
        eax = *((ebp - 0x103c));
        eax = skip_param (eax);
        *((ebp - 0x103c)) = eax;
        *((ebp - 0x105c)) = 0;
    }
    eax = next_espace ();
    *((ebp - 0x1054)) = eax;
    edx = cur_equation;
    ebx = n_lhs;
    eax = *((ebx + edx*4));
    eax <<= 4;
    eax = lhs;
    edx = *((eax + edx*4));
    ecx = *((ebp - 0x1054));
    eax = *((eax + ecx*4));
    memmove (eax, edx, eax);
    eax = cur_equation;
    eax = *((ebx + eax*4));
    edx = *((ebp - 0x1054));
    *((ebx + edx*4)) = eax;
    *((edx*4 + obj.n_rhs)) = 0;
    eax = alloc_next_espace ();
    *((ebp - 0x104c)) = eax;
    ecx = *((ebp - 0x1054));
    *((ebx + ecx*4)) = 0;
    if (eax < 0) {
        *(esp) = "Out of free equation spaces.";
        error ();
        eax = 0;
        goto label_3;
    }
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        edx = rhs;
        edi = *((edx + eax*4));
        ebx = eax*4 + obj_n_rhs;
        eax = *((ebp - 0x1054));
        edx = *((edx + eax*4));
        *((ebp - 0x1044)) = edx;
        edx = eax*4 + obj_n_rhs;
        *((ebp - 0x1064)) = edx;
    } else {
        edx = lhs;
        edi = *((edx + eax*4));
        ebx = eax*4 + obj_n_lhs;
        ecx = *((ebp - 0x1054));
        edx = *((edx + ecx*4));
        *((ebp - 0x1044)) = edx;
        eax = ecx*4 + obj_n_lhs;
        *((ebp - 0x1064)) = eax;
    }
    eax = *((ebp - 0x103c));
    eax = *(eax);
    if (al != 0) {
        eax = (int32_t) al;
        eax = isvarchar (eax);
        if (eax != 0) {
            eax = *((ebp - 0x103c));
            eax = ebp - 0x1020;
            eax = parse_var2 (eax, eax);
            *((ebp - 0x103c)) = eax;
            if (eax == 0) {
                goto label_2;
            }
        }
        eax = *((ebp - 0x103c));
        if (*(eax) != 0) {
            edx = ebp - 0x1024;
            eax = decstrtol (eax, edx);
            *((ebp - 0x1060)) = eax;
            eax = *((ebp - 0x103c));
            eax = skip_param (eax);
            if (eax == *((ebp - 0x1024))) {
                if (*((ebp - 0x1060)) >= 0) {
                    goto label_4;
                }
            }
            *(esp) = "Positive integer required for order.";
            error ();
            eax = 0;
            goto label_3;
label_4:
            *((ebp - 0x103c)) = eax;
        }
    } else {
        *((ebp - 0x1060)) = 0xffffffff;
    }
    eax = ebp - 0x1020;
    *((esp + 8)) = eax;
    eax = *(ebx);
    no_vars (edi, eax);
    if (*((ebp - 0x1020)) == 0) {
        eax = ebp - 0x1020;
        eax = prompt_var (eax);
        if (eax == 0) {
            goto label_2;
        }
    }
    eax = *((ebp - 0x1020));
    eax = *(ebx);
    eax = found_var (edi, eax, eax);
    if (eax == 0) {
        warning ("Variable not found.");
    }
    eax = *(ebx);
    eax <<= 4;
    esi = rhs;
    edx = *((ebp - 0x104c));
    eax = *((esi + edx*4));
    memmove (eax, edi, eax);
    eax = *(ebx);
    *((ebp - 0x102c)) = eax;
    ecx = ebp - 0x102c;
    *((esp + 4)) = ecx;
    edx = *((ebp - 0x104c));
    eax = *((esi + edx*4));
    *(esp) = eax;
    uf_simp ();
    eax = *((ebp - 0x1020));
    *((esp + 8)) = eax;
    ecx = ebp - 0x102c;
    edx = *((ebp - 0x104c));
    eax = *((esi + edx*4));
    eax = differentiate (eax, ecx);
    if (eax == 0) {
        *(esp) = "Differentiation failed.";
        error ();
        eax = 0;
        goto label_3;
    }
    eax = *((ebp - 0x103c));
    if (*(eax) != 0) {
        eax += *(obj.input_column);
        eax -= *((ebp - 0x1048));
        *(obj.input_column) = eax;
        eax = *((ebp - 0x103c));
        *((esp + 8)) = eax;
        eax = ebp - 0x1028;
        ecx = *((ebp - 0x104c));
        eax = *((ecx*4 + obj.lhs));
        eax = parse_expr (eax, eax);
        *((ebp - 0x103c)) = eax;
        if (eax == 0) {
            goto label_2;
        }
        if (*((ebp - 0x1028)) > 0) {
            goto label_5;
        }
        goto label_2;
    }
    eax = *((ebp - 0x1020));
    list_var (eax, 0);
    *((esp + 8)) = 0x8079800;
    *((esp + 4)) = "Taylor series expansion around %s = point.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 8)) = 0x50;
    my_strlcpy (obj.prompt_str, "Enter point: ");
    eax = ebp - 0x1028;
    edx = *((ebp - 0x104c));
    eax = *((edx*4 + obj.lhs));
    eax = get_expr (eax, eax);
    if (eax == 0) {
        goto label_2;
    }
label_5:
    if (*((ebp - 0x1060)) < 0) {
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter order (number of derivatives to take): ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x1024)) = eax;
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) != 0) {
            edx = ebp - 0x103c;
            eax = decstrtol (eax, edx);
            *((ebp - 0x1060)) = eax;
            eax = *((ebp - 0x103c));
            if (*(eax) == 0) {
                if (*((ebp - 0x1060)) >= 0) {
                    goto label_6;
                }
            }
            *(esp) = "Positive integer required for order.";
            error ();
            eax = 0;
            goto label_3;
        }
        *((esp + 4)) = "Derivatives will be taken until they reach zero...\n";
        *(esp) = 1;
        printf_chk ();
        *((ebp - 0x1060)) = 0x7ffffffe;
    }
label_6:
    *((esp + 4)) = "Computing the Taylor series";
    *(esp) = 1;
    printf_chk ();
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        *((esp + 4)) = " of the RHS";
        *(esp) = 1;
        printf_chk ();
    }
    if (*((ebp - 0x105c)) != 0) {
        *((esp + 4)) = " and simplifying";
        *(esp) = 1;
        printf_chk ();
    }
    *((esp + 4)) = 0x8075a4c;
    *(esp) = 1;
    printf_chk ();
    eax = *(ebx);
    eax <<= 4;
    ecx = *((ebp - 0x1044));
    memmove (ecx, edi, eax);
    eax = *(ebx);
    *((ebp - 0x1030)) = eax;
    *((ebp - 0x1048)) = 0;
    esi = 0;
label_1:
    eax = *((ebp - 0x1030));
    if (esi >= eax) {
        goto label_7;
    }
    ebx = esi;
    *((ebp - 0x1050)) = esi;
label_0:
    edi = ebx;
    esi = ebx;
    esi <<= 4;
    esi += *((ebp - 0x1044));
    if (*(esi) != 1) {
        goto label_8;
    }
    edx = *((esi + 8));
    if (edx != *((ebp - 0x1020))) {
        goto label_8;
    }
    edx = *((esi + 4));
    *((ebp - 0x1058)) = edx;
    edx = *((ebp - 0x1028));
    eax = eax + edx - 1;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = ebx;
    eax = ~eax;
    eax += *((ebp - 0x1030));
    eax <<= 4;
    edi <<= 4;
    ecx = *((ebp - 0x1044));
    eax = edi + ecx + 0x10;
    eax = ebx;
    eax += *((ebp - 0x1028));
    eax <<= 4;
    eax += ecx;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x1028));
    eax = *((ebp - 0x1028));
    eax += *((ebp - 0x1030));
    eax--;
    *((ebp - 0x1030)) = eax;
    edx <<= 4;
    edx = *((ebp - 0x104c));
    ecx = lhs;
    eax = *((ecx + edx*4));
    memmove (esi, eax, edx);
    eax = ebx;
    eax += *((ebp - 0x1028));
    if (ebx >= eax) {
        goto label_9;
    }
    esi += 4;
    edx = *((ebp - 0x1058));
    do {
        *(esi) += edx;
        ebx++;
        esi += 0x10;
    } while (eax > ebx);
label_9:
    ebx = eax - 1;
label_8:
    ebx += 2;
    eax = *((ebp - 0x1030));
    if (eax > ebx) {
        goto label_0;
    }
    esi = *((ebp - 0x1050));
label_7:
    edx = *((ebp - 0x1028));
    eax = eax + edx + 7;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp - 0x1030));
    if (esi >= ecx) {
        goto label_10;
    }
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x1044));
    eax = edx + eax + 4;
    edx = esi;
    do {
        *(eax)++;
        edx++;
        ecx = *((ebp - 0x1030));
        eax += 0x10;
    } while (ecx > edx);
label_10:
    ecx <<= 4;
    ecx += *((ebp - 0x1044));
    *((ecx + 4)) = 1;
    *(ecx) = 2;
    *((ecx + 8)) = 3;
    eax = ecx + 0x10;
    *((eax + 4)) = 3;
    *(eax) = 1;
    edx = *((ebp - 0x1020));
    *((eax + 8)) = edx;
    ecx += 0x20;
    *((ecx + 4)) = 3;
    *(ecx) = 2;
    *((ecx + 8)) = 2;
    ebx = *((ebp - 0x1030));
    ebx += 3;
    *((ebp - 0x1030)) = ebx;
    eax = *((ebp - 0x1028));
    eax <<= 4;
    ecx = *((ebp - 0x104c));
    edx = lhs;
    eax = *((edx + ecx*4));
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x1044));
    memmove (eax, eax, eax);
    edx = *((ebp - 0x1030));
    edx += *((ebp - 0x1028));
    *((ebp - 0x1030)) = edx;
    if (ebx >= edx) {
        goto label_11;
    }
    eax = ebx;
    eax <<= 4;
    ecx = *((ebp - 0x1044));
    eax = ecx + eax + 4;
    do {
        *(eax) += 3;
        ebx++;
        edx = *((ebp - 0x1030));
        eax += 0x10;
    } while (edx > ebx);
label_11:
    edx <<= 4;
    edx += *((ebp - 0x1044));
    *((edx + 4)) = 2;
    *(edx) = 2;
    *((edx + 8)) = 6;
    eax = edx + 0x10;
    *((eax + 4)) = 2;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x1048));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = edx + 0x20;
    *((eax + 4)) = 1;
    *(eax) = 2;
    *((eax + 8)) = 4;
    edx += 0x30;
    if (*((ebp - 0x1048)) <= 1) {
        *(fp_stack--) = 1.0;
        goto label_12;
    }
    eax = 2;
    *(fp_stack--) = 1.0;
    ecx = *((ebp - 0x1048));
    do {
        *((ebp - 0x1040)) = eax;
        *(fp_stack--) = *((ebp - 0x1040));
        fp_stack[0] *= fp_stack[1];
        fp_stack++;
        eax++;
    } while (ecx >= eax);
label_12:
    *((edx + 4)) = 1;
    *(edx) = 0;
    *((edx + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x1030));
    eax += 4;
    *((ebp - 0x1030)) = eax;
    if (esi >= eax) {
        goto label_13;
    }
    eax = esi;
    eax <<= 4;
    edx = *((ebp - 0x1044));
    eax = edx + eax + 4;
    do {
        *(eax)++;
        esi++;
        eax += 0x10;
    } while (*((ebp - 0x1030)) > esi);
label_13:
    if (*((ebp - 0x105c)) != 0) {
        ecx = ebp - 0x1030;
        *((esp + 4)) = ecx;
        eax = *((ebp - 0x1044));
        *(esp) = eax;
        uf_simp ();
    }
    *((esp + 0x10)) = 0;
    eax = *((ebp - 0x1030));
    edx = *((ebp - 0x1044));
    list_debug (0, edx, eax);
    eax = *((ebp - 0x1030));
    *((esp + 4)) = eax;
    ecx = *((ebp - 0x1044));
    eax = exp_contains_infinity (ecx);
    if (eax != 0) {
        *(esp) = "Result invalid because it contains infinity or NaN.";
        error ();
        eax = 0;
        goto label_3;
    }
    eax = *((ebp - 0x1060));
    if (*((ebp - 0x1048)) >= eax) {
        goto label_14;
    }
    if (*((ebp - 0x1048)) > 0) {
        eax = *((ebp - 0x1020));
        *((esp + 8)) = eax;
        edx = ebp - 0x102c;
        ecx = *((ebp - 0x104c));
        eax = *((ecx*4 + obj.rhs));
        eax = differentiate (eax, edx);
        if (eax != 0) {
            goto label_15;
        }
        *(esp) = "Differentiation failed.";
        error ();
        eax = 0;
        goto label_3;
    }
label_15:
    eax = symblify;
    *(obj.symb_flag) = eax;
    *((esp + 0xc)) = 1;
    *((esp + 8)) = 1;
    eax = ebp - 0x102c;
    edx = *((ebp - 0x104c));
    eax = *((edx*4 + obj.rhs));
    simpa_side (eax, eax);
    *(obj.symb_flag) = 0;
    eax = *((ebp - 0x102c));
    if (eax == 1) {
        ecx = *((ebp - 0x104c));
        edx = *((ecx*4 + obj.rhs));
        if (*(edx) != 0) {
            goto label_16;
        }
        *(fp_stack--) = *((edx + 8));
        *(fp_stack--) = 0.0;
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            goto label_16;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_14;
        }
    }
label_16:
    ebx = *((ebp - 0x1030));
    esi = ebx + 1;
    eax = esi + eax;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (ebx <= 0) {
        goto label_17;
    }
    eax = *((ebp - 0x1044));
    edx = 0;
    do {
        *((eax + 4))++;
        edx++;
        eax += 0x10;
    } while (edx != ebx);
label_17:
    ebx <<= 4;
    ebx += *((ebp - 0x1044));
    *((ebx + 4)) = 1;
    *(ebx) = 2;
    *((ebx + 8)) = 1;
    eax = *((ebp - 0x102c));
    eax <<= 4;
    edx = *((ebp - 0x104c));
    eax = *((edx*4 + obj.rhs));
    eax = esi;
    eax <<= 4;
    eax += *((ebp - 0x1044));
    memmove (eax, eax, eax);
    eax = esi;
    eax += *((ebp - 0x102c));
    *((ebp - 0x1030)) = eax;
    *((ebp - 0x1048))++;
    goto label_1;
label_14:
    eax = 0x8075e75;
    edx = 0x80757fe;
    if (*((ebp - 0x1048)) == 1) {
        eax = edx;
    }
    *((esp + 0xc)) = eax;
    ecx = *((ebp - 0x1048));
    *((esp + 8)) = ecx;
    *((esp + 4)) = "%ld derivative%s applied.\n";
    *(esp) = 1;
    printf_chk ();
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        edx = n_lhs;
        eax = *((edx + eax*4));
        ecx = *((ebp - 0x1054));
        *((edx + ecx*4)) = eax;
    }
    eax = *((ebp - 0x1030));
    edx = *((ebp - 0x1064));
    *(edx) = eax;
    ecx = *((ebp - 0x1054));
    *(obj.cur_equation) = ecx;
    return_result (ecx);
    goto label_3;
label_2:
    eax = 0;
label_3:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*((eax*4 + obj.n_rhs)) != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d5d8 */
#include <stdint.h>
 
uint32_t dbg_simple_frac_side (int32_t arg_8h, int32_t arg_ch, int * np, token_type * equation) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = np;
    esi = equation;
    /* void simple_frac_side(token_type * equation,int * np); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    if (*(ebx) <= 0) {
        goto label_1;
    }
    do {
label_0:
        *(fp_stack--) = 1.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        simp_ssub (5, ebx, 0);
        *((esp + 4)) = ebx;
        *(esp) = esi;
        eax = poly_gcd_simp ();
    } while (eax != 0);
    eax = uf_power (esi, ebx);
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 8)) = 2;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = super_factor ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 0x10)) = 0;
    eax = *(ebx);
    list_debug (0, esi, eax);
    *((esp + 4)) = ebx;
    make_fractions (esi);
    uf_tsimp (esi, ebx);
    *((esp + 8)) = 1;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    poly_factor ();
    *((esp + 0x10)) = 2;
    *((esp + 0xc)) = 0;
    simpb_side (esi, ebx, 1);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    fractions_and_group ();
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8067912 */
#include <stdint.h>
 
int32_t dbg_poly_gcd_simp (void) {
    token_type * equation;
    int * np;
    /* int poly_gcd_simp(token_type * equation,int * np); */
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    polydiv_recurse (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062df5 */
#include <stdint.h>
 
uint32_t dbg_uf_power (void * arg_8h, size_t * arg_ch, int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    size_t * var_sp_4h;
    int32_t var_sp_8h;
    eax = rv;
    /* int uf_power(token_type * equation,int * np); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    *((esp + 4)) = esi;
    organize (edi);
    *((esp + 8)) = 2;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = sub_ufactor ();
    ebx = eax;
    if (eax != 0) {
        *((esp + 4)) = esi;
        organize (edi);
    }
    eax = ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80620ae */
#include <stdint.h>
 
int32_t dbg_sub_ufactor (int32_t e1, int32_t i, int32_t j, int32_t len, int32_t be1) {
    int32_t var_70h;
    int32_t var_6ch;
    int32_t var_68h;
    void * var_64h;
    int32_t var_60h;
    uint32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    int32_t modified;
    int32_t var_4ch;
    uint32_t var_48h;
    void * var_44h;
    int32_t k;
    int32_t var_3ch;
    void * var_38h;
    double d1;
    int32_t var_28h;
    void * var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    token_type * equation;
    int * np;
    int32_t ii;
    void * s2;
    size_t n;
    ecx = e1;
    edx = i;
    esi = j;
    edi = len;
    eax = be1;
    /* int sub_ufactor(token_type * equation,int * np,int ii); */
    eax = *((ebp + 0xc));
    ecx = *(eax);
    ebx = 1;
    *((ebp - 0x50)) = 0;
    if (ecx <= 1) {
        goto label_13;
    }
    edx = *((ebp + 0x10));
    edx &= 1;
    *((ebp - 0x5c)) = edx;
label_11:
    *((ebp - 0x38)) = ebx;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x24)) = eax;
    edi = *((eax + 8));
    if (edi < 3) {
        goto label_12;
    }
    if (edi > 4) {
        if (edi != 6) {
            goto label_12;
        }
    } else {
        if (*((ebp + 0x10)) != 1) {
            goto label_12;
        }
        goto label_14;
    }
    if (*((ebp - 0x5c)) != 0) {
        goto label_12;
    }
label_14:
    eax = *((ebp - 0x24));
    esi = *((eax + 4));
    edx = ebx;
    edx -= 2;
    *((ebp - 0x4c)) = edx;
    if (edx < 0) {
        goto label_15;
    }
    eax = edx;
    eax <<= 4;
    edx = *((ebp + 8));
    if (esi > *((eax + edx + 4))) {
        goto label_15;
    }
    eax = ebx;
    eax <<= 4;
    eax = edx + eax - 0x3c;
    edx = *((ebp - 0x4c));
    *((ebp - 0x3c)) = ebx;
    while (edx >= 0) {
        ebx = *(eax);
        eax -= 0x20;
        if (esi > ebx) {
            goto label_16;
        }
        edx -= 2;
    }
    *((ebp - 0x4c)) = edx;
    ebx = *((ebp - 0x3c));
    goto label_15;
label_16:
    *((ebp - 0x4c)) = edx;
    ebx = *((ebp - 0x3c));
label_15:
    eax = *((ebp - 0x4c));
    eax++;
    *((ebp - 0x58)) = eax;
    edx = ebx + 2;
    *((ebp - 0x30)) = edx;
    if (edx >= ecx) {
        goto label_17;
    }
    eax = edx;
    eax <<= 4;
    edx = *((ebp + 8));
    if (esi > *((eax + edx + 4))) {
        goto label_17;
    }
    eax = ebx;
    eax <<= 4;
    eax = edx + eax + 0x44;
    edx = *((ebp - 0x30));
    *((ebp - 0x3c)) = edx;
    *((ebp - 0x28)) = ebx;
    while (edx < ecx) {
        ebx = *(eax);
        eax += 0x20;
        if (esi > ebx) {
            goto label_18;
        }
        edx += 2;
    }
    *((ebp - 0x3c)) = edx;
    ebx = *((ebp - 0x28));
    goto label_19;
label_17:
    ecx = *((ebp - 0x30));
    *((ebp - 0x3c)) = ecx;
    goto label_19;
label_18:
    *((ebp - 0x3c)) = edx;
    ebx = *((ebp - 0x28));
label_19:
    if (edi < 3) {
        goto label_12;
    }
    if (edi > 4) {
        if (edi != 6) {
            goto label_12;
        }
        goto label_20;
    }
    if (*((ebp + 0x10)) != 1) {
        goto label_12;
    }
    edi = *((ebp - 0x58));
    edi++;
    *((ebp - 0x24)) = edi;
    eax = *((ebp - 0x3c));
    if (edi >= eax) {
        goto label_12;
    }
    edi = esi + 1;
    ecx = *((ebp - 0x24));
    *((ebp - 0x30)) = ebx;
    *((ebp - 0x24)) = edi;
label_2:
    eax = ecx;
    eax <<= 4;
    eax += *((ebp + 8));
    ebx = *((eax + 4));
    if (ebx != *((ebp - 0x24))) {
        goto label_21;
    }
    eax = *((eax + 8));
    eax--;
    if (eax > 1) {
        goto label_21;
    }
    eax = ecx - 2;
    if (*((ebp - 0x58)) > eax) {
        goto label_22;
    }
    edx = eax;
    edx <<= 4;
    edi = *((ebp + 8));
    if (esi >= *((edx + edi + 4))) {
        goto label_22;
    }
    edx = ecx;
    edx <<= 4;
    edx = edi + edx - 0x3c;
    *((ebp - 0x28)) = ebx;
    edi = *((ebp - 0x58));
    while (edi <= eax) {
        ebx = *(edx);
        edx -= 0x20;
        if (esi >= ebx) {
            goto label_23;
        }
        eax -= 2;
    }
    ebx = *((ebp - 0x28));
    goto label_22;
label_23:
    ebx = *((ebp - 0x28));
label_22:
    eax++;
    *((ebp - 0x38)) = eax;
    eax = ecx + 2;
    if (eax >= *((ebp - 0x3c))) {
        goto label_24;
    }
    edx = eax;
    edx <<= 4;
    edi = *((ebp + 8));
    if (esi >= *((edx + edi + 4))) {
        goto label_24;
    }
    edx = ecx;
    edx <<= 4;
    edx = edi + edx + 0x44;
    *((ebp - 0x28)) = ebx;
    edi = *((ebp - 0x3c));
    while (eax < edi) {
        ebx = *(edx);
        edx += 0x20;
        if (esi >= ebx) {
            goto label_25;
        }
        eax += 2;
    }
    ebx = *((ebp - 0x28));
    goto label_24;
label_25:
    ebx = *((ebp - 0x28));
label_24:
    edx = *((ebp - 0x38));
    while (*((edx + edi + 8)) != 4) {
        *((ebp - 0x54)) = ebx;
        *((ebp - 0x24)) = ecx;
        *((ebp - 0x44)) = eax;
        ecx = *((ebp - 0x38));
        ecx -= *((ebp - 0x58));
        *((ebp - 0x50)) = ecx;
        ebx = *((ebp - 0x3c));
        ebx -= eax;
        *((ebp - 0x60)) = ebx;
        ecx <<= 4;
        *((ebp - 0x68)) = ecx;
        eax = *((ebp - 0x58));
        eax <<= 4;
        eax += *((ebp + 8));
        *((ebp - 0x64)) = eax;
        ebx <<= 4;
        *((ebp - 0x6c)) = ebx;
        eax = *((ebp - 0x44));
        eax <<= 4;
        eax += *((ebp + 8));
        *((ebp - 0x70)) = eax;
        esi = 0;
        goto label_26;
        edx = *((ebp - 0x38));
        edx--;
        edx <<= 4;
        edi = *((ebp + 8));
    }
    ecx = eax - 2;
    goto label_21;
label_0:
    edx = *((ebp - 0x24));
    edx++;
    *((ebp - 0x38)) = edx;
    esi = *((ebp - 0x48));
    *((ebp - 0x24)) = eax;
label_26:
    ecx = *((ebp - 0x50));
    ecx += esi;
    *((ebp - 0x30)) = ecx;
    ebx = *((ebp - 0x24));
    ebx -= *((ebp - 0x38));
    *((ebp - 0x40)) = ebx;
    edi = ebx;
    edi += ecx;
    eax = *((ebp - 0x60));
    eax += edi;
    *((ebp - 0x28)) = eax;
    eax++;
    *((ebp - 0x48)) = eax;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ebx = esi;
    ebx <<= 4;
    edx = *((ebp - 0x68));
    ecx = *((ebp - 0x64));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, ecx, edx);
    if (esi >= *((ebp - 0x30))) {
        goto label_27;
    }
    edx = *((ebp - 0x30));
    do {
        eax = ebx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        esi++;
        ebx += 0x10;
    } while (edx > esi);
label_27:
    eax = *((ebp - 0x40));
    eax <<= 4;
    eax = *((ebp - 0x38));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ebx = edi;
    ebx <<= 4;
    esi = *((ebp - 0x6c));
    eax = *((ebp - 0x70));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, eax, esi);
    if (edi >= *((ebp - 0x28))) {
        goto label_28;
    }
    edx = *((ebp - 0x28));
    do {
        eax = ebx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        edi++;
        ebx += 0x10;
    } while (edx > edi);
label_28:
    edx = *((ebp - 0x44));
    if (*((ebp - 0x24)) >= edx) {
        goto label_29;
    }
    eax = *((ebp - 0x28));
    eax <<= 4;
    edx = scratch;
    ecx = *((ebp - 0x24));
    ecx <<= 4;
    esi = *((ebp + 8));
    ebx = *((ecx + esi));
    *((edx + eax)) = ebx;
    ebx = *((ecx + esi + 4));
    *((edx + eax + 4)) = ebx;
    ebx = *((ecx + esi + 8));
    *((edx + eax + 8)) = ebx;
    ecx = *((ecx + esi + 0xc));
    *((edx + eax + 0xc)) = ecx;
    eax += *(obj.scratch);
    *((eax + 4))--;
    eax = *((ebp - 0x24));
    eax += 2;
    if (eax >= *((ebp - 0x44))) {
        goto label_0;
    }
    edx = eax;
    edx <<= 4;
    edi = *((ebp - 0x54));
    if (edi == *((edx + esi + 4))) {
        goto label_0;
    }
    edx = *((ebp - 0x24));
    edx <<= 4;
    edx = esi + edx + 0x44;
    esi = edi;
    ebx = *((ebp - 0x44));
    goto label_30;
label_1:
    ecx = *(edx);
    edx += 0x20;
    if (esi == ecx) {
        goto label_0;
    }
label_30:
    eax += 2;
    if (eax < ebx) {
        goto label_1;
    }
    goto label_0;
label_29:
    ebx = *((ebp - 0x58));
    ebx -= *((ebp - 0x3c));
    eax = ebx;
    edx = *((ebp + 0xc));
    eax += *(edx);
    eax += *((ebp - 0x28));
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    eax -= *((ebp - 0x3c));
    eax <<= 4;
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = *((ebp - 0x28));
    eax += *((ebp - 0x58));
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, eax);
    esi = *((ebp - 0x28));
    eax = esi + ebx;
    edi = *((ebp + 0xc));
    *(edi) += eax;
    eax = esi;
    eax <<= 4;
    eax = scratch;
    eax = *((ebp - 0x64));
    eax = memmove (eax, eax, eax);
    goto label_31;
label_21:
    ecx += 2;
    if (ecx < *((ebp - 0x3c))) {
        goto label_2;
    }
    ebx = *((ebp - 0x30));
    goto label_12;
label_20:
    cl = (*((ebp + 0x10)) == 0) ? 1 : 0;
    if (*((ebp + 0x10)) != 2) {
        if (cl == 0) {
            goto label_32;
        }
    }
    edx = *((ebp - 0x58));
    edx++;
    *((ebp - 0x28)) = edx;
    if (edx < ebx) {
        goto label_33;
    }
    goto label_32;
    do {
        edx = eax;
        edi = *((eax + 4));
        eax += 0x20;
        if (edi == *((ebp - 0x48))) {
            goto label_5;
        }
label_6:
        *((ebp - 0x28)) += 2;
    } while (*((ebp - 0x28)) < ebx);
    goto label_32;
label_5:
    eax = *((edx + 8));
    eax -= 3;
    if (eax > 1) {
        goto label_32;
    }
    ecx = *((ebp - 0x3c));
    ecx -= ebx;
    *((ebp - 0x54)) = ecx;
    ecx <<= 4;
    *((ebp - 0x50)) = ecx;
    esi = *((ebp - 0x58));
    *((ebp - 0x30)) = esi;
    esi = 0;
    *((ebp - 0x38)) = esi;
    *((ebp - 0x44)) = ebx;
    goto label_34;
label_3:
    edi = *((ebp - 0x28));
    edi++;
    *((ebp - 0x30)) = edi;
    edx = *((ebp - 0x40));
    *((ebp - 0x38)) = edx;
    *((ebp - 0x28)) = eax;
label_34:
    ebx = *((ebp - 0x28));
    ebx -= *((ebp - 0x30));
    esi = *((ebp - 0x38));
    esi = ebx + esi;
    edi = *((ebp - 0x54));
    edi = esi + edi;
    ecx = edi + 1;
    *((ebp - 0x40)) = ecx;
    if (ecx > *(obj.n_tokens)) {
        error_huge ();
    }
    ebx <<= 4;
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = *((ebp - 0x38));
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, ebx);
    ebx = esi;
    ebx <<= 4;
    eax = *((ebp - 0x50));
    edx = *((ebp - 0x24));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, edx, eax);
    if (esi >= edi) {
        goto label_35;
    }
    do {
        eax = ebx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        esi++;
        ebx += 0x10;
    } while (edi > esi);
label_35:
    ecx = *((ebp - 0x44));
    if (*((ebp - 0x28)) >= ecx) {
        goto label_36;
    }
    edi <<= 4;
    eax = scratch;
    edx = *((ebp - 0x28));
    edx <<= 4;
    ebx = *((ebp + 8));
    ecx = *((edx + ebx));
    *((eax + edi)) = ecx;
    ecx = *((edx + ebx + 4));
    *((eax + edi + 4)) = ecx;
    ecx = *((edx + ebx + 8));
    *((eax + edi + 8)) = ecx;
    edx = *((edx + ebx + 0xc));
    *((eax + edi + 0xc)) = edx;
    edi += *(obj.scratch);
    *((edi + 4))--;
    eax = *((ebp - 0x28));
    eax += 2;
    if (eax >= *((ebp - 0x44))) {
        goto label_3;
    }
    edx = eax;
    edx <<= 4;
    esi = *((ebp - 0x48));
    if (*((edx + ebx + 4)) == esi) {
        goto label_3;
    }
    edx = *((ebp - 0x28));
    edx <<= 4;
    edx = ebx + edx + 0x44;
    ebx = *((ebp - 0x44));
    goto label_37;
label_4:
    ecx = *(edx);
    edx += 0x20;
    if (ecx == esi) {
        goto label_3;
    }
label_37:
    eax += 2;
    if (eax < ebx) {
        goto label_4;
    }
    goto label_3;
label_36:
    ebx = *((ebp - 0x58));
    ebx -= *((ebp - 0x3c));
    eax = ebx;
    edx = *((ebp + 0xc));
    eax += *(edx);
    eax += edi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    eax -= *((ebp - 0x3c));
    eax <<= 4;
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = *((ebp - 0x58));
    eax = edi + eax;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, eax);
    eax = ebx;
    esi = *((ebp + 0xc));
    eax += *(esi);
    eax += edi;
    *(esi) = eax;
    eax = edi;
    eax <<= 4;
    eax = scratch;
    eax = *((ebp - 0x58));
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, eax);
    goto label_31;
label_33:
    edx = *((ebp - 0x28));
    edx <<= 4;
    edx += *((ebp + 8));
    edi = esi + 1;
    *((ebp - 0x48)) = edi;
    if (*((edx + 4)) == edi) {
        goto label_5;
    }
    eax = *((ebp - 0x4c));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x40;
    goto label_6;
label_32:
    if (cl == 0) {
        if (*((ebp + 0x10)) != 4) {
            goto label_38;
        }
    }
    ecx = *((ebp - 0x3c));
    if (*((ebp - 0x30)) < ecx) {
        goto label_39;
    }
    goto label_38;
    do {
        edx = eax;
        edi = *((eax + 4));
        eax += 0x20;
        if (*((ebp - 0x40)) == edi) {
            goto label_40;
        }
label_10:
        ecx += 2;
    } while (ecx < *((ebp - 0x3c)));
    goto label_38;
label_9:
    edi = *((ebp - 0x30));
    *((ebp - 0x28)) = edi;
    goto label_41;
label_40:
    *((ebp - 0x28)) = ecx;
label_41:
    eax = *((edx + 8));
    eax--;
    if (eax > 1) {
        goto label_38;
    }
    ebx++;
    *((ebp - 0x38)) = ebx;
    ebx -= *((ebp - 0x58));
    *((ebp - 0x48)) = ebx;
    ebx <<= 4;
    *((ebp - 0x54)) = ebx;
    eax = *((ebp - 0x58));
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x44)) = eax;
    edi = 0;
    eax = *((ebp - 0x30));
    eax -= *((ebp - 0x58));
    *((ebp - 0x30)) = eax;
    *((ebp - 0x50)) = esi;
    goto label_42;
label_7:
    edi++;
    edx = *((ebp - 0x28));
    edx++;
    *((ebp - 0x38)) = edx;
    *((ebp - 0x28)) = eax;
label_42:
    ecx = *((ebp - 0x28));
    ecx -= *((ebp - 0x38));
    *((ebp - 0x24)) = ecx;
    eax = *((ebp - 0x30));
    eax += edi;
    eax += ecx;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ebx = edi;
    ebx <<= 4;
    esi = *((ebp - 0x54));
    eax = *((ebp - 0x44));
    eax = ebx;
    eax += *(obj.scratch);
    memmove (eax, eax, esi);
    esi = *((ebp - 0x48));
    esi = edi + esi;
    if (edi >= esi) {
        goto label_43;
    }
    do {
        eax = ebx;
        eax += *(obj.scratch);
        *((eax + 4))++;
        edi++;
        ebx += 0x10;
    } while (esi > edi);
label_43:
    eax = *((ebp - 0x24));
    eax <<= 4;
    eax = *((ebp - 0x38));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = esi;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    edi = *((ebp - 0x24));
    edi = esi + edi;
    edx = *((ebp - 0x3c));
    if (*((ebp - 0x28)) >= edx) {
        goto label_44;
    }
    eax = edi;
    eax <<= 4;
    edx = scratch;
    ecx = *((ebp - 0x50));
    *((edx + eax + 4)) = ecx;
    edx = scratch;
    *((edx + eax)) = 2;
    edx = *((ebp - 0x28));
    edx <<= 4;
    ebx = *((ebp + 8));
    if (*((edx + ebx + 8)) == 1) {
        edx = scratch;
        *((edx + eax + 8)) = 3;
    } else {
        edx = scratch;
        *((edx + eax + 8)) = 4;
    }
    eax = *((ebp - 0x28));
    eax += 2;
    if (eax >= *((ebp - 0x3c))) {
        goto label_7;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x40));
    esi = *((ebp + 8));
    if (ecx == *((edx + esi + 4))) {
        goto label_7;
    }
    edx = *((ebp - 0x28));
    edx <<= 4;
    edx = esi + edx + 0x44;
    esi = ecx;
    ebx = *((ebp - 0x3c));
    goto label_45;
label_8:
    ecx = *(edx);
    edx += 0x20;
    if (esi == ecx) {
        goto label_7;
    }
label_45:
    eax += 2;
    if (eax < ebx) {
        goto label_8;
    }
    goto label_7;
label_44:
    ebx = *((ebp - 0x58));
    ebx -= *((ebp - 0x3c));
    eax = ebx;
    esi = *((ebp + 0xc));
    eax += *(esi);
    eax += edi;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= *((ebp - 0x3c));
    eax <<= 4;
    eax = *((ebp - 0x3c));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = *((ebp - 0x58));
    eax = edi + eax;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, eax);
    eax = ebx;
    ecx = *((ebp + 0xc));
    eax += *(ecx);
    eax += edi;
    *(ecx) = eax;
    edi <<= 4;
    eax = scratch;
    ebx = *((ebp - 0x44));
    memmove (ebx, eax, edi);
    goto label_31;
label_39:
    edx = *((ebp - 0x30));
    edx <<= 4;
    edx += *((ebp + 8));
    edi = esi + 1;
    *((ebp - 0x40)) = edi;
    if (*((edx + 4)) == edi) {
        goto label_9;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x40;
    ecx = *((ebp - 0x30));
    *((ebp - 0x28)) = ecx;
    goto label_10;
label_38:
    ebp - 0x28 = (*((ebp + 0x10)) != 8) ? 1 : 0;
    if (*((ebp + 0x10)) != 6) {
        if (*((ebp - 0x28)) != 0) {
            goto label_12;
        }
    }
    eax = *((ebp - 0x38));
    eax <<= 4;
    edx = *((ebp + 8));
    edi = eax + edx + 0x10;
    if (esi != *((edi + 4))) {
        goto label_12;
    }
    if (*(edi) != 0) {
        goto label_12;
    }
    *(fp_stack--) = *((edi + 8));
    *((ebp - 0x30)) = fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = finite ();
    if (eax == 0) {
        goto label_12;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x30));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_46;
    }
    if (*((ebp - 0x28)) == 0) {
        goto label_47;
    }
    *(fp_stack--) = *(0x8076e08);
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_12;
    }
    eax = ebx;
    eax -= *((ebp - 0x58));
    if (eax == 1) {
        eax = *((ebp - 0x58));
        eax <<= 4;
        edx = *((ebp + 8));
        if (*((eax + edx)) == 0) {
            goto label_48;
        }
        goto label_12;
    }
    if (eax <= 1) {
        goto label_48;
    }
    *(fp_stack--) = *(0x8072058);
    *(fp_stack--) = *((ebp - 0x30));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_48;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x30));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_49;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x30));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_49:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_12;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_12;
    }
    goto label_48;
label_47:
    fp_stack++;
label_48:
    *(fp_stack--) = *((ebp - 0x30));
    *(esp) = fp_stack[0];
    fp_stack--;
    ceil ();
    *(fp_stack--) = 1.0;
    fp_stack[1] -= fp_stack[0];
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    *((ebp - 0x38)) = fp_stack[0];
    fp_stack--;
    eax = ebx;
    eax -= *((ebp - 0x58));
    *((ebp - 0x30)) = eax;
    *(fp_stack--) = *((ebp - 0x30));
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    fp_stack[0] *= *((ebp - 0x38));
    ecx = *((ebp + 0xc));
    edx = *(ecx);
    *((ebp - 0x20)) = edx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] += fp_stack[1];
    eax = n_tokens;
    eax -= 0xa;
    *((ebp - 0x20)) = eax;
    *(fp_stack--) = *((ebp - 0x20));
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_50;
    }
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *(fp_stack--) = *((ebp - 0x38));
    *((ebp - 0x28)) = fp_stack[0];
    fp_stack--;
    *((ebp - 0x40)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x3c));
    *((ebp - 0x50)) = eax;
    ecx = eax;
    ecx <<= 4;
    *((ebp - 0x48)) = ecx;
    eax = *((ebp + 8));
    eax += ecx;
    *((ebp - 0x44)) = eax;
    eax = edx;
    eax -= *((ebp - 0x3c));
    eax <<= 4;
    edx = *((ebp - 0x44));
    eax = *((ebp - 0x40));
    eax += *((ebp - 0x3c));
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, edx, eax);
    eax = *((ebp - 0x40));
    ecx = *((ebp + 0xc));
    *(ecx) += eax;
    *(fp_stack--) = *((ebp - 0x38));
    *((edi + 8)) -= fp_stack[0];
    *((edi + 8)) = fp_stack[0];
    fp_stack--;
    if (*((ebp - 0x28)) <= 0) {
        goto label_51;
    }
    edx = *((ebp - 0x30));
    edx <<= 4;
    *((ebp - 0x54)) = edx;
    eax = *((ebp - 0x58));
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x40)) = eax;
    eax = *((ebp - 0x30));
    eax++;
    eax <<= 4;
    *((ebp - 0x38)) = eax;
    eax = *((ebp - 0x48));
    ecx = *((ebp + 8));
    ecx = eax + ecx + 4;
    *((ebp - 0x48)) = ecx;
    eax = *((ebp - 0x50));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    *((ebp - 0x30)) = eax;
    *((ebp - 0x50)) = edi;
    edi = ebx;
    ebx = *((ebp - 0x48));
    do {
        *(ebx) = esi;
        *((ebx - 4)) = 2;
        *((ebx + 4)) = 3;
        eax = *((ebp - 0x54));
        edx = *((ebp - 0x40));
        ecx = *((ebp - 0x30));
        memmove (ecx, edx, eax);
        ebx += *((ebp - 0x38));
        eax = *((ebp - 0x38));
        *((ebp - 0x30)) += eax;
        *((ebp - 0x28))--;
    } while (*((ebp - 0x28)) > 0);
    ebx = edi;
    edi = *((ebp - 0x50));
label_51:
    *(fp_stack--) = *((edi + 8));
    *(fp_stack--) = 1.0;
    fp_tmp_5 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_5;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_52;
        }
    }
    edx = *((ebp - 0x3c));
    if (*((ebp - 0x58)) >= edx) {
        goto label_31;
label_52:
        ecx = *((ebp + 0xc));
        eax = *(ecx);
        eax -= *((ebp - 0x3c));
        eax <<= 4;
        esi = *((ebp - 0x44));
        edi = *((ebp - 0x24));
        memmove (edi, esi, eax);
        ebx -= *((ebp - 0x3c));
        eax = *((ebp + 0xc));
        *(eax) += ebx;
        goto label_31;
    }
    eax = *((ebp - 0x58));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = edx + eax + 4;
    edx = *((ebp - 0x58));
    do {
        *(eax)++;
        edx++;
        eax += 0x10;
    } while (edx < *((ebp - 0x3c)));
    goto label_31;
label_46:
    fp_stack++;
    goto label_12;
label_50:
    fp_stack++;
label_12:
    ebx += 2;
    esi = *((ebp + 0xc));
    ecx = *(esi);
    if (ecx > ebx) {
        goto label_11;
    }
label_13:
    eax = *((ebp - 0x50));
    return eax;
label_31:
    ebx = *((ebp - 0x4c));
    *((ebp - 0x50)) = 1;
    goto label_12;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fb7c */
#include <stdint.h>
 
int32_t dbg_list_debug (size_t * arg_ch, size_t arg_10h, char * arg_14h, char * arg_18h, token_type * p2, int32_t n2) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t level;
    size_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_ch;
    ebx = p2;
    esi = n2;
    /* void list_debug(int level,token_type * p1,int n1,token_type * p2,int n2); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    eax = *((ebp + 8));
    ebx = *((ebp + 0x14));
    esi = *((ebp + 0x18));
    if (*(obj.debug_level) >= eax) {
        *((esp + 0xc)) = eax;
        *((esp + 8)) = 0x8077a85;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 8)) = 0;
        eax = *((ebp + 0x10));
        *((esp + 4)) = eax;
        eax = *((ebp + 0xc));
        *(esp) = eax;
        list_proc ();
        if (ebx != 0) {
            if (esi <= 0) {
                goto label_0;
            }
            *((esp + 8)) = 0x80759cf;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            *((esp + 8)) = 0;
            *((esp + 4)) = esi;
            *(esp) = ebx;
            list_proc ();
        }
label_0:
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f04 */
#include <stdint.h>
 
void fprintf_chk (void) {
    fprintf_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fb4b */
#include <stdint.h>
 
int32_t dbg_list_proc (void) {
    token_type * p1;
    int32_t n;
    int32_t export_flag;
    size_t * var_4h;
    int32_t var_8h;
    int32_t var_ch;
    char * var_10h;
    /* int list_proc(token_type * p1,int n,int export_flag); */
    eax = *((ebp + 0x10));
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = 0;
    *((esp + 8)) = 1;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    list_string_sub ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806f191 */
#include <stdint.h>
 
int32_t dbg_list_string_sub (int32_t i1, char * cp, int32_t len) {
    int32_t var_43ch;
    int32_t var_438h;
    int32_t export_precision;
    int32_t var_430h;
    int32_t min1;
    int32_t i;
    int32_t var_424h;
    int32_t cflag;
    uint32_t var_41ch;
    int32_t var_418h;
    int32_t k;
    char * dest;
    int32_t cur_level;
    char[500] buf2;
    char[500] buf;
    char * canary;
    token_type * p1;
    int32_t n;
    int32_t outflag;
    char * string;
    int32_t export_flag;
    char * src;
    int32_t var_8h;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = i1;
    edi = cp;
    eax = len;
    /* int list_string_sub(token_type * p1,int n,int outflag,char * string,int export_flag); */
    eax = *((ebp + 8));
    *((ebp - 0x430)) = eax;
    edx = *((ebp + 0x14));
    *((ebp - 0x41c)) = edx;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    al = (*((ebp + 0x10)) != 0) ? 1 : 0;
    dl = (*((ebp + 0x18)) == 0) ? 1 : 0;
    edx = (int32_t) dl;
    edx &= eax;
    *((ebp - 0x420)) = edx;
    if (*((ebp - 0x41c)) != 0) {
        edx = *((ebp - 0x41c));
        *(edx) = 0;
    }
    eax -= eax;
    eax &= 0xfffffffb;
    eax += 0x14;
    *((ebp - 0x434)) = eax;
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = *((ebp - 0x430));
    eax = min_level (eax);
    *((ebp - 0x42c)) = eax;
    *((ebp - 0x410)) = 0;
    if (*((ebp + 0xc)) <= 0) {
        goto label_1;
    }
    *((ebp - 0x40c)) = eax;
    *((ebp - 0x428)) = 0;
    eax = *((ebp + 0x18));
    eax = -eax;
    *((ebp - 0x438)) = eax;
    edx = ebp - 0x210;
    *((ebp - 0x43c)) = edx;
label_0:
    eax = *((ebp - 0x428));
    eax <<= 4;
    eax += *((ebp - 0x430));
    *((ebp - 0x424)) = eax;
    edx = *((ebp - 0x40c));
    edx -= *((eax + 4));
    *((ebp - 0x418)) = edx;
    eax = edx;
    eax >>= 0x1f;
    edx ^= eax;
    edx -= eax;
    *((ebp - 0x414)) = edx;
    if (edx <= 0) {
        goto label_2;
    }
    esi = *((ebp - 0x410));
    esi++;
    edi = *((ebp - 0x41c));
    edi += *((ebp - 0x410));
    ebx = 1;
    do {
        if (*((ebp - 0x418)) > 0) {
            *((ebp - 0x40c))--;
            if (*((ebp - 0x41c)) != 0) {
                *(edi) = 0x29;
            }
            if (*((ebp + 0x10)) != 0) {
                *((esp + 0xc)) = 0x80779a8;
                *((esp + 8)) = 0x8075e74;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            *((ebp - 0x410)) = esi;
            if (*((ebp - 0x420)) == 0) {
                goto label_3;
            }
            eax = *((ebp - 0x40c));
            eax -= *((ebp - 0x42c));
            set_color (eax);
        } else {
            *((ebp - 0x40c))++;
            if (*((ebp - 0x420)) != 0) {
                eax = *((ebp - 0x40c));
                eax -= *((ebp - 0x42c));
                set_color (eax);
            }
            if (*((ebp - 0x41c)) != 0) {
                *(edi) = 0x28;
            }
            if (*((ebp + 0x10)) != 0) {
                *((esp + 0xc)) = 0x8075ad6;
                *((esp + 8)) = 0x8075e74;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            *((ebp - 0x410)) = esi;
        }
label_3:
        ebx++;
        esi++;
        edi++;
    } while (*((ebp - 0x414)) >= ebx);
label_2:
    edx = *((ebp - 0x424));
    eax = *(edx);
    if (eax != 1) {
        if (eax >= 1) {
            if (eax != 2) {
                goto label_4;
            }
            eax = *((ebp - 0x424));
            *(fp_stack--) = *((eax + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            fp_stack--;
            fp_stack++;
        } else {
        } else {
            if (fp_stack[0] == fp_stack[1]) {
                if (fp_stack[0] == fp_stack[1]) {
                    goto label_5;
                }
                *(fp_stack--) = 0.0;
                *((eax + 8)) = fp_stack[0];
                fp_stack--;
            }
label_5:
            if (*((ebp + 0x18)) == 3) {
                eax = *((ebp - 0x424));
                *(fp_stack--) = *((eax + 8));
                *((esp + 0x18)) = fp_stack[0];
                fp_stack--;
                *((esp + 0x14)) = 0xf;
                *((esp + 0x10)) = "%#.*g";
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                edx = ebp - 0x210;
                *(esp) = edx;
                snprintf_chk ();
                eax = ebp - 0x210;
                trim_zeros ();
            } else {
                if (*((ebp + 0x18)) == 0) {
                    if (*(obj.high_prec) == 0) {
                        goto label_6;
                    }
                }
                eax = *((ebp - 0x424));
                *(fp_stack--) = *((eax + 8));
                *((esp + 0x18)) = fp_stack[0];
                fp_stack--;
                edx = *((ebp - 0x434));
                *((esp + 0x14)) = edx;
                *((esp + 0x10)) = 0x80759b8;
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                eax = ebp - 0x210;
                *(esp) = eax;
                snprintf_chk ();
                goto label_7;
label_6:
                eax = finance_option;
                if (eax != 0) {
                    edx = *((ebp - 0x424));
                    *(fp_stack--) = *((edx + 8));
                    *((esp + 0x18)) = fp_stack[0];
                    fp_stack--;
                    *((esp + 0x14)) = eax;
                    *((esp + 0x10)) = "%.*f";
                    *((esp + 0xc)) = 0x1f4;
                    *((esp + 8)) = 1;
                    *((esp + 4)) = 0x1f4;
                    eax = ebp - 0x210;
                    *(esp) = eax;
                    snprintf_chk ();
                } else {
                    edx = *((ebp - 0x424));
                    *(fp_stack--) = *((edx + 8));
                    *(fp_stack--) = 0.0;
                    fp_stack--;
                    if (fp_stack[0] > fp_stack[1]) {
                        if (*(obj.negate_highest_precedence) == 0) {
                            *((esp + 0x18)) = fp_stack[0];
                            fp_stack--;
                            eax = precision;
                            *((esp + 0x14)) = eax;
                            *((esp + 0x10)) = "(%.*g)";
                            *((esp + 0xc)) = 0x1f4;
                            *((esp + 8)) = 1;
                            *((esp + 4)) = 0x1f4;
                            eax = ebp - 0x210;
                            *(esp) = eax;
                            snprintf_chk ();
                        }
                    } else {
                        *((esp + 0x18)) = fp_stack[0];
                        fp_stack--;
                        eax = precision;
                        *((esp + 0x14)) = eax;
                        *((esp + 0x10)) = 0x80759b8;
                        *((esp + 0xc)) = 0x1f4;
                        *((esp + 8)) = 1;
                        *((esp + 4)) = 0x1f4;
                        edx = ebp - 0x210;
                        *(esp) = edx;
                        snprintf_chk ();
                    }
                    if (*((ebp - 0x41c)) != 0) {
                        eax = ebp - 0x210;
                        eax = *((ebp - 0x41c));
                        eax += *((ebp - 0x410));
                        strcpy (eax, eax);
                    }
                    if (*((ebp + 0x10)) != 0) {
                        edx = ebp - 0x210;
                        *((esp + 0xc)) = edx;
                        *((esp + 8)) = 0x8075e74;
                        *((esp + 4)) = 1;
                        eax = gfp;
                        *(esp) = eax;
                        fprintf_chk ();
                    }
                    eax = 0;
                    ecx = 0xffffffff;
                    edi = *((ebp - 0x43c));
                    __asm ("repne scasb al, byte es:[edi]");
                    ecx = ~ecx;
                    eax = *((ebp - 0x410));
                    eax = eax + ecx - 1;
                    *((ebp - 0x410)) = eax;
                    goto label_4;
                }
            }
label_7:
            edx = *((ebp - 0x424));
            *(fp_stack--) = *((edx + 8));
            *(fp_stack--) = 0.0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] > fp_stack[1]) {
                eax = ebp - 0x210;
                *((esp + 0x14)) = eax;
                *((esp + 0x10)) = "(%s)";
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                edx = ebp - 0x404;
                *(esp) = edx;
                snprintf_chk ();
                if (*((ebp - 0x41c)) != 0) {
                    eax = ebp - 0x404;
                    eax = *((ebp - 0x41c));
                    eax += *((ebp - 0x410));
                    strcpy (eax, eax);
                }
                if (*((ebp + 0x10)) != 0) {
                    edx = ebp - 0x404;
                    *((esp + 0xc)) = edx;
                    *((esp + 8)) = 0x8075e74;
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                }
                edi = ebp - 0x404;
                eax = 0;
                ecx = 0xffffffff;
                __asm ("repne scasb al, byte es:[edi]");
                ecx = ~ecx;
                eax = *((ebp - 0x410));
                eax = eax + ecx - 1;
                *((ebp - 0x410)) = eax;
                goto label_4;
            }
            if (*((ebp - 0x41c)) != 0) {
                edx = ebp - 0x210;
                eax = *((ebp - 0x41c));
                eax += *((ebp - 0x410));
                strcpy (eax, edx);
            }
            if (*((ebp + 0x10)) != 0) {
                eax = ebp - 0x210;
                *((esp + 0xc)) = eax;
                *((esp + 8)) = 0x8075e74;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            eax = 0;
            ecx = 0xffffffff;
            edi = *((ebp - 0x43c));
            __asm ("repne scasb al, byte es:[edi]");
            ecx = ~ecx;
            edx = *((ebp - 0x410));
            edx = edx + ecx - 1;
            *((ebp - 0x410)) = edx;
            eax = *((ebp - 0x438));
            edx = *((ebp - 0x424));
            eax = *((edx + 8));
            list_var (eax, eax);
            if (*((ebp - 0x41c)) != 0) {
                eax = *((ebp - 0x41c));
                eax += *((ebp - 0x410));
                strcpy (eax, obj.var_str);
            }
            if (*((ebp + 0x10)) != 0) {
                *((esp + 0xc)) = obj.var_str;
                *((esp + 8)) = 0x8075e74;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            edi = var_str;
            eax = 0;
            ecx = 0xffffffff;
            __asm ("repne scasb al, byte es:[edi]");
            ecx = ~ecx;
            eax = *((ebp - 0x410));
            eax = eax + ecx - 1;
            *((ebp - 0x410)) = eax;
            goto label_4;
        }
        edx = *((ebp - 0x424));
        if (*((edx + 8)) <= 9) {
            eax = *((edx + 8));
            /* switch table (10 cases) at 0x8077bc8 */
            edi = 0x8077a0b;
        } else {
            edi = "(unknown operator)";
            goto label_8;
            edi = 0x8077a22;
            goto label_8;
            edi = 0x8077a2b;
            goto label_8;
            edi = 0x8077a7f;
            goto label_8;
            edi = 0x8077a7e;
            goto label_8;
            edi = 0x8077a26;
            goto label_8;
            if (*(obj.power_starstar) == 0) {
                edi = 0x8077a81;
                if (*((ebp + 0x18)) != 3) {
                    goto label_8;
                }
            }
            edi = 0x8077a2a;
            goto label_8;
            *((ebp - 0x428))++;
            edi = 0x8077a83;
        }
label_8:
        if (*((ebp - 0x41c)) != 0) {
            eax = *((ebp - 0x41c));
            eax += *((ebp - 0x410));
            strcpy (eax, edi);
        }
        if (*((ebp + 0x10)) != 0) {
            *((esp + 0xc)) = edi;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        eax = *((ebp - 0x410));
        eax = eax + ecx - 1;
        *((ebp - 0x410)) = eax;
    }
label_4:
    *((ebp - 0x428))++;
    edx = *((ebp - 0x428));
    if (*((ebp + 0xc)) > edx) {
        goto label_0;
    }
    eax = *((ebp - 0x410));
    edi = *((ebp - 0x40c));
    edi -= *((ebp - 0x42c));
    if (edi <= 0) {
        goto label_1;
    }
    *((ebp - 0x40c)) = eax;
    esi = *((ebp - 0x41c));
    esi += eax;
    ebx = edi;
    *((ebp - 0x410)) = edi;
    edi = *((ebp - 0x41c));
    do {
        if (edi != 0) {
            *(esi) = 0x29;
        }
        if (*((ebp + 0x10)) != 0) {
            *((esp + 0xc)) = 0x80779a8;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        ebx--;
        if (*((ebp - 0x420)) != 0) {
            set_color (ebx);
        }
        esi++;
    } while (ebx > 0);
    edi = *((ebp - 0x410));
    eax = *((ebp - 0x40c));
    edi = edi + eax;
    *((ebp - 0x410)) = edi;
label_1:
    eax = *((ebp - 0x410));
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (ebx != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070715 */
#include <stdint.h>
 
int32_t dbg_make_fractions (void * arg_8h, int32_t i, int32_t k, int32_t level, token_type * equation, int32_t j) {
    int32_t var_44h;
    int32_t var_40h;
    uint32_t var_3ch;
    int32_t inc_level;
    int32_t modified;
    int32_t var_30h;
    int32_t var_2ch;
    double denominator;
    double numerator;
    int * np;
    void * s2;
    size_t n;
    int32_t var_ch;
    ebx = i;
    ecx = k;
    esi = level;
    edi = equation;
    eax = j;
    /* int make_fractions(token_type * equation,int * np); */
    edi = *((ebp + 8));
    ebx = 0;
    *((ebp - 0x34)) = 0;
    eax = *((ebp + 0xc));
    if (*(eax) <= 0) {
        goto label_1;
    }
label_0:
    *((ebp - 0x2c)) = ebx;
    esi = ebx;
    esi <<= 4;
    esi = edi + esi;
    if (*(esi) != 0) {
        goto label_2;
    }
    edx = *((esi + 4));
    *((ebp - 0x30)) = edx;
    if (ebx > 0) {
        eax = ebx;
        eax <<= 4;
        eax = eax + edi - 0x10;
        if (*((eax + 4)) != edx) {
            goto label_3;
        }
        if (*((eax + 8)) == 4) {
            goto label_2;
        }
    }
label_3:
    ecx = ebp - 0x28;
    eax = ebp - 0x20;
    *(fp_stack--) = *((esi + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = f_to_fraction (ecx, eax);
    if (eax == 0) {
        goto label_2;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x28));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_4;
        }
        *(fp_stack--) = *((ebp - 0x20));
        *((esi + 8)) = fp_stack[0];
        fp_stack--;
        goto label_2;
    }
label_4:
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp + 0xc));
    edx = *(ecx);
    al = (edx > 1) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x38)) = eax;
    eax = ebx + 1;
    *((ebp - 0x34)) = eax;
    if (edx <= eax) {
        goto label_5;
    }
    eax = *((ebp - 0x2c));
    eax <<= 4;
    eax = eax + edi + 0x10;
    ecx = *((eax + 4));
    *((ebp - 0x3c)) = ecx;
    ecx = *((ebp - 0x30));
    if (*((ebp - 0x3c)) != ecx) {
        goto label_5;
    }
    eax = *((eax + 8));
    if (eax != 3) {
        eax = 0;
        if (eax != 4) {
            eax = *((ebp - 0x38));
        }
        *((ebp - 0x38)) = eax;
        goto label_5;
    }
    eax = ebx + 3;
    *((ebp - 0x34)) = eax;
    if (edx <= eax) {
        goto label_6;
    }
    eax <<= 4;
    eax = edi + eax;
    *((ebp - 0x38)) = eax;
    ecx = *((eax + 4));
    if (*((ebp - 0x30)) > ecx) {
        goto label_6;
    }
    eax = ebx;
    eax <<= 4;
    eax = eax + edi + 0x50;
    *((ebp - 0x40)) = ebx;
    ebx = *((ebp - 0x34));
    *((ebp - 0x44)) = esi;
    esi = *((ebp - 0x30));
    *((ebp - 0x30)) = edi;
    edi = *((ebp - 0x38));
    do {
        if (esi == ecx) {
            if (*((edi + 8)) == 4) {
                goto label_7;
            }
        }
        ebx += 2;
        if (edx <= ebx) {
            goto label_8;
        }
        edi = eax;
        ecx = *((eax + 4));
        eax += 0x20;
    } while (esi <= ecx);
    *((ebp - 0x34)) = ebx;
    ebx = *((ebp - 0x40));
    esi = *((ebp - 0x44));
    edi = *((ebp - 0x30));
    goto label_6;
label_7:
    *((ebp - 0x34)) = ebx;
    ebx = *((ebp - 0x40));
    esi = *((ebp - 0x44));
    edi = *((ebp - 0x30));
    goto label_6;
label_8:
    *((ebp - 0x34)) = ebx;
    ebx = *((ebp - 0x40));
    esi = *((ebp - 0x44));
    edi = *((ebp - 0x30));
label_6:
    *(fp_stack--) = *((ebp - 0x20));
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            fp_stack++;
            eax = *((ebp - 0x34));
            eax -= ebx;
            eax = eax - 2;
            eax <<= 4;
            eax = *((ebp - 0x2c));
            eax <<= 4;
            eax = eax + edi + 0x20;
            memmove (esi, eax, eax);
            *((ebp - 0x34)) -= 2;
        }
    } else {
        *((esi + 8)) = fp_stack[0];
        fp_stack--;
        edx = *((ebp + 0xc));
        eax = *(edx);
        eax -= *((ebp - 0x34));
        eax <<= 4;
        eax = *((ebp - 0x34));
        eax <<= 4;
        eax = edi + eax;
        eax = *((ebp - 0x34));
        eax <<= 4;
        eax = eax + edi + 0x20;
        memmove (eax, eax, eax);
        ecx = *((ebp + 0xc));
        *(ecx) += 2;
    }
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax = edi + eax;
    edx = *((ebp - 0x3c));
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 4;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax = eax + edi + 0x10;
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x28));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_9;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_9;
    }
    ebx -= 2;
    *((ebp - 0x34)) = 1;
    goto label_2;
label_5:
    eax = ebx;
    eax = ~eax;
    edx = eax + edx;
    edx <<= 4;
    eax = *((ebp - 0x2c));
    eax <<= 4;
    eax = eax + edi + 0x10;
    eax = *((ebp - 0x2c));
    eax <<= 4;
    eax = eax + edi + 0x30;
    memmove (eax, eax, edx);
    ecx = *((ebp + 0xc));
    *(ecx) += 2;
    *(fp_stack--) = *((ebp - 0x20));
    *((esi + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax = edi + eax;
    edx = *((ebp - 0x30));
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 4;
    eax = *((ebp - 0x34));
    eax++;
    edx = eax;
    edx <<= 4;
    edx = edi + edx;
    ecx = *((ebp - 0x30));
    *((edx + 4)) = ecx;
    *(edx) = 0;
    *(fp_stack--) = *((ebp - 0x28));
    *((edx + 8)) = fp_stack[0];
    fp_stack--;
    if (*((ebp - 0x38)) == 0) {
        goto label_9;
    }
    if (ebx > eax) {
        goto label_9;
    }
    esi += 4;
    edx = ebx;
    do {
        *(esi)++;
        edx++;
        esi += 0x10;
    } while (eax >= edx);
label_9:
    *((ebp - 0x34)) = 1;
label_2:
    ebx += 2;
    eax = *((ebp + 0xc));
    if (*(eax) > ebx) {
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x34));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062f95 */
#include <stdint.h>
 
uint32_t dbg_uf_tsimp (void * arg_8h, size_t * arg_ch, int32_t rv) {
    size_t * var_4h;
    edi = rv;
    /* int uf_tsimp(token_type * equation,int * np); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = uf_times ();
    edi = eax;
    simp_loop (esi, ebx);
    while (eax != 0) {
        simp_loop (esi, ebx);
        edi = 1;
        *((esp + 4)) = ebx;
        *(esp) = esi;
        eax = uf_times ();
    }
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d324 */
#include <stdint.h>
 
int32_t dbg_simpb_side (void * arg_8h, char * arg_ch, int32_t arg_18h, int32_t i, long int v1, int * np, long int last_v) {
    int32_t var_1f68h;
    int32_t var_1f64h;
    int32_t cnt;
    int32_t vc;
    sort_type[1000] va;
    int32_t uf_power_flag;
    int32_t power_flag;
    char * nmemb;
    size_t size;
    int32_t const void *);
    char * var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = i;
    edx = v1;
    esi = np;
    edi = last_v;
    /* void simpb_side(token_type * equation,int * np,int uf_power_flag,int power_flag,int fc_level); */
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    simp_loop (edi, esi);
    if (*((ebp + 0x10)) != 0) {
        uf_allpower (edi, esi);
    }
    eax = 0;
    *((ebp - 0x1f5c)) = 0;
    *((ebp - 0x1f68)) = edi;
    edi = eax;
    *((ebp - 0x1f64)) = esi;
    goto label_2;
    do {
        ebx = ecx;
label_0:
        if (*(eax) == 1) {
            ecx = *((eax + 8));
            if (ecx > edi) {
                if (ebx == -1) {
                    goto label_3;
                }
                if (ecx < ebx) {
                    goto label_3;
                }
                if (ebx != ecx) {
                    goto label_4;
                }
                *((ebp - 0x1f60))++;
                ecx = ebx;
            }
        } else {
label_4:
            ecx = ebx;
            goto label_5;
label_3:
            *((ebp - 0x1f60)) = 1;
        }
label_5:
        edx += 2;
        eax += 0x20;
    } while (edx < esi);
    if (ecx != -1) {
        if (ecx > 3) {
            edx = *((ebp - 0x1f5c));
            *((ebp + edx*8 - 0x1f58)) = ecx;
            eax = *((ebp - 0x1f60));
            *((ebp + edx*8 - 0x1f54)) = eax;
            edx++;
            *((ebp - 0x1f5c)) = edx;
        }
        if (*((ebp - 0x1f5c)) > 0x3e7) {
            goto label_6;
        }
        edi = ecx;
label_2:
        edx = *((ebp - 0x1f64));
        esi = *(edx);
        if (esi <= 0) {
            goto label_6;
        }
        eax = *((ebp - 0x1f68));
        ebx = 0xffffffff;
        *((ebp - 0x1f60)) = 0;
        edx = 0;
        goto label_0;
    }
label_6:
    edi = *((ebp - 0x1f68));
    esi = *((ebp - 0x1f64));
    if (*((ebp - 0x1f5c)) == 0) {
        goto label_7;
    }
    eax = *((ebp - 0x1f5c));
    eax = ebp - 0x1f58;
    qsort (dbg.simpb_vcmp, eax, 8);
    edx = *((ebp + 0x18));
    eax = *((ebp - 0x1f58));
    simp2_divide (edx, esi, eax);
    if (*((ebp - 0x1f5c)) <= 1) {
        goto label_8;
    }
    ebx = 1;
    *((ebp - 0x1f60)) = edi;
    edi = esi;
    do {
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp + ebx*8 - 0x1f58));
        *((esp + 8)) = eax;
        *((esp + 4)) = edi;
        eax = *((ebp - 0x1f60));
        *(esp) = eax;
        eax = factor_divide ();
        if (eax != 0) {
            edx = *((ebp + 0x18));
            eax = *((ebp + ebx*8 - 0x1f58));
            eax = *((ebp - 0x1f60));
            simp2_divide (edx, edi, eax);
        }
        ebx++;
    } while (ebx < *((ebp - 0x1f5c)));
    esi = edi;
    edi = *((ebp - 0x1f60));
label_8:
    edx = *((ebp + 0x18));
    simp2_divide (edx, esi, 0);
    ebx = 0;
    if (*((ebp - 0x1f5c)) > 0) {
        goto label_1;
    }
    goto label_9;
    do {
        eax = *((ebp + 0x18));
        simp2_divide (eax, esi, 0);
label_1:
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp + ebx*8 - 0x1f58));
        *((esp + 8)) = eax;
        *((esp + 4)) = esi;
        *(esp) = edi;
        eax = factor_plus ();
    } while (eax != 0);
    ebx++;
    if (ebx < *((ebp - 0x1f5c))) {
        goto label_1;
    }
    while (eax != 0) {
        simp2_divide (ebx, esi, 0);
        goto label_10;
label_9:
        ebx = *((ebp + 0x18));
label_10:
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = 5;
        *((esp + 4)) = esi;
        *(esp) = edi;
        eax = factor_plus ();
    }
label_7:
    eax = *((ebp + 0x18));
    eax = *((ebp + 0x14));
    *(fp_stack--) = 0.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    simp_ssub (eax, esi, 5);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061b6c */
#include <stdint.h>
 
uint32_t dbg_fractions_and_group (int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    token_type * equation;
    int * np;
    char * var_sp_4h;
    edi = rv;
    /* int fractions_and_group(token_type * equation,int * np); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    elim_loop (esi, ebx);
    *((esp + 4)) = ebx;
    eax = make_fractions (esi);
    edi = eax;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    group_proc ();
    eax = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x807057d */
#include <stdint.h>
 
uint32_t dbg_f_to_fraction (int32_t arg_10h, int32_t arg_14h, double * numeratorp, double * denominatorp) {
    double numerator;
    double denominator;
    double d;
    ebx = numeratorp;
    esi = denominatorp;
    /* int f_to_fraction(double d,double * numeratorp,double * denominatorp); */
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x10)) = fp_stack[0];
    ebx = *((ebp + 0x10));
    esi = *((ebp + 0x14));
    *(ebx) = fp_stack[0];
    *(fp_stack--) = 1.0;
    *(esi) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = finite ();
    if (eax == 0) {
        goto label_0;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x10));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (eax == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_1;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x10));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_1:
    eax = 1;
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_2;
        }
    }
    *(fp_stack--) = *(obj.small_epsilon);
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x10));
    *(esp) = fp_stack[0];
    fp_stack--;
    my_round ();
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_3;
        }
    }
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[1] -= fp_stack[0];
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] *= *((ebp - 0x18));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        *(ebx) = fp_stack[0];
        fp_stack--;
        eax = 1;
        goto label_2;
label_3:
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x10));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 1.0;
    *(esp) = fp_stack[0];
    fp_stack--;
    gcd ();
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *(obj.epsilon);
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x10));
        fp_stack[1] /= fp_stack[0];
        fp_stack++;
        *(esp) = fp_stack[0];
        fp_stack--;
        my_round ();
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x18));
        *(0x8075170) /= fp_stack[0];
        *(esp) = fp_stack[0];
        fp_stack--;
        my_round ();
        *((ebp - 0x18)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack[0] = abs(fp_stack[0]);
        *(fp_stack--) = *(0x8077c68);
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        fp_stack--;
        if (fp_stack[0] < fp_stack[1]) {
            *(fp_stack--) = *((ebp - 0x18));
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] < fp_stack[1]) {
                *(fp_stack--) = *(0x8072058);
                fp_stack--;
                if (fp_stack[0] <= fp_stack[1]) {
                    *((esp + 8)) = fp_stack[0];
                    fp_stack--;
                    *(fp_stack--) = *((ebp - 0x20));
                    *(esp) = fp_stack[0];
                    fp_stack--;
                    gcd ();
                    *(fp_stack--) = 1.0;
                    fp_tmp_3 = fp_stack[1];
                    fp_stack[1] = fp_stack[0];
                    fp_stack[0] = fp_tmp_3;
                    fp_stack[1] = fp_stack[0];
                    fp_stack--;
                    if (fp_stack[0] > fp_stack[1]) {
                        *(fp_stack--) = *((ebp - 0x20));
                        fp_stack[0] /= fp_stack[1];
                        *((ebp - 0x20)) = fp_stack[0];
                        fp_stack--;
                        *((ebp - 0x18)) /= fp_stack[0];
                        *((ebp - 0x18)) = fp_stack[0];
                        fp_stack--;
                    } else {
                        fp_stack++;
                    }
                    *(fp_stack--) = *((ebp - 0x20));
                    fp_stack[0] /= *((ebp - 0x18));
                    *(fp_stack--) = *((ebp - 0x10));
                    fp_stack[1] -= fp_stack[0];
                    fp_stack[0] = abs(fp_stack[0]);
                    fp_tmp_4 = fp_stack[1];
                    fp_stack[1] = fp_stack[0];
                    fp_stack[0] = fp_tmp_4;
                    fp_stack[0] = abs(fp_stack[0]);
                    fp_stack[0] *= *(obj.small_epsilon);
                    fp_tmp_5 = fp_stack[1];
                    fp_stack[1] = fp_stack[0];
                    fp_stack[0] = fp_tmp_5;
                    fp_stack--;
                    fp_stack++;
                    if (fp_stack[0] > fp_stack[1]) {
                        goto label_0;
                    }
                    *(fp_stack--) = *((ebp - 0x20));
                    *(ebx) = fp_stack[0];
                    fp_stack--;
                    *(fp_stack--) = *((ebp - 0x18));
                    *(esi) = fp_stack[0];
                    fp_stack--;
                    eax = 1;
                    fp_stack++;
                    fp_stack++;
                    fp_stack++;
                } else {
                } else {
                } else {
                } else {
                    fp_stack++;
                }
            }
        }
label_0:
        eax = 0;
    }
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8071820 */
#include <stdint.h>
 
void libc_csu_fini (void) {
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804982a */
#include <stdint.h>
 
int32_t dbg_main_io_loop (char * cp) {
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    int32_t var_18h;
    eax = cp;
    /* void main_io_loop(); */
    ebx = "&mdash;&gt; ";
    esi = 0x8071931;
    do {
        default_color ();
        eax = esi;
        if (*(obj.html_flag) != 0) {
            eax = ebx;
        }
        *((esp + 0x18)) = eax;
        eax = cur_equation;
        eax++;
        *((esp + 0x14)) = eax;
        *((esp + 0x10)) = "%d%s";
        *((esp + 0xc)) = 0x50;
        *((esp + 8)) = 1;
        *((esp + 4)) = 0x50;
        *(esp) = obj.prompt_str;
        snprintf_chk ();
        eax = n_tokens;
        eax <<= 4;
        eax = tlhs;
        eax = get_string (eax, eax);
        if (eax == 0) {
            goto label_0;
        }
        process (eax);
    } while (1);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a0a7 */
#include <stdint.h>
 
int32_t dbg_found_var (int32_t arg_8h, size_t * arg_ch, size_t * arg_10h, int32_t n, int32_t j, long int v) {
    int32_t count;
    ebx = n;
    edx = j;
    esi = v;
    /* int found_var(token_type * p1,int n,long int v); */
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    if (esi == 0) {
        goto label_0;
    }
    if (ebx <= 0) {
        goto label_0;
    }
    edx = *((ebp + 8));
    *((ebp - 0x10)) = 0;
    ecx = 0;
    do {
        if (*(edx) == 1) {
            al = (*((edx + 8)) == esi) ? 1 : 0;
            edi = eax;
            edi &= 0xff;
            *((ebp - 0x10)) += edi;
        }
        ecx++;
        edx += 0x10;
    } while (ecx != ebx);
    goto label_1;
label_0:
    *((ebp - 0x10)) = 0;
label_1:
    eax = *((ebp - 0x10));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805c1f9 */
#include <stdint.h>
 
uint32_t dbg_calc (int32_t arg_8h, size_t arg_ch, int * op1p, double * k1p, int32_t op1) {
    double d2;
    double d1;
    double d;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t op2;
    double k2;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    esi = op1p;
    edi = k1p;
    eax = op1;
    /* int calc(int * op1p,double * k1p,int op2,double k2); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    *(fp_stack--) = *((ebp + 0x14));
    *((ebp - 0x40)) = fp_stack[0];
    fp_stack--;
    *(obj.domain_check) = 0;
    eax = errno_location ();
    ebx = eax;
    *(eax) = 0;
    eax = 0;
    if (esi != 0) {
        eax = *(esi);
    }
    if (*((ebp + 0x10)) > 9) {
        goto label_0;
    }
    edx = *((ebp + 0x10));
    /* switch table (10 cases) at 0x8076ddc */
    if (eax == 2) {
        *(fp_stack--) = *(edi);
        fp_stack[0] = -fp_stack[0];
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    } else {
        *(fp_stack--) = *(edi);
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    }
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] = abs(fp_stack[0]);
    fp_stack[0] *= *(obj.epsilon);
    *((ebp - 0x28)) = fp_stack[0];
    fp_stack--;
    if (*((ebp + 0x10)) == 1) {
        *(fp_stack--) = *((ebp - 0x40));
        fp_stack[0] += *((ebp - 0x20));
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    } else {
        *(fp_stack--) = *((ebp - 0x40));
        *((ebp - 0x20)) -= fp_stack[0];
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    }
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *((ebp - 0x28));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = 0.0;
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
    }
    if (eax == 0) {
        *(fp_stack--) = *((ebp - 0x20));
        *(edi) = fp_stack[0];
        fp_stack--;
        al = 1;
        goto label_1;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        *(esi) = 1;
        *(fp_stack--) = *((ebp - 0x20));
        *(edi) = fp_stack[0];
        fp_stack--;
        eax = 1;
        goto label_1;
    }
    *(esi) = 2;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] = -fp_stack[0];
    *(edi) = fp_stack[0];
    fp_stack--;
    eax = 1;
    goto label_1;
    edx = 3;
    if (eax == 0) {
        eax = edx;
    }
    if (eax == *((ebp + 0x10))) {
        *(fp_stack--) = *((ebp - 0x40));
        fp_stack[0] *= *(edi);
        *(edi) = fp_stack[0];
        fp_stack--;
        eax = 1;
        goto label_1;
    }
    if (eax == 4) {
        *(fp_stack--) = *(edi);
        *(esp) = fp_stack[0];
        fp_stack--;
        check_divide_by_zero ();
        *(fp_stack--) = *((ebp - 0x40));
        fp_stack[0] /= *(edi);
        *(edi) = fp_stack[0];
        fp_stack--;
        *(esi) = 3;
        eax = 1;
        goto label_1;
    }
    if (*((ebp + 0x10)) != 4) {
        goto label_2;
    }
    *(fp_stack--) = *((ebp - 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    check_divide_by_zero ();
    *(fp_stack--) = *((ebp - 0x40));
    *(edi) /= fp_stack[0];
    *(edi) = fp_stack[0];
    fp_stack--;
    eax = 1;
    goto label_1;
    *(fp_stack--) = *((ebp - 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    check_divide_by_zero ();
    *(fp_stack--) = *((ebp - 0x40));
    *(edi) /= fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (edi);
    fp_stack++;
    eax = 1;
    goto label_1;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_3;
        }
        warning ("Modulo 0 encountered, might be considered undefined.");
    }
label_3:
    eax = ebp - 0x20;
    *(fp_stack--) = *((ebp - 0x40));
    *(edi) /= fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    modf (eax);
    fp_stack[0] *= *((ebp - 0x40));
    *(edi) = fp_stack[0];
    if (*(obj.modulus_mode) == 0) {
        goto label_4;
    }
    *(fp_stack--) = 0.0;
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x40));
        fp_stack[0] = abs(fp_stack[0]);
        fp_stack[0] += fp_stack[1];
        fp_stack++;
        *(edi) = fp_stack[0];
        fp_stack--;
    } else {
        fp_stack++;
    }
    if (*(obj.modulus_mode) != 1) {
        goto label_2;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x40));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_5;
    }
    *(fp_stack--) = *(edi);
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_6;
    }
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(edi) = fp_stack[0];
    fp_stack--;
    eax = 1;
    goto label_1;
    *(fp_stack--) = *(edi);
    *(fp_stack--) = 0.0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_7;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x40));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_8;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_8:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_2;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_2;
    }
label_7:
    *(obj.domain_check) = 1;
    *(fp_stack--) = *(edi);
    *(fp_stack--) = 0.0;
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_9;
        }
        *(fp_stack--) = *((ebp - 0x40));
        fp_stack--;
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        if (fp_stack[0] != fp_stack[2]) {
            goto label_10;
        }
        if (fp_stack[0] == fp_stack[2]) {
            goto label_10;
        }
        fp_stack++;
        warning ("0^0 encountered, might be considered indeterminate.");
        *(fp_stack--) = 1.0;
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
        goto label_11;
    }
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    goto label_12;
label_9:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_12:
    *(fp_stack--) = 0.0;
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_13;
        }
label_10:
        *(fp_stack--) = 0.0;
        *(fp_stack--) = *((ebp - 0x40));
        fp_tmp_5 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_5;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_13;
        }
        fp_stack++;
        warning ("Divide by zero (0 raised to negative power).");
        *(fp_stack--) = *(0x8075660);
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
        goto label_11;
    }
label_13:
    *(fp_stack--) = *((ebp - 0x40));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    pow ();
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    if (*(obj.preserve_surds) == 0) {
        goto label_11;
    }
    if (*(obj.approximate_roots) != 0) {
        goto label_11;
    }
    *(fp_stack--) = *((ebp - 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = finite ();
    if (eax == 0) {
        goto label_11;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x40));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (eax == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_14;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x40));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_14:
    *(fp_stack--) = 0.0;
    fp_tmp_6 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_6;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    eax = ebp - 0x30;
    eax = ebp - 0x28;
    *(fp_stack--) = *(edi);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = f_to_fraction (eax, eax);
    if (eax != 0) {
        eax = ebp - 0x30;
        eax = ebp - 0x28;
        *(fp_stack--) = *((ebp - 0x20));
        *(esp) = fp_stack[0];
        fp_stack--;
        eax = f_to_fraction (eax, eax);
        if (eax == 0) {
            *(obj.domain_check) = 0;
        }
    } else {
label_11:
        check_err ();
        if (*(obj.domain_check) != 0) {
            *(fp_stack--) = *((ebp - 0x20));
            *(edi) = fp_stack[0];
            fp_stack--;
            eax = 1;
            goto label_1;
            *(fp_stack--) = 1.0;
            fp_stack[0] += *(edi);
            *(esp) = fp_stack[0];
            fp_stack--;
            lgamma ();
            *(esp) = fp_stack[0];
            fp_stack--;
            exp ();
            *(fp_stack--) = *(obj.signgam);
            fp_stack[0] *= fp_stack[1];
            fp_stack++;
            *((ebp - 0x20)) = fp_stack[0];
            if (*(ebx) == 0) {
                *(edi) = fp_stack[0];
                fp_stack--;
                eax = 1;
                goto label_1;
            }
            fp_stack++;
label_0:
            eax = 0;
            goto label_1;
label_4:
            fp_stack++;
            goto label_2;
label_5:
            fp_stack++;
            goto label_2;
label_6:
            fp_stack++;
            fp_stack++;
        }
label_2:
        eax = 1;
    }
label_1:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070286 */
#include <stdint.h>
 
uint32_t dbg_reset_attr (void) {
    char * var_4h;
    /* void reset_attr(); */
    if (*(obj.color_flag) != 0) {
        if (*(obj.cur_color) < 0) {
            goto label_0;
        }
        if (*(obj.html_flag) != 0) {
            *((esp + 4)) = "</font>";
            *(esp) = 1;
            printf_chk ();
        } else {
            *((esp + 4)) = "\e[0m";
            *(esp) = 1;
            printf_chk ();
        }
    }
label_0:
    *(obj.cur_color) = 0xffffffff;
    eax = fflush (0);
    if (eax != 0) {
        perror ("fflush(3) call failed");
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8068610 */
#include <stdint.h>
 
uint32_t dbg_limit_cmd (int32_t i) {
    int32_t var_4ch;
    token_type want;
    int32_t var_38h;
    uint32_t var_34h;
    token_type solved_v;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    long int v;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * cp;
    char * s2;
    size_t * n;
    char * var_sp_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = i;
    /* int limit_cmd(char * cp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    *((ebp - 0x1c)) = 0;
    eax = current_not_defined ();
    if (eax == 0) {
        eax = next_espace ();
        ebx = eax;
        eax = cur_equation;
        if (*((eax*4 + obj.n_rhs)) == 0) {
            esi = n_lhs;
            edx = *((esi + eax*4));
            edx <<= 4;
            edi = lhs;
            edx = *((edi + eax*4));
            eax = *((eax*4 + obj.rhs));
            memmove (eax, edx, edx);
            eax = cur_equation;
            edx = *((esi + eax*4));
            *((eax*4 + obj.n_rhs)) = edx;
            *((esi + eax*4)) = 1;
            eax = *((edi + eax*4));
            *((eax + 4)) = 1;
            eax = cur_equation;
            eax = *((edi + eax*4));
            *(eax) = 1;
            *((esp + 4)) = "answer";
            eax = cur_equation;
            eax = *((edi + eax*4));
            eax += 8;
            parse_var (eax);
        }
        eax = cur_equation;
        eax = solved_equation (eax);
        if (eax == 0) {
            *(esp) = "The current equation is not solved for a variable.";
            error ();
            eax = 0;
        } else {
            eax = cur_equation;
        }
        eax = *((eax*4 + obj.lhs));
        edx = *(eax);
        *((ebp - 0x2c)) = edx;
        edx = *((eax + 4));
        *((ebp - 0x28)) = edx;
        edx = *((eax + 8));
        *((ebp - 0x24)) = edx;
        eax = *((eax + 0xc));
        *((ebp - 0x20)) = eax;
        esi = *((ebp + 8));
        if (*(esi) != 0) {
            eax = ebp - 0x1c;
            eax = parse_var2 (eax, esi);
            esi = eax;
            if (eax == 0) {
                goto label_0;
            }
        }
        eax = cur_equation;
        edx = ebp - 0x1c;
        *((esp + 8)) = edx;
        edx = *((eax*4 + obj.n_rhs));
        eax = *((eax*4 + obj.rhs));
        eax = no_vars (eax, edx);
        if (eax != 0) {
            *(esp) = "Current expression contains no variables.";
            error ();
            eax = 0;
        } else {
        }
        if (*((ebp - 0x1c)) == 0) {
            eax = ebp - 0x1c;
            eax = prompt_var (eax);
            if (eax == 0) {
                goto label_0;
            }
        }
        eax = cur_equation;
        edx = *((ebp - 0x1c));
        edx = *((eax*4 + obj.n_rhs));
        eax = *((eax*4 + obj.rhs));
        eax = found_var (eax, edx, edx);
        if (eax == 0) {
            *(esp) = "Variable not found.";
            error ();
            eax = 0;
        } else {
        }
        if (*(esi) == 0x3d) {
            esi++;
            eax = skip_space (esi);
            esi = eax;
        }
        if (*(esi) != 0) {
            eax = esi;
            eax -= *((ebp + 8));
            *(obj.input_column) += eax;
            *((esp + 8)) = esi;
            eax = tes;
            eax = parse_expr (eax, 0x80795f4);
            if (eax == 0) {
                goto label_0;
            }
            if (*(obj.n_tes) <= 0) {
            } else {
                eax = *((ebp - 0x1c));
                list_var (eax, 0);
                *((esp + 0x14)) = 0x8079800;
                *((esp + 0x10)) = "as (%s) goes to: ";
                *((esp + 0xc)) = 0x50;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x50;
                *(esp) = obj.prompt_str;
                snprintf_chk ();
                eax = tes;
                eax = get_expr (eax, 0x80795f4);
                if (eax == 0) {
                    goto label_0;
                }
            }
            eax = cur_equation;
            copy_espace (eax, ebx);
            edi = ebx*4;
            esi = edi + obj_n_rhs;
            *((esp + 0xc)) = 0;
            *((esp + 8)) = 0;
            eax = *((ebx*4 + obj.rhs));
            simpa_side (eax, esi);
            eax = tes;
            simp_loop (eax, 0x80795f4);
            if (*(obj.n_tes) == 1) {
                eax = tes;
                if (*(eax) != 0) {
                    goto label_1;
                }
                *(fp_stack--) = *((eax + 8));
                *(fp_stack--) = *(0x8075178);
                fp_tmp_0 = fp_stack[1];
                fp_stack[1] = fp_stack[0];
                fp_stack[0] = fp_tmp_0;
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] <= fp_stack[1]) {
                    goto label_1;
                }
                *(obj.n_tes) = 1;
                edx = zero_token;
                *(eax) = edx;
                edx = .comment;
                *((eax + 4)) = edx;
                edx = .comment;
                *((eax + 8)) = edx;
                edx = .comment;
                *((eax + 0xc)) = edx;
                eax = tlhs;
                edx = one_token;
                *(eax) = edx;
                edx = .comment;
                *((eax + 4)) = edx;
                edx = .comment;
                *((eax + 8)) = edx;
                edx = .comment;
                *((eax + 0xc)) = edx;
                eax = tlhs;
                *((eax + 0x14)) = 1;
                eax = tlhs;
                *((eax + 0x10)) = 2;
                eax = tlhs;
                *((eax + 0x18)) = 4;
                eax = tlhs;
                *((eax + 0x24)) = 1;
                eax = tlhs;
                *((eax + 0x20)) = 1;
                edx = *((ebp - 0x1c));
                eax = tlhs;
                *((eax + 0x28)) = edx;
                *(obj.n_tlhs) = 3;
                eax = *((ebp - 0x1c));
                *((esp + 0x10)) = eax;
                *((esp + 0xc)) = 3;
                eax = tlhs;
                *((esp + 8)) = eax;
                *((esp + 4)) = esi;
                eax = *((ebx*4 + obj.rhs));
                subst_var_with_exp (eax);
            }
label_1:
            if (*(obj.debug_level) >= 0) {
                *((esp + 0xc)) = "Solving...";
                *((esp + 8)) = 0x807277d;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            *((ebp - 0x38)) = 1;
            *((ebp - 0x3c)) = 1;
            eax = *((ebp - 0x1c));
            *((ebp - 0x34)) = eax;
            edi += obj.n_lhs;
            *((ebp - 0x4c)) = edi;
            *((esp + 0x14)) = esi;
            eax = *((ebx*4 + obj.rhs));
            *((esp + 0x10)) = eax;
            *((esp + 0xc)) = edi;
            eax = *((ebx*4 + obj.lhs));
            *((esp + 8)) = eax;
            *((esp + 4)) = 1;
            eax = ebp - 0x3c;
            *(esp) = eax;
            eax = solve_sub ();
            if (eax <= 0) {
                *(esp) = "Can't take the limit because solve failed.";
                error ();
                eax = 0;
                goto label_2;
            }
            eax = n_tes;
            eax <<= 4;
            eax = tes;
            eax = *((ebx*4 + obj.lhs));
            memmove (eax, eax, eax);
            eax = n_tes;
            *((ebx*4 + obj.n_lhs)) = eax;
            eax = symblify;
            *(obj.symb_flag) = eax;
            *((esp + 0xc)) = 0;
            *((esp + 8)) = 0;
            edi = rhs;
            eax = *((edi + ebx*4));
            simpa_side (eax, esi);
            *(obj.symb_flag) = 0;
            eax = *((ebx*4 + obj.n_rhs));
            *((esp + 4)) = eax;
            eax = *((edi + ebx*4));
            eax = exp_contains_nan (eax);
            if (eax != 0) {
                *(esp) = "Unable to take limit; result contains NaN (Not a Number).";
                error ();
                eax = 0;
                goto label_2;
            }
            *((esp + 0x14)) = esi;
            eax = *((ebx*4 + obj.rhs));
            *((esp + 0x10)) = eax;
            eax = *((ebp - 0x4c));
            *((esp + 0xc)) = eax;
            eax = *((ebx*4 + obj.lhs));
            *((esp + 8)) = eax;
            *((esp + 4)) = 1;
            eax = ebp - 0x2c;
            *(esp) = eax;
            eax = solve_sub ();
            if (eax <= 0) {
                *(esp) = "Can't take the limit because solve failed.";
                error ();
                eax = 0;
                goto label_2;
            }
            *((esp + 0xc)) = 0;
            *((esp + 8)) = 0;
            esi = rhs;
            eax = *((esi + ebx*4));
            simpa_side (eax, esi);
            eax = *((ebx*4 + obj.n_rhs));
            *((esp + 4)) = eax;
            eax = *((esi + ebx*4));
            eax = exp_contains_nan (eax);
            if (eax != 0) {
                *(esp) = "Unable to take limit; result contains NaN (Not a Number).";
                error ();
                eax = 0;
                goto label_2;
            }
            return_result (ebx);
        }
    } else {
label_0:
        eax = 0;
    }
label_2:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806b429 */
#include <stdint.h>
 
uint32_t dbg_laplace_cmd (int32_t arg_8h, char * cp, int32_t i, int * nps) {
    int * np;
    token_type * dest;
    token_type * source;
    int32_t inverse_flag;
    int32_t n1;
    long int v;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * s2;
    size_t n;
    int32_t var_sp_ch;
    ebx = cp;
    esi = i;
    edi = nps;
    /* int laplace_cmd(char * cp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    *((ebp - 0x1c)) = 0;
    eax = current_not_defined ();
    if (eax == 0) {
        eax = next_espace ();
        esi = eax;
        eax = cur_equation;
        if (*((eax*4 + obj.n_rhs)) != 0) {
            edx = rhs;
            ecx = *((edx + eax*4));
            *((ebp - 0x30)) = ecx;
            edi = eax*4 + obj_n_rhs;
            edx = *((edx + esi*4));
            *((ebp - 0x34)) = edx;
            eax = esi*4 + obj_n_rhs;
            *((ebp - 0x38)) = eax;
        } else {
            edx = lhs;
            ecx = *((edx + eax*4));
            *((ebp - 0x30)) = ecx;
            edi = eax*4 + obj_n_lhs;
            edx = *((edx + esi*4));
            *((ebp - 0x34)) = edx;
            eax = esi*4 + obj_n_lhs;
            *((ebp - 0x38)) = eax;
        }
        *((esp + 4)) = "inverse";
        eax = strcmp_tospace (ebx);
        al = (eax == 0) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x2c)) = eax;
        if (eax != 0) {
            eax = skip_param (ebx);
            ebx = eax;
        }
        if (*(ebx) != 0) {
            eax = ebp - 0x1c;
            eax = parse_var2 (eax, ebx);
            ebx = eax;
            if (eax == 0) {
            } else {
                eax = ebp - 0x1c;
                eax = prompt_var (eax);
                if (eax == 0) {
                    goto label_0;
                }
            }
            eax = extra_characters (ebx);
            if (eax != 0) {
                goto label_0;
            }
            *(obj.partial_flag) = 0;
            *((esp + 4)) = edi;
            edx = *((ebp - 0x30));
            *(esp) = edx;
            uf_simp ();
            *(obj.partial_flag) = 1;
            eax = *((ebp - 0x1c));
            ecx = *((ebp - 0x30));
            factorv (ecx, edi, eax);
            eax = *(edi);
            eax <<= 4;
            eax = *((ebp - 0x30));
            edx = *((ebp - 0x34));
            memmove (edx, eax, eax);
            eax = *(edi);
            *((ebp - 0x20)) = eax;
            if (*((ebp - 0x2c)) != 0) {
                *((esp + 0xc)) = 1;
                edx = *((ebp - 0x1c));
                *((esp + 8)) = edx;
                *((esp + 4)) = eax;
                ecx = *((ebp - 0x34));
                eax = poly_in_v (ecx);
                if (eax != 0) {
                    *((esp + 0xc)) = dbg.inv_laplace_sub;
                    eax = *((ebp - 0x1c));
                    eax = ebp - 0x20;
                    eax = *((ebp - 0x34));
                    eax = int_dispatch (eax, eax, eax);
                    if (eax != 0) {
                        goto label_1;
                    }
                }
                *(esp) = "Inverse Laplace failed.";
                error ();
                eax = 0;
                goto label_2;
            }
            *((esp + 0xc)) = 0;
            edx = *((ebp - 0x1c));
            *((esp + 8)) = edx;
            *((esp + 4)) = eax;
            edx = *((ebp - 0x34));
            eax = poly_in_v (edx);
            if (eax != 0) {
                *((esp + 0xc)) = dbg.laplace_sub;
                eax = *((ebp - 0x1c));
                eax = ebp - 0x20;
                ecx = *((ebp - 0x34));
                eax = int_dispatch (ecx, eax, eax);
                if (eax != 0) {
                    goto label_1;
                }
            }
            *(esp) = "Laplace failed, not a polynomial.";
            error ();
            eax = 0;
            goto label_2;
label_1:
            eax = ebp - 0x20;
            eax = *((ebp - 0x34));
            simp_loop (eax, eax);
            eax = cur_equation;
            if (*((eax*4 + obj.n_rhs)) != 0) {
                ebx = n_lhs;
                edx = *((ebx + eax*4));
                edx <<= 4;
                edx = lhs;
                eax = *((edx + eax*4));
                eax = *((edx + esi*4));
                memmove (eax, eax, edx);
                eax = cur_equation;
                eax = *((ebx + eax*4));
                *((ebx + esi*4)) = eax;
            }
            eax = *((ebp - 0x20));
            edx = *((ebp - 0x38));
            *(edx) = eax;
            *(obj.cur_equation) = esi;
            return_result (esi);
        }
    } else {
label_0:
        eax = 0;
    }
label_2:
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8051a6a */
#include <stdint.h>
 
int32_t dbg_skip_no (int32_t arg_8h, char ** cpp) {
    char * var_4h;
    ebx = cpp;
    /* int skip_no(char ** cpp); */
    ebx = *((ebp + 8));
    *((esp + 4)) = 0x8075670;
    eax = *(ebx);
    eax = strcmp_tospace (eax);
    if (eax != 0) {
        *((esp + 4)) = 0x8075673;
        eax = *(ebx);
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            goto label_0;
        }
        *((esp + 4)) = 0x8075677;
        eax = *(ebx);
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            goto label_0;
        }
        *((esp + 4)) = "false";
        eax = *(ebx);
        eax = strcmp_tospace (eax);
        if (eax != 0) {
            goto label_1;
        }
    }
label_0:
    eax = *(ebx);
    eax = skip_param (eax);
    *(ebx) = eax;
    eax = 1;
    goto label_2;
label_1:
    *((esp + 4)) = 0x8075681;
    eax = *(ebx);
    eax = strcmp_tospace (eax);
    if (eax != 0) {
        *((esp + 4)) = 0x8075900;
        eax = *(ebx);
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            goto label_3;
        }
        *((esp + 4)) = "true";
        eax = *(ebx);
        eax = strcmp_tospace (eax);
        edx = eax;
        eax = 0;
        if (edx != 0) {
            goto label_2;
        }
    }
label_3:
    eax = *(ebx);
    eax = skip_param (eax);
    *(ebx) = eax;
    eax = 0;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a45e */
#include <stdint.h>
 
uint32_t dbg_strcmp_tospace (char * arg_ch, char * cp2a, char * cp1a, char * cp2) {
    char * cp1;
    char * s2;
    size_t n;
    ebx = cp2a;
    esi = cp1a;
    edi = cp2;
    /* int strcmp_tospace(char * cp1,char * cp2); */
    edi = *((ebp + 0xc));
    edx = *((ebp + 8));
    eax = *(edx);
    esi = edx;
    if (al != 0) {
        goto label_1;
    }
    while (eax == 0) {
        esi++;
        eax = *(esi);
        if (al == 0) {
label_0:
            eax = *(edi);
            ebx = edi;
            if (al != 0) {
                goto label_2;
            }
            goto label_3;
        }
label_1:
        eax = (int32_t) al;
        eax = isdelimiter (eax);
    }
    goto label_0;
    do {
        ebx++;
        eax = *(ebx);
        if (al == 0) {
            goto label_3;
        }
label_2:
        eax = (int32_t) al;
        eax = isdelimiter (eax);
    } while (eax == 0);
label_3:
    ebx -= edi;
    esi -= *((ebp + 8));
    if (ebx < esi) {
        ebx = esi;
    }
    eax = *((ebp + 8));
    strncasecmp (eax, edi, ebx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a977 */
#include <stdint.h>
 
int32_t dbg_subst_var_with_exp (size_t arg_10h, int32_t k, int32_t level, int32_t j) {
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    void * var_28h;
    int32_t var_24h;
    void * s1;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    int32_t len;
    long int v;
    size_t s2;
    size_t n;
    ecx = k;
    edx = level;
    esi = j;
    /* void subst_var_with_exp(token_type * equation,int * np,token_type * expression,int len,long int v); */
    edx = *((ebp + 8));
    if (*((ebp + 0x18)) == 0) {
        goto label_1;
    }
    if (*((ebp + 0x14)) <= 0) {
        goto label_1;
    }
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    esi = *(ecx);
    esi--;
    if (esi < 0) {
        goto label_1;
    }
    ecx = *((ebp + 0x14));
    ecx <<= 4;
    *((ebp - 0x2c)) = ecx;
    ebx = esi;
    ebx <<= 4;
    ebx = edx + ebx;
    ecx = eax;
    ecx = -ecx;
    *((ebp - 0x24)) = ecx;
    edi = *((ebp + 0x14));
    edi += esi;
    ecx = edi;
    ecx <<= 4;
    ecx = edx + ecx;
    *((ebp - 0x20)) = ecx;
    eax <<= 4;
    eax = edx + eax;
    *((ebp - 0x1c)) = eax;
label_0:
    *((ebp - 0x28)) = ebx;
    if (*(ebx) != 1) {
        goto label_2;
    }
    eax = *((ebp + 0x18));
    if (*((ebx + 8)) != eax) {
        goto label_2;
    }
    edx = *((ebx + 4));
    *((ebp - 0x30)) = edx;
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    edx = *((ebp + 0x14));
    eax = edx + eax - 1;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    *((ebp - 0x34)) = edi;
    eax = *((ebp - 0x24));
    ecx = *((ebp + 0xc));
    eax += *(ecx);
    eax <<= 4;
    eax = *((ebp - 0x1c));
    edx = *((ebp - 0x20));
    memmove (edx, eax, eax);
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    edx = *((ebp + 0x14));
    eax = edx + eax - 1;
    *(ecx) = eax;
    ecx = *((ebp - 0x2c));
    eax = *((ebp + 0x10));
    edx = *((ebp - 0x28));
    memmove (edx, eax, ecx);
    if (esi >= edi) {
        goto label_2;
    }
    eax = *((ebp - 0x28));
    eax += 4;
    edx = esi;
    *((ebp - 0x28)) = edi;
    ecx = *((ebp - 0x30));
    edi = *((ebp - 0x34));
    do {
        *(eax) += ecx;
        edx++;
        eax += 0x10;
    } while (edx < edi);
    edi = *((ebp - 0x28));
label_2:
    ebx -= 0x10;
    *((ebp - 0x24))++;
    *((ebp - 0x20)) -= 0x10;
    *((ebp - 0x1c)) -= 0x10;
    edi--;
    esi--;
    if (esi >= 0) {
        goto label_0;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a801 */
#include <stdint.h>
 
int32_t dbg_get_yes_no (char * cp) {
    char[4096] buf;
    int32_t var_ch;
    int32_t var_4h;
    ebx = cp;
    /* int get_yes_no(); */
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    esi = ebp - 0x100c;
    do {
        eax = get_string (esi, 0x1000);
        ebx = eax;
        if (eax == 0) {
            goto label_0;
        }
        str_tolower (eax);
        eax = *(ebx);
        if (al == 0x6e) {
            goto label_0;
        }
    } while (al != 0x79);
    eax = 1;
    goto label_1;
label_0:
    eax = 0;
label_1:
    edx = *((ebp - 0xc));
    edx ^= *(gs:0x14);
    if (al != 0x79) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8058a78 */
#include <stdint.h>
 
int32_t dbg_calculate_cmd (int32_t arg_8h, long int l, int32_t k, long int iterations) {
    int32_t var_10d4h;
    token_type * source;
    int32_t var_10cch;
    int32_t value_entered;
    int32_t var_10c4h;
    long int counter_max;
    int32_t i;
    int32_t factor_flag;
    long int counter;
    int32_t var_10b0h;
    char * cp;
    int32_t diff_sign;
    long int it_v;
    char[4096] buf;
    sign_array_type sa_value;
    sign_array_type sa_mark;
    int32_t var_1ch;
    char * s2;
    size_t * n;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = l;
    edx = k;
    edi = iterations;
    /* int calculate_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x10ac)) = eax;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    *((ebp - 0x10a0)) = 0;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_3;
    }
    *((ebp - 0x10b8)) = 0;
    do {
        *((esp + 4)) = 0x8072c49;
        eax = *((ebp - 0x10ac));
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            *((ebp - 0x10b8)) = 1;
        } else {
            *((esp + 4)) = "repeat";
            eax = *((ebp - 0x10ac));
            eax = strcmp_tospace (eax);
            if (eax != 0) {
                goto label_4;
            }
            *(obj.repeat_flag) = 1;
        }
        eax = *((ebp - 0x10ac));
        eax = skip_param (eax);
        *((ebp - 0x10ac)) = eax;
    } while (1);
label_4:
    edx = cur_equation;
    *((ebp - 0x10bc)) = edx;
    ebx = *((edx*4 + obj.n_rhs));
    *((ebp - 0x10c4)) = ebx;
    if (ebx != 0) {
        edi = *((edx*4 + obj.rhs));
        *((ebp - 0x10d0)) = edi;
    } else {
        eax = *((ebp - 0x10bc));
        eax = *((eax*4 + obj.lhs));
        *((ebp - 0x10d0)) = eax;
        edx = *((ebp - 0x10bc));
        edx = *((edx*4 + obj.n_lhs));
        *((ebp - 0x10c4)) = edx;
    }
    eax = *((ebp - 0x10ac));
    *((ebp - 0x10cc)) = 1;
    if (*(eax) != 0) {
        eax = ebp - 0x10a0;
        eax = parse_var2 (eax, eax);
        *((ebp - 0x10ac)) = eax;
        if (eax == 0) {
            goto label_3;
        }
        eax = *((ebp - 0x10a0));
        ebx = *((ebp - 0x10c4));
        edi = *((ebp - 0x10d0));
        eax = found_var (edi, ebx, eax);
        if (eax == 0) {
            *(esp) = "Specified iteration variable not found.";
            error ();
            eax = 0;
            goto label_5;
        }
        eax = *((ebp - 0x10ac));
        if (*(eax) == 0) {
            *((esp + 8)) = 0x50;
            my_strlcpy (obj.prompt_str, "Enter number of iterations: ");
            eax = ebp - 0x109c;
            eax = get_string (eax, 0x1000);
            *((ebp - 0x10ac)) = eax;
            if (eax == 0) {
                goto label_3;
            }
        }
        eax = ebp - 0x10ac;
        eax = *((ebp - 0x10ac));
        eax = decstrtol (eax, eax);
        *((ebp - 0x10cc)) = eax;
        eax = *((ebp - 0x10ac));
        if (*(eax) == 0) {
            if (*((ebp - 0x10cc)) >= 0) {
                goto label_6;
            }
        }
        *(esp) = "Positive integer required.";
        error ();
        eax = 0;
        goto label_5;
label_6:
        if (*((ebp - 0x10cc)) != 0) {
            goto label_7;
        }
        warning ("Infinite iterations.");
        *((ebp - 0x10cc)) = 0x7ffffffe;
    }
label_7:
    eax = *((ebp - 0x10c4));
    eax <<= 4;
    *((ebp - 0x10d4)) = eax;
    esi = ebp - 0x5c;
label_2:
    edx = *((ebp - 0x10c4));
    *(obj.n_trhs) = edx;
    ebx = *((ebp - 0x10d4));
    edi = *((ebp - 0x10d0));
    eax = trhs;
    memmove (eax, edi, ebx);
    if (*((ebp - 0x10c4)) <= 0) {
        *((ebp - 0x10c8)) = 0;
        goto label_8;
    }
    *((ebp - 0x10c8)) = 0;
    edi = 0;
    eax = *((ebp - 0x10d0));
    *((ebp - 0x10b4)) = eax;
    *((ebp - 0x10b0)) = edi;
    edi = *((ebp - 0x10c4));
    goto label_9;
label_0:
    *((ebp - 0x10b0)) = ebx;
label_9:
    eax = *((ebp - 0x10b4));
    ecx = 0xffffffff;
    edx = 0;
    do {
        if (*(eax) == 1) {
            ebx = *((eax + 8));
            if (*((ebp - 0x10b0)) < ebx) {
                if (ecx == -1) {
                    goto label_10;
                }
                if (ebx > ecx) {
                    ebx = ecx;
                }
            }
        } else {
            ebx = ecx;
        }
label_10:
        edx += 2;
        eax += 0x20;
        if (edi <= edx) {
            goto label_11;
        }
        ecx = ebx;
    } while (1);
label_11:
    *((ebp - 0x10b0)) = ebx;
    if (ebx == -1) {
label_8:
        eax = 0;
        if (*(obj.n_trhs) > 0) {
            goto label_12;
        }
        goto label_13;
    }
    eax = *((ebp - 0x10b0));
    eax &= 0x3fff;
    if (eax <= 4) {
        goto label_0;
    }
    edx = *((ebp - 0x10b0));
    if (edx == *((ebp - 0x10a0))) {
        goto label_0;
    }
    list_var (edx, 0);
    *((esp + 0x14)) = 0x8079800;
    *((esp + 0x10)) = "Enter %s: ";
    *((esp + 0xc)) = 0x50;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x50;
    *(esp) = obj.prompt_str;
    snprintf_chk ();
    eax = tlhs;
    eax = get_expr (eax, 0x80796b8);
    if (eax == 0) {
        goto label_0;
    }
    edx = n_tlhs;
    if (edx <= 0) {
        goto label_14;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        if (*(edx) == 1) {
            edx + 8 = -edx + 8;
        }
        eax += 2;
        edx = n_tlhs;
    } while (edx > eax);
label_14:
    eax = *((ebp - 0x10b0));
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = edx;
    eax = tlhs;
    *((esp + 8)) = eax;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    eax = subst_var_with_exp (eax);
    *((ebp - 0x10c8)) = 1;
    goto label_0;
    do {
label_12:
        edx = eax;
        edx <<= 4;
        edx += *(obj.trhs);
        if (*(edx) == 1) {
            ecx = *((edx + 8));
            if (ecx >= 0) {
                goto label_15;
            }
            ecx = -ecx;
            *((edx + 8)) = ecx;
        }
label_15:
        eax += 2;
    } while (*(obj.n_trhs) > eax);
label_13:
    eax = *((ebp - 0x10a0));
    if (eax == 0) {
        goto label_16;
    }
    list_var (eax, 0);
    *((esp + 0x14)) = 0x8079800;
    *((esp + 0x10)) = "Enter initial %s: ";
    *((esp + 0xc)) = 0x50;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x50;
    *(esp) = obj.prompt_str;
    snprintf_chk ();
    eax = tes;
    eax = get_expr (eax, 0x80795f4);
    if (eax == 0) {
        eax = repeat_flag;
        goto label_5;
    }
    *((esp + 4)) = obj.n_tes;
    eax = tes;
    *(esp) = eax;
    calc_simp ();
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = tlhs;
    memmove (eax, eax, eax);
    eax = n_trhs;
    *(obj.n_tlhs) = eax;
    if (*((ebp - 0x10cc)) <= 0) {
        goto label_17;
    }
    ebx = 0;
    edi = *((ebp - 0x10cc));
    do {
        eax = n_tlhs;
        eax <<= 4;
        eax = tlhs;
        eax = trhs;
        memmove (eax, eax, eax);
        eax = n_tlhs;
        *(obj.n_trhs) = eax;
        eax = *((ebp - 0x10a0));
        *((esp + 0x10)) = eax;
        eax = n_tes;
        *((esp + 0xc)) = eax;
        eax = tes;
        *((esp + 8)) = eax;
        *((esp + 4)) = 0x80798b4;
        eax = trhs;
        subst_var_with_exp (eax);
        *((esp + 4)) = 0x80798b4;
        eax = trhs;
        *(esp) = eax;
        calc_simp ();
        edx = ebp - 0x10a4;
        *((esp + 0x10)) = edx;
        eax = n_tes;
        *((esp + 0xc)) = eax;
        eax = tes;
        *((esp + 8)) = eax;
        eax = n_trhs;
        *((esp + 4)) = eax;
        eax = trhs;
        *(esp) = eax;
        eax = se_compare ();
        if (eax != 0) {
            if (*((ebp - 0x10a4)) != 0) {
                goto label_18;
            }
            ebx++;
            *((esp + 0xc)) = ebx;
            *((esp + 8)) = "Convergence reached after %ld iterations.\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            *((ebp - 0x10c8)) = 1;
            goto label_16;
        }
label_18:
        eax = n_trhs;
        eax <<= 4;
        eax = trhs;
        eax = tes;
        memmove (eax, eax, eax);
        eax = n_trhs;
        *(obj.n_tes) = eax;
        ebx++;
    } while (ebx < edi);
label_17:
    *((ebp - 0x10c8)) = 1;
label_16:
    *((esp + 4)) = obj.n_trhs;
    eax = trhs;
    *(esp) = eax;
    calc_simp ();
    ecx = 0x10;
    eax = 0;
    edi = esi;
    memset (edi, eax, ecx);
    ecx = n_trhs;
    if (ecx <= 0) {
        goto label_19;
    }
    eax = trhs;
    edx = 0;
    do {
        if (*(eax) == 1) {
            ebx = *((eax + 8));
            edi = *((eax + 8));
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_20;
            }
            ebx >>= 0xe;
            ebx &= 0x3f;
            *((ebp + ebx - 0x5c)) = 1;
        }
label_20:
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
label_19:
    ecx = 0;
    eax = 0;
    do {
        ecx -= 0xffffffff;
        eax++;
    } while (eax != 0x40);
    al = 1;
    eax <<= cl;
    ecx = eax;
    eax--;
    *((ebp - 0x10c0)) = eax;
    if (eax == 0) {
        goto label_21;
    }
    *((esp + 0xc)) = ecx;
    *((esp + 8)) = "There are %ld solutions.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    if (*((ebp - 0x10c0)) >= 0) {
        goto label_22;
    }
    goto label_23;
label_1:
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = tlhs;
    memmove (eax, eax, eax);
    edi = n_trhs;
    *(obj.n_tlhs) = edi;
    ecx = 0;
    eax = 0;
    *((ebp - 0x10b0)) = edi;
    do {
        if (*((esi + eax)) != 0) {
            edi = *((ebp - 0x10b4));
            edi >>= cl;
            edi &= 1;
            ebx = edi;
            *((ebp + eax - 0x9c)) = bl;
            ecx++;
        }
        eax++;
    } while (eax != 0x40);
    edi = *((ebp - 0x10b0));
    if (edi <= 0) {
        goto label_24;
    }
    al = 0;
    *(fp_stack--) = 1.0;
    do {
        ecx = eax;
        ecx <<= 4;
        edx = ecx;
        edx += *(obj.tlhs);
        if (*(edx) == 1) {
            ebx = *((edx + 8));
            edi = *((edx + 8));
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_25;
            }
            ebx >>= 0xe;
            ebx &= 0x3f;
            if (*((ebp + ebx - 0x9c)) != 0) {
                *(edx) = 0;
                edx = tlhs;
                *(fp_stack--) = 1.0;
                fp_stack[0] = -fp_stack[0];
                *((ecx + edx + 8)) = fp_stack[0];
                fp_stack--;
            } else {
                *(edx) = 0;
                edx = tlhs;
                *((edx + ecx + 8)) = fp_stack[0];
            }
        }
label_25:
        eax += 2;
    } while (*(obj.n_tlhs) > eax);
    fp_stack++;
label_24:
    eax = 0;
    ebx = 0;
    edx = *((ebp - 0x10b4));
    edx++;
    *((ebp - 0x10b0)) = edx;
    do {
        edi = ebx;
        if (*((esi + ebx)) != 0) {
            if (eax != 0) {
                *((esp + 8)) = 0x8075f0e;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            } else {
                eax = *((ebp - 0x10b0));
                *((esp + 0xc)) = eax;
                *((esp + 8)) = "Solution number %ld with ";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            eax = ebx;
            eax <<= 0xe;
            eax += 4;
            list_var (eax, 0);
            *((esp + 0xc)) = 0x8079800;
            *((esp + 8)) = "%s = ";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            if (*((ebp + edi - 0x9c)) != 0) {
                *((esp + 8)) = 0x8075f2b;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                eax = 1;
            } else {
                *((esp + 8)) = 0x8075f2c;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                eax = 1;
            }
        }
        ebx++;
    } while (ebx != 0x40);
    if (eax != 0) {
        *((esp + 8)) = 0x8072669;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 4)) = obj.n_tlhs;
    eax = tlhs;
    *(esp) = eax;
    calc_simp ();
    if (*((ebp - 0x10b8)) != 0) {
        *((esp + 4)) = obj.n_tlhs;
        eax = tlhs;
        *(esp) = eax;
        simp_side ();
    }
    *((esp + 8)) = 0x8077a28;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    edx = *((ebp - 0x10bc));
    if (*((edx*4 + obj.n_rhs)) != 0) {
        *((esp + 8)) = 0;
        eax = *((edx*4 + obj.n_lhs));
        *((esp + 4)) = eax;
        eax = *((edx*4 + obj.lhs));
        *(esp) = eax;
        list_proc ();
        *((esp + 8)) = 0x80759cf;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    ebx = *((ebp - 0x10b8));
    *((esp + 8)) = ebx;
    eax = tlhs;
    list_factor (eax, 0x80796b8);
    if (*(obj.n_tlhs) <= 9) {
        *((esp + 4)) = obj.n_tlhs;
        eax = tlhs;
        eax = make_fractions (eax);
        if (eax == 0) {
            goto label_26;
        }
        *((esp + 4)) = obj.n_tlhs;
        eax = tlhs;
        *(esp) = eax;
        group_proc ();
        *((esp + 8)) = 0x80759cf;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 8)) = ebx;
        eax = tlhs;
        list_factor (eax, 0x80796b8);
    }
label_26:
    *((esp + 8)) = 0x80757fc;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((ebp - 0x10b4))++;
    edi = *((ebp - 0x10b4));
    if (*((ebp - 0x10c0)) >= edi) {
        goto label_1;
    }
label_23:
    if (*((ebp - 0x10c8)) == 0) {
        goto label_27;
    }
    if (*(obj.repeat_flag) != 0) {
        goto label_2;
    }
    goto label_27;
label_3:
    eax = 0;
    goto label_5;
label_27:
    eax = 1;
label_5:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*(obj.repeat_flag) != 0) {
        goto label_28;
label_21:
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
label_22:
        *((ebp - 0x10b4)) = 0;
        goto label_1;
label_28:
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806a31a */
#include <stdint.h>
 
uint32_t dbg_derivative_cmd (int * nps, token_type * dest, token_type * source, int32_t len) {
    int * np;
    int32_t solved;
    int32_t i;
    int32_t simplify_flag;
    int32_t var_2ch;
    int32_t n1;
    long int v;
    char * cp;
    char * s2;
    size_t n;
    int32_t var_ch;
    ebx = nps;
    esi = dest;
    edi = source;
    eax = len;
    /* int derivative_cmd(char * cp); */
    *((ebp - 0x1c)) = 0;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_0;
    }
    eax = cur_equation;
    eax = solved_equation (eax);
    *((ebp - 0x38)) = eax;
    *((esp + 4)) = "nosimplify";
    eax = *((ebp + 8));
    eax = strcmp_tospace (eax);
    *((ebp - 0x30)) = 1;
    if (eax == 0) {
        eax = *((ebp + 8));
        eax = skip_param (eax);
        *((ebp + 8)) = eax;
        *((ebp - 0x30)) = 0;
    }
    eax = next_espace ();
    *((ebp - 0x34)) = eax;
    edx = cur_equation;
    if (*((edx*4 + obj.n_rhs)) != 0) {
        if (*((ebp - 0x38)) == 0) {
            warning ("Not a solved equation.  Only the RHS will be differentiated.");
        }
        edx = cur_equation;
        eax = rhs;
        edi = *((eax + edx*4));
        ebx = edx*4 + obj_n_rhs;
        edx = *((ebp - 0x34));
        esi = *((eax + edx*4));
        ecx = edx*4 + obj_n_rhs;
        *((ebp - 0x3c)) = ecx;
    } else {
        eax = lhs;
        edi = *((eax + edx*4));
        ebx = edx*4 + obj_n_lhs;
        edx = *((ebp - 0x34));
        esi = *((eax + edx*4));
        ecx = edx*4 + obj_n_lhs;
        *((ebp - 0x3c)) = ecx;
    }
    eax = *((ebp + 8));
    if (*(eax) != 0) {
        *(esp) = eax;
        eax = is_all ();
        if (eax != 0) {
            eax = *((ebp + 8));
            eax = skip_param (eax);
            *((ebp + 8)) = eax;
            *((ebp - 0x1c)) = 5;
        } else {
            eax = *((ebp + 8));
            eax = *(eax);
            eax = isvarchar (eax);
            if (eax == 0) {
                goto label_1;
            }
            eax = *((ebp + 8));
            eax = ebp - 0x1c;
            eax = parse_var2 (eax, eax);
            *((ebp + 8)) = eax;
            if (eax == 0) {
                goto label_0;
            }
        }
label_1:
        eax = *((ebp + 8));
        if (*(eax) == 0) {
            goto label_2;
        }
        edx = ebp + 8;
        eax = decstrtol (eax, edx);
        *((ebp - 0x2c)) = eax;
        eax = *((ebp + 8));
        if (*(eax) == 0) {
            if (*((ebp - 0x2c)) > 0) {
                goto label_3;
            }
        }
        *(esp) = "The order must be a positive integer.";
        error ();
        eax = 0;
        goto label_4;
    }
label_2:
    *((ebp - 0x2c)) = 1;
label_3:
    eax = ebp - 0x1c;
    *((esp + 8)) = eax;
    eax = *(ebx);
    eax = no_vars (edi, eax);
    if (eax != 0) {
        *(esp) = "Current expression contains no variables; the derivative would be zero.";
        error ();
        eax = 0;
        goto label_4;
    }
    if (*((ebp - 0x1c)) == 0) {
        eax = ebp - 0x1c;
        eax = prompt_var (eax);
        if (eax == 0) {
            goto label_0;
        }
    }
    eax = *((ebp - 0x1c));
    if (eax != 5) {
        eax = *(ebx);
        eax = found_var (edi, eax, eax);
        if (eax != 0) {
            goto label_5;
        }
        *(esp) = "Variable not found; the derivative would be zero.";
        error ();
        eax = 0;
        goto label_4;
    }
label_5:
    if (*(obj.debug_level) >= 0) {
        eax = *((ebp - 0x1c));
        list_var (eax, 0);
        eax = cur_equation;
        if (*((eax*4 + obj.n_rhs)) != 0) {
            *((esp + 8)) = obj.var_str;
            *((esp + 4)) = "Differentiating the RHS with respect to (%s)";
            *(esp) = 1;
            printf_chk ();
        } else {
            *((esp + 8)) = obj.var_str;
            *((esp + 4)) = "Differentiating with respect to (%s)";
            *(esp) = 1;
            printf_chk ();
        }
        if (*((ebp - 0x2c)) != 1) {
            ecx = *((ebp - 0x2c));
            *((esp + 8)) = ecx;
            *((esp + 4)) = " %ld times";
            *(esp) = 1;
            printf_chk ();
        }
        if (*((ebp - 0x30)) != 0) {
            *((esp + 4)) = " and simplifying...\n";
            *(esp) = 1;
            printf_chk ();
        } else {
            *((esp + 4)) = 0x8075a4c;
            *(esp) = 1;
            printf_chk ();
        }
    }
    eax = *(ebx);
    eax <<= 4;
    memmove (esi, edi, eax);
    eax = *(ebx);
    *((ebp - 0x20)) = eax;
    if (*((ebp - 0x2c)) <= 0) {
        goto label_6;
    }
    ebx = 0;
    edi = ebp - 0x20;
    do {
        eax = *((ebp - 0x1c));
        *((esp + 8)) = eax;
        eax = differentiate (esi, edi);
        if (eax == 0) {
            *(esp) = "Differentiation failed.";
            error ();
            eax = 0;
            goto label_4;
        }
        if (*((ebp - 0x30)) != 0) {
            *((esp + 0xc)) = 0;
            *((esp + 8)) = 1;
            simpa_side (esi, edi);
        } else {
            elim_loop (esi, edi);
        }
        ebx++;
    } while (*((ebp - 0x2c)) > ebx);
label_6:
    eax = *((ebp - 0x20));
    edx = *((ebp - 0x3c));
    *(edx) = eax;
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) == 0) {
        goto label_7;
    }
    ebx = n_lhs;
    edx = *((ebx + eax*4));
    edx <<= 4;
    edx = lhs;
    eax = *((edx + eax*4));
    ecx = *((ebp - 0x34));
    eax = *((edx + ecx*4));
    memmove (eax, eax, edx);
    eax = cur_equation;
    eax = *((ebx + eax*4));
    edx = *((ebp - 0x34));
    *((ebx + edx*4)) = eax;
    if (*((ebp - 0x38)) == 0) {
        goto label_7;
    }
    eax = isvarchar (0x27);
    if (eax == 0) {
        goto label_7;
    }
    ecx = *((ebp - 0x34));
    eax = *((ecx*4 + obj.lhs));
    eax = *((eax + 8));
    eax = list_var (eax, 0);
    if (*((ebp - 0x2c)) <= 0) {
        goto label_8;
    }
    if (eax > 0x62) {
        goto label_8;
    }
    ecx = eax + obj_var_str;
    edx = 0;
    ebx = *((ebp - 0x2c));
    do {
        *(ecx) = 0x27;
        eax++;
        edx++;
        ecx++;
        if (ebx <= edx) {
            goto label_8;
        }
    } while (eax <= 0x62);
label_8:
    *((eax + obj.var_str)) = 0;
    *((esp + 4)) = 0x8079800;
    edx = *((ebp - 0x34));
    eax = *((edx*4 + obj.lhs));
    eax += 8;
    parse_var (eax);
label_7:
    ecx = *((ebp - 0x34));
    *(obj.cur_equation) = ecx;
    return_result (ecx);
    goto label_4;
label_0:
    eax = 0;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a5e5 */
#include <stdint.h>
 
int32_t dbg_free_result_str (void) {
    /* void free_result_str(); */
    eax = result_str;
    if (eax != 0) {
        free (eax);
        *(obj.result_str) = 0;
    }
    *(obj.result_en) = 0xffffffff;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049034 */
#include <stdint.h>
 
void free (void) {
    free ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d830 */
#include <stdint.h>
 
int32_t dbg_complex_fixup (int32_t arg_8h, complexs * ap) {
    ecx = ap;
    /* int complex_fixup(complexs * ap); */
    edx = *((ebp + 8));
    *(fp_stack--) = *(edx);
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = fp_stack[1];
    fp_stack[0] *= *(0x8077988);
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = fp_stack[1];
    fp_stack[0] = abs(fp_stack[0]);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        fp_stack++;
        fp_stack++;
        *(fp_stack--) = 0.0;
        *((edx + 8)) = fp_stack[0];
        fp_stack--;
        eax = 1;
    } else {
        fp_stack[0] *= *(0x8077988);
        fp_stack[0] = abs(fp_stack[0]);
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        fp_stack[0] = abs(fp_stack[0]);
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        eax = 0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_0;
        }
        *(fp_stack--) = 0.0;
        *(edx) = fp_stack[0];
        fp_stack--;
        al = 1;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8053768 */
#include <stdint.h>
 
uint32_t dbg_save_cmd (int32_t arg_8h, int32_t rv, char * cp, FILE * fp) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * mode;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = rv;
    esi = cp;
    edi = fp;
    /* int save_cmd(char * cp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    if (*(obj.security_level) > 1) {
        *(esp) = "Command disabled.";
        error ();
        ebx = 0;
    } else {
        clean_up ();
        if (*(esi) == 0) {
            *(esp) = "No file name specified.";
            error ();
            ebx = 0;
        } else {
            eax = access (esi, 0);
            if (eax == 0) {
                eax = access (esi, 2);
                if (eax != 0) {
                    *(esp) = "Specified save file is not writable.";
                    error ();
                    ebx = 0;
                } else {
                    *((esp + 0x14)) = esi;
                }
                *((esp + 0x10)) = "File \"%s\" exists, overwrite (y/n)? ";
                *((esp + 0xc)) = 0x50;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x50;
                *(esp) = obj.prompt_str;
                snprintf_chk ();
                eax = get_yes_no ();
                if (eax == 0) {
                    *((esp + 4)) = "Command aborted.\n";
                    *(esp) = 1;
                    printf_chk ();
                    ebx = 0;
                }
            } else {
                eax = fopen (esi, 0x80779f1);
                edi = eax;
                if (eax == 0) {
                    *(esp) = "Can't create specified save file.";
                    eax = error ();
                    ebx = 0;
                } else {
                    *(obj.gfp) = eax;
                    *(obj.high_prec) = 1;
                    *(esp) = 0x807207b;
                    eax = list_cmd ();
                    ebx = eax;
                    *(obj.high_prec) = 0;
                    eax = default_out;
                    *(obj.gfp) = eax;
                    eax = fclose (edi);
                    if (eax == 0) {
                        if (ebx != 0) {
                            *((esp + 8)) = esi;
                            *((esp + 4)) = "All equations saved in file \"%s\".\n";
                            *(esp) = 1;
                            printf_chk ();
                        }
                    } else {
                        *(esp) = "Error encountered while saving equations.";
                        error ();
                        ebx = 0;
                    }
                }
            }
        }
    }
    eax = 0;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80525b0 */
#include <stdint.h>
 
int32_t dbg_version_report (void) {
    int32_t var_4h;
    char * var_8h;
    char * var_ch;
    /* int version_report(); */
    *((esp + 0xc)) = "15.1.1";
    *((esp + 8)) = "Mathomatic version %s\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "Compile-time defines used: ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "UNIX ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "READLINE ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = n_tokens;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "\n\nThe current expression array size is %d tokens,\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    eax = fprintf_chk ();
    eax = *(obj.n_tokens) * 0xce0;
    edx = 0x10624dd3;
    edx:eax = eax * edx;
    edx >>= 6;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = "making the maximum memory usage %ld kilobytes.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = security_level;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "The current security level is %d.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806de45 */
#include <stdint.h>
 
int32_t dbg_list_code (uint32_t arg_14h, int32_t cur_level, int32_t len, char * cp) {
    uint32_t var_25ch;
    int32_t min1;
    int32_t var_254h;
    int32_t var_250h;
    int32_t var_24ch;
    int32_t var_248h;
    int32_t var_244h;
    int32_t i;
    int32_t var_23ch;
    int32_t var_238h;
    int32_t var_234h;
    int32_t var_230h;
    int32_t k;
    int32_t var_228h;
    int32_t i1;
    int32_t var_220h;
    int32_t var_21ch;
    char[500] buf;
    int32_t canary;
    token_type * equation;
    int * np;
    language_list language;
    uint32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = cur_level;
    esi = len;
    eax = cp;
    /* int list_code(token_type * equation,int * np,language_list language,int int_flag); */
    eax = *((ebp + 8));
    *((ebp - 0x254)) = eax;
    edx = *((ebp + 0xc));
    *((ebp - 0x23c)) = edx;
    ecx = *(gs:0x14);
    *((ebp - 0x1c)) = ecx;
    ecx = 0;
    eax = *(edx);
    *((esp + 4)) = eax;
    ebx = *((ebp - 0x254));
    eax = min_level (ebx);
    *((ebp - 0x258)) = eax;
    eax = *((ebp - 0x23c));
    edx = *(eax);
    al = (edx >= 2) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x258)) -= eax;
    *((ebp - 0x228)) = 0;
    if (edx <= 0) {
        goto label_3;
    }
    edx = *((ebp - 0x258));
    *((ebp - 0x220)) = edx;
    *((ebp - 0x240)) = 0;
    ecx = *((ebp + 0x10));
    ecx--;
    *((ebp - 0x25c)) = ecx;
label_2:
    eax = *((ebp - 0x240));
    eax <<= 4;
    eax += *((ebp - 0x254));
    *((ebp - 0x250)) = eax;
    ebx = *((ebp - 0x220));
    ebx -= *((eax + 4));
    *((ebp - 0x230)) = ebx;
    eax = ebx;
    eax >>= 0x1f;
    ebx ^= eax;
    ebx -= eax;
    *((ebp - 0x22c)) = ebx;
    if (ebx <= 0) {
        goto label_4;
    }
    eax = *((ebp - 0x240));
    eax++;
    *((ebp - 0x238)) = eax;
    *((ebp - 0x244)) = eax;
    eax <<= 4;
    eax += *((ebp - 0x254));
    *((ebp - 0x234)) = eax;
    *((ebp - 0x224)) = 1;
    eax = *((ebp - 0x240));
    eax <<= 4;
    edx = *((ebp - 0x254));
    eax = eax + edx + 0x30;
    *((ebp - 0x248)) = eax;
    ecx = *((ebp - 0x238));
    *((ebp - 0x24c)) = ecx;
label_1:
    if (*((ebp - 0x230)) > 0) {
        *((ebp - 0x220))--;
        *((esp + 8)) = 0x80779a8;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        eax = fprintf_chk ();
        *((ebp - 0x228)) += eax;
        goto label_5;
    }
    *((ebp - 0x220))++;
    eax = *((ebp - 0x23c));
    ebx = *(eax);
    if (*((ebp - 0x238)) >= ebx) {
        goto label_6;
    }
    edx = *((ebp - 0x234));
    eax = *((edx + 4));
    if (*((ebp - 0x220)) > eax) {
        goto label_6;
    }
    esi = edx;
    edi = *((ebp - 0x244));
    if (*((ebp - 0x220)) != eax) {
        goto label_7;
    }
    goto label_8;
label_0:
    edx += 0x20;
    if (ebx != ecx) {
        goto label_9;
    }
label_8:
    eax = *((esi + 8));
    if (eax != 6) {
        if (eax != 7) {
            goto label_6;
        }
        goto label_10;
    }
    eax = edi;
    eax <<= 4;
    ecx = *((ebp - 0x254));
    edx = eax + ecx - 0x10;
    ecx = *((edx + 4));
    if (ecx != *((ebp - 0x220))) {
        goto label_11;
    }
    ebx = *((ebp - 0x254));
    eax = eax + ebx + 0x10;
    if (ecx != *((eax + 4))) {
        goto label_11;
    }
    if (*(eax) != 0) {
        goto label_11;
    }
    *(fp_stack--) = *((eax + 8));
    *(fp_stack--) = *(0x8072058);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_11;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_11;
    }
    *((esi + 8)) = 3;
    edi = eax;
    esi = edx;
    ecx = 4;
    do {
        *(es:edi) = *(esi);
        ecx--;
        esi += 4;
        es:edi += 4;
    } while (ecx != 0);
    goto label_6;
label_11:
    if (*((ebp + 0x14)) != 0) {
        goto label_6;
    }
    if (*((ebp + 0x10)) != 1) {
        if (*((ebp + 0x10)) != 2) {
            goto label_6;
        }
    } else {
        *((esp + 8)) = 0x80779ef;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        eax = fprintf_chk ();
        *((ebp - 0x228)) += eax;
        goto label_6;
    }
    *((esp + 8)) = "Math.pow";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    eax = fprintf_chk ();
    *((ebp - 0x228)) += eax;
    goto label_6;
label_10:
    *((esp + 8)) = "fact";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    eax = fprintf_chk ();
    *((ebp - 0x228)) += eax;
    goto label_6;
label_7:
    edx = *((ebp - 0x248));
    eax = *((ebp - 0x24c));
    *((ebp - 0x21c)) = ebx;
    ebx = *((ebp - 0x220));
label_9:
    eax += 2;
    if (*((ebp - 0x21c)) <= eax) {
        goto label_6;
    }
    edi = eax;
    esi = edx;
    ecx = *((edx + 4));
    if (ebx <= ecx) {
        goto label_0;
    }
label_6:
    *((esp + 8)) = 0x8075ad6;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    eax = fprintf_chk ();
    *((ebp - 0x228)) += eax;
label_5:
    *((ebp - 0x224))++;
    eax = *((ebp - 0x224));
    if (*((ebp - 0x22c)) >= eax) {
        goto label_1;
    }
label_4:
    edx = *((ebp - 0x250));
    eax = *(edx);
    if (eax != 1) {
        if (eax >= 1) {
            if (eax != 2) {
                goto label_12;
            }
            ecx = *((ebp - 0x250));
            *(fp_stack--) = *((ecx + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
            fp_stack--;
            fp_stack++;
        } else {
        } else {
            if (fp_stack[0] == fp_stack[1]) {
                if (fp_stack[0] == fp_stack[1]) {
                    goto label_13;
                }
                *(fp_stack--) = 0.0;
                *((ecx + 8)) = fp_stack[0];
                fp_stack--;
            }
label_13:
            if (*((ebp + 0x14)) != 0) {
                eax = *((ebp - 0x250));
                *(fp_stack--) = *((eax + 8));
                *((esp + 0x14)) = fp_stack[0];
                fp_stack--;
                *((esp + 0x10)) = "%.0f";
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                edx = ebp - 0x210;
                *(esp) = edx;
                snprintf_chk ();
            } else {
                ecx = *((ebp - 0x250));
                *(fp_stack--) = *((ecx + 8));
                *((esp + 0x18)) = fp_stack[0];
                fp_stack--;
                *((esp + 0x14)) = 0xf;
                *((esp + 0x10)) = "%#.*g";
                *((esp + 0xc)) = 0x1f4;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1f4;
                ebx = ebp - 0x210;
                *(esp) = ebx;
                snprintf_chk ();
                eax = ebx;
                trim_zeros ();
            }
            eax = *((ebp - 0x250));
            *(fp_stack--) = *((eax + 8));
            *(fp_stack--) = 0.0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] > fp_stack[1]) {
                edx = ebp - 0x210;
                *((esp + 0xc)) = edx;
                *((esp + 8)) = "(%s)";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                eax = fprintf_chk ();
                *((ebp - 0x228)) += eax;
                goto label_12;
            }
            ecx = ebp - 0x210;
            *((esp + 0xc)) = ecx;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            *((ebp - 0x228)) += eax;
            if (*((ebp + 0x14)) != 0) {
                if (*((ebp - 0x25c)) > 1) {
                    goto label_14;
                }
                ebx = *((ebp - 0x250));
                if (*((ebx + 8)) != 3) {
                    goto label_14;
                }
                *((esp + 8)) = 0x8077a08;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                eax = fprintf_chk ();
                *((ebp - 0x228)) += eax;
                goto label_12;
            }
label_14:
            eax = *((ebp + 0x10));
            edx = *((ebp - 0x250));
            eax = *((edx + 8));
            list_var (eax, eax);
            *((esp + 0xc)) = 0x8079800;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            *((ebp - 0x228)) += eax;
            goto label_12;
        }
        ecx = *((ebp - 0x250));
        if (*((ecx + 8)) <= 9) {
            eax = *((ecx + 8));
            /* switch table (10 cases) at 0x8077b78 */
            eax = 0x8077a0b;
        } else {
            eax = "(unknown operator)";
            goto label_15;
            eax = 0x8077a22;
            goto label_15;
            eax = 0x8077a2b;
            goto label_15;
            eax = 0x8077a7f;
            goto label_15;
            eax = 0x8077a26;
            goto label_15;
            if (*((ebp + 0x14)) == 0) {
                eax = 0x8075f0e;
                if (*((ebp + 0x10)) != 3) {
                    goto label_15;
                }
            }
            eax = 0x8077a2a;
            goto label_15;
            *((ebp - 0x240))++;
            eax = 0x80757fe;
        }
label_15:
        *((esp + 0xc)) = eax;
        *((esp + 8)) = 0x8075e74;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        eax = fprintf_chk ();
        *((ebp - 0x228)) += eax;
    }
label_12:
    *((ebp - 0x240))++;
    eax = *((ebp - 0x240));
    ebx = *((ebp - 0x23c));
    if (*(ebx) > eax) {
        goto label_2;
    }
    ebx = *((ebp - 0x220));
    ebx -= *((ebp - 0x258));
    if (ebx <= 0) {
        goto label_3;
    }
    esi = *((ebp - 0x228));
    do {
        *((esp + 8)) = 0x80779a8;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        eax = fprintf_chk ();
        esi += eax;
        ebx--;
    } while (ebx > 0);
    *((ebp - 0x228)) = esi;
label_3:
    eax = *((ebp - 0x228));
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (ebx != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805cb7b */
#include <stdint.h>
 
int32_t dbg_combine_constants (void) {
    token_type * equation;
    int * np;
    int32_t iflag;
    size_t var_4h;
    /* int combine_constants(token_type * equation,int * np,int iflag); */
    eax = *((ebp + 0x10));
    *((esp + 4)) = eax;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    const_recurse (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804e68e */
#include <stdint.h>
 
int32_t dbg_solve_espace (int32_t arg_8h, int32_t want, int32_t rv) {
    int32_t have;
    char * var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = want;
    esi = rv;
    /* int solve_espace(int want,int have); */
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    edx = *((ebx*4 + obj.n_lhs));
    if (edx != 0) {
        if (*((ebx*4 + obj.n_rhs)) != 0) {
            *(esp) = "This program will only solve for a single variable or for zero.";
            error ();
            *((ebx*4 + obj.n_lhs)) = 0;
            *((ebx*4 + obj.n_rhs)) = 0;
            esi = 0;
            goto label_0;
        }
        ecx = eax*4;
        esi = ecx + obj_n_rhs;
        *((esp + 0x14)) = esi;
        esi = *((eax*4 + obj.rhs));
        *((esp + 0x10)) = esi;
        ecx += obj.n_lhs;
        *((esp + 0xc)) = ecx;
        ecx = lhs;
        eax = *((ecx + eax*4));
        *((esp + 8)) = eax;
        *((esp + 4)) = edx;
        eax = *((ecx + ebx*4));
        *(esp) = eax;
        eax = solve_sub ();
        esi = eax;
    } else {
        edx = eax*4;
        ecx = edx + obj_n_lhs;
        *((esp + 0x14)) = ecx;
        ecx = *((eax*4 + obj.lhs));
        *((esp + 0x10)) = ecx;
        edx += obj.n_rhs;
        *((esp + 0xc)) = edx;
        edx = rhs;
        eax = *((edx + eax*4));
        *((esp + 8)) = eax;
        eax = *((ebx*4 + obj.n_rhs));
        *((esp + 4)) = eax;
        eax = *((edx + ebx*4));
        *(esp) = eax;
        eax = solve_sub ();
        esi = eax;
    }
    *((ebx*4 + obj.n_lhs)) = 0;
    *((ebx*4 + obj.n_rhs)) = 0;
    if (esi <= 0) {
label_0:
        *((esp + 4)) = "Solve failed.\n";
        *(esp) = 1;
        printf_chk ();
    }
    al = (esi > 0) ? 1 : 0;
    eax = (int32_t) al;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805a00b */
#include <stdint.h>
 
int32_t dbg_rationalize (int32_t end_loc, int32_t k1, int32_t k, int32_t j) {
    int32_t var_54h;
    int32_t var_50h;
    int32_t modified;
    int32_t var_48h;
    uint32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t flag;
    uint32_t var_34h;
    int32_t count;
    int32_t var_2ch;
    int32_t neg_one_loc;
    int32_t div_level;
    int32_t var_20h;
    int32_t i;
    token_type * equation;
    int * np;
    void * s2;
    size_t * n;
    int32_t var_ch;
    ebx = end_loc;
    esi = k1;
    edi = k;
    eax = j;
    /* int rationalize(token_type * equation,int * np); */
    *((ebp - 0x4c)) = 0;
    *((ebp - 0x1c)) = 1;
    *((ebp - 0x54)) = 1;
    goto label_2;
label_0:
    eax = *((ebp - 0x3c));
    *((ebp - 0x1c)) = eax;
label_2:
    edx = *((ebp + 0xc));
    esi = *(edx);
    if (*((ebp - 0x1c)) >= esi) {
        goto label_6;
    }
    ecx = *((ebp - 0x1c));
    *((ebp - 0x40)) = ecx;
    eax = ecx;
    eax <<= 4;
    eax += *((ebp + 8));
    if (*((eax + 8)) != 4) {
        goto label_7;
    }
    eax = *((eax + 4));
    *((ebp - 0x24)) = eax;
    ebx = ecx;
    ebx += 2;
    *((ebp - 0x3c)) = ebx;
    if (esi <= ebx) {
        goto label_7;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp + 8));
    eax = *((eax + edx + 4));
    if (*((ebp - 0x24)) >= eax) {
        goto label_7;
    }
    edx = ecx;
    edx <<= 4;
    ecx = *((ebp + 8));
    edx = ecx + edx + 0x44;
    *((ebp - 0x30)) = 0;
    *((ebp - 0x20)) = 0xffffffff;
    ecx = *((ebp - 0x24));
    ecx++;
    do {
        edi = ecx;
        if (eax == ecx) {
            *((ebp - 0x30))++;
            eax = *((ebp - 0x20));
            __asm ("cmovs eax, ebx");
            *((ebp - 0x20)) = eax;
        }
        ebx += 2;
        if (esi <= ebx) {
            goto label_8;
        }
        eax = *(edx);
        edx += 0x20;
    } while (*((ebp - 0x24)) < eax);
label_8:
    *((ebp - 0x48)) = edi;
    eax = *((ebp - 0x20));
    if (eax < 0) {
        goto label_7;
    }
    eax <<= 4;
    edx = *((ebp + 8));
    eax = *((eax + edx + 8));
    eax--;
    if (eax > 1) {
        goto label_7;
    }
    ecx = *((ebp - 0x1c));
    *((ebp - 0x2c)) = ecx;
    eax = *((ebp - 0x24));
    eax += 2;
    *((ebp - 0x28)) = eax;
    edx = *((ebp - 0x24));
    edx += 3;
    *((ebp - 0x34)) = edx;
    *((ebp - 0x44)) = ebx;
    goto label_9;
label_4:
    ecx = *((ebp - 0x20));
    *((ebp - 0x2c)) = ecx;
    *((ebp - 0x20)) = eax;
label_9:
    edi = *((ebp - 0x20));
    edi -= 2;
    if (*((ebp - 0x2c)) >= edi) {
        goto label_10;
    }
    ebx = edi;
    ebx <<= 4;
    ebx += *((ebp + 8));
    eax = *((ebp - 0x28));
    *((ebp - 0x50)) = eax;
    if (*((ebx + 4)) != eax) {
        goto label_11;
    }
    while (esi < edx) {
        ebx = eax;
        ecx = *((eax + 4));
        eax -= 0x20;
        if (ecx == edi) {
            edi = *((ebp - 0x38));
            eax = *((ebx + 8));
            if (eax < 3) {
                goto label_10;
            }
            edx = *((ebp - 0x54));
            *((ebp - 0x38)) = edx;
            if (eax <= 4) {
                goto label_12;
            }
            if (eax != 6) {
                goto label_10;
            }
            goto label_13;
label_11:
            eax = *((ebp - 0x20));
            eax <<= 4;
            ecx = *((ebp + 8));
            eax = eax + ecx - 0x40;
            edx = edi;
            *((ebp - 0x38)) = edi;
            esi = *((ebp - 0x2c));
            edi = *((ebp - 0x28));
        }
        edx -= 2;
    }
    goto label_10;
label_3:
    eax = *(ebx);
    if (eax != *((ebp - 0x28))) {
        if (eax != *((ebp - 0x34))) {
            goto label_14;
        }
        if (*((ebp - 0x38)) != 1) {
            goto label_14;
        }
    }
    if (*((ebx + 4)) != 6) {
        goto label_14;
    }
    if (eax != *(esi)) {
        goto label_14;
    }
    if (*((esi - 4)) != 0) {
        goto label_14;
    }
    *(fp_stack--) = *((esi + 4));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*((esi - 4)) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_15;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_16;
label_15:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_16:
    *(fp_stack--) = *(0x8072054);
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_14;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_14;
    }
    ebx = *((ebp - 0x44));
    if (*((ebp - 0x3c)) >= ebx) {
        goto label_17;
    }
    eax = *((ebp - 0x3c));
    eax <<= 4;
    edx = *((ebp + 8));
    esi = edx + eax + 8;
    eax = *((ebp - 0x40));
    eax <<= 4;
    eax = edx + eax + 0x34;
    ecx = *((ebp - 0x3c));
    *((ebp - 0x44)) = edi;
    *((ebp - 0x28)) = ebx;
    edi = eax;
    ebx = ecx;
label_1:
    if (*(esi) != 6) {
        goto label_18;
    }
    eax = *((esi - 4));
    if (eax != *(edi)) {
        goto label_18;
    }
    if (*((edi - 4)) != 0) {
        goto label_18;
    }
    *(fp_stack--) = *((edi + 4));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*((edi - 4)) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_19;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_20;
label_19:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_20:
    *(fp_stack--) = *(0x8072054);
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_18;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_18;
    }
    if (*((ebp - 0x44)) == ebx) {
        goto label_18;
    }
    eax = *((ebp - 0x50));
    if (eax != *((esi - 4))) {
        goto label_0;
    }
    if (*((ebp - 0x30)) != 1) {
        goto label_0;
    }
label_18:
    ebx += 2;
    esi += 0x20;
    edi += 0x20;
    if (*((ebp - 0x28)) > ebx) {
        goto label_1;
    }
    ebx = *((ebp - 0x28));
label_17:
    edx = *((ebp - 0x2c));
    edx++;
    *((ebp - 0x28)) = edx;
    edi = *((ebp - 0x2c));
    edi -= *((ebp - 0x1c));
    esi = edi;
    esi <<= 4;
    eax = *((ebp - 0x40));
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x10;
    eax = scratch;
    memmove (eax, eax, esi);
    eax = scratch;
    edx = *((ebp - 0x50));
    *((eax + esi + 4)) = edx;
    eax = scratch;
    *((eax + esi)) = 0;
    eax = scratch;
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((esi + eax + 8)) = fp_stack[0];
    fp_stack--;
    edx = edi + 1;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x50));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 3;
    eax = ebx;
    eax -= *((ebp - 0x28));
    eax <<= 4;
    eax = *((ebp - 0x28));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = edi + 2;
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    esi = *((ebp - 0x20));
    esi -= *((ebp - 0x28));
    if (esi <= 0) {
        goto label_21;
    }
    edx = edi + 2;
    edx <<= 4;
    eax = 0;
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (eax != esi);
label_21:
    eax = *((ebp - 0x1c));
    eax = ~eax;
    edi = ebx + eax + 2;
    eax = edi + edi + 2;
    *((ebp - 0x1c)) = eax;
    edx = *((ebp + 0xc));
    eax += *(edx);
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    esi = ebx;
    esi <<= 4;
    esi += *((ebp + 8));
    ecx = *((ebp + 0xc));
    eax = *(ecx);
    eax -= ebx;
    eax <<= 4;
    eax = *((ebp - 0x1c));
    eax += ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, esi, eax);
    edx = *((ebp - 0x1c));
    eax = *((ebp + 0xc));
    *(eax) += edx;
    ecx = *((ebp - 0x24));
    *((esi + 4)) = ecx;
    *(esi) = 2;
    *((esi + 8)) = 3;
    esi = ebx + 1;
    ebx = edi;
    ebx <<= 4;
    eax = scratch;
    eax = esi;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, ebx);
    esi += edi;
    eax = esi;
    eax <<= 4;
    eax += *((ebp + 8));
    edx = *((ebp - 0x24));
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 4;
    esi++;
    eax = scratch;
    eax = esi;
    eax <<= 4;
    eax += *((ebp + 8));
    memmove (eax, eax, ebx);
    edi = esi + edi;
    *((ebp - 0x1c)) = edi;
    *((ebp - 0x4c)) = 1;
    if (*(obj.debug_level) <= 0) {
        goto label_2;
    }
    *((esp + 0xc)) = 0x8076b50;
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((ebp - 0x4c)) = 1;
    goto label_2;
label_14:
    edi -= 2;
    ebx -= 0x20;
    esi -= 0x20;
    if (*((ebp - 0x2c)) < edi) {
        goto label_3;
    }
label_10:
    ecx = *((ebp - 0x44));
    if (*((ebp - 0x20)) >= ecx) {
        goto label_7;
    }
    eax = *((ebp - 0x20));
    eax += 2;
    if (ecx <= eax) {
        goto label_4;
    }
    edx = eax;
    edx <<= 4;
    ecx = *((ebp - 0x48));
    ebx = *((ebp + 8));
    if (ecx == *((edx + ebx + 4))) {
        goto label_4;
    }
    edx = *((ebp - 0x20));
    edx <<= 4;
    edx = ebx + edx + 0x44;
    ebx = *((ebp - 0x44));
    esi = ecx;
    goto label_22;
label_5:
    ecx = *(edx);
    edx += 0x20;
    if (esi == ecx) {
        goto label_4;
    }
label_22:
    eax += 2;
    if (ebx > eax) {
        goto label_5;
    }
    goto label_4;
label_7:
    *((ebp - 0x1c)) += 2;
    goto label_2;
label_6:
    eax = *((ebp - 0x4c));
    return eax;
label_13:
    *((ebp - 0x38)) = 2;
label_12:
    eax = edi;
    eax <<= 4;
    edx = *((ebp + 8));
    ebx = edx + eax + 4;
    eax = *((ebp - 0x20));
    eax <<= 4;
    esi = edx + eax - 0xc;
    goto label_3;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8063081 */
#include <stdint.h>
 
int32_t dbg_get_term (void ** arg_ch, int32_t n1, int32_t no, int32_t j, int32_t i) {
    int32_t var_14h;
    token_type * p1;
    int32_t count;
    int * tp1;
    int * lentp1;
    ebx = n1;
    edx = no;
    edi = j;
    eax = i;
    /* int get_term(token_type * p1,int n1,int count,int * tp1,int * lentp1); */
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    edx = *((ebp + 8));
    ecx = 0;
    edi = 0;
    eax = 1;
    *((ebp - 0x14)) = esi;
    do {
        if (eax < ebx) {
            if (*((edx + 0x14)) != 1) {
                goto label_0;
            }
            esi = *((edx + 0x18));
            esi--;
            if (esi > 1) {
                goto label_0;
            }
        }
        ecx++;
        if (ecx >= *((ebp - 0x14))) {
            edx = *((ebp + 0x14));
            *(edx) = edi;
            eax -= edi;
            edx = *((ebp + 0x18));
            *(edx) = eax;
            eax = 1;
            goto label_1;
        }
        if (eax >= ebx) {
            goto label_2;
        }
        edi = eax + 1;
label_0:
        eax += 2;
        edx += 0x20;
    } while (1);
label_2:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804aebc */
#include <stdint.h>
 
int32_t dbg_not_defined (int32_t arg_8h, int32_t i) {
    ecx = i;
    /* int not_defined(int i); */
    edx = *((ebp + 8));
    if (edx >= 0) {
        if (edx < *(obj.n_equations)) {
            goto label_0;
        }
    }
    *(esp) = "Invalid equation number.";
    error ();
    eax = 1;
    goto label_1;
label_0:
    eax = 0;
    if (*((edx*4 + obj.n_lhs)) <= 0) {
        *(esp) = "Equation space is empty.";
        error ();
        eax = 1;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806cdd7 */
#include <stdint.h>
 
int32_t dbg_complex_root_simp (int32_t level, int32_t i, int32_t j) {
    int32_t var_60h;
    int32_t modified;
    int32_t var_58h;
    int32_t len;
    int32_t var_50h;
    int32_t var_4ch;
    complexs r;
    complexs p;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    complexs c;
    int32_t var_24h;
    int32_t var_bp_20h;
    int32_t var_bp_1ch;
    int32_t var_ch;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    int32_t var_8h;
    int32_t var_sp_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    int32_t var_20h;
    ebx = level;
    esi = i;
    edi = j;
    /* int complex_root_simp(token_type * equation,int * np); */
    *((ebp - 0x5c)) = 0;
    eax = *((ebp + 8));
    eax += 0x20;
    *((ebp - 0x60)) = eax;
label_0:
    edx = *((ebp + 0xc));
    edi = *(edx);
    if (edi <= 1) {
        goto label_2;
    }
    esi = *((ebp - 0x60));
    *((ebp - 0x4c)) = 1;
label_1:
    if (*((esi - 8)) != 6) {
        goto label_3;
    }
    ebx = *((esi - 0xc));
    eax = *((ebp - 0x4c));
    *((ebp - 0x50)) = eax;
    eax += 2;
    if (edi <= eax) {
        goto label_4;
    }
    if (ebx > *((esi + 0x14))) {
        goto label_4;
    }
    edx = esi + 0x34;
    do {
        eax += 2;
        if (eax >= edi) {
            goto label_4;
        }
        ecx = *(edx);
        edx += 0x20;
    } while (ebx <= ecx);
label_4:
    edx = *((ebp - 0x4c));
    edx = ~edx;
    edx = eax + edx;
    *((ebp - 0x54)) = edx;
    edx = ebp - 0x38;
    *((esp + 8)) = edx;
    eax = *((ebp - 0x54));
    eax = parse_complex (esi, eax);
    if (eax == 0) {
        goto label_3;
    }
    edi = *((ebp - 0x50));
    edi--;
    if (edi < 0) {
        goto label_5;
    }
    if (ebx > *((esi - 0x1c))) {
        goto label_5;
    }
    eax = esi - 0x2c;
    do {
        edi--;
        if (edi < 0) {
            goto label_5;
        }
        edx = *(eax);
        eax -= 0x10;
    } while (ebx <= edx);
label_5:
    edi++;
    *((ebp - 0x58)) = edi;
    eax = edi;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x50)) = eax;
    edx = ebp - 0x28;
    *((esp + 8)) = edx;
    eax = *((ebp - 0x4c));
    eax -= edi;
    eax = *((ebp - 0x50));
    eax = parse_complex (eax, eax);
    if (eax != 0) {
        *(fp_stack--) = 0.0;
        *(fp_stack--) = *((ebp - 0x20));
        fp_stack--;
        if (fp_stack[0] == fp_stack[1]) {
            if (fp_stack[0] != fp_stack[1]) {
                *(fp_stack--) = *((ebp - 0x30));
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] == fp_stack[1]) {
                    goto label_6;
                }
                if (fp_stack[0] == fp_stack[1]) {
                    goto label_3;
                }
                fp_stack++;
            } else {
            } else {
                fp_stack++;
            }
        }
label_6:
        eax = *((ebp - 0x4c));
        edx = *((ebp - 0x54));
        esi = eax + edx + 1;
        eax = ebp - 0x48;
        edx = *((ebp - 0x38));
        *((esp + 0x14)) = edx;
        edx = *((ebp - 0x34));
        *((esp + 0x18)) = edx;
        edx = *((ebp - 0x30));
        edx = *((ebp - 0x2c));
        edx = *((ebp - 0x28));
        edx = *((ebp - 0x24));
        edx = *((ebp - 0x20));
        edx = *((ebp - 0x1c));
        complex_pow (edx, edx, edx);
        edx = edi;
        edx -= esi;
        *((ebp - 0x4c)) = edx;
        edx = *((ebp + 0xc));
        eax = *(edx);
        edx = *((ebp - 0x4c));
        eax = edx + eax + 5;
        if (eax > *(obj.n_tokens)) {
            error_huge ();
        }
        edx = *((ebp + 0xc));
        eax = *(edx);
        eax -= esi;
        eax <<= 4;
        eax = esi;
        eax <<= 4;
        eax += *((ebp + 8));
        eax = *((ebp - 0x58));
        eax <<= 4;
        edx = *((ebp + 8));
        eax = eax + edx + 0x50;
        memmove (eax, eax, eax);
        edx = *((ebp + 0xc));
        eax = *(edx);
        edx = *((ebp - 0x4c));
        eax = edx + eax + 5;
        edx = *((ebp + 0xc));
        *(edx) = eax;
        eax = *((ebp - 0x50));
        *((eax + 4)) = ebx;
        *(eax) = 0;
        *(fp_stack--) = *((ebp - 0x48));
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = edi;
        eax <<= 4;
        edx = *((ebp + 8));
        eax = eax + edx + 0x10;
        *((eax + 4)) = ebx;
        *(eax) = 2;
        *((eax + 8)) = 1;
        ebx++;
        eax = edi;
        eax <<= 4;
        eax = eax + edx + 0x20;
        *((eax + 4)) = ebx;
        *(eax) = 0;
        *(fp_stack--) = *((ebp - 0x40));
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        eax = edi;
        eax <<= 4;
        eax = eax + edx + 0x30;
        *((eax + 4)) = ebx;
        *(eax) = 2;
        *((eax + 8)) = 3;
        edi <<= 4;
        eax = edi + edx + 0x40;
        *((eax + 4)) = ebx;
        *(eax) = 1;
        *((eax + 8)) = 3;
        *((ebp - 0x5c)) = 1;
        goto label_0;
    }
label_3:
    *((ebp - 0x4c)) += 2;
    eax = *((ebp + 0xc));
    edi = *(eax);
    esi += 0x20;
    if (edi > *((ebp - 0x4c))) {
        goto label_1;
    }
label_2:
    if (*((ebp - 0x5c)) != 0) {
        warning ("Complex number roots approximated.");
    }
    eax = *((ebp - 0x5c));
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80560ae */
#include <stdint.h>
 
int32_t dbg_push_cmd (void) {
    int32_t j;
    int32_t i;
    char * cp;
    int32_t var_4h;
    int32_t var_8h;
    char * var_sp_ch;
    /* int push_cmd(char * cp); */
    if (*(obj.readline_enabled) == 0) {
        *(esp) = "Readline is currently turned off.";
        error ();
        eax = 0;
        goto label_0;
    }
    eax = ebp - 0x10;
    eax = ebp - 0xc;
    eax = ebp + 8;
    eax = get_range_eol (eax, eax, eax);
    edx = eax;
    eax = 0;
    if (edx == 0) {
        goto label_0;
    }
    eax = *((ebp - 0xc));
    if (eax > *((ebp - 0x10))) {
        goto label_1;
    }
    ebx = n_lhs;
    do {
        if (*((ebx + eax*4)) != 0) {
            eax = push_en (eax);
            if (eax != 0) {
                goto label_2;
            }
            *(esp) = "Push failed.";
            error ();
            eax = 0;
            goto label_0;
        }
label_2:
        eax = *((ebp - 0xc));
        eax++;
        *((ebp - 0xc)) = eax;
    } while (*((ebp - 0x10)) >= eax);
label_1:
    eax = 1;
    if (*(obj.debug_level) >= 0) {
        *((esp + 0xc)) = "Expression pushed.  Press the UP key to access.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 1;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805364d */
#include <stdint.h>
 
uint32_t dbg_list_cmd (char * cp1, int32_t export_flag) {
    int32_t j;
    int32_t i;
    char * cp;
    char * s2;
    size_t n;
    ebx = cp1;
    esi = export_flag;
    /* int list_cmd(char * cp); */
    ebx = *((ebp + 8));
    eax = strncasecmp (ebx, "gnuplot", 4);
    if (eax == 0) {
        eax = skip_param (ebx);
        *((ebp + 8)) = eax;
        esi = 3;
    } else {
        eax = strncasecmp (ebx, "export", 4);
        if (eax == 0) {
            eax = skip_param (ebx);
            *((ebp + 8)) = eax;
            esi = 2;
        } else {
            eax = strncasecmp (ebx, "maxima", 4);
            esi = 0;
            if (eax != 0) {
                goto label_1;
            }
            eax = skip_param (ebx);
            *((ebp + 8)) = eax;
            si = 1;
        }
    }
label_1:
    edi = ebp - 0x20;
label_0:
    ebx = *((ebp + 8));
    *((esp + 8)) = edi;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range (eax, eax);
    if (eax == 0) {
        goto label_2;
    }
    eax = *((ebp + 8));
    while (ebx != eax) {
        eax = *((ebp - 0x1c));
        ebx = n_lhs;
        if (eax <= *((ebp - 0x20))) {
            goto label_3;
        }
        goto label_4;
    }
    *(esp) = "Invalid argument.";
    error ();
    eax = 0;
    goto label_2;
    do {
label_3:
        if (*((ebx + eax*4)) > 0) {
            list1_sub (eax, esi);
        }
        eax = *((ebp - 0x1c));
        eax++;
        *((ebp - 0x1c)) = eax;
    } while (*((ebp - 0x20)) >= eax);
label_4:
    eax = *((ebp + 8));
    if (*(eax) != 0) {
        goto label_0;
    }
    eax = 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8063572 */
#include <stdint.h>
 
int32_t dbg_smart_div (int32_t skip_count, int32_t flag, int32_t term_size) {
    int32_t trhs_size;
    int32_t var_1fch;
    int32_t var_1f8h;
    int32_t var_1f4h;
    token_type * qp;
    int32_t count;
    int32_t var_1e8h;
    int32_t var_1e4h;
    int32_t var_1e0h;
    int32_t var_1dch;
    int32_t old_n_quotient;
    int32_t var_1d4h;
    int32_t t2;
    int32_t var_1cch;
    int32_t var_1c8h;
    int32_t dcount;
    int32_t term_pos;
    int32_t len_t2;
    int[100] skip_terms;
    int32_t len_t1;
    int32_t t1;
    token_type * d1;
    int32_t len1;
    token_type * d2;
    int32_t len2;
    void ** s2;
    size_t * n;
    char * var_ch;
    int32_t var_10h;
    esi = skip_count;
    edi = flag;
    eax = term_size;
    /* int smart_div(token_type * d1,int len1,token_type * d2,int len2); */
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x14));
    eax = ebx;
    eax <<= 4;
    eax = *((ebp + 8));
    eax = trhs;
    memmove (eax, eax, eax);
    *(obj.n_trhs) = ebx;
    eax = esi;
    eax <<= 4;
    eax = *((ebp + 0x10));
    eax = tlhs;
    memmove (eax, eax, eax);
    *(obj.n_tlhs) = esi;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    uf_simp_no_repeat ();
    *((esp + 4)) = 0x80796b8;
    eax = tlhs;
    *(esp) = eax;
    uf_simp_no_repeat ();
    if (*(obj.debug_level) > 2) {
        *((esp + 0xc)) = 0x8076e0c;
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 0x10)) = 0;
    eax = n_trhs;
    eax = trhs;
    list_debug (0, eax, eax);
    *((esp + 0x10)) = 0;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (0, eax, eax);
    ecx = 0;
    *((ebp - 0x1c4)) = 0;
    *((ebp - 0x1bc)) = 0;
    *((ebp - 0x1d0)) = 0;
    *((ebp - 0x1c0)) = 0;
    esi = 0;
    ebx = 0;
    edi = 0;
    do {
        if (ebx < *(obj.n_tlhs)) {
            edx = ebx;
            edx <<= 4;
            edx += *(obj.tlhs);
            eax = *(edx);
            if (eax != 2) {
                goto label_8;
            }
            if (*((edx + 4)) != 1) {
                goto label_9;
            }
            eax = *((edx + 8));
            eax--;
            if (eax > 1) {
                goto label_9;
            }
        }
        *((ebp - 0x1c4))++;
        if (ecx != 0) {
            if (*((ebp - 0x1bc)) != 0) {
                eax = ebx;
                eax -= esi;
                eax = esi;
                eax <<= 4;
                eax += *(obj.tlhs);
                eax = var_count (eax, eax);
                if (*((ebp - 0x1c0)) <= eax) {
                    goto label_10;
                }
            }
            eax = ebx;
            eax -= esi;
            *((ebp - 0x1bc)) = eax;
            eax = esi;
            eax <<= 4;
            eax += *(obj.tlhs);
            eax = var_count (eax, eax);
            *((ebp - 0x1c0)) = eax;
            *((ebp - 0x1d0)) = esi;
        }
label_10:
        if (ebx >= *(obj.n_tlhs)) {
            goto label_11;
label_8:
            if (eax != 1) {
                goto label_9;
            }
            edx = 1;
            if (*((edx + 8)) != 3) {
                ecx = edx;
            }
        } else {
            esi = ebx + 1;
            ecx = edi;
        }
label_9:
        ebx++;
    } while (1);
label_11:
    if (*((ebp - 0x1bc)) <= 0) {
        goto label_7;
    }
    *(obj.n_quotient) = 1;
    eax = zero_token;
    *(obj.quotient) = eax;
    eax = .comment;
    *(0x8083f84) = eax;
    eax = .comment;
    *(0x8083f88) = eax;
    eax = .comment;
    *(0x8083f8c) = eax;
    eax = n_tlhs;
    if (eax > 0x7530) {
        goto label_7;
    }
    *((esp + 0xc)) = 0x75300;
    eax <<= 4;
    *((esp + 8)) = eax;
    eax = tlhs;
    *((esp + 4)) = eax;
    *(esp) = obj.divisor;
    memmove_chk ();
    eax = n_tlhs;
    *(obj.n_divisor) = eax;
    ebx = ebp - 0x1b0;
label_1:
    ecx = n_trhs;
    *((ebp - 0x200)) = ecx;
    eax = *((ebp - 0x1bc));
    eax <<= 4;
    *((ebp - 0x1cc)) = eax;
    edx = *((ebp - 0x1d0));
    edx <<= 4;
    *((ebp - 0x1e4)) = edx;
    edx += obj.divisor;
    *((ebp - 0x1c8)) = edx;
    ecx = *((ebp - 0x1bc));
    ecx += *((ebp - 0x1d0));
    *((ebp - 0x1dc)) = ecx;
    eax = ecx;
    eax <<= 4;
    eax += obj.divisor;
    *((ebp - 0x1f8)) = eax;
    *((ebp - 0x1ec)) = 0;
    esi = 0;
    eax = *((ebp - 0x1d0));
    eax--;
    eax <<= 4;
    *((ebp - 0x1fc)) = eax;
label_4:
    eax = n_trhs;
    *((ebp - 0x1e8)) = eax;
    edx = n_quotient;
    *((ebp - 0x1f4)) = edx;
    ecx = *((ebp - 0x1b0));
    *((ebp - 0x1c0)) = ecx;
    edi = 1;
label_0:
    eax = ebp - 0x20;
    *((esp + 0x10)) = eax;
    edx = ebp - 0x1c;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = edi;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    eax = get_term (eax);
    if (eax == 0) {
        goto label_12;
    }
    if (esi <= 0) {
        goto label_13;
    }
    edx = *((ebp - 0x1c));
    eax = 0;
    if (*((ebp - 0x1c0)) != edx) {
        goto label_14;
    }
    goto label_15;
    do {
        if (edx == *((ebx + eax*4))) {
            goto label_15;
        }
label_14:
        eax++;
    } while (esi > eax);
    goto label_13;
label_6:
    eax <<= 4;
    eax = *((ebp - 0x1c));
    eax <<= 4;
    eax += *(obj.trhs);
    eax = tlhs;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x20));
    *(obj.n_tlhs) = edx;
    if (edx <= 0) {
        goto label_16;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
        edx = n_tlhs;
    } while (edx > eax);
label_16:
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 4;
    eax = n_tlhs;
    eax++;
    *(obj.n_tlhs) = eax;
    ecx = *((ebp - 0x1cc));
    edx = *((ebp - 0x1c8));
    eax <<= 4;
    eax += *(obj.tlhs);
    memmove (eax, edx, ecx);
    eax = n_tlhs;
    edx = *((ebp - 0x1bc));
    edx += eax;
    *(obj.n_tlhs) = edx;
    if (eax >= edx) {
        goto label_17;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.tlhs);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (*(obj.n_tlhs) > eax);
label_17:
    eax = tlhs;
    eax = simp_loop (eax, obj.n_tlhs);
    if (eax != 0) {
        eax = n_tlhs;
        *((esp + 4)) = eax;
        eax = tlhs;
        eax = basic_size (eax);
        *((ebp - 0x1d4)) = eax;
        eax = *((ebp - 0x20));
        *((esp + 4)) = eax;
        eax = *((ebp - 0x1c));
        eax <<= 4;
        eax += *(obj.trhs);
        eax = basic_size (eax);
        if (*((ebp - 0x1d4)) <= eax) {
            ecx = *((ebp - 0x1c));
            *((ebp - 0x1c0)) = ecx;
            eax = *((ebp - 0x20));
            if (*(obj.n_tlhs) > 0) {
                goto label_18;
            }
        }
    } else {
label_15:
        edi++;
        goto label_0;
    }
label_12:
    if (*((ebp - 0x1ec)) <= 0) {
        if (*((ebp - 0x1c4)) <= 1) {
            goto label_7;
        }
        eax = n_divisor;
        *((ebp - 0x1bc)) = eax;
        *((ebp - 0x1d0)) = 0;
        *((ebp - 0x1c4)) = 1;
        goto label_1;
    }
label_5:
    if (*((ebp - 0x1c4)) > 1) {
label_3:
        edx = n_trhs;
        edx += *(obj.n_quotient);
        eax = *((ebp - 0x200));
        eax++;
        if (edx >= eax) {
            goto label_7;
        }
    }
label_2:
    eax = n_quotient;
    eax <<= 4;
    eax = tlhs;
    memmove (eax, 0x8083f80, eax);
    eax = n_quotient;
    *(obj.n_tlhs) = eax;
    *((esp + 0x10)) = 0;
    eax = tlhs;
    list_debug (0, eax, eax);
    *((esp + 0x10)) = 0;
    eax = n_trhs;
    eax = trhs;
    list_debug (0, eax, eax);
    eax = 1;
    goto label_19;
label_18:
    edx = *((ebp - 0x1c0));
    *((ebp - 0x1c)) = edx;
    *((ebp - 0x20)) = eax;
    if (edx > 0) {
        edx--;
        ecx = edx;
        ecx <<= 4;
        edi = 2;
        edx = trhs;
        if (*((ecx + edx + 8)) == 2) {
            goto label_20;
        }
    }
    edi = 1;
label_20:
    if (*((ebp - 0x1d0)) > 0) {
        ecx = *((ebp - 0x1fc));
        if (*((ecx + 0x816e5a8)) != 2) {
            goto label_21;
        }
        dl = (edi != 2) ? 1 : 0;
        edi = (int32_t) dl;
        edi++;
    }
label_21:
    ecx = *((ebp - 0x1bc));
    edx = eax + ecx + 1;
    if (edx > *(obj.n_tokens)) {
        goto label_7;
    }
    eax <<= 4;
    eax = *((ebp - 0x1c0));
    eax <<= 4;
    eax += *(obj.trhs);
    eax = tlhs;
    memmove (eax, eax, eax);
    edx = *((ebp - 0x20));
    *(obj.n_tlhs) = edx;
    if (edx <= 0) {
        goto label_22;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
        edx = n_tlhs;
    } while (edx > eax);
label_22:
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 4;
    eax = n_tlhs;
    eax++;
    *(obj.n_tlhs) = eax;
    edx = *((ebp - 0x1cc));
    ecx = *((ebp - 0x1c8));
    eax <<= 4;
    eax += *(obj.tlhs);
    memmove (eax, ecx, edx);
    eax = n_tlhs;
    edx = *((ebp - 0x1bc));
    edx += eax;
    *(obj.n_tlhs) = edx;
    if (eax >= edx) {
        goto label_23;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.tlhs);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (*(obj.n_tlhs) > eax);
label_23:
    eax = tlhs;
    simp_loop (eax, obj.n_tlhs);
    eax = n_tlhs;
    ecx = n_tlhs;
    ecx += *(obj.n_quotient);
    ecx++;
    edx = 0x7530;
    if (*(obj.n_tokens) <= 0x7530) {
        edx = *(obj.n_tokens);
    }
    if (ecx > edx) {
        goto label_7;
    }
    if (eax <= 0) {
        goto label_24;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
    } while (*(obj.n_tlhs) > eax);
label_24:
    eax = n_quotient;
    *((ebp - 0x1d8)) = eax;
    eax = quotient;
    edx = *((ebp - 0x1d8));
    edx <<= 4;
    *((edx + eax + 4)) = 1;
    *((edx + eax)) = 2;
    *((edx + eax + 8)) = edi;
    eax = *((ebp - 0x1d8));
    eax++;
    *(obj.n_quotient) = eax;
    eax <<= 4;
    eax += obj.quotient;
    *((ebp - 0x1f0)) = eax;
    edx = n_tlhs;
    *((ebp - 0x1d4)) = edx;
    edx <<= 4;
    *((ebp - 0x1e0)) = edx;
    eax = tlhs;
    ecx = *((ebp - 0x1f0));
    memmove (ecx, eax, edx);
    eax = n_tlhs;
    *(obj.n_quotient) += eax;
    eax = n_trhs;
    ecx = *((ebp - 0x1d4));
    edx = eax + ecx + 2;
    edx += *(obj.n_divisor);
    if (edx > *(obj.n_tokens)) {
        goto label_7;
    }
    eax <<= 4;
    eax = trhs;
    eax = tlhs;
    memmove (eax, eax, eax);
    edx = n_trhs;
    *(obj.n_tlhs) = edx;
    eax = *((ebp - 0x1c));
    eax += *((ebp - 0x20));
    edx -= eax;
    edx <<= 4;
    eax <<= 4;
    eax += *(obj.trhs);
    eax = *((ebp - 0x1c));
    eax <<= 4;
    edx = trhs;
    eax = eax + edx + 0x10;
    memmove (eax, eax, edx);
    eax = n_trhs;
    eax++;
    eax -= *((ebp - 0x20));
    *(obj.n_trhs) = eax;
    eax = trhs;
    edx = *((ebp - 0x1c));
    edx <<= 4;
    ecx = zero_token;
    *((edx + eax)) = ecx;
    ecx = .comment;
    *((edx + eax + 4)) = ecx;
    ecx = .comment;
    *((edx + eax + 8)) = ecx;
    ecx = .comment;
    *((edx + eax + 0xc)) = ecx;
    edx = n_trhs;
    if (edx <= 0) {
        goto label_25;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.trhs);
        *((edx + 4))++;
        eax++;
        edx = n_trhs;
    } while (edx > eax);
label_25:
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 4)) = 1;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    if (edi == 1) {
        edx = n_trhs;
        edx <<= 4;
        eax = trhs;
        *((edx + eax + 8)) = 2;
    } else {
        edx = n_trhs;
        edx <<= 4;
        eax = trhs;
        *((edx + eax + 8)) = 1;
    }
    eax = n_trhs;
    eax++;
    *(obj.n_trhs) = eax;
    ecx = *((ebp - 0x1e0));
    edx = *((ebp - 0x1f0));
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, edx, ecx);
    eax = n_trhs;
    ecx = *((ebp - 0x1d4));
    ecx = eax + ecx;
    *(obj.n_trhs) = ecx;
    if (eax >= ecx) {
        goto label_26;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.trhs);
        *((ecx + 4))++;
        eax++;
        ecx = n_trhs;
        edx += 0x10;
    } while (ecx > eax);
label_26:
    ecx <<= 4;
    eax = trhs;
    *((ecx + eax + 4)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 8)) = 3;
    edi = n_trhs;
    edi++;
    *(obj.n_trhs) = edi;
    ecx = *((ebp - 0x1e4));
    eax = edi;
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, 0x816e5a0, ecx);
    edx = *((ebp - 0x1d0));
    edx += *(obj.n_trhs);
    *(obj.n_trhs) = edx;
    eax = trhs;
    edx <<= 4;
    ecx = zero_token;
    *((edx + eax)) = ecx;
    ecx = .comment;
    *((edx + eax + 4)) = ecx;
    ecx = .comment;
    *((edx + eax + 8)) = ecx;
    ecx = .comment;
    *((edx + eax + 0xc)) = ecx;
    eax = n_trhs;
    eax++;
    *(obj.n_trhs) = eax;
    edx = n_divisor;
    edx -= *((ebp - 0x1dc));
    edx <<= 4;
    edx = *((ebp - 0x1f8));
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, edx, edx);
    edx = n_trhs;
    edx += *(obj.n_divisor);
    edx -= *((ebp - 0x1dc));
    *(obj.n_trhs) = edx;
    if (edi >= edx) {
        goto label_27;
    }
    eax = edi;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.trhs);
        *((edx + 4)) += 2;
        edi++;
        edx = n_trhs;
        eax += 0x10;
    } while (edx > edi);
label_27:
    *((esp + 0x10)) = 0;
    eax = trhs;
    list_debug (0, eax, edx);
    eax = trhs;
    uf_tsimp (eax, 0x80798b4);
    *((esp + 0x10)) = 0;
    eax = n_trhs;
    eax = trhs;
    list_debug (0, eax, eax);
    eax = n_trhs;
    if (eax != 1) {
        goto label_28;
    }
    edx = trhs;
    if (*(edx) != 0) {
        goto label_28;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_28;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_2;
    }
label_28:
    if (*((ebp - 0x1c4)) <= 1) {
        goto label_29;
    }
    ecx = *((ebp - 0x1f4));
    ecx += *((ebp - 0x1e8));
    edx = eax;
    edx += *(obj.n_quotient);
    if (ecx > edx) {
        goto label_29;
    }
    if (esi > 0x63) {
        if (*((ebp - 0x1ec)) == 0) {
            goto label_7;
        }
        ecx = *((ebp - 0x1d8));
        *(obj.n_quotient) = ecx;
        eax = n_tlhs;
        eax <<= 4;
        eax = tlhs;
        eax = trhs;
        memmove (eax, eax, eax);
        eax = n_tlhs;
        *(obj.n_trhs) = eax;
        goto label_3;
    }
    eax = *((ebp - 0x1c0));
    *((ebp + esi*4 - 0x1b0)) = eax;
    esi++;
    edx = *((ebp - 0x1d8));
    *(obj.n_quotient) = edx;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    eax = trhs;
    memmove (eax, eax, eax);
    eax = n_tlhs;
    *(obj.n_trhs) = eax;
    if (*(obj.debug_level) <= 2) {
        goto label_4;
    }
    *((esp + 0xc)) = "Skipping last operation.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    eax = fprintf_chk ();
    goto label_4;
label_29:
    if (eax != 1) {
        goto label_30;
    }
    eax = trhs;
    if (*(eax) == 0) {
        goto label_5;
    }
label_30:
    *((ebp - 0x1ec))++;
    esi = 0;
    goto label_4;
label_7:
    eax = 0;
label_19:
    return eax;
label_13:
    eax = *((ebp - 0x20));
    ecx = *((ebp - 0x1bc));
    edx = ecx + eax + 1;
    if (edx <= *(obj.n_tokens)) {
        goto label_6;
    }
    goto label_7;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049760 */
#include <stdint.h>
 
uint32_t dbg_set_signals (int32_t rv) {
    void * func;
    ebx = rv;
    /* int set_signals(); */
    *((esp + 4)) = 0x8049390;
    eax = signal (8);
    esi = eax;
    *((esp + 4)) = 0x8049478;
    eax = signal (2);
    ebx = 0;
    if (eax != -1) {
        bl = (esi != -1) ? 1 : 0;
        ebx = (int32_t) bl;
    }
    *((esp + 4)) = dbg.inthandler;
    eax = signal (3);
    eax = 0;
    if (eax == -1) {
        ebx = eax;
    }
    *((esp + 4)) = 0x804943c;
    eax = signal (0xf);
    eax = 0;
    if (eax == -1) {
        ebx = eax;
    }
    *((esp + 4)) = 0x804943c;
    eax = signal (1);
    eax = 0;
    if (eax == -1) {
        ebx = eax;
    }
    *((esp + 4)) = 0x804965d;
    eax = signal (0x1c);
    eax = 0;
    if (eax == -1) {
        ebx = eax;
    }
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f14 */
#include <stdint.h>
 
void signal (void) {
    signal ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b139 */
#include <stdint.h>
 
int32_t dbg_get_range_eol (char * arg_8h, char * arg_ch, size_t arg_10h) {
    char * var_4h;
    size_t var_8h;
    /* int get_range_eol(char ** cpp,int * ip,int * jp); */
    ebx = *((ebp + 8));
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    eax = get_range (ebx, eax);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        eax = *(ebx);
        eax = extra_characters (eax);
        al = (eax == 0) ? 1 : 0;
        eax = (int32_t) al;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804af59 */
#include <stdint.h>
 
int32_t dbg_get_range (char * arg_ch, char * arg_10h, int * jp, int32_t i, int * ip) {
    char * cp;
    char ** cpp;
    char * * endptr;
    int32_t base;
    ebx = jp;
    ecx = i;
    edi = ip;
    /* int get_range(char ** cpp,int * ip,int * jp); */
    edi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    edx = *((ebp + 8));
    eax = *(edx);
    eax = skip_space (eax);
    *((ebp - 0x1c)) = eax;
    *(esp) = eax;
    eax = is_all ();
    if (eax == 0) {
        goto label_0;
    }
    eax = *((ebp - 0x1c));
    eax = skip_param (eax);
    *((ebp - 0x1c)) = eax;
    *(edi) = 0;
    eax = n_equations;
    edx = eax - 1;
    *(ebx) = edx;
    if (edx <= 0) {
        goto label_1;
    }
    if (*((edx*4 + obj.n_lhs)) != 0) {
        goto label_1;
    }
    eax -= 2;
    edx = eax*4 + obj_n_lhs;
    do {
        *(ebx) = eax;
        if (eax <= 0) {
            goto label_1;
        }
        ecx = *(edx);
        eax--;
        edx -= 4;
    } while (ecx == 0);
    goto label_1;
label_0:
    eax = ctype_b_loc ();
    esi = eax;
    eax = *((ebp - 0x1c));
    ecx = *(eax);
    edx = *(esi);
    if ((*((edx + ecx*2 + 1)) & 8) != 0) {
        edx = ebp - 0x1c;
        eax = strtol (eax, edx, 0xa);
        eax--;
        *(edi) = eax;
    } else {
        eax = cur_equation;
        *(edi) = eax;
    }
    eax = *(edi);
    if (eax >= 0) {
        if (eax < *(obj.n_equations)) {
            goto label_2;
        }
    }
    *(esp) = "Invalid equation number.";
    error ();
    eax = 0;
    goto label_3;
label_2:
    edx = *((ebp - 0x1c));
    if (*(edx) != 0x2d) {
        eax = not_defined (eax);
        edx = eax;
        eax = 0;
        if (edx != 0) {
            goto label_3;
        }
        eax = *(edi);
        *(ebx) = eax;
        eax = *((ebp - 0x1c));
        eax = skip_space (eax);
        edx = *((ebp + 8));
        *(edx) = eax;
        eax = 1;
        goto label_3;
    }
    edx++;
    *((ebp - 0x1c)) = edx;
    eax = *(edx);
    ecx = *(esi);
    if ((*((ecx + eax*2 + 1)) & 8) != 0) {
        eax = ebp - 0x1c;
        eax = strtol (edx, eax, 0xa);
        eax--;
        *(ebx) = eax;
    } else {
        eax = cur_equation;
        *(ebx) = eax;
    }
    eax = *(ebx);
    if (eax >= 0) {
        if (eax < *(obj.n_equations)) {
            goto label_4;
        }
    }
    *(esp) = "Invalid equation number.";
    error ();
    eax = 0;
    goto label_3;
label_4:
    edx = *(edi);
    if (eax < edx) {
        *(edi) = eax;
        *(ebx) = edx;
    }
label_1:
    eax = *((ebp - 0x1c));
    eax = skip_space (eax);
    *((ebp - 0x1c)) = eax;
    edx = *(edi);
    esi = *(ebx);
    if (esi < edx) {
        goto label_5;
    }
    ecx = edx*4 + 0x8082d84;
    if (*((edx*4 + obj.n_lhs)) <= 0) {
        goto label_6;
    }
    while (esi >= edx) {
        ebx = *(ecx);
        ecx += 4;
        if (ebx > 0) {
            edx = *((ebp + 8));
            *(edx) = eax;
            eax = 1;
            goto label_3;
        }
label_6:
        edx++;
    }
label_5:
    *(esp) = "No equations defined in specified range.";
    error ();
    eax = 0;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804adb9 */
#include <stdint.h>
 
int32_t dbg_extra_characters (uint32_t arg_8h) {
    /* int extra_characters(char * cp); */
    eax = *((ebp + 8));
    if (eax != 0) {
        eax = skip_space (eax);
        if (*(eax) != 0) {
            *(esp) = "Extra characters or unrecognized argument.";
            error ();
            eax = 1;
        }
    } else {
        eax = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a053 */
#include <stdint.h>
 
int32_t dbg_next_sign (void * arg_8h, long int * vp, int32_t i) {
    edx = vp;
    eax = i;
    /* int next_sign(long int * vp); */
    ecx = *((ebp + 8));
    eax = 1;
    edx = sign_array;
    if (*(obj.sign_array) != 0) {
        goto label_1;
    }
    al = 0;
    goto label_2;
label_0:
    *(ecx) = 4;
    eax = 0;
    goto label_3;
    do {
label_1:
        if (*((eax + edx)) == 0) {
label_2:
            edx = eax;
            edx <<= 0xe;
            edx += 4;
            *(ecx) = edx;
            *((eax + obj.sign_array)) = 1;
            eax = 1;
            goto label_3;
        }
        eax++;
    } while (eax != 0x40);
    goto label_0;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a8df */
#include <stdint.h>
 
int32_t dbg_copy_espace (int32_t arg_8h, char * arg_ch, int32_t src, int32_t dest) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    void ** s2;
    size_t * n;
    ebx = src;
    esi = dest;
    /* void copy_espace(int src,int dest); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    if (ebx != esi) {
        edi = n_lhs;
        eax = *((edi + ebx*4));
        eax <<= 4;
        eax = lhs;
        edx = *((eax + ebx*4));
        eax = *((eax + esi*4));
        memmove (eax, edx, eax);
        eax = *((edi + ebx*4));
        *((edi + esi*4)) = eax;
        edi = n_rhs;
        eax = *((edi + ebx*4));
        eax <<= 4;
        eax = rhs;
        edx = *((eax + ebx*4));
        eax = *((eax + esi*4));
        memmove (eax, edx, eax);
        eax = *((edi + ebx*4));
        *((edi + esi*4)) = eax;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80491c4 */
#include <stdint.h>
 
void memmove (void) {
    memmove ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8052d39 */
#include <stdint.h>
 
uint32_t dbg_approximate_cmd (char * cp1) {
    int32_t j;
    int32_t i;
    char * cp;
    int32_t var_4h;
    int32_t var_8h;
    ebx = cp1;
    /* int approximate_cmd(char * cp); */
    edi = ebp - 0x20;
label_0:
    ebx = *((ebp + 8));
    *((esp + 8)) = edi;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range (eax, eax);
    if (eax == 0) {
        goto label_1;
    }
    eax = *((ebp + 8));
    while (ebx != eax) {
        eax = *((ebp - 0x1c));
        esi = n_lhs;
        ebx = lhs;
        if (eax <= *((ebp - 0x20))) {
            goto label_2;
        }
        goto label_3;
    }
    *(esp) = "Invalid argument.";
    error ();
    eax = 0;
    goto label_4;
    do {
label_2:
        if (*((esi + eax*4)) != 0) {
            edx = eax*4 + obj_n_lhs;
            *((esp + 4)) = edx;
            eax = *((ebx + eax*4));
            subst_constants (eax);
            eax = *((ebp - 0x1c));
            edx = eax*4 + obj_n_rhs;
            *((esp + 4)) = edx;
            eax = *((eax*4 + obj.rhs));
            subst_constants (eax);
            *(obj.approximate_roots) = 1;
            eax = *((ebp - 0x1c));
            simp_equation (eax);
            eax = *((ebp - 0x1c));
            edx = eax*4 + obj_n_lhs;
            eax = *((ebx + eax*4));
            factorv (eax, edx, 3);
            eax = *((ebp - 0x1c));
            if (*((eax*4 + obj.n_rhs)) != 0) {
                edx = eax*4 + obj_n_rhs;
                eax = *((eax*4 + obj.rhs));
                factorv (eax, edx, 3);
            }
            *(obj.approximate_roots) = 0;
            eax = *((ebp - 0x1c));
            eax = return_result (eax);
            if (eax == 0) {
                goto label_1;
            }
        }
        eax = *((ebp - 0x1c));
        eax++;
        *((ebp - 0x1c)) = eax;
    } while (*((ebp - 0x20)) >= eax);
label_3:
    eax = *((ebp + 8));
    if (*(eax) != 0) {
        goto label_0;
    }
    eax = 1;
    goto label_4;
label_1:
    eax = 0;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805048f */
#include <stdint.h>
 
uint32_t dbg_binary_parenthesize (void * arg_ch, int32_t n, int32_t level, int32_t j) {
    int32_t var_3ch;
    int32_t var_2ch;
    size_t var_1ch;
    token_type * p1;
    int32_t i;
    ebx = n;
    edx = level;
    eax = j;
    /* void binary_parenthesize(token_type * p1,int n,int i); */
    ebx = *((ebp + 0xc));
    eax = ebx - 1;
    if (eax > *((ebp + 0x10))) {
        if ((bl & 1) == 0) {
            goto label_0;
        }
        if ((*((ebp + 0x10)) & 1) != 0) {
            goto label_1;
        }
    }
label_0:
    error_bug ("Internal error in arguments to binary_parenthesize().");
label_1:
    eax = *((ebp + 0x10));
    *((ebp - 0x1c)) = eax;
    eax <<= 4;
    eax += *((ebp + 8));
    ecx = *((eax + 4));
    edx = ecx + 1;
    *((eax + 4)) = edx;
    eax = *((ebp + 0x10));
    eax <<= 4;
    esi = *((ebp + 8));
    edx = eax + esi - 0x10;
    eax = *((edx + 4));
    esi = eax + 1;
    *((edx + 4)) = esi;
    if (ecx >= eax) {
        goto label_2;
    }
    edi = *((ebp + 0x10));
    edi -= 2;
    *((ebp - 0x3c)) = edi;
    if (edi < 0) {
        goto label_2;
    }
    edi <<= 4;
    edi += *((ebp + 8));
    esi = *((edi + 4));
    if (ecx >= esi) {
        goto label_2;
    }
    eax = *((ebp + 0x10));
    eax <<= 4;
    edx = *((ebp + 8));
    edx = eax + edx - 0x30;
    eax = edx;
    edx = *((ebp - 0x3c));
    while (edx >= 0) {
        edi = eax;
        esi = *((eax + 4));
        eax -= 0x10;
        if (ecx >= esi) {
            goto label_2;
        }
        esi++;
        *((edi + 4)) = esi;
        edx--;
    }
label_2:
    eax = *((ebp - 0x1c));
    eax <<= 4;
    esi = *((ebp + 8));
    edx = eax + esi + 0x10;
    eax = *((edx + 4));
    esi = eax + 1;
    *((edx + 4)) = esi;
    if (ecx >= eax) {
        goto label_3;
    }
    eax = *((ebp + 0x10));
    eax += 2;
    if (ebx <= eax) {
        goto label_3;
    }
    esi = eax;
    esi <<= 4;
    esi += *((ebp + 8));
    edi = *((esi + 4));
    *((ebp - 0x2c)) = edi;
    if (ecx >= edi) {
        goto label_3;
    }
    edx = *((ebp + 0x10));
    edx <<= 4;
    edi = *((ebp + 8));
    edi = edx + edi + 0x30;
    *((ebp - 0x1c)) = edi;
    edx = *((ebp - 0x2c));
    while (ebx > eax) {
        esi = edi;
        edx = *((edi + 4));
        edi += 0x10;
        if (ecx >= edx) {
            goto label_3;
        }
        edx++;
        *((esi + 4)) = edx;
        eax++;
    }
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80578b1 */
#include <stdint.h>
 
uint32_t dbg_read_sub (int32_t arg_8h, int32_t rv, char * cp) {
    jmp_buf save_save;
    void * size;
    size_t stream;
    ebx = rv;
    eax = cp;
    /* int read_sub(FILE * fp); */
    eax = ebp - 0xa4;
    memmove (eax, 0x8079600, 0x9c);
    eax = setjmp (obj.jmp_save);
    ebx = eax;
    if (eax == 0) {
        goto label_0;
    }
    clean_up ();
    if (ebx != 0xe) {
        goto label_1;
    }
    *(esp) = "Expression too large.";
    eax = error ();
    goto label_1;
    do {
        eax = display_process (eax);
        if (eax == 0) {
            *((esp + 4)) = 3;
            *(esp) = obj.jmp_save;
            longjmp_chk ();
        }
label_0:
        eax = *((ebp + 8));
        eax = n_tokens;
        eax <<= 4;
        eax = tlhs;
        eax = fgets (eax, eax, eax);
    } while (eax != 0);
label_1:
    eax = ebp - 0xa4;
    memmove (obj.jmp_save, eax, 0x9c);
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d04b */
#include <stdint.h>
 
uint32_t dbg_approximate_complex_roots (int32_t arg_8h, int32_t arg_ch, token_type * equation, int * np) {
    int32_t var_4h;
    ebx = equation;
    esi = np;
    /* void approximate_complex_roots(token_type * equation,int * np); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    do {
        elim_loop (ebx, esi);
        *((esp + 4)) = esi;
        *(esp) = ebx;
        eax = complex_root_simp ();
    } while (eax != 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d152 */
#include <stdint.h>
 
uint32_t dbg_simp_equation (int32_t arg_8h, int32_t n) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    ebx = n;
    /* void simp_equation(int n); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    if (*((ebx*4 + obj.n_lhs)) > 0) {
        esi = ebx*4;
        eax = esi + obj_n_lhs;
        eax = *((ebx*4 + obj.lhs));
        simp_loop (eax, eax);
        if (*((ebx*4 + obj.n_rhs)) == 0) {
            goto label_0;
        }
        esi += obj.n_rhs;
        eax = *((ebx*4 + obj.rhs));
        simp_loop (eax, esi);
    }
label_0:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d024 */
#include <stdint.h>
 
uint32_t dbg_simp_loop (void * arg_8h, char * arg_ch, token_type * equation, int * np, int32_t rv, int32_t i) {
    int32_t var_4h;
    ebx = equation;
    esi = np;
    edi = rv;
    eax = i;
    /* int simp_loop(token_type * equation,int * np); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    edi = 0;
    goto label_1;
label_0:
    edi = 1;
    do {
label_1:
        elim_loop (ebx, esi);
        *((esp + 4)) = esi;
        *(esp) = ebx;
        eax = simp2_power ();
    } while (eax != 0);
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_times ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = elim_sign ();
    if (eax != 0) {
        goto label_1;
    }
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = subtract_itself ();
    if (eax != 0) {
        goto label_1;
    }
    eax = edi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805f3dd */
#include <stdint.h>
 
int32_t dbg_factor_times (void) {
    token_type * equation;
    int * np;
    /* int factor_times(token_type * equation,int * np); */
    *(esp) = 1;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    ftimes_recurse ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070a5d */
#include <stdint.h>
 
uint32_t dbg_is_prime (void) {
    /* int is_prime(); */
    multiply_out_unique ();
    *(fp_stack--) = *(0x8072058);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        if (*(obj.uno) == 1) {
            al = (*(obj.ucnt) == 1) ? 1 : 0;
            eax = (int32_t) al;
        }
    } else {
        eax = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062d9f */
#include <stdint.h>
 
uint32_t dbg_uf_pplus (int32_t arg_8h, char * arg_ch, int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * var_sp_4h;
    int32_t var_sp_8h;
    eax = rv;
    /* int uf_pplus(token_type * equation,int * np); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    *((esp + 4)) = esi;
    organize (edi);
    *((esp + 8)) = 4;
    *((esp + 4)) = esi;
    *(esp) = edi;
    eax = sub_ufactor ();
    ebx = eax;
    if (eax != 0) {
        *((esp + 4)) = esi;
        organize (edi);
    }
    eax = ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8053c1d */
#include <stdint.h>
 
int32_t dbg_divide_cmd (int32_t i, int32_t j) {
    double d4;
    double d3;
    complexs c3;
    complexs c2;
    int32_t var_5ch;
    int32_t var_58h;
    int32_t var_54h;
    complexs c1;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t var_44h;
    double d5;
    double d2;
    double d1;
    int32_t nright;
    int32_t nleft;
    long int v_tmp;
    long int v;
    int32_t var_bp_ch;
    char * cp;
    int32_t var_4h_2;
    char * var_4h;
    char * var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_sp_1ch;
    int32_t var_sp_20h;
    int32_t var_sp_24h;
    ebx = i;
    esi = j;
    /* int divide_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x1c)) = 0;
    *((ebp - 0x24)) = 0;
    *((ebp - 0x28)) = 0;
    *(obj.pull_number) = 0xffffffff;
    if (*(eax) != 0) {
        eax = ebp - 0x1c;
        eax = parse_var2 (eax, eax);
        if (eax == 0) {
            goto label_1;
        }
        eax = extra_characters (eax);
        if (eax != 0) {
            goto label_1;
        }
    }
    eax = next_espace ();
    ebx = eax;
    do {
label_0:
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter dividend: ");
        eax = ebp - 0x28;
        eax = *((ebx*4 + obj.rhs));
        eax = get_expr (eax, eax);
        if (eax == 0) {
            eax = repeat_flag;
            goto label_2;
        }
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter divisor: ");
        eax = ebp - 0x24;
        eax = *((ebx*4 + obj.lhs));
        eax = get_expr (eax, eax);
        if (eax == 0) {
            eax = repeat_flag;
            goto label_2;
        }
        edi = 0x80757fd;
        *((esp + 8)) = edi;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = ebp - 0x28;
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.rhs));
        *(esp) = eax;
        calc_simp ();
        eax = ebp - 0x24;
        *((esp + 4)) = eax;
        esi = lhs;
        eax = *((esi + ebx*4));
        *(esp) = eax;
        calc_simp ();
        eax = ebp - 0x38;
        *((esp + 8)) = eax;
        eax = *((ebp - 0x24));
        *((esp + 4)) = eax;
        eax = *((esi + ebx*4));
        eax = get_constant (eax);
        if (eax != 0) {
            *(fp_stack--) = *((ebp - 0x38));
            *(esp) = fp_stack[0];
            fp_stack--;
            check_divide_by_zero ();
        }
        eax = ebp - 0x30;
        *((esp + 8)) = eax;
        eax = *((ebp - 0x28));
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.rhs));
        eax = get_constant (eax);
        if (eax == 0) {
            goto label_3;
        }
        eax = ebp - 0x38;
        *((esp + 8)) = eax;
        eax = *((ebp - 0x24));
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        eax = get_constant (eax);
        if (eax == 0) {
            goto label_3;
        }
        *(fp_stack--) = *((ebp - 0x38));
        *((esp + 8)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x30));
        *(esp) = fp_stack[0];
        fp_stack--;
        gcd_verified ();
        *((ebp - 0x80)) = fp_stack[0];
        fp_stack--;
        eax = ebp - 0x40;
        *(fp_stack--) = *((ebp - 0x30));
        fp_stack[0] /= *((ebp - 0x38));
        *(esp) = fp_stack[0];
        fp_stack--;
        modf (eax);
        *((ebp - 0x88)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x30));
        *(fp_stack--) = *((ebp - 0x38));
        eax = precision;
        *(fp_stack--) = fp_stack[1];
        fp_stack[0] /= fp_stack[1];
        *((esp + 0x28)) = fp_stack[0];
        fp_stack--;
        *((esp + 0x24)) = eax;
        *((esp + 0x1c)) = fp_stack[0];
        fp_stack--;
        *((esp + 0x18)) = eax;
        *((esp + 0x10)) = fp_stack[0];
        fp_stack--;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "%.*g/%.*g = %.*g";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *(fp_stack--) = 0.0;
        *(fp_stack--) = *((ebp - 0x80));
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_4;
            }
        }
        *((ebp - 0x38)) /= fp_stack[0];
        *(fp_stack--) = 1.0;
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_5;
            }
        }
        eax = precision;
        *((esp + 0x1c)) = fp_stack[0];
        fp_stack--;
        *((esp + 0x18)) = eax;
        *(fp_stack--) = *((ebp - 0x80));
        *((ebp - 0x30)) /= fp_stack[0];
        *((esp + 0x10)) = fp_stack[0];
        fp_stack--;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = " = %.*g/%.*g";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        goto label_6;
label_4:
        fp_stack++;
        goto label_6;
label_5:
        fp_stack++;
label_6:
        eax = precision;
        *(fp_stack--) = *((ebp - 0x88));
        fp_stack[0] *= *((ebp - 0x38));
        *((esp + 0x1c)) = fp_stack[0];
        fp_stack--;
        *((esp + 0x18)) = eax;
        *(fp_stack--) = *((ebp - 0x40));
        *((esp + 0x10)) = fp_stack[0];
        fp_stack--;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "\nQuotient: %.*g, Remainder: %.*g\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *(fp_stack--) = *((ebp - 0x30));
        fp_stack[0] = abs(fp_stack[0]);
        *((ebp - 0x30)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x38));
        fp_stack[0] = abs(fp_stack[0]);
        *((ebp - 0x38)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = 0.0;
        *(fp_stack--) = *((ebp - 0x80));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_7;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_7;
        }
        *((esp + 8)) = "No GCD found.\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    } while (*(obj.repeat_flag) != 0);
    goto label_8;
label_7:
    *((esp + 8)) = "GCD = ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = *(0x8072774);
    *(fp_stack--) = *((ebp - 0x80));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        *(esp) = fp_stack[0];
        fp_stack--;
        eax = factor_one ();
        if (eax != 0) {
            eax = is_prime ();
            if (eax != 0) {
                goto label_9;
            }
            display_unique ();
        } else {
            fp_stack++;
        }
label_9:
        *(fp_stack--) = *((ebp - 0x80));
        *(esp) = fp_stack[0];
        fp_stack--;
        display_fraction ();
    }
    *(fp_stack--) = *((ebp - 0x30));
    fp_stack[0] *= *((ebp - 0x38));
    fp_stack[0] /= *((ebp - 0x80));
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
    *((esp + 8)) = "LCM = ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = *(0x8072774);
    *(fp_stack--) = *((ebp - 0x80));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        *(esp) = fp_stack[0];
        fp_stack--;
        eax = factor_one ();
        if (eax != 0) {
            eax = is_prime ();
            if (eax != 0) {
                goto label_10;
            }
            display_unique ();
        } else {
            fp_stack++;
        }
label_10:
        *(fp_stack--) = *((ebp - 0x80));
        *(esp) = fp_stack[0];
        fp_stack--;
        display_fraction ();
    }
    if (*(obj.repeat_flag) != 0) {
        goto label_0;
    }
    goto label_8;
label_3:
    eax = ebp - 0x50;
    *((esp + 8)) = eax;
    eax = *((ebp - 0x28));
    eax = *((ebx*4 + obj.rhs));
    eax = parse_complex (eax, eax);
    if (eax == 0) {
        goto label_11;
    }
    eax = ebp - 0x60;
    *((esp + 8)) = eax;
    eax = *((ebp - 0x24));
    eax = *((ebx*4 + obj.lhs));
    eax = parse_complex (eax, eax);
    if (eax == 0) {
        goto label_11;
    }
    eax = ebp - 0x70;
    edx = *((ebp - 0x60));
    *((esp + 0x14)) = edx;
    edx = *((ebp - 0x5c));
    *((esp + 0x18)) = edx;
    edx = *((ebp - 0x58));
    edx = *((ebp - 0x54));
    edx = *((ebp - 0x50));
    edx = *((ebp - 0x4c));
    edx = *((ebp - 0x48));
    edx = *((ebp - 0x44));
    complex_div (edx, edx, edx);
    *((esp + 8)) = "Result of complex number division:\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = precision;
    *(fp_stack--) = *((ebp - 0x68));
    *((esp + 0x1c)) = fp_stack[0];
    fp_stack--;
    *((esp + 0x18)) = eax;
    *(fp_stack--) = *((ebp - 0x70));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "%.*g %+.*g*i\n\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    if (*(obj.repeat_flag) != 0) {
        goto label_0;
    }
    goto label_8;
label_11:
    eax = *((ebp - 0x1c));
    *((ebp - 0x20)) = eax;
    eax = ebp - 0x20;
    *((esp + 0x10)) = eax;
    eax = *((ebp - 0x24));
    *((esp + 0xc)) = eax;
    eax = *((ebx*4 + obj.lhs));
    *((esp + 8)) = eax;
    eax = *((ebp - 0x28));
    *((esp + 4)) = eax;
    eax = *((ebx*4 + obj.rhs));
    *(esp) = eax;
    eax = poly_div ();
    if (eax != 0) {
        eax = tlhs;
        simp_divide (eax, obj.n_tlhs);
        eax = trhs;
        simp_divide (eax, 0x80798b4);
        eax = *((ebp - 0x20));
        list_var (eax, 0);
        *((esp + 0xc)) = 0x8079800;
        *((esp + 8)) = "Polynomial division successful using base variable (%s).\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 8)) = "The quotient is:\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 4)) = 0x80796b8;
        eax = tlhs;
        *(esp) = eax;
        fractions_and_group ();
        *((esp + 8)) = 0;
        eax = tlhs;
        list_factor (eax, 0x80796b8);
        *((esp + 8)) = "\n\nThe remainder is:\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 4)) = 0x80798b4;
        eax = trhs;
        *(esp) = eax;
        fractions_and_group ();
        *((esp + 8)) = 0;
        eax = trhs;
        list_factor (eax, 0x80798b4);
        *((esp + 8)) = edi;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    } else {
        *((esp + 8)) = "Polynomial division failed.\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 8)) = edi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = *((ebp - 0x1c));
    *((esp + 0x10)) = eax;
    eax = *((ebp - 0x24));
    *((esp + 0xc)) = eax;
    eax = *((ebx*4 + obj.lhs));
    *((esp + 8)) = eax;
    eax = *((ebp - 0x28));
    eax = *((ebx*4 + obj.rhs));
    eax = poly_gcd (eax, eax);
    esi = eax;
    if (eax == 0) {
        eax = *((ebp - 0x1c));
        *((esp + 0x10)) = eax;
        eax = *((ebp - 0x28));
        *((esp + 0xc)) = eax;
        eax = *((ebx*4 + obj.rhs));
        *((esp + 8)) = eax;
        eax = *((ebp - 0x24));
        eax = *((ebx*4 + obj.lhs));
        eax = poly_gcd (eax, eax);
        esi = eax;
        if (eax == 0) {
            goto label_12;
        }
    }
    eax = trhs;
    simp_divide (eax, obj.n_trhs);
    eax = 0x8075e75;
    edx = 0x80757fe;
    if (esi == 1) {
        eax = edx;
    }
    *((esp + 0x10)) = eax;
    *((esp + 0xc)) = esi;
    *((esp + 8)) = "Polynomial GCD (%d Euclidean algorithm iteration%s):\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    fractions_and_group ();
    *((esp + 8)) = 0;
    eax = trhs;
    list_factor (eax, 0x80798b4);
    *((esp + 8)) = edi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    goto label_13;
label_12:
    *((esp + 8)) = "No univariate polynomial GCD found.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
label_13:
    if (*(obj.repeat_flag) != 0) {
        goto label_0;
    }
    goto label_8;
label_1:
    eax = 0;
    goto label_2;
label_8:
    eax = 1;
label_2:
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062d66 */
#include <stdint.h>
 
uint32_t dbg_uf_allpower (int32_t arg_8h, size_t * arg_ch, token_type * equation, int * np) {
    size_t * var_4h;
    int32_t var_8h;
    ebx = equation;
    esi = np;
    /* void uf_allpower(token_type * equation,int * np); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    do {
        *((esp + 4)) = esi;
        organize (ebx);
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        *(esp) = ebx;
        eax = sub_ufactor ();
    } while (eax != 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806a750 */
#include <stdint.h>
 
uint32_t dbg_nintegrate_cmd (int32_t i2, int32_t level, token_type * dest, token_type * ep) {
    int * np;
    int32_t solved;
    void * var_5ch;
    int32_t iterations;
    token_type * source;
    int32_t trap_flag;
    int32_t i;
    int * nps;
    int32_t var_44h;
    int32_t first_size;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t singularity;
    int32_t n1;
    long int v;
    char * cp;
    char * s2;
    size_t n;
    ebx = i2;
    esi = level;
    edi = dest;
    eax = ep;
    /* int nintegrate_cmd(char * cp); */
    *((ebp - 0x1c)) = 0;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_3;
    }
    eax = cur_equation;
    eax = solved_equation (eax);
    *((ebp - 0x60)) = eax;
    eax = next_espace ();
    *((ebp - 0x4c)) = eax;
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        edx = rhs;
        ecx = *((edx + eax*4));
        *((ebp - 0x54)) = ecx;
        eax = eax*4 + obj_n_rhs;
        *((ebp - 0x48)) = eax;
        ebx = *((ebp - 0x4c));
        edx = *((edx + ebx*4));
        *((ebp - 0x5c)) = edx;
        eax = ebx*4 + obj_n_rhs;
        *((ebp - 0x64)) = eax;
    } else {
        edx = lhs;
        ecx = *((edx + eax*4));
        *((ebp - 0x54)) = ecx;
        eax = eax*4 + obj_n_lhs;
        *((ebp - 0x48)) = eax;
        ebx = *((ebp - 0x4c));
        edx = *((edx + ebx*4));
        *((ebp - 0x5c)) = edx;
        eax = ebx*4 + obj_n_lhs;
        *((ebp - 0x64)) = eax;
    }
    ebx = *((ebp + 8));
    eax = strncasecmp (ebx, 0x80774b0, 4);
    al = (eax == 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x50)) = eax;
    if (eax != 0) {
        eax = skip_param (ebx);
        *((ebp + 8)) = eax;
    }
    eax = *((ebp + 8));
    if (*(eax) != 0) {
        eax = ebp - 0x1c;
        eax = parse_var2 (eax, eax);
        *((ebp + 8)) = eax;
        if (eax == 0) {
            goto label_3;
        }
        if (*(eax) == 0) {
            goto label_4;
        }
        edx = ebp + 8;
        eax = decstrtol (eax, edx);
        *((ebp - 0x58)) = eax;
        eax = *((ebp + 8));
        if (*(eax) == 0) {
            if (*((ebp - 0x58)) <= 0) {
                goto label_5;
            }
            if ((*((ebp - 0x58)) & 1) == 0) {
                goto label_6;
            }
        }
label_5:
        *(esp) = "Number of partitions must be a positive, even integer.";
        error ();
        eax = 0;
        goto label_7;
    }
    eax = ebp - 0x1c;
    eax = prompt_var (eax);
    if (eax == 0) {
        goto label_3;
    }
label_4:
    *((ebp - 0x58)) = 0x3e8;
label_6:
    ecx = *((ebp - 0x48));
    ecx = *(ecx);
    *((ebp - 0x3c)) = ecx;
    if (ecx <= 1) {
        goto label_8;
    }
    ebx = *((ebp - 0x1c));
    *((ebp - 0x38)) = ebx;
    esi = *((ebp - 0x54));
    esi += 0x20;
    eax = ecx;
    eax -= 2;
    eax >>= 1;
    eax = eax + eax + 4;
    *((ebp - 0x34)) = eax;
    edi = 2;
    *((ebp - 0x30)) = 0;
label_0:
    if (*((esi - 8)) != 4) {
        goto label_9;
    }
    edx = edi;
    if (edi >= *((ebp - 0x3c))) {
        goto label_9;
    }
    ecx = esi;
    ebx = *((esi - 0xc));
    if (*((esi + 4)) < ebx) {
        goto label_9;
    }
    eax = esi + 0x10;
    *((ebp - 0x40)) = esi;
    esi = *((ebp - 0x3c));
    *((ebp - 0x44)) = edi;
    edi = ebx;
    do {
        if (*(ecx) == 1) {
            ebx = *((ebp - 0x38));
            ecx = 1;
            if (*((ecx + 8)) != ebx) {
                ecx = *((ebp - 0x30));
            }
            *((ebp - 0x30)) = ecx;
        }
        edx++;
        if (edx >= esi) {
            goto label_10;
        }
        ecx = eax;
        ebx = *((eax + 4));
        eax += 0x10;
    } while (ebx >= edi);
    esi = *((ebp - 0x40));
    edi = *((ebp - 0x44));
    goto label_9;
label_10:
    esi = *((ebp - 0x40));
    edi = *((ebp - 0x44));
label_9:
    edi += 2;
    esi += 0x20;
    if (edi != *((ebp - 0x34))) {
        goto label_0;
    }
    if (*((ebp - 0x30)) != 0) {
        warning ("Singularity detected, result of numerical integration might be wrong.");
    }
label_8:
    *((esp + 8)) = 0x50;
    my_strlcpy (obj.prompt_str, "Enter lower bound: ");
    eax = tlhs;
    eax = get_expr (eax, 0x80796b8);
    if (eax == 0) {
        goto label_3;
    }
    *((esp + 4)) = obj.n_tlhs;
    eax = tlhs;
    subst_constants (eax);
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    eax = exp_contains_infinity (eax);
    if (eax != 0) {
        *(esp) = "Error: Bound contains infinity.";
        error ();
        eax = 0;
        goto label_7;
    }
    *((esp + 8)) = 0x50;
    my_strlcpy (obj.prompt_str, "Enter upper bound: ");
    eax = trhs;
    eax = get_expr (eax, 0x80798b4);
    if (eax == 0) {
        goto label_3;
    }
    *((esp + 4)) = obj.n_trhs;
    eax = trhs;
    subst_constants (eax);
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    eax = exp_contains_infinity (eax);
    if (eax != 0) {
        *(esp) = "Error: Bound contains infinity.";
        error ();
        eax = 0;
        goto label_7;
    }
    eax = n_tlhs;
    eax += *(obj.n_trhs);
    eax += 3;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        *((esp + 4)) = "Approximating the definite integral of the RHS\n";
        *(esp) = 1;
        printf_chk ();
    } else {
        *((esp + 4)) = "Approximating the definite integral\n";
        *(esp) = 1;
        printf_chk ();
    }
    if (*((ebp - 0x50)) != 0) {
        ebx = *((ebp - 0x58));
        *((esp + 8)) = ebx;
        *((esp + 4)) = "using the trapezoid method (%d partitions)...\n";
        *(esp) = 1;
        printf_chk ();
    } else {
        eax = *((ebp - 0x58));
        *((esp + 8)) = eax;
        *((esp + 4)) = "using Simpson's rule (%d partitions)...\n";
        *(esp) = 1;
        printf_chk ();
    }
    edx = *((ebp - 0x48));
    *((esp + 4)) = edx;
    ecx = *((ebp - 0x54));
    subst_constants (ecx);
    ebx = *((ebp - 0x48));
    eax = *((ebp - 0x54));
    simp_loop (eax, ebx);
    edx = n_trhs;
    if (edx <= 0) {
        goto label_11;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.trhs);
        *((edx + 4)) += 2;
        eax++;
        edx = n_trhs;
    } while (edx > eax);
label_11:
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 4)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 8)) = 2;
    ebx = n_trhs;
    ebx++;
    *(obj.n_trhs) = ebx;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    eax = ebx;
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, eax, eax);
    edx = n_trhs;
    edx += *(obj.n_tlhs);
    *(obj.n_trhs) = edx;
    if (ebx >= edx) {
        goto label_12;
    }
    eax = ebx;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.trhs);
        *((edx + 4)) += 2;
        ebx++;
        edx = n_trhs;
        eax += 0x10;
    } while (edx > ebx);
label_12:
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 4)) = 1;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 8)) = 4;
    eax = n_trhs;
    eax++;
    *(obj.n_trhs) = eax;
    edx = eax;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 4)) = 1;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 0;
    edx = n_trhs;
    edx <<= 4;
    *(fp_stack--) = *((ebp - 0x58));
    eax = trhs;
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    *(obj.n_trhs)++;
    eax = trhs;
    simp_loop (eax, 0x80798b4);
    eax = zero_token;
    edx = *((ebp - 0x5c));
    *(edx) = eax;
    eax = .comment;
    *((edx + 4)) = eax;
    eax = .comment;
    *((edx + 8)) = eax;
    eax = .comment;
    *((edx + 0xc)) = eax;
    *((ebp - 0x20)) = 1;
    if (*((ebp - 0x58)) < 0) {
        goto label_13;
    }
    *((ebp - 0x40)) = 0;
    *((ebp - 0x34)) = 0;
    *((ebp - 0x38)) = edx;
    edi = *((ebp - 0x5c));
label_2:
    eax = *((ebp - 0x20));
    eax++;
    ecx = *((ebp - 0x48));
    eax += *(ecx);
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp - 0x20));
    if (ecx <= 0) {
        goto label_14;
    }
    eax = *((ebp - 0x38));
    edx = 0;
    do {
        *((eax + 4))++;
        edx++;
        ecx = *((ebp - 0x20));
        eax += 0x10;
    } while (ecx > edx);
label_14:
    ecx <<= 4;
    ecx = edi + ecx;
    *((ecx + 4)) = 1;
    *(ecx) = 2;
    *((ecx + 8)) = 1;
    ebx = *((ebp - 0x20));
    ebx++;
    *((ebp - 0x20)) = ebx;
    edx = *((ebp - 0x48));
    eax = *(edx);
    eax <<= 4;
    ecx = *((ebp - 0x54));
    eax = ebx;
    eax <<= 4;
    eax = edi + eax;
    memmove (eax, ecx, eax);
    eax = *((ebp - 0x20));
    edx = *((ebp - 0x48));
    eax += *(edx);
    *((ebp - 0x20)) = eax;
    if (ebx >= eax) {
        goto label_15;
    }
    eax = ebx;
    eax <<= 4;
    edx = edi + eax + 4;
    ecx = ebx;
    do {
        *(edx) += 2;
        ecx++;
        eax = *((ebp - 0x20));
        edx += 0x10;
    } while (eax > ecx);
    if (ebx >= eax) {
        goto label_15;
    }
label_1:
    *((ebp - 0x30)) = ebx;
    esi = ebx;
    esi <<= 4;
    esi = edi + esi;
    if (*(esi) != 1) {
        goto label_16;
    }
    edx = *((esi + 8));
    if (edx != *((ebp - 0x1c))) {
        goto label_16;
    }
    ecx = *((esi + 4));
    *((ebp - 0x44)) = ecx;
    edx = n_tlhs;
    edx += *(obj.n_trhs);
    edx += 2;
    *((ebp - 0x3c)) = edx;
    eax += edx;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = ebx;
    eax = ~eax;
    eax += *((ebp - 0x20));
    eax <<= 4;
    eax = *((ebp - 0x30));
    eax <<= 4;
    eax = eax + edi + 0x10;
    edx = *((ebp - 0x3c));
    eax = edx + ebx + 1;
    eax <<= 4;
    eax = edi + eax;
    memmove (eax, eax, eax);
    ecx = *((ebp - 0x3c));
    *((ebp - 0x20)) += ecx;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    memmove (esi, eax, eax);
    eax = ebx;
    eax += *(obj.n_tlhs);
    edx = *((ebp - 0x44));
    edx++;
    if (ebx >= eax) {
        goto label_17;
    }
    esi += 4;
    do {
        *(esi) += edx;
        ebx++;
        esi += 0x10;
    } while (eax > ebx);
label_17:
    ecx = eax;
    ecx <<= 4;
    ecx = edi + ecx;
    *((ecx + 4)) = edx;
    *(ecx) = 2;
    *((ecx + 8)) = 1;
    ebx = ecx + 0x10;
    esi = edx + 1;
    *((ebx + 4)) = esi;
    *(ebx) = 0;
    *(fp_stack--) = *((ebp - 0x34));
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    ecx += 0x20;
    *((ecx + 4)) = esi;
    *(ecx) = 2;
    *((ecx + 8)) = 3;
    ebx = eax + 3;
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = ebx;
    eax <<= 4;
    eax = edi + eax;
    memmove (eax, eax, eax);
    edx = ebx;
    edx += *(obj.n_trhs);
    if (ebx >= edx) {
        goto label_18;
    }
    eax = ebx;
    eax <<= 4;
    eax = edi + eax + 4;
    do {
        *(eax) += esi;
        ebx++;
        eax += 0x10;
    } while (edx > ebx);
label_18:
    ebx = edx - 1;
label_16:
    ebx += 2;
    eax = *((ebp - 0x20));
    if (eax > ebx) {
        goto label_1;
    }
label_15:
    if (*((ebp - 0x34)) > 0) {
        ebx = *((ebp - 0x58));
        if (*((ebp - 0x34)) >= ebx) {
            goto label_19;
        }
        eax += 2;
        if (eax > *(obj.n_tokens)) {
            error_huge ();
        }
        eax = *((ebp - 0x20));
        eax <<= 4;
        eax = edi + eax;
        *((eax + 4)) = 2;
        *(eax) = 2;
        *((eax + 8)) = 3;
        eax += 0x10;
        *((eax + 4)) = 2;
        *(eax) = 0;
        if (*((ebp - 0x50)) != 0) {
            *(fp_stack--) = *(0x8072058);
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
        } else {
            if ((*((ebp - 0x34)) & 1) != 0) {
                *(fp_stack--) = *(0x8072774);
                *((eax + 8)) = fp_stack[0];
                fp_stack--;
            } else {
                *(fp_stack--) = *(0x8072058);
                *((eax + 8)) = fp_stack[0];
                fp_stack--;
            }
        }
        *((ebp - 0x20)) += 2;
    }
label_19:
    *(obj.approximate_roots) = 1;
    eax = ebp - 0x20;
    edx = *((ebp - 0x38));
    elim_loop (edx, eax);
    ecx = ebp - 0x20;
    *((esp + 4)) = ecx;
    ebx = *((ebp - 0x38));
    *(esp) = ebx;
    ufactor ();
    eax = ebp - 0x20;
    simp_divide (ebx, eax);
    *(obj.approximate_roots) = 0;
    eax = *((ebp - 0x20));
    *((esp + 4)) = eax;
    eax = exp_contains_infinity (ebx);
    if (eax != 0) {
        *(esp) = "Integration failed because result contains infinity or NaN (a singularity).";
        error ();
        eax = 0;
        goto label_7;
    }
    if (*((ebp - 0x34)) != 0) {
        if (*((ebp - 0x34)) == 1) {
            edx = *((ebp - 0x20));
            eax = 4;
            if (edx > 3) {
                eax = edx;
            }
            *((ebp - 0x40)) = eax;
        } else {
            eax = *((ebp - 0x20));
            edx = eax + 7;
            __asm ("cmovs eax, edx");
            eax >>= 3;
            if (*((ebp - 0x40)) > eax) {
                goto label_20;
            }
            *(esp) = "Integration failed.";
            error ();
            eax = 0;
            goto label_7;
        }
    }
label_20:
    *((ebp - 0x34))++;
    ecx = *((ebp - 0x34));
    if (*((ebp - 0x58)) >= ecx) {
        goto label_2;
    }
label_13:
    eax = *((ebp - 0x20));
    eax += *(obj.n_trhs);
    eax += 3;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp - 0x20));
    if (ecx <= 0) {
        goto label_21;
    }
    eax = *((ebp - 0x5c));
    edx = 0;
    do {
        *((eax + 4))++;
        edx++;
        ecx = *((ebp - 0x20));
        eax += 0x10;
    } while (ecx > edx);
label_21:
    eax = ecx;
    eax <<= 4;
    eax += *((ebp - 0x5c));
    *((eax + 4)) = 1;
    *(eax) = 2;
    *((eax + 8)) = 4;
    eax += 0x10;
    *((eax + 4)) = 1;
    *(eax) = 0;
    if (*((ebp - 0x50)) != 0) {
        *(fp_stack--) = *(0x8072058);
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
    } else {
        *(fp_stack--) = *(0x807205c);
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
    }
    eax += 0x10;
    *((eax + 4)) = 1;
    *(eax) = 2;
    *((eax + 8)) = 3;
    ebx = *((ebp - 0x20));
    ebx += 3;
    *((ebp - 0x20)) = ebx;
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp - 0x5c));
    memmove (eax, eax, eax);
    eax = n_trhs;
    eax += *((ebp - 0x20));
    *((ebp - 0x20)) = eax;
    if (ebx >= eax) {
        goto label_22;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp - 0x5c));
    eax = edx + eax + 4;
    do {
        *(eax)++;
        ebx++;
        eax += 0x10;
    } while (*((ebp - 0x20)) > ebx);
label_22:
    *(obj.approximate_roots) = 1;
    ebx = ebp - 0x20;
    ecx = *((ebp - 0x5c));
    elim_loop (ecx, ebx);
    *((esp + 4)) = ebx;
    eax = *((ebp - 0x5c));
    *(esp) = eax;
    ufactor ();
    edx = *((ebp - 0x5c));
    simp_divide (edx, ebx);
    *(obj.approximate_roots) = 0;
    *((esp + 4)) = "Numerical integration successful:\n";
    *(esp) = 1;
    printf_chk ();
    eax = *((ebp - 0x20));
    ecx = *((ebp - 0x64));
    *(ecx) = eax;
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        ebx = n_lhs;
        edx = *((ebx + eax*4));
        edx <<= 4;
        edx = lhs;
        eax = *((edx + eax*4));
        ecx = *((ebp - 0x4c));
        eax = *((edx + ecx*4));
        memmove (eax, eax, edx);
        eax = cur_equation;
        eax = *((ebx + eax*4));
        edx = *((ebp - 0x4c));
        *((ebx + edx*4)) = eax;
        if (*((ebp - 0x60)) == 0) {
            goto label_23;
        }
        eax = isvarchar (0x27);
        if (eax == 0) {
            goto label_23;
        }
        ecx = *((ebp - 0x4c));
        eax = *((ecx*4 + obj.lhs));
        eax = *((eax + 8));
        eax = list_var (eax, 0);
        if (eax > 0) {
            eax--;
            if (*((eax + obj.var_str)) != 0x27) {
                goto label_24;
            }
            *((eax + obj.var_str)) = 0;
        }
label_24:
        *((esp + 4)) = obj.var_str;
        ebx = *((ebp - 0x4c));
        eax = *((ebx*4 + obj.lhs));
        eax += 8;
        parse_var (eax);
    }
label_23:
    eax = *((ebp - 0x4c));
    *(obj.cur_equation) = eax;
    return_result (eax);
    goto label_7;
label_3:
    eax = 0;
label_7:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d882 */
#include <stdint.h>
 
int32_t dbg_complex_add (int32_t arg_8h) {
    complexs a;
    complexs b;
    /* complexs complex_add(complexs a,complexs b); */
    eax = *((ebp + 8));
    *(fp_stack--) = *((ebp + 0xc));
    fp_stack[0] += *((ebp + 0x1c));
    *(fp_stack--) = *((ebp + 0x14));
    fp_stack[0] += *((ebp + 0x24));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8054457 */
#include <stdint.h>
 
int32_t dbg_compare_es (int32_t arg_8h, char * arg_ch, int32_t i, int32_t j, int32_t rv) {
    int32_t diff_sign;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    int32_t var_10h;
    ebx = i;
    esi = j;
    eax = rv;
    /* int compare_es(int i,int j); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = *((ebx*4 + obj.n_lhs));
    if (eax != 0) {
        edx = *((esi*4 + obj.n_lhs));
        if (edx != 0) {
            *(obj.sign_cmp_flag) = 1;
            ecx = ebp - 0xc;
            *((esp + 0x10)) = ecx;
            *((esp + 0xc)) = edx;
            edx = lhs;
            ecx = *((edx + esi*4));
            *((esp + 8)) = ecx;
            *((esp + 4)) = eax;
            eax = *((edx + ebx*4));
            *(esp) = eax;
            eax = se_compare ();
            *(obj.sign_cmp_flag) = 0;
            if (eax == 0) {
                goto label_0;
            }
            if (*((ebp - 0xc)) != 0) {
                goto label_0;
            }
            eax = *((ebx*4 + obj.n_rhs));
            if (eax == 0) {
                al = (*((esi*4 + obj.n_rhs)) == 0) ? 1 : 0;
                eax = (int32_t) al;
                goto label_1;
            }
            edx = *((esi*4 + obj.n_rhs));
            if (edx == 0) {
                goto label_0;
            }
            *(obj.sign_cmp_flag) = 1;
            ecx = ebp - 0xc;
            *((esp + 0x10)) = ecx;
            *((esp + 0xc)) = edx;
            edx = rhs;
            ecx = *((edx + esi*4));
            *((esp + 8)) = ecx;
            *((esp + 4)) = eax;
            eax = *((edx + ebx*4));
            *(esp) = eax;
            eax = se_compare ();
            *(obj.sign_cmp_flag) = 0;
            if (eax == 0) {
                goto label_0;
            }
            al = (*((ebp - 0xc)) == 0) ? 1 : 0;
            eax = (int32_t) al;
        }
    } else {
label_0:
        eax = 0;
    }
label_1:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805037e */
#include <stdint.h>
 
int32_t dbg_my_strlcpy (char * arg_ch, size_t arg_10h) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * dest;
    void * s2;
    size_t n;
    /* int my_strlcpy(char * dest,char * src,int n); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edx = *((ebp + 0xc));
    edi = *((ebp + 0xc));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    esi = ecx - 1;
    ebx = *((ebp + 0x10));
    ebx--;
    if (esi <= ebx) {
        ebx = esi;
    }
    eax = *((ebp + 8));
    memmove (eax, edx, ebx);
    eax = *((ebp + 8));
    *((eax + ebx)) = 0;
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804e8f0 */
#include <stdint.h>
 
int32_t dbg_shell_out (char * string, int32_t rv) {
    int32_t var_4h;
    ebx = rv;
    /* int shell_out(char * cp); */
    if (*(obj.security_level) != 0) {
        error_bug ("Shelling out disabled.");
    }
    reset_attr ();
    errno_location ();
    *(eax) = 0;
    eax = *((ebp + 8));
    eax = system (eax);
    ebx = eax;
    *((esp + 4)) = 0x80757fd;
    *(esp) = 1;
    printf_chk ();
    if (ebx < 0) {
        perror ("system(3) call failed");
    }
    default_color ();
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8050598 */
#include <stdint.h>
 
int32_t dbg_give_priority (int32_t arg_8h, char * arg_ch, int32_t i, token_type * equation, int * np) {
    int32_t var_1ch;
    int32_t var_4h;
    int32_t var_8h;
    ebx = i;
    esi = equation;
    edi = np;
    /* void give_priority(token_type * equation,int * np); */
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    eax = *(edi);
    if (eax <= 1) {
        goto label_1;
    }
    ebx = 1;
    do {
        edx = 1;
        edx <<= 4;
        if (*((esi + edx + 8)) == 7) {
            *((esp + 8)) = ebx;
            *((esp + 4)) = eax;
            binary_parenthesize (esi);
        }
        ebx += 2;
        eax = *(edi);
    } while (eax > ebx);
label_1:
    if (*(obj.right_associative_power) == 0) {
        eax = *(edi);
        ebx = 1;
        if (eax > 1) {
            goto label_2;
        }
        goto label_3;
    }
    ebx = eax - 2;
    if (ebx <= 0) {
        goto label_0;
    }
    eax = ebx;
    eax <<= 4;
    eax = esi + eax + 8;
    *((ebp - 0x1c)) = eax;
    do {
        eax = *((ebp - 0x1c));
        if (*(eax) == 6) {
            *((esp + 8)) = ebx;
            eax = *(edi);
            *((esp + 4)) = eax;
            binary_parenthesize (esi);
        }
        ebx -= 2;
        *((ebp - 0x1c)) -= 0x20;
    } while (ebx > 0);
label_0:
    eax = *(edi);
    ebx = 1;
    if (eax > 1) {
        goto label_4;
    }
    goto label_3;
    do {
label_2:
        edx = ebx;
        edx <<= 4;
        if (*((esi + edx + 8)) == 6) {
            *((esp + 8)) = ebx;
            *((esp + 4)) = eax;
            binary_parenthesize (esi);
        }
        ebx += 2;
        eax = *(edi);
    } while (eax > ebx);
    goto label_0;
    do {
label_4:
        edx = ebx;
        edx <<= 4;
        if (*((esi + edx + 8)) <= 9) {
            ecx = *((esi + edx + 8));
            edx = 1;
            edx <<= cl;
            if ((edx & 0x238) == 0) {
                goto label_5;
            }
            *((esp + 8)) = ebx;
            *((esp + 4)) = eax;
            binary_parenthesize (esi);
        }
label_5:
        ebx += 2;
        eax = *(edi);
    } while (eax > ebx);
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057eb0 */
#include <stdint.h>
 
int32_t dbg_eliminate_cmd (int32_t arg_8h, int32_t i, int32_t using_flag, long int v1) {
    int32_t did_something;
    char * cp_start;
    int32_t success_flag;
    int32_t var_2038h;
    int32_t vc;
    int32_t var_2030h;
    char * cp;
    long int[1000] va;
    long int v;
    char[4096] buf;
    char[100] used;
    uint32_t canary;
    char * var_4h;
    int32_t var_8h;
    ebx = i;
    esi = using_flag;
    eax = v1;
    /* int eliminate_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x202c)) = eax;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    edx = ebp - 0x80;
    ecx = 0x19;
    edi = edx;
    memset (edi, eax, ecx);
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_2;
    }
    *((esp + 4)) = "repeat";
    eax = *((ebp - 0x202c));
    eax = strcmp_tospace (eax);
    if (eax == 0) {
        *(obj.repeat_flag) = 1;
        eax = *((ebp - 0x202c));
        eax = skip_param (eax);
        *((ebp - 0x202c)) = eax;
    }
    eax = *((ebp - 0x202c));
    if (*(eax) == 0) {
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter variables to eliminate: ");
        eax = ebp - 0x1080;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x202c)) = eax;
        if (eax == 0) {
            goto label_2;
        }
        if (*(eax) == 0) {
            goto label_2;
        }
    }
    edx = *((ebp - 0x202c));
    *((ebp - 0x2040)) = edx;
    *((ebp - 0x2044)) = 0;
    *((ebp - 0x203c)) = 0;
    ebx = 0;
    *((ebp - 0x2034)) = 0;
label_0:
    if (*((ebp - 0x2034)) != 0) {
        *((ebp - 0x2034))--;
        ecx = *((ebp - 0x2034));
        eax = *((ebp + ecx*4 - 0x2024));
        *((ebp - 0x1084)) = eax;
        goto label_3;
    }
    eax = *((ebp - 0x202c));
    if (*(eax) == 0) {
        goto label_4;
    }
    *(esp) = eax;
    eax = is_all ();
    if (eax == 0) {
        goto label_5;
    }
    eax = *((ebp - 0x202c));
    eax = skip_param (eax);
    *((ebp - 0x202c)) = eax;
    eax = cur_equation;
    *((ebp - 0x2038)) = eax;
    edi = *((eax*4 + obj.n_lhs));
    *((ebp - 0x2030)) = 0;
    goto label_6;
label_1:
    *((ebp - 0x2030)) = eax;
label_6:
    eax = 0xffffffff;
    if (edi <= 0) {
        goto label_7;
    }
    ecx = *((ebp - 0x2038));
    eax = lhs;
    edx = *((eax + ecx*4));
    ecx = 0;
    ebx = 0xffffffff;
    esi = *((ebp - 0x2030));
    do {
        if (*(edx) == 1) {
            eax = *((edx + 8));
            if (esi < eax) {
                if (ebx == -1) {
                    goto label_8;
                }
                if (eax > ebx) {
                    eax = ebx;
                }
            }
        } else {
            eax = ebx;
        }
label_8:
        ecx += 2;
        edx += 0x20;
        if (ecx >= edi) {
            goto label_7;
        }
        ebx = eax;
    } while (1);
label_7:
    edx = *((ebp - 0x2038));
    esi = *((edx*4 + obj.n_rhs));
    ebx = 0;
    if (esi <= 0) {
        goto label_9;
    }
    edx = *((edx*4 + obj.rhs));
    do {
        if (*(edx) == 1) {
            ecx = *((edx + 8));
            if (*((ebp - 0x2030)) < ecx) {
                if (eax == -1) {
                    goto label_10;
                }
                if (ecx > eax) {
                    ecx = eax;
                }
            }
        } else {
            ecx = eax;
        }
label_10:
        ebx += 2;
        edx += 0x20;
        if (esi <= ebx) {
            goto label_11;
        }
        eax = ecx;
    } while (1);
label_11:
    eax = ecx;
label_9:
    if (eax == -1) {
        goto label_0;
    }
    edx = eax;
    edx &= 0x3fff;
    if (edx <= 4) {
        goto label_1;
    }
    if (*((ebp - 0x2034)) > 0x3e7) {
        goto label_0;
    }
    edx = *((ebp - 0x2034));
    *((ebp + edx*4 - 0x2024)) = eax;
    edx++;
    *((ebp - 0x2034)) = edx;
    goto label_1;
label_5:
    eax = *((ebp - 0x202c));
    ecx = ebp - 0x1084;
    eax = parse_var2 (ecx, eax);
    *((ebp - 0x202c)) = eax;
    if (eax == 0) {
        goto label_2;
label_4:
        if (*(obj.repeat_flag) != 0) {
            if (*((ebp - 0x203c)) == 0) {
                goto label_12;
            }
            eax = *((ebp - 0x2040));
            *((ebp - 0x202c)) = eax;
            *((ebp - 0x203c)) = 0;
            goto label_0;
        }
label_12:
        if (*((ebp - 0x2044)) != 0) {
            eax = cur_equation;
            eax = return_result (eax);
            *((ebp - 0x2044)) = eax;
            goto label_13;
        }
        *(esp) = "No substitutions made.";
        error ();
        goto label_13;
    }
label_3:
    *((esp + 4)) = "using";
    eax = *((ebp - 0x202c));
    eax = strcmp_tospace (eax);
    al = (eax == 0) ? 1 : 0;
    esi = (int32_t) al;
    if (esi != 0) {
        eax = *((ebp - 0x202c));
        eax = skip_param (eax);
        *((ebp - 0x202c)) = eax;
        edx = ebp - 0x202c;
        decstrtol (eax, edx);
        ebx = eax - 1;
        eax = not_defined (ebx);
        if (eax != 0) {
            goto label_2;
        }
    }
    eax = *((ebp - 0x1084));
    eax = cur_equation;
    eax = var_in_equation (eax, eax);
    if (eax != 0) {
        goto label_14;
    }
    if (*(obj.repeat_flag) != 0) {
        goto label_0;
    }
    eax = *((ebp - 0x1084));
    list_var (eax, 0);
    *((esp + 8)) = 0x8079800;
    *((esp + 4)) = "Variable (%s) not found in current equation.\n";
    *(esp) = 1;
    printf_chk ();
    goto label_0;
label_14:
    if (esi == 0) {
        goto label_15;
    }
    edx = *((ebp - 0x1084));
    eax = ebx;
    eax = elim_sub ();
    if (eax == 0) {
        goto label_0;
    }
    goto label_16;
label_15:
    ebx = cur_equation;
    eax = n_equations;
    if (eax <= 1) {
        goto label_0;
    }
    esi = 1;
    edi = n_lhs;
    do {
        eax--;
        edx = ebx - 1;
        ebx = eax;
        if (ebx > 0) {
            ebx = edx;
        }
        if (*((ebp + ebx - 0x80)) == 0) {
            if (*((edi + ebx*4)) == 0) {
                goto label_17;
            }
            if (*((ebx*4 + obj.n_rhs)) == 0) {
                goto label_17;
            }
            eax = *((ebp - 0x1084));
            eax = var_in_equation (ebx, eax);
            if (eax == 0) {
                goto label_17;
            }
            edx = *((ebp - 0x1084));
            eax = ebx;
            eax = elim_sub ();
            if (eax != 0) {
                goto label_16;
            }
        }
label_17:
        esi++;
        eax = n_equations;
    } while (eax > esi);
    goto label_0;
label_16:
    *((ebp + ebx - 0x80)) = 1;
    *((ebp - 0x2044)) = 1;
    *((ebp - 0x203c)) = 1;
    goto label_0;
label_2:
    *((ebp - 0x2044)) = 0;
label_13:
    eax = *((ebp - 0x2044));
    ecx = *((ebp - 0x1c));
    ecx ^= *(gs:0x14);
    if (eax != esi) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806b21f */
#include <stdint.h>
 
int32_t dbg_make_powers (int32_t level, int32_t i) {
    int32_t var_1ch;
    token_type * equation;
    int * np;
    long int v;
    void * s2;
    size_t n;
    esi = level;
    eax = i;
    /* void make_powers(token_type * equation,int * np,long int v); */
    eax = 0;
    goto label_1;
label_0:
    edi = eax;
    ebx = eax;
    ebx <<= 4;
    ebx += *((ebp + 8));
    esi = *((ebx + 4));
    ecx = *(ebx);
    if (ecx != 2) {
        goto label_2;
    }
    if (*((ebx + 8)) != 6) {
        goto label_2;
    }
    ecx = eax + 2;
    if (edx <= ecx) {
        goto label_3;
    }
    ebx = ecx;
    ebx <<= 4;
    edi = *((ebp + 8));
    if (esi > *((ebx + edi + 4))) {
        goto label_3;
    }
    eax <<= 4;
    eax = edi + eax + 0x44;
    do {
        ecx += 2;
        if (edx <= ecx) {
            goto label_3;
        }
        ebx = *(eax);
        eax += 0x20;
    } while (esi <= ebx);
    goto label_3;
label_2:
    if (ecx == 1) {
        ecx = *((ebp + 0x10));
        if (*((ebx + 8)) != ecx) {
            goto label_4;
        }
        ecx = eax + 1;
        *((ebp - 0x1c)) = ecx;
        if (edx > ecx) {
            edi++;
            edi <<= 4;
            ecx = *((ebp + 8));
            if (*((edi + ecx + 8)) == 6) {
                goto label_4;
            }
        }
        edx += 2;
        if (edx > *(obj.n_tokens)) {
            error_huge ();
        }
        esi++;
        *((ebx + 4)) = esi;
        ebx = *((ebp - 0x1c));
        ebx <<= 4;
        ebx += *((ebp + 8));
        edi = *((ebp + 0xc));
        eax = *(edi);
        eax -= *((ebp - 0x1c));
        eax <<= 4;
        eax = *((ebp - 0x1c));
        eax <<= 4;
        edx = *((ebp + 8));
        eax = eax + edx + 0x20;
        memmove (eax, ebx, eax);
        *(edi) += 2;
        *((ebx + 4)) = esi;
        *(ebx) = 2;
        *((ebx + 8)) = 6;
        eax = *((ebp - 0x1c));
        eax++;
        edx = eax;
        edx <<= 4;
        edx += *((ebp + 8));
        *((edx + 4)) = esi;
        *(edx) = 0;
        *(fp_stack--) = 1.0;
        *((edx + 8)) = fp_stack[0];
        fp_stack--;
    }
label_4:
    ecx = eax + 1;
label_3:
    eax = ecx;
label_1:
    ecx = *((ebp + 0xc));
    edx = *(ecx);
    if (eax < edx) {
        goto label_0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80717c4 */
#include <stdint.h>
 
uint32_t dbg_factor_int_sub (int32_t arg_8h, int32_t n) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    ebx = n;
    /* void factor_int_sub(int n); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    if (*((ebx*4 + obj.n_lhs)) > 0) {
        esi = ebx*4;
        eax = esi + obj_n_lhs;
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *(esp) = eax;
        factor_int ();
        esi += obj.n_rhs;
        *((esp + 4)) = esi;
        eax = *((ebx*4 + obj.rhs));
        *(esp) = eax;
        factor_int ();
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x807157c */
#include <stdint.h>
 
int32_t dbg_factor_int (int32_t xsize, int32_t i, int32_t j) {
    int32_t level;
    int32_t var_20h;
    int32_t modified;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    ebx = xsize;
    esi = i;
    edi = j;
    /* int factor_int(token_type * equation,int * np); */
    *((ebp - 0x1c)) = 0;
    ebx = 0;
    eax = *((ebp + 0xc));
    if (*(eax) <= 0) {
        goto label_2;
    }
label_0:
    esi = ebx;
    esi <<= 4;
    esi += *((ebp + 8));
    if (*(esi) != 0) {
        goto label_3;
    }
    *(fp_stack--) = *((esi + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = factor_one ();
    if (eax == 0) {
        goto label_3;
    }
    edi = uno;
    if (edi <= 0) {
        goto label_3;
    }
    if (edi == 1) {
        edx = ucnt;
        if (*(edx) > 1) {
            goto label_4;
        }
        goto label_3;
    }
    esi = *((esi + 4));
    *((ebp - 0x24)) = esi;
    if (edi > 1) {
        ecx = *((ebp + 0xc));
        al = (*(ecx) >= 2) ? 1 : 0;
        eax = (int32_t) al;
        *((ebp - 0x24)) += eax;
    }
label_1:
    edx = 0xfffffffe;
    eax = 0;
    do {
        ecx = edx + 4;
        edx += 2;
        if (*((eax*4 + obj.ucnt)) >= 2) {
            edx = ecx;
        }
        eax++;
    } while (eax != edi);
    eax = *((ebp + 0xc));
    edx += *(eax);
    while (*(obj.uno) > 0) {
        edi = 0;
        edx = *((ebp - 0x24));
        edx++;
        *((ebp - 0x20)) = edx;
        esi = ebx;
        goto label_5;
        error_huge ();
    }
    goto label_6;
    do {
label_5:
        *((ebp - 0x1c)) = edi;
        bl = (*((edi*4 + obj.ucnt)) > 1) ? 1 : 0;
        ebx = (int32_t) bl;
        ebx = ebx + ebx + 2;
        eax = ebx - 2;
        if (edi == 0) {
            ebx = eax;
        }
        if (ebx > 0) {
            ecx = *((ebp + 0xc));
            eax = *(ecx);
            eax -= esi;
            eax <<= 4;
            eax = esi;
            eax <<= 4;
            eax += *((ebp + 8));
            eax = ebx + esi;
            eax <<= 4;
            eax += *((ebp + 8));
            memmove (eax, eax, eax);
            eax = *((ebp + 0xc));
            *(eax) += ebx;
            if (edi <= 0) {
                goto label_7;
            }
            eax = esi;
            eax <<= 4;
            edx = *((ebp + 8));
            eax = eax + edx + 0x10;
            *(eax) = 2;
            ecx = *((ebp - 0x24));
            *((eax + 4)) = ecx;
            *((eax + 8)) = 3;
            esi += 2;
        }
label_7:
        eax = esi;
        eax <<= 4;
        eax += *((ebp + 8));
        *(eax) = 0;
        edx = *((ebp - 0x24));
        *((eax + 4)) = edx;
        ecx = *((ebp - 0x1c));
        *(fp_stack--) = *((ecx*8 + obj.unique));
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
        edx = ucnt;
        if (*((edx + ecx*4)) > 1) {
            ecx = *((ebp - 0x20));
            *((eax + 4)) = ecx;
            eax = esi;
            eax <<= 4;
            edx = *((ebp + 8));
            eax = eax + edx + 0x10;
            *(eax) = 2;
            *((eax + 4)) = ecx;
            *((eax + 8)) = 6;
            esi += 2;
            eax = esi;
            eax <<= 4;
            eax += edx;
            *((eax + 4)) = ecx;
            *(eax) = 0;
            ecx = *((ebp - 0x1c));
            edx = ucnt;
            *(fp_stack--) = *((edx + ecx*4));
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
        }
        edi++;
    } while (*(obj.uno) > edi);
    ebx = esi;
label_6:
    *((ebp - 0x1c)) = 1;
label_3:
    ebx += 2;
    ecx = *((ebp + 0xc));
    if (*(ecx) > ebx) {
        goto label_0;
    }
label_2:
    eax = *((ebp - 0x1c));
    return eax;
label_4:
    esi = *((esi + 4));
    *((ebp - 0x24)) = esi;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b3e4 */
#include <stdint.h>
 
int32_t dbg_set_sign_array (int32_t i, int32_t j) {
    uint32_t var_14h;
    int32_t var_10h;
    ebx = i;
    ecx = j;
    /* void set_sign_array(); */
    edi = sign_array;
    edx = 0x40;
    eax = 0;
    if ((edi & 1) != 0) {
        *(edi) = al;
        edi++;
        edx--;
    }
    if ((edi & 2) != 0) {
        *(edi) = ax;
        edi += 2;
        edx -= 2;
    }
    ecx = edx;
    ecx >>= 2;
    memset (edi, eax, ecx);
    if ((dl & 2) != 0) {
        *(edi) = ax;
        edi += 2;
    }
    if ((dl & 1) != 0) {
        *(edi) = al;
    }
    eax = n_equations;
    *((ebp - 0x14)) = eax;
    if (eax <= 0) {
        goto label_1;
    }
    ebx = 0;
label_0:
    ecx = *((ebx*4 + obj.n_lhs));
    if (ecx <= 0) {
        goto label_2;
    }
    eax = *((ebx*4 + obj.lhs));
    edx = 0;
    *((ebp - 0x10)) = ebx;
    do {
        if (*(eax) == 1) {
            esi = *((eax + 8));
            edi = *((eax + 8));
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_3;
            }
            esi >>= 0xe;
            esi &= 0x3f;
            *((esi + obj.sign_array)) = 1;
        }
label_3:
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
    edi = *((ebp - 0x10));
    ecx = *((edi*4 + obj.n_rhs));
    if (ecx <= 0) {
        goto label_2;
    }
    eax = *((edi*4 + obj.rhs));
    edx = 0;
    do {
        if (*(eax) == 1) {
            esi = *((eax + 8));
            edi = *((eax + 8));
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_4;
            }
            esi >>= 0xe;
            esi &= 0x3f;
            *((esi + obj.sign_array)) = 1;
        }
label_4:
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
label_2:
    ebx++;
    if (ebx != *((ebp - 0x14))) {
        goto label_0;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8050c67 */
#include <stdint.h>
 
int32_t dbg_parse_section (int32_t arg_8h, int32_t arg_ch, uint32_t arg_14h, char * cp1, int32_t cur_level) {
    int32_t abs_count;
    size_t * var_58h;
    int32_t operand;
    int32_t var_50h;
    int32_t var_4ch;
    int[10] abs_array;
    char * cp;
    char * endptr;
    size_t * n;
    ebx = cp1;
    edx = cur_level;
    /* char * parse_section(token_type * equation,int * np,char * cp,int allow_space); */
    eax = *((ebp + 0x10));
    *((ebp - 0x58)) = eax;
    if (eax == 0) {
        goto label_1;
    }
    *((ebp - 0x5c)) = 0;
    *((ebp - 0x54)) = 0;
    *((ebp - 0x50)) = 1;
    *((ebp - 0x4c)) = 0;
label_0:
    eax = n_tokens;
    eax -= 0xa;
    if (*((ebp - 0x4c)) > eax) {
        error_huge ();
    }
    eax = *((ebp + 0x10));
    edx = *(eax);
    if (dl != 0x29) {
        if (dl <= 0x29) {
            if (dl == 0x20) {
                goto label_2;
            }
            if (dl <= 0x20) {
                if (dl == 9) {
                    goto label_2;
                }
                if (dl == 0xa) {
                    goto label_3;
                }
                if (dl == 0) {
                    goto label_3;
                }
                goto label_4;
            }
            if (dl != 0x28) {
                goto label_4;
            }
        } else {
            if (dl == 0x3d) {
                goto label_3;
            }
            if (dl <= 0x3d) {
                if (dl != 0x3b) {
                    goto label_4;
                }
                goto label_3;
            }
            if (dl == 0x7b) {
                goto label_5;
            }
            if (dl != 0x7d) {
                goto label_4;
            }
            goto label_6;
        }
label_5:
        if (*((ebp - 0x54)) != 0) {
            eax = *((ebp - 0x4c));
            eax <<= 4;
            eax += *((ebp + 8));
            edx = *((ebp - 0x50));
            *((eax + 4)) = edx;
            *(eax) = 2;
            *((eax + 8)) = 3;
            *((ebp - 0x4c))++;
            *((ebp - 0x54)) = 0;
        }
        *((ebp - 0x50))++;
        goto label_7;
    }
label_6:
    *((ebp - 0x50))--;
    if (*((ebp - 0x50)) > 0) {
        if (*((ebp - 0x5c)) <= 0) {
            goto label_8;
        }
        ebx = *((ebp - 0x50));
        ecx = *((ebp - 0x5c));
        if (ebx >= *((ebp + ecx*4 - 0x44))) {
            goto label_8;
        }
    }
    *((esp + 4)) = "Unmatched parenthesis: too many )";
    eax -= *((ebp - 0x58));
    put_up_arrow (eax);
    eax = 0;
    goto label_9;
label_8:
    if (*((ebp - 0x54)) != 0) {
        goto label_7;
    }
    goto label_10;
label_2:
    if (*((ebp + 0x14)) != 0) {
        goto label_7;
    }
    goto label_3;
label_4:
    cl = (*((ebp - 0x54)) == 0) ? 1 : 0;
    ecx = (int32_t) cl;
    *((ebp - 0x54)) = ecx;
    ecx = edx - 0x21;
    if (cl > 0x5b) {
        goto label_11;
    }
    ecx = (int32_t) cl;
    /* switch table (92 cases) at 0x80754e0 */
    if (*((ebp - 0x54)) != 0) {
        if (*((ebp - 0x5c)) > 9) {
            *(esp) = "Too many nested absolute values.";
            error ();
            eax = 0;
            goto label_9;
        }
        *((ebp - 0x50)) += 3;
        edx = *((ebp - 0x50));
        eax = *((ebp - 0x5c));
        *((ebp + eax*4 - 0x40)) = edx;
        eax++;
        *((ebp - 0x5c)) = eax;
    } else {
        if (*((ebp - 0x5c)) <= 0) {
            goto label_10;
        }
        *((ebp - 0x5c))--;
        ecx = *((ebp - 0x5c));
        eax = *((ebp + ecx*4 - 0x40));
        if (eax != *((ebp - 0x50))) {
            goto label_10;
        }
        ecx = eax - 1;
        edx = *((ebp - 0x4c));
        edx <<= 4;
        edx += *((ebp + 8));
        *((edx + 4)) = ecx;
        *(edx) = 2;
        *((edx + 8)) = 6;
        edx = *((ebp - 0x4c));
        edx <<= 4;
        ebx = *((ebp + 8));
        edx = edx + ebx + 0x10;
        *((edx + 4)) = ecx;
        *(edx) = 0;
        *(fp_stack--) = *(0x8072058);
        *((edx + 8)) = fp_stack[0];
        fp_stack--;
        ecx = eax - 2;
        edx = *((ebp - 0x4c));
        edx <<= 4;
        edx = edx + ebx + 0x20;
        *((edx + 4)) = ecx;
        *(edx) = 2;
        *((edx + 8)) = 6;
        edx = *((ebp - 0x4c));
        edx <<= 4;
        edx = edx + ebx + 0x30;
        *((edx + 4)) = ecx;
        *(edx) = 0;
        *(fp_stack--) = *(0x8072054);
        *((edx + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x4c)) += 4;
        eax -= 3;
        *((ebp - 0x50)) = eax;
    }
    al = (*((ebp - 0x54)) == 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x54)) = eax;
    goto label_7;
    if (*((ebp - 0x54)) != 0) {
        goto label_10;
    }
    if (*((eax + 1)) == 0x21) {
        if (*((eax + 2)) == 0x21) {
            goto label_12;
        }
        warning ("Multifactorial not implemented, using x!! = (x!)!");
    }
label_12:
    eax = *((ebp - 0x4c));
    eax <<= 4;
    eax += *((ebp + 8));
    edx = *((ebp - 0x50));
    *((eax + 4)) = edx;
    *(eax) = 2;
    *((eax + 8)) = 7;
    eax = *((ebp - 0x4c));
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x10;
    *((eax + 4)) = edx;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    *((ebp - 0x4c)) += 2;
    *((ebp - 0x54)) = 1;
    goto label_7;
    do {
        if (*((ebp - 0x54)) != 0) {
            goto label_10;
        }
        eax = *((ebp - 0x4c));
        eax <<= 4;
        eax += *((ebp + 8));
        edx = *((ebp - 0x50));
        *((eax + 4)) = edx;
        *(eax) = 2;
        *((eax + 8)) = 6;
        *((ebp - 0x4c))++;
        goto label_7;
        eax++;
        if (*(eax) != 0x2a) {
            goto label_13;
        }
        *((ebp + 0x10)) = eax;
    } while (1);
label_13:
    if (*((ebp - 0x54)) != 0) {
        goto label_10;
    }
    eax = *((ebp - 0x4c));
    eax <<= 4;
    eax += *((ebp + 8));
    ecx = *((ebp - 0x50));
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 3;
    *((ebp - 0x4c))++;
    goto label_7;
    if (*((ebp - 0x54)) != 0) {
        goto label_10;
    }
    eax++;
    if (*(eax) == 0x2f) {
        *((ebp + 0x10)) = eax;
        eax = *((ebp - 0x4c));
        eax <<= 4;
        eax += *((ebp + 8));
        ebx = *((ebp - 0x50));
        *((eax + 4)) = ebx;
        *(eax) = 2;
        *((eax + 8)) = 9;
    } else {
        eax = *((ebp - 0x4c));
        eax <<= 4;
        eax += *((ebp + 8));
        edx = *((ebp - 0x50));
        *((eax + 4)) = edx;
        *(eax) = 2;
        *((eax + 8)) = 4;
    }
    *((ebp - 0x4c))++;
    goto label_7;
    if (*((ebp - 0x54)) != 0) {
        goto label_10;
    }
    eax = *((ebp - 0x4c));
    eax <<= 4;
    eax += *((ebp + 8));
    ecx = *((ebp - 0x50));
    *((eax + 4)) = ecx;
    *(eax) = 2;
    *((eax + 8)) = 5;
    *((ebp - 0x4c))++;
    goto label_7;
    if (*((ebp - 0x54)) == 0) {
        eax = *((ebp - 0x4c));
        eax <<= 4;
        eax += *((ebp + 8));
        ebx = *((ebp - 0x50));
        *((eax + 4)) = ebx;
        *(eax) = 2;
        edx = *((ebp + 0x10));
        dl = (*(edx) != 0x2b) ? 1 : 0;
        edx = (int32_t) dl;
        edx++;
        *((eax + 8)) = edx;
        *((ebp - 0x4c))++;
    }
    esi = *((ebp + 0x10));
    edi = 0x80751ce;
    ecx = 3;
    __asm ("repe cmpsb byte [esi], byte ptr es:[edi]");
    dl = (*((ebp - 0x4c)) > 0) ? 1 : 0;
    al = (*((ebp - 0x4c)) < 0) ? 1 : 0;
    if (dl == al) {
        eax = *((ebp - 0x4c));
        eax <<= 4;
        eax += *((ebp + 8));
        edx = *((ebp - 0x50));
        *((eax + 4)) = edx;
        *(eax) = 1;
        eax += 8;
        next_sign (eax);
        eax = *((ebp - 0x4c));
        eax <<= 4;
        ecx = *((ebp + 8));
        eax = eax + ecx + 0x10;
        ebx = *((ebp - 0x50));
        *((eax + 4)) = ebx;
        *(eax) = 2;
        *((eax + 8)) = 3;
        *((ebp - 0x4c)) += 2;
        *((ebp + 0x10)) += 2;
        *((ebp - 0x54)) = 0;
    } else {
        if (*((ebp - 0x54)) == 0) {
            goto label_7;
        }
        goto label_14;
        if (*((ebp - 0x54)) == 0) {
            eax = *((ebp - 0x4c));
            eax <<= 4;
            eax += *((ebp + 8));
            edx = *((ebp - 0x50));
            *((eax + 4)) = edx;
            *(eax) = 2;
            *((eax + 8)) = 3;
            *((ebp - 0x4c))++;
            *((ebp - 0x54)) = 1;
        }
label_14:
        esi = *((ebp + 0x10));
        if (*(esi) == 0x2d) {
            if (*(obj.negate_highest_precedence) != 0) {
                eax = ctype_b_loc ();
                edx = *((esi + 1));
                ecx = (int32_t) dl;
                eax = *(eax);
                if ((*((eax + ecx*2 + 1)) & 8) != 0) {
                    goto label_15;
                }
                if (dl == 0x2e) {
                    goto label_15;
                }
            }
            eax = *((ebp - 0x4c));
            eax <<= 4;
            eax += *((ebp + 8));
            *(eax) = 0;
            *(fp_stack--) = 1.0;
            fp_stack[0] = -fp_stack[0];
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            edx = *((ebp - 0x50));
            *((eax + 4)) = edx;
            eax = *((ebp - 0x4c));
            eax <<= 4;
            ecx = *((ebp + 8));
            eax = eax + ecx + 0x10;
            *(eax) = 2;
            *((eax + 8)) = 8;
            *((eax + 4)) = edx;
            *((ebp - 0x4c)) += 2;
            *((ebp - 0x54)) = 0;
        } else {
label_15:
            eax = errno_location ();
            ebx = eax;
            *(eax) = 0;
            eax = ebp + 0x10;
            strtod (esi, eax);
            if (esi == *((ebp + 0x10))) {
                goto label_16;
            }
            if (*(ebx) != 0) {
                fp_stack++;
                *((esp + 4)) = "Constant out of range.";
                esi -= *((ebp - 0x58));
                put_up_arrow (esi);
                eax = 0;
                goto label_9;
            }
            eax = *((ebp - 0x4c));
            eax <<= 4;
            eax += *((ebp + 8));
            *(eax) = 0;
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            edx = *((ebp - 0x50));
            *((eax + 4)) = edx;
            *((ebp - 0x4c))++;
            *((ebp + 0x10))--;
            goto label_7;
label_11:
            edx = (int32_t) dl;
            eax = isvarchar (edx);
            if (eax == 0) {
                *((esp + 4)) = "Unrecognized character.";
                eax = *((ebp + 0x10));
                eax -= *((ebp - 0x58));
                put_up_arrow (eax);
                eax = 0;
                goto label_9;
            }
            if (*((ebp - 0x54)) == 0) {
                eax = *((ebp - 0x4c));
                eax <<= 4;
                eax += *((ebp + 8));
                ecx = *((ebp - 0x50));
                *((eax + 4)) = ecx;
                *(eax) = 2;
                *((eax + 8)) = 3;
                *((ebp - 0x4c))++;
                *((ebp - 0x54)) = 1;
            }
            ebx = *((ebp + 0x10));
            eax = strncasecmp (ebx, 0x80751b7, 3);
            if (eax == 0) {
                eax = *((ebx + 3));
                eax = isvarchar (eax);
                if (eax == 0) {
                    eax = *((ebp - 0x4c));
                    eax <<= 4;
                    eax += *((ebp + 8));
                    *(eax) = 0;
                    *(fp_stack--) = *(0x8075660);
                    *((eax + 8)) = fp_stack[0];
                    fp_stack--;
                    *((ebp + 0x10)) += 3;
                }
            } else {
                eax = *((ebp - 0x4c));
                eax <<= 4;
                eax += *((ebp + 8));
                *(eax) = 1;
                edx = *((ebp + 0x10));
                *((esp + 4)) = edx;
                eax += 8;
                eax = parse_var (eax);
                *((ebp + 0x10)) = eax;
                if (eax == 0) {
                    goto label_1;
                }
            }
            eax = *((ebp + 0x10));
            if (*(eax) == 0x28) {
                *((esp + 4)) = "Named functions currently not implemented, except when using m4.";
                ebx -= *((ebp - 0x58));
                put_up_arrow (ebx);
                eax = 0;
                goto label_9;
            }
            eax--;
            *((ebp + 0x10)) = eax;
            eax = *((ebp - 0x4c));
            eax <<= 4;
            ecx = *((ebp - 0x50));
            edx = *((ebp + 8));
            *((eax + edx + 4)) = ecx;
            *((ebp - 0x4c))++;
        }
    }
label_7:
    *((ebp + 0x10))++;
    goto label_0;
label_3:
    ebx = eax;
    if (*((ebp - 0x5c)) != 0) {
        goto label_10;
    }
    cl = (*((ebp - 0x4c)) != 0) ? 1 : 0;
    if (*((ebp - 0x4c)) != 0) {
        if (*((ebp - 0x54)) == 0) {
            goto label_10;
        }
    }
    if (*((ebp - 0x50)) == 1) {
        if (dl == 0x3d) {
            goto label_17;
        }
        goto label_18;
    }
    *((esp + 4)) = "Unmatched parenthesis: missing )";
    ebx -= *((ebp - 0x58));
    put_up_arrow (ebx);
    eax = 0;
    goto label_9;
    do {
label_17:
        eax++;
        *((ebp + 0x10)) = eax;
    } while (*(eax) == 0x3d);
label_18:
    eax = *((ebp - 0x4c));
    ebx = *((ebp + 0xc));
    *(ebx) = eax;
    if (cl != 0) {
        *((esp + 4)) = ebx;
        edx = *((ebp + 8));
        handle_negate (edx);
        ecx = *((ebp + 8));
        give_priority (ecx, ebx);
        *((esp + 4)) = ebx;
        ebx = *((ebp + 8));
        organize (ebx);
    }
    eax = *((ebp + 0x10));
    edx = *((ebp + 0x10));
    edx -= *((ebp - 0x58));
    *(obj.input_column) += edx;
    goto label_9;
label_16:
    fp_stack++;
label_10:
    *((esp + 4)) = "Syntax error.";
    eax = *((ebp + 0x10));
    eax -= *((ebp - 0x58));
    put_up_arrow (eax);
    eax = 0;
    goto label_9;
label_1:
    eax = 0;
label_9:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804f44b */
#include <stdint.h>
 
int32_t dbg_display_process (int32_t arg_8h, char * cp) {
    char * var_4h;
    char * var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = cp;
    /* int display_process(char * cp); */
    ebx = *((ebp + 8));
    eax = 0;
    if (ebx != 0) {
        default_color ();
        eax = 0x8071931;
        edx = "&mdash;&gt; ";
        if (*(obj.html_flag) != 0) {
            eax = edx;
        }
        *((esp + 0xc)) = eax;
        eax = cur_equation;
        eax++;
        *((esp + 8)) = eax;
        *((esp + 4)) = "%d%s";
        *(esp) = 1;
        eax = printf_chk ();
        *(obj.input_column) = eax;
        if (*(obj.html_flag) != 0) {
            *((esp + 8)) = ebx;
            *((esp + 4)) = "<b>%s</b>";
            *(esp) = 1;
            printf_chk ();
        } else {
            *((esp + 8)) = ebx;
            *((esp + 4)) = 0x8075e74;
            *(esp) = 1;
            printf_chk ();
        }
        eax = gfp;
        if (eax != *(obj.stdout)) {
            if (eax == *(obj.stderr)) {
                goto label_0;
            }
            *((esp + 0x14)) = ebx;
            *((esp + 0x10)) = 0x8071931;
            edx = cur_equation;
            edx++;
            *((esp + 0xc)) = edx;
            *((esp + 8)) = "%d%s%s";
            *((esp + 4)) = 1;
            *(esp) = eax;
            fprintf_chk ();
        }
label_0:
        set_error_level (ebx);
        process (ebx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a597 */
#include <stdint.h>
 
uint32_t dbg_decstrtol (char * str, char * arg_ch, long int l) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * * endptr;
    char * base;
    esi = l;
    /* long int decstrtol(char * cp,char ** cpp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = strtol (edi, ebx, 0xa);
    esi = eax;
    if (ebx != 0) {
        eax = *(ebx);
        if (eax == edi) {
            goto label_0;
        }
        eax = skip_space (eax);
        *(ebx) = eax;
    }
label_0:
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049014 */
#include <stdint.h>
 
void strtol (void) {
    strtol ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a4ff */
#include <stdint.h>
 
uint32_t dbg_skip_space (char * arg_8h, char * cp) {
    esi = cp;
    /* char * skip_space(char * cp); */
    esi = *((ebp + 8));
    if (esi == 0) {
        goto label_0;
    }
    ebx = *(esi);
    if (bl == 0) {
        goto label_0;
    }
    eax = ctype_b_loc ();
    eax = *(eax);
    while ((*((eax + ebx*2 + 1)) & 0x20) != 0) {
        esi++;
        ebx = *(esi);
        if (bl == 0) {
            goto label_0;
        }
        ebx = (int32_t) bl;
    }
label_0:
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8066dfd */
#include <stdint.h>
 
int32_t dbg_poly_gcd (int32_t arg_8h, char * arg_ch, int32_t count, int32_t llen, token_type * larger) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    token_type * smaller;
    int32_t slen;
    long int v;
    void ** s2;
    size_t * n;
    char * var_sp_ch;
    int32_t var_10h;
    ebx = count;
    esi = llen;
    edi = larger;
    /* int poly_gcd(token_type * larger,int llen,token_type * smaller,int slen,long int v); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x14));
    eax = n_tokens;
    if (eax >= esi) {
        edx = 0x7530;
        if (eax > 0x7530) {
            eax = edx;
        }
        if (eax >= ebx) {
            eax = esi;
            eax <<= 4;
            eax = trhs;
            memmove (eax, edi, eax);
            *(obj.n_trhs) = esi;
            eax = ebx;
            eax <<= 4;
            eax = *((ebp + 0x10));
            eax = tlhs;
            memmove (eax, eax, eax);
            *(obj.n_tlhs) = ebx;
            eax = remove_factors ();
            if (eax == 0) {
                goto label_0;
            }
            eax = n_tlhs;
            if (eax > 0x7530) {
                goto label_0;
            }
            *((esp + 0xc)) = 0x75300;
            eax <<= 4;
            *((esp + 8)) = eax;
            eax = tlhs;
            *((esp + 4)) = eax;
            *(esp) = obj.gcd_divisor;
            memmove_chk ();
            eax = n_tlhs;
            *(obj.len_d) = eax;
            eax = ebp + 0x18;
            eax = do_gcd ();
            ebx = eax;
            if (eax == 0) {
                goto label_1;
            }
            if (eax > 1) {
                eax = len_d;
                if (eax > *(obj.n_tokens)) {
                    goto label_0;
                }
                eax <<= 4;
                eax = tlhs;
                memmove (eax, 0x80f9280, eax);
                eax = len_d;
                *(obj.n_tlhs) = eax;
                eax = remove_factors ();
                if (eax == 0) {
                    goto label_0;
                }
                eax = n_tlhs;
                if (eax > 0x7530) {
                    goto label_0;
                }
                *((esp + 0xc)) = 0x75300;
                eax <<= 4;
                *((esp + 8)) = eax;
                eax = tlhs;
                *((esp + 4)) = eax;
                *(esp) = obj.gcd_divisor;
                memmove_chk ();
                eax = n_tlhs;
                *(obj.len_d) = eax;
                edx = ebp + 0x18;
                *((esp + 0x10)) = edx;
                *((esp + 0xc)) = eax;
                *((esp + 8)) = 0x80f9280;
                *((esp + 4)) = esi;
                *(esp) = edi;
                eax = poly_div ();
                if (eax == 2) {
                    goto label_2;
                }
                if (*(obj.debug_level) <= 0) {
                    goto label_0;
                }
                *((esp + 0xc)) = "Polynomial GCD found, but larger divide failed in poly_gcd().";
                *((esp + 8)) = 0x807277d;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                ebx = 0;
                goto label_1;
            }
label_2:
            eax = len_d;
            if (eax > *(obj.n_tokens)) {
                goto label_0;
            }
            eax <<= 4;
            eax = trhs;
            memmove (eax, 0x80f9280, eax);
            eax = len_d;
            *(obj.n_trhs) = eax;
            *((esp + 4)) = 0x80796b8;
            eax = tlhs;
            *(esp) = eax;
            uf_simp ();
            *((esp + 4)) = 0x80798b4;
            eax = trhs;
            *(esp) = eax;
            uf_simp ();
            if (*(obj.debug_level) <= 2) {
                goto label_1;
            }
            *((esp + 0xc)) = "poly_gcd() successful.";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
    } else {
label_0:
        ebx = 0;
    }
label_1:
    eax = 0;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8066dde */
#include <stdint.h>
 
int32_t dbg_mod_simp (void) {
    token_type * equation;
    int * np;
    /* int mod_simp(token_type * equation,int * np); */
    *(esp) = 1;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    mod_recurse ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d095 */
#include <stdint.h>
 
uint32_t dbg_simp_divide (void * arg_8h, char * arg_ch, token_type * equation, int * np) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = equation;
    esi = np;
    /* void simp_divide(token_type * equation,int * np); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    do {
label_0:
        simp_loop (ebx, esi);
        *((esp + 8)) = 1;
        *((esp + 4)) = esi;
        eax = factor_constants (ebx);
    } while (eax != 0);
    *(fp_stack--) = 0.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    *((esp + 8)) = 0;
    *((esp + 4)) = esi;
    *(esp) = ebx;
    eax = factor_divide ();
    if (eax != 0) {
        goto label_0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d9b9 */
#include <stdint.h>
 
int32_t dbg_complex_log (int32_t arg_8h) {
    complexs a;
    /* complexs complex_log(complexs a); */
    ebx = *((ebp + 8));
    *(fp_stack--) = *((ebp + 0xc));
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp + 0x14));
    *((ebp - 0x10)) = fp_stack[0];
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] *= fp_stack[0];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] *= fp_stack[0];
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(esp) = fp_stack[0];
    fp_stack--;
    log (ebx);
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x18));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x10));
    *(esp) = fp_stack[0];
    fp_stack--;
    atan2 ();
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] *= *(0x8072054);
    *(ebx) = fp_stack[0];
    fp_stack--;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80491f4 */
#include <stdint.h>
 
void log (void) {
    log ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049194 */
#include <stdint.h>
 
void atan2 (void) {
    atan2 ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8059835 */
#include <stdint.h>
 
int32_t dbg_div_imaginary (int32_t j, int32_t ilevel, int32_t k) {
    int32_t var_50h;
    int32_t var_4ch;
    int32_t biloc;
    int32_t op;
    int32_t var_40h;
    int32_t var_3ch;
    void * var_38h;
    int32_t eiloc;
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t iloc;
    int32_t var_24h;
    int32_t i;
    int32_t level;
    token_type * equation;
    int * np;
    void * s2;
    size_t * n;
    ecx = j;
    esi = ilevel;
    eax = k;
    /* int div_imaginary(token_type * equation,int * np); */
    eax = *((ebp + 0xc));
    eax = *(eax);
    *((ebp - 0x2c)) = eax;
    if (eax <= 1) {
        goto label_1;
    }
    edi = *((ebp + 8));
    edi += 0x10;
    *((ebp - 0x24)) = 2;
    *((ebp - 0x20)) = 1;
label_0:
    edx = *((ebp - 0x20));
    *((ebp - 0x38)) = edx;
    *((ebp - 0x3c)) = edi;
    if (*((edi + 8)) != 4) {
        goto label_2;
    }
    ecx = *((edi + 4));
    *((ebp - 0x1c)) = ecx;
    esi = *((ebp - 0x24));
    *((ebp - 0x4c)) = esi;
    if (*((ebp - 0x2c)) <= esi) {
        goto label_2;
    }
    ebx = edi + 0x10;
    esi = *((edi + 0x14));
    if (ecx >= esi) {
        goto label_2;
    }
    eax = edi + 0x20;
    *((ebp - 0x40)) = edx;
    edx = *((ebp - 0x4c));
    *((ebp - 0x28)) = 0xffffffff;
    *((ebp - 0x34)) = 0xffffffff;
    *((ebp - 0x48)) = 0xffffffff;
    *((ebp - 0x44)) = 0;
    ecx++;
    *((ebp - 0x30)) = ecx;
    *((ebp - 0x50)) = edi;
    edi = *((ebp - 0x2c));
    do {
        ecx = *(ebx);
        if (ecx == 2) {
            if (esi == *((ebp - 0x30))) {
                ebx = *((ebx + 8));
                *((ebp - 0x44)) = ebx;
                if (*((ebp - 0x28)) >= 0) {
                    if (*((ebp - 0x34)) >= 0) {
                        goto label_3;
                    }
                    *((ebp - 0x34)) = edx;
                    *((ebp - 0x40)) = edx;
                    goto label_4;
                }
label_3:
                *((ebp - 0x40)) = edx;
            }
        } else {
            if (ecx != 1) {
                goto label_4;
            }
            if (*((ebx + 8)) != 3) {
                goto label_4;
            }
            if (*((ebp - 0x28)) >= 0) {
                edi = *((ebp - 0x50));
                *((ebp - 0x44)) = 0;
                goto label_5;
            }
            ecx = *((ebp - 0x40));
            ecx++;
            *((ebp - 0x48)) = ecx;
            *((ebp - 0x28)) = edx;
        }
label_4:
        edx++;
        if (edx >= edi) {
            goto label_6;
        }
        ebx = eax;
        esi = *((eax + 4));
        eax += 0x10;
    } while (*((ebp - 0x1c)) < esi);
    edi = *((ebp - 0x50));
    goto label_5;
label_6:
    edi = *((ebp - 0x50));
label_5:
    if (*((ebp - 0x28)) >= 0) {
        esi = *((ebp - 0x34));
        __asm ("cmovs esi, edx");
        *((ebp - 0x34)) = esi;
    }
    if (*((ebp - 0x28)) < 0) {
        goto label_2;
    }
    eax = *((ebp - 0x44));
    eax--;
    if (eax > 1) {
        goto label_2;
    }
    eax = *((ebp - 0x28));
    *((ebp - 0x40)) = eax;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x30)) = eax;
    esi = *((eax + 4));
    ebx = *((ebp - 0x1c));
    ebx++;
    if (ebx != esi) {
        ecx = *((ebp - 0x1c));
        ecx += 2;
        if (ecx != esi) {
            goto label_2;
        }
        esi = *((ebp - 0x28));
        if (*((ebp - 0x48)) < esi) {
            eax = esi;
            eax--;
            eax <<= 4;
            esi = *((ebp + 8));
            if (*((eax + esi + 8)) != 3) {
                goto label_2;
            }
        }
        eax = *((ebp - 0x28));
        eax++;
        if (*((ebp - 0x34)) > eax) {
            eax = *((ebp - 0x40));
            eax++;
            eax <<= 4;
            esi = *((ebp + 8));
            eax = *((eax + esi + 8));
            eax -= 3;
            if (eax > 1) {
                goto label_2;
            }
        }
        esi = ecx;
    }
    eax = *((ebp - 0x20));
    eax = ~eax;
    *((ebp - 0x44)) = eax;
    edi = eax;
    edi += edx;
    edx = *((ebp - 0x34));
    edx -= *((ebp - 0x48));
    *((ebp - 0x34)) = edx;
    ecx = *((ebp - 0x2c));
    eax = edi + ecx + 7;
    eax += edx;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = edi;
    eax <<= 4;
    *((ebp - 0x24)) = eax;
    eax = *((ebp - 0x38));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    *((ebp - 0x38)) = eax;
    ecx = *((ebp - 0x24));
    eax = scratch;
    memmove (eax, eax, ecx);
    edx = *((ebp - 0x44));
    edx += *((ebp - 0x28));
    edx <<= 4;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = 0.0;
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    if (edi <= 0) {
        goto label_7;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.scratch);
        *((edx + 4)) += 2;
        eax++;
    } while (eax != edi);
label_7:
    eax = *((ebp - 0x1c));
    eax += 2;
    *((ebp - 0x2c)) = eax;
    eax = scratch;
    ecx = *((ebp - 0x2c));
    edx = *((ebp - 0x24));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 6;
    edx = edi + 1;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = *(0x8072058);
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    edx = edi + 2;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = ebx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 1;
    eax = edi + 3;
    *((ebp - 0x1c)) = eax;
    eax = *((ebp - 0x34));
    eax <<= 4;
    eax = *((ebp - 0x48));
    eax <<= 4;
    eax += *((ebp + 8));
    eax = *((ebp - 0x1c));
    eax <<= 4;
    eax += *(obj.scratch);
    memmove (eax, eax, eax);
    ebx = *((ebp - 0x1c));
    ebx += *((ebp - 0x34));
    if (*((ebp - 0x1c)) >= ebx) {
        goto label_8;
    }
    edx = edi + 3;
    edx <<= 4;
    eax = *((ebp - 0x1c));
    do {
        ecx = edx;
        ecx += *(obj.scratch);
        *((ecx + 4)) += 2;
        eax++;
        edx += 0x10;
    } while (ebx > eax);
label_8:
    edx = ebx;
    edx <<= 4;
    eax = scratch;
    ecx = *((ebp - 0x2c));
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 2;
    eax = scratch;
    *((eax + edx + 8)) = 6;
    edx = ebx + 1;
    edx <<= 4;
    eax = scratch;
    *((eax + edx + 4)) = ecx;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = *(0x8072058);
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    edi = ebx + 2;
    eax = *((ebp - 0x28));
    eax -= *((ebp - 0x48));
    eax += *((ebp - 0x1c));
    edx = eax;
    edx <<= 4;
    eax = scratch;
    *((eax + edx)) = 0;
    eax = scratch;
    *(fp_stack--) = 1.0;
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax -= *((ebp - 0x28));
    eax <<= 4;
    ecx = *((ebp - 0x30));
    eax = *((ebp - 0x40));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x20;
    memmove (eax, ecx, eax);
    ecx = *((ebp + 0xc));
    *(ecx) += 2;
    esi++;
    eax = *((ebp - 0x30));
    *((eax + 4)) = esi;
    *(eax) = 0;
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x28));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    *((eax + 4)) = esi;
    *(eax) = 2;
    *((eax + 8)) = 3;
    eax = *((ebp - 0x28));
    eax += 2;
    eax <<= 4;
    *((eax + edx + 4)) = esi;
    eax = *((ebp - 0x4c));
    eax = edi + eax;
    eax <<= 4;
    ebx = edx;
    ebx += eax;
    eax = *(ecx);
    eax -= *((ebp - 0x20));
    eax <<= 4;
    ecx = *((ebp - 0x3c));
    memmove (ebx, ecx, eax);
    esi = *((ebp + 0xc));
    eax = *(esi);
    eax = edi + eax + 1;
    *(esi) = eax;
    edi <<= 4;
    eax = scratch;
    eax = *((ebp - 0x38));
    memmove (eax, eax, edi);
    *((ebx + 8)) = 3;
    eax = 1;
    goto label_9;
label_2:
    *((ebp - 0x20)) += 2;
    edi += 0x20;
    *((ebp - 0x24)) += 2;
    edx = *((ebp - 0x20));
    if (*((ebp - 0x2c)) > edx) {
        goto label_0;
    }
label_1:
    eax = 0;
label_9:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80558a8 */
#include <stdint.h>
 
int32_t dbg_set_options (char * option_string, int32_t negate, int32_t i) {
    char * cp1;
    char * cp;
    char * s2;
    size_t n;
    ebx = option_string;
    edi = negate;
    eax = i;
    /* int set_options(char * cp); */
    do {
label_0:
        eax = *((ebp + 8));
        eax = skip_space (eax);
        ebx = eax;
        *((ebp + 8)) = eax;
        if (*(eax) == 0) {
            eax = 1;
            goto label_1;
        }
        if (*(obj.security_level) <= 2) {
            eax = strncasecmp (eax, 0x8075b7f, 3);
            if (eax != 0) {
                goto label_2;
            }
            eax = skip_param (ebx);
            *((ebp + 8)) = eax;
            if (*(eax) == 0) {
                eax = getenv ("HOME");
                *((ebp - 0x1c)) = eax;
                if (eax == 0) {
                    goto label_3;
                }
                *((ebp + 8)) = eax;
            }
label_3:
            eax = *((ebp + 8));
            *(esp) = eax;
            eax = chdir ();
            if (eax != 0) {
                *(esp) = "Error changing directory.";
                error ();
                eax = 0;
                goto label_1;
            }
            eax = stdout;
            output_current_directory (eax);
            eax = 1;
            goto label_1;
        }
label_2:
        eax = ebp + 8;
        eax = skip_no (eax);
        edi = eax;
        ebx = *((ebp + 8));
        eax = skip_param (ebx);
        esi = eax;
        *((ebp + 8)) = eax;
        eax = strncasecmp (ebx, "debug", 5);
        if (eax == 0) {
            if (edi != 0) {
                *(obj.debug_level) = 0;
                goto label_4;
            }
            eax = ebp - 0x1c;
            decstrtol (esi, eax);
            edx = *((ebp - 0x1c));
            if (*((ebp + 8)) == edx) {
                *(esp) = "Please specify the debug level number.";
                error ();
                eax = 0;
                goto label_1;
            }
            *((ebp + 8)) = edx;
            *(obj.debug_level) = eax;
            goto label_4;
        }
        eax = strncasecmp (ebx, "special", 7);
        if (eax == 0) {
            if (edi != 0) {
                *(obj.special_variable_characters) = 0;
                al = 1;
                goto label_1;
            }
            *((esp + 8)) = 0x100;
            my_strlcpy (obj.special_variable_characters, esi);
            eax = 1;
            goto label_1;
        }
        eax = strncasecmp (ebx, "columns", 6);
        if (eax == 0) {
            if (edi != 0) {
                *(obj.screen_columns) = 0;
                goto label_4;
            }
            eax = ebp - 0x1c;
            eax = decstrtol (esi, eax);
            if (eax >= 0) {
                edx = *((ebp - 0x1c));
                if (*((ebp + 8)) != edx) {
                    goto label_5;
                }
            }
            *(esp) = "Please specify how wide the screen is; 0 = infinite columns.";
            error ();
            eax = 0;
            goto label_1;
label_5:
            *((ebp + 8)) = edx;
            *(obj.screen_columns) = eax;
            goto label_4;
        }
        eax = strncasecmp (ebx, "wide", 4);
        if (eax != 0) {
            goto label_6;
        }
        if (edi != 0) {
            goto label_7;
        }
        *(obj.screen_columns) = 0;
        *(obj.screen_rows) = 0;
    } while (1);
label_7:
    get_screen_size ();
    goto label_0;
label_6:
    eax = strncasecmp (ebx, "precision", 4);
    if (eax == 0) {
        eax = ebp - 0x1c;
        eax = decstrtol (esi, eax);
        if (eax <= 0xe) {
            edx = *((ebp + 8));
            if (edx != *((ebp - 0x1c))) {
                goto label_8;
            }
        }
        *(esp) = "Please specify a display precision between 0 and 14 digits.";
        error ();
        eax = 0;
        goto label_1;
label_8:
        *(obj.precision) = eax;
        eax = 1;
    } else {
        *((esp + 4)) = "auto";
        eax = strcmp_tospace (ebx);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.autoselect) = eax;
            *(obj.autocalc) = eax;
            *(obj.autosolve) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "autosolve", 9);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.autosolve) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "autocalc", 8);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.autocalc) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "autoselect", 0xa);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.autoselect) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "case", 4);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.case_sensitive_flag) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "display2d", 7);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.display2d) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "prompt", 6);
        if (eax == 0) {
            *(obj.quiet_mode) = edi;
            goto label_0;
        }
        eax = strncasecmp (ebx, "preserve", 8);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.preserve_surds) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "rationalize", 0xb);
        if (eax == 0) {
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.rationalize_denominators) = eax;
            goto label_0;
        }
        eax = strncasecmp (ebx, "modulus_mode", 3);
        if (eax == 0) {
            if (edi != 0) {
                *(obj.modulus_mode) = 0;
            } else {
                eax = ebp - 0x1c;
            }
            eax = *((ebp + 8));
            eax = decstrtol (eax, eax);
            edx = *((ebp - 0x1c));
            if (*((ebp + 8)) != edx) {
                if (eax < 0) {
                    goto label_9;
                }
                if (eax <= 2) {
                    goto label_10;
                }
            }
label_9:
            *(esp) = "Please specify the modulus mode number (0, 1, or 2).";
            error ();
            *((esp + 4)) = "0 means modulus operator (%%) result has same sign as dividend,\n";
            *(esp) = 1;
            printf_chk ();
            *((esp + 4)) = "1 means computed result always has same sign as the divisor,\n";
            *(esp) = 1;
            printf_chk ();
            *((esp + 4)) = "2 means the result is always positive or zero.\n";
            *(esp) = 1;
            printf_chk ();
            eax = modulus_mode;
            *((esp + 8)) = eax;
            *((esp + 4)) = "Current value is %d.\n";
            *(esp) = 1;
            printf_chk ();
            eax = 0;
            goto label_1;
label_10:
            *((ebp + 8)) = edx;
            *(obj.modulus_mode) = eax;
        } else {
            eax = strncasecmp (ebx, "color", 5);
            if (eax == 0) {
                reset_attr ();
                al = (edi == 0) ? 1 : 0;
                eax = (int32_t) al;
                *(obj.color_flag) = eax;
                goto label_0;
            }
            eax = strncasecmp (ebx, 0x8071994, 4);
            if (eax == 0) {
                reset_attr ();
                al = (edi == 0) ? 1 : 0;
                eax = (int32_t) al;
                *(obj.bold_colors) = eax;
                goto label_0;
            }
            eax = strncasecmp (ebx, "finance", 7);
            if (eax == 0) {
                if (edi != 0) {
                    *(obj.finance_option) = 0;
                } else {
                    eax = ebp - 0x1c;
                }
                eax = *((ebp + 8));
                decstrtol (eax, eax);
                ecx = *((ebp + 8));
                edx = *((ebp - 0x1c));
                if (ecx == edx) {
                    eax = 2;
                    if (*(ecx) == 0) {
                        goto label_11;
                    }
                    *(esp) = "Please specify the number of digits.";
                    error ();
                    eax = 0;
                    goto label_1;
                }
                if (eax > 0xe) {
                    *(esp) = "Minimum is 0, maximum is 14.";
                    error ();
                    eax = 0;
                    goto label_1;
                }
label_11:
                *((ebp + 8)) = edx;
                *(obj.finance_option) = eax;
            } else {
                eax = strncasecmp (ebx, "factor_integers", 6);
                if (eax == 0) {
                    al = (edi == 0) ? 1 : 0;
                    eax = (int32_t) al;
                    *(obj.factor_int_flag) = eax;
                    goto label_0;
                }
                eax = strncasecmp (ebx, "right_associative_power", 5);
                if (eax == 0) {
                    al = (edi == 0) ? 1 : 0;
                    eax = (int32_t) al;
                    *(obj.right_associative_power) = eax;
                    goto label_0;
                }
                eax = strncasecmp (ebx, "negate_highest_precedence", 6);
                if (eax == 0) {
                    al = (edi == 0) ? 1 : 0;
                    eax = (int32_t) al;
                    *(obj.negate_highest_precedence) = eax;
                    goto label_0;
                }
                if (*(obj.security_level) <= 1) {
                    *((esp + 4)) = "save";
                    eax = strcmp_tospace (ebx);
                    if (eax != 0) {
                        goto label_12;
                    }
                    if (*(obj.rc_file) == 0) {
                        *(esp) = "Set options startup file name not set.";
                        error ();
                        eax = 0;
                        goto label_1;
                    }
                    if (edi != 0) {
                        eax = unlink (obj.rc_file);
                        if (eax != 0) {
                            goto label_4;
                        }
                        *((esp + 8)) = obj.rc_file;
                        *((esp + 4)) = "Set options startup file \"%s\" removed.\n";
                        *(esp) = 1;
                        printf_chk ();
                        goto label_4;
                    }
                    eax = save_set_options ();
                    edx = eax;
                    eax = 0;
                    if (edx != 0) {
                        goto label_4;
                    }
                    goto label_1;
                }
label_12:
                *(esp) = "Unknown set option.";
                error ();
                eax = 0;
                goto label_1;
            }
        }
label_4:
        eax = *((ebp + 8));
        eax = extra_characters (eax);
        al = (eax == 0) ? 1 : 0;
        eax = (int32_t) al;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a95d */
#include <stdint.h>
 
void dbg_error_huge (void) {
    int32_t var_18h;
    int32_t var_4h;
    /* void error_huge(); */
    *((esp + 4)) = 0xe;
    *(esp) = obj.jmp_save;
    return longjmp_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b23d */
#include <stdint.h>
 
int32_t dbg_error_bug (int32_t status) {
    char const * str;
    char * var_4h;
    /* void error_bug(char const * str); */
    eax = *((ebp + 8));
    *(esp) = eax;
    error ();
    *((esp + 4)) = "Please report this bug to the maintainers,\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "along with the entry sequence that caused it.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "Type \"help bugs\" for info on how to report bugs found in this program.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = 0xd;
    *(esp) = obj.jmp_save;
    return longjmp_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805da11 */
#include <stdint.h>
 
int32_t dbg_simpa_side (size_t * arg_10h, char * arg_14h, int32_t flag) {
    jmp_buf save_save;
    token_type * equation;
    int * np;
    char * s2;
    size_t * n;
    char * var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ebx = flag;
    /* void simpa_side(token_type * equation,int * np,int quick_flag,int frac_flag); */
    edx = *((ebp + 0xc));
    eax = *(edx);
    if (eax <= 1) {
        goto label_3;
    }
    *((esp + 0x10)) = 0;
    eax = *((ebp + 8));
    list_debug (0, eax, eax);
    *((esp + 0x10)) = 1;
    *((esp + 0xc)) = 1;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    simpb_side (eax, edx, 0);
    if (*(obj.rationalize_denominators) != 0) {
        edx = *((ebp + 0xc));
        *((esp + 4)) = edx;
        eax = *((ebp + 8));
        *(esp) = eax;
        rationalize ();
    }
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = *((ebp + 8));
    *(esp) = eax;
    unsimp_power ();
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = *((ebp + 8));
    *(esp) = eax;
    uf_times ();
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    simp_loop (eax, edx);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    uf_pplus (eax, edx);
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    uf_repeat (eax, edx);
    do {
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        elim_loop (eax, edx);
        edx = *((ebp + 0xc));
        *((esp + 4)) = edx;
        eax = *((ebp + 8));
        *(esp) = eax;
        eax = mod_simp ();
    } while (eax != 0);
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = *((ebp + 8));
    simp_i (eax);
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = *((ebp + 8));
    *(esp) = eax;
    unsimp_power ();
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    eax = *((ebp + 8));
    *(esp) = eax;
    uf_times ();
    *(fp_stack--) = 1.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    simp_ssub (1, eax, 0);
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    unsimp_power ();
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    uf_neg_help ();
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    uf_times ();
    do {
label_0:
        *(fp_stack--) = 1.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp + 0xc));
        edx = *((ebp + 8));
        simp_ssub (2, eax, 0);
        eax = *((ebp + 0xc));
        *((esp + 4)) = eax;
        edx = *((ebp + 8));
        *(esp) = edx;
        eax = poly_gcd_simp ();
    } while (eax != 0);
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    eax = uf_power (edx, eax);
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 8)) = 2;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    eax = super_factor ();
    if (eax != 0) {
        goto label_0;
    }
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    unsimp_power ();
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    uf_times ();
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    factorv (edx, eax, 3);
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    uf_pplus (edx, eax);
    *(fp_stack--) = 1.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    simp_ssub (1, eax, 0);
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    uf_times ();
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    uf_pplus (edx, eax);
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    factorv (edx, eax, 3);
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    uf_power (edx, eax);
    do {
label_1:
        *(fp_stack--) = 1.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp + 0xc));
        edx = *((ebp + 8));
        simp_ssub (6, eax, 0);
        eax = *((ebp + 0xc));
        *((esp + 4)) = eax;
        edx = *((ebp + 8));
        *(esp) = edx;
        eax = poly_gcd_simp ();
    } while (eax != 0);
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    eax = uf_power (edx, eax);
    if (eax != 0) {
        goto label_1;
    }
    *((esp + 8)) = 2;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    eax = super_factor ();
    if (eax != 0) {
        goto label_1;
    }
    eax = *((ebp + 0x14));
    *(obj.partial_flag) = eax;
    edx = *((ebp + 0xc));
    eax = *(edx);
    *(obj.n_tlhs) = eax;
    eax <<= 4;
    eax = *((ebp + 8));
    eax = tlhs;
    memmove (eax, eax, eax);
    eax = ebp - 0xa4;
    memmove (eax, 0x8079600, 0x9c);
    eax = setjmp (obj.jmp_save);
    ebx = eax;
    if (eax != 0) {
        eax = ebp - 0xa4;
        memmove (obj.jmp_save, eax, 0x9c);
        if (ebx == 0xd) {
            *((esp + 4)) = 0xd;
            *(esp) = obj.jmp_save;
            longjmp_chk ();
        }
        eax = n_tlhs;
        edx = *((ebp + 0xc));
        *(edx) = eax;
        eax = n_tlhs;
        eax <<= 4;
        eax = tlhs;
        eax = *((ebp + 8));
        memmove (eax, eax, eax);
        if (*(obj.debug_level) > 0) {
            *((esp + 0xc)) = "Simplify not expanding fully, due to oversized expression.";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        *(obj.partial_flag) = 1;
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        uf_tsimp (eax, edx);
        goto label_4;
    }
    if (*((ebp + 0x10)) == 0) {
        goto label_5;
    }
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    uf_tsimp (eax, edx);
    goto label_6;
    do {
label_5:
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        uf_power (eax, edx);
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        uf_repeat (eax, edx);
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        eax = uf_tsimp (eax, edx);
    } while (eax != 0);
label_6:
    eax = ebp - 0xa4;
    memmove (obj.jmp_save, eax, 0x9c);
label_4:
    *(obj.partial_flag) = 1;
    *((esp + 0x10)) = 2;
    *((esp + 0xc)) = 1;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    simpb_side (eax, edx, 1);
    if (*(obj.debug_level) > 0) {
        *((esp + 0xc)) = "Simplify result before applying polynomial operations:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 0x10)) = 0;
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax = *((ebp + 8));
    list_debug (0, eax, eax);
    ebx = 0;
    do {
label_2:
        edx = *((ebp + 0xc));
        *((esp + 4)) = edx;
        eax = *((ebp + 8));
        *(esp) = eax;
        eax = poly_gcd_simp ();
        if (eax != 0) {
            *((esp + 0x10)) = 3;
            *((esp + 0xc)) = 1;
            edx = *((ebp + 0xc));
            eax = *((ebp + 8));
            simpb_side (eax, edx, 0);
        } else {
            if (ebx != 0) {
                goto label_7;
            }
        }
        *((esp + 8)) = 1;
        edx = *((ebp + 0xc));
        *((esp + 4)) = edx;
        eax = *((ebp + 8));
        *(esp) = eax;
        eax = poly_factor ();
        if (eax == 0) {
            goto label_7;
        }
        *((esp + 0x10)) = 3;
        *((esp + 0xc)) = 1;
        edx = *((ebp + 0xc));
        eax = *((ebp + 8));
        simpb_side (eax, edx, 0);
        ebx = 1;
    } while (1);
label_7:
    if (*((ebp + 0x14)) == 0) {
        edx = *((ebp + 0x10));
        *((esp + 0xc)) = edx;
        eax = *((ebp + 0xc));
        edx = *((ebp + 8));
        eax = div_remainder (edx, eax, 1);
        if (eax == 0) {
            goto label_8;
        }
        *((esp + 0x10)) = 3;
        *((esp + 0xc)) = 1;
        eax = *((ebp + 0xc));
        edx = *((ebp + 8));
        simpb_side (edx, eax, 0);
        ebx = 0;
        goto label_2;
    }
label_8:
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    simp_constant_power (edx);
    *(fp_stack--) = 1.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    simp_ssub (5, eax, 0);
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    unsimp_power ();
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    make_fractions (edx);
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    factor_power ();
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    uf_tsimp (edx, eax);
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    make_fractions (edx);
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    uf_power (edx, eax);
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    integer_root_simp ();
    *((esp + 0x10)) = 3;
    *((esp + 0xc)) = 1;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    simpb_side (edx, eax, 1);
    *((esp + 8)) = 0;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    poly_factor ();
    *((esp + 0x10)) = 2;
    al = (*((ebp + 0x14)) == 0) ? 1 : 0;
    eax = (int32_t) al;
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0xc));
    edx = *((ebp + 8));
    simpb_side (edx, eax, 1);
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d6e2 */
#include <stdint.h>
 
int32_t dbg_simpv_side (char * arg_ch, char * arg_10h, long int v, int * np) {
    token_type * equation;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    ecx = v;
    eax = np;
    /* void simpv_side(token_type * equation,int * np,long int v); */
    eax = *((ebp + 0xc));
    edx = *((ebp + 0x10));
    if (*(eax) != 0) {
        cl = (edx == 0) ? 1 : 0;
        ecx = (int32_t) cl;
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp + 8));
        simp_ssub (6, eax, edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805b9ce */
#include <stdint.h>
 
int32_t dbg_elim_k (char * arg_ch, token_type * p4, int32_t flag, int32_t level) {
    int32_t var_68h;
    int32_t var_64h;
    int32_t var_60h;
    void * var_5ch;
    int32_t var_4ch;
    int32_t var_48h;
    int32_t modified;
    uint32_t var_40h;
    int32_t var_3ch;
    double d;
    void * s1;
    double denominator;
    double numerator;
    token_type * equation;
    void * s2;
    size_t n;
    int32_t var_ch;
    ebx = p4;
    esi = flag;
    edi = level;
    /* int elim_k(token_type * equation,int * np); */
    esi = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax += 0x10;
    *((ebp - 0x48)) = eax;
    ebx = eax;
    *((ebp - 0x44)) = 0;
    do {
label_0:
        edi = *(esi);
        edi <<= 4;
        edi += *((ebp + 8));
        if (ebx >= edi) {
            goto label_3;
        }
        if (*(ebx) == 2) {
            goto label_4;
        }
        ebx += 0x10;
    } while (1);
label_4:
    edx = *((ebx + 4));
    *((ebp - 0x38)) = edx;
    eax = *((ebx + 8));
    edx = eax - 1;
    if (edx > 1) {
        goto label_5;
    }
    ecx = ebx + 0x10;
    *((ebp - 0x2c)) = ecx;
    edx = ebx + 0x20;
    if (edi > edx) {
        ecx = *((ebp - 0x38));
        ecx++;
        if (*((edx + 4)) != ecx) {
            goto label_6;
        }
        ecx = *((edx + 8));
        ecx -= 3;
        if (ecx > 1) {
            goto label_6;
        }
        ecx = *((ebp - 0x2c));
        if (*(ecx) != 0) {
            goto label_6;
        }
        *(fp_stack--) = *((ecx + 8));
        *(fp_stack--) = 0.0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_6;
        }
        al = (eax == 1) ? 1 : 0;
        eax = (int32_t) al;
        eax++;
        *((ebx + 8)) = eax;
        eax = *((ebp - 0x2c));
        *(fp_stack--) = *((eax + 8));
        fp_stack[0] = -fp_stack[0];
        *((eax + 8)) = fp_stack[0];
        fp_stack--;
    }
label_6:
    eax = *((ebp - 0x38));
    ecx = *((ebp - 0x2c));
    if (*((ecx + 4)) == eax) {
        if (*(ecx) != 0) {
            goto label_7;
        }
        *(fp_stack--) = *((ecx + 8));
        *(fp_stack--) = 0.0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] > fp_stack[1]) {
            al = (*((ebx + 8)) == 1) ? 1 : 0;
            eax = (int32_t) al;
            eax++;
            *((ebx + 8)) = eax;
            ecx = *((ebp - 0x2c));
            *(fp_stack--) = *((ecx + 8));
            fp_stack[0] = -fp_stack[0];
            *((ecx + 8)) = fp_stack[0];
            fp_stack--;
        }
        eax = *((ebp - 0x2c));
        *(fp_stack--) = *((eax + 8));
        *(fp_stack--) = 0.0;
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_7;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_7;
        }
        eax = ebx + 0x20;
        edi -= eax;
        memmove (ebx, edx, edi);
        *(esi) -= 2;
        *((ebp - 0x44)) = 1;
        goto label_0;
    }
label_7:
    edx = ebx - 0x10;
    *((ebp - 0x40)) = edx;
    ecx = *((edx + 4));
    *((ebp - 0x3c)) = ecx;
    eax = *((ebp - 0x38));
    if (ecx == eax) {
        if (*(edx) == 0) {
            *(fp_stack--) = *((edx + 8));
            *(esp) = fp_stack[0];
            fp_stack--;
            eax = isinf ();
            if (eax == 0) {
                goto label_8;
            }
            edx = *((ebp - 0x40));
            *((ebp - 0x2c)) = edx;
        }
    } else {
label_8:
        ecx = *((ebp - 0x2c));
        ecx = *((ecx + 4));
        *((ebp - 0x3c)) = ecx;
        eax = *((ebp - 0x38));
        if (ecx != eax) {
            goto label_5;
        }
        edx = *((ebp - 0x2c));
        if (*(edx) != 0) {
            goto label_5;
        }
    }
    ecx = *((ebp - 0x2c));
    *(fp_stack--) = *((ecx + 8));
    *((ebp - 0x58)) = fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = isinf ();
    if (eax == 0) {
        goto label_5;
    }
    eax = *((ebx + 4));
    *((ebp - 0x4c)) = eax;
    *((ebp - 0x5c)) = ebx;
    *((ebp - 0x40)) = 0;
    if (*((ebp - 0x3c)) > eax) {
label_1:
        *((ebp - 0x5c)) += 0x10;
        edx = *((ebp - 0x4c));
        if (*((ebp - 0x3c)) <= edx) {
            goto label_9;
        }
        *((ebp - 0x4c)) = ebx;
        goto label_10;
    }
    *((ebp - 0x60)) = ebx;
    *((ebp - 0x64)) = edi;
    edi = *((ebp - 0x38));
    ebx = *((ebp - 0x5c));
    *((ebp - 0x68)) = esi;
    esi = *((ebp - 0x40));
    do {
        if (*(ebx) == 0) {
            if (ebx == *((ebp - 0x2c))) {
                goto label_11;
            }
            *(fp_stack--) = *((ebx + 8));
            *(esp) = fp_stack[0];
            fp_stack--;
            eax = finite ();
            ecx = 1;
            if (eax != 0) {
                esi = ecx;
                goto label_11;
            }
        }
label_11:
        if (ebx == *((ebp + 8))) {
            goto label_12;
        }
        ebx -= 0x10;
    } while (edi <= *((ebx + 4)));
    *((ebp - 0x40)) = esi;
    edi = *((ebp - 0x64));
    *((ebp - 0x5c)) = ebx;
    ebx = *((ebp - 0x60));
    esi = *((ebp - 0x68));
    goto label_1;
label_12:
    *((ebp - 0x40)) = esi;
    edi = *((ebp - 0x64));
    *((ebp - 0x5c)) = ebx;
    ebx = *((ebp - 0x60));
    esi = *((ebp - 0x68));
label_9:
    *((ebp - 0x4c)) = ebx;
    *((ebp - 0x60)) = ebx;
    *((ebp - 0x64)) = esi;
    esi = *((ebp - 0x3c));
    do {
        if (*(ebx) == 0) {
            if (ebx == *((ebp - 0x2c))) {
                goto label_13;
            }
            *(fp_stack--) = *((ebx + 8));
            *(esp) = fp_stack[0];
            fp_stack--;
            eax = finite ();
            eax = 1;
            if (eax != 0) {
                eax = *((ebp - 0x40));
            }
            *((ebp - 0x40)) = eax;
        }
label_13:
        ebx += 0x10;
        if (edi <= ebx) {
            goto label_14;
        }
    } while (esi <= *((ebx + 4)));
    *((ebp - 0x4c)) = ebx;
    ebx = *((ebp - 0x60));
    esi = *((ebp - 0x64));
    goto label_10;
label_14:
    *((ebp - 0x4c)) = ebx;
    ebx = *((ebp - 0x60));
    esi = *((ebp - 0x64));
label_10:
    if (*((ebp - 0x40)) == 0) {
        edx = *((ebp - 0x5c));
        if (*((ebp - 0x2c)) > edx) {
            ecx = *((ebp - 0x2c));
            if (*((ecx - 8)) != 2) {
                goto label_15;
            }
            *(fp_stack--) = *((ebp - 0x58));
            fp_stack[0] = -fp_stack[0];
            *((ecx + 8)) = fp_stack[0];
            fp_stack--;
        }
label_15:
        ebx = *((ebp - 0x2c));
        ebx += 0x10;
        edi -= *((ebp - 0x4c));
        eax = *((ebp - 0x4c));
        memmove (ebx, eax, edi);
        eax = *((ebp - 0x4c));
        eax -= ebx;
        eax >>= 4;
        edx = *(esi);
        edx -= eax;
        eax = edx;
        *(esi) = edx;
        eax <<= 4;
        eax += *((ebp + 8));
        eax -= *((ebp - 0x2c));
        edx = *((ebp - 0x2c));
        ecx = *((ebp - 0x5c));
        memmove (ecx, edx, eax);
        eax = *((ebp - 0x2c));
        eax -= *((ebp - 0x5c));
        eax >>= 4;
        *(esi) -= eax;
        *((ebp - 0x44)) = 1;
        goto label_3;
    }
label_5:
    eax = ebx - 0x10;
    *((ebp - 0x2c)) = eax;
    if (*((ebx + 8)) > 9) {
        goto label_16;
    }
    eax = *((ebx + 8));
    /* switch table (10 cases) at 0x8076db4 */
    ecx = *((ebp - 0x38));
    edx = *((ebp - 0x2c));
    if (*((edx + 4)) != ecx) {
        goto label_16;
    }
    if (*(edx) != 0) {
        goto label_16;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_16;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_16;
    }
    eax = ebx + 0x10;
    edi -= eax;
    memmove (edx, eax, edi);
    *(esi) -= 2;
    *((ebp - 0x44)) = 1;
    goto label_0;
    edx = *((ebp - 0x2c));
    eax = *((edx + 4));
    if (eax != *((ebp - 0x38))) {
        goto label_16;
    }
    if (*(edx) != 0) {
        goto label_16;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_16;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_16;
    }
    ecx = *((ebp + 8));
    if (edx != ecx) {
        if (eax <= *((edx - 0xc))) {
            goto label_16;
        }
    }
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    ecx = *((ebp - 0x2c));
    *((ecx + 8)) = fp_stack[0];
    fp_stack--;
    *((ebx + 8)) = 3;
    eax = ebx;
    eax -= *((ebp + 8));
    eax >>= 4;
    *((esp + 8)) = eax;
    eax = *(esi);
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    binary_parenthesize (eax);
    *((ebp - 0x44)) = 1;
    goto label_0;
    edx = *((ebp - 0x2c));
    eax = *((edx + 4));
    if (eax != *((ebp - 0x38))) {
        goto label_17;
    }
    if (*(edx) != 0) {
        goto label_17;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_18;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_18;
    }
    fp_stack++;
    ecx = ebx + 0x20;
    *((ebp - 0x38)) = ecx;
    if (edi <= ecx) {
        goto label_19;
    }
    if (eax <= *((ecx + 4))) {
        goto label_20;
    }
    goto label_19;
    do {
        if (eax > *((edx + 4))) {
            goto label_21;
label_20:
            edx = *((ebp - 0x38));
        }
        edx += 0x20;
    } while (edi > edx);
    *((ebp - 0x38)) = edx;
    goto label_19;
label_21:
    *((ebp - 0x38)) = edx;
label_19:
    edi -= *((ebp - 0x38));
    eax = *((ebp - 0x38));
    memmove (ebx, eax, edi);
    eax = *((ebp - 0x38));
    eax -= ebx;
    eax >>= 4;
    *(esi) -= eax;
    *((ebp - 0x44)) = 1;
    goto label_0;
label_18:
    fp_stack[0] -= *(0x8075170);
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *(obj.epsilon);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        eax = ebx + 0x10;
        edi -= eax;
        edx = *((ebp - 0x2c));
        memmove (edx, eax, edi);
        *(esi) -= 2;
        *((ebp - 0x44)) = 1;
        goto label_0;
    }
label_17:
    eax = ebx + 0x10;
    edi = *((eax + 4));
    if (edi != *((ebp - 0x38))) {
        goto label_16;
    }
    if (*(eax) != 0) {
        goto label_16;
    }
    *(fp_stack--) = *((eax + 8));
    *((ebp - 0x38)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x2c));
    if (*((ebp + 8)) >= eax) {
        goto label_22;
    }
    eax -= 0x10;
    if (edi > *((eax + 4))) {
        goto label_22;
    }
    *((ebp - 0x2c)) = eax;
    ecx = *((ebp + 8));
    while (ecx < eax) {
        edx = eax - 0x10;
        if (edi > *((edx + 4))) {
            goto label_23;
        }
        eax = edx;
    }
    *((ebp - 0x2c)) = eax;
    goto label_22;
label_23:
    *((ebp - 0x2c)) = eax;
label_22:
    edx = *((ebp - 0x2c));
    if (edi == *((edx + 4))) {
        if (*(edx) == 0) {
            goto label_16;
        }
    }
    ebx -= *((ebp - 0x2c));
    ecx = *((ebp - 0x2c));
    eax = ecx;
    eax += 0x20;
    memmove (eax, ecx, ebx);
    eax = *((ebp - 0x2c));
    *((eax + 4)) = edi;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x38));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x2c));
    eax += 0x10;
    *((eax + 4)) = edi;
    *(eax) = 2;
    *((eax + 8)) = 3;
    ebx = *((ebp - 0x2c));
    ebx -= 0x10;
    eax = *((ebp - 0x2c));
    if (*((ebp + 8)) >= eax) {
        ebx = *((ebp - 0x48));
    }
    goto label_0;
    edx = *((ebp - 0x2c));
    eax = *((edx + 4));
    if (eax != *((ebp - 0x38))) {
        goto label_24;
    }
    if (*(edx) != 0) {
        goto label_24;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_24;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_24;
    }
    ecx = ebx + 0x20;
    *((ebp - 0x38)) = ecx;
    if (edi <= ecx) {
        goto label_25;
    }
    if (eax <= *((ecx + 4))) {
        goto label_26;
    }
    goto label_25;
    do {
        if (eax > *((edx + 4))) {
            goto label_27;
label_26:
            edx = *((ebp - 0x38));
        }
        edx += 0x20;
    } while (edi > edx);
    *((ebp - 0x38)) = edx;
    goto label_25;
label_27:
    *((ebp - 0x38)) = edx;
label_25:
    edi -= *((ebp - 0x38));
    eax = *((ebp - 0x38));
    memmove (ebx, eax, edi);
    eax = *((ebp - 0x38));
    eax -= ebx;
    eax >>= 4;
    *(esi) -= eax;
    *((ebp - 0x44)) = 1;
    goto label_0;
label_24:
    edi = ebx + 0x10;
    edx = *((ebp - 0x38));
    if (*((edi + 4)) != edx) {
        goto label_16;
    }
    eax = *(edi);
    if (eax == 0) {
        ecx = ebp - 0x28;
        eax = ebp - 0x20;
        *(fp_stack--) = *((edi + 8));
        *(esp) = fp_stack[0];
        fp_stack--;
        f_to_fraction (ecx, eax);
        *(fp_stack--) = *((ebp - 0x20));
        *(esp) = fp_stack[0];
        fp_stack--;
        eax = check_divide_by_zero ();
        *(fp_stack--) = *((ebp - 0x28));
        fp_stack[0] /= *((ebp - 0x20));
        *((edi + 8)) = fp_stack[0];
        fp_stack--;
        *((ebx + 8)) = 3;
        goto label_0;
    }
    if (eax != 1) {
        goto label_16;
    }
    eax = *((edi + 8));
    eax &= 0x3fff;
    if (eax != 4) {
        goto label_16;
    }
    *((ebx + 8)) = 3;
    goto label_0;
    edx = *((ebp - 0x2c));
    eax = *((edx + 4));
    if (eax != *((ebp - 0x38))) {
        goto label_16;
    }
    if (*(edx) != 0) {
        goto label_16;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_5 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_5;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_16;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_16;
    }
    ecx = ebx + 0x20;
    *((ebp - 0x38)) = ecx;
    if (edi <= ecx) {
        goto label_28;
    }
    if (*((ecx + 4)) >= eax) {
        goto label_29;
    }
    goto label_28;
    do {
        if (eax > *((edx + 4))) {
            goto label_30;
label_29:
            edx = *((ebp - 0x38));
        }
        edx += 0x20;
    } while (edi > edx);
    *((ebp - 0x38)) = edx;
    goto label_28;
label_30:
    *((ebp - 0x38)) = edx;
label_28:
    edi -= *((ebp - 0x38));
    eax = *((ebp - 0x38));
    memmove (ebx, eax, edi);
    eax = *((ebp - 0x38));
    eax -= ebx;
    eax >>= 4;
    *(esi) -= eax;
    *((ebp - 0x44)) = 1;
    goto label_0;
    edx = *((ebp - 0x2c));
    eax = *((edx + 4));
    if (eax != *((ebp - 0x38))) {
        goto label_31;
    }
    if (*(edx) != 0) {
        goto label_31;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 1.0;
    fp_tmp_6 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_6;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_31;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_31;
    }
    ecx = ebx + 0x20;
    *((ebp - 0x38)) = ecx;
    if (edi <= ecx) {
        goto label_32;
    }
    if (*((ecx + 4)) > eax) {
        goto label_33;
    }
    goto label_32;
    do {
        if (eax >= *((edx + 4))) {
            goto label_34;
label_33:
            edx = *((ebp - 0x38));
        }
        edx += 0x20;
    } while (edi > edx);
    *((ebp - 0x38)) = edx;
    goto label_32;
label_34:
    *((ebp - 0x38)) = edx;
label_32:
    edi -= *((ebp - 0x38));
    eax = *((ebp - 0x38));
    memmove (ebx, eax, edi);
    eax = *((ebp - 0x38));
    eax -= ebx;
    eax >>= 4;
    *(esi) -= eax;
    *((ebp - 0x44)) = 1;
    goto label_0;
label_31:
    edx = ebx + 0x10;
    *((ebp - 0x3c)) = edx;
    eax = *((edx + 4));
    if (eax != *((ebp - 0x38))) {
        goto label_16;
    }
    if (*(edx) != 0) {
        goto label_16;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = 0.0;
    fp_tmp_7 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_7;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_35;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_36;
    }
    goto label_35;
    do {
        ecx = edx - 0x10;
        if (eax >= *((ecx + 4))) {
            goto label_37;
        }
        edx = ecx;
label_2:
    } while (ebx < edx);
    ebx = *((ebp - 0x38));
    *((ebp - 0x2c)) = edx;
    goto label_38;
label_36:
    fp_stack++;
    ecx = *((ebp - 0x2c));
    if (*((ebp + 8)) < ecx) {
        edx = ecx;
        edx -= 0x10;
        if (*((edx + 4)) <= eax) {
            goto label_38;
        }
        *((ebp - 0x2c)) = edx;
        *((ebp - 0x38)) = ebx;
        ebx = *((ebp + 8));
        goto label_2;
label_37:
        ebx = *((ebp - 0x38));
        *((ebp - 0x2c)) = edx;
    }
label_38:
    ebx += 0x10;
    edi -= ebx;
    eax = *((ebp - 0x3c));
    edx = *((ebp - 0x2c));
    memmove (edx, eax, edi);
    eax = *((ebp - 0x3c));
    eax -= *((ebp - 0x2c));
    eax >>= 4;
    *(esi) -= eax;
    *(fp_stack--) = 1.0;
    ecx = *((ebp - 0x2c));
    *((ecx + 8)) = fp_stack[0];
    fp_stack--;
    ebx = ecx;
    ebx += 0x10;
    *((ebp - 0x44)) = 1;
    goto label_0;
label_35:
    fp_stack[0] -= *(0x8075170);
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *(obj.epsilon);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        eax = ebx + 0x20;
        edi -= eax;
        memmove (ebx, eax, edi);
        *(esi) -= 2;
        *((ebp - 0x44)) = 1;
        goto label_0;
    }
label_16:
    ebx += 0x20;
    goto label_0;
label_3:
    eax = *((ebp - 0x44));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062e4b */
#include <stdint.h>
 
int32_t dbg_uf_times (int32_t j, int32_t level, int32_t i) {
    int32_t var_24h;
    int32_t rv;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    size_t * var_4h;
    int32_t var_8h;
    ecx = j;
    esi = level;
    eax = i;
    /* int uf_times(token_type * equation,int * np); */
    *((ebp - 0x20)) = 0;
label_1:
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    organize (edx);
    if (*(obj.partial_flag) != 0) {
        eax = *((ebp + 0xc));
        *((esp + 4)) = eax;
        edx = *((ebp + 8));
        *(esp) = edx;
        reorder ();
    }
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    group_proc ();
    if (*(obj.partial_flag) == 0) {
        goto label_2;
    }
    eax = *((ebp + 0xc));
    if (*(eax) <= 1) {
        goto label_2;
    }
    esi = *((ebp + 8));
    edi = 0;
label_0:
    if (*((esi + 0x18)) != 4) {
        goto label_3;
    }
    edx = *((esi + 0x14));
    *((ebp - 0x1c)) = edx;
    edx = edi;
    if (edi < 0) {
        goto label_3;
    }
    ebx = esi;
    ecx = *((esi + 4));
    if (*((ebp - 0x1c)) > ecx) {
        goto label_3;
    }
    eax = esi - 0x10;
    *((ebp - 0x24)) = esi;
    esi = *((ebp - 0x1c));
    while (edx >= 0) {
        ebx = eax;
        ecx = *((eax + 4));
        eax -= 0x10;
        if (esi > ecx) {
            goto label_4;
        }
        ecx += 2;
        *((ebx + 4)) = ecx;
        edx--;
    }
    esi = *((ebp - 0x24));
    goto label_3;
label_4:
    esi = *((ebp - 0x24));
label_3:
    eax = edi + 3;
    edi += 2;
    esi += 0x20;
    edx = *((ebp + 0xc));
    if (*(edx) > eax) {
        goto label_0;
    }
label_2:
    *((esp + 8)) = 1;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    *(esp) = edx;
    eax = sub_ufactor ();
    *((ebp - 0x20)) |= eax;
    if (eax != 0) {
        goto label_1;
    }
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    edx = *((ebp + 8));
    organize (edx);
    eax = *((ebp - 0x20));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8052146 */
#include <stdint.h>
 
int32_t dbg_echo_cmd (void) {
    char * cp;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    /* int echo_cmd(char * cp); */
    eax = *((ebp + 8));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d968 */
#include <stdint.h>
 
uint32_t dbg_complex_exp (int32_t arg_8h) {
    int32_t var_18h;
    int32_t var_10h;
    complexs a;
    int32_t var_8h;
    int32_t var_ch;
    /* complexs complex_exp(complexs a); */
    ebx = *((ebp + 8));
    eax = ebp - 0x10;
    edx = ebp - 0x18;
    *((esp + 0xc)) = edx;
    *((esp + 8)) = eax;
    *(fp_stack--) = *((ebp + 0x14));
    *(esp) = fp_stack[0];
    fp_stack--;
    sincos ();
    *(fp_stack--) = *((ebp - 0x18));
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x10));
    *((ebp - 0x28)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp + 0xc));
    *(esp) = fp_stack[0];
    fp_stack--;
    exp ();
    *(fp_stack--) = *((ebp - 0x28));
    fp_stack[0] *= fp_stack[1];
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    fp_stack[0] *= *((ebp - 0x20));
    *(ebx) = fp_stack[0];
    fp_stack--;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80492a4 */
#include <stdint.h>
 
void sincos (void) {
    sincos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049004 */
#include <stdint.h>
 
void exp (void) {
    exp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80570dd */
#include <stdint.h>
 
int32_t dbg_sum_cmd (void) {
    char * cp;
    /* int sum_cmd(char * cp); */
    edx = 0;
    eax = *((ebp + 8));
    sum_product ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057cf9 */
#include <stdint.h>
 
int32_t dbg_display_cmd (char * cp1) {
    int32_t factor_flag;
    int32_t displayed;
    jmp_buf save_save;
    int32_t j;
    int32_t i;
    char * cp;
    char * s2;
    size_t n;
    ebx = cp1;
    /* int display_cmd(char * cp); */
    *((esp + 4)) = 0x8072c49;
    eax = *((ebp + 8));
    eax = strcmp_tospace (eax);
    al = (eax == 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0xc0)) = eax;
    if (eax != 0) {
        eax = *((ebp + 8));
        eax = skip_param (eax);
        *((ebp + 8)) = eax;
    }
    *((ebp - 0xbc)) = 0;
label_0:
    ebx = *((ebp + 8));
    eax = ebp - 0x10;
    *((esp + 8)) = eax;
    eax = ebp - 0xc;
    eax = ebp + 8;
    eax = get_range (eax, eax);
    if (eax == 0) {
        *((ebp - 0xbc)) = 0;
        goto label_1;
    }
    eax = *((ebp + 8));
    while (ebx != eax) {
        eax = *((ebp - 0xc));
        if (eax <= *((ebp - 0x10))) {
            goto label_2;
        }
        goto label_3;
    }
    *(esp) = "Invalid argument.";
    error ();
    *((ebp - 0xbc)) = 0;
    goto label_1;
    do {
label_2:
        if (*((eax*4 + obj.n_lhs)) > 0) {
            eax = ebp - 0xac;
            memmove (eax, 0x8079600, 0x9c);
            eax = setjmp (obj.jmp_save);
            if (eax != 0) {
                eax = ebp - 0xac;
                memmove (obj.jmp_save, eax, 0x9c);
                eax = *((ebp - 0xc));
                eax++;
                *((esp + 8)) = eax;
                *((esp + 4)) = "Skipping equation number %d.\n";
                *(esp) = 1;
                printf_chk ();
            } else {
                eax = *((ebp - 0xc));
                make_fractions_and_group (eax);
                if (*((ebp - 0xc0)) == 0) {
                    if (*(obj.factor_int_flag) == 0) {
                        goto label_4;
                    }
                }
                eax = *((ebp - 0xc));
                factor_int_sub (eax);
label_4:
                eax = ebp - 0xac;
                memmove (obj.jmp_save, eax, 0x9c);
                eax = *((ebp - 0xc));
                eax = flist_equation (eax);
                eax = 1;
                if (eax <= 0) {
                    eax = *((ebp - 0xbc));
                }
                *((ebp - 0xbc)) = eax;
            }
        }
        eax = *((ebp - 0xc));
        eax++;
        *((ebp - 0xc)) = eax;
    } while (*((ebp - 0x10)) >= eax);
label_3:
    eax = *((ebp + 8));
    if (*(eax) != 0) {
        goto label_0;
    }
label_1:
    eax = *((ebp - 0xbc));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d76a */
#include <stdint.h>
 
void dbg_calc_simp (void) {
    token_type * equation;
    int * np;
    int32_t var_4h;
    int32_t var_8h;
    /* void calc_simp(token_type * equation,int * np); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *(obj.approximate_roots) = 1;
    *((esp + 4)) = ebx;
    subst_constants (esi);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    simp_side ();
    uf_power (esi, ebx);
    factorv (esi, ebx, 3);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    ufactor ();
    factorv (esi, ebx, 3);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    uf_simp ();
    factorv (esi, ebx, 3);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    simp_side ();
    *((esp + 4)) = ebx;
    make_fractions (esi);
    uf_tsimp (esi, ebx);
    *(obj.approximate_roots) = 0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805031b */
#include <stdint.h>
 
uint32_t dbg_subst_constants (char * arg_ch, int32_t i, int * np) {
    int32_t modified;
    double d;
    token_type * equation;
    int32_t var_4h;
    esi = i;
    edi = np;
    /* int subst_constants(token_type * equation,int * np); */
    edi = *((ebp + 0xc));
    *((ebp - 0x24)) = 0;
    if (*(edi) <= 0) {
        goto label_0;
    }
    ebx = *((ebp + 8));
    esi = 0;
    do {
        if (*(ebx) == 1) {
            eax = ebp - 0x18;
            eax = *((ebx + 8));
            eax = var_is_const (eax, eax);
            if (eax == 0) {
                goto label_1;
            }
            *(ebx) = 0;
            *(fp_stack--) = *((ebp - 0x18));
            *((ebx + 8)) = fp_stack[0];
            fp_stack--;
            *((ebp - 0x24)) = 1;
        }
label_1:
        esi += 2;
        ebx += 0x20;
    } while (*(edi) > esi);
label_0:
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d72a */
#include <stdint.h>
 
int32_t dbg_simp_side (void) {
    token_type * equation;
    int * np;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_1ch;
    /* void simp_side(token_type * equation,int * np); */
    *(fp_stack--) = 1.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    simp_ssub (6, eax, 0);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d0ec */
#include <stdint.h>
 
uint32_t dbg_factorv (int32_t arg_8h, char * arg_ch, size_t * arg_10h, int * np, token_type * equation, long int v) {
    int32_t var_4h;
    int32_t var_8h;
    ebx = np;
    esi = equation;
    edi = v;
    /* void factorv(token_type * equation,int * np,long int v); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    if (edi != 3) {
        goto label_0;
    }
    approximate_complex_roots (esi, ebx);
    do {
label_0:
        simp_loop (esi, ebx);
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = edi;
        *((esp + 4)) = ebx;
        *(esp) = esi;
        eax = factor_plus ();
    } while (eax != 0);
    if (edi != 3) {
        goto label_1;
    }
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = div_imaginary ();
    if (eax != 0) {
        goto label_0;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062f4b */
#include <stdint.h>
 
uint32_t dbg_ufactor (int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    token_type * equation;
    int * np;
    size_t * var_sp_4h;
    edi = rv;
    /* int ufactor(token_type * equation,int * np); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    uf_repeat (esi, ebx);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = uf_times ();
    edi = eax;
    uf_allpower (esi, ebx);
    eax = edi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062d0e */
#include <stdint.h>
 
uint32_t dbg_uf_repeat (void * arg_8h, size_t * arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    size_t * var_sp_4h;
    int32_t var_sp_8h;
    /* void uf_repeat(token_type * equation,int * np); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    organize (esi);
    *((esp + 8)) = 6;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = sub_ufactor ();
    if (eax != 0) {
        *((esp + 4)) = ebx;
        organize (esi);
    }
    *((esp + 4)) = ebx;
    patch_root_div (esi);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061c40 */
#include <stdint.h>
 
int32_t dbg_patch_root_div (size_t * arg_ch, int32_t i, int * np) {
    uint32_t var_3ch;
    int32_t var_34h;
    int32_t var_30h;
    int32_t modified;
    int32_t var_20h;
    void * s1;
    token_type * equation;
    void * s2;
    size_t n;
    ebx = i;
    esi = np;
    /* int patch_root_div(token_type * equation,int * np); */
    esi = *((ebp + 0xc));
    eax = *(esi);
    eax -= 2;
    *((ebp - 0x24)) = 0;
    ebx = 1;
    if (eax <= 1) {
        goto label_1;
    }
label_0:
    edi = ebx;
    edi <<= 4;
    edi += *((ebp + 8));
    if (*((edi + 8)) != 4) {
        goto label_2;
    }
    edx = *((edi + 4));
    *((ebp - 0x20)) = edx;
    edx = ebx;
    edx <<= 4;
    ecx = *((ebp + 8));
    edx = edx + ecx + 0x20;
    *((ebp - 0x1c)) = edx;
    if (*((edx + 8)) != 6) {
        goto label_2;
    }
    edx = *((edx + 4));
    *((ebp - 0x3c)) = edx;
    edx = *((ebp - 0x20));
    edx++;
    if (*((ebp - 0x3c)) != edx) {
        goto label_2;
    }
    ecx = ebx;
    ecx <<= 4;
    edx = *((ebp + 8));
    edx = ecx + edx + 0x10;
    *((ebp - 0x30)) = edx;
    if (*(edx) != 0) {
        goto label_2;
    }
    eax = ecx;
    ecx = *((ebp + 8));
    eax = eax + ecx + 0x30;
    *((ebp - 0x34)) = eax;
    edx = *((ebp - 0x3c));
    if (edx != *((eax + 4))) {
        goto label_2;
    }
    if (*(eax) != 0) {
        goto label_2;
    }
    ecx = *((ebp - 0x30));
    *(fp_stack--) = *((ecx + 8));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(eax) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_3;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_4;
label_3:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_4:
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            if (*(obj.rationalize_denominators) == 0) {
                goto label_2;
            }
            eax = *((ebp - 0x34));
            *(fp_stack--) = *((eax + 8));
            *((ebp - 0x30)) = fp_stack[0];
            *(esp) = fp_stack[0];
            fp_stack--;
            eax = finite ();
            if (eax == 0) {
                goto label_2;
            }
            *(fp_stack--) = 0.0;
            *(fp_stack--) = *((ebp - 0x30));
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
            fp_stack--;
            if (fp_stack[0] >= fp_stack[1]) {
                goto label_5;
            }
            *(fp_stack--) = 1.0;
            fp_tmp_2 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_2;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] >= fp_stack[1]) {
                goto label_2;
            }
            eax = *(esi);
            eax += 2;
            if (eax > *(obj.n_tokens)) {
                error_huge ();
            }
            *(fp_stack--) = 1.0;
            eax = *((ebp - 0x34));
            *((eax + 8)) -= fp_stack[0];
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            eax = *(esi);
            eax -= ebx;
            eax <<= 4;
            edx = *((ebp - 0x1c));
            memmove (edx, edi, eax);
            *(esi) += 2;
            eax = ebx;
            eax <<= 4;
            ecx = *((ebp + 8));
            eax = eax + ecx + 0x10;
            edx = *((ebp - 0x20));
            *((eax + 4)) = edx;
            *(eax) = 0;
            edx = ebx + 3;
            edx <<= 4;
            *(fp_stack--) = *((edx + ecx + 8));
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            ebx += 2;
            *((ebp - 0x24)) = 1;
        }
    } else {
        *((edi + 8)) = 3;
        *(fp_stack--) = 1.0;
        ecx = *((ebp - 0x30));
        fp_stack[0] /= *((ecx + 8));
        *((ecx + 8)) = fp_stack[0];
        fp_stack--;
        *((ebp - 0x24)) = 1;
        goto label_2;
label_5:
        fp_stack++;
    }
label_2:
    ebx += 2;
    eax = *(esi);
    eax -= 2;
    if (eax > ebx) {
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806301f */
#include <stdint.h>
 
void dbg_uf_simp (void) {
    int32_t var_8h;
    int32_t var_4h;
    token_type * equation;
    int * np;
    char * var_sp_4h;
    /* void uf_simp(token_type * equation,int * np); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    uf_tsimp (esi, ebx);
    uf_power (esi, ebx);
    uf_repeat (esi, ebx);
    uf_tsimp (esi, ebx);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070300 */
#include <stdint.h>
 
uint32_t dbg_gcd (int32_t count) {
    double lower_limit;
    double divisor;
    double d1;
    double d2;
    ebx = count;
    /* double gcd(double d1,double d2); */
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x10)) = fp_stack[0];
    *(fp_stack--) = *((ebp + 0x10));
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = finite ();
    if (eax == 0) {
        goto label_1;
    }
    *(fp_stack--) = *((ebp - 0x18));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = finite ();
    if (eax == 0) {
        goto label_1;
    }
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[2];
    fp_stack[2] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    if (fp_stack[0] != fp_stack[2]) {
        if (fp_stack[0] == fp_stack[2]) {
            goto label_2;
        }
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
    } else {
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
    }
    fp_stack[2] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] == fp_stack[2]) {
        if (fp_stack[0] == fp_stack[2]) {
            goto label_3;
        }
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        goto label_4;
    }
label_3:
    *(fp_stack--) = fp_stack[0];
    __asm ("fcmovnbe st(0), st(2)");
    *((ebp - 0x10)) = fp_stack[0];
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    __asm ("fcmovbe st(0), st(2)");
    fp_stack[2] = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = fp_stack[1];
    fp_stack[0] *= *(obj.epsilon);
    *((ebp - 0x18)) = fp_stack[0];
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_5;
    }
    *(fp_stack--) = *(0x8076b48);
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_6;
    }
    ebx = 1;
label_0:
    *(fp_stack--) = *((ebp - 0x10));
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_7;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x10));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_8;
label_7:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_8:
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = *((ebp - 0x18));
    if (fp_stack[0] < fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x10));
        fp_stack[0] -= fp_stack[2];
        fp_stack[0] = abs(fp_stack[0]);
        fp_tmp_5 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_5;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] < fp_stack[1]) {
            goto label_9;
        }
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x10));
    *(fp_stack--) = 0.0;
    fp_tmp_6 = fp_stack[2];
    fp_stack[2] = fp_stack[0];
    fp_stack[0] = fp_tmp_6;
    fp_stack--;
    if (fp_stack[0] != fp_stack[2]) {
        if (fp_stack[0] == fp_stack[2]) {
            goto label_10;
        }
    }
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] *= *(0x8076e08);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_4;
label_9:
        ebx++;
        if (ebx == 0x32) {
            fp_stack++;
            *(fp_stack--) = 0.0;
            goto label_4;
        }
        *(fp_stack--) = *((ebp - 0x10));
        fp_tmp_7 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_7;
        *((ebp - 0x10)) = fp_stack[0];
        fp_stack--;
        goto label_0;
label_1:
        *(fp_stack--) = 0.0;
        goto label_4;
label_5:
        fp_stack++;
        goto label_11;
label_6:
        fp_stack++;
label_11:
        *(fp_stack--) = 0.0;
        goto label_4;
label_10:
        fp_stack++;
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x10));
    goto label_4;
label_2:
    fp_stack++;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8055821 */
#include <stdint.h>
 
int32_t dbg_output_current_directory (int32_t arg_8h, FILE * ofp) {
    char[4096] buf;
    int32_t canary;
    int32_t var_4h;
    char * var_8h;
    int32_t var_sp_ch;
    ebx = ofp;
    /* int output_current_directory(FILE * ofp); */
    ebx = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    if (*(obj.security_level) <= 2) {
        if (ebx != 0) {
            *((esp + 4)) = 0x1000;
            eax = ebp - 0x100c;
            *(esp) = eax;
            eax = getcwd ();
            if (eax == 0) {
                goto label_0;
            }
            eax = ebp - 0x100c;
            *((esp + 0xc)) = eax;
            *((esp + 8)) = "directory = %s\n";
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
            eax = 1;
        }
    } else {
label_0:
        eax = 0;
    }
    edx = *((ebp - 0xc));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8058321 */
#include <stdint.h>
 
int32_t dbg_simplify_cmd (int32_t arg_8h, int32_t k1, int32_t k, int32_t frac_flag, int32_t symb) {
    int32_t var_26ch;
    long int counter_max;
    uint32_t var_25ch;
    int32_t var_258h;
    int32_t quick_flag;
    int32_t quickest_flag;
    long int counter;
    int32_t var_244h;
    int32_t var_240h;
    char * cp;
    long int[100] previous_solution_number;
    int32_t j;
    int32_t i;
    sign_array_type sa_value;
    sign_array_type sa_mark;
    int32_t canary;
    char * s2;
    size_t n;
    int32_t var_ch;
    ebx = k1;
    edx = k;
    esi = frac_flag;
    edi = symb;
    /* int simplify_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x23c)) = eax;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    *((ebp - 0x258)) = 0;
    edi = 0;
    *((ebp - 0x250)) = 0;
    *((ebp - 0x254)) = 0;
    *((ebp - 0x25c)) = 0;
    esi = 1;
    *((ebp - 0x240)) = edi;
    do {
        ebx = *((ebp - 0x23c));
        eax = strncasecmp (ebx, "sign", 4);
        if (eax == 0) {
            edi = esi;
        } else {
            eax = strncasecmp (ebx, "symbolic", 4);
            if (eax == 0) {
                *((ebp - 0x240)) = esi;
            } else {
                *((esp + 4)) = "quickest";
                eax = strcmp_tospace (ebx);
                if (eax == 0) {
                    *((ebp - 0x250)) = esi;
                } else {
                    *((esp + 4)) = "quick";
                    eax = *((ebp - 0x23c));
                    eax = strcmp_tospace (eax);
                    if (eax == 0) {
                        *((ebp - 0x254)) = esi;
                    } else {
                        eax = *((ebp - 0x23c));
                        eax = strncasecmp (eax, "fraction", 4);
                        if (eax != 0) {
                            goto label_2;
                        }
                        *((ebp - 0x258)) = esi;
                    }
                }
            }
        }
        eax = *((ebp - 0x23c));
        eax = skip_param (eax);
        *((ebp - 0x23c)) = eax;
    } while (1);
label_2:
    *((ebp - 0x25c)) = edi;
    edi = *((ebp - 0x240));
    eax = ebp - 0xa4;
    eax = ebp - 0xa0;
    eax = ebp - 0x23c;
    eax = get_range_eol (eax, eax, eax);
    edx = eax;
    eax = 0;
    if (edx == 0) {
        goto label_3;
    }
    *(obj.symb_flag) = edi;
    eax = *((ebp - 0xa0));
    if (eax > *((ebp - 0xa4))) {
        goto label_4;
    }
    esi = ebp - 0x5c;
label_1:
    if (*((eax*4 + obj.n_lhs)) == 0) {
        goto label_5;
    }
    if (*((ebp - 0x250)) != 0) {
        simp_equation (eax);
    } else {
        edx = *((ebp - 0x258));
        *((esp + 0xc)) = edx;
        ecx = *((ebp - 0x254));
        edx = eax*4 + obj_n_lhs;
        eax = *((eax*4 + obj.lhs));
        simpa_repeat_side (eax, edx, ecx);
        eax = *((ebp - 0xa0));
        ebx = *((ebp - 0x258));
        *((esp + 0xc)) = ebx;
        edi = *((ebp - 0x254));
        edx = eax*4 + obj_n_rhs;
        eax = *((eax*4 + obj.rhs));
        simpa_repeat_side (eax, edx, edi);
    }
    eax = *((ebp - 0xa0));
    eax = return_result (eax);
    if (eax == 0) {
        *(obj.symb_flag) = 0;
        goto label_3;
    }
    if (*((ebp - 0x25c)) == 0) {
        goto label_5;
    }
    edx = ebp - 0x234;
    eax = 0;
    ecx = 0x64;
    edi = edx;
    memset (edi, eax, ecx);
    cl = 0x10;
    edi = esi;
    memset (edi, eax, ecx);
    ecx = *((ebp - 0xa0));
    edx = *((ecx*4 + obj.n_lhs));
    if (edx <= 0) {
        goto label_6;
    }
    ebx = lhs;
    do {
        edi = eax;
        edi <<= 4;
        edi += *((ebx + ecx*4));
        if (*(edi) == 1) {
            edi = *((edi + 8));
            *((ebp - 0x244)) = edi;
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_7;
            }
            edi = *((ebp - 0x244));
            edi >>= 0xe;
            edi &= 0x3f;
            *((ebp + edi - 0x5c)) = 1;
        }
label_7:
        eax += 2;
    } while (edx > eax);
label_6:
    edx = *((ebp - 0xa0));
    ecx = *((edx*4 + obj.n_rhs));
    if (ecx <= 0) {
        goto label_8;
    }
    eax = 0;
    ebx = rhs;
    do {
        edi = eax;
        edi <<= 4;
        edi += *((ebx + edx*4));
        if (*(edi) == 1) {
            edi = *((edi + 8));
            *((ebp - 0x244)) = edi;
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_9;
            }
            edi = *((ebp - 0x244));
            edi >>= 0xe;
            edi &= 0x3f;
            *((ebp + edi - 0x5c)) = 1;
        }
label_9:
        eax += 2;
    } while (ecx > eax);
label_8:
    eax = 0;
    ecx = 0;
    do {
        ecx -= 0xffffffff;
        eax++;
    } while (eax != 0x40);
    if (ecx == 0) {
        goto label_5;
    }
    al = 1;
    eax <<= cl;
    eax--;
    *((ebp - 0x260)) = eax;
    if (eax < 0) {
        goto label_5;
    }
    *((ebp - 0x244)) = 1;
    *((ebp - 0x24c)) = 0;
label_0:
    eax = next_espace ();
    *((ebp - 0x240)) = eax;
    eax = *((ebp - 0xa0));
    copy_espace (eax, eax);
    eax = 0;
    ecx = 0;
    do {
        if (*((esi + eax)) != 0) {
            edi = *((ebp - 0x24c));
            edi >>= cl;
            edi &= 1;
            ebx = edi;
            *((ebp + eax - 0x9c)) = bl;
            ecx++;
        }
        eax++;
    } while (eax != 0x40);
    edi = *((ebp - 0x240));
    if (*((edi*4 + obj.n_lhs)) <= 0) {
        goto label_10;
    }
    al = 0;
    edi = lhs;
    do {
        ecx = eax;
        ecx <<= 4;
        edx = ecx;
        ebx = *((ebp - 0x240));
        edx += *((edi + ebx*4));
        if (*(edx) == 1) {
            ebx = *((edx + 8));
            *((ebp - 0x26c)) = ebx;
            ebx &= 0x3fff;
            if (ebx != 4) {
                goto label_11;
            }
            ebx = *((ebp - 0x26c));
            ebx >>= 0xe;
            ebx &= 0x3f;
            if (*((ebp + ebx - 0x9c)) != 0) {
                *(edx) = 0;
                ebx = *((ebp - 0x240));
                edx = *((edi + ebx*4));
                *(fp_stack--) = 1.0;
                fp_stack[0] = -fp_stack[0];
                *((ecx + edx + 8)) = fp_stack[0];
                fp_stack--;
            } else {
                *(edx) = 0;
                ebx = *((ebp - 0x240));
                edx = *((edi + ebx*4));
                *(fp_stack--) = 1.0;
                *((ecx + edx + 8)) = fp_stack[0];
                fp_stack--;
            }
        }
label_11:
        eax += 2;
        edx = *((ebp - 0x240));
        ecx = n_lhs;
    } while (*((ecx + edx*4)) > eax);
label_10:
    ebx = *((ebp - 0x240));
    if (*((ebx*4 + obj.n_rhs)) <= 0) {
        goto label_12;
    }
    eax = 0;
    edi = rhs;
    do {
        ecx = eax;
        ecx <<= 4;
        edx = ecx;
        ebx = *((ebp - 0x240));
        edx += *((edi + ebx*4));
        if (*(edx) == 1) {
            ebx = *((edx + 8));
            *((ebp - 0x26c)) = ebx;
            ebx &= 0x3fff;
            if (ebx != 4) {
                goto label_13;
            }
            ebx = *((ebp - 0x26c));
            ebx >>= 0xe;
            ebx &= 0x3f;
            if (*((ebp + ebx - 0x9c)) != 0) {
                *(edx) = 0;
                ebx = *((ebp - 0x240));
                edx = *((edi + ebx*4));
                *(fp_stack--) = 1.0;
                fp_stack[0] = -fp_stack[0];
                *((ecx + edx + 8)) = fp_stack[0];
                fp_stack--;
            } else {
                *(edx) = 0;
                ebx = *((ebp - 0x240));
                edx = *((edi + ebx*4));
                *(fp_stack--) = 1.0;
                *((ecx + edx + 8)) = fp_stack[0];
                fp_stack--;
            }
        }
label_13:
        eax += 2;
        edx = *((ebp - 0x240));
        ecx = n_rhs;
    } while (*((ecx + edx*4)) > eax);
label_12:
    ebx = 0;
    eax = 0;
    do {
        edi = ebx;
        if (*((esi + ebx)) != 0) {
            if (eax != 0) {
                *((esp + 8)) = 0x8075f0e;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            } else {
                eax = *((ebp - 0x244));
                *((esp + 0xc)) = eax;
                *((esp + 8)) = "Solution number %ld with ";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            eax = ebx;
            eax <<= 0xe;
            eax += 4;
            list_var (eax, 0);
            *((esp + 0xc)) = 0x8079800;
            *((esp + 8)) = "%s = ";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            if (*((ebp + edi - 0x9c)) != 0) {
                *((esp + 8)) = 0x8075f2b;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                eax = 1;
            } else {
                *((esp + 8)) = 0x8075f2c;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                eax = 1;
            }
        }
        ebx++;
    } while (ebx != 0x40);
    if (eax != 0) {
        *((esp + 8)) = 0x8072669;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    if (*((ebp - 0x250)) != 0) {
        edx = *((ebp - 0x240));
        simp_equation (edx);
    } else {
        ebx = *((ebp - 0x240));
        ebx <<= 2;
        ecx = *((ebp - 0x258));
        *((esp + 0xc)) = ecx;
        edi = *((ebp - 0x254));
        eax = ebx + obj_n_lhs;
        edx = *((ebp - 0x240));
        eax = *((edx*4 + obj.lhs));
        simpa_repeat_side (eax, eax, edi);
        ecx = *((ebp - 0x258));
        *((esp + 0xc)) = ecx;
        ebx += obj.n_rhs;
        ebx = *((ebp - 0x240));
        eax = *((ebx*4 + obj.rhs));
        simpa_repeat_side (eax, ebx, edi);
    }
    ebx = 0;
    edi = *((ebp - 0x240));
    do {
        if (*((ebp + ebx*4 - 0x234)) != 0) {
            eax = compare_es (ebx, edi);
            if (eax != 0) {
                edi = *((ebp - 0x240));
                *((edi*4 + obj.n_lhs)) = 0;
                *((edi*4 + obj.n_rhs)) = 0;
                eax = *((ebp + ebx*4 - 0x234));
                *((esp + 0xc)) = eax;
                *((esp + 8)) = "is identical to solution number %ld.\n";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
        } else {
            ebx++;
        } while (ebx != 0x64);
    }
    eax = *((ebp - 0x240));
    if (*((eax*4 + obj.n_lhs)) != 0) {
        list_sub (eax);
        ecx = *((ebp - 0x244));
        edx = *((ebp - 0x240));
        *((ebp + edx*4 - 0x234)) = ecx;
    }
    *((ebp - 0x24c))++;
    *((ebp - 0x244))++;
    ebx = *((ebp - 0x24c));
    if (*((ebp - 0x260)) >= ebx) {
        goto label_0;
    }
label_5:
    eax = *((ebp - 0xa0));
    eax++;
    *((ebp - 0xa0)) = eax;
    if (*((ebp - 0xa4)) >= eax) {
        goto label_1;
    }
label_4:
    *(obj.symb_flag) = 0;
    eax = 1;
label_3:
    edi = *((ebp - 0x1c));
    edi ^= *(gs:0x14);
    if (*((ebp - 0xa4)) != eax) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8054fe6 */
#include <stdint.h>
 
uint32_t dbg_tally_cmd (int32_t i) {
    int32_t arithmetic_mean;
    double count;
    char * cp;
    char * s2;
    size_t n;
    ebx = i;
    /* int tally_cmd(char * cp); */
    ebx = *((ebp + 8));
    eax = strncasecmp (ebx, "average", 4);
    *((ebp - 0x24)) = 0;
    if (eax == 0) {
        eax = skip_param (ebx);
        ebx = eax;
        *((ebp - 0x24)) = 1;
    }
    eax = extra_characters (ebx);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        goto label_2;
    }
    eax = trhs;
    edx = zero_token;
    *(eax) = edx;
    edx = .comment;
    *((eax + 4)) = edx;
    edx = .comment;
    *((eax + 8)) = edx;
    edx = .comment;
    *((eax + 0xc)) = edx;
    *(obj.n_trhs) = 1;
    edi = "Running total = ";
    *((esp + 8)) = edi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = 0;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    list_proc ();
    esi = 0x80757fd;
    *((esp + 8)) = esi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = 0.0;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    ebx = 0;
    goto label_1;
label_0:
    if (*((ebp - 0x24)) == 0) {
        goto label_1;
    }
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    eax = tlhs;
    memmove (eax, eax, eax);
    eax = n_trhs;
    *(obj.n_tlhs) = eax;
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    edx = n_tlhs;
    if (edx <= 0) {
        goto label_3;
    }
    eax = ebx;
    do {
        edx = ebx;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
        edx = n_tlhs;
    } while (edx > eax);
label_3:
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 4;
    eax = n_tlhs;
    eax++;
    *(obj.n_tlhs) = eax;
    eax <<= 4;
    edx = tlhs;
    *((eax + edx)) = 0;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *(fp_stack--) = *((ebp - 0x20));
    *((edx + eax + 8)) = fp_stack[0];
    fp_stack--;
    *(obj.n_tlhs)++;
    *((esp + 4)) = 0x80796b8;
    eax = tlhs;
    *(esp) = eax;
    calc_simp ();
    *((esp + 8)) = "Average = ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = ebx;
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    *(esp) = eax;
    list_proc ();
    *((esp + 8)) = esi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
label_1:
    *((esp + 8)) = esi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = 0x50;
    my_strlcpy (obj.prompt_str, "Enter value: ");
    eax = tlhs;
    eax = get_expr (eax, 0x80796b8);
    if (eax == 0) {
        goto label_4;
    }
    eax = n_trhs;
    eax += *(obj.n_tlhs);
    eax++;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*(obj.n_tlhs) <= 0) {
        goto label_5;
    }
    eax = ebx;
    do {
        edx = ebx;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
    } while (*(obj.n_tlhs) > eax);
label_5:
    edx = n_trhs;
    if (edx <= 0) {
        goto label_6;
    }
    eax = ebx;
    do {
        edx = ebx;
        edx <<= 4;
        edx += *(obj.trhs);
        *((edx + 4))++;
        eax++;
        edx = n_trhs;
    } while (edx > eax);
label_6:
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 4)) = 1;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 8)) = 1;
    eax = n_trhs;
    eax++;
    *(obj.n_trhs) = eax;
    edx = n_tlhs;
    edx <<= 4;
    edx = tlhs;
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, edx, edx);
    eax = n_tlhs;
    *(obj.n_trhs) += eax;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    calc_simp ();
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] += *(0x8075170);
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *((esp + 8)) = edi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = ebx;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    list_proc ();
    *((esp + 8)) = esi;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_0;
    }
    goto label_1;
label_4:
    *((esp + 8)) = "End.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a39a */
#include <stdint.h>
 
uint32_t dbg_exp_contains_nan (char * arg_ch, int32_t i, int32_t n1) {
    token_type * p1;
    esi = i;
    edi = n1;
    /* int exp_contains_nan(token_type * p1,int n1); */
    edi = *((ebp + 0xc));
    if (edi <= 0) {
        goto label_0;
    }
    ebx = *((ebp + 8));
    esi = 0;
    do {
        if (*(ebx) == 0) {
            *(fp_stack--) = *((ebx + 8));
            *(esp) = fp_stack[0];
            fp_stack--;
            eax = isnan ();
            if (eax == 0) {
                goto label_1;
            }
            eax = 1;
            goto label_2;
        }
label_1:
        esi += 2;
        ebx += 0x20;
    } while (edi > esi);
label_0:
    eax = 0;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ac74 */
#include <stdint.h>
 
int32_t dbg_alloc_next_espace (int32_t i, int32_t n) {
    ebx = i;
    ecx = n;
    /* int alloc_next_espace(); */
    edx = cur_equation;
    edi = n_equations;
    if (edx < edi) {
        if (*((edx*4 + obj.n_lhs)) != 0) {
            goto label_2;
        }
        goto label_3;
label_0:
        ecx = edx + 1;
        eax = 0x51eb851f;
        edx:eax = eax * ecx;
        edx >>= 5;
        eax = ecx;
        eax >>= 0x1f;
        edx -= eax;
        edx *= 0x64;
        ecx -= edx;
        edx = ecx;
label_1:
        if (edx < edi) {
            goto label_4;
        }
    }
    eax = alloc_espace (edi);
    if (eax != 0) {
        goto label_5;
    }
    warning ("Memory is exhausted.");
    eax = n_equations;
    if (eax <= 0) {
        goto label_6;
    }
    edx = 0;
    ecx = n_lhs;
    if (*(obj.n_lhs) != 0) {
        goto label_7;
    }
    while (edx < eax) {
        if (*((ecx + edx*4)) == 0) {
            *((edx*4 + obj.n_rhs)) = 0;
            goto label_8;
        }
label_7:
        edx++;
    }
    goto label_6;
label_5:
    *(obj.n_equations)++;
    edx = edi;
    goto label_8;
label_4:
    if (*((esi + edx*4)) == 0) {
        goto label_3;
    }
    ebx++;
    if (ebx != 0x64) {
        goto label_0;
    }
    goto label_6;
label_3:
    *((edx*4 + obj.n_rhs)) = 0;
    goto label_8;
label_6:
    edx = 0xffffffff;
label_8:
    eax = 0xffffffff;
    return eax;
label_2:
    ecx = edx + 1;
    edx = 0x51eb851f;
    eax = ecx;
    edx:eax = eax * edx;
    edx >>= 5;
    ebx = ecx;
    ebx >>= 0x1f;
    edx -= ebx;
    edx *= 0x64;
    ecx -= edx;
    edx = ecx;
    ebx = 1;
    esi = n_lhs;
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805d8af */
#include <stdint.h>
 
int32_t dbg_simp_i (char * arg_ch, int * np, int32_t i) {
    int32_t var_24h;
    int32_t level;
    int32_t var_1ch;
    token_type * equation;
    char * s2;
    size_t n;
    esi = np;
    edi = i;
    /* void simp_i(token_type * equation,int * np); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    simp_loop (esi, ebx);
    eax = *(ebx);
    if (eax <= 0) {
        goto label_0;
    }
    edi = 0;
    *((ebp - 0x1c)) = esi;
    esi = ebx;
    do {
        *((ebp - 0x24)) = edi;
        ebx = edi;
        ebx <<= 4;
        ebx += *((ebp - 0x1c));
        if (*(ebx) == 1) {
            if (*((ebx + 8)) != 3) {
                goto label_1;
            }
            eax += 2;
            if (eax > *(obj.n_tokens)) {
                error_huge ();
            }
            eax = *((ebx + 4));
            eax++;
            *((ebp - 0x20)) = eax;
            eax = *(esi);
            eax -= edi;
            eax <<= 4;
            eax = *((ebp - 0x24));
            eax <<= 4;
            edx = *((ebp - 0x1c));
            eax = eax + edx + 0x20;
            memmove (eax, ebx, eax);
            *(esi) += 2;
            eax = *((ebp - 0x20));
            *((ebx + 4)) = eax;
            *(ebx) = 0;
            *(fp_stack--) = 1.0;
            fp_stack[0] = -fp_stack[0];
            *((ebx + 8)) = fp_stack[0];
            fp_stack--;
            eax = edi;
            eax <<= 4;
            edx = *((ebp - 0x1c));
            eax = eax + edx + 0x10;
            edx = *((ebp - 0x20));
            *((eax + 4)) = edx;
            *(eax) = 2;
            *((eax + 8)) = 6;
            edi += 2;
            eax = edi;
            eax <<= 4;
            eax += *((ebp - 0x1c));
            *((eax + 4)) = edx;
            *(eax) = 0;
            *(fp_stack--) = *(0x8072054);
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
        }
label_1:
        edi += 2;
        eax = *(esi);
    } while (eax > edi);
    ebx = esi;
    esi = *((ebp - 0x1c));
    do {
label_0:
        *((esp + 4)) = ebx;
        organize (esi);
        *((esp + 8)) = 0;
        *((esp + 4)) = ebx;
        *(esp) = esi;
        combine_constants ();
        *((esp + 4)) = ebx;
        eax = elim_k (esi);
    } while (eax != 0);
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = simp_pp ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = factor_power ();
    if (eax != 0) {
        goto label_0;
    }
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = factor_times ();
    if (eax != 0) {
        goto label_0;
    }
    simp_loop (esi, ebx);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806f98b */
#include <stdint.h>
 
int32_t dbg_list_expression (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, char * cp, int32_t n, int32_t export_flag, int32_t len) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    ebx = cp;
    esi = n;
    edi = export_flag;
    eax = len;
    /* char * list_expression(token_type * p1,int n,int export_flag); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    ebx = 0;
    if (esi > 0) {
        *((esp + 0xc)) = edi;
        *((esp + 8)) = 0;
        *((esp + 4)) = esi;
        eax = *((ebp + 8));
        *(esp) = eax;
        eax = list_string ();
        eax++;
        eax = malloc (eax);
        ebx = eax;
        if (eax == 0) {
            *(esp) = 0x8077c40;
            eax = error ();
        } else {
            *((esp + 0xc)) = edi;
            *((esp + 8)) = eax;
            *((esp + 4)) = esi;
            eax = *((ebp + 8));
            *(esp) = eax;
            list_string ();
        }
    }
    eax = ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d0ae */
#include <stdint.h>
 
int32_t dbg_roots_cmd (int32_t arg_8h) {
    double radius_root;
    double k;
    double root;
    double d;
    int32_t var_1078h;
    int32_t var_1074h;
    int32_t var_1070h;
    int32_t var_106ch;
    char * cp;
    complexs check;
    int32_t var_104ch;
    int32_t var_1048h;
    int32_t var_1044h;
    complexs c2;
    int32_t var_103ch;
    int32_t var_1038h;
    int32_t var_1034h;
    double theta;
    double radius;
    char[4096] buf;
    int32_t canary;
    int32_t var_ch;
    char * endptr;
    char * var_8h;
    int32_t var_sp_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_sp_1ch;
    int32_t var_20h;
    int32_t var_24h;
    /* int roots_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x105c)) = eax;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    *(fp_stack--) = 0.0;
    *((ebp - 0x1098)) = fp_stack[0];
    fp_stack--;
    edi = ebp - 0x1040;
    ebx = ebp - 0x1078;
label_1:
    eax = *((ebp - 0x105c));
    if (*(eax) == 0) {
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter root (positive integer): ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x105c)) = eax;
        if (eax == 0) {
            goto label_2;
        }
    }
    eax = ebp - 0x105c;
    eax = *((ebp - 0x105c));
    strtod (eax, eax);
    *((ebp - 0x1088)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x105c));
    esi = *(eax);
    edx = esi;
    if (dl != 0) {
        eax = ctype_b_loc ();
        edx = esi;
        esi = (int32_t) dl;
        eax = *(eax);
        if ((*((eax + esi*2 + 1)) & 0x20) == 0) {
            goto label_3;
        }
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x1088));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_4;
    }
    *(fp_stack--) = *(0x8077980);
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_3;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x1088));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_5;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x1088));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_5:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_6;
        }
        goto label_3;
label_4:
        fp_stack++;
    }
label_3:
    *(fp_stack--) = *(0x8077980);
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = "Root must be a positive integer less than or equal to %.0f.\n";
    *(esp) = 1;
    printf_chk ();
    eax = 0;
    goto label_7;
label_6:
    eax = *((ebp - 0x105c));
    eax = skip_space (eax);
    *((ebp - 0x105c)) = eax;
    if (*(eax) == 0) {
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter real part (X): ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x105c)) = eax;
        if (eax == 0) {
            goto label_2;
        }
    }
    eax = ebp - 0x105c;
    eax = *((ebp - 0x105c));
    strtod (eax, eax);
    *((ebp - 0x1080)) = fp_stack[0];
    fp_stack--;
    esi = *((ebp - 0x105c));
    edx = *(esi);
    *((ebp - 0x1090)) = dl;
    if (dl != 0) {
        eax = ctype_b_loc ();
        edx = *((ebp - 0x1090));
        eax = *(eax);
        if ((*((eax + edx*2 + 1)) & 0x20) != 0) {
            goto label_8;
        }
        *(esp) = "Number expected.";
        error ();
        eax = 0;
        goto label_7;
    }
label_8:
    eax = skip_space (esi);
    *((ebp - 0x105c)) = eax;
    if (*(eax) == 0) {
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter imaginary part (Y): ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x105c)) = eax;
        if (eax == 0) {
            goto label_2;
        }
    }
    eax = ebp - 0x105c;
    eax = *((ebp - 0x105c));
    strtod (eax, eax);
    *((ebp - 0x1090)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x105c));
    if (*(eax) != 0) {
        *(esp) = "Number expected.";
        error ();
        eax = 0;
        goto label_7;
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x1080));
    fp_stack--;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_9;
        }
        *(fp_stack--) = *((ebp - 0x1090));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_10;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_10;
        }
        eax = repeat_flag;
        goto label_7;
    }
    fp_stack++;
    goto label_10;
label_9:
    fp_stack++;
label_10:
    errno_location ();
    *(eax) = 0;
    eax = ebp - 0x1030;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1028;
    *((esp + 0x10)) = eax;
    *(fp_stack--) = *((ebp - 0x1090));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x1080));
    *(esp) = fp_stack[0];
    fp_stack--;
    rect_to_polar ();
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x1088));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_11;
        }
    }
    *(0x8075170) /= fp_stack[0];
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x1028));
    *(esp) = fp_stack[0];
    fp_stack--;
    pow ();
    *((ebp - 0x1098)) = fp_stack[0];
    fp_stack--;
    check_err ();
    *(fp_stack--) = *((ebp - 0x1030));
    eax = precision;
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] *= *(0x8077984);
    fp_stack[0] /= *(0x8075658);
    *((esp + 0x28)) = fp_stack[0];
    fp_stack--;
    *((esp + 0x24)) = eax;
    *((esp + 0x1c)) = fp_stack[0];
    fp_stack--;
    *((esp + 0x18)) = eax;
    *(fp_stack--) = *((ebp - 0x1028));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "\nThe polar coordinates are:\n%.*g amplitude and %.*g radians (%.*g degrees).\n\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    goto label_12;
label_11:
    fp_stack++;
    check_err ();
    *(fp_stack--) = *((ebp - 0x1030));
    eax = precision;
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] *= *(0x8077984);
    fp_stack[0] /= *(0x8075658);
    *((esp + 0x28)) = fp_stack[0];
    fp_stack--;
    *((esp + 0x24)) = eax;
    *((esp + 0x1c)) = fp_stack[0];
    fp_stack--;
    *((esp + 0x18)) = eax;
    *(fp_stack--) = *((ebp - 0x1028));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "\nThe polar coordinates are:\n%.*g amplitude and %.*g radians (%.*g degrees).\n\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x1088));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_13;
        }
    }
label_12:
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x1090));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            *(fp_stack--) = *((ebp - 0x1088));
            *((esp + 0x1c)) = fp_stack[0];
            *(fp_stack--) = *((ebp - 0x1080));
            *((esp + 0x14)) = fp_stack[0];
            fp_stack--;
            *((esp + 0xc)) = fp_stack[0];
            fp_stack--;
            *((esp + 8)) = "The %.12g roots of (%.12g)^(1/%.12g) are:\n\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
    } else {
        *(fp_stack--) = *((ebp - 0x1088));
        *((esp + 0x24)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x1090));
        *((esp + 0x1c)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x1080));
        *((esp + 0x14)) = fp_stack[0];
        fp_stack--;
        *(fp_stack--) = *((ebp - 0x1088));
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = "The %.12g roots of (%.12g%+.12g*i)^(1/%.12g) are:\n\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x1088));
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_14;
    }
    *((ebp - 0x1090)) = fp_stack[0];
    fp_stack--;
    esi = ebp - 0x1050;
label_0:
    *(fp_stack--) = *((ebp - 0x1090));
    fp_stack[0] += fp_stack[0];
    fp_stack[0] *= *(0x8075658);
    fp_stack[0] += *((ebp - 0x1030));
    fp_stack[0] /= *((ebp - 0x1088));
    *((ebp - 0x1080)) = fp_stack[0];
    *(esp) = fp_stack[0];
    fp_stack--;
    cos ();
    fp_stack[0] *= *((ebp - 0x1098));
    *((ebp - 0x1040)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x1080));
    *(esp) = fp_stack[0];
    fp_stack--;
    sin ();
    fp_stack[0] *= *((ebp - 0x1098));
    *((ebp - 0x1038)) = fp_stack[0];
    fp_stack--;
    complex_fixup (edi);
    *(fp_stack--) = *((ebp - 0x1040));
    *(fp_stack--) = 0.0;
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            *(fp_stack--) = *((ebp - 0x1038));
            fp_stack--;
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] != fp_stack[2]) {
                goto label_15;
            }
            if (fp_stack[0] == fp_stack[2]) {
                goto label_16;
            }
            fp_stack[1] = fp_stack[0];
            fp_stack--;
        } else {
        } else {
            fp_stack[1] = fp_stack[0];
            fp_stack--;
        }
    }
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    *((esp + 8)) = "%.12g ";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    goto label_17;
label_15:
    fp_stack++;
    goto label_17;
label_16:
    fp_stack++;
label_17:
    *(fp_stack--) = *((ebp - 0x1038));
    *(fp_stack--) = 0.0;
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_18;
        }
    }
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    *((esp + 8)) = "%+.12g*i";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    goto label_19;
label_18:
    fp_stack++;
label_19:
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = *((ebp - 0x1040));
    *((ebp - 0x1050)) = eax;
    eax = *((ebp - 0x103c));
    *((ebp - 0x104c)) = eax;
    eax = *((ebp - 0x1038));
    *((ebp - 0x1048)) = eax;
    eax = *((ebp - 0x1034));
    *((ebp - 0x1044)) = eax;
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x1088));
    fp_stack--;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_20;
    }
    *((ebp - 0x1080)) = fp_stack[0];
    fp_stack--;
    do {
        eax = *((ebp - 0x1040));
        *((esp + 0x14)) = eax;
        eax = *((ebp - 0x103c));
        *((esp + 0x18)) = eax;
        eax = *((ebp - 0x1038));
        *((esp + 0x1c)) = eax;
        eax = *((ebp - 0x1034));
        *((esp + 0x20)) = eax;
        eax = *((ebp - 0x1050));
        *((esp + 4)) = eax;
        eax = *((ebp - 0x104c));
        *((esp + 8)) = eax;
        eax = *((ebp - 0x1048));
        *((esp + 0xc)) = eax;
        eax = *((ebp - 0x1044));
        *((esp + 0x10)) = eax;
        complex_mult (ebx);
        eax = *((ebp - 0x1078));
        *((ebp - 0x1050)) = eax;
        eax = *((ebp - 0x1074));
        *((ebp - 0x104c)) = eax;
        eax = *((ebp - 0x1070));
        *((ebp - 0x1048)) = eax;
        eax = *((ebp - 0x106c));
        *((ebp - 0x1044)) = eax;
        *(fp_stack--) = *((ebp - 0x1080));
        fp_stack[0] += *(0x8075170);
        *((ebp - 0x1080)) = fp_stack[0];
        *(fp_stack--) = *((ebp - 0x1088));
        fp_stack--;
        fp_stack++;
    } while (fp_stack[0] > fp_stack[1]);
    goto label_21;
label_20:
    fp_stack++;
label_21:
    complex_fixup (esi);
    *((esp + 4)) = "Inverse check:";
    *(esp) = 1;
    printf_chk ();
    *(fp_stack--) = *((ebp - 0x1050));
    *(fp_stack--) = 0.0;
    fp_tmp_5 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_5;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            *(fp_stack--) = *((ebp - 0x1048));
            fp_stack--;
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] != fp_stack[2]) {
                goto label_22;
            }
            if (fp_stack[0] == fp_stack[2]) {
                goto label_23;
            }
            fp_stack[1] = fp_stack[0];
            fp_stack--;
        } else {
        } else {
            fp_stack[1] = fp_stack[0];
            fp_stack--;
        }
    }
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = " %.10g";
    *(esp) = 1;
    printf_chk ();
    goto label_24;
label_22:
    fp_stack++;
    goto label_24;
label_23:
    fp_stack++;
label_24:
    *(fp_stack--) = *((ebp - 0x1048));
    *(fp_stack--) = 0.0;
    fp_tmp_6 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_6;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_25;
        }
    }
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *((esp + 4)) = " %+.10g*i";
    *(esp) = 1;
    printf_chk ();
    goto label_26;
label_25:
    fp_stack++;
label_26:
    *((esp + 4)) = 0x80757fc;
    *(esp) = 1;
    printf_chk ();
    *(fp_stack--) = *((ebp - 0x1090));
    fp_stack[0] += *(0x8075170);
    *((ebp - 0x1090)) = fp_stack[0];
    *(fp_stack--) = *((ebp - 0x1088));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_0;
    }
    goto label_13;
label_14:
    fp_stack++;
label_13:
    if (*(obj.repeat_flag) != 0) {
        goto label_1;
    }
    eax = 1;
    goto label_7;
label_2:
    eax = 0;
label_7:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*(obj.repeat_flag) != 0) {
        stack_chk_fail ();
    }
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80526ba */
#include <stdint.h>
 
uint32_t dbg_version_cmd (int32_t rv) {
    char * cp;
    int32_t var_4h;
    char * var_8h;
    ebx = rv;
    /* int version_cmd(char * cp); */
    eax = version_report ();
    ebx = eax;
    *((esp + 8)) = "\nMathomatic is GNU LGPL version 2.1 licensed software,\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "meaning it is free software that comes with no warranty.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "Type \"help copyright\" for the copyright and license.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "\nThe newest version of Mathomatic is always available at\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "the Mathomatic website: http://mathomatic.org\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "Feedback and contributions are welcomed.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a535 */
#include <stdint.h>
 
uint32_t dbg_skip_param (char * arg_8h, char * cp) {
    ebx = cp;
    /* char * skip_param(char * cp); */
    ebx = *((ebp + 8));
    if (ebx == 0) {
        goto label_1;
    }
    eax = *(ebx);
    if (al != 0) {
        goto label_2;
    }
    goto label_3;
    do {
label_0:
        ebx++;
        eax = *(ebx);
        if (al == 0) {
            goto label_3;
        }
label_2:
    } while (al < 0);
    eax = (int32_t) al;
    eax = isdelimiter (eax);
    if (eax == 0) {
        goto label_0;
    }
label_3:
    eax = skip_space (ebx);
    ebx = eax;
    eax = *(eax);
    eax = isdelimiter (eax);
    if (eax != 0) {
        ebx++;
        eax = skip_space (ebx);
        ebx = eax;
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80694f5 */
#include <stdint.h>
 
int32_t dbg_differentiate (void ** arg_8h, char * arg_ch, int32_t i, token_type * equation, int * np) {
    long int v;
    size_t * var_4h;
    int32_t var_8h;
    ebx = i;
    esi = equation;
    edi = np;
    /* int differentiate(token_type * equation,int * np,long int v); */
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    *((esp + 4)) = edi;
    organize (esi);
    eax = *(edi);
    if (eax <= 1) {
        goto label_0;
    }
    ebx = 1;
    do {
        edx = 1;
        edx <<= 4;
        edx = *((esi + edx + 8));
        edx -= 3;
        if (edx <= 1) {
            *((esp + 8)) = ebx;
            *((esp + 4)) = eax;
            binary_parenthesize (esi);
        }
        ebx += 2;
        eax = *(edi);
    } while (eax > ebx);
label_0:
    eax = *((ebp + 0x10));
    ecx = 0;
    edx = edi;
    eax = esi;
    d_recurse (1, eax);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8052177 */
#include <stdint.h>
 
int32_t dbg_output_options (int32_t arg_8h, FILE * __stream) {
    int32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    ebx = __stream;
    /* void output_options(FILE * ofp); */
    ebx = *((ebp + 8));
    if (ebx != 0) {
        eax = precision;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "precision = %d digits\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.autosolve) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "autosolve\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.autocalc) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "autocalc\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.autoselect) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "autoselect\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        eax = debug_level;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "debug_level = %d\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.case_sensitive_flag) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "case_sensitive\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.color_flag) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "color\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.bold_colors) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "bold_colors\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.display2d) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "display2d\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.preserve_surds) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "preserve_surds\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.rationalize_denominators) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "rationalize_denominators\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        eax = modulus_mode;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "modulus_mode = %d\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        eax = finance_option;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "finance = %d\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.factor_int_flag) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "factor_integers\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.right_associative_power) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "right_associative_power\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        if (*(obj.negate_highest_precedence) == 0) {
            *((esp + 8)) = 0x80756ec;
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
        }
        *((esp + 8)) = "negate_highest_precedence\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
        *((esp + 0xc)) = 0x8079180;
        *((esp + 8)) = "special_variable_characters = %s\n";
        *((esp + 4)) = 1;
        *(esp) = ebx;
        fprintf_chk ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80502d0 */
#include <stdint.h>
 
int32_t dbg_var_is_const (int32_t arg_8h, int32_t arg_ch, long int v, double * dp) {
    ecx = v;
    edx = dp;
    /* int var_is_const(long int v,double * dp); */
    edx = *((ebp + 8));
    ecx = *((ebp + 0xc));
    if (edx != 1) {
        eax = 0;
        if (edx != 2) {
            goto label_0;
        }
    } else {
        if (ecx == 0) {
            goto label_1;
        }
        *(fp_stack--) = *(0x8075650);
        *(ecx) = fp_stack[0];
        fp_stack--;
        eax = 1;
        goto label_0;
    }
    if (ecx != 0) {
        *(fp_stack--) = *(0x8075658);
        *(ecx) = fp_stack[0];
        fp_stack--;
        eax = 1;
    } else {
label_1:
        eax = 1;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80516a1 */
#include <stdint.h>
 
int32_t dbg_quit_cmd (int32_t ev) {
    char * cp;
    int32_t var_4h;
    ebx = ev;
    /* int quit_cmd(char * cp); */
    eax = *((ebp + 8));
    ebx = 0;
    if (*(eax) != 0) {
        edx = ebp + 8;
        eax = decstrtol (eax, edx);
        ebx = eax;
        eax = *((ebp + 8));
        eax = extra_characters (eax);
        if (eax != 0) {
            goto label_0;
        }
    }
    exit_program (ebx);
label_0:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x807022b */
#include <stdint.h>
 
int32_t dbg_list_sub (int32_t arg_8h, int32_t n) {
    int32_t var_4h;
    ebx = n;
    /* int list_sub(int n); */
    ebx = *((ebp + 8));
    eax = 0;
    if (*((ebx*4 + obj.n_lhs)) > 0) {
        make_fractions_and_group (ebx);
        if (*(obj.factor_int_flag) != 0) {
            factor_int_sub (ebx);
        }
        if (*(obj.display2d) != 0) {
            flist_equation (ebx);
        } else {
            list1_sub (ebx, 0);
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80630f1 */
#include <stdint.h>
 
int32_t dbg_term_value (int32_t level, int32_t j, int32_t divide_flag, int32_t i) {
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t div_level;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    double * dp;
    token_type * p1;
    int32_t n1;
    int32_t loc;
    ebx = level;
    ecx = j;
    edi = divide_flag;
    eax = i;
    /* void term_value(double * dp,token_type * p1,int n1,int loc); */
    esi = *((ebp + 0x10));
    *(fp_stack--) = 0.0;
    eax = *((ebp + 8));
    *(eax) = fp_stack[0];
    eax += 8;
    *((ebp - 0x10)) = eax;
    *(eax) = fp_stack[0];
    ecx = *((ebp + 8));
    ecx += 0x10;
    *((ebp - 0x18)) = ecx;
    *(ecx) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x14));
    *((ebp - 0x20)) = 0;
    if (eax >= esi) {
        goto label_1;
    }
    eax <<= 4;
    ebx = *((ebp + 0xc));
    edx = ebx + eax + 4;
    eax = *((ebp + 0x14));
    edi = 0;
    do {
        ebx = *(edx);
        ecx = *((edx - 4));
        if (ecx == 1) {
            if (edi != 0) {
                *(fp_stack--) = 1.0;
                ecx = *((ebp + 8));
                *(ecx) -= fp_stack[0];
                *(ecx) = fp_stack[0];
                fp_stack--;
                *(fp_stack--) = *((edx + 4));
                ebx = *((ebp - 0x10));
                *(ebx) -= fp_stack[0];
                *(ebx) = fp_stack[0];
                fp_stack--;
                *(fp_stack--) = *((edx + 4));
                ecx = *((ebp - 0x18));
                *(ecx) -= fp_stack[0];
                *(ecx) = fp_stack[0];
                fp_stack--;
            } else {
                *(fp_stack--) = 1.0;
            }
            ebx = *((ebp + 8));
            fp_stack[0] += *(ebx);
            *(ebx) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = *((edx + 4));
            ecx = *((ebp - 0x10));
            fp_stack[0] += *(ecx);
            *(ecx) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = *((edx + 4));
            ebx = *((ebp - 0x18));
            fp_stack[0] += *(ebx);
            *(ebx) = fp_stack[0];
            fp_stack--;
        } else {
            if (ecx != 2) {
                goto label_2;
            }
            if (ebx == 1) {
                ecx = *((edx + 4));
                ecx--;
                if (ecx <= 1) {
                    goto label_1;
                }
            }
            if (*((edx + 4)) == 4) {
                if (edi != 0) {
                    if (ebx >= *((ebp - 0x20))) {
                        goto label_2;
                    }
                }
                *((ebp - 0x20)) = ebx;
                edi = 1;
            } else {
                if (edi == 0) {
                    goto label_2;
                }
                ecx = 0;
                if (ebx > *((ebp - 0x20))) {
                    edi = ecx;
                    goto label_2;
                }
            }
        }
label_2:
        eax++;
        edx += 0x10;
    } while (esi > eax);
label_1:
    edx = *((ebp + 0x14));
    edx++;
    if (eax <= edx) {
        goto label_3;
    }
    edx <<= 4;
    ebx = *((ebp + 0xc));
    edx = ebx + edx + 4;
    ecx = *((ebp + 0x14));
    ebx = *((ebp + 0x14));
    ebx <<= 4;
    edi = *((ebp + 0xc));
    esi = edi + ebx + 0x24;
    ebx = ecx;
    ebx <<= 4;
    ebx = edi + ebx + 4;
    *((ebp - 0x10)) = ebx;
    ebx = ecx;
    ebx <<= 4;
    ebx = ebx + edi - 0x10;
    *((ebp - 0x14)) = ebx;
    edi = 0;
    *(fp_stack--) = 1.0;
    *((ebp - 0x1c)) = eax;
label_0:
    eax = *(edx);
    *((ebp - 0x28)) = eax;
    eax = *((edx + 4));
    if (eax == 4) {
        if (edi != 0) {
            ebx = *((ebp - 0x20));
            if (*((ebp - 0x28)) >= ebx) {
                goto label_4;
            }
        }
        edi = *((ebp - 0x28));
        *((ebp - 0x20)) = edi;
        edi = 1;
        goto label_4;
    }
    if (edi != 0) {
        ebx = *((ebp - 0x20));
        ebx = 0;
        if (*((ebp - 0x28)) > ebx) {
            edi = ebx;
            goto label_5;
        }
    }
label_5:
    if (eax != 6) {
        goto label_4;
    }
    eax = *(esi);
    *((ebp - 0x24)) = eax;
    ebx = *((ebp - 0x28));
    if (eax != ebx) {
        goto label_4;
    }
    if (*((esi - 4)) != 0) {
        goto label_4;
    }
    *(fp_stack--) = 1.0;
    *((esi + 4)) -= fp_stack[0];
    *((ebp - 0x3c)) = ecx;
    if (*((ebp + 0x14)) > ecx) {
        goto label_6;
    }
    eax = *((ebp - 0x10));
    eax -= 4;
    *((ebp - 0x28)) = eax;
    eax = *((ebp - 0x24));
    ebx = *((ebp - 0x10));
    if (*(ebx) < eax) {
        goto label_6;
    }
    eax = *((ebp - 0x14));
    *(fp_stack--) = 0.0;
    *(fp_stack--) = fp_stack[0];
    *((ebp - 0x2c)) = edi;
    *((ebp - 0x30)) = esi;
    *((ebp - 0x34)) = ecx;
    *((ebp - 0x38)) = edx;
    ebx = ecx;
    edx = *((ebp - 0x28));
    edi = *((ebp - 0x24));
    esi = *((ebp + 0x14));
    do {
        if (*(edx) == 1) {
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            fp_stack[0] += fp_stack[3];
            *(fp_stack--) = *((edx + 8));
            fp_stack[0] += fp_stack[2];
            fp_stack++;
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
        }
        ebx--;
        if (esi > ebx) {
            goto label_7;
        }
        edx = eax;
        ecx = *((eax + 4));
        eax -= 0x10;
    } while (edi <= ecx);
    edi = *((ebp - 0x2c));
    esi = *((ebp - 0x30));
    ecx = *((ebp - 0x34));
    edx = *((ebp - 0x38));
    goto label_8;
label_6:
    *(fp_stack--) = 0.0;
    *(fp_stack--) = fp_stack[0];
    goto label_8;
label_7:
    edi = *((ebp - 0x2c));
    esi = *((ebp - 0x30));
    ecx = *((ebp - 0x34));
    edx = *((ebp - 0x38));
label_8:
    if (edi != 0) {
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        fp_stack[0] *= fp_stack[2];
        ebx = *((ebp + 8));
        *(ebx) -= fp_stack[0];
        *(ebx) = fp_stack[0];
        fp_stack--;
        fp_stack[0] *= fp_stack[1];
        fp_stack++;
        eax = *((ebp - 0x18));
        *(eax) -= fp_stack[0];
        *(eax) = fp_stack[0];
        fp_stack--;
    } else {
        fp_tmp_3 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_3;
        fp_stack[0] *= fp_stack[2];
        ebx = *((ebp + 8));
        fp_stack[0] += *(ebx);
        *(ebx) = fp_stack[0];
        fp_stack--;
        fp_stack[0] *= fp_stack[1];
        fp_stack++;
        eax = *((ebp - 0x18));
        fp_stack[0] += *(eax);
        *(eax) = fp_stack[0];
        fp_stack--;
    }
label_4:
    edx += 0x20;
    ecx += 2;
    esi += 0x20;
    *((ebp - 0x10)) += 0x20;
    *((ebp - 0x14)) += 0x20;
    eax = ecx + 1;
    if (*((ebp - 0x1c)) > eax) {
        goto label_0;
    }
    fp_stack++;
label_3:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805e1ee */
#include <stdint.h>
 
int32_t dbg_simpa_repeat_side (int32_t arg_8h, char * arg_ch, int32_t arg_14h, int * np, token_type * equation, int32_t frac_flag) {
    int32_t quick_flag;
    void * s2;
    size_t * n;
    int32_t var_ch;
    ebx = np;
    esi = equation;
    edi = frac_flag;
    /* void simpa_repeat_side(token_type * equation,int * np,int quick_flag,int frac_flag); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    edi = *((ebp + 0x14));
    *((esp + 0xc)) = edi;
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    simpa_side (esi, ebx);
    if (*(obj.repeat_flag) == 0) {
        goto label_0;
    }
    do {
        eax = *(ebx);
        *(obj.n_tes) = eax;
        eax <<= 4;
        eax = tes;
        memmove (eax, esi, eax);
        *((esp + 0xc)) = edi;
        eax = *((ebp + 0x10));
        *((esp + 8)) = eax;
        simpa_side (esi, ebx);
        edx = *(ebx);
        eax = n_tes;
    } while (edx < eax);
    if (eax != edx) {
        *(ebx) = eax;
        eax = n_tes;
        eax <<= 4;
        eax = tes;
        memmove (esi, eax, eax);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061bb6 */
#include <stdint.h>
 
uint32_t dbg_make_fractions_and_group (int32_t arg_8h, int32_t n, int32_t rv) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    ebx = n;
    esi = rv;
    /* int make_fractions_and_group(int n); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = 0;
    if (*((ebx*4 + obj.n_lhs)) > 0) {
        edi = ebx*4;
        eax = edi + obj_n_lhs;
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *(esp) = eax;
        eax = fractions_and_group ();
        esi = eax;
        if (*((ebx*4 + obj.n_rhs)) == 0) {
            goto label_0;
        }
        edi += obj.n_rhs;
        *((esp + 4)) = edi;
        eax = *((ebx*4 + obj.rhs));
        *(esp) = eax;
        eax = fractions_and_group ();
        eax = 1;
        if (eax == 0) {
            esi = eax;
            goto label_0;
        }
    }
label_0:
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a101 */
#include <stdint.h>
 
int32_t dbg_solved_equation (int32_t arg_8h, int32_t i) {
    int32_t var_4h;
    int32_t var_8h;
    eax = i;
    /* int solved_equation(int i); */
    eax = *((ebp + 8));
    edx = *((eax*4 + obj.n_rhs));
    if (edx > 0) {
        if (*((eax*4 + obj.n_lhs)) == 1) {
            ecx = *((eax*4 + obj.lhs));
            if (*(ecx) != 1) {
                goto label_0;
            }
            ecx = *((ecx + 8));
            ebx = *((ecx + 8));
            ebx &= 0x3fff;
            if (ebx <= 4) {
                goto label_0;
            }
            eax = *((eax*4 + obj.rhs));
            eax = found_var (eax, edx, ecx);
            al = (eax == 0) ? 1 : 0;
            eax = (int32_t) al;
        }
    } else {
label_0:
        eax = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a297 */
#include <stdint.h>
 
int32_t dbg_var_count (int32_t arg_8h, void * arg_ch, int32_t i, int32_t n1, int32_t count) {
    ecx = i;
    esi = n1;
    eax = count;
    /* int var_count(token_type * p1,int n1); */
    esi = *((ebp + 0xc));
    eax = 0;
    if (esi <= 0) {
        goto label_0;
    }
    ecx = *((ebp + 8));
    edx = 0;
    do {
        bl = (*(ecx) == 1) ? 1 : 0;
        ebx = (int32_t) bl;
        eax += ebx;
        edx += 2;
        ecx += 0x20;
    } while (esi > edx);
label_0:
    esi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8051b3f */
#include <stdint.h>
 
int32_t dbg_factor_cmd (int32_t arg_8h, int32_t power_flag, int32_t valid_range) {
    int32_t var_1048h;
    int32_t var_1044h;
    int32_t var_1040h;
    char * cp_start;
    double d;
    char * cp;
    long int v;
    int32_t j;
    int32_t i;
    char[4096] buf;
    int32_t var_1ch;
    char * endptr;
    char * var_8h;
    ebx = power_flag;
    eax = valid_range;
    /* int factor_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x102c)) = eax;
    edx = *(gs:0x14);
    *((ebp - 0x1c)) = edx;
    edx = 0;
    *((ebp - 0x103c)) = eax;
    *((esp + 4)) = "number";
    eax = strcmp_tospace (eax);
    if (eax == 0) {
        eax = *((ebp - 0x102c));
        eax = skip_param (eax);
        *((ebp - 0x102c)) = eax;
    } else {
        *((esp + 4)) = "numbers";
        eax = *((ebp - 0x102c));
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            *(obj.repeat_flag) = 1;
            eax = *((ebp - 0x102c));
            eax = skip_param (eax);
            *((ebp - 0x102c)) = eax;
        } else {
            *((esp + 4)) = 0x8075c80;
            eax = *((ebp - 0x102c));
            eax = strcmp_tospace (eax);
            ebx = 0;
            if (eax == 0) {
                eax = *((ebp - 0x102c));
                eax = skip_param (eax);
                *((ebp - 0x102c)) = eax;
                bl = 1;
            }
            eax = ebp - 0x1024;
            *((esp + 8)) = eax;
            eax = ebp - 0x1020;
            eax = ebp - 0x102c;
            eax = get_range (eax, eax);
            if (eax != 0) {
                goto label_7;
            }
            eax = *((ebp - 0x102c));
            ebx = *(eax);
            if (bl != 0x2d) {
                eax = ctype_b_loc ();
                ebx = (int32_t) bl;
                eax = *(eax);
                if ((*((eax + ebx*2 + 1)) & 8) == 0) {
                    goto label_8;
                }
            }
            *((esp + 4)) = "Factoring integers on command line instead:\n";
            *(esp) = 1;
            printf_chk ();
        }
    }
    edi = ebp - 0x102c;
label_2:
    eax = *((ebp - 0x102c));
    if (*(eax) != 0) {
        goto label_9;
    }
    do {
label_0:
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter integers to factor: ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        *((ebp - 0x103c)) = eax;
        *((ebp - 0x102c)) = eax;
        if (eax == 0) {
            goto label_8;
        }
        if (*(eax) != 0) {
            goto label_9;
        }
        goto label_10;
label_1:
        strtod (ebx, edi);
        *((ebp - 0x1038)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x102c));
        if (ebx != eax) {
            goto label_11;
        }
        *(esp) = "Integer expected.";
        eax = error ();
    } while (1);
label_11:
    eax = skip_space (eax);
    *((ebp - 0x102c)) = eax;
    esi = *(eax);
    edx = esi;
    if (dl == 0) {
        goto label_12;
    }
    eax = ctype_b_loc ();
    edx = esi;
    esi = (int32_t) dl;
    eax = *(eax);
    if ((*((eax + esi*2 + 1)) & 8) != 0) {
        goto label_12;
    }
    eax = ebx;
    eax += *(obj.input_column);
    eax -= *((ebp - 0x103c));
    *(obj.input_column) = eax;
    *((esp + 8)) = ebx;
    eax = tes;
    eax = parse_expr (eax, 0x80795f4);
    *((ebp - 0x102c)) = eax;
    if (eax == 0) {
        goto label_0;
    }
    if (*(obj.n_tes) <= 0) {
        goto label_10;
    }
    *((esp + 4)) = obj.n_tes;
    eax = tes;
    *(esp) = eax;
    calc_simp ();
    if (*(obj.n_tes) == 1) {
        eax = tes;
        if (*(eax) == 0) {
            goto label_13;
        }
    }
    *(esp) = "Integer expected.";
    error ();
    goto label_0;
label_13:
    *(fp_stack--) = *((eax + 8));
    *((ebp - 0x1038)) = fp_stack[0];
    fp_stack--;
label_12:
    eax = *((ebp - 0x102c));
    eax = skip_space (eax);
    *((ebp - 0x102c)) = eax;
    *(fp_stack--) = *((ebp - 0x1038));
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = factor_one ();
    if (eax == 0) {
        *(esp) = "Number too large to factor or not a non-zero integer.";
        error ();
        goto label_0;
    }
    display_unique ();
    eax = is_prime ();
    if (eax != 0) {
        *((esp + 8)) = "Prime number!\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
label_9:
    ebx = *((ebp - 0x102c));
    if (*(ebx) != 0) {
        goto label_1;
    }
    if (*(obj.repeat_flag) != 0) {
        goto label_2;
    }
    goto label_10;
label_5:
    eax = *((ebp - 0x102c));
    eax = extra_characters (eax);
    if (eax != 0) {
        goto label_8;
    }
    eax = *((ebp - 0x1020));
    *((ebp - 0x1038)) = eax;
    if (eax > *((ebp - 0x1024))) {
        goto label_10;
    }
    ebx = eax;
    ebx <<= 2;
    edx = ebx + obj_n_lhs;
    *((ebp - 0x103c)) = edx;
    eax = ebx + obj_n_rhs;
    *((ebp - 0x1048)) = eax;
    edi = ebx + obj_rhs;
    *((ebp - 0x1044)) = eax;
    ebx += obj.lhs;
    *((ebp - 0x1040)) = edx;
label_3:
    edx = *((ebp - 0x103c));
    if (*(edx) == 0) {
        goto label_14;
    }
    esi = *((ebp - 0x1040));
    *((esp + 4)) = esi;
    eax = *(ebx);
    *(esp) = eax;
    factor_power ();
    do {
        eax = *(ebx);
        simp_loop (eax, esi);
        *((esp + 4)) = esi;
        eax = *(ebx);
        *(esp) = eax;
        eax = factor_power ();
    } while (eax != 0);
    eax = *((ebp - 0x1048));
    if (*(eax) == 0) {
        goto label_15;
    }
    esi = *((ebp - 0x1044));
    *((esp + 4)) = esi;
    eax = *(edi);
    *(esp) = eax;
    factor_power ();
    do {
        eax = *(edi);
        simp_loop (eax, esi);
        *((esp + 4)) = esi;
        eax = *(edi);
        *(esp) = eax;
        eax = factor_power ();
    } while (eax != 0);
label_15:
    edx = *((ebp - 0x1038));
    eax = return_result (edx);
    if (eax == 0) {
        goto label_8;
    }
label_14:
    *((ebp - 0x1038))++;
    *((ebp - 0x103c)) += 4;
    *((ebp - 0x1048)) += 4;
    edi += 4;
    *((ebp - 0x1044)) += 4;
    ebx += 4;
    *((ebp - 0x1040)) += 4;
    eax = *((ebp - 0x1038));
    if (*((ebp - 0x1024)) >= eax) {
        goto label_3;
    }
    goto label_10;
label_4:
    *((ebp - 0x1028)) = 0;
    eax = *((ebp - 0x102c));
    if (*(eax) == 0) {
        goto label_6;
    }
    edx = ebp - 0x1028;
    eax = parse_var2 (edx, eax);
    *((ebp - 0x102c)) = eax;
    if (eax == 0) {
        goto label_8;
    }
    if (*((ebp - 0x1028)) == 0) {
        goto label_6;
    }
    ebx = *((ebp - 0x1020));
    if (*((ebp - 0x1024)) < ebx) {
        goto label_16;
    }
    do {
        eax = *((ebp - 0x1028));
        eax = var_in_equation (ebx, eax);
        if (eax != 0) {
            goto label_6;
        }
        ebx++;
    } while (*((ebp - 0x1024)) >= ebx);
    goto label_16;
label_6:
    ebx = *((ebp - 0x1020));
    if (*((ebp - 0x1024)) < ebx) {
        goto label_17;
    }
    eax = ebx*4;
    esi = eax + obj_n_lhs;
    edi = eax + obj_lhs;
    *((ebp - 0x103c)) = esi;
    edx = eax + obj_n_rhs;
    *((ebp - 0x1038)) = edx;
    eax += obj.rhs;
    *((ebp - 0x1044)) = eax;
    *((ebp - 0x1040)) = edx;
    do {
        if (*(esi) != 0) {
            eax = *((ebp - 0x1028));
            *((esp + 8)) = eax;
            eax = *((ebp - 0x103c));
            eax = *(edi);
            simpv_side (eax, eax);
            edx = *((ebp - 0x1038));
            if (*(edx) == 0) {
                goto label_18;
            }
            eax = *((ebp - 0x1028));
            *((esp + 8)) = eax;
            eax = *((ebp - 0x1040));
            edx = *((ebp - 0x1044));
            eax = *(edx);
            simpv_side (eax, eax);
        }
label_18:
        ebx++;
        esi += 4;
        edi += 4;
        *((ebp - 0x103c)) += 4;
        *((ebp - 0x1038)) += 4;
        *((ebp - 0x1044)) += 4;
        *((ebp - 0x1040)) += 4;
    } while (*((ebp - 0x1024)) >= ebx);
label_17:
    eax = *((ebp - 0x102c));
    if (*(eax) != 0) {
        goto label_4;
    }
    ebx = *((ebp - 0x1020));
    if (*((ebp - 0x1024)) < ebx) {
        goto label_10;
    }
    esi = ebx*4 + obj_n_lhs;
    do {
        if (*(esi) != 0) {
            eax = return_result (ebx);
            if (eax == 0) {
                goto label_8;
            }
        }
        ebx++;
        esi += 4;
    } while (*((ebp - 0x1024)) >= ebx);
    goto label_10;
label_8:
    eax = 0;
    goto label_19;
label_10:
    eax = 1;
label_19:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*((ebp - 0x1024)) == ebx) {
        goto label_20;
    }
    goto label_21;
label_7:
    if (ebx == 0) {
        goto label_4;
    }
    goto label_5;
label_16:
    warning ("Variable not found.");
    goto label_6;
label_21:
    stack_chk_fail ();
label_20:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806db71 */
#include <stdint.h>
 
int32_t dbg_int_expr (char * arg_ch, int32_t i, int32_t n) {
    token_type * p1;
    esi = i;
    edi = n;
    /* int int_expr(token_type * p1,int n); */
    edi = *((ebp + 0xc));
    if (edi <= 0) {
        goto label_1;
    }
    ebx = *((ebp + 8));
    esi = 0;
label_0:
    eax = *(ebx);
    if (eax != 0) {
        if (eax != 1) {
            goto label_2;
        }
        goto label_3;
    }
    *(fp_stack--) = *((ebx + 8));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (eax == 1);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_4;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_5;
label_4:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_5:
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_6;
    }
    if (fp_stack[0] != fp_stack[1]) {
        goto label_6;
label_3:
        if (*((ebx + 8)) <= 2) {
            goto label_6;
        }
    }
label_2:
    esi++;
    ebx += 0x10;
    if (edi > esi) {
        goto label_0;
    }
    goto label_1;
label_6:
    eax = 0;
    goto label_7;
label_1:
    eax = 1;
label_7:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806c8f0 */
#include <stdint.h>
 
int32_t dbg_get_constant (char * arg_ch, int32_t level, int32_t i, int32_t n) {
    int32_t prev_approx_flag;
    int32_t var_2ch;
    double d2;
    double d1;
    token_type * p1;
    double * dp;
    int32_t var_4h;
    int32_t var_8h;
    ebx = level;
    edx = i;
    esi = n;
    do {
        /* int get_constant(token_type * p1,int n,double * dp); */
label_0:
        esi = *((ebp + 0xc));
        if (esi > 0) {
            if ((esi & 1) != 0) {
                goto label_3;
            }
        }
        error_bug ("Call to get_constant() has invalid expression length.");
label_3:
        if (esi == 1) {
            edx = *((ebp + 8));
            eax = *(edx);
            if (eax != 0) {
                if (eax != 1) {
                    goto label_4;
                }
            } else {
                eax = *((ebp + 8));
                *(fp_stack--) = *((eax + 8));
                edx = *((ebp + 0x10));
                *(edx) = fp_stack[0];
                fp_stack--;
                eax = 1;
                goto label_5;
            }
            eax = *((ebp + 0x10));
            edx = *((ebp + 8));
            eax = *((edx + 8));
            eax = var_is_const (eax, eax);
            al = (eax != 0) ? 1 : 0;
            eax = (int32_t) al;
            goto label_5;
        }
        if (esi <= 2) {
            goto label_4;
        }
        eax = *((ebp + 8));
        eax += 0x10;
        *((ebp - 0x2c)) = eax;
        ebx = *((eax + 4));
        eax = ebp - 0x20;
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        edx = *((ebp + 8));
        eax = get_constant (edx);
    } while (1);
    if (eax == 0) {
        goto label_4;
    }
    if (esi > 1) {
        goto label_6;
    }
    goto label_7;
label_1:
    *((ebp - 0x30)) = ebx;
    eax = ebx;
    eax <<= 4;
    eax += *((ebp + 8));
    *((ebp - 0x2c)) = eax;
    if (*(eax) != 2) {
        goto label_4;
    }
    eax = *((eax + 4));
    if (eax > edi) {
        goto label_4;
    }
    edi = eax;
    ecx = ebx;
label_2:
    ebx = ecx + 2;
    if (esi <= ebx) {
        goto label_8;
    }
    eax = ebx;
    eax <<= 4;
    edx = *((ebp + 8));
    if (edi >= *((eax + edx + 4))) {
        goto label_8;
    }
    eax = ecx;
    eax <<= 4;
    eax = edx + eax + 0x44;
    do {
        ebx += 2;
        if (esi <= ebx) {
            goto label_8;
        }
        edx = *(eax);
        eax += 0x20;
    } while (edx > edi);
label_8:
    eax = ebp - 0x28;
    *((esp + 8)) = eax;
    ecx = ~ecx;
    ecx = ebx + ecx;
    *((esp + 4)) = ecx;
    eax = *((ebp - 0x30));
    eax <<= 4;
    edx = *((ebp + 8));
    eax = eax + edx + 0x10;
    eax = get_constant (eax);
    goto label_0;
    if (eax == 0) {
        goto label_4;
    }
    eax = approximate_roots;
    *((ebp - 0x30)) = eax;
    *(obj.approximate_roots) = 1;
    *(fp_stack--) = *((ebp - 0x28));
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    edx = *((ebp - 0x2c));
    eax = *((edx + 8));
    *((esp + 8)) = eax;
    eax = ebp - 0x20;
    eax = calc (0, eax);
    if (eax == 0) {
        goto label_9;
    }
    edx = *((ebp - 0x30));
    *(obj.approximate_roots) = edx;
    eax = *((ebp - 0x2c));
    if (*((eax + 8)) == 6) {
        if (*(obj.domain_check) == 0) {
            goto label_4;
        }
    }
    *(obj.domain_check) = 0;
    if (esi > ebx) {
        goto label_1;
    }
    goto label_7;
label_9:
    edx = *((ebp - 0x30));
    *(obj.approximate_roots) = edx;
    eax = 0;
    goto label_5;
label_6:
    eax = *((ebp - 0x2c));
    if (*(eax) == 2) {
        edi = *((eax + 4));
        if (ebx >= edi) {
            *((ebp - 0x30)) = 1;
            ecx = 1;
            goto label_2;
label_7:
            *(fp_stack--) = *((ebp - 0x20));
            edx = *((ebp + 0x10));
            *(edx) = fp_stack[0];
            fp_stack--;
            eax = 1;
        }
    } else {
label_4:
        eax = 0;
    }
label_5:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805454a */
#include <stdint.h>
 
uint32_t dbg_compare_cmd (int32_t i, int32_t j) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t symb;
    int32_t diff_sign;
    char * cp;
    char * s2;
    size_t n;
    char * var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = i;
    esi = j;
    /* int compare_cmd(char * cp); */
    ebx = *((ebp + 8));
    eax = strncasecmp (ebx, "symbolic", 3);
    *((ebp - 0x2c)) = 0;
    if (eax == 0) {
        eax = skip_param (ebx);
        *((ebp + 8)) = eax;
        *((ebp - 0x2c)) = 1;
    }
    *((esp + 4)) = "with";
    eax = *((ebp + 8));
    eax = strcmp_tospace (eax);
    if (eax == 0) {
        eax = *((ebp + 8));
        eax = skip_param (eax);
        *((ebp + 8)) = eax;
    }
    eax = ebp + 8;
    eax = *((ebp + 8));
    eax = decstrtol (eax, eax);
    edi = eax;
    ebx = eax - 1;
    eax = not_defined (ebx);
    if (eax == 0) {
        *((esp + 4)) = "with";
        eax = *((ebp + 8));
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            eax = *((ebp + 8));
            eax = skip_param (eax);
            *((ebp + 8)) = eax;
        }
        eax = *((ebp + 8));
        *(esp) = eax;
        eax = get_default_en ();
        esi = eax;
        if (eax < 0) {
            goto label_0;
        }
        if (ebx == eax) {
            *(esp) = "Cannot compare an equation with itself.";
            error ();
            eax = 0;
            goto label_1;
        }
        eax = eax + 1;
        *((esp + 0x10)) = eax;
        *((esp + 0xc)) = edi;
        *((esp + 8)) = "Comparing #%d with #%d...\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        if (*((ebx*4 + obj.n_rhs)) != 0) {
            if (*((esi*4 + obj.n_rhs)) != 0) {
            } else {
                if (*((esi*4 + obj.n_rhs)) != 0) {
                    goto label_2;
                }
                edx = ebx*4 + obj_n_lhs;
                *((ebp - 0x34)) = edx;
                edi = lhs;
                eax = *((edi + ebx*4));
                simp_loop (eax, edx);
                eax = esi*4 + obj_n_lhs;
                *((ebp - 0x30)) = eax;
                eax = *((edi + esi*4));
                simp_loop (eax, eax);
                eax = compare_es (ebx, esi);
                if (eax != 0) {
                    *((esp + 8)) = "Expressions are identical.\n";
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                    eax = 1;
                    goto label_1;
                }
                if (*(obj.debug_level) >= 0) {
                    *((esp + 0xc)) = "Simplifying both expressions...";
                    *((esp + 8)) = 0x807277d;
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                }
                edx = *((ebp - 0x2c));
                *(obj.symb_flag) = edx;
                *((esp + 0xc)) = 1;
                *((esp + 8)) = 0;
                eax = *((ebp - 0x34));
                edi = lhs;
                eax = *((edi + ebx*4));
                simpa_side (eax, eax);
                *((esp + 0xc)) = 1;
                *((esp + 8)) = 0;
                edx = *((ebp - 0x30));
                eax = *((edi + esi*4));
                simpa_side (eax, edx);
                *(obj.symb_flag) = 0;
                if (*(obj.debug_level) >= 0) {
                    list_sub (ebx);
                    list_sub (esi);
                }
                eax = compare_es (ebx, esi);
                if (eax != 0) {
                    *((esp + 8)) = "Expressions are identical.\n";
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                    eax = 1;
                    goto label_1;
                }
                eax = *((ebp - 0x34));
                *((esp + 4)) = eax;
                edi = lhs;
                eax = *((edi + ebx*4));
                *(esp) = eax;
                uf_simp ();
                edx = *((ebp - 0x30));
                *((esp + 4)) = edx;
                eax = *((edi + esi*4));
                *(esp) = eax;
                uf_simp ();
                eax = compare_es (ebx, esi);
                if (eax != 0) {
                    *((esp + 8)) = "Expressions are identical.\n";
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                    eax = 1;
                    goto label_1;
                }
                *((esp + 8)) = "Expressions differ.\n";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
                eax = 0;
                goto label_1;
            }
label_2:
            *(esp) = "Cannot compare an equation with a non-equation.";
            error ();
            eax = 0;
            goto label_1;
        }
        eax = compare_es (ebx, esi);
        if (eax != 0) {
            *((esp + 8)) = "Equations are identical.\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = 1;
            goto label_1;
        }
        eax = solved_equation (ebx);
        if (eax != 0) {
            eax = solved_equation (esi);
            if (eax == 0) {
                goto label_3;
            }
            eax = ebx*4 + obj_n_rhs;
            *((ebp - 0x34)) = eax;
            edi = rhs;
            eax = *((edi + ebx*4));
            simp_loop (eax, eax);
            edx = esi*4 + obj_n_rhs;
            *((ebp - 0x30)) = edx;
            eax = *((edi + esi*4));
            simp_loop (eax, edx);
            ecx = ebp - 0x1c;
            edx = esi;
            eax = ebx;
            eax = compare_rhs ();
            if (eax != 0) {
                goto label_4;
            }
            if (*(obj.debug_level) >= 0) {
                *((esp + 0xc)) = "Simplifying both equations...";
                *((esp + 8)) = 0x807277d;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                fprintf_chk ();
            }
            eax = *((ebp - 0x2c));
            *(obj.symb_flag) = eax;
            *((esp + 0xc)) = 1;
            *((esp + 8)) = 0;
            edx = *((ebp - 0x34));
            edi = rhs;
            eax = *((edi + ebx*4));
            simpa_side (eax, edx);
            *((esp + 0xc)) = 1;
            *((esp + 8)) = 0;
            eax = *((ebp - 0x30));
            eax = *((edi + esi*4));
            simpa_side (eax, eax);
            *(obj.symb_flag) = 0;
            if (*(obj.debug_level) >= 0) {
                list_sub (ebx);
                list_sub (esi);
            }
            ecx = ebp - 0x1c;
            edx = esi;
            eax = ebx;
            eax = compare_rhs ();
            if (eax != 0) {
                goto label_4;
            }
            edx = *((ebp - 0x34));
            *((esp + 4)) = edx;
            edi = rhs;
            eax = *((edi + ebx*4));
            *(esp) = eax;
            uf_simp ();
            eax = *((ebp - 0x30));
            *((esp + 4)) = eax;
            eax = *((edi + esi*4));
            *(esp) = eax;
            uf_simp ();
            ecx = ebp - 0x1c;
            edx = esi;
            eax = ebx;
            eax = compare_rhs ();
            if (eax != 0) {
                goto label_4;
            }
        }
label_3:
        if (*(obj.debug_level) >= 0) {
            *((esp + 0xc)) = "Solving both equations for zero and unfactoring...";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        eax = ebx*4;
        edi = eax + obj_n_rhs;
        eax += obj.n_lhs;
        *((ebp - 0x30)) = eax;
        *((esp + 0x14)) = edi;
        eax = *((ebx*4 + obj.rhs));
        *((esp + 0x10)) = eax;
        edx = *((ebp - 0x30));
        *((esp + 0xc)) = edx;
        eax = *((ebx*4 + obj.lhs));
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        *(esp) = obj.zero_token;
        eax = solve_sub ();
        if (eax <= 0) {
            goto label_0;
        }
        eax = esi*4;
        edx = eax + obj_n_rhs;
        *((ebp - 0x34)) = edx;
        eax += obj.n_lhs;
        *((ebp - 0x38)) = eax;
        *((esp + 0x14)) = edx;
        eax = *((esi*4 + obj.rhs));
        *((esp + 0x10)) = eax;
        eax = *((ebp - 0x38));
        *((esp + 0xc)) = eax;
        eax = *((esi*4 + obj.lhs));
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        *(esp) = obj.zero_token;
        eax = solve_sub ();
        if (eax <= 0) {
            goto label_0;
        }
        *((esp + 4)) = edi;
        eax = *((ebx*4 + obj.rhs));
        *(esp) = eax;
        uf_simp ();
        edx = *((ebp - 0x34));
        *((esp + 4)) = edx;
        eax = *((esi*4 + obj.rhs));
        *(esp) = eax;
        uf_simp ();
        ecx = ebp - 0x1c;
        edx = esi;
        eax = ebx;
        eax = compare_rhs ();
        if (eax != 0) {
            *((esp + 8)) = "Equations are identical.\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = 1;
            goto label_1;
        }
        if (*(obj.debug_level) >= 0) {
            *((esp + 0xc)) = "Simplifying both equations...";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        eax = *((ebp - 0x2c));
        *(obj.symb_flag) = eax;
        *((esp + 0xc)) = 0;
        *((esp + 8)) = 0;
        eax = *((ebx*4 + obj.rhs));
        simpa_side (eax, edi);
        *((esp + 0xc)) = 0;
        *((esp + 8)) = 0;
        edx = *((ebp - 0x34));
        eax = *((esi*4 + obj.rhs));
        simpa_side (eax, edx);
        *(obj.symb_flag) = 0;
        ecx = ebp - 0x1c;
        edx = esi;
        eax = ebx;
        eax = compare_rhs ();
        if (eax != 0) {
            *((esp + 8)) = "Equations are identical.\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = 1;
            goto label_1;
        }
        *((esp + 0x14)) = edi;
        eax = *((ebx*4 + obj.rhs));
        *((esp + 0x10)) = eax;
        eax = *((ebp - 0x30));
        *((esp + 0xc)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        *(esp) = obj.zero_token;
        eax = solve_sub ();
        if (eax <= 0) {
            goto label_0;
        }
        edx = *((ebp - 0x34));
        *((esp + 0x14)) = edx;
        eax = *((esi*4 + obj.rhs));
        *((esp + 0x10)) = eax;
        eax = *((ebp - 0x38));
        *((esp + 0xc)) = eax;
        eax = *((esi*4 + obj.lhs));
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        *(esp) = obj.zero_token;
        eax = solve_sub ();
        if (eax <= 0) {
            goto label_0;
        }
        *((esp + 4)) = edi;
        edi = rhs;
        eax = *((edi + ebx*4));
        *(esp) = eax;
        uf_simp ();
        edx = *((ebp - 0x34));
        *((esp + 4)) = edx;
        eax = *((edi + esi*4));
        *(esp) = eax;
        uf_simp ();
        ecx = ebp - 0x1c;
        edx = esi;
        eax = ebx;
        eax = compare_rhs ();
        if (eax != 0) {
            *((esp + 8)) = "Equations are identical.\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = 1;
            goto label_1;
        }
        *((esp + 8)) = "Equations differ.\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 0;
        goto label_1;
label_4:
        if (*((ebp - 0x1c)) == 0) {
            eax = lhs;
            edx = *((eax + ebx*4));
            eax = *((eax + esi*4));
            edx = *((edx + 8));
            if (edx != *((eax + 8))) {
                goto label_5;
            }
            *((esp + 8)) = "Equations are identical.\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            eax = 1;
            goto label_1;
        }
label_5:
        *((esp + 8)) = "Variable (";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 8)) = 0;
        eax = *((ebx*4 + obj.n_lhs));
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *(esp) = eax;
        list_proc ();
        *((esp + 8)) = ") in the first equation is equal to (";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        if (*((ebp - 0x1c)) != 0) {
            *((esp + 8)) = 0x807295b;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        *((esp + 8)) = 0;
        eax = *((esi*4 + obj.n_lhs));
        *((esp + 4)) = eax;
        eax = *((esi*4 + obj.lhs));
        *(esp) = eax;
        list_proc ();
        *((esp + 8)) = ") in the second equation.\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 2;
        if (*((ebp - 0x1c)) == 0) {
            goto label_1;
        }
    }
label_0:
    eax = 0;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061e10 */
#include <stdint.h>
 
int32_t dbg_uf_neg_help (int32_t i) {
    int32_t var_20h;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    ebx = i;
    /* void uf_neg_help(token_type * equation,int * np); */
    edx = *((ebp + 0xc));
    eax = *(edx);
    edx = eax - 1;
    if (edx <= 0) {
        goto label_0;
    }
    ebx = 0;
    do {
        edi = 0;
        esi = ebx;
        esi <<= 4;
        esi += *((ebp + 8));
        if (*(esi) == 0) {
            *(fp_stack--) = *((esi + 8));
            *(fp_stack--) = 0.0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] <= fp_stack[1]) {
                goto label_1;
            }
            edx = ebx;
            edx <<= 4;
            ecx = *((ebp + 8));
            edx = edx + ecx + 0x10;
            *((ebp - 0x1c)) = edx;
            edx = *((edx + 4));
            *((ebp - 0x20)) = edx;
            if (edx != *((esi + 4))) {
                goto label_1;
            }
            ecx = *((ebp - 0x1c));
            edx = *((ecx + 8));
            edx -= 3;
            if (edx > 1) {
                goto label_1;
            }
            eax += 2;
            if (eax > *(obj.n_tokens)) {
                error_huge ();
            }
            eax = ebx;
            eax = ~eax;
            edx = *((ebp + 0xc));
            eax += *(edx);
            eax <<= 4;
            ecx = *((ebp - 0x1c));
            edi <<= 4;
            edx = *((ebp + 8));
            eax = edi + edx + 0x30;
            memmove (eax, ecx, eax);
            ecx = *((ebp + 0xc));
            *(ecx) += 2;
            *(fp_stack--) = *((esi + 8));
            fp_stack[0] = -fp_stack[0];
            *((esi + 8)) = fp_stack[0];
            fp_stack--;
            eax = ebx;
            eax <<= 4;
            edx = *((ebp + 8));
            eax = eax + edx + 0x10;
            ecx = *((ebp - 0x20));
            *((eax + 4)) = ecx;
            *(eax) = 2;
            *((eax + 8)) = 4;
            ebx += 2;
            eax = ebx;
            eax <<= 4;
            eax += edx;
            *((eax + 4)) = ecx;
            *(eax) = 0;
            *(fp_stack--) = 1.0;
            fp_stack[0] = -fp_stack[0];
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
        }
label_1:
        ebx += 2;
        edx = *((ebp + 0xc));
        eax = *(edx);
        edx = eax - 1;
    } while (edx > ebx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805572d */
#include <stdint.h>
 
int32_t dbg_pause_cmd (int32_t arg_8h, char * cp1) {
    char[4096] buf;
    int32_t canary;
    char * s2;
    size_t n;
    int32_t var_sp_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = cp1;
    /* int pause_cmd(char * cp); */
    ebx = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    if (*(obj.test_mode) == 0) {
        eax = isatty (0);
        if (eax != 0) {
            eax = "Please press the Enter key";
            if (*(ebx) == 0) {
                ebx = eax;
            }
            *((esp + 0x14)) = ebx;
            *((esp + 0x10)) = " ==== %s ==== ";
            *((esp + 0xc)) = 0x50;
            *((esp + 8)) = 1;
            *((esp + 4)) = 0x50;
            *(esp) = obj.prompt_str;
            snprintf_chk ();
            eax = ebp - 0x100c;
            eax = get_string (eax, 0x1000);
            ebx = eax;
            if (eax == 0) {
                goto label_0;
            }
            eax = strncasecmp (eax, "quit", 4);
            if (eax == 0) {
                goto label_0;
            }
            eax = strncasecmp (ebx, "exit", 4);
            al = (eax != 0) ? 1 : 0;
            eax = (int32_t) al;
        }
    } else {
        eax = 1;
        goto label_1;
label_0:
        eax = 0;
    }
label_1:
    edx = *((ebp - 0xc));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a42b */
#include <stdint.h>
 
uint32_t dbg_isdelimiter (int32_t arg_8h, int32_t ch) {
    ebx = ch;
    /* int isdelimiter(int ch); */
    ebx = *((ebp + 8));
    eax = ctype_b_loc ();
    eax = *(eax);
    if ((*((eax + ebx*2 + 1)) & 0x20) == 0) {
        if (ebx != 0x2c) {
            goto label_0;
        }
    }
    eax = 1;
    goto label_1;
label_0:
    al = (ebx == 0x3d) ? 1 : 0;
    eax = (int32_t) al;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806436b */
#include <stdint.h>
 
int32_t dbg_is_integer_var (int32_t arg_8h, int (*)() strncmpfunc, char * cp) {
    char * var_4h;
    int32_t var_8h;
    ebx = strncmpfunc;
    ecx = cp;
    /* int is_integer_var(long int v); */
    eax = imp.strncmp;
    ebx = imp.strncasecmp;
    if (*(obj.case_sensitive_flag) != 0) {
        ebx = eax;
    }
    eax = *((ebp + 8));
    eax = var_name (eax);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        eax = void (*ebx)(uint32_t, char*, uint32_t) (edx, "integer", 7);
        al = (eax == 0) ? 1 : 0;
        eax = (int32_t) al;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806db10 */
#include <stdint.h>
 
int32_t dbg_var_name (int32_t arg_8h, long int l, char * cp) {
    ecx = l;
    eax = cp;
    /* char * var_name(long int v); */
    edx = *((ebp + 8));
    edx &= 0x3fff;
    edx -= 0x41;
    eax = 0;
    if (edx <= 0x1f3f) {
        eax = *((edx*4 + obj.var_names));
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fdb5 */
#include <stdint.h>
 
int32_t dbg_flist_equation (int32_t arg_8h, int32_t pos, int32_t n, int32_t len2, int32_t len3) {
    int32_t var_70h;
    int32_t width;
    int32_t min2_line;
    int32_t max2_line;
    int32_t min_line;
    int32_t max_line;
    int32_t low;
    int32_t high;
    char[50] buf;
    int32_t canary;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = pos;
    esi = n;
    edi = len2;
    eax = len3;
    /* int flist_equation(int n); */
    esi = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    *((ebp - 0x54)) = 0;
    *((ebp - 0x58)) = 0;
    *((ebp - 0x6c)) = 0;
    if (*((esi*4 + obj.n_lhs)) <= 0) {
        goto label_2;
    }
    *((ebp - 0x68)) = 0;
    *((ebp - 0x64)) = 0;
    *((ebp - 0x60)) = 0;
    *((ebp - 0x5c)) = 0;
    eax = esi + 1;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = "#%d: ";
    *((esp + 0xc)) = 0x32;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x32;
    eax = ebp - 0x4e;
    *(esp) = eax;
    eax = snprintf_chk ();
    edi = eax;
    *(obj.cur_line) = 0;
    *(obj.cur_pos) = 0;
    ebx = *((esi*4 + obj.n_rhs));
    edx = *((esi*4 + obj.n_lhs));
    eax = ebp - 0x60;
    eax = ebp - 0x5c;
    ecx = 0;
    eax = *((esi*4 + obj.lhs));
    flist_sub (0, eax, eax);
    eax = edi + eax;
    *((ebp - 0x6c)) = eax;
    eax = 0;
    edi = 0;
    if (*((esi*4 + obj.n_rhs)) == 0) {
        goto label_3;
    }
    *((ebp - 0x6c)) += 3;
    do {
label_0:
        eax = *((esi*4 + obj.rhs));
        edx = ebp - 0x58;
        ecx = ebp - 0x54;
        ecx = 0;
        edx = ebx;
        flist_sub (0, ecx, edx);
        edx = screen_columns;
        if (edx == 0) {
            goto label_4;
        }
        edx = gfp;
        if (edx != *(obj.stdout)) {
            goto label_4;
        }
        edx = screen_columns;
        ecx = *((ebp - 0x6c));
        ecx = eax + ecx;
        if (ecx < edx) {
            goto label_4;
        }
        if (ebx <= 0) {
            goto label_4;
        }
        ebx--;
    } while (ebx <= 0);
    eax = ebx;
    eax <<= 4;
    eax += *((esi*4 + obj.rhs));
    eax += 4;
    edx = 1;
label_1:
    if (*(eax) != 1) {
        goto label_5;
    }
    if (*((eax - 4)) != 2) {
        goto label_5;
    }
    if (*((eax + 4)) > 5) {
        goto label_5;
    }
    edi = edx;
    ecx = *((eax + 4));
    edi <<= cl;
    if ((edi & 0x26) != 0) {
        goto label_0;
    }
label_5:
    ebx--;
    eax -= 0x10;
    if (ebx > 0) {
        goto label_1;
    }
    goto label_0;
label_4:
    edi = eax;
    eax = ebx;
    edx = *((ebp - 0x54));
    if (edx > *((ebp - 0x5c))) {
        *((ebp - 0x5c)) = edx;
    }
    edx = *((ebp - 0x58));
    if (edx < *((ebp - 0x60))) {
        *((ebp - 0x60)) = edx;
    }
    edx = *((esi*4 + obj.n_rhs));
    edx -= eax;
    eax <<= 4;
    eax += *((esi*4 + obj.rhs));
    ecx = ebp - 0x68;
    ecx = ebp - 0x64;
    ecx = 0;
    eax = flist_sub (0, ecx, ecx);
label_3:
    edi += *((ebp - 0x6c));
    if (edi >= eax) {
        eax = edi;
    }
    *((ebp - 0x6c)) = eax;
    eax = screen_columns;
    if (eax != 0) {
        eax = gfp;
        if (eax != *(obj.stdout)) {
            goto label_6;
        }
        eax = screen_columns;
        if (*((ebp - 0x6c)) < eax) {
            goto label_6;
        }
        eax = list1_sub (esi, 0);
        *((ebp - 0x6c)) = eax;
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        goto label_2;
    }
label_6:
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = *((ebp - 0x5c));
    *(obj.cur_line) = eax;
    if (*((ebp - 0x60)) > eax) {
        goto label_7;
    }
    *((ebp - 0x70)) = ebx;
    do {
        *(obj.cur_pos) = 0;
        if (*(obj.cur_line) == 0) {
            eax = ebp - 0x4e;
            *((esp + 0xc)) = eax;
            *((esp + 8)) = 0x8075e74;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            *(obj.cur_pos) += eax;
        }
        edi = ebp - 0x4e;
        ecx = 0xffffffff;
        eax = 0;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        ebx = ecx - 1;
        edx = *((esi*4 + obj.n_lhs));
        eax = *((esi*4 + obj.lhs));
        ecx = ebp - 0x58;
        edi = ebp - 0x54;
        ecx = 1;
        eax = flist_sub (ebx, edi, ecx);
        edi = eax;
        if (*((esi*4 + obj.n_rhs)) != 0) {
            if (*(obj.cur_line) == 0) {
                *((esp + 0xc)) = 0x80759cf;
                *((esp + 8)) = 0x8075e74;
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                eax = fprintf_chk ();
                *(obj.cur_pos) += eax;
            }
            edx = ebx + edi + 3;
            eax = *((esi*4 + obj.rhs));
            ecx = ebp - 0x58;
            edi = ebp - 0x54;
            ecx = 1;
            edx = *((ebp - 0x70));
            flist_sub (edx, edi, ecx);
        }
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = cur_line;
        eax--;
        *(obj.cur_line) = eax;
    } while (*((ebp - 0x60)) <= eax);
    ebx = *((ebp - 0x70));
label_7:
    if (ebx >= *((esi*4 + obj.n_rhs))) {
        goto label_8;
    }
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = *((ebp - 0x64));
    *(obj.cur_line) = eax;
    if (*((ebp - 0x68)) > eax) {
        goto label_8;
    }
    eax = ebx;
    eax <<= 4;
    *((ebp - 0x70)) = eax;
    edi = ebp - 0x58;
    do {
        *(obj.cur_pos) = 0;
        edx = *((esi*4 + obj.n_rhs));
        edx -= ebx;
        eax = *((ebp - 0x70));
        eax += *((esi*4 + obj.rhs));
        ecx = ebp - 0x54;
        ecx = 1;
        flist_sub (0, ecx, edi);
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = cur_line;
        eax--;
        *(obj.cur_line) = eax;
    } while (*((ebp - 0x68)) <= eax);
label_8:
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
label_2:
    eax = *((ebp - 0x6c));
    edi = *((ebp - 0x1c));
    edi ^= *(gs:0x14);
    if (*((ebp - 0x68)) != eax) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8071777 */
#include <stdint.h>
 
int32_t dbg_list_factor (int32_t arg_8h, char * arg_ch, int * np, token_type * equation) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t factor_flag;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    ebx = np;
    esi = equation;
    /* int list_factor(token_type * equation,int * np,int factor_flag); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    if (*((ebp + 0x10)) == 0) {
        if (*(obj.factor_int_flag) == 0) {
            goto label_0;
        }
    }
    *((esp + 4)) = ebx;
    *(esp) = esi;
    factor_int ();
label_0:
    *((esp + 8)) = 0;
    eax = *(ebx);
    *((esp + 4)) = eax;
    *(esp) = esi;
    list_proc ();
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8053371 */
#include <stdint.h>
 
int32_t dbg_code_cmd (int32_t int_flag, char * cp1, language_list language) {
    int32_t var_30h;
    int32_t displayed;
    int32_t j;
    int32_t i;
    char * cp;
    char * var_4h;
    int32_t var_8h;
    ebx = int_flag;
    esi = cp1;
    edi = language;
    /* int code_cmd(char * cp); */
    ebx = 0;
    esi = 1;
    edi = 1;
    do {
        *((esp + 4)) = 0x8075a34;
        eax = *((ebp + 8));
        eax = strcmp_tospace (eax);
        if (eax != 0) {
            *((esp + 4)) = 0x80758b4;
            eax = *((ebp + 8));
            eax = strcmp_tospace (eax);
            if (eax != 0) {
                *((esp + 4)) = "java";
                eax = *((ebp + 8));
                eax = strcmp_tospace (eax);
                if (eax == 0) {
                    esi = 2;
                    goto label_2;
                }
                *((esp + 4)) = "python";
                eax = *((ebp + 8));
                eax = strcmp_tospace (eax);
                if (eax == 0) {
                    esi = 3;
                    goto label_2;
                }
                *((esp + 4)) = 0x80758bd;
                eax = *((ebp + 8));
                eax = strcmp_tospace (eax);
                if (eax == 0) {
                    goto label_3;
                }
                *((esp + 4)) = "integer";
                eax = *((ebp + 8));
                eax = strcmp_tospace (eax);
                if (eax == 0) {
                    goto label_3;
                }
            }
        } else {
            esi = edi;
            goto label_2;
label_3:
            ebx = edi;
label_2:
            eax = *((ebp + 8));
            eax = skip_param (eax);
            *((ebp + 8)) = eax;
        } while (1);
    }
    *((ebp - 0x2c)) = 0;
    *((ebp - 0x30)) = esi;
label_0:
    esi = *((ebp + 8));
    eax = ebp - 0x20;
    *((esp + 8)) = eax;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range (eax, eax);
    if (eax == 0) {
        *((ebp - 0x2c)) = 0;
        goto label_4;
    }
    eax = *((ebp + 8));
    while (esi != eax) {
        eax = *((ebp - 0x1c));
        edi = n_lhs;
        esi = n_rhs;
        if (eax <= *((ebp - 0x20))) {
            goto label_5;
        }
        goto label_6;
    }
    *(esp) = "Invalid argument.";
    error ();
    *((ebp - 0x2c)) = 0;
    goto label_4;
    do {
label_5:
        edx = *((edi + eax*4));
        if (edx > 0) {
            if (*((esi + eax*4)) != 0) {
                if (edx != 1) {
                    goto label_7;
                }
                eax = *((eax*4 + obj.lhs));
                if (*(eax) == 1) {
                    goto label_8;
                }
            }
label_7:
            warning ("Can't make assignment statement because this is not an equation.");
label_8:
            *(obj.approximate_roots) = 1;
            eax = *((ebp - 0x1c));
            edx = eax*4 + obj_n_lhs;
            *((esp + 4)) = edx;
            eax = *((eax*4 + obj.lhs));
            simp_i (eax);
            if (ebx != 0) {
                eax = *((ebp - 0x1c));
                edx = eax*4 + obj_n_lhs;
                eax = *((eax*4 + obj.lhs));
                uf_repeat_always (eax, edx);
            }
            eax = *((ebp - 0x1c));
            if (*((esi + eax*4)) > 0) {
                edx = eax*4 + obj_n_rhs;
                *((esp + 4)) = edx;
                eax = *((eax*4 + obj.rhs));
                simp_i (eax);
                if (ebx == 0) {
                    goto label_9;
                }
                eax = *((ebp - 0x1c));
                edx = eax*4 + obj_n_rhs;
                eax = *((eax*4 + obj.rhs));
                uf_repeat_always (eax, edx);
                *(obj.approximate_roots) = 0;
                eax = *((ebp - 0x1c));
                eax = make_fractions_and_group (eax);
            } else {
                *(obj.approximate_roots) = 0;
                make_fractions_and_group (eax);
                if (ebx == 0) {
                    goto label_1;
                }
            }
            eax = *((ebp - 0x1c));
            edx = *((edi + eax*4));
            *((esp + 4)) = edx;
            eax = *((eax*4 + obj.lhs));
            eax = int_expr (eax);
            if (eax != 0) {
                eax = *((ebp - 0x1c));
                edx = *((esi + eax*4));
                *((esp + 4)) = edx;
                eax = *((eax*4 + obj.rhs));
                eax = int_expr (eax);
                if (eax != 0) {
                    goto label_1;
                }
            }
            warning ("Not an integer expression.");
label_1:
            *((esp + 8)) = ebx;
            eax = *((ebp - 0x30));
            *((esp + 4)) = eax;
            eax = *((ebp - 0x1c));
            eax = list_c_equation (eax);
            eax = 1;
            if (eax <= 0) {
                eax = *((ebp - 0x2c));
            }
            *((ebp - 0x2c)) = eax;
        }
        eax = *((ebp - 0x1c));
        eax++;
        *((ebp - 0x1c)) = eax;
    } while (*((ebp - 0x20)) >= eax);
label_6:
    eax = *((ebp + 8));
    if (*(eax) != 0) {
        goto label_0;
    }
label_4:
    eax = *((ebp - 0x2c));
    return eax;
label_9:
    *(obj.approximate_roots) = 0;
    eax = *((ebp - 0x1c));
    make_fractions_and_group (eax);
    goto label_1;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049673 */
#include <stdint.h>
 
int32_t dbg_load_rc (int32_t rv, FILE * fp, char * cp) {
    char[4096] buf;
    int32_t var_1ch;
    char * size;
    FILE * stream;
    int32_t var_ch;
    int32_t var_10h;
    char * var_14h;
    char * var_18h;
    esi = rv;
    edi = fp;
    eax = cp;
    /* int load_rc(); */
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    eax = getenv ("HOME");
    if (eax == 0) {
        goto label_0;
    }
    *((esp + 0x18)) = ".mathomaticrc";
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = "%s/%s";
    *((esp + 0xc)) = 0x1000;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x1000;
    *(esp) = obj.rc_file;
    snprintf_chk ();
    eax = fopen (obj.rc_file, 0x80729f4);
    edi = eax;
    if (eax == 0) {
        goto label_0;
    }
    esi = 1;
    while (eax != 0) {
        set_error_level (ebx);
        *(esp) = ebx;
        eax = set_options ();
        edx = 0;
        if (eax == 0) {
            esi = edx;
        }
        eax = ebp - 0x101c;
        eax = fgets (eax, 0x1000, edi);
        ebx = eax;
    }
    fclose (edi);
    goto label_1;
label_0:
    esi = 1;
label_1:
    eax = 1;
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a4dc */
#include <stdint.h>
 
int32_t dbg_is_all (void) {
    char * cp;
    int32_t var_4h;
    /* int is_all(char * cp); */
    *((esp + 4)) = 0x807207b;
    eax = *((ebp + 8));
    eax = strcmp_tospace (eax);
    al = (eax == 0) ? 1 : 0;
    eax = (int32_t) al;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806dc02 */
#include <stdint.h>
 
int32_t dbg_list_var (uint32_t arg_8h, char * arg_ch, int32_t from_memory, int32_t j, int32_t lang_code, char * cp) {
    char * var_4h;
    int32_t var_8h;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    int32_t var_18h;
    ebx = from_memory;
    esi = j;
    edi = lang_code;
    eax = cp;
    /* int list_var(long int v,int lang_code); */
    esi = *((ebp + 8));
    edi = *((ebp + 0xc));
    *(obj.var_str) = 0;
    eax = esi;
    eax &= 0x3fff;
    if (eax <= 5) {
        /* switch table (6 cases) at 0x8077b14 */
        eax = 0x807207b;
        goto label_1;
        ebx = 0;
        eax = "sign";
        goto label_2;
        edi = var_str;
        eax = 0;
        ecx = 0xffffffff;
        __asm ("repne scasb al, byte es:[edi]");
        ecx = ~ecx;
        eax = ecx - 1;
        goto label_3;
        eax = edi + 3;
        if (eax <= 6) {
            /* switch table (7 cases) at 0x8077b2c */
            eax = 0x8077990;
            goto label_1;
            ebx = 0;
            eax = "{0,1}";
            goto label_2;
            eax = 0x8077991;
            goto label_1;
            eax = 0x80751c8;
            goto label_1;
            eax = 0x8077999;
            goto label_1;
        }
        eax = "1.0i";
        goto label_1;
        eax = edi + 3;
        if (eax <= 6) {
            /* switch table (7 cases) at 0x8077b48 */
            eax = 0x80751c4;
            goto label_1;
            ebx = 0;
            eax = "exp(1.0)";
            goto label_2;
            eax = 0x80779aa;
            goto label_1;
            eax = 0x80779ad;
            goto label_1;
            eax = "Math.E";
            goto label_1;
            eax = "math.e";
            goto label_1;
        }
        eax = 0x80779ab;
        goto label_1;
        edx = edi + 1;
        eax = 0x80779c0;
        if (edx > 4) {
            goto label_1;
        }
        /* switch table (5 cases) at 0x8077b64 */
        ebx = 0;
        eax = 0x80779bf;
        goto label_2;
        eax = 0x80751c7;
        goto label_1;
        eax = "Math.PI";
        goto label_1;
        eax = "math.pi";
        goto label_1;
    }
    eax = var_name (esi);
    ebx = 1;
label_2:
    if (eax != 0) {
label_0:
        esi >>= 0xe;
        esi &= 0x3f;
        if (esi != 0) {
            esi--;
            *((esp + 0x18)) = esi;
            *((esp + 0x14)) = eax;
            *((esp + 0x10)) = "%s%d";
            *((esp + 0xc)) = 0xb4;
            *((esp + 8)) = 1;
            *((esp + 4)) = 0xb4;
            *(esp) = obj.var_str;
            eax = snprintf_chk ();
        } else {
            *((esp + 8)) = 0xb4;
        }
        my_strlcpy (obj.var_str, eax);
    } else {
        *((esp + 8)) = 0xb4;
        my_strlcpy (obj.var_str, "bad_variable");
    }
    if (ebx == 0) {
        goto label_4;
    }
    if (edi == 0) {
        goto label_4;
    }
    ebx = *(obj.var_str);
    if (bl == 0) {
        goto label_4;
    }
    esi = 0;
    edi = var_str;
    do {
        if (bl != 0x5f) {
            eax = ctype_b_loc ();
            ebx = (int32_t) bl;
            eax = *(eax);
            if ((*((eax + ebx*2)) & 8) != 0) {
                goto label_5;
            }
            *((esi + edi)) = 0x5f;
        }
label_5:
        esi++;
        ebx = *((esi + edi));
    } while (bl != 0);
label_4:
    edi = var_str;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = ecx - 1;
label_3:
    return eax;
    eax = "M_PI";
label_1:
    ebx = 0;
    goto label_0;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049224 */
#include <stdint.h>
 
void snprintf_chk (void) {
    snprintf_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049084 */
#include <stdint.h>
 
void ctype_b_loc (void) {
    ctype_b_loc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b29e */
#include <stdint.h>
 
int32_t dbg_clear_all (int32_t i) {
    ebx = i;
    /* void clear_all(); */
    *(obj.cur_equation) = 0;
    edx = n_lhs;
    eax = 0;
    ecx = 0x64;
    edi = edx;
    memset (edi, eax, ecx);
    edx = n_rhs;
    cl = 0x64;
    edi = edx;
    memset (edi, eax, ecx);
    eax = var_names;
    if (eax == 0) {
        goto label_0;
    }
    ebx = 0;
    esi = var_names;
    do {
        free (eax);
        *((esi + ebx*4)) = 0;
        ebx++;
        eax = *((esi + ebx*4));
    } while (eax != 0);
label_0:
    edi = sign_array;
    edx = 0x40;
    eax = 0;
    if ((edi & 1) != 0) {
        *(edi) = al;
        edi++;
        edx--;
    }
    if ((edi & 2) != 0) {
        *(edi) = ax;
        edi += 2;
        edx -= 2;
    }
    ecx = edx;
    ecx >>= 2;
    memset (edi, eax, ecx);
    if ((dl & 2) != 0) {
        *(edi) = ax;
        edi += 2;
    }
    if ((dl & 1) != 0) {
        *(edi) = al;
    }
    init_gvars ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80538f6 */
#include <stdint.h>
 
uint32_t dbg_clear_cmd (char * cp1) {
    int32_t j;
    int32_t i;
    char * cp;
    int32_t var_4h;
    int32_t var_8h;
    ebx = cp1;
    /* int clear_cmd(char * cp); */
    esi = ebp - 0x20;
label_0:
    ebx = *((ebp + 8));
    *(esp) = ebx;
    eax = is_all ();
    if (eax != 0) {
        clear_all ();
        eax = 1;
        goto label_1;
    }
    *((esp + 8)) = esi;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range (eax, eax);
    if (eax == 0) {
        goto label_1;
    }
    edi = *((ebp + 8));
    while (ebx != edi) {
        eax = *((ebp - 0x1c));
        ebx = *((ebp - 0x20));
        if (eax <= ebx) {
            goto label_2;
        }
        goto label_3;
    }
    *(esp) = "Invalid argument.";
    error ();
    eax = 0;
    goto label_1;
label_2:
    edx = eax*4;
    ecx = edx + obj_n_lhs;
    edx += obj.n_rhs;
    do {
        *(ecx) = 0;
        *(edx) = 0;
        eax++;
        ecx += 4;
        edx += 4;
    } while (eax <= ebx);
    *((ebp - 0x1c)) = eax;
label_3:
    if (*(edi) != 0) {
        goto label_0;
    }
    eax = 1;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a3e4 */
#include <stdint.h>
 
uint32_t dbg_exp_contains_infinity (char * arg_ch, int32_t i, int32_t n1) {
    token_type * p1;
    esi = i;
    edi = n1;
    /* int exp_contains_infinity(token_type * p1,int n1); */
    edi = *((ebp + 0xc));
    if (edi <= 0) {
        goto label_0;
    }
    ebx = *((ebp + 8));
    esi = 0;
    do {
        if (*(ebx) == 0) {
            *(fp_stack--) = *((ebx + 8));
            *(esp) = fp_stack[0];
            fp_stack--;
            eax = finite ();
            if (eax != 0) {
                goto label_1;
            }
            al = 1;
            goto label_2;
        }
label_1:
        esi++;
        ebx += 0x10;
    } while (edi > esi);
label_0:
    eax = 0;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b17c */
#include <stdint.h>
 
uint32_t dbg_next_espace (int32_t i) {
    char * var_4h;
    eax = i;
    /* int next_espace(); */
    eax = alloc_next_espace ();
    if (eax < 0) {
        *(esp) = "Out of free equation spaces.";
        error ();
        *((esp + 4)) = "Use the clear command on unnecessary equations and try again.\n";
        *(esp) = 1;
        printf_chk ();
        *((esp + 4)) = 3;
        *(esp) = obj.jmp_save;
        longjmp_chk ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048ef4 */
#include <stdint.h>
 
void longjmp_chk (void) {
    longjmp_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a168 */
#include <stdint.h>
 
int32_t dbg_var_in_equation (int32_t arg_8h, char * arg_ch, int32_t i, long int v) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    ebx = i;
    esi = v;
    /* int var_in_equation(int i,long int v); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = *((ebx*4 + obj.n_lhs));
    if (eax > 0) {
        eax = *((ebx*4 + obj.lhs));
        eax = found_var (eax, eax, esi);
        edx = eax;
        eax = 1;
        if (edx != 0) {
            goto label_0;
        }
        eax = *((ebx*4 + obj.n_rhs));
        if (eax > 0) {
            eax = *((ebx*4 + obj.rhs));
            eax = found_var (eax, eax, esi);
            al = (eax != 0) ? 1 : 0;
            eax = (int32_t) al;
        }
    } else {
        eax = 0;
    }
label_0:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8071830 */
#include <stdint.h>
 
uint32_t libc_csu_init (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h) {
    int32_t var_4h;
    int32_t var_8h;
    _i686_get_pc_thunk_bx (ebx, esi, edi);
    ebx += 0x77b9;
    _init ();
    edi = ebx - 0xf8;
    eax = ebx - 0xf8;
    edi -= eax;
    edi >>= 2;
    if (edi == 0) {
        goto label_0;
    }
    esi = 0;
    do {
        eax = *((ebp + 0x10));
        eax = *((ebp + 0xc));
        eax = *((ebp + 8));
        uint32_t (*ebx + esi*4 - 0xf8)(uint32_t, uint32_t, uint32_t) (eax, eax, eax);
        esi++;
    } while (esi < edi);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062cc2 */
#include <stdint.h>
 
uint32_t dbg_uf_repeat_always (int32_t arg_8h, char * arg_ch) {
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    /* void uf_repeat_always(token_type * equation,int * np); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    organize (esi);
    *((esp + 8)) = 8;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    eax = sub_ufactor ();
    if (eax != 0) {
        *((esp + 4)) = ebx;
        organize (esi);
    }
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8055fd5 */
#include <stdint.h>
 
int32_t dbg_set_cmd (void) {
    char * cp;
    int32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    /* int set_cmd(char * cp); */
    eax = *((ebp + 8));
    if (*(eax) == 0) {
        *((esp + 8)) = "Options are set as follows:\n\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = gfp;
        output_options (eax);
        eax = screen_columns;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "columns = %d\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = gfp;
        output_current_directory (eax);
        eax = 1;
    } else {
        *(esp) = eax;
        set_options ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804d01a */
#include <stdint.h>
 
int32_t dbg_solve_sub (int32_t op, token_type * p2, token_type * p1, int32_t foundp, int32_t len2, token_type * b1) {
    int32_t var_7ch;
    int32_t inc_count;
    int32_t zero_solved;
    int32_t worked;
    int32_t qtries;
    int32_t success;
    token_type * ep;
    int32_t found2;
    int32_t var_54h;
    int32_t len1;
    long int v;
    int32_t found_count;
    int32_t zsolve;
    double denominator;
    double numerator;
    int32_t diff_sign;
    token_type * wantp;
    int32_t wantn;
    token_type * leftp;
    int * leftnp;
    token_type * rightp;
    int * rightnp;
    size_t * s2;
    size_t * n;
    char * var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_sp_1ch;
    ebx = op;
    ecx = p2;
    edx = p1;
    esi = foundp;
    edi = len2;
    eax = b1;
    /* int solve_sub(token_type * wantp,int wantn,token_type * leftp,int * leftnp,token_type * rightp,int * rightnp); */
label_17:
    *(obj.repeat_count) = 0;
    edx = *((ebp + 0x14));
    eax = *(edx);
    *(obj.n_tlhs) = eax;
    eax <<= 4;
    ecx = *((ebp + 0x10));
    eax = tlhs;
    memmove (eax, ecx, eax);
    ebx = *((ebp + 0x1c));
    eax = *(ebx);
    *(obj.n_trhs) = eax;
    eax <<= 4;
    esi = *((ebp + 0x18));
    eax = trhs;
    memmove (eax, esi, eax);
    if (*((ebp + 0xc)) != 1) {
        *(esp) = "This program will only solve for a single variable or for zero.";
        error ();
        *((ebp - 0x60)) = 0;
        goto label_21;
    }
    if (*(obj.n_tlhs) > 0) {
        eax = n_trhs;
        if (eax > 0) {
            goto label_22;
        }
    }
    *(esp) = "Please enter an equation or a command like \"help\".";
    eax = error ();
    *((ebp - 0x60)) = 0;
    goto label_21;
label_22:
    edi = *((ebp + 8));
    edx = *(edi);
    if (edx == 1) {
        edx = *((edi + 8));
        *((ebp - 0x4c)) = edx;
        eax = trhs;
        eax = found_var (eax, eax, edx);
        if (eax != 0) {
            goto label_23;
        }
        ecx = *((ebp - 0x4c));
        eax = n_tlhs;
        eax = tlhs;
        eax = found_var (eax, eax, ecx);
        if (eax != 0) {
            goto label_23;
        }
        *(esp) = "Variable not found.";
        error ();
        *((ebp - 0x60)) = 0;
        goto label_21;
    }
    if (edx == 0) {
        ebx = *((ebp + 8));
        *(fp_stack--) = *((ebx + 8));
        *(fp_stack--) = 0.0;
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_24;
            }
            *((ebp - 0x3c)) = 1;
            *((ebp - 0x4c)) = 0;
        }
    } else {
label_24:
        *(esp) = "This program will only solve for a single variable or for zero.";
        error ();
        *((ebp - 0x60)) = 0;
        goto label_21;
label_23:
        *((ebp - 0x3c)) = 0;
    }
    eax = tlhs;
    uf_power (eax, obj.n_tlhs);
    eax = trhs;
    uf_power (eax, 0x80798b4);
    *((ebp - 0x60)) = 1;
    *((ebp - 0x6c)) = 0;
    *((ebp - 0x70)) = 0;
    *((ebp - 0x64)) = 0;
    *((ebp - 0x5c)) = 0;
    goto label_1;
label_19:
    *((ebp - 0x6c)) = 1;
    goto label_1;
label_13:
    *((ebp - 0x6c)) = 0;
    *((ebp - 0x64)) = 0;
    *((ebp - 0x5c)) = 1;
    do {
label_1:
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        esi = *((ebp - 0x3c));
        eax = tlhs;
        simps_side (eax, 0x80796b8, esi);
        if (*((ebp - 0x5c)) != 0) {
            eax = trhs;
            simp_loop (eax, obj.n_trhs);
            *((esp + 4)) = 0x80798b4;
            eax = trhs;
            *(esp) = eax;
            uf_simp ();
            edi = *((ebp - 0x4c));
            eax = trhs;
            factorv (eax, 0x80798b4, edi);
        } else {
            eax = *((ebp - 0x3c));
            eax = trhs;
            simps_side (eax, 0x80798b4, eax);
        }
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
label_4:
        edx = trhs;
        eax = n_trhs;
        eax <<= 4;
        eax = edx + eax;
        if (*((ebp - 0x3c)) == 0) {
            if (edx < eax) {
                goto label_25;
            }
            goto label_26;
        }
        if (edx >= eax) {
            goto label_26;
        }
        ecx = edx;
label_0:
        if (*((ecx + 4)) != 1) {
            goto label_27;
        }
        if (*(ecx) != 2) {
            goto label_27;
        }
        ebx = ecx + 0x10;
        if (*((ecx + 8)) != 4) {
            goto label_27;
        }
        *((esp + 8)) = obj.n_tlhs;
        eax = tlhs;
        *((esp + 4)) = eax;
        ecx = edx;
        edx = ebx;
        eax = 4;
        eax = g_of_f (obj.n_trhs);
    } while (eax != 0);
    goto label_28;
label_27:
    ecx += 0x10;
    if (eax > ecx) {
        goto label_0;
    }
    goto label_26;
label_25:
    edi = edx;
    ecx = edx;
    esi = 0;
    *((ebp - 0x48)) = edx;
label_2:
    ebx = *(ecx);
    if (ebx != 1) {
        goto label_29;
    }
    edx = *((ebp - 0x4c));
    if (*((ecx + 8)) != edx) {
        goto label_29;
    }
    edx = *((ebp - 0x48));
    if (esi != 0) {
        goto label_30;
    }
    ecx += 0x10;
    do {
        if (ecx >= eax) {
            goto label_31;
        }
        if (*((ecx + 4)) == 1) {
            if (*(ecx) != 2) {
                goto label_32;
            }
            esi = *((ecx + 8));
            if (esi < 1) {
                goto label_30;
            }
            if (esi <= 2) {
                goto label_31;
            }
            if (esi > 4) {
                goto label_30;
            }
            goto label_33;
        }
label_32:
        ecx += 0x10;
    } while (1);
label_30:
    if (esi <= 6) {
        ebx = 1;
        ecx = esi;
        ebx <<= cl;
        if ((bl & 0x58) != 0) {
            goto label_33;
        }
    }
    edx = edi;
    goto label_34;
label_33:
    ecx = edx;
    do {
        *((ecx + 4))++;
        ecx += 0x10;
    } while (ecx < eax);
    esi = 1;
    goto label_34;
label_31:
    edx = edi;
    esi = 1;
label_34:
    *((esp + 8)) = obj.n_tlhs;
    eax = tlhs;
    *((esp + 4)) = eax;
    ecx = trhs;
    eax = esi;
    eax = g_of_f (obj.n_trhs);
    if (eax != 0) {
        goto label_1;
    }
    goto label_28;
label_29:
    if (*((ecx + 4)) == 1) {
        if (ebx != 2) {
            goto label_35;
        }
        esi = *((ecx + 8));
        edi = ecx + 0x10;
    }
label_35:
    ecx += 0x10;
    if (eax > ecx) {
        goto label_2;
    }
    edx = *((ebp - 0x48));
label_26:
    if (*((ebp - 0x5c)) != 0) {
        ebx = *((ebp - 0x3c));
        simps_side (edx, 0x80798b4, ebx);
        goto label_10;
label_18:
        *((ebp - 0x6c)) = 1;
    }
label_10:
    *((ebp - 0x5c)) = 0;
    *((ebp - 0x68)) = 1;
label_9:
    esi = *((ebp - 0x4c));
    eax = n_trhs;
    eax = trhs;
    eax = found_var (eax, eax, esi);
    if (eax != 0) {
        if (*(obj.debug_level) <= 0) {
            goto label_28;
        }
        *((esp + 0xc)) = "Solve variable moved back to RHS, quitting solve routine.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((ebp - 0x60)) = 0;
        goto label_21;
    }
    edi = ebp - 0x1c;
    *((esp + 0x10)) = edi;
    eax = n_tlhs;
    *((esp + 0xc)) = eax;
    eax = tlhs;
    *((esp + 8)) = eax;
    *((esp + 4)) = 1;
    eax = *((ebp + 8));
    *(esp) = eax;
    eax = se_compare ();
    if (eax == 0) {
        goto label_36;
    }
    if (*((ebp - 0x1c)) != 0) {
        goto label_36;
    }
    if (*((ebp - 0x3c)) == 0) {
        goto label_37;
    }
label_6:
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    eax = trhs;
    uf_power (eax, 0x80798b4);
    do {
label_3:
        *(fp_stack--) = 0.0;
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = trhs;
        simp_ssub (0, 0x80798b4, 0);
        eax = trhs;
        eax = uf_power (eax, 0x80798b4);
    } while (eax != 0);
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    eax = super_factor ();
    if (eax != 0) {
        goto label_3;
    }
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    esi = trhs;
    ebx = n_trhs;
    edx = n_trhs;
    edx <<= 4;
    edx = esi + edx;
    eax = esi + 0x10;
    ecx = 0;
    goto label_38;
label_5:
    if (*((eax + 4)) != 1) {
        goto label_39;
    }
    ecx = *((eax + 8));
    if (ecx == 4) {
        goto label_4;
    }
    if (ecx != 3) {
        goto label_40;
    }
label_39:
    eax += 0x20;
label_38:
    if (eax < edx) {
        goto label_5;
    }
label_40:
    if (ecx == 3) {
        goto label_41;
    }
    if (ecx != 6) {
        goto label_42;
    }
    goto label_43;
label_8:
    ebx = esi;
    do {
        eax = *(ebx);
        if (eax == 2) {
            if (*((ebx + 4)) != 1) {
                goto label_44;
            }
label_7:
            edi = esi + 0x10;
            edx -= ebx;
            memmove (edi, ebx, edx);
            eax = ebx;
            eax -= edi;
            eax >>= 4;
            *(obj.n_trhs) -= eax;
            *(esi) = 0;
            *(fp_stack--) = 1.0;
            *((esi + 8)) = fp_stack[0];
            fp_stack--;
            goto label_6;
        }
        if (eax != 0) {
            if (eax != 1) {
                goto label_45;
            }
            eax = *((ebx + 8));
            eax &= 0x3fff;
            if (eax > 4) {
                goto label_45;
            }
        }
label_44:
        ebx += 0x10;
    } while (edx > ebx);
    goto label_7;
label_45:
    esi += 0x10;
    while (*((esi + 4)) > 1) {
        esi += 0x20;
        if (esi >= edx) {
            goto label_46;
        }
    }
label_46:
    esi += 0x10;
label_41:
    if (esi < edx) {
        goto label_8;
    }
    goto label_42;
label_43:
    eax += 0x10;
    if (*((eax + 4)) == 1) {
        if (*(eax) != 0) {
            goto label_42;
        }
        *(fp_stack--) = *((eax + 8));
        *(fp_stack--) = 0.0;
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_42;
        }
        ebx -= 2;
        *(obj.n_trhs) = ebx;
        goto label_6;
    }
label_42:
    if (*(obj.debug_level) > 0) {
        *((esp + 0xc)) = "Solve for zero completed:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        goto label_47;
label_37:
        if (*(obj.debug_level) <= 0) {
            goto label_47;
        }
        *((esp + 0xc)) = "Solve completed:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
label_47:
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    eax = *((ebp + 0x10));
    memmove (eax, eax, eax);
    eax = n_tlhs;
    edx = *((ebp + 0x14));
    *(edx) = eax;
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    ecx = *((ebp + 0x18));
    memmove (ecx, eax, eax);
    eax = n_trhs;
    ebx = *((ebp + 0x1c));
    *(ebx) = eax;
    goto label_21;
label_36:
    esi = tlhs;
    *((ebp - 0x50)) = esi;
    edi = n_tlhs;
    *((ebp - 0x54)) = edi;
    esi = edi;
    esi <<= 4;
    esi += *((ebp - 0x50));
    edx = *((ebp - 0x50));
    ebx = *((ebp - 0x50));
    edi = 0;
    eax = 0;
    ecx = 0;
    *((ebp - 0x48)) = 0;
    *((ebp - 0x58)) = ecx;
    *((ebp - 0x7c)) = edi;
label_20:
    if (ebx < esi) {
        if (*((ebx + 4)) != 1) {
            goto label_48;
        }
        if (*(ebx) != 2) {
            goto label_48;
        }
    }
    if (eax != 0) {
        goto label_49;
    }
    if (ebx >= esi) {
        if (*((ebp - 0x48)) != 0) {
            goto label_50;
        }
        if (*((ebp - 0x3c)) != 0) {
            goto label_50;
        }
        if (*((ebp - 0x54)) > 1) {
            goto label_50;
        }
        eax = *((ebp - 0x50));
        if (*(eax) == 0) {
            goto label_51;
        }
    }
label_50:
    eax = ebx;
    eax -= edx;
    eax -= 0x10;
    if (eax <= 0xf) {
        if (*(edx) != 0) {
            goto label_52;
        }
        *(fp_stack--) = *((edx + 8));
        *(fp_stack--) = 1.0;
        fp_tmp_2 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_2;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_52;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_52;
        }
        if (ebx >= esi) {
            goto label_52;
        }
        if (*((ebx + 8)) == 4) {
            goto label_51;
        }
    }
label_52:
    if (ecx != 0) {
        goto label_53;
    }
    if (ebx >= esi) {
        goto label_54;
    }
    edi = *((ebp - 0x7c));
    do {
        if (*((ebx + 4)) == 1) {
            if (*(ebx) != 2) {
                goto label_55;
            }
            *((ebp - 0x7c)) = edi;
            ecx = *((ebx + 8));
            if (ecx < 1) {
                goto label_53;
            }
            if (ecx <= 2) {
                goto label_54;
            }
            eax = 3;
            if (ecx <= 4) {
                ecx = eax;
            }
            goto label_53;
        }
label_55:
        ebx += 0x10;
    } while (esi > ebx);
    *((ebp - 0x7c)) = edi;
label_54:
    ecx = 1;
label_53:
    if (*((ebp - 0x3c)) == 0) {
        goto label_56;
    }
    if (ebx < esi) {
        if (ecx > 4) {
            goto label_57;
        }
        eax = 1;
        eax <<= cl;
        if ((al & 0x16) != 0) {
            goto label_58;
        }
        goto label_57;
    }
    eax = ecx;
    if (ecx == 4) {
        goto label_59;
    }
    if (*((ebp - 0x50)) >= esi) {
        goto label_60;
    }
    eax = *((ebp - 0x50));
    do {
        *((eax + 4))++;
        eax += 0x10;
    } while (esi > eax);
label_60:
    edx = *((ebp - 0x50));
    eax = 1;
    goto label_59;
label_56:
    eax = ecx;
    goto label_59;
label_58:
    eax = ecx;
label_59:
    *((esp + 8)) = obj.n_trhs;
    ecx = trhs;
    *((esp + 4)) = ecx;
    ecx = tlhs;
    eax = g_of_f (obj.n_tlhs);
    if (eax == 0) {
        goto label_28;
    }
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    if (*((ebp - 0x5c)) != 0) {
        eax = tlhs;
        simp_loop (eax, obj.n_tlhs);
    } else {
        edx = *((ebp - 0x3c));
        eax = tlhs;
        simps_side (eax, 0x80796b8, edx);
    }
    ecx = *((ebp - 0x3c));
    eax = trhs;
    simps_side (eax, 0x80798b4, ecx);
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    eax = list_debug (eax, eax, eax);
    goto label_9;
label_49:
    eax += *((ebp - 0x7c));
    if (ecx != 4) {
        eax = *((ebp - 0x7c));
    }
    *((ebp - 0x7c)) = eax;
label_51:
    if (ebx < esi) {
        goto label_57;
    }
    edi = *((ebp - 0x7c));
    if (*((ebp - 0x48)) != 0) {
        goto label_61;
    }
    ebx = *((ebp - 0x4c));
    eax = n_trhs;
    eax = trhs;
    eax = found_var (eax, eax, ebx);
    if (eax != 0) {
        if (*(obj.debug_level) <= 0) {
            goto label_28;
        }
        *((esp + 0xc)) = "Solve variable moved back to RHS, quitting solve routine.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((ebp - 0x60)) = 0;
        goto label_21;
    }
    *((esp + 4)) = obj.n_tlhs;
    eax = tlhs;
    *(esp) = eax;
    calc_simp ();
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    *(esp) = eax;
    calc_simp ();
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    eax = n_trhs;
    *((esp + 0xc)) = eax;
    eax = trhs;
    *((esp + 8)) = eax;
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    *(esp) = eax;
    eax = se_compare ();
    while (*((ebp - 0x1c)) != 0) {
        ecx = n_tlhs;
        eax = tlhs;
        edx = 0;
        goto label_62;
    }
    *(esp) = "This equation is an identity.";
    error ();
    *((esp + 4)) = "That is, the LHS is identical to the RHS.\n";
    *(esp) = 1;
    eax = printf_chk ();
    *((ebp - 0x60)) = 0xffffffff;
    goto label_21;
    do {
        if (*(eax) == 1) {
            if (*((eax + 8)) <= 3) {
                goto label_63;
            }
            ecx = 1;
            goto label_64;
        }
label_63:
        edx += 2;
        eax += 0x20;
label_62:
    } while (edx < ecx);
    ecx = 0;
label_64:
    ebx = n_trhs;
    eax = trhs;
    edx = 0;
    while (edx < ebx) {
        if (*(eax) == 1) {
            if (*((eax + 8)) > 3) {
                goto label_65;
            }
        }
        edx += 2;
        eax += 0x20;
    }
    if (ecx != 0) {
label_65:
        *(esp) = "This equation is independent of the solve variable.";
        error ();
        *((ebp - 0x60)) = 0xfffffffe;
        goto label_21;
    }
    *(esp) = "There are no possible values for the solve variable.";
    error ();
    *((ebp - 0x60)) = 0xfffffffe;
    goto label_21;
label_61:
    if (*(obj.n_trhs) == 1) {
        eax = trhs;
        if (*(eax) == 0) {
            *(fp_stack--) = *((eax + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_3 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_3;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] != fp_stack[1]) {
                goto label_66;
            }
            if (fp_stack[0] == fp_stack[1]) {
                goto label_66;
            }
            *(fp_stack--) = 0.0;
            *((eax + 8)) = fp_stack[0];
            fp_stack--;
            ecx = 1;
        }
    } else {
label_66:
        ecx = 0;
    }
    if (*((ebp - 0x48)) <= edi) {
        *(esp) = obj.n_trhs;
        ecx = trhs;
        edx = n_tlhs;
        eax = tlhs;
        eax = flip ();
        if (eax == 0) {
            goto label_28;
        }
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        eax = *((ebp - 0x3c));
        eax = tlhs;
        simps_side (eax, 0x80796b8, eax);
        edx = *((ebp - 0x3c));
        eax = trhs;
        simps_side (eax, 0x80798b4, edx);
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        goto label_10;
    }
    if (*((ebp - 0x68)) != 0) {
        if (*((ebp - 0x5c)) != 0) {
            goto label_67;
        }
        if (*(obj.debug_level) > 0) {
            *((esp + 0xc)) = "Unfactoring...";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        *(obj.partial_flag) = 0;
        *((esp + 4)) = 0x80796b8;
        eax = tlhs;
        *(esp) = eax;
        uf_simp ();
        *(obj.partial_flag) = 1;
        ecx = *((ebp - 0x4c));
        eax = tlhs;
        factorv (eax, 0x80796b8, ecx);
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        *((ebp - 0x5c)) = 1;
        *((ebp - 0x68)) = 0;
        goto label_9;
    }
label_67:
    if (*((ebp - 0x5c)) != 0) {
        ebx = *((ebp - 0x3c));
        eax = tlhs;
        simps_side (eax, 0x80796b8, ebx);
        eax = n_trhs;
        *((esp + 0x10)) = eax;
        eax = trhs;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (eax, eax, eax);
        *((ebp - 0x5c)) = 0;
        goto label_9;
    }
    esi = tlhs;
    *((ebp - 0x48)) = esi;
    edi = n_tlhs;
    *((ebp - 0x54)) = edi;
    eax = esi;
    eax += 0x20;
    ebx = esi;
    esi = 0;
    edi = 1;
    goto label_68;
label_11:
    *((ebp - 0x50)) = edi;
    if (*((eax - 0xc)) != 1) {
        goto label_69;
    }
    edx = *((eax - 8));
    *((ebp - 0x68)) = edx;
    edx -= 3;
    if (edx > 1) {
        edx = *((ebp - 0x68));
        esi = *((ebp - 0x68));
        goto label_70;
    }
    edx = 3;
    if (esi == 0) {
        esi = edx;
    }
    if (ecx != 0) {
        if (*((ebp - 0x68)) != 4) {
            *((ebp - 0x50)) = eax;
            if (*(eax) != 1) {
                goto label_69;
            }
            edx = *((ebp - 0x4c));
            if (*((eax + 8)) != edx) {
                goto label_69;
            }
            edx = *((eax + 4));
            *((ebp - 0x58)) = edx;
            if (edx == 1) {
                goto label_71;
            }
            if (edx != 2) {
                goto label_69;
            }
            if (*((eax + 0x18)) != 6) {
                goto label_69;
            }
            if (*((eax + 0x24)) != 2) {
                goto label_69;
            }
            if (*((eax + 0x20)) != 0) {
                goto label_69;
            }
            *(fp_stack--) = *((eax + 0x28));
            *(fp_stack--) = 0.0;
            fp_tmp_4 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_4;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] > fp_stack[1]) {
                goto label_71;
            }
            goto label_69;
        }
        edx = *((ebp - 0x68));
        eax = *((ebp - 0x50));
        eax <<= 4;
        esi = *((ebp - 0x48));
        ebx = eax + esi + 0x10;
        esi = edx;
        goto label_70;
    }
    if (*((ebp - 0x68)) != 4) {
        goto label_69;
    }
    edx = *((ebp - 0x50));
    edx += 2;
    *((ebp - 0x50)) = edx;
    edx = eax + 0x10;
    *((ebp - 0x7c)) = eax;
    while (eax > 1) {
        edx += 0x20;
        if (*((ebp - 0x58)) == 2) {
            eax = *((ebp - 0x7c));
            edx = *((ebp - 0x68));
            edx = *((edx + 8));
            edx--;
            if (edx > 1) {
                goto label_69;
            }
            *((ebp - 0x50)) = eax;
            esi = 4;
            goto label_72;
        }
        *((ebp - 0x50)) += 2;
        eax = *((ebp - 0x54));
        if (*((ebp - 0x50)) >= eax) {
            goto label_73;
        }
        *((ebp - 0x68)) = edx;
        eax = *((edx + 4));
        *((ebp - 0x58)) = eax;
    }
    eax = *((ebp - 0x7c));
    goto label_69;
label_73:
    eax = *((ebp - 0x7c));
label_69:
    *((ebp - 0x50)) = ebx;
    goto label_72;
label_71:
    esi = *((ebp - 0x68));
label_72:
    edi += 2;
    eax += 0x20;
    ebx = *((ebp - 0x50));
label_68:
    if (edi < *((ebp - 0x54))) {
        goto label_11;
    }
label_70:
    edx = *((ebp - 0x6c));
    *((ebp - 0x48)) = dl;
    if (ecx != 0) {
        if (dl != 0) {
            if (esi != 3) {
                goto label_74;
            }
            if (*(ebx) != 1) {
                goto label_74;
            }
            ecx = *((ebp - 0x4c));
            if (*((ebx + 8)) != ecx) {
                goto label_74;
            }
            eax = *((ebx + 4));
            if (eax == 1) {
                goto label_75;
            }
            if (eax != 2) {
                goto label_76;
            }
            if (*((ebx + 0x18)) != 6) {
                goto label_76;
            }
            eax = ebx + 0x20;
            if (*((eax + 4)) != 2) {
                goto label_76;
            }
            if (*(eax) != 0) {
                goto label_76;
            }
            *(fp_stack--) = *((eax + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_5 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_5;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] <= fp_stack[1]) {
                goto label_76;
            }
        }
    } else {
label_74:
        if (esi != 4) {
            goto label_76;
        }
        goto label_77;
    }
label_75:
    *((esp + 8)) = "Removing possible solution: \";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = 0;
    *((esp + 4)) = 1;
    *(esp) = ebx;
    list_proc ();
    *((esp + 8)) = " = 0\".\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((ebp - 0x60)) = 2;
    *((ebp - 0x64)) = 0;
    goto label_78;
label_77:
    *((ebp - 0x5c)) = 1;
    if (*(obj.debug_level) > 0) {
        *((esp + 0xc)) = "Juggling...";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((ebp - 0x5c)) = 1;
    }
label_78:
    *((esp + 8)) = obj.n_trhs;
    eax = trhs;
    *((esp + 4)) = eax;
    ecx = tlhs;
    edx = ebx;
    eax = esi;
    eax = g_of_f (obj.n_tlhs);
    if (eax != 0) {
        goto label_1;
    }
    goto label_28;
label_12:
    eax = tlhs;
    *((ebp - 0x58)) = esi;
    edx = esi;
    edx <<= 4;
    *((ebp - 0x54)) = edx;
    edx = eax + edx;
    if (*((edx + 8)) != 6) {
        goto label_79;
    }
    ecx = edi + 0x20;
    *((ebp - 0x50)) = ecx;
    eax += ecx;
    ecx = *((eax + 4));
    if (ecx != *((edx + 4))) {
        goto label_79;
    }
    if (*(eax) != 0) {
        goto label_79;
    }
    *(fp_stack--) = *((eax + 8));
    *(fp_stack--) = fp_stack[0];
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = 1.0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_80;
    }
    eax = ebp - 0x30;
    edx = ebp - 0x28;
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = f_to_fraction (eax, edx);
    if (eax == 0) {
        goto label_79;
    }
    *(fp_stack--) = *((ebp - 0x28));
    fp_stack[0] = abs(fp_stack[0]);
    *(fp_stack--) = 1.0;
    fp_tmp_6 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_6;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_79;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_79;
    }
    *(fp_stack--) = *((ebp - 0x30));
    *(fp_stack--) = *(0x8072058);
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_79;
    }
    ecx = *((ebp - 0x58));
    ecx--;
    edx = tlhs;
    eax = *((ebp - 0x54));
    eax += edx;
    *((ebp - 0x54)) = eax;
    eax = edx + edi;
    *((ebp - 0x58)) = edx;
    *((ebp - 0x68)) = ecx;
    while (edx >= *((ecx + 4))) {
        if (*(eax) == 1) {
            edx = *((ebp - 0x4c));
            if (*((eax + 8)) != edx) {
                goto label_81;
            }
            edx = *((ebp - 0x58));
            if (ebx != 0) {
                edx += *((ebp - 0x50));
                *(fp_stack--) = *((ebx + 8));
                fp_stack[0] = abs(fp_stack[0]);
                *(fp_stack--) = *((edx + 8));
                fp_stack[0] = abs(fp_stack[0]);
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] > fp_stack[1]) {
                    goto label_82;
                }
                goto label_79;
            }
            edx += *((ebp - 0x50));
            goto label_82;
        }
label_81:
        *((ebp - 0x68))--;
        eax -= 0x10;
        if (*((ebp - 0x68)) < 0) {
            goto label_79;
        }
        edx = *((eax + 4));
        ecx = *((ebp - 0x54));
    }
    goto label_79;
label_80:
    fp_stack++;
label_79:
    edx = ebx;
label_82:
    esi += 2;
    edi += 0x20;
    ebx = edx;
    goto label_83;
label_76:
    edi = 0;
    ebx = 0;
    esi = 1;
label_83:
    if (esi < *(obj.n_tlhs)) {
        goto label_12;
    }
    if (*((ebp - 0x48)) == 0) {
        goto label_84;
    }
    if (ebx == 0) {
        goto label_84;
    }
    *((ebp - 0x70))++;
    if (*((ebp - 0x70)) > 0x14) {
        goto label_28;
    }
    *(fp_stack--) = 1.0;
    fp_stack[0] /= *((ebx + 8));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    eax = precision;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "Raising both equation sides to the power of %.*g and unfactoring...\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = *((ebx + 8));
    *((ebp - 0x48)) = fp_stack[0];
    fp_stack--;
    *(obj.partial_flag) = 0;
    *((esp + 4)) = 0x80796b8;
    eax = tlhs;
    *(esp) = eax;
    ufactor ();
    *(obj.partial_flag) = 1;
    eax = symblify;
    *(obj.symb_flag) = eax;
    *(fp_stack--) = *((ebp - 0x48));
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x4c));
    eax = tlhs;
    simp_ssub (2, 0x80796b8, eax);
    *(fp_stack--) = 1.0;
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    eax = tlhs;
    simp_ssub (2, 0x80796b8, 0);
    *(obj.symb_flag) = 0;
    *((ebp - 0x64)) = 1;
label_16:
    eax = tlhs;
    edx = n_tlhs;
    edx <<= 4;
    edx = eax + edx;
    *((ebp - 0x5c)) = edx;
    ecx = eax + 0x10;
    *((ebp - 0x50)) = 0;
    esi = 0;
label_14:
    if (*((ebp - 0x5c)) <= ecx) {
        goto label_13;
    }
    edi = *((ecx + 4));
    if (edi == 1) {
        goto label_85;
    }
    if (*((ecx + 8)) != 6) {
        goto label_86;
    }
    if (edi != *((ecx + 0x14))) {
        goto label_86;
    }
    if (*((ecx + 0x10)) != 0) {
        goto label_86;
    }
    *(fp_stack--) = *((ecx + 0x18));
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_86;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_86;
    }
    edx = ecx - 0x10;
    ebx = 0;
    *((ebp - 0x54)) = edi;
    do {
        edi = *((ebp - 0x54));
        if (edi > *((edx + 4))) {
            edx += 0x10;
            goto label_87;
        }
        if (*(edx) == 1) {
            edi = *((ebp - 0x4c));
            edi = 1;
            if (edi != *((edx + 8))) {
                ebx = edi;
                goto label_88;
            }
        }
label_88:
        if (eax == edx) {
            goto label_89;
        }
        edx -= 0x10;
    } while (1);
label_89:
    edx = eax;
label_87:
    if (ebx != 0) {
        ebx = ecx;
        ebx -= edx;
        edx = ebx;
        edx >>= 4;
        if (*((ebp - 0x50)) >= edx) {
            edx = *((ebp - 0x50));
        }
        *((ebp - 0x50)) = edx;
        esi = *((ebp - 0x64));
    }
label_86:
    ecx += 0x20;
    goto label_14;
label_85:
    *((ebp - 0x6c)) = esi;
    edx = ecx + 0x20;
    edi = 0;
    *((ebp - 0x58)) = 0;
    *((ebp - 0x68)) = esi;
label_15:
    if (*((ebp - 0x5c)) <= edx) {
        goto label_90;
    }
    if (*((edx + 8)) != 6) {
        goto label_91;
    }
    esi = *((edx + 0x14));
    *((ebp - 0x54)) = esi;
    if (esi != *((edx + 4))) {
        goto label_91;
    }
    if (*((edx + 0x10)) != 0) {
        goto label_91;
    }
    *(fp_stack--) = *((edx + 0x18));
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_91;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_91;
    }
    ebx = edx - 0x10;
    esi = 0;
    *((ebp - 0x7c)) = edx;
    do {
        edx = *((ebp - 0x54));
        if (edx > *((ebx + 4))) {
            edx = *((ebp - 0x7c));
            ebx += 0x10;
            goto label_92;
        }
        if (*(ebx) == 1) {
            edx = *((ebp - 0x4c));
            edx = 1;
            if (edx != *((ebx + 8))) {
                esi = edx;
                goto label_93;
            }
        }
label_93:
        if (eax == ebx) {
            goto label_94;
        }
        ebx -= 0x10;
    } while (1);
label_94:
    edx = *((ebp - 0x7c));
    ebx = eax;
label_92:
    if (esi != 0) {
        esi = edx;
        esi -= ebx;
        ebx = esi;
        ebx >>= 4;
        if (edi < ebx) {
            edi = ebx;
        }
        ebx = *((ebp - 0x64));
        *((ebp - 0x58)) = ebx;
    }
label_91:
    edx += 0x20;
    goto label_15;
label_90:
    esi = *((ebp - 0x68));
    if (*((ebp - 0x6c)) != 0) {
        if (*((ebp - 0x58)) == 0) {
            goto label_95;
        }
        edx = 0;
        if (edi <= *((ebp - 0x50))) {
            esi = edx;
            goto label_95;
        }
    }
label_95:
    edx = ecx + 0x10;
    ebx = *((ecx + 8));
    if (ebx != 6) {
        goto label_96;
    }
    if (*((edx + 4)) != 1) {
        goto label_96;
    }
    if (*(edx) != 0) {
        goto label_96;
    }
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = *((ebp - 0x48));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_96;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_96;
    }
    *((esp + 8)) = obj.n_trhs;
    ecx = trhs;
    *((esp + 4)) = ecx;
    ecx = eax;
    eax = 6;
    eax = g_of_f (obj.n_tlhs);
    if (eax != 0) {
        goto label_13;
    }
    goto label_28;
label_96:
    if (esi == 0) {
        edx = ecx;
        edx -= eax;
        edx -= 0x10;
        if (edx <= 0xf) {
            if (ebx != 4) {
                goto label_97;
            }
            if (*(eax) != 0) {
                goto label_98;
            }
            *(fp_stack--) = *((eax + 8));
            *(fp_stack--) = 1.0;
            fp_tmp_7 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_7;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] != fp_stack[1]) {
                goto label_98;
            }
            if (fp_stack[0] == fp_stack[1]) {
                goto label_98;
            }
            *(esp) = obj.n_trhs;
            ecx = trhs;
            edx = n_tlhs;
            eax = flip ();
            if (eax != 0) {
                goto label_99;
            }
            goto label_28;
        }
label_97:
        if (ebx >= 1) {
            if (ebx > 2) {
                if (ebx <= 4) {
                } else {
                    edx = eax;
                    ebx = 1;
                }
            } else {
                edx = eax;
                goto label_100;
            }
label_98:
            edx = eax;
            ebx = 3;
        }
    }
label_100:
    *((esp + 8)) = obj.n_trhs;
    ecx = trhs;
    *((esp + 4)) = ecx;
    ecx = eax;
    eax = ebx;
    eax = g_of_f (obj.n_tlhs);
    if (eax == 0) {
        goto label_28;
    }
label_99:
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    eax = tlhs;
    simp_loop (eax, 0x80796b8);
    eax = trhs;
    simp_loop (eax, 0x80798b4);
    eax = n_trhs;
    *((esp + 0x10)) = eax;
    eax = trhs;
    eax = n_tlhs;
    eax = tlhs;
    list_debug (eax, eax, eax);
    goto label_16;
label_84:
    if (*((ebp - 0x64)) != 0) {
        goto label_28;
    }
    if (*(obj.debug_level) > 0) {
        *((esp + 0xc)) = "Solving for zero...";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = n_tlhs;
    edx = *((ebp + 0x14));
    *(edx) = eax;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    ecx = *((ebp + 0x10));
    memmove (ecx, eax, eax);
    eax = n_trhs;
    ebx = *((ebp + 0x1c));
    *(ebx) = eax;
    eax = n_trhs;
    eax <<= 4;
    eax = trhs;
    esi = *((ebp + 0x18));
    memmove (esi, eax, eax);
    *((esp + 0x14)) = ebx;
    *((esp + 0x10)) = esi;
    edi = *((ebp + 0x14));
    *((esp + 0xc)) = edi;
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    *((esp + 4)) = 1;
    *(esp) = obj.zero_token;
    eax = solve_sub ();
    goto label_17;
    if (eax <= 0) {
        goto label_28;
    }
    *((ebp - 0x64)) -= 0xffffffff;
    eax = *((ebp - 0x4c));
    eax = quad_solve ();
    if (eax != 0) {
        goto label_18;
    }
    goto label_19;
label_57:
    ecx = *((ebx + 8));
    edx = ebx + 0x10;
    eax = 0;
    goto label_101;
label_48:
    if (*(ebx) == 1) {
        edi = *((ebp - 0x4c));
        if (*((ebx + 8)) != edi) {
            goto label_101;
        }
        *((ebp - 0x48))++;
        eax++;
    }
label_101:
    ebx += 0x10;
    goto label_20;
label_28:
    *((ebp - 0x60)) = 0;
label_21:
    eax = *((ebp - 0x60));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80503d7 */
#include <stdint.h>
 
int32_t dbg_remove_trailing_spaces (int32_t arg_8h, int32_t i, char * cp) {
    ebx = i;
    esi = cp;
    /* void remove_trailing_spaces(char * cp); */
    esi = *((ebp + 8));
    edi = *((ebp + 8));
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    edi = ecx - 1;
    ebx = ecx;
    ebx -= 2;
    if (ebx < 0) {
        goto label_0;
    }
    eax = ctype_b_loc ();
    edi = esi + edi;
    while ((*((edx + ecx*2 + 1)) & 0x20) != 0) {
        *((edi - 1)) = 0;
        edi--;
        ebx--;
        if (ebx < 0) {
            goto label_0;
        }
        ecx = *((edi - 1));
        edx = *(eax);
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070444 */
#include <stdint.h>
 
uint16_t dbg_gcd_verified (void) {
    double d4;
    double d3;
    double divisor;
    double d1;
    double d2;
    /* double gcd_verified(double d1,double d2); */
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x18)) = fp_stack[0];
    *(fp_stack--) = *((ebp + 0x10));
    *((ebp - 0x20)) = fp_stack[0];
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = gcd ();
    *((ebp - 0x10)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0x10));
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_0;
        }
    }
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[1] /= fp_stack[0];
    fp_stack++;
    *((ebp - 0x18)) = fp_stack[0];
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_1;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x18));
    *(esp) = fp_stack[0];
    fp_stack--;
    ax = fmod ();
label_1:
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_2;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_2;
    }
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] /= *((ebp - 0x10));
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x20));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_3;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x20));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_3:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            *(fp_stack--) = *((ebp - 0x20));
            *((esp + 8)) = fp_stack[0];
            fp_stack--;
            *(fp_stack--) = *((ebp - 0x18));
            *(esp) = fp_stack[0];
            fp_stack--;
            gcd ();
            *(fp_stack--) = 1.0;
            fp_tmp_3 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_3;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] != fp_stack[1]) {
                if (fp_stack[0] == fp_stack[1]) {
                    goto label_4;
                }
            }
            *(fp_stack--) = 0.0;
            *((ebp - 0x10)) = fp_stack[0];
            fp_stack--;
        }
    } else {
label_2:
        *(fp_stack--) = 0.0;
        *((ebp - 0x10)) = fp_stack[0];
        fp_stack--;
        goto label_4;
label_0:
        fp_stack++;
    }
label_4:
    *(fp_stack--) = *((ebp - 0x10));
    return ax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806e42e */
#include <stdint.h>
 
int32_t dbg_list_c_equation (int32_t arg_8h, int32_t en, int32_t len) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    language_list language;
    int32_t int_flag;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    ebx = en;
    esi = len;
    /* int list_c_equation(int en,language_list language,int int_flag); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    esi = 0;
    if (*((ebx*4 + obj.n_lhs)) > 0) {
        edi = ebx*4;
        eax = *((ebp + 0x10));
        *((esp + 0xc)) = eax;
        eax = *((ebp + 0xc));
        *((esp + 8)) = eax;
        eax = edi + obj_n_lhs;
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        eax = list_code (eax);
        esi = eax;
        if (*((ebx*4 + obj.n_rhs)) != 0) {
            *((esp + 8)) = 0x80759cf;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            *((ebp - 0x1c)) = eax;
            eax = *((ebp + 0x10));
            *((esp + 0xc)) = eax;
            eax = *((ebp + 0xc));
            *((esp + 8)) = eax;
            edi += obj.n_rhs;
            *((esp + 4)) = edi;
            eax = *((ebx*4 + obj.rhs));
            eax = list_code (eax);
            eax += *((ebp - 0x1c));
            esi += eax;
        }
        eax = *((ebp + 0xc));
        eax--;
        if (eax <= 1) {
            *((esp + 8)) = 0x8077a56;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            esi += eax;
        }
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80664f4 */
#include <stdint.h>
 
int32_t dbg_div_remainder (void * arg_8h, char * arg_ch, size_t * arg_10h, int32_t rv, int * np, token_type * equation) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t quick_flag;
    int32_t var_sp_4h;
    ebx = rv;
    esi = np;
    edi = equation;
    /* int div_remainder(token_type * equation,int * np,int poly_flag,int quick_flag); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (*((ebp + 0x14)) != 0) {
        *((esp + 4)) = esi;
        *(esp) = edi;
        group_proc ();
        *((esp + 4)) = ebx;
        *(esp) = 1;
        ecx = 0;
        edx = esi;
        eax = edi;
        eax = pdiv_recurse ();
        ebx = eax;
        *((esp + 4)) = esi;
        organize (edi);
    } else {
        *((esp + 4)) = ebx;
        *(esp) = 1;
        ecx = 0;
        edx = esi;
        eax = edi;
        eax = pdiv_recurse ();
        ebx = eax;
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804f580 */
#include <stdint.h>
 
uint32_t dbg_help_cmd (int32_t arg_8h, int32_t j, char * cp1, int32_t row, char * cp) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t flag;
    int32_t var_1ch;
    char * s2;
    size_t * n;
    char * var_ch;
    int32_t var_10h;
    ebx = j;
    ecx = cp1;
    esi = row;
    edi = cp;
    /* int help_cmd(char * cp); */
    edi = *((ebp + 8));
    ebx = *(edi);
    if (bl == 0) {
        goto label_2;
    }
    eax = ctype_b_loc ();
    *((ebp - 0x28)) = eax;
    eax = *(eax);
    *((ebp - 0x24)) = edi;
    edx = edi;
    while ((*((eax + ebx*2 + 1)) & 0x20) == 0) {
        edx++;
        ebx = *(edx);
        if (bl == 0) {
            goto label_3;
        }
        ebx = (int32_t) bl;
    }
label_3:
    *((ebp - 0x24)) = edx;
    if (edx == edi) {
        goto label_2;
    }
    *((ebp - 0x20)) = 0;
label_0:
    ebx = com_list;
    esi = 0;
    ecx = *((ebp - 0x24));
    ecx -= edi;
    *((ebp - 0x1c)) = ecx;
    do {
        eax = *((ebp - 0x1c));
        eax = *(ebx);
        eax = strncasecmp (edi, eax, eax);
        if (eax != 0) {
            eax = *((ebx + 4));
            if (eax == 0) {
                goto label_4;
            }
            edx = *((ebp - 0x1c));
            eax = strncasecmp (edi, eax, edx);
            if (eax != 0) {
                goto label_4;
            }
        }
        display_command (esi);
        *((ebp - 0x20)) = 1;
label_4:
        esi++;
        ebx += 0x18;
    } while (esi != 0x2a);
    ebx = *((ebp - 0x24));
    ebx -= edi;
    if (*((ebp - 0x20)) == 0) {
        goto label_5;
    }
    ecx = *((ebp - 0x24));
    eax = skip_space (ecx);
    edi = eax;
    eax = *(eax);
    if (al == 0) {
        goto label_6;
    }
    ecx = *((ebp - 0x28));
    edx = *(ecx);
    *((ebp - 0x24)) = edi;
    ecx = edi;
    while ((*((edx + eax*2 + 1)) & 0x20) == 0) {
        ecx++;
        eax = *(ecx);
        if (al == 0) {
            goto label_7;
        }
        eax = (int32_t) al;
    }
label_7:
    *((ebp - 0x24)) = ecx;
    if (ecx != edi) {
        goto label_0;
    }
    goto label_6;
label_5:
    eax = strncasecmp (edi, "examples", ebx);
    if (eax == 0) {
        *(esp) = "P>\a\by)\a\b~)\a\b";
        read_examples ();
        goto label_8;
    }
    eax = strncasecmp (edi, "copyright", ebx);
    if (eax != 0) {
        eax = strncasecmp (edi, "license", ebx);
        if (eax != 0) {
            goto label_9;
        }
    }
    *((esp + 0xc)) = "Copyright and License for Mathomatic";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "------------------------------------\n";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = "x9\a\b";
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 0x8075e74;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
    goto label_8;
label_9:
    eax = strncasecmp (edi, "bugs", ebx);
    if (eax == 0) {
        *((esp + 0xc)) = "Report bugs on the Launchpad support website for Mathomatic:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "http://launchpad.net/mathomatic\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Please include the following information (from the version command):\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        version_report ();
        goto label_8;
    }
    eax = strncasecmp (edi, "usage", ebx);
    if (eax != 0) {
        goto label_10;
    }
    *((esp + 0xc)) = "Mathomatic Command Usage Syntax";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "-------------------------------";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    ebx = 0;
    esi = 3;
    edi = 0x8074d8c;
    do {
        eax = *((ebx + edi));
        *((esp + 0x10)) = eax;
        eax = *((ebx + obj.com_list));
        *((esp + 0xc)) = eax;
        *((esp + 8)) = 0x8072788;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        esi++;
        eax = gfp;
        if (eax == *(obj.stdout)) {
            eax = screen_rows;
            if (eax == 0) {
                goto label_11;
            }
            eax = screen_rows;
            eax -= 2;
            if (esi < eax) {
                goto label_11;
            }
            eax = pause_cmd (0x80757fe);
            if (eax == 0) {
                goto label_12;
            }
            esi = 1;
        }
label_11:
        ebx += 0x18;
    } while (ebx != 0x3f0);
    goto label_6;
label_10:
    eax = strncasecmp (edi, "geometry", ebx);
    if (eax == 0) {
        *((esp + 0xc)) = "Commonly used standard (Euclidean) geometric formulas";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "-----------------------------------------------------";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Triangle of base \"b\" and height \"h\":";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    area = b*h/2\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Rectangle of length \"l\" and width \"w\":";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    area = l*w                    perimeter = 2*l + 2*w\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Trapezoid of parallel sides \"a\" and \"b\", and \"d\" distance between them:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    area = d*(a + b)/2\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Circle of radius \"r\":";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    area = pi*r^2                 perimeter = 2*pi*r\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Rectangular solid of length \"l\", width \"w\", and height \"h\":";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    volume = l*w*h                surface_area = 2*l*w + 2*l*h + 2*w*h\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Sphere of radius \"r\":";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    volume = 4/3*pi*r^3           surface_area = 4*pi*r^2\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Convex polygon of \"n\" sides, sum of all interior angles formula:";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    sum = (n - 2)*180 degrees     sum = (n - 2)*pi radians";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 1;
        goto label_8;
    }
    eax = strncasecmp (edi, "expressions", ebx);
    if (eax != 0) {
        eax = strncasecmp (edi, "equations", ebx);
        if (eax != 0) {
            goto label_13;
        }
    }
    *((esp + 0xc)) = "To enter an expression or equation, simply type it in at the prompt.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Operators have precedence decreasing as indicated:\n";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    - negate (highest precedence)";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    ! factorial (gamma function)";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    ** or ^ power (exponentiation)";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    * multiply      / divide        % modulus       // integral divide";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    + add           - subtract";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    = equate (lowest precedence)\n";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Variables consist of any combination of letters, digits, and underscores (_).";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Predefined variables follow:\n";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    sign, sign1, sign2, ... - may only be +1 or -1";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "    integer, integer1, ... - may only be an integer value\n";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Absolute value notation \"|x|\" and dual polarity \"+/-x\" are understood.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Type \"help constants\" for information on entering constants.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
    goto label_8;
label_13:
    eax = strncasecmp (edi, "constants", ebx);
    if (eax == 0) {
        *((esp + 0xc)) = "Constants are double precision floating point values with up to";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "14 decimal digits accuracy.  They can be entered in standard, scientific,";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "or hexadecimal notation.  Excepting named constants, constants always";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "start with a decimal digit (0..9) or a period.\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "Named constants follow:\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    e or e# - the universal constant e (2.7182818284...)";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    pi or pi# - the universal constant pi (3.1415926535...)";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    i or i# - the imaginary unit (square root of -1)";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "The above constants may also be used anywhere variables are required.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    inf - floating point infinity constant";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0xc)) = "    nan - invalid floating point result (not enterable)\n";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *(fp_stack--) = *(0x8075178);
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = "The largest value of a constant is +/-%g\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *(fp_stack--) = *(0x8075180);
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = "The smallest value of a constant is +/-%g\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = 1;
        goto label_8;
    }
    *(esp) = edi;
    eax = is_all ();
    if (eax == 0) {
        goto label_14;
    }
    *((esp + 0xc)) = "Mathomatic Command Summary";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "--------------------------";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    ebx = 3;
    esi = 0;
    edi = 1;
    do {
        eax = display_command (esi);
        ebx += eax;
        eax = gfp;
        if (eax == *(obj.stdout)) {
            eax = screen_rows;
            if (eax == 0) {
                goto label_15;
            }
            eax = screen_rows;
            eax -= 5;
            if (ebx < eax) {
                goto label_15;
            }
            eax = pause_cmd (0x80757fe);
            if (eax == 0) {
                goto label_12;
            }
            ebx = edi;
        }
label_15:
        esi++;
    } while (esi != 0x2a);
    *((esp + 0xc)) = 0x2a;
    *((esp + 8)) = "End of command list.  Total of %d different commands.\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
    goto label_8;
label_14:
    *(esp) = "Unrecognized help topic or command.";
    error ();
    eax = 0;
    goto label_8;
label_2:
    *((esp + 0xc)) = "Mathomatic is a Computer Algebra System (CAS) and calculator program.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "To see helpful interactive examples, type \"help examples\".";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Type \"help equations\" for help with entering expressions and equations.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Type \"help all\" for a summary and syntax of all commands.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Type \"help usage\" to display the syntax of all commands.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "\"help\" or \"?\" followed by a command name will give info on that command.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "Other help keywords: constants, geometry, copyright, license, bugs.\n";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = 0x2a;
    *((esp + 8)) = "These are the %d commands:\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    edi = com_list;
    esi = 0;
label_1:
    eax = 0x66666667;
    edx:eax = eax * esi;
    edx >>= 1;
    eax = esi;
    eax >>= 0x1f;
    edx -= eax;
    eax = edx * 5;
    if (esi == eax) {
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = *(edi);
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 0x8075e74;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    eax = fprintf_chk ();
    ebx = 0xf;
    ebx -= eax;
    if (ebx <= 0) {
        goto label_16;
    }
    do {
        *((esp + 8)) = 0x8077a28;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        ebx--;
    } while (ebx > 0);
label_16:
    esi++;
    edi += 0x18;
    if (esi != 0x2a) {
        goto label_1;
    }
    *((esp + 0xc)) = "\n\nTo select an equation space, type the equation number at the main prompt.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 0xc)) = "To solve the current equation, type the variable name at the main prompt.";
    *((esp + 8)) = 0x807277d;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = 1;
    goto label_8;
label_6:
    eax = 1;
    goto label_8;
label_12:
    eax = 0;
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804e8bb */
#include <stdint.h>
 
int32_t dbg_parse_var2 (uint32_t arg_8h, char * arg_ch) {
    int32_t var_4h;
    /* char * parse_var2(long int * vp,char * cp); */
    eax = *((ebp + 0xc));
    eax = skip_space (eax);
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax = parse_var (eax);
    edx = eax;
    eax = 0;
    if (edx != 0) {
        skip_space (edx);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805073a */
#include <stdint.h>
 
int32_t dbg_parse_var (char * arg_ch, int32_t i, char * cp, long int vtmp) {
    int32_t var_90h;
    int (*)() strcmpfunc;
    char * cp1;
    char[101] buf;
    int32_t var_1ch;
    long int * vp;
    char * endptr;
    size_t base;
    ebx = i;
    edi = cp;
    eax = vtmp;
    /* char * parse_var(long int * vp,char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x90)) = eax;
    edi = *((ebp + 0xc));
    edx = *(gs:0x14);
    *((ebp - 0x1c)) = edx;
    edx = 0;
    eax = imp.strcmp;
    edx = imp.strcasecmp;
    if (*(obj.case_sensitive_flag) == 0) {
        eax = edx;
    }
    *((ebp - 0x8c)) = eax;
    eax = *(edi);
    eax = isvarchar (eax);
    if (eax == 0) {
        *(esp) = "Invalid variable.";
        error ();
        eax = 0;
        goto label_0;
    }
    *((ebp - 0x88)) = edi;
    eax = *(edi);
    ebx = 0;
    if (al == 0) {
        goto label_1;
    }
    esi = ebp - 0x81;
    do {
        eax = (int32_t) al;
        eax = isvarchar (eax);
        if (eax == 0) {
            goto label_1;
        }
        if (ebx == 0x64) {
            *(esp) = "Variable name too long.";
            error ();
            eax = 0;
            goto label_0;
        }
        eax = *((ebp - 0x88));
        edx = *(eax);
        *((esi + ebx)) = dl;
        ebx++;
        eax++;
        *((ebp - 0x88)) = eax;
        eax = *(eax);
    } while (al != 0);
label_1:
    *((ebp + ebx - 0x81)) = 0;
    eax = ebp - 0x81;
    eax = strcasecmp (eax, 0x80751b7);
    if (eax == 0) {
        *(esp) = "Infinity cannot be used as a variable.";
        error ();
        eax = 0;
        goto label_0;
    }
    eax = ebp - 0x81;
    eax = strcasecmp (eax, 0x80751bb);
    if (eax == 0) {
        *(esp) = "NaN (Not a Number) cannot be directly entered.";
        error ();
        eax = 0;
        goto label_0;
    }
    eax = ebp - 0x81;
    eax = uint32_t (*ebp - 0x8c)(uint32_t, char*) (eax, "sign");
    if (eax == 0) {
        eax = ctype_b_loc ();
        edx = *((ebp - 0x88));
        ebx = *(edx);
        ecx = *(eax);
        eax = 4;
        if ((*((ecx + ebx*2 + 1)) & 8) == 0) {
            goto label_2;
        }
        goto label_3;
    }
    eax = strncasecmp (edi, 0x80751c8, 2);
    if (eax == 0) {
        eax = *((ebp - 0x90));
        *(eax) = 3;
        eax = edi + 2;
        goto label_0;
    }
    eax = strncasecmp (edi, 0x80751c4, 2);
    if (eax == 0) {
        edx = *((ebp - 0x90));
        *(edx) = 1;
        eax = edi + 2;
        goto label_0;
    }
    eax = strncasecmp (edi, 0x80751c7, 3);
    if (eax == 0) {
        eax = *((ebp - 0x90));
        *(eax) = 2;
        eax = edi + 3;
        goto label_0;
    }
    *((ebp - 0x88)) = edi;
    eax = *(edi);
    ebx = 0;
    if (al == 0) {
        goto label_4;
    }
    esi = ebp - 0x81;
    do {
        eax = (int32_t) al;
        eax = isvarchar (eax);
        if (eax == 0) {
            eax = ctype_b_loc ();
            edx = *((ebp - 0x88));
            edx = *(edx);
            eax = *(eax);
            if ((*((eax + edx*2 + 1)) & 8) == 0) {
                goto label_4;
            }
        }
        if (ebx == 0x64) {
            *(esp) = "Variable name too long.";
            error ();
            eax = 0;
            goto label_0;
        }
        eax = *((ebp - 0x88));
        edx = *(eax);
        *((esi + ebx)) = dl;
        ebx++;
        eax++;
        *((ebp - 0x88)) = eax;
        eax = *(eax);
    } while (al != 0);
label_4:
    *((ebp + ebx - 0x81)) = 0;
    eax = ebp - 0x81;
    eax = uint32_t (*ebp - 0x8c)(uint32_t, uint32_t) (eax, 0x8077991);
    if (eax == 0) {
        edx = *((ebp - 0x90));
        *(edx) = 3;
        eax = *((ebp - 0x88));
        goto label_0;
    }
    eax = ebp - 0x81;
    eax = uint32_t (*ebp - 0x8c)(uint32_t, uint32_t) (eax, 0x80779ab);
    if (eax == 0) {
        eax = *((ebp - 0x90));
        *(eax) = 1;
        eax = *((ebp - 0x88));
        goto label_0;
    }
    eax = ebp - 0x81;
    eax = uint32_t (*ebp - 0x8c)(uint32_t, uint32_t) (eax, 0x80779c0);
    if (eax == 0) {
        edx = *((ebp - 0x90));
        *(edx) = 2;
        eax = *((ebp - 0x88));
        goto label_0;
    }
    eax = ebp - 0x81;
    *(esp) = eax;
    eax = is_all ();
    if (eax == 0) {
        eax = var_names;
        ebx = 0;
        if (eax != 0) {
            goto label_5;
        }
        goto label_6;
    }
    *(esp) = "\"all\" is a reserved word and may not be used as a variable name.";
    error ();
    eax = 0;
    goto label_0;
label_5:
    esi = ebp - 0x81;
    edi = var_names;
    do {
        eax = uint32_t (*ebp - 0x8c)(uint32_t, uint32_t) (esi, eax);
        if (eax == 0) {
            eax = ebx;
            eax += 0x41;
            if (eax != 0) {
                goto label_7;
            }
        } else {
            ebx++;
            eax = *((edi + ebx*4));
        } while (eax != 0);
    }
    do {
        if (ebx > 0x1f3e) {
            *(esp) = "Maximum number of variable names reached.";
            error ();
            *((esp + 4)) = "Please restart or use \"clear all\".\n";
            *(esp) = 1;
            printf_chk ();
            eax = 0;
        } else {
            edi = ebp - 0x81;
            eax = 0;
            ecx = 0xffffffff;
            __asm ("repne scasb al, byte es:[edi]");
            esi = ecx;
            esi = ~esi;
            eax = malloc (esi);
            *((ebx*4 + obj.var_names)) = eax;
            if (eax == 0) {
                *(esp) = "Out of memory (can't malloc(3) variable name).";
                error ();
                eax = 0;
            } else {
                edx = ebp - 0x81;
                memmove (eax, edx, esi);
                eax = ebx + 0x41;
                *((ebx*4 + 0x8079ae4)) = 0;
label_7:
                edx = *((ebp - 0x90));
                *(edx) = eax;
                eax = *((ebp - 0x88));
                goto label_0;
label_3:
                eax = ebp - 0x88;
                eax = strtol (edx, eax, 0xa);
                if (eax > 0x3e) {
                    *(esp) = "Maximum subscript exceeded in special variable name.";
                    error ();
                    eax = 0;
                } else {
                    eax++;
                    *((eax + obj.sign_array)) = 1;
                    eax <<= 0xe;
                    eax += 4;
label_2:
                    edx = *((ebp - 0x90));
                    *(edx) = eax;
                    eax = *((ebp - 0x88));
                }
            }
        }
label_0:
        edx = *((ebp - 0x1c));
        edx ^= *(gs:0x14);
        if (eax == 0) {
            goto label_8;
        }
        goto label_9;
label_6:
        ebx = 0;
    } while (1);
label_9:
    stack_chk_fail ();
label_8:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b351 */
#include <stdint.h>
 
int32_t dbg_init_mem (void) {
    /* int init_mem(); */
    eax = n_tokens;
    eax *= 3;
    edx = eax;
    edx >>= 0x1f;
    eax = edx + eax;
    eax >>= 1;
    eax <<= 4;
    eax = malloc (eax);
    *(obj.scratch) = eax;
    if (eax != 0) {
        eax = n_tokens;
        eax <<= 4;
        eax = malloc (eax);
        *(obj.tes) = eax;
        if (eax != 0) {
            eax = n_tokens;
            eax <<= 4;
            eax = malloc (eax);
            *(obj.tlhs) = eax;
            if (eax == 0) {
                goto label_0;
            }
            eax = n_tokens;
            eax <<= 4;
            eax = malloc (eax);
            *(obj.trhs) = eax;
            if (eax == 0) {
                goto label_0;
            }
            eax = alloc_next_espace ();
            if (eax < 0) {
                goto label_0;
            }
            clear_all ();
            eax = 1;
        }
    } else {
label_0:
        eax = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fa09 */
#include <stdint.h>
 
int32_t dbg_list_equation (int32_t arg_8h, int32_t n, char * cp, int32_t len) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t export_flag;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    ebx = n;
    esi = cp;
    eax = len;
    /* char * list_equation(int n,int export_flag); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    eax = *((ebx*4 + obj.n_lhs));
    esi = 0;
    if (eax > 0) {
        edx = *((ebp + 0xc));
        *((esp + 0xc)) = edx;
        *((esp + 8)) = 0;
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *(esp) = eax;
        list_string ();
        edx = *((ebx*4 + obj.n_rhs));
        if (edx != 0) {
            esi = eax + 3;
            eax = *((ebp + 0xc));
            *((esp + 0xc)) = eax;
            *((esp + 8)) = 0;
            *((esp + 4)) = edx;
            eax = *((ebx*4 + obj.rhs));
            *(esp) = eax;
            eax = list_string ();
            eax += esi;
        }
        eax += 2;
        eax = malloc (eax);
        esi = eax;
        if (eax == 0) {
            *(esp) = 0x8077c40;
            eax = error ();
        } else {
            edx = *((ebp + 0xc));
            *((esp + 0xc)) = edx;
            *((esp + 8)) = eax;
            eax = *((ebx*4 + obj.n_lhs));
            *((esp + 4)) = eax;
            eax = *((ebx*4 + obj.lhs));
            *(esp) = eax;
            list_string ();
            if (*((ebx*4 + obj.n_rhs)) != 0) {
                edx = 0xffffffff;
                edi = esi;
                eax = 0;
                ecx = edx;
                __asm ("repne scasb al, byte es:[edi]");
                ecx = ~ecx;
                *((esi + ecx - 1)) = 0x203d20;
                edi = esi;
                ecx = edx;
                __asm ("repne scasb al, byte es:[edi]");
                ecx = ~ecx;
                eax = *((ebp + 0xc));
                *((esp + 0xc)) = eax;
                eax = esi + ecx - 1;
                *((esp + 8)) = eax;
                eax = *((ebx*4 + obj.n_rhs));
                *((esp + 4)) = eax;
                eax = *((ebx*4 + obj.rhs));
                *(esp) = eax;
                list_string ();
            }
            if (*((ebp + 0xc)) != 1) {
                goto label_0;
            }
            edi = esi;
            eax = 0;
            ecx = 0xffffffff;
            __asm ("repne scasb al, byte es:[edi]");
            ecx = ~ecx;
            *((esi + ecx - 1)) = 0x3b;
        }
    }
label_0:
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805eb89 */
#include <stdint.h>
 
int32_t dbg_factor_power (void) {
    token_type * equation;
    int * np;
    /* int factor_power(token_type * equation,int * np); */
    *(esp) = 1;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    fpower_recurse ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8064f8f */
#include <stdint.h>
 
int32_t dbg_poly_div (int32_t sign, int32_t sum_size, int32_t last_count) {
    int32_t var_f4h;
    int32_t var_f0h;
    int32_t old_partial;
    jmp_buf save_save;
    double d;
    double divisor_power;
    double last_power;
    int32_t divide_flag;
    int32_t len_t2;
    int32_t t2;
    int32_t len_t1;
    int32_t t1;
    token_type * d1;
    int32_t len1;
    token_type * d2;
    int32_t len2;
    long int * vp;
    size_t * s2;
    size_t n;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    ebx = sign;
    ecx = sum_size;
    edi = last_count;
    /* int poly_div(token_type * d1,int len1,token_type * d2,int len2,long int * vp); */
    eax = partial_flag;
    *((ebp - 0xec)) = eax;
    *(obj.partial_flag) = 0;
    eax = ebp - 0xe4;
    memmove (eax, 0x8079600, 0x9c);
    eax = setjmp (obj.jmp_save);
    ebx = eax;
    if (eax != 0) {
        eax = ebp - 0xe4;
        memmove (obj.jmp_save, eax, 0x9c);
        edx = *((ebp - 0xec));
        *(obj.partial_flag) = edx;
        if (ebx != 0xd) {
            ebx = 0;
            goto label_1;
        }
        *((esp + 4)) = 0xd;
        *(esp) = obj.jmp_save;
        longjmp_chk ();
    }
    eax = n_tokens;
    if (*((ebp + 0xc)) > eax) {
        goto label_2;
    }
    if (*((ebp + 0x14)) > eax) {
        goto label_2;
    }
    eax = trhs;
    if (*((ebp + 8)) != eax) {
        edx = *((ebp + 0xc));
        edx <<= 4;
        edx = *((ebp + 8));
        memmove (eax, edx, edx);
        eax = *((ebp + 0xc));
        *(obj.n_trhs) = eax;
    }
    eax = tlhs;
    if (*((ebp + 0x10)) != eax) {
        edx = *((ebp + 0x14));
        edx <<= 4;
        edx = *((ebp + 0x10));
        memmove (eax, edx, edx);
        eax = *((ebp + 0x14));
        *(obj.n_tlhs) = eax;
    }
    *((esp + 4)) = obj.n_trhs;
    eax = trhs;
    *(esp) = eax;
    uf_simp ();
    *((esp + 4)) = 0x80796b8;
    eax = tlhs;
    *(esp) = eax;
    uf_simp ();
    edx = *((ebp + 0x18));
    if (*(edx) == 0) {
        eax = n_tlhs;
        ecx = tlhs;
        edx = n_trhs;
        eax = trhs;
        eax = find_highest_count (eax, edx);
        if (eax == 0) {
            goto label_2;
        }
    }
    if (*(obj.debug_level) > 2) {
        edx = *((ebp + 0x18));
        eax = *(edx);
        list_var (eax, 0);
        *((esp + 0xc)) = 0x8079800;
        *((esp + 8)) = "poly_div() starts using base variable (%s):\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        *((esp + 0x10)) = 0;
        eax = n_trhs;
        eax = trhs;
        list_debug (0, eax, eax);
        *((esp + 0x10)) = 0;
        eax = n_tlhs;
        eax = tlhs;
        list_debug (0, eax, eax);
    }
    *((ebp - 0x2c)) = 2;
    ebx = ebp - 0x2c;
    *((esp + 0x18)) = ebx;
    eax = ebp - 0x20;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x38;
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0x18));
    *((esp + 8)) = eax;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    eax = find_greatest_power ();
    edi = eax;
    *((esp + 0x18)) = ebx;
    eax = ebp - 0x28;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x24;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x40;
    *((esp + 0xc)) = eax;
    edx = *((ebp + 0x18));
    *((esp + 8)) = edx;
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    *(esp) = eax;
    find_greatest_power ();
    *(fp_stack--) = *((ebp - 0x40));
    *(fp_stack--) = 0.0;
    fp_stack--;
    if (fp_stack[0] < fp_stack[1]) {
        *(fp_stack--) = *((ebp - 0x38));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_3;
        }
    } else {
        fp_stack++;
    }
    al = (*((ebp - 0x2c)) == 0) ? 1 : 0;
    eax = (int32_t) al;
    *((ebp - 0x2c)) = eax;
    ebx = ebp - 0x2c;
    *((esp + 0x18)) = ebx;
    eax = ebp - 0x20;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x38;
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0x18));
    *((esp + 8)) = eax;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    eax = find_greatest_power ();
    edi = eax;
    *((esp + 0x18)) = ebx;
    eax = ebp - 0x28;
    *((esp + 0x14)) = eax;
    eax = ebp - 0x24;
    *((esp + 0x10)) = eax;
    eax = ebp - 0x40;
    *((esp + 0xc)) = eax;
    edx = *((ebp + 0x18));
    *((esp + 8)) = edx;
    eax = n_tlhs;
    *((esp + 4)) = eax;
    eax = tlhs;
    *(esp) = eax;
    find_greatest_power ();
    *(fp_stack--) = *((ebp - 0x40));
    *(fp_stack--) = 0.0;
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        goto label_4;
    }
    *(fp_stack--) = *((ebp - 0x38));
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_2;
    }
label_3:
    *(obj.n_quotient) = 1;
    eax = zero_token;
    *(obj.quotient) = eax;
    eax = .comment;
    *(0x8083f84) = eax;
    eax = .comment;
    *(0x8083f88) = eax;
    eax = .comment;
    *(0x8083f8c) = eax;
    eax = n_tlhs;
    if (eax > 0x7530) {
        goto label_2;
    }
    *((esp + 0xc)) = 0x75300;
    eax <<= 4;
    *((esp + 8)) = eax;
    eax = tlhs;
    *((esp + 4)) = eax;
    *(esp) = obj.divisor;
    memmove_chk ();
    eax = n_tlhs;
    *(obj.n_divisor) = eax;
    eax = n_trhs;
    *((ebp - 0xf0)) = eax;
    edx = n_quotient;
    *((ebp - 0xf4)) = edx;
    goto label_5;
label_0:
    edi = eax;
label_5:
    eax = *((ebp - 0x1c));
    if (eax > 0) {
        ecx = eax - 1;
        ecx <<= 4;
        ebx = 2;
        edx = trhs;
        if (*((ecx + edx + 8)) == 2) {
            goto label_6;
        }
    }
    ebx = 1;
label_6:
    edx = *((ebp - 0x24));
    if (edx > 0) {
        edx <<= 4;
        if (*((edx + 0x816e598)) != 2) {
            goto label_7;
        }
        bl = (ebx != 2) ? 1 : 0;
        ebx = (int32_t) bl;
        ebx++;
    }
label_7:
    edx = *((ebp - 0x20));
    ecx = *((ebp - 0x20));
    ecx += *((ebp - 0x28));
    ecx++;
    if (ecx > *(obj.n_tokens)) {
        goto label_2;
    }
    edx <<= 4;
    eax <<= 4;
    eax += *(obj.trhs);
    eax = tlhs;
    memmove (eax, eax, edx);
    edx = *((ebp - 0x20));
    *(obj.n_tlhs) = edx;
    if (edx <= 0) {
        goto label_8;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
        edx = n_tlhs;
    } while (eax < edx);
label_8:
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 4)) = 1;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax)) = 2;
    edx = n_tlhs;
    edx <<= 4;
    eax = tlhs;
    *((edx + eax + 8)) = 4;
    eax = n_tlhs;
    eax++;
    *(obj.n_tlhs) = eax;
    edx = *((ebp - 0x28));
    edx <<= 4;
    edx = *((ebp - 0x24));
    edx <<= 4;
    edx += obj.divisor;
    eax <<= 4;
    eax += *(obj.tlhs);
    memmove (eax, edx, edx);
    eax = n_tlhs;
    edx = n_tlhs;
    edx += *((ebp - 0x28));
    *(obj.n_tlhs) = edx;
    if (eax >= edx) {
        goto label_9;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.tlhs);
        *((ecx + 4))++;
        eax++;
        edx += 0x10;
    } while (eax < *(obj.n_tlhs));
label_9:
    eax = tlhs;
    eax = simp_loop (eax, obj.n_tlhs);
    if (eax == 0) {
        goto label_2;
    }
    eax = n_tlhs;
    ecx = n_tlhs;
    ecx += *(obj.n_quotient);
    ecx++;
    edx = 0x7530;
    if (*(obj.n_tokens) <= 0x7530) {
        edx = *(obj.n_tokens);
    }
    if (ecx > edx) {
        goto label_2;
    }
    if (eax <= 0) {
        goto label_10;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.tlhs);
        *((edx + 4))++;
        eax++;
    } while (eax < *(obj.n_tlhs));
label_10:
    ecx = n_quotient;
    eax = quotient;
    edx = ecx;
    edx <<= 4;
    *((edx + eax + 4)) = 1;
    *((edx + eax)) = 2;
    *((edx + eax + 8)) = ebx;
    ecx++;
    *(obj.n_quotient) = ecx;
    eax = n_tlhs;
    eax <<= 4;
    eax = tlhs;
    ecx <<= 4;
    ecx += obj.quotient;
    memmove (ecx, eax, eax);
    eax = n_tlhs;
    *(obj.n_quotient) += eax;
    eax = n_trhs;
    edx = n_trhs;
    edx += *(obj.n_tlhs);
    edx += 2;
    edx += *(obj.n_divisor);
    if (edx > *(obj.n_tokens)) {
        goto label_2;
    }
    ecx = *((ebp - 0x1c));
    esi = *((ebp - 0x1c));
    esi += *((ebp - 0x20));
    edx = trhs;
    eax -= esi;
    eax <<= 4;
    esi <<= 4;
    esi = edx + esi;
    ecx <<= 4;
    eax = ecx + edx + 0x10;
    memmove (eax, esi, eax);
    eax = n_trhs;
    eax++;
    eax -= *((ebp - 0x20));
    *(obj.n_trhs) = eax;
    eax = trhs;
    edx = *((ebp - 0x1c));
    edx <<= 4;
    ecx = zero_token;
    *((edx + eax)) = ecx;
    ecx = .comment;
    *((edx + eax + 4)) = ecx;
    ecx = .comment;
    *((edx + eax + 8)) = ecx;
    ecx = .comment;
    *((edx + eax + 0xc)) = ecx;
    edx = n_trhs;
    if (edx <= 0) {
        goto label_11;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.trhs);
        *((edx + 4))++;
        eax++;
        edx = n_trhs;
    } while (eax < edx);
label_11:
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 4)) = 1;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    if (ebx == 1) {
        edx = n_trhs;
        edx <<= 4;
        eax = trhs;
        *((edx + eax + 8)) = 2;
    } else {
        edx = n_trhs;
        edx <<= 4;
        eax = trhs;
        *((edx + eax + 8)) = 1;
    }
    eax = n_trhs;
    eax++;
    *(obj.n_trhs) = eax;
    edx = n_tlhs;
    edx <<= 4;
    edx = tlhs;
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, edx, edx);
    eax = n_trhs;
    ecx = n_trhs;
    ecx += *(obj.n_tlhs);
    *(obj.n_trhs) = ecx;
    if (eax >= ecx) {
        goto label_12;
    }
    edx = eax;
    edx <<= 4;
    do {
        ecx = edx;
        ecx += *(obj.trhs);
        *((ecx + 4))++;
        eax++;
        ecx = n_trhs;
        edx += 0x10;
    } while (eax < ecx);
label_12:
    ecx <<= 4;
    eax = trhs;
    *((ecx + eax + 4)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax)) = 2;
    edx = n_trhs;
    edx <<= 4;
    eax = trhs;
    *((edx + eax + 8)) = 3;
    ebx = n_trhs;
    ebx++;
    *(obj.n_trhs) = ebx;
    eax = *((ebp - 0x24));
    eax <<= 4;
    eax = ebx;
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, 0x816e5a0, eax);
    edx = *((ebp - 0x24));
    edx += *(obj.n_trhs);
    *(obj.n_trhs) = edx;
    eax = trhs;
    edx <<= 4;
    ecx = zero_token;
    *((edx + eax)) = ecx;
    ecx = .comment;
    *((edx + eax + 4)) = ecx;
    ecx = .comment;
    *((edx + eax + 8)) = ecx;
    ecx = .comment;
    *((edx + eax + 0xc)) = ecx;
    eax = n_trhs;
    eax++;
    *(obj.n_trhs) = eax;
    edx = *((ebp - 0x28));
    edx += *((ebp - 0x24));
    ecx = n_divisor;
    ecx -= edx;
    ecx <<= 4;
    edx <<= 4;
    edx += obj.divisor;
    eax <<= 4;
    eax += *(obj.trhs);
    memmove (eax, edx, ecx);
    edx = n_trhs;
    edx += *(obj.n_divisor);
    edx -= *((ebp - 0x24));
    edx -= *((ebp - 0x28));
    *(obj.n_trhs) = edx;
    if (ebx >= edx) {
        goto label_13;
    }
    eax = ebx;
    eax <<= 4;
    do {
        edx = eax;
        edx += *(obj.trhs);
        *((edx + 4)) += 2;
        ebx++;
        edx = n_trhs;
        eax += 0x10;
    } while (ebx < edx);
label_13:
    *((esp + 0x10)) = 0;
    eax = trhs;
    list_debug (0, eax, edx);
    eax = trhs;
    uf_repeat (eax, 0x80798b4);
    eax = trhs;
    uf_tsimp (eax, 0x80798b4);
    *((esp + 0x10)) = 0;
    eax = n_trhs;
    eax = trhs;
    list_debug (0, eax, eax);
    eax = ebp - 0x2c;
    *((esp + 0x18)) = eax;
    edx = ebp - 0x20;
    *((esp + 0x14)) = edx;
    eax = ebp - 0x1c;
    *((esp + 0x10)) = eax;
    edx = ebp - 0x48;
    *((esp + 0xc)) = edx;
    eax = *((ebp + 0x18));
    *((esp + 8)) = eax;
    eax = n_trhs;
    *((esp + 4)) = eax;
    eax = trhs;
    *(esp) = eax;
    find_greatest_power ();
    *(fp_stack--) = *((ebp - 0x48));
    *(fp_stack--) = *((ebp - 0x40));
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        fp_stack++;
        eax = n_quotient;
        eax <<= 4;
        eax = tlhs;
        memmove (eax, 0x8083f80, eax);
        eax = n_quotient;
        *(obj.n_tlhs) = eax;
        *((esp + 0x10)) = 0;
        eax = tlhs;
        list_debug (0, eax, eax);
        *((esp + 0x10)) = 0;
        eax = n_trhs;
        eax = trhs;
        list_debug (0, eax, eax);
        eax = n_trhs;
        if (eax == 1) {
            edx = trhs;
            if (*(edx) != 0) {
                goto label_14;
            }
            *(fp_stack--) = *((edx + 8));
            ebx = 2;
            *(fp_stack--) = 0.0;
            fp_tmp_2 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_2;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] == fp_stack[1]) {
                goto label_14;
            }
            if (fp_stack[0] == fp_stack[1]) {
                goto label_15;
            }
        }
label_14:
        edx = *((ebp - 0xf4));
        edx += *((ebp - 0xf0));
        ecx = eax;
        ecx += *(obj.n_quotient);
        ebx = 1;
        if (edx > ecx) {
            goto label_15;
        }
        ecx = eax + 1;
        if (edx >= ecx) {
            goto label_16;
        }
        ebx = 0xfffffffe;
        if (eax > *(obj.n_divisor)) {
            goto label_15;
        }
        goto label_16;
    }
    *(fp_stack--) = *((ebp - 0x38));
    if (fp_stack[0] > fp_stack[1]) {
        fp_stack++;
        *((ebp - 0x38)) = fp_stack[0];
        fp_stack--;
        goto label_0;
    }
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_2;
    }
    if (eax < edi) {
        goto label_0;
    }
    goto label_2;
label_4:
    fp_stack++;
label_2:
    ebx = 0;
    goto label_15;
label_16:
    ebx = 0xffffffff;
label_15:
    eax = ebp - 0xe4;
    memmove (obj.jmp_save, eax, 0x9c);
    edx = *((ebp - 0xec));
    *(obj.partial_flag) = edx;
label_1:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8060c10 */
#include <stdint.h>
 
int32_t dbg_factor_plus (void) {
    token_type * equation;
    int * np;
    long int v;
    double d;
    int32_t var_4h;
    int32_t var_10h;
    int32_t var_14h;
    /* int factor_plus(token_type * equation,int * np,long int v,double d); */
    *((esp + 0x14)) = 0;
    *((esp + 0x10)) = 0;
    *(fp_stack--) = *((ebp + 0x14));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x10));
    *((esp + 4)) = eax;
    *(esp) = 1;
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    fplus_recurse ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804f53b */
#include <stdint.h>
 
int32_t dbg_read_examples (char * cp) {
    char ** cpp;
    ebx = cp;
    /* int read_examples(char ** cpp); */
    esi = *((ebp + 8));
    eax = *(esi);
    if (eax == 0) {
        goto label_0;
    }
    do {
        *(esp) = eax;
        eax = strdup ();
        ebx = eax;
        eax = display_process (eax);
        if (eax == 0) {
            goto label_1;
        }
        free (ebx);
        eax = *((esi + 4));
        esi += 4;
    } while (eax != 0);
label_0:
    eax = 1;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804b1c1 */
#include <stdint.h>
 
uint32_t dbg_check_err (void) {
    int32_t var_4h;
    /* void check_err(); */
    eax = errno_location ();
    edx = *(eax);
    if (edx != 0x21) {
        if (edx != 0x22) {
            goto label_0;
        }
    } else {
        *(eax) = 0;
        if (*(obj.domain_check) != 0) {
            *(obj.domain_check) = 0;
            goto label_0;
        }
        *(esp) = "Domain error in constant.";
        error ();
        *((esp + 4)) = 2;
        *(esp) = obj.jmp_save;
        longjmp_chk ();
    }
    *(eax) = 0;
    *(esp) = "Overflow error in constant.";
    error ();
    *((esp + 4)) = 2;
    *(esp) = obj.jmp_save;
    longjmp_chk ();
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804abac */
#include <stdint.h>
 
uint32_t dbg_get_screen_size (void) {
    winsize ws;
    uint32_t request;
    int32_t var_8h;
    /* void get_screen_size(); */
    *(ws.ws_row) = 0;
    *((ebp - 0x10)) = 0;
    eax = ebp - 0x10;
    *((esp + 8)) = eax;
    eax = ioctl (1, 0x5413);
    if (eax >= 0) {
        eax = *(ws.ws_row);
        if (ax != 0) {
            eax = (int32_t) ax;
            *(obj.screen_columns) = eax;
        }
        eax = *((ebp - 0x10));
        if (ax == 0) {
            goto label_0;
        }
        eax = (int32_t) ax;
        *(obj.screen_rows) = eax;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804aaa1 */
#include <stdint.h>
 
int32_t dbg_alloc_espace (int32_t arg_8h, int32_t i) {
    int32_t var_8h;
    int32_t var_4h;
    ebx = i;
    /* int alloc_espace(int i); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    ebx = *((ebp + 8));
    if (ebx <= 0x63) {
        if (*((ebx*4 + obj.lhs)) != 0) {
            if (*((ebx*4 + obj.rhs)) != 0) {
                goto label_0;
            }
        }
        eax = n_tokens;
        eax <<= 4;
        eax = malloc (eax);
        *((ebx*4 + obj.lhs)) = eax;
        if (eax != 0) {
            eax = n_tokens;
            eax <<= 4;
            eax = malloc (eax);
            *((ebx*4 + obj.rhs)) = eax;
            if (eax != 0) {
                goto label_0;
            }
            esi = lhs;
            eax = *((esi + ebx*4));
            free (eax);
            *((esi + ebx*4)) = 0;
            eax = 0;
        }
    } else {
        eax = 0;
        goto label_1;
label_0:
        eax = 1;
    }
label_1:
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057973 */
#include <stdint.h>
 
int32_t dbg_read_file (int32_t arg_8h, char * cp, char * __s, int32_t rv) {
    char[4096] buf;
    int32_t canary;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * mode;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = cp;
    esi = __s;
    edi = rv;
    /* int read_file(char * cp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    if (*(ebx) == 0) {
        *(esp) = "No file name specified.";
        error ();
        eax = 0;
    } else {
        esi = ebp - 0x101c;
        *((esp + 0x14)) = ebx;
        *((esp + 0x10)) = "%s.in";
        *((esp + 0xc)) = 0x1000;
        *((esp + 8)) = 1;
        *((esp + 4)) = 0x1000;
        *(esp) = esi;
        snprintf_chk ();
        eax = fopen (esi, 0x80729f4);
        esi = eax;
        if (eax == 0) {
            eax = fopen (ebx, 0x80729f4);
            esi = eax;
            if (eax == 0) {
                *(esp) = "Can't open input file.";
                error ();
                eax = 0;
            } else {
                ebx = ebp - 0x101c;
            }
            eax = read_sub (esi);
            edi = eax;
            if (eax != 0) {
                *((esp + 4)) = "Read operation aborted.\n";
                *(esp) = 1;
                printf_chk ();
            } else {
                if (*(obj.quiet_mode) != 0) {
                    goto label_0;
                }
                *((esp + 8)) = ebx;
                *((esp + 4)) = "Finished reading file \"%s\".\n";
                *(esp) = 1;
                printf_chk ();
            }
label_0:
            fclose (esi);
            al = (edi == 0) ? 1 : 0;
            eax = (int32_t) al;
        }
    }
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (edi != 0) {
        stack_chk_fail ();
    }
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80643bf */
#include <stdint.h>
 
int32_t dbg_is_integer_expr (void * arg_ch, int32_t i, int32_t n) {
    token_type * p1;
    esi = i;
    edi = n;
    /* int is_integer_expr(token_type * p1,int n); */
    edi = *((ebp + 0xc));
    if (edi <= 0) {
        goto label_1;
    }
    ebx = *((ebp + 8));
    esi = 0;
label_0:
    eax = *(ebx);
    if (eax == 1) {
        goto label_2;
    }
    if (eax >= 1) {
        if (eax != 2) {
            goto label_3;
        }
        if (*((ebx + 8)) != 4) {
            goto label_3;
        }
        goto label_4;
    }
    *(fp_stack--) = *((ebx + 8));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*((ebx + 8)) == 4);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_5;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_6;
label_5:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_6:
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] == fp_stack[1]) {
        goto label_4;
    }
    if (fp_stack[0] != fp_stack[1]) {
        goto label_4;
label_2:
        eax = *((ebx + 8));
        eax = is_integer_var (eax);
        if (eax != 0) {
            goto label_3;
        }
        eax = *((ebx + 8));
        eax &= 0x3fff;
        if (eax != 4) {
            goto label_4;
        }
    }
label_3:
    esi++;
    ebx += 0x10;
    if (edi > esi) {
        goto label_0;
    }
    goto label_1;
label_4:
    eax = 0;
    goto label_7;
label_1:
    eax = 1;
label_7:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8061f1b */
#include <stdint.h>
 
int32_t dbg_unsimp_power (int32_t j, int32_t i) {
    int32_t var_2ch;
    int32_t var_28h;
    int32_t modified;
    int32_t var_20h;
    int32_t var_1ch;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    edx = j;
    eax = i;
    /* int unsimp_power(token_type * equation,int * np); */
    eax = *((ebp + 0xc));
    edi = *(eax);
    *((ebp - 0x24)) = 0;
    if (edi <= 1) {
        goto label_1;
    }
    ebx = *((ebp + 8));
    ebx += 0x20;
    esi = 0xffffffff;
label_0:
    if (*((ebx - 8)) != 6) {
        goto label_2;
    }
    edx = *((ebx - 0xc));
    *((ebp - 0x1c)) = edx;
    if (edx == *((ebx + 4))) {
        if (*(ebx) == 0) {
            goto label_2;
        }
    }
    edx = esi;
    if (esi < 0) {
        goto label_3;
    }
    eax = ebx - 0x30;
    *((ebp - 0x20)) = eax;
    ecx = *((ebx - 0x2c));
    if (*((ebp - 0x1c)) <= ecx) {
        goto label_4;
    }
    while (edx >= 0) {
        edi = eax;
        ecx = *((eax + 4));
        eax -= 0x20;
        if (ebx > ecx) {
            ebx = *((ebp - 0x20));
            *((ebp - 0x20)) = edi;
            edi = *((ebp - 0x28));
            eax = *((ebp - 0x1c));
            eax--;
            if (ecx != eax) {
                goto label_3;
            }
            edx = *((ebp - 0x20));
            if (*((edx + 8)) != 4) {
                goto label_3;
            }
            goto label_5;
label_4:
            eax = ebx - 0x50;
            *((ebp - 0x20)) = ebx;
            *((ebp - 0x28)) = edi;
            ebx = *((ebp - 0x1c));
        }
        edx -= 2;
    }
    ebx = *((ebp - 0x20));
    goto label_3;
label_5:
    edi += 2;
    if (edi > *(obj.n_tokens)) {
        error_huge ();
    }
    eax = *((ebp - 0x20));
    *((eax + 8)) = 3;
    edx = esi + 3;
    *((ebp - 0x20)) = edx;
    eax = *((ebp + 0xc));
    edi = *(eax);
    if (edi <= edx) {
        goto label_6;
    }
    *((ebp - 0x28)) = ebx;
    edx = *((ebx + 4));
    if (*((ebp - 0x1c)) > edx) {
        goto label_6;
    }
    eax = ebx + 0x10;
    ecx = *((ebp - 0x20));
    *((ebp - 0x2c)) = ebx;
    *((ebp - 0x28)) = esi;
    esi = *((ebp + 0xc));
    while (edi > ecx) {
        ebx = eax;
        edx = *((eax + 4));
        eax += 0x10;
        if (*((ebp - 0x1c)) > edx) {
            goto label_7;
        }
        edx++;
        *((ebx + 4)) = edx;
        ecx++;
        edi = *(esi);
    }
    ebx = *((ebp - 0x2c));
    esi = *((ebp - 0x28));
    goto label_6;
label_7:
    ebx = *((ebp - 0x2c));
    esi = *((ebp - 0x28));
label_6:
    edi -= *((ebp - 0x20));
    eax = edi;
    eax <<= 4;
    eax = ebx + 0x20;
    memmove (eax, ebx, eax);
    edx = *((ebp + 0xc));
    *(edx) += 2;
    eax = *((ebp - 0x1c));
    eax++;
    *((ebx + 4)) = eax;
    *(ebx) = 0;
    *(fp_stack--) = 1.0;
    fp_stack[0] = -fp_stack[0];
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    *((ebx + 0x14)) = eax;
    *((ebx + 0x10)) = 2;
    *((ebx + 0x18)) = 3;
    eax = 1;
    goto label_8;
label_3:
    eax = 0;
label_8:
    *((ebp - 0x24)) |= eax;
label_2:
    eax = esi + 4;
    edx = *((ebp + 0xc));
    edi = *(edx);
    esi += 2;
    ebx += 0x20;
    if (edi > eax) {
        goto label_0;
    }
label_1:
    eax = *((ebp - 0x24));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ab33 */
#include <stdint.h>
 
int32_t dbg_clean_up (int32_t i) {
    eax = i;
    /* void clean_up(); */
    init_gvars ();
    eax = gfp;
    if (eax != *(obj.default_out)) {
        if (eax != *(obj.stdout)) {
            if (eax == *(obj.stderr)) {
                goto label_0;
            }
            fclose (eax);
        }
label_0:
        eax = default_out;
        *(obj.gfp) = eax;
    }
    ebx = n_equations;
    if (ebx <= 0) {
        goto label_1;
    }
    eax = 0;
    edx = n_lhs;
    edi = n_rhs;
    do {
        if (*((edx + eax*4)) <= 0) {
            *((edx + eax*4)) = 0;
            *((edi + eax*4)) = 0;
        }
        eax++;
    } while (eax != ebx);
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8063406 */
#include <stdint.h>
 
int32_t dbg_poly_in_v (char * arg_14h, int32_t j, int32_t k, int32_t level) {
    int32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t vlevel;
    int32_t count;
    int32_t var_20h;
    int32_t i;
    token_type * p1;
    int32_t n;
    long int v;
    int32_t var_4h;
    esi = j;
    edi = k;
    eax = level;
    /* int poly_in_v(token_type * p1,int n,long int v,int allow_divides); */
    eax = *((ebp + 8));
    *((ebp - 0x20)) = eax;
    esi = 0;
    *((ebp - 0x1c)) = 1;
label_1:
    edx = *((ebp + 0xc));
    if (*((ebp - 0x1c)) < edx) {
        edi = *((ebp - 0x20));
        if (*((edi + 0x14)) != 1) {
            goto label_2;
        }
        eax = *((edi + 0x18));
        eax--;
        if (eax > 1) {
            goto label_2;
        }
    }
    ebx = *((ebp - 0x1c));
    ebx -= esi;
    esi <<= 4;
    esi += *((ebp + 8));
    *((esp + 4)) = ebx;
    eax = min_level (esi);
    if (ebx <= 0) {
        goto label_3;
    }
    edx = esi;
    ecx = 1;
    *((ebp - 0x24)) = 0;
    edi = eax + 1;
    *((ebp - 0x30)) = edi;
    *((ebp - 0x2c)) = esi;
label_0:
    if (*(edx) != 1) {
        goto label_4;
    }
    esi = *((ebp + 0x10));
    if (esi != *((edx + 8))) {
        goto label_4;
    }
    *((ebp - 0x24))++;
    if (*((ebp - 0x24)) > 1) {
        goto label_5;
    }
    edi = *((edx + 4));
    *((ebp - 0x28)) = edi;
    if (eax != edi) {
        esi = *((ebp - 0x30));
        if (edi != esi) {
            goto label_5;
        }
    }
    if (ebx <= 1) {
        goto label_6;
    }
    edi = *((ebp - 0x2c));
    *((ebp - 0x3c)) = edi;
    edi = 1;
    esi = ecx - 2;
    *((ebp - 0x34)) = esi;
    *((ebp - 0x38)) = edx;
    esi = *((ebp - 0x3c));
    do {
        if (eax == *((esi + 0x14))) {
            edx = *((esi + 0x18));
            if (edx != 4) {
                if (edx != 6) {
                    if (edx != 3) {
                        goto label_5;
                    }
                } else {
                    if (*((ebp + 0x14)) != 0) {
                        goto label_7;
                    }
                    if (*((ebp - 0x34)) != edi) {
                        goto label_7;
                    }
                    goto label_5;
                }
                if (ecx != edi) {
                    goto label_5;
                }
            }
        }
label_7:
        edi += 2;
        esi += 0x20;
    } while (ebx > edi);
    edx = *((ebp - 0x38));
label_6:
    edi = *((ebp - 0x30));
    if (*((ebp - 0x28)) == edi) {
        if (ebx <= ecx) {
            goto label_5;
        }
        esi = *((ebp - 0x28));
        if (esi != *((edx + 0x14))) {
            goto label_5;
        }
        if (*((edx + 0x18)) != 6) {
            goto label_5;
        }
    }
label_4:
    edx += 0x20;
    ecx += 2;
    esi = ecx - 1;
    if (esi < ebx) {
        goto label_0;
    }
label_3:
    edi = *((ebp + 0xc));
    if (*((ebp - 0x1c)) >= edi) {
        eax = 1;
    } else {
        esi = *((ebp - 0x1c));
        esi++;
label_2:
        *((ebp - 0x1c)) += 2;
        *((ebp - 0x20)) += 0x20;
        goto label_1;
label_5:
        eax = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a35b */
#include <stdint.h>
 
int32_t dbg_exp_is_numeric (char * arg_ch, int32_t i, int32_t n1) {
    token_type * p1;
    ecx = i;
    edx = n1;
    /* int exp_is_numeric(token_type * p1,int n1); */
    ecx = *((ebp + 0xc));
    if (ecx <= 0) {
        goto label_0;
    }
    eax = *((ebp + 8));
    edx = 0;
    do {
        if (*(eax) == 1) {
            ebx = *((eax + 8));
            ebx &= 0x3fff;
            if (ebx <= 4) {
                goto label_1;
            }
            eax = 0;
            goto label_2;
        }
label_1:
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
label_0:
    eax = 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8050428 */
#include <stdint.h>
 
uint32_t dbg_set_error_level (char * s1, char * cp1) {
    char * s2;
    esi = cp1;
    /* void set_error_level(char * cp); */
    esi = *((ebp + 8));
    *(obj.point_flag) = 1;
    eax = strpbrk (esi, 0x8075188);
    if (eax != 0) {
        *(eax) = 0;
    }
    remove_trailing_spaces (esi);
    ebx = *(esi);
    if (bl == 0) {
        goto label_0;
    }
    eax = ctype_b_loc ();
    do {
        ebx = (int32_t) bl;
        edx = *(eax);
        if ((*((edx + ebx*2 + 1)) & 0x40) == 0) {
            *(obj.point_flag) = 0;
        }
        esi++;
        ebx = *(esi);
    } while (bl != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8052868 */
#include <stdint.h>
 
uint32_t dbg_replace_cmd (long int v, int32_t found, int32_t vc, char * cp1) {
    int32_t var_fdch;
    int32_t var_fd8h;
    int32_t var_fd4h;
    int32_t i;
    long int last_v;
    long int[1000] va;
    int32_t var_1ch;
    char * cp;
    char * s2;
    size_t * n;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = v;
    ecx = found;
    edi = vc;
    eax = cp1;
    /* int replace_cmd(char * cp); */
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_2;
    }
    eax = cur_equation;
    *((ebp - 0xfd0)) = eax;
    edx = *((ebp + 8));
    if (*(edx) == 0) {
        *((ebp - 0xfdc)) = edx;
        edi = 0;
        goto label_3;
    }
    ebx = ebp - 0xfbc;
    eax = *((ebp + 8));
    edi = 0;
    esi = eax;
    do {
        *((esp + 4)) = "with";
        eax = strcmp_tospace (esi);
        if (eax == 0) {
            *((ebp - 0xfdc)) = esi;
            if (edi != 0) {
                goto label_3;
            }
            *(esp) = "No variables specified.";
            error ();
            eax = 0;
            goto label_4;
        }
        if (edi == 0x3e8) {
            *(esp) = "Too many variables specified.";
            error ();
            eax = 0;
            goto label_4;
        }
        eax = parse_var2 (ebx, esi);
        esi = eax;
        if (eax == 0) {
            goto label_2;
        }
        eax = *(ebx);
        edx = *((ebp - 0xfd0));
        eax = var_in_equation (edx, eax);
        if (eax == 0) {
            *(esp) = "Variable not found.";
            error ();
            eax = 0;
            goto label_4;
        }
        edi++;
        ebx += 4;
    } while (*(esi) != 0);
    *((ebp - 0xfdc)) = esi;
label_3:
    edx = *((ebp - 0xfd0));
    eax = *((edx*4 + obj.n_lhs));
    *(obj.n_tlhs) = eax;
    eax <<= 4;
    eax = *((edx*4 + obj.lhs));
    eax = tlhs;
    memmove (eax, eax, eax);
    edx = *((ebp - 0xfd0));
    eax = *((edx*4 + obj.n_rhs));
    *(obj.n_trhs) = eax;
    eax <<= 4;
    eax = *((edx*4 + obj.rhs));
    eax = trhs;
    memmove (eax, eax, eax);
    *((ebp - 0xfcc)) = 0;
    esi = ebp - 0xfbc;
    goto label_5;
label_0:
    *((ebp - 0xfcc)) = ebx;
label_5:
    eax = *((ebp - 0xfd0));
    edx = n_lhs;
    eax = *((edx + eax*4));
    *((ebp - 0xfd4)) = eax;
    ebx = 0xffffffff;
    if (eax <= 0) {
        goto label_6;
    }
    edx = *((ebp - 0xfd0));
    eax = *((edx*4 + obj.lhs));
    ecx = 0xffffffff;
    edx = 0;
    *((ebp - 0xfd8)) = edi;
    edi = *((ebp - 0xfd4));
    do {
        if (*(eax) == 1) {
            ebx = *((eax + 8));
            if (*((ebp - 0xfcc)) < ebx) {
                if (ecx == -1) {
                    goto label_7;
                }
                if (ebx > ecx) {
                    ebx = ecx;
                }
            }
        } else {
            ebx = ecx;
        }
label_7:
        edx += 2;
        eax += 0x20;
        if (edx >= edi) {
            goto label_8;
        }
        ecx = ebx;
    } while (1);
label_8:
    edi = *((ebp - 0xfd8));
label_6:
    eax = *((ebp - 0xfd0));
    ecx = *((eax*4 + obj.n_rhs));
    if (ecx <= 0) {
        goto label_9;
    }
    eax = *((eax*4 + obj.rhs));
    edx = 0;
    *((ebp - 0xfd4)) = edi;
    edi = ecx;
    do {
        if (*(eax) == 1) {
            ecx = *((eax + 8));
            if (*((ebp - 0xfcc)) < ecx) {
                if (ebx == -1) {
                    goto label_10;
                }
                if (ecx > ebx) {
                    ecx = ebx;
                }
            }
        } else {
            ecx = ebx;
        }
label_10:
        edx += 2;
        eax += 0x20;
        if (edi <= edx) {
            goto label_11;
        }
        ebx = ecx;
    } while (1);
label_11:
    edi = *((ebp - 0xfd4));
    ebx = ecx;
label_9:
    if (ebx == -1) {
        eax = 0;
        if (*(obj.n_tlhs) > 0) {
            goto label_12;
        }
        goto label_13;
    }
    if (edi == 0) {
        goto label_14;
    }
    if (edi <= 0) {
        goto label_0;
    }
    edx = 0;
    eax = 0;
    ecx = 1;
    do {
        if (*((esi + eax*4)) == ebx) {
            edx = ecx;
        }
        eax++;
    } while (eax != edi);
    if (edx == 0) {
        goto label_0;
    }
    eax = *((ebp - 0xfdc));
    if (*(eax) != 0) {
        *((esp + 4)) = "with";
        eax = strcmp_tospace (eax);
        if (eax != 0) {
            goto label_2;
        }
        edx = *((ebp - 0xfdc));
        eax = skip_param (edx);
        edx = eax;
        edx -= *((ebp + 8));
        *(obj.input_column) += edx;
        *((esp + 8)) = eax;
        eax = ebp - 0x1c;
        eax = scratch;
        eax = parse_expr (eax, eax);
        if (eax == 0) {
            goto label_2;
        }
        if (*((ebp - 0x1c)) > 0) {
            goto label_15;
        }
        goto label_2;
label_1:
        edx = *((ebp - 0x1c));
        if (edx > 0) {
            goto label_15;
        }
        goto label_16;
    }
label_14:
    list_var (ebx, 0);
    *((esp + 0x14)) = 0x8079800;
    *((esp + 0x10)) = "Enter %s: ";
    *((esp + 0xc)) = 0x50;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x50;
    *(esp) = obj.prompt_str;
    snprintf_chk ();
    edx = ebp - 0x1c;
    eax = scratch;
    eax = get_expr (eax, edx);
    if (eax == 0) {
        goto label_0;
    }
    goto label_1;
label_15:
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.scratch);
        if (*(edx) == 1) {
            edx + 8 = -edx + 8;
        }
        eax += 2;
        edx = *((ebp - 0x1c));
    } while (edx > eax);
label_16:
    *((esp + 0x10)) = ebx;
    *((esp + 0xc)) = edx;
    eax = scratch;
    *((esp + 8)) = eax;
    *((esp + 4)) = 0x80796b8;
    eax = tlhs;
    subst_var_with_exp (eax);
    *((esp + 0x10)) = ebx;
    eax = *((ebp - 0x1c));
    *((esp + 0xc)) = eax;
    eax = scratch;
    *((esp + 8)) = eax;
    *((esp + 4)) = 0x80798b4;
    eax = trhs;
    eax = subst_var_with_exp (eax);
    goto label_0;
    do {
label_12:
        edx = eax;
        edx <<= 4;
        edx += *(obj.tlhs);
        if (*(edx) == 1) {
            ecx = *((edx + 8));
            if (ecx >= 0) {
                goto label_17;
            }
            ecx = -ecx;
            *((edx + 8)) = ecx;
        }
label_17:
        eax += 2;
    } while (*(obj.n_tlhs) > eax);
label_13:
    if (*(obj.n_trhs) <= 0) {
        goto label_18;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.trhs);
        if (*(edx) == 1) {
            ecx = *((edx + 8));
            if (ecx >= 0) {
                goto label_19;
            }
            ecx = -ecx;
            *((edx + 8)) = ecx;
        }
label_19:
        eax += 2;
    } while (*(obj.n_trhs) > eax);
label_18:
    eax = n_tlhs;
    edx = *((ebp - 0xfd0));
    *((edx*4 + obj.n_lhs)) = eax;
    eax <<= 4;
    eax = tlhs;
    eax = *((edx*4 + obj.lhs));
    memmove (eax, eax, eax);
    eax = n_trhs;
    edx = *((ebp - 0xfd0));
    *((edx*4 + obj.n_rhs)) = eax;
    eax <<= 4;
    eax = trhs;
    eax = *((edx*4 + obj.rhs));
    memmove (eax, eax, eax);
    eax = *((ebp - 0xfd0));
    simp_equation (eax);
    edx = *((ebp - 0xfd0));
    return_result (edx);
    goto label_4;
label_2:
    eax = 0;
label_4:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80566a8 */
#include <stdint.h>
 
uint32_t dbg_optimize_cmd (int32_t rv, int32_t j) {
    int32_t k;
    int32_t flag;
    int32_t var_50h;
    int32_t start_en;
    int32_t var_48h;
    int32_t var_44h;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    uint32_t var_30h;
    int32_t var_2ch;
    int32_t stop;
    int32_t start;
    char * cp;
    int32_t var_4h;
    int32_t var_8h;
    ebx = rv;
    esi = j;
    /* int optimize_cmd(char * cp); */
    eax = ebp - 0x20;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range_eol (eax, eax, eax);
    ebx = 0;
    if (eax == 0) {
        goto label_9;
    }
    *(obj.opt_en) = 0xffffffff;
    ebx = *((ebp - 0x1c));
    esi = ebx*4 + obj_n_lhs;
    eax = ebx;
    while (ebx <= *((ebp - 0x20))) {
        if (*(esi) != 0) {
            simp_equation (ebx);
            eax = ebx;
        }
        ebx++;
        esi += 4;
    }
    *((ebp - 0x20)) = eax;
    *((ebp - 0x34)) = 0;
label_2:
    ebx = *((ebp - 0x1c));
    eax = ebx*4;
    edi = eax + obj_rhs;
    eax += obj.n_rhs;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x54)) = 0;
    goto label_10;
label_1:
    esi = *((ebp - 0x1c));
    edx = *((ebp - 0x2c));
    *((ebp - 0x30)) = edx;
    goto label_11;
label_0:
    if (ebx == esi) {
        goto label_12;
    }
    do {
        ecx = esi;
        edx = *((ebp - 0x30));
        eax = *(edi);
        eax = find_more ();
        if (eax == 0) {
            goto label_12;
        }
        *((ebp - 0x54)) = 1;
        *((ebp - 0x34)) = 1;
    } while (1);
label_12:
    esi++;
label_11:
    if (esi <= *((ebp - 0x20))) {
        goto label_0;
    }
    ebx++;
    edi += 4;
    *((ebp - 0x2c)) += 4;
label_10:
    if (ebx <= *((ebp - 0x20))) {
        goto label_1;
    }
    if (*((ebp - 0x54)) != 0) {
        goto label_2;
    }
    ecx = *((ebp - 0x1c));
    *((ebp - 0x2c)) = ecx;
    eax = ecx;
    eax <<= 2;
    esi = eax + obj_n_lhs;
    *((ebp - 0x48)) = esi;
    edx = eax + obj_rhs;
    *((ebp - 0x44)) = edx;
    ecx = eax + obj_n_rhs;
    *((ebp - 0x40)) = ecx;
    eax += obj.lhs;
    *((ebp - 0x3c)) = eax;
    *((ebp - 0x50)) = esi;
    *((ebp - 0x4c)) = 0;
    edi = rhs;
    goto label_13;
label_8:
    esi = *((ebp - 0x48));
    if (*(esi) == 0) {
        goto label_14;
    }
    eax = *((ebp - 0x50));
    *((ebp - 0x38)) = eax;
label_4:
    edx = *((ebp - 0x2c));
    eax = simp_equation (edx);
    ecx = *((ebp - 0x54));
    *((ebp - 0x30)) = ecx;
    esi = 0;
    goto label_15;
label_3:
    simp_equation (eax);
    eax = *((ebp - 0x2c));
    if (*((ebx*4 + obj.opt_en)) == eax) {
        goto label_16;
    }
    *((ebp - 0x58)) = esi;
    do {
        ecx = *((ebx*4 + obj.opt_en));
        edx = *((ebp - 0x38));
        esi = *((ebp - 0x3c));
        eax = *(esi);
        eax = find_more ();
        if (eax == 0) {
            goto label_17;
        }
        *((ebp - 0x30)) = 1;
    } while (1);
    do {
        *((ebp - 0x30)) = 1;
label_17:
        ecx = *((ebx*4 + obj.opt_en));
        edx = *((ebp - 0x40));
        esi = *((ebp - 0x44));
        eax = *(esi);
        eax = find_more ();
    } while (eax != 0);
    esi = *((ebp - 0x58));
label_16:
    esi++;
label_15:
    ebx = esi;
    eax = *((esi*4 + obj.opt_en));
    if (eax >= 0) {
        goto label_3;
    }
    if (*((ebp - 0x30)) != 0) {
        goto label_4;
    }
    ebx = 1;
    do {
        edx = *((ebp - 0x38));
        ecx = *((ebp - 0x3c));
        eax = *(ecx);
        eax = opt_es ();
        if (eax == 0) {
            goto label_18;
        }
        *((ebp - 0x34)) = ebx;
    } while (1);
    do {
        *((ebp - 0x34)) = ebx;
        goto label_19;
label_18:
        ebx = 1;
label_19:
        edx = *((ebp - 0x40));
        esi = *((ebp - 0x44));
        eax = *(esi);
        eax = opt_es ();
    } while (eax != 0);
    if (*((ebp - 0x34)) == 0) {
        goto label_14;
    }
    eax = *((ebp - 0x4c));
    eax = eax*4 + obj_opt_en;
    *((ebp - 0x38)) = eax;
    *((ebp - 0x30)) = eax;
    goto label_20;
label_6:
    eax++;
    *((ebp - 0x58)) = eax;
    if (*((esi + 4)) < 0) {
        goto label_21;
    }
    ebx = eax*4 + obj_opt_en;
    do {
label_5:
        eax = *(ebx);
        edx = eax*4 + obj_n_rhs;
        eax = *((edi + eax*4));
        ecx = *(esi);
        eax = find_more ();
    } while (eax != 0);
    do {
        eax = *(esi);
        edx = eax*4 + obj_n_rhs;
        eax = *((edi + eax*4));
        ecx = *(ebx);
        eax = find_more ();
    } while (eax != 0);
    eax = *((ebx + 4));
    ebx += 4;
    if (eax >= 0) {
        goto label_5;
    }
label_21:
    esi += 4;
    eax = *((ebp - 0x58));
label_7:
    if (*(esi) >= 0) {
        goto label_6;
    }
    ebx = *((ebp - 0x30));
    do {
        eax = *(ebx);
        edx = eax*4 + obj_n_rhs;
        eax = *((edi + eax*4));
        eax = opt_es ();
    } while (eax != 0);
    *((ebp - 0x30)) += 4;
label_20:
    edx = *((ebp - 0x30));
    if (*(edx) < 0) {
        goto label_22;
    }
    esi = *((ebp - 0x38));
    eax = *((ebp - 0x4c));
    goto label_7;
    do {
        list_sub (eax);
        *((ebp - 0x4c))++;
        goto label_23;
label_22:
        ebx = *((ebp - 0x38));
label_23:
        eax = *(ebx);
        ebx += 4;
    } while (eax >= 0);
    ecx = *((ebp - 0x2c));
    list_sub (ecx);
label_14:
    *((ebp - 0x2c))++;
    *((ebp - 0x48)) += 4;
    *((ebp - 0x44)) += 4;
    *((ebp - 0x40)) += 4;
    *((ebp - 0x3c)) += 4;
    *((ebp - 0x50)) += 4;
label_13:
    esi = *((ebp - 0x2c));
    if (esi <= *((ebp - 0x20))) {
        goto label_8;
    }
    ebx = *((ebp - 0x34));
    if (ebx == 0) {
        *(esp) = "Unable to find any repeated expressions.";
        error ();
    }
label_9:
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057638 */
#include <stdint.h>
 
int32_t dbg_plot_cmd (int32_t arg_8h, char * cp, int32_t free_cp) {
    char[4096] cl;
    int32_t var_ch;
    char * c;
    int32_t var_8h;
    int32_t var_sp_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = cp;
    esi = free_cp;
    /* int plot_cmd(char * cp); */
    ebx = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    if (*(obj.security_level) != 0) {
        *(esp) = "Command disabled.";
        error ();
        eax = 0;
        goto label_1;
    }
    eax = *(ebx);
    esi = 0;
    if (al == 0) {
        eax = current_not_defined ();
        if (eax != 0) {
            goto label_2;
        }
        eax = cur_equation;
        edx = *((eax*4 + obj.n_rhs));
        if (edx != 0) {
            eax = *((eax*4 + obj.rhs));
            eax = list_expression (eax, edx, 3);
            ebx = eax;
        } else {
            edx = *((eax*4 + obj.n_lhs));
            eax = *((eax*4 + obj.lhs));
            eax = list_expression (eax, edx, 3);
            ebx = eax;
        }
        if (ebx == 0) {
            goto label_2;
        }
        eax = *(ebx);
        if (al == 0) {
            goto label_3;
        }
        esi = 1;
    }
    if (al == 0x27) {
        goto label_4;
    }
    if (al == 0x5c) {
        goto label_4;
    }
    edx = ebx;
    do {
        edx++;
        eax = *(edx);
        if (al == 0) {
            goto label_0;
        }
        if (al == 0x27) {
            goto label_5;
        }
    } while (al != 0x5c);
    goto label_5;
label_3:
    esi = 1;
    while (edx != 0) {
        *(esp) = "Invalid character in expression string.";
        error ();
        if (esi != 0) {
            free (ebx);
            eax = 0;
            goto label_1;
label_0:
            eax = strchr (ebx, 0x79);
            if (eax != 0) {
                *((esp + 4)) = "Performing 3D surface plot...\n";
                *(esp) = 1;
                printf_chk ();
                *((esp + 0x14)) = ebx;
                *((esp + 0x10)) = "echo 'set grid; splot %s'|gnuplot -persist";
                *((esp + 0xc)) = 0x1000;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1000;
                eax = ebp - 0x100c;
                *(esp) = eax;
                snprintf_chk ();
            } else {
                *((esp + 4)) = "Performing 2D plot...\n";
                *(esp) = 1;
                printf_chk ();
                *((esp + 0x14)) = ebx;
                *((esp + 0x10)) = "echo 'set grid; plot %s'|gnuplot -persist";
                *((esp + 0xc)) = 0x1000;
                *((esp + 8)) = 1;
                *((esp + 4)) = 0x1000;
                eax = ebp - 0x100c;
                *(esp) = eax;
                snprintf_chk ();
            }
            if (esi != 0) {
                free (ebx);
            }
            eax = ebp - 0x100c;
            eax = shell_out (eax);
            if (eax != 0) {
                *(esp) = "Error trying to run gnuplot.";
                error ();
                eax = ebp - 0x100c;
                *((esp + 8)) = eax;
                *((esp + 4)) = "Command line = \"%s\".\n";
                *(esp) = 1;
                printf_chk ();
                eax = 0;
            } else {
                eax = 1;
            }
            if (*(obj.debug_level) <= 0) {
                goto label_1;
            }
            eax = ebp - 0x100c;
            *((esp + 8)) = eax;
            *((esp + 4)) = "Command line = \"%s\".\n";
            *(esp) = 1;
            printf_chk ();
            eax = 1;
        } else {
label_2:
            eax = 0;
        }
label_1:
        edx = *((ebp - 0xc));
        edx ^= *(gs:0x14);
        if (*(obj.debug_level) == 0) {
            goto label_6;
        }
        goto label_7;
label_4:
        edx = ebx;
label_5:
    }
    goto label_0;
label_7:
    stack_chk_fail ();
label_6:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804af06 */
#include <stdint.h>
 
int32_t dbg_get_default_en (int32_t i) {
    char * cp;
    int32_t var_4h;
    ebx = i;
    /* int get_default_en(char * cp); */
    eax = *((ebp + 8));
    if (*(eax) == 0) {
        ebx = cur_equation;
    } else {
        edx = ebp + 8;
        eax = decstrtol (eax, edx);
        ebx = eax;
        eax = *((ebp + 8));
        eax = extra_characters (eax);
        if (eax != 0) {
            goto label_0;
        }
        ebx--;
    }
    eax = not_defined (ebx);
    if (eax != 0) {
label_0:
        ebx = 0xffffffff;
    }
    eax = 0xffffffff;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80646fc */
#include <stdint.h>
 
int32_t dbg_find_greatest_power (int32_t i, int32_t level, int32_t was_power, int32_t divide_flag, int32_t k) {
    int32_t var_8ch;
    uint32_t var_84h;
    double d;
    int32_t var_74h;
    uint32_t var_70h;
    uint32_t var_6ch;
    long int v;
    int32_t rv;
    int32_t count;
    uint32_t var_5ch;
    int32_t div_level;
    int32_t j;
    int32_t var_50h;
    int32_t var_4ch;
    double[3] va;
    double[3] last_va;
    token_type * p1;
    int32_t n1;
    long int * vp1;
    double * pp1;
    int * tp1;
    int * lentp1;
    int * dcodep;
    void * s2;
    size_t n;
    int32_t var_ch;
    ebx = i;
    ecx = level;
    edx = was_power;
    edi = divide_flag;
    eax = k;
    /* int find_greatest_power(token_type * p1,int n1,long int * vp1,double * pp1,int * tp1,int * lentp1,int * dcodep); */
    edi = *((ebp + 8));
    esi = *((ebp + 0xc));
    ebx = ebp - 0x30;
    ecx = 0;
    edx = 0x18;
    eax = 0;
    do {
        *((ebx + eax)) = ecx;
        eax += 4;
    } while (eax < edx);
    *(fp_stack--) = 0.0;
    eax = *((ebp + 0x14));
    *(eax) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0x18));
    *(eax) = 0xffffffff;
    edx = *((ebp + 0x20));
    edx = *(edx);
    *((ebp - 0x64)) = edx;
    *((ebp - 0x5c)) = edi;
    *((ebp - 0x60)) = 0;
    ecx = 0;
    *((ebp - 0x68)) = 0;
    *((ebp - 0x58)) = 0;
    *((ebp - 0x4c)) = 0;
    *((ebp - 0x54)) = 0;
    ebx = 1;
    *((ebp - 0x8c)) = edi;
    *((ebp - 0x50)) = esi;
    esi = edi;
label_1:
    if (ebx < *((ebp - 0x50))) {
        eax = *((esi + 0x18));
        edx = eax - 1;
        if (edx > 1) {
            goto label_4;
        }
        if (*((esi + 0x14)) != 1) {
            goto label_4;
        }
    }
    if (ecx != 0) {
        goto label_5;
    }
    ecx = *((ebp + 0x14));
    *(fp_stack--) = *(ecx);
    *(fp_stack--) = 1.0;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] < fp_stack[1]) {
        goto label_5;
    }
    if (ebx <= *((ebp - 0x54))) {
        goto label_5;
    }
    eax = *((ebp - 0x54));
    *((ebp - 0x4c)) = 0;
    *((ebp - 0x5c)) = esi;
    esi = 0;
    *((ebp - 0x6c)) = esi;
    edi = *((ebp - 0x8c));
label_0:
    ecx = eax;
    ecx <<= 4;
    ecx = edi + ecx;
    edx = *(ecx);
    if (edx == 1) {
        edx = *((ebp + 0x20));
        esi = *(edx);
        if (esi <= 1) {
            if (*((ebp - 0x6c)) != esi) {
                goto label_6;
            }
        }
        esi = *((ebp + 0x10));
        edx = *(esi);
        if (edx != 0) {
            if (edx != *((ecx + 8))) {
                goto label_6;
            }
            eax = *((ebp - 0x6c));
            *((ebp - 0x4c)) = eax;
            esi = *((ebp - 0x5c));
            *((ebp - 0x8c)) = edi;
            edi = eax;
            edx = *((ebp - 0x54));
            *((esp + 0xc)) = edx;
            ecx = *((ebp - 0x50));
            *((esp + 8)) = ecx;
            eax = *((ebp - 0x8c));
            *((esp + 4)) = eax;
            edx = ebp - 0x48;
            *(esp) = edx;
            term_value ();
            ecx = *((ebp + 0x14));
            *(fp_stack--) = *(ecx);
            *(fp_stack--) = 1.0;
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            dl = (fp_stack[0] == fp_stack[1]) ? 1 : 0;
            __asm ("setnp al");
            edx &= eax;
            eax = *((ebp - 0x4c));
            al = (*((ebp - 0x64)) > eax) ? 1 : 0;
            eax = (int32_t) al;
            edx &= eax;
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] == fp_stack[1]) {
                if (fp_stack[0] != fp_stack[1]) {
                    if (*((ebp - 0x64)) != edi) {
                        goto label_7;
                    }
                    edi = *((ebp - 0x54));
                    ecx = *((ebp + 0x18));
                    al = (*(ecx) != edi) ? 1 : 0;
                    eax = (int32_t) al;
                    *((ebp - 0x60)) += eax;
                    *(fp_stack--) = *((ebp - 0x48));
                    *(fp_stack--) = *((ebp - 0x30));
                    fp_tmp_1 = fp_stack[1];
                    fp_stack[1] = fp_stack[0];
                    fp_stack[0] = fp_tmp_1;
                    if (fp_stack[0] == fp_stack[1]) {
                        if (fp_stack[0] != fp_stack[1]) {
                            fp_stack++;
                            fp_stack++;
                            *(fp_stack--) = *((ebp - 0x40));
                            *(fp_stack--) = *((ebp - 0x28));
                            fp_tmp_2 = fp_stack[1];
                            fp_stack[1] = fp_stack[0];
                            fp_stack[0] = fp_tmp_2;
                            if (fp_stack[0] == fp_stack[1]) {
                                if (fp_stack[0] != fp_stack[1]) {
                                    fp_stack++;
                                    fp_stack++;
                                    *(fp_stack--) = *((ebp - 0x38));
                                    *(fp_stack--) = *((ebp - 0x20));
                                    fp_tmp_3 = fp_stack[1];
                                    fp_stack[1] = fp_stack[0];
                                    fp_stack[0] = fp_tmp_3;
                                    if (fp_stack[0] != fp_stack[1]) {
                                        if (fp_stack[0] == fp_stack[1]) {
                                            goto label_8;
                                        }
                                        fp_tmp_4 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_4;
                                        fp_tmp_5 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_5;
                                        fp_tmp_6 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_6;
                                        fp_tmp_7 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_7;
                                        fp_tmp_8 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_8;
                                    } else {
                                    } else {
                                    } else {
                                    } else {
                                    } else {
                                        fp_tmp_9 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_9;
                                    }
                                }
                            }
                        }
                    }
                    fp_stack--;
                    fp_stack++;
                    if (fp_stack[0] > fp_stack[1]) {
                        goto label_9;
                    }
                }
            } else {
label_7:
                *(fp_stack--) = 1.0;
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] > fp_stack[1]) {
                    goto label_10;
                }
                if (edx != 0) {
                    goto label_10;
                }
                goto label_5;
label_8:
                fp_stack++;
                fp_stack++;
            }
            *(fp_stack--) = 1.0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] <= fp_stack[1]) {
                if (edx == 0) {
                    goto label_5;
                }
                goto label_2;
label_9:
                fp_stack++;
            }
label_2:
            eax = ebp - 0x48;
            edx = ebp - 0x30;
            memmove (edx, eax, 0x18);
            *(fp_stack--) = 1.0;
            ecx = *((ebp + 0x14));
            *(ecx) = fp_stack[0];
            fp_stack--;
            edx = *((ebp - 0x54));
            eax = *((ebp + 0x18));
            *(eax) = edx;
            ecx = *((ebp - 0x4c));
            *((ebp - 0x64)) = ecx;
            goto label_5;
        }
        esi = *((ebp - 0x6c));
        *((ebp - 0x4c)) = esi;
        esi = *((ebp - 0x5c));
        *((ebp - 0x8c)) = edi;
        ecx = *((ecx + 8));
        *((ebp - 0x68)) = ecx;
        *(fp_stack--) = 1.0;
        edi = *((ebp + 0x14));
        *(edi) = fp_stack[0];
        fp_stack--;
        edx = *((ebp - 0x54));
        eax = *((ebp + 0x18));
        *(eax) = edx;
        ecx = *((ebp - 0x4c));
        *((ebp - 0x64)) = ecx;
        goto label_5;
    }
    if (edx != 2) {
        goto label_6;
    }
    edx = *((ecx + 8));
    if (edx == 4) {
        if (*((ebp - 0x6c)) != 0) {
            esi = *((ebp - 0x58));
            if (esi <= *((ecx + 4))) {
                goto label_6;
            }
        }
        ecx = *((ecx + 4));
        *((ebp - 0x58)) = ecx;
        *((ebp - 0x6c)) = 1;
        goto label_6;
    }
    if (*((ebp - 0x6c)) != 0) {
        esi = *((ebp - 0x58));
        esi = 0;
        if (esi < *((ecx + 4))) {
            esi = *((ebp - 0x6c));
        }
        *((ebp - 0x6c)) = esi;
    }
    if (edx != 6) {
        goto label_6;
    }
    ecx = *((ecx + 4));
    *((ebp - 0x4c)) = ecx;
    edx = eax;
    edx <<= 4;
    edx = edi + edx + 0x24;
    esi = *((ebp - 0x6c));
    do {
        eax += 2;
        if (ebx <= eax) {
            goto label_11;
        }
        ecx = *(edx);
        edx += 0x20;
    } while (*((ebp - 0x4c)) < ecx);
label_11:
    *((ebp - 0x6c)) = esi;
    eax--;
label_6:
    eax++;
    if (ebx > eax) {
        goto label_0;
    }
    esi = *((ebp - 0x5c));
    *((ebp - 0x8c)) = edi;
label_5:
    if (ebx >= *((ebp - 0x50))) {
        goto label_12;
    }
    edi = ebx + 1;
    *((ebp - 0x54)) = edi;
    ecx = 0;
    *((ebp - 0x4c)) = 0;
    goto label_13;
label_4:
    edx = *((esi + 0x14));
    if (eax == 4) {
        if (*((ebp - 0x4c)) != 0) {
            if (edx >= *((ebp - 0x58))) {
                goto label_13;
            }
        }
        *((ebp - 0x58)) = edx;
        *((ebp - 0x4c)) = 1;
        goto label_13;
    }
    if (*((ebp - 0x4c)) != 0) {
        edi = 0;
        if (edx > *((ebp - 0x58))) {
            edi = *((ebp - 0x4c));
        }
        *((ebp - 0x4c)) = edi;
    }
    if (eax != 6) {
        goto label_13;
    }
    if (*((esi + 0x20)) != 0) {
        goto label_13;
    }
    eax = *((ebp + 0x10));
    eax = *(eax);
    *((ebp - 0x5c)) = eax;
    if (eax == 0) {
        if (*((esi + 0x24)) != edx) {
            goto label_13;
        }
    }
    edi = *((ebp + 0x20));
    eax = *(edi);
    if (eax <= 1) {
        if (*((ebp - 0x4c)) != eax) {
            goto label_13;
        }
    }
    *(fp_stack--) = *((esi + 0x28));
    *((ebp - 0x80)) = fp_stack[0];
    fp_stack--;
    eax = esi;
    edi = esi - 0xc;
    *((ebp - 0x74)) = edi;
    *((ebp - 0x70)) = esi;
    *((ebp - 0x84)) = ecx;
    ecx = ebx;
    *((ebp - 0x6c)) = ebx;
    ebx = *((ebp - 0x74));
    edi = *((ebp - 0x8c));
    do {
        if (*(eax) == 1) {
            if (*((ebp - 0x5c)) != 0) {
                esi = *((ebp - 0x5c));
                if (esi != *((eax + 8))) {
                    goto label_14;
                }
                esi = *((ebp - 0x70));
                ebx = *((ebp - 0x6c));
                *((ebp - 0x8c)) = edi;
                edi = *((ebp - 0x54));
                *((esp + 0xc)) = edi;
                eax = *((ebp - 0x50));
                *((esp + 8)) = eax;
                edx = *((ebp - 0x8c));
                *((esp + 4)) = edx;
                ecx = ebp - 0x48;
                *(esp) = ecx;
                term_value ();
                edi = *((ebp + 0x14));
                *(fp_stack--) = *(edi);
                *(fp_stack--) = *((ebp - 0x80));
                dl = (fp_stack[0] == fp_stack[1]) ? 1 : 0;
                __asm ("setnp al");
                edx &= eax;
                eax = *((ebp - 0x4c));
                al = (*((ebp - 0x64)) > eax) ? 1 : 0;
                eax = (int32_t) al;
                edx &= eax;
                fp_stack--;
                if (fp_stack[0] == fp_stack[1]) {
                    if (fp_stack[0] != fp_stack[1]) {
                        ecx = *((ebp - 0x4c));
                        if (*((ebp - 0x64)) != ecx) {
                            goto label_15;
                        }
                        eax = *((ebp - 0x54));
                        edi = *((ebp + 0x18));
                        al = (*(edi) != eax) ? 1 : 0;
                        eax = (int32_t) al;
                        *((ebp - 0x60)) += eax;
                        *(fp_stack--) = *((ebp - 0x48));
                        *(fp_stack--) = *((ebp - 0x30));
                        fp_tmp_10 = fp_stack[1];
                        fp_stack[1] = fp_stack[0];
                        fp_stack[0] = fp_tmp_10;
                        if (fp_stack[0] == fp_stack[1]) {
                            if (fp_stack[0] != fp_stack[1]) {
                                fp_stack++;
                                fp_stack++;
                                *(fp_stack--) = *((ebp - 0x40));
                                *(fp_stack--) = *((ebp - 0x28));
                                fp_tmp_11 = fp_stack[1];
                                fp_stack[1] = fp_stack[0];
                                fp_stack[0] = fp_tmp_11;
                                if (fp_stack[0] == fp_stack[1]) {
                                    if (fp_stack[0] != fp_stack[1]) {
                                        fp_stack++;
                                        fp_stack++;
                                        *(fp_stack--) = *((ebp - 0x38));
                                        *(fp_stack--) = *((ebp - 0x20));
                                        fp_tmp_12 = fp_stack[1];
                                        fp_stack[1] = fp_stack[0];
                                        fp_stack[0] = fp_tmp_12;
                                        if (fp_stack[0] != fp_stack[1]) {
                                            if (fp_stack[0] == fp_stack[1]) {
                                                goto label_16;
                                            }
                                            fp_tmp_13 = fp_stack[1];
                                            fp_stack[1] = fp_stack[0];
                                            fp_stack[0] = fp_tmp_13;
                                            fp_tmp_14 = fp_stack[1];
                                            fp_stack[1] = fp_stack[0];
                                            fp_stack[0] = fp_tmp_14;
                                            fp_tmp_15 = fp_stack[1];
                                            fp_stack[1] = fp_stack[0];
                                            fp_stack[0] = fp_tmp_15;
                                            fp_tmp_16 = fp_stack[1];
                                            fp_stack[1] = fp_stack[0];
                                            fp_stack[0] = fp_tmp_16;
                                            fp_tmp_17 = fp_stack[1];
                                            fp_stack[1] = fp_stack[0];
                                            fp_stack[0] = fp_tmp_17;
                                        } else {
                                        } else {
                                        } else {
                                        } else {
                                        } else {
                                            fp_tmp_18 = fp_stack[1];
                                            fp_stack[1] = fp_stack[0];
                                            fp_stack[0] = fp_tmp_18;
                                        }
                                    }
                                }
                            }
                        }
                        fp_stack--;
                        fp_stack++;
                        if (fp_stack[0] > fp_stack[1]) {
                            goto label_17;
                        }
                    }
                } else {
label_15:
                    *(fp_stack--) = *((ebp - 0x80));
                    fp_stack--;
                    fp_stack++;
                    if (fp_stack[0] > fp_stack[1]) {
                        goto label_18;
                    }
                    if (edx != 0) {
                        goto label_18;
                    }
                    goto label_19;
label_16:
                    fp_stack++;
                    fp_stack++;
                }
                *(fp_stack--) = *((ebp - 0x80));
                fp_stack--;
                fp_stack++;
                if (fp_stack[0] <= fp_stack[1]) {
                    if (edx == 0) {
                        goto label_19;
                    }
                    goto label_3;
label_17:
                    fp_stack++;
                }
label_3:
                eax = ebp - 0x48;
                edx = ebp - 0x30;
                memmove (edx, eax, 0x18);
                *(fp_stack--) = *((ebp - 0x80));
                ecx = *((ebp + 0x14));
                *(ecx) = fp_stack[0];
                fp_stack--;
                edx = *((ebp - 0x54));
                eax = *((ebp + 0x18));
                *(eax) = edx;
                ecx = *((ebp - 0x4c));
                *((ebp - 0x64)) = ecx;
                ecx = 1;
                goto label_13;
            }
            ebx = *((ebp - 0x6c));
            esi = *((ebp - 0x70));
            *((ebp - 0x8c)) = edi;
            edi = *((ebp + 0x14));
            *(fp_stack--) = *(edi);
            *(fp_stack--) = *((ebp - 0x80));
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] <= fp_stack[1]) {
                goto label_20;
            }
            eax = *((eax + 8));
            *((ebp - 0x68)) = eax;
            eax = edi;
            *(eax) = fp_stack[0];
            fp_stack--;
            edx = *((ebp - 0x54));
            eax = *((ebp + 0x18));
            *(eax) = edx;
            ecx = *((ebp - 0x4c));
            *((ebp - 0x64)) = ecx;
            ecx = 1;
            goto label_13;
        }
label_14:
        ecx -= 2;
        if (*((ebp - 0x54)) >= ecx) {
            goto label_21;
        }
        esi = *(ebx);
        eax -= 0x20;
        ebx -= 0x20;
    } while (edx < esi);
    esi = *((ebp - 0x70));
    ecx = *((ebp - 0x84));
    ebx = *((ebp - 0x6c));
    *((ebp - 0x8c)) = edi;
    goto label_13;
label_20:
    fp_stack++;
label_19:
    ecx = 1;
    goto label_13;
label_21:
    esi = *((ebp - 0x70));
    ecx = *((ebp - 0x84));
    ebx = *((ebp - 0x6c));
    *((ebp - 0x8c)) = edi;
label_13:
    ebx += 2;
    esi += 0x20;
    goto label_1;
label_12:
    edi = *((ebp - 0x8c));
    esi = *((ebp - 0x50));
    eax = *((ebp + 0x10));
    if (*(eax) == 0) {
        edx = *((ebp - 0x68));
        *(eax) = edx;
    }
    eax = *((ebp + 0x18));
    ecx = *(eax);
    if (ecx < 0) {
        goto label_22;
    }
    edx = ecx + 1;
    if (esi <= edx) {
        goto label_23;
    }
    eax = edx;
    eax <<= 4;
    eax = edi + eax + 8;
    do {
        ebx = *(eax);
        ebx--;
        if (ebx <= 1) {
            if (*((eax - 4)) == 1) {
                goto label_23;
            }
        }
        edx += 2;
        eax += 0x20;
    } while (esi > edx);
label_23:
    edx -= ecx;
    eax = *((ebp + 0x1c));
    *(eax) = edx;
label_22:
    edx = *((ebp + 0x20));
    if (*(edx) == 2) {
        ecx = *((ebp - 0x64));
        *(edx) = ecx;
    }
    eax = *((ebp - 0x60));
    return eax;
label_10:
    *((ebp - 0x60)) = 1;
    goto label_2;
label_18:
    *((ebp - 0x60)) = 1;
    goto label_3;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806f95b */
#include <stdint.h>
 
int32_t dbg_list_string (void) {
    token_type * p1;
    int32_t n;
    char * string;
    int32_t export_flag;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    /* int list_string(token_type * p1,int n,char * string,int export_flag); */
    eax = *((ebp + 0x14));
    *((esp + 0x10)) = eax;
    eax = *((ebp + 0x10));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 0;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    *(esp) = eax;
    list_string_sub ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a63c */
#include <stdint.h>
 
int32_t dbg_get_string (int32_t arg_8h, char * arg_ch, char * string, int32_t n, char * cp) {
    char * size;
    FILE * stream;
    int32_t var_ch;
    int32_t var_10h;
    ebx = string;
    esi = n;
    edi = cp;
    /* char * get_string(char * string,int n); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    if (*(obj.quiet_mode) != 0) {
        *(obj.prompt_str) = 0;
    }
    edi = prompt_str;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx--;
    *(obj.input_column) = ecx;
    if (*(obj.readline_enabled) != 0) {
        if (*(obj.echo_input) == 0) {
            *(esp) = obj.prompt_str;
            eax = readline ();
            edi = eax;
            if (eax == 0) {
                if (*(obj.quiet_mode) == 0) {
                    *((esp + 4)) = "\nEnd of input.\n";
                    *(esp) = 1;
                    printf_chk ();
                }
                exit_program (0);
            }
            *((esp + 8)) = esi;
            my_strlcpy (ebx, edi);
            eax = skip_space (edi);
            if (*(eax) != 0) {
                eax = last_history_string;
                if (eax != 0) {
                    eax = strcmp (eax, edi);
                    if (eax == 0) {
                        goto label_0;
                    }
                }
                *(esp) = edi;
                add_history ();
                *(obj.last_history_string) = edi;
                goto label_1;
            }
label_0:
            free (edi);
        } else {
            if (*(obj.echo_input) != 0) {
                goto label_2;
            }
            *((esp + 8)) = obj.prompt_str;
            *((esp + 4)) = 0x8075e74;
            *(esp) = 1;
            printf_chk ();
        }
label_2:
        eax = stdin;
        eax = fgets (ebx, esi, eax);
        if (eax != 0) {
            goto label_1;
        }
        if (*(obj.quiet_mode) == 0) {
            *((esp + 4)) = "\nEnd of input.\n";
            *(esp) = 1;
            printf_chk ();
        }
        exit_program (0);
    }
label_1:
    edi = ebx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx -= 2;
    if (ecx >= 0) {
        ecx = ebx + ecx;
        if (*(ecx) != 0xa) {
            goto label_3;
        }
        *(ecx) = 0;
    }
label_3:
    eax = gfp;
    if (eax != *(obj.stdout)) {
        if (eax != *(obj.stderr)) {
            goto label_4;
        }
    }
    if (*(obj.echo_input) != 0) {
label_4:
        *((esp + 0x10)) = ebx;
        *((esp + 0xc)) = 0x80795a0;
        *((esp + 8)) = "%s%s\n";
        *((esp + 4)) = 1;
        *(esp) = eax;
        fprintf_chk ();
    }
    set_error_level (ebx);
    *(obj.abort_flag) = 0;
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806c0d8 */
#include <stdint.h>
 
int32_t dbg_integrate_cmd (int32_t arg_8h, int32_t definite_flag, int32_t j, long int l1, token_type * source, int32_t len) {
    int * np;
    int32_t solved;
    uint32_t var_b5h;
    int32_t i;
    double integrate_order;
    uint32_t var_a1h;
    int32_t var_a0h;
    char * cp;
    int32_t n2;
    int32_t n1;
    long int v;
    char[100] var_name_buf;
    int32_t var_1ch;
    char * endptr;
    size_t n;
    int32_t var_ch;
    char * var_10h;
    int32_t var_14h;
    ebx = definite_flag;
    ecx = j;
    esi = l1;
    edi = source;
    eax = len;
    /* int integrate_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x9c)) = eax;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    *((ebp - 0x84)) = 0;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_1;
    }
    eax = cur_equation;
    eax = solved_equation (eax);
    *((ebp - 0xbc)) = eax;
    eax = next_espace ();
    *((ebp - 0xb4)) = eax;
    edi = 0;
    ebx = 0;
    esi = 1;
    do {
        *((esp + 4)) = "definite";
        eax = *((ebp - 0x9c));
        eax = strcmp_tospace (eax);
        if (eax == 0) {
            ebx = esi;
        } else {
            *((esp + 4)) = "constant";
            eax = *((ebp - 0x9c));
            eax = strcmp_tospace (eax);
            if (eax != 0) {
                goto label_2;
            }
            edi = esi;
        }
        eax = *((ebp - 0x9c));
        eax = skip_param (eax);
        *((ebp - 0x9c)) = eax;
    } while (1);
label_2:
    edx = edi;
    *((ebp - 0xa1)) = dl;
    *((ebp - 0xb5)) = bl;
    if (dl != 0) {
        if (bl == 0) {
            goto label_3;
        }
        *(esp) = "Conflicting options given.";
        error ();
        eax = 0;
        goto label_4;
    }
label_3:
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        edx = rhs;
        edi = *((edx + eax*4));
        esi = eax*4 + obj_n_rhs;
        ecx = *((ebp - 0xb4));
        ebx = *((edx + ecx*4));
        eax = ecx*4 + obj_n_rhs;
        *((ebp - 0xc0)) = eax;
    } else {
        edx = lhs;
        edi = *((edx + eax*4));
        esi = eax*4 + obj_n_lhs;
        ecx = *((ebp - 0xb4));
        ebx = *((edx + ecx*4));
        eax = ecx*4 + obj_n_lhs;
        *((ebp - 0xc0)) = eax;
    }
    eax = *((ebp - 0x9c));
    eax = *(eax);
    if (al == 0) {
        goto label_5;
    }
    eax = (int32_t) al;
    eax = isvarchar (eax);
    if (eax != 0) {
        eax = *((ebp - 0x9c));
        eax = ebp - 0x84;
        eax = parse_var2 (eax, eax);
        *((ebp - 0x9c)) = eax;
        if (eax == 0) {
            goto label_1;
        }
    }
    eax = *((ebp - 0x9c));
    if (*(eax) == 0) {
        *(fp_stack--) = 1.0;
        *((ebp - 0xb0)) = fp_stack[0];
        fp_stack--;
    } else {
        edx = ebp - 0x9c;
        strtod (eax, edx);
        *((ebp - 0xb0)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x9c));
        if (*(eax) != 0) {
            goto label_6;
        }
        *(fp_stack--) = 0.0;
        *(fp_stack--) = *((ebp - 0xb0));
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] >= fp_stack[1]) {
            goto label_6;
        }
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0xb0));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_7;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0xb0));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_7:
    *(fp_stack--) = 0.0;
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_8;
        }
    }
label_6:
    *(esp) = "The order must be a positive integer.";
    error ();
    eax = 0;
    goto label_4;
label_5:
    *(fp_stack--) = 1.0;
    *((ebp - 0xb0)) = fp_stack[0];
    fp_stack--;
label_8:
    if (*((ebp - 0x84)) == 0) {
        eax = ebp - 0x84;
        eax = prompt_var (eax);
        if (eax == 0) {
            goto label_1;
        }
    }
    if (*(obj.debug_level) >= 0) {
        eax = *((ebp - 0x84));
        list_var (eax, 0);
        eax = cur_equation;
        if (*((eax*4 + obj.n_rhs)) != 0) {
            *((esp + 8)) = obj.var_str;
            *((esp + 4)) = "Integrating the RHS with respect to (%s)";
            *(esp) = 1;
            printf_chk ();
        } else {
            *((esp + 8)) = obj.var_str;
            *((esp + 4)) = "Integrating with respect to (%s)";
            *(esp) = 1;
            printf_chk ();
        }
        *(fp_stack--) = 1.0;
        *(fp_stack--) = *((ebp - 0xb0));
        fp_stack[1] = fp_stack[0];
        fp_stack--;
        if (fp_stack[0] != fp_stack[1]) {
            if (fp_stack[0] == fp_stack[1]) {
                goto label_9;
            }
        }
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        eax = precision;
        *((esp + 8)) = eax;
        *((esp + 4)) = " %.*g times";
        *(esp) = 1;
        printf_chk ();
        goto label_10;
label_9:
        fp_stack++;
label_10:
        *((esp + 4)) = " and simplifying...\n";
        *(esp) = 1;
        printf_chk ();
    }
    *(obj.partial_flag) = 0;
    *((esp + 4)) = esi;
    *(esp) = edi;
    uf_simp ();
    *(obj.partial_flag) = 1;
    eax = *((ebp - 0x84));
    factorv (edi, esi, eax);
    eax = *(esi);
    eax <<= 4;
    memmove (ebx, edi, eax);
    eax = *(esi);
    *((ebp - 0x88)) = eax;
    esi = 0;
    *(fp_stack--) = 0.0;
    *(fp_stack--) = *((ebp - 0xb0));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] <= fp_stack[1]) {
        goto label_11;
    }
    edi = ebp - 0x88;
label_0:
    *((esp + 0xc)) = dbg.integrate_sub;
    eax = *((ebp - 0x84));
    eax = int_dispatch (ebx, edi, eax);
    if (eax == 0) {
        *(esp) = "Integration failed, not a polynomial.";
        error ();
        eax = 0;
        goto label_4;
    }
    if (*((ebp - 0xa1)) == 0) {
        goto label_12;
    }
    eax = *((ebp - 0x88));
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    ecx = *((ebp - 0x88));
    if (ecx <= 0) {
        goto label_13;
    }
    eax = ebx;
    edx = 0;
    do {
        *((eax + 4))++;
        edx++;
        ecx = *((ebp - 0x88));
        eax += 0x10;
    } while (ecx > edx);
label_13:
    ecx <<= 4;
    *((ecx + ebx)) = 2;
    eax = *((ebp - 0x88));
    eax <<= 4;
    *((eax + ebx + 4)) = 1;
    eax = *((ebp - 0x88));
    eax <<= 4;
    *((eax + ebx + 8)) = 1;
    eax = *((ebp - 0x88));
    eax++;
    *((ebp - 0x88)) = eax;
    eax <<= 4;
    *((eax + ebx)) = 1;
    eax = *((ebp - 0x88));
    eax <<= 4;
    *((eax + ebx + 4)) = 1;
    eax = constant_var_number;
    *((esp + 0x14)) = eax;
    *((esp + 0x10)) = "C_%d";
    *((esp + 0xc)) = 0x64;
    *((esp + 8)) = 1;
    *((esp + 4)) = 0x64;
    eax = ebp - 0x80;
    *(esp) = eax;
    snprintf_chk ();
    edx = ebp - 0x80;
    *((esp + 4)) = edx;
    eax = *((ebp - 0x88));
    eax <<= 4;
    eax = ebx + eax + 8;
    eax = parse_var (eax);
    if (eax == 0) {
        goto label_1;
    }
    *((ebp - 0x88))++;
    edx = constant_var_number;
    edx++;
    eax = 1;
    __asm ("cmovns eax, edx");
    *(obj.constant_var_number) = eax;
label_12:
    simp_loop (ebx, edi);
    esi++;
    *((ebp - 0xa0)) = esi;
    *(fp_stack--) = *((ebp - 0xa0));
    *(fp_stack--) = *((ebp - 0xb0));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_0;
    }
label_11:
    if (*((ebp - 0xb5)) == 0) {
        goto label_14;
    }
    *((esp + 8)) = 0x50;
    my_strlcpy (obj.prompt_str, "Enter lower bound: ");
    eax = tlhs;
    eax = get_expr (eax, 0x80796b8);
    if (eax == 0) {
        goto label_1;
    }
    *((esp + 8)) = 0x50;
    my_strlcpy (obj.prompt_str, "Enter upper bound: ");
    eax = trhs;
    eax = get_expr (eax, 0x80798b4);
    if (eax == 0) {
        goto label_1;
    }
    eax = *((ebp - 0x88));
    eax <<= 4;
    eax = scratch;
    memmove (eax, ebx, eax);
    eax = *((ebp - 0x88));
    *((ebp - 0x8c)) = eax;
    eax = *((ebp - 0x84));
    *((esp + 0x10)) = eax;
    eax = n_tlhs;
    *((esp + 0xc)) = eax;
    eax = tlhs;
    *((esp + 8)) = eax;
    eax = ebp - 0x8c;
    *((esp + 4)) = eax;
    eax = scratch;
    subst_var_with_exp (eax);
    eax = *((ebp - 0x84));
    *((esp + 0x10)) = eax;
    eax = n_trhs;
    *((esp + 0xc)) = eax;
    eax = trhs;
    *((esp + 8)) = eax;
    eax = ebp - 0x88;
    *((esp + 4)) = eax;
    subst_var_with_exp (ebx);
    eax = *((ebp - 0x88));
    eax += *((ebp - 0x8c));
    eax++;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    if (*((ebp - 0x88)) <= 0) {
        goto label_15;
    }
    eax = ebx;
    edx = 0;
    do {
        *((eax + 4))++;
        edx++;
        eax += 0x10;
    } while (*((ebp - 0x88)) > edx);
label_15:
    if (*((ebp - 0x8c)) <= 0) {
        goto label_16;
    }
    eax = 0;
    do {
        edx = 0;
        edx <<= 4;
        edx += *(obj.scratch);
        *((edx + 4))++;
        eax++;
    } while (*((ebp - 0x8c)) > eax);
label_16:
    eax = *((ebp - 0x88));
    eax <<= 4;
    *((eax + ebx)) = 2;
    eax = *((ebp - 0x88));
    eax <<= 4;
    *((eax + ebx + 4)) = 1;
    eax = *((ebp - 0x88));
    eax <<= 4;
    *((eax + ebx + 8)) = 2;
    eax = *((ebp - 0x88));
    eax++;
    *((ebp - 0x88)) = eax;
    edx = *((ebp - 0x8c));
    edx <<= 4;
    edx = scratch;
    eax <<= 4;
    eax = ebx + eax;
    memmove (eax, edx, edx);
    eax = *((ebp - 0x8c));
    *((ebp - 0x88)) += eax;
label_14:
    *((esp + 0xc)) = 0;
    *((esp + 8)) = 0;
    eax = ebp - 0x88;
    simpa_side (ebx, eax);
    eax = *((ebp - 0x88));
    edx = *((ebp - 0xc0));
    *(edx) = eax;
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) == 0) {
        goto label_17;
    }
    ebx = n_lhs;
    edx = *((ebx + eax*4));
    edx <<= 4;
    edx = lhs;
    eax = *((edx + eax*4));
    ecx = *((ebp - 0xb4));
    eax = *((edx + ecx*4));
    memmove (eax, eax, edx);
    eax = cur_equation;
    eax = *((ebx + eax*4));
    edx = *((ebp - 0xb4));
    *((ebx + edx*4)) = eax;
    if (*((ebp - 0xbc)) == 0) {
        goto label_17;
    }
    eax = isvarchar (0x27);
    if (eax == 0) {
        goto label_17;
    }
    ecx = *((ebp - 0xb4));
    eax = *((ecx*4 + obj.lhs));
    eax = *((eax + 8));
    eax = list_var (eax, 0);
    ecx = eax + 0x80797ff;
    edx = 0;
    while (*(ecx) == 0x27) {
        *(ecx) = 0;
        edx++;
        ecx--;
        ebx = eax;
        ebx -= edx;
        *((ebp - 0xa0)) = edx;
        *(fp_stack--) = *((ebp - 0xa0));
        *(fp_stack--) = *((ebp - 0xb0));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] <= fp_stack[1]) {
            goto label_18;
        }
        if (ebx <= 0) {
            goto label_18;
        }
    }
label_18:
    *((esp + 4)) = obj.var_str;
    edx = *((ebp - 0xb4));
    eax = *((edx*4 + obj.lhs));
    eax += 8;
    parse_var (eax);
label_17:
    ecx = *((ebp - 0xb4));
    *(obj.cur_equation) = ecx;
    return_result (ecx);
    goto label_4;
label_1:
    eax = 0;
label_4:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8055703 */
#include <stdint.h>
 
int32_t dbg_imaginary_cmd (void) {
    char * cp;
    /* int imaginary_cmd(char * cp); */
    edx = 1;
    eax = *((ebp + 8));
    complex_func ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a86f */
#include <stdint.h>
 
int32_t dbg_get_expr (int32_t arg_8h, char * arg_ch, int * np, token_type * equation, char * cp) {
    char[60000] buf;
    int32_t canary;
    int32_t var_4h;
    int32_t var_8h;
    ebx = np;
    edi = equation;
    eax = cp;
    /* int get_expr(token_type * equation,int * np); */
    edi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    esi = ebp - 0xea7c;
    do {
        eax = get_string (esi, 0xea60);
        if (eax == 0) {
            goto label_0;
        }
        *((esp + 8)) = eax;
        eax = parse_expr (edi, ebx);
    } while (eax == 0);
    al = (*(ebx) > 0) ? 1 : 0;
    eax = (int32_t) al;
label_0:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*(ebx) != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057bbf */
#include <stdint.h>
 
int32_t dbg_edit_cmd (int32_t rv, int32_t fd) {
    char[4096] tmp_file;
    int32_t canary;
    char * cp;
    char * mode;
    int32_t var_8h;
    ebx = rv;
    eax = fd;
    /* int edit_cmd(char * cp); */
    ebx = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0xc)) = eax;
    eax = 0;
    if (*(obj.security_level) != 0) {
        *(esp) = "Command disabled.";
        error ();
        ebx = 0;
    } else {
        clean_up ();
        if (*(ebx) == 0) {
            *((esp + 8)) = 0x1000;
            ebx = ebp - 0x100c;
            my_strlcpy (ebx, "/tmp/mathomatic.XXXXXX");
            eax = mkstemp (ebx);
            if (eax >= 0) {
                *((esp + 4)) = 0x8075eaa;
                *(esp) = eax;
                eax = fdopen ();
                ebx = eax;
                if (eax != 0) {
                    goto label_0;
                }
            }
            *(esp) = "Can't create temporary file.";
            eax = error ();
            ebx = 0;
            goto label_1;
label_0:
            *(obj.gfp) = eax;
            *(obj.high_prec) = 1;
            *(esp) = 0x807207b;
            list_cmd ();
            *(obj.high_prec) = 0;
            eax = default_out;
            *(obj.gfp) = eax;
            fclose (ebx);
            esi = ebp - 0x100c;
            eax = esi;
            eax = edit_sub ();
            ebx = eax;
            unlink (esi);
        } else {
            eax = access (ebx, 6);
            if (eax != 0) {
                *(esp) = "You can only edit existing/writable files or all equations.";
                error ();
                ebx = 0;
            } else {
                eax = ebx;
                eax = edit_sub ();
                ebx = eax;
            }
        }
    }
label_1:
    edx = *((ebp - 0xc));
    edx ^= *(gs:0x14);
    if (eax != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d07c */
#include <stdint.h>
 
int32_t dbg_rect_to_polar (void) {
    double x;
    double y;
    double * radiusp;
    double * thetap;
    /* void rect_to_polar(double x,double y,double * radiusp,double * thetap); */
    *(fp_stack--) = *((ebp + 8));
    *(fp_stack--) = *((ebp + 0x10));
    *(fp_stack--) = fp_stack[1];
    fp_stack[0] *= fp_stack[2];
    *(fp_stack--) = fp_stack[1];
    fp_stack[0] *= fp_stack[2];
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    fp_stack[0] = sqrt(fp_stack[0]);
    eax = *((ebp + 0x18));
    *(eax) = fp_stack[0];
    fp_stack--;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    atan2 (ebp);
    eax = *((ebp + 0x1c));
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804e7b0 */
#include <stdint.h>
 
uint32_t dbg_display_command (int32_t arg_8h, int32_t rows) {
    int32_t var_1ch;
    int32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    int32_t var_10h;
    esi = rows;
    /* int display_command(int i); */
    ebx = *((ebp + 8));
    esi = com_list;
    edi = ebx + ebx;
    eax = edi + ebx;
    eax = *((esi + eax*8));
    *((ebp - 0x1c)) = eax;
    eax = edi + ebx;
    eax = *((eax*8 + 0x8074d90));
    *((esp + 0x10)) = eax;
    eax = *((ebp - 0x1c));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 0x8072778;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = edi + ebx;
    eax = *((esi + eax*8 + 0xc));
    *((esp + 0x10)) = eax;
    eax = *((ebp - 0x1c));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "Usage: %s %s\n";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    edi += ebx;
    eax = *((esi + edi*8 + 4));
    esi = 3;
    if (eax != 0) {
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "Alternate name for this command: %s\n";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        si = 4;
    }
    eax = ebx * 3;
    eax = *((eax*8 + 0x8074d94));
    if (eax != 0) {
        *((esp + 0xc)) = eax;
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        esi++;
    }
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = esi;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049390 */
#include <stdint.h>
 
void dbg_fphandler (void) {
    int32_t sig;
    /* void fphandler(int sig); */
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80570c8 */
#include <stdint.h>
 
int32_t dbg_product_cmd (void) {
    char * cp;
    /* int product_cmd(char * cp); */
    edx = 1;
    eax = *((ebp + 8));
    sum_product ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a2c9 */
#include <stdint.h>
 
int32_t dbg_no_vars (char * arg_ch, size_t * arg_10h, int32_t j, int32_t n, long int * vp) {
    int32_t found;
    token_type * source;
    int32_t var_4h;
    ecx = j;
    edx = n;
    edi = vp;
    /* int no_vars(token_type * source,int n,long int * vp); */
    eax = *((ebp + 8));
    ecx = *((ebp + 0xc));
    edi = *((ebp + 0x10));
    if (*(edi) == 0) {
        *((ebp - 0x10)) = 0;
        if (ecx > 0) {
            goto label_0;
        }
        goto label_1;
    }
    eax = var_count (eax, ecx);
    al = (eax == 0) ? 1 : 0;
    eax = (int32_t) al;
    goto label_2;
label_0:
    *((ebp - 0x10)) = 0;
    edx = 0;
    do {
        if (*(eax) == 1) {
            ebx = *((eax + 8));
            esi = *((eax + 8));
            esi &= 0x3fff;
            if (esi <= 4) {
                goto label_3;
            }
            esi = *(edi);
            if (esi != 0) {
                if (ebx == esi) {
                    goto label_3;
                }
                *(edi) = 0;
                goto label_1;
            }
            *(edi) = ebx;
            *((ebp - 0x10)) = 1;
        }
label_3:
        edx += 2;
        eax += 0x20;
    } while (ecx > edx);
label_1:
    al = (*((ebp - 0x10)) == 0) ? 1 : 0;
    eax = (int32_t) al;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80515d9 */
#include <stdint.h>
 
uint32_t dbg_parse_equation (int32_t arg_8h, char * arg_ch, char * cp, int32_t n) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    ebx = cp;
    esi = n;
    /* char * parse_equation(int n,char * cp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    if (ebx != 0) {
        if (*(obj.case_sensitive_flag) == 0) {
            str_tolower (ebx);
        }
        edi = esi*4;
        *((esp + 0xc)) = 1;
        eax = edi + obj_n_lhs;
        eax = *((esi*4 + obj.lhs));
        eax = parse_section (eax, eax, ebx);
        ebx = eax;
        if (eax == 0) {
            goto label_0;
        }
        *((esp + 0xc)) = 1;
        edi += obj.n_rhs;
        eax = *((esi*4 + obj.rhs));
        eax = parse_section (eax, edi, eax);
        ebx = eax;
        if (eax == 0) {
            goto label_0;
        }
        eax = extra_characters (eax);
        eax = 0;
        if (eax == 0) {
            ebx = eax;
            goto label_0;
        }
    }
label_0:
    eax = ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049fd0 */
#include <stdint.h>
 
void dbg_init_gvars (void) {
    /* void init_gvars(); */
    *(obj.domain_check) = 0;
    *(obj.high_prec) = 0;
    *(obj.partial_flag) = 1;
    *(obj.symb_flag) = 0;
    *(obj.sign_cmp_flag) = 0;
    *(obj.approximate_roots) = 0;
    *(obj.repeat_flag) = 0;
    *(0x8079918) = 1;
    *(obj.zero_token) = 0;
    *(fp_stack--) = 0.0;
    *(0x807991c) = fp_stack[0];
    fp_stack--;
    *(0x80796a8) = 1;
    *(obj.one_token) = 0;
    *(fp_stack--) = 1.0;
    *(0x80796ac) = fp_stack[0];
    fp_stack--;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8063353 */
#include <stdint.h>
 
uint32_t dbg_basic_size (void * arg_ch, int32_t len, int32_t i, int32_t constant_flag) {
    int32_t j;
    int32_t rv;
    int32_t level;
    token_type * p1;
    int32_t var_4h;
    ebx = len;
    ecx = i;
    esi = constant_flag;
    /* int basic_size(token_type * p1,int len); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    eax = min_level (esi);
    *((ebp - 0x1c)) = eax;
    if (ebx <= 0) {
        *((ebp - 0x20)) = ebx;
        *((ebp - 0x24)) = 0xffffffff;
        ebx = 0;
        goto label_0;
    }
    eax = esi;
    *((ebp - 0x20)) = ebx;
    esi = 1;
    *((ebp - 0x24)) = 0xffffffff;
    edx = 0;
    edi = 0;
    do {
        ecx = *(eax);
        if (ecx == 2) {
            ecx = *((ebp - 0x1c));
            if (ecx != *((eax + 4))) {
                goto label_1;
            }
            ecx = *((eax + 8));
            ecx -= 3;
            if (ecx > 1) {
                goto label_1;
            }
            if (esi == 0) {
                *((ebp - 0x24)) = edx;
                si = 1;
            } else {
                ecx = *((ebp - 0x24));
            }
            ecx += *((ebp - 0x20));
            ecx -= edx;
            *((ebp - 0x20)) = ecx;
            *((ebp - 0x24)) = edx;
            esi = 1;
        } else {
            if (ecx == 0) {
                esi = edi;
                goto label_1;
            }
        }
label_1:
        edx++;
        eax += 0x10;
    } while (edx != ebx);
    if (esi != 0) {
label_0:
        eax = *((ebp - 0x20));
        eax += *((ebp - 0x24));
        eax -= ebx;
        *((ebp - 0x20)) = eax;
    }
    eax = *((ebp - 0x20));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ae82 */
#include <stdint.h>
 
int32_t dbg_current_not_defined (int32_t i) {
    ecx = i;
    /* int current_not_defined(); */
    edx = cur_equation;
    if (edx >= 0) {
        if (edx >= *(obj.n_equations)) {
            goto label_0;
        }
        eax = 0;
        if (*((edx*4 + obj.n_lhs)) > 0) {
            goto label_1;
        }
    }
label_0:
    *(esp) = "No current equation or expression.";
    error ();
    eax = 1;
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8069ff8 */
#include <stdint.h>
 
uint32_t dbg_extrema_cmd (int32_t i, token_type * source, long int l1) {
    long int order;
    token_type want;
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_20h;
    long int v;
    char * cp;
    void ** s2;
    size_t * n;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = i;
    esi = source;
    edi = l1;
    /* int extrema_cmd(char * cp); */
    *((ebp - 0x1c)) = 0;
    eax = current_not_defined ();
    if (eax != 0) {
        goto label_0;
    }
    eax = next_espace ();
    ebx = eax;
    eax = cur_equation;
    if (*((eax*4 + obj.n_rhs)) != 0) {
        eax = solved_equation (eax);
        if (eax == 0) {
            *(esp) = "The current equation is not solved for a variable.";
            error ();
            eax = 0;
            goto label_1;
        }
        eax = cur_equation;
        esi = *((eax*4 + obj.rhs));
        eax = *((eax*4 + obj.n_rhs));
        *((ebp - 0x20)) = eax;
    } else {
        esi = *((eax*4 + obj.lhs));
        eax = *((eax*4 + obj.n_lhs));
        *((ebp - 0x20)) = eax;
    }
    eax = *((ebp + 8));
    eax = *(eax);
    if (al != 0) {
        eax = (int32_t) al;
        eax = isvarchar (eax);
        if (eax != 0) {
            eax = *((ebp + 8));
            eax = ebp - 0x1c;
            eax = parse_var2 (eax, eax);
            *((ebp + 8)) = eax;
            if (eax == 0) {
                goto label_0;
            }
        }
        eax = *((ebp + 8));
        if (*(eax) == 0) {
            goto label_2;
        }
        edx = ebp + 8;
        eax = decstrtol (eax, edx);
        *((ebp - 0x3c)) = eax;
        eax = *((ebp + 8));
        if (*(eax) == 0) {
            if (*((ebp - 0x3c)) > 0) {
                goto label_3;
            }
        }
        *(esp) = "The order must be a positive integer.";
        error ();
        eax = 0;
        goto label_1;
    }
label_2:
    *((ebp - 0x3c)) = 1;
label_3:
    eax = ebp - 0x1c;
    *((esp + 8)) = eax;
    eax = *((ebp - 0x20));
    eax = no_vars (esi, eax);
    if (eax != 0) {
        *(esp) = "Current expression contains no variables.";
        error ();
        eax = 0;
        goto label_1;
    }
    if (*((ebp - 0x1c)) == 0) {
        eax = ebp - 0x1c;
        eax = prompt_var (eax);
        if (eax == 0) {
            goto label_0;
        }
    }
    eax = *((ebp - 0x1c));
    eax = *((ebp - 0x20));
    eax = found_var (esi, eax, eax);
    if (eax == 0) {
        *(esp) = "Variable not found; the derivative would be zero.";
        error ();
        eax = 0;
        goto label_1;
    }
    eax = *((ebp - 0x20));
    eax <<= 4;
    eax = *((ebx*4 + obj.rhs));
    memmove (eax, esi, eax);
    if (*((ebp - 0x3c)) <= 0) {
        goto label_4;
    }
    edi = 0;
    esi = rhs;
    do {
        eax = *((ebp - 0x1c));
        *((esp + 8)) = eax;
        eax = ebp - 0x20;
        eax = *((esi + ebx*4));
        eax = differentiate (eax, eax);
        if (eax == 0) {
            *(esp) = "Differentiation failed.";
            error ();
            eax = 0;
            goto label_1;
        }
        *((esp + 0xc)) = 0;
        *((esp + 8)) = 1;
        edx = ebp - 0x20;
        eax = *((esi + ebx*4));
        simpa_side (eax, edx);
        edi++;
    } while (*((ebp - 0x3c)) > edi);
label_4:
    eax = *((ebp - 0x1c));
    eax = *((ebp - 0x20));
    eax = *((ebx*4 + obj.rhs));
    eax = found_var (eax, eax, eax);
    if (eax == 0) {
        *(esp) = "There are no solutions.";
        error ();
        eax = 0;
    } else {
        eax = *((ebp - 0x20));
        *((ebx*4 + obj.n_rhs)) = eax;
        *((ebx*4 + obj.n_lhs)) = 1;
        edx = lhs;
        eax = *((edx + ebx*4));
        ecx = zero_token;
        *(eax) = ecx;
        ecx = .comment;
        *((eax + 4)) = ecx;
        ecx = .comment;
        *((eax + 8)) = ecx;
        ecx = .comment;
        *((eax + 0xc)) = ecx;
        *(obj.cur_equation) = ebx;
        *((ebp - 0x2c)) = 1;
        *((ebp - 0x30)) = 1;
        eax = *((ebp - 0x1c));
        *((ebp - 0x28)) = eax;
        eax = ebx*4;
        esi = eax + obj_n_rhs;
        *((esp + 0x14)) = esi;
        ecx = *((ebx*4 + obj.rhs));
        *((esp + 0x10)) = ecx;
        eax += obj.n_lhs;
        *((esp + 0xc)) = eax;
        eax = *((edx + ebx*4));
        *((esp + 8)) = eax;
        *((esp + 4)) = 1;
        eax = ebp - 0x30;
        *(esp) = eax;
        eax = solve_sub ();
        if (eax <= 0) {
            *(esp) = "Solve failed.";
            error ();
            eax = 0;
        } else {
            *((esp + 0xc)) = 0;
            *((esp + 8)) = 0;
            eax = *((ebx*4 + obj.rhs));
            simpa_side (eax, esi);
            eax = cur_equation;
            return_result (eax);
            goto label_1;
label_0:
            eax = 0;
        }
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a221 */
#include <stdint.h>
 
int32_t dbg_level_plus_count (int32_t arg_8h, int32_t arg_ch, int32_t arg_10h, int32_t n1, int32_t i, int32_t level, int32_t count) {
    ebx = n1;
    edx = i;
    esi = level;
    eax = count;
    /* int level_plus_count(token_type * p1,int n1,int level); */
    ebx = *((ebp + 0xc));
    esi = *((ebp + 0x10));
    eax = 0;
    if (ebx <= 1) {
        goto label_0;
    }
    edx = *((ebp + 8));
    ecx = 1;
    do {
        if (*((edx + 0x14)) == esi) {
            edi = *((edx + 0x18));
            edi--;
            eax += 0;
        }
        ecx += 2;
        edx += 0x20;
    } while (ebx > ecx);
label_0:
    esi = ebx;
    edi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a1e2 */
#include <stdint.h>
 
int32_t dbg_min_level (size_t * arg_8h, token_type * ep, token_type * p1, int32_t min1) {
    int32_t n;
    ebx = ep;
    ecx = p1;
    eax = min1;
    /* int min_level(token_type * expression,int n); */
    edx = *((ebp + 8));
    ebx = *((ebp + 0xc));
    if (ebx <= 1) {
        eax = 1;
        if (ebx <= 0) {
            goto label_0;
        }
        eax = *((edx + 4));
        goto label_0;
    }
    eax = *((edx + 0x14));
    ebx <<= 4;
    ebx = edx + ebx;
    edx += 0x30;
    if (ebx <= edx) {
        goto label_0;
    }
    do {
        ecx = *((edx + 4));
        if (eax > ecx) {
            eax = ecx;
        }
        edx += 0x20;
    } while (ebx > edx);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8057a98 */
#include <stdint.h>
 
int32_t dbg_read_cmd (void) {
    char * cp;
    /* int read_cmd(char * cp); */
    if (*(obj.security_level) > 2) {
        *(esp) = "Command disabled.";
        error ();
        eax = 0;
    } else {
        eax = *((ebp + 8));
        read_file (eax);
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8062feb */
#include <stdint.h>
 
void dbg_uf_simp_no_repeat (void) {
    int32_t var_8h;
    int32_t var_4h;
    token_type * equation;
    int * np;
    int32_t var_sp_4h;
    /* void uf_simp_no_repeat(token_type * equation,int * np); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    uf_power (esi, ebx);
    uf_tsimp (esi, ebx);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049478 */
#include <stdint.h>
 
int32_t dbg_inthandler (void) {
    int32_t sig;
    char * var_4h;
    /* void inthandler(int sig); */
    eax = abort_flag;
    eax++;
    *(obj.abort_flag) = eax;
    eax = abort_flag;
    if (eax >= 0) {
        if (eax > 1) {
            if (eax != 2) {
                goto label_0;
            }
        } else {
            *((esp + 4)) = "\nUser interrupt signal received; three times quits Mathomatic.\n";
            *(esp) = 1;
            printf_chk ();
            goto label_1;
        }
        *((esp + 4)) = "\nPress Control-C once more to quit program.\n";
        *(esp) = 1;
        printf_chk ();
    } else {
label_0:
        *((esp + 4)) = "\nRepeatedly interrupted; returning to operating system...\n";
        *(esp) = 1;
        printf_chk ();
        exit_program (1);
    }
label_1:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80524df */
#include <stdint.h>
 
int32_t dbg_save_set_options (FILE * fp) {
    char * mode;
    char * var_8h;
    ebx = fp;
    /* int save_set_options(); */
    if (*(obj.rc_file) == 0) {
        *(esp) = "Set options startup file name not set.";
        error ();
        eax = 0;
    } else {
        eax = fopen (obj.rc_file, 0x80779f1);
        ebx = eax;
        if (eax == 0) {
            *(esp) = "Unable to write to set options startup file.";
            error ();
            eax = 0;
        } else {
            *((esp + 8)) = "; Mathomatic set options loaded at startup.\n";
            *((esp + 4)) = 1;
            *(esp) = eax;
            fprintf_chk ();
            *((esp + 8)) = "; This file can be edited.\n\n";
            *((esp + 4)) = 1;
            *(esp) = ebx;
            fprintf_chk ();
            output_options (ebx);
            eax = fclose (ebx);
            if (eax == 0) {
                *((esp + 8)) = obj.rc_file;
                *((esp + 4)) = "All options saved in startup file \"%s\".\n";
                *(esp) = 1;
                printf_chk ();
                eax = 1;
            } else {
                *(esp) = "Error saving set options.";
                error ();
                eax = 0;
            }
        }
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8053b59 */
#include <stdint.h>
 
uint32_t dbg_display_fraction (int32_t rv) {
    double d5;
    double d4;
    int32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    int32_t var_sp_18h;
    ebx = rv;
    /* int display_fraction(double value); */
    *(fp_stack--) = *((ebp + 8));
    *((ebp - 0x20)) = fp_stack[0];
    eax = ebp - 0x18;
    eax = ebp - 0x10;
    *(esp) = fp_stack[0];
    fp_stack--;
    f_to_fraction (eax, eax);
    *(fp_stack--) = *((ebp - 0x20));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    eax = precision;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = 0x80759b8;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    *(fp_stack--) = *((ebp - 0x18));
    ebx = 0;
    *(fp_stack--) = 1.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_0;
        }
    }
    eax = precision;
    *((esp + 0x1c)) = fp_stack[0];
    fp_stack--;
    *((esp + 0x18)) = eax;
    *(fp_stack--) = *((ebp - 0x10));
    *((esp + 0x10)) = fp_stack[0];
    fp_stack--;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = " = %.*g/%.*g";
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    bl = 1;
    goto label_1;
label_0:
    fp_stack++;
label_1:
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    eax = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805143a */
#include <stdint.h>
 
uint32_t dbg_parse_expr (void * s1, char * arg_ch, int32_t i, char * cp1, int * np) {
    char * cp2;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    char * cp;
    void * s2;
    size_t * n;
    int32_t var_sp_ch;
    ebx = i;
    esi = cp1;
    edi = np;
    /* char * parse_expr(token_type * equation,int * np,char * cp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    edi = *((ebp + 0xc));
    ebx = *((ebp + 0x10));
    if (ebx != 0) {
        if (*(obj.case_sensitive_flag) == 0) {
            str_tolower (ebx);
        }
        eax = skip_space (ebx);
        if (*(eax) == 0x23) {
            esi = eax + 1;
            eax = *(esi);
            if (al != 0x2b) {
                if (al != 0x2d) {
                    goto label_0;
                }
            }
            eax = ebp - 0x1c;
            eax = decstrtol (esi, eax);
            ebx = eax;
            ebx += *(obj.cur_equation);
            goto label_1;
label_0:
            eax = ebp - 0x1c;
            decstrtol (esi, eax);
            ebx = eax - 1;
label_1:
            eax = *((ebp - 0x1c));
            if (esi != eax) {
                if (*(eax) == 0) {
                    goto label_2;
                }
            }
            *(esp) = "Error parsing equation space number.";
            error ();
            ebx = 0;
            goto label_3;
label_2:
            if (ebx >= 0) {
                if (ebx >= *(obj.n_equations)) {
                    goto label_4;
                }
                eax = *((ebx*4 + obj.n_lhs));
                if (eax > 0) {
                    goto label_5;
                }
            }
label_4:
            *(esp) = "No expression available in specified equation space.";
            error ();
            ebx = 0;
            goto label_3;
label_5:
            edx = *((ebx*4 + obj.n_rhs));
            if (edx != 0) {
                edx <<= 4;
                eax = *((ebx*4 + obj.rhs));
                eax = *((ebp + 8));
                memmove (eax, eax, edx);
                eax = *((ebx*4 + obj.n_rhs));
                *(edi) = eax;
            } else {
                eax <<= 4;
                eax = *((ebx*4 + obj.lhs));
                eax = *((ebp + 8));
                memmove (eax, eax, eax);
                eax = *((ebx*4 + obj.n_lhs));
                *(edi) = eax;
            }
            *((esp + 8)) = 0;
            eax = *(edi);
            *((esp + 4)) = eax;
            eax = *((ebp + 8));
            *(esp) = eax;
            list_proc ();
            *((esp + 8)) = 0x80757fd;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
            ebx = *((ebp - 0x1c));
        } else {
            *((esp + 0xc)) = 1;
            eax = *((ebp + 8));
            eax = parse_section (eax, edi, ebx);
            ebx = eax;
            if (eax == 0) {
                goto label_3;
            }
            eax = extra_characters (eax);
            eax = 0;
            if (eax == 0) {
                ebx = eax;
                goto label_3;
            }
        }
    }
label_3:
    eax = ebx;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8067067 */
#include <stdint.h>
 
int32_t dbg_poly2_gcd (int32_t count) {
    jmp_buf save_save;
    token_type * larger;
    int32_t llen;
    token_type * smaller;
    int32_t slen;
    long int v;
    void ** s2;
    size_t * n;
    char * var_ch;
    int32_t var_10h;
    ebx = count;
    /* int poly2_gcd(token_type * larger,int llen,token_type * smaller,int slen,long int v); */
    if (*(obj.debug_level) > 2) {
        *((esp + 0xc)) = "Entering poly2_gcd():";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((esp + 0x10)) = 0;
    eax = *((ebp + 0xc));
    eax = *((ebp + 8));
    list_debug (0, eax, eax);
    *((esp + 0x10)) = 0;
    eax = *((ebp + 0x14));
    eax = *((ebp + 0x10));
    list_debug (0, eax, eax);
    eax = n_tokens;
    if (*((ebp + 0xc)) <= eax) {
        edx = 0x7530;
        if (eax > 0x7530) {
            eax = edx;
        }
        if (*((ebp + 0x14)) <= eax) {
            eax = *((ebp + 0xc));
            eax <<= 4;
            eax = *((ebp + 8));
            eax = trhs;
            memmove (eax, eax, eax);
            eax = *((ebp + 0xc));
            *(obj.n_trhs) = eax;
            eax = *((ebp + 0x14));
            eax <<= 4;
            eax = *((ebp + 0x10));
            eax = tlhs;
            memmove (eax, eax, eax);
            eax = *((ebp + 0x14));
            *(obj.n_tlhs) = eax;
            eax = ebp - 0xa4;
            memmove (eax, 0x8079600, 0x9c);
            eax = setjmp (obj.jmp_save);
            ebx = eax;
            if (eax != 0) {
                eax = ebp - 0xa4;
                memmove (obj.jmp_save, eax, 0x9c);
                if (ebx != 0xd) {
                    goto label_0;
                }
                *((esp + 4)) = 0xd;
                *(esp) = obj.jmp_save;
                longjmp_chk ();
            }
            *((esp + 4)) = obj.n_tlhs;
            eax = tlhs;
            *(esp) = eax;
            uf_simp ();
            eax = ebp - 0xa4;
            memmove (obj.jmp_save, eax, 0x9c);
            eax = n_tlhs;
            *((esp + 4)) = eax;
            eax = tlhs;
            *(esp) = eax;
            eax = level1_plus_count ();
            if (eax == 0) {
                goto label_0;
            }
            eax = n_tlhs;
            if (eax > 0x7530) {
                goto label_0;
            }
            *((esp + 0xc)) = 0x75300;
            eax <<= 4;
            *((esp + 8)) = eax;
            eax = tlhs;
            *((esp + 4)) = eax;
            *(esp) = obj.gcd_divisor;
            memmove_chk ();
            eax = n_tlhs;
            *(obj.len_d) = eax;
            eax = ebp + 0x18;
            eax = do_gcd ();
            ebx = eax;
            if (eax == 0) {
                goto label_1;
            }
            if (eax > 1) {
                eax = len_d;
                *((esp + 4)) = eax;
                *(esp) = obj.gcd_divisor;
                eax = level1_plus_count ();
                if (eax == 0) {
                    goto label_0;
                }
                eax = ebp + 0x18;
                *((esp + 0x10)) = eax;
                eax = len_d;
                *((esp + 0xc)) = eax;
                *((esp + 8)) = 0x80f9280;
                eax = *((ebp + 0x14));
                *((esp + 4)) = eax;
                eax = *((ebp + 0x10));
                *(esp) = eax;
                eax = poly_div ();
                if (eax != 2) {
                    if (*(obj.debug_level) <= 0) {
                        goto label_0;
                    }
                    *((esp + 0xc)) = "Polynomial GCD found, but smaller divide failed in poly2_gcd().";
                    *((esp + 8)) = 0x807277d;
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                    ebx = 0;
                    goto label_1;
                }
                eax = len_d;
                eax <<= 4;
                eax = trhs;
                memmove (eax, 0x80f9280, eax);
                eax = len_d;
                *(obj.n_trhs) = eax;
                eax = n_tlhs;
                if (eax > 0x7530) {
                    goto label_0;
                }
                *((esp + 0xc)) = 0x75300;
                eax <<= 4;
                *((esp + 8)) = eax;
                eax = tlhs;
                *((esp + 4)) = eax;
                *(esp) = obj.gcd_divisor;
                memmove_chk ();
                eax = n_tlhs;
                *(obj.len_d) = eax;
                eax = n_trhs;
                eax <<= 4;
                eax = trhs;
                eax = tlhs;
                memmove (eax, eax, eax);
                eax = n_trhs;
                *(obj.n_tlhs) = eax;
                edx = ebp + 0x18;
                *((esp + 0x10)) = edx;
                *((esp + 0xc)) = eax;
                eax = tlhs;
                *((esp + 8)) = eax;
                eax = *((ebp + 0xc));
                *((esp + 4)) = eax;
                eax = *((ebp + 8));
                *(esp) = eax;
                eax = poly_div ();
                if (eax != 2) {
                    if (*(obj.debug_level) <= 0) {
                        goto label_0;
                    }
                    *((esp + 0xc)) = "Polynomial GCD found, but larger divide failed in poly2_gcd().";
                    *((esp + 8)) = 0x807277d;
                    *((esp + 4)) = 1;
                    eax = gfp;
                    *(esp) = eax;
                    fprintf_chk ();
                    ebx = 0;
                    goto label_1;
                }
                eax = len_d;
                eax <<= 4;
                eax = trhs;
                memmove (eax, 0x80f9280, eax);
                eax = len_d;
                *(obj.n_trhs) = eax;
            } else {
                *(obj.n_trhs) = 1;
                eax = trhs;
                edx = one_token;
                *(eax) = edx;
                edx = .comment;
                *((eax + 4)) = edx;
                edx = .comment;
                *((eax + 8)) = edx;
                edx = .comment;
                *((eax + 0xc)) = edx;
            }
            if (*(obj.debug_level) <= 2) {
                goto label_1;
            }
            *((esp + 0xc)) = "poly2_gcd() successful.";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
    } else {
label_0:
        ebx = 0;
    }
label_1:
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80516e8 */
#include <stdint.h>
 
uint32_t dbg_fraction_cmd (void) {
    int32_t j;
    int32_t i;
    char * cp;
    int32_t var_4h;
    int32_t var_8h;
    /* int fraction_cmd(char * cp); */
    eax = ebp - 0x10;
    eax = ebp - 0xc;
    eax = ebp + 8;
    eax = get_range_eol (eax, eax, eax);
    if (eax == 0) {
        goto label_0;
    }
    eax = *((ebp - 0xc));
    if (eax > *((ebp - 0x10))) {
        goto label_1;
    }
    ebx = n_lhs;
    esi = lhs;
    do {
        if (*((ebx + eax*4)) != 0) {
            edx = eax*4 + obj_n_lhs;
            eax = *((esi + eax*4));
            simple_frac_side (eax, edx);
            eax = *((ebp - 0xc));
            edx = eax*4 + obj_n_rhs;
            eax = *((eax*4 + obj.rhs));
            simple_frac_side (eax, edx);
            eax = *((ebp - 0xc));
            eax = return_result (eax);
            if (eax == 0) {
                goto label_0;
            }
        }
        eax = *((ebp - 0xc));
        eax++;
        *((ebp - 0xc)) = eax;
    } while (*((ebp - 0x10)) >= eax);
    goto label_1;
label_0:
    eax = 0;
    goto label_2;
label_1:
    eax = 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80494f0 */
#include <stdint.h>
 
int32_t dbg_usage (void) {
    char * var_4h;
    char * var_8h;
    /* void usage(); */
    *((esp + 8)) = "15.1.1";
    *((esp + 4)) = "\nMathomatic computer algebra system version %s\n\n";
    *(esp) = 1;
    printf_chk ();
    eax = prog_name;
    *((esp + 8)) = eax;
    *((esp + 4)) = "Usage: %s [ options ] [ input_files ]\n\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "Options:\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -b            Enable bold color mode.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -c            Toggle color mode.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -h            Display this help and exit.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -m number     Specify a memory size multiplier.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -q            Set quiet mode (don't display prompts).\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -r            Disable readline.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -s level      Set enforced security level for session.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -t            Set test mode.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -u            Set unbuffered output.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -v            Display version information, then exit.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -w            Wide output mode, sets unlimited width.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "  -x            Enable HTML/XHTML output mode.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "\nPlease refer to the Mathomatic man page for more information.\n";
    *(esp) = 1;
    printf_chk ();
    *((esp + 4)) = "The man page is viewed by typing \"man mathomatic\" in shell.\n";
    *(esp) = 1;
    printf_chk ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804943c */
#include <stdint.h>
 
void dbg_exithandler (void) {
    int32_t sig;
    /* void exithandler(int sig); */
    exit_program (1);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8052e8c */
#include <stdint.h>
 
int32_t dbg_variables_cmd (int32_t i1, token_type * p1, language_list lang_code, long int v1) {
    int32_t imag_flag;
    int32_t var_1f8ch;
    int32_t int_flag;
    int32_t vc;
    int32_t var_1f80h;
    int32_t var_1f7ch;
    int32_t cnt;
    int32_t var_1f74h;
    int32_t var_1f70h;
    long int last_v;
    sort_type[1000] va;
    int32_t j;
    int32_t i;
    char * cp;
    char * nmemb;
    size_t size;
    int32_t const void *);
    ebx = i1;
    ecx = p1;
    edi = lang_code;
    eax = v1;
    /* int variables_cmd(char * cp); */
    *((esp + 4)) = 0x8075a34;
    eax = *((ebp + 8));
    eax = strcmp_tospace (eax);
    if (eax != 0) {
        *((esp + 4)) = 0x80758b4;
        eax = *((ebp + 8));
        eax = strcmp_tospace (eax);
        if (eax != 0) {
            goto label_6;
        }
    }
    eax = *((ebp + 8));
    eax = skip_param (eax);
    *((ebp + 8)) = eax;
    *((ebp - 0x1f88)) = 0;
    *((ebp - 0x1f8c)) = 1;
    goto label_7;
label_6:
    *((esp + 4)) = "java";
    eax = *((ebp + 8));
    eax = strcmp_tospace (eax);
    if (eax == 0) {
        eax = *((ebp + 8));
        eax = skip_param (eax);
        *((ebp + 8)) = eax;
        *((ebp - 0x1f88)) = 0;
        *((ebp - 0x1f8c)) = 2;
    } else {
        *((esp + 4)) = 0x80758bd;
        eax = *((ebp + 8));
        eax = strcmp_tospace (eax);
        if (eax != 0) {
            *((esp + 4)) = "integer";
            eax = *((ebp + 8));
            eax = strcmp_tospace (eax);
            if (eax != 0) {
                *((ebp - 0x1f88)) = 0;
                *((ebp - 0x1f8c)) = 0;
            }
        } else {
            eax = *((ebp + 8));
            eax = skip_param (eax);
            *((ebp + 8)) = eax;
            *((ebp - 0x1f88)) = 1;
            *((ebp - 0x1f8c)) = 1;
        }
    }
label_7:
    eax = ebp - 0x20;
    eax = ebp - 0x1c;
    eax = ebp + 8;
    eax = get_range_eol (eax, eax, eax);
    edx = eax;
    eax = 0;
    if (edx == 0) {
        goto label_8;
    }
    edx = *((ebp - 0x1c));
    *((ebp - 0x1f80)) = edx;
    ecx = *((ebp - 0x20));
    *((ebp - 0x1f7c)) = ecx;
    *((ebp - 0x1f90)) = 0;
    if (edx > ecx) {
        goto label_9;
    }
    esi = edx;
    esi <<= 2;
    ebx = esi + obj_n_lhs;
    eax = esi + obj_rhs;
    *((ebp - 0x1f6c)) = eax;
    edx = esi + obj_lhs;
    *((ebp - 0x1f70)) = edx;
    esi += obj.n_rhs;
    edi = *((ebp - 0x1f80));
label_0:
    ecx = *(ebx);
    if (ecx <= 0) {
        goto label_10;
    }
    eax = *(esi);
    if (eax > 0) {
        ecx = *((ebp - 0x1f6c));
        edx = *(ecx);
        ecx = eax;
    } else {
        eax = *((ebp - 0x1f70));
        edx = *(eax);
    }
    eax = *(eax);
    edx = 0;
    do {
        if (*(eax) == 1) {
            if (*((eax + 8)) == 3) {
                *((ebp - 0x1f90)) = 1;
            }
        } else {
            edx += 2;
            eax += 0x20;
        }
    } while (ecx > edx);
label_10:
    edi++;
    ebx += 4;
    *((ebp - 0x1f6c)) += 4;
    *((ebp - 0x1f70)) += 4;
    esi += 4;
    if (edi <= *((ebp - 0x1f7c))) {
        goto label_0;
    }
label_9:
    *((ebp - 0x1f84)) = 0;
    edx = *((ebp - 0x1f7c));
    if (*((ebp - 0x1f80)) > edx) {
        goto label_11;
    }
    ecx = *((ebp - 0x1f80));
    *((ebp - 0x1f70)) = ecx;
    *((ebp - 0x1f6c)) = 0;
    ebx = 0;
    *((ebp - 0x1f78)) = 0;
    esi = 0xffffffff;
    *((ebp - 0x1f74)) = ecx;
    goto label_5;
label_2:
    *(esp) = "Too many variables to list.";
    error ();
    eax = 0;
    goto label_8;
label_1:
    esi = eax;
label_5:
    eax = *((ebp - 0x1f80));
    edi = *((ebx + eax*4 + obj.n_lhs));
    eax = esi;
    if (edi <= 0) {
        goto label_12;
    }
    ecx = *((ebp - 0x1f74));
    edx = *((ebx + ecx*4 + obj.lhs));
    ecx = 0;
    do {
        if (*(edx) == 1) {
            eax = *((edx + 8));
            if (eax > *((ebp - 0x1f6c))) {
                if (esi == -1) {
                    goto label_13;
                }
                if (esi > eax) {
                    goto label_13;
                }
                if (esi != eax) {
                    goto label_14;
                }
                *((ebp - 0x1f78))++;
                eax = esi;
            }
        } else {
label_14:
            eax = esi;
            goto label_15;
label_13:
            *((ebp - 0x1f78)) = 1;
        }
label_15:
        ecx += 2;
        edx += 0x20;
        if (edi <= ecx) {
            goto label_16;
        }
        esi = eax;
    } while (1);
label_16:
    ecx = *((ebp - 0x1f74));
    edx = *((ebx + ecx*4 + obj.rhs));
    edi = *((ebx + ecx*4 + obj.n_rhs));
    if (edi <= 0) {
        goto label_12;
    }
    ecx = 0;
    do {
        if (*(edx) == 1) {
            esi = *((edx + 8));
            if (esi > *((ebp - 0x1f6c))) {
                if (eax == -1) {
                    goto label_17;
                }
                if (eax > esi) {
                    goto label_17;
                }
                if (eax != esi) {
                    goto label_18;
                }
                *((ebp - 0x1f78))++;
                esi = eax;
            }
        } else {
label_18:
            esi = eax;
            goto label_19;
label_17:
            *((ebp - 0x1f78)) = 1;
        }
label_19:
        ecx += 2;
        edx += 0x20;
        if (edi <= ecx) {
            eax = esi;
        } else {
            eax = esi;
        } while (1);
    }
label_12:
    *((ebp - 0x1f70))++;
    ebx += 4;
    edx = *((ebp - 0x1f7c));
    if (*((ebp - 0x1f70)) <= edx) {
        goto label_1;
    }
    if (eax != -1) {
        ecx = *((ebp - 0x1f84));
        *((ebp + ecx*8 - 0x1f60)) = eax;
        edx = *((ebp - 0x1f78));
        *((ebp + ecx*8 - 0x1f5c)) = edx;
        ecx++;
        *((ebp - 0x1f84)) = ecx;
        if (ecx != 0x3e8) {
            goto label_20;
        }
        goto label_2;
    }
label_11:
    if (*((ebp - 0x1f84)) <= 0) {
        goto label_21;
    }
    ecx = *((ebp - 0x1f84));
    eax = ebp - 0x1f60;
    qsort (sym.vcmp, ecx, 8);
    ebx = 0;
    esi = ebp - 0x1f60;
    edi = *((ebp - 0x1f8c));
    do {
        if (edi != 0) {
            eax = *((esi + ebx*8));
            if (eax <= 3) {
                goto label_22;
            }
            goto label_23;
        }
        eax = *((esi + ebx*8));
        list_var (eax, 0);
        *((esp + 0xc)) = 0x8079800;
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        goto label_22;
label_4:
        *((esp + 8)) = "_Complex ";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
label_3:
        if (*((ebp - 0x1f88)) != 0) {
            *((esp + 0xc)) = obj.var_str;
            *((esp + 8)) = "int %s;\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        } else {
            *((esp + 0xc)) = obj.var_str;
            *((esp + 8)) = "double %s;\n";
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
label_22:
        ebx++;
    } while (ebx < *((ebp - 0x1f84)));
label_21:
    eax = 1;
label_8:
    return eax;
label_23:
    eax = list_var (eax, edi);
    if (*((ebp - 0x1f90)) == 0) {
        goto label_3;
    }
    goto label_4;
label_20:
    *((ebp - 0x1f6c)) = eax;
    eax = *((ebp - 0x1f74));
    *((ebp - 0x1f70)) = eax;
    ebx = 0;
    *((ebp - 0x1f78)) = 0;
    esi = 0xffffffff;
    goto label_5;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8055718 */
#include <stdint.h>
 
int32_t dbg_real_cmd (void) {
    char * cp;
    /* int real_cmd(char * cp); */
    edx = 0;
    eax = *((ebp + 8));
    complex_func ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805a987 */
#include <stdint.h>
 
int32_t dbg_reorder (void) {
    token_type * equation;
    int * np;
    /* int reorder(token_type * equation,int * np); */
    ecx = 0;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    order_recurse (1);
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80570f2 */
#include <stdint.h>
 
int32_t dbg_solve_cmd (int32_t i, int32_t j, int32_t once_through, char * cp1) {
    int32_t plural_flag;
    int32_t var_1040h;
    int32_t var_103ch;
    token_type want;
    int32_t var_1030h;
    int32_t var_102ch;
    int32_t diff_sign;
    long int v;
    char[4096] buf;
    int32_t var_1ch;
    char * cp;
    char * var_4h;
    int32_t var_8h;
    char * var_ch;
    int32_t var_10h;
    int32_t var_14h;
    ebx = i;
    esi = j;
    edi = once_through;
    eax = cp1;
    /* int solve_cmd(char * cp); */
    esi = *((ebp + 8));
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    eax = cur_equation;
    if (eax >= 0) {
        if (eax >= *(obj.n_equations)) {
            goto label_2;
        }
        if (*((eax*4 + obj.n_lhs)) <= 0) {
            goto label_2;
        }
        if (*((eax*4 + obj.n_rhs)) > 0) {
            goto label_3;
        }
    }
label_2:
    *(esp) = "No current equation.";
    error ();
    eax = 0;
    goto label_4;
label_3:
    eax = next_espace ();
    ebx = eax;
    *((esp + 4)) = "verify";
    eax = strcmp_tospace (esi);
    edi = 0;
    if (eax == 0) {
        eax = skip_param (esi);
        esi = eax;
        di = 1;
    }
    *((esp + 4)) = 0x8075d65;
    eax = strcmp_tospace (esi);
    if (eax == 0) {
        eax = skip_param (esi);
        if (*(eax) != 0) {
            esi = eax;
        }
    } else {
        if (*(esi) != 0) {
            goto label_5;
        }
        *((esp + 8)) = 0x50;
        my_strlcpy (obj.prompt_str, "Enter variable to solve for: ");
        eax = ebp - 0x101c;
        eax = get_string (eax, 0x1000);
        esi = eax;
        if (eax == 0) {
            goto label_6;
        }
    }
label_5:
    if (edi == 0) {
        goto label_7;
    }
    eax = ebp - 0x1020;
    eax = parse_var2 (eax, esi);
    if (eax == 0) {
        goto label_6;
    }
    eax = extra_characters (eax);
    if (eax != 0) {
        goto label_6;
    }
    eax = cur_equation;
    copy_espace (eax, ebx);
    *((ebp - 0x1030)) = 1;
    *((ebp - 0x1034)) = 1;
    eax = *((ebp - 0x1020));
    *((ebp - 0x102c)) = eax;
    eax = cur_equation;
    edx = eax*4;
    ecx = edx + obj_n_rhs;
    *((esp + 0x14)) = ecx;
    ecx = *((eax*4 + obj.rhs));
    *((esp + 0x10)) = ecx;
    edx += obj.n_lhs;
    *((esp + 0xc)) = edx;
    eax = *((eax*4 + obj.lhs));
    *((esp + 8)) = eax;
    *((esp + 4)) = 1;
    eax = ebp - 0x1034;
    *(esp) = eax;
    eax = solve_sub ();
    if (eax <= 0) {
        goto label_8;
    }
    eax = cur_equation;
    return_result (eax);
    eax = cur_equation;
    eax = compare_es (eax, ebx);
    if (eax == 0) {
        edx = cur_equation;
        eax = *((edx*4 + obj.n_rhs));
        if (eax > 0) {
            goto label_9;
        }
        goto label_10;
    }
    if (*(obj.debug_level) >= 0) {
        *((esp + 0xc)) = "Nothing was done, so no need to verify solution.";
        *((esp + 8)) = 0x807277d;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    *((ebx*4 + obj.n_lhs)) = 0;
    *((ebx*4 + obj.n_rhs)) = 0;
    eax = 1;
    goto label_4;
label_9:
    ecx = *((edx*4 + obj.rhs));
    esi = 0;
    do {
        if (*(ecx) == 1) {
            edi = *((ecx + 8));
            edi &= 0x3fff;
            if (edi != 4) {
                goto label_11;
            }
            *((ebp - 0x1044)) = 1;
            goto label_12;
        }
label_11:
        esi += 2;
        ecx += 0x20;
    } while (esi < eax);
label_10:
    *((ebp - 0x1044)) = 0;
label_12:
    ecx = ebx*4;
    *((ebp - 0x103c)) = ecx;
    ecx += obj.n_lhs;
    *((ebp - 0x1040)) = ecx;
    ecx = *((ebp - 0x1020));
    *((esp + 0x10)) = ecx;
    *((esp + 0xc)) = eax;
    esi = rhs;
    eax = *((esi + edx*4));
    *((esp + 8)) = eax;
    eax = *((ebp - 0x1040));
    *((esp + 4)) = eax;
    edi = lhs;
    eax = *((edi + ebx*4));
    subst_var_with_exp (eax);
    eax = cur_equation;
    edx = *((ebp - 0x103c));
    edx += obj.n_rhs;
    *((ebp - 0x103c)) = edx;
    edx = *((ebp - 0x1020));
    *((esp + 0x10)) = edx;
    edx = *((eax*4 + obj.n_rhs));
    *((esp + 0xc)) = edx;
    eax = *((esi + eax*4));
    *((esp + 8)) = eax;
    ecx = *((ebp - 0x103c));
    *((esp + 4)) = ecx;
    eax = *((esi + ebx*4));
    subst_var_with_exp (eax);
    eax = *((ebp - 0x1040));
    *((esp + 4)) = eax;
    eax = *((edi + ebx*4));
    *(esp) = eax;
    calc_simp ();
    edx = *((ebp - 0x103c));
    *((esp + 4)) = edx;
    eax = *((esi + ebx*4));
    *(esp) = eax;
    calc_simp ();
    edi = 0;
    esi = n_lhs;
    do {
        eax = *((esi + ebx*4));
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        eax = exp_contains_infinity (eax);
        if (eax == 0) {
            eax = *((ebx*4 + obj.n_rhs));
            *((esp + 4)) = eax;
            eax = *((ebx*4 + obj.rhs));
            eax = exp_contains_infinity (eax);
            if (eax == 0) {
                goto label_13;
            }
        }
        eax = 1;
        goto label_14;
label_0:
        if (*((ebp - 0x1024)) == 0) {
            if (*((ebp - 0x1044)) != 0) {
                *((esp + 4)) = "Solutions verified.\n";
                *(esp) = 1;
                printf_chk ();
            } else {
                *((esp + 4)) = "Solution verified.\n";
                *(esp) = 1;
                printf_chk ();
            }
            *((ebx*4 + obj.n_lhs)) = 0;
            *((ebx*4 + obj.n_rhs)) = 0;
            eax = 1;
            goto label_4;
        }
label_1:
        eax = 0;
label_14:
        if (eax != 0) {
            goto label_15;
        }
        if (edi != 0) {
            goto label_15;
        }
        eax = symblify;
        *(obj.symb_flag) = eax;
        *((esp + 0xc)) = 0;
        *((esp + 8)) = 1;
        ecx = *((ebp - 0x1040));
        eax = *((ebx*4 + obj.lhs));
        simpa_side (eax, ecx);
        *((esp + 0xc)) = 0;
        *((esp + 8)) = 1;
        eax = *((ebp - 0x103c));
        eax = *((ebx*4 + obj.rhs));
        simpa_side (eax, eax);
        *(obj.symb_flag) = 0;
        di = 1;
    } while (1);
label_15:
    *(esp) = "Solution might be incorrect.";
    error ();
    *((ebx*4 + obj.n_lhs)) = 0;
    *((ebx*4 + obj.n_rhs)) = 0;
    eax = 2;
    goto label_4;
label_8:
    *((esp + 4)) = "Solve failed.\n";
    *(esp) = 1;
    printf_chk ();
    goto label_16;
label_7:
    eax = parse_equation (ebx, esi);
    if (eax != 0) {
        eax = cur_equation;
        *((esp + 4)) = eax;
        eax = solve_espace (ebx);
        if (eax != 0) {
            eax = cur_equation;
            return_result (eax);
        }
    } else {
label_16:
        *((ebx*4 + obj.n_lhs)) = 0;
        *((ebx*4 + obj.n_rhs)) = 0;
        eax = 0;
        goto label_4;
label_6:
        eax = 0;
    }
label_4:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (eax == 0) {
        goto label_17;
    }
    goto label_18;
label_13:
    ecx = ebp - 0x1024;
    *((esp + 0x10)) = ecx;
    eax = *((ebx*4 + obj.n_rhs));
    *((esp + 0xc)) = eax;
    eax = *((ebx*4 + obj.rhs));
    *((esp + 8)) = eax;
    eax = *((esi + ebx*4));
    *((esp + 4)) = eax;
    eax = *((ebx*4 + obj.lhs));
    *(esp) = eax;
    eax = se_compare ();
    if (eax != 0) {
        goto label_0;
    }
    goto label_1;
label_18:
    stack_chk_fail ();
label_17:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805cba1 */
#include <stdint.h>
 
int32_t dbg_integer_root_simp (int32_t root, int32_t k, int32_t i, int32_t j) {
    int32_t var_44h;
    void * s1;
    int32_t var_3ch;
    double d2;
    int32_t modified;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    token_type * equation;
    int * np;
    void * s2;
    size_t n;
    ebx = root;
    ecx = k;
    esi = i;
    eax = j;
    /* int integer_root_simp(token_type * equation,int * np); */
    edx = *((ebp + 0xc));
    eax = *(edx);
    edx = eax - 2;
    esi = 1;
    *((ebp - 0x2c)) = 0;
    if (edx <= 1) {
        goto label_2;
    }
label_1:
    edi = esi;
    edi <<= 4;
    edi += *((ebp + 8));
    if (*((edi + 8)) != 6) {
        goto label_3;
    }
    ecx = esi;
    ecx <<= 4;
    ebx = *((ebp + 8));
    ecx = ecx + ebx - 0x10;
    *((ebp - 0x28)) = ecx;
    ecx = *((ecx + 4));
    *((ebp - 0x24)) = ecx;
    if (ecx != *((edi + 4))) {
        goto label_3;
    }
    ecx = esi;
    ecx <<= 4;
    ecx = ecx + ebx + 0x20;
    ebx = *((ecx + 4));
    *((ebp - 0x38)) = ebx;
    ebx = *((ebp - 0x24));
    ebx++;
    if (*((ebp - 0x38)) != ebx) {
        goto label_3;
    }
    if (*((ecx + 8)) != 4) {
        goto label_3;
    }
    ecx = esi;
    ecx <<= 4;
    ebx = *((ebp + 8));
    ecx = ecx + ebx + 0x30;
    *((ebp - 0x3c)) = ecx;
    ebx = *((ebp - 0x38));
    if (ebx != *((ecx + 4))) {
        goto label_3;
    }
    ecx = *((ebp - 0x28));
    if (*(ecx) != 0) {
        goto label_3;
    }
    ecx = esi;
    ecx <<= 4;
    ebx = *((ebp + 8));
    ecx = ecx + ebx + 0x10;
    *((ebp - 0x40)) = ecx;
    if (*(ecx) != 0) {
        goto label_3;
    }
    ecx = *((ebp - 0x3c));
    if (*(ecx) != 0) {
        goto label_3;
    }
    ebx = esi + 4;
    *((ebp - 0x44)) = ebx;
    if (ebx < eax) {
        eax = ebx;
        eax <<= 4;
        ecx = *((ebp - 0x24));
        edx = *((ebp + 8));
        if (ecx <= *((eax + edx + 4))) {
            goto label_3;
        }
    }
    ebx = *((ebp - 0x40));
    *(fp_stack--) = *((ebx + 8));
    *((ebp - 0x38)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x38));
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_4;
    }
    *(fp_stack--) = *(0x8076e04);
    fp_tmp_1 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_1;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_3;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x38));
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (fp_stack[0] == fp_stack[1]);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_5;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp - 0x38));
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
label_5:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_3;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_3;
    }
    eax = errno_location ();
    ebx = eax;
    *(eax) = 0;
    *(fp_stack--) = *((ebp - 0x38));
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp - 0x28));
    *(fp_stack--) = *((eax + 8));
    *(esp) = fp_stack[0];
    fp_stack--;
    pow ();
    if (*(ebx) != 0) {
        goto label_6;
    }
    edx = *((ebp - 0x3c));
    *(fp_stack--) = *((edx + 8));
    *(fp_stack--) = *(0x8076e04);
    fp_tmp_3 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_3;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_7;
    }
    *(fp_stack--) = *(0x8072058);
    fp_stack--;
    if (fp_stack[0] > fp_stack[1]) {
        goto label_8;
    }
    eax = *((ebp - 0x1a));
    ah = 0xc;
    *((ebp - 0x1c)) = ax;
    *((ebp - 0x20)) = fp_stack[0];
    ebx = *((ebp - 0x20));
    *((ebp - 0x20)) = ebx;
    *(fp_stack--) = *((ebp - 0x20));
    fp_tmp_4 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_4;
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        goto label_9;
    }
    if (fp_stack[0] == fp_stack[1]) {
        goto label_10;
    }
    if (ebx <= 1) {
        goto label_11;
    }
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = factor_one ();
    if (eax == 0) {
        goto label_3;
    }
    ecx = uno;
    *((ebp - 0x3c)) = ecx;
    *(fp_stack--) = 1.0;
    *((ebp - 0x38)) = fp_stack[0];
    fp_stack--;
    eax = 0;
    goto label_12;
    do {
        *(fp_stack--) = *((ebp - 0x38));
        fp_stack[0] *= *((edx*8 + obj.unique));
        *((ebp - 0x38)) = fp_stack[0];
        fp_stack--;
        ecx -= ebx;
        *((edx*4 + obj.ucnt)) = ecx;
        goto label_13;
label_0:
        edx = eax;
label_13:
        ecx = *((eax*4 + obj.ucnt));
    } while (ebx <= ecx);
    eax++;
label_12:
    if (eax < *((ebp - 0x3c))) {
        goto label_0;
    }
    *(fp_stack--) = 1.0;
    *(fp_stack--) = *((ebp - 0x38));
    fp_stack--;
    fp_stack++;
    if (fp_stack[0] != fp_stack[1]) {
        if (fp_stack[0] == fp_stack[1]) {
            goto label_3;
        }
    }
    edx = *((ebp + 0xc));
    eax = *(edx);
    eax += 2;
    if (eax > *(obj.n_tokens)) {
        error_huge ();
    }
    *(fp_stack--) = 1.0;
    ecx = *((ebp - 0x40));
    *((ecx + 8)) = fp_stack[0];
    fp_stack--;
    multiply_out_unique ();
    eax = *((ebp - 0x28));
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    edx = esi - 1;
    eax = edx;
    eax <<= 4;
    ecx = *((ebp + 8));
    eax = ecx + eax + 4;
    while (edx < *((ebp - 0x44))) {
        *(eax)++;
        edx++;
        eax += 0x10;
    }
    ebx = *((ebp + 0xc));
    eax = *(ebx);
    eax++;
    eax -= esi;
    eax <<= 4;
    eax = *((ebp - 0x28));
    edx = *((ebp - 0x40));
    memmove (edx, eax, eax);
    *(ebx) += 2;
    ecx = *((ebp - 0x24));
    *((edi + 4)) = ecx;
    *(edi) = 2;
    *((edi + 8)) = 3;
    ebx = *((ebp - 0x28));
    *((ebx + 4)) = ecx;
    *(ebx) = 0;
    *(fp_stack--) = *((ebp - 0x38));
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    esi += 2;
    *((ebp - 0x2c)) = 1;
    goto label_3;
label_4:
    fp_stack++;
    goto label_3;
label_6:
    fp_stack++;
    goto label_3;
label_7:
    fp_stack++;
    fp_stack++;
    goto label_3;
label_8:
    fp_stack++;
    fp_stack++;
    goto label_3;
label_9:
    fp_stack++;
    goto label_3;
label_10:
    fp_stack++;
    goto label_3;
label_11:
    fp_stack++;
label_3:
    esi += 2;
    edx = *((ebp + 0xc));
    eax = *(edx);
    edx = eax - 2;
    if (edx > esi) {
        goto label_1;
    }
label_2:
    eax = *((ebp - 0x2c));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804e9f6 */
#include <stdint.h>
 
uint32_t dbg_process_parse (int32_t arg_8h, int32_t equals_flag, unsigned char const * __s1, int32_t i, char * ep) {
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_1ah;
    char * cp;
    char * s2;
    size_t * n;
    char * var_ch;
    ecx = equals_flag;
    esi = __s1;
    edi = i;
    eax = ep;
    /* int process_parse(int n,char * cp); */
    ebx = *((ebp + 8));
    esi = *((ebp + 0xc));
    eax = parse_equation (ebx, esi);
    if (eax == 0) {
        goto label_0;
    }
    if (esi >= eax) {
        goto label_1;
    }
    edx = esi;
    if (*(esi) != 0x3d) {
        goto label_2;
    }
    goto label_3;
    do {
        if (*(edx) == 0x3d) {
            goto label_3;
        }
label_2:
        edx++;
    } while (eax > edx);
    goto label_1;
label_3:
    edx = 1;
    goto label_4;
label_1:
    edx = 0;
label_4:
    eax = *((ebx*4 + obj.n_lhs));
    if (eax == 0) {
        if (*((ebx*4 + obj.n_rhs)) != 0) {
            goto label_5;
        }
        eax = 0x80727bc;
        edx = *(esi);
        if (dl != *(eax)) {
            goto label_6;
        }
        edx = *((esi + 1));
        if (dl != *((eax + 1))) {
            goto label_6;
        }
        eax = cur_equation;
        if (*((eax*4 + obj.n_lhs)) <= 0) {
            goto label_6;
        }
        if (*((eax*4 + obj.n_rhs)) <= 0) {
            goto label_6;
        }
        if (*(obj.debug_level) >= 0) {
            *((esp + 0xc)) = "Swapping both sides of the current equation...";
            *((esp + 8)) = 0x807277d;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        ebx = cur_equation;
        edi = n_lhs;
        eax = *((edi + ebx*4));
        *((ebp - 0x24)) = eax;
        eax <<= 4;
        *((ebp - 0x28)) = eax;
        esi = lhs;
        eax = *((esi + ebx*4));
        eax = tes;
        memmove (eax, eax, eax);
        eax = *((ebx*4 + obj.n_rhs));
        *((edi + ebx*4)) = eax;
        eax <<= 4;
        edi = rhs;
        eax = *((edi + ebx*4));
        eax = *((esi + ebx*4));
        memmove (eax, eax, eax);
        eax = *((ebp - 0x24));
        *((ebx*4 + obj.n_rhs)) = eax;
        eax = *((ebp - 0x28));
        eax = tes;
        eax = *((edi + ebx*4));
        memmove (eax, eax, eax);
        eax = cur_equation;
        eax = return_result (eax);
        goto label_7;
    }
    if (*((ebx*4 + obj.n_rhs)) != 0) {
        goto label_8;
    }
label_5:
    if (edx == 0) {
        if (*(obj.autosolve) == 0) {
            goto label_9;
        }
    }
    if (eax == 1) {
        ecx = *((ebx*4 + obj.lhs));
        esi = *(ecx);
        if (esi == 0) {
            *(fp_stack--) = *((ecx + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_0 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_0;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] == fp_stack[1]) {
                goto label_10;
            }
            if (fp_stack[0] == fp_stack[1]) {
                goto label_11;
            }
        } else {
            if (esi != 1) {
                goto label_10;
            }
            ecx = *((ecx + 8));
            ecx &= 0x3fff;
            if (ecx > 4) {
                goto label_11;
            }
            if (edx != 0) {
                goto label_11;
            }
        }
    }
label_10:
    if (*((ebx*4 + obj.n_rhs)) == 1) {
        ecx = *((ebx*4 + obj.rhs));
        edx = *(ecx);
        if (edx == 0) {
            *(fp_stack--) = *((ecx + 8));
            *(fp_stack--) = 0.0;
            fp_tmp_1 = fp_stack[1];
            fp_stack[1] = fp_stack[0];
            fp_stack[0] = fp_tmp_1;
            fp_stack--;
            fp_stack++;
            if (fp_stack[0] == fp_stack[1]) {
                goto label_12;
            }
            if (fp_stack[0] == fp_stack[1]) {
                goto label_11;
            }
            goto label_12;
        }
        if (edx != 1) {
            goto label_9;
        }
label_11:
        eax = cur_equation;
        *((esp + 4)) = eax;
        eax = solve_espace (ebx);
        edx = eax;
        eax = 0;
        if (edx == 0) {
            goto label_7;
        }
        eax = cur_equation;
        return_result (eax);
        goto label_7;
    }
label_9:
    if (*((ebx*4 + obj.n_rhs)) != 0) {
label_12:
        *((ebx*4 + obj.n_lhs)) = 1;
        eax = *((ebx*4 + obj.lhs));
        edx = zero_token;
        *(eax) = edx;
        edx = .comment;
        *((eax + 4)) = edx;
        edx = .comment;
        *((eax + 8)) = edx;
        edx = .comment;
        *((eax + 0xc)) = edx;
        goto label_8;
    }
    if (*(obj.autoselect) == 0) {
        goto label_13;
    }
    if (eax != 1) {
        goto label_13;
    }
    eax = *((ebx*4 + obj.lhs));
    if (*(eax) != 0) {
        goto label_13;
    }
    *(fp_stack--) = *((eax + 8));
    *(fp_stack--) = 1.0;
    *(fp_stack--) = fp_stack[1];
    do {
        fp_stack[0] %= fp_stack[1];
        ax = fp_status;
        __asm ("sahf");
    } while (*(eax) == 0);
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] != fp_stack[0]) {
        if (fp_stack[0] == fp_stack[0]) {
            goto label_14;
        }
        fp_stack++;
    } else {
        fp_stack++;
    }
    *(fp_stack--) = 1.0;
    *((esp + 8)) = fp_stack[0];
    fp_stack--;
    *(esp) = fp_stack[0];
    fp_stack--;
    fmod ();
    goto label_15;
label_14:
    fp_stack[1] = fp_stack[0];
    fp_stack--;
label_15:
    *(fp_stack--) = 0.0;
    fp_tmp_2 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_2;
    fp_stack--;
    if (fp_stack[0] == fp_stack[1]) {
        if (fp_stack[0] != fp_stack[1]) {
            eax = *((ebx*4 + obj.lhs));
            *(fp_stack--) = *((eax + 8));
            fp_stack[1] = fp_stack[0];
            fp_stack--;
            if (fp_stack[0] > fp_stack[1]) {
                *(fp_stack--) = *(obj.n_equations);
                fp_stack--;
                if (fp_stack[0] >= fp_stack[1]) {
                    fp_stack[0] -= *(0x8075170);
                    eax = *((ebp - 0x1a));
                    ah = 0xc;
                    *((ebp - 0x1c)) = ax;
                    *((ebp - 0x20)) = fp_stack[0];
                    fp_stack--;
                    eax = *((ebp - 0x20));
                    *(obj.cur_equation) = eax;
                    *((ebx*4 + obj.n_lhs)) = 0;
                    return_result (eax);
                    eax = 1;
                } else {
                    fp_stack++;
                } else {
                    fp_stack++;
                } else {
                    fp_stack++;
                }
            } else {
                fp_stack++;
            }
        }
label_13:
        if (*(obj.autocalc) != 0) {
            eax = *((ebx*4 + obj.n_lhs));
            if (eax != 0) {
                *((esp + 4)) = eax;
                eax = *((ebx*4 + obj.lhs));
                eax = exp_is_numeric (eax);
                if (eax == 0) {
                    goto label_8;
                }
                esi = n_lhs;
                eax = *((esi + ebx*4));
                eax <<= 4;
                eax = *((ebx*4 + obj.lhs));
                eax = *((ebx*4 + obj.rhs));
                memmove (eax, eax, eax);
                eax = *((esi + ebx*4));
                *((ebx*4 + obj.n_rhs)) = eax;
            }
            eax = lhs;
            edx = *((eax + ebx*4));
            *((edx + 4)) = 1;
            edx = *((eax + ebx*4));
            *(edx) = 1;
            *((esp + 4)) = "answer";
            eax = *((eax + ebx*4));
            eax += 8;
            parse_var (eax);
            esi = n_lhs;
            *((esi + ebx*4)) = 1;
            edi = cur_equation;
            *(obj.cur_equation) = ebx;
            calculate_cmd (0x80757fe);
            *(obj.cur_equation) = edi;
            *((esi + ebx*4)) = 0;
            *((ebx*4 + obj.n_rhs)) = 0;
            eax = 1;
        } else {
label_8:
            *(obj.cur_equation) = ebx;
            return_result (ebx);
            goto label_7;
label_0:
            *((ebx*4 + obj.n_lhs)) = 0;
            *((ebx*4 + obj.n_rhs)) = 0;
            eax = 0;
            goto label_7;
label_6:
            eax = 1;
        }
    }
label_7:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80506f5 */
#include <stdint.h>
 
uint32_t dbg_isvarchar (int32_t arg_8h, int32_t ch) {
    int32_t c;
    ebx = ch;
    /* int isvarchar(int ch); */
    ebx = *((ebp + 8));
    if (ebx != 0x5f) {
        if (ebx != 0) {
            eax = strchr (obj.special_variable_characters, ebx);
            if (eax != 0) {
                goto label_0;
            }
        }
        eax = ctype_b_loc ();
        eax = *(eax);
        eax = *((eax + ebx*2));
        eax >>= 0xa;
        eax &= 1;
    } else {
label_0:
        eax = 1;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a25f */
#include <stdint.h>
 
uint32_t dbg_level1_plus_count (void) {
    int32_t var_8h;
    int32_t var_4h;
    token_type * p1;
    int32_t n1;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    /* int level1_plus_count(token_type * p1,int n1); */
    *((ebp - 8)) = ebx;
    *((ebp - 4)) = esi;
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    *((esp + 4)) = ebx;
    eax = min_level (esi);
    level_plus_count (esi, ebx, eax);
    ebx = *((ebp - 8));
    esi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x807125f */
#include <stdint.h>
 
int32_t dbg_display_unique (int32_t i) {
    int32_t var_4h;
    char * var_8h;
    int32_t var_ch;
    ebx = i;
    /* void display_unique(); */
    multiply_out_unique ();
    *((esp + 0xc)) = fp_stack[0];
    fp_stack--;
    *((esp + 8)) = 0x8077c70;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    ebx = 0;
    esi = unique;
    edi = ucnt;
    while (ebx < *(obj.uno)) {
        *(fp_stack--) = *((esi + ebx*8));
        *((esp + 0xc)) = fp_stack[0];
        fp_stack--;
        *((esp + 8)) = "%.0f";
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
        eax = *((edi + ebx*4));
        if (eax > 1) {
            *((esp + 0xc)) = eax;
            *((esp + 8)) = 0x8077c78;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
        ebx++;
        if (ebx < *(obj.uno)) {
            *((esp + 8)) = 0x8077c7c;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            fprintf_chk ();
        }
    }
    *((esp + 8)) = 0x80757fd;
    *((esp + 4)) = 1;
    eax = gfp;
    *(esp) = eax;
    fprintf_chk ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805277e */
#include <stdint.h>
 
int32_t dbg_copy_cmd (int32_t arg_8h, int32_t i1, int32_t k) {
    char * cp;
    int32_t j;
    int32_t i;
    char[100] exists;
    int32_t canary;
    int32_t var_4h;
    int32_t var_8h;
    ebx = i1;
    edi = k;
    /* int copy_cmd(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x8c)) = eax;
    eax = *(gs:0x14);
    *((ebp - 0x1c)) = eax;
    eax = 0;
    eax = ebp - 0x88;
    eax = ebp - 0x84;
    eax = ebp - 0x8c;
    eax = get_range_eol (eax, eax, eax);
    if (eax == 0) {
        goto label_0;
    }
    eax = 0;
    edx = ebp - 0x80;
    do {
        *((edx + eax)) = 0;
        eax++;
    } while (eax != 0x64);
    ebx = *((ebp - 0x84));
    edi = *((ebp - 0x88));
    if (ebx > edi) {
        goto label_1;
    }
    edx = ebx*4 + obj_n_lhs;
    esi = ebp + ebx - 0x80;
    ecx = esi;
    eax = ebx;
    do {
        if (*(edx) > 0) {
            *(ecx) = 1;
        }
        eax++;
        edx += 4;
        ecx++;
    } while (eax <= edi);
    do {
        if (*(esi) != 0) {
            eax = next_espace ();
            edi = eax;
            copy_espace (ebx, eax);
            eax = return_result (edi);
            if (eax == 0) {
                goto label_0;
            }
        }
        ebx++;
        esi++;
    } while (*((ebp - 0x88)) >= ebx);
    goto label_1;
label_0:
    eax = 0;
    goto label_2;
label_1:
    eax = 1;
label_2:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*((ebp - 0x88)) != ebx) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806fc38 */
#include <stdint.h>
 
uint32_t dbg_list1_sub (int32_t arg_8h, char * arg_ch, int32_t n, int32_t len, int32_t export_flag) {
    int32_t var_1ch;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    int32_t var_sp_4h;
    char * var_sp_8h;
    int32_t var_sp_ch;
    ebx = n;
    esi = len;
    edi = export_flag;
    /* int list1_sub(int n,int export_flag); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    ebx = *((ebp + 8));
    edi = *((ebp + 0xc));
    esi = 0;
    if (*((ebx*4 + obj.n_lhs)) > 0) {
        if (edi == 0) {
            if (*(obj.high_prec) == 0) {
                eax = ebx + 1;
                *((esp + 0xc)) = eax;
                *((esp + 8)) = "#%d: ";
                *((esp + 4)) = 1;
                eax = gfp;
                *(esp) = eax;
                eax = fprintf_chk ();
                esi = eax;
            }
        } else {
            esi = 0;
        }
        *((esp + 8)) = edi;
        eax = *((ebx*4 + obj.n_lhs));
        *((esp + 4)) = eax;
        eax = *((ebx*4 + obj.lhs));
        *(esp) = eax;
        list_proc ();
        esi = eax + esi;
        if (*((ebx*4 + obj.n_rhs)) != 0) {
            *((esp + 8)) = 0x80759cf;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            *((ebp - 0x1c)) = eax;
            *((esp + 8)) = edi;
            eax = *((ebx*4 + obj.n_rhs));
            *((esp + 4)) = eax;
            eax = *((ebx*4 + obj.rhs));
            *(esp) = eax;
            eax = list_proc ();
            eax += *((ebp - 0x1c));
            esi += eax;
        }
        if (edi == 1) {
            *((esp + 8)) = 0x8077a56;
            *((esp + 4)) = 1;
            eax = gfp;
            *(esp) = eax;
            eax = fprintf_chk ();
            esi += eax;
        }
        *((esp + 8)) = 0x80757fd;
        *((esp + 4)) = 1;
        eax = gfp;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = esi;
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070a10 */
#include <stdint.h>
 
int32_t dbg_multiply_out_unique (int32_t i, int32_t j) {
    edx = i;
    eax = j;
    /* double multiply_out_unique(); */
    ebx = uno;
    if (ebx <= 0) {
        goto label_1;
    }
    ecx = 0;
    *(fp_stack--) = 1.0;
    esi = ucnt;
    edi = unique;
    goto label_2;
    do {
label_0:
        fp_stack[1] *= fp_stack[0];
        eax++;
    } while (eax != edx);
    fp_stack++;
    do {
        ecx++;
        if (ecx == ebx) {
            goto label_3;
        }
label_2:
        edx = *((esi + ecx*4));
    } while (edx <= 0);
    *(fp_stack--) = *((edi + ecx*8));
    eax = 0;
    goto label_0;
label_1:
    *(fp_stack--) = 1.0;
label_3:
    esi = ebx;
    edi = ebx;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d8b6 */
#include <stdint.h>
 
int32_t dbg_complex_mult (int32_t arg_8h) {
    complexs a;
    complexs b;
    /* complexs complex_mult(complexs a,complexs b); */
    eax = *((ebp + 8));
    *(fp_stack--) = *((ebp + 0xc));
    *(fp_stack--) = *((ebp + 0x14));
    *(fp_stack--) = *((ebp + 0x1c));
    *(fp_stack--) = *((ebp + 0x24));
    *(fp_stack--) = fp_stack[3];
    fp_stack[0] *= fp_stack[1];
    *(fp_stack--) = fp_stack[3];
    fp_stack[0] *= fp_stack[3];
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *((eax + 8)) = fp_stack[0];
    fp_stack--;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[0] *= fp_stack[3];
    fp_stack++;
    fp_stack[0] *= fp_stack[1];
    fp_stack++;
    fp_stack[0] -= fp_stack[1];
    fp_stack++;
    *(eax) = fp_stack[0];
    fp_stack--;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806b348 */
#include <stdint.h>
 
int32_t dbg_int_dispatch (void * arg_8h, char * arg_ch, int32_t arg_14h, int * np, token_type * equation, int32_t j, int32_t i) {
    long int v;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    ebx = np;
    esi = equation;
    edi = j;
    eax = i;
    /* int int_dispatch(token_type * equation,int * np,long int v,int (*)() func); */
    esi = *((ebp + 8));
    ebx = *((ebp + 0xc));
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    make_powers ();
    edi = 0;
    eax = 1;
    if (*(ebx) <= 1) {
label_1:
        edx = *((ebp + 0x10));
        eax = uint32_t (*ebp + 0x14)(uint32_t, uint32_t, uint32_t) (edx, ebx, edi);
        goto label_2;
    }
label_0:
    edx = eax;
    edx <<= 4;
    edx = esi + edx;
    if (*((edx + 4)) != 1) {
        goto label_3;
    }
    edx = *((edx + 8));
    edx--;
    if (edx > 1) {
        goto label_3;
    }
    edx = *((ebp + 0x10));
    eax = uint32_t (*ebp + 0x14)(uint32_t, uint32_t, uint32_t) (edx, ebx, edi);
    if (eax == 0) {
        goto label_4;
    }
    eax = edi + 1;
    ecx = *(ebx);
    if (eax >= ecx) {
        goto label_5;
    }
    edx = eax;
    edx <<= 4;
    if (*((edx + esi + 4)) != 1) {
        goto label_6;
    }
    while (eax < ecx) {
        edi = *(edx);
        edx += 0x20;
        if (edi == 1) {
            edi = eax + 1;
            goto label_3;
label_6:
            edi <<= 4;
            edx = esi + edi + 0x34;
        }
        eax += 2;
    }
    goto label_5;
label_3:
    eax += 2;
    if (*(ebx) > eax) {
        goto label_0;
    }
    goto label_1;
label_4:
    eax = 0;
    goto label_2;
label_5:
    eax = 1;
label_2:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x805b96d */
#include <stdint.h>
 
int32_t dbg_se_compare (int32_t l1, int32_t l2) {
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    token_type * p1;
    int32_t n1;
    token_type * p2;
    int32_t n2;
    int * diff_signp;
    int32_t var_sp_4h;
    int32_t var_sp_8h;
    int32_t var_sp_ch;
    edi = l1;
    eax = l2;
    /* int se_compare(token_type * p1,int n1,token_type * p2,int n2,int * diff_signp); */
    *((ebp - 0xc)) = ebx;
    *((ebp - 8)) = esi;
    *((ebp - 4)) = edi;
    esi = *((ebp + 0x10));
    ebx = *((ebp + 0x14));
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 8));
    eax = min_level (eax);
    edi = eax;
    *((esp + 4)) = ebx;
    eax = min_level (esi);
    edx = *((ebp + 0x18));
    *((esp + 0xc)) = edx;
    *((esp + 8)) = eax;
    *((esp + 4)) = ebx;
    *(esp) = esi;
    ecx = edi;
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    compare_recurse ();
    ebx = *((ebp - 0xc));
    esi = *((ebp - 8));
    edi = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8070529 */
#include <stdint.h>
 
int32_t dbg_my_round (int32_t arg_8h, int32_t arg_ch) {
    double d1;
    int32_t var_ch;
    int32_t var_8h;
    /* double my_round(double d1); */
    eax = *((ebp + 8));
    *((ebp - 0x10)) = eax;
    eax = *((ebp + 0xc));
    *((ebp - 0xc)) = eax;
    *(fp_stack--) = *((ebp - 0x10));
    *(fp_stack--) = 0.0;
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    fp_stack[1] = fp_stack[0];
    fp_stack--;
    if (fp_stack[0] >= fp_stack[1]) {
        eax = ebp - 0x10;
        fp_stack[0] += *(0x8072054);
        *(esp) = fp_stack[0];
        fp_stack--;
        modf (eax);
        fp_stack++;
    } else {
        eax = ebp - 0x10;
        fp_stack[0] -= *(0x8072054);
        *(esp) = fp_stack[0];
        fp_stack--;
        modf (eax);
        fp_stack++;
    }
    *(fp_stack--) = *((ebp - 0x10));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8050be0 */
#include <stdint.h>
 
uint32_t dbg_put_up_arrow (size_t * arg_8h, int32_t i, int32_t cnt) {
    char * cp;
    int32_t var_4h;
    ebx = i;
    esi = cnt;
    /* void put_up_arrow(int cnt,char * cp); */
    esi = *((ebp + 8));
    eax = isatty (0);
    if (eax == 0) {
        goto label_0;
    }
    if (*(obj.point_flag) == 0) {
        goto label_0;
    }
    if (*(obj.html_flag) != 0) {
        goto label_0;
    }
    eax = esi;
    eax += *(obj.input_column);
    if (eax <= 0) {
        goto label_1;
    }
    ebx = 0;
    do {
        *((esp + 4)) = 0x8077a28;
        *(esp) = 1;
        printf_chk ();
        ebx++;
        eax = esi;
        eax += *(obj.input_column);
    } while (eax > ebx);
label_1:
    *((esp + 4)) = 0x80751cb;
    *(esp) = 1;
    printf_chk ();
label_0:
    eax = *((ebp + 0xc));
    *(esp) = eax;
    error ();
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804e95a */
#include <stdint.h>
 
int32_t dbg_parse (int32_t arg_8h, int32_t n) {
    char * cp;
    int32_t var_4h;
    ebx = n;
    /* int parse(int n,char * cp); */
    ebx = *((ebp + 8));
    eax = *((ebp + 0xc));
    eax = parse_equation (ebx, eax);
    if (eax != 0) {
        if (*((ebx*4 + obj.n_lhs)) == 0) {
            eax = 1;
            if (*((ebx*4 + obj.n_rhs)) == 0) {
                goto label_0;
            }
            *((ebx*4 + obj.n_lhs)) = 1;
            eax = *((ebx*4 + obj.lhs));
            edx = zero_token;
            *(eax) = edx;
            edx = .comment;
            *((eax + 4)) = edx;
            edx = .comment;
            *((eax + 8)) = edx;
            edx = .comment;
            *((eax + 0xc)) = edx;
        }
        *(obj.cur_equation) = ebx;
        return_result (ebx);
    } else {
        *((ebx*4 + obj.n_lhs)) = 0;
        *((ebx*4 + obj.n_rhs)) = 0;
        eax = 0;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804965d */
#include <stdint.h>
 
int32_t dbg_resizehandler (void) {
    int32_t sig;
    /* void resizehandler(int sig); */
    eax = screen_columns;
    if (eax != 0) {
        get_screen_size ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80513ec */
#include <stdint.h>
 
int32_t dbg_str_tolower (int32_t arg_8h, char * cp) {
    ebx = cp;
    /* void str_tolower(char * cp); */
    ebx = *((ebp + 8));
    if (ebx == 0) {
        goto label_0;
    }
    esi = *(ebx);
    eax = esi;
    if (al == 0) {
        goto label_0;
    }
    eax = ctype_b_loc ();
    edi = eax;
    do {
        eax = esi;
        esi = (int32_t) al;
        eax = *(edi);
        if ((*((eax + esi*2 + 1)) & 1) != 0) {
            eax = ctype_tolower_loc ();
            eax = *(eax);
            eax = *((eax + esi*4));
            *(ebx) = al;
        }
        ebx++;
        esi = *(ebx);
        eax = esi;
    } while (al != 0);
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806d8e3 */
#include <stdint.h>
 
uint32_t dbg_complex_div (int32_t arg_8h, char * arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_20h, int32_t arg_24h, int32_t arg_28h) {
    complexs num;
    int32_t var_bp_4h;
    complexs a;
    complexs b;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_sp_18h;
    int32_t var_1ch;
    int32_t var_20h;
    /* complexs complex_div(complexs a,complexs b); */
    ebx = *((ebp + 8));
    *(fp_stack--) = *((ebp + 0x1c));
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = *((ebp + 0x24));
    fp_stack[0] = -fp_stack[0];
    *((ebp - 0x28)) = fp_stack[0];
    *((ebp + 0x24)) = fp_stack[0];
    fp_stack--;
    eax = ebp - 0x18;
    edx = *((ebp + 0x1c));
    *((esp + 0x14)) = edx;
    edx = *((ebp + 0x20));
    *((esp + 0x18)) = edx;
    edx = *((ebp + 0x24));
    *((esp + 0x1c)) = edx;
    edx = *((ebp + 0x28));
    *((esp + 0x20)) = edx;
    edx = *((ebp + 0xc));
    *((esp + 4)) = edx;
    edx = *((ebp + 0x10));
    *((esp + 8)) = edx;
    edx = *((ebp + 0x14));
    *((esp + 0xc)) = edx;
    edx = *((ebp + 0x18));
    *((esp + 0x10)) = edx;
    complex_mult (eax);
    *(fp_stack--) = *((ebp - 0x20));
    fp_stack[0] *= fp_stack[0];
    *(fp_stack--) = *((ebp - 0x28));
    fp_stack[0] *= fp_stack[0];
    fp_stack[0] += fp_stack[1];
    fp_stack++;
    *(fp_stack--) = *((ebp - 0x18));
    fp_stack[0] /= fp_stack[1];
    fp_tmp_0 = fp_stack[1];
    fp_stack[1] = fp_stack[0];
    fp_stack[0] = fp_tmp_0;
    *((ebp - 0x10)) /= fp_stack[0];
    *((ebx + 8)) = fp_stack[0];
    fp_stack--;
    *(ebx) = fp_stack[0];
    fp_stack--;
    eax = ebx;
    ebx = *((ebp - 4));
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804a612 */
#include <stdint.h>
 
int32_t dbg_return_result (void ** arg_8h) {
    /* int return_result(int en); */
    edx = *((ebp + 8));
    eax = 0;
    if (*((edx*4 + obj.n_lhs)) > 0) {
        eax = list_sub (edx);
        al = (eax != 0) ? 1 : 0;
        eax = (int32_t) al;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8056051 */
#include <stdint.h>
 
int32_t dbg_push_en (int32_t arg_8h, char * cp) {
    int32_t var_4h;
    ebx = cp;
    /* int push_en(int en); */
    if (*(obj.readline_enabled) != 0) {
        *(obj.high_prec) = 1;
        *((esp + 4)) = 0;
        eax = *((ebp + 8));
        eax = list_equation (eax);
        ebx = eax;
        *(obj.high_prec) = 0;
        if (eax != 0) {
            *(esp) = eax;
            add_history ();
            *(obj.last_history_string) = ebx;
            eax = 1;
        }
    } else {
        eax = 0;
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806da0f */
#include <stdint.h>
 
int32_t dbg_complex_pow (int32_t arg_8h, int32_t arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_20h, int32_t arg_24h, int32_t arg_28h) {
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    complexs r;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_bp_ch;
    complexs a;
    complexs b;
    int32_t var_4h_3;
    int32_t var_4h_2;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_18h;
    int32_t var_sp_1ch;
    int32_t var_sp_20h;
    /* complexs complex_pow(complexs a,complexs b); */
    ebx = *((ebp + 8));
    esi = ebp - 0x38;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = *((ebp + 0x10));
    *((esp + 8)) = eax;
    eax = *((ebp + 0x14));
    *((esp + 0xc)) = eax;
    eax = *((ebp + 0x18));
    *((esp + 0x10)) = eax;
    complex_log (esi);
    edi = *((ebp - 0x38));
    *((ebp - 0x28)) = edi;
    ecx = *((ebp - 0x34));
    *((ebp - 0x24)) = ecx;
    edx = *((ebp - 0x30));
    *((ebp - 0x20)) = edx;
    eax = *((ebp - 0x2c));
    *((ebp - 0x1c)) = eax;
    eax = *((ebp + 0x1c));
    *((esp + 0x14)) = eax;
    eax = *((ebp + 0x20));
    *((esp + 0x18)) = eax;
    eax = *((ebp + 0x24));
    *((esp + 0x1c)) = eax;
    eax = *((ebp + 0x28));
    *((esp + 0x20)) = eax;
    *((esp + 4)) = edi;
    *((esp + 8)) = ecx;
    *((esp + 0xc)) = edx;
    eax = *((ebp - 0x2c));
    *((esp + 0x10)) = eax;
    complex_mult (esi);
    edi = *((ebp - 0x38));
    *((ebp - 0x28)) = edi;
    ecx = *((ebp - 0x34));
    *((ebp - 0x24)) = ecx;
    edx = *((ebp - 0x30));
    *((ebp - 0x20)) = edx;
    eax = *((ebp - 0x2c));
    *((ebp - 0x1c)) = eax;
    *((esp + 4)) = edi;
    *((esp + 8)) = ecx;
    *((esp + 0xc)) = edx;
    *((esp + 0x10)) = eax;
    complex_exp (esi);
    eax = *((ebp - 0x38));
    *((ebp - 0x28)) = eax;
    eax = *((ebp - 0x34));
    *((ebp - 0x24)) = eax;
    eax = *((ebp - 0x30));
    *((ebp - 0x20)) = eax;
    eax = *((ebp - 0x2c));
    *((ebp - 0x1c)) = eax;
    eax = ebp - 0x28;
    complex_fixup (eax);
    eax = *((ebp - 0x28));
    *(ebx) = eax;
    eax = *((ebp - 0x24));
    *((ebx + 4)) = eax;
    eax = *((ebp - 0x20));
    *((ebx + 8)) = eax;
    eax = *((ebp - 0x1c));
    *((ebx + 0xc)) = eax;
    eax = ebx;
    esp = ebp - 0xc;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x807188a */
#include <stdint.h>
 
void i686_get_pc_thunk_bx (void) {
    ebx = *(esp);
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x804ee45 */
#include <stdint.h>
 
int32_t dbg_process (int32_t arg_8h, int32_t i1, int32_t append_flag, int32_t len, int32_t our_repeat_flag, char * filename) {
    int32_t var_1048h;
    uint32_t var_1044h;
    int32_t var_1040h;
    uint32_t var_103ch;
    uint32_t var_1038h;
    uint32_t var_1034h;
    int32_t var_1030h;
    char * s1;
    char * cp1;
    int32_t var_101eh;
    char[4096] buf2;
    int32_t var_101bh;
    int32_t canary;
    char * mode;
    size_t n;
    int32_t var_ch;
    ebx = i1;
    edx = append_flag;
    esi = len;
    edi = our_repeat_flag;
    eax = filename;
    /* int process(char * cp); */
    eax = *((ebp + 8));
    *((ebp - 0x1044)) = eax;
    edx = *(gs:0x14);
    *((ebp - 0x1c)) = edx;
    edx = 0;
    init_gvars ();
    set_sign_array ();
    ebx = 0;
    if (*((ebp - 0x1044)) == 0) {
        goto label_2;
    }
    eax = *((ebp - 0x1044));
    eax = skip_space (eax);
    *((ebp - 0x102c)) = eax;
    edx = eax;
    eax = *(eax);
    if (al == 0x23) {
        edi = edx;
        edi++;
        eax = *(edi);
        if (al != 0x2b) {
            if (al != 0x2d) {
                goto label_3;
            }
        }
        eax = ebp - 0x1020;
        eax = decstrtol (edi, eax);
        esi = eax;
        esi += *(obj.cur_equation);
        goto label_4;
label_3:
        eax = ebp - 0x1020;
        decstrtol (edi, eax);
        esi = eax - 1;
label_4:
        eax = *((ebp - 0x1020));
        ebx = 1;
        if (edi == eax) {
            goto label_2;
        }
        if (esi >= 0) {
            if (esi < *(obj.n_equations)) {
                goto label_5;
            }
        }
        *(esp) = "Equation not defined.";
        eax = error ();
        ebx = 0;
        goto label_2;
label_5:
        dl = (*(eax) == 0x3a) ? 1 : 0;
        edx = (int32_t) dl;
        eax += edx;
        eax = skip_space (eax);
        if (*(eax) != 0) {
            edx = eax;
            edx -= *((ebp - 0x1044));
            *(obj.input_column) += edx;
            *((esp + 4)) = eax;
            eax = parse (esi);
            ebx = eax;
            goto label_2;
        }
        *(obj.cur_equation) = esi;
        al = return_result (esi);
        ebx = 1;
        goto label_2;
    }
    if (*(obj.security_level) == 0) {
        if (al != 0x21) {
            goto label_6;
        }
        eax = getenv ("SHELL");
        edx = "/bin/sh";
        if (eax == 0) {
            eax = edx;
        }
        *((ebp - 0x1020)) = eax;
        eax = access (eax, 1);
        if (eax != 0) {
            *(esp) = "Shell not found or not executable, check SHELL environment variable.";
            error ();
            ebx = 0;
            goto label_2;
        }
        eax = *((ebp - 0x102c));
        eax++;
        eax = skip_space (eax);
        if (*(eax) == 0) {
            eax = *((ebp - 0x1020));
        }
        eax = shell_out (eax);
        bl = (eax == 0) ? 1 : 0;
        ebx = (int32_t) bl;
        goto label_2;
    }
label_6:
    *((ebp - 0x103c)) = 0;
    edi = 1;
    if (al == 0x3f) {
        eax = *((ebp - 0x102c));
        eax++;
        eax = skip_space (eax);
        edx = eax;
        edx -= *((ebp - 0x1044));
        *(obj.input_column) += edx;
        eax = help_cmd (eax);
        ebx = eax;
        goto label_2;
    }
label_0:
    eax = *((ebp - 0x102c));
    *((ebp - 0x1020)) = eax;
    esi = *(eax);
    ebx = eax;
    edx = esi;
    if (dl == 0) {
        goto label_7;
    }
    eax = ctype_b_loc ();
    edx = esi;
    while ((*((edx + esi*2 + 1)) & 0x20) == 0) {
        ebx++;
        *((ebp - 0x1020)) = ebx;
        edx = *(ebx);
        if (dl == 0) {
            goto label_7;
        }
        esi = (int32_t) dl;
        edx = *(eax);
    }
label_7:
    eax = *((ebp - 0x102c));
    *((ebp - 0x1040)) = eax;
    esi = ebx;
    esi -= eax;
    if (esi == 6) {
        eax = strncasecmp (eax, "repeat", 6);
        if (eax != 0) {
            goto label_8;
        }
        eax = skip_space (ebx);
        *((ebp - 0x102c)) = eax;
        *((ebp - 0x103c)) = edi;
        goto label_0;
    }
label_8:
    *((ebp - 0x1038)) = esi;
    esi = com_list;
    *((ebp - 0x1030)) = 0;
    edx = *((ebp - 0x1038));
    *((ebp - 0x1034)) = edx;
    *((ebp - 0x1048)) = ebx;
label_1:
    ebx = *(esi);
    edi = *(esi);
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx--;
    eax = 4;
    if (ecx > 4) {
        ecx = eax;
    }
    if (*((ebp - 0x1038)) >= ecx) {
        eax = *((ebp - 0x1034));
        edx = *((ebp - 0x102c));
        eax = strncasecmp (edx, ebx, eax);
        if (eax == 0) {
            goto label_9;
        }
    }
    edx = *((esi + 4));
    if (edx == 0) {
        goto label_10;
    }
    edi = edx;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    ecx--;
    eax = 4;
    if (ecx > 4) {
        ecx = eax;
    }
    if (*((ebp - 0x1034)) < ecx) {
        goto label_10;
    }
    eax = *((ebp - 0x1034));
    edx = *((ebp - 0x102c));
    eax = strncasecmp (edx, edx, eax);
    if (eax != 0) {
        goto label_10;
    }
label_9:
    esi = ebx;
    ebx = *((ebp - 0x1048));
    eax = skip_space (ebx);
    *((ebp - 0x1020)) = eax;
    edx = eax;
    edx -= *((ebp - 0x1044));
    *(obj.input_column) += edx;
    *((esp + 8)) = 0x1000;
    eax = ebp - 0x101c;
    eax = my_strlcpy (eax, eax);
    if (eax > 0xfff) {
        *(esp) = "Command line too long.";
        error ();
        ebx = 0;
        goto label_2;
    }
    if (*(obj.security_level) > 1) {
        goto label_11;
    }
    edi = ebp - 0x101c;
    eax = 0;
    ecx = 0xffffffff;
    __asm ("repne scasb al, byte es:[edi]");
    ecx = ~ecx;
    eax = ecx - 1;
    ebx = ecx;
    ebx -= 2;
    if (ebx < 0) {
        goto label_11;
    }
    eax = ebp + eax - 0x101e;
    if (*((ebp + ebx - 0x101c)) != 0x3e) {
        goto label_12;
    }
    while (ebx >= 0) {
        edx = *(eax);
        eax--;
        if (dl == 0x3e) {
            eax = ebp + ebx - 0x101b;
            eax = skip_space (eax);
            if (ebx != 0) {
                edx = ebx - 1;
                ecx = 1;
                if (*((ebp + edx - 0x101c)) == 0x3e) {
                    goto label_13;
                }
            }
            edx = ebx;
            ecx = 0;
label_13:
            *((ebp + edx - 0x101c)) = 0;
            if (eax != 0) {
                goto label_14;
            }
            goto label_11;
        }
label_12:
        ebx--;
    }
    goto label_11;
label_14:
    if (ecx != 0) {
        eax = fopen (eax, 0x8072a7b);
        ebx = eax;
    } else {
        eax = fopen (eax, 0x80779f1);
        ebx = eax;
    }
    if (ebx == 0) {
        *(esp) = "Can't open redirected output file for writing.";
        error ();
        goto label_2;
    }
    eax = gfp;
    if (eax != *(obj.stdout)) {
        if (eax == *(obj.stderr)) {
            goto label_15;
        }
        if (eax == *(obj.default_out)) {
            goto label_15;
        }
        fclose (eax);
    }
label_15:
    *(obj.gfp) = ebx;
    ebx = ebp - 0x101c;
    remove_trailing_spaces (ebx);
    *(obj.pull_number) = 1;
    eax = *((ebp - 0x103c));
    *(obj.repeat_flag) = eax;
    edx = *((ebp - 0x1030));
    eax = edx * 3;
    eax = uint32_t (*eax*8 + 0x8074d88)(uint32_t) (ebx);
    ebx = eax;
    *(obj.repeat_flag) = 0;
    eax = gfp;
    if (eax == *(obj.default_out)) {
        goto label_16;
label_11:
        ebx = ebp - 0x101c;
        remove_trailing_spaces (ebx);
        *(obj.pull_number) = 1;
        eax = *((ebp - 0x103c));
        *(obj.repeat_flag) = eax;
        edx = *((ebp - 0x1030));
        eax = edx * 3;
        eax = uint32_t (*eax*8 + 0x8074d88)(uint32_t) (ebx);
        ebx = eax;
        *(obj.repeat_flag) = 0;
    } else {
        if (eax != *(obj.stdout)) {
            if (eax == *(obj.stderr)) {
                goto label_17;
            }
            fclose (eax);
        }
label_17:
        eax = default_out;
        *(obj.gfp) = eax;
    }
label_16:
    if (ebx != 0) {
        goto label_2;
    }
    if (*(obj.debug_level) < 0) {
        goto label_2;
    }
    eax = *((ebp - 0x1030)) * 0x18;
    eax = *((eax + 0x8074d8c));
    *((esp + 0xc)) = eax;
    *((esp + 8)) = esi;
    *((esp + 4)) = "Command usage: %s %s\n";
    *(esp) = 1;
    printf_chk ();
    goto label_2;
label_10:
    *((ebp - 0x1030))++;
    esi += 0x18;
    if (*((ebp - 0x1030)) != 0x2a) {
        goto label_1;
    }
    if (*((ebp - 0x103c)) != 0) {
        *(esp) = "Expecting command to repeat.";
        error ();
        ebx = 0;
    } else {
        eax = next_espace ();
        edx = *((ebp - 0x1040));
        edx -= *((ebp - 0x1044));
        *(obj.input_column) += edx;
        edx = *((ebp - 0x102c));
        *((esp + 4)) = edx;
        eax = process_parse (eax);
        ebx = eax;
    }
label_2:
    edx = *((ebp - 0x1c));
    edx ^= *(gs:0x14);
    if (*(obj.input_column) != 0) {
        stack_chk_fail ();
    }
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80498b9 */
#include <stdint.h>
 
int32_t dbg_main (int32_t i, int32_t wide_flag, int32_t coption, unsigned char const * __s1) {
    int32_t argc;
    char ** argv;
    int32_t var_4h;
    int32_t var_8h;
    int32_t var_ch;
    int32_t var_10h;
    int32_t var_14h;
    int32_t var_18h;
    int32_t var_24h;
    int32_t boption;
    double denominator;
    double numerator;
    char * cp;
    ebx = i;
    esi = wide_flag;
    edi = coption;
    eax = __s1;
    /* int main(int argc,char ** argv); */
    *((esp + 0x4c)) = 0;
    init_gvars ();
    eax = stdout;
    *(obj.default_out) = eax;
    *(obj.gfp) = eax;
    esi = 0;
    *((esp + 0x28)) = 0;
    edi = 0;
    ebx = 0x8071ff4;
    void (*0x8049a9f)() ();
    eax -= 0x62;
    if (eax > 0x16) {
        void (*0x8049a86)() ();
    }
    uint32_t (*ebx + eax*4)() ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049a9f */
#include <stdint.h>
 
int32_t loc_08049a9f (int32_t arg_ch, char * * argv, char * optstring, char * arg_10h, int32_t arg_14h, int32_t arg_18h, int32_t arg_24h, uint32_t arg_28h, int32_t arg_38h, int32_t arg_40h, char * arg_4ch) {
    edx = *((ebp + 0xc));
    eax = *((ebp + 8));
    eax = getopt (eax, edx, "s:bqrtchuvwxm:");
    if (eax >= 0) {
        void (*0x80498fd)() ();
    }
    if (*(obj.n_tokens) <= 0x63) {
        eax = prog_name;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "%s: Expression array size too small.\n";
        *((esp + 4)) = 1;
        eax = stderr;
        *(esp) = eax;
        fprintf_chk ();
        exit (2);
    }
    eax = init_mem ();
    if (eax == 0) {
        eax = prog_name;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "%s: Not enough memory.\n";
        *((esp + 4)) = 1;
        eax = stderr;
        *(esp) = eax;
        fprintf_chk ();
        exit (2);
    }
    if (*(obj.readline_enabled) != 0) {
        eax = getenv ("HOME");
        *((esp + 0x4c)) = eax;
        if (eax != 0) {
            edx = prog_name;
            if (edx == 0) {
                goto label_0;
            }
            *((esp + 0x18)) = edx;
            *((esp + 0x14)) = eax;
            *((esp + 0x10)) = "%s/.%s_history";
            *((esp + 0xc)) = 0x1000;
            *((esp + 8)) = 1;
            *((esp + 4)) = 0x1000;
            *(esp) = obj.history_filename_storage;
            snprintf_chk ();
            *(obj.history_filename) = 0x8081a20;
        }
label_0:
        rl_initialize ();
        using_history ();
        *(esp) = 0x1f4;
        stifle_history ();
        *(obj.rl_inhibit_completion) = 1;
        if (*(obj.html_flag) == 0) {
            *(esp) = "colors";
            eax = tigetnum ();
            al = (eax > 7) ? 1 : 0;
            eax = (int32_t) al;
            *(obj.color_flag) = eax;
        }
        eax = history_filename;
        *(esp) = eax;
        read_history ();
    }
    get_screen_size ();
    if (*(obj.html_flag) != 0) {
        *((esp + 4)) = "<pre>\n";
        *(esp) = 1;
        printf_chk ();
    }
    if (*(obj.test_mode) == 0) {
        if (*(obj.quiet_mode) == 0) {
            if (*(obj.security_level) > 1) {
                *((esp + 4)) = "Secure ";
                *(esp) = 1;
                printf_chk ();
            }
            *((esp + 8)) = "15.1.1";
            *((esp + 4)) = "Mathomatic version %s (www.mathomatic.org)\n";
            *(esp) = 1;
            printf_chk ();
            *((esp + 4)) = "Copyright (C) 1987-2010 George Gesslein II.\n";
            *(esp) = 1;
            printf_chk ();
            eax = n_tokens;
            eax <<= 5;
            edx = 0x10624dd3;
            edx:eax = eax * edx;
            edx >>= 6;
            *((esp + 0xc)) = edx;
            *((esp + 8)) = 0x64;
            *((esp + 4)) = "%d equation spaces available, %ld kilobytes per equation space.\n";
            *(esp) = 1;
            printf_chk ();
            if (*(obj.test_mode) != 0) {
                goto label_1;
            }
        }
        eax = load_rc ();
        if (eax != 0) {
            goto label_1;
        }
        *((esp + 0x10)) = obj.rc_file;
        eax = prog_name;
        *((esp + 0xc)) = eax;
        *((esp + 8)) = "%s: Error loading set options from \"%s\".\n";
        *((esp + 4)) = 1;
        eax = stderr;
        *(esp) = eax;
        fprintf_chk ();
    }
label_1:
    if (esi != 0) {
        *(obj.screen_columns) = 0;
        *(obj.screen_rows) = 0;
    }
    if ((edi & 1) != 0) {
        al = (*(obj.color_flag) == 0) ? 1 : 0;
        eax = (int32_t) al;
        *(obj.color_flag) = eax;
    }
    if (*((esp + 0x28)) != 0) {
        *(obj.color_flag) = 1;
        *(obj.bold_colors) = 1;
    }
    if (*(obj.test_mode) != 0) {
        *(obj.color_flag) = 0;
    }
    if (*(obj.quiet_mode) == 0) {
        if (*(obj.color_flag) == 0) {
            goto label_2;
        }
        eax = 0x80757fe;
        edx = " bold";
        if (*(obj.bold_colors) == 0) {
            edx = eax;
        }
        eax = "ANSI";
        ecx = "HTML";
        if (*(obj.html_flag) != 0) {
            eax = ecx;
        }
        *((esp + 0xc)) = edx;
        *((esp + 8)) = eax;
        *((esp + 4)) = "%s%s color mode enabled";
        *(esp) = 1;
        printf_chk ();
        if (*((esp + 0x28)) == 0) {
            *((esp + 4)) = "; disable with the -c option or \"set no color\".\n";
            *(esp) = 1;
            printf_chk ();
        } else {
            *((esp + 4)) = 0x807270a;
            *(esp) = 1;
            printf_chk ();
        }
    }
label_2:
    eax = setjmp (obj.jmp_save);
    ebx = eax;
    if (eax != 0) {
        clean_up ();
        if (ebx == 0xe) {
            *(esp) = "Expression too large.";
            error ();
        }
        *((esp + 4)) = "Operation aborted.\n";
        *(esp) = 1;
        printf_chk ();
        goto label_3;
    }
    eax = set_signals ();
    if (eax == 0) {
        *((esp + 8)) = "signal(2) setting failed.\n";
        *((esp + 4)) = 1;
        eax = stderr;
        *(esp) = eax;
        fprintf_chk ();
    }
    eax = esp + 0x38;
    eax = esp + 0x40;
    *(fp_stack--) = *(0x8072054);
    *(esp) = fp_stack[0];
    fp_stack--;
    eax = f_to_fraction (eax, eax);
    if (eax != 0) {
        *(fp_stack--) = 1.0;
        *(fp_stack--) = *((esp + 0x40));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_4;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_4;
        }
        *(fp_stack--) = *((esp + 0x38));
        *(fp_stack--) = *(0x8072058);
        fp_tmp_0 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_0;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_4;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_4;
        }
        eax = esp + 0x38;
        eax = esp + 0x40;
        *(fp_stack--) = *(0x8072068);
        *(esp) = fp_stack[0];
        fp_stack--;
        eax = f_to_fraction (eax, eax);
        if (eax == 0) {
            goto label_4;
        }
        *(fp_stack--) = 1.0;
        *(fp_stack--) = *((esp + 0x40));
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] != fp_stack[1]) {
            goto label_4;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_4;
        }
        *(fp_stack--) = *((esp + 0x38));
        *(fp_stack--) = *(0x807205c);
        fp_tmp_1 = fp_stack[1];
        fp_stack[1] = fp_stack[0];
        fp_stack[0] = fp_tmp_1;
        fp_stack--;
        fp_stack++;
        if (fp_stack[0] == fp_stack[1]) {
            goto label_4;
        }
        if (fp_stack[0] == fp_stack[1]) {
            goto label_5;
        }
    }
label_4:
    eax = prog_name;
    *((esp + 0xc)) = eax;
    *((esp + 8)) = "%s: Cannot convert any floating point values to fractions.\n";
    *((esp + 4)) = 1;
    eax = stderr;
    *(esp) = eax;
    fprintf_chk ();
    *((esp + 8)) = "Roots will not work properly.\n";
    *((esp + 4)) = 1;
    eax = stderr;
    *(esp) = eax;
    fprintf_chk ();
label_5:
    esi = optind;
    if (*((ebp + 8)) <= esi) {
        goto label_3;
    }
    eax = *((ebp + 0xc));
    eax = eax + esi*4;
    *((esp + 0x24)) = eax;
    eax = *(eax);
    if (eax == 0) {
        goto label_3;
    }
    edx = *((ebp + 0xc));
    ebx = edx + esi*4 + 4;
    edi = 0x807295b;
    do {
        edx = *(eax);
        if (dl == *(edi)) {
            edx = *((eax + 1));
            if (dl == *((edi + 1))) {
                eax = main_io_loop ();
            }
        } else {
            eax = read_file (eax);
            if (eax != 0) {
                goto label_6;
            }
            edx = *((esp + 0x24));
            eax = *(edx);
            *((esp + 0xc)) = eax;
            *((esp + 8)) = "Read of file \"%s\" failed.\n";
            *((esp + 4)) = 1;
            eax = stderr;
            *(esp) = eax;
            fprintf_chk ();
            exit_program (1);
        }
label_6:
        esi++;
        if (*((ebp + 8)) <= esi) {
            goto label_3;
        }
        *((esp + 0x24)) = ebx;
        eax = *(ebx);
        ebx += 4;
    } while (eax != 0);
label_3:
    main_io_loop ();
    exit_program (0);
    eax = 0;
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80490c4 */
#include <stdint.h>
 
void getopt (void) {
    getopt ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049294 */
#include <stdint.h>
 
void exit (void) {
    exit ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f84 */
#include <stdint.h>
 
void getenv (void) {
    getenv ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048ec4 */
#include <stdint.h>
 
void rl_initialize (void) {
    rl_initialize ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049204 */
#include <stdint.h>
 
void using_history (void) {
    using_history ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049154 */
#include <stdint.h>
 
void stifle_history (void) {
    stifle_history ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048fd4 */
#include <stdint.h>
 
void tigetnum (void) {
    tigetnum ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f54 */
#include <stdint.h>
 
void read_history (void) {
    read_history ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80490b4 */
#include <stdint.h>
 
void setjmp (void) {
    setjmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x806cae3 */
#include <stdint.h>
 
uint32_t dbg_parse_complex (size_t * arg_8h, char * arg_10h, int32_t level2, complexs * cp, token_type * p1) {
    int32_t var_4ch;
    int32_t level;
    int32_t times_cnt;
    int32_t plus_cnt;
    int32_t imag_cnt;
    int32_t var_38h;
    int32_t var_34h;
    int32_t j;
    int32_t var_2ch;
    complexs c;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t n;
    int32_t var_4h;
    int32_t var_8h;
    ecx = level2;
    esi = cp;
    edi = p1;
    /* int parse_complex(token_type * p1,int n,complexs * cp); */
    edi = *((ebp + 8));
    esi = *((ebp + 0x10));
    eax = ebp - 0x28;
    *((esp + 8)) = eax;
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = get_constant (edi);
    if (eax != 0) {
        *(fp_stack--) = 0.0;
        *((ebp - 0x20)) = fp_stack[0];
        fp_stack--;
        eax = *((ebp - 0x28));
        *(esi) = eax;
        eax = *((ebp - 0x24));
        *((esi + 4)) = eax;
        eax = *((ebp - 0x20));
        *((esi + 8)) = eax;
        eax = *((ebp - 0x1c));
        *((esi + 0xc)) = eax;
        eax = 1;
        goto label_0;
    }
    eax = *((ebp + 0xc));
    *((esp + 4)) = eax;
    eax = min_level (edi);
    *((ebp - 0x48)) = eax;
    *(fp_stack--) = 0.0;
    *((ebp - 0x28)) = fp_stack[0];
    fp_stack--;
    *(fp_stack--) = 1.0;
    *((ebp - 0x20)) = fp_stack[0];
    fp_stack--;
    eax = *((ebp + 0xc));
    eax--;
    *((ebp - 0x30)) = eax;
    if (eax < 0) {
        goto label_1;
    }
    ebx = eax;
    ebx <<= 4;
    ebx = edi + ebx;
    eax = *((ebp + 0xc));
    eax <<= 4;
    eax = edi + eax;
    *((ebp - 0x34)) = eax;
    eax = *((ebp + 0xc));
    eax <<= 4;
    eax = eax + edi - 0x20;
    *((ebp - 0x2c)) = eax;
    *((ebp - 0x38)) = 0;
    *((ebp - 0x44)) = 0;
    *((ebp - 0x40)) = 0;
    *((ebp - 0x3c)) = 0;
    do {
        eax = *(ebx);
        if (eax != 1) {
            if (eax < 1) {
                goto label_2;
            }
            if (eax != 2) {
                goto label_1;
            }
        } else {
            eax = *((ebx + 8));
            eax = var_is_const (eax, 0);
            if (eax != 0) {
                goto label_2;
            }
            if (*((ebx + 8)) != 3) {
                goto label_1;
            }
            *((ebp - 0x3c))++;
            goto label_2;
        }
        edx = *((ebx + 4));
        eax = *((ebx + 8));
        if (eax != 2) {
            if (eax <= 2) {
                if (eax != 1) {
                    goto label_1;
                }
            } else {
            } else {
                if (eax != 3) {
                    if (eax != 4) {
                        goto label_1;
                    }
                } else {
                    *((ebp - 0x44))++;
                    if (*((ebp - 0x44)) > 1) {
                        goto label_1;
                    }
                    ecx = *((ebp - 0x2c));
                    *((ebp - 0x4c)) = ecx;
                    eax = *((ecx + 4));
                    if (eax != edx) {
                        goto label_1;
                    }
                    edx = *((ebp - 0x34));
                    if (eax != *((edx + 4))) {
                        goto label_1;
                    }
                    if (*(ecx) == 1) {
                        if (*((ecx + 8)) != 3) {
                            goto label_3;
                        }
                        eax = ebp - 0x20;
                        *((esp + 8)) = eax;
                        *((esp + 4)) = 1;
                        eax = get_constant (edx);
                        if (eax != 0) {
                            goto label_2;
                        }
                        goto label_1;
                    }
label_3:
                    ecx = *((ebp - 0x34));
                    if (*(ecx) != 1) {
                        goto label_1;
                    }
                    if (*((ecx + 8)) != 3) {
                        goto label_1;
                    }
                    eax = ebp - 0x20;
                    *((esp + 8)) = eax;
                    *((esp + 4)) = 1;
                    ecx = *((ebp - 0x4c));
                    eax = get_constant (ecx);
                    if (eax != 0) {
                        goto label_2;
                    }
                    goto label_1;
                }
                *((ebp - 0x44))++;
                if (*((ebp - 0x44)) > 1) {
                    goto label_1;
                }
                ecx = *((ebp - 0x2c));
                eax = *((ecx + 4));
                if (eax != edx) {
                    goto label_1;
                }
                edx = *((ebp - 0x34));
                if (eax != *((edx + 4))) {
                    goto label_1;
                }
                if (*(ecx) != 1) {
                    goto label_1;
                }
                if (*((ecx + 8)) != 3) {
                    goto label_1;
                }
                eax = ebp - 0x20;
                *((esp + 8)) = eax;
                *((esp + 4)) = 1;
                eax = get_constant (edx);
                if (eax == 0) {
                    goto label_1;
                }
                *(fp_stack--) = 1.0;
                fp_stack[0] /= *((ebp - 0x20));
                *((ebp - 0x20)) = fp_stack[0];
                fp_stack--;
                if (*((ebp - 0x3c)) == 0) {
                    goto label_4;
                }
                *(fp_stack--) = *((ebp - 0x20));
                fp_stack[0] = -fp_stack[0];
                *((ebp - 0x20)) = fp_stack[0];
                fp_stack--;
            }
label_4:
            *((ebp - 0x40))++;
            if (*((ebp - 0x40)) > 1) {
                goto label_1;
            }
            if (*((ebp - 0x48)) != edx) {
                goto label_1;
            }
            ecx = ebp - 0x28;
            *((esp + 8)) = ecx;
            eax = *((ebp - 0x30));
            *((esp + 4)) = eax;
            eax = get_constant (edi);
            if (eax != 0) {
                goto label_5;
            }
            ecx = ebp - 0x28;
            *((esp + 8)) = ecx;
            eax = *((ebp - 0x38));
            *((esp + 4)) = eax;
            ecx = *((ebp - 0x34));
            eax = get_constant (ecx);
            if (eax == 0) {
                goto label_1;
            }
            if (*((ebx + 8)) != 2) {
                goto label_2;
            }
            *(fp_stack--) = *((ebp - 0x28));
            fp_stack[0] = -fp_stack[0];
            *((ebp - 0x28)) = fp_stack[0];
            fp_stack--;
        }
label_2:
        *((ebp - 0x38))++;
        ebx -= 0x10;
        *((ebp - 0x34)) -= 0x10;
        *((ebp - 0x2c)) -= 0x10;
        *((ebp - 0x30))--;
    } while (*((ebp - 0x30)) >= 0);
label_5:
    if (*((ebp - 0x3c)) == 1) {
        eax = *((ebp - 0x28));
        *(esi) = eax;
        eax = *((ebp - 0x24));
        *((esi + 4)) = eax;
        eax = *((ebp - 0x20));
        *((esi + 8)) = eax;
        eax = *((ebp - 0x1c));
        *((esi + 0xc)) = eax;
        eax = 1;
    } else {
label_1:
        eax = 0;
    }
label_0:
    return eax;
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048e94 */
#include <stdint.h>
 
void fmod (void) {
    fmod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048ea4 */
#include <stdint.h>
 
void errno_location (void) {
    errno_location ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048eb4 */
#include <stdint.h>
 
void setbuf (void) {
    setbuf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048ed4 */
#include <stdint.h>
 
void qsort (void) {
    qsort ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048ee4 */
#include <stdint.h>
 
void write_history (void) {
    write_history ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f44 */
#include <stdint.h>
 
void isinf (void) {
    isinf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f64 */
#include <stdint.h>
 
void strtod (void) {
    strtod ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f74 */
#include <stdint.h>
 
void strchr (void) {
    strchr ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048f94 */
#include <stdint.h>
 
void system (void) {
    system ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048fa4 */
#include <stdint.h>
 
void pow (void) {
    pow ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048fb4 */
#include <stdint.h>
 
void fgets (void) {
    fgets ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048fe4 */
#include <stdint.h>
 
void modf (void) {
    modf ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8048ff4 */
#include <stdint.h>
 
void perror (void) {
    perror ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049024 */
#include <stdint.h>
 
void fdopen (void) {
    fdopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049044 */
#include <stdint.h>
 
void access (void) {
    access ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049054 */
#include <stdint.h>
 
void fflush (void) {
    fflush ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049064 */
#include <stdint.h>
 
void mkstemp (void) {
    mkstemp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049074 */
#include <stdint.h>
 
void ioctl (void) {
    ioctl ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049094 */
#include <stdint.h>
 
void isatty (void) {
    isatty ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80490a4 */
#include <stdint.h>
 
void fclose (void) {
    fclose ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80490d4 */
#include <stdint.h>
 
void fopen (void) {
    fopen ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80490e4 */
#include <stdint.h>
 
void cos (void) {
    cos ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80490f4 */
#include <stdint.h>
 
void unlink (void) {
    unlink ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049104 */
#include <stdint.h>
 
void finite (void) {
    finite ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049114 */
#include <stdint.h>
 
void strcpy (void) {
    strcpy ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049124 */
#include <stdint.h>
 
void chdir (void) {
    chdir ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049134 */
#include <stdint.h>
 
void lgamma (void) {
    lgamma ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049164 */
#include <stdint.h>
 
void readline (void) {
    readline ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049174 */
#include <stdint.h>
 
void malloc (void) {
    malloc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049184 */
#include <stdint.h>
 
void stack_chk_fail (void) {
    stack_chk_fail ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80491a4 */
#include <stdint.h>
 
void isnan (void) {
    isnan ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80491d4 */
#include <stdint.h>
 
void ctype_tolower_loc (void) {
    ctype_tolower_loc ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80491e4 */
#include <stdint.h>
 
void getcwd (void) {
    getcwd ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049234 */
#include <stdint.h>
 
void strpbrk (void) {
    strpbrk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049244 */
#include <stdint.h>
 
void memmove_chk (void) {
    memmove_chk ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049254 */
#include <stdint.h>
 
void add_history (void) {
    add_history ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049264 */
#include <stdint.h>
 
void sin (void) {
    sin ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049284 */
#include <stdint.h>
 
void strdup (void) {
    strdup ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80492b4 */
#include <stdint.h>
 
void ceil (void) {
    ceil ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x80491b4 */
#include <stdint.h>
 
void strncasecmp (void) {
    strncasecmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049144 */
#include <stdint.h>
 
void strcasecmp (void) {
    strcasecmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049274 */
#include <stdint.h>
 
void strcmp (void) {
    strcmp ();
}
/* r2dec pseudo code output */
/* SUBJECTS/from_decompile-it.com/mathomatic/ia32_elf_from_website/subject.exe @ 0x8049214 */
#include <stdint.h>
 
void strncmp (void) {
    strncmp ();
}
