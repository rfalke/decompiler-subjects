/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
int sub_8048E84();
// double fmod(double x, double y);
// int *__errno_location(void);
// int rl_initialize(void); weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int __cdecl write_history(_DWORD); weak
// int __cdecl __longjmp_chk(_DWORD, _DWORD); weak
// int __fprintf_chk(_DWORD, _DWORD, const char *, ...); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __gmon_start__(void); weak
// int __printf_chk(_DWORD, const char *, ...); weak
// int __isinf(double value);
// int __cdecl read_history(_DWORD); weak
// double strtod(const char *nptr, char **endptr);
// char *strchr(const char *s, int c);
// char *getenv(const char *name);
// int system(const char *command);
// double pow(double x, double y);
// char *fgets(char *s, int n, FILE *stream);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int tigetnum(const char *);
// double modf(double x, double *iptr);
// void perror(const char *s);
// double exp(double x);
// int strtol(const char *nptr, char **endptr, int base);
// FILE *fdopen(int fd, const char *modes);
// void free(void *ptr);
// int access(const char *name, int type);
// int fflush(FILE *stream);
// int mkstemp(char *template);
// int ioctl(int fd, unsigned int request, ...);
// const unsigned __int16 **__ctype_b_loc(void);
// int isatty(int fd);
// int fclose(FILE *stream);
// int _setjmp(struct __jmp_buf_tag env[1]);
// int getopt(int argc, char *const *argv, const char *shortopts);
// FILE *fopen(const char *filename, const char *modes);
// double cos(double x);
// int unlink(const char *name);
// int __finite(double value);
// char *strcpy(char *dest, const char *src);
// int chdir(const char *path);
// double lgamma(double);
// int strcasecmp(const char *s1, const char *s2);
// int __cdecl stifle_history(_DWORD); weak
// int __cdecl readline(_DWORD); weak
// void *malloc(size_t size);
// double atan2(double y, double x);
// int __isnan(double value);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// void *memmove(void *dest, const void *src, size_t n);
// const __int32_t **__ctype_tolower_loc(void);
// char *getcwd(char *buf, size_t size);
// double log(double x);
// int using_history(void); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...); weak
// char *strpbrk(const char *s, const char *accept);
// int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl add_history(_DWORD); weak
// double sin(double x);
// int strcmp(const char *s1, const char *s2);
// int __cdecl __strdup(_DWORD); weak
// void exit(int status);
// int __cdecl sincos(_DWORD, _DWORD, _DWORD, _DWORD); weak
// double ceil(double x);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void _do_global_dtors_aux();
int frame_dummy();
void __cdecl fphandler(int sig);
void __cdecl __noreturn exit_program(int exit_value);
void __cdecl exithandler(int sig);
void __cdecl alarmhandler(int sig);
void __cdecl inthandler(int sig);
void usage(); // idb
void __cdecl resizehandler(int sig);
int load_rc(); // idb
_BOOL4 set_signals();
void main_io_loop(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
void init_gvars(); // idb
int __cdecl next_sign(int *vp);
int __cdecl found_var(token_type *p1, int n, int v);
int __cdecl solved_equation(int i);
int __cdecl var_in_equation(int i, int v);
int __cdecl min_level(token_type *expression, int n);
int __cdecl level_plus_count(token_type *p1, int n1, int level);
int __cdecl level1_plus_count(token_type *p1, int n1);
int __cdecl var_count(token_type *p1, int n1);
int __cdecl no_vars(token_type *source, int n, int *vp);
int __cdecl exp_is_numeric(token_type *p1, int n1);
int __cdecl exp_contains_nan(token_type *p1, int n1);
int __cdecl exp_contains_infinity(token_type *p1, int n1);
int __cdecl isdelimiter(int ch_0);
int __cdecl strcmp_tospace(char *cp1, char *cp2);
int __cdecl is_all(char *cp);
char *__cdecl skip_space(char *cp);
char *__cdecl skip_param(char *cp);
int __cdecl decstrtol(char *cp, char **cpp);
void free_result_str(); // idb
int __cdecl return_result(int en);
char *__cdecl get_string(char *string, int n);
int get_yes_no(); // idb
int __cdecl get_expr(token_type *equation, int *np);
void __cdecl copy_espace(int src, int dest);
void __noreturn error_huge(); // idb
void __cdecl subst_var_with_exp(token_type *equation, int *np, token_type *expression, int len, int v);
int __cdecl alloc_espace(int i);
void clean_up(); // idb
void get_screen_size(); // idb
void __cdecl warning(const char *str);
int __cdecl check_divide_by_zero(double denominator);
int alloc_next_espace(); // idb
void __cdecl error(const char *str);
int __cdecl extra_characters(char *cp);
int __cdecl prompt_var(int *vp);
int current_not_defined(); // idb
int __cdecl not_defined(int i);
int __cdecl get_default_en(char *cp);
int __cdecl get_range(char **cpp, int *ip_0, int *jp);
int __cdecl get_range_eol(char **cpp, int *ip_0, int *jp);
int next_espace(); // idb
void check_err(); // idb
void __cdecl error_bug(const char *str);
void clear_all(); // idb
int init_mem(); // idb
void set_sign_array(); // idb
// int __usercall flip@<eax>(token_type *side1p@<eax>, int *side1np@<edx>, token_type *side2p@<ecx>, int *side2np); idb
// int __usercall g_of_f@<eax>(int op@<eax>, token_type *operandp@<edx>, token_type *side1p@<ecx>, int *side1np, token_type *side2p, int *side2np); idb
// int __usercall quad_solve@<eax>(int v@<eax>); idb
int __cdecl solve_sub(token_type *wantp, int wantn, token_type *leftp, int *leftnp, token_type *rightp, int *rightnp);
int __cdecl solve_espace(int want, int have);
int __cdecl display_command(int i);
char *__cdecl parse_var2(int *vp, char *cp);
int __cdecl shell_out(char *cp);
int __cdecl parse(int n, char *cp);
int __cdecl process_parse(int n, char *cp);
int __cdecl process(char *cp);
int __cdecl display_process(char *cp);
int __cdecl read_examples(char **cpp);
int __cdecl help_cmd(char *cp);
int __cdecl var_is_const(int v, double *dp);
int __cdecl subst_constants(token_type *equation, int *np);
int __cdecl my_strlcpy(char *dest, char *src, int n);
void __cdecl remove_trailing_spaces(char *cp);
void __cdecl set_error_level(char *cp);
void __cdecl binary_parenthesize(token_type *p1, int n, int i);
void __cdecl give_priority(token_type *equation, int *np);
void __cdecl handle_negate(token_type *equation, int *np);
int __cdecl isvarchar(int ch_0);
char *__cdecl parse_var(int *vp, char *cp);
void __cdecl put_up_arrow(int cnt, char *cp);
char *__cdecl parse_section(token_type *equation, int *np, char *cp, int allow_space);
void __cdecl str_tolower(char *cp);
char *__cdecl parse_expr(token_type *equation, int *np, char *cp);
char *__cdecl parse_equation(int n, char *cp);
int __cdecl vcmp(sort_type *p1, sort_type *p2);
int __cdecl quit_cmd(char *cp);
int __cdecl fraction_cmd(char *cp);
int __cdecl unfactor_cmd(char *cp);
int __cdecl skip_no(char **cpp);
int __cdecl factor_cmd(char *cp);
int __cdecl echo_cmd(char *cp);
void __cdecl output_options(FILE *ofp);
int save_set_options(); // idb
int version_report(); // idb
int __cdecl version_cmd(char *cp);
int __cdecl copy_cmd(char *cp);
int __cdecl replace_cmd(char *cp);
int __cdecl approximate_cmd(char *cp);
int __cdecl variables_cmd(char *cp);
int __cdecl code_cmd(char *cp);
int __cdecl list_cmd(char *cp);
int __cdecl save_cmd(char *cp);
int __cdecl clear_cmd(char *cp);
// int __usercall elim_sub@<eax>(int i@<eax>, int v@<edx>); idb
int __cdecl display_fraction(double value);
int __cdecl divide_cmd(char *cp);
// int __usercall compare_rhs@<eax>(int i@<eax>, int j@<edx>, int *diff_signp@<ecx>); idb
int __cdecl compare_es(int i, int j);
int __cdecl compare_cmd(char *cp);
// int __usercall find_more@<eax>(token_type *equation@<eax>, int *np@<edx>, int en@<ecx>); idb
int __cdecl tally_cmd(char *cp);
// int __usercall complex_func@<eax>(char *cp@<eax>, int imag_flag@<edx>); idb
int __cdecl imaginary_cmd(char *cp);
int __cdecl real_cmd(char *cp);
int __cdecl pause_cmd(char *cp);
int __cdecl output_current_directory(FILE *ofp);
int __cdecl set_options(char *cp);
int __cdecl set_cmd(char *cp);
int __cdecl push_en(int en);
int __cdecl push_cmd(char *cp);
// int __usercall opt_es@<eax>(token_type *equation@<eax>, int *np@<edx>); idb
int __cdecl optimize_cmd(char *cp);
// int __usercall sum_product@<eax>(char *cp@<eax>, int product_flag@<edx>); idb
int __cdecl product_cmd(char *cp);
int __cdecl sum_cmd(char *cp);
int __cdecl solve_cmd(char *cp);
int __cdecl plot_cmd(char *cp);
int __cdecl read_sub(FILE *fp);
int __cdecl read_file(char *cp);
int __cdecl read_cmd(char *cp);
// int __usercall edit_sub@<eax>(char *cp@<eax>); idb
int __cdecl edit_cmd(char *cp);
int __cdecl display_cmd(char *cp);
int __cdecl eliminate_cmd(char *cp);
int __cdecl simplify_cmd(char *cp);
int __cdecl calculate_cmd(char *cp);
// void __usercall org_up_level(token_type *bp_0@<eax>, token_type *ep@<edx>, int level@<ecx>, int invert); idb
// int __usercall org_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int *elocp); idb
int __cdecl simpb_vcmp(sort_type *p1, sort_type *p2);
int __cdecl div_imaginary(token_type *equation, int *np);
int __cdecl simp2_power(token_type *equation, int *np);
int __cdecl simp_constant_power(token_type *equation, int *np);
int __cdecl rationalize(token_type *equation, int *np);
// int __usercall order_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level); idb
int __cdecl reorder(token_type *equation, int *np);
int __cdecl elim_sign(token_type *equation, int *np);
int __cdecl simp_pp(token_type *equation, int *np);
// _BOOL4 __usercall compare_recurse@<eax>(token_type *p1@<eax>, int n1@<edx>, int l1@<ecx>, token_type *p2, int n2, int l2, int *diff_signp);
int __cdecl se_compare(token_type *p1, int n1, token_type *p2, int n2, int *diff_signp);
int __cdecl elim_k(token_type *equation, int *np);
int __cdecl calc(int *op1p, double *k1p, int op2, double k2_0);
// int __usercall const_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int iflag); idb
int __cdecl combine_constants(token_type *equation, int *np, int iflag);
int __cdecl integer_root_simp(token_type *equation, int *np);
void __cdecl organize(token_type *equation, int *np);
void __cdecl elim_loop(token_type *equation, int *np);
int __cdecl simp_loop(token_type *equation, int *np);
void __cdecl simp_divide(token_type *equation, int *np);
void __cdecl factorv(token_type *equation, int *np, int v);
void __cdecl simp_equation(int n);
void __cdecl simp2_divide(token_type *equation, int *np, int v, int fc_level);
void __cdecl simp_ssub(token_type *equation, int *np, int v, double d, int power_flag, int times_flag, int fc_level);
void __cdecl simpb_side(token_type *equation, int *np, int uf_power_flag, int power_flag, int fc_level);
void __cdecl simple_frac_side(token_type *equation, int *np);
void __cdecl simpv_side(token_type *equation, int *np, int v);
void __cdecl simp_side(token_type *equation, int *np);
void __cdecl calc_simp(token_type *equation, int *np);
void __cdecl simps_side(token_type *equation, int *np, int zsolve);
void __cdecl simp_i(token_type *equation, int *np);
void __cdecl simpa_side(token_type *equation, int *np, int quick_flag, int frac_flag);
void __cdecl simpa_repeat_side(token_type *equation, int *np, int quick_flag, int frac_flag);
// int __usercall fpower_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level); idb
int __cdecl factor_power(token_type *equation, int *np);
// int __usercall ftimes_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level); idb
int __cdecl factor_times(token_type *equation, int *np);
// int __usercall big_fplus@<eax>(token_type *equation@<eax>, int level@<edx>, int diff_sign@<ecx>, int sop1, int op1, int op2, int i1, int i2, int b1, int b2, int ai, int aj, int i, int j, int e1, int e2); idb
// int __usercall fplus_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int v, double d, int whole_flag, int div_only); idb
int __cdecl factor_plus(token_type *equation, int *np, int v, double d);
int __cdecl subtract_itself(token_type *equation, int *np);
int __cdecl factor_divide(token_type *equation, int *np, int v, double d);
// int __usercall sf_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int start_flag); idb
// void __usercall group_recurse(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level); idb
void __cdecl group_proc(token_type *equation, int *np);
int __cdecl super_factor(token_type *equation, int *np, int start_flag);
int __cdecl fractions_and_group(token_type *equation, int *np);
int __cdecl make_fractions_and_group(int n);
int __cdecl patch_root_div(token_type *equation, int *np);
void __cdecl uf_neg_help(token_type *equation, int *np);
int __cdecl unsimp_power(token_type *equation, int *np);
int __cdecl sub_ufactor(token_type *equation, int *np, int ii);
void __cdecl uf_repeat_always(token_type *equation, int *np);
void __cdecl uf_repeat(token_type *equation, int *np);
void __cdecl uf_allpower(token_type *equation, int *np);
int __cdecl uf_pplus(token_type *equation, int *np);
int __cdecl uf_power(token_type *equation, int *np);
int __cdecl uf_times(token_type *equation, int *np);
int __cdecl ufactor(token_type *equation, int *np);
int __cdecl uf_tsimp(token_type *equation, int *np);
void __cdecl uf_simp_no_repeat(token_type *equation, int *np);
void __cdecl uf_simp(token_type *equation, int *np);
int __cdecl vcmp_0(sort_type *p1, sort_type *p2);
int __cdecl get_term(token_type *p1, int n1, int count, int *tp1, int *lentp1);
void __cdecl term_value(double *dp, token_type *p1, int n1, int loc);
int __cdecl basic_size(token_type *p1, int len);
int __cdecl poly_in_v(token_type *p1, int n, int v, int allow_divides);
int __cdecl smart_div(token_type *d1, int len1, token_type *d2, int len2);
// void __usercall save_factors(token_type *equation@<eax>, int *np@<edx>, int loc1@<ecx>, int len, int level); idb
int __cdecl is_integer_var(int v);
int __cdecl is_integer_expr(token_type *p1, int n);
int remove_factors(); // idb
int __cdecl find_greatest_power(token_type *p1, int n1, int *vp1, double *pp1, int *tp1, int *lentp1, int *dcodep);
// int __usercall find_highest_count@<eax>(token_type *p1@<eax>, int n1@<edx>, token_type *p2@<ecx>, int n2, int *vp1); idb
int __cdecl poly_div(token_type *d1, int len1, token_type *d2, int len2, int *vp);
// int __usercall do_gcd@<eax>(int *vp@<eax>); idb
// int __usercall pdiv_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int code); idb
int __cdecl div_remainder(token_type *equation, int *np, int poly_flag, int quick_flag);
// int __usercall mod_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level); idb
int __cdecl mod_simp(token_type *equation, int *np);
int __cdecl poly_gcd(token_type *larger, int llen, token_type *smaller, int slen, int v);
int __cdecl poly2_gcd(token_type *larger, int llen, token_type *smaller, int slen, int v);
// int __usercall polydiv_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level); idb
int __cdecl poly_gcd_simp(token_type *equation, int *np);
// int __usercall pf_sub@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int len, int level, int do_repeat); idb
// int __usercall pf_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int do_repeat); idb
int __cdecl poly_factor(token_type *equation, int *np, int do_repeat);
int __cdecl limit_cmd(char *cp);
// int __usercall d_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int v); idb
int __cdecl differentiate(token_type *equation, int *np, int v);
int __cdecl taylor_cmd(char *cp);
int __cdecl extrema_cmd(char *cp);
int __cdecl derivative_cmd(char *cp);
int __cdecl nintegrate_cmd(char *cp);
void __cdecl make_powers(token_type *equation, int *np, int v);
int __cdecl int_dispatch(token_type *equation, int *np, int v, int (*func)(...));
int __cdecl laplace_cmd(char *cp);
int __cdecl laplace_sub(token_type *equation, int *np, int loc, int eloc, int v);
int __cdecl inv_laplace_sub(token_type *equation, int *np, int loc, int eloc, int v);
int __cdecl integrate_sub(token_type *equation, int *np, int loc, int eloc, int v);
int __cdecl integrate_cmd(char *cp);
int __cdecl get_constant(token_type *p1, int n, double *dp);
int __cdecl parse_complex(token_type *p1, int n, complexs_0 *cp);
int __cdecl complex_root_simp(token_type *equation, int *np);
void __cdecl approximate_complex_roots(token_type *equation, int *np);
void __cdecl rect_to_polar(double x, double y, double *radiusp, double *thetap);
int __cdecl roots_cmd(char *cp);
int __cdecl complex_fixup(complexs_0 *ap);
// complexs_0 *__userpurge complex_add@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b);
// complexs_0 *__userpurge complex_negate@<eax>(complexs_0 *retstr, complexs_0 a);
// complexs_0 *__userpurge complex_mult@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b);
// complexs_0 *__userpurge complex_div@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b);
// complexs_0 *__userpurge complex_exp@<eax>(complexs_0 *retstr, complexs_0 a);
// complexs_0 *__userpurge complex_log@<eax>(complexs_0 *retstr, complexs_0 a);
// complexs_0 *__userpurge complex_pow@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b);
char *__cdecl var_name(int v);
// void __usercall trim_zeros(char *buf@<eax>); idb
int __cdecl int_expr(token_type *p1, int n);
int __cdecl list_var(int v, int lang_code);
int __cdecl list_code(token_type *equation, int *np, language_list language, int int_flag);
int __cdecl list_c_equation(int en, language_list language, int int_flag);
void __cdecl set_color(int color);
// int __usercall flist_recurse@<eax>(token_type *p1@<eax>, int n@<edx>, int out_flag@<ecx>, int line, int pos, int cur_level, int *highp, int *lowp); idb
int __cdecl list_string_sub(token_type *p1, int n, int outflag, char *string, int export_flag);
int __cdecl list_string(token_type *p1, int n, char *string, int export_flag);
char *__cdecl list_expression(token_type *p1, int n, int export_flag);
char *__cdecl list_equation(int n, int export_flag);
int __cdecl list_proc(token_type *p1, int n, int export_flag);
void __cdecl list_debug(int level, token_type *p1, int n1, token_type *p2, int n2);
int __cdecl list1_sub(int n, int export_flag);
void default_color(); // idb
// int __usercall flist_sub@<eax>(token_type *p1@<eax>, int n@<edx>, int out_flag@<ecx>, int pos, int *highp, int *lowp); idb
int __cdecl flist_equation(int n);
int __cdecl list_sub(int n);
void reset_attr(); // idb
double __cdecl gcd(double d1, double d2);
double __cdecl gcd_verified(double d1, double d2);
double __cdecl my_round(double d1);
int __cdecl f_to_fraction(double d, double *numeratorp, double *denominatorp);
int __cdecl make_fractions(token_type *equation, int *np);
long double multiply_out_unique();
_BOOL4 is_prime();
// int __usercall fc_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int level_code); idb
int __cdecl factor_constants(token_type *equation, int *np, int level_code);
void display_unique(); // idb
void __cdecl try_factor(double arg);
int __cdecl factor_one(double value);
int __cdecl factor_int(token_type *equation, int *np);
int __cdecl list_factor(token_type *equation, int *np, int factor_flag);
void __cdecl factor_int_sub(int n);
void _libc_csu_fini(void); // idb
void _libc_csu_init(void); // idb
void (*_do_global_ctors_aux())(void);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

char asc_80727BC[2] = "="; // weak
char asc_8072942[27] = "--------------------------"; // weak
const com_type com_list[42] =
{
  {
    "approximate",
    NULL,
    &approximate_cmd,
    "[equation-number-ranges]",
    "Approximate all numerical values in equation spaces.",
    NULL
  },
  {
    "calculate",
    NULL,
    &calculate_cmd,
    "[\"factor\"] [variable number-of-iterations]",
    "Temporarily plug in values for variables and approximate.",
    "This command may be preceded with \"repeat\"."
  },
  {
    "clear",
    NULL,
    &clear_cmd,
    "[equation-number-ranges]",
    "Delete expressions stored in memory so equation spaces can be reused.",
    "Tip: Use \"clear all\" to quickly restart Mathomatic."
  },
  {
    "code",
    NULL,
    &code_cmd,
    "[\"c\" or \"java\" or \"python\" or \"integer\"] [equation-number-ranges]",
    "Output C, Java, or Python code for the specified equations.",
    "Related commands: simplify, optimize, and variables"
  },
  {
    "compare",
    NULL,
    &compare_cmd,
    "[\"symbolic\"] equation-number [\"with\" equation-number]",
    "Compare two equation spaces to see if they are mathematically the same.",
    NULL
  },
  {
    "copy",
    NULL,
    &copy_cmd,
    "[equation-number-range]",
    "Duplicate the contents of the specified equation spaces.",
    NULL
  },
  {
    "derivative",
    "differentiate",
    &derivative_cmd,
    "[\"nosimplify\"] [variable or \"all\"] [order]",
    "Symbolically differentiate and simplify, order times.",
    NULL
  },
  {
    "display",
    NULL,
    &display_cmd,
    "[\"factor\"] [equation-number-ranges]",
    "Display equation spaces in pretty multi-line (2D) fraction format.",
    NULL
  },
  {
    "divide",
    NULL,
    &divide_cmd,
    "[variable]",
    "Prompt for 2 numbers or polynomials and divide. Give result and GCD.",
    "This command may be preceded with \"repeat\"."
  },
  {
    "echo",
    NULL,
    &echo_cmd,
    "[text]",
    "Output a line of text, followed by a newline.",
    NULL
  },
  {
    "edit",
    NULL,
    &edit_cmd,
    "[file-name]",
    "Edit all equation spaces or an input file, then read them in.",
    NULL
  },
  {
    "eliminate",
    NULL,
    &eliminate_cmd,
    "variables or \"all\" [\"using\" equation-number]",
    "Substitute the specified variables with solved equations.",
    "This command may be preceded with \"repeat\"."
  },
  {
    "extrema",
    NULL,
    &extrema_cmd,
    "[variable] [order]",
    "Show where the slope of the current equation equals zero.",
    NULL
  },
  {
    "factor",
    "collect",
    &factor_cmd,
    "[\"number\" [integers]] or [\"power\"] [equation-number-range] [variables]",
    "Factor variables in equation spaces or factor given integers.",
    NULL
  },
  {
    "fraction",
    "together",
    &fraction_cmd,
    "[equation-number-range]",
    "Convert expression to a single simple fraction, if any fractions are in it.",
    NULL
  },
  {
    "help",
    NULL,
    &help_cmd,
    "[topic or command-names]",
    "Short, built-in help and reference.",
    NULL
  },
  {
    "imaginary",
    NULL,
    &imaginary_cmd,
    "[variable]",
    "Copy the imaginary part of the current expression.",
    "Related command: real"
  },
  {
    "integrate",
    "integral",
    &integrate_cmd,
    "[\"constant\" or \"definite\"] variable [order]",
    "Symbolically integrate polynomials order times, then simplify.",
    NULL
  },
  {
    "laplace",
    NULL,
    &laplace_cmd,
    "[\"inverse\"] variable",
    "Compute the Laplace or inverse Laplace transform of polynomials.",
    NULL
  },
  {
    "limit",
    NULL,
    &limit_cmd,
    "variable expression",
    "Take the limit as variable goes to expression (experimental).",
    NULL
  },
  {
    "list",
    NULL,
    &list_cmd,
    "[\"export\" or \"maxima\" or \"gnuplot\"] [equation-number-ranges]",
    "Display equation spaces in single-line format.",
    NULL
  },
  {
    &unk_8072B23,
    NULL,
    &nintegrate_cmd,
    "[\"trapezoid\"] variable [partitions]",
    "Do numerical definite integration using Simpson's rule.",
    NULL
  },
  {
    "optimize",
    NULL,
    &optimize_cmd,
    "[equation-number-range]",
    "Split up equations into smaller, more efficient equations.",
    &unk_8072B37
  },
  {
    "pause",
    NULL,
    &pause_cmd,
    "[text]",
    "Wait for user to press the Enter key. Optionally display a message.",
    NULL
  },
  {
    (char *)0x8075921,
    NULL,
    &plot_cmd,
    "[expression]",
    "Automatically plot expression in 2D or 3D with Gnuplot.",
    NULL
  },
  {
    "product",
    NULL,
    &product_cmd,
    "variable start end [step-size]",
    "Compute the product as variable goes from start to end.",
    "Related command: sum"
  },
  {
    "push",
    NULL,
    &push_cmd,
    "[equation-number-range]",
    "Push the specified expressions into the readline history.",
    NULL
  },
  {
    "quit",
    "exit",
    &quit_cmd,
    "[exit-value]",
    "Terminate this program without saving.",
    NULL
  },
  {
    "read",
    NULL,
    &read_cmd,
    "file-name",
    "Read in a text file as if it was typed in.",
    NULL
  },
  {
    (char *)0x8072AD9,
    NULL,
    &real_cmd,
    "[variable]",
    "Copy the real part of the current expression.",
    &unk_8072B9B
  },
  {
    "replace",
    NULL,
    &replace_cmd,
    "[variables [\"with\" expression]]",
    "Substitute variables in the current equation with expressions.",
    NULL
  },
  {
    "roots",
    NULL,
    &roots_cmd,
    "root real-part imaginary-part",
    "Display all the roots of a complex number.",
    "This command may be preceded with \"repeat\"."
  },
  {
    "save",
    NULL,
    &save_cmd,
    "file-name",
    "Save all equation spaces in a text file.",
    &unk_8072BE7
  },
  {
    "set",
    NULL,
    &set_cmd,
    "[[\"no\"] option] ...",
    "Display, set, or save current session options.",
    "Tip: Type \"set\" by itself to show all current option settings."
  },
  {
    (char *)0x80770B5,
    NULL,
    &simplify_cmd,
    "[\"sign\"] [\"symbolic\"] [\"quick\"] [\"quickest\"] [\"fraction\"] [equation-number-range]",
    "Completely simplify expressions.",
    "This command may be preceded with \"repeat\"."
  },
  {
    (char *)0x8075BCB,
    NULL,
    &solve_cmd,
    "[\"verify\"] [\"for\"] variable or \"0\"",
    "Solve the current equation for a variable or for zero.",
    NULL
  },
  {
    (char *)0x8072B71,
    NULL,
    &sum_cmd,
    "variable start end [step-size]",
    "Compute the summation as variable goes from start to end.",
    &unk_8072C15
  },
  {
    "tally",
    NULL,
    &tally_cmd,
    "[\"average\"]",
    "Prompt for and add entries, show total and optionally the average.",
    NULL
  },
  {
    "taylor",
    NULL,
    &taylor_cmd,
    "[\"nosimplify\"] variable order point",
    "Compute the Taylor series expansion of the current expression.",
    NULL
  },
  {
    &unk_8072C47,
    "expand",
    &unfactor_cmd,
    "[\"fraction\"] [\"quick\"] [\"power\"] [equation-number-range]",
    "Algebraically expand (multiply out) expressions.",
    NULL
  },
  {
    "variables",
    NULL,
    &variables_cmd,
    "[\"c\" or \"java\" or \"integer\"] [equation-number-range]",
    "Show all variable names used within the specified expressions.",
    &unk_8072B37
  },
  {
    "version",
    NULL,
    &version_cmd,
    (char *)0x80757FE,
    "Display Mathomatic version and license information.",
    NULL
  }
}; // idb
const char accept[3] = ";\n\r"; // idb
_UNKNOWN unk_8077990; // weak
_UNKNOWN unk_8077991; // weak
char *const bright_html_carray[7] = { "#00FF00", "#FFFF00", "#FF0000", "#FF9000", "#FF00FF", "#00FFFF", "#0000FF" }; // idb
char *const html_carray[7] = { "green", "olive", "red", "maroon", "purple", "teal", "navy" }; // idb
const int carray[6] = { 32, 33, 31, 35, 34, 36 }; // idb
const double skip_multiples[48] =
{
   10.0,
   2.0,
   4.0,
   2.0,
   4.0,
   6.0,
   2.0,
   6.0,
   4.0,
   2.0,
   4.0,
   6.0,
   6.0,
   2.0,
   6.0,
   4.0,
   2.0,
   6.0,
   4.0,
   6.0,
   8.0,
   4.0,
   2.0,
   4.0,
   2.0,
   4.0,
   8.0,
   6.0,
   4.0,
   6.0,
   2.0,
   4.0,
   6.0,
   2.0,
   6.0,
   6.0,
   4.0,
   2.0,
   4.0,
   6.0,
   2.0,
   6.0,
   4.0,
   2.0,
   4.0,
   2.0,
   10.0,
   2.0
}; // idb
int _CTOR_LIST__ = -1; // weak
int _DTOR_LIST__[] = { -1 }; // weak
int _DTOR_END__ = 0; // weak
int _JCR_LIST__ = 0; // weak
int (*dword_8078FFC)(void) = NULL; // weak
int n_tokens = 60000; // idb
int precision = 14; // idb
int case_sensitive_flag = 1; // idb
int display2d = 1; // idb
int preserve_surds = 1; // idb
int rationalize_denominators = 1; // idb
int modulus_mode = 2; // idb
volatile int screen_columns = 80; // idb
volatile int screen_rows = 24; // idb
int autosolve = 1; // idb
int autocalc = 1; // idb
int autoselect = 1; // idb
char special_variable_characters[256] =
{
  '\'',
  '\\',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int negate_highest_precedence = 1; // idb
int color_flag = 1; // idb
int cur_color = -1; // idb
double small_epsilon =  5.0e-15; // idb
double epsilon =  5.0e-14; // idb
char *prog_name = "mathomatic"; // idb
int readline_enabled = 1; // idb
int symblify = 1; // idb
int result_en = -1; // idb
char *license_string = "    Mathomatic computer algebra system\n    Copyright (C) 1987-2010 George Gesslein II\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n\nThe full text of this license with details is contained in the file \"COPYING\"\nin the Mathomatic source distribution obtained from http://mathomatic.org\nAll Mathomatic files are published under this license.\n\nChief author, maintainer, and copyright holder contact information:\n  email:\n    gesslein@linux.com\n  postal address:\n    George Gesslein II\n    P.O. Box 224\n    Lansing, New York  14882-0224\n    USA\n"; // idb
char *example_strings[18] =
{
  "; The derivative of the absolute value function:\n",
  "|x|\n",
  "derivative\n",
  "pause\n",
  (char *)0x80757FD,
  "; Enter a common temperature conversion formula:\n",
  "fahrenheit = (9*celsius/5) + 32\n",
  "repeat calculate ; plug in values until an empty line is entered\n",
  "; Solve for the other variable and simplify the result:\n",
  "solve for celsius\n",
  "simplify\n",
  "variables ; show all variables that occur in an expression\n",
  "pause\n",
  (char *)0x80757FD,
  "; Expand the following exponentiated sum into polynomial form:\n",
  "(x+1)^5\n",
  "unfactor\n",
  NULL
}; // idb
int constant_var_number = 1; // idb
int rl_inhibit_completion; // weak
int optind; // weak
FILE *stderr; // idb
int signgam; // weak
FILE *stdin; // idb
FILE *stdout; // idb
char completed_7065; // weak
int dtor_idx_7067; // weak
int integer_coefficients; // idb
int last_int_var; // idb
int prev_n2_10129; // idb
int prev_n1_10128; // idb
int repeat_count; // idb
int last_temp_var; // idb
int opt_en[100]; // idb
int cur_line; // idb
int cur_pos; // idb
double nn; // idb
double vv; // idb
char prompt_str[80]; // idb
token_type *tlhs; // idb
int n_tes; // idb
token_type *trhs; // idb
jmp_buf jmp_save; // idb
int quiet_mode; // idb
int cur_equation; // idb
token_type one_token; // idb
int symb_flag; // idb
int n_tlhs; // idb
FILE *default_out; // idb
int test_mode; // idb
int power_starstar; // idb
int ucnt[64]; // idb
int sign_cmp_flag; // idb
int approximate_roots; // idb
_UNKNOWN unk_80797FF; // weak
char var_str[180]; // idb
int n_trhs; // idb
char sign_array[64]; // idb
int security_level; // idb
int right_associative_power; // idb
int pull_number; // idb
int finance_option; // idb
char *history_filename; // idb
token_type zero_token; // idb
char *result_str; // idb
int n_rhs[100]; // idb
int bold_colors; // idb
char *var_names[8000]; // idb
char *last_history_string; // idb
FILE *gfp; // idb
double unique[64]; // idb
int n_equations; // idb
const char *error_str; // idb
char history_filename_storage[4096]; // idb
token_type *scratch; // idb
int uno; // idb
token_type *lhs[100]; // idb
volatile int abort_flag; // idb
int partial_flag; // idb
int debug_level; // idb
int factor_int_flag; // idb
token_type *rhs[100]; // idb
int echo_input; // idb
const char *warning_str; // idb
int n_lhs[100]; // idb
int html_flag; // idb
int domain_check; // idb
int high_prec; // idb
int repeat_flag; // idb
token_type *tes; // idb
char rc_file[4096]; // idb
int input_column; // idb
int point_flag; // idb
int n_divisor; // idb
token_type quotient[30000]; // idb
token_type gcd_divisor[30000]; // idb
int n_quotient; // idb
int len_d; // idb
int dword_816E598[]; // weak
token_type divisor[30000]; // idb
// extern _UNKNOWN _gmon_start__; weak


//----- (08048E54) --------------------------------------------------------
int init_proc()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( &_gmon_start__ )
    __gmon_start__();
  frame_dummy();
  _do_global_ctors_aux();
  return v1;
}
// 8048E80: variable 'v1' is possibly undefined
// 8048F24: using guessed type int __gmon_start__(void);

//----- (08048E84) --------------------------------------------------------
int sub_8048E84()
{
  return dword_8078FFC();
}
// 8078FFC: using guessed type int (*dword_8078FFC)(void);

//----- (080492D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, _libc_csu_init, _libc_csu_fini, a2, &v3);
  __halt();
}
// 80492D3: positive sp value 4 has been found

//----- (08049300) --------------------------------------------------------
void _do_global_dtors_aux()
{
  int v0; // eax
  unsigned int i; // ebx

  if ( !completed_7065 )
  {
    v0 = dtor_idx_7067;
    for ( i = &_DTOR_END__ - _DTOR_LIST__ - 1; dtor_idx_7067 < i; v0 = dtor_idx_7067 )
    {
      dtor_idx_7067 = v0 + 1;
      ((void (*)(void))_DTOR_LIST__[v0 + 1])();
    }
    completed_7065 = 1;
  }
}
// 8078F04: using guessed type int _DTOR_LIST__[];
// 8078F08: using guessed type int _DTOR_END__;
// 80793A4: using guessed type char completed_7065;
// 80793A8: using guessed type int dtor_idx_7067;

//----- (08049360) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  result = _JCR_LIST__;
  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 8078F0C: using guessed type int _JCR_LIST__;

//----- (08049390) --------------------------------------------------------
void __cdecl fphandler(int sig)
{
  ;
}

//----- (08049395) --------------------------------------------------------
void __cdecl __noreturn exit_program(int exit_value)
{
  reset_attr();
  if ( html_flag )
    __printf_chk(1, "</pre>\n");
  if ( readline_enabled && write_history(history_filename) )
    __fprintf_chk(stderr, 1, "%s: Unable to save readline history into file \"%s\".\n", prog_name, history_filename);
  if ( !exit_value && !quiet_mode && !html_flag )
    __printf_chk(1, "Thank you for using Mathomatic!\n");
  exit(exit_value);
}
// 8048EE4: using guessed type int __cdecl write_history(_DWORD);
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804943C) --------------------------------------------------------
void __cdecl __noreturn exithandler(int sig)
{
  exit_program(1);
}

//----- (08049450) --------------------------------------------------------
void __cdecl __noreturn alarmhandler(int sig)
{
  __printf_chk(1, "\nTimeout, quitting...\n");
  exit_program(1);
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08049478) --------------------------------------------------------
void __cdecl inthandler(int sig)
{
  if ( ++abort_flag < 0 )
    goto LABEL_6;
  if ( abort_flag > 1 )
  {
    if ( abort_flag == 2 )
    {
      __printf_chk(1, "\nPress Control-C once more to quit program.\n");
      return;
    }
LABEL_6:
    __printf_chk(1, "\nRepeatedly interrupted; returning to operating system...\n");
    exit_program(1);
  }
  __printf_chk(1, "\nUser interrupt signal received; three times quits Mathomatic.\n");
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (080494F0) --------------------------------------------------------
void usage()
{
  __printf_chk(1, "\nMathomatic computer algebra system version %s\n\n", "15.1.1");
  __printf_chk(1, "Usage: %s [ options ] [ input_files ]\n\n", prog_name);
  __printf_chk(1, "Options:\n");
  __printf_chk(1, "  -b            Enable bold color mode.\n");
  __printf_chk(1, "  -c            Toggle color mode.\n");
  __printf_chk(1, "  -h            Display this help and exit.\n");
  __printf_chk(1, "  -m number     Specify a memory size multiplier.\n");
  __printf_chk(1, "  -q            Set quiet mode (don't display prompts).\n");
  __printf_chk(1, "  -r            Disable readline.\n");
  __printf_chk(1, "  -s level      Set enforced security level for session.\n");
  __printf_chk(1, "  -t            Set test mode.\n");
  __printf_chk(1, "  -u            Set unbuffered output.\n");
  __printf_chk(1, "  -v            Display version information, then exit.\n");
  __printf_chk(1, "  -w            Wide output mode, sets unlimited width.\n");
  __printf_chk(1, "  -x            Enable HTML/XHTML output mode.\n");
  __printf_chk(1, "\nPlease refer to the Mathomatic man page for more information.\n");
  __printf_chk(1, "The man page is viewed by typing \"man mathomatic\" in shell.\n");
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804965D) --------------------------------------------------------
void __cdecl resizehandler(int sig)
{
  if ( screen_columns )
    get_screen_size();
}

//----- (08049673) --------------------------------------------------------
int load_rc()
{
  char *v0; // eax
  FILE *v1; // edi
  int v2; // esi
  char *v3; // eax
  char *v4; // ebx
  char buf[4096]; // [esp+2Ch] [ebp-101Ch] BYREF
  unsigned int v7; // [esp+102Ch] [ebp-1Ch]

  v7 = __readgsdword(0x14u);
  v0 = getenv("HOME");
  if ( !v0 )
    return 1;
  __snprintf_chk(rc_file, 4096, 1, 4096, "%s/%s", v0, ".mathomaticrc");
  v1 = fopen(rc_file, "r");
  if ( !v1 )
    return 1;
  v2 = 1;
  while ( 1 )
  {
    v3 = fgets(buf, 4096, v1);
    v4 = v3;
    if ( !v3 )
      break;
    set_error_level(v3);
    if ( !set_options(v4) )
      v2 = 0;
  }
  fclose(v1);
  return v2;
}
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08049760) --------------------------------------------------------
_BOOL4 set_signals()
{
  __sighandler_t v0; // esi
  _BOOL4 v1; // ebx

  v0 = signal(8, fphandler);
  v1 = 0;
  if ( signal(2, inthandler) != (__sighandler_t)-1 )
    v1 = (__sighandler_t)((char *)v0 + 1) != 0;
  if ( signal(3, inthandler) == (__sighandler_t)-1 )
    v1 = 0;
  if ( signal(15, exithandler) == (__sighandler_t)-1 )
    v1 = 0;
  if ( signal(1, exithandler) == (__sighandler_t)-1 )
    v1 = 0;
  if ( signal(28, resizehandler) == (__sighandler_t)-1 )
    v1 = 0;
  return v1;
}

//----- (0804982A) --------------------------------------------------------
void main_io_loop()
{
  const char *v0; // eax
  char *v1; // eax

  while ( 1 )
  {
    default_color();
    v0 = "-> ";
    if ( html_flag )
      v0 = "&mdash;&gt; ";
    __snprintf_chk(prompt_str, 80, 1, 80, "%d%s", cur_equation + 1, v0);
    v1 = get_string((char *)tlhs, 16 * n_tokens);
    if ( !v1 )
      break;
    process(v1);
  }
}
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080498B9) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int v4; // eax
  char *v5; // eax
  const char *v6; // edx
  const char *v7; // eax
  int v8; // ebx
  int v9; // esi
  char *v10; // eax
  char **v11; // ebx
  int result; // eax
  const char **v13; // [esp+24h] [ebp-3Ch]
  double denominatorp; // [esp+38h] [ebp-28h] BYREF
  double numeratorp; // [esp+40h] [ebp-20h] BYREF
  char *endptr; // [esp+4Ch] [ebp-14h]

  endptr = 0;
  init_gvars();
  default_out = stdout;
  gfp = stdout;
  v4 = getopt(argc, (char *const *)argv, "s:bqrtchuvwxm:");
  if ( v4 < 0 )
  {
    if ( n_tokens <= 99 )
    {
      __fprintf_chk(stderr, 1, "%s: Expression array size too small.\n", prog_name);
      exit(2);
    }
    if ( !init_mem() )
    {
      __fprintf_chk(stderr, 1, "%s: Not enough memory.\n", prog_name);
      exit(2);
    }
    if ( readline_enabled )
    {
      v5 = getenv("HOME");
      endptr = v5;
      if ( v5 && prog_name )
      {
        __snprintf_chk(history_filename_storage, 4096, 1, 4096, "%s/.%s_history", v5, prog_name);
        history_filename = history_filename_storage;
      }
      rl_initialize();
      using_history();
      stifle_history(500);
      rl_inhibit_completion = 1;
      if ( !html_flag )
        color_flag = tigetnum("colors") > 7;
      read_history(history_filename);
    }
    get_screen_size();
    if ( html_flag )
      __printf_chk(1, "<pre>\n");
    if ( !test_mode )
    {
      if ( quiet_mode )
        goto LABEL_61;
      if ( security_level > 1 )
        __printf_chk(1, "Secure ");
      __printf_chk(1, "Mathomatic version %s (www.mathomatic.org)\n", "15.1.1");
      __printf_chk(1, "Copyright (C) 1987-2010 George Gesslein II.\n");
      __printf_chk(1, "%d equation spaces available, %ld kilobytes per equation space.\n", 100, 32 * n_tokens / 0x3E8u);
      if ( !test_mode )
      {
LABEL_61:
        if ( !load_rc() )
          __fprintf_chk(stderr, 1, "%s: Error loading set options from \"%s\".\n", prog_name, rc_file);
      }
    }
    if ( test_mode )
      color_flag = 0;
    if ( !quiet_mode && color_flag )
    {
      v6 = " bold";
      if ( !bold_colors )
        v6 = "";
      v7 = "ANSI";
      if ( html_flag )
        v7 = "HTML";
      __printf_chk(1, "%s%s color mode enabled", v7, v6);
      __printf_chk(1, "; disable with the -c option or \"set no color\".\n");
    }
    v8 = _setjmp(jmp_save);
    if ( v8 )
    {
      clean_up();
      if ( v8 == 14 )
        error("Expression too large.");
      __printf_chk(1, "Operation aborted.\n");
    }
    else
    {
      if ( !set_signals() )
        __fprintf_chk(stderr, 1, "signal(2) setting failed.\n");
      if ( !f_to_fraction(0.5, &numeratorp, &denominatorp)
        || numeratorp != 1.0
        || denominatorp != 2.0
        || !f_to_fraction(0.3333333333333333, &numeratorp, &denominatorp)
        || numeratorp != 1.0
        || denominatorp != 3.0 )
      {
        __fprintf_chk(stderr, 1, "%s: Cannot convert any floating point values to fractions.\n", prog_name);
        __fprintf_chk(stderr, 1, "Roots will not work properly.\n");
      }
      v9 = optind;
      if ( argc > optind )
      {
        v13 = &argv[optind];
        v10 = (char *)*v13;
        if ( *v13 )
        {
          v11 = (char **)&argv[optind + 1];
          do
          {
            if ( *v10 == asc_8072942[25] && v10[1] == asc_8072942[26] )
            {
              main_io_loop();
            }
            else if ( !read_file(v10) )
            {
              __fprintf_chk(stderr, 1, "Read of file \"%s\" failed.\n", *v13);
              exit_program(1);
            }
            if ( argc <= ++v9 )
              break;
            v13 = (const char **)v11;
            v10 = *v11++;
          }
          while ( v10 );
        }
      }
    }
    main_io_loop();
    exit_program(0);
  }
  v3 = v4 - 98;
  if ( v3 <= 0x16 )
    __asm { jmp     dword ptr [ebx+eax*4] }
  usage();
  exit(2);
  return result;
}
// 8049D22: conditional instruction was optimized away because of '%0x28.4==0'
// 8049DA6: conditional instruction was optimized away because of '%0x28.4==0'
// 80498B9: variable 'result' is possibly undefined
// 8048EC4: using guessed type int rl_initialize(void);
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8048F54: using guessed type int __cdecl read_history(_DWORD);
// 8049154: using guessed type int __cdecl stifle_history(_DWORD);
// 8049204: using guessed type int using_history(void);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);
// 8079340: using guessed type int rl_inhibit_completion;
// 8079360: using guessed type int optind;

//----- (08049FD0) --------------------------------------------------------
void init_gvars()
{
  domain_check = 0;
  high_prec = 0;
  partial_flag = 1;
  symb_flag = 0;
  sign_cmp_flag = 0;
  approximate_roots = 0;
  repeat_flag = 0;
  zero_token.level = 1;
  zero_token.kind = CONSTANT;
  zero_token.token.constant = 0.0;
  one_token.level = 1;
  one_token.kind = CONSTANT;
  one_token.token.constant = 1.0;
}

//----- (0804A053) --------------------------------------------------------
int __cdecl next_sign(int *vp)
{
  int v1; // eax

  v1 = 1;
  if ( sign_array[0] )
  {
    while ( sign_array[v1] )
    {
      if ( ++v1 == 64 )
      {
        *vp = 4;
        return 0;
      }
    }
  }
  else
  {
    LOBYTE(v1) = 0;
  }
  *vp = (v1 << 14) + 4;
  sign_array[v1] = 1;
  return 1;
}

//----- (0804A0A7) --------------------------------------------------------
int __cdecl found_var(token_type *p1, int n, int v)
{
  int i; // ecx
  int count; // [esp+0h] [ebp-10h]

  if ( !v || n <= 0 )
    return 0;
  count = 0;
  for ( i = 0; i != n; ++i )
  {
    if ( p1->kind == VARIABLE )
      count += p1->token.variable == v;
    ++p1;
  }
  return count;
}

//----- (0804A101) --------------------------------------------------------
int __cdecl solved_equation(int i)
{
  int v1; // edx
  token_type *v2; // ecx
  int v3; // ecx
  int result; // eax

  v1 = n_rhs[i];
  if ( v1 > 0 && n_lhs[i] == 1 && (v2 = lhs[i], v2->kind == VARIABLE) && (v3 = v2->token.variable, (v3 & 0x3FFFu) > 4) )
    result = found_var(rhs[i], v1, v3) == 0;
  else
    result = 0;
  return result;
}

//----- (0804A168) --------------------------------------------------------
int __cdecl var_in_equation(int i, int v)
{
  int v2; // eax
  int v3; // edx
  int result; // eax
  int v5; // eax

  v2 = n_lhs[i];
  if ( v2 <= 0 )
    goto LABEL_5;
  v3 = found_var(lhs[i], v2, v);
  result = 1;
  if ( v3 )
    return result;
  v5 = n_rhs[i];
  if ( v5 <= 0 )
LABEL_5:
    result = 0;
  else
    result = found_var(rhs[i], v5, v) != 0;
  return result;
}

//----- (0804A1E2) --------------------------------------------------------
int __cdecl min_level(token_type *expression, int n)
{
  int result; // eax
  token_type *v3; // ebx
  token_type *i; // edx

  if ( n > 1 )
  {
    result = expression[1].level;
    v3 = &expression[n];
    for ( i = expression + 3; v3 > i; i += 2 )
    {
      if ( result > i->level )
        result = i->level;
    }
  }
  else
  {
    result = 1;
    if ( n > 0 )
      result = expression->level;
  }
  return result;
}

//----- (0804A221) --------------------------------------------------------
int __cdecl level_plus_count(token_type *p1, int n1, int level)
{
  int result; // eax
  int i; // ecx

  result = 0;
  if ( n1 > 1 )
  {
    for ( i = 1; i < n1; i += 2 )
    {
      if ( p1[1].level == level )
        result += (unsigned int)(p1[1].token.variable - 1) < 2;
      p1 += 2;
    }
  }
  return result;
}

//----- (0804A25F) --------------------------------------------------------
int __cdecl level1_plus_count(token_type *p1, int n1)
{
  int v2; // eax

  v2 = min_level(p1, n1);
  return level_plus_count(p1, n1, v2);
}

//----- (0804A297) --------------------------------------------------------
int __cdecl var_count(token_type *p1, int n1)
{
  int result; // eax
  int i; // edx

  result = 0;
  if ( n1 > 0 )
  {
    for ( i = 0; i < n1; i += 2 )
    {
      result += p1->kind == VARIABLE;
      p1 += 2;
    }
  }
  return result;
}

//----- (0804A2C9) --------------------------------------------------------
int __cdecl no_vars(token_type *source, int n, int *vp)
{
  token_type *v3; // eax
  int i; // edx
  int v6; // ebx
  int found; // [esp+8h] [ebp-10h]

  v3 = source;
  if ( *vp )
    return var_count(source, n) == 0;
  found = 0;
  if ( n > 0 )
  {
    found = 0;
    for ( i = 0; n > i; i += 2 )
    {
      if ( v3->kind == VARIABLE )
      {
        v6 = v3->token.variable;
        if ( (v6 & 0x3FFFu) > 4 )
        {
          if ( *vp )
          {
            if ( v6 != *vp )
            {
              *vp = 0;
              return found == 0;
            }
          }
          else
          {
            *vp = v6;
            found = 1;
          }
        }
      }
      v3 += 2;
    }
  }
  return found == 0;
}

//----- (0804A35B) --------------------------------------------------------
int __cdecl exp_is_numeric(token_type *p1, int n1)
{
  int v3; // edx

  if ( n1 <= 0 )
    return 1;
  v3 = 0;
  while ( p1->kind != VARIABLE || (p1->token.variable & 0x3FFFu) <= 4 )
  {
    v3 += 2;
    p1 += 2;
    if ( n1 <= v3 )
      return 1;
  }
  return 0;
}

//----- (0804A39A) --------------------------------------------------------
int __cdecl exp_contains_nan(token_type *p1, int n1)
{
  int v3; // esi

  if ( n1 <= 0 )
    return 0;
  v3 = 0;
  while ( p1->kind || !__isnan(p1->token.constant) )
  {
    v3 += 2;
    p1 += 2;
    if ( n1 <= v3 )
      return 0;
  }
  return 1;
}

//----- (0804A3E4) --------------------------------------------------------
int __cdecl exp_contains_infinity(token_type *p1, int n1)
{
  int v3; // esi

  if ( n1 <= 0 )
    return 0;
  v3 = 0;
  while ( p1->kind || __finite(p1->token.constant) )
  {
    ++v3;
    ++p1;
    if ( n1 <= v3 )
      return 0;
  }
  return 1;
}

//----- (0804A42B) --------------------------------------------------------
int __cdecl isdelimiter(int ch_0)
{
  int result; // eax

  if ( ((*__ctype_b_loc())[ch_0] & 0x2000) != 0 || ch_0 == 44 )
    result = 1;
  else
    result = ch_0 == 61;
  return result;
}

//----- (0804A45E) --------------------------------------------------------
int __cdecl strcmp_tospace(char *cp1, char *cp2)
{
  char v2; // al
  char *i; // esi
  char v4; // al
  char *j; // ebx
  signed int v6; // ebx
  signed int v7; // esi

  v2 = *cp1;
  for ( i = cp1; *i; v2 = *++i )
  {
    if ( isdelimiter(v2) )
      break;
  }
  v4 = *cp2;
  for ( j = cp2; *j; v4 = *++j )
  {
    if ( isdelimiter(v4) )
      break;
  }
  v6 = j - cp2;
  v7 = i - cp1;
  if ( v6 < v7 )
    v6 = v7;
  return strncasecmp(cp1, cp2, v6);
}

//----- (0804A4DC) --------------------------------------------------------
int __cdecl is_all(char *cp)
{
  return strcmp_tospace(cp, "all") == 0;
}

//----- (0804A4FF) --------------------------------------------------------
char *__cdecl skip_space(char *cp)
{
  char *v1; // esi
  char v2; // bl
  const unsigned __int16 *v3; // eax

  v1 = cp;
  if ( cp )
  {
    v2 = *cp;
    if ( *cp )
    {
      v3 = *__ctype_b_loc();
      do
      {
        if ( (v3[v2] & 0x2000) == 0 )
          break;
        v2 = *++v1;
      }
      while ( *v1 );
    }
  }
  return v1;
}

//----- (0804A535) --------------------------------------------------------
char *__cdecl skip_param(char *cp)
{
  char *v1; // ebx
  char v2; // al

  v1 = cp;
  if ( cp )
  {
    v2 = *cp;
    if ( *cp )
    {
      do
      {
        if ( v2 >= 0 && isdelimiter(v2) )
          break;
        v2 = *++v1;
      }
      while ( *v1 );
    }
    v1 = skip_space(v1);
    if ( isdelimiter(*v1) )
      v1 = skip_space(v1 + 1);
  }
  return v1;
}

//----- (0804A597) --------------------------------------------------------
int __cdecl decstrtol(char *cp, char **cpp)
{
  int v2; // esi

  v2 = strtol(cp, cpp, 10);
  if ( cpp && *cpp != cp )
    *cpp = skip_space(*cpp);
  return v2;
}

//----- (0804A5E5) --------------------------------------------------------
void free_result_str()
{
  if ( result_str )
  {
    free(result_str);
    result_str = 0;
  }
  result_en = -1;
}

//----- (0804A612) --------------------------------------------------------
int __cdecl return_result(int en)
{
  int result; // eax

  result = 0;
  if ( n_lhs[en] > 0 )
    result = list_sub(en) != 0;
  return result;
}

//----- (0804A63C) --------------------------------------------------------
char *__cdecl get_string(char *string, int n)
{
  char *v2; // eax
  char *v3; // edi
  unsigned int v4; // kr08_4
  char *v5; // ecx

  if ( quiet_mode )
    prompt_str[0] = 0;
  input_column = strlen(prompt_str);
  if ( readline_enabled )
  {
    if ( !echo_input )
    {
      v2 = (char *)readline(prompt_str);
      v3 = v2;
      if ( !v2 )
      {
        if ( !quiet_mode )
          __printf_chk(1, "\nEnd of input.\n");
        exit_program(0);
      }
      my_strlcpy(string, v2, n);
      if ( !*skip_space(v3) || last_history_string && !strcmp(last_history_string, v3) )
      {
        free(v3);
      }
      else
      {
        add_history(v3);
        last_history_string = v3;
      }
      goto LABEL_20;
    }
  }
  else if ( !echo_input )
  {
    __printf_chk(1, "%s", prompt_str);
  }
  if ( !fgets(string, n, stdin) )
  {
    if ( !quiet_mode )
      __printf_chk(1, "\nEnd of input.\n");
    exit_program(0);
  }
LABEL_20:
  v4 = strlen(string) + 1;
  if ( (int)(v4 - 2) >= 0 )
  {
    v5 = &string[v4 - 2];
    if ( *v5 == 10 )
      *v5 = 0;
  }
  if ( gfp != stdout && gfp != stderr || echo_input )
    __fprintf_chk(gfp, 1, "%s%s\n", prompt_str, string);
  set_error_level(string);
  abort_flag = 0;
  return string;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049164: using guessed type int __cdecl readline(_DWORD);
// 8049254: using guessed type int __cdecl add_history(_DWORD);

//----- (0804A801) --------------------------------------------------------
int get_yes_no()
{
  char *v0; // eax
  char *v1; // ebx
  char buf[4096]; // [esp+1Ch] [ebp-100Ch] BYREF
  unsigned int v4; // [esp+101Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  while ( 1 )
  {
    v0 = get_string(buf, 4096);
    v1 = v0;
    if ( !v0 )
      break;
    str_tolower(v0);
    if ( *v1 == 110 )
      break;
    if ( *v1 == 121 )
      return 1;
  }
  return 0;
}

//----- (0804A86F) --------------------------------------------------------
int __cdecl get_expr(token_type *equation, int *np)
{
  int result; // eax
  char buf[60000]; // [esp+1Ch] [ebp-EA7Ch] BYREF
  unsigned int v4; // [esp+EA7Ch] [ebp-1Ch]

  v4 = __readgsdword(0x14u);
  while ( 1 )
  {
    result = (int)get_string(buf, 60000);
    if ( !result )
      break;
    if ( parse_expr(equation, np, (char *)result) )
      return *np > 0;
  }
  return result;
}

//----- (0804A8DF) --------------------------------------------------------
void __cdecl copy_espace(int src, int dest)
{
  if ( src != dest )
  {
    memmove(lhs[dest], lhs[src], 16 * n_lhs[src]);
    n_lhs[dest] = n_lhs[src];
    memmove(rhs[dest], rhs[src], 16 * n_rhs[src]);
    n_rhs[dest] = n_rhs[src];
  }
}

//----- (0804A95D) --------------------------------------------------------
void __noreturn error_huge()
{
  __longjmp_chk(jmp_save, 14);
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);

//----- (0804A977) --------------------------------------------------------
void __cdecl subst_var_with_exp(token_type *equation, int *np, token_type *expression, int len, int v)
{
  int v5; // eax
  int v6; // esi
  token_type *v7; // ebx
  int v8; // edi
  int *v9; // eax
  int v10; // edx
  int v11; // [esp+18h] [ebp-30h]
  int v12; // [esp+24h] [ebp-24h]
  token_type *dest; // [esp+28h] [ebp-20h]
  token_type *src; // [esp+2Ch] [ebp-1Ch]

  if ( v )
  {
    if ( len > 0 )
    {
      v5 = *np;
      v6 = *np - 1;
      if ( v6 >= 0 )
      {
        v7 = &equation[v6];
        v12 = -v5;
        v8 = v6 + len;
        dest = &equation[v6 + len];
        src = &equation[v5];
        do
        {
          if ( v7->kind == VARIABLE && v7->token.variable == v )
          {
            v11 = v7->level;
            if ( len + *np - 1 > n_tokens )
              error_huge();
            memmove(dest, src, 16 * (*np + v12));
            *np = len + *np - 1;
            memmove(v7, expression, 16 * len);
            if ( v6 < v8 )
            {
              v9 = &v7->level;
              v10 = v6;
              do
              {
                *v9 += v11;
                ++v10;
                v9 += 4;
              }
              while ( v10 < v8 );
            }
          }
          --v7;
          ++v12;
          --dest;
          --src;
          --v8;
          --v6;
        }
        while ( v6 >= 0 );
      }
    }
  }
}

//----- (0804AAA1) --------------------------------------------------------
int __cdecl alloc_espace(int i)
{
  token_type *v1; // eax
  token_type *v2; // eax

  if ( i > 99 )
    return 0;
  if ( !lhs[i] || !rhs[i] )
  {
    v1 = (token_type *)malloc(16 * n_tokens);
    lhs[i] = v1;
    if ( v1 )
    {
      v2 = (token_type *)malloc(16 * n_tokens);
      rhs[i] = v2;
      if ( !v2 )
      {
        free(lhs[i]);
        lhs[i] = 0;
        return 0;
      }
      return 1;
    }
    return 0;
  }
  return 1;
}

//----- (0804AB33) --------------------------------------------------------
void clean_up()
{
  int v0; // ebx
  int v1; // eax

  init_gvars();
  if ( gfp != default_out )
  {
    if ( gfp != stdout && gfp != stderr )
      fclose(gfp);
    gfp = default_out;
  }
  v0 = n_equations;
  if ( n_equations > 0 )
  {
    v1 = 0;
    do
    {
      if ( n_lhs[v1] <= 0 )
      {
        n_lhs[v1] = 0;
        n_rhs[v1] = 0;
      }
      ++v1;
    }
    while ( v1 != v0 );
  }
}

//----- (0804ABAC) --------------------------------------------------------
void get_screen_size()
{
  winsize ws; // [esp+18h] [ebp-10h] BYREF

  ws.ws_col = 0;
  ws.ws_row = 0;
  if ( ioctl(1, 0x5413u, &ws) >= 0 )
  {
    if ( ws.ws_col )
      screen_columns = ws.ws_col;
    if ( ws.ws_row )
      screen_rows = ws.ws_row;
  }
}

//----- (0804AC01) --------------------------------------------------------
void __cdecl warning(const char *str)
{
  warning_str = str;
  if ( debug_level >= 0 )
  {
    set_color(1);
    __printf_chk(1, "Warning: %s\n", str);
    default_color();
  }
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804AC49) --------------------------------------------------------
int __cdecl check_divide_by_zero(double denominator)
{
  int result; // eax

  result = 0;
  if ( denominator == 0.0 )
  {
    warning("Division by zero.");
    result = 1;
  }
  return result;
}

//----- (0804AC74) --------------------------------------------------------
int alloc_next_espace()
{
  int v0; // edx
  int v1; // edi
  int v2; // ebx

  v0 = cur_equation;
  v1 = n_equations;
  if ( cur_equation < n_equations )
  {
    if ( !n_lhs[cur_equation] )
    {
LABEL_18:
      n_rhs[v0] = 0;
      return v0;
    }
    v0 = (cur_equation + 1) % 100;
    v2 = 1;
    while ( v0 < n_equations )
    {
      if ( !n_lhs[v0] )
        goto LABEL_18;
      if ( ++v2 == 100 )
        return -1;
      v0 = (v0 + 1) % 100;
    }
  }
  if ( alloc_espace(n_equations) )
  {
    ++n_equations;
    return v1;
  }
  warning("Memory is exhausted.");
  if ( n_equations <= 0 )
    return -1;
  v0 = 0;
  if ( n_lhs[0] )
  {
    while ( ++v0 < n_equations )
    {
      if ( !n_lhs[v0] )
        goto LABEL_11;
    }
    return -1;
  }
LABEL_11:
  n_rhs[v0] = 0;
  return v0;
}

//----- (0804AD7A) --------------------------------------------------------
void __cdecl error(const char *str)
{
  error_str = str;
  set_color(2);
  __printf_chk(1, "%s\n", str);
  default_color();
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804ADB9) --------------------------------------------------------
int __cdecl extra_characters(char *cp)
{
  if ( !cp || !*skip_space(cp) )
    return 0;
  error("Extra characters or unrecognized argument.");
  return 1;
}

//----- (0804ADED) --------------------------------------------------------
int __cdecl prompt_var(int *vp)
{
  char *v1; // eax
  char *v2; // eax
  char buf[4096]; // [esp+1Ch] [ebp-100Ch] BYREF
  unsigned int v5; // [esp+101Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  while ( 1 )
  {
    my_strlcpy(prompt_str, "Enter variable: ", 80);
    v1 = get_string(buf, 4096);
    if ( !v1 || !*v1 )
      break;
    v2 = parse_var2(vp, v1);
    if ( v2 && !extra_characters(v2) )
      return 1;
  }
  return 0;
}

//----- (0804AE82) --------------------------------------------------------
int current_not_defined()
{
  int result; // eax

  if ( cur_equation < 0 || cur_equation >= n_equations || (result = 0, n_lhs[cur_equation] <= 0) )
  {
    error("No current equation or expression.");
    result = 1;
  }
  return result;
}

//----- (0804AEBC) --------------------------------------------------------
int __cdecl not_defined(int i)
{
  int result; // eax

  if ( i >= 0 && i < n_equations )
  {
    result = 0;
    if ( n_lhs[i] <= 0 )
    {
      error("Equation space is empty.");
      result = 1;
    }
  }
  else
  {
    error("Invalid equation number.");
    result = 1;
  }
  return result;
}

//----- (0804AF06) --------------------------------------------------------
int __cdecl get_default_en(char *cp)
{
  int v1; // ebx
  int v2; // ebx

  if ( *cp )
  {
    v2 = decstrtol(cp, &cp);
    if ( extra_characters(cp) )
      return -1;
    v1 = v2 - 1;
  }
  else
  {
    v1 = cur_equation;
  }
  if ( not_defined(v1) )
    return -1;
  return v1;
}

//----- (0804AF59) --------------------------------------------------------
int __cdecl get_range(char **cpp, int *ip_0, int *jp)
{
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int *v6; // edx
  int v7; // ecx
  const unsigned __int16 **v8; // esi
  int result; // eax
  int v10; // edx
  char *v11; // edx
  int v12; // eax
  int v13; // edx
  char *v14; // eax
  int v15; // edx
  int *v16; // ecx
  int v17; // ebx
  char *cp[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  cp[0] = skip_space(*cpp);
  if ( is_all(cp[0]) )
  {
    cp[0] = skip_param(cp[0]);
    *ip_0 = 0;
    v3 = n_equations;
    v4 = n_equations - 1;
    *jp = n_equations - 1;
    if ( v4 > 0 && !n_lhs[v4] )
    {
      v5 = v3 - 2;
      v6 = &n_lhs[v5];
      do
      {
        *jp = v5;
        if ( v5 <= 0 )
          break;
        v7 = *v6;
        --v5;
        --v6;
      }
      while ( !v7 );
    }
  }
  else
  {
    v8 = __ctype_b_loc();
    if ( ((*v8)[*cp[0]] & 0x800) != 0 )
      *ip_0 = strtol(cp[0], cp, 10) - 1;
    else
      *ip_0 = cur_equation;
    if ( *ip_0 < 0 || *ip_0 >= n_equations )
      goto LABEL_13;
    if ( *cp[0] != 45 )
    {
      v10 = not_defined(*ip_0);
      result = 0;
      if ( !v10 )
      {
        *jp = *ip_0;
        *cpp = skip_space(cp[0]);
        result = 1;
      }
      return result;
    }
    v11 = cp[0] + 1;
    cp[0] = v11;
    *jp = ((*v8)[*v11] & 0x800) != 0 ? strtol(v11, cp, 10) - 1 : cur_equation;
    v12 = *jp;
    if ( *jp < 0 || v12 >= n_equations )
    {
LABEL_13:
      error("Invalid equation number.");
      return 0;
    }
    v13 = *ip_0;
    if ( v12 < *ip_0 )
    {
      *ip_0 = v12;
      *jp = v13;
    }
  }
  v14 = skip_space(cp[0]);
  cp[0] = v14;
  v15 = *ip_0;
  if ( *jp >= *ip_0 )
  {
    v16 = (int *)(4 * v15 + 134753668);
    if ( n_lhs[v15] > 0 )
    {
LABEL_29:
      *cpp = v14;
      return 1;
    }
    while ( *jp >= ++v15 )
    {
      v17 = *v16++;
      if ( v17 > 0 )
        goto LABEL_29;
    }
  }
  error("No equations defined in specified range.");
  return 0;
}

//----- (0804B139) --------------------------------------------------------
int __cdecl get_range_eol(char **cpp, int *ip_0, int *jp)
{
  int v3; // edx
  int result; // eax

  v3 = get_range(cpp, ip_0, jp);
  result = 0;
  if ( v3 )
    result = extra_characters(*cpp) == 0;
  return result;
}

//----- (0804B17C) --------------------------------------------------------
int next_espace()
{
  int result; // eax

  result = alloc_next_espace();
  if ( result < 0 )
  {
    error("Out of free equation spaces.");
    __printf_chk(1, "Use the clear command on unnecessary equations and try again.\n");
    __longjmp_chk(jmp_save, 3);
  }
  return result;
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804B1C1) --------------------------------------------------------
void check_err()
{
  int *v0; // eax

  v0 = __errno_location();
  if ( *v0 == 33 )
  {
    *v0 = 0;
    if ( !domain_check )
    {
      error("Domain error in constant.");
      __longjmp_chk(jmp_save, 2);
    }
    domain_check = 0;
  }
  else if ( *v0 == 34 )
  {
    *v0 = 0;
    error("Overflow error in constant.");
    __longjmp_chk(jmp_save, 2);
  }
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);

//----- (0804B23D) --------------------------------------------------------
void __cdecl __noreturn error_bug(const char *str)
{
  error(str);
  __printf_chk(1, "Please report this bug to the maintainers,\n");
  __printf_chk(1, "along with the entry sequence that caused it.\n");
  __printf_chk(1, "Type \"help bugs\" for info on how to report bugs found in this program.\n");
  __longjmp_chk(jmp_save, 13);
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804B29E) --------------------------------------------------------
void clear_all()
{
  char *v0; // eax
  int v1; // ebx
  char *v2; // edi
  unsigned int v3; // edx
  char *v4; // edi

  cur_equation = 0;
  memset(n_lhs, 0, sizeof(n_lhs));
  memset(n_rhs, 0, sizeof(n_rhs));
  v0 = var_names[0];
  if ( var_names[0] )
  {
    v1 = 0;
    do
    {
      free(v0);
      var_names[v1++] = 0;
      v0 = var_names[v1];
    }
    while ( v0 );
  }
  v2 = sign_array;
  v3 = 64;
  if ( ((unsigned int)sign_array & 1) != 0 )
  {
    sign_array[0] = 0;
    v2 = &sign_array[1];
    v3 = 63;
  }
  if ( ((unsigned __int8)v2 & 2) != 0 )
  {
    *(_WORD *)v2 = 0;
    v2 += 2;
    v3 -= 2;
  }
  memset(v2, 0, 4 * (v3 >> 2));
  v4 = &v2[4 * (v3 >> 2)];
  if ( (v3 & 2) != 0 )
  {
    *(_WORD *)v4 = 0;
    v4 += 2;
  }
  if ( (v3 & 1) != 0 )
    *v4 = 0;
  init_gvars();
}

//----- (0804B351) --------------------------------------------------------
int init_mem()
{
  scratch = (token_type *)malloc(16 * (3 * n_tokens / 2));
  if ( !scratch )
    return 0;
  tes = (token_type *)malloc(16 * n_tokens);
  if ( !tes )
    return 0;
  tlhs = (token_type *)malloc(16 * n_tokens);
  if ( !tlhs )
    return 0;
  trhs = (token_type *)malloc(16 * n_tokens);
  if ( !trhs || alloc_next_espace() < 0 )
    return 0;
  clear_all();
  return 1;
}

//----- (0804B3E4) --------------------------------------------------------
void set_sign_array()
{
  char *v0; // edi
  unsigned int v1; // edx
  char *v2; // edi
  int v3; // ebx
  int v4; // ecx
  token_type *v5; // eax
  int i; // edx
  int v7; // ecx
  token_type *v8; // eax
  int j; // edx
  int v10; // [esp+0h] [ebp-14h]

  v0 = sign_array;
  v1 = 64;
  if ( ((unsigned int)sign_array & 1) != 0 )
  {
    sign_array[0] = 0;
    v0 = &sign_array[1];
    v1 = 63;
  }
  if ( ((unsigned __int8)v0 & 2) != 0 )
  {
    *(_WORD *)v0 = 0;
    v0 += 2;
    v1 -= 2;
  }
  memset(v0, 0, 4 * (v1 >> 2));
  v2 = &v0[4 * (v1 >> 2)];
  if ( (v1 & 2) != 0 )
  {
    *(_WORD *)v2 = 0;
    v2 += 2;
  }
  if ( (v1 & 1) != 0 )
    *v2 = 0;
  v10 = n_equations;
  if ( n_equations > 0 )
  {
    v3 = 0;
    do
    {
      v4 = n_lhs[v3];
      if ( v4 > 0 )
      {
        v5 = lhs[v3];
        for ( i = 0; i < v4; i += 2 )
        {
          if ( v5->kind == VARIABLE && (v5->token.variable & 0x3FFF) == 4 )
            sign_array[(v5->token.variable >> 14) & 0x3F] = 1;
          v5 += 2;
        }
        v7 = n_rhs[v3];
        if ( v7 > 0 )
        {
          v8 = rhs[v3];
          for ( j = 0; j < v7; j += 2 )
          {
            if ( v8->kind == VARIABLE && (v8->token.variable & 0x3FFF) == 4 )
              sign_array[(v8->token.variable >> 14) & 0x3F] = 1;
            v8 += 2;
          }
        }
      }
      ++v3;
    }
    while ( v3 != v10 );
  }
}

//----- (0804B4F0) --------------------------------------------------------
int __usercall flip@<eax>(token_type *side1p@<eax>, int *side1np@<edx>, token_type *side2p@<ecx>, int *side2np)
{
  token_type *v7; // edx
  token_type *v8; // eax
  token_type *v9; // edx
  token_type *v10; // eax
  token_type *v11; // ebx
  token_type *v12; // esi

  if ( debug_level > 0 )
    __fprintf_chk(gfp, 1, "%s\n", "Taking the reciprocal of both sides of the equation...");
  if ( *side1np + 2 > n_tokens || n_tokens < *side2np + 2 )
    error_huge();
  v7 = &side1p[*side1np];
  if ( side1p < v7 )
  {
    v8 = side1p;
    do
    {
      ++v8->level;
      ++v8;
    }
    while ( v7 > v8 );
  }
  v9 = &side2p[*side2np];
  if ( side2p < v9 )
  {
    v10 = side2p;
    do
    {
      ++v10->level;
      ++v10;
    }
    while ( v9 > v10 );
  }
  memmove(&side1p[2], side1p, 16 * *side1np);
  *side1np += 2;
  memmove(&side2p[2], side2p, 16 * *side2np);
  *side2np += 2;
  *side1p = one_token;
  v11 = side1p + 1;
  v11->level = 1;
  v11->kind = OPERATOR;
  v11->token.variable = 4;
  *side2p = one_token;
  v12 = side2p + 1;
  v12->level = 1;
  v12->kind = OPERATOR;
  v12->token.variable = 4;
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0804B637) --------------------------------------------------------
int __usercall g_of_f@<eax>(int op@<eax>, token_type *operandp@<edx>, token_type *side1p@<ecx>, int *side1np, token_type *side2p, int *side2np)
{
  int result; // eax
  token_type *v7; // edi
  token_type *i; // ebx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  token_type *v14; // eax
  int v15; // ebx
  token_type *v16; // edx
  token_type *v17; // eax
  int v18; // eax
  long double v19; // fst5
  char v21; // c2
  token_type *v22; // edx
  token_type *v23; // eax
  token_type *v24; // ecx
  size_t n; // [esp+3Ch] [ebp-11Ch]
  int operandn; // [esp+44h] [ebp-114h]
  token_type *v28; // [esp+50h] [ebp-108h]
  int oldn; // [esp+58h] [ebp-100h]
  int v30; // [esp+5Ch] [ebp-FCh]
  complexs_0 v31; // [esp+60h] [ebp-F8h] BYREF
  complexs_0 a; // [esp+78h] [ebp-E0h] BYREF
  complexs_0 b; // [esp+88h] [ebp-D0h] BYREF
  complexs_0 c2; // [esp+98h] [ebp-C0h] BYREF
  complexs_0 c1; // [esp+A8h] [ebp-B0h] BYREF
  double d2; // [esp+B8h] [ebp-A0h] BYREF
  double d1; // [esp+C0h] [ebp-98h] BYREF
  double denominator; // [esp+C8h] [ebp-90h] BYREF
  double numerator; // [esp+D0h] [ebp-88h] BYREF
  char v40[100]; // [esp+D8h] [ebp-80h] BYREF
  unsigned int v41; // [esp+13Ch] [ebp-1Ch]

  v30 = op;
  v28 = operandp;
  v41 = __readgsdword(0x14u);
  oldn = *side1np;
  if ( *side1np == prev_n1_10128 && *side2np == prev_n2_10129 )
  {
    if ( ++repeat_count > 2 )
    {
      if ( debug_level > 0 )
      {
        __fprintf_chk(gfp, 1, "%s\n", "Infinite loop aborted in solve routine.");
        return 0;
      }
      return 0;
    }
  }
  else
  {
    prev_n1_10128 = *side1np;
    prev_n2_10129 = *side2np;
    repeat_count = 0;
  }
  if ( (unsigned int)(op - 1) > 5 )
    return 0;
  v7 = &side1p[oldn];
  for ( i = operandp + 1; v7 > i; i += 2 )
  {
    if ( i->level == 1 )
    {
      v9 = i->token.variable;
      if ( v9 == 5 )
      {
        v28 = i + 1;
      }
      else
      {
        if ( v9 != 7 )
          break;
        v30 = 1;
      }
    }
  }
  n = (char *)i - (char *)v28;
  operandn = i - v28;
  if ( v30 == 6 && v28 == side1p )
  {
    if ( parse_complex(side2p, *side2np, &c1) && parse_complex(v28, operandn, &c2) )
    {
      if ( debug_level > 0 )
        __fprintf_chk(gfp, 1, "%s\n", "Taking logarithm of both equation sides:");
      *__errno_location() = 0;
      complex_log(&b, c2);
      complex_log(&a, c1);
      complex_div(&v31, a, b);
      c1 = v31;
      *side2np = 0;
      side2p->level = 1;
      side2p[*side2np].kind = CONSTANT;
      side2p[*side2np].token.constant = c1.re;
      v10 = *side2np + 1;
      *side2np = v10;
      side2p[v10].level = 1;
      side2p[*side2np].kind = OPERATOR;
      side2p[*side2np].token.variable = 1;
      v11 = *side2np + 1;
      *side2np = v11;
      side2p[v11].level = 2;
      side2p[*side2np].kind = CONSTANT;
      side2p[*side2np].token.constant = c1.im;
      v12 = *side2np + 1;
      *side2np = v12;
      side2p[v12].level = 2;
      side2p[*side2np].kind = OPERATOR;
      side2p[*side2np].token.variable = 3;
      v13 = *side2np + 1;
      *side2np = v13;
      side2p[v13].level = 2;
      side2p[*side2np].kind = VARIABLE;
      side2p[(*side2np)++].token.variable = 3;
      memmove(side1p, &i[1], 16 * (*side1np + ~operandn));
      *side1np += ~operandn;
      check_err();
      return 1;
    }
    return 0;
  }
  if ( v30 == 5 && get_constant(side2p, *side2np, &d1) && get_constant(v28, operandn, &d2) && fabs(d1) >= fabs(d2) )
  {
    error("There are no possible solutions.");
    return 0;
  }
  if ( debug_level > 0 )
  {
    switch ( v30 )
    {
      case 1:
        __fprintf_chk(gfp, 1, "Subtracting");
        break;
      case 2:
        __fprintf_chk(gfp, 1, "Adding");
        break;
      case 3:
        __fprintf_chk(gfp, 1, "Dividing both sides of the equation by");
        break;
      case 4:
        __fprintf_chk(gfp, 1, "Multiplying both sides of the equation by");
        break;
      case 5:
        __fprintf_chk(gfp, 1, "Applying inverse modulus of");
        break;
      case 6:
        __fprintf_chk(gfp, 1, "Raising both sides of the equation to the power of");
        break;
      default:
        break;
    }
    if ( v30 == 6 && operandn == 1 && v28->kind == CONSTANT )
    {
      __fprintf_chk(gfp, 1, " %.*g:\n", precision, (double)(1.0 / v28->token.constant));
      goto LABEL_50;
    }
    __fprintf_chk(gfp, 1, " \"");
    if ( v30 == 6 )
      __fprintf_chk(gfp, 1, "1/(");
    list_proc(v28, operandn, 0);
    if ( v30 != 2 )
    {
      if ( v30 <= 2 )
      {
        if ( v30 == 1 )
        {
          __fprintf_chk(gfp, 1, "\" from both sides of the equation:\n");
          goto LABEL_50;
        }
        goto LABEL_49;
      }
      if ( v30 != 5 )
      {
        if ( v30 == 6 )
          __fprintf_chk(gfp, 1, ")");
LABEL_49:
        __fprintf_chk(gfp, 1, "\":\n");
        goto LABEL_50;
      }
    }
    __fprintf_chk(gfp, 1, "\" to both sides of the equation:\n");
  }
LABEL_50:
  if ( operandn + *side1np + 3 > n_tokens || n_tokens < operandn + *side2np + 5 )
    error_huge();
  if ( min_level(side1p, oldn) <= 1 && side1p < v7 )
  {
    v14 = side1p;
    do
    {
      ++v14->level;
      ++v14;
    }
    while ( v7 > v14 );
  }
  v15 = *side2np;
  if ( min_level(side2p, *side2np) <= 1 )
  {
    v16 = &side2p[v15];
    if ( side2p < v16 )
    {
      v17 = side2p;
      do
      {
        ++v17->level;
        ++v17;
      }
      while ( v16 > v17 );
    }
  }
  switch ( v30 )
  {
    case 1:
      v7->level = 1;
      v7->kind = OPERATOR;
      v7->token.variable = 2;
      memmove(&v7[1], v28, n);
      *side1np += operandn + 1;
      break;
    case 2:
      v7->level = 1;
      v7->kind = OPERATOR;
      v7->token.variable = 1;
      memmove(&v7[1], v28, n);
      *side1np += operandn + 1;
      break;
    case 3:
      v7->level = 1;
      v7->kind = OPERATOR;
      v7->token.variable = 4;
      memmove(&v7[1], v28, n);
      *side1np += operandn + 1;
      break;
    case 4:
      v7->level = 1;
      v7->kind = OPERATOR;
      v7->token.variable = 3;
      memmove(&v7[1], v28, n);
      *side1np += operandn + 1;
      break;
    case 5:
      v7->level = 1;
      v7->kind = OPERATOR;
      v7->token.variable = 1;
      v7[1].level = 2;
      v7[1].kind = VARIABLE;
      __snprintf_chk(v40, 100, 1, 100, "%s%.0d", "integer", last_int_var);
      if ( !parse_var((int *)&v7[1].token, v40) )
        return 0;
      v18 = 0;
      if ( last_int_var + 1 >= 0 )
        v18 = last_int_var + 1;
      last_int_var = v18;
      v7[2].level = 2;
      v7[2].kind = OPERATOR;
      v7[2].token.variable = 3;
      memmove(&v7[3], v28, n);
      *side1np += operandn + 3;
      break;
    case 6:
      v7->level = 1;
      v7->kind = OPERATOR;
      v7->token.variable = 6;
      v7[1].level = 2;
      v7[1].kind = CONSTANT;
      v7[1].token.constant = 1.0;
      v7[2].level = 2;
      v7[2].kind = OPERATOR;
      v7[2].token.variable = 4;
      memmove(&v7[3], v28, n);
      *side1np += operandn + 3;
      break;
    default:
      break;
  }
  memmove(&side2p[*side2np], v7, 16 * (*side1np - oldn));
  *side2np += *side1np - oldn;
  if ( v30 == 6 && operandn == 1 && v28->kind == CONSTANT )
  {
    f_to_fraction(v28->token.constant, &numerator, &denominator);
    v19 = numerator;
    do
      v19 = __FPREM__(v19, 2.0);
    while ( v21 );
    if ( v19 == 0.0 )
    {
      v22 = &side2p[*side2np];
      v23 = side2p;
      v24 = side2p;
      if ( side2p < v22 )
      {
        do
        {
          ++v23->level;
          ++v23;
        }
        while ( v22 > v23 );
        v24 = (token_type *)((char *)side2p + (((unsigned int)v22 + ~(unsigned int)side2p) & 0xFFFFFFF0) + 16);
      }
      v24->level = 1;
      v24->kind = OPERATOR;
      v24->token.variable = 3;
      v24[1].level = 1;
      v24[1].kind = VARIABLE;
      next_sign((int *)&v24[1].token);
      *side2np += 2;
    }
  }
  result = 1;
  if ( (unsigned int)(v30 - 5) <= 1 )
  {
    *side1np = &v28[-1] - side1p;
    result = 1;
  }
  return result;
}
// 804C0D2: variable 'v21' is possibly undefined
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0804C1C3) --------------------------------------------------------
int __usercall quad_solve@<eax>(int v@<eax>)
{
  token_type *v1; // eax
  token_type *v2; // esi
  long double v3; // fst7
  int v4; // edx
  token_type *v5; // edi
  token_type *v6; // edx
  int v7; // ecx
  long double v8; // fst6
  long double v9; // fst6
  int v10; // eax
  int v11; // eax
  token_type *v12; // esi
  int v13; // eax
  token_type *v14; // ebx
  int v15; // edi
  const void *v16; // eax
  int v17; // esi
  int v18; // edx
  int v19; // ecx
  int i; // eax
  int v21; // edx
  int v22; // edx
  int v23; // edx
  int v24; // edx
  int v25; // edx
  int v26; // edi
  int v27; // ecx
  int v28; // edx
  int v29; // esi
  int v30; // esi
  int v31; // ebx
  int v32; // edx
  int v33; // eax
  int v34; // edx
  token_type *v35; // ebx
  token_type *v36; // eax
  int v37; // edi
  token_type *v38; // esi
  int v39; // ecx
  int v40; // edx
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // eax
  int v45; // eax
  int v46; // eax
  int v47; // ebx
  int v48; // eax
  int v49; // eax
  int v50; // eax
  int v51; // ebx
  int v52; // ebx
  int result; // eax
  int opx1; // [esp+24h] [ebp-6A4h]
  int opx2; // [esp+28h] [ebp-6A0h]
  int opx2a; // [esp+28h] [ebp-6A0h]
  token_type *a2ep; // [esp+2Ch] [ebp-69Ch]
  token_type *a2p; // [esp+30h] [ebp-698h]
  token_type *a1p; // [esp+34h] [ebp-694h]
  token_type *x1p; // [esp+38h] [ebp-690h]
  int alen; // [esp+3Ch] [ebp-68Ch]
  int alena; // [esp+3Ch] [ebp-68Ch]
  size_t n; // [esp+40h] [ebp-688h]
  int v64; // [esp+44h] [ebp-684h]
  int v65; // [esp+44h] [ebp-684h]
  int v66; // [esp+44h] [ebp-684h]
  int nx1; // [esp+4Ch] [ebp-67Ch]
  int nx1a; // [esp+4Ch] [ebp-67Ch]
  token_type *v70; // [esp+50h] [ebp-678h]
  int v71; // [esp+50h] [ebp-678h]
  int op; // [esp+54h] [ebp-674h]
  token_type *opa; // [esp+54h] [ebp-674h]
  int opb; // [esp+54h] [ebp-674h]
  double high_power[2]; // [esp+58h] [ebp-670h] BYREF
  token_type x1_storage[100]; // [esp+6Ch] [ebp-65Ch] BYREF
  int diff_sign[7]; // [esp+6ACh] [ebp-1Ch] BYREF

  uf_simp(trhs, &n_trhs);
  while ( factor_plus(trhs, &n_trhs, v, 0.0) )
    simp_loop(trhs, &n_trhs);
  list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
  v1 = trhs;
  v70 = &trhs[n_trhs];
  v2 = trhs;
  v3 = 0.0;
  nx1 = 0;
  op = 0;
  a2ep = 0;
  a2p = 0;
  a1p = 0;
  x1p = 0;
  while ( 1 )
  {
    if ( v1 < v70 )
    {
      v4 = v1->level;
      high_power[0] = v3;
      v5 = v2;
      if ( v4 != 1 )
        goto LABEL_44;
      if ( v1->kind != OPERATOR )
        goto LABEL_42;
      if ( (unsigned int)(v1->token.variable - 1) > 1 )
        return 0;
    }
    if ( (unsigned int)(op - 3) <= 1 )
    {
      if ( v1 <= v2 )
      {
        high_power[0] = v3;
        v5 = v2;
        nx1 = 0;
        goto LABEL_39;
      }
      v5 = v2;
      v6 = v2;
      nx1 = 0;
      v64 = 0;
      while ( 1 )
      {
        v7 = v6->level;
        if ( v7 == 2 )
        {
          if ( v6->kind == OPERATOR )
          {
            v5 = v6 + 1;
            v64 = v6->token.variable;
            high_power[0] = v3;
            nx1 = 0;
            goto LABEL_30;
          }
        }
        else if ( v6->kind == OPERATOR )
        {
          if ( v7 == 3
            && v6->token.variable == 6
            && nx1
            && (v64 == 3 || !v64)
            && v6[1].level == 3
            && v6[1].kind == CONSTANT )
          {
            v8 = v6[1].token.constant;
            high_power[0] = v6[1].token.constant;
            if ( v8 > v3 )
            {
              a2p = v6 + 2;
              a2ep = v1;
              a1p = v2;
              x1p = v5;
              goto LABEL_30;
            }
          }
        }
        else if ( v6->kind == VARIABLE && v6->token.variable == v )
        {
          high_power[0] = v3;
          nx1 = 1;
          goto LABEL_30;
        }
        high_power[0] = v3;
LABEL_30:
        if ( v1 <= ++v6 )
          goto LABEL_39;
        v3 = high_power[0];
      }
    }
    if ( op == 6
      && nx1
      && v1[-1].level == 2
      && v1[-1].kind == CONSTANT
      && (v9 = v1[-1].token.constant, high_power[0] = v1[-1].token.constant, v9 > v3) )
    {
      v5 = v2;
      a2ep = v1;
      a2p = v1;
      a1p = v2;
      x1p = v2;
    }
    else
    {
      high_power[0] = v3;
      v5 = v2;
    }
LABEL_39:
    if ( v1 >= v70 )
      break;
    v4 = v1->level;
    if ( v4 == 1 )
    {
      v3 = high_power[0];
      v2 = v5;
LABEL_42:
      if ( v1->kind == OPERATOR )
      {
        v2 = v1 + 1;
        nx1 = 0;
        op = 0;
      }
      goto LABEL_52;
    }
LABEL_44:
    if ( v1->kind == OPERATOR )
    {
      if ( v4 == 2 )
      {
        op = v1->token.variable;
        v3 = high_power[0];
        v2 = v5;
        goto LABEL_52;
      }
    }
    else if ( !op && v1->kind == VARIABLE && v1->token.variable == v )
    {
      v3 = high_power[0];
      v2 = v5;
      nx1 = 1;
      goto LABEL_52;
    }
    v3 = high_power[0];
    v2 = v5;
LABEL_52:
    ++v1;
  }
  if ( high_power[0] == 0.0 )
    return 0;
  list_var(v, 0);
  __fprintf_chk(gfp, 1, "Equation is a degree %.*g polynomial in (%s).\n", precision, high_power[0], var_str);
  if ( trhs >= a1p || (opx1 = 2, a1p[-1].token.variable != 2) )
    opx1 = 1;
  if ( high_power[0] == 2.0 )
  {
    v10 = a2p - x1p - 2;
    nx1a = v10;
    if ( v10 <= 100 )
    {
      __memmove_chk(x1_storage, x1p, 16 * v10, 1600);
      goto LABEL_62;
    }
    return 0;
  }
  v11 = a2p - x1p;
  nx1a = v11;
  if ( v11 > 100 )
    return 0;
  __memmove_chk(x1_storage, x1p, 16 * v11, 1600);
  *(double *)((char *)&high_power[2 * nx1a + 1] + 4) = *(double *)((char *)&high_power[2 * nx1a + 1] + 4) * 0.5;
LABEL_62:
  v12 = trhs;
  LODWORD(high_power[0]) = trhs;
  opx2 = 0;
  v65 = 0;
  while ( 2 )
  {
    if ( v12 < v70 )
    {
      v13 = v12->level;
      opa = (token_type *)LODWORD(high_power[0]);
      if ( v13 == 1 )
      {
        if ( v12->kind == OPERATOR )
          break;
LABEL_84:
        if ( v12->kind == OPERATOR )
        {
          opx2 = v12->token.variable;
          LODWORD(high_power[0]) = v12 + 1;
          v65 = 0;
        }
LABEL_90:
        ++v12;
        continue;
      }
LABEL_86:
      if ( v12->kind == OPERATOR && v13 == 2 )
      {
        v65 = v12->token.variable;
        LODWORD(high_power[0]) = opa;
      }
      else
      {
        LODWORD(high_power[0]) = opa;
      }
      goto LABEL_90;
    }
    break;
  }
  n = (size_t)v12;
  alen = LODWORD(high_power[0]);
  if ( !se_compare(
          x1_storage,
          nx1a,
          (token_type *)LODWORD(high_power[0]),
          ((int)v12 - LODWORD(high_power[0])) >> 4,
          diff_sign) )
  {
    opa = (token_type *)LODWORD(high_power[0]);
    if ( (unsigned int)(v65 - 3) > 1 )
    {
LABEL_81:
      if ( v12 >= v70 )
        return 0;
      v13 = v12->level;
      if ( v13 == 1 )
      {
        LODWORD(high_power[0]) = opa;
        goto LABEL_84;
      }
      goto LABEL_86;
    }
    v14 = (token_type *)LODWORD(high_power[0]);
    v15 = 0;
    while ( 2 )
    {
      if ( v12 <= v14 )
      {
LABEL_72:
        if ( (!v15 || v15 == 3) && se_compare(x1_storage, nx1a, opa, v14 - opa, diff_sign) )
        {
          v16 = (const void *)LODWORD(high_power[0]);
          LODWORD(high_power[0]) = opa;
          goto big_bbreak;
        }
        if ( v12 <= v14 )
          goto LABEL_81;
        if ( v14->level == 2 )
          goto LABEL_78;
      }
      else if ( v14->level == 2 )
      {
        if ( v14->kind == OPERATOR )
          goto LABEL_72;
LABEL_78:
        if ( v14->kind == OPERATOR )
        {
          opa = v14 + 1;
          v15 = v14->token.variable;
        }
      }
      ++v14;
      continue;
    }
  }
  v16 = (const void *)LODWORD(high_power[0]);
  v14 = v12;
big_bbreak:
  if ( opx2 < 0 )
    return 0;
  if ( opx2 <= 1 )
  {
    opx2 = 2;
    if ( !diff_sign[0] )
      goto LABEL_99;
  }
  else
  {
    if ( opx2 != 2 )
      return 0;
    if ( diff_sign[0] )
LABEL_99:
      opx2 = 1;
  }
  memmove(scratch, v16, LODWORD(high_power[0]) - alen);
  v17 = (LODWORD(high_power[0]) - alen) >> 4;
  v18 = v17;
  scratch[v18].level = 7;
  scratch[v18].kind = CONSTANT;
  if ( opx2 == 2 )
    scratch[v18].token.constant = -1.0;
  else
    scratch[v18].token.constant = 1.0;
  memmove(&scratch[v17 + 1], v14, n - (_DWORD)v14);
  opb = v17 + 1 + ((int)(n - (_DWORD)v14) >> 4);
  v19 = 7 - min_level(scratch, opb);
  if ( opb > 0 )
  {
    for ( i = 0; i != opb; ++i )
      scratch[i].level += v19;
  }
  v21 = opb;
  scratch[v21].level = 6;
  scratch[v21].kind = OPERATOR;
  scratch[v21].token.variable = 6;
  v22 = opb + 1;
  scratch[v22].level = 6;
  scratch[v22].kind = CONSTANT;
  scratch[v22].token.constant = 2.0;
  v23 = opb + 2;
  scratch[v23].level = 5;
  scratch[v23].kind = OPERATOR;
  scratch[v23].token.variable = 2;
  v24 = opb + 3;
  scratch[v24].level = 6;
  scratch[v24].kind = CONSTANT;
  scratch[v24].token.constant = 4.0;
  v25 = opb + 4;
  scratch[v25].level = 6;
  scratch[v25].kind = OPERATOR;
  scratch[v25].token.variable = 3;
  v26 = opb + 5;
  opx2a = opb + 5;
  memmove(&scratch[opx2a], a1p, (char *)x1p - (char *)a1p);
  v27 = opb + 5 + x1p - a1p;
  v28 = v27;
  scratch[v28].level = 7;
  scratch[v28].kind = CONSTANT;
  if ( opx1 == 2 )
    scratch[v28].token.constant = -1.0;
  else
    scratch[v28].token.constant = 1.0;
  v29 = v27 + 1;
  memmove(&scratch[v27 + 1], a2p, (char *)a2ep - (char *)a2p);
  v30 = a2ep - a2p + v29;
  alena = v30 - v26;
  v31 = 7 - min_level(&scratch[opx2a], v30 - v26);
  if ( v26 < v30 )
  {
    v32 = opb + 5;
    v33 = opb + 5;
    do
    {
      scratch[v32].level += v31;
      ++v33;
      ++v32;
    }
    while ( v30 > v33 );
  }
  v34 = v30;
  scratch[v34].level = 6;
  scratch[v34].kind = OPERATOR;
  scratch[v34].token.variable = 3;
  v66 = v30 + 1;
  scratch[v30 + 1] = zero_token;
  v35 = trhs;
  v36 = trhs;
  v37 = v30 + 2;
  v38 = v70;
  while ( 2 )
  {
    if ( v35 < v38 && (v35->level != 1 || v35->kind != OPERATOR) )
    {
LABEL_127:
      ++v35;
      continue;
    }
    break;
  }
  if ( (v36 > x1p || v35 <= x1p)
    && ((unsigned int)v36 > LODWORD(high_power[0]) || (unsigned int)v35 <= LODWORD(high_power[0])) )
  {
    if ( v36 == trhs )
    {
      v39 = v37;
      scratch[v39].level = 1;
      scratch[v39].kind = OPERATOR;
      scratch[v39].token.variable = 1;
      ++v37;
    }
    v71 = (char *)v35 - (char *)v36;
    memmove(&scratch[v37], v36, (char *)v35 - (char *)v36);
    v37 += v71 >> 4;
  }
  if ( v35 < v38 )
  {
    v36 = v35;
    goto LABEL_127;
  }
  if ( v66 < v37 )
  {
    v40 = v66;
    v41 = v66;
    do
    {
      scratch[v40].level += 6;
      ++v41;
      ++v40;
    }
    while ( v41 < v37 );
  }
  v42 = v37;
  scratch[v42].level = 4;
  scratch[v42].kind = OPERATOR;
  scratch[v42].token.variable = 6;
  v43 = v37 + 1;
  scratch[v43].level = 4;
  scratch[v43].kind = CONSTANT;
  scratch[v43].token.constant = 0.5;
  v44 = v37 + 2;
  scratch[v44].level = 3;
  scratch[v44].kind = OPERATOR;
  scratch[v44].token.variable = 3;
  v45 = v37 + 3;
  scratch[v45].level = 3;
  scratch[v45].kind = VARIABLE;
  next_sign((int *)&scratch[v45].token);
  v46 = v37 + 4;
  scratch[v46].level = 2;
  scratch[v46].kind = OPERATOR;
  scratch[v46].token.variable = 2;
  v47 = v37 + 5 + opb;
  if ( alena + v47 + 3 > n_tokens )
    error_huge();
  memmove(&scratch[v37 + 5], scratch, 16 * opb);
  v48 = v47;
  scratch[v48].level = 1;
  scratch[v48].kind = OPERATOR;
  scratch[v48].token.variable = 4;
  v49 = v47 + 1;
  scratch[v49].level = 2;
  scratch[v49].kind = CONSTANT;
  scratch[v49].token.constant = 2.0;
  v50 = v47 + 2;
  scratch[v50].level = 2;
  scratch[v50].kind = OPERATOR;
  scratch[v50].token.variable = 3;
  v51 = v47 + 3;
  memmove(&scratch[v51], &scratch[opx2a], 16 * alena);
  v52 = alena + v51;
  if ( found_var(scratch, v52, v) )
    return 0;
  memmove(tlhs, x1_storage, 16 * nx1a);
  n_tlhs = nx1a;
  simp_loop(tlhs, &n_tlhs);
  memmove(trhs, scratch, 16 * v52);
  n_trhs = v52;
  simp_loop(trhs, &n_trhs);
  list_debug(2, tlhs, n_tlhs, trhs, n_trhs);
  uf_tsimp(trhs, &n_trhs);
  simps_side(trhs, &n_trhs, 0);
  list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
  result = 1;
  if ( debug_level >= 0 )
  {
    __fprintf_chk(gfp, 1, "%s\n", "Equation was solved with the quadratic formula.");
    result = 1;
  }
  return result;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049244: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804D01A) --------------------------------------------------------
int __cdecl solve_sub(token_type *wantp, int wantn, token_type *leftp, int *leftnp, token_type *rightp, int *rightnp)
{
  token_type *v6; // edx
  token_type *v7; // eax
  token_type *v8; // ecx
  token_type *v9; // edi
  token_type *v10; // ecx
  int v11; // esi
  token_type *v12; // edx
  token_type *i; // ecx
  token_type *v14; // ecx
  token_type *v15; // esi
  token_type *v16; // edx
  token_type *v17; // eax
  int v18; // ecx
  token_type *v19; // ebx
  kind_list v20; // eax
  token_type *j; // esi
  token_type *v22; // eax
  token_type *v23; // esi
  token_type *v24; // edx
  token_type *v25; // ebx
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  token_type *v29; // eax
  int v30; // eax
  token_type *v31; // eax
  int k; // edx
  int v33; // ecx
  token_type *v34; // eax
  int l; // edx
  int v36; // ecx
  token_type *v37; // eax
  token_type *v38; // ebx
  int v39; // esi
  int v40; // edi
  int v41; // edx
  token_type *v42; // edx
  int v43; // eax
  token_type *v44; // edx
  token_type *v45; // eax
  token_type *v46; // eax
  double *v47; // edx
  int m; // esi
  int v49; // edi
  double *v50; // ebx
  token_type *v51; // ecx
  int v52; // esi
  int v53; // edi
  token_type *v54; // edx
  int v55; // ebx
  token_type *v56; // edx
  int v57; // edx
  token_type *v58; // edx
  int v59; // edi
  token_type *v60; // ebx
  int v61; // esi
  token_type *v62; // ebx
  int v63; // ebx
  int v64; // esi
  token_type *v65; // edx
  int v66; // ebx
  int v68; // [esp+2Ch] [ebp-7Ch]
  int inc_count; // [esp+38h] [ebp-70h]
  char zero_solved; // [esp+3Ch] [ebp-6Ch]
  int zero_solveda; // [esp+3Ch] [ebp-6Ch]
  int worked; // [esp+40h] [ebp-68h]
  int workeda; // [esp+40h] [ebp-68h]
  int workedb; // [esp+40h] [ebp-68h]
  int workedc; // [esp+40h] [ebp-68h]
  int workedd; // [esp+40h] [ebp-68h]
  int qtries; // [esp+44h] [ebp-64h]
  int success; // [esp+48h] [ebp-60h]
  int uf_flag; // [esp+4Ch] [ebp-5Ch]
  token_type *uf_flaga; // [esp+4Ch] [ebp-5Ch]
  int v81; // [esp+50h] [ebp-58h]
  int v82; // [esp+50h] [ebp-58h]
  int v83; // [esp+54h] [ebp-54h]
  token_type *operandp; // [esp+58h] [ebp-50h]
  token_type *operandpa; // [esp+58h] [ebp-50h]
  token_type *operandpb; // [esp+58h] [ebp-50h]
  token_type *operandpc; // [esp+58h] [ebp-50h]
  token_type *operandpd; // [esp+58h] [ebp-50h]
  int v; // [esp+5Ch] [ebp-4Ch]
  int found_count; // [esp+60h] [ebp-48h]
  double found_counta; // [esp+60h] [ebp-48h]
  int zsolve; // [esp+6Ch] [ebp-3Ch]
  double denominator; // [esp+78h] [ebp-30h] BYREF
  double numerator; // [esp+80h] [ebp-28h] BYREF
  int diff_sign[7]; // [esp+8Ch] [ebp-1Ch] BYREF

  repeat_count = 0;
  n_tlhs = *leftnp;
  memmove(tlhs, leftp, 16 * n_tlhs);
  n_trhs = *rightnp;
  memmove(trhs, rightp, 16 * n_trhs);
  if ( wantn != 1 )
    goto LABEL_2;
  if ( n_tlhs <= 0 || n_trhs <= 0 )
  {
    error("Please enter an equation or a command like \"help\".");
    return 0;
  }
  if ( wantp->kind == VARIABLE )
  {
    v = wantp->token.variable;
    if ( !found_var(trhs, n_trhs, v) && !found_var(tlhs, n_tlhs, v) )
    {
      error("Variable not found.");
      return 0;
    }
    zsolve = 0;
  }
  else
  {
    if ( wantp->kind || wantp->token.constant != 0.0 )
    {
LABEL_2:
      error("This program will only solve for a single variable or for zero.");
      return 0;
    }
    zsolve = 1;
    v = 0;
  }
  uf_power(tlhs, &n_tlhs);
  uf_power(trhs, &n_trhs);
  success = 1;
  zero_solved = 0;
  inc_count = 0;
  qtries = 0;
  uf_flag = 0;
  while ( 2 )
  {
    while ( 2 )
    {
      while ( 2 )
      {
        while ( 2 )
        {
          while ( 1 )
          {
            list_debug(2, tlhs, n_tlhs, trhs, n_trhs);
            simps_side(tlhs, &n_tlhs, zsolve);
            if ( uf_flag )
            {
              simp_loop(trhs, &n_trhs);
              uf_simp(trhs, &n_trhs);
              factorv(trhs, &n_trhs, v);
            }
            else
            {
              simps_side(trhs, &n_trhs, zsolve);
            }
            list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
no_simp:
            v6 = trhs;
            v7 = &trhs[n_trhs];
            if ( !zsolve )
              break;
            if ( trhs >= v7 )
              goto LABEL_60;
            v8 = trhs;
            while ( v8->level != 1 || v8->kind != OPERATOR || v8->token.variable != 4 )
            {
              if ( v7 <= ++v8 )
                goto LABEL_60;
            }
            if ( !g_of_f(4, v8 + 1, trhs, &n_trhs, tlhs, &n_tlhs) )
              return 0;
          }
          if ( trhs < v7 )
          {
            v9 = trhs;
            v10 = trhs;
            v11 = 0;
            while ( v10->kind != VARIABLE || v10->token.variable != v )
            {
              if ( v10->level == 1 && v10->kind == OPERATOR )
              {
                v11 = v10->token.variable;
                v9 = v10 + 1;
              }
              if ( v7 <= ++v10 )
              {
                v6 = trhs;
                goto LABEL_60;
              }
            }
            v12 = trhs;
            if ( v11 )
            {
LABEL_46:
              if ( (unsigned int)v11 > 6 || ((1 << v11) & 0x58) == 0 )
              {
                v12 = v9;
                goto LABEL_53;
              }
            }
            else
            {
              for ( i = v10 + 1; ; ++i )
              {
                if ( i >= v7 )
                  goto LABEL_52;
                if ( i->level == 1 && i->kind == OPERATOR )
                  break;
              }
              v11 = i->token.variable;
              if ( v11 < 1 )
                goto LABEL_46;
              if ( v11 <= 2 )
              {
LABEL_52:
                v12 = v9;
                v11 = 1;
                goto LABEL_53;
              }
              if ( v11 > 4 )
                goto LABEL_46;
            }
            v14 = trhs;
            do
            {
              ++v14->level;
              ++v14;
            }
            while ( v14 < v7 );
            v11 = 1;
LABEL_53:
            if ( !g_of_f(v11, v12, trhs, &n_trhs, tlhs, &n_tlhs) )
              return 0;
            continue;
          }
          break;
        }
LABEL_60:
        if ( uf_flag )
          simps_side(v6, &n_trhs, zsolve);
LABEL_63:
        while ( 2 )
        {
          uf_flag = 0;
          worked = 1;
LABEL_64:
          while ( 2 )
          {
            if ( found_var(trhs, n_trhs, v) )
            {
              if ( debug_level <= 0 )
                return 0;
              goto LABEL_66;
            }
            if ( se_compare(wantp, 1, tlhs, n_tlhs, diff_sign) && !diff_sign[0] )
            {
              if ( zsolve )
              {
                while ( 1 )
                {
LABEL_70:
                  list_debug(4, tlhs, n_tlhs, trhs, n_trhs);
                  uf_power(trhs, &n_trhs);
                  do
                  {
                    do
                      simp_ssub(trhs, &n_trhs, 0, 0.0, 0, 1, 0);
                    while ( uf_power(trhs, &n_trhs) );
                  }
                  while ( super_factor(trhs, &n_trhs, 1) );
                  list_debug(3, tlhs, n_tlhs, trhs, n_trhs);
                  v15 = trhs;
                  v16 = &trhs[n_trhs];
                  v17 = trhs + 1;
                  v18 = 0;
                  while ( v17 < v16 )
                  {
                    if ( v17->level == 1 )
                    {
                      v18 = v17->token.variable;
                      if ( v18 == 4 )
                        goto no_simp;
                      if ( v18 != 3 )
                        break;
                    }
                    v17 += 2;
                  }
                  if ( v18 == 3 )
                  {
LABEL_96:
                    if ( v15 >= v16 )
                      break;
                    v19 = v15;
                    while ( 1 )
                    {
                      v20 = v19->kind;
                      if ( v19->kind == OPERATOR )
                      {
                        if ( v19->level == 1 )
                          goto LABEL_85;
                      }
                      else if ( v20 && (v20 != VARIABLE || (v19->token.variable & 0x3FFFu) > 4) )
                      {
                        for ( j = v15 + 1; j < v16 && j->level > 1; j += 2 )
                          ;
                        v15 = j + 1;
                        goto LABEL_96;
                      }
                      if ( v16 <= ++v19 )
                      {
LABEL_85:
                        memmove(&v15[1], v19, (char *)v16 - (char *)v19);
                        n_trhs -= v19 - &v15[1];
                        v15->kind = CONSTANT;
                        v15->token.constant = 1.0;
                        goto LABEL_70;
                      }
                    }
                  }
                  if ( v18 != 6 )
                    break;
                  v22 = v17 + 1;
                  if ( v22->level != 1 || v22->kind || v22->token.constant <= 0.0 )
                    break;
                  n_trhs -= 2;
                }
                if ( debug_level > 0 )
                  __fprintf_chk(gfp, 1, "%s\n", "Solve for zero completed:");
              }
              else if ( debug_level > 0 )
              {
                __fprintf_chk(gfp, 1, "%s\n", "Solve completed:");
              }
              list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
              memmove(leftp, tlhs, 16 * n_tlhs);
              *leftnp = n_tlhs;
              memmove(rightp, trhs, 16 * n_trhs);
              *rightnp = n_trhs;
              return success;
            }
            operandp = tlhs;
            v23 = &tlhs[n_tlhs];
            v24 = tlhs;
            v25 = tlhs;
            v26 = 0;
            v27 = 0;
            found_count = 0;
            v68 = 0;
            while ( v25 < v23 && (v25->level != 1 || v25->kind != OPERATOR) )
            {
              if ( v25->kind == VARIABLE && v25->token.variable == v )
              {
                ++found_count;
                ++v26;
              }
LABEL_342:
              ++v25;
            }
            if ( v26 )
            {
              v30 = v68 + v26;
              if ( v27 != 4 )
                v30 = v68;
              v68 = v30;
            }
            else if ( (v25 < v23 || found_count || zsolve || n_tlhs > 1 || tlhs->kind)
                   && ((unsigned int)((char *)v25 - (char *)v24 - 16) > 0xF
                    || v24->kind
                    || v24->token.constant != 1.0
                    || v25 >= v23
                    || v25->token.variable != 4) )
            {
              if ( !v27 )
              {
                if ( v25 >= v23 )
                  goto LABEL_132;
                while ( v25->level != 1 || v25->kind != OPERATOR )
                {
                  if ( v23 <= ++v25 )
                    goto LABEL_132;
                }
                v27 = v25->token.variable;
                if ( v27 < 1 )
                  goto LABEL_133;
                if ( v27 <= 2 )
                {
LABEL_132:
                  v27 = 1;
                }
                else if ( v27 <= 4 )
                {
                  v27 = 3;
                }
              }
LABEL_133:
              if ( !zsolve )
              {
                v28 = v27;
                goto LABEL_145;
              }
              if ( v25 >= v23 )
              {
                v28 = v27;
                if ( v27 != 4 )
                {
                  if ( tlhs < v23 )
                  {
                    v29 = tlhs;
                    do
                    {
                      ++v29->level;
                      ++v29;
                    }
                    while ( v23 > v29 );
                  }
                  v24 = operandp;
                  v28 = 1;
                }
LABEL_145:
                if ( !g_of_f(v28, v24, tlhs, &n_tlhs, trhs, &n_trhs) )
                  return 0;
                list_debug(2, tlhs, n_tlhs, trhs, n_trhs);
                if ( uf_flag )
                  simp_loop(tlhs, &n_tlhs);
                else
                  simps_side(tlhs, &n_tlhs, zsolve);
                simps_side(trhs, &n_trhs, zsolve);
                list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
                continue;
              }
              if ( (unsigned int)v27 <= 4 && ((1 << v27) & 0x16) != 0 )
              {
                v28 = v27;
                goto LABEL_145;
              }
              goto fin1;
            }
            break;
          }
          if ( v25 < v23 )
          {
fin1:
            v27 = v25->token.variable;
            v24 = v25 + 1;
            v26 = 0;
            goto LABEL_342;
          }
          if ( !found_count )
          {
            if ( !found_var(trhs, n_trhs, v) )
            {
              calc_simp(tlhs, &n_tlhs);
              calc_simp(trhs, &n_trhs);
              if ( !se_compare(tlhs, n_tlhs, trhs, n_trhs, diff_sign) || diff_sign[0] )
              {
                v31 = tlhs;
                for ( k = 0; k < n_tlhs; k += 2 )
                {
                  if ( v31->kind == VARIABLE && v31->token.variable > 3 )
                  {
                    v33 = 1;
                    goto LABEL_168;
                  }
                  v31 += 2;
                }
                v33 = 0;
LABEL_168:
                v34 = trhs;
                for ( l = 0; l < n_trhs; l += 2 )
                {
                  if ( v34->kind == VARIABLE && v34->token.variable > 3 )
                    goto LABEL_174;
                  v34 += 2;
                }
                if ( v33 )
                {
LABEL_174:
                  error("This equation is independent of the solve variable.");
                  return -2;
                }
                error("There are no possible values for the solve variable.");
                success = -2;
              }
              else
              {
                error("This equation is an identity.");
                __printf_chk(1, "That is, the LHS is identical to the RHS.\n");
                success = -1;
              }
              return success;
            }
            if ( debug_level <= 0 )
              return 0;
LABEL_66:
            __fprintf_chk(gfp, 1, "%s\n", "Solve variable moved back to RHS, quitting solve routine.");
            return 0;
          }
          if ( n_trhs == 1 && trhs->kind == CONSTANT && trhs->token.constant == 0.0 )
          {
            trhs->token.constant = 0.0;
            v36 = 1;
          }
          else
          {
            v36 = 0;
          }
          if ( found_count <= v68 )
          {
            if ( !flip(tlhs, &n_tlhs, trhs, &n_trhs) )
              return 0;
            list_debug(2, tlhs, n_tlhs, trhs, n_trhs);
            simps_side(tlhs, &n_tlhs, zsolve);
            simps_side(trhs, &n_trhs, zsolve);
            list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
            continue;
          }
          break;
        }
        if ( worked && !uf_flag )
        {
          if ( debug_level > 0 )
            __fprintf_chk(gfp, 1, "%s\n", "Unfactoring...");
          partial_flag = 0;
          uf_simp(tlhs, &n_tlhs);
          partial_flag = 1;
          factorv(tlhs, &n_tlhs, v);
          list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
          uf_flag = 1;
          worked = 0;
          goto LABEL_64;
        }
        if ( uf_flag )
        {
          simps_side(tlhs, &n_tlhs, zsolve);
          list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
          uf_flag = 0;
          goto LABEL_64;
        }
        v37 = tlhs + 2;
        v38 = tlhs;
        v39 = 0;
        v40 = 1;
        while ( 2 )
        {
          if ( v40 < n_tlhs )
          {
            if ( v37[-1].level == 1 )
            {
              workeda = v37[-1].token.variable;
              if ( (unsigned int)(workeda - 3) > 1 )
              {
                v39 = v37[-1].token.variable;
                break;
              }
              if ( !v39 )
                v39 = 3;
              if ( v36 )
              {
                if ( workeda == 4 )
                {
                  v38 = &tlhs[v40 + 1];
                  v39 = 4;
                  break;
                }
                operandpa = v37;
                if ( v37->kind == VARIABLE && v37->token.variable == v )
                {
                  v41 = v37->level;
                  if ( v41 == 1
                    || v41 == 2
                    && v37[1].token.variable == 6
                    && v37[2].level == 2
                    && v37[2].kind == CONSTANT
                    && v37[2].token.constant > 0.0 )
                  {
                    v39 = v37[-1].token.variable;
                    goto LABEL_219;
                  }
                }
              }
              else if ( workeda == 4 )
              {
                operandpb = (token_type *)(v40 + 2);
                v42 = v37 + 1;
                while ( (int)operandpb < n_tlhs )
                {
                  workedb = (int)v42;
                  v81 = v42->level;
                  if ( v81 <= 1 )
                    break;
                  v42 += 2;
                  if ( v81 == 2 )
                  {
                    if ( (unsigned int)(*(_DWORD *)(workedb + 8) - 1) > 1 )
                      break;
                    operandpa = v37;
                    v39 = 4;
                    goto LABEL_219;
                  }
                  operandpb = (token_type *)((char *)operandpb + 2);
                }
              }
            }
            operandpa = v38;
LABEL_219:
            v40 += 2;
            v37 += 2;
            v38 = operandpa;
            continue;
          }
          break;
        }
        if ( v36 && zero_solved && v39 == 3 && v38->kind == VARIABLE && v38->token.variable == v )
        {
          v43 = v38->level;
          if ( v43 == 1
            || v43 == 2
            && v38[1].token.variable == 6
            && v38[2].level == 2
            && v38[2].kind == CONSTANT
            && v38[2].token.constant > 0.0 )
          {
            __fprintf_chk(gfp, 1, "Removing possible solution: \"");
            list_proc(v38, 1, 0);
            __fprintf_chk(gfp, 1, " = 0\".\n");
            success = 2;
            qtries = 0;
LABEL_238:
            if ( !g_of_f(v39, v38, tlhs, &n_tlhs, trhs, &n_trhs) )
              return 0;
            continue;
          }
        }
        else if ( v39 == 4 )
        {
          uf_flag = 1;
          if ( debug_level > 0 )
          {
            __fprintf_chk(gfp, 1, "%s\n", "Juggling...");
            uf_flag = 1;
          }
          goto LABEL_238;
        }
        break;
      }
      v49 = 0;
      v50 = 0;
      for ( m = 1; m < n_tlhs; m += 2 )
      {
        v44 = &tlhs[m];
        if ( v44->token.variable == 6 )
        {
          operandpc = (token_type *)(v49 * 16 + 32);
          v45 = &tlhs[v49 + 2];
          if ( v45->level == v44->level
            && v45->kind == CONSTANT
            && fabs(v45->token.constant) < 1.0
            && f_to_fraction(v45->token.constant, &numerator, &denominator)
            && fabs(numerator) == 1.0
            && denominator >= 2.0 )
          {
            v46 = &tlhs[v49];
            for ( workedc = m - 1; workedc >= 0 && v46->level >= tlhs[m].level; --workedc )
            {
              if ( v46->kind == VARIABLE && v46->token.variable == v )
              {
                if ( !v50 )
                {
                  v47 = (double *)((char *)tlhs + (_DWORD)operandpc);
                  goto LABEL_258;
                }
                v47 = (double *)((char *)tlhs + (_DWORD)operandpc);
                if ( fabs(*(double *)((char *)&tlhs->token.constant + (_DWORD)operandpc)) > fabs(v50[1]) )
                  goto LABEL_258;
                break;
              }
              --v46;
            }
          }
        }
        v47 = v50;
LABEL_258:
        v49 += 2;
        v50 = v47;
      }
      if ( !zero_solved || !v50 )
      {
        if ( qtries )
          return 0;
        if ( debug_level > 0 )
          __fprintf_chk(gfp, 1, "%s\n", "Solving for zero...");
        *leftnp = n_tlhs;
        memmove(leftp, tlhs, 16 * n_tlhs);
        *rightnp = n_trhs;
        memmove(rightp, trhs, 16 * n_trhs);
        if ( solve_sub(&zero_token, 1, leftp, leftnp, rightp, rightnp) <= 0 )
          return 0;
        qtries = zero_solved != 0;
        if ( !quad_solve(v) )
        {
          zero_solved = 1;
          continue;
        }
        zero_solved = 1;
        goto LABEL_63;
      }
      break;
    }
    if ( ++inc_count > 20 )
      return 0;
    __fprintf_chk(
      gfp,
      1,
      "Raising both equation sides to the power of %.*g and unfactoring...\n",
      precision,
      (double)(1.0 / v50[1]));
    found_counta = v50[1];
    partial_flag = 0;
    ufactor(tlhs, &n_tlhs);
    partial_flag = 1;
    symb_flag = symblify;
    simp_ssub(tlhs, &n_tlhs, v, found_counta, 1, 0, 2);
    simp_ssub(tlhs, &n_tlhs, 0, 1.0, 1, 1, 2);
    symb_flag = 0;
    while ( 2 )
    {
      uf_flaga = &tlhs[n_tlhs];
      v51 = tlhs + 1;
      operandpd = 0;
      v52 = 0;
      while ( 1 )
      {
        if ( uf_flaga <= v51 )
          goto LABEL_16;
        v53 = v51->level;
        if ( v53 == 1 )
          break;
        if ( v51->token.variable == 6
          && v53 == v51[1].level
          && v51[1].kind == CONSTANT
          && found_counta == v51[1].token.constant )
        {
          v54 = v51 - 1;
          v55 = 0;
          while ( 1 )
          {
            if ( v51->level > v54->level )
            {
              v56 = v54 + 1;
              goto LABEL_281;
            }
            if ( v54->kind == VARIABLE && v == v54->token.variable )
              v55 = 1;
            if ( tlhs == v54 )
              break;
            --v54;
          }
          v56 = tlhs;
LABEL_281:
          if ( v55 )
          {
            v57 = v51 - v56;
            if ( (int)operandpd >= v57 )
              v57 = (int)operandpd;
            operandpd = (token_type *)v57;
            v52 = 1;
          }
        }
        v51 += 2;
      }
      zero_solveda = v52;
      v58 = v51 + 2;
      v59 = 0;
      v82 = 0;
      workedd = v52;
      while ( uf_flaga > v58 )
      {
        if ( v58->token.variable == 6 )
        {
          v83 = v58[1].level;
          if ( v83 == v58->level && v58[1].kind == CONSTANT && found_counta == v58[1].token.constant )
          {
            v60 = v58 - 1;
            v61 = 0;
            while ( 1 )
            {
              if ( v83 > v60->level )
              {
                v62 = v60 + 1;
                goto LABEL_301;
              }
              if ( v60->kind == VARIABLE && v == v60->token.variable )
                v61 = 1;
              if ( tlhs == v60 )
                break;
              --v60;
            }
            v62 = tlhs;
LABEL_301:
            if ( v61 )
            {
              v63 = v58 - v62;
              if ( v59 < v63 )
                v59 = v63;
              v82 = 1;
            }
          }
        }
        v58 += 2;
      }
      v64 = workedd;
      if ( zero_solveda && v82 && v59 > (int)operandpd )
        v64 = 0;
      v65 = v51 + 1;
      v66 = v51->token.variable;
      if ( v66 != 6 || v51[1].level != 1 || v65->kind || found_counta != v51[1].token.constant )
      {
        if ( v64 )
          goto LABEL_330;
        if ( (unsigned int)((char *)v51 - (char *)tlhs - 16) <= 0xF && v66 == 4 )
        {
          if ( tlhs->kind == CONSTANT && tlhs->token.constant == 1.0 )
          {
            if ( !flip(tlhs, &n_tlhs, trhs, &n_trhs) )
              return 0;
LABEL_331:
            list_debug(2, tlhs, n_tlhs, trhs, n_trhs);
            simp_loop(tlhs, &n_tlhs);
            simp_loop(trhs, &n_trhs);
            list_debug(1, tlhs, n_tlhs, trhs, n_trhs);
            continue;
          }
        }
        else
        {
          if ( v66 < 1 )
            goto LABEL_328;
          if ( v66 <= 2 )
          {
            v65 = tlhs;
            v66 = 1;
            goto LABEL_330;
          }
          if ( v66 > 4 )
          {
LABEL_328:
            v65 = tlhs;
            goto LABEL_330;
          }
        }
        v65 = tlhs;
        v66 = 3;
LABEL_330:
        if ( !g_of_f(v66, v65, tlhs, &n_tlhs, trhs, &n_trhs) )
          return 0;
        goto LABEL_331;
      }
      break;
    }
    if ( g_of_f(6, v65, tlhs, &n_tlhs, trhs, &n_trhs) )
    {
LABEL_16:
      zero_solved = 0;
      qtries = 0;
      uf_flag = 1;
      continue;
    }
    return 0;
  }
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804E68E) --------------------------------------------------------
int __cdecl solve_espace(int want, int have)
{
  int v2; // edx
  int v3; // esi

  v2 = n_lhs[want];
  if ( v2 )
  {
    if ( n_rhs[want] )
    {
      error("This program will only solve for a single variable or for zero.");
      n_lhs[want] = 0;
      n_rhs[want] = 0;
      v3 = 0;
LABEL_7:
      __printf_chk(1, "Solve failed.\n");
      return v3 > 0;
    }
    v3 = solve_sub(lhs[want], v2, lhs[have], (int *)(4 * have + 134753664), rhs[have], &n_rhs[have]);
  }
  else
  {
    v3 = solve_sub(rhs[want], n_rhs[want], rhs[have], (int *)(4 * have + 134715712), lhs[have], &n_lhs[have]);
  }
  n_lhs[want] = 0;
  n_rhs[want] = 0;
  if ( v3 <= 0 )
    goto LABEL_7;
  return v3 > 0;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804E7B0) --------------------------------------------------------
int __cdecl display_command(int i)
{
  char *v1; // eax
  int v2; // esi
  char *v4; // [esp+2Ch] [ebp-1Ch]

  v4 = com_list[i].name;
  __fprintf_chk(gfp, 1, "%s - %s\n", v4, com_list[i].info);
  __fprintf_chk(gfp, 1, "Usage: %s %s\n", v4, com_list[i].usage);
  v1 = com_list[i].secondary_name;
  v2 = 3;
  if ( v1 )
  {
    __fprintf_chk(gfp, 1, "Alternate name for this command: %s\n", v1);
    LOWORD(v2) = 4;
  }
  if ( com_list[i].extra )
  {
    __fprintf_chk(gfp, 1, "%s\n", com_list[i].extra);
    ++v2;
  }
  __fprintf_chk(gfp, 1, "\n");
  return v2;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0804E8BB) --------------------------------------------------------
char *__cdecl parse_var2(int *vp, char *cp)
{
  char *v2; // edx
  char *result; // eax
  char *v4; // [esp+4h] [ebp-14h]

  v4 = skip_space(cp);
  v2 = parse_var(vp, v4);
  result = 0;
  if ( v2 )
    result = skip_space(v2);
  return result;
}

//----- (0804E8F0) --------------------------------------------------------
int __cdecl shell_out(char *cp)
{
  int v1; // ebx

  if ( security_level )
    error_bug("Shelling out disabled.");
  reset_attr();
  *__errno_location() = 0;
  v1 = system(cp);
  __printf_chk(1, "\n");
  if ( v1 < 0 )
    perror("system(3) call failed");
  default_color();
  return v1;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804E95A) --------------------------------------------------------
int __cdecl parse(int n, char *cp)
{
  int result; // eax

  if ( parse_equation(n, cp) )
  {
    if ( !n_lhs[n] )
    {
      result = 1;
      if ( !n_rhs[n] )
        return result;
      n_lhs[n] = 1;
      *lhs[n] = zero_token;
    }
    cur_equation = n;
    result = return_result(n);
  }
  else
  {
    n_lhs[n] = 0;
    n_rhs[n] = 0;
    result = 0;
  }
  return result;
}

//----- (0804E9F6) --------------------------------------------------------
int __cdecl process_parse(int n, char *cp)
{
  char *v2; // eax
  char *v3; // edx
  int v4; // edx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int result; // eax
  token_type *v9; // ecx
  token_type *v10; // ecx
  int v11; // edx
  token_type *v12; // eax
  long double v13; // fst5
  char v15; // c2
  long double v16; // fst7
  int v17; // edi
  int v18; // [esp+14h] [ebp-24h]

  v2 = parse_equation(n, cp);
  if ( !v2 )
  {
    n_lhs[n] = 0;
    n_rhs[n] = 0;
    return 0;
  }
  if ( cp >= v2 )
    goto LABEL_9;
  v3 = cp;
  if ( *cp != 61 )
  {
    while ( v2 > ++v3 )
    {
      if ( *v3 == 61 )
        goto LABEL_8;
    }
LABEL_9:
    v4 = 0;
    goto LABEL_10;
  }
LABEL_8:
  v4 = 1;
LABEL_10:
  v5 = n_lhs[n];
  if ( v5 )
  {
    if ( n_rhs[n] )
    {
return_ok:
      cur_equation = n;
      return return_result(n);
    }
  }
  else if ( !n_rhs[n] )
  {
    if ( *cp != asc_80727BC[0] || cp[1] != asc_80727BC[1] || n_lhs[cur_equation] <= 0 || n_rhs[cur_equation] <= 0 )
      return 1;
    if ( debug_level >= 0 )
      __fprintf_chk(gfp, 1, "%s\n", "Swapping both sides of the current equation...");
    v6 = cur_equation;
    v18 = n_lhs[cur_equation];
    memmove(tes, lhs[cur_equation], 16 * v18);
    v7 = n_rhs[v6];
    n_lhs[v6] = v7;
    memmove(lhs[v6], rhs[v6], 16 * v7);
    n_rhs[v6] = v18;
    memmove(rhs[v6], tes, 16 * v18);
    return return_result(cur_equation);
  }
  if ( !v4 && !autosolve )
    goto LABEL_36;
  if ( v5 == 1 )
  {
    v9 = lhs[n];
    if ( v9->kind )
    {
      if ( v9->kind == VARIABLE && ((v9->token.variable & 0x3FFFu) > 4 || v4) )
        goto LABEL_34;
    }
    else if ( v9->token.constant == 0.0 )
    {
      goto LABEL_34;
    }
  }
  if ( n_rhs[n] != 1 )
  {
LABEL_36:
    if ( !n_rhs[n] )
    {
      if ( autoselect )
      {
        if ( v5 == 1 )
        {
          v12 = lhs[n];
          if ( v12->kind == CONSTANT )
          {
            v13 = v12->token.constant;
            do
              v13 = __FPREM__(v13, 1.0);
            while ( v15 );
            if ( v13 == 0.0 )
            {
              v16 = lhs[n]->token.constant;
              if ( v16 > 0.0 && (long double)n_equations >= v16 )
              {
                cur_equation = (int)(v16 - 1.0);
                n_lhs[n] = 0;
                return_result((int)(v16 - 1.0));
                return 1;
              }
            }
          }
        }
      }
      if ( !autocalc )
        goto return_ok;
      if ( n_lhs[n] )
      {
        if ( !exp_is_numeric(lhs[n], n_lhs[n]) )
          goto return_ok;
        memmove(rhs[n], lhs[n], 16 * n_lhs[n]);
        n_rhs[n] = n_lhs[n];
      }
      lhs[n]->level = 1;
      lhs[n]->kind = VARIABLE;
      parse_var((int *)&lhs[n]->token, "answer");
      n_lhs[n] = 1;
      v17 = cur_equation;
      cur_equation = n;
      calculate_cmd("");
      cur_equation = v17;
      n_lhs[n] = 0;
      n_rhs[n] = 0;
      return 1;
    }
    goto LABEL_37;
  }
  v10 = rhs[n];
  if ( v10->kind )
  {
    if ( v10->kind == VARIABLE )
      goto LABEL_34;
    goto LABEL_36;
  }
  if ( v10->token.constant != 0.0 )
  {
LABEL_37:
    n_lhs[n] = 1;
    *lhs[n] = zero_token;
    goto return_ok;
  }
LABEL_34:
  v11 = solve_espace(n, cur_equation);
  result = 0;
  if ( v11 )
    result = return_result(cur_equation);
  return result;
}
// 804EC9A: variable 'v15' is possibly undefined
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0804EE45) --------------------------------------------------------
int __cdecl process(char *cp)
{
  int v1; // ebx
  char v2; // al
  char v3; // al
  int v4; // esi
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char v9; // si
  char *v10; // ebx
  const unsigned __int16 **v11; // eax
  char v12; // dl
  const com_type *v13; // esi
  const char *v14; // ebx
  unsigned int v15; // ecx
  const char *v16; // edx
  unsigned int v17; // ecx
  const char *v18; // esi
  unsigned int v19; // ecx
  unsigned int v20; // ebx
  char *v21; // eax
  char v22; // dl
  char *v23; // eax
  unsigned int v24; // edx
  int v25; // ecx
  int v26; // eax
  char *v28; // [esp+10h] [ebp-1048h]
  int v29; // [esp+1Ch] [ebp-103Ch]
  size_t v30; // [esp+20h] [ebp-1038h]
  int v31; // [esp+28h] [ebp-1030h]
  char *s1; // [esp+2Ch] [ebp-102Ch]
  char *cp1; // [esp+38h] [ebp-1020h] BYREF
  char buf2[4096]; // [esp+3Ch] [ebp-101Ch] BYREF
  unsigned int v35; // [esp+103Ch] [ebp-1Ch]

  v35 = __readgsdword(0x14u);
  init_gvars();
  set_sign_array();
  v1 = 0;
  if ( !cp )
    return v1;
  s1 = skip_space(cp);
  v2 = *s1;
  if ( *s1 == 35 )
  {
    v3 = s1[1];
    if ( v3 == 43 || v3 == 45 )
      v4 = cur_equation + decstrtol(s1 + 1, &cp1);
    else
      v4 = decstrtol(s1 + 1, &cp1) - 1;
    v1 = 1;
    if ( s1 + 1 != cp1 )
    {
      if ( v4 >= 0 && v4 < n_equations )
      {
        v5 = skip_space(&cp1[*cp1 == 58]);
        if ( *v5 )
        {
          input_column += v5 - cp;
          v1 = parse(v4, v5);
        }
        else
        {
          cur_equation = v4;
          return_result(v4);
          v1 = 1;
        }
      }
      else
      {
        error("Equation not defined.");
        v1 = 0;
      }
    }
    return v1;
  }
  if ( !security_level && v2 == 33 )
  {
    v6 = getenv("SHELL");
    if ( !v6 )
      v6 = "/bin/sh";
    cp1 = v6;
    if ( access(v6, 1) )
    {
      error("Shell not found or not executable, check SHELL environment variable.");
      v1 = 0;
    }
    else
    {
      v7 = skip_space(s1 + 1);
      if ( !*v7 )
        v7 = cp1;
      v1 = shell_out(v7) == 0;
    }
    return v1;
  }
  v29 = 0;
  if ( v2 == 63 )
  {
    v8 = skip_space(s1 + 1);
    input_column += v8 - cp;
    return help_cmd(v8);
  }
  while ( 1 )
  {
    cp1 = s1;
    v9 = *s1;
    v10 = s1;
    if ( *s1 )
    {
      v11 = __ctype_b_loc();
      v12 = v9;
      do
      {
        if ( ((*v11)[v12] & 0x2000) != 0 )
          break;
        cp1 = ++v10;
        v12 = *v10;
      }
      while ( *v10 );
    }
    if ( v10 - s1 != 6 || strncasecmp(s1, "repeat", 6u) )
      break;
    s1 = skip_space(v10);
    v29 = 1;
  }
  v30 = v10 - s1;
  v13 = com_list;
  v31 = 0;
  v28 = v10;
  while ( 1 )
  {
    v14 = v13->name;
    v15 = strlen(v13->name);
    if ( v15 > 4 )
      v15 = 4;
    if ( v30 >= v15 && !strncasecmp(s1, v14, v30) )
      break;
    v16 = v13->secondary_name;
    if ( v16 )
    {
      v17 = strlen(v13->secondary_name);
      if ( v17 > 4 )
        v17 = 4;
      if ( v30 >= v17 && !strncasecmp(s1, v16, v30) )
        break;
    }
    ++v31;
    ++v13;
    if ( v31 == 42 )
    {
      if ( v29 )
      {
        error("Expecting command to repeat.");
        v1 = 0;
      }
      else
      {
        v26 = next_espace();
        input_column += s1 - cp;
        v1 = process_parse(v26, s1);
      }
      return v1;
    }
  }
  v18 = v14;
  cp1 = skip_space(v28);
  input_column += cp1 - cp;
  if ( (unsigned int)my_strlcpy(buf2, cp1, 4096) > 0xFFF )
  {
    error("Command line too long.");
    return 0;
  }
  if ( security_level <= 1 )
  {
    v19 = strlen(buf2) + 1;
    v20 = v19 - 2;
    if ( (int)(v19 - 2) >= 0 )
    {
      v21 = (char *)&cp1 + v19 + 1;
      if ( buf2[v20] == 62 )
      {
LABEL_49:
        v23 = skip_space(&buf2[v20 + 1]);
        if ( !v20 || (v24 = v20 - 1, v25 = 1, buf2[v20 - 1] != 62) )
        {
          v24 = v20;
          v25 = 0;
        }
        buf2[v24] = 0;
        if ( v23 )
        {
          if ( v25 )
            v1 = (int)fopen(v23, "a");
          else
            v1 = (int)fopen(v23, "w");
          if ( !v1 )
          {
            error("Can't open redirected output file for writing.");
            return v1;
          }
          if ( gfp != stdout && gfp != stderr && gfp != default_out )
            fclose(gfp);
          gfp = (FILE *)v1;
          remove_trailing_spaces(buf2);
          pull_number = 1;
          repeat_flag = v29;
          v1 = com_list[v31].func(buf2);
          repeat_flag = 0;
          if ( gfp != default_out )
          {
            if ( gfp != stdout && gfp != stderr )
              fclose(gfp);
            gfp = default_out;
          }
          goto LABEL_72;
        }
      }
      else
      {
        while ( (--v20 & 0x80000000) == 0 )
        {
          v22 = *v21--;
          if ( v22 == 62 )
            goto LABEL_49;
        }
      }
    }
  }
  remove_trailing_spaces(buf2);
  pull_number = 1;
  repeat_flag = v29;
  v1 = com_list[v31].func(buf2);
  repeat_flag = 0;
LABEL_72:
  if ( !v1 && debug_level >= 0 )
    __printf_chk(1, "Command usage: %s %s\n", v18, com_list[v31].usage);
  return v1;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804F44B) --------------------------------------------------------
int __cdecl display_process(char *cp)
{
  int result; // eax
  const char *v2; // eax

  result = 0;
  if ( cp )
  {
    default_color();
    v2 = "-> ";
    if ( html_flag )
      v2 = "&mdash;&gt; ";
    input_column = __printf_chk(1, "%d%s", cur_equation + 1, v2);
    if ( html_flag )
      __printf_chk(1, "<b>%s</b>", cp);
    else
      __printf_chk(1, "%s", cp);
    if ( gfp != stdout && gfp != stderr )
      __fprintf_chk(gfp, 1, "%d%s%s", cur_equation + 1, "-> ", cp);
    set_error_level(cp);
    result = process(cp);
  }
  return result;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804F53B) --------------------------------------------------------
int __cdecl read_examples(char **cpp)
{
  char **v1; // esi
  char *v2; // eax
  char *v3; // ebx
  int result; // eax

  v1 = cpp;
  v2 = *cpp;
  if ( !*cpp )
    return 1;
  while ( 1 )
  {
    v3 = (char *)__strdup(v2);
    result = display_process(v3);
    if ( !result )
      break;
    free(v3);
    v2 = v1[1];
    ++v1;
    if ( !v2 )
      return 1;
  }
  return result;
}
// 8049284: using guessed type int __cdecl __strdup(_DWORD);

//----- (0804F580) --------------------------------------------------------
int __cdecl help_cmd(char *cp)
{
  char *v1; // edi
  char v2; // bl
  char *v3; // edx
  const com_type *v4; // ebx
  int v5; // esi
  const char *v6; // eax
  size_t v7; // ebx
  char v8; // al
  char *v9; // ecx
  int v11; // ebx
  int v12; // esi
  int v13; // ebx
  int v14; // esi
  const com_type *v15; // edi
  int i; // esi
  int j; // ebx
  const unsigned __int16 **v18; // [esp+20h] [ebp-28h]
  char *v19; // [esp+24h] [ebp-24h]
  int flag; // [esp+28h] [ebp-20h]
  size_t n; // [esp+2Ch] [ebp-1Ch]

  v1 = cp;
  v2 = *cp;
  if ( *cp )
  {
    v18 = __ctype_b_loc();
    v3 = cp;
    do
    {
      if ( ((*v18)[v2] & 0x2000) != 0 )
        break;
      v2 = *++v3;
    }
    while ( *v3 );
    v19 = v3;
    if ( v3 != cp )
    {
      flag = 0;
      while ( 1 )
      {
        v4 = com_list;
        v5 = 0;
        n = v19 - v1;
        do
        {
          if ( !strncasecmp(v1, v4->name, n) || (v6 = v4->secondary_name) != 0 && !strncasecmp(v1, v6, n) )
          {
            display_command(v5);
            flag = 1;
          }
          ++v5;
          ++v4;
        }
        while ( v5 != 42 );
        v7 = v19 - v1;
        if ( !flag )
          break;
        v1 = skip_space(v19);
        v8 = *v1;
        if ( *v1 )
        {
          v9 = v1;
          do
          {
            if ( ((*v18)[v8] & 0x2000) != 0 )
              break;
            v8 = *++v9;
          }
          while ( *v9 );
          v19 = v9;
          if ( v9 != v1 )
            continue;
        }
        return 1;
      }
      if ( !strncasecmp(v1, "examples", v19 - v1) )
        return read_examples(example_strings);
      if ( !strncasecmp(v1, "copyright", v7) || !strncasecmp(v1, "license", v7) )
      {
        __fprintf_chk(gfp, 1, "%s\n", "Copyright and License for Mathomatic");
        __fprintf_chk(gfp, 1, "%s\n", "------------------------------------\n");
        __fprintf_chk(gfp, 1, "%s", license_string);
        return 1;
      }
      if ( !strncasecmp(v1, "bugs", v7) )
      {
        __fprintf_chk(gfp, 1, "%s\n", "Report bugs on the Launchpad support website for Mathomatic:");
        __fprintf_chk(gfp, 1, "%s\n", "http://launchpad.net/mathomatic\n");
        __fprintf_chk(gfp, 1, "%s\n", "Please include the following information (from the version command):\n");
        return version_report();
      }
      if ( strncasecmp(v1, "usage", v7) )
      {
        if ( !strncasecmp(v1, "geometry", v7) )
        {
          __fprintf_chk(gfp, 1, "%s\n", "Commonly used standard (Euclidean) geometric formulas");
          __fprintf_chk(gfp, 1, "%s\n", "-----------------------------------------------------");
          __fprintf_chk(gfp, 1, "%s\n", "Triangle of base \"b\" and height \"h\":");
          __fprintf_chk(gfp, 1, "%s\n", "    area = b*h/2\n");
          __fprintf_chk(gfp, 1, "%s\n", "Rectangle of length \"l\" and width \"w\":");
          __fprintf_chk(gfp, 1, "%s\n", "    area = l*w                    perimeter = 2*l + 2*w\n");
          __fprintf_chk(gfp, 1, "%s\n", "Trapezoid of parallel sides \"a\" and \"b\", and \"d\" distance between them:");
          __fprintf_chk(gfp, 1, "%s\n", "    area = d*(a + b)/2\n");
          __fprintf_chk(gfp, 1, "%s\n", "Circle of radius \"r\":");
          __fprintf_chk(gfp, 1, "%s\n", "    area = pi*r^2                 perimeter = 2*pi*r\n");
          __fprintf_chk(gfp, 1, "%s\n", "Rectangular solid of length \"l\", width \"w\", and height \"h\":");
          __fprintf_chk(gfp, 1, "%s\n", "    volume = l*w*h                surface_area = 2*l*w + 2*l*h + 2*w*h\n");
          __fprintf_chk(gfp, 1, "%s\n", "Sphere of radius \"r\":");
          __fprintf_chk(gfp, 1, "%s\n", "    volume = 4/3*pi*r^3           surface_area = 4*pi*r^2\n");
          __fprintf_chk(gfp, 1, "%s\n", "Convex polygon of \"n\" sides, sum of all interior angles formula:");
          __fprintf_chk(gfp, 1, "%s\n", "    sum = (n - 2)*180 degrees     sum = (n - 2)*pi radians");
          return 1;
        }
        if ( !strncasecmp(v1, "expressions", v7) || !strncasecmp(v1, "equations", v7) )
        {
          __fprintf_chk(gfp, 1, "%s\n", "To enter an expression or equation, simply type it in at the prompt.");
          __fprintf_chk(gfp, 1, "%s\n", "Operators have precedence decreasing as indicated:\n");
          __fprintf_chk(gfp, 1, "%s\n", "    - negate (highest precedence)");
          __fprintf_chk(gfp, 1, "%s\n", "    ! factorial (gamma function)");
          __fprintf_chk(gfp, 1, "%s\n", "    ** or ^ power (exponentiation)");
          __fprintf_chk(gfp, 1, "%s\n", "    * multiply      / divide        % modulus       // integral divide");
          __fprintf_chk(gfp, 1, "%s\n", "    + add           - subtract");
          __fprintf_chk(gfp, 1, "%s\n", "    = equate (lowest precedence)\n");
          __fprintf_chk(gfp, 1, "%s\n", "Variables consist of any combination of letters, digits, and underscores (_).");
          __fprintf_chk(gfp, 1, "%s\n", "Predefined variables follow:\n");
          __fprintf_chk(gfp, 1, "%s\n", "    sign, sign1, sign2, ... - may only be +1 or -1");
          __fprintf_chk(gfp, 1, "%s\n", "    integer, integer1, ... - may only be an integer value\n");
          __fprintf_chk(gfp, 1, "%s\n", "Absolute value notation \"|x|\" and dual polarity \"+/-x\" are understood.");
          __fprintf_chk(gfp, 1, "%s\n", "Type \"help constants\" for information on entering constants.");
          return 1;
        }
        if ( !strncasecmp(v1, "constants", v7) )
        {
          __fprintf_chk(gfp, 1, "%s\n", "Constants are double precision floating point values with up to");
          __fprintf_chk(gfp, 1, "%s\n", "14 decimal digits accuracy.  They can be entered in standard, scientific,");
          __fprintf_chk(gfp, 1, "%s\n", "or hexadecimal notation.  Excepting named constants, constants always");
          __fprintf_chk(gfp, 1, "%s\n", "start with a decimal digit (0..9) or a period.\n");
          __fprintf_chk(gfp, 1, "%s\n", "Named constants follow:\n");
          __fprintf_chk(gfp, 1, "%s\n", "    e or e# - the universal constant e (2.7182818284...)");
          __fprintf_chk(gfp, 1, "%s\n", "    pi or pi# - the universal constant pi (3.1415926535...)");
          __fprintf_chk(gfp, 1, "%s\n", "    i or i# - the imaginary unit (square root of -1)");
          __fprintf_chk(gfp, 1, "%s\n", "The above constants may also be used anywhere variables are required.");
          __fprintf_chk(gfp, 1, "%s\n", "    inf - floating point infinity constant");
          __fprintf_chk(gfp, 1, "%s\n", "    nan - invalid floating point result (not enterable)\n");
          __fprintf_chk(gfp, 1, "The largest value of a constant is +/-%g\n", (double)1.797693134862316e308);
          __fprintf_chk(gfp, 1, "The smallest value of a constant is +/-%g\n", (double)2.225073858507201e-308);
          return 1;
        }
        if ( !is_all(v1) )
        {
          error("Unrecognized help topic or command.");
          return 0;
        }
        __fprintf_chk(gfp, 1, "%s\n", "Mathomatic Command Summary");
        __fprintf_chk(gfp, 1, "%s\n", "--------------------------");
        v13 = 3;
        v14 = 0;
        while ( 1 )
        {
          v13 += display_command(v14);
          if ( gfp == stdout && screen_rows && v13 >= screen_rows - 5 )
          {
            if ( !pause_cmd("") )
              return 0;
            v13 = 1;
          }
          if ( ++v14 == 42 )
          {
            __fprintf_chk(gfp, 1, "End of command list.  Total of %d different commands.\n", 42);
            return 1;
          }
        }
      }
      __fprintf_chk(gfp, 1, "%s\n", "Mathomatic Command Usage Syntax");
      __fprintf_chk(gfp, 1, "%s\n", "-------------------------------");
      v11 = 0;
      v12 = 3;
      do
      {
        __fprintf_chk(gfp, 1, "%s %s\n", com_list[v11].name, *(const char **)(v11 * 24 + 134696332));
        ++v12;
        if ( gfp == stdout && screen_rows && v12 >= screen_rows - 2 )
        {
          if ( !pause_cmd("") )
            return 0;
          v12 = 1;
        }
        ++v11;
      }
      while ( v11 != 42 );
      return 1;
    }
  }
  __fprintf_chk(gfp, 1, "%s\n", "Mathomatic is a Computer Algebra System (CAS) and calculator program.");
  __fprintf_chk(gfp, 1, "%s\n", "To see helpful interactive examples, type \"help examples\".");
  __fprintf_chk(gfp, 1, "%s\n", "Type \"help equations\" for help with entering expressions and equations.");
  __fprintf_chk(gfp, 1, "%s\n", "Type \"help all\" for a summary and syntax of all commands.");
  __fprintf_chk(gfp, 1, "%s\n", "Type \"help usage\" to display the syntax of all commands.");
  __fprintf_chk(gfp, 1, "%s\n", "\"help\" or \"?\" followed by a command name will give info on that command.");
  __fprintf_chk(gfp, 1, "%s\n", "Other help keywords: constants, geometry, copyright, license, bugs.\n");
  __fprintf_chk(gfp, 1, "These are the %d commands:\n", 42);
  v15 = com_list;
  for ( i = 0; i != 42; ++i )
  {
    if ( i == 5 * (i / 5) )
      __fprintf_chk(gfp, 1, "\n");
    for ( j = 15 - __fprintf_chk(gfp, 1, "%s", v15->name); j > 0; --j )
      __fprintf_chk(gfp, 1, " ");
    ++v15;
  }
  __fprintf_chk(gfp, 1, "%s\n", "\n\nTo select an equation space, type the equation number at the main prompt.");
  __fprintf_chk(gfp, 1, "%s\n", "To solve the current equation, type the variable name at the main prompt.");
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080502D0) --------------------------------------------------------
int __cdecl var_is_const(int v, double *dp)
{
  int result; // eax

  if ( v == 1 )
  {
    if ( dp )
    {
      *dp = 2.718281828459045;
      return 1;
    }
  }
  else
  {
    result = 0;
    if ( v != 2 )
      return result;
    if ( dp )
    {
      *dp = 3.141592653589793;
      return 1;
    }
  }
  return 1;
}

//----- (0805031B) --------------------------------------------------------
int __cdecl subst_constants(token_type *equation, int *np)
{
  int v3; // esi
  int modified; // [esp+Ch] [ebp-24h]
  double d[3]; // [esp+18h] [ebp-18h] BYREF

  modified = 0;
  if ( *np > 0 )
  {
    v3 = 0;
    do
    {
      if ( equation->kind == VARIABLE && var_is_const(equation->token.variable, d) )
      {
        equation->kind = CONSTANT;
        equation->token.constant = d[0];
        modified = 1;
      }
      v3 += 2;
      equation += 2;
    }
    while ( *np > v3 );
  }
  return modified;
}

//----- (0805037E) --------------------------------------------------------
int __cdecl my_strlcpy(char *dest, char *src, int n)
{
  unsigned int v3; // ecx
  int v4; // esi
  size_t v5; // ebx

  v3 = strlen(src) + 1;
  v4 = v3 - 1;
  v5 = n - 1;
  if ( (int)(v3 - 1) <= n - 1 )
    v5 = v3 - 1;
  memmove(dest, src, v5);
  dest[v5] = 0;
  return v4;
}

//----- (080503D7) --------------------------------------------------------
void __cdecl remove_trailing_spaces(char *cp)
{
  unsigned int v1; // ecx
  unsigned int v2; // edi
  int v3; // ebx
  const unsigned __int16 **v4; // eax
  char *v5; // edi

  v1 = strlen(cp) + 1;
  v2 = v1 - 1;
  v3 = v1 - 2;
  if ( (int)(v1 - 2) >= 0 )
  {
    v4 = __ctype_b_loc();
    v5 = &cp[v2];
    do
    {
      if ( ((*v4)[*(v5 - 1)] & 0x2000) == 0 )
        break;
      *--v5 = 0;
      --v3;
    }
    while ( v3 >= 0 );
  }
}

//----- (08050428) --------------------------------------------------------
void __cdecl set_error_level(char *cp)
{
  char *v1; // esi
  char *v2; // eax
  char v3; // bl
  const unsigned __int16 **v4; // eax

  v1 = cp;
  point_flag = 1;
  v2 = strpbrk(cp, accept);
  if ( v2 )
    *v2 = 0;
  remove_trailing_spaces(cp);
  v3 = *cp;
  if ( *cp )
  {
    v4 = __ctype_b_loc();
    do
    {
      if ( ((*v4)[v3] & 0x4000) == 0 )
        point_flag = 0;
      v3 = *++v1;
    }
    while ( *v1 );
  }
}

//----- (0805048F) --------------------------------------------------------
void __cdecl binary_parenthesize(token_type *p1, int n, int i)
{
  token_type *v3; // eax
  int v4; // ecx
  token_type *v5; // edx
  int v6; // eax
  token_type *v7; // edi
  int v8; // esi
  token_type *v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // eax
  token_type *v13; // esi
  token_type *v14; // edi
  int v15; // edx

  if ( n - 1 <= i || (n & 1) == 0 || (i & 1) == 0 )
    error_bug("Internal error in arguments to binary_parenthesize().");
  v3 = &p1[i];
  v4 = v3->level;
  v3->level = v4 + 1;
  v5 = v3 - 1;
  v6 = v3[-1].level;
  v5->level = v6 + 1;
  if ( v4 < v6 && i - 2 >= 0 )
  {
    v7 = &p1[i - 2];
    v8 = v7->level;
    if ( v4 < v8 )
    {
      v9 = &p1[i - 3];
      v10 = i - 2;
      do
      {
        v7->level = v8 + 1;
        if ( --v10 < 0 )
          break;
        v7 = v9;
        v8 = v9->level;
        --v9;
      }
      while ( v4 < v8 );
    }
  }
  v11 = p1[i + 1].level;
  p1[i + 1].level = v11 + 1;
  if ( v4 < v11 )
  {
    v12 = i + 2;
    if ( n > i + 2 )
    {
      v13 = &p1[v12];
      if ( v4 < v13->level )
      {
        v14 = &p1[i + 3];
        v15 = v13->level;
        do
        {
          v13->level = v15 + 1;
          if ( n <= ++v12 )
            break;
          v13 = v14;
          v15 = v14->level;
          ++v14;
        }
        while ( v4 < v15 );
      }
    }
  }
}

//----- (08050598) --------------------------------------------------------
void __cdecl give_priority(token_type *equation, int *np)
{
  int v2; // eax
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // ebx
  int v7; // eax
  int i; // ebx
  storage_type *v9; // [esp+1Ch] [ebp-1Ch]

  v2 = *np;
  if ( *np > 1 )
  {
    v3 = 1;
    do
    {
      if ( equation[v3].token.variable == 7 )
        binary_parenthesize(equation, v2, v3);
      v3 += 2;
      v2 = *np;
    }
    while ( *np > v3 );
  }
  if ( right_associative_power )
  {
    v6 = v2 - 2;
    if ( v2 - 2 > 0 )
    {
      v9 = &equation[v6].token;
      do
      {
        if ( v9->variable == 6 )
          binary_parenthesize(equation, *np, v6);
        v6 -= 2;
        v9 -= 4;
      }
      while ( v6 > 0 );
    }
  }
  else
  {
    v4 = *np;
    v5 = 1;
    if ( *np <= 1 )
      return;
    do
    {
      if ( equation[v5].token.variable == 6 )
        binary_parenthesize(equation, v4, v5);
      v5 += 2;
      v4 = *np;
    }
    while ( *np > v5 );
  }
  v7 = *np;
  for ( i = 1; *np > i; v7 = *np )
  {
    if ( equation[i].token.variable <= 9u && ((1 << equation[i].token.variable) & 0x238) != 0 )
      binary_parenthesize(equation, v7, i);
    i += 2;
  }
}

//----- (0805069F) --------------------------------------------------------
void __cdecl handle_negate(token_type *equation, int *np)
{
  token_type *v2; // ebx
  int v3; // esi

  if ( *np > 1 )
  {
    v2 = equation;
    v3 = 1;
    do
    {
      if ( v2[1].token.variable == 8 )
      {
        v2[1].token.variable = 3;
        if ( negate_highest_precedence )
          binary_parenthesize(equation, *np, v3);
      }
      v3 += 2;
      v2 += 2;
    }
    while ( *np > v3 );
  }
}

//----- (080506F5) --------------------------------------------------------
int __cdecl isvarchar(int ch_0)
{
  int result; // eax

  if ( ch_0 == 95 || ch_0 && strchr(special_variable_characters, ch_0) )
    result = 1;
  else
    result = ((*__ctype_b_loc())[ch_0] >> 10) & 1;
  return result;
}

//----- (0805073A) --------------------------------------------------------
char *__cdecl parse_var(int *vp, char *cp)
{
  int (*v2)(const char *, const char *); // eax
  char v4; // al
  int v5; // ebx
  char *v6; // eax
  const unsigned __int16 *v7; // ecx
  int v8; // eax
  char v9; // al
  int i; // ebx
  char *v11; // eax
  char *v12; // eax
  int v13; // ebx
  int v14; // eax
  size_t v15; // esi
  char *v16; // eax
  unsigned int v17; // eax
  unsigned int v18; // eax
  int (*strcmpfunc)(...); // [esp+1Ch] [ebp-8Ch]
  char *cp1; // [esp+20h] [ebp-88h] BYREF
  char buf[101]; // [esp+27h] [ebp-81h] BYREF
  unsigned int v22; // [esp+8Ch] [ebp-1Ch]

  v22 = __readgsdword(0x14u);
  v2 = strcmp;
  if ( !case_sensitive_flag )
    v2 = strcasecmp;
  strcmpfunc = (int (*)(...))v2;
  if ( !isvarchar(*cp) )
  {
    error("Invalid variable.");
    return 0;
  }
  cp1 = cp;
  v4 = *cp;
  v5 = 0;
  if ( *cp )
  {
    while ( isvarchar(v4) )
    {
      if ( v5 == 100 )
      {
LABEL_8:
        error("Variable name too long.");
        return 0;
      }
      v6 = cp1;
      buf[v5++] = *cp1;
      cp1 = v6 + 1;
      v4 = v6[1];
      if ( !v4 )
        break;
    }
  }
  buf[v5] = 0;
  if ( !strcasecmp(buf, "inf") )
  {
    error("Infinity cannot be used as a variable.");
    return 0;
  }
  if ( !strcasecmp(buf, "nan") )
  {
    error("NaN (Not a Number) cannot be directly entered.");
    return 0;
  }
  if ( strcmpfunc(buf, "sign") )
  {
    if ( !strncasecmp(cp, "i#", 2u) )
    {
      *vp = 3;
      return cp + 2;
    }
    if ( !strncasecmp(cp, "e#", 2u) )
    {
      *vp = 1;
      return cp + 2;
    }
    if ( !strncasecmp(cp, "pi#", 3u) )
    {
      *vp = 2;
      return cp + 3;
    }
    cp1 = cp;
    v9 = *cp;
    for ( i = 0; v9; v9 = v11[1] )
    {
      if ( !isvarchar(v9) && ((*__ctype_b_loc())[*cp1] & 0x800) == 0 )
        break;
      if ( i == 100 )
        goto LABEL_8;
      v11 = cp1;
      buf[i++] = *cp1;
      cp1 = v11 + 1;
    }
    buf[i] = 0;
    if ( !strcmpfunc(buf, &unk_8077991) )
    {
      *vp = 3;
      return cp1;
    }
    if ( !strcmpfunc(buf, "e") )
    {
      *vp = 1;
      return cp1;
    }
    if ( !strcmpfunc(buf, "pi") )
    {
      *vp = 2;
      return cp1;
    }
    if ( is_all(buf) )
    {
      error("\"all\" is a reserved word and may not be used as a variable name.");
      return 0;
    }
    v12 = var_names[0];
    v13 = 0;
    if ( var_names[0] )
    {
      while ( strcmpfunc(buf, v12) )
      {
        v12 = var_names[++v13];
        if ( !v12 )
          goto LABEL_42;
      }
      v14 = v13 + 65;
      if ( v13 != -65 )
      {
LABEL_47:
        *vp = v14;
        return cp1;
      }
    }
    else
    {
      v13 = 0;
    }
LABEL_42:
    if ( v13 > 7998 )
    {
      error("Maximum number of variable names reached.");
      __printf_chk(1, "Please restart or use \"clear all\".\n");
      return 0;
    }
    v15 = strlen(buf) + 1;
    v16 = (char *)malloc(v15);
    var_names[v13] = v16;
    if ( !v16 )
    {
      error("Out of memory (can't malloc(3) variable name).");
      return 0;
    }
    memmove(v16, buf, v15);
    v14 = v13 + 65;
    var_names[v13 + 1] = 0;
    goto LABEL_47;
  }
  v7 = *__ctype_b_loc();
  v8 = 4;
  if ( (v7[*cp1] & 0x800) != 0 )
  {
    v17 = strtol(cp1, &cp1, 10);
    if ( v17 > 0x3E )
    {
      error("Maximum subscript exceeded in special variable name.");
      return 0;
    }
    v18 = v17 + 1;
    sign_array[v18] = 1;
    v8 = (v18 << 14) + 4;
  }
  *vp = v8;
  return cp1;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08050BE0) --------------------------------------------------------
void __cdecl put_up_arrow(int cnt, char *cp)
{
  int v2; // ebx

  if ( isatty(0) && point_flag && !html_flag )
  {
    if ( input_column + cnt > 0 )
    {
      v2 = 0;
      do
      {
        __printf_chk(1, " ");
        ++v2;
      }
      while ( input_column + cnt > v2 );
    }
    __printf_chk(1, "^ ");
  }
  error(cp);
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08050C67) --------------------------------------------------------
char *__cdecl parse_section(token_type *equation, int *np, char *cp, int allow_space)
{
  char *v4; // eax
  char v5; // dl
  token_type *v6; // eax
  char *result; // eax
  int v8; // eax
  token_type *v9; // edx
  token_type *v10; // edx
  token_type *v11; // edx
  token_type *v12; // eax
  token_type *v13; // eax
  token_type *v14; // eax
  token_type *v15; // eax
  token_type *v16; // eax
  token_type *v17; // eax
  token_type *v18; // eax
  token_type *v19; // eax
  token_type *v20; // eax
  token_type *v21; // eax
  char *v22; // esi
  const unsigned __int16 **v23; // eax
  char v24; // dl
  token_type *v25; // eax
  int *v26; // ebx
  long double v27; // fst7
  token_type *v28; // eax
  token_type *v29; // eax
  char *v30; // ebx
  token_type *v31; // eax
  token_type *v32; // eax
  int abs_count; // [esp+1Ch] [ebp-5Ch]
  char *v34; // [esp+20h] [ebp-58h]
  int operand; // [esp+24h] [ebp-54h]
  int v36; // [esp+28h] [ebp-50h]
  int n; // [esp+2Ch] [ebp-4Ch]
  int v38; // [esp+34h] [ebp-44h]
  int abs_array[10]; // [esp+38h] [ebp-40h]

  v34 = cp;
  if ( !cp )
    return 0;
  abs_count = 0;
  operand = 0;
  v36 = 1;
  n = 0;
  while ( 1 )
  {
    if ( n > n_tokens - 10 )
      error_huge();
    v4 = cp;
    v5 = *cp;
    if ( *cp == 41 )
    {
LABEL_25:
      if ( --v36 <= 0 || abs_count > 0 && v36 < *(&v38 + abs_count) )
      {
        put_up_arrow(cp - v34, "Unmatched parenthesis: too many )");
        return 0;
      }
      if ( !operand )
        goto syntax_error;
      goto LABEL_88;
    }
    if ( v5 <= 41 )
      break;
    if ( v5 == 61 )
      goto p_out;
    if ( v5 > 61 )
    {
      if ( v5 == 123 )
      {
LABEL_22:
        if ( operand )
        {
          v6 = &equation[n];
          v6->level = v36;
          v6->kind = OPERATOR;
          v6->token.variable = 3;
          ++n;
          operand = 0;
        }
        ++v36;
        goto LABEL_88;
      }
      if ( v5 == 125 )
        goto LABEL_25;
    }
    else if ( v5 == 59 )
    {
      goto p_out;
    }
LABEL_33:
    operand = operand == 0;
    switch ( v5 )
    {
      case '!':
        if ( operand )
          goto syntax_error;
        if ( cp[1] == 33 && cp[2] != 33 )
          warning("Multifactorial not implemented, using x!! = (x!)!");
        v12 = &equation[n];
        v12->level = v36;
        v12->kind = OPERATOR;
        v12->token.variable = 7;
        ++v12;
        v12->level = v36;
        v12->kind = CONSTANT;
        v12->token.constant = 1.0;
        n += 2;
        operand = 1;
        break;
      case '%':
        if ( operand )
          goto syntax_error;
        v17 = &equation[n];
        v17->level = v36;
        v17->kind = OPERATOR;
        v17->token.variable = 5;
        ++n;
        break;
      case '*':
        if ( cp[1] == 42 )
        {
          ++cp;
parse_power:
          if ( operand )
            goto syntax_error;
          v13 = &equation[n];
          v13->level = v36;
          v13->kind = OPERATOR;
          v13->token.variable = 6;
          ++n;
        }
        else
        {
          if ( operand )
            goto syntax_error;
          v14 = &equation[n];
          v14->level = v36;
          v14->kind = OPERATOR;
          v14->token.variable = 3;
          ++n;
        }
        break;
      case '+':
      case '-':
        if ( !operand )
        {
          v18 = &equation[n];
          v18->level = v36;
          v18->kind = OPERATOR;
          v18->token.variable = (*cp != 43) + 1;
          ++n;
        }
        if ( !memcmp(cp, "+/-", 3u) )
        {
          v19 = &equation[n];
          v19->level = v36;
          v19->kind = VARIABLE;
          next_sign((int *)&v19->token);
          v20 = &equation[n + 1];
          v20->level = v36;
          v20->kind = OPERATOR;
          v20->token.variable = 3;
          n += 2;
          cp += 2;
          operand = 0;
        }
        else if ( operand )
        {
LABEL_68:
          v22 = cp;
          if ( *cp != 45
            || negate_highest_precedence
            && ((v23 = __ctype_b_loc(), v24 = v22[1], ((*v23)[v24] & 0x800) != 0) || v24 == 46) )
          {
            v26 = __errno_location();
            *v26 = 0;
            v27 = strtod(v22, &cp);
            if ( v22 == cp )
              goto syntax_error;
            if ( *v26 )
            {
              put_up_arrow(v22 - v34, "Constant out of range.");
              return 0;
            }
            v28 = &equation[n];
            v28->kind = CONSTANT;
            v28->token.constant = v27;
            v28->level = v36;
            ++n;
            --cp;
          }
          else
          {
            v25 = &equation[n];
            v25->kind = CONSTANT;
            v25->token.constant = -1.0;
            v25->level = v36;
            ++v25;
            v25->kind = OPERATOR;
            v25->token.variable = 8;
            v25->level = v36;
            n += 2;
            operand = 0;
          }
        }
        break;
      case '.':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        if ( !operand )
        {
          v21 = &equation[n];
          v21->level = v36;
          v21->kind = OPERATOR;
          v21->token.variable = 3;
          ++n;
          operand = 1;
        }
        goto LABEL_68;
      case '/':
        if ( operand )
          goto syntax_error;
        if ( cp[1] == 47 )
        {
          ++cp;
          v15 = &equation[n];
          v15->level = v36;
          v15->kind = OPERATOR;
          v15->token.variable = 9;
        }
        else
        {
          v16 = &equation[n];
          v16->level = v36;
          v16->kind = OPERATOR;
          v16->token.variable = 4;
        }
        ++n;
        break;
      case '^':
        goto parse_power;
      case '|':
        if ( operand )
        {
          if ( abs_count > 9 )
          {
            error("Too many nested absolute values.");
            return 0;
          }
          v36 += 3;
          abs_array[abs_count++] = v36;
        }
        else
        {
          if ( abs_count <= 0 )
            goto syntax_error;
          v8 = abs_array[--abs_count];
          if ( v8 != v36 )
            goto syntax_error;
          v9 = &equation[n];
          v9->level = v8 - 1;
          v9->kind = OPERATOR;
          v9->token.variable = 6;
          ++v9;
          v9->level = v8 - 1;
          v9->kind = CONSTANT;
          v9->token.constant = 2.0;
          v10 = &equation[n + 2];
          v10->level = v8 - 2;
          v10->kind = OPERATOR;
          v10->token.variable = 6;
          v11 = &equation[n + 3];
          v11->level = v8 - 2;
          v11->kind = CONSTANT;
          v11->token.constant = 0.5;
          n += 4;
          v36 = v8 - 3;
        }
        operand = operand == 0;
        break;
      default:
        if ( !isvarchar(v5) )
        {
          put_up_arrow(cp - v34, "Unrecognized character.");
          return 0;
        }
        if ( !operand )
        {
          v29 = &equation[n];
          v29->level = v36;
          v29->kind = OPERATOR;
          v29->token.variable = 3;
          ++n;
          operand = 1;
        }
        v30 = cp;
        if ( strncasecmp(cp, "inf", 3u) || isvarchar(v30[3]) )
        {
          v32 = &equation[n];
          v32->kind = VARIABLE;
          cp = parse_var((int *)&v32->token, cp);
          if ( !cp )
            return 0;
        }
        else
        {
          v31 = &equation[n];
          v31->kind = CONSTANT;
          v31->token.constant = INFINITY;
          cp += 3;
        }
        if ( *cp == 40 )
        {
          put_up_arrow(v30 - v34, "Named functions currently not implemented, except when using m4.");
          return 0;
        }
        --cp;
        equation[n++].level = v36;
        break;
    }
LABEL_88:
    ++cp;
  }
  if ( v5 == 32 )
    goto LABEL_31;
  if ( v5 > 32 )
  {
    if ( v5 == 40 )
      goto LABEL_22;
    goto LABEL_33;
  }
  if ( v5 == 9 )
  {
LABEL_31:
    if ( !allow_space )
      goto p_out;
    goto LABEL_88;
  }
  if ( v5 != 10 && v5 )
    goto LABEL_33;
p_out:
  if ( abs_count || n && !operand )
  {
syntax_error:
    put_up_arrow(cp - v34, "Syntax error.");
    result = 0;
  }
  else if ( v36 == 1 )
  {
    if ( v5 == 61 )
    {
      do
        cp = ++v4;
      while ( *v4 == 61 );
    }
    *np = n;
    if ( n )
    {
      handle_negate(equation, np);
      give_priority(equation, np);
      organize(equation, np);
    }
    result = cp;
    input_column += cp - v34;
  }
  else
  {
    put_up_arrow(cp - v34, "Unmatched parenthesis: missing )");
    result = 0;
  }
  return result;
}

//----- (080513EC) --------------------------------------------------------
void __cdecl str_tolower(char *cp)
{
  char *v1; // ebx
  char v2; // si
  const unsigned __int16 **v3; // edi

  v1 = cp;
  if ( cp )
  {
    v2 = *cp;
    if ( *cp )
    {
      v3 = __ctype_b_loc();
      do
      {
        if ( ((*v3)[v2] & 0x100) != 0 )
          *v1 = (*__ctype_tolower_loc())[v2];
        v2 = *++v1;
      }
      while ( *v1 );
    }
  }
}

//----- (0805143A) --------------------------------------------------------
char *__cdecl parse_expr(token_type *equation, int *np, char *cp)
{
  char *v3; // ebx
  char *v4; // eax
  char *v5; // esi
  char v6; // al
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  char *v10; // eax
  char *cp2[4]; // [esp+1Ch] [ebp-1Ch] BYREF

  v3 = cp;
  if ( cp )
  {
    if ( !case_sensitive_flag )
      str_tolower(cp);
    v4 = skip_space(cp);
    if ( *v4 == 35 )
    {
      v5 = v4 + 1;
      v6 = v4[1];
      if ( v6 == 43 || v6 == 45 )
        v7 = cur_equation + decstrtol(v5, cp2);
      else
        v7 = decstrtol(v5, cp2) - 1;
      if ( v5 == cp2[0] || *cp2[0] )
      {
        error("Error parsing equation space number.");
        v3 = 0;
      }
      else if ( v7 >= 0 && v7 < n_equations && (v8 = n_lhs[v7], v8 > 0) )
      {
        v9 = n_rhs[v7];
        if ( v9 )
        {
          memmove(equation, rhs[v7], 16 * v9);
          *np = n_rhs[v7];
        }
        else
        {
          memmove(equation, lhs[v7], 16 * v8);
          *np = n_lhs[v7];
        }
        list_proc(equation, *np, 0);
        __fprintf_chk(gfp, 1, "\n");
        v3 = cp2[0];
      }
      else
      {
        error("No expression available in specified equation space.");
        v3 = 0;
      }
    }
    else
    {
      v10 = parse_section(equation, np, cp, 1);
      v3 = v10;
      if ( v10 && extra_characters(v10) )
        v3 = 0;
    }
  }
  return v3;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080515D9) --------------------------------------------------------
char *__cdecl parse_equation(int n, char *cp)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax

  v2 = cp;
  if ( cp )
  {
    if ( !case_sensitive_flag )
      str_tolower(cp);
    v3 = parse_section(lhs[n], &n_lhs[n], cp, 1);
    v2 = v3;
    if ( v3 )
    {
      v4 = parse_section(rhs[n], (int *)(4 * n + 134715712), v3, 1);
      v2 = v4;
      if ( v4 )
      {
        if ( extra_characters(v4) )
          v2 = 0;
      }
    }
  }
  return v2;
}

//----- (08051690) --------------------------------------------------------
int __cdecl vcmp(sort_type *p1, sort_type *p2)
{
  return p2->count - p1->count;
}

//----- (080516A1) --------------------------------------------------------
int __cdecl quit_cmd(char *cp)
{
  int v1; // ebx

  v1 = 0;
  if ( !*cp || (v1 = decstrtol(cp, &cp), !extra_characters(cp)) )
    exit_program(v1);
  return 0;
}

//----- (080516E8) --------------------------------------------------------
int __cdecl fraction_cmd(char *cp)
{
  int v1; // eax
  int j; // [esp+18h] [ebp-10h] BYREF
  int i[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( !get_range_eol(&cp, i, &j) )
    return 0;
  v1 = i[0];
  if ( i[0] <= j )
  {
    while ( 1 )
    {
      if ( n_lhs[v1] )
      {
        simple_frac_side(lhs[v1], &n_lhs[v1]);
        simple_frac_side(rhs[i[0]], &n_rhs[i[0]]);
        if ( !return_result(i[0]) )
          break;
      }
      v1 = i[0] + 1;
      i[0] = v1;
      if ( j < v1 )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (0805178A) --------------------------------------------------------
int __cdecl unfactor_cmd(char *cp)
{
  int v1; // esi
  char *v2; // ebx
  int v3; // edx
  int result; // eax
  int v5; // eax
  int v6; // eax
  int power_flag; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  int j; // [esp+28h] [ebp-20h] BYREF
  int i[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  power_flag = 0;
  v8 = 0;
  v1 = 0;
  while ( 1 )
  {
    v2 = cp;
    if ( !strncasecmp(cp, "quick", 4u) )
    {
      v1 = 1;
      goto LABEL_9;
    }
    if ( strncasecmp(v2, "fraction", 4u) && strncasecmp(v2, "fully", 4u) )
      break;
    v8 = 1;
LABEL_9:
    cp = skip_param(v2);
  }
  if ( !strncasecmp(v2, "power", 4u) )
  {
    power_flag = 1;
    goto LABEL_9;
  }
  v3 = get_range_eol(&cp, i, &j);
  result = 0;
  if ( v3 )
  {
    partial_flag = v8 == 0;
    if ( power_flag )
    {
      v6 = i[0];
      if ( i[0] > j )
        goto LABEL_37;
      while ( 1 )
      {
        if ( n_lhs[v6] )
        {
          if ( v1 )
            uf_power(lhs[v6], &n_lhs[v6]);
          else
            uf_allpower(lhs[v6], &n_lhs[v6]);
          elim_loop(lhs[i[0]], &n_lhs[i[0]]);
          if ( n_rhs[i[0]] )
          {
            if ( v1 )
              uf_power(rhs[i[0]], &n_rhs[i[0]]);
            else
              uf_allpower(rhs[i[0]], &n_rhs[i[0]]);
            elim_loop(rhs[i[0]], &n_rhs[i[0]]);
          }
          result = return_result(i[0]);
          if ( !result )
            break;
        }
        v6 = i[0] + 1;
        i[0] = v6;
        if ( j < v6 )
          goto LABEL_37;
      }
      partial_flag = 1;
    }
    else
    {
      v5 = i[0];
      if ( j >= i[0] )
      {
        while ( 1 )
        {
          if ( n_lhs[v5] )
          {
            if ( v1 )
            {
              uf_tsimp(lhs[v5], &n_lhs[v5]);
              if ( n_rhs[i[0]] )
                uf_tsimp(rhs[i[0]], &n_rhs[i[0]]);
            }
            else
            {
              uf_simp(lhs[v5], &n_lhs[v5]);
              if ( n_rhs[i[0]] )
                uf_simp(rhs[i[0]], &n_rhs[i[0]]);
            }
            result = return_result(i[0]);
            if ( !result )
              break;
          }
          v5 = i[0] + 1;
          i[0] = v5;
          if ( j < v5 )
            goto LABEL_37;
        }
        partial_flag = 1;
      }
      else
      {
LABEL_37:
        partial_flag = 1;
        result = 1;
      }
    }
  }
  return result;
}

//----- (08051A6A) --------------------------------------------------------
int __cdecl skip_no(char **cpp)
{
  int result; // eax
  int v2; // edx

  if ( strcmp_tospace(*cpp, "no")
    && strcmp_tospace(*cpp, "not")
    && strcmp_tospace(*cpp, "off")
    && strcmp_tospace(*cpp, "false") )
  {
    if ( !strcmp_tospace(*cpp, "yes")
      || !strcmp_tospace(*cpp, (char *)"on")
      || (v2 = strcmp_tospace(*cpp, "true"), result = 0, !v2) )
    {
      *cpp = skip_param(*cpp);
      result = 0;
    }
  }
  else
  {
    *cpp = skip_param(*cpp);
    result = 1;
  }
  return result;
}

//----- (08051B3F) --------------------------------------------------------
int __cdecl factor_cmd(char *cp)
{
  int v1; // ebx
  char v2; // bl
  char *v3; // eax
  char v4; // si
  char *v5; // ebx
  token_type **v6; // edi
  token_type **v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int *v10; // esi
  token_type **v11; // edi
  int v12; // ebx
  int *k; // esi
  int *v15; // [esp+10h] [ebp-1048h]
  int *v16; // [esp+14h] [ebp-1044h]
  int *v17; // [esp+14h] [ebp-1044h]
  int *np; // [esp+18h] [ebp-1040h]
  int *npa; // [esp+18h] [ebp-1040h]
  char *cp_start; // [esp+1Ch] [ebp-103Ch]
  char *cp_starta; // [esp+1Ch] [ebp-103Ch]
  int *cp_startb; // [esp+1Ch] [ebp-103Ch]
  double d; // [esp+20h] [ebp-1038h]
  int da; // [esp+20h] [ebp-1038h]
  int *db; // [esp+20h] [ebp-1038h]
  char *cp_0; // [esp+2Ch] [ebp-102Ch] BYREF
  int v; // [esp+30h] [ebp-1028h] BYREF
  int j; // [esp+34h] [ebp-1024h] BYREF
  int i; // [esp+38h] [ebp-1020h] BYREF
  char buf[4096]; // [esp+3Ch] [ebp-101Ch] BYREF
  unsigned int v31; // [esp+103Ch] [ebp-1Ch]

  cp_0 = cp;
  v31 = __readgsdword(0x14u);
  cp_start = cp;
  if ( !strcmp_tospace(cp, "number") )
  {
    cp_0 = skip_param(cp_0);
    goto LABEL_11;
  }
  if ( !strcmp_tospace(cp_0, "numbers") )
  {
    repeat_flag = 1;
    cp_0 = skip_param(cp_0);
    goto LABEL_11;
  }
  v1 = 0;
  if ( !strcmp_tospace(cp_0, "power") )
  {
    cp_0 = skip_param(cp_0);
    LOBYTE(v1) = 1;
  }
  if ( !get_range(&cp_0, &i, &j) )
  {
    if ( *cp_0 == 45 || (v2 = *cp_0, ((*__ctype_b_loc())[v2] & 0x800) != 0) )
    {
      __printf_chk(1, "Factoring integers on command line instead:\n");
      while ( 1 )
      {
LABEL_11:
        if ( *cp_0 )
          goto LABEL_29;
retry:
        my_strlcpy(prompt_str, "Enter integers to factor: ", 80);
        v3 = get_string(buf, 4096);
        cp_start = v3;
        cp_0 = v3;
        if ( !v3 )
          break;
        if ( !*v3 )
          return 1;
LABEL_29:
        while ( 1 )
        {
          v5 = cp_0;
          if ( !*cp_0 )
            break;
          d = strtod(cp_0, &cp_0);
          if ( v5 == cp_0 )
            goto LABEL_16;
          cp_0 = skip_space(cp_0);
          if ( *cp_0 )
          {
            v4 = *cp_0;
            if ( ((*__ctype_b_loc())[v4] & 0x800) == 0 )
            {
              input_column = &v5[input_column] - cp_start;
              cp_0 = parse_expr(tes, &n_tes, v5);
              if ( !cp_0 )
                goto retry;
              if ( n_tes <= 0 )
                return 1;
              calc_simp(tes, &n_tes);
              if ( n_tes != 1 || tes->kind )
              {
LABEL_16:
                error("Integer expected.");
                goto retry;
              }
              d = tes->token.constant;
            }
          }
          cp_0 = skip_space(cp_0);
          if ( !factor_one(d) )
          {
            error("Number too large to factor or not a non-zero integer.");
            goto retry;
          }
          display_unique();
          if ( is_prime() )
            __fprintf_chk(gfp, 1, "Prime number!\n");
        }
        if ( !repeat_flag )
          return 1;
      }
    }
    return 0;
  }
  if ( v1 )
  {
    if ( extra_characters(cp_0) )
      return 0;
    da = i;
    if ( i <= j )
    {
      cp_starta = (char *)&n_lhs[i];
      v15 = &n_rhs[i];
      v6 = &rhs[i];
      v16 = v15;
      v7 = (token_type **)(4 * i + 134752832);
      for ( np = (int *)cp_starta; ; ++np )
      {
        if ( *(_DWORD *)cp_starta )
        {
          factor_power(*v7, np);
          do
            simp_loop(*v7, np);
          while ( factor_power(*v7, np) );
          if ( *v15 )
          {
            factor_power(*v6, v16);
            do
              simp_loop(*v6, v16);
            while ( factor_power(*v6, v16) );
          }
          if ( !return_result(da) )
            break;
        }
        ++da;
        cp_starta += 4;
        ++v15;
        ++v6;
        ++v16;
        ++v7;
        if ( j < da )
          return 1;
      }
      return 0;
    }
  }
  else
  {
    do
    {
      v = 0;
      if ( *cp_0 )
      {
        cp_0 = parse_var2(&v, cp_0);
        if ( !cp_0 )
          return 0;
        if ( v )
        {
          v8 = i;
          if ( j < i )
          {
LABEL_68:
            warning("Variable not found.");
          }
          else
          {
            while ( !var_in_equation(v8, v) )
            {
              if ( j < ++v8 )
                goto LABEL_68;
            }
          }
        }
      }
      v9 = i;
      if ( j >= i )
      {
        v10 = &n_lhs[i];
        v11 = &lhs[i];
        cp_startb = v10;
        db = &n_rhs[i];
        v17 = (int *)(4 * i + 134753248);
        npa = db;
        do
        {
          if ( *v10 )
          {
            simpv_side(*v11, cp_startb, v);
            if ( *db )
              simpv_side((token_type *)*v17, npa, v);
          }
          ++v9;
          ++v10;
          ++v11;
          ++cp_startb;
          ++db;
          ++v17;
          ++npa;
        }
        while ( j >= v9 );
      }
    }
    while ( *cp_0 );
    v12 = i;
    if ( j >= i )
    {
      for ( k = &n_lhs[i]; !*k || return_result(v12); ++k )
      {
        if ( j < ++v12 )
          return 1;
      }
      return 0;
    }
  }
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08052146) --------------------------------------------------------
int __cdecl echo_cmd(char *cp)
{
  __fprintf_chk(gfp, 1, "%s\n", cp);
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08052177) --------------------------------------------------------
void __cdecl output_options(FILE *ofp)
{
  if ( ofp )
  {
    __fprintf_chk(ofp, 1, "precision = %d digits\n", precision);
    if ( !autosolve )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "autosolve\n");
    if ( !autocalc )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "autocalc\n");
    if ( !autoselect )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "autoselect\n");
    __fprintf_chk(ofp, 1, "debug_level = %d\n", debug_level);
    if ( !case_sensitive_flag )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "case_sensitive\n");
    if ( !color_flag )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "color\n");
    if ( !bold_colors )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "bold_colors\n");
    if ( !display2d )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "display2d\n");
    if ( !preserve_surds )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "preserve_surds\n");
    if ( !rationalize_denominators )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "rationalize_denominators\n");
    __fprintf_chk(ofp, 1, "modulus_mode = %d\n", modulus_mode);
    __fprintf_chk(ofp, 1, "finance = %d\n", finance_option);
    if ( !factor_int_flag )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "factor_integers\n");
    if ( !right_associative_power )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "right_associative_power\n");
    if ( !negate_highest_precedence )
      __fprintf_chk(ofp, 1, "no ");
    __fprintf_chk(ofp, 1, "negate_highest_precedence\n");
    __fprintf_chk(ofp, 1, "special_variable_characters = %s\n", special_variable_characters);
  }
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080524DF) --------------------------------------------------------
int save_set_options()
{
  int result; // eax
  FILE *v1; // eax
  FILE *v2; // ebx

  if ( rc_file[0] )
  {
    v1 = fopen(rc_file, "w");
    v2 = v1;
    if ( v1 )
    {
      __fprintf_chk(v1, 1, "; Mathomatic set options loaded at startup.\n");
      __fprintf_chk(v2, 1, "; This file can be edited.\n\n");
      output_options(v2);
      if ( fclose(v2) )
      {
        error("Error saving set options.");
        result = 0;
      }
      else
      {
        __printf_chk(1, "All options saved in startup file \"%s\".\n", rc_file);
        result = 1;
      }
    }
    else
    {
      error("Unable to write to set options startup file.");
      result = 0;
    }
  }
  else
  {
    error("Set options startup file name not set.");
    result = 0;
  }
  return result;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (080525B0) --------------------------------------------------------
int version_report()
{
  __fprintf_chk(gfp, 1, "Mathomatic version %s\n", "15.1.1");
  __fprintf_chk(gfp, 1, "Compile-time defines used: ");
  __fprintf_chk(gfp, 1, "UNIX ");
  __fprintf_chk(gfp, 1, "READLINE ");
  __fprintf_chk(gfp, 1, "\n\nThe current expression array size is %d tokens,\n", n_tokens);
  __fprintf_chk(gfp, 1, "making the maximum memory usage %ld kilobytes.\n", 3296 * n_tokens / 0x3E8u);
  __fprintf_chk(gfp, 1, "The current security level is %d.\n", security_level);
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080526BA) --------------------------------------------------------
int __cdecl version_cmd(char *cp)
{
  int v1; // ebx

  v1 = version_report();
  __fprintf_chk(gfp, 1, "\nMathomatic is GNU LGPL version 2.1 licensed software,\n");
  __fprintf_chk(gfp, 1, "meaning it is free software that comes with no warranty.\n");
  __fprintf_chk(gfp, 1, "Type \"help copyright\" for the copyright and license.\n");
  __fprintf_chk(gfp, 1, "\nThe newest version of Mathomatic is always available at\n");
  __fprintf_chk(gfp, 1, "the Mathomatic website: http://mathomatic.org\n");
  __fprintf_chk(gfp, 1, "Feedback and contributions are welcomed.\n");
  return v1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0805277E) --------------------------------------------------------
int __cdecl copy_cmd(char *cp)
{
  int k; // eax
  int v2; // ebx
  int v3; // edi
  int *v4; // edx
  char *v5; // esi
  char *v6; // ecx
  int v7; // eax
  int v8; // edi
  char *cp_0; // [esp+1Ch] [ebp-8Ch] BYREF
  int j; // [esp+20h] [ebp-88h] BYREF
  int i; // [esp+24h] [ebp-84h] BYREF
  char exists[100]; // [esp+28h] [ebp-80h] BYREF
  unsigned int v14; // [esp+8Ch] [ebp-1Ch]

  cp_0 = cp;
  v14 = __readgsdword(0x14u);
  if ( !get_range_eol(&cp_0, &i, &j) )
    return 0;
  for ( k = 0; k != 100; ++k )
    exists[k] = 0;
  v2 = i;
  v3 = j;
  if ( i <= j )
  {
    v4 = &n_lhs[i];
    v5 = &exists[i];
    v6 = &exists[i];
    v7 = i;
    do
    {
      if ( *v4 > 0 )
        *v6 = 1;
      ++v7;
      ++v4;
      ++v6;
    }
    while ( v7 <= v3 );
    while ( 1 )
    {
      if ( *v5 )
      {
        v8 = next_espace();
        copy_espace(v2, v8);
        if ( !return_result(v8) )
          break;
      }
      ++v2;
      ++v5;
      if ( j < v2 )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (08052868) --------------------------------------------------------
int __cdecl replace_cmd(char *cp)
{
  int v1; // edi
  int *v2; // ebx
  char *v3; // esi
  int v5; // ebx
  token_type *v6; // eax
  int v7; // ecx
  int v8; // edx
  token_type *v9; // eax
  int v10; // edx
  int v11; // ecx
  int k; // eax
  int v13; // edx
  int j; // eax
  char *v15; // eax
  int v16; // edx
  int v17; // eax
  token_type *v18; // edx
  token_type *v19; // edx
  int v20; // ecx
  int v21; // eax
  token_type *v22; // edx
  int v23; // ecx
  int v24; // eax
  int v25; // eax
  char *v26; // [esp+2Ch] [ebp-FDCh]
  int v27; // [esp+34h] [ebp-FD4h]
  int i; // [esp+38h] [ebp-FD0h]
  int last_v; // [esp+3Ch] [ebp-FCCh]
  int va[1000]; // [esp+4Ch] [ebp-FBCh] BYREF
  int n[7]; // [esp+FECh] [ebp-1Ch] BYREF

  if ( current_not_defined() )
    return 0;
  i = cur_equation;
  if ( *cp )
  {
    v2 = va;
    v1 = 0;
    v3 = cp;
    while ( strcmp_tospace(v3, "with") )
    {
      if ( v1 == 1000 )
      {
        error("Too many variables specified.");
        return 0;
      }
      v3 = parse_var2(v2, v3);
      if ( !v3 )
        return 0;
      if ( !var_in_equation(i, *v2) )
      {
        error("Variable not found.");
        return 0;
      }
      ++v1;
      ++v2;
      if ( !*v3 )
      {
        v26 = v3;
        goto LABEL_15;
      }
    }
    v26 = v3;
    if ( !v1 )
    {
      error("No variables specified.");
      return 0;
    }
  }
  else
  {
    v26 = cp;
    v1 = 0;
  }
LABEL_15:
  n_tlhs = n_lhs[i];
  memmove(tlhs, lhs[i], 16 * n_tlhs);
  n_trhs = n_rhs[i];
  memmove(trhs, rhs[i], 16 * n_trhs);
  for ( last_v = 0; ; last_v = v5 )
  {
    v27 = n_lhs[i];
    v5 = -1;
    if ( v27 > 0 )
    {
      v6 = lhs[i];
      v7 = -1;
      v8 = 0;
      while ( 1 )
      {
        if ( v6->kind == VARIABLE && (v5 = v6->token.variable, last_v < v5) )
        {
          if ( v7 != -1 && v5 > v7 )
            v5 = v7;
        }
        else
        {
          v5 = v7;
        }
        v8 += 2;
        v6 += 2;
        if ( v8 >= v27 )
          break;
        v7 = v5;
      }
    }
    if ( n_rhs[i] > 0 )
    {
      v9 = rhs[i];
      v10 = 0;
      while ( 1 )
      {
        if ( v9->kind == VARIABLE && (v11 = v9->token.variable, last_v < v11) )
        {
          if ( v5 != -1 && v11 > v5 )
            v11 = v5;
        }
        else
        {
          v11 = v5;
        }
        v10 += 2;
        v9 += 2;
        if ( n_rhs[i] <= v10 )
          break;
        v5 = v11;
      }
      v5 = v11;
    }
    if ( v5 == -1 )
      break;
    if ( !v1 )
      goto LABEL_57;
    if ( v1 > 0 )
    {
      v13 = 0;
      for ( j = 0; j != v1; ++j )
      {
        if ( va[j] == v5 )
          v13 = 1;
      }
      if ( v13 )
      {
        if ( *v26 )
        {
          if ( strcmp_tospace(v26, "with") )
            return 0;
          v15 = skip_param(v26);
          input_column += v15 - cp;
          if ( !parse_expr(scratch, n, v15) || n[0] <= 0 )
            return 0;
          goto LABEL_59;
        }
LABEL_57:
        list_var(v5, 0);
        __snprintf_chk(prompt_str, 80, 1, 80, "Enter %s: ", var_str);
        if ( !get_expr(scratch, n) )
          continue;
        v16 = n[0];
        if ( n[0] > 0 )
        {
LABEL_59:
          v17 = 0;
          do
          {
            v18 = &scratch[v17];
            if ( v18->kind == VARIABLE )
              v18->token.variable = -v18->token.variable;
            v17 += 2;
            v16 = n[0];
          }
          while ( n[0] > v17 );
        }
        subst_var_with_exp(tlhs, &n_tlhs, scratch, v16, v5);
        subst_var_with_exp(trhs, &n_trhs, scratch, n[0], v5);
        continue;
      }
    }
  }
  for ( k = 0; n_tlhs > k; k += 2 )
  {
    v19 = &tlhs[k];
    if ( v19->kind == VARIABLE )
    {
      v20 = v19->token.variable;
      if ( v20 < 0 )
        v19->token.variable = -v20;
    }
  }
  if ( n_trhs > 0 )
  {
    v21 = 0;
    do
    {
      v22 = &trhs[v21];
      if ( v22->kind == VARIABLE )
      {
        v23 = v22->token.variable;
        if ( v23 < 0 )
          v22->token.variable = -v23;
      }
      v21 += 2;
    }
    while ( n_trhs > v21 );
  }
  v24 = n_tlhs;
  n_lhs[i] = n_tlhs;
  memmove(lhs[i], tlhs, 16 * v24);
  v25 = n_trhs;
  n_rhs[i] = n_trhs;
  memmove(rhs[i], trhs, 16 * v25);
  simp_equation(i);
  return return_result(i);
}
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08052D39) --------------------------------------------------------
int __cdecl approximate_cmd(char *cp)
{
  char *v1; // ebx
  int k; // eax
  int j; // [esp+18h] [ebp-20h] BYREF
  int i[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  while ( 1 )
  {
    v1 = cp;
    if ( !get_range(&cp, i, &j) )
      return 0;
    if ( *cp && v1 == cp )
    {
      error("Invalid argument.");
      return 0;
    }
    for ( k = i[0]; j >= k; i[0] = k )
    {
      if ( n_lhs[k] )
      {
        subst_constants(lhs[k], &n_lhs[k]);
        subst_constants(rhs[i[0]], &n_rhs[i[0]]);
        approximate_roots = 1;
        simp_equation(i[0]);
        factorv(lhs[i[0]], &n_lhs[i[0]], 3);
        if ( n_rhs[i[0]] )
          factorv(rhs[i[0]], &n_rhs[i[0]], 3);
        approximate_roots = 0;
        if ( !return_result(i[0]) )
          return 0;
      }
      k = i[0] + 1;
    }
    if ( !*cp )
      return 1;
  }
}

//----- (08052E8C) --------------------------------------------------------
int __cdecl variables_cmd(char *cp)
{
  int v1; // edx
  int result; // eax
  int *v3; // ebx
  int *v4; // esi
  int v5; // edi
  int v6; // ecx
  token_type *v7; // edx
  token_type *v8; // eax
  int v9; // edx
  int v10; // ebx
  int v11; // esi
  int v12; // edi
  int v13; // eax
  _DWORD *v14; // edx
  int v15; // ecx
  _DWORD *v16; // edx
  int v17; // edi
  int v18; // ecx
  int v19; // esi
  int k; // ebx
  int v21; // eax
  int imag_flag; // [esp+18h] [ebp-1F90h]
  int v23; // [esp+1Ch] [ebp-1F8Ch]
  int int_flag; // [esp+20h] [ebp-1F88h]
  int vc; // [esp+24h] [ebp-1F84h]
  int v26; // [esp+28h] [ebp-1F80h]
  int v27; // [esp+2Ch] [ebp-1F7Ch]
  int cnt; // [esp+30h] [ebp-1F78h]
  token_type **v29; // [esp+38h] [ebp-1F70h]
  int v30; // [esp+38h] [ebp-1F70h]
  token_type **last_v; // [esp+3Ch] [ebp-1F6Ch]
  int last_va; // [esp+3Ch] [ebp-1F6Ch]
  sort_type va[1000]; // [esp+48h] [ebp-1F60h] BYREF
  int j; // [esp+1F88h] [ebp-20h] BYREF
  int i[7]; // [esp+1F8Ch] [ebp-1Ch] BYREF

  if ( strcmp_tospace(cp, (char *)"c") && strcmp_tospace(cp, "c++") )
  {
    if ( strcmp_tospace(cp, "java") )
    {
      if ( strcmp_tospace(cp, "int") && strcmp_tospace(cp, "integer") )
      {
        int_flag = 0;
        v23 = 0;
      }
      else
      {
        cp = skip_param(cp);
        int_flag = 1;
        v23 = 1;
      }
    }
    else
    {
      cp = skip_param(cp);
      int_flag = 0;
      v23 = 2;
    }
  }
  else
  {
    cp = skip_param(cp);
    int_flag = 0;
    v23 = 1;
  }
  v1 = get_range_eol(&cp, i, &j);
  result = 0;
  if ( !v1 )
    return result;
  v26 = i[0];
  v27 = j;
  imag_flag = 0;
  if ( i[0] <= j )
  {
    v3 = &n_lhs[i[0]];
    last_v = &rhs[i[0]];
    v29 = &lhs[i[0]];
    v4 = (int *)(4 * i[0] + 134715712);
    v5 = i[0];
    do
    {
      v6 = *v3;
      if ( *v3 > 0 )
      {
        if ( *v4 <= 0 )
        {
          v7 = *v29;
        }
        else
        {
          v7 = *last_v;
          v6 = *v4;
        }
        v8 = v7;
        v9 = 0;
        while ( v8->kind != VARIABLE || v8->token.variable != 3 )
        {
          v9 += 2;
          v8 += 2;
          if ( v6 <= v9 )
            goto LABEL_22;
        }
        imag_flag = 1;
      }
LABEL_22:
      ++v5;
      ++v3;
      ++last_v;
      ++v29;
      ++v4;
    }
    while ( v5 <= j );
  }
  vc = 0;
  if ( i[0] > j )
  {
LABEL_55:
    if ( vc > 0 )
    {
      qsort(va, vc, 8u, (__compar_fn_t)vcmp);
      for ( k = 0; k < vc; ++k )
      {
        if ( v23 )
        {
          v21 = va[k].v;
          if ( v21 > 3 )
          {
            list_var(v21, v23);
            if ( imag_flag )
              __fprintf_chk(gfp, 1, "_Complex ");
            if ( int_flag )
              __fprintf_chk(gfp, 1, "int %s;\n", var_str);
            else
              __fprintf_chk(gfp, 1, "double %s;\n", var_str);
          }
        }
        else
        {
          list_var(va[k].v, 0);
          __fprintf_chk(gfp, 1, "%s\n", var_str);
        }
      }
    }
    return 1;
  }
  v30 = i[0];
  last_va = 0;
  v10 = 0;
  cnt = 0;
  v11 = -1;
  while ( 2 )
  {
    while ( 2 )
    {
      v12 = n_lhs[v26 + v10];
      v13 = v11;
      if ( v12 <= 0 )
        goto LABEL_51;
      v14 = *(token_type **)((char *)&lhs[v26] + v10 * 4);
      v15 = 0;
      while ( 1 )
      {
        if ( *v14 != 1 )
          goto LABEL_34;
        v13 = v14[2];
        if ( v13 <= last_va )
          goto LABEL_34;
        if ( v11 != -1 && v11 <= v13 )
        {
          if ( v11 == v13 )
          {
            ++cnt;
            v13 = v11;
            goto LABEL_36;
          }
LABEL_34:
          v13 = v11;
          goto LABEL_36;
        }
        cnt = 1;
LABEL_36:
        v15 += 2;
        v14 += 8;
        if ( v12 <= v15 )
          break;
        v11 = v13;
      }
      v16 = *(token_type **)((char *)&rhs[v26] + v10 * 4);
      v17 = n_rhs[v26 + v10];
      if ( v17 <= 0 )
        goto LABEL_51;
      v18 = 0;
      while ( 2 )
      {
        if ( *v16 != 1 )
          goto LABEL_46;
        v19 = v16[2];
        if ( v19 <= last_va )
          goto LABEL_46;
        if ( v13 == -1 || v13 > v19 )
        {
          cnt = 1;
        }
        else
        {
          if ( v13 == v19 )
          {
            ++cnt;
            v19 = v13;
            goto LABEL_48;
          }
LABEL_46:
          v19 = v13;
        }
LABEL_48:
        v18 += 2;
        v16 += 8;
        if ( v17 > v18 )
        {
          v13 = v19;
          continue;
        }
        break;
      }
      v13 = v19;
LABEL_51:
      ++v30;
      ++v10;
      if ( v30 <= v27 )
      {
        v11 = v13;
        continue;
      }
      break;
    }
    if ( v13 == -1 )
      goto LABEL_55;
    va[vc].v = v13;
    va[vc++].count = cnt;
    if ( vc != 1000 )
    {
      last_va = v13;
      v30 = v26;
      v10 = 0;
      cnt = 0;
      v11 = -1;
      continue;
    }
    break;
  }
  error("Too many variables to list.");
  return 0;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08053371) --------------------------------------------------------
int __cdecl code_cmd(char *cp)
{
  int v1; // ebx
  int v2; // esi
  char *v3; // esi
  int v4; // eax
  int v5; // edx
  bool v6; // cc
  int v7; // eax
  language_list v9; // [esp+18h] [ebp-30h]
  int displayed; // [esp+1Ch] [ebp-2Ch]
  int j; // [esp+28h] [ebp-20h] BYREF
  int i[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  v1 = 0;
  v2 = 1;
  while ( 1 )
  {
    if ( !strcmp_tospace(cp, (char *)"c") || !strcmp_tospace(cp, "c++") )
    {
      v2 = 1;
      goto LABEL_13;
    }
    if ( !strcmp_tospace(cp, "java") )
    {
      v2 = 2;
      goto LABEL_13;
    }
    if ( !strcmp_tospace(cp, "python") )
    {
      v2 = 3;
      goto LABEL_13;
    }
    if ( strcmp_tospace(cp, "int") && strcmp_tospace(cp, "integer") )
      break;
    v1 = 1;
LABEL_13:
    cp = skip_param(cp);
  }
  displayed = 0;
  v9 = v2;
  while ( 1 )
  {
    v3 = cp;
    if ( !get_range(&cp, i, &j) )
      return 0;
    if ( *cp && v3 == cp )
    {
      error("Invalid argument.");
      return 0;
    }
    v4 = i[0];
    if ( i[0] <= j )
    {
      while ( 1 )
      {
        v5 = n_lhs[v4];
        if ( v5 > 0 )
          break;
LABEL_38:
        v4 = i[0] + 1;
        i[0] = v4;
        if ( j < v4 )
          goto LABEL_39;
      }
      if ( !n_rhs[v4] || v5 != 1 || lhs[v4]->kind != VARIABLE )
        warning("Can't make assignment statement because this is not an equation.");
      approximate_roots = 1;
      simp_i(lhs[i[0]], &n_lhs[i[0]]);
      if ( v1 )
        uf_repeat_always(lhs[i[0]], &n_lhs[i[0]]);
      if ( n_rhs[i[0]] <= 0 )
      {
        approximate_roots = 0;
        make_fractions_and_group(i[0]);
        if ( v1 )
        {
LABEL_32:
          if ( !int_expr(lhs[i[0]], n_lhs[i[0]]) || !int_expr(rhs[i[0]], n_rhs[i[0]]) )
            warning("Not an integer expression.");
        }
      }
      else
      {
        simp_i(rhs[i[0]], &n_rhs[i[0]]);
        if ( v1 )
        {
          uf_repeat_always(rhs[i[0]], &n_rhs[i[0]]);
          approximate_roots = 0;
          make_fractions_and_group(i[0]);
          goto LABEL_32;
        }
        approximate_roots = 0;
        make_fractions_and_group(i[0]);
      }
      v6 = list_c_equation(i[0], v9, v1) <= 0;
      v7 = 1;
      if ( v6 )
        v7 = displayed;
      displayed = v7;
      goto LABEL_38;
    }
LABEL_39:
    if ( !*cp )
      return displayed;
  }
}

//----- (0805364D) --------------------------------------------------------
int __cdecl list_cmd(char *cp)
{
  char *v1; // ebx
  int v2; // esi
  char *v3; // ebx
  int result; // eax
  int k; // eax
  int j; // [esp+18h] [ebp-20h] BYREF
  int i[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  v1 = cp;
  if ( !strncasecmp(cp, "gnuplot", 4u) )
  {
    cp = skip_param(v1);
    v2 = 3;
  }
  else if ( !strncasecmp(v1, "export", 4u) )
  {
    cp = skip_param(v1);
    v2 = 2;
  }
  else
  {
    v2 = 0;
    if ( !strncasecmp(v1, "maxima", 4u) )
    {
      cp = skip_param(v1);
      LOWORD(v2) = 1;
    }
  }
  while ( 1 )
  {
    v3 = cp;
    result = get_range(&cp, i, &j);
    if ( !result )
      break;
    if ( *cp && v3 == cp )
    {
      error("Invalid argument.");
      return 0;
    }
    for ( k = i[0]; j >= k; i[0] = k )
    {
      if ( n_lhs[k] > 0 )
        list1_sub(k, v2);
      k = i[0] + 1;
    }
    if ( !*cp )
      return 1;
  }
  return result;
}

//----- (08053768) --------------------------------------------------------
int __cdecl save_cmd(char *cp)
{
  int v1; // ebx
  FILE *v2; // eax
  FILE *v3; // edi

  if ( security_level <= 1 )
  {
    clean_up();
    if ( *cp )
    {
      if ( !access(cp, 0) )
      {
        if ( access(cp, 2) )
        {
          error("Specified save file is not writable.");
          return 0;
        }
        __snprintf_chk(prompt_str, 80, 1, 80, "File \"%s\" exists, overwrite (y/n)? ", cp);
        if ( !get_yes_no() )
        {
          __printf_chk(1, "Command aborted.\n");
          return 0;
        }
      }
      v2 = fopen(cp, "w");
      v3 = v2;
      if ( v2 )
      {
        gfp = v2;
        high_prec = 1;
        v1 = list_cmd("all");
        high_prec = 0;
        gfp = default_out;
        if ( fclose(v3) || !v1 )
        {
          error("Error encountered while saving equations.");
          v1 = 0;
        }
        else
        {
          __printf_chk(1, "All equations saved in file \"%s\".\n", cp);
        }
      }
      else
      {
        error("Can't create specified save file.");
        v1 = 0;
      }
    }
    else
    {
      error("No file name specified.");
      v1 = 0;
    }
  }
  else
  {
    error("Command disabled.");
    v1 = 0;
  }
  return v1;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080538F6) --------------------------------------------------------
int __cdecl clear_cmd(char *cp)
{
  char *v1; // ebx
  int result; // eax
  char *v3; // edi
  int v4; // eax
  int v5; // ebx
  int *v6; // ecx
  _DWORD *v7; // edx
  int j; // [esp+18h] [ebp-20h] BYREF
  int i[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  do
  {
    v1 = cp;
    if ( is_all(cp) )
    {
      clear_all();
      return 1;
    }
    result = get_range(&cp, i, &j);
    if ( !result )
      return result;
    v3 = cp;
    if ( *cp && v1 == cp )
    {
      error("Invalid argument.");
      return 0;
    }
    v4 = i[0];
    v5 = j;
    if ( i[0] <= j )
    {
      v6 = &n_lhs[i[0]];
      v7 = (_DWORD *)(4 * i[0] + 134715712);
      do
      {
        *v6 = 0;
        *v7 = 0;
        ++v4;
        ++v6;
        ++v7;
      }
      while ( v4 <= v5 );
      i[0] = v4;
    }
  }
  while ( *v3 );
  return 1;
}

//----- (080539AA) --------------------------------------------------------
int __usercall elim_sub@<eax>(int i@<eax>, int v@<edx>)
{
  int v5; // eax
  token_type want; // [esp+20h] [ebp-28h] BYREF

  if ( i == cur_equation )
  {
    error("Error: source and destination are the same.");
    return 0;
  }
  if ( solved_equation(i) )
  {
    v5 = lhs[i]->token.variable;
    if ( v5 == v )
    {
      list_var(v5, 0);
      __printf_chk(
        1,
        "Substituting the RHS of equation #%d into the current equation for variable (%s)...\n",
        i + 1,
        var_str);
LABEL_6:
      subst_var_with_exp(rhs[cur_equation], &n_rhs[cur_equation], rhs[i], n_rhs[i], v);
      subst_var_with_exp(lhs[cur_equation], &n_lhs[cur_equation], rhs[i], n_rhs[i], v);
      simp_equation(cur_equation);
      return 1;
    }
  }
  list_var(v, 0);
  __printf_chk(1, "Solving equation #%d for (%s) and substituting into the current equation...\n", i + 1, var_str);
  want.level = 1;
  want.kind = VARIABLE;
  want.token.variable = v;
  if ( solve_sub(&want, 1, lhs[i], (int *)(4 * i + 134753664), rhs[i], &n_rhs[i]) > 0 )
    goto LABEL_6;
  error("Solve failed.");
  return 0;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08053B59) --------------------------------------------------------
int __cdecl display_fraction(double value)
{
  int v1; // ebx
  double d5; // [esp+40h] [ebp-18h] BYREF
  double d4[2]; // [esp+48h] [ebp-10h] BYREF

  f_to_fraction(value, d4, &d5);
  __fprintf_chk(gfp, 1, "%.*g", precision, value);
  v1 = 0;
  if ( d5 != 1.0 )
  {
    __fprintf_chk(gfp, 1, " = %.*g/%.*g", precision, d4[0], precision, d5);
    LOBYTE(v1) = 1;
  }
  __fprintf_chk(gfp, 1, "\n");
  return v1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08053C1D) --------------------------------------------------------
int __cdecl divide_cmd(char *cp)
{
  char *v1; // eax
  int v2; // ebx
  long double v4; // fst6
  int v5; // esi
  const char *v6; // eax
  double d4; // [esp+30h] [ebp-88h]
  double d3; // [esp+38h] [ebp-80h]
  double d3a; // [esp+38h] [ebp-80h]
  complexs_0 c3; // [esp+48h] [ebp-70h] BYREF
  complexs_0 c2; // [esp+58h] [ebp-60h] BYREF
  complexs_0 c1; // [esp+68h] [ebp-50h] BYREF
  double d5; // [esp+78h] [ebp-40h] BYREF
  double d2; // [esp+80h] [ebp-38h] BYREF
  double d1; // [esp+88h] [ebp-30h] BYREF
  int nright; // [esp+90h] [ebp-28h] BYREF
  int nleft; // [esp+94h] [ebp-24h] BYREF
  int v_tmp; // [esp+98h] [ebp-20h] BYREF
  int v[7]; // [esp+9Ch] [ebp-1Ch] BYREF

  v[0] = 0;
  nleft = 0;
  nright = 0;
  pull_number = -1;
  if ( *cp )
  {
    v1 = parse_var2(v, cp);
    if ( !v1 || extra_characters(v1) )
      return 0;
  }
  v2 = next_espace();
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        my_strlcpy(prompt_str, "Enter dividend: ", 80);
        if ( !get_expr(rhs[v2], &nright) )
          return repeat_flag;
        my_strlcpy(prompt_str, "Enter divisor: ", 80);
        if ( !get_expr(lhs[v2], &nleft) )
          return repeat_flag;
        __fprintf_chk(gfp, 1, "\n");
        calc_simp(rhs[v2], &nright);
        calc_simp(lhs[v2], &nleft);
        if ( get_constant(lhs[v2], nleft, &d2) )
          check_divide_by_zero(d2);
        if ( !get_constant(rhs[v2], nright, &d1) || !get_constant(lhs[v2], nleft, &d2) )
          break;
        d3 = gcd_verified(d1, d2);
        d4 = modf(d1 / d2, &d5);
        __fprintf_chk(gfp, 1, "%.*g/%.*g = %.*g", precision, d1, precision, d2, precision, d1 / d2);
        if ( d3 != 0.0 )
        {
          v4 = d2 / d3;
          if ( v4 != 1.0 )
            __fprintf_chk(gfp, 1, " = %.*g/%.*g", precision, d1 / d3, precision, (double)v4);
        }
        __fprintf_chk(gfp, 1, "\nQuotient: %.*g, Remainder: %.*g\n", precision, d5, precision, d4 * d2);
        d1 = fabs(d1);
        d2 = fabs(d2);
        if ( d3 == 0.0 )
        {
          __fprintf_chk(gfp, 1, "No GCD found.\n");
          if ( !repeat_flag )
            return 1;
        }
        else
        {
          __fprintf_chk(gfp, 1, "GCD = ");
          if ( d3 < 4.0 || !factor_one(d3) || is_prime() )
            display_fraction(d3);
          else
            display_unique();
          d3a = d1 * d2 / d3;
          __fprintf_chk(gfp, 1, "LCM = ");
          if ( d3a < 4.0 || !factor_one(d3a) || is_prime() )
            display_fraction(d3a);
          else
            display_unique();
          if ( !repeat_flag )
            return 1;
        }
      }
      if ( !parse_complex(rhs[v2], nright, &c1) || !parse_complex(lhs[v2], nleft, &c2) )
        break;
      complex_div(&c3, c1, c2);
      __fprintf_chk(gfp, 1, "Result of complex number division:\n");
      __fprintf_chk(gfp, 1, "%.*g %+.*g*i\n\n", precision, c3.re, precision, c3.im);
      if ( !repeat_flag )
        return 1;
    }
    v_tmp = v[0];
    if ( poly_div(rhs[v2], nright, lhs[v2], nleft, &v_tmp) )
    {
      simp_divide(tlhs, &n_tlhs);
      simp_divide(trhs, &n_trhs);
      list_var(v_tmp, 0);
      __fprintf_chk(gfp, 1, "Polynomial division successful using base variable (%s).\n", var_str);
      __fprintf_chk(gfp, 1, "The quotient is:\n");
      fractions_and_group(tlhs, &n_tlhs);
      list_factor(tlhs, &n_tlhs, 0);
      __fprintf_chk(gfp, 1, "\n\nThe remainder is:\n");
      fractions_and_group(trhs, &n_trhs);
      list_factor(trhs, &n_trhs, 0);
      __fprintf_chk(gfp, 1, "\n");
    }
    else
    {
      __fprintf_chk(gfp, 1, "Polynomial division failed.\n");
    }
    __fprintf_chk(gfp, 1, "\n");
    v5 = poly_gcd(rhs[v2], nright, lhs[v2], nleft, v[0]);
    if ( v5 || (v5 = poly_gcd(lhs[v2], nleft, rhs[v2], nright, v[0])) != 0 )
    {
      simp_divide(trhs, &n_trhs);
      v6 = "s";
      if ( v5 == 1 )
        v6 = "; This file can be edited.\n\n" + 28;
      __fprintf_chk(gfp, 1, "Polynomial GCD (%d Euclidean algorithm iteration%s):\n", v5, v6);
      fractions_and_group(trhs, &n_trhs);
      list_factor(trhs, &n_trhs, 0);
      __fprintf_chk(gfp, 1, "\n");
    }
    else
    {
      __fprintf_chk(gfp, 1, "No univariate polynomial GCD found.\n");
    }
  }
  while ( repeat_flag );
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080543B1) --------------------------------------------------------
int __usercall compare_rhs@<eax>(int i@<eax>, int j@<edx>, int *diff_signp@<ecx>)
{
  int result; // eax

  if ( se_compare(rhs[i], n_rhs[i], rhs[i], n_rhs[i], diff_signp) && !*diff_signp )
  {
    sign_cmp_flag = 1;
    result = se_compare(rhs[i], n_rhs[i], rhs[j], n_rhs[j], diff_signp);
    sign_cmp_flag = 0;
  }
  else
  {
    error("Error in compare function or too many terms to compare.");
    result = 0;
  }
  return result;
}

//----- (08054457) --------------------------------------------------------
int __cdecl compare_es(int i, int j)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // edx
  int v8; // eax
  int diff_sign; // [esp+2Ch] [ebp-Ch] BYREF

  v2 = n_lhs[i];
  if ( !v2 )
    goto LABEL_10;
  v3 = n_lhs[j];
  if ( !v3 )
    goto LABEL_10;
  sign_cmp_flag = 1;
  v4 = se_compare(lhs[i], v2, lhs[j], v3, &diff_sign);
  sign_cmp_flag = 0;
  if ( !v4 || diff_sign )
    goto LABEL_10;
  v5 = n_rhs[i];
  if ( !v5 )
    return n_rhs[j] == 0;
  v7 = n_rhs[j];
  if ( v7 && (sign_cmp_flag = 1, v8 = se_compare(rhs[i], v5, rhs[j], v7, &diff_sign), sign_cmp_flag = 0, v8) )
    result = diff_sign == 0;
  else
LABEL_10:
    result = 0;
  return result;
}

//----- (0805454A) --------------------------------------------------------
int __cdecl compare_cmd(char *cp)
{
  char *v1; // ebx
  int v2; // edi
  int v3; // ebx
  int v4; // eax
  int v5; // esi
  int result; // eax
  int *np; // [esp+24h] [ebp-34h]
  int *npa; // [esp+24h] [ebp-34h]
  int *npb; // [esp+24h] [ebp-34h]
  int *leftnp; // [esp+28h] [ebp-30h]
  int *leftnpa; // [esp+28h] [ebp-30h]
  int symb; // [esp+2Ch] [ebp-2Ch]
  int diff_sign[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v1 = cp;
  symb = 0;
  if ( !strncasecmp(cp, "symbolic", 3u) )
  {
    cp = skip_param(v1);
    symb = 1;
  }
  if ( !strcmp_tospace(cp, "with") )
    cp = skip_param(cp);
  v2 = decstrtol(cp, &cp);
  v3 = v2 - 1;
  if ( not_defined(v2 - 1) )
    return 0;
  if ( !strcmp_tospace(cp, "with") )
    cp = skip_param(cp);
  v4 = get_default_en(cp);
  v5 = v4;
  if ( v4 < 0 )
    return 0;
  if ( v3 == v4 )
  {
    error("Cannot compare an equation with itself.");
    return 0;
  }
  __fprintf_chk(gfp, 1, "Comparing #%d with #%d...\n", v2, v4 + 1);
  if ( !n_rhs[v3] )
  {
    if ( !n_rhs[v5] )
    {
      np = &n_lhs[v3];
      simp_loop(lhs[v3], np);
      leftnp = &n_lhs[v5];
      simp_loop(lhs[v5], leftnp);
      if ( compare_es(v3, v5) )
        goto LABEL_23;
      if ( debug_level >= 0 )
        __fprintf_chk(gfp, 1, "%s\n", "Simplifying both expressions...");
      symb_flag = symb;
      simpa_side(lhs[v3], np, 0, 1);
      simpa_side(lhs[v5], leftnp, 0, 1);
      symb_flag = 0;
      if ( debug_level >= 0 )
      {
        list_sub(v3);
        list_sub(v5);
      }
      if ( compare_es(v3, v5) || (uf_simp(lhs[v3], np), uf_simp(lhs[v5], leftnp), compare_es(v3, v5)) )
      {
LABEL_23:
        __fprintf_chk(gfp, 1, "Expressions are identical.\n");
        result = 1;
      }
      else
      {
        __fprintf_chk(gfp, 1, "Expressions differ.\n");
        result = 0;
      }
      return result;
    }
LABEL_25:
    error("Cannot compare an equation with a non-equation.");
    return 0;
  }
  if ( !n_rhs[v5] )
    goto LABEL_25;
  if ( compare_es(v3, v5) )
  {
    __fprintf_chk(gfp, 1, "Equations are identical.\n");
    return 1;
  }
  if ( !solved_equation(v3) || !solved_equation(v5) )
    goto LABEL_37;
  npa = &n_rhs[v3];
  simp_loop(rhs[v3], npa);
  leftnpa = &n_rhs[v5];
  simp_loop(rhs[v5], leftnpa);
  if ( !compare_rhs(v3, v5, diff_sign) )
  {
    if ( debug_level >= 0 )
      __fprintf_chk(gfp, 1, "%s\n", "Simplifying both equations...");
    symb_flag = symb;
    simpa_side(rhs[v3], npa, 0, 1);
    simpa_side(rhs[v5], leftnpa, 0, 1);
    symb_flag = 0;
    if ( debug_level >= 0 )
    {
      list_sub(v3);
      list_sub(v5);
    }
    if ( !compare_rhs(v3, v5, diff_sign) )
    {
      uf_simp(rhs[v3], npa);
      uf_simp(rhs[v5], leftnpa);
      if ( !compare_rhs(v3, v5, diff_sign) )
      {
LABEL_37:
        if ( debug_level >= 0 )
          __fprintf_chk(gfp, 1, "%s\n", "Solving both equations for zero and unfactoring...");
        if ( solve_sub(&zero_token, 1, lhs[v3], (int *)(4 * v3 + 134753664), rhs[v3], &n_rhs[v3]) > 0 )
        {
          npb = &n_rhs[v5];
          if ( solve_sub(&zero_token, 1, lhs[v5], (int *)(4 * v5 + 134753664), rhs[v5], npb) > 0 )
          {
            uf_simp(rhs[v3], &n_rhs[v3]);
            uf_simp(rhs[v5], npb);
            if ( !compare_rhs(v3, v5, diff_sign) )
            {
              if ( debug_level >= 0 )
                __fprintf_chk(gfp, 1, "%s\n", "Simplifying both equations...");
              symb_flag = symb;
              simpa_side(rhs[v3], &n_rhs[v3], 0, 0);
              simpa_side(rhs[v5], npb, 0, 0);
              symb_flag = 0;
              if ( !compare_rhs(v3, v5, diff_sign) )
              {
                if ( solve_sub(&zero_token, 1, lhs[v3], (int *)(4 * v3 + 134753664), rhs[v3], &n_rhs[v3]) > 0
                  && solve_sub(&zero_token, 1, lhs[v5], (int *)(4 * v5 + 134753664), rhs[v5], npb) > 0 )
                {
                  uf_simp(rhs[v3], &n_rhs[v3]);
                  uf_simp(rhs[v5], npb);
                  if ( !compare_rhs(v3, v5, diff_sign) )
                  {
                    __fprintf_chk(gfp, 1, "Equations differ.\n");
                    return 0;
                  }
                  goto LABEL_52;
                }
                return 0;
              }
            }
LABEL_52:
            __fprintf_chk(gfp, 1, "Equations are identical.\n");
            return 1;
          }
        }
        return 0;
      }
    }
  }
  if ( !diff_sign[0] && lhs[v3]->token.variable == lhs[v5]->token.variable )
    goto LABEL_52;
  __fprintf_chk(gfp, 1, "Variable (");
  list_proc(lhs[v3], n_lhs[v3], 0);
  __fprintf_chk(gfp, 1, ") in the first equation is equal to (");
  if ( diff_sign[0] )
    __fprintf_chk(gfp, 1, "-");
  list_proc(lhs[v5], n_lhs[v5], 0);
  __fprintf_chk(gfp, 1, ") in the second equation.\n");
  result = 2;
  if ( diff_sign[0] )
    return 0;
  return result;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08054E04) --------------------------------------------------------
int __usercall find_more@<eax>(token_type *equation@<eax>, int *np@<edx>, int en@<ecx>)
{
  int v3; // esi
  int i; // ebx
  int v5; // edx
  int *v6; // eax
  token_type *v7; // eax
  token_type *v8; // eax
  int v10; // edi
  int v11; // ecx
  int v12; // [esp+28h] [ebp-40h]
  token_type *p1; // [esp+2Ch] [ebp-3Ch]
  int found_se; // [esp+38h] [ebp-30h]
  int found_sea; // [esp+38h] [ebp-30h]
  int diff_sign[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  if ( *np > 0 )
  {
    v3 = 1;
    if ( solved_equation(en) )
    {
      while ( 1 )
      {
        v11 = *np;
        if ( *np <= 1 )
          break;
        found_sea = 0;
        v10 = 1;
        for ( i = 1; ; i += 2 )
        {
          if ( i < v11 && v3 <= equation[i].level )
          {
            v6 = &equation[i + 2].level;
            do
            {
              i += 2;
              if ( i >= v11 )
                break;
              v5 = *v6;
              v6 += 8;
            }
            while ( v5 >= v3 );
          }
          if ( i != v10 )
          {
            found_se = v10 - 1;
            p1 = &equation[v10 - 1];
            if ( se_compare(p1, i - (v10 - 1), rhs[en], n_rhs[en], diff_sign) )
            {
              v12 = v3;
              if ( diff_sign[0] )
              {
                memmove(&equation[v10 + 2], &equation[i], 16 * (*np - i));
                *np = v10 + *np + 2 - i;
                ++v3;
                p1->level = v12 + 1;
                p1->kind = CONSTANT;
                p1->token.constant = -1.0;
                v7 = &equation[v10];
                v7->level = v12 + 1;
                v7->kind = OPERATOR;
                v7->token.variable = 3;
                found_se = v10 + 1;
              }
              else
              {
                memmove(&equation[v10], &equation[i], 16 * (*np - i));
                *np += v10 - i;
              }
              v8 = &equation[found_se];
              v8->level = v3;
              v8->kind = VARIABLE;
              v8->token.variable = lhs[en]->token.variable;
              return 1;
            }
            found_sea = 1;
          }
          v10 = i + 2;
          v11 = *np;
          if ( *np <= i + 2 )
            break;
        }
        if ( !found_sea )
          return 0;
        ++v3;
      }
    }
  }
  return 0;
}

//----- (08054FE6) --------------------------------------------------------
int __cdecl tally_cmd(char *cp)
{
  char *v1; // ebx
  int v2; // edx
  int result; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int arithmetic_mean; // [esp+14h] [ebp-24h]
  double count; // [esp+18h] [ebp-20h]

  v1 = cp;
  arithmetic_mean = 0;
  if ( !strncasecmp(cp, "average", 4u) )
  {
    v1 = skip_param(cp);
    arithmetic_mean = 1;
  }
  v2 = extra_characters(v1);
  result = 0;
  if ( !v2 )
  {
    *trhs = zero_token;
    n_trhs = 1;
    __fprintf_chk(gfp, 1, "Running total = ");
    list_proc(trhs, n_trhs, 0);
    __fprintf_chk(gfp, 1, "\n");
    count = 0.0;
    while ( 1 )
    {
      __fprintf_chk(gfp, 1, "\n");
      my_strlcpy(prompt_str, "Enter value: ", 80);
      if ( !get_expr(tlhs, &n_tlhs) )
        break;
      if ( n_tlhs + n_trhs + 1 > n_tokens )
        error_huge();
      if ( n_tlhs > 0 )
      {
        v6 = 0;
        do
          ++tlhs[v6++].level;
        while ( n_tlhs > v6 );
      }
      v7 = n_trhs;
      if ( n_trhs > 0 )
      {
        v8 = 0;
        do
        {
          ++trhs[v8++].level;
          v7 = n_trhs;
        }
        while ( n_trhs > v8 );
      }
      trhs[v7].kind = OPERATOR;
      trhs[n_trhs].level = 1;
      trhs[n_trhs++].token.variable = 1;
      memmove(&trhs[n_trhs], tlhs, 16 * n_tlhs);
      n_trhs += n_tlhs;
      calc_simp(trhs, &n_trhs);
      count = count + 1.0;
      __fprintf_chk(gfp, 1, "Running total = ");
      list_proc(trhs, n_trhs, 0);
      __fprintf_chk(gfp, 1, "\n");
      if ( count > 0.0 && arithmetic_mean )
      {
        memmove(tlhs, trhs, 16 * n_trhs);
        n_tlhs = n_trhs;
        if ( n_trhs + 2 > n_tokens )
          error_huge();
        v4 = n_tlhs;
        if ( n_tlhs > 0 )
        {
          v5 = 0;
          do
          {
            ++tlhs[v5++].level;
            v4 = n_tlhs;
          }
          while ( n_tlhs > v5 );
        }
        tlhs[v4].kind = OPERATOR;
        tlhs[n_tlhs].level = 1;
        tlhs[n_tlhs++].token.variable = 4;
        tlhs[n_tlhs].kind = CONSTANT;
        tlhs[n_tlhs].level = 1;
        tlhs[n_tlhs++].token.constant = count;
        calc_simp(tlhs, &n_tlhs);
        __fprintf_chk(gfp, 1, "Average = ");
        list_proc(tlhs, n_tlhs, 0);
        __fprintf_chk(gfp, 1, "\n");
      }
    }
    __fprintf_chk(gfp, 1, "End.\n");
    result = 1;
  }
  return result;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08055415) --------------------------------------------------------
int __usercall complex_func@<eax>(char *cp@<eax>, int imag_flag@<edx>)
{
  char *v3; // eax
  int v4; // edx
  int k; // ebx
  int v6; // ecx
  int *v7; // eax
  int *np; // [esp+24h] [ebp-54h]
  int j; // [esp+28h] [ebp-50h]
  int i; // [esp+2Ch] [ebp-4Ch]
  int has_real; // [esp+30h] [ebp-48h]
  int has_imag; // [esp+34h] [ebp-44h]
  token_type *equation; // [esp+38h] [ebp-40h]
  int *nps; // [esp+40h] [ebp-38h]
  token_type *source; // [esp+44h] [ebp-34h]
  int beg; // [esp+48h] [ebp-30h]
  int v; // [esp+58h] [ebp-20h] BYREF
  int n1[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v = 3;
  if ( current_not_defined() )
    return 0;
  i = cur_equation;
  j = next_espace();
  if ( n_rhs[i] )
  {
    source = rhs[i];
    nps = &n_rhs[i];
    equation = rhs[j];
    np = &n_rhs[j];
  }
  else
  {
    source = lhs[i];
    nps = &n_lhs[i];
    equation = lhs[j];
    np = &n_lhs[j];
  }
  if ( *cp )
  {
    v3 = parse_var2(&v, cp);
    if ( !v3 || extra_characters(v3) )
      return 0;
  }
  simp_loop(source, nps);
  uf_simp(source, nps);
  factorv(source, nps, v);
  partial_flag = 0;
  uf_simp(source, nps);
  partial_flag = 1;
  n1[0] = 1;
  *equation = zero_token;
  v4 = *nps;
  if ( *nps <= 0 )
    goto LABEL_31;
  has_real = 0;
  has_imag = 0;
  beg = 0;
  for ( k = 0; ; beg = k++ )
  {
    v6 = 0;
    if ( v4 <= k )
      goto LABEL_20;
    v7 = &source[k].level;
    v6 = 0;
    do
    {
      if ( *v7 == 1 && *(v7 - 1) == 2 )
      {
        if ( (unsigned int)(v7[1] - 1) <= 1 )
          break;
      }
      else if ( *(v7 - 1) == 1 && v7[1] == v )
      {
        v6 = 1;
      }
      ++k;
      v7 += 4;
    }
    while ( v4 > k );
    if ( v6 )
      has_imag = 1;
    else
LABEL_20:
      has_real = 1;
    if ( v6 == imag_flag )
    {
      if ( !beg )
        n1[0] = 0;
      memmove(&equation[n1[0]], &source[beg], 16 * (k - beg));
      n1[0] += k - beg;
    }
    v4 = *nps;
    if ( *nps <= k )
      break;
  }
  if ( !has_imag || !has_real )
LABEL_31:
    warning("Expression was not a mix.");
  do
    simp_loop(equation, n1);
  while ( factor_plus(equation, n1, v, 0.0) );
  simp_divide(equation, n1);
  if ( n_rhs[i] )
  {
    memmove(lhs[j], lhs[i], 16 * n_lhs[i]);
    n_lhs[j] = n_lhs[i];
  }
  *np = n1[0];
  cur_equation = j;
  return return_result(j);
}

//----- (08055703) --------------------------------------------------------
int __cdecl imaginary_cmd(char *cp)
{
  return complex_func(cp, 1);
}

//----- (08055718) --------------------------------------------------------
int __cdecl real_cmd(char *cp)
{
  return complex_func(cp, 0);
}

//----- (0805572D) --------------------------------------------------------
int __cdecl pause_cmd(char *cp)
{
  char *v1; // ebx
  char *v2; // eax
  const char *v3; // ebx
  int result; // eax
  char buf[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v6; // [esp+102Ch] [ebp-Ch]

  v1 = cp;
  v6 = __readgsdword(0x14u);
  if ( test_mode || !isatty(0) )
    return 1;
  if ( !*cp )
    v1 = "Please press the Enter key";
  __snprintf_chk(prompt_str, 80, 1, 80, " ==== %s ==== ", v1);
  v2 = get_string(buf, 4096);
  v3 = v2;
  if ( !v2 || !strncasecmp(v2, "quit", 4u) )
    result = 0;
  else
    result = strncasecmp(v3, "exit", 4u) != 0;
  return result;
}
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08055821) --------------------------------------------------------
int __cdecl output_current_directory(FILE *ofp)
{
  char buf[4096]; // [esp+1Ch] [ebp-100Ch] BYREF
  unsigned int v3; // [esp+101Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  if ( security_level > 2 || !ofp || !getcwd(buf, 0x1000u) )
    return 0;
  __fprintf_chk(ofp, 1, "directory = %s\n", buf);
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080558A8) --------------------------------------------------------
int __cdecl set_options(char *cp)
{
  char *v1; // eax
  char *v2; // ebx
  int result; // eax
  char *v4; // eax
  int v5; // edi
  char *v6; // ebx
  char *v7; // esi
  int v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  int v11; // eax
  unsigned int v12; // eax
  int v13; // edx
  char *cp1[7]; // [esp+1Ch] [ebp-1Ch] BYREF

  while ( 1 )
  {
    v1 = skip_space(cp);
    v2 = v1;
    cp = v1;
    if ( !*v1 )
      return 1;
    if ( security_level <= 2 && !strncasecmp(v1, "dir", 3u) )
      break;
    v5 = skip_no(&cp);
    v6 = cp;
    v7 = skip_param(cp);
    cp = v7;
    if ( !strncasecmp(v6, "debug", 5u) )
    {
      if ( v5 )
      {
        debug_level = 0;
      }
      else
      {
        v8 = decstrtol(v7, cp1);
        if ( cp == cp1[0] )
        {
          error("Please specify the debug level number.");
          return 0;
        }
        cp = cp1[0];
        debug_level = v8;
      }
      return extra_characters(cp) == 0;
    }
    result = strncasecmp(v6, "special", 7u);
    if ( !result )
    {
      if ( v5 )
      {
        special_variable_characters[0] = 0;
        LOBYTE(result) = 1;
      }
      else
      {
        my_strlcpy(special_variable_characters, v7, 256);
        result = 1;
      }
      return result;
    }
    if ( !strncasecmp(v6, "columns", 6u) )
    {
      if ( v5 )
      {
        screen_columns = 0;
      }
      else
      {
        v9 = decstrtol(v7, cp1);
        if ( v9 < 0 || cp == cp1[0] )
        {
          error("Please specify how wide the screen is; 0 = infinite columns.");
          return 0;
        }
        cp = cp1[0];
        screen_columns = v9;
      }
      return extra_characters(cp) == 0;
    }
    if ( !strncasecmp(v6, "wide", 4u) )
    {
      if ( v5 )
      {
        get_screen_size();
      }
      else
      {
        screen_columns = 0;
        screen_rows = 0;
      }
    }
    else
    {
      if ( !strncasecmp(v6, "precision", 4u) )
      {
        v10 = decstrtol(v7, cp1);
        if ( v10 > 0xE || cp == cp1[0] )
        {
          error("Please specify a display precision between 0 and 14 digits.");
          result = 0;
        }
        else
        {
          precision = v10;
          result = 1;
        }
        return result;
      }
      if ( strcmp_tospace(v6, "auto") )
      {
        if ( !strncasecmp(v6, "autosolve", 9u) )
        {
          autosolve = v5 == 0;
        }
        else if ( !strncasecmp(v6, "autocalc", 8u) )
        {
          autocalc = v5 == 0;
        }
        else if ( !strncasecmp(v6, "autoselect", 0xAu) )
        {
          autoselect = v5 == 0;
        }
        else if ( !strncasecmp(v6, "case", 4u) )
        {
          case_sensitive_flag = v5 == 0;
        }
        else if ( !strncasecmp(v6, "display2d", 7u) )
        {
          display2d = v5 == 0;
        }
        else if ( !strncasecmp(v6, "prompt", 6u) )
        {
          quiet_mode = v5;
        }
        else if ( !strncasecmp(v6, "preserve", 8u) )
        {
          preserve_surds = v5 == 0;
        }
        else if ( !strncasecmp(v6, "rationalize", 0xBu) )
        {
          rationalize_denominators = v5 == 0;
        }
        else
        {
          if ( !strncasecmp(v6, "modulus_mode", 3u) )
          {
            if ( v5 )
            {
              modulus_mode = 0;
            }
            else
            {
              v11 = decstrtol(cp, cp1);
              if ( cp == cp1[0] || v11 < 0 || v11 > 2 )
              {
                error("Please specify the modulus mode number (0, 1, or 2).");
                __printf_chk(1, "0 means modulus operator (%%) result has same sign as dividend,\n");
                __printf_chk(1, "1 means computed result always has same sign as the divisor,\n");
                __printf_chk(1, "2 means the result is always positive or zero.\n");
                __printf_chk(1, "Current value is %d.\n", modulus_mode);
                return 0;
              }
              cp = cp1[0];
              modulus_mode = v11;
            }
            return extra_characters(cp) == 0;
          }
          if ( !strncasecmp(v6, "color", 5u) )
          {
            reset_attr();
            color_flag = v5 == 0;
          }
          else if ( !strncasecmp(v6, "bold", 4u) )
          {
            reset_attr();
            bold_colors = v5 == 0;
          }
          else
          {
            if ( !strncasecmp(v6, "finance", 7u) )
            {
              if ( v5 )
              {
                finance_option = 0;
              }
              else
              {
                v12 = decstrtol(cp, cp1);
                if ( cp == cp1[0] )
                {
                  v12 = 2;
                  if ( *cp )
                  {
                    error("Please specify the number of digits.");
                    return 0;
                  }
                }
                else if ( v12 > 0xE )
                {
                  error("Minimum is 0, maximum is 14.");
                  return 0;
                }
                cp = cp1[0];
                finance_option = v12;
              }
              return extra_characters(cp) == 0;
            }
            if ( !strncasecmp(v6, "factor_integers", 6u) )
            {
              factor_int_flag = v5 == 0;
            }
            else if ( !strncasecmp(v6, "right_associative_power", 5u) )
            {
              right_associative_power = v5 == 0;
            }
            else
            {
              if ( strncasecmp(v6, "negate_highest_precedence", 6u) )
              {
                if ( security_level > 1 || strcmp_tospace(v6, "save") )
                {
                  error("Unknown set option.");
                  return 0;
                }
                if ( !rc_file[0] )
                {
                  error("Set options startup file name not set.");
                  return 0;
                }
                if ( v5 )
                {
                  if ( !unlink(rc_file) )
                    __printf_chk(1, "Set options startup file \"%s\" removed.\n", rc_file);
                }
                else
                {
                  v13 = save_set_options();
                  result = 0;
                  if ( !v13 )
                    return result;
                }
                return extra_characters(cp) == 0;
              }
              negate_highest_precedence = v5 == 0;
            }
          }
        }
      }
      else
      {
        autoselect = v5 == 0;
        autocalc = v5 == 0;
        autosolve = v5 == 0;
      }
    }
  }
  cp = skip_param(v2);
  if ( !*cp )
  {
    v4 = getenv("HOME");
    cp1[0] = v4;
    if ( v4 )
      cp = v4;
  }
  if ( chdir(cp) )
  {
    error("Error changing directory.");
    result = 0;
  }
  else
  {
    output_current_directory(stdout);
    result = 1;
  }
  return result;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08055FD5) --------------------------------------------------------
int __cdecl set_cmd(char *cp)
{
  if ( *cp )
    return set_options(cp);
  __fprintf_chk(gfp, 1, "Options are set as follows:\n\n");
  output_options(gfp);
  __fprintf_chk(gfp, 1, "columns = %d\n", screen_columns);
  output_current_directory(gfp);
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08056051) --------------------------------------------------------
int __cdecl push_en(int en)
{
  char *v1; // eax
  char *v2; // ebx

  if ( !readline_enabled )
    return 0;
  high_prec = 1;
  v1 = list_equation(en, 0);
  v2 = v1;
  high_prec = 0;
  if ( !v1 )
    return 0;
  add_history(v1);
  last_history_string = v2;
  return 1;
}
// 8049254: using guessed type int __cdecl add_history(_DWORD);

//----- (080560AE) --------------------------------------------------------
int __cdecl push_cmd(char *cp)
{
  int result; // eax
  int v2; // edx
  int v3; // eax
  int j; // [esp+18h] [ebp-10h] BYREF
  int i[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( readline_enabled )
  {
    v2 = get_range_eol(&cp, i, &j);
    result = 0;
    if ( v2 )
    {
      v3 = i[0];
      if ( i[0] > j )
      {
LABEL_9:
        result = 1;
        if ( debug_level >= 0 )
        {
          __fprintf_chk(gfp, 1, "%s\n", "Expression pushed.  Press the UP key to access.");
          result = 1;
        }
      }
      else
      {
        while ( !n_lhs[v3] || push_en(v3) )
        {
          v3 = i[0] + 1;
          i[0] = v3;
          if ( j < v3 )
            goto LABEL_9;
        }
        error("Push failed.");
        result = 0;
      }
    }
  }
  else
  {
    error("Readline is currently turned off.");
    result = 0;
  }
  return result;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08056176) --------------------------------------------------------
int __usercall opt_es@<eax>(token_type *equation@<eax>, int *np@<edx>)
{
  int v2; // edx
  int v3; // esi
  int *v4; // eax
  int k; // esi
  int l; // ebx
  int v7; // edx
  int *v8; // eax
  int v9; // eax
  token_type *v10; // eax
  token_type *v11; // eax
  int m; // eax
  int v14; // edi
  int v15; // ecx
  int v16; // ebx
  int v17; // ecx
  int v18; // [esp+24h] [ebp-B4h]
  int i; // [esp+28h] [ebp-B0h]
  int v20; // [esp+2Ch] [ebp-ACh]
  int i2; // [esp+30h] [ebp-A8h]
  int n1; // [esp+34h] [ebp-A4h]
  token_type *p1; // [esp+38h] [ebp-A0h]
  token_type *p2; // [esp+3Ch] [ebp-9Ch]
  int j; // [esp+40h] [ebp-98h]
  int found_se1; // [esp+48h] [ebp-90h]
  int found_se1a; // [esp+48h] [ebp-90h]
  int v; // [esp+50h] [ebp-88h] BYREF
  int diff_sign; // [esp+54h] [ebp-84h] BYREF
  char v32[100]; // [esp+58h] [ebp-80h] BYREF
  unsigned int v33; // [esp+BCh] [ebp-1Ch]

  v33 = __readgsdword(0x14u);
  if ( *np > 0 )
  {
    for ( i = 1; ; ++i )
    {
      v17 = *np;
      if ( *np <= 1 )
        break;
      v16 = 0;
      v20 = 1;
      for ( j = 1; ; j += 2 )
      {
        if ( v17 > j && i < equation[j].level )
        {
          v4 = &equation[j + 2].level;
          v2 = j;
          while ( 1 )
          {
            v2 += 2;
            if ( v2 >= v17 )
              break;
            v3 = *v4;
            v4 += 8;
            if ( v3 <= i )
            {
              j = v2;
              goto LABEL_7;
            }
          }
          j = v2;
        }
LABEL_7:
        if ( j != v20 )
        {
          n1 = j - (v20 - 1);
          if ( n1 > 6 )
          {
            p1 = &equation[v20 - 1];
            for ( k = 1; ; ++k )
            {
              v15 = *np;
              if ( *np <= 1 )
                break;
              found_se1a = 0;
              v14 = 1;
              for ( l = 1; ; l += 2 )
              {
                if ( v15 > l && k < equation[l].level )
                {
                  v8 = &equation[l + 2].level;
                  do
                  {
                    l += 2;
                    if ( l >= v15 )
                      break;
                    v7 = *v8;
                    v8 += 8;
                  }
                  while ( v7 > k );
                }
                if ( l != v14 )
                {
                  if ( v14 > j )
                  {
                    found_se1 = v14 - 1;
                    if ( l - (v14 - 1) > 6 )
                    {
                      p2 = &equation[found_se1];
                      if ( se_compare(p1, n1, p2, l - (v14 - 1), &diff_sign) )
                      {
                        v18 = k;
                        __snprintf_chk(v32, 100, 1, 100, "temp%.0d", last_temp_var);
                        if ( !parse_var(&v, v32) )
                          return 0;
                        v9 = 0;
                        if ( last_temp_var + 1 >= 0 )
                          v9 = last_temp_var + 1;
                        last_temp_var = v9;
                        i2 = next_espace();
                        lhs[i2]->level = 1;
                        lhs[i2]->kind = VARIABLE;
                        lhs[i2]->token.variable = v;
                        n_lhs[i2] = 1;
                        memmove(rhs[i2], p1, 16 * n1);
                        n_rhs[i2] = n1;
                        if ( diff_sign )
                        {
                          memmove(&equation[v14 + 2], &equation[l], 16 * (*np - l));
                          *np = v14 + *np + 2 - l;
                          ++k;
                          p2->level = v18 + 1;
                          p2->kind = CONSTANT;
                          p2->token.constant = -1.0;
                          v10 = &equation[v14];
                          v10->level = v18 + 1;
                          v10->kind = OPERATOR;
                          v10->token.variable = 3;
                          found_se1 = v14 + 1;
                        }
                        else
                        {
                          memmove(&equation[v14], &equation[l], 16 * (*np - l));
                          *np += v14 - l;
                        }
                        v11 = &equation[found_se1];
                        v11->level = k;
                        v11->kind = VARIABLE;
                        v11->token.variable = v;
                        memmove(&equation[v20], &equation[j], 16 * (*np - j));
                        *np += v20 - j;
                        p1->level = i;
                        p1->kind = VARIABLE;
                        p1->token.variable = v;
                        while ( find_more(equation, np, i2) )
                          ;
                        simp_loop(rhs[i2], &n_rhs[i2]);
                        simp_loop(equation, np);
                        for ( m = 0; opt_en[m] >= 0; ++m )
                          ;
                        opt_en[m] = i2;
                        opt_en[m + 1] = -1;
                        return 1;
                      }
                    }
                  }
                  found_se1a = 1;
                }
                v14 = l + 2;
                v15 = *np;
                if ( *np <= l + 2 )
                  break;
              }
              if ( !found_se1a )
                break;
            }
          }
          v16 = 1;
        }
        v20 = j + 2;
        v17 = *np;
        if ( *np <= j + 2 )
          break;
      }
      if ( !v16 )
        break;
    }
  }
  return 0;
}
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080566A8) --------------------------------------------------------
int __cdecl optimize_cmd(char *cp)
{
  int v1; // ebx
  int v2; // ebx
  int *v3; // esi
  int v4; // eax
  int v5; // ebx
  token_type **v6; // edi
  int i; // esi
  int j; // esi
  int v9; // eax
  int *v10; // ebx
  int v11; // eax
  int *v12; // esi
  int v13; // eax
  int *v14; // ebx
  int v15; // eax
  int k; // [esp+10h] [ebp-58h]
  int flag; // [esp+14h] [ebp-54h]
  int *v19; // [esp+18h] [ebp-50h]
  int start_en; // [esp+1Ch] [ebp-4Ch]
  int *v21; // [esp+20h] [ebp-48h]
  token_type **v22; // [esp+24h] [ebp-44h]
  int *v23; // [esp+28h] [ebp-40h]
  token_type **v24; // [esp+2Ch] [ebp-3Ch]
  int v25; // [esp+34h] [ebp-34h]
  int np; // [esp+38h] [ebp-30h]
  int *npa; // [esp+38h] [ebp-30h]
  int *n; // [esp+3Ch] [ebp-2Ch]
  int na; // [esp+3Ch] [ebp-2Ch]
  int stop; // [esp+48h] [ebp-20h] BYREF
  int start[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  v1 = 0;
  if ( get_range_eol(&cp, start, &stop) )
  {
    opt_en[0] = -1;
    v2 = start[0];
    v3 = &n_lhs[start[0]];
    v4 = start[0];
    while ( v2 <= stop )
    {
      if ( *v3 )
      {
        simp_equation(v2);
        v4 = v2;
      }
      ++v2;
      ++v3;
    }
    stop = v4;
    v25 = 0;
    do
    {
      v5 = start[0];
      v6 = &rhs[start[0]];
      n = (int *)(4 * start[0] + 134715712);
      flag = 0;
      while ( v5 <= stop )
      {
        for ( i = start[0]; i <= stop; ++i )
        {
          if ( v5 != i )
          {
            while ( find_more(*v6, n, i) )
            {
              flag = 1;
              v25 = 1;
            }
          }
        }
        ++v5;
        ++v6;
        ++n;
      }
    }
    while ( flag );
    na = start[0];
    v21 = &n_lhs[start[0]];
    v22 = &rhs[start[0]];
    v23 = &n_rhs[start[0]];
    v24 = (token_type **)(4 * start[0] + 134752832);
    v19 = v21;
    start_en = 0;
    while ( na <= stop )
    {
      if ( *v21 )
      {
        do
        {
          simp_equation(na);
          np = 0;
          for ( j = 0; opt_en[j] >= 0; ++j )
          {
            simp_equation(opt_en[j]);
            if ( opt_en[j] != na )
            {
              while ( find_more(*v24, v19, opt_en[j]) )
                np = 1;
              while ( find_more(*v22, v23, opt_en[j]) )
                np = 1;
            }
          }
        }
        while ( np );
        while ( opt_es(*v24, v19) )
          v25 = 1;
        while ( opt_es(*v22, v23) )
          v25 = 1;
        if ( v25 )
        {
          for ( npa = &opt_en[start_en]; *npa >= 0; ++npa )
          {
            v12 = &opt_en[start_en];
            v13 = start_en;
            while ( *v12 >= 0 )
            {
              v9 = v13 + 1;
              k = v9;
              if ( v12[1] >= 0 )
              {
                v10 = &opt_en[v9];
                do
                {
                  while ( find_more(rhs[*v10], &n_rhs[*v10], *v12) )
                    ;
                  while ( find_more(rhs[*v12], &n_rhs[*v12], *v10) )
                    ;
                  v11 = v10[1];
                  ++v10;
                }
                while ( v11 >= 0 );
              }
              ++v12;
              v13 = k;
            }
            while ( opt_es(rhs[*npa], &n_rhs[*npa]) )
              ;
          }
          v14 = &opt_en[start_en];
          while ( 1 )
          {
            v15 = *v14++;
            if ( v15 < 0 )
              break;
            list_sub(v15);
            ++start_en;
          }
          list_sub(na);
        }
      }
      ++na;
      ++v21;
      ++v22;
      ++v23;
      ++v24;
      ++v19;
    }
    v1 = v25;
    if ( !v25 )
      error("Unable to find any repeated expressions.");
  }
  return v1;
}

//----- (0805699C) --------------------------------------------------------
int __usercall sum_product@<eax>(char *cp@<eax>, int product_flag@<edx>)
{
  int v3; // ebx
  token_type *v4; // esi
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst5
  char v10; // c2
  int v11; // eax
  token_type *v12; // edx
  int v13; // eax
  int v14; // ecx
  token_type *v15; // eax
  int v16; // edx
  long double v17; // fst7
  double step; // [esp+30h] [ebp-1058h]
  double end; // [esp+38h] [ebp-1050h]
  int result_equation; // [esp+44h] [ebp-1044h]
  double start; // [esp+48h] [ebp-1040h]
  token_type *source; // [esp+54h] [ebp-1034h]
  const char *cp1; // [esp+58h] [ebp-1030h]
  const char *cp1a; // [esp+58h] [ebp-1030h]
  char *cp1b; // [esp+58h] [ebp-1030h]
  _BOOL4 cp1c; // [esp+58h] [ebp-1030h]
  char *cpa[2]; // [esp+5Ch] [ebp-102Ch] BYREF
  int n; // [esp+64h] [ebp-1024h] BYREF
  int v; // [esp+68h] [ebp-1020h] BYREF
  char buf[4096]; // [esp+6Ch] [ebp-101Ch] BYREF
  unsigned int v32; // [esp+106Ch] [ebp-1Ch]

  cpa[0] = cp;
  v32 = __readgsdword(0x14u);
  v = 0;
  if ( current_not_defined() )
    return 0;
  result_equation = next_espace();
  v3 = n_rhs[cur_equation];
  if ( v3 )
  {
    source = rhs[cur_equation];
    v4 = rhs[result_equation];
  }
  else
  {
    v3 = n_lhs[cur_equation];
    source = lhs[cur_equation];
    v4 = lhs[result_equation];
  }
  if ( *cpa[0] )
  {
    cpa[0] = parse_var2(&v, cpa[0]);
    if ( !cpa[0] )
      return 0;
  }
  if ( no_vars(source, v3, &v) )
  {
    error("Current expression contains no variables.");
    return 0;
  }
  if ( !v && !prompt_var(&v) )
    return 0;
  if ( !found_var(source, v3, v) )
  {
    error("Variable not found.");
    return 0;
  }
  if ( *cpa[0] )
  {
    if ( *cpa[0] == 61 )
      ++cpa[0];
    cp1 = cpa[0];
    v6 = strtod(cpa[0], cpa);
    goto LABEL_19;
  }
  list_var(v, 0);
  __snprintf_chk(prompt_str, 80, 1, 80, "%s = ", var_str);
  cp1 = get_string(buf, 4096);
  if ( !cp1 )
    return 0;
  v6 = strtod(cp1, cpa);
LABEL_19:
  start = v6;
  if ( cp1 == cpa[0] )
  {
LABEL_20:
    error("Number expected.");
    return 0;
  }
  if ( fabs(start) >= 1.0e15 )
    goto LABEL_22;
  cpa[0] = skip_space(cpa[0]);
  if ( !strcmp_tospace(cpa[0], (char *)"to") )
    cpa[0] = skip_param(cpa[0]);
  cp1a = cpa[0];
  if ( !*cpa[0] )
  {
    my_strlcpy(prompt_str, "To: ", 80);
    cp1a = get_string(buf, 4096);
    if ( !cp1a )
      return 0;
  }
  end = strtod(cp1a, cpa);
  if ( cp1a == cpa[0] )
    goto LABEL_20;
  if ( fabs(end) >= 1.0e15 )
  {
LABEL_22:
    error("Number too large.");
    return 0;
  }
  cp1b = skip_space(cpa[0]);
  cpa[0] = cp1b;
  if ( *cp1b )
  {
    v7 = strtod(cp1b, cpa);
    if ( cp1b == cpa[0] || (step = fabs(v7), step <= 0.0) || step >= 1.0e15 )
    {
      error("Invalid step.");
      return 0;
    }
  }
  else
  {
    step = 1.0;
  }
  if ( extra_characters(cpa[0]) )
    return 0;
  cp1c = start > (long double)end;
  v8 = fabs(start - end) / step;
  do
    v8 = __FPREM__(v8, 1.0);
  while ( v10 );
  if ( v8 != 0.0 )
    warning("End value not reached.");
  if ( product_flag )
    *v4 = one_token;
  else
    *v4 = zero_token;
  n = 1;
  while ( cp1c ? start >= (long double)end : end >= (long double)start )
  {
    if ( v3 + n + 1 > n_tokens )
      error_huge();
    memmove(tlhs, source, 16 * v3);
    n_tlhs = v3;
    if ( v3 > 0 )
    {
      v11 = 0;
      do
      {
        v12 = &tlhs[v11];
        if ( v12->kind == VARIABLE && v12->token.variable == v )
        {
          v12->kind = CONSTANT;
          tlhs[v11].token.constant = start;
        }
        v11 += 2;
      }
      while ( n_tlhs > v11 );
      if ( n_tlhs > 0 )
      {
        v13 = 0;
        do
          ++tlhs[v13++].level;
        while ( n_tlhs > v13 );
      }
    }
    v14 = n;
    if ( n > 0 )
    {
      v15 = v4;
      v16 = 0;
      do
      {
        ++v15->level;
        ++v16;
        v14 = n;
        ++v15;
      }
      while ( n > v16 );
    }
    v4[v14].kind = OPERATOR;
    v4[n].level = 1;
    if ( product_flag )
      v4[n].token.variable = 3;
    else
      v4[n].token.variable = 1;
    memmove(&v4[++n], tlhs, 16 * n_tlhs);
    n += n_tlhs;
    calc_simp(v4, &n);
    if ( cp1c )
      v17 = start - step;
    else
      v17 = start + step;
    start = v17;
  }
  if ( n_rhs[cur_equation] )
  {
    n_rhs[result_equation] = n;
    memmove(lhs[result_equation], lhs[cur_equation], 16 * n_lhs[cur_equation]);
    n_lhs[result_equation] = n_lhs[cur_equation];
  }
  else
  {
    n_lhs[result_equation] = n;
  }
  return return_result(result_equation);
}
// 8056DA1: variable 'v10' is possibly undefined
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080570C8) --------------------------------------------------------
int __cdecl product_cmd(char *cp)
{
  return sum_product(cp, 1);
}

//----- (080570DD) --------------------------------------------------------
int __cdecl sum_cmd(char *cp)
{
  return sum_product(cp, 0);
}

//----- (080570F2) --------------------------------------------------------
int __cdecl solve_cmd(char *cp)
{
  char *v1; // esi
  int v3; // ebx
  int v4; // edi
  char *v5; // eax
  char *v6; // eax
  int v7; // eax
  token_type *v8; // ecx
  int v9; // esi
  int i; // edi
  int v11; // eax
  int plural_flag; // [esp+24h] [ebp-1044h]
  int *np; // [esp+28h] [ebp-1040h]
  int *v14; // [esp+2Ch] [ebp-103Ch]
  token_type want; // [esp+34h] [ebp-1034h] BYREF
  int diff_sign; // [esp+44h] [ebp-1024h] BYREF
  int v; // [esp+48h] [ebp-1020h] BYREF
  char buf[4096]; // [esp+4Ch] [ebp-101Ch] BYREF
  unsigned int v19; // [esp+104Ch] [ebp-1Ch]

  v1 = cp;
  v19 = __readgsdword(0x14u);
  if ( cur_equation < 0 || cur_equation >= n_equations || n_lhs[cur_equation] <= 0 || n_rhs[cur_equation] <= 0 )
  {
    error("No current equation.");
    return 0;
  }
  v3 = next_espace();
  v4 = 0;
  if ( !strcmp_tospace(cp, "verify") )
  {
    v1 = skip_param(cp);
    LOWORD(v4) = 1;
  }
  if ( strcmp_tospace(v1, "for") || (v5 = skip_param(v1), !*v5) )
  {
    if ( !*v1 )
    {
      my_strlcpy(prompt_str, "Enter variable to solve for: ", 80);
      v1 = get_string(buf, 4096);
      if ( !v1 )
        return 0;
    }
  }
  else
  {
    v1 = v5;
  }
  if ( !v4 )
  {
    if ( parse_equation(v3, v1) && solve_espace(v3, cur_equation) )
      return return_result(cur_equation);
    goto LABEL_47;
  }
  v6 = parse_var2(&v, v1);
  if ( !v6 || extra_characters(v6) )
    return 0;
  copy_espace(cur_equation, v3);
  want.level = 1;
  want.kind = VARIABLE;
  want.token.variable = v;
  if ( solve_sub(
         &want,
         1,
         lhs[cur_equation],
         (int *)(4 * cur_equation + 134753664),
         rhs[cur_equation],
         &n_rhs[cur_equation]) <= 0 )
  {
    __printf_chk(1, "Solve failed.\n");
LABEL_47:
    n_lhs[v3] = 0;
    n_rhs[v3] = 0;
    return 0;
  }
  return_result(cur_equation);
  if ( !compare_es(cur_equation, v3) )
  {
    v7 = n_rhs[cur_equation];
    if ( v7 > 0 )
    {
      v8 = rhs[cur_equation];
      v9 = 0;
      while ( v8->kind != VARIABLE || (v8->token.variable & 0x3FFF) != 4 )
      {
        v9 += 2;
        v8 += 2;
        if ( v9 >= v7 )
          goto LABEL_28;
      }
      plural_flag = 1;
    }
    else
    {
LABEL_28:
      plural_flag = 0;
    }
    np = (int *)(4 * v3 + 134753664);
    subst_var_with_exp(lhs[v3], np, rhs[cur_equation], v7, v);
    v14 = (int *)(4 * v3 + 134715712);
    subst_var_with_exp(rhs[v3], v14, rhs[cur_equation], n_rhs[cur_equation], v);
    calc_simp(lhs[v3], np);
    calc_simp(rhs[v3], v14);
    for ( i = 0; ; LOWORD(i) = 1 )
    {
      if ( exp_contains_infinity(lhs[v3], n_lhs[v3]) || exp_contains_infinity(rhs[v3], n_rhs[v3]) )
      {
        v11 = 1;
      }
      else
      {
        if ( se_compare(lhs[v3], n_lhs[v3], rhs[v3], n_rhs[v3], &diff_sign) && !diff_sign )
        {
          if ( plural_flag )
            __printf_chk(1, "Solutions verified.\n");
          else
            __printf_chk(1, "Solution verified.\n");
          n_lhs[v3] = 0;
          n_rhs[v3] = 0;
          return 1;
        }
        v11 = 0;
      }
      if ( v11 || i )
      {
        error("Solution might be incorrect.");
        n_lhs[v3] = 0;
        n_rhs[v3] = 0;
        return 2;
      }
      symb_flag = symblify;
      simpa_side(lhs[v3], np, 1, 0);
      simpa_side(rhs[v3], v14, 1, 0);
      symb_flag = 0;
    }
  }
  if ( debug_level >= 0 )
    __fprintf_chk(gfp, 1, "%s\n", "Nothing was done, so no need to verify solution.");
  n_lhs[v3] = 0;
  n_rhs[v3] = 0;
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08057638) --------------------------------------------------------
int __cdecl plot_cmd(char *cp)
{
  char *v1; // ebx
  int result; // eax
  char v3; // al
  int v4; // esi
  int v5; // edx
  char *v6; // edx
  char v7; // al
  char cl_0[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v9; // [esp+102Ch] [ebp-Ch]

  v1 = cp;
  v9 = __readgsdword(0x14u);
  if ( security_level )
  {
    error("Command disabled.");
    return 0;
  }
  v3 = *cp;
  v4 = 0;
  if ( *cp )
    goto LABEL_11;
  if ( current_not_defined() )
    return 0;
  v5 = n_rhs[cur_equation];
  v1 = v5 ? list_expression(rhs[cur_equation], v5, 3) : list_expression(lhs[cur_equation], n_lhs[cur_equation], 3);
  if ( !v1 )
    return 0;
  v3 = *v1;
  if ( *v1 )
  {
    v4 = 1;
LABEL_11:
    if ( v3 != 39 && v3 != 92 )
    {
      v6 = v1;
      while ( 1 )
      {
        v7 = *++v6;
        if ( !*v6 )
          goto LABEL_21;
        if ( v7 == 39 || v7 == 92 )
          goto LABEL_33;
      }
    }
    v6 = v1;
LABEL_33:
    if ( !v6 )
      goto LABEL_21;
    error("Invalid character in expression string.");
    if ( v4 )
    {
      free(v1);
      return 0;
    }
    return 0;
  }
  v4 = 1;
LABEL_21:
  if ( strchr(v1, 121) )
  {
    __printf_chk(1, "Performing 3D surface plot...\n");
    __snprintf_chk(cl_0, 4096, 1, 4096, "echo 'set grid; splot %s'|gnuplot -persist", v1);
  }
  else
  {
    __printf_chk(1, "Performing 2D plot...\n");
    __snprintf_chk(cl_0, 4096, 1, 4096, "echo 'set grid; plot %s'|gnuplot -persist", v1);
  }
  if ( v4 )
    free(v1);
  if ( shell_out(cl_0) )
  {
    error("Error trying to run gnuplot.");
    __printf_chk(1, "Command line = \"%s\".\n", cl_0);
    result = 0;
  }
  else
  {
    result = 1;
    if ( debug_level > 0 )
    {
      __printf_chk(1, "Command line = \"%s\".\n", cl_0);
      result = 1;
    }
  }
  return result;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (080578B1) --------------------------------------------------------
int __cdecl read_sub(FILE *fp)
{
  int v1; // ebx
  char *v2; // eax
  jmp_buf save_save; // [esp+14h] [ebp-A4h] BYREF

  memmove(save_save, jmp_save, 0x9Cu);
  v1 = _setjmp(jmp_save);
  if ( v1 )
  {
    clean_up();
    if ( v1 == 14 )
      error("Expression too large.");
  }
  else
  {
    while ( 1 )
    {
      v2 = fgets((char *)tlhs, 16 * n_tokens, fp);
      if ( !v2 )
        break;
      if ( !display_process(v2) )
        __longjmp_chk(jmp_save, 3);
    }
  }
  memmove(jmp_save, save_save, 0x9Cu);
  return v1;
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);

//----- (08057973) --------------------------------------------------------
int __cdecl read_file(char *cp)
{
  char *v1; // ebx
  FILE *v3; // esi
  int v4; // edi
  char buf[4096]; // [esp+2Ch] [ebp-101Ch] BYREF
  unsigned int v6; // [esp+102Ch] [ebp-1Ch]

  v1 = cp;
  v6 = __readgsdword(0x14u);
  if ( !*cp )
  {
    error("No file name specified.");
    return 0;
  }
  __snprintf_chk(buf, 4096, 1, 4096, "%s.in", cp);
  v3 = fopen(buf, "r");
  if ( v3 )
  {
    v1 = buf;
  }
  else
  {
    v3 = fopen(cp, "r");
    if ( !v3 )
    {
      error("Can't open input file.");
      return 0;
    }
  }
  v4 = read_sub(v3);
  if ( v4 )
  {
    __printf_chk(1, "Read operation aborted.\n");
  }
  else if ( !quiet_mode )
  {
    __printf_chk(1, "Finished reading file \"%s\".\n", v1);
  }
  fclose(v3);
  return v4 == 0;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08057A98) --------------------------------------------------------
int __cdecl read_cmd(char *cp)
{
  if ( security_level <= 2 )
    return read_file(cp);
  error("Command disabled.");
  return 0;
}

//----- (08057AC7) --------------------------------------------------------
int __usercall edit_sub@<eax>(char *cp@<eax>)
{
  char *v2; // eax
  char cl_0[4096]; // [esp+2Ch] [ebp-100Ch] BYREF
  unsigned int v5; // [esp+102Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  do
  {
    v2 = getenv("EDITOR");
    if ( !v2 )
    {
      error("EDITOR environment variable not set.");
      return 0;
    }
    __snprintf_chk(cl_0, 4096, 1, 4096, "%s %s", v2, cp);
    if ( shell_out(cl_0) )
    {
      error("Error executing editor, check EDITOR environment variable.");
      __printf_chk(1, "Command line = \"%s\".\n", cl_0);
      return 0;
    }
    clear_all();
  }
  while ( !read_cmd(cp) && pause_cmd("Prepare to rerun the editor") );
  return 1;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08057BBF) --------------------------------------------------------
int __cdecl edit_cmd(char *cp)
{
  int v1; // ebx
  int v2; // eax
  FILE *v3; // eax
  FILE *v4; // ebx
  char tmp_file[4096]; // [esp+1Ch] [ebp-100Ch] BYREF
  unsigned int v7; // [esp+101Ch] [ebp-Ch]

  v7 = __readgsdword(0x14u);
  if ( security_level )
  {
    error("Command disabled.");
    v1 = 0;
  }
  else
  {
    clean_up();
    if ( *cp )
    {
      if ( access(cp, 6) )
      {
        error("You can only edit existing/writable files or all equations.");
        v1 = 0;
      }
      else
      {
        v1 = edit_sub(cp);
      }
    }
    else
    {
      my_strlcpy(tmp_file, "/tmp/mathomatic.XXXXXX", 4096);
      v2 = mkstemp(tmp_file);
      if ( v2 >= 0 && (v3 = fdopen(v2, "w+"), (v4 = v3) != 0) )
      {
        gfp = v3;
        high_prec = 1;
        list_cmd("all");
        high_prec = 0;
        gfp = default_out;
        fclose(v4);
        v1 = edit_sub(tmp_file);
        unlink(tmp_file);
      }
      else
      {
        error("Can't create temporary file.");
        v1 = 0;
      }
    }
  }
  return v1;
}

//----- (08057CF9) --------------------------------------------------------
int __cdecl display_cmd(char *cp)
{
  int v1; // eax
  char *v2; // ebx
  int k; // eax
  bool v4; // cc
  int v5; // eax
  int factor_flag; // [esp+18h] [ebp-C0h]
  int displayed; // [esp+1Ch] [ebp-BCh]
  jmp_buf save_save; // [esp+2Ch] [ebp-ACh] BYREF
  int j; // [esp+C8h] [ebp-10h] BYREF
  int i[3]; // [esp+CCh] [ebp-Ch] BYREF

  v1 = strcmp_tospace(cp, "factor");
  factor_flag = v1 == 0;
  if ( !v1 )
    cp = skip_param(cp);
  displayed = 0;
  while ( 1 )
  {
    v2 = cp;
    if ( !get_range(&cp, i, &j) )
      return 0;
    if ( *cp && v2 == cp )
      break;
    for ( k = i[0]; j >= k; i[0] = k )
    {
      if ( n_lhs[k] > 0 )
      {
        memmove(save_save, jmp_save, 0x9Cu);
        if ( _setjmp(jmp_save) )
        {
          memmove(jmp_save, save_save, 0x9Cu);
          __printf_chk(1, "Skipping equation number %d.\n", i[0] + 1);
        }
        else
        {
          make_fractions_and_group(i[0]);
          if ( factor_flag || factor_int_flag )
            factor_int_sub(i[0]);
          memmove(jmp_save, save_save, 0x9Cu);
          v4 = flist_equation(i[0]) <= 0;
          v5 = 1;
          if ( v4 )
            v5 = displayed;
          displayed = v5;
        }
      }
      k = i[0] + 1;
    }
    if ( !*cp )
      return displayed;
  }
  error("Invalid argument.");
  return 0;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08057EB0) --------------------------------------------------------
int __cdecl eliminate_cmd(char *cp)
{
  char *v1; // eax
  int v2; // ebx
  int v3; // edi
  int v4; // eax
  token_type *v5; // edx
  int v6; // ecx
  int j; // ebx
  int v8; // esi
  token_type *v9; // edx
  int v10; // ecx
  bool v11; // al
  _BOOL4 v12; // esi
  int v13; // eax
  int v14; // esi
  int v15; // edx
  bool v16; // cc
  int did_something; // [esp+14h] [ebp-2044h]
  char *cp_start; // [esp+18h] [ebp-2040h]
  int success_flag; // [esp+1Ch] [ebp-203Ch]
  int v21; // [esp+20h] [ebp-2038h]
  int vc; // [esp+24h] [ebp-2034h]
  int i; // [esp+28h] [ebp-2030h]
  char *cp_0; // [esp+2Ch] [ebp-202Ch] BYREF
  int va[1000]; // [esp+34h] [ebp-2024h]
  int v; // [esp+FD4h] [ebp-1084h] BYREF
  char buf[4096]; // [esp+FD8h] [ebp-1080h] BYREF
  char used[100]; // [esp+1FD8h] [ebp-80h] BYREF
  unsigned int v29; // [esp+203Ch] [ebp-1Ch]

  cp_0 = cp;
  v29 = __readgsdword(0x14u);
  memset(used, 0, sizeof(used));
  if ( current_not_defined() )
    return 0;
  if ( !strcmp_tospace(cp_0, "repeat") )
  {
    repeat_flag = 1;
    cp_0 = skip_param(cp_0);
  }
  if ( !*cp_0 )
  {
    my_strlcpy(prompt_str, "Enter variables to eliminate: ", 80);
    v1 = get_string(buf, 4096);
    cp_0 = v1;
    if ( !v1 || !*v1 )
      return 0;
  }
  cp_start = cp_0;
  did_something = 0;
  success_flag = 0;
  v2 = 0;
  vc = 0;
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_8:
      while ( vc )
      {
        v = va[--vc];
LABEL_49:
        v11 = strcmp_tospace(cp_0, "using") == 0;
        v12 = v11;
        if ( v11 )
        {
          cp_0 = skip_param(cp_0);
          v2 = decstrtol(cp_0, &cp_0) - 1;
          if ( not_defined(v2) )
            return 0;
        }
        if ( var_in_equation(cur_equation, v) )
        {
          if ( v12 )
          {
            if ( elim_sub(v2, v) )
              goto LABEL_68;
          }
          else
          {
            v2 = cur_equation;
            v13 = n_equations;
            if ( n_equations > 1 )
            {
              v14 = 1;
              while ( 1 )
              {
                v15 = v2 - 1;
                v16 = v2 <= 0;
                v2 = v13 - 1;
                if ( !v16 )
                  v2 = v15;
                if ( !used[v2] && n_lhs[v2] && n_rhs[v2] && var_in_equation(v2, v) && elim_sub(v2, v) )
                  break;
                ++v14;
                v13 = n_equations;
                if ( n_equations <= v14 )
                  goto LABEL_8;
              }
LABEL_68:
              used[v2] = 1;
              did_something = 1;
              success_flag = 1;
            }
          }
        }
        else if ( !repeat_flag )
        {
          list_var(v, 0);
          __printf_chk(1, "Variable (%s) not found in current equation.\n", var_str);
        }
      }
      if ( !*cp_0 )
        break;
      if ( !is_all(cp_0) )
      {
        cp_0 = parse_var2(&v, cp_0);
        if ( !cp_0 )
          return 0;
        goto LABEL_49;
      }
      cp_0 = skip_param(cp_0);
      v21 = cur_equation;
      v3 = n_lhs[cur_equation];
      for ( i = 0; ; i = v4 )
      {
        v4 = -1;
        if ( v3 > 0 )
        {
          v5 = lhs[v21];
          v6 = 0;
          for ( j = -1; ; j = v4 )
          {
            if ( v5->kind == VARIABLE && (v4 = v5->token.variable, i < v4) )
            {
              if ( j != -1 && v4 > j )
                v4 = j;
            }
            else
            {
              v4 = j;
            }
            v6 += 2;
            v5 += 2;
            if ( v6 >= v3 )
              break;
          }
        }
        v8 = n_rhs[v21];
        v2 = 0;
        if ( v8 > 0 )
        {
          v9 = rhs[v21];
          while ( 1 )
          {
            if ( v9->kind == VARIABLE && (v10 = v9->token.variable, i < v10) )
            {
              if ( v4 != -1 && v10 > v4 )
                v10 = v4;
            }
            else
            {
              v10 = v4;
            }
            v2 += 2;
            v9 += 2;
            if ( v8 <= v2 )
              break;
            v4 = v10;
          }
          v4 = v10;
        }
        if ( v4 == -1 )
          break;
        if ( (v4 & 0x3FFFu) > 4 )
        {
          if ( vc > 999 )
            goto LABEL_8;
          va[vc++] = v4;
        }
      }
    }
    if ( !repeat_flag || !success_flag )
      break;
    cp_0 = cp_start;
    success_flag = 0;
  }
  if ( did_something )
    return return_result(cur_equation);
  error("No substitutions made.");
  return did_something;
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08058321) --------------------------------------------------------
int __cdecl simplify_cmd(char *cp)
{
  int v1; // edi
  int v2; // edx
  int result; // eax
  int k; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  token_type *v8; // edi
  int v9; // edx
  int v10; // ecx
  int l; // eax
  token_type *v12; // edi
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  int v17; // ecx
  token_type *v18; // edx
  int v19; // eax
  int v20; // ecx
  token_type *v21; // edx
  int v22; // ebx
  int v23; // eax
  int v24; // ebx
  int counter_max; // [esp+28h] [ebp-260h]
  int v26; // [esp+2Ch] [ebp-25Ch]
  int v27; // [esp+30h] [ebp-258h]
  int quick_flag; // [esp+34h] [ebp-254h]
  int quickest_flag; // [esp+38h] [ebp-250h]
  int counter; // [esp+3Ch] [ebp-24Ch]
  int v31; // [esp+44h] [ebp-244h]
  int n; // [esp+48h] [ebp-240h]
  int na; // [esp+48h] [ebp-240h]
  char *cp_0; // [esp+4Ch] [ebp-23Ch] BYREF
  int previous_solution_number[100]; // [esp+54h] [ebp-234h] BYREF
  int j; // [esp+1E4h] [ebp-A4h] BYREF
  int i; // [esp+1E8h] [ebp-A0h] BYREF
  sign_array_type sa_value; // [esp+1ECh] [ebp-9Ch]
  sign_array_type sa_mark; // [esp+22Ch] [ebp-5Ch] BYREF
  unsigned int v40; // [esp+26Ch] [ebp-1Ch]

  cp_0 = cp;
  v40 = __readgsdword(0x14u);
  v27 = 0;
  v1 = 0;
  quickest_flag = 0;
  quick_flag = 0;
  n = 0;
  while ( 1 )
  {
    if ( !strncasecmp(cp_0, "sign", 4u) )
    {
      v1 = 1;
      goto LABEL_12;
    }
    if ( !strncasecmp(cp_0, "symbolic", 4u) )
    {
      n = 1;
      goto LABEL_12;
    }
    if ( !strcmp_tospace(cp_0, "quickest") )
    {
      quickest_flag = 1;
      goto LABEL_12;
    }
    if ( !strcmp_tospace(cp_0, "quick") )
    {
      quick_flag = 1;
      goto LABEL_12;
    }
    if ( strncasecmp(cp_0, "fraction", 4u) )
      break;
    v27 = 1;
LABEL_12:
    cp_0 = skip_param(cp_0);
  }
  v26 = v1;
  v2 = get_range_eol(&cp_0, &i, &j);
  result = 0;
  if ( !v2 )
    return result;
  symb_flag = n;
  for ( k = i; j >= k; i = k )
  {
    if ( n_lhs[k] )
    {
      if ( quickest_flag )
      {
        simp_equation(k);
      }
      else
      {
        simpa_repeat_side(lhs[k], &n_lhs[k], quick_flag, v27);
        simpa_repeat_side(rhs[i], &n_rhs[i], quick_flag, v27);
      }
      result = return_result(i);
      if ( !result )
      {
        symb_flag = 0;
        return result;
      }
      if ( v26 )
      {
        v5 = 0;
        memset(previous_solution_number, 0, sizeof(previous_solution_number));
        memset(sa_mark, 0, sizeof(sa_mark));
        v6 = i;
        v7 = n_lhs[i];
        if ( v7 > 0 )
        {
          do
          {
            v8 = &lhs[v6][v5];
            if ( v8->kind == VARIABLE && (v8->token.variable & 0x3FFF) == 4 )
              sa_mark[(v8->token.variable >> 14) & 0x3F] = 1;
            v5 += 2;
          }
          while ( v7 > v5 );
        }
        v9 = i;
        v10 = n_rhs[i];
        if ( v10 > 0 )
        {
          for ( l = 0; l < v10; l += 2 )
          {
            v12 = &rhs[v9][l];
            if ( v12->kind == VARIABLE && (v12->token.variable & 0x3FFF) == 4 )
              sa_mark[(v12->token.variable >> 14) & 0x3F] = 1;
          }
        }
        v13 = 0;
        v14 = 0;
        do
          v14 -= (sa_mark[v13++] == 0) - 1;
        while ( v13 != 64 );
        if ( v14 )
        {
          LOBYTE(v13) = 1;
          counter_max = (v13 << v14) - 1;
          if ( counter_max >= 0 )
          {
            v31 = 1;
            for ( counter = 0; counter <= counter_max; ++counter )
            {
              na = next_espace();
              copy_espace(i, na);
              v15 = 0;
              v16 = 0;
              do
              {
                if ( sa_mark[v15] )
                  sa_value[v15] = (counter >> v16++) & 1;
                ++v15;
              }
              while ( v15 != 64 );
              if ( n_lhs[na] > 0 )
              {
                LOBYTE(v15) = 0;
                do
                {
                  v17 = v15;
                  v18 = &lhs[na][v15];
                  if ( v18->kind == VARIABLE && (v18->token.variable & 0x3FFF) == 4 )
                  {
                    if ( sa_value[(v18->token.variable >> 14) & 0x3F] )
                    {
                      v18->kind = CONSTANT;
                      lhs[na][v17].token.constant = -1.0;
                    }
                    else
                    {
                      v18->kind = CONSTANT;
                      lhs[na][v17].token.constant = 1.0;
                    }
                  }
                  v15 += 2;
                }
                while ( n_lhs[na] > v15 );
              }
              if ( n_rhs[na] > 0 )
              {
                v19 = 0;
                do
                {
                  v20 = v19;
                  v21 = &rhs[na][v19];
                  if ( v21->kind == VARIABLE && (v21->token.variable & 0x3FFF) == 4 )
                  {
                    if ( sa_value[(v21->token.variable >> 14) & 0x3F] )
                    {
                      v21->kind = CONSTANT;
                      rhs[na][v20].token.constant = -1.0;
                    }
                    else
                    {
                      v21->kind = CONSTANT;
                      rhs[na][v20].token.constant = 1.0;
                    }
                  }
                  v19 += 2;
                }
                while ( n_rhs[na] > v19 );
              }
              v22 = 0;
              v23 = 0;
              do
              {
                if ( sa_mark[v22] )
                {
                  if ( v23 )
                    __fprintf_chk(gfp, 1, ", ");
                  else
                    __fprintf_chk(gfp, 1, "Solution number %ld with ", v31);
                  list_var((v22 << 14) + 4, 0);
                  __fprintf_chk(gfp, 1, "%s = ", var_str);
                  if ( sa_value[v22] )
                    __fprintf_chk(gfp, 1, "-1");
                  else
                    __fprintf_chk(gfp, 1, "1");
                  v23 = 1;
                }
                ++v22;
              }
              while ( v22 != 64 );
              if ( v23 )
                __fprintf_chk(gfp, 1, ":\n");
              if ( quickest_flag )
              {
                simp_equation(na);
              }
              else
              {
                simpa_repeat_side(lhs[na], &n_lhs[na], quick_flag, v27);
                simpa_repeat_side(rhs[na], (int *)(4 * na + 134715712), quick_flag, v27);
              }
              v24 = 0;
              while ( !previous_solution_number[v24] || !compare_es(v24, na) )
              {
                if ( ++v24 == 100 )
                  goto LABEL_78;
              }
              n_lhs[na] = 0;
              n_rhs[na] = 0;
              __fprintf_chk(gfp, 1, "is identical to solution number %ld.\n", previous_solution_number[v24]);
LABEL_78:
              if ( n_lhs[na] )
              {
                list_sub(na);
                previous_solution_number[na] = v31;
              }
              ++v31;
            }
          }
        }
      }
    }
    k = i + 1;
  }
  symb_flag = 0;
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08058A78) --------------------------------------------------------
int __cdecl calculate_cmd(char *cp)
{
  token_type *v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ebx
  int k; // eax
  int v7; // edx
  int v8; // eax
  token_type *v9; // edx
  token_type *v10; // edx
  int v11; // ecx
  int l; // ebx
  int v13; // ecx
  token_type *v14; // eax
  int v15; // edx
  char v16; // cl
  int m; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  token_type *v22; // edx
  int v23; // eax
  int n; // ebx
  token_type *source; // [esp+28h] [ebp-10D0h]
  int v26; // [esp+2Ch] [ebp-10CCh]
  int value_entered; // [esp+30h] [ebp-10C8h]
  int v28; // [esp+34h] [ebp-10C4h]
  int counter_max; // [esp+38h] [ebp-10C0h]
  int i; // [esp+3Ch] [ebp-10BCh]
  int factor_flag; // [esp+40h] [ebp-10B8h]
  int counter; // [esp+44h] [ebp-10B4h]
  int j; // [esp+48h] [ebp-10B0h]
  int v34; // [esp+48h] [ebp-10B0h]
  char *cp_0; // [esp+4Ch] [ebp-10ACh] BYREF
  int diff_sign; // [esp+54h] [ebp-10A4h] BYREF
  int it_v; // [esp+58h] [ebp-10A0h] BYREF
  char buf[4096]; // [esp+5Ch] [ebp-109Ch] BYREF
  sign_array_type sa_value; // [esp+105Ch] [ebp-9Ch]
  sign_array_type sa_mark; // [esp+109Ch] [ebp-5Ch] BYREF
  unsigned int v41; // [esp+10DCh] [ebp-1Ch]

  cp_0 = cp;
  v41 = __readgsdword(0x14u);
  it_v = 0;
  if ( current_not_defined() )
    return 0;
  factor_flag = 0;
  while ( 1 )
  {
    if ( !strcmp_tospace(cp_0, "factor") )
    {
      factor_flag = 1;
      goto LABEL_7;
    }
    if ( strcmp_tospace(cp_0, "repeat") )
      break;
    repeat_flag = 1;
LABEL_7:
    cp_0 = skip_param(cp_0);
  }
  i = cur_equation;
  v28 = n_rhs[cur_equation];
  if ( v28 )
  {
    source = rhs[cur_equation];
  }
  else
  {
    source = lhs[cur_equation];
    v28 = n_lhs[cur_equation];
  }
  v26 = 1;
  if ( !*cp_0 )
    goto LABEL_22;
  cp_0 = parse_var2(&it_v, cp_0);
  if ( !cp_0 )
    return 0;
  if ( !found_var(source, v28, it_v) )
  {
    error("Specified iteration variable not found.");
    return 0;
  }
  if ( !*cp_0 )
  {
    my_strlcpy(prompt_str, "Enter number of iterations: ", 80);
    cp_0 = get_string(buf, 4096);
    if ( !cp_0 )
      return 0;
  }
  v26 = decstrtol(cp_0, &cp_0);
  if ( *cp_0 || v26 < 0 )
  {
    error("Positive integer required.");
    return 0;
  }
  if ( !v26 )
  {
    warning("Infinite iterations.");
    v26 = 2147483646;
  }
LABEL_22:
  while ( 2 )
  {
    n_trhs = v28;
    memmove(trhs, source, 16 * v28);
    if ( v28 > 0 )
    {
      value_entered = 0;
      for ( j = 0; ; j = v5 )
      {
        v2 = source;
        v3 = -1;
        v4 = 0;
        while ( 1 )
        {
          if ( v2->kind == VARIABLE && (v5 = v2->token.variable, j < v5) )
          {
            if ( v3 != -1 && v5 > v3 )
              v5 = v3;
          }
          else
          {
            v5 = v3;
          }
          v4 += 2;
          v2 += 2;
          if ( v28 <= v4 )
            break;
          v3 = v5;
        }
        if ( v5 == -1 )
          break;
        if ( (v5 & 0x3FFFu) > 4 && v5 != it_v )
        {
          list_var(v5, 0);
          __snprintf_chk(prompt_str, 80, 1, 80, "Enter %s: ", var_str);
          if ( get_expr(tlhs, &n_tlhs) )
          {
            v7 = n_tlhs;
            if ( n_tlhs > 0 )
            {
              v8 = 0;
              do
              {
                v9 = &tlhs[v8];
                if ( v9->kind == VARIABLE )
                  v9->token.variable = -v9->token.variable;
                v8 += 2;
                v7 = n_tlhs;
              }
              while ( n_tlhs > v8 );
            }
            subst_var_with_exp(trhs, &n_trhs, tlhs, v7, v5);
            value_entered = 1;
          }
        }
      }
    }
    else
    {
      value_entered = 0;
    }
    for ( k = 0; n_trhs > k; k += 2 )
    {
      v10 = &trhs[k];
      if ( v10->kind == VARIABLE )
      {
        v11 = v10->token.variable;
        if ( v11 < 0 )
          v10->token.variable = -v11;
      }
    }
    if ( it_v )
    {
      list_var(it_v, 0);
      __snprintf_chk(prompt_str, 80, 1, 80, "Enter initial %s: ", var_str);
      if ( !get_expr(tes, &n_tes) )
        return repeat_flag;
      calc_simp(tes, &n_tes);
      memmove(tlhs, trhs, 16 * n_trhs);
      n_tlhs = n_trhs;
      for ( l = 0; l < v26; ++l )
      {
        memmove(trhs, tlhs, 16 * n_tlhs);
        n_trhs = n_tlhs;
        subst_var_with_exp(trhs, &n_trhs, tes, n_tes, it_v);
        calc_simp(trhs, &n_trhs);
        if ( se_compare(trhs, n_trhs, tes, n_tes, &diff_sign) && !diff_sign )
        {
          __fprintf_chk(gfp, 1, "Convergence reached after %ld iterations.\n", l + 1);
          value_entered = 1;
          goto LABEL_61;
        }
        memmove(tes, trhs, 16 * n_trhs);
        n_tes = n_trhs;
      }
      value_entered = 1;
    }
LABEL_61:
    calc_simp(trhs, &n_trhs);
    memset(sa_mark, 0, sizeof(sa_mark));
    v13 = n_trhs;
    if ( n_trhs > 0 )
    {
      v14 = trhs;
      v15 = 0;
      do
      {
        if ( v14->kind == VARIABLE && (v14->token.variable & 0x3FFF) == 4 )
          sa_mark[(v14->token.variable >> 14) & 0x3F] = 1;
        v15 += 2;
        v14 += 2;
      }
      while ( v13 > v15 );
    }
    v16 = 0;
    for ( m = 0; m != 64; ++m )
      v16 -= (sa_mark[m] == 0) - 1;
    LOBYTE(m) = 1;
    v18 = m << v16;
    counter_max = v18 - 1;
    if ( v18 == 1 )
    {
      __fprintf_chk(gfp, 1, "\n");
    }
    else
    {
      __fprintf_chk(gfp, 1, "There are %ld solutions.\n", v18);
      __fprintf_chk(gfp, 1, "\n");
      if ( counter_max < 0 )
        goto LABEL_104;
    }
    counter = 0;
    do
    {
      memmove(tlhs, trhs, 16 * n_trhs);
      n_tlhs = n_trhs;
      v19 = 0;
      v20 = 0;
      v34 = n_trhs;
      do
      {
        if ( sa_mark[v20] )
          sa_value[v20] = (counter >> v19++) & 1;
        ++v20;
      }
      while ( v20 != 64 );
      if ( v34 > 0 )
      {
        LOBYTE(v20) = 0;
        do
        {
          v21 = v20;
          v22 = &tlhs[v20];
          if ( v22->kind == VARIABLE && (v22->token.variable & 0x3FFF) == 4 )
          {
            if ( sa_value[(v22->token.variable >> 14) & 0x3F] )
            {
              v22->kind = CONSTANT;
              tlhs[v21].token.constant = -1.0;
            }
            else
            {
              v22->kind = CONSTANT;
              tlhs[v21].token.constant = 1.0;
            }
          }
          v20 += 2;
        }
        while ( n_tlhs > v20 );
      }
      v23 = 0;
      for ( n = 0; n != 64; ++n )
      {
        if ( sa_mark[n] )
        {
          if ( v23 )
            __fprintf_chk(gfp, 1, ", ");
          else
            __fprintf_chk(gfp, 1, "Solution number %ld with ", counter + 1);
          list_var((n << 14) + 4, 0);
          __fprintf_chk(gfp, 1, "%s = ", var_str);
          if ( sa_value[n] )
            __fprintf_chk(gfp, 1, "-1");
          else
            __fprintf_chk(gfp, 1, "1");
          v23 = 1;
        }
      }
      if ( v23 )
        __fprintf_chk(gfp, 1, ":\n");
      calc_simp(tlhs, &n_tlhs);
      if ( factor_flag )
        simp_side(tlhs, &n_tlhs);
      __fprintf_chk(gfp, 1, " ");
      if ( n_rhs[i] )
      {
        list_proc(lhs[i], n_lhs[i], 0);
        __fprintf_chk(gfp, 1, " = ");
      }
      list_factor(tlhs, &n_tlhs, factor_flag);
      if ( n_tlhs <= 9 && make_fractions(tlhs, &n_tlhs) )
      {
        group_proc(tlhs, &n_tlhs);
        __fprintf_chk(gfp, 1, " = ");
        list_factor(tlhs, &n_tlhs, factor_flag);
      }
      __fprintf_chk(gfp, 1, "\n\n");
      ++counter;
    }
    while ( counter_max >= counter );
LABEL_104:
    if ( value_entered && repeat_flag )
      continue;
    return 1;
  }
}
// 8058F44: conditional instruction was optimized away because of '%var_10CC.4>=1'
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08059530) --------------------------------------------------------
void __usercall org_up_level(token_type *bp_0@<eax>, token_type *ep@<edx>, int level@<ecx>, int invert)
{
  int v4; // ebx
  int v5; // ebx

  if ( invert )
  {
    for ( ; ep >= bp_0; ++bp_0 )
    {
      v4 = bp_0->level - 1;
      bp_0->level = v4;
      if ( v4 == level && bp_0->kind == OPERATOR )
      {
        v5 = bp_0->token.variable;
        if ( v5 == 2 )
        {
          bp_0->token.variable = 1;
        }
        else if ( v5 > 2 )
        {
          if ( v5 == 3 )
          {
            bp_0->token.variable = 4;
          }
          else if ( v5 == 4 )
          {
            bp_0->token.variable = 3;
          }
        }
        else if ( v5 == 1 )
        {
          bp_0->token.variable = 2;
        }
      }
    }
  }
  else
  {
    for ( ; ep >= bp_0; ++bp_0 )
      --bp_0->level;
  }
}

//----- (080595E1) --------------------------------------------------------
int __usercall org_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int *elocp)
{
  token_type *v5; // edi
  int v6; // ebx
  token_type *v7; // ecx
  token_type *i; // eax
  int v9; // edx
  int v10; // esi
  token_type *v11; // edx
  int v12; // ebx
  token_type *v13; // esi
  int v14; // eax
  int v15; // eax
  int op; // [esp+30h] [ebp-38h]
  int eloc; // [esp+34h] [ebp-34h]
  token_type *bp_0; // [esp+38h] [ebp-30h]
  int sub_eloc[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  bp_0 = &equation[loc];
  v5 = &equation[*np];
  v6 = bp_0->level;
  v7 = bp_0 + 1;
  for ( i = bp_0 + 1; v5 > i; i += 2 )
  {
    v9 = i->level;
    if ( v9 < v6 )
    {
      if ( v9 < level )
        break;
      v6 = i->level;
    }
  }
  eloc = i - equation - 1;
  if ( elocp )
    *elocp = i - equation - 1;
  if ( eloc != loc )
  {
    if ( level < v6 && bp_0 < i )
    {
      v11 = bp_0;
      do
      {
        v11->level += level - v6;
        ++v11;
      }
      while ( v11 < i );
    }
    if ( v7 < i )
    {
      if ( bp_0[1].level == level )
      {
LABEL_20:
        op = v7->token.variable;
LABEL_23:
        if ( loc > eloc )
          return op;
        v12 = loc;
        while ( 1 )
        {
          v13 = &equation[v12];
          if ( level < v13->level )
            break;
LABEL_39:
          v12 += 2;
          if ( eloc < v12 )
            return op;
        }
        v14 = org_recurse(equation, np, v12, level + 1, sub_eloc);
        if ( v14 >= 1 )
        {
          if ( v14 > 2 )
          {
            if ( v14 > 4 || (unsigned int)(op - 3) > 1 )
              goto LABEL_38;
            v15 = 0;
            if ( loc <= v12 - 1 )
              v15 = equation[v12 - 1].token.variable == 4;
            goto LABEL_37;
          }
          if ( (unsigned int)(op - 1) <= 1 )
          {
            v15 = 0;
            if ( loc <= v12 - 1 )
              v15 = equation[v12 - 1].token.variable == 2;
LABEL_37:
            org_up_level(v13, &equation[sub_eloc[0]], level, v15);
            goto LABEL_38;
          }
        }
LABEL_38:
        v12 = sub_eloc[0];
        goto LABEL_39;
      }
      while ( 1 )
      {
        v7 += 2;
        if ( v7 >= i )
          break;
        if ( v7->level == level )
          goto LABEL_20;
      }
    }
    op = 0;
    goto LABEL_23;
  }
  v10 = level - 1;
  if ( level - 1 <= 0 )
    v10 = 1;
  bp_0->level = v10;
  return 0;
}

//----- (080597BE) --------------------------------------------------------
int __cdecl simpb_vcmp(sort_type *p1, sort_type *p2)
{
  int v2; // esi
  int v3; // ebx
  int v4; // eax
  int v5; // edx
  int result; // eax
  int v7; // [esp+0h] [ebp-14h]

  v2 = p1->v;
  v7 = p1->v & 0x3FFF;
  v3 = p2->v;
  if ( (v7 != 4) == ((p2->v & 0x3FFF) == 4) )
  {
    result = 1;
    if ( v7 != 4 )
      return result;
  }
  else
  {
    v4 = p2->count;
    v5 = p1->count;
    if ( v4 != v5 )
      return v4 - v5;
    if ( v2 >= v3 )
      return v2 != v3;
  }
  return -1;
}

//----- (08059835) --------------------------------------------------------
int __cdecl div_imaginary(token_type *equation, int *np)
{
  token_type *v2; // edi
  int v3; // ecx
  token_type *v4; // ebx
  int v5; // esi
  token_type *v6; // eax
  int v7; // edx
  int v8; // esi
  int v9; // esi
  int v10; // edi
  int v11; // edx
  int j; // eax
  int v13; // edx
  int v14; // edx
  int v15; // ebx
  int v16; // edx
  int v17; // eax
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v21; // esi
  token_type *v22; // eax
  signed int v24; // [esp+1Ch] [ebp-4Ch]
  int biloc; // [esp+20h] [ebp-48h]
  int op; // [esp+24h] [ebp-44h]
  int v27; // [esp+28h] [ebp-40h]
  token_type *v28; // [esp+2Ch] [ebp-3Ch]
  token_type *dest; // [esp+30h] [ebp-38h]
  int eiloc; // [esp+34h] [ebp-34h]
  int eiloca; // [esp+34h] [ebp-34h]
  token_type *src; // [esp+38h] [ebp-30h]
  int v33; // [esp+3Ch] [ebp-2Ch]
  int v34; // [esp+3Ch] [ebp-2Ch]
  int iloc; // [esp+40h] [ebp-28h]
  signed int v36; // [esp+44h] [ebp-24h]
  size_t v37; // [esp+44h] [ebp-24h]
  int i; // [esp+48h] [ebp-20h]
  int level; // [esp+4Ch] [ebp-1Ch]
  int levela; // [esp+4Ch] [ebp-1Ch]

  v33 = *np;
  if ( *np <= 1 )
    return 0;
  v2 = equation + 1;
  v36 = 2;
  i = 1;
  while ( 1 )
  {
    v28 = v2;
    if ( v2->token.variable == 4 )
    {
      v3 = v2->level;
      level = v3;
      v24 = v36;
      if ( v33 > v36 )
      {
        v4 = v2 + 1;
        v5 = v2[1].level;
        if ( v3 < v5 )
          break;
      }
    }
LABEL_42:
    i += 2;
    v2 += 2;
    v36 += 2;
    if ( v33 <= i )
      return 0;
  }
  v6 = v2 + 2;
  v27 = i;
  v7 = v36;
  iloc = -1;
  eiloc = -1;
  biloc = -1;
  op = 0;
  while ( 1 )
  {
    if ( v4->kind == OPERATOR && v5 == v3 + 1 )
    {
      op = v4->token.variable;
      if ( iloc < 0 || eiloc >= 0 )
      {
        v27 = v7;
      }
      else
      {
        eiloc = v7;
        v27 = v7;
      }
      goto LABEL_18;
    }
    if ( v4->kind == VARIABLE && v4->token.variable == 3 )
      break;
LABEL_18:
    if ( ++v7 < v33 )
    {
      v4 = v6;
      v5 = v6->level;
      ++v6;
      if ( v3 < v5 )
        continue;
    }
    goto LABEL_20;
  }
  if ( iloc < 0 )
  {
    biloc = v27 + 1;
    iloc = v7;
    goto LABEL_18;
  }
  op = 0;
LABEL_20:
  if ( iloc >= 0 )
  {
    v8 = eiloc;
    if ( eiloc < 0 )
      v8 = v7;
    eiloc = v8;
  }
  if ( iloc < 0 || (unsigned int)(op - 1) > 1 )
    goto LABEL_42;
  src = &equation[iloc];
  v9 = src->level;
  if ( v3 + 1 == v9 )
    goto LABEL_33;
  if ( v3 + 2 != v9
    || biloc < iloc && equation[iloc - 1].token.variable != 3
    || eiloc > iloc + 1 && (unsigned int)(equation[iloc + 1].token.variable - 3) > 1 )
  {
    goto LABEL_42;
  }
  v9 = v3 + 2;
LABEL_33:
  v10 = v7 + ~i;
  eiloca = eiloc - biloc;
  if ( eiloca + v10 + v33 + 7 > n_tokens )
    error_huge();
  v37 = v10;
  dest = &equation[i + 1];
  memmove(scratch, dest, 16 * v10);
  v11 = iloc + ~i;
  scratch[v11].kind = CONSTANT;
  scratch[v11].token.constant = 0.0;
  if ( v10 > 0 )
  {
    for ( j = 0; j != v10; ++j )
      scratch[j].level += 2;
  }
  v34 = level + 2;
  scratch[v37].level = level + 2;
  scratch[v10].kind = OPERATOR;
  scratch[v37].token.variable = 6;
  v13 = v10 + 1;
  scratch[v13].level = level + 2;
  scratch[v13].kind = CONSTANT;
  scratch[v13].token.constant = 2.0;
  v14 = v10 + 2;
  scratch[v14].level = level + 1;
  scratch[v14].kind = OPERATOR;
  scratch[v14].token.variable = 1;
  levela = v10 + 3;
  memmove(&scratch[v10 + 3], &equation[biloc], 16 * eiloca);
  v15 = eiloca + v10 + 3;
  if ( levela < eiloca + levela )
  {
    v16 = v10 + 3;
    v17 = v10 + 3;
    do
    {
      scratch[v16].level += 2;
      ++v17;
      ++v16;
    }
    while ( v15 > v17 );
  }
  v18 = v15;
  scratch[v18].level = v34;
  scratch[v18].kind = OPERATOR;
  scratch[v18].token.variable = 6;
  v19 = v15 + 1;
  scratch[v19].level = v34;
  scratch[v19].kind = CONSTANT;
  scratch[v19].token.constant = 2.0;
  v20 = levela + iloc - biloc;
  scratch[v20].kind = CONSTANT;
  scratch[v20].token.constant = 1.0;
  memmove(&equation[iloc + 2], src, 16 * (*np - iloc));
  *np += 2;
  v21 = v9 + 1;
  src->level = v21;
  src->kind = CONSTANT;
  src->token.constant = -1.0;
  v22 = &equation[iloc + 1];
  v22->level = v21;
  v22->kind = OPERATOR;
  v22->token.variable = 3;
  equation[iloc + 2].level = v21;
  memmove(&equation[v15 + 2 + v24], v28, 16 * (*np - i));
  *np += v15 + 2 + 1;
  memmove(dest, scratch, 16 * (v15 + 2));
  equation[v15 + 2 + v24].token.variable = 3;
  return 1;
}

//----- (08059CBE) --------------------------------------------------------
int __cdecl simp2_power(token_type *equation, int *np)
{
  int v2; // eax
  token_type *v3; // esi
  double *v4; // edi
  int v5; // ecx
  int v6; // ebx
  token_type *v7; // edx
  int v8; // ecx
  int v9; // eax
  int *v10; // edx
  int v11; // ecx
  int v12; // edi
  int *v13; // eax
  int v14; // edx
  token_type *v15; // ebx
  int v16; // eax
  unsigned int v18; // [esp+38h] [ebp-30h]
  int modified; // [esp+3Ch] [ebp-2Ch]
  int v20; // [esp+40h] [ebp-28h]
  int v21; // [esp+44h] [ebp-24h]
  int v22; // [esp+48h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-1Ch]

  v2 = *np;
  modified = 0;
  if ( *np > 1 )
  {
    v3 = equation + 2;
    i = 1;
    while ( v3[-1].token.variable != 6 )
    {
LABEL_38:
      i += 2;
      v2 = *np;
      v3 += 2;
      if ( *np <= i )
        return modified;
    }
    v22 = v3[-1].level;
    v20 = i + 1;
    if ( v2 <= i + 1 || (v4 = (double *)v3, v5 = v3->level, v22 > v5) )
    {
      v6 = i + 1;
      v18 = 0;
      v21 = -1;
    }
    else
    {
      v6 = i + 1;
      v18 = 0;
      v21 = -1;
      v7 = v3 + 1;
      do
      {
        if ( v22 + 1 == v5 )
        {
          if ( *(_DWORD *)v4 == 2 )
          {
            v18 = *((_DWORD *)v4 + 2);
          }
          else if ( !*(_DWORD *)v4 )
          {
            v8 = v21;
            if ( v4[1] < 0.0 )
              v8 = v6;
            v21 = v8;
          }
        }
        if ( ++v6 >= v2 )
          break;
        v4 = (double *)v7;
        v5 = v7->level;
        ++v7;
      }
      while ( v22 <= v5 );
    }
    if ( v6 - i > 2 || v3->kind || v3->token.constant >= 0.0 )
    {
      if ( v21 < 0 )
        goto LABEL_36;
      v20 = v21;
    }
    if ( v18 <= 4 && ((1 << v18) & 0x19) != 0 )
    {
      if ( v2 + 2 > n_tokens )
        error_huge();
      equation[v20].token.constant = -equation[v20].token.constant;
      v9 = i - 2;
      if ( i - 2 >= 0 && v22 <= v3[-3].level )
      {
        v10 = &v3[-4].level;
        do
        {
          if ( --v9 < 0 )
            break;
          v11 = *v10;
          v10 -= 4;
        }
        while ( v22 <= v11 );
      }
      v12 = v9 + 1;
      if ( v6 > v9 + 1 )
      {
        v13 = &equation[v12].level;
        v14 = v12;
        do
        {
          ++*v13;
          ++v14;
          v13 += 4;
        }
        while ( v6 > v14 );
      }
      v15 = &equation[v12];
      memmove(&v15[2], v15, 16 * (*np - v12));
      *np += 2;
      v15->level = v22;
      v15->kind = CONSTANT;
      v15->token.constant = 1.0;
      v15[1].level = v22;
      v15[1].kind = OPERATOR;
      v15[1].token.variable = 4;
      v16 = 1;
      goto LABEL_37;
    }
LABEL_36:
    v16 = 0;
LABEL_37:
    modified |= v16;
    goto LABEL_38;
  }
  return modified;
}

//----- (08059ED8) --------------------------------------------------------
int __cdecl simp_constant_power(token_type *equation, int *np)
{
  int v2; // eax
  token_type *v3; // ebx
  int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int modified; // [esp+2Ch] [ebp-1Ch]

  if ( symb_flag )
  {
    v2 = *np;
    if ( *np > 1 )
    {
      v3 = equation + 3;
      v4 = 3;
      modified = 0;
      while ( v3[-2].token.variable != 6 )
      {
LABEL_20:
        v7 = v4;
        v2 = *np;
        v4 += 2;
        v3 += 2;
        if ( *np <= v7 )
          return modified;
      }
      v10 = v3[-2].level;
      if ( v10 == v3[-3].level && v3[-3].kind == CONSTANT )
      {
        v9 = v3[-1].level;
        if ( v9 == v10 + 1 && v3[-1].kind == CONSTANT && v3[-1].token.constant != 1.0 && v4 < v2 && v9 == v3->level )
        {
          v5 = v3->token.variable;
          if ( v5 == 3 )
          {
LABEL_17:
            v3->level = v10;
            v3->token.variable = 6;
            ++v3[-3].level;
            ++v3[-2].level;
            v6 = 1;
LABEL_19:
            modified |= v6;
            goto LABEL_20;
          }
          if ( v5 == 4 )
          {
            if ( v2 + 2 > n_tokens )
              error_huge();
            memmove(&v3[2], v3, 16 * (*np - v4));
            *np += 2;
            v3[1].level = v9;
            v3[1].kind = CONSTANT;
            v3[1].token.constant = 1.0;
            goto LABEL_17;
          }
        }
      }
      v6 = 0;
      goto LABEL_19;
    }
  }
  return 0;
}

//----- (0805A00B) --------------------------------------------------------
int __cdecl rationalize(token_type *equation, int *np)
{
  int v2; // esi
  token_type *v3; // eax
  int v4; // ebx
  int v5; // eax
  int *v6; // edx
  int v7; // eax
  int v8; // edi
  token_type *v9; // ebx
  int v10; // ecx
  token_type *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // eax
  long double v15; // fst5
  char v17; // c2
  int v18; // ebx
  storage_type *v19; // esi
  int *v20; // edi
  int v21; // ebx
  long double v22; // fst5
  char v24; // c2
  int v25; // esi
  int v26; // edx
  int v27; // edx
  int v28; // eax
  int v29; // edi
  token_type *v30; // esi
  int v31; // esi
  token_type *v32; // eax
  int *v33; // ebx
  int *v34; // esi
  int v35; // eax
  int *v36; // edx
  int v37; // ecx
  int v39; // [esp+18h] [ebp-50h]
  int modified; // [esp+1Ch] [ebp-4Ch]
  int v41; // [esp+20h] [ebp-48h]
  int v42; // [esp+24h] [ebp-44h]
  int v43; // [esp+24h] [ebp-44h]
  int v44; // [esp+2Ch] [ebp-3Ch]
  int flag; // [esp+30h] [ebp-38h]
  int count; // [esp+38h] [ebp-30h]
  int v47; // [esp+3Ch] [ebp-2Ch]
  int neg_one_loc; // [esp+40h] [ebp-28h]
  int neg_one_loca; // [esp+40h] [ebp-28h]
  int div_level; // [esp+44h] [ebp-24h]
  int v51; // [esp+48h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-1Ch]
  int ia; // [esp+4Ch] [ebp-1Ch]

  modified = 0;
  i = 1;
LABEL_3:
  while ( 1 )
  {
    v2 = *np;
    if ( i >= *np )
      return modified;
    v3 = &equation[i];
    if ( v3->token.variable != 4 )
      goto LABEL_67;
    div_level = v3->level;
    v4 = i + 2;
    v44 = i + 2;
    if ( v2 <= i + 2 )
      goto LABEL_67;
    v5 = equation[v4].level;
    if ( div_level >= v5 )
      goto LABEL_67;
    v6 = &equation[i + 4].level;
    count = 0;
    v51 = -1;
    do
    {
      if ( v5 == div_level + 1 )
      {
        ++count;
        v7 = v51;
        if ( v51 < 0 )
          v7 = v4;
        v51 = v7;
      }
      v4 += 2;
      if ( v2 <= v4 )
        break;
      v5 = *v6;
      v6 += 8;
    }
    while ( div_level < v5 );
    v41 = div_level + 1;
    if ( v51 < 0 || (unsigned int)(equation[v51].token.variable - 1) > 1 )
    {
LABEL_67:
      i += 2;
      continue;
    }
    v47 = i;
    neg_one_loc = div_level + 2;
    v42 = v4;
    while ( 1 )
    {
      v8 = v51 - 2;
      if ( v47 >= v51 - 2 )
        goto LABEL_60;
      v9 = &equation[v8];
      v39 = div_level + 2;
      if ( v9->level != neg_one_loc )
      {
        v11 = &equation[v51 - 4];
        v13 = v51 - 2;
        while ( 1 )
        {
          v13 -= 2;
          if ( v47 >= v13 )
            goto LABEL_60;
          v9 = v11;
          v10 = v11->level;
          v11 -= 2;
          if ( v10 == neg_one_loc )
          {
            v8 = v51 - 2;
            break;
          }
        }
      }
      v12 = v9->token.variable;
      if ( v12 >= 3 )
      {
        flag = 1;
        if ( v12 <= 4 )
          goto LABEL_69;
        if ( v12 == 6 )
          break;
      }
LABEL_60:
      if ( v51 >= v42 )
        goto LABEL_67;
      v35 = v51 + 2;
      if ( v42 > v51 + 2 && v41 != equation[v35].level )
      {
        v36 = &equation[v51 + 4].level;
        do
        {
          v35 += 2;
          if ( v42 <= v35 )
            break;
          v37 = *v36;
          v36 += 8;
        }
        while ( v41 != v37 );
      }
      v47 = v51;
      v51 = v35;
    }
    flag = 2;
LABEL_69:
    v33 = &equation[v8].level;
    v34 = &equation[v51 - 1].level;
    while ( 1 )
    {
      v14 = *v33;
      if ( (*v33 == neg_one_loc || v14 == div_level + 3 && flag == 1) && v33[1] == 6 && v14 == *v34 && !*(v34 - 1) )
      {
        v15 = *(double *)(v34 + 1);
        do
          v15 = __FPREM__(v15, 1.0);
        while ( v17 );
        if ( v15 == 0.5 )
          break;
      }
      v8 -= 2;
      v33 -= 8;
      v34 -= 8;
      if ( v47 >= v8 )
        goto LABEL_60;
    }
    v18 = v42;
    if ( v44 < v42 )
    {
      v19 = &equation[v44].token;
      v43 = v8;
      neg_one_loca = v18;
      v20 = &equation[i + 3].level;
      v21 = i + 2;
      do
      {
        if ( v19->variable == 6 && *(&v19[-1].operatr + 1) == *v20 && !*(v20 - 1) )
        {
          v22 = *(double *)(v20 + 1);
          do
            v22 = __FPREM__(v22, 1.0);
          while ( v24 );
          if ( v22 == 0.5 && v43 != v21 && (v39 != *(&v19[-1].operatr + 1) || count != 1) )
          {
            i += 2;
            goto LABEL_3;
          }
        }
        v21 += 2;
        v19 += 4;
        v20 += 8;
      }
      while ( neg_one_loca > v21 );
      v18 = neg_one_loca;
    }
    v25 = v47 - i;
    memmove(scratch, &equation[i + 1], v25 * 16);
    scratch[v25].level = v39;
    scratch[v25].kind = CONSTANT;
    scratch[v25].token.constant = -1.0;
    v26 = v47 - i + 1;
    scratch[v26].level = v39;
    scratch[v26].kind = OPERATOR;
    scratch[v26].token.variable = 3;
    memmove(&scratch[v47 - i + 2], &equation[v47 + 1], 16 * (v18 - (v47 + 1)));
    if ( v51 - (v47 + 1) > 0 )
    {
      v27 = v47 - i + 2;
      v28 = 0;
      do
      {
        ++scratch[v27].level;
        ++v28;
        ++v27;
      }
      while ( v28 != v51 - (v47 + 1) );
    }
    v29 = v18 + ~i + 2;
    ia = 2 * v29 + 2;
    if ( *np + ia > n_tokens )
      error_huge();
    v30 = &equation[v18];
    memmove(&equation[v18 + ia], v30, 16 * (*np - v18));
    *np += ia;
    v30->level = div_level;
    v30->kind = OPERATOR;
    v30->token.variable = 3;
    memmove(&equation[v18 + 1], scratch, 16 * v29);
    v31 = v29 + v18 + 1;
    v32 = &equation[v31];
    v32->level = div_level;
    v32->kind = OPERATOR;
    v32->token.variable = 4;
    memmove(&equation[++v31], scratch, 16 * v29);
    i = v31 + v29;
    modified = 1;
    if ( debug_level > 0 )
    {
      __fprintf_chk(gfp, 1, "%s\n", "Square roots in denominator rationalized.");
      modified = 1;
    }
  }
}
// 805A1DC: variable 'v17' is possibly undefined
// 805A264: variable 'v24' is possibly undefined
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0805A554) --------------------------------------------------------
int __usercall order_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level)
{
  int v4; // ebx
  int v5; // edi
  token_type *v6; // edx
  int v7; // eax
  int v8; // eax
  int *v9; // edx
  int v10; // ebx
  int v11; // edx
  int v12; // ecx
  token_type *v13; // edx
  int v14; // edi
  int *v15; // eax
  int v16; // edx
  int *v17; // eax
  int v18; // ebx
  int v19; // ebx
  int *v20; // eax
  int v21; // edx
  int v22; // edi
  int *i; // eax
  token_type *v24; // ecx
  int v25; // eax
  int *v26; // edx
  int v27; // ecx
  size_t v28; // eax
  token_type *v29; // ebx
  int v31; // [esp+2Ch] [ebp-3Ch]
  int v32; // [esp+3Ch] [ebp-2Ch]
  int v33; // [esp+40h] [ebp-28h]
  int modified; // [esp+44h] [ebp-24h]
  int modifieda; // [esp+44h] [ebp-24h]
  int modifiedb; // [esp+44h] [ebp-24h]
  token_type *ka; // [esp+48h] [ebp-20h]
  int kb; // [esp+48h] [ebp-20h]

  v32 = loc;
  if ( (loc & 1) != 0 )
    goto corrupt;
  v4 = loc;
  modified = 0;
  v5 = 0;
  while ( 1 )
  {
    v12 = *np;
    if ( v4 >= *np )
      goto LABEL_29;
    v6 = &equation[v4];
    v7 = v6->level;
    if ( v7 < level )
      break;
    if ( v7 <= level )
    {
      if ( (v6->kind == OPERATOR) != (v4 & 1) )
        goto corrupt;
      if ( v6->kind != OPERATOR )
        goto LABEL_24;
      v11 = v6->token.variable;
      if ( !v11 )
        goto corrupt;
      if ( v5 )
      {
        if ( v11 < 1 )
          goto corrupt;
        if ( v11 <= 2 )
        {
          if ( (unsigned int)(v5 - 1) > 1 )
            goto corrupt;
        }
        else if ( v11 > 4 || (unsigned int)(v5 - 3) > 1 )
        {
          goto corrupt;
        }
LABEL_24:
        v11 = v5;
      }
      v8 = v4 + 1;
      goto LABEL_27;
    }
    modified |= order_recurse(equation, np, v4, level + 1);
    v8 = v4 + 1;
    if ( v4 + 1 < *np && level < equation[v8].level )
    {
      v9 = &equation[v4 + 2].level;
      do
      {
        if ( ++v8 >= *np )
          break;
        v10 = *v9;
        v9 += 4;
      }
      while ( level < v10 );
    }
    v11 = v5;
LABEL_27:
    v5 = v11;
    v4 = v8;
  }
  if ( v6->kind != OPERATOR )
    goto corrupt;
LABEL_29:
  if ( (v4 & 1) == 0 )
corrupt:
    error_bug("Internal representation of expression is corrupt!");
  if ( v5 >= 1 )
  {
    if ( v5 <= 2 )
    {
      v13 = &equation[v32];
      ka = v13;
      if ( v13->kind == CONSTANT
        && v13->token.constant < 0.0
        && (v13->level == level
         || equation[v32 + 1].level == level + 1 && (unsigned int)(equation[v32 + 1].token.variable - 3) <= 1) )
      {
        v14 = v32 + 1;
        if ( v32 + 1 < v4 )
        {
          v15 = &equation[v14].level;
          v16 = v32 + 1;
          while ( *v15 != level || v15[1] != 1 )
          {
            v16 += 2;
            v15 += 8;
            if ( v16 >= v4 )
              return modified;
          }
          modifieda = v16 + 1;
          v17 = &equation[v14].level;
          while ( v12 > v14 )
          {
            v18 = *v17;
            v17 += 8;
            if ( level >= v18 )
              break;
            v14 += 2;
          }
          v19 = v16 + 2;
          v20 = &equation[v16 + 2].level;
          while ( v12 > v19 )
          {
            v21 = *v20;
            v20 += 8;
            if ( level >= v21 )
              break;
            v19 += 2;
          }
          memmove(scratch, ka, 16 * (v19 - v32));
          memmove(&equation[v19 - modifieda + v32], &equation[v14], 16 * (modifieda - v14));
          memmove(ka, &scratch[modifieda - v32], 16 * (v19 - modifieda));
          memmove(&equation[v19 - (v14 - v32)], scratch, 16 * (v14 - v32));
          modified = 1;
        }
      }
    }
    else if ( v5 <= 4 )
    {
      v22 = v32 + 1;
      if ( v32 + 1 < v4 )
      {
        for ( i = &equation[v22].level; *i != level || i[1] != 4; i += 8 )
        {
          v22 += 2;
          if ( v4 <= v22 )
            return modified;
        }
        kb = v22 + 2;
        if ( v22 + 2 < v4 )
        {
          v31 = v4;
          do
          {
            v24 = &equation[kb];
            if ( v24->level == level && v24->token.variable == 3 )
            {
              v25 = kb + 2;
              if ( kb + 2 < v31 && level < equation[v25].level )
              {
                v26 = &equation[kb + 4].level;
                while ( 1 )
                {
                  v25 += 2;
                  if ( v25 >= v31 )
                    break;
                  v27 = *v26;
                  v26 += 8;
                  if ( level >= v27 )
                  {
                    v24 = &equation[kb];
                    goto LABEL_71;
                  }
                }
                v24 = &equation[kb];
              }
LABEL_71:
              modifiedb = v25 - kb;
              v33 = 16 * (v25 - kb);
              memmove(scratch, v24, v33);
              v28 = 16 * (kb - v22);
              v29 = &equation[v22];
              v22 += modifiedb;
              memmove(&equation[v22], v29, v28);
              memmove(v29, scratch, v33);
              kb += modifiedb;
              modified = 1;
            }
            else
            {
              kb += 2;
            }
          }
          while ( v31 > kb );
        }
      }
    }
  }
  return modified;
}

//----- (0805A987) --------------------------------------------------------
int __cdecl reorder(token_type *equation, int *np)
{
  return order_recurse(equation, np, 0, 1);
}

//----- (0805A9A6) --------------------------------------------------------
int __cdecl elim_sign(token_type *equation, int *np)
{
  int v2; // edx
  int i; // ebx
  token_type *v4; // esi
  int v5; // eax
  token_type *v6; // eax
  token_type *v7; // eax
  long double v8; // fst5
  char v10; // c2
  token_type *v11; // eax
  token_type *v12; // esi
  int v13; // edx
  token_type *v14; // eax
  int v15; // ecx
  token_type *v16; // ecx
  int v17; // edx
  token_type *v18; // eax
  int v19; // ebx
  long double v20; // fst7
  token_type *v21; // eax
  int v22; // eax
  long double v23; // fst5
  char v25; // c2
  long double v26; // fst5
  char v28; // c2
  long double v29; // fst5
  char v31; // c2
  int modified; // [esp+20h] [ebp-38h]
  int v34; // [esp+24h] [ebp-34h]
  int v35; // [esp+28h] [ebp-30h]
  int v36; // [esp+28h] [ebp-30h]
  int level; // [esp+2Ch] [ebp-2Ch]
  int levela; // [esp+2Ch] [ebp-2Ch]
  double denominator; // [esp+30h] [ebp-28h] BYREF
  double numerator[4]; // [esp+38h] [ebp-20h] BYREF

  v2 = *np;
  modified = 0;
  for ( i = 1; *np > i; v2 = *np )
  {
    v4 = &equation[i];
    level = v4->level;
    v5 = v4->token.variable;
    if ( v5 == 4 && (v35 = equation[i + 1].level, v35 == level) )
    {
      if ( equation[i + 1].kind == VARIABLE && equation[i + 1].token.variable == 3 )
      {
        if ( v2 + 2 > n_tokens )
          error_huge();
        memmove(&equation[i + 2], &equation[i], 16 * (*np - i));
        *np += 2;
        v4->level = v35;
        v4->kind = OPERATOR;
        v4->token.variable = 3;
        v6 = &equation[i + 1];
        v6->level = v35;
        v6->kind = CONSTANT;
        v6->token.constant = -1.0;
        i += 2;
        v7 = &equation[i];
        v7->level = v35;
        v7->kind = OPERATOR;
        v7->token.variable = 3;
        modified = 1;
      }
    }
    else if ( v5 == 6 )
    {
      v34 = equation[i + 1].level;
      if ( v34 == level && equation[i + 1].kind == CONSTANT )
      {
        f_to_fraction(equation[i + 1].token.constant, numerator, &denominator);
        v8 = numerator[0];
        do
          v8 = __FPREM__(v8, 2.0);
        while ( v10 );
        if ( v8 == 0.0 )
        {
          v11 = &equation[i - 1];
          if ( v34 == v11->level && v11->kind == VARIABLE && v11->token.variable == 3 )
          {
            v11->kind = CONSTANT;
            v11->token.constant = -1.0;
            equation[i + 1].token.constant = equation[i + 1].token.constant * 0.5;
            modified = 1;
          }
          else
          {
            levela = i - 1;
            if ( i - 1 >= 0 )
            {
              v12 = &equation[i - 1];
              v13 = v12->level;
              if ( v34 > v13 )
                goto LABEL_31;
              v14 = &equation[i - 2];
              v15 = i - 1;
              while ( v34 + 1 < v13 || v12->kind != OPERATOR )
              {
                if ( --v15 >= 0 )
                {
                  v12 = v14;
                  v13 = v14->level;
                  --v14;
                  if ( v34 <= v13 )
                    continue;
                }
                goto LABEL_31;
              }
              if ( v12->token.variable <= 4u && ((1 << v12->token.variable) & 0x19) != 0 && levela >= 0 )
              {
LABEL_31:
                v16 = &equation[levela];
                v17 = v16->level;
                if ( v34 <= v17 )
                {
                  v18 = &equation[i - 2];
                  v36 = i;
                  v19 = i - 1;
                  while ( 1 )
                  {
                    if ( v34 + 1 >= v17 )
                    {
                      if ( v16->kind == VARIABLE && (v16->token.variable & 0x3FFF) == 4 )
                      {
                        v16->kind = CONSTANT;
                        v16->token.constant = 1.0;
                        modified = 1;
                      }
                      else if ( v16->kind == CONSTANT )
                      {
                        v20 = v16->token.constant;
                        if ( v20 < 0.0 )
                        {
                          v16->token.constant = -v20;
                          modified = 1;
                        }
                      }
                    }
                    if ( --v19 < 0 )
                      break;
                    v16 = v18;
                    v17 = v18->level;
                    --v18;
                    if ( v34 > v17 )
                    {
                      i = v36;
                      goto LABEL_61;
                    }
                  }
                  i = v36;
                }
              }
            }
          }
        }
        else
        {
          v21 = &equation[i - 1];
          if ( v21->level == level && v21->kind == VARIABLE )
          {
            v22 = v21->token.variable;
            if ( v22 == 3 )
            {
              v23 = equation[i + 1].token.constant;
              do
                v23 = __FPREM__(v23, 4.0);
              while ( v25 );
              if ( v23 == 1.0 )
              {
                v4->token.variable = 3;
                equation[i + 1].token.constant = 1.0;
                modified = 1;
              }
              else if ( v23 == 3.0 )
              {
                v4->token.variable = 3;
                equation[i + 1].token.constant = -1.0;
                modified = 1;
              }
            }
            else if ( (v22 & 0x3FFF) == 4 )
            {
              v26 = denominator;
              do
                v26 = __FPREM__(v26, 2.0);
              while ( v28 );
              if ( v26 == 1.0 )
              {
                v29 = numerator[0];
                do
                  v29 = __FPREM__(v29, 2.0);
                while ( v31 );
                numerator[0] = v29;
                if ( v29 != equation[i + 1].token.constant )
                {
                  equation[i + 1].token.constant = v29;
                  modified = 1;
                }
              }
            }
          }
        }
      }
    }
LABEL_61:
    i += 2;
  }
  return modified;
}
// 805AB13: variable 'v10' is possibly undefined
// 805ACF6: variable 'v25' is possibly undefined
// 805AD98: variable 'v28' is possibly undefined
// 805ADDA: variable 'v31' is possibly undefined

//----- (0805AE41) --------------------------------------------------------
int __cdecl simp_pp(token_type *equation, int *np)
{
  int v2; // esi
  token_type *v3; // eax
  int *v4; // eax
  int v5; // ebx
  int v6; // esi
  long double v7; // fst5
  char v9; // c2
  long double v10; // fst5
  char v12; // c2
  long double v13; // fst5
  char v15; // c2
  int v16; // edx
  token_type *v17; // eax
  token_type *v18; // ecx
  int v19; // edx
  int *v20; // eax
  int modified; // [esp+14h] [ebp-44h]
  int v23; // [esp+1Ch] [ebp-3Ch]
  int *v24; // [esp+20h] [ebp-38h]
  int v25; // [esp+24h] [ebp-34h]
  int ilevel; // [esp+28h] [ebp-30h]
  int ilevela; // [esp+28h] [ebp-30h]
  int i; // [esp+2Ch] [ebp-2Ch]
  double denominator; // [esp+30h] [ebp-28h] BYREF
  double numerator[4]; // [esp+38h] [ebp-20h] BYREF

  v2 = *np;
  modified = 0;
  for ( i = 1; *np > i; v2 = *np )
  {
    v3 = &equation[i];
    if ( v3->token.variable == 6 )
    {
      ilevel = v3->level;
      v23 = i + 2;
      if ( i + 2 < v2 )
      {
        v4 = &equation[i + 2].level;
        v5 = i + 2;
        while ( 1 )
        {
          v24 = v4 - 1;
          if ( ilevel - 1 == *v4 && v4[1] == 6 )
            break;
          if ( ilevel < *v4 )
          {
            v5 += 2;
            v4 += 8;
            if ( v2 > v5 )
              continue;
          }
          goto LABEL_37;
        }
        ilevela = ilevel - 1;
        v6 = v5;
        if ( symb_flag )
        {
LABEL_24:
          v24[2] = 3;
          if ( v5 < *np )
          {
            v16 = v24[1];
            if ( ilevela <= v16 )
            {
              v17 = &equation[v5 + 1];
              v25 = v5;
              v18 = (token_type *)v24;
              while ( 1 )
              {
                v18->level = v16 + 2;
                if ( *np <= ++v5 )
                  break;
                v18 = v17;
                v16 = v17->level;
                ++v17;
                if ( ilevela > v16 )
                {
                  v6 = v25;
                  goto LABEL_31;
                }
              }
              v6 = v25;
            }
          }
LABEL_31:
          v19 = i + 1;
          if ( v6 > i + 1 )
          {
            v20 = &equation[v19].level;
            do
            {
              ++*v20;
              ++v19;
              v20 += 4;
            }
            while ( v6 > v19 );
          }
          i -= 2;
          modified = 1;
          goto LABEL_37;
        }
        if ( ilevela != equation[v5 + 1].level || equation[v5 + 1].kind )
        {
          if ( v5 == v23 && equation[i + 1].kind == CONSTANT )
          {
            f_to_fraction(equation[i + 1].token.constant, numerator, &denominator);
            v13 = numerator[0];
            do
              v13 = __FPREM__(v13, 2.0);
            while ( v15 );
            if ( v13 != 0.0 )
              goto LABEL_24;
          }
        }
        else
        {
          f_to_fraction(equation[v5 + 1].token.constant, numerator, &denominator);
          v7 = denominator;
          do
            v7 = __FPREM__(v7, 2.0);
          while ( v9 );
          if ( v7 != 0.0 )
            goto LABEL_24;
          if ( v5 == v23 && equation[i + 1].kind == CONSTANT )
          {
            f_to_fraction(equation[i + 1].token.constant, numerator, &denominator);
            v10 = numerator[0];
            do
              v10 = __FPREM__(v10, 2.0);
            while ( v12 );
            if ( v10 != 0.0 )
              goto LABEL_24;
          }
        }
      }
    }
LABEL_37:
    i += 2;
  }
  return modified;
}
// 805AF27: variable 'v9' is possibly undefined
// 805AFA9: variable 'v12' is possibly undefined
// 805B035: variable 'v15' is possibly undefined

//----- (0805B11E) --------------------------------------------------------
_BOOL4 __usercall compare_recurse@<eax>(token_type *p1@<eax>, int n1@<edx>, int l1@<ecx>, token_type *p2, int n2, int l2, int *diff_signp)
{
  token_type *v7; // ebx
  kind_list v9; // eax
  _BOOL4 result; // eax
  long double v11; // fst6
  long double v12; // fst7
  long double v13; // fst4
  token_type *v14; // edx
  token_type *v15; // eax
  token_type *v16; // eax
  token_type *v17; // ecx
  _BOOL4 v18; // ecx
  int v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // ebx
  int v23; // edx
  token_type *v24; // eax
  int v25; // esi
  token_type *v26; // ebx
  int v27; // ebx
  bool v28; // al
  token_type *v29; // esi
  int v30; // eax
  int v31; // ecx
  int i; // eax
  token_type *v33; // edx
  int op2; // [esp+10h] [ebp-C3B8h]
  int first; // [esp+14h] [ebp-C3B4h]
  double compare_epsilon; // [esp+18h] [ebp-C3B0h]
  int v37; // [esp+20h] [ebp-C3A8h]
  int v38; // [esp+28h] [ebp-C3A0h]
  token_type *v39; // [esp+2Ch] [ebp-C39Ch]
  int last_op1; // [esp+30h] [ebp-C398h]
  int v41; // [esp+34h] [ebp-C394h]
  unsigned int op1; // [esp+38h] [ebp-C390h]
  token_type *v43; // [esp+40h] [ebp-C388h]
  int v44; // [esp+44h] [ebp-C384h]
  token_type *v45; // [esp+48h] [ebp-C380h]
  token_type *v47; // [esp+4Ch] [ebp-C37Ch]
  token_type *v48; // [esp+4Ch] [ebp-C37Ch]
  token_type *v49; // [esp+4Ch] [ebp-C37Ch]
  token_type *opa2[10000]; // [esp+58h] [ebp-C370h]
  int j; // [esp+9C98h] [ebp-2730h] BYREF
  char used[10000]; // [esp+9C9Ch] [ebp-272Ch]
  unsigned int v53; // [esp+C3ACh] [ebp-1Ch]

  v7 = p1;
  v53 = __readgsdword(0x14u);
  compare_epsilon = epsilon;
  *diff_signp = 0;
  if ( n1 == 1 && n2 == 1 )
  {
    v9 = p1->kind;
    if ( v7->kind == p2->kind )
    {
      if ( v9 )
      {
        if ( v9 == VARIABLE )
        {
          if ( sign_cmp_flag && (v7->token.variable & 0x3FFF) == 4 )
            result = (p2->token.variable & 0x3FFF) == 4;
          else
            result = v7->token.variable == p2->token.variable;
          return result;
        }
      }
      else
      {
        v11 = v7->token.constant;
        v12 = p2->token.constant;
        if ( v11 == v12 )
          return 1;
        if ( -v12 == v11 )
        {
          *diff_signp = 1;
          return 1;
        }
        v13 = fabs(v11) * compare_epsilon;
        if ( v13 > fabs(v11 - v12) )
          return 1;
        if ( v13 > fabs(v12 + v11) )
        {
          *diff_signp = 1;
          return 1;
        }
      }
    }
    return 0;
  }
  v39 = &p1[n1];
  v14 = &p2[n2];
  v15 = p1 + 1;
  if ( v39 > &v7[1] )
  {
    if ( v7[1].level == l1 )
    {
LABEL_20:
      op1 = v15->token.variable;
      goto LABEL_23;
    }
    while ( 1 )
    {
      v15 += 2;
      if ( v39 <= v15 )
        break;
      if ( v15->level == l1 )
        goto LABEL_20;
    }
  }
  op1 = 0;
LABEL_23:
  v16 = p2 + 1;
  if ( v14 <= &p2[1] )
  {
LABEL_33:
    op2 = 0;
LABEL_34:
    if ( op1 - 3 > 1 )
      return 0;
    opa2[0] = p2;
    used[0] = 0;
    v44 = 1;
    if ( v14 <= v16 )
      goto LABEL_65;
    v21 = 1;
    v48 = v7;
    v22 = l2;
    do
    {
LABEL_59:
      if ( v16->level == v22 )
      {
        opa2[v21] = v16 + 1;
        used[v21++] = 0;
        if ( v21 > 9999 )
        {
          if ( debug_level > 0 )
          {
            __fprintf_chk(gfp, 1, "%s\n", "Expression too big to compare, because MAX_COMPARE_TERMS exceeded.");
            return 0;
          }
          return 0;
        }
      }
      v16 += 2;
    }
    while ( v14 > v16 );
    v44 = v21;
    v7 = v48;
LABEL_65:
    opa2[v44] = v16 + 1;
    v49 = v7;
    last_op1 = 0;
    first = 1;
    v37 = 1 << op1;
    v38 = (1 << op1) & 0x19;
    while ( 1 )
    {
      v43 = v49 + 1;
      if ( v39 > &v49[1] && l1 < v49[1].level )
      {
        v24 = v49 + 3;
        v25 = 1;
        while ( 1 )
        {
          v25 += 2;
          v26 = v24;
          if ( v24 >= v39 )
            break;
          v23 = v24->level;
          v24 += 2;
          if ( l1 >= v23 )
          {
            v43 = v26;
            goto LABEL_72;
          }
        }
        v43 = v24;
      }
      else
      {
        v25 = 1;
      }
LABEL_72:
      if ( v44 <= 0 )
      {
LABEL_77:
        if ( op1 - 3 <= 1
          && v49->level == l1
          && v49->kind == CONSTANT
          && compare_epsilon >= fabs(fabs(v49->token.constant) - 1.0) )
        {
          if ( v49->token.constant < 0.0 )
            *diff_signp ^= 1u;
          goto LABEL_117;
        }
        return 0;
      }
      v27 = 0;
      v41 = v25;
      while ( 1 )
      {
        if ( used[v27] )
          goto LABEL_115;
        if ( op1 > 4 )
          goto LABEL_93;
        if ( !v38 )
        {
          if ( (v37 & 6) != 0 )
            goto LABEL_94;
LABEL_93:
          if ( (last_op1 == 0) != (v27 == 0) )
            return 0;
          goto LABEL_94;
        }
        v28 = 0;
        if ( v27 )
          v28 = opa2[v27][-1].token.variable == 4;
        if ( (last_op1 == 4) != v28 )
          goto LABEL_115;
LABEL_94:
        v29 = opa2[v27];
        v30 = l2 + 1;
        if ( l2 >= v29->level )
          v30 = l2;
        v31 = l1 + 1;
        if ( l1 >= v49->level )
          v31 = l1;
        if ( !compare_recurse(v49, v41, v31, v29, opa2[v27 + 1] - v29 - 1, v30, &j) )
          goto LABEL_115;
        if ( op1 <= 4 )
        {
          if ( v38 )
          {
            *diff_signp ^= j;
            goto LABEL_114;
          }
          if ( (v37 & 6) != 0 )
            break;
        }
        if ( !j )
          goto LABEL_114;
LABEL_115:
        if ( ++v27 >= v44 )
          goto LABEL_77;
      }
      if ( last_op1 == 2 )
        j = j == 0;
      if ( v27 && v29[-1].token.variable == 2 )
        j = j == 0;
      if ( !first )
      {
        if ( *diff_signp == j )
          goto LABEL_114;
        goto LABEL_115;
      }
      *diff_signp = j;
      first = 0;
LABEL_114:
      used[v27] = 1;
LABEL_117:
      if ( v39 <= v43 )
      {
        if ( v44 > 0 )
        {
          for ( i = 0; i < v44; ++i )
          {
            if ( !used[i] )
            {
              if ( (unsigned int)(op2 - 3) > 1 )
                return 0;
              v33 = opa2[i];
              if ( v33->level != l2 || v33->kind || compare_epsilon < fabs(fabs(v33->token.constant) - 1.0) )
                return 0;
              if ( v33->token.constant < 0.0 )
                *diff_signp ^= 1u;
            }
          }
        }
        return 1;
      }
      last_op1 = v43->token.variable;
      v49 = v43 + 1;
    }
  }
  v45 = p2 + 1;
  if ( p2[1].level != l2 )
  {
    v17 = p2 + 1;
    while ( 1 )
    {
      v17 += 2;
      if ( v14 <= v17 )
        break;
      if ( v17->level == l2 )
      {
        v45 = v17;
        v16 = p2 + 1;
        goto LABEL_28;
      }
    }
    v16 = p2 + 1;
    goto LABEL_33;
  }
LABEL_28:
  op2 = v45->token.variable;
  if ( !op2 )
    goto LABEL_34;
  switch ( op1 )
  {
    case 0u:
      if ( (unsigned int)(op2 - 3) > 1 )
        return 0;
      goto LABEL_133;
    case 1u:
    case 2u:
      v18 = (unsigned int)(op2 - 1) > 1;
      break;
    case 3u:
    case 4u:
      v18 = (unsigned int)(op2 - 3) > 1;
      break;
    default:
      v18 = op1 != op2;
      break;
  }
  if ( !v18 )
  {
LABEL_133:
    opa2[0] = p2;
    used[0] = 0;
    v21 = 1;
    v48 = v7;
    v22 = l2;
    goto LABEL_59;
  }
  if ( v7->kind == CONSTANT && v7->level == l1 && op1 == 3 && compare_epsilon >= fabs(fabs(v7->token.constant) - 1.0) )
  {
    v47 = (token_type *)(n1 - 2);
    v19 = min_level(v7 + 2, (int)v47);
    if ( compare_recurse(v7 + 2, (int)v47, v19, p2, n2, l2, diff_signp) )
    {
      if ( v7->token.constant >= 0.0 )
        return 1;
      *diff_signp ^= 1u;
      return 1;
    }
    return 0;
  }
  if ( p2->kind )
    return 0;
  if ( p2->level != l2 )
    return 0;
  if ( op2 != 3 )
    return 0;
  if ( compare_epsilon < fabs(fabs(p2->token.constant) - 1.0) )
    return 0;
  v20 = min_level(p2 + 2, n2 - 2);
  if ( !compare_recurse(v7, n1, l1, p2 + 2, n2 - 2, v20, diff_signp) )
    return 0;
  if ( p2->token.constant >= 0.0 )
    return 1;
  *diff_signp ^= 1u;
  return 1;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0805B96D) --------------------------------------------------------
int __cdecl se_compare(token_type *p1, int n1, token_type *p2, int n2, int *diff_signp)
{
  int v5; // edi
  int v6; // eax

  v5 = min_level(p1, n1);
  v6 = min_level(p2, n2);
  return compare_recurse(p1, n1, v5, p2, n2, v6, diff_signp);
}

//----- (0805B9CE) --------------------------------------------------------
int __cdecl elim_k(token_type *equation, int *np)
{
  token_type *v3; // ebx
  token_type *v4; // edi
  int v5; // eax
  token_type *v6; // edx
  int v7; // esi
  bool v8; // zf
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  token_type *v13; // edx
  int v14; // edi
  unsigned int v15; // eax
  int v16; // eax
  token_type *v17; // edx
  token_type *v18; // edi
  int v19; // eax
  token_type *v20; // edx
  int v21; // eax
  token_type *v22; // edx
  int v23; // eax
  unsigned int v24; // edx
  int *v26; // [esp+10h] [ebp-68h]
  token_type *v27; // [esp+18h] [ebp-60h]
  token_type *v28; // [esp+18h] [ebp-60h]
  token_type *dest; // [esp+1Ch] [ebp-5Ch]
  token_type *desta; // [esp+1Ch] [ebp-5Ch]
  double v31; // [esp+20h] [ebp-58h]
  void *src; // [esp+2Ch] [ebp-4Ch]
  token_type *srca; // [esp+2Ch] [ebp-4Ch]
  int modified; // [esp+34h] [ebp-44h]
  int v35; // [esp+38h] [ebp-40h]
  char *v36; // [esp+3Ch] [ebp-3Ch]
  token_type *v37; // [esp+3Ch] [ebp-3Ch]
  char *d; // [esp+40h] [ebp-38h]
  token_type *da; // [esp+40h] [ebp-38h]
  double db; // [esp+40h] [ebp-38h]
  double *v41; // [esp+4Ch] [ebp-2Ch]
  token_type *v42; // [esp+4Ch] [ebp-2Ch]
  double denominator; // [esp+50h] [ebp-28h] BYREF
  double numerator[4]; // [esp+58h] [ebp-20h] BYREF

  v3 = equation + 1;
  modified = 0;
  while ( 1 )
  {
    v4 = &equation[*np];
    if ( v3 >= v4 )
      return modified;
    if ( v3->kind == OPERATOR )
    {
      d = (char *)v3->level;
      v5 = v3->token.variable;
      if ( (unsigned int)(v5 - 1) > 1 )
        goto LABEL_52;
      v41 = (double *)&v3[1];
      if ( v4 > &v3[2]
        && (char *)v3[2].level == d + 1
        && (unsigned int)(v3[2].token.variable - 3) <= 1
        && !*(_DWORD *)v41
        && v3[1].token.constant < 0.0 )
      {
        v3->token.variable = (v5 == 1) + 1;
        v3[1].token.constant = -v3[1].token.constant;
      }
      if ( (char *)v3[1].level == d && !*(_DWORD *)v41 )
      {
        if ( v3[1].token.constant < 0.0 )
        {
          v3->token.variable = (v3->token.variable == 1) + 1;
          v3[1].token.constant = -v3[1].token.constant;
        }
        if ( v3[1].token.constant == 0.0 )
          goto LABEL_17;
      }
      v6 = v3 - 1;
      v36 = (char *)v3[-1].level;
      if ( v36 == d && v6->kind == CONSTANT && __isinf(v6->token.constant) )
      {
        v41 = (double *)&v3[-1];
      }
      else
      {
        v36 = (char *)v3[1].level;
        if ( v36 != d || *(_DWORD *)v41 )
          goto LABEL_52;
      }
      v31 = v41[1];
      if ( __isinf(v31) )
      {
        src = (void *)v3->level;
        dest = v3;
        v35 = 0;
        if ( (int)v36 <= (int)src )
        {
          v27 = v3;
          v26 = np;
          v7 = 0;
          while ( 1 )
          {
            if ( v3->kind == CONSTANT && v3 != (token_type *)v41 && !__finite(v3->token.constant) )
              v7 = 1;
            if ( v3 == equation )
              break;
            --v3;
            if ( (int)d > v3->level )
            {
              v35 = v7;
              dest = v3;
              v3 = v27;
              np = v26;
              goto LABEL_26;
            }
          }
          v35 = v7;
          desta = v3;
          v3 = v27;
          np = v26;
        }
        else
        {
LABEL_26:
          desta = dest + 1;
          if ( (int)v36 > (int)src )
          {
            srca = v3;
            goto LABEL_47;
          }
        }
        v28 = v3;
        while ( 1 )
        {
          if ( v3->kind == CONSTANT && v3 != (token_type *)v41 )
          {
            v8 = __finite(v3->token.constant) == 0;
            v9 = 1;
            if ( !v8 )
              v9 = v35;
            v35 = v9;
          }
          if ( v4 <= ++v3 )
            break;
          if ( (int)v36 > v3->level )
          {
            srca = v3;
            v3 = v28;
            goto LABEL_47;
          }
        }
        srca = v3;
        v3 = v28;
LABEL_47:
        if ( !v35 )
        {
          if ( v41 > (double *)desta && *((_DWORD *)v41 - 2) == 2 )
            v41[1] = -v31;
          memmove(v41 + 2, srca, (char *)v4 - (char *)srca);
          v10 = *np - (((char *)srca - (char *)(v41 + 2)) >> 4);
          *np = v10;
          memmove(desta, v41, (char *)&equation[v10] - (char *)v41);
          *np -= ((char *)v41 - (char *)desta) >> 4;
          return 1;
        }
      }
LABEL_52:
      v42 = v3 - 1;
      switch ( v3->token.variable )
      {
        case 1:
          if ( (char *)v42->level != d || v42->kind || v42->token.constant != 0.0 )
            goto LABEL_147;
          goto LABEL_56;
        case 2:
          v11 = v42->level;
          if ( (char *)v11 != d || v42->kind || v42->token.constant != 0.0 || v42 != equation && v11 <= v3[-2].level )
            goto LABEL_147;
          v42->token.constant = -1.0;
          v3->token.variable = 3;
          binary_parenthesize(equation, *np, v3 - equation);
          modified = 1;
          continue;
        case 3:
          v12 = v42->level;
          if ( (char *)v12 != d || v42->kind )
            goto LABEL_76;
          if ( v42->token.constant == 0.0 )
          {
            da = v3 + 2;
            if ( v4 > &v3[2] && v12 <= v3[2].level )
            {
              v13 = v3 + 2;
              while ( 1 )
              {
                v13 += 2;
                if ( v4 <= v13 )
                  break;
                if ( v12 > v13->level )
                {
                  da = v13;
                  goto LABEL_132;
                }
              }
              da = v13;
            }
            goto LABEL_132;
          }
          if ( epsilon >= fabs(v42->token.constant - 1.0) )
          {
LABEL_56:
            memmove(v42, &v3[1], (char *)v4 - (char *)&v3[1]);
            *np -= 2;
            modified = 1;
            continue;
          }
LABEL_76:
          v14 = v3[1].level;
          if ( (char *)v14 != d || v3[1].kind )
            goto LABEL_147;
          db = v3[1].token.constant;
          if ( equation >= v42 )
            goto LABEL_86;
          v15 = (unsigned int)&v3[-2];
          if ( v14 > v3[-2].level )
            goto LABEL_86;
          while ( 2 )
          {
            if ( (unsigned int)equation < v15 )
            {
              if ( v14 <= *(_DWORD *)(v15 - 16 + 4) )
              {
                v15 -= 16;
                continue;
              }
              v42 = (token_type *)v15;
            }
            else
            {
              v42 = (token_type *)v15;
            }
            break;
          }
LABEL_86:
          if ( v14 == v42->level && v42->kind == CONSTANT )
            goto LABEL_147;
          memmove(&v42[2], v42, (char *)v3 - (char *)v42);
          v42->level = v14;
          v42->kind = CONSTANT;
          v42->token.constant = db;
          v42[1].level = v14;
          v42[1].kind = OPERATOR;
          v42[1].token.variable = 3;
          v3 = v42 - 1;
          if ( equation >= v42 )
            v3 = equation + 1;
          continue;
        case 4:
          v16 = v42->level;
          if ( (char *)v16 == d && v42->kind == CONSTANT && v42->token.constant == 0.0 )
          {
            da = v3 + 2;
            if ( v4 > &v3[2] && v16 <= v3[2].level )
            {
              v17 = v3 + 2;
              while ( 1 )
              {
                v17 += 2;
                if ( v4 <= v17 )
                  break;
                if ( v16 > v17->level )
                {
                  da = v17;
                  goto LABEL_132;
                }
              }
              da = v17;
            }
            goto LABEL_132;
          }
          v18 = v3 + 1;
          if ( (char *)v3[1].level != d )
            goto LABEL_147;
          if ( v18->kind == CONSTANT )
          {
            f_to_fraction(v3[1].token.constant, numerator, &denominator);
            check_divide_by_zero(numerator[0]);
            v3[1].token.constant = denominator / numerator[0];
            v3->token.variable = 3;
            continue;
          }
          if ( v18->kind == VARIABLE && (v3[1].token.variable & 0x3FFF) == 4 )
          {
            v3->token.variable = 3;
            continue;
          }
          goto LABEL_147;
        case 5:
        case 9:
          v19 = v42->level;
          if ( (char *)v19 != d || v42->kind || v42->token.constant != 0.0 )
            goto LABEL_147;
          da = v3 + 2;
          if ( v4 <= &v3[2] || v3[2].level < v19 )
            goto LABEL_132;
          v20 = v3 + 2;
          while ( 1 )
          {
            v20 += 2;
            if ( v4 <= v20 )
              break;
            if ( v19 > v20->level )
            {
              da = v20;
              goto LABEL_132;
            }
          }
          da = v20;
          goto LABEL_132;
        case 6:
          v21 = v42->level;
          if ( (char *)v21 == d && v42->kind == CONSTANT && v42->token.constant == 1.0 )
          {
            da = v3 + 2;
            if ( v4 > &v3[2] && v3[2].level > v21 )
            {
              v22 = v3 + 2;
              while ( 1 )
              {
                v22 += 2;
                if ( v4 <= v22 )
                  break;
                if ( v21 >= v22->level )
                {
                  da = v22;
                  goto LABEL_132;
                }
              }
              da = v22;
            }
LABEL_132:
            memmove(v3, da, (char *)v4 - (char *)da);
            *np -= da - v3;
            modified = 1;
            continue;
          }
          v37 = v3 + 1;
          v23 = v3[1].level;
          if ( (char *)v23 != d || v3[1].kind )
            goto LABEL_147;
          if ( v3[1].token.constant == 0.0 )
          {
            if ( equation >= v42 )
              goto LABEL_145;
            v24 = (unsigned int)&v3[-2];
            if ( v3[-2].level <= v23 )
              goto LABEL_145;
            while ( (unsigned int)equation < v24 )
            {
              if ( v23 >= *(_DWORD *)(v24 - 16 + 4) )
              {
                v42 = (token_type *)v24;
                goto LABEL_145;
              }
              v24 -= 16;
            }
            v42 = (token_type *)v24;
LABEL_145:
            memmove(v42, v37, (char *)v4 - (char *)&v3[1]);
            *np -= v37 - v42;
            v42->token.constant = 1.0;
            v3 = v42 + 1;
            modified = 1;
            continue;
          }
          if ( epsilon < fabs(v3[1].token.constant - 1.0) )
          {
LABEL_147:
            v3 += 2;
            continue;
          }
          break;
        default:
          goto LABEL_147;
      }
LABEL_17:
      memmove(v3, &v3[2], (char *)v4 - (char *)&v3[2]);
      *np -= 2;
      modified = 1;
    }
    else
    {
      ++v3;
    }
  }
}

//----- (0805C1F9) --------------------------------------------------------
int __cdecl calc(int *op1p, double *k1p, int op2, double k2_0)
{
  int *v4; // ebx
  int v5; // eax
  long double v6; // fst7
  int result; // eax
  long double v8; // fst7
  long double v9; // fst6
  char v11; // c2
  long double v12; // fst7
  long double v13; // fst6
  char v15; // c2
  long double v16; // fst7
  long double v17; // fst7
  double d2; // [esp+28h] [ebp-30h] BYREF
  double d1; // [esp+30h] [ebp-28h] BYREF
  double d[2]; // [esp+38h] [ebp-20h] BYREF

  domain_check = 0;
  v4 = __errno_location();
  *v4 = 0;
  v5 = 0;
  if ( op1p )
    v5 = *op1p;
  switch ( op2 )
  {
    case 1:
    case 2:
      if ( v5 == 2 )
        d[0] = -*k1p;
      else
        d[0] = *k1p;
      d1 = fabs(d[0]) * epsilon;
      if ( op2 == 1 )
        v6 = k2_0 + d[0];
      else
        v6 = d[0] - k2_0;
      d[0] = v6;
      if ( d1 > fabs((double)v6) )
        d[0] = 0.0;
      if ( v5 )
      {
        if ( d[0] < 0.0 )
        {
          *op1p = 2;
          *k1p = -d[0];
        }
        else
        {
          *op1p = 1;
          *k1p = d[0];
        }
        result = 1;
      }
      else
      {
        *k1p = d[0];
        result = 1;
      }
      return result;
    case 3:
    case 4:
      if ( !v5 )
        v5 = 3;
      if ( v5 == op2 )
      {
        *k1p = k2_0 * *k1p;
        result = 1;
      }
      else if ( v5 == 4 )
      {
        check_divide_by_zero(*k1p);
        *k1p = k2_0 / *k1p;
        *op1p = 3;
        result = 1;
      }
      else
      {
        if ( op2 != 4 )
          return 1;
        check_divide_by_zero(k2_0);
        *k1p = *k1p / k2_0;
        result = 1;
      }
      return result;
    case 5:
      if ( k2_0 == 0.0 )
        warning("Modulo 0 encountered, might be considered undefined.");
      v8 = modf(*k1p / k2_0, d) * k2_0;
      *k1p = v8;
      if ( !modulus_mode )
        return 1;
      if ( v8 < 0.0 )
        *k1p = v8 + fabs(k2_0);
      if ( modulus_mode != 1 || k2_0 >= 0.0 || *k1p <= 0.0 )
        return 1;
      *k1p = k2_0 + *k1p;
      return 1;
    case 6:
      if ( *k1p < 0.0 )
      {
        v9 = k2_0;
        do
          v9 = __FPREM__(v9, 1.0);
        while ( v11 );
        if ( v9 != 0.0 )
          return 1;
      }
      domain_check = 1;
      if ( *k1p == 0.0 )
      {
        v12 = *k1p;
        if ( k2_0 == 0.0 )
        {
          warning("0^0 encountered, might be considered indeterminate.");
          d[0] = 1.0;
          goto LABEL_55;
        }
      }
      else
      {
        v12 = *k1p;
        if ( v12 != 0.0 )
          goto LABEL_46;
      }
      if ( k2_0 < 0.0 )
      {
        warning("Divide by zero (0 raised to negative power).");
        d[0] = INFINITY;
        goto LABEL_55;
      }
LABEL_46:
      d[0] = pow(v12, k2_0);
      if ( preserve_surds )
      {
        if ( !approximate_roots )
        {
          if ( __finite(k2_0) )
          {
            v13 = k2_0;
            do
              v13 = __FPREM__(v13, 1.0);
            while ( v15 );
            if ( v13 != 0.0 )
            {
              if ( f_to_fraction(*k1p, &d1, &d2) )
              {
                result = f_to_fraction(d[0], &d1, &d2);
                if ( !result )
                {
                  domain_check = 0;
                  return result;
                }
              }
            }
          }
        }
      }
LABEL_55:
      check_err();
      if ( !domain_check )
        return 1;
      *k1p = d[0];
      return 1;
    case 7:
      v16 = lgamma(*k1p + 1.0);
      v17 = exp(v16) * (long double)signgam;
      d[0] = v17;
      if ( *v4 )
        return 0;
      *k1p = v17;
      return 1;
    case 9:
      check_divide_by_zero(k2_0);
      modf(*k1p / k2_0, k1p);
      return 1;
    default:
      return 0;
  }
}
// 805C416: variable 'v11' is possibly undefined
// 805C504: variable 'v15' is possibly undefined
// 8079368: using guessed type int signgam;

//----- (0805C5E4) --------------------------------------------------------
int __usercall const_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int iflag)
{
  int v5; // ebx
  token_type *v6; // esi
  int v7; // eax
  int v8; // eax
  int *v9; // eax
  int v10; // ecx
  storage_type *v11; // eax
  double *v12; // esi
  token_type *v13; // eax
  _DWORD *v14; // esi
  token_type *v15; // ecx
  token_type *v16; // eax
  int v17; // eax
  long double v18; // fst5
  char v20; // c2
  long double v21; // fst5
  char v23; // c2
  double *v24; // edx
  token_type *v25; // ecx
  token_type *v26; // edx
  int v27; // esi
  token_type *v28; // eax
  token_type *v29; // eax
  double *v30; // ecx
  token_type *v31; // eax
  _DWORD *v32; // ecx
  token_type *v33; // esi
  token_type *v34; // eax
  int v35; // eax
  complexs_0 v37; // [esp+4h] [ebp-D4h] BYREF
  complexs_0 v38[2]; // [esp+14h] [ebp-C4h] BYREF
  int v39; // [esp+3Ch] [ebp-9Ch]
  int v40; // [esp+40h] [ebp-98h]
  int v41; // [esp+44h] [ebp-94h]
  double d2; // [esp+48h] [ebp-90h]
  void *dest; // [esp+54h] [ebp-84h]
  double d3; // [esp+58h] [ebp-80h]
  void *src; // [esp+64h] [ebp-74h]
  int const_count; // [esp+68h] [ebp-70h]
  int loc1; // [esp+6Ch] [ebp-6Ch]
  int modified; // [esp+70h] [ebp-68h]
  token_type *v49; // [esp+74h] [ebp-64h]
  int *v50; // [esp+78h] [ebp-60h]
  token_type *v51; // [esp+7Ch] [ebp-5Ch]
  complexs_0 p; // [esp+88h] [ebp-50h] BYREF
  complexs_0 cv; // [esp+98h] [ebp-40h] BYREF
  double denominator; // [esp+A8h] [ebp-30h] BYREF
  double numerator; // [esp+B0h] [ebp-28h] BYREF
  double d1[4]; // [esp+B8h] [ebp-20h] BYREF

  v51 = equation;
  v50 = np;
  v41 = loc;
  loc1 = loc;
  v5 = loc;
  modified = 0;
  const_count = 0;
  v40 = level + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v5 >= *v50 || (v49 = (token_type *)v5, v6 = &v51[v5], v7 = v6->level, v7 < level) )
      {
        if ( v5 - v41 == 1 )
        {
          v8 = level - 1;
          if ( level - 1 <= 0 )
            v8 = 1;
          v51[v41].level = v8;
        }
        return modified;
      }
      if ( v7 <= level )
        break;
      modified |= const_recurse(v51, v50, v5, v40, iflag);
      if ( v5 < *v50 && level < v6->level )
      {
        v9 = &v51[v5 + 1].level;
        do
        {
          if ( ++v5 >= *v50 )
            break;
          v10 = *v9;
          v9 += 4;
        }
        while ( level < v10 );
      }
    }
    if ( v6->kind == CONSTANT )
    {
      if ( !const_count )
      {
        loc1 = v5;
        const_count = 1;
        goto LABEL_46;
      }
      dest = &v51[(int)v49 - 1];
      LODWORD(d3) = *((_DWORD *)dest + 2);
      v39 = loc1;
      src = &v51[loc1];
      d1[0] = *((double *)src + 1);
      d2 = v6->token.constant;
      v11 = 0;
      if ( loc1 > v41 )
        v11 = &v51[v39 - 1].token;
      if ( calc((int *)v11, d1, SLODWORD(d3), d2) )
        break;
    }
LABEL_46:
    ++v5;
  }
  if ( LODWORD(d3) != 6 || domain_check )
  {
not_imaginary:
    *((double *)src + 1) = d1[0];
    domain_check = 0;
    memmove(dest, &v51[(int)v49 + 1], 16 * (*v50 + ~v5));
    *v50 -= 2;
    v5 -= 2;
    modified = 1;
    goto LABEL_46;
  }
  if ( !f_to_fraction(d2, &numerator, &denominator) )
  {
    v49 = &v51[v5];
    if ( iflag && (!preserve_surds || approximate_roots) )
    {
      cv.re = d1[0];
      cv.im = 0.0;
      p.re = d2;
      p.im = 0.0;
      qmemcpy(v38, &p, 0x10u);
      qmemcpy(&v37, &cv, sizeof(v37));
      complex_pow(&cv, v37, v38[0]);
      if ( *v50 + 2 > n_tokens )
        error_huge();
      HIDWORD(v37.re) = 16 * (*v50 - loc1);
      v12 = (double *)src;
      memmove(&v51[v39 + 2], src, HIDWORD(v37.re));
      *v50 += 2;
      *((_DWORD *)v12 + 1) = level;
      *(_DWORD *)v12 = 0;
      v12[1] = cv.re;
      v13 = &v51[loc1 + 1];
      v13->level = level;
      v13->kind = OPERATOR;
      v13->token.variable = 1;
      v14 = v49;
      v49->level = level + 1;
      *v14 = 1;
      v14[2] = 3;
      v15 = v51;
      v16 = &v51[v5 + 1];
      v16->level = level + 1;
      v16->kind = OPERATOR;
      v16->token.variable = 3;
      v17 = (int)&v15[v5 + 2];
      *(_DWORD *)(v17 + 4) = level + 1;
      *(_DWORD *)v17 = 0;
      *(double *)(v17 + 8) = cv.im;
      modified = 1;
    }
    return modified;
  }
  *__errno_location() = 0;
  d3 = pow(-d1[0], d2);
  check_err();
  v18 = denominator;
  do
    v18 = __FPREM__(v18, 2.0);
  while ( v20 );
  if ( v18 != 0.0 )
  {
    v21 = numerator;
    do
      v21 = __FPREM__(v21, 2.0);
    while ( v23 );
    if ( v21 != 0.0 )
      d3 = -d3;
    d1[0] = d3;
    goto not_imaginary;
  }
  v49 = v6;
  if ( iflag )
  {
    if ( *v50 + 2 > n_tokens )
      error_huge();
    memmove(&v51[v39 + 2], src, 16 * (*v50 - loc1));
    *v50 += 2;
    if ( d2 == 0.5 )
    {
      v24 = (double *)src;
      *((_DWORD *)src + 1) = level + 1;
      *(_DWORD *)v24 = 0;
      v24[1] = -d1[0];
      v25 = v51;
      v26 = &v51[loc1 + 1];
      v26->level = level + 1;
      v26->kind = OPERATOR;
      v26->token.variable = 6;
      v27 = (int)v49;
      v49->level = level + 1;
      *(_DWORD *)v27 = 0;
      *(double *)(v27 + 8) = 0.5;
      v28 = &v25[v5 + 1];
      v28->level = level;
      v28->kind = OPERATOR;
      v28->token.variable = 3;
      v29 = &v25[v5 + 2];
      v29->level = level;
      v29->kind = VARIABLE;
      v29->token.variable = 3;
    }
    else
    {
      v30 = (double *)src;
      *((_DWORD *)src + 1) = level;
      *(_DWORD *)v30 = 0;
      v30[1] = d3;
      v31 = &v51[loc1 + 1];
      v31->level = level;
      v31->kind = OPERATOR;
      v31->token.variable = 3;
      v32 = v49;
      v49->level = level + 1;
      *v32 = 1;
      v32[2] = 3;
      v33 = v51;
      v34 = &v51[v5 + 1];
      v34->level = level + 1;
      v34->kind = OPERATOR;
      v34->token.variable = 6;
      v35 = (int)&v33[v5 + 2];
      *(_DWORD *)(v35 + 4) = level + 1;
      *(_DWORD *)v35 = 0;
      *(double *)(v35 + 8) = d2 + d2;
    }
    modified = 1;
  }
  return modified;
}
// 805C908: variable 'v20' is possibly undefined
// 805C94A: variable 'v23' is possibly undefined

//----- (0805CB7B) --------------------------------------------------------
int __cdecl combine_constants(token_type *equation, int *np, int iflag)
{
  return const_recurse(equation, np, 0, 1, iflag);
}

//----- (0805CBA1) --------------------------------------------------------
int __cdecl integer_root_simp(token_type *equation, int *np)
{
  int v2; // eax
  int v3; // esi
  token_type *v4; // edi
  long double v5; // fst6
  char v7; // c2
  int *v8; // ebx
  long double v9; // fst7
  long double v10; // fst6
  int v11; // ebx
  int i; // eax
  int v13; // ecx
  int v14; // edx
  int *v15; // eax
  token_type *dest; // [esp+18h] [ebp-40h]
  int v18; // [esp+1Ch] [ebp-3Ch]
  int d2; // [esp+20h] [ebp-38h]
  double d2a; // [esp+20h] [ebp-38h]
  double d2b; // [esp+20h] [ebp-38h]
  int modified; // [esp+2Ch] [ebp-2Ch]
  token_type *src; // [esp+30h] [ebp-28h]
  int v24; // [esp+34h] [ebp-24h]

  v2 = *np;
  v3 = 1;
  for ( modified = 0; *np - 2 > v3; v2 = *np )
  {
    v4 = &equation[v3];
    if ( v4->token.variable == 6 )
    {
      src = &equation[v3 - 1];
      v24 = src->level;
      if ( v24 == v4->level )
      {
        d2 = equation[v3 + 2].level;
        if ( d2 == v24 + 1
          && equation[v3 + 2].token.variable == 4
          && d2 == equation[v3 + 3].level
          && src->kind == CONSTANT )
        {
          dest = &equation[v3 + 1];
          if ( dest->kind == CONSTANT
            && equation[v3 + 3].kind == CONSTANT
            && (v3 + 4 >= v2 || v24 > equation[v3 + 4].level) )
          {
            d2a = equation[v3 + 1].token.constant;
            if ( d2a >= 1.0 && d2a <= 50.0 )
            {
              v5 = d2a;
              do
                v5 = __FPREM__(v5, 1.0);
              while ( v7 );
              if ( v5 == 0.0 )
              {
                v8 = __errno_location();
                *v8 = 0;
                v9 = pow(src->token.constant, d2a);
                if ( !*v8 )
                {
                  v10 = equation[v3 + 3].token.constant;
                  if ( v10 <= 50.0 && v10 >= 2.0 )
                  {
                    v11 = (int)v10;
                    if ( v10 == (long double)(int)v10 && v11 > 1 && factor_one(v9) )
                    {
                      v18 = uno;
                      d2b = 1.0;
                      for ( i = 0; i < v18; ++i )
                      {
                        while ( 1 )
                        {
                          v13 = ucnt[i];
                          if ( v11 > v13 )
                            break;
                          d2b = d2b * unique[i];
                          ucnt[i] = v13 - v11;
                        }
                      }
                      if ( d2b != 1.0 )
                      {
                        if ( *np + 2 > n_tokens )
                          error_huge();
                        equation[v3 + 1].token.constant = 1.0;
                        src->token.constant = multiply_out_unique();
                        v14 = v3 - 1;
                        v15 = &equation[v3 - 1].level;
                        while ( v14 < v3 + 4 )
                        {
                          ++*v15;
                          ++v14;
                          v15 += 4;
                        }
                        memmove(dest, src, 16 * (*np + 1 - v3));
                        *np += 2;
                        v4->level = v24;
                        v4->kind = OPERATOR;
                        v4->token.variable = 3;
                        src->level = v24;
                        src->kind = CONSTANT;
                        src->token.constant = d2b;
                        v3 += 2;
                        modified = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v3 += 2;
  }
  return modified;
}
// 805CCBD: variable 'v7' is possibly undefined

//----- (0805CEBA) --------------------------------------------------------
void __cdecl organize(token_type *equation, int *np)
{
  if ( *np <= 0 || (*np & 1) == 0 )
  {
    __printf_chk(1, "Bad expression size = %d.\n", *np);
    error_bug("Internal error: organize() called with bad expression size.");
  }
  if ( *np > n_tokens )
    error_bug("Internal error: expression array overflow detected in organize().");
  org_recurse(equation, np, 0, 1, 0);
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0805CF2C) --------------------------------------------------------
void __cdecl elim_loop(token_type *equation, int *np)
{
  if ( abort_flag )
  {
    abort_flag = 0;
    __longjmp_chk(jmp_save, 13);
  }
  list_debug(6, equation, *np, 0, 0);
  do
  {
    do
      organize(equation, np);
    while ( combine_constants(equation, np, 1) );
  }
  while ( elim_k(equation, np) || simp_pp(equation, np) );
  if ( reorder(equation, np) )
  {
    do
      organize(equation, np);
    while ( elim_k(equation, np) );
  }
  list_debug(5, equation, *np, 0, 0);
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);

//----- (0805D024) --------------------------------------------------------
int __cdecl simp_loop(token_type *equation, int *np)
{
  int v2; // edi

  v2 = 0;
  do
  {
    while ( 1 )
    {
      do
        elim_loop(equation, np);
      while ( simp2_power(equation, np) );
      if ( !factor_times(equation, np) )
        break;
      v2 = 1;
    }
  }
  while ( elim_sign(equation, np) || subtract_itself(equation, np) );
  return v2;
}

//----- (0805D095) --------------------------------------------------------
void __cdecl simp_divide(token_type *equation, int *np)
{
  do
  {
    do
      simp_loop(equation, np);
    while ( factor_constants(equation, np, 1) );
  }
  while ( factor_divide(equation, np, 0, 0.0) );
}

//----- (0805D0EC) --------------------------------------------------------
void __cdecl factorv(token_type *equation, int *np, int v)
{
  if ( v == 3 )
    approximate_complex_roots(equation, np);
  do
  {
    do
      simp_loop(equation, np);
    while ( factor_plus(equation, np, v, 0.0) );
  }
  while ( v == 3 && div_imaginary(equation, np) );
}

//----- (0805D152) --------------------------------------------------------
void __cdecl simp_equation(int n)
{
  if ( n_lhs[n] > 0 )
  {
    simp_loop(lhs[n], &n_lhs[n]);
    if ( n_rhs[n] )
      simp_loop(rhs[n], (int *)(4 * n + 134715712));
  }
}

//----- (0805D1B8) --------------------------------------------------------
void __cdecl simp2_divide(token_type *equation, int *np, int v, int fc_level)
{
  do
  {
    do
      elim_loop(equation, np);
    while ( simp2_power(equation, np) );
  }
  while ( elim_sign(equation, np)
       || subtract_itself(equation, np)
       || factor_constants(equation, np, fc_level)
       || factor_divide(equation, np, v, 0.0) );
}

//----- (0805D23F) --------------------------------------------------------
void __cdecl simp_ssub(token_type *equation, int *np, int v, double d, int power_flag, int times_flag, int fc_level)
{
  do
  {
    do
      elim_loop(equation, np);
    while ( simp2_power(equation, np) );
  }
  while ( times_flag && factor_times(equation, np)
       || elim_sign(equation, np)
       || subtract_itself(equation, np)
       || factor_constants(equation, np, fc_level)
       || factor_divide(equation, np, v, d)
       || factor_plus(equation, np, v, d)
       || power_flag && factor_power(equation, np) );
}

//----- (0805D324) --------------------------------------------------------
void __cdecl simpb_side(token_type *equation, int *np, int uf_power_flag, int power_flag, int fc_level)
{
  int v5; // edi
  int v6; // ebx
  int v7; // ecx
  int v8; // edx
  token_type *v9; // eax
  int i; // ebx
  int j; // ebx
  int cnt; // [esp+28h] [ebp-1F60h]
  int vc; // [esp+2Ch] [ebp-1F5Ch]
  sort_type va[1000]; // [esp+30h] [ebp-1F58h] BYREF

  simp_loop(equation, np);
  if ( uf_power_flag )
    uf_allpower(equation, np);
  vc = 0;
  v5 = 0;
LABEL_19:
  if ( *np > 0 )
  {
    v9 = equation;
    v6 = -1;
    cnt = 0;
    v8 = 0;
    while ( 1 )
    {
      if ( v9->kind != VARIABLE )
        goto LABEL_11;
      v7 = v9->token.variable;
      if ( v7 <= v5 )
        goto LABEL_11;
      if ( v6 != -1 && v7 >= v6 )
        break;
      cnt = 1;
LABEL_13:
      v8 += 2;
      v9 += 2;
      if ( v8 >= *np )
      {
        if ( v7 != -1 )
        {
          if ( v7 > 3 )
          {
            va[vc].v = v7;
            va[vc++].count = cnt;
          }
          if ( vc <= 999 )
          {
            v5 = v7;
            goto LABEL_19;
          }
        }
        goto LABEL_21;
      }
      v6 = v7;
    }
    if ( v6 == v7 )
    {
      ++cnt;
      v7 = v6;
      goto LABEL_13;
    }
LABEL_11:
    v7 = v6;
    goto LABEL_13;
  }
LABEL_21:
  if ( vc )
  {
    qsort(va, vc, 8u, (__compar_fn_t)simpb_vcmp);
    simp2_divide(equation, np, va[0].v, fc_level);
    if ( vc > 1 )
    {
      for ( i = 1; i < vc; ++i )
      {
        if ( factor_divide(equation, np, va[i].v, 0.0) )
          simp2_divide(equation, np, va[i].v, fc_level);
      }
    }
    simp2_divide(equation, np, 0, fc_level);
    for ( j = 0; j < vc; ++j )
    {
      while ( factor_plus(equation, np, va[j].v, 0.0) )
        simp2_divide(equation, np, 0, fc_level);
    }
    while ( factor_plus(equation, np, 5, 0.0) )
      simp2_divide(equation, np, 0, fc_level);
  }
  simp_ssub(equation, np, 5, 0.0, power_flag, 1, fc_level);
}

//----- (0805D5D8) --------------------------------------------------------
void __cdecl simple_frac_side(token_type *equation, int *np)
{
  if ( *np > 0 )
  {
    do
    {
      do
        simp_ssub(equation, np, 0, 1.0, 0, 1, 5);
      while ( poly_gcd_simp(equation, np) );
    }
    while ( uf_power(equation, np) || super_factor(equation, np, 2) );
    list_debug(2, equation, *np, 0, 0);
    make_fractions(equation, np);
    uf_tsimp(equation, np);
    poly_factor(equation, np, 1);
    simpb_side(equation, np, 1, 0, 2);
    fractions_and_group(equation, np);
  }
}

//----- (0805D6E2) --------------------------------------------------------
void __cdecl simpv_side(token_type *equation, int *np, int v)
{
  if ( *np )
    simp_ssub(equation, np, v, 0.0, v == 0, 1, 6);
}

//----- (0805D72A) --------------------------------------------------------
void __cdecl simp_side(token_type *equation, int *np)
{
  simp_ssub(equation, np, 0, 1.0, 1, 1, 6);
}

//----- (0805D76A) --------------------------------------------------------
void __cdecl calc_simp(token_type *equation, int *np)
{
  approximate_roots = 1;
  subst_constants(equation, np);
  simp_side(equation, np);
  uf_power(equation, np);
  factorv(equation, np, 3);
  ufactor(equation, np);
  factorv(equation, np, 3);
  uf_simp(equation, np);
  factorv(equation, np, 3);
  simp_side(equation, np);
  make_fractions(equation, np);
  uf_tsimp(equation, np);
  approximate_roots = 0;
}

//----- (0805D82F) --------------------------------------------------------
void __cdecl simps_side(token_type *equation, int *np, int zsolve)
{
  elim_loop(equation, np);
  simp_constant_power(equation, np);
  do
    simp_ssub(equation, np, 0, 0.0, zsolve == 0, 1, 6);
  while ( super_factor(equation, np, 0) );
}

//----- (0805D8AF) --------------------------------------------------------
void __cdecl simp_i(token_type *equation, int *np)
{
  token_type *v2; // esi
  int *v3; // ebx
  int v4; // eax
  int v5; // edi
  token_type *v6; // ebx
  token_type *v7; // eax
  token_type *v8; // eax
  int level; // [esp+18h] [ebp-20h]

  v2 = equation;
  v3 = np;
  simp_loop(equation, np);
  v4 = *np;
  if ( *np > 0 )
  {
    v5 = 0;
    do
    {
      v6 = &equation[v5];
      if ( v6->kind == VARIABLE && v6->token.variable == 3 )
      {
        if ( v4 + 2 > n_tokens )
          error_huge();
        level = v6->level + 1;
        memmove(&equation[v5 + 2], &equation[v5], 16 * (*np - v5));
        *np += 2;
        v6->level = level;
        v6->kind = CONSTANT;
        v6->token.constant = -1.0;
        v7 = &equation[v5 + 1];
        v7->level = level;
        v7->kind = OPERATOR;
        v7->token.variable = 6;
        v5 += 2;
        v8 = &equation[v5];
        v8->level = level;
        v8->kind = CONSTANT;
        v8->token.constant = 0.5;
      }
      v5 += 2;
      v4 = *np;
    }
    while ( *np > v5 );
    v3 = np;
    v2 = equation;
  }
  do
  {
    do
    {
      organize(v2, v3);
      combine_constants(v2, v3, 0);
    }
    while ( elim_k(v2, v3) );
  }
  while ( simp_pp(v2, v3) || factor_power(v2, v3) || factor_times(v2, v3) );
  simp_loop(v2, v3);
}

//----- (0805DA11) --------------------------------------------------------
void __cdecl simpa_side(token_type *equation, int *np, int quick_flag, int frac_flag)
{
  int v4; // ebx
  int v5; // ebx
  jmp_buf save_save; // [esp+24h] [ebp-A4h] BYREF

  if ( *np > 1 )
  {
    list_debug(2, equation, *np, 0, 0);
    simpb_side(equation, np, 0, 1, 1);
    if ( rationalize_denominators )
      rationalize(equation, np);
    unsimp_power(equation, np);
    uf_times(equation, np);
    simp_loop(equation, np);
    uf_pplus(equation, np);
    uf_repeat(equation, np);
    do
      elim_loop(equation, np);
    while ( mod_simp(equation, np) );
    simp_i(equation, np);
    unsimp_power(equation, np);
    uf_times(equation, np);
    simp_ssub(equation, np, 0, 1.0, 1, 1, 1);
    unsimp_power(equation, np);
    uf_neg_help(equation, np);
    uf_times(equation, np);
    do
    {
      do
        simp_ssub(equation, np, 0, 1.0, 0, 1, 2);
      while ( poly_gcd_simp(equation, np) );
    }
    while ( uf_power(equation, np) || super_factor(equation, np, 2) );
    unsimp_power(equation, np);
    uf_times(equation, np);
    factorv(equation, np, 3);
    uf_pplus(equation, np);
    simp_ssub(equation, np, 0, 1.0, 1, 0, 1);
    uf_times(equation, np);
    uf_pplus(equation, np);
    factorv(equation, np, 3);
    uf_power(equation, np);
    do
    {
      do
        simp_ssub(equation, np, 0, 1.0, 0, 1, 6);
      while ( poly_gcd_simp(equation, np) );
    }
    while ( uf_power(equation, np) || super_factor(equation, np, 2) );
    partial_flag = frac_flag;
    n_tlhs = *np;
    memmove(tlhs, equation, 16 * n_tlhs);
    memmove(save_save, jmp_save, 0x9Cu);
    v4 = _setjmp(jmp_save);
    if ( v4 )
    {
      memmove(jmp_save, save_save, 0x9Cu);
      if ( v4 == 13 )
        __longjmp_chk(jmp_save, 13);
      *np = n_tlhs;
      memmove(equation, tlhs, 16 * n_tlhs);
      if ( debug_level > 0 )
        __fprintf_chk(gfp, 1, "%s\n", "Simplify not expanding fully, due to oversized expression.");
      partial_flag = 1;
      uf_tsimp(equation, np);
    }
    else
    {
      if ( quick_flag )
      {
        uf_tsimp(equation, np);
      }
      else
      {
        do
        {
          uf_power(equation, np);
          uf_repeat(equation, np);
        }
        while ( uf_tsimp(equation, np) );
      }
      memmove(jmp_save, save_save, 0x9Cu);
    }
    partial_flag = 1;
    simpb_side(equation, np, 1, 1, 2);
    if ( debug_level > 0 )
      __fprintf_chk(gfp, 1, "%s\n", "Simplify result before applying polynomial operations:");
    list_debug(1, equation, *np, 0, 0);
    v5 = 0;
    while ( !poly_gcd_simp(equation, np) )
    {
      if ( v5 )
      {
LABEL_32:
        if ( frac_flag || !div_remainder(equation, np, 1, quick_flag) )
        {
          simp_constant_power(equation, np);
          simp_ssub(equation, np, 0, 1.0, 1, 1, 5);
          unsimp_power(equation, np);
          make_fractions(equation, np);
          factor_power(equation, np);
          uf_tsimp(equation, np);
          make_fractions(equation, np);
          uf_power(equation, np);
          integer_root_simp(equation, np);
          simpb_side(equation, np, 1, 1, 3);
          poly_factor(equation, np, 0);
          simpb_side(equation, np, 1, frac_flag == 0, 2);
          return;
        }
        simpb_side(equation, np, 0, 1, 3);
        v5 = 0;
      }
      else
      {
LABEL_30:
        if ( !poly_factor(equation, np, 1) )
          goto LABEL_32;
        simpb_side(equation, np, 0, 1, 3);
        v5 = 1;
      }
    }
    simpb_side(equation, np, 0, 1, 3);
    goto LABEL_30;
  }
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0805E1EE) --------------------------------------------------------
void __cdecl simpa_repeat_side(token_type *equation, int *np, int quick_flag, int frac_flag)
{
  simpa_side(equation, np, quick_flag, frac_flag);
  if ( repeat_flag )
  {
    do
    {
      n_tes = *np;
      memmove(tes, equation, 16 * n_tes);
      simpa_side(equation, np, quick_flag, frac_flag);
    }
    while ( *np < n_tes );
    if ( n_tes != *np )
    {
      *np = n_tes;
      memmove(equation, tes, 16 * n_tes);
    }
  }
}

//----- (0805E290) --------------------------------------------------------
int __usercall fpower_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level)
{
  int v4; // edx
  token_type *v5; // ebx
  int v6; // eax
  token_type *v7; // eax
  int v8; // esi
  int v9; // ecx
  int k; // ebx
  int v11; // ebx
  int *v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // edi
  int *v17; // edx
  int v18; // eax
  int v19; // ecx
  int *v20; // edx
  int v21; // ebx
  int *v22; // edx
  int v23; // edi
  int v24; // ecx
  int *v25; // eax
  int v26; // edx
  int v27; // edx
  int v28; // eax
  int v29; // ebx
  int *v30; // eax
  int v31; // eax
  int v32; // ebx
  int v33; // ebx
  int i; // edx
  int v35; // edx
  int v36; // ebx
  int v37; // edi
  int v38; // edi
  int v39; // edx
  int v40; // edi
  int v41; // edi
  int v42; // edx
  int v43; // edx
  int v44; // edi
  int v45; // edx
  int v46; // edx
  int v47; // ebx
  int v48; // edx
  int v49; // eax
  int v50; // eax
  int *v51; // edx
  int v52; // ebx
  int v53; // eax
  int v55; // [esp+2Ch] [ebp-9Ch]
  int v56; // [esp+40h] [ebp-88h]
  int modified; // [esp+44h] [ebp-84h]
  int len1; // [esp+50h] [ebp-78h]
  int v59; // [esp+54h] [ebp-74h]
  int v60; // [esp+58h] [ebp-70h]
  int v61; // [esp+58h] [ebp-70h]
  token_type *v62; // [esp+5Ch] [ebp-6Ch]
  int v63; // [esp+60h] [ebp-68h]
  int p1; // [esp+64h] [ebp-64h]
  int v65; // [esp+68h] [ebp-60h]
  int v66; // [esp+70h] [ebp-58h]
  int v67; // [esp+70h] [ebp-58h]
  int v70; // [esp+7Ch] [ebp-4Ch]
  int v71; // [esp+80h] [ebp-48h]
  int len2; // [esp+84h] [ebp-44h]
  int v73; // [esp+88h] [ebp-40h]
  int v74; // [esp+8Ch] [ebp-3Ch]
  _BOOL4 v75; // [esp+8Ch] [ebp-3Ch]
  bool v76; // [esp+8Ch] [ebp-3Ch]
  token_type *dest; // [esp+90h] [ebp-38h]
  int n1; // [esp+94h] [ebp-34h]
  int n1a; // [esp+94h] [ebp-34h]
  int n1b; // [esp+94h] [ebp-34h]
  int j; // [esp+9Ch] [ebp-2Ch]
  int ja; // [esp+9Ch] [ebp-2Ch]
  int diff_signp[7]; // [esp+ACh] [ebp-1Ch] BYREF

  v4 = loc + 1;
  if ( loc + 1 < *np )
  {
    v5 = &equation[v4];
    v6 = v5->level;
    if ( level <= v6 )
    {
      if ( v6 == level )
      {
LABEL_6:
        if ( (unsigned int)(v5->token.variable - 3) <= 1 )
        {
          v71 = loc;
          modified = 0;
          v8 = level + 1;
          v55 = level + 2;
          v56 = level + 2;
          while ( 1 )
          {
            while ( 1 )
            {
              v74 = v71 + 1;
              v11 = *np;
              if ( v71 + 1 >= *np || level >= equation[v74].level )
              {
                v13 = v71 + 1;
              }
              else
              {
                v12 = &equation[v71 + 3].level;
                v13 = v71 + 1;
                do
                {
                  v13 += 2;
                  if ( v13 >= v11 )
                    break;
                  v14 = *v12;
                  v12 += 8;
                }
                while ( level < v14 );
              }
              len1 = v13 - v71;
              v73 = v13;
              v15 = v13 + 1;
              j = v15;
              if ( v15 < v11 )
              {
                v65 = v15;
                dest = &equation[v15 - 1];
                if ( level <= dest->level )
                  break;
              }
LABEL_103:
              v71 = v74 + len1;
              if ( v74 + len1 >= v11 || level > equation[v74 - 1 + len1].level )
                goto LABEL_12;
            }
            v62 = &equation[v71 - 1];
            while ( 1 )
            {
              v16 = j + 1;
              if ( j + 1 >= v11 || level >= equation[v16].level )
              {
                v18 = j + 1;
              }
              else
              {
                v17 = &equation[j + 3].level;
                v18 = j + 1;
                do
                {
                  v18 += 2;
                  if ( v18 >= v11 )
                  {
                    v16 = j + 1;
                    goto LABEL_32;
                  }
                  v19 = *v17;
                  v17 += 8;
                }
                while ( level < v19 );
                v16 = j + 1;
              }
LABEL_32:
              len2 = v18 - j;
              v66 = dest->token.variable;
              v70 = 3;
              if ( v71 > loc )
                v70 = v62->token.variable;
              if ( v74 >= v73 )
                goto LABEL_102;
              v20 = &equation[v74].level;
              v21 = v71 + 1;
              while ( v8 != *v20 || v20[1] != 6 )
              {
                v21 += 2;
                v20 += 8;
                if ( v73 <= v21 )
                  goto LABEL_102;
              }
              v63 = v18;
              if ( v16 >= v18 )
                goto LABEL_102;
              v22 = &equation[v16].level;
              while ( v8 != *v22 || v22[1] != 6 )
              {
                v16 += 2;
                v22 += 8;
                if ( v18 <= v16 )
                  goto LABEL_102;
              }
              n1 = v73 + ~v21;
              if ( se_compare(&equation[v21 + 1], n1, &one_token, 1, diff_signp) )
                goto LABEL_102;
              if ( se_compare(&equation[v21 + 1], n1, &equation[v16 + 1], v63 + ~v16, diff_signp) )
                break;
              while ( 1 )
              {
                v24 = 3;
                if ( equation[v21].token.variable != 6 )
                  v24 = equation[v21].token.variable;
                p1 = v24;
                v59 = v21 + 1;
                if ( v73 <= v21 + 1 )
                  break;
                v60 = v21 + 2;
                if ( v73 > v21 + 2 )
                {
                  v25 = &equation[v21 + 2].level;
                  v26 = v21 + 2;
                  while ( *v25 != v55 || (unsigned int)(v25[1] - 3) > 1 )
                  {
                    v26 += 2;
                    v25 += 8;
                    if ( v73 <= v26 )
                    {
                      v60 = v26;
                      goto LABEL_61;
                    }
                  }
                  v60 = v26;
                }
LABEL_61:
                v27 = se_compare(&equation[v59], v60 - v59, &one_token, 1, diff_signp);
                v28 = v16;
                if ( !v27 )
                {
                  while ( 1 )
                  {
                    n1b = v28 + 1;
                    if ( v63 <= v28 + 1 )
                      break;
                    v29 = v28 + 2;
                    if ( v63 > v28 + 2 )
                    {
                      v30 = &equation[v28 + 2].level;
                      do
                      {
                        if ( *v30 == v55 && (unsigned int)(v30[1] - 3) <= 1 )
                          break;
                        v29 += 2;
                        v30 += 8;
                      }
                      while ( v63 > v29 );
                    }
                    v31 = equation[n1b - 1].token.variable;
                    if ( v31 == 6 )
                    {
                      if ( p1 != 3 )
                        goto LABEL_63;
                    }
                    else if ( v31 != p1 )
                    {
                      goto LABEL_63;
                    }
                    if ( se_compare(&equation[v59], v60 - v59, &equation[n1b], v29 - n1b, diff_signp) )
                    {
                      v23 = n1b;
                      n1a = j + len2;
                      v63 = v29;
                      goto LABEL_76;
                    }
LABEL_63:
                    v28 = v29;
                  }
                }
                v21 = v60;
              }
LABEL_102:
              j += len2 + 1;
              v11 = *np;
              if ( *np > j )
              {
                v65 = j;
                dest = &equation[j - 1];
                if ( level <= dest->level )
                  continue;
              }
              goto LABEL_103;
            }
            v59 = v21 + 1;
            v23 = v16 + 1;
            n1a = j + len2;
            v60 = v73;
            p1 = 3;
LABEL_76:
            if ( v66 == 4 )
              diff_signp[0] = diff_signp[0] == 0;
            v75 = 0;
            if ( v70 == 4 )
              v75 = diff_signp[0] != 0;
            v67 = v59 - v71;
            v32 = v59 - v71;
            memmove(scratch, &equation[v71], v32 * 16);
            scratch[v32].level = v56;
            scratch[v32].kind = CONSTANT;
            v76 = !v75;
            if ( v76 && v70 == 4 )
              scratch[v32].token.constant = -1.0;
            else
              scratch[v32].token.constant = 1.0;
            memmove(&scratch[v67 + 1], &equation[v60], 16 * (v73 - v60));
            v33 = v73 - v60 + v67 + 1;
            if ( v33 > 0 )
            {
              for ( i = 0; i != v33; ++i )
                scratch[i].level += 2;
            }
            v35 = v33;
            scratch[v35].level = v56;
            scratch[v35].kind = OPERATOR;
            scratch[v35].token.variable = 3;
            v36 = v33 + 1;
            v37 = v23 - j;
            memmove(&scratch[v36], &equation[v65], 16 * v37);
            v38 = v36 + v37;
            v39 = v38;
            scratch[v39].level = v56;
            scratch[v39].kind = CONSTANT;
            if ( v76 && diff_signp[0] )
              scratch[v39].token.constant = -1.0;
            else
              scratch[v39].token.constant = 1.0;
            v40 = v38 + 1;
            memmove(&scratch[v40], &equation[v63], 16 * (n1a - v63));
            v41 = n1a - v63 + v40;
            if ( v36 < v41 )
            {
              v42 = v36;
              do
              {
                scratch[v42].level += 2;
                ++v36;
                ++v42;
              }
              while ( v41 > v36 );
            }
            v43 = v41;
            scratch[v43].level = level + 1;
            scratch[v43].kind = OPERATOR;
            scratch[v43].token.variable = 6;
            v44 = v41 + 1;
            if ( p1 == 4 )
            {
              v45 = v44;
              scratch[v45].level = v56;
              scratch[v45].kind = CONSTANT;
              scratch[v45].token.constant = 1.0;
              v46 = v44 + 1;
              scratch[v46].level = v56;
              scratch[v46].kind = OPERATOR;
              scratch[v46].token.variable = 4;
              v44 += 2;
            }
            v61 = v60 - v59;
            v47 = v44;
            memmove(&scratch[v44], &equation[v59], 16 * v61);
            v48 = v44 + v61;
            for ( ja = v44 + v61; v48 > v44; ++v47 )
            {
              ++scratch[v47].level;
              ++v44;
            }
            if ( ja + *np + ~len2 - len1 > n_tokens )
              error_huge();
            if ( v76 && v70 == 4 )
              v62->token.variable = 3;
            memmove(dest, &equation[n1a], 16 * (*np - n1a));
            v49 = *np + ~len2;
            *np = v49;
            memmove(&equation[v71 + ja], &equation[v73], 16 * (v49 - v73));
            *np += ja - len1;
            memmove(&equation[v71], scratch, 16 * ja);
            modified = 1;
          }
        }
      }
      else
      {
        v7 = &equation[loc + 3];
        while ( 1 )
        {
          v4 += 2;
          if ( v4 >= *np )
            break;
          v5 = v7;
          v9 = v7->level;
          if ( v9 < level )
            break;
          v7 += 2;
          if ( v9 == level )
            goto LABEL_6;
        }
      }
    }
  }
  modified = 0;
LABEL_12:
  for ( k = loc; k < *np; k = v50 )
  {
    v53 = equation[k].level;
    if ( level > v53 )
      break;
    if ( level >= v53 )
    {
      v50 = k + 1;
    }
    else
    {
      modified |= fpower_recurse(equation, np, k, level + 1);
      v50 = k + 1;
      if ( *np > k + 1 && level < equation[v50].level )
      {
        v51 = &equation[k + 3].level;
        do
        {
          v50 += 2;
          if ( *np <= v50 )
            break;
          v52 = *v51;
          v51 += 8;
        }
        while ( level < v52 );
      }
    }
  }
  return modified;
}

//----- (0805EB89) --------------------------------------------------------
int __cdecl factor_power(token_type *equation, int *np)
{
  return fpower_recurse(equation, np, 0, 1);
}

//----- (0805EBA8) --------------------------------------------------------
int __usercall ftimes_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level)
{
  int v4; // edx
  token_type *v5; // ebx
  int v6; // eax
  token_type *v7; // eax
  int v8; // edi
  int v9; // ecx
  int v10; // esi
  int *v11; // edx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ebx
  int *v16; // edx
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  int v20; // esi
  int *v21; // eax
  int *v22; // eax
  int v23; // eax
  int v24; // edx
  int *v25; // eax
  int v26; // edx
  token_type *v27; // eax
  token_type *v28; // esi
  token_type *v29; // eax
  int v30; // esi
  token_type *v31; // eax
  token_type *v32; // eax
  int i; // ebx
  int v34; // eax
  int *v35; // edx
  int v36; // ebx
  int v37; // eax
  token_type *v39; // [esp+40h] [ebp-88h]
  int modified; // [esp+44h] [ebp-84h]
  char v42; // [esp+50h] [ebp-78h]
  token_type *p1; // [esp+64h] [ebp-64h]
  int n1; // [esp+68h] [ebp-60h]
  int v45; // [esp+6Ch] [ebp-5Ch]
  int v46; // [esp+70h] [ebp-58h]
  int v47; // [esp+74h] [ebp-54h]
  int v48; // [esp+74h] [ebp-54h]
  int v49; // [esp+78h] [ebp-50h]
  bool v50; // [esp+78h] [ebp-50h]
  token_type *p2; // [esp+80h] [ebp-48h]
  token_type *p2b; // [esp+80h] [ebp-48h]
  token_type *p2a; // [esp+80h] [ebp-48h]
  int v55; // [esp+84h] [ebp-44h]
  int len1; // [esp+88h] [ebp-40h]
  int len1a; // [esp+88h] [ebp-40h]
  int len2; // [esp+8Ch] [ebp-3Ch]
  int j; // [esp+90h] [ebp-38h]
  token_type *v60; // [esp+94h] [ebp-34h]
  int v61; // [esp+94h] [ebp-34h]
  int n2; // [esp+98h] [ebp-30h]
  int n2a; // [esp+98h] [ebp-30h]
  int diff_signp[7]; // [esp+ACh] [ebp-1Ch] BYREF

  v4 = loc + 1;
  if ( loc + 1 >= *np || (v5 = &equation[v4], v6 = v5->level, level > v6) )
  {
LABEL_103:
    i = loc;
    modified = 0;
    goto LABEL_104;
  }
  if ( v6 != level )
  {
    v7 = &equation[loc + 3];
    do
    {
      v4 += 2;
      if ( v4 >= *np )
        goto LABEL_103;
      v5 = v7;
      v9 = v7->level;
      if ( v9 < level )
        goto LABEL_103;
      v7 += 2;
    }
    while ( v9 != level );
  }
  modified = 0;
  if ( (unsigned int)(v5->token.variable - 3) > 1 )
    goto LABEL_91;
  v46 = loc;
  v8 = level + 1;
LABEL_12:
  while ( 2 )
  {
    v47 = v46 + 1;
    v10 = *np;
    if ( v46 + 1 >= *np || level >= equation[v46 + 1].level )
    {
      v12 = v46 + 1;
    }
    else
    {
      v11 = &equation[v46 + 3].level;
      v12 = v46 + 1;
      do
      {
        v12 += 2;
        if ( v12 >= v10 )
          break;
        v13 = *v11;
        v11 += 8;
      }
      while ( level < v13 );
    }
    len1 = v12 - v46;
    v55 = v12;
    v14 = v12 + 1;
    j = v14;
    if ( v14 < v10 )
    {
      n2 = v14;
      v60 = &equation[v14 - 1];
      if ( level <= v60->level )
      {
        v39 = &equation[v46 - 1];
        p1 = &equation[v46];
        while ( 1 )
        {
          v15 = j + 1;
          if ( j + 1 >= v10 || level >= equation[v15].level )
          {
            v17 = j + 1;
          }
          else
          {
            v16 = &equation[j + 3].level;
            v17 = j + 1;
            do
            {
              v17 += 2;
              if ( v17 >= v10 )
              {
                v15 = j + 1;
                goto LABEL_31;
              }
              v18 = *v16;
              v16 += 8;
            }
            while ( level < v18 );
            v15 = j + 1;
          }
LABEL_31:
          len2 = v17 - j;
          v45 = v60->token.variable;
          v49 = 3;
          if ( v46 > loc )
            v49 = v39->token.variable;
          if ( len1 == 1 && p1->kind == CONSTANT || len2 == 1 && equation[n2].kind == CONSTANT )
            goto LABEL_88;
          v61 = v17;
          p2 = &equation[n2];
          if ( se_compare(p1, len1, p2, len2, diff_signp) )
            break;
          v20 = v46 + 1;
          if ( v47 < v55 )
          {
            v21 = &equation[v47].level;
            do
            {
              if ( v8 == *v21 && v21[1] == 6 )
                break;
              v20 += 2;
              v21 += 8;
            }
            while ( v55 > v20 );
          }
          if ( v15 < v61 )
          {
            v22 = &equation[v15].level;
            do
            {
              if ( v8 == *v22 && v22[1] == 6 )
                break;
              v15 += 2;
              v22 += 8;
            }
            while ( v61 > v15 );
          }
          if ( v55 <= v20 && v61 <= v15 )
            goto LABEL_88;
          if ( !se_compare(p1, v20 - v46, p2, v15 - j, diff_signp) )
          {
            if ( v55 <= v20 || v61 <= v15 )
              goto LABEL_88;
            if ( se_compare(p1, len1, p2, v15 - j, diff_signp) )
              goto LABEL_58;
            if ( !se_compare(p1, v20 - v46, p2, len2, diff_signp) )
              goto LABEL_88;
            v15 = j + len2;
          }
          if ( v55 == v20 )
            goto LABEL_58;
          n1 = v55 - 1 - v20;
LABEL_59:
          LOBYTE(v19) = v49 == 4;
          v50 = v49 != 4 || v45 != 4;
          LOBYTE(v19) = v50 & v19;
          v42 = v19;
          v23 = (v19 << 31 >> 31) & 2;
          v24 = 1;
          if ( v61 != v15 )
            v24 = v61 - 1 - v15;
          if ( v15 - j != 1 || p2->kind || p2->token.constant != -1.0 )
          {
            n2a = v24 + v20 + n1 + 2 - v46 - len1 + v23;
            if ( !diff_signp[0] )
            {
              len1a = v20;
              goto LABEL_71;
            }
            if ( v15 - j != 1 || p2->kind )
            {
              v48 = v61 + 2 - v15;
              if ( v48 + *np + n2a > n_tokens )
                error_huge();
              p2b = &equation[v61];
              memmove(&equation[v61 + v48], p2b, 16 * (*np - v61));
              *np += v48;
              p2b->level = level;
              p2b->kind = OPERATOR;
              p2b->token.variable = v45;
              p2b[1].level = level + 1;
              p2b[1].kind = CONSTANT;
              p2b[1].token.constant = -1.0;
              memmove(&p2b[2], &equation[v15], 16 * (v61 - v15));
              len1a = v20;
LABEL_71:
              if ( *np + n2a > n_tokens )
                error_huge();
              p2a = &equation[v55];
              memmove(&equation[v55 + n2a], p2a, 16 * (*np - v55));
              *np += n2a;
              if ( v55 == len1a )
              {
                if ( v46 < v55 )
                {
                  v25 = &p1->level;
                  v26 = v46;
                  do
                  {
                    ++*v25;
                    ++v26;
                    v25 += 4;
                  }
                  while ( v55 > v26 );
                }
                p2a->level = v8;
                p2a->kind = OPERATOR;
                p2a->token.variable = 6;
                v27 = &equation[v55 + 1];
                v27->level = v8;
                v27->kind = CONSTANT;
                v27->token.constant = 1.0;
              }
              if ( v42 )
              {
                v39->token.variable = 3;
                v28 = &equation[len1a + 1];
                memmove(&equation[len1a + 3], v28, 16 * n1);
                v28->level = v8;
                v28->kind = CONSTANT;
                v28->token.constant = -1.0;
                v20 = len1a + 2;
                v29 = &equation[len1a + 2];
                v29->level = v8;
                v29->kind = OPERATOR;
                v29->token.variable = 3;
                binary_parenthesize(equation, len1a + 2 + n1 + 1, len1a + 2);
              }
              v30 = v20 + n1 + 1;
              v31 = &equation[v30];
              v31->level = v8;
              v31->kind = OPERATOR;
              if ( v50 && v45 == 4 )
                v31->token.variable = 2;
              else
                v31->token.variable = 1;
              if ( v61 == v15 )
              {
                v32 = &equation[v30 + 1];
                v32->level = v8;
                v32->kind = CONSTANT;
                v32->token.constant = 1.0;
                binary_parenthesize(equation, v30 + 2, v30);
              }
              else
              {
                memmove(&equation[v30 + 1], &equation[n2a + 1 + v15], 16 * (v61 - 1 - v15));
                binary_parenthesize(equation, v61 - v15 + v30, v30);
              }
              memmove(&equation[n2a - 1 + j], &equation[n2a + v61], 16 * (*np - (n2a + v61)));
              *np += ~len2;
              modified = 1;
              goto LABEL_12;
            }
          }
LABEL_88:
          j += len2 + 1;
          v10 = *np;
          if ( *np > j )
          {
            n2 = j;
            v60 = &equation[j - 1];
            if ( level <= v60->level )
              continue;
          }
          goto LABEL_89;
        }
        v15 = j + len2;
LABEL_58:
        v20 = v55;
        n1 = 1;
        goto LABEL_59;
      }
    }
LABEL_89:
    v46 = v47 + len1;
    if ( v47 + len1 < v10 && level <= equation[v47 - 1 + len1].level )
      continue;
    break;
  }
LABEL_91:
  if ( modified )
    return 1;
LABEL_104:
  for ( i = loc; i < *np; i = v34 )
  {
    v37 = equation[i].level;
    if ( level > v37 )
      break;
    if ( level >= v37 )
    {
      v34 = i + 1;
    }
    else
    {
      modified |= ftimes_recurse(equation, np, i, level + 1);
      v34 = i + 1;
      if ( *np > i + 1 && level < equation[v34].level )
      {
        v35 = &equation[i + 3].level;
        do
        {
          v34 += 2;
          if ( *np <= v34 )
            break;
          v36 = *v35;
          v35 += 8;
        }
        while ( level < v36 );
      }
    }
  }
  return modified;
}
// 805EF3E: variable 'v19' is possibly undefined

//----- (0805F3DD) --------------------------------------------------------
int __cdecl factor_times(token_type *equation, int *np)
{
  return ftimes_recurse(equation, np, 0, 1);
}

//----- (0805F3FC) --------------------------------------------------------
int __usercall big_fplus@<eax>(token_type *equation@<eax>, int level@<edx>, int diff_sign@<ecx>, int sop1, int op1, int op2, int i1, int i2, int b1, int b2, int ai, int aj, int i, int j, int e1, int e2)
{
  int v16; // ebx
  int v17; // esi
  int v18; // eax
  int v19; // eax
  int v20; // ebx
  int v21; // esi
  int v22; // eax
  int v23; // esi
  int v24; // esi
  int v25; // eax
  int v26; // eax
  int v27; // edi
  int v28; // ebx
  int v29; // esi
  int v30; // eax
  int v31; // edx
  bool v32; // zf
  int v33; // eax
  int v34; // esi
  int v35; // ebx
  int v36; // eax
  int v37; // edx
  int v38; // eax
  int v39; // eax
  int v40; // ebx
  int result; // eax
  int v42; // edx
  int v43; // edi
  int v44; // [esp+1Ch] [ebp-3Ch]
  int v45; // [esp+20h] [ebp-38h]
  bool v47; // [esp+24h] [ebp-34h]
  int v48; // [esp+28h] [ebp-30h]
  int v51; // [esp+34h] [ebp-24h]
  int v52; // [esp+3Ch] [ebp-1Ch]

  v48 = 0;
  if ( sop1 == 4 )
  {
    scratch->level = level;
    scratch->kind = CONSTANT;
    scratch->token.constant = 1.0;
    scratch[1].level = level;
    scratch[1].kind = OPERATOR;
    scratch[1].token.variable = 4;
    v48 = 2;
  }
  v16 = v48;
  memmove(&scratch[v48], &equation[b1], 16 * (i - b1));
  v17 = v48 + i - b1;
  if ( b1 == i1 && i == e1 && v48 < v17 )
  {
    v18 = v48;
    do
    {
      ++scratch[v16].level;
      ++v18;
      ++v16;
    }
    while ( v17 > v18 );
  }
  v19 = v17;
  scratch[v19].level = level;
  scratch[v19].kind = OPERATOR;
  scratch[v19].token.variable = 3;
  v20 = v17 + 1;
  memmove(&scratch[v17 + 1], &equation[i1], 16 * (b1 - i1));
  v21 = v48 + i + 1 - i1;
  v22 = v21;
  scratch[v22].level = level;
  scratch[v22].kind = CONSTANT;
  if ( op1 == 2 )
    scratch[v22].token.constant = -1.0;
  else
    scratch[v22].token.constant = 1.0;
  v23 = v21 + 1;
  memmove(&scratch[v23], &equation[i], 16 * (e1 - i));
  v24 = e1 - i + v23;
  if ( v20 < v24 )
  {
    v25 = v20;
    do
    {
      scratch[v25].level += 2;
      ++v20;
      ++v25;
    }
    while ( v24 > v20 );
  }
  v26 = v24;
  scratch[v26].level = level + 1;
  scratch[v26].kind = OPERATOR;
  scratch[v26].token.variable = op2;
  v51 = v24 + 1;
  memmove(&scratch[v24 + 1], &equation[i2], 16 * (b2 - i2));
  v27 = v24 + 1 + b2 - i2;
  v44 = i - ai;
  if ( v24 + 1 - i2 + e2 + 2 * (i - ai) + 2 > n_tokens )
    error_huge();
  v45 = v24 + 1 - i2 + aj;
  v28 = v27;
  memmove(&scratch[v27], &equation[b2], 16 * (j - b2));
  v29 = v24 + 1 - i2 + j;
  v30 = v45 + 1;
  if ( v29 > v45 + 1 )
  {
    v31 = v30;
    do
    {
      ++scratch[v31].level;
      ++v30;
      ++v31;
    }
    while ( v29 > v30 );
  }
  v32 = diff_sign == 0;
  v47 = diff_sign != 0;
  if ( !v32 && b2 == i2 && j == e2 && v27 < v29 )
  {
    do
    {
      ++scratch[v28].level;
      ++v27;
      ++v28;
    }
    while ( v29 > v27 );
  }
  v33 = v29;
  scratch[v33].level = scratch[v45].level + 1;
  scratch[v33].kind = OPERATOR;
  scratch[v33].token.variable = 2;
  v34 = v29 + 1;
  v52 = i + ~ai;
  memmove(&scratch[v34], &equation[ai + 1], 16 * v52);
  v35 = v34 + v52;
  v36 = scratch[v45].level + 2 - min_level(&equation[ai + 1], v52);
  if ( v34 < v34 + v52 )
  {
    v37 = v34;
    do
    {
      scratch[v37].level += v36;
      ++v34;
      ++v37;
    }
    while ( v35 > v34 );
  }
  if ( v47 )
  {
    v38 = v35;
    scratch[v38].level = level;
    scratch[v38].kind = OPERATOR;
    if ( sop1 == 4 )
      scratch[v38].token.variable = 3;
    else
      scratch[v38].token.variable = 4;
    v39 = v35 + 1;
    scratch[v39].level = level + 1;
    scratch[v39].kind = CONSTANT;
    scratch[v39].token.constant = -1.0;
    v40 = v35 + 2;
    memmove(&scratch[v40], &scratch[v48 + ai - b1], 16 * v44);
    v35 = v44 + v40;
  }
  memmove(&scratch[v35], &equation[j], 16 * (e2 - j));
  result = v35 + e2 - j;
  if ( v51 < result )
  {
    v42 = v51;
    v43 = v51;
    do
    {
      scratch[v42].level += 2;
      ++v43;
      ++v42;
    }
    while ( result > v43 );
  }
  return result;
}

//----- (0805F8B2) --------------------------------------------------------
int __usercall fplus_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int v, double d, int whole_flag, int div_only)
{
  int v8; // edx
  token_type *v9; // eax
  token_type *v10; // ebx
  int v11; // ecx
  int v12; // ebx
  int *v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // eax
  int *v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // edi
  int v22; // edx
  int *v23; // eax
  token_type *v24; // eax
  token_type *v25; // eax
  int v26; // edx
  storage_type *v27; // edx
  int v28; // ecx
  int *v29; // ebx
  int *v30; // esi
  token_type *v31; // edi
  int *v32; // esi
  int v33; // edi
  token_type *v34; // ebx
  int v35; // eax
  token_type *v36; // edx
  int v37; // ebx
  int *v38; // eax
  token_type *v39; // eax
  _BOOL4 v40; // eax
  _BOOL4 v41; // edi
  int v42; // esi
  int v43; // eax
  int v44; // edi
  int v45; // esi
  int v46; // eax
  int v47; // edx
  int v48; // edx
  int v49; // edx
  long double v50; // fst5
  char v52; // c2
  int v53; // eax
  int v54; // eax
  int v55; // edx
  int v56; // edx
  int v57; // ecx
  int v58; // esi
  int v59; // eax
  int v60; // edx
  int v61; // ecx
  int v62; // edx
  int v63; // edx
  int v64; // edx
  int v65; // edx
  int v66; // edx
  int v67; // esi
  int v68; // edx
  int v69; // eax
  int v70; // edx
  int v71; // esi
  int v72; // edi
  int v73; // ecx
  int v74; // eax
  int v75; // edx
  int v76; // edx
  int v77; // edi
  int v78; // ebx
  int v79; // eax
  int v80; // eax
  int v81; // edx
  int *v82; // eax
  int v83; // edx
  int *v84; // eax
  long double v85; // fst6
  long double v86; // fst5
  char v88; // c2
  long double v89; // fst6
  long double v90; // fst5
  char v92; // c2
  long double v93; // fst6
  long double v94; // fst7
  long double v95; // fst7
  long double v96; // fst6
  long double v97; // rt2
  int v98; // ebx
  int *v99; // eax
  int v100; // ecx
  int v101; // eax
  int v103; // edi
  int v104; // edx
  int v105; // [esp+4Ch] [ebp-DCh]
  int *v106; // [esp+64h] [ebp-C4h]
  token_type *v107; // [esp+68h] [ebp-C0h]
  int v108; // [esp+70h] [ebp-B8h]
  int v109; // [esp+74h] [ebp-B4h]
  int op2; // [esp+78h] [ebp-B0h]
  int v111; // [esp+7Ch] [ebp-ACh]
  int v113; // [esp+88h] [ebp-A0h]
  int modified; // [esp+8Ch] [ebp-9Ch]
  token_type *dest; // [esp+94h] [ebp-94h]
  int len1; // [esp+98h] [ebp-90h]
  int len2; // [esp+B4h] [ebp-74h]
  int e1; // [esp+B8h] [ebp-70h]
  int sop1; // [esp+BCh] [ebp-6Ch]
  int v121; // [esp+C4h] [ebp-64h]
  token_type *v122; // [esp+C8h] [ebp-60h]
  int v123; // [esp+C8h] [ebp-60h]
  int v124; // [esp+C8h] [ebp-60h]
  int v125; // [esp+C8h] [ebp-60h]
  int v126; // [esp+C8h] [ebp-60h]
  token_type *op1; // [esp+CCh] [ebp-5Ch]
  int op1a; // [esp+CCh] [ebp-5Ch]
  int op1b; // [esp+CCh] [ebp-5Ch]
  int *v130; // [esp+D0h] [ebp-58h]
  double v131; // [esp+D0h] [ebp-58h]
  int v132; // [esp+D0h] [ebp-58h]
  double v133; // [esp+D0h] [ebp-58h]
  token_type *v134; // [esp+D8h] [ebp-50h]
  double v135; // [esp+D8h] [ebp-50h]
  double v136; // [esp+D8h] [ebp-50h]
  int i1; // [esp+E0h] [ebp-48h]
  int j; // [esp+E4h] [ebp-44h]
  int v139; // [esp+E8h] [ebp-40h]
  int v140; // [esp+ECh] [ebp-3Ch]
  int v141; // [esp+ECh] [ebp-3Ch]
  int b1; // [esp+F4h] [ebp-34h]
  int b2; // [esp+F8h] [ebp-30h]
  int b2a; // [esp+F8h] [ebp-30h]
  double iptr; // [esp+100h] [ebp-28h] BYREF
  int diff_signp[7]; // [esp+10Ch] [ebp-1Ch] BYREF

  v8 = loc + 1;
  v9 = &equation[loc + 1];
  while ( 1 )
  {
    if ( v8 >= *np || (v10 = v9, v11 = v9->level, v11 < level) )
    {
      v98 = loc;
      modified = 0;
      goto LABEL_257;
    }
    v9 += 2;
    if ( v11 == level )
      break;
    v8 += 2;
  }
  modified = 0;
  if ( (unsigned int)(v10->token.variable - 1) <= 1 )
  {
    i1 = loc;
    v121 = level + 1;
    do
    {
LABEL_9:
      v109 = i1 + 1;
      v12 = *np;
      if ( i1 + 1 >= *np || level >= equation[i1 + 1].level )
      {
        v14 = i1 + 1;
      }
      else
      {
        v13 = &equation[i1 + 3].level;
        v14 = i1 + 1;
        do
        {
          v14 += 2;
          if ( v14 >= v12 )
            break;
          v15 = *v13;
          v13 += 8;
        }
        while ( level < v15 );
      }
      len1 = v14 - i1;
      e1 = v14;
      v16 = v14 + 1;
      j = v16;
      if ( v16 < v12 )
      {
        v113 = v16;
        dest = &equation[v16 - 1];
        if ( level <= dest->level )
        {
          v107 = &equation[i1 - 1];
          v108 = i1;
          v122 = &equation[i1];
          do
          {
            v17 = j + 1;
            if ( j + 1 < v12 && level < equation[v17].level )
            {
              v18 = &equation[j + 3].level;
              do
              {
                v17 += 2;
                if ( v17 >= v12 )
                  break;
                v19 = *v18;
                v18 += 8;
              }
              while ( level < v19 );
            }
            len2 = v17 - j;
            v139 = v17;
            op2 = dest->token.variable;
            v111 = 1;
            if ( i1 > loc )
              v111 = v107->token.variable;
            v20 = i1 - 1;
            op1 = &equation[v113];
            while ( 1 )
            {
              v21 = v20 + 1;
              b1 = v20 + 1;
              if ( e1 <= v20 + 1 )
                break;
              if ( whole_flag )
              {
                if ( len1 <= 1
                  || equation[v21].kind
                  || v121 != equation[v21 + 1].level
                  || (unsigned int)(equation[v21 + 1].token.variable - 3) > 1 )
                {
                  v140 = e1;
                }
                else
                {
                  b1 = v20 + 3;
                  v140 = e1;
                }
              }
              else
              {
                v22 = v20 + 2;
                v140 = v20 + 2;
                if ( e1 > v20 + 2 )
                {
                  v23 = &equation[v20 + 2].level;
                  while ( v121 != *v23 || (unsigned int)(v23[1] - 3) > 1 )
                  {
                    v22 += 2;
                    v23 += 8;
                    if ( e1 <= v22 )
                    {
                      v140 = v22;
                      goto LABEL_44;
                    }
                  }
                  v140 = v22;
                }
              }
LABEL_44:
              sop1 = 3;
              if ( i1 < b1 )
                sop1 = equation[b1 - 1].token.variable;
              if ( !div_only || sop1 == 4 )
              {
                if ( v140 - b1 != 1 || (v24 = &equation[b1], v24->kind) || fabs(v24->token.constant) != 1.0 )
                {
                  if ( whole_flag || !v || v == 5 )
                    goto LABEL_80;
                  if ( d == 0.0 || d == 1.0 )
                  {
                    if ( b1 < v140 )
                    {
                      v25 = &equation[b1];
                      v26 = b1;
                      while ( v25->kind != VARIABLE || v != v25->token.variable )
                      {
                        v26 += 2;
                        v25 += 2;
                        if ( v140 <= v26 )
                          goto LABEL_28;
                      }
LABEL_80:
                      v35 = j - 1;
LABEL_82:
                      v36 = (token_type *)(v35 + 1);
                      b2a = v35 + 1;
                      if ( v139 <= v35 + 1 )
                        goto LABEL_28;
                      if ( whole_flag )
                      {
                        if ( len2 <= 1
                          || equation[(_DWORD)v36].kind
                          || v121 != equation[(int)v36 + 1].level
                          || (unsigned int)(equation[(int)v36 + 1].token.variable - 3) > 1 )
                        {
                          v37 = v139;
                        }
                        else
                        {
                          b2a = v35 + 3;
                          v37 = v139;
                        }
                        goto LABEL_100;
                      }
                      v37 = v35 + 2;
                      if ( v139 > v35 + 2 )
                      {
                        v38 = &equation[v35 + 2].level;
                        v36 = (token_type *)(level + 1);
                        do
                        {
                          if ( v121 == *v38 && (unsigned int)(v38[1] - 3) <= 1 )
                            break;
                          v37 += 2;
                          v38 += 8;
                        }
                        while ( v139 > v37 );
                      }
                      if ( b2a <= j )
                      {
                        if ( sop1 == 4 )
                          goto LABEL_81;
LABEL_100:
                        if ( v37 - b2a == 1 )
                        {
                          v39 = &equation[b2a];
                          if ( v39->kind == CONSTANT && fabs(v39->token.constant) == 1.0 )
                            goto LABEL_81;
                        }
                        v40 = whole_flag != 0;
                        v41 = i1 < b1 && whole_flag != 0;
                        if ( i1 < b1 && whole_flag != 0 )
                        {
                          v135 = v122->token.constant;
                          v122->token.constant = 1.0;
                          v36 = (token_type *)i1;
                          b1 = i1;
                        }
                        else
                        {
                          v135 = 0.0;
                        }
                        LOBYTE(v36) = j < b2a;
                        v42 = (unsigned int)v36 & v40;
                        if ( ((unsigned int)v36 & v40) != 0 )
                        {
                          v131 = op1->token.constant;
                          op1->token.constant = 1.0;
                          b2a = j;
                        }
                        else
                        {
                          v131 = 0.0;
                        }
                        v43 = se_compare(&equation[b1], v140 - b1, &equation[b2a], v37 - b2a, diff_signp);
                        if ( v41 )
                        {
                          v122->token.constant = v135;
                          b1 += 2;
                        }
                        if ( v42 )
                        {
                          op1->token.constant = v131;
                          b2a += 2;
                        }
                        if ( v43 )
                        {
                          iptr = 1.0;
                          v44 = v37;
                          v45 = v140;
                          goto LABEL_115;
                        }
                        if ( whole_flag )
                          break;
                        if ( div_only || v )
                          goto LABEL_81;
                        if ( i1 != b1 || (v81 = level + 1, e1 != v140) )
                          v81 = level + 2;
                        v45 = b1 + 1;
                        if ( v140 <= b1 + 1 )
                        {
LABEL_182:
                          v45 = v140;
                          v136 = 1.0;
                        }
                        else
                        {
                          v82 = &equation[v45].level;
                          while ( *v82 != v81 || v82[1] != 6 )
                          {
                            v45 += 2;
                            v82 += 8;
                            if ( v140 <= v45 )
                              goto LABEL_182;
                          }
                          if ( v81 == equation[v45 + 1].level && equation[v45 + 1].kind == CONSTANT )
                          {
                            v136 = equation[v45 + 1].token.constant;
                            if ( v136 > 0.0 )
                              goto LABEL_184;
LABEL_81:
                            v35 = v37;
                            goto LABEL_82;
                          }
                          v136 = -1.0;
                        }
LABEL_184:
                        if ( j != b2a || (v83 = level + 1, v139 != v37) )
                          v83 = level + 2;
                        v44 = b2a + 1;
                        if ( v37 <= b2a + 1 )
                        {
LABEL_196:
                          v44 = v37;
                          v133 = 1.0;
                        }
                        else
                        {
                          v84 = &equation[v44].level;
                          while ( *v84 != v83 || v84[1] != 6 )
                          {
                            v44 += 2;
                            v84 += 8;
                            if ( v37 <= v44 )
                              goto LABEL_196;
                          }
                          if ( v83 != equation[v44 + 1].level || equation[v44 + 1].kind )
                          {
                            v133 = -1.0;
                          }
                          else
                          {
                            v133 = equation[v44 + 1].token.constant;
                            if ( v133 <= 0.0 )
                              goto LABEL_81;
                          }
                        }
                        if ( (v140 != v45 || v37 != v44)
                          && (v45 - b1 != 1 || equation[b1].kind)
                          && (d != 1.0 || v136 >= 0.0 && v133 >= 0.0)
                          && se_compare(&equation[b1], v45 - b1, &equation[b2a], v44 - b2a, diff_signp) )
                        {
                          if ( v136 <= 0.0 && v133 <= 0.0 )
                          {
                            v93 = (long double)(v140 - v45);
                            v94 = (long double)(v37 - v44);
                            if ( v93 == v94 )
                            {
                              if ( v45 + 2 < v140
                                && (v125 = equation[v45 + 1].level, v125 == equation[v45].level + 1)
                                && v125 == equation[v45 + 2].level
                                && equation[v45 + 1].kind == CONSTANT
                                && (unsigned int)(equation[v45 + 2].token.variable - 3) <= 1 )
                              {
                                v95 = fabs(equation[v45 + 1].token.constant);
                              }
                              else
                              {
                                v95 = 1.0;
                              }
                              if ( v37 > v44 + 2
                                && (v126 = equation[v44 + 1].level, v126 == equation[v44].level + 1)
                                && v126 == equation[v44 + 2].level
                                && equation[v44 + 1].kind == CONSTANT
                                && (unsigned int)(equation[v44 + 2].token.variable - 3) <= 1 )
                              {
                                v96 = fabs(equation[v44 + 1].token.constant);
                              }
                              else
                              {
                                v96 = 1.0;
                              }
                            }
                            else
                            {
                              v97 = v93;
                              v96 = v94;
                              v95 = v97;
                            }
                            if ( v96 < v95 )
                              v78 = big_fplus(
                                      equation,
                                      v121,
                                      diff_signp[0],
                                      sop1,
                                      op2,
                                      v111,
                                      j,
                                      i1,
                                      b2a,
                                      b1,
                                      v44,
                                      v45,
                                      v37,
                                      v140,
                                      v139,
                                      e1);
                            else
                              v78 = big_fplus(
                                      equation,
                                      v121,
                                      diff_signp[0],
                                      sop1,
                                      v111,
                                      op2,
                                      i1,
                                      j,
                                      b1,
                                      b2a,
                                      v45,
                                      v44,
                                      v140,
                                      v37,
                                      e1,
                                      v139);
                            goto LABEL_162;
                          }
                          if ( v136 >= 0.0 )
                          {
                            if ( v133 >= 0.0 )
                            {
                              v85 = v133;
                              if ( v133 > (long double)v136 )
                                v85 = v136;
                              iptr = v85;
                              if ( !diff_signp[0] )
                              {
                                v86 = v85;
                                do
                                  v86 = __FPREM__(v86, 1.0);
                                while ( v88 );
                                if ( v86 != 0.0 )
                                {
                                  v89 = v136;
                                  if ( v136 <= (long double)v133 )
                                    v89 = v133;
                                  v90 = v89 - iptr;
                                  do
                                    v90 = __FPREM__(v90, 1.0);
                                  while ( v92 );
                                  if ( v90 == 0.0 )
                                    goto LABEL_115;
                                }
                              }
                            }
                            else
                            {
                              iptr = v136;
                            }
                          }
                          else
                          {
                            iptr = v133;
                          }
                          if ( iptr >= 1.0 )
                          {
                            modf(iptr, &iptr);
LABEL_115:
                            v123 = 0;
                            if ( sop1 == 4 )
                            {
                              scratch->level = v121;
                              scratch->kind = CONSTANT;
                              scratch->token.constant = 1.0;
                              scratch[1].level = v121;
                              scratch[1].kind = OPERATOR;
                              scratch[1].token.variable = 4;
                              v123 = 2;
                            }
                            memmove(&scratch[v123], &equation[b1], 16 * (v45 - b1));
                            op1a = v45 - b1 + v123;
                            if ( iptr == 1.0 )
                            {
                              if ( i1 == b1 && e1 == v45 && v123 < op1a )
                              {
                                v54 = v123;
                                v55 = v123;
                                do
                                {
                                  ++scratch[v55].level;
                                  ++v54;
                                  ++v55;
                                }
                                while ( op1a > v54 );
                              }
                            }
                            else
                            {
                              if ( v123 < v45 - b1 + v123 )
                              {
                                v46 = v123;
                                v47 = v123;
                                do
                                {
                                  scratch[v47].level += 2;
                                  ++v46;
                                  ++v47;
                                }
                                while ( op1a > v46 );
                              }
                              v48 = op1a;
                              scratch[v48].level = level + 2;
                              scratch[v48].kind = OPERATOR;
                              scratch[v48].token.variable = 6;
                              v49 = op1a + 1;
                              scratch[v49].level = level + 2;
                              scratch[v49].kind = CONSTANT;
                              scratch[v49].token.constant = iptr;
                              op1a += 2;
                              v50 = iptr;
                              do
                                v50 = __FPREM__(v50, 2.0);
                              while ( v52 );
                              v53 = 0;
                              if ( 0.0 != v50 )
                                v53 = diff_signp[0];
                              diff_signp[0] = v53;
                            }
                            v56 = op1a;
                            scratch[v56].level = v121;
                            scratch[v56].kind = OPERATOR;
                            scratch[v56].token.variable = 3;
                            v124 = op1a + 1;
                            memmove(&scratch[op1a + 1], &equation[v108], 16 * (b1 - i1));
                            v57 = b1 - i1 + op1a + 1;
                            op1b = v57;
                            if ( v140 != v45 )
                            {
                              v132 = v45 - b1 + v57;
                              memmove(&scratch[v57], &equation[b1], 16 * (v140 - b1));
                              v58 = op1b + v140 - b1;
                              if ( i1 == b1 && e1 == v140 && op1b < v58 )
                              {
                                v59 = op1b;
                                v60 = op1b;
                                do
                                {
                                  ++scratch[v60].level;
                                  ++v59;
                                  ++v60;
                                }
                                while ( v58 > v59 );
                              }
                              v61 = v132 + 1;
                              if ( v58 > v132 + 1 )
                              {
                                v62 = v61;
                                do
                                {
                                  ++scratch[v62].level;
                                  ++v61;
                                  ++v62;
                                }
                                while ( v58 > v61 );
                              }
                              v63 = v58;
                              scratch[v63].level = scratch[v132].level + 1;
                              scratch[v63].kind = OPERATOR;
                              scratch[v63].token.variable = 2;
                              v64 = v58 + 1;
                              scratch[v64].level = scratch[v132].level + 1;
                              scratch[v64].kind = CONSTANT;
                              scratch[v64].token.constant = iptr;
                              v65 = v58 + 2;
                              scratch[v65].level = v121;
                              scratch[v65].kind = OPERATOR;
                              scratch[v65].token.variable = 3;
                              op1b = v58 + 3;
                            }
                            v66 = op1b;
                            scratch[v66].level = v121;
                            scratch[v66].kind = CONSTANT;
                            if ( v111 == 2 )
                              scratch[v66].token.constant = -1.0;
                            else
                              scratch[v66].token.constant = 1.0;
                            memmove(&scratch[op1b + 1], &equation[v140], 16 * (e1 - v140));
                            v67 = e1 - v140 + op1b + 1;
                            if ( v124 < v67 )
                            {
                              v68 = v124;
                              v69 = v124;
                              do
                              {
                                scratch[v68].level += 2;
                                ++v69;
                                ++v68;
                              }
                              while ( v67 > v69 );
                            }
                            v70 = v67;
                            scratch[v70].level = level + 2;
                            scratch[v70].kind = OPERATOR;
                            diff_signp[0] ^= op2 == 2;
                            if ( diff_signp[0] )
                              scratch[v70].token.variable = 2;
                            else
                              scratch[v70].token.variable = 1;
                            v71 = v67 + 1;
                            if ( v37 == v44 )
                            {
                              if ( v71 + b2a + v139 + 1 - j - v37 > n_tokens )
                                error_huge();
                              memmove(&scratch[v71], &equation[v113], 16 * (b2a - j));
                              v103 = v71 + b2a - j;
                              v104 = v103;
                              scratch[v104].level = v121;
                              scratch[v104].kind = CONSTANT;
                              scratch[v104].token.constant = 1.0;
                              v77 = v103 + 1;
                            }
                            else
                            {
                              if ( v71 + len2 + 2 > n_tokens )
                                error_huge();
                              memmove(&scratch[v71], &equation[v113], 16 * (b2a - j));
                              v141 = v71 - j + v44;
                              memmove(&scratch[v71 + b2a - j], &equation[b2a], 16 * (v37 - b2a));
                              v72 = v71 - j + v37;
                              v73 = v141 + 1;
                              if ( v72 > v141 + 1 )
                              {
                                v74 = v73;
                                do
                                {
                                  ++scratch[v74].level;
                                  ++v73;
                                  ++v74;
                                }
                                while ( v72 > v73 );
                              }
                              v75 = v72;
                              scratch[v75].level = scratch[v141].level + 1;
                              scratch[v75].kind = OPERATOR;
                              scratch[v75].token.variable = 2;
                              v76 = v72 + 1;
                              scratch[v76].level = scratch[v141].level + 1;
                              scratch[v76].kind = CONSTANT;
                              scratch[v76].token.constant = iptr;
                              v77 = v72 + 2;
                            }
                            memmove(&scratch[v77], &equation[v37], 16 * (v139 - v37));
                            v78 = v77 + v139 - v37;
                            if ( v71 < v78 )
                            {
                              v79 = v71;
                              do
                              {
                                scratch[v79].level += 2;
                                ++v71;
                                ++v79;
                              }
                              while ( v78 > v71 );
                            }
LABEL_162:
                            if ( ~len2 + *np + v78 - len1 > n_tokens )
                              error_huge();
                            if ( v111 == 2 )
                              v107->token.variable = 1;
                            memmove(dest, &equation[v139], 16 * (*np - v139));
                            v80 = *np + ~len2;
                            *np = v80;
                            memmove(&equation[v78 + i1], &equation[e1], 16 * (v80 - e1));
                            *np += v78 - len1;
                            memmove(&equation[v108], scratch, 16 * v78);
                            modified = 1;
                            goto LABEL_9;
                          }
                        }
                        goto LABEL_81;
                      }
                      v36 = equation;
                      if ( sop1 == equation[b2a - 1].token.variable )
                        goto LABEL_100;
                      goto LABEL_81;
                    }
                  }
                  else if ( v140 > b1 + 1 )
                  {
                    v27 = &equation[b1 + 1].token;
                    v28 = b1;
                    v29 = &equation[b1 + 2].level;
                    v30 = &equation[b1].level;
                    v31 = &equation[b1 - 1];
                    do
                    {
                      if ( v27->variable == 6 )
                      {
                        v105 = *(&v27[-1].operatr + 1);
                        if ( v105 == *v29 && !*(v29 - 1) && d == *(double *)(v29 + 1) )
                        {
                          b2 = v28;
                          if ( v28 >= 0 && v105 <= *v30 )
                          {
                            v134 = v31;
                            v130 = v30;
                            v106 = v29;
                            v34 = v31;
                            v32 = v30 - 1;
                            while ( 1 )
                            {
                              if ( *v32 == 1 && v == v32[2] )
                                goto LABEL_80;
                              if ( --b2 < 0 )
                                break;
                              v32 = (int *)v34;
                              v33 = v34->level;
                              --v34;
                              if ( v105 > v33 )
                              {
                                v31 = v134;
                                v30 = v130;
                                v29 = v106;
                                goto LABEL_78;
                              }
                            }
                            v31 = v134;
                            v30 = v130;
                            v29 = v106;
                          }
                        }
                      }
LABEL_78:
                      v27 += 4;
                      v28 += 2;
                      v29 += 8;
                      v30 += 8;
                      v31 += 2;
                    }
                    while ( v140 > v28 + 1 );
                  }
                }
              }
LABEL_28:
              v20 = v140;
            }
            j += len2 + 1;
            v12 = *np;
            if ( *np <= j )
              break;
            v113 = j;
            dest = &equation[j - 1];
          }
          while ( level <= dest->level );
        }
      }
      i1 = v109 + len1;
    }
    while ( v109 + len1 < v12 && level <= equation[v109 - 1 + len1].level );
  }
  v98 = loc;
  if ( modified )
    return 1;
LABEL_257:
  while ( v98 < *np )
  {
    v101 = equation[v98].level;
    if ( level > v101 )
      break;
    if ( level >= v101 )
    {
      ++v98;
    }
    else
    {
      modified |= fplus_recurse(equation, np, v98++, level + 1, v, d, whole_flag, div_only);
      v99 = &equation[v98].level;
      while ( v98 < *np )
      {
        v100 = *v99;
        v99 += 8;
        if ( level >= v100 )
          break;
        v98 += 2;
      }
    }
  }
  return modified;
}
// 806005C: variable 'v52' is possibly undefined
// 8060808: variable 'v88' is possibly undefined
// 8060850: variable 'v92' is possibly undefined

//----- (08060C10) --------------------------------------------------------
int __cdecl factor_plus(token_type *equation, int *np, int v, double d)
{
  return fplus_recurse(equation, np, 0, 1, v, d, 0, 0);
}

//----- (08060C4D) --------------------------------------------------------
int __cdecl subtract_itself(token_type *equation, int *np)
{
  return fplus_recurse(equation, np, 0, 1, 0, 0.0, 1, 0);
}

//----- (08060C8A) --------------------------------------------------------
int __cdecl factor_divide(token_type *equation, int *np, int v, double d)
{
  return fplus_recurse(equation, np, 0, 1, v, d, 0, 1);
}

//----- (08060CD0) --------------------------------------------------------
int __usercall sf_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int start_flag)
{
  int v5; // edx
  token_type *v6; // ebx
  int v7; // ecx
  token_type *v8; // eax
  int v9; // ebx
  int v10; // eax
  int *v11; // edx
  int v12; // ebx
  token_type *v13; // edx
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  int *v17; // edx
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // ebx
  int *v22; // edx
  int v23; // eax
  int v24; // ebx
  int v25; // edx
  int *v26; // eax
  int v27; // esi
  int *v28; // eax
  int v29; // ecx
  int *v30; // eax
  int *v31; // eax
  int v32; // ecx
  int v33; // eax
  int *v34; // eax
  int v35; // edx
  int *v36; // eax
  int v37; // edx
  int v38; // edx
  int l; // eax
  int v40; // edx
  int v41; // esi
  int v42; // edx
  int v43; // eax
  int v44; // edx
  int v45; // ebx
  int v46; // esi
  int v47; // edx
  int v48; // esi
  int v49; // eax
  int v50; // ebx
  token_type *v51; // eax
  int i; // edx
  token_type *v53; // eax
  int j; // edx
  int v55; // edx
  int v56; // esi
  int v57; // esi
  int k; // eax
  int v59; // edx
  int v60; // esi
  int v61; // edx
  int v62; // ebx
  int v63; // ebx
  int v64; // eax
  int v65; // edx
  int v66; // ebx
  int v67; // edx
  int v68; // esi
  int v69; // eax
  int v70; // ebx
  token_type *smaller; // [esp+28h] [ebp-80h]
  int v73; // [esp+2Ch] [ebp-7Ch]
  token_type *src; // [esp+38h] [ebp-70h]
  int v75; // [esp+3Ch] [ebp-6Ch]
  int v76; // [esp+40h] [ebp-68h]
  int v77; // [esp+44h] [ebp-64h]
  int v78; // [esp+48h] [ebp-60h]
  token_type *v79; // [esp+48h] [ebp-60h]
  token_type *v80; // [esp+48h] [ebp-60h]
  int llen; // [esp+4Ch] [ebp-5Ch]
  int llena; // [esp+4Ch] [ebp-5Ch]
  int v83; // [esp+50h] [ebp-58h]
  int v84; // [esp+54h] [ebp-54h]
  int len1; // [esp+5Ch] [ebp-4Ch]
  token_type *dest; // [esp+60h] [ebp-48h]
  int v87; // [esp+64h] [ebp-44h]
  char *v88; // [esp+64h] [ebp-44h]
  char *v89; // [esp+64h] [ebp-44h]
  int v91; // [esp+6Ch] [ebp-3Ch]
  token_type *v92; // [esp+6Ch] [ebp-3Ch]
  int v93; // [esp+70h] [ebp-38h]
  int len2; // [esp+7Ch] [ebp-2Ch]
  int modified; // [esp+80h] [ebp-28h]
  int modifieda; // [esp+80h] [ebp-28h]
  int modifiedb; // [esp+80h] [ebp-28h]
  int v99; // [esp+84h] [ebp-24h]
  int v101; // [esp+8Ch] [ebp-1Ch]
  int v102; // [esp+8Ch] [ebp-1Ch]
  int v103; // [esp+8Ch] [ebp-1Ch]
  int v104; // [esp+8Ch] [ebp-1Ch]
  char *v105; // [esp+8Ch] [ebp-1Ch]
  int v106; // [esp+8Ch] [ebp-1Ch]

  if ( !start_flag )
  {
    v5 = loc + 1;
    if ( loc + 1 < *np )
    {
      v6 = &equation[v5];
      v7 = v6->level;
      if ( level <= v7 )
      {
        v8 = &equation[loc + 3];
        while ( v7 != level || v6->token.variable != 4 )
        {
          v5 += 2;
          if ( v5 < *np )
          {
            v6 = v8;
            v7 = v8->level;
            v8 += 2;
            if ( v7 >= level )
              continue;
          }
          goto LABEL_10;
        }
        start_flag = 1;
      }
    }
  }
LABEL_10:
  v9 = loc;
  modified = 0;
  v101 = 0;
  while ( v9 < *np )
  {
    v13 = &equation[v9];
    v14 = v13->level;
    if ( level > v14 )
      break;
    if ( level >= v14 )
    {
      if ( v13->kind == OPERATOR )
        v101 = v13->token.variable;
      v10 = v9 + 1;
    }
    else
    {
      modified |= sf_recurse(equation, np, v9, level + 1, start_flag);
      v10 = v9 + 1;
      if ( v9 + 1 < *np && level < equation[v10].level )
      {
        v11 = &equation[v9 + 3].level;
        do
        {
          v10 += 2;
          if ( v10 >= *np )
            break;
          v12 = *v11;
          v11 += 8;
        }
        while ( level < v12 );
      }
    }
    v9 = v10;
  }
  if ( !modified && start_flag && (unsigned int)(v101 - 1) <= 1 )
  {
    v93 = loc + 1;
    src = &equation[loc];
    v15 = level + 1;
    while ( 1 )
    {
      v16 = *np;
      if ( v93 >= *np || level >= equation[loc + 1].level )
      {
        v18 = loc + 1;
      }
      else
      {
        v17 = &equation[loc + 3].level;
        v18 = loc + 1;
        do
        {
          v18 += 2;
          if ( v18 >= v16 )
            break;
          v19 = *v17;
          v17 += 8;
        }
        while ( level < v19 );
      }
      len1 = v18 - loc;
      v99 = v18;
      v20 = v18 + 1;
      v102 = v20;
      if ( v20 >= v16 )
        return modified;
      v76 = v20;
      dest = &equation[v20 - 1];
      if ( level > dest->level )
        return modified;
      while ( 1 )
      {
        v21 = v102 + 1;
        if ( v102 + 1 >= v16 || level >= equation[v21].level )
        {
          v23 = v102 + 1;
        }
        else
        {
          v22 = &equation[v102 + 3].level;
          v23 = v102 + 1;
          while ( 1 )
          {
            v23 += 2;
            if ( v23 >= v16 )
              break;
            v24 = *v22;
            v22 += 8;
            if ( level >= v24 )
            {
              v21 = v102 + 1;
              goto LABEL_45;
            }
          }
          v21 = v102 + 1;
        }
LABEL_45:
        len2 = v23 - v102;
        v25 = v23;
        v75 = dest->token.variable;
        if ( v93 >= v99 )
        {
          v27 = loc + 1;
LABEL_134:
          v84 = v27 + 1;
          v91 = 0;
        }
        else
        {
          v26 = &equation[v93].level;
          v27 = loc + 1;
          while ( v15 != *v26 || v26[1] != 4 )
          {
            v27 += 2;
            v26 += 8;
            if ( v99 <= v27 )
              goto LABEL_134;
          }
          v87 = v27;
          v84 = v27 + 1;
          v27 += 2;
          if ( v99 > v27 && v15 < equation[v27].level )
          {
            v28 = &equation[v87 + 4].level;
            do
            {
              v27 += 2;
              if ( v99 <= v27 )
                break;
              v29 = *v28;
              v28 += 8;
            }
            while ( v15 < v29 );
          }
          v91 = 1;
        }
        if ( v21 >= v25 )
        {
LABEL_135:
          v88 = (char *)(v21 + 1);
          v33 = 0;
        }
        else
        {
          v30 = &equation[v21].level;
          while ( v15 != *v30 || v30[1] != 4 )
          {
            v21 += 2;
            v30 += 8;
            if ( v25 <= v21 )
              goto LABEL_135;
          }
          v78 = v21;
          v88 = (char *)(v21 + 1);
          v21 += 2;
          if ( v25 > v21 && v15 < equation[v21].level )
          {
            v31 = &equation[v78 + 4].level;
            do
            {
              v21 += 2;
              if ( v25 <= v21 )
                break;
              v32 = *v31;
              v31 += 8;
            }
            while ( v15 < v32 );
          }
          v33 = 1;
        }
        if ( v33 || v91 )
          break;
        v70 = v102 + len2 + 1;
        v102 = v70;
        v16 = *np;
        if ( *np > v70 )
        {
          v76 = v70;
          dest = &equation[v70 - 1];
          if ( level <= dest->level )
            continue;
        }
        return modified;
      }
      v83 = v25;
      modifieda = v33;
      v77 = v102;
      if ( start_flag == 2 && (_BYTE)v91 && v33 )
      {
        llen = v27 - v84;
        v79 = &equation[v84];
        if ( poly2_gcd(v79, v27 - v84, &equation[(_DWORD)v88], v21 - (_DWORD)v88, 0) )
        {
          smaller = tlhs;
          modifiedb = n_tlhs;
          v92 = trhs;
          v103 = n_trhs;
LABEL_112:
          if ( (int)&v88[2 * v103 + v99 - loc + 5 + v83 - v77 - v21 + modifiedb] > n_tokens )
            error_huge();
          if ( modifiedb > 0 )
          {
            v51 = smaller;
            for ( i = 0; i != modifiedb; ++i )
            {
              v51->level += v15;
              ++v51;
            }
          }
          if ( v103 > 0 )
          {
            v53 = v92;
            for ( j = 0; j != v103; ++j )
            {
              v53->level += v15;
              ++v53;
            }
          }
          v73 = v84 + ~loc;
          memmove(scratch, src, 16 * v73);
          memmove(&scratch[v73], &equation[v27], 16 * (v99 - v27));
          v55 = v73 + v99 - v27;
          scratch[v55].level = v15;
          scratch[v55].kind = OPERATOR;
          scratch[v55].token.variable = 3;
          v56 = v73 + v99 - v27 + 1;
          memmove(&scratch[v56], v92, 16 * v103);
          v57 = v103 + v56;
          if ( v57 > 0 )
          {
            for ( k = 0; k != v57; ++k )
              scratch[k].level += 2;
          }
          v59 = v57;
          scratch[v59].level = level + 2;
          scratch[v59].kind = OPERATOR;
          scratch[v59].token.variable = v75;
          v60 = v57 + 1;
          v89 = &v88[-v77 - 1];
          memmove(&scratch[v60], &equation[v76], 16 * (_DWORD)v89);
          memmove(&scratch[(_DWORD)&v89[v60]], &equation[v21], 16 * (v83 - v21));
          v61 = (int)&v89[v60 + v83 - v21];
          scratch[v61].level = v15;
          scratch[v61].kind = OPERATOR;
          scratch[v61].token.variable = 3;
          v62 = (int)&v89[v60 + 1 + v83 - v21];
          memmove(&scratch[v62], smaller, 16 * modifiedb);
          v63 = modifiedb + v62;
          if ( v60 < v63 )
          {
            v64 = v60;
            do
            {
              scratch[v64].level += 2;
              ++v60;
              ++v64;
            }
            while ( v63 > v60 );
          }
          v65 = v63;
          scratch[v65].level = v15;
          scratch[v65].kind = OPERATOR;
          scratch[v65].token.variable = 4;
          v66 = v63 + 1;
          memmove(&scratch[v66], v79, 16 * llen);
          v67 = v66 + llen;
          scratch[v67].level = v15;
          scratch[v67].kind = OPERATOR;
          scratch[v67].token.variable = 3;
          v68 = v66 + llen + 1;
          memmove(&scratch[v68], v92, 16 * v103);
          v46 = v103 + v68;
          if ( v66 < v46 )
          {
            v69 = v66;
            do
            {
              ++scratch[v69].level;
              ++v66;
              ++v69;
            }
            while ( v46 > v66 );
          }
          goto LABEL_109;
        }
        if ( poly2_gcd(&equation[(_DWORD)v88], v21 - (_DWORD)v88, v79, llen, 0) )
        {
          smaller = trhs;
          modifiedb = n_trhs;
          v92 = tlhs;
          v103 = n_tlhs;
          goto LABEL_112;
        }
      }
      v80 = (token_type *)(v27 - v84);
      llena = v21 - (_DWORD)v88;
      if ( v21 - (int)v88 + v27 - v84 + len2 + len1 + 8 > n_tokens )
        error_huge();
      if ( !v91 && loc < v99 )
      {
        v34 = &equation[loc].level;
        v35 = loc;
        do
        {
          ++*v34;
          ++v35;
          v34 += 4;
        }
        while ( v99 > v35 );
      }
      if ( !modifieda && v102 < v83 )
      {
        v36 = &equation[v102].level;
        v37 = v102;
        do
        {
          ++*v36;
          ++v37;
          v36 += 4;
        }
        while ( v37 < v83 );
      }
      v104 = v84 + ~loc;
      memmove(scratch, src, 16 * v104);
      if ( (_BYTE)v91 )
      {
        memmove(&scratch[v104], &equation[v27], 16 * (v99 - v27));
        v104 += v99 - v27;
      }
      if ( modifieda )
      {
        v38 = v104;
        scratch[v38].level = v15;
        scratch[v38].kind = OPERATOR;
        scratch[v38].token.variable = 3;
        memmove(&scratch[v104 + 1], &equation[(_DWORD)v88], 16 * llena);
        v104 += llena + 1;
      }
      if ( v104 > 0 )
      {
        for ( l = 0; l != v104; ++l )
          scratch[l].level += 2;
      }
      v40 = v104;
      scratch[v40].level = level + 2;
      scratch[v40].kind = OPERATOR;
      scratch[v40].token.variable = v75;
      v41 = v104 + 1;
      v105 = &v88[-v77 - 1];
      memmove(&scratch[v41], &equation[v76], 16 * (_DWORD)v105);
      v106 = (int)&v105[v41];
      if ( modifieda )
      {
        memmove(&scratch[v106], &equation[v21], 16 * (v83 - v21));
        v106 += v83 - v21;
      }
      if ( (_BYTE)v91 )
      {
        v42 = v106;
        scratch[v42].level = v15;
        scratch[v42].kind = OPERATOR;
        scratch[v42].token.variable = 3;
        memmove(&scratch[v106 + 1], &equation[v84], 16 * (_DWORD)v80);
        v106 += (int)&v80->kind + 1;
      }
      if ( v41 < v106 )
      {
        v43 = v41;
        do
        {
          scratch[v43].level += 2;
          ++v41;
          ++v43;
        }
        while ( v41 < v106 );
      }
      v44 = v106;
      scratch[v44].level = v15;
      scratch[v44].kind = OPERATOR;
      scratch[v44].token.variable = 4;
      v45 = v106 + 1;
      if ( (_BYTE)v91 )
        break;
      if ( modifieda )
      {
        v48 = v106 + 1;
LABEL_105:
        memmove(&scratch[v48], &equation[(_DWORD)v88], 16 * llena);
        v46 = llena + v48;
        goto LABEL_106;
      }
      v46 = v106 + 1;
LABEL_106:
      if ( v45 < v46 )
      {
        v49 = v45;
        do
        {
          ++scratch[v49].level;
          ++v45;
          ++v49;
        }
        while ( v45 < v46 );
      }
LABEL_109:
      if ( v46 + *np + ~len2 - len1 > n_tokens )
        error_huge();
      memmove(dest, &equation[v83], 16 * (*np - v83));
      v50 = *np + ~len2;
      *np = v50;
      memmove(&equation[v46 + loc], &equation[v99], 16 * (v50 - v99));
      *np += v46 - len1;
      memmove(src, scratch, 16 * v46);
      modified = 1;
    }
    memmove(&scratch[v45], &equation[v84], 16 * (_DWORD)v80);
    v46 = (int)v80 + v45;
    if ( !modifieda )
      goto LABEL_106;
    v47 = v46;
    scratch[v47].level = v15;
    scratch[v47].kind = OPERATOR;
    scratch[v47].token.variable = 3;
    v48 = v46 + 1;
    goto LABEL_105;
  }
  return modified;
}

//----- (080618F5) --------------------------------------------------------
void __usercall group_recurse(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level)
{
  int i; // esi
  int v6; // eax
  int *v7; // edx
  int v8; // esi
  int v9; // eax
  int v10; // edi
  int v11; // eax
  token_type *v12; // ecx
  int *v13; // eax
  char *v14; // edx
  int v15; // edx
  int v16; // edx
  int *v17; // eax
  char *src; // [esp+1Ch] [ebp-2Ch]
  char *v19; // [esp+20h] [ebp-28h]
  int di_0; // [esp+24h] [ebp-24h]
  int di_0a; // [esp+24h] [ebp-24h]
  int v22; // [esp+28h] [ebp-20h]

  di_0 = loc;
  for ( i = loc; i < *np; i = v6 )
  {
    v9 = equation[i].level;
    if ( v9 < level )
      break;
    if ( v9 <= level )
    {
      v6 = i + 1;
    }
    else
    {
      group_recurse(equation, np, i, level + 1);
      v6 = i + 1;
      if ( i + 1 < *np && level < equation[v6].level )
      {
        v7 = &equation[i + 3].level;
        do
        {
          v6 += 2;
          if ( v6 >= *np )
            break;
          v8 = *v7;
          v7 += 8;
        }
        while ( level < v8 );
      }
    }
  }
  v10 = di_0 + 1;
  if ( di_0 + 1 < i )
  {
    v11 = 0;
    di_0a = -1;
    v22 = i;
    do
    {
      v12 = &equation[v10];
      if ( v12->level == level )
      {
        if ( v12->token.variable == 4 )
        {
          if ( di_0a >= 0 )
          {
            src = (char *)(v10 + 2);
            if ( v10 + 2 < i )
            {
              v13 = &equation[v10 + 2].level;
              v14 = (char *)(v10 + 2);
              while ( *v13 != level || v13[1] == 4 )
              {
                v14 += 2;
                v13 += 8;
                if ( (int)v14 >= i )
                {
                  src = v14;
                  goto LABEL_26;
                }
              }
              src = v14;
            }
LABEL_26:
            v19 = &src[-v10];
            if ( i == v22 )
            {
              v10 = (int)src;
              v22 = (int)src;
            }
            else
            {
              memmove(scratch, &equation[v10], 16 * (_DWORD)v19);
              memmove(&equation[(_DWORD)&v19[di_0a]], &equation[di_0a], 16 * (v10 - di_0a));
              memmove(&equation[di_0a], scratch, 16 * (_DWORD)v19);
              v22 += (int)v19;
              v10 = (int)(src - 2);
            }
            v11 = 1;
          }
          else
          {
            di_0a = v10;
          }
        }
        else if ( di_0a >= 0 )
        {
          v15 = v22;
          if ( i == v22 )
            v15 = v10;
          v22 = v15;
        }
      }
      v10 += 2;
    }
    while ( v10 < i );
    if ( v11 )
    {
      v16 = di_0a + 1;
      if ( v22 > di_0a + 1 )
      {
        v17 = &equation[v16].level;
        do
        {
          if ( *v17 == level && *(v17 - 1) == 2 )
            v17[1] = 3;
          ++*v17;
          ++v16;
          v17 += 4;
        }
        while ( v22 > v16 );
      }
    }
  }
}

//----- (08061AF3) --------------------------------------------------------
void __cdecl group_proc(token_type *equation, int *np)
{
  group_recurse(equation, np, 0, 1);
}

//----- (08061B12) --------------------------------------------------------
int __cdecl super_factor(token_type *equation, int *np, int start_flag)
{
  int v3; // edi

  group_proc(equation, np);
  v3 = sf_recurse(equation, np, 0, 1, start_flag);
  organize(equation, np);
  return v3;
}

//----- (08061B6C) --------------------------------------------------------
int __cdecl fractions_and_group(token_type *equation, int *np)
{
  int v2; // edi

  elim_loop(equation, np);
  v2 = make_fractions(equation, np);
  group_proc(equation, np);
  return v2;
}

//----- (08061BB6) --------------------------------------------------------
int __cdecl make_fractions_and_group(int n)
{
  int v1; // esi

  v1 = 0;
  if ( n_lhs[n] > 0 )
  {
    v1 = fractions_and_group(lhs[n], &n_lhs[n]);
    if ( n_rhs[n] )
    {
      if ( fractions_and_group(rhs[n], (int *)(4 * n + 134715712)) )
        v1 = 1;
    }
  }
  return v1;
}

//----- (08061C40) --------------------------------------------------------
int __cdecl patch_root_div(token_type *equation, int *np)
{
  int i; // ebx
  token_type *v3; // edi
  long double v4; // fst5
  char v6; // c2
  token_type *v7; // eax
  int v9; // [esp+1Ch] [ebp-3Ch]
  double v10; // [esp+28h] [ebp-30h]
  int modified; // [esp+34h] [ebp-24h]
  int v12; // [esp+38h] [ebp-20h]

  modified = 0;
  for ( i = 1; *np - 2 > i; i += 2 )
  {
    v3 = &equation[i];
    if ( v3->token.variable == 4 )
    {
      v12 = v3->level;
      if ( equation[i + 2].token.variable == 6 )
      {
        v9 = equation[i + 2].level;
        if ( v9 == v12 + 1
          && equation[i + 1].kind == CONSTANT
          && v9 == equation[i + 3].level
          && equation[i + 3].kind == CONSTANT )
        {
          v4 = equation[i + 1].token.constant;
          do
            v4 = __FPREM__(v4, 1.0);
          while ( v6 );
          if ( v4 == 0.0 )
          {
            if ( rationalize_denominators )
            {
              v10 = equation[i + 3].token.constant;
              if ( __finite(v10) )
              {
                if ( v10 > 0.0 && v10 < 1.0 )
                {
                  if ( *np + 2 > n_tokens )
                    error_huge();
                  equation[i + 3].token.constant = equation[i + 3].token.constant - 1.0;
                  memmove(&equation[i + 2], v3, 16 * (*np - i));
                  *np += 2;
                  v7 = &equation[i + 1];
                  v7->level = v12;
                  v7->kind = CONSTANT;
                  v7->token.constant = equation[i + 3].token.constant;
                  i += 2;
                  modified = 1;
                }
              }
            }
          }
          else
          {
            v3->token.variable = 3;
            equation[i + 1].token.constant = 1.0 / equation[i + 1].token.constant;
            modified = 1;
          }
        }
      }
    }
  }
  return modified;
}
// 8061CF4: variable 'v6' is possibly undefined

//----- (08061E10) --------------------------------------------------------
void __cdecl uf_neg_help(token_type *equation, int *np)
{
  int v2; // eax
  int v3; // ebx
  token_type *v4; // esi
  token_type *v5; // eax
  token_type *v6; // eax
  int v7; // [esp+18h] [ebp-20h]

  v2 = *np;
  if ( *np - 1 > 0 )
  {
    v3 = 0;
    do
    {
      v4 = &equation[v3];
      if ( v4->kind == CONSTANT && v4->token.constant < 0.0 )
      {
        v7 = equation[v3 + 1].level;
        if ( v7 == v4->level && (unsigned int)(equation[v3 + 1].token.variable - 3) <= 1 )
        {
          if ( v2 + 2 > n_tokens )
            error_huge();
          memmove(&equation[v3 + 3], &equation[v3 + 1], 16 * (*np + ~v3));
          *np += 2;
          v4->token.constant = -v4->token.constant;
          v5 = &equation[v3 + 1];
          v5->level = v7;
          v5->kind = OPERATOR;
          v5->token.variable = 4;
          v3 += 2;
          v6 = &equation[v3];
          v6->level = v7;
          v6->kind = CONSTANT;
          v6->token.constant = -1.0;
        }
      }
      v3 += 2;
      v2 = *np;
    }
    while ( *np - 1 > v3 );
  }
}

//----- (08061F1B) --------------------------------------------------------
int __cdecl unsimp_power(token_type *equation, int *np)
{
  int v2; // edi
  token_type *v3; // ebx
  int v4; // esi
  int v5; // edx
  int v6; // ecx
  token_type *v7; // edi
  token_type *v8; // eax
  int v9; // edi
  int v10; // edx
  token_type *v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  token_type *v16; // [esp+1Ch] [ebp-2Ch]
  int v17; // [esp+20h] [ebp-28h]
  int modified; // [esp+24h] [ebp-24h]
  token_type *v19; // [esp+28h] [ebp-20h]
  int v20; // [esp+2Ch] [ebp-1Ch]

  v2 = *np;
  modified = 0;
  if ( *np > 1 )
  {
    v3 = equation + 2;
    v4 = -1;
    do
    {
      if ( v3[-1].token.variable != 6 )
        goto LABEL_29;
      v20 = v3[-1].level;
      if ( v20 == v3->level && v3->kind == CONSTANT )
        goto LABEL_29;
      v5 = v4;
      if ( v4 >= 0 )
      {
        v19 = v3 - 3;
        v6 = v3[-3].level;
        if ( v20 <= v6 )
        {
          v8 = v3 - 5;
          v17 = v2;
          while ( 1 )
          {
            v5 -= 2;
            if ( v5 < 0 )
              break;
            v7 = v8;
            v6 = v8->level;
            v8 -= 2;
            if ( v20 > v6 )
            {
              v19 = v7;
              v2 = v17;
              goto LABEL_11;
            }
          }
        }
        else
        {
LABEL_11:
          if ( v6 == v20 - 1 && v19->token.variable == 4 )
          {
            if ( v2 + 2 > n_tokens )
              error_huge();
            v19->token.variable = 3;
            v9 = *np;
            if ( *np > v4 + 3 )
            {
              v10 = v3->level;
              if ( v20 <= v10 )
              {
                v11 = v3 + 1;
                v12 = v4 + 3;
                v16 = v3;
                do
                {
                  v3->level = v10 + 1;
                  ++v12;
                  v9 = *np;
                  if ( *np <= v12 )
                  {
                    v3 = v16;
                    goto LABEL_26;
                  }
                  v3 = v11;
                  v10 = v11->level;
                  ++v11;
                }
                while ( v20 <= v10 );
                v3 = v16;
              }
            }
LABEL_26:
            memmove(&v3[2], v3, 16 * (v9 - (v4 + 3)));
            *np += 2;
            v3->level = v20 + 1;
            v3->kind = CONSTANT;
            v3->token.constant = -1.0;
            v3[1].level = v20 + 1;
            v3[1].kind = OPERATOR;
            v3[1].token.variable = 3;
            v13 = 1;
            goto LABEL_28;
          }
        }
      }
      v13 = 0;
LABEL_28:
      modified |= v13;
LABEL_29:
      v14 = v4 + 4;
      v2 = *np;
      v4 += 2;
      v3 += 2;
    }
    while ( *np > v14 );
  }
  return modified;
}

//----- (080620AE) --------------------------------------------------------
int __cdecl sub_ufactor(token_type *equation, int *np, int ii)
{
  int v3; // ecx
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  int *v7; // eax
  int v8; // edx
  int v9; // ebx
  int *v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // ecx
  token_type *v14; // eax
  int v15; // ebx
  int v16; // eax
  int *v17; // edx
  int v18; // ebx
  int v19; // eax
  int *v20; // edx
  int v21; // ebx
  int v22; // esi
  int v23; // edi
  int v24; // ebx
  int v25; // ebx
  unsigned int v26; // eax
  token_type *v27; // edx
  int v28; // eax
  int *v29; // edx
  int v30; // ecx
  token_type *v31; // edx
  int v32; // edi
  token_type *v33; // eax
  signed int v34; // esi
  signed int v35; // edi
  signed int v36; // ebx
  unsigned int v37; // edi
  token_type *v38; // eax
  int v39; // eax
  int *v40; // edx
  int v41; // ecx
  token_type *v42; // edx
  void *v43; // edi
  token_type *v44; // eax
  int v45; // ecx
  char *v46; // edi
  int v47; // ebx
  int i; // esi
  int v49; // edi
  char *v50; // eax
  int v51; // eax
  int *v52; // edx
  void *v53; // ecx
  token_type *v54; // edi
  long double v55; // fst6
  char v57; // c2
  long double v58; // fst7
  int v59; // edi
  int *v60; // ebx
  int *v61; // eax
  int v62; // edx
  token_type *v64; // [esp+18h] [ebp-70h]
  int v65; // [esp+1Ch] [ebp-6Ch]
  int n; // [esp+20h] [ebp-68h]
  token_type *src; // [esp+24h] [ebp-64h]
  int v68; // [esp+28h] [ebp-60h]
  int v69; // [esp+30h] [ebp-58h]
  size_t v70; // [esp+34h] [ebp-54h]
  size_t v71; // [esp+34h] [ebp-54h]
  int v72; // [esp+34h] [ebp-54h]
  int modified; // [esp+38h] [ebp-50h]
  int modifieda; // [esp+38h] [ebp-50h]
  int modifiedb; // [esp+38h] [ebp-50h]
  int modifiedc; // [esp+38h] [ebp-50h]
  int modifiedd; // [esp+38h] [ebp-50h]
  int v78; // [esp+3Ch] [ebp-4Ch]
  int v79; // [esp+40h] [ebp-48h]
  int v80; // [esp+40h] [ebp-48h]
  int v81; // [esp+40h] [ebp-48h]
  void *dest; // [esp+44h] [ebp-44h]
  void *desta; // [esp+44h] [ebp-44h]
  token_type *destb; // [esp+44h] [ebp-44h]
  void *v85; // [esp+48h] [ebp-40h]
  void *v86; // [esp+48h] [ebp-40h]
  int v87; // [esp+4Ch] [ebp-3Ch]
  int v88; // [esp+4Ch] [ebp-3Ch]
  int v89; // [esp+50h] [ebp-38h]
  int v90; // [esp+50h] [ebp-38h]
  void *v91; // [esp+50h] [ebp-38h]
  int v92; // [esp+50h] [ebp-38h]
  double v93; // [esp+50h] [ebp-38h]
  int v94; // [esp+50h] [ebp-38h]
  int v95; // [esp+58h] [ebp-30h]
  void *v96; // [esp+58h] [ebp-30h]
  int v97; // [esp+58h] [ebp-30h]
  int v98; // [esp+58h] [ebp-30h]
  char *v99; // [esp+58h] [ebp-30h]
  double v100; // [esp+58h] [ebp-30h]
  int v101; // [esp+58h] [ebp-30h]
  token_type *v102; // [esp+58h] [ebp-30h]
  int v103; // [esp+60h] [ebp-28h]
  int v104; // [esp+60h] [ebp-28h]
  int v105; // [esp+60h] [ebp-28h]
  int v106; // [esp+60h] [ebp-28h]
  int v107; // [esp+60h] [ebp-28h]
  int v108; // [esp+60h] [ebp-28h]
  int v109; // [esp+60h] [ebp-28h]
  token_type *v110; // [esp+64h] [ebp-24h]
  int v111; // [esp+64h] [ebp-24h]
  int v112; // [esp+64h] [ebp-24h]

  v3 = *np;
  v4 = 1;
  modified = 0;
  while ( *np > v4 )
  {
    v89 = v4;
    v110 = &equation[v4];
    v5 = v110->token.variable;
    if ( v5 >= 3 )
    {
      if ( v5 <= 4 )
      {
        if ( ii != 1 )
          goto LABEL_152;
      }
      else if ( v5 != 6 || (ii & 1) != 0 )
      {
        goto LABEL_152;
      }
      v6 = v110->level;
      v78 = v4 - 2;
      if ( v4 - 2 >= 0 && v6 <= equation[v4 - 2].level )
      {
        v7 = (int *)&equation[v4 - 3] - 3;
        v8 = v4 - 2;
        v87 = v4;
        do
        {
          v8 -= 2;
          if ( v8 < 0 )
          {
            v78 = v8;
            v4 = v87;
            goto LABEL_16;
          }
          v9 = *v7;
          v7 -= 8;
        }
        while ( v6 <= v9 );
        v78 = v8;
        v4 = v87;
      }
LABEL_16:
      v69 = v78 + 1;
      v95 = v4 + 2;
      if ( v4 + 2 >= v3 || v6 > equation[v4 + 2].level )
      {
        v88 = v4 + 2;
      }
      else
      {
        v10 = &equation[v4 + 4].level;
        v11 = v4 + 2;
        v103 = v4;
        do
        {
          v11 += 2;
          if ( v11 >= v3 )
          {
            v88 = v11;
            v4 = v103;
            goto LABEL_24;
          }
          v12 = *v10;
          v10 += 8;
        }
        while ( v6 <= v12 );
        v88 = v11;
        v4 = v103;
      }
LABEL_24:
      if ( v5 <= 4 )
      {
        if ( ii == 1 && v78 + 2 < v88 )
        {
          v13 = v78 + 2;
          v96 = (void *)v4;
          while ( 1 )
          {
            v14 = &equation[v13];
            v15 = v14->level;
            if ( v15 == v6 + 1 && (unsigned int)(v14->token.variable - 1) <= 1 )
            {
              v16 = v13 - 2;
              if ( v69 <= v13 - 2 && v6 < equation[v16].level )
              {
                v17 = (int *)&equation[v13 - 3] - 3;
                v104 = v15;
                do
                {
                  v16 -= 2;
                  if ( v69 > v16 )
                  {
                    v15 = v104;
                    goto LABEL_37;
                  }
                  v18 = *v17;
                  v17 -= 8;
                }
                while ( v6 < v18 );
                v15 = v104;
              }
LABEL_37:
              v90 = v16 + 1;
              v19 = v13 + 2;
              if ( v13 + 2 < v88 && v6 < equation[v19].level )
              {
                v20 = &equation[v13 + 4].level;
                v105 = v15;
                do
                {
                  v19 += 2;
                  if ( v19 >= v88 )
                  {
                    v15 = v105;
                    goto LABEL_44;
                  }
                  v21 = *v20;
                  v20 += 8;
                }
                while ( v6 < v21 );
                v15 = v105;
              }
LABEL_44:
              if ( v69 >= v90 || equation[v90 - 1].token.variable != 4 )
              {
                v70 = v15;
                v111 = v13;
                dest = (void *)v19;
                modifieda = v90 - v69;
                v68 = v88 - v19;
                n = 16 * (v90 - v69);
                src = &equation[v69];
                v65 = 16 * (v88 - v19);
                v64 = &equation[v19];
                v22 = 0;
                while ( 1 )
                {
                  v97 = v22 + modifieda;
                  v23 = v22 + modifieda + v111 - v90;
                  v106 = v23 + v68;
                  v79 = v23 + v68 + 1;
                  if ( v79 > n_tokens )
                    error_huge();
                  v24 = v22;
                  memmove(&scratch[v22], src, n);
                  for ( ; v97 > v22; ++v24 )
                  {
                    ++scratch[v24].level;
                    ++v22;
                  }
                  memmove(&scratch[v97], &equation[v90], 16 * (v111 - v90));
                  v25 = v23;
                  memmove(&scratch[v23], v64, v65);
                  for ( ; v106 > v23; ++v25 )
                  {
                    ++scratch[v25].level;
                    ++v23;
                  }
                  if ( v111 >= (int)dest )
                    break;
                  v26 = v106;
                  v27 = scratch;
                  scratch[v26].kind = equation[v111].kind;
                  v27[v26].level = equation[v111].level;
                  v27[v26].token.variable = equation[v111].token.variable;
                  *(&v27[v26].token.operatr + 1) = *(&equation[v111].token.operatr + 1);
                  --scratch[v26].level;
                  v28 = v111 + 2;
                  if ( v111 + 2 < (int)dest && v70 != equation[v28].level )
                  {
                    v29 = &equation[v111 + 4].level;
                    do
                    {
                      v28 += 2;
                      if ( v28 >= (int)dest )
                        break;
                      v30 = *v29;
                      v29 += 8;
                    }
                    while ( v70 != v30 );
                  }
                  v90 = v111 + 1;
                  v22 = v79;
                  v111 = v28;
                }
                if ( v106 + *np + v69 - v88 > n_tokens )
                  error_huge();
                memmove(&equation[v69 + v106], &equation[v88], 16 * (*np - v88));
                *np += v106 + v69 - v88;
                memmove(src, scratch, 16 * v106);
                goto LABEL_154;
              }
              v13 = v19 - 2;
            }
            v13 += 2;
            if ( v13 >= v88 )
            {
              v4 = (int)v96;
              goto LABEL_152;
            }
          }
        }
        goto LABEL_152;
      }
      if ( ii == 2 || !ii )
      {
        v107 = v78 + 2;
        if ( v78 + 2 < v4 )
        {
          v31 = &equation[v107];
          v80 = v6 + 1;
          if ( v31->level == v6 + 1 )
          {
LABEL_74:
            if ( (unsigned int)(v31->token.variable - 3) <= 1 )
            {
              v71 = v88 - v4;
              modifiedb = 16 * (v88 - v4);
              v98 = v78 + 1;
              v91 = 0;
              desta = (void *)v4;
              while ( 1 )
              {
                v34 = (signed int)v91 + v107 - v98;
                v35 = v34 + v71;
                v85 = (void *)(v34 + v71 + 1);
                if ( (int)v85 > n_tokens )
                  error_huge();
                memmove(&scratch[(_DWORD)v91], &equation[v98], 16 * (v107 - v98));
                v36 = v34;
                memmove(&scratch[v34], v110, modifiedb);
                for ( ; v35 > v34; ++v36 )
                {
                  ++scratch[v36].level;
                  ++v34;
                }
                if ( v107 >= (int)desta )
                  break;
                v37 = v35;
                v38 = scratch;
                scratch[v37].kind = equation[v107].kind;
                v38[v37].level = equation[v107].level;
                v38[v37].token.variable = equation[v107].token.variable;
                *(&v38[v37].token.operatr + 1) = *(&equation[v107].token.operatr + 1);
                --scratch[v37].level;
                v39 = v107 + 2;
                if ( v107 + 2 < (int)desta && equation[v39].level != v80 )
                {
                  v40 = &equation[v107 + 4].level;
                  do
                  {
                    v39 += 2;
                    if ( v39 >= (int)desta )
                      break;
                    v41 = *v40;
                    v40 += 8;
                  }
                  while ( v41 != v80 );
                }
                v98 = v107 + 1;
                v91 = v85;
                v107 = v39;
              }
              if ( v35 + *np + v69 - v88 > n_tokens )
                error_huge();
              memmove(&equation[v35 + v69], &equation[v88], 16 * (*np - v88));
              *np += v35 + v69 - v88;
              memmove(&equation[v69], scratch, 16 * v35);
              goto LABEL_154;
            }
          }
          else
          {
            v33 = &equation[v78 + 4];
            while ( 1 )
            {
              v107 += 2;
              if ( v107 >= v4 )
                break;
              v31 = v33;
              v32 = v33->level;
              v33 += 2;
              if ( v32 == v80 )
                goto LABEL_74;
            }
          }
        }
      }
      if ( (!ii || ii == 4) && v95 < v88 )
      {
        v42 = &equation[v95];
        v86 = (void *)(v6 + 1);
        if ( v42->level == v6 + 1 )
        {
          v108 = v95;
LABEL_102:
          if ( (unsigned int)(v42->token.variable - 1) <= 1 )
          {
            v92 = v4 + 1;
            v81 = v4 - v78;
            destb = &equation[v69];
            v46 = 0;
            v99 = (char *)(v95 - v69);
            modifiedc = v110->level;
            while ( 1 )
            {
              v112 = v108 - v92;
              if ( (int)&v99[(int)v46 + v108 - v92] > n_tokens )
                error_huge();
              v47 = (int)v46;
              memmove(&scratch[(_DWORD)v46], destb, 16 * v81);
              for ( i = (int)&v46[v81]; i > (int)v46; ++v47 )
              {
                ++scratch[v47].level;
                ++v46;
              }
              memmove(&scratch[i], &equation[v92], 16 * v112);
              v49 = i + v112;
              if ( v108 >= v88 )
                break;
              v50 = (char *)(16 * v49);
              *(_DWORD *)&v50[(_DWORD)scratch + 4] = modifiedc;
              *(_DWORD *)&v50[(_DWORD)scratch] = 2;
              if ( equation[v108].token.variable == 1 )
                *(_DWORD *)&v50[(_DWORD)scratch + 8] = 3;
              else
                *(_DWORD *)&v50[(_DWORD)scratch + 8] = 4;
              v51 = v108 + 2;
              if ( v108 + 2 < v88 && v86 != (void *)equation[v51].level )
              {
                v52 = &equation[v108 + 4].level;
                do
                {
                  v51 += 2;
                  if ( v51 >= v88 )
                    break;
                  v53 = (void *)*v52;
                  v52 += 8;
                }
                while ( v86 != v53 );
              }
              v46 = (char *)(v49 + 1);
              v92 = v108 + 1;
              v108 = v51;
            }
            if ( v49 + *np + v69 - v88 > n_tokens )
              error_huge();
            memmove(&equation[v49 + v69], &equation[v88], 16 * (*np - v88));
            *np += v49 + v69 - v88;
            memmove(destb, scratch, 16 * v49);
            goto LABEL_154;
          }
        }
        else
        {
          v44 = &equation[v4 + 4];
          v45 = v95;
          while ( 1 )
          {
            v45 += 2;
            if ( v45 >= v88 )
              break;
            v42 = v44;
            v43 = (void *)v44->level;
            v44 += 2;
            if ( v86 == v43 )
            {
              v108 = v45;
              goto LABEL_102;
            }
          }
        }
      }
      if ( ii != 6 && ii != 8 )
        goto LABEL_152;
      v54 = &equation[v89 + 1];
      if ( v6 != equation[v89 + 1].level )
        goto LABEL_152;
      if ( v54->kind )
        goto LABEL_152;
      v100 = equation[v89 + 1].token.constant;
      if ( !__finite(v100) || v100 <= 1.0 )
        goto LABEL_152;
      if ( ii != 8 )
      {
        if ( v100 > 100.0 )
          goto LABEL_152;
        if ( v4 - v69 == 1 )
        {
          if ( equation[v69].kind )
            goto LABEL_152;
        }
        else if ( v4 - v69 > 1 && v100 > 2.0 )
        {
          v55 = v100;
          do
            v55 = __FPREM__(v55, 1.0);
          while ( v57 );
          if ( v55 != 0.0 )
            goto LABEL_152;
        }
      }
      v93 = ceil(v100) - 1.0;
      v101 = v4 - v69;
      v58 = ((long double)(v4 - v69) + 1.0) * v93;
      if ( (long double)*np + v58 <= (long double)(n_tokens - 10) )
      {
        v109 = (int)v93;
        memmove(&equation[v88 + (int)v58], &equation[v88], 16 * (*np - v88));
        *np += (int)v58;
        v54->token.constant = v54->token.constant - v93;
        if ( v109 > 0 )
        {
          v72 = 16 * v101;
          v94 = 16 * (v101 + 1);
          v102 = &equation[v88 + 1];
          modifiedd = (int)v54;
          v59 = v4;
          v60 = &equation[v88].level;
          do
          {
            *v60 = v6;
            *(v60 - 1) = 2;
            v60[1] = 3;
            memmove(v102, &equation[v69], v72);
            v60 = (int *)((char *)v60 + v94);
            v102 = (token_type *)((char *)v102 + v94);
            --v109;
          }
          while ( v109 > 0 );
          v4 = v59;
          v54 = (token_type *)modifiedd;
        }
        if ( v54->token.constant == 1.0 )
        {
          memmove(v110, &equation[v88], 16 * (*np - v88));
          *np += v4 - v88;
        }
        else if ( v69 < v88 )
        {
          v61 = &equation[v69].level;
          v62 = v78 + 1;
          do
          {
            ++*v61;
            ++v62;
            v61 += 4;
          }
          while ( v62 < v88 );
        }
LABEL_154:
        v4 = v78;
        modified = 1;
        goto LABEL_152;
      }
    }
LABEL_152:
    v4 += 2;
    v3 = *np;
  }
  return modified;
}
// 80621CF: conditional instruction was optimized away because of 'edi.4 in (3..4|==6)'
// 80621DD: conditional instruction was optimized away because of 'edi.4==6'
// 8062AAA: variable 'v57' is possibly undefined

//----- (08062CC2) --------------------------------------------------------
void __cdecl uf_repeat_always(token_type *equation, int *np)
{
  organize(equation, np);
  if ( sub_ufactor(equation, np, 8) )
    organize(equation, np);
}

//----- (08062D0E) --------------------------------------------------------
void __cdecl uf_repeat(token_type *equation, int *np)
{
  organize(equation, np);
  if ( sub_ufactor(equation, np, 6) )
    organize(equation, np);
  patch_root_div(equation, np);
}

//----- (08062D66) --------------------------------------------------------
void __cdecl uf_allpower(token_type *equation, int *np)
{
  do
    organize(equation, np);
  while ( sub_ufactor(equation, np, 0) );
}

//----- (08062D9F) --------------------------------------------------------
int __cdecl uf_pplus(token_type *equation, int *np)
{
  int v2; // ebx

  organize(equation, np);
  v2 = sub_ufactor(equation, np, 4);
  if ( v2 )
    organize(equation, np);
  return v2;
}

//----- (08062DF5) --------------------------------------------------------
int __cdecl uf_power(token_type *equation, int *np)
{
  int v2; // ebx

  organize(equation, np);
  v2 = sub_ufactor(equation, np, 2);
  if ( v2 )
    organize(equation, np);
  return v2;
}

//----- (08062E4B) --------------------------------------------------------
int __cdecl uf_times(token_type *equation, int *np)
{
  token_type *v2; // esi
  int v3; // edi
  int v4; // edx
  token_type *v5; // ebx
  int v6; // ecx
  token_type *v7; // eax
  int v8; // eax
  int v9; // eax
  int rv; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]

  rv = 0;
  do
  {
    organize(equation, np);
    if ( partial_flag )
      reorder(equation, np);
    group_proc(equation, np);
    if ( partial_flag && *np > 1 )
    {
      v2 = equation;
      v3 = 0;
      do
      {
        if ( v2[1].token.variable == 4 )
        {
          v12 = v2[1].level;
          v4 = v3;
          if ( v3 >= 0 )
          {
            v5 = v2;
            v6 = v2->level;
            if ( v12 <= v6 )
            {
              v7 = v2 - 1;
              do
              {
                v5->level = v6 + 2;
                if ( --v4 < 0 )
                  break;
                v5 = v7;
                v6 = v7->level;
                --v7;
              }
              while ( v12 <= v6 );
            }
          }
        }
        v8 = v3 + 3;
        v3 += 2;
        v2 += 2;
      }
      while ( *np > v8 );
    }
    v9 = sub_ufactor(equation, np, 1);
    rv |= v9;
  }
  while ( v9 );
  organize(equation, np);
  return rv;
}

//----- (08062F4B) --------------------------------------------------------
int __cdecl ufactor(token_type *equation, int *np)
{
  int v2; // edi

  uf_repeat(equation, np);
  v2 = uf_times(equation, np);
  uf_allpower(equation, np);
  return v2;
}

//----- (08062F95) --------------------------------------------------------
int __cdecl uf_tsimp(token_type *equation, int *np)
{
  int v2; // edi

  v2 = uf_times(equation, np);
  simp_loop(equation, np);
  while ( uf_times(equation, np) )
  {
    simp_loop(equation, np);
    v2 = 1;
  }
  return v2;
}

//----- (08062FEB) --------------------------------------------------------
void __cdecl uf_simp_no_repeat(token_type *equation, int *np)
{
  uf_power(equation, np);
  uf_tsimp(equation, np);
}

//----- (0806301F) --------------------------------------------------------
void __cdecl uf_simp(token_type *equation, int *np)
{
  uf_tsimp(equation, np);
  uf_power(equation, np);
  uf_repeat(equation, np);
  uf_tsimp(equation, np);
}

//----- (08063070) --------------------------------------------------------
int __cdecl vcmp_0(sort_type *p1, sort_type *p2)
{
  return p2->count - p1->count;
}

//----- (08063081) --------------------------------------------------------
int __cdecl get_term(token_type *p1, int n1, int count, int *tp1, int *lentp1)
{
  int v6; // ecx
  int v7; // edi
  int i; // eax

  v6 = 0;
  v7 = 0;
  for ( i = 1; i < n1 && (p1[1].level != 1 || (unsigned int)(p1[1].token.variable - 1) > 1); i += 2 )
LABEL_9:
    p1 += 2;
  if ( ++v6 >= count )
  {
    *tp1 = v7;
    *lentp1 = i - v7;
    return 1;
  }
  if ( i < n1 )
  {
    v7 = i + 1;
    goto LABEL_9;
  }
  return 0;
}

//----- (080630F1) --------------------------------------------------------
void __cdecl term_value(double *dp, token_type *p1, int n1, int loc)
{
  int v4; // eax
  int *v5; // edx
  int v6; // edi
  int v7; // ebx
  int v8; // ecx
  long double v9; // fst7
  int *v10; // edx
  int v11; // ecx
  int *v12; // esi
  int v13; // edi
  int v14; // eax
  long double v15; // fst6
  token_type *v16; // eax
  long double v17; // fst5
  long double v18; // fst4
  int v19; // ebx
  int *v20; // edx
  int v21; // ecx
  long double v22; // fst6
  int *v23; // [esp+4h] [ebp-38h]
  int v24; // [esp+8h] [ebp-34h]
  int v25; // [esp+14h] [ebp-28h]
  int v26; // [esp+18h] [ebp-24h]
  int div_level; // [esp+1Ch] [ebp-20h]
  int v28; // [esp+20h] [ebp-1Ch]
  double *v29; // [esp+24h] [ebp-18h]
  token_type *v30; // [esp+28h] [ebp-14h]
  double *v31; // [esp+2Ch] [ebp-10h]
  int *v32; // [esp+2Ch] [ebp-10h]

  *dp = 0.0;
  v31 = dp + 1;
  dp[1] = 0.0;
  v29 = dp + 2;
  dp[2] = 0.0;
  v4 = loc;
  div_level = 0;
  if ( loc < n1 )
  {
    v5 = &p1[loc].level;
    v4 = loc;
    v6 = 0;
    do
    {
      v7 = *v5;
      v8 = *(v5 - 1);
      if ( v8 == 1 )
      {
        if ( v6 )
        {
          *dp = *dp - 1.0;
          *v31 = *v31 - (long double)v5[1];
          v9 = *v29 - (long double)v5[1];
        }
        else
        {
          *dp = *dp + 1.0;
          *v31 = (long double)v5[1] + *v31;
          v9 = (long double)v5[1] + *v29;
        }
        *v29 = v9;
      }
      else if ( v8 == 2 )
      {
        if ( v7 == 1 && (unsigned int)(v5[1] - 1) <= 1 )
          break;
        if ( v5[1] == 4 )
        {
          if ( !v6 || v7 < div_level )
          {
            div_level = *v5;
            v6 = 1;
          }
        }
        else if ( v6 && v7 <= div_level )
        {
          v6 = 0;
        }
      }
      ++v4;
      v5 += 4;
    }
    while ( n1 > v4 );
  }
  if ( v4 > loc + 1 )
  {
    v10 = &p1[loc + 1].level;
    v11 = loc;
    v12 = &p1[loc + 2].level;
    v32 = &p1[loc].level;
    v30 = &p1[loc - 1];
    v13 = 0;
    v28 = v4;
    do
    {
      v25 = *v10;
      v14 = v10[1];
      if ( v14 == 4 )
      {
        if ( !v13 || v25 < div_level )
        {
          div_level = *v10;
          v13 = 1;
        }
      }
      else
      {
        if ( v13 && v25 <= div_level )
          v13 = 0;
        if ( v14 == 6 )
        {
          v26 = *v12;
          if ( *v12 == v25 && !*(v12 - 1) )
          {
            v15 = *(double *)(v12 + 1) - 1.0;
            if ( loc > v11 || *v32 < v26 )
            {
              v17 = 0.0;
              v18 = 0.0;
            }
            else
            {
              v16 = v30;
              v17 = 0.0;
              v18 = 0.0;
              v24 = v11;
              v23 = v10;
              v19 = v11;
              v20 = v32 - 1;
              while ( 1 )
              {
                if ( *v20 == 1 )
                {
                  v18 = v18 + (long double)v20[2];
                  v17 = v17 + 1.0;
                }
                if ( loc > --v19 )
                  break;
                v20 = (int *)v16;
                v21 = v16->level;
                --v16;
                if ( v26 > v21 )
                {
                  v11 = v24;
                  v10 = v23;
                  goto LABEL_41;
                }
              }
              v11 = v24;
              v10 = v23;
            }
LABEL_41:
            if ( v13 )
            {
              *dp = *dp - v17 * v15;
              v22 = *v29 - v15 * v18;
            }
            else
            {
              *dp = v17 * v15 + *dp;
              v22 = v15 * v18 + *v29;
            }
            *v29 = v22;
          }
        }
      }
      v10 += 8;
      v11 += 2;
      v12 += 8;
      v32 += 8;
      v30 += 2;
    }
    while ( v28 > v11 + 1 );
  }
}

//----- (08063353) --------------------------------------------------------
int __cdecl basic_size(token_type *p1, int len)
{
  int v2; // ebx
  token_type *v3; // eax
  int v4; // esi
  int i; // edx
  int j; // [esp+14h] [ebp-24h]
  int rv; // [esp+18h] [ebp-20h]
  int level; // [esp+1Ch] [ebp-1Ch]

  v2 = len;
  level = min_level(p1, len);
  if ( len <= 0 )
  {
    rv = len;
    j = -1;
    v2 = 0;
    return j + rv - v2;
  }
  v3 = p1;
  rv = len;
  v4 = 1;
  j = -1;
  for ( i = 0; i != len; ++i )
  {
    if ( v3->kind == OPERATOR )
    {
      if ( level == v3->level && (unsigned int)(v3->token.variable - 3) <= 1 )
      {
        if ( v4 )
        {
          rv = rv + j - i;
          j = i;
          v4 = 1;
        }
        else
        {
          j = i;
          LOWORD(v4) = 1;
        }
      }
    }
    else if ( v3->kind )
    {
      v4 = 0;
    }
    ++v3;
  }
  if ( v4 )
    return j + rv - v2;
  return rv;
}

//----- (08063406) --------------------------------------------------------
int __cdecl poly_in_v(token_type *p1, int n, int v, int allow_divides)
{
  int v4; // esi
  int v5; // ebx
  token_type *v6; // esi
  int v7; // eax
  token_type *v8; // edx
  int v9; // ecx
  int v10; // edi
  int v11; // edi
  token_type *v12; // esi
  int v13; // edx
  token_type *v15; // [esp+20h] [ebp-38h]
  int v16; // [esp+28h] [ebp-30h]
  token_type *v17; // [esp+2Ch] [ebp-2Ch]
  int v18; // [esp+30h] [ebp-28h]
  int v19; // [esp+34h] [ebp-24h]
  token_type *v20; // [esp+38h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-1Ch]

  v20 = p1;
  v4 = 0;
  for ( i = 1; ; i += 2 )
  {
    if ( i < n && (v20[1].level != 1 || (unsigned int)(v20[1].token.variable - 1) > 1) )
      goto LABEL_33;
    v5 = i - v4;
    v6 = &p1[v4];
    v7 = min_level(v6, v5);
    if ( v5 > 0 )
      break;
LABEL_30:
    if ( i >= n )
      return 1;
    v4 = i + 1;
LABEL_33:
    v20 += 2;
  }
  v8 = v6;
  v9 = 1;
  v19 = 0;
  v16 = v7 + 1;
  v17 = v6;
  while ( 1 )
  {
    if ( v8->kind == VARIABLE && v == v8->token.variable )
    {
      if ( ++v19 > 1 )
        return 0;
      v10 = v8->level;
      v18 = v10;
      if ( v7 != v10 && v10 != v16 )
        return 0;
      if ( v5 > 1 )
      {
        v11 = 1;
        v15 = v8;
        v12 = v17;
        do
        {
          if ( v7 == v12[1].level )
          {
            v13 = v12[1].token.variable;
            switch ( v13 )
            {
              case 4:
                if ( !allow_divides && v9 - 2 == v11 )
                  return 0;
                break;
              case 6:
                if ( v9 != v11 )
                  return 0;
                break;
              case 3:
                break;
              default:
                return 0;
            }
          }
          v11 += 2;
          v12 += 2;
        }
        while ( v5 > v11 );
        v8 = v15;
      }
      if ( v18 == v16 && (v5 <= v9 || v18 != v8[1].level || v8[1].token.variable != 6) )
        return 0;
    }
    v8 += 2;
    v9 += 2;
    if ( v9 - 1 >= v5 )
      goto LABEL_30;
  }
}

//----- (08063572) --------------------------------------------------------
int __cdecl smart_div(token_type *d1, int len1, token_type *d2, int len2)
{
  int v4; // ecx
  int v5; // esi
  int i; // ebx
  token_type *v7; // edx
  int v8; // esi
  int v9; // edi
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v16; // edi
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // edx
  int v22; // eax
  int v23; // edx
  int v24; // edx
  int v25; // eax
  int v26; // eax
  int v27; // ecx
  int v28; // edx
  int v29; // edi
  int v30; // edx
  int v31; // eax
  int trhs_size; // [esp+28h] [ebp-200h]
  int v33; // [esp+34h] [ebp-1F4h]
  int count; // [esp+3Ch] [ebp-1ECh]
  int v35; // [esp+40h] [ebp-1E8h]
  int v36; // [esp+48h] [ebp-1E0h]
  int v37; // [esp+4Ch] [ebp-1DCh]
  int old_n_quotient; // [esp+50h] [ebp-1D8h]
  int v39; // [esp+54h] [ebp-1D4h]
  int v40; // [esp+54h] [ebp-1D4h]
  int t2; // [esp+58h] [ebp-1D0h]
  int n; // [esp+5Ch] [ebp-1CCh]
  void *src; // [esp+60h] [ebp-1C8h]
  int dcount; // [esp+64h] [ebp-1C4h]
  int term_pos; // [esp+68h] [ebp-1C0h]
  int term_posa; // [esp+68h] [ebp-1C0h]
  int term_posb; // [esp+68h] [ebp-1C0h]
  int len_t2; // [esp+6Ch] [ebp-1BCh]
  int skip_terms[100]; // [esp+78h] [ebp-1B0h]
  int len_t1; // [esp+208h] [ebp-20h] BYREF
  int t1[7]; // [esp+20Ch] [ebp-1Ch] BYREF

  memmove(trhs, d1, 16 * len1);
  n_trhs = len1;
  memmove(tlhs, d2, 16 * len2);
  n_tlhs = len2;
  uf_simp_no_repeat(trhs, &n_trhs);
  uf_simp_no_repeat(tlhs, &n_tlhs);
  if ( debug_level > 2 )
    __fprintf_chk(gfp, 1, "%s\n", "smart_div() starts:");
  list_debug(3, trhs, n_trhs, 0, 0);
  list_debug(3, tlhs, n_tlhs, 0, 0);
  v4 = 0;
  dcount = 0;
  len_t2 = 0;
  t2 = 0;
  term_pos = 0;
  v5 = 0;
  for ( i = 0; i < n_tlhs; ++i )
  {
    v7 = &tlhs[i];
    if ( v7->kind == OPERATOR )
    {
      if ( v7->level == 1 && (unsigned int)(v7->token.variable - 1) <= 1 )
        break;
    }
    else if ( v7->kind == VARIABLE && v7->token.variable != 3 )
    {
      v4 = 1;
    }
LABEL_19:
    ;
  }
  ++dcount;
  if ( v4 && (!len_t2 || term_pos > var_count(&tlhs[v5], i - v5)) )
  {
    len_t2 = i - v5;
    term_pos = var_count(&tlhs[v5], i - v5);
    t2 = v5;
  }
  if ( i < n_tlhs )
  {
    v5 = i + 1;
    v4 = 0;
    goto LABEL_19;
  }
  if ( len_t2 <= 0 )
    return 0;
  n_quotient = 1;
  quotient[0] = zero_token;
  if ( n_tlhs > 30000 )
    return 0;
  __memmove_chk(divisor, tlhs, 16 * n_tlhs, 480000);
  n_divisor = n_tlhs;
  while ( 2 )
  {
    trhs_size = n_trhs;
    n = 16 * len_t2;
    src = (void *)(16 * t2 + 135718304);
    v37 = t2 + len_t2;
    count = 0;
    v8 = 0;
LABEL_24:
    v35 = n_trhs;
    v33 = n_quotient;
    term_posa = skip_terms[0];
    v9 = 1;
    while ( 2 )
    {
      if ( !get_term(trhs, n_trhs, v9, t1, &len_t1) )
        goto LABEL_43;
      if ( v8 > 0 )
      {
        v10 = 0;
        if ( term_posa == t1[0] )
        {
LABEL_42:
          ++v9;
          continue;
        }
        while ( v8 > ++v10 )
        {
          if ( t1[0] == skip_terms[v10] )
            goto LABEL_42;
        }
      }
      break;
    }
    if ( len_t2 + len_t1 + 1 > n_tokens )
      return 0;
    memmove(tlhs, &trhs[t1[0]], 16 * len_t1);
    v11 = len_t1;
    n_tlhs = len_t1;
    if ( len_t1 > 0 )
    {
      v12 = 0;
      do
      {
        ++tlhs[v12++].level;
        v11 = n_tlhs;
      }
      while ( n_tlhs > v12 );
    }
    tlhs[v11].level = 1;
    tlhs[n_tlhs].kind = OPERATOR;
    tlhs[n_tlhs++].token.variable = 4;
    memmove(&tlhs[n_tlhs], src, n);
    v13 = n_tlhs;
    n_tlhs += len_t2;
    if ( v13 < n_tlhs )
    {
      v14 = v13;
      do
      {
        ++tlhs[v14].level;
        ++v13;
        ++v14;
      }
      while ( n_tlhs > v13 );
    }
    if ( !simp_loop(tlhs, &n_tlhs) )
      goto LABEL_42;
    v39 = basic_size(tlhs, n_tlhs);
    if ( v39 > basic_size(&trhs[t1[0]], len_t1) )
      goto LABEL_42;
    term_posb = t1[0];
    if ( n_tlhs <= 0 )
    {
LABEL_43:
      if ( count <= 0 )
      {
        if ( dcount <= 1 )
          return 0;
        len_t2 = n_divisor;
        t2 = 0;
        dcount = 1;
        continue;
      }
end_div:
      if ( dcount > 1 )
      {
LABEL_47:
        if ( n_quotient + n_trhs >= trhs_size + 1 )
          return 0;
      }
end_div2:
      memmove(tlhs, quotient, 16 * n_quotient);
      n_tlhs = n_quotient;
      list_debug(3, tlhs, n_quotient, 0, 0);
      list_debug(3, trhs, n_trhs, 0, 0);
      return 1;
    }
    break;
  }
  if ( t1[0] <= 0 || (v16 = 2, trhs[t1[0] - 1].token.variable != 2) )
    v16 = 1;
  if ( t2 > 0 && divisor[t2 - 1].token.variable == 2 )
    v16 = (v16 != 2) + 1;
  if ( len_t1 + len_t2 + 1 <= n_tokens )
  {
    memmove(tlhs, &trhs[t1[0]], 16 * len_t1);
    v17 = len_t1;
    n_tlhs = len_t1;
    if ( len_t1 > 0 )
    {
      v18 = 0;
      do
      {
        ++tlhs[v18++].level;
        v17 = n_tlhs;
      }
      while ( n_tlhs > v18 );
    }
    tlhs[v17].level = 1;
    tlhs[n_tlhs].kind = OPERATOR;
    tlhs[n_tlhs++].token.variable = 4;
    memmove(&tlhs[n_tlhs], src, n);
    v19 = n_tlhs;
    n_tlhs += len_t2;
    if ( v19 < n_tlhs )
    {
      v20 = v19;
      do
      {
        ++tlhs[v20].level;
        ++v19;
        ++v20;
      }
      while ( n_tlhs > v19 );
    }
    simp_loop(tlhs, &n_tlhs);
    v21 = 30000;
    if ( n_tokens <= 30000 )
      v21 = n_tokens;
    if ( n_quotient + n_tlhs + 1 <= v21 )
    {
      if ( n_tlhs > 0 )
      {
        v22 = 0;
        do
          ++tlhs[v22++].level;
        while ( n_tlhs > v22 );
      }
      old_n_quotient = n_quotient;
      v23 = n_quotient;
      quotient[v23].level = 1;
      quotient[v23].kind = OPERATOR;
      quotient[v23].token.variable = v16;
      n_quotient = old_n_quotient + 1;
      v40 = n_tlhs;
      v36 = 16 * n_tlhs;
      memmove((void *)(16 * (old_n_quotient + 1) + 134758272), tlhs, 16 * n_tlhs);
      n_quotient += n_tlhs;
      if ( n_divisor + n_trhs + v40 + 2 <= n_tokens )
      {
        memmove(tlhs, trhs, 16 * n_trhs);
        n_tlhs = n_trhs;
        memmove(&trhs[t1[0] + 1], &trhs[len_t1 + t1[0]], 16 * (n_trhs - (len_t1 + t1[0])));
        n_trhs = n_trhs + 1 - len_t1;
        trhs[t1[0]] = zero_token;
        v24 = n_trhs;
        if ( n_trhs > 0 )
        {
          v25 = 0;
          do
          {
            ++trhs[v25++].level;
            v24 = n_trhs;
          }
          while ( n_trhs > v25 );
        }
        trhs[v24].level = 1;
        trhs[n_trhs].kind = OPERATOR;
        if ( v16 == 1 )
          trhs[n_trhs].token.variable = 2;
        else
          trhs[n_trhs].token.variable = 1;
        memmove(&trhs[++n_trhs], (const void *)(16 * (old_n_quotient + 1) + 134758272), v36);
        v26 = n_trhs;
        v27 = n_trhs + v40;
        n_trhs = v27;
        if ( v26 < v27 )
        {
          v28 = v26;
          do
          {
            ++trhs[v28].level;
            ++v26;
            v27 = n_trhs;
            ++v28;
          }
          while ( n_trhs > v26 );
        }
        trhs[v27].level = 2;
        trhs[n_trhs].kind = OPERATOR;
        trhs[n_trhs].token.variable = 3;
        v29 = n_trhs + 1;
        n_trhs = v29;
        memmove(&trhs[v29], divisor, 16 * t2);
        n_trhs += t2;
        trhs[n_trhs++] = zero_token;
        memmove(&trhs[n_trhs], (const void *)(16 * (t2 + len_t2) + 135718304), 16 * (n_divisor - v37));
        v30 = n_divisor + n_trhs - v37;
        n_trhs = v30;
        if ( v29 < v30 )
        {
          v31 = v29;
          do
          {
            trhs[v31].level += 2;
            ++v29;
            v30 = n_trhs;
            ++v31;
          }
          while ( n_trhs > v29 );
        }
        list_debug(3, trhs, v30, 0, 0);
        uf_tsimp(trhs, &n_trhs);
        list_debug(4, trhs, n_trhs, 0, 0);
        if ( n_trhs == 1 && trhs->kind == CONSTANT && trhs->token.constant == 0.0 )
          goto end_div2;
        if ( dcount <= 1 || v35 + v33 > n_quotient + n_trhs )
        {
          if ( n_trhs != 1 || trhs->kind )
          {
            ++count;
            v8 = 0;
            goto LABEL_24;
          }
          goto end_div;
        }
        if ( v8 <= 99 )
        {
          skip_terms[v8++] = term_posb;
          n_quotient = old_n_quotient;
          memmove(trhs, tlhs, 16 * n_tlhs);
          n_trhs = n_tlhs;
          if ( debug_level > 2 )
            __fprintf_chk(gfp, 1, "%s\n", "Skipping last operation.");
          goto LABEL_24;
        }
        if ( count )
        {
          n_quotient = old_n_quotient;
          memmove(trhs, tlhs, 16 * n_tlhs);
          n_trhs = n_tlhs;
          goto LABEL_47;
        }
      }
    }
  }
  return 0;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049244: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806425F) --------------------------------------------------------
void __usercall save_factors(token_type *equation@<eax>, int *np@<edx>, int loc1@<ecx>, int len, int level)
{
  int v7; // edx
  token_type *v8; // eax
  int v9; // edx
  int *v10; // eax
  int v11; // ecx
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+18h] [ebp-20h]

  v12 = n_trhs + n_tlhs + 1;
  if ( *np + v12 - len > n_tokens )
    error_huge();
  memmove(&equation[v12 + loc1], &equation[loc1 + len], 16 * (*np - (loc1 + len)));
  *np += v12 - len;
  memmove(&equation[loc1], tlhs, 16 * n_tlhs);
  v7 = n_tlhs + loc1;
  v8 = &equation[n_tlhs + loc1];
  v8->level = 0;
  v8->kind = OPERATOR;
  v8->token.variable = 3;
  v13 = v7 + 1;
  memmove(&equation[v7 + 1], trhs, 16 * n_trhs);
  v9 = n_trhs + v13;
  if ( loc1 < n_trhs + v13 )
  {
    v10 = &equation[loc1].level;
    v11 = loc1;
    do
    {
      *v10 += level;
      ++v11;
      v10 += 4;
    }
    while ( v9 > v11 );
  }
}

//----- (0806436B) --------------------------------------------------------
int __cdecl is_integer_var(int v)
{
  int (*v1)(const char *, const char *, size_t); // ebx
  char *v2; // edx
  int result; // eax

  v1 = strncasecmp;
  if ( case_sensitive_flag )
    v1 = strncmp;
  v2 = var_name(v);
  result = 0;
  if ( v2 )
    result = v1(v2, "integer", 7) == 0;
  return result;
}

//----- (080643BF) --------------------------------------------------------
int __cdecl is_integer_expr(token_type *p1, int n)
{
  int i; // esi
  kind_list v4; // eax
  long double v5; // fst5
  char v7; // c2

  if ( n > 0 )
  {
    for ( i = 0; n > i; ++i )
    {
      v4 = p1->kind;
      if ( p1->kind == VARIABLE )
      {
        if ( !is_integer_var(p1->token.variable) && (p1->token.variable & 0x3FFF) != 4 )
          return 0;
      }
      else if ( v4 )
      {
        if ( v4 == OPERATOR && p1->token.variable == 4 )
          return 0;
      }
      else
      {
        v5 = p1->token.constant;
        do
          v5 = __FPREM__(v5, 1.0);
        while ( v7 );
        if ( v5 != 0.0 )
          return 0;
      }
      ++p1;
    }
  }
  return 1;
}
// 8064406: variable 'v7' is possibly undefined

//----- (0806447A) --------------------------------------------------------
int remove_factors()
{
  int v0; // ebx
  int v2; // ecx
  int v3; // ebx
  token_type *v4; // eax
  int v5; // esi
  int v6; // eax
  int divide_flag; // [esp+24h] [ebp-24h]
  int n1; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+2Ch] [ebp-1Ch]

  if ( debug_level > 2 )
    __fprintf_chk(gfp, 1, "%s\n", "Entering remove_factors() with:");
  list_debug(3, tlhs, n_tlhs, 0, 0);
  do
    simp_ssub(tlhs, &n_tlhs, 0, 1.0, 0, 1, 4);
  while ( uf_power(tlhs, &n_tlhs) );
  if ( n_tlhs <= 1 )
    return 0;
  divide_flag = 0;
  v2 = 0;
  n1 = 0;
  v9 = 0;
  v3 = 1;
  do
  {
    v4 = &tlhs[v3];
    v5 = v4->token.variable;
    v6 = v4->level;
    if ( v6 == 1 )
    {
      if ( v5 < 1 )
        return 0;
      if ( v5 <= 2 )
      {
LABEL_26:
        v2 = 1;
        goto LABEL_27;
      }
      if ( v5 > 4 )
        return 0;
      if ( v2 && !divide_flag )
      {
        v10 = v9 - (n1 > 0);
        memmove(&scratch[n1], &tlhs[v10], 16 * (v3 - v10));
        n1 += v3 - v10;
      }
      divide_flag = v5 == 4;
      v9 = v3 + 1;
      v2 = 0;
    }
    else if ( v6 == 2 && (unsigned int)(v5 - 1) <= 1 )
    {
      goto LABEL_26;
    }
LABEL_27:
    v3 += 2;
  }
  while ( n_tlhs > v3 );
  if ( v2 && !divide_flag )
  {
    if ( n1 > 0 )
      --v9;
    v0 = v3 - v9;
    memmove(&scratch[n1], &tlhs[v9], 16 * v0);
    n1 += v0;
  }
  if ( n1 > 0 )
  {
    memmove(tlhs, scratch, 16 * n1);
    n_tlhs = n1;
    list_debug(3, tlhs, n1, 0, 0);
    return 1;
  }
  return 0;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080646FC) --------------------------------------------------------
int __cdecl find_greatest_power(token_type *p1, int n1, int *vp1, double *pp1, int *tp1, int *lentp1, int *dcodep)
{
  unsigned int i; // eax
  int v8; // ecx
  int v9; // ebx
  token_type *k; // esi
  int v11; // eax
  int v12; // eax
  token_type *v13; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // edx
  long double v17; // fst7
  long double v18; // fst5
  long double v19; // fst6
  int v20; // edx
  int v21; // esi
  int *v22; // edx
  int v23; // ecx
  int v24; // edx
  int v25; // edi
  token_type *v26; // eax
  int v27; // ecx
  int *v28; // ebx
  long double v29; // fst7
  int v30; // edx
  int v31; // eax
  int v32; // edx
  long double v33; // fst5
  long double v34; // fst6
  int v35; // esi
  int v36; // ecx
  int v37; // edx
  storage_type *v38; // eax
  int v40; // [esp+24h] [ebp-84h]
  double d; // [esp+28h] [ebp-80h]
  token_type *v42; // [esp+38h] [ebp-70h]
  int v43; // [esp+3Ch] [ebp-6Ch]
  int v44; // [esp+3Ch] [ebp-6Ch]
  int v; // [esp+40h] [ebp-68h]
  int rv; // [esp+44h] [ebp-64h]
  int count; // [esp+48h] [ebp-60h]
  token_type *v48; // [esp+4Ch] [ebp-5Ch]
  int v49; // [esp+4Ch] [ebp-5Ch]
  int div_level; // [esp+50h] [ebp-58h]
  int j; // [esp+54h] [ebp-54h]
  int v52; // [esp+5Ch] [ebp-4Ch]
  int v53; // [esp+5Ch] [ebp-4Ch]
  double va[3]; // [esp+60h] [ebp-48h] BYREF
  double last_va[3]; // [esp+78h] [ebp-30h] BYREF

  for ( i = 0; i < 0x18; i += 4 )
    *(_DWORD *)((char *)last_va + i) = 0;
  *pp1 = 0.0;
  *tp1 = -1;
  rv = *dcodep;
  count = 0;
  v8 = 0;
  v = 0;
  div_level = 0;
  v52 = 0;
  j = 0;
  v9 = 1;
  for ( k = p1; v9 < n1; k += 2 )
  {
    v11 = k[1].token.variable;
    if ( (unsigned int)(v11 - 1) <= 1 && k[1].level == 1 )
      break;
    v24 = k[1].level;
    if ( v11 == 4 )
    {
      if ( !v52 || v24 < div_level )
      {
        div_level = k[1].level;
        v52 = 1;
      }
    }
    else
    {
      if ( v52 )
      {
        v25 = 0;
        if ( v24 > div_level )
          v25 = v52;
        v52 = v25;
      }
      if ( v11 == 6 && k[2].kind == CONSTANT )
      {
        v49 = *vp1;
        if ( (*vp1 || k[2].level == v24) && (*dcodep > 1 || v52 == *dcodep) )
        {
          d = k[2].token.constant;
          v26 = k;
          v42 = k;
          v40 = v8;
          v27 = v9;
          v44 = v9;
          v28 = &k[-1].level;
          while ( 1 )
          {
            if ( v26->kind == VARIABLE )
            {
              if ( !v49 )
              {
                v9 = v44;
                k = v42;
                if ( d > (long double)*pp1 )
                {
                  v = v26->token.variable;
                  *pp1 = d;
                  *tp1 = j;
                  rv = v52;
                  v8 = 1;
                  goto LABEL_92;
                }
                goto LABEL_90;
              }
              if ( v49 == v26->token.variable )
                break;
            }
            v27 -= 2;
            if ( j >= v27 )
            {
              k = v42;
              v8 = v40;
              v9 = v44;
              goto LABEL_92;
            }
            v35 = *v28;
            v26 -= 2;
            v28 -= 8;
            if ( v24 >= v35 )
            {
              k = v42;
              v8 = v40;
              v9 = v44;
              goto LABEL_92;
            }
          }
          k = v42;
          v9 = v44;
          term_value(va, p1, n1, j);
          v29 = *pp1;
          LOBYTE(v30) = d == v29;
          LOBYTE(v31) = 1;
          v32 = (rv > v52) & v31 & v30;
          if ( d == v29 && rv == v52 )
          {
            count += *tp1 != j;
            if ( va[0] == last_va[0] )
            {
              if ( va[1] == last_va[1] )
              {
                if ( va[2] != last_va[2] )
                {
                  v33 = last_va[2];
                  v34 = va[2];
                  goto LABEL_77;
                }
LABEL_82:
                if ( d > v29 || v32 )
                {
LABEL_84:
                  memmove(last_va, va, 0x18u);
                  *pp1 = d;
                  *tp1 = j;
                  rv = v52;
                  v8 = 1;
                  goto LABEL_92;
                }
LABEL_90:
                v8 = 1;
                goto LABEL_92;
              }
              v33 = last_va[1];
              v34 = va[1];
            }
            else
            {
              v33 = last_va[0];
              v34 = va[0];
            }
LABEL_77:
            if ( v33 <= v34 )
              goto LABEL_82;
            goto LABEL_84;
          }
          if ( d > v29 || v32 )
          {
            count = 1;
            goto LABEL_84;
          }
          goto LABEL_90;
        }
      }
    }
LABEL_92:
    v9 += 2;
  }
  if ( v8 || *pp1 > 1.0 || v9 <= j )
    goto LABEL_49;
  v12 = j;
  v48 = k;
  v43 = 0;
  while ( 1 )
  {
    v13 = &p1[v12];
    if ( v13->kind == VARIABLE )
      break;
    if ( v13->kind == OPERATOR )
    {
      v20 = v13->token.variable;
      if ( v20 == 4 )
      {
        if ( !v43 || div_level > v13->level )
        {
          div_level = v13->level;
          v43 = 1;
        }
      }
      else
      {
        if ( v43 )
        {
          v21 = 0;
          if ( div_level < v13->level )
            v21 = v43;
          v43 = v21;
        }
        if ( v20 == 6 )
        {
          v53 = v13->level;
          v22 = &p1[v12 + 2].level;
          do
          {
            v12 += 2;
            if ( v9 <= v12 )
              break;
            v23 = *v22;
            v22 += 8;
          }
          while ( v53 < v23 );
          --v12;
        }
      }
    }
LABEL_47:
    if ( v9 <= ++v12 )
    {
      k = v48;
      goto LABEL_49;
    }
  }
  if ( *dcodep <= 1 && v43 != *dcodep )
    goto LABEL_47;
  if ( !*vp1 )
  {
    k = v48;
    v = v13->token.variable;
    *pp1 = 1.0;
    *tp1 = j;
    rv = v43;
    goto LABEL_49;
  }
  if ( *vp1 != v13->token.variable )
    goto LABEL_47;
  k = v48;
  term_value(va, p1, n1, j);
  LOBYTE(v14) = 1.0 == *pp1;
  LOBYTE(v15) = 1;
  v16 = (rv > v43) & v15 & v14;
  v17 = *pp1;
  if ( v17 != 1.0 || rv != v43 )
  {
    if ( v17 < 1.0 || v16 )
    {
      count = 1;
      goto LABEL_31;
    }
    goto LABEL_49;
  }
  count += *tp1 != j;
  if ( va[0] != last_va[0] )
  {
    v18 = last_va[0];
    v19 = va[0];
    goto LABEL_24;
  }
  if ( va[1] != last_va[1] )
  {
    v18 = last_va[1];
    v19 = va[1];
LABEL_24:
    if ( v18 <= v19 )
      goto LABEL_29;
    goto LABEL_31;
  }
  if ( va[2] != last_va[2] )
  {
    v18 = last_va[2];
    v19 = va[2];
    goto LABEL_24;
  }
LABEL_29:
  if ( v17 < 1.0 || v16 )
  {
LABEL_31:
    memmove(last_va, va, 0x18u);
    *pp1 = 1.0;
    *tp1 = j;
    rv = v43;
  }
LABEL_49:
  if ( v9 < n1 )
  {
    j = v9 + 1;
    v8 = 0;
    v52 = 0;
    goto LABEL_92;
  }
  if ( !*vp1 )
    *vp1 = v;
  v36 = *tp1;
  if ( *tp1 >= 0 )
  {
    v37 = v36 + 1;
    if ( n1 > v36 + 1 )
    {
      v38 = &p1[v37].token;
      do
      {
        if ( (unsigned int)(v38->variable - 1) <= 1 && *(&v38[-1].operatr + 1) == 1 )
          break;
        v37 += 2;
        v38 += 4;
      }
      while ( n1 > v37 );
    }
    *lentp1 = v37 - v36;
  }
  if ( *dcodep == 2 )
    *dcodep = rv;
  return count;
}
// 8064859: variable 'v15' is possibly undefined
// 8064859: variable 'v14' is possibly undefined
// 8064B0F: variable 'v31' is possibly undefined
// 8064B0F: variable 'v30' is possibly undefined

//----- (08064D0F) --------------------------------------------------------
int __usercall find_highest_count@<eax>(token_type *p1@<eax>, int n1@<edx>, token_type *p2@<ecx>, int n2, int *vp1)
{
  int v6; // edi
  int v7; // ecx
  int v8; // edx
  token_type *v9; // eax
  signed int v10; // esi
  int v11; // edi
  int v12; // eax
  int v13; // eax
  int count1; // [esp+28h] [ebp-1F90h]
  int count1a; // [esp+28h] [ebp-1F90h]
  int count1b; // [esp+28h] [ebp-1F90h]
  int last_v; // [esp+2Ch] [ebp-1F8Ch]
  sort_type va[1000]; // [esp+38h] [ebp-1F80h] BYREF
  double d2; // [esp+1F78h] [ebp-40h] BYREF
  double d1; // [esp+1F80h] [ebp-38h] BYREF
  int len_t2; // [esp+1F8Ch] [ebp-2Ch] BYREF
  int t2; // [esp+1F90h] [ebp-28h] BYREF
  int len_t1; // [esp+1F94h] [ebp-24h] BYREF
  int t1; // [esp+1F98h] [ebp-20h] BYREF
  int divide_flag[7]; // [esp+1F9Ch] [ebp-1Ch] BYREF

  if ( n1 <= 0 )
  {
    v10 = 0;
    goto LABEL_18;
  }
  last_v = 0;
  v10 = 0;
  while ( 2 )
  {
    v9 = p1;
    v6 = -1;
    count1 = 0;
    v8 = 0;
    while ( 1 )
    {
      if ( v9->kind != VARIABLE )
        goto LABEL_10;
      v7 = v9->token.variable;
      if ( v7 <= last_v )
        goto LABEL_10;
      if ( v6 != -1 && v7 >= v6 )
      {
        if ( v6 == v7 )
        {
          ++count1;
          v7 = v6;
          goto LABEL_12;
        }
LABEL_10:
        v7 = v6;
        goto LABEL_12;
      }
      count1 = 1;
LABEL_12:
      v8 += 2;
      v9 += 2;
      if ( n1 <= v8 )
        break;
      v6 = v7;
    }
    if ( v7 != -1 )
    {
      va[v10].v = v7;
      va[v10++].count = count1;
      if ( v10 != 1000 )
      {
        last_v = v7;
        continue;
      }
LABEL_19:
      qsort(va, v10, 8u, (__compar_fn_t)vcmp_0);
      v11 = 0;
      while ( 1 )
      {
        if ( (va[v11].v & 0x3FFFu) > 4 )
        {
          *vp1 = va[v11].v;
          divide_flag[0] = 2;
          count1a = find_greatest_power(p1, n1, vp1, &d1, &t1, &len_t1, divide_flag);
          v12 = find_greatest_power(p2, n2, vp1, &d2, &t2, &len_t2, divide_flag);
          if ( d2 > 0.0 && d2 <= (long double)d1 && count1a >= v12 )
            break;
          divide_flag[0] = divide_flag[0] == 0;
          count1b = find_greatest_power(p1, n1, vp1, &d1, &t1, &len_t1, divide_flag);
          v13 = find_greatest_power(p2, n2, vp1, &d2, &t2, &len_t2, divide_flag);
          if ( d2 > 0.0 && d2 <= (long double)d1 && count1b >= v13 )
            break;
        }
        if ( ++v11 >= v10 )
          return 0;
      }
      return va[v11].count;
    }
    break;
  }
LABEL_18:
  if ( v10 > 0 )
    goto LABEL_19;
  return 0;
}

//----- (08064F8F) --------------------------------------------------------
int __cdecl poly_div(token_type *d1, int len1, token_type *d2, int len2, int *vp)
{
  int v5; // ebx
  int v6; // ebx
  int v7; // edi
  int v8; // ebx
  int v9; // edx
  int v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // edx
  int v14; // eax
  int v15; // ecx
  int v16; // edx
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // ebx
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v27; // [esp+24h] [ebp-F4h]
  int v28; // [esp+28h] [ebp-F0h]
  int old_partial; // [esp+2Ch] [ebp-ECh]
  jmp_buf save_save; // [esp+34h] [ebp-E4h] BYREF
  double v31; // [esp+D0h] [ebp-48h] BYREF
  double v32; // [esp+D8h] [ebp-40h] BYREF
  double pp1; // [esp+E0h] [ebp-38h] BYREF
  int dcodep; // [esp+ECh] [ebp-2Ch] BYREF
  int v35; // [esp+F0h] [ebp-28h] BYREF
  int v36; // [esp+F4h] [ebp-24h] BYREF
  int lentp1; // [esp+F8h] [ebp-20h] BYREF
  int tp1[7]; // [esp+FCh] [ebp-1Ch] BYREF

  old_partial = partial_flag;
  partial_flag = 0;
  memmove(save_save, jmp_save, 0x9Cu);
  v5 = _setjmp(jmp_save);
  if ( v5 )
  {
    memmove(jmp_save, save_save, 0x9Cu);
    partial_flag = old_partial;
    if ( v5 == 13 )
      __longjmp_chk(jmp_save, 13);
    v6 = 0;
  }
  else
  {
    if ( len1 <= n_tokens && len2 <= n_tokens )
    {
      if ( d1 != trhs )
      {
        memmove(trhs, d1, 16 * len1);
        n_trhs = len1;
      }
      if ( d2 != tlhs )
      {
        memmove(tlhs, d2, 16 * len2);
        n_tlhs = len2;
      }
      uf_simp(trhs, &n_trhs);
      uf_simp(tlhs, &n_tlhs);
      if ( *vp || find_highest_count(trhs, n_trhs, tlhs, n_tlhs, vp) )
      {
        if ( debug_level > 2 )
        {
          list_var(*vp, 0);
          __fprintf_chk(gfp, 1, "poly_div() starts using base variable (%s):\n", var_str);
          list_debug(3, trhs, n_trhs, 0, 0);
          list_debug(3, tlhs, n_tlhs, 0, 0);
        }
        if ( (dcodep = 2,
              v7 = find_greatest_power(trhs, n_trhs, vp, &pp1, tp1, &lentp1, &dcodep),
              find_greatest_power(tlhs, n_tlhs, vp, &v32, &v36, &v35, &dcodep),
              v32 > 0.0)
          && v32 <= (long double)pp1
          || (dcodep = dcodep == 0,
              v7 = find_greatest_power(trhs, n_trhs, vp, &pp1, tp1, &lentp1, &dcodep),
              find_greatest_power(tlhs, n_tlhs, vp, &v32, &v36, &v35, &dcodep),
              v32 > 0.0)
          && v32 <= (long double)pp1 )
        {
          n_quotient = 1;
          quotient[0] = zero_token;
          if ( n_tlhs <= 30000 )
          {
            __memmove_chk(divisor, tlhs, 16 * n_tlhs, 480000);
            n_divisor = n_tlhs;
            v28 = n_trhs;
            v27 = n_quotient;
            while ( 1 )
            {
              if ( tp1[0] <= 0 || (v8 = 2, trhs[tp1[0] - 1].token.variable != 2) )
                v8 = 1;
              if ( v36 > 0 && dword_816E598[4 * v36] == 2 )
                v8 = (v8 != 2) + 1;
              if ( v35 + lentp1 + 1 > n_tokens )
                break;
              memmove(tlhs, &trhs[tp1[0]], 16 * lentp1);
              v9 = lentp1;
              n_tlhs = lentp1;
              if ( lentp1 > 0 )
              {
                v10 = 0;
                do
                {
                  ++tlhs[v10++].level;
                  v9 = n_tlhs;
                }
                while ( v10 < n_tlhs );
              }
              tlhs[v9].level = 1;
              tlhs[n_tlhs].kind = OPERATOR;
              tlhs[n_tlhs++].token.variable = 4;
              memmove(&tlhs[n_tlhs], (const void *)(16 * v36 + 135718304), 16 * v35);
              v11 = n_tlhs;
              n_tlhs += v35;
              if ( v11 < n_tlhs )
              {
                v12 = v11;
                do
                {
                  ++tlhs[v12].level;
                  ++v11;
                  ++v12;
                }
                while ( v11 < n_tlhs );
              }
              if ( !simp_loop(tlhs, &n_tlhs) )
                break;
              v13 = 30000;
              if ( n_tokens <= 30000 )
                v13 = n_tokens;
              if ( n_quotient + n_tlhs + 1 > v13 )
                break;
              if ( n_tlhs > 0 )
              {
                v14 = 0;
                do
                  ++tlhs[v14++].level;
                while ( v14 < n_tlhs );
              }
              v15 = n_quotient;
              v16 = n_quotient;
              quotient[v16].level = 1;
              quotient[v16].kind = OPERATOR;
              quotient[v16].token.variable = v8;
              n_quotient = v15 + 1;
              memmove((void *)(16 * (v15 + 1) + 134758272), tlhs, 16 * n_tlhs);
              n_quotient += n_tlhs;
              if ( n_divisor + n_tlhs + n_trhs + 2 > n_tokens )
                break;
              memmove(&trhs[tp1[0] + 1], &trhs[lentp1 + tp1[0]], 16 * (n_trhs - (lentp1 + tp1[0])));
              n_trhs = n_trhs + 1 - lentp1;
              trhs[tp1[0]] = zero_token;
              v17 = n_trhs;
              if ( n_trhs > 0 )
              {
                v18 = 0;
                do
                {
                  ++trhs[v18++].level;
                  v17 = n_trhs;
                }
                while ( v18 < n_trhs );
              }
              trhs[v17].level = 1;
              trhs[n_trhs].kind = OPERATOR;
              if ( v8 == 1 )
                trhs[n_trhs].token.variable = 2;
              else
                trhs[n_trhs].token.variable = 1;
              memmove(&trhs[++n_trhs], tlhs, 16 * n_tlhs);
              v19 = n_trhs;
              v20 = n_tlhs + n_trhs;
              n_trhs = v20;
              if ( v19 < v20 )
              {
                v21 = v19;
                do
                {
                  ++trhs[v21].level;
                  ++v19;
                  v20 = n_trhs;
                  ++v21;
                }
                while ( v19 < n_trhs );
              }
              trhs[v20].level = 2;
              trhs[n_trhs].kind = OPERATOR;
              trhs[n_trhs].token.variable = 3;
              v22 = n_trhs + 1;
              n_trhs = v22;
              memmove(&trhs[v22], divisor, 16 * v36);
              n_trhs += v36;
              trhs[n_trhs++] = zero_token;
              memmove(&trhs[n_trhs], (const void *)(16 * (v36 + v35) + 135718304), 16 * (n_divisor - (v36 + v35)));
              v23 = n_divisor + n_trhs - v36 - v35;
              n_trhs = v23;
              if ( v22 < v23 )
              {
                v24 = v22;
                do
                {
                  trhs[v24].level += 2;
                  ++v22;
                  v23 = n_trhs;
                  ++v24;
                }
                while ( v22 < n_trhs );
              }
              list_debug(3, trhs, v23, 0, 0);
              uf_repeat(trhs, &n_trhs);
              uf_tsimp(trhs, &n_trhs);
              list_debug(4, trhs, n_trhs, 0, 0);
              v25 = find_greatest_power(trhs, n_trhs, vp, &v31, tp1, &lentp1, &dcodep);
              if ( v32 > (long double)v31 )
              {
                memmove(tlhs, quotient, 16 * n_quotient);
                n_tlhs = n_quotient;
                list_debug(3, tlhs, n_quotient, 0, 0);
                list_debug(3, trhs, n_trhs, 0, 0);
                if ( n_trhs != 1 || trhs->kind || (v6 = 2, trhs->token.constant != 0.0) )
                {
                  v6 = 1;
                  if ( v28 + v27 <= n_quotient + n_trhs )
                  {
                    if ( v28 + v27 >= n_trhs + 1 || (v6 = -2, n_trhs <= n_divisor) )
                      v6 = -1;
                  }
                }
                goto LABEL_69;
              }
              if ( pp1 <= (long double)v31 )
              {
                if ( v31 > (long double)pp1 || v25 >= v7 )
                  break;
              }
              else
              {
                pp1 = v31;
              }
              v7 = v25;
            }
          }
        }
      }
    }
    v6 = 0;
LABEL_69:
    memmove(jmp_save, save_save, 0x9Cu);
    partial_flag = old_partial;
  }
  return v6;
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049244: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 816E598: using guessed type int dword_816E598[];

//----- (08065A2E) --------------------------------------------------------
int __usercall do_gcd@<eax>(int *vp@<eax>)
{
  int i; // ebx
  int v3; // eax
  int v4; // eax

  for ( i = 1; i != 50; ++i )
  {
    v3 = poly_div(trhs, n_trhs, gcd_divisor, len_d, vp);
    if ( !v3 )
      break;
    if ( v3 == 2 )
      return i;
    if ( len_d > n_tokens )
      break;
    if ( n_trhs > 30000 )
      break;
    memmove(scratch, trhs, 16 * n_trhs);
    memmove(trhs, gcd_divisor, 16 * len_d);
    __memmove_chk(gcd_divisor, scratch, 16 * n_trhs, 480000);
    v4 = n_trhs;
    n_trhs = len_d;
    len_d = v4;
  }
  return 0;
}
// 8049244: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08065B31) --------------------------------------------------------
int __usercall pdiv_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int code)
{
  int v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int *v11; // ebx
  int v12; // esi
  int v13; // ebx
  int v14; // eax
  int v15; // esi
  int v16; // edx
  int v17; // edx
  token_type *v18; // edi
  int v19; // ecx
  token_type *v20; // eax
  int v21; // eax
  token_type *v22; // edi
  int v23; // ecx
  token_type *v24; // edx
  int v25; // eax
  int v26; // edi
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // ebx
  int v33; // eax
  int v34; // ebx
  _BOOL4 v35; // eax
  int v36; // ebx
  int v37; // edx
  int v38; // eax
  int v39; // esi
  int v40; // edx
  int *v41; // eax
  token_type *v42; // ebx
  int v43; // eax
  int v44; // ebx
  int v45; // ebx
  int v47; // ebx
  int v48; // eax
  int *v49; // edx
  int v50; // ebx
  int v51; // eax
  token_type *v53; // [esp+34h] [ebp-94h]
  token_type *v54; // [esp+38h] [ebp-90h]
  int v55; // [esp+40h] [ebp-88h]
  token_type *v58; // [esp+58h] [ebp-70h]
  int v59; // [esp+5Ch] [ebp-6Ch]
  token_type *dest; // [esp+60h] [ebp-68h]
  int real_len1; // [esp+64h] [ebp-64h]
  int v62; // [esp+68h] [ebp-60h]
  int j; // [esp+6Ch] [ebp-5Ch]
  int ja; // [esp+6Ch] [ebp-5Ch]
  token_type *v65; // [esp+70h] [ebp-58h]
  int v66; // [esp+74h] [ebp-54h]
  token_type *v67; // [esp+78h] [ebp-50h]
  int len2; // [esp+80h] [ebp-48h]
  token_type *v70; // [esp+84h] [ebp-44h]
  int v71; // [esp+88h] [ebp-40h]
  token_type *d1; // [esp+8Ch] [ebp-3Ch]
  token_type *d2; // [esp+90h] [ebp-38h]
  int flag; // [esp+94h] [ebp-34h]
  int flaga; // [esp+94h] [ebp-34h]
  int op; // [esp+98h] [ebp-30h]
  char opa; // [esp+98h] [ebp-30h]
  int v78; // [esp+9Ch] [ebp-2Ch]
  int v[7]; // [esp+ACh] [ebp-1Ch] BYREF

  v5 = level;
  v6 = loc + 1;
  v7 = *np;
  if ( loc + 1 < *np )
  {
    dest = &equation[v6];
    v8 = dest->level;
    if ( level <= v8 )
    {
      v54 = &equation[loc];
      v65 = v54 + 5;
      v66 = ~v6;
      v70 = v54 + 3;
      v71 = loc + 1;
      v53 = &equation[v6];
      v9 = loc + 1;
      do
      {
        if ( v8 == level && dest->token.variable == 4 )
        {
          v10 = v71 + 2;
          v55 = v71 + 2;
          if ( v7 <= v71 + 2 || level >= v70->level )
          {
            v10 = v71 + 2;
          }
          else
          {
            v11 = &v65->level;
            do
            {
              v10 += 2;
              if ( v10 >= v7 )
                break;
              v12 = *v11;
              v11 += 8;
            }
            while ( level < v12 );
          }
          v13 = *np;
          if ( loc < *np )
          {
            v14 = v54->level;
            if ( level <= v14 )
            {
              real_len1 = v66 + v10;
              d2 = &equation[v9 + 1];
              v67 = v53;
              v58 = v54 + 3;
              d1 = v54;
              v15 = v66 + v10;
              j = loc;
              v16 = 0;
              do
              {
                if ( level == v14 && d1->kind == OPERATOR )
                {
                  v16 = d1->token.variable;
                }
                else if ( v16 != 4 )
                {
                  v17 = j + 1;
                  if ( v13 > j + 1 )
                  {
                    v18 = v67;
                    v19 = v67->level;
                    if ( level < v19 )
                    {
                      v20 = v58;
                      op = 0;
                      do
                      {
                        if ( v19 == level + 1 )
                          op = v18->token.variable;
                        v17 += 2;
                        if ( v17 >= v13 )
                          break;
                        v18 = v20;
                        v19 = v20->level;
                        v20 += 2;
                      }
                      while ( level < v19 );
                      if ( (unsigned int)(op - 1) <= 1 )
                      {
                        len2 = v17 - j;
                        if ( v13 <= v55 )
                          goto LABEL_43;
                        v21 = v70->level;
                        if ( level >= v21 )
                          goto LABEL_43;
                        v22 = v70;
                        v23 = v71 + 2;
                        flag = 0;
                        v62 = 0;
                        v24 = v65;
                        while ( 1 )
                        {
                          if ( v21 == level + 3 )
                          {
                            v25 = 1;
                            if ( (unsigned int)(v22->token.variable - 1) > 1 )
                              v25 = flag;
                            flag = v25;
                          }
                          else if ( v21 == level + 2 )
                          {
                            v62 = v22->token.variable;
                          }
                          else if ( v21 == level + 1 )
                          {
                            if ( v22->token.variable == 6 && ((unsigned int)(v62 - 1) <= 1 || v62 == 3 && flag == 1) )
                            {
                              v15 = v23 + v66;
                              v26 = 1;
                              goto LABEL_44;
                            }
LABEL_43:
                            v26 = 0;
LABEL_44:
                            for ( flaga = code; ; flaga = code == 0 )
                            {
                              while ( 2 )
                              {
                                if ( !v26 )
                                  v15 = real_len1;
                                v[0] = 0;
                                if ( v26 | flaga )
                                  v27 = poly_div(d1, len2, d2, v15, v);
                                else
                                  v27 = smart_div(d1, len2, d2, v15);
                                if ( v27 > 0 && n_trhs == 1 && trhs->kind == CONSTANT )
                                {
                                  opa = v26;
                                  if ( trhs->token.constant == 0.0 )
                                    goto LABEL_60;
                                }
                                opa = v26;
                                if ( (_BYTE)v26 )
                                  goto LABEL_48;
                                if ( v27 > 0 )
                                {
LABEL_60:
                                  if ( v15 + n_trhs + n_tlhs + 2 > n_tokens )
                                    error_huge();
                                  v28 = n_tlhs;
                                  if ( n_tlhs > 0 )
                                  {
                                    v29 = 0;
                                    do
                                    {
                                      ++tlhs[v29++].level;
                                      v28 = n_tlhs;
                                    }
                                    while ( n_tlhs > v29 );
                                  }
                                  tlhs[v28].level = 1;
                                  tlhs[n_tlhs].kind = OPERATOR;
                                  tlhs[n_tlhs++].token.variable = 1;
                                  v30 = n_trhs;
                                  if ( n_trhs > 0 )
                                  {
                                    v31 = 0;
                                    do
                                    {
                                      trhs[v31++].level += 2;
                                      v30 = n_trhs;
                                    }
                                    while ( n_trhs > v31 );
                                  }
                                  memmove(&tlhs[n_tlhs], trhs, 16 * v30);
                                  n_tlhs += n_trhs;
                                  tlhs[n_tlhs].level = 2;
                                  tlhs[n_tlhs].kind = OPERATOR;
                                  tlhs[n_tlhs].token.variable = 4;
                                  v32 = n_tlhs + 1;
                                  n_tlhs = v32;
                                  memmove(&tlhs[v32], d2, 16 * v15);
                                  n_tlhs += v15;
                                  if ( v32 < n_tlhs )
                                  {
                                    v33 = v32;
                                    do
                                    {
                                      tlhs[v33].level += 2;
                                      ++v32;
                                      ++v33;
                                    }
                                    while ( n_tlhs > v32 );
                                  }
                                  list_debug(3, d1, len2, 0, 0);
                                  list_debug(3, d2, v15, 0, 0);
                                  simpb_side(tlhs, &n_tlhs, 0, 1, 3);
                                  list_debug(3, tlhs, n_tlhs, 0, 0);
                                  if ( opa )
                                  {
                                    v34 = var_count(tlhs, n_tlhs);
                                    v35 = v34 <= var_count(d1, len2);
                                  }
                                  else
                                  {
                                    v59 = var_count(tlhs, n_tlhs) + (v15 + len2 + 1 <= n_tlhs);
                                    v36 = var_count(d1, len2);
                                    v35 = v59 <= v36 + var_count(d2, v15);
                                  }
                                  if ( v35 )
                                  {
                                    v37 = n_tlhs;
                                    if ( n_tlhs > 0 )
                                    {
                                      v38 = 0;
                                      do
                                      {
                                        tlhs[v38++].level += level;
                                        v37 = n_tlhs;
                                      }
                                      while ( n_tlhs > v38 );
                                    }
                                    if ( opa )
                                    {
                                      if ( v37 - len2 + *np + 2 > n_tokens )
                                        error_huge();
                                      v39 = v55 + v15;
                                      v40 = v71 + real_len1;
                                      if ( v39 <= v71 + real_len1 )
                                      {
                                        v41 = &equation[v39].level;
                                        do
                                        {
                                          ++*v41;
                                          ++v39;
                                          v41 += 4;
                                        }
                                        while ( v39 <= v40 );
                                      }
                                      v42 = &equation[v39];
                                      memmove(&equation[v40 + 3], v42, 16 * (*np - v39));
                                      *np += 2;
                                      v42->level = level + 2;
                                      v42->kind = OPERATOR;
                                      v42->token.variable = 2;
                                      v42[1].level = level + 2;
                                      v42[1].kind = CONSTANT;
                                      v42[1].token.constant = 1.0;
                                      v43 = j + 2;
                                      if ( v71 >= j )
                                        v43 = j;
                                      ja = v43;
                                    }
                                    else
                                    {
                                      v44 = ~v15;
                                      if ( v37 + *np + ~v15 - len2 > n_tokens )
                                        error_huge();
                                      memmove(dest, &equation[v71 + 1 + v15], 16 * (*np + v66 - v15));
                                      *np += v44;
                                      v45 = j + v44;
                                      if ( v71 >= j )
                                        v45 = j;
                                      ja = v45;
                                    }
                                    memmove(&equation[n_tlhs + ja], &equation[len2 + ja], 16 * (*np - (len2 + ja)));
                                    *np = n_tlhs + *np - len2;
                                    memmove(&equation[ja], tlhs, 16 * n_tlhs);
                                    if ( v26 | flaga )
                                    {
                                      if ( debug_level > 0 )
                                        __fprintf_chk(gfp, 1, "%s\n", "Polynomial division successful.");
                                    }
                                    else if ( debug_level > 0 )
                                    {
                                      __fprintf_chk(gfp, 1, "%s\n", "Smart division successful.");
                                    }
                                    list_debug(3, equation, *np, 0, 0);
                                    return 1;
                                  }
                                }
                                if ( opa )
                                {
LABEL_48:
                                  v26 = 0;
                                  continue;
                                }
                                break;
                              }
                              if ( flaga != code )
                                goto LABEL_101;
                            }
                          }
                          v23 += 2;
                          if ( v23 < v13 )
                          {
                            v22 = v24;
                            v21 = v24->level;
                            v24 += 2;
                            if ( level < v21 )
                              continue;
                          }
                          goto LABEL_43;
                        }
                      }
                    }
                  }
LABEL_101:
                  v16 = 4;
                }
                ++j;
                v13 = *np;
                if ( *np <= j )
                  break;
                d1 = v67;
                v14 = v67->level;
                ++v67;
                ++v58;
              }
              while ( level <= v14 );
            }
          }
        }
        v71 += 2;
        v7 = *np;
        if ( *np <= v71 )
        {
          v5 = level;
          goto LABEL_106;
        }
        v9 = v71;
        dest = v70;
        v8 = v70->level;
        v70 += 2;
        v65 += 2;
        v66 -= 2;
      }
      while ( v8 >= level );
      v5 = level;
    }
  }
LABEL_106:
  v47 = loc;
  v78 = 0;
  while ( v47 < *np )
  {
    v51 = equation[v47].level;
    if ( v5 > v51 )
      return v78;
    if ( v5 >= v51 )
    {
      v48 = v47 + 1;
    }
    else
    {
      v78 |= pdiv_recurse(equation, np, v47, v5 + 1, code);
      v48 = v47 + 1;
      if ( *np > v47 + 1 && v5 < equation[v48].level )
      {
        v49 = &equation[v47 + 3].level;
        do
        {
          v48 += 2;
          if ( *np <= v48 )
            break;
          v50 = *v49;
          v49 += 8;
        }
        while ( v5 < v50 );
      }
    }
    v47 = v48;
  }
  return v78;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080664F4) --------------------------------------------------------
int __cdecl div_remainder(token_type *equation, int *np, int poly_flag, int quick_flag)
{
  int v4; // ebx

  if ( !quick_flag )
    return pdiv_recurse(equation, np, 0, 1, poly_flag);
  group_proc(equation, np);
  v4 = pdiv_recurse(equation, np, 0, 1, poly_flag);
  organize(equation, np);
  return v4;
}

//----- (08066571) --------------------------------------------------------
int __usercall mod_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level)
{
  int v4; // ebx
  int v6; // eax
  int *v7; // edx
  int v8; // ebx
  int v9; // edx
  int v10; // eax
  int result; // eax
  int v12; // edi
  token_type *v13; // ebx
  int v14; // ecx
  int v15; // esi
  int v16; // eax
  int *v17; // ecx
  int v18; // ebx
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  int v22; // edx
  token_type *v23; // eax
  token_type *v24; // esi
  int v25; // ebx
  int v26; // edi
  int v27; // esi
  int *v28; // ebx
  int v29; // edi
  int v30; // ebx
  token_type *v31; // esi
  int v32; // edx
  int v33; // edx
  int v34; // edi
  int *v35; // esi
  int v36; // eax
  int v37; // ebx
  int *v38; // edx
  int v39; // ecx
  int v40; // eax
  int v41; // edx
  token_type *v42; // [esp+2Ch] [ebp-BCh]
  int len2; // [esp+38h] [ebp-B0h]
  int v44; // [esp+3Ch] [ebp-ACh]
  token_type *d1; // [esp+4Ch] [ebp-9Ch]
  int v46; // [esp+50h] [ebp-98h]
  token_type *v47; // [esp+54h] [ebp-94h]
  int *v48; // [esp+60h] [ebp-88h]
  int v49; // [esp+64h] [ebp-84h]
  int j; // [esp+68h] [ebp-80h]
  token_type *v51; // [esp+6Ch] [ebp-7Ch]
  int v52; // [esp+70h] [ebp-78h]
  token_type *p1; // [esp+74h] [ebp-74h]
  int len1; // [esp+78h] [ebp-70h]
  int v55; // [esp+7Ch] [ebp-6Ch]
  int v56; // [esp+80h] [ebp-68h]
  int i3; // [esp+88h] [ebp-60h]
  token_type *v58; // [esp+90h] [ebp-58h]
  int v59; // [esp+94h] [ebp-54h]
  token_type *v61; // [esp+A4h] [ebp-44h]
  int v62; // [esp+A8h] [ebp-40h]
  int v63; // [esp+ACh] [ebp-3Ch]
  int *v64; // [esp+B0h] [ebp-38h]
  int *v65; // [esp+B0h] [ebp-38h]
  int dest; // [esp+B4h] [ebp-34h]
  token_type *v67; // [esp+B8h] [ebp-30h]
  token_type *v68; // [esp+B8h] [ebp-30h]
  int p2; // [esp+BCh] [ebp-2Ch]
  token_type *p2a; // [esp+BCh] [ebp-2Ch]
  int p2b; // [esp+BCh] [ebp-2Ch]
  int v; // [esp+C8h] [ebp-20h] BYREF
  int diff_sign[7]; // [esp+CCh] [ebp-1Ch] BYREF

  v61 = equation;
  v46 = loc;
  v4 = loc;
  v49 = 0;
  while ( 1 )
  {
    v9 = *np;
    if ( v4 >= *np )
      break;
    v10 = equation[v4].level;
    if ( v10 < level )
      break;
    if ( v10 <= level )
    {
      v6 = v4 + 1;
    }
    else
    {
      v49 |= mod_recurse(equation, np, v4, level + 1);
      v6 = v4 + 1;
      if ( v4 + 1 < *np && level < equation[v6].level )
      {
        v7 = &equation[v4 + 3].level;
        do
        {
          v6 += 2;
          if ( v6 >= *np )
            break;
          v8 = *v7;
          v7 += 8;
        }
        while ( level < v8 );
      }
    }
    v4 = v6;
  }
  result = v49;
  if ( v49 )
    return 1;
  v12 = v46 + 1;
  if ( v46 + 1 < v9 )
  {
    v13 = &v61[v12];
    v14 = v13->level;
    if ( level <= v14 )
    {
      v59 = v46 + 3;
      v56 = ~v12;
      v55 = (int)&v61[v46 + 5];
      v58 = &v61[v46 + 3];
      v42 = &v61[v12];
      v62 = level + 2;
      v15 = v46 + 1;
      while ( 1 )
      {
        if ( level == v14 && v13->token.variable == 5 )
        {
          v16 = v59;
          if ( v9 > v59 && level < v58->level )
          {
            v17 = (int *)(v55 + 4);
            do
            {
              v16 += 2;
              if ( v16 >= v9 )
                break;
              v18 = *v17;
              v17 += 8;
            }
            while ( level < v18 );
          }
          len1 = v56 + v16;
          v19 = *np;
          if ( v46 < *np )
          {
            v20 = v61[v46].level;
            if ( level <= v20 )
              break;
          }
        }
LABEL_101:
        v9 = *np;
        if ( *np <= v59 )
          return 0;
        v13 = v58;
        v14 = v58->level;
        v58 += 2;
        v56 -= 2;
        v55 += 32;
        if ( level > v14 )
          return 0;
        v15 = v59;
        v59 += 2;
      }
      p1 = &v61[v15 + 1];
      v51 = v42;
      v47 = &v61[v46 + 3];
      d1 = &v61[v46];
      j = v46;
      v21 = 0;
      v44 = level + 1;
      while ( 1 )
      {
        if ( level == v20 && d1->kind == OPERATOR )
        {
          v21 = d1->token.variable;
        }
        else if ( v21 != 5 )
        {
          v67 = (token_type *)(j + 1);
          if ( v19 <= j + 1 || (v22 = v51->level, level >= v22) )
          {
            len2 = 1;
          }
          else
          {
            v23 = v47;
            v24 = v51;
            v25 = j + 1;
            p2 = j + 1;
            v26 = 0;
            do
            {
              if ( v22 == level + 1 )
              {
                v26 = v24->token.variable;
                p2 = v25;
              }
              v25 += 2;
              if ( v19 <= v25 )
                break;
              v24 = v23;
              v22 = v23->level;
              v23 += 2;
            }
            while ( level < v22 );
            v52 = v25;
            len2 = v25 - j;
            if ( v26 == 3 )
            {
              if ( is_integer_expr(d1, len2) )
              {
                v64 = &v51->level;
                v27 = j + 1;
                while ( 1 )
                {
                  if ( (int)v67 >= v52 || v44 == *v64 )
                  {
                    if ( (int)v67 > v27 )
                    {
                      v28 = &v61[v27].level;
                      v29 = (int)v67 + ~v27;
                      p2a = &v61[v27 + 1];
                      do
                      {
                        if ( *v28 == v62 && v28[1] == 5 && se_compare(p1, len1, p2a, v29, diff_sign) )
                        {
                          memmove(v28 - 1, &v61[(_DWORD)v67], 16 * (*np - (_DWORD)v67));
                          *np += ~v29;
                          return 1;
                        }
                        v27 += 2;
                        v28 += 8;
                        v29 -= 2;
                        p2a += 2;
                      }
                      while ( (int)v67 > v27 );
                    }
                    if ( (int)v67 >= v52 )
                      break;
                  }
                  v67 = (token_type *)((char *)v67 + 2);
                  v64 += 8;
                }
              }
            }
            else if ( v26 > 3 )
            {
              if ( v26 == 5 && se_compare(p1, len1, &v61[p2 + 1], v25 + ~p2, diff_sign) )
              {
                memmove(&v61[p2], &v61[v25], 16 * (*np - v25));
                *np += ~(v25 + ~p2);
                return 1;
              }
            }
            else if ( v26 >= 1 )
            {
              i3 = j - 1;
              v48 = &v51->level;
              v30 = j + 1;
              for ( p2b = j + 1; ; p2b += 2 )
              {
                if ( p2b >= v52 || v44 == *v48 )
                {
                  for ( ; p2b > v30; v30 += 2 )
                  {
                    v31 = &v61[v30];
                    if ( v31->level == v62 )
                    {
                      v32 = v31->token.variable;
                      if ( v32 == 3 )
                      {
                        v30 = p2b - 2;
                        if ( is_integer_expr(&v61[i3 + 1], p2b + ~i3) )
                        {
                          v33 = i3 + 2;
                          if ( p2b > i3 + 2 )
                          {
                            v34 = i3 + 4;
                            v35 = &v61[v33].level;
                            dest = ~v33;
                            v68 = &v61[i3 + 3];
                            v65 = &v61[i3 + 4].level;
                            v63 = (int)&v61[i3 + 6];
                            do
                            {
                              v36 = *v35;
                              if ( *v35 == level + 3 && v35[1] == 5 )
                              {
                                v37 = v34;
                                if ( p2b > v34 && *v65 > v36 )
                                {
                                  v38 = (int *)(v63 + 4);
                                  do
                                  {
                                    v37 += 2;
                                    if ( p2b <= v37 )
                                      break;
                                    v39 = *v38;
                                    v38 += 8;
                                  }
                                  while ( v36 < v39 );
                                }
                                if ( se_compare(p1, len1, v68, v37 + dest, diff_sign) )
                                {
                                  memmove(v35 - 1, &v61[v37], 16 * (*np - v37));
                                  *np += ~(v37 + dest);
                                  return 1;
                                }
                              }
                              v34 += 2;
                              v35 += 8;
                              dest -= 2;
                              v68 += 2;
                              v65 += 8;
                              v63 += 32;
                            }
                            while ( p2b > v34 - 2 );
                            v30 = p2b - 2;
                          }
                        }
                      }
                      else if ( v32 == 5 && se_compare(p1, len1, &v61[v30 + 1], ~v30 + p2b, diff_sign) )
                      {
                        memmove(v31, &v61[p2b], 16 * (*np - p2b));
                        *np += ~(~v30 + p2b);
                        return 1;
                      }
                    }
                  }
                  if ( p2b >= v52 )
                    break;
                  i3 = p2b;
                }
                v48 += 8;
              }
            }
          }
          v = 0;
          if ( poly_div(d1, len2, p1, len1, &v) )
          {
            uf_pplus(tlhs, &n_tlhs);
            if ( is_integer_expr(tlhs, n_tlhs) )
            {
              if ( n_trhs + *np - len2 > n_tokens )
                error_huge();
              v40 = n_trhs;
              if ( n_trhs > 0 )
              {
                v41 = 0;
                do
                {
                  trhs[v41++].level += level;
                  v40 = n_trhs;
                }
                while ( n_trhs > v41 );
              }
              memmove(&v61[j + v40], &v61[j + len2], 16 * (*np - (j + len2)));
              *np = n_trhs + *np - len2;
              memmove(d1, trhs, 16 * n_trhs);
              return 1;
            }
          }
          v21 = 5;
        }
        ++j;
        v19 = *np;
        if ( *np > j )
        {
          d1 = v51;
          v20 = v51->level;
          ++v51;
          ++v47;
          if ( level <= v20 )
            continue;
        }
        goto LABEL_101;
      }
    }
  }
  return result;
}

//----- (08066DDE) --------------------------------------------------------
int __cdecl mod_simp(token_type *equation, int *np)
{
  return mod_recurse(equation, np, 0, 1);
}

//----- (08066DFD) --------------------------------------------------------
int __cdecl poly_gcd(token_type *larger, int llen, token_type *smaller, int slen, int v)
{
  int v5; // eax
  int v6; // eax
  int v7; // ebx

  v5 = n_tokens;
  if ( n_tokens < llen )
    return 0;
  if ( n_tokens > 30000 )
    v5 = 30000;
  if ( v5 < slen )
    return 0;
  memmove(trhs, larger, 16 * llen);
  n_trhs = llen;
  memmove(tlhs, smaller, 16 * slen);
  n_tlhs = slen;
  if ( !remove_factors() || n_tlhs > 30000 )
    return 0;
  __memmove_chk(gcd_divisor, tlhs, 16 * n_tlhs, 480000);
  len_d = n_tlhs;
  v6 = do_gcd(&v);
  v7 = v6;
  if ( v6 )
  {
    if ( v6 > 1 )
    {
      if ( len_d > n_tokens )
        return 0;
      memmove(tlhs, gcd_divisor, 16 * len_d);
      n_tlhs = len_d;
      if ( !remove_factors() || n_tlhs > 30000 )
        return 0;
      __memmove_chk(gcd_divisor, tlhs, 16 * n_tlhs, 480000);
      len_d = n_tlhs;
      if ( poly_div(larger, llen, gcd_divisor, n_tlhs, &v) != 2 )
      {
        if ( debug_level > 0 )
        {
          __fprintf_chk(gfp, 1, "%s\n", "Polynomial GCD found, but larger divide failed in poly_gcd().");
          return 0;
        }
        return 0;
      }
    }
    if ( len_d > n_tokens )
      return 0;
    memmove(trhs, gcd_divisor, 16 * len_d);
    n_trhs = len_d;
    uf_simp(tlhs, &n_tlhs);
    uf_simp(trhs, &n_trhs);
    if ( debug_level > 2 )
      __fprintf_chk(gfp, 1, "%s\n", "poly_gcd() successful.");
  }
  return v7;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049244: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08067067) --------------------------------------------------------
int __cdecl poly2_gcd(token_type *larger, int llen, token_type *smaller, int slen, int v)
{
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // ebx
  jmp_buf save_save; // [esp+24h] [ebp-A4h] BYREF

  if ( debug_level > 2 )
    __fprintf_chk(gfp, 1, "%s\n", "Entering poly2_gcd():");
  list_debug(3, larger, llen, 0, 0);
  list_debug(3, smaller, slen, 0, 0);
  v5 = n_tokens;
  if ( llen > n_tokens )
    return 0;
  if ( n_tokens > 30000 )
    v5 = 30000;
  if ( slen > v5 )
    return 0;
  memmove(trhs, larger, 16 * llen);
  n_trhs = llen;
  memmove(tlhs, smaller, 16 * slen);
  n_tlhs = slen;
  memmove(save_save, jmp_save, 0x9Cu);
  v6 = _setjmp(jmp_save);
  if ( v6 )
  {
    memmove(jmp_save, save_save, 0x9Cu);
    if ( v6 == 13 )
      __longjmp_chk(jmp_save, 13);
    return 0;
  }
  uf_simp(tlhs, &n_tlhs);
  memmove(jmp_save, save_save, 0x9Cu);
  if ( !level1_plus_count(tlhs, n_tlhs) || n_tlhs > 30000 )
    return 0;
  __memmove_chk(gcd_divisor, tlhs, 16 * n_tlhs, 480000);
  len_d = n_tlhs;
  v7 = do_gcd(&v);
  v8 = v7;
  if ( v7 )
  {
    if ( v7 <= 1 )
    {
      n_trhs = 1;
      *trhs = one_token;
    }
    else
    {
      if ( !level1_plus_count(gcd_divisor, len_d) )
        return 0;
      if ( poly_div(smaller, slen, gcd_divisor, len_d, &v) != 2 )
      {
        if ( debug_level > 0 )
        {
          __fprintf_chk(gfp, 1, "%s\n", "Polynomial GCD found, but smaller divide failed in poly2_gcd().");
          return 0;
        }
        return 0;
      }
      memmove(trhs, gcd_divisor, 16 * len_d);
      n_trhs = len_d;
      if ( n_tlhs > 30000 )
        return 0;
      __memmove_chk(gcd_divisor, tlhs, 16 * n_tlhs, 480000);
      len_d = n_tlhs;
      memmove(tlhs, trhs, 16 * n_trhs);
      n_tlhs = n_trhs;
      if ( poly_div(larger, llen, tlhs, n_trhs, &v) != 2 )
      {
        if ( debug_level > 0 )
        {
          __fprintf_chk(gfp, 1, "%s\n", "Polynomial GCD found, but larger divide failed in poly2_gcd().");
          return 0;
        }
        return 0;
      }
      memmove(trhs, gcd_divisor, 16 * len_d);
      n_trhs = len_d;
    }
    if ( debug_level > 2 )
      __fprintf_chk(gfp, 1, "%s\n", "poly2_gcd() successful.");
  }
  return v8;
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049244: using guessed type int __cdecl __memmove_chk(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806749B) --------------------------------------------------------
int __usercall polydiv_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level)
{
  int v4; // esi
  int v6; // eax
  int *v7; // edx
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int v11; // edx
  token_type *v12; // ecx
  int v13; // edx
  int *v14; // ecx
  int v15; // esi
  int v16; // edi
  int v17; // eax
  token_type *v18; // esi
  int v19; // edx
  int v20; // eax
  int *v21; // edx
  int v22; // ecx
  int v23; // edi
  int v24; // eax
  int v25; // edx
  int v26; // eax
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v31; // [esp+38h] [ebp-50h]
  int modified; // [esp+3Ch] [ebp-4Ch]
  int v33; // [esp+40h] [ebp-48h]
  token_type *v34; // [esp+44h] [ebp-44h]
  token_type *larger; // [esp+48h] [ebp-40h]
  int llen; // [esp+4Ch] [ebp-3Ch]
  int v37; // [esp+50h] [ebp-38h]
  int v38; // [esp+54h] [ebp-34h]
  int v39; // [esp+58h] [ebp-30h]
  token_type *smaller; // [esp+5Ch] [ebp-2Ch]
  int v42; // [esp+64h] [ebp-24h]
  int v43; // [esp+68h] [ebp-20h]
  int j; // [esp+6Ch] [ebp-1Ch]
  int ja; // [esp+6Ch] [ebp-1Ch]

  v34 = equation;
  v33 = loc;
  v4 = loc;
  modified = 0;
  while ( v4 < *np )
  {
    v9 = equation[v4].level;
    if ( v9 < level )
      break;
    if ( v9 <= level )
    {
      v6 = v4 + 1;
    }
    else
    {
      modified |= polydiv_recurse(equation, np, v4, level + 1);
      v6 = v4 + 1;
      if ( v4 + 1 < *np && level < equation[v6].level )
      {
        v7 = &equation[v4 + 3].level;
        do
        {
          v6 += 2;
          if ( v6 >= *np )
            break;
          v8 = *v7;
          v7 += 8;
        }
        while ( level < v8 );
      }
    }
    v4 = v6;
  }
  v31 = v33 + 1;
  while ( 1 )
  {
    v10 = *np;
    if ( v31 >= *np )
      return modified;
    v11 = v34[v33 + 1].level;
    if ( level > v11 )
      return modified;
    v38 = ~(v33 + 1);
    v37 = (int)&v34[v33 + 5];
    v42 = (int)&v34[v33 + 3];
    v12 = &v34[v33 + 1];
    j = v33 + 1;
    v43 = v33 + 1;
    while ( 1 )
    {
      if ( level == v11 && v12->token.variable == 4 )
      {
        v13 = v43 + 2;
        if ( v10 > v43 + 2 && level < *(_DWORD *)(v42 + 4) )
        {
          v14 = (int *)(v37 + 4);
          do
          {
            v13 += 2;
            if ( v13 >= v10 )
              break;
            v15 = *v14;
            v14 += 8;
          }
          while ( level < v15 );
        }
        llen = v38 + v13;
        v16 = *np;
        if ( v33 < *np )
        {
          v17 = v34[v33].level;
          if ( level <= v17 )
            break;
        }
      }
LABEL_55:
      v43 += 2;
      v10 = *np;
      if ( *np > v43 )
      {
        j = v43;
        v12 = (token_type *)v42;
        v11 = *(_DWORD *)(v42 + 4);
        v42 += 32;
        v38 -= 2;
        v37 += 32;
        if ( level <= v11 )
          continue;
      }
      return modified;
    }
    larger = &v34[j + 1];
    v18 = &v34[v31];
    v39 = (int)&v34[v33 + 3];
    smaller = &v34[v33];
    ja = v33;
    v19 = 0;
    while ( 1 )
    {
      if ( level == v17 && smaller->kind == OPERATOR )
      {
        v19 = smaller->token.variable;
        goto LABEL_53;
      }
      if ( v19 != 4 )
        break;
LABEL_53:
      ++ja;
      v16 = *np;
      if ( *np > ja )
      {
        smaller = v18;
        v17 = v18->level;
        ++v18;
        v39 += 16;
        if ( level <= v17 )
          continue;
      }
      goto LABEL_55;
    }
    v20 = ja + 1;
    if ( v16 > ja + 1 && level < v18->level )
    {
      v21 = (int *)(v39 + 4);
      do
      {
        v20 += 2;
        if ( v16 <= v20 )
          break;
        v22 = *v21;
        v21 += 8;
      }
      while ( level < v22 );
    }
    v23 = v20 - ja;
    if ( poly2_gcd(larger, llen, smaller, v20 - ja, 0) )
      goto store_code;
    if ( !poly2_gcd(smaller, v23, larger, llen, 0) )
    {
      v19 = 4;
      goto LABEL_53;
    }
    v28 = ja - 1;
    ja = v43 + 1;
    v29 = llen;
    llen = v23;
    v23 = v29;
    v43 = v28;
store_code:
    if ( n_tlhs > 0 )
    {
      v24 = 0;
      do
        tlhs[v24++].level += level;
      while ( n_tlhs > v24 );
    }
    v25 = n_trhs;
    if ( n_trhs > 0 )
    {
      v26 = 0;
      do
      {
        trhs[v26++].level += level;
        v25 = n_trhs;
      }
      while ( n_trhs > v26 );
    }
    v27 = *np + v25 - v23;
    if ( v27 > n_tokens || n_tokens < n_tlhs + v27 - llen )
      error_huge();
    memmove(&v34[n_trhs + ja], &v34[v23 + ja], 16 * (*np - (v23 + ja)));
    *np = n_trhs + *np - v23;
    if ( v43 > ja )
      v43 = n_trhs + v43 - v23;
    memmove(&v34[ja], trhs, 16 * n_trhs);
    memmove(&v34[n_tlhs + 1 + v43], &v34[v43 + 1 + llen], 16 * (*np - llen + ~v43));
    *np = n_tlhs + *np - llen;
    memmove(&v34[v43 + 1], tlhs, 16 * n_tlhs);
    modified = 1;
    if ( debug_level > 0 )
    {
      __fprintf_chk(gfp, 1, "%s\n", "Division simplified with polynomial GCD.");
      modified = 1;
    }
  }
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08067912) --------------------------------------------------------
int __cdecl poly_gcd_simp(token_type *equation, int *np)
{
  return polydiv_recurse(equation, np, 0, 1);
}

//----- (08067931) --------------------------------------------------------
int __usercall pf_sub@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int len, int level, int do_repeat)
{
  int v6; // edi
  int l; // ebx
  int v8; // ecx
  int v9; // edx
  token_type *v10; // eax
  int v11; // ebx
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // eax
  int v17; // esi
  token_type *v18; // eax
  int i; // edx
  int v20; // ecx
  int v21; // ebx
  int v22; // eax
  int v23; // edx
  int v24; // edx
  int v25; // ebx
  int loc2; // [esp+28h] [ebp-2070h]
  int len_first; // [esp+2Ch] [ebp-206Ch]
  int old_partial; // [esp+30h] [ebp-2068h]
  token_type *p1; // [esp+3Ch] [ebp-205Ch]
  int modified; // [esp+40h] [ebp-2058h]
  int v34; // [esp+48h] [ebp-2050h]
  int v35; // [esp+50h] [ebp-2048h]
  token_type *src; // [esp+58h] [ebp-2040h]
  int loc1; // [esp+5Ch] [ebp-203Ch]
  token_type *v39; // [esp+64h] [ebp-2034h]
  int v40; // [esp+68h] [ebp-2030h]
  int cnt; // [esp+6Ch] [ebp-202Ch]
  int v42; // [esp+70h] [ebp-2028h]
  int v43; // [esp+74h] [ebp-2024h]
  int vc; // [esp+7Ch] [ebp-201Ch]
  sort_type va[1000]; // [esp+8Ch] [ebp-200Ch] BYREF
  jmp_buf save_save; // [esp+1FCCh] [ebp-CCh] BYREF
  double d; // [esp+2068h] [ebp-30h] BYREF
  int div_flag; // [esp+2070h] [ebp-28h] BYREF
  int v; // [esp+2074h] [ebp-24h] BYREF
  int k; // [esp+2078h] [ebp-20h] BYREF
  int j[7]; // [esp+207Ch] [ebp-1Ch] BYREF

  v = 0;
  div_flag = 3;
  if ( debug_level > 2 )
    __fprintf_chk(gfp, 1, "%s\n", "Entering pf_sub().");
  old_partial = partial_flag;
  p1 = &equation[loc];
  find_greatest_power(p1, len, &v, &d, j, &k, &div_flag);
  if ( !v )
    return 0;
  memmove(save_save, jmp_save, 0x9Cu);
  v40 = _setjmp(jmp_save);
  if ( v40 )
  {
    partial_flag = old_partial;
    memmove(jmp_save, save_save, 0x9Cu);
    if ( v40 == 13 )
      __longjmp_chk(jmp_save, 13);
    return 0;
  }
  loc1 = loc;
  if ( !do_repeat )
  {
LABEL_62:
    v17 = 0;
LABEL_63:
    memmove(trhs, p1, 16 * len);
    n_trhs = len;
    uf_simp(trhs, &n_trhs);
    v = -1;
    if ( len > 0 )
    {
      while ( 1 )
      {
        v18 = &equation[loc];
        for ( i = 0; i < len; i += 2 )
        {
          if ( v18->kind == VARIABLE )
          {
            v20 = v18->token.variable;
            if ( v17 < v20 && (v == -1 || v20 < v) )
              v = v18->token.variable;
          }
          v18 += 2;
        }
        v17 = v;
        if ( v == -1 )
          break;
        if ( find_greatest_power(trhs, n_trhs, &v, &d, j, &k, &div_flag) > 1 )
        {
          memmove(tlhs, trhs, 16 * n_trhs);
          for ( n_tlhs = n_trhs; factor_plus(tlhs, &n_tlhs, v, 0.0); simp_loop(tlhs, &n_tlhs) )
            ;
          if ( find_greatest_power(tlhs, n_tlhs, &v, &d, j, &k, &div_flag) == 1 )
          {
            memmove(tlhs, &tlhs[j[0]], 16 * k);
            n_tlhs = k;
            if ( debug_level > 2 )
            {
              __fprintf_chk(gfp, 1, "Trying factor: ");
              list_proc(tlhs, n_tlhs, 0);
              __fprintf_chk(gfp, 1, "\n");
            }
            if ( poly_gcd(&equation[loc1], len, tlhs, n_tlhs, 0) && level1_plus_count(tlhs, n_tlhs) )
            {
              if ( debug_level > 0 )
                __fprintf_chk(gfp, 1, "%s\n", "Symbolic polynomial factored.");
              save_factors(equation, np, loc1, len, level);
              v21 = 1;
              goto LABEL_103;
            }
            goto LABEL_63;
          }
        }
        v = -1;
      }
    }
    v21 = 0;
LABEL_103:
    memmove(jmp_save, save_save, 0x9Cu);
    modified = 0;
    return v21 | modified;
  }
  loc2 = loc;
  v35 = 2;
  v34 = 0;
  len_first = 0;
  modified = 0;
LABEL_10:
  src = &equation[loc1];
  memmove(trhs, src, 16 * len);
  n_trhs = len;
  partial_flag = 0;
  uf_simp(trhs, &n_trhs);
  partial_flag = old_partial;
  if ( level1_plus_count(trhs, n_trhs) > 1 )
  {
    v6 = n_trhs;
    v39 = trhs;
    if ( n_trhs <= 0 )
    {
      vc = 0;
      goto LABEL_28;
    }
    v42 = 0;
    vc = 0;
LABEL_26:
    v10 = v39;
    v9 = 0;
    cnt = 0;
    for ( l = -1; ; l = v8 )
    {
      if ( v10->kind != VARIABLE )
        goto LABEL_20;
      v8 = v10->token.variable;
      if ( v8 <= v42 )
        goto LABEL_20;
      if ( l != -1 && v8 >= l )
        break;
      cnt = 1;
LABEL_22:
      v9 += 2;
      v10 += 2;
      if ( v9 >= v6 )
      {
        if ( v8 != -1 )
        {
          va[vc].v = v8;
          va[vc++].count = cnt;
          if ( vc != 1000 )
          {
            v42 = v8;
            goto LABEL_26;
          }
        }
LABEL_28:
        list_debug(3, src, len, 0, 0);
        list_debug(3, trhs, n_trhs, 0, 0);
        if ( v && !poly_in_v(trhs, n_trhs, v, 1) )
          v = 0;
        if ( vc <= 0 )
          goto skip_factor;
        v11 = 0;
        v43 = -1;
        do
        {
          v12 = va[v11].v;
          if ( (v12 & 0x3FFFu) > 4 )
          {
            if ( !v && poly_in_v(trhs, n_trhs, v12, 1) )
              v = v12;
            if ( v43 < 0 || v43 > va[v11].count )
              v43 = va[v11].count;
          }
          ++v11;
        }
        while ( v11 < vc );
        if ( v43 <= 1 )
          goto skip_factor;
        if ( !v )
          goto skip_factor;
        memmove(tlhs, trhs, 16 * n_trhs);
        n_tlhs = n_trhs;
        if ( !differentiate(tlhs, &n_tlhs, v) )
          goto skip_factor;
        if ( debug_level > 2 )
        {
          list_var(v, 0);
          __fprintf_chk(gfp, 1, "Differentiation successful using variable (%s).\n", var_str);
        }
        simp_loop(tlhs, &n_tlhs);
        v13 = n_tlhs;
        v14 = 30000;
        if ( n_tokens <= 30000 )
          v14 = n_tokens;
        if ( n_tlhs + 2 > v14 )
          goto LABEL_61;
        if ( n_tlhs > 0 )
        {
          v15 = 0;
          do
          {
            ++tlhs[v15++].level;
            v13 = n_tlhs;
          }
          while ( n_tlhs > v15 );
        }
        tlhs[v13].kind = OPERATOR;
        tlhs[n_tlhs].level = 1;
        tlhs[n_tlhs++].token.variable = 3;
        tlhs[n_tlhs].kind = VARIABLE;
        tlhs[n_tlhs].level = 1;
        tlhs[n_tlhs++].token.variable = v;
        uf_simp(tlhs, &n_tlhs);
        if ( !poly_gcd(src, len, tlhs, n_tlhs, v) || !level1_plus_count(tlhs, n_tlhs) )
        {
LABEL_61:
          if ( !modified )
            goto LABEL_62;
          memmove(jmp_save, save_save, 0x9Cu);
          goto LABEL_87;
        }
        save_factors(equation, np, loc1, len, level);
        v16 = n_tlhs;
        loc1 += n_tlhs + 1;
        len = n_trhs;
        if ( v35 == 2 )
        {
          if ( debug_level > 0 )
            __fprintf_chk(gfp, 1, "%s\n", "Polynomial with repeated factor factored.");
          len_first = n_tlhs;
          loc2 = loc1;
        }
        else
        {
          if ( v35 != 3 )
            v16 = v34;
          v34 = v16;
        }
        ++v35;
        modified = 1;
        goto LABEL_10;
      }
    }
    if ( l == v8 )
    {
      ++cnt;
      v8 = l;
      goto LABEL_22;
    }
LABEL_20:
    v8 = l;
    goto LABEL_22;
  }
skip_factor:
  memmove(jmp_save, save_save, 0x9Cu);
  if ( !modified )
    goto LABEL_98;
LABEL_87:
  if ( v34 )
  {
    v22 = v34;
    v23 = loc2;
  }
  else
  {
    v22 = len_first;
    v23 = loc;
  }
  if ( poly_gcd(src, len, &equation[v23], v22, v) )
  {
    save_factors(equation, np, loc1, len, level);
    loc1 += n_tlhs + 1;
    len = n_trhs;
  }
  v24 = loc2;
  if ( !v34 )
    v24 = loc1;
  v25 = v34;
  if ( !v34 )
    v25 = len;
  if ( poly_gcd(p1, len_first, &equation[v24], v25, 0) )
  {
    save_factors(equation, np, loc, len_first, level);
    v21 = 0;
    return v21 | modified;
  }
LABEL_98:
  v21 = 0;
  return v21 | modified;
}
// 8048EF4: using guessed type int __cdecl __longjmp_chk(_DWORD, _DWORD);
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (080684BF) --------------------------------------------------------
int __usercall pf_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int do_repeat)
{
  int v6; // edx
  token_type *v7; // esi
  int v8; // ecx
  token_type *v9; // eax
  int i; // esi
  int v11; // eax
  int *v12; // edx
  int v13; // esi
  int v14; // eax
  int op; // [esp+28h] [ebp-20h]
  int opa; // [esp+28h] [ebp-20h]

  v6 = loc + 1;
  if ( loc + 1 >= *np )
    goto LABEL_10;
  v7 = &equation[v6];
  v8 = v7->level;
  if ( level > v8 )
    goto LABEL_10;
  v9 = &equation[loc + 3];
  op = 0;
  do
  {
    if ( v8 == level )
      op = v7->token.variable;
    v6 += 2;
    if ( *np <= v6 )
      break;
    v7 = v9;
    v8 = v9->level;
    v9 += 2;
  }
  while ( v8 >= level );
  if ( (unsigned int)(op - 1) > 1 )
LABEL_10:
    opa = 0;
  else
    opa = pf_sub(equation, np, loc, v6 - loc, level, do_repeat);
  for ( i = loc; i < *np; i = v11 )
  {
    v14 = equation[i].level;
    if ( level > v14 )
      break;
    if ( level >= v14 )
    {
      v11 = i + 1;
    }
    else
    {
      opa |= pf_recurse(equation, np, i, level + 1, do_repeat);
      v11 = i + 1;
      if ( *np > i + 1 && level < equation[v11].level )
      {
        v12 = &equation[i + 3].level;
        do
        {
          v11 += 2;
          if ( *np <= v11 )
            break;
          v13 = *v12;
          v12 += 8;
        }
        while ( level < v13 );
      }
    }
  }
  return opa;
}

//----- (080685DE) --------------------------------------------------------
int __cdecl poly_factor(token_type *equation, int *np, int do_repeat)
{
  return pf_recurse(equation, np, 0, 1, do_repeat);
}

//----- (08068610) --------------------------------------------------------
int __cdecl limit_cmd(char *cp)
{
  int v1; // ebx
  int v2; // eax
  char *v4; // esi
  token_type *v5; // eax
  token_type want; // [esp+3Ch] [ebp-3Ch] BYREF
  token_type solved_v; // [esp+4Ch] [ebp-2Ch] BYREF
  int v[4]; // [esp+5Ch] [ebp-1Ch] BYREF

  v[0] = 0;
  if ( current_not_defined() )
    return 0;
  v1 = next_espace();
  if ( !n_rhs[cur_equation] )
  {
    memmove(rhs[cur_equation], lhs[cur_equation], 16 * n_lhs[cur_equation]);
    v2 = cur_equation;
    n_rhs[cur_equation] = n_lhs[cur_equation];
    n_lhs[v2] = 1;
    lhs[v2]->level = 1;
    lhs[cur_equation]->kind = VARIABLE;
    parse_var((int *)&lhs[cur_equation]->token, "answer");
  }
  if ( !solved_equation(cur_equation) )
  {
    error("The current equation is not solved for a variable.");
    return 0;
  }
  solved_v = *lhs[cur_equation];
  v4 = cp;
  if ( *cp )
  {
    v4 = parse_var2(v, cp);
    if ( !v4 )
      return 0;
  }
  if ( no_vars(rhs[cur_equation], n_rhs[cur_equation], v) )
  {
    error("Current expression contains no variables.");
    return 0;
  }
  if ( !v[0] && !prompt_var(v) )
    return 0;
  if ( !found_var(rhs[cur_equation], n_rhs[cur_equation], v[0]) )
  {
    error("Variable not found.");
    return 0;
  }
  if ( *v4 == 61 )
    v4 = skip_space(v4 + 1);
  if ( *v4 )
  {
    input_column += v4 - cp;
    if ( !parse_expr(tes, &n_tes, v4) || n_tes <= 0 )
      return 0;
LABEL_21:
    copy_espace(cur_equation, v1);
    simpa_side(rhs[v1], &n_rhs[v1], 0, 0);
    simp_loop(tes, &n_tes);
    if ( n_tes == 1 )
    {
      v5 = tes;
      if ( tes->kind == CONSTANT && tes->token.constant > 1.797693134862316e308 )
      {
        n_tes = 1;
        tes->kind = zero_token.kind;
        v5->level = zero_token.level;
        v5->token.constant = zero_token.token.constant;
        *tlhs = one_token;
        tlhs[1].level = 1;
        tlhs[1].kind = OPERATOR;
        tlhs[1].token.variable = 4;
        tlhs[2].level = 1;
        tlhs[2].kind = VARIABLE;
        tlhs[2].token.variable = v[0];
        n_tlhs = 3;
        subst_var_with_exp(rhs[v1], &n_rhs[v1], tlhs, 3, v[0]);
      }
    }
    if ( debug_level >= 0 )
      __fprintf_chk(gfp, 1, "%s\n", "Solving...");
    want.level = 1;
    want.kind = VARIABLE;
    want.token.variable = v[0];
    if ( solve_sub(&want, 1, lhs[v1], (int *)(4 * v1 + 134753664), rhs[v1], &n_rhs[v1]) <= 0 )
      goto LABEL_28;
    memmove(lhs[v1], tes, 16 * n_tes);
    n_lhs[v1] = n_tes;
    symb_flag = symblify;
    simpa_side(rhs[v1], &n_rhs[v1], 0, 0);
    symb_flag = 0;
    if ( !exp_contains_nan(rhs[v1], n_rhs[v1]) )
    {
      if ( solve_sub(&solved_v, 1, lhs[v1], (int *)(4 * v1 + 134753664), rhs[v1], &n_rhs[v1]) <= 0 )
      {
LABEL_28:
        error("Can't take the limit because solve failed.");
        return 0;
      }
      simpa_side(rhs[v1], &n_rhs[v1], 0, 0);
      if ( !exp_contains_nan(rhs[v1], n_rhs[v1]) )
        return return_result(v1);
    }
    error("Unable to take limit; result contains NaN (Not a Number).");
    return 0;
  }
  list_var(v[0], 0);
  __snprintf_chk(prompt_str, 80, 1, 80, "as (%s) goes to: ", var_str);
  if ( get_expr(tes, &n_tes) )
    goto LABEL_21;
  return 0;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (08068BB6) --------------------------------------------------------
int __usercall d_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int v)
{
  int v5; // esi
  token_type *v6; // eax
  int result; // eax
  int v8; // ebx
  int v9; // edi
  int v10; // edx
  token_type *v11; // eax
  token_type *v12; // ecx
  token_type *v13; // eax
  int v14; // edx
  int v15; // eax
  int *v16; // edx
  int v17; // ebx
  int i; // ebx
  token_type *v19; // eax
  int *v20; // eax
  int v21; // edx
  token_type *v22; // eax
  int v23; // esi
  int *v24; // eax
  int v25; // edx
  token_type *v26; // eax
  token_type *v27; // edi
  token_type *v28; // eax
  token_type *v29; // eax
  int v30; // edx
  int *v31; // eax
  int v32; // edx
  int v33; // edi
  int v34; // edi
  int v35; // eax
  int v36; // edx
  int v37; // edi
  int v38; // edx
  int v39; // edx
  int v40; // edx
  int v41; // edi
  int v42; // edx
  int v43; // edi
  int v45; // [esp+34h] [ebp-54h]
  int v46; // [esp+34h] [ebp-54h]
  int oploc; // [esp+3Ch] [ebp-4Ch]
  int oploca; // [esp+3Ch] [ebp-4Ch]
  int oplocb; // [esp+3Ch] [ebp-4Ch]
  int oplocc; // [esp+3Ch] [ebp-4Ch]
  token_type *src; // [esp+40h] [ebp-48h]
  int v54; // [esp+48h] [ebp-40h]
  unsigned int op; // [esp+4Ch] [ebp-3Ch]
  int opa; // [esp+4Ch] [ebp-3Ch]
  int opd; // [esp+4Ch] [ebp-3Ch]
  token_type *ope; // [esp+4Ch] [ebp-3Ch]
  int opb; // [esp+4Ch] [ebp-3Ch]
  int opc; // [esp+4Ch] [ebp-3Ch]
  complexs_0 v61; // [esp+50h] [ebp-38h] BYREF
  complexs_0 c; // [esp+60h] [ebp-28h] BYREF

  v54 = loc;
  v5 = level;
  v6 = &equation[loc];
  src = v6;
  if ( v6->level >= level )
  {
    v8 = loc + 1;
    v9 = *np;
    if ( loc + 1 >= *np || (v10 = equation[v8].level, level > v10) )
    {
LABEL_39:
      for ( i = v54; i < *np; i = v15 )
      {
        v19 = &equation[i];
        if ( level > v19->level )
          break;
        if ( v19->kind == OPERATOR )
        {
          v15 = i + 1;
        }
        else
        {
          if ( !d_recurse(equation, np, i, level + 1, v) )
            goto LABEL_84;
          v15 = i + 1;
          if ( i + 1 < *np && level < equation[v15].level )
          {
            v16 = &equation[i + 3].level;
            do
            {
              v15 += 2;
              if ( v15 >= *np )
                break;
              v17 = *v16;
              v16 += 8;
            }
            while ( level < v17 );
          }
        }
      }
      result = 1;
    }
    else
    {
      v11 = &equation[loc + 3];
      oploc = loc + 1;
      op = 0;
      v12 = &equation[v8];
      do
      {
        if ( level == v10 )
        {
          if ( op > 2 )
            error_bug("Internal error in d_recurse(): differentiating with unparenthesized operators is not allowed.");
          op = v12->token.variable;
          oploc = v8;
        }
        v8 += 2;
        if ( v8 >= v9 )
          break;
        v12 = v11;
        v10 = v11->level;
        v11 += 2;
      }
      while ( level <= v10 );
      v45 = oploc;
      switch ( op )
      {
        case 0u:
        case 1u:
        case 2u:
          goto LABEL_39;
        case 3u:
          if ( v9 + v8 - v54 + 1 > n_tokens )
            error_huge();
          if ( v54 < v8 )
          {
            v20 = &src->level;
            v21 = v54;
            do
            {
              ++*v20;
              ++v21;
              v20 += 4;
            }
            while ( v21 < v8 );
          }
          memmove(&equation[v8 + 1], src, 16 * (*np - v54));
          *np += v8 - v54 + 1;
          v22 = &equation[v8];
          v22->level = level;
          v22->kind = OPERATOR;
          v22->token.variable = 1;
          v23 = level + 2;
          if ( !d_recurse(equation, np, v8 + oploc - v54 + 2, level + 2, v) )
            goto LABEL_84;
          return d_recurse(equation, np, v54, v23, v);
        case 4u:
          opa = v8 - v54;
          oploca = v8 - oploc;
          if ( v8 - v45 + v9 + v8 - v54 + 3 > n_tokens )
            error_huge();
          if ( v54 < v8 )
          {
            v24 = &src->level;
            v25 = v54;
            do
            {
              *v24 += 2;
              ++v25;
              v24 += 4;
            }
            while ( v25 < v8 );
          }
          equation[v45].token.variable = 3;
          memmove(&equation[v8 + 1], src, 16 * (*np - v54));
          *np += opa + 1;
          v26 = &equation[v8];
          v26->level = level + 1;
          v26->kind = OPERATOR;
          v26->token.variable = 2;
          opd = v8 + opa + 1;
          v27 = &equation[opd];
          memmove(&equation[opd + 2 + oploca], v27, 16 * (*np - opd));
          *np += oploca + 2;
          v27->level = level;
          v27->kind = OPERATOR;
          v27->token.variable = 4;
          memmove(&v27[1], &equation[v45 + 1], 16 * (v8 + ~v45));
          v28 = &equation[oploca + opd];
          v28->level = level + 1;
          v28->kind = OPERATOR;
          v28->token.variable = 6;
          ++v28;
          v28->level = level + 1;
          v28->kind = CONSTANT;
          v28->token.constant = 2.0;
          v23 = level + 3;
          if ( !d_recurse(equation, np, v8 + v45 - v54 + 2, level + 3, v) )
            goto LABEL_84;
          return d_recurse(equation, np, v54, v23, v);
        case 6u:
          if ( oploc >= v8 )
            goto LABEL_70;
          v29 = &equation[oploc];
          v30 = oploc;
          while ( v29->kind != VARIABLE || (v != 5 || (v29->token.variable & 0x3FFFu) <= 4) && v29->token.variable != v )
          {
            ++v30;
            ++v29;
            if ( v8 <= v30 )
            {
LABEL_70:
              oplocc = v8 + ~oploc;
              v33 = v8 + ~v45;
              memmove(scratch, &equation[v45 + 1], v33 * 16);
              scratch[v33].level = level;
              scratch[v33].kind = OPERATOR;
              scratch[v33].token.variable = 3;
              opb = oplocc + 1;
              if ( v8 - v54 + oplocc + 1 + 2 > n_tokens )
                error_huge();
              memmove(&scratch[opb], src, 16 * (v8 - v54));
              v34 = opb + v45 - v54 + 1;
              v35 = oplocc + 1;
              if ( opb < v34 )
              {
                v36 = opb;
                do
                {
                  ++scratch[v36].level;
                  ++v35;
                  ++v36;
                }
                while ( v34 > v35 );
                v35 = opb + opb + v45 - v54 - (v8 + ~v45);
              }
              v37 = oplocc + v34;
              if ( v35 < v37 )
              {
                v38 = v35;
                do
                {
                  scratch[v38].level += 2;
                  ++v35;
                  ++v38;
                }
                while ( v37 > v35 );
              }
              v39 = v37;
              scratch[v39].level = level + 2;
              scratch[v39].kind = OPERATOR;
              scratch[v39].token.variable = 2;
              v40 = v37 + 1;
              scratch[v40].level = level + 2;
              scratch[v40].kind = CONSTANT;
              scratch[v40].token.constant = 1.0;
              v41 = v37 + 2;
              v46 = v45 - v54;
              if ( v46 + v41 + 1 > n_tokens )
                error_huge();
              v42 = v41;
              scratch[v42].level = level;
              scratch[v42].kind = OPERATOR;
              scratch[v42].token.variable = 3;
              opc = v41 + 1;
              memmove(&scratch[v41 + 1], src, 16 * v46);
              v43 = v46 + opc;
              if ( v46 + opc + *np + v54 - v8 > n_tokens )
                error_huge();
              memmove(&equation[v43 + v54], &equation[v8], 16 * (*np - v8));
              *np += v43 + v54 - v8;
              memmove(src, scratch, 16 * v43);
              return d_recurse(equation, np, v54 + opc, level + 1, v);
            }
          }
          if ( !parse_complex(src, oploc - v54, &c) )
            goto LABEL_84;
          complex_log(&v61, c);
          c = v61;
          oplocb = v8 + 6 - oploc;
          if ( *np + oplocb > n_tokens )
            error_huge();
          ope = &equation[v8];
          memmove(&equation[v8 + oplocb], ope, 16 * (*np - v8));
          *np += oplocb;
          ope->level = level;
          ope->kind = OPERATOR;
          ope->token.variable = 3;
          ope[1].level = level + 1;
          ope[1].kind = CONSTANT;
          ope[1].token.constant = c.re;
          ope[2].level = level + 1;
          ope[2].kind = OPERATOR;
          ope[2].token.variable = 1;
          ope[3].level = level + 2;
          ope[3].kind = CONSTANT;
          ope[3].token.constant = c.im;
          ope[4].level = level + 2;
          ope[4].kind = OPERATOR;
          ope[4].token.variable = 3;
          ope[5].level = level + 2;
          ope[5].kind = VARIABLE;
          ope[5].token.variable = 3;
          ope[6].level = level;
          ope[6].kind = OPERATOR;
          ope[6].token.variable = 3;
          memmove(&equation[v8 + 7], &equation[v45 + 1], 16 * (v8 + ~v45));
          if ( v54 < v8 )
          {
            v31 = &src->level;
            v32 = v54;
            do
            {
              ++*v31;
              ++v32;
              v31 += 4;
            }
            while ( v8 > v32 );
          }
          return d_recurse(equation, np, v8 + 7, level + 1, v);
        default:
          if ( v54 >= v8 )
            goto LABEL_28;
          v13 = src;
          v14 = v54;
          break;
      }
      while ( v13->kind != VARIABLE || (v != 5 || (v13->token.variable & 0x3FFFu) <= 4) && v13->token.variable != v )
      {
        v14 += 2;
        v13 += 2;
        if ( v14 >= v8 )
        {
          v5 = level;
LABEL_28:
          memmove(&equation[loc + 1], &equation[v8], 16 * (v9 - v8));
          *np += v54 - v8 + 1;
          src->level = v5;
          src->kind = CONSTANT;
          src->token.constant = 0.0;
          return 1;
        }
      }
LABEL_84:
      result = 0;
    }
  }
  else if ( v6->kind == VARIABLE && (v == 5 && (v6->token.variable & 0x3FFFu) > 4 || v6->token.variable == v) )
  {
    v6->kind = CONSTANT;
    v6->token.constant = 1.0;
    result = 1;
  }
  else
  {
    v6->kind = CONSTANT;
    v6->token.constant = 0.0;
    result = 1;
  }
  return result;
}

//----- (080694F5) --------------------------------------------------------
int __cdecl differentiate(token_type *equation, int *np, int v)
{
  int v3; // eax
  int v4; // ebx

  organize(equation, np);
  v3 = *np;
  if ( *np > 1 )
  {
    v4 = 1;
    do
    {
      if ( (unsigned int)(equation[v4].token.variable - 3) <= 1 )
        binary_parenthesize(equation, v3, v4);
      v4 += 2;
      v3 = *np;
    }
    while ( *np > v4 );
  }
  return d_recurse(equation, np, 0, 1, v);
}

//----- (0806956A) --------------------------------------------------------
int __cdecl taylor_cmd(char *cp)
{
  token_type *v2; // edi
  int *v3; // ebx
  char *v4; // eax
  char *v5; // eax
  int v6; // esi
  int v7; // eax
  int v8; // ebx
  token_type *v9; // esi
  int v10; // eax
  int *v11; // esi
  int v12; // ecx
  int *v13; // eax
  int v14; // edx
  token_type *v15; // ecx
  int v16; // ebx
  int v17; // edx
  int *v18; // eax
  token_type *v19; // edx
  token_type *v20; // edx
  long double v21; // fst7
  int v22; // eax
  int *v23; // eax
  token_type *v24; // edx
  int v25; // ebx
  token_type *v26; // eax
  int v27; // edx
  token_type *v28; // ebx
  const char *v29; // eax
  int *np; // [esp+24h] [ebp-1064h]
  int order; // [esp+28h] [ebp-1060h]
  int simplify_flag; // [esp+2Ch] [ebp-105Ch]
  int v33; // [esp+30h] [ebp-1058h]
  int i; // [esp+34h] [ebp-1054h]
  int v35; // [esp+38h] [ebp-1050h]
  int our; // [esp+3Ch] [ebp-104Ch]
  char *cp_start; // [esp+40h] [ebp-1048h]
  token_type *dest; // [esp+44h] [ebp-1044h]
  char *cp_0; // [esp+4Ch] [ebp-103Ch] BYREF
  int n1; // [esp+58h] [ebp-1030h] BYREF
  int our_nrhs; // [esp+5Ch] [ebp-102Ch] BYREF
  int our_nlhs; // [esp+60h] [ebp-1028h] BYREF
  char *cp1; // [esp+64h] [ebp-1024h] BYREF
  int v; // [esp+68h] [ebp-1020h] BYREF
  char buf[4096]; // [esp+6Ch] [ebp-101Ch] BYREF
  unsigned int v46; // [esp+106Ch] [ebp-1Ch]

  cp_0 = cp;
  v46 = __readgsdword(0x14u);
  v = 0;
  if ( current_not_defined() )
    return 0;
  simplify_flag = 1;
  if ( !strcmp_tospace(cp_0, "nosimplify") )
  {
    cp_0 = skip_param(cp_0);
    simplify_flag = 0;
  }
  i = next_espace();
  memmove(lhs[i], lhs[cur_equation], 16 * n_lhs[cur_equation]);
  n_lhs[i] = n_lhs[cur_equation];
  n_rhs[i] = 0;
  our = alloc_next_espace();
  n_lhs[i] = 0;
  if ( our < 0 )
  {
    error("Out of free equation spaces.");
    return 0;
  }
  if ( n_rhs[cur_equation] )
  {
    v2 = rhs[cur_equation];
    v3 = &n_rhs[cur_equation];
    dest = rhs[i];
    np = &n_rhs[i];
  }
  else
  {
    v2 = lhs[cur_equation];
    v3 = &n_lhs[cur_equation];
    dest = lhs[i];
    np = &n_lhs[i];
  }
  if ( !*cp_0 )
    goto LABEL_17;
  if ( isvarchar(*cp_0) )
  {
    cp_0 = parse_var2(&v, cp_0);
    if ( !cp_0 )
      return 0;
  }
  if ( *cp_0 )
  {
    order = decstrtol(cp_0, &cp1);
    v4 = skip_param(cp_0);
    if ( v4 != cp1 || order < 0 )
    {
      error("Positive integer required for order.");
      return 0;
    }
    cp_0 = v4;
  }
  else
  {
LABEL_17:
    order = -1;
  }
  no_vars(v2, *v3, &v);
  if ( !v && !prompt_var(&v) )
    return 0;
  if ( !found_var(v2, *v3, v) )
    warning("Variable not found.");
  memmove(rhs[our], v2, 16 * *v3);
  our_nrhs = *v3;
  uf_simp(rhs[our], &our_nrhs);
  if ( !differentiate(rhs[our], &our_nrhs, v) )
  {
    error("Differentiation failed.");
    return 0;
  }
  if ( *cp_0 )
  {
    input_column = &cp_0[input_column] - cp;
    cp_0 = parse_expr(lhs[our], &our_nlhs, cp_0);
    if ( !cp_0 || our_nlhs <= 0 )
      return 0;
  }
  else
  {
    list_var(v, 0);
    __printf_chk(1, "Taylor series expansion around %s = point.\n", var_str);
    my_strlcpy(prompt_str, "Enter point: ", 80);
    if ( !get_expr(lhs[our], &our_nlhs) )
      return 0;
  }
  if ( order < 0 )
  {
    my_strlcpy(prompt_str, "Enter order (number of derivatives to take): ", 80);
    v5 = get_string(buf, 4096);
    cp1 = v5;
    if ( v5 )
    {
      if ( *v5 )
      {
        order = decstrtol(v5, &cp_0);
        if ( *cp_0 || order < 0 )
        {
          error("Positive integer required for order.");
          return 0;
        }
      }
      else
      {
        __printf_chk(1, "Derivatives will be taken until they reach zero...\n");
        order = 2147483646;
      }
      goto LABEL_36;
    }
    return 0;
  }
LABEL_36:
  __printf_chk(1, "Computing the Taylor series");
  if ( n_rhs[cur_equation] )
    __printf_chk(1, " of the RHS");
  if ( simplify_flag )
    __printf_chk(1, " and simplifying");
  __printf_chk(1, "...\n");
  memmove(dest, v2, 16 * *v3);
  n1 = *v3;
  cp_start = 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = n1;
    if ( v6 < n1 )
    {
      v8 = v6;
      v35 = v6;
      do
      {
        v9 = &dest[v8];
        if ( v9->kind == VARIABLE && v9->token.variable == v )
        {
          v33 = v9->level;
          if ( v7 + our_nlhs - 1 > n_tokens )
            error_huge();
          memmove(&dest[our_nlhs + v8], &dest[v8 + 1], 16 * (n1 + ~v8));
          n1 = n1 + our_nlhs - 1;
          memmove(v9, lhs[our], 16 * our_nlhs);
          v10 = our_nlhs + v8;
          if ( v8 < our_nlhs + v8 )
          {
            v11 = &v9->level;
            do
            {
              *v11 += v33;
              ++v8;
              v11 += 4;
            }
            while ( v10 > v8 );
          }
          v8 = v10 - 1;
        }
        v8 += 2;
        v7 = n1;
      }
      while ( n1 > v8 );
      v6 = v35;
    }
    if ( v7 + our_nlhs + 7 > n_tokens )
      error_huge();
    v12 = n1;
    if ( v6 < n1 )
    {
      v13 = &dest[v6].level;
      v14 = v6;
      do
      {
        ++*v13;
        ++v14;
        v12 = n1;
        v13 += 4;
      }
      while ( n1 > v14 );
    }
    v15 = &dest[v12];
    v15->level = 1;
    v15->kind = OPERATOR;
    v15->token.variable = 3;
    v15[1].level = 3;
    v15[1].kind = VARIABLE;
    v15[1].token.variable = v;
    v15 += 2;
    v15->level = 3;
    v15->kind = OPERATOR;
    v15->token.variable = 2;
    v16 = n1 + 3;
    n1 = v16;
    memmove(&dest[v16], lhs[our], 16 * our_nlhs);
    v17 = our_nlhs + n1;
    n1 = v17;
    if ( v16 < v17 )
    {
      v18 = &dest[v16].level;
      do
      {
        *v18 += 3;
        ++v16;
        v17 = n1;
        v18 += 4;
      }
      while ( n1 > v16 );
    }
    v19 = &dest[v17];
    v19->level = 2;
    v19->kind = OPERATOR;
    v19->token.variable = 6;
    v19[1].level = 2;
    v19[1].kind = CONSTANT;
    v19[1].token.constant = (double)(int)cp_start;
    v19[2].level = 1;
    v19[2].kind = OPERATOR;
    v19[2].token.variable = 4;
    v20 = v19 + 3;
    if ( (int)cp_start > 1 )
    {
      v22 = 2;
      v21 = 1.0;
      do
        v21 = v21 * (long double)v22++;
      while ( (int)cp_start >= v22 );
    }
    else
    {
      v21 = 1.0;
    }
    v20->level = 1;
    v20->kind = CONSTANT;
    v20->token.constant = v21;
    n1 += 4;
    if ( v6 < n1 )
    {
      v23 = &dest[v6].level;
      do
      {
        ++*v23;
        ++v6;
        v23 += 4;
      }
      while ( n1 > v6 );
    }
    if ( simplify_flag )
      uf_simp(dest, &n1);
    list_debug(1, dest, n1, 0, 0);
    if ( exp_contains_infinity(dest, n1) )
    {
      error("Result invalid because it contains infinity or NaN.");
      return 0;
    }
    if ( (int)cp_start >= order )
      break;
    if ( (int)cp_start > 0 && !differentiate(rhs[our], &our_nrhs, v) )
    {
      error("Differentiation failed.");
      return 0;
    }
    symb_flag = symblify;
    simpa_side(rhs[our], &our_nrhs, 1, 1);
    symb_flag = 0;
    if ( our_nrhs == 1 )
    {
      v24 = rhs[our];
      if ( v24->kind == CONSTANT && v24->token.constant == 0.0 )
        break;
    }
    v25 = n1;
    v6 = n1 + 1;
    if ( n1 + 1 + our_nrhs > n_tokens )
      error_huge();
    if ( n1 > 0 )
    {
      v26 = dest;
      v27 = 0;
      do
      {
        ++v26->level;
        ++v27;
        ++v26;
      }
      while ( v27 != v25 );
    }
    v28 = &dest[v25];
    v28->level = 1;
    v28->kind = OPERATOR;
    v28->token.variable = 1;
    memmove(&dest[v6], rhs[our], 16 * our_nrhs);
    n1 = our_nrhs + v6;
    ++cp_start;
  }
  v29 = "%s %s" + 4;
  if ( cp_start == (char *)1 )
    v29 = "; This file can be edited.\n\n" + 28;
  __printf_chk(1, "%ld derivative%s applied.\n", cp_start, v29);
  if ( n_rhs[cur_equation] )
    n_lhs[i] = n_lhs[cur_equation];
  *np = n1;
  cur_equation = i;
  return return_result(i);
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08069FF8) --------------------------------------------------------
int __cdecl extrema_cmd(char *cp)
{
  int v1; // ebx
  int result; // eax
  token_type *v3; // esi
  int i; // edi
  int order; // [esp+2Ch] [ebp-3Ch]
  token_type want; // [esp+38h] [ebp-30h] BYREF
  int n; // [esp+48h] [ebp-20h] BYREF
  int v[7]; // [esp+4Ch] [ebp-1Ch] BYREF

  v[0] = 0;
  if ( current_not_defined() )
    return 0;
  v1 = next_espace();
  if ( n_rhs[cur_equation] )
  {
    if ( !solved_equation(cur_equation) )
    {
      error("The current equation is not solved for a variable.");
      return 0;
    }
    v3 = rhs[cur_equation];
    n = n_rhs[cur_equation];
  }
  else
  {
    v3 = lhs[cur_equation];
    n = n_lhs[cur_equation];
  }
  if ( !*cp )
    goto LABEL_14;
  if ( isvarchar(*cp) )
  {
    cp = parse_var2(v, cp);
    if ( !cp )
      return 0;
  }
  if ( !*cp )
  {
LABEL_14:
    order = 1;
    goto LABEL_15;
  }
  order = decstrtol(cp, &cp);
  if ( *cp || order <= 0 )
  {
    error("The order must be a positive integer.");
    return 0;
  }
LABEL_15:
  if ( no_vars(v3, n, v) )
  {
    error("Current expression contains no variables.");
    return 0;
  }
  if ( !v[0] && !prompt_var(v) )
    return 0;
  if ( found_var(v3, n, v[0]) )
  {
    memmove(rhs[v1], v3, 16 * n);
    for ( i = 0; i < order; ++i )
    {
      if ( !differentiate(rhs[v1], &n, v[0]) )
      {
        error("Differentiation failed.");
        return 0;
      }
      simpa_side(rhs[v1], &n, 1, 0);
    }
    if ( found_var(rhs[v1], n, v[0]) )
    {
      n_rhs[v1] = n;
      n_lhs[v1] = 1;
      *lhs[v1] = zero_token;
      cur_equation = v1;
      want.level = 1;
      want.kind = VARIABLE;
      want.token.variable = v[0];
      if ( solve_sub(&want, 1, lhs[v1], (int *)(4 * v1 + 134753664), rhs[v1], &n_rhs[v1]) > 0 )
      {
        simpa_side(rhs[v1], &n_rhs[v1], 0, 0);
        result = return_result(cur_equation);
      }
      else
      {
        error("Solve failed.");
        result = 0;
      }
    }
    else
    {
      error("There are no solutions.");
      result = 0;
    }
  }
  else
  {
    error("Variable not found; the derivative would be zero.");
    result = 0;
  }
  return result;
}
// 806A18B: conditional instruction was optimized away because of '%order.4>=1'

//----- (0806A31A) --------------------------------------------------------
int __cdecl derivative_cmd(char *cp)
{
  token_type *v1; // edi
  int *v2; // ebx
  token_type *v3; // esi
  int result; // eax
  int j; // ebx
  int v6; // eax
  char *v7; // ecx
  int v8; // edx
  int *np; // [esp+1Ch] [ebp-3Ch]
  int solved; // [esp+20h] [ebp-38h]
  int i; // [esp+24h] [ebp-34h]
  int simplify_flag; // [esp+28h] [ebp-30h]
  int v13; // [esp+2Ch] [ebp-2Ch]
  int n1; // [esp+38h] [ebp-20h] BYREF
  int v[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  v[0] = 0;
  if ( current_not_defined() )
    return 0;
  solved = solved_equation(cur_equation);
  simplify_flag = 1;
  if ( !strcmp_tospace(cp, "nosimplify") )
  {
    cp = skip_param(cp);
    simplify_flag = 0;
  }
  i = next_espace();
  if ( n_rhs[cur_equation] )
  {
    if ( !solved )
      warning("Not a solved equation.  Only the RHS will be differentiated.");
    v1 = rhs[cur_equation];
    v2 = &n_rhs[cur_equation];
    v3 = rhs[i];
    np = &n_rhs[i];
  }
  else
  {
    v1 = lhs[cur_equation];
    v2 = &n_lhs[cur_equation];
    v3 = lhs[i];
    np = &n_lhs[i];
  }
  if ( !*cp )
    goto LABEL_18;
  if ( is_all(cp) )
  {
    cp = skip_param(cp);
    v[0] = 5;
    goto LABEL_14;
  }
  if ( isvarchar(*cp) )
  {
    cp = parse_var2(v, cp);
    if ( !cp )
      return 0;
  }
LABEL_14:
  if ( !*cp )
  {
LABEL_18:
    v13 = 1;
    goto LABEL_19;
  }
  v13 = decstrtol(cp, &cp);
  if ( *cp || v13 <= 0 )
  {
    error("The order must be a positive integer.");
    return 0;
  }
LABEL_19:
  if ( no_vars(v1, *v2, v) )
  {
    error("Current expression contains no variables; the derivative would be zero.");
    return 0;
  }
  if ( !v[0] && !prompt_var(v) )
    return 0;
  if ( v[0] == 5 || found_var(v1, *v2, v[0]) )
  {
    if ( debug_level >= 0 )
    {
      list_var(v[0], 0);
      if ( n_rhs[cur_equation] )
        __printf_chk(1, "Differentiating the RHS with respect to (%s)", var_str);
      else
        __printf_chk(1, "Differentiating with respect to (%s)", var_str);
      if ( v13 != 1 )
        __printf_chk(1, " %ld times", v13);
      if ( simplify_flag )
        __printf_chk(1, " and simplifying...\n");
      else
        __printf_chk(1, "...\n");
    }
    memmove(v3, v1, 16 * *v2);
    n1 = *v2;
    for ( j = 0; j < v13; ++j )
    {
      if ( !differentiate(v3, &n1, v[0]) )
      {
        error("Differentiation failed.");
        return 0;
      }
      if ( simplify_flag )
        simpa_side(v3, &n1, 1, 0);
      else
        elim_loop(v3, &n1);
    }
    *np = n1;
    if ( n_rhs[cur_equation] )
    {
      memmove(lhs[i], lhs[cur_equation], 16 * n_lhs[cur_equation]);
      n_lhs[i] = n_lhs[cur_equation];
      if ( solved )
      {
        if ( isvarchar(39) )
        {
          v6 = list_var(lhs[i]->token.variable, 0);
          if ( v6 <= 98 )
          {
            v7 = &var_str[v6];
            v8 = 0;
            do
            {
              *v7 = 39;
              ++v6;
              ++v8;
              ++v7;
            }
            while ( v13 > v8 && v6 <= 98 );
          }
          var_str[v6] = 0;
          parse_var((int *)&lhs[i]->token, var_str);
        }
      }
    }
    cur_equation = i;
    result = return_result(i);
  }
  else
  {
    error("Variable not found; the derivative would be zero.");
    result = 0;
  }
  return result;
}
// 806A5E1: conditional instruction was optimized away because of '%var_2C.4>=1'
// 806A6D9: conditional instruction was optimized away because of '%var_2C.4>=1'
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806A750) --------------------------------------------------------
int __cdecl nintegrate_cmd(char *cp)
{
  char *v1; // ebx
  int v2; // eax
  char *v3; // eax
  token_type *v5; // esi
  int v6; // edi
  int v7; // edx
  token_type *v8; // ecx
  token_type *v9; // eax
  bool v10; // zf
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // eax
  int v15; // ebx
  int v16; // edx
  int v17; // eax
  int v18; // ecx
  token_type *v19; // eax
  int k; // edx
  token_type *v21; // ecx
  int v22; // ebx
  int v23; // eax
  int *v24; // edx
  int v25; // ecx
  token_type *v26; // esi
  int v27; // eax
  int v28; // edx
  int *v29; // esi
  token_type *v30; // ecx
  int v31; // ebx
  int v32; // edx
  int *v33; // eax
  token_type *v34; // eax
  double *v35; // eax
  int v36; // eax
  int v37; // ecx
  token_type *v38; // eax
  int l; // edx
  token_type *v40; // eax
  token_type *v41; // eax
  token_type *v42; // eax
  int v43; // ebx
  int *v44; // eax
  int v45; // eax
  int v46; // eax
  int *np; // [esp+14h] [ebp-64h]
  int solved; // [esp+18h] [ebp-60h]
  token_type *v49; // [esp+1Ch] [ebp-5Ch]
  int iterations; // [esp+20h] [ebp-58h]
  token_type *source; // [esp+24h] [ebp-54h]
  int trap_flag; // [esp+28h] [ebp-50h]
  int i; // [esp+2Ch] [ebp-4Ch]
  int *nps; // [esp+30h] [ebp-48h]
  int v55; // [esp+34h] [ebp-44h]
  int first_size; // [esp+38h] [ebp-40h]
  int v57; // [esp+3Ch] [ebp-3Ch]
  int v58; // [esp+3Ch] [ebp-3Ch]
  int j; // [esp+44h] [ebp-34h]
  int singularity; // [esp+48h] [ebp-30h]
  int n1; // [esp+58h] [ebp-20h] BYREF
  int v[7]; // [esp+5Ch] [ebp-1Ch] BYREF

  v[0] = 0;
  if ( current_not_defined() )
    return 0;
  solved = solved_equation(cur_equation);
  i = next_espace();
  if ( n_rhs[cur_equation] )
  {
    source = rhs[cur_equation];
    nps = &n_rhs[cur_equation];
    v49 = rhs[i];
    np = &n_rhs[i];
  }
  else
  {
    source = lhs[cur_equation];
    nps = &n_lhs[cur_equation];
    v49 = lhs[i];
    np = &n_lhs[i];
  }
  v1 = cp;
  v2 = strncasecmp(cp, "trap", 4u);
  trap_flag = v2 == 0;
  if ( !v2 )
    cp = skip_param(v1);
  if ( !*cp )
  {
    if ( prompt_var(v) )
      goto LABEL_15;
    return 0;
  }
  v3 = parse_var2(v, cp);
  cp = v3;
  if ( !v3 )
    return 0;
  if ( *v3 )
  {
    iterations = decstrtol(v3, &cp);
    if ( *cp || iterations <= 0 || (iterations & 1) != 0 )
    {
      error("Number of partitions must be a positive, even integer.");
      return 0;
    }
    goto LABEL_16;
  }
LABEL_15:
  iterations = 1000;
LABEL_16:
  v57 = *nps;
  if ( *nps > 1 )
  {
    v5 = source + 2;
    v6 = 2;
    singularity = 0;
    do
    {
      if ( v5[-1].token.variable == 4 )
      {
        v7 = v6;
        if ( v6 < v57 )
        {
          v8 = v5;
          if ( v5->level >= v5[-1].level )
          {
            v9 = v5 + 1;
            do
            {
              if ( v8->kind == VARIABLE )
              {
                v10 = v8->token.variable == v[0];
                v11 = 1;
                if ( !v10 )
                  v11 = singularity;
                singularity = v11;
              }
              if ( ++v7 >= v57 )
                break;
              v8 = v9;
              v12 = v9->level;
              ++v9;
            }
            while ( v12 >= v5[-1].level );
          }
        }
      }
      v6 += 2;
      v5 += 2;
    }
    while ( v6 != 2 * ((unsigned int)(*nps - 2) >> 1) + 4 );
    if ( singularity )
      warning("Singularity detected, result of numerical integration might be wrong.");
  }
  my_strlcpy(prompt_str, "Enter lower bound: ", 80);
  if ( !get_expr(tlhs, &n_tlhs) )
    return 0;
  subst_constants(tlhs, &n_tlhs);
  if ( exp_contains_infinity(tlhs, n_tlhs) )
  {
LABEL_33:
    error("Error: Bound contains infinity.");
    return 0;
  }
  my_strlcpy(prompt_str, "Enter upper bound: ", 80);
  if ( !get_expr(trhs, &n_trhs) )
    return 0;
  subst_constants(trhs, &n_trhs);
  if ( exp_contains_infinity(trhs, n_trhs) )
    goto LABEL_33;
  if ( n_trhs + n_tlhs + 3 > n_tokens )
    error_huge();
  if ( n_rhs[cur_equation] )
    __printf_chk(1, "Approximating the definite integral of the RHS\n");
  else
    __printf_chk(1, "Approximating the definite integral\n");
  if ( trap_flag )
    __printf_chk(1, "using the trapezoid method (%d partitions)...\n", iterations);
  else
    __printf_chk(1, "using Simpson's rule (%d partitions)...\n", iterations);
  subst_constants(source, nps);
  simp_loop(source, nps);
  v13 = n_trhs;
  if ( n_trhs > 0 )
  {
    v14 = 0;
    do
    {
      trhs[v14++].level += 2;
      v13 = n_trhs;
    }
    while ( n_trhs > v14 );
  }
  trhs[v13].level = 2;
  trhs[n_trhs].kind = OPERATOR;
  trhs[n_trhs].token.variable = 2;
  v15 = n_trhs + 1;
  n_trhs = v15;
  memmove(&trhs[v15], tlhs, 16 * n_tlhs);
  v16 = n_tlhs + n_trhs;
  n_trhs = v16;
  if ( v15 < v16 )
  {
    v17 = v15;
    do
    {
      trhs[v17].level += 2;
      ++v15;
      v16 = n_trhs;
      ++v17;
    }
    while ( n_trhs > v15 );
  }
  trhs[v16].level = 1;
  trhs[n_trhs].kind = OPERATOR;
  trhs[n_trhs++].token.variable = 4;
  trhs[n_trhs].level = 1;
  trhs[n_trhs].kind = CONSTANT;
  trhs[n_trhs++].token.constant = (double)iterations;
  simp_loop(trhs, &n_trhs);
  *v49 = zero_token;
  n1 = 1;
  first_size = 0;
  for ( j = 0; j <= iterations; ++j )
  {
    if ( *nps + n1 + 1 > n_tokens )
      error_huge();
    v18 = n1;
    if ( n1 > 0 )
    {
      v19 = v49;
      for ( k = 0; k < n1; ++k )
      {
        ++v19->level;
        v18 = n1;
        ++v19;
      }
    }
    v21 = &v49[v18];
    v21->level = 1;
    v21->kind = OPERATOR;
    v21->token.variable = 1;
    v22 = n1 + 1;
    n1 = v22;
    memmove(&v49[v22], source, 16 * *nps);
    v23 = *nps + n1;
    n1 = v23;
    if ( v22 < v23 )
    {
      v24 = &v49[v22].level;
      v25 = v22;
      do
      {
        *v24 += 2;
        ++v25;
        v23 = n1;
        v24 += 4;
      }
      while ( n1 > v25 );
      for ( ; n1 > v22; v23 = n1 )
      {
        v26 = &v49[v22];
        if ( v26->kind == VARIABLE && v26->token.variable == v[0] )
        {
          v55 = v26->level;
          v58 = n_trhs + n_tlhs + 2;
          if ( v58 + v23 > n_tokens )
            error_huge();
          memmove(&v49[v58 + 1 + v22], &v49[v22 + 1], 16 * (n1 + ~v22));
          n1 += v58;
          memmove(&v49[v22], tlhs, 16 * n_tlhs);
          v27 = n_tlhs + v22;
          v28 = v55 + 1;
          if ( v22 < n_tlhs + v22 )
          {
            v29 = &v26->level;
            do
            {
              *v29 += v28;
              ++v22;
              v29 += 4;
            }
            while ( v27 > v22 );
          }
          v30 = &v49[v27];
          v30->level = v28;
          v30->kind = OPERATOR;
          v30->token.variable = 1;
          v30[1].level = v55 + 2;
          v30[1].kind = CONSTANT;
          v30[1].token.constant = (double)j;
          v30 += 2;
          v30->level = v55 + 2;
          v30->kind = OPERATOR;
          v30->token.variable = 3;
          v31 = v27 + 3;
          memmove(&v49[v27 + 3], trhs, 16 * n_trhs);
          v32 = n_trhs + v31;
          if ( v31 < n_trhs + v31 )
          {
            v33 = &v49[v31].level;
            do
            {
              *v33 += v55 + 2;
              ++v31;
              v33 += 4;
            }
            while ( v32 > v31 );
          }
          v22 = v32 - 1;
        }
        v22 += 2;
      }
    }
    if ( j > 0 && j < iterations )
    {
      if ( v23 + 2 > n_tokens )
        error_huge();
      v34 = &v49[n1];
      v34->level = 2;
      v34->kind = OPERATOR;
      v34->token.variable = 3;
      v35 = (double *)&v34[1];
      *((_DWORD *)v35 + 1) = 2;
      *(_DWORD *)v35 = 0;
      if ( trap_flag )
      {
        v35[1] = 2.0;
      }
      else if ( (j & 1) != 0 )
      {
        v35[1] = 4.0;
      }
      else
      {
        v35[1] = 2.0;
      }
      n1 += 2;
    }
    approximate_roots = 1;
    elim_loop(v49, &n1);
    ufactor(v49, &n1);
    simp_divide(v49, &n1);
    approximate_roots = 0;
    if ( exp_contains_infinity(v49, n1) )
    {
      error("Integration failed because result contains infinity or NaN (a singularity).");
      return 0;
    }
    if ( j )
    {
      if ( j == 1 )
      {
        v36 = 4;
        if ( n1 > 3 )
          v36 = n1;
        first_size = v36;
      }
      else if ( first_size <= n1 / 8 )
      {
        error("Integration failed.");
        return 0;
      }
    }
  }
  if ( n_trhs + n1 + 3 > n_tokens )
    error_huge();
  v37 = n1;
  if ( n1 > 0 )
  {
    v38 = v49;
    for ( l = 0; l < n1; ++l )
    {
      ++v38->level;
      v37 = n1;
      ++v38;
    }
  }
  v40 = &v49[v37];
  v40->level = 1;
  v40->kind = OPERATOR;
  v40->token.variable = 4;
  v41 = v40 + 1;
  v41->level = 1;
  v41->kind = CONSTANT;
  if ( trap_flag )
    v41->token.constant = 2.0;
  else
    v41->token.constant = 3.0;
  v42 = v41 + 1;
  v42->level = 1;
  v42->kind = OPERATOR;
  v42->token.variable = 3;
  v43 = n1 + 3;
  n1 = v43;
  memmove(&v49[v43], trhs, 16 * n_trhs);
  n1 += n_trhs;
  if ( v43 < n1 )
  {
    v44 = &v49[v43].level;
    do
    {
      ++*v44;
      ++v43;
      v44 += 4;
    }
    while ( n1 > v43 );
  }
  approximate_roots = 1;
  elim_loop(v49, &n1);
  ufactor(v49, &n1);
  simp_divide(v49, &n1);
  approximate_roots = 0;
  __printf_chk(1, "Numerical integration successful:\n");
  *np = n1;
  if ( n_rhs[cur_equation] )
  {
    memmove(lhs[i], lhs[cur_equation], 16 * n_lhs[cur_equation]);
    n_lhs[i] = n_lhs[cur_equation];
    if ( solved )
    {
      if ( isvarchar(39) )
      {
        v45 = list_var(lhs[i]->token.variable, 0);
        if ( v45 > 0 )
        {
          v46 = v45 - 1;
          if ( var_str[v46] == 39 )
            var_str[v46] = 0;
        }
        parse_var((int *)&lhs[i]->token, var_str);
      }
    }
  }
  cur_equation = i;
  return return_result(i);
}
// 806AC9C: conditional instruction was optimized away because of '%iterations.4>=1'
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806B21F) --------------------------------------------------------
void __cdecl make_powers(token_type *equation, int *np, int v)
{
  int i; // eax
  token_type *v4; // ebx
  int v5; // esi
  int v6; // ecx
  int *v7; // eax
  int v8; // ebx
  int v9; // esi
  token_type *v10; // ebx
  token_type *v11; // edx
  int v12; // edx
  int v13; // [esp+1Ch] [ebp-1Ch]

  for ( i = 0; ; i = v6 )
  {
    v12 = *np;
    if ( i >= *np )
      break;
    v4 = &equation[i];
    v5 = v4->level;
    if ( v4->kind == OPERATOR && v4->token.variable == 6 )
    {
      v6 = i + 2;
      if ( v12 > i + 2 && v5 <= equation[v6].level )
      {
        v7 = &equation[i + 4].level;
        do
        {
          v6 += 2;
          if ( v12 <= v6 )
            break;
          v8 = *v7;
          v7 += 8;
        }
        while ( v5 <= v8 );
      }
    }
    else
    {
      if ( v4->kind == VARIABLE && v4->token.variable == v )
      {
        v13 = i + 1;
        if ( v12 <= i + 1 || equation[i + 1].token.variable != 6 )
        {
          if ( v12 + 2 > n_tokens )
            error_huge();
          v9 = v5 + 1;
          v4->level = v9;
          v10 = &equation[v13];
          memmove(&v10[2], v10, 16 * (*np - v13));
          *np += 2;
          v10->level = v9;
          v10->kind = OPERATOR;
          v10->token.variable = 6;
          i = v13 + 1;
          v11 = &equation[v13 + 1];
          v11->level = v9;
          v11->kind = CONSTANT;
          v11->token.constant = 1.0;
        }
      }
      v6 = i + 1;
    }
  }
}

//----- (0806B348) --------------------------------------------------------
int __cdecl int_dispatch(token_type *equation, int *np, int v, int (*func)(...))
{
  int v4; // edi
  int v5; // eax
  token_type *v7; // edx
  int v8; // edi
  int *v9; // edx

  make_powers(equation, np, v);
  v4 = 0;
  v5 = 1;
  if ( *np <= 1 )
    return func(equation, np, v4, v5, v);
  while ( 1 )
  {
    v7 = &equation[v5];
    if ( v7->level != 1 || (unsigned int)(v7->token.variable - 1) > 1 )
      goto LABEL_14;
    if ( !func(equation, np, v4, v5, v) )
      return 0;
    v5 = v4 + 1;
    if ( v4 + 1 >= *np )
      return 1;
    if ( equation[v5].level != 1 )
      break;
LABEL_10:
    v4 = v5 + 1;
LABEL_14:
    v5 += 2;
    if ( *np <= v5 )
      return func(equation, np, v4, v5, v);
  }
  v9 = &equation[v4 + 3].level;
  while ( 1 )
  {
    v5 += 2;
    if ( v5 >= *np )
      return 1;
    v8 = *v9;
    v9 += 8;
    if ( v8 == 1 )
      goto LABEL_10;
  }
}

//----- (0806B429) --------------------------------------------------------
int __cdecl laplace_cmd(char *cp)
{
  char *v1; // ebx
  int v2; // esi
  int *v3; // edi
  int v4; // eax
  int v5; // eax
  int *np; // [esp+10h] [ebp-38h]
  token_type *dest; // [esp+14h] [ebp-34h]
  token_type *source; // [esp+18h] [ebp-30h]
  int inverse_flag; // [esp+1Ch] [ebp-2Ch]
  int n1; // [esp+28h] [ebp-20h] BYREF
  int v[4]; // [esp+2Ch] [ebp-1Ch] BYREF

  v1 = cp;
  v[0] = 0;
  if ( current_not_defined() )
    return 0;
  v2 = next_espace();
  if ( n_rhs[cur_equation] )
  {
    source = rhs[cur_equation];
    v3 = &n_rhs[cur_equation];
    dest = rhs[v2];
    np = &n_rhs[v2];
  }
  else
  {
    source = lhs[cur_equation];
    v3 = &n_lhs[cur_equation];
    dest = lhs[v2];
    np = &n_lhs[v2];
  }
  v4 = strcmp_tospace(cp, "inverse");
  inverse_flag = v4 == 0;
  if ( !v4 )
    v1 = skip_param(cp);
  if ( *v1 )
  {
    v1 = parse_var2(v, v1);
    if ( !v1 )
      return 0;
  }
  else if ( !prompt_var(v) )
  {
    return 0;
  }
  if ( extra_characters(v1) )
    return 0;
  partial_flag = 0;
  uf_simp(source, v3);
  partial_flag = 1;
  factorv(source, v3, v[0]);
  memmove(dest, source, 16 * *v3);
  v5 = *v3;
  n1 = *v3;
  if ( inverse_flag )
  {
    if ( !poly_in_v(dest, v5, v[0], 1) || !int_dispatch(dest, &n1, v[0], (int (*)(...))inv_laplace_sub) )
    {
      error("Inverse Laplace failed.");
      return 0;
    }
  }
  else if ( !poly_in_v(dest, v5, v[0], 0) || !int_dispatch(dest, &n1, v[0], (int (*)(...))laplace_sub) )
  {
    error("Laplace failed, not a polynomial.");
    return 0;
  }
  simp_loop(dest, &n1);
  if ( n_rhs[cur_equation] )
  {
    memmove(lhs[v2], lhs[cur_equation], 16 * n_lhs[cur_equation]);
    n_lhs[v2] = n_lhs[cur_equation];
  }
  *np = n1;
  cur_equation = v2;
  return return_result(v2);
}

//----- (0806B6A8) --------------------------------------------------------
int __cdecl laplace_sub(token_type *equation, int *np, int loc, int eloc, int v)
{
  int v5; // ebx
  int *v6; // eax
  int v7; // edx
  token_type *v8; // eax
  token_type *v9; // eax
  int v10; // eax
  token_type *v11; // ecx
  int v12; // edx
  token_type *v13; // eax
  int v14; // edi
  int v15; // esi
  int v16; // ecx
  int v17; // edi
  int *v18; // eax
  int v19; // edx
  token_type *v20; // eax
  token_type *v21; // ebx
  token_type *v22; // eax
  int result; // eax
  token_type *v24; // ebx
  int v25; // [esp+1Ch] [ebp-2Ch]
  token_type *src; // [esp+20h] [ebp-28h]
  int len; // [esp+24h] [ebp-24h]
  int mlevel; // [esp+28h] [ebp-20h]
  token_type *expression; // [esp+2Ch] [ebp-1Ch]

  v5 = loc;
  mlevel = min_level(&equation[loc], eloc - loc) + 1;
  if ( eloc <= loc )
  {
LABEL_23:
    if ( *np + 2 > n_tokens )
      error_huge();
    v24 = &equation[eloc];
    memmove(&v24[2], v24, 16 * (*np - eloc));
    *np += 2;
    v24->level = mlevel;
    v24->kind = OPERATOR;
    v24->token.variable = 4;
    v24[1].level = mlevel;
    v24[1].kind = VARIABLE;
    v24[1].token.variable = v;
    result = 1;
  }
  else
  {
    v6 = &equation[loc].level;
    v7 = loc;
    do
    {
      *v6 += 2;
      ++v7;
      v6 += 4;
    }
    while ( eloc > v7 );
    v8 = &equation[loc];
    while ( v8->kind != VARIABLE || v8->token.variable != v )
    {
      v5 += 2;
      v8 += 2;
      if ( eloc <= v5 )
        goto LABEL_23;
    }
    if ( eloc > v5 + 1 && (v9 = &equation[v5 + 1], v9->token.variable == 6) )
    {
      v10 = v9->level;
      v25 = v10;
      expression = (token_type *)(v5 + 2);
      if ( eloc <= v5 + 2 || (v11 = &equation[v5 + 2], v12 = v11->level, v10 > v12) )
      {
        v14 = v5 + 2;
      }
      else
      {
        v13 = &equation[v5 + 3];
        v14 = v5 + 2;
        do
        {
          v11->level = v12 + 1;
          if ( eloc <= ++v14 )
            break;
          v11 = v13;
          v12 = v13->level;
          ++v13;
        }
        while ( v25 <= v12 );
      }
      len = v14 - (_DWORD)expression;
      if ( v14 - (int)expression + *np + 7 > n_tokens )
        error_huge();
      src = &equation[v14];
      memmove(&src[4], src, 16 * (*np - v14));
      *np += 4;
      v15 = eloc + 4;
      v16 = v25 + 1;
      src->level = v25 + 1;
      src->kind = OPERATOR;
      src->token.variable = 1;
      src[1].level = v25 + 1;
      src[1].kind = CONSTANT;
      src[1].token.constant = 1.0;
      v17 = v14 + 2;
      if ( (int)expression < v17 )
      {
        v18 = &equation[v5 + 2].level;
        v19 = v5 + 2;
        do
        {
          ++*v18;
          ++v19;
          v18 += 4;
        }
        while ( v17 > v19 );
      }
      v20 = &equation[v17];
      v20->level = v16;
      v20->kind = OPERATOR;
      v20->token.variable = 3;
      ++v20;
      v20->level = v16;
      v20->kind = CONSTANT;
      v20->token.constant = -1.0;
      v21 = &equation[v15];
      memmove(&equation[v15 + 3 + len], v21, 16 * (*np - v15));
      *np += len + 3;
      v21->level = mlevel;
      v21->kind = OPERATOR;
      v21->token.variable = 3;
      memmove(&equation[eloc + 5], &equation[(_DWORD)expression], 16 * len);
      v22 = &equation[len + 5 + eloc];
      v22->level = mlevel + 1;
      v22->kind = OPERATOR;
      v22->token.variable = 7;
      ++v22;
      v22->level = mlevel + 1;
      v22->kind = CONSTANT;
      v22->token.constant = 1.0;
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (0806B9BB) --------------------------------------------------------
int __cdecl inv_laplace_sub(token_type *equation, int *np, int loc, int eloc, int v)
{
  int *v5; // eax
  int v6; // edx
  token_type *v7; // eax
  int v8; // edx
  token_type *v9; // esi
  int v10; // edi
  token_type *v11; // ecx
  int v12; // eax
  token_type *v13; // edx
  int v14; // esi
  int v15; // edi
  token_type *v16; // esi
  token_type *v17; // eax
  token_type *src; // [esp+20h] [ebp-28h]
  int len; // [esp+24h] [ebp-24h]
  int v21; // [esp+28h] [ebp-20h]
  int expression; // [esp+2Ch] [ebp-1Ch]

  v21 = min_level(&equation[loc], eloc - loc);
  if ( eloc <= loc )
    return 0;
  v5 = &equation[loc].level;
  v6 = loc;
  do
  {
    *v5 += 2;
    ++v6;
    v5 += 4;
  }
  while ( eloc > v6 );
  v7 = &equation[loc];
  v8 = loc;
  while ( v7->kind != VARIABLE || v7->token.variable != v )
  {
    v8 += 2;
    v7 += 2;
    if ( eloc <= v8 )
      return 0;
  }
  if ( eloc <= v8 + 1 )
    return 0;
  v9 = &equation[v8 + 1];
  if ( v9->token.variable != 6 || loc >= v8 - 1 || equation[v8 - 1].token.variable != 4 )
    return 0;
  v10 = v9->level;
  expression = v8 + 2;
  if ( eloc <= v8 + 2 || (v11 = &equation[v8 + 2], v12 = v11->level, v10 > v12) )
  {
    v14 = v8 + 2;
  }
  else
  {
    v13 = &equation[v8 + 3];
    v14 = expression;
    do
    {
      v11->level = v12 + 1;
      if ( eloc <= ++v14 )
        break;
      v11 = v13;
      v12 = v13->level;
      ++v13;
    }
    while ( v10 <= v12 );
  }
  len = v14 - expression;
  if ( v14 - expression + *np + 7 > n_tokens )
    error_huge();
  equation[expression - 3].token.variable = 3;
  src = &equation[v14];
  memmove(&src[2], src, 16 * (*np - v14));
  *np += 2;
  v15 = v10 + 1;
  src->level = v15;
  src->kind = OPERATOR;
  src->token.variable = 2;
  src[1].level = v15;
  src[1].kind = CONSTANT;
  src[1].token.constant = 1.0;
  v16 = &equation[eloc + 2];
  memmove(&equation[len + 7 + eloc], v16, 16 * (*np - (eloc + 2)));
  *np += len + 2 + 3;
  v16->level = v21 + 1;
  v16->kind = OPERATOR;
  v16->token.variable = 4;
  memmove(&equation[eloc + 3], &equation[expression], 16 * (len + 2));
  v17 = &equation[len + 5 + eloc];
  v17->level = v21 + 2;
  v17->kind = OPERATOR;
  v17->token.variable = 7;
  ++v17;
  v17->level = v21 + 2;
  v17->kind = CONSTANT;
  v17->token.constant = 1.0;
  return 1;
}

//----- (0806BC22) --------------------------------------------------------
int __cdecl integrate_sub(token_type *equation, int *np, int loc, int eloc, int v)
{
  int v5; // ebx
  int v6; // edx
  token_type *v7; // eax
  storage_type *v8; // ecx
  int v9; // edi
  int *v10; // esi
  int v11; // edi
  int v12; // ecx
  token_type *v13; // edi
  int *v14; // eax
  int v15; // edx
  int v16; // esi
  _BOOL4 v17; // ecx
  token_type *v18; // eax
  token_type *v19; // eax
  int v20; // edx
  token_type *v21; // eax
  token_type *v22; // edi
  int v23; // ecx
  token_type *v24; // eax
  token_type *v25; // ecx
  int v26; // eax
  token_type *v27; // edx
  int v28; // esi
  token_type *v29; // edi
  token_type *v30; // esi
  token_type *v32; // esi
  storage_type *v33; // [esp+20h] [ebp-48h]
  int v34; // [esp+28h] [ebp-40h]
  int vlevel; // [esp+34h] [ebp-34h]
  int count; // [esp+38h] [ebp-30h]
  int v37; // [esp+3Ch] [ebp-2Ch]
  int v38; // [esp+3Ch] [ebp-2Ch]
  token_type *len; // [esp+40h] [ebp-28h]
  int lena; // [esp+40h] [ebp-28h]
  int v41; // [esp+44h] [ebp-24h]
  int mlevel; // [esp+48h] [ebp-20h]
  int v43; // [esp+4Ch] [ebp-1Ch]

  v5 = eloc;
  v37 = min_level(&equation[loc], eloc - loc);
  if ( eloc > loc )
  {
    v6 = loc + 1;
    v7 = &equation[loc];
    count = 0;
    v34 = v37 + 1;
    v8 = &v7[1].token;
    do
    {
      if ( v7->kind == VARIABLE && v7->token.variable == v )
      {
        if ( ++count > 1 )
          return 0;
        v9 = v7->level;
        vlevel = v9;
        if ( v37 != v9 && v34 != v9 )
          return 0;
        if ( eloc > loc + 1 )
        {
          v10 = &equation[loc + 1].level;
          v11 = loc + 1;
          v33 = v8;
          while ( 1 )
          {
            if ( v37 == *v10 )
            {
              v12 = v10[1];
              if ( v12 < 3 || v12 > 4 && (v12 != 6 || v11 != v6) )
                return 0;
            }
            v11 += 2;
            v10 += 8;
            if ( eloc <= v11 )
            {
              v8 = v33;
              break;
            }
          }
        }
        if ( v34 == vlevel && (eloc <= v6 || v34 != *(&v8[-1].operatr + 1) || v8->variable != 6) )
          return 0;
      }
      v7 += 2;
      v8 += 4;
      v6 += 2;
    }
    while ( eloc > v6 - 1 );
    v13 = &equation[loc];
    mlevel = v37 + 1;
    v14 = &v13->level;
    v15 = loc;
    do
    {
      *v14 += 2;
      ++v15;
      v14 += 4;
    }
    while ( eloc > v15 );
    v16 = loc;
    while ( v13->kind != VARIABLE || v13->token.variable != v )
    {
      v16 += 2;
      v13 += 2;
      if ( eloc <= v16 )
        goto LABEL_54;
    }
    v17 = 0;
    if ( loc < v16 )
      v17 = equation[v16 - 1].token.variable == 4;
    if ( eloc > v16 + 1 )
    {
      v18 = &equation[v16 + 1];
      if ( v18->token.variable == 6 )
      {
        v41 = v18->level;
        v43 = v16 + 2;
        if ( !v17 )
        {
LABEL_43:
          if ( v5 <= v43 || (v25 = &equation[v43], v26 = v25->level, v41 > v26) )
          {
            v28 = v16 + 2;
          }
          else
          {
            v27 = &equation[v16 + 3];
            v28 = v16 + 2;
            do
            {
              v25->level = v26 + 1;
              if ( v5 <= ++v28 )
                break;
              v25 = v27;
              v26 = v27->level;
              ++v27;
            }
            while ( v41 <= v26 );
          }
          lena = v28 - v43;
          if ( v28 - v43 + *np + 5 > n_tokens )
            error_huge();
          v29 = &equation[v28];
          memmove(&v29[2], v29, 16 * (*np - v28));
          *np += 2;
          v29->level = v41 + 1;
          v29->kind = OPERATOR;
          v29->token.variable = 1;
          v29[1].level = v41 + 1;
          v29[1].kind = CONSTANT;
          v29[1].token.constant = 1.0;
          v30 = &equation[v5 + 2];
          memmove(&equation[lena + 5 + v5], v30, 16 * (*np - (v5 + 2)));
          *np += lena + 2 + 1;
          v30->level = mlevel;
          v30->kind = OPERATOR;
          v30->token.variable = 4;
          memmove(&equation[v5 + 3], &equation[v43], 16 * (lena + 2));
          return 1;
        }
        v38 = v16 + 2;
        v19 = &equation[v16 + 2];
        len = v19;
        if ( v19->level != v41 || v19->kind || v19->token.constant != 1.0 )
        {
          if ( *np + 2 > n_tokens )
            error_huge();
          if ( eloc > v43 )
          {
            v20 = v19->level;
            if ( v41 <= v20 )
            {
              v21 = &equation[v16 + 3];
              v22 = len;
              v23 = v16 + 2;
              do
              {
                v22->level = v20 + 1;
                if ( eloc <= ++v23 )
                  break;
                v22 = v21;
                v20 = v21->level;
                ++v21;
              }
              while ( v41 <= v20 );
            }
          }
          equation[v16 - 1].token.variable = 3;
          memmove(&equation[v38 + 2], len, 16 * (*np - v43));
          *np += 2;
          v5 = eloc + 2;
          len->level = v41 + 1;
          len->kind = CONSTANT;
          len->token.constant = -1.0;
          v24 = &equation[v38 + 1];
          v24->level = v41 + 1;
          v24->kind = OPERATOR;
          v24->token.variable = 3;
          goto LABEL_43;
        }
      }
    }
    return 0;
  }
  mlevel = v37 + 1;
LABEL_54:
  if ( *np + 2 > n_tokens )
    error_huge();
  v32 = &equation[eloc];
  memmove(&v32[2], v32, 16 * (*np - eloc));
  *np += 2;
  v32->level = mlevel;
  v32->kind = OPERATOR;
  v32->token.variable = 3;
  v32[1].level = mlevel;
  v32[1].kind = VARIABLE;
  v32[1].token.variable = v;
  return 1;
}

//----- (0806C0D8) --------------------------------------------------------
int __cdecl integrate_cmd(char *cp)
{
  char v1; // di
  char v2; // bl
  token_type *v4; // edi
  int *v5; // esi
  token_type *v6; // ebx
  long double v7; // fst6
  char v9; // c2
  int v10; // esi
  int v11; // ecx
  token_type *v12; // eax
  int m; // edx
  int v14; // eax
  token_type *v15; // eax
  int k; // edx
  int l; // eax
  int v18; // eax
  _BYTE *v19; // ecx
  int j; // edx
  int *np; // [esp+28h] [ebp-C0h]
  int solved; // [esp+2Ch] [ebp-BCh]
  char v23; // [esp+33h] [ebp-B5h]
  int i; // [esp+34h] [ebp-B4h]
  double integrate_order; // [esp+38h] [ebp-B0h]
  char v26; // [esp+47h] [ebp-A1h]
  char *cp_0; // [esp+4Ch] [ebp-9Ch] BYREF
  int n2; // [esp+5Ch] [ebp-8Ch] BYREF
  int n1; // [esp+60h] [ebp-88h] BYREF
  int v; // [esp+64h] [ebp-84h] BYREF
  char v31[100]; // [esp+68h] [ebp-80h] BYREF
  unsigned int v32; // [esp+CCh] [ebp-1Ch]

  cp_0 = cp;
  v32 = __readgsdword(0x14u);
  v = 0;
  if ( current_not_defined() )
    return 0;
  solved = solved_equation(cur_equation);
  i = next_espace();
  v1 = 0;
  v2 = 0;
  while ( 1 )
  {
    if ( !strcmp_tospace(cp_0, "definite") )
    {
      v2 = 1;
      goto LABEL_7;
    }
    if ( strcmp_tospace(cp_0, "constant") )
      break;
    v1 = 1;
LABEL_7:
    cp_0 = skip_param(cp_0);
  }
  v26 = v1;
  v23 = v2;
  if ( v1 && v2 )
  {
    error("Conflicting options given.");
    return 0;
  }
  if ( n_rhs[cur_equation] )
  {
    v4 = rhs[cur_equation];
    v5 = &n_rhs[cur_equation];
    v6 = rhs[i];
    np = &n_rhs[i];
  }
  else
  {
    v4 = lhs[cur_equation];
    v5 = &n_lhs[cur_equation];
    v6 = lhs[i];
    np = &n_lhs[i];
  }
  if ( !*cp_0 )
  {
    integrate_order = 1.0;
    goto LABEL_26;
  }
  if ( isvarchar(*cp_0) )
  {
    cp_0 = parse_var2(&v, cp_0);
    if ( !cp_0 )
      return 0;
  }
  if ( !*cp_0 )
  {
    integrate_order = 1.0;
    goto LABEL_21;
  }
  integrate_order = strtod(cp_0, &cp_0);
  if ( *cp_0 || integrate_order <= 0.0 )
  {
LABEL_24:
    error("The order must be a positive integer.");
    return 0;
  }
LABEL_21:
  v7 = integrate_order;
  do
    v7 = __FPREM__(v7, 1.0);
  while ( v9 );
  if ( v7 != 0.0 )
    goto LABEL_24;
LABEL_26:
  if ( !v && !prompt_var(&v) )
    return 0;
  if ( debug_level >= 0 )
  {
    list_var(v, 0);
    if ( n_rhs[cur_equation] )
      __printf_chk(1, "Integrating the RHS with respect to (%s)", var_str);
    else
      __printf_chk(1, "Integrating with respect to (%s)", var_str);
    if ( integrate_order != 1.0 )
      __printf_chk(1, " %.*g times", precision, integrate_order);
    __printf_chk(1, " and simplifying...\n");
  }
  partial_flag = 0;
  uf_simp(v4, v5);
  partial_flag = 1;
  factorv(v4, v5, v);
  memmove(v6, v4, 16 * *v5);
  n1 = *v5;
  v10 = 0;
  if ( integrate_order <= 0.0 )
  {
LABEL_49:
    if ( !v23 )
    {
LABEL_61:
      simpa_side(v6, &n1, 0, 0);
      *np = n1;
      if ( n_rhs[cur_equation] )
      {
        memmove(lhs[i], lhs[cur_equation], 16 * n_lhs[cur_equation]);
        n_lhs[i] = n_lhs[cur_equation];
        if ( solved )
        {
          if ( isvarchar(39) )
          {
            v18 = list_var(lhs[i]->token.variable, 0);
            v19 = (char *)&unk_80797FF + v18;
            for ( j = 0; integrate_order > (long double)j && v18 - j > 0 && *v19 == 39; ++j )
              *v19-- = 0;
            parse_var((int *)&lhs[i]->token, var_str);
          }
        }
      }
      cur_equation = i;
      return return_result(i);
    }
    my_strlcpy(prompt_str, "Enter lower bound: ", 80);
    if ( get_expr(tlhs, &n_tlhs) )
    {
      my_strlcpy(prompt_str, "Enter upper bound: ", 80);
      if ( get_expr(trhs, &n_trhs) )
      {
        memmove(scratch, v6, 16 * n1);
        n2 = n1;
        subst_var_with_exp(scratch, &n2, tlhs, n_tlhs, v);
        subst_var_with_exp(v6, &n1, trhs, n_trhs, v);
        if ( n2 + n1 + 1 > n_tokens )
          error_huge();
        if ( n1 > 0 )
        {
          v15 = v6;
          for ( k = 0; k < n1; ++k )
          {
            ++v15->level;
            ++v15;
          }
        }
        if ( n2 > 0 )
        {
          for ( l = 0; l < n2; ++l )
            ++scratch[l].level;
        }
        v6[n1].kind = OPERATOR;
        v6[n1].level = 1;
        v6[n1++].token.variable = 2;
        memmove(&v6[n1], scratch, 16 * n2);
        n1 += n2;
        goto LABEL_61;
      }
    }
    return 0;
  }
  while ( int_dispatch(v6, &n1, v, (int (*)(...))integrate_sub) )
  {
    if ( v26 )
    {
      if ( n1 + 2 > n_tokens )
        error_huge();
      v11 = n1;
      if ( n1 > 0 )
      {
        v12 = v6;
        for ( m = 0; m < n1; ++m )
        {
          ++v12->level;
          v11 = n1;
          ++v12;
        }
      }
      v6[v11].kind = OPERATOR;
      v6[n1].level = 1;
      v6[n1++].token.variable = 1;
      v6[n1].kind = VARIABLE;
      v6[n1].level = 1;
      __snprintf_chk(v31, 100, 1, 100, "C_%d", constant_var_number);
      if ( !parse_var((int *)&v6[n1].token, v31) )
        return 0;
      ++n1;
      v14 = 1;
      if ( constant_var_number + 1 >= 0 )
        v14 = constant_var_number + 1;
      constant_var_number = v14;
    }
    simp_loop(v6, &n1);
    if ( integrate_order <= (long double)++v10 )
      goto LABEL_49;
  }
  error("Integration failed, not a polynomial.");
  return 0;
}
// 806C2AE: variable 'v9' is possibly undefined
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0806C8F0) --------------------------------------------------------
int __cdecl get_constant(token_type *p1, int n, double *dp)
{
  int v4; // ebx
  token_type *v5; // eax
  int v6; // eax
  int v7; // edi
  int i; // ecx
  int v9; // ebx
  int *v10; // eax
  int v11; // edx
  int prev_approx_flag; // [esp+28h] [ebp-30h]
  int prev_approx_flaga; // [esp+28h] [ebp-30h]
  token_type *v14; // [esp+2Ch] [ebp-2Ch]
  double d2; // [esp+30h] [ebp-28h] BYREF
  double d1[4]; // [esp+38h] [ebp-20h] BYREF

  if ( n <= 0 || (n & 1) == 0 )
    error_bug("Call to get_constant() has invalid expression length.");
  if ( n == 1 )
  {
    if ( p1->kind == CONSTANT )
    {
      *dp = p1->token.constant;
      return 1;
    }
    if ( p1->kind == VARIABLE )
      return var_is_const(p1->token.variable, dp) != 0;
  }
  else if ( n > 2 )
  {
    v14 = p1 + 1;
    v4 = p1[1].level;
    if ( get_constant(p1, 1, d1) )
    {
      if ( v14->kind == OPERATOR )
      {
        v7 = p1[1].level;
        if ( v4 >= v7 )
        {
          prev_approx_flag = 1;
          for ( i = 1; ; i = v9 )
          {
            v9 = i + 2;
            if ( n > i + 2 && v7 < p1[v9].level )
            {
              v10 = &p1[i + 4].level;
              do
              {
                v9 += 2;
                if ( n <= v9 )
                  break;
                v11 = *v10;
                v10 += 8;
              }
              while ( v11 > v7 );
            }
            if ( !get_constant(&p1[prev_approx_flag + 1], v9 + ~i, &d2) )
              break;
            prev_approx_flaga = approximate_roots;
            approximate_roots = 1;
            if ( !calc(0, d1, v14->token.variable, d2) )
            {
              approximate_roots = prev_approx_flaga;
              return 0;
            }
            approximate_roots = prev_approx_flaga;
            if ( v14->token.variable == 6 && !domain_check )
              return 0;
            domain_check = 0;
            if ( n <= v9 )
            {
              *dp = d1[0];
              return 1;
            }
            prev_approx_flag = v9;
            v5 = &p1[v9];
            v14 = v5;
            if ( v5->kind != OPERATOR )
              return 0;
            v6 = v5->level;
            if ( v6 > v7 )
              return 0;
            v7 = v6;
          }
        }
      }
    }
  }
  return 0;
}
// 806C99E: conditional instruction was optimized away because of '%n.4>=3'

//----- (0806CAE3) --------------------------------------------------------
int __cdecl parse_complex(token_type *p1, int n, complexs_0 *cp)
{
  token_type *v4; // ebx
  kind_list v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int level; // [esp+20h] [ebp-48h]
  int times_cnt; // [esp+24h] [ebp-44h]
  int plus_cnt; // [esp+28h] [ebp-40h]
  int imag_cnt; // [esp+2Ch] [ebp-3Ch]
  int v14; // [esp+30h] [ebp-38h]
  token_type *v15; // [esp+34h] [ebp-34h]
  int j; // [esp+38h] [ebp-30h]
  token_type *v17; // [esp+3Ch] [ebp-2Ch]
  complexs_0 c; // [esp+40h] [ebp-28h] BYREF

  if ( get_constant(p1, n, &c.re) )
  {
    c.im = 0.0;
    *cp = c;
    return 1;
  }
  level = min_level(p1, n);
  c.re = 0.0;
  c.im = 1.0;
  j = n - 1;
  if ( n - 1 < 0 )
    return 0;
  v4 = &p1[n - 1];
  v15 = &p1[n];
  v17 = v15 - 2;
  v14 = 0;
  times_cnt = 0;
  plus_cnt = 0;
  imag_cnt = 0;
  while ( 1 )
  {
    v5 = v4->kind;
    if ( v4->kind == VARIABLE )
    {
      if ( !var_is_const(v4->token.variable, 0) )
      {
        if ( v4->token.variable != 3 )
          return 0;
        ++imag_cnt;
      }
      goto LABEL_45;
    }
    if ( v5 )
      break;
LABEL_45:
    ++v14;
    --v4;
    --v15;
    --v17;
    if ( --j < 0 )
      goto done;
  }
  if ( v5 != OPERATOR )
    return 0;
  v6 = v4->level;
  v7 = v4->token.variable;
  if ( v7 == 2 )
  {
    if ( imag_cnt )
      c.im = -c.im;
  }
  else
  {
    if ( v7 > 2 )
    {
      if ( v7 == 3 )
      {
        if ( ++times_cnt > 1 )
          return 0;
        v8 = v17->level;
        if ( v8 != v6 || v8 != v15->level )
          return 0;
        if ( v17->kind == VARIABLE && v17->token.variable == 3 )
        {
          if ( !get_constant(v15, 1, &c.im) )
            return 0;
        }
        else if ( v15->kind != VARIABLE || v15->token.variable != 3 || !get_constant(v17, 1, &c.im) )
        {
          return 0;
        }
      }
      else
      {
        if ( v7 != 4 )
          return 0;
        if ( ++times_cnt > 1 )
          return 0;
        v9 = v17->level;
        if ( v9 != v6
          || v9 != v15->level
          || v17->kind != VARIABLE
          || v17->token.variable != 3
          || !get_constant(v15, 1, &c.im) )
        {
          return 0;
        }
        c.im = 1.0 / c.im;
      }
      goto LABEL_45;
    }
    if ( v7 != 1 )
      return 0;
  }
  if ( ++plus_cnt > 1 || level != v6 )
    return 0;
  if ( !get_constant(p1, j, &c.re) )
  {
    if ( !get_constant(v15, v14, &c.re) )
      return 0;
    if ( v4->token.variable == 2 )
      c.re = -c.re;
    goto LABEL_45;
  }
done:
  if ( imag_cnt == 1 )
  {
    *cp = c;
    return 1;
  }
  return 0;
}

//----- (0806CDD7) --------------------------------------------------------
int __cdecl complex_root_simp(token_type *equation, int *np)
{
  int v2; // edi
  token_type *v3; // esi
  int v4; // ebx
  int v5; // eax
  int *v6; // edx
  int v7; // ecx
  int v8; // edi
  int *v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // esi
  token_type *v13; // eax
  int v14; // ebx
  token_type *v15; // eax
  token_type *v16; // eax
  token_type *v17; // eax
  int modified; // [esp+3Ch] [ebp-5Ch]
  int len; // [esp+44h] [ebp-54h]
  token_type *v21; // [esp+48h] [ebp-50h]
  int v22; // [esp+4Ch] [ebp-4Ch]
  complexs_0 r; // [esp+50h] [ebp-48h] BYREF
  complexs_0 p; // [esp+60h] [ebp-38h] BYREF
  complexs_0 c; // [esp+70h] [ebp-28h] BYREF

  for ( modified = 0; ; modified = 1 )
  {
    v2 = *np;
    if ( *np <= 1 )
      break;
    v3 = equation + 2;
    v22 = 1;
    while ( 1 )
    {
      if ( v3[-1].token.variable == 6 )
      {
        v4 = v3[-1].level;
        v5 = v22 + 2;
        if ( v2 > v22 + 2 && v4 <= v3[1].level )
        {
          v6 = &v3[3].level;
          do
          {
            v5 += 2;
            if ( v5 >= v2 )
              break;
            v7 = *v6;
            v6 += 8;
          }
          while ( v4 <= v7 );
        }
        len = v5 + ~v22;
        if ( parse_complex(v3, len, &p) )
        {
          v8 = v22 - 1;
          if ( v22 - 1 >= 0 && v4 <= v3[-2].level )
          {
            v9 = &v3[-3].level;
            do
            {
              if ( --v8 < 0 )
                break;
              v10 = *v9;
              v9 -= 4;
            }
            while ( v4 <= v10 );
          }
          v11 = v8 + 1;
          v21 = &equation[v11];
          if ( parse_complex(v21, v22 - v11, &c) )
          {
            if ( c.im != 0.0 || p.im != 0.0 )
              break;
          }
        }
      }
      v22 += 2;
      v2 = *np;
      v3 += 2;
      if ( *np <= v22 )
        goto LABEL_23;
    }
    v12 = v22 + len + 1;
    complex_pow(&r, c, p);
    if ( v11 - v12 + *np + 5 > n_tokens )
      error_huge();
    memmove(&equation[v11 + 5], &equation[v12], 16 * (*np - v12));
    *np += v11 - v12 + 5;
    v21->level = v4;
    v21->kind = CONSTANT;
    v21->token.constant = r.re;
    v13 = &equation[v11 + 1];
    v13->level = v4;
    v13->kind = OPERATOR;
    v13->token.variable = 1;
    v14 = v4 + 1;
    v15 = &equation[v11 + 2];
    v15->level = v14;
    v15->kind = CONSTANT;
    v15->token.constant = r.im;
    v16 = &equation[v11 + 3];
    v16->level = v14;
    v16->kind = OPERATOR;
    v16->token.variable = 3;
    v17 = &equation[v11 + 4];
    v17->level = v14;
    v17->kind = VARIABLE;
    v17->token.variable = 3;
  }
LABEL_23:
  if ( modified )
    warning("Complex number roots approximated.");
  return modified;
}

//----- (0806D04B) --------------------------------------------------------
void __cdecl approximate_complex_roots(token_type *equation, int *np)
{
  do
    elim_loop(equation, np);
  while ( complex_root_simp(equation, np) );
}

//----- (0806D07C) --------------------------------------------------------
void __cdecl rect_to_polar(double x, double y, double *radiusp, double *thetap)
{
  *radiusp = sqrt(x * x + y * y);
  *thetap = atan2(y, x);
}

//----- (0806D0AE) --------------------------------------------------------
int __cdecl roots_cmd(char *cp)
{
  char v1; // si
  long double v2; // fst6
  char v4; // c2
  char *v6; // esi
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  double radius_root; // [esp+30h] [ebp-1098h]
  char kb; // [esp+38h] [ebp-1090h]
  double k; // [esp+38h] [ebp-1090h]
  double ka; // [esp+38h] [ebp-1090h]
  double root; // [esp+40h] [ebp-1088h]
  double d; // [esp+48h] [ebp-1080h]
  double db; // [esp+48h] [ebp-1080h]
  double da; // [esp+48h] [ebp-1080h]
  complexs_0 v19; // [esp+50h] [ebp-1078h] BYREF
  char *cp_0[3]; // [esp+6Ch] [ebp-105Ch] BYREF
  complexs_0 check; // [esp+78h] [ebp-1050h] BYREF
  complexs_0 c2; // [esp+88h] [ebp-1040h] BYREF
  double theta; // [esp+98h] [ebp-1030h] BYREF
  double radius; // [esp+A0h] [ebp-1028h] BYREF
  char buf[4096]; // [esp+ACh] [ebp-101Ch] BYREF
  unsigned int v26; // [esp+10ACh] [ebp-1Ch]

  cp_0[0] = cp;
  v26 = __readgsdword(0x14u);
  radius_root = 0.0;
  while ( 1 )
  {
    if ( !*cp_0[0] )
    {
      my_strlcpy(prompt_str, "Enter root (positive integer): ", 80);
      cp_0[0] = get_string(buf, 4096);
      if ( !cp_0[0] )
        return 0;
    }
    root = strtod(cp_0[0], cp_0);
    if ( *cp_0[0] )
    {
      v1 = *cp_0[0];
      if ( ((*__ctype_b_loc())[v1] & 0x2000) == 0 )
        goto LABEL_11;
    }
    if ( root < 0.0 )
      goto LABEL_11;
    if ( root > 10000.0 )
      goto LABEL_11;
    v2 = root;
    do
      v2 = __FPREM__(v2, 1.0);
    while ( v4 );
    if ( v2 != 0.0 )
    {
LABEL_11:
      __printf_chk(1, "Root must be a positive integer less than or equal to %.0f.\n", (double)10000.0);
      return 0;
    }
    cp_0[0] = skip_space(cp_0[0]);
    if ( !*cp_0[0] )
    {
      my_strlcpy(prompt_str, "Enter real part (X): ", 80);
      cp_0[0] = get_string(buf, 4096);
      if ( !cp_0[0] )
        return 0;
    }
    d = strtod(cp_0[0], cp_0);
    v6 = cp_0[0];
    if ( *cp_0[0] )
    {
      kb = *cp_0[0];
      if ( ((*__ctype_b_loc())[kb] & 0x2000) == 0 )
      {
LABEL_16:
        error("Number expected.");
        return 0;
      }
    }
    cp_0[0] = skip_space(v6);
    if ( !*cp_0[0] )
    {
      my_strlcpy(prompt_str, "Enter imaginary part (Y): ", 80);
      cp_0[0] = get_string(buf, 4096);
      if ( !cp_0[0] )
        return 0;
    }
    k = strtod(cp_0[0], cp_0);
    if ( *cp_0[0] )
      goto LABEL_16;
    if ( d == 0.0 && k == 0.0 )
      return repeat_flag;
    *__errno_location() = 0;
    rect_to_polar(d, k, &radius, &theta);
    if ( root != 0.0 )
    {
      radius_root = pow(radius, 1.0 / root);
      check_err();
      __fprintf_chk(
        gfp,
        1,
        "\nThe polar coordinates are:\n%.*g amplitude and %.*g radians (%.*g degrees).\n\n",
        precision,
        radius,
        precision,
        theta,
        precision,
        (double)(theta * 180.0 / 3.141592653589793));
LABEL_26:
      if ( k == 0.0 )
        __fprintf_chk(gfp, 1, "The %.12g roots of (%.12g)^(1/%.12g) are:\n\n", root, d, root);
      else
        __fprintf_chk(gfp, 1, "The %.12g roots of (%.12g%+.12g*i)^(1/%.12g) are:\n\n", root, d, k, root);
      if ( root > 0.0 )
      {
        ka = 0.0;
        while ( 1 )
        {
          db = ((ka + ka) * 3.141592653589793 + theta) / root;
          c2.re = cos(db) * radius_root;
          c2.im = sin(db) * radius_root;
          complex_fixup(&c2);
          if ( c2.re == 0.0 )
          {
            v7 = c2.re;
            if ( c2.im != 0.0 )
              goto LABEL_36;
          }
          else
          {
            v7 = c2.re;
          }
          __fprintf_chk(gfp, 1, "%.12g ", (double)v7);
LABEL_36:
          if ( c2.im != 0.0 )
            __fprintf_chk(gfp, 1, "%+.12g*i", c2.im);
          __fprintf_chk(gfp, 1, "\n");
          check = c2;
          if ( root > 1.0 )
          {
            da = 1.0;
            do
            {
              complex_mult(&v19, check, c2);
              check = v19;
              v8 = da + 1.0;
              da = v8;
            }
            while ( root > v8 );
          }
          complex_fixup(&check);
          __printf_chk(1, "Inverse check:");
          if ( check.re != 0.0 )
          {
            v9 = check.re;
LABEL_45:
            __printf_chk(1, " %.10g", (double)v9);
            goto LABEL_46;
          }
          v9 = check.re;
          if ( check.im == 0.0 )
            goto LABEL_45;
LABEL_46:
          if ( check.im != 0.0 )
            __printf_chk(1, " %+.10g*i", check.im);
          __printf_chk(1, "\n\n");
          v10 = ka + 1.0;
          ka = v10;
          if ( root <= v10 )
            goto LABEL_49;
        }
      }
      goto LABEL_49;
    }
    check_err();
    __fprintf_chk(
      gfp,
      1,
      "\nThe polar coordinates are:\n%.*g amplitude and %.*g radians (%.*g degrees).\n\n",
      precision,
      radius,
      precision,
      theta,
      precision,
      (double)(theta * 180.0 / 3.141592653589793));
    if ( root != 0.0 )
      goto LABEL_26;
LABEL_49:
    if ( !repeat_flag )
      return 1;
  }
}
// 806D196: variable 'v4' is possibly undefined
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806D830) --------------------------------------------------------
int __cdecl complex_fixup(complexs_0 *ap)
{
  int result; // eax

  if ( fabs(ap->re * 5.0e-14) <= fabs(ap->im) )
  {
    result = 0;
    if ( fabs(ap->im * 5.0e-14) > fabs(ap->re) )
    {
      ap->re = 0.0;
      LOBYTE(result) = 1;
    }
  }
  else
  {
    ap->im = 0.0;
    result = 1;
  }
  return result;
}

//----- (0806D882) --------------------------------------------------------
complexs_0 *__userpurge complex_add@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b)
{
  complexs_0 *result; // eax

  result = retstr;
  retstr->im = a.im + b.im;
  retstr->re = a.re + b.re;
  return result;
}

//----- (0806D89D) --------------------------------------------------------
complexs_0 *__userpurge complex_negate@<eax>(complexs_0 *retstr, complexs_0 a)
{
  complexs_0 *result; // eax

  result = retstr;
  retstr->im = -a.im;
  retstr->re = -a.re;
  return result;
}

//----- (0806D8B6) --------------------------------------------------------
complexs_0 *__userpurge complex_mult@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b)
{
  complexs_0 *result; // eax

  result = retstr;
  retstr->im = a.re * b.im + a.im * b.re;
  retstr->re = a.re * b.re - a.im * b.im;
  return result;
}

//----- (0806D8E3) --------------------------------------------------------
complexs_0 *__userpurge complex_div@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b)
{
  long double v3; // fst7
  complexs_0 num; // [esp+34h] [ebp-18h] BYREF

  b.im = -b.im;
  complex_mult(&num, a, b);
  v3 = num.re / (b.re * b.re + b.im * b.im);
  retstr->im = num.im / (b.re * b.re + b.im * b.im);
  retstr->re = v3;
  return retstr;
}

//----- (0806D968) --------------------------------------------------------
complexs_0 *__userpurge complex_exp@<eax>(complexs_0 *retstr, complexs_0 a)
{
  long double v2; // fst7
  double v4; // [esp+10h] [ebp-28h]
  double v5; // [esp+18h] [ebp-20h]
  double v6; // [esp+20h] [ebp-18h] BYREF
  double v7[2]; // [esp+28h] [ebp-10h] BYREF

  sincos(LODWORD(a.im), HIDWORD(a.im), v7, &v6);
  v5 = v6;
  v4 = v7[0];
  v2 = exp(a.re);
  retstr->im = v4 * v2;
  retstr->re = v2 * v5;
  return retstr;
}
// 80492A4: using guessed type int __cdecl sincos(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0806D9B9) --------------------------------------------------------
complexs_0 *__userpurge complex_log@<eax>(complexs_0 *retstr, complexs_0 a)
{
  double v3; // [esp+18h] [ebp-20h]

  v3 = log(a.re * a.re + a.im * a.im);
  retstr->im = atan2(a.im, a.re);
  retstr->re = v3 * 0.5;
  return retstr;
}

//----- (0806DA0F) --------------------------------------------------------
complexs_0 *__userpurge complex_pow@<eax>(complexs_0 *retstr, complexs_0 a, complexs_0 b)
{
  complexs_0 v4; // [esp+30h] [ebp-38h] BYREF
  complexs_0 r; // [esp+40h] [ebp-28h] BYREF

  complex_log(&v4, a);
  r = v4;
  complex_mult(&v4, v4, b);
  r = v4;
  complex_exp(&v4, v4);
  r = v4;
  complex_fixup(&r);
  *retstr = r;
  return retstr;
}

//----- (0806DB10) --------------------------------------------------------
char *__cdecl var_name(int v)
{
  unsigned int v1; // edx
  char *result; // eax

  v1 = (v & 0x3FFF) - 65;
  result = 0;
  if ( v1 <= 0x1F3F )
    result = var_names[v1];
  return result;
}

//----- (0806DB35) --------------------------------------------------------
void __usercall trim_zeros(char *buf@<eax>)
{
  unsigned int v2; // ecx
  unsigned int v3; // eax
  int v4; // ecx
  char *v5; // edx
  char v6; // al

  v2 = strlen(buf) + 1;
  v3 = v2 - 1;
  v4 = v2 - 2;
  if ( v4 >= 0 )
  {
    v5 = &buf[v3];
    do
    {
      v6 = *(v5 - 1);
      if ( v6 != 48 )
      {
        if ( v6 != 46 )
          return;
        v5[1] = 0;
      }
      --v5;
      --v4;
    }
    while ( v4 >= 0 );
  }
}

//----- (0806DB71) --------------------------------------------------------
int __cdecl int_expr(token_type *p1, int n)
{
  int i; // esi
  long double v4; // fst5
  char v6; // c2

  if ( n > 0 )
  {
    for ( i = 0; n > i; ++i )
    {
      if ( p1->kind )
      {
        if ( p1->kind == VARIABLE && p1->token.variable <= 2 )
          return 0;
      }
      else
      {
        v4 = p1->token.constant;
        do
          v4 = __FPREM__(v4, 1.0);
        while ( v6 );
        if ( v4 != 0.0 )
          return 0;
      }
      ++p1;
    }
  }
  return 1;
}
// 806DBA2: variable 'v6' is possibly undefined

//----- (0806DC02) --------------------------------------------------------
int __cdecl list_var(int v, int lang_code)
{
  char *v2; // eax
  int v3; // ebx
  int v5; // esi
  char v6; // bl
  int v7; // esi

  var_str[0] = 0;
  switch ( v & 0x3FFF )
  {
    case 0:
      return strlen(var_str);
    case 1:
      switch ( lang_code )
      {
        case -3:
          v3 = 0;
          v2 = "exp(1.0)";
          goto LABEL_26;
        case -1:
          v2 = "%e";
          goto LABEL_41;
        case 0:
          v2 = "e#";
          goto LABEL_41;
        case 1:
          v2 = "M_E";
          goto LABEL_41;
        case 2:
          v2 = "Math.E";
          goto LABEL_41;
        case 3:
          v2 = "math.e";
          goto LABEL_41;
        default:
          v2 = "%e" + 1;
          goto LABEL_41;
      }
    case 2:
      v2 = "pi";
      switch ( lang_code )
      {
        case -1:
          v3 = 0;
          v2 = "%pi";
          goto LABEL_26;
        case 0:
          v2 = "pi#";
          goto LABEL_41;
        case 1:
          v2 = "M_PI";
          goto LABEL_41;
        case 2:
          v2 = "Math.PI";
          goto LABEL_41;
        case 3:
          v2 = "math.pi";
          goto LABEL_41;
        default:
          goto LABEL_41;
      }
    case 3:
      switch ( lang_code )
      {
        case -3:
          v3 = 0;
          v2 = "{0,1}";
          goto LABEL_26;
        case -2:
          v2 = (char *)&unk_8077991;
          goto LABEL_41;
        case -1:
          v2 = (char *)&unk_8077990;
          goto LABEL_41;
        case 0:
          v2 = (_BYTE *)("pi#" + 1);
          goto LABEL_41;
        case 3:
          v2 = "1j";
          goto LABEL_41;
        default:
          v2 = "1.0i";
          goto LABEL_41;
      }
    case 4:
      v3 = 0;
      v2 = "sign";
      goto LABEL_26;
    case 5:
      v2 = "all";
LABEL_41:
      v3 = 0;
      goto LABEL_27;
    default:
      v2 = var_name(v);
      v3 = 1;
LABEL_26:
      if ( v2 )
      {
LABEL_27:
        v5 = (v >> 14) & 0x3F;
        if ( v5 )
          __snprintf_chk(var_str, 180, 1, 180, "%s%d", v2, v5 - 1);
        else
          my_strlcpy(var_str, v2, 180);
      }
      else
      {
        my_strlcpy(var_str, "bad_variable", 180);
      }
      if ( v3 )
      {
        if ( lang_code )
        {
          v6 = var_str[0];
          if ( var_str[0] )
          {
            v7 = 0;
            do
            {
              if ( v6 != 95 && ((*__ctype_b_loc())[v6] & 8) == 0 )
                var_str[v7] = 95;
              v6 = var_str[++v7];
            }
            while ( v6 );
          }
        }
      }
      return strlen(var_str);
  }
}
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0806DE45) --------------------------------------------------------
int __cdecl list_code(token_type *equation, int *np, language_list language, int int_flag)
{
  int v4; // eax
  token_type *v5; // esi
  int v6; // edi
  token_type *v7; // edx
  int v8; // eax
  token_type *v9; // edx
  int v10; // ecx
  token_type *v11; // eax
  int v12; // eax
  int v13; // ecx
  kind_list v14; // eax
  const char *v15; // eax
  int v16; // ebx
  int v17; // esi
  int min1; // [esp+30h] [ebp-258h]
  token_type *v20; // [esp+38h] [ebp-250h]
  int i; // [esp+48h] [ebp-240h]
  int v22; // [esp+58h] [ebp-230h]
  int k; // [esp+5Ch] [ebp-22Ch]
  int v24; // [esp+60h] [ebp-228h]
  int i1; // [esp+64h] [ebp-224h]
  int v26; // [esp+68h] [ebp-220h]
  char buf[500]; // [esp+78h] [ebp-210h] BYREF
  unsigned int v28; // [esp+26Ch] [ebp-1Ch]

  v28 = __readgsdword(0x14u);
  min1 = min_level(equation, *np) - (*np >= 2);
  v24 = 0;
  if ( *np > 0 )
  {
    v26 = min1;
    i = 0;
    do
    {
      v20 = &equation[i];
      v22 = v26 - v20->level;
      k = abs32(v22);
      if ( k > 0 )
      {
        for ( i1 = 1; i1 <= k; ++i1 )
        {
          if ( v22 <= 0 )
          {
            ++v26;
            if ( i + 1 < *np )
            {
              v4 = equation[i + 1].level;
              if ( v26 <= v4 )
              {
                v5 = &equation[i + 1];
                v6 = i + 1;
                if ( v26 == v4 )
                {
LABEL_12:
                  v8 = v5->token.variable;
                  if ( v8 == 6 )
                  {
                    v9 = &equation[v6 - 1];
                    v10 = v9->level;
                    if ( v10 == v26
                      && (v11 = &equation[v6 + 1], v10 == equation[v6 + 1].level)
                      && v11->kind == CONSTANT
                      && equation[v6 + 1].token.constant == 2.0 )
                    {
                      v5->token.variable = 3;
                      qmemcpy(v11, v9, sizeof(token_type));
                    }
                    else if ( !int_flag )
                    {
                      if ( language == C )
                      {
                        v24 += __fprintf_chk(gfp, 1, "pow");
                      }
                      else if ( language == JAVA )
                      {
                        v24 += __fprintf_chk(gfp, 1, "Math.pow");
                      }
                    }
                  }
                  else if ( v8 == 7 )
                  {
                    v24 += __fprintf_chk(gfp, 1, "fact");
                  }
                }
                else
                {
                  v7 = &equation[i + 3];
                  v12 = i + 1;
                  while ( 1 )
                  {
                    v12 += 2;
                    if ( *np <= v12 )
                      break;
                    v6 = v12;
                    v5 = v7;
                    v13 = v7->level;
                    if ( v26 > v13 )
                      break;
                    v7 += 2;
                    if ( v26 == v13 )
                      goto LABEL_12;
                  }
                }
              }
            }
            v24 += __fprintf_chk(gfp, 1, "(");
          }
          else
          {
            --v26;
            v24 += __fprintf_chk(gfp, 1, ")");
          }
        }
      }
      v14 = v20->kind;
      if ( v20->kind == VARIABLE )
      {
        if ( int_flag && (unsigned int)(language - 1) <= 1 && v20->token.variable == 3 )
        {
          v24 += __fprintf_chk(gfp, 1, "1i");
        }
        else
        {
          list_var(v20->token.variable, language);
          v24 += __fprintf_chk(gfp, 1, "%s", var_str);
        }
      }
      else if ( v14 )
      {
        if ( v14 == OPERATOR )
        {
          switch ( v20->token.variable )
          {
            case 1:
              v15 = " + ";
              break;
            case 2:
              v15 = " - ";
              break;
            case 3:
              v15 = "*";
              break;
            case 4:
            case 9:
              v15 = "/";
              break;
            case 5:
              v15 = " % ";
              break;
            case 6:
              if ( int_flag || (v15 = ", ", language == PYTHON) )
                v15 = "**";
              break;
            case 7:
              ++i;
              v15 = "; This file can be edited.\n\n" + 28;
              break;
            default:
              v15 = "(unknown operator)";
              break;
          }
          v24 += __fprintf_chk(gfp, 1, "%s", v15);
        }
      }
      else
      {
        if ( v20->token.constant == 0.0 )
          v20->token.constant = 0.0;
        if ( int_flag )
        {
          __snprintf_chk(buf, 500, 1, 500, "%.0f", v20->token.constant);
        }
        else
        {
          __snprintf_chk(buf, 500, 1, 500, "%#.*g", 15, v20->token.constant);
          trim_zeros(buf);
        }
        if ( v20->token.constant >= 0.0 )
          v24 += __fprintf_chk(gfp, 1, "%s", buf);
        else
          v24 += __fprintf_chk(gfp, 1, "(%s)", buf);
      }
      ++i;
    }
    while ( *np > i );
    v16 = v26 - min1;
    if ( v26 - min1 > 0 )
    {
      v17 = v24;
      do
      {
        v17 += __fprintf_chk(gfp, 1, ")");
        --v16;
      }
      while ( v16 > 0 );
      v24 = v17;
    }
  }
  return v24;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0806E42E) --------------------------------------------------------
int __cdecl list_c_equation(int en, language_list language, int int_flag)
{
  int v3; // esi
  int v5; // [esp+1Ch] [ebp-1Ch]

  v3 = 0;
  if ( n_lhs[en] > 0 )
  {
    v3 = list_code(lhs[en], &n_lhs[en], language, int_flag);
    if ( n_rhs[en] )
    {
      v5 = __fprintf_chk(gfp, 1, " = ");
      v3 += v5 + list_code(rhs[en], (int *)(4 * en + 134715712), language, int_flag);
    }
    if ( (unsigned int)(language - 1) <= 1 )
      v3 += __fprintf_chk(gfp, 1, ";");
    __fprintf_chk(gfp, 1, "\n");
  }
  return v3;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0806E52F) --------------------------------------------------------
void __cdecl set_color(int color)
{
  if ( gfp == stdout && cur_color != color && color_flag )
  {
    if ( html_flag )
    {
      if ( cur_color >= 0 )
        __printf_chk(1, "</font>");
      if ( bold_colors )
        __printf_chk(1, "<font color=\"%s\">", bright_html_carray[color % 7]);
      else
        __printf_chk(1, "<font color=\"%s\">", html_carray[color % 7]);
    }
    else
    {
      __printf_chk(1, "\x1B[%d;%dm", bold_colors, carray[color % 6]);
    }
    cur_color = color;
  }
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0806E66C) --------------------------------------------------------
int __usercall flist_recurse@<eax>(token_type *p1@<eax>, int n@<edx>, int out_flag@<ecx>, int line, int pos, int cur_level, int *highp, int *lowp)
{
  int v8; // ebx
  int v9; // edi
  int v10; // eax
  token_type *v11; // edx
  int v12; // esi
  int v13; // edx
  int *v14; // ecx
  int v15; // ebx
  int v16; // edx
  int v17; // esi
  int i; // ebx
  int v19; // esi
  int v20; // ebx
  int *v21; // eax
  int v22; // edx
  int v23; // eax
  int v24; // ecx
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int j; // ebx
  int v29; // eax
  int v30; // eax
  int v31; // eax
  token_type *v32; // eax
  kind_list v33; // edx
  long double v34; // fst7
  int v35; // ebx
  const char *v36; // eax
  int v37; // ebx
  int v38; // edi
  int v39; // esi
  int v41; // [esp+28h] [ebp-270h]
  int v42; // [esp+2Ch] [ebp-26Ch]
  int v43; // [esp+30h] [ebp-268h]
  _BOOL4 v44; // [esp+34h] [ebp-264h]
  int v45; // [esp+38h] [ebp-260h]
  int v46; // [esp+3Ch] [ebp-25Ch]
  int v47; // [esp+40h] [ebp-258h]
  int v49; // [esp+48h] [ebp-250h]
  int v50; // [esp+48h] [ebp-250h]
  token_type *v51; // [esp+54h] [ebp-244h]
  token_type *v52; // [esp+54h] [ebp-244h]
  token_type *v53; // [esp+54h] [ebp-244h]
  int div_loc; // [esp+58h] [ebp-240h]
  int div_loca; // [esp+58h] [ebp-240h]
  int stop_at; // [esp+60h] [ebp-238h]
  token_type *stop_ata; // [esp+60h] [ebp-238h]
  int len1; // [esp+68h] [ebp-230h]
  int len2; // [esp+6Ch] [ebp-22Ch]
  int len2a; // [esp+6Ch] [ebp-22Ch]
  int oflag; // [esp+70h] [ebp-228h]
  int v64; // [esp+74h] [ebp-224h]
  int v65; // [esp+78h] [ebp-220h]
  int v66; // [esp+78h] [ebp-220h]
  int k; // [esp+7Ch] [ebp-21Ch]
  int ka; // [esp+7Ch] [ebp-21Ch]
  int low; // [esp+80h] [ebp-218h] BYREF
  int high; // [esp+84h] [ebp-214h] BYREF
  char buf[500]; // [esp+88h] [ebp-210h] BYREF
  unsigned int v72; // [esp+27Ch] [ebp-1Ch]

  v8 = line;
  v72 = __readgsdword(0x14u);
  *highp = line;
  *lowp = line;
  v64 = 0;
  if ( n <= 0 )
    return v64;
  oflag = 0;
  if ( out_flag )
    oflag = line == cur_line;
  v44 = 0;
  if ( html_flag )
    v44 = gfp == stdout;
  if ( oflag )
  {
    set_color(cur_level - 1);
    if ( pos > cur_pos )
    {
      do
      {
        __fprintf_chk(gfp, 1, " ");
        ++cur_pos;
      }
      while ( pos > cur_pos );
      v8 = line;
    }
  }
  v45 = v8 + 1;
  v46 = v8 - 1;
  v41 = 2 * (v8 + 1);
  v43 = 2 * (v8 - 1);
  v9 = cur_level;
  stop_at = n;
  v64 = 0;
  len2 = 0;
  div_loc = -1;
  v10 = 0;
  do
  {
LABEL_12:
    v11 = &p1[v10];
    if ( v11->kind == OPERATOR && v11->token.variable == 4 )
    {
      v12 = v11->level;
      v13 = v10 - 2;
      if ( v10 - 2 > 0 && v12 <= p1[v13].level )
      {
        v14 = (int *)&p1[v10 - 3] - 3;
        do
        {
          v13 -= 2;
          if ( v13 <= 0 )
            break;
          v15 = *v14;
          v14 -= 8;
        }
        while ( v12 <= v15 );
      }
      v16 = v13 + 1;
      if ( div_loc < 0 || v16 < stop_at || v16 == stop_at && (stop_at = v16, v12 < p1[div_loc].level) )
      {
        div_loc = v10;
        stop_at = v16;
      }
    }
    ++v10;
  }
  while ( n > v10 );
  v49 = div_loc;
  v51 = &p1[div_loc];
  while ( 1 )
  {
    if ( stop_at == len2 )
    {
      v65 = v9 - v51->level;
      k = abs32(v65) - 1;
    }
    else
    {
      v65 = v9 - p1[len2].level;
      k = abs32(v65);
    }
    if ( k > 0 )
    {
      v17 = v64 + 1;
      for ( i = 1; i <= k; ++i )
      {
        if ( v65 <= 0 )
        {
          v64 = v17;
          if ( oflag )
          {
            set_color(v9);
            __fprintf_chk(gfp, 1, "(");
          }
          ++v9;
        }
        else
        {
          --v9;
          v64 = v17;
          if ( oflag )
          {
            __fprintf_chk(gfp, 1, ")");
            set_color(v9 - 1);
          }
        }
        ++v17;
      }
    }
    if ( stop_at == len2 )
      break;
    v32 = &p1[len2];
    v33 = v32->kind;
    if ( v32->kind == VARIABLE )
    {
      v64 += list_var(v32->token.variable, 0);
      if ( !oflag )
        goto LABEL_113;
      __fprintf_chk(gfp, 1, "%s", var_str);
      v35 = len2;
    }
    else
    {
      if ( v33 == CONSTANT )
      {
        if ( v32->token.constant == 0.0 )
        {
          v34 = 0.0;
          v32->token.constant = 0.0;
          goto LABEL_82;
        }
        v34 = v32->token.constant;
        if ( v34 == -1.0
          && (!len2 || p1[len2 - 1].level < v32->level)
          && (v35 = len2 + 1, n > len2 + 1)
          && v32->level == p1[len2 + 1].level
          && p1[len2 + 1].token.variable == 3 )
        {
          v64 += __snprintf_chk(buf, 500, 1, 500, "-");
        }
        else
        {
LABEL_82:
          if ( finance_option )
          {
            if ( v34 >= 0.0 )
              v64 += __snprintf_chk(buf, 500, 1, 500, "%.*f", finance_option, (double)v34);
            else
              v64 += __snprintf_chk(buf, 500, 1, 500, "(%.*f)", finance_option, (double)v34);
            v35 = len2;
          }
          else if ( v34 >= 0.0 || negate_highest_precedence )
          {
            v64 += __snprintf_chk(buf, 500, 1, 500, "%.*g", precision, (double)v34);
            v35 = len2;
          }
          else
          {
            v64 += __snprintf_chk(buf, 500, 1, 500, "(%.*g)", precision, (double)v34);
            v35 = len2;
          }
        }
        if ( oflag )
          __fprintf_chk(gfp, 1, "%s", buf);
        goto LABEL_114;
      }
      if ( v33 != OPERATOR )
        goto LABEL_113;
      switch ( v32->token.variable )
      {
        case 1:
          v64 += 3;
          v36 = " + ";
          break;
        case 2:
          v36 = " &minus; ";
          if ( !v44 )
            v36 = " - ";
          v64 += 3;
          break;
        case 3:
          v36 = "&middot;";
          if ( !v44 )
            v36 = "**" + 1;
          ++v64;
          break;
        case 4:
          ++v64;
          v36 = "/";
          break;
        case 5:
          v64 += 3;
          v36 = " % ";
          break;
        case 6:
          if ( power_starstar )
          {
            v64 += 2;
            v36 = "**";
          }
          else
          {
            ++v64;
            v36 = "^";
          }
          break;
        case 7:
          ++v64;
          ++len2;
          v36 = "!";
          break;
        case 9:
          v64 += 2;
          v36 = "//";
          break;
        default:
          v64 += 18;
          v36 = "(unknown operator)";
          break;
      }
      if ( !oflag )
      {
LABEL_113:
        v35 = len2;
        goto LABEL_114;
      }
      __fprintf_chk(gfp, 1, "%s", v36);
      v35 = len2;
    }
LABEL_114:
    len2 = v35 + 1;
    if ( n <= v35 + 1 )
      goto LABEL_115;
  }
  v19 = v51->level;
  v66 = pos + v64;
  v47 = div_loc - stop_at;
  v52 = &p1[stop_at];
  len1 = flist_recurse(v52, div_loc - stop_at, 0, v45, pos + v64, v19, &high, &low);
  v42 = low;
  v20 = div_loc + 2;
  if ( n > div_loc + 2 && v19 < p1[v20].level )
  {
    v21 = &p1[div_loc + 4].level;
    do
    {
      v20 += 2;
      if ( n <= v20 )
        break;
      v22 = *v21;
      v21 += 8;
    }
    while ( v19 < v22 );
  }
  div_loca = v20 + ~div_loc;
  stop_ata = &p1[v49 + 1];
  v23 = flist_recurse(stop_ata, div_loca, 0, v46, v66, v19, &high, &low);
  len2a = v23;
  v50 = high;
  v24 = len1;
  if ( v23 >= len1 )
    v24 = v23;
  ka = v24;
  v25 = 0;
  if ( len1 < v24 )
    v25 = (v24 - len1) / 2;
  flist_recurse(v52, v47, out_flag, v41 - v42, v66 + v25, v19, &high, &low);
  v26 = high;
  if ( *highp >= high )
    v26 = *highp;
  *highp = v26;
  v27 = low;
  if ( *lowp <= low )
    v27 = *lowp;
  *lowp = v27;
  if ( oflag )
  {
    set_color(v19 - 1);
    if ( ka > 0 )
    {
      v53 = (token_type *)v20;
      for ( j = 0; j < ka; ++j )
      {
        if ( v44 )
          __fprintf_chk(gfp, 1, "&minus;");
        else
          __fprintf_chk(gfp, 1, "-");
      }
      v20 = (int)v53;
    }
    set_color(v9 - 1);
  }
  v29 = 0;
  if ( len2a < ka )
    v29 = (ka - len2a) / 2;
  flist_recurse(stop_ata, div_loca, out_flag, v43 - v50, v66 + v29, v19, &high, &low);
  v30 = high;
  if ( *highp >= high )
    v30 = *highp;
  *highp = v30;
  v31 = low;
  if ( *lowp <= low )
    v31 = *lowp;
  *lowp = v31;
  v64 += ka;
  if ( n > v20 )
  {
    len2 = v20;
    stop_at = n;
    v10 = v20;
    div_loc = -1;
    goto LABEL_12;
  }
LABEL_115:
  v37 = v9 - cur_level;
  if ( v9 - cur_level > 0 )
  {
    v38 = v9 - 2;
    v39 = v64;
    while ( 1 )
    {
      ++v39;
      --v37;
      if ( oflag )
      {
        __fprintf_chk(gfp, 1, ")");
        if ( v37 <= 0 )
        {
          v64 = v39;
          goto LABEL_126;
        }
        set_color(v38);
      }
      else if ( v37 <= 0 )
      {
        return v39;
      }
      --v38;
    }
  }
  if ( oflag )
LABEL_126:
    cur_pos += v64;
  return v64;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0806F191) --------------------------------------------------------
int __cdecl list_string_sub(token_type *p1, int n, int outflag, char *string, int export_flag)
{
  int v5; // eax
  int v6; // esi
  char *v7; // edi
  int j; // ebx
  kind_list v9; // eax
  const char *v10; // edi
  char *v11; // esi
  int v12; // ebx
  int export_precision; // [esp+34h] [ebp-434h]
  int min1; // [esp+3Ch] [ebp-42Ch]
  int i; // [esp+40h] [ebp-428h]
  token_type *v17; // [esp+44h] [ebp-424h]
  int v18; // [esp+50h] [ebp-418h]
  int k; // [esp+54h] [ebp-414h]
  int v20; // [esp+58h] [ebp-410h]
  int cur_level; // [esp+5Ch] [ebp-40Ch]
  char buf2[500]; // [esp+64h] [ebp-404h] BYREF
  char buf[500]; // [esp+258h] [ebp-210h] BYREF
  unsigned int v24; // [esp+44Ch] [ebp-1Ch]

  v24 = __readgsdword(0x14u);
  if ( string )
    *string = 0;
  export_precision = high_prec == 0 ? 15 : 20;
  v5 = min_level(p1, n);
  min1 = v5;
  v20 = 0;
  if ( n > 0 )
  {
    cur_level = v5;
    i = 0;
    while ( 1 )
    {
      v17 = &p1[i];
      v18 = cur_level - v17->level;
      k = abs32(v18);
      if ( k > 0 )
      {
        v6 = v20 + 1;
        v7 = &string[v20];
        for ( j = 1; j <= k; ++j )
        {
          if ( v18 <= 0 )
          {
            ++cur_level;
            if ( outflag != 0 && export_flag == 0 )
              set_color(cur_level - min1);
            if ( string )
              *(_WORD *)v7 = 40;
            if ( outflag )
              __fprintf_chk(gfp, 1, "%s", "(");
            v20 = v6;
          }
          else
          {
            --cur_level;
            if ( string )
              *(_WORD *)v7 = 41;
            if ( outflag )
              __fprintf_chk(gfp, 1, "%s", ")");
            v20 = v6;
            if ( outflag != 0 && export_flag == 0 )
              set_color(cur_level - min1);
          }
          ++v6;
          ++v7;
        }
      }
      v9 = v17->kind;
      if ( v17->kind == VARIABLE )
      {
        list_var(v17->token.variable, -export_flag);
        if ( string )
          strcpy(&string[v20], var_str);
        if ( outflag )
          __fprintf_chk(gfp, 1, "%s", var_str);
        v20 += strlen(var_str);
        goto LABEL_77;
      }
      if ( v9 )
      {
        if ( v9 == OPERATOR )
        {
          switch ( v17->token.variable )
          {
            case 1:
              v10 = " + ";
              break;
            case 2:
              v10 = " - ";
              break;
            case 3:
              v10 = "**" + 1;
              break;
            case 4:
              v10 = "//" + 1;
              break;
            case 5:
              v10 = " % ";
              break;
            case 6:
              if ( power_starstar || (v10 = "^", export_flag == 3) )
                v10 = "**";
              break;
            case 7:
              ++i;
              v10 = "!";
              break;
            case 9:
              v10 = "//";
              break;
            default:
              v10 = "(unknown operator)";
              break;
          }
          if ( string )
            strcpy(&string[v20], v10);
          if ( outflag )
            __fprintf_chk(gfp, 1, "%s", v10);
          v20 += strlen(v10);
        }
      }
      else
      {
        if ( v17->token.constant == 0.0 )
          v17->token.constant = 0.0;
        if ( export_flag == 3 )
        {
          __snprintf_chk(buf, 500, 1, 500, "%#.*g", 15, v17->token.constant);
          trim_zeros(buf);
        }
        else if ( export_flag || high_prec )
        {
          __snprintf_chk(buf, 500, 1, 500, "%.*g", export_precision, v17->token.constant);
        }
        else
        {
          if ( !finance_option )
          {
            if ( v17->token.constant >= 0.0 || negate_highest_precedence )
              __snprintf_chk(buf, 500, 1, 500, "%.*g", precision, v17->token.constant);
            else
              __snprintf_chk(buf, 500, 1, 500, "(%.*g)", precision, v17->token.constant);
            if ( string )
              strcpy(&string[v20], buf);
            if ( outflag )
              __fprintf_chk(gfp, 1, "%s", buf);
            v20 += strlen(buf);
            goto LABEL_77;
          }
          __snprintf_chk(buf, 500, 1, 500, "%.*f", finance_option, v17->token.constant);
        }
        if ( v17->token.constant >= 0.0 )
        {
          if ( string )
            strcpy(&string[v20], buf);
          if ( outflag )
            __fprintf_chk(gfp, 1, "%s", buf);
          v20 += strlen(buf);
        }
        else
        {
          __snprintf_chk(buf2, 500, 1, 500, "(%s)", buf);
          if ( string )
            strcpy(&string[v20], buf2);
          if ( outflag )
            __fprintf_chk(gfp, 1, "%s", buf2);
          v20 += strlen(buf2);
        }
      }
LABEL_77:
      if ( n <= ++i )
      {
        if ( cur_level - min1 > 0 )
        {
          v11 = &string[v20];
          v12 = cur_level - min1;
          do
          {
            if ( string )
              *(_WORD *)v11 = 41;
            if ( outflag )
              __fprintf_chk(gfp, 1, "%s", ")");
            --v12;
            if ( outflag != 0 && export_flag == 0 )
              set_color(v12);
            ++v11;
          }
          while ( v12 > 0 );
          v20 += cur_level - min1;
        }
        return v20;
      }
    }
  }
  return v20;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0806F95B) --------------------------------------------------------
int __cdecl list_string(token_type *p1, int n, char *string, int export_flag)
{
  return list_string_sub(p1, n, 0, string, export_flag);
}

//----- (0806F98B) --------------------------------------------------------
char *__cdecl list_expression(token_type *p1, int n, int export_flag)
{
  char *v3; // ebx
  int v4; // eax
  char *v5; // eax

  v3 = 0;
  if ( n > 0 )
  {
    v4 = list_string(p1, n, 0, export_flag);
    v5 = (char *)malloc(v4 + 1);
    v3 = v5;
    if ( v5 )
      list_string(p1, n, v5, export_flag);
    else
      error("Out of memory (can't malloc(3)).");
  }
  return v3;
}

//----- (0806FA09) --------------------------------------------------------
char *__cdecl list_equation(int n, int export_flag)
{
  int v2; // eax
  const char *v3; // esi
  int v4; // eax
  int v5; // edx
  char *v6; // eax

  v2 = n_lhs[n];
  v3 = 0;
  if ( v2 > 0 )
  {
    v4 = list_string(lhs[n], v2, 0, export_flag);
    v5 = n_rhs[n];
    if ( v5 )
      v4 += 3 + list_string(rhs[n], v5, 0, export_flag);
    v6 = (char *)malloc(v4 + 2);
    v3 = v6;
    if ( v6 )
    {
      list_string(lhs[n], n_lhs[n], v6, export_flag);
      if ( n_rhs[n] )
      {
        *(_DWORD *)&v3[strlen(v3)] = 2112800;
        list_string(rhs[n], n_rhs[n], (char *)&v3[strlen(v3)], export_flag);
      }
      if ( export_flag == 1 )
        *(_WORD *)&v3[strlen(v3)] = 59;
    }
    else
    {
      error("Out of memory (can't malloc(3)).");
    }
  }
  return (char *)v3;
}

//----- (0806FB4B) --------------------------------------------------------
int __cdecl list_proc(token_type *p1, int n, int export_flag)
{
  return list_string_sub(p1, n, 1, 0, export_flag);
}

//----- (0806FB7C) --------------------------------------------------------
void __cdecl list_debug(int level, token_type *p1, int n1, token_type *p2, int n2)
{
  if ( debug_level >= level )
  {
    __fprintf_chk(gfp, 1, "level %d: ", level);
    list_proc(p1, n1, 0);
    if ( p2 )
    {
      if ( n2 > 0 )
      {
        __fprintf_chk(gfp, 1, " = ");
        list_proc(p2, n2, 0);
      }
    }
    __fprintf_chk(gfp, 1, "\n");
  }
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0806FC38) --------------------------------------------------------
int __cdecl list1_sub(int n, int export_flag)
{
  int v2; // esi
  int v3; // esi
  int v5; // [esp+1Ch] [ebp-1Ch]

  v2 = 0;
  if ( n_lhs[n] > 0 )
  {
    if ( export_flag || high_prec )
      v3 = 0;
    else
      v3 = __fprintf_chk(gfp, 1, "#%d: ", n + 1);
    v2 = list_proc(lhs[n], n_lhs[n], export_flag) + v3;
    if ( n_rhs[n] )
    {
      v5 = __fprintf_chk(gfp, 1, " = ");
      v2 += v5 + list_proc(rhs[n], n_rhs[n], export_flag);
    }
    if ( export_flag == 1 )
      v2 += __fprintf_chk(gfp, 1, ";");
    __fprintf_chk(gfp, 1, "\n");
  }
  return v2;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (0806FD58) --------------------------------------------------------
void default_color()
{
  set_color(0);
}

//----- (0806FD6C) --------------------------------------------------------
int __usercall flist_sub@<eax>(token_type *p1@<eax>, int n@<edx>, int out_flag@<ecx>, int pos, int *highp, int *lowp)
{
  int v7; // esi

  v7 = flist_recurse(p1, n, out_flag, 0, pos, 1, highp, lowp);
  if ( out_flag )
    default_color();
  return v7;
}

//----- (0806FDB5) --------------------------------------------------------
int __cdecl flist_equation(int n)
{
  int v1; // edi
  int v2; // ebx
  int v3; // eax
  int v4; // edi
  int v5; // eax
  int *v6; // eax
  int v7; // edi
  unsigned int v8; // kr04_4
  int v9; // edi
  int width; // [esp+2Ch] [ebp-6Ch]
  int widtha; // [esp+2Ch] [ebp-6Ch]
  int min2_line; // [esp+30h] [ebp-68h] BYREF
  int max2_line; // [esp+34h] [ebp-64h] BYREF
  int min_line; // [esp+38h] [ebp-60h] BYREF
  int max_line; // [esp+3Ch] [ebp-5Ch] BYREF
  int low; // [esp+40h] [ebp-58h] BYREF
  int high; // [esp+44h] [ebp-54h] BYREF
  char buf[50]; // [esp+4Ah] [ebp-4Eh] BYREF
  unsigned int v20; // [esp+7Ch] [ebp-1Ch]

  v20 = __readgsdword(0x14u);
  high = 0;
  low = 0;
  width = 0;
  if ( n_lhs[n] > 0 )
  {
    min2_line = 0;
    max2_line = 0;
    min_line = 0;
    max_line = 0;
    v1 = __snprintf_chk(buf, 50, 1, 50, "#%d: ", n + 1);
    cur_line = 0;
    cur_pos = 0;
    v2 = n_rhs[n];
    widtha = v1 + flist_sub(lhs[n], n_lhs[n], 0, 0, &max_line, &min_line);
    v3 = 0;
    v4 = 0;
    if ( n_rhs[n] )
    {
      widtha += 3;
      while ( 1 )
      {
        v5 = flist_sub(rhs[n], v2, 0, 0, &high, &low);
        if ( !screen_columns || gfp != stdout || v5 + widtha < screen_columns || v2 <= 0 )
          break;
        if ( --v2 > 0 )
        {
          v6 = &rhs[n][v2].level;
          do
          {
            if ( *v6 == 1 && *(v6 - 1) == 2 && (unsigned int)v6[1] <= 5 && ((1 << *((_BYTE *)v6 + 4)) & 0x26) != 0 )
              break;
            --v2;
            v6 -= 4;
          }
          while ( v2 > 0 );
        }
      }
      v4 = v5;
      if ( high > max_line )
        max_line = high;
      if ( low < min_line )
        min_line = low;
      v3 = flist_sub(&rhs[n][v2], n_rhs[n] - v2, 0, 0, &max2_line, &min2_line);
    }
    v7 = widtha + v4;
    if ( v7 >= v3 )
      v3 = v7;
    width = v3;
    if ( screen_columns && gfp == stdout && v3 >= screen_columns )
    {
      width = list1_sub(n, 0);
      __fprintf_chk(gfp, 1, "\n");
    }
    else
    {
      __fprintf_chk(gfp, 1, "\n");
      for ( cur_line = max_line; min_line <= cur_line; --cur_line )
      {
        cur_pos = 0;
        if ( !cur_line )
          cur_pos += __fprintf_chk(gfp, 1, "%s", buf);
        v8 = strlen(buf) + 1;
        v9 = flist_sub(lhs[n], n_lhs[n], 1, v8 - 1, &high, &low);
        if ( n_rhs[n] )
        {
          if ( !cur_line )
            cur_pos += __fprintf_chk(gfp, 1, "%s", " = ");
          flist_sub(rhs[n], v2, 1, v8 - 1 + v9 + 3, &high, &low);
        }
        __fprintf_chk(gfp, 1, "\n");
      }
      if ( v2 < n_rhs[n] )
      {
        __fprintf_chk(gfp, 1, "\n");
        for ( cur_line = max2_line; min2_line <= cur_line; --cur_line )
        {
          cur_pos = 0;
          flist_sub(&rhs[n][v2], n_rhs[n] - v2, 1, 0, &high, &low);
          __fprintf_chk(gfp, 1, "\n");
        }
      }
      __fprintf_chk(gfp, 1, "\n");
    }
  }
  return width;
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8049224: using guessed type int __snprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, const char *, ...);

//----- (0807022B) --------------------------------------------------------
int __cdecl list_sub(int n)
{
  int result; // eax

  result = 0;
  if ( n_lhs[n] > 0 )
  {
    make_fractions_and_group(n);
    if ( factor_int_flag )
      factor_int_sub(n);
    if ( display2d )
      result = flist_equation(n);
    else
      result = list1_sub(n, 0);
  }
  return result;
}

//----- (08070286) --------------------------------------------------------
void reset_attr()
{
  if ( color_flag && cur_color >= 0 )
  {
    if ( html_flag )
      __printf_chk(1, "</font>");
    else
      __printf_chk(1, "\x1B[0m");
  }
  cur_color = -1;
  if ( fflush(0) )
    perror("fflush(3) call failed");
}
// 8048F34: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (08070300) --------------------------------------------------------
double __cdecl gcd(double d1, double d2)
{
  long double v2; // fst6
  long double v3; // fst5
  long double v4; // rt1
  long double v5; // fst5
  long double v6; // fst6
  long double v7; // fst7
  long double result; // fst7
  bool v9; // cc
  long double v10; // fst5
  long double v11; // rt0
  long double v12; // fst5
  long double v13; // fst6
  long double v14; // fst7
  long double v15; // fst5
  int v16; // ebx
  long double v17; // fst5
  char v19; // c2
  long double v20; // fst7
  long double v21; // fst5
  long double v22; // fst6
  double lower_limit; // [esp+10h] [ebp-18h]
  double divisor; // [esp+18h] [ebp-10h]

  if ( !__finite(d1) || !__finite(d2) )
    return 0.0;
  v2 = fabs(d2);
  v3 = fabs(d1);
  if ( v3 == 0.0 )
    return v2;
  v4 = v3;
  v5 = v2;
  v6 = v4;
  v7 = v5;
  if ( v5 == 0.0 )
    return v6;
  v9 = v6 <= v5;
  v10 = v6;
  if ( v6 > v7 )
    v10 = v7;
  divisor = v10;
  v11 = v10;
  v12 = v6;
  v13 = v11;
  if ( v9 )
    v12 = v7;
  v14 = v12;
  v15 = v12 * epsilon;
  lower_limit = v15;
  if ( v15 >= v13 || v14 >= 1.0e15 )
    return 0.0;
  v16 = 1;
  while ( 1 )
  {
    v17 = v14;
    do
      v17 = __FPREM__(v17, divisor);
    while ( v19 );
    v20 = fabs(v17);
    if ( lower_limit >= v20 || lower_limit >= fabs(divisor - v20) )
      break;
    if ( ++v16 == 50 )
      return 0.0;
    v22 = v20;
    v14 = divisor;
    divisor = v22;
  }
  v21 = v20;
  result = 0.0;
  if ( v21 == 0.0 || lower_limit * 100.0 < divisor )
    result = divisor;
  return result;
}
// 80703AA: variable 'v19' is possibly undefined

//----- (08070444) --------------------------------------------------------
double __cdecl gcd_verified(double d1, double d2)
{
  long double v2; // fst7
  long double v3; // fst6
  char v5; // c2
  long double v6; // fst6
  char v8; // c2
  double d4; // [esp+18h] [ebp-20h]
  double divisor; // [esp+28h] [ebp-10h]

  divisor = gcd(d1, d2);
  if ( divisor != 0.0 )
  {
    v2 = d1 / divisor;
    v3 = v2;
    do
      v3 = __FPREM__(v3, 1.0);
    while ( v5 );
    if ( v3 != 0.0 )
      goto LABEL_10;
    d4 = d2 / divisor;
    v6 = d4;
    do
      v6 = __FPREM__(v6, 1.0);
    while ( v8 );
    if ( v6 == 0.0 )
    {
      if ( gcd(v2, d4) != 1.0 )
        divisor = 0.0;
    }
    else
    {
LABEL_10:
      divisor = 0.0;
    }
  }
  return divisor;
}
// 8070487: variable 'v5' is possibly undefined
// 80704C7: variable 'v8' is possibly undefined

//----- (08070529) --------------------------------------------------------
double __cdecl my_round(double d1)
{
  long double v1; // fst7
  double d1_0[2]; // [esp+18h] [ebp-10h] BYREF

  d1_0[0] = d1;
  v1 = d1;
  if ( d1 < 0.0 )
    modf(v1 - 0.5, d1_0);
  else
    modf(v1 + 0.5, d1_0);
  return d1_0[0];
}

//----- (0807057D) --------------------------------------------------------
int __cdecl f_to_fraction(double d, double *numeratorp, double *denominatorp)
{
  long double v3; // fst6
  char v5; // c2
  int result; // eax
  long double v7; // fst7
  long double v8; // fst7
  double numerator; // [esp+18h] [ebp-20h]
  double denominator; // [esp+20h] [ebp-18h]
  double denominatora; // [esp+20h] [ebp-18h]
  double denominatorb; // [esp+20h] [ebp-18h]

  *numeratorp = d;
  *denominatorp = 1.0;
  if ( !__finite(d) )
    return 0;
  v3 = d;
  do
    v3 = __FPREM__(v3, 1.0);
  while ( v5 );
  result = 1;
  if ( v3 != 0.0 )
  {
    denominator = small_epsilon;
    v7 = my_round(d);
    if ( v7 != 0.0 && fabs(d) * denominator >= fabs(v7 - d) )
    {
      *numeratorp = v7;
      return 1;
    }
    denominatora = gcd(1.0, d);
    if ( denominatora > (long double)epsilon )
    {
      numerator = my_round(d / denominatora);
      denominatorb = my_round(1.0 / denominatora);
      if ( fabs(numerator) < 1.0e12 && denominatorb < 1.0e12 && denominatorb >= 2.0 )
      {
        v8 = gcd(numerator, denominatorb);
        if ( v8 > 1.0 )
        {
          numerator = numerator / v8;
          denominatorb = denominatorb / v8;
        }
        if ( fabs(numerator / denominatorb - d) <= fabs(numerator / denominatorb) * small_epsilon )
        {
          *numeratorp = numerator;
          *denominatorp = denominatorb;
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}
// 80705B1: variable 'v5' is possibly undefined

//----- (08070715) --------------------------------------------------------
int __cdecl make_fractions(token_type *equation, int *np)
{
  int v3; // ebx
  token_type *v4; // esi
  token_type *v5; // eax
  int v6; // edx
  int v7; // eax
  bool v8; // zf
  _BOOL4 v9; // eax
  int v10; // ecx
  token_type *v11; // eax
  int v12; // ebx
  int v13; // esi
  token_type *v14; // edi
  token_type *v15; // eax
  token_type *v16; // eax
  int v17; // eax
  token_type *v18; // edx
  int *v19; // esi
  int v20; // edx
  token_type *v22; // [esp+14h] [ebp-44h]
  int v23; // [esp+18h] [ebp-40h]
  int v24; // [esp+1Ch] [ebp-3Ch]
  int inc_level; // [esp+20h] [ebp-38h]
  token_type *inc_levela; // [esp+20h] [ebp-38h]
  int modified; // [esp+24h] [ebp-34h]
  int modifieda; // [esp+24h] [ebp-34h]
  int v29; // [esp+28h] [ebp-30h]
  token_type *v30; // [esp+28h] [ebp-30h]
  int v31; // [esp+2Ch] [ebp-2Ch]
  double denominator; // [esp+30h] [ebp-28h] BYREF
  double numerator[4]; // [esp+38h] [ebp-20h] BYREF

  v3 = 0;
  modified = 0;
  while ( *np > v3 )
  {
    v31 = v3;
    v4 = &equation[v3];
    if ( v4->kind )
      goto LABEL_37;
    v29 = v4->level;
    if ( v3 > 0 )
    {
      v5 = &equation[v3 - 1];
      if ( v5->level == v4->level && v5->token.variable == 4 )
        goto LABEL_37;
    }
    if ( !f_to_fraction(v4->token.constant, numerator, &denominator) )
      goto LABEL_37;
    if ( denominator == 1.0 )
    {
      v4->token.constant = numerator[0];
    }
    else
    {
      if ( *np + 2 > n_tokens )
        error_huge();
      v6 = *np;
      inc_level = *np > 1;
      if ( *np <= v3 + 1 )
        goto LABEL_32;
      v24 = equation[v3 + 1].level;
      if ( v24 != v29 )
        goto LABEL_32;
      v7 = equation[v3 + 1].token.variable;
      if ( v7 != 3 )
      {
        v8 = v7 == 4;
        v9 = 0;
        if ( !v8 )
          v9 = *np > 1;
        inc_level = v9;
LABEL_32:
        memmove(&equation[v3 + 3], &equation[v3 + 1], 16 * (~v3 + v6));
        *np += 2;
        v4->token.constant = numerator[0];
        v16 = &equation[v3 + 1];
        v16->level = v29;
        v16->kind = OPERATOR;
        v16->token.variable = 4;
        v17 = v3 + 2;
        v18 = &equation[v3 + 2];
        v18->level = v29;
        v18->kind = CONSTANT;
        v18->token.constant = denominator;
        if ( inc_level && v3 <= v17 )
        {
          v19 = &v4->level;
          v20 = v3;
          do
          {
            ++*v19;
            ++v20;
            v19 += 4;
          }
          while ( v17 >= v20 );
        }
LABEL_36:
        modified = 1;
        goto LABEL_37;
      }
      modifieda = v3 + 3;
      if ( v6 > v3 + 3 )
      {
        inc_levela = &equation[v3 + 3];
        v10 = inc_levela->level;
        if ( v29 <= v10 )
        {
          v11 = &equation[v3 + 5];
          v23 = v3;
          v12 = v3 + 3;
          v22 = v4;
          v13 = v29;
          v30 = equation;
          v14 = inc_levela;
          while ( 1 )
          {
            if ( v13 == v10 && v14->token.variable == 4 )
            {
              modifieda = v12;
              v3 = v23;
              v4 = v22;
              equation = v30;
              goto LABEL_27;
            }
            v12 += 2;
            if ( v6 <= v12 )
              break;
            v14 = v11;
            v10 = v11->level;
            v11 += 2;
            if ( v13 > v10 )
            {
              modifieda = v12;
              v3 = v23;
              v4 = v22;
              equation = v30;
              goto LABEL_27;
            }
          }
          modifieda = v12;
          v3 = v23;
          v4 = v22;
          equation = v30;
        }
      }
LABEL_27:
      if ( numerator[0] == 1.0 )
      {
        memmove(v4, &equation[v31 + 2], 16 * (modifieda - v3 - 2));
        modifieda -= 2;
      }
      else
      {
        v4->token.constant = numerator[0];
        memmove(&equation[modifieda + 2], &equation[modifieda], 16 * (*np - modifieda));
        *np += 2;
      }
      v15 = &equation[modifieda];
      v15->level = v24;
      v15->kind = OPERATOR;
      v15->token.variable = 4;
      ++v15;
      v15->level = v24;
      v15->kind = CONSTANT;
      v15->token.constant = denominator;
      if ( numerator[0] != 1.0 )
        goto LABEL_36;
      v3 -= 2;
      modified = 1;
    }
LABEL_37:
    v3 += 2;
  }
  return modified;
}

//----- (08070A10) --------------------------------------------------------
long double multiply_out_unique()
{
  int v0; // ecx
  long double result; // fst7
  int i; // eax
  int v3; // edx

  if ( uno <= 0 )
    return 1.0;
  v0 = 0;
  result = 1.0;
  do
  {
    v3 = ucnt[v0];
    if ( v3 > 0 )
    {
      for ( i = 0; i != v3; ++i )
        result = result * unique[v0];
    }
    ++v0;
  }
  while ( v0 != uno );
  return result;
}

//----- (08070A5D) --------------------------------------------------------
_BOOL4 is_prime()
{
  _BOOL4 result; // eax

  if ( multiply_out_unique() >= 2.0 && uno == 1 )
    result = ucnt[0] == 1;
  else
    result = 0;
  return result;
}

//----- (08070A90) --------------------------------------------------------
int __usercall fc_recurse@<eax>(token_type *equation@<eax>, int *np@<edx>, int loc@<ecx>, int level, int level_code)
{
  int v5; // ebx
  int v7; // eax
  int *v8; // edx
  int v9; // ebx
  int v10; // eax
  unsigned int v11; // eax
  long double v12; // fst7
  long double v13; // fst6
  int v14; // eax
  int v15; // eax
  long double v16; // fst6
  long double v17; // fst5
  int v18; // ebx
  token_type *v19; // ecx
  int v20; // edx
  int v21; // eax
  int v22; // esi
  int *v23; // esi
  int v24; // edi
  int v25; // eax
  storage_type *v26; // ebx
  long double v27; // fst6
  int v28; // eax
  long double v29; // fst6
  long double v30; // fst5
  int v31; // eax
  int v32; // edi
  int v33; // eax
  long double v34; // fst6
  int i; // esi
  token_type *v36; // eax
  long double v37; // fst6
  char v39; // c2
  long double v40; // fst6
  char v42; // c2
  int v43; // eax
  int *v44; // edx
  int v45; // esi
  long double v46; // fst6
  int v47; // eax
  token_type *v48; // edx
  int v49; // ebx
  int *v50; // eax
  int *v51; // edx
  int v52; // esi
  token_type *v53; // esi
  token_type *v54; // eax
  int v55; // ecx
  int v56; // edx
  int v57; // ebx
  int v58; // esi
  token_type *v59; // esi
  int improve_readability; // [esp+14h] [ebp-74h]
  int op_count; // [esp+1Ch] [ebp-6Ch]
  int const_count; // [esp+20h] [ebp-68h]
  int v64; // [esp+24h] [ebp-64h]
  int gcd_flag; // [esp+28h] [ebp-60h]
  int v66; // [esp+30h] [ebp-58h]
  int neg_flag; // [esp+34h] [ebp-54h]
  int v68; // [esp+38h] [ebp-50h]
  int first; // [esp+3Ch] [ebp-4Ch]
  double minimum; // [esp+40h] [ebp-48h]
  double minimuma; // [esp+40h] [ebp-48h]
  token_type *v72; // [esp+4Ch] [ebp-3Ch]
  int v73; // [esp+50h] [ebp-38h]
  token_type *v74; // [esp+50h] [ebp-38h]
  int v76; // [esp+5Ch] [ebp-2Ch]
  int v77; // [esp+60h] [ebp-28h]
  int v78; // [esp+60h] [ebp-28h]
  int v79; // [esp+64h] [ebp-24h]
  double v80; // [esp+68h] [ebp-20h]
  token_type *v81; // [esp+68h] [ebp-20h]

  v72 = equation;
  v68 = loc;
  v5 = loc;
  v66 = 0;
  while ( v5 < *np )
  {
    v10 = equation[v5].level;
    if ( v10 < level )
      break;
    if ( v10 <= level )
    {
      v7 = v5 + 1;
    }
    else
    {
      v66 |= fc_recurse(equation, np, v5, level + 1, level_code);
      v7 = v5 + 1;
      if ( v5 + 1 < *np && level < equation[v7].level )
      {
        v8 = &equation[v5 + 3].level;
        do
        {
          v7 += 2;
          if ( v7 >= *np )
            break;
          v9 = *v8;
          v8 += 8;
        }
        while ( level < v9 );
      }
    }
    v5 = v7;
  }
  if ( v66 )
    return 1;
  v11 = level_code & 3;
  improve_readability = 1;
  if ( v11 <= 1 && (improve_readability = level == 1 && v11 != 0, level != 1 || v11 == 0)
    || (gcd_flag = 1, !integer_coefficients) )
  {
    gcd_flag = ((unsigned int)level_code >> 2) & 1;
  }
  v77 = v68;
  const_count = 0;
  op_count = 0;
  neg_flag = 1;
  first = 1;
  v12 = 1.0;
  minimum = 1.0;
  while ( 1 )
  {
    v32 = *np;
    if ( v77 >= *np )
      break;
    v74 = &v72[v77];
    v33 = v74->level;
    if ( level > v33 )
      break;
    if ( level == v33 )
    {
      if ( v74->kind == CONSTANT )
      {
        ++const_count;
        v13 = v74->token.constant;
        goto LABEL_31;
      }
      if ( v74->kind == OPERATOR )
      {
        v14 = v74->token.variable;
        if ( v14 == 1 )
        {
          neg_flag = 0;
        }
        else if ( v14 != 2 )
        {
          return 0;
        }
        ++op_count;
        ++v77;
      }
      else
      {
        v13 = 1.0;
LABEL_31:
        if ( v77 == v68 )
        {
          v15 = 0;
          if ( v13 <= 0.0 )
            v15 = neg_flag;
          neg_flag = v15;
        }
        v16 = fabs(v13);
        if ( first )
        {
          v12 = v16;
          minimum = v16;
          first = 0;
        }
        else
        {
          v17 = minimum;
          if ( minimum > v16 )
            v17 = v16;
          minimum = v17;
          if ( gcd_flag && v12 != 0.0 )
            v12 = gcd_verified(v16, v12);
        }
        ++v77;
      }
    }
    else
    {
      v18 = v77 + 1;
      if ( v32 <= v77 + 1 )
        goto LABEL_71;
      v19 = &v72[v18];
      v20 = v19->level;
      if ( level >= v20 )
        goto LABEL_71;
      v21 = (int)&v72[v77 + 3];
      v22 = 0;
      do
      {
        if ( v20 == level + 1 )
          v22 = v19->token.variable;
        v18 += 2;
        if ( v32 <= v18 )
          break;
        v19 = (token_type *)v21;
        v20 = *(_DWORD *)(v21 + 4);
        v21 += 32;
      }
      while ( level < v20 );
      v76 = v18;
      if ( (unsigned int)(v22 - 3) > 1 )
        goto LABEL_71;
      if ( v77 < v18 )
      {
        v23 = &v74->level;
        v24 = v77;
        v73 = v18;
        v25 = v77;
        v64 = v18;
        v26 = &v72[v77 - 1].token;
        do
        {
          if ( *v23 == level + 1 && !*(v23 - 1) )
          {
            if ( v25 == v76 || v24 > v25 && v26->variable != 3 )
              return 0;
            v27 = *(double *)(v23 + 1);
            if ( v25 == v68 )
            {
              v28 = 0;
              if ( v27 <= 0.0 )
                v28 = neg_flag;
              neg_flag = v28;
            }
            v29 = fabs(v27);
            if ( first )
            {
              v12 = v29;
              minimum = v29;
              v25 = v73;
              first = 0;
            }
            else
            {
              v30 = minimum;
              if ( minimum > v29 )
                v30 = v29;
              minimum = v30;
              if ( !gcd_flag || v12 == 0.0 )
              {
                v25 = v73;
              }
              else
              {
                v12 = gcd_verified(v29, v12);
                v25 = v73;
              }
            }
          }
          ++v24;
          v23 += 4;
          v26 += 2;
        }
        while ( v76 > v24 );
        v77 = v25;
        v18 = v64;
      }
      if ( v77 != v76 )
      {
LABEL_71:
        v31 = 0;
        if ( v77 != v68 )
          v31 = neg_flag;
        neg_flag = v31;
        if ( first )
        {
          v77 = v18;
          first = 0;
          v12 = 1.0;
          minimum = 1.0;
        }
        else
        {
          if ( minimum > 1.0 )
            minimum = 1.0;
          if ( !gcd_flag || v12 == 0.0 )
          {
            v77 = v18;
          }
          else
          {
            v12 = gcd_verified(1.0, v12);
            v77 = v18;
          }
        }
      }
    }
  }
  if ( gcd_flag )
  {
    v34 = minimum;
    if ( 0.0 != v12 )
      v34 = v12;
    minimum = v34;
  }
  if ( !first && op_count && const_count <= 1 && (neg_flag || minimum != 1.0) && minimum != 0.0 && __finite(minimum) )
  {
    if ( improve_readability )
    {
      for ( i = v68; ; i = v43 + 1 )
      {
        v36 = &v72[i];
        if ( v36->kind == CONSTANT
          && ((v78 = v36->level, v78 == level)
           || i + 1 < *np
           && v78 == level + 1
           && v78 == v72[i + 1].level
           && (unsigned int)(v72[i + 1].token.variable - 3) <= 1) )
        {
          v80 = v36->token.constant;
        }
        else
        {
          v80 = 1.0;
        }
        if ( !gcd_flag && minimum >= 1.0 )
        {
          minimum = 1.0;
          goto LABEL_124;
        }
        if ( minimum < 1.0 )
        {
          v37 = v80;
          do
            v37 = __FPREM__(v37, 1.0);
          while ( v39 );
          if ( v37 == 0.0 )
            goto LABEL_123;
        }
        v40 = v80;
        do
          v40 = __FPREM__(v40, minimum);
        while ( v42 );
        if ( v40 != 0.0 )
        {
LABEL_123:
          minimum = 1.0;
          goto LABEL_124;
        }
        v43 = i + 1;
        if ( i + 1 >= *np )
          goto LABEL_124;
        if ( level < v72[v43].level )
          break;
LABEL_151:
        if ( level > v72[v43].level )
          goto LABEL_124;
      }
      v44 = &v72[i + 3].level;
      while ( 1 )
      {
        v43 += 2;
        if ( v43 >= *np )
          break;
        v45 = *v44;
        v44 += 8;
        if ( level >= v45 )
          goto LABEL_151;
      }
    }
LABEL_124:
    v46 = minimum;
    if ( neg_flag )
      v46 = -minimum;
    minimuma = v46;
    if ( v46 != 1.0 )
    {
      if ( *np + 2 * op_count + 4 > n_tokens )
        error_huge();
      v47 = *np;
      if ( v68 >= *np )
        goto LABEL_147;
      v48 = &v72[v68];
      v81 = v48;
      if ( level > v48->level )
        goto LABEL_147;
      v49 = v68;
      v79 = level + 1;
      do
      {
        if ( v48->kind != OPERATOR )
        {
          v50 = &v72[v49].level;
          v51 = &v72[v49 + 1].level;
          do
          {
            ++*v50;
            if ( ++v49 >= *np )
              break;
            v52 = *v51;
            v50 += 4;
            v51 += 4;
          }
          while ( level < v52 );
          v53 = &v72[v49];
          memmove(&v53[2], v53, 16 * (*np - v49));
          *np += 2;
          v53->level = v79;
          v53->kind = OPERATOR;
          v53->token.variable = 4;
          v54 = &v72[++v49];
          v54->level = v79;
          v54->kind = CONSTANT;
          v54->token.constant = minimuma;
        }
        ++v49;
        v47 = *np;
        if ( *np <= v49 )
          break;
        v48 = &v72[v49];
      }
      while ( level <= v48->level );
      if ( v47 > v68 && (v55 = v81->level, level <= v55) )
      {
        v56 = (int)&v72[v68 + 1];
        v57 = v68;
        v58 = (int)v81;
        do
        {
          *(_DWORD *)(v58 + 4) = v55 + 1;
          ++v57;
          v47 = *np;
          if ( *np <= v57 )
            break;
          v58 = v56;
          v55 = *(_DWORD *)(v56 + 4);
          v56 += 16;
        }
        while ( level <= v55 );
      }
      else
      {
LABEL_147:
        v57 = v68;
      }
      v59 = &v72[v57];
      memmove(&v59[2], v59, 16 * (v47 - v57));
      *np += 2;
      v59->level = level;
      v59->kind = OPERATOR;
      v59->token.variable = 3;
      v59[1].level = level;
      v59[1].kind = CONSTANT;
      v59[1].token.constant = minimuma;
      v66 = 1;
    }
  }
  return v66;
}
// 8070F6F: variable 'v39' is possibly undefined
// 8070FB0: variable 'v42' is possibly undefined

//----- (0807122F) --------------------------------------------------------
int __cdecl factor_constants(token_type *equation, int *np, int level_code)
{
  int result; // eax

  result = 0;
  if ( level_code != 3 )
    result = fc_recurse(equation, np, 0, 1, level_code);
  return result;
}

//----- (0807125F) --------------------------------------------------------
void display_unique()
{
  long double v0; // fst7
  int v1; // ebx

  v0 = multiply_out_unique();
  __fprintf_chk(gfp, 1, "%.0f = ", (double)v0);
  v1 = 0;
  while ( v1 < uno )
  {
    __fprintf_chk(gfp, 1, "%.0f", unique[v1]);
    if ( ucnt[v1] > 1 )
      __fprintf_chk(gfp, 1, "^%d", ucnt[v1]);
    if ( ++v1 < uno )
      __fprintf_chk(gfp, 1, " * ");
  }
  __fprintf_chk(gfp, 1, "\n");
}
// 8048F04: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08071341) --------------------------------------------------------
void __cdecl try_factor(double arg)
{
  int v1; // eax
  long double v2; // fst7
  long double v3; // fst5
  char v5; // c2

  do
  {
    v3 = nn;
    do
      v3 = __FPREM__(v3, arg);
    while ( v5 );
    if ( v3 != 0.0 )
      break;
    v1 = uno;
    if ( uno > 0 && unique[uno - 1] == arg )
    {
      ++ucnt[uno - 1];
    }
    else
    {
      unique[uno] = arg;
      ucnt[v1] = 1;
      uno = v1 + 1;
    }
    v2 = nn / arg;
    nn = v2;
    vv = sqrt(fabs(v2)) + 1.0;
  }
  while ( v2 > 1.0 || v2 < -1.0 );
}
// 80713DC: variable 'v5' is possibly undefined

//----- (08071415) --------------------------------------------------------
int __cdecl factor_one(double value)
{
  long double v1; // fst6
  char v3; // c2
  int i; // ebx
  long double v5; // fst7
  int result; // eax
  double d; // [esp+18h] [ebp-10h]

  uno = 0;
  nn = value;
  if ( value == 0.0 )
    return 0;
  if ( fabs(value) >= 1.0e15 )
    return 0;
  v1 = value;
  do
    v1 = __FPREM__(v1, 1.0);
  while ( v3 );
  if ( v1 != 0.0 )
    return 0;
  vv = sqrt(fabs(nn)) + 1.0;
  try_factor(2.0);
  try_factor(3.0);
  try_factor(5.0);
  try_factor(7.0);
  d = 1.0;
  while ( vv >= (long double)d )
  {
    for ( i = 0; i != 48; ++i )
    {
      d = d + skip_multiples[i];
      try_factor(d);
    }
  }
  if ( nn != 1.0 )
    try_factor(nn);
  v5 = multiply_out_unique();
  result = 1;
  if ( v5 != value )
    error_bug("Internal error factoring integers.");
  return result;
}
// 8071462: variable 'v3' is possibly undefined

//----- (0807157C) --------------------------------------------------------
int __cdecl factor_int(token_type *equation, int *np)
{
  int i; // ebx
  token_type *v3; // esi
  int v4; // edx
  int v5; // eax
  int v6; // ecx
  int v7; // edi
  int v8; // esi
  int v9; // ebx
  token_type *v10; // eax
  token_type *v11; // eax
  token_type *v12; // eax
  token_type *v13; // eax
  int level; // [esp+14h] [ebp-24h]
  int v16; // [esp+18h] [ebp-20h]
  int modified; // [esp+1Ch] [ebp-1Ch]

  modified = 0;
  for ( i = 0; *np > i; i += 2 )
  {
    v3 = &equation[i];
    if ( v3->kind == CONSTANT && factor_one(v3->token.constant) && uno > 0 )
    {
      if ( uno != 1 )
      {
        level = v3->level;
        if ( uno > 1 )
          level += *np >= 2;
        goto LABEL_10;
      }
      if ( ucnt[0] > 1 )
      {
        level = v3->level;
LABEL_10:
        v4 = -2;
        v5 = 0;
        do
        {
          v6 = v4 + 4;
          v4 += 2;
          if ( ucnt[v5] >= 2 )
            v4 = v6;
          ++v5;
        }
        while ( v5 != uno );
        if ( *np + v4 > n_tokens )
          error_huge();
        v7 = 0;
        v16 = level + 1;
        v8 = i;
        do
        {
          v9 = 2 * (ucnt[v7] > 1) + 2;
          if ( !v7 )
            v9 = 2 * (ucnt[0] > 1);
          if ( v9 > 0 )
          {
            memmove(&equation[v9 + v8], &equation[v8], 16 * (*np - v8));
            *np += v9;
            if ( v7 > 0 )
            {
              v10 = &equation[v8 + 1];
              v10->kind = OPERATOR;
              v10->level = level;
              v10->token.variable = 3;
              v8 += 2;
            }
          }
          v11 = &equation[v8];
          v11->kind = CONSTANT;
          v11->level = level;
          v11->token.constant = unique[v7];
          if ( ucnt[v7] > 1 )
          {
            v11->level = v16;
            v12 = &equation[v8 + 1];
            v12->kind = OPERATOR;
            v12->level = v16;
            v12->token.variable = 6;
            v8 += 2;
            v13 = &equation[v8];
            v13->level = v16;
            v13->kind = CONSTANT;
            v13->token.constant = (double)ucnt[v7];
          }
          ++v7;
        }
        while ( uno > v7 );
        i = v8;
        modified = 1;
        continue;
      }
    }
  }
  return modified;
}

//----- (08071777) --------------------------------------------------------
int __cdecl list_factor(token_type *equation, int *np, int factor_flag)
{
  if ( factor_flag || factor_int_flag )
    factor_int(equation, np);
  return list_proc(equation, *np, 0);
}

//----- (080717C4) --------------------------------------------------------
void __cdecl factor_int_sub(int n)
{
  if ( n_lhs[n] > 0 )
  {
    factor_int(lhs[n], &n_lhs[n]);
    factor_int(rhs[n], (int *)(4 * n + 134715712));
  }
}

//----- (08071820) --------------------------------------------------------
void _libc_csu_fini(void)
{
  ;
}

//----- (08071830) --------------------------------------------------------
void _libc_csu_init(void)
{
  init_proc();
}

//----- (08071890) --------------------------------------------------------
void (*_do_global_ctors_aux())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    v1 = (void (**)(void))&_CTOR_LIST__;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 8078EFC: using guessed type int _CTOR_LIST__;

//----- (080718BC) --------------------------------------------------------
void term_proc()
{
  _do_global_dtors_aux();
}

// nfuncs=435 queued=300 decompiled=300 lumina nreq=0 worse=0 better=0
// ALL OK, 300 function(s) have been successfully decompiled
